\section{On \Cref{sec:cc_transform} (\nameref{sec:cc_transform})}

In this section, we provide the proofs omitted from \Cref{sec:cc_transform} of the main body, as well as an extended discussion of PQ-trees and clone-aware axioms. 

\subsection{Extended discussion of clone structures and PQ-trees}\label{subsec:extended_pqtrees}
Here, we expand on our discussion of the PQ-trees, first defined by \citet{Booth76:Testing} and later used by \citet{Elkind10:Clone} for representing clone sets. For the full set of formal definitions, see \citet{Elkind10:Clone}. 

Given $\profile$ we can use a PQ-tree to represent its \emph{clone structure} $\family(\profile) \subseteq \mathcal{P}(\cand)$, which is the collection of \textit{all} clone sets on $\profile$. For example, if $\profile$ is the profile from \Cref{fig:eg_prof}, then $\family(\profile)=\{\{a\},\{b\}, \{c\}, \{d\}, \{b,c\}, \{a,b,c,d\}\}$.
Given a set of candidates $\cand=\{a_i\}_{i \in [m]}$, a PQ-tree $T$ over $\cand$ is an ordered tree where the leaves of the tree correspond to a particular permutation of the elements of $\cand$.
Each internal node is either of ``type P'' or of ``type Q''. 
If a node is of type P, then its children can be permuted arbitrarily. 
If a node is of type Q, then the only allowable operation is the reversal of its children's order.

\citet{Elkind10:Clone} begin by defining two special types of clone structures: a \emph{maximal} clone structure (which they also call a \emph{string of sausages}) and a \emph{minimal} clone structure (also called a \emph{fat sausage}). 
A string of sausages corresponds to the clone structure that arises when all rankings in the profile $\profile$ consist of a single linear order (WLOG, $\sigma_1 : a_1 \succ a_2 \succ \cdots \succ a_m$) or its reversal. Then $\family(\profile) = \{ \{a_k\}_{i \leq j}: i \leq j\}$, meaning that the clone structure contains all intervals of candidates in $\sigma_1$. The \emph{majority ranking} of the Q-node is $\sigma_1$ or its reverse, depending on which one appears more in $\profile$. The ``opposite'' scenario (a fat sausage) is when $\family(\profile') = \{A\} \cup \{\{a_i\}\}_{i \in [m]}$, meaning we only have the trivial clone sets in our structure. This arises, for example, when $\profile'$ corresponds to a cyclic profile on $A$, \emph{i.e.}, $\profile' = (\sigma_1', \ldots, \sigma'_m)$, and the preferences of the $i$-th voter are given by $\sigma'_i : a_i \succ_{\sigma_i} a_{i+1} \succ_{\sigma_i} \cdots \succ_{\sigma_i} a_m \succ_{\sigma_i} a_1 \succ_{\sigma_i} \cdots \succ_{\sigma{i}} a_{i-1}$.

We need a few more definitions before describing the construction of the PQ-tree.
Let $\mathcal{F}$ be a family of subsets on a finite set $F$, and likewise $\mathcal{E}$ for $E$, where $F \cap E = \emptyset$.
Then, we can \emph{embed} $\mathcal{F}$ into $\mathcal{E}$ as follows: given $e \in E$, we replace each set $X$ containing $e$ with $(X \setminus \{e\}) \cup F$. 
The resulting family of subsets is denoted by $\mathcal{E}(e \rightarrow \mathcal{F})$.
The inverse operation of embedding is called \emph{collapsing}; note that for a family of subsets $\family$ on $A$ to be collapsible, it should contain a set that does not intersect non-trivially (\emph{i.e.}, not as a sub/superset) with any other set in $\family$), which motivates the definition of a \emph{proper subfamily} of $\mathcal{F}$:

\begin{definition}\label{def:irreducible}
Let $\mathcal{F}$ be a family of subsets on a finite set $F$. A subset $\mathcal{E} \subseteq \mathcal{F}$ is called a \emph{proper subfamily} of $\mathcal{F}$ if there is a set $E \in \mathcal{F}$ such that (i) $\mathcal{E} = \{F \in \mathcal{F} \mid F \subseteq E\}$; (ii) for any $X \in \mathcal{F} \setminus \mathcal{E}$, either $E \subseteq X$ or $X \cap E = \varnothing$, (iii) $E$ is a proper subset of $F$. 
A family of subsets with no proper subfamily is called \emph{irreducible.}
\end{definition}

The key result that we require in the construction of a PQ-tree is that \emph{any irreducible clone structure is either a fat sausage or a string of sausages}   \cite[Thm. 3.10]{Elkind10:Clone}.
Given a clone structure $\family \subseteq \mathcal{P}(\cand)$, we construct its corresponding PQ-tree $T(\family)$ iteratively:
\begin{enumerate}
    \item Pick some non-singleton, irreducible minimal set of clones  $\mathcal{E}_1 \subseteq \family$. By \Cref{def:irreducible}, there exists $C_1 \in \family$ such that $\mathcal{E}_1 = \{F \in \mathcal{F} \mid F \subseteq C_1\}$. 
    \item Update $\family$ to $\family(\mathcal{E}_1 \rightarrow C_1)$, \emph{i.e.}, substitute all appearances of the members of $C_1$ in $\family$ by a meta-candidate $C_1$, and remove the sets in $\family$ that correspond to subsets of $C_1$. Since $C_1$ is either a subset of a superset of each $K \in \family$ is overlaps with, this transformation is well-defined.
    \item Build the subtree for $C_1$. By Theorem 3.10 in \citet{Elkind10:Clone}, $C_1$ is either a fat sausage or a string of sausages.
    If it is a fat sausage, then $C_1$ is set to be of type P- and label it as the $\odot$-product of the candidates in $C_1$. If $|C_1|=2$, then it is both a fat sausage and a string of sausages. 
    In this case, we treat it as a string of sausages sausage (following the convention by \citet{Elkind10:Clone}).
    The candidates in $C_1$ are placed as the children leaves in the subtree.
    If it is a string of sausages, then $C_1$ is of type Q-, and we label it as the $\oplus$-product of the candidates in $C_1$.
    The candidates in $C_1$ are similarly placed as the children leaves in the subtree, following the order dictated by $C_1$.
    \item We repeat the previous three steps for $C_i$, with $i=2,\ldots$,  until we cannot find any non-singleton, irreducible, minimal set. For any child node of $C_i$ that corresponds to a previously-collapsed subset $C_j$ with $j<i$, the node is replaced with the subtree of $C_j$, already constructed by assumption. For child nodes of $C_i$ that correspond to original candidates from $A$, the node is a leaf.
    \item Eventually, no proper irreducible subfamilies are left, and all of the remaining candidates form either a string of sausages or a fat sausage, so we place them as children of the root of $T(\family)$, similarly labeling it as type P or Q. 
\end{enumerate}

The order in which we choose $C_i$ does not impact the final construction, as the irreducible proper subsets of a clone structure $\family$ is non-overlapping \cite[Proposition 4.2.]{Elkind10:Clone}, implying a unique decomposition of candidates into irreducible proper subsets at each step. This ensures that the PQ-tree of a preference profile is unique~\citep{Karpov19:Group}.

\subsection{Discussion of PQ-tree algorithms}\label{sec:app:pq-trees}

The original PQ-tree algorithm is due to Booth and Luecker, who introduced it as a way to represent a family of permutations on a set of elements~\citep{Booth76:Testing}.
Later, \citet{Elkind10:Clone} showed its use in the context of computational social choice.
Cornaz, Galand, and Spanjaard carefully analyze the Booth and Luecker algorithm in the context of voting rules and establish the runtime of $O(nm^3)$ that we use in Lemma~\ref{lemma:pq-poly}~\citep{Cornaz13:Kemeny}.
In this section, we provide some more context on the general relationship between PQ-tree constructions (and tournament decomposition tree constructions) with the graph theoretic literature on modular tree decomposition (particularly with the modular tree decomposition algorithm by \citet{Capelle02:Graph}, following the observations made by \citet{Brandt11:Fixed}.

\citet{Brandt11:Fixed} study CC tournament solutions, following the definition of composition consistency for tournaments first given by~\citep{Laffond96:Composition}.
They provide a \emph{decomposition tree of a tournament} $T$ meant for efficiently implementing CC tournament solutions.
In their analysis, they use what they call the \emph{decomposition degree} of a tournament, which is a parameter that reflects its decomposability (the lower the degree, the better well-behaved its decomposition).
Their decomposition tree is the tournament version of the PQ-tree construction of \citet{Elkind10:Clone}: both use trees with two different types of internal nodes as a suitable way of representing clone structures.
The correspondence between the two constructions is the following:
\begin{enumerate}
    \item \citet{Elkind10:Clone} use a PQ-tree to represent clone structures given a profile $\profile$, while \citet{Brandt11:Fixed} use a decomposition tree to represent components (Definition~\ref{appdef:component_tour}) given a tournament $T$.
    \item \citet{Elkind10:Clone} divide the internal nodes into types P and Q, whereas \citet{Brandt18:Extending} calls them \emph{irreducible} and \emph{reducible}, respectively (but the definition is the same one).
\end{enumerate}

Besides the naming of the internal nodes and the difference between having a profile $\sigma$ versus a tournament $T$ as input, given the equivalence between components in $T$ and clones in $\sigma$, \citet{Brandt18:Extending}'s definition of a decomposition tree of $T$ is equivalent to \citet{Elkind10:Clone}'s definition of a PQ-tree for $\sigma$.
In particular, claims relating to the running time required to compute a decomposition tree of a tournament can be transferred to the running time required to compute PQ-trees.

\citet{Brandt18:Extending} make the following two observations about the running time required to compute the decomposition tree of a tournament $T$:
\begin{enumerate}
    \item First, we compute a \emph{factorization permutation} of $T$, which is a permutation of the alternatives in $A$ such that each component of $T$ is a contiguous interval in the permutation.
    \citet{McConnell05:Linear} provide a linear time algorithm for computing a factorizing permutation of a tournament in linear time
    \item Second, given $T$ and a factorization permutation of $T$, we can use the graph theoretic algorithm by \citet{Capelle02:Graph} to obtain the decomposition tree of $T$.
\end{enumerate}

In our settings of profiles, we can adapt the running time argument from~\citep{Brandt18:Extending} as follows:
\begin{enumerate}
    \item In the case of profiles $\profile$, we do not need to do more work to compute the factorization permutation of $T$; we can read it directly from $\profile$ (from any one voter's ranking).
    By definition of a clone set, \emph{every} voter ranks the members of a clone set continguously in their ranking. 
    Therefore, every single voter's ranking is a factorization permutation of $\profile$.
    Thus, computing the factorization permutation requires $O(|A|)$ running time.
    \item The graph theoretic algorithm \citet{Capelle02:Graph} that \citet{Brandt18:Extending} use for computing decomposition tree tournaments is not directly related to tournaments (or to computational social choice).
    Rather, \citet{Capelle02:Graph} deal with a broad definition of a \emph{modular decomposition} of a directed graph.
    Zooming out from tournaments, for a given graph $G=(V, E)$, a decomposition tree $T_G$ is such that the vertices of $G$ are in one-to-one correspondence with the leaves of $T_G$, and the internal nodes correspond to subsets of $V$.
    They call the nodes of
    a decomposition tree (and the sets of vertices they induce) \emph{decomposition sets}.
    They study the general case where the decomposition sets correspond to \emph{modules}: 
    \begin{definition}
        A \emph{module} in a graph $G = (V, E)$ is a set $X$ of vertices such that 1) if $y \in V \setminus X$, then $y$ has either directed edges to all members of $X$ or to none of them, and 2) all members of $X$ have either directed edges to $y$, or none of them do.
    \end{definition}
    Intuitively, a set of vertices in a graph forms a module if every vertex in $V \setminus X$ has a ``uniform'' relationship to all members of $X$~\citep{McConnell05:Linear}.
    Note that the definition of a module imposes no requirements on whether the vertices in $X$ should be connected or not.
    Observe also that connected components are a particular case of modules.
    A module is \emph{strong} if it does not overlap with any other module.
    Then, \citet{Capelle02:Graph} call the decomposition tree of a graph $G$ into its strong modules the \emph{modular decomposition tree} of $G$, and they provide a (complicated) linear time algorithm for computing it (which we can treat as a black-box algorithm).
    
    The literature on modular decomposition graphs is extensive and a popular topic in graph theory. 
    However, as noted in \citet{Brandt18:Extending}, the literature on composition-consistency (and in social choice more broadly) and on modular decompositions in graph theory is not well-connected.
    In this section, we help clarify part of this connection by detailing how we can use the modular decomposition algorithm by \citet{Capelle02:Graph} to compute the PQ-tree.
    Given that the notion of a module is the graph-theoretic generalization of clone sets in profiles and components in tournaments, we hope that there can be further interesting connections between the two fields.
\end{enumerate}

As observed by \citet{Brandt18:Extending},
to compute the decomposition tree of a tournament, we can simply input the graph induced by the tournament (\emph{i.e.}, we draw an edge from $a$ to $b$ if $a$ beats $b$) to the modular decomposition tree algorithm of \citet{Capelle02:Graph}.
In our case, for computing the PQ-tree using the algorithm of~\citep{Capelle02:Graph}, we need to input a graph $G$ built from $\profile$ such that the modules of $G$ are in bijection with the clone sets of $\profile$. 

\subsection{Clone-aware axioms}\label{appsec:ca-axioms}
First, we introduce three axioms show that they are not necessarily satisfied by $f^{CC}$ (\Cref{def:cc-transform}), even if $f$ satisfies them, implying our CC transformation does not preserve them. We will then introduce \emph{clone-aware} relaxations of these axioms, which are in fact preserved by the CC transformation (see \Cref{thm:cc_transform}). 

\begin{definition}\label{def:mono}
    An SCF $f$ satisfies \emph{monotonicity} if $a \in f(\profile)$ implies $a \in f(\profile')$ if for all $i \in N$ and $b,c \in A \setminus\{a\}$, we have $a \succ_{\sigma_i} b \Rightarrow a \succ_{\sigma'_i} b$ and $b \succ_{\sigma_i} c \Rightarrow b \succ_{\sigma'_i} c$.
\end{definition}

Inuitively, monotonicity dictates that promoting a winner in a profile while keeping all else constant should not cause them to lose. We see that monotonicity is not necessarily preserved by our CC transformation.

\begin{example}\label{ex:counter-mono}
    Consider Plurality Voting $(PV)$, which is monotonic, and the profile $\profile$ from \Cref{fig:counter_mono}. Notice $\{a_1,a_2,a_3\}$ is a fat sausage and is grouped up by the PQ tree. $\{a_1,a_2,a_3\}$ wins against $b$ in the root, and the $a_1$ wins against $a_2$ and $a_3$ with 5 plurality votes, hence $PV^{CC}(\profile)=\{a_1\}$. However, say \emph{one} of the rightmost voters move $a_1$ up, submitting $a_1 \succ b \succ a_2 \succ a_3$ instead. Then there are no longer any nontrivial clone sets, and $a_3$ wins with 4 plurality votes ($a_1$ only has 3). Hence, with this new profile (call it $\profile$'), we have $PV^{CC}(\profile')=PV(\profile')=\{a_3\}$, showing that $PV^{CC}$ is \emph{not} monotone.
\end{example}
\begin{figure}
    \centering
    \begin{subfigure}{.49\textwidth}
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            2 voters & 4 voters & 2 voters & 3 voters \\
            \hline
            \cellcolor{yellow!25}$a_1$ & \cellcolor{green!25}$a_3$ & \cellcolor{orange!25}$a_2$ & \cellcolor{blue!25}$b$ \\ \hline
            \cellcolor{orange!25}$a_2$ & \cellcolor{yellow!25}$a_1$ & \cellcolor{green!25}$a_3$ & \cellcolor{yellow!25}$a_1$ \\ \hline
            \cellcolor{green!25}$a_3$ & \cellcolor{orange!25}$a_2$ & \cellcolor{yellow!25}$a_1$ & \cellcolor{orange!25}$a_2$ \\ \hline
            \cellcolor{blue!25}$b$ & \cellcolor{blue!25}$b$ & \cellcolor{blue!25}$b$ & \cellcolor{green!25}$a_3$ \\
            \hline
        \end{tabular} \caption{Example profile $\boldsymbol{\sigma}$}\label{fig:counter_mono}
    \end{subfigure}
    \begin{subfigure}{.49\textwidth}
        \centering
        \begin{tabular}{|c|c|c|c|}
            \hline
            6 voters & 5 voters & 2 voters & 2 voters \\ \hline
            \cellcolor{yellow!25} $a_1$ & \cellcolor{blue!25} $c$ & \cellcolor{green!25} $b$ & \cellcolor{green!25} $b$ \\ \hline
            \cellcolor{red!25} $a_2$ & \cellcolor{red!25} $a_2$ & \cellcolor{blue!25} $c$ & \cellcolor{blue!25} $c$ \\ \hline
            \cellcolor{green!25} $b$ & \cellcolor{yellow!25} $a_1$ & \cellcolor{yellow!25} $a_1$ & \cellcolor{red!25} $a_2$ \\ \hline
            \cellcolor{blue!25} $c$ & \cellcolor{green!25} $b$ & \cellcolor{orange!25} $z$ & \cellcolor{yellow!25} $a_1$ \\ \hline
            \cellcolor{orange!25} $z$ & \cellcolor{orange!25} $z$& \cellcolor{red!25} $a_2$ & \cellcolor{orange!25} $z$ \\
            \hline
            \end{tabular}
        \caption{Example profile $\profile$}\label{fig:isda-counter}
    \end{subfigure}
\caption{Two example profiles}
\end{figure}
Given a preference profile $\profile=(\sigma_1,\sigma_2,\ldots, \sigma_n) \in \mathcal{L}(A)^n$ over voters $N=[n]$ and a new $(n+1)$th voter with ranking $\sigma_{n+1}$ over $A$, we denote by $\profile+\sigma_{n+1}$ the profile $(\sigma_1,\sigma_2,\ldots, \sigma_n, \sigma_{n+1}) \in \mathcal{L}(A)^{n+1}$. Also, given any voter $i \in N \cup \{n+1\}$ with ranking $\sigma_i$ over $A$ and a non-empty subset $B \subseteq A$, we denote by $\max_{i}(B)$ the candidate in $B$ that is ranked highest by $\sigma_i$. For example, if $\sigma_i = a \succ b \succ c \succ d$, and $B=\{b,c,d\}$, then $\max_i(B)=b$.


\begin{definition}[\citealt{Brandt17:Optimal}]\label{appdef:participation}
    An SCF $f$ satisfies \emph{(optimistic) participation} if given any profile $\profile \in \mathcal{L}(\cand)^n$ and any ranking $\sigma_{n+1} \in\mathcal{L}(\cand) $, we have $\max_{n+1}(f(\profile)) \succeq_{n+1} \max_{n+1}(f(\profile+\sigma_{n+1})).$

\end{definition}
 Participation dictates that a new voter cannot hurt themselves (in terms of their most preferred winner\footnote{One can alternatively use a pessimistic definition focusing on the new voter's lowest ranked candidate in the winner set.}) by participating in the election.

\begin{example}\label{ex:counter-part}
    Once again, Plurality Voting $(PV)$, which satisfies participation, and the profile $\profile$ from \Cref{fig:counter_mono}. As explained in \Cref{ex:counter-mono}, we have $PV^{CC}(\profile)=\{a_1\}$. Consider $\sigma_{n+1}: a_1 \succ b \succ a_2 \succ a_3$ and $\profile'=\profile+\sigma_{n+1}$. Since there are no non-trivial clone sets in $\profile'$, we have $PV^{CC}(\profile')=PV(\profile')= \{a_3\}$. Since $a_1 \succ_{n+1} a_3$, this shows $PV^{CC}$ violates participation, and that someone ranking $\sigma_{n+1}$ is better off staying away from this election. 
\end{example}
    
    Given a set $E$ and a family of its subsets $\mathcal{E} \subseteq 2^E$, for any $a \in E$, we denote $\mathcal{E}-\{a\} = \{K \setminus \{a\}: K \in \mathcal{E}\}$ 

\begin{definition}\label{appdef:isda}
    An SCF $f$ satisfies \emph{independence of Smith-dominated alternatives (ISDA)} if given any profile $\profile \in \mathcal{L}(\cand)^n$ over candidates $A$ and any candidate $a\in A$ such that $a \notin \textit{Sm}(\profile)$ and $\family(\profile \setminus\{a\}) = \family(\profile) - \{a\}$, we have $f(\profile)=f(\profile \setminus \{a\})$
\end{definition}

In words, the winner(s) under any rule satisfying ISDA is not affected by the addition of a non-Smith candidate.

\begin{example}\label{ex:counter-isda}
 Consider Beatpath ($BP$), which satisfies ISDA~\citep{Schulze10:New} and the profile $\profile$ from \Cref{fig:isda-counter}, which is a minor modification from the counterexample for $BP$ in the proof of \Cref{thm:cc_fails}. With $z$ in the ballot, there are no non-trivial clone sets, so $BP^{CC}(\profile)=BP(\profile)=\{a_1,a_2\}$. Notice also that $Sm(\profile)=A \setminus\{z\}$, so $z$ is indeed a non-Smith candidate. With $z$ gone however, $\{a_1,a_2\}$ is a clone set again, and hence $BP^{CC}$ first groups them up, picks $\{a_1,a_2\}$, and then picks $a_1$ in the restriction. Hence, $BP^{CC}(\profile \setminus\{z\}) =\{a_1\}$, showing that the CC-transformation does not necessarily preserve ISDA.
\end{example}

The common thread in \Cref{ex:counter-mono,ex:counter-part,ex:counter-isda} is that the changes in profile (whether promoting a winner on a ranking or the addition/removal of a voter/candidate) significantly alters the clone structure of the profile, causing the behavioral of any $f^{CC}$ to significantly change. Instead, we can relax each of these axioms by limiting the changes they consider to those that leave the clone structure unaffected. We present these relaxations (called the clone-aware version of each axiom) below. These new axioms implicitly assume that the clone structures are \textit{inherent}, based on the candidates' location is some perceptual space (which is in fact the interpretation put forward by \citet{Tideman87:Independence}), so any ``realistic'' change we will do to the profile will not alter the clone sets. 


\camono*

\begin{definition}\label{appdef:clone_participation}
    An SCF $f$ satisfies \emph{clone-aware (optimistic) participation (participation$\ca$)} if given any profile $\profile \in \mathcal{L}(\cand)^n$ and any ranking $\sigma_{n+1} \in\mathcal{L}(\cand) $ such that $\family(\profile)=\family(\profile+\sigma_{n+1})$, we have $\max_{n+1}(f(\profile)) \succeq_{n+1} \max_{n+1}(f(\profile+\sigma_{n+1})).$

\end{definition}

\begin{definition}\label{appdef:clone_isda}
    An SCF $f$ satisfies \emph{clone-aware ISDA (ISDA$\ca$)} if given any profile $\profile \in \mathcal{L}(\cand)^n$ over candidates $A$ and any candidate $a\in A$ such that $a \notin \textit{Sm}(\profile)$ and $\family(\profile \setminus\{a\}) = \family(\profile) - \{a\}$, we have $f(\profile)=f(\profile \setminus \{a\})$
\end{definition}






\subsection{Proof of \Cref{thm:cc_transform}}
In this section, we prove the theoretical guarantees of our CC-transform for SCFs.

\cctransform* 

\begin{proof}
We prove each condition one by one.
    \paragraph{Condition 1.} We first prove an intermediary lemma.
    \begin{lemma}\label{lemma:triv decomp}
        Given neutral SCF $f$ and profile $\profile$ over candidates $A$, we have $f(\profile)=\gloc_{f}(\profile,\decomp_{triv})$, where $\decomp_{triv}=\{\{a\}\}_{a \in A}$.
    \end{lemma}
    \begin{proof}
        Note that $\profile^{\decomp_{triv}}$ is isomorphic to $\profile$, with each $a\in A$ replaced with $\{a\}$. By neutrality, we must have $f(\profile^{\decomp_{triv}}) =\{\{a\}\}_{a \in f(\profile)}$. Moreover, since an SCF always returns a non-empty subset, $f(\profile|_{\{a\}})=\{a\}$ for any $a \in A$. This gives us
        \begin{align*}
            \gloc_f(\profile, \decomp_{triv})= \bigcup_{K \in f(\profile^{\decomp_{triv}})} f(\profile|_{K}) =   \bigcup_{a \in f(\profile)} f(\profile|_{\{a\}})= \bigcup_{a \in f(\profile)} \{a\}= f(\profile).
        \end{align*}
    \end{proof}

    
    If $\profile$ has no non-trivial clone sets, then $\family(\profile)$ is a fat sausage, so the PQ tree of $\profile$ (say $T$) is simply a single P-node (say $\node$) with all of the candidates in $A$ as its children leaf nodes. Since decomp$(\node,T)=\{\{a\}\}_{a \in A}=\decomp_{triv}$,  \Cref{alg:cc-transform} simply outputs $f^{CC}(\profile)=\gloc_{f}(\profile,\decomp_{triv})$. By \Cref{lemma:triv decomp}, this implies $f^{CC}(\profile)=f(\profile)$.

    \paragraph{Condition 2.} The fact that $f^{CC}$ is neutral follows from the neutrality of $f$ and that $\Cref{alg:cc-transform}$ is robust to relabeling of candidates. To prove $f^{CC}$ satisfies $CC$, we first prove an important lemma.

    \begin{lemma}\label{lemma:fcc_intermediary}
        Given neutral SCF $f$ and profile $\profile$, say $\decomp, \decomp'$ are two clone decomposition with respect to $\profile$, such that $\decomp= \{K_1,K_2,\ldots, K_z\} \cup \{\{a\}\}_{a \in A \setminus \left( \bigcup_{i \in [z]}K_i \right)}$ for some $z \in \mathbb{Z}_{\geq 0}$, and there exists some $K \subseteq A \setminus \left( \bigcup_{i \in [z]}K_i \right)$ with $|K|>1$ that satisfies $\decomp' = \decomp \setminus \calD \cup \{K\}$, where $\calD=\{\{a\}\}_{a \in K}$. In words, $\decomp'$ is the same decomposition as $\decomp$, except a group of singleton clone sets in $\decomp$ is now combined into a single new clone set $K$. Then $\gloc_{f^{CC}}(\profile, \decomp)=\gloc_{f^{CC}}(\profile, \decomp')$.
    \end{lemma}
    The proof of \Cref{lemma:fcc_intermediary} relies on the observation that the PQ trees for $\profile^\decomp$ and  $\profile^{\decomp'}$ are identical, except the subtree(s) corresponding to $\calD$ in the former (by \Cref{lemma:pq_clones}) is replaced by a single leaf node $K$ in the latter. Hence, we first show that \Cref{alg:cc-transform} proceeds identically on inputs $\profile^\decomp$ and  $\profile^{\decomp'}$, picking the same set of leaves from $\decomp \setminus \calD$ in both cases and returning \emph{some} descendants of $\calD$ in the former case if it returns $K$ in the latter. We then show that \emph{if} some descendants of $\calD$ are returned by the algorithm on input $\profile^\decomp$, these are exactly the same as the output of the algorihtm when run on input $\profile|_K$. Combining these gives us the lemma statement.
    \begin{proof}[Proof of \Cref{lemma:fcc_intermediary}]
        Say $\decomp, \decomp'$ satisfies the conditions in the lemma statement. Say $T$ and $T'$ are the PQ trees of $\profile^\decomp$ and $\profile^{\decomp'}$, respectively.\footnote{It is worth making a notational point here: when dealing with PQ trees of a profile $\profile$ over a candidates $A$, and each leaf node corresponded to a candidate in $a \in A$ and each internal node could be represented as a subset $\node \subseteq A$. Since $T$ (resp., $T'$) is the PQ trees of a summary $\profile^\decomp$ (resp., $\profile^{\decomp'}$), each leaf node now corresponds to a clone set $K \in \decomp$ (resp., $K' \in \decomp'$) and each internal node can be represented as a subset $\calB \subseteq \decomp$ (resp., $\calB' \subseteq \decomp'$).} Given an interval node $\calB \subseteq \decomp$ (resp., $\calB' \subseteq \decomp')$ in $T$ (resp., $T'$), we denote by $T(\calB$) (resp., $T'(\calB')$) the subtree of $T$ (resp., $T'$) rooteed at $\calB$ (resp., $\calB'$). We will be comparing the structure of $T$ and $T'$, using the fact that PQ trees are built by iteratively collapsing irreducible subfamilies (see \Cref{subsec:extended_pqtrees} above, and also \citet{Elkind10:Clone}). Since $\mathcal{D}=\{\{a\}\}_{a \in K}$ is a clone set with respect to $\profile^\decomp$ (which follows from the assumption that $K$ is a clone set with respect to $\profile$), by \Cref{lemma:pq_clones}, there are two options:
        \begin{itemize}
            \item $\mathcal{D}$ is a node of $T$, in which case its members are leaves of a subtree ($T(\calD)$). In this case, the tree $T'$ is identical to $T$, except $T(\calD)$ is replaced by a single leaf node $K$. The PQ tree for $\profile|_{K}$, on the other hand, is exactly $T(\calD)$ (except the leaf for each singleton $\{a\}$ is replaced with the leaf for $a$).
            \item $\mathcal{D}$ union of an interval of nodes ($\{B_k(\calB,T)\}_{i \leq k \leq j}$ for some $i < j$) that are adjacent children of the same Q-node $\calB \subseteq \decomp$, in which case its members are leaves of the same interval of subtrees ($\{T(B_k(\calB,T))\}_{i \leq k \leq j}$ ) . In this case, the tree $T'$ is identical to $T$, except the children of $\calB$ corresponding to $\calD$ ($\{T(B_k(\calB,T))\}_{i \leq k \leq j}$) are now replaced by a single leaf node $K$, placed in appropriate place in the majority ranking of $\calB$ (in this case, $i$th position), which is well-defined, since the replaced children formed an interval. The PQ tree for $\profile|_{K}$, on the other hand, is exactly $\{T(B_k(\calB,T))\}_{i \leq k \leq j}$, united by a single Q-node that is the root of the tree (except the leaf for each singleton $\{a\}$ is replaced with the leaf for $a$).
        \end{itemize}
        Now take any internal node $\calB \subseteq \decomp$ of the tree $T$ such that either $\calD \subsetneq \calB$ or  $\calD \cap \calB =\emptyset$ (in words, $T(\calB)$ either strictly contains $\calD$, or is not overlapping with it $\calD$ at all). In both  cases, there is (by the analysis above) a corresponding node $\calB'$ in the tree $T'$: if $\calD \subseteq \calB$, then $\calB'=\calB \setminus \calD \cup \{K\}$, and if $\calD \cap \calB =\emptyset$ then $\calB'=\calB$. We would like to compare the children node that are enqueued by \Cref{alg:cc-transform} if (\textbf{case (a)}) it enqueues $\calB$ when run on input $\profile^\decomp$ versus if (\textbf{case (b)}) it enqueues $\calB'$ when run on input $\profile^{\decomp'}$. We consider each possible scenario:
        \begin{enumerate}
            \item[1.] If $\calD \cap \calB =\emptyset$. In this case, $\calB'=\calB$ so the algorithm proceeds the same way in both cases \casea and \caseb, enqueing the same children regardless of whether $\calB$ is a Q-node or a P-node.
            \item[2.] If $\calD \subsetneq \calB$, and $\calB$ has a child node $\mathcal{E}$ such that $\calD \subseteq \mathcal{E}$. In words, $\calB$ is either a non-immediate ancestor of the subtree(s) corresponding to $\calD$ or the parent node of a single subtree $T(\calD)$. In this case, decomp($\calB',T'$)=  decomp($\calB,T)\setminus \{\mathcal{E}\} \cup \{\mathcal{E}'\}$, where $\mathcal{E}'=\mathcal{E} \setminus \mathcal{D} \cup \{K\}$. Then, $\profile^{\text{decomp}(\calB,T)}$ and $\profile^{\text{decomp}(\calB',T')}$ are isomorphic (with $\mathcal{E}$ relabeled as $\mathcal{E}'$). Hence, the algorithm proceeds the same way in both cases \casea and \caseb, enqueing the same children regardless of whether $\calB$ is a Q-node or a P-node, since $f$ is neutral. In other words, any child node $\mathcal{F} \neq \mathcal{E}$ will be enqueued in case \casea iff it is enqueued in case \caseb; $\mathcal{E}$ will be enqueued in case \casea iff $\mathcal{E}'$ is enqueued in case \caseb.
            \item[3.] If $\calD \subsetneq \calB$ and no child node of $\calB$ entirely contains $\calD$. By \Cref{lemma:pq_clones}, this implies that $\calB$ is a Q-node and $\exists i,j: 0 \leq i < j \leq |\text{decomp}(\calB,T)|$ such that $\calD=\bigcup_{k: i \leq k \leq j} B_k(\calB, T)$. In words, $\calD$ corresponds to the leaves of multiple (specifically, $j-i+1$) subtrees ($\{T(B_k(\calB,T))\}_{i \leq k \leq j}$) whose roots ($\{B_k(\calB,T)\}_{i \leq k \leq j}$) are an interval of children nodes of $\calB$. We cannot have $j-i+1 =|\text{decomp}(\calB,T)|$, since this would imply $\calB= \calD$, even though we assumed $\calD$ is a strict subset of $\calB$. Hence, $\calB'$ (the node in $T'$ corresponding to $\calB$) is a Q-node with $|\text{decomp}(\calB,T)|-(j-i)$ children nodes,\footnote{If $|\text{decomp}(\calB,T)|-(j-i)=2$, then $\calB'$ is technically both a Q- and a P- node, which does not affect our analysis since \Cref{alg:cc-transform} treats these cases identically.} with $\{T(B_k(\calB,T))\}_{i \leq k \leq j}$ replaced by a single leaf node $K$ (respecting the rest of the order). Say $\ell = |\text{decomp}(\calB,T)|$ and $\ell'=|\text{decomp}(\calB',T')|=|\text{decomp}(\calB,T)|-(j-i)$. By the clone set definition, we have that $\profile^\decomp|_{\{B_1(\calB,T),B_2(\calB,T)\}}$ and $\profile^{\decomp'}|_{\{B_1(\calB',T'),B_2(\calB',T')\}}$ are isomorphic, and since $f$ is neutral, we have  $$B_i(\calB,T)\in f(\profile^\decomp|_{\{B_1(\calB,T),B_2(\calB,T)\}}) \Leftrightarrow B_i(\calB',T')\in f(\profile^{\decomp'}|_{\{B_1(\calB',T'),B_2(\calB',T')\}})$$ for $i \in \{1,2\}$. Then we consider the three possible cases separately:
            \begin{itemize}
                \item[3a.] If $f(\profile^{\decomp}|_{\{B_1(\calB,T),B_2(\calB,T)\}})=\{B_1(\calB,T)\}$, then $B_1(\calB,T)$ gets enqueued in case \casea, and $B_1(\calB',T')$ gets enqueued in case \caseb. If $i>1$ (\emph{i.e.}, $B_1(\calB,T) \cap \calD =\emptyset$)  then $B_1(\calB,T)=B_1(\calB',T')$, so the same node gets enqueued in both cases. If $i=1$, then $B_1(\calB',T')=\{K\}$, so $B_1(\calB,T)  \subseteq \calD$ gets enqueued in \casea and $\{K\}$ gets enqueued in \caseb.
                \item[3b.] If $f(\profile^{\decomp}|_{\{B_1(\calB,T),B_2(\calB,T)\}})=\{B_2(\calB,T)\}$, then $B_\ell(\calB,T)$ gets enqueued in case \casea and $B_{\ell'}(\calB',T')$ gets enqueued in case \caseb. If $j<\ell$ (\emph{i.e.}, $B_\ell(\calB,T) \cap \calD =\emptyset$)  then $B_{\ell}(\calB,T)=B_{\ell'}(\calB',T')$, so the same node gets enqueued in both cases. If $j=\ell$, then $B_{\ell'}(\calB',T')=\{K\}$, so $B_\ell(\calB,T)  \subseteq \calD$ gets enqueued in \casea and $\{K\}$ gets enqueued in \caseb.
                \item[3c. ] $f(\profile^{\decomp}|_{\{B_1(\calB,T),B_2(\calB,T)\}})=\{B_1(\calB,T),B_2(\calB,T)\}$, then all the children nodes get enqueued in both cases
            \end{itemize}
        \end{enumerate}
    Together, the cases above imply that starting from corresponding nodes $\calB$ and $\calB'$ in $T$ and $T'$ (respectively) that either contain $\calD$ and $\{K\}$ (respectively) or do not overlap with them,
    \begin{itemize}
        \item \Cref{alg:cc-transform} enqueues any child node of $\calB$ that either contains $\calD$ or do not overlap with it in \casea if and only if it enqueues corresponding childnode of $\calB'$ in \caseb
        \item \Cref{alg:cc-transform} enqueues some subtree(s) corresponding to $\calD$ in \casea if and only if it outputs $|K|$ as one of the winners in \caseb.
    \end{itemize}
    Since \Cref{alg:cc-transform} run on both input $\profile^\decomp$ or input $\profile^{\decomp'}$ start at their root nodes (which indeed contain $\calD$ and $\{K\}$, respectively), inductively applying this argument implies that for all $K' \in \decomp \setminus \calD$, we have:
    \begin{align}
        K' \in f^{CC}(\profile^\decomp) &\iff  K' \in f^{CC}(\profile^{\decomp'})\label{eq:non_d}\\
        \calD \cap f^{CC}(\profile^\decomp) \neq \emptyset &\iff  K \in f^{CC}(\profile^{\decomp'})\label{eq:yes_d}
    \end{align}
    
    What remains to be shown is if $ \calD \cap f^{CC}(\profile^\decomp) \neq \emptyset$, then $\calD \cap f^{CC}(\profile^\decomp)=\{\{a\}\}_{a \in f^{CC}(\profile|_{K})}$. In words, we must show that  if \Cref{alg:cc-transform} outputs any descendants of $\calD$ in case \casea, then these decedents are the same as those that are output by the algorithm on input $\profile|_K$. Consider the three cases, assuming $ \calD \cap f^{CC}(\profile^\decomp) \neq \emptyset$: 
        \begin{itemize}
            \item $\calD$ corresponds to a single subtree $T(\calD)$. Then by case (2.) above, we have that $\calD$ will be enqueued by \Cref{alg:cc-transform} when running on input $\profile^\decomp$ annd $\{K\}$ will be enqueued by the algorithm when run on input $\profile^{\decomp'}$. Since the PQ-tree for $\decomp|_K$ is identical to $T(\calD)$, the descendants of $\calD$ that will be output by \Cref{alg:cc-transform} when running on input $\profile^\decomp$ (after dequeuing $\calD$) are the same as the ones the algorithm would output on input $\profile|_K$.
            \item $\calD$ corresponds to an interval of children nodes ($\{B_k(\calB,T)\}_{i \leq k \leq j}$ ) under a Q-node ($\calB$) in $T$ and $f(\profile^{\decomp}|_{{\{B_1(\calB,T),B_2(\calB,T)\}})=\{B_1(\calB,T),B_2(\calB,T)\}}$. Then by case (3c.) above, \Cref{alg:cc-transform} will enqueue all of these children nodes when running on input $\profile^\decomp$ and will enqueue $\{K\}$ when running on input $\profile^{\decomp'}$. The root of the PQ tree of $\profile|_K$ (say $T_K$) is a Q-node (denoted $K$) connecting these subtrees ($\{T(B_k(\calB,T))\}_{i \leq k \leq j}$ ). Since $f$ is neutral, we have $f(\profile^{\decomp}|_{\{B_1(K,T_K),B_2(K,T_K)\}})=\{B_1(\calB,T_K),B_2(\calB,T_K)\}$ as, by definition of Q-nodes, any voter $i \in \voter$ will have $B_1(\calB,T) \succ_{i} B_2(\calB,T)$ if and only if $B_1(K,T_K) \succ_{i} B_2(K,T_K)$. Hence, once again all of these subtrees will be enqueued on the first step of \Cref{alg:cc-transform} when it is run on input $\profile|_K$. The rest of the algorithm will follow identically in both cases.
            \item $\calD$ corresponds to an interval of children nodes ($\{B_k(\calB,T)\}_{i \leq k \leq j}$ ) under a Q-node ($\calB$) in $T$ with $f(\profile^{\decomp}|_{{\{B_1(\calB,T),B_2(\calB,T)\}})=\{B_1(\calB,T)\}}$ (resp., $f(\profile^{\decomp}|_{{\{B_1(\calB,T),B_2(\calB,T)\}})=\{B_2(\calB,T)\}}$). Then by case (3a.) (resp., (3b.)) above, \Cref{alg:cc-transform} will only enqueue $\mathcal{E}\equiv B_1(\calB,T)\subsetneq \calD$ (resp., $\mathcal{E}\equiv B_j(\calB,T)\subsetneq \calD$). Then, the root of the PQ tree of $\profile|_K$ (say $T_k$) is a Q-node (denoted $K$) with $B_1(K,T_K)$ (resp., $B_{j-i+1}(K,T_K)$) corresponding to $\mathcal{E}$. By neutrality of $f$, we have $f(\profile^{\decomp}|_{\{B_1(K,T_K),B_2(K,T_K)\}})=\{B_1(\calB,T_K)\}$ (resp., $f(\profile^{\decomp}|_{\{B_1(K,T_K),B_2(K,T_K)\}})=\{B_2(\calB,T_K)\}$). Therefore, the first step of \Cref{alg:cc-transform} when it is run on input $\profile|_K$ will pick the subtree corresponding to $\mathcal{E}$. The rest of the algorithm will follow identically in both cases.
    \end{itemize}
    Together, these cases show that the if any descendent of $\calD$ will be output when \Cref{alg:cc-transform} is run on $\profile^\decomp$, then they are the same as those output when its run on $\profile|_K$. In other words, if $ \calD \cap f^{CC}(\profile^\decomp) \neq \emptyset$, then $\calD \cap f^{CC}(\profile^\decomp)=\{\{a\}\}_{a \in f^{CC}(\profile|_{K})}$. Combined with (\ref{eq:non_d}) and (\ref{eq:yes_d}), this gives us
    
    \begin{align*}
        \calD \cap f^{CC}(\profile^\decomp) = \emptyset \Rightarrow \gloc_{f^{CC}}(\profile, \decomp) &=\bigcup_{K' \in f^{CC}(\profile^\decomp)} f^{CC}(\profile|_{K'})\\&=\bigcup_{K' \in f^{CC}(\profile^{\decomp'})} f^{CC}(\profile|_{K'})= \gloc_{f^{CC}}(\profile, \decomp')\text{, and}
    \end{align*}
    \begin{align*}
        \calD \cap f^{CC}(\profile^\decomp) \neq \emptyset \Rightarrow \gloc_{f^{CC}}(\profile, \decomp) &=\left(\bigcup_{K' \in f^{CC}(\profile^\decomp) \setminus \calD} f^{CC}(\profile|_{K'})\right) \cup \left(\bigcup_{K' \in f^{CC}(\profile^\decomp) \cap \calD} f^{CC}(\profile|_{K'})\right) \\
        &=\left(\bigcup_{K' \in f^{CC}(\profile^{\decomp'}) \setminus \{K\}} f^{CC}(\profile|_{K'})\right) \cup \left(\bigcup_{a \in f^{CC}(\profile|_{K})} f^{CC}(\profile|_{\{a\}})\right)\\
        &=\left(\bigcup_{K' \in f^{CC}(\profile^{\decomp'}) \setminus \{K\}} f^{CC}(\profile|_{K'})\right) \cup f^{CC}(\profile|_{K})\\
        &=\bigcup_{K' \in f^{CC}(\profile^{\decomp'})} f^{CC}(\profile|_{K'})=\gloc_{f^{CC}}(\profile, \decomp').
    \end{align*}
    In both cases, we have $\gloc_{f^{CC}}(\profile, \decomp)=\gloc_{f^{CC}}(\profile, \decomp')$, completing the proof of the lemma.
    \end{proof}
We now turn to proving $f^{CC}$ satisfies CC for any neutral $f$. Now, given any neutral SCF $f$, profile $\profile$ over $A$, and decomposition $\decomp=\{K_1,K_2,\ldots, K_\ell\}$ with respect to $\profile$, define $\decomp_i= \{K_1,K_2,\ldots, K_i\} \cup \{\{a\}\}_{a \in A \setminus \left( \bigcup_{j \in [i]}K_j \right)}$ for each $i \in [\ell]\cup\{0\}$. In words, $\decomp_i$ is the decomposition with the first $i$ clone sets in $\decomp$, and the remaining candidates are left as singletons. We have $\decomp_0=\{\{a\}\}_{a \in A}=\decomp_{triv}$ and $\decomp_\ell=\decomp$. Then
\begin{align*}
    f^{CC}(\profile)= \gloc_{f^{CC}}(\profile, \decomp_0) = \gloc_{f^{CC}}(\profile, \decomp_1) = \ldots =  \gloc_{f^{CC}}(\profile, \decomp_{\ell-1}) =  \gloc_{f^{CC}}(\profile, \decomp_\ell)=\gloc_{f^{CC}}(\profile, \decomp), 
\end{align*}
where first equality follows from \Cref{lemma:triv decomp} and subsequent inequalities follow from \Cref{lemma:fcc_intermediary}. Since $\decomp$ was arbitrarily chosen, this proves that $f^{CC}$ satisfies CC.

\paragraph{Condition 3.} Say $f$ is a composition-consistent SCF. By \Cref{def:oioc}, $f$ must be neutral. We will prove $f(\profile)=f^{CC}(\profile)$ by inducting on the depth of the PQ-tree of $\profile$ (say $T$). As a base case, say $T$ has depth one (\emph{i.e.}, it is a single leaf node). This implies there is a single candidate in $\profile$, so both $f$ and $f^{CC}$ will return that candidate. Now, assume $f$ and $f^{CC}$ agree on all profiles with PQ-trees of depth 1,2,\ldots,i-1, and say $\profile$ has a PQ-tree (say $T$) of depth $i$. Say $\cand$ is the root node of $T$ and consider two cases:
\begin{enumerate}
    \item $\cand$ is a P-node. Say $\decomp =$decomp$(K,T)$. By the recursive construction of \Cref{alg:cc-transform}, we will have $f^{CC}(\profile)= \bigcup_{\node \in f(\profile^\decomp)}f^{CC}(\profile|_B)$. Since $f$ is CC, we must also have $f(\profile)=\gloc_{f}(\profile,\decomp)= \bigcup_{\node \in f(\profile^\decomp)}f(\profile|_B)$. For each $B \in \decomp$, $\profile|_B$ can have a PQ-tree of depth at most $i-1$. Thus, by the inductive hypothesis we have $f^{CC}(\profile|_B)=f(\profile|_B)$, implying $f^{CC}(\profile)=f(\profile)$, as desired.
    \item $\cand$ is a Q-node. Say $\decomp =$decomp$(K,T)$ and $\ell =|\decomp|$. For each $i,j \in [\ell]$, say $\node_{i} = \node_i(\cand, T)$ and $B_{i,j}= \cup_{[k\in [i,j]}B_k$. Consider three cases:
    \begin{enumerate}
        \item[(2a)] $f(\profile^\decomp|_{\{B_1,B_2\}})=\{B_1\}$. By \Cref{alg:cc-transform}, we have $f^{CC}(\profile)=f^{CC}(\profile|_{B_1})$. Consider the decomposition $\decomp_1 = \{B_1, B_{2,\ell}\}$ (this is indeed a valid decomposition by the definition of a Q-node). Since $f$ is CC and neutral, we must have $f(\profile)=\gloc_f(\profile,\decomp_1)=\bigcup_{B \in f(\profile^{\decomp_1})}f(\profile|_B)=f(\profile|_{B_1})$. Since $\profile|_{B_1}$ must have a PQ-tree of depth at most $i-1$, by the inductive hypothesis we must have $f^{CC}(\profile|_{B_1})= f(\profile|_{B_1})$, implying $f^{CC}(\profile)=f(\profile)$, as desired. 
        \item[(2b)] $f(\profile^\decomp|_{\{B_1,B_2\}})=\{B_2\}$. By \Cref{alg:cc-transform}, we have $f^{CC}(\profile)=f^{CC}(\profile|_{B_\ell})$. Consider the decomposition $\decomp_2 = \{B_{1,\ell-1}, B_{\ell}\}$ (this is indeed a valid decomposition by the definition of a Q-node). Since $f$ is CC and neutral, we must have $f(\profile)=\gloc_f(\profile,\decomp_2)=\bigcup_{B \in f(\profile^{\decomp_2})}f(\profile|_B)=f(\profile|_{B_\ell})$. Since $\profile|_{B_\ell}$ must have a PQ-tree of depth at most $i-1$, by the inductive hypothesis we must have $f^{CC}(\profile|_{B_\ell})= f(\profile|_{B_\ell})$, implying $f^{CC}(\profile)=f(\profile)$, as desired. 
        \item[(2c)] $f(\profile^\decomp|_{\{B_1,B_2\}})=\{B_1, B_2\}$. By \Cref{alg:cc-transform}, we have $f^{CC}(\profile)=\bigcup_{i \in [\ell]}f^{CC}(\profile|_{B_i})$. For each $i \in [\ell-1]$, define $\decomp_i= \{B_i, B_{i+1,\ell}\}$ as a decomposition of $\profile|_{B_{i,\ell}}$. By successively using the fact that $f$ is CC and neutral, we get
        \begin{align*}
            f(\profile)&=\gloc_f(\profile,\decomp_1)= \bigcup_{\node \in f(\profile^\decomp_{1})} f(\profile|_B)= f(\profile|_{B_1}) \cup f(\profile|_{B_{2,\ell}}) =  f(\profile|_{B_1}) \cup \gloc_f(\profile|_{B_{2,\ell}}, \decomp_2)\\
            &= f(\profile|_{B_1}) \cup  f(\profile|_{B_2}) \cup  f(\profile|_{B_{3,\ell}}) = f(\profile|_{B_1}) \cup  f(\profile|_{B_2}) \cup  \gloc_f(\profile|_{B_{3,\ell}}, \decomp_3)=\ldots\\
            &= \bigcup_{i \in [\ell]} f(\profile|_{B_i}).
        \end{align*}
        For each $i\in [\ell]$, $\profile|_{B_i}$ must have a PQ-tree of depth at most $i-1$. Thus by the inductive hypothesis we must have $f^{CC}(\profile|_{B_i})= f(\profile|_{B_i})$, implying $f^{CC}(\profile)=f(\profile)$, as desired. 
    \end{enumerate}
\end{enumerate}
The inductive proof above shows that in all cases, we have $f(\profile)=f^{CC}(\profile)$ for all $\profile$, as long as $f$ is CC. 


\paragraph{Condition 4.} The statement that $f$ being anonymous implies $f^{CC}$ being anonymous follows from the fact that \Cref{alg:cc-transform} is robust to relabeling of voters. For each of the remaining properties, we will prove that it is preserved as a separate lemma. We start with Condorcet consistency. Recall that $f$ is Condorcet-consistent if it returns $Sm(\profile)$ whenever  $|Sm(\profile)|=1$, where $Sm$ is defined in \Cref{tab:scfs}. In words, if there is a candidate $a \in A$ that pairwise defeats every other candidate in $\profile$ (\emph{i.e.}, $a$ is the \emph{Condorcet winner}), then we must have $f(\profile)=\{a\}$.
\begin{lemma}\label{lemma:cc_condorcet}
If (neutral) $f$ is Condorcet-consistent, then $f^{CC}$ is Condorcet-consistent.
\end{lemma}
\begin{proof}

Consider running \Cref{alg:cc-transform} on input SCF $f$, which is Condorcet-consistent, and profile $\profile$, where $a \in A$ is the Condorcet winner.


Assume the algorithm dequeues node $B \subseteq A$ whose subtree contains $a$. If $|B|=1$, then $\node$ is the leaf corresponding to $\{a\}$, and $a$ is added to the winner list $W$. If $|B|>1$, then say $\decomp =$decomp($B,T$). Since $|B|$ is an internal node, we have $|\decomp|>1$ (all internal nodes in the PQ-tree has at least two children---see \Cref{subsec:extended_pqtrees} above). We would like to the show that \emph{only} the child node that contains $a$ (say $K_a \in \decomp$) will be enqueued by the algorithm. Given any $K' \in \decomp \setminus\{K_a\}$ and $b \in K'$, we have $M[a,b] =M^\decomp[K_a,K']$ by the clone definition (\emph{i.e.}, the majority relationship between $a$ and $b$ is the same as the majority relationship between their clone sets). Since $a$ pairwise defeats all $b \in A \setminus\{a\}$, this implies $K_a$ pairwise defeats all $K' \in \decomp \setminus\{K_a\}$, \emph{i.e.}, $K_a$ is the Condorcet winner of $\profile^\decomp$. Then, there are two options:

\begin{enumerate}
    \item If $B$ is a P-node: since $\clone_a$ is the Condorcet winner of $\profile^\decomp$ and $f$ is Condorcet-consistent we have that $f(\profile^\decomp) = \{\clone_a\}$. Hence, only $K_a$ is enqueued by the algorithm among the children nodes of $K_a$.
    \item If $B$ is a Q-node: since $\clone_a$ is a Condorcet winner of $\profile^\decomp$, we must have $K_a= B_1(B,T)$. Moreover, since $f$ is Condorcet-consistent, we must have $f(\profile^\decomp|_{\{B_1(B,T),B_2(B,T)\}})=\{B_1(B,T)\}$ (as $B_1(B,T)=K_a$ pairwise defeats $B_2(B,T)$). Hence, only $K_a$ is enqueued by the algorithm among the children nodes of $B$.
\end{enumerate}

This implies that starting from a node whose subtree contains $a$, \Cref{alg:cc-transform} will iteratively pick only the children node containing $a$, until arriving at $a$'s leaf node and adding it to the winner list. Since the queue $\queue$ initially has only the root node (denoted $A$), whose subtree $(T)$ indeed contains $a$, this implies only $a$ will be added to $W$ by the algorithm. Hence, $f^{CC}(\profile) = \{a\}$, \emph{i.e.}, $f^{CC}$ is Condorcet-consistent. 
\end{proof} 


Before proving the preservation of the stronger axiom of Smith consistency, which dictates $f(\profile) \subseteq Sm(\profile)$ for \emph{all} profiles $\profile$, we first prove a useful intermediary lemma.

\begin{lemma} \label{lemma:smith_intersect}
    Given any profile $\profile$ and clone set $\clone$ with respect to $\profile$, it must be that $\clone$ and $Sm(\profile)$ cannot intersect nontrivially. That is, it must be that either $Sm(\profile) \subseteq \clone$, $\clone \subseteq Sm(\profile)$, or $Sm(\profile) \cap \clone = \emptyset$. 
    
    \begin{proof}
Suppose $K$ and $Sm(\profile)$ intersects nontrivially. Take any $a \in \clone \setminus Sm(\profile)$,  $b \in \clone \cap Sm(\profile)$, and $c \in Sm(\profile) \setminus K$. We must have that $c$ pairwise defeats $a$, since $a \notin  Sm(\profile) $ and $c \in  Sm(\profile)$. By the clone definition this implies $c$ also pairwise defeats $b$. Thus each candidate in $Sm(\profile) \setminus \clone$ pairwise defeats any candidate out of it, and is strictly smaller than $Sm(\profile)$. This contradicts the definition of $Sm(\profile)$. 
    \end{proof}
    
\end{lemma}
\begin{corollary}\label{cor:smith_clone}
If $\decomp$ is a clone decomposition with respect to $\profile$, either there exists $K \in \decomp$ such that $Sm(\profile) \subseteq K$, or there exists $\decomp' \subseteq \decomp$ such that $Sm(\profile) = \bigsqcup_{K \in \decomp'}K$.
\end{corollary}

\begin{lemma}\label{lemma:cc_smith}
    If (neutral) $f$ is Smith-consistent, then $f^{CC}$ is Smith-consistent. 
\end{lemma}
\begin{proof}
    We first show that when run on SCF $f$ (which is Smith-consistent) and profile $\profile$ (with PQ tree $T$), for any node $B \subseteq A$ whose subtree contains the entirety of $Sm(\profile)$, \Cref{alg:cc-transform} either only enqueues a single child node that is also a superset of $Sm(\profile)$, or only enqueues (possibly multiple) children nodes that are subsets of $Sm(\profile)$. By \Cref{cor:smith_clone}, when the algorithm is at node $B$ that is a superset of $Sm(\profile)$, the corresponding decomposition $\decomp=$decomp$(B,T)$ will satisfy one of two cases:

    \begin{enumerate}
        \item One child node ($\clone_S \in \decomp$) will contain all candidates in the Smith set. By the clone definition, this implies $K_S$ pairwise defeats every other clone set in $\profile^\decomp$. This means that $\{\clone_S\}$ is the Smith set of $\profile^\decomp$. Consider the cases for $B$: 
        \begin{enumerate}
            \item[(1a)] If $B$ is P-node, then because $f$ is Smith-consistent, we have that $f(\profile^\decomp) \subseteq Sm(\profile^\decomp) = \{\clone_S\}$. Hence, again, only $K_S$ gets enqueued.
            \item[(1b)] If $B$ is a Q-node, then we must have $B_1(B,T)=K_S$, which is the only child that gets enqueued. Moreover, since $f$ is Smith-consistent, we must have $f(\profile^\decomp|_{\{B_1(B,T),B_2(B,T)\}})=\{B_1(B,T)\}$ (as $B_1(B,T)=K_a$ pairwise defeats $B_2(B,T)$, so $\Sm(\profile^\decomp|_{\{B_1(B,T),B_2(B,T)\}})=\{B_1(B,T)\}$). Hence, only $K_S$ is enqueued by the algorithm among the children nodes of $B$.
        \end{enumerate} 
        \item There exists some $\decomp' \subseteq \decomp$ such that $Sm(\profile)=\bigsqcup_{K \in \decomp'} K$. In this case, $\decomp'$ is the Smith set of $\profile^\decomp$ (since $Sm(\profile^\decomp) \subseteq \decomp'$ by the clone definition, and $\decomp' \subseteq Sm(\profile^\decomp)$ by the minimality of $Sm(\profile)$). Consider the cases for $B$: \begin{enumerate}
            \item[(2a)] $B$ is a P-node. Since $f$ is Smith-consistent, it must be that $f(\profile^\decomp) \subseteq Sm(\profile^\decomp)=\decomp'$. Therefore, only child nodes that are subsets of $Sm(\profile)$ will be enqueued. 
            \item[(2b)]  $B$ is a Q-node and $\decomp \setminus \decomp'=\emptyset$. Then we have $B=Sm(\profile^\decomp)$, so any children of $\node$ that is enqueued is a subset of $Sm(\profile^\decomp)$ by definition.
            \item[(2c)]  $B$ is a Q-node and $\decomp \setminus \decomp' \neq \emptyset$. Since any $K \in \decomp'$ must pairwise any $K'$, we must have $\decomp' = \{B_i(\node, T)\}_{i=1}^j$ for some $j < |\decomp|$. Further, we must $j=1$, as otherwise $B_1(B,T)$ also pairwise defeats the remaining members of $\decomp'= \Sm(\profile^\decomp)$, which contradicts the minimality of $\Sm$. Therefore this case is identical to that of (1b), and only the Smith set gets enqueued. 
        \end{enumerate} 
    \end{enumerate}

Starting from a node $B$ that is a superset of $Sm(\profile)$, there can only $|B\setminus Sm(\profile)|$ number of subsequent nodes that falls into case (1) above, since each time this happens at least \emph{some} non-Smith candidates are dropped by the algorithm. Hence, starting from a node $B$ that is a superset of $Sm(\profile)$, the algorithm will eventually come to a node that fulfills case (2) above, in which case only the child nodes that are entirely subsets of $Sm(\profile)$ are enqueued, after which it is impossible for any $B\setminus Sm(\profile)$ to win. Since the root node of the tree ($\cand$), where the algorithm starts, is by definition a superset of $Sm(\profile)$, this implies that $f^{CC} (\profile) \subseteq \Sm(\profile)$, \emph{i.e.}, $f^{CC}$ satisfies Smith-consistency. 
\end{proof}

Recall that unlike the other axioms, we have so far only defined decisiveness on a specific profile $\profile$, \emph{i.e.} $|f(\profile)|=1$ (see \Cref{sec:bg}). Having fixed the voters $N$ and candidates $\cand$, we say $f$ is (overall) decisive if it is decisive on all $\profile\in \mathcal{L}(\cand)^n$. 
\begin{lemma}\label{lemma:cc_decisive}
If (neutral) $f$ is decisive, then $f^{CC}$ is decisive. 
\end{lemma}
\begin{proof}
When run on $f$ and any profile $\profile$ (with PQ-tree $T$), for each node $\node$ that is dequeued, \Cref{alg:cc-transform} will always enqueue a single child node of  $\node$: if $\node$ is a P-node, this is $f(\profile^\decomp)$ (where $\decomp =$decomp$(\node,T)$), which has cardinality 1 since $f$ is decisive; if $\node$ is a Q-node, this is $B_1(\node,T)$ or $B_{|\decomp|}(\node,T)$ (we cannot have $f(\profile^\decomp|_{\{B_1(\node,T),B_2(\node,T)\}}=\{B_1(\node,T),B_2(\node,T)\}$ since $f$ is decisive). This implies that \Cref{alg:cc-transform} will start from the root node of $T$ and go down one child node at a time, until reaching a leaf node, which will be the single winner added to $W$. Hence, $|f^{CC}(\profile)|=1$ for all $\profile$, \emph{i.e.} $f^{CC}$ is decisive.
\end{proof}
We now move to the clone-aware axioms, formally defined in the preceding section.

\begin{lemma}\label{lemma:cc_mono}
If (neutral) $f$ satisfies monotonicity$\ca$  (Def.~\ref{def:weak-mono}), then $f^{CC}$ satisfies monotonicity$\ca$. 
\end{lemma}

\begin{proof}
    Fix a profile $\profile$, a candidate $a \in f^{CC}(\profile)$, and a second profile $\profile'$ with (1) $\family(\profile)=\family(\profile')$ and (2) for all $i \in N$ and $b,c \in A \setminus\{a\}$, we have $a \succ_{\sigma_i} b \Rightarrow a \succ_{\sigma'_i} b$ and $b \succ_{\sigma_i} c \Rightarrow b \succ_{\sigma'_i} c$. We would like to show that $a \in f^{CC}(\profile').$ Since, $\family(\profile)=\family(\profile')$ the node structure of the PQ-trees of the two profiles (say $T$ and $T'$, respectively) are identical, but the number of each vote in $\profile^\decomp$ and $\profile'^\decomp$ might be different for a given $\decomp$. Hence, we only need to show that at each node $B \subseteq A$ that contains $a$, the child node containing $a$ (and possibly others) will be enqueued. Fix an internal node $\node$ cotaining $a$ in the PQ-tree, and say $\decomp=$ decomp($B,T$)=decomp($B,T'$) and $K_a$ is the clone set in $\decomp$ containing $a$ (\emph{i.e.}, $a \in K_a \in \decomp$). Consider two options:

    \begin{enumerate}
        \item $\node$ is a P-node. Since $a \in f^{CC}(\profile)$, we must have $K_a \in f(\profile^\decomp)$. Furthermore, for any two clone sets $K_b, K_c \in \decomp \setminus \{K_a\}$, it must be that $K_a \succ_{\sigma_i^\decomp} K_b \implies K_a \succ_{{\sigma_i^\decomp}'} K_b$ and 
        $K_b \succ_{\sigma_i^\decomp} K_c \implies K_b \succ_{{\sigma_i^\decomp}'} K_c$ for all $i \in N$ by the clone set definition, since the only difference between $\profile$ and $\profile'$ is $a$ moving up in some rankings. As $f$ satisfies clone-aware monotonicity, $K_a \in f(\profile^\decomp) \implies K_a \in f({\profile'^\decomp})$, implying $K_a$ is enqueued in both cases.
        \item $\node$ is a Q-node. This implies everyone in $\profile^\decomp$ has either ranked $B_1(\node, T) \succ B_2(\node, T) \succ \ldots \succ B_{|\decomp|}(\node,T)$ or $B_{|\decomp|}(\node, T) \succ B_{|\decomp|-1}(\node, T) \succ \ldots \succ B_{1}(\node,T)$. Say $K_a = B_{k}(\node,T)$ for some $k \in [|\decomp|]$. Consider two cases:
        \begin{itemize}
            \item[(2a)] $|\decomp|>2$. For any $i \in \voter$, we will show that  $\sigma_i^\decomp= \sigma_i'^{\decomp}$. By construction, the order in which all $B_{i}(\node, T)$ for $i \in [|\decomp|]\setminus \{k\}$ are the same in the two rankings, as only $K_a$ can move up. Assume for the sake of contradiction $\sigma_{i}'^{\decomp}$ ranks $K_a$ in the $j$th position for some $j<k$. If $j>1$, this implies $\{B_{j-1}(\node,T), B_{j}(\node,T)\}$ is a clone set in $\profile^\decomp$ (by definition of a Q-node) but not a clone set in $\profile'^{\decomp}$ (as they are interrupted by $K_a$ in $\sigma_i'^{\decomp}$), and therefore $ B_{j-1}(\node,T) \cup B_{j}(\node,T) \in \family(\profile) \setminus \family(\profile')$, which contradicts the assumption that $\family(\profile)=\family(\profile')$. Similarly, if $k < |\decomp|$, then $ B_{k}(\node,T) \cup B_{k+1}(\node,T) \in \family(\profile) \setminus  \family(\profile')$, once again leading to a contradiction. Lastly, if $j=1$ and $k=|\decomp|$, we have  $ B_{k-1}(\node,T) \cup B_{k}(\node,T) \in \family(\profile) \setminus  \family(\profile')$, as they are now interrupted by $B_1(\node, T)$ (we have $k-1>1$ since $k>2$). In all cases, assuming $j<k$ leads to a contradiction. Hence,   $\sigma_{i}'^{\decomp}$ ranks $K_a$ in the $k$th position, implying $\sigma_i^\decomp= \sigma_i'^{\decomp}$ and therefore $\profile^\decomp= \profile'^{\decomp}$. Thus, \Cref{alg:cc-transform} enqueues the same children nodes (and by assumption $K_a$) in both cases. 
            \item[(2b)] $|\decomp|=2$, in this case, $\node$ is a P-node and a Q-node at the same time (Q-nodes with two children are treated identically to P-nodes by \Cref{alg:cc-transform}), therefore we have this case is identical to case (1) above.
        \end{itemize}
    \end{enumerate}

 Therefore, at every step in the PQ-tree, since the clone set that contains $a$ is enqueued when running \Cref{alg:cc-transform} on $\profile$, it will also be enqueued when running \Cref{alg:cc-transform} on $\profile'$. Hence, $a \in f^{CC}(\profile')$, as desired.
\end{proof}    


\begin{lemma}\label{lemma:cc_isda}
If  (neutral) $f$ satisfies ISDA$\ca$ (Def.~\ref{appdef:clone_isda}), then $f^{CC}$ satisfies ISDA$\ca$.
\end{lemma}
\begin{proof}
    Assume $f$ satisfies ISDA$\ca$, and take any profile $\profile \in \mathcal{L}(\cand)^n$ over candidates $A$ and any candidate $a\in A$ such that $a \notin \textit{Sm}(\profile)$ and $\family(\profile \setminus\{a\}) = \family(\profile) - \{a\}$. Denote $\profile'=\profile \setminus\{a\}$. Say $T$ is the PQ-tree of $\profile$ and $\decomp=\{K_1,K_2, \ldots , K_\ell\}=$decomp($A,T$) are children nodes of the root node of $T$. WLOG, say $a \in K_\ell$. Since $\family(\profile') = \family(\profile) - \{a\}$, we have that $\decomp' = \{\clone_1, ... , \clone_\ell \setminus \{a\} \}$ is a clone decomposition with respect to $\profile'$. We will argue $f^{CC}(\profile) = f^{CC}(\profile\setminus \{a\})$ by induction on the depth of the PQ-tree of $\profile$ (say $T$). 

    \noindent\textbf{Base case:} Say $T$ has depth 2 (depth 1 is impossible, since $a \notin \Sm(\profile)$ implies $\profile$ is over at least 2 candidates). In this case, $|K_i|=1$ for each $i \in [\ell]$. If the root is a P-node, this implies $\profile$ has no non-trivial clone sets. Since $\family(\profile') = \family(\profile) - \{a\}$, this implies $\profile'$ also  has no non-trivial clone sets. Then:
    \begin{align*}
        f^{CC}(\profile) =   f(\profile) =f(\profile')=f^{CC}(\profile')  
    \end{align*}
    where the first and last inequality follows from Condition 1 of \Cref{thm:cc_transform} proven above, and the second inequality follows from the assumption that $f$ satisfies ISDA$\ca$. If the root of $T$ is a Q-node (with majority ranking $\sigma$) on the other hand, it must be an untied Q-node (\emph{i.e.}, strictly more voters rank $\sigma$ than 
    its reverrse), otherwise we would have had $Sm(\profile)=A$, which contradicts the assumption that $a\notin Sm(\profile)$. Since $f$ satisfies ISDA$\ca$, we must have $f(\profile^\decomp|_{\{B_1(\node,T),B_2(\node,T)\}} = \{B_1(\node,T)\}$, otherwise removing $B_2(\node,T)\}$, which is not in the Smith set of $\profile^\decomp|_{\{B_1(\node,T),B_2(\node,T)\}}$ would change the election result. Therefore, $f^{CC}(\profile) =  B_1(A,T)$. Since $a$ is not in the Smith set, this implies $K_\ell=\{a\} \neq B_1(B,T)$. Since the removal of $a$ does not change the clone structure, the PQ tree of $\profile'$ (say $T'$) is either a single leaf node corresponding to $B_1(\node, T)$ (if $\ell=2$) or is also a single Q-node with $\ell-1$ children nodes that are all leaves and majority matrix $\sigma \setminus\{a\}$ (if $\ell >2$). Since $a$ did not come first in $\sigma$, this implies  $f^{CC}(\profile')=B_1(A \setminus\{a\},T')= B_1(A,T)= f^{CC}(\profile)$. This finishes the base case.

    \noindent \textbf{Inductive:} Assume that $f^{CC}(\profile)= f^{CC}(\profile')$ if the depth of $T$ is $1,2,\ldots k-1$. Fix a profile $\profile$ such that $T$ has depth $k$. Since $f^{CC}$ satisfies CC by Condition 2 proven above, we have $f^{CC}(\profile) = \gloc_{f^{CC}}(\profile, \decomp)$ and $f^{CC}(\profile') = \gloc_{f^{CC}}(\profile', \decomp')$. Hence, it is sufficent to prove that $\gloc_{f^{CC}}(\profile, \decomp)=\gloc_{f^{CC}}(\profile', \decomp')$. Consider two cases:

    \begin{enumerate}
        \item If $|\clone_\ell| = 1$, then $\clone_\ell=\{a\}$ is a Smith-dominated candidate within $\profile^\decomp$. Moreover, $\decomp'= \{K_1,K_2,\ldots,K_{\ell-1}\}$. Since $\decomp$ correspond to the children of the root node of $T$, the PQ-tree of $\profile^\decomp$ (say $T^\decomp$) is either a single P-node or a Q-node. Since $\profile'^{\decomp'}= \profile^{\decomp} \setminus \{K_\ell\}$, it follows by the base case above that $f^{CC}(\profile^{\decomp}) = f^{CC}(\profile'^{\decomp'})$. Then we have:
        \begin{align*}
            \gloc_{f^{CC}}(\profile, \decomp) = \bigcup_{K \in f^{CC}(\profile^{\decomp}) } f(\profile|_{K})=\bigcup_{K \in f^{CC}(\profile'^{\decomp'}) } f(\profile|_{K})= \gloc_{f^{CC}}(\profile', \decomp')
        \end{align*}
        and we are done.
        \item If $|\clone_\ell| > 1$: Then $\profile^\decomp$ and $\profile'^{\decomp'}$ are isomorphic, where the meta-candidate $K_\ell$ in  $\profile^\decomp$ is replaced with the meta-candidate $K'_\ell=K_\ell \setminus
        \{a\}$ in $\profile'^{\decomp'}$. Consider two options: 
        \begin{enumerate}
            \item[(2a)] $K_\ell \notin f^{CC}(\profile^\decomp)$. Then, by neutrality, we have $f^{CC}(\profile'^{\decomp'})=f^{CC}(\profile^\decomp)$, and we have
            \begin{align*}
            \gloc_{f^{CC}}(\profile, \decomp) = \bigcup_{K \in f^{CC}(\profile^{\decomp}) } f(\profile|_{K})=\bigcup_{K \in f^{CC}(\profile'^{\decomp'}) } f(\profile|_{K})= \gloc_{f^{CC}}(\profile', \decomp').
            \end{align*}

            \item[(2b)] $K_\ell \in f^{CC}(\profile^\decomp)$. Then, by neutrality, we have $f^{CC}(\profile'^{\decomp'})=f^{CC}(\profile^\decomp) \setminus \{K_\ell\} \cup \{K'_\ell\}$. We argue that $\Sm(\profile) \cap K_\ell \neq  \emptyset$. Assume for the sake of contradiction that  $\Sm(\profile) \cap K_\ell =  \emptyset$. Then $K_\ell \notin Sm(\profile^\decomp)$. If the root of $T^\decomp$ is a Q-node, this contradicts $K_\ell \in f^{CC}(\profile^\decomp)$, since it cannot not be $B_1(\decomp, T^{\decomp})$, which is the only enqueued child node since $f$ is ISDA$\ca$. If the root of $T^\decomp$ is a P-node, then by Condition 1 of \Cref{thm:cc_transform}, we have $f(\profile^\decomp) = f^{CC}(\profile^\decomp)$, so $K_\ell \in f(\profile^\decomp)$ violates the assumption that $f$ satisfies ISDA$\ca$, since by definition removing $K_\ell$ (which is not in $Sm(\profile^\decomp)$) will change the outcome. Therefore, we must have  $\Sm(\profile) \cap K_\ell \neq  \emptyset$. By \Cref{lemma:smith_intersect}, this implies  $Sm(\profile) \subset K_\ell$, since $a \in K_\ell \setminus Sm(\profile)$. Then, $a \notin Sm(\profile|_{K_\ell})$. Moreover, the PQ-tree of $\profile|_{K_\ell}$ has depth at most $k-1$. By the inductive hypothesis, this implies that $f^{CC}(\profile|_{K_\ell}) = f^{CC}(\profile|_{K_\ell} \setminus\{a\}) =f^{CC}(\profile|_{K'_\ell})$. Therefore
            \begin{align*}
                \gloc_{f^{CC}}(\profile, \decomp) &= \left(\bigcup_{K \in f^{CC}(\profile^{\decomp}) \setminus\{K_\ell\}} f(\profile|_{K})\right) \cup f^{CC}(\profile|_{K_\ell}) \\
                &= \left(\bigcup_{K \in f^{CC}(\profile'^{\decomp'}) \setminus\{K'_\ell\}} f(\profile|_{K})\right) \cup f^{CC}(\profile|_{K'_\ell}) \\
                &=\bigcup_{K \in f^{CC}(\profile'^{\decomp'}) } f(\profile|_{K})= \gloc_{f^{CC}}(\profile', \decomp').
            \end{align*}
        \end{enumerate}
    \end{enumerate}
    In each case, we have shown that $ \gloc_{f^{CC}}(\profile, \decomp)=  \gloc_{f^{CC}}(\profile', \decomp')$, which, by Condition 2, implies $f^{CC}(\profile)=f^{CC}(\profile')$, thus completing the inductive case.
\end{proof}    

\begin{lemma}\label{lemma:cc_participation}

If (neutral) $f$ satisfies participation$\ca$ (Def.~\ref{appdef:clone_participation}), then $f^{CC}$ satisfies participation$\ca$.
\end{lemma}

\begin{proof}

    Fix any profile $\profile \in \mathcal{L}(\cand)^n$ and any ranking $\sigma_{n+1} \in\mathcal{L}(\cand) $ such that $\family(\profile)=\family(\profile+\sigma_{n+1})$, implying that the PQ tree of both (say $T$ and $T'$, respectively) have the same structure. We denote $\profile'=\profile+\sigma_{n+1}$. Fix a node $\node$ in the PQ-tree that was dequeued by \Cref{alg:cc-transform} at some point when run on input $\profile$. Say $\decomp=$ decomp($B,T$)=decomp($B,T'$) and that $\decomp^* \subseteq \decomp$ are the child nodes that were enqueued by the algorithm. We will show that if \Cref{alg:cc-transform} on input $\profile'$ ever dequeues $\node$, then it will either enqueue $\max_{n+1}(\decomp^*)$ or a child node preferred by $\profile^\decomp_{n+1}$. Consider two cases:
    
    \begin{enumerate}
        \item $\node$ is a P-node. In that case, $\decomp^*=f(\profile^\decomp)$ by construction of \Cref{alg:cc-transform}. Similarly, if dequeued when run on input $\profile'$, \Cref{alg:cc-transform} will enqueue $f(\profile'^\decomp)$. Since $f$ satisfies clone-aware participation, we must have  $\max_{n+1}(f(\profile'^\decomp)) \succeq_{n+1}\max_{n+1}(f(\profile^\decomp))$, so the algorithm does indeed enqueue $\max_{n+1}(\decomp^*)$ or a child node preferred by $\profile^\decomp_{n+1}$. 
        \item $\node$ is a Q-node, with majority ranking $\sigma^*$ over $\decomp$. Moreover, since $\family(\profile)=\family(\profile')$, $\sigma^\decomp_{n+1}$ must either be $\sigma^*$ or its reverse. Consider three subcases:
        \begin{enumerate}
            \item[(2a)] $f(\profile^{\decomp}|_{\{B_1(\node, T), B_2(\node,T)\}})=\{B_1(\node,T)\}$. If $\sigma_{n+1}^\decomp=\sigma^*$, then $\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}}$ is simply $\profile^{\decomp}|_{\{B_1(\node, T), B_2(\node,T)\}}$ with an additional $(B_1(\node, T) \succ B_2(\node, T))$ vote. Since $f$ satisfies participation$\ca$, we must have $f(\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}})=\{B_1(\node,T')\}=\{B_1(\node,T)\}$. Thus $B_{1}(\node,T)$ get enqueued on input $\profile'$, which is the top ranked candidate in $\sigma^\decomp_{n+1}$. If $\sigma_{n+1}^\decomp$ is the reverse of $\sigma^*$, on the other hand, the child node enqueued at $\node$ on input $\profile$ ($B_1(\node,T)$) is the bottom ranked candidate in $\sigma_{n+1}^\decomp$, so it cannot possibly be ranked above the child node enqueued at $\node$ on input $\profile'$.
            \item[(2b)] $f(\profile^{\decomp}|_{\{B_1(\node, T), B_2(\node,T)\}})=\{B_2(\node,T)\}$. If $\sigma_{n+1}^\decomp=\sigma^*$, the child node enqueued at $\node$ on input $\profile$ ($B_{|\decomp|}(\node,T)$) is the bottom ranked candidate in $\sigma_{n+1}^\decomp$, so it cannot possibly be ranked above the child node enqueued at $\node$ on input $\profile'$. If $\sigma_{n+1}^\decomp$ is the reverse of $\sigma^*$, on the other hand, $\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}}$ is simply $\profile^{\decomp}|_{\{B_1(\node, T), B_2(\node,T)\}}$ with an additional $(B_2(\node, T) \succ B_1(\node, T))$ vote. By assumption $f$ satisfies participation$\ca$; thus, we must have $f(\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}})=\{B_2(\node,T')\}=\{B_2(\node,T)\}$. Thus $B_{|\decomp|}(\node,T)$ get on input $\profile'$, which is the top ranked candidate in $\sigma^\decomp_{n+1}$.
            \item[(2c)] $f(\profile^{\decomp}|_{\{B_1(\node, T), B_2(\node,T)\}})=\{B_1(\node,T),B_2(\node,T)\}$. If $\sigma_{n+1}^\decomp=\sigma^*$, $\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}}$ is simply $\profile^{\decomp}|_{\{B_1(\node, T), B_2(\node,T)\}}$ with an additional $(B_1(\node, T) \succ B_2(\node, T))$ vote. Since $f$ satisfies participation$\ca$, we must have $B_1(\node,T') \in f(\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}})$. Thus $B_{1}(\node,T)$ is one of the child nodes that get enqueued on input $\profile'$, which is the top ranked candidate in $\sigma^\decomp_{n+1}$. If $\sigma_{n+1}^\decomp$ is the reverse of $\sigma^*$, on the other hand, $\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}}$ is simply $\profile^{\decomp}|_{\{B_1(\node, T), B_2(\node,T)\}}$ with an additional $(B_2(\node, T) \succ B_1(\node, T))$ vote. Since $f$ satisfies participation$\ca$, we must have $B_2(\node,T)\in f(\profile'^{\decomp}|_{\{B_1(\node, T'), B_2(\node,T')\}})$. Thus $B_{|\decomp|}(\node,T)$ is one of the child nodes that get enqueued on input $\profile'$, which is the top ranked candidate in $\sigma^\decomp_{n+1}$.
        \end{enumerate}
    \end{enumerate}
    
    In each case, we see that if \Cref{alg:cc-transform} is considering $\node$ when run on $\profile'$, it will either enqueue $\max_{n+1}(\decomp^*)$ or a child node strictly preferred by $\profile^\decomp_{n+1}$. 
    
    Say $B$ is the root node $(A)$, which is indeed dequeued by the algorithm  when run on either input. If a $K \succ \max_{n+1}(\decomp^*)$ is enqueued (\emph{i.e.}, a strictly preferred child node) when run on input $\sigma'$, then we are done, since this implies $f^{CC}(\profile') \cap K \neq \emptyset$ and each element of $K$ is preferred to all elements in $f^{CC}(\profile)$ by $\sigma_{n+1}$. Otherwise,  $\max_{n+1}(\decomp^*)$ must have been enqueued, and we can apply the same argument to that node, since it will be considered by the algorithm on both inputs. We repeat following the $\max_{n+1}(\decomp^*)$ on each step until we reach a strictly preferred child node that is enqueued, or we reach a leaf node, in which case $\max_{n+1}(f^{CC}(\profile))= \max_{n+1}(f^{CC}(\profile'))$. In either case, we have $\max_{n+1}(f^{CC}(\profile')) \succeq_{n+1} \max_{n+1}(f^{CC}(\profile'))$, proving $f^{CC}$ satisfies participation$\ca$. 
    \end{proof}    

Together \Cref{lemma:cc_condorcet,lemma:cc_smith,lemma:cc_decisive,lemma:cc_mono,lemma:cc_isda,lemma:cc_participation} prove Condition 4 of \Cref{thm:cc_transform}.

\paragraph{Condition 5.}
We analyze the running time of Algorithm 1: CC transformation for SCF $f$.
First, we construct the PQ-tree $T = PQ(\profile)$ for $\sigma$.
By Lemma~\ref{lemma:pq-poly} (shown by \citet{Cornaz13:Kemeny}), this requires $O(nm^3)$ time.
Next, whenever Algorithm~\ref{alg:cc-transform} encounters a node $B$ that is of type P-, it runs $f$ on $\profile^\mathcal{K}$, where $\mathcal{K} = \mathrm{decomp}(B, T)$. 
By definition of $\delta(T)$, we can upper bound the runtime of running $\profile^\mathcal{K}$ for each node $B$ of type P- by $g(n, \delta(T))$.
Hence, overall, this requires at most $|\mathcal{P}| \cdot g(n, \delta(T))$ runtime, where recall that $\mathcal{P}$ denotes the set of P-nodes in PQ-tree $T$.
On the other hand, whenever Algorithm~\ref{alg:cc-transform} encounters a node $B$ that is of type Q-, it only runs $f$ on the first two child nodes; \emph{i.e.}, it runs $f$ with at most two candidates. 
Again by definition of function $g$, each encounter of a Q-node in Algorithm~\ref{alg:cc-transform} thus adds a running time of at most $g(n, 2)$. 
Overall, this requires $|\mathcal{Q}| \cdot g(n, 2)$ runtime, where $\mathcal{Q}$ denotes the set of Q-nodes in PQ-tree $T$. 

Hence, the total runtime of Algorithm~\ref{alg:cc-transform} is $O(nm^3) + |\mathcal{P}| \cdot g(n, \delta(T)) + |\mathcal{Q}| \cdot g(n, 2)$.
By definition of $\delta(T)$, and excluding the trivial case where $m=1$, it follows that $\delta(T) \geq 2$, and thus $g(n, 2) \leq g(n, \delta(T))$.
Moreover, since all nodes of a PQ-tree are of either type P- or type Q-, it follows that $|\mathcal{P}| + |\mathcal{Q}| \leq m$, as the number of internal nodes in a tree with $m$ leaves is bounded by $m$. 

Therefore, the total running time of Algorithm~\ref{alg:cc-transform} is upper bounded by $O(nm^3) + m \cdot g(n, \delta(T))$. 

\end{proof}

