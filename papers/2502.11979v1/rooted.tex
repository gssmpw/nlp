\label{sec:rooted}

\newcommand{\Crounding}{4}

In this section, we define a simpler variant of our problem and present a polynomial-time constant factor approximation algorithm for it, which will be a building block of the main algorithm.

\begin{definition}
    An instance of our problem on a grid graph $G$ with driver multiset $B$ is \emph{rooted} if one of the vertices in the top row of $G$ (the \emph{root}, denoted $r$) is an endpoint of every path desired by drivers in the multiset $B$.
\end{definition}

We will prove the following:

\begin{lemma}
\label{rooted_rev}
    Assume a fixed grid width $\omega$. For any rooted instance with maximal revenue $\mathrm{OPT}_r$, a~price assignment generating at least $\frac{\mathrm{OPT}_r}{\Crounding}$ in revenue can be found in polynomial time.
\end{lemma}

\subsection{Rounding}
\label{sect:rounding}

One of the crucial techniques used throughout the algorithm is price rounding.
Let us formalize the underlying observation.

\input{rounding_lemma.tex}

By this lemma we can restrict our attention to prices from $\mathcal{P}$.
An important consequence of this is that the costs of paths in $G$ will always be multiples of
$p_{min} = \frac{b_{max}}{2^{\ceil{\log \bra{4 m \cdot \abs{B}}}}}$.
Another observation is that once a distance between any two vertices in $G$ exceeds $b_{max}$, 
it does not matter how much it is exactly, because no driver will ever choose this path anyway.
Thus, we will unify all paths with total cost exceeding $b_{max}$ and treat them as if they had cost $\infty$.
Hence, we can restrict our attention to distances that are $\infty$, $0$ or multiples of $p_{min}$ not exceeding $b_{max}$.
This yields a polynomial upper bound on the number of possible distances between two vertices of $G$,
which allows us to use distances as state descriptions in the dynamic programming.

\subsection{Assume-Implement Dynamic Programming}

Before we proceed to the description of the algorithm, assume we index rows of $G$ top to bottom and introduce some notation:
\begin{itemize}[nosep]
\item $R_i$ -- the set of vertices in the $i$-th row of $G$.
\item $G_i$ -- the subgraph of $G$ consisting of vertices from rows $i$ and $i+1$ and edges in the $i$-th row and between rows $i$ and $i+1$.
\item $B_{R_i}$ -- the multiset of drivers whose desired paths start in $R_i$.
\end{itemize}

Let us consider a subgrid $H$ consisting of some consecutive rows of $G$.
For the purpose of paths that only pass through $H$ (have endpoints either outide of $H$ or on its boundary),
we do not need to consider all the edges inside $H$.
It is enough to consider the distances between the vertices on the boundary of $H$.
In some parts of the algorithm we will assume these distances to be equal to certain values and
then construct price assignments inside $H$ that fulfill those assumptions.
The following concept allows us to formalize the assumptions on pairwise distances for a set of vertices.

\begin{definition}
    \label{def:distance_matrix}
    Given a grid $H$ and a subset $S$ of its vertices,
    a \emph{distance matrix} for $S$ is an $\abs{S} \times \abs{S}$ matrix $D$ indexed by vertices from $S$,
    where $D_{a, b}$ is the assumed distance, i.e. sum of weights along a cheapest path, between $a$ and $b$ in $H$.

    We will say that a certain edge-weighting \emph{realizes} a distance matrix if it satisfies the above condition
    (for all $a, b \in S$, $D_{a,b}$ is actually equal to the distance between $a$ and $b$ in $H$).

    \textbf{Note:}~We will frequently consider $H$ to be a subgraph of the (weighted) grid $G$.
    In that case the distance matrix describes the cheapest paths in $H$ and not $G$.
    Even though under some weight assignments $G$ may contain shorter paths between vertices in $S$.
\end{definition}

In the algorithm we will often have to merge two graphs into a single one.
We will be interested in knowing the distances in the union of the two graphs
based on assumptions about the distances in the original graphs.
The following formalizes this operation.

\begin{definition}
\label{def:dist_product}
Let $G_A$ and $G_B$ be two same-width edge-disjoint weighted grids with (possibly) some edges missing that share a common row with vertex set $R$ that is the top row of one and the bottom row of the other.
Let $A$ and $B$ be distance matrices for vertices $S_A$ in graph $G_A$ and $S_B$ in $G_B$, such that $R \subseteq S_A \cap S_B$.
Then, the \textbf{product} of $A$ and $B$, denoted $A \dpro{} B$, is a distance matrix $C$ for $S_A \cup S_B$ that
describes the distances in (is realized by) the union of $G_A$ and $G_B$
under the assumption that $A$ and $B$ are realized.

Sometimes, in order to limit the dimensionality, we will want the product of $A$ and $B$
to be defined only for a certain subset $S \subseteq S_A \cup S_B$, in which case we write $A \dpro{S} B$.
\end{definition}

Note that the product of two distance matrices is well-defined:
because $R$ is a separator of $G_A$ and $G_B$, any shortest path between two vertices from $S_A \cup S_B$ can be partitioned into segments whose lengths are determined by either $A$ or $B$.
Thus, $A$ and $B$ already determine all pairwise distances in $S_A \cup S_B$ in $G_A \cup G_B$.

Each state of the dynamic program corresponds to a certain ($i$-th) row of the grid
and two distance matrices (\cref{def:distance_matrix}):
\begin{itemize}[nosep]
\item \emph{lower matrix} $L$ --
a distance matrix for $R_i$ in the part of $G$ below and including row $i$,
\item \emph{upper matrix} $U$ --
a distance matrix for $R_i \cup {r}$ in the grid above row $i$ excluding edges in of the $i$-th row.
This is the matrix on which we use the assume-implement technique.
\end{itemize}
Thanks to the rounding technique, we can restrict out attention to distance matrices
with values equal to $0$, $\infty$ or a multiple of $p_{min}$ as argued in \cref{sect:rounding}.

The value of $dp_{i, L, U}$ is defined as the maximum revenue generated by the drivers
whose non-root endpoint lies on or below row $i$ under a price assignment
to the edges in $i$-th row and below that realizes the matrix $L$ and assuming that
the price assignment to the edges above row $i$ realizes the upper matrix $U$.
If the lower matrix is not feasible (there does not exist a weight assignment realizing it),
we set $dp_{i, L, U} := -\infty$.
Note that we do not treat the upper matrix this way, because
for the sake of this particular state of the dynamic program we assume that a price assignment realizing it exists.
Correctness is guaranteed since this assumption is contained in the description of the state and checked at every step.

The values of $dp_{i, L, U}$ are computed bottom-up and naively, i.e. for each state we consider
all possible states from the previous row and all possible price assignments $w: E(G_i) \rightarrow \roundedSet$.
That is, we check all ways of pricing the edges in $i$-th row and those between the current and the previous row.
At each level we include the revenue from the drivers whose desired paths start in $R_i$ ($B_{R_i}$).
For convenience, we write weight assignments as distance matrices for $R_i \cup R_{i+1}$.
Let $\mathcal{W}_i$ denote the set of such distance matrices realized by $G_i$ with all assignments $w: E(G_i) \rightarrow \roundedSet$.
Then, $dp_{i, L, U}$ equals:%
%
\begin{equation}
\label{eq:dp}
dp_{i, L, U} \hspace{0.27cm} := \hspace{-0.75cm} 
\max_{
    \begin{array}{c} W \in \mathcal{W}_i, L', U', \; s.t. \\
    L' \dpro{R_i} W = L \\
    U \dpro{R_{i+1} \cup \set{r}} W = U' \end{array}} \hspace{-0.95cm}
    dp_{i+1, L', U'}
    \hspace{0.45cm} + \hspace{-0.55cm}
    \sum_{
    \begin{array}{c} (v, r, b) \in B_{R_i}, \; s.t. \\
    b \geq \bra{L \dpro{} U}_{r, v} \end{array}}
    \hspace{-0.95cm}\bra{L \dpro{} U}_{r, v}
\end{equation}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.65\textwidth]{dp_colors}
    \caption{
        Dynamic programming states for row $i+1$ (left) and $i$ (right).
        For reference, here $i = 2$.
        Black dotted edges represent the graph $G_i$.
        Black vertices marked with asterisks are
        non-root endpoints for the drivers in $B_{R_i}$ -- those are exactly the drivers from the sum in \cref{eq:dp}.
    }

\end{figure}

The left term denotes the best revenue that can be achieved by the
drivers from rows below $i$ assuming the distance matrices $L$ and $U$ are realized.
It is a maximum over all possible lower and upper distance matrices
$L'$ and $U'$ for the previous row and each possible way $W$ to price the edges in $G_i$.
Here we only consider the combinations that are consistent with distance matrices $L$ and $U$:
% , i.e.:
\begin{itemize}[nosep]
\item $L' \dpro{R_i} W = L$ : price assignments to edges from rows $i+1$ and below realizing the matrix $L'$ extended by $W$ realize the matrix~$L$,
\item $U \dpro{R_{i+1} \cup \set{r}} W = U'$ : price assignments to edges above row $i$ realizing $U$ extended by $W$ realize the matrix~$U'$.
\end{itemize}
% \ajnote{The following two paragraphs are new.}
Note that $E(G_i) = E(L) \setminus E(L')$ and $E(G_i) = E(U') \setminus E(U)$, where $E(M)$ denotes the edges of the graph corresponding to the matrix $M$.
Thus, it is clear that by pricing $E(G_i)$ we extend the lower matrix $L'$ to $L$ and the upper matrix $U$ to $U'$.
In other words, as we move up through the rows the graph for the lower matrix, for which the solution is already constructed, grows.
On the other hand, the graph for the upper matrix shrinks, which highlights the ``implement'' aspect of the assume-implement technique:
the solution for the upper part of the grid that has been assumed (by $U'$) in a state for the previous row
is partially implemented by the price assignment to $E(G_i)$ while the remaining part still remains assumed by $U$.

The right term is the revenue from the drivers in $B_{R_i}$
(each driver contributes the distance between her endpoints provided it does not exceed her budget).
Note that $U \dpro{} \mathit{L}$ is a distance matrix describing the whole grid $G$ with respect to $R_i \cup \set{r}$, so
for each $v \in R_i$ we know that $\bra{L \dpro{} U}_{r, v}$ is the distance from $r$ to $v$ in $G$ under any weight assignment
realizing $L$ and $U$.
This highlights the other aspect of the assume-implement technique ---
in order to calculate the revenue of the drivers in the current row, we need knowledge of
the prices of the edges in row $i$ and below (the lower matrix), which are already constructed,
as well as the price of edges above row $i$ (the upper matrix), which are not part of the solution
for the current state of the dynamic program.
The lower matrix is already known because the solution is constructed bottom-up.
The upper matrix is assumed (the ``assume'' aspect of the assume-implement technique), so that we have
all the necessary information to process drivers in the current row.

The values of $dp$ for the bottom row are initialized to the revenue from the respective
drivers for all upper matrices and feasible lower matrices as follows:
\[ dp_{n, L, U} := \sum_{
    \begin{array}{c} (v, r, b) \in B_{R_n}, \; s.t. \\
    b \geq \bra{L \dpro{} U}_{r, v} \end{array}}
    \bra{L \dpro{} U}_{r, v} \]
A lower matrix is feasible if there exists a weight assignment realizing it.
In this case, the lower matrix is describing a single row of the grid,
so this condition can easily be checked by naively iterating over all weight assignments
to the edges inside $R_n$ ($\abs{R_n} = \omega$).

The algorithm obtains the revenue $\max_{L} dp_{1, L, U_{\infty}}$, i.e.
chooses the biggest revenue among the lower matrices and the
infinite upper matrix $U_{\infty}$ which has $0$'s on the main diagonal and $\infty$'s elsewhere.
It is because the upper matrices for the top row by definition describe an empty graph.
$\max_{L} dp_{1, L, U_{\infty}}$ is also the optimal revenue under the assumption that all edge prices are rounded (belong to $\roundedSet$).
This follows from the definition of the $dp$ values and the fact that for each rounded price assignment there exists a distance matrix realized by it.
Thus, by the Rounding Lemma, $\max_{L} dp_{1, U_{\infty}, L} \geq \frac{\mathrm{OPT}_r}{\Crounding}$.

The price assignment itself can retrieved by a simple backtracking procedure, because
the algorithm stores $W$ and the best previous state from \cref{eq:dp}
alongside the values of $dp$.

\begin{lemma}
    The above algorithm runs in polynomial time.
\end{lemma}
\begin{proof}
    The number of states in the dynamic programming is bounded by a product of $m$ (the number of rows in $G$) and the numbers of possible lower and upper matrices.
    The upper and lower matrices are respectively of size $(\omega + 1) \times (\omega + 1)$, and $\omega \times \omega$,
    both of which are constant because we are working on a bounded-width grid.
    As discussed in \cref{sect:rounding}, the number of possible distance values is polynomially bounded.
    Hence, the number of different matrices and thus the number of states is polynomially bounded.

    Calculating the value of each state is also done in polynomial time.
    As we have already shown, the number of different matrices $U'$ and $L'$ is polynomially bounded.
    $\abs{\mathcal{W}_i}$ is also polynomially bounded, because we assign a polynomial number of weights (from $\roundedSet$) to a constant ($2\omega - 1$) number of edges.
    The same reasoning applies to the initializaton of the $dp$ for the bottom row.

    Since the number of states is polynomially bounded and the time to calculate the value of each state is polynomial, the algorithm runs in polynomial time.
\end{proof}

The above algorithm can be easily extended to work with incomplete grids (i.e. grids where some of the edges are missing).
Such a grid can be modeled as a complete grid, where we require some of the edges to have infinite weight ($b_{max}+1$).
Because no driver will be able to afford such edges, they will never be used in the produced solution -- as if they were not present.
On the other hand, the remaining edges are priced and sold as usual.
We enforce this condition by changing the $\mathcal{W}_i$ set from \cref{eq:dp} to model
price assignments $w: E(G_i) \rightarrow \roundedSet \cup \set{\infty}$ such that all edges not present in the incomplete grid are assigned $\infty$.
Note that now $\mathcal{W}_i$ sets will be different for particular rows because the set of missing edges is different for each row.
Both correctness and polynomial time complexity follow from the previous discussion.
