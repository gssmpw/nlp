In this section, we formalize our problem statement and describe two baseline approaches. Fig. \ref{fig: approaches} provides an illustration of the two baseline approaches and the proposed method. 

\begin{figure*} [t]
  \centering
  \includegraphics[width=6.9in]{figures/illustration.pdf}
  %\vspace{-5mm}
  \caption{An illustration of the three approaches described in this paper and evaluated in our experiment.}
  \label{fig: approaches}
  \vspace{-7mm}
\end{figure*}

\vspace{-2mm}
\subsection{Problem Formulation} 
\vspace{-1mm}

% Consider a surface represented by a triangle mesh $\mathcal{M}{=}(V, E)$, where $V{=}\{\mathbf{p}_1, \mathbf{p}_2, ..., \mathbf{p}_n\}$ are the vertices and $E$ represents the edges. 

The coverage problem is defined on a surface mesh represented as a connected triangle mesh $\mathcal{M}{=}(V, E)$, where $V{=}\{\mathbf{p}_1, \mathbf{p}_2, ..., \mathbf{p}_n\}$ are the vertices and $E$ represents the edges. 
The number of vertices $n$ defines the level of discretization of the surface. We assume that the vertices are sampled densely enough to accurately represent the shape of the surface and that visiting all vertices is sufficient to cover the surface.
For each vertex $\mathbf{p}_i {\in} \mathbb{R}^3$, we compute its normal vector $\mathbf{n}_i {\in} \mathbb{R}^3$, such that $\lVert \mathbf{n}_i \lVert_2 {=}1$.
%The computed normal $\mathbf{n}_i$ provides the orientation for the end-effector to ensure that it aligns with the surface's local geometry as it traverses the mesh.
We define the \textit{end-effector target} at each vertex as $\mathbf{x}_i{=}(\mathbf{p}_i, \mathbf{n}_i)$, where $\mathbf{x}_i {\in} \mathbb{R}^3 {\times} S^2$. This target provides the position and orientation constraints for the end-effector in 5 degrees of freedom (DoF). 
For a manipulator with $k$ DoF, whose joint configuration is represented by $\mathbf{\theta} {\in} \mathbb{R}^k$, the robot is considered redundant if $k{>}5$.
In addition, the application may allow certain tolerances, \textit{i.e.}, allowable position or rotation inaccuracy.  

The goal of this work is to generate a joint space path $\boldsymbol{\xi} {=} \{\mathbf{\theta}_1, \mathbf{\theta}_2, ..., \mathbf{\theta}_n \}$ that drives the robot's end-effector to visit all end-effector targets on the surface exactly once while minimizing specific costs in joint space. The primary objective is to minimize the number of arm reconfigurations, with the secondary goal of reducing overall joint movements.
We assume that between $\mathbf{\theta}_i$ and $\mathbf{\theta}_{i+1}$ the robot can either linearly move in its joint space or needs to perform an arm reconfiguration using a motion planner. 


\vspace{-3mm}
\subsection{Baseline 1: Cart-TSP-IKLink} \label{sec:cart-tsp}
\vspace{-1mm}

We adapt Cart-TSP-IKLinK from prior work \cite{hess2012null, suarez2018robotsp}, incorporating IKLink \cite{wang2024iklink} for the final path following step. This approach constructs a graph in Cartesian space, uses a Traveling Salesman Problem (TSP) solver to find paths that visit each node exactly once, and generates joint motions to track the paths using IKLink. 

\textit{Step I: Construct a Cartesian Graph} --- The Cartesian graph shares the same nodes and edges as the input surface mesh. The edge weights are determined by a combination of the positional and rotational distances.
\vspace{-2mm}
\begin{equation}
    \Delta(\mathbf{x}_i,\mathbf{x}_j) = \lVert \mathbf{p}_i - \mathbf{p}_j \lVert_2 + \alpha \cdot \text{arccos}(\frac{\mathbf{n}_i \cdot \mathbf{n}_j}{\lVert\mathbf{n}_i\lVert_2\lVert\mathbf{n}_j\lVert_2})
    \label{eq:cartesian_dist}
\vspace{-1mm}
\end{equation}
where $\alpha$ is a parameter, set to $\alpha{=}0.1$ in our implementation. 

\textit{Step II: Solve TSP} ---
As discussed in \cref{sec:gtsp}, the solution of TSP is a \textit{cycle}, from which we extract a \textit{path}. We introduce a dummy node to the graph, connected to all other nodes with zero-weight edges, and then convert a TSP solution to a path by removing the dummy node. In this work, we use the LKH \cite{helsgaun2000effective} solver to iteratively find TSP routes, which are then converted into paths.  

\textit{Step III: Track Cartesian Path (using IKLink)} ---
We use IKLink \cite{wang2024iklink} to generate joint movements that move the end-effector along the paths found in Step II. IKLink enables a robot to track Cartesian paths with minimal reconfigurations and joint movements. The method involves two stages: first sampling $m$ IK solutions for each end-effector pose ($m{=}100$ in our implementation), then applying a dynamic programming algorithm to find joint movements with minimal configurations and joint movements. As shown in Fig \ref{fig: approaches}, we perform IK sampling once and then run the dynamic programming algorithm for each found path. 

\textit{Analysis} --- 
Cart-TSP-IKLink solves the TSP on a graph with $n$ nodes, making it relatively efficient. This approach finds optimal paths in Cartesian space and is ideal for objectives such as minimizing end-effector movements. However, an optimal path in Cartesian space may result in suboptimal paths in joint space. Therefore, Cart-TSP-IKlink may generate motions that involve frequent reconfigurations or large joint movements, which we will demonstrate in \cref{sec:evaluation}.


\vspace{-3mm}
\subsection{Baseline 2: Joint-GTSP} \label{sec:joint_gtsp}
\vspace{-1mm}

%In contrast to the Cart-TSP-IKLink method, which solves TSP on a Cartesian graph, 
Joint-GTSP implements the approach of prior work \cite{hess2012null, kaljaca2020coverage, zhang2024jpmdp}, framing the coverage path planning problem as a Generalized Traveling Salesman Problem (GTSP) in joint space. 
This method consists of three steps: sampling multiple inverse kinematics (IK) solutions for each end-effector target, constructing a graph where nodes represent IK solutions, and finding paths in the graph using a GTSP solver. 

\textit{Step A: Sample IK Solutions} ---
We sample $m$ IK solutions $\{\theta^1_i, \theta^2_i, ...\}$ for each end-effector target $\mathbf{x}_i$ by uniformly sampling initial joint configuration from the robot's joint space. We set $m{=}100$ in our implementation. An optimization-based IK solver, RangedIK \cite{wang2023rangedik}, is used to find IK solutions that are close to the randomly sampled initial configurations. Similar to prior work \cite{wang2024iklink}, we then use DBSCAN \cite{ester1996density} to merge similar IK solutions to reduce the size of the graph.

\textit{Step B: Construct Joint Graph} ---
These IK solutions are used as nodes to construct a graph in joint space. 
All IK solutions for an end-effector target are grouped in a set.
Two IK solutions are connected if their corresponding end-effector targets $\mathbf{x}_i$ and $\mathbf{x}_j$ are neighbors in the input mesh, \textit{i.e.}, $(i,j) {\in} E$. The edge weights are the cost to move between two robot configurations:
    \vspace{-2mm}
\begin{equation}
    w(\mathbf{\theta}_i^a, \mathbf{\theta}_j^b){=} 
    \begin{cases}
        \lVert \mathbf{\theta}_i^a {-} \mathbf{\theta}_j^b \lVert&\text{if } (i.j) {\in} E \text{ and } r(\mathbf{\theta}_i^a, \mathbf{\theta}_j^b ) \\
        M              &\text{if } (i.j) {\in} E \text{ and not }  r(\mathbf{\theta}_i^a,\mathbf{\theta}_j^b ) \\
        \infty & \text{otherwise} 
    \end{cases}
    \vspace{-2mm}
\end{equation}
where $r(\theta^a_i, \theta^b_j)$ decides whether a reconfiguration is required between joint configurations $\theta^a_i$ and $\theta^b_j$. If a reconfiguration is required, a large value $M$ is assigned as the edge weight. 
The function $r(\theta^a, \theta^b)$ returns true if 1) their corresponding end-effector targets are far apart, \textit{i.e.}, $\Delta(\mathbf{x}_i, \mathbf{x}_j) {>} \tau_1$, 2) the maximum joint movement exceeds a threshold, \textit{i.e.,} $\max_k( |\theta_i^a[k] {-} \theta_j^b[k]|) {>} \tau_2$, or 3) the linear interpolation between IK solutions deviates from the end-effector targets, \textit{i.e.},  $\Delta(\text{FK}(\theta), \mathbf{x}_i){>}\tau_3$ or $\Delta(\text{FK}(\theta), \mathbf{x}_j){>} \tau_3$, where $\text{FK}(\cdot)$ is the robot's forward kinematics function, $\mathbf{\theta}{=}\text{lerp}(\theta^a_i, \theta^a_i, t)$ is a linearly interpolated joint configuration and $t {\in} (0,1)$ is the interpolation parameter.   

\textit{Step C: Solve GTSP} --- To find paths that visit each set in the constructed graph exactly once, we introduce an additional node with its own set, connected to all other nodes with zero-weight edges. A GTSP route (a cycle) is converted to a joint path by removing the additional node.

\textit{Analysis} --- The Joint-GTSP approach solves GTSP on a graph with $nm$ nodes, where $n$ is the number of end-effector targets and $m$ is the average number of IK sampling for each end-effector target. Solving an NP-hard problem on a large graph, this approach is slow and does not scale well to large inputs. Many modern GTSP solvers trade solution quality for speed, producing sub-optimal results in shorter timeframes. 


