\section{Representations of Categories}





%\begin{figure}\centering\includegraphics[width=0.8\textwidth]{figures/ex01.jpg}\caption{This example illustrates the main idea to produce three schemas of different data. Figure B illustrates that the transitive dependency will not be materialized in a graph.  Since student $\rightarrow$ Department and  Department  $\rightarrow$ DepartmentHead, student $\rightarrow$ DepartmentHead. Therefore, there is no edge between student and DepartmentHead.}\label{fig:exampleAB}\end{figure}

%\begin{figure}\centering\includegraphics[width=0.8\textwidth]{figures/composedarrows.jpg}\caption{Illustration to removing the composed arrows. }\label{fig:composedarrows}\end{figure}

%\begin{figure}\centering\includegraphics[width=0.6\textwidth]{figures/exa03.jpg}\caption{This example illustrates the fifth normal form. We do not need the SPJ table.  This example shows that SPJ is a join limit from three relation SP, PJ and SJ, which will generate the SPJ relation by three table joins.  This limit says that whenever a supplier s supplies part  p, and a project j uses part p, and the supplier s supplies at least one part to project j, then supplier will also be supplying part p to project j. }\label{fig:exampleD}\end{figure}

%\begin{figure}\centering\includegraphics[width=0.6\textwidth]{figures/SPJData.jpg}\caption{This figure shows the example data for the join of three tables, then the last table is the limit table.}\label{fig:SPJData}\end{figure}

%The categorical framework provides a unified view of multi-mode data. In this section, we demonstrate the usefulness of this framework to output the normalized schema for different types of data.


%including composed morphisms. In this paper, we only consider a category with a finite number of objects and arrows, but each object may contain an infinite number of elements \cite{hirst1993completeness}, which is connected with some application areas that involve streaming or temporal data.  since a complete representation is often unnecessary as some arrows (e.g. composed arrows) or objects are derivable from others. 

%\begin{figure}\centering\includegraphics[width=0.7\textwidth]{figures/ideas.jpg}\caption{Illustration to then main workflow for the optimization and output }\label{fig:ideas}\end{figure}

%Given a category $\mathcal{C}$, its representation is a directed graph, denoted as $\mathcal{G}(C)$, consisting of vertices and arrows, where the vertices correspond to the objects and the arrows indicate the functions between these objects (sets). A representation may not necessarily include  all the objects and morphisms in a given category. For instance, the composed arrows and identity arrows may be ignored in a representation without losing any information. In this section, we leverage the inference rules of functional dependencies and multivalued dependencies to derive two levels of reduced representation for categories. This reduced representation is a condensed representation that intentionally ignores some selected objects and morphisms with the properties of both sound and complete, meaning that it can accurately capture or derive all the morphisms and objects of $\mathcal{C}$. Later  we then can establish a connection between the reduced representation and the hierarchy of the database normal form theory, as discussed in Section 5.

%In this section, we will build the link between the reduced representation of categories and the normal form theory of databases, which presents an innovative  approach to define the  principles of normal forms in multi-model databases.

%This endeavor unfolds an innovative  approach to define the  principles of normal forms in multi-model databases.


%In the following three sections, we aim to establish a connection between the reduced representations of categories and the framework of normal forms in databases. To achieve this, 

In this section, we design two levels of reduced representations for categories. 


%as illustrated in Figure \ref{fig:reduced}, which serve as a condensed form by eliminating derivable objects and morphisms. 

%We will explicitly show the connection of these two reduced representations and normal form theory in databases in Section 6.  


%As mentioned in Section 2.1, strictly speaking, a category is beyond a graph with composed arrows. However, for the purpose of visual representation, we still can use a directed graph $G$ to represent a category $\mathcal{C}$ by omitting the composed arrows.  

%$G$ may not necessarily include all the objects and morphisms in $\mathcal{C}$. For example,

%Further,    identity arrows can also be omitted from the representation without any loss of information.

%A representation $G$ of a category $\mathcal{C}$ can be a directed graph. It is important to note that $G$ may not necessarily include all the objects and morphisms in $\mathcal{C}$. For example, composed arrows and identity arrows can be omitted from the representation without any loss of information. In this section, we derive two levels of reduced representations for categories, as illustrated in Figure \ref{fig:reduced}. These reduced representations serve as a condensed form intentionally ignoring redundant objects and morphisms. 

%We establish an intriguing connection between the reduced representations and the hierarchy of the database normal form theory, as discussed in Section 5. This connection sheds light on a new perspective of multi-model database normal form theory through the lens of category theory. 

%For the sake of simplicity, certain elements may be excluded from a representation without compromising the information it conveys. For example, composed arrows and identity arrows can be omitted from the representation without any loss of information. This selective omission allows for a more concise depiction of the category.




%Despite the omissions, it possesses the properties of being both sound and complete. This implies that the reduced representation accurately captures or derives all the morphisms and objects of $\mathcal{C}$.



%By developing a reduced representation for categories and exploring its correlation with database normal form theory, we advance our comprehension of category theory and its practical applications in the realm of databases.


%Given a category, we may convert it to a complete graph representation, where all objects and morphisms correspond to the nodes and vertexes in the graph. It is feasible as the limited number of objects and the single morphism between any two objects. 

%However, it is often not feasible to enumerate all the objects and morphisms in a given category. For instance, in a monoidal category, the presence of a loop morphism may lead to an infinite number of composed morphisms. To address this issue, this section focuses on studying a reduced representation $\mathcal{R}$ of a category $\mathcal{C}$.




%Furthermore, in relational databases, given a relational schema and a set of constraints (e.g. functional dependency and join dependency), there are different algorithms to decompose this relation to a good schema to satisfy different levels of normal forms. Analogously, given a category, we will introduce three levels of reduced representations, as illustrated in Figure \ref{fig:reduced}. These three levels enable the creation of a hierarchical structure of concise representations for categories. The significance of this hierarchical structure becomes evident when we establish a connection between it and the hierarchy of the database normal form theory, as discussed in Section 5. 

%This intriguing connection sheds light on the relationship between the reduced representations of categories and the normal form theory,

%that enable the creation of a hierarchy of concise representations of categories,   We will establish a fascinating connection between this hierarchy of reduced representations and the hierarchy of the normal form theory in Section 5.    


%A complete enumeration of  all objects and morphisms in a $\mathcal{C}$ is sometimes impossible. For example, consider the loop morphism in a category with an object (i.e. a monoidal category  ), there are possibly infinite numbers of composed morphisms.

%In this paper, we study a reduced (concise) representation $\mathcal{R}$ of a category $\mathcal{C}$, which is sound and complete, in the sense that all morphisms and objects of $\mathcal{C}$ can be correctly derived from $\mathcal{R}$. 


%Enhance with injective, surjective properties:FD 4: If $X \to Y$ and $X \to Z$, and $X \to Y$ is a subjective function, then $X \to Z$. FD 5: If $X \to Z$ and $Y \to Z$, and $Y \to Z$ is an injective function, then $X \to Y$.



\subsection{First Reduced Representation}
\label{subsec:1RR}

%In a relational database setting, given a set F of FDs, numerous other functional dependencies can be inferred or deduced from the FDs in F. We call them implied functional dependencies. There are three well-known inference rules for functional dependencies, called Amstrong's axioms: FD 1: If $Y \subseteq X$, then $X \to Y$; This says that every two objects which have containment relationship, then there is a projection arrow between them. FD 2: If $X \to Y$, then $XZ \to YZ$; In particular, given an element $(x,z) \in XZ$, we define that $(y,z) \in YZ$ and $(y,z)$ is the image of   $(x,z)$. FD 3: If $X \to Y$ and $Y \to Z$, then $X \to Z$. This is exactly the transitivity rule in categories.  It is important to note that these three rules are real axioms here. That is, they are correct by definition, not proof. We define the existence of objects and arrows with these rules.  


%There are three levels of cover between two graph representation G1 and G2

%1. Level 1 cover: A graph representation $G_1$ is said to cover another graph representation $G_2$ by level 1 if every arrows in $G_2$ can be inferred from $G_1^+$.

%2. Level 2 cover: A graph representation $G_1$ is said to cover another graph representation $G_2$ by level 2 if every arrows in $G_2$ can be inferred from  $(G_1 \cup L)^+$, where L denotes the restorable limit and colimits objects in $G_2$.

%3. Level 3 cover: A graph representation $G_1$ is said to cover another graph representation $G_2$ by level 3 if every arrows in $G_2$ can be inferred from  $(G_1 \cup L \cup A)^+$, where L denotes the restorable limit and colimits objects in $G_2$ and A denotes all the restorable arrows.

% which corresponds to Boyce-Codd normal form (BCNF) in relational normal form theory. 



\begin{definition}
Given a set of functional dependencies $F$,  a graph representation $G$ of a category $\mathcal{C}$ is said to cover another graph representation $G'$  if every arrow in $G'$ is also in $(G,F)^+$; that is, if every arrow in $G'$ can be inferred from $G$ and $F$. 
\end{definition}

\begin{definition}
    Given a set of functional dependencies $F$, two graph representations $G$ and $G'$ are equivalent if $G$ covers $G'$ and $G'$ covers $G$. 
\end{definition}

 Roughly speaking, the computation of a First Reduced Representation (1RR) is similar to computing a minimal (canonical) cover of functional dependencies,  wherein an equivalent representation with the minimum number of arrows is sought. Algorithm \ref{alg:1RR} describes the key steps involved in generating the 1RR. The inputs to this algorithm are a graph representation $G$ of a category and a set of functional dependencies $F$ in the canonical form. The output is the 1RR.

% The first step is to compute a closure category $(G,F)^+$, which is accomplished through Algorithm \ref{alg:closureFD} (Line 1). The closure category ensures that all relevant functional dependencies that can be inferred from the original ones are explicitly included. Next, we proceed to remove any redundant arrows from the graph while ensuring that the remaining graph remains equivalent (Lines 2-4). When an arrow $f: X \to Y$ is removed, two cases arise: (1) If the arrow $f$ is a projection arrow, the definition of the relationship object $X$ involving $f$ is altered by removing an extraneous object $Y$ from $X$, or (2) if the arrow $f$ is not a projection arrow, it is simply removed as it can be derived from other existing arrows.


 
 
 %Algorithm \ref{alg:1RR} describes the main steps to generate the 1RR. The input is a graph representation $G$ of a category and a set of functional dependencies with a canonical form. First, a closure category $G^+$ is computed by Algorithm \ref{alg:closureFD}. Second, any arrow is removed if the remaining graph after the removal is still equivalent. When an arrow $f: X \to Y$ is removed, there are two cases: (1) $X$ is a relationship object and this arrow is a projection arrow, then the definition of the relationship object $X$ is changed, an extraneous object $Y$ is removed from $X$, or (2) this arrow is not a projection arrow. This step removes a redundant arrow. 


 
%We will now proceed with a detailed walkthrough of the algorithm. In Step 1, a closure category $G_1$ is computed by Algorithm \ref{alg:closureFD}. In Step 2, the modified graph $G_1$ is transformed into a set of functional dependencies. For every relationship object $X$ in $G_1$, two new functional dependencies are included: $X \to A_1, \ldots, A_n$ and $A_1, \ldots, A_n \to X$, where $A_i \in \pi(X)$. Additionally, other arrows in $G_1$ are converted into corresponding functional dependencies. Consequently, apart from the functional dependencies for relationship objects, all other arrows in $G_1$ have a single attribute on the LHS. In Step 3, a minimal cover for all the functional dependencies is computed (\cite{elmasri2000fundamentals}). Finally, in Step 4, the computed minimal cover is transformed into a new graph representation.  Each functional dependency, represented as $f: X \to Y$, is translated into an arrow connecting the sets $X$ and $Y$ in the graph.  When the left-hand side (LHS) of a functional dependency $X$ consists of multiple attributes, e.g., $X = A_1, \ldots, A_n \to Y$, a new relationship object $X$ is introduced in $G_0$. Projection arrows represented as $X \to A_i$ for each $X_i$ are also added, along with the arrow $X \to Y$. 







%This process follows a similar approach to Step 1, where functional dependencies are translated into arrows connecting the appropriate objects.




%A canonical form of a functional dependency is obtained by decomposing it into a set of minimal cover, irreducible FDs and ensuring that the right-hand side of each FD contains only a single attribute. 

%In the sequel,  $X$  denotes a relationship object, which is associated with multiple attributes $A_1,...,A_n$.

 %We now go through the algorithm.  Step 1 adds all functional dependencies into $G_0$. Each FD $f: X \to Y$ is represented as an arrow between $X$ and $Y$. If $X$ or $Y$ does not occur in $G_0$, then add new objects and arrows correspondingly.   If the left-hand side (LHS) of $X$ has multiple attributes, say $ X=X_1,...,X_n \to Y$, then create a new relationship object $X$ in $G_0$, add all projection arrows $X \to X_i$ for each $X_i$, and add the arrow $X \to Y$. Step 2 converts the new $G_1$ into a set of FDs, For each relationship object $X$ in $G_1$, add two new FDs: $X \to X_1,...,X_n$ and $X_1,...,X_n \to X$.  And other arrows are converted to FDs correspondingly. Therefore, except for the FDs for relationship objects, all other arrows have a single attribute in LHS. Step 3 computes a minimal cover for all FDs.  An algorithm to compute minimal cover is offered in the appendix based on the approach in \cite{elmasri2000fundamentals}  for the sake of self-containment of this paper. Finally, in Step 4, this minimal cover is converted to a new graph representation.  The approach is similar to that of Step 1. 
 
 
 %For any rule with multiple attributes in LHS, say  $X_1,X_2,...X_n \to X$, then $X$ is defined as a relationship object for $X_1,X_2,...,X_n$. The following lemma shows that the definition of each relationship object $X$ is unique.    

%xcept for the FD involving the definition of a relationship object, the LHS of all other FDs has a single attribute, and those FDs are represented as arrows in the returned graph.  


 

% \begin{lemma} In the output of a set of FDs in Line 3 of Algorithm \ref{alg:1RR}, for each FD with multiple attributes in LHS, the corresponding RHS is different.  \end{lemma}

%\begin{proof} Because there is only one original rule whose RHS is X and LHS has multiple elements. It is possible that the LHS is reduced, but there is only one rule about X. Thus, we can define X uniquely.\end{proof}


 
 %In a relational database setting, given a set F of FDs, numerous other functional dependencies can be inferred or deduced from the FDs in F. We call them implied functional dependencies. There are three well-known inference rules for functional dependencies, called Amstrong's axioms: FD 1: If $Y \subseteq X$, then $X \to Y$; This says that every two objects which have containment relationship, then there is a projection arrow between them. FD 2: If $X \to Y$, then $XZ \to YZ$; In particular, given an element $(x,z) \in XZ$, we define that $(y,z) \in YZ$ and $(y,z)$ is the image of   $(x,z)$. FD 3: If $X \to Y$ and $Y \to Z$, then $X \to Z$. This is exactly the transitivity rule in categories.  It is important to note that these three rules are real axioms here. That is, they are correct by definition, not proof. We define the existence of objects and arrows with these rules.  A canonical cover is a set of functional dependencies that is minimal and equivalent to the original set of functional dependencies.




 

%Note that if RHS has multiple elements, then this rule is at most one as it is a minimal cover and the number of the original rules is at most one. 





%Given a set of functional dependencies, if the LHS X contains multiple attributes, if X appears in category C, replace X with a single attribute. Otherwise, create a new relationship object for X, and create the projection morphisms: $X \to X_i$ in C.


%Here are the steps to obtain a canonical cover: 1. Start with the original set of functional dependencies.2. Decompose any functional dependency that contains multiple attributes on the right-hand side into individual functional dependencies. For example, if you have $A  \to BC$, decompose it into $A \to B$ and $A \to C$.3. Eliminate any redundant dependencies. A dependency $X \to Y$ is redundant if Y can be derived from X and other existing dependencies. Remove the redundant dependencies while maintaining the original dependencies. 4. Repeat steps 2 and 3 until no further decomposition or elimination of dependencies is possible. The resulting set of dependencies is the canonical cover.


%\begin{algorithm}\caption{Level 1 cover}\label{alg:level1cover}\input{algorithms/level1cover}\end{algorithm}

%\begin{algorithm}\caption{Level 2 cover}\label{alg:level2cover}\input{algorithms/level2cover}\end{algorithm}


%\begin{algorithm}\caption{Level 3 cover}\label{alg:level3cover}\input{algorithms/level3cover}\end{algorithm}









%G1 is equivalent to G2 if and only if G1 covers G2 and G2 covers G1. We may also say G1 is equivalent to G2 by level 1, 2 or 3 inference.




%Given a representation G, if G' is the first reduced representation and G' is equivalent to G by level 2 inference, and G' has the minimal number of limit and colimit objects, then G' is the second reduced representation of G.


%A category without (co)limit and commutative diagram constraints can be represented with a set of functional dependencies. Each arrow in a schema category can be represented with a functional dependency. Each isolated object without morphism may be represented as a trivial FD: $X \to X$. Similarly a graph can be also represented as a set of FDs. A graph representation G of C is the first reduced representation if $FD(G)$ is a minmal cover of $FD(C)$.


%Intuitively, the first reduced representation of a category $\mathcal{C}$ determines a graph $\mathcal{G(C)}$  with the same objects and arrows, forgetting the identities and  all arrows (functions) that can be composed.
%Intuitively, the first reduced representation of a category $\mathcal{C}$ determines a graph $\mathcal{G(C)}$  with the same objects and arrows, forgetting the identities and  all arrows (functions) that can be composed.

%An algorithm to compute the minimal cover:https://www.inf.usi.ch/faculty/soule/teaching/2014-spring/cover.pdf


%\begin{definition} (First Reduced Representation) A graph representation $\mathcal{G}$ of a category $\mathcal{C}$ is in the first reduced representation (1RR) if and only if  all identity arrows and composed arrows are removed. In other words, 1RR keeps only atomic arrows and projection arrows. \label{def:1RR}\end{definition} 

%\begin{definition} (minimal cover) A graph representation $\mathcal{G}$ of a category $\mathcal{C}$ is a minimal cover of $\mathcal{C}$ if the moval of any arrows will not equivalent to $\mathcal{C}$.\label{def:mincover} \end{definition} 

%\begin{definition} (First Reduced Representation) A graph representation $\mathcal{G}$ of a category $\mathcal{C}$ is in the first reduced representation (1RR) if and only if  $\mathcal{G}$ is a minimal cover of $\mathcal{C}$. \label{def:1RR}\end{definition}

%\begin{definition} (First Reduced Representation) A graph representation $\mathcal{G}$ of a category $\mathcal{C}$ with functional dependencies is in the first reduced representation (1RR) if and only if it is a canonical cover of $\mathcal{C}$. We can use the following algorithm to find at least one first reduced representation.\label{def:1RR2}\end{definition} 

%Given a representation G, if G' is equivalent to G by level 1 inference, and G' has the minimal arrow cover and minimal relationship width, then G' is the first reduce representation of G.



%\begin{algorithm}\caption{Computing the complete representation}\label{alg:complete1}\input{algorithms/computecomplete1}\end{algorithm}

\begin{algorithm}
\caption{Computing the First Reduced Representation (1RR)}
\label{alg:1RR}
\input{algorithms/compute1RR2}
\end{algorithm}








%\begin{example} See Figure \ref{fig:composedarrows}. In this example,Person has three attributes SSN, Yea and Age. $Year \to Age$. SSN is a bijective function with Person. In this case, the two composed arrows i.e. (SSN, Year) and (Person, Age) are removed. When we map the categories into relational data, based on the mapping algorithms which are introduced in Section 4, a complete category in Figure \ref{fig:composedarrows}(a) will output a table T1(Person,SSY,Age, Year). But  the reduce presentation will output two tables T2(Person,SSN,year) and T3(Year,Age). Note that T1 is not in the third normal form (3NF), but T2 and T3 are. This example intutively shows the connection between the reduced representation and the normal form theory, which will be elaborated on later.\end{example}

%\begin{example} See an example to illustrate 1RR \ref{fig:1RRExample}. Step 1, Convert FDs to G, and add the two objects X1=BC and X2=CD, and the corresponding projection arrows and other arrows. Step 2: all FDS: $A \to BCDE$, $X1 \to BCD$, $BC \to X1$, $X2 \to CDF$, $CD \to X2$, $E \to F$. Then compute the closures. For example, Closure(X1)= BCDF, Closure(X2)=CDF. Remove the projection and composed elements. Then the final category is shown in Figure (b).\end{example}

\vspace{-2mm}
\begin{example}  Recall Figure \ref{fig:1RRExample}, where the subfigure (c) illustrates the removal of three redundant arrows, namely $D \to B$, $D \to C$, and $A \to C$, resulting in the first reduced representation.

\label{exp:1RRExample} \end{example}

%The time complexity of this algorithm is dominated by the cost to compute the closure of the functional dependencies (i.e. Line 3). Let $m$ and $n$ be the number of objects and arrows in $G_0$, and let $d$ be the number of FDs. The total time for computing the FD closure is $O((d+n) \cdot m)$ based on the implementations of the papers (\cite{elmasri2000fundamentals,10.1145/320493.320489}. Using this procedure, one can implement Algorithm \ref{alg:1RR} with the time $O((d+n) \cdot m)$.


%This can be done with a polynomial algorithm, which runs in O(A*F), where A denotes the total number of attributes of all relationship objects, and F is the total number of arrows in G.

%Let $m$ be the number of objects in $G$, $n$ the number of arrows in $G$, and let $d_1$ and $d_2$ be the number of FDs and MVDs, respectively. The total time for computing the FD closure is $O((d_1+n) \cdot m)$ and MVD closure is $O((d_2+n) \cdot m^3)$ based on the implementations of papers  (\cite{10.1145/320493.320489, 10.1145/320613.320614}. Using these procedures, one can implement Algorithm \ref{alg:2RR} with the time $O(d_1+d_2+n) \cdot m^3)$.

%In the above example, the two arrows are removed.  We will show in the next section that this representation will produce two relational tables T1(Person,SSN,year) and T2(Year,Age). These two tables satisfy 3NF and BCNF. If we include all attributes in one table, then it has transitive function dependency and violates the 3NF. In the later section, we will the output relational data can satisfy both 3NF and BCNF, and further they can satisfy the improved 3NF and BCNF, which was proposed in paper \cite{journals/tods/LingTK81}. In essence, the first reduced representation can be viewed as a generalization of 3NF and BCNF for multi-model data. 

%Note that the first reduce representation of a category C is not unique in some cases, as the composed arrows may be defined differently. For example, consider three loop arrows for a set \{$a,b,c$\}. The function $f_0$ is an identity function, and the other two functions are defined as follows: $f_1(a)=b$, $f_1(b)=c$, $f_1(c)=a$, and $f_2(a)=c$, $f_2(b)=a$, and $f_2(c)=b$. Thus, $f_1 \circ f_1$ = $f_2$, and $f_2 \circ f_2$ = $f_1$. $f_0$ is an identity function that should be removed. However, either $f_1$ or $f_2$ can be considered as a composed arrow. Either one of them can be removed, but not both.

\subsection{Second Reduced Representation}

%The first reduced representation removes the selected arrows in a category, and the second reduced representation further removes selected objects called derivable relationship objects to further reduce redundancy. 

%The first reduced representation involves the removal of specific arrows within a category to reduce the redundancy, and the second reduced representation eliminates certain objects called derivable relationship objects to further minimize the redundancy.

While the first reduced representation condenses the graph representation by eliminating redundant arrows,  the second reduced representation (2RR) takes the optimization process a step further by eliminating (or decomposing) redundant objects, called \textit{derivable relationship objects}.


\begin{definition} (Derivable relationship objects) A  relationship object $O$ in a category $\mathcal{C}$ is derivable if the following conditions are satisfied: (i) $O$ is a limit or an MVD object, and (ii) there is no incoming arrow to $O$; and (iii) for each outgoing arrow $k: O \to X$, where $k$ is not a projection arrow, there exists a projection arrow $f: O \to Y$, and another arrow $g: Y \to X$, such that $k = g \circ f$ in $C$. \label{def:derivable_relation}\end{definition}

%A derivable relationship object can be removed without losing any information when the following three conditions are satisfied simultaneously, (i) they are universal objects (limit or pullback); (ii) they have no incoming arrows; and (iii) any outgoing edge can be derived through other arrows. In addition, if a derivable relationship object is an MVD object (see Definition \ref{def:MVD}), then we call it derivable MVD object, otherwise it is a derivable limit object.  

A derivable relationship object can be removed without losing any information when the following three conditions are simultaneously satisfied: (i) it is a universal object (limit or pullback); (ii) it has no incoming arrows; and (iii) any outgoing edge can be derived through other arrows. Additionally, if a derivable relationship object is an MVD object (defined in Definition \ref{def:MVD}), it is called a derivable MVD object; otherwise, it is a derivable limit object.

%Therefore, this (co)limit can be removed without losing extra information in the category.

%Intuitively, this algorithm removes the universal objects such as pure pullback, limits, and colimits.

%Algorithm \ref{alg:2RR}  generates the second reduced representation. The input is a graph representation and a set of functional dependencies and multivalued dependencies with the canonical form \cite{10.1145/27629.214286}. The output is the second reduced representation. First, similar to 1RR, all functional dependencies are added into $G$, and then the graph is converted into a set of FD in Lines 1 and 2. The key steps lie in Lines 3 and 4. In particular, Line 3 removes the implicit pullback objects. In order to compute the closure of MVDs, the dependent basis of each LHS is calculated. The appendix shows the algorithm to compute the MVD dependency basis. While there is any derivable relationship object $O$ containing both X and Y, where there is a non-trivial MVD $X \to\to Y$. If $O$ contains only X and Y, remove O, otherwise, decompose O with two subobjects $X \cup Y$ and $O-Y$, and the associated projection arrows are also separated. Line 4 removes the derivable limits and colimit objects, which can be recovered from other objects and morphisms.  Finally, lines 5 and 6 generate the corresponding category based on the minimal cover of functional dependencies as the approach for 1RR. 
%\cite{10.1145/27629.214286}

%Algorithm \ref{alg:2RR} is designed to generate the 2RR, with the input of a graph representation $G$, a set of FDs $F$, and a set of MVDs $M$.  The algorithm's steps are outlined as follows. It begins by utilizing Algorithm \ref{alg:closureMVD} to compute a closure category $(G,F,M)^+$ (Line 1). Next, the algorithm focuses on removing derivable MVD objects (Line 2), by iteratively examining MVD objects denoted as $O$ in the context of $X \to\to_O Y$. When such objects are found, the algorithm decomposes them into two subobjects: $X \cup Y$ and $O - Y$. Subsequently, the derivable limit objects are also eliminated. The final steps (Lines 3-5) involve removing the redundant arrows following a similar approach as 1RR.





Algorithm \ref{alg:2RR} is designed to generate the 2RR, using a graph representation $G$, a set of functional dependencies (FDs) $F$, and a set of multivalued dependencies (MVDs) $M$ as input. The steps of the algorithm are outlined as follows: The algorithm begins by utilizing Algorithm \ref{alg:closureMVD} to compute a closure category $(G,F,M)^+$ (Line 1). It then focuses on removing derivable MVD objects (Line 2). This is done by iteratively examining MVD objects, denoted as $O$, in the context of $X \to\to_O Y$. When such objects are found, the algorithm decomposes them into two subobjects: $X \cup Y$ and $O - Y$. Subsequently, it eliminates the derivable limit objects. The final steps (Lines 3-5) involve removing the redundant arrows, following a similar approach to the 1RR algorithm.



%In Line 2, the algorithm first proceeds to remove derivable MVD objects.  As long as there exist MVD objects denoted as $O$ with respect to $X \to\to_U Y$, the algorithm decomposes them into two subobjects: $X \cup Y$ and $O-Y$. Then it eliminates derivable limits objects. The final steps (Lines 3-5) involve removing the redundant arrows following a similar approach as 1RR.




%We now describe Algorithm \ref{alg:2RR}. First, in Step 1, similar to 1RR, all functional dependencies are initially added to the graph $G_0$. Step 2 removes implicit pullback objects. In particular, to infer all MVDs, the dependent basis of each left-hand side (LHS) of MVDs should be calculated. The algorithm to compute the MVD dependency basis is provided in the appendix based on the paper \cite{10.1145/320613.320614}. While there is any implicit pullback object $O$ with respect to $X \to\to Y$, it is decomposed into two subobjects: $X \cup Y$ and $O-Y$, while also separating the associated projection arrows. Step 4 handles the removal of derivable limits and colimit objects, which can be obtained from other objects and morphisms within the graph.  Finally, in Steps 5 and 6, the algorithm generates the corresponding category based on the minimal cover of functional dependencies, following the same approach as 1RR. By applying this algorithm, the second reduced representation is produced, resulting in a more optimized and streamlined category structure by removing redundant objects and morphisms.

%Given one MVD $X \to\to Y$, and any object $Z$, we assume that there is an object $XZ$ in C and $XYZ$ is a pullback for $XY$, $XZ$ and $X$.




%We say a category C is consistent with an MVD $X \to Y$ if there is at least one relationship object which associates with both $X$ and $Y$ in C.

 



%\begin{algorithm}\caption{Compute the complete category with MVDs}\label{alg:complete2}\input{algorithms/computecomplete2}\end{algorithm}


%If a restorable relationship object is associated with at least three objects, and two of them are $X, Y$, and there is a multivalued dependency $X \to\to Y$ in C, then we call this object is restorable pullback object withrespect to $X \to\to Y$.




\begin{algorithm}
\caption{Computing the second reduced representation (2RR)}
\label{alg:2RR}
\input{algorithms/compute2RR}
\end{algorithm}


%\begin{definition} (Second Reduced Representation) A graph representation of a category $\mathcal{C}$ is in the second reduced representation (2RR) if and only if  it is in 1RR and it removes restorable pullback, limit and colimit objects. Algorithm \ref{alg:2RR} shows an algorithm that can find at least one second reduced representation.\end{definition}

%\begin{algorithm}\caption{Computing 2RR}\label{alg:2RR}\input{algorithms/compute2RR}\end{algorithm}




\begin{example}  This example illustrates the 2RR algorithm. Figure  \ref{fig:2RRExample}(a) is the input. In Line 1, a closure of the category is computed, which has been explained in Example \ref{exp:CloureMVDExample}.  In Line 2,  $X$  is decomposed to $X_1$ and $X_2$ due to MVDs $A \to\to_X B$ and $A \to\to_X CD$.  In Lines 3-5, the redundant arrows are removed. Finally, the 2RR is shown in Fig. \ref{fig:2RRExample}(c), where there is no derivable MVD object. 
\label{exp:2RRExample} \end{example}




%The time complexities of Algorithms  \ref{alg:1RR} and \ref{alg:2RR} are essentially that of the computation of the closure of FDs and MVDs. That is, they are the same as that of Algorithm \ref{alg:closureFD} and \ref{alg:closureMVD} respectively, which were analyzed before.


%A linear time algorithm for testing membership in the closure of a set of FDs is presented in \cite{10.1145/320493.320489}. Using this procedure, one can implement Algorithm 1 with a time bound of $O(m^2)$, . 



%We now analyze the time complexity of the algorithm. The membership problem for MVDs can be decided in time $O(L(D)^4)$, where $L(D)$ is the size of the description of the given set of dependencies and the category.

%It is important to note that in 2RR algorithm, all restorable pullback objects are decomposed and removed. Because we use the inference rules for FD and MVDs. But we do not apply the inference rule. 

%As shown in Section \ref{sec:limits},  limits have their connection with join dependency. Recall that the 4th normal form and Project-Join normal form (PJ/NF)  is defined with the join dependency. Later we will connect the second reduced representation with PJ/NF.

%Figure \ref{fig:reduced} (b) shows the main idea for the second reduced representation: eliminating all pure limits and colimits objects.  The relational data after this reduction will satisfy the fifth normal form. A relation schema R is in fifth normal form (5NF) (or project-join normal form (PJNF)) with respect to a set F of functional, multivalued, and join dependencies if, for every nontrivial join dependency JD($R_1$,$R_2$,...$R_n$) in $F^+$ (that is, implied by F), every $R_i$ is a superkey of R.


%\subsection{Third Reduced Representation}3RR further removes unique arrows in  commutative triangles to avoid redundant storage. Let us see the following example to understand it.  

%\begin{figure} \centering \includegraphics[width=0.6\textwidth]{figures/UniqueArrow2.jpg} \caption{This example illustrates that the left and right unique arrow. For Fig (a), assume that each school has exactly one dean, then staff can decide department, and department can decide faculty. Dean can decide the school. Then there is one unique arrow from staff to dean.  For Fig (b), each research group belong to one faculty. If two groups has the same GroupHead, then these two groups should belong to the same faculty. All GroupHead should have one group. That is $\forall groupHead, \exists group, s.t. group \rightarrow groupHead $ } \label{fig:universal}  \end{figure}


%\begin{example} See Fig. \ref{fig:universal}.This example illustrates that the left and right unique arrows. See Fig. \ref{fig:universal}(a). Assume that each faculty has exactly one dean, then staff can decide department, and department can decide faculty. Dean can decide the faculty. Then there is one unique arrow from staff to dean. For example, if one staff change the department, or one faculty change the dean, there is no need to update the relation between the staff and the dean. And thus it can avoid the issue of data anomalies. See Fig. \ref{fig:universal} (b). This example illustrates that  we can avoid the implementation of the arrow $f$ from GroupHead to School. Here we assume that this $f$ is unique. Each group belongs to one faculty. If two groups has the same GroupHead, then these two groups should belong to the same faculty. All GroupHead should have one group. That is $\forall groupHead, \exists group, s.t. group \rightarrow groupHead $.\label{exp:3RR} \end{example}


%\begin{figure}\centering\includegraphics[width=0.2\textwidth]{figures/restorablearrow.jpg}\caption{Illustration to the left and right restorable arrows in  the commutative triangle. }\label{fig:restorablearrows}\end{figure}



%\begin{definition} (Third Reduced representation) A graph representation $\mathcal{G}$ of a category $\mathcal{C}$ is in the third reduced representation (3RR) if and only if $\mathcal{G}$ is a 2RR and a left or right unique arrow is removed in any commutative triangle of $\mathcal{G}$.\end{definition}



%\begin{algorithm}\caption{Computing 3RR}\label{alg:3RR}\input{algorithms/compute3RR}\end{algorithm}

%Recall Example \ref{exp:3RR} which illustrates the left unique arrow (between staff and Dean) and the right unique arrow (between GHead and School).  Note that this normalized representation cannot be defined by the classic normalized form.  The algorithm for the third reduced representation outputs a specification of relation schema that is beyond the fifth normal form.  The existing normal form theory decomposes a table into several smaller pieces. But the third representation amps to schema without the redundant attributes. That is, the third avoids redundancy by removing some attributes. Although the relational normal form has no similar idea, By considering the object normal and XML normal form, we can find some related ideas which will be discussed later in Section 5.   


