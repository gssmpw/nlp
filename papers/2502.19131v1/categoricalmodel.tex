

\section{Thin Set Category}

\nopagebreak

In this section, we describe a formal conceptual data model for multi-model data with a \textbf{thin set category}.

\subsection{Objects and Morphisms in Categories}


\begin{definition}\label{def:category} \cite{MacLane:205493} (Mathematical category) A category $\mathcal{C}$ consists of a collection of objects denoted by $Obj(\mathcal{C})$ and a collection of morphisms denoted by $Hom(\mathcal{C})$.  For each morphism $f \in Hom(\mathcal{C})$ there exists an object $A \in Obj(\mathcal{C})$ that is a domain of $f$ and an object $B \in Obj(\mathcal{C})$ that is a target of $f$. In this case we denote $f \colon A \to B$. We require that all the defined compositions of morphisms are included in $\mathcal{C}$: if $f\colon A \to B \in Hom(\mathcal{C})$ and $g \colon B \to C \in Hom(\mathcal{C})$, then $g \circ f \colon A \to C \in Hom(\mathcal{C})$. We assume that the composition operation is associative and for every object $A \in Obj(\mathcal{C})$ there exists an identity morphism $\text{id}_{A} \colon A \to A$ so that $f \circ \text{id}_{A} = f$ and $\text{id}_{A} \circ f = f$ whenever the composition is defined.
\end{definition}

%\vspace{-5mm}

Intuitively, a category can be viewed as a graph. A category consists of objects and morphisms, where the objects can be thought of as nodes in a graph, and the arrows can be seen as directed edges connecting the nodes. However, a category is a more structured and rich mathematical concept that incorporates additional properties and operations beyond those of a graph. In a category, there is a composition operation defined on the arrows, allowing for the composition of arrows along a path. This composition operation follows certain rules, such as associativity, which are not typically present in a general graph. 



%a category as a directed multi-graph.   Here, the objects are represented as nodes, and the morphisms as edges. However, a category extends beyond the concept of a graph in one key aspect. A category specifies the composition of any two morphisms, and this composition operation adheres to the principle of associativity. 

%Secondly, a category introduces the notion of an identity morphism for each object within the category. 

%It is worth noting that multiple edges can exist between two nodes. 

%Visually, an entity object is depicted as a square shape. Graphically, a relationship object is symbolized by a diamond shape. which is graphically represented as a circle.

A database can be viewed as a category, specifically a \textbf{Set} category. In this context, each object in the category represents a set, while each morphism corresponds to a function between two sets. Both objects and morphisms possess distinct names within a database category (see an example in Figure 1). The composition of morphisms aligns with the composition of functions. Drawing inspiration from the principles of entity-relationship (ER) diagrams, we identify three fundamental types of objects within this category: \textit{entity objects}, \textit{attribute objects}, and \textit{relationship objects}. An entity object can represent a physical object, an event, or a conceptual entity. Visually, an entity object is depicted as a square shape. The elements contained within an entity object consist of a set of surrogate keys, which are sequentially generated integer numbers.  A relationship object captures the connections between various objects. Graphically, a relationship object is symbolized by a diamond shape. Similar to entity objects, the elements within a relationship object are also represented by surrogate keys.  An attribute object is a particular property to describe an entity or a relationship object, which is graphically represented as a circle.  Each attribute is associated with the domain of values. The domain is similar to the basic data types in programming languages, such as string, integer, Boolean, etc.  

%\begin{definition} (Database category)A database category $\mathcal{C}$ is a special type of category, where each  object is a set and each morphism is a function.  There are three types of objects: entity objects, relationship objects, and attribute objects. There are three types of morphisms: monomorphism, epimorphism and isomorphism, which corresponds to three types of functions: surjective, injective and bijective functions. Each object and morphism in the category has a (distinct) label.\end{definition}


%In this paper, we use $Set$ category where each object is a set and  each morphism is a function.



%In addition, an attribute can be simple or composite. A simple attribute has a single domain (such as Char or integer), whereas a composite attribute object is an attribute  that is composed of multiple simple attributes. It represents a more complex piece of data that can be broken down into its constituent parts. For instance, address is a composite attribute that may include street, zip-code, and country etc simple attributes. The elements in each composite attribute are also a set of surrogate keys.

%A morphism  is considered an identity if it corresponds to an identity function. In other words, it maps each element to itself.  Every object within a category possesses an associated identity morphism. 

Morphisims are defined as functions in sets. A function maps elements from its domain to elements in its codomain. Let $X$ and $Y$ are two sets (objects), then $f$: $X \to Y $ is a function  from the domain $X$ to the codomain $Y$ such that for any element $\forall  x \in X$,  there is certainly one element $y \in Y$, $ y = f(x)$. A morphism is sometimes called an arrow. Thus, we say arrow, function, or morphism interchangeably, and they are equivalent. Given a relationship object $R$ which associates several other objects $X_1$,$X_2$,...,$X_n$, the morphism between $R$ and $X_i$ is called projection morphism, denoted as $\pi_i(R)=X_i$ 
 (1$\leq$$i$$\leq$$n$).   In database theory, a functional dependency (FD) is a constraint that specifies the relationship between sets of values.  In the context of category theory, each morphism, denoted as $X \to Y$, naturally corresponds to a functional dependency. This is due to the fact that there is a unique element in the set $Y$ for every element in the set $X$. The transitivity of functional dependencies can be understood as the composition of arrows in a category.

%An identity morphism maps each element to itself.  Every object within a category possesses an associated identity morphism. 

%However, note that there exists a subtle difference between morphisms in category theory and functional dependencies in relational tables. In a relational table, for every tuple belonging to attribute(s) $Y$, there will always be a corresponding value for the attribute(s) $X$. However, in a category, it is possible for an element in the set $Y$ to not have a preimage in the set $X$. This distinction arises from the fact that the definition of functions guarantees that each element in the domain has an image in the codomain, but not necessarily the other way around. However, for simplicity and ease of analysis, we intentionally overlook this distinction and assume that each function is surjective throughout this paper. This means that every element in the codomain is mapped to by at least one element in the domain.

%A functional dependency (FD) in DBMS is a constraint that specifies how a set of attributes determines another set of attributes in a relation. In a category, each morphism $X \to Y$ naturally defines a function dependency because there is only one element  in $Y$ for any given element in $X$. The transitivity of FD  corresponds to the composed arrows in a category. However, it is worth to note the subtle difference between morphism and FD. In a relational table, for each tuple from attribute(s) $Y$, there always exists a corresponding value for $X$. However, in a category, it is possible that an element in $Y$ cannot find its preimage from $X$. Because the definition of functions only guanrantee that each element in X has an image, not vice versa. For the purpose of this paper, we intentionally ignore this difference and assume that each function is surjective, where each element of the codomain is mapped to by at least one element of the domain. 

%A morphism is classified as atomic if it cannot be derived through the composition of other arrows. Otherwise, it is referred to as a composed arrow. For instance, the morphism connecting mothers and children is atomic, while that connecting grandmothers and children is a composed one. 





%A functional dependency (FD) in DBMS is a constraint that specifies how a set of attributes determines another set of attributes in a relation. In a database, each function $X \to Y$ defines a function dependency because there is only one element (tuple) in $Y$ for any given element (tuple) in $X$. The transitivity of FD  naturally corresponds to the composed arrows in a category. Meanwhile,  note the nuanced difference between them. In a relational table instance, for each tuple from attribute(s) $Y$, there exists a corresponding tuple for $X$. This ensures that the functional dependency is well-defined. However, in a category, it is possible that an element in an object $Y$ cannot find its preimage in $X$. But in this paper, when we discuss the category for database, we intentionally ignore this difference, We assume that each function is surjective. The function is surjective, or onto, if each element of the codomain is mapped to by at least one element of the domain. 




%In mathematics, injections, surjections, and bijections are three classes of functions.  A function is injective, or one-to-one, if each element of the codomain is mapped to by at most one element of the domain.  The function is surjective, or onto, if each element of the codomain is mapped to by at least one element of the domain. The function is bijective (one-to-one and onto) if each element of the codomain is mapped to exactly one element of the domain. 


%In the language of category theory,  these three functions are called monomorphism, epimorphism and isomorphism, which correspond to surjective, injective and bijective respectively. 



%It is important to understand a special type of morphism that is associated with any relationship object. Given objects $X_1$,$X_2$,...,$X_1$,  $Y$ within the category, the relationship object formed by their combination is denoted as $XY$. Naturally, two morphisms emerge from this relationship object: $\pi_1: XY \to X$ and $\pi_2: XY \to Y$.


%Furthermore, a specific type of morphism exists within the category, namely the projection morphism (denoted as $\pi$), which connects a relationship object with its associated object. To illustrate, 



%A morphism is atomic if it cannot be derived through the composition of other arrows, otherwise, it is called the composed arrow. For example, the  arrow between mothers and children is atomic, but the arrow between grandmothers and children is a composed arrow.  In addition, a morphism between a relationship object and its associated object is called projection morphism (denoted with $\pi$). That is, given two objects $X$ and $Y$ in a category, let $XY$ denote the relationship object of $X$ and $Y$. Naturally, two morphisms emerge from this relationship object:  $\pi_1: XY \to X$ and $\pi_2: XY \to Y$.



Similar to a schema for a database table, a category schema provides a descriptive representation of how data within the category is organized and structured. It encompasses various details, such as the category's name, the domains of elements within each object (set) and any constraints (e.g., pullback or pushout to be elaborated upon later) that are applicable to the category.  A schema does not store the actual data within the category but rather defines the overall shape and format of the data. Note that a categorical schema offers a unified view of multi-model data. In this paper, we show algorithms that facilitate the mapping of a categorical schema to different individual data schemas, such as relational schema, XML DTD, and property graph schema. 

%These algorithms will enable us to effectively translate the categorical schema into specific data representations, allowing for seamless integration and utilization across different data models.






%\begin{example} Assume that there is a relationship object (O) between Student (S) and Course (S), and $f_1$ denotes the function between O and S, and $f_2$ is the function between O and C:  (1) $f_1$ and $f_2$ are surjections, then each course has at most one student and each student takes at most one course; (2) $f_1$ and $f_2$ are injections, each course has at least one student, and each student takes at least one course; (3) $f_1$ is a surjection, and $f_2$ are injection, each student takes at most one course, and each course has at least one student; Total participation means surjection function. (4)  f1 is an injection, and f2 is a surjection, each student takes at least one course, and each course has at most one student. \end{example}





%Functional dependencies are important for designing good database schemas and normalizing relations. Given a set of functional dependencies, in the setting of relational databases, there are algorithms to generate a set of relational schema such that each relation satisfy a certain level of normal form to reduce data redundancy and inconsistency. Analogously, in this paper, we  design algorithms to map a set of functional dependencies to a category and then convert this unified category to different types of data schema, including relations, XML, and property graph schema. Those output schema can also guarantee  a certain level of normal form to avoid data redundancy and inconsistency.

%\noindent \textbf{Discussion on function dependencies and arrows}:







%One question is whether these three inference rules can be applied to infer in a category. 

%There are three inference rules on Amstrong Axims \cite{armstrong1974dependency}: FD 1: If $Y \subseteq X$, then $X \to Y$; FD 2: If $X \to Y$, then $XZ \to YZ$; FD 3: If $X \to Y$ and $Y \to Z$, then $X \to Z$.

%In the above three rules, FD 1 shows that relationship object X can derive its all projection objects Y. This is because by definition of relationship, it must refer to the element in its associated object, and thus the mapping always can be found. But FD 2 does not hold. Let us see an example. Assume that three objects: project, supplier, and product. If project $\to$ supplier, meaning each project has one specific supplier. However,   project,product $\to$ supplier, product may not be true. This is because it is possible there is some certain product, which is required by the project, but this product cannot be supplied by the supplier. The traditional database assumes that it is impossible, but in this paper, we do not make such an assumption. FD3 holds because of the composition rule.

%Given a functional dependency $X_1,X_2,...X_n \to Y$ where the left-hand side includes multiple attributes, in order to present this FD we need to create a relationship object  X=$X_1,X_2,...X_n$, then it becomes $X \to Y$. In addition, we also need ot add the projection arrow from $X$ to each $X_i$.


\subsection{Thin Category}

%The category discussed in this paper is not only a set category but also a thin category, defined as follows: 

In this paper, the category under discussion is not just any set category, but rather a thin category, precisely defined as follows:

%In this subsection, we define a thin category and connect it with Universal Relational Assumption (URA).

%For simplicity, this paper assumes that there is only one morphism between any two objects. This is called a thin category as defined follows:

%For example, if there are two morphisms $f$ and $g$ between $X$ and $Y$, then Y can be divided into Y1 and Y2, such that $f:X \to Y1$ and $g: X \to Y2$.

%Throughout this paper, we assume that  given a pair of objects x and y, and any two morphisms f, g: $x \to y$, the morphisms f and g are equal, which is called a 'thin category'.

\begin{definition}(Thin Category) \cite{roman2017introduction} Given a pair of objects $X$ and $Y$ in a category $\mathcal{C}$, and any two morphisms $f$, $g$: $X \to Y$, we say that $\mathcal{C}$ is a thin category if and only if the morphisms $f$ and $g$ are equal. 
\end{definition}

%For example, if there are two morphisms $f, g$: children $ \to $ parents, f is mother, and g father. Then to define a thin category, the parent can be divided into father and mother two objects.

%In practice, transforming a non-thin category into a thin category involves the process of partitioning the objects $X$ and $Y$ within the category. When given two distinct morphisms, $f$ and $g$, both mapping from $X$ to $Y$, we can partition the object $Y$ into two distinct subsets, denoted as $Y_1$ and $Y_2$. Consequently, $f$ and $g$ are associated with one of these subsets: $f$ maps to $Y_1$, and $g$ maps to $Y_2$. In addition, note that a thin category accommodates the presence of bijective morphisms. In other words, within a thin category, it is possible for both $f: Y \to X$ and its inverse $f^{-1}: Y \to X$ to coexist and be well-defined simultaneously.


%In practice, to convert a non-thin category to a thin category, given two objects $X$ and $Y$, if there are two different morphisms $f$ and $g$: $X \to Y$, then $Y$ can be divided into $Y_1$ and $Y_2$, such that $f:X \to Y_1$ and $g: X \to Y_2$.  Note that a thin category allows a bijective function, i.e.  $f: Y \to X$ and $f^{-1}: Y \to X$ can hold simultaneously.

%A commutative diagram is a diagram such that all directed paths in the diagram with the same start and endpoints lead to the same result. 

In category theory, a commutative diagram is a graphical representation that depicts the relationships between objects and morphisms.  A diagram $\mathcal{D}$ is commutative meaning that different paths through the diagram yield the same result. In other words, if there are multiple ways to get from one object to another by following a sequence of morphisms, all these paths lead to the same result. The following lemma (\cite{roman2017introduction}) connects thin categories with commutative diagrams.

%The proof of all lemmas and theorems in this paper can be found in Appendix \ref{sec:proofs}. 


 
%Commutative diagrams are usually composed of commutative triangles and commutative squares. A looped arrow indicates a map from a set to itself. 

 

 \begin{lemma}  [\cite{roman2017introduction}] All diagrams in a thin category are commutative.\label{lem:thincommutative} 
 \end{lemma}

%\begin{proof} (Sketch) Without loss of generality, consider three objects $A$, $B$ and $C$ in a category.  Let $f: A \to B$,  $g: B \to C$, and   let $k = g \circ f$. Since there is only one arrow (i.e. $k$) between $A$ and $C$, then this diagram is commutative, otherwise, there are at least two arrows between $A$ and $C$, which contradicts the definition of a thin category. This commutative result can be proved for any two sequences of objects with the same starting and ending points, which concludes this proof.\end{proof}

%\begin{example} Figure \ref{fig:commutativediagram}(a) illustrates a commutative diagram. Each group has one head and this head is affiliated with a school. Then this school is the same as the group's department's school. This is a commutative diagram. That is: $ \phi_2 \circ \phi_1 = \phi_4 \circ \phi_3$. Figure \ref{fig:commutativediagram}(b) shows the example of the weak entity object, which implies a commutative diagram for a dependent, the employer of each dependent is decided by the corresponding employer.    \end{example}

%A thin category ensures that different paths for constructing or transforming data are equivalent, resulting in consistent outcomes. It is interesting to note that a thin category is closely linked to the universal relational assumption (URA) in database theory, which asserts that each attribute name is unique, and all information can be consolidated within a single relation. The output of relation data from a thin category satisfies the URA.


 %A thin category ensures the equivalence of various paths, thereby guaranteeing commutativity for all diagrams. It is intriguing to note its link to the Universal Relational Assumption (URA) in database theory. The URA assumes that each attribute name must be unique, allowing the consolidation of all information within a single relation. The output of relational data from a thin category adheres to the URA.  Consequently, when examined through the lens of category theory, the URA in database theory can be seen as the different names to define a thin set category!


 A thin category ensures the equivalence of various paths, thereby guaranteeing commutativity for all diagrams. It is intriguing to note its link to the Universal Relational Assumption (URA) \cite{DBLP:conf/pods/KuckS82,DBLP:conf/pods/SteinM85} in database theory. The URA assumes that each attribute name must be unique, allowing the consolidation of all information from multiple relations within a single relation through join operators. The output of relational data from a thin category adheres to the URA. Consequently, when examined through the lens of category theory, the URA in database theory can be understood as an alternative way to define a thin category.
 
The following definition summarizes the main characteristics of the database category.
 
 
 
%Since all diagrams in a thin category are commutative, all information can be joined together to produce a single relation. 




\begin{definition}(Database Category) A database category is a special type of category defined as a thin set category. Each object is a set and each morphism is a function. There are three types of objects: \textit{entity objects}, \textit{attribute objects}, and \textit{relationship objects}. All diagrams in this category are \textbf{commutative}. \end{definition}



\subsection{Multivalued Dependencies and Pullback }
\label{sec:mvd}

%Functional dependencies (FDs) serve to describe the relationship between the values of one set of attributes and the values of another set. In contrast, multivalued dependencies (MVDs) capture non-trivial dependencies between sets of attributes, where each set can possess multiple values for the other. 

While a functional dependency, denoted as $X \to Y$, can be represented as a morphism between the sets $X$ and $Y$ within a category, defining multivalued dependencies (MVDs) requires additional conceptual tools. We employ the concept of \textbf{pullback}, which serves as a universal structure in categories, to define MVDs. 

%This allows us to precisely define and characterize the nature of multivalued dependencies in a systematic manner. 

%While functional dependencies (FDs) describe how the values of one set of attributes determine the values of another set, multivalued dependencies (MVDs) represent non-trivial dependencies between sets of attributes where each set can have multiple values for the other.  A functional dependency $X  \to Y$ can be interpreted as a morphism between X and Y in a category. On the other hand,  the definition of multivalued dependencies involves more machinery. We need to leverage pullback, a universal structure of categories to define MVD.


%Pullback describes the joining of two tables. As for the joining with multiple tables, we use a general definition called limits.



\begin{definition} (Pullback) Given a category $\mathcal{C}$ with three objects $A$, $B$, and $C$, and two morphisms: $f: A \to B$, $g: B \to C$. The pullback $P$ of $f$ and $g$ consists of morphisms $p_1: P \to A$  and $p_2: P \to B$ such that $f \circ p_1$=$g \circ p_2$  and $P$ has the universal property. That is, given any other object $P'$ with   two morphisms $p'_1: P' \to A$  and $p'_2: P' \to B$ such that $f \circ p'_1$=$g \circ p'_2$, there exists a unique morphism $u: P' \to  P$ with $p_1 \circ u = p'_1$ and  $p_2 \circ u = p'_2$.\end{definition}

%\[
%\xymatrix{
%P \ar[r]^{p_1} \ar[d]_{p_2} & A \ar[d]^f \\
%B \ar[r]_g & C
%}
%\]

%\[
%\xymatrix{
%P' \ar@/_/[ddr]_{p'_2} \ar@/^/[drr]^{p'_1} \ar@{.>}[dr]|-{u}\\
%& P \ar[d]^{p_2} \ar[r]_{p_1} & A\ar[d]_f \\
%&B \ar[r]^g &C}
%\]



%where $f,g$ are morphisms in $\mathcal{C}$. This means that for any object $Q$ and morphisms $q_1:Q\to X$ and $q_2:Q\to Y$ such that $f\circ q_1 = g\circ q_2$, there exists a unique morphism $u:Q\to P$ such that $p_1\circ u = q_1$ and $p_2\circ u = q_2$. 

In the category of sets, the pullback $P$ of functions $f : A \to C$ and $g : B \to C$ always exists and is given by the join of the sets $A$ and $B$ through $C$.
\[ P = A \bowtie_C B = \{ (a,b) \in A \times B | f(a)=g(b)=c, c \in C \} \]


%\begin{example} Assume that two tables T1(A,B), key is A, and T2(C,B), key is C. Then the join T1 and T2 based on A can be defined as the pullback object in the category:\[\xymatrix{{T_1 \bowtie  T_2} \ar[r]^{\pi} \ar[d]_{\pi} & A \ar[d] \\C \ar[r] & B}\]\end{example}

Given a relation $R(X,Y,Z)$ and two multivalued dependencies (MVDs) $ X \to\to Y$ and  $ X \to\to Z$.   The relation $R$ can be constructed by the following pullback diagram:
\[
\xymatrix{
{XYZ} \ar[r]^{\pi_1} \ar[d]_{\pi_2} & XY \ar[d]^{\pi_3} \\
XZ \ar[r]_{\pi_4} & X
}
\]


\[ XYZ = \{ (x,y,z) \in XY \times XZ |  (x,y) \in XY \wedge (x,z) \in XZ \wedge x \in X \} \]



%An MVD $X \to\to Y$ holds in a category C means that given any object $Z$, the relationship object XYZ is a pullback of XY and XZ, shown in the above diagram.  Since a pullback involves the values of object Z, a multivalued dependency $X \to\to Y$  cannot be checked through only X and Y alone. It follows that the specification of Z is an integral part of the MVD. It would be more appropriate, perhaps, to use the notation $X \to\to Y(Z)$ to stress the fact that the MVD (pullback) involves the set Z. However,  we (and most database papers) assume that the MVD is valid for all $Z$ in the database. For this reason, we still use  $X \to\to Y$. 

%Recall that the definition of MVD $X \to\to Y$ involves "a universal set U". The reason is that the validity of  $X \to\to Y$ depends on all other attributes associated with this relation. In the setting of most database papers,  $U$ is fixed. However, in a category of this paper,  $U$ could be various relationship objects which contain $X$ and $Y$. Thus the specification of $U$ is an integral part of an MVD. We sometimes use the notation $X \to\to_U Y$ to stress the fact that the MVD involves the set $U$.   


%It is possible that a relationship object UXY is valid, but U'XY is not valid. Thus, MVD constraints are sensitive to ''context'' while a functional dependency is not. We will see later that this global context gives rise to the inference rules of MVD are different from FDs. 

%In order to define an MVD $X \to\to Y$ in a category C, for any given object $Z$, then XYZ is a pullback relationship object with the above definition. 

%While a functional dependency $X  \to Y$ is defined in terms of the sets X and Y alone and can be interpreted as an arrow between X and Y in the category, the definition of multivalued dependencies involves more machinery.  On the other hand, the multivalued dependency $X \to\to Y$  depends on the values of all relationship objects which includes X, Y. It cannot be checked through only X and Y and their arrows. It is possible that a relationship object UXY is valid, but U'XY is not valid. Thus, MVD constraints are sensitive to ''context'' while a functional dependency is not. We will see later that this global context gives rise to the inference rules of MVD are different from FDs. It follows that the specification of U is an integral part of the MVD. It would be more appropriate, perhaps, to use the notation $X \to\to Y(U)$ to stress the fact that the MVD involves the set U. However, in this paper we assume that the MVD is valid for all $U \in C$. For this reason, we still use  $X \to\to Y$. In other words,  $X \to\to Y$ defines a set of limits. For any other object $XU$, there is a limit for $XYU$ in the category.



\subsection{Join Dependency and Limit }
\label{sec:joindependency}

 %Let $R$ be a relation and $S$ =\{$S_1,...,S_q$\} be a set of subsets of $R$, with the union of the $S_i$’s being $R$. If $R =  S_1(r) \bowtie  ... \bowtie  S_q(r)$, then we say $R$ satisfies the join dependency (JD) *[$S_1, ..., S_q$].  An MVD is a special case of a join dependency. If $U$ is a universal set of attributes, then a relation $I$ over $U$ satisfies an MVD: $X \to\to Y$ if $I$ satisfies JD:*[$XY,X(U-Y)$].  


 If $U$ is a universal set of attributes, a join dependency over $U$ is an expression of the form $\bowtie[X_1,...,X_n]$, where each of $X_1,...,X_n$ is a subset of $U$ with the union of the $X_i$’s being $U$. A relation $I$ over $U$ satisfy $\bowtie[X_1,...,X_n]$ if $I = ~\bowtie^n_{i=1}(\pi_{X_i}(I))$. A multivalued dependency (MVD) is a special case of a join dependency.  A relation $I$ over $U$ satisfies an MVD: $X \to\to Y$ if $I = ~\bowtie[XY,X(U-Y)]$.  
 
 %then a relation $I$ over $U$ satisfies an MVD: $X \to\to Y$ if $I$ satisfies JD:*[$XY,X(U-Y)$].  

%\[
%\xymatrix{
%x \ar@(ul,dl)[]|{id} \ar@/^/[rr]|f
%&& f(x) \ar@/^/[ll]|{f^{-1}} }
%\]

%Note that a limit is a generalization of a pullback in category theory, we use it to connect join dependency, which is a generalization of multivalued dependency.  

In category theory,  a limit is considered a broader concept, encompassing and generalizing the notion of a pullback. In database field, join dependency serves as a more inclusive concept compared to multivalued dependency. By recognizing these analogies, we can establish meaningful connections between join dependencies and limits, unveiling the parallels between these two concepts.






\begin{figure}\centering
\[\xymatrix{
& & {S'} \ar@{.>}[d]|u \ar[ddll]|{\psi'_1} \ar[ddl]|{\psi'_2} \ar[ddr]|{\cdots} \ar[ddrr]|{\psi'_n} \ar@/^1pc/[dd]|{\psi'_3} \\
 & & {S}  \ar[dll]|{\psi_1} \ar[dl]|{\psi_2} \ar[d]|{\psi_3} \ar[dr]|{\cdots} \ar[drr]|{\psi_n} \\
T_1 \ar[dr] \ar[d]|{\pi_{11}}  & T_2  \ar[dl] \ar[dr]  \ar[d]|{\pi_{22}} & T_3 \ar[d]|{\pi_{33}} \ar[dl] \ar[dr] & ... \ar[d]|{\pi_{ij}} \ar[dl] \ar[dr] & T_n \ar[d]|{\pi_{nn}} \ar[dl] \\  
A_1 & A_2 & A_3 & ... & A_m
}
\]
\caption{This commutative diagram serves to illustrate the concept of a join limit. For the sake of clarity, the composed morphisms from $S$ to $A_1, ..., A_m$ and from $S'$ to $A_1, ..., A_m$ have been omitted in the diagram.  } \label{fig:joinlimitdiagram}
 \end{figure}


 
 %because it can be expressed as a binary join dependency. For example, $X \to\to Y$ is the same as JD:*[$XY,X(U-Y)$], where U is the     Meanwhile, limits are the generalization of pullback. We use limits to define join dependency.

 %\begin{definition} (Universal arrow) A universal arrow from X to F is a unique pair ($A,u: X \to F(A)$) in D which has the following property, commonly referred to as a universal property. For any morphism of the form $f: X$ $\to$ $F(A')$ in D, there exists a unique morphism h: A $\to$ A' in C such that the following diagram commutes. \end{definition} 

 \begin{definition} (Cone) Let $\mathcal{J}$ and $\mathcal{C}$ be categories. A diagram of $\mathcal{J}$ in $\mathcal{C}$ is a functor $D:$$\mathcal{J}$ $\to$ $\mathcal{C}$. A cone to  $D$ consists of an object $S$ in $\mathcal{C}$ and a family of morphisms in $\mathcal{C}$, $\psi_X: S \to D(X) $ for each object $X$ in $\mathcal{J}$, such that for every morphism $f: X \to Y$, the triangle commutes $D(f) \circ \psi_X = \psi_Y$ in $\mathcal{C}$. $S$ is called the summit of the cone.
\end{definition}

\begin{definition} (Limit) A limit of the diagram $D:$$\mathcal{J}$ $\to$ $\mathcal{C}$ is a cone ($S, \psi_X$) to $D$ such that for every other cone ($S', \psi'_X$) there is a unique morphism $u: S' \to S$ such that $\psi_X \circ u = \psi'_X$ for all $X$ in $\mathcal{J}$. Thus, the limit is the ``\textit{closest}" cone to the diagram $D$. 
\end{definition}



%\begin{definition} \cite{MacLane:205493} (limits) Given categories C, J and the diagonal functor $\triangle: C \to C^J$, a limit for a functor $F: J \to C$ is a universal arrow (r,v) from $\triangle$ to F. It consists of an object r of C, called the limit object of the functor F, together with a natural transformation $v:\triangle r \to F$ which is universal among natural transformation $v:\triangle C \to F$. We call $\tau: c \to F$ a cone to the base F for the vertex c.\end{definition}


%\begin{definition} \cite{kan1958adjoint} (limits)Let $F \rightarrow J$ be a diagram of shape J in a category C. A cone to F is an object N of C together with a family $\psi_{X}: N \to F(X)$  of morphisms indexed by the objects X of J, such that for every morphism $f:X \to Y$ in J, we have  $F(f) \circ \psi _{X}=\psi_{Y}$.  A limit of the diagram $F:J\to C$ is a cone  $(L,\phi)$ to F such that for every other cone  $(N,\psi)$ to F there exists a unique morphism $u:N \to L$ such that  $\phi_{X} \circ u=\psi_{X}$ for all X in J. Limits are also referred to as universal cones, since they are characterized by a universal property.\end{definition}


%One says that the cone $(N,\psi)$ factors through the cone  $(L,\phi)$ with the unique factorization u.

%\begin{figure}
%\centering
%\includegraphics[width=0.5\textwidth]{figures/joinlimit.jpg}
%\caption{Illustration to the join limit}
%\label{fig:joinlimit}
%\end{figure}

%The following description connects the join dependency with limits. 

Based on the above general definition of limit, we describe a special type called \textbf{join limit} that is used in this paper to connect join dependency with limit. See the diagram in Figure \ref{fig:joinlimitdiagram}. A join limit is a limit of a diagram indexed by a  category $\mathcal{J}$. Consider a database category $\mathcal{C}$, $T_1,T_2,...,T_n$ are relationship objects, and $A_1,A_2,...,A_m$ are their associate objects. $\pi_{ij}$ is a projection morphisms from $T_i$ to $A_j$ defining a diagram of the shape in $\mathcal{C}$. A cone with the summit $S$ consists of  $m+n$ morphisms $\psi_X$, one for each object $X$ in the indexing category so that all triangles commute. The join limit $(S,\psi_X)$ is the closest cone over the diagram, such that for every other cone ($S', \psi'_X$) there is a unique morphism $u: S' \to S$ such that $\psi_X \circ u = \psi'_X$ for all $X$ in $\mathcal{J}$. In the context of the join limit, all morphisms $\psi_X$ and $\pi_{ij}$ are projection morphisms. The summit $S$ is a join limit, which satisfies $\bowtie[T_1,...,T_n]$. An example of join limit is shown in Introduction section (Figure \ref{fig:SPJJoin}) about three tables on \texttt{Supplier}, \texttt{Product} and \texttt{Project}.



%a commutative diagram with the following universal property (Figure \ref{fig:joinlimit}(b)): given any commutative diagram, there is a unique factorization of its legs through the summit of the limit cone. The limit object is called a join limit written $JD: *(T_1 \Join T_2 \Join ,..., \Join T_n)$.




%If J is the discrete category \{1,2,...$n$\}, a functor F: \{1,2,...$n$\} $\rightarrow$ C is a list of objects $<A_1,A_2,...,A_n>$ of C. The limit object is called a join limit of $a_1,a_2,...,a_n$, and is written $A_1 \Join A_2 \Join ,..., \Join A_n$; the limit diagram consists of $A_1 \Join A_2 \Join ,..., \Join A_n$ and $n$ arrows $f_1, f_2,...,f_n$, See Figure 9, called projection of the join limit. They constitute a cone from the vertex $A_1 \Join A_2 \Join ,..., \Join A_n$, so by the definition of a limit, there is a bijection of sets natural in c,\[ Hom(c,A_1 \Join A_2 \Join ,..., \Join A_n)   \cong Hom(c,A_1) \times  Hom(c,A_2) ... \times Hom(c,A_n)  \]which sends each $h$: $c \rightarrow A_1 \Join A_2 \Join ,..., \Join A_n$ to the set of composites $<f_1 h, f_2 h,... f_n h >$. Conversely, given arrows $g_i$:$c \rightarrow A_i $, there is a unique $h$: $c \rightarrow A_1 \Join A_2 \Join ,..., \Join A_n$ with $f_i h = g_i$. We write \[ h = (g_1.g_2,...g_n) : c \rightarrow A_1 \Join A_2 \Join ,..., \Join A_n  \]


%\begin{figure}\centering\[\xymatrix{&*+{SPJ (Limit)} \ar[dl] \ar[d] \ar[dr] \\SP \ar[dr] \ar[d]  & PJ  \ar[dl] \ar[dr] & SJ  \ar[d] \ar[dl]  \\  Product & Supplier & Project}\]\caption{An example to illustrate join limit.} \label{fig:SPJJoin}\end{figure}

 

%\begin{example} We illustrate the notion of join limit through an example involving three tables: \texttt{SP(Supplier, Product)},  \texttt{SJ(Supplier, Project)}, and \texttt{PJ(Project, Product)}. Assume the table \texttt{SPJ (Supplier, Project, Product)} = $SP \bowtie PJ \bowtie SJ$, which can be described using the concept of a join limit.   As shown in Figure \ref{fig:SPJJoin},  \texttt{SPJ} is the summit, \texttt{SP}, \texttt{PJ}, \texttt{SJ} are three relationship objects, and  \texttt{Product}, \texttt{Supplier} and \texttt{Project} are their projection objects.\end{example}

%satisfies a join dependency JD: *(\texttt{SP(Supplier, Product)}, \texttt{SJ(Supplier, Project)}, and 

 %Consider three tables \texttt{SP(Supplier, Product)}, \texttt{SJ(Supplier, Project)}, and \texttt{PJ(Project, Product)}.     The summit table \texttt{SPJ} shown in Figure \ref{fig:SPJJoin} satisfies a join dependency JD: *(\texttt{SP(Supplier, Product)}, \texttt{SJ(Supplier, Project)}, and \texttt{PJ(Project, Product)}). See Figure \ref{fig:joinlimitdiagram} for the commutative diagram of a join limit.


%This limit says that whenever a supplier s supplies part p, and a project j uses part p, and the supplier s supplies at least one part to project j, then the supplier will also be supplying part p to project j.

%\begin{figure}\centering\includegraphics[width=0.6\textwidth]{figures/LimitsGeneration.jpg}\caption{An example for the generation of limits from join dependency}\label{fig:limitsgeneration}\end{figure}

%Given a set of functional dependencies and join dependencies, Algorithm \ref{alg:JD2limit} shows how to generate a category.

%\begin{example} See Figure \ref{fig:limitsgeneration} for an example. In the first step, Bc, CD, and C are generated. Then in the second step, BC, CD are connected to C. In the last step, A, B D, E are generated and are connected to the corresponding set.\end{example}


%\begin{algorithm} \caption{Join dependency to limits }\label{alg:JD2limit}\input{algorithms/JD2limit}\end{algorithm}



%The following theorem shows that all limits can be boiled down to equalizer and product. Then this theorem can be explained that the join operator is considered an extended operator in relational algebra.  Any join operator can be boiled down to selection (which corresponds to equalizer) and cartesian product (which corresponds to product).

%\begin{definition} Let $\mathcal{C}$ be a category, and consider the diagram \[\begin{array}{ccc} A & \xRightarrow{f,g} & B \\ \end{array} \] The \textit{equalizer} of $f$ and $g$ consists of an object $E$ and a morphism $e: E \to A$ such that the following conditions hold: 1. $f \circ e = g \circ e$: This ensures that the diagram commutes. 2. For any object $Q$ and morphism $q: Q \to A$ satisfying $f \circ q = g \circ q$, there exists a unique morphism $\bar{q}: Q \to E$ such that $q = e \circ \bar{q}$: This condition states that for any other morphism $q$ satisfying the same property as $e$, there exists a unique morphism $\bar{q}$ that factors through $e$. The equalizer of $f$ and $g$ is denoted as $\text{eq}(f,g)$ or $\text{eq}(A,B)$. \end{definition}

%\begin{theorem} Any limit in a Set Category may be expressed as an equalizer of a pair of maps between products. Explicitly, for any small F: $J \to Set$, there is an equalizer diagram: \[ Lim_JF \to \prod_{j \in obj} F_j  \rightrightarrows  \prod_{f \in mor J} F(cod J) \]\end{theorem}The above theorem can be found in the book "category theory in context" \cite{riehl2017category}  page 87.

%The implication of join dependence is different from functional dependencies (fd's). It has been shown that there is no sound and complete set of inference rules for jd's analogous to those for fd's.  The absence of finite axiomatization for different types of dependencies, including join dependencies, is proved in paper \cite{petrov1989finite}. Note that The absence of a solution does not imply the nonenumerability of consequences. It implies only that a finite set of rules are not sufficient for obtaining all consequences. In addition, logical implication for jd's is decidable. The complexity of implication is polynomial for a fixed database schema but becomes NP-hard if the schema is considered part of the input \cite{10.5555/551350}.

%\begin{example}Figure shows an example to generate limits for a given set of JD dependencies.  \end{example}

%\begin{lemma}All join dependencies can be represented as limit objects in a category. \label{lem:join}\end{lemma}\begin{proof} See Algorithm \ref{alg:JD2limit} which shows how to convert a join dependency specification into a limit. Since the university property of limits, this algorithm can output results to find all join results. \end{proof}

%Meanwhile, it is important to note the difference between the three dependencies in the category. First functional dependency can be directly depicted in categories with an arrow. Second join dependency can be defined as a limit in the category. Third, multivalued dependency $X \to\to Y$ is more complicated. In fact, this MVD definition relies on the context. 



%\begin{figure}\centering\includegraphics[width=0.7\textwidth]{figures/JDImplication.jpg}\caption{This is an example to illustrate the necessity of implication for Join dependency implication. If we cannot find all JDs, then the output schema may not satisfy the generalized JD normal form. In this example, the table R6 can be computed from the join of R3, R4, and R5, and a projection on $x_1$ and $z$. }\label{fig:JDImplication}\end{figure}

%\begin{corollary}Any limit object in a database category may be computed through set intersection operations between caterisian products. \end{corollary}

%This theorem shows that all limits can be computed product and intersection operators in sets. 


\subsection{Pushout}

%The previous discussion highlights the correlation between pullbacks (limits) and multi-valued dependencies (join dependencies). This connection raises another question: how can we elucidate pushouts and colimits, which serve as the dual concepts to pullbacks and limits, respectively? 



In category theory, ``\textbf{duality}'' establishes a relationship between two concepts or operations by interchanging certain elements or properties. One such instance of duality exists between pushout and pullback. While a pullback captures the splitting of a morphism into two through projection, a pushout represents a way to merge two morphisms into a single entity. As pullbacks are associated with join operators, pushouts effectively define the equivalent class within a  database.


%Given that pullbacks are associated with multivalued dependencies, an intriguing inquiry arises as to whether pushouts give rise to another form of database constraint. In the subsequent discussion, we aim to demonstrate that pushouts indeed define the connected components within a graph database.

%The above discussion shows the connection between pullback (limit) and multi-valued dependency (join dependency). A natural question arises: how to explain pushout and colimit which are dual concepts of pullback and limit? In category theory,  duality is a notion that establishes a relationship between two concepts or operations by interchanging certain elements or properties. One such example is the duality between pushouts and pullbacks. while a pullback represents the operation that captures the splitting of a morphism into two by projection, a pushout represents a way to combine two morphisms into one. Given that pullbacks are associated with multivalued dependency, an intriguing inquiry arises as to whether pushouts give rise to another form of database constraint. In the subsequent discussion, we demonstrate that pushout indeed defines the connected components within an undirected graph database.



%Since pullback corresponds to multivalued dependency, one interesting question is whether pushout leads to another database constraint. In the following, we show that pushout actually defines the connected components in a (undirected) graph.

%A pushout is a quotient of the disjoint union of two sets. The ‘pushout’ of this diagram is the set X obtained by taking the disjoint union A+B and identifying $a \in A$ with $b \in B$ if there exists $x \in C$ such that $f(x)=a$ and $g(x)=b$ (and all identifications that follow to keep equality an equivalence relation).

%\begin{figure}\centering\includegraphics[width=0.7\textwidth]{figures/pushoutfamily2.jpg}\caption{Illustration to pushout with an example }\label{fig:pushoutfamily}\end{figure}

\begin{definition}  (Pushout) Given a category $\mathcal{C}$ with three objects $A$, $B$, and $C$, and two morphisms: $f: A \to B$, $g: A \to C$. The pushout $P$ of $f$ and $g$ consists of morphisms $p_1: B \to P$  and $p_2: C \to P$ such that $p_1 \circ f$=$p_2 \circ g$  and $P$ has the universal property. That is, given any other object $P'$ with two morphisms $p'_1: B \to P'$  and $p'_2: C \to P'$ such that $p'_1 \circ f$ = $p'_2 \circ g$, there exists a unique morphism $u: P \to  P'$ with $u \circ p_1 = p'_1$ and  $u \circ p_2 = p'_2$.




%\[
%  \xymatrix@=3pc{
%    & & P' \\
%    B \ar[r]^{p_1}\ar@/^/[rru]^{p'_1} & P \ar@{.>}[ru]_u  & \\
%    A \ar [u]^f \ar[r]_g & C \ar[u]_{p_2}\ar@/_/[ruu]_{p'_2} &
%  }
%\]



\end{definition}


%\begin{definition} (Pushout)  Let $\mathcal{C}$ be a category and $f: A \to B$, $g: A \to C$. The \textit{pushout} of $f$ and $g$ in $\mathcal{C}$ is a universal object denoted by $B \sqcup_A C$, along with the morphisms $i: B \to B \sqcup_A C$ and $j: C \to B \sqcup_A C$, satisfying the following conditions:1. The diagram below commutes:\[
%\xymatrix{
%    A \ar[r]^{f} \ar[d]_{g} & B \ar[d]^{i} \\
%    C \ar[r]_{j} & B \sqcup_A C
%}
%\]
%2. For any object $X$ in $\mathcal{C}$ and morphisms $h: B \to X$ and $k: C \to X$ such that $h \circ f = k \circ g$, there exists a unique morphism $m: B \sqcup_A C \to X$  such that $h = m \circ i$ and $k = m \circ j$. The pushout $B \sqcup_A C$ together with $i$ and $j$ is uniquely determined up to isomorphism.\end{definition}




%\begin{definition} (Pushout)Let $\mathcal{C}$ be a category, and consider the diagram\[\begin{array}{ccc}A & \xrightarrow{f} & B \\\downarrow{g} & & \downarrow{h} \\C & \xrightarrow{k} & D \\\end{array}\]The \textit{pushout} of the diagram is an object $P$ together with morphisms $i: B \to P$ and $j: D \to P$ satisfying the following conditions:1. $i \circ f = j \circ g$: This ensures that the diagram commutes.2. For any object $Q$ and morphisms $u: B \to Q$ and $v: D \to Q$ satisfying $u \circ f = v \circ g$, there exists a unique morphism $\bar{u}: P \to Q$ such that $u = \bar{u} \circ i$ and $v = \bar{u} \circ j$: This condition states that for any other morphisms $u$ and $v$ satisfying the same properties as $i$ and $j$ respectively, there exists a unique morphism $\bar{u}$ that factors through $i$ and $j$.The pushout of the diagram is denoted as $\text{pushout}(f,g,k)$ or $\text{pushout}(A,B,C,D)$.\end{definition} 

 In the context of set category, the pushout of $f$ and $g$ is the disjoint union of $B$ and $C$, where elements sharing a common preimage (in $A$) are identified, together with the morphisms $p_1, p_2$ from $B$ and $C$, i.e.  $P=(B\cup C)/ \sim $, where $\sim$ is the equivalence relation
such that $f(a) \sim g(a)$ for all $a \in A$ .


%\begin{example}  This example constructs a database instance to illustrate pushout. Consider a category with a  \texttt{Mother} object which has two elements \{$m_1$, $m_2$\}, a \texttt{Father} object with three elements:  \{$t_1$, $t_2$, $t_3$\}, and a \texttt{Child} object with three elements:  \{$s_1$, $s_2$, $s_3$\} such that $f(s_1)=m_1$, $f(s_2)=m_1$, $f(s_3)=m_2$, $g(s_1)=t_1$, $g(s_2)=t_2,  ~g(s_3)=t_3$. Then the pushout \texttt{Family} object contains two equivalence classes (elements): ($m_1$,$t_1$,$t_2$) and ($m_2$,$t_3$). The commutative diagram is illustrated below: 
%\[\xymatrix{Child \ar[r]^{f} \ar[d]_{g} & Mother \ar[d]^{p_1} \\Father \ar[r]_{p_2} & Family }\]
%\end{example}

%Further, pushout can be used to define connected components in an undirected graph, as each connected component constitute an equivalence class. More details for an example can be found in Appendix \ref{sec:pushout}.

%The pushout can be also employed to compute connected components within an undirected graph, as each connected component forms an equivalence class. For further elucidation and an example, please refer to Appendix \ref{sec:pushout}.

The following example illustrates the connection between the pushout and the connected component of an undirected graph.

\begin{example} Given an undirected graph $G$, the \texttt{Edge} table includes two attributes \texttt{Node\_id1} and \texttt{Node\_id2}, which describes edges between any two nodes in $G$.   The pushout object \texttt{Component} computes the connected component in the graph $G$, as illustrated in the following commutative diagram.


\[\xymatrix{Edge \ar[r]^{f} \ar[d]_{g} & Node\_id1 \ar[d]^{p_1} \\Node\_id2 \ar[r]_{p_2} & Component (Pushout) }\]\end{example}

%Note that the pullback object in category theory corresponds to the join operator in relational databases and the pushout object corresponds to the connected component in an undirected graph. Since pullback and pushout are dual objects, a captivating observation emerges: the join operator of relational databases and the computation of connected components of graph databases exhibit duality when viewed through the lens of category theory.

Consider that the pullback object corresponds to the join operator in relational databases, while the pushout object corresponds to the connected component in an undirected graph. As pullback and pushout are dual objects, an intriguing observation arises: \textit{the join operator in relational databases and the computation of connected components in graph databases demonstrate duality when examined through the lens of category theory}.

%For a general undirected graph, we may use the following coequalizer to compute the connected component.

%\begin{definition} (Coequalizer)Let $\mathcal{C}$ be a category and $f, g: A \to B$ be two morphisms in $\mathcal{C}$. A \textit{coequalizer} of $f$ and $g$ consists of an object $Q$ and a morphism $q: B \to Q$ such that the following conditions hold:1. $q \circ f = q \circ g$: This ensures that the diagram commutes. 2. For any object $R$ and morphism $r: B \to R$ satisfying $r \circ f = r \circ g$, there exists a unique morphism $\bar{r}: Q \to R$ such that $r = \bar{r} \circ q$: This condition states that for any other morphism $r$ satisfying the same property as $q$, there exists a unique morphism $\bar{r}$ that factors through $q$.The coequalizer of $f$ and $g$ is denoted as $\text{coeq}(f,g)$ or $\text{coeq}(A,B)$.\[  A  \rightrightarrows  B  \rightarrow Q \]\end{definition} 



%\begin{example} Consider another example about pushout with an undirected graph $G$. The \texttt{Edge} table includes two attributes \texttt{Node\_id1} and \texttt{Node\_id2}, which describes edges in $G$.   The pushout object \texttt{Component} computes the connected component in the graph $G$, as illustrated in the following commutative diagram.


%\[\xymatrix{Edge \ar[r]^{f} \ar[d]_{g} & Node\_id1 \ar[d]^{p_1} \\Node\_id2 \ar[r]_{p_2} & Component }\]\end{example}


%\begin{figure}\centering\includegraphics[width=0.4\textwidth]{figures/colimitSPJ.jpg}\caption{Illustration to colimit with SPJ}\label{fig:colimitSPJ}\end{figure}




%Pushout is a special type of colimit. It is straightforward to obtain the definition of colimit by inverting all morphisms in the limit.  The application of colimit includes the generalization of graph connect components as illustrated in the following example. 


%we will explicitly state them here and give an example of colimits in databases.

%\begin{definition} (colimits)Let $F: J \rightarrow C$ be a diagram of shape J in a category C. A co-cone to F is an object N of C together with a family $\psi_{X}:  F(X) \to N$  of morphisms indexed by the objects X of J, such that for every morphism $f:X \to Y$ in J, we have  $\psi_{Y} \circ  F(f) = \psi _{X}$.  A colimit of the diagram $F:J\to C$ is a co-cone  $(L,\phi)$ to F such that for every other cone  $(N,\psi)$ to F there exists a unique morphism $u:L \to N$ such that  $u \circ \phi_{X}  =\psi_{X}$ for all X in J.\end{definition}




%\begin{example} Consider an example of limits. We inverse the arrows on supplier, project and product. This is a generalized version of connected component, which shows the number of components fro supplier, project and product without any overlapping.  \end{example}




%Similarly, there is a general method to construct colimits in any category via coproducts and coequalizers. Let A and B be categories, and $T: A \to B$ be a functor. If B has coproducts of all families indexed by objects and morphisms of A and all binary coequalizers, then the colimit of T exists. It is the coequalizer of a pair of maps (F, G) from the coproduct of all domains of T to the coproduct of all values of T, such that F maps each morphism f in A to its domain and G maps each morphism f in A to its codomain composed with T(f). This means that any colimit in a category can be expressed as an coequalizer of a pair of maps between coproducts in that category.

%we prove the analogous formula for limits or colimits of diagrams valued in any category by reducing the proofs of these general results to the case of limits in Set. This strategy succeeds because limits and colimits in a general locally small category are defined representably in terms of limits in the category of sets. See around page 97 of that book.


% \begin{definition} (left restorable arrow) Let $A$, $B$ and $C$ are three objects in a category.  Let f: $A \to B$,  g: $B \to C$, and  k=   $g \circ f$. We say that $f$ is a left restorable arrow for $g$ and $k$ if and only if  $g$ is an injective function. That is, $g$ maps distinct elements of $B$ to distinct elements of $C$;\end{definition}

%\begin{lemma}Let $A$, $B$ and $C$ are three objects in a category.  Let f: $A \to B$,  g: $B \to C$, and  k=   $g \circ f$. If $f$ is a left unique arrow for $g$ and $k$, then the function $f$ can be derived from $g$ and $k$. \end{lemma} \begin{proof}We need to prove that given any element $a \in A$, the image of $a$ in $B$ can be uniquely decided by $g$ and $k$.  In fact, $f(a)=g^{-1}(k(a))$ and $g^{-1}$ exists for $k(a)$. Because the preimage of $k(a)$ always exists in $B$ and it is unique, as $g$ is an injective function and $k=   g \circ f$. \end{proof}

%\begin{definition} (right restorable Arrow) Let $A$, $B$ and $C$ are three objects in a category.  Let f: $A \to B$,  g: $B \to C$, and k =   $g \circ f$. That is, A, B C compose a commutative triangle. We say that $g$ is a right restorable arrow for $f$ and $k$ if and only if $f$ is a surjective function. That is, every element of $B$ is the image of at least one element of $A$.\end{definition}

%\begin{lemma} Let $A$, $B$ and $C$ are three objects in a category.  Let f: $A \to B$,  g: $B \to C$, and  k=   $g \circ f$. If $g$ is a right restorable arrow for $f$ and $k$, then the function $g$ can be derived from $f$ and $k$.\end{lemma}\begin{proof}We need to prove that given any element $b \in B$, the image of $b$ in $C$ can be uniquely decided by $f$ and $k$.   Because  $f$ is a surjective function, consider any $a$ in A and $f(a)=b$. We say that $g(b)=k(a)$, because $k=   g \circ f$. It is impossible that there is another element $a'$, s.t., $f(a')=b$, but $k(a) \neq k(a')$, as g is a single-image function.\end{proof}


%Functional dependencies play a crucial role in database management systems (DBMS) as they define the relationships between sets of attributes within a relation. These dependencies are essential for the design of efficient database schemas and the process of normalization. In the realm of relational databases, algorithms exist to derive a set of relational schemas from a given set of functional dependencies. These schemas adhere to specific levels of normal form, thereby minimizing data redundancy and ensuring data consistency. In this paper, we extend this concept further by proposing algorithms that convert sets of functional dependencies into a unified category. From this unified category, we generate different types of data representations, including relations, XML, and property graphs. Notably, these output data representations maintain the unified principles of normal form, thereby reducing redundancy and ensuring data consistency across the various data models.Algorithm 





%\begin{figure}\centering\includegraphics[width=0.6\textwidth]{figures/necessaryOfImplication.jpg}\caption{This example shows the necessity to compute the implication of FD. In this example, if we do not know the arrow from a to BC, then the output schema will not satisfy the 3NF. Thus, it is important to derive all related arrows (FDs) that are defined with the objects in the category.}\label{fig:implication}\end{figure}

%A set of constraints $C$ implies a constraint $c$, written $C \models c$, if $SAT(C)$ contains $SAT(c)$. A designer usually provides an explicit set of functional dependencies F whose closure F+ is the complete set of functional dependencies in the category representation. We say one functional dependency $X \to Y$ is proper  if there is no proper subset $X' \subset X$, such that  $X' \to Y$. In addition, the trivial FD $X \to Y$ means that $Y$ is a subset of $X$, otherwise, it is non-trivial.  Given any FD $X \to Y$, if $X$ includes two or multiple attributes, then we need to create a composite attribute which is an attribute object, but its elements are surrogate keys.  

%(1) Projection: for any two sets of objects $X$ and $Y$, then $XY \to X$ and  $XY \to Y$ are two projection morphisms.(2) Union: for any two sets of objects: if $X \to Y$ and $X \to Z$ then $X \to YZ$ is a composite morphism. Note that $YZ$ is not a Cartesian product object of $Y$ and $Z$. In particular, if $f(x)=y$ and $g(x)=z$, then $k: X \to YZ$ is defined as $k(x)=(y,z)$. (3) Composable: given three objects, if $X \to Y$, $Y \to Z$, then $X \to Z$. 



%\begin{algorithm} \caption{Complete a category given a set of functional dependencies}\label{alg:addarrows}\input{algorithms/addArrows}\end{algorithm}

%\begin{example}  This example illustrates the algorithm \ref{alg:addarrows}. Consider the FD $\Sigma$=\{$A \to B$, $A \to C$, $BC \to D$\}. $\Sigma^+$=$\Sigma$ $\cup$ \{$A \to D$\}, $\Sigma^\{++\}$=$\Sigma^+$ $\cup$ \{$A \to BC$\}. Finally, some projection arrows can be added such as $BC \to B$ and $BC \to C$. \end{example}


%\begin{lemma}Given a set of functional dependencies F and a category C which is constructed based on F with the above rules, all properly functional dependencies occur in $C$ as the arrows.    \label{lem:completeFDs}\end{lemma}

%Proof: The correctness holds based on the Armstrong axioms. All proper functional dependencies can be derived and constructed in C as arrows.  



%\subsection{Comparison between classic and categorical ER models}

%Table \ref{tab:ERmodel} provides a summary of the distinctions between the classic Entity-Relationship (ER) model and the categorical model proposed in this paper.


%\noindent \textbf{Comparison between the classic and categorical ER model}: The primary differentiation between the two models arises from three perspectives: 

%(1) The categorical ER model introduces the concepts of pullback, pushout, and limit, which encompass richer semantic constraints compared to the classic ER model.

%(2) The categorical ER model explicitly defines composable morphisms and the associative property, aspects that are not explicitly addressed in the classic ER model.

%(3) A fascinating connection emerges between the representation of the categorical model and the database normal form theory, which will be elaborated in the subsequent sections.

%It is noteworthy that related works (e.g., \cite{10.1145/111197.111200,10.1145/7474.7475} etc) have also extended the ER diagram to incorporate semantic notions and additional information, such as object-oriented features. An extensive discussion regarding related works on extended ER models with category theory can be found in Section \ref{sec:relatedwork}.






%(1) The categorical ER model in this paper introduces the concepts of pullback, pushout, and limits, which encompass richer semantic constraints compared to the classic ER model. (2) The categorical ER model explicitly defines composable morphisms and the associative property, which are not explicitly addressed in the classic ER model. (3) There is an intriguing connection between the representation of the categorical model and the database normal form theory, which will be described in the following sections.  Note that  related works (e.g. \cite{10.1145/111197.111200,10.1145/7474.7475} ) have also extended the ER diagram to incorporate semantic notions and additional information, such as object-oriented features.  See Section \ref{sec:relatedwork} for more discussion about related works about extended ER models with category theory. 



 

\begin{comment}
\begin{table}
\centering
\begin{tabular}{ |c|c| } 
 \hline
 Classic ER model & Categorical model\\ [0.5ex] 
  \hline  \hline 
 Entity & Entity object \\ 
 \hline 
 Relationship & Relationship object  \\ 
 \hline
 Attributes & Attribute object  \\ 
 \hline 
 No correspondence & Composition \\ 
  \hline
 Key attribute &  Bijective morphism \\ 
 \hline
Function dependency  &  Function morphism \\
\hline
Multivalued dependency  &  Pullback \\
 \hline
Join dependency  &  Limit \\
 \hline
No correspondence  &  Pushout and Colimit \\
 \hline
\end{tabular}
\caption{Comparison between classic ER and categorical ER models}
\label{tab:ERmodel}
\end{table}
\end{comment}

%\begin{figure}\centering\includegraphics[width=0.6\textwidth]{figures/commutativeexample.jpg}\caption{An example to illustrate the commutative diagram.}\label{fig:commutativediagram}\end{figure}





%\begin{figure}\centering\includegraphics[width=0.6\textwidth]{figures/colimitexample.jpg}\caption{An example to illustrate the example of colimit constraint.}\label{fig:colimitexample}\end{figure}


%\begin{figure}\centering\includegraphics[width=0.4\textwidth]{figures/universal.jpg}\caption{Illustration to the universal morphism. }\label{fig:universalmorphism}\end{figure}

%\begin{figure}\centering\includegraphics[width=0.4\textwidth]{figures/loopdiagram.jpg}\caption{A loop diagram to illustrate the commutative diagram. }\label{fig:loopdiagram}\end{figure}








