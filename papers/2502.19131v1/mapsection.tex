\section{Mapping to Relation Data Schema}

%In the view of this paper, the purpose of a database is to store all information on objects and morphisms in a (set) category. For example,  a relational database stores data using relational tables. An XML database uses XML documents and a  multi-model database leverages the combination of multiple formats of data to store the information in a category. 



%In this section, we introduce an algorithm for mapping a category schema to a relation schema. Due to space limitations, other algorithms which map a category schema to XML and property graph schemas have to be put in Appendix.  Before delving into the details, we provide an overview of the notations that will be used throughout this discussion.

\begin{algorithm} \caption{Map  category schema to relational Schema}
\label{alg:map2relationschema}
\input{algorithms/map2relationschema3}
\end{algorithm}

In this section, we present an algorithm that converts a category schema into a relation schema. Due to space constraints, the algorithms that converts a category schema to XML, graph and hybrid schemata are included in Appendixes \ref{sec:XMLDTD} to \ref{sec:hybrid}.

%Prior to delving into the algorithm, we offer an overview of the notations that will be employed.

%\subsection{Notations of Categories}

%Following the relational database notation, the symbol $\pi$ represents a projection edge in  $E(G(\mathcal{C}$ between two objects.

Let us consider a category denoted as $\mathcal{C}$ and its corresponding reduced representation, $G(\mathcal{C})$.  The set of nodes in the representation is referred to as $V(G(\mathcal{C}$)), while the set of edges is denoted as $E(G(\mathcal{C}))$.  For an object $O$ in $V(G(\mathcal{C}$)), the label associated with node $O$ is denoted as $\lambda_G(O)$.  Furthermore, the set of outgoing objects from  $O$ is denoted as $outNbr_{G(C)}(O)$, and the set of bi-directional neighbors is denoted as $bin_G(O)$. To simplify the notation, when the graph $G(\mathcal{C})$ is clear from the context, we may simply use $\lambda(O)$,  $outNbr(O)$, and $bin(O)$ respectively. In addition, a database schema on universe $U$ is a set $R$ of relation schemes \{$R_1,R_2,...,R_p$\},
where  $\bigcup_{i=1}^{p} R_{i} = U$.
The set of attributes of $R_i$ is $sort(R_i)$ and the surrogate key of $R_i$ is denoted by $SK(R_i)$ (if any).

%If $O$ is an entity or relationship object, then $SK_G(O)$ refers to the surrogate keys of $O$.


%Table \ref{tab:notation} provides a summary of the notations used in the algorithms.


%A database schema on universe $U$ is a set $R$ of relation schemes \{$R_1,R_2,...,R_p$\}, where  $\bigcup_{i=1}^{p} R_{i} = U$. The label (name) of a table $R_i$ is $\lambda(R_i)$. Given a tuple $t$ in a relation, the surrogate key of $t$ (if any) is denoted as $SK(t)$.


%XML is represented as a finite rooted directed tree, with each node in the tree associated with a tag. Within this tree structure, two special attributes are assigned to nodes: @ID and @IDREF. The @ID attribute serves as a unique identifier (key) for a particular node, while the @IDREF attribute is used to reference the ID of other nodes. Note that each node possesses only one @ID attribute, but it can have multiple @IDREF attributes to refer to different nodes within the XML structure.

%An XML tree T is a tree with 5-tuple($V$, lab, elem, att, root) where $V$ is a ﬁnite set of node (tags); $lab$ map each node $v$ in $V$ to a type (tag); $elem$ map each node $v$ in a string or a set of other nodes;  att is a partial function $V \times Att \to str$. For each v, the set @a $\in Att $. There are two special attributes are assigned to nodes: @ID and @IDREF, $root \in V$ is the root of T. Note that, in general XML trees, children of each node are ordered. However, this paper focuses on XML normal form theory, which does not use the ordering in the tree, we  disregard this ordering. 

%\begin{definition}(XML tree) An XML tree T is a tree with 5-tuple($V$, lab, elem, att, root) where\begin{itemize}\item $V$ is a ﬁnite set of node (tags);\item $lab$ map each node $v$ in $V$ to a type (tag);\item $elem$ map each node $v$ in a string or a set of other nodes  \item  att is a partial function $V \times Att \to str$. For each v, the set @a $\in Att $. There are two special attributes are assigned to nodes: @ID and @IDREF.   \item $root \in V$ is the root of T.\end{itemize}\end{definition}

 

%\begin{definition} A DTD is a 5-tuple($L$, A, P, R, r) where\begin{itemize}\item $L$ is a ﬁnite set of element types (tags);\item $A$ is a ﬁnite set of strings (attributes), starting with the symble @;\item P is a set of rules $a \rightarrow P_a$ for each $a \in L$, where  $P_a$ is a regular expression over $L$ - \{$r$\}\item  R assigns  each $e \in L $ a ﬁnite  subset of A (possibly empty; R(a) is the set of attributes of a)\item $r \in L$ is the root.\end{itemize}\end{definition}



% A DTD is a 5-tuple($L$, A, P, R, r) where $L$ is a ﬁnite set of element types (tags); $A$ is a ﬁnite set of strings (attributes), starting with the symble @; P is a set of rules $a \rightarrow P_a$ for each $a \in L$, where  $P_a$ is a regular expression over $L$ - \{$r$\}.  R assigns  each $e \in L $ a ﬁnite  subset of A (possibly empty; R(a) is the set of attributes of a, $r \in L$ is the root.

%A property graph, denoted as $PG(V,E)$, represents an undirected multi-edge graph. It consists of a vertex set $V$ and an edge set $E$. In this graph, each vertex $v \in V$ and each edge $e \in E$ possess data properties in the form of multiple attribute-value pairs \{$(a,u)$\}. The labels of the nodes and edges are denoted by $\lambda(v)$ and $\lambda(e)$ respectively.

%A Property graph schema is a 5-tuple(V, E, A, L, P) where V is a ﬁnite set of vertices; E is a ﬁnite set of edges; A is a ﬁnite set of attributes; L is a ﬁnite set of labels (names) of vertices and edges; P is a function $V \cup E \rightarrow \{(a,str)\}$, mapping vertices and edges to a set of attribute-value pairs.

%\begin{definition}(Property graph schema) A Property graph schema is a 5-tuple(V, E, A, L, P) where\begin{itemize}\item V is a ﬁnite set of vertices;\item E is a ﬁnite set of edges;\item A is a ﬁnite set of attributes; \item L is a ﬁnite set of labels (names) of vertices and edges;\item P is a function $V \cup E \rightarrow \{(a,str)\}$, mapping vertices and edges to a set of attribute-value pairs. \end{itemize}\end{definition}

%Given a unified categorical model (including schema category and instance category),  describe In this section, we describe algorithms to map the representations of categories to different types of data, including relation, hierarchical, graph, and hybrid data set. We show that the output data schemata satisfy different normalized forms with various reduced representations. 

\begin{comment}
\begin{table}
\centering
\begin{tabular}{ |c|c| } 
 \hline
 Category $\mathcal{C}$ & \\ [0.5ex] 
  \hline  \hline 
Objects & $O, A, B, C$ \\ 
 \hline 
 Functions (Arrows) & $f, g$   \\ 
 \hline
 Labels of objects and  arrows & $\lambda(O)$, $\lambda(f)$   \\ 
 \hline  
  Bi-directional neighbours of $O$ & $Bin(O)$ \\
  \hline
 Outgoing neighbours of $O$ &  $outNbrAdj(O)$ \\ 
 \hline
 The set of the associated objects of $O$   &   $\pi(O)$ \\
 \hline
 the surrogate key of $O$  &   $SK(O)$ \\
 \hline
XML tree data  &   \\
 \hline
ID and IDREF attributes  & @ID, @IDREF   \\
 \hline
Property Graph $\mathcal{PG}$ &   \\
 \hline
Vertices and edges  &  $V, E$ \\
 \hline
 Types of vertices and edges  &  $\lambda(v)$, $\lambda(e)$ \\
 \hline
 Attribute-value pairs of vertices and edges  &  $\rho(v)$, $\rho(e)$ \\
 \hline
\end{tabular}
\caption{Notation}
\label{tab:notation}
\end{table}
\end{comment}




%The algorithm processes each object $O$ in a specific order: entity, relationship, and attribute objects (Line 1).

%Algorithm \ref{alg:map2relationschema} outlines the framework to map a reduced representation $G(\mathcal{C})$ to a  relational schema.  For each object $O$, a new relation $R_i$ is generated (Lines 2-5), and the neighbor objects $N$ of $O$ are inserted into $R_i$ as attributes (Lines 6-10). If $N$ is an entity or relationship object, treat the attribute $N$ as a foreign key in $R_i$, referring to the relation generated for $N$ (Lines 12). If $N$ is a bidirectional neighbor of $O$, then all outgoing edges of $N$ are also inserted into $R_i$, as $N$ is a key of $R_i$ because of the bijective function between $N$ and $O$ (Line 13-15).  Finally, clean the output data by removing surrogate keys if they are not referenced by any other table, and removing the subsumed relations (Lines 17-21).

Algorithm \ref{alg:map2relationschema} outlines an approach for the conversion of a reduced representation $G(\mathcal{C})$ into a relational schema.  The algorithm proceeds as follows: For each object $O_i$ having outgoing edges, a corresponding relation $R_i$ is instantiated (Lines 1-8).  The algorithm proceeds to include every outgoing neighbor $N$ of $O_i$ as an attribute within relation $R_i$ (Lines 10-17). If $N$ is an entity or relationship object, the surrogate key of $N$ is treated as a foreign key in $R_i$, referencing the relation generated for $N$ (Lines 13-14). Additionally, if $N$ is a bidirectional neighbor of $O_i$, the algorithm augments $R_i$ with the outgoing neighbors of $N$, since $N$  serves as a key in $R_i$ due to the bijective relationship between $O_i$ and $N$ (Lines 15-17). Finally, the algorithm eliminates subsumed relations and removes any surrogate key that is not referred to by any other relation (Lines 18-23). 

%Appendix \ref{sec:category2relation} show several examples to illustrate this algorithm. 




\begin{example} Recall the 1RR graph in Fig \ref{fig:1RRExample}(c). If we run Algorithm \ref{alg:map2relationschema}, the output comprises three relations:  $R_1(A,E)$  (key is $AE$) ($D$ is removed in Line 21), $R_2(A,B)$  (key is $A$) and $R_3(B,C)$  (key is $B$). All those relations satisfy  BCNF. In contrast, if we convert the input graph in Figure \ref{fig:1RRExample}(a) into relations, they include a table $R(A,B,C)$ (with $A$ as the key), which fails to satisfy BCNF (or 3NF) due to $B \to C$.  This example provides an intuitive demonstration of the benefits of the 1RR approach, which ensures that the resulting output schema satisfies BCNF. 

%A more formal discussion will follow in the next section.
\end{example}

%\begin{example} Example \ref{exp:2RRExample} shows a 2RR graph in Figure \ref{fig:2RRExample}(c). If we run the above algorithm, the output schema comprises four relations:  $R_1(A,E)$ (key is $AE$), $R_2(A,C,F)$, (key is $A$), $R_3(F,B)$ (key is $F$), and $R_4(B,D)$ (key is $B$). All those relations satisfy the 4NF.  However, if we convert the input in Figure \ref{fig:2RRExample}(a) into a relation schema, wherein one output table  $R_5(A,E,D)$ is not in 4NF due to the MVD $A \to\to_{R_5} D$. This example provides an intuitive demonstration of the benefits of the 2RR approach, which ensures that the resulting output schema satisfies 4NF. The forthcoming section will provide proof of this result. \end{example}

%In contrast, if we convert the input graph in Figure \ref{fig:1RRExample}(a) to relational schema, then $R(A,B,C)$ (key is $A$) is output, but it not in BCNF (or 3NF) due to the FD $B \to C$. This example intuitively shows that the 1RR can guarantee that the output schema satisfies BCNF. We will give proof of this result in the next section. 


%A database schema S is a ﬁnite set of relation names, with a set of attributes, denoted by attr(R), associated with each R $\in$ S. We shall identify attr(R) of cardinality m with \{1, . . ., m\}.  An instance I of schema S assigns to each symbol R $\in$ S with m = $attr(R)$ a relation I(R) which is a ﬁnite set of m-tuples over N+.



%\begin{algorithm} \caption{Map to Relational Data}\label{alg:map2relation2}\input{algorithms/map2relation2.tex}\end{algorithm}

%\begin{figure}\centering\includegraphics[width=0.8\textwidth]{figures/ex02.jpg}\caption{ Two FDs: Student, Course $\to$ Instructor and Instructor $\to$ Course. Figure C illustrates that the base diagram can avoid the edge between SC and Course, and generate three tables to satisfy the  BCNF. R1(SC, student, Instructor), R2(Instructor,Course). Then The relation between SC and course can be derived from R1 and R2. Note that in relation tables R(student, instructor, course), we cannot find a lossless decomposition to obtain tables satisfying BCNF. }\label{fig:exampleC}\end{figure}






%Further, if $N$ is an entity or relationship neighbor of $O$, the surrogate key of $N$ is added as an IDREF attribute to $O$ (Lines 20-22). This step establishes a linkage between $N$ and $O$ through the IDREF attribute.


%This mapping facilitates the representation and validation of XML data according to the structure and relationships defined in the reduced representation schema.


%The neighbor node $n$ of $O$ are output with the child node of v. The surrogate keys are defined as the ID attribute of the element.  The bi-directional node n is included in the subtrees of v, as n and v have a bijective function between them. 




 

%Readers might notice that the mapping algorithm above  generates the trees whose length are  always two, i.e. a shallow and wide tree. There are two reasons to explain this: (i) any tree can be reorganized as two levels tree with the schema shown in the figure (one object with all nodes, and the other objects with the edges), (ii) the normalization requires to reduce the redundancy. The tree with higher depth is more possible to incur the the redundancy. For example, see $root \to A$, $A \to B$, $B \to C$, R(A)=\{@SerialKey\_A\}, R(B)=\{@SerialKey\_B\} and R(C)=\{@SerialKey\_C\}.  If two different A has the same B, then the C nodes under the B has to be reduplicated. Therefore, it will cause the redundancy storage and violates the normalization. One way to avoid the redundancy is to use this schema: $root \to A,B,C$, R(A)= \{@SerialKey\_A, @SerialKey\_B\},   R(B)=\{@SerialKey\_B, @SerialKey\_C\}, R(C)=\{@SerialKey\_C\}.  










%\begin{algorithm} \caption{Map to Property Graph}\label{alg:map2graph2}\input{algorithms/map2graph2}\end{algorithm}

%\item L is a ﬁnite set of labels (names) of $V \cup E$; 




%The associated attribute objects are included as attribute-value pairs for the corresponding node.
 
%Algorithm \ref{alg:map2graphschema} provides a mapping procedure for converting a category into a property graph schema.  Initially, convert each entity object in the category into a node in the property graph (Lines 2-3).  Then convert binary relationship objects into edges connecting two objects in the property graph (Lines 7-8). For the ternary or multi-way relationship objects, a node is created in the graph to represent the relationship (Lines 9-10). Assuming $N$ is a neighbor from  $O$. If $N$ is an attribute object, add $N$ as an attribute for $O$ (Lines 16-17). If $N$ is an entity (or relationship) object create a new edge in the graph for the object $N$ (Lines 18-19).   If the edge between $N$ and $O$ is bidirectional, add all outgoing neighbors of $N$ to an attribute value or an edge for $O$ (Line 20-21). 



%By following this algorithm, a category can be effectively mapped to a property graph schema. This mapping process facilitates the categorical representation in a graph-based database environment.
 
 %See an example in Figure \ref{fig:composedarrows}, assume that SSN has another attribute  object N, then this attribute will be added to Person object as an attribute-value pair, instead of a pair for SSN. We will not create a separate node for SSN, as it is the key for the person.   

%\begin{definition} A graph schema is a structure (V,E,$\eta$,$\lambda$,$\kappa$) where\begin{itemize}\item $V \subseteq O$ is a finite set of objects, called vertices;\item $E \subseteq O$ is a finite set of objects, called edges;\item $\eta: E \to  V  \times V$ is a function assigning to each edge an ordered pair of vertices;\item $\lambda: V \cup E \to L$ is a function assigning to each object a finite set of labels.\item $\kappa: V \cup E \to P$ is a function assigning to each object a finite set of properties.\end{itemize}\end{definition}



%The following rules can be considered when we map a category to a graph. Entity types become vertex types.  Binary relationship types become edge types. N-ary relationship types become vertex types




%\begin{algorithm} \caption{Map to a graph schema}\label{alg:map2graph}\input{algorithms/map2graph.tex}\end{algorithm}


%Figure \ref{fig:firstexample} illustrates an example of three types of data derived from category data. 









%Here, $N$ represents the total number of elements across all objects, $d$ is the maximum in-degree observed among the objects, and $M$ corresponds to the maximum number of functions between any two objects. Importantly, the time complexity is bounded by the product of these factors due to the fact that each object is processed a maximum of $d$ times.
 
 %To illustrate this concept, Figure \ref{fig:hybrid} demonstrates an example wherein customer data is divided into two distinct parts. The first part pertains to the information of customers, which is represented using relational data structures. The second part captures the friendship connections between customers and is best represented as a graph.

%\begin{algorithm} \caption{Map to a hybrid schema}\label{alg:map2hybrid}\input{algorithms/map2hybrid.tex}\end{algorithm}

%\begin{figure}
%\centering
%\includegraphics[width=0.7\textwidth]{figures/hybrid.jpg}
%\caption{An example to illustrate the output of two different models of data} \label{fig:hybrid}
%\end{figure}



