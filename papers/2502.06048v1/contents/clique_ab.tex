\label{chap:tour}
\zzcommand{\clique}{\textsc{Secluded Clique}}
\newcommand{\aboundedlong}{\textsc{Out-Secluded $\alpha$-Bounded Subgraph}}
\newcommand{\abounded}{\textsc{Out-Secluded $\alpha$-BS}}
\newcommand{\secuna}[1]{\textsc{Undirected Secluded {#1}-BS}}

In this section, we consider a generalization of the undirected \clique{} problem to directed graphs. We generalize this property in the following way.

\begin{definition}[$\alpha$-Bounded]
    A directed graph $G$ is called \emph{$\alpha$-bounded} if $G$ includes no independent set of size $\alpha + 1$, that is, for all $S \subseteq \ve{G}$ with $\abs{S} = \alpha + 1$, the graph $\induced{G}{S}$ includes at least one edge.
\end{definition}

Our problem of interest will be the \aboundedlong{} problem (\abounded{}).
Note that $\alpha$ is part of the problem and can therefore always be assumed to be constant.
In the directed case, $\alpha = 1$ is analogous to the \prname{Out}{Tournament} problem, with the only difference that tournaments cannot include more than one edge between a pair of vertices.

In \Cref{sec:alpha_bounded}, we show how to solve \abounded{} with a branching algorithm. The general nature of these branching rules allows us to transfer and optimize them, to significantly improve the best known runtime for the \clique{} problem to $1.6181^kn^{\bigO{1}}$ in \Cref{sec:clique}.

\subsection{Secluded \texorpdfstring{$\alpha$}{Î±}-Bounded Subgraphs}\label{sec:alpha_bounded}

First, we consider \abounded{}.
Our branching algorithm starts by selecting one part of the solution and then relies on the fact that the remaining solution has to be close around the selected part. More concretely, we start by picking an independent set that is part of the solution and build the remaining solution within its two-hop neighborhood. The following lemma justifies this strategy. 
% To be able to apply our previous technique, we use the following lemma to show that $\alpha$-bounded graphs also admit some kind of local structure.
The proof of this lemma was sketched on \emph{Mathematics Stack Exchange}~\cite{stackexchange}, we give an inspired proof again for completeness.

\iflong
\begin{lemma}
\else
\begin{lemma}[$\star$]
\fi
\label{lem:ind_set_reaches}
  In every directed graph $G$, there is an independent set $U \subseteq \ve{G}$, such that every vertex in $\ve{G}$ is reachable from an $u \in U$ via a path of length at most $2$.
\end{lemma}
\iflong
\begin{proof}
  We prove the statement by induction on $\abs{\ve{G}}$. For $\abs{\ve{G}}=1$, it clearly holds.

  Assume the statement holds for all graphs with fewer than $\abs{\ve{G}}$ vertices, we want to prove it for $G$.
  Let $v \in \ve{G}$ be a vertex. If $v$ reaches every other vertex via at most 2 edges, $\set{v}$ is our desired independent set. Otherwise, $T \coloneqq \ve{G} \setminus \coutNei{v}$ is non-empty. Since $\abs{T} < \abs{\ve{G}}$, we can apply the induction hypothesis. So, let $T' \subseteq T$ be an independent set in $\induced{G}{T}$ that reaches every vertex of $T$ via at most two edges. Now we consider the edges between $v$ and $T'$. 

  Since $T \cap \outNei{v} = \emptyset$, there cannot be an edge $(v,t')$ for any $t' \in T'$. If there is an edge $(t', v)$ for some $t' \in T'$, then $T'$ is also a solution for $G$ since $t'$ can reach $\coutNei{v}$ via at most 2 edges.
  Finally, if there is no edge between $v$ and $T'$, then $T' \cup \set{v}$ is an independent set. Also $T' \cup \set{v}$ reaches by definition all of $T \cup \coutNei{v}$ via at most 2 edges.
\end{proof}
\fi

For $\alpha$-bounded graphs, all independent set have size at most $\alpha$, so trying every subset of $\ve{G}$ of size at most $\alpha$ allows us to find a set that plays the role of $U$ in \Cref{lem:ind_set_reaches} in our solution. Hence, the first step of our algorithm will be iterate over all such sets. From then on, we only consider solutions $S \subseteq \coutNei{\coutNei{U}}$.

Then, our algorithm uses two branching rules. Both rules have in common that in contrast to many well-known branching algorithms~\cite[Chapter~3]{cygan2015parameterized}, we never include vertices into a partial solution. Instead, due to the nature of our parameter, we only decide that vertices should be part of the final neighborhood. This means that we remove the vertex from the graph and decrease the parameter by 1.
Our first branching rule branches on independent sets of size $\alpha + 1$ in $\coutNei{\coutNei{U}}$, to ensure that $\coutNei{\coutNei{U}}$ becomes $\alpha$-bounded. The second rule is then used to decrease the size of the neighborhood of $\coutNei{\coutNei{U}}$, until it becomes secluded.
% By differentiating some more base cases in these two high-level rules, we arrive at a branching vector of $(1,2)$ for the desired runtime.

% In the first reduction rule , we used the following observation. If we are in a branch in which we already decided that $u$ should be part of the final solution $S$ and there is $v \in \outNei{u}$, then either $v \in \nei{S}$ or $v \in S$. The same works if $v$ is farther away from $u$. For a $u$-$v$-path $P$, either some vertex on $P$ has to be in $\nei{S}$ or $v$ must be in $S$. If this path has constant size, we can branch on these options, which we use in the upcoming algorithm.
To formalize which vertices exactly to branch on, we use some new notation. For a vertex $v \in \ve{G}$ and a vertex set $U \subseteq \ve{G}$, pick an arbitrary shortest path from $U$ to $v$ if there exists one. Define $\shor{v}$ to be the vertices on that path including $v$ but excluding the first vertex $u \in U$. Note that after removing vertices from the graph, $\shor{v}$ might change.

Now, we can give our algorithm for finding secluded $\alpha$-bounded graphs. 

\restateab*
\iflong
\begin{proof}
    \begin{figure}[t]
      \centering \hfill
      \begin{subfigure}{0.48\textwidth} \centering
        \includegraphics[height=0.5\textwidth,page=8]{figures/clique_rules}
        \caption{Case 1. If $\alpha \le 2$, not all of $v_1$, $v_2$, and $v_3$ can be in $S$. One of the five vertices must be in $\nei{S}$.}
      \end{subfigure} \hfill
      \begin{subfigure}{0.48\textwidth} \centering
        \includegraphics[height=0.5\textwidth,page=9]{figures/clique_rules}
        \caption{Case 2. Since $v_3$ is not reachable from $U$ via 2 edges, one of $v_1$, $v_2$, and $v_3$ must be in $\nei{S}$.}
      \end{subfigure} \hfill
      \caption{A visualization of the branching rules for the \abounded{} algorithm in \Cref{thm:alpha_bounded_fpt}. We are only looking for solutions $S$ including $U$, where every $v \in S$ is reachable from some $u \in U$ via at most 2 edges. Dotted connections stand for edges that do not exist.}\label{fig:alpha}
    \end{figure}

    \newcommand{\curr}{\coutNei{\coutNei{U}}}
    \begin{algorithm}[t]
      \caption{The branching algorithm for \abounded{} that returns a solution including the set $U \subseteq \ve{G}$.}
      \label{alg:abounded}
      \DontPrintSemicolon
      \SetKwFunction{FMain}{$\alpha$-BS}
      \SetKwProg{Fn}{def}{:}{}
      \Fn{\FMain{$G$, $\omega$, $w$, $k$, $U$}}{
        \uIf{$k < 0$} {
          \textbf{abort}\; 
        }
        \uElseIf{$\curr$ is a solution} {
            \KwRet $\curr$\;
        }
        \uElseIf{there is an independent set $I \subseteq \curr$ of size $\abs{I} = \alpha + 1$} {
            \ForEach{$v \in \bigcup_{w \in I} \shor{w}$} {
                Call \FMain{$G-v$, $\omega$, $w$, $k-1$, $U$}\;
            }
        }
        \ElseIf{there is $w \in \outNei{\curr{}}$} {
            \ForEach{$v \in \shor{w}$} {
                Call \FMain{$G-v$, $\omega$, $w$, $k-1$, $U$}\;
            }
        }
      }
    \end{algorithm}
    
    Let $(G,\wOp, w, k)$ be an instance of \abounded{}. 
    We guess a vertex set $U \subseteq \ve{G}$ that should be part of a desired solution $S$. Furthermore, we want to find a solution $S$ to the instance such that $S \subseteq \coutNei{\coutNei{S}}$, that is, every $v \in S$ should be reachable from $U$ via at most two edges.
    We give a recursive branching algorithm that finds the optimal solution under these additional constraints.
    The algorithm is also described in \Cref{alg:abounded}.
    
    When deciding that a vertex should be part of the final neighborhood, we can simply delete it and decrease $k$ by one. In case $k$ decreases below 0, there is no solution. If $\curr$ is a solution to the instance, we return it. These are the base cases of our algorithm. Otherwise we apply the following branching rules and repeat the algorithm for all non-empty independent sets $U \subseteq \ve{G}$ of size at most $\alpha$.
    The branching rules are visualized in \Cref{fig:alpha}.
    
    \begin{description}
        \item[Case 1. $\curr$ is not $\alpha$-bounded.] In this case, there must be an independent set $I \subseteq \curr$ of size $\alpha + 1$. Clearly, not all of $I$ can be part of the solution, so there is a vertex $w \in I \setminus S$. This means that either $w$ or a vertex on every path from $U$ to $w$ must be in $\outNei{S}$.
        The set $\shor{w}$ is one such path of length at most 2. Thus, one of $\bigcup_{w \in I} \shor{w}$ must be part of the out-neighborhood of $S$ and we branch on all of these vertices. For one vertex, delete it and decrease $k$ by 1.
    
        \medskip
        \item[Case 2. $\curr$ is $\alpha$-bounded, but has additional neighbors.] Consider one of these neighbors $w \in \outNei{\curr}$.
        Since $w$ is not reachable from $U$ via at most two edges, we should not include it in the solution. Now, $\shor{w}$ is a path of length 3, and one of its vertices must be in $\outNei{S}$. We again branch on all options, delete the corresponding vertex and decrease $k$ by 1.
    \end{description}

    By \Cref{lem:ind_set_reaches}, there is a suitable choice of $U$ for every solution. Therefore, if we can find the maximum solution containing $U$ if one exists in every iteration with our branching algorithm, the total algorithm is correct.
    Also notice that the branching rules are a complete case distinction; if none of the rules apply, the algorithm reaches a base case.
    The remaining proof of correctness follows from a simple induction.

    We initially have to consider all subsets of $\ve{G}$ of size at most $\alpha$ while rejecting subsets that are not an independent set in time $n^{\alpha+1}$.
    To bound the runtime of the branching algorithm, notice that in each case we branch and make progress decreasing $k$ by 1.
    In the first cases, the independent set $I$ has size $\alpha + 1$ for every $w \in I$, the path $\shor{w}$ includes at most 2 vertices. Hence, there are at most $2(\alpha + 1)$ branches in this case. The second case gives exactly 3 branches and is thus dominated by the first rule.  This gives the claimed runtime and concludes the proof. 
\end{proof}
\fi

For the tournament setting, we can simply extend the first branching rule from the algorithm from \Cref{thm:alpha_bounded_fpt} to also branch on two vertices that are connected by a bidirectional edge.

\begin{theorem}
  \prname{Out}{Tournament} is solvable in time $4^kn^{\bigO{1}}$.
\end{theorem}

\begin{comment}
\iflong
In undirected graphs, the situation is simpler. Instead of \Cref{lem:ind_set_reaches}, clearly any maximum size independent set reaches every vertex via a single edge. Therefore, when adapting the algorithm from \Cref{thm:alpha_bounded_fpt}, the first rule has at most $\alpha + 1$ branches and the second rule now has at most $2$ branches. This gives us the following corollary, which also generalizes \Cref{thm:secluded_clique_fpt}.

\begin{corollary}\label{cor:undir_ab}
  \secuna{$\alpha$} is solvable in time $(\alpha+1)^kn^{\alpha+\bigO{1}}$.
\end{corollary}
\fi
\end{comment}

Moreover, note that if we instead define the directed problem to ask for the total neighborhood $\nei{S} \le k$, the problem is identical to solving the undirected version on the underlying undirected graph. 
In undirected graphs, instead of \Cref{lem:ind_set_reaches}, any maximal independent set reaches every vertex via a single edge. We can use this insight to adapt the previous algorithm to a faster one for the total neighborhood variant of the problem.

\restateabtotal*
\begin{proof}[Proof Sketch]
    Notice that in every directed graph $G$, any maximal independent set $U \subseteq \ve{G}$ fulfills $\cnei{U} = V$. Therefore, we can execute the same algorithm as described in \Cref{alg:abounded} and the proof of \Cref{thm:alpha_bounded_fpt} with $\cnei{U}$ instead of $\coutNei{\coutNei{U}}$. This leads to a smaller size set of vertices to branch on, namely $\alpha + 1$ instead of $2\alpha + 2$ for the first case and 2 instead of 3 for the second case. The remaining steps work out in the same way.
\end{proof}

\subsection{Faster \textsc{Secluded Clique} using Branching}\label{sec:clique}

The \clique{} problem has been shown to admit an FPT-algorithm running in time $2^{\bigO{k \log k}}n^{\bigO{1}}$ by contracting twins and then using color coding~\cite{golovach2020finding}. Furthermore, the single-exponential algorithm for \textsc{Secluded $\mathcal{F}$-Free Subgraph} from~\cite{jansen2023single} can also solve this problem in time $2^{\bigO{k}}n^{\bigO{1}}$ when choosing $\mathcal{F}$ to include only the independent set on two vertices. 
In this section, we give a faster and simpler algorithm using branching that achieves the same in time $1.6181^k n^{\bigO{1}}$.

% Intuitively, what makes this problem easily tractable is its local nature. When fixing a single vertex $v \in \ve{G}$ and looking for cliques including $v$, we know that any solution must be a subset of $\cnei{v}$. This fact allows us to construct local branching rules and will be crucial also for finding graphs with higher independence number.

The ideas behind our branching rules are the the same as in \Cref{thm:alpha_bounded_fpt}. However, this time, the forbidden structures are only independent sets of size 2. Therefore, it is enough guess a single vertex $u$ initially. This allows us also to analyze the rules more closely and split them into several cases.
By differentiating between more different scenarios in these two high-level rules, we arrive at a branching vector of $(1,2)$ for the desired runtime.

\restateclique*

\iflong
\begin{proof}
    \begin{algorithm}[t]
    % \begin{algorithmic}
      \caption{The $1.6181^kn^{\bigO{1}}$ branching algorithm for \clique{} that returns a $k$-secluded clique of weight at least $w$ including $u \in \ve{G}$.}
      \label{alg:clique_fast}
      \DontPrintSemicolon
      \SetKwFunction{FMain}{Clique}
      \SetKwProg{Fn}{def}{:}{}
      \Fn{\FMain{$G$, $\omega$, $w$, $k$, $u$}}{
        \uIf{$k < 0$} {
          \textbf{abort}\; 
        }
        \uElseIf{$\cnei{u}$ is a solution} {
            \KwRet $\cnei{u}$\;
        }
        \uElseIf{there are distinct $v_1, v_2, v_3 \in \nei{u}$ with $\{v_1, v_2\}, \{v_1, v_3\} \notin \e{G}$} {
            Call \FMain{$G-v_1$, $\omega$, $w$, $k-1$, $u$}\;
            Call \FMain{$G-\{v_2, v_3\}$, $\omega$, $w$, $k-2$, $u$}\;
        }
        \uElseIf{there are distinct $v_1, v_2 \in \nei{u}$ with $\{v_1, v_2\} \notin \e{G}$, $\nei{v_1}, \nei{v_2} \subseteq \cnei{u}$, and $\w{v_1} \le \w{v_2}$} {
            Call \FMain{$G-v_1$, $\omega$, $w$, $k-1$, $u$}\;
        }
        \uElseIf{there are distinct $v_1, v_2 \in \nei{u}$ with $\{v_1, v_2\} \notin \e{G}$ and $\nei{v_1} \not\subseteq \cnei{u}$} {
            Call \FMain{$G-v_1$, $\omega$, $w$, $k-1$, $u$}\;
            Call \FMain{$G - (\neiOp'(v_1) \cup \set{v_2})$, $\wOp$, $w$, $k- (\abs{\neiOp'(v_2)} + 1)$, $u$}\;
        }
        \uElseIf{there is $v_1 \in \nei{u}$ with $\neiOp'(v_1) = \set{v_2}$} {
            Call \FMain{$G - v_2$, $\wOp$, $w$, $k-1$, $u$}\;
        }
        \ElseIf{there is $v \in \nei{u}$ with $\abs{\neiOp'(v)} \ge 2$} {
            Call \FMain{$G-v$, $\wOp$, $w$, $k-1$, $u$}\;
            Call \FMain{$G - \neiOp'(v)$, $\wOp$, $w$, $k- \abs{\neiOp'(v)}$, $u$}\;
        }
      }
    % \end{algorithmic}
    \end{algorithm}

    \begin{figure}[t] \centering \hfill
      \begin{subfigure}{0.32\textwidth} \centering
        \includegraphics[width=0.6\textwidth,page=3]{figures/clique_rules}
        \caption{Case 1a. Either $v_2 \in \nei{S}$ or $v_1,v_3 \in \nei{S}$ must hold.}
      \end{subfigure} \hfill
      \begin{subfigure}{0.32\textwidth} \centering
        \includegraphics[width=0.6\textwidth,page=4]{figures/clique_rules}
        \caption{Case 1b. It only changes the weight if $v_1 \in \nei{S}$ or $v_2 \nei{S}$.}
      \end{subfigure} \hfill
      \begin{subfigure}{0.32\textwidth} \centering
        \includegraphics[width=0.6\textwidth,page=5]{figures/clique_rules}
        \caption{Case 1c. Either $v_1 \in \nei{S}$ or $\neiOp'(v_1) \cup \set{v_2} \subseteq \nei{S}$ must hold.}
      \end{subfigure} \hfill
      \begin{subfigure}{0.49\textwidth} \centering
        \includegraphics[width=0.38\textwidth,page=6]{figures/clique_rules}
        \caption{Case 2a. The only neighbor of $v_1$ outside $\cnei{u}$ is $v_2$. Therefore, $v_2 \in \nei{S}$ must hold.}
      \end{subfigure} \hfill
      \begin{subfigure}{0.49\textwidth} \centering
        \includegraphics[width=0.38\textwidth,page=7]{figures/clique_rules}
        \caption{Case 2b. Either $v_1 \in \nei{S}$ or $\neiOp'(v_1) \subseteq \nei{S}$ must hold.}
      \end{subfigure} \hfill
      \caption{A visualization of the branching rules for the improved \textsc{Secluded Clique} algorithm in \Cref{thm:clique_better}. We are only looking for solutions $S$ including $u$. Dotted connections stand for edges that do not exist. Also, vertices outside of $\cnei{u}$ are never connected to $u$. In (b) to (e), we can assume that $v_1$ is connected to all other vertices in $\cnei{u}$, and the same holds for $v_2$ in (b) and (c). Dotted edges to the outside of $\cnei{u}$ mean that no such edges exist.}\label{fig:clique2}
    \end{figure}
    
    Let $(G,\wOp, w, k)$ be an instance of \clique{}. 
    We guess a vertex $u\in \ve{G}$ that should be part of a desired solution $S$, that is we look for a solution $S \subseteq \cnei{u}$ with $u \in S$. We give a recursive branching algorithm that branches on which vertices should be part of the neighborhood. 
    The algorithm is also described in \Cref{alg:clique_fast}.
    
    When deciding that a vertex should be part of the final neighborhood, we can simply delete it and decrease $k$ by one. In case $k$ decreases below 0, there is no solution. If $\cnei{u}$ is a solution to the instance, we return it. These are the base cases of our algorithm. Otherwise we apply the following branching rules and repeat the algorithm for all choices of $u \in \ve{G}$.
    Denote for $v \in \ve{G}$ with $\neiOp'(v) \coloneqq \nei{v} \setminus \cnei{u}$ the additional neighborhood of $v$ that is not part of $\cnei{u}$. 
    The branching rules are visualized in \Cref{fig:clique2}.
    
\begin{description}
    \item[Case 1. $\cnei{u}$ does not form a clique.] In this case we must have a pair of vertices  $v_1, v_2 \in N(X)$ with $\set{v_1, v_2}\notin E(G)$. We now break into following three subcases.
    
    \begin{itemize}
        \item\label{it:clique1} \textbf{1a. There is a vertex $v_1 \in \nei{u}$ not connected to at least 2 others.} Formally speaking, there are distinct $v_2, v_3 \in \nei{u}$ with $\set{v_1, v_2}, \set{v_1, v_3} \notin \e{G}$. In this case, we know that if $v_1$ is in $S$, then both $v_2$ and $v_3$ cannot be in $S$.
        Therefore, we branch into removing both $v_2$ and $v_3$ or removing just $v_1$. We decrease $k$ by $1$ or $2$.

        \item \label{it:clique2}\textbf{1b. There are disconnected $v_1, v_2 \in \nei{u}$ that have no other neighbors.}
        Since the previous subcase does not apply and $\neiOp'(v_1) = \neiOp'(v_2) = \emptyset$, we know that $v_1$ and $v_2$ must be twins. Not both of them can be part of $S$, so we could remove either of them. Therefore, it is optimal to remove the vertex with smaller weight, decrease $k$, and recurse.
        
        \item \label{it:clique3}\textbf{1c. There are disconnected $v_1, v_2 \in \nei{u}$ with at least one other neighbor.}
        Suppose $\neiOp'(v_1) \ne \emptyset$. In this case, we know that if $v_1 \in S$, then both $v_2$ and all of $\neiOp'(v_1)$ have to go in $\nei{S}$.
        Thus, we branch into two cases where we either remove $v_1$ or $\neiOp'(v_1) \cup \set{v_2}$ and decrease $k$ accordingly.
    \end{itemize} \medskip 
    
    \item[Case 2. $\cnei{u}$ forms a clique.] In this case, we break into following two subcases.
    \begin{itemize}
        \item \label{it:clique4}\textbf{2a. There is $v_1 \in \nei{u}$ with only one other neighbor $\neiOp'(v_1) = \set{v_2}$.} In this case, it is always optimal to include $v_1$ in $S$. This adds at most one neighbor $v_2$ compared to not including $v_1$, which would add $v_1$ into $\nei{S}$. Since weights are non-negative, $v_2$ should go into $\nei{S}$. We remove it from $G$ and decrease $k$ by 1.
        
        \item \label{it:clique5}\textbf{2b. There is $v \in \nei{u}$ with at least two other neighbors in $\neiOp'(v)$.} Secondly, if there is $v$ remaining with at least two neighbors, we again consider all options.
        If $v \in S$, we know that all of $\neiOp'(v)$ have to be in $\nei{S}$. We branch into two cases in which we either remove $v$, or remove all of $\neiOp'(v)$ from $G$. In both cases, we decrease $k$ by the number of removed vertices.
    \end{itemize}
\end{description}

Notice that the case distinction is exhaustive, that is, if none of the cases apply $\cnei{u}$ is a clique without neighbors.
To give an upper bound on the runtime of the algorithm, notice that in each of the cases we either reduce the size of the parameter by at least one (Case 1b, Case 2a) or do branching. But in each of the branching steps (Case 1a, Case 1c, Case 2b) we make progress decreasing $k$ by 1 in the first branch, and at least 2 in the second branch. Hence they have the branching vector $(1,2)$, which is known~\cite[Chapter 3]{cygan2015parameterized} to result in a runtime of $1.6181^k$.  Therefore, the runtime of the recursive algorithm is upper-bounded by $1.6181^k n^{\mathcal{O}(1)}$, where the final runtime is achieved by multiplying by $n$ (the number of initial guesses of the vertex $u$). The proof of correctness follows from a simple induction. This concludes the algorithm. 
\end{proof}
\fi


\begin{comment}
\subsection{Restricted Secluded Subgraphs in \texorpdfstring{$\alpha$}{Î±}-Bounded Graphs}\label{sec:restricted}

In this subsection, considering  $\alpha$-bounded graphs as an input, we look  two problems (i) \textsc{Out-Secluded $\propOp$-Subgraph} (ii) \textsc{Total-Secluded $\propOp$-Subgraph}   where $\propOp$ be any graph property that is verifiable in time $n^{\bigO{1}}$. 

More interestingly, notice that the algorithm from \Cref{thm:alpha_bounded_fpt} is a branching algorithm that can be extended to an enumeration algorithm. If we change it to output all found solutions, we can enumerate all secluded $\alpha$-bounded graphs in the same time. Furthermore, if $G$ is already $\alpha$-bounded, we can use this insight to solve \textsc{Out-Secluded $\propOp$-Subgraph} efficiently, if $\propOp$ is verifiable efficiently.

\begin{theorem}
\label{thm:alpha_eff}
  Let $\propOp$ be any graph property that is verifiable in time $n^{\bigO{1}}$. Then, \textsc{Out-Secluded $\propOp$-Subgraph} in $\alpha$-bounded graphs is solvable in time $(2\alpha + 2)^k n^{\alpha + \bigO{1}}$.
\end{theorem}
\iflong
\begin{proof}
  The algorithm first runs the enumeration algorithm for \textsc{Out-Secluded $\alpha$-BS} from \Cref{thm:alpha_bounded_fpt} on $G$. For every enumerated vertex subset $S$, we verify whether it satisfies $\propOp$. If that is the case, we output $S$. Otherwise, there is no solution.

  Because $G$ is $\alpha$-bounded, so is every induced subgraph of $G$. Therefore, any solution to \textsc{Out-Secluded $\propOp$-Subgraph} must also be $\alpha$-bounded. Thus, it will be enumerated by the algorithm from \Cref{thm:alpha_bounded_fpt}. The runtime only increases by the additional polynomial overhead from verifying the property $\propOp$.
\end{proof}
\fi

Again, the same is possible for the total neighborhood setting. 
\begin{corollary}\label{thm:alpha_eff_tot}
  Let $\propOp$ be any graph property that is verifiable in time $n^{\bigO{1}}$. Then, \textsc{Total-Secluded $\propOp$-Subgraph} in $\alpha$-bounded graphs is solvable in time $(\alpha + 1)^k n^{\alpha + \bigO{1}}$.
\end{corollary}
\end{comment}
