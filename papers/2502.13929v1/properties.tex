\section{Expressing properties in Certora and Move Prover}
\label{sec:properties}

We report here the code of some of the classes of specifications discussed in ~\Cref{sec:comparison:prover}. Due to the appendix space constraint, we refer to our \href{\githubaddress}{dataset} for a more comprehensive set of examples. The list of properties for each property type can be found  in the associated \href{\sheeturl}{sheet}.

\subsection{Function specs}
 

The  \Cref{fig:specCVL} and \Cref{fig:specMSL} presented in \Cref{sec:background:provers} are examples of function specs.
%Other examples are \enriconote{lista di qualche nome di prop specificata come function spec}






\subsection{State invariants}
\label{sec:appendix:stateInv}

As an example of state invariant, consider the property of \contracturl{vault} that ``\emph{the owner and the recovery key are distinct}'' (\specurl{vault}{keys-distinct}).
Note that, as observed in the \emph{Access control and ownership} paragraph in \Cref{sec:comparison:language}, the \emph{owner} in Move is the address that owns the  resource, while in Solidity it is the a field of the contract. 
An alternative way to specify certain invariants in MSL is through \emph{struct invariant} (\eg \specurl{vault}{state-idle-req-inter}).


\begin{lstlisting}[language=cvl,caption={Specification of \specurl{vault}{keys-distinct} in CVL}]
invariant keys_distinct()
    currentContract.owner != currentContract.recovery;
\end{lstlisting}


\begin{lstlisting}[language=move,caption={Specification of \specurl{vault}{keys-distinct} in MSL}]
spec vault_addr::vault {
  spec module { 
      use aptos_framework::aptos_coin::{AptosCoin};
      invariant forall a : address where exists<Vault<AptosCoin>>(a):
      		global<Vault<AptosCoin>>(a).recovery != a;
  }
}
\end{lstlisting}

\begin{lstlisting}[language=move,caption={Specification of \specurl{vault}{state-idle-req-inter} in MSL}]
spec vault_addr::vault {
   spec Vault {     invariant (state == IDLE) || (state == REQ);  }
 }
\end{lstlisting}




\subsection{Single-transition invariants}
\label{sec:appendix:singleTransInv}

As an example of single transition invariant, consider the property of \contracturl{bank} that ``\emph{if the assets of a user A are decreased after a transaction (of the Bank contract), then that transaction must be a deposit where A is the sender}'' (\specurl{bank}{assets-dec-onlyif-deposit}).
As  observed in the \emph{Single-transition invariants} paragraph in \Cref{sec:comparison:prover}, in MSL the property can only be verified through the contrapositive 
(\ie, ``\emph{for every transaction that is not a \code{deposit()}, or for which A is
not the sender, then the assets of A are not decreased}''), 
using a set of function specs. 
Note that, in the case \contracturl{bank} had a higher number of functions, the size of the MSL specification would grow proportionally, while the CVL spec size would remain constant.


\begin{lstlisting}[language=cvl,caption={Specification of \specurl{bank}{assets-dec-onlyif-deposit} in CVL}]

rule assets_dec_onlyif_deposit {
    env e; 
    method f;
    calldataarg args;
    address a;
    require e.msg.sender != currentContract;
    require a != e.msg.sender;
    require a != currentContract; // check that sender is not the contract 
    
    mathint old_a_balance = nativeBalances[a];
    f(e, args);
    mathint new_a_balance = nativeBalances[a];

    assert new_a_balance < old_a_balance => (f.selector == sig:deposit().selector && e.msg.sender == a);
}
\end{lstlisting}


\begin{lstlisting}[language=move,caption={Specification of \specurl{bank}{assets-dec-onlyif-deposit} in MSL}]

spec bank_addr::bank {
    use std::features;    
    spec withdraw {
        let sender_coins_value = global<coin::CoinStore<AptosCoin>>(signer::address_of(sender)).coin.value;
        let post sender_coins_value_post = global<coin::CoinStore<AptosCoin>>(signer::address_of(sender)).coin.value;
        requires !features::spec_is_enabled(features::COIN_TO_FUNGIBLE_ASSET_MIGRATION);
        ensures sender_coins_value_post >= sender_coins_value;
    }

    spec deposit {
        let addr_sender = signer::address_of(sender);
        let bank_credits = global<Bank>(owner).credits;
        let post bank_credits_post = global<Bank>(owner).credits;
        ensures forall a: address where a!=addr_sender : global<coin::CoinStore<AptosCoin>>(a).coin.value >= old(global<coin::CoinStore<AptosCoin>>(a).coin.value);
    }
}
\end{lstlisting}





%\bartnote{forse non riusciamo a mettere un esempio di tutto: farei solo function spec e invariants}

%\enriconote{function spec nel Background, metterei State invariants e single transition, e per le altre link a qualche spec del dataset? (o versione estesa arxiv?)}

\subsection{Multiple-transition invariants}

An example of multiple-transition invariant is \specurl{vault}{finalize-or-cancel-twice-revert}, only expressible in CVL.\footnote{\url{\githubaddress/blob/main/contracts/vault/certora/finalize-or-cancel-twice-revert.spec}}

\subsection{Metamorphic properties}
An example of metamorphic property is \specurl{bank}{withdraw-additivity}, only expressible in CVL.\footnote{\url{\githubaddress/blob/main/contracts/bank/certora/withdraw-additivity.spec}}

\endinput



\begin{lstlisting}[language=cvl,caption={Specification of \specurl{bank}{deposit-assets-transfer} in CVL}]
rule deposit_assets_transfer {
  env e;
  require e.msg.sender != currentContract;
  mathint old_contract_balance = nativeBalances[currentContract];
  mathint old_sender_balance = nativeBalances[e.msg.sender];
  deposit(e);
  mathint new_contract_balance = nativeBalances[currentContract];
  assert new_contract_balance == old_contract_balance + e.msg.value;
  assert nativeBalances[e.msg.sender] == old_sender_balance - e.msg.value;
}
\end{lstlisting}

\begin{lstlisting}[language=move,caption={Specification of \specurl{bank}{deposit-assets-transfer} in MSL}]
spec bank_addr::bank {
  use std::features;

  spec deposit {
    let addr_sender = signer::address_of(sender);
    let sender_coins_value = global<coin::CoinStore<AptosCoin>>(addr_sender).coin.value;
    let post sender_coins_value_post = global<coin::CoinStore<AptosCoin>>(addr_sender).coin.value;
    let bank_credits = global<Bank>(owner).credits;
    let post bank_credits_post = global<Bank>(owner).credits;
    let bank_credits_sender_coin_value =
    if (simple_map::spec_contains_key(bank_credits, addr_sender))
      { simple_map::spec_get(bank_credits,signer::address_of(sender)).value }
    else
      { 0 };
    let post bank_credits_sender_coin_value_post =  simple_map::spec_get(bank_credits_post,signer::address_of(sender)).value;
    ensures bank_credits_sender_coin_value_post == bank_credits_sender_coin_value + amount;
    requires !features::spec_is_enabled(features::COIN_TO_FUNGIBLE_ASSET_MIGRATION);
    ensures sender_coins_value_post == (sender_coins_value - amount);
  }
}
\end{lstlisting}


\subsection{Multiple-transition invariants}

\subsection{Metamorphic properties}

\begin{figure}[t]
\small
\begin{lstlisting}[language=cvl,caption={Simplified CVL code for the Bank verification},label={fig:specSol}]
// a transaction deposit(amount) aborts if amount is greater than 
// the transaction sender's T balance.  
rule deposit_revert {
    env e;
    require( e.msg.value > nativeBalances[e.msg.sender] );
    deposit@withrevert(e);
    assert lastReverted;
}
\end{lstlisting}
\end{figure}

\begin{figure}[t]
%\small
\begin{lstlisting}[language=move,caption={Simplified MSL code for the Bank verification},label={fig:specMove}]
spec bank_addr::bank {
  spec deposit {
     // the abort condition is an "if", not an "if and only if"
   pragma aborts_if_is_partial = true;
   let sender_coins_val =global<CoinStore>(address_of(sender)).coin.value;
   let bank = global<Bank>(owner); //SERVE?? e' cosi' anche in github
   aborts_if ( sender_coins_val < amount );
   }
}
\end{lstlisting}
\end{figure}
