\section{Comparison}
\label{sec:comparison}

% \bartnote{differenza in usabilità? Certora cloud iper-lento, Move Prover core dump il 50\% delle volte e output quasi illeggibile wrt Certora. In Move Prover non sembra che sia possibile suddividere la specifica di un modulo tra diversi files, che è parecchio noioso quando uno vuole verificare individualmente delle proprietà}

%\enriconote{Strutturerei come "discussione per esempi": concetto generale -> discussione -> esempio
%Direi che è importante discutere un po' di esempi di proprietà. Scegliamo solo quelli in cui i tool divergono? Vogliamo inserire delle tabelle?
%}

Based on our dataset, we now present our comparative analysis.
%We now discuss the differences that we have observed while %performing the experiments as explained in Section \ref{sec:methodology:props}.building up our dataset.
%We keep our focus on the verification tasks over which we have observed a discrepancy between the verification in Solidity and in Move. 
Building upon the analysis of each property, we elaborate our findings to construct an organized knowledge that extends beyond our choice of use cases. 
In particular, we focus on properties where discrepancies arise between verification in Solidity and Move.
These properties serve as illustrative examples for a broader discussion of the fundamental differences in the verification of the two languages.
%
Our observations can be grouped as follows: 
properties whose ground truths disagree;  
properties that trivially hold in one language but not in the other; 
properties not expressible in one or both specification languages; 
properties expressible but not verifiable by one or both tools.
%
These four cases are not necessarily independent of one another, but they help to better identify the primary causes of discrepancy. %s we have observed.
In the first two groups, the discrepancy specifically depends on the contract languages, while, in the latter two, it depends more on the specification language and prover functionalities. %kept in consideration are the main causes.
We accordingly organise this part into two subsection: \Cref{sec:comparison:language} focuses on the impact of the contract languages, while \Cref{sec:comparison:prover} focuses on the impact of the specification languages and on the provers functionalities.


%I casi interessanti sono i seguenti:
%\begin{enumerate}
%    \item Ground truth diversa nei due linguaggi
%    \item Proprietà trivialmente vera in un linguaggio ma non nell'altro (o anche: proprietà A trivialmente implicata da proprietà B in un linguaggio ma non nell'altro)
%    \bartnote{vedere se troviamo altre istanze} 
%    \item Proprietà esprimibile ma non verificabile in 1 (o più) tool  \enriconote{ce ne sono? es. assets-dec-onlyif-deposit}
%    \enriconote{discorso su effort nel martellare il contratto per far sì che la ground truth valga (o che il prover riesca a verificare)}
%    \item Proprietà non esprimibile in 1 (o più) tool
%    \enriconote{Magari dividere in 2: a. quelle esprimibili in 1 tool ma non nell'altro; b. quelle non esprimibili in nessuna delle due (però magari in altri tool, liveness e liquidity) }
%    \item  \enriconote{altre?}
%\end{enumerate}
%I primi due casi sono language-dependent, il terzo prevalentemente tool dependent (però attenzione), il quarto prover-dependent.


\subsection{Impact of the contract language}

%\enriconote{Possiamo definire \emph{classi}?}

\label{sec:comparison:language}

%\enriconote{Qui differenze tra il valore di verità (e la verificabilità?) in Solidity vs. Move che dipendono unicamente dalle caratteristiche del linguaggio (mentre le funzionalità dei tool di verifica sono trascurabili).
%In questa parte dovrebbe andare tutto a favore di Move.}

\mypar{Resource preservation} 
As observed in~\Cref{sec:background}, 
Move enforces asset integrity by ensuring that assets cannot be duplicated
but only \emph{moved} between owners;
by contrast, Solidity --- except that for native tokens (ETH) --- requires the management of assets to be implemented at a contract level.
%
For example, in the \contracturl{bank} use case, 
the \code{credits} are rendered in Move as a map from \code{address} to \code{Coin} (that \emph{are} the actual assets), %(which are resources that are handled natively), %transfered from users to the contract and ).
while in Solidity they are
a map from \code{address} to \code{int}.
This means that the Solidity code merely \emph{tracks} the assets deposited by each user. However, implementation bugs can lead to a mismatch between the assets controlled by the contract and the overall amount of user credits, assigning more or fewer credits than they are entitled to. 
%\footnote{\silvianote{tutto questo già detto in sez.2, qui sarebbe bene illustrare per bene come si specifica la proprietà, riusando anche il fatto che in sez.2 c'è il sorgente}}
This significantly impacts the specification and verification of properties.
% bart: tolto % concerning credits. % in the two languages. 
First of all, in MSL, since credits \emph{are}  assets, such properties are implied by properties that concern assets. 
For example, in MSL the specification  of the property that, after a successful deposit of $n$ tokens, the credits of the sender are increased by $n$ (\specurl{bank}{deposit-assets-credit}), 
%precisely coincides with
is exactly 
a sub-specification of the property that, after a successful deposit of $n$ tokens, exactly $n$ tokens pass from the control of the sender to the control of the contract  (\specurl{bank}{deposit-assets-transfer}). %\silvianote{mi pare che il nome di questa sia dep-asset-TRANSFER} \enriconote{fixed}
In CVL, on the contrary, these two properties are disjoint, and it is possible --- in the presence of bugs related to the handling of credits --- for the former to hold, but for the latter to be violated.
This shows that, in order to cover the same set of properties,  a higher number of specifications has to be written  in Solidity than in Move.
Moreover, in Move, certain properties concerning credits trivially hold, while, in Solidity, they may be hardly verifiable, or even unexpressable.
For example,  the property that the sum of all the credits  does not exceed the amount of assets controlled by the contract (\specurl{bank}{credits-leq-balance})
trivially holds in Move, where \code{credits} coincide with the 
deposited 
%controlled 
assets, %, due to the resource-oriented nature of the language, 
but not in Solidity, where \code{credits} just {represent}  the deposited assets. %Moreover,
In general, verifying such kind of properties is quite challenging, as they require to reason about quantities depending on an unbounded number of users.
%\footnote{\enriconote{qui capire bene se va bene come è posta, non è necessario dire se Certora riesce o no (è teoricamente possibile, ma in ogni caso una sbatta, basta passi questo concetto)}}
%We can see the impact as well in the case of \specurl{bank}{deposit-assets-transfer} and \specurl{bank}{deposit-assets-credit}. In Move, the second one is a sub-property of the first one; in Solidity, they are two unrelated properties.
%\footnote{\silvianote{Per quanto ci siano i link, questi nomi da soli di proprietà sono molto vacui e tutto è poco concreto}}

 
% makes the movements of assets   movements  hence by design the movement of assets is more secure than in Solidity, where implementational bugs are a common .  

%In Solidity, the user credits are stored as a map from address to int, and the balance of the contract represents the assets owned by the contract. In Move, there is no balance of the contract, and user credits are stored as a map from address to coin, which directly controls the assets. \\ 
 %   In Solidity, implementation bugs may cause a mismatch between the assets controlled by the contract and the overall amount of user credits, assigning more or less credits than what is due to certain users.
 %   \enriconote{implica bank/credits-leq-balance}
  %  \enriconote{implica che (bank/deposit-assets-transfer implica bank/deposit-assets-credit)}


\mypar{Access control and ownership} 
%\enriconote{Cambiare titolo in \emph{Access control and ownership}? E quello prima in \emph{Resource preservation}?}
%\enriconote{era \emph{Contract ownership}}
%\enriconote{Non sono sicuro della differenza con Resource ownership. Il fatto che in un metodo si possa non specificare l'address che possiede il contratto, non è necessariamente diverso dal fatto che si possa non specificare l'address che possiede una qualsiasi risorsa.  così che solo l'owner la possa chiamare,  }
%In Move, every resource has an \emph{owner}. 
%
Most Smart contracts implement access control mechanisms to ensure that certain actions can only be performed by certain users under certain conditions.
%
A typical check is that some resources can only be updated by functions called by the contract owner.
%
Move inherently supports this kind of check: it suffices that all the functions that update the resource borrow it through a signer address. This is because, in Move, a resource can only be referenced through the address of its resource owner. %\silvianote{noterei che anche questo è stato messo in luce nel background}.
This is a security pattern in Move to reduce the risks of access control errors~\cite{aptos-security-guidelines}.
% In Move, in order to borrow a resource, it is necessary to refer to the address of the owner of the resource. 
%  This makes it possible to write functions so that certain resources are usable only by the signer of the transaction,
%
In Solidity, instead, resource ownership is not a native notion, so it must be encoded by the contract logic. In particular, in order to implement the check above, the contract must first record the owner address in a variable, and each sensitive function must require that the transaction sender and the owner coincide. 
Forgetting even a single check can lead to vulnerabilities, as in the Parity Wallet hack, where the absence of such check in a function enabled the attacker to become the owner and steal all the contract funds~\cite{parity-wallet-hack}. 
% \footnote{\silvianote{fino a qui sembr piu' "background" che analisi dei nostri esperimenti. NO: ora è molto MEGLIO} }
%
In our dataset this difference in behaviour can be observed, \eg, in  \contracturl{vault}, for the property that  a call to the function \code{finalize()} aborts if the sender is not the owner  (\specurl{vault}{finalize-revert}).
%is witnessed by the encoding of the property \specurl{vault}{finalize-revert},which requires that a call to the \code{finalize} function aborts if the sender is not the owner.\footnote{\silvianote{NON VA BENE: non si capisce che funzione è, deve essere piu' auto-contenuto}}
%
In CVL, we need to explicitly check that the address of the sender is equal to the \code{owner} field, while, in MSL, since the function directly accesses the \code{Vault} struct owned by the sender, and the \emph{owner} is not determined by the value of a variable %of the contract
but by the address that owns the resource,
then the check trivially holds, being enforced by the language. %\footnote{\silvianote{serve dire da cosa del nostro test si vede questo} \enriconote{il test in MSL non c'è proprio bisogno (né possibilità} di scriverlo}}
%
Another typical check is that some addresses used by the contract (\eg, its owner) do not change throughout the contract lifespan (\eg, \specurl{vault}{owner-immutable}).
In Solidity, it is possible to enforce that by declaring the addresses as \code{immutable}. 
In such a case, the property is directly enforced by the Solidity compiler, without having to resort to verification. 
%
Enforcing the same check in Move is less straightforward. A method is to record the concerned addresses as fields of some struct, and then verify with the MVP that these fields are invariant.
%\enriconote{citare owner-immutable}

%Però se caso più complicato e l'owner può cambiare, questo non più possibile, e verifica non più triviale.
%In Move, in ogni caso, è possibile anche avere una doppia protezione, includendo sempre l'owner come campo del contratto, e facendo sempre check che owner parametro è address del signer. 
%Questo può essere necessario per assicurarsi che non sia possibile fare moveTo fraudolenti (¡una risorsa non ha un identificativo!)
%Es. differenza è finalize-revert: ...

%We observed the impact of this feature in all of our three use cases. Let's consider, for example, the \usecase{Vault} use case.
%While in Solidity the owner of the vault has to be implemented as a field \texttt{owner} of the contract, in Move it is precisely identified with the address that owns the resource \texttt{Vault}. 


%This makes properties such as \spec{vault/owner-immutable}  trivially verified in Move, while in Solidity they must be explicitly verified, since bugs could allow an attacker to change the value of the field \texttt{owner} in the contract.
%\footnote{\enriconote{Solidity: In realtà usando immutable non c'è questo rischio...}}
%\footnote{\enriconote{Move: e se si facesse un moveTo? come andrebbe considerata? forse non sarebbe nemmeno verificabile... (a cosa si riferisce il concetto "owner"?)}   }

%Similarly, for properties such as \spec{vault/finalize-revert}, while in Solidity there is the need to verify that the address of the msg.sender coincides with the address stored in the field \texttt{owner}, in Move the method \texttt{finalize} is written in such a way that the signer of the call can only interact with the \texttt{Vault} that they own. For an attacker, it would be impossible to call \texttt{finalize} on the vault of another address, not because of additional \emph{requires}, but because of the implicit access-control mechanism of Move.
%\footnote{\enriconote{stressare che, per quanto simili le ultime 2 sezioni, il focus è diverso: nella prima è specificatamente sulla non-duplicabilità delle risorse, nella seconda è specificatamente sull'ownership}}

%\enriconote{Attenzione: questo non protegge dal fatto che un attaccante possa rubare la risorsa con un moveTo
%\\ in Move bisognerebbe verificare che non si può fare moveTo, questo in realtà è un problema (owner-immutable) ora è ND}

%\bartnote{prima descrizione generale, poi esempio}
%In Solidity the contract Vault has its own address that can be called by anyone; in Move certain methods (not cancel) can be called only by the owner. This is by-design 
%    \enriconote{Cambiare contratti}
%    \enriconote{Prop. 1: owner-immutable: questa è trivial in entrambi ma per motivi diversi (Solidity: immutable; Move: ownership)}
%    \enriconote{Prop. 2: only-owner-can-call: trivial solo in Move}

\mypar{Assets transfer} \label{sec:comparison:language:assetTransfer}
%
Solidity and Move render assets and their transfers differently, leading to different techniques for expressing and verifying properties related to them.
In Solidity, while there is a clear dichotomy in how the native asset (\ie, ETH) and user-defined assets (\eg, ERC20 tokens) are handled, in both cases transfers are rendered as contract calls.
The outcome of a contract call depends on whether the callee is an externally owned account (EOA) or a contract account.
When the callee is an EOA, the transfer is guaranteed to succeed, whereas for contract accounts the effect of the call depends on the implementation of the function handling the call.
For instance, assets may be returned to the caller if the call reverts, 
or they may be forwarded (either in full or in part) to other accounts if the function is designed to do so and has enough gas.
Therefore, properties about asset transfers should either discriminate between EOAs and contract accounts, %\footnote{\enriconote{specificare che discriminare così non si può fare a livello di linguaggio di specifica}}, 
or add assumptions about the implementation of the receiver function.
%
However, the first choice is not always viable, as detecting whether an address is an EOA or a contract account (either at contract or specification level) is possible only in limited cases~\cite{openzeppelin-eoa,BFMPS24fmbc}.
The second choice is problematic as well, since if the assumptions are false then the property may be violated at runtime.
%
Unlike Solidity, Move offers linguistic primitives for transferring ownership of resources, enabling a more disciplined modelling of asset transfers. 
This reduces the effort required to incorporate the necessary assumptions when encoding properties.
In our dataset, we have observed this, \eg, in \specurl{vault}{finalize-not-revert} (\ie, a \code{finalize()} transaction sent by the contract owner does not abort), which holds in Move but not in Solidity, since the transfer may fail when the receiver is a contract.
Furthermore, also \specurl{vault}{finalize-asset-transfer} (\ie, after a successful \code{finalize()}, a given amount of assets pass from the contract to the \code{receiver}), holds in Move but not in Solidity since, if the receiver is a contract, the assets can immediately be transferred to another address through the fallback function.   

%\bartnote{osservazioni (da riordinare)}
%\begin{itemize}
%\item in Solidity c'è differenza tra tx.origin (EOA) e msg.sender, mentre in Move sono la stessa cosa. Quindi, nelle proprietà che riguardano qualcosa che succede al chiamante di una funzione, in Solidity possono succedere cose diverse in base al fatto che questo sia un EOA o un contratto, in Move no. 
%\item 
%\item tx.origin check vale solo su msg.sender
%\end{itemize}

%\footnote{\silvianote{NON VA BENE: sembra che sia tutto background, bisogna illustrare esempi specifici di proprietà che hanno valori diversi in linguaggi diversi} \enriconote{sì c'è la mia nota inline per questo}}
% Balances of ETH are stored into accounts (both users' and contracts'), while those in user-defined assets are 
    
% some properties in Solidity do not hold if a withdrawing contract has a fallback that transfers funds to an other address (if enough gas is available); in any case, the fallback might simply fail, and prevent the address to receive. How to specify these properties?
    
% su reentrancy: some properties in Solidity do not hold due to re-entrancy.
% \enriconote{Quali?} \bartnote{in Bank nessuno. Devo controllare in Vault}
% \enriconote{in Bank usavamo low-level call, suscettibile re-entrancy}

%\enriconote{brasare questo sotto}
%\mypar{Global vs Local / Intra vs Inter-functions} 
%\label{sec:comparison:language:globalocal}
%In Solidity whenever a field of the contract is changed the global state is updated; in Move it is updated only after the function has finished (or if something is published?).
%For this reason in Solidity verification is needed also on a local level, while not in Move.
%Verification: Certora can verify properties intra-function (because they are global); Move Prover cannot (but it's not important ...?) %(\enriconote{maybe with struct invariant?})
%    \enriconote{vault/keys-invariant}


\mypar{Function dispatching}
%
Solidity features a form of dynamic dispatching, in that the compiler does not always know, for a contract-to-contract call, the code that will be executed in the callee. 
% \ie it allows to select at run-time which implementation of a polymorphic function to call. \bartnote{??}
This poses significant challenges to verification. 
Indeed, to avoid unsoundness, verification tools must assume that contract-to-contract calls can execute arbitrary code, which easily leads to false negatives.
In order to address the issue, Certora 
% provides a \emph{dispatcher} functionality, which 
allows users to specify a set of possible implementations of the callee, and verify the caller against each of them~\cite{certora-dispatcher}.
This technique can require considerable effort, and does not resolve the underlying unsoundness issue.
Move, on the other hand, features static dispatching, \ie the compiler (and, consequently, the verifier) know exactly the code that will be executed in the callee.
%  \ie the implementation of a polymorphic operation has to be selected at compile time. This avoids the issues caused by dynamic dispatching.
We have observed the impact of these different dispatching designs, \eg, in the property \specurl{price-bet}{win-revert} (\ie, a \code{win} transaction aborts if the  oracle exchange rate is less than a given value).
% requires to call an external contract (the Oracle) in order to know whether the player has won the bet or not. 
In Certora, verifying the property requires the user to explicitly instruct the verifier to resolve the call with a given oracle implementation: leaving that unspecified would make verification fail.
In practice, many Solidity contracts are written in a way that makes it impossible to predict the actual implementations of the callees (\eg, Solidity contracts using ERC20-compatible tokens usually define only their interface).


\mypar{Other features}
%
\emph{Immutability.} In Solidity, the \code{immutable} keyword allows to enforce that certain variables cannot change value throughout the whole lifespan of the contract, making certain properties (\eg, the above-mentioned \specurl{vault}{owner-immutable}) enforced by the Solidity compiler. In Aptos Move, since an equivalent modifier does not seem to be available, such properties have to be explicitly verified with a prover.\footnote{Note that, in SUI Move, %but not in Aptos Move,
it is possible to define \emph{frozen objects} (\ie objects that cannot be modified nor moved). It does not seem possible to define \emph{frozen fields} of an object, though.}
%\enriconote{su SUI sembra possibile:  \url{https://move-book.com/object/ownership.html}, però solo per le risorse (non per i campi)?}
%\url{https://medium.com/building-on-sui/code-in-move-4-sui-move-basics-76c21cc0df1c} 
%\emph{``There is also a special type of shared object which is immutable (or frozen) objects.''} 
%\footnote{\enriconote{ma c'è un motivo intrinseco per cui in Move non c'è immutable?}}
%\enriconote{Immutability: In tabella per oplimit-immutable abbiamo in Solidity \emph{trivial (enforced by compiler)}. Per Move non esistono tipi immutable?}

\emph{Self-destruct.} 
%\emph{Frozen assets.}
In Solidity, contracts can receive native tokens at any time through the \emph{self-destruct} method. This requires additional precautions during implementation to prevent funds from getting locked in the contract.
For example, our Solidity implementation of the \contracturl{bank} use case allows users to withdraw only the funds corresponding to their credits (\ie, funds that have been previously deposited). In contrast, funds received via self-destruct cannot be withdrawn from the contract and remain locked.
This is not the case in Move, as no equivalent of the self-destruct method exists.
For example, the property that, if the contract controls some assets, then it is always possible to transfer them  to some user (\specurl{bank}{no-frozen-assets}), holds in Move, but not in Solidity, since the contract only allows creditor to withdraw the assets they have deposited, but  does not  provide any function to transfer funds received via self-destruct, resulting in funds getting stuck in the contract.

\mypar{Necessary technical assumptions} As discussed in~\Cref{sec:methodology},  the translation of properties written in natural language to formal specification often requires the addition of low-level technical assumptions. Here, we report the cases that we have observed in our experiments.


%\emph{Overflow.} In Solidity, overflow issues can often be the cause of bugs{\enriconote{ref}}. 
%In Move, on the contrary, any arithmetic operation that would result in an overflow triggers an abort~\cite{aptos-security-guidelines}, preventing then such kind of vulnerabilities.  
%We have observed 
%\url{https://aptos.dev/en/build/smart-contracts/book/integers#arithmetic}
%\url{https://github.com/Zellic/move-prover-examples}.
%\enriconote{\specurl{bank}{deposit-not-revert} non ha bisogno di assunzione su overflow?} 
%\bartnote{TODO controllare spec }


\emph{Accepting incoming transfers.} As observed in the  ``\emph{Assets transfer}'' paragraph, properties concerning the transfer of assets may need further assumptions on the receiver part. In Move, the only technical assumption we needed to add in our dataset is that the \code{CoinStore} of the address receiving the assets is not \code{frozen}.
In Solidity, one sufficient condition that can be used when the receiver equals to the transaction sender is that the sender is an EOA.
Although this could be encoded in CVL by requiring that 
\code{e.msg.sender==e.tx.origin}, the Certora prover does not use this additional assumption, leading to a false negative
(\eg, in \specurl{bank}{withdraw-assets-transfer}).
Other conditions, such as ensuring that the receiver does not fail or does not perform further calls, do not appear to be expressible in CVL.
% however, more complex assumptions, not always easily writeable in the specification language, are needed. 
%servono assunzioni più forti non scrivibili semplicemente a livello di specifica  

\emph{Coin-to-FungibleAsset.} Recently, Aptos has introduced a ``\emph{Fungible Asset}'' (FA) standard~\cite{aptos-fungible-asset} that extends the \emph{Coin} standard, and it has enabled automatic migration from Coin to FA by default. This automatic migration can make certain properties  concerning the transfer of Coins (\eg \specurl{bank}{deposit-revert}) violated, since Coins are not preserved (but migrated to FA). In order to verify such properties, it is necessary to disable the automatic migration.      
%\url{https://medium.com/aptoslabs/live-on-aptos-mainnet-coin-to-fungible-asset-migration-58eacaeaf7f7} 

\emph{Sender is not the contract.} In Solidity, it is possible that a contract calls itself. 
In certain cases, it may be necessary to assume that this is not the case, as, otherwise, certain properties might either not hold, or be unverifiable in practice. For example, \specurl{bank}{deposit-assets-transfer} specifies that, after a successfull deposit of $n$ tokens, the balance of the sender is decreased by $n$. 
While this property is true without further assumptions (since the specific \code{Bank} contract cannot call itself), in Certora the verification will fail without adding the assumption that the sender is not the contract.
%\silvianote{meglio frase più esplicita: in Certora the assumption that the caller is not the current contract is needed since.. }, 
This is because verification tools usually over-approximate the set of possible executions, thus considering also the impossible case in which the contract calls itself.
%failing to prove that the property holds without the assumption.
%Un contratto può chiamare sè stesso (a priori) quindi può essere necessario fare l'assunzione che questo non sia il caso (a volte necessario solo a livello di verifica, se il contratto non chiama sè stesso) 

 
\subsection{Impact of the specification language and prover functionalities}
\label{sec:comparison:prover}

%\enriconote{era \emph{Impact of the specification language}}

%\enriconote{Qui differenze che dipendono dalle funzionalità dei prover.}
%\small{\enriconote{(nella tabella è possibile far risaltare la questione quantificatori?)} \enriconote{direi che anche se fosse possibile non sarebbe desiderabile}}

%\enriconote{La tabella in sè può andare al di là del confronto Certora vs. Move Prover (e del confronto Solidity vs. Move): può essere vista più in generale come guida del tipo di proprietà che è desirabile poter verificare}

We now consider different classes of properties and discuss how (and whether) they can be expressed in the two specification languages. 
The organization in classes has not to be intended as a formal taxonomy,
%since in some cases %, depending on the specification language, 
%two classes may overlap.
rather as a schematic way to present our findings.

%\enriconote{organizzazione paragrafi}

%Here, we discuss how different specification languages %, as well as different prover-specific functionalities,
%impact the verificability of certain specifications. 

%Specificare che le classi di proprietà non sono disgiunte (es. function specs e single-transition invariants)

%\ 
%\enriconote{usare un paragrafo per ogni Tipo primario (gli altri dentro)}
%\ 
%\enriconote{Tabella: hook, ghost variables \\ State invariant Global non chiaro}
%\enriconote{mettere proprio template di regole? nel caso eventualmente spostare in tabella se prende troppo spazio}

%\mypar{Tutto bene}
%Paragrafo su tipi di proprietà per cui entrambi i prover si comportano fondamentalmente allo stesso modo e non danno problemi.



\mypar{Function specs} We denote by ``{function spec}'' properties that specifically target  a given function.
We divide these properties into ``{success conditions}'', which characterize the conditions under which a function aborts or not, and ``{post-conditions}'', which express properties regarding the state after the call, assuming that the call has not aborted. 
The Move Prover has an ad-hoc specification format for function specs. 
%For success conditions, it uses the keywords \code{abort-if}% 
%+\footnote{\enriconote{citare che affinché non sia iff bisogna aggiungere un parametro?}} and \code{requires}; for post-conditions, it uses the keyword \code{ensure} \footnote{\enriconote{non si può usare requires con ensure?}}. 
In Certora, function specs can be expressed as rules that explicitly mention the function being called, %, using a single call to the target method, 
and using \code{requires} statements for pre-conditions, the expression \code{lastReverted} for checking abort conditions, and the statement \code{assert} for post-conditions. 
\Cref{fig:specCVL} and \Cref{fig:specMSL} presented in \Cref{sec:background:provers} are examples of function specs in CVL and MSL, respectively.
Both tools perform well over properties of this kind in our dataset. 
%Both tools can express properties of this kind satisfactorily.
%We have not observed a significant differences in the usability and effectiveness of the two tools for properties of this kind.

 
\mypar{State invariants} We denote by ``state invariants'' properties of the form ``\emph{for every reachable state \state, it holds that $\Prop(\state)$}'', where {$\Prop(\state)$} is a property that only mentions variables in the state \state. 
In Move,  state invariants can be proved in two ways: either using a \emph{struct invariant} spec, in case an invariant only deals with a single structure (\eg, in any state, the vault state is IDLE or REQ, \ie \specurl{vault}{state-idle-req-inter}), or, otherwise, using a \emph{global invariant} spec (\eg, the owner and the recovery keys are distinct, \ie \specurl{vault}{keys-distinct}).
%\footnote{\enriconote{sull'articolo su Diem non si capisce se ci sia un qualche comportamento diverso [cont...] 
% v. \emph{Relationship with DI.}, però dagli esperimenti che abbiamo fatto non sembra valere su Aptos
%}}
In Certora, %all invariants can only be written as global invariants.
there is a common way to write invariants. See  \Cref{sec:appendix:stateInv} for some examples.
Both tools perform well over properties of this kind on our dataset.


\mypar{Single-transition invariants} 
We denote by ``single-transition invariants'' properties of the form ``\emph{for every reachable state \state, and for every transaction \method, either $\method$ aborts, or it holds that $\Prop(\state, \nexts(\state, \method), \method)$}'',
%\footnote{\enriconote{con \emph{method} io intendo \emph{method call} (quindi includendo i parametri), ma forse non è chiaro}}
 where $\nexts(\state, \method)$ is the state after a successful execution of \method in \state.  
 Note that function specs are a special case where the called function is fixed.
 %this class is a superset of the Function specs one. \enriconote{check}\silvianote{dipende da cosa è di preciso lo stato, comunque toglierei la frase che mette più dubbi che altro.}
Certora is quite flexible for the verification of such properties, and allows to express arbitrary (quantifier-free) conditions on the parameters of \method.
In the Move Prover, there are two different ways to express single-transition invariants, both of which are less general than Certora rules.
The first way is to use \emph{global invariant updates}. 
This construct, however, does not %seem to 
allow to make explicit mention of the parameters of the transaction \method,   restricting expressible properties to those of the form $\Prop(\state, \nexts(\state, \method))$, where \method remains implicitly universally quantified. 
The second way is to use a \emph{schema} of function specs (that is, syntactic sugar to group together a set of function specs with a common body). 
Writing a single-transition invariant this way, however, requires to write an instance of the schema for each method.
%(or, at least, for each method allowed by $\Prop(\state, \nexts(\state), \method)$)\silvianote{cos'è un metodo allwoed by a property? mi sembra piu' chiaro senza questa parentesi}. 
This makes the specification code significantly more verbose than in CVL.
%\footnote{\enriconote{Riusciamo a trovare una proprietà esprimibile in CVL ma non in MSL?
%oltre la verbosità: siamo sicuri che non si possano scrivere tutte queste proprietà in questo modo? Es. tramite condizioni prima di include
%}}
As an example, in CVL it is possible to succinctly express that some properties relating pre and post states hold only if a given function is called,
\eg, in \contract{Bank}, 
that if the assets of a user \user{A} are decreased after a transaction, then that transaction must be a \code{deposit()} where \user{A} is the sender (\specurl{bank}{assets-dec-onlyif-deposit}).
In MSL, it seems to   only be  possible to specify the contrapositive, i.e. that, for every transaction that is not a \code{deposit()}, or for which \user{A} is not the sender, then the assets of \user{A} are not decreased.
This, however, requires to write a function spec for each function that is not the \code{deposit()}, and one further function spec for the \code{deposit()}, restricted to the case of \user{A} not being the sender. See also \Cref{sec:appendix:singleTransInv}.
%\footnote{\silvianote{non si capisce davvero che significa, sembra tutto un po' troppo astratto}}
%\footnote{\enriconote{Stress che (?):
% Quelle che ci sono in Move Prover ma servono abbastanza a poco, perché non parlano del metodo chiamato, ed è poco comune che un contratto ammetta invarianti che devono valere per ogni metodo chiamato (alternativamente, ci si deve ridurre a usare gli schemi, ma è meno immediato). Nel benchmark ci sono pochissimi esempi (sarebbe necessario avere le trace spec, i.e. transition invariants multipli).
%Idem per i signer: spesso una proprietà vuoi che valga solo per uno/alcuni signer (non tutti)
%}}

%\mypar{Transition variables references}
%\enriconote{¡Merge con par sopra!}

%\enriconote{sembra che non ci sia modo di riferirsi alle variabili di transizione (nome del metodo e chiamante) per gli invarianti globali (ma solo all'interno di unit specs)}
%In Certora, it is possible to verify that certain properties concerning pre and post states can be satisfied only if a given method is called. In Move Prover, it seems that this is possible only via contrapositives, i.e. showing that, for all other methods, the property is not satisfiable (but schemas can be used).
%\enriconote{integrare bene con quello sopra}

\mypar{Multiple transition invariants} 
%\bartnote{Trace properties?}: With the Move Prover, it seems that it is not possible to verify properties concerning two or more calls, for example "\emph{a call to method A after a call to method B always abort}"
We denote by ``multiple-transition invariants'' properties of the form 
%"\emph{it always holds that, after succesful calls to methods $\method_1, \dots \method_n$, $P(\state, \nexts(\state), \dots , \nexts^n(\state), \method_1, \dots \method_n)$}"
``\emph{for every reachable state \state, and for every sequence of transactions $\vec{T} = \method_1 \ldots \method_n$, either one transaction aborts, or 
%$\Prop(\state, \nexts^n(\state), \method_1, \dots \method_n)$}'', where $\nexts^n(\state)$
$\Prop(\state, \nexts(\state,\vec{T}[1:1]), \dots , \nexts(\state,\vec{T}[1:n]), \method_1 \ldots \method_n)$} holds'', 
where $\nexts(\state,\vec{T}[1:i])$ 
%for $1 \leq  i \leq n$, 
denotes the  state after the successfull execution of $\method_1, \dots, \method_i$.
%\bartnote{notazione}\silvianote{l'ho semplificata (ma commentata)} \enriconote{serve parlare anche degli stati intermedi}
In CVL, it is possible to express such specifications analogously to single-transition invariants, by subsequent function calls in the same rule. 
In MSL, this kind of specifications does not seem to be expressible. 
%, nor
% in any of the two ways previously discussed. 
%Indeed, it does not seem to be possible to use two \code{update} keywords subsequently, nor to call two function specs one after the other. % (either using or not Schemas).
An example of property that is possible to verify with Certora but not with the Move Prover is that, in \contracturl{vault}, 
%a \code{finalize()} transaction called immediately after a successful  \code{withdraw()} does not abort if sent after \code{wait\_time} units have elapsed
a \code{finalize()} or a \code{cancel()} transaction aborts if performed immediately after another \code{finalize()} or \code{cancel()} transaction
(\specurl{vault}{finalize-or-cancel-twice-revert}).

%\enriconote{vault/withdraw-withdraw-revert}

\mypar{Metamorphic properties} 
%\bartnote{metamorphic properties?} 
Following \cite{Chen18csur}, we denote as ``{metamorphic}'' properties over multiple (finite) traces.
\bartnote{statement su rilevanza}
A typical class of metamorphic property are \emph{additivity properties}: for example, in the \contracturl{bank} contract, is it true that the state reached after depositing $n+m$ tokens is equal to the state reached after first depositing $n$ tokens and then immediately depositing other $m$ tokens (\specurl{bank}{deposit-additivity})?  
In CVL, it is possible to express some metamorphic properties  through the use of \code{storage} types, 
which allow to record the contract storage at different points of execution, and later compare them. %\footnote{\enriconote{and the balances of the users?}}
% inside rules, so that it is possible to specify from which state a transaction is called.
This feature is not present in MSL, so metamorphic properties do not seem expressible.
%(e.g. \emph{additivity}): It seems that it is not possible to verify such properties with the Move Prover, as there is no \emph{storage type} (as in Certora).
    
%\enriconote{Mettere paragrafo "Other properties" dove ci vanno tutte quelle non trattabili dai tool}

%\mypar{Other properties}
\mypar{Other properties}
Some classes of properties do not seem expressible in any of the two tools. 
Without claiming exhaustivity, we now briefly discuss some of the classes we have encountered, with particular attention to those that seem addressable by other tools.

%\enriconote{Specificare da qualche parte che anche se 1 proprietà (più astratta) si può verificare come proprietà (più concreta) che la dimostra, ai fini di verifica questo non è indifferente: per farlo serve una conoscenza più o meno approfondita di come funziona il contratto. È più potente invece poter verificare la proprietà "as is" }

 \emph{Liveness.} Liveness properties have the form %``\emph{eventually a state \state s.t. $\Prop(\state)$ is reached}''.
 ``\emph{eventually a state that satisfies certain conditions is reached}''.
In \contracturl{price-bet}, a desirable liveness property is that no assets remain locked in the contract, \ie, eventually the balance is zero (\specurl{price-bet}{eventually-balance-zero}). 
%This property cannot be verified by Certora nor by the Move Prover. 
Note that this property is closely related to, but more abstract than, the property that a call to \code{timeout()} --- which transfers the assets controlled by the contract to the owner ---
does not revert if fired after the deadline has passed (\specurl{price-bet}{timeout-not-revert}). 
Tools able to handle such kind of properties, usually under the assumption of fairness conditions (in the example, that the \code{timeout()} function is called at least one after the deadline), are VeriSolid~\cite{VeriSolid} and VeriMove~\cite{VeriMove}, and SmartPulse~\cite{Stephens21sp}.

\emph{Liquidity/Enabledness.} Liquidity~\cite{Solvent} or Enabledness~\cite{Schiffl24fmbc}  properties are of the form %``\emph{in any reachable state \state, there exists a sequence of at most $n$ transactions $\method_1, \dots, \method_n$ such that $P(\state, \nexts(\state), \dots , \nexts^n(\state), \method_1, \dots \method_n)$}''. 
``\emph{in every reachable state, certain users are always able to 
fire a (fixed) number of transactions
to reach a desirable state}''. 
In \contracturl{bank}, an example of such properties is that, if a user has strictly positive credits, she is  always able to fire a single transaction %(or sequence of transactions) 
to transfer the corresponding funds  from the contract (\specurl{bank}{no-frozen-credits}). Note that this kind of property never mentions the function that should be called nor its parameters, as they  are existentially quantified and determining them is a task of the tool. A tool that addresses such kind of properties is Solvent~\cite{Solvent}.

%{Liquidity/Enabledness}
%    ci riesce \cite{Solvent}

\emph{CTL fragment}: The specification language of VeriSolid (and, consequently, of VeriMove) covers an expressive fragment of Computational Tree Logic (CTL). Such expressivity comes at the expenses of soundness, as the verification process relies on a certain level of abstraction.
Examples of CTL specifications include the Liveness seen before, as well as properties of the form ``\emph{$\Prop_1$ cannot happen  after $\Prop_2$}'', or ``\emph{If $\Prop_1$ happens, then $\Prop_2$ can only happen after $\Prop_3$ happens}''. 
These properties cannot be expressed in CVL, since it is not possible to talk about unbounded sequences of method calls, but only about sequences of states of finite length.
In our dataset, an example of property not expressible in CVL but in the CTL fragment supported by VeriSolid is \specurl{vault}{finalize-after-withdraw-not-revert}, which states that \emph{``after a successful \code{withdraw()}, if no \code{cancel()} or \code{finalize()} have been called successfully, then \code{finalize()} does not abort}''.


Note that all these properties have a higher level of abstraction  than those discussed in the previous paragraphs.
Although some of these properties, in certain cases,
%especially for small contracts,
can be reformulated in terms of more concrete properties that imply them,   
doing so requires a more advanced knowledge of the low-level aspects contract, and reduces their generality.
It has been observed that properties that abstract the system %, although in general harder to verify in practice, 
%are  more desirable and 
have a better return-on-investment than low-level properties~\cite{Xu24langsec}. %\enriconote{citare anche in Conclusions}
%For this reasons, being able to verify 

\mypar{Orthogonal features of properties} We now address specific features of properties that can appear in all previous classes, hence for which a separate discussion is needed.
%\mypar{Other functionality  % technical?
%aspects }

\emph{Inter vs. Intra function invariants}  
Invariants can be of two kinds: those that must be preserved across function calls (\emph{inter-function} invariants) and those that must be preserved within the execution of a function (\emph{intra-function} invariants).
%\silvianote{questa terminologia fa un po' confusione con gli state/global invariant discussi prima. Forse si potrebbe parlare di intra-function e inter-function invariants? Mah!} 
%\enriconote{abbiamo tolto le occorrenze di global sopra}
In the latter, the notion of \emph{reachable state} is extended to include also intermediate states. % that are only reachable during the execution of a function. 
In some cases, it may be desirable to verify that certain properties hold not just inter-function but also intra-function. 
For example, consider in \contracturl{vault} the requirement that ``\emph{the \code{receiver} key cannot be changed after initialization}''.
Requiring this invariant to only hold inter-function (\specurl{vault}{keys-invariant-inter}) is not enough, as the \code{receiver} key may be changed inside the \code{finalize()} function before the transfer call in order to send the assets to an attacker address, and then restored to the original value before the end of the function. 
It is necessary to require the invariant to hold also intra-function (\specurl{vault}{keys-invariant-intra}).
In Certora, verification of intra-function invariants  is possible through ghost variables and hooks~\cite{certora-hooks}.
In Move, on the contrary, verification of intra-function invariants is, in general, not possible. The MVP can check that an invariant holds \emph{globally}, \ie every time the global state is updated~\cite{aptos-msl}, but this cannot capture every change that occurs during the execution of a function (in the example mentioned above, the MVP is not able to detect that that the \code{receiver} key is changed within the execution of the \code{finalize()}).

%\footnote{\enriconote{Specificare che abbiamo fatto la prova spiegata sopra e MVP non cia fa?}}. 


 \emph{Nested quantifiers.} Several interesting properties require the nesting of quantifiers. 
 In Certora, quantifier nesting is limited to \emph{exists-forall} fragments, whereas \emph{forall-exists} fragments are disallowed. 
 %https://docs.certora.com/en/latest/docs/prover/approx/grounding.html#alternating-quantifiers
 This makes properties such as \specurl{bank}{exists-at-least-one-credit-change}  not expressible in CVL. 
  On the contrary, MSL allows arbitrary combinations of quantifiers. 
 In practice, however, the verification of such properties can be quite troubleful, as the underlying SMT solvers often struggle with quantifiers. 
 In our experiments with the MVP, we managed to successfully verify the property \specurl{bank}{exists-at-least-one-credit-change}, 
 but got an inconsistent result in the case of \specurl{bank}{exists-unique-asset-change}. 
This inconsistency may be caused by 
%the version of Z3 used. \enriconote{ultima frase si può scrivere meglio}
the version of the underlying SMT solver used.
 
% \bartnote{TODO: check in Bank deposit credit-exists (\ie dopo deposit esiste almeno un address con credit $>0$) }
%Proprietà interessanti necessitano nesting quantificatori .
%MVP offre più supporto di Certora a riguardo. 
%Nei nostri esperimenti siamo riusciti a verificare anche proprietà interessanti,
%ma abbiamo anche osservato incoerenza tra ground truth e risultato del tool. 
% \ \ Qui stiamo attenti che in Certora son state discontinuate, mentre nel Move Prover sembra quasi non funzionino a volte 
%    (potrebbe dipendere dalla versione di Z3, ma non abbiamo modo di saperlo) \ 
%    (exists-unique-asset-change non funziona; exists-unique-credit-change sì)    

\emph{Gas.} %\enriconote{servirebbe altro use case (magari coi loop); per il momento solo discorso vago con l'unico esempio che vediamo}
As discussed in ``\emph{Assets transfer}'' in~\Cref{sec:comparison:language:assetTransfer},
the truth of certain properties may depend on the amount of gas available to the involved functions. 
For instance, in Solidity the ground truths of
%the property that, after a successful \code{withdraw()}, exactly amount units of T pass from the control of the contract to that of the sender.
\specurl{bank}{withdraw-assets-transfer} and
\specurl{vault}{finalize-assets-transfer} differ because 
of the functions used in the respective contracts to transfer ETH
from the contract to another address:
in the implementation of \contracturl{bank}, we are using \code{transfer}, 
which do not carry enough gas to perform further calls,
while in \contracturl{vault} we are using \code{call}, which
instead transfers all the gas to the callee.
% \enriconote{testo --- c'è già citata in Necessary technical assumptions}
% bart: ci stavo guardando anche io; menzionerei anche la vault/finalize-assets-transfer, dove invece la proprietà non vale perché nel contratto si usa la low-level call anziché la tranfer (quindi, in teoria ci potrebbe essere abbastanza gas da permettere ulteriori call)
% holds in Solidity because the \code{transfer} function, used to send ETH to the sender, only carries a limited amount gas, preventing the receiver from executing further calls).\silvianote{non capisco quando nel definire la ground truth assumiamo che le chiamate di funzione non abbiano gas per ulteriori chiamate. Qui lo facciamo, ma nel parag Asset Transfer si dice che vault/finalize-asset-transfer non vale perche' la fallback potrebbe spostare i soldi, ma anche li' potrei limitare il gas impedendo ulteriori spostamenti. Sabglio? }
Certora however over-approximates the amount of gas available, so it gives a false negative for \specurl{bank}{withdraw-assets-transfer}.

  %In certain cases, it may be necessary to reason about gas consumption. For example, \specurl{bank}{withdraw-assets-transfer}
  %\enriconote{In Move può mai servire parlare di gas?}
%Gas: Certora ha modo di parlare del gas, ma sovra-approssima troppo (non riesce neanche a verificare la monotonia). In particolare alcune proprietà (es. \specurl{bank}{withdraw-assets-transfer}) possono essere vere perché il metodo usato (es. \code{transfer}) does not have enough gas to allow the receiver to perform further transfers, ma Certora non riesce a verificarle.
%Il Move Prover invece non sembra avere modo di parlarne

% \emph{Language-specific features.}
% Certain language features can heavily complicate verification, requiring tools to implement advanced functionalities. This is the case, for example, of dynamic dispatching in Solidity. In order to address the verification of certain properties, CVL introduced the \code{dispatcher} summary type. In MSL, on the contrary, such functionality is not needed, as dispatching is static instead of dynamic. \enriconote{example?}\silvianote{Io toglierei questo paragrafo: è troppo generico l'inizio e la parte sul dispatching è stata detta prima}
%Indeed, in order to address the issues  Certora,    
%Per alcuni aspetti del linguaggio che rendono la verifica più complessa, es. dispatcher, è necessario che il prover sviluppi funzionalità più complesse (es i dispatcher di Certora). Per Move non c'è bisogno.
