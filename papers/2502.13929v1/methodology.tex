\section{Methodology}
\label{sec:methodology}

%\bartnote{dire che diamo più dettagli su use cases e loro proprietà nella sezione 4}

%\enriconote{Metterei le varie giustificazioni qui sistematizzate (anziché sparse nelle altre sezioni) }

We now detail the methodology we adopted for our comparative analysis,
explaining the choices of the verification tools, use cases, and properties, and how we have built our dataset.%\enriconote{necessario per includere il fatto che nella 3.3 discutiamo anche come costruiamo le spec, non è solo scelta della proprietà}
% Furthermore, we illustrate how we construct our dataset.


\subsection{Verification tools}
\label{sec:methodology:provers}

Given the variety of verification tools available, particularly for Solidity,
doing an extensive comparison of all these tools lies beyond the scope of this work.
%, and will make explicit mention of other tools only when needed.
We focus on the Certora Prover for Solidity and the Aptos MVP for Move. The choice of the Aptos MVP is straightforward, as it is, to the best of our knowledge, the only supported version of the Prover at the time of writing,
%This choice has been made on the basis of: 
%\bartnote{capisco, ma non menzionerei la completezza} \enriconote{extensivity? comprehensiveness?} completeness of the  contract language supported, 
%expressivity of the specification language, adoption in real-world settings, and documentation and maintenance of the tool.
which has furthermore been used to formally verify large Move libraries, including the entire Aptos smart contract layer~\cite{Park24fmbc}.
We exclude VeriMove~\cite{VeriMove} as it only supports a strict subset of the language.
%
%The only other tool that we are aware of able to verify Move is VeriMove, which, however, seems to only support a subset of the Move language. 
For Solidity, the variety of available tools is broader. 
While no single tool strictly outperforms all others in every aspect,
we choose the Certora Prover since it is the tool most used in real-world settings for the verification of complex properties.
%we have found that the Certora Prover is the only one that consistently satisfies all our prerequisites to a high degree.
%\bartnote{non abbiamo mai dato prerequisiti, mi pare} \enriconote{mi riferisco all'elenco che segue "on the basis of"... altro termine?}
%While each of these tools has its strengths, and 
% we select the Certora Prover since it is fairly expressive,  it is the tool most used in industry, and the better documented one. 
We will nonetheless explicitly mention other tools capable of 
%verifying 
addressing 
properties beyond the scope of the two selected tools, whenever applicable. 
%In the cases of properties that cannot be verified by these two tools, we will make explicit mention of  other tools that are able address such properties, if any.
%\silvianote{controlla che poi lo facciamo davvero} %\enriconote{sì lo facciamo davvero}
%, while discussing provers functionalities in Section \ref{sec:comparison:prover}. 
In the following, we will refer to the two tools just as Certora and Move Prover (or MVP).
%
%Per Solidity, invece, c'è un ecosistema molto più ricco, con diversi tool, ognuno con suoi punti di forza, nessuno strettamente dominante.
%Un confronto esaustivo tra i tool di verifica per Solidity esula da questo lavoro
%(in parte è stato fatto qui, tra SolCMC e Certora~\cite{BFMPS24fmbc}).
%Qui ci concentriamo su Certora perché quello che riteniamo più espressivo (in termini di proprietà esprimibili, così come di feature).
%Se determinate proprietà possono essere verificate con altri tool ma non Certora, lo annotiamo a parte \enriconote{Abbiamo esempi? Es. Liveness con SmartPulse, liquidity con Solvent}.
%\myparB{Move}
%
%Inoltre, lo scopo del nostro lavoro non è dare un giudizio complessivo ai due tool, nè fare un confronto 1-1. 
%Ci interessa più vedere come cambia la verifica nei 2 linguaggi, e cosa lo stato dell'arte in termini di tool ci permette di fare al momento della scrittura dell'articolo.
%
%\myparB{Mani avanti}
%Note that, when we compare Certora with the Move Prover, our goal is not to draw a one-to-one comparison, nor to decide which tool is ``better'' than the other.
%
%Va precisato che lo scopo del Move Prover e di Certora, e il modo con cui sono stati pensati, è diverso. Infatti:
%\begin{itemize}
%\item Move Prover: specification and development go side-by-side (strongly tied to the type system).
%\item Certora: ex-post analysis of contracts, for auditing: the contract cannot be changed, so the specification language must be rich 
%\end{itemize}
%
%Indeed, such a straight-forward comparison would not have significance per se, as 
We remark that Certora and MVP have been designed with different goals. 
In Move, specification and development go side-by-side. 
% (MVP is strongly tied to the type system). 
Certora, on the other hand, is more oriented to the ex-post analysis of contracts and is primarily used for auditing~\cite{certora-reports}:
consequently, CVL is designed to support the verification of complex properties without requiring modifications to the contract code (\eg, updating ghost variables at given program points).
%
Despite these differences, applying the state-of-the-art tools to a common benchmark is crucial to answer our research questions, namely which properties can be verified in the two languages at the time of writing (RQ2), and how the choice of the contract language affects the quality of the verification process (RQ1). %\footnote{\enriconote{ultimo paragrafo verboso e ripetitivo}}

% However, the goal of our experiments is not to draw a one-to-one comparison between the two tools; rather, to assess the state-of-the-art of the verification for both Solidity and Move.

%From a certain point of view, a fairer comparison\footnote{\enriconote{forse toglierei questo pezzo: alla fine il nostro non è un confronto tra i tool in quanto tali, ma tra lo stato dell'arte della verifica nei due linguaggi: per ciascuno abbiamo preso il tool migliore}} would be between the Move Prover and SolCMC, since also the latter is shipped within the compiler and its main intended purpose is  assisting developers during the development phase. 

% However, the Move Prover specification language is way richer than the SolCMC one, and, moreover, the specification can be kept separated from the implementation. For this reason, for the scope of our work, is more interesting to compare the Move Prover with Certora.

% enrico: questo alla fine lo diciamo già su e non è così interessante, considerato che alla fine il confronto è più sull'espressività che sulle performance
%In order to analyze and compare the outcomes of the tools, we observe that they both rely on SMT solvers at the core of computation. 
%From this point of view, even though different use of SMT solvers (as well as different versions of the same SMT solver) 
%%, and different techniques to use the SMT solvers, 
%may relevantly impact the results given by the provers, 
%the comparison is ultimately fair. 

%Come ruolo, il Move Prover è più simile a SolCMC: sviluppato e mantenuto da chi mantiene il linguaggio per assistere gli sviluppatori.

%Da questo punto di vista, potrebbe considerarsi più fair confrontare Move Prover con SolCMC, però SolCMC è estremamente limitato e il Move Prover permette di formalizzare specifiche molto più ricche degli assert.
% \bartnote{ma la specifica può essere in gran parte separata dall'implentazione (diversamente da SolCMC)}


%Per questo motivo, è più interessante confrontarlo con Certora, nonostante lo scopo con cui sono stati sviluppati i due tool sia diverso.

%Da questo punto di vista, il Move Prover potrebbe essere visto come via di mezzo tra SolCMC e Certora.

% \bartnote{Una cosa da dire (forse criticabile) è che stiamo usando il Move Prover allo stesso modo in cui ci si aspetta di usare Certora, ovvero: ho un contratto fissato, e voglio scrivere una specifica esterna senza modificare o annotare il contratto. Notare che Move Prover supporta (forse meglio) l'approccio design-by-contract, in cui è consentito - anzi in molti casi è proprio necessario - annotare il programma con pre- e post-condizioni e invarianti}



\subsection{Use cases}
\label{sec:methodology:contracts}
%\enriconote{Con che criterio abbiamo scelto i contratti? Dire specificità di ciascuno dei 3 contratti che li rendono interessanti dal punto di vista della verifica. }

In the selection of the verification use cases, 
we identify three paradigmatic smart contracts with increasing level of complexity and exhibiting a rich spectrum of features: a \contracturl{bank} contract, a \contracturl{vault} contract, and a \contracturl{price-bet} contract (due to space constraints, we  present them in~\Cref{sec:benchmark}).
We implement each use case in Solidity and in Aptos Move, ensuring that these implementations remain as close as possible.
% \footnote{The implementations we consider are based on the  Rosetta Smart Contract benchmark~\cite{Rosetta25fgcs}.}
%We have taken inspiration from the Rosetta repository~\cite{Rosetta25fgcs}, which includes implementations of common use cases in different contract languages (including Solidity and Aptos Move),. We 
%Per la scelta degli use case da considerare, siamo partiti da un benchmark pubblico \cite{Rosetta25fgcs} che contiene implementazioni degli stessi use case in  linguaggi diversi (tra cui Solidity e Aptos Move).
%\bartnote{non stresserei troppo su questo, visto che poi abbiamo modificato i contratti per renderli più interessanti}
%
%Abbiamo scelto di considerare un numero ridotto di use case così da poter per privilegiare un'analisi più in profondità delle proprietà desiderabili per ciascun contratto.
%
%Given the qualitative approach of our work, we decide to focus 
%
The verification of these use cases requires to deal with properties featuring several aspects, such as: key-value maps, access control, time constraints, contract-to-contract calls, transaction-ordering dependencies, \emph{etc}.
%
%Questo è coerente con il nostro approccio qualitativo e non quantitativo. Considerare un ampio numero di use cases restando in superficie a livello di verification task non ci avrebbe dato modo di studiare sufficientemente a fondo ... \enriconote{altro?}
%
%In particolare, abbiamo scelto contratti che ci danno la possibilità di esprimere proprietà che riguardano: key-value maps, access control, contract-to-contract calls, transaction-ordering dependencies, time constraints, ...
%
% In alcuni casi, abbiamo apportato modifiche minori ai contratti, o per correggere imprecisioni nell'implementazione, o per rendere il contratto un po' più interessante (ma non artificioso).
%\textcolor{red}{
%\begin{itemize}
%    \item Bank: mappe, special users (quantificatori?)
%    \item Vault: state-based, tempo, adversary, transaction-ordering dependencies
%    \item Price-bet: external call ($\implies$ aleatorietà, "non-determinismo"), transaction-ordering dependencies (con le tx dell'oracolo) 
%\end{itemize}
%}


\subsection{Properties }
\label{sec:methodology:props}

%\enriconote{v. differenza contract-level e program-level. Osservazione: differenza non è così binaria.}

%\silvianote{Con che criterio si individuano le proprietà desiderabili?}

%\enriconote{Specificare che non ci interessa fare una valutazione "quantitativa" (perché non avrebbe senso), quindi la scelta delle proprietà dipende anche dal loro interesse da un punto di vista di verifica, e ci interessa più la varietà delle proprietà che la quantità}

For every use cases, we consider an extensive set of properties, ranging from low-level properties that only target single contract functions, to more high-level ones that characterize the global behaviour of the contract. 
%While the first kind is essential for checking that single methods have been correctly implemented, it has been observed that verification of the second kind of specs is more impactful in industrial contexts \cite{Xu24langsec}. We give equal importance to the two kind of specifications.
Our choice of properties is based on breadth and diversity (in terms of language features involved, abstraction level, temporal logic structure). 
Overall, we end up with \nTotProperties properties. 
%
%Per ogni contratto, abbiamo considerato diverse proprietà: sia proprietà low-level che possono riguardano ad esempio un singolo metodo avulso dal contesto del contratto, sia proprietà di carattare più generale che riguardano il comportamento ideale del contratto (che possono anche non riferirsi direttamente a nessun metodo). 
%\enriconote{Citare che è stato osservato in \cite{Xu24langsec} che non tutte le specifiche hanno lo stesso impatto (anche come ROI). }
%
Aiming at generality, and potentially including also properties that cannot  be expressed in the considered tools, we write properties in natural language. 
% Note that the two truth values may not coincide due to the different characteristics of the languages.
We then encode each property, whenever possible, as CVL and MSL specifications.
%\enriconote{Introducto termine specification per la scrittura delle proprietà in CVL e MSL}
Often, this translation involves adding suitable low-level technical assumptions, to make the specification aligned with the spirit of the corresponding natural language property. 
% For some properties, it is necessary to add certain low-level technical assumptions, without which the verification would not be possible. 
As an example, in Move, users may have a frozen coin store that prevents them from receiving tokens; in such a case, even if the natural language property does not mention such aspect, we consider adding such low-level technical assumptions as part of the translation process. 
%
Furthermore, coherently with most verification tools,
% we neglect gas and storage fees:
%we assume that users do not pay any fee when submitting a transaction.
we neglect transaction fees.
We then manually annotate the expected truth value in Solidity and Move.
%
Finally, we run the provers and take note of their output.
We end up, for each use case, with a \href{\sheeturl}{sheet} consisting of four main columns for each property row: two columns for the ground truths, and two for the provers results. We enrich the table with additional columns containing notes on: the class of the property, the expected truth values, the formal specifications, and the provers outputs.\silvianote{Perché qui c'è solo l'hyperlink implicito e non l'url come per il dataset?}   

%\enriconote{integrare}\emph{Fees.} Tutte le nostre proprietà sono intese "up to fees". Nota: questo è anche consistente con l'interpretazione di vari tool (es. Certora, MVP, SolCMC) 

%Abbiamo scritto le proprietà in linguaggio naturale, e,   per ciascuna proprietà, abbiamo annotato  la ground truth attesa in Solidity e Move
%\enriconote{nota: non sempre coincide (vedremo degli esempi in Comparison)}

%Scriviamo poi la proprietà come specifica nel linguaggio dei due tool. 

%Nota: non sempre ciò è possibile, alcune proprietà non sono esprimibili in uno dei due tool o in entrambi (vedremo degli esempi in Comparison).

%Nota: spesso le proprietà necessitano, in uno o nell'altro linguaggio, di assumptions aggiuntive low-level (ragionevoli), in assenza delle quali le proprietà sarebbero false. 
%\enriconote{Inserire esempio per far capire che parliamo di sottigliezze} 
%\enriconote{Specificare che consideriamo le proprietà "le stesse", up to queste piccole assumptions (che fanno parte quindi non della proprietà, intesa in linguaggio naturale, ma della specifica, intesa in senso tecnico).}

% \emph{assumptions}? (e.g. in Move that contract exists, that funds are not locked, that fungible-to-asset is disabled, etc. ...)


%Per ogni verification task, segnamo poi valore ritornato da entrambi i tool (se possibile). 

%La parte interessante, è quando o le ground truth o l'esprimibilità delle proprietà o i risultati della verifica mismatchano. 
%Nella sezione Comparison analizzeremo principalmente questi casi. 

%\ 

% \enriconote{Io non inserirei qui la tabella sulla tassonomia perché per me è uno dei risultati dell'articolo: è una sistematizzazione di quelli che possono essere verification task interessanti, molto influenzata, in particolare, dalla verifica nei linguaggi Solidity e Move, e ancor più specificatamente, per sistematizzare le differenze tra i due tool Certora e Move Prover. Presentarla qui nella sezione metodologia la farebbe sembrare conoscenza pregressa, e invertirebbe il rapporto causa-effetto (non abbiamo scelto le proprietà data la tassonomia, ma abbiamo stilato la tassonomia date le proprietà e i risultati dei tool).    }
