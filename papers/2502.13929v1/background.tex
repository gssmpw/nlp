\section{Background}
\label{sec:background}

In this section we overview the main features of 
%the two platforms (\ie, contract language with an associated verification tool) \enriconote{platform fa pensare a una roba troppo integrata, vero per MVP ma non per Certora}
the two languages and of the two verification tools
considered in our experimental comparison. 
%\bartnote{simplify next}
In particular, we focus on key design choices of the underlying intended blockchain's model, since it has an impact on both the specification and the verification of contracts' properties. %\enriconote{cambierei questa frase}
%the interconnection between the contract language and the specification language for its verification, observing how they reflect .

\subsection{Contract languages: Solidity \emph{vs.}~Move}
\label{sec:background:languages}

From the perspective of smart contract programming, a blockchain is best understood as an asset-exchange state machine, in which the state keeps track of the assets owned by each account, and every transaction contributes to a state transition, possibly creating new assets or exchanging assets among accounts. 
%
In Solidity, there are two kinds of accounts: 
externally owned accounts (EOAs) and contract accounts.
The state of the asset-exchange machine can be seen as a map that associates each EOA with a balance of native assets owned by the account (\eg, ETH in Ethereum), and each contract account with a balance and a \emph{storage}, which contains variables and data structures that define the contract state. 
% and keeps track of the asset balance (henceforth the \emph{global store}) as a map that associates each (user or contract) account with the amount of native assets the account owns (henceforth the \emph{balance}). 
Differently, in Move the state of the machine can be seen as a map from accounts to the assets owned by them. 
Assets (called \emph{resources} in Move) are encoded by struct datatypes that enjoy linear semantics, \ie, a static type system ensures that resources are never duplicated or lost.
%
The main difference between Solidity and Move is the representation and accounting of  assets. 
In particular, accounts in Solidity can only explicitly own native assets, while in Move they can own arbitrary resources.
This has a relevant impact, since most real-world contracts involve the creation and exchange of \emph{user-defined} assets, \eg to represent utilities or market shares in DeFi protocols.
Representing and handling user-defined assets in Solidity requires a suitable encoding in the smart contract, while in Move all assets are dealt uniformly.

\begin{figure}[t]
\small
\begin{lstlisting}[language=solidity,caption={Simplified Solidity code for the Bank case study},label={fig:codeSol}]
contract Bank { 
  mapping (address => uint) credits;
  function deposit() payable {  credits[msg.sender] += msg.value;  }
  function withdraw(uint amount) {
    credits[msg.sender] -= amount; payable(msg.sender).transfer(amount);
  }
}
\end{lstlisting}
\end{figure}

\begin{figure}[t]
\begin{lstlisting}[language=move,caption={Simplified Move code for the Bank case study},label={fig:codeMove}]
module bank {
  struct Bank { credits : SimpleMap<address, Coin> } //  resource definition 
  fun init(account : &signer) {
    let bank = Bank { credits : simple_map::new() }; // create a resource 
    move_to(account, bank); // now signer owns a bank
  }
  fun deposit(sender : &signer, owner : address, amount : u64)  {
    let bank = borrow_global_mut<Bank>(owner); // borrow the resource        
    let to_deposit = coin::withdraw(sender, amount); // get sender's coins
    let credit = map::borrow_mut(&mut bank.credits,address_of(sender)); 
    coin::merge(credit, to_deposit); // increase credit by merging coins   
  }
  fun withdraw(sender : &signer, owner : address, amount : u64) {  ... }
}
\end{lstlisting}
\end{figure}

%let coin_available = simple_map::borrow_mut(&mut bank.credits, &signer::address_of(sender));

To exemplify, consider the simplified Solidity code in~\Cref{fig:codeSol}, which encodes a simple bank contract. Once deployed on the blockchain, the global store keeps track of the bank's \emph{balance}, \ie the amount of ETH associated to the contract account. The contract stores in a variable the \code{credits} (a \emph{number} that \emph{represents} ETHs) associated to each bank's client. 
%An account must invoke the function \code{deposit} with an amount of ETH. 
When an account (\code{msg.sender}) invokes the function \code{deposit} sending a given amount (\code{msg.value}) of ETH, the effect is twofold: the ETHs are transferred to the contract's balance, and the sender's additional credit is registered.
The  {\tt withdraw} function first decreases the number of credits and then transfers the amount of ETH to the sender. 
%
The corresponding Move code is shown in~\Cref{fig:codeMove}. The code defines a \code{bank} module, which relies on two types of \emph{resources}: the \code{Coin}s provided by the underlying platform, and the user-defined \code{Bank} data structure. The contract is initialized by the function \code{init}: the signer of the transaction initializes a new, empty, \code{Bank} and registers its ownership in the global store. When an account invokes the function \code{deposit}, he takes the role of the \code{sender} (\ie, the transaction's signer), and the function code executes three steps: (i) the \code{Bank} resource is borrowed from the address of its \code{owner},  (ii) an \code{amount} of \code{Coin}s are borrowed from those owned by the \code{sender}, and (iii) they are merged with those already registered in the \code{Bank}'s \code{credits} map.  

Despite its simplicity, this example already shows some differences between the two languages in terms of asset management. 
In Move, resources are first-class citizens, with properties such as linearity statically guaranteed by the type system.
By contrast, in Solidity the user-defined assets must be carefully handled at the contract level (\eg, the logic of the {\tt credits} map must correctly match the flow of ETH), which may be a source of critical bugs. 

We will discuss other features and differences between Solidity and Move in~\Cref{sec:comparison}, where they will be instrumental in addressing RQ1 about the impact of language design on smart contract verification.

% \enriconote{da qui listerei le altre features rilevanti, dicendo che le analizzeremo in sez  discutendo in profondità il loro impatto sulla verifica}

%\enriconote{non si capisce il senso della frase che segue}
% On the other hand, Move adopts a sophisticated access control mechanism inspired by Rust, which requires to properly handle mutable and immutable references to the resources in the global store.\silvianote{...sistema a seconda di ciò che serve dire nella discussione.}

% Finally, in Solidity the transfer of ETH (\cf {\tt withdraw} in Figure~\ref{fig:codeSol}) involves the well-known risks of re-entrancy vulnerabilities, due to the possibility of the  %activation of an unknown fallback function of the receiver address
% callee to call back its caller. %in such a way as to modify its state variables, bringing it into an inconsistent state where it performs unwanted actions 
% This is impossible in Move, since invoking another contract is not possible unless its module is known at compile-time, and mutual recursive calls between modules are forbidden at compile-time. 


%\bartnote{conviene notare già qui alcune differenze nei linguaggi, o nella subsection 2.3?}
%\bartnote{anche la withdraw sarebbe interessante, almeno per Solidity, per dire che usa una chiamata esterna per trasferire gli ETH. Siamo stretti con lo spazio però}

%// ~Solidity: deposit is allowed only to msg.sender (the transaction signer)


\subsection{Formal verification tools for Solidity and Move}
\label{sec:background:provers}

% An extensive comparison between the numerous verification tools falls out of the scope of this work (see \cite{Rosetta25fgcs}...), which is rather focused on an experimental comparison of the two platforms. We then just introduce the selected verification tools, namely Certora Prover and Move Prover, positioning them in the state of the art and highlighting their connections with the corresponding smart contract language features. 

%\myparB{Solidity} 
For Solidity, there exist several bug detection tools~\cite{Kushwaha22access} as well as several verification tools~\cite{Tolmach22csur}. 
% composed of several tools. 
%, each with strengths and weaknesses, and such that no one strictly dominates all the others. 
The two main verification tools are SolCMC \cite{Solcmc}, shipped with the Solidity compiler, and the Certora Prover \cite{certora}. 
% developed by the homonym auditing company. 
%While both tools are very advanced and can be thought as complementary to each other, Certora  is the more expressive one, with SolCMC limited to in-code \code{assert} statements (see \cite{BFMPS24fmbc} for a comparison).
Other verification tools, including
SmartACE~\cite{Wesley22vmcai}, 
SmartPulse~\cite{Stephens21sp},   
Solvent~\cite{Solvent},
VeriSolid~\cite{Nelaturu23tdsc},
VerX~\cite{Permenev20sp}, and 
Zeus~\cite{Kalra18ndss},
target various verification aspects,
each tool having its own specification language,
level of abstraction, 
and limitations.
%
%For example\footnote{\enriconote{attaccare meglio}}, the 
In this work, we focus on Certora (see~\Cref{sec:methodology}), whose verification language (CVL)~\cite{certora-cvl} features two ways of expressing contract properties:
\emph{invariants}, which represent conditions that must remain true across contract transitions, and \emph{rules}, which are a flexible way to specify more general conditions on possible contract transitions. CVL rules can arbitrarily combine requirements on the contract state, calls to contract functions (possibly, leaving some call parameters partially specified), and assertions on the states reached upon these calls.

%Most of them target a specific set of specifications, then they are able to express properties that falls out of the scope of the Certora Verification Language (CVL), but at the same time they do not cover other properties captured by CVL.
%%making them complementary to the Certora Prover.
%For example, SmartPulse targets liveness properties, Solvent targets enabledness/liquidity properties, and VeriSolid target certain CTL properties, all of which cannot be addressed with Certora. 
%%However, most of these tools work on a certain level of abstraction, while the Certora Prover work with the actual compiled EVM code,  and, overall, CVL seems to be more expressive than any of the single specification language supported by these tools.
%Moreover, the Certora Prover is the tool most used in industry, and the better documented one. 
%For these reasons, we choose this tool for our experimentation with Solidity.
%to use the Certora Prover in our experiments (just \emph{Certora} in the following).

%Per Solidity, invece, c'è un ecosistema molto più ricco, con diversi tool, ognuno con suoi punti di forza, nessuno strettamente dominante.
%Un confronto esaustivo tra i tool di verifica per Solidity esula da questo lavoro
%(in parte è stato fatto qui, tra SolCMC e Certora~\cite{BFMPS24fmbc}).
%Qui ci concentriamo su Certora perché quello che riteniamo più espressivo (in termini di proprietà esprimibili, così come di feature).
%Se determinate proprietà possono essere verificate con altri tool ma non Certora, lo annotiamo a parte \enriconote{Abbiamo esempi? Es. Liveness con SmartPulse, liquidity con Solvent}.

%\myparB{Move}
%\enriconote{un po' brutto che qui si fa la storia e sopra no}
The Move language, since its early stages, has been tightly coupled and integrated with the Move Prover (MVP): they have been developed and maintained together, and the MVP is intended to be used routinely during smart contract development, likely to an advanced type checker.
The Move Prover specification language (MSL) \cite{aptos-msl,Xu24langsec} features different ways of expressing properties: function specifications (in terms of pre- and post- conditions), and invariants on functions, on struct datatypes, on global states, and on state transitions (see~\Cref{sec:properties}).
%
We are only aware of  another tool that addresses formal verification of Move contracts, VeriMove \cite{VeriMove}, built upon the Solidity counter-part VeriSolid.% 

%These verification tools either prove that the property holds in all possible contract executions, or provide a counter-example that violates the property.

% senso: guarda che i tool non sono sound
% To stay on the safe side, verification tools try to over-approximate the set of reachable contract states. 
% Therefore, when a tool outputs that a property is verified, this usually implies that the property holds in all possible contract executions.
% Instead, when a tool detects a possible violation of a property, it typically provides a counterexample, \eg a state where the property does not hold.
% However, due to over-approximation, this state may not always be reachable in actual executions. \enriconote{ruolo di questo paragrafo poco chiaro}

% The tool chain takes in input the Move source code with the specification, and the Prover Compiler generates Boogie IR  which is further lowered into the SMT language and subsequently fed to an SMT solver such as Z3 or CVC5.

% While the specification language of VeriMove allows to express some complex CTL temporal formulas that are out of the scope of the Move Prover, it seems to only support a subset of the Move language. 

%\enriconote{è corretto dire che non sembra si possano esprimere proprietà più low-level? possiamo aggiungere che, che noi sappiamo, VeriMove non è (ancora) utilizzato, mentre il Prover di Aptos sì?}

%For these reasons, we decide to focus on the Aptos Move Prover  (just \emph{Move Prover} in the following)..

As an example, consider the property ``\emph{after a successful \code{deposit}, the credits of the sender are increased exactly by  the {amount} of tokens deposited}''.  %(\specurl{bank}{deposit-assets-credit}).
In CVL (\Cref{fig:specCVL}), the rule first specifies the call environment \code{e} (which includes the transaction parameters \code{msg.sender} and \code{msg.value}), and stores the sender's credit before the call to \code{deposit()} in the variable \code{old\_value}. 
Then, the rule calls \code{deposit()} with environment \code{e}, and checks whether the sender's credits after the call have been increased by the amount sent.
In MSL (\Cref{fig:specMSL}), the property is expressed as a function spec (\ie, a specification targeting a single function), in terms of pre and post conditions.
The variables tagged with {\textcolor{red}{\code{post}} refer to the values of the expressions \emph{after} the call to \code{deposit}.

\begin{lstlisting}[language=cvl,caption={Specification of \specurl{bank}{deposit-assets-credit} in CVL},label={fig:specCVL}]
rule deposit_assets_credit {
  env e; // environment variables of the call
  address addr_sender = e.msg.sender; // transaction sender
  mathint amount = e.msg.value; // amount of ETH tokens sent by sender to contract
  mathint old_value = currentContract.credits[addr_sender];
  deposit(e); // perform a successful call to deposit
  mathint new_value = currentContract.credits[addr_sender];
  assert new_value == old_value + amount; // verification condition
}
\end{lstlisting}

\begin{lstlisting}[language=move,caption={Specification of \specurl{bank}{deposit-assets-credit} in MSL (simplified)},label={fig:specMSL}]

spec bank_addr::bank {
  spec deposit {
    let addr_sender = signer::address_of(sender);
    let old_credits = global<Bank>(owner).credits;
    let old_value = simple_map::spec_get(old_credits, addr_sender).value;  
    let post new_credits = global<Bank>(owner).credits;
    let post new_value = simple_map::spec_get(new_credits,addr_sender).value;
    ensures new_value == old_value + amount; // verification condition
  }
}
\end{lstlisting}