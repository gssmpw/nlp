

\section{Introduction}

%In the realm of smart contracts, program correctness is even more crucial than in standard program development. \enriconote{criticabile (correctness di standard programs che girano sugli aerei più crucial di correctness di smart contracs)}
Due to the immutability of the code after deployment 
% the absence of intermediaries,
and the huge amount of economic assets managed, ensuring the correctness of smart contracts is a crucial task.
Attacks exploiting code vulnerabilities and wrong implementations of the business logic are estimated to have caused  over \$6 billion of losses~\cite{Chaliasos24icse}, creating
%This is because smart contracts cannot be modified once deployed on a blockchain, and because they operate activities with high economic value across industry sectors including supply chain, finance and legal services. \enriconote{accorciato}
a huge demand for safer and verifiable code. 
%and validation\enriconote{non trattiamo validation}
%techniques. % able to detect bugs and prove implementation correctness  with respect to the intended specifications.
%, which lead to the proliferation of many different tools\enriconote{qui forse si intendeva bug detection tool ma non chiaro; per verifica i tool sono decisamente pochi}, that vary depending on the platform, the target language, and the type of properties they intend to verify.  Besides surveys or taxonomies, properly assessing and comparing even similar techniques is challenging. 
%both at bytecode or low level checks, property-based testing, static analysis
%\enriconote{riscrivo parlando direttamente di Solidity e Move}

Solidity, the most adopted smart contract language, %used on EVM-compatible blockchains,
presents  semantical quirks that make contract implementation quite error-prone, and that highly complicate the verification process. 
In order to address this issue, several bug-detection tools have been developed~\cite{Tolmach22csur}, as well as some verification tools, that vary in scope, specification language, and level of abstraction. Most notably, SolCMC~\cite{Solcmc}, shipped with the Solidity compiler,
and the Certora Prover~\cite{certora}, developed for auditing.

Move is a more recent smart contract language, originally developed for the Diem/Libra blockchain  
and later adopted by Aptos, SUI and IOTA.
Designed with verifiability in mind, Move has been accompanied by a formal verification tool~\cite{Zhong20cav} since its early development.
%https://github.com/MystenLabs/awesome-move?tab=readme-ov-file

In this work, we investigate how differences in the design of Solidity and Move (in the Aptos dialect) affect verifiability.
%
%We conducted a pilot study involving two relevant platforms: the Solidity language with the Certora Prover verification tool, and the Move Aptos language with its companion Move Prover. We selected the first because it is the most adopted smart contract language, and the second because it is designed to be solid and grounded on the companion verifier tool. \enriconote{tolgo, spiegato sopra}
%
We base our study on a comparative analysis of a small set of paradigmatic use cases, 
each evaluated against a range of representative properties. These properties span from low-level
aspects, such as function specifications and state invariants, to more high-level ones that
characterize the business logic of the contract.
For each property, we study the ground truth in Solidity and in Move, 
and we write, whenever possible, the corresponding formal specifications in the Certora Verification Language and in the Move Specification Language.
We focus, in particular, on properties that exhibit discrepancies in ground truths, expressibility, or verifiability. 
%behaviour of the contracts as a whole\footnote{\enriconote{poco chiaro}}.
%
%Without claiming to be an exhaustive comparison\enriconote{non scusiamoci}, 
The %findings 
results
of our analysis offer relevant insights about 
%%the role of contract language features in formal verification, as well as the state of the art of two widely used verification tools.
%%
%%and we put forward 
the following  research questions: %and working methodology:
%More specifically, we investigate:
\begin{description}

%\item[RQ1)] What is the role of the languages' features on the verification of smart contracts in Solidity and Move?
\item[RQ1)] What is the impact of different features of  Solidity and Move on verification?
%How different features of Solidity and Move impact verification?
% (which properties are impossible to verify, which are trivial, ...).

\item[RQ2)] What is the state-of-the-art of verification tools for Solidity and Move, and which kind of properties are they currently able to verify?
\end{description}
%\item[Data Collection)] 
As an additional contribution, we have developed a {\bf public dataset}\footnote{\githuburl} (the first of this kind)
%\enriconote{stresserei più che è il primo dataset che ti mette fianco a fianco spec in CVL e MSL}
that serves as a basis of an experimental --- and extensible --- comparison between the Certora and the Aptos Move specification languages and verifiers.

%\enriconote{spostato su}
%To support our findings %In order to answer the research questions 
%we adopt an empirical methodology  that entails the construction of a public {\bf Dataset}\footnote{\urlGithub}. 
%More precisely, for each contract-specific property, 
%$(i)$ we propose a categorization of the property\footnote{\enriconote{non direi questo, la usiamo solo per orientarci, è attaccabile}}, we annotate
%$(ii)$ the expected truth value in Solidity and Move (which may depend on the specific aspects of the contract language),
%$(iii)$ the possibility of expressing the property in the specification language of each tool, 
%and we report the $(iv)$ output the provers. %(which depends not only on the language but also on the features of the tools). %we  test the \emph{expressiveness} of the specification languages provided by the two verification tools, and $(iii)$ we compare \emph{verification results} for  expressible properties. 
%\end{description}
%
%Most entries in the dataset are enriched with notes, to emphasize that we do not put forward a taxonomy of properties nor a quantitative analysis \enriconote{il punto delle note non è tanto questo, + non scusiamoci}, 
%but a data collection that can be the base of an experimental -and extensible- comparison of two contract verification tools.\enriconote{spostato su}

\mypar{Structure}
The paper starts in~\Cref{sec:background} with an overview of Solidity and Move, and their respective verification tools. 
%Section 3 details the methodology we adopted and justifies our choices in terms  of verification tools, use cases and verification tasks. 
\Cref{sec:methodology} presents our methodology and discusses the choices of tools, use cases and properties. 
%The main results of our comparative analysis are detailed 
In~\Cref{sec:comparison} we present the results of our comparative analysis, addressing RQ1 and RQ2 in~\Cref{sec:comparison:language} and in~\Cref{sec:comparison:prover}, respectively. 
%and distinguishes between the impact of contract languages (RQ1) and the impact of the prover languages and functionalities (RQ2).
Finally, in~\Cref{sec:conclusions} we summarize our findings, discuss limitations, and outline future work.

%\silvianote{...non piu' leones, ma sarebbe da integrare con qualche hint sulle risposte a RQ1/RQ2. Oppure l'intro è ok così e le risposte sintetiche alle RQ le mettiamo nelle conclusioni}