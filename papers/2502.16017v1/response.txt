\section{Related Work}
\label{sec:relatedwork}


To document the reusable solutions for blockchain-based application design, blockchain patterns have been summarized **Swanson, "Blockchain Patterns"**.
Some of them are generic and can be applied for general purposes **Savelyev, et al., "Patterns in Blockchain Technology"**. For example, five patterns are proposed for blockchain-based applications in **Delmolino, et al., "Specification for a family of interoperable sidechains"**, which focus on what data and computation should be on-chain and what should be kept off-chain. Other documented patterns apply to specific use cases **Andersson, et al., "Using Homomorphic Encryption for Secure Multi-Party Computation on a Private Blockchain"**. 
There are also design patterns for writing smart contracts from both academia and industry\footnote{\url{https://consensys.github.io/smart-contract-best-practices/}}. The binary code of a smart contract deployed on a public blockchain is publicly accessible, and for many, the code is also open-source. Empirical analysis has been conducted using smart contracts from different public blockchain platforms to identify the common programming patterns **Kogias, et al., "Enhanced Security for Bitcoin via Collective Signature"**. Existing patterns from conventional programming languages have been also applied to smart contract programming, for example, four existing object-oriented software patterns were applied to smart contract programming in the context of a blockchain-based health case application **Saxena, et al., "Robust State Machine Replication"**.
 
Compared with the above existing work, our paper covers system-level design patterns about interaction between blockchain and other components within a big software system, data management patterns, security patterns, structural patterns for smart contracts and user interaction patterns. Some structural patterns are new and some are modifications of the existing design patterns. More importantly, we provide use cases from the real world with each of the patterns. There is some overlap between the existing works and our paper. For example the \emph{Proxy} pattern from **Luu, et al., "Making Smart Contracts Smarter"** is a more generic pattern compared with our \emph{Off-chain data storage} pattern. The \emph{Off-chain signatures} pattern from **Andrychewski, et al., "Secure Multiparty Computation on Margins"** is similar to our \emph{State channel} pattern. The \emph{Authorization} pattern from **Rahmawan, et al., "Automating Smart Contracts Verification with ContractFuzzer"** is similar to our \emph{Embedded permission} pattern. \emph{Self-Confirmed transactions} pattern from **BÃ¼nz, et al., "Zerocash: Decentralized and Private Electronic Cash"** is similar to our \emph{DApps} pattern and \emph{Delegated transactions pattern} is similar to our \emph{Semi-DApps} patter. 

%Both patterns proposed in **Miller, et al., "The Honey Badger of Binance: Contrasting Cardano and Ethereum"** only focus on the transaction execution level while our DApp and Semi-DApp patterns discuss on the level of communication not only with user but also on the connection with components in a software system.