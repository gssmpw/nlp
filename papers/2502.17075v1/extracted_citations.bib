@inproceedings{MLSYS2021_cc427d93,
  title = {Equality {{Saturation}} for {{Tensor Graph Superoptimization}}},
  booktitle = {Proceedings of {{Machine Learning}} and {{Systems}}},
  author = {Yang, Yichen and Phothilimthana, Phitchaya and Wang, Yisu and Willsey, Max and Roy, Sudip and Pienaar, Jacques},
  editor = {Smola, A. and Dimakis, A. and Stoica, I.},
  year = {2021},
  volume = {3},
  pages = {255--268},
  keywords = {application,Computer Science - Artificial Intelligence,Computer Science - Distributed Parallel and Cluster Computing,equality saturation},
  file = {/Users/jumerckx/Zotero/storage/LC3YEDX7/Yang et al. - Equality Saturation for Tensor Graph Superoptimization.pdf;/Users/jumerckx/Zotero/storage/NDGHWQ5S/2101.html}
}

@misc{ahrensFinchSparseStructured2024,
  title = {Finch: {{Sparse}} and {{Structured Array Programming}} with {{Control Flow}}},
  shorttitle = {Finch},
  author = {Ahrens, Willow and Collin, Teodoro Fields and Patel, Radha and Deeds, Kyle and Hong, Changwan and Amarasinghe, Saman},
  year = {2024},
  publisher = {arXiv},
  doi = {10.48550/ARXIV.2404.16730},
  urldate = {2025-01-14},
  abstract = {From FORTRAN to NumPy, arrays have revolutionized how we express computation. However, arrays in these, and almost all prominent systems, can only handle dense rectilinear integer grids. Real world arrays often contain underlying structure, such as sparsity, runs of repeated values, or symmetry. Support for structured data is fragmented and incomplete. Existing frameworks limit the array structures and program control flow they support to better simplify the problem.  In this work, we propose a new programming language, Finch, which supports both flexible control flow and diverse data structures. Finch facilitates a programming model which resolves the challenges of computing over structured arrays by combining control flow and data structures into a common representation where they can be co-optimized. Finch automatically specializes control flow to data so that performance engineers can focus on experimenting with many algorithms. Finch supports a familiar programming language of loops, statements, ifs, breaks, etc., over a wide variety of array structures, such as sparsity, run-length-encoding, symmetry, triangles, padding, or blocks. Finch reliably utilizes the key properties of structure, such as structural zeros, repeated values, or clustered non-zeros. We show that this leads to dramatic speedups in operations such as SpMV and SpGEMM, image processing, graph analytics, and a high-level tensor operator fusion interface.},
  copyright = {arXiv.org perpetual, non-exclusive license},
  keywords = {Computer Science - Mathematical Software,FOS: Computer and information sciences,Mathematical Software (cs.MS)},
  file = {/Users/jumerckx/Zotero/storage/NN6G4QU2/Ahrens et al. - 2024 - Finch Sparse and Structured Array Programming with Control Flow.pdf;/Users/jumerckx/Zotero/storage/J2BEFN73/2404.html;/Users/jumerckx/Zotero/storage/MXKBPY9P/2404.html}
}

@inproceedings{ahrensLoopletsLanguageStructured2023,
  title = {Looplets: A Language for Structured Coiteration},
  booktitle = {Proceedings of the 21st {{ACM}}/{{IEEE}} International Symposium on Code Generation and Optimization},
  author = {Ahrens, Willow and Donenfeld, Daniel and Kjolstad, Fredrik and Amarasinghe, Saman},
  year = {2023},
  series = {CGO '23},
  pages = {41--54},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3579990.3580020},
  abstract = {Real world arrays often contain underlying structure, such as sparsity, runs of repeated values, or symmetry. Specializing for structure yields significant speedups. But automatically generating efficient code for structured data is challenging, especially when arrays with different structure interact. We show how to abstract over array structures so that the compiler can generate code to coiterate over any combination of them. Our technique enables new array formats (such as 1DVBL for irregular clustered sparsity), new iteration strategies (such as galloping intersections), and new operations over structured data (such as concatenation or convolution).},
  isbn = {979-8-4007-0101-6},
  keywords = {Array,Coiteration,Compressed,Sparse,Tensor}
}

@article{bahmannPerfectReconstructabilityControl2015,
  title = {Perfect {{Reconstructability}} of {{Control Flow}} from {{Demand Dependence Graphs}}},
  author = {Bahmann, Helge and Reissmann, Nico and Jahre, Magnus and Meyer, Jan Christian},
  year = {2015},
  month = jan,
  journal = {ACM Transactions on Architecture and Code Optimization},
  volume = {11},
  number = {4},
  pages = {1--25},
  issn = {1544-3566, 1544-3973},
  doi = {10.1145/2693261},
  urldate = {2024-07-01},
  abstract = {Demand-based dependence graphs (DDGs), such as the (Regionalized) Value State Dependence Graph ((R)VSDG), are intermediate representations (IRs) well suited for a wide range of program transformations. They explicitly model the flow of data and state, and only implicitly represent a restricted form of control flow. These features make DDGs especially suitable for automatic parallelization and vectorization, but cannot be leveraged by practical compilers without efficient construction and destruction algorithms. Construction algorithms remodel the arbitrarily complex control flow of a procedure to make it amenable to DDG representation, whereas destruction algorithms reestablish control flow for generating efficient object code. Existing literature presents solutions to both problems, but these impose structural constraints on the generatable control flow, and omit qualitative evaluation.                            The key contribution of this article is to show that there is no intrinsic structural limitation in the control flow directly extractable from RVSDGs. This fundamental result originates from an interpretation of loop repetition and decision predicates as computed continuations, leading to the introduction of the               predicate continuation               normal form. We provide an algorithm for constructing RVSDGs in predicate continuation form, and propose a novel destruction algorithm for RVSDGs in this form. Our destruction algorithm can generate arbitrarily complex control flow; we show this by proving that the original CFG an RVSDG was derived from can, apart from overspecific detail, be reconstructed perfectly. Additionally, we prove termination and correctness of these algorithms. Furthermore, we empirically evaluate the performance, the representational overhead at compile time, and the reduction in branch instructions compared to existing solutions. In contrast to previous work, our algorithms impose no additional overhead on the control flow of the produced object code. To our knowledge, this is the first scheme that allows the original control flow of a procedure to be recovered from a DDG representation.},
  langid = {english},
  file = {/Users/jumerckx/Zotero/storage/E357QGVY/Bahmann et al. - 2015 - Perfect Reconstructability of Control Flow from De.pdf}
}

@article{chandrakananandiRewriteRuleInference2021,
  title = {Rewrite Rule Inference Using Equality Saturation},
  author = {{Chandrakana Nandi} and Nandi, Chandrakana and {Max Willsey} and Willsey, Max and {Amy Zhu} and Zhu, Amy Y. X. and {Yisu Remy Wang} and Wang, Yisu Remy and {Brett Saiki} and Saiki, Brett and {Adam Anderson} and Anderson, Adam and {Adriana Schulz} and Schulz, Adriana and {Dan Grossman} and Grossman, Dan and {Zachary Tatlock} and Tatlock, Zachary},
  year = {2021},
  month = oct,
  journal = {Proc. ACM Program. Lang.},
  volume = {5},
  pages = {1--28},
  doi = {10.1145/3485496},
  abstract = {Many compilers, synthesizers, and theorem provers rely on rewrite rules to simplify expressions or prove equivalences. Developing rewrite rules can be difficult: rules may be subtly incorrect, profitable rules are easy to miss, and rulesets must be rechecked or extended whenever semantics are tweaked. Large rulesets can also be challenging to apply: redundant rules slow down rule-based search and frustrate debugging.  This paper explores how equality saturation, a promising technique that uses e-graphs to apply rewrite rules, can also be used to infer rewrite rules. E-graphs can compactly represent the exponentially large sets of enumerated terms and potential rewrite rules. We show that equality saturation efficiently shrinks both sets, leading to faster synthesis of smaller, more general rulesets.  We prototyped these strategies in a tool dubbed Ruler. Compared to a similar tool built on CVC4, Ruler synthesizes 5.8{\texttimes} smaller rulesets 25{\texttimes} faster without compromising on proving power. In an end-to-end case study, we show Ruler-synthesized rules which perform as well as those crafted by domain experts, and addressed a longstanding issue in a popular open source tool.},
  keywords = {equality saturation,theory},
  annotation = {ARXIV\_ID: 2108.10436\\
MAG ID: 3207460439\\
S2ID: 55b91d4be522c2726ec2852febbec5537081672f},
  file = {/Users/jumerckx/Zotero/storage/G6STCYUS/Chandrakana Nandi et al. - 2021 - Rewrite rule inference using equality saturation.pdf}
}

@article{cheliMetatheoryjlFastElegant2021,
  title = {Metatheory.Jl: {{Fast}} and {{Elegant Algebraic Computation}} in {{Julia}} with {{Extensible Equality Saturation}}},
  author = {Cheli, Alessandro},
  year = {2021},
  journal = {Journal of Open Source Software},
  volume = {6},
  number = {59},
  pages = {3078},
  doi = {10.21105/joss.03078},
  abstract = {We introduce Metatheory.jl: a lightweight and performant general purpose symbolics and metaprogramming framework meant to simplify the act of writing complex Julia metaprograms and to significantly enhance Julia with a native term rewriting system, based on state-of-the-art equality saturation techniques, and a dynamic first class Abstract Syntax Tree (AST) pattern matching system that is dynamically composable in an algebraic fashion, taking full advantage of the language's powerful reflection capabilities. Our contribution allows to perform general purpose symbolic mathematics, manipulation, optimization, synthesis or analysis of syntactically valid Julia expressions with a clean and concise programming interface, both during compilation or execution of programs.},
  keywords = {equality saturation,theory},
  annotation = {ARXIV\_ID: 2102.07888\\
MAG ID: 3145384168\\
S2ID: 46b544baa83079f1a59bdafc13e63a2583e27f57},
  file = {/Users/jumerckx/Zotero/storage/7BJ2Q4KF/Cheli - 2021 - Metatheory.jl Fast and Elegant Algebraic Computation in Julia with Extensible Equality Saturation.pdf}
}

@misc{fallinAegraphsAcyclicEgraphs2023,
  title = {Aegraphs: {{Acyclic}} e-Graphs for Efficient Optimization in a Production Compiler},
  author = {Fallin, Chris},
  year = {2023},
  howpublished = {EGRAPHS 2023 keynote},
  keywords = {application,equality saturation,theory}
}

@article{gowdaHighperformanceSymbolicnumericsMultiple2022,
  title = {High-Performance Symbolic-Numerics via Multiple Dispatch},
  author = {Gowda, Shashi and Ma, Yingbo and Cheli, Alessandro and Gw{\'o}{\'z}zd{\'z}, Maja and Shah, Viral B. and Edelman, Alan and Rackauckas, Christopher},
  year = {2022},
  month = jan,
  journal = {ACM Communications in Computer Algebra},
  volume = {55},
  number = {3},
  pages = {92--96},
  issn = {1932-2240},
  doi = {10.1145/3511528.3511535},
  urldate = {2024-10-10},
  abstract = {As mathematical computing becomes more democratized in high-level languages, high-performance symbolic-numeric systems are necessary for domain scientists and engineers to get the best performance out of their machine without deep knowledge of code optimization. Naturally, users need different term types either to have different algebraic properties for them, or to use efficient data structures. To this end, we developed Symbolics.jl, an extendable symbolic system which uses dynamic multiple dispatch to change behavior depending on the domain needs. In this work we detail an underlying abstract term interface which allows for speed without sacrificing generality. We show that by formalizing a generic API on actions independent of implementation, we can retroactively add optimized data structures to our system without changing the pre-existing term rewriters. We showcase how this can be used to optimize term construction and give a 113x acceleration on general symbolic transformations. Further, we show that such a generic API allows for complementary term-rewriting implementations. Exploiting this feature, we demonstrate the ability to swap between classical term-rewriting simplifiers and e-graph-based term-rewriting simplifiers. We illustrate how this symbolic system improves numerical computing tasks by showcasing an e-graph ruleset which minimizes the number of CPU cycles during expression evaluation, and demonstrate how it simplifies a real-world reaction-network simulation to halve the runtime. Additionally, we show a reaction-diffusion partial differential equation solver which is able to be automatically converted into symbolic expressions via multiple dispatch tracing, which is subsequently accelerated and parallelized to give a 157x simulation speedup. Together, this presents Symbolics.jl as a next-generation symbolic-numeric computing environment geared towards modeling and simulation.},
  keywords = {application,equality saturation},
  file = {/Users/jumerckx/Zotero/storage/8B5CMKWM/Gowda et al. - 2022 - High-performance symbolic-numerics via multiple dispatch.pdf}
}

@misc{heImprovingTermExtraction2017,
  title = {Improving {{Term Extraction}} with {{Acyclic Constraints}}},
  author = {He, Mike and Dong, Haichen and Malik, Sharad and Gupta, Aarti},
  year = {2017},
  abstract = {Term extraction is a crucial workload in egg for determining the desired terms to be extracted. Some prior works have formulated term extraction as integer linear programming (ILP) problems in order to cope with common sub-expressions for optimality that could not be handled by greedy algorithms. Although ILP-based extraction algorithms ensure optimality, these formulations offload a topological sorting problem to the ILP solver to avoid extracting cyclic terms, which does not scale well with the complexity of cycles in the e-graph. Instead of enforcing topological orders with constraints, we propose to explicitly identify the cycles and encode them to Acyclic constraints. This approach enables us to formulate term extraction problems in terms of Weighted Partial MAXSAT problems and improve the solving speed of the current ILP formulation. Our evaluation of term extraction for equality saturation on real-world Deep Learning (DL) workloads shows that using the improved formulation yields up to {$\sim$}3x speed-up on the total extraction time compared with using the state-of-the-art ILP encoding.},
  langid = {english},
  keywords = {equality saturation,theory},
  file = {/Users/jumerckx/Zotero/storage/J8NREGXN/He et al. - 2017 - Improving Term Extraction with Acyclic Constraints.pdf}
}

@inproceedings{kourtaCaviarEgraphBased2022,
  title = {Caviar: An e-Graph Based {{TRS}} for Automatic Code Optimization},
  shorttitle = {Caviar},
  booktitle = {Proceedings of the 31st {{ACM SIGPLAN International Conference}} on {{Compiler Construction}}},
  author = {Kourta, Smail and Namani, Adel Abderahmane and {Benbouzid-Si Tayeb}, Fatima and Hazelwood, Kim and Cummins, Chris and Leather, Hugh and Baghdadi, Riyadh},
  year = {2022},
  month = mar,
  series = {{{CC}} 2022},
  pages = {54--64},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3497776.3517781},
  urldate = {2024-10-28},
  abstract = {Term Rewriting Systems (TRSs) are used in compilers to simplify and prove expressions. State-of-the-art TRSs in compilers use a greedy algorithm that applies a set of rewriting rules in a predefined order (where some of the rules are not axiomatic). This leads to a loss of the ability to simplify certain expressions. E-graphs and equality saturation sidestep this issue by representing the different equivalent expressions in a compact manner from which the optimal expression can be extracted. While an e-graph-based TRS can be more powerful than a TRS that uses a greedy algorithm, it is slower because expressions may have a large or sometimes infinite number of equivalent expressions. Accelerating e-graph construction is crucial for making the use of e-graphs practical in compilers. In this paper, we present Caviar, an e-graph-based TRS for proving expressions within compilers. The main advantage of Caviar is its speed. It can prove expressions much faster than base e-graph TRSs. It relies on three techniques: 1) a technique that stops e-graphs from growing when the goal is reached, called Iteration Level Check; 2) a mechanism that balances exploration and exploitation in the equality saturation algorithm, called Pulsing Caviar; 3) a technique to stop e-graph construction before reaching saturation when a non-provable pattern is detected, called Non-Provable Patterns Detection (NPPD). We evaluate caviar on Halide, an optimizing compiler that relies on a greedy-algorithm-based TRS to simplify and prove its expressions. The proposed techniques allow Caviar to accelerate e-graph expansion for the task of proving expressions. They also allow Caviar to prove expressions that Halide's TRS cannot prove while being only 0.68x slower. Caviar is publicly available at: \&lt;a\&gt;https://github.com/caviar-trs/caviar\&lt;/a\&gt;.},
  isbn = {978-1-4503-9183-2},
  keywords = {application,equality saturation,verification},
  file = {/Users/jumerckx/Zotero/storage/59CDFKZF/Kourta et al. - 2022 - Caviar an e-graph based TRS for automatic code optimization.pdf}
}

@inproceedings{matsumuraSymbolicEmulatorShuffle2023,
  title = {A {{Symbolic Emulator}} for {{Shuffle Synthesis}} on the {{NVIDIA PTX Code}}},
  booktitle = {Proceedings of the 32nd {{ACM SIGPLAN International Conference}} on {{Compiler Construction}}},
  author = {Matsumura, Kazuaki and De Gonzalo, Simon Garcia and Pe{\~n}a, Antonio J.},
  year = {2023},
  month = feb,
  series = {{{CC}} 2023},
  pages = {110--121},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/3578360.3580253},
  urldate = {2024-10-28},
  abstract = {Various kinds of applications take advantage of GPUs through automation tools that attempt to automatically exploit the available performance of the GPU's parallel architecture. Directive-based programming models, such as OpenACC, are one such method that easily enables parallel computing by just adhering code annotations to code loops. Such abstract models, however, often prevent programmers from making additional low-level optimizations to take advantage of the advanced architectural features of GPUs because the actual generated computation is hidden from the application developer. This paper describes and implements a novel flexible optimization technique that operates by inserting a code emulator phase to the tail-end of the compilation pipeline. Our tool emulates the generated code using symbolic analysis by substituting dynamic information and thus allowing for further low-level code optimizations to be applied. We implement our tool to support both CUDA and OpenACC directives as the frontend of the compilation pipeline, thus enabling low-level GPU optimizations for OpenACC that were not previously possible. We demonstrate the capabilities of our tool by automating warp-level shuffle instructions that are difficult to use by even advanced GPU programmers. Lastly, evaluating our tool with a benchmark suite and complex application code, we provide a detailed study to assess the benefits of shuffle instructions across four generations of GPU architectures.},
  isbn = {979-8-4007-0088-0},
  keywords = {application,equality saturation,hardware},
  file = {/Users/jumerckx/Zotero/storage/GEZS39U3/Matsumura et al. - 2023 - A Symbolic Emulator for Shuffle Synthesis on the NVIDIA PTX Code.pdf}
}

@misc{optir2022,
  title = {Optir},
  author = {Sharp, Jamey},
  year = {2022},
  publisher = {GitHub},
  keywords = {application,equality saturation}
}

@inproceedings{panchekhaAutomaticallyImprovingAccuracy2015,
  title = {Automatically Improving Accuracy for Floating Point Expressions},
  booktitle = {Proceedings of the 36th {{ACM SIGPLAN Conference}} on {{Programming Language Design}} and {{Implementation}}},
  author = {Panchekha, Pavel and {Sanchez-Stern}, Alex and Wilcox, James R. and Tatlock, Zachary},
  year = {2015},
  month = jun,
  pages = {1--11},
  publisher = {ACM},
  address = {Portland OR USA},
  doi = {10.1145/2737924.2737959},
  urldate = {2025-01-14},
  isbn = {978-1-4503-3468-6},
  langid = {english},
  keywords = {application,equality saturation},
  file = {/Users/jumerckx/Zotero/storage/6RBWCL4U/Pavel Panchekha et al. - 2015 - Automatically improving accuracy for floating point expressions.pdf}
}

@article{reissmannRVSDGIntermediateRepresentation2020,
  title = {{{RVSDG}}: {{An Intermediate Representation}} for {{Optimizing Compilers}}},
  shorttitle = {{{RVSDG}}},
  author = {Reissmann, Nico and Meyer, Jan Christian and Bahmann, Helge and Sj{\"a}lander, Magnus},
  year = {2020},
  month = nov,
  journal = {ACM Transactions on Embedded Computing Systems},
  volume = {19},
  number = {6},
  eprint = {1912.05036},
  primaryclass = {cs},
  pages = {1--28},
  issn = {1539-9087, 1558-3465},
  doi = {10.1145/3391902},
  urldate = {2024-07-01},
  abstract = {Intermediate Representations (IRs) are central to optimizing compilers as the way the program is represented may enhance or limit analyses and transformations. Suitable IRs focus on exposing the most relevant information and establish invariants that different compiler passes can rely on. While control-flow centric IRs appear to be a natural fit for imperative programming languages, analyses required by compilers have increasingly shifted to understand data dependencies and work at multiple abstraction layers at the same time. This is partially evidenced in recent developments such as the MLIR proposed by Google. However, rigorous use of data flow centric IRs in general purpose compilers has not been evaluated for feasibility and usability as previous works provide no practical implementations. We present the Regionalized Value State Dependence Graph (RVSDG) IR for optimizing compilers. The RVSDG is a data flow centric IR where nodes represent computations, edges represent computational dependencies, and regions capture the hierarchical structure of programs. It represents programs in demand-dependence form, implicitly supports structured control flow, and models entire programs within a single IR. We provide a complete specification of the RVSDG, construction and destruction methods, as well as exemplify its utility by presenting Dead Node and Common Node Elimination optimizations. We implemented a prototype compiler and evaluate it in terms of performance, code size, compilation time, and representational overhead. Our results indicate that the RVSDG can serve as a competitive IR in optimizing compilers while reducing complexity.},
  archiveprefix = {arXiv},
  keywords = {Computer Science - Programming Languages},
  file = {/Users/jumerckx/Zotero/storage/PVX3VKTT/Reissmann et al. - 2020 - RVSDG An Intermediate Representation for Optimizi.pdf;/Users/jumerckx/Zotero/storage/BR9AGDCG/1912.html;/Users/jumerckx/Zotero/storage/KJ5HSZZG/1912.html}
}

@inproceedings{smithPureTensorProgram2021,
  title = {Pure Tensor Program Rewriting via Access Patterns (Representation Pearl)},
  booktitle = {Proceedings of the 5th {{ACM SIGPLAN International Symposium}} on {{Machine Programming}}},
  author = {Smith, Gus Henry and Liu, Andrew and Lyubomirsky, Steven and Davidson, Scott and McMahan, Joseph and Taylor, Michael and Ceze, Luis and Tatlock, Zachary},
  year = {2021},
  month = jun,
  pages = {21--31},
  publisher = {ACM},
  address = {Virtual Canada},
  doi = {10.1145/3460945.3464953},
  urldate = {2025-01-14},
  isbn = {978-1-4503-8467-4},
  langid = {english},
  keywords = {application,Computer Science - Programming Languages,equality saturation,tensor compiler},
  file = {/Users/jumerckx/Zotero/storage/4IJNGHAI/Smith et al. - 2021 - Pure tensor program rewriting via access patterns (representation pearl).pdf}
}

@inproceedings{steppEqualityBasedTranslationValidator2011,
  title = {Equality-{{Based Translation Validator}} for {{LLVM}}},
  booktitle = {Computer {{Aided Verification}}},
  author = {Stepp, Michael and Tate, Ross and Lerner, Sorin},
  editor = {Gopalakrishnan, Ganesh and Qadeer, Shaz},
  year = {2011},
  pages = {737--742},
  publisher = {Springer},
  address = {Berlin, Heidelberg},
  doi = {10.1007/978-3-642-22110-1_59},
  abstract = {We updated our Peggy tool, previously presented in [6], to perform translation validation for the LLVM compiler using a technique called Equality Saturation. We present the tool, and illustrate its effectiveness at doing translation validation on SPEC 2006 benchmarks.},
  isbn = {978-3-642-22110-1},
  langid = {english},
  keywords = {application,Compiler Optimization,Congruence Closure,equality saturation,Equality Saturation,Original Code,Translation Validation,verification},
  file = {/Users/jumerckx/Zotero/storage/JICNVZE6/Stepp et al. - 2011 - Equality-Based Translation Validator for LLVM.pdf}
}

@misc{sunEgraphsCircuitsOptimal2024,
  title = {E-Graphs as Circuits, and Optimal Extraction via Treewidth},
  author = {Sun, Glenn and Zhang, Yihong and Ni, Haobin},
  year = {2024},
  eprint = {2408.17042},
  primaryclass = {cs.DS},
  abstract = {We solve the optimal extraction problem for e-graphs by first showing a connection between e-graphs and cyclic monotone Boolean circuits, then solving the weighted satisfiability problem for such circuits. The solution is a parameterized algorithm based on treewidth. Additionally, we show how the circuit view of e-graphs allows us to apply simplification techniques that are not possible when operating directly on e-graphs. While the core parameterized algorithm may be adapted to work directly on e-graphs, the simplification results show why the circuit view is helpful.},
  archiveprefix = {arXiv},
  keywords = {equality saturation,extraction,theory},
  file = {/Users/jumerckx/Zotero/storage/S3QUTQZA/Sun et al. - 2024 - E-graphs as circuits, and optimal extraction via treewidth.pdf}
}

@inproceedings{tateEqualitySaturationNew2009,
  title = {Equality Saturation: A New Approach to Optimization},
  shorttitle = {Equality Saturation},
  booktitle = {Proceedings of the 36th Annual {{ACM SIGPLAN-SIGACT}} Symposium on {{Principles}} of Programming Languages},
  author = {Tate, Ross and Stepp, Michael and Tatlock, Zachary and Lerner, Sorin},
  year = {2009},
  month = jan,
  series = {{{POPL}} '09},
  pages = {264--276},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  doi = {10.1145/1480881.1480915},
  urldate = {2024-10-08},
  abstract = {Optimizations in a traditional compiler are applied sequentially, with each optimization destructively modifying the program to produce a transformed program that is then passed to the next optimization. We present a new approach for structuring the optimization phase of a compiler. In our approach, optimizations take the form of equality analyses that add equality information to a common intermediate representation. The optimizer works by repeatedly applying these analyses to infer equivalences between program fragments, thus saturating the intermediate representation with equalities. Once saturated, the intermediate representation encodes multiple optimized versions of the input program. At this point, a profitability heuristic picks the final optimized program from the various programs represented in the saturated representation. Our proposed way of structuring optimizers has a variety of benefits over previous approaches: our approach obviates the need to worry about optimization ordering, enables the use of a global optimization heuristic that selects among fully optimized programs, and can be used to perform translation validation, even on compilers other than our own. We present our approach, formalize it, and describe our choice of intermediate representation. We also present experimental results showing that our approach is practical in terms of time and space overhead, is effective at discovering intricate optimization opportunities, and is effective at performing translation validation for a realistic optimizer.},
  isbn = {978-1-60558-379-2},
  keywords = {application,equality saturation,theory},
  file = {/Users/jumerckx/Zotero/storage/T28X4HK5/Tate et al. - 2009 - Equality saturation a new approach to optimization.pdf}
}

@inproceedings{ustunIMpressLargeInteger2022,
  title = {{{IMpress}}: {{Large Integer Multiplication Expression Rewriting}} for {{FPGA HLS}}},
  shorttitle = {{{IMpress}}},
  booktitle = {2022 {{IEEE}} 30th {{Annual International Symposium}} on {{Field-Programmable Custom Computing Machines}} ({{FCCM}})},
  author = {Ustun, Ecenur and San, Ismail and Yin, Jiaqi and Yu, Cunxi and Zhang, Zhiru},
  year = {2022},
  month = may,
  pages = {1--10},
  publisher = {IEEE},
  address = {New York City, NY, USA},
  doi = {10.1109/FCCM53951.2022.9786123},
  urldate = {2025-01-14},
  copyright = {https://doi.org/10.15223/policy-029},
  isbn = {978-1-6654-8332-2},
  keywords = {application,equality saturation,hardware},
  file = {/Users/jumerckx/Zotero/storage/GH96SCJB/Ecenur Ustun et al. - 2022 - IMpress Large Integer Multiplication Expression Rewriting for FPGA HLS.pdf}
}

@inproceedings{vanhattumVectorizationDigitalSignal2021,
  title = {Vectorization for Digital Signal Processors via Equality Saturation},
  booktitle = {Proceedings of the 26th {{ACM International Conference}} on {{Architectural Support}} for {{Programming Languages}} and {{Operating Systems}}},
  author = {VanHattum, Alexa and Nigam, Rachit and Lee, Vincent T. and Bornholt, James and Sampson, Adrian},
  year = {2021},
  month = apr,
  pages = {874--886},
  publisher = {ACM},
  address = {Virtual USA},
  doi = {10.1145/3445814.3446707},
  urldate = {2025-01-14},
  isbn = {978-1-4503-8317-2},
  langid = {english},
  keywords = {application,equality saturation,hardware},
  file = {/Users/jumerckx/Zotero/storage/EZUXGCNH/Alexa VanHattum et al. - 2021 - Vectorization for digital signal processors via equality saturation.pdf}
}

@article{wangSPORESSumproductOptimization2020,
  title = {{{SPORES}}: Sum-Product Optimization via Relational Equality Saturation for Large Scale Linear Algebra},
  shorttitle = {{{SPORES}}},
  author = {Wang, Yisu Remy and Hutchison, Shana and Leang, Jonathan and Howe, Bill and Suciu, Dan},
  year = {2020},
  month = aug,
  journal = {Proceedings of the VLDB Endowment},
  volume = {13},
  number = {12},
  pages = {1919--1932},
  issn = {2150-8097},
  doi = {10.14778/3407790.3407799},
  urldate = {2025-01-14},
  abstract = {Machine learning algorithms are commonly specified in linear algebra (LA). LA expressions can be rewritten into more efficient forms, by taking advantage of input properties such as               sparsity               , as well as program properties such as               common subexpressions               and               fusible operators.               The complex interaction among these properties' impact on the execution cost poses a challenge to optimizing compilers. Existing compilers resort to intricate heuristics that complicate the codebase and add maintenance cost, but fail to search through the large space of equivalent LA expressions to find the cheapest one. We introduce a general optimization technique for LA expressions, by converting the LA expressions into Relational Algebra (RA) expressions, optimizing the latter, then converting the result back to (optimized) LA expressions. The rewrite rules we design in this approach are complete, meaning that any equivalent LA expression is covered in the search space. The challenge is the major size of the search space, and we address this by adopting and extending a technique used in compilers, called               equality saturation.               Our optimizer, SPORES, uses rule sampling to quickly cover vast portions of the search space; it then uses a constraint solver to extract the optimal plan from the covered space, or alternatively uses a greedy algorithm to shorten compile time. We integrate SPORES into SystemML and validate it empirically across a spectrum of machine learning tasks; SPORES can derive all existing hand-coded optimizations in SystemML, and perform new optimizations that lead to up to 10X speedup.},
  langid = {english},
  keywords = {application,equality saturation},
  file = {/Users/jumerckx/Zotero/storage/6VYJVJ2R/Yisu Remy Wang et al. - 2020 - SPORES sum-product optimization via relational equality saturation for large scale linear algebra.pdf}
}

@article{willseyEggFastExtensible2021,
  title = {Egg: {{Fast}} and Extensible Equality Saturation},
  shorttitle = {Egg},
  author = {Willsey, Max and Nandi, Chandrakana and Wang, Yisu Remy and Flatt, Oliver and Tatlock, Zachary and Panchekha, Pavel},
  year = {2021},
  month = jan,
  journal = {Proceedings of the ACM on Programming Languages},
  volume = {5},
  number = {POPL},
  pages = {1--29},
  issn = {2475-1421},
  doi = {10.1145/3434304},
  urldate = {2024-02-26},
  abstract = {An e-graph efficiently represents a congruence relation over many expressions. Although they were originally developed in the late 1970s for use in automated theorem provers, a more recent technique known as equality saturation repurposes e-graphs to implement state-of-the-art, rewrite-driven compiler optimizations and program synthesizers. However, e-graphs remain unspecialized for this newer use case. Equality saturation workloads exhibit distinct characteristics and often require ad-hoc e-graph extensions to incorporate transformations beyond purely syntactic rewrites.             This work contributes two techniques that make e-graphs fast and extensible, specializing them to equality saturation. A new amortized invariant restoration technique called rebuilding takes advantage of equality saturation's distinct workload, providing asymptotic speedups over current techniques in practice. A general mechanism called e-class analyses integrates domain-specific analyses into the e-graph, reducing the need for ad hoc manipulation.             We implemented these techniques in a new open-source library called egg. Our case studies on three previously published applications of equality saturation highlight how egg's performance and flexibility enable state-of-the-art results across diverse domains.},
  langid = {english},
  keywords = {egraphs,equality saturation,theory},
  file = {/Users/jumerckx/Zotero/storage/T23525DR/Willsey et al. - 2021 - egg Fast and extensible equality saturation.pdf}
}

@misc{y.wangEGraphsVSAsTree2022,
  title = {E-{{Graphs}}, {{VSAs}}, and {{Tree Automata}}: A {{Rosetta Stone}}},
  author = {{Y. Wang} and {James Koppel} and {Altan Haan} and {Josh Pollock}},
  year = {2022},
  abstract = {Many tasks in programming languages involve representing and manipulating sets of programs. In program synthesis, the goal is to find a program satisfying a given specification from a set of programs possibly generated by a given grammar. In program optimization, the goal is to find an efficient program from the set of programs equivalent to the input. Programming languages research has considered various abstractions to represent sets of programs. Two examples are the version space algebra (VSA) [Lau et al. 2003; Mitchell 1982], popularized by FlashFill [Gulwani 2011] for enumerative program synthesis, and the e-graph [Nelson 1980; Nieuwenhuis and Oliveras 2005] that lies at the heart of an array of new program optimizers [Willsey et al. 2021]. In this talk we show that VSAs and e-graphs are but special cases of the well-studied finite-state (tree) automata from formal language theory. This new perspective allows us to place VSAs and e-graphs on a firm theoretical foundation, and also enables us to leverage powerful tools from formal language theory to perform tasks in programming languages. In the converse, bridging the concepts can also contribute to tree automata research with techniques developed for e-graphs and VSAs.},
  keywords = {equality saturation,extraction,theory},
  annotation = {S2ID: be732ff9716f6f22ed1fdbbc0199c10dad6c9130}
}

