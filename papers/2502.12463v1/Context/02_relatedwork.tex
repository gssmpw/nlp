\section{Related Work}

\subsection{Penetration Depth Computation}

The computation of penetration depth often utilizes the Minkowski sum, a well-regarded algorithm documented in Dobkin et al.'s work~\cite{dobkin1993computing}.
This method shows high efficacy for convex shapes, where the simplicity of the objects allows for accurate and computationally efficient penetration depth calculations~\cite{dobkin1993computing,varadhan2004accurate,hachenberger2009exact}.
However, applying this algorithm to concave shapes significantly increases computational complexity.  
As a result, research has focused on developing methods to approximate penetration depth more efficiently for these shapes~\cite{cameron1997enhancing,bergen1999fast,lien2010simple,je2012polydepth}.  

Beyond the Minkowski sum, other methods have been explored, including techniques such as utilizing distance fields or the Hausdorff distance for penetration depth calculations~\cite{fisher2001fast,sud2006fast,SIG09HIST}.

Tang et al.\cite{SIG09HIST} devised an efficient algorithm for calculating the Hausdorff distance between two objects within a given error bound.
They also demonstrated that the proposed algorithm can accelerate penetration depth computation by focusing on the Hausdorff distance in overlapping regions of objects.
Building upon Tang et al.'s method, Zheng et al.\cite{zheng2022economic} improved performance using a BVH-based framework with a four-point strategy.
This method has achieved a performance improvement of up to 20 times compared to Tang et al.'s technique~\cite{SIG09HIST}.
\revision{A common feature of these works, known as the culling-based method, is computing bounds for the Hausdorff distance and reducing the search space.}

\revision{Although culling-based methods have demonstrated significant performance gains, they face challenges in leveraging parallel hardware.  
Updating and sharing bounds require synchronization, which is not well-suited for massively parallel processing architectures such as GPUs.}

\revision{In this work, we propose a GPU-based penetration depth algorithm that specifically accelerates two key processes using RT core technology:  
(1) detecting the overlapping volume and (2) calculating the Hausdorff distance.  
To highlight the effectiveness of our approach, we also implemented a CPU-based penetration depth algorithm based on Tang et al.~\cite{SIG09HIST} and Zheng et al.~\cite{zheng2022economic} for performance comparison.}

%In this work, we propose a GPU-based penetration depth algorithm, specifically accelerating two key processes with RT core technology:  
%first, detecting the overlapping volume; and second, calculating the Hausdorff distance.  
%To highlight our method's effectiveness, we also implemented a CPU-based penetration depth algorithm based on Tang et al.~\cite{SIG09HIST} and Zheng et al.~\cite{zheng2022economic} for performance comparison.  

%utilize a Hausdorff distance-based method for penetration depth calculation, accelerating two key processes with RT core technology: 

%A notable development in this area is the work of Tang et al., who devised algorithms for the rapid calculation of the Hausdorff distance between two objects~\cite{SIG09HIST}.
%Their approach is geared towards efficient penetration depth calculation by focusing on the Hausdorff distance in overlapping object regions.


%One of the algorithms for calculating penetration depth is the Minkowski sum.\cite{dobkin1993computing} The Minkowski sum is useful to compute penetration depth between two convex objects because they have a simple shape so the Minkowski sum can calculate accurate penetration depth with low computational complexity~\cite{dobkin1993computing,varadhan2004accurate,hachenberger2009exact}.
%However, applying the Minkowski sum in cases involving concave objects is challenging due to higher computational complexity. As a result, prior research has focused on quickly computing an approximate penetration depth in these scenarios~\cite{cameron1997enhancing,bergen1999fast,lien2010simple,je2012polydepth}.

%Instead of the Minkowski sum method, there have also been attempts to calculate the penetration depth based on the distance field or the vertices that make up the objects~\cite{fisher2001fast,sud2006fast,SIG09HIST}. Tang et al.~\cite{SIG09HIST} proposed the algorithms that compute the Hausdorff distance between two objects quickly and showed that can be computed penetration depth to fast by calculating the Hausdorff distance for the overlapping area of two objects.

%In this paper, the proposed method is based on Tang's methods~\cite{SIG09HIST}, and then partially divided into steps detecting overlapping volume step and the Hausdorff distance step. These two steps accelerated with RT core.

\subsection{Ray-Tracing Core-Based Acceleration}

\revision{Recent advancements in GPU technology have led to the integration of dedicated ray-tracing cores (RT cores), enabling hardware-accelerated ray tracing.
These cores optimize intersection checks between rays and objects, allowing for efficient ray-bounding box and ray-triangle intersection tests.
To utilize RT cores, various frameworks such as DXR, OptiX~\cite{parker2010optix}, and Vulkan have been developed.
RT cores primarily accelerate ray intersection tasks by efficiently traversing acceleration hierarchies.}

%The Ray-Tracing Core (RT-core) is NVIDIAâ€™s specialized hardware for accelerating ray tracing.
%Integrated into RTX GPUs like the GeForce RTX series

%\revision{Notably, OptiX~\cite{parker2010optix} is an NVIDIA-supported SDK.
%The ray-tracing core primarily facilitates two tasks: building an acceleration hierarchy and executing ray intersection tasks with traversal.}
%OptiX operates by launching a CUDA kernel and invoking a ray generation ($ray_{gen}$) shader.
%Each CUDA core thread makes requests to the ray-tracing core, which then executes appropriate shaders like intersection ($IS$), miss($miss_{hit}$), closest hit($closest$), and any hit($any_{hit}$).
%Consequently, OptiX enables access to the results of ray-primitive intersection tests.

While the core purpose of ray-tracing cores is to expedite ray tracing, recent studies have explored their application beyond this traditional scope~\cite{wald2019rtx,zhu2022rtnn,thoman2022multi,nagarajan2023rt,meneses2023accelerating,morrical2023attribute}.
Wald et al.~\cite{wald2019rtx} addressed the problem of locating points within tetrahedra using ray-tracing cores.
Zhu et al.~\cite{zhu2022rtnn} introduced a K-Nearest Neighbor (K-NN) algorithm utilizing ray-tracing cores, achieving performance improvements of 2.2 to 65.0 times compared to previous GPU-based nearest neighbor search algorithms.
Thoman et al.~\cite{thoman2022multi} employed RT cores for Room Impulse Response (RIR) simulation.
Nagarajan et al.~\cite{nagarajan2023rt} implemented RT core-based DBSCAN clustering, reporting up to 4 times higher performance enhancement.
Meneses et al.~\cite{meneses2023accelerating} proposed RT core-based Range Minimum Query (RMQ) algorithms, yielding performance up to 2.3 times faster than existing RMQ methods.

\revision{
For collision detection between objects, one of the fundamental proximity queries, researchers have explored ray-tracing approaches even before the introduction of RT-core technology.
Hermann et al.\cite{hermann2008ray} proposed ray-tracing-based collision detection methods for deformable bodies.
Youngjun et al.\cite{kim2010mesh} applied Hermann's idea to medical simulation.
Lehericey et al.\cite{lehericey2015gpu} introduced GPU ray-traced collision detection algorithms for cloth simulation.
Recently, these approaches have been extended to utilize RT cores, as demonstrated by Sui et al.\cite{sui2024hardware}, who proposed discrete and continuous collision detection algorithms using ray-tracing cores.
Unlike these works, which focus on determining when and where collisions occur, our work focuses on calculating penetration depth.
}

In line with these advancements, this study uniquely applies RT-core technology to compute penetration depth, diverging from traditional ray-tracing applications and thereby contributing a novel approach to this field.

%\subsection{Collision detection with Ray-tracing}

%\YW{There have been attempts to apply the ray tracing approaches for collision detection~\cite{hermann2008ray, kim2010mesh, lehericey2015gpu}. Hermann et al~\cite{hermann2008ray} proposed ray tracing collision detection methods for deformable bodies. Youngjun et al~\cite{kim2010mesh} apply Hermann's idea for Medical simulation. Lehericey et al~\cite{lehericey2015gpu} introduced GPU ray-traced collision detection algorithms for cloth simulation.
%However, these methods proposed deformable objects, not solid- or discrete- objects, and there is no report about the result using ray tracing core yet. Therefore, our research implements the penetration depth algorithm with ray tracing methods and reports the benefit of ray tracing core.}

%\YW{Sui et al~\cite{sui2024hardware} proposed the method for discrete and continuous collision detection with ray tracing core. They generate the ray candidate as much as the edge of the source mesh and investigate the intersections to solve discrete collision detection. And also, to solve continuous collision detection, they build sphere-swept volumes with OptiX B-Spline curves using continuous trajectory points that are pre-computed and trace the ray samely. However, their implementation only considers non-penetrating collision, and because of that reason, there need for other approaches to compute penetration cases.}

%\YW{To address this issue, our approacthe has propose the methods to find penetration surface with RT core (that called RT-PPE). Not only that, our methods report the penetration depth as computing the Hausdorff distance between the penetration surface.}

%Recently, modern GPU embedded ray tracing core for hardware accelerated ray tracing.

%To access the ray tracing core, we can use DXR, OptiX~\cite{parker2010optix}, and Vulkan.
%Above all, OptiX~\cite{parker2010optix} is NVIDIA NVIDIA-supported SDK. The ray tracing core actually works about two tasks. One is a built acceleration hierarchy, and another is ray intersection task with traversal. Therefore OptiX launches one CUDA kernel and called $ray\_gen$ shader. Each CUDA core thread requests to ray tracing core, and then ray tracing core executes a suitable shader such as $IS$, $miss\_hit$, $closest$, $any\_hit$ shader.
%Finally, we can access ray-primitive intersection test results using OptiX shader.

%While the ray tracing core is designed for accelerating ray tracing, recent research tried using the ray tracing core for other purposes~\cite{wald2019rtx,zhu2022rtnn,thoman2022multi,nagarajan2023rt,meneses2023accelerating,morrical2023attribute}.
%%Beyond ray tracing
%Wald et al~\cite{wald2019rtx} solved the point in location of tetrahedron problem using ray tracing cores.
%%RTNN
%Zhu et al~\cite{zhu2022rtnn} proposed K-NN(K-Nearest Neighbor) algorithms using ray tracing cores. They achieved a performance of 2.2-65.0 times faster than prior GPU-based nearest neighbor search algorithms.
%%RIR Simulation
%Thoman et al~\cite{thoman2022multi} utilized the RT core to RIR(Room impulse response) simulation,
%%RT-DBSCAN
%Nagarajan et al~\cite{nagarajan2023rt} implemented DBSCAN clustering with RT core and achieved performance up to 4x times.
%%RTX-RMQ
%Meneses et al~\cite{meneses2023accelerating} proposed RT core-based RMQ(Range minimum query) algorithms, and they got performance up to 2.3x than state-of-the-art RMQ algorithms.

%%
%Similar to prior research, this study is distinguished by utilizing RT-core for computing penetration depth, as opposed to conventional ray tracing problems.


