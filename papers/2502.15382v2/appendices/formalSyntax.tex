\section{Complete formal syntax} \label{app:syntax}

The figure below is the formal syntax of PVL programs supported by VeyMont, including the complete OOP fragment of PVL.

\begin{figure}[t]
\begin{adjustwidth}{-0.15\paperwidth}{-0.15\paperwidth}
\begin{minipage}{0.5\textwidth}
\begin{align*}
x, y, z &::= \textrm{field,} \quad v, u, w ::= \textrm{variable,} \quad m ::= \textrm{method,}\\
f &::= \textrm{function,} \quad C ::= \textrm{class,} \quad P ::= \textrm{predicate,} \\
T &::= \texttt{int} \mid \texttt{boolean} \mid \texttt{seq<}T\texttt{>} \mid C \mid ... \\
K &::= \texttt{requires $E$; ensures $E$;} \qquad  \\
K_H &::= \textrm{$K$ with $R, H$} \qquad K_R ::= \textrm{$K$ with $R, R$} \\
\textrm{\textbf{prog}} &::= \overline{\textrm{\textbf{decl}}} \\
\textrm{\textbf{decl}} &::= \texttt{class} \; C \; \texttt{\{} \; \overline{D_{cls}} \; \texttt{\}} 
\mid \texttt{resource} \; P\parens{\overline{T \; v}} \; = \; E\texttt{;} \\
& \mid \texttt{$K$ pure} \; T \; f \parens{\overline{T \; v}} \; \texttt{=} \; E\texttt{;} \mid \texttt{$K_H$ pure} \; T \; f_H \parens{\overline{T \; v}} \; \texttt{=} \; H\texttt{;} \\
& \mid \textrm{\textbf{chor}} \\
D_{cls} &::= \; T \; x\texttt{;} \mid K_R \; T \; m \texttt{(} \overline{T \; v} \texttt{)} \; S_m \\
E &::= v \mid r \mid F \mid E \; \texttt{+} \; E \; | \; E \; \texttt{\&\&} \; E \mid E\texttt{.}f\parens{\overline{E}} \mid ... \\
H &::= \textrm{$E$ extended with: $\texttt{$E_h$.$x$} \mid \texttt{$E_h$.$f_h$($\overline{E_h}$)}$} \mid \texttt{$F$[$E_h$]} \mid \texttt{this} \\
R &::= H \mid \texttt{Perm($H$.$x$, $H$)} \mid \texttt{$R$ ** $R$} \mid \texttt{$P$($\overline{H}$)} \\
& \mid \texttt{$H$ ==> $R$} \mid \textrm{QP} \\
S_{m} &::= \texttt{assert} \; H \texttt{;} \mid H \; \texttt{=} \; H\texttt{;} \mid \texttt{$H$.$m$($\overline{H}$)} \\
& \mid \texttt{inhale $R$;} \mid \texttt{exhale $R$;} \mid \texttt{if} \; \parens{H} \; S_m \; S_m \\
& \mid \texttt{loop\_invariant} \; R\texttt{;} \; \texttt{while} \; \parens{H} \; S_m \mid ...\\
& \mid K_R \; \texttt{par} \; \parens{T \; v \; = \; H \; \texttt{..} \; H} \; S_m 
\end{align*}
\end{minipage}%
\hfill
\begin{minipage}{0.5\textwidth}
\begin{align*}
e, a, b &::= \textrm{endpoint} \quad F, G ::= \textrm{endpoint family,} \\
\textrm{\textbf{chor}} &::= \texttt{$K_R$ choreography} \parens{\overline{T \; v}} \braces{ \; \overline{D_{\texttt{chor}}} \;} \\
D_{chor} &::= \texttt{endpoint} \; e \; \texttt{=} \; C \parens{\overline{H}} ; \\
& \mid \texttt{endpoint} \; F \brackets{v \; \texttt{:=} \; 0 \; \texttt{..} \; H} \; = \; C \parens{\overline{E}} ; \\
& \mid K_R \; \texttt{run} \; \braces{\; S_{\texttt{chor}} \;}  \\
S_{chor} &::= \texttt{if} \; \parens{H_{chor}} \; S_{chor} \; S_{chor} \mid \texttt{assert} \; R_{chor}\texttt{;} \\
& \mid \texttt{loop\_invariant $R_{chor}$; while ($H_{chor}$) $S_{chor}$} \\
& \mid \texttt{endpoint} \; \alpha\texttt{:} \; S_{ep} \\
& \mid \texttt{channel\_invariant} \; R_{chan}\texttt{;} \; \texttt{communicate} \; \alpha\texttt{:} \; H \; \texttt{->} \; \alpha\texttt{:} \; H\texttt{;} \\
S_{ep} &::= H\texttt{.}m\parens{\overline{H}} \mid \texttt{$H$ := $H$;} \\
H_{chor} &::= \parens{\kwepexpr{} \; \alpha\texttt{;} \; H} \mid H_{chor} \; \texttt{\&\&} \; H_{chor} \\ 
R_{chor} &::= \parens{\kwepexpr{} \; \alpha\texttt{;} \; R} \mid R_{chor} \; \texttt{\&\&} \; R_{chor} \mid \parens{\kwchor{} \; H} \\ % \textrm{$E_{chor}$ with $R$, extended with $\parens{\kwchor{} \; E_h}$} \\
R_{chan} &::= \textrm{$R$ extended with: $\kwmsg{} \mid \kwsender{} \mid \kwreceiver{}$} \\
r, p &::= e \mid F\brackets{E} \qquad \alpha, \beta ::= r \mid F\brackets{v \; \texttt{:=} \; E \; \texttt{..} \; E}
\end{align*}
\begin{comment}
- $F$ is not included in $r$ because we use $r$ mostly in transformation rules. Referring to individual families only happens in actual programs, so we just add it on its own to $E$
- \chor is included in $R_{chor}$ so you can use it in contracts, and not in branch/loop conditions.
\end{comment}
\end{minipage}%
\end{adjustwidth}
\caption{PVL syntax. Left: OOP fragment, right: choreographic fragment.}\label{app:fig:syntax}
\end{figure}

\paragraph{Core PVL} The syntax of PVL is shown in \cref{app:fig:syntax}, of which the left is the syntax for core OOP PVL. PVL has classes, methods, fields, and supports several built-in types, such as integers (\texttt{int}), booleans, and sequences (e.g. \texttt{seq<int>}). It supports standard statements such as \texttt{while}, \texttt{if} and variable assignment, and standard expressions such as boolean logic and arithmetic. It also supports verification primitives such as contracts with pre- and postconditions, and assertions and ownership through permission annotations. The main primitive for concurrency in \pvl{} is the \texttt{par} block. When a main thread reaches a \texttt{par} block, $N$ subthreads are spawned to execute the body of the \texttt{par} block in parallel. The main thread waits until all subthreads are finished, and then continues with the remainder of the program.

We want to highlight how expressions are defined in \cref{app:fig:syntax}. Pure expressions $E$ only depend on local variables and immutable value constructors, such as sequences and sets. Heap-dependent expressions $H$ are a superset of $E$, that can also refer to fields of objects. Resource expressions ($R$) are a superset of $H$, and include permissions using the \texttt{Perm} keyword, as well as the separating conjunction operator \texttt{**} to compose resources. These different kinds of expressions give rise to variations of several other nodes: pure contracts ($K$), contracts that only inspect the heap and not modify it ($K_H$) and contracts that require and return resources ($K_R$), pure functions ($f$) and functions that read the heap ($f_H$). 

\paragraph{Choreography DSL in PVL} On the right of \cref{app:fig:syntax} is the choreographic fragment of PVL. A choreography has zero or more parameters, and defines one or more endpoint or endpoint families. Endpoint $e$ are singular endpoints, defined to have a name and instructions on how it should be instantiated with a given constructor. Endpoint families extend this notion with an extra size parameter that indicates the size of the endpoint family at runtime. Where a singular endpoint is represented at run-time with an instance of the given class $C$, an endpoint family is represented with an immutable sequence of such instances. Finally, a choreography also contains a \kwrun{} declaration, which is the main body of the choreography and contains a sequence of choreographic statements.

There are a two ways to refer to endpoints. First, to refer to singular endpoints there is the notation $r$, which refers to either an endpoint $e$ or a member of an endpoint family $F$ at index $E$. Second, there is the notation $\alpha$ for endpoint targets in general, which extends singular endpoints with ranges of endpoint families. This can be used to state that e.g. a statement must be executed by a subrange of an endpoint family.

The syntax for choreographic statements $S_{chor}$ partially overlaps with regular PVL statements $S_m$, but they cannot be used interchangeably. Specifically because e.g. the choreographic \kwif{} requires its condition to be one or more endpoint expressions \texttt{(\kwepexpr{} $\alpha$; $H$)} combined with \texttt{\&\&}, whereas the regular PVL \kwif{} requires a plain heap expression $H$. The semantics is similar to the semantics of each statement in PVL, except that each endpoint only executes those staments that are relevant to the endpoint. For example, the choreographic statement \texttt{endpoint $a$: $e$.$x$ := 3} will be executed by $a$, but skipped by $b$. Composite statements are transparent with regards to this; if an endpoint does not occur within a composite choreographic statement, it skips it.

A communication statement is parameterized when the $\alpha$ notation is used to denote a range, such as \texttt{$F$[v := 0 .. N]}. When both alphas of the communicate indicate a singular endpoint, it is just a regular non-parameterized communicate (though even in the non-parameterized communicate, a member of an endpoint family might participate through endpoint family indexing, such as \texttt{$F$[5]}).

The user can also declare a channel invariant on a communicate statement, which specifies an invariant over values sent over that channel. This invariant must be proven over the values sent, and may be assumed over the values received. Within this invariant, the keywords \kwsender{}, \kwreceiver{} and \kwmsg{} must be used to refer symbolically to the respective concepts.

Choreographic expressions are adapted to allow the same projectability that is natural for statements. The primitive here is the endpoint expression, written as \texttt{(\kwepexpr{} $\alpha$; $H$)}, and also for $R$. This expression indicates that $H$ is only relevant for the endpoint target $\alpha$, and must be ignored by other endpoints. This means that any endpoint covered by $\alpha$ will evaluate the expression, while endpoints not covered by $\alpha$ will simply continue as if the expression evaluated to \kwtrue{}. This is sound, because endpoint expressions may only occur positively, and because VeyMont checks branch unanimity~\cite{VandenBos2023}.

The \kwchor{} expression is used to indicate that an expression should only be included in the choreographic projection, and that is should not be included in the endpoint projection. In addition, within a \kwchor{} expression, permissions from all endpoints can freely be mixed. In spirit, \kwchor{} is similar to \kwassume{}, in that it is used to ``debug'' non-verifying programs, and that any use of \kwchor{} should include an explanation of why it is needed, or otherwise removed. For more information on endpoint expressions, we refer the reader to \cite{Rubbens2024}.