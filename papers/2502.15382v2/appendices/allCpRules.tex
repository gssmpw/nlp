\section{Choreographic Projection Rules}\label{app:cp}

\begin{figure}[ht!]
\centering
\begin{adjustwidth}{-0.17\paperwidth}{-0.17\paperwidth}
\begin{mathpar}
\RuleCpExpr[tr]{} \and 
\RuleCpExprSkip[tr]{} \and
\RuleCpAssign[tr]{} \and
\RuleCpIf[tr]{} \and
\RuleCpWhile[tr]{} \and
\RuleCpMethodCall[tr]{} \and
\RuleCpComm[tr]{} \and
\RuleCpExprRange[tr]{} \and 
\RuleCpExprIndex[tr]{} \and
\RuleCpMethodCallRange[tr]{} \and
\RuleCpCommRange[tr]{}
\end{mathpar}
\end{adjustwidth}
\caption{All choreographic projection rules}
\end{figure}

We will now discuss the transformation rules for the choreographic projection.

The transformation rules distinguish between \begin{enumerate*}[1.]\item singular endpoints using $e$, \item  singular or indexed endpoint families using $r$, and \item endpoints or endpoint family ranges using $\alpha$\end{enumerate*}. E.g. rule \refrule[tr]{CpExpr} applies only to singular endpoints, such that another rule (in this case rule \refrule[tr]{CpExprRange}) is necessary to handle the parameterized case. In contrast, e.g. rule \refrule[tr]{CpExprSkip} uses $\alpha$, and hence works for both endpoint family ranges as well as singular endpoints.

Rule \refrule[tr]{CpExpr} enables confined memory mode~\cite{Rubbens2024} to make sure $E$ is evaluated using only memory of $r$.

Rule \textsc{CpExprSkip} skips an expression by transforming it to \kwtrue{} if it is not relevant for the current target for confinement. This is safe, because the side condition $\textsf{sort}(\alpha) \neq \textsf{sort}(r)$ guarantees that the expression is not relevant to $r$.

Rule \refrule[tr]{CpAssign} uses confined memory mode to ensure the assignment is executed on the memory of $r$. For this rule there is no parameterized version. This is because it is difficult to automatically infer the footprint of the expressions $E_{loc}$ and $E_v$ in a parameterized context. If required, the user can work around this by defining a method on an endpoint that only writes to a field, and call this using the rule for parameterized method invocation, discussed later.

The rules \refrule[tr]{CpIf} and \refrule[tr]{CpWhile} forward the choreographic projection to their subparts, while also adding deadlock freedom checks~\cite{VandenBos2023}. As there is no endpoint context on these statements, no confinement is necessary.

Rule \refrule[tr]{CpMethodCall} evaluates the target of the method in confined memory mode. On then target, it calls a version of the method $m$ adapted to the stratified permissions memory model~\cite{Rubbens2024}.

Rule \refrule[tr]{CpComm} encodes a communication from endpoint $r$ to endpoint $p$. First, the message value is computed, confined to the memory of $r$. Then, the channel invariant is removed from the state of $r$ using the \kwexhale{} statement. Note that the channel may contain the placeholder expressions \kwmsg, \kwsender, \kwreceiver, in this case referring to the value of $H_{msg}$, $r$ and $p$ respectively. The projection instantiates these placeholders with their concrete values by passing $v$, $r$ and $p$ as arguments to the channel invariant $R_I$. Then, the invariant is added to the state of $p$, after which finally the value is written to the destination location.

Rule \refrule[tr]{CpExprRange} evaluates an expression for all endpoints in an endpoint family symbolically by replacing the \kwepexpr{} keyword with \kwforall{}. This is sound, as \kwepexpr{} expressions can only occur in a positive positions: $H_{chor}$ is essentially a list of \kwepexpr{} expressions combined with \texttt{\&\&}. This is at the logical level equivalent to using \kwforall{}.

Rule \refrule[tr]{CpExprIndex} shows how to project an endpoint expression with a range in confined mode: an implication is prepended to the expression $E$ that ensures $E$ is only evaluated if the confinement target index $j$ is within the bounds of the endpoint expression range, $E_{low}$ and $E_{high}$. Effectively, we intersect the range specified by the endpoint expression with the confinement target. This rule is necessary when using the confined memory mode for branch unanimity (i.e. the \textsf{unanimous} function).

Rule \refrule[tr]{CpMethodCallRange} transforms a method call on a range of endpoints into a par block that executes the method calls indepently and in parallel. This is essential: if the par block can be proven correct, this means the method calls can safely be executed independly and in parallel, which means splitting this method call up using the endpoint projection is safe. The syntax for the object on which the method is called is restricted: instead of a general expression $H$ we allow only an indexed family. This ensures the required annotations for the \kwpar{} block can be automatically generated, as it keeps the footprint predictable and exact.

Rule \refrule[tr]{CpCommRange} does something similar as rule \refrule[tr]{CpMethodCallRange}, except for two things. First, the injectivity is checked by adding an assert and a quantifier encoding the injectivity property over the expression $d$. Second, by modelling the actual message exchange within the par block. This message exchange works as follows: \begin{enumerate*}\item evaluate the message in the context of \kwfi{}, \item remove the channel invariant from the state of \kwfi{}, \item add the state to \famidx{G}{d(i)}, \item  assign the message to the destination location, allowing only memory to be used of the receiving party\end{enumerate*}. Similar to rule \refrule[tr]{CpMethodCallRange}, if this par block can be verified, it is safe to split this block across endpoints using the endpoint projection. For this rule, the allowed syntaxes for the message and destination are similarly restricted as \refrule[tr]{CpMethodCallRange} to allow for automatic annotation generation.