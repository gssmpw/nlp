\section{Endpoint Projection Rules}\label{app:ep}

\begin{figure}[ht!]
\centering
\begin{adjustwidth}{-0.2\paperwidth}{-0.2\paperwidth} % Apparently geometry also changes paperwidth...?
\begin{mathpar}
\RuleEpAssign[tr]{} \and
\RuleEpAssignSkip[tr]{} \and
\RuleEpSend[tr]{} \and
\RuleEpReceive[tr]{} \and
\RuleEpComm[tr]{} \and
\RuleEpCommSkip[tr]{} \and
\RuleEpExpr[tr]{} \and
\RuleEpExprSkip[tr]{} \and
\RuleEpExprIndex[tr]{} \and
\RuleEpRange[tr]{} \and
\RuleEpAnd[tr]{} \and
\RuleEpChor[tr]{} \and
\RuleEpIf[tr]{} \and
\RuleEpWhile[tr]{} \and
\RuleEpIndexSend[tr]{} \and
\RuleEpIndexReceive[tr]{} \and
\RuleEpRangeSend[tr]{} \and
\RuleEpRangeReceive[tr]{}
\end{mathpar}
\end{adjustwidth}
\caption{All endpoint projection rules}
\end{figure}

Rules \refrule[tr]{EpAssign}, \refrule[tr]{EpExpr}, \refrule[tr]{EpAnd}, \refrule[tr]{EpIf}, \refrule[tr]{EpWhile} and their \textsc{*Skip} versions should be self explanatory: they preserve the meaning of the choreographic statement if it is related to the current projection target, and otherwise replace it with the empty block statement (resp. \kwtrue{} for expressions). 

Rule \refrule[tr]{EpComm} shows that each communication statement is processed twice: once in $send$ mode and once in $receive$ mode, passed as an argument through the superscript position. The sending part is processed first to ensure the projected program cannot get stuck. Rule \refrule[tr]{EpCommSkip} shows what happens when the projection target is neither in the sending or the receiving position: it is replaced with the empty block statement. The \textsf{sort} function is used here to avoid having to add duplicate cases for both singular endpoints $e$ as well as endpoint family indices such as \kwfi{}.

Rules \refrule[tr]{EpSend} and \refrule[tr]{EpReceive} shows that sends and receives are encoded with resp. \texttt{writeValue} and \texttt{readValue} method calls on a channel. The specific channel is retrieved from a table that is pre-generated similar to how this is done for the choreographic projection. This is indicated with the $\denote{L}_r$ notation.

Rule \refrule[tr]{EpExprIndex} shows how to transform an endpoint expression when it concerns an indexed endpoint family, and when the current projection target is also an indexed endpoint family. In this case, the expression $E$ is encoded in such a way that it is only evaluated if the indices match of the two endpoint families.

For rule \refrule[tr]{EpRange}, this is similar, except that the current projection target index now has to be in a range $[E_h,)$.

Rule \refrule[tr]{EpChor} always drops the expression $E$, as this annotation indicates the expression should only be included in the choreographic projection.

Rules \refrule[tr]{EpIndexSend}, \refrule[tr]{EpIndexReceive}, \refrule[tr]{EpRangeSend} and \refrule[tr]{EpRangeReceive} apply the same trick as \refrule[tr]{EpExprIndex}, they check if the current projection target index falls in the range specified by the statement. 

For rule \refrule[tr]{EpRangeReceive} there is an additional complication: the inverse of the expression $d$ needs to be computed at run-time to determine the sending endpoint index. While injectivity of this expression is checked using the choreographic projection, this does not result in the actual expression $d^{-1}$; \veymont{} reasons symbolically about it during the choreographic projection, for the purposes of verification. Instead, the endpoint projection uses pattern matching to ensure $d$ is in a form that is actually invertible. For example, the expression $i+1$ can be pattern matched to find that the inverted form is $i-1$.