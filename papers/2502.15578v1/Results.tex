\section{Experimental Results}
% \vspace{-0.1cm}
\subsection{Experimental Setup}
\vspace{-0.1cm}
\begin{table}[t]
\centering
\caption{Resource utilization of different fault attack setups on Pynq-Z1 FPGA (SC: Self-clocked RO).}
\fontsize{8.2}{8.2}\selectfont

\begin{tabular}{|c |c |c|c|c|c|} 
\cline{1-6}
{Module}&No. of &\multicolumn{2}{c|}{LUT configured by  }&\multicolumn{2}{c|}{Overall LUT } \\ 

&instances&\multicolumn{2}{c|}{power-wasters (\%)}& \multicolumn{2}{c|}{utilization (\%)}\\
\cline{3-6}
&&RO&SC &RO&SC  \\
\hline
Adder&1000&29.6&28.2&64.6&76.9 \\
\hline
AES&2&22&26&76.7 &78.7\\
\hline






\end{tabular}
 \vspace{-0.2cm}
 \label{lut}

%%%%add perf. eval
\end{table}



We implement FLARE on the Pynq-Z1 FPGA, which consists of 53,200 LUTs. The power-wasters, AES, and adder modules are implemented in Verilog. Note that while our evaluation focuses on RO and self-clocked RO circuits, the attack can be demonstrated using other power-wasters discussed in prior literature, as they share similar structural configurations \cite{FPGAhammer} \cite{Krautter2019MitigatingCloud} \cite{9810438}. Importantly, FLARE is generalizable to other FPGAs as the vulnerabilities exploited during the partial reconfiguration process is not FPGA-specific. We use Vivado 2023.2 to synthesize, implement, and generate the bitstream corresponding to the hardware setup for the attack evaluation. Table \ref{lut} shows the resource utilization of the implemented designs. We use Vitis to load partial bitstreams into CoRQ.  We test the fault attack using three partial bitstreams -- \textit{blinkall, blinkcount}, and \textit{blinkline}. We monitor the attack success using the fault detection signal $flt_{sig}$, which is captured by the GPIO port of the FPGA. A video demo of the fault attack experiments performed in this work is available in \cite{demo}.

\vspace{-0.1cm}
 \begin{figure}
\centering
\includegraphics[width=0.43\textwidth]{Figures/Floorplan.pdf}

\caption{Floorplan of the attack setup incorporating adder modules on Pynq-Z1 FPGA (PE: Priority encoder).}
\label{addfloorplan}
\vspace{-0.6cm}
\end{figure}
 \begin{figure}[t]

\includegraphics[width=0.5\textwidth]{Figures/merged_adder_fail.pdf}

\caption{Distribution of the number of fails in the adder modules for (a) RO and (b) Self-clocked RO (PE 1 and PE 2 refer to priority encoders $p_1$ and $p_2$, respectively).}
\label{adder}
\vspace{-0.5cm}
\end{figure}




\subsection{Fault Attack Analysis on Adders}
\vspace{-0.1cm}
We evaluate FLARE on adder modules that are pre-configured on the FPGA. Fig. \ref{addfloorplan} shows the floorplan of the experimental setup implementing adder modules on the Pynq-Z1 FPGA. We conducted 10,000 fault attack attempts on the FPGA. In each attempt, a different partial bitstream is loaded into CoRQ for configuration. Power-wasters were activated specifically during the reconfiguration process to enable fault injection and were deactivated once the process concluded. After configuring the partial bitstream on the FPGA, we verify that the fault is successfully injected, altering the configuration address and redirecting the bitstream to the adder PRRs. Fig. \ref{adder} demonstrates the distribution of the fails due to the fault attack. We observe that for both combinational and self-clocked ROs, FLARE consistently induces faulty computations in at least one of the adder clusters$^1$. In some cases, the adders  remain unaffected, producing correct outputs. However, the faults disrupt the functionality of modules $p_1$ and $p_2$, resulting in incorrect encoded outputs. Fig. \ref{addf}(a) and Fig. \ref{addf}(b), show the frequency of fails in adder clusters \#1 and \#2, respectively. 

% We split each cluster into 10 bins, each having 50 adder instances. This ensures a fine-grained analysis of victim PRRs that are the predominant fault-injection sites. 
% In adder cluster \#1, the number of fails for each adder ranges from 8 to 12, indicating a proportionate fault impact. In adder cluster \#1, the adders failing the maximum number of times (12 fails each) are: 7, 11, 14, 116, 127, 364, and 401.
% However, the number of fails in adder cluster \#2 is significantly higher, within the range [19, 20]. 


% \vspace{-0.1cm}


 \begin{figure*}[t]

\includegraphics[width=\textwidth]{Figures/merged_final.pdf}

\caption{ Parts (a) and (b) depict the number of fails in adder clusters \#1 and \#2, respectively, with ROs. Parts (c) and (d) show the fail frequency in clusters \#1 and \#2, respectively, with self-clocked ROs. }
\label{addf}
\vspace{-0.4cm}
\end{figure*}


\subsection{Fault Attack Analysis on AES}
\vspace{-0.1cm}
To demonstrate the generalizability of FLARE, we evaluate another critical module, namely AES. The attack setup is shown in Fig. \ref{aesfloorplan}, which details the placement of the AES instances on the Pynq-Z1 FPGA. We keep the upper bound of AES instances to 2 as adding more instances exceeds the number of LUTs of the FPGA, causing place-and-route errors during the Vivado implementation phase. Similar to adder evaluation, we performed a total of 10,000 fault attack attempts using both combinational and self-clocked ROs. We observe successful fault-injection by both the power-wasters --  after five fault-injection attempts, AES \#1 consistently generates incorrect ciphertexts, indicating successful disruption of its encryption operations\footnote[1]{A video demo of the fault attack is presented in \cite{demo}.}. However, AES \#2 remains unaffected by the fault attack, primarily due to the placement and routing constraints of the PRRs where it is configured.

\vspace{-0.1cm}
 \begin{figure}
\centering
\includegraphics[width=0.43\textwidth]{Figures/aes_floorplan.pdf}

\caption{Floorplan of the attack setup using AES modules.}
\label{aesfloorplan}
\vspace{-0.1cm}
\end{figure}
\subsection{Bypassing CRC Mechanisms}
\vspace{-0.1cm}
During bitstream generation, the CRC value is computed and embedded within the bitstream. The \textit{crc\_check} function in CoRQ computes the CRC of the bitstream before configuring it on the FPGA. As explained in \cite{crc}, CRC only verifies the bitstream data; there are no checks to ensure that the bitstream is configured in the correct PRR. 
  To validate whether FLARE evades CRC, we conducted experiments using a test bitstream, namely \textit{blinkcount}. We monitor the \textit{corq\_status} flag to check if CRC detects a faulty bitstream. We obtain the following message on Vitis: \textit{Decrypting blinkcount successful. Bitstream successfully loaded.} Since FLARE manipulates the configuration address rather than the bitstream data, it successfully evades CRC, and the fault-injected bitstream is incorrectly configured in the victim PRR of the FPGA.
\vspace{-0.1cm}

\subsection{Comparison to Prior Fault Attack Schemes}
\vspace{-0.1cm}

By precisely targeting the configuration address of a bitstream and reducing the attack duration, FLARE is significantly faster and stealthier than prior runtime fault attacks \cite{8056840} \cite{FPGAhammer} \cite{7809042} \cite{8844478}, while minimizing the likelihood of detection by \cite{9643485} \cite{10.1145/3451236}. Moreover, FLARE adversely impacts multiple modules on the FPGA simultaneously, a threat not explored in prior fault attacks. For a fair evaluation, we compare FLARE with  \cite{chaudhuri2024hackingfabrictargetingpartial}, as both approaches specifically target fault-injection in the partial reconfiguration process. As highlighted in Table \ref{faultcomp}, FLARE is 200$\times$ faster than \cite{chaudhuri2024hackingfabrictargetingpartial} in executing a successful attack. While both \cite{chaudhuri2024hackingfabrictargetingpartial} and FLARE successfully induce faults in the bitstream, \cite{chaudhuri2024hackingfabrictargetingpartial} has a 100\% detection rate by CRC, whereas FLARE bypasses CRC verification entirely.  

\vspace{-0.1cm}
\begin{table}[t]
\centering
% \begin{threeparttable}
%r2d2 cap attack current sensing
\fontsize{8.7}{8.7}\selectfont

\caption{Comparison of FLARE with \cite{chaudhuri2024hackingfabrictargetingpartial}.}

    \label{compare}
    \begin{tabular}{|c| c| c|} 
    \hline
% \multirow{2}{*}{$K$}&
{Parameter} &\cite{chaudhuri2024hackingfabrictargetingpartial} & \textbf{FLARE} \\
\hline
Attack duration&40 ms&200 $\mu$s \\
\hline
Exposure window&Entire bitstream &Targeted (`select' part \\
&&of bitstream) \\
\hline
CRC evasion?&\xmark&\checkmark \\
\hline
\end{tabular}

\vspace{-0.3cm}


\label{faultcomp}
\end{table}








