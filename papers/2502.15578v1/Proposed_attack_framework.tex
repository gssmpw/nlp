\section{Fault Attack Targeting Reconfiguration Address Manipulation}
\vspace{-0.1cm}
In this section, we provide a detailed analysis of FLARE, which targets configuration address manipulation. First, we implement several power-wasters that have been shown to cause voltage-based fault attacks and DoS \cite{8056840, FPGAhammer, Krautter2019MitigatingCloud, 9810438}. We evaluate the appropriate configuration parameters of these power-wasters for triggering a successful fault attack on the FPGA. Next, we describe how activation of these power-wasters during the partial reconfiguration process of bitstreams can adversely impact co-tenant modules on the FPGA. Finally, we provide a detailed description of the bitstream reconfiguration process and the attack setup on the FPGA.
\vspace{-0.1cm}
 \subsection{Fault Injection Using Power-Wasters }
\vspace{-0.1cm}
 As demonstrated in \cite{8056840, chaudhuri2024hackingfabrictargetingpartial}, ROs can be implemented as malicious power-wasters, causing high voltage fluctuations when triggered at a specific toggling frequency. Alternatively, loop-free self-clocked ROs  bypass DRC and are capable of generating clock glitches and severe voltage fluctuations on the PDN \cite{Sugawara2019OscillatorCentre}. Based on these observations, we evaluate both combinational and loop-free ROs for injecting faults into bitstreams. To induce malicious fault injections in bitstreams during partial reconfiguration, it is crucial to determine appropriate fault-injection parameters for the RO grid: (1) Number of ROs, (2) toggling frequency, and (3) duty cycle. We choose the upper bound of the number of RO and self-clocked RO instances to be 16000 and the toggling frequency range as $10^5-10^6$ Hz to be consistent with the experimental setup in prior work \cite{chaudhuri2024hackingfabrictargetingpartial, gnad2020remote}. These power-wasters are deployed on the FPGA to launch fault attacks on user bitstreams while they are being loaded into the RM for partial reconfiguration.
\vspace{-0.1cm}
\begin{figure}
\centering
\includegraphics[width=0.32\textwidth]{Figures/bs_data.pdf}

\caption{Structure of a Xilinx partial bitstream (the target region for attack is highlighted in red).}
\label{structure}
\vspace{-0.5cm}
\end{figure}
 \subsection{Proposed Fault Attack Methodology}
\vspace{-0.1cm}
 Prior fault attacks \cite{FPGAhammer, 8056840} require the power-wasters to be activated continuously throughout the runtime of user modules to ensure a successful  fault attack. This significantly increases the attack \textit{exposure window}, i.e., the duration for which the attack needs to be active, making it more susceptible to detection. Unlike previous approaches, FLARE is precisely timed to be activated only when the configuration address of the bitstream is being loaded to the RM and remains inactive otherwise. This targeted activation makes the attack stealthy and minimizes the likelihood of detection \cite{9643485, 10.1145/3451236}. By injecting faults in `select' part of the bitstream, FLARE manipulates the configuration address, redirecting the bitstream to incorrect PRR(s), which we refer to as \textit{victim} PRRs.
 
\textbf{Injecting Faults to the Reconfiguration Address:} To understand how FLARE operates, it is important to examine the structure of an FPGA bitstream. Fig. \ref{structure} shows the bitstream structure of a Xilinx 7-series FPGA. The bitstream is partitioned into several structured frames \cite{pham2017bitman}.  The first section is the synchronization header, which initializes the bitstream. The header is followed by configuration address frames, which allocate a fixed set of bits namely `select' \cite{9643485}. Finally, the footer includes CRC values. The `select' part identifies the target PRRs where the bitstream is intended to be uploaded. The precise timing of FLARE is based on the fixed and well-defined structure of the Xilinx FPGA bitstream \cite{9643485}. The configuration process of a bitstream on the FPGA operates at a specific clock frequency. Using this frequency and information about the number of frames prior to the `select' frames, an attacker can estimate the time window during which the `select' part will be configured. In this duration, the attacker activates the RO grid to inject faults in the bitstream. 
 % For instance, the header may include a NOP (no operation) command to introduce a delay before programming begins. 
 
\textbf{Analysis of Attack Impact:} We emphasize that while earlier attacks primarily focused on single-tenant vulnerabilities or localized faults within a specific module, FLARE exposes a broader vulnerability by targeting multiple modules co-located on the FPGA, a threat that was not explored in prior fault attacks \cite{chaudhuri2024hackingfabrictargetingpartial, FPGAhammer, krautter2021remote, provelengios2020power}. Importantly, we evaluate the effectiveness of the attack after deactivating the power-wasters. At this point, the faulty bitstreams are already loaded into the FPGA, and any errors in module functionality are observed post-reconfiguration. The objectives of FLARE are as follows:

\begin{itemize}[leftmargin=*,topsep=0pt]
    \item \textit{Denial-of-service}:  By manipulating the configuration address of the user bitstream, the bitstream is redirected to incorrect PRRs. This results in an incomplete configuration of the intended module, rendering it non-functional. 
    \item \textit{Faulty computation in co-tenant module(s)}: When a bitstream is redirected to a wrong configuration address, it may overwrite the existing logic of a co-tenant module. This leads to erroneous computations and incorrect functionality of the module. For instance, arithmetic modules used for data processing may generate incorrect results, potentially compromising the integrity and functionality of user modules. Note that once the faults are injected in the victim PRRs, they persist until the FPGA is fully reconfigured. 
\end{itemize}


\vspace{-0.2cm}

\subsection{Attack Setup}
\vspace{-0.1cm}
\begin{figure}[t]
\includegraphics[width=1\linewidth]{Figures/algo_ets.pdf}

\caption{Pseudocode for partial reconfiguration of bitstreams on the FPGA via CoRQ.}\label{alg}

\vspace{-0.6cm}
\end{figure}


\textbf{Dynamic Partial Reconfiguration Using CoRQ:} We utilize an open source runtime RM, namely Command-based Reconfiguration Queue (CoRQ), for loading and dynamically reconfiguring bitstreams on the FPGA \cite{7946114}. CoRQ can store multiple partial bitstreams corresponding to different modules, and reconfigure them onto specific PRRs of the FPGA based on their configuration addresses. The steps for dynamic reconfiguration of a bitstream are illustrated in Fig. \ref{alg}. First, the FPGA bitstreams are loaded into the CoRQ memory (marked as \textbf{\textit{sel\_bitstore}}). Next, they are passed through CRC evaluation (marked as \textbf{\textit{crc\_check}}). If CRC passes, the bitstreams are successfully configured on the FPGA, else they are blocked from reconfiguration.
Vivado allows users to enable or disable the CRC of bitstreams based on their requirements. In scenarios where the bitstream is encrypted, the CRC is disabled using the constraint \textit{BITSTREAM.GENERAL.CRC Disable} \cite{ref_ultra}. To assess the impact of FLARE on CRC, we deliberately enable CRC during bitstream generation in all our experiments.

CoRQ shares its status as a register that can be read by the processing system, enabling real-time guarantees that can be exploited by attackers. By monitoring when CoRQ starts to be busy, we can precisely determine when the configuration address  begins to be uploaded (explained in Section IV.B).

Note that while our experiments target a specific RM, the attack methodology is generic and applicable to various RMs in FPGAs as the reconfiguration always has the same flow.



\textbf{Implementation of Victim Modules:} We evaluate FLARE on two design modules: (1) Adders, which are commonly used in ALUs and signal processing, and (2) AES, which is needed in communication and cryptography operations \cite{krautter2021remote}.  To create a realistic attack scenario, we configure a majority of the lookup tables (LUTs) on the FPGA with these modules \cite{luo2020stealthy}. This reflects real-world multi-tenant FPGAs, where shared modules boost throughput and utilization \cite{mbongue2020architecture}.
\vspace{-0.1cm}
\subsubsection{Case Study 1: Adder}
\vspace{-0.1cm}
In our first case study, we evaluate combinational adders as their outputs are not impacted by timing violations commonly associated with fault attacks \cite{9643485}, allowing us to specifically focus on the impact of address manipulation. To identify which adders are affected by the fault-injected input bitstream, we implement two adder clusters, referred to as adder cluster \#1 and adder cluster \#2, with each cluster containing $n$ adder modules. Through experimental analysis, we observe that initializing adders separately rather than grouping them into clusters is not feasible, as it results in inefficient resource utilization.  To ensure maximum LUT usage, we set $n=500$; $n>500$ causes placement error during Vivado implementation. Each adder module computes the sum of fixed inputs. In an address manipulation-based fault attack, the input bitstream is redirected to the adder PRRs, leading to erroneous computations in the adder modules. To localize the faulty adders, we generate signals $flag_1^i$ and $flag_2^i $, $1 \leq i \leq n$, corresponding to each adder module $i$ in adder clusters \#1 and \#2, respectively. A value of `0' for $flag_1^i$ ($flag_2^i$) indicates that adder $i$ in adder cluster \#1 (adder cluster \#2) produces the correct output, while a value of `1' indicates a faulty output.

Monitoring the $flag_1$ and $flag_2$ signals directly is not practical due to their large widths of 500 bits each. To address this, we encode $flag_1$  and $flag_2$ using priority encoder modules $p_1$ and $p_2$, respectively; this enables us to localize the faulty adder modules within the respective adder clusters. The adder clusters and priority encoders contribute to 21.2\% of LUT utilization. Finally, we read the data from $flt_{sig}$, which encodes the information about the faulty adders. Specifically, the lower 10 bits of $flt_{sig}$, denoted as $flt_{sig}[9:0]$, are used by $p_1$ to indicate the faulty adder from adder cluster \#1. Similarly, the next 10 bits, $flt_{sig}[19:10]$, are used by  $p_2$ to denote the faulty adder from adder cluster \#2.

\vspace{-0.1cm}

\subsubsection{Case Study 2: AES}
\vspace{-0.1cm}
In our second case study, we evaluate FLARE on an AES-128 implementation. AES encryption and decryption involve the following operations -- \textit{sub\_bytes}, \textit{mix\_columns}, \textit{shift\_rows}, and \textit{key\_expansion}. Given the substantial overhead of each AES module in terms of the number of configured LUTs on the FPGA (each AES module utilizes 10223 LUTs), we implement only two such AES instances, namely AES \#1 and AES \#2, which contribute to 38.6\% of the FPGA LUT utilization. For our experiments, we configure both the AES modules with the same 128-bit plaintext and 128-bit key. A fault attack is successful when the fault-injected bitstream is redirected to atleast one of the AES modules, resulting in computational errors. We compare the outputs of the AES modules against the predetermined ciphertext. If the ciphertext of AES \#1 (AES \#2) matches the expected value, we set $flag_1$ ($flag_2$) as 0, else we set it as 1. The fault detection signals
$flag_1$ and $flag_2$ are encoded in the least significant bits $flt_{sig}[0]$ and $flt_{sig}[1]$, respectively. The value of $flt_{sig}$ determines one of the following:
\begin{itemize}[leftmargin=*,topsep=0pt]
    \item $flt_{sig}=0$: No fault attack is detected in the AES modules.
    \item $flt_{sig}=1$: A fault attack results in incorrect reconfiguration of a bitstream in the PRR of AES \#1. 
    \item $flt_{sig}=2$: A fault attack results in redirection of the bitstream to AES \#2. 
    \item  $flt_{sig}=3$: Both AES \#1 and AES \#2 are impacted. 
\end{itemize}
\vspace{-0.1cm}





