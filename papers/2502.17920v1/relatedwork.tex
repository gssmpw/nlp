\section{Related Work}
%\subsection{Continual Learning}

Continual Learning (CL) requires model to continuously learn and recognize new classes without forgetting what it has previously learned \cite{dong2022federated,dong2023federated,gao2022r,goswami2024fecam,wang2022beef,zhao2021mgsvf}. Traditional CL methods can be grouped into four main approaches: replay-based, knowledge distillation, model architecture, and regularization-based methods. Replay-based methods \cite{liu2021rmm,luo2023class,wu2019large,buzzega2020dark,wang2022memory,wang2021triple,rebuffi2017icarl} involve store a subset of data from previous classes and replay them during training on new classes to preserve existing knowledge. Knowledge distillation methods \cite{dhar2019learning,douillard2020podnet,li2017learning,simon2021learning,tao2020topology} retain information from previously learned classes by using auxiliary loss functions that ensure the outputs of the old model is preserved while learning new classes. Model architecture methods \cite{shi2022mimicking,zhao2020maintaining,hu2023dense,wang2023incorporating,yang2022continual} modify the network structure to integrate new classes by designing specialized parameter modules for each stages, ensuring that the learning of new classes doesn't interfere with previously acquired knowledge. Regularization-based methods \cite{zhou2023hierarchical,aljundi2018memory,zenke2017continual,xiang2022coarse,dhar2019learning,li2017learning} impose constraints on the modelâ€™s parameters to prevent substantial changes that could lead to forgetting, thereby maintaining the integrity of important weights.


LoRA \cite{hu2021lora} is an efficient model fine-tuning method. Instead of fine-tuning the entire pre-trained model, LoRA fine-tunes specific submodules of the pre-trained model by inserting low-rank matrices. Traditional LoRA performs well in static task environments, where the tasks and data remain fixed during training \cite{hayou2024lora+,li2023loftq,kopiczko2023vera}. In continual learning settings, however, the traditional LoRA method faces challenges, particularly in handling the arrival of new tasks while retaining knowledge from previous ones to prevent catastrophic forgetting.
To address this challenge, a prevalent strategy involves combining multiple LoRA modules, each responsible for handling specific tasks within the input data \cite{wei2024online,zhou2024expandable,liang2024inflora}. The Mixture of Experts (MoE) \cite{jacobs1991adaptive,shazeer2017outrageously} framework integrates multiple expert networks and assigns tasks through a gating mechanism, thereby enhancing the model's performance across diverse tasks. Inspired by this, MoE-LoRA \cite{yu2024boosting} introduces a mixture of experts model to allocate and select LoRA modules, reducing conflicts between new and existing tasks. Additionally, infLoRA \cite{liang2024inflora} uses independent LoRA submodules for each new task and employs regularization techniques to minimize interference between new and old tasks. EASE \cite{zhou2024expandable} addresses data distribution changes by storing prototypes of each task-specific subspace and adopting a semantic-guided prototype augmentation strategy. Online-LoRA \cite{wei2024online} implements an online weight regularization strategy that automatically identifies changes in data distribution to reduce forgetting.
However, these methods rely on multiple LoRA modules, leading to a linear increase in parameter and computational overhead, and the challenge of effectively integrating all LoRA modules during inference.

%% ----------  Methodology  ----------- %%