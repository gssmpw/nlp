Essentially, to instantiate a new MAPSS Instance the MECO has to first translate a VI-independent MAPSSD (received on step1 in Fig \ref{fig:poc_seq_diag}) into a package of properly configured Kubernetes objects implementing the MAPSS Instance (to which we will refer as the MAPSS Instance Kubernetes deployment plan or \textit{KDP} for short), and then it has to deploy the KDP objects within the K3S etcd datastore. To perform both of these operation, the MECO relies on the \textit{HelmManager} and the \textit{MAPSSI Chart Repository} sub-modules, where We implemented the former as a wrapper of the Helm 3.0 Go library, and the latter as a repository of helm charts. Essentially we extensively leveraged Helm in our implementation. Helm is an open source template and package manager for Kubernetes, which allows to pack a set of Kubernetes object definition files (i.e. files describing properties of Kubernetes objects) into a package (the Helm Chart), and to manage the instantiation, upgrade and deletion (i.e. the LCM) of the corresponding Kubernetes objects as they were a single entity (the Helm Chart Release). Helm, further, allows to augment Kubernetes object definition files with helm template commands. By providing helm a list of arguments for these template commands at chart instantiation time, it is possible to dynamically customise the chart before it is actually deployed.  Example of these customisations spans from overriding object default values with the one passed as command arguments (e.g. a port exposed by a container, the namespace name, etc..) to dynamically enabling disabling chart sections.

To be more precise, to perform the MAPSSD to KDP translation the MECO leverages a set of pre-loaded KDPs templates, which are stored within the MASPS Instance Chart repository sub-module, as Helm charts. The association between a MAPSSD and its helm chart could be implemented via the the \textit{mapssImplTemplateId} identifier contained in the MAPSSD. In other words, for each \textit{mapssImplTemplateId} the MECO expects to find a corresponding KDP template in the MASPSI Chart Repository. Then, each chart includes a set of pre-configured Kubernetes objects. These objects defines the ACFs containers to run (e.g. via Kubernetes PODs objects), ACFs behavioural parameters (e.g. via environmental variables in Kubernetes ConfigMaps objects), ACFs connection points (i.e. exposed ports), and possibly custom scheduling policies (e.g., number of replicas, failure behaviour, etc.), and any other Kubernetes feature that is necessary for the correct deployment of the MAPSS Instance. We thus augmented the chart object definition files with helm template commands, that enable the MECO to dynamically customise the template using information derived from the MAPSSD. In the current implementation, we limit such customization to: $i)$ setting the target namespace name to which objects will belong; $ii)$ setting computational, storage and networking requirements for the namespace; $iii)$ setting computational and storage requirements per ACF, and networking requirements per pair of ACFs. 

We assume that the ASP is in charge of defining these templates and pre-loading the MASPSI Chart Repository. Such design choices are justified by observing that, as per roles highlighted in section \ref{subsec:roles}, the ASP has the necessary expertise to properly select, compose and configure ACFs to provide an AS. It is further aware of the type of the MEC Customer nested-VI (Kubernetes in our case), and, thus, it is able to select and properly configure the subset of Kubernetes objects that will allow to implement the MAPSS instances of the designed ASes. The MEC APSSMF (and hence E2E APSMF) could retrieve the correct \textit{mapssImplTemplateId} to set in the MASSD using an ASP provided translation table. However, the communication between the MEC APSSMF  and the ASP is out of the scope of the current implementation. We, as well, leave as future work the implementation of a more complex and automated translation from the proposed MAPSSD to a KDP.

To better detail the translation process, in Figure \ref{fig:poc_seq_diag} we illustrate the sequence of operations and the necessary interactions that are needed to instantiate a new MAPSS Instance. In \textit{step1}, the MECO API Server receives a new POST request carrying a MAPSSD. In \textit{step2}, the MECO API Server performs a first level of translation on the received MAPSSD. This operation derives the set of arguments for the helm chart template commands, which allows to perform the template customisation (e.g. to set the proper value of computational resources). The MECO API Server retrieves the helm chart id from the \textit{mapssImplTemplateId} identifier contained in the MAPSSD (\textit{dempoTpl} in this example). Thus, \textit{step2} is concluded with the API Server that instructs the HelmManager to deploy the \textit{demoTpl} helm chart with the correct set of chart arguments. Subsequently, in \textit{step3}, the HelmManager fetches the \textit{demoTpl} helm chart from the MAPSSI chart repository, and it starts the deployment process. As a first operation, in \textit{step4}, the HelmManager contacts the K3S API Server to create a new Kubernetes namespace whose name matches the \textit{mapssId}. In \textit{step6}, HelmManager will thus apply the custom arguments to the \textit{dempoTpl} chart, \textit{step5}, and start the chart release process, whose release name is set to \textit{dempoSlice}. This process involves the generation of the proper set of Kubernetes objects definition files (i.e. the Kubernetes Deployment Plan). Once the KDP is ready, HelmManager will instruct the K3S API Server to create the latter objects in the etcd database (\textit{step7}). Finally, in \textit{step8}, the K3S controller manager will start performing control actions according to the received Kubernetes objects. The latter includes contacting the ACF Image Repository to fetch ACFs container images for scheduleding.   
