\subsection{\dappl~Ergonomics and Syntactic Sugar}\label{appendix:sugar}
We extend the \dappl~core calculus with several ergonomic features that makes
the modeling of decision scenarios easier.

\subsubsection{Ending an expression with \dapplcode{reward}.}

Instead of $\reward k {\return \tt}$ one can write $\dapplcode{reward k}$.

\subsubsection{Support for discrete distributions.}\label{sugar:discrete}

We give \dappl~support for explicit categorical distributions over
a set of variables. For example, the expression \texttt{disc[a : 0.5, b: 0.3, c: 0.2]}
defines a probability distribution over the set of names \texttt{\{a,b,c\}} in which \texttt{a}
has probability 0.5, \texttt{b} has probability 0.3, and \texttt c has probability 0.2.
Discrete distributions de-sugar into a style of \textit{one-hot encoding}, in which a 
distribution over $n$ categorical variables are represented $n$ Boolean variables~\citep{holtzen2020scaling}.

\subsubsection{Overloading of if-then-else and choose-with.}\label{sugar:overloading}

We allow the guard of an if-then-else statement to be a decision with one choice.
Intuitively this would represent the decision of choosing to do something or not.
Symmetrically, we allow use of the choose-with statement over categorical distributions
as outlined above in \ref{sugar:discrete}.
We can do this as for a decision with one choice $c$, 
the expression $\text{ExactlyOne}(c)=c$, and analogously, we can check that for
a categorical distribution \texttt{disc[x1 : p1 , ... , xn : pn]}, the one-hot encoding
will enforce the exactly-one constraint.

\subsubsection{Bounded loops.}\label{sugar:loops}

We allow bounded loops; that are, loops that terminate after a specified number of times.
This avoids the potential of infinite computation while maintaining exactness, 
which has been implemented in several existing PPLs. 
The syntax is $\texttt{loop } n \texttt{ \{} e \texttt{\}}$, on which an expression $e$
is run $n$ many times.
In the case that a decision is within the loop, as an optimization we can pull the decision out of the loop, at which point the expected utility becomes $n$ times that of $e$. This is proved sound in the following Lemma.

\begin{lemma}[Soundness of loops]
  For a $\dappl{}$ program $e$,
  \begin{equation}
  \infer
  {\EU(\texttt{loop } n \texttt{ \{} e \texttt{\}}) = nk}
  {\EU(e) = k & n >0}
\end{equation}
\end{lemma}

\begin{proof}
We prove this by induction.
As a base case we have that 
$\texttt{loop } n \texttt{ \{} e \texttt{\}} = e$,
and $\EU(e) =k $, so $\texttt{loop } n \texttt{ \{} e \texttt{\}} \Downarrow_{\EU} k$ 
as desired. 

In our inductive case, we observe that
$\texttt{loop } n \texttt{ \{} e \texttt{\}} = 
\bind x {\texttt{loop } (n-1) \texttt{ \{} e \texttt{\}}} e$. We see that $x$ will not occur free in $e$, 
or vice versa; thus we can add utilities via our semantics to get $\EU(\texttt{loop } n \texttt{ \{} e \texttt{\}}) = (n-1)k +k = nk$ as desired.  
\end{proof}