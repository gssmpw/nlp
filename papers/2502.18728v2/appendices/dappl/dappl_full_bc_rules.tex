\subsection{Full Boolean compilation rules of \dappl{}}
\label{appendix:dappl bc}

See~\cref{fig:dappl full bc}.

\begin{figure}
  \begin{mdframed}
  {\footnotesize 
  \begin{align*}
    \infer[\texttt{bc/var}]
    {x \leadsto (x, T, \eset, \eset)}
    {}
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/true}]
      {\tt \leadsto (T, T,\eset, \eset)}{}
    \qquad
    \infer[\texttt{bc/false}]
      {\ff \leadsto (F,T, \eset, \eset)}{}
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/flip}]
      {\flip{\theta} \leadsto 
        (f_{\theta}, 
        T, 
        (f_{\theta} \mapsto (\theta,0), \overline{f_{\theta}} \mapsto (1-\theta, 0)),
        \eset)}
      {\text{fresh } f_{\theta}}
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/ret}]
      {\return P \leadsto 
        (\varphi, T, \eset, \eset)}
      {P \leadsto (\varphi, T, \eset, \eset)}
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/reward}]
    {
      \reward k  e \leadsto 
      (\varphi, \gamma, R \cup \{r_k\}, 
        w \cup \{r_k \mapsto (1,k), \overline{r_k} \mapsto (1,0)\})}
    {
      \text{fresh } r_k
      & e \leadsto (\varphi, \gamma, R,w)
    }
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/obs}]
    {\observe x e \leadsto (\varphi, \gamma \land x, w, R)}
    {x \leadsto (x, T, \eset, \eset)
    & e \leadsto (\varphi, \gamma, w, R)}
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/[]}]
    {[a_1, \cdots, a_n] \leadsto 
    (\exactlyone{(v_1,\cdots, v_n)}, T, \{v_i \mapsto (1,0), \overline{v_i} \mapsto (1,0)\}_{i \leq n}, \eset )}
    {\text{fresh }v_1, \cdots, v_n}
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/ite}]
    {
      \ite{x}{e_t}{e_e} \leadsto 
      \begin{gathered}
        \big(
          (x \land \varphi_t \land R_t \land \conjneg{R_e}) 
            \lor (\overline{x} \land \varphi_e \land R_e \land \conjneg{R_t}), \\
          (x \land \gamma_t) \lor (\overline{x} \land \gamma_e),
          w_t \cup w_e,
          \eset) 
      \end{gathered}
    } {
      x \leadsto 
      (x, T, \eset, \eset) 
      & 
      e_t \leadsto 
      (\varphi_t, \gamma_t, w_t, R_t) 
      & 
      e_e \leadsto 
      (\varphi_e, \gamma_e, w_e, R_e)
    }
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/choose}]
    {\choose x {a_i \implies e_i} 
    \leadsto 
    \begin{gathered}
      \Big(\varphi \land \bigvee (a_i \land e_i 
      \land \bigwedge_{j \neq i} \conjneg{R_j}), 
      x \land \bigvee (a_i \land \gamma_i), \\
      \bigcup w_i, \bigcup R_i)
    \end{gathered}
  }
    {e \leadsto 
    (\varphi, T, \eset, \eset) 
    & 
    \forall \ i.  \ e_i \leadsto (\varphi_i, \gamma_i, w_i, R_i)}
  \end{align*}
  \begin{align*}
    \infer[\texttt{bc/<-}]
    {\bind{x}{e}{e'} \leadsto 
    (\varphi'[x \mapsto \varphi], 
    \gamma \land \gamma'[x \mapsto \varphi],
    w \cup w', 
    R \cup R')}
    {
      e \leadsto (\varphi, \gamma, w, R) 
      & 
      e' \leadsto (\varphi', \gamma', w', R')
    }
  \end{align*}
  }
  \end{mdframed}
  \caption{Boolean compilation rules of \texttt{dappl}. Compilation rules for
  $\land, \lor, \neg$ are omitted as they are straightforward.}
  \label{fig:dappl full bc}
  \end{figure}