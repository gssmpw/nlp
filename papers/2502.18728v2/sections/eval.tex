\cref{sec:bbir} outlined how BBIR can both \textit{factorize} program
structure and \textit{prune} ineffective strategies over such a representation.
But, the question still remains: does this translate into a fast
language for optimization in practice?
To answer this question we compare \dappl{} and \pineappl{} against
existing languages to express and solve MEU and MMAP problems.\footnote{\emph{Evaluation and implementation details:} All timings of
benchmarks were run on a single thread,
on a server with 512GB of RAM and two AMD EPYC 7543
CPUs.
The BBIR and and associated algorithms are written in Rust.
$\pineappl$ was written in Rust, while $\dappl$ was written in OCaml.
When feasible, the output by ProbLog and its variants
were verified to match the policies output by \dappl{} and $\pineappl$.
}

\subsection{Empirical Evaluation of $\dappl$}\label{subsec:dappl-eval}
\input{sections/dappl_eval.tex}


\subsection{Empirical Evaluation of $\pineappl$}
\input{sections/pineapple_eval.tex}