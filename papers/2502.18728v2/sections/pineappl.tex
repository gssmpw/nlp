
In this section, we describe the syntax, semantics, and boolean compilation of
$\pineappl$. $\pineappl$ is
different from $\dappl$ in the fact that it is
a first-order, imperative probabilistic programming
language with support for first-class MMAP computation, along with
marginal probability computations.
Much like the organization of~\cref{sec:dappl},
we will first introduce the syntax and semantics (\cref{subsec:pineappl-sem}),
then outline the Boolean compilation (\cref{subsec:pineappl-compl}).

\subsection{Syntax and Semantics of $\pineappl$}
\label{subsec:pineappl-sem}


\input{figs/pineappl-syntax.tex}
The full syntax of pineappl is in~\cref{fig:pineappl-syntax}.  A $\pineappl$
program is made of two parts: statements and a query.  Statements consist of
(1) variables bound to either \pineapplcode{flip}s or expressions over them,
(2) a \pineapplcode{mmap} statement for binding a set of variables
$\texttt{x}_1, \hdots, \texttt{x}_n$
to the MMAP state of variables $\texttt{m}_1, \hdots, \texttt{m}_n$, or
(3) a sequence of the above.
A query asks for the marginal probabilty of an
expression.
We assume all variables have unique names.
Note that
\pineapplcode{mmap} and \pineapplcode{Pr} can be followed by \pineapplcode{ with \{e\}},
denoting the \textit{observation} of expression \pineapplcode{e}.
We impose the additional restriction that no variables referenced in the observed
expression have been bound by \pineapplcode{mmap}.
We endow more sugar in the full language, including support for
multiple queries, categorical discrete random variables, and bounded loops
in~\citet{cho2025scaling}.


\input{figs/pineappl-opsem.tex}

$\pineappl{}$'s semantics are given by two relations: $\Downarrow$ and $\Downarrow_P$,
described in~\cref{fig:pineappl-os}.
The
$\Downarrow$ relation is a big-step operational semantics
relating pairs of statements and distributions $(s, \mathcal D)$
to a new distribution $\mathcal D'$.
These distributions are over assignments of variables.
The
$\Downarrow_P$ relation relates a $\pineappl{}$ program $P = s; q$
to a real number correponding to the probability of query $q$.


To remark on the notation behind several rules:

\begin{enumerate}[leftmargin=*]
  \item The $\Pr_{\mathcal D}[e]$ notation used in
  \texttt{s/assn}, \texttt{s/if}, \texttt{p/pr}, \texttt{p/pr/with}
  denotes the probability of the event in $\mathcal D$ that the Boolean expression $e$ is satisfied.
  \item $MMAP_{\mathcal D}$, as used in \texttt{s/mmap} and \texttt{s/mmap/with},
  is the marginal MAP operator of some vector of variables $\vec{\mathtt{x}}$
  over a distribution $\mathcal D$, potentially conditioned on an expression $e$. More precisely we can define $MMAP_{\mathcal D}$ as follows:
  \begin{equation}
    MMAP_{\mathcal D}(\vec{\mathtt x} \mid e) = \max_{\sigma \in inst(\vec{\mathtt x})} \mathcal D(\sigma \mid e),
  \end{equation}
  where $\mathcal D(\sigma \mid e)$ is the probability of the instantiation $\sigma$ in $\mathcal D$ conditional on $e$.
\end{enumerate}


% For each binding
% and existing trace, two additional traces are created, one where the bound
% variable is $\top$ and the other where it is $\bot$. Each trace is then
% re-weighted by the probability of the particular instantiation of variables in
% that trace. To accomplish this re-weighting, we rely on two evaluation functions,
% $\Pr_{\mathcal{T}}(\varphi)$ in \cref{def:pr-trace} and
% $\mathrm{MMAP}_{\mathcal{T}}(v)$ in \cref{def:mmap-trace}, which compute the
% weighted trace probability of $\varphi$ or the MMAP state of variables $v$,
% given a set of weighted traces $\mathcal{T}$, respectively.

% \begin{definition}[$\Pr$ over weighted traces]
%   \label{def:pr-trace}
%     For some set of weighted traces $\mathcal{T}$ and boolean formula $\varphi$,
%     \[
%       Pr_{\mathcal{T}}(\varphi) =
%         \sum_{\{(\sigma, w) \in \mathcal{T} \mid (\sigma \models \varphi)\}} w
%     \]
% \end{definition}
% \begin{definition}[MMAP over weighted traces]
%   \label{def:mmap-trace}
%   For some set of weighted traces $\mathcal{T}$, let $M$ be a set of boolean
%   variables such that $M \subseteq \mathcal{T}^{-1}$ and let $V = \mathcal{T}^{-1}
%   \setminus M$. Then,
%   \[
%     MMAP_{\mathcal{T}}(M) = \argmax_{\sigma \in \mathcal{M}} \sum_{v \in V}
%       \Pr_{\sigma \cap \mathcal{T}}(v)
%   \]
%   where $\mathcal{M}$ is the set of all possible assignments to the variables in
%   $M$.
% \end{definition}
% Thus, assignment re-weights traces by the probability of satisfying the assigned
% expression and bindings introduced by \texttt{if-else} statements re-weight
% traces by the probability of satisfying the guard.

% The only statement which breaks from the mold is the first-class \texttt{mmap}
% statement. The statement relies on the already computed traces to query for the
% MMAP state of a set of variables, these traces are then augmented with new
% bindings to this state. Notably, this expression does not double the number of
% traces, because we do not need to consider both assignments to the MMAP, since
% there is exactly one correct answer to the optimization problem posed by MMAP.
% The evaluation functions also give rise to the MMAP and marginal probability
% queries for the whole program. The full semantics are presented in
% \Cref{fig:pineappl-os}.\footnote{These semantics rely on a function $e \leadsto
% \varphi$, which compiles $\pineappl$ expressions to boolean formulae, this
% compilation is excedingly straightforward and thus we elide its presentation. We
% will reuse this compilation function in \cref{subsec:pineappl-compl}.}

% To handle observation, we must consider each query separately. For programs
% making a marginal probability query, \texttt{Pr(e) with o}, we first compute the
% unnormalized probability of \texttt{e \&\& o} and then compute the normalizing
% constant as the marginal probability of the observation \texttt{o}, this follows
% directly from Bayes' rule. As an example consider the $\pineappl$ program:
% \begin{pineapplcodeblock}
%  x $\sim$ flip(0.5); y $\sim$ flip(0.5); $\Pr$ (x $\land$ y $\land$ x) with x
% \end{pineapplcodeblock}
% After running the operational semantics on the statement of the program, the
% result is $\mathcal{T} = \{ ([x \mapsto \top; y \mapsto \top], 0.25),
%   ([x \mapsto \top; y \mapsto \bot], 0.25)
%   ([x \mapsto \bot; y \mapsto \top], 0.25)
%   ([x \mapsto \bot; y \mapsto \bot], 0.25)
% \}$. Therefore, the result of the query is
% \[
%   \frac{\Pr_{\mathcal{T}}(x \land y \land x)}{\Pr_{\mathcal{T}}(x)} = \frac{0.25}{0.5} = 0.5.
% \]

Finally, we can query the probability of an expression \texttt{e} over the
compiled distribution via $\Downarrow_P$. To handle observation, \pineapplcode{Pr(e) with \{o\}},
as with the rule \texttt{p/pr/with},
we first compute the unormalized probability of the observation being
true jointly with the query, $\Pr_{\mathcal{D}}[e \land o = \tt]$, and then divide by the
normalizing constant, $\Pr_{\mathcal{D}}[o = \tt]$; this is Bayes' rule.

\subsection{Boolean Compilation of $\pineappl{}$}
\label{subsec:pineappl-compl}
\input{figs/pineappl-compilation.tex}

Like $\dappl{}$, we compile $\pineappl$ programs to Boolean formulae as a tractable
representation. Key rules are in~\cref{fig:pineappl-compl} and full rules are in~\cref{appendix:pineappl-compl-complete}.
The BBIR is used in the \texttt{bc/mmap} and \texttt{bc/mmap/with} rule, where
the premise $MMAP$ is identical to that defined in~\cref{subsubsec:mmap}, and is solved via
Algorithm~\ref{algorithm:bb}. We define three relations:
\begin{itemize}[leftmargin=*]
  \item $e \leadsto_E \varphi$ compiles a $\pineappl$ expression to a Boolean formula,
  \item $(s, \mathcal{F}, w) \leadsto (\mathcal{F}', w)$ compiles a $\pineappl$ statement $s$,
  a set of pairs of identifers and formulae $\mathcal F$, and a weight map of literals $w$
  into a set $\mathcal{F'}$ and weight map $w'$, and
  \item $s ; q \leadsto_P (\varphi, \psi, w)$ with an unnormalized formula $\varphi$, an accepting formula $\psi$, and a weight map $w$.
\end{itemize}
% The restriction of $\mathcal F$ to formulas which take the form $x \leftrightarrow \varphi$
% is important as it preserves the binding structure of new variables.

To conclude the section, we give a correctness theorem, akin to~\cref{thm:compiler correctness}, proven in~\cref{appendix:proof-pineappl-correctness}.
% ~\citet{cho2025scaling}.

\begin{theorem}\label{thm:pineappl correctness}
  For a $\pineappl{}$ program $s;q$, let $s ; q\Downarrow_P p$ and
  $s ; q \leadsto_P (\chi \land \paren{\bigwedge_{(x, \varphi) \in \mathcal{F}} x \leftrightarrow \varphi},\psi, w)$.
  Then
  {\footnotesize\begin{equation}
    p = \frac{\AMC_{\R}\left(\chi \land \paren{\bigwedge_{(x, \varphi) \in \mathcal{F}} x \leftrightarrow \varphi} \land \psi,w\right)}{\AMC_{\R}(\psi \land \paren{\bigwedge_{(x, \varphi) \in \mathcal{F}} x \leftrightarrow \varphi}, w)}.
  \end{equation}}
\end{theorem}

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "../oopsla-appendix"
%%% End:
