\subsubsection*{Languages for Optimization and Decision-Making.}~~There have been many
proposed languages for modeling decision-making and optimization from both the
artificial intelligence and programming languages communities.
Influence
diagrams~\citep{khaled2013solving,maua2016equivalences},
planning languages like PDDL and RDDL~\citep{sanner2010relational},
\dtproblog{}~\citep{van2010dtproblog}, and DT-Golog~\citep{boutilierdecision} give
a declarative or graphical description language for describing decision-making
scenarios. The typical approach to performing MEU on in this setting is
order-constrained variable elimination, which has the same worst-case complexity
as order-constrained knowledge compilation.  The problem of solving MEU has been
well-studied on influence diagrams, and branch-and-bound is a common approach in
this setting~\citep{yuan2012solving}; however, we believe our approach here is
the first to leverage knowledge compilation in conjunction with branch-and-bound
for solving MEU.  In the programming languages community, the problem of
designing languages for decision-making has been increasingly of interest and
sparked several recent languages and
systems~\citep{abadi2021smart,lago2022reinforcement}. These listed systems
support more sophisticated language features than \dappl{}, but no
implementation is provided for us to compare performance against.  There are a
number of existing approaches describing programs that model computations over semirings, such as
aProbLog~\citep{kimmig2011algebraic,kimmig2017algebraic} and weighted
programming~\citep{batz2022weighted}; these approaches do not aim to solve
semiring optimization problems such as what we propose here.

\subsubsection*{Knowledge Compilation for Optimization Problems.}
Broadly there are two main approaches within the literature for leveraging
knowledge compilation during optimization: branch-and-bound and
order-constrained approaches. The branch-and-bound approach was
originally proposed by \citet{huang2006solving} for solving the MMAP
problem in Bayesian networks.  Since then the approach has been refined and
improved, but remains the state-of-the-art approach for solving
MMAP on many problem
instances~\citep{choi2022solving,conaty2017approximation}.
\citet{kimmig2011algebraic} introduced AMC, and
\citet{kiesel2022efficient} introduced two-level AMC
to show how to solve MEU by combining the
expected utility and tropical semiring
for computing the MEU of \dtproblog{} programs, generalizing the work of~\citet{derkinderen2020algebraic}.
The primary limitation of two-level AMC is that it requires a fixed
variable order, which can lead to blowup, as we have seen in Section~\ref{sec:eval}.
Seen from this perspective, our branch-and-bound IR can be thought of as a
generalization of the branch-and-bound approach of \citet{huang2006solving}
to work over a much broader class of semirings than just the real semiring,
enabling it to be applied to problems such as MEU.


\subsubsection*{Meta-Reasoning in PPLs.}
Some PPLs today contain some support for forms of \emph{meta-inference}: the
ability to evaluate a marginal query while running a program.  Concretely,
languages with meta-inference typically include an \texttt{infer e} or
\texttt{normalize e} keyword that queries for the probability that a (closed)
program \texttt{e} evaluates to a particular value.
Examples include
\texttt{Church}~\citep{goodman2008church},
Anglican~\citep{tolpin2015probabilistic}, \texttt{Gen}~\cite{cusumano2019gen},
meta-\problog{}~\citep{mantadelis2011nesting},
\texttt{Venture}~\citep{mansinghka2014venture}, and
\texttt{Omega}~\citep{tavares2019random}.
The difference between MMAP and nested inference is that MMAP is finding the
optimal assignment to free variables.

It is possible to use meta-inference
to solve MMAP by enumerating over assignments to free variables,
and selecting the assignment that has the greatest marginal probability.
However, this runs into a clear state-space explosion challenge:
exhaustively enumerating the space of possible assignments during meta-inference
is infeasible for many of the examples we showed in our experiments (for
instance, the examples in our Bayesian network benchmarks query the MMAP state
of over 100 variables in some instances). Hence, for scalability reasons, we
argue that an MMAP query is an invaluable first-class citizen in addition to
meta-inference, and that staging is a useful framework for leveraging
compilation in order to scale. Anglican supports first-class MAP (maximum a posteori) inference, but does not
support MMAP queries~\cite{tolpin2015maximum}.

\subsubsection*{Probabilistic Model Checking and MDPs.} Probabilistic model checkers
such as Storm~\citep{dehnert2017storm} and PRISM~\citep{kwiatkowska2002prism} give
a specification language and query language for describing, solving, and
verifying Markov decision processes, and hence are capable of solving MEU
problems. These languages can scale quite well, and are especially useful for
verifying complex temporal queries. However, these systems require describing
the probabilistic system as an MDP, which can be very expensive; as shown in~\citet{holtzen2021model}, MDP-based
representations can scale poorly when compared with approaches that leverage
factorization on problem instances that exhibit independence structure.
Concretely, the Bayesian network examples given in our experiments would pose
significant scaling challenges to these systems, especially the large
hidden-Markov-model in Figure~\ref{fig : dr}. Additionally, MDPs do not
support first-class conditioning on evidence, which \dappl{} and many
other probabilistic programming languages support.


% \subsubsection{Weighted Programming}