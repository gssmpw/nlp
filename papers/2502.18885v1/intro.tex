\section{Introduction}

Reasoning about shared-variable concurrent programs is notoriously challenging due to the need to account for interference between concurrently executing threads. Traditional approaches to verifying such programs often struggle with modularity and composability---properties critical for scalable and maintainable verification. While numerous techniques, e.g.,~\cite{DBLP:journals/iandc/Brookes96,DBLP:conf/amast/Dingel98,DBLP:journals/fac/Dingel02,DBLP:conf/ppdp/Benton0N16,DBLP:journals/corr/abs-1009-2405,DBLP:conf/aplas/DvirKL22,baumann2014ownership,kragl2020verifying}, have been proposed to mitigate this complexity, the potential of epistemic logic---a formalism for reasoning about knowledge---remains largely underexplored in this context. In this paper, we demonstrate how \textit{temporal epistemic logic}, a framework combining \textbf{temporal} and \textbf{epistemic reasoning}, enables modular and compositional verification of concurrent systems.

We achieve this using \textit{past-time temporal epistemic logic}, a well-established framework in distributed systems for reasoning about knowledge and its evolution over time~\cite{DBLP:journals/jacm/AlurHK02,DBLP:conf/podc/HalpernM84,DBLP:conf/focs/Pnueli77,DBLP:conf/pldi/BalliuDG11}. Temporal epistemic logic enriches standard temporal logic with epistemic connectives such as ``$\Knows$'' (usually depicted by $K$). These operators allow reasoning about how an agent's (e.g., a program thread's) local state constrains its knowledge of the global system state. Specifically, the assertion ``thread $A$ $\Knows$ $\phi$'' means that $\phi$ holds in all global states consistent with $A$'s (past) observations. This aligns with the possible-worlds semantics of knowledge, where an agent's knowledge is determined by the set of global states indistinguishable from its local perspective.


To illustrate, consider verifying a concurrent program where threads interact through shared variables. Each thread's actions alter the global state, and synchronization often depends on their evolving knowledge of the system. For instance, a thread may need to assert: ``\textbf{Thread $A$ knows that thread $B$ has not written to variable $x$ since condition $C$ was met}''. Such properties inherently involve both temporal reasoning (e.g., sequencing of events) and epistemic reasoning (e.g., what one thread infers about another's actions). By formalizing such requirements in past-time temporal epistemic logic, we provide a foundation for expressing and verifying synchronization conditions compositionally.

Our work builds on Halpern and Moses' framework~\cite{DBLP:conf/ijcai/HalpernM85} for reasoning about distributed processes, augmenting it with past-time temporal operators (e.g., ``since'', ``previously at'') to capture the historical context of thread interactions. This allows threads to reference their observational history when establishing knowledge, enabling precise reasoning about interference. For example, a thread can derive that it ``$\Knows\;\; \phi$'' by analyzing its own past observations, avoiding global reasoning about all possible interleavings. Such isolation of thread-specific knowledge conditions enables local proofs of correctness that can be combined to infer global system properties, thus achieving modularity.

In this paper, we outline the formal semantics of our logic, describe a proof system for reasoning about concurrent programs, prove its soundness, and demonstrate its application through examples\footnote{Partial mechanization and verification of the base logic in Isabelle/HOL is available at \url{https://github.com/FMSecure/pttel-theory}}. We additionally show how our framework can be integrated with the rely-guarantee reasoning~\cite{DBLP:phd/ethos/Jones81} to specify and verify properties of shared variable concurrent programs in a modular and compositional manner. Overall, leveraging the expressiveness of past-time temporal epistemic logic, our aim is to provide a rigorous foundation for the verification of concurrent systems.

\subsection{Related Work}
The verification of concurrent programs has been extensively studied, with approaches ranging from separation logic~\cite{DBLP:conf/concur/OHearn04} to rely-guarantee~\cite{DBLP:phd/ethos/Jones81} reasoning.
The PhD theses of Baumann and Bernhard~\cite{baumann2014ownership,kragl2020verifying} give
an overview of various techniques used in the verification of concurrent programs, including techniques beyond the scope of epistemic logic.  
Here, we only focus on those studies that have used epistemic logic for concurrent program verification.

\paragraph{Temporal Logic and Compositionality}
Temporal logic, introduced by Pnueli~\cite{DBLP:conf/focs/Pnueli77,DBLP:books/daglib/0080029} for reactive systems, has been widely adopted in concurrency. However, traditional linear-time (LTL) and branching-time (CTL)~\cite{DBLP:conf/lop/ClarkeE81} logics lack epistemic modalities, precluding assertions about what threads know based on their local states. 

\paragraph{Epistemic Logic in Concurrency Verification}
Epistemic logic~\cite{hintikka1962knowledge} originated as a framework for modeling knowledge in multi-agent systems, with applications in game theory, economics, distributed systems, and artificial intelligence. Halpern and Moses pioneered its use in distributed computing with their seminal work on common knowledge ~\cite{DBLP:conf/podc/HalpernM84,DBLP:journals/jacm/HalpernM90}, which formalizes conditions under which agreement protocols can achieve consensus. Their ideas inspired extensions to probabilistic settings~\cite{DBLP:conf/podc/HalpernT89}, zero-knowledge protocols~\cite{DBLP:conf/stoc/HalpernMT88}, and broader applications in multi-agent coordination~\cite{DBLP:conf/podc/NeigerT87,DBLP:conf/wdag/NeigerT90,DBLP:conf/podc/PanangadenT88}. Fagin et al.~\cite{DBLP:books/mit/FHMV1995} later systematized these concepts in a textbook, making epistemic logic a cornerstone of knowledge representation.

In the concurrency verification domain, there are only a few works that explored the usage of the epistemic logic for reasoning about the correctness of multi-threaded programs, e.g.,~\cite{DBLP:phd/hal/Knight13,DBLP:conf/forte/ChadhaDK09,DBLP:conf/lpar/DechesneMO07}. Notable contributions include the work by Chadha, Delaune, and Kremer~\cite{DBLP:conf/forte/ChadhaDK09} that proposed an epistemic logic for a variant of the $\pi$-calculus that is particularly tailored for modeling cryptographic protocols. Their work focuses on reasoning about epistemic knowledge, especially in the context of security properties such as secrecy and anonymity. Dechesne et al.~\cite{DBLP:conf/lpar/DechesneMO07} explored the relation of operational semantics and epistemic logic using labeled transition systems. Similarly, Knight~\cite{knight2013epistemic} studied the use of epistemic modalities as programming constructs within a process calculus, developed a dynamic epistemic logic for analyzing knowledge evolution in labeled transition systems, and introduced a game semantics for concurrent processes that allows for modeling agents with varying epistemic capabilities.

Also, Van der Hoek et al.~\cite{DBLP:conf/rex/HoekHM92} contributed to this discourse. Their work extends Halpern et al.~\cite{DBLP:conf/ijcai/HalpernM85,DBLP:journals/jacm/HalpernM90} work on distributed systems to facilitate the verification of concurrent computations using partially ordered sets of action labels. They employed a variant of Hoare's~\cite{DBLP:journals/cacm/Hoare78} communicating sequential processes (CSP) as a case study to show the application of their theoretical framework. 

