\section{Preliminaries}
\label{sec:ModelStructure}
We begin by introducing the preliminaries required to understand the contribution of this work.

Let $f:A\rightarrow B$ be a mapping and $A'\subseteq A$. Then $f\Restrict A':A' \rightarrow B$ restricts the domain of $f$ to $A'$.
Also, let $[i,j]$, $i\leq j$, be the interval $\{k\mid i\leq k \leq j\}$.

%
We denote a shared resource, featureless for now, by $\store\in\Store$. Later we instantiate it with the shared memory. We denote thread id's (or tid's) by $\tid$ and a set of \emph{control states} by $\Ctl$. \emph{Thread configurations} $\config\in\Configs$ have the shape $\langle\tid,c\rangle$ where $c\in \Ctl$. 
We define a local \textit{next state} as a total function $\Next:\Configs \times \Store \rightarrow \Configs \times \Store$, and assume that the
this function is not the identity on any command, that is, for all $c$, $\store$, if $\Next(c,\store) = \langle c',\store'\rangle$ then $c\neq c'$. This property allows us to easily detect when a thread performs a computation step and is trivially valid in any of the program models we consider later.

A \emph{state} is a structure $\state = \config_{\tid_1} \parallel \cdots \parallel \config_{\tid_n}\parallel \store \in \State$ where $\parallel$ is assumed to be commutative and associative (on configurations), and $\config_{\tid_i}=\langle \tid_i,c_i\rangle$ such that thread id's are unique, i.e. $i\neq j$ implies $\tid_i\neq \tid_j$. Let $\Control(\state,\tid)$ be a function that returns the control state $c$ associated with thread id $\tid$ in $\state$. Also, (with a little misuse of notation) let $\store(\state)$ to extract the shared resource from $\state$. Then, the local transition structure is extended to global states by the condition:

\[
\begin{array}{c}
\Next(\config_{\tid_i},\store) = \langle \config_{\tid_i}',\store'\rangle \\ \hline
\config_{\tid_1} \parallel \cdots \parallel \config_{\tid_i} \parallel \cdots \parallel \config_{\tid_n}\parallel \store\ \TransRel\
\config_{\tid_1} \parallel \cdots \parallel \config_{\tid_i}' \parallel \cdots \parallel \config_{\tid_n}\parallel \store'
\end{array}
\]
which represents a \textit{statically parallel asynchronous interleaving} model.
Our transition relation determines a set of  \textit{computation paths}, or \textit{runs}, $\pi:\omega \rightarrow \State$, which are all paths
generated by the transition relation. For $i\in\omega$, we call the state $\pi(i)$ a \emph{point} of $\pi$. 
Also, we assume for now that the transition relation is total so we do not have to consider terminating runs, and we assume
weak fairness so that all threads are scheduled infinitely often along each run. Considering these assumptions, we write all points $\pi(i)$ of a run
$\pi$ in the form $\langle\tid_1,c_{1,i}\rangle \parallel \cdots \parallel \langle\tid_n,c_{n,i}\rangle\parallel \store_i$ and we refer to $c_{j,i}$ as $\Control(\pi,\tid_j,i)$ where $\store_i$ is $\store(\pi,i)$.

We additionally need to define the concept of a \emph{previous thread state}. To this end, let $i\in\omega$ and $\tid=\tid_k$. Then,
thread $\tid$'s previous state (relative to the index $i$) is a run index $j<i$ such that 
$\Next_{\tid}(c_{k,j},\store_j) = \langle c_{k,j+1},\store_{j+1}\rangle$ and for all $l:j<l<i$, $c_{k,l} = c_{k,l+1}$. In other words, thread $\tid$'s previous state is the execution point at which thread $\tid$ last performed a transition.

The observation \textit{history} of thread $\tid$ in run $\pi$ is a pair of mappings $h_{\pi,\tid}:\omega\rightarrow\Ctl$ and $f:\omega \rightarrow \omega$, where $f$ takes run indices to history indices, such that:
\begin{enumerate}
\item $h(f(i)) = \Control(\pi(i),\tid)$
\item If $\Control(\pi(i),\tid) = \Control(\pi(i+1),\tid)$ (i.e., $\tid$ is not scheduled) then $f(i) = f(i+1)$
\item If $\Control(\pi(i),\tid) \neq \Control(\pi(i+1),\tid)$ then $f(i+1) = f(i) + 1$
\end{enumerate}

The fairness assumption ensures that $h$ is well-defined. We usually elide $f$ and let $\History(\pi,\tid)$ be the history pair $\langle h,f\rangle$.
A \textit{point} for a given run $\pi$ and thread $\tid$ is a pair $\point = \langle h,i\rangle$ such that $h$ is an observation history of $\tid$ in $\pi$.
