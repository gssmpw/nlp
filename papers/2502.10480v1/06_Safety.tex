\section{Safety Assurances}
Figure~\ref{fig:arch_flow} outlines the process of achieving a safe relocation of TPODS module on a tumbling RSO. As discussed in the previous section, the first step is to generate fuel-optimal relocation trajectories with an ellipsoidal keep-out-constraint. Once such trajectories are obtained, a model predictive controller (MPC) is leveraged to command each module to follow their respective reference trajectories \cite{parikh2024rapidtrajectoryoptimizationcontrol}. To avoid colliding with the RSO and another TPODS module, two different modalities have been considered, and are presented in the following subsections.

\subsection{Trajectory following with MPC}
The primary control mechanism that enables individual modules to follow the predefined reference trajectory is a linear MPC \cite{parikh2024rapidtrajectoryoptimizationcontrol}. A simplified double integrator dynamics with the discrete state-space model
\begin{align}\label{eq:EOM_d}
    \bm{x}_{k+1} &= \boldsymbol{A}_d\boldsymbol{x}_k + \boldsymbol{B}_d\boldsymbol{u} \\
    \bm{y}_{k} &=  \boldsymbol{C}_d\boldsymbol{x}_k
\end{align}
is considered to control each TPODS. The desired force in each translational degree of freedom constitutes the control input $\boldsymbol{u}$. The optimization problem which is being solved at each receding horizon is 
\begin{equation}\label{eq:L2_min}
    \min_{\boldsymbol{u}_{k+i}\in \mathbb{R}^{m}} \sum_{i=0}^{p-1} \Big(\boldsymbol{u}^{\top}_{k+i}\boldsymbol{W}_u\boldsymbol{u}_{k+i}\ +  \left(\boldsymbol{y}_{k+i+1}-\boldsymbol{y}_r\right)^{\top}\boldsymbol{W}_y\left(\boldsymbol{y}_{k+i+1}-\boldsymbol{y}_r\right)\Big)
\end{equation}
where the state $\boldsymbol{y}$ can be related to the initial input and control history using the following recursion
\begin{equation}\label{eq:state_eq_comb}
    \begin{bmatrix}
    y(k+1)\\
    y(k+2)\\
    \vdots \\
    y(k+p)\\
    \end{bmatrix} =
    \begin{bmatrix}
    \boldsymbol{A}_d\\
    \boldsymbol{A}^2_d\\
    \vdots \\
    \boldsymbol{A}^p_d\\
    \end{bmatrix} \boldsymbol{x}_k +
    \begin{bmatrix}
    \boldsymbol{B}_d & 0 & \hdots & 0\\
    \boldsymbol{B}_d\boldsymbol{A}_d & \boldsymbol{B}_d & \hdots & 0 \\
    \vdots & \vdots & \ddots & 0\\
    \boldsymbol{B}_d\boldsymbol{A}^{p-1}_d & \boldsymbol{B}_d\boldsymbol{A}^{p-2}_d & \hdots & \boldsymbol{B}_d\\
    \end{bmatrix}\begin{bmatrix}
    u(k)\\
    u(k+1)\\
    \vdots \\
    u(k+p-1)\\
    \end{bmatrix}
\end{equation}
compactly written by,
\begin{equation}\label{eq:state_compact}
   \boldsymbol{y}  = \boldsymbol{S}_x \boldsymbol{x}_k + \boldsymbol{S}_y \boldsymbol{u}
\end{equation}
Substitution of Equation \ref{eq:state_compact} in the optimization problem defined by Equation \ref{eq:L2_min} results in the following quadratic program
\begin{equation}\label{eq:QP_aug_inp}
    \min_{\boldsymbol{u}\in \mathbb{R}^{p*m}, \nspace{1}\epsilon} \boldsymbol{u}^{\top}\boldsymbol{W}_u\boldsymbol{u} + \boldsymbol{u}^{\top}\boldsymbol{S}^{\top}_u\boldsymbol{W}_y\boldsymbol{S}_u\boldsymbol{u} + 2\left( \boldsymbol{x}_k\boldsymbol{S}^{\top}_x\boldsymbol{W}_y\boldsymbol{S}_u\boldsymbol{u} - \boldsymbol{y}^{\top}_r\boldsymbol{W}_y\boldsymbol{S}_u\boldsymbol{u}\right) + \rho \epsilon^2
\end{equation}
subject to
\begin{align*}
\boldsymbol{u}-V^u_{max}\epsilon &\leq \boldsymbol{u}_{max}\\
-\boldsymbol{u}-V^u_{min}\epsilon &\leq -\boldsymbol{u}_{min}\\
\boldsymbol{S}_u\boldsymbol{u}-V^y_{max}\epsilon &\leq \boldsymbol{y}_{max}-\boldsymbol{S}_x\boldsymbol{x}_k\\
-\boldsymbol{S}_u\boldsymbol{u}-V^y_{min}\epsilon &\leq -\boldsymbol{y}_{min}+\boldsymbol{S}_x\boldsymbol{x}_k
\end{align*}
where $\rho$ is a weighting factor for slack variable $\epsilon$ and $V^u_{max}$,$V^u_{min}$,$V^y_{max}$ and $V^y_{min}$ regulate the softness of the constraint. The computed control input is then converted to respective thrust commands and passed to the simulation framework to update the states of the module. 

\subsection{Differentiable Collision Detection for Polytopic Hulls}\label{sec:DCOL}

Approximating intricate volumetric shapes with ellipsoidal outlines is commonly employed to incorporate KOC's, often guaranteeing safe motion. However, this requires a conservative approximation of the original body. An alternative is to use the actual polytopic shape of the RSO to execute differential collision detection for convex polytopes (DCOL) instead of relying on ellipsoidal approximations \cite{DCOL}. This collision detection strategy offers a reliable and efficient means to implement KOC's \cite{DCOL,Sow2024ACF}. DCOL-based collision detection operates by enlarging the polytopic convex hulls of both the target and chaser using a scaling factor $s$. If $s$ exceeds one, the two bodies remain apart. For any collection of polytopes, the smallest $s$ can be determined by solving a linear programming problem with inequality constraints, derived from the condition that the intersection lies within both expanded polytopes.

\begin{figure}[!t]
\centerline{\includegraphics[width=\textwidth]{Figures/MPC_flow.png}}
\caption{Collision avoidance using MPC and polytopic hulls}
\label{fig:MPC_flow}
\end{figure}

The overall flow diagram of the reference trajectory following, collision detection and avoidance is presented in Figure~\ref{fig:MPC_flow}. The optimization framework first solves the quadratic program defined by Equation~\ref{eq:QP_aug_inp} without consideration of collision avoidance. For the computed control history, a collision detection based on the expanding polytopes is performed. If a collision is detected for any instance in the chosen control horizon, the following optimization problem is solved again to compute $\dif{\bm{u}}$ with a constraint to ensure the desired separation.
\begin{align}
    \min_{\bm{u},\dif{\bm{u}},\boldsymbol{\varepsilon}} \qquad &\lvert|\bm{u} + \dif{\bm{u}}|\rvert_2 + \lvert|\boldsymbol{y}-\boldsymbol{y}_{r}|\rvert_2 + \rho\varepsilon^2 \\
    \text{s.t.} \qquad \bm{x}_{k+1} &= \boldsymbol{A}_d\boldsymbol{x}_k + \boldsymbol{B}_d\left( \bm{u} + \dif{\bm{u}} \right)&\\
    \bm{u}_{\max} &\geq \lvert\bm{u}+\dif{\bm{u}}\rvert \\
    s_\text{thr} &\leq s + \pdv{s}{\bm{r}_c} \pdv{\bm{r}_c}{\left(\bm{u}+\dif{\bm{u}}\right)} + \rho \varepsilon 
\end{align}
Here, $\bm{r}_c$ is the position of the active TPODS and it is assumed that the TPODS only undergoes translation motion to avoid collision with other objects.
\subsection{Planar Collision Avoidance}
\begin{figure}[t!]
     \begin{subfigure}[b]{0.49\textwidth}
        \centering
         \includegraphics[width=\textwidth]{Figures/col_traj_2D.eps}
         \caption{Reference motion}\label{fig:col_traj_2D_a}
     \end{subfigure}   
     \begin{subfigure}[b]{0.49\textwidth}
        \centering
         \includegraphics[width=\textwidth]{Figures/col_traj_2D_with_CA.eps}
         \caption{Trajectories with active collision avoidance}\label{fig:col_traj_2D_b}
     \end{subfigure}
     \centering
    \caption{Collision avoidance with DCOL for planar motion}
\end{figure}

While the DCOL framework has been shown to work well for avoiding stationary obstacles \cite{parikh2024rapidtrajectoryoptimizationcontrol,DCOL}, it has certain limitations when avoiding dynamic objects. To highlight this, a planar example has been presented in Figure~\ref{fig:col_traj_2D_a}. The numerical value below each silhouette depicts the time instance at which the position of the module is shown. The objective here is to implement the DCOL framework to avoid collision of two agents as they cross paths. As seen from Figure~\ref{fig:col_traj_2D_a}, the two trajectories are picked such that they pass through the same point in space-time, resulting in a collision of two modules. When the DCOL framework is applied to avoid collision between two modules, as seen from Figure~\ref{fig:col_traj_2D_b}, the modules deviate from their respective reference trajectories to avoid the collision. However, due to the nature of reference trajectories and symmetry of the motion, the deviation results in a deadlock scenario where each module is momentarily stuck in their current position. It is important to note that for real-world applications the uncertainty associated with the pose of each module will cause the deadlock to break. However, the scenario presented here highlights one of the avenues where the DCOL framework is not efficient. 

\begin{figure}[!b]
\centerline{\includegraphics[width=1\textwidth]{Figures/DCOL_CA_TPODS.eps}}
\caption{TPODS-TPODS and TPODS-RSO Collision avoidance with DCOL}
\label{fig:DCOL_CA_TPODS}
\end{figure}

The performance of the collision avoidance maneuver is further deteriorated in the case of head-on collisions. In Figure~\ref{fig:DCOL_CA_TPODS} one such scenarios is presented. It can be observed that in the process of avoiding a collision with the magenta TPODS, the brown TPODS gets ahead of the magenta TPODS. However, the desired direction of motion for both TPODS are opposite. This results in the magenta TPODS being dominant in the pair and the brown TPODS almost follows the reference trajectory for the magenta TPODS for a significant duration. Finally, the brown TPODS is able to break this dominance and proceed towards it's reference trajectory. This underscores the deficiency of the DCOL-based collision avoidance approach in preventing head-on collisions. 

As an alternative to collision avoidance maneuvers, an intricate phasing scheme can also be employed. The relative distance between two modules can be formulated as a function of their initial time separation. Once a collision is detected by the algorithm, an optimization subroutine tries to adjust the initial phasing time such that the resulting relative motion of the modules is collision free. This is achieved by minimizing the area of the relative distance curve below a predefined threshold. The proposed approach is applied to the example motion of Figure~\ref{fig:col_traj_2D_a}. For the unmodified reference trajectories, a collision is imminent if both modules start their motion at the same time. This can be observed in Figure~\ref{fig:col_traj_2D_with_phase_b} as the relative distance curve drops below the predefined threshold for a significant duration. An optimization subroutine computes the initial time separation needed to ensure that the area of relative distance curve below the threshold is nullified. As presented in Figure~\ref{fig:col_traj_2D_with_phase_b}, this results in a modified trajectory which is collision free. 

Figure~\ref{fig:col_traj_2D_with_phase_a} underscores the effectiveness of this approach by comparing the motion of the two modules. It can be observed that both modules reach a similar position, separated by a large time difference. While this approach is effective in preventing collision and does not require additional corrective maneuvers, it does not scale well with multiple modules and requires planning before the motion is initiated. Hence a CBF approach is explored as an alternative to resolve inter-module collisions and is presented in the following subsections.

\begin{figure}[t!]
     \begin{subfigure}[b]{0.51\textwidth}
        \centering
         \includegraphics[width=\textwidth]{Figures/col_traj_2D_with_phase.eps}
         \caption{Motion of modules with initial time phasing}\label{fig:col_traj_2D_with_phase_a}
     \end{subfigure}   
     \begin{subfigure}[b]{0.48\textwidth}
        \centering
         \includegraphics[width=\textwidth]{Figures/rel_dist_2D_with_phase.eps}
         \caption{Relative distance history}\label{fig:col_traj_2D_with_phase_b}
     \end{subfigure}
     \centering
    \caption{Collision prevention using phasing for planar motion}
\end{figure}

\subsection{Control Barrier Functions} \label{sec:cbf}
This section introduces concepts necessary for making claims on collision-free motion of the TPODS modules. Control barrier functions (CBFs) are introduced in a deterministic setting. Consider a nonlinear control affine dynamical system modeled as
\begin{align} \label{eq:affine-dynamics}
    \dot{\boldsymbol{x}} = f(\boldsymbol{x}) + g(\boldsymbol{x})\boldsymbol{u},
\end{align}
where $f:\mathcal{X} \rightarrow \mathbb{R}^n$ and $g:\mathcal{X} \rightarrow \mathbb{R}^{n \times m}$ are Lipschitz continuous functions, $\boldsymbol{x} \in \mathcal{X} \subseteq \mathbb{R}^n$ represents the state vector, and $\boldsymbol{u} \in \mathcal{U} \subseteq \mathbb{R}^m$ represents the control vector. $\mathcal{X}$ is the set of all possible states and $\mathcal{U}$ is the admissible control set.

In the context of CBF-based safety, we define safety as a region of the state space, known as the safe set $\Cs$, within which the dynamical system must stay. Safe controllers are ones that render this safe set forward invariant.

\begin{definition}[Forward invariance] \label{def:forward_inv}
A set $\mathcal{C} \subset \mathbb{R}^n$ is \textit{forward invariant} for a dynamical system defined by \eqref{eq:affine-dynamics} if $\boldsymbol{x}(0) \in \mathcal{C} \implies \boldsymbol{x}(t) \in \mathcal{C}, \,$ for all $t > 0$.
\end{definition}

Now, consider the safe set $\Cs$ as the 0-superlevel set of a continuously differentiable function $h : \mathcal{X} \rightarrow \mathbb{R}$ where
\begin{align} \label{eq:safeset}
    \Cs \triangleq \{\boldsymbol{x} \in \mathcal{X} : h(\boldsymbol{x}) \ge 0\}, \\ \partial\Cs \triangleq \{ \boldsymbol{x} \in \mathcal{X} : h(\boldsymbol{x})=0 \}, \\
    \text{Int}(\Cs) \triangleq \{\boldsymbol{x} \in \mathcal{X} : h(\boldsymbol{x}) > 0 \}. \label{eq:safeset2}
\end{align}
It is assumed that for this function, $\partial h/\partial \boldsymbol{x}(\boldsymbol{x}) \neq 0$ for all $\boldsymbol{x} \in \partial \Cs$, and that $\text{Int}(\Cs) \neq \emptyset$, and $\overline{\text{Int}(\Cs)} = \Cs$.
\begin{definition}[Control barrier function \cite{ames_2017}] \label{def:cbf}
    Given a set $\Cs$ defined by \eqref{eq:safeset}$-$\eqref{eq:safeset2} a function $h : \mathcal{X} \rightarrow \mathbb{R}$ is a control barrier function (CBF) if there exists a class-$\mathcal{K}_{\infty}$ function $\alpha$\footnote{$\alpha : \mathbb{R}_{\ge 0} \rightarrow \mathbb{R}_{\ge 0}$ is a class-$\mathcal{K}_{\infty}$ function if it is continuous, $\alpha(0)=0$ and $\text{lim}_{x \rightarrow \infty} \nspace{2}\alpha(x) = \infty$.} such that for all $\boldsymbol{x} \in \Cs$
\begin{equation}\label{eq:cbf_condition1}
    \sup_{\boldsymbol{u} \in \mathcal{U}} \dot{h}(\boldsymbol{x},\boldsymbol{u}) \triangleq \underbrace{\nabla h(\boldsymbol{x}) f(\boldsymbol{x})}_{ L_f h(\boldsymbol{x})} + \underbrace{\nabla h(\boldsymbol{x}) g(\boldsymbol{x})}_{L_g h (\boldsymbol{x})}\boldsymbol{u} \ge  -\alpha(h(\boldsymbol{x})),
\end{equation}
where $L_f$ and $L_g$ are Lie derivatives of $h$ along $f$ and $g$, respectively.
\end{definition}
Next, we arrive at the main result of \cite{ames_2017}, relating CBFs and forward invariance to safety.
\begin{theorem}[\cite{ames_2017}] \label{thm: cbf}
Given a set $\Cs \subset \mathbb{R}^n$ defined by \eqref{eq:safeset}$-$\eqref{eq:safeset2} for a continuously differentiable function $h$, if $h$ is a CBF on $\Cs$ then any locally Lipschitz continuous controller $k:\mathcal{X} \rightarrow \mathcal{U}$, $\boldsymbol{u}=k(\boldsymbol{x})$ satisfying 
\begin{align} \label{eq: cbf_condition}
    L_f h(\boldsymbol{x}) + L_g h (\boldsymbol{x}) \boldsymbol{u} \ge -\alpha(h(\boldsymbol{x}))
\end{align}
for all $\boldsymbol{x} \in \Cs$ will render the set $\Cs$ forward invariant.
\end{theorem}

For the nonlinear affine system \eqref{eq:affine-dynamics}, the sufficient condition for forward invariance of the safe set is linear in the control, often motivating the use of CBFs to supply safety constraints to a quadratic program (QP). For an arbitrary primary controller, $\boldsymbol{u}_{\rm p} \in \mathcal{U}$ (e.g., the output of an MPC controller for instance), it is possible to ensure the safety of \eqref{eq:affine-dynamics} by solving the following point-wise optimization problem for the safe control, $\boldsymbol{u}_{\rm safe}$:
\begin{align} 
% \begin{gathered} 
    \boldsymbol{u}_{\rm safe} = \underset{\boldsymbol{u} \in \mathcal{U}}{\text{argmin}} \mkern9mu & \frac{1}{2}\left\Vert \boldsymbol{u}_{\rm p}-\boldsymbol{u}\right\Vert^{2}
    % \quad \quad \quad \quad  (\text{CBF-QP})
    \tag{CBF-QP} \label{eq:cbf-qp} \\
    % \quad \quad \quad \quad
    \text{s.t.} \quad & L_f h(\boldsymbol{x}) + L_g h (\boldsymbol{x}) \boldsymbol{u} \ge -\alpha(h(\boldsymbol{x})). \nonumber
% \end{gathered}
\end{align}
This \eqref{eq:cbf-qp} is thus a \textit{point-wise} optimal safe control with respect to the cost function $\left\Vert \boldsymbol{u}_{\rm p}-\boldsymbol{u}\right\Vert^{2}$, solving for the safe control which is closest to the desired control $\boldsymbol{u}_{\rm p}$ at any time instance. Because only a single QP must be solved at every time instance, the CBF approach provides a computationally efficient solution to safe control.

\subsection{Multi-agent Collision Avoidance with CBFs}
%
% \todo{cite the paper on multi-agent collision avoidance for multi-agent using the braking distance, write out formulation for our case that i derived, and also cite the papers on inspection and JAIS which use this concept}
%
Using the framework of CBFs, it is possible to develop a set of state constraints which, when enforced, guarantee safety of multiple planar TPODS agents simultaneously. The dynamics of agent $i$ in a swarm of $N$ TPODS with mass $m$ is written as 
\begin{align}
    \begin{bmatrix}
        \dot{\boldsymbol{x}}_i \\
        \dot{\boldsymbol{v}}_i
    \end{bmatrix}
    =
    \begin{bmatrix}
        \boldsymbol{0} & \boldsymbol{I}_{2\times2} \\
        \boldsymbol{0} & \boldsymbol{0}
    \end{bmatrix}
    \begin{bmatrix}
        {\boldsymbol{x}}_i \\
        {\boldsymbol{v}}_i
    \end{bmatrix}
    + 
    \begin{bmatrix}
        \boldsymbol{0} \\
        \frac{\boldsymbol{I}_{2\times2}}{\sqrt{2}m}
    \end{bmatrix} \boldsymbol{u}_i
\end{align}
where $\boldsymbol{u}_i$ is the control force for the TPODS $i$ with $\norm{\boldsymbol{u}_i} \leq u_{\rm max}$. As done in \cite{BORRMANN201568}, one can develop a safety constraint for each TPODS pair by considering the maximum braking distance for each agent. We denote the relative position between agent $i$ and another agent $j$ as $\Delta \boldsymbol{x}_{ij} = \boldsymbol{x}_i - \boldsymbol{x}_j$ and the relative velocity as $\Delta \boldsymbol{v}_{ij} = \boldsymbol{v}_i - \boldsymbol{v}_j$. The desired safety constraint should ensure that each agent always keeps at least a distance $D_{\rm s}$ between each other. The pairwise safety constraint which satisfies such a criterion is written as
\begin{align}
    h_{1,ij} \triangleq \underbrace{\frac{\Delta \boldsymbol{x}_{ij}^{\top}}{\norm{\Delta \boldsymbol{x}_{ij}}}\Delta \boldsymbol{v}_{ij}}_{\Bar{\boldsymbol{v}}_{ij}} + \sqrt{2\Delta u_{\rm max}(\norm{\Delta \boldsymbol{x}_{ij}} - D_{\rm s})}, \nspace{4} \forall \nspace{1} i \neq j
\end{align}
where $\Delta u_{\rm max} = 2 u_{\rm max}$ indicates the maximum \textit{combined} braking force two agents can apply. For the planar relocation example, $D_{\rm s} = 2r_{\rm p}$ where the TPODS geometry of a square with side length $L$ is over-approximated as a circle of radius $r_{\rm p} = \frac{\sqrt{2}}{2}L$. Note that this condition only needs to be enforced when the agents are moving towards each other (i.e., when $\Bar{\boldsymbol{v}}_{ij}< 0$). Applying \Cref{thm: cbf}, the forward invariance condition for pairwise agent safety becomes
\begin{align} \label{eq: cbf_planar}
    \nabla h_{1,ij} \boldsymbol{\cdot}
    \begin{bmatrix}
        \Delta \boldsymbol{v}_{ij} \\
        \frac{\boldsymbol{I}_{2\times2}}{\sqrt{2}m} \Delta \boldsymbol{u}_{ij}
    \end{bmatrix}
    \geq -\alpha_{1}(h_{1,ij})
\end{align}
where $\Delta \boldsymbol{u}_{ij} = \boldsymbol{u}_i - \boldsymbol{u}_j$ and the gradient of $h_{1,ij}$ is
\begin{align*}
    \nabla h_{1,ij} = 
    % \bigg[
    \begin{bmatrix}
        \begin{bmatrix}
                    \Delta\boldsymbol{v}_{i j}^{\top}\left(\frac{\boldsymbol{I}_{2\times2}}{\left\|\Delta \boldsymbol{x}_{i j}\right\|}-\frac{\left(\Delta \boldsymbol{x}_{i j}\right)\left(\Delta \boldsymbol{x}_{i j}\right)^{\top}}{\left\|\Delta \boldsymbol{x}_{i j}\right\|^3}\right) + \left(2 \Delta u_{\rm max}\left(\left\|\boldsymbol{x}_{i j}\right\|- D_{\rm s
                    }\right)\right)^{-\frac{1}{2}} \cdot \frac{\Delta \boldsymbol{x}_{i j}^{\top}}{\left\|\Delta \boldsymbol{x}_{i j}\right\|} \Delta u_{\rm max}
        \end{bmatrix},
        \begin{bmatrix}
            \frac{\Delta \boldsymbol{x}_{ij}^{\top}}{\norm{\Delta \boldsymbol{x}_{ij}}}
        \end{bmatrix}
    \end{bmatrix}
    % \bigg]
\end{align*}
Thus \eqref{eq: cbf_planar} provides a linear constraint on $\boldsymbol{u}_i$ and $\boldsymbol{u}_j$ which guarantees safety of agent $i$ and $j$. This formulation therefore is a centralized control solution, as all safe control actions for all agents are selected simultaneously according to \eqref{eq: cbf_planar}.

% \todo{Please populate this with few lines : I am adding the trajectory and comparison of states for DCOL vs CBF in planr collision avoidance}

\subsection{Planar Collision Avoidance}

Figure~\ref{fig: CBF_2d_traj} demonstrates the effectiveness of the proposed pairwise CBF constraint for multi-agent collision avoidance. Both agents avoid collision in Figure~\ref{fig:col_traj_2D_b_CBF} and then navigate to their respective targets. Unlike the DCOL-based approach, the CBF constraint considers the maximum braking force of both agents and does not have to perform any phasing subroutines. Because the CBF approach seeks to minimize the deviation between the desired control and the safe control, the resulting motion is often more fuel efficient than other approaches. \Cref{fig:DCOL_vs_CBF_sates} and \Cref{fig:DCOL_vs_CBF_inputs} compare the results for the DCOL approach and the CBF approach. From a visual inspection, one can see that the DCOL framework exhibits motion which makes a more drastic change to the reference, and exhibits significant chattering when the agents approach each other. Indeed, \Cref{tab:planar_compare} shows that the total impulse consumed by the agents using DCOL was over $50$\% more than that of the agents using the CBF constraints. Furthermore, because the CBF agents must only solve a single QP at each time instance, the average computational time for each agent was significantly lower than their DCOL counterparts. These advantages highlight the desire to use CBFs over the DCOL approach for TPODS-TPODS collision avoidance.

\begin{figure}[t!]
     \begin{subfigure}[b]{0.49\textwidth}
        \centering
         \includegraphics[width=\textwidth]{Figures/col_traj_2D.eps}
         \caption{Reference motion}\label{fig:col_traj_2D_a_CBF}
     \end{subfigure}   
     \begin{subfigure}[b]{0.49\textwidth}
        \centering
         \includegraphics[width=\textwidth]{Figures/col_traj_2D_CBF.eps}
         \caption{Trajectories with active collision avoidance}\label{fig:col_traj_2D_b_CBF}
     \end{subfigure}
     \centering
    \caption{Collision avoidance with CBF for planar motion}
     \label{fig: CBF_2d_traj}
\end{figure}

\begin{figure}[!b]
\begin{subfigure}[b]{0.49\textwidth}
    \centering
    \centerline{\includegraphics[width=\textwidth]{Figures/DCOL_vs_CBF_states1.eps}}
    \caption{TPODS1}
\end{subfigure}
\begin{subfigure}[b]{0.49\textwidth}
    \centering
    \centerline{\includegraphics[width=\textwidth]{Figures/DCOL_vs_CBF_states2.eps}}
    \caption{TPODS2}
\end{subfigure}
\caption{Comparison of states for two collision avoidance strategies}
\label{fig:DCOL_vs_CBF_sates}
\end{figure}

\begin{figure}[!h]
\begin{subfigure}[b]{\textwidth}
    \centering
    \centerline{\includegraphics[width=\textwidth]{Figures/DCOL_vs_CBF_inputs.eps}}
    \caption{TPODS1}
\end{subfigure}
\begin{subfigure}[b]{\textwidth}
    \centering
    \centerline{\includegraphics[width=\textwidth]{Figures/DCOL_vs_CBF_inputs2.eps}}
    \caption{TPODS2}
\end{subfigure}
\caption{Comparison of control inputs for two collision avoidance strategies}
\label{fig:DCOL_vs_CBF_inputs}
\end{figure}


\begin{table}
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \multirow{2}{*}{Approach} & \multicolumn{2}{|c|}{Total Impulse [Ns]} & \multicolumn{3}{|c|}{Computational Time [s]} \\
        \cline{2-6}
        & TPODS1 & TPODS2 & Total & Average & Active \\
        \hline
        DCOL & 1.5887 & 1.6854 & 45.9415 & 0.0229 & 0.0914\\
        \hline
        CBF & 1.0065 & 1.0260 & 28.7520 & 0.0144 & 0.0151\\
        \hline
    \end{tabular}
    \caption{Performance comparison of two collision avoidance strategies}
    \label{tab:planar_compare}
\end{table}

\subsection{High-order Control Barrier Functions} \label{sec:HOCBF}

While the standard CBF formulation holds for constraints which have a relative degree of one, complications may arise when the relative degree exceeds one. These cases require additional mathematical machinery to retain actionable safety assurances. 

\begin{definition}[Relative degree \cite{khalil2002nonlinear}]
    The relative degree of a sufficiently differentiable function $h : \mathbb{R}^n \rightarrow \mathbb{R}$ with respect to \eqref{eq:affine-dynamics} is the number of times $h$ must be differentiated along the dynamics of \eqref{eq:affine-dynamics} until the control $\boldsymbol{u}$ appears explicitly in the corresponding derivative.
\end{definition}

For CBF constraints $h$ which have a relative degree greater than one, components of the control may not appear in the condition for forward invariance in \eqref{eq: cbf_condition}, meaning that the safety condition cannot be enforced by the \eqref{eq:cbf-qp}. One method to handle this challenge is through the use of high-order control barrier functions (HOCBFs) \cite{xiaoHOCBF2019,xiao2021high,TanHOCBF_2022}. These require sequentially differentiating the barrier functions to rectify the maximum difference in relative degree. 

As such, consider an $r^{th}$-order differentiable function $h : \mathcal{X} \rightarrow \mathbb{R}$, a dynamical system \eqref{eq:affine-dynamics}, and $r$ sufficiently smooth extended class-$\mathcal{K}$\footnote{A continuous function $\alpha : (-b,a) \rightarrow (-\infty,\infty)$ is an extended class $\mathcal{K}$ function for some $a,b > 0$ if it is strictly increasing and $\alpha(0)=0$.} functions $\alpha_1(\cdot)$, $\alpha_2(\cdot)$, $\cdots$, $\alpha_r(\cdot)$. We define a cascading sequence of functions $\psi_k(\boldsymbol{x})$ where,
\begin{equation} \label{eq:HOCBF_psi}
    \psi_k(\boldsymbol{x}) \triangleq \dot{\psi}_{k-1}(\boldsymbol{x}) + \alpha_k(\psi_{k-1}(\boldsymbol{x})), \quad \forall \nspace{2} k \in \{1, 2,...,r\}
\end{equation}
and $\psi_0(\boldsymbol{x})=h(\boldsymbol{x})$, and $\dot{\psi}_{k-1}(\boldsymbol{x}) = L_f \psi_{k-1}(\boldsymbol{x}) + L_g \psi_{k-1}(\boldsymbol{x}) \boldsymbol{u}$. These functions make up the corresponding sets: $\mathcal{C}_{k} = \{ \boldsymbol{x} : \psi_{k-1}(\boldsymbol{x}) \ge 0\}$. With the above, the high-order control barrier function can be formally defined. 
%  %Consider a $r^{th}$ order differentiable function $h : \mathbb{R}^{n} \rightarrow \mathbb{R}$ 
% Consider again .. (level set construction)

\begin{definition}[High-order control barrier functions \cite{TanHOCBF_2022}] \label{def: hocbf}
    An $r^{th}$-order differentiable function $h : \mathcal{X} \rightarrow \mathbb{R}$ is called a high-order control barrier function (HOCBF) of order $r$ for system \eqref{eq:affine-dynamics} if there exist differentiable extended class-$\mathcal{K}$ functions $\alpha_k$, $\forall \nspace{1} k \in \{1,2,...,r\}$, and an open set $\mathcal{D}$ with $\mathcal{C}_{\rm S} \triangleq \bigcap^{\nspace{1}r}_{\nspace{1}k=1} \mathcal{C}_{k} \subset \mathcal{D} \subset \mathbb{R}^n$, where each $\psi_k$ is given by \eqref{eq:HOCBF_psi} such that the following two conditions are satisfied:
    \begin{enumerate}
        \item $L_g L^{k}_f h(\boldsymbol{x}) = \boldsymbol{0}, \forall \boldsymbol{x} \nspace{1}\in \mathcal{D}$ for $k \in \{ 1,2,\cdots,r - 2\}$.
        \item For all $\boldsymbol{x} \in \mathcal{D},$
            \begin{align}
               \sup_{\boldsymbol{u} \in \mathcal{U}} \psi_r (\boldsymbol{x})  = 
               \sup_{\boldsymbol{u} \in \mathcal{U}} \left[L_f \psi_{r-1}(\boldsymbol{x}) + L_g \psi_{r-1} (\boldsymbol{x}) \boldsymbol{u} + \alpha_r(\psi_{r-1}(\boldsymbol{x}))\right] \geq 0.
            \end{align}
    \end{enumerate}
\end{definition}
Forward of invariance of $\mathcal{C}_{\rm S}$ can be obtained in a manner similar to that of standard CBFs.

\begin{theorem}[Thm. 1 \cite{TanHOCBF_2022}] Consider an HOCBF $h$, $\psi_{k-1}$, $1 \leq k \leq r$ defined in \eqref{eq:HOCBF_psi}. Then any locally Lipschitz continuous controller $\boldsymbol{k} : \mathcal{X} \rightarrow \mathcal{U}, \boldsymbol{u} = k(\boldsymbol{x})$ satisfying
\begin{align}
    L_f \psi_{r-1}(\boldsymbol{x}) + L_g \psi_{r-1} (\boldsymbol{x}) \boldsymbol{u} \geq -\alpha_r(\psi_{r-1}(\boldsymbol{x}))
\end{align}
for all $\boldsymbol{x} \in \mathcal{C}_{\rm S}$ will render the set $\mathcal{C}_{\rm S}$ forward invariant for \eqref{eq:affine-dynamics}.
\end{theorem}
Naturally, for $r = 1$, an HOCBF reduces to a CBF as per \Cref{def:cbf}. Like for the standard CBF, the condition for forward invariance and therefore safety is linear in control and thus a minimally invasive, safe controller can be constructed using HOCBFs. The safe control which minimizes the deviation from an arbitrary primary controller, $\boldsymbol{u}_{\rm p} \in \mathcal{U}$, is denoted $\boldsymbol{u}_{\rm safe}$:
\begin{align} 
% \begin{gathered} 
    \boldsymbol{u}_{\rm safe} = \underset{\boldsymbol{u} \in \mathcal{U}}{\text{argmin}} \mkern9mu & \frac{1}{2}\left\Vert \boldsymbol{u}_{\rm p}-\boldsymbol{u}\right\Vert^{2}
    % \quad \quad \quad \quad  (\text{CBF-QP})
    \tag{HOCBF-QP} \label{eq:hocbf-qp} \\
    % \quad \quad \quad \quad
    \text{s.t.} \quad & L_f \psi_{r-1}(\boldsymbol{x}) + L_g \psi_{r-1} (\boldsymbol{x}) \boldsymbol{u} \geq -\alpha_r(\psi_{r-1}(\boldsymbol{x})). \nonumber
% \end{gathered}
\end{align}

\subsection{Multi-agent Collision Avoidance with HOCBFs}

The following sections describe the safety constraints which are the basis for the HOCBFs used to enforce safety for the 3D multi-agent relocation case.

\subsubsection{TPODS-RSO Constraint}

First, consider the constraint describing TPODS to RSO collision avoidance. Each TPODS cube with length $L$ is approximated as a sphere with radius $r_{\rm s}=\frac{\sqrt{3}}{2}L$. Recalling that the RSO is modeled as an ellipsoidal mass, its surface can be described as
\begin{align}
    \frac{x^2}{a^2} + \frac{y^2}{b^2} + \frac{z^2}{c^2} = 1
\end{align}
where are $x$, $y$, and $z$ are coordinates in the RSO reference frame. Thus, TPODS to RSO safety will be guaranteed as long as the following inequality holds for all times:
\begin{align} \label{eq:koz}
    h_{\rm koz}(\boldsymbol{x}^{\mathcal{B}}) \triangleq \frac{x^2}{(a+r_{\rm s})^2} + \frac{y^2}{(b+r_{\rm s})^2} + \frac{z^2}{(c+r_{\rm s})^2} - 1 \geq 0
\end{align}
where $x$, $y$, and $z$ describe the position of the TPODS module in the RSO reference frame. Because this is a relative degree two constraint, HOCBFs must be used to enforce safety. The control constraints for the TPODS-RSO collision avoidance can therefore be obtained by employing the sequential differentiation described in \eqref{eq:HOCBF_psi}, with $\psi_0(\boldsymbol{x}) = h_{\rm koz}(\boldsymbol{x})$, taking care to apply derivatives in the RSO-fixed frame.

\subsubsection{TPODS-TPODS Constraint}

Using the same over-approximation of the TPODS geometry, the inter-agent constraint can be described simply with 
\begin{align} \label{eq:h_tpods_tpods}
    h_{{\rm ca},ij}(\boldsymbol{x}_{ij}^{\mathcal{B}}) \triangleq (x_i - x_j)^2 + (y_i - y_j)^2 + (z_i - z_j)^2 - (2r_{\rm s})^2
\end{align}
for each unique $ij$ pair with $i \neq j$ where $\boldsymbol{x}_{k}^{\mathcal{B}}$ represents the $k^{th}$ agent's states in the RSO frame and $\boldsymbol{x}_{ij}^{\mathcal{B}} \triangleq [(\boldsymbol{x}_{i}^{\mathcal{B}})^{\top}, (\boldsymbol{x}_{j}^{\mathcal{B}})^{\top}]^{\top}$. Safety is guaranteed if $h_{{\rm ca},ij} \geq 0$ for each TPODS pair at all times. Because the constraints are again only on the position level, the relative degree is two and HOCBFs must be used to enforce TPODS-TPODS collision avoidance. Since $h_{{\rm ca},ij}$ generates control constraints for each unique TPODS pair, the technique may not scale to a large number of agents. For multiple simultaneous collisions, control constraints obtained from sequentially differentiating \eqref{eq:h_tpods_tpods} may result in infeasibility, especially in the presence of actuator constraints. For the number of agents considered in the relocation mission, we did not observe such complications.