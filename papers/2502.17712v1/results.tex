\section{Results and Validation}
\label{sec:results}
\label{sec:eval}

We evaluate the suitability of FastAtlas for TSS applications by assessing both baseline texture-space shading settings (one-to-one texel-to-pixel shading rate) and settings reflective of potential decoupled shading application categories: using atlases to control per-frame sampling rates and streaming shading across networks. Figs. \ref{fig:alg_overview} and \ref{fig:igarashi_packing} show the stages of the method, and Figs. \ref{fig:teaser},~\ref{fig:static},~\ref{fig:atlas}, and~\ref{fig:sas_issues} show typical FastAtlas atlases. In each category we compare the results obtained with FastAtlas against those generated using the most relevant alternatives. Detailed statistics, renders and comparisons are provided in the supplementary document, supplemental galleries, and video. Please zoom in on images throughout the paper to see fine details. For additional ablations, including experiments with temporal re-use and other applications such as depth-of-field and foveated rendering, please see our supplemental material.

\paragraph*{Setup.}

In the experiments below, we evaluate FastAtlas and alternatives by atlassing, shading and rasterizing thirteen representative flight paths of complex scenes. Nine of the paths are generated by rotating a camera from a fixed position in the scene, and four are generated by moving the camera along a trajectory specified by a spline flight path. All flight paths use frequently rendered scenes from the Computer Graphics Archive \cite{McGuire2017Data} (see supplemental for more detail). We rasterize scenes at two window resolutions: $1920 \times 1080$, the size of a standard high-definition display, and $3840 \times 2160$, used by high-resolution UHD displays. 

Regardless of application, TSS aims to produce rendered outputs that are as visually similar as possible to those obtained via standard forward rendering. We hence measure visual quality as the difference between TSS (ours or alternative) and forward rendering outputs, generated using the standard forward renderer in the G3D engine \cite{G3D17} which uses the same ubershader as TSS. We quantify this difference using the \FLIP metric which measures the perceptual difference between a frame generated by the renderer being tested and a ``ground truth'' reference frame \cite{andersson2020FLIP}.  \FLIP values range from $0$ to $1$, with 0 being best. We expect \FLIP values to always be non-zero, as even at 100\% shading rate there will always be small differences between pixel and texel space shading due to aliased sampling with arbitrary phase offsets. We report the average mean \FLIP error across all frames in the path. 

We also report the average $L^{2}$ and $L^{\infty}$ texture stretch metrics of Sander et al. ~\shortcite{sander2001texture} between the triangles on screen and in the atlas for all of our frames; $L^{2}$ measures the root-mean-squares stretch of the texture atlas over a frame, and $L^{\infty}$ measures the worst per triangle stretch. These metrics assess sampling uniformity at a triangle level. $L^{2}$ and $L^{\infty}$ of 1 mean that the sampling rate is one-to-one, with values above 1 indicating undersampling, and below 1 oversampling. A divergence between $L^{2}$ and $L^{\infty}$ indicates different sampling rates in different parts of the scene. 

\vspace{-3mm}
\paragraph*{Comparison Setup.}

We compare the visual quality of FastAtlas TSS to other popular TSS methods. First, we compare against fixed, or static atlases, generated using the {\em xatlas library}. Until recently, texture space shading has always been performed with static atlases; this establishes a baseline against our method. Second, we compare against Shading Atlas Streaming (SAS) \cite{mueller2018shading}, which packs small 1-3 triangle charts into regular grids using a ``superblock'' scheme inspired by memory management. Finally, we compare our visual quality to the meshlet shading atlases of Neff et al. \shortcite{Neff2022MSA}, the current state-of-the-art for dynamic texture space shading. Neither SAS nor Neff et al. \shortcite{Neff2022MSA} provide code; while the authors of Neff et al. generously shared their meshlet generation code with us, they were unable to share the rest of the codebase. We therefore reimplemented these two methods as discussed in the supplemental material (App. B) and confirmed the correctness of our implementations as much as possible with the authors. In the experiments below we use the MSA-P method of Neff et al. (using screen projection to parameterize charts). In our experiments the MSA-UV method (parameterizing charts in advance using \cite{levy2002least}) led to higher \FLIP error and introduced folded/non-bijectively mapped charts for many scenes, leading to catastrophic failures for frames containing these charts.  

\subsection{Texture-Space Shading Baseline}
\input{table_flip-tss-overview-2024-09-23}

As a baseline experiment we use FastAtlas to shade our input corpus, aiming for a 100\% shading rate. We use a fixed atlas size of $8K \times 8K$ which in our experiments was sufficient for FastAtlas to achieve this goal at both standard and high display resolutions (Tab.~\ref{tab:flip_tss_overview}). We ran all alternative methods using the same settings. Using this baseline setting, our \FLIP error is $42\%$ lower than that of the best performing alternative (MSA-P) at standard display resolution, and $46\%$ lower than this best alternative at 4K resolution.
  
We compare our baseline results against static atlases with an extra-large atlas size of $32K \times 32K$; this serves as a proxy for the virtualized texture-space shading methods of Baker et al. \cite{baker:2016,Baker2022}. We show representative outputs of our method and this alternative in Fig. \ref{fig:static}. 
Using static 32K atlases on a regular size display, our average \FLIP with an 8K atlas is 0.038, versus an average \FLIP using a 32K static atlas of 0.055. Our method outperforms static 32K atlases on all inputs except {\em Breakfast Room}, where both \FLIP errors are negligible - ours is 0.002, and the alternative is 0.001. As the results show, even without increasing shading rate, FastAtlas achieves higher rendering quality than static atlases at both 8K and 32K, and can further improve rendering quality when shading rate is increased. We note that, unlike our method, static atlases do not allow control over shading rate. 

\input{table_stretch_fixed_atlas-2024-09-25}

Table ~\ref{tab:stretch_fixed_atlas} reports stretch metrics versus prior art at $8K \times 8K$ for both $1920 \times 1080$ and $3840 \times 2160$ screen resolutions. At both screen resolutions, FastAtlas's $L^2$ and $L^\infty$ metrics are very close to 1, reflecting an ideal one-to-one sampling rate. MSA-P has reasonable $L^2$ stretch with an 8k atlas size, but has higher $L^\infty$ stretch than FastAtlas (most likely due to undersampling of meshlets in specific superblocks). Both static atlases and SAS have higher $L^2$ stretch, and much higher $L^\infty$ stretch, than FastAtlas; the discrepancy between the $L^2$ and $L^\infty$ stretches is due to both methods having high parametric distortion. SAS in particular has the highest $L^\infty$ stretch of all methods, consistent with our observation, illustrated in Figs. \ref{fig:teaser} and \ref{fig:sas_issues}, that constraining parameterized charts to rectangular patches can introduce excessive stretch. Fig~\ref{fig:prev_work} shows a representative example of our and alternative renders generated using this baseline setting. 

\subsection{Controlled Shading Rate}
\label{sec:shading_rate}
\input{table_flip-fixed-shading-rate-2024-09-18}
\input{table_stretch_fixed_size_2024-09-25}
We evaluate the use of FastAtlas to generate atlases with a specified target texel to pixel ratio. This setting enables  undersampling, where the shading rate is lower than rasterization rate, reducing overall render time. 
We evaluate FastAtlas suitability for this application both qualitatively, through visual inspection, and quantitatively, by measuring perceptual differences vis-a-vis forward rendering outputs.
For all examples, we use an atlas size of $8K^2$ and set the shading rate by pre-scaling the target bounding box sizes passed to FastAtlas. We evaluate FastAtlas performance in these settings by uniformly scaling the boxes to a fixed percentage of their original dimensions (50\%, 25\%, 12.5\%); target effective shading rate is then the {\em square} of this scale factor (a 50\% scale factor yields a target shading rate of 25\%). We test this setup on both standard and high-resolution display settings. Examples of output renders generated with these settings are shown in Figs.~\ref{fig:seams} and~\ref{fig:reduced_sr}. We showcase two key applications of controlled shading rate with FastAtlas (depth-of-field and foveated rendering) in our supplemental material.
An example of oversampling (multiple texels correspond to a single pixel) is provided in the supplementary.

\begin{figure*}
   \includegraphics[width=\linewidth]{fig_reduced_sr_v6_bistroExt.pdf}
    \caption{Comparing FastAtlas to \cite{Neff2022MSA} and a forward upsampling baseline when targeting reduced shading rates. Here, all methods target a shading rate of 12.5\% ($0.125^2=0.016$ or 1.6\% of samples). The forward upsampling baseline (b) introduces jagged artifacts while \cite{Neff2022MSA} (c) exhibits undersampling (highlighted on zoomed images). FastAtlas (d) achieves the most similar results to ground truth forward rendering (a) and preserves important details even at the extremely low 12.5\% shading rate.}
    \label{fig:reduced_sr}
\end{figure*}

\paragraph*{Comparisons} We compare our render quality using FastAtlas for reduced shading rates against potential alternatives (Tab. ~\ref{tab:flip_fixed_sr}). To establish a baseline, we shade a reduced-size framebuffer using the forward renderer, then upsample it to our screen resolution using simple bilinear upsampling. We outperform this method by 26\% and 22\% on average at 1080p and 4K resolutions respectively (Tab.\ref{tab:flip_fixed_sr}).
We compare our results to those of the MSA-P method of \cite{Neff2022MSA}  using the scale factors above; after computing the screen space bounding box of each meshlet, we multiply both box dimensions by the corresponding scale factor. We then pass the bounding boxes to their packing method, which may further scale them down if needed to fit in the atlas. The error introduced by their method is significantly higher than ours (Tab. ~\ref{tab:flip_fixed_sr}, ``MSA-P''), but the difference decreases as scale factor goes down. This is predictable, as at lower scales the error is dominated by undersampling; however, even at 12.5\% scale factor our error is 20\% smaller (18\% on a 4K display.) These numbers are consistent with visual inspection (Figs.~\ref{fig:seams},~\ref{fig:reduced_sr}), and our texture stretch measurements (Tab.~\ref{tab:stretch_fixed_sr}).

Shading Atlas Streaming (SAS) \cite{mueller2018shading} and its followups \cite{hladky2019tessellated,hladky2021snakebinning} are designed for streaming as the target application, and do not provide a way to control the scale of individual charts relative to their screen resolution. As such, they are inherently ill suited for applications that wish to control shading rates, and we cannot compare against them for this test.

\subsection{Limited Atlas Size/Streaming}
\label{sec:compare_streaming}
\input{table_flip-fixed-atlas-2024-09-18}

Our next experiment represents a typical use case for games and streaming applications, where users seek both runtime and memory savings and rely on a fixed budget of texture memory to determine shading rate.  We test this setup using both standard and 4K displays. In addition to the baseline $8K \times 8K$ atlas size reported earlier, we generate and shade texture atlases at $4K \times4K$, and $2K\times2K$ resolutions. We do not evaluate higher resolutions since, as reported above, FastAtlas can pack almost all frames at 100\% shading rate, using 8K atlases, even for high-resolution displays. Tab. ~\ref{tab:flip_fixed_atlas} and Figs. ~\ref{fig:teaser}, \ref{fig:static}, \ref{fig:atlas},~\ref{fig:sas_issues},~\ref{fig:more_lowres} demonstrate FastAtlas's performance in this setting. As expected, \FLIP error increases as atlas size decreases, leading to undersampling. However, this increase is relatively minor, with the visual quality remaining high even for 2K atlases (e.g. Fig. ~\ref{fig:teaser}).

\subsubsection{Comparisons} 
We compare the visual quality of our results generated using fixed atlas sizes to static atlases; shading atlas streaming (SAS) \cite{mueller2018shading}; and MSA \cite{Neff2022MSA}. We show representative outputs of our method, and these alternatives, in Figs. ~\ref{fig:teaser}, \ref{fig:atlas},~\ref{fig:sas_issues}, and ~\ref{fig:more_lowres}.  As documented in Tabs. ~\ref{tab:flip_tss_overview} and ~\ref{tab:flip_fixed_atlas}, the visual error (\FLIP) of outputs produced using fixed size static atlases (8K, 4K, and 2K) is a factor of 2 to 3.6 times higher than ours, and significantly higher than that of dynamic atlasing alternatives. With smaller fixed atlas sizes, our texture stretch is also much lower (Tab.~\ref{tab:stretch_fixed_atlas}).

Our comparisons (Fig. \ref{fig:atlas},~\ref{fig:sas_issues},~\ref{fig:more_lowres}, Tab.~\ref{tab:flip_fixed_atlas}) show that FastAtlas consistently outperforms SAS across the input scenes tested. As detailed in the appendix, we outperform SAS on all scenes using 8K and 4K atlases for both standard and 4K displays. At 1080p, we reduce \FLIP error by 43\% with 8K atlases and 39\% with 4K atlases on average compared to SAS. At 4K, we reduce \FLIP error by 53\% and 32\% respectively. Using 2K atlases, we outperform SAS on 11 out of 13 scenes at 1080p (average improvement 26\%), and 10 out of 13 scenes on a 4K display (average improvement 18\%). SAS has worse texture stretch (both $L^2$ and $L^\infty$) than FastAtlas on all scenes at all fixed atlas resolutions, with $L^\infty$ texture stretch being particularly severe: at $2K$, our mean $L^2$ texture stretch is $1.59$ versus SAS's $L^2$ of $16.77$, and our mean $L^\infty$ texture stretch across all frames is $1.59$ versus their $L^\infty$ of $33.39$. This confirms our visual assessment that their method has significant patches of severe parametric distortion; we note that while these may be immediately visible to a human viewer (Figs. ~\ref{fig:teaser} (frieze); ~\ref{fig:sas_issues}), this sort of visual error may not be captured by \FLIP on regions of low-contrast texture.

Using fixed atlas sizes on both regular and high-res displays, the ratio of MSA-P's \FLIP to ours ranges between 1.7 and 1.8; a very significant difference. These numbers are consistent with visual inspection. As Figs. ~\ref{fig:teaser}, ~\ref{fig:seams}, ~\ref{fig:more_lowres} show, at resolutions of 4K and less, the seam artifacts in the outputs of Neff et al become increasingly pronounced. On the {\em Robot Lab} scene which Neff et al. use in their paper (albeit with refined tessellation), our method's improvement is notable across all resolutions. With a $8\operatorname{k}^{2}/4\operatorname{k}^{2}$ texel atlas and a 1080p framebuffer, MSA-P has the best texture stretch of previous work; however, we still outperform it by a significant margin (4K 1080p: MSA-P mean $L^2$ $1.96$ vs FastAtlas $1.04$; $L^\infty$ $3.82$ versus FastAtlas $1.04$). However, with a fixed size $2\operatorname{k}^2$-texel atlas, or on a 4K HDMI display, FastAtlas outperforms it by an order of magnitude (4K HDMI: MSA-P mean $L^2$ 11.36 versus FastAtlas $1.55$; MSA-P mean $L^\infty$ 25.88 versus FastAtlas $1.55$.)

\begin{figure*}
\includegraphics[width=\linewidth]{fig_low_res_all_v2_breakfast.pdf}
\caption{Additional comparisons with prior art ($2K \times 2K$ atlases). Left to right:  forward render, static atlasing, SAS \cite{mueller2018shading}, MSA  \cite{Neff2022MSA}, FastAtlas. While all prior method outputs exhibit notable undersampling, our results remain visually close to forward rendering.}
\label{fig:more_lowres}
\end{figure*}

\begin{figure*}
\includegraphics[width=\linewidth]{fig_low_res_us_sas_v2_robotLab.pdf}
\caption{Additional comparisons with SAS \cite{mueller2018shading}  using $4K \times 4K$ atlases. Left to right: forward render, SAS \cite{mueller2018shading}, FastAtlas. While SAS outputs exhibit notable undersampling and smudging artifacts, our results remain visually close to forward rendering. }
\label{fig:more_lowres_sas}
\end{figure*}

\begin{figure*}
\includegraphics[width=\linewidth]{fig_low_res_us_meshlet_v1_bistroInt.pdf}
\caption{Additional comparisons with MSA \cite{Neff2022MSA}  using $2K \times 2K$ atlases. Left to right: forward render, MSA-P \cite{Neff2022MSA}, FastAtlas. While MSA outputs exhibit notable undersampling and seam artifacts, our results remain visually close to forward rendering. }
\label{fig:more_lowres_meshlet}
\end{figure*}

\input{table_runtime-2024-09-30}
\subsection{Runtime.} 
Tab.~\ref{tab:runtimes} reports average runtimes for each part of our atlas generation and shading methods. Times were measured on an Intel Core i9-13900k CPU with 32 GB of RAM and an NVIDIA GeForce RTX 4090; see supplementary for exact experiment protocol. Total FastAtlas atlas generation time remains steady across all experiments, averaging $1.4ms$ per frame. Atlassing time is highest (3ms on average) on {\em San Miguel} (over 9M triangles). This number is negligible compared to shading time, which averages between 45 and 134 ms across the different experiments, and accounts for roughly 95\% of the total time per frame. As desired, shading time decreases with a decrease in shading rate. This is most notable in our experiments where shading rate is explicitly controlled, especially when going from 100\% to 50\% (decrease is not linear, as smaller charts do not shrink below a $2 \times 2$ pixel minimal size). 

Atlas computation time is dominated by the cost of ordering and packing boxes; ordering cost is roughly constant for each atlas resolution, ranging from 0.6ms for 8K to 0.3ms for 2K. Packing cost is largely resolution independent, but increases with increased scene complexity, and thus chart count, ranging from 0.5ms for simpler scenes to 1.1ms for {\em San Miguel}; as this number is dominated by the cost of evaluating the multiple packings, it can be ``tuned'' for target applications by trading packing tightness for runtime speed. 

We have no access to code for any of the prior methods we compare against, nor to the exact inputs they used, making runtime comparisons infeasible. As such, our re-implementation may not have the same performance as their original code. Moreover, as noted by Neff et al. ~\shortcite{Neff2022MSA}, when evaluating on standard scenes such as {\em Robot Lab} both they and SAS refine their meshes to demonstrate cases where their method and SAS perform best; these refined meshes are not readily available. 
As such, we cannot compare our runtimes to their reported ones for the same inputs. Overall, however, we believe our method is both competitive in terms of run-time and suitable for real-time applications on commercially available hardware. 

Finally, we compare the runtimes of our unoptimized research code to those of the G3D forward renderer, which has been highly optimized and hand-tuned over several years. G3D forward rendering takes $25.3$ msec at 1080p on average, and $71.4$ msec at 4K on average across our test scenes. While this is faster than our method at 1080p across all experiments, at 50\% shading rate on 4K monitors we outperform the forward renderer (70.4 msec) and are significantly faster at 25\% shading rate (49.5 msec.) Improvement is most pronounced on scenes with lower geometric and material complexity (at 50\% SR we outperform the forward renderer on all scenes except {\em bistro exterior}, {\em San Miguel}, and {\em modern house}); this and profiling suggests that our primary performance disadvantage during shading is due to unoptimized handling of scenes with multiple materials, which can be improved for commercial applciations. Overall, this confirms that our method is practical for reducing shading cost on high-resolution displays, or where reduced shading rate is desireable. 
 
