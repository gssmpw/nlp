\begin{figure*}[t]
\includegraphics[width=\linewidth]{fig_sponza_v3.pdf}
\caption{Comparing FastAtlas (d) to representative TSS atlassing alternatives using same atlas size (here $8K\times 8K$). (a) Ground truth forward rendering; (b) MSA-P  \cite{Neff2022MSA} notably blurs the intricate banner design; (c) SAS \cite{mueller2018shading} has more localized, but significant, blurring. (d) FastAtlas produces significantly better quality renders than all alternatives. Render quality is reflected in the \FLIP error maps shown next to each output (black low error; purple to pink high).}
\label{fig:prev_work}
\end{figure*}

\section{Related Work}
\label{sec:related}

Our work builds on existing research on texture space shading, texture and shading atlas generation, and atlas packing. 

\paragraph*{Texture-Space Shading.} 
TSS methods decouple shading from rendering by storing the output of a shading computation pass in a texture atlas, then treating it as a texture at render time. TSS has been hailed as a solution for several different problems, including improving render quality via oversampling \cite{Baker2022,baker:2016}, minimizing client compute effort by shading atlases on servers and streaming them to the client \cite{mueller2018shading,hladky2019tessellated,hladky2021snakebinning,Neff2022MSA}, and improving rendering speed by shading atlases at resolutions lower than screen resolution or at temporal frequency lower than rendering frequency \cite{mueller2021tasa}. In all these settings, the goal is to maximize the visual quality of the output renders. For oversampling, the aim of decoupling is to improve rendering quality compared to forward rendering; for other applications, the goal is to generate renders which are visually close to ground truth forward/deferred rendering outputs.

The main sources of visual artifacts in TSS rendering are undersampling and shading discontinuities along visible texture seams. Undersampling blurs fine details in output renders and occurs when a triangle, or any portion of it, is allocated a much smaller space in the atlas than on screen. Some undersampling is inevitable (e.g. if atlas size is smaller than screen size) or desirable (reducing shading time); however, maximizing visual quality requires controlling undersampling as much as possible. Sampling mismatches across visible seams lead to noticeable shading discontinuities \cite{liu2017seamless} which become increasingly noticeable when combined with undersampling (Fig~\ref{fig:seams}b). 

For real-world TSS applications, visual quality is typically balanced against constraints on atlas size (which, at the very least, needs to fit into GPU memory) and runtime. 
As such, uncontrollable oversampling is also undesirable as it decreases rendering speed and wastes memory \cite{hillesland2016texel}.
As demonstrated in Sec. ~\ref{sec:results}, our atlasing strategy provides a high degree of sampling control and can be effectively used for all applications above.

\paragraph*{Traditional Atlas Generation.}
Atlas generation for storing surface signals (such as albedo or normal maps) is a well-researched problem~\cite{sheffer2007mesh}, involving three steps that can sometimes be performed in tandem \cite{BoundedDistortParam:2002,Li:2018:OptCuts}: cutting input surfaces into charts \cite{julius2005d,zhou2004iso}; parameterizing these charts in 2D \cite{levy2002least,sheffer2005abf++,jiang2017simplicial}; and finally packing the 2D charts into an atlas \cite{levy2002least,Limper18BoxCutter,igarashi2001adaptive,liu2019atlas}. The key considerations driving the methods involved are parameterization distortion; output chart seam length; bijectivity guarantees; atlas memory footprint; and runtime.
 
Traditional atlasing methods are CPU-based, and take multiple minutes to generate results for typical scenes; we aim for a GPU-based real-time method with related, but not identical, desiderata. Like traditional methods, we seek to control the atlas's memory footprint by optimizing packing efficiency; aim for a bijective mapping between the {\em visible} 3D content in each frame and the atlas; and aim to minimize the length of visible seams.  While seams can be partly hidden using seam-hiding techniques \cite{liu2017seamless,Ray2010invisible}, these techniques are far from real time and thus unsuitable for our needs. The distortion metrics minimized by the different atlassing methods are application-dependent~\cite{sheffer2007mesh,sander2002signal,sander2001texture}. For TSS, the dominant consideration is sampling rate. Our projection-based parameterization and subsequent packing step ensures a constant sampling rate across all charts. By placing seams only along the boundaries of visible regions, we avoid {\em all} rendering artifacts associated with visible seams. Our atlases can be computed near-instantaneously for charts of any shape or size, and our parameterization is bijective across the visible portions of our charts.

\paragraph*{Traditional Atlas Packing.} Textures and other surface signals are stored as 2D rectangular images defined over a bounding box of the packed atlas charts (where the box and the image have the same aspect ratio).  Any space within this box that is not occupied by the atlas charts is wasted as it contains no actual signal; packing the parameterized charts into a tight bounding box is a key element of any atlasing scheme \cite{levy2002least,Limper18BoxCutter}. Packing efficiency (the ratio between the areas of the packed atlas and its bounding box) is therefore a critical consideration for practical atlasing applications. In the context of TSS, packing efficiency directly impacts sampling rate. Unfortunately, maximizing the packing efficiency for a given set of charts is NP-hard \cite{Milenkovic1999}. Traditional \cite{levy2002least,igarashi2001adaptive} and recent \cite{Limper18BoxCutter,zhangatlasgeneration,knodt2023uvopt,liu2019atlas} methods for packing general charts have multi-minute runtimes. 

Packing methods that attempt real-time performance rely on strong assumptions about the shape and size of the charts packed. At the extreme end, some assume that all charts are same size right angle isosceles triangles \cite{Maruya:1995,Carr:2002} or squares \cite{purnomo2004seamless}. While these methods can achieve high packing efficiency, generating parameterized charts that satisfy these assumptions requires introducing extremely long seams, and high parametric distortion as arbitrarily shaped triangles or charts are forced to map to highly constrained parameter domains. Like the latter methods FastAtlas packing runs in real-time; however in contrast to them it makes no assumptions about parameterized chart shape or connectivity. 

\paragraph*{Atlas Generation and Packing for TSS.} 
Many TSS approaches use {\em static} pre-computed texture atlases covering {\em entire scenes} \cite{baker:2016, Baker2022, hillesland2016texel},
and compute these atlases using traditional time-consuming atlasing strategies discussed above.
Even if the overall atlas size is large, the atlas resolution of the content visible in individual frames is often low; this leads to visible undersampling, particularly on content close to the camera \cite{Neff2022MSA,Karis:NaniteTalk} (Fig.~\ref{fig:static}b). Using smaller atlas sizes, even relatively far objects can be highly undersampled (Sec.~\ref{sec:results}). This approach is therefore largely used in settings where strong assumptions can be made about the rendered content \cite{baker:2016}, or where atlas size exceeds display resolution by orders of magnitude (e.g. \cite{Baker2022}, which uses a $256K \times 256K$ atlas stored in virtualized texture memory.) FastAtlas makes no such assumptions and produces high quality renders using atlases small enough to fit in GPU memory (Fig.~\ref{fig:static}c).

\begin{figure}
\includegraphics[width=\linewidth]{fig_modern_house_v2.pdf}
\caption{SAS ~\cite{mueller2018shading} vs FastAtlas:  (a) Reference forward rendering. (b,d) SAS can form charts which are far from rectangular (d, left); mapping such charts into rectangular parameter domains introduces excessive stretch (d,center/right) leading to blurring/smearing artifacts (b, highlighted). (c,e) FastAtlas projection based parameterization preserves the screen-space triangle shape (e,left), and distributes undersampling uniformly leading to better visual outputs (c).  SAS (d) and FastAtlas (e,right) atlases ($2K \times 2K$). Please zoom in to see details.}
\label{fig:sas_issues}
\vspace{-5mm}
\end{figure}

Several recent TSS methods that target streaming applications \cite{mueller2018shading,hladky2019tessellated,hladky2021snakebinning,Neff2022MSA} compute per-scene static charts, then form per-frame atlases which include only fully or partially visible charts. Shading Atlas Streaming (SAS) \cite{mueller2018shading} pre-segments scenes into charts with 2 to 3 triangles, and parameterizes each chart into a rectangle. They constrain these rectangles' dimensions to be powers of 2, and propose a packing strategy designed for such rectangular charts. These constraints allow for space-efficient, real-time packing, but can introduce significant parametric distortion (in both world and screen space) which results in highly notable, unevenly distributed  undersampling (Fig~\ref{fig:sas_issues}). SAS followups use triangle strips as charts \cite{hladky2019tessellated,hladky2021snakebinning} combined with a similar parameterization and packing strategy. As noted by \cite{hladky2022quadstream}, based on experiments with their code, these methods lack robustness and fail to generate atlases for complex scenes such as San Miguel (Fig.~\ref{fig:san_miguel}). 

Neff et al. \shortcite{Neff2022MSA} use an atlassing framework based on mesh shaders (Fig.~\ref{fig:prev_work}b).
They segment input scenes offline into roughly evenly-sized charts with at most 84 triangles (the largest meshlet size supported by mesh shaders), then parameterize these charts either offline, or dynamically by projecting each chart to view space; and finally form per-frame atlases by packing visible charts using a grid-based method that works best when presented with evenly sized charts. 
As Neff et al. note, both theirs and prior dynamic atlassing methods \cite{mueller2018shading,hladky2019tessellated} perform best when presented with meshes with roughly uniformly sized triangles. In the experiments in their paper, they refined their input meshes to evaluate both their method and SAS, making them more uniform. Our experiments (Sec~\ref{sec:results}) show that the visual quality of the renders produced using these methods significantly degrades on unevenly tessellated inputs, typical of real-life game and other environments. 
To ensure that the parameterized charts can be packed into an atlas of a given size, all above methods  \cite{mueller2018shading,hladky2019tessellated,hladky2021snakebinning,Neff2022MSA} cap the dimensions of the charts they pack, and scale charts down if they exceed these ``superblock'' dimensions (e.g. Fig~\ref{fig:atlas},~\ref{fig:sas_issues}). Sec~\ref{sec:results} provides extensive comparisons of FastAtlas, showing we outperform these alternatives. 

\begin{figure}
\includegraphics[width=\linewidth]{fig_seams_v3.pdf}
\caption{MSA-P ~\cite{Neff2022MSA} use charts whose seams when visible can lead to noticeable undesirable shading discontinuities (highlighted in the zoomed image)  (b). FastAtlas charts have no visible seams, and are better packed leading to superior render quality. In this example, we use 25\% shading rate and an atlas size of $8K \times 8K$.}
\label{fig:seams}
\vspace{-5mm}
\end{figure}

\paragraph*{TSS Alternatives and Temporal Reuse.}
While hardware-level decoupled shading \cite{ragan2011decoupled, burns2010lazy,clarberg2013sort} is a promising concept, it is not supported by current commercial hardware. 
In addition to TSS, several other approaches explore decoupling on standard GPU hardware.
Liktor and Dachsbacher~\shortcite{liktor2012decoupled} decouple shading and rasterization by shading directly into a linear buffer which stores an array of shading samples per triangle. This precludes efficient hardware texture sampling and filtering, slowing computation and preventing real-time performance. QuadStream \cite{hladky2022quadstream} decouples shading between client and server; it addresses a different problem than a fully decoupled shading method (reconstructing occluded geometry and shading, seen from novel viewpoints on a client) and operates directly on already-shaded framebuffers.
Researchers have explored screen-space reverse reprojection between frames, or between views, as a pseudo-shading cache \cite{nehab2007accelerating} or for temporal anti-aliasing \cite{karis2014hqaa, Yang2020TAA}.  Reprojection often introduces rendering artifacts such as ghosting and flicker, and flicker, and can fail for content moving in and out of occlusion and for first frames after a camera cut \cite{Scherzer11asurvey}. FastAtlas can be used to facilitate selective shading reuse across frames and does not suffer from these artifacts (see supplemental).
