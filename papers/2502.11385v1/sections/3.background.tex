\section{Background}
\label{chap:background}

This section contains detailed information on some of the topics required to completely understand the tools and software used in this study. Section \ref{sec:circuit-cutting} describes the circuit-cutting framework CutQC and how it works, whereas Section \ref{sec:gpu-simulation} talks about how GPU-based simulation works in Qiskit.

\subsection{Circuit Cutting using CutQC}
\label{sec:circuit-cutting}

The CutQC framework cuts a quantum circuit along its qubit wires (vertical cuts). The vertical cuts use the fact that a unitary matrix of any arbitrary operation can be decomposed into any set of orthonormal matrix bases. To demonstrate this, the CutQC paper by Tang, W. et al. \cite{tang2021cutqc} uses the basis composed of the set of Pauli matrices \emph{I}, \emph{X}, \emph{Y} and \emph{Z}. Consider an arbitrary 2$\times$2 matrix \textbf{A} expressed as a linear combination of the Pauli bases, $\textbf{A} = \alpha\emph{X} + \beta\emph{Y} + \gamma\emph{Z} + \delta\emph{I}$. The trace of this matrix with a Pauli matrix, for example, with \emph{X} is 
$$ \emph{Tr} \left( \textbf{A}\emph{X} \right) =  \alpha\emph{Tr} \left( X^{2} \right) + \beta\emph{Tr} \left( X\emph{Y} \right) + \gamma\emph{Tr} \left( X\emph{Z} \right) + \delta\emph{Tr} \left( X \right) = 2\alpha$$
This is using the fact that Pauli matrices are traceless (resulting in $\emph{Tr} \left( X \right)=0$), they anti-commute, which implies their product has zero trace (resulting in $\emph{Tr} \left( X\emph{Y} \right)=\emph{Tr} \left( X\emph{Z} \right)=0$) and the square of a Pauli matrix is the identity matrix (resulting in $\emph{Tr} \left( X^{2} \right)=\emph{Tr} \left( I \right)=2$). Similarly, we can show that $\emph{Tr} \left( \textbf{A}\emph{Y} \right) = 2\beta$, $\emph{Tr} \left( \textbf{A}\emph{Z} \right) = 2\gamma$ and $\emph{Tr} \left( \textbf{A}\emph{I} \right) = 2\delta$.  

\noindent Using the above, we can decompose matrix A as 
\begin{equation} \label{eq:3.1}
    \textbf{A} = \frac{ \emph{Tr} \left( \textbf{A}\emph{I} \right) I + \emph{Tr} \left( \textbf{A}\emph{X} \right) X + \emph{Tr} \left( \textbf{A}\emph{Y} \right) Y + \emph{Tr} \left( \textbf{A}\emph{Z} \right) Z }{2}
\end{equation}

However, Eq. \ref{eq:3.1} requires access to complex amplitudes, which are unavailable on quantum computers. To execute this on a quantum computer, we need to decompose the Pauli matrices further into their eigenbasis and organize the terms.  

We obtain the following identity after this decomposition.
\begin{equation} \label{eq:3.2}
    \textbf{A} = \frac{A_1 + A_2 + A_3 + A_4}{2}
\end{equation}
where
\begin{equation} \label{eq:3.3}
    A_1 = [ \emph{Tr} \left( \textbf{A} \emph{I} \right) + \emph{Tr} \left( A\emph{Z} \right) ] |0\rangle\langle0|
\end{equation}
\begin{equation} \label{eq:3.4}
    A_2 = [ \emph{Tr} \left( \textbf{A} \emph{I} \right) - \emph{Tr} \left( A\emph{Z} \right) ] |1\rangle\langle1|
\end{equation}
\begin{equation} \label{eq:3.5}
    A_3 = \emph{Tr} \left( \textbf{A} \emph{X} \right) [ 2 |\text{+}\rangle\langle\text{+}| - |0\rangle\langle0| - |1\rangle\langle1| ]
\end{equation}
\begin{equation} \label{eq:3.6}
    A_4 = \emph{Tr} \left( \textbf{A} \emph{Y} \right) [ 2 |\text{+}i\rangle\langle\text{+}i| - |0\rangle\langle0| - |1\rangle\langle1| ]
\end{equation}


\noindent This decomposition can be achieved if we use the below equations
$$ \emph{I} = |0\rangle\langle0| + |1\rangle\langle1| $$
$$ \emph{Z} = |0\rangle\langle0| - |1\rangle\langle1| $$
$$ \emph{X} = 2 |\text{+}\rangle\langle\text{+}| - \emph{I} $$
$$ \emph{Y} = 2 |\text{+}i\rangle\langle\text{+}i| - \emph{I} $$

\noindent The first two terms can be substituted in Eq. \ref{eq:3.1} and grouped together to get Eqs. \ref{eq:3.3} and \ref{eq:3.4} whereas the last two terms help get Eqs. \ref{eq:3.5} and \ref{eq:3.6}.

Each trace operator $A_{i}$ corresponds physically to measure the qubit in one of the Pauli bases, and each density matrix corresponds physically to initialize the qubit in one of the eigenstates. Figure \ref{fig:edge-decomposition} shows the resulting subcircuits and the reconstruction procedure incurred when making a single cut. Since measuring a qubit in the $I$ and $Z$ basis corresponds to the output, we have three upstream circuits (measuring in $I$, $X$ and $Y$ bases) and four downstream circuits (initializing with $|\text{0}\rangle$, $|\text{1}\rangle$, $|\text{+}\rangle$ and $|\text{-}\rangle$).

\begin{figure}[htbp]
    \centering
    \includegraphics[alt={Circuit edge decomposition when a cut is made to a quantum circuit. We get three different upstream measurement circuits and four different downstream initialization circuits}, width=\linewidth]{figures/edge-decomposition.png}
    \caption{Procedure to cut one qubit wire. The wire between vertices $u$ and $v$ (left) can be cut by (as shown on the right) summing over four pairs of measurement circuits appended to $u$ and state initialization circuits prepended to $v$. Measurement circuits in the \emph{I} and \emph{Z} basis have the same physical implementation. The three different upstream measurement circuits and the four different downstream initialization circuits are now separate and can be independently evaluated. (Image Source: Tang, W. et al. \cite{tang2021cutqc}) }
    \label{fig:edge-decomposition}
\end{figure}


\begin{figure}[htbp]
    \centering
    \includegraphics[alt={Example of cutting a five-qubit circuit into two smaller subcircuits of three qubits each using the CutQC framework.}, width=\linewidth]{figures/cutqc-cut-example.png}
    \caption{Example of cutting a five-qubit circuit into two smaller subcircuits of three qubits each. The subcircuits are produced by cutting the $q_2$ wire between the first two $cZ$ gates. The three variations of $subcircuit_1$ and four variations of $subcircuit_2$ can then be evaluated on a 3-qubit quantum device, instead of a 5-qubit device. The classical postprocessing involves summing over four Kronecker products between the two subcircuits for the one cut made. (Image Source: Tang, W. et al. \cite{tang2021cutqc}) }
    \label{fig:cut-example}
\end{figure}

Figure \ref{fig:cut-example} shows an example of how the cut process looks like using a sample circuit of 5 qubits. The cut splits the circuit into two subcircuits with 3 qubits each. Note that the qubit \textit{subcirc}$1_2$ does not appear in the final output of the uncut circuit. Therefore, each shot obtained from executing subcircuit 1 needs to be multiplied by $\pm$1 depending on the measurement outcome of \textit{subcirc}$1_2$. This is called 'shot attribution' and contributes to the final output as

\begin{equation} \label{eq:3.7}
\begin{split}
    \begin{cases}
        & \overline{xx0},\overline{xx1} \rightarrow +\overline{xx} \quad M_2 = I, \\
        & \overline{xx0} \rightarrow +\overline{xx} \\
        & \overline{xx1} \rightarrow -\overline{xx} \quad \quad \quad \text{otherwise}
    \end{cases}
\end{split}
\end{equation}
where $\overline{xx}$ is the measured outcome of qubits \textit{subcirc}$1_0$ and \textit{subcirc}$1_1$.

Using the above equations, the probability of a particular state, e.g. $|01010\rangle$, can be calculated for the uncut circuit in Figure \ref{fig:cut-example}. Only the first two qubits from subcircuit 1 contribute to the final state (i.e. $|01\rangle$), so we must attribute the shots for this subcircuit. Using Eq. \ref{eq:3.7} and Eqs. \ref{eq:3.3}...\ref{eq:3.6}, we get the reconstruction terms as 
\begin{equation*}
\begin{split}
    & p_{1,1} = p(|010\rangle | I) + p(|011\rangle | I) + p(|010\rangle | Z) - p(|011\rangle | Z) \\
    & p_{1,2} = p(|010\rangle | I) + p(|011\rangle | I) - p(|010\rangle | Z) + p(|011\rangle | Z) \\
    & p_{1,3} = p(|010\rangle | X) - p(|011\rangle | X) \\
    & p_{1,4} = p(|010\rangle | Y) - p(|011\rangle | Y)
\end{split}
\end{equation*}

\noindent Similarly, the state contributed from subcircuit 2 is $|010\rangle$ and the reconstruction terms for it are
\begin{equation*}
\begin{split}
    & p_{2,1} = p(|010\rangle\ |\ |0\rangle) \\
    & p_{2,2} = p(|010\rangle\ |\ |1\rangle) \\
    & p_{2,3} = 2p(|010\rangle\ |\ |+\rangle) - p(|010\rangle\ |\ |0\rangle) - p(|010\rangle\ |\ |1\rangle) \\
    & p_{2,4} = 2p(|010\rangle\ |\ |i\rangle) - p(|010\rangle\ |\ |0\rangle) - p(|010\rangle\ |\ |1\rangle)
\end{split}
\end{equation*}

\noindent The final reconstructed probability of the uncut state $|01010\rangle$ can then be calculated by summing over the four pairs of Kronecker products as shown in Figure \ref{fig:edge-decomposition} using
\begin{equation*}
    p(|01010\rangle) = \frac{1}{2} \sum^{4}_{i=1} p_{i,1} \otimes p_{2,i}
\end{equation*}

\noindent In the classical postprocessing step of CutQC, the above step is performed for all possible states in the uncut circuit.







\subsection{GPU-based Quantum Circuit simulation}
\label{sec:gpu-simulation}

In this study, the classical simulator used is the \emph{Qiskit Aer} \cite{qiskitAerGPU} simulator, which supports using GPUs to simulate the statevector of a quantum circuit. It also supports using multiple GPUs (in both single-node and multi-node configurations) to parallelise simulations based on the work done by Doi, J. et al. \cite{qiskitGPUpaper}. This section aims to provide more insight into their work.

On a classical machine, to simulate a \emph{n}-qubit statevector, we need to store all the $2^{n}$ probability amplitudes as single or double precision complex numbers. Storing the statevector for circuits using a few qubits is quite easy, but each added qubit doubles the amount of memory required to store the statevector. This makes it unfeasible to simulate circuits with more than 35 qubits (which requires more than 500 GB of RAM to store the entire statevector). To store such large statevectors, Distributed Memory is needed where probability amplitudes are split into chunks and distributed across nodes. This, however, has the drawback of increased communication overhead as amplitudes need to be exchanged across memory spaces. Minimizing data exchanges between memory spaces is a key factor in scaling the performance of a distributed memory environment. The technique developed by Doi, J. et al. reduces the amount of data exchanges by moving all the gates associated with a smaller number of qubits by inserting noiseless swap gates. These operations resemble cache blocking on a classical computer \cite{10.5555/2568134}, and the concept of optimization is similar to one on a classical computer since gates are blocked on the qubits to be accessed faster.  

The first step is to split the statevector into chunks residing in distributed memory spaces. A naive way to do this for a $n$-qubit statevector is shown in Figure \ref{fig:naive-chunks}. Here the statevector is split and spread across four distributed memory spaces with four chunks of $2^{n-2}$ probability amplitudes. In this scenario, gate operations on qubits from $0$ to $n-3$ are performed within a process, whereas data exchange is necessary for operations on $n-2$ and $n-1$ qubits. Every memory space requires a buffer for these data exchanges (shown as the darker shaded parts in the figure) to receive a copy of probability amplitudes. This approach requires double the memory space to have a copy of remote memory, which is not memory efficient. A better approach proposed in the paper is to divide the statevector into $2^{nc}$ small chunks and exchange them in a pipeline to minimize space for buffering. Figure \ref{fig:efficient-chunks} shows an example of using only one buffer to exchange chunks.  



\begin{figure*}[htbp]
\centering
\begin{subfigure}{0.4\textwidth}
  \centering
  \includegraphics[alt={Naive implementation of probability amplitude exchange between distributed memory spaces. This implementation requires twice the memory space.}, width=0.6\textwidth]{figures/naive-chunks.png}
  \caption{}
  \label{fig:naive-chunks}
\end{subfigure}%
\begin{subfigure}{0.4\textwidth}
  \centering
  \includegraphics[alt={Efficient approach of probability amplitude exchange between distributed memory spaces. The data is split into $2^{nc}$ chunks to reduce the buffer space required to exchange chunks between memory spaces.}, width=\textwidth]{figures/efficient-chunking.png}
  \caption{}
  \label{fig:efficient-chunks}
\end{subfigure}
\caption{ Different chunking methods. (a) A naive implementation of probability amplitude exchange between distributed memory spaces. In this example, we apply a gate to qubit $k=n-1$. This implementation requires twice the memory space. (b) Dividing a state vector into small chunks and performing probability amplitude exchange by chunks. So, we only need one additional chunk per memory space to perform probability amplitude exchange. (Image Source: Doi, J. et al. \cite{qiskitGPUpaper}) }
\label{fig:chunking}
\end{figure*}


% \begin{figure}[h]
%     \centering
%     \includegraphics[alt={Naive implementation of probability amplitude exchange between distributed memory spaces. This implementation requires twice the memory space.}, width=0.8\linewidth]{figures/naive-chunks.png}
%     \caption{Naive implementation of probability amplitude exchange between distributed memory spaces. In this example, we apply a gate to qubit $k=n-1$. This implementation requires twice the memory space. (Image Source: Doi, J. et al. \cite{qiskitGPUpaper})}
%     \label{fig:naive-chunks}
% \end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[alt={Efficient approach of probability amplitude exchange between distributed memory spaces. The data is split into $2^{nc}$ chunks to reduce the buffer space required to exchange chunks between memory spaces.}, width=\linewidth]{figures/efficient-chunking.png}
%     \caption{ Dividing a state vector into small chunks and performing probability amplitude exchange by chunks. So, we only need one additional chunk per memory space to perform probability amplitude exchange. (Image Source: Doi, J. et al. \cite{qiskitGPUpaper})}
%     \label{fig:efficient-chunks}
% \end{figure}


The second step is to ensure that most gate operations are performed locally within a memory space. In other words, maximizing consecutive gate operations which act on qubits smaller than the number of chunks $nc$ since all gate operations on such qubits would be performed locally without needing any data exchange. This is done before executing the circuit in the circuit transpile phase. One of the methods is to use \textit{Qubit reordering}, where if some qubits are not updated by any of the gates, then we map them to qubits larger than or equal to $nc$ and other qubits to smaller qubits than $nc$ in simulation. This method can help to reduce data movements but cannot remove all data movements if a circuit updates $nc$ or larger qubits. In this scenario, data movement is reduced by inserting noiseless swap gates in the circuit to move as many qubits as possible to less than $nc$. An example of this can be seen in Figures \ref{fig:gpu-input-circuit} and \ref{fig:gpu-transpiled-circuit}. Figure \ref{fig:gpu-input-circuit} shows a circuit in which all qubits are updated. Here, gate operations on qubits greater than $nc$ need to refer to probability amplitudes from different chunks to be simulated. Figure \ref{fig:gpu-transpiled-circuit} shows the circuit after the cache blocking (inserting swap gates) is applied during the transpile phase. Here, using four swap gates, all the gate operations are moved to be applied on qubits less than $nc$, which does not require any data exchanges between chunks. Note that the execution order of some of the gates is also swapped so that all operations can be performed using a single chunk. 


\begin{figure*}[htbp]
\centering
\begin{subfigure}{0.35\textwidth}
  \centering
  \includegraphics[alt={Example input quantum circuit having gate operations on all qubits. Data exchange is necessary to perform all gate operations.}, width=\linewidth]{figures/gpu-input-circuit.png}
  \caption{}
  \label{fig:gpu-input-circuit}
\end{subfigure}%
\begin{subfigure}{0.55\textwidth}
  \centering
  \includegraphics[alt={Example output quantum circuit after swap gates are inserted. All of the gate operations are now shifted to qubits less than \textit{nc} to eliminate data exchanges.}, width=\linewidth]{figures/gpu-transpiled-circuit.png}
  \caption{}
  \label{fig:gpu-transpiled-circuit}
\end{subfigure}
\caption{ Example of using cache blocking on a quantum circuit. (a) shows the input circuit consisting of u1, u3 and CNOT gates. \textit{nc} denotes the number of qubits of a chunk. The gates on qubits $>$ nc need to refer to probability amplitudes over multiple chunks to be simulated. (b) shows the output circuit after cache blocking is performed. Four swap gates are added to move all the gates to qubits $<$ \textit{nc}; now, all the gates can be performed without referring to probability amplitudes over chunks. (Image Source: Doi, J. et al. \cite{qiskitGPUpaper}) }
\label{fig:gpu-circuit}
\end{figure*}



% \begin{figure}[htbp]
%     \centering
%     \includegraphics[alt={Example input quantum circuit having gate operations on all qubits. Data exchange is necessary to perform all gate operations.}, width=\linewidth]{figures/gpu-input-circuit.png}
%     \caption{ Example of an input quantum circuit consisting of u1, u3 and CNOT gates. \textit{nc} denotes the number of qubits of a chunk. The gates on qubits $>$ nc need to refer to probability amplitudes over multiple chunks to be simulated. (Image Source: Doi, J. et al. \cite{qiskitGPUpaper})}
%     \label{fig:gpu-input-circuit}
% \end{figure}

% \begin{figure}[htbp]
%     \centering
%     \includegraphics[alt={Example output quantum circuit after swap gates are inserted. All of the gate operations are now shifted to qubits less than \textit{nc} to eliminate data exchanges.}, width=\linewidth]{figures/gpu-transpiled-circuit.png}
%     \caption{ Example of a cache blocked circuit. Four swap gates are added to move all the gates to fewer qubits than \textit{nc}; now, all the gates can be performed without referring to probability amplitudes over chunks. (Image Source: Doi, J. et al. \cite{qiskitGPUpaper})}
%     \label{fig:gpu-transpiled-circuit}
% \end{figure}