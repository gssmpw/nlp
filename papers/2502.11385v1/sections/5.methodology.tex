\section{Methodology}
\label{chap:methodology}

This section aims to provide more information on the benchmarks performed in this study. Section \ref{sec:environment} talks about the hardware and software used for the benchmarks, and detailed information about the benchmarks is provided in Section \ref{sec:benchmarks}.




\subsection{Hardware and Software Environments}
\label{sec:environment}

\subsubsection{Hardware Environment}

All benchmarks were performed on Perlmutter \cite{perlmutter} (operated by NERSC at Lawrence Berkeley National Lab). Each benchmark was executed on a dedicated GPU node with several nodes being available for running multiple benchmarks at once.  

Each GPU node on Perlmutter has an AMD EPYC 7763 (Milan) CPU at 2.45 GHz, 256GB DDR4 RAM and four NVIDIA A100 GPUs \cite{perlmutter_specs}. There are two variants of these GPU nodes: a normal one with 40GB NVIDIA A100 GPUs and a high-bandwidth one with 80GB NVIDIA A100 GPUs. Benchmarks up to 30 qubits were executed on normal GPU nodes, whereas circuits with more than 30 qubits were executed on high-bandwidth GPU nodes.


\subsubsection{Software Environment}

All quantum circuit simulations were performed using the Qiskit Aer simulator \cite{qiskitPaper}\cite{qiskit}\cite{qiskitAerGPU} with GPUs on a server with SUSE Linux Enterprise Server 15 SP4. To split a quantum circuit into sub-circuits, the benchmarks use the CutQC framework \cite{cutqc} based on the work by Tang, W. et. al. \cite{tang2021cutqc}.  

\noindent Below is a list of all major software used in the benchmarks and their respective versions.
\begin{itemize}
    \item Python 3.12.2
    \item Qiskit 1.0.2
    \item Qiskit-Aer-GPU 0.14.0.1
\end{itemize}




\subsection{Benchmarks}
\label{sec:benchmarks}

The circuits used in the benchmarks are selected from the CutQC paper. The benchmarks were run for the number of qubits ranging from 10 to 34 (the maximum number of qubits we can simulate using one node of Perlmutter). Two methods are used to simulate the circuits: the first one simulates the circuit as it is (an uncut circuit), and the other uses CutQC to split the circuit into multiple subcircuits and simulate these subcircuits.  

The evaluation runtime, i.e., the time required to simulate all circuits using Qiskit Aer, is the main performance metric captured to compare the simulation methods. Apart from this, the runtime is also captured for different phases of the circuit-splitting method to gain more insights into the runtime scaling. Finally, circuit-splitting metadata (which includes the subcircuit width and number of effective qubits for every subcircuit generated) is also captured, which helps us to co-relate some of the observed trends in the runtime plots.

\vspace{\baselineskip}
\noindent More information about the circuits benchmarked is listed below.

\begin{enumerate}
    \item \textit{Adder}: This is a quantum ripple-carry addition circuit with a single ancilla qubit and linear depth based on the work of Cuccaro, S. A. et. al. \cite{cuccaro2004new}. It can be used to sum two quantum registers of the same width. It is benchmarked for an even number of qubits.
    \item \textit{Approximate Quantum Fourier Transform (AQFT)}: Work done by Barenco, A. et al. \cite{barenco1996approximate} proposes that as far as periodicity estimation is concerned, the AQFT algorithm yields better results than the QFT (Quantum Fourier Transform) algorithm. It is also benchmarked for an even number of qubits and a standard implementation from the Qiskit circuit library is used to generate the circuit.
    \item \textit{Berstein-Vazirani (BV)}: A popular quantum algorithm based on the work of Bernstein, E. et. al. \cite{bernstein1993quantum} which solves the hidden string problem. The implementation used in the benchmark is referenced from the QED-C \cite{qedcBenchmark} benchmark suite.
    \item \textit{Hardware efficient ansatz (HWEA)}: An example of quantum variational algorithms inspired by the work of Moll, N. et. al. \cite{moll2018quantum}.
    \item \textit{Supremacy}: A type of 2-D random circuit based on the work by Boixo, S. et. al. \cite{boixo2018characterizing} to characterize quantum supremacy. Similar to the CutQC paper, benchmarks are performed for near-square-shaped (e.g. 3*4) circuit layouts (which are harder to cut).
\end{enumerate}

\noindent All the circuits used in the benchmarks are not dense (having a huge circuit depth) quantum circuits but are rather sparse when it comes to the layout of the gates applied to the qubits. This is necessary because we impose a constraint on the CutQC framework to cut a given circuit within 10 cuts and generate a maximum of 5 subcircuits. While cutting dense circuits like Grover's (implemented without using ancilla qubits) is theoretically possible using the framework, the number of cuts required to cut such a circuit is very high, leading to enormous classical post-processing costs and is therefore not practical to simulate. One of the goals of these benchmarks is to study the impact of different sparse layouts of circuits on the runtime and the incurred classical post-processing cost when these circuits are simulated using \textit{circuit splitting}.