\section{Appendix: Experimental results}
In this section, we present the results of the comprehensive experimental evaluation, which contains various combinations of query graphs, problem formulations, and classical and quantum optimizers. For each method proposed in this work, we evaluated the technique against five common query graph types: clique, star, chain, cycle, and tree. Each query graph is labeled using the format 'Graph name - number of nodes'. For each graph type and graph size, we randomly selected 20 query graph instances with cardinalities and selectivities. The cardinalities are randomly sampled from the range 10 to 50 and selectivity from interval $(0, 1]$. The costs are summed over 20 runs, describing a realistic cumulative error, and scaled with respect to the cost returned from the dynamic programming algorithm \textit{with} cross-products, which is the optimal left-deep plan. The anonymized code for this experimental evaluation can be found on GitHub \cite{anonymous2024qjoin}. Since we have used 20 query graph instances for five different graph types of sizes 3 to 60 and solved them with four different quantum and classical solvers, the total number of evaluated query graphs is in the thousands.

%After fixing one of the three proposed methods and a query graph instance, we have constructed the corresponding HUBO optimization problem. Then, we have submitted the problem for each selected solver. Depending on the solver's requirements, we might need to translate the HUBO problem into the equivalent QUBO problem. The available solvers include two quantum computing (D-wave quantum annealer, D-wave Hybrid quantum annealer) and two classical approaches (exact poly solver, Gurobi optimizer).

We have decided to focus on the quality of solutions instead of optimization time. Although time is crucial in real-life cases, integrating quantum computational systems with classical systems still brings an unavoidable overhead. Quantum computers work at the time scale of nano and milliseconds, but the classical pre-and post-processing makes the total computation time relatively long in practice. Concretely, these pre-and post-processing phases are demonstrated by such steps as encoding problems in HUBO/QUBO format, submitting them to a quantum computer over a possibly slow connection, and even waiting in line for the quantum computer to become available from the other users. After executing the workload, we need to translate the obtained results back into a format that allows us to interpret them in the light of the original problem.

\textbf{Summary of proposed methods.} We have proposed three algorithms to solve the join order selection problem with a higher-order unconstrained binary optimization model. Table \ref{table:methods} introduces names for these methods, which are used in this section.

\begin{table}[!ht]
\centering
\resizebox{0.5\columnwidth}{!}{
\begin{tabular}{|c|c|c|c|}
\hline
\textbf{Method name} & \textbf{Cost function} & \textbf{Validity constraint} \\ \hline
precise 1 & precise cost function & cost function dependent \\ \hline
precise 2 & precise cost function & cost function independent \\ \hline
heuristic & heuristic cost function & cost function dependent \\ \hline
\end{tabular}
}
\caption{Summary of proposed algorithms}
\label{table:methods}
\end{table}

\input{sections/results/precise_1}
\input{sections/results/precise_2}
\input{sections/results/heuristic_1}