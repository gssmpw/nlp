\section{Setting}

\subsection{Join order selection problem}

We start by formally defining the join order selection problem. We assume the SQL queries are given as query graphs of form $G = (V, E)$, where $V$ is the set of nodes (i.e., tables or relations). Fig.~\ref{fig:SQL_query_graph} shows an example of a query and its query graph. We denote relations as $R_i$ for some non-negative integer $i$. The set $E$ is the set of edges defined by join predicates $p_{ij}$ between tables $R_i$ and $R_j$. Every table $R_i$ has a cardinality, denoted by $|R_i|$, and every predicate has a selectivity $0 < f_{ij} \leq 1$. The join is denoted by $R_i \bowtie_{p_{ij}} R_j$. This work assumes that the joins are inner joins, although we will discuss the extension to other joins, such as outer joins.

\begin{figure}[tb]
    \centering
    \includegraphics[width = 0.3\columnwidth]{figures/SQL_to_query_graph_example.png}
    \caption{SQL query and its corresponding query graph}
    \label{fig:SQL_query_graph}
    \Description[SQL query and its corresponding query graph]{SQL query is represented as text containing the standard SQL keywords and four inner joins between five tables. This query corresponds to a tree-shaped query graph, and its corresponding query graph contains five nodes (tables). The inner join conditions in the query give the edges.}
\end{figure}

A join tree $T$ of a query graph $G$ is a binary tree where every relation of $G$ appears once in the leaf nodes, and every non-leaf node has a form $R_{k_1} \bowtie \ldots \bowtie R_{k_n}$ for some $R_{k_1}, \ldots, R_{k_n} \in G$ such that the two child nodes of $R_{k_1} \bowtie \ldots \bowtie R_{k_n}$ contain the relations $R_{k_1}, \ldots, R_{k_n}$. Following the definition in \cite{Neumann_Radke_2018}, we define that a join tree $T$ adheres a query graph $G$ if for every subtree $T' = T_1 \bowtie T_2$ of $T$ there exists relations $R_1$ and $R_2$ such that $R_1 \in T_1$ and $R_2 \in T_2$ and $(R_1, R_2) \in E$. The join order selection problem is finding a join tree $T$ that adheres to query graph $G$ and minimizes a given cost function. In the terminology of this paper, the first problem, a join tree adhering to the query graph, is called a \textit{validity constraint}. The problem of minimizing the cost is called a \textit{cost constraint}. Next, we define the standard cost function for join trees.

Standard cost functions are based on estimating cardinalities of intermediate results in the join order process \cite{10.14778/2850583.2850594, Neumann_course, cluet1995complexity}. Thus, we first define how to compute the cardinality of a given join tree $T$. For join tree $T$, its cardinality is defined recursively
\begin{equation}\label{eq:join_tree_card}
    |T| = \begin{cases}
    \ |R_i| &\quad \text{if } T = R_i \text{ is a leaf node} \\
    \ \prod_{R_i \in T_1, R_j \in T_2} f_{ij}|T_1||T_2| &\quad \text{if } T = T_1 \bowtie T_2.
    \end{cases}
\end{equation}

Based on the cardinalities, we define the cost function recursively as
\begin{equation}\label{eq:cost_function}
    C(T) = \begin{cases}
        \ 0 &\quad \text{if } T = R_i \text{ is a leaf node} \\
        \ |T| + C(T_1) + C(T_2) &\quad \text{if } T = T_1 \bowtie T_2.
    \end{cases}
\end{equation}
This is the standard cost function \cite{cluet1995complexity}, which has also been used in earlier quantum computing formulations \cite{Schonberger_Scherzinger_Mauerer, 10.14778/3632093.3632112, Schonberger_Trummer_Mauerer_2023} and in the corresponding MILP formulation \cite{Trummer_Koch_2017}.

\subsection{Unconstrained binary optimization}

Optimization is one of the key fields where quantum computing is assumed to provide computational value \cite{abbas2024quantumoptimizationpotentialchallenges}. This part provides a brief and high-level overview of how optimization algorithms are developed in quantum computing. We guide a reader to \cite{Nielsen_Chuang_2010, Winker_Groppe_Uotila_Yan_Lu_Franz_Mauerer_2023} to more detailed basics about quantum computing. Additionally, \cite{Schonberger_Scherzinger_Mauerer} provides an excellent introduction to quantum annealing and quadratic unconstrained binary optimization models for a database specialist.

Our work relies on Higher-order Unconstrained Binary Optimization (HUBO) \cite{boros_2002} problems, which are a generalization of Quadratic Unconstrained Binary Optimization (QUBO) problems. As far as we know, there is little research on formulating domain-specific problems using HUBOs. One use case for HUBOs has been optimizing matrix multiplication algorithms \cite{uotila2024tensordecompositionsadiabaticquantum}. One reason for this is that HUBO problems are hard not only theoretically but also practically \cite{boros_2002}. Due to this computational complexity, they provide a potential area for exploring the practical benefits of quantum computing over classical approaches. Despite being challenging, they have a straightforward quantum computational formulation \cite{10313783} in theory.

Next, we define HUBO problems \cite{boros_2002} formally and show their connection to QUBO problems. Let $x \in \left\{0, 1 \right\}^{n}$ be a binary variable vector of type $x = (x_1, \ldots, x_n)$ so that $x_i \in \left\{ 0, 1 \right\}$ representing values false and true. Let $[n] = \left\{1, \ldots, n \right\}$ be an indexing set. The HUBO problem is the following minimization problem of a binary polynomial
\begin{equation}\label{eq:hubo}
    \argmin_{x \in \left\{0, 1 \right\}^{n}} \ \sum_{S \subset [n]}\alpha_{S}\prod_{i \in S}x_i,
\end{equation}
where $\alpha_{S} \in \mathds{R}$. For each non-empty subset $S$, we have the corresponding higher-order term $\alpha_{S}\prod_{i \in S}x_i$. In practice, we have $\alpha_{S} = 0$ for many terms. Otherwise, in the worst case, we have $2^{|S|} - 1$ terms. In this work, \textit{term} will sometimes mean the variable-tuple $\prod_{i \in S}x_i$ (excluding the coefficient $\alpha_{S}$), but in those cases, we will explicitly indicate what the coefficient is. Alternatively, we can write the same polynomial as
\begin{equation}\label{def:hubo_open}
    \sum_{S \subset [n]}\alpha_{S}\prod_{i \in S}x_i = \sum_{i \in [n]}\alpha_i x_i + \sum_{i < j}\alpha_{i,j}x_ix_j + \sum_{i < j < k}\alpha_{i,j,k}x_ix_jx_k + \ldots
\end{equation}

Quadratic Unconstrained Binary Optimization (QUBO) problems are a restricted case of HUBO problems where we consider only limited-sized subsets $|S| \leq 2$. Concretely, a QUBO problem is the minimization problem of the polynomial
\begin{equation}\label{def:qubo}
    \sum_{i \in [n]}\alpha_i x_i + \sum_{i < j}\alpha_{i,j}x_ix_j.
\end{equation}
Both QUBO and HUBO problems are NP-hard \cite{lucas_2014, boros_2002}. As discussed, QUBO formalism has been the standard method for tackling database optimization problems, and many other well-known optimization problems (e.g., knapsack, maxcut, and traveling salesman) have a QUBO formulation \cite{lucas_2014}.

\subsection{Optimization on quantum hardware}

Next, we briefly introduce the basics of quantum computing for optimization problems and discuss techniques for solving HUBOs and QUBOs on quantum hardware. Quantum computing can be divided into multiple paradigms regarding hardware and software. This division is exceptionally versatile since there is no "winning" method for building quantum computers yet. Quantum computers are designed to be built on superconducting circuits (IBM, Google, IQM) \cite{Wendin_2017}, trapped ions (Quantinuum, IonQ) \cite{paul1990electromagnetic}, neutral atoms (Quera, Pasqal) \cite{GRIMM200095}, photons (Xanadu) \cite{knill2001scheme}, diamonds (Quantum Brilliance) \cite{neumann2008multipartite}, and many other quantum mechanical phenomena \cite{https://doi.org/10.1002/spe.3039}. A special type of quantum hardware is a quantum annealer (D-Wave) \cite{APOLLONI1989233, PhysRevE.58.5355}, which does not implement universal quantum computation but offers specific optimization capabilities with better scalability.

On top of the hardware, a partly hardware-dependent software stack is designed to translate and compile high-level quantum algorithms into a format that specific quantum hardware supports. As we will explain, QUBOs are a widely accepted high-level abstraction that can be solved on most quantum hardware. The other common high-level abstraction is quantum circuits. Quantum algorithm design can still be divided into paradigms: adiabatic and circuit-based quantum computing, which are universal quantum computing paradigms \cite{Aharonov_van_Dam_Kempe_Landau_Lloyd_Regev_2004}. Unlike traditional introductions to quantum computing, we focus on the fundamentals of adiabatic quantum computing. This choice is motivated by the fact that our experimental evaluation was conducted on a quantum annealer, a type of adiabatic quantum computer. Due to space limitations, we introduce the more commonly used quantum circuit model in the appendix. With the circuit model, we have another set of tools to optimize unconstrained binary optimization problems. Since the scalability of universal quantum computers using quantum circuits is still very limited, we present the connection between our algorithms and the quantum circuit model only theoretically and hope that our work is a motivating and practical use case.

\textbf{Adiabatic quantum computing.} Quantum computing can be implemented utilizing the adiabatic evolution of a quantum mechanical system \cite{Farhi_Goldstone_Gutmann_Sipser_2000}. This work utilizes quantum annealing, which is a part of the adiabatic quantum computing paradigm \cite{Lidar_adiabatic}. We start from the axiomatic fact that the SchrÃ¶dinger equation describes an evolution of the quantum mechanical system \cite{Nielsen_Chuang_2010}. This evolution models a system with a Hermitian operator known as a Hamiltonian. In this work, we are not interested in arbitrary Hamiltonians but in those with a form that maps to QUBO and HUBO optimization problems. For QUBOs, the corresponding problem Hamiltonian, also called an Ising Hamiltonian, is
\begin{displaymath}
\sum_{i} h_i \sigma_{z}^{i} + \sum_{j < i} J_{i,j}\sigma_{z}^{i}\sigma_{z}^{j},
\end{displaymath}
where $\sigma_{z}^{j}$ are Pauli-Z operators for each $j$. The correspondence between the formulation in Eq. \eqref{def:qubo} is clear: the coefficients $h_i$ are the linear terms, and $J_{i,j}$ are the quadratic terms. For each $i$, $\sigma_{z}^{i}$ corresponds to the variable $x_i$. For HUBOs the problem Hamiltonian is
\begin{displaymath}
    \sum_{S \subset [n]}\beta_{S}\prod_{i \in S}\sigma_{z}^{i},
\end{displaymath}
where the correspondence to Eq. \eqref{def:hubo_open} is the same. As in the case of QUBOs and HUBOs, we aim to minimize the value of a Hamiltonian. In other words, we aim to find a quantum state, called a ground state, where the Hamiltonian's energy is minimized. After minimizing the Hamiltonian, we also obtain a solution to the corresponding combinatorial optimization problem \cite{Farhi_Goldstone_Gutmann_Sipser_2000}.

Since a Hamiltonian $H$ is a Hermitian operator by definition, it has the following spectral decomposition
\begin{displaymath}
    H = \sum_{e} \lambda_{e}|e\rangle \langle e|,
\end{displaymath}
where $\lambda_{e}$ are the operator's eigenvalues and $|e\rangle$ are its eigenstates. Minimizing the Hamiltonian and solving the corresponding combinatorial optimization problem require finding the lowest eigenvalue $\lambda_{e}$ and its corresponding eigenstate, also called a ground state. This is the central problem addressed by the quantum computing methods introduced in this work.

Next, we describe how adiabatic quantum computing can find the lowest eigenstate and solve the optimization problem. For simplicity, let us focus on solving QUBOs on a quantum annealer. The general adiabatic quantum computing is similar \cite{Lidar_adiabatic}. We define the following Hamiltonian \cite{d_wave}
\begin{equation}\label{eq:adiabatic_Hamiltonian}
H(s) = \underbrace{-\frac{A(s)}{2}\sum_{i} \sigma_{x}^{i}}_{\text{initial Hamiltonian}} + \underbrace{\frac{B(s)}{2}\left( \sum_{i} h_i \sigma_{z}^{i} + \sum_{j < i} J_{i,j}\sigma_{z}^{i}\sigma_{z}^{j}\right)}_{\text{problem Hamiltonian}},
\end{equation}
where $A(s)$ is the so-called tunneling energy function and $B(s)$ is the problem Hamiltonian energy function at $s$. During the annealing process, the value $s$ runs from $0$ to $1$ , causing $A(s) \to 0$ and $B(s) \to 1$. We begin with a simple initial Hamiltonian, whose ground state is easy to prepare, and gradually evolve to the problem Hamiltonian. By the adiabatic theorem \cite{Lidar_adiabatic}, if the process is slow enough, the system remains in its ground state and ends up solving the optimization problem. However, quantum annealers are limited to solving QUBOs, meaning we cannot encode higher-order terms in the problem Hamiltonian. In contrast, universal adiabatic and gate-based quantum computers do not have this restriction.

\textbf{Classical computers.} Considering classical computers, we can solve QUBOs using simulated annealing \cite{doi:10.1126/science.220.4598.671}, digital annealing \cite{Aramon_Rosenberg_Valiante_Miyazawa_Tamura_Katzgraber_2019}, and classical solvers such as Gurobi and CPLEX. Unfortunately, classical solvers cannot natively solve higher-order binary optimization models, but we have to rely on rewriting methods that reduce HUBOs into QUBOs. We introduce two reduction methods to rewrite higher-order problems into quadratic ones. Due to space limitations, the details of these reduction methods are in the appendix. The key idea is to replace higher-order terms with slack variables.