\subsection{Precise cost function as HUBO}\label{subsection:cost_function}

After defining the binary variables of our optimization model, we describe how we encode the cost function as a higher-order unconstrained binary optimization problem whose minimum is the optimal cost up to cross products for the left-deep join order selection problem. We describe the cost constraint first since the validity constraints can be computed based on terms that we compute for the cost constraint. First, we demonstrate the intuition behind the construction with an example.

\begin{example}\label{ex:example2}
Every join should be performed at exactly one rank for left-deep join trees. Starting from rank $0$, let us say that we choose to perform a join between the relations $R_1$ and $R_2$ and obtain $R_1 \bowtie R_2$. The corresponding activated binary variable is $x_{1,2}^{0} = 1$. Based on Def.~\eqref{eq:cost_function} of the cost function, the cost of performing this join is $f_{1,2}|R_1||R_2|$. Thus, if we decide to make this join at this rank, we include the term
\begin{equation*}
    f_{1,2}|R_1||R_2|x_{1,2}^{0}
\end{equation*}
to the cost HUBO. This example demonstrates that it is easy to encode the costs at rank $0$, which correspond to linear variables in the cost HUBO.

Next, we assume the query graph gives us a join predicate with selectivity $f_{2,3}$ between the tables $R_2$ and $R_3$. Now we ask how expensive it is to perform the join between intermediate result $R_1 \bowtie R_2$ and relation $R_3$. By Def.~\eqref{eq:cost_function}, the cost of making this join is
\begin{equation}\label{eq:card_123}
    f_{1,2}f_{2,3}|R_1||R_2||R_3|
\end{equation}
assuming that there is no edge $(R_1, R_3)$ which indicates that $f_{1,3} = 1$. Note that this is not the total cost of performing all the joins but the cardinality of the resulting table $R_1 \bowtie R_2 \bowtie R_3$. The left-deep join tree $(R_1 \bowtie R_2) \bowtie R_3$ should be selected if the following total cost function evaluates to a relatively small value
\begin{equation*}
    f_{1,2}|R_1||R_2|x_{1,2}^{0} + f_{1,2}f_{2,3}|R_1||R_2||R_3|x_{1,2}^{0}x_{2,3}^{1}.
\end{equation*}
When the binary variables are active, i.e., $x_{1,2}^{0} = x_{2,3}^{1} = 1$, the previous function evaluates the total cost of performing the join $(R_1 \bowtie R_2) \bowtie R_3$.

One of the key ideas is that the cardinality in Eq. \eqref{eq:card_123} does not depend on the join order but only on the tables that are part of the join at that point. In other words, this means that the cardinality in Eq. \eqref{eq:card_123} is the same for any join result that includes the relations $R_1$, $R_2$ and $R_3$ such as $(R_1 \bowtie R_3) \bowtie R_2$ and $R_1 \bowtie (R_2 \bowtie R_3)$. This naturally generalizes to any number of relations. The total costs of these plans likely differ because intermediate steps have different costs. Intuitively, our HUBO model seeks the optimal configuration of joins to construct the full join tree so that the sum of the intermediate results is the smallest.
\end{example}

Next, we formally describe constructing the HUBO problem that encodes the precise cost function for a complete left-deep join order selection problem respecting the structure of a given query graph $G$. The HUBO problem is constructed recursively with respect to the rank $r$. The construction of the HUBO problem becomes recursive because the definition of the cost function \eqref{eq:cost_function} is recursive.

\textbf{Step $r = 0$.} Let $G = (V, E)$ be a query graph. Based on Def.~\eqref{eq:cost_function}, we include the costs of making the rank $0$ joins to the cost HUBO. Precisely, we add terms
\begin{equation*}
    |R_i \bowtie R_j|x_{i,j}^{0} = f_{ij}|R_i||R_j|x_{i,j}^{0} = \alpha_{(i,j)}x_{i,j}^{0},
\end{equation*}
for every join $(R_i, R_j) \in E$, where we denote $\alpha_{(i,j)} := f_{ij}|R_i||R_j|$ the coefficient.

\textbf{Step $r = 1$.} For clarity, we also show step $r = 1$. Assuming we have completed step $r = 0$, we consider adding variables of type $x_{i,j}^{1}$. For every join $(R_i, R_j) \in E$, we select the adjacent joins $(R_{i'}, R_{j'})$ in the query graph. An adjacent join means that the joins share exactly one common table. This creates quadratic terms of type $x_{i,j}^{0}x_{i',j'}^{1}$ with coefficients of type $$\alpha^{1}_{(i,j,i',j')} = f_{ij}f_{i'j'}f_{i'j}f_{ij'}|R_i||R_j||R_i'||R_j'|.$$ So, we add terms $\alpha_{(i,j,i',j')}x_{i,j}^{0}x_{i',j'}^{1}$ to the cost HUBO.

\textbf{Step for arbitrary $r$.} Next, we consider adding a general rank $0 < r < |V| - 1$ variables of form $x_{i', j'}^{r}$ to the HUBO problem. For the general case, we formalize the method using connected subgraphs in the query graph: Let $\mathcal{S}$ be the set of size $r-1$ connected subgraphs in the query graph so that every subgraph corresponds to terms that were generated at step $r-1$. Since the cost function is defined recursively, this is an alternative way to express that we have added the variables to rank $r - 1$. This means that the HUBO problem, encoding the total cost up to this step, has the form:
\begin{align*}
    \underbrace{\sum_{(i, j) \in E}\alpha_{(i,j)} x_{i,j}^{0}}_{\text{case } r = 0} + \underbrace{\sum_{(i, j) \in E}\sum_{(i', j') \in E} \alpha_{(i,j,i',j')} x_{i,j}^{0}x_{i', j'}^{1}}_{\text{case } r = 1} + \ldots  
    + \underbrace{\sum_{S \in \mathcal{S}}\alpha_{S}\prod_{(R_i, R_j) \in S, 0\leq k \leq r - 1} x_{i,j}^{k}}_{\text{case } r - 1}.
\end{align*}
For simplicity, we first focus on generating the next term without a coefficient. Let $S \in \mathcal{S}$ be a fixed subgraph of the query graph. Let $(R_{i'}, R_{j'}) \in E$ be an edge that is not part of the subgraph $S$ but connected to it so that either $R_{i'} \in S$ or $R_{j'} \in S$ (but not both $R_{i'}, R_{j'} \in S$). This means we join exactly one new table. For this fixed subgraph $S$ and fixed join $(R_{i'}, R_{j'})$, we are going to add the following element to the cost HUBO:
\begin{equation}\label{eq:new_term}
\underbrace{\prod_{(R_i, R_j) \in S, 0\leq k \leq r - 1} x_{i,j}^{k}}_{\text{term at rank } r - 1} \underbrace{x_{i',j'}^{r}}_{\text{new variable at rank } r}
\end{equation}
The new term is just the ''old'' term from the previous step multiplied by the new variable $x_{i',j'}^{r}$.

The new coefficient is easy to compute based on the subgraph $S$ and the latest included join $(R_{i'}, R_{j'})$. Precisely, consider the new induced subgraph $S' = S \cup \left\{(R_{i'}, R_{j'})\right\}$. Note that the induced subgraph $S'$ may contain new edges besides the latest included edge $(R_{i'}, R_{j'})$. However, the new coefficient for term \eqref{eq:new_term} is
\begin{equation}\label{eq:term_coefficient}
\alpha_{S'} = \prod_{(R_i, R_j) \in S'}f_{i,j}\prod_{R_i \in S'}|R_i|.
\end{equation}
This formula is just the general expression of Eq.~\eqref{eq:card_123} in Example \ref{ex:example2}. The previous construction is repeated for each subgraph $S \in \mathcal{S}$ and each edge adjacent to subgraph $S$ sharing one common vertex (i.e., a table). The idea of how the terms are appended at rank $2$ is visualized in Fig.~\ref{fig:subgraph_generation}. One of the final configurations is visualized in Fig.~\ref{fig:subgraph_to_terms}, which also shows how the terms are interpreted as join trees.

\begin{figure}
\centering
\begin{subfigure}[t]{.49\linewidth}
  \centering
  \includegraphics[width = \textwidth]{figures/subgraph_generation.png}
  \caption{With relations 0, 1, and 2 already joined, relation 3 is the only option for left-deep plans. Two combinations arise based on whether edge $(0,2)$ or $(1,2)$ joins first. Coloring links graph variables, generating terms in HUBO.}
  \label{fig:subgraph_generation}
  \Description[subgraph_generation]{Assuming we have considered the relations 0, 1, and 2 at earlier ranks, then the only possible relation we can join in left-deep plans is relation 3. Two combinations are included depending on whether edge $(0,2)$ or edge $(1,2)$ is joined first. Coloring highlights the connection between variables in the graph and produces terms in HUBO.}
\end{subfigure}\hfill
\begin{subfigure}[t]{.49\linewidth}
  \centering
    \includegraphics[width = \textwidth]{figures/subgraph_to_terms.png}
    \caption{The figure presents one option as the final assignment for the binary variables in the query graph. The algorithm returns the corresponding join tree if the variables are selected true.}
    \label{fig:subgraph_to_terms}
    \Description[subgraph_to_terms]{The figure presents one option as the final assignment for the binary variables in the query graph. The algorithm returns the corresponding join tree if the variables are selected true.}
\end{subfigure}
\caption{Two examples for variable generation in tree query graph}
\label{fig:test}
\end{figure}

The algorithm to generate the cost HUBO is presented in Alg.~\ref{alg:hubo_term_construction}. It inputs a query graph and outputs a dictionary called HUBO, which stores the terms of the cost HUBO problem. The keys in this dictionary are sets of tables, and the values are sets of terms. We exclude the coefficient computation for simplicity since the coefficients can be efficiently computed with Eq.~\eqref{eq:term_coefficient}.

\input{algorithms/dfs_subgraph_enumeration}