\section{Join order cost as HUBO}

In this section, we develop two higher-order unconstrained binary optimization (HUBO) problems that encode the cost function in Eq.~\eqref{eq:cost_function} for a left-deep join order selection problem. Compared to the previous quantum computing for join order optimization research, we formulate the optimization problem from the perspective of \textit{joins} instead of the perspective of \textit{relations} \cite{Schonberger_Scherzinger_Mauerer}. Given a query graph $G$, the number of required joins to create a valid left-deep join tree is $|V| - 1$, where $|V|$ is the number of nodes (i.e., relations, tables) in query graph $G$. This is easy to see since the first join is performed between two tables, and after that, every join includes one more table until all the tables have been joined.

Our algorithm is designed to rank joins, and ranking gives the order for the joins. This means a join (i.e., edge in the query graph $G$) has a rank $0 \leq k < |V| - 1$ if the join should be performed after all the lower rank joins are performed. We need $|V| - 1$ rank values to create a left-deep join order plan. Having $|V| - 1$ rank values applies to left-deep join plans but not bushy ones. For bushy plans, we can join multiple tables simultaneously, meaning that some of the joins can have the same rank, i.e., appear at the same level in the join tree.

Initially, any join $(R_i, R_j) \in G$ can have any rank $0 \leq r < |V| - 1$. We define the binary variables of our HUBO problems to be
\begin{equation}\label{def:binary_variables}
    x_{i,j}^{r} \in \left\{0, 1 \right\},
\end{equation}
where the indices $i$ and $j$ refer to the relations $R_i$ and $R_j$ and $r$ denotes the rank. Hence, our model consists of $(|V|- 1)|E|$ binary variables since for every rank value $0 \leq r < |V| - 1$, we have $|E|$ many joins (edges) from which we can choose the join.

The interpretation of these binary variables is as follows: If $x_{i,j}^{r} = 1$, then the join $(R_i, R_j)$ should be performed at rank $r$. Now the join $(R_i, R_j)$ is not necessarily between the tables $R_i$ and $R_j$ since at $r > 0$ the left relation is an intermediate result of type $R_{k_1} \bowtie \ldots \bowtie R_i \bowtie \ldots \bowtie R_{k_n}$ for some indices $k_1, \ldots, k_n$. Thus, the tuples $(R_i, R_j)$ represent joins in the query graph rather than materialized joins in query processing.

\begin{example}
Consider that we have a simple, complete query graph of four relations $\left\{0,1,2,3\right\}$. Thus, we have $|V| = 4$ relations, $|E| = 6$ possible joins and $(|V| - 1)|E| = 18$ binary variables. Depending on the selectivities and cardinalities, an example solution that the model can return is $x_{0,1}^{0} = 1$, $x_{1,2}^{1} = 1$, and $x_{2,3}^{2} = 1$, which gives us left-deep join tree $[[0, 1], 2], 3]$. The solution is not unique; also $x_{0, 1}^{0} = 1$, $x_{0, 2}^{1} = 1$, and $x_{2, 3}^{2} = 1$ produces the same plan with the same cost.
\end{example}

\input{sections/join_order_selection_theory/precise}
\input{sections/join_order_selection_theory/heuristic}