\section{Appendix: Background on quantum computing}

\subsection{Quantum circuit model}

In this part, we define the quantum circuit model \cite{Nielsen_Chuang_2010}. Classical computers operate with bits having discrete values of $0$ or $1$. Quantum computing is based on quantum bits, called qubits, that are formally represented as vectors in a complex-valued Hilbert space. For a single qubit system, the basis vectors of this space are $|0\rangle:= [1, 0]^{\top}$ and $|1\rangle:= [0, 1]^{\top}$. Every state in a single-qubit quantum computer can be represented as a complex-valued linear combination of these basis states as $|\varphi\rangle = \alpha |0\rangle + \beta |1\rangle$, where $\alpha, \beta \in \mathds{C}$ so that $|\alpha|^2 + |\beta|^2 = 1$. The values $\alpha$ and $\beta$ are also called amplitudes, and their squared lengths $|\alpha|^2 $ and $|\beta|^2$ can be interpreted as a probability distribution. Since a qubit is an element of a Hilbert space equipped with the standard tensor product, we can construct larger systems by applying tensor product operation between the smaller systems. For example, a two-qubit system is described by four basis states: $|0\rangle\otimes|0\rangle = |00\rangle$, $|01\rangle$, $|10 \rangle$ and $|11\rangle$.

The quantum algorithm is implemented by applying quantum logic gates to the qubits. These gates must respect the condition that the resulting quantum system has $\sum_{i}|\alpha_i|^2 = 1$ over the amplitudes $\alpha_i$. The operations which satisfy this property are the unitary matrices. A matrix $U$ over the complex numbers is unitary if its inverse is its conjugate transpose. The conjugate transpose is obtained by conjugating the matrice's complex-valued elements and then transposing the matrix. A quantum circuit represents a quantum computational system where the circuit's wires represent qubits, and operations are represented as gates acting on wires. 

The system is measured after the gates have been applied to the qubits. Measurement operation is especially characteristic of quantum computing and does not have a similar role in classical computing. Informally, measuring corresponds to the return statement at the end of a classical function. The most common measurement operation is measuring on a computational basis. This means that after a measurement, we obtain a classical bit string whose length is the number of qubits. For example, if we measure a 2-qubit system, the possible measurement results are $00$, $01$, $10$, and $11$. The connection to the amplitudes is the following: if the system has a state $\alpha_{11}|11\rangle$, then the value $|\alpha_{11}|^2$ is the probability that we obtain the result $11$ when we measure. 

In quantum computing, we can perform various measurements \cite{Nielsen_Chuang_2010}. In this work, we measure an expectation value of an observable, which is a typical measurement operation in practical applications. This measurement estimates the Hamiltonian's energy value corresponding to the cost we aim to minimize in the combinatorial optimization problem. The expectation value can be interpreted as the weighted average of all possible measurement outcomes, where each outcome is weighted by its probability. However, it does not necessarily correspond to the most probable measurement outcome. Formally, suppose $H$ is an operator such as a Hamiltonian. In that case, we compute $\langle \varphi | H | \varphi \rangle = \sum_{j}\lambda_j |\langle\varphi | \lambda_j\rangle|^2$, where $\lambda_j$ and $|\lambda_j \rangle$ are the eigenvalue and eigenvectors of the operator $H$ and the state $| \varphi \rangle$ is the state where the quantum mechanical system is before the measurement. Now the sum is the weighted average of the eigenvalues which are precisely the measurement results when measuring the observable: the eigenvalues $\lambda_j$ are the measurement outcomes, and $|\langle\varphi | \lambda_j\rangle|^2$ corresponds to the probability, which can be viewed as an overlap between the eigenstate $|\lambda_j \rangle$ and the system's current state $| \varphi \rangle$.

\subsection{QAOA and VQE}

On the gate-based universal quantum computers, we can apply the Quantum Approximate Optimization Algorithm (QAOA) \cite{farhi2014quantum} or Variational Quantum Eigensolver (VQE) \cite{Peruzzo_2014} to find the ground state of the Hamiltonian. Both QAOA and VQE are variational algorithms, meaning we execute them in two phases: first, we execute the circuit with a fixed parameter configuration on a quantum computer, then we estimate the circuit's gradient on a classical computer and tune the parameters. These two phases are repeated until a sufficiently good parameter configuration is found. 

First, we focus on QAOA. In this algorithm, we create two Hamiltonians: a mixer Hamiltonian $H_{\mathrm{mix}}$ and a problem Hamiltonian $H_{C}$. The most common mixer Hamiltonian is $H_{\mathrm{mix}} = \sum_{j}\sigma_{x}^{j}$. These Hamiltonians roughly correspond to the initial Hamiltonian and the problem Hamiltonian in Eq.~\eqref{eq:adiabatic_Hamiltonian}, and the cost Hamiltonian encodes the solution to the optimization problem. Then, we prepare two parametrized circuits for each Hamiltonian: $U_{C}:= e^{-i\gamma H_C}$ and $U_{\mathrm{mix}}:= e^{-i\alpha H_{\mathrm{mix}}}$. More concretely, implementing Hamiltonians as circuits, we follow the idea presented in \cite{Nielsen_Chuang_2010}. For example, if the Hamiltonian is $H = 2\sigma_{z}^{0} \otimes \sigma_{z}^{1} \otimes \sigma_{z}^{2}$, then the corresponding parametrized circuit is in Fig.~\ref{fig:circuit_example}. The important point is that we can natively encode and optimize HUBO problems using this method.
\begin{figure}
    \centering
    \input{figures/circuit_example}
    \caption{Circuit implementing the Hamiltonian $H = 2 \sigma_{z}^{0} \otimes \sigma_{z}^{1} \otimes \sigma_{z}^{2}$}
    \label{fig:circuit_example}
\end{figure}
Next, we define the complete QAOA circuit, which is a repeated application of circuits $U_C$ and $U_{\mathrm{mix}}$ for $n$ times. The precise value of $n$ depends on the problem, but already values such as $3$ have proved to be good \cite{farhi2014quantum}. Then, we prepare an equal superposition over all the basis states, choose random initial values for the parameters $\gamma$ and $\alpha$, and apply the complete QAOA circuit to the state. The equal superposition encodes that initially, every possible binary configuration has an equal probability of being selected as a solution. After preparing the circuit, we measure the expectation value of the cost Hamiltonian $H_C$. Then, we repeat the circuit execution with modified parameters $\gamma$ and $\alpha$. Since parametrized unitaries are differentiable, the circuits are also differentiable with respect to the parameters, and we can optimize the parameters $\gamma$ and $\alpha$ using classical stochastic gradient descent methods. The optimization goal is to find a parameter configuration that minimizes the expectation value of the Hamiltonian, which solves the combinatorial optimization problem.

The basic principles of VQE are similar to those of QAOA, except that the VQE circuit does not implement $U_C$ and $U_{\mathrm{mix}}$ circuits. The parameterized circuit in VQE is a sophisticated guess that is optimized to minimize the energy of the Hamiltonian using classical gradient descent methods. In VQE, we also measure the expectation value of the cost Hamiltonian $H_C$. QAOA and VQE have many modified versions that tackle challenges in the current noisy intermediate-scale quantum computing. 