\section{Problem Definition}

\begin{figure*}[th!]
\centering
\includegraphics[width=1.0\textwidth]{Figs/Fig.overview.pdf}
\caption{Overview of our work for developing coding tutoring agents. \textbf{Left}: The context of the coding tutoring problem. \textbf{Middle}: Trace-and-Verify (\textsc{Traver}) workflow. \textbf{Right}: \textsc{Dict} evaluation protocol.
}
\label{fig:overview}
\end{figure*}



We formulate coding tutoring as an interactive dialogue process between a \textbf{tutor} and a \textbf{student}, where the goal is to help the student implement a working solution that passes predefined unit tests for a target coding task.

Formally, the tutor is assigned a coding task $\mathcal{T}$ that consists of a function signature and a requirement description outlining the desired functionality. 
The tasks are repository-level, which require an understanding of multiple interdependent files within the codebase to implement a correct solution.
The tutor has access to task-specific knowledge $\mathcal{K}$, which includes (\romannumeral1) \textit{Code Contexts}: Contextual code snippets surrounding the desired code, which help the tutor show examples when necessary; (\romannumeral2) \textit{Reference Dependencies}: Cross-referenced elements such as intra-class, intra-file, and cross-file dependencies, along with their corresponding descriptions (e.g., docstrings), which involve key knowledge for completing the desired code; and (\romannumeral3) \textit{Reference Solution Steps}: Key steps required to complete the target task, describing using natural languages. 

The student is given the task $\mathcal{T}$ and possesses some subset of $\mathcal{K}$ as their prior knowledge, but the tutor remains unaware of which specific concepts or dependencies the student has already mastered.
The goal of the tutor is to guide the student, regardless of his or her background, toward solving the task $\mathcal{T}$ through multi-turn interactions.
