\section{Methodology}
We formulate the tool learning task, present our motivation, and propose the \texttt{ToolCoder} framework.

\subsection{Task Formulation and Motivation}
The goal of tool learning is to enable a LLM $\mathcal{M}$ to accomplish natural language tasks by generating and executing appropriate tool sequences. Given a task $q$, the LLM selects appropriate tools from a toolbox $\mathcal{T} = \{t_1, t_2, \ldots, t_{|\mathcal{T}|}\}$, where each tool $t_i$ is accompanied by its documentation $d_i \in \mathcal{D}$ describing its functionality, arguments, and output schema. Through tool interaction, $\mathcal{M}$ generates a solution response $r$ that finally addresses the task.

% Existing methods struggle with complex task planning and robust execution. Software engineering principles, which emphasize modular design, systematic error diagnosis, and code reusability, offer valuable insights to address these limitations. Furthermore, by expressing complex task through structured code, LLMs can leverage coding paradigms to enhance their systematic reasoning and planning capabilities~\cite{DBLP:conf/icml/GaoMZ00YCN23, DBLP:conf/icml/WangCY0L0J24}.
Existing methods struggle with complex task planning and robust execution. To address these limitations, We draw inspiration from software engineering principles, which emphasize modular design, error diagnosis, and code reusability. Furthermore, by expressing complex tasks through structured code, LLMs can leverage established programming paradigms to enhance their systematic reasoning and planning capabilities~\cite{DBLP:conf/icml/GaoMZ00YCN23, DBLP:conf/icml/WangCY0L0J24}.

% Inspired by these insights, we reformulate tool learning as a code generation task, transforming natural language tasks into code generation with tool-specific function implementation. This code-centric reformulation implements standardized function interfaces and incorporates fundamental software engineering principles, including requirement analysis, task decomposition, modular implementation, error handling, and code reuse. By structuring tool operations as well-defined programming components, our approach effectively leverages both software engineering methodologies and LLMs' code generation capabilities to enhance the reliability and efficiency of tool learning systems.



% Inspired by these insights, we reformulate tool learning as a code generation task, where natural language tasks are transformed into structured programs consisting of a main orchestration function $f_{\text{main}}$ and constituent functions $\mathcal{F}$ that utilize specific tools. This code-centric approach enables the application of fundamental software engineering principles throughout the learning process: from initial requirement analysis and task decomposition, through modular implementation, to systematic error handling and code reuse. By structuring tool operations as well-defined programming components with standardized interfaces $(f_i: (\text{input}_i) \rightarrow \text{output}_i)$, we leverage both the systematic methodology of software engineering and the code generation capabilities of LLMs to enhance the effectiveness and reliability of tool learning systems.


Inspired by these insights, we reformulate tool learning as a code generation task. This reformulation enables us to \emph{apply fundamental software engineering principles throughout the tool learning process: from initial requirement analysis and task decomposition, through modular implementation, to systematic error handling and code reuse}. 
By structuring tool operations as well-defined programming components, we can leverage both the systematic methodology of software engineering and the code generation capabilities of LLMs.


% Formally, we reformulate the tool learning process as a structured code generation task. Given a natural language task $q$ and a toolbox $\mathcal{T}$, our objective is to generate an executable program $\mathcal{P}$ that effectively orchestrates the available tools to produce the desired response $r$. This reformulation can be expressed as:

% $\mathcal{P} = \{f_{\text{main}}, \mathcal{F}\}$, where $f_{\text{main}}$ represents the main orchestration function and $\mathcal{F} = \{f_1, f_2, ..., f_n\}$ denotes a set of constituent functions, each utilizing specific tools from $\mathcal{T}$. Each function $f_i$ follows a standardized interface:

% $f_i: (\text{input}_i) \rightarrow \text{output}_i$

% The program $\mathcal{P}$ is generated through a systematic process:
% $\phi: (q, \mathcal{T}, \mathcal{D}) \rightarrow \mathcal{P}$

% where $\phi$ represents the transformation from natural language to executable code, incorporating tool documentation $\mathcal{D}$ to ensure proper tool usage. The final response $r$ is obtained by executing $\mathcal{P}$:

% $r = \text{execute}(\mathcal{P})$

% This code-centric reformulation naturally incorporates software engineering principles: structured program design through function composition, explicit interface definitions, and systematic error handling through standard programming constructs.


\subsection{\texttt{ToolCoder}: Code-Empowered Tool Learning Framework}
We propose a novel framework \texttt{ToolCoder}, which converts queries into Python function scaffolds (\S~\ref{sec:task_to_code}), performs subtask planning and tool selection (\S~\ref{sec:planning}), and generates executable implementations (\S~\ref{sec:main_function}) with error reflection mechanisms (\S~\ref{sec:reflection}), as illustrated in Figure~\ref{fig:overview}.

% This code-empowered approach leverages the reasoning power of LLMs, Python’s error traceback for reliable debugging (\S~\ref{sec:reflection}), and a reusable repository of executed code snippets to enhance efficiency and reduce redundancy.
% \texttt{ToolCoder} stimulates the reasoning power of LLMs, incorporates systematic error handling  (\S~\ref{sec:reflection}), and establishes a reusable code repository to promote efficiency and reduce redundancy.

\subsubsection{Task-to-Code Transformation}
\label{sec:task_to_code}

Our \texttt{ToolCoder} starts by identifying user needs and transforming the natural language task $q$ into a structured Python function scaffold $c$, aligning with the requirements analysis phase in software engineering. This process can be formalized as:
\begin{equation}
\textstyle
\setlength\abovedisplayskip{0.2cm}
\setlength\belowdisplayskip{0.2cm}
\begin{aligned}
c = \mathcal{M}_{T2C}(q),
\end{aligned}
\end{equation}
% where $\mathcal{M}_{T2C}$ denotes the task-to-code transformation module and is implemented with the prompt provided in Appendix Figure~\ref{fig:task_to_code_prompt}. 
where $\mathcal{M}_{T2C}$ represents the task-to-code transformation module, following the prompt template shown in Appendix Figure~\ref{fig:task_to_code_prompt}.
% The scaffold $c$, as shown in Figure~\ref{fig:scaffold}, includes several key components: a meaningful function name indicating the task's purpose, a parameter list capturing key variables, and a comprehensive docstring documenting the function's purpose, parameter descriptions, and expected return value. 
The scaffold $c$, as shown in Figure~\ref{fig:scaffold}, includes several key components: a descriptive function name that indicates the intended task, a parameter list that specifies required inputs, and a comprehensive docstring that documents the function's purpose, parameter descriptions, and expected return value. 
% Additionally, the function body remains intentionally unimplemented at this stage, serving as a placeholder for subsequent planning and tool execution phases.
The function body is deliberately left empty at this stage, serving as a structured placeholder to be filled during subsequent planning and tool execution phases.

\input{appendix/code_template_example}

By converting natural language queries into structured code scaffolds, \texttt{ToolCoder} clearly understands the requirements, precise input and output specifications, and clear task goals, laying a solid foundation for task decomposition.

\subsubsection{Subtask Planning and Tool Selection}
\label{sec:planning}
% This stage breaks down tasks into modular components and defining the necessary data and operations for execution, mirroring the design phase in software engineering. \texttt{ToolCoder} utilizes the generated Python function scaffold $c$ to decompose high-level tasks into clear, step-by-step subtasks:
This stage focuses on subtask planning and tool selection, decomposing tasks into modular components and determining appropriate tools, following modular design in software engineering. Given candidate toolbox $\mathcal{T}$ and the generated Python scaffold $c$, \texttt{ToolCoder} translates high-level tasks into concrete, actionable subtasks:
\begin{equation}
\textstyle
\setlength\abovedisplayskip{0.2cm}
\setlength\belowdisplayskip{0.2cm}
\begin{aligned}
\boldsymbol{s} = \mathcal{M}_{TP}(c, \mathcal{T}) = \{s_1, s_2, \dots, s_m\},
\end{aligned}
\end{equation} 
% where $\mathcal{T}$ denotes the candidate toolbox. The task planning module $\mathcal{M}_{TP}$ (implemented with the prompt illustrated in Appendix Figure~\ref{fig:subtask_planning_prompt}) analyzes the input function scaffold $c$, utilizing the strong reasoning capabilities of code-empowered model to break down the task into clear, step-by-step subtasks $\boldsymbol{s} = \{s_1, s_2, \dots, s_m\}$, which are then embedded as detailed code comments within the function scaffold $c$, forming a pseudo-code execution plan $c_{\boldsymbol{s}}$ that outlines the necessary steps for achieving the desired outcome.
where $\mathcal{M}_{TP}$ is the subtask planning module  (implemented with the prompt in Appendix Figure~\ref{fig:subtask_planning_prompt}). $\mathcal{M}_{TP}$ analyzes the Python scaffold $c$ and generates concrete subtasks $\boldsymbol{s} = \{s_1, s_2, \dots, s_m\}$. These subtasks are then embedded as structured code comments within scaffold $c$, forming a subtask-based plan $c_{\boldsymbol{s}}$ that outlines all the necessary steps.

% 为何不做工具检索，对于大量的工具如何处理

% The tool selection module $\mathcal{M}_{TS}$ (detailed in Appendix Figure~\ref{fig:tool_selection_prompt}) then analyzes the comments-based plan $c_{\boldsymbol{s}}$ and references the documentation of each tool to understand their input-output specifications. 
% Based on this information, \texttt{ToolCoder} implements placeholders for the necessary tool calls and data flow operations within the main function's body. This ensures that the main function has a clear invocation flow, with placeholders indicating where specific tools will be called and how data will be managed.

The tool selection module $\mathcal{M}_{TS}$ (prompt in Appendix Figure~\ref{fig:tool_selection_prompt}) systematically analyzes the subtask-based plan $c_{\boldsymbol{s}}$ and references the documentation of each tool to understand their input-output specifications.  
Based on the analysis, \texttt{ToolCoder} generates pseudocode $c_{\boldsymbol{p}}$ whose main function body contains proper tool invocation sequences and clear data flow pathways, such as parsing the necessary parameters from the previous API to input the next API call. Each necessary tool call is placed with a sub-function placeholder, whose specific functionality is not implemented.

Through structured planning and tool selection, \texttt{ToolCoder} maximizes the model's reasoning potential by leveraging coding paradigms, ensuring reliable and systematic task completion.


\subsubsection{Implementation and Execution}
\label{sec:main_function}
\paragraph{Implementation}
% In this stage, \texttt{ToolCoder} transforms placeholders for tool calls into concrete sub-functions and assembles a fully executable Python function $F$. This process leverages the API documentation of the selected tools $\mathcal{T}_{\boldsymbol{s}}$ and a repository of previously validated functions $\mathcal{F}$:
% In this stage, \texttt{ToolCoder} implements the specific functionality of sub-function placeholder for each tool call and assembles a fully executable Python program $F$. This process leverages the API documentation of the selected tools $\mathcal{T}_{\boldsymbol{s}}$ and a repository of previously successfully executed functions $\mathcal{F}$:
In this stage, \texttt{ToolCoder} implements the specific functionality of sub-function placeholder, using the API documentation of selected tools $\mathcal{T}_{\boldsymbol{s}}$ and a repository of correctly-executed subfunction $\mathcal{F}$, assembling them into an executable program $F$.
\begin{equation}
\textstyle
\setlength\abovedisplayskip{0.2cm}
\setlength\belowdisplayskip{0.2cm}
\begin{aligned}
F = \mathcal{M}_{CG}(c_{\boldsymbol{p}}, \mathcal{T}_{\boldsymbol{s}}, \mathcal{F}),  
\end{aligned}
\end{equation} 
where $\mathcal{M}_{CG}$ is the code generation module (prompt in Appendix Figure~\ref{fig:main_function_template}), $\mathcal{T}_{\boldsymbol{s}}$ denotes the subset of candidate tools selected based on the pseudocode $c_{\boldsymbol{p}}$, and $\mathcal{F}$ represents the reusable repository of successfully executed functions. 
% \texttt{ToolCoder} processes each subplan $s_i$, implementing it as a sub-function using the relevant tools from $\mathcal{T}_{\boldsymbol{s}}$ based on their documentation and previously successful sub-function snippets in $\mathcal{F}$.
For each subplan $s_i$, \texttt{ToolCoder} implements corresponding sub-functions by leveraging tool documentation from $\mathcal{T}_{\boldsymbol{s}}$ and reusable repository $\mathcal{F}$.
% By carefully managing the data flow between consecutive steps and adhering to the tools' input-output specifications, \texttt{ToolCoder} ensures smooth execution and maintains consistency throughout the implementation process.

\paragraph{Execution}
Once the function $F$ is generated, it is executed within the Python environment $\mathbf{E}$ to produce response $r$ or exceptions $e$:  
\begin{equation}
\textstyle
\setlength\abovedisplayskip{0.2cm}
\setlength\belowdisplayskip{0.2cm}
\begin{aligned}
r, e = \mathbf{E}(F).
\end{aligned}
\end{equation}
% If the error message $e$ is empty, the generated response $r$ will be returned as the final answer to the user’s task $q$. Otherwise, the presence of errors triggers an error reflection process to identify and resolve any issues.
If program $F$ is successfully executed, the generated response $r$ will be returned as the final answer to the user’s task $q$. Otherwise, the error message $e$ triggers an error reflection process to identify and resolve any issues.

\paragraph{Reusable Function Repository}
To facilitate the implementation process, \texttt{ToolCoder} maintains a reusable function repository $\mathcal{F}$, which stores successfully executed sub-function snippets that implement specific API functionalities. During task execution, \texttt{ToolCoder} extracts these successful sub-functions from program $F$ and adds them to repository $\mathcal{F}$, creating a collection of reusable implementations with their execution contexts.

% Whenever the same tools are invoked in future tasks, the framework can reference these stored successful executions to avoid redundant error-prone code generation. This minimizes the likelihood of generating erroneous or inefficient code, as \texttt{ToolCoder} can draw upon proven solutions for the same tool invocations.

% 体现出这里的可复用只复用了各个API调用对应的子函数
% \texttt{ToolCoder} enhances the implementation process by leveraging a reusable function repository $\mathcal{F}$, which stores previously validated code snippets that correspond to successful tool invocations. During task execution, \texttt{ToolCoder} records the successful code fragments generated from the execution of tool invocations $\mathcal{T}_{\boldsymbol{s}} = \{t_{i_1}, t_{i_2}, \dots, t_{i_k}\}$ as part of the task's subtasks. These fragments are added to the repository $\mathcal{F}$, creating a collection of function snippets associated with specific tools and their successful execution contexts.

% By collecting these sub-function snippets, \texttt{ToolCoder} builds a repository of reliable implementations for each tool used. Whenever the same tools are invoked in future tasks, the framework can reference these stored successful executions to avoid redundant error-prone code generation. This minimizes the likelihood of generating erroneous or inefficient code, as \texttt{ToolCoder} can draw upon proven solutions for the same tool invocations.
Through collecting these sub-function snippets, \texttt{ToolCoder} builds a reliable function repository for each tool used. 
% Whenever the same tools are invoked in future tasks, the framework can reference these stored successful executions to eliminate generating erroneous or inefficient code. Furthermore, it also promotes code reuse avoid solving similar problems from scratch, promoting the efficiency of the system.
This enables efficient code reuse in future tasks, preventing potential errors and eliminating redundant development while enhancing system efficiency and reliability.
% This minimizes the likelihood of generating erroneous or inefficient code, as \texttt{ToolCoder} can draw upon proven solutions for the same tool invocations.



\subsubsection{Error Reflection}
\label{sec:reflection}
To mitigate common errors like vague planning, invalid tool selection, and execution failures, \texttt{ToolCoder} leverages explicit exception tracebacks to identify and correct issues, and iteratively refine task plans and enhance the reliability of the system.

\paragraph{Plan Reformulation}  
If the plan $c_{\boldsymbol{s}}$ generated by the task decomposition module $\mathcal{M}_{TD}$ includes invalid or non-existent tools, \texttt{ToolCoder} invokes planning reformulation strategy to refine the plan. Specifically, it detects errors by cross-referencing each tool in the plan against the available tools in $\mathcal{T}$. For every invalid tool, it generates explicit instructions for the LLM, guiding LLM to select an appropriate alternative from $\mathcal{T}$ to fulfill the required functionality. This ensures that the reformulated plan $c_{\boldsymbol{s}^{'}}$ consists entirely of tools that are present in the candidate toolbox.
% \begin{equation}
% \textstyle
% \setlength\abovedisplayskip{0.2cm}
% \setlength\belowdisplayskip{0.2cm}
% \begin{aligned}
% c_{\boldsymbol{s}^{'}} = \mathcal{M}_{PR}(c_{\boldsymbol{s}}, \mathcal{T}).
% \end{aligned}
% \end{equation}

\paragraph{Code Review}
If the initial function $F$ fails, producing an error $e$, \texttt{ToolCoder} employs  code review to analyze the error, identify its cause, and generate corrections. Python's clear and detailed exception tracebacks allow precise pinpointing of the error location and facilitate understanding of the underlying issue. The function $F$ is revised based on the current error $e$ and then re-executed using $\mathbf{E}$, yielding a new result $r$ and an updated error state $e$. This process is performed iteratively, typically up to three times, until execution succeeds (i.e., $e = \emptyset$) or the maximum number of attempts is reached.