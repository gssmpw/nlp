\section{Introduction}
As large language models (LLMs) continue to advance, tool learning has emerged as a critical capability, enabling LLMs to solve complex real-world tasks through dynamic interaction with external tools and APIs~\cite{DBLP:journals/corr/abs-2405-17935}. This capability extends LLMs' problem-solving abilities and allows them to adapt to dynamic environments and specialized domains~\cite{DBLP:conf/iclr/00020LCYPJ24}.

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{fig/motiv.pdf}
    \caption{Illustration of key limitations in existing approaches: weak planning strategies, insufficient error handling, and lack of experience reuse.}
    \label{fig:intro}
    \vspace{-0.6cm}
\end{figure}


Current approaches for tool learning predominantly follow a sequential \textit{plan-execute-observe} paradigm~\cite{DBLP:conf/iclr/YaoZYDSN023,DBLP:journals/corr/abs-2303-09014,DBLP:conf/nips/LuPCGCWZG23}, where LLMs iteratively plan actions, execute tools, and observe outcomes. 
% While frameworks like ReAct~\cite{DBLP:conf/iclr/YaoZYDSN023} and Chameleon~\cite{DBLP:conf/nips/LuPCGCWZG23} have demonstrated promising results, they suffer from several limitations. 
% However, as shown in Figure~\ref{fig:intro}, these methods rely heavily on hand-crafted prompts and natural language reasoning, making multi-step planning difficult and often leading to unreliable performance in complex tasks~\cite{DBLP:journals/corr/abs-2407-03007,DBLP:conf/icml/WangCY0L0J24}.
While frameworks like ReAct~\cite{DBLP:conf/iclr/YaoZYDSN023} and Chameleon~\cite{DBLP:conf/nips/LuPCGCWZG23} have demonstrated success in simple task handling, they suffer from several limitations. 
As shown in Figure~\ref{fig:intro}, these methods rely heavily on hand-crafted prompts and natural language reasoning, making multi-step planning difficult and often leading to unreliable performance in complex tasks~\cite{DBLP:journals/corr/abs-2407-03007,DBLP:conf/icml/WangCY0L0J24}.
Moreover, they lack precise error diagnosis and reflection mechanisms—when execution fails, they are unable to identify the actual causes of errors or propose targeted corrective actions~\cite{DBLP:conf/icml/WangCY0L0J24,wang-etal-2024-llms-imaginarium}. 
% Furthermore, current frameworks do not accumulate successful execution experiences, treating each query as independent and failing to leverage past solutions for efficiency gains~\cite{DBLP:conf/iclr/YuanC000J24}. 
Furthermore, current frameworks are unable to accumulate and reuse successful experiences from past executions, treating each query in isolation and repeatedly solving similar problems from scratch~\cite{DBLP:conf/iclr/YuanC000J24}.
These limitations hinder the robustness, adaptability, and scalability of tool-learning systems.

In this paper, we propose \texttt{ToolCoder}, a novel code-empowered framework that re-formulates tool learning as a code generation task. 
Inspired by software engineering principles, \texttt{ToolCoder} systematically addresses these challenges in tool learning through these key stages: 
% First, \texttt{ToolCoder} converts natural language queries into scaffolded Python functions with clearly defined input-output specifications, analogous to requirement analysis in software engineering.
% First, \texttt{ToolCoder} converts natural language queries into scaffolded Python functions with clear input-output specifications, analogous to requirement analysis in software engineering, enabling clearly defined input-output specifications.
First, \texttt{ToolCoder} converts vague natural language queries into structured Python function scaffold, analogous to the requirement analysis in software engineering, enabling clearly defined input-output specifications. 
Then, following modular design principles, \texttt{ToolCoder} systematically breaks down scaffold into subtasks with descriptive comments, enabling LLMs to leverage coding paradigms for complex reasoning and planning.
% decomposes the task into subtasks with embedded comments, stimulating LLMs' reasoning capabilities through programming paradigms.
% In the implementation phase, \texttt{ToolCoder} generates code for individual functions and the main program, and executes main program to obtain the final response. Successful code snippets are stored in a reusable function repository to accumulate successful implementations, promoting code reuse and execution efficiency across tasks.
% For error handling, \texttt{ToolCoder} leverages Python's error traceback mechanism for debugging, significantly improving the reliability of tool learning system.
% In the implementation phase, \texttt{ToolCoder} generates well-structured runnable code for both sub-function and main functions, then executes them to obtain final responses. Successfully executed code snippets are stored in a function repository to accumulate proven implementations, enabling efficient code reuse in future tasks.
In the implementation phase, \texttt{ToolCoder} generates well-structured runnable code for both sub-function and main functions, then executes them to obtain final responses. Successfully executed code snippets are stored in a function repository to accumulate proven implementations, helping solving similar problems.
For failed executions, \texttt{ToolCoder} leverages explicit Python's error traceback mechanism for accurate error diagnosis, significantly improving the reliability of tool learning system.



 % Finally, \texttt{ToolCoder} handles execution by generating individual functions and main programs, while incorporating systematic error handling through Python's traceback analysis for runtime exception resolution. To promote code reusability, \texttt{ToolCoder} maintains a repository of validated function implementations for efficient solution development.


% In this paper, we propose \texttt{ToolCoder}, \emph{a novel code-empowered framework that re-formulates tool learning as a code generation task}.
% Software engineering principles offer valuable insights to address the above limitations. Just as software development relies on modular design, systematic error handling, and code reusability, tool learning systems can benefit from adopting similar principles.
% Following established software engineering practices. This reformulation enables us to \emph{apply fundamental software engineering principles throughout the tool learning process: from initial requirement analysis and task decomposition, through modular implementation, to systematic error handling and code reuse}.
% Inspired by software engineer principles, we systematically design the code-empowered \texttt{ToolCoder} framework.
% \texttt{ToolCoder} first converts natural language queries into scaffolded Python functions with clearly defined input-output specifications through task-to-code transformation, similar to requirement analysis in software engineering.
% Following modular design principles, \texttt{ToolCoder} decomposes the task into smaller subtasks and plans their implementation through structured comments, while identifying appropriate APIs for each modular component.
% In the implementation phase, \texttt{ToolCoder} generates both the individual functions and main program, transforming each planned subtask into executable code.
% For error handling and debugging, \texttt{ToolCoder} analyzes Python's error traceback to identify issues, automatically re-planning and regenerating code to resolve runtime exceptions.

% Our \texttt{ToolCoder} then generates executable functions by integrating the subtasks as during the implementation phase.
% Finally, it leverages Python's error traceback for targeted debugging and optimization, re-planning and re-generating code  when errors occur.
% Successful code snippets are stored in a reusable function repository, enabling efficient reuse to improve future task execution and reduce redundancy.



% First, by transforming task planning into code-based decomposition and leveraging the reasoning capabilities of code-empowered LLMs, our approach enables more systematic and precise task breakdowns compared to traditional natural language-based methods. Second, the use of Python’s explicit error traceback mechanism facilitates clear and targeted error diagnosis, improving system reliability and reducing error rates. Finally, the framework supports knowledge accumulation through the reusable function repository, which stores successful code snippets from past tool invocations, allowing for efficient reuse in future tasks and enhancing execution reliability.
% \textbf{1)} We transform planning into code-based decomposition to stimulate the reasoning capabilities of LLMs, enabling \texttt{ToolCoder} to perform more systematic and precise task decomposition compared to traditional natural language-based methods.
% \texttt{ToolCoder} offers several key advantages. 
% \textbf{1)} By transforming task planning into code-based decomposition, \texttt{ToolCoder} stimulates the reasoning capabilities of LLMs through programming paradigms, enabling more systematic and precise task execution compared to traditional natural language-based methods.
% \textbf{2)} \texttt{ToolCoder} adopts Python’s explicit error traceback mechanism to facilitate clear and targeted error diagnosis, improving system reliability and reducing error rates.
% \textbf{3)} \texttt{ToolCoder} supports knowledge accumulation through the reusable function repository, which stores successful code snippets from past tool invocations, allowing for efficient reuse in future tasks and enhancing execution reliability.

% To evaluate \texttt{ToolCoder}'s effectiveness, we conduct comprehensive experiments on multiple benchmark datasets~\cite{DBLP:journals/corr/abs-2306-06624,li-etal-2023-api}, comparing its performance against state-of-the-art baseline methods. The experimental results demonstrate that \texttt{ToolCoder} significantly outperforms existing approaches in both Success Rate and Correct Path Rate, particularly in complex scenarios requiring multi-step tool interactions. These results validate the effectiveness of our code-empowered approach and its potential for advancing LLM-based tool learning systems.
To evaluate \texttt{ToolCoder}'s effectiveness, we conduct comprehensive experiments on multiple benchmark datasets~\cite{DBLP:journals/corr/abs-2306-06624,li-etal-2023-api}. Our experimental results demonstrate that \texttt{ToolCoder} significantly outperforms SOTA approaches in all metrics. We also validate the necessity of each proposed component. Furthermore, we observe that \texttt{ToolCoder} brings more substantial improvements in code LLMs compared to base LLMs. These findings confirm the superiority of systematic code-centric framework and its potential for advancing tool learning systems.


The main contributions of this work are:
\begin{itemize}[leftmargin=0.6cm, itemindent=0cm, itemsep=0pt]
    % \item[$\bullet$] Propose a novel framework that transforms tool learning into a code generation task, can make use of advantages of programming.
    % \item[$\bullet$] Design a comprehensive system architecture \texttt{ToolCoder} incorporating query-to-code transformation, systematic task decomposition, and iterative refinement with error diagnosis.
    % \item[$\bullet$] Through extensive experiments on benchmark datasets, \texttt{ToolCoder} significantly improves the success rate and reliability of tool learning.
    \item[$\bullet$] We propose \texttt{ToolCoder} framework that re-formulates tool learning as a code generation task, leveraging both software engineering principles and LLMs' code generation capabilities.
    % \item[$\bullet$] We design a comprehensive system architecture, incorporating query-to-code transformation, systematic task decomposition, and iterative refinement with error diagnosis.
    \item[$\bullet$] We design a systematic architecture that converts natural language task into modular code components, implements and executes them to generate final response. We also incorporate error diagnosis and code reuse mechanisms for efficiency and reliability.
    \item[$\bullet$] Extensive experiments on benchmarks demonstrate \texttt{ToolCoder} significantly improve the success rate and reliability of tool learning.
\end{itemize}