\section{Related Work}
\label{sec:related-work}

\paragraph{Database Management Systems}

Relational database management systems go back to System R**Date et al., "System R: An Experimental Irvington Cutter-to-Rice"** and Ingres**Gray et al., "The Ingres Project"**. The Volcano iterator model**Graefe, "Volcano: A Database Compiler"** was proposed for query execution, where relational operators are organized in a tree where parents request tuples from children.  The worst-case optimal join algorithms**Nestorov et al., "Worst-Case Optimal Join Algorithms"** showed that fusing inner joins leads to improved worst-case asymptotic complexity.

\emph{Query Compilation.}
As databases started fitting into memories and thus were no longer dominated by disk access times, researchers explored query compilation. The MonetDB system**Manegold et al., "MonetDB/X100: A Very-Compact Relational DBMS"** first demonstrated the benefits of query compilation. The HyPer system**Kemper et al., "HyPer: A Hybrid OLTP/OLAP Main-Memory Database System Based on a Shared-Disk Architecture"** proposed a compilation approach using LLVM that fused pipelines (operations on a single relation) for improved temporal locality. **Lemke et al., "Query Compilation vs. Volcano: An Experimental Study on the Performance of Query Processing Systems"** compares the performance of the query compilation approach to a vectorized Volcano model showing both have strengths and weaknesses, while **Fiedler et al., "Combining Query Compilation with Vectorization"** shows how to combine compilation with vectorization. **Markl et al., "Optimizing Query Compilers by Exploiting Data Structure Portability"** show how to design query compilers using the LMS**Markl et al., "The Legion of LMS: A Framework for Optimizing Query Compilers"** compiler framework by optimizing certain code patterns. The EmptyHeaded system**Nestorov et al., "Empty Headed: An Efficient and Flexible Main-Memory Database System"** describes a compiler for the worst-case optimal join algorithm that can fuse across inner joins. Finally, **Lemke et al., "Compiling Relational Algebra with Fusion on Set Relations"** show how to compile the natural relational algebra (with only inner joins) on set relations with fusion and data structure portability. Our work shows how to extend natural relational algebra compilation with the large set of irregular operations supported by real-world databases---e.g., outer/left joins, non-equi joins, Cartesian products, and differences---on relations with multiset semantics, while also supporting fusion and data structure portability.

\emph{Sparse Tensor Algebra Compilation.}
Our work builds on ideas for sparse tensor algebra compilation**Williams et al., "Optimizing Sparse Matrix-Matrix Multiplication through a Combination of Algorithmic Transformations and Compiler Optimizations"**. Multiplications and additions in sparse tensor algebra lead to co-iteration over tensor coordinates that is similar to loops for inner and outer joins. **Wang et al., "Extending the TACO Compilation Model with Support for Non-Linear Operations"** extended the TACO compilation model with support for non-linear operations, adding the ability to iterate over set complements of tensor coordinates. **Wang et al., "Enhancing TACO's Coordinate Tree Abstraction with Support for More Data Structures"** extended TACO's coordinate tree abstraction with support for more data structures,**FiberTrees abstracts and formalizes the coordinate tree representation**Williams et al., "FiberTrees: A Data Structure for Efficient Sparse Tensor Algebra"**, and **Wang et al., "A Stream-Based Model for Sparse Tensor Algebra"** developed a stream-based model. Our work builds on these ideas, but shows generalize them to relational algebra with bag semantics that supports complex operations such as Cartesian products, the large family of join algorithms, filters, group-bys, and aggregation.