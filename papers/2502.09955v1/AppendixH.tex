\UseRawInputEncoding

\section{Combinatorics Game Code}
\label{appendix:H}

\paragraph{Program synthesis and simulation.}
Given the problem in English and game representation, an LLM writes Python code that implements the state, observation, transition, and reward functions $\mathcal{S}, \Omega, \mathcal{O}, T, R$, and simulates game-play trajectories $\tau \;=\; \bigl(s_0, o_0, a_0, r_0, s_1, o_1, a_1, r_1,\ldots\bigr)$, where $s_t \sim T(s_{t-1}, a_{t-1})$ and $o_t = \mathcal{O}(s_t)$. We run a set of simulations $\{\tau_i\}_{i=1}^m$ on small instances to collect data which is used as additional information to find an answer and identify strategies for a proof.


\subsection*{2024 IMO}
\label{appendix:H_2024_IMO}


\subsubsection*{Problem 3}

\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={2024 IMO problem 3 game code.},
label={listing:IMO2024P3}
]
import gymnasium as gym
from gymnasium import spaces
import pygame
import numpy as np
from collections import deque


class IMOSequenceEnv(gym.Env):
    metadata = {"render_modes": ["human"], "render_fps": 4}

    def __init__(self, render_mode=None):
        super().__init__()
        self.render_mode = render_mode
        self.sequence = deque(maxlen=None)
        self.observation_space = spaces.Dict({
            'sequence': spaces.Sequence(spaces.Box(low=1, high=MAX_INT, shape=(), dtype=np.int32)),
            'position': spaces.Discrete(MAX_INT)
        })
        self.action_space = spaces.Discrete(6)
        self.window = None
        self.clock = None
        self.font = None
        self.small_font = None
        self.step_next = False
        self.reset_requested = False
        self.multi_step = False
        self.scroll_offset = 0
        self.odd_period = None
        self.even_period = None
        self.odd_start = None
        self.even_start = None

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.sequence.clear()
        self.sequence.append(self.np_random.integers(1, 4))
        self.position = 1
        self.scroll_offset = 0
        self.odd_period = None
        self.even_period = None
        self.odd_start = None
        self.even_start = None

        observation = {'sequence': list(self.sequence), 'position': self.position}
        if self.render_mode == "human":
            self.render()
        return observation, {}

    def step(self, action):
        if self.position >= 2:
            prev_element = self.sequence[self.position - 1]
            count = sum(1 for x in list(self.sequence)[:self.position] if x == prev_element)
            self.sequence.append(count)
        else:
            self.sequence.append(action)

        self.position += 1
        if self.position > MAX_VISIBLE_ELEMENTS + self.scroll_offset:
            self.scroll_offset = self.position - MAX_VISIBLE_ELEMENTS

        self._detect_periodicity()
        reward = self._calculate_reward()

        observation = {'sequence': list(self.sequence), 'position': self.position}
        if self.render_mode == "human":
            self.render()
        return observation, reward, False, False, {}

    def _detect_periodicity(self):
        def find_repeating_pattern(seq):
            if len(seq) < 10:
                return None, None

            for period in range(2, len(seq) // 3):
                for start in range(len(seq) - 3 * period):
                    pattern = seq[start:start + period]
                    repetitions = 0
                    pos = start
                    while pos + period <= len(seq):
                        if seq[pos:pos + period] == pattern:
                            repetitions += 1
                            pos += period
                        else:
                            break
                    if repetitions >= 3:
                        return period, start
            return None, None

        odd_seq = list(self.sequence)[1::2]
        even_seq = list(self.sequence)[::2]

        if self.odd_period is None:
            self.odd_period, self.odd_start = find_repeating_pattern(odd_seq)

        if self.even_period is None:
            self.even_period, self.even_start = find_repeating_pattern(even_seq)

    def _calculate_reward(self):
        return 10 if (self.odd_period is not None or self.even_period is not None) else 0

    def render(self):
        if self.window is None:
            pygame.init()
            self.window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
            pygame.display.set_caption("IMO Sequence Visualization")
            self.clock = pygame.time.Clock()
            self.font = pygame.font.SysFont('Arial', 24)
            self.small_font = pygame.font.SysFont('Arial', 16)

        self.window.fill(BACKGROUND_COLOR)

        # Define layout sections
        histogram_height = int(WINDOW_HEIGHT * 0.6)
        sequences_height = int(WINDOW_HEIGHT * 0.25)
        hist_x = 100
        hist_y = 50

        # Create frequency count dictionary and track positions
        values = list(self.sequence)
        if values:
            value_counts = {}
            positions = {}
            max_val = max(values)

            # First pass: count frequencies and store positions
            for idx, val in enumerate(values):
                if val not in value_counts:
                    value_counts[val] = []
                    positions[val] = []
                value_counts[val].append(len(value_counts[val]))
                positions[val].append(idx)

            # Draw vertical stacks
            cell_size = 50
            spacing = 70
            connections = []

            # First draw all connections (behind the cells)
            for val in range(1, max_val + 1):
                if val in value_counts:
                    counts = value_counts[val]
                    x = hist_x + (val - 1) * spacing

                    for i, count in enumerate(counts):
                        y = histogram_height - (i + 1) * cell_size
                        sequence_pos = positions[val][i]

                        if sequence_pos < len(values) - 1:
                            next_val = values[sequence_pos + 1]
                            next_count = value_counts[next_val].index(len(value_counts[next_val]) - 1)
                            start_pos = (x + cell_size // 2, y + cell_size // 2)
                            end_pos = (hist_x + (next_val - 1) * spacing + cell_size // 2,
                                       histogram_height - (next_count + 1) * cell_size + cell_size // 2)
                            # Draw connection line immediately
                            pygame.draw.line(self.window, CONNECTION_COLOR, start_pos, end_pos, 3)

            # Then draw the cells (on top of the lines)
            for val in range(1, max_val + 1):
                if val in value_counts:
                    counts = value_counts[val]
                    x = hist_x + (val - 1) * spacing

                    for i, count in enumerate(counts):
                        y = histogram_height - (i + 1) * cell_size
                        sequence_pos = positions[val][i]

                        # Draw cell with orange background
                        rect = pygame.Rect(x, y, cell_size, cell_size)
                        pygame.draw.rect(self.window, CELL_BG_COLOR, rect)
                        pygame.draw.rect(self.window, AXIS_COLOR, rect, 1)

                        # Draw index number
                        text = self.small_font.render(str(sequence_pos), True, TEXT_COLOR)
                        text_rect = text.get_rect(center=(x + cell_size // 2, y + cell_size // 2))
                        self.window.blit(text, text_rect)

            # Draw x-axis
            pygame.draw.line(self.window, AXIS_COLOR,
                             (hist_x - 20, histogram_height),
                             (hist_x + (max_val + 1) * spacing, histogram_height), 2)

            # Draw x-axis labels
            for val in range(1, max_val + 1):
                x = hist_x + (val - 1) * spacing + cell_size // 2
                text = self.font.render(str(val), True, TEXT_COLOR)
                text_rect = text.get_rect(center=(x, histogram_height + 25))
                self.window.blit(text, text_rect)

        # Draw sequence section
        seq_start_y = histogram_height + 60
        header_x = 50

        # Draw current sequence
        for i in range(self.scroll_offset, min(self.position, self.scroll_offset + MAX_VISIBLE_ELEMENTS)):
            x = header_x + (i - self.scroll_offset) * (CELL_SIZE + CELL_PADDING)
            y = seq_start_y + 30

            # Draw cell with orange background
            pygame.draw.rect(self.window, CELL_BG_COLOR, (x, y, CELL_SIZE, CELL_SIZE))
            pygame.draw.rect(self.window, AXIS_COLOR, (x, y, CELL_SIZE, CELL_SIZE), 1)

            # Draw value
            value_surface = self.small_font.render(str(self.sequence[i]), True, TEXT_COLOR)
            value_rect = value_surface.get_rect(center=(x + CELL_SIZE // 2, y + CELL_SIZE // 2))
            self.window.blit(value_surface, value_rect)

            # Draw index
            index_surface = self.small_font.render(str(i), True, TEXT_COLOR)
            index_rect = index_surface.get_rect(center=(x + CELL_SIZE // 2, y - 15))
            self.window.blit(index_surface, index_rect)

        # Draw buttons
        button_width = 150
        button_height = 40
        button_padding = 20
        buttons_y = WINDOW_HEIGHT - 60

        start_x_buttons = (WINDOW_WIDTH - (3 * button_width + 2 * button_padding)) // 2

        buttons = [
            ("Step", (start_x_buttons, buttons_y, button_width, button_height), (0, 180, 0)),
            ("+10", (start_x_buttons + button_width + button_padding, buttons_y, button_width, button_height),
             (0, 140, 0)),
            ("Reset", (start_x_buttons + 2 * (button_width + button_padding), buttons_y, button_width, button_height),
             (180, 0, 0))
        ]

        for text, (x, y, w, h), color in buttons:
            button_rect = pygame.Rect(x, y, w, h)
            pygame.draw.rect(self.window, color, button_rect)
            pygame.draw.rect(self.window, AXIS_COLOR, button_rect, 1)
            text_surface = self.font.render(text, True, (255, 255, 255))
            self.window.blit(text_surface, text_surface.get_rect(center=button_rect.center))

        # Handle events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                quit()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = event.pos
                for text, (bx, by, bw, bh), _ in buttons:
                    if bx <= x <= bx + bw and by <= y <= by + bh:
                        if text == "Step":
                            self.step_next = True
                        elif text == "+10":
                            self.multi_step = True
                        elif text == "Reset":
                            self.reset_requested = True
                        break

        pygame.display.flip()
        self.clock.tick(self.metadata["render_fps"])

    def close(self):
        if self.window is not None:
            pygame.quit()
            self.window = None


\end{lstlisting}

\newpage
\clearpage

\subsubsection*{Problem 5}

\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={2024 IMO problem 5 game code.},
label={listing:IMO2024P5}
]
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import pygame
import time


class TurboSnailEnv(gym.Env):
    metadata = {'render_modes': ['human'], 'render_fps': 4}

    def __init__(self, grid_size=(8, 7), render_mode=None):
        super().__init__()
        self.grid_rows, self.grid_cols = grid_size
        self.render_mode = render_mode
        self.action_space = spaces.Discrete(3)
        self.observation_space = spaces.Box(
            low=-1.0,
            high=1.0,
            shape=(2 + self.grid_rows * self.grid_cols,),
            dtype=np.float32
        )

        self.max_attempts = 3
        self.attempts = 0
        self._monster_positions = None
        self._agent_position = None
        self._grid_knowledge = None
        self._current_attempt_over = False

        self.window_size = 800
        if self.render_mode == 'human':
            pygame.init()
            self.screen = pygame.display.set_mode((self.window_size - 88, self.window_size))
            pygame.display.set_caption("Turbo the Snail")
            self.clock = pygame.time.Clock()
        else:
            self.screen = None
            self.clock = None

        self.reset()

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.attempts = 0
        monster_rows = list(range(1, self.grid_rows - 1))
        monster_cols = self.np_random.permutation(self.grid_cols)[:len(monster_rows)]

        self._monster_positions = set(zip(monster_rows, monster_cols))
        self._grid_knowledge = np.zeros((self.grid_rows, self.grid_cols), dtype=np.int8)
        self._agent_position = (0, self.np_random.integers(0, self.grid_cols))
        self._current_attempt_over = False

        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == 'human':
            self.render()

        return observation, info

    def step(self, action):
        row, col = self._agent_position
        penalty = 0.0  # Initialize penalty
        if action == 0:  # Down
            row = min(self.grid_rows - 1, row + 1)
        elif action == 1:  # Left
            col = max(0, col - 1)
        elif action == 2:  # Right
            col = min(self.grid_cols - 1, col + 1)
        elif action == 3:  # Up
            row = max(0, row - 1)
            penalty = 0.1
        else:
            raise ValueError("Invalid action")

        self._agent_position = (row, col)

        terminated = False
        reward = -0.01 - penalty  # Small negative reward per step plus penalty if moved up

        # Check if agent encounters a monster
        if self._agent_position in self._monster_positions:
            self._grid_knowledge[row, col] = -1  # Mark as monster
            self.attempts += 1  # Increment attempts
            if self.attempts >= self.max_attempts:
                terminated = True
                reward = -1.0  # Large negative reward for failing
            else:
                self._agent_position = (0, self.np_random.integers(0, self.grid_cols))  # Transport back to first row
                reward -= 0.1  # Additional negative reward for hitting a monster
        else:
            self._grid_knowledge[row, col] = 1  # Mark as safe
            if row == self.grid_rows - 1:
                # Agent has reached the bottom row
                reward = 1.0 - 0.1 * self.attempts  # Positive reward, less per attempt
                terminated = True

        observation = self._get_obs()
        info = self._get_info()

        if self.render_mode == 'human':
            self.render()

        return observation, reward, terminated, False, info

    def _get_obs(self):
        agent_row, agent_col = self._agent_position
        # Normalize agent position to [0,1]
        agent_pos = np.array([agent_row / (self.grid_rows - 1), agent_col / (self.grid_cols - 1)], dtype=np.float32)
        # Flatten grid knowledge
        grid_knowledge_flat = self._grid_knowledge.flatten().astype(np.float32)
        return np.concatenate([agent_pos, grid_knowledge_flat])

    def _get_info(self):
        return {
            'attempts': self.attempts
        }

    def render(self):
        if self.screen is None:
            return

        cell_size = self.window_size // max(self.grid_rows, self.grid_cols)
        self.screen.fill((30, 30, 30)) 

        # Draw grid lines
        for x in range(self.grid_cols + 1):
            pygame.draw.line(self.screen, (200, 200, 200), (x * cell_size, 0),
                             (x * cell_size, self.grid_rows * cell_size))
        for y in range(self.grid_rows + 1):
            pygame.draw.line(self.screen, (200, 200, 200), (0, y * cell_size),
                             (self.grid_cols * cell_size, y * cell_size))

        # Draw known cells
        for r in range(self.grid_rows):
            for c in range(self.grid_cols):
                rect = pygame.Rect(c * cell_size, r * cell_size, cell_size, cell_size)
                if r == 0 or r == self.grid_rows - 1:
                    pygame.draw.rect(self.screen, (60, 60, 60), rect)  # Dark grey for the first row
                elif self._grid_knowledge[r, c] == 1:
                    pygame.draw.rect(self.screen, (100, 200, 100), rect)  # Green for safe cells
                elif self._grid_knowledge[r, c] == -1:
                    pygame.draw.rect(self.screen, (200, 100, 100), rect)  # Red for monster cells

        # Draw labels for the starting and goal rows
        font = pygame.font.Font(None, 36)
        starting_label = font.render("Starting row", True, (255, 255, 255))
        goal_label = font.render("Goal row", True, (255, 255, 255))
        self.screen.blit(starting_label, ((self.window_size - 250)/2, 50))
        self.screen.blit(goal_label, ((self.window_size - 220)/2, (self.grid_rows - 1) * cell_size + 50))

        # Draw agent
        agent_rect = pygame.Rect(
            self._agent_position[1] * cell_size,
            self._agent_position[0] * cell_size,
            cell_size,
            cell_size
        )
        pygame.draw.rect(self.screen, (100, 100, 250), agent_rect)  # Blue for agent

        # Update the display
        pygame.display.flip()
        self.clock.tick(self.metadata['render_fps'])

    def close(self):
        if self.screen is not None:
            pygame.quit()
            self.screen = None
\end{lstlisting}


\newpage

\subsection*{2024 USAMO}
\label{appendix:H_2024_USAMO}

\subsubsection*{Problem 2}

\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={USAMO 2024 problem 2 game code.},
label={listing:USAMO2024C2}
]
import gymnasium as gym
import numpy as np
from gymnasium import spaces
from typing import Optional, Tuple, Dict, Any
import pygame
import math

class SetsEnvironment(gym.Env):
    """
    A Gymnasium environment for the sets intersection problem with Pygame visualization.
    The threshold for counting elements is dynamically set to half of the total sets.
    """
    
    def __init__(self, num_sets: int = 100, max_elements: int = 1000, render_mode: str = "pygame"):
        super().__init__()
        
        self.num_sets = num_sets
        self.max_elements = max_elements
        self.render_mode = render_mode
        self.threshold = num_sets // 2  # New threshold based on half the number of sets
        
        # Action space: (set_idx, element_idx, action_type)
        # action_type: 0 = remove, 1 = add
        self.action_space = spaces.MultiDiscrete([
            num_sets,           # Which set to modify
            max_elements,       # Which element to add/remove
            2                   # Add or remove action
        ])
        
        # Observation space: binary matrix of shape (max_elements, num_sets)
        self.observation_space = spaces.Box(
            low=0,
            high=1,
            shape=(max_elements, num_sets),
            dtype=np.int8
        )
        
        self.state = None
        self.steps = 0
        self.max_steps = 10000
        self.best_valid_score = float('inf')  # Track best valid solution
        
        # Pygame visualization setup
        if self.render_mode == "pygame":
            pygame.init()
            self.window_size = (1200, 800)
            self.screen = pygame.display.set_mode(self.window_size)
            pygame.display.set_caption(f"Sets Intersection Visualization (Threshold: {self.threshold} sets)")
            self.clock = pygame.time.Clock()
            self.font = pygame.font.Font(None, 24)
            
            # Colors
            self.colors = [
                (255, 0, 0), (0, 255, 0), (0, 0, 255),
                (255, 255, 0), (255, 0, 255), (0, 255, 255),
                (128, 0, 0), (0, 128, 0), (0, 0, 128),
                (128, 128, 0)
            ] * 10  # Repeat colors for more sets
    
    def reset(self, seed: Optional[int] = None, options: Optional[Dict] = None) -> Tuple[np.ndarray, Dict[str, Any]]:
        super().reset(seed=seed)
        
        # Initialize with one element in all sets to ensure non-empty intersection
        self.state = np.zeros((self.max_elements, self.num_sets), dtype=np.int8)
        self.state[0] = 1  # First element belongs to all sets
        
        self.steps = 0
        self.best_valid_score = float('inf')
        
        if self.render_mode == "pygame":
            self._render_frame()
        
        return self.state, {}
    
    def _check_constraints(self) -> bool:
        """Check if current state satisfies all constraints."""
        # Get all possible subsets of sets (using binary representation)
        for subset_mask in range(1, 2**self.num_sets):
            # Convert to binary array
            subset = np.array([int(x) for x in format(subset_mask, f'0{self.num_sets}b')])
            num_sets_in_subset = np.sum(subset)
            
            # Get elements in intersection of these sets
            intersection_size = np.sum(np.all(self.state[:, subset == 1] == 1, axis=1))
            
            # Check if intersection size is multiple of number of sets
            if intersection_size % num_sets_in_subset != 0:
                return False
            
            # Check if intersection is non-empty when all sets are selected
            if subset_mask == 2**self.num_sets - 1 and intersection_size == 0:
                return False
                
        return True
    
    def _get_reward(self) -> float:
        """Calculate reward based on number of elements in threshold or more sets."""
        elements_above_threshold = np.sum(np.sum(self.state, axis=1) >= self.threshold)
        return -elements_above_threshold  # Negative because we want to minimize
    
    def step(self, action: np.ndarray) -> Tuple[np.ndarray, float, bool, bool, Dict[str, Any]]:
        self.steps += 1
        
        set_idx, element_idx, action_type = action
        
        # Apply action directly without reverting
        self.state[element_idx, set_idx] = action_type
        
        # Calculate reward
        reward = self._get_reward()
        
        # Check if current state is valid
        is_valid = self._check_constraints()
        
        if is_valid:
            # Update best valid score if current solution is better
            current_score = -reward  # Convert negative reward to positive score
            if current_score < self.best_valid_score:
                self.best_valid_score = current_score
                reward += 1000  # Bonus for finding better solution
        else:
            reward -= 10  # Small penalty for invalid states to encourage finding valid ones
        
        # Terminate if we find a valid solution
        # Note: You might want to continue searching for better solutions
        terminated = (is_valid and self.steps >= 1000) or self.steps >= self.max_steps
        truncated = False
        
        if self.render_mode == "pygame":
            self._render_frame()
        
        info = {
            'is_valid': is_valid,
            'best_valid_score': self.best_valid_score if self.best_valid_score != float('inf') else None
        }
        
        return self.state, reward, terminated, truncated, info
    
    def _render_frame(self):
        """Render the current state using Pygame."""
        if self.render_mode != "pygame":
            return
            
        self.screen.fill((255, 255, 255))  # White background
        
        # Calculate visualization parameters
        active_elements = np.sum(self.state, axis=1) > 0
        num_active_elements = np.sum(active_elements)
        elements_above_threshold = np.sum(np.sum(self.state, axis=1) >= self.threshold)
        is_valid = self._check_constraints()
        
        # Draw sets as circles
        center_x = self.window_size[0] // 2
        center_y = self.window_size[1] // 2
        max_radius = min(self.window_size[0], self.window_size[1]) * 0.4
        
        visible_sets = min(10, self.num_sets)

        # Draw elements in a grid layout
        element_radius = 3
        grid_spacing = 10
        elements_per_row = 20
        margin_left = 500
        margin_top = 300
        
        # Draw active elements
        for elem_idx in range(self.max_elements):
            if np.sum(self.state[elem_idx]) > 0:  # If element is in any set
                sets_containing = np.where(self.state[elem_idx] == 1)[0]
                
                # Calculate grid position
                row = (elem_idx // elements_per_row)
                col = elem_idx % elements_per_row
                x = margin_left + col * grid_spacing
                y = margin_top + row * grid_spacing
                
                # Color based on threshold
                if len(sets_containing) >= self.threshold:
                    color = (255, 0, 0)  # Red for elements above threshold
                else:
                    color = (0, 0, 0)    # Black for other elements
                
                # Draw lines to sets (only for first few elements to avoid clutter)
                if elem_idx < 20:  # Limit connections to first 20 elements
                    for set_idx in sets_containing[:visible_sets]:
                        angle = 2 * math.pi * set_idx / visible_sets
                        set_x = center_x + max_radius * math.cos(angle)
                        set_y = center_y + max_radius * math.sin(angle)
                        pygame.draw.line(self.screen, (200, 200, 200), (x, y), (int(set_x), int(set_y)), 3)

                # Draw element
                pygame.draw.circle(self.screen, color, (x, y), element_radius)    
        
        # Draw sets (first 10 sets for visibility)
        for i in range(visible_sets):
            angle = 2 * math.pi * i / visible_sets
            x = center_x + max_radius * math.cos(angle)
            y = center_y + max_radius * math.sin(angle)
            
            # Draw set circle
            pygame.draw.circle(self.screen, self.colors[i], (int(x), int(y)), 50, 5)
            
            # Draw set label
            text = self.font.render(f"Set {i+1}", True, self.colors[i])
            self.screen.blit(text, (int(x) - 20, int(y) - 30))


        # Draw statistics
        stats = [
            f"Step: {self.steps}/{self.max_steps}",
            f"Active Elements: {num_active_elements}",
            f"Elements in {self.threshold}+ sets: {elements_above_threshold}",
            f"Valid Solution: {'Yes' if is_valid else 'No'}",
            f"Best Valid Score: {self.best_valid_score if self.best_valid_score != float('inf') else 'None'}",
        ]
        
        for i, text in enumerate(stats):
            surface = self.font.render(text, True, (0, 0, 0))
            self.screen.blit(surface, (10, 10 + i * 30))
        
        pygame.display.flip()
        self.clock.tick(30)
    
    def render(self):
        """Render the environment."""
        if self.render_mode == "pygame":
            self._render_frame()
        else:
            # Print text-based statistics
            elements_in_sets = np.sum(self.state, axis=1)
            elements_above_threshold = np.sum(elements_in_sets >= self.threshold)
            print(f"Elements in {self.threshold}+ sets: {elements_above_threshold}")
            print(f"Step: {self.steps}/{self.max_steps}")
            print(f"Best Valid Score: {self.best_valid_score if self.best_valid_score != float('inf') else 'None'}")
    
    def close(self):
        """Close the environment."""
        if self.render_mode == "pygame":
            pygame.quit()

# Example usage
if __name__ == "__main__":
    # Example with different number of sets
    num_sets = 6  # Try with different numbers of sets
    max_elements = 50
    env = SetsEnvironment(num_sets=num_sets, max_elements = max_elements, render_mode="pygame")
    obs, _ = env.reset()
    
    running = True
    while running:
        # Handle Pygame events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                
        # Random agent example
        action = env.action_space.sample()
        obs, reward, terminated, truncated, info = env.step(action)
        
        if terminated or truncated:
            obs, _ = env.reset()
            
    env.close()

\end{lstlisting}

\newpage
\clearpage

\subsubsection*{Problem 4}

\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={USAMO 2024 problem 4 game code.},
label={listing:USAMO2024C4}
]

import pygame
import numpy as np
import gymnasium as gym
from gymnasium import spaces
from datetime import datetime

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
GRAY = (200, 200, 200)
GREEN = (0, 255, 0)

# Screen settings
WIDTH, HEIGHT = 600, 800
CELL_SIZE = 143
MARGIN = 5
FPS = 30


class BeadsGame(gym.Env):
    def __init__(self, initial_m=4, initial_n=4, max_blocks=10):
        super().__init__()
        self.max_blocks = max_blocks
        self.m = initial_m
        self.n = initial_n

        # Gymnasium action and observation spaces
        self.action_space = spaces.MultiDiscrete([2] * (self.m * self.n))
        self.observation_space = spaces.Box(
            low=0, high=1,
            shape=(self.m, self.n),
            dtype=np.int32
        )

        # Pygame setup
        pygame.init()
        self.screen = pygame.display.set_mode((WIDTH, HEIGHT))
        pygame.display.set_caption("Beads Game")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont("Arial", 20)

        # Track successful solutions
        self.solutions = set()
        self.solutions_file = f"beads_solutions_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"

        # Game state
        self.reset()

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.grid = np.zeros((self.m, self.n), dtype=int)
        self.valid = False
        self.score = 0
        return self.grid, {}

    def check_constraints(self):
        """
        Check if each possible circular cut of the necklace has unique red bead counts.
        Checks that for each start position, the rows have distinct red bead counts.
        """
        # Manually extend the grid by copying the next row to the right, and for the last row, wrap around to the first row
        extended_grid = np.zeros((self.m, 2 * self.n), dtype=int)  # Create an extended grid

        for row in range(self.m):
            # Copy the current row to the first part of the extended grid
            extended_grid[row, :self.n] = self.grid[row]

            # Copy the next row to the second part (wrap around for the last row)
            extended_grid[row, self.n:] = self.grid[(row + 1) % self.m]

        # For each possible start position
        for start in range(self.n):
            # Collect red bead counts for this circular cut
            row_counts = [np.sum(extended_grid[row, start:start + self.n]) for row in range(self.m)]

            # Check if all counts in this cut are unique
            if len(set(row_counts)) != self.m:
                return False

        return True

    def calculate_score(self):
        """Calculate the score based on grid validity and bead count."""
        return self.m * self.n if self.check_constraints() else -1

    def update_solutions(self):
        """Automatically track valid solutions."""
        if self.check_constraints():
            self.solutions.add((self.n, self.m))

    def save_solutions_to_file(self):
        """Write all collected solutions to file as tuples."""
        if len(self.solutions) > 0:
            sorted_solutions = sorted(list(self.solutions))
            with open(self.solutions_file, 'w') as f:
                solution_strings = [f"({n},{m})" for n, m in sorted_solutions]
                f.write(" ; ".join(solution_strings))
            print(f"Solutions saved to {self.solutions_file}")

    def step(self, action):
        # Convert action to grid update
        action_grid = np.array(action).reshape(self.m, self.n)
        self.grid = action_grid

        # Check game constraints and update solutions
        self.valid = self.check_constraints()
        self.score = self.calculate_score()
        self.update_solutions()

        # Determine if game is done
        done = self.valid

        return self.grid, self.score, done, False, {}

    def render(self):
        self.screen.fill(WHITE)

        # Draw grid
        for row in range(self.m):
            for col in range(self.n):
                color = RED if self.grid[row][col] == 1 else BLUE
                pygame.draw.rect(self.screen, color, [
                    col * (CELL_SIZE + MARGIN) + MARGIN,
                    row * (CELL_SIZE + MARGIN) + MARGIN,
                    CELL_SIZE,
                    CELL_SIZE
                ])
                pygame.draw.rect(self.screen, GRAY, [
                    col * (CELL_SIZE + MARGIN) + MARGIN,
                    row * (CELL_SIZE + MARGIN) + MARGIN,
                    CELL_SIZE,
                    CELL_SIZE
                ], 1)

        # Display current m and n
        m_text = self.font.render(f"Rows (m): {self.m}", True, BLACK)
        n_text = self.font.render(f"Columns (n): {self.n}", True, BLACK)
        # self.screen.blit(m_text, (WIDTH - 200, 10))
        # self.screen.blit(n_text, (WIDTH - 200, 40))
        self.screen.blit(m_text, (WIDTH - 200, HEIGHT - 140))
        self.screen.blit(n_text, (WIDTH - 200, HEIGHT - 110))

        # Display solutions count
        solutions_text = self.font.render(f"Solutions found: {len(self.solutions)}", True, BLACK)
        self.screen.blit(solutions_text, (WIDTH - 200, HEIGHT - 30))

        # Display real-time score and status
        score_text = self.font.render(f"Score: {self.calculate_score()}", True, BLACK)
        self.screen.blit(score_text, (WIDTH - 200, HEIGHT - 70))

        if self.check_constraints():
            status_text = self.font.render("Valid Configuration!", True, GREEN)
        else:
            status_text = self.font.render("Invalid Configuration", True, RED)
        self.screen.blit(status_text, (WIDTH // 2 - 100, HEIGHT - 40))

        # Display controls
        controls_text1 = self.font.render("Q/A: Change m  |  W/S: Change n", True, BLACK)
        controls_text2 = self.font.render("R: Reset  |  ESC: Quit", True, BLACK)
        self.screen.blit(controls_text1, (10, HEIGHT - 140))
        self.screen.blit(controls_text2, (10, HEIGHT - 110))

        pygame.display.flip()
        self.clock.tick(FPS)

    def close(self):
        self.save_solutions_to_file()
        pygame.quit()


def interactive_play():
    env = BeadsGame()

    running = True
    while running:
        env.render()

        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = pygame.mouse.get_pos()
                col = x // (CELL_SIZE + MARGIN)
                row = y // (CELL_SIZE + MARGIN)
                if 0 <= row < env.m and 0 <= col < env.n:
                    env.grid[row][col] = 1 - env.grid[row][col]
                    env.update_solutions()  # Check for valid solution after each move
            elif event.type == pygame.KEYDOWN:
                # Controls for m and n
                if event.key == pygame.K_q and env.m > 1:
                    env.m -= 1
                    env.reset()
                elif event.key == pygame.K_a:
                    env.m += 1
                    env.reset()
                elif event.key == pygame.K_w and env.n > 1:
                    env.n -= 1
                    env.reset()
                elif event.key == pygame.K_s:
                    env.n += 1
                    env.reset()

                # Reset game
                elif event.key == pygame.K_r:
                    env.reset()

                # Quit game
                elif event.key == pygame.K_ESCAPE:
                    running = False

    env.close()


if __name__ == "__main__":
    interactive_play()


\end{lstlisting}


\newpage
\clearpage


\subsection*{2023 IMO Shortlist}
\label{appendix:H_2023_IMO_Shortlist}

\subsubsection*{Problem 1}
\label{appendix:H_2023_IMO_Shortlist_C1}

\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={IMO 2023 Shortlist problem 1 game code.},
label={listing:IMO2023SLC1}
]
import time

import numpy as np
import pygame
import gymnasium as gym
from gymnasium import spaces

class CoinFlipGridEnv(gym.Env):
    """
    Custom Gymnasium environment for the coin flipping problem.
    The agent aims to flip all coins to head-side up (1),
    using moves defined in the problem description.
    """
    metadata = {'render_modes': ['human', 'rgb_array'], 'render_fps': 10}

    def __init__(self, m=4, n=4, render_mode=None):
        super().__init__()
        self.coin_choice = 0

        self.m = m  # number of rows
        self.n = n  # number of columns
        self.size = (self.m, self.n)
        self.render_mode = render_mode

        # Maximum window size
        self.max_window_size = 800  # Maximum size of the PyGame window (adjust as needed)
        self.text_height = 70       # Height reserved for text and buttons at the top

        # Compute cell size and window dimensions dynamically based on m and n
        self.cell_size = min((self.max_window_size - self.text_height) // self.m, (self.max_window_size) // self.n)
        self.window_width = self.n * self.cell_size
        self.window_height = self.m * self.cell_size + self.text_height  # Add space for text

        # Observation space: the state of the grid (flattened)
        self.observation_space = spaces.Box(0, 1, shape=(self.m * self.n,), dtype=int)

        # Action space: selecting a 2x2 square and choosing which coin to flip
        # Total actions = 2 * (m-1)*(n-1)
        self.num_actions = 2 * (self.m - 1) * (self.n - 1)
        self.action_space = spaces.Discrete(self.num_actions)

        # PyGame variables
        self.window = None
        self.clock = None

        # Initialize the state
        self.state = np.zeros((self.m, self.n), dtype=int)

        # Variables for highlighting
        self.last_action = None  # To store the last action taken
        self.flipped_coins = []  # To store the positions of flipped coins

        # For the "Reset" button
        self.button_rect = pygame.Rect(self.window_width - 100, 10, 80, 30)

    def reset(self, seed=None, options=None):
        super().reset(seed=seed)
        self.state = np.zeros((self.m, self.n), dtype=int)
        self.last_action = None
        self.flipped_coins = []
        if self.render_mode == "human" and self.window is not None:
            self.window.fill((255, 255, 255))
            pygame.display.flip()
        return self.state.flatten(), {}

    def step(self, action):
        total_squares = (self.m - 1) * (self.n - 1)
        if action < total_squares * 2:
            square_index = action // 2
            coin_choice = action % 2  # 0: flip top-right; 1: flip bottom-left

            i = square_index // (self.n - 1)
            j = square_index % (self.n - 1)

            self._perform_move(i, j, coin_choice)
            self.last_action = (i, j, coin_choice)  # Store the last action for highlighting
        else:
            raise ValueError("Invalid action.")

        done = np.all(self.state == 1)
        reward = 1 if done else -0.01

        return self.state.flatten(), reward, done, False, {}

    def _perform_move(self, i, j, coin_choice):
        self.flipped_coins = []

        self.state[i, j] ^= 1  # Flip top-left
        self.flipped_coins.append((i, j))

        self.state[i+1, j+1] ^= 1  # Flip bottom-right
        self.flipped_coins.append((i+1, j+1))

        if coin_choice == 0:
            self.state[i, j+1] ^= 1  # Flip top-right
            self.flipped_coins.append((i, j+1))
        else:
            self.state[i+1, j] ^= 1  # Flip bottom-left
            self.flipped_coins.append((i+1, j))

    def calculate_T_values(self):
        T = [0, 0, 0]
        for i in range(self.m):
            for j in range(self.n):
                label = (i + j) % 3  # Zero-based indexing
                if self.state[i, j] == 1:  # Coin is head-side up
                    T[label] += 1
        return T

    def check_invariant(self):
        T = self.calculate_T_values()
        parity = [T[i] % 2 for i in range(3)]
        return parity.count(parity[0]) == 3  # Returns True if all parities are equal

    def render(self):
        if self.render_mode == "human":
            if self.window is None:
                pygame.init()
                pygame.display.init()
                self.window = pygame.display.set_mode((self.window_width, self.window_height))
                self.clock = pygame.time.Clock()
            self._render_frame()
            self.clock.tick(self.metadata["render_fps"])
        elif self.render_mode == "rgb_array":
            return self._render_frame()

    def _render_frame(self):
        if self.window is None:
            pygame.init()
            pygame.display.init()
            self.window = pygame.Surface((self.window_width, self.window_height))

        self.window.fill((255, 255, 255))

        # Draw the coin_choice indicator
        font = pygame.font.SysFont(None, 24)
        coin_choice_text = f"Coin choice: {self.coin_choice} ({'top-right' if self.coin_choice == 0 else 'bottom-left'})"
        text = font.render(coin_choice_text, True, (0, 0, 0))
        self.window.blit(text, (10, 10))

        # Draw the "Reset" button
        pygame.draw.rect(self.window, (0, 128, 0), self.button_rect)  # Green button
        text = font.render('Reset', True, (255, 255, 255))
        text_rect = text.get_rect(center=self.button_rect.center)
        self.window.blit(text, text_rect)

        # Calculate T values and check invariant
        T = self.calculate_T_values()
        invariant_holds = self.check_invariant()

        # Display T(0), T(1), T(2)
        T_text = f"T(0): {T[0]}, T(1): {T[1]}, T(2): {T[2]}"
        T_surface = font.render(T_text, True, (0, 0, 0))
        self.window.blit(T_surface, (10, 35))

        # Display invariant status
        invariant_text = f"Invariant holds: {invariant_holds}"
        invariant_surface = font.render(invariant_text, True, (0, 0, 0))
        self.window.blit(invariant_surface, (200, 35))

        # Draw the grid and coins
        for i in range(self.m):
            for j in range(self.n):
                rect = pygame.Rect(
                    j * self.cell_size,
                    i * self.cell_size + self.text_height,  # Adjust for the coin_choice text
                    self.cell_size,
                    self.cell_size
                )
                pygame.draw.rect(self.window, (0, 0, 0), rect, 1)

                # Draw coin
                if self.state[i, j] == 0:
                    pygame.draw.circle(
                        self.window,
                        (128, 128, 128),
                        rect.center,
                        self.cell_size // 2 - 5
                    )
                else:
                    pygame.draw.circle(
                        self.window,
                        (255, 223, 0),
                        rect.center,
                        self.cell_size // 2 - 5
                    )

                # Calculate the label
                label = i + j + 1 # (i + j) % 3  # 1-n and 1-m
                #label =  (i + j) % 3  # Zero-based indexing
                label_text = str(label)
                label_surface = font.render(label_text, True, (0, 0, 0))
                label_rect = label_surface.get_rect(
                    center=(rect.x + self.cell_size // 2, rect.y + self.cell_size // 2)
                )
               # self.window.blit(label_surface, label_rect)

        # Highlight the last selected 2x2 square and flipped coins
        if self.last_action is not None:
            i, j, _ = self.last_action
            highlight_rect = pygame.Rect(
                j * self.cell_size,
                i * self.cell_size + self.text_height,
                self.cell_size * 2,
                self.cell_size * 2
            )
            pygame.draw.rect(self.window, (255, 0, 0), highlight_rect, 3)  # Red border

            for (fi, fj) in self.flipped_coins:
                padding = 4
                rect = pygame.Rect(
                    fj * self.cell_size + padding,
                    fi * self.cell_size + self.text_height + padding,
                    self.cell_size - 2 * padding,
                    self.cell_size - 2 * padding
                )
                pygame.draw.rect(self.window, (0, 255, 0), rect, 3)  # Green border

        if self.render_mode == "human":
            pygame.display.get_surface().blit(self.window, (0, 0))
            pygame.display.flip()
        else:
            return np.array(pygame.surfarray.array3d(self.window))

    def close(self):
        if self.window is not None:
            pygame.display.quit()
            pygame.quit()
            self.window = None
            self.clock = None
            
\end{lstlisting}


\newpage
\clearpage

\subsubsection*{Problem 2}
\label{appendix:G_2023_IMO_Shortlist_C2}

\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={IMO 2023 Shortlist problem 2 game code.},
label={listing:IMO2024SLC2}
]
import gymnasium as gym
from gymnasium import spaces
import numpy as np
from itertools import product
import pygame
import sys
import csv
from dataclasses import dataclass
from typing import Optional, Dict, Any, List, Tuple

@dataclass
class SequenceRecord:
    sequence: List[int]
    score: float
    k: int

class SequenceGameEnv(gym.Env):
    def __init__(self, initial_k: int = 10, human_play: bool = True):
        super(SequenceGameEnv, self).__init__()
        
        self.human_play = human_play
        self.k = initial_k
        self.sequence = []
        self.max_length = 100
        
        # History tracking
        self.submission_history: List[SequenceRecord] = []
        self.best_submission: Optional[SequenceRecord] = None
        
        # Action space includes numbers 1 to k and 'submit' action
        self.action_space = spaces.Discrete(self.k + 1)
        
        self.observation_space = spaces.Dict({
            "sequence": spaces.Box(low=1, high=self.k, shape=(self.max_length,), dtype=np.int64),
            "length": spaces.Discrete(self.max_length),
            "k": spaces.Box(low=1, high=np.inf, shape=(1,), dtype=np.int64)
        })
        
        self.reset()

    def set_k(self, new_k: int) -> None:
        self.k = new_k
        self.action_space = spaces.Discrete(self.k + 1)

    def reset(self, k: Optional[int] = None) -> tuple[Dict, Dict]:
        if k is not None:
            self.set_k(k)
        
        self.sequence = []
        
        observation = {
            "sequence": np.array(self.sequence),
            "length": len(self.sequence),
            "k": np.array([self.k])
        }
        return observation, {}

    def step(self, action: int) -> tuple[Dict, float, bool, bool, Dict]:
        done = False
        reward = 0
        
        # Handle submit action
        if action == self.k:  # Submit action
            if len(self.sequence) > 0:
                if self._is_valid_sequence():
                    reward = len(self.sequence)
                    # Record submission
                    record = SequenceRecord(
                        sequence=self.sequence.copy(),
                        score=reward,
                        k=self.k
                    )
                    self.submission_history.append(record)
                    
                    # Update best submission
                    if (self.best_submission is None or 
                        reward > self.best_submission.score):
                        self.best_submission = record
                else:
                    reward = -1
                # Reset sequence after submission but don't end game
                self.sequence = []
            else:
                reward = 0
        
        # Handle number actions
        elif 0 < action <= self.k:
            self.sequence.append(action)
            if len(self.sequence) >= self.max_length:
                done = True
                reward = -1 if not self._is_valid_sequence() else len(self.sequence)

        observation = {
            "sequence": np.array(self.sequence),
            "length": len(self.sequence),
            "k": np.array([self.k])
        }        
        return observation, reward, done, False, {}

    def _is_valid_sequence(self) -> bool:
        for i in range(len(self.sequence)):
            for j in range(i + 1, len(self.sequence) + 1):
                sub_seq = self.sequence[i:j]
                for s in product([1, -1], repeat=len(sub_seq)):
                    if np.dot(sub_seq, s) == 0:
                        return False
        return True
    
    def export_best_result(self, filename: str = "best_sequence.csv"):
        if self.best_submission:
            with open(filename, 'w', newline='') as f:
                writer = csv.writer(f)
                writer.writerow(['k', 'best_list', 'length'])
                writer.writerow([
                    self.best_submission.k,
                    ','.join(map(str, self.best_submission.sequence)),
                    len(self.best_submission.sequence)
                ])

class SequenceGameGUI:
    def __init__(self, env: SequenceGameEnv):
        pygame.init()
        self.env = env
        self.WIDTH, self.HEIGHT = 800, 600
        self.screen = pygame.display.set_mode((self.WIDTH, self.HEIGHT))
        pygame.display.set_caption("Sequence Game")
        self.font = pygame.font.Font(None, 32)
        
        # Button settings
        self.button_width = 60
        self.button_height = 40
        self.button_margin = 10
        self.number_button_color = (0, 0, 255)
        self.button_hover_color = (0, 100, 255)
        
        # Control button colors
        self.submit_button_color = (0, 255, 0)
        self.quit_button_color = (255, 0, 0)
        self.reset_button_color = (255, 165, 0)
        
        # Scroll settings
        self.scroll_x = 0
        self.scroll_speed = 20
        self.buttons_area_width = self.WIDTH - 120
        
        # Button rectangles
        self.submit_button = pygame.Rect(10, 120, 100, 40)
        self.quit_button = pygame.Rect(120, 120, 100, 40)
        self.reset_button = pygame.Rect(10, self.HEIGHT - 50, 100, 40)
        
        # K input settings
        self.k_input = ""
        self.k_input_active = False
        self.k_input_rect = pygame.Rect(120, self.HEIGHT - 50, 100, 40)
        
        # Tooltip settings
        self.hover_text = ""
        self.hover_pos = (0, 0)

    def draw_buttons(self):
        total_width = self.env.k * (self.button_width + self.button_margin)
        
        # Draw scroll arrows if needed
        if total_width > self.buttons_area_width:
            left_arrow = pygame.Rect(0, 60, 30, self.button_height)
            pygame.draw.rect(self.screen, (150, 150, 150), left_arrow)
            if left_arrow.collidepoint(pygame.mouse.get_pos()):
                self.scroll_x = min(0, self.scroll_x + self.scroll_speed)
            
            right_arrow = pygame.Rect(self.WIDTH - 30, 60, 30, self.button_height)
            pygame.draw.rect(self.screen, (150, 150, 150), right_arrow)
            if right_arrow.collidepoint(pygame.mouse.get_pos()):
                self.scroll_x = max(-(total_width - self.buttons_area_width), 
                                  self.scroll_x - self.scroll_speed)
        
        # Create number buttons surface
        buttons_surface = pygame.Surface((total_width, self.button_height))
        buttons_surface.fill((255, 255, 255))
        
        mouse_pos = pygame.mouse.get_pos()
        
        # Draw number buttons
        self.hover_text = ""
        for i in range(1, self.env.k + 1):
            x = (i-1) * (self.button_width + self.button_margin)
            button_rect = pygame.Rect(x, 0, self.button_width, self.button_height)
            
            screen_rect = pygame.Rect(x + 30 + self.scroll_x, 60, 
                                    self.button_width, self.button_height)
            if screen_rect.collidepoint(mouse_pos):
                pygame.draw.rect(buttons_surface, self.button_hover_color, button_rect)
                self.hover_text = str(i)
                self.hover_pos = (mouse_pos[0], mouse_pos[1] - 20)
            else:
                pygame.draw.rect(buttons_surface, self.number_button_color, button_rect)
            
            button_text = self.font.render(str(i), True, (255, 255, 255))
            buttons_surface.blit(button_text, (x + 15, 8))
        
        # Draw buttons surface with clipping
        buttons_display = pygame.Surface((self.buttons_area_width, self.button_height))
        buttons_display.fill((255, 255, 255))
        buttons_display.blit(buttons_surface, (self.scroll_x, 0))
        self.screen.blit(buttons_display, (30, 60))
        
        # Draw control buttons
        pygame.draw.rect(self.screen, self.submit_button_color, self.submit_button)
        submit_text = self.font.render("Submit", True, (255, 255, 255))
        self.screen.blit(submit_text, (20, 130))
        
        pygame.draw.rect(self.screen, self.quit_button_color, self.quit_button)
        quit_text = self.font.render("Quit", True, (255, 255, 255))
        self.screen.blit(quit_text, (140, 130))
        
        pygame.draw.rect(self.screen, self.reset_button_color, self.reset_button)
        reset_text = self.font.render("Reset", True, (255, 255, 255))
        self.screen.blit(reset_text, (20, self.HEIGHT - 45))
        
        # Draw k input box
        pygame.draw.rect(self.screen, (200, 200, 200) if self.k_input_active 
                        else (100, 100, 100), self.k_input_rect)
        k_text = self.font.render(self.k_input, True, (255, 255, 255))
        self.screen.blit(k_text, (130, self.HEIGHT - 45))
        
        # Draw current k and best score
        k_label = self.font.render(f"Current k: {self.env.k}", True, (0, 0, 0))
        self.screen.blit(k_label, (230, self.HEIGHT - 45))
        
        if self.env.best_submission:
            best_score = self.font.render(
                f"Best Score: {self.env.best_submission.score}", True, (0, 0, 0))
            self.screen.blit(best_score, (400, self.HEIGHT - 45))

        # Draw hover text
        if self.hover_text:
            hover_surface = self.font.render(self.hover_text, True, (0, 0, 0))
            self.screen.blit(hover_surface, self.hover_pos)

    def get_button_at_position(self, pos):
        adjusted_x = pos[0] - 30 - self.scroll_x
        if 60 <= pos[1] <= 60 + self.button_height:
            button_index = adjusted_x // (self.button_width + self.button_margin)
            if 0 <= button_index < self.env.k:
                return int(button_index + 1)
        return None

    def run(self):
        observation, _ = self.env.reset()
        running = True
        
        while running:
            self.screen.fill((255, 255, 255))
            
            # Display current sequence
            sequence_text = "Current Sequence: " + " ".join(map(str, self.env.sequence))
            text_surface = self.font.render(sequence_text, True, (0, 0, 0))
            self.screen.blit(text_surface, (10, 10))
            
            # Draw all buttons
            self.draw_buttons()
            
            # Update display
            pygame.display.flip()
            
            # Event handling
            for event in pygame.event.get():
                if event.type == pygame.QUIT:
                    running = False
                
                elif event.type == pygame.MOUSEBUTTONDOWN:
                    mouse_pos = pygame.mouse.get_pos()
                    button_clicked = self.get_button_at_position(mouse_pos)
                    
                    if button_clicked is not None:
                        observation, reward, done, _, _ = self.env.step(button_clicked)
                    
                    elif self.submit_button.collidepoint(mouse_pos):
                        observation, reward, done, _, _ = self.env.step(self.env.k)
                        if reward > 0:
                            self.show_submission_result(reward)
                    
                    elif self.quit_button.collidepoint(mouse_pos):
                        self.env.export_best_result()
                        running = False
                    
                    elif self.reset_button.collidepoint(mouse_pos):
                        try:
                            new_k = int(self.k_input) if self.k_input else self.env.k
                            if new_k > 0:
                                observation, _ = self.env.reset(k=new_k)
                                self.scroll_x = 0
                            self.k_input = ""
                        except ValueError:
                            pass
                    
                    self.k_input_active = self.k_input_rect.collidepoint(mouse_pos)
                
                elif event.type == pygame.KEYDOWN and self.k_input_active:
                    if event.key == pygame.K_RETURN:
                        self.k_input_active = False
                    elif event.key == pygame.K_BACKSPACE:
                        self.k_input = self.k_input[:-1]
                    elif event.unicode.isdigit():
                        self.k_input += event.unicode
        
        pygame.quit()

    def show_submission_result(self, reward):
        """Display submission result briefly."""
        overlay = pygame.Surface((300, 100))
        overlay.fill((255, 255, 255))
        pygame.draw.rect(overlay, (0, 255, 0), overlay.get_rect(), 2)
        
        text = self.font.render(f"Sequence Score: {reward}", True, (0, 0, 0))
        overlay.blit(text, (20, 40))
        
        x = (self.WIDTH - overlay.get_width()) // 2
        y = (self.HEIGHT - overlay.get_height()) // 2
        
        self.screen.blit(overlay, (x, y))
        pygame.display.flip()
        pygame.time.wait(1000)

def main():
    env = SequenceGameEnv(initial_k=10, human_play=True)
    gui = SequenceGameGUI(env)
    gui.run()

if __name__ == "__main__":
    main()

\end{lstlisting}


\newpage
\clearpage

\subsubsection*{Problem 3}
\label{appendix:G_2023_IMO_Shortlist_C3}


\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={2023 IMO Shortlist problem 3 game code.},
label={listing:IMO2024SLC3}
]
import pygame
import pygame.gfxdraw
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import sys
import time

# Gymnasium Environment class definition
class IMOEnvironment(gym.Env):
    metadata = {'render_modes': ['human']}
    def __init__(self, n=6):
        super(IMOEnvironment, self).__init__()
        self.n = n  # Number of rows in the triangle
        self.action_space = spaces.Discrete(2)  # 0: Left, 1: Right
        self.observation_space = spaces.Tuple((
            spaces.Discrete(self.n),  # Current row
            spaces.Discrete(self.n),  # Position in current row
            spaces.MultiBinary(self.n * (self.n + 1) // 2)  # Red circles configuration
        ))
        self.screen_width = 800
        self.screen_height = 600
        self.reset()
        # Pygame initialization
        pygame.init()
        self.screen = pygame.display.set_mode((self.screen_width, self.screen_height))
        pygame.display.set_caption('IMO Ninja Path Environment')
        self.clock = pygame.time.Clock()
    
    def reset(self):
        # Initialize the triangle and red circles
        self.current_row = 0
        self.current_pos = 0  # Always start at the top circle
        self.path = [(self.current_row, self.current_pos)]
        # Generate red circles: one per row
        self.red_circles = {}
        for row in range(self.n):
            red_pos = np.random.randint(0, row + 1)
            self.red_circles[row] = red_pos
        # Create a flattened representation for the observation
        self.state = (self.current_row, self.current_pos, self._get_red_circles_flat())
        return self.state
    
    def step(self, action):
        # Action: 0 for Left, 1 for Right
        done = False
        reward = 0

        # Move to the next row
        self.current_row += 1
        if action == 0:
            # Move to the left child
            self.current_pos = self.current_pos
        elif action == 1:
            # Move to the right child
            self.current_pos = self.current_pos + 1
        else:
            raise ValueError("Invalid action")

        self.path.append((self.current_row, self.current_pos))

        # Check if landed on a red circle
        if self.red_circles.get(self.current_row) == self.current_pos:
            reward = 1

        # Check if we have reached the bottom row
        if self.current_row == self.n - 1:
            done = True

        self.state = (self.current_row, self.current_pos, self._get_red_circles_flat())
        info = {}
        return self.state, reward, done, info

    def render(self, mode='human'):
         # Handle Pygame events
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()

        # Clear the screen
        self.screen.fill((255, 255, 255))  # White background

        # Parameters for drawing
        circle_radius = 30
        vertical_spacing = 53
        horizontal_spacing = 60
        start_x = self.screen_width // 2
        start_y = 100

        # Draw the triangle of circles
        positions = {}
        for row in range(self.n):
            row_circles = row + 1
            row_y = start_y + row * vertical_spacing
            row_width = (row_circles - 1) * horizontal_spacing
            for pos in range(row_circles):
                # Calculate x position
                x = start_x - row_width // 2 + pos * horizontal_spacing
                y = row_y
                positions[(row, pos)] = (x, y)

                # Determine circle color
                circle_color = (255, 255, 255)  # White
                if self.red_circles.get(row) == pos:
                    circle_color = (255, 0, 0)  # Red

                # Draw the circle
                pygame.gfxdraw.filled_circle(self.screen, int(x), int(y), circle_radius, circle_color)
                pygame.gfxdraw.aacircle(self.screen, int(x), int(y), circle_radius, (0, 0, 0))  # Black border

        # Draw fancy arrows along the path
        if len(self.path) > 1:
            for i in range(len(self.path) - 1):
                start_pos = positions[self.path[i]]
                end_pos = positions[self.path[i + 1]]
                self.draw_fancy_arrow(self.screen, (0, 0, 0), start_pos, end_pos)

        # Update the display
        pygame.display.flip()
        self.clock.tick(2)  # Limit to 2 frames per second

    def draw_fancy_arrow(self, surface, color, start, end, arrow_width=5, arrow_head_length=20, arrow_head_width=20):
        # Scale arrow dimensions
        arrow_width = int(arrow_width)
        arrow_head_length = int(arrow_head_length)
        arrow_head_width = int(arrow_head_width)

        # Calculate the direction vector
        direction = pygame.math.Vector2(end) - pygame.math.Vector2(start)
        length = direction.length()
        if length == 0:
            return
        direction = direction.normalize()

        # Calculate the arrowhead points
        left_head = end - direction * arrow_head_length + direction.rotate(90) * (arrow_head_width / 2)
        right_head = end - direction * arrow_head_length + direction.rotate(-90) * (arrow_head_width / 2)

        # Draw the arrow shaft with anti-aliasing
        pygame.draw.line(surface, color, start, end, arrow_width)

        # Draw the arrowhead
        pygame.gfxdraw.filled_polygon(surface, [(int(end[0]), int(end[1])),
                                                (int(left_head[0]), int(left_head[1])),
                                                (int(right_head[0]), int(right_head[1]))], color)
        pygame.gfxdraw.aapolygon(surface, [(int(end[0]), int(end[1])),
                                           (int(left_head[0]), int(left_head[1])),
                                           (int(right_head[0]), int(right_head[1]))], color)

    def _get_red_circles_flat(self):
        # Flatten the red circles into a binary array
        total_circles = self.n * (self.n + 1) // 2
        red_circles_flat = np.zeros(total_circles, dtype=int)
        index = 0
        for row in range(self.n):
            for pos in range(row + 1):
                if self.red_circles.get(row) == pos:
                    red_circles_flat[index] = 1
                index += 1
        return red_circles_flat

    def close(self):
        if self.render_mode == 'human':
            pygame.quit()

# Main game loop
def main():
    env = IMOEnvironment(n=6)
    state = env.reset()
    done = False
    env.render()
    total_reward = 0
    step_count = 0
    path_taken = []

    while not done:
        action = env.action_space.sample()
        time.sleep(0.5)  # Slow down the auto mode for visualization
        state, reward, done, info = env.step(action)
        total_reward += reward
        step_count += 1
        path_taken.append('Left' if action == 0 else 'Right')

    env.render()

    print(f"Episode finished in {step_count} steps.")
    print(f"Actions taken: {path_taken}")
    print(f"Total reward (number of red circles collected): {total_reward}")
    print("-" * 50)
    time.sleep(1)
    
    env.close()

if __name__ == "__main__":
    main()

\end{lstlisting}


\newpage
\clearpage

\subsubsection*{Problem 4}
\label{appendix:G_2023_IMO_Shortlist_C4}



\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={2023 IMO Shortlist game code.},
label={listing:IMO2024SLC4}
]
import gymnasium as gym
from gymnasium import spaces
import numpy as np
import pygame
import sys

class StripToGridEnv(gym.Env):
    metadata = {'render.modes': ['human']}

    def __init__(self, n=3):
        super(StripToGridEnv, self).__init__()
        self.n = n
        self.n2 = n * n
        self.action_space = spaces.MultiBinary(self.n2 - 1)
        self.observation_space = spaces.MultiBinary(self.n2 - 1)
        self.state = np.zeros(self.n2 - 1, dtype=int)
        self.num_cuts = 0
        self.done = False
        self.screen = None
        self.clock = None
        self.isopen = True

    def step(self, action):
        assert self.action_space.contains(action), f"{action} ({type(action)}) invalid"
        if self.done:
            return self.state, 0, self.done, {}
        cuts_made = action.astype(int)
        new_cuts = np.maximum(self.state, cuts_made)
        cuts_added = np.sum(new_cuts - self.state)
        self.state = new_cuts
        self.num_cuts += cuts_added
        reward = -cuts_added
        success = self.attempt_assemble_grid()
        if success:
            reward += 1000
            self.done = True
        info = {}
        return self.state, reward, self.done, info

    def reset(self):
        self.state = np.zeros(self.n2 - 1, dtype=int)
        self.num_cuts = 0
        self.done = False
        return self.state

    def render(self, mode='human'):
        if self.screen is None:
            pygame.init()
            pygame.display.init()
            self.size = self.width, self.height = 300, 300
            self.screen = pygame.display.set_mode(self.size)
            pygame.display.set_caption("Strip to Grid Animation")
            self.clock = pygame.time.Clock()
            self.WHITE = (255, 255, 255)
            self.BLACK = (0, 0, 0)
            self.GROUP_COLORS = [
                (255, 200, 200),
                (200, 255, 200),
                (200, 200, 255),
                (255, 255, 200),
                (200, 255, 255),
                (255, 200, 255),
                (240, 240, 240),
                (200, 200, 200),
                (150, 150, 150),
            ]
            self.cell_size = self.width // self.n
            self.font = pygame.font.SysFont(None, 40)
            self.arrived_pieces = []
            self.moving_pieces = []
            self.pieces_initialized = False
        self.screen.fill(self.WHITE)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.isopen = False
        for i in range(self.n + 1):
            pygame.draw.line(self.screen, self.BLACK, (0, i * self.cell_size), (self.width, i * self.cell_size), 2)
            pygame.draw.line(self.screen, self.BLACK, (i * self.cell_size, 0), (i * self.cell_size, self.height), 2)
        if not self.pieces_initialized:
            self.prepare_pieces()
            self.pieces_initialized = True
        if not self.done:
            self.animate_pieces()
        else:
            self.draw_all_pieces()
        pygame.display.flip()
        self.clock.tick(60)

    def close(self):
        if self.screen is not None:
            pygame.display.quit()
            pygame.quit()
            self.isopen = False

    def attempt_assemble_grid(self):
        cut_positions = np.where(self.state == 1)[0] + 1
        piece_indices = np.split(np.arange(1, self.n2 + 1), cut_positions)
        labels = np.concatenate(piece_indices)
        if len(labels) != self.n2:
            return False
        grid = np.reshape(labels, (self.n, self.n))
        for i in range(self.n):
            for j in range(self.n):
                a_ij = grid[i, j]
                if (a_ij - (i + 1 + j + 1 - 1)) % self.n != 0:
                    return False
        return True

    def prepare_pieces(self):
        cut_positions = np.where(self.state == 1)[0] + 1
        piece_indices = np.split(np.arange(1, self.n2 + 1), cut_positions)
        self.pieces = {}
        self.piece_order = []
        self.start_positions = {}
        self.moving_pieces = {}
        self.arrived_pieces = []
        group = 0
        offsets = [(-self.cell_size * self.n, 0), (self.width, 0), (0, -self.cell_size * self.n)]
        offset_index = 0
        row = 0
        col = 0
        for idx, piece in enumerate(piece_indices):
            piece_size = len(piece)
            cells = []
            numbers = []
            for p in piece:
                cells.append((row, col))
                numbers.append(p)
                col += 1
                if col >= self.n:
                    col = 0
                    row += 1
            start_pos = offsets[offset_index % len(offsets)]
            offset_index += 1
            self.pieces[group] = {
                'cells': cells,
                'numbers': numbers,
                'start_pos': start_pos,
            }
            self.piece_order.append(group)
            group += 1
        for group in self.piece_order:
            piece = self.pieces[group]
            self.moving_pieces[group] = {
                'positions': [],
                'cells': piece['cells'],
                'numbers': piece['numbers'],
                'start_pos': list(piece['start_pos']),
                'current_pos': list(piece['start_pos']),
                'target_cells': piece['cells'],
                'arrived': False,
            }
        self.current_piece_index = 0
        self.move_speed = 5

    def animate_pieces(self):
        for group in self.arrived_pieces:
            self.draw_piece(group, final_position=True)
        if self.current_piece_index < len(self.piece_order):
            group = self.piece_order[self.current_piece_index]
            piece_info = self.moving_pieces[group]
            if not piece_info['arrived']:
                target_x = piece_info['target_cells'][0][1] * self.cell_size
                target_y = piece_info['target_cells'][0][0] * self.cell_size
                dx = target_x - piece_info['current_pos'][0]
                dy = target_y - piece_info['current_pos'][1]
                dist = (dx ** 2 + dy ** 2) ** 0.5
                if dist < self.move_speed:
                    piece_info['current_pos'][0] = target_x
                    piece_info['current_pos'][1] = target_y
                    piece_info['arrived'] = True
                    self.arrived_pieces.append(group)
                    self.current_piece_index += 1
                else:
                    piece_info['current_pos'][0] += self.move_speed * dx / dist
                    piece_info['current_pos'][1] += self.move_speed * dy / dist
            self.draw_piece(group)
        else:
            self.done = True

    def draw_piece(self, group, final_position=False):
        piece_info = self.moving_pieces[group]
        for idx, (cell_row, cell_col) in enumerate(piece_info['cells']):
            number = piece_info['numbers'][idx]
            group_color = self.GROUP_COLORS[group % len(self.GROUP_COLORS)]
            if final_position:
                cell_x = cell_col * self.cell_size
                cell_y = cell_row * self.cell_size
            else:
                cell_offset_x = (cell_col - piece_info['target_cells'][0][1]) * self.cell_size
                cell_offset_y = (cell_row - piece_info['target_cells'][0][0]) * self.cell_size
                cell_x = piece_info['current_pos'][0] + cell_offset_x
                cell_y = piece_info['current_pos'][1] + cell_offset_y
            cell_rect = pygame.Rect(cell_x, cell_y, self.cell_size, self.cell_size)
            pygame.draw.rect(self.screen, group_color, cell_rect)
            pygame.draw.rect(self.screen, self.BLACK, cell_rect, 2)
            text = self.font.render(str(number), True, self.BLACK)
            text_rect = text.get_rect(center=cell_rect.center)
            self.screen.blit(text, text_rect)

    def draw_all_pieces(self):
        for group in self.piece_order:
            self.draw_piece(group, final_position=True)

def main():
    env = StripToGridEnv(n=3)
    state = env.reset()
    done = False
    action = np.zeros(env.n2 - 1)
    action[2] = 1  # Cut after position 3
    action[5] = 1  # Cut after position 6

    state, reward, done, info = env.step(action)
    env.render()

    while env.isopen:
        env.render()

    env.close()

if __name__ == "__main__":
    main()
\end{lstlisting}




\newpage
\clearpage

\subsubsection*{Problem 5}
\label{appendix:G_2023_IMO_Shortlist_C5}


\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={2023 IMO Shortlist game code.},
label={listing:IMO2024SLC5}
]
import gymnasium as gym
from gymnasium import spaces
import pygame
import numpy as np
import time

class TreasureChestEnv(gym.Env):
    metadata = {"render_modes": ["human", "rgb_array"], "render_fps": 4}

    def __init__(self, num_chests=5, render_mode=None):
        super(TreasureChestEnv, self).__init__()
        
        self.render_mode = render_mode
        self.num_chests = num_chests
        self.window_size = (800, 600)
        self.chest_width = min(100, 700 // self.num_chests)
        self.chest_height = 80
        self.step_count = 0
        self.all_time_max_diff = 0  # Track all-time maximum difference
        
        # Action space: which chest to put gem in
        self.action_space = spaces.Discrete(num_chests)
        
        # Observation space
        self.observation_space = spaces.Dict({
            'gems': spaces.Box(low=0, high=float('inf'), shape=(num_chests,), dtype=np.float32),
            'locks': spaces.Box(low=0, high=1, shape=(num_chests,), dtype=np.int8)
        })

        # Initialize pygame
        self.window = None
        self.clock = None
        self.previous_max_diff = 0
        
        # Button states
        self.step_requested = False
        self.step_count_requested = 0
        
    def reset(self, seed=None):
        super().reset(seed=seed)
        self.gems = np.zeros(self.num_chests, dtype=np.float32)
        self.locks = np.zeros(self.num_chests, dtype=np.int8)
        self.previous_max_diff = 0
        self.warning_message = ""
        self.warning_timer = 0
        self.step_count = 0
        # Removed all_time_max_diff reset to maintain it across regular resets
        
        observation = {
            'gems': self.gems.copy(),
            'locks': self.locks.copy()
        }
        
        if self.render_mode == "human":
            self._render_frame()
            
        return observation, {}

    def reset_with_new_chests(self, new_num_chests):
        """Reset the environment with a new number of chests"""
        self.num_chests = new_num_chests
        self.chest_width = min(100, 700 // self.num_chests)
        self.action_space = spaces.Discrete(new_num_chests)
        self.observation_space = spaces.Dict({
            'gems': spaces.Box(low=0, high=float('inf'), shape=(new_num_chests,), dtype=np.float32),
            'locks': spaces.Box(low=0, high=1, shape=(new_num_chests,), dtype=np.int8)
        })
        self.all_time_max_diff = 0  # Only reset all-time max when changing chest count
        return self.reset()
    
    def choose_best_action(self):
        """AI strategy: Choose the unlocked chest with minimum gems"""
        unlocked_chests = np.where(self.locks == 0)[0]
        if len(unlocked_chests) == 0:
            return None
        
        gems_unlocked = self.gems[unlocked_chests]
        min_gem_idx = unlocked_chests[np.argmin(gems_unlocked)]
        return min_gem_idx

    def step(self, action=None):
        if action is None:
            action = self.choose_best_action()
            if action is None:
                self.warning_message = "No valid moves available!"
                self.warning_timer = time.time()
                return self._get_obs(), -1, True, False, {'invalid_action': True}
        
        self.step_count += 1
        
        if not self._is_valid_action(action):
            self.warning_message = f"Chest #{action} is locked! Choosing another chest."
            self.warning_timer = time.time()
            return self._get_obs(), -1, False, False, {'invalid_action': True}
        
        self.gems[action] += 1
        self._fairy_action()
        
        current_max_diff = np.max(self.gems) - np.min(self.gems)
        self.all_time_max_diff = max(self.all_time_max_diff, current_max_diff)
        
        if current_max_diff < self.previous_max_diff:
            reward = 10
        elif current_max_diff > self.previous_max_diff:
            reward = -10
        else:
            reward = 1
            
        self.previous_max_diff = current_max_diff
        
        if self.render_mode == "human":
            self._render_frame()
        
        return self._get_obs(), reward, False, False, {
            'max_diff': current_max_diff,
            'unlocked_count': np.sum(self.locks == 0),
            'all_time_max_diff': self.all_time_max_diff
        }
    
    def _is_valid_action(self, action):
        return self.locks[action] == 0
    
    def _fairy_action(self):
        """Modified fairy strategy: Lock chest with minimum gems to maximize difference"""
        unlocked_chests = np.where(self.locks == 0)[0]
        if len(unlocked_chests) > 1:
            # Get gems count of unlocked chests
            unlocked_gems = self.gems[unlocked_chests]
            # Find indices of chests with minimum gems
            min_gem_value = np.min(unlocked_gems)
            min_gem_indices = unlocked_chests[unlocked_gems == min_gem_value]
            # Randomly choose one of the chests with minimum gems
            chest_to_lock = self.np_random.choice(min_gem_indices)
            self.locks[chest_to_lock] = 1
        elif len(unlocked_chests) == 1:
            self.locks[:] = 0
    
    def _get_obs(self):
        return {
            'gems': self.gems.copy(),
            'locks': self.locks.copy()
        }
    
    def _render_frame(self):
        if self.window is None and self.render_mode == "human":
            pygame.init()
            pygame.display.init()
            self.window = pygame.display.set_mode(self.window_size)
            pygame.display.set_caption("Treasure Distribution Analysis")
            self.clock = pygame.time.Clock()
            self.font = pygame.font.Font(None, 36)
        
        if self.window is not None:
            # Fill background
            self.window.fill((255, 255, 255))
            
            # Draw title
            title = self.font.render("Treasure Distribution Analysis", True, (0, 0, 0))
            step_text = self.font.render(f"Step Count: {self.step_count}", True, (128, 128, 128))
            
            title_rect = title.get_rect(center=(self.window_size[0]//2, 30))
            step_rect = step_text.get_rect(center=(self.window_size[0]//2, 60))
            
            self.window.blit(title, title_rect)
            self.window.blit(step_text, step_rect)
            
            # Draw buttons (centered, above the grid)
            buttons_y = 100
            button_width = 80
            button_height = 30
            button_spacing = 10
            total_buttons_width = (button_width * 5) + (button_spacing * 4)
            start_x = (self.window_size[0] - total_buttons_width) // 2
            
            buttons = [
                ("Step +1", (start_x, buttons_y)),
                ("Step +10", (start_x + button_width + button_spacing, buttons_y)),
                ("Reset", (start_x + (button_width + button_spacing) * 2, buttons_y)),
                ("N-1", (start_x + (button_width + button_spacing) * 3, buttons_y)),
                ("N+1", (start_x + (button_width + button_spacing) * 4, buttons_y))
            ]
            
            button_rects = []
            for text, pos in buttons:
                button_rect = pygame.Rect(pos[0], pos[1], button_width, button_height)
                pygame.draw.rect(self.window, (255, 255, 255), button_rect)
                pygame.draw.rect(self.window, (0, 0, 0), button_rect, 1)
                
                button_text = self.font.render(text, True, (0, 0, 0))
                text_rect = button_text.get_rect(center=button_rect.center)
                self.window.blit(button_text, text_rect)
                button_rects.append(button_rect)
            
            # Draw chests grid
            grid_top = 150
            chest_size = 96  # 24px * 4 to match the React version
            grid_spacing = 4
            total_grid_width = (chest_size * self.num_chests) + (grid_spacing * (self.num_chests - 1))
            start_x = (self.window_size[0] - total_grid_width) // 2
            
            for i in range(self.num_chests):
                x = start_x + i * (chest_size + grid_spacing)
                
                # Draw chest box
                chest_rect = pygame.Rect(x, grid_top, chest_size, chest_size)
                chest_color = (230, 230, 230) if self.locks[i] else (255, 255, 255)
                pygame.draw.rect(self.window, chest_color, chest_rect)
                pygame.draw.rect(self.window, (0, 0, 0), chest_rect, 1)
                
                # Draw chest number
                num_text = self.font.render(f"#{i}", True, (0, 0, 0))
                num_rect = num_text.get_rect(topleft=(x + 4, grid_top + 4))
                self.window.blit(num_text, num_rect)
                
                # Draw lock status
                lock_text = self.font.render("\textbullet{}" if self.locks[i] else "\textsquare{}", True, (0, 0, 0))
                lock_rect = lock_text.get_rect(topright=(x + chest_size - 4, grid_top + 4))
                self.window.blit(lock_text, lock_rect)
                
                # Draw gems count
                if self.gems[i] > 0:
                    gem_text = self.font.render(f"x{int(self.gems[i])}", True, (0, 0, 0))
                    gem_rect = gem_text.get_rect(bottomleft=(x + 4, grid_top + chest_size - 4))
                    self.window.blit(gem_text, gem_rect)
            
            # Draw legend
            legend_y = grid_top + chest_size + 40
            legend_text = self.font.render("\textsquare{} : unlocked     \textbullet{} : locked", True, (0, 0, 0))
            legend_rect = legend_text.get_rect(center=(self.window_size[0]//2, legend_y))
            legend_box = pygame.Rect(
                legend_rect.left - 10, 
                legend_rect.top - 5,
                legend_rect.width + 20,
                legend_rect.height + 10
            )
            pygame.draw.rect(self.window, (255, 255, 255), legend_box)
            pygame.draw.rect(self.window, (0, 0, 0), legend_box, 1)
            self.window.blit(legend_text, legend_rect)
            
            pygame.display.flip()
            self.clock.tick(self.metadata["render_fps"])
        
        return button_rects
    
    def _draw_buttons(self):
        # This method is now handled within _render_frame
        button_width = 80
        button_height = 30
        button_spacing = 10
        buttons_y = 100
        total_buttons_width = (button_width * 5) + (button_spacing * 4)
        start_x = (self.window_size[0] - total_buttons_width) // 2
        
        step_button = pygame.Rect(start_x, buttons_y, button_width, button_height)
        step10_button = pygame.Rect(start_x + button_width + button_spacing, buttons_y, button_width, button_height)
        reset_button = pygame.Rect(start_x + (button_width + button_spacing) * 2, buttons_y, button_width, button_height)
        decrease_button = pygame.Rect(start_x + (button_width + button_spacing) * 3, buttons_y, button_width, button_height)
        increase_button = pygame.Rect(start_x + (button_width + button_spacing) * 4, buttons_y, button_width, button_height)
        
        return step_button, step10_button, reset_button, decrease_button, increase_button
    def close(self):
        if self.window is not None:
            pygame.display.quit()
            pygame.quit()
def main():
    env = TreasureChestEnv(num_chests=5, render_mode="human")
    obs, _ = env.reset()
    
    running = True
    while running:
        step_button, step10_button, reset_button, decrease_button, increase_button = env._draw_buttons()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.MOUSEBUTTONDOWN:
                mouse_pos = event.pos
                if step_button.collidepoint(mouse_pos):
                    obs, reward, terminated, truncated, info = env.step()
                    print(f"Step +1: Reward={reward}, Max Diff={info['max_diff']}")
                    print(f"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}")
                elif step10_button.collidepoint(mouse_pos):
                    for _ in range(10):
                        obs, reward, terminated, truncated, info = env.step()
                    print(f"Step +10: Final Reward={reward}, Max Diff={info['max_diff']}")
                    print(f"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}")
                elif reset_button.collidepoint(mouse_pos):
                    obs, _ = env.reset()
                    print("Environment reset")
                    print(f"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}")
                elif decrease_button.collidepoint(mouse_pos) and env.num_chests > 2:
                    obs, _ = env.reset_with_new_chests(env.num_chests - 1)
                    print(f"Decreased to {env.num_chests} chests")
                    print(f"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}")
                elif increase_button.collidepoint(mouse_pos) and env.num_chests < 15:
                    obs, _ = env.reset_with_new_chests(env.num_chests + 1)
                    print(f"Increased to {env.num_chests} chests")
                    print(f"Gems: {tuple(env.gems.astype(int))}, Locks: {tuple(env.locks)}")
        env._render_frame()
    
    env.close()

if __name__ == "__main__":
    main()
\end{lstlisting}

\newpage
\clearpage


\subsubsection*{Problem 7}
\label{appendix:G_2023_IMO_Shortlist_C7}


\hrule
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em,
caption={IMO 2023 Shortlist problem 7 game code.},
label={listing:IMO2024SLC7}
]
import gym
from gym import spaces
import numpy as np
import networkx as nx
import math
from itertools import permutations
import pygame
import sys
import time

# Constants for visualization (optional)
WINDOW_WIDTH = 800
WINDOW_HEIGHT = 600
NODE_RADIUS = 20
EDGE_WIDTH = 2
FPS = 60

# Colors (optional)
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (180, 180, 180)
LIGHT_GRAY = (220, 220, 220)
TEXT_COLOR = (0, 0, 0)
HIGHLIGHT_COLOR = (255, 0, 0)

# Define a set of colors for companies (companies' colors)
COMPANY_COLORS = [
    (0, 255, 255),  # Cyan
    (0, 255, 0),  # Green
    (255, 165, 0),  # Orange
    (0, 0, 255),  # Blue
    (128, 0, 128),  # Purple
    (255, 192, 203),  # Pink
    (128, 128, 0),  # Olive
    (0, 128, 128),  # Teal
    (255, 215, 0),  # Gold
    (0, 0, 0),  # Black
    (255, 255, 255)  # White
]


class ImoniFerryLineEnv(gym.Env):
    metadata = {'render.modes': ['human']}

    def __init__(self, n, k, render=False):
        self.render_mode = render
        # Initialize Pygame only if rendering is enabled
        if self.render_mode:
            pygame.init()
            self.window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
            pygame.display.set_caption("IMO Gym Environment Visualization")
            self.clock = pygame.time.Clock()
            self.font = pygame.font.SysFont(None, 24)

        super(ImoniFerryLineEnv, self).__init__()
        self.n = n  # Number of islands (nodes)
        self.k = k  # Number of companies

        # Initialize the graph
        self.graph = nx.complete_graph(n)
        self.original_graph = self.graph.copy()

        # Assign initial colors
        self.assign_node_colors()
        self.assign_edge_colors()

        # Define action and observation space
        # Actions: Remove a company's edges or decide to terminate
        # Action k corresponds to deciding to terminate and make a prediction
        self.action_space = spaces.Discrete(k + 1)

        # Observation space: Adjacency matrix with company labels
        # Each edge can have k possible colors or -1 if removed
        self.observation_space = spaces.Box(low=-1, high=k - 1, shape=(n * n,), dtype=np.int32)

        # Initialize Pygame for visualization (optional)
        pygame.init()
        self.window = pygame.display.set_mode((WINDOW_WIDTH, WINDOW_HEIGHT))
        pygame.display.set_caption("IMO Gym Environment Visualization")
        self.clock = pygame.time.Clock()
        self.font = pygame.font.SysFont(None, 24)

        # Node positions
        self.positions = self._generate_node_positions()

        # Control variables
        self.removed_colors = []
        self.current_step = 0
        self.max_steps = k + 1  # Removing k companies and then deciding
        self.done = False

    def _generate_node_positions(self):
        # Position nodes in a circle
        center_x = WINDOW_WIDTH // 2
        center_y = WINDOW_HEIGHT // 2
        radius = min(WINDOW_WIDTH, WINDOW_HEIGHT) // 2 - 50
        positions = []
        for i in range(self.n):
            angle = 2 * np.pi * i / self.n
            x = center_x + int(radius * np.cos(angle))
            y = center_y + int(radius * np.sin(angle))
            positions.append((x, y))
        return positions

    def assign_node_colors(self):
        # Assign colors to nodes based on the formula (if needed)
        # Currently not used in observation; can be expanded
        self.node_colors = np.zeros(self.n, dtype=int)  # Placeholder

    def assign_edge_colors(self):
        # Assign colors to edges based on the colors of their incident nodes
        # For simplicity, assign colors sequentially
        self.edge_colors = {}
        for idx, (i, j) in enumerate(self.graph.edges()):
            color = idx % self.k  # Simple assignment
            self.edge_colors[(i, j)] = color

    def step(self, action):
        """
        Execute one time step within the environment.
        """
        if self.done:
            return self._get_obs(), 0, self.done, {}

        reward = 0
        info = {}

        if action < self.k:
            # Remove all edges of the selected company
            removed_company = action
            self.removed_colors.append(removed_company)
            edges_to_remove = [edge for edge, color in self.edge_colors.items() if color == removed_company]
            self.graph.remove_edges_from(edges_to_remove)
            self.current_step += 1
            print(f"Removed company {removed_company}, edges: {edges_to_remove}")

            # Check for Hamiltonian path after each removal
            has_path = self.has_hamiltonian_path()
            print(f"Hamiltonian Path Exists: {has_path}")
            # No immediate reward; reward is given upon termination
        elif action == self.k:
            # Decide to terminate and make a prediction about maximal k
            # Here, we'll simulate the agent's prediction
            # For simplicity, assume the agent predicts the current number of removed companies as k
            predicted_k = len(self.removed_colors)
            actual_k = self.k
            if predicted_k == actual_k:
                reward = 1  # Correct prediction
            else:
                reward = -1  # Incorrect prediction
            self.done = True
            print(f"Agent predicted k={predicted_k}, actual k={actual_k}, Reward: {reward}")
        else:
            raise ValueError("Invalid Action")

        obs = self._get_obs()

        return obs, reward, self.done, info

    def reset(self):
        """
        Reset the state of the environment to an initial state.
        """
        self.graph = self.original_graph.copy()
        self.removed_colors = []
        self.current_step = 0
        self.done = False
        return self._get_obs()

    def render(self, mode='human'):
        """
        Render the environment to the screen.
        """
        self.window.fill(WHITE)
        # Draw edges
        for i, j in self.graph.edges():
            color_index = self.edge_colors.get((i, j), -1)
            if color_index == -1:
                color = LIGHT_GRAY  # Removed edge
            else:
                color = COMPANY_COLORS[color_index % len(COMPANY_COLORS)]
            start_pos = self.positions[i]
            end_pos = self.positions[j]
            pygame.draw.line(self.window, color, start_pos, end_pos, EDGE_WIDTH)

        # Draw nodes
        for idx, (x, y) in enumerate(self.positions):
            node_color = COMPANY_COLORS[self.node_colors[idx] % len(COMPANY_COLORS)]
            pygame.draw.circle(self.window, node_color, (x, y), NODE_RADIUS)
            label = self.font.render(str(idx + 1), True, BLACK)
            label_rect = label.get_rect(center=(x, y))
            self.window.blit(label, label_rect)

        # Draw step information
        step_text = f"Step: {self.current_step}/{self.max_steps}"
        step_surface = self.font.render(step_text, True, TEXT_COLOR)
        self.window.blit(step_surface, (10, 10))

        # Display removed companies
        removed_text = f"Removed Companies: {self.removed_colors}"
        removed_surface = self.font.render(removed_text, True, TEXT_COLOR)
        self.window.blit(removed_surface, (10, 30))

        # Display instructions
        instructions = "Press ESC to exit."
        instructions_surface = self.font.render(instructions, True, TEXT_COLOR)
        self.window.blit(instructions_surface, (10, WINDOW_HEIGHT - 30))

        pygame.display.flip()
        self.clock.tick(FPS)
        self.handle_events()

    def close(self):
        """
        Clean up the environment.
        """
        pygame.quit()

    def _get_obs(self):
        """
        Return the current observation.
        """
        # Create an adjacency matrix with company labels
        adj_matrix = np.full((self.n, self.n), -1, dtype=int)
        for i, j in self.graph.edges():
            adj_matrix[i, j] = self.edge_colors.get((i, j), -1)
            adj_matrix[j, i] = self.edge_colors.get((j, i), -1)  # Ensure symmetry
        return adj_matrix.flatten()

    def has_hamiltonian_path(self):
        """
        Check if the current graph has a Hamiltonian path.
        """
        # For small n, this is feasible
        nodes = list(self.graph.nodes())
        for perm in permutations(nodes):
            if all(self.graph.has_edge(perm[i], perm[i + 1]) for i in range(len(perm) - 1)):
                return True
        return False

    def handle_events(self):
        """
        Handle Pygame events.
        """
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                self.close()
                sys.exit()
            elif event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    self.close()
                    sys.exit()

\end{lstlisting}
