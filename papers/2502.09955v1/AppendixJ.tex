\section{Autoformalization of Combinatorics Theorems in Lean}
\label{appendix:J}


\subsection*{2024 IMO}
\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Autoformalization for 2024 IMO Problem 5]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]

import Mathlib.Data.Finset.Basic
import Mathlib.Tactic

namespace IMO2024P5

/--
Coordinates on the board are given by a row index (0 < row < 2024)
and a column index (0 < col < 2023).
-/
structure Coords where
  row : Fin 2024
  col : Fin 2023

/--
A monster placement on the 2024x2023 board. There is exactly one monster
in each row except the first (row = 0) and the last (row = 2023), and
each column contains at most one monster.
-/
structure MonsterPlacement where
  /-- $monster c$ means there is a monster at the coordinates $c$. -/
  monster : Coords $\to$ Prop

  /--
  Exactly one monster in each "middle" row:
  for each row $r$ with $r \neq 0$ and $r \neq 2023$,
  there is exactly one column $c$ such that $monster (\langle r,c\rangle )$ holds.
  -/
  exactly_one_monster_per_row :
    $\forall$ r : Fin 2024,
      $r.val \neq 0 \land  r.val \neq 2023 \to
      \exists!$  (c : Fin 2023), $monster \langle r, c\rangle $

  /--
  Each column contains at most one monster:
  if $monster (\langle r_{1}, c\rangle )$ and $monster (\langle r_{2}, c\rangle )$, then $r_{1} = r_{2}$.
  -/
  at_most_one_monster_per_col :
    \forall (c : Fin 2023) (r_{1} r_{2} : Fin 2024),
      $monster \langle r_{1}, c\rangle  \to monster \langle r_{2}, c\rangle  \to r_{1} = r_{2}$

/--
Two board cells are adjacent if and only if they share a common side,
i.e., they lie in the same row with consecutive columns, or the same
column with consecutive rows.
-/
def adjacent (x y : Coords) : Prop :=
  (x.row = y.row $\land$  (x.col.val + 1 = y.col.val $\lor$ x.col.val = y.col.val + 1)) $\lor$
  (x.col = y.col $\land$  (x.row.val + 1 = y.row.val $\lor$ x.row.val = y.row.val + 1))

/--
An attempt is a finite path starting in row 0 and moving step-by-step
to adjacent cells. The attempt ends as soon as Turbo either encounters
a monster or reaches row 2023.
-/
structure Attempt where
  /-- The finite sequence of coordinates in the path. -/
  path : List Coords
  /-- The first cell is in the top row (row = 0). -/
  start_in_top : path.head?.map ($\cdot$.row.val) = some 0
  /-- Consecutive cells in the path are adjacent. -/
  steps_adjacent : $\forall$ (i : $\mathbb{N}$), i < path.length - 1 $\to$ adjacent (path.nthLe i (by linarith)) (path.nthLe (i+1) (by linarith))
  /-- The last cell is either in row 2023 (success) or contains a monster (failure). -/
  end_condition : (path.last?.map ($\cdot$.row.val) = some 2023)$ \lor$
                  $\exists$ c, path.last? = some c $\land$  False -- We'll refine to a monster condition below.

/--
We say that an attempt "hits a monster" in a given $placement$ if its last cell
contains a monster (i.e., Turbo is forced back to the top). Conversely, if
the last cell is in row 2023, Turbo successfully reaches the bottom row.
-/
def attempt_hits_monster (placement : MonsterPlacement) (A : Attempt) : Prop :=
  match A.path.last? with
  | none   => False  -- Empty path (not really allowed by the problem, but for completeness)
  | some c => placement.monster c $\land$  c.row.val $\neq$ 2023

def attempt_reaches_last_row (A : Attempt) : Prop :=
  match A.path.last? with
  | none   => False
  | some c => c.row.val = 2023

/--
A (high-level) strategy for Turbo up to $n$ attempts means: no matter how
the monsters are placed, Turbo can adapt each new attempt based on all
information learned so far (which cells are known to have monsters),
and is guaranteed to reach the last row by or before the $n$-th attempt.
-/
def TurboHasStrategy (n : $\mathbb{N}$) : Prop :=
  $\forall$ (placement : MonsterPlacement),
    -- "$\exists$ strategy" that guarantees success in $\leq$ n attempts,
    -- regardless of where the monsters are located.
    $\exists$ (attempts : Fin n.succ $\to$ Attempt),
      -- The idea is that each attempt can depend on the knowledge
      -- gained from previous attempts (which cells had monsters).
      -- We do not formalize that dependency here, but we require
      -- that by the final attempt, Turbo has reached row 2023.
      $\exists$ (k : Fin n.succ), attempt_reaches_last_row (attempts k)

/--
We denote by solution_value the minimum number of attempts $n$ such that
Turbo can guarantee reaching the last row in at most $n$ attempts, no matter
how the monsters are placed.
-/
abbrev solution_value : $\mathbb{N}$ := sorry

/--
Final statement of the problem: Determine (prove) the minimum $n$ such that
Turbo has a winning strategy on or before the $n$-th attempt, for any
valid monster placement.
-/
theorem snail_game :
  IsGreatest {n | TurboHasStrategy n} (solution_value) :=
sorry

end IMO2024P5
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=2024 IMO Problem 5 Back-translation]
\setlength{\parskip}{1em}
\textbf{Problem Statement.} Consider a \(2024\times 2023\) rectangular grid whose rows are numbered from \(0\) to \(2023\) and whose columns are numbered from \(0\) to \(2022\). In each of the rows \(1, 2, \ldots, 2022\), exactly one cell contains a monster, and no column contains more than one monster. (In other words, for each row \(r\in\{1,\dots,2022\}\) there is exactly one column \(c\) so that the cell \((r,c)\) contains a monster, and different rows never share the same monster column.)

Two cells \((r_1, c_1)\) and \((r_2, c_2)\) are said to be adjacent if either they lie in the same row and their column indices differ by exactly \(1\), or they lie in the same column and their row indices differ by exactly \(1\).

A single attempt is a path of cells \((r_0,c_0)\), \((r_1,c_1)\), \dots, \((r_k,c_k)\) such that:\\
1. The first cell of the path lies in the top row \(r_0=0\).\\
2. Every consecutive pair of cells in the path is adjacent. \\
3. Either the last cell of the path lies in the bottom row \(r_k=2023\), or else it is a cell containing a monster (in one of the rows \(1\) through \(2022\)).

We say an attempt reaches the last row if its final cell lies in row \(2023\), and it hits a monster if its final cell is a monster cell in some row from \(1\) to \(2022\).\\
Turbo's goal is to discover a path from the top row (\(r=0\)) to the bottom row (\(r=2023\)) that avoids all monsters. However, Turbo does not know in advance where the monsters are placed. After each attempt that hits a monster, Turbo learns (at least) which cell that final monster occupied, and can use this information in the next attempt to avoid or circumvent monsters.

Formally, we say Turbo has a strategy in at most \(n\) attempts if, for any arrangement of monsters satisfying the above conditions, Turbo can make at most \(n\) attempts, each possibly informed by the outcomes of the previous attempts, and ensure that at least one of those attempts reaches the bottom row. Denote by \(\mathrm{TurboHasStrategy}(n)\) the statement ``Turbo can guarantee success in at most \(n\) attempts.''

Let \(\textit{solution\_value}\) be the (optimal) number of attempts needed so that \(\mathrm{TurboHasStrategy}\bigl(\textit{solution\_value}\bigr)\) holds, and moreover no smaller number of attempts can always guarantee a successful path. Prove that \(\textit{solution\_value}\) is the greatest element of the set
\[
\{\,n \mid \mathrm{TurboHasStrategy}(n)\}.
\]

In other words, show that Turbo can indeed guarantee reaching the bottom row in \(\textit{solution\_value}\) attempts, and cannot do so (for all possible monster placements) in fewer.
\end{tcolorbox}

\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2024 IMO Problem 3]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]

import Mathlib.Tactic
import Mathlib.Data.Nat.Basic
import Mathlib.Data.Finset.Basic

namespace IMO2024P3

/--
An infinite sequence of positive integers indexed by natural numbers
starting from 1. We represent it as a function $a : \mathbb{N} \to \mathbb{N}$ with the
convention that $a(0)$ corresponds to $a_{1}$, $a(1)$ to $a_{2}$, and so on.
Thus, $a(n)$ represents $a_{n+1}$ in the original statement.
-/
def InfiniteSequence := $\mathbb{N} \to \mathbb{N}$

/--
We say that $a$ is *valid* with respect to a positive integer $N$ if for each
$n > N$, the value of $a(n)$ is the number of times $a(n - 1)$ appears in
the list $a(0), a(1), \dots, a(n - 1)$. In other words, for each $n > N$,
$a_{n+1}$ is the count of how many times $a_{n}$ appears in $a_{1}, a_{2}, \dots, a_{n}$.
-/
def valid_sequence (a : InfiniteSequence) (N : $\mathbb{N}$) : Prop :=
  $\forall$ (n : $\mathbb{N}$), n > N $\to$
    a n = (Finset.filter (fun k => a k = a (n - 1)) (Finset.range n)).card

/--
An infinite sequence $b$ is *eventually periodic* if there exist positive
integers $p$ and $M$ such that for all $m \geq M$, we have $b(m + p) = b(m)$.
-/
def eventually_periodic (b : InfiniteSequence) : Prop :=
  $\exists$ (p M : $\mathbb{N}$), p > 0 $\land$  $\forall$ m $\geq$ M, b (m + p) = b m

/--
Given an infinite sequence of positive integers $a$ (where $a(n)$ stands for
$a_{n+1}$), and a positive integer $N$ satisfying the condition that for
each $n > N$, $a_{n+1}$ is the number of times $a_{n}$ appears among
$a_{1}, a_{2}, \dots, a_{n}$, prove that at least one of the subsequences
$a_{1}, a_{3}, a_{5}, \dots$ and $a_{2}, a_{4}, a_{6}, \dots$ is eventually periodic.

In our indexing scheme:
- the "odd subsequence" corresponds to $a(0), a(2), a(4), \dots$
- the "even subsequence" corresponds to $a(1), a(3), a(5), \dots$
-/
theorem imo_new_problem
  (a : InfiniteSequence) (N : \mathbb{N}) (hpos : \forall n, a n > 0) (hvalid : valid_sequence a N) :
  eventually_periodic (fun m => a (2 * m)) \lor eventually_periodic (fun m => a (2 * m + 1)) :=
sorry

end IMO2024P3
\end{lstlisting}
\end{tcolorbox}

\subsection*{2024 USAMO}
\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2024 USAMO Problem 2]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Nat.Basic
import Mathlib.Tactic

namespace USAMO2024P2

/--
We have 100 finite sets of integers, $S_{1}, S_{2}, \dots, S_{100}$, with the following properties:

1. Their overall intersection is non-empty, i.e. ($\bigcap i, S_i$).Nonempty.
2. For every non-empty subset T of the indices {$0,1,\dots,99$} (representing a choice of sets),
   the cardinality of the intersection of S_{i} for $i \in T$ is a multiple of the number of sets in T.

We want to find the least possible number of elements that lie in at least 50 of these sets.
-/
structure GoodFamily (S : Fin 100 $\to$ Finset $\mathbb{Z}$) : Prop where
  nonempty_intersection : ($\bigcap i, S_i$).Nonempty
  multiple_property :
    $\forall$ (T : Finset (Fin 100)), T.Nonempty $\to$
      T.card | ($\bigcap$ (i : Fin 100) (_ : $i \in T), S_i$).card

/--
The number of elements that are contained in at least 50 of the sets $S_{i}$.
-/
def countInAtLeast50 (S : Fin 100 $\to$ Finset $\mathbb{Z}$) : $\mathbb{N}$ :=
  (SetOf fun (x : $\mathbb{Z}$) =>
    50 $\leq$ (Finset.univ.filter fun i : Fin $100 \Rightarrow x \in S_i$).card
  ).toFinset.card

/--
We denote by solution\_value the minimal possible value of countInAtLeast50 S
among all families of sets $S$ satisfying the above properties.
-/
abbrev solution_value : $\mathbb{N}$ := sorry

/--
Restatement of the problem: Determine (prove a formula or evaluate) the least possible
number of elements that lie in at least 50 of the sets S_{i}, subject to the given conditions.
-/
theorem USAMO2024P2 :
    IsLeast { c | $\exists$ (S : Fin 100 $\to$ Finset $\mathbb{Z}$), GoodFamily S $\land$  countInAtLeast50 S = c }
            (solution_value) := sorry

end USAMO2024P2
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2024 USAMO Problem 4]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Tactic
import Mathlib.Data.Fin.Basic
import Mathlib.Data.Finset.Basic
import Mathlib.Algebra.BigOperators.Basic

namespace USAMO2024P4

/--
A $necklace$ of length $N$ is given by a function from $Fin N$ to $Bool$
($true$ for red and $false$ for blue).
-/
structure necklace (N : $\mathbb{N}$) where
  color : Fin N $\to$ Bool

/--
For a necklace with $m * n$ beads (arranged circularly), a cut position
$s : Fin (m * n)$ partitions the necklace into $m$ blocks, each of length $n$.
Specifically, the $i$-th block (where $i : Fin m$) consists of the beads
whose indices range from $s + i * n$ to $s + i * n + n - 1$ (taken modulo $m * n$).
-/
def block_indices (m n : $\mathbb{N}$) (s : Fin (m * n)) (i : Fin m) : Finset (Fin (m * n)) :=
  -- The set of indices (mod m*n) belonging to the i-th block after a cut at s.
  Finset.image ($\lambda$ k : Fin n $\Rightarrow$ $\langle$ (s + i * n + k) % (m * n), sorry_proof$\rangle$ ) (Finset.univ)

/--
$block_red_count m n col s_i$ is the number of red beads in the $i$-th block
(after cutting at position $s$).
-/
def block_red_count (m n : $\mathbb{N}$) (col : necklace (m * n)) (s : Fin (m * n)) (i : Fin m) : $\mathbb{N}$ :=
  (block_indices m n s_i).filter (lambda x => col.color x).card

/--
We say that a given cut position $s$ has the "distinct-blocks" property
if, for that cut, each of the $m$ blocks has a *distinct* number of red beads.
-/
def distinct_blocks_for_cut (m n : $\mathbb{N}$) (col : necklace (m * n)) (s : Fin (m * n)) : Prop :=
  Function.Injective ($\lambda$ i : Fin m => block_red_count m n col s_i)

/--
The $distinct_blocks_property$ holds for a necklace if *every* cut position
produces $m$ blocks having distinct red-bead counts.
-/
def distinct_blocks_property (m n : $\mathbb{N}$) (col : necklace (m * n)) : Prop :=
  $\forall$ s : Fin (m * n), distinct_blocks_for_cut m n col s

/--
A pair $(m, n)$ is *admissible* if there exists a necklace of length $m * n$
such that no matter how we cut the necklace into $m$ consecutive blocks
of length $n$, each block has a distinct number of red beads.
-/
def admissible (m n : $\mathbb{N}$) : Prop :=
  $\exists$ (col : necklace (m * n)), distinct_blocks_property m n col

/--
**USAMO2024P4** :

"Let $m$ and $n$ be positive integers. A circular necklace contains $m * n$ beads,
each either red or blue. It turned out that no matter how the necklace was cut
into $m$ blocks of $n$ consecutive beads, each block had a distinct number of red beads.
Determine all possible values of the ordered pair $(m, n)$."

This theorem statement encodes: "Classify or determine all $(m, n)$ for which
an admissible necklace exists."
-/
theorem USAMO2024P4 (m n : $\mathbb{N}$) (hm : 0 < m) (hn : 0 < n) :
  admissible m n $\iff$ sorry :=
sorry

end USAMO2024P4
\end{lstlisting}
\end{tcolorbox}

\subsection*{2023 IMO Shortlist}
\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2023 IMO Shortlist Combinatorics Problem 1]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Tactic
import Mathlib.Data.Nat.Basic

namespace IMO2023SLC1

/--
A coin can be in one of two states: heads or tails.
We represent this by a simple inductive type.
-/
inductive CoinSide
| heads
| tails

open CoinSide

/--
Flip a coin from heads to tails or from tails to heads.
-/
def flip (c : CoinSide) : CoinSide :=
  match c with
  | heads => tails
  | tails => heads

/--
An $m\times n$ grid of coins, each coin has a row index $0 \leq r < m$
and a column index $0 \leq c < n$.
-/
structure Grid (m n : $\mathbb{N}$) where
  coin : Fin m $\to$ Fin n $\to$ CoinSide

/--
The initial configuration: every coin is tails.
-/
def initialGrid (m n : $\mathbb{N}$) : Grid m n :=
  { coin := fun _ _ => tails }

/--
Check whether every coin in the grid is heads.
-/
def allHeads {m n : $\mathbb{N}$} (g : Grid m n) : Prop :=
  $\forall$ (r : Fin m) (c : Fin n), g.coin r c = heads

/--
A move is defined by:
1. Selecting the top-left coordinate of a valid $2 \times 2$ square,
2. Flipping the coins in the top-left and bottom-right cells,
3. Choosing exactly one of the remaining two diagonal cells
   (top-right or bottom-left) to flip as well.

We capture this choice by storing:
- The row and column of the top-left corner of the $2 \times 2$ square,
- A boolean (or similar) to indicate which diagonal coin to flip.
  For example, if $diagFlip = true$, flip the top-right coin;
  otherwise, flip the bottom-left coin.
-/
structure Move (m n : $\mathbb{N}$) where
  (row : Fin (m - 1))
  (col : Fin (n - 1))
  (diagFlip : Bool)  -- true means flip top-right; false means flip bottom-left

/--
Apply a single move to a grid:
- Flip the coins at top-left $(row, col)$ and bottom-right $(row+1, col+1)$.
- Then flip exactly one of the coins at $(row, col+1)$ or $(row+1, col)$,
  depending on the boolean flag in the move.
-/
def applyMove {m n : $\mathbb{N}$} (g : Grid m n) (mv : Move m n) : Grid m n :=
  let row_{0} := mv.row
  let col_{0} := mv.col
  let flipDiag := mv.diagFlip

  -- Helper to flip exactly one cell
  let flipCell (r : Fin m) (c : Fin n) (g : Grid m n) : Grid m n :=
    { coin := fun r' c' =>
        if r' = r $\land$  c' = c
          then flip (g.coin r' c')
          else g.coin r' c' }

  -- Flip top-left
  let $g_{1}$ := flipCell $row_{0}$ $col_{0}$ g
  -- Flip bottom-right
  let $g_{2}$ := flipCell ($\langle row_{0} + 1, Nat.lt_of_lt_pred row_{0}.isLt\rangle$ )
                     (\langle col_{0} + 1, Nat.lt_of_lt_pred col_{0}.isLt\rangle )
                     $g_{1}$
  -- Flip either top-right or bottom-left
  if flipDiag then
    -- Flip top-right
    flipCell $row_{0} (\langle col_{0} + 1, Nat.lt_of_lt_pred col_{0}.isLt\rangle ) g_{2}$
  else
    -- Flip bottom-left
    flipCell ($\langle row_{0} + 1, Nat.lt_of_lt_pred row_{0}.isLt\rangle$ ) $col_{0} g_{2}$

/--
We say that it is "possible" to turn all coins heads-up if
there exists a finite sequence of valid moves that transforms
the $initialGrid$ (all tails) into a grid with $allHeads$.
-/
def possible (m n : $\mathbb{N}$) : Prop :=
  $\exists$ (moves : List (Move m n)),
    let finalGrid := moves.foldl (fun g mv => applyMove g mv) (initialGrid m n)
    in allHeads finalGrid

/--
Main theorem statement (to be proved):
Determine all pairs $(m, n)$ (with $1 < m$ and $1 < n$) for which
it is possible to obtain a configuration where every coin is heads
after a finite number of moves as described.

The actual classification of such $(m, n)$ is omitted here
and replaced by $sorry$. 
-/
theorem imoNewProblem (m n : $\mathbb{N}$) (hm : 1 < m) (hn : 1 < n) :
  possible m n $\iff$ -- "$\iff$" replaced with the actual condition describing all valid (m, n).
  sorry := sorry

end IMO2023SLC1
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2023 IMO Shortlist Combinatorics Problem 2]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Tactic
import Mathlib.Data.Fintype.Basic
import Mathlib.Data.Nat.Basic

namespace IMO2023SLC2

/--
A sequence of nonempty length $L$ in which the terms are given by $seq : Fin L \to \mathbb{N}$.
-/
structure IntSequence (L : $\mathbb{N}$) where
  seq : Fin $L \to \mathbb{N}$

/--
States that every term of the given sequence is a positive integer and is bounded above by $2^2023$.
-/
def is_positive_bounded {L : \mathbb{N}} (S : IntSequence L) : Prop :=
  $\forall$ i : Fin L, 0 < S.seq i $\land$  S.seq i $\leq 2^{2023}$

/--
States that there is no *consecutive* subsequence of $S$ (from index $i$ to $j$ with $i \leq j$)
and no choice of signs $\pm 1$ such that the signed sum of that subsequence is zero.
-/
def no_consecutive_zero_sum {L : \mathbb{N}} (S : IntSequence L) : Prop :=
  $\forall$ (i j : $\mathbb{N}$), $i \leq j \to j < L \to i < L \to$
   $ \neg \exists$ (sign : Fin (j - i + 1) $\to \mathbb{Z}$),
      ($\forall$ x, sign x = 1 $\lor$ sign x = -1) $\land $
      $\sum x$, sign x * S.seq $\langle i + x.val, by linarith\rangle  = 0$

/--
A sequence is *valid* if:

1. Every term is a positive integer bounded by $2^2023$.
2. There is no consecutive subsequence with a signed sum of zero.
-/
def is_valid_sequence {L : $\mathbb{N}$} (S : IntSequence L) : Prop :=
  is_positive_bounded S $\land$  no_consecutive_zero_sum S

/--
$maximal_length$ is the maximum possible $L$ for which there
exists a valid sequence of length $L$.
-/
def maximal_length : $\mathbb{N}$ :=
  sorry  -- to be determined

/--
The main statement: the maximal length of such a sequence is $maximal_length$.
-/
theorem determine_maximal_length :
  IsGreatest { L | $\exists$ S : IntSequence L, is_valid_sequence S } maximal_length :=
sorry

end IMO2023SLC2
\end{lstlisting}
\end{tcolorbox}


\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2023 IMO Shortlist Combinatorics Problem 3]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Data.Fintype.Card
import Mathlib.Tactic

namespace IMO2023SLC3

/--
A triangle of $n$ rows where the $i$th row contains exactly $i$ circles.
Exactly one circle in each row is colored red.
-/
structure Triangle (n : $\mathbb{N}$) where
  /--
  $red i$ is the index (from $0$ to $i-1$) of the red circle in the $i$th row,
  where rows are indexed by $i : Finset.Icc 1 n$. Note that $i.val$ is the
  natural number corresponding to the row index, hence we use $Fin i.val$.
  -/
  red : (i : Finset.Icc 1 n) $\to$ Fin i.val

/--
Helper function to move from row $i$ to row $i+1$ (when $i.val+1 $\leq$ n$).
-/
def next_row {n :$ \mathbb{N}$} (i : Finset.Icc 1 n) (h : i.val + 1 $\leq$ n) : Finset.Icc 1 n :=
  $\langle i.val + 1, h\rangle $

/--
A ninja-path in a triangle of $n$ rows is determined by choosing exactly
one circle from each row in such a way that if you are on circle $j$ in row $i$,
then the circle in row $i+1$ must be either $j$ or $j+1$.
-/
structure NinjaPath (n : $\mathbb{N}$) where
  /--
  For each row $i$, $steps i$ gives the index of the chosen circle
  in that row (index in $0..(i-1)$).
  -/
  steps : (i : Finset.Icc 1 n) $\to$ Fin i.val

  /--
  The path condition: from circle $steps i$ in row $i$, you can only move to
  circle $steps (i+1)$ in row $i+1$ whose index is either the same or one greater.
  -/
  steps_valid :
    $\forall$ (i : Finset.Icc 1 n) (h : i.val + 1 $\leq$ n),
      (steps i).val = (steps (next_row i h)).val $\lor$
      (steps i).val + 1 = (steps (next_row i h)).val

/--
$largest_k n$ will be the maximum number of red circles that a ninja-path
can always guarantee to pass through, regardless of how the single red circle
in each row is placed.
-/
abbrev largest_k (n : $\mathbb{N}$) : $\mathbb{N}$ :=
  sorry  -- This is where one would define or compute the exact value of k.

/--
Main statement: for any way of coloring one circle red in each row of an
$n$-row triangle, there is always a ninja-path containing at least $largest_k n$
red circles. Moreover, $largest_k n$ is the maximal such value satisfying
this universal condition.
-/
theorem find_max_red_circles (n : $\mathbb{N}$) :
    IsGreatest
      { k | $\forall$ T : Triangle n, $\exists$ p : NinjaPath n, k $\leq$ Fintype.card { i // T.red i = p.steps i } }
      (largest_k n) := sorry

end IMO2023SLC3
\end{lstlisting}
\end{tcolorbox}


\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2023 IMO Shortlist Combinatorics Problem 4]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Tactic

namespace IMO2023SLC4

/--
An arrangement of labels $1, 2, \dots, n^2$ into an $n \times n$ grid.
Here, $label i j$ is the integer in the $(i+1)$-th row and $(j+1)$-th column (0-based indexing in Lean),
and we require it to lie between $1$ and $n^2$.
-/
structure Arrangement (n : $\mathbb{N}$) where
  label : Fin n $\to$ Fin n \to \mathbb{N}
  label_range : $\forall$ i j, 1 $\leq$ label i j $\land$  label i j $\leq$ n^2
  /--
  The divisibility property: for each square in the $(i+1)$-th row and $(j+1)$-th column,
  $label i j - (i + j + 1 - 1)$ (which corresponds to $a_{i+1,j+1} - ( (i+1) + (j+1) - 1 )$
  in 1-based indexing) is divisible by $n$.
  -/
 end IMO2023SLC4
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2023 IMO Shortlist Combinatorics Problem 5]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Tactic
import Mathlib.Data.Finset.Basic
import Mathlib.Data.Nat.Basic

namespace IMO2023SLC5

/--
A configuration of the 2023 chests on a given day.

$\textbullet{}$ $gems i$ is the number of gems in chest $i$.
$\textbullet{}$ $unlocked$ is the set of chests that are unlocked.
-/
structure ChestConfig where
  gems : Fin 2023 $\to \mathbb{N}$
  unlocked : Finset (Fin 2023)

/--
Elisa's move: she must add a gem to one of the currently unlocked chests.
An "Elisa strategy" can be seen as a function that, given the current
configuration, selects an unlocked chest in which to place the new gem.
-/
abbrev ElisaStrategy := ChestConfig $\to$ Fin 2023

/--
Fairy's move: after Elisa places a gem, if more than one chest is unlocked,
the fairy locks exactly one of those unlocked chests. If there is exactly
one unlocked chest, the fairy unlocks all chests.
A "Fairy strategy" can be seen as a function that, given the current
configuration (after Elisa has placed her gem), decides which chest to lock
(or decides to unlock all, if only one is unlocked).
-/
abbrev FairyStrategy := ChestConfig $\to$ Option (Fin 2023)
/-
Interpretation of $FairyStrategy$:
$\textbullet{}$ If $fairy cfg = some c$, then the fairy locks chest $c$ (which must be in $cfg.unlocked$).
$\textbullet{}$ If $fairy cfg = none$, then the fairy unlocks all chests.
-/

/--
A valid transition from $cfg$ to $cfg'$ consists of:
1. Elisa places a gem in an unlocked chest $e$ chosen by her strategy.
2. If $cfg.unlocked$ had more than one chest, then the fairy locks exactly
   one unlocked chest $f$ chosen by its strategy. Otherwise, if there was
   exactly one unlocked chest, the fairy unlocks all chests.

This definition is just a *specification* of a one-step update rule; we do not
fully enforce correctness conditions here but illustrate how one might encode
them. In a full formal proof, we would ensure:
  - $e \in cfg.unlocked$
  - if $cfg.unlocked$ has card > 1, then $f \in cfg.unlocked$
  - if $cfg.unlocked$ has card = 1, then $f = none$ (unlock all)
etc.
-/
def valid_transition 
  (elisa : ElisaStrategy) (fairy : FairyStrategy)
  (cfg cfg' : ChestConfig) : Prop :=
let e := elisa cfg in
let f := fairy ($\langle$ fun i => if i = e then cfg.gems i + 1 else cfg.gems i,
                  cfg.unlocked$\rangle$ ) in
-- Construct $cfg'$ by adding Elisa's gem and applying the fairy's choice
cfg'.gems = fun i => if i = e then cfg.gems i + 1 else cfg.gems i
$\land$  match f with
  | some chest_to_lock =>
      cfg.unlocked.card > 1
      $\land$  cfg'.unlocked = cfg.unlocked.erase chest_to_lock
  | none =>
      cfg.unlocked.card = 1
      $\land$  cfg'.unlocked = Finset.univ
  end

/--
We say that an infinite sequence of configurations $s : \mathbb{N} \to ChestConfig$
respects strategies $(elisa, fairy)$ if each successive pair $(s n, s (n+1))$
is a valid transition using those strategies.
-/
def respects_strategies 
  (elisa : ElisaStrategy) (fairy : FairyStrategy)
  (s : $\mathbb{N} \to$ ChestConfig) : Prop :=
$\forall$ n : $\mathbb{N}$, valid_transition elisa fairy (s n) (s (n+1))

/--
A statement of the main property:

"There exists a constant $C$ such that Elisa can ensure, no matter how the
fairy acts, that for every pair of chests $i, j$ and for all times $t$,
the difference in the number of gems between chest $i$ and chest $j$
is at most $C$."

Formally, we assert the existence of:

$\textbullet{}$ A natural number $C$.
$\textbullet{}$ An Elisa strategy $elisa$.

such that for *every* fairy strategy $fairy$, if $s$ is an infinite sequence
of valid configurations (starting from all chests unlocked and empty) that
respects $(elisa, fairy)$, then for all times $t$ and all chests $i, j$,
we have $|s(t).gems i - s(t).gems j| \leq C$.
-/
theorem imo2023_chests :
  $\exists$ (C : $\mathbb{N}$) (elisa : ElisaStrategy),
    $\forall$ (fairy : FairyStrategy),
      $\forall$ (s : $\mathbb{N}$ $\to$ ChestConfig)
        (hstart : s 0 = 
          { gems := fun _ => 0,
            unlocked := Finset.univ } )
        (hrespect : respects_strategies elisa fairy s),
      $\forall$ (t :$ \mathbb{N}$) (i j : Fin 2023),
        (s t).gems i $\leq$ (s t).gems j + C
        $\land$  (s t).gems j $\leq$ (s t).gems i + C :=
sorry

end IMO2023SLC5
\end{lstlisting}
\end{tcolorbox}


\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2023 IMO Shortlist Combinatorics Problem 6]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Tactic
import Mathlib.Data.Finset.Basic

namespace IMO2023SLC6

/--
A coordinate in an N$\times$ N grid, with 0 $\leq$ row, col < N.
-/
structure GridCoords (N : $\mathbb{N}$) where
  row : Fin N
  col : Fin N

/--
A "right-down" adjacency between two cells means that the second cell
is either directly to the right (same row, next column) or directly
below (next row, same column) of the first.
-/
def is_adj_right_down {N : $\mathbb{N}$} (c_{1} c_{2} : GridCoords N) : Prop :=
  (c_{2}.row = c_{1}.row $\land$  c_{2}.col = c_{1}.col.succ) $\lor$
  (c_{2}.col = c_{1}.col $\land$  c_{2}.row = c_{1}.row.succ)

/--
A "right-down" path is a finite list of cells in the grid such that
each consecutive pair of cells satisfies $is_adj_right_down$.
-/
def is_right_down_path {N : $\mathbb{N}$} (p : List (GridCoords N)) : Prop :=
  $\forall$ i, i + 1 < p.length $\to$ is_adj_right_down (p.nthLe i (by simp)) (p.nthLe (i+1) (by simp))

/--
A "right-up" adjacency between two cells means that the second cell
is either directly to the right (same row, next column) or directly
above (previous row, same column) of the first.
-/
def is_adj_right_up {N : $\mathbb{N}$} ($c_{1} c_{2}$ : GridCoords N) : Prop :=
  $(c_{2}.row = c_{1}.row \land  c_{2}.col = c_{1}.col.succ) \lor
  (c_{2}.col = c_{1}.col \land  c_{1}.row = c_{2}.row.succ)$

/--
A "right-up" path is a finite list of cells in the grid such that
each consecutive pair of cells satisfies $is_adj_right_up$.
-/
def is_right_up_path {N : $\mathbb{N}$} (p : List (GridCoords N)) : Prop :=
  $\forall$ i, i + 1 < p.length $\to$ is_adj_right_up (p.nthLe i (by simp)) (p.nthLe (i+1) (by simp))

/--
A path that is either right-down or right-up.
-/
def is_rd_or_ru_path {N :$ \mathbb{N}$} (p : List (GridCoords N)) : Prop :=
  is_right_down_path p $\lor$ is_right_up_path p

/--
A partition of the N$\times$ N grid into a family of right-down or right-up paths means:
1. Every cell of the grid appears in exactly one path in the family.
2. Each path in the family is a right-down or right-up path.
-/
structure PartitionIntoPaths (N : $\mathbb{N}$) where
  paths : List (List (GridCoords N))
  covers  : ($\bigcup$ (p $\in$ paths) , p.toFinset) = 
              (Finset.univ : Finset (GridCoords N))
  disjoint : $\forall (p_{1} p_{2} \in paths), p_{1} \neq p_{2} \to 
               (p_{1}.toFinset \bigcap p_{2}.toFinset) = \emptyset$
  valid    : $\forall (p \in paths), is_rd_or_ru_path p$

/--
**The main theorem**: The cells of an N$\times$ N grid cannot be partitioned into
fewer than N right-down or right-up paths.
-/
theorem grid_partition_lower_bound (N : $\mathbb{N}$) (hN : 0 < N) :
  $\forall$ (P : PartitionIntoPaths N), P.paths.length $\geq$ N := by
  /-
    **Proof Sketch (to be completed):**
    1. Argue by contradiction: assume there is a partition with fewer than N paths.
    2. Derive a counting or combinatorial contradiction by examining rows/columns.
    3. Conclude that at least N paths are necessary.

    The details of the proof are omitted here; they would replicate the
    standard arguments from the original IMO-style solution.
  -/
  sorry

end IMO2023SLC6
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[enhanced, breakable, rounded corners,
    colback=green!5!white, colframe=green!75!black,
    colbacktitle=green!85!black, fonttitle=\bfseries, coltitle=white, title=Lean Theorem for 2023 IMO Shortlist Combinatorics Problem 7]
\setlength{\parskip}{1em}
\begin{lstlisting}[
language=Python, basicstyle=\scriptsize\ttfamily, numbers=left, breaklines=true, breakatwhitespace=true, xleftmargin=2em, xrightmargin=2em, aboveskip=1em, belowskip=1em, mathescape=true
]
import Mathlib.Tactic
import Mathlib.Combinatorics.SimpleGraph.Basic

/- 
  We formalize the Imomi archipelago problem:

  We have n $\geq$ 2 islands. Each pair of distinct islands has a unique ferry line 
  running in both directions, and each ferry line is operated by exactly one 
  of k companies. 

  It is known that if any one of the k companies closes all its ferry lines, 
  the resulting network no longer admits a route visiting each island exactly once 
  (i.e., no Hamiltonian path exists in that subgraph). 

  We want to determine the maximum possible number k of companies, in terms of n.
-/

namespace IMO2023SLC7

/--
A structure representing an assignment of ferry lines (edges in a complete graph on $n$ vertices)
to $k$ companies. Here, the function $company_of$ assigns each unordered pair of distinct islands
($Sym2 (Fin n)$) to one of the $k$ companies.

Additionally, we record the condition that if we remove from the complete graph all edges operated
by any one company, the resulting graph has no Hamiltonian path.
-/
structure Archipelago (n k : $\mathbb{N}$) where
  /-- Assignment of each unordered pair of distinct islands 
      to a company numbered in $Fin k$. -/
  company_of : Sym2 (Fin n) $\to$ Fin k

  /-- Condition: removing the edges of any single company destroys all Hamiltonian paths. 
      Formally, for each company $c$, the induced subgraph on edges not operated by $c$
      has no Hamiltonian path. -/
  no_hamiltonian_if_company_removed :
    $\forall$ c : Fin k,
      $\neg$ hasHamiltonianPath
        ((SimpleGraph.complete (Fin n)).spanningSubgraph
          (lambda e, company_of e $\neq$ c))

/--
$max_possible_k n$ is defined as the maximal number of companies $k$ such that there exists
an $Archipelago n k$ satisfying the above condition.
-/
abbrev max_possible_k (n : $\mathbb{N}$) : $\mathbb{N}$ := sorry

/--
The main statement of the problem: for each $n \geq 2$, the maximum number of companies in
such an archipelago is $max_possible_k n$. We leave $max_possible_k n$ as a $sorry$,
since determining its value is exactly the content of the problem.
-/
theorem imomi_archipelago (n : \mathbb{N}) (hn : 2 \leq n) :
  IsGreatest {k | \exists A : Archipelago n k, True} (max_possible_k n) :=
sorry

end IMO2023SLC7
\end{lstlisting}
\end{tcolorbox}