\section{Introduction}
\label{sec:intro}

%Copied from Svard
To ensure system robustness \agy{0}{(security, safety, and reliability)}, it is critical to maintain memory isolation: accessing a memory address should \emph{not} cause unintended side-effects on data stored \om{2}{in} other addresses~\cite{kim2014flipping}.
Unfortunately, with aggressive technology scaling, DRAM~\cite{dennard1968fieldeffect}, the prevalent main memory technology, suffers from increased \emph{read disturbance}: accessing (reading) a row of DRAM cells (i.e., a DRAM row) degrades the data integrity of other physically close but \emph{unaccessed} DRAM rows.\noCiteHardwareBasedMitigations{}\noCiteMcBasedRowHammerMitigations{}
RowHammer~\cite{kim2014flipping} is a prime example of DRAM read disturbance, where a row (i.e., victim row) can experience bitflips when at least one nearby row (i.e., aggressor row) is repeatedly activated (i.e., hammered)~\rhmemisolationrefs{} more times than a threshold, called the \gls{nrh}.
\emph{RowPress}~\cite{luo2023rowpress} is another prime example of DRAM read disturbance that amplifies the effect of RowHammer \ous{2}{by keeping an aggressor row open for longer, thereby causing more disturbance with each activation and consequently reducing} \gls{nrh}.

A simple way of mitigating DRAM read disturbance is to preventively refresh potential victim rows before bitflips occur.
Unfortunately, a preventive refresh blocks accesses to thousands of DRAM rows that are in the same DRAM bank for a non-negligible time window \ous{0}{(e.g., 350ns~\cite{jedec2024jesd795c})}, in which the memory controller should \emph{not} issue any other DRAM command \om{2}{to the bank}.
As DRAM chips become more vulnerable to read disturbance with technology node scaling, preventive refreshes can significantly reduce system performance~\refreshBasedRowHammerDefenseCitations{}. Therefore, it is important to accurately identify when a preventive refresh is needed and perform it \om{2}{in a timely manner}.
% Doing so comes at the cost of potential performance degradation~\refreshBasedRowHammerDefenseCitations{}.

To provide DRAM chips with the necessary flexibility to perform preventive refreshes in a timely manner, recent DRAM standards (e.g., DDR5~\cite{jedec2020jesd795, jedec2024jesd795c}) introduce 1) a command called \emph{\gls{rfm}}\cite{jedec2020jesd795} and 2) a \ous{0}{framework} called \emph{\gls{prac}}\cite{jedec2024jesd795c}.
\gls{rfm} is a command that provides the DRAM chip with a time window (e.g., \param{\SI{195}{\nano\second}}~\cite{jedec2024jesd795c}) to perform preventive refreshes.
Specifications before 2024 (e.g., \om{2}{earlier} DDR5~\cite{jedec2020jesd795}) advise the memory controller to issue \gls{rfm} when the number of row activations in a bank or a logical memory region exceeds a threshold (e.g., \param{32}~\cite{jedec2024jesd795c}), \om{2}{a mechanism we call} \emph{periodic RFM (PRFM)}.

A recent update \om{2}{(as of April 2024)} of the JEDEC DDR5 specification~\cite{saroiu2024ddr5, jedec2024jesd795c} introduces a new on-DRAM-die read disturbance mitigation \ous{0}{framework} called \gls{prac}.
\gls{prac} has two key features.
First, \gls{prac} maintains an activation counter per DRAM row~\cite{kim2014flipping} to accurately identify when a preventive refresh is needed.
\gls{prac} increments a DRAM row's activation counter while the row is being closed, which increases the latency of closing a row, i.e., the \gls{trp} and \gls{trc} timing parameters.
Second, \gls{prac} proposes a new \emph{back-off} signal to convey the need for preventive refreshes from the DRAM chip to the memory controller, similar to what prior works propose~\cite{bennett2021panopticon, devaux2021method, yaglikci2021security, hassan2022acase, kim2022mithril, hassan2024self}\omcomment{2}{also cite SMD MICRO'24, update reference blocks everywhere}\ouscomment{2}{ACK. Added SMD. TODO: Create and revise citation blocks}.
The DRAM chip asserts this back-off signal when a DRAM row's activation count reaches a critical value.
Within a predefined time window (e.g., \param{\SI{180}{\nano\second}}~\cite{jedec2024jesd795c}) after receiving the back-off signal, the memory controller has to issue an \gls{rfm} command so that the DRAM chip can perform the necessary preventive refresh operations.
\gls{prac} aims to
1) avoid read disturbance bitflips by performing necessary preventive refreshes in a timely manner and
2) minimize unnecessary preventive refreshes by accurately tracking each row's activation count.
Unfortunately, \emph{no} prior work rigorously investigates \gls{prac}'s security, performance, energy, and \ous{0}{storage} cost\nbcomment{0}{what cost? if you mean area/storage it is better to mention here. cost on its own doesn't mean much. it could mean \$s even.} \agy{0}{implications} for modern and future systems. 

\agy{0}{In this paper, we} 1)~present the first rigorous security, performance, energy, and \ous{0}{storage} cost\nbcomment{0}{:(} analyses of \gls{prac}, \agy{0}{which identifies \gls{prac}'s two major weaknesses} and
2)~propose a new mechanism, \X{}, which addresses \agy{0}{those} weaknesses.

\head{\gls{prac} Analysis}
We analyze \gls{prac} in \param{three} steps.
First, we define a security-oriented adversarial access pattern that achieves the highest possible activation count in systems protected by \gls{prac}.
Second, we conduct a security analysis by evaluating the highest possible activation count that a DRAM row can reach under different configurations of \gls{prac}.
Our security analysis shows that \gls{prac} can be configured for secure operation against an \gls{nrh} value of \param{20} or higher.
Third, we conduct a system performance analysis using cycle-accurate simulations with an open-source simulator, Ramulator 2.0~\cite{luo2023ramulator2, ramulator2github}.
Our system performance results across 60 different four-core multiprogrammed workload mixes show that:
At modern \gls{nrh} values higher than \param{1K}, \gls{prac}'s overheads are mainly dominated by the increased critical DRAM timing parameters where \gls{prac} incurs high average (maximum) \param{9.7}\% (\param{13.4}\%) system performance and \param{18.4\%} (\param{22.9\%}) DRAM energy overheads.
For the lowest secure \gls{nrh} value of \param{20}, these overheads increase to \param{81.2}\% (\param{91.9}\%) and \param{7.9x} (\param{8.7x}), respectively.\footnote{Our analysis rigorously sweeps \gls{nrh} to extremely low values (e.g., 20). \agy{2}{This is} because a mitigation mechanism that securely scales to low \om{2}{\gls{nrh} values} with low performance and energy overheads provides two benefits:
1)~activation counters maintain fewer bits, resulting in smaller hardware complexity and
2)~read disturbance profiling becomes significantly shorter as \om{2}{each} DRAM row can be tested for a \om{2}{smaller} hammer count (e.g., hammering the row 64 times takes $16\times$ shorter than hammering the row 1024 times).}

We attribute these large overheads to \param{two} key weaknesses \om{2}{in \gls{prac}}.
\ous{0}{First, \gls{prac} increases critical DRAM \ous{6}{timing} parameters due to the additional time required to increment activation counters.}
\ous{0}{Second, \gls{prac} performs a \ous{2}{fixed} number of preventive refreshes at a time and enforces a \emph{delay period} during which preventive refreshes \om{2}{\emph{cannot}} be requested, making it vulnerable to an adversarial \om{2}{access} pattern known as the \emph{wave attack}.}
% \gls{prac}
% 1) increases the critical latency parameters of DRAM due to the additional time required to increment counters and
% 2) \ous{0}{performs a constant number of preventive refreshes at a time} and enforces a \emph{delay period} during which preventive refreshes cannot be requested, making it vulnerable to \ous{0}{adversarial pattern} known as the \emph{wave attack}.

\head{\agy{0}{\X{}}}
To address PRACâ€™s two \om{2}{major} weaknesses, we propose \X{}.
\X{} 1)~updates row activation counters \om{2}{\emph{concurrently}} \ous{5}{while} serving accesses by \om{2}{physically} separating counters from the data and
2)~prevents the wave attack by dynamically controlling the number of preventive refreshes performed \ous{2}{by the memory controller} and removing the delay period \ous{2}{after the memory controller performs preventive refreshes}.\footnote{In Greek mythology, Cronus is renowned for separating heaven and earth~\cite{graf1993greek}, and Chronos for controlling time~\cite{graf1993greek}. We chose their blended name, Chronus, which resembles our proposal: separating counters (similar to Cronus separating worlds) and dynamically controlling the number of preventive refreshes (similar to Chronos controlling time).}

\head{Key Results}
We compare \X{} to 1)~\param{three} variants of PRAC, as the state-of-the-art industry solutions, and 2)~\param{three} other state-of-the-art \nb{0}{academic} proposals, i.e., Graphene~\cite{park2020graphene}, Hydra~\cite{qureshi2022hydra}, and PARA~\cite{kim2014flipping}.\omcomment{2}{Why do we not compare others like abacus, for example?}\ouscomment{2}{Maria was implementing modern mechanisms like Abacus and Comet. I contacted her and will push for more mechanisms.}
Our performance analysis shows that \X{} outperforms \emph{all} six evaluated mechanisms across all studied workloads and \gls{nrh} values.
\X{} incurs near-zero system performance (\ous{6}{$<$\param{0.1\%}} on average) and \param{relatively low (compared to \gls{prac})} DRAM energy (\param{10.3}\% on average) overheads for \ous{2}{modern} DRAM chips \om{2}{($\nrh{} =$ 1K)} and low system performance (\ous{6}{\param{8.3\%}} on average) and DRAM energy (\param{17.9\%} on average) overheads for future DRAM chips \om{2}{($\nrh{} =$ 20)}.

We make the following contributions:
\begin{itemize}
    [noitemsep,topsep=0pt,parsep=0pt,partopsep=0pt,labelindent=0pt,itemindent=0pt,leftmargin=*]
    \item We present the first security analysis of \om{2}{industry's state-of-the-art read disturbance solution, \gls{prac}}, and provide robust configurations against its worst-case access pattern.
    \item We rigorously evaluate the performance, energy, and cost implications of \gls{prac}'s different configurations for modern and future DRAM chips. Our results show that \gls{prac} incurs non-negligible overheads \nb{0}{due} to two \agy{0}{major} weaknesses: 1) increased critical DRAM timing parameters, and 2) wave attack vulnerability due to \om{2}{allowing only} a \ous{2}{fixed} number of preventive refreshes.
    %, even for DRAM chips with \gls{nrh} values higher than 1K, because it increases critical DRAM timing parameters.
    \item We propose \X{}, which addresses the weaknesses of \gls{prac} through \ous{0}{1) updating row activation counters concurrently \ous{5}{while} serving accesses by separating counters from the data and 2) preventing wave attacks by dynamically controlling the number of preventive refreshes as needed}. We show that \X{}'s system performance overhead is near-zero (very low) for modern (future) DRAM chips.
    % Our performance analysis shows that 
    % \X{} incurs near-zero system performance overhead for today's DRAM chips and has low system performance overhead for future DRAM chips.
    \item We compare \X{} against three variants of \gls{prac} and three state-of-the-art mitigation mechanisms. Our results show that 1)~\X{} outperforms all evaluated mitigation mechanisms at all evaluated \gls{nrh} values and 2)~\gls{prac} \ous{0}{variants} underperform against \param{three} of the \param{four} (including \X{}) mitigation mechanisms for modern DRAM chips with relatively high (i.e., $\geq$1K) \gls{nrh} values.
    \item To aid future research in a transparent manner, we open-source our implementations \om{2}{with Ramulator 2.0~\cite{chronusgithub}}.
\end{itemize}
%, and even denial of service attacks

%new text

% JEDEC's latest DDR5 specification~\cite{jedecddr5} introduces the \gls{rfm} command. This command allows the DRAM banks to have preventive operation periods depending on the incoming row activation rate.
% To do so, the memory controller keeps track of activation counts of each bank and issues the command whenever a counter reaches \gls{rfmth}. As a simple example, hammering a single row is ineffective against \gls{rfm} as a correctly configured system will refresh this aggressor row before it reaches \gls{nrh}. The system designer can choose \gls{rfmth} to be one less than \gls{nrh} and prevent this attack. However, a \param{two} phase attack can be conducted to cause bitflips for this trivial configuration.
% First, \param{two} rows are chosen where each row is activated $\frac{\gls{rfm}_{th}}{2}$ times and an \gls{rfm} command is triggered. As both rows have the same activations counts, the \gls{rfm} command will refresh the neighbors of an arbitrary row.
% Second, the row that has not been refreshed by the \gls{rfm} command is chosen and hammered \gls{rfmth} times.
% By doing so, a row activation count of $1.5\gls{rfm}_{th}$ is reached and the system security is compromised. It can be seen that a comprehensive analysis is required to understand the relation between a worst-case attack pattern and the \gls{rfmth} to reliably mitigate RowHammer bitflips with \gls{rfm}.

% \textbf{To this end}, we i) adapt the \emph{Wave Attack}~\cite{silverbullet} against the \gls{rfm} command, ii) mathematically analyze the relation of the attack parameters with the \gls{rfmth}, and iii) empirically show the performance impact of \emph{secure} \gls{rfmth} configurations as the \gls{nrh} decreases.