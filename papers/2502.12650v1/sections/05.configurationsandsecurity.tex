\section{Configuration of PRAC and Security Analysis}
\label{sec:configurationandsecurity}
This section investigates different \gls{rfm} and \gls{prac} configurations and their impact on security under the wave attack.

\head{Key Parameters}\ouscomment{4}{Moved before notation} We assume
a \emph{blast radius} of 2~\cite{kogler2022half},
a \gls{trc} of \SI{52}{\nano\second}~\cite{jedec2024jesd795c},
and a \gls{trfm} of \SI{350}{\nano\second}~\cite{jedec2024jesd795c}, which allows an RFM command to refresh four victim rows of one aggressor row.

\head{Notation} \agy{0}{$R_i$ is} the set of rows that the wave attack hammers in round $i$ \agy{0}{and $|R_{i}|$ is} the \ous{0}{number of rows in} $R_i$.

\head{PRFM}
In round 1, the wave attack \agy{0}{hammers each row in $R_1$ once, causing the memory controller to issue $\lfloor(|R_{1}|/\rfmth{})\rfloor$ \gls{rfm} commands, \ous{0}{each refreshing} \ous{0}{four} victims of one aggressor row.}
In round 2, the wave attack \agy{0}{hammers} the non-mitigated rows $R_2$, where $|R_2| = |R_1| - \lfloor ({|R_1|}/{\rfmth{}}) \rfloor$.
By repeating this calculation $i$ times, Equation~\ref{eqn:rfmrec} evaluates the number of non-mitigated rows at an arbitrary round $i$ ($|R_{i}|$). 

\vspace{-8pt}
\begin{equation}
\label{eqn:rfmrec}
|R_{i}| = |R_{1}| - 
\Bigl\lfloor
\frac{
\sum_{k=1}^{i-1} |R_{k}|
}{
RFM_{th}
}
\Bigr\rfloor
\end{equation}

\vspace{2pt}
To cause bitflips, the wave attack must make sure that 1) at least one aggressor row is not mitigated (i.e., its victims are \emph{not} refreshed by an RFM command until the end of round $N_{RH}$, i.e., $|R_{N_{RH}}| > 0$\nb{0}{)}, and 2) the time taken by the attacker's row activations and RFM preventive refreshes do \emph{not} exceed \gls{trefw}, i.e., aggressor's victims are \emph{not} periodically refreshed before being activated \gls{nrh} times.
We rigorously sweep the wave attack's parameters and identify the maximum hammer count of an aggressor row before its victims are refreshed.
% For an \gls{rfm}-only system to be secure against RowHammer bitflips it should not be possible for an attacker to obtain $|R_{N_{RH}-1}| > 0$ within \gls{trefw} for any $R_0$.
% Based on this observation, we perform an analysis of the maximum steps possible under a system with \gls{rfm} protection for varying \gls{rfmth} configurations and initial row set sizes.

\head{\gls{prac}-N}
We adapt our \gls{prfm} wave attack analysis to \gls{prac}-N by leveraging two key insights.
First, \gls{prac}-N mechanism will \emph{not} preventively refresh any row until a row's activation count reaches \glsfirst{aboth} \ous{4}{(i.e., the back-off threshold)}.\omcomment{4}{Is there a meaning to \gls{aboth}? i.e.,...}\ouscomment{4}{It is the back-off threshold. It is defined in PRAC's operation and parameters but added a reminder here to help reader follow easier.}
We prepare rows in $R_1$ such that each row is already hammered \gls{aboth}-1 times.
Doing so, the number of rounds necessary to induce a bitflip is reduced by \gls{aboth}-1.
Second, at least one row's activation counter remains above \gls{aboth} across \emph{all} rounds after initialization until the end of the wave attack.
This causes \gls{prac}-N to assert the back-off signal as frequently as possible, i.e., with a time period containing a recovery period ($\bonrefs\times\trfm$), a delay period (\gls{tbodelay}), and a window of normal traffic (\gls{taboact})~\cite{jedec2024jesd795c}.
Leveraging these insights, we update Equation~\ref{eqn:rfmrec} to derive Equation~\ref{eqn:pracrec}.
% activation counter

\vspace{-8pt}
\begin{equation}
\label{eqn:pracrec}
|R_{i}| = |R_{1}| - \bonrefs \times
\Bigl\lfloor
\frac{
\sum_{k=1}^{i-1} |R_{k}|
}{
(\bonacts + (\taboact / \trc))
}
\Bigr\rfloor
\end{equation}

\vspace{2pt}
For a \gls{prac}-N system to be secure,
an attacker should \emph{not} be able to obtain $|R_{\nrh{}-\aboth{}}| > 0$ within \gls{trefw} for any $R_1$.
We analyze the maximum hammer count of an aggressor row before its victims are refreshed in a \gls{prac}-N-protected system 
% under a system with \gls{prac}-N protection 
for a wide set of \gls{aboth} and $|R_{1}|$ configurations. 
% and initial row set sizes.

\head{Configuration Sweep}
\figref{fig:rfmpracanalysis} shows the maximum activation count an aggressor row can reach before its victims are refreshed (y-axis) for \gls{prfm} and \gls{prac}-N in \figsref{fig:rfmpracanalysis}a and~\ref{fig:rfmpracanalysis}b, respectively.
\figref{fig:rfmpracanalysis}a shows the bank activation threshold to issue an RFM command ($\rfmth{}$) on the x-axis and starting \om{4}{(i.e., round 1)} row set size ($|R_1|$) color-coded. \figref{fig:rfmpracanalysis}b shows the back-off threshold ($\aboth{}$)\omcomment{4}{NBO should have been defined and explained earlier in this section}\ouscomment{4}{Fixed with your comment above.} on the x-axis and $\bonrefs$ color-coded.
\ous{4}{In \figref{fig:rfmpracanalysis}b, each bar depicts the \om{5}{\emph{worst-case}} starting row set size (i.e., $|R_1|$ that yields the highest activation count)}.

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{figures/pracanalplot_combined.pdf}
\caption{Maximum activations to a row allowed by (a) \gls{prfm} and (b) \gls{prac}-N}
\label{fig:rfmpracanalysis}
\end{figure}

From \figref{fig:rfmpracanalysis}a, we observe that to prevent bitflips for very low \gls{nrh} values (e.g., 32 on the y axis), \gls{rfmth} should be configured to very low values (e.g., $<$4), as only such \gls{rfmth} values result in activation counts less than \gls{nrh} for all $|R_1|$ values.
From \agy{0}{\figref{fig:rfmpracanalysis}b}, we observe that \gls{prac}-N provides security at \gls{nrh} values as low as \param{20} (because a row can receive \param{19} activations as annotated) when configured to 1) trigger a back-off as frequently as possible ($N_{BO}=1$) and 2) issue \param{four} RFMs
in the recovery period (i.e., \gls{prac}-4).
For the remaining sections, we configure \gls{prfm} and \gls{prac} using these secure thresholds.\footnote{In this study, we assume that we can accurately determine \gls{nrh}. \gf{0}{However, that} is a difficult problem, as determining \gls{nrh} for every row has many challenges and a time-consuming process~\cite{kim2014flipping, orosa2021deeper, luo2023rowpress, kim2020revisiting, saroiu2022configure, olgun2023understanding, olgun2024read, zhou2023threshold, olgun2025variable}).}
We also assume that \gls{prac} \emph{borrows} time from periodic refreshes to transparently refresh the potential victims of one aggressor row every other periodic refresh command (\ous{5}{an operation we call \emph{borrowed refresh}}, as shown to be possible in modern DRAM chips~\cite{hassan2021utrr}), thereby reducing the number of back-offs needed.
We do \emph{not} consider periodic refreshes in our security analysis because the memory controller can potentially delay \ous{4}{a periodic refresh up to 4 times~\cite{jedec2024jesd795c}.\omcomment{5}{Did anyone publish a system level attack that exploits this fresh postponing?}\ouscomment{5}{Not that I am aware of. Also, this was reduced from 7 or 8 in DDR4 (?) to 4 in DDR5. I think this is a ``soft'' mitigation against RowPress. MINT (Moin's MICRO paper) discusses delayed refreshes as a problem though.}
These delays result in a maximum time between two consecutive $REF$ commands of $5*\trefi{}$ \ous{7}{(i.e., \SI{19500}{\nano\second} or 414 row activations for a single DDR5 bank with $\trc{} =$~\SI{47}{\nano\second})}\omcomment{7}{If 19500 was correct keep it as it was. Also, why e.g. for 414 activations?}\ouscomment{7}{It is correct (5 * 3900ns). I wrote e.g. because tRC could vary (also added what tRC I assumed and switched back to i.e.)}.
This large window where the DRAM cells \emph{cannot} be protected with a periodic refresh} significantly reduces the security of mechanisms that rely on borrowed refreshes.\omcomment{5}{Borrowed refresh is undefined? Also very odd terminology. Fix.}\ouscomment{5}{Acknowledged. Defined above.}