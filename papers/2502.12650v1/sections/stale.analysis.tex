\section{Attack Definition and Security Analysis}
\label{sec:analysis}

For our analysis, we assume that 1) the DRAM chips have perfect tracking, i.e., \gls{prac}, 2) the \gls{rfm} command always refreshes the victims of a row with the maximum activation counter, 3) the attacker can reverse engineer the logical to physical DRAM address translation, and 4) an attacker can deduce which row is refreshed internally for tie-breaker refreshes (i.e., an \gls{rfm} refresh between rows with the same activation counter).

We make \param{two} important observations from our trivial configuration analysis where the system designer chooses $\rfmth = \nrh - 1$.

\obs{obs:decoy}{An attacker can choose a set of rows as \emph{\agy{0}{decoy}} rows and boost other rows' maximum achievable activation counts.}

\obs{obs:ref}{An attacker should equally distribute their activations to the \emph{\agy{0}{decoy}} and \emph{real} attacker rows. By doing so, the attacker obtains new sets of rows with increasing activation counts.}

Based on these preliminary observations, we mathematically define our attack as \param{two} recurrences in Takeaway~\ref{tak:decoydef} and \ref{tak:recdef}.

\takeaway{tak:decoydef}{Selecting a set of rows of non-zero size $B_{i}$ with a minimum activation counters across these rows of $A_{i}$, and activating each row in $B_{i}$ once yields a new set of rows of size $B_{i+1}$ with activation counts $A_{i+1}$, where $B_{i+1} \leq B_{i}$ and $A_{i+1} = A_{i}+1$.}

\obs{obs:decoydefrec}{An attacker can start with an arbitrary set of rows of size $B_{0}$ and recursively attack the resulting sets of rows $B_{1}, B_{2}, ...\ B_{n}$ to achieve the increasing row activations of $A_{1}, A_{2}, ...\ A_{n}$.}

\obs{obs:decoydefatk}{A cold attack that starts with rows $B_{0}$ with $A_{0} = 0$ always has $A_{i} = i$ for all $i$ where $B_{i} > 0$.}

\takeaway{tak:recdef}{We know that i) each \gls{rfmth} activations cause an \gls{rfm} command, and ii) an attacker must perform $B_{k}$ activations to increase each row counter in the set by one to obtain $B_{k+1}$.}

\begin{equation}
\label{eqn:recinit}
B_{k+1} = B_{k} - \Bigl\lfloor
\frac{
R_{k} + B_{k}
}{
RFM_{th}
} \Bigr\rfloor
\end{equation}

Here, $R_{k}$ denotes the bank activation counter at the start of step $k$. We can sum the total activations from the initial state and avoid introducing the recurrence $R$ to our calculations.
By doing so, the size of the remaining rows at step $i$ ($B_{i}$) can be found with Equation~\ref{eqn:recdef}. Here, $B_{0}$ is the number of initial rows with no assumed activation counters (i.e., $A_{0} = 0$). Note that the $A_{0} = 0$ assumption simplifies our analysis per Observation~\ref{obs:decoydefatk}.

\begin{equation}
\label{eqn:recdef}
B_{i} = B_{0} - \Bigl\lfloor
\frac{
\sum_{k=0}^{i-1} B_{k}
}{
RFM_{th}
} \Bigr\rfloor
\end{equation}

Each row in a DRAM module is refreshed periodically independent of their activation rates to prevent data loss against retention.
Therefore, for a system to be secure against RowHammer bitflips under \gls{rfm} protection, the \gls{rfmth} should be selected such that an attacker should never be able to choose $B_{0}$ large enough to reach a $B_{i} > 0$ where $i \geq \nrh{}$.

\obs{obs:refduration}{Each row in a DRAM module is refreshed every \gls{trefw}.
This operation is performed by issuing a \gls{ref} command every \gls{trefi} and this command takes \gls{trfc} to complete.
The \gls{dallref} can be found with Equation~\ref{eqn:allref}.

\begin{equation}
\label{eqn:allref}
\dallref = \frac{\trefw{}}{\trefi{}} * \trfc
\end{equation}}

% \obs{obs:maxrfm}
{An \gls{rfm} command is triggered for every \gls{rfmth} activations and this command takes \gls{trfm} to complete.
We can access a bank as fast as \gls{trc}.
Therefore, \gls{trfmperiod} can be found with Equation~\ref{eqn:rfmperiod}.

\begin{equation}
\label{eqn:rfmperiod}
\trfmperiod = \rfmth * \trc + \trfm
\end{equation}

Given \gls{trfmperiod}, we calculate \gls{maxrfm} with Equation~\ref{eqn:maxrfm}.

% There is a syntax error somewhere here
% \begin{equation}
% \label{eqn:maxrfm}
% \maxrfm = \frac{\trefw - \dallref}{\trfmperiod}
% \end{equation}}

\takeaway{tak:maxact}{Based on Observations~\ref{obs:refduration} and~\ref{obs:maxrfm}, we derive the \gls{maxact} in Equation~\ref{eqn:maxact}.

\begin{equation}
\label{eqn:maxact}
\maxact = \maxrfm * \rfmth
\end{equation}

We can further unroll this equation to obtain it in terms of primitives, which yields Equation~\ref{eqn:maxactsimp}.

\begin{equation}
\label{eqn:maxactsimp}
\maxact = \frac{\trefw - \frac{\trefw}{\trefi} * \trfc}{\rfmth * \trc + \trfm} * \rfmth
\end{equation}}

An attack can only trigger a bitflip if it can reach $B_{\nrh{}} > 0$ within a refresh window. We formally define the security requirement of \gls{rfm} in Takeaway~\ref{lem:rhsecure}.

\takeaway{lem:rhsecure}{An \gls{rfm} protected system is secure against RowHammer bitflips if at least \param{one} of the \param{two} following conditions are true:
\begin{enumerate}
    \item $B_{\nrh{}} = 0$
    \item $\sum_{k=0}^{N_{RH}-1} B_{k} > \maxact$
\end{enumerate}}

Based on Takeaway~\ref{lem:rhsecure} we perform an analysis of the maximum steps possible under a system with \gls{rfm} protection for varying \gls{rfmth} configurations and initial row set sizes. Figure~\ref{fig:rfmkiller} presents the results of our analysis where the x-axis shows the different $\rfmth{}$ values, the y-axis shows the maximum achievable step $i$ where $B_{i} > 0$, and each bar identifies a different starting row set size ($B_{0}$).

% \begin{figure}[h]
% \centering
% \includegraphics[width=\linewidth]{figures/rfmkilleranalplot.pdf}
% \caption{Maximum possible activations on a row achievable with related to initial row set sizes and $\rfmth$.}
% \label{fig:rfmkiller}
% \end{figure}

We make \param{N} observations from Figure~\ref{fig:rfmkiller}.
First, configurations with $\rfmth < 6$ prevent bitflips even at a very low $\nrh=64$ against all $B_{0}$ as the necessary number of activations to reach $B_{\nrh}$ is greater than $\maxact$.
Second, the maximum $\rfmth$ value of \param{80}\footnote{
\gls{rfm} commands can be post-poned until the bank activation counter reaches 10x \gls{rfmth} in the standard. However, once this threshold is reached an \gls{rfm} command needs to be issued every \gls{rfmth}.}
defined in JEDEC DDR5 specitifaction~\cite{jedecddr5} does not provide sensitive configuration to systems with $\nrh > 512$.

\subsection{Extension to Alert Back-Off Protocol}
\label{sec:aboanalysis}

The recently introduced Alert Back-Off Protocol~\cite{jedecddr5} allows the DRAM module to request extra time from the memory controller to perform refresh management operations. With the \gls{abo} protocol, the memory controller continues operation for a set duration ($tABO_{ACT}$) before the recovery period and has a row activation budget (e.g., \param{4} ACTs) after the recovery period, where the DRAM module \emph{cannot} make another \gls{abo} request.

We extend our analysis to determine safe threshold configurations of the \gls{abo} protocol, such that an attacker \emph{cannot} activate a row enough times to induce a bitflip. We make \param{two} observations. First, we highlight the attack opportunities present in the protocol. Second, we explain how our \gls{rfm} security analysis can be extended to \gls{abo}.

\obs{obs:pracoppor}{There are \param{two} opportunities an attacker can exploit to increase their attack efficiency.
First, the module does not request an \gls{abo} until one of the rows reaches the \gls{aboth}. The attack can use this period to bring up attacker and decoy rows to some activation level.
Second, several row activations must be scheduled between consecutive \gls{abo}s. The attack can use this period to continue the wave attack.}

\obs{obs:rfmtoprac}{From Observation~\ref{obs:pracoppor}, an attacker can initially start with a set of rows with activation counts $\aboth{}-1$. Following this initialization, the first-row activation will cause an \gls{abo}, and every \param{$\aboact{}+\abodelay{}$} activations will be followed by \param{$\aboact{}$} refreshes. Based on our observation, we map this pattern to our earlier analysis where $\rfmth{}=\aboact{}+\abodelay{}$ and each RFM removing $\aboact{}$ rows.}

Based on Observation~\ref{obs:rfmtoprac} we derive the number of remaining rows at attack step $i$ ($B_i$) with Equation~\ref{eqn:pracstep}.

\begin{equation}
\label{eqn:pracstep}
B_{i} = B_{0} - \aboact{} * \Bigl\lfloor
\frac{
\sum_{k=0}^{i-1} B_{k}
}{
\aboact{} + \abodelay{}
} \Bigr\rfloor
\end{equation}

\takeaway{tak:pracsecure}{An \gls{abo} protected system is secure against RowHammer bitflips if at least \param{one} of the \param{two} following conditions are true:
\begin{enumerate}
    \item $B_{\nrh{}-\aboth{}+1} = 0$
    \item $(\sum_{k=0}^{\nrh{}-\aboth{}} B_{k}) + (\aboth{}-1 * B_0) > \maxact$
\end{enumerate}
The first condition states that no initial decoy row size will allow an attacker to perform \gls{nrh} activations on a row. As the attacker initializes each starting row, we reduce the necessary attack step to reach by $\aboth{}-1$.
The second condition states that even if a starting row size allows $\nrh{}$ activations on a single row, the necessary activations to initialize these rows and perform the wave attack should fit into a refresh window.}

\subsection{Under Attack}

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{figures/_fourcore_attack_scaling.pdf}
\caption{Attacker performance}
\label{fig:pracanalysis}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{figures/_fourcore_attack_energy.pdf}
\caption{Attacker energy}
\label{fig:pracanalysis}
\end{figure}

\begin{figure}[h]
\centering
\includegraphics[width=\linewidth]{figures/_fourcore_attack_latency.pdf}
\caption{Attacker latency}
\label{fig:pracanalysis}
\end{figure}
