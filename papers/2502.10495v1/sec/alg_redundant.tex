\begin{algorithm}[t]
\footnotesize
\caption{Key Channel Enhancement}
\label{alg:generate_key}
\textbf{Input:} $\mathbf{z}_T^k$: Latent noise in key channel, $\mathbf{k}$: Extracted key bits, $R$: Number of redundancies, $\mathcal{M}$: Mapping function \\
{\textbf{Output:} $\overline{\mathbf{z}}_T^{k}$: Latent noise with robust key}
\begin{algorithmic}[1]
\FOR{$r = 1$ {\bfseries to} $R$}
    \FOR{$m = 1$ {\bfseries to} $\text{len}(\mathbf{k})$}
        \STATE \textcolor{brown}{/*Find the latent noise corresponding to $k^r_m$*/}
        \STATE $(i, j, q) \gets \mathcal{M}(r \times M + m)$ 
        \STATE $k^r_m \gets 1$ \textbf{if} ${z}^k_{T, i, j, q} > 0$ \textbf{else} $0$
        \IF{$k^r_m \neq k_m$}
            \STATE \textcolor{brown}{/*Search for latent noise to swap*/}
            \STATE $p \gets m + 1$
            \WHILE{True}
                \STATE $(i', j', q') \gets \mathcal{M}(r \times M + p)$
                \STATE \text{new\_bit} $\gets 1$ \textbf{if} ${z}^k_{T, i', j', q'} > 0$ \textbf{else} $0$
                \IF{\text{new\_bit} $= k_m$}
                    \STATE \text{swap}(${z}^k_{T, i, j, q}$, ${z}^k_{T, i', j', q'}$)
                    \STATE \textbf{break}
                \ENDIF
                \STATE $p \gets p + 1$
            \ENDWHILE
        \ENDIF
    \ENDFOR
\ENDFOR
\STATE $\overline{\mathbf{z}}_T^{k} \gets \mathbf{z}_T^{k}$
\STATE {\bfseries return} $\overline{\mathbf{z}}_T^{k}$
\end{algorithmic}
\end{algorithm}
% \vspace{-0.6cm}

