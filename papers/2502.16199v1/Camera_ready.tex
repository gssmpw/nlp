\documentclass[10pt, conference, letterpaper]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
\usepackage{siunitx}
% \usepackage{hyperref}%hyper reference, should be placed before {pgfplot}
\usepackage{ifpdf}
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{booktabs} % For formal tables
\usepackage{verbatim}
\usepackage{graphics} % for pdf, bitmapped graphics files
\usepackage{epsfig} % for postscript graphics files\
\usepackage{tikz}
\usepackage{epstopdf}
\usepackage{subfigure}
\usepackage{balance}
\usepackage{comment}
\usepackage{booktabs}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage{colortbl}
\usepackage{tabularx}
\usepackage{color}
\usepackage{xspace}
\usepackage{graphicx}    % For importing graphics
\usepackage{url}         
\usepackage[ruled,vlined,linesnumbered,resetcount]{algorithm2e}
% \usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{placeins}
\usepackage{multirow}
\usepackage{caption}
\usepackage{enumitem}
\usepackage{leading}
\usepackage{pgfplots}
\usepackage{xcolor}
\usepackage{diagbox}
\usepackage{threeparttable}
\usepackage{makecell}

% \usepackage{hyperref}
\usepackage{mathtools}
\DeclareMathOperator*{\argmin}{arg\,min} 
\DeclareMathOperator*{\subjectto}{subject\,\,to} 
% \newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{proof}{Proof}
\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}


% % remove blank space around figure
% \setlength{\textfloatsep}{1pt}
% % space between text and image/table 
% \setlength{\intextsep}{1pt}
% % space between image and table 
% \setlength{\floatsep}{1pt}
% % remove white space between equations
% \setlength{\belowdisplayskip}{2pt} \setlength{\belowdisplayshortskip}{2pt}
% \setlength{\abovedisplayskip}{2pt} \setlength{\abovedisplayshortskip}{2pt}

% Yu change white space
% \captionsetup[figure]{font=small,labelfont=bf,skip=1pt}
% \captionsetup[subfigure]{font=small,labelfont=bf,skip=1pt}
% \captionsetup[table]{font=small,labelfont=bf,skip=1pt}

% Yu change white space
% \setlength{\abovecaptionskip}{2pt}
% \setlength{\belowcaptionskip}{2pt}
% \setlength{\textfloatsep}{2pt}

    
\newcommand{\sun}[1]{\textcolor[rgb]{1, 0, 1}{\textbf{#1}}}
\newcommand{\weitao}[1]{{\color{red} Weitao: #1}}
\newcommand{\huanqi}[1]{{\color{blue} Huanqi: #1}}
% \newcommand{\yu}[1]{{\color{yellow} Yu: #1}}
\newcommand{\SystemName}{\texttt{LLMKey}\xspace}




\begin{document}
\title{LLMKey: LLM-Powered Wireless Key Generation Scheme for Next-Gen IoV Systems}

\DeclareRobustCommand*{\IEEEauthorrefmark}[1]{%
  \raisebox{0pt}[0pt][0pt]{\textsuperscript{\footnotesize #1}}%
}
% \author{Anonymous Authors}
\author{\IEEEauthorblockN{Huanqi Yang\IEEEauthorrefmark{},
Weitao Xu\thanks{* Weitao Xu is the corresponding author.}\IEEEauthorrefmark{*}
}
% \IEEEauthorblockA{
% % Department of Computer Science\\
% \IEEEauthorrefmark{1}City University of Hong Kong Shenzhen Research Institute
% }
\IEEEauthorblockA{
\IEEEauthorrefmark{}Department of Computer Science, City University of Hong Kong
}
\vspace{-0.3in}
}
% \vspace{-0.3in}

\maketitle
\vspace{-0.3in}
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}
\pagestyle{empty}
% plain
\begin{abstract}
% due to noisy channel measurement and inefficient quantization process in LoRa networks. 
% Wireless key generation is a promising technology to establish a pair of cryptographic keys for wireless networks in a lightweight and information-theoretic secure way. 
% Despite much work in the literature, existing systems perform poorly in emerging LoRa networks due to its low data rate and long range communication feature. 
% We propose several novel methods to significantly improve the performance of \SystemName. (Yu: no need)
% we design a LoRa-specific channel characteristic that can provide fine-grained channel information. 
% overcome the limitation of existing quantization schemes, 
% since it is a lightweight and information-theoretic secure way
% Wireless key generation shows great potential for establishing cryptographic keys in Next-Gen IoV Systems. However, existing systems often suffer from inefficiencies and poor performance due to frequent channel probing and ineffective quantization. To bridge this gap, this paper proposes a novel key generation system, named \SystemName. We identify excessive channel probing and suboptimal quantization as the primary limitations. To enable efficient and secret probing, we propose a novel large language model (LLM)-based channel probing method that leverages the power of LLMs to reduce the number of probing rounds while preserving essential channel information. Rather than relying on conventional quantization, \SystemName employs a perturbed compressed sensing-based key delivery mechanism, enhancing both robustness and security. Evaluation in various real-world environments shows that \SystemName achieves an average key agreement rate of 98.78\%.
Wireless key generation holds significant promise for establishing cryptographic keys in Next-Gen Internet of Vehicles (IoV) systems. However, existing approaches often face inefficiencies and performance limitations caused by frequent channel probing and ineffective quantization. To address these challenges, this paper introduces \SystemName, a novel key generation system designed to enhance efficiency and security.
We identify excessive channel probing and suboptimal quantization as critical bottlenecks in current methods. To mitigate these issues, we propose an innovative large language model (LLM)-based channel probing technique that leverages the capabilities of LLMs to reduce probing rounds while preserving crucial channel information. Instead of conventional quantization, \SystemName adopts a perturbed compressed sensing-based key delivery mechanism, improving both robustness and security.
Extensive evaluations are conducted in four real-world scenarios, encompassing V2I (Vehicle-to-Infrastructure) and V2V (Vehicle-to-Vehicle) settings in both urban and rural environments. The results show that \SystemName achieves an average key agreement rate of 98.78\%, highlighting its effectiveness and reliability across diverse conditions.

% Moreover, we implement a \SystemName prototype and demonstrate that it can be executed in \SI{0.2}{\s}.
\end{abstract}

\begin{IEEEkeywords}
Physical layer key generation, large language model, Internet of Vehicles
\end{IEEEkeywords}

\section{Introduction}
\label{intro}
\subsection{Background and Limitations}
The Internet of Vehicles (IoV) has rapidly evolved to facilitate seamless connectivity between various entities in vehicle networks, aiming to enhance urban transportation, minimize accidents, and bolster traffic surveillance. This technology's pervasive nature has drawn significant interest. As shown in Fig.~\ref{fig:v2x}, IoV integrates diverse objects using wireless communication methods, supporting multiple interaction models such as vehicle-to-vehicle (V2V) and vehicle-to-infrastructure (V2I).


Aforementioned Vehicle-to-everything (V2X) frameworks necessitate the frequent exchange of critical real-time data, including speed and location, across vehicles and essential infrastructure components over wireless channels. Safeguarding this data transmission is paramount to maintaining the integrity of vehicular systems and ensuring passenger safety. For instance, adversaries can intercept communications and compromise control units by decoding passcodes, potentially causing catastrophic outcomes or fatalities~\cite{hasrouny2017vanet}. Consequently, the need for robust key establishment processes has become important, allowing two authenticated nodes to create a secure key over public channels. However, conventional approaches like public key infrastructure (PKI) and pre-shared key (PSK) are inadequate for IoV networks due to two primary factors: 1) the transient and highly dynamic nature of IoV systems makes sustained PKI availability impractical; 2) PSK methods are rigid, difficult to scale, and susceptible to theft by malicious actors. The inherently mobile and decentralized characteristics of IoV present significant challenges for secure key generation and management.

\begin{figure}
	\centering
	\includegraphics[width=3in]{figure/IoV_llmkey.pdf}
	\caption{IoV communication scenarios.}
	\label{fig:v2x}
	\vspace{-0.25in}
\end{figure}

To address the limitations discussed earlier, physical layer key generation leveraging channel reciprocity has gained traction as a viable method for establishing secure cryptographic keys between two IoV communication nodes. This approach is based on the concept that certain channel properties, such as the Received Signal Strength Indicator (RSSI), will exhibit similarity at both ends if data packets are exchanged within the channel's coherence time~\footnote{Coherence time refers to the period during which the channel remains relatively stable}~\cite{jana2009effectiveness}.
However, the necessity for long-distance communication restricts the applicability of many short-range wireless technologies (e.g., WiFi, Zigbee) in generating secret keys for IoV environments. LoRa, a widely-used low-power wide-area network (LPWAN) technology, offers a compelling alternative by enabling long-range communication suitable for IoV key generation. Despite recent advancements in this area~\cite{junejo2021lora,ruotsalainen2019experimental,xulorakey,yang2022vehicle,jiayaoipsn}, our investigation highlights two critical and unresolved challenges:

\textbf{(1) Excessive channel probing process.}
Physical-layer key generation relies heavily on repeated channel probing, requiring both legitimate parties to exchange numerous probing packets over multiple rounds to measure the channel characteristics based on the principle of channel reciprocity. To derive a 128-bit cryptographic key, the nodes must transmit a sufficient volume of effective packets. However, this process is not only energy-intensive for communication nodes but also increases the risk of eavesdropping by malicious actors. As a result, the current channel probing methods fail to deliver both energy efficiency and robust security for physical-layer key generation in IoV networks.


\textbf{(2) Inefficient quantization process.} 
Once channel measurements are collected, the subsequent step is quantization, which translates these measurements into binary values. Despite the development of various quantization techniques~\cite{junejo2021lora,ruotsalainen2019experimental,xulorakey,yang2022vehicle,jiayaoipsn}, the process remains inherently lossy and susceptible to errors~\cite{xi2016instant}. As a result, key generation systems relying on quantization may require a higher volume of packet exchanges to gather sufficient channel data, often necessitating an additional reconciliation phase to correct errors. This, in turn, can compromise system efficiency and diminish overall robustness.



% ~\cite{junejo2021lora,ruotsalainen2019experimental,xulorakey,yang2022vehicle,jiayaoipsn}
% To address these new challenges, a number of efforts have been made recently. The received signal strength indicator (RSSI) (i.e., channel characteristic) based method with quantization \cite{xulorakey} has been proposed to present the feasibility of physical-layer key generation in LoRa networks, but the number of keys extracted by RSSI is limited due to course-grained channel characteristic. To improve the key generation rate, a register RSSI based method \cite{jiayaoipsn} has been proposed, but the achieved key generation rate is still relatively low (e.g., \SI{13.8}{bits\per\second} only). Hence, we reveal that the following two fundamental challenges remain unsolved.
% For example, LoRa-Key~\cite{xulorakey} is the first work that comprehensively studies the feasibility of physical layer key generation in LoRa networks; 
% however, their solution can only extract limited number of keys due to the use of course-grained channel characteristic (i.e., received signal strength indicator (RSSI)). 
% Gao. \textit{et al.}~\cite{jiayaoipsn} proposed to use register RSSI to improve the key generation rate, but they achieved \SI{13.8}{bits\per\second} key generation rate only. 
% To overcome the limitation of traditional quantization method, Vehicle-Key~\cite{yang2022vehicle} designed a deep learning-based quantization model to improve the key generation rate for LoRa-enabled Internet of Vehicles (IoV), but its key generation rate (only \SI{15}{bits\per\second}) is still insufficient to meet the demand of secure IoV communication, where high-speed vehicles need to exchange information with other vehicles or road side unites frequently. 
% After literature review, we find two fundamental limitations of existing methods.

% \textbf{(1) Coarse-grained and noisy channel measurement}

% Physical-layer key generation is based on channel reciprocity, which indicates the two communication parties will have highly correlated channel measurements if the channel can be probed within the channel coherence time. Therefore, accurate and fine-grained channel measurement is the basis for efficient key generation. Unfortunately, the commonly used physical-layer characteristics for LoRa networks is RSSI~\cite{xulorakey, junejo2021lora}, which can only provide coarse-grained channel information. Some recent works~\cite{jiayaoipsn, yang2022vehicle} utilize register RSSI to improve the granularity of wireless channel, but the register RSSI measurements are still noisy~\cite{jiayaoipsn}. Therefore, existing channel indicators cannot provide sufficient and accurate information for physical-layer key generation in LoRa networks.

% \textbf{(2) Inefficient quantization process} 

% In most physical-layer key generation systems, after obtaining channel measurements, the next step is quantization which converts channel measurements into binary bits (i.e., 1 or 0). Although a variety of quantization mechanisms have been proposed~\cite{junejo2021lora,ruotsalainen2019experimental,xulorakey,yang2022vehicle,jiayaoipsn}, the quantization process is inherently lossy and error-prone \cite{xi2016instant}. Due to noisy channel measurement and the low data rate of LoRa networks~\cite{ren2022lorawan}, the quantization-based key generation system may need to exchange more packets to obtain more channel information and run an additional information reconciliation process to partially fix errors. Hence, it may further lead to system inefficiency and lack of robustness. 
% The above noisy channel measurement problem and the low data rate feature of LoRa networks further exacerbate the inefficiency and lack of robustness using existing quantization methods. As a result, the key generation system needs to exchange more packets to obtain more channel information and run additional information reconciliation process to fix the errors, which incurs high energy consumption and computational cost.


\subsection{Contributions}
In this paper, we design and implement a novel physical layer key generation system for IoV networks named \SystemName, which essentially addresses the above challenges.
% ~\footnote{Soteria: goddess of safety and deliverance from harm in Greek mythology.}

% To enable energy-efficient and secure channel probing, we propose a LLM enabled skipped channel probing  and channel information recover method. Inspired by the growing potential of LLMs to improve data management and operational efficiency in smart transportation systems, The objective is to investigate and understand the inferential and reconstructive capabilities of LLMs by providing them with skipped channel measurement data along with a basic prompt in the cloud. The cloud feeds the skipped data into the LLM, enabling the generation of precise and efficient reconstructions of the original channel measurement data.
To achieve energy-efficient and secure channel probing, we propose an large language model (LLM)-enabled skipped channel probing and channel information recovery method. Drawing inspiration from the increasing potential of LLMs to enhance data management and operational efficiency in smart transportation systems~\cite{yang2024transcompressor}, our goal is to explore the inferential and reconstructive capabilities of LLMs. By providing skipped channel measurement data and a simple prompt to the cloud, the LLM processes this input to generate accurate and efficient reconstructions of the original channel measurements. This approach minimizes the need for excessive probing, reducing energy consumption and enhancing security in IoV networks.
% \sun{To enable fine-grained channel sampling, we take a closer look at the CSS modulation of LoRa physical layer. Given the finding that every chirp in LoRa packet has a constant amplitude, we plan to leverage them to indicate the channel state.}
% To enable fine-grained channel sampling, we take a closer look at the CSS modulation of LoRa's physical-layer.
% In our preliminary study, we reveal that every chirp modulated in sender has a constant amplitude, which can be utilized to indicate channel state. 
% Our insight is to divide a LoRa packet into multiple chirps and calculate the fine-grained changes of chirps.
% Following this idea, we propose a LoRa-specific channel measurement named Chirp-Level Signal Strength Indicator (CLSSI) by analyzing the changes of the chirp units in LoRa packets.
% Different from packet-level RSSI, chirp-level CLSSI contains much richer channel information in the same period of time because each LoRa packet contains tens of chirps. 
% Additionally, due to the half-duplex mode (i.e., asynchronous channel sampling) of LoRa transceivers, channel information may be missed which impairs the channel reciprocity.
% However, the problem of missing channel information due to the half-duplex mode of LoRa transceivers impairs channel reciprocity.
% Fortunately, with sufficient channel information provided by CLSSI, we observe that the missing channel information can be practically estimated. Therefore, we design a channel state estimation algorithm by adopting a lightweight spline fitting method, and the estimated CLSSI provides an accurate and comprehensive measurement of wireless channel.
% To the best of our knowledge, this is the first chirp-level feature for LoRa signal.

To tackle the second challenge, we adopt a Perturbed Compressed Sensing (PCS)-based key delivery technique, recently introduced as an efficient way to transmit secret keys between devices~\cite{yang2023chirpkey}. This approach utilizes PCS to facilitate key delivery by accommodating slight discrepancies between the matrices of the sender and receiver. We leverage channel measurements—similar yet not identical data—to construct these matrices, where one matrix compresses the secret key and the other decompresses it.
By eliminating the need for quantization and information reconciliation, this method enhances both system efficiency and robustness in secret bit agreement. Unlike traditional quantization-based approaches, the secret key is generated through a random key generator, allowing for the creation of highly random and secure keys.

% quantization issue -> cs could robustly work, but security issue may raise -> we use PCS features match to our question, leading to efficiency + robustness -> since pcs requires two different matrices (i.e., the similar but not the same, tiny difference) for security, our chirp-level channel measurement can provide the required information, hence our benefits
% is suitable 
% \huanqi{
% To address the second challenge, we propose a novel Perturbed Compressed Sensing (PCS) based key delivery method that can efficiently deliver a secret key generated by one LoRa device to another. Inspired by the success of compressed sensing theory, our initial idea is to deliver the compressed key and reconstruct it on the receiver side directly using compressed sensing with fair robustness. However, since standard compressed sensing requires the same measurement matrix to be pre-shared by Alice and Bob, using channel measurements may not be able to construct the matrix, hence it may fail to apply in our work.
% % while the attacker may intercept the matrix to crack the key~\cite{yang2015security}, hence it may raise critical security concerns. a l robustness and security, 
% Alternatively, we leverage PCS for the design of key delivery. Since PCS accepts the tiny difference between the matrices of sender and receiver, we intuitively use the channel measurements (i.e., similar but not the same channel information) to construct the matrices, where one matrix is used for compressing the secret key and another matrix is used for decompressing the key. 
% % resulting in notable security improvement. 
% In particular, due to decoupling the need for quantization and information reconciliation process, the proposed method is able to effectively achieve system efficiency and robustness for secret bit agreement. Moreover, different from the quantization-based methods, since the secret key is obtained from a random key generator, \SystemName can build a key with strong randomness.
% % (i.e., avoiding keys with low entropy).



% as PCS considers the tiny difference between the matrices of sender and receiver, and we can use the similar but not the same channel measurements of Alice and Bob to generate the matrices. 
% Therefore, we propose a novel PCS-based method to successfully deliver the secret key in a secure way. The key idea of this method is to use channel measurements to construct two matrices, where one matrix is used for compressing the secret key and another matrix is used for decompressing the key. 
% The proposed PCS-based key delivery method eliminates the need of quantization and information reconciliation process. 
% Therefore, our method is efficient and robust for secret bit agreement. 
% Moreover, instead of generating binary keys from channel measurements directly, the secret key to be delivered is obtained from a random key generator. Therefore, \SystemName can always build a key with strong randomness and avoid keys with low entropy.
% }

% The key idea xxx perturbed compressed sensing (PCS) + PCS features match to our question, leading to efficiency + robustness
% However, it is non-trivial to achieve a balance between robustness and security.
% traditional pcs leads to xxx issue.
% our idea is 

% how to use PCS
% The key idea of this method is to use the similar but not the same channel measurements to construct two matrices, where one matrix is used for compressing the secret key and another matrix is used for decompressing the key.

% While the idea seems simple, it is non-trivial to achieve a balance between robustness and security. 

% Inspired by the success of compressed sensing theory, we propose a novel perturbed compressed sensing (PCS)-based method to successfully deliver the secret key in a secure way. 
% The proposed PCS-based key delivery method eliminates the need of quantization and information reconciliation process. 
% Therefore, our method is efficient and robust for secret bit agreement. Moreover, instead of generating binary keys from channel measurements directly, the secret key to be delivered is obtained from a random key generator. Therefore, \SystemName can always build a key with strong randomness and avoid keys with low entropy.}



% With the above novel solutions, \SystemName presents three unique advantages over existing methods. First, different from RSSI, our new channel feature CLSSI contains much richer channel information in the same period of time. Therefore, it can significantly improve the key generation rate. Second, the proposed PCS-based key delivery method eliminates the need of quantization and information reconciliation process. Therefore, our method is efficient and robust for secret bit agreement. Third, instead of generating binary keys from channel measurements directly, the secret key to be delivered is obtained from a random key generator. Therefore, \SystemName can always build a key with strong randomness and avoid keys with low entropy.

We conduct extensive evaluations in both V2I and V2V settings in both urban and rural environments. Results show that \SystemName achieves a high matching rate. 
In summary, this paper makes the following contributions.
% \begin{itemize}[leftmargin=*,noitemsep,topsep=0pt]
%     \item We propose \SystemName, a novel physical-layer key generation scheme for IoV networks. \SystemName addresses two key limitations in existing work and enables fast and secure physical-layer key generation.
%     \item We propose a novel fine-grained channel state indicator, named CLSSI. Compared to existing channel indicators, CLSSI can provide fine-grained and accurate channel state information. To improve the integrity of channel information, we propose a lightweight channel state estimation method to comprehensively recover the channel information.
%     \item We propose a novel PCS-based key delivery scheme to deliver secret keys. Compared to existing quantization-based solutions, the proposed method improves the robustness significantly. We demonstrate the security of the proposed scheme via rigorous proof and extensive evaluation.
%     \item We conduct extensive experiments to evaluate \SystemName in different real environments. Results show that \SystemName achieves an average key matching rate of 99.58\% and a key generation rate of \SI{13}{bits} per measurement. Compared to the state-of-the-arts, \SystemName improves key matching rate and key generation rate by 11.03--26.58\% and 27--49$\times$, respectively. Results also show that it takes less than \SI{0.2}{\s} to generate a 128-bit key and incurs low power consumption.
    
% \end{itemize}
\begin{itemize}
    \item We propose the first LLM-powered physical-layer key generation scheme, enhancing the accuracy, security, and efficiency of secret key generation in IoV systems.
    \item \SystemName demonstrates that LLMs can act as zero-shot reconstructors of channel measurement data, effectively interpreting and recovering information without the need for fine-tuning or domain-specific training.  
    \item We conduct extensive experiments to evaluate \SystemName in different real environments. Comprehensive evaluations show that our system can achieves an average key agreement rate of 98.78\%.
\end{itemize}

% The rest of the paper is organized as follows. We discuss the related work in Sec.~\ref{sec:Background}. We present the system model in Sec.~\ref{sec:model}. We present the design details in Sec.~\ref{sec:signal} and Sec.~\ref{sec:key}. Then, we evaluate the \SystemName in Sec.~\ref{sec:eva} and conclude the paper in Sec.~\ref{sec:conclusion}.




\section{Related Work}
\label{sec:Background}
% This section discusses three aspects of related work: wireless key generation, compressed sensing, and LoRa security.
\subsection{Large language models}
% Recent advancements in LLMs have dramatically advanced artificial intelligence and natural language processing. LLMs such as OpenAI's GPT-3 and Meta's LLaMA 2~\cite{touvron2023llama} have shown exceptional capabilities in generating coherent and contextually relevant narratives, handling complex tasks such as multilingual translation, query responses, and code generation.
% Historically, the development of neural language models (NLMs)\cite{arisoy2012deep} and early LLMs like GPT-2\cite{radford2019language} and BERT~\cite{devlin2018bert} 
% set foundational milestones. 
% The development of these models has progressively featured enhanced complexity and capabilities, as exemplified by PaLM~\cite{chowdhery2023palm} and GPT-4.
% Zero-shot generalization has significantly enhanced the utility of LLMs as assistants, prompting the development of methods aimed at aligning LLMs with human preferences and instructions. 
% In this study, we demonstrate that the zero-shot generalization capabilities of LLMs and their preference towards compressible patterns are not limited to language understanding but can also be effectively applied to transportation sensor data.
Recent breakthroughs in large language models (LLMs) have significantly propelled advancements in artificial intelligence and natural language processing. Models like OpenAI's GPT-3 and Meta's LLaMA 2~\cite{touvron2023llama} have demonstrated remarkable proficiency in producing contextually appropriate and coherent text, excelling in tasks such as multilingual translation, question answering, and code generation.
The evolution of neural language models (NLMs)\cite{arisoy2012deep}, alongside earlier LLMs like GPT-2\cite{radford2019language} and BERT~\cite{devlin2018bert}, laid the groundwork for these advancements. Over time, language models have grown in sophistication and capability, as seen with more recent models like PaLM~\cite{chowdhery2023palm} and GPT-4~\cite{achiam2023gpt}.
% A key factor in enhancing the versatility of LLMs is their ability to generalize in zero-shot scenarios, driving the development of techniques to align these models with human intentions and preferences.

\subsection{Wireless Key Generation} 

% Wireless key generation has received considerable attention over the past decades. In the literature, a large volume of systems have been proposed for different wireless technologies, such as Wi-Fi~\cite{xi2016instant, liu2013fast}, Zigbee~\cite{Aonowireless2005}, and Bluetooth~\cite{premnath2014secret}. In these studies, researchers have used a variety of physical-layer features, including Channel State Information (CSI) \cite{xi2016instant, liu2013fast}, RSSI \cite{yang2022vehicle, jiayaoipsn}, and phase \cite{wang2011fast}. For example, TDS \cite{xi2016instant} exploited Wi-Fi CSI as channel characteristics to generate keys for mobile devices. 
% To enhance the channel reciprocity of CSI, Liu \textit{et al.}~\cite{liu2013fast} leveraged channel response in multiple Orthogonal Frequency-Division Multiplexing (OFDM) subcarriers, coupled with a Channel Gain Complement (CGC) scheme for key generation. 
Wireless key generation~\cite{zhang2016key} has attracted significant interest over the past few decades. Numerous systems have been developed across various wireless technologies, including Wi-Fi~\cite{xi2016instant, liu2013fast}, Zigbee~\cite{Aonowireless2005}, LoRa~\cite{zhang2018channel, ruotsalainen2019experimental, xulorakey, jiayaoipsn, yang2022vehicle}, and Bluetooth~\cite{premnath2014secret}. Researchers have explored diverse physical-layer attributes, such as Channel State Information (CSI)\cite{xi2016instant, liu2013fast}, Received Signal Strength Indicator (RSSI)\cite{yang2022vehicle, jiayaoipsn}, and phase~\cite{wang2011fast}.
For instance, TDS~\cite{xi2016instant} utilized Wi-Fi CSI to derive cryptographic keys for mobile devices by leveraging channel characteristics. To further improve CSI reciprocity, Liu et al.~\cite{liu2013fast} employed channel responses from multiple Orthogonal Frequency-Division Multiplexing (OFDM) subcarriers. This approach was complemented by a Channel Gain Complement (CGC) scheme to facilitate more reliable key generation.

\subsection{LLMs for Time Series Analysis}
The application of LLMs to time series tasks has garnered increasing attention from researchers. For instance, TIME-LLM repurposed an existing LLM for time series forecasting while maintaining the original architecture of the language model~\cite{jin2023time}. 
% This approach reformatted time series data into textual prototypes, allowing for alignment between textual and time series representations.
Similarly, LLMTIME~\cite{gruver2024large} leveraged pretrained LLMs for continuous time series prediction by encoding numerical values as text and generating forecasts through text-based completions. However, this method primarily focuses on the temporal dimension, overlooking spatial dependencies in the data.
To address spatial considerations, GATGPT integrated a graph attention network with GPT to perform spatio-temporal imputation~\cite{chen2023gatgpt}. 
Furthermore, researchers have explored the use of LLMs for interpreting sensor data to facilitate real-world sensing~\cite{ji2024hargpt,yang2024you,yang2024transcompressor}.

% \subsection{LLMs for Time Series}

% Several researchers have investigated the potential of using LLMs for time series applications. 
% For example, TIME-LLM adapted an existing LLM for time series forecasting while preserving the original language model structure~\cite{jin2023time}. The model reprogrammed the input time series as text prototypes, facilitating alignment between text and time series modalities.
% LLMTIME~\cite{gruver2024large} harnessed pretrained LLMs for continuous time series forecasting by representing numerical values in textual format and generating extrapolations through text completions. This model, however, only addresses the temporal dimension of the data, neglecting spatial aspects.
% GATGPT combined the graph attention network with GPT for spatial-temporal imputation~\cite{chen2023gatgpt}, enhancing the LLM's ability to understand spatial dependencies, though it somewhat neglects the temporal aspects. Besides, some researchers propose to use LLMs to understand sensor data to sense the physical world~\cite{ji2024hargpt,yang2024you,yang2024transcompressor}. 
% However, these methods, designed specifically for time series forecasting and understanding, are not suitable for transportation sensor data compression and reconstruction. Therefore, we propose \SystemName—a system that can effectively reconstruct compressed sensor data by leveraging the extensive knowledge base of LLMs.



% LoRa is an emerging wireless communication technology designed specifically for long-range and low-power communications. The low data rate and long airtime feature of LoRa bring new research challenges. To address these challenges, several key generation systems for LoRa networks have been proposed in recent years. For example, LoRa-Key~\cite{xulorakey} is the first RSSI-based key generation method for LoRa. In their follow-up research~\cite{jiayaoipsn}, a variant RSSI feature, register RSSI, is exploited, which can provide finer granularity of channel sampling for key generation. 
% Recently, Yang \textit{et al.}~\cite{yang2022vehicle} utilized the mean value of adjacent rRSSI (arRSSI) of LoRa signals for key establishment on Internet of Vehicles (IoV) scenarios. 
% However, the performance of these systems is limited because of the use of coarse-grained channel characteristics and inefficient quantization mechanism. Our work differs from existing studies in two aspects. First, we propose a novel LoRa-specific channel characteristics that can provide fine-grained channel state information. Second, we propose a novel PCS-based key delivery method instead of using quantization-based key generation methods.  

% \textbf{Compressed Sensing.} 
% Compressed sensing is a signal processing technique used to reconstruct signals efficiently by finding solutions for underdetermined linear systems. In addition to data compression, it can also  be applied in IoT security schemes \cite{dautov2013establishing, xue2017kryptein}. For example, 
% H2B~\cite{lin2019h2b} used a compressed sensing-based reconciliation method to correct key mismatches due to the low SNR of the heartbeat interval signals. Additionally, Kryptein~\cite{xue2017kryptein} proposed a compressed sensing-based encryption method to enable secure data queries for cloud-enabled IoT systems. Dautov \textit{et al.}~\cite{dautov2013establishing} explored the feasibility of constructing secure compressed sensing matrices based on wireless physical-layer security.
% These existing works apply compressed sensing to different IoT security scenarios, which inspires this paper to pioneer the use of a compressed sensing framework for wireless key generation. Unlike existing studies that used standard compressed sensing techniques for IoT security, our work uses the perturbed version of compressed sensing for the physical-layer key generation, which is more practical in real-world applications.


% \textbf{LoRa Security.}
% With massive deployments of LoRa networks, the security issues have attracted significant efforts~\cite{li2022lora, sun2022recent, hou2022cloaklora,hou2021jamming}, with an emphasis on key management, authentication, and physical-layer key generation. 
% For key management, existing works mainly focus on the derivation, distribution, and destruction process of application layer keys, including DevNonce~\cite{tomasin2017security} and NwkSKey~\cite{kim2017dual}. 
% Additionally, researchers have exploited different features of LoRa signals resulted from hardware imperfections for device authentication purpose, such as carrier frequency offset~\cite{wang2020slora}, amplitude-phase~\cite{al2021deeplora}, and signal spectrogram~\cite{shen2021radio}. 
% However, such methods generally suffer from heavy computation cost and poor scalability. 
% Thus, key generation has emerged as a promising solution for secure wireless communication due to its high energy efficiency and prior-free requirements compared with the aforementioned schemes. In this paper, we propose a novel secret key generation scheme to provide robust and lightweight key establishment for LoRa networks.

\begin{figure*}
    \centering
    \includegraphics[width=5.5in]{figure/overview_llmkey.pdf}
    \caption{System workflow.}
    \label{fig:workflow}
    \vspace{-0.3in}
\end{figure*}

\section{System Model}
\label{sec:model}
% This section presents the user model and attack model.
% \subsection{User Model}
% We assume there are two devices in a LoRa network, namely Alice and Bob,  that intend to agree on the same key to safeguard their communication. They are both embedded with LoRa communication modules, with no prior sharing of secrets. They follow the work-flow in Fig.~\ref{fig:workflow} to generate keys step by step. In the first phase, they measure the channel by exchanging a number of probe and response packets. Then both Alice and Bob start key generation phase, which includes skipped channel probing, channel recover, perturbed measurement matrix generation, key compression and reconstruction, and privacy amplification. Finally, the key is used to encrypt/decrypt data to ensure secure communication.
In an IoV network, we consider two devices, Alice and Bob, aiming to establish a shared key to secure their communication. Both devices are equipped with LoRa communication modules, and no pre-shared secrets exist between them. They follow the process outlined in Fig.~\ref{fig:workflow} to generate cryptographic keys step by step. This process involves skipped channel probing, LLM-based channel recovery, perturbed measurement matrix generation, key compression and reconstruction, and privacy amplification. Notably, the LLM-based recovery and key reconstruction are performed using a server-based API service, which is a reasonable assumption due to the server's enhanced computational capabilities and robust security protocols.
Once the key is successfully generated, it is applied to encrypt and decrypt data, ensuring secure communication between the two devices.





% \textbf{LPWAN compatibility.} 

% \begin{figure}
%     \centering
%     \includegraphics[width=2.0in]{figure/clcsi_original.pdf}
%     \caption{Received packets of Alice and Bob. \footnotesize{The left figure shows the channel variance for each half of Alice and Bob due to non-simultaneous sampling, respectively. The right figure zoom in a chirp of Bob.}}
%     \label{fig:clcsi_ori}
%     \vspace{-0.2in}
% \end{figure}



% \vspace{-0.2in}

% 

\section{System Design}
\label{sec:signal}
% This section presents the proposed fine-grained channel indicator and a channel state estimation method to improve channel reciprocity.
% \subsection{Skipped Channel Probing}
% This technique involves sampling only a specified fraction \( \alpha \) of the total data points collected. For example, if \( \alpha = 0.1 \), the system will sample every tenth data point.
% The number of data points collected, \( n_{\text{collected}} \) of sequence \( S_{A} \) and \( S_{B} \) can be calculated as:
% \[
% n_{\text{collected}} = \lfloor \alpha \cdot n_{\text{total}} \rfloor,
% \]
% where \( n_{\text{total}} \) is the total number of data points that would have been collected without skip sampling, and \( \lfloor \cdot \rfloor \) denotes the floor function, which rounds down to the nearest whole number.
% Skip sampling effectively decreases the burden on both the data storage systems and the bandwidth required for transmitting data to the cloud. This reduction is crucial for efficient and cost-effective system operations, especially in large-scale or real-time applications like traffic monitoring and autonomous vehicle navigation, where sending all data to the cloud in real-time may not be feasible.
\subsection{Skipped Channel Probing}
Channel probing is a critical process for measuring channel characteristics, which forms the foundation for key generation in wireless communication systems. In \SystemName, we utilize adjacent rRSSI (arRSSI)~\cite{yang2022vehicle} as the channel indicator. Skipped channel probing involves randomly performing probing for only a specified fraction \( \alpha \) of the total potential probing instances. For example, if \( \alpha = 0.1 \), approximately 10\% of the total possible probing instances are executed, while the rest are skipped randomly.
The number of probing instances performed, \( n_{\text{probed}} \), for sequences \( S_{A} \) and \( S_{B} \) can be calculated as:
\[
n_{\text{probed}} = \lfloor \alpha \cdot n_{\text{total}} \rfloor,
\]
where \( n_{\text{total}} \) represents the total number of potential probing instances, and \( \lfloor \cdot \rfloor \) denotes the floor function, rounding down to the nearest whole number.
Skip channel probing effectively reduces the overhead of frequent probing, alleviating the load on communication channels and conserving energy. This technique enhances efficiency, particularly in resource-constrained environments and large-scale deployments, by maintaining sufficient channel information without excessive probing.


% \subsection{Data Rescaling}
% Once the selectively sampled data reaches the cloud, it undergoes a process of rescaling. The goal of rescaling is to prepare the data for processing and analysis by ensuring that it conforms to a standard scale. Specifically, we rescale the data to the range between 0 and 1.
% The formula for rescaling a data value \( x \) from its original range \([x_{\text{min}}, x_{\text{max}}]\) to the range \([0, 1]\) is given by:
% \[
% x_{\text{scaled}} = \frac{x - x_{\text{min}}}{x_{\text{max}} - x_{\text{min}}},
% \]

% After rescaling, the data undergoes a further process to retain only two decimal places. This truncation is performed to reduce the lengths of tokens, improving efficiency for LLMs. Truncated data is then ready to be fed into LLMs. The truncation can be mathematically represented as:
% \[
% x_{\text{truncated}} = \left\lfloor 100 \cdot x_{\text{scaled}} \right\rfloor / 100 ,
% \]
% where \( \left\lfloor \cdot \right\rfloor \) denotes the floor function, ensuring that the value is truncated to two decimal places.
\subsection{Data Rescaling}
After the selectively probed channel data is collected, it undergoes rescaling to prepare for further processing and analysis. The rescaling process ensures the data conforms to a standard scale, enhancing consistency and compatibility with subsequent operations. Specifically, the channel data sequences \( S_{A} \) and \( S_{B} \) are rescaled to the range \([0, 1]\).  
The rescaling of a data value in \( S_{A} \) or \( S_{B} \), originally in the range \([S_{\text{min}}, S_{\text{max}}]\), is performed using the following formula:  
\[
S_{\text{scaled}} = \frac{S - S_{\text{min}}}{S_{\text{max}} - S_{\text{min}}},
\]
To optimize the data for lightweight processing by LLMs, the rescaled values are truncated to retain only two decimal places. This reduces the token length, enhancing efficiency and reducing computational overhead. The truncation process is defined as:  
\[
S_{A\text{truncated}} = \left\lfloor 100 \cdot S_{A\text{scaled}} \right\rfloor / 100,
\]
\[
S_{B\text{truncated}} = \left\lfloor 100 \cdot S_{B\text{scaled}} \right\rfloor / 100,
\]
where \( \left\lfloor \cdot \right\rfloor \) represents the floor function, ensuring the value is truncated at two decimal places.  
The truncated and rescaled data sequences \( S_{A\text{truncated}} \) and \( S_{B\text{truncated}} \) are subsequently ready for input into LLMs, preserving essential information while maintaining efficiency in resource-constrained environments.  



\subsection{LLM-based Channel Information Recovery}
To recover the skipped channel measurements, we employ an LLM to reconstruct the arRSSI data for Alice and Bob.
The relationship between the input data and the LLM's output can be mathematically expressed as follows:
\[
S_{A}^{\prime} = \text{LLM}(S_{A\text{truncated}}), S_{B}^{\prime} = \text{LLM}(S_{B\text{truncated}}),
\]
where \( S_{A\text{truncated}} \) and \( S_{B\text{truncated}} \) represents the truncated version of the data, as described in the previous sections. The function \( \text{LLM} \) encapsulates the processing capabilities of the LLM, which computes the output \( S_{A}^{\prime} \) and \( S_{B}^{\prime} \) based on the input data.
% The structure of our prompt, as illustrated in Fig.~\ref{fig:prompt}, adopts an elegantly minimalist design. It starts with a straightforward instruction that primes the LLM to tap into its specialized repository of knowledge on channel measurement data. This is followed by a probing question that provides detailed context regarding the data acquisition process, the sequence of channel measurement data, and the specific type of channel measurement.
% The prompt concludes with a directive to the LLM: "Do not say anything like 'the decompressed sequence is', just return the decompressed sequence." This approach is strategically chosen to ensure the output is clear and uncluttered, facilitating straightforward interpretation and analysis.
The structure of our prompt, as depicted in Fig.~\ref{fig:prompt}, follows a clean and concise design. It begins with a simple instruction that directs the LLM to draw from its knowledge of channel measurement data. Next, a question is presented, offering detailed context about the data collection process, the sequence of measurements, and the specific type of channel information involved.
The prompt concludes with a clear directive: "Do not say anything like 'the decompressed sequence is', just return the decompressed sequence." This deliberate phrasing ensures that the output remains streamlined and easy to interpret, minimizing unnecessary text and enhancing clarity for seamless analysis.

Fig.~\ref{fig:reconstruct} showcases the reconstruction results achieved using the LLM-based recovery method. The figure demonstrates that as the probing ratio $\alpha$ increases from 0.5 to 0.9, the accuracy of channel measurement data reconstruction significantly improves. This improvement can be attributed to higher probing ratios, which preserve more original data and reduce information loss during skipped probing, resulting in more precise reconstructions. Furthermore, the correlation between Alice and Bob post-recovery remains comparable to that of the original data.

\begin{figure}
    \centering
    \includegraphics[width=0.83\linewidth]{figure/prompt_llmkey.pdf}
    \caption{Chain-of-thought prompt design for \SystemName.}
    \label{fig:prompt}
    \vspace{-0.2in}
\end{figure}

\begin{figure*}
\centering
% \setcounter{figure}{7}
\subfigure[$\alpha$ = 0.5, V2I.]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=\linewidth]{figure/GenA_B_Window_3_down_50.pdf}
\label{fig:v2i1}
\end{minipage}%
}%
\subfigure[$\alpha$ = 0.7, V2I.]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=\linewidth]{figure/GenA_B_Window_3_down_70.pdf}
\label{fig:v2i2}
\end{minipage}%
}%
% \vspace{-3mm}
\subfigure[$\alpha$ = 0.9, V2I.]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=\linewidth]{figure/GenA_B_Window_3_down_90.pdf}
\label{fig:v2i3}
\end{minipage}%
}%
\\
% \hspace{-5mm}
\subfigure[$\alpha$ = 0.5, V2V.]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=\linewidth]{figure/GenA_B_Window_5_down_50.pdf}
\label{fig:v2v1}
\end{minipage}%
}%
\subfigure[$\alpha$ = 0.7, V2V.]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=\linewidth]{figure/GenA_B_Window_5_down_70.pdf}
\label{fig:v2v2}
\end{minipage}%
}%
\subfigure[$\alpha$ = 0.9, V2V.]{
\begin{minipage}[t]{0.32\linewidth}
\centering
\includegraphics[width=\linewidth]{figure/GenA_B_Window_5_down_90.pdf}
\label{fig:v2v3}
\end{minipage}%
}%
\centering
\vspace{-0.1in}
\caption{Channel recovery results.}
\label{fig:reconstruct}
\vspace{-0.2in}
\end{figure*}

\subsection{PCS-based Key Delivery} \label{sec:key}

% As aforementioned, the traditional quantization process is inherently lossy and may cause mismatches between legitimate nodes~\cite{xi2016instant}, e.g., the fixed threshold may lead to mismatched quantized bits for Alice and Bob~\cite{jana2009effectiveness, weitaoInaudibelKey, wei20222}.
% To address, we employ a PCS-based key delivery method~\cite{yang2023chirpkey}, which includes the measurement matrix generation, key compression and reconstruction.
As previously mentioned, conventional quantization is inherently lossy and can result in discrepancies between legitimate nodes~\cite{xi2016instant}. 
For example, fixed thresholds may produce differing quantized bits for Alice and Bob~\cite{jana2009effectiveness, weitaoInaudibelKey, wei20222}.
To mitigate this issue, we adopt a PCS-based key delivery approach~\cite{yang2023chirpkey}, which involves generating a measurement matrix, followed by key compression and subsequent reconstruction.

% \subsection{Principle of Perturbed Compressed Sensing}
% \label{subsec:pcs}
% Compressed sensing is a technique in the signal processing field which allows acquiring signals while taking few samples. Assume there is a linear compression system $y = A x$, where $x \in  \mathbb{R}^{N}$ is the original signal, $A \in \mathbb{R}^{M \times N} (M<N)$ is the measurement or sensing matrix, and $y \in  \mathbb{R}^{N}$ is the compressed signal.  Compressed sensing states that if $x$ is sparse, it can be reconstructed from far fewer samples than required by the Nyquist–Shannon sampling theorem.

% In standard compressed sensing, the measurement matrix $A$ is assumed to be
% exactly known and identical by the compressor and receiver, so that the receiver can recover $x$ by $\ell_1$ minimization:
% \begin{equation}
% \small
%     \hat{x} = \argmin_x \| x \|_1 \quad \text{ subject to } \|y - Ax\|_2 < \epsilon,
%     \label{l1} 
% \end{equation}
% where $\epsilon$ is used to account for noise. Unfortunately, such an ideal assumption is not always the case in practice. For example, when the compressed signal $y$ and measurement matrix $A$ is transmitted from a compressor to a recoverer via a wireless channel, the received $y$ and $A$ are often perturbed versions due to noise: 
% \begin{equation}
% \small
% \label{equa:2}
%     \hat{A} = A + E \text { and } \hat{y} = y + e,
% \end{equation} 
% where $E \in \mathbb{R}^{M \times N}$ and $e \in \mathbb{R}^{M \times 1}$ denote unknown perturbations from different sources, such as ambient noise, measurement error, and coding error. In this case, the standard compressed sensing recovery process becomes how to recover the original signal $x$ from the perturbed compressed signal $y$ and measurement matrix $\hat{A}$. According to perturbed compressed sensing theory~\cite{arablouei2017fast}, this problem can be solved by the following $\ell_1$ minimization:
% \begin{equation}
% \label{equa:4}
% \small
%     %\begin{gathered}
% \argmin_{x, e, E} \|{e}\|_{2}^{2}+\|{E}\|_{F}+\lambda\|A\|_{1} \quad
% 	\text{subject to }  \hat{y} = \hat{A} x,
% 	%\end{gathered}
% \end{equation}
% where $\lambda > 0$ is the regularization parameter, $\|\cdot\|_{2},\|\cdot\|_{F}$, and $\|\cdot\|_{1}$ stand for $\ell_{2}$, Frobenius, and $\ell_{1}$ norms, respectively. To solve the above $\ell_1$ minimization problem, we can use the fast reconstruction algorithm based on total least-squares and proximal splitting~\cite{arablouei2017fast}.


% \textbf{Perturbed Measurement Matrix Generation.}
% % \label{subsec:pmmg}
% Based on the above PCS theory, we propose a novel PCS-based key delivery method. The main idea of our method is \textit{since Alice and Bob have similar but not the same channel measurements (i.e., $S_{A}^{\prime}$ and $S_{B}^{\prime}$), if we can use $S_{A}^{\prime}$ and $S_{B}^{\prime}$ to construct two measurement matrices that are similar to $A$ and $\hat{A}$ above, then Alice can compress the key which can be recovered by Bob. While for attacker Eve, since her channel measurements are totally different, she cannot generate a similar perturbed measurement matrix to successfully reconstruct the key.} In the following, we present the details of the proposed method which includes perturbation matrix generation, compression and reconstruction.

\textbf{Perturbed measurement matrix generation.}
% Structured matrix perturbation~\cite{herman2010general} is a commonly used perturbation with a fixed structure in PCS. Each of its columns is an unknown constant, which is imposed with a known operation that defines the direction of the perturbation. 
% In this paper, we use the circulant matrix as the structured perturbation matrix because it is easy to be implemented in low-power LoRa end nodes. The construction method of a typical circulant matrix $f(C)$ is as follows. First, a random vector $C$ is generated, that is, $C=\left(c_{0}, c_{1}, \cdots, c_{N-1}\right) \in R^{N}$. Then the generated random vector $C$ performs cyclic displacement for $M$ times to construct the remaining $M-1$ row vectors. Finally, all the row vectors generate the entire matrix $f(C)$ through cyclic displacement.
In this work, we adopt the circulant matrix as the structured perturbation matrix due to its simplicity and ease of implementation in low-power LoRa end nodes.  
The construction process of a typical circulant matrix \( f(R) \) is as follows. First, a random vector \( R \) is generated, expressed as  
$R=\left(r_{0}, r_{1}, \cdots, r_{N-1}\right) \in R^{N}$
This vector undergoes cyclic shifts \( M \) times to form the remaining \( M-1 \) row vectors. The final circulant matrix \( f(R) \) is constructed by arranging all row vectors in a cyclically shifted manner, which is described as
% as
\begin{equation}
\small
f(R)= \left(\begin{array}{cccc}r_{0} & r_{N-1} & \cdots & r_{1} \\ r_{1} & r_{0} & \cdots & r_{2} \\ \vdots & \vdots & \ddots & \vdots \\ r_{M-1} & r_{M-2} & \cdots & r_{M}\end{array}\right).
\end{equation}

% We assume there is a default sensing matrix $A_{0}$ (we use random Gaussian matrix in \SystemName), and the goal of Alice and Bob is to use their channel measurements to generate a perturbation matrix which perturbs the default matrix. We find that using the generated perturbation matrix to directly perturb the default matrix will decrease the reconstruction capability when the average value of the perturbation matrix is large. Thus, to control the magnitude of the generated perturbation matrix, we apply a scale factor $\eta$ to the recovered arRSSI values of Alice $S^{\prime}_{{A}}$ and Bob $S^{\prime}_{{B}}$ to control the magnitude of the perturbation matrix of Alice: $\hat{S}_{{A}}=\frac{1}{\eta} S^{\prime}_{{A}}$ and $\hat{S}_{{B}}=\frac{1}{\eta} S^{\prime}_{{B}}$. The analysis of selecting a suitable $\eta$ is presented in Sec.\ref{subsec:sec_pcs}.
We assume the existence of a default sensing matrix \( A_{0} \) (in \SystemName, a random Gaussian matrix is used). The objective for Alice and Bob is to utilize their channel measurements to generate a perturbation matrix that modifies this default matrix. 
However, we observe that directly applying the perturbation matrix to \( A_{0} \) can reduce reconstruction accuracy, particularly when the perturbation matrix has a high average value.  
To mitigate this issue and regulate the magnitude of the perturbation matrix, we introduce a scaling factor \( \theta \). This factor is applied to the recovered arRSSI values from Alice \( S^{\prime}_{{A}} \) and Bob \( S^{\prime}_{{B}} \), resulting in scaled perturbation matrices:  
\begin{equation}
\small
\hat{S}_{{A}} = \frac{1}{\theta} S^{\prime}_{{A}} \quad \text{and} \quad \hat{S}_{{B}} = \frac{1}{\theta} S^{\prime}_{{B}}
\end{equation}

% Afterwards, the generated perturbed measurement matrices of Alice and Bob can be obtained by adding generated perturbation matrix to the default matrix $A_{0}$ as
% \begin{equation}
% \small
% A_{a}=A_0 (I+E_a) \text { and } A_{b}=A_0 (I+E_b),
% \end{equation}
% where $I$ is the identity matrix, ${E_a}=f\left(\hat{S}_{{A}}\right)$ and ${E_b}=f\left(\hat{S}_{{B}}\right)$ are the generated circulant matrices of Alice and Bob.
% , respectively.  %After obtaining the perturbed measurement matrices, Alice uses $A_a$ to compress her original key while Bob uses $A_b$ to recover the key, which is detailed below.
The perturbed measurement matrices for Alice and Bob are subsequently derived by applying the generated perturbation matrix to the default matrix \( A_{0} \). This process can be expressed as:  
\begin{equation}
\small
A_{a} = A_0 (I + E_a) \quad \text{and} \quad A_{b} = A_0 (I + E_b),
\end{equation}
where \( I \) represents the identity matrix, and \( E_a = f\left(\hat{S}_{{A}}\right) \) and \( E_b = f\left(\hat{S}_{{B}}\right) \) correspond to the circulant matrices generated from the scaled arRSSI values of Alice and Bob, respectively.  


% \begin{algorithm}[t]
% \caption{PCS-based key delivery.}
% \label{alg:pcs}
% \small
% \DontPrintSemicolon

% \KwIn{$\hat{S}_{A}$ and $\hat{S}_{B}$: recovered arRSSI sequences measured by Alice and Bob. $A_0$: the original measurement matrix.}

% \KwOut{$K_A$ and $K_B$: secret keys for Alice and Bob.}

% \textbf{Alice:}

% $A_{a}=A_{0}+f\left(\hat{S}_{A}\right) $
% % \algorithmiccomment{generate perturbed measurement matrix of Alice.}

% $K_{A}=PRNG(seed)$
% \algorithmiccomment{generate random key}

% $K_{A}^{s}= sparse (K_{A})$
% \algorithmiccomment{sparse the key}

% $Syn=\left[Syn_1, Syn_2\right]$, $Syn_1=A_{a} K_{A}^{s}$, $Syn_2=A_{a} K_{A}$
% % \algorithmiccomment{prepare the syndrome.}

% Send $Syn$ to Bob via public channel

% \textbf{Bob:}

% Receive noised syndrome $Syn^{\prime}=Syn+e$ 

% $A_{b}=A_{0}+f\left(\hat{S}_{A B}\right)$
% % \algorithmiccomment{generate perturbed measurement matrix of Bob.}

% $K_{B}^{s}= solve\_\ell_{1}$$(Syn_1,A_b)$

% % \For{$i=0; i<len(Syn_1); i=i+1$}{

% % $K_{B}^{si}= solve\_\ell_{1}$$(Syn_1^{i},A_b)$
% % % \algorithmiccomment{compressed vector reconstruction.}

% % $K_{B}^{s}\leftarrow K_{B}^{si}$
% % % \algorithmiccomment{append $K_{\mathrm{Bob}}^{si}$ to $K_{\mathrm{Bob}}^{s}$.}

% % }

% $K_{B}^{\prime}= de$-$sparse (K_{B}^{s})$
% \algorithmiccomment{reconstruct the key}

% $\Delta=A_b K_{B}^{\prime}-Syn_2$

% $\Delta_{AB}= solve\_\ell_{1}(\Delta,A_b)$

% % \For{$j=0; j<len(Syn_2); j=j+1$}{
% % $\Delta=A_b K_{B}^{\prime}-Syn_2$

% % $\Delta_{AB}^{j}= solve\_\ell_{1}(\Delta^{j},A_b)$
% % % \algorithmiccomment{compressed vector reconstruction.}

% % $\Delta_{AB}\leftarrow \Delta_{AB}^{j}$
% % }

% $K_{B}=K_{B}^{\prime} \oplus \Delta_{AB}$
% \algorithmiccomment{solve the mismatched bits}

% \Return $K_{A}, K_{B}$

% \end{algorithm}

% \subsection{Compression and Reconstruction}
% \label{subsec:com_recon}
% After obtaining the perturbation measurement matrices $A_a$ and $A_b$, Alice and Bob are able to perform information compression and reconstruction. %Since Alice and Bob have similar perturbation matrices, the relative perturbation of Bob to Alice is small, which guarantees the stability of compressed information transmission between Alice and Bob. Additionally, attacker Eve cannot obtain a perturbation matrix that is similar to $A_a$ and $A_b$, the small perturbation ensures the security of both parties,  The details of compression and reconstruction are as follows. 

% \textbf{Compression by Alice.} First, Alice generates a random binary sequence $K_{A} \in R^{N}$. Since compressed sensing requires sparse input, we sparse the random sequence by interpolating four zero bits (sparsity level $>4$) between each bit to transform $K_{A}$ to be a spare vector $K_{A}^{s}$. Next, Alice calculates a syndrome which is defined by $Syn=[Syn_{1}, Syn_{2}]=[A_{a} K_{A}^{s}, A_{a} K_{A}]$. The first part of the syndrome (i.e., $A_{a} K_{A}^{s}$) is a compression of the secret key $K_{A}^{s}$. The second part of the syndrome (i.e., $A_{a} K_{A}$) is used for error checking and correction. Afterwards, Alice transmits the syndrome $Syn$ to Bob through the public channel.
\textbf{Compression by Alice.} Alice begins by generating a random binary sequence \( K_{A} \in R^{N} \). To meet the sparsity requirement of compressed sensing, she increases the sparsity of \( K_{A} \) by inserting four zero bits between each bit, producing a sparse vector \( K_{A}^{s} \).  
Alice then computes a syndrome, defined as  
\begin{equation}
\small
Syn = [Syn_{1}, Syn_{2}] = [A_{a} K_{A}^{s}, A_{a} K_{A}]
\end{equation}
The first component \( A_{a} K_{A}^{s} \) represents the compressed form of the secret key \( K_{A}^{s} \), while the second component \( A_{a} K_{A} \) serves as a mechanism for error detection and correction. Finally, Alice transmits the syndrome \( Syn \) to Bob over a public channel.  


% \textbf{Reconstruction by Bob.} Let $Syn^{\prime}$ be the received syndrome with some noise $Syn^{\prime}=Syn + e = [Syn_{1} + e, Syn_{2} + e]$. After receiving the syndrome, Bob uses the first part of syndrome $(Syn_{1}+e)$ to reconstruct a sparse key $K_{B}^{s}$ by solving the following $\ell_{1}$-regularized total least-squares problem:
\textbf{Reconstruction by Bob.} Let \( Syn^{\prime} \) represent the received syndrome, which includes some noise, expressed as \( Syn^{\prime} = Syn + e = [Syn_{1} + e, Syn_{2} + e] \). Upon receiving the syndrome, Bob leverages the first part \( (Syn_{1} + e) \) to reconstruct a sparse key \( K_{B}^{s} \) by solving the following \( \ell_{1} \)-regularized total least squares problem:  
\begin{equation}
\label{equa:4}
\small
    \begin{gathered}
	\argmin_{{{e}, {E_p}, K_{B}^{s}}} \ \ \|{e}\|_{2}^{2}+\|{E_p}\|_{F}+\lambda\|{K_{B}^{s}}\|_{1}\\
	\text{subject to} \ \ ({A_b}+{E_p}) {K_{B}^{s}}=Syn_{1}+e,
	\end{gathered}
\end{equation}
% where ${E_p}$ is the perturbation difference between ${A_b}$ and ${A_a}$, namely ${E_p}={A_b}-{A_a}$. After obtaining the sparse key $K_{B}^{s}$, Bob de-sparses it to obtain $K_{B}^{\prime}$. After this step, Bob obtains an estimated key $K_{B}^{\prime}$ from the first part of the syndrome.
where \( E_p \) represents the perturbation difference between \( A_b \) and \( A_a \), defined as \( E_p = A_b - A_a \). Once Bob reconstructs the sparse key \( K_{B}^{s} \), he applies a de-sparsification process to retrieve \( K_{B}^{\prime} \). Through this method, Bob derives the estimated key \( K_{B}^{\prime} \) from the first part of the received syndrome.  


\begin{figure}[tbp!]
    \centering
    \includegraphics[width=0.8\linewidth]{figure/exp_llmkey.png}
    \vspace{-0.1in}
	\caption{Experimental setup.}
    \vspace{-0.2in}
	\label{fig:real_world}
\end{figure}

% In practice, $K_{B}^{\prime}$ is not exactly the same as Alice's original key $K_{A}$ because of noise. Therefore, Bob uses the second part of the syndrome to correct the errors. To this end, Bob first  calculates a
% mismatched vector $\Delta$ as follows
In practice, Bob’s reconstructed key \( K_{B}^{\prime} \) typically differs slightly from Alice’s original key \( K_{A} \) due to the presence of noise. To address these discrepancies, Bob leverages the second part of the syndrome to perform error correction. He begins by computing a mismatch vector \( \Delta \) as follows:  
\begin{equation}
\small
\label{equa:7}
  \begin{aligned}
    \Delta &=A_b K_{B}^{\prime}-Syn_{2} = (A_b K_{B}^{\prime}-A_a K_{A})+e \\
         &= A_b K_{B}^{\prime}-(A_b+E_p) K_A = A_b (K_{B}^{\prime}-K_A)+e \\
         &=A_b \Delta_{AB}+e,
  \end{aligned}
\end{equation}
% where $\Delta_{AB}$ means the mismatches between Alice's original key $K_{A}$ and Bob's estimation $K_B^{\prime}$. Since Alice and Bob are legitimate devices, there are only few mismatches in their keys, i.e, $\Delta_{AB}$ is sparse. Therefore, Bob can reconstruct the mismatches by solving the following $\ell_{1}$-regularized total least-squares problem:
where \( \Delta_{AB} \) represents the difference between Alice’s original key \( K_{A} \) and Bob’s reconstructed key \( K_B^{\prime} \). Since Alice and Bob are legitimate parties, the discrepancy between their keys is minimal, resulting in a sparse \( \Delta_{AB} \). Bob can recover these mismatches by solving the following \( \ell_{1} \)-regularized total least squares problem:  
\begin{equation}
\small
\label{equa:nn}
    %\begin{gathered}
	\argmin_{{\Delta}, {e}} \|{e}\|_{2}^{2}+\lambda\|\Delta\|_{1}
	\quad \text{ subject to } {A_b} {\Delta_{AB}} = \Delta + e,
	%\end{gathered}
\end{equation}
This process ensures that Bob can accurately reconstruct any remaining errors, thereby aligning his key more closely with Alice’s. Using \( \Delta_{AB} \), Bob can derive \( K_{A} \) by performing the XOR operation, expressed as \( K_{B} = K_{B}^{\prime} \oplus \Delta_{AB} \), where \( \oplus \) denotes the XOR function. As a result, Alice and Bob ultimately converge on the same key, ensuring \( K_{A} = K_{B} \).


% With $\Delta_{AB}$, Bob can deduce $K_{A}$ by simply calculating $K_{B}=K_{B}^{\prime} \oplus \Delta_{AB}$, where $\oplus$ is XOR operation. Finally, both Alice and Bob agree on the same key $K_{A}=K_{B}$. 



\subsection{Privacy Amplification}
% Although the PCS-based key delivery method achieves high reliability as evaluated in Sec.~\ref{sec:eva}, it also reveals some information to attackers because Alice and Bob have to transmit the syndrome in the public channel. This problem can be solved by privacy amplification techniques, such as hash functions~\cite{weitaoInaudibelKey,xulorakey}. In \SystemName, We employ the widely used hash function SHA-128 as a privacy amplification technique to increase the randomness of the final keys. After generating the same key, Alice and Bob can use AES-128 or other symmetric key encryption methods to encrypt/decrypt their communications.
Although the PCS-based key delivery method demonstrates high reliability, it inadvertently exposes some information to potential attackers since Alice and Bob must transmit the syndrome over a public channel. This issue can be mitigated using privacy amplification techniques, such as hash functions~\cite{weitaoInaudibelKey,xulorakey}.  
In \SystemName, we apply the widely adopted SHA-128 hash function to enhance the randomness and security of the final keys. Once Alice and Bob successfully generate the same key, they can utilize AES-128 or other symmetric encryption algorithms to secure their communications through encryption and decryption.




\section{Evaluation}
\label{sec:eva}
% This section presents the evaluation results.
\subsection{Experimental Setup}
\label{subsec:setup}
Fig.~\ref{fig:real_world} illustrates the experimental setup and data collection process. An Arduino Uno equipped with a Dragino LoRa Shield\footnote{https://www.dragino.com/products/lora/item/102-lora-shield.html} (AVR ATmega328P, SX1278) is utilized as the communication node in the IoV environment. The experiments are conducted across four distinct IoV scenarios: V2I-Urban, V2I-Rural, V2V-Urban, and V2V-Rural.
In each scenario, two identical devices represent Alice and Bob. For V2V experiments, the devices are mounted on the rooftops of vehicles, with Alice and Bob moving randomly, resulting in distances ranging from several hundred meters to a few kilometers. In V2I scenarios, Bob is stationed on the roof of a building to emulate an infrastructure node, while Alice moves freely.
To analyze the datasets collected under different probing rates and IoV scenarios, we utilize GPT-4~\cite{achiam2023gpt}, the most advanced and capable LLM currently available. 
% This comprehensive analysis enables a deeper understanding of how various configurations affect system performance.

\textbf{Metric.} For evaluating the accuracy of recovered channel measurement data, we employ the Mean Squared Error (MSE):
\[
\text{MSE} = \frac{1}{n} \sum_{i=1}^{n} (y_i - \hat{y}_i)^2.
\]
Here, \( n \) denotes the number of data points, \( y_i \) the actual values, and \( \hat{y}_i \) the predicted values. 
% MSE quantifies the average squared difference between the predicted and actual values, providing insight into the accuracy of channel reconstruction. A lower MSE indicates better performance. 
For evaluating the accuracy of the generated key, we use the key agreement rate (KAR):
\[
\text{KAR} = \frac{\text{Number of matching key bits}}{\text{Total number of key bits}}.
\]
The key agreement rate measures the proportion of bits that match between the keys generated by Alice and Bob.
% , reflecting the overall reliability of the key generation process. 
% A higher KAR indicates better synchronization between the two parties, which is critical for secure communication. 



\subsection{Overall Performance}
% Fig.~\ref{fig:eva_over} presents the key agreement rate across V2I-Urban, V2I-Rural, V2V-Urban, and V2V-Rural scenarios, utilizing the method implemented in \SystemName. For each scenario, the figure also reports the key agreement rate at various probing ratios denoted by $\alpha$.
% We can see that
% the \SystemName achieves high key agreement rate in different scenarios under different $\alpha$. Specifically, the achieves average 0.978 key agreement rate when $\alpha = 0.5$ , 0.9915 key agreement rate when $\alpha = 0.5$ , 0.994 key agreement rate when $\alpha = 0.5$. 
% Fig.~\ref{fig:reconstruct} illustrates this phenomenon, showing that as the probing ratio parameter \(\alpha\) is adjusted from 0.5 to 0.9, the recover accuracy of channel measurement data improves visibly. This improvement is primarily because higher probing ratios retain more original data, reducing the information loss during the skipped probing process and thus facilitating more accurate recover.
% The results demonstrate the high effectiveness of \SystemName across different scenarios.
% Fig.~\ref{fig:reconstruct} highlights the LLM-based recover results, demonstrating that as the probing ratio $\alpha$ increases from 0.5 to 0.9, the accuracy of channel measurement data reconstruction visibly improves. This enhancement can be attributed to higher probing ratios preserving more original data, minimizing information loss during the skipped probing process, and leading to more precise reconstructions.  

% Fig.~\ref{fig:eva_over} illustrates the key agreement rates achieved in V2I-Urban, V2I-Rural, V2V-Urban, and V2V-Rural scenarios using the method implemented in \SystemName. The figure also displays the key agreement rates at different probing ratios, denoted by $\alpha$, for each scenario.  
% The results show that \SystemName consistently achieves high key agreement rates across various scenarios and probing ratios. Specifically, the system attains an average key agreement rate of 0.978 when $\alpha = 0.5$, 0.9915 when $\alpha = 0.7$, and 0.994 when $\alpha = 0.9$.  
% Overall, the results underscore the high effectiveness and robustness of \SystemName across diverse IoV scenarios.

% Fig.~\ref{fig:eva_over2} shows the average recover accuracy of Alice and Bob when $\alpha$ is set to 0.3 to 0.9. The results show that our system can maintain MSE lower than 0.1 even when the probing rate $\alpha$ is only 0.3. Notably, the MSE is low as 0.03 when $\alpha$ is bigger than 0.7.
Fig.~\ref{fig:eva_over2} illustrates the average recovery accuracy of Alice and Bob for values of $\alpha$ ranging from 0.3 to 0.9. The results demonstrate that our system maintains an MSE below 0.1, even when the probing rate $\alpha$ is as low as 0.3. Notably, when $\alpha$ exceeds 0.7, the MSE drops to as low as 0.03.
Fig.~\ref{fig:eva_over} presents the key agreement rates obtained across V2I-Urban, V2I-Rural, V2V-Urban, and V2V-Rural scenarios using the method implemented in \SystemName. The figure further illustrates the key agreement rates at varying probing ratios, represented by $\alpha$, for each scenario.
The results indicate that \SystemName consistently achieves high key agreement rates across different scenarios and probing ratios. Notably, the system attains an average key agreement rate of 0.978 at $\alpha = 0.5$, 0.9915 at $\alpha = 0.7$, and 0.994 at $\alpha = 0.9$.
Overall, the findings highlight the exceptional effectiveness and robustness of \SystemName in diverse IoV scenarios.


\begin{figure}
\centering
% \setcounter{figure}{}
\subfigure[Recovery accuracy.]{
\begin{minipage}[t]{0.48\linewidth}
\centering
\includegraphics[width=1\linewidth]{figure/llmkey_eva2.pdf}
\label{fig:eva_over2}
\end{minipage}%
}
\hspace{-0.1in}
\subfigure[Overall accuracy.]{
\begin{minipage}[t]{0.48\linewidth}
\centering
\includegraphics[width=1\linewidth]{figure/llmkey_eva.pdf}
\label{fig:eva_over}
\end{minipage}%
}
\vspace{-0.1in}
\centering
\caption{Overall Performance.}
% \label{fig:deform3}
\vspace{-0.3in}
\end{figure}

% \begin{figure}[tbp!]
%     \centering
%     \includegraphics[width=0.68\linewidth]{figure/llmkey_eva.pdf}
% 	\caption{Overall Performance.}
% 	\label{fig:eva_over}
% 	% \vspace{-0.3in}
% \end{figure}



\section{Conclusion}
\label{sec:conclusion}
In this paper, we propose \SystemName, a physical-layer key generation system designed for Next-Gen IoV systems. \SystemName addresses key inefficiencies found in existing wireless key generation methods, such as excessive channel probing and ineffective quantization. To overcome these challenges, we introduce several novel techniques to significantly enhance the performance of the key generation process.  
First, we develop an LLM-based channel probing method that reduces the number of probing rounds while preserving essential channel characteristics, enabling efficient and secure probing. Additionally, \SystemName replaces traditional quantization with a PCS-based key delivery mechanism, boosting both robustness and security.  
Real-world evaluations demonstrate that \SystemName achieves an average key agreement rate of 98.78\%.

% In this paper, we propose \SystemName, a physical-layer key generation system for LoRa networks. In \SystemName, we propose a number of novel methods to significantly improve the performance of key generation process. First, we design CLSSI, a LoRa-specific channel indicator to provide fine-grained and accurate channel information. Additionally, we propose a lightweight channel state estimation method to comprehensively recover the channel information. Then, we propose a novel PCS-based key delivery method to securely deliver the secret keys. Extensive evaluations show that \SystemName achieves an average KMR of 99.58\% and outperforms existing techniques by 11.03\%--26.58\%. In addition, our security analysis shows that \SystemName is resistant to several common attacks. Results also show that \SystemName takes less than \SI{0.2}{\s} to generate a 128-bit key, proving that \SystemName can provide fast and secure wireless key generation for LoRa networks.



\section*{Acknowledgment}
The project was supported by the NSF of Guangdong Province (Project No. 2024A1515010192)

\bibliographystyle{IEEEtran}
\bibliography{bib}


\end{document}
