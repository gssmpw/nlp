\section{Exact algorithms}
\newcommand{\binmdt}{\textsc{BinMDT}}%
\newcommand{\incmdt}{\textsc{IncMDT}}%
\label{sec:exact-algorithms}%
Now we present two exact algorithms:
\incmdt{} is an incremental method that uses a SAT solver for
iterative improvement, until it can prove that no better solution exists.
\binmdt{} is based on a binary search for the optimal dilation $\rho$;
once the lower and upper bound are reasonably close,
the approach falls back to \incmdt{} to reach a provably optimal solution.

\subsection{Triangulation supergraph}
Both algorithms rely on the MDT supergraph mentioned in \cref{sec:edge-enumeration}.
As part of this computation, we also obtain an initial triangulation and its dilation,
as well the intersecting possible edges $I(st)$ for each possible edge $st$.
In both algorithms, we may gradually discover triangulations with lower dilation;
these are used to exclude additional edges using the precomputed dilation thresholds $\vartheta(e)$.
To keep track of the status of each edge,
we insert all points and possible edges into a graph data structure we call \emph{triangulation supergraph}.
In this structure, we mark each edge as \emph{possible}, \emph{impossible} or \emph{certain}.
Initially, all enumerated edges are \emph{possible}.
If, at any point, all edges intersecting an edge $e$ become \emph{impossible}, $e$ becomes \emph{certain}.
If an \emph{impossible} edge becomes \emph{certain} or vice versa, the graph does not contain a triangulation any longer.
If this happens, we say we encounter an \emph{edge conflict}.

\subsection{SAT formulation}
Given a triangulation supergraph $G = (P, E)$, we model the problem of finding a triangulation 
on \emph{possible} and \emph{certain} edges using the following simple SAT formulation.
Let $E_p \subseteq E$ be the set of non-\emph{impossible} edges when the SAT formulation is constructed.
For each edge $e \in E_p$, we have a variable $x_e$.
We use the following clauses in our formulation.
\begin{align}
    &\lnot x_{e_1} \lor \lnot x_{e_2} &\forall e_1, e_2 \in E_p: e_2 \in I(e_1) \label{eq:pairwise-intersection}\\
    &x_e \lor \bigvee_{\substack{e_j \in I(e)}} x_{e_j} &\forall e \in E_p\label{eq:enforce-edges}
\end{align}
Clauses (\ref{eq:pairwise-intersection}) ensure crossing-freeness and clauses (\ref{eq:enforce-edges}) ensure maximality.
When an edge $e$ becomes certain, we add the clause $x_e$; similarly, when an edge becomes impossible, we add the clause $\lnot x_e$.
Both algorithms are based on this simple formulation;
in the following, we describe how they use and modify it to find an MDT.

\subsection{Clause generation}
The following subproblem, which we call \emph{dilation path separation}, arises in both our algorithms:
Given a dilation bound $\rho$, a triangulation supergraph $G = (P, E)$ excluding only edges that cannot be in any triangulation with dilation less than $\rho$,
a current triangulation $T$ and a pair of points $s,t \in P$ such that $|\pi_T(s,t)| \geq \rho \cdot d(s,t)$, 
find a clause $C$ that is (a) violated by $T$ and (b) satisfied by any triangulation $T'$ with $\rho(T') < \rho$.

\begin{lemma}
    Assuming a polynomial-time oracle for comparing sums of square roots,
    there is a polynomial-time algorithm that solves the dilation path separation problem.
\end{lemma}
\begin{proof}
    Let $\Pi$ be the set of all $s$-$t$-paths $\pi$ in $G$ with $|\pi| < \rho \cdot d(s,t)$.
    We begin by observing that, along every path $\pi \in \Pi$, there is an edge $e \in E$
    that is not in $T$; otherwise, we get a contradiction to $|\pi_T(s,t)| \geq \rho \cdot d(s,t)$.
    Let $E' \subseteq E \setminus T$ be a set of edges such that for each $\pi \in \Pi$, 
    there is an edge $e \in E'$ on $\pi$.
    Then, $C = \bigvee_{e \in E'} x_e$ is a clause that satisfies the requirements;
    note that if $\Pi$ is empty, the empty clause can be returned.

    $T$ contains no edge from $E'$, so $C$ is violated by $T$.
    Furthermore, if a triangulation $T'$ with $\rho(T') < \rho$ does not contain any of the edges in $E'$,
    it contains none of the paths in $\Pi$.
    Therefore, $\pi_{T'}(s,t)$ uses an edge that is not in $E$, which has been excluded from all triangulations with dilation less than $\rho$; a contradiction.
    $E'$ can be computed by repeatedly computing shortest $s$-$t$-paths $\pi$;
    as long as $\pi < \rho d(s,t)$, we find an edge $e \notin T$ on $\pi$, add $e$ to $E'$ and forbid it in future paths.
    The number of edges bounds the number of iterations of this process;
    using the comparison oracle, we can efficiently perform each iteration.
\end{proof}

For a description of how we compute $E'$ in practice, see \cref{sec:practical-dilation-path-sep}.

\begin{figure}
    \includegraphics[width=\linewidth]{figures/experiments/04_mdt_comparison/iterative_search_progress.pdf}
    \caption{Progress of the incremental algorithm on an instance with $n = 50$ points. Green edges indicate changes in the triangulation, red edges indicate a dilation-defining path.}
    \label{fig:iterative-search-progress}
\end{figure}

\subsection{Incremental algorithm}
\label{sec:incremental-algorithm}
Based on the SAT formulation and the algorithm for the dilation path separation problem, \incmdt{} is simple.
Given an initial triangulation $T$ with dilation $\rho$, we enumerate the set of candidate edges and construct a triangulation supergraph $G$ with bound $\rho$.
We construct the initial SAT formula $M$ and solve it; if it is unsatisfiable, the initial triangulation is optimal.
Otherwise, we repeat the following until the model becomes unsatisfiable or we encounter an edge conflict, keeping track of the best triangulation found, see~\cref{fig:iterative-search-progress}.

We extract the new triangulation $T'$ from the SAT solver and compute the dilation $\rho'$ and a pair $s, t$ of points realizing $\rho'$.
If $\rho'$ is better than the best previously found dilation $\rho$, we update $\rho$ and mark all edges $e$ with $\vartheta(e) \geq \rho'$ as \emph{impossible}.
We then set $T = T'$ and solve the dilation path separation problem for $\rho$, $G$, $T$, $s$ and $t$.
We add the resulting clause to $M$ and let the SAT solver find a new solution.
% TODO: Appendix pseudo code
%\begin{algorithm}[t]
%    \SetKwInOut{Input}{Input}
%    \Input{Initial Triangulation $T$ with dilation $\rho$}
%    Compute the triangulation supergraph from $\rho$\;
%    Initialize SAT model $M$\;
%    \While{true}{
%        \If{$M$ is not satisfiable}{
%            \Return $T$\;
%        }
%        Let $T'$ be a triangulation that satisfies $M$\;
%        Compute $\rho'$ and two vertices $s,t$ with dilation $\rho'$ in $T'$\;
%
%        \If{$\rho' \leq \rho$}{
%            Update the triangulation supergraph with $\rho'$\;
%            $\rho \leftarrow \rho'$\;
%            $T \leftarrow T'$\;
%        }
%
%        \eIf{shorter $st$-path exists in triangulation supergraph}{
%            Generate violating clause and add it to $M$\;
%        }{
%            \Return $T$\;
%        }        
%    }
%    \caption{Pseudo code of the incremental algorithm}
%    \label{alg:incremental-algorithm}
%\end{algorithm}


%We propose an exact incremental SAT-based algorithm for solving the MDP to provable optimality.
%Given the initial solution, it (1) identifies the pair $s,t$ of points that
%define the dilation and then (2) formulates and solves a SAT problem that enforces edges on a shorter $st$-path, see~\cref{alg:incremental-algorithm} for details.
%Steps (1) and (2) can be repeated until no shorter $st$-path exists (i.e. all such paths are excluded based on previous constraints).
%In order to compare two solutions it is necessary to be able to compute the dilation of a given triangulation as if we were using infinite precision.
%It is crucial that this is done efficiently as computing the dilation comes with a significant overhead in runtime. \Cref{sec:exactness-implementation-issues} outlines our implementation.
%The algorithm terminates if the constraints introduced in (2) lead to a infeasible SAT model or if no shorter $st$-path exists in the triangulation supergraph.
%We use a simple SAT formulation with Boolean variables $x_e$ for all edges $e\in E$.
%\michael{We should add some notation for possible/impossible/certain to make this more clear.}

%If an edge $e$ is marked as \emph{certain} or \emph{impossible} in the triangulation supergraph, the variable $x_e$ is set to true or false, respectively.
%\Cref{eq:pairwise-intersection} enforces that no two edges can be selected that intersect each other in an inner point of one of the edges.
%As a triangulation is a maximal planar graph, \cref{eq:enforce-edges} enforces that for any edge $e_i\in E$, either $e_i$ or one intersecting edge is selected.


%Whenever the SAT problem finds a feasible solution $T'$ with objective value $\rho'$, we identify two points $s,t$ with dilation $\rho'$ in $T'$ that are connected by some path of length $\ell$.
%In any solution with dilation $< \rho'$, $s$ and $t$ have to be connected by a shorter path.
%It suffices to identify all edges on possible shorter $st$-paths and enforce that at least one of these edges is in the solution. \Cref{fig:path-enumeration} shows that that it is sometimes possible to reduce the number of edges that need to be enforced by identifying a hitting set on the edges of the possible $st$-paths.
%We propose a heuristic to identify a reasonably small hitting set.
%Our approach uses a bidirectional Dijkstra in the possible and certain edges of the triangulation supergraph to search for all shorter paths between $s$ and $t$.
%Whenever we find a shorter path, at least one edge on the path is not part of the current solution. We remove that edge from the graph and add it to the edge set $E'$.
%This process is repeated until no shorter path exists.
%We then build a set $E'$ of edges that are not in the current triangulation but cut through every shorter $st$-path.
%In any triangulation with a smaller dilation, $s$ and $t$ have to be connected by a shorter path and thus at least one of the edges from $E'$ has to be in the solution which we enforce by adding constraints $\bigvee_{e \in E'} x_e$.
%Note that this constraint remains valid for all subsequent SAT problems as the set of possible edges is reduced in each iteration.
%Once no shorter path exists, or the newly added constraint leads to an infeasible SAT model, the algorithm terminates and returns the current solution.

\subsection{Binary search}
\label{sec:binary-search}
\newcommand{\rhoLB}{\rho_{\text{lb}}}
\newcommand{\rhoUB}{\rho_{\text{ub}}}

% TODO Appendix pseudo code
%\begin{algorithm}[t]
%    \SetKwInOut{Input}{Input}
%    \Input{Initial Triangulation $T$ with dilation $\rho$}
%    Compute the triangulation supergraph from $\rho$\;
%    Compute initial lower bound $\rhoLB$\;
%    \textsc{BinarySearch}($\rho$, $\rhoLB$)\;
%    \caption{Pseudo code of the binary search algorithm}
%    \label{alg:binary-search-algorithm}
%\end{algorithm}
%\begin{algorithm}[t]
%    \SetKwInOut{Input}{Input}
%    \Input{Initial Triangulation $T$ with dilation $\rho$}
%    \While{true}{
%        \If{$M$ is not satisfiable}{
%            \Return $T$\;
%        }
%        Let $T'$ be a triangulation that satisfies $M$\;
%        Compute $\rho'$ and two vertices $s,t$ with dilation $\rho'$ in $T'$\;
%
%        \If{$\rho' \leq \rho$}{
%            Update the triangulation supergraph with $\rho'$\;
%            $\rho \leftarrow \rho'$\;
%            $T \leftarrow T'$\;
%        }
%
%        \eIf{shorter $st$-path exists in triangulation supergraph}{
%            Generate violating clause and add it to $M$\;
%        }{
%            \Return $T$\;
%        }        
%    }
%    \caption{Pseudo code of the binary search phase}
%    \label{alg:binary-search-phase}
%\end{algorithm}
Preliminary experiments with \incmdt{} showed that we spend almost all runtime for computing dilations, 
even for instances for which we could rely exclusively on interval arithmetic, requiring no exact computations.
For many instances, most iterations of \incmdt{} resulted in tiny improvements of the dilation.
To reduce the number of iterations (and thus, dilations computed), 
we considered the binary search-based algorithm \binmdt{}.

\subsubsection{High-level idea}
At any point in time, aside from the dilation $\rhoUB$ of the best known triangulation,
\binmdt{} maintains a lower bound $\rhoLB$ on the dilation, initialized as described in \cref{sec:edge-enumeration}.

As long as $\rhoUB-\rhoLB \geq \sigma$ for a small threshold value $\sigma$, \binmdt{} performs a binary search.
It computes a new dilation bound $\rho = \frac{1}{2}(\rhoLB + \rhoUB)$.
It then uses the SAT model in a similar way as \incmdt{} to determine whether a triangulation $T$ with $\rho(T) < \rho$ exists.
If it does, it updates $\rhoUB = \rho(T)$; otherwise, it updates $\rhoLB = \rho$.

Once $\rhoUB-\rhoLB$ falls below $\sigma$, \binmdt{} falls back to a slightly modified version of \incmdt{} to find the MDT,
starting from the best known triangulation with dilation $\rhoUB$.

In the following, we describe and motivate the differences between how \incmdt{} and \binmdt{} use the SAT formulation;
for more details, see also \cref{sec:incremental-sat-solving}.

\subsubsection{Dilation sampling}
To further reduce the time spent on computing dilations, observe the following.
When a node $v$ of some graph $G$ is expanded in Dijkstra's algorithm from source $s$, we know the shortest path from $s$ to $v$ and thus the dilation $\rho_G(s,v)$.
Because $\rho_G(s,v) \leq \rho(G)$, we can compute a lower bound on the dilation much faster than the precise value by only performing a constant number of node expansions from each point $p \in P$.
We call this \emph{sampling} of the dilation.
Given a bound $\rho$ on the dilation, we can sample a triangulation $T$ for violations, i.e., pairs $s,t$ of points with $\rho_T(s,t) \geq \rho$.
We observed that a dilation-defining path usually consisted of few edges;
thus, we have a good chance of finding it by sampling.

If it is likely that a new-found triangulation $T'$ violates a given bound $\rho$,
we can thus expect to save time by sampling for violations instead of computing the dilation exactly.
Sampling also allows us to use multiple violations to construct multiple clauses in each iteration,
potentially further reducing the number of iterations.
\binmdt{} uses sampling after each SAT call with a small constant limit on the number of violations.
If violations are found, no full dilation computation is required and violations are used to construct clauses.
Only if no violations are found, we compute the exact dilation;
ideally, this only happens once for each upper bound reduction in the binary search,
namely once we find a triangulation satisfying the current bound.
We also sample in the final improvement phase of \binmdt{}.
For an experimental overview on the number of times sampling was sufficient in comparison to the 
number of times the dilation had to be computed exactly, see \cref{sec:experiments-dilation-computation}.
