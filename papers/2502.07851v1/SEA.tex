\documentclass[a4paper,UKenglish,cleveref, autoref, thm-restate]{lipics-v2021}
\usepackage{algpseudocode}
\usepackage[ruled]{algorithm}
\usepackage{tikz}
\usepackage{multicol}
\usepackage{svg}
\newtheorem{problem}[theorem]{Problem}
\usepackage[normalem]{ulem}
\usepackage{arydshln}
\newcommand{\rsp}{\textsc{Robot Scheduling}~}


%This is a template for producing LIPIcs articles. 
%See lipics-v2021-authors-guidelines.pdf for further information.
%for A4 paper format use option "a4paper", for US-letter use option "letterpaper"
%for british hyphenation rules use option "UKenglish", for american hyphenation rules use option "USenglish"
%for section-numbered lemmas etc., use "numberwithinsect"
%for enabling cleveref support, use "cleveref"
%for enabling autoref support, use "autoref"
%for anonymousing the authors (e.g. for double-blind review), add "anonymous"

%for enabling thm-restate support, use "thm-restate"
%for enabling a two-column layout for the author/affilation part (only applicable for > 6 authors), use "authorcolumns"
%for producing a PDF according the PDF/A standard, add "pdfa"

%\pdfoutput=1 %uncomment to ensure pdflatex processing (mandatatory e.g. to submit to arXiv)
\hideLIPIcs  %uncomment to remove references to LIPIcs series (logo, DOI, ...), e.g. when preparing a pre-final version to be uploaded to arXiv or another public repository

%\graphicspath{{./graphics/}}%helpful if your graphic files are in another directory

\bibliographystyle{plainurl}% the mandatory bibstyle

\title{Fast and Safe Scheduling of Robots} %TODO Please add

%\titlerunning{Dummy short title} %TODO optional, please use if title is longer than one line

\author{Duncan Adamson}{Department of Computer Science, University of St Andrews, St Andrews, UK}{}{https://orcid.org/0000-0003-3343-2435}{}
\author{Nathan Flaherty}{Leverhulme Research Centre for Functional Materials Design, University of Liverpool, Liverpool, UK}{}{https://orcid.org/0000-0002-2798-4084}{}

\author{Igor Potapov}{Department of Computer Science, University of Liverpool, Liverpool, UK}{potapov@liverpool.ac.uk}{https://orcid.org/0000-0002-7192-7853}{}
\author{Paul G Spirakis}{Department of Computer Science, University of Liverpool, Liverpool, UK}{p.spirakis@liverpool.ac.uk}{https://orcid.org/0000-0001-5396-3749}{}
\authorrunning{D. Adamson, N. Flaherty, I. Potapov, P.G. Spirakis} 
%\Copyright{Jane Open Access and Joan R. Public} %TODO mandatory, please use full first names. LIPIcs license is "CC-BY";  http://creativecommons.org/licenses/by/3.0/
\ccsdesc[500]{Theory of computation~Graph algorithms analysis}

\keywords{Integer Linear Programming, Graph Algorithms, Robot Scheduling} %TODO mandatory; please add comma-separated list of keywords

\category{} %optional, e.g. invited paper

\relatedversion{} %optional, e.g. full version hosted on arXiv, HAL, or other respository/website
%\relatedversiondetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93]{Classification (e.g. Full Version, Extended Version, Previous Version}{URL to related version} %linktext and cite are optional

%\supplement{}%optional, e.g. related research data, source code, ... hosted on a repository like zenodo, figshare, GitHub, ...
%\supplementdetails[linktext={opt. text shown instead of the URL}, cite=DBLP:books/mk/GrayR93, subcategory={Description, Subcategory}, swhid={Software Heritage Identifier}]{General Classification (e.g. Software, Dataset, Model, ...)}{URL to related version} %linktext, cite, and subcategory are optional

%\funding{(Optional) general funding statement \dots}%optional, to capture a funding statement, which applies to all authors. Please enter author specific funding statements as fifth argument of the \author macro.

%\acknowledgements{I want to thank \dots}%optional

\nolinenumbers %uncomment to disable line numbering



%Editor-only macros:: begin (do not touch as author)%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\maketitle

%TODO mandatory: add short abstract of the document
\begin{abstract}

In this paper, we present an experimental analysis of a fast heuristic algorithm that was designed to generate a fast, collision-free schedule for a set of robots on a path graph. 
The experiments confirm the algorithm's effectiveness in producing collision-free schedules as well as achieving the optimal solution when all tasks assigned to the robots are of equal duration.
Additionally, we provide
an integer linear programming formulation that guarantees an optimal solution for this scheduling problem on any input graph, at the expense of 
significantly greater computational resources. We prove the correctness of our integer linear program. By comparing the solutions of these two algorithms, including the time required by the schedule itself, and the run time of each algorithm, we show that the heuristic algorithm is optimal or near optimal in nearly all cases, with a far faster run time than the integer linear program.





\end{abstract}

\section{Introduction}

Recent years have seen an increase in the use of moving autonomous robots within a range of environments, from manufacturing \cite{Liu2023} to Unmanned Aerial Vehicles \cite{qamar2023trmaxalloc}. We are particularly interested in the scheduling of robots within chemistry labs. This is motivated by a significant and expanding body of work concerning robotic chemists. Initial work on these systems focused on building robots performing reactions within fixed environments \cite{granda2018controlling,king2011rise,langner2019ternary,li2015synthesis,macleod2020selfdriving}, however recently Burger et al. \cite{burger2020mobile} have presented a robot capable of moving within a laboratory and completing tasks throughout the space. The works of Burger et al. \cite{burger2020mobile} and Liu et al. \cite{Liu2023} provide the main motivation for this work, namely the  
Robot Trajectory Planning problem
%of moving robots 
within a laboratory environment (as presented by Burger et al. \cite{burger2020mobile}) while avoiding collisions (as investigated in the manufacturing context by Liu et al. \cite{Liu2023}).\looseness=-1

Throughout all such applications there are two %clear
objectives for robots, namely
(1) minimise the time of completing all tasks and
(2)  complete tasks safely avoiding collisions.
%
%
%
%the robots need to complete their tasks quickly and (2) the robots must complete their tasks safely. 
%
This seemingly simple problem of finding the best path for a robot to complete all the tasks is a variant of the well known travelling salesman problem.
%
%Neither of these problems %are trivial, indeed, the %seemingly simple challenge %of finding the best path %for a robot to take in %order to complete all its %task is an example of the %well known travelling %salesman problem. 
In the other direction, scheduling the robots in such a way that they avoid collision is known to be NP-hard \cite{ourPreviousPaper}, even when the space is simplified to a simple discrete structure such as a tree.\looseness=-1

\subsection{Our Contribution}

In this paper, we present an experimental analysis of a fast heuristic algorithm allowing us to find a fast, collision-free, schedule for a set of robots on a path graph. We experimentally verify the optimality of  the algorithm for finding a collision-free  schedule on paths when the tasks that each robot must complete all have the same length with the optimal solution. Additionally, we provide an integer linear program that solves this problem optimally on any input graph, at the expense of far more computational resources being required. By comparing the solutions of these two algorithms, including the time required by the schedule itself, and the run time of each algorithm, we show that the heuristic algorithm is optimal or near optimal in nearly all cases, with a far faster run time than the integer linear program.

\subsection{Related Works}
There is a large number of results across many settings and variations of the temporal graph exploration problem, including when the number of vertices an agent can visit in one timestep is unbounded \cite{arrighi2023kernelizing,erlebach2022parameterized}, bounded \cite{erlebach_et_al:LIPIcs.ICALP.2019.141,erlebach2021temporal,michail2016traveling}, and for specific graph classes \cite{adamson2022faster,akrida2021temporal,bodlaender2019exploring,bumpus2023edge,deligkas2022optimizing,erlebach2022exploration,erlebach2018faster,taghian2020exploring}.
Particularly relevant to us is the work of Michail and Spirakis \cite{michail2016traveling}, who showed that the problem of determining the fastest exploration of a temporal graph is NP-hard, and, furthermore, no constant factor approximation algorithm exists of the shortest exploration (in terms of the length of the path found by the algorithm, compared to the shortest path exploring the graph) unless $P = NP$. As noted, the change in the structure of temporal graphs is close to the challenges implemented in our graph by agents blocking potential moves from each other.
In terms of positive results, the work of Erlebach et al. \cite{erlebach2021temporal} provided a substantial set of results that have formed the basis for much of the subsequent work on algorithmic results for temporal graph exploration. Of particular interest to us are the results that show that, for temporal graphs that are connected in every timestep, an agent can visit any subset of $m$ vertices in at most $O(n m)$ time, and provide constructions for faster explorations of graphs with $b$ agents and an $(r, b)$-division ($O(n^2 b / r + n r b^2)$ time), and $2 \times n$ grids with $4 \log n$ agents ($O(n \log n)$ time).


\section{Preliminaries}\label{sec:prelim}
Before proceeding we need to introduce some necessary definitions, here we follow the same conventions to \cite{ourPreviousPaper}. A (simple) graph $G=(V,E)$ is a pair consisting of a set of vertices $V$ and a set of edges $E \subseteq V \times V$. A \emph{walk} in a graph $G$ of length $\ell$ is a sequence of $\ell$ edges of the form $(v_1, v_2), (v_2, v_3), \dots, (v_{\ell - 1}, v_{\ell})$. Any walk $w$ can visit the same vertex multiple times and may use the same edge multiple times. 
A walk without any such repetitions is called a \emph{path}. A path which visits all vertices in a graph is called a \emph{Hamiltonian path}.
We define a $n \times m $ \emph{lattice} graph to be a square-grid with $n$ vertices in each row and $m$ vertices in each column.
Given a walk $w = (v_1, v_2), (v_2, v_3), \dots, (v_{\ell - 1}, v_{\ell})$, we denote by $\vert w \vert$ the total number of edges in $w$, and by $w[i]$ the $i^{th}$ edge in $w$. In this paper, we also allow walks to contain self-adjacent moves, i.e. moves of the form $(v_i, v_i)$ for every vertex in the graph. 
In this problem, we consider a set of agents, which we call \emph{robots}, moving on a given graph $G = (V, E)$ and completing a set of tasks $\mathcal{T} = \{t_1, t_2, \dots, t_m\}$. Each robot has some initial position $sv \in V$ and they each take a single timestep to traverse an edge.
A \emph{task} $t_i$ is a pair $(v_i,d_i)$ where $v_i$ is the vertex the task is located and $d_i$ is the duration of that task (i.e. the number of timesteps a robot needs to be on that task's vertex for in order to complete it).  
A \emph{schedule} $C$ for a robot is a sequence alternating between walks and tasks (which could begin and end with any combination of walk and task, task and task, walk and walk, or task and walk) starting at the initial vertex for its robot.
The \emph{timespan} (or makespan) of a schedule is the number of timesteps that schedule takes to be executed, formally if a schedule $C$ consists of tasks $t_1,...,t_m$ and walks $w_1,..,w_p$ then the timespan of $C$ (denoted $\vert C\vert$) is given by $\vert C \vert = \left( \sum_{i \in [1, p]} \vert w_i \vert \right) + \left(\sum_{j \in [1, m]} d_j  \right)$.
The \emph{walk representation} $\mathcal{W}(C)$ of a schedule $C$ is an ordered sequence of edges formed by replacing the task $t_i = (v_i,d_i)$ in $C$ with a walk of length $\vert t_i \vert = d_i$ consisting only of the edge $(v_{i}, v_i)$, then concatenate the walks together in order. 
A set of schedules $\mathcal{C} = C_1,...,C_k$ is said to be task-completing if for each task $t \in \mathcal{T}$ there exists a schedule $C_i$ such that $t \in C_i$.
We call such a set of schedules $\mathcal{C}$ \emph{collision-free} if there is no timestep where the robots traverse the same edge or inhabit the same vertex. In other words, for every pair of schedules $C_i,C_j$ where $i \neq j$ and all timesteps $s \in [\vert C_i \vert ]$, $\mathcal{W}(C_i)[s] = (v, u)$ and $\mathcal{W}(C_j)[s] = (v', u')$ satisfies $u \neq u'$, $v \neq v'$ and $(v, u) \neq (u', v')$.
Given 2 sets of schedules $\mathcal{C}$ and $\mathcal{C}'$, we say $\mathcal{C}$ is \emph{faster} than $\mathcal{C'}$ if $\max_{C_i \in \mathcal{C}} \vert C_i \vert < \max_{C_j' \in \mathcal{C}'} \vert C_j' \vert$.

Given a graph $G = (V, E)$, set of $k$ robots $R_1, R_2, \dots, R_k$ starting on vertices $sv_1, sv_2, \dots, sv_k$, and set of tasks $\mathcal{T}$, a \emph{fastest} task-completing, collision-free set of $k$-schedules is the set of schedules $\mathcal{C}$ such that any other set of task-completing, collision-free schedules is no faster than $\mathcal{C}$. Note that there may be multiple such schedules.\looseness=-1
%The aim of the $k$-\textsc{Robot Scheduling} problem  is to find a shortest collision-free and task-completing set of schedules for the $k$ robots.
\begin{problem}[$k$-\rsp]
    \label{prob:robot-scheduling}
    Given a graph $G = (V, E)$, set of $k$  robots $R_1, R_2, \dots, R_k$ starting on vertices $sv_1, sv_2, \dots, sv_k$, and set of tasks $\mathcal{T}$, what is the fastest task-completing, collision-free set of $k$-schedules $\mathcal{C} = (C_1, C_2, \dots, C_k)$ such that $C_i$ can be assigned to $R_i$, for all $ i \in [1, k]$?\looseness=-1
\end{problem}
\subsection{Previous Work on \rsp}%(partition on Line/Cycle/Trees)}
The work presented in this paper relies on previous work done by Adamson et al. in \cite{ourPreviousPaper}, particularly the partition algorithm which we shall now present here. 

The partition algorithm takes an instance of \textsc{Robot Scheduling} on a path graph $P=(V,E)$ and splits the graph into $k$ contiguous subpaths such that each robot completes the tasks in one of the subpaths. 
In order to know the schedules from partitioning the path it is required to know how long the shortest schedule for one robot to complete all tasks on a path would take. 
This is done by taking the minimum time of the robot going to the leftmost task first and then going right or going to the rightmost task first and then going left. 

Let $C_1(P,T,sv)$ be shortest schedule for one robot, starting at vertex $sv$, to complete all tasks in $T = t_1,...,t_m$ located on vertices $i_1,...,i_m$ on path $P$.  Here we assume $i_j < i_{j+1}$ for all  $j \in [m]$.
$$C_1(P,T,sv) =\min(\vert sv - i_1 \vert, \vert sv - i_m \vert) + i_m - i_1 + \sum\limits_{t \in T} t.$$

This can now be used in the dynamic programming algorithm shown below, here we have robots $R_1,...,R_k$ starting on initial vertices $sv_1,...,sv_k$ where $sv_i  < sv_{i+1}$ for all $i\in[k]$. 
\paragraph*{$k$-Partition Algorithm}
Let $S[c,\ell ]$ be the length of the schedule involving the leftmost $c$ robots (i.e. robots $R_1,...,R_c$) and the leftmost $\ell$ tasks.

For all $\ell \in [m]$ we initialise $S[1,\ell] := C_1 (P,\{t_1,...,t_\ell \},sv_1 )$.
Then, for each $c \in [k] $ the partition algorithm iterates through each task-containing vertex and considers splitting the path such that the first $c-1$ robots complete all tasks to the left of that point and robot $R_c$ completes the rest. The algorithm chooses the splitting point with minimum timespan to store in the table. Formally:
$$S[c, \ell] = \min_{r \in [1, \ell]} \max(\vert C_1(P, (t_{r + 1}, t_{r + 2}, \dots, t_\ell), sv_c) \vert , S[c-1, r]).$$


This algorithm was shown to be optimal for equal length tasks but a $k$-approximation otherwise. 


\subsection{Paths Connecting All Tasks} \label{sec:path_connecting_tasks_hardness}
Since an algorithm for approximating a solution to the \textsc{Robot Scheduling} problem on a path is known , a natural subproblem is in general graphs - does there exist a path connecting all tasks, and if so, can we find one?  We use this concept in subsection \ref{sec:grids} when using the partition algorithm on a lattice graph. 
\begin{problem}[\textsc{Path}]
    Given a graph $G=(V,E)$ and a set $S \subseteq V$, does there exist a path connecting all vertices in $S$?
\end{problem}
%The problem {\sc path} is : given a graph $G=(V,E)$ and a set $S \subseteq V$, is there a path connecting all vertices in $S$ and if yes , can we find one such path ?

\begin{theorem}\label{thm:path_NPC}
The problem {\sc path} is NP-Complete.
\end{theorem}

\begin{proof}
It is clear that \textsc{path} can be verified in polynomial time by traversing the certificate path to ensure $S$ is covered. 
To prove NP-hardness we reduce from Hamiltonian Path.
Consider S=V. Then {\sc path} has a yes answer if and only if $G$ has a Hamiltonian path.   
\end{proof}


\begin{theorem}\label{thm:path_polytime}
    The problem {\sc path} can be solved in polynomial time for fixed $m = \vert S \vert$. %fixed parameter tractable with respect to the parameter $k = \vert S \vert$.
\end{theorem}

\begin{proof}
Any path (if it exists) connecting all vertices in $S$ will visit them in some particular order. We shall examine all possible orderings of the $m$ vertices. Let such an ordering be $v_1, v_2, ...v_k$ . 
We now construct a graph G' such that if there exists $m$ disjoint paths in $G'$ then we have a path connecting all vertices in $S$ in $G$.
 For each vertex $v_i \in S$ we add the pair of vertices $v_i , v'_i$ to $G'$. Where $v'_i$ is adjacent to both $v_i$ and the neighbourhood of $v_i$ in $G$. 
We define two vertex sets, $A$ and $B$, with $A = \{v_1,v'_1,v_3,v'_3,...\}$ being all odd-numbered vertices and $B = \{v_2,v'_2,v_4,v'_4,...\}$ being all the even-numbered vertices.
We also add to vertices $s$ and $t$ to $G'$, with $s$ being adjacent to all vertices in $A$ (other than $v_1$) and $t$ being adjacent to all vertices in $B$.

The problem is now whether or not there exist $m$ internally disjoint paths between $s$ and $t$, this can be done in polynomial time for fixed $m$, we do this by using the $O(n^{m^{5^m}})$ algorithm in \cite{lochet2021} with the graph $G'$ and $m$ copies of the pair $(s,t)$.

In the yes instance the $m$ disjoint paths will be of the form $s,v'_1,...,v_2,t$ , $s,v_3,...,v'_2,t$, $s,v'_3,...,v_4,t$ ... etc.   and so in the original graph $G$ we have the path between all vertices in $S$ in the order  $v_1,...,v_m$. 
Since we need to do this for all orderings of the $m$ vertices in $S$ this can be done in $O(m!\cdot n^{O(m^{5^m})})$ time.
\end{proof}

%\begin{theorem}
    %The problem {\sc path} is W[1]-hard, parametrised by $k = \vert S \vert$
%\end{theorem}

%\section{Shortest Paths between Tasks}
%If the answer to problem {\sc path} is yes then a subsequent challenge is to efficiently find a shortest path connecting all tasks in $S$.
%
\section{Integer Linear Programming Formulation of the Collision-Free Robot Scheduling Problem}
\label{sec:integer_program}


We now introduce our integer linear programming (ILP) model. First, we outline the variables used in the program, before moving on to the constraints and objective function. We prove the correctness of the program as the corresponding constraints are presented.
We note that our ILP formulation uses a polynomial number of variables and constraints on the size of the input graph , the number of robots and the number of tasks.
The primary variables used in this program to represent the schedule of each robot are the set of binary variables $x_{r, v, t} \in \{0, 1\}$, where $r \in [k], v \in V$ and $t \in [\tau]$. Where $\tau$ is an upper bound on the time a schedule could take, we use $\tau = n\cdot k + \sum_t d_t $. Here $x_{r, v, t} = 1$ iff the $r^{th}$ robot is on vertex $v$ at timestep $t$. We use these variables to construct a schedule for each robot by setting robot $r$ to be at vertex $v$ at timestep $t$ iff $x_{r, v, t} = 1$. If the robot $r$ occupies some vertex $v$ for containing a task requiring $\ell$ timesteps for $\ell$ consecutive timesteps, we assume that $r$ completes the task while at that vertex.

Additionally, we introduce the binary variables $TC_{i, t} \in \{0, 1\}$, for every $i \in [T], t \in [\tau]$ with $TC_{i, t} = 1$ iff the $i^{th}$ task has been completed by timestep $t$. Finally, we use the set of binary variables $AC_{t} \in \{0, 1\}$, for every $t \in [\tau]$ to denote if every task in the graph has been completed by timestep $t$.

We now present our constraints. First, we introduce the \emph{movement constraints}, i.e. the constraints determining that the robot is at exactly one position at each timestep, that the robots can only stay in place, or move between adjacent vertices, between sequential timesteps, and that the schedule is collision-free.

\begin{align}
    \sum\limits_{v \in V} x_{r, v, t} = 1 & & \forall r \in [k], t \in [\tau]\label{eq:only_one_robot_position_per_timestep}\\
    x_{r, v, t} \leq \sum\limits_{v' \in N(v) \cup \{ v \}} x_{r, v', t - 1} & & \forall r \in [k], t \in [2, \tau] \label{eq:adjancent_robots}\\
    \sum\limits_{r \in [k]} x_{r, v, t} \leq 1 & & \forall v \in V, t \in [\tau]\label{eq:only_one_robot_per_vertex_timestep}\\
    x_{r, v, t} + x_{r, v', t - 1} + x_{r', v, t - 1} + x_{r', v', t} \leq 3 & & \forall r \in [k], r' \in [k] \setminus \{ r \}, (v, v') \in E, t \in [\tau] \label{eq:no_crossover}
\end{align}

\begin{lemma}
    \label{lem:collsion_free}
    Constraints \ref{eq:only_one_robot_position_per_timestep}, \ref{eq:adjancent_robots}, \ref{eq:only_one_robot_per_vertex_timestep}, and \ref{eq:no_crossover} ensure that the schedule given by the integer program is collision-free.
\end{lemma}

\begin{proof}
     Constraint (\ref{eq:only_one_robot_position_per_timestep}) ensures that each robot occupies exactly one position during each timestep, as otherwise $\sum\limits_{v \in V} x_{r, v, t} > 1$, if $r$ occupies two positions, or, $\sum\limits_{v \in V} x_{r, v, t} = 0$, if $r$ is not assigned any position.  Constraint (\ref{eq:adjancent_robots})  ensures that robot $r$ can be at vertex $v$ at timestep $t$ iff $r$ was at $v$, or some vertex neighbouring $v$, in the previous timestep, for any timestep in $[2, \tau]$, i.e. any timestep other than the first one. Next Constraint (\ref{eq:only_one_robot_per_vertex_timestep}) guarantee that no vertex can be occupied by more than one robot at any given timestep. Finally, Constraint (\ref{eq:no_crossover}) ensures that, given any pair of robots $r, r' \in [k]$ where $r \neq r'$, we ensure that $r$ and $r'$ do not attempt to cross the same edge in the same timestep. Explicitly, if $ x_{r, v, t} + x_{r, v', t - 1} + x_{r', v, t - 1} + x_{r', v', t} = 4$, then $r$ moves from $v'$ to $v$ in timestep $t$, and $r'$ moves from $v$ to $v'$ in timestep $t$. Otherwise, one or both of $r$ and $r'$ do not use $(v, v')$ in timestep $t$.
    Therefore, the schedule is collision-free.
\end{proof}

We now present our constraints concerning the completion of tasks.

\begin{align}
    TC_{i, t} \leq TC_{i, t - 1} + \max_{r \in [k]} \left(\sum\limits_{j \in [t - d_i, t]} x_{r, v_i, j} / d_i\right) & & \forall i \in [T], t \in [\tau]\label{eq:note_when_tasks_are_complete}\\
    TC_{i, t} \geq TC_{i, t - 1} & & \forall i \in [T], t \in [\tau] \label{eq:tasks_stay_completed}
\end{align}

%{\color{blue} To late to really update, but we could use
%\begin{align*}
%        TC_{i, t} \geq \left(\sum\limits_{j \in [t - d_i, t]} x_{r, v_i, j} / (d_i - 1)\right) - 1 & & \forall r \in [k], i \in [T], t \in [\tau]
%\end{align*}
%As a simplification of constraint \ref{eq:note_when_tasks_are_complete} that also forces $TC_{i, t}$ to be one as soon as we complete the task.
%}

\begin{lemma}
    \label{lem:TC_constraints_work}
    The value of $TC_{i, t}$ is one only if some robot has completed task $i$ by timestep $t$.
\end{lemma}

\begin{proof}
    From Constraint (\ref{eq:note_when_tasks_are_complete}) it follows that the value of $TC_{i, t}$ can be one only if either $TC_{i, t - 1} = 1$ or $\sum\limits_{j \in [t - d_i, t]} x_{r, v_i, j} / d_i = 1$, for some robot $r$. Note that, by our construction, we assume that if robot $r$ remains on the vertex $v_i$ for $d_i$ timesteps, then it will complete task $i$, therefore, if $\sum\limits_{j \in [t - d_i, t]} x_{r, v_i, j} / d_i = 1$ for any robot $r \in [k]$, the task $i$ must be completed. Further, by Constraint (\ref{eq:tasks_stay_completed}), if $TC_{i, t - 1} = 1$, indicating that the task has been completed, then $TC_{i, t} = 1$.
    Therefore, the correctness follows.
\end{proof}

\begin{lemma}
    \label{lem:TC_constaints_allow_the_right_answer}
    Given any schedule where task $i$ is completed by timestep $t$, the value of $TC_{i,t}$ may be set to one.
\end{lemma}

\begin{proof}
    Observe that task $i$ can be completed at timestep $t$ if there exists some robot $r$ and timestep $t' \in [t]$ such that $x_{r, i j} = 1$, for every $j \in [t' - d_i, t']$. Therefore, by Constraint (\ref{eq:note_when_tasks_are_complete}), $TC_{i, t'}$ may be equal to $1$. By extension, if $TC_{i, t'} = 1$ then, for any $t'' \in [t' + 1, \tau]$, we can set $TC_{i, t''}$ to $1$. Thus we get the statement.
\end{proof}

Finally, we provide our constraint for the all complete $AC_t$ variable.

\begin{align}
    AC_t \leq \sum\limits_{i \in [\vert T \vert]} TC_{i, t} / \vert T\vert & & \forall t \in [\tau]\label{eq:all_complete}
\end{align}

\begin{lemma}
    \label{lem:AC}
    The value of $AC_t$ is $1$ only if every task has been completed by timestep $t$.
\end{lemma}

\begin{proof}
    From Constraint (\ref{eq:all_complete}), $AC_t$ can be $1$ if and only if $TC_{i, t} = 1$, $\forall i \in [T]$. From Lemma \ref{lem:TC_constaints_allow_the_right_answer}, the value of $TC_{i, t}$ is one only if the task $i$ has been complete by timestep $t$.
    Therefore, $AC_t$ is one only if all tasks have been complete.
    % From Lemma \ref{lem:C_constaints_allow_the_right_answer}, given any timestep $t' \in [T]$ where task $i$ has been completed, there is an assignment of variables such that $TC_{i, t} = 1$. The
\end{proof}

\begin{theorem}
    The integer program formulated with Constraints (\ref{eq:only_one_robot_position_per_timestep}), (\ref{eq:adjancent_robots}), (\ref{eq:only_one_robot_per_vertex_timestep}),
(\ref{eq:no_crossover}),
(\ref{eq:note_when_tasks_are_complete}),
(\ref{eq:tasks_stay_completed}),
(\ref{eq:all_complete}) and the objective $$ \textrm{Maximise } \sum_{t\in [\tau]} AC_t$$
correctly finds the fastest, collision-free, task completing schedule for a given instance of $k$
\end{theorem}

\begin{proof}
    From Lemmas \ref{lem:collsion_free}, \ref{lem:TC_constraints_work}, 
\ref{lem:TC_constaints_allow_the_right_answer}, and \ref{lem:AC} we have that the program will compute a collision-free schedule, with $AC_t = 1$ only if every task has been completed by timestep $t$. Now, observe that the optimal solution to this program is the solution such that $AC_t = 1$ for the maximum number of values of $t \in [T]$. Following Lemma \ref{lem:TC_constaints_allow_the_right_answer}, for any given schedule such that task $i$ is completed by timestep $t$, there is a valid assignment of variables such that $TC_{t, i} = 1$. Therefore, given any schedule such that every task is complete by timestep $t$, there is an assignment of variables such that $AC_t = 1$. Thus, by finding the assignment such that $\sum_{t \in [\tau]} AC_t$ is maximised, we find the fastest collision-free schedule that completes all the tasks in the minimum number of timesteps, giving the proof.
\end{proof}

\section{Experiments}
%TOTAL:12767374
%OPTIMAL: 11061661
%Percentage=86.64006396303579%
We implemented the Partition Algorithm in python and executed it on a desktop computer with an Intel i7-4790 @ 4.000 GHz processor and 16GB of RAM. The linear programming solver we used was Gurobi \cite{gurobi}, implemented using the gurobipy library for python.
We generated the instances of the \rsp problem and executed the partition algorithm and Gurobi for both of them in order to analyse the performance of the partition algorithm in general. Full data can be found at \cite{data} and the python code at \cite{code}.

\begin{figure}
    \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{figures/average_plot_6_3_18}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
    \includegraphics[width=\linewidth]{figures/average_plot_6_3}
    \end{subfigure}
    \caption{Comparison of the performance ratio of the Partition Algorithm to the theoretical optimal results given by our integer programming model. On the left, the tasks had a total length of 18, while the number of tasks varies across the $x$-axis. On the right we show the same for total lengths of $4,6,8,...$ showing the performance ratio being better the higher the total duration.}
    \label{fig:fxixed_total_length}
\end{figure}

We highlight some key results from our experiments. In Figure \ref{fig:fxixed_total_length} we highlight a set of experiments on the performance ratio of the Partition Algorithm relative to the number of tasks, while maintaining the total task length at 18, number of robots at 3, and path length at $6$. We observe that, as the number of tasks increases, the performance ratio tends towards $1$. Indeed, once we have at least 5 tasks, we have not found any instances where the partition algorithm returns any non-optimal solution.

\begin{figure}
   \begin{subfigure}{0.5\textwidth}
        \includegraphics[width=\linewidth]{figures/average_plot_7_4_7}
    \end{subfigure}
    \begin{subfigure}{0.5\textwidth}
    \includegraphics[width=\linewidth]{figures/percentage_plot_7_4_7}
    \end{subfigure}
    \caption{Comparison of the performance ratio of the Partition Algorithm to the theoretical optimal results given by our integer programming model. In this case, the tasks had a total length of 7, while the number of tasks varies across the $x$-axis.}
    \label{fig:fixed_location}
\end{figure}

In Figure \ref{fig:fixed_location}, we show a similar experiment with $4$ robots, $7$ positions, and a total task length of $7$. Again, we see the performance ratio tending towards $1$, and indeed reaching it once the instance includes $5$ tasks.

\begin{figure}
    \centering
    \includegraphics[width=0.7\textwidth]{figures/performance_n7.png}
    \caption{Comparison of proportion of output from the partition algorithm with optimal timespan , and timespan within the size of a single task  from optimal for fixed $n=7$. The plot shows the proportion decreasing as the number of robots increases.}
    \label{fig:nkm_experiment}
\end{figure}

In Figure \ref{fig:nkm_experiment} we evaluate the performance of the partition algorithm by comparing the proportion of the schedules which are optimal or close to optimal as the number of robots increases for a fixed path size of $7$. There are three lines, the first is the proportion of all  the instances with timespan of $OPT$, the second is the proportion of all the instances with timespan  $\leq OPT + d_{min}$ and the last is those with timespan $\leq OPT + d_{max}$ where $d_{min}$ and $d_{max}$ are the durations of the shortest and longest tasks in that instance respectively (i.e. it is equivalent to having one task assigned to the wrong robot).
We find that the percentage of instances which are optimal decreases rapidly as the number of robots increases. This effect is lessened somewhat but still visible as we allow larger differences away from optimal.   
%With Figure \ref{fig:nkm_experiment} we compare the  .We see that theorithm instead seems to decrease rapidly as the number of robots increases. The same trends can be seen when looking at the ratio of instances in which the partition algorithm returns a solution that is at most the length of the shortest or longest task off from the optimal performance ratio.
%

In Figure \ref{fig:runtime} we compare the runtime of the partition algorithm against the integer programming formulation implemented in Gurobi.
\begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{figures/runtime_comparison.png}
    \caption{Plot of runtime against number of tasks for a fixed graph size of $n=10$, comparing Gurobi against the partition algorithm.}
    \label{fig:runtime}
\end{figure}

\subsection{Lattice Graphs}\label{sec:grids}
On a Lattice Graph one can easily find a Hamiltonian Path, in multiple ways, and so we can use one of them in order to make use of the Partition Algorithm on lattices. 
A natural way to do so is by ``snaking'' row by row in alternating directions as shown in Figure \ref{fig:grid-hamiltonian-path} .

\begin{figure}
    \centering
    \begin{tikzpicture}
    \tikzset{vertex/.style = {shape=circle,draw,minimum size=2.5em}}
    \tikzset{edge/.style = {-}}
    \node[vertex,draw=red](v_4) at (0,4){$v_4,{\color{red}2}$};
    \node[vertex](v_1) at (0,6){$v_1$};
    \node[vertex, draw=red](v_5) at (2,4){$v_5,{\color{red}5}$};
    \node[vertex](v_8) at (2,2){$v_8$};
    \node[vertex](v_7) at (0,2) {$v_7$};
    \node [vertex, draw =blue, inner sep=11pt] at (v_7){}; 
    \node[vertex](v_6) at (4,4) {$v_6$};
    \node[vertex](v_9) at (4,2) {$v_9$};
    \node [vertex, draw =blue, inner sep=11pt] at (v_9){}; 
    \node[vertex,draw=red](v_2) at (2,6) {$v_2,{\color{red}3}$};
    \node[vertex](v_3) at (4,6) {$v_3$};
    \draw[dotted,edge] (v_4) to (v_1);
    \draw[dotted,edge] (v_4) to (v_5);
    \draw[dotted,edge] (v_1) to (v_2);
    \draw[dotted,edge] (v_2) to (v_5);
    \draw[dotted,edge] (v_2) to (v_3);
    \draw[dotted,edge] (v_6) to (v_9);
    \draw[dotted,edge] (v_5) to (v_8);
    \draw[dotted,edge] (v_8) to (v_9);
    \draw[dotted,edge] (v_6) to (v_3);
    \draw[dotted,edge] (v_6) to (v_5);
    \draw[dotted,edge] (v_8) to (v_7);
    \draw[dotted,edge] (v_4) to (v_7);
    \draw[edge,red,line width=1.34] (v_7) to (v_8);
    \draw[edge,red,line width=1.34] (v_9) to (v_8);
    \draw[edge,red,line width=1.34] (v_9) to (v_6);
    \draw[edge,red,line width=1.34] (v_5) to (v_6);
    \draw[edge,red,line width=1.34] (v_5) to (v_4);
    \draw[edge,red,line width=1.34] (v_1) to (v_4);
    \draw[edge,red,line width=1.34] (v_1) to (v_2);
    \draw[edge,red,line width=1.34] (v_3) to (v_2);
    
    
    
    
    
    
    
    \end{tikzpicture}
    \caption{Instance of 2-\rsp  on a $3 \times 3$ Lattice Graph with Hamiltonian Path shown in red.}
    \label{fig:grid-hamiltonian-path}
\end{figure}

The experimentation we have done on lattices involved finding a Hamiltonian path to ``flatten" the grid for use in the partition algorithm. We did this in two ways (starting at the top left and going right first or starting at the top right and going left first) and took the minimum timespan of both of the outputs of the partition algorithm.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/grids_performance.png}
    \caption{A plot showing the average performance ratio over all generated instances increasing as the grid size increases for 2,3 and 4 robots. We note in general Performance ratio is lower for fewer robots.}
    \label{fig:grid_results}
\end{figure}

In Figure \ref{fig:grid_results} we give a brief overview of the results of our algorithm when applied to the grid. In this case, we see a general decrease in the performance of this algorithm when applied to larger grids. This suggests that the freedom of movement has a substantial impact on the performance of the algorithm.

\subsection{Analysis}

Considering the full data, we see two natural trends. First, we have that as the number of tasks increases, the performance of the partition algorithm increases (performance ratio tends to 1). Secondly, as the number of robots increases, the performance decreases (performance ratio tends larger).

In the first case, we see that as the length of the tasks tends towards uniform, the partition algorithm approaches optimality. This seems to follow from the design of the algorithm itself. While this is not entirely surprising, it suggests that the performance ratio is granular to the degree that, for instances with only a small difference in task length, it represents a good heuristic that can output near-optimal solutions in most cases.

The more interesting result is the correlation between the number of robots and the optimality of the algorithm. This, combined with the results on the lattice, strongly implies that assigning tasks within contiguous regions leads to suboptimal results. Focusing on instances with particularly poor performance ratios, we see a general trend towards instances with tasks with significant disparity regarding length. This, again, suggests that the primary issue with the Partition algorithm is the assignment of robots to contiguous ``blocks'' of tasks. %Indeed, this closely matches the explicit counter-example shown in Example \ref{ex:#1}.

Overcoming this seems to be a non-trivial task. One possible improvement suggested by these results would be to vary the starting robot in the assignment. While this would not find the optimal solution in all instances, the broader search would avoid inefficiencies caused by forcing the leftmost robot to take the left most task.

\section{Conclusion}

This paper has shown that the Partition Algorithm given in \cite{ourPreviousPaper} matches the optimal solution for Problem \ref{prob:robot-scheduling} in many cases, particularly for small numbers of robots and relatively uniform task lengths. In doing so, we have also provided an Integer Programming solution, giving the optimal result in many cases.

There are three natural directions in which to take this work. The first would be finding an optimal polynomial time algorithm for this problem if such an algorithm exists. The second opposing direction would be to search for proof of the hardness of this problem on Path Graphs. Finally, regardless of the first two questions, we would seek to find an explicit approximation bound for the Partition Algorithm, or some alternative polynomial time algorithm. 

\bibliography{references}

\appendix
\section{Integer Linear Program}

\begin{align}
   & \textrm{Maximise} \sum_{t\in{[\tau]}}AC_t \notag \\
   & \textrm{Subject To:} \notag \\
   & \sum\limits_{v \in V} x_{r, v, t} = 1 & & \forall r \in [k], t \in [\tau] \tag{\ref{eq:only_one_robot_position_per_timestep}}\\
   & x_{r, v, t} \leq \sum\limits_{N(v) \cup \{ v \}} x_{r, v, t - 1} & & \forall r \in [k], t \in [2, \tau] \tag{\ref{eq:adjancent_robots}}\\
   & \sum\limits_{r \in [k]} x_{r, v, t} \leq 1 & & \forall v \in V, t \in [\tau]\tag{\ref{eq:only_one_robot_per_vertex_timestep}}\\
   & x_{r, v, t} + x_{r, v', t - 1} + x_{r', v, t - 1} + x_{r', v', t} \leq 3 & & \forall r \in [k], r' \in [k] \setminus \{ r \}, (v, v') \in E, t \in [\tau] \tag{\ref{eq:no_crossover}}\\
   & TC_{i, t} \leq TC_{i, t - 1} + \max_{r \in [k]} \left(\sum\limits_{j \in [t - d_i, t]} x_{r, v_i, j} / d_i\right) & & \forall i \in [T], t \in [\tau]\tag{\ref{eq:note_when_tasks_are_complete}}\\
   & TC_{i, t} \geq TC_{i, t - 1} & & \forall i \in [T], t \in [\tau] \tag{\ref{eq:tasks_stay_completed}}\\
   & AC_t \leq \sum\limits_{i \in [\vert T \vert]} TC_{i, t} / \vert T \vert & & \forall t \in [\tau]\tag{\ref{eq:all_complete}}
\end{align}

The following equivalent but slightly different formulation is exactly what was used in the experiments. With the additional variables $m_{r,v,t}$ which is 1 iff robot r landed on vertex v on timestep t. As well as $TCR_{r,i,t}$ which is 1 iff robot $r$ completed task $i$ by timestep $t$.
 \begin{align}
    &\textrm{Minimise } \sum_{t\in [\tau]} t\cdot AC_t  \notag\\
    &\text{Subject To:} \notag \\
 &x_{r,v,t} \leq \sum_{v' \in N(v) \cup \{v\}} x_{r,v',t-1}\ \forall v \in V, r \in [k], t \in [\tau] \tag{1}\\
 &\sum_{r\in [k]} x_{r,v,t}  \leq 1\ \forall v\in V ,t \in [\tau] \tag{2} \\ 
 &x_{r,v,t} + x_{r,v',t+1} + x_{r',v',t} + x_{r',v,t+1} \leq 3\ \forall (r,r') \in [k] \times [k] , (v,v') \in E, t \in [\tau] \tag{3}\\
 &m_{r,v,t} = \sum_{v' \in N(v)} x[r,v',t-1] \cdot x[r,v,t]\ \forall t \in [\tau], r \in [k] , v\in V \tag{4} \\
 &\sum_{v \in V} x_{r,v,t}  = 1\ \forall r \in [k] ,t \in [\tau] \tag{5}\\%(each robot can only be at one vertex at once)\\
 &TCR_{r,i,t} \leq TCR_{r,i,t-1} + \frac{ \sum_{j = t-d_i}^{t} (1-m_{r,v_i,j})\cdot x_{r,v_i,j}}{d_i} \forall r\in[k], i \in [m], t \in [\tau] \tag{6}\\ %(TCR only 1 if r has spent d_i timesteps at v_i)\\ 
 &TCR_{r,i,t} \geq TCR_{r,i,t-1}\ \forall r \in [k], i \in [m], t \in [\tau].\tag{7}\\
 &TC_{i,t} \leq \sum_{r \in [k]} TCR[r,i,t]\ \forall t\in[\tau], i \in [m]\tag{8}\\
 &TC_{i,t} \geq TC_{i,t-1}\  \forall i \in [m], \in [\tau].\tag{9}\\
 &AC_t \leq \frac{\sum_{i \in[m]} TC_{i,t}}{m}\ \forall t\in[\tau] \tag{10}\\
 &\sum_{t\in [\tau]} AC_{t} = 1 \tag{11}
 \end{align}
\end{document}
