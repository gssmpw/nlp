\section{Detailed Design and protocols}
\label{sec05}
In this section, we describe the \sysname components, beginning with the gradient obfuscation method (Section~\ref{subsec05-03}), followed by the proposed secure aggregation service mesh structure (Section~\ref{subsec05-01}), and the implicit attestation mechanism (Section~\ref{subsec05-02}). 
We choose this order for better exposition. 
\subsection{Client-Side GOOD Training} 
\label{subsec05-03}
The two key components of GOOD training are fractal distribution generation, which allows gradient obfuscation, and a SNNL regularization loss component, which allows for latent space entanglement of distributions. The fractal distribution is generated by using IFS-based fractal generation algorithms proposed in existing model pretraining literature, where low-cost synthetic images are generated based on natural law. Due to reduced generation cost and no reliance on collected datasets, the client can do a real-time generation of fractal images or can create the distribution for itself in an offline phase~\cite{KatOkaKaz20,AndFar22}.


Introducing the second component (SNNL regularization term) ensures that the orthogonal distribution is effectively entangled with the primary distribution. Without sufficient entanglement, the subspace of the orthogonal distribution in the latent space remains distinct and easily separable from that of the primary task~\cite{JiaChoCha21}. To address this and better intertwine the gradients of the orthogonal task and primary task, we use a variant of SNNL loss to apply a subspace entanglement constraint. This constraint enhances the privacy of the obfuscated gradients by making it infeasible to isolate information specific to the primary task.

Existing entanglement methods using SNNL for learned representations have proven effective in reducing the distance between the representations of a hidden distribution and the primary distribution~\cite{JiaChoCha21}. These methods typically rely on Euclidean distance to bring the manifold representations closer. However, Euclidean distance introduces challenges, as it makes the entanglement measure sensitive to norm magnitudes and can lead to an increased influence of individual datapoints on local optimality, hence not allowing for maximal possible overlap. Similar issues make Cosine Similarity a better alternative for clustering problems~\cite{Hua08}. We modify the SNNL loss by using cosine similarity as the distance measure between latent space representations instead of Euclidean distance, leading to better alignment due to feature normalization~\cite{ChuJiaLei17} and increased overlap between the subspaces in the latent space.

\floatname{algorithm}{Algorithm}
\setcounter{algorithm}{0}
\begin{algorithm}[t]
\small
\caption{GOOD-based Client Training }
\label{Algo-1}
\textbf{Input:} \raggedright ${W}_k$,  $\mathbb{D}_C^{Priv}$, $\tau \in [0,1]$, ${N, b}$ (Fractal Parameters).\\
\textbf{Output:} ${W}_k$
\begin{algorithmic}[1]
\vspace{-0.1in}
\item[]
\Statex \hspace{-0.2in} \textcolor{SeaGreen}{\(\triangleright\) Generate Fractal Distribution}
\STATE ${D}_C^O$ = IFS\_GENERATOR(${N, b}$) 

\Statex \hspace{-0.2in} \textcolor{SeaGreen}{\(\triangleright\) Start Training}

\FOR{$i = 1$ \textbf{to} $n_{\text{epochs}}$}

\Statex \hspace{-0.2in} \textcolor{SeaGreen}{\(\triangleright\)Sample Primary and Orthogonal Distributions}

\STATE $\{X_T, Y_T\} = \{X_C^{Priv} \cup 
\vspace{0.05in}
X_C^O,Y_C^{Priv} \cup Y_C^O\}$ \newline
$,\forall \{X_C^{Priv},Y_C^{Priv}\}  \in \mathbb{D}_C^{Priv}, \forall \{X_C^O,Y_C^O\}  \in \mathbb{D}_C^O$

\Statex \hspace{-0.2in} \textcolor{SeaGreen}{\(\triangleright\)Entanglement-based Loss Computation}

\STATE $\mathcal{L} = \mathcal{L_{CE}}\big({F}_S(X_C^{Priv}),Y_C^{Priv} \big)$ + $\tau \, C$-$SNNL\big({F}_S(X_T),Y_T \big)$

\STATE $W_k^{(t+1)} = W_k^{(t)} - \eta \nabla_{W_k} \mathcal{L}(W_k^{(t)}, X_T, Y_T)
$

\ENDFOR
\STATE {\bf Return $W_k$ } 
\end{algorithmic}
\end{algorithm}

We further modify the SNNL function by introducing a lower bound of zero and replacing the exponential scaling with a logarithmic scale, imposing a greater penalty for lower spatial overlap compared to SNNL. The final regularization term looks as follows:
\begin{align*}
\mathcal{C-SNNL} &  = -\sum\limits_{i \in 1...b } \log\Biggl( \frac{\sum\limits_{\substack{j \in 1..b \\ j \neq i \, \land \, y_{i} = y_{j}}} \log {\Big(\mathcal{C.S}\big(x_i, x_j\big)\Big)}}{\sum\limits_{\substack{k \in 1..b \, \land \, k \neq i }} \log {\Big(\mathcal{C.S}\big(x_i, x_k\big)\Big)}}\Biggl),
\end{align*}
where $\mathcal{C.S}()$ is the cosine similarity measure.
In summary, the proposed GOOD mechanism combines fractal generation using IFS and latent space entanglement to achieve gradient privacy while maintaining model performance. Fractal images offer a scalable and cost-effective means of generating an orthogonal distribution, while latent space entanglement effectively obfuscates client gradients, helping preserve model performance and also enhancing its discriminative capabilities~\cite{FroPapHin19}.





\begin{figure*}[!ht]
\centering
  \includegraphics[width=0.9\textwidth]{Figures/DCTC.pdf} 
  \vspace{-0.1in}
  \caption{The sequence diagram of \sysname outlines the communication flow between the Service Provider, Server, and Client. Detailed interactions and credential establishment processes are presented in Subsections~\ref{subsec05-01} and~\ref{subsec05-02} (Protocols 1–5).}
  \label{fig:DcTC} 
  \vspace{-0.0in}
\end{figure*}


\subsection{TEE Mesh-based Secure Aggregation}
\label{subsec05-01}
Figure~\ref{fig:DcTC} illustrates the interactions between entities in \sysname for onboarding the coordinator and aggregator enclaves.
For simplicity, we illustrate the coordinator enclave and aggregator enclave running on the same edge server. However, \sysname's protocols allow for the running of coordinator and aggregation enclaves on individual servers, with multiple aggregation enclaves onboarded by a coordinator enclave with the right attributes for MABE.
\bigskip

\noindent
{\bf System Setup and Service Registration (Protocol~\ref{proto1})} 

\noindent
A service provider creates the ABE public and private keys ($M_{pk}$, $M_{sk}$) corresponding to the $n$ attributes it wants to support. The service provider then creates a manifest, known as the application's app structure ($AS$), outlining resource requirements and enclave environment specifications for the coordinator and aggregation applications. A token and signature are also included with the manifest to prove authenticity. The $AS$ for the coordinator and aggregation applications are referred to as the coordinator app structure ($CAS$) and the aggregation app structure ($AAS$), respectively (Lines 1-3).

Along with the $AS$, the service provider will also generate the attestation primitives ($attestPrim$) for each application. These attestation primitives will be used during RA-TLS connections to ensure that the applications in the secure enclaves are set up correctly. A set of signature verification and generation keys ($VK_{SP}$, $SK_{SP}$), are generated for communication purposes. The executables for the coordinator and aggregation applications ($CoorApp$ and $AggApp$) are encrypted using symmetric encryption keys $K_{C}$ and  $K_{A}$ respectively to get $encCoorApp$ and $encAggApp$. Encrypting these applications provides confidentiality in case they are distributed ahead of time and enables in-network caching (Lines 4-6). 
\bigskip
\floatname{algorithm}{Protocol}
\setcounter{algorithm}{0}
\begin{algorithm}[t]
\small
\caption{Service Setup}
\label{proto1}
\begin{algorithmic}[1]
\item[]
\begin{center}
\end{center}
\STATE $\Big(\mathsf{sysparam}$$,M_{pk} = (apk_{1},$$\dots, $$apk_{n}),$$  M_{sk} = $$(ask_{1},$$ \dots,$$ ask_{n}\Big)$$ \leftarrow \setup(1^{\lambda}, n)$
\STATE $CAS = \{manifest_{coor}, token_{coor}, signature_{coor}\} $

\STATE $AAS = (manifest_{agg}, token_{agg}, signature_{agg})$



\STATE $encCoorApp  = Enc_{K_C}(CoorApp)$
\STATE $encAggApp  = Enc_{K_A}(AggApp)$



\STATE $\mathsf{Generate}$ $attestPrim$ (Used during RA-TLS) 
\end{algorithmic}
\end{algorithm}











\noindent
{\bf Coordinator Onboarding (Protocol~\ref{proto-2})}





\begin{algorithm}[t]
\small
\caption{Coordinator Enclave Onboarding}
\label{proto-2}
\begin{algorithmic}[1]
\item[]



\begin{center}
\graybox{
\COMMENT {\textbf {At Service Provider}}
}
\end{center}
\STATE $Res \leftarrow   \{BootApp, encCoorApp,  CAS\}$, $\sigma_{Res}\leftarrow Sign_{SK_{sp}}(Res)$.
\STATE $\mathsf{Send}$ ($Res,\sigma_{Res}$) to Server
\begin{center}
\graybox{
\COMMENT {\textbf {At Server}}
}
\end{center}
\STATE $\mathsf{Receive}$  $(Res, \sigma_{Res})$
\STATE $(BootApp, encCoorApp, CAS) \gets$ Extract $Res$.
\IF {$true \gets \mathsf{Verify}_{VK_{sp}}(Res, \sigma_{Res})$}
\STATE $\mathsf{Execute}$ $BootApp$, 
\STATE $CoorEnc$ $\gets$ $BootApp$ initializes a secure enclave for the Coordinator.

\STATE $BootApp$ loads $encCoorApp$ and $CAS$ onto $CoorEnc$.
\ELSE
    \STATE Drop connection and return error 
\ENDIF
\begin{center}
\graybox{
\COMMENT {\textbf {At Coordinator Encalve}}
}
\end{center}
\STATE $\mathsf{Initialize}$ RA-TLS connection with $ServiceProvider$
\begin{center}
\graybox{
\COMMENT {\textbf {At Service Provider}}
}
\end{center}
\IF {$true \gets$  RA-TLS.Authentication()}
\STATE $\mathsf{Return}$ $K_{C}$ to $CoorEnc$
\ELSE
    \STATE Drop connection and return error 
\ENDIF

\begin{center}
\graybox{
\COMMENT {\textbf {At Coordinator Encalve}}
}
\end{center}

\STATE $CoorApp = {Dec}_{K_C}(encCoorApp)$.
\STATE $\mathsf{Execute}$ $CoorApp$
\STATE $\mathsf{Initialize}$ RA-TLS connection with $ServiceProvider$

\begin{center}
\graybox{
\COMMENT {\textbf {At Service Provider}}
}
\end{center}
\IF {$true \gets$  RA-TLS.Authentication()}
\STATE $[A_e] \gets ABE.KeyGen(M_{sk}, e)$
\STATE  $\mathsf{Store}$ $\{e, [A_e ]\}$ in $serverTable$
\STATE $\mathsf{Return}$ $[[A_e], K_A] $ to $CoorEnc$
\ELSE
    \STATE Drop connection and return error 
\ENDIF

\end{algorithmic}
\end{algorithm}

\noindent
Edge servers register with the service provider to provision coordinator enclave by receiving a prepared software package ($Res$). $Res$ contains the $BootApp$, the $encCoorApp$, and $CAS$ (Lines 1-4). %
Upon verifying the integrity of $Res$, the server will execute the $BootApp$ which will then create a secure enclave ($CoorEnc$) for the coordinator, onto which $encCoorApp$ will be loaded. The enclave will then use a high-level RA-TLS connection with the service provider for remote attestation, after which it will be provided with a decryption key ($K_C$) for the coordinator app (Lines 5-18). 

After being initialized, $CoorApp$ then creates a mid-level RA-TLS connection to the service provider to receive the ABE decryption keys. We note that the reason for this second mid-level RA-TLS connection is to verify the legitimacy of the coordinator enclave by the service provider, hence avoiding an enclave-swapping attack. In enclave swapping attack, an attacker can start with the legitimate coordinator enclave and swap it with a malicious coordinator enclave, hence allowing it to steal decryption keys. %
Upon verification of the running coordinator enclave, the service provider proceeds with provisioning the attestation collateral, the decryption key for the aggregation application ($K_A$), and the appropriate private attributes ($[A_e]$). The attributes provisioned by the service provider are generated specifically for use by the coordinator and its cluster and allow for the decryption of client data. The service provider creates a mapping between the cluster ID ($e$) and $[A_e]$ (Lines 19-27).

Once $CoorApp$ is fully provisioned, it will notify the $BootApp$ that it is ready to onboard aggregator enclaves.
The coordinator will be responsible for remote and local attestation and for key provisioning of aggregator enclaves. Local attestation is performed when the coordinator and aggregator enclaves are on the same machine, while remote attestation is performed when they are on separate machines. The process for local and remote attestation is outlined in~\cite{Anati2013InnovativeTF}. With local attestation, the aggregator will generate an enclave report via a hardware instruction that can be directly sent to the coordinator for verification. In the case of remote attestation, the aggregator enclave generates an enclave report, which will be sent to the {\it Quoting Enclave}, a special enclave enabled by Intel SGX. The Quoting Enclave will then locally attest the aggregator enclave and return an SGX quote to the aggregator. This quote is then sent to the coordinator who will use the $attestPrim$ function to verify successful aggregator deployment.
\bigskip



\begin{algorithm}[t]
\small
\caption{Aggregation Enclave Onbording}
\label{proto-3}
\begin{algorithmic}[1]
\item[]

\begin{center}
\graybox{
\COMMENT {\textbf {At Service Provider}}
}
\end{center}

\STATE $Res \gets \{BootApp,EncAggApp, AAS\}$, $\sigma_{Res}\gets Sign_{SK_{sp}}(Res)$
\STATE $\mathsf{Return}$ $\{Res,\sigma_{Res}\}$


\begin{center}
\graybox{
\COMMENT {\textbf {At Server}}
}
\end{center}

\STATE $\mathsf{Receive}$  $\{Res,\sigma_{Res}\}$
\STATE  $\{BootApp,EncAggApp, AAS\} \gets Extract Res$.
\IF {$true \gets \mathsf{Verify}_{VK_{sp}}(Res, \sigma_{Res})$}
    \STATE $\mathsf{Execute}$ $BootApp$, 
    \STATE $AggEnc$ $\leftarrow$ $BootApp$ initializes a secure enclave for the service.
    \STATE $BootApp$ loads $encAggApp$ and $AAS$ onto $AggEnc$.
    \STATE $BootApp$ sends a request to $CoorEnc$ to attest $AggEnc$
\ELSE
    \STATE Drop connection and return error 
\ENDIF
\begin{center}
\graybox{
\COMMENT {\textbf {At Coordinator Enclave }}
}
\end{center}
\IF{attestation successful}
    \STATE $\mathsf{Send}$ $[[A_e], {K_A}]$ to $AggEnc$
\ELSE
    \STATE Drop connection and return error 
\ENDIF

\begin{center}
\graybox{
\COMMENT {\textbf {At Aggregation Enclave}}
}
\end{center}

\STATE $AggApp \gets {Dec}_{K_A}(EncAggApp)$

\State $\mathsf{Execute}$ $AggApp$

\end{algorithmic}
\end{algorithm}



\noindent
{\bf Onboarding Aggregator Enclave (Protocol~\ref{proto-3})}

\noindent
A server begins the onboarding process of the aggregation service by sending a request to the service provider. If the device is not collocated with the coordinator, it will also request the $BootApp$. The response to this request will include $EncAggApp$, the $AAS$, and a signature for verification (Lines 1-4). If not already running, the server initializes the $BootApp$, which in turn, initializes a secure enclave ($AggEnc$). The $BootApp$ then loads the $EncAggApp$ and $AAS$ to the enclave. The $BootApp$ then sends a request to the $CoorEnc$ to attest the newly created enclave (Lines 5-12).
The coordinator then attests $AggEnc$ using local or remote attestation, based on where the enclave is hosted. An inter-enclave secure channel is then established to provision the required keys and attributes (Lines 13-17), allowing $AggEnc$ to decrypt and deploy $AggApp$. 
\bigskip

\noindent
{\bf User Registration} %

\noindent
A client can utilize the aggregation services provided by the service provider once it retrieves the appropriate public attributes and $M_{pk}$. Depending on the service provider these attributes may be freely accessible, or the client can gain access to them after going through a registration process with the service provider. After which the client can securely receive a tuple that includes the public attributes, $M_{pk}$, and the signature of the service provider.






\subsection{Data-centric Attestation} 
\label{subsec05-02}
{\bf Aggregation Request (Protocol~\ref{proto-5})}

\noindent
In the service offloading phase, $AggApp$ is loaded with sufficient credentials and is ready to serve client requests.
Client $u$ is a consumer of the aggregation service running at $AggApp$. We assume that $u$ has already registered for the aggregation service with the provider and obtained sufficient credentials, keys, and policies needed for data encryption. Client $u$'s initial request to $AggApp$ will be to attain a copy of the global weights. In subsequent requests, the client will include its local weights so that they may receive the result of their integration into the global model stored at the aggregator. Client $u$ then encrypts its request which includes its private data (i.e., local weights) using a hybrid cryptosystem. More specifically, $u$ first encrypts its Data using a symmetric key cryptosystem such as AES 256 with key $K_U$ to generate $C_1$. Then $C_2$ will be generated by encrypting $K_U$ using ABE with a public key $M_{pk}$ and a user-defined access policy comprising a subset of the public attributes represented by $\Upsilon_{Agg}$ in a disjunctive boolean clause to control access to the ciphertext (\eg (Aggregation $\wedge$ Microsoft) (Lines 1-8).


\begin{algorithm}[!t]
\small
\caption{Client Aggregation Request}
\label{proto-5}
\begin{algorithmic}[1]
\IF {$W_k == \phi$}
\STATE $U \gets$  Request for global weights
\ELSE
\STATE  $W_k^{Pre} \gets W_k$
\STATE $U \gets \{W_k^{Pre}, W_k\}$
\ENDIF
\STATE $C_1 \gets \mathsf{Enc}_{K_U}(U)$
\STATE $C_2 \gets \encrypt(M_{pk}, \Upsilon_{Agg} , K)$
\STATE $\mathsf{Set}$ $Req \gets \{C_1, C_2, Cert_u\}, \sigma_{Req} \gets \mathsf{Sign}_{SK_u}(Req)$ 
\STATE $\mathsf{Send}$ $\{Req, \sigma_{Req}\}$ to {\it AggEnc} 
\end{algorithmic}
\end{algorithm}

Thus, only allowing the entities with the corresponding attribute keys to decrypt the ciphertext. Client $u$ forms a request made up of $C_1$, $C_2$, and a certificate ($Cert_u$) for verification purposes, which is then signed using $SK_u$ before sending to $AggEnc$ (Lines 9-10). 
\bigskip


\noindent
{\bf Aggregation Response (Protocol~\ref{proto-6})}
\\
\noindent
When $AggApp$ receives $u$'s request, it first verifies the client's signature for correctness (Lines 1-3). $AggApp$ then decrypts $C_2$ using its private attributes, $[A_{e}]$ (using CP-ABE), thereby retrieving the symmetric key $K_U$ which is then used to decrypt $C_1$. The aggregator now has $u$'s Data and can satisfy the request. If the request is not valid then the connection is dropped. Otherwise, based on the request received $AggApp$ either sends a copy of its global weights to the user or incorporates the client's weights into its model before sending a copy of the result to $u$ (Lines 4-10). The result is encrypted using $K_U$ (i.e., $C_3$) and then sent back to $u$ along with the certificate of the provisioning enclave (Lines 11-12). After receiving the response, $u$ decrypts $C_3$ and obtains the global weights.

For further security, an enclave report for $AggEnc$ may be obtained which can be verified by $u$ using the service provider's certificate, ensuring that the aggregation was executed correctly and from inside of a secure enclave. The provisioning enclave certificate can be validated using Intel’s root of trust which is already cached at the client. 
We note that checking the enclave report or verifying the chain of trust is not necessary. By receiving the computation result, encrypted with the client’s selected symmetric key ($K_U$), we can infer that a legitimate enclave with requisite credentials (ABE keys) had decrypted the symmetric key and the client’s data.

    



\begin{algorithm}[t]
\small
\caption{Aggregation Server's Response to Client}
\label{proto-6}
\begin{algorithmic}[1]
    
\item[]
\begin{center}
\end{center}

\STATE $\mathsf{Receive}$  $\{Req, \sigma_{Req}\}$
\STATE $\mathsf{Extract}$ $\{C_1, C_2, Cert_u\} \leftarrow Req$, $VK_{u} \leftarrow Cert_{u}$
\IF {$true \leftarrow \mathsf{Verify}_{VK_{u}}(Req, \sigma_{Req})$}

\STATE{$ K \leftarrow \decrypt(M_{pk},[A_e],C_2)$}
\STATE $U = \mathsf{Dec}_{K_U}(C_1)$
    \IF{$U$ is a request for global weights}
    
    
    \STATE $C_3 =  \mathsf{Enc}_{K_U}(W_G)$, 
    
    \STATE $\mathsf{Return}$ $C_3$  
    \ELSIF{$U$ is a aggregation request}%
        \STATE $W_G  = W_G -  \frac{1}{K}*(W_K^{Pre} - W_K)$
        \STATE $C_3 =  \mathsf{Enc}_{K_U}(W_G)$, 
    
        \STATE $\mathsf{Return}$ $C_3$          
    \ENDIF

\ELSE
    \STATE Drop connection and return error 
\ENDIF



\end{algorithmic}
\end{algorithm}








