\section{Related works}
\textbf{Imbalance Graph Classification:}
Due to the non-Euclidean characteristics of graph data, the imbalance problem in this type of data necessitates additional attention and specialized focus. Following the categorization of imbalance classification methodologies, we similarly categorize imbalance graph classification models into two main groups: data-level and algorithm-level methods.

\textit{Data-level methodologies} try to rebalance the learning environment by manipulating training data in feature or label spaces. Fundamental approaches such as over-sampling and under-sampling, prevalent in traditional class-imbalanced learning, require adaptation to suit the complexities inherent in graph data, characterized by intricate node dependencies and interconnections. Data-level methods could subcategorized into data interpolation, adversarial generation, and pseudo-labeling \citep{ma2023class}. Data interpolation techniques, exemplified by SMOTE \citep{chawla2002smote} and its graph-oriented variant, GraphSMOTE \citep{zhao2021graphsmote}, generate synthetic minority nodes by interpolating between existing node representations. Methods like GATSMOTE \citep{liu2022gatsmote} and GNN-CL \citep{li2024graph} enhance this process through attention mechanisms, ensuring quality edge predictions between synthetic and real nodes. Moreover, Mixup strategies, as seen in GraphMixup \citep{wu2022graphmixup} and GraphENS \citep{park2022graphens}, introduce sophisticated blending techniques to combat neighbor memorization issues and prevent out-of-domain sample generation.

\textit{Algorithm-level methodologies} focus on refining learning algorithms to accommodate class imbalance effectively. Model refinement strategies adapt graph representation learning architectures to improve performance by incorporating class-specific adjustments and modules tailored to handle imbalance. For instance, approaches like ACS-GNN \citep{ma2022attention} and EGCN \citep{wang2022effective} modify aggregation operations within graph neural networks to prioritize minority class information, ultimately enhancing classification accuracy. Additionally, loss function engineering tries to design customized loss functions to prioritize minority class errors or encourage wider class separations, a challenging task given the connectivity properties of nodes in graphs. Recent innovations like ReNode \citep{chen2021topology} and TAM \citep{song2022tam} integrate graph topology information into loss function designs, showcasing advancements in addressing class imbalance within the graph context. \citet{jervakani2024klce} proposed a KL regularization for imbalance node classification.

\textbf{Generalization Error and Node Classification:} There are two different scenarios in node classification, including inductive and transductive scenarios. Inductive learning node classification involves (semi-)supervised learning on graph data samples where the test data are unseen during training. In Inductive node classification For node classification tasks, \citep{verma2019stability} discussed the generalization error under node classification for GNNs via algorithm stability analysis in an inductive learning setting based on the SGD optimization algorithm. The work by \citet{zhou2021generalization} extended the results in \citep{verma2019stability} and found that increasing the depth of Graph Convolutional Neural Network (GCN) enlarges its generalization error for the node classification task. In Transductive Node Classification, based on transductive Rademacher complexity, a high-probability upper bound on the generalization error of the transductive node classification task was proposed by \citet{esser2021learning}. The transductive modeling of node classification was studied in \citep{oono2020optimization} and \citep{tang2023towards}. \citep{cong2021provable} presented an upper bound on the generalization error of GCNs for node classification via transductive uniform stability, building on the work of \citep{el2006stable}. In contrast, our research focuses on the task of imbalance transductive node classification and we provide an upper bound on population risk.

\textbf{Uncertainty in Self-training: }
The integration of uncertainty estimation in GNNs has been extensively explored, particularly in self-training frameworks \cite{wang2021be,yang2021self,zhao2021entropy}. Early contributions, such as \cite{li2018deeper}, introduced a simple strategy that selects the top K most confident nodes based on softmax probabilities for pseudo-labeling, expanding the labeled set iteratively. This approach was later refined by \cite{sun2020multi}, which employed a multi-stage self-training method, iteratively updating node labels to enhance GNN performance in sparse label settings. Extending these ideas, \cite{yang2021self} proposed a self-enhanced GNN framework that utilizes an ensemble of models to ensure consistency in pseudo-label predictions, thereby improving robustness against label noise. A common technique for uncertainty estimation in these methods is the use of entropy, as demonstrated in \cite{cai2017active, zhang2021alg}, which measures prediction confidence to guide node selection. Building on this, \cite{zhao2021entropy} introduced an entropy-aware self-training framework, incorporating an entropy-aggregation layer to account for graph structural information in uncertainty estimation. While traditional approaches in entropy-based uncertainty estimation, prioritize high-confidence nodes for pseudo-labeling, this practice might unintentionally reinforce distributional biases, as highlighted by \cite{liu2022confidence}, where over-reliance on highly certain nodes risks a distribution shift between the original labeled set and the expanded pseudo-labeled set. Furthermore, \cite{li2023informative} observed that nodes with very high confidence often contribute redundant information, limiting the diversity of the labeled dataset and potentially biased learning process. To address this concerning issue, in this work, we suggest to balance node selection across a broader confidence range to improve the performance of our model.
% \vspace{-1em}