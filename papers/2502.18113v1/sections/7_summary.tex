\section{Discussion}
\label{sec: summary}
Based on our research, we highlight three notable findings:

(1) \textsf{A compact coding method that significantly enhances search performance may not be suitable for index construction.} Recent research \cite{DiskANN,yue2023routing,HVS,yang2024bridging} has integrated compact coding techniques, such as PQ \cite{PQ}, into the search process while preserving the original HNSW index construction. This approach improves search performance but incurs additional indexing time. Note that the index construction process presents greater challenges due to its more complex execution logic relative to the search procedure \cite{HNSW,graph_survey_vldb2021}. Consequently, directly applying existing compact coding methods to HNSW construction may not yield substantial improvements in indexing speed. Our empirical results indicate that while HNSW-SQ enhances search performance compared to standard HNSW, it provides only marginal improvements in indexing speed.


(2) \textsf{Reducing more dimensions may bring higher accuracy.} While it might seem intuitive that preserving more dimensions during vector dimensionality reduction would increase accuracy \cite{ADSampling,tau-MG,yang2024bridging}, focusing on principal components is advisable when vector representation is constrained by limited bit allocation. This approach reduces the impact of less significant components, which tend to suffer from poor bit usage. For instance, \texttt{Flash} leverages lower-dimensional principal components, significantly accelerating index construction and delivering superior search performance compared to higher-dimensional counterparts (Figure \ref{fig: HNSW-Flash param}).

(3) \textsf{Encoding vectors and distances with a tiny amount of bits to align with hardware constraints may yield substantial benefits.} In compact coding methods, fewer bits typically enhance efficiency but may compromise accuracy, while more bits can improve accuracy at the cost of efficiency \cite{PQ,OPQ}. Therefore, determining an optimal bit count is essential for balancing accuracy and efficiency. However, this optimal count may not align with hardware constraints. Addressing this requires redefining the balance to accommodate hardware specifications. With tailored hardware optimizations, using fewer bits may achieve a better balance than the original optimal counts. For example, \texttt{Flash} encodes distances with 8 bits to leverage SIMD capabilities, achieving a more favorable balance than the standard 32-bit configuration.





