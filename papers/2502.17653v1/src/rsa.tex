\subsection{RSA-based Digital Signatures}
\label{sec:rsa}


\begin{figure}
    \centering
    \input{tikz/rsa-pkg}
    \caption{RSA-based Key Generation}
    \label{fig:rsa:keygen}
\end{figure}


%
To make sure that our Hypothesis~\ref{def:sig:correct}
for functional correctness of digital signatures as
stated in Figure~\ref{fig:sigprim:hypo} is indeed
sufficient, we implement RSA-based digital signatures.
%
RSA-based signatures are one of the schemes from the
TPM 2.0 specification.
%
We take full advantage of \ssprove and its access to the
rich ecosystem of existing developments.
%
A full definition of RSA along with a proof of
functional correctness is available in the \texttt{mathcomp-extra}
library.\footnote{https://github.com/thery/mathcomp-extra}
%
We placed this proof at the heart of our proof
for functional correctness of RSA-based digital signatures.
%
A substantial part of our development then evolves around
the setup of the sampling spaces.
%
In Figure~\ref{fig:rsa:keygen}, we list a condensed and
slightly simplified versioni of the code for 
$\Sigma$.\icoq{KeyGen}.
%
The interested reader can find the full implementation
in our \coq development.
%

\subsection{Sample Spaces}
%
The code highlights the three places where we sample
values from uniform distributions.
%
In total, we need to sample values for $p$, $q$ and $e$
(Lines~2,3 and 8).
%
From these values, we calculate $d$ (Line~9) and
define the public and the secret key to return (Lines~13--17).
%
Our sampling spaces $P$, $Q$ and $E$ establish the
properties that are need for our functional correctness
proof.

%
The space that all threee spaces are based upon must
obey the following requirements.
%
First, we need to sample prime numbers.
%
Second, there need to exist at least three distinct prime
numbers.
%
The following is our mathcomp-based definition:
%
\begin{minted}[fontsize=\footnotesize,escapeinside=&&]{coq}
Variable n : &$\mathbb{N}$&.
Definition &$\mathbb{B}$& : Type := 'I_(n.+6).
Definition primes : finType := {x :&$\mathbb{B}$& | prime x}.
Definition P : {set primes} := [set : primes].
\end{minted}
%
This definition fulfills both requirement.
%
The set \icoq{P} contains only primes.
%
And \icoq{P} contains at least the primes that are smaller 
than $6$, i.e., $2$, $3$ and $5$.
%

%
The sampling space \icoq{Q} now needs to establish the
property that \icoq{p != q} (Line~4).
%
That is, \icoq{Q} is depending on the value that was 
sampled before from \icoq{P}.
%
But \icoq{Q} has to establish yet another property for
the space \icoq{E}:
%
\begin{minted}[fontsize=\footnotesize,escapeinside=&&]{coq}
Definition Q p :=
  let P' := P :\ p in
  if p == 2 
  then P' \ 3
  else if p == 3 
       then P' :\ 2
       else P'.
\end{minted}
%
In \icoq{RSA.KeyGen}, we use \icoq{p} and \icoq{q}
to compute $\phi^n$, the Euler totient function (Line~6).
%
This $\phi^n$ then defines $E$:
%
\begin{minted}[fontsize=\footnotesize,escapeinside=@@]{coq}
Definition E' {m: @$\mathbb{B}$@ * @$\mathbb{B}$@)} (H: 2<m) :=
  { x : @$\mathbb{Z}_m$@ | 1 < x && coprime m x}.
Definition E {m: @$\mathbb{B}$@ * @$\mathbb{B}$@)} (H: 2<m) : {set (E' H)} := 
  [set : E' H].
\end{minted}
%
$E$ needs to have at least one value to sample \icoq{e} (Line~8).
%
That is, $\phi^n > 3$.
%
And hence, the construction of $Q$ must exclude the
two cases where \icoq{p := 2} and \icoq{q := 3} or vice versa
because 
\[
    \phi^n = (2-1) * (3-1) = 5 \ngtr 5
\]
would not provide a space to sample a coprime number \icoq{e} 
from.
%

\subsection{Functional Correctness}

%
Based on this sample space construction, we can now
proof functional correctness for our digital signature scheme.
%
\begin{theorem}[Functional Correctness for RSA-based Digital Signatures]
    Given the definitions of our RSA-based signature scheme $\Sigma := \texttt{RSA}$,
    the following holds:
  \begin{center}
    \begin{minipage}{0.75\columnwidth}
    \begin{minted}[fontsize=\footnotesize,escapeinside=@@,autogobble]{coq}
@$\forall$@ m sk pk,
    ((sk,pk) <- RSA.KeyGen) ->
    RSA.VerSig pk (RSA.Sign sk m) m == true.
    \end{minted}
    \end{minipage}
    \end{center}
\end{theorem}
\begin{IEEEproof}
    %
    The proof establishes all necessary properties
    from the construction of the sampling spaces and
    finally reduces to the functional correctness
    of RSA itself.
    %
    Our \coq development has all the details.
    %
\end{IEEEproof}

%%% The specifications so far are abstract, without concrete implementation.
%%% %
%%% In this chapter, we specify the RSA Digital Signature Scheme to showcase that out abstract signature model can be implemented. 
%%% %
%%% We use RSA signatures for they are one of the schemes from the TPM 2.0 specification.
%%% %
%%% 
%%% %
%%% We take advantage on the \href{https://github.com/thery/mathcomp-extra/blob/master/rsa.v}{mathcomp-extra} GitHub repository, where they implemented the RSA Encryption Scheme and prove functional correctness. 
%%% %
%%% They implemented the RSA parameters as a \textit{struct} with the following parameters: 
%%% %
%%% $p$ and $q$ are distinct prime numbers, $pq$ is a natural number that is dividable by both $p-1$ and $q-1$ and lastly, $e$ and $d$ are two natural numbers such that $e*d=1\;\text{mod}pq$. 
%%% %
%%% Note that this notation for $pq$ denotes the totient of $p*q$.
%%% %
%%% 
%%% %
%%% RSA defines encryption and decryption as depicted in Fig. \ref{rsa-enc-dec}.
%%% %
%%% 
%%% \begin{figure}[h]
%%% 	\begin{center}
%%% 		\begin{tikzpicture}
%%% 				
%%% 			% Encrypt %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 			\filldraw [fill=white, draw=black, thick] 
%%% 			(1,0) rectangle (8,-0.9);
%%% 			\filldraw [fill=orange!20, draw=black, thick] 
%%% 			(1,0) rectangle (8,-.5) node[pos=.5] 
%%% 			{\small\textbf{Definition:} $encrypt$};;
%%% 			\filldraw [fill=orange!10, draw=black, thick] 
%%% 			(1,-.5) rectangle (8,-0.9) ;;			
%%% 			
%%% 			\node at (4.3,-0.7) [font=\sffamily] {
%%% 				\footnotesize$ encrypt\;e\;pq\;w\;:\;nat\;:=\;w ^ e\;mod\;pq$ };
%%% 
%%% 			% Decrypt %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 			\filldraw [fill=white, draw=black, thick] 
%%% 			(1,-1.2) rectangle (8,-2.1);
%%% 			\filldraw [fill=orange!20, draw=black, thick] 
%%% 			(1,-1.2) rectangle (8,-1.7) node[pos=.5] 
%%% 			{\small\textbf{Definition:} $decrypt$};;
%%% 			\filldraw [fill=orange!10, draw=black, thick] 
%%% 			(1,-1.7) rectangle (8,-2.1) ;;			
%%% 			
%%% 			\node at (4.3,-1.9) [font=\sffamily] {
%%% 				\footnotesize $decrypt\;d\;pq\;w\;:\;nat\;:=\;w ^ d\;mod\;pq$ };
%%% 			
%%% 		\end{tikzpicture}	
%%% 		\caption{Parametric Definition of a Hash function $\mathcal{H}$ and it's collision resistance}
%%% 		\label{rsa-enc-dec}
%%% 	\end{center}
%%% \end{figure}
%%% 
%%% %
%%% These definitions of the RSA Encryption and Decryption will be used straight forward to define the Sign and Verify functionalities of the Signature Scheme:
%%% %
%%% $$Sign\;:=\;Encrypt\text{ ,and }Verify\;:=\;Encrypt$$.
%%% %
%%% \todo{make some of these lines Coq code}
%%% 
%%% %
%%% The setup requires two distinct prime numbers. 
%%% %
%%% The sampling from a set is implemented in SSProve, we just need to provide the set of prime numbers to sample from.
%%% %
%%% Let $n\;:\;nat$ be a Variable. 
%%% %
%%% We define $r_0\;:\;nat\;:=\;n+6$ and $R_0\;:\;Type\;:=\;I_{r_0}$, the natural numbers smaller than $r_0$. 
%%% %
%%% See chapter \ref{sec:imply} for more details about the choice of $r_0$. 
%%% %
%%% Now, we define the property of an element of $R_0$ being prime as follows: $$prime_num\;:\;finType\;:=\;{x:\:R_0 \;|\;prime\;x}.$$ 
%%% %
%%% Finally, we can define the set of Prime numbers smaller than $r_0$ as $$Definition\;P\;:\;{set\;prime_num}\;:=\;[set\;:\;prime_num].$$
%%% %
%%% 
%%% \subsection{RSA Setup}
%%% 
%%% 
%%% \begin{figure}[h]
%%% 	\begin{center}
%%% 		\begin{tikzpicture}			
%%% 			% Header %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 			\filldraw [fill=white, draw=black, thick] 
%%% 			(1,0) rectangle (8,-5.4);
%%% 			\filldraw [fill=black!20, draw=black, thick] 
%%% 			(1,0) rectangle (8,-.5) node[pos=.5] 
%%% 			{\small\textbf{Package:} RSA Key\textunderscore\text{Gen}};;
%%% 			\filldraw [fill=black!10, draw=black, thick] 
%%% 			(1,-.5) rectangle (8,-1.7) ;;
%%% 			
%%% 			\node at (2.25,-.7) [font=\sffamily] {\footnotesize\textbf{Locations:} };
%%% 			\node at (2.6,-1.1) [font=\sffamily] {\footnotesize\textbf{Input Interface:} };
%%% 			\node at (2.7,-1.5) [font=\sffamily] {\footnotesize\textbf{Output Interface:}};
%%% 			
%%% 			\node at (5.35,-.7) [font=\sffamily] { \footnotesize $sk\textunderscore loc$, $pk\textunderscore loc$};
%%% 			\node at (4.5,-1.1) [font=\sffamily] {\footnotesize $[\;\;]$};
%%% 			
%%% 			\node at (4.8,-1.5) [font=\sffamily] {\footnotesize $[sk,pk]$};		
%%% 			
%%% 			% Body %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 			
%%% 			% get_pk
%%% 			\node at (2.75,-2.0)  {\small{$\# RSA-Key\textunderscore Gen$}};
%%% 			
%%% 			\node at (4.25,-2.4)  {\footnotesize{$p\;\leftarrow sample\;uniform\;P\;;;$}};
%%% 			\node at (4.45,-2.8)  {\footnotesize{$q\;\leftarrow sample\;uniform\;P\setminus p\;;;$}};
%%% 			\node at (3.7,-3.2)  {\footnotesize{$\texttt{assert}\;(p\;\neq\;q)\;;;$}};
%%% 			\node at (4.45,-3.6)  {\footnotesize{$e\;\leftarrow sample\;uniform\;i\textunderscore ss\;;;$}};
%%% 			\node at (4.1,-4)  {\footnotesize{$d\texttt{ := }e^{-1}\;\text{mod}\;\phi(p*q)\;;;$}};
%%% 			\node at (4.05,-4.4)  {\footnotesize{$\#\texttt{put}\;sk\textunderscore loc\;(p*q,e)\;;;$}};
%%% 			\node at (4.05,-4.8)  {\footnotesize{$\#\texttt{put}\;pk\textunderscore loc\;(p*q,d)\;;;$}};
%%% 			\node at (4,-5.2)  {\footnotesize{$\texttt{ret}\;((p*q,e),(p*q,d))$}};
%%% 
%%% 		\end{tikzpicture}	
%%% 		\caption{RSA Signatures Key Generation}
%%% 		\label{rsa-keygen}
%%% 	\end{center}
%%% \end{figure}
%%% \hspace{.2cm}
%%% 
%%% \todo{check for formalizations on scholar}
%%% 
%%% \todo{make code style aligned with SSProve paper, eg minted, footnotesize, etc.}
%%% 
%%% %
%%% We show the following two properties. The first on is that the Signature Scheme is correct (Fig. \ref{rsa-correct}).
%%% %
%%% 
%%% \begin{figure}[h]
%%% 	\begin{center}
%%% 		\begin{tikzpicture}
%%% 			
%%% 			% Header %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 			\filldraw [fill=white, draw=black, thick] 
%%% 			(1,0) rectangle (8,-1.4);
%%% 			\filldraw [fill=green!20, draw=black, thick] 
%%% 			(1,0) rectangle (8,-.5) node[pos=.5] 
%%% 			{\small\textbf{Theorem:} RSA Signature Correct};;
%%% 			\filldraw [fill=green!10, draw=black, thick] 
%%% 			(1,-.5) rectangle (8,-1.4) ;;
%%% 			
%%% 			\node at (4.4,-0.8) [font=\sffamily] {
%%% 				\footnotesize $If\;(sk,pk)\leftarrow Key\textunderscore Gen$ };
%%% 			
%%% 			\node at (4.5,-1.2) [font=\sffamily] {
%%% 				\footnotesize $Ver\textunderscore sig\;pk\;(Sign\;sk\;msg)\;msg \;==\;true.$ };
%%% 			
%%% 		\end{tikzpicture}	
%%% 		\caption{RSA Signature Correctness Theorem}
%%% 		\label{rsa-correct}
%%% 	\end{center}
%%% \end{figure}
%%% 
%%% \jm{not happy with the style of the last Theorems/Lemmata. They are in parts pure Coq, not SSProve notation. I would like to indicate that a little better.}
%%% 
%%% %
%%% The second important property is that the Signature Property from above is fulfilled.
%%% %
%%% 
%%% \begin{figure}[h]
%%% 	\begin{center}
%%% 		\begin{tikzpicture}
%%% 			
%%% 			% Header %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% 			\filldraw [fill=white, draw=black, thick] 
%%% 			(1,0) rectangle (8,-1.8);
%%% 			\filldraw [fill=green!20, draw=black, thick] 
%%% 			(1,0) rectangle (8,-.5) node[pos=.5] 
%%% 			{\small\textbf{Theorem:} RSA Signature Property};;
%%% 			\filldraw [fill=green!10, draw=black, thick] 
%%% 			(1,-.5) rectangle (8,-1.8) ;;
%%% 			
%%% 			\node at (4.5,-.8) [font=\sffamily] {
%%% 				\footnotesize $\forall\;l:\;{fmap\;(Signature*Message)\;\rightarrow unit}$ };
%%% 			\node at (4.5,-1.2) [font=\sffamily] {
%%% 				\footnotesize $Ver\textunderscore sig\;pk\;(Sign\;sk\;m)\;m\;$ };
%%% 			\node at (4.4,-1.6) [font=\sffamily] {
%%% 				\footnotesize $= \;((Sign\;sk\;m,\;m)\;\in\;domm \;l)$ };
%%% ;
%%% 		\end{tikzpicture}	
%%% 		\caption{RSA Signature Property}
%%% 		\label{rsa-sig-prop}
%%% 	\end{center}
%%% \end{figure}
%%% \hspace{.2cm}
%%% 
%%% 
%%% 
%%% \subsection{Signature properties revisited}
%%% 
%%% \todo{talk about how we implemented the parameters from the signature specification and how this RSA chapter relates to the properties from above}
