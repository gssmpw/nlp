\section{From Existential Unforgeability to Indistinguishability}
\label{sec:TheoryFound}
%
%\newcommand{\oo}{\ensuremath{\mathcal{O}}\xspace}
%\newcommand{\p}{\ensuremath{\mathcal{P}}\xspace}
%\newcommand{\x}{\icoq{X}\xspace}
%\newcommand{\y}{\icoq{Y}\xspace}
%\newcommand{\z}{\icoq{Z}\xspace}
%
Remote attestation is based on digital signatures and as such
inherits their security property.
%
Digital signatures are secure against chosen-message attacks when
the generated signature is not forgable.
%
That is, an attacker that has seen a finite number of message-signature
pairs cannot generate a signature for a new message.
%
This property is well-known as \emph{unforgeability}~\cite{goldwasser1988digital}.
%
In this section, we establish the connection between
unforgeability and the semantic proofs for indistinguishability in
the SSP methodology.
%
First, we define digital signatures and unforgeability.
%
Afterwards, we introduce the concept of indistinguishability.
%
Finally, we connect the two to define the foundation for
our security definition of RA.
%

\subsection{Unforgable Digital Signatures}

%
We follow textbook definitions~\cite{joy,companion} to specify digital
signatures and then define \emph{unforgeability} as their fundamental
security property.
%

\subsubsection{Specification}
\begin{definition}[Signature Scheme $\Sigma$]
  \label{def:sig:scheme}
  \[
  \Sigma=(\text{KeyGen},\text{Sign},\text{VerSig})
  \]
\end{definition}
%
A digital signature scheme $\Sigma$
defined over a message space $\mathcal{M}$ consists
of three probabilistic polynomial-time algorithms:
%
\begin{itemize}
  %
    \item \textbf{KeyGen} generates
    a pair of keys $(sk, pk)$, where $sk$ is the secret signing
    key and $pk$ is the public verification key. 
    %
    \item\textbf{Sign} takes the secret signing key $sk$ and
    a message $m\in\mathcal{M}$ to generate a signature $\sigma$ on the message.
    %
    \item\textbf{VerSig} uses the public key $pk$ to verify whether
    a signature $\sigma$ was generated from a message $m$.
    %
\end{itemize}
%
%If the $\sigma$ output is Sign$(sk, m)$, then VerSig$(pk, m, \sigma) = true $. 
The output $\sigma =$ Sign$(sk, m)$ is called correct if VerSig$(pk, m, \sigma) = true $. 

%We say that a signature $\sigma$ is valid for a message $m$ when
 %$\Sigma.\text{VerSig}(pk, m, s) = true$.
%
Functional correctnes ensures that the verification process
succeeds for legitimate signatures.
%
\begin{definition}[Functional Correctness]
  \label{def:sig:correct}
  \begin{align*}
  \forall ~ m\in\mathcal{M} ~ pk ~ sk, ~ & (pk,sk) := \Sigma.\text{KeyGen} \Rightarrow\\
  & \Sigma.\text{VerSig} \: (pk, m, \Sigma.\text{Sign} \: (sk,m)) = true
  \end{align*}
  %
\end{definition}
%
A signature scheme is correct if,
for every pair $(sk, pk)$ the key generation produces, and
for every message $m$, the signing algorithm genreates a
signature that the verification algorithm accepts as a
valid signature for $m$.
%

\subsubsection{Unforgeability}
%
%As we mentioned before, in unforgeability, the adversary should not be able to create a valid signature on behalf of the legitimate signer, even if they have seen many valid signatures on other messages.
%
%Digital signature schemes are often anlayzed under two different variants of unforgeability, with Existential Unforgeability under Chosen Message Attack (EUF-CMA) and Strong Existential Unforgeability under a Chosen Message Attack (sEUF-CMA).
In the security of cryptographic protocols, the desired security property is captured as a game between 
an \emph{adversary} who tries to break the scheme's security 
and a \emph{challenger} who mediates interactions between the adversary and the signature 
scheme under some adversarial powers and stops trivial wins.

%
There are two security notions for signature schemes: 
the standard notion, Existential Unforgeability under Chosen Message Attack (EUF-CMA), 
and the \emph{strong} Existential Unforgeability under Chosen Message Attack (sEUF-CMA). 
%
%For a public digital signature scheme $\Sigma$, we define
%Existential Unforgeability in the setting of a Chosen
%Plaintext Attack (EU-CPA)~\cite{goldwasser1988digital}.
%
%Two variants of EU-CMA exist.
In EUF-CMA~\cite{goldwasser1988digital}, the adversary has to forge a signature of
any \emph{new} message, i.e., a message \emph{without} a
previously generated signature.
%
Here, we only focus on the stronger notion, sEUF-CMA, where the adversary
has to forge a signature of any message, i.e., including messages
\emph{with} a previously generated 
signature. 
%
The formal definition of sEUF-CMA is defined in in~\ref{def:seuf-cma}.
%
\begin{definition}[sEUF-CMA]\label{def:seuf-cma}
  A digital signature scheme $\Sigma$ is strongly
  existentially unforgeable	under a chosen message attack if for any
  probabilistic polynomial-time adversary $\mathcal{A}$,
  the probability of forging a new, valid signature for any message—including previously 
  signed messages—is negligible. 
  The advantage of $\mathcal{A}$ in breaking the sEUF-CMA security is
%	\[
%  \text{Adv}_{(\Sigma,\mathcal{A})}^{\text{sEUF-CMA}} :=
 % \text{Pr}\big[ \text{Exp}_{\Sigma}^{\text{sEUF-CMA}}(\mathcal{A})\big]< \text{negl}
%  \]
%
  \[
  \text{Adv}_{\Sigma}^{\text{sEUF-CMA}} (\mathcal{A}) :=
  \text{Pr}\big[ \text{Exp}_{(\Sigma,\mathcal{A})}^{\text{sEUF-CMA}}()\big]< \text{negl}
  \]
  %
  where the \(Exp_{\Sigma}^{\text{sEUF-CMA}}\) is defined in Figure~\ref{fig:problem:eu}. 
  %
\end{definition}
%
Following the figure, the left-hand side is the \emph{challenger}, 
which displays the signing oracle answering queries, whereas the right-hand side is the \emph{adversary}.
%
The adversary queries and maintains the set $\mathcal{S}$ before attempting to forge. 
%
The adversary is assumed to have access to a set of valid message-signature pairs.
%
This so-called \emph{Oracle access} is accounted for in the
according (security) game for the proof.
%
The adversary generates messages and inquiries according to signatures.
%
If the adversary can produce a message-signature pair,
 s/he successfully forged the signature.
%
%\sa{not sure as it talks abt euf}The statement ``assert" confirms that the forged signature is valid and not reused, 
%translating the essence of strong unforgeability. 
%
%Note, the main difference between standard and strong unforgeability 
%is that the adversary $(\mathcal{A})$ must output a pair $(m, \sigma)$ such that if 
%$\Sigma.Ver(pk, m, \sigma)=true$, and 
%$(m, \sigma)$ is not equal the pairs returned by Sign, then $\mathcal{A}$ wins the game.
%
Note that the main difference between the standard and strong EUF-CMA is that in EUF-CMA, the adversary cannot create a 
signature for any new messages which s/he has not seen signed before. 
%
The strong EUF-CMA stops creating new signatures for 
messages that have already been signed.
%
In other words, the adversary cannot modify 
existing signatures to create a new valid one for the same message. 
%

The following Game~\ref{game:seuf-cma} illustrates the security of digital signatures ($\Sigma$) under sEUF-CMA (we follow game-based proofs).
%
Game-based proofs~\cite{shoup2004sequences} are an approach that proves cryptographic properties (e.g., correctness, indistinguishability, and unforgeability) 
by modelling the adversary's interaction with the system as a sequence of games. 
%
Their proof-reasing follows \textit{probabilistic relational Hoare logic} (pRHL)~\cite{barthe2009formal}.
%
Each game shows a phase in an attack to show that no efficient adversary can distinguish between 
real and ideal circumstances, proving the scheme's security. 
%
\begin{figure}
  \begin{game}\label{game:seuf-cma} %[\underline{$\text{Expt}_{\Sigma}^{\text{sEUF-CMA}}(\mathcal{A})$}]\label{game:seuf-cma} 
    \texttt{\underline{$\text{Exp}_{(\Sigma, \mathcal{A})}^{\text{sEUF-CMA}}( )$}}
    \begin{itemize}
      \item The \emph{challenger} generates a key pair $(sk,pk)\leftarrow \Sigma.KeyGen()$ and provides the public key $pk$ to $\mathcal{A}$.
      \item For the \emph{signing queries}, $\mathcal{A}$ adaptively issues signature queries $m_1,\dots,m_q$ to the \emph{challenger}. 
      % 
      To each query $m_i$, the \emph{challenger} outputs $\sigma_i \leftarrow \Sigma.Sign(sk, m_i)$ and 
      stores in $(m_i, \sigma_i)$ in the set $S$.
      \item To attempt the forger, $\mathcal{A}$ outputs a candidate forgery $(m_\mathcal{A}, \sigma_\mathcal{A})$.
      \item $\mathcal{A}$ wins if:
      \begin{enumerate}
        \item $\Sigma.VerSig(pk, \sigma_\mathcal{A}, m_\mathcal{A}) = 1/true$, which means the signature is valid, and
        \item $(m_\mathcal{A}, \sigma_\mathcal{A}) \neq S $, which means it is not previously signed message-signature pair.
      \end{enumerate} 
    \end{itemize}
  \end{game}
\end{figure}
%
%
\begin{figure*}
	\centering
	\begin{subfigure}[b]{0.8\columnwidth}
		\centering
		\input{tikz/eu-sig-prot}
		\caption{Exp$_\Sigma^{\text{sEUF-CMA}}$ Game}
		\label{fig:problem:eu}
	\end{subfigure}
%
	\begin{subfigure}[b]{0.8\columnwidth}
		\centering
		\input{tikz/sig-indist}
		\caption{Primitives
        $ \mathcal{G}_{\text{ \textcolor{lGray}{R} \textcolor{lYellow}{I}} }^{\Sigma}$ 
    }
    %$\mathcal{G}_{real}\approx_0\mathcal{G}_{ideal}$
		\label{fig:problem:ind}
	\end{subfigure}
%
	\begin{subfigure}[b]{0.4\columnwidth}
		\centering
		\input{tikz/sig-ind-prot}
		\caption{Protocol}
		\label{fig:problem:eu-ind}
	\end{subfigure}
  \caption{
    %
	Secure Signatures:
    %
    \ref{fig:problem:ind}) the (classic) 
    security game for strong existential unforgability for the \emph{protocol of secure signatures}~\cite{goldwasser1988digital},
    %
    \ref{fig:problem:ind}) indistinguishability
    between a real and an ideal (,i.e, semantic) implementation
    for the primitives of secure signatures~\cite{joy,companion}, and
    %
    \ref{fig:problem:eu-ind} indistinguishability
    between the real and the ideal (i.e., semantic) composition
    of the \emph{protocol for secure signatures}.
    %
    We (informally) argue that \ref{fig:problem:ind} captures
    the same notion of security as \ref{fig:problem:eu-ind}.
    %
  }
	\label{sig-defs}
\end{figure*}


\subsection{Indistinguishability}
%
Figure~\ref{sig-defs} gives an overview and outlines the 
three levels of formalization of secure digital signatures. 
%
It highlights how these levels of abstraction can help us formalize from 
traditional (pen-and-paper) proofs to machine-checked verification, 
specifically in the context of remote attestation. 
%
The formalization progresses from the traditional definition of sEUF-CMA (Figure~\ref{fig:problem:eu}) and 
transitions to indistinguishability-based with game-based security proofs (Figure~\ref{fig:problem:ind}) and 
finally integrates these reasonings into protocol-level security (Figure~\ref{fig:problem:eu-ind}). 
%
The reason for reaching the protocol level is that this approach could 
be used to analyze a broader system before delving into individual parts. 
%
So, by establishing the security guarantees at the protocol level first, 
we would want to deliver a foundation for displaying that the underlying 
primitives preserve these guarantees when instantiated. 
%

Now, to extend our game to indistinguishability~\cite{ssprove,joy,companion}, 
we define a \emph{game pair} (as shown in Figure~\ref{fig:problem:ind}).
%
In the \emph{game pair} ($ \mathcal{G}_{\text{ \textcolor{lGray}{R} \textcolor{lYellow}{I}} }$), 
the $\mathcal{G}_{\real}$ portrays the signature scheme's actual behaviour.
%
In the ($\mathcal{G}_{\ideal}$), 
the adversary interacts with the theoretical perfect simulator (provided simulated, randomized signatures). 
%
So, the scheme becomes indistinguishable if no adversary can differentiate between these two with non-negligible advantages. 
%
Thus, this indistinguishability guarantees the equivalence of simulated and real settings, bridging unforgeability and 
indistinguishability in the security analysis of digital signature schemes. 
%
The following definition formally defines perfect indistinguishability.
%
%\begin{definition}[Indistinguishability ($\approx$)~\cite{ssprove}] \sa{which ref in ?}
	%Let $\mathcal{G}_1$ and $\mathcal{G}_2$ be two games with a common interface.
  %We say that $\mathcal{G}_1$ and $\mathcal{G}_2$ are indistinguishable, 
  %denoted $\mathcal{G}_1\approx\mathcal{G}_2$, 
  %if for all probabilistic polynomial-time (ppt) programs $\mathcal{A}$, that output a single bit, the following holds:
  %
  % $$\text{Adv}_{\mathcal{A}} = |\;\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_{1}\big]-\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_{2}\big]\;| $$
  %, where, $\mathcal{G}_1$ represents the real game and $\mathcal{G}_2$ represents an ideal game.
  %The probability that adversary $\mathcal{A}$ wins in the two games is denoted as:
  %$\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_1\big]$ and $\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_2\big]$
  %
  %where $\mathcal{A}\circ\mathcal{G}_1$ refers to the $\mathcal{A}$'s interaction 
  %or composition with real game ($\mathcal{G}_{1}$),
  %and
  %
  % $\mathcal{A}\circ\mathcal{G}_2$'s composition with ideal game ($\mathcal{G}_{2}$).
  %
  %We define a probabilistic polynomial-time (ppt) adversary $\mathcal{A}$ which interacts with both games.
  %
  %The advantage of adversary in distinguishing between $\mathcal{G}_1$ and $\mathcal{G}_2$ is given by:
  %
  %$$\text{Adv}_{\mathcal{A}} = |\;\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_{real}\big]-\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_{ideal}\big]\;|. $$
  %
%\end{definition}

%
\begin{definition}[Perfect Indistinguishability ($\approx_0$)~\cite{ssprove,joy,companion}]
	Let two games $\mathcal{G}_1$ and $\mathcal{G}_2$, have a common interface.
  %
  We say that $\mathcal{G}_1$ and $\mathcal{G}_2$ are perfectly indistinguishable, denoted by 
  $\mathcal{G}_1\approx_0\mathcal{G}_2$ if, 
  for all probabilistic polynomial-time (ppt) adversaries $\mathcal{A}$,
  the distinguishing advantage satisfies as :
  %
  $$\text{Adv} (\mathcal{G}_1, \mathcal{G}_2) (\mathcal{A}) 
  = |\;\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_{1}\big]-\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_{2}\big]\;| = 0 $$
  %
  where $\mathcal{A}\circ\mathcal{G}_1$ refers to the adversary 
  interacting with \real game ($\mathcal{G}_{1}$), 
  and 
  $\mathcal{A}\circ\mathcal{G}_2$ refers to the adversary 
  interacting with \ideal game ($\mathcal{G}_{2}$).
\end{definition}
%
This definition implies that no adversary, regardless of computational power, 
can distinguish between $\mathcal{G}_{1}$ and $\mathcal{G}_{2}$ with any nonzero advantage. 
%
Unlike indistinguishability, which only needs the advantage to be 
negligible, perfect indistinguishability ensures exact equality to zero. 
%
%
%
  %We say that $\mathcal{G}_1$ and $\mathcal{G}_2$ are indistinguishable, denoted $\mathcal{G}_1\approx_0\mathcal{G}_2$, if for all $ppt$ programs $\mathcal{A}$, that output a single bit, the following holds:
	%  $$\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_1\big]\approx\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_2\big].$$
	% We call $$|\;\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_1\big]-\text{Pr}\big[\mathcal{A}\circ\mathcal{G}_2\big]\;|$$
	% the advantage of $\mathcal{A}$ in distinguishing $\mathcal{G}_1$ and $\mathcal{G}_2$.

%Indistinguishability in digital signature schemes refers to the security notion that an adversary cannot
%distinguish between a real signature (generated according to the defined scheme) and a randomized signature (from an idealized version).
%We define this notion following~\cite{joy,companion}.
%
%
%\textbf{Perfect Indistinguishability ($\approx_0$)}: %~\cite{ssprove}:
%We define the \emph{game pair} ($ \mathcal{G}_{\text{IND}}^{\Sigma}$) (as shown in Figure~\ref{fig:problem:ind}) as 
%perfectly indistinguishable as defined in \ssprove~\cite{ssprove}. 
%If the probabilistic polynomial-time (ppt) adversary, $\mathcal{A}$, interacts with $\mathcal{G}_{1}$ 
%and $\mathcal{G}_{2}$, then
% $ \mathcal{G}_{\text{indist}}^{\Sigma} (\mathcal{A}) = 0$. 
% We say the advantage of $\mathcal{A}$ in distinguishing $\mathcal{G}_{1}$ and $\mathcal{G}_{2}$ is:
% $$(\mathcal{G}_{1} \approx_0 \mathcal{G}_{2}) := (\text{Adv}(\mathcal{A}) \leq 0 ).$$
%

In our formal development for indistinguishability-based reasoning (Figure~\ref{fig:problem:ind}), 
the main distinction between these two games lies in how the verification process 
interacts with the set $S$ of signed messages check. 
%
The game for \real follows the standard signature scheme, 
while the game for \ideal strictly tracks whether a queried signature derives from the signing oracle $S$. 
%
Here, the key observation is that the verification outcome `$b$’ in the game $\mathcal{G}_{\real}^{\Sigma}$ 
corresponds to the output `$b$’ in the game $\mathcal{G}_{\ideal}^{\Sigma}$. 
%
In case `$b$’ is \emph{false}, the adversary's attempts to forgery have trivially failed, and the proof structure ensures that 
the adversary's success probability remains negligible (does not need further reasoning as the adversary lost by definition). 
%
In case `$b$’ is \emph{true}, the adversary has successfully generated a valid signature, and we need to check if this 
signature was generated by the genuine signing operation (appears in the set $S$) or if it forms a new forgery. 
%
If the message-signature pair appears in the set $S$, then the adversary did not forge anything new. 
%
If the pair was not in the set $S$, the adversary has forged the new signature. 
%

\subsection{State-separating proofs with SSProve}
%
This section briefly introduces syntactical constructions used in the \ssprove library in \coq.
%
Readers familiar with SSP can safely skip this section.
%
SSProve is a \coq library that implements the State-Separation Proof (SSP) methodology to provide a framework for cryptographic proofs~\cite{ssp}.
%

\paragraph{Packages}
%
A packages in \ssprove defines a set of procedures that
operate on a common state.
%
We present a simple package in Figure~\ref{fig:package}.
%
A package \emph{imports} procedures, i.e., procedure types,
and \emph{exports} own procedures.
%
Example package $\mathcal{E}$ defines and exports procedure \icoq{z}.
%
The definition of \icoq{z} depends on imported procedure types
\icoq{x} and \icoq{y}.
%
\ssp defines and \ssprove implements sequential composition
$\circ$ for packages.
%
For example, two packages, $\mathcal{E}_1$ and $\mathcal{E}_2$, with 
\emph{import} ($\mathcal{E}_1$) $\subseteq$ \emph{export} ($\mathcal{E}_1$) is $\mathcal{E}_1 \circ \mathcal{E}_2$, 
are accepted by inlining procedure definitions each time $\mathcal{E}_1$ calls a procedure $\mathcal{E}_2$. 
%
%For example, $\mathcal{O} \circ \mathcal{E}$ requires $\mathcal{O}$ to define procedures \icoq{x} and \icoq{y}.
%
\begin{figure}
  \centering
  \input{tikz/package}
	\caption{A package $\mathcal{E}$ in \ssprove.}
  \label{fig:package}
\end{figure}
%

\paragraph{Procedures}
%
For the definition of a procedure, \ssprove provides
a language that is based on the notion of a state monad \icoq{code}
to account for operations on the package state
and sampling from distributions~\cite{10.1145/143165.143169}.
%
The \cget and \cput commands allow monadic read and write
access to state locations.
%
To keep the listings concise, we abstract over the
locations and denote \icoq{@}$\mathcal{S}$ to denote
the memory location for \icoq{@}$\mathcal{S}$.
%
Other monadic operations are \cassert statements
and sampling values (\csample) from a probability
distribution over finite spaces\footnote{\icoq{n <$} $\mathbb{N}_6$ is
notation for \icoq{n <- sample} $\mathbb{N}_6$.}.
%
\ssprove allows the embedding of \coq expressions such as
\icoq{z + n} into the code of a procedure.
%
Values may enter into the \icoq{code} monad
via the usual \cret command.
%
Throughout the paper, we mark all commands with a \texttt{\#}. 
%
All imports and exports are monadic procedures and
part of the composition requires to match up the
states of the composed packages.
%
For the imports and export of the example package %\p (gives an error)
in Figure~\ref{fig:package}, we omitted this detail.
%

In our formal development in \ssprove, the protocol-level 
abstraction (Figure~\ref{fig:problem:eu-ind}) 
presents secure signatures as black-box functionalities to ensure their composability in the cryptographic protocols. 
%
This composition guarantees that the signature scheme's security is directly 
related to the protocol's security (as shown in Figure~\ref{fig:pprot}). 
%
While protocol-level abstraction provides applicable reasoning, 
we use primitive-level reasoning to grasp additional security properties. 
%
Especially in \ra, signatures are used to authenticate system states, 
and confirming their security involves more than existential unforgeability. 
%
The insight is that primitive-level reasoning lets anyone analyze security 
beyond a single protocol instance.
%
During our development, whilst defining the indistinguishability games, we figured that the collision resistance property 
was essential for the primitives of \ra but not necessarily required for the protocol's security. 
%
Proving this property in the security of \ra means that we need more in-depth cryptographic reasonings which expand beyond protocol correctness. 
%
Also, even though \ssprove is a helpful tool for structured verification, the tool struggles to align with traditional cryptographic reasoning. 
%
Like other tools, the challenge is translating cryptographic proofs 
into machine-checked settings that frequently lack the flexibility to grab intuitive security statements. 
%
Therefore, we establish the equivalence between strong unforgeability and indistinguishability to bridge this gap, 
and we present that both perspectives still direct to the same security guarantees. 
%

%\todo{Is the below text still needed?}
%In our formal development, the indistinguishability-based definition for secure signatures is illustrated in Figure \ref{fig:problem:ind}. 
%
%Indistinuishability proofs in \ssprove are game-based.
%A \emph{game} is simply a packages with no imports.
%A \emph{game pair} is then a pair of packages with the same exports.
%An industinuishability statement about two games\icoq{G}$_1$ and \icoq{G}$_2$ reasons about the advantage of an attacker.
%An \emph{attacker} is a package that imports all exports from game packages.
%
%\begin{minted}[escapeinside=@@]{Coq}
%  Definition Adv A G@$_1$@ G@$_2$@ := @$|$@ A @$\circ$@ G@$_1$@ - A @$\circ$@ G@$_2$@ @$|$@.
%  \end{minted}
%
%\begin{definition}[Advantage]\label{def:advOfA}
% That is, the adavantage of an attacker $\mathcal{A}$
% is defined as:
% \[ \text{Adv } \mathcal{A} \: \mathcal{G}_1 \, \mathcal{G}_2 := | \mathcal{A}\circ\mathcal{G}_{1} - \mathcal{A}\circ\mathcal{G}_{2} | \]
%\end{definition}
%
%For the upcoming section, it suffices to understand that
%indistinguishability %\mintinline{Coq}{G}$_1 \indist$ \mintinline{Coq}{G}$_2$ means
%$\mathcal{G}_1 \indist \mathcal{G}_2$ means
%
%\begin{minted}[escapeinside=@@]{Coq}
%Adv A G@$_1$@ G@$_2$@ = 0.
%\end{minted}
%
%\[ \text{Adv} \; \mathcal{A} \; \; \mathcal{G}_1 \; \mathcal{G}_2 = 0. \]


%\todo{
    %
% The reasoning from the left figure to the right figure in the overview
 %needs to establish an outline for the reader.
   %
% It needs to tell the reader why we are talking about protocols first and
 %and only then about primitves.
   %
% My take would be to show the cryptographer's reasoning here first which argues for the protocol approach.
   %
% Once we have shown the protocol approach, we show actually that reasoning about primitives is valuable because:
   %
% \begin{itemize}
     %
%     \item We get new properties because we do not reason only about one          specific case.
%     \item And we see that the reasoning of the cryptographers is not easily
 %        doable in tools such as SSProve and maybe even the whole theory        behind it.
 %\end{itemize} }

