\section{A Formal Specification for Digital Signatures}
\label{sec:sig}

%
In this section, we present our formal specification of digital
signatures and verify that it is secure against forgery. 
%
First, we present an overview of our specifications and fix their notations.
%
Afterwards, we specify the package for key generation.
%and state its assumptions for concrete implementations such as RSA. 
%
Then, we followed the specifications for digital signatures. 
%
First, we define the packages and then provide details for proof of 
game-based indistinguishability (perfect).
%

\subsection{Overview and Notations}
%
Our development has two parts: the composition of the packages
and the proof development to establish the security properties.
%

\subsubsection{Package Composition}

\begin{figure*}
	\centering
	\input{tikz/overview}
	\caption{
  %
  Our formal specification of remote attestation is based on digital signatures.
  %
  The security reasoning is based on the concept of indistinguishability
  for a game pair \real, which represents the actual code,
  and \ideal, which represents the model, i.e., the semantics
  of the real code
  in the context of indistinguishability proofs.}\label{fig:overview}
\end{figure*}


\begin{figure}
  \centering
  \input{tikz/prot-pkg}
  \caption{The protocol package for digitial signatures.}
  \label{fig:pprot}
\end{figure}
%
Figure~\ref{fig:overview} visualizes our specification using SSP-style
visualization for package composition.
%
In the figure, we accordingly highlight \real (shaded in grey) and 
\ideal (shaded in yellow) packages.
%
Our specification builds upon a key generation package \pkeygen that
establishes the probabilistic foundation.
%
The package \pkeygen abstracts over a concrete foundation to allow
for various instantiations such as RSA and ECDSA.
%
A full specification for the instantiation with RSA is in Appendix~\ref{sec:rsa}
with the details in the proof development.
%
The package \pkeygen exports a \ekeygen procedure for the packages that
define the \real and \ideal signature
primitives.
%
%Figure~\ref{fig:problem:eu-ind} shows that the composition of \prot \sa{SigProt?} with 
%packages \real and \ideal for signature
%primitves instantiates the protocol for digitial signatures.
%
%The protocol remains unchanged for remote attestation such that
%we can compose \pprot similarly with the \real and \ideal packages 
%for the remote attestation primitives.
%

\subsubsection{Proof Development}
%
Our proof development shows that our structured approach proves 
the security of signatures by establishing an equivalence between 
sEUF-CMA and indistinguishability-based security. 
%
The main idea is that if a signature scheme is secure with strong unforgeability, 
then the probability of forging a valid signature for the previously signed message is negligible. 
%
The signature verification in $\mathcal{G}_{\real}^{\Sigma}$ returns true with a valid message-signature pair. 
%
By the definition of strong unforgeability assumption, the $\mathcal{G}_{\ideal}^{\Sigma}$ must also return true, 
as any valid signature must have been generated by singing primitive. 
%
This ensures that the real and ideal signature verification processes remain indistinguishable. 
%
Contrariwise, if the real and ideal signature packages are 
indistinguishable, it implies that the ideal one must also 
accept any valid message-signature pair accepted by the real package. 
%
If an adversary could forge a valid signature, the real package would return \emph{true}, 
while the ideal package would return \emph{false}. 
%
By ensuring that the adversary can not distinguish these two cases, 
we naturally guarantee that forging a new signature is infeasible. 
%
This reasoning extends to both fresh and previously signed messages, which leads 
to the judgment that indistinguishability implies sEUF-CMA. 
%

Our proof construction establishes indistinguishability, i.e.,
strong existential unforgeability, for digital signatures based on
the protocol packages (Theorem~\ref{theo:indist-signature}). 
%
Theorem~\ref{theo:redprot} is a reduction theorem and states that
the security of remote attestation is smaller or equal to the
security of digital signatures.
%
Theorem~\ref{theo:indist-ra} then uses Theorem~\ref{theo:indist-signature}
and Theorem~\ref{theo:redprot} to verify strong existential
unforgeability of remote attestation.
%


\subsection{Key Generation}

\begin{figure}
	\centering
    \begin{subfigure}[b]{\columnwidth}
    \centering
       \begin{minted}[fontsize=\footnotesize,escapeinside=@@,autogobble]{coq}
Parameters SecKey PubKey : finType.
Parameter  @$\Sigma$.@KeyGen : @$\forall$@ s, code s (PubKey Ã— SecKey).
		  	\end{minted}
      \caption{Parameters.}
	    \label{fig:keygen:params}
    \end{subfigure}
\\[0.3cm]
  \begin{subfigure}[b]{\columnwidth}
    \centering
    \input{tikz/keygen-pkg}
    \caption{Package.}
    \label{fig:keygen:package}
  \end{subfigure}
  \caption{
    %
    The \pkeygen package and its parameters.
    %
  }
  \label{fig:keygen}
\end{figure}

%
Following the (textbook) definitions from Section~\ref{sec:TheoryFound},
we define the package \pkeygen in Figure~\ref{fig:keygen}.
%
We leave the definition of the secret key (\lseckey)
and the public key (\lpubkey) abstract as parameters
and just require them to be of a finite type.
%
Similarly, we parameterize the package with an algorithm
$\Sigma$.\pkeygen that implements the final key generation.
%
We do not import this algorithm because otherwise, we cannot play
the security game: game packages cannot have imports.
%
The algorithm $\Sigma$.\pkeygen nevertheless emits monadic code
because it needs to sample the keys from a distribution.
%
This differs from the textbook definition, which states that the $\Sigma$.KeyGen
is a pure function.
%
The $\Sigma$.\pkeygen is polymorph in the state \icoq{s}, i.e.,
it has no side-effects to the state other than for sampling.
%
The \egetpk procedure stores the generated secret and public
keys into its state and returns them both.
%
We are now ready to specify digital signatures.
%
We start with defining the primitives, and
afterwards, we compose the protocol games to prove perfect indistinguishability, 
i.e., strong existential unforgeability for digital signatures.
%

\subsection{Primitives}

\begin{figure}
	\centering
   \begin{subfigure}[b]{\columnwidth}
    \centering
        \begin{minted}[fontsize=\footnotesize,escapeinside=@@,autogobble]{coq}
Parameters Message Signature : finType.
Parameter  @$\Sigma$@.Sign : SecKey -> Message -> Signature.
Parameter  @$\Sigma$@.VerSig :
  PubKey -> Signature -> Message -> bool.
	\end{minted}
    \caption{Parameters}
    \label{fig:sigprim:params}
  \end{subfigure}
\\[0.3cm]
   \begin{subfigure}[b]{\columnwidth}
    \centering
        \begin{minted}[fontsize=\footnotesize,escapeinside=@@,autogobble]{coq}
Hypothesis sig_correct :
  @$\forall$@ m sk pk,
    ((sk,pk) <- @$\Sigma$@.KeyGen) ->
    @$\Sigma$@.VerSig pk (@$\Sigma$@.Sign sk m) m == true.
	\end{minted}
    \caption{Functional Correctness}
    \label{fig:sigprim:hypo}
  \end{subfigure}
\\[0.3cm]
\begin{subfigure}[b]{\columnwidth}
    \centering
    \input{tikz/sig-real-vs-ideal}
    \caption{Packages}
    \label{fig:sigprim:packages}
  \end{subfigure}
	\caption{
    %
    The \real and \ideal Signature Primitives packages
    and their parameters and hyptohesis.
    %
    }
	\label{fig:sigprim}
\end{figure}

%
Figure~\ref{fig:sigprim} defines the abstractions and then
specifies the primitives for our digital signatures.
%

%
In line with the (textbook) definition presented in
Figure~\ref{fig:problem:ind}, our implementation of
the signature primitives abstracts over a concrete
signature scheme.
%
In Figure~\ref{fig:sigprim:params}, we abstract over concrete
implementations for messages and signatures.
%
The abstractions for signing a message and verifying a signature
complete Definition~\ref{def:sig:scheme} of a signature scheme $\Sigma$.
%
Note that both $\Sigma$\icoq{.Sign} and $\Sigma$.\icoq{VerSig}
are pure functions because they neither sample nor access any state.
%
Functional correctness (Definition~\ref{def:sig:correct}) is then
a hypothesis of our primitives for digital signatures (Figure~\ref{fig:sigprim:hypo}).
%

%
We specify the \real and \ideal packages for the primitives
of our digital signatures in Figure~\ref{fig:sigprim:packages}.
%
Our specification pays attention to accessing and updating
the state, e.g., for the set \icoq{S} of observed signatures in the
\ideal package.
%
Both packages import \ekeygen to obtain the
public key \icoq{pk}.
%
Note again that \ekeygen stores the generated keys \icoq{sk}
and \icoq{pk} into its state.
%
Respectively, the state of \pkeygen needs to be a
subset of the state of each package such that \esign and
\eversig can access the keys.
%
Apart from these implementation details,
both package definitions follow the (textbook)
specification from Figure~\ref{fig:problem:ind}.
%


\subsection{Indistinguishability}

\begin{figure}
    \begin{minted}[fontsize=\footnotesize,escapeinside=&&,autogobble]{coq}
Definition SigProt&$_{\text{\real}}$& :=
  {package SigProt &$\circledcirc$& SigPrim&$_{\text{\real}}$& &$\circ$& KeyGen}.

Definition SigProt&$_{\text{\ideal}}$& :=
  {package SigProt &$\circledcirc$& SigPrim&$_{\text{\ideal}}$& &$\circ$& KeyGen}.
    \end{minted}
   \caption{Protocol games for digital signatures.}
   \label{fig:sigprot}
\end{figure}

%We prove security against forgery for our digital signaturesbased on the generic protocol \pprot.
%In order to establish the game for this proof, we need a \real and \ideal protocol package.
%We construct both packages via package composition.
%
To prove the security against forgery for our digital signatures, 
we establish a \emph{game pair} for this security proof. 
%
We construct a \real and \ideal protocol package, as shown in Figure~\ref{fig:sigprot}. 
%
The \real protocol package
\psigprot$_{\text{\real}}$ is a composition of packages
Sig\prot, \psigprim$_{\text{\real}}$ and \pkeygen. 
%\pkeygen, \psigprim$_{\text{\real}}$ and \pprot.
%
The respective \ideal package
\psigprot$_{\text{\ideal}}$ is a composition of packages
Sig\prot, \psigprim$_{\text{\ideal}}$ and \pkeygen.
%pkeygen, \psigprim$_{\text{\ideal}}$ and \pprot.
%
We use the special notation $\circledcirc$ to denote a composition
up to renaming procedures \esign to \icoq{challenge} and
\eversig to \icoq{verify}%
\footnote{
%
In \ssprove , this is not necessary because procedure names map
to a particular natural number.
%
Mapping different procedure names to the same natural numbers
establishes the link without an auxilary package for renaming
procedures.
%
}.
%
The game that we play, and respectively, the theorem that we prove,
establishes perfect indistinguishability between the \real and 
the \ideal protocol package (Figure~\ref{fig:sigprim:packages}).

%
\begin{theorem}[%\icoq{SigProt_}$\mathcal{G}_{\text{\pindist}}^{\Sigma}$: 
  Perfect Indistinguishability of Digital Signatures]\label{theo:indist-signature}
  %
  For every attacker \A, the advantage to distinguish the packages
  \psigprot$_{\text{\real}}$ and \psigprot$_{\text{\ideal}}$ is $0$:
  %
  \begin{center}
    \begin{minipage}{0.5\columnwidth}
    \begin{minted}[fontsize=\footnotesize,escapeinside=&&,autogobble]{coq}
SigProt&$_{\text{\real}}$& &$\pindist$& SigProt&$_{\text{\ideal}}$&.
    \end{minted}
    \end{minipage}
    \end{center}
\end{theorem} 

%
\begin{figure}
\begin{center}
\begin{minipage}{0.9\columnwidth}
\begin{minted}[escapeinside=@@,fontsize=\footnotesize,autogobble,linenos]{Coq}
@$\vdash$@
{ @$\lambda$@ (s@$_1$@, s@$_2$@),
  let inv := heap_ignore @$\{\mathcal{SIG}\}$@ in
  let h   := inv @$\rtimes$@ rm_rhs @$\mathcal{SIG}$@ S in
  let h'  := set_rhs @$\mathcal{SIG}$@ (S @$\cup$@ @$\{$@(@$\Sigma$@.Sign sk m, m)@$\}$@ h in
  let h'' := h' @$\rtimes$@ rm_rhs @$\mathcal{SIG}$@ S' in
  h'' (s@$_1$@, s@$_2$@)) }
ret (pk, @$\Sigma$@.Sign sk m, @$\Sigma$@.VerSig pk (@$\Sigma$@.Sign sk m) m)
@$\approx$@
ret (pk, @$\Sigma$@.Sign sk m, (@$\Sigma$@.Sign sk m, m) @$\in$@ S')
{ @$\lambda$@ (s@$_1$@,r@$_1$@)
    (s@$_2$@,r@$_2$@), r@$_1$@ = r@$_2$@ @$\land$@ heap_ignore @$\{\mathcal{SIG}\}$@ (s@$_1$@, s@$_2$@) }
\end{minted}
\end{minipage}
\end{center}

\caption{
  %
  The final step in the proof of the Theorem \icoq{SigProt_}$\mathcal{G}_{\text{\pindist}}^{\Sigma}$ reduces it to \icoq{sig_correct}.
  %
}
\label{fig:ind:proof}
\end{figure}
%
%
\begin{IEEEproof}
%[Proof of \icoq{SigProt_}$\mathcal{G}_{\text{\pindist}}^{\Sigma}$]
The according proof (game) is a straight forward application of
\ssprove tactics that reduce the goal to the judgement in Figure~\ref{fig:ind:proof}.
%
We use the \icoq{heap_ignore} invariant that is already defined in
\ssprove to state that
\icoq{s}$_1$, the state of the \real package, and
\icoq{s}$_2$, the state of the \ideal package are equal up to
the $\mathcal{SIG}$ location.
%
The proof process extends this invariant in the precondition
with a trace of reads from state into local variables and
updates to state (Lines~4--6).
%
The commands for the \real (left) and \ideal (right) commands
are equal up to the third element of the returned triple.
%
Clearly, the trace contains the evidence (Line~5) that the
signature--message pair really is in \icoq{S'} (Line~10).
%
This allows us to reduce the indistinguishability to the equality
%
\begin{minted}[escapeinside=@@,autogobble]{Coq}
@$\Sigma$@.VerSig pk (@$\Sigma$@.Sign sk m) m = true
\end{minted}
%
which is the functional correctness Hypothesis \icoq{sig_correct}
of the signature scheme $\Sigma$.
%
\end{IEEEproof}



