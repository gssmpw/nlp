\section{Foundationally Proving Indistinguishability using SSProve}
\label{sec:ssprove}
\sa{This section needs to go away but we need the below command lines in sec2.}




%
\ssprove is a \coq library that implements the State
Separation Proof (\ssp) methodology to provide a framework
for cryptographic proofs~\cite{ssp}.
%
This section gives a brief introduction and defines the notiation
that we use in the next sections for our formalization.\footnote{
Readers familiar with SSP can safely skip this section.}
%
First, we introduce packages and the syntactical constructions
to implement them.
%
Afterwards, we describe game-based security proofs as the
foundation to reasoning about security semantically.
%

\paragraph{Packages}

%
A packages in \ssprove defines a set of procedures that
operate on a common state.
%
We present a simple package in Figure~\ref{fig:package}.
%
A package \emph{imports} procedures, i.e., procedure types,
and \emph{exports} own procedures.
%
Package \p defines and exports procedure \z.
%
The definition of \z depends on imported procedure types
\x and \y.
%
\ssp defines and \ssprove implements sequential composition
$\circ$ for packages.
%
For example, $\oo \circ \p$ requires \oo
to define procedures \x and \y.
%

%
For the definition of a procedure, \ssprove provides
a language that is based on the notion of a state monad \mintinline{Coq}{code}
to account for operations on the package state
and sampling from distributions~\cite{10.1145/143165.143169}.
%
The \cget and \cput commands allow monadic read and write
access to state locations.
%
To keep the listings concise, we abstract over the
locations and denote \mintinline{Coq}{@}$\mathcal{S}$ to denote
the memory location for \mintinline{Coq}{@}$\mathcal{S}$.
%
Other monadic operations are \cassert statements
and sampling values (\csample) from a probability
distribution over finite spaces\footnote{\mintinline{Coq}{n <$} $\mathbb{N}_6$ is
notation for \mintinline{Coq}{n <- sample} $\mathbb{N}_6$.}.
%
\ssprove allows to embedded \coq expressions such as
\mintinline{Coq}{z + n} into the code of a procedure.
%
Values may enter into the \mintinline{Coq}{code} monad
via the usual \cret command.
%
Throughout the paper, we mark all commands with a \texttt{\#}.
%
All imports and exports are monadic procedures and
part of the composition requires to match up the
states of the composed packages.
%
For the imports and export of the example package \p
in Figure~\ref{fig:package}, we omitted this detail.
%

%
\paragraph{Game-based Proofs}
%
Indistinuishability proofs in \ssprove are game-based.
%
A \emph{game} is simply a packages with no imports.
%
A \emph{game pair} is then a pair of packages with the same
exports.
%
An industinuishability statement about two games
\mintinline{Coq}{G}$_1$ and \mintinline{Coq}{G}$_2$
reasons about the advantage of an attacker.
%
An \emph{attacker} is a package that imports all
exports from game packages.
%
That is, the adavantage of an attacker \mintinline{Coq}{A}
is simply
%
\begin{minted}[escapeinside=@@]{Coq}
Definition Adv A G@$_1$@ G@$_2$@ := @$|$@ A @$\circ$@ G@$_1$@ - A @$\circ$@ G@$_2$@ @$|$@.
\end{minted}
%
\se{
  %
  Indeed what does that actually mean when a package composition
  produces a real number.
  %
  At this point, this does not matter.
  %
  We need detail this point in the implications section.
  %
}
%
For the upcoming section, it suffices to understand that
indistinguishability \mintinline{Coq}{G}$_1 \indist$ \mintinline{Coq}{G}$_2$ means
%
\begin{minted}[escapeinside=@@]{Coq}
Adv A G@$_1$@ G@$_2$@ = 0.
\end{minted}
%
In Section~\ref{sec:imply}, we get back to the interesting
question of what it actually means for a package to produce
a real number.
%
Proof-reasing follows \textit{probabilistic relational Hoare logic} (pRHL)~\cite{barthe2009formal}.
%
Judgements in this logic are hoare triples
%
%
%@$\vDash\big\{(s_1,s_2).\phi\big\}\;c_1\thicksim c_2\;\big\{((s_1',r_1),(s_2',r_2)),\psi\big\}$$
\begin{minted}[escapeinside=@@,fontsize=\footnotesize,autogobble]{Coq}
  @$\vdash$@ { @$\lambda$@ (s@$_1$@,s@$_2$@), @$\phi$@ } c@$_1$@ @$\approx$@ c@$_2$@ { @$\lambda$@ ((s@$_1$@',r@$_1$@),(s@$_2$@',r@$_2$@)), @$\psi$@ }
\end{minted}
%
where the pre-condition $\phi$ is a proposition about initial states
\mintinline{Coq}{s}$_1$, \mintinline{Coq}{s}$_2$
and the post-condition $\psi$ is a proposition about the final states
\mintinline{Coq}{s}$_1'$, \mintinline{Coq}{s}$_2'$
and the results
\mintinline{Coq}{r}$_1$, \mintinline{Coq}{r}$_2$
produced by the commands
\mintinline{Coq}{c}$_1$, \mintinline{Coq}{c}$_2$
of games
\mintinline{Coq}{G}$_1$, \mintinline{Coq}{G}$_2$
respectively.
%

