\section{Introduction}\label{sec:Introduction}
Simulators play a fundamental role in robotics, e.g.  for developing dynamic multi-robot environments, control algorithms or action sequences.
Different simulators exist for different tasks, however, over the last years the open-sourced Robot Operating System (ROS) in combination with the physics simulator and visualization tool Gazebo \cite{quigley09}  has emerged as a standard environment  \cite{sarabakha2023}. \\
\begin{figure}[thpb]
      \centering
		\includegraphics[scale=0.25]{./pics/sphinx_gazebo.pdf}
\caption{Drones simulated in Sphinx (left image) are mirrored in Gazebo (central image), where they can be included in other, multi-robot simulations. Furthermore, our developed control frameworks allow accurate tracking of moving targets in simulation and the real world (right image) a common use case for which our simulation framework is a suitable choice.}
\label{fig:title_image}
 \end{figure}
It is common in research to design and build customized robots for specific purposes and experiments, which is usually a time-consuming process until all hardware-related issues have been solved. In this regard, commercial robotic platforms often provide a shortcut to quick deployment of a robotic system since these issues have been ruled-out by the manufacturer during the development phase of the product.  However, for scientific robotic applications this advantage is often diminished when no or only a simulation with limited interfaces or customization options is provided along with the robot. 

This problem is aggravated in complex multi-robot dynamic scenarios when robots of different types and different manufacturers need to be simulated at once. 
There are two ways to solve this problem.  First, either all robotic platforms are realized in a common simulation environment or second, the different simulations are interfaced and thus capable of exchanging data. Whereas the first way is often associated with a time consuming system identification with subsequent (re-)implementation of the real robots in the chosen simulator, the second way promises a quicker way to deployment of the system and therefore is the approach we follow in this paper. However, in this regard, often proprietary partially-open or closed-sourced simulators  suffer from two main accessibility problems that limit their utility to the scientific community. i) The state of dynamic actors in the simulation environment cannot be updated via common middleware such as ROS and ii) reading state values such as pose, velocity, accelerations etc. during runtime is blocked.


In this work we solve the aforementioned accessibility problems while focusing on a powerful consumer drone called \textit{Anafi} that is manufactured by Parrot Drone \cite{parrot_drone_sas}. For development, testing and mission planning a comprehensive simulation environment named Sphinx \cite{parrot_sphinx} is provided. Even-though scenes in which the drone operates can be customized using static and dynamic actors, being only partially open-source Sphinx suffers from the two aforementioned accessibility problems. This is a major drawback since the information about objects in the scene other than the Anafi drone is frequently required, e.g. during the design of a tracking controller and therefore the first limitation in using Sphinx. 

The second limitation in using Sphinx is the  PID-based controller framework provided with the firmware of the Anafi drone. A common application in aerial robotics is target tracking, e.g. \cite{tallamraju2018,tallamraju2019}. However, depending on the manoeuvrability of the target, agile tracking controllers are required. Feedback controllers such as the provided PID-based control framework are suitable only for slowly moving targets as otherwise large tracking offsets can occur. Furthermore, the PID control stack integrated in the firmware of the \textit{Anafi} drone shows a peculiar behaviour considerably limiting its applicability to target tracking tasks. Frequent updates to the target waypoint, a common practice in tracking scenarios, do not yield the anticipated smooth transition between successive waypoints of the drone. Instead, an oscillating motion characteristic can be observed, leading to slow response  behaviour which is illustrated by Figure \ref{fig:moveto}.

\begin{figure}[thpb]
      \centering
		\includegraphics[scale=0.37]{./pics/moveto.pdf}
\caption{Static waypoint tracked with the default PID-based controller (x-direction displayed only). The pitch angle reveals the oscillating motion and slow response. }
\label{fig:moveto}
 \end{figure}

A starting point to create a solution is given by the attitude controller of the \textit{Anafi} drone which accepts a continuous stream of roll, pitch, yaw and vertical velocity commands \cite{olympe_pcmd}. \\
Against this background, we address the aforementioned accessibility issues of Sphinx as well as the peculiar behaviour of the PID-based controller framework by introducing the following novel methods, as is illustrated by Figure \ref{fig:title_image}.
\begin{enumerate}
\item \textit{Sphinx-Gazebo integration}: We propose a ROS package that runs Sphinx in parallel with Gazebo. Being the better established framework, Gazebo is expected to contain the majority of simulated robots into which the \textit{Anafi} drone shall be integrated. We achieve this by creating a visualization of a  drone in Gazebo, which mirrors the flight behaviour of the \textit{Anafi} drone simulated in Sphinx. Communication between the simulators is realized using ROS and the \textit{anafi_ros} package \cite{sarabakha2023}. 
\item \textit{Target tracking control}: Using a novel concept of cumulative error states, we implement a quadratic MPC building on top of  \cite{tallamraju2018}. It is specifically  designed to reduce the target tracking error and runs efficiently with low computational cost. We also implement a customized PID-based controller in ROS solving the unwanted oscillating motion characteristic present in the  PID-framework provided in the \textit{Anafi} firmware. To this aim, the controller framework's output are roll, pitch, yaw and vertical velocity commands, which can be sent to the drone in a continuous fashion. We use our PID-based controller framework to compare the performance of our MPC against it.
 %It takes as input position waypoint commands and produces setpoints for the roll, pitch yaw and vertical velocity of the drone. 
\end{enumerate}
We demonstrate the efficacy of our two solution approaches as follows. First, we include the Anafi drone in the airship simulation \cite{price2022}. Second, we evaluate the performance of the MPC in simulated and real-world experiments by comparing it to our customized PID controller baseline.
The remainder of this paper is structured as follows. Related work is summarized in Section \ref{sec:related_work}, Section \ref{sec:methodology} contains information about the connection between Sphinx and Gazebo as well as the controller designs, followed by Section \ref{sec:implementation} explaining details of the implementation. The results are described in Section \ref{sec:experiments} before we conclude this work in Section \ref{sec:conclusion}.



\section{Related Work} \label{sec:related_work}
In general, there exist various universal purpose robotic simulators, e.g. Pybullet \cite{pybullet}, NVIDIA Isaac Sim \cite{isaac_sim} and MuJoCo \cite{todorov2012}. However, in the past years Gazebo  \cite{gazebo} has emerged as a widely used tool \cite{sarabakha2023} due to its easy integration into the ROS middleware \cite{quigley09}, a framework to exchange data in distributed networks running on different machines. It enables easy realization of multi-robot systems which can be seamlessly deployed in both simulation and on real hardware. 

In particular, in the field of aerial robotics several frameworks are available for the simulation of multi-rotor vehicles, e.g. Microsoft AirSim \cite{airsim}, a drone simulator which is realized as a plugin for Unreal Engine 4 (UE4). This enables running simulations with high graphic quality as is often required for AI-based applications.

Widely used multi-rotor drone simulators are PX4-SITL \cite{px4_sitl} and RotorS \cite{furrer2016}. Both rely on Gazebo for physics modelling and visualization thus highlighting the importance Gazebo holds within the robotic community. Whereas the former is build around the PX4 Autopilot ecosystem providing software and hardware components for autonomous control of unmanned aerial vehicles (UAVs), the latter focusses on simulation and control of multi-rotors as well as a variety of sensors.\\ %In this work, we built on top of RotorS by leveraging code and meshes for the visualization of the Anafi drone in Gazebo. Furthermore, we compare our MPC controller against the provided Lee controller of a drone of similar mass and size \textcolor{red}{Not sure if we wil do this}. 
Sphinx \cite{parrot_sphinx} is a simulator specifically designed for the simulation of the Anafi drone series distributed by Parrot Drone. Whereas both PX4-SITL and RotorS are fully open source simulators, the Anafi drone firmware and Sphinx simulator are proprietary, although customizable to a certain degree. The big advantage in using Sphinx is that it provides a testbed for  scenarios involving the high-end  drones of the Anafi series. Interfacing the drone firmware and thus retrieving the state of the drone is possible using the Olympe API \cite{parrot_olympe} for which \textit{anafi_ros} \cite{sarabakha2023} is a ROS-wrapper. This enables easy integration into ROS frameworks, however, integrating the Anafi drones into arbitrary Gazebo-based environments is not possible. \textit{anafi_autonomy} \cite{anafi_autonomy} is build on top of \textit{anafi_ros} and implements among mission planning features also a velocity controller. In order to  also provide a position and thus a tracking controller, we not only implement our own PID-based tracking framework but also an MPC which builds on top of \cite{tallamraju2018}. In this work, an efficient formulation of a MPC for tracking tasks featuring obstacle avoidance with high execution rate has been introduced. We  augment the dynamic model of the MPC with additional cummulative error states to minimize the constant tracking error while leaving out unnecessary components such as obstacle avoidance. For this task, we rely higher-level trajectory planning methods that send waypoints to the MPC. 

