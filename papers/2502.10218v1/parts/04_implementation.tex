\section{Implementation}\label{sec:implementation}
\subsection{General}
We set up the experiments to demonstrate
\begin{itemize}
\item  that our framework allows the integration of the Anafi drone into a complex multi-robot simulation in Gazebo.
\item  that our MPC  tracking controller (see Section \ref{sec:mpc}) outperforms in simulation and real world experiments  our customized PID controller framework (see Section \ref{sec:pid_controller_framework}). We introduced the latter to serve as a  baseline for the performance evaluation of the MPC while addressing the shortcomings of the PID control stack which is implemented in the Anafi firmware and provided by Parrot Drone.
\end{itemize}
\subsection{Simulation Environment}
All simulations were conducted on a desktop computer with the following specifications. Ubuntu 20, AMD Ryzen threadripper 3960x 24-core processor, NVIDIA GeForce RTX 3080, 128 GB RAM, 6TB SSD. The installed ROS version is  Noetic featuring Gazebo 11.11, ROS nodes are written in Python 3.8.10. The installed version of Sphinx is 2.15.1.

\subsection{Integration of the Anafi Drone into a Multi-Robot Simulation}
We choose our Gazebo-based airship simulation \cite{price2022} to include the Anafi drone as a second aerial vehicle in the simulation. The \textit{Interface} component sends data from Sphinx to Gazebo with a frequency of $100\si{hz}$. 

\subsection{Verification of the Custom PID-based Controller Framework and of the MPC}
\setlength{\tabcolsep}{4pt}

\begin{table}[]
\center
\small
\caption{Parameters set for the PID controller and the MPC. \label{tab:controller_constraints}}
\begin{tabular}{@{}lll@{}}
\toprule
Controller& Parameter           & Value \\ \midrule
MPC & $ \left\lbrace x,y,z \right\rbrace_{max/min} $ & $\pm \infty \si{m}$ \\
MPC & $ \left\lbrace x_{ref},y_{ref},z_{ref} \right\rbrace_{max/min} $ & $\pm \infty \si{m}$ \\
MPC &$ \left\lbrace v_x,v_y,v_z \right\rbrace_{max/min} $ & $\pm \left\lbrace 10,10, 2\right\rbrace \si{m/s}$ \\
MPC &$ \left\lbrace v_{ref,x},v_{ref,y},v_{ref,z} \right\rbrace_{max/min} $ & $\pm \infty \si{m/s}$ \\
MPC &$ \left\lbrace x,y,z \right\rbrace_{cum,max/min} $ & $\pm \infty \si{m}$ \\
MPC &$ \left\lbrace v_x,v_y,v_z\right\rbrace_{cum,max/min}$ & $\pm \infty \si{m/s}$ \\
MPC &$ \left\lbrace a_x,a_y,a_z \right\rbrace_{max/min} $ & $\pm 5 \si{m/s^2}$ \\
MPC &$N$ & $30$\\
MPC &$\Delta t$ & $0.1$\\
MPC &Execution/output frequency & $10\si{hz}/10\si{hz}$\\

\midrule
PID &$ \left\lbrace v_x,v_y,v_z \right\rbrace_{max/min} $ & $\pm \left\lbrace 10,10, 2\right\rbrace \si{m/s}$  \\
PID &$ v_{z,max/min}$ & $\pm 2\si{m/s}$\\
PID &$ \theta_{max/min}$ & $\pm 30.64\si{^{\circ}}$\\
PID &$ \phi_{max/min}$ & $\pm 30.64\si{^{\circ}}$\\
PID &Yaw rate & $\pm 180\si{^{\circ}/s}$\\
PID &Execution/output frequency & $\sim30\si{hz}/10\si{hz}$\\
\bottomrule
\end{tabular} 
\end{table}
Table \ref{tab:controller_constraints} summarizes the values of parameters associated with the PID controller framework or the MPC, respectively.


\setlength{\tabcolsep}{6pt}
\begin{table}[]
\center
\small
\caption{Controller gains used for the (cascaded) PID-based controller framework. \label{tab:gains}}
\begin{tabular}{@{}ccccc@{}}
\toprule
Control Loop            & $k_p$ & $k_i$  & $k_d$ &  \\ \midrule
Lon. outer loop & 0.875 & 0.0001 & 0     &  \\
Lon. inner loop & 10    & 1      & 0     &  \\
Lat. outer loop      & 0.875 & 0.001  & 0     &  \\
Lat. inner loop      & -10    & -1      & 0     &  \\
Vertical             & 1     & 0      & 0.001 &  \\
Yaw                  & 0.6   & 0.2    & 0.003 & \\
\bottomrule
\end{tabular} 
\end{table}

The PID controller baseline is implemented using the ROS package \textit{pid} \cite{ros_pid} in combination with custom interface nodes. Table \ref{tab:gains} summarizes the gain values used for the different controllers.
The weight matrices used in \eqref{eq:MPC} were carefully tuned to achieve the best possible behaviour and are defined as follows.
\begin{align}
\mathbf{Q} &= \operatorname{diag}\left( \mathbf{0}_{1\times12} ,10^{-3},10^{-3},10^{-3},\mathbf{0}_{1\times3}\right)\\
\mathbf{Q_N} &= \operatorname{diag}\left( \mathbf{0}_{1\times12} ,5,5,5,\mathbf{0}_{1\times3}\right)\\
\mathbf{R} &= \operatorname{diag}\left( 0.2,0.2,0.2\right)\\
\end{align}
We also found that weights  for only the positional cumulative errors were required to achieve good tracking performance.
The initial values of $\bar{\mathbf{z}}$ are based on the  commanded waypoints.
\begin{dmath}
\bar{\mathbf{z}}= \left[x_{ref},  x_{ref},  y_{ref},  y_{ref}, z_{ref},  z_{ref},,...\\ v_{x,ref},v_{x,ref}, v_{y,ref}, v_{y,ref},  v_{z,ref},v_{z,ref},...  \\ 0,  0,  0,0, 0, 0\right]^T,
\end{dmath}
Whereas the first 12 reference  states follow the waypoint values, the last six states are set to 0. They define the desired cumulative error for the positional and velocity states that the solver should achieve when optimizing \eqref{eq:MPC} 
