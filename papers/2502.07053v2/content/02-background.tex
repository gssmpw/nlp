\section{Background}\label{sec:bg}
%
\subsection{Targeted Devices}
We focus on resource-constrained devices using low-end MCUs, such as Atmel AVR ATmega and TI MSP430, 
which are low-power single-core platforms with limited memory. These devices have $8$-bit or $16$-bit 
CPUs, $1$-$16$MHz clock frequencies, and typically $\leq~64$KB of addressable memory. Data memory
(DMEM) ranges from $4$ to $16$KB, while the rest is program memory (PMEM). Software executes in-place
from PMEM. It runs on ``bare metal'',  with no memory management for virtual memory or isolation.

A representative architecture for targeted devices includes a CPU core, DMA controller, and 
interrupt controller connected via a bus to memory regions: ROM, PMEM, DMEM, and peripheral 
memory. ROM holds the bootloader and immutable software. Device software resides in PMEM, 
and DMEM is used for the stack and heap. The device may incorporate both internal peripherals (timers) and external peripherals (sensors, actuators).

\subsection{Remote Attestation (\ra)}
%
As mentioned earlier, \ra is used for malware detection on a remote device. It is typically
achieved via a challenge-response protocol that enables a trusted entity called a verifier (\vrf) 
to remotely verify the software state of an untrusted remote device (\prv):
\begin{compactenum}  
  \item \vrf sends an \ra request with a challenge (\chal) to \prv.
  \item \prv generates an unforgeable attestation report, i.e., an authenticated integrity check 
  over PMEM, including the software, and \chal, and sends it to \vrf.
  \item \vrf verifies the report to determine whether \prv is in a valid state.
\end{compactenum}
%
The report includes either a Message Authentication Code (MAC) or a signature, depending 
on the type of cryptography used. In the former case, \prv and \vrf must share a unique 
secret key -- \key, while in the latter, \key is a unique private key of \prv. In either case, 
\key must be stored securely and be accessible only to the trusted 
attestation code on \prv.  
% This requirement, coupled with %  Consequently, \prv requires some hardware support.

%\vspace{0.1cm}
A large body of research 
\cite{vrased,noorman2013sancus,smart,nunes2020apex,rata,casu,jakkamsetti2023caveat,
aldoseri2023symbolic,wang2023ari,evtyushkin2014iso,ghaeini2019patt,sehatbakhsh2019emma,
feng2021scalable} explored \ra for low-end devices. Prior work can be split into {\bf passive} and 
{\bf active} techniques.
The former only {\bf detects} compromise and offers no guarantee of the device responding to an 
\ra request. Whereas, the latter either {\bf prevents} compromise and/or 
guarantees small security-critical tasks (e.g., an \ra response).

\subsection{Network Attestation (\sa)}
%
Unlike single-device \ra, which involves one \vrf and one \prv, \sa deals with a potentially
large number (network, group, or swarm) of \prv-s. This opens new challenges.
First, na\"{\i}ve adoption of single-\prv{} \ra techniques is inefficient and even impractical.
Also, \sa needs to take into account topology discovery, key management, and routing. This can 
be further complicated by mobility (i.e., dynamic topology) and device heterogeneity.
Moreover, \toctousa (inter-device \toctou) emerges as a new problem.


\subsection{Building Blocks} 
%
\noindent
{\bf $\boldsymbol{\rata}$ \cite{rata}} is a passive Root-of-Trust (\rot) architecture that 
mitigates \toctoura with minimal additional hardware. \rata securely logs the last PMEM 
modification time to a protected memory region called Latest Modification Time (LMT), 
which can not be modified by any software. 
\prv's attestation report securely reflects the integrity of its software state indirectly 
through the LMT. This approach is based on the principle that any modification to the 
software in PMEM would necessitate an update to the LMT. Thus, by attesting the LMT, \rata 
effectively attests the software state without needing to read the entire PMEM contents. 
This minimizes \ra computational overheads of \prv by attesting only 
a fixed-size ($32$-byte) LMT (plus the \vrf's challenge of roughly the same size), instead 
of attesting its entire software in PMEM.

\noindent
{\bf $\boldsymbol{\casu}$ \cite{casu}} is an active \rot architecture 
that provides run-time software immutability and authenticated software updates. 
It defends against code injection (into PMEM) and data execution attacks by preventing 
(1) unauthorized modification of PMEM and (2) code execution from DMEM.
\casu monitors several CPU hardware signals (e.g., program counter, write-enable bit, and 
destination memory address) and triggers a reset if any violation is detected.
The only means to modify PMEM is via secure update.
\casu inherently prevents \toctoura since PMEM cannot be overwritten by malware.

\noindent
{\bf $\boldsymbol{\garota}$ \cite{garota}} is another active architecture which 
guarantees execution of trusted and safety-critical tasks. 
These tasks are triggered based on arbitrary events captured by hardware peripherals 
(e.g., timers, GPIO ports, and network interfaces), even if malware is present on the device.
\garota provides two hardware properties: ``guaranteed triggering’’ and 
``re-triggering on failure’’.
The former ensures that a particular event of interest always triggers execution of 
\garota TCB tasks,
while the latter ensures that if TCB execution is interrupted for any reason (e.g., attempts to 
violate execution integrity), the device resets, and the TCB task is guaranteed to be 
executed first after the boot. \garota has 3 flavors:  TimerTCB, NetTCB, and GPIO-TCB,. 
In this paper, we are interested in the first two:
(1) {\bf TimerTCB} -- A real-time system where a predefined safety-critical task is 
guaranteed to execute periodically, and
(2) {\bf NetTCB} -- A trusted component that guarantees to process commands 
received over the network, thus preventing malware on the MCU from intercepting 
and/or discarding commands destined for the \rot.

\subsection{Hash Chains for Authentication \label{chains}}
%
Hash chains provide a secure, scalable, and efficient means of authentication,
originally proposed by Lamport \cite{lamport1981}. 
Over the last 40+ years, they have been used in numerous settings where one party (signer/sender)
needs inexpensive (though limited or metered) authentication to a multitude of receivers.

An $m$-link hash chain is constructed by repeatedly applying a cryptographic hash function 
$H$, starting with the initial secret value $x_0$, such that:
%
\[\Scale[0.85]
{H(x_0) = x_1, H(x_1) = x_2, ... , H(x_{m-1})=x_m, \;\;\mbox{i.e.,}\;\;
x_m = H^m(x_0)}
\]
%
To set up the operation of an $m$-link hash chain, signer (sender) retains
$x_0$ ({\bf root}) and shares final $x_m$ ({\bf anchor}) 
with all receivers. Given a value $x_i$ where $(0\leq~i\leq~m)$, it is computationally 
infeasible to compute $x_{i-1}$ or any previous value $x_k$ for $k < i$.
Conversely, calculating $x_{i+1}$ or any subsequent value $x_j$ where $j > i$ is straightforward;
$x_j$ can be computed by repeatedly applying the hash function $H()$ to $x_i$ (j-i times). 

For the first authentication round, signer reveals $x_{m-1}$ and all receivers can easily
authenticate it by comparing $H(x_{m-1})\stackrel{?}{=}x_m$. In the second round, 
the signer reveals $x_{m-2}$, and so on. This continues until the hash chain is exhausted, 
at which point a new hash chain is generated and shared. See Section \ref{renewal} 
for the use of hash chains in \system.

Suppose that a receiver is de-synchronized: it currently has $x_i$ and, instead
of the expected $x_{i-1}$, it next receives authenticator $x_j$ where $j<(i-1)$. This means that 
this receiver missed $i-j-1$ successive authenticators: $x_{i-1},...,x_{j+1}$.
Nonetheless, a receiver can quickly re-synchronize by authenticating $x_j$ via
computing $H^{(i-j)}(x_j)$ and checking if it matches $x_i$.
