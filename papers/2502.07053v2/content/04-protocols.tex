\section{\system Protocols} \label{sec:protocol}
%
This section describes two protocol variants.
The notation used in the rest of the paper is summarized in Table \ref{table:notation}.

\noindent{\bf Assumptions:}
As mentioned above, we assume that each \prv shares a unique symmetric key (\key) with \vrf. 
Also, throughout a single attestation instance, \vrf is assumed to be within the broadcast range 
of at least one \prv, and the entire \prv network must remain connected during this time.
Furthermore, all \prv-s have a parameter (\maxdelay) that denotes the maximum attestation report (\Attrep)
propagation delay in the network. In the absolute worst case of a line topology, it can
be set as: $\maxdelay=n*t_{report}$, where $n$ is the number of \prv-s and $t_{report}$ is the \Attrep\ propagation delay.
We also assume that the attestation request (\Attreq) propagation delay ($t_{request}$) 
and the \Attreq\ verification time ($t_{hash}$) are known to all \prv-s.
\maxdelay\ is needed to limit the time when 
each \prv forwards other \prv-s' attestation results towards \vrf.
For the sake of simplicity, we assume that no new attestation requests 
are issued while one is being served.

\noindent {\it NOTE:} As mentioned at the end of Section \ref{elems}, the use of hash 
chains for \vrf authentication is optional; a separate group key shared between \vrf and all \prv-s 
could be used instead, albeit with the risk of its possible leak.

\subsection{\trapsrtc: RTC-Based \sa Technique}\label{sec:one}
%
Commodity RTCs, such as MCP7940MT-I/SM \cite{rtc}, are now readily available for 
under $\$0.60$ per unit. This affordability marks a significant shift from the past, 
when real-time security features were often too costly for IoT devices. This motivates 
our design of an \sa protocol for devices with RTCs.
We begin by presenting this simple variant of the core ideas of \system.
An alternative variant without the RTC requirement is described in Section \ref{sec:two}.
\trapsrtc pseudo-code is shown in Algorithms \ref{alg:rtc_prv} and \ref{alg:rtc_vrf}.


%
\begin{figure}
    \centering
    \includegraphics[height=1.2in,width=0.7\columnwidth]{images/vrf_FSM.pdf}
    \vspace{-.5em}
    \caption{\vrf\ State Machine}
    \label{fig:vrfFSM}
    \vspace{-1.5em}
\end{figure}
%
\begin{compactitem}[]
    \item {\bf \underline{\bf V1.} Idle:} \vrf waits for an external signal to begin an attestation instance. 
    When it occurs, \vrf transitions to \textbf{Initiate}.
    %
    \item {\bf \underline{\bf V2.} Initiate:} \vrf assigns \attesttime{}, 
    %
    as described in Section \ref{section:timeout}, which accounts for request 
    propagation and network height. (\attesttime{} is computed by each \prv in \trapsnortc.)     
    %
    It then initializes 
    \textit{Attest}=\textit{Fail}=$\emptyset$, and \textit{NoRep}=\{\devid-s of all \prv-s\}. 
    Next, \vrf sets \snd\ to \vrf, composes \Attreq, and broadcasts it. (Recall the assumption 
    that at least one \prv must be within broadcast range of \vrf at this time.) 
    It then sets a local timer to \timeout{},
    %
    as detailed in Section \ref{section:timeout}, which factors into network size and delays, 
    %
    and then transitions to \textbf{Collect}.
    %
    \item {\bf \underline{\bf V3.} Collect:} \vrf waits for \Attrep-s. 
    Upon receipt of an \Attrep, \vrf first checks that \hash\ contained in \Attrep\ matches that in the 
    currently pending \Attreq; otherwise, it is discarded. Next, \vrf validates \Attrep\ by 
    looking up the corresponding \key shared with \prv (identified by \devid) and recomputing 
    the MAC. If MAC validation fails, \Attrep\ is discarded. Otherwise:
    \begin{compactitem}[]
        \item {\it \underline{V3.1}} (\casu): \devid\ is moved from \textit{NoRep} to \textit{Attest}.
        \item {\it \underline{V3.2}} (\rata): \vrf maintains the last valid \lmt\ for each \prv. 
    When processing an \Attrep\ from a given \prv, \vrf compares received \lmt$'$\ with the stored 
    \lmt\ for that \prv. A mismatch signifies failed attestation and
    \devid\ is added to \textit{Fail}. Otherwise, it is added to \textit{Attest}. 
    In either case, \devid\ is removed from \textit{NoRep}.
        \item {\it \underline{V3.3}} If $\textit{NoRep}=\emptyset$, \vrf transitions to \textbf{Tally}.
        \item {\it \underline{V3.4}} If \timeout\ timer expires, \vrf transitions to \textbf{Tally}.
    \end{compactitem}
    \item {\bf \underline{\bf V4.} Tally:} \vrf outputs \textit{Attest}, \textit{Fail}, and 
    \textit{NoRep}. It then returns to \textbf{Idle}.
    %
\end{compactitem}


\begin{algorithm}[hbt!]
\footnotesize
\caption{Pseudo-code of $\boldsymbol{\trapsrtc}$ for \prv}\label{alg:rtc_prv}
    \begin{algorithmic}[1]
    \While{True}
        \State \textit{m} = RECEIVE()
        \If {TYPE(\textit{m}) == \textit{``req''}}
            \State [\snd, \hashind, \hash, \attesttime] $\gets$ DECOMPOSE(\textit{m})
            \If {$\curhashind <= \hashind$}
                \State CONTINUE() 
            \EndIf
            \If {GET\_TIME() $>=$ \attesttime}
                \State CONTINUE() 
            \EndIf
            \If {\textit{H}$^{(\curhashind-\hashind)}(\hash)$ $\neq$ \curhash}
                \State CONTINUE()
            \EndIf
             \State \parent $\gets$ \snd; \curhashind $\gets$ \hashind; \curhash $\gets$ \hash; \textit{attestTime} $\gets$ \attesttime;
             \State BROADCAST(\textit{``req''}, \devid, \curhashind, \curhash, \attesttime)
             \State \textit{CurTime} $\gets$ \textit{GET\_TIME()} \Comment{Get current time from RTC}
             \While {\textit{CurTime} $<$ \attesttime} \Comment{non-busy-waiting}
             \State \textit{CurTime} $\gets$ GET\_TIME()
        % %%%%%
             \EndWhile
             \State \attesttime$'$ $\gets$ \textit{CurTime}
             \State \Authrep $\gets$ MAC(\key, \parent, \attesttime$'$, \hash, \{\lmt\})
             \State \Attrep $\gets$ \textit{``rep''}, \devid, \parent, \attesttime$'$,  \hash, \{\lmt\}, \Authrep
             \State UNICAST(\parent, \Attrep)
             \State SET\_TIMER(\height*t$_{report}$)
        \EndIf
         \If {TYPE(\textit{m}) == \textit{``rep''}}
                 \If {\hash == GET\_\hash(\textit{m})}
                     \State UNICAST(\parent, \textit{m})
                 \EndIf
        \EndIf
    \EndWhile
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}[hbt!]
\footnotesize
\caption{Pseudo-code of $\boldsymbol{\trapsrtc}$ for \vrf}\label{alg:rtc_vrf}
    \begin{algorithmic}[1]
    \While{True}
        \State \textit{type} $\gets$ REQUEST\_TYPE() 
        \State \hashind $\gets$ GET\_HASH\_IND()
        \State \hash $\gets$ GET\_HASH(\hashind)
        \State \attesttime $\gets$ \netheight*(t$_{request}$+t$_{hash}$)+t$_{slack}$+\textit{GET\_TIME()}
        \State \Attreq $\gets$ \textit{``req'', vrf}, \hashind, \hash, \attesttime
        \State \textit{Attest} $\gets \emptyset$; \textit{Fail} $\gets \emptyset$; \textit{NoRep} $\gets$ \{\devid-s of all \prv-s\}
        \State BROADCAST(\Attreq)
        \State T $\gets$ GET\_TIME()
        \While{\attesttime $<$ T $<$ \timeout}
             \State \Attrep $\gets$ RECEIVE()
             \State [\devid, \parent, \attesttime, \hash, \lmt, \Authrep] $\gets$ DECOMPOSE(\textit{\textit{m}})
             \State \lmt$'$ $\gets$ LMT\_LIST(\devid) \Comment{\casu skips \#13, \#15, \#17, \#18}
             \If{(\hash \ == \curhash) \ AND 
             (MAC(\key, \parent, \attesttime, \hash, \{\lmt\}) == \Authrep)}
                 \If {\lmt == \lmt$'$} 
                     \State \textit{Attest} $\gets$ \textit{Attest} $\cup$ \devid
                 \Else
                     \State \textit{Fail} $\gets$ \textit{Fail} $\cup$ \devid
                 \EndIf
             \State \textit{NoRep} $\gets$ \textit{NoRep} $\backslash$ \devid
             \EndIf
        \EndWhile
        \State OUTPUT(\textit{Attest}, \textit{Fail}, \textit{NoRep})
    \EndWhile
    \end{algorithmic}
\end{algorithm} 

\trapsrtc\ has two message types:

\noindent \textbf{Attestation Request ($\boldsymbol{\Attreq}$):} Generated by \vrf, 
it contains: \hash, \hashind, and \attesttime, which are used to authenticate \Attreq. Note that \hash\ 
is used as a challenge for this \sa. $\boldsymbol{\Attreq}$ also includes
the packet type field: \textit{``req''} and the identifier \snd\ of either \vrf 
that originated it (for the first hop), or a \prv that forwards it (for subsequent hops).
\snd\ is used by each receiving \prv to learn its parent in the spanning tree.

\noindent \textbf{Attestation Report ($\boldsymbol{\Attrep}$):} Generated by each \prv, this 
message carries the attestation report. It contains an authentication token (\Authrep), which provides message integrity. 
\lmt$'$\ is included in the calculation of \Authrep\ and in \Attrep\ only for \rata-enabled \prv-s. 
Similar to $\boldsymbol{\Attreq}$, $\boldsymbol{\Attrep}$
also includes the packet type field: \textit{``rep''}  and the identifier of \prv that generated 
this report. Also, \Attrep\ includes \hash\ that was received in \Attreq\ and the actual time 
(\attesttime$'$) when attestation is performed.

\begin{table}[ht]
    \vspace{.7em}
    \footnotesize
    % \scriptsize
    \begin{tabularx}{\linewidth}{|c|X|}
        \hline
        \rowcolor{gray!20}
        {\bf Notation} & \multicolumn{1}{c|}{\bf Meaning} \\            
        \thickhline
        $\devid$ & Identifier of responding $\prv$ \\
        \hline
        $\parent$ & Identifier of responding $\prv$'s parent \\
        \hline
        $\snd$ & Identifier of the sending device \\
        \hline
        $H()$ & Cryptographic hash function (e.g., SHA2-256) used in hash chain computation \\
        \hline 
        $H^s(x)$ & Denotes $s>1$ repeated applications of $H()$ starting with initial input $x$ \\
        \hline        
        $\hash$ & Hash value sent by $\vrf$ that authenticates it to all $\prv$-s; 
            it also serves as the challenge for this $\sa$ instance \\
        \hline
        $\curhash$ & Current hash value stored by $\prv$ \\
        \hline
        $\hashind$ & Index of $\hash$ sent by $\vrf$  \\
        \hline
        $\curhashind$ & Index of $\curhash$ stored by $\prv$ \\
        \hline
        $\netheight$ & Network spanning tree height  \\
        \hline
        $\height$ & Height of $\prv$ in the spanning tree \\
        \hline        
        $\lmt$ & Last Modification Time (of PMEM), only used in $\rata$, stored on \vrf \\        
        \hline
        $\lmt'$ & Last Modification Time (of PMEM), only used in $\rata$, stored on \prv \\        
        \hline
        \key & Shared key between \prv and \vrf, securely stored on \prv and restricted to its trusted attestation code \\
        \hline
        $\Attreq$ & \parbox[c]{1\linewidth}{\vspace{2pt}\raggedright Attestation request message ($\vrf \rightarrow \prv$): \\
        \phantom{}[\textit{"req"}, \snd, \hash, \hashind, \attesttime]}\vspace{1pt}\\
\hline
        $\Attrep$ & \parbox[c]{1\linewidth}{\vspace{2pt}\raggedright Attestation report message ($\vrf \leftarrow \prv$): \\
        \phantom{}\tiny{[\textit{"rep"}, \devid, \parent, \attesttime$'$, \hash, \{\lmt\}, \Authrep]}}\vspace{1pt}\\
\hline
        $\Authrep$ & \parbox[c]{1\linewidth}{\vspace{2pt}\raggedright 
           Authentication of attestation report in $\Attrep$: \\ 
           \tiny{MAC(\key, \parent, \attesttime$'$, \hash, \{\lmt$'$\})}}\vspace{1pt}\\
        \hline
        t$_{request}$ & propagation delay of $\Attreq$\\
        \hline
        t$_{report}$ & propagation delay of $\Attrep$\\
        \hline
        t$_{hash}$ & Computation time for $\Attreq$ verification \\
        \hline        
        t$_{MAC}$ & Computation time for MAC generation \\
        \hline
        t$_{slack}$ & Additional slack time \\
        \hline
        $\maxdelay$ & Max delay to receive an $\Attrep$ from a descendant $\prv$ \\
        \hline
        $\attesttime$ & Time to begin attestation, set by $\vrf$ \\
        \hline        
        $\attesttime'$ & Time when a given $\prv$ actually performed attestation \\
        \hline
        $\timeout$ & $\vrf$'s timeout for receiving all attestation replies \\
        \hline
    \end{tabularx} 
    \caption{Notation Summary} 
    \vspace{-3em}
    \label{table:notation}
\end{table}

We now describe \prv operation as a state machine with five states, as shown in 
Figure \ref{fig:prvFSM}: {\it Idle, Verify, Attest-Wait, Attest,}  and {\it Forward-Wait}.

\begin{figure}
    \centering
    \includegraphics[height=1.5in,width=0.7\columnwidth]{images/prv_FSM.pdf}
    \vspace{-1em}
    \caption{\prv\ State Machine} 
    \label{fig:prvFSM}
    % \vspace{-2em}
\end{figure}
%

\begin{compactitem}[]
%
    \item {\bf \underline{\bf P1.} Idle:} \prv runs normally. Upon receiving an \Attreq, it 
    proceeds to \textbf{Verify}. Any \Attrep\ received in this state is discarded.
%
    \item {\bf \underline{\bf P2.} Verify:} 
    \begin{compactitem}[]
        \item \underline{\it P2.1:} \prv checks if $\curhashind>\hashind$ and $\attesttime>T$,
    where $T$ is its current RTC value. If either check fails, it discards \Attreq\ and 
    returns to {\bf Idle}. 
        \item \underline{\it P2.2:} \prv computes and checks whether $H^s(\hash) \stackrel{?}{=} 
    \curhash$, where $s=\curhashind-\hashind$.\footnote{Recall that it is possible for $s>1$,
    (as discussed at the end of Section \ref{chains}) meaning that \prv became de-synchronized.
    Also, \hashind\ is decremented by one in every \ra instance.}
    If not, it discards \Attreq\ and returns to {\bf Idle}.
    (Note that a \prv might receive duplicate \Attreq-s from multiple neighbors; it simply discards them.)
    \item \underline{\it P2.3:} \prv\ replaces: \curhash\ with \hash, and \curhashind\ with \hashind. 
    Then, \prv stores \snd\ as \parent, sets \snd\ field of received \Attreq\ to its \devid, and 
    broadcasts modified \Attreq.
    %\vspace{.1cm}
    \item \underline{\it P2.4:} \prv sets (using its RTC) a secure timer (TimerTCB) to \attesttime\ 
    and transitions to \textbf{Attest-Wait}.
    \end{compactitem} 
%
     \item {\bf \underline{\bf P3.} Attest-Wait:} \prv runs normally while the timer is ticking. 
     If any \Attreq\ is received in this state, it is discarded. 
%
    \item {\bf \underline{\bf P4.} Attest:} When the timer matches \attesttime, \prv sets {\it \attesttime$'$} 
    to the current RTC value, computes \Authrep{}, and composes 
    \Attrep\ as defined above. It then uni-casts \Attrep\ to \parent{}, sets the timer 
    to \maxdelay, and transitions to \textbf{Forward-Wait}.
%    
% \vspace{0.2cm}
    \item {\bf \underline{\bf P5.} Forward-Wait:} \prv runs normally while the timer is ticking. If \prv 
    receives an \Attrep, it checks whether the report's \hash\ matches that previously received 
    in \textbf{Verify}. If not, it is discarded. Otherwise, \prv uni-casts received \Attrep\  
    to its parent and remains in \textbf{Forward-Wait}. When the timer matches \maxdelay, \prv transitions 
    to \textbf{Idle}. Note that any \Attreq \ received while in this state 
    is discarded. 
%
\end{compactitem}

Whereas, as shown in Figure \ref{fig:vrfFSM}, \vrf's state machine has four states: 
{\it Idle, Initiate, Collect,} and {\it Tally}.



\subsection{\trapsnortc: Clockless \sa Technique}\label{sec:two}

Despite its relatively low cost, an RTC might still not be viable for some IoT deployments. 
This leads us to construct a \system variant without RTCs.
Pseudo-code for \trapsnortc is shown in Algorithms \ref{alg:nortc_prv} and \ref{alg:nortc_vrf}.

\begin{algorithm}[hbt!]
\footnotesize
 \caption{Pseudo-code of $\boldsymbol{\trapsnortc}$ for \prv}\label{alg:nortc_prv}
     \begin{algorithmic}[1]
     \While{ True }
         \State \textit{m} = RECEIVE()
         \If {TYPE(\textit{m}) == ``req''}
             \State [\snd, \hashind, \hash, \height, \netheight, \attesttime] $\gets$ DECOMPOSE(\textit{m})
             \If {$\curhashind <= \hashind$}
                 \State CONTINUE() 
             \EndIf
             
             \If {\textit{H}$^{(\curhashind-\hashind)}$(\hash) $\neq$ \curhash}
                 \State CONTINUE()
             \EndIf
             \State \parent $\gets$ \snd; \curhashind $\gets$ \hashind; \curhash $\gets$ \hash; \textit{attestTime} $\gets$ \attesttime;
             \State BROADCAST(\textit{``req''}, \devid, \curhashind, \curhash, \height + 1, \netheight, \attesttime)
        
             \State \textit{timer} $\gets$ \textit{startTimer()} \Comment{start a timer}
             \State \textit{attestWait} $\gets$ (\netheight-\height)*(\textit{t$_{request}$+\textit{t$_{hash}$})}
        
             \While {\textit{timer} $<$ \textit{attestWait}} \Comment{non-busy-waiting}%do something here
                 \State WAIT()
             \EndWhile
             \state \attesttime$'$ $\gets$ \textit{timer}
             \State \Authrep $\gets$ MAC(\key, \parent, \attesttime, \hash, {\lmt})
             \State \Attrep $\gets$ \textit{``rep''}, \devid, \parent, \attesttime$'$, \hash, {\lmt}, \Authrep
             \State UNICAST(\parent, \Attrep)
             \State SET\_TIMER(\height*\textit{t$_{report}$})
         \EndIf
         \If {TYPE(\textit{m}) == \textit{``rep''}}
                 \If {\hash == GET\_\hash(\textit{m})}
                     \State UNICAST(\parent, \textit{m})
                \EndIf
        \EndIf
    \EndWhile
     \end{algorithmic}
 \end{algorithm}

 
 \begin{algorithm}[hbt!]
\footnotesize
 \caption{Pseudo-code of $\boldsymbol{\trapsnortc}$ for \vrf}\label{alg:nortc_vrf}
     \begin{algorithmic}[1]
     \While{True}
         \State \textit{type} $\gets$ REQUEST\_TYPE() 
         \State \hashind $\gets$ GET\_HASH\_IND()
         \State \hash $\gets$ GET\_HASH(\hashind)
         \State \attesttime $\gets$ \textit{\netheight}*(t$_{request}$+$t_{hash})+t_{slack}$+\textit{GET\_TIME()}
         \State \netheight $\gets$ GET\_NET\_height()
    
         \State \Attreq $\gets$ \textit{``req''}, \vrf, \hashind, \hash, 0, \netheight, \attesttime
         \State Attest $\gets \emptyset$; Fail $\gets \emptyset$; NoRep $\gets$ \{\devid-s of all \prv-s\}
         \State BROADCAST(\textit{InitID}, \Attreq)
         \State T $\gets$ GET\_TIME()
        \While{T $<$ \timeout}
             \State \Attrep $\gets$ RECEIVE()
             \State [\devid, \parent, \attesttime, \hash, \{\lmt\}, \Authrep] $\gets$ DECOMPOSE(\textit{\textit{m}})
             \State \lmt$'$ $\gets$ LMT\_LIST(\devid) \Comment{\casu skips \#14, \#16, \#18, \#19}
             \If{(\hash \ == \curhash) \ AND  (MAC(\key, \parent, \attesttime, \hash, \{\lmt\}) == \Authrep)}
                 \If {\lmt == \lmt$'$}
                     \State \textit{Attest} $\gets$ \textit{Attest} $\cup$ \{\devid\}
                 \Else
                     \State \textit{Fail} $\gets$ \textit{Fail} $\cup$ \{\devid\}
                 \EndIf
             \State \textit{NoRep} $\gets$ \textit{NoRep} $\backslash$ \{\devid\}
             \EndIf
        \EndWhile
        \State OUTPUT(\textit{Attest}, \textit{Fail}, \textit{NoRep})
     \EndWhile
     \end{algorithmic}
 \end{algorithm} 

There are still just two message types, \Attreq\ and \Attrep, 
of which only \Attreq\ differs from \trapsrtc:
%

\noindent \textbf{Attestation Request ($\boldsymbol{\Attreq}$):} Generated by \vrf, \Attreq\ includes two extra fields: \height\ and \netheight\ 
which represent the height of the sender (\vrf or \prv) and the spanning tree height of the network,
respectively. \height\ is essentially a hop counter during the propagation of \Attreq\ 
throughout the network. It is initialized to 0 by \vrf and incremented by each forwarding \prv.
%

\prv's state machine has five states, three of which are identical to those in \trapsrtc.
Only {\underline{Verify}} and {\underline{Attest}} differ, as follows:
\begin{compactitem}[]
    \item {\bf \underline{\bf P2.} Verify:} 
    \begin{compactitem}[]
        \item \underline{\it P2.1:}  \prv checks whether $\curhashind>\hashind$.    
        If this check fails, it discards \Attreq\ and returns to {\bf Idle}.
        \item \underline{\it P2.2:} \prv 
        computes and checks whether $H^s(\hash) \stackrel{?}{=} \curhash$, where 
        $s=\curhashind-\hashind$. If not, it discards \Attreq\ and returns to {\bf Idle}.
        Duplicate \Attreq-s from multiple neighbors are also discarded. 
        \item  \underline{\it P2.3:} \prv replaces: \curhash\ with \hash, and \curhashind\ with \hashind. Then, \prv stores \snd\ as \parent, 
        sets \snd\ field to its \devid, increments \height{}, and broadcasts modified \Attreq. 
        \item \underline{\it P2.4:} \prv sets a secure timer (TimerTCB) to: 
        \begin{equation}
            \textit{attestWait} = (\netheight-\height)*({t_{request}} + {t_{hash}})
        \end{equation}
        and transitions to \textbf{Attest-Wait}.
    \end{compactitem}
%
    \item {\bf \underline{\bf P4.} Attest:} Identical to \trapsrtc, except that \prv sets {\it \attesttime$'$} 
    to its current secure timer value, to be later validated by \vrf.
    The degree of reduction of \toctousa depends on the accuracy and functionality of \prv's secure timer.
    Also, the propagation delay from \vrf to each \prv affects \toctousa.
    This is discussed in more detail in Section \ref{subsec:security-analysis}.
%
\end{compactitem}
%
Note that \attesttime\ in \trapsnortc is a timer value (increases from 0),
unlike that in \trapsrtc, which represents the current time.
\vrf's state machine has four states identical to that of \trapsrtc.

\noindent {\bf Protocol Trade-offs:} \system's two variants address distinct deployment 
constraints. \trapsrtc uses RTCs to synchronize attestation timing globally via precise 
timestamps (\attesttime), thus minimizing \toctousa with marginal hardware costs.
Whereas, \trapsnortc eliminates RTC dependencies by deriving attestation timing from the 
network topology (\netheight), thus sacrificing \toctousa precision for broader applicability.
These synchronization implications are addressed in Section \ref{dis:precise_sync}.

\subsection{Renewing Hash Chains \label{renewal}}
%
As typical for any technique utilizing hash chains, the issue of chain depletion must
be addressed. An $m$-link hash chain is depleted after $m$ authentication instances
($m$ \sa instances in our context). To address this issue and ensure 
long-term operation, we need a mechanism for refreshing the hash chain. 

Recall the well-known Lamport hash chain construct from Section \ref{chains}. 
Suppose that the current hash chain of length $m$ being used is ${\mathcal X}$:
$$
H(x_0) = x_1, H(x_1) = x_2, ... , H(x_{m-1})=x_m
$$
Suppose that we have already used up $m-2$ links of the chain for all \prv-s. 
This means that only two links in the chain remain, and the entire chain will be depleted when \vrf reveals $x_1$ and then
$x_0$ in the next two \sa instances. Knowing this, \vrf wants all \prv-s 
to switch over to a new hash chain ${\mathcal X'}$:
$$
H(x'_0) = x'_1, H(x'_1) = x'_2, ... , H(x'_{m-1})=x'_m
$$
To do so, it includes in the next \Attreq\ (\Attreq$_{_{m-1}}$) two extra values/fields:
\begin{center}
\noindent 
\Attreq$_{_{m-1}}$ = [\textit{``req''}, \snd, \hash=$x_1$, \hashind=$1$, \\
\attesttime, {\bf NewChain=$\boldsymbol{x'_m}$, Auth=$\boldsymbol{MAC(x_0,x'_m)}$} ]
\end{center}
%
These two new fields convey the anchor of the new hash chain {\bf NewChain} and its authenticator {\bf Auth} 
computed as a MAC over NewChain using, as a key, still-unreleased next link in the current chain -- $x_0$. 
Upon receiving such an \Attreq, in addition to the usual \Attreq \ processing, 
a \prv stores NewChain and Auth. Obviously, at this time, a \prv has no way to 
verify Auth since it does not yet know $x_0$. A \prv continues to process this \Attreq,
as detailed earlier.

However, at this stage, each \prv{} maintains a current hash ${\mathcal X}$, where 
$\curhashind=1$ and $\curhash=x_1$. A \prv waits for the next \sa instance, wherein 
\Attreq$_{_m}$ should convey $x_0$. Upon receiving \Attreq$_{_m}$, a \prv obtains 
$x_0'$, which may differ from the original $x_0$ if it was modified by \sadv in transit.
As part of its normal processing, a \prv first verifies that $H(x_0')=\curhash=x_1$. 
A \prv recomputes Auth$'$ using the newly received $x_0'$ and its stored NewChain value. 
If Auth$'$ matches the previously stored Auth, a \prv completes the switchover 
to the chain ${\mathcal X'}$ by setting $\curhashind=m$ and $\curhash=x'_m$. 

This simple renewal technique is secure, lightweight, and trivial to implement. 
However, two factors contribute to its fragility. 

\noindent {\bf Timing:}
It must hold that the time difference between \vrf sending \Attreq$_{_{m-1}}$
and \Attreq$_{_{m}}$ is sufficiently long to avoid forgeries of NewChain and Auth. However, even 
when the time difference is reasonably long, \sadv can delay the delivery of \Attreq$_{_{m-1}}$ 
to one or more targeted \prv-s. If \Attreq$_{_{m}}$ is sent by \vrf
when at least one \prv has not yet received \Attreq$_{_{m-1}}$, \sadv can learn $x_0$ from \Attreq$_{_{m}}$. 
It can then change the NewChain field in \Attreq$_{_{m-1}}$  from $x'_m$ to $y_m$, and Auth field --
from $MAC(x_0,x'_m)$ to $MAC(x_0,y_m)$, where $y_m$ is the anchor of \sadv-selected hash chain.

This issue is not unique to the present technique. It is indeed quite similar to the timing requirement
in the well-known TESLA protocol for secure multicast and its many variants \cite{perrig-tesla}.
TESLA also uses the delayed key disclosure mechanism and makes reasonable assumptions about 
timing.\footnote{See Section 2.2 in IETF RFC 4082: \url{https://www.ietf.org/rfc/rfc4082.txt)}.}
The timing issue can be further mitigated if \vrf switches the chain in 
\Attreq$_{_{m}}$ only if it has received legitimate responses from all \prv-s upon
sending \Attreq$_{_{m-1}}$. 

\noindent {\bf DoS on $\boldsymbol{\prv}$-s:}
Upon observing \Attreq$_{_{m-1}}$, \sadv (present in the network) can modify 
NewChain and/or Auth fields. Each \prv would then duly store these two values. Once the subsequent 
\Attreq$_{_m}$ arrives in the next \sa instance, each \prv would fail to verify stored NewChain and Auth, 
thus ending up being unable to process any further \Attreq-s. Although there is no full-blown fix for 
this problem, one way to side-step it is for \vrf to begin switching to the new hash chain prior 
to a few links being left in the old chain, i.e., when \curhash \ $=(m-k)$ for some reasonably small $k$.
In this case, Auth $={MAC(x_{m-k-1},x'_m)}$, which can be verified in the successive attestation, 
\Attreq$_{_{m-k-1}}$. Then, \vrf can decide to switch to ${\mathcal X'}$ when it receives valid 
\Attrep-s from all \prv-s, indicating that all have the identical NewChain, ${x'_m}$.

\subsection{Timeouts}\label{section:timeout}
%
The overall attestation timeout (on \vrf) is set as follows:
\begin{equation}\label{eq:t-overall}
    \timeout = n * (t_{request}+t_{hash} + t_{report}) + t_{MAC} + t_{slack}
\end{equation}
where $n$ is the total number of \prv-s in the network.
\vrf sets the attestation time in \trapsrtc as follows:
\begin{equation}\label{eq:t-attestation}    
    \attesttime = \netheight * (t_{request}+t_{hash})+t_{slack}+t_{current}
    % \vspace{-1em}  
\end{equation}
where t$_{current}$ is \vrf's current time.

\attesttime\ must be large enough for every \prv to receive \Attreq\
before the actual attestation begins.
Note that an inflated \attesttime\ does not influence \toctousa; it only incurs \vrf's waiting time.
In the worst case (line topology), the total request propagation time would be: $n*(t_{request}+t_{hash})$.
Once all devices receive the request, they perform attestation at (ideally) the 
same time \attesttime, taking \ $t_{MAC}$. Finally, \Attrep-s from all \prv-s 
need to be returned to \vrf, which takes at most $n*t_{report}$ in the worst case. 
Note that t$_{report}$ may differ from t$_{request}$ \ due to network congestion caused by 
simultaneous response transmissions from all \prv-s. An additional tolerance
value t$_{slack}$ helps account for unexpected delays.