\section{Evaluation \label{eval}}

\subsection{Security Analysis} \label{subsec:security-analysis}

\noindent {\bf Network-based $\boldsymbol{\sadv}$:}
This adversary (\sadv) is a malicious (not a \system{} \prv) physical network entity, e.g., a non-compliant IoT device or a computer. 

\Attreq\ in \trapsrtc includes: \textit{``req''}, \snd, \hash, \hashind, \attesttime, while \Attreq\ in \trapsnortc also includes \height{} and \netheight. \prv authenticates each \Attreq{} by verifying \hashind, \attesttime, and checking if $H^s(\hash) = \curhash$, where $s=\curhashind-\hashind$. The \hash{} is known only to \vrf, and recovering it from \curhash{} is computationally infeasible, so \sadv cannot forge \hash. However, \sadv can modify other fields (such as \attesttime, \height, and \netheight) affecting \prv's attestation time. Nonetheless, this is later detected by \vrf, as \attesttime$'$ is included in \Authrep{} within each \prv's \Attrep.

\sadv can also alter the \snd{} field in \Attreq{}, supplying an incorrect \parent{} to \prv. This may obstruct valid \Attrep-s from benign \prv-s. However, \vrf will notice the absence of \Attrep{} from affected \prv-s.

\Attrep{} includes: \textit{``rep''}, \devid, \parent, \attesttime$'$, \hash, \{\lmt$'$\}, and \Authrep, with authenticity and integrity ensured by \Authrep, computed as:\\ MAC(\key,\parent,\attesttime$'$,\hash,\{\lmt$'$\}). Manipulation of \devid\ is detectable by \vrf since \devid is used to retrieve the corresponding key.

\sadv can forge an \Attrep{} only if: (1) \sadv forges \Authrep{} without knowing \key, which is infeasible with a secure MAC function, or (2) \sadv learns \key and constructs an authentic \Authrep{}, which is infeasible since \key is in the TCB and is only accessible to \system software.

\noindent {\bf Malware-based $\boldsymbol{\sadv}$:}
\system remains secure despite malware presence on any number of \prv-s due to: (1) \prv's TCB ensuring \key secrecy, (2) NetTCB enforcing receiving and forwarding of \Attreq\ and \Attrep\, (3) TimerTCB ensuring timely \Attrep\ generation, and (4) \prv's TCB blocking non-TCB software from sending \Attrep\ or \Attreq\ messages. These measures prevent DoS attacks from \prv-resident malware.

\noindent {\bf $\boldsymbol{\toctousa}$ \& $\boldsymbol{\toctoura}$:}
\trapsrtc eliminates \toctousa as long as the RTC is accurately synchronized with the \vrf. Meanwhile, minimizing \toctousa in \trapsnortc depends on: (a) the secure timer, and (b) propagation delay from \vrf to each \prv. Two scenarios relating to the former could increase \toctousa in \trapsnortc: (a-1) \sadv tampering with a \prv's secure timer, or (a-2) timer drift due to physical imperfections, disrupting the attestation schedule.

To address (a-1), \trapsnortc uses TimerTCB to: (1) prioritize the timer's Interrupt Service Routine (ISR) for timely attestation, and (2) protect timer configurations from unauthorized changes. Although (a-2) can't be fully addressed, \trapsnortc significantly reduces \toctousa compared to unsynchronized schemes. For example, with a propagation delay $t_{request}=1$ms and \netheight$=10,000$, \prv-s wait for up to $10$s. A timer drift of $100$ppm results in a $1$ms drift, reducing \toctousa from $10,000$ms to $1$ms in \trapsnortc.

 Recall that \trapsnortc assumes identical network propagation delays. However, in reality, variations may occur due to congestion or connectivity changes. For instance, with \netheight$=10,000$ and $t_{request}=1$ms, if the delay between $\prv_i$ and $\prv_j$ is $1.5$ms, $\prv_i$ starts attestation $0.5$ms earlier than its descendants. To minimize this, (b), $t_{request}$ should average all network propagation delays. Note that \netheight\ over-estimation by \vrf doesn't affect \toctousa; it only delays attestation start on \prv-s.


\begin{table}[!t]
    \centering
    \small
    \begin{tabularx}{\linewidth}{|c|X|}
    % \label{table:notations}
        \hline
        \rowcolor{gray!20}
        {\bf Notation} & \multicolumn{1}{c|}{\bf Description} \\            
        \thickhline
        $\pc$	     & 	Program Counter pointing to the current instruction being executed \\
        \hline
        $\wen$ 	 &	1-bit signal that represents whether MCU core is writing to memory \\
        \hline
        $\daddr$ 	 &	Memory address being accessed by MCU core \\
        \hline
        $\dmaen$   &	1-bit signal that represents whether DMA is active \\
        \hline
        $\dmaaddr$ &	Memory address being accessed by DMA \\
        \hline
        $\reset$	 &	Signal that reboots the MCU when it is set to logic `1'\\
        \hline
        $\tcr$	 &	Trusted code region, a fixed ROM region storing $\trapscasu$ software \\
        \hline        
        $\er$	     &	Executable region, a memory region where authorized (normal) software is stored \\
        \hline
        $\ep$	     &	Executable pointer, a fixed memory region storing current $\er$ boundary \\    
        \hline
        $\ivtr$	 &	Reserved memory region for the MCU's interrupt vector table \\
        \hline
        $\casumem$ &  Memory region protected by $\trapscasu$ hardware, including $\er$, $\ep$, and $\ivtr$ \\
        \hline
        $\gie$     &  Global interrupt enable, 1-bit signal that represents whether interrupts are globally enabled \\
        \hline
        $\irq$     &  1-bit signal that represents if an interrupt occurs \\
        \hline
        $\irqcfg$  &  Set of registers in DMEM used to configure of interrupts, e.g., timer deadline and UART baudrate\\
        \hline
        $\isrt$    &  Timer interrupt service routine, privileged software that controls a timer interrupt: \newline
                        $\isrt = [\isrtmin, \isrtmax]$ \\    
        \hline
        $\isru$    &  UART interrupt service routine, privileged software that handles a UART interrupt: \newline
                        $\isru = [\isrumin, \isrumax]$ \\
        \hline        
    \end{tabularx}
    \caption{Notation Summary}
\label{table:notations}
\end{table}


\begin{figure*}[t]
    % \centering
    % \small
    % \captionsetup{justification=centering}
    \begin{mdframed}[userdefinedwidth=0.95\textwidth]
        $\bullet\ $ {\it Security Properties Stemming from} $\boldsymbol{\casu}$\\
        \textbf{- \small Software Immutability in PMEM:}\\        
        \begin{equation}\label{eq:hwprop_wp}
            \textbf{G}: \{\text{modMem}(\casumem) \land (\pc \notin \tcr) \rightarrow \reset\}
        \end{equation}
        \textbf{- \small Unauthorized Software Execution Prevention:}
        \begin{equation}\label{eq:hwprop_usep}
            \textbf{G}: \{(\pc \notin \er) \land (\pc \notin \tcr) \rightarrow \reset\}
        \end{equation} \\
        $\bullet\ $ {\it Security Properties Stemming from} $\boldsymbol{\garota}$\\
        \textbf{- \small IRQ Configuration Protection:}
        \begin{equation}\label{eq:irqcfg-protection}
            \textbf{G}: \{[\neg(\pc \in \tcr) \land \wen \land (\daddr \in \irqcfg)] \lor [\dmaen \land (\dmaaddr \in \irqcfg)] \rightarrow \reset\}
        \end{equation}
        \textbf{- \small Timer ISR Execution Atomicity:}        
        \begin{equation}\label{eq:timer-isr-protection1}
            \textbf{G}: \{\neg \reset \land \neg (\pc \in \isrt) \land (\textbf{X}(\pc) \in \isrt) \rightarrow \textbf{X}(\pc) = \isrtmin \lor \textbf{X}(\reset) \}
        \end{equation}
        \begin{equation}\label{eq:timer-isr-protection2}
            \textbf{G}: \{\neg \reset \land (\pc \in \isrt) \land \neg (\textbf{X}(\pc) \in \isrt) \rightarrow \pc = \isrtmax \lor \textbf{X}(\reset) \}            
        \end{equation}
        \begin{equation}\label{eq:timer-isr-protection3}
            \textbf{G}: \{(\pc \in \isrt) \land (\irq \lor \dmaen) \rightarrow \reset \}
        \end{equation}
        \textbf{- \small UART ISR Execution Atomicity:}        
        \begin{equation}\label{eq:uart-isr-protection1}
            \textbf{G}: \{\neg \reset \land \neg (\pc \in \isru) \land (\textbf{X}(\pc) \in \isru) \rightarrow \textbf{X}(\pc) = \isrumin \lor \textbf{X}(\reset) \}
        \end{equation}
        \begin{equation}\label{eq:uart-isr-protection2}
            \textbf{G}: \{\neg \reset \land (\pc \in \isru) \land \neg (\textbf{X}(\pc) \in \isru) \rightarrow \pc = \isrumax \lor \textbf{X}(\reset) \}            
        \end{equation}
        \begin{equation}\label{eq:uart-isr-protection3}
            \textbf{G}: \{(\pc \in \isru) \land (\irq \lor \dmaen) \rightarrow \reset \}
        \end{equation}
        \textbf{- \small Interrupt Disablement Protection:}
        \begin{equation}\label{eq:irq-disablement-protection}
            \textbf{G}: \{\neg \reset \land \gie \land \neg \textbf{X}(\gie) \rightarrow (\textbf{X}(\pc) \in (\isrt \lor \isru)) \lor \textbf{X}(\reset)\}
        \end{equation}        
    \end{mdframed}
    % \vspace{-0.8em}
    \caption{\trapscasu Hardware Security Properties}\label{fig:hwprop}
    % \vspace{-0.8em}
    % \normalsize
\end{figure*}

% \subsection{\trapscasu Formal Verification} \label{subsec:formal-verification}
\noindent{\bf Formal Verification of $\boldsymbol{\trapscasu}$:}
We formally specify \trapscasu with \trapsnortc security goals using Linear Temporal Logic (LTL).
Formal verification plays a crucial role by showing that \trapscasu adheres to well-specified goals.
It assures that it does not exhibit any unintended behavior, especially in corner cases, 
rarely encountered conditions and/or execution paths, that humans tend to overlook.
By employing computer-aided tools, we define and validate LTL rules that govern \trapscasu operation.
The use of LTL enables precisely capturing temporal dependencies and expected behavior 
over time, ensuring that \trapscasu meets stringent security standards.
Table \ref{table:notations} describes the notation used in this section.

We use regular propositional logic, such as conjunction $\land$, disjunction $\lor$, 
negation $\neg$, and implication $\rightarrow$. A few other temporal quantifiers are used as well:
%
\begin{compactitem}
    \item $\textbf{X} \Phi$ (ne$\textbf{X}$t) -- holds if $\Phi$=true at the next system state.
    \item $\textbf{F} \Phi$ ($\textbf{F}$uture) -- holds if there is a future state when $\Phi$=true.
    \item $\textbf{G} \Phi$ ($\textbf{G}$lobally) -- holds if for all future states $\Phi$=true.
\end{compactitem}
%
Figure \ref{fig:hwprop} formally describes \trapscasu hardware security properties using 
propositional logic and temporal quantifiers. Recall that \trapscasu is based on \casu 
combined with \garota. All such properties must hold at all times to achieve \trapscasu's
security goals.

LTL \ref{eq:hwprop_wp} states that any modifications to \casumem, including \er, \ep, and \ivtr, 
trigger a reset when \trapscasu software is not running. \er is a region in PMEM, where normal 
device software resides, while \ep is a fixed region in PMEM that points to \er.
Upon a secure update, \ep is updated to point to the new verified software version.
\ivtr also resides in PMEM and contains the ISR addresses.
As stated in LTL \ref{eq:hwprop_usep}, the MCU cannot execute any code outside \er 
or \trapscasu code in read-only memory (ROM).
% \gene{What does "or not \tcr" mean?}

LTL \ref{eq:irqcfg-protection} ensures that, if the timer or the UART peripheral configurations
are modified by any software (other than the timer or UART ISR-s), a reset is triggered.
LTL \ref{eq:timer-isr-protection1}-\ref{eq:timer-isr-protection3} specify atomic operation of 
timer ISR, LTL \ref{eq:timer-isr-protection1} and LTL \ref{eq:timer-isr-protection2} guarantee 
that \isrtmin and \isrtmax are the only legal entry and exit points, respectively.
Also, LTL \ref{eq:timer-isr-protection3} states that DMA and other interrupts must remain 
inactive while timer ISR executes. Similarly, LTL 
\ref{eq:uart-isr-protection1}-\ref{eq:uart-isr-protection3} enforce UART ISR atomicity.
Finally, LTL \ref{eq:irq-disablement-protection} guarantees that \gie can be disabled 
only if the timer or UART ISR-s are running. Any violations result in a device reset.

Note that we slightly modified \casu and \garota to realize \trapscasu:
\begin{compactenum}
    \item \trapscasu employs both TimerTCB and NetTCB, while \garota uses them individually in each case.
    \item {\it Trusted PMEM Updates} rule from \garota is integrated to Equation \ref{eq:hwprop_wp}.
    \item \garota's {\it Re-Trigger on Failure} property is not viable 
    since \trapscasu cannot retain a consistent timer value upon a failure (e.g., a reset) in \trapsnortc. 
\end{compactenum}

To verify the above LTL rules, we convert the Verilog code described at the Register Transfer Level 
(RTL) to Symbolic Model Verifier (SMV) \cite{mcmillan1993smv} using Verilog2SMV \cite{irfan2016verilog2smv}.
The SMV output is in turn fed to the NuSMV \cite{cimatti2002nusmv} model-checker for specified LTL 
rule validation. NuSMV works by checking LTL specifications against the system finite-state machine 
for all reachable states. This comprehensive approach ensures that \trapscasu's security goals 
are thoroughly validated, offering robust assurance against potential vulnerabilities.
See \cite{TRAPSAnonOpenSource} for further proof details.



%\vspace{0.2cm}
\subsection{Hardware Overhead} \label{subsec:hw_overhead}
%\vspace{0.2cm}
%
Recall that underlying hardware RoT for \prv-s in \system is either \casu or \rata with 
additional hardware support from \garota.
Table \ref{table: hardware overhead} compares the hardware overhead of \trapscasu and \trapsrata
implementations with the baseline openMSP430, \casu, and \rata architectures.
\trapscasu implementation requires $0.46$\% more Look-Up Tables (LUTs) and $0.55$\% more registers over 
\casu.  Also, \trapsrata implementation needs $0.05$\% LUTs and $0.69$\% registers over \rata.
Numbers of additional LUTs and registers are under $15$, implying minimal overheads incurred
by NetTCB and TimerTCB.

\noindent {\bf Comparison with Other Hybrid \rot:}
We compare \system with other hybrid \rot constructions leveraging \ra:
VRASED \cite{vrased}, RATA \cite{rata}, CASU \cite{casu}, GAROTA \cite{garota}, and APEX \cite{nunes2020apex}. 
Note that RATA, CASU, APEX are implemented based on VRASED,
and all the above architectures are (in turn) based on openMSP430.
Results are shown in Figure \ref{fig: hw_comparison}.
APEX has a higher overhead than others due to additional hardware properties required
for generating proofs-of-execution.

\begin{table}  
  %\vspace{.7em}
  % \small
  \centering\captionsetup{justification = centering}
  \footnotesize
  % \scriptsize
  {
     \begin{tabular}{|Sc|Sc|Sc|} \hline
     \rowcolor{gray!20}
     \bf Architecture & \bf Look-Up Tables & \bf Registers  \\ \thickhline
     openMSP430 &  $1854$ & $692$ \\ \hline
     \casu & $1956$ & $726$ \\ \hline 
     \rowcolor{yellow!20}$\boldsymbol{\trapscasu}$ & {\bf $1967$ (+$11$)} & {\bf $740$ (+$14$)} \\ \hline
     \rata & $1928$ & $728$ \\ \hline 
     \rowcolor{yellow!20}$\boldsymbol{\trapsrata}$ & {\bf $1935$ (+$7$)} & {\bf $737$ (+$9$)} \\ \hline 
     \end{tabular}
  }
  %\vspace{.05cm}
  \caption{\system Hardware Overhead} 
  \label{table: hardware overhead}
  \vspace{-3em}
\end{table}


\begin{figure}
	\centering\captionsetup{justification = centering}
	\subfloat[Additional LUTs (\%)]
	{\includegraphics[width=0.5\columnwidth]{images/lut_comparison.pdf}}
	\subfloat[Additional Reg-s (\%)]
	{\includegraphics[width=0.5\columnwidth]{images/reg_comparison.pdf}}
	\vspace{-1em}
	\caption{Hardware Overhead Comparison}
        % \vspace{-2em}
	\label{fig: hw_comparison} 
\end{figure}

%\vspace{0.2cm}
\subsection{Run-time Overhead} \label{subsec:runtime-overhead}
%\vspace{0.2cm}

Since \vrf is not a resource-constrained device, we focus on the overheads incurred on \prv.
Table \ref{table:run-time overhead} provides an overview of the run-time overhead for 
\system and a comparison with prominent prior \sa techniques: SEDA \cite{asokan2015seda}, 
SCRAPS \cite{petzi2022scraps}, DIAT \cite{abera2019diat}, and SANA \cite{ambrosin2016sana}.
% 
\begin{table}
    % \footnotesize
    % \small
    
    \captionsetup{justification=centering}
    \scriptsize
    \resizebox{\columnwidth}{!}{
    \begin{tabular}{|c|c|c|}
        \hline
        \rowcolor{gray!20}
        & {\bf Request} & {\bf Report} \\
        \rowcolor{gray!20}
        & {\bf Verification} & {\bf Generation} \\
        \rowcolor{gray!20}
        \multirow{-3}{*}{\bf Architecture} & {\bf Time (ms)} & {\bf Time (ms)} \\
        % \\ Verification \\ Time (ms)}} & {\bf \makecell {Report \\ Generation \\ Time (ms)}} \\ 
        \thickhline
        \makecell{\trapscasu  (@ $8$MHz)} &  $13.0$ & $29.5$ \\ \hline
     \makecell{\trapsrata  (@ $8$MHz)} & $12.9$ & $29.8$ \\ \hline 
     \makecell{SEDA Initiator \\ (SMART) (@ $8$MHz)} & N/A & \makecell{$56900$ $+$ \\ $256*g$} \\ \hline 
    \makecell{SEDA participating devices \\ (SMART) (@ $8$MHz)} & N/A & \makecell{$96$ $+$ \\ $256*(g-1)$}\\ \hline 
    \makecell{SEDA Initiator \\ (TRUSTLITE) (@ $24$MHz)} & N/A & $347.2 + 4.4*g$ \\ \hline 
    \makecell{SEDA participating devices \\ (TRUSTLITE) (@ $24$MHz)} & N/A & \makecell{$0.6$ $+$ \\ $4.4*(g-1)$} \\ \hline 
    \makecell{SCRAPS \\ (LPC55S69) (@ $150$MHz)} & N/A & $2109.1$ \\ \hline
    \makecell{SCRAPS \\ (ATmega1284P) (@ $20$MHz)} & N/A & $40147.4$ \\ \hline
    \makecell{DIAT  (@ $168$MHz)} & N/A & $835$ \\ \hline
    \makecell{SANA  (@ $48$MHz)} & $921.5$ & $3125.8$ \\ \hline
    \end{tabular}
    }
    \vspace{.05cm}
    \caption{\small Run-time Overhead Comparison 
    \\ ($g$: number of neighbors of a device)
    }
    \label{table:run-time overhead}
    \vspace{-4em}
\end{table}

Generating the attestation report (\Attrep) is quite fast for both \trapscasu\ and \trapsrata\ \prv types, since the overhead
is dominated by the computation of an HMAC over a minimal fixed-length region. 

In comparison, initiators in SEDA have 

to sign the entire  
aggregated report, resulting  in a  significantly longer timing overhead compared to \system. The report generation time of other \prv-s is also higher than \system as they must attest the whole program memory and verify neighbors' reports.

Moreover, report generation time in SEDA grows (almost) linearly, relying on the number of neighbors, denoted by $g$.

We also examine run-time overhead of SCRAPS, DIAT, and SANA.
These schemes perform relatively complex tasks as part of attestation and thus
incur high run-time overhead despite being implemented on more powerful devices. 

In summary, compared to DIAT, SCRAPS, and SANA, \system is lightweight in terms of run-time overhead.

%\vspace{0.2cm}
\subsection{Energy Consumption}\label{subsec:energy-overhead}
%\vspace{0.2cm}
\comment{
\begin{table}
        \footnotesize
        % \scriptsize
        \centering
        \captionsetup{justification = centering}
        % \resizebox{\columnwidth}{!} {
        \begin{tabular}{|Sc|Sc|Sc|}
            \hline
            \rowcolor{gray!20}
            {\bf \small Device Type} & {\bf \small  Dynamic Power} & {\bf \small Device Static Power} \\
            \thickhline
            \makecell{\small \casu, \\ \rata}  & {\small $111 mW$} & {\small $72 mW$}\\
            \hline
            % \rata & 0.111 W & 0.072 W\\
            % \hline
            \makecell{\small \trapscasu, \\ \trapsrata}  & {\small $115 mW$} & {\small $72 mW$}\\
            \hline
            % \trapsrata & 0.115 W & 0.072 W\\
            % \hline
        \end{tabular}  
        % }      
        \vspace{.05cm}
        \caption{\system Energy Overhead}
        \label{table:power overhead}
        % \vspace{-0.5cm}
\end{table}
Table \ref{table:power overhead} shows 
Estimated power consumption is measured by Xilinx Vivado.
}

Dynamic power consumption measurements from Xilinx Vivado show that \trapscasu{} and \trapsrata{} consume $115 mW$, of which $111 mW$ is consumed
by either \casu or \rata. This represents a $2$\% increase in total on-chip power.
Total time spent by \system (request verification and report generation) is $42.5$ms for \trapscasu and 
$42.7$ms for \trapsrata. Therefore, energy consumption per attestation instance is $\approx~0.00221$mWh 
for \trapscasu and \trapsrata, which is negligible.

%\vspace{0.2cm}
\subsection{Scalability Eval via Network Simulation} \label{sec:network-simulation}
%\vspace{0.2cm}

We conduct network simulations using the OMNeT++ \cite{omnetpp}. % to evaluate \system performance in a large network.
Since \trapsrtc and \trapsnortc protocols are similar, only the former is simulated.
Simulations are performed at the application layer. Cryptographic operations are simulated using delays 
that correspond to their actual execution times on \trapscasu and \trapsrata\ \prv-s.
We exclude \vrf's verification time from the simulations and set the communication rate between \prv-s to $250$Kbps.
This rate matches the standard data rate for ZigBee -- a common communication protocol for IoT devices.
Simulations are conducted with various spanning tree topologies: line, star, and several types of trees, with degrees
ranging from $2$ (binary) to $12$. We also vary the number of devices from $10$ to $1,000,000$.
Simulation results for \trapscasu and \trapsrata are almost identical, thus, only \trapscasu results are shown in Figures \ref{fig: star linear} and \ref{fig: tree topologies}.

\begin{figure}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=0.9\columnwidth]{images/traps_star_linear.pdf}
    % \vspace{-.5cm}
    \caption{\system Simulation for Line/Star Topologies}
    \label{fig: star linear}
    % \vspace{-.25cm}
\end{figure}

\begin{figure}
    \centering
    \captionsetup{justification=centering}
    \includegraphics[width=0.9\columnwidth]{images/traps_tree_topologies.pdf}
    \caption{\system Simulation for Various Tree Topologies} 
    \label{fig: tree topologies}
    % \vspace{-0.25cm}
\end{figure}

As evident from Figure \ref{fig: star linear}, the run-time of \system is constant with the star topology and 
grows linearly with the linear topology.
This is because, in the former, \prv can start attestation almost immediately (as there is no forwarding to descendants), 
while each \prv waits until the farthest-away \prv is ready to perform attestation in the latter. 
The actual run-time for the star topology is $343$ms. For a network with a tree topology, 
\system run-time overhead is logarithmic in the number of \prv-s since the tree height governs it.
Simulation results show that \system is efficient in both small and large networks with various topologies. 