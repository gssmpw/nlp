\section{Design Overview \label{design}} 
%
\subsection{System Model}
\noindent {\bf Network:}
We assume a single verifier (\vrf) and a network of multiple low-end embedded devices as 
\prv-s. \vrf is assumed to be trusted and sufficiently powerful. 
The network is assumed to be: (1) connected, i.e., there is always a path between \vrf and any of  
\prv-s, and (2) quasi-static during attestation, i.e., its topology can change as long as the changes 
do not influence the path of message propagation. \system is network-agnostic and can be 
realized over any popular medium (e.g., WiFi, Bluetooth, Cellular, Zigbee, Matter).

\noindent {\bf $\boldsymbol{\ra}$ Architecture in $\boldsymbol{\prv}$:}
All \prv-s must support \rata or \casu architecture: in a given deployment, either all support
the former or all support the latter, i.e., no mixing.\footnote{This is not a hard requirement,
meaning that a mix of \rata and \casu devices would work as well;
however, it makes the presentation simpler.}
As mentioned in Section \ref{sec:bg}, an attestation token in 
\rata is computed as a keyed hash over a small fixed-size input.

In contrast, \casu prevents any PMEM modification (except via secure update), 
thus obviating the entire need for \ra. However, \casu does not offer \prv liveness.
Note that, in any secure \ra technique, an attestation token returned by \prv 
provides both attestation and \prv liveness.
The latter is important for detecting whether \prv is operational, i.e., not powered off, 
destroyed/damaged, or physically removed. 
To this end, \casu supports a ``secure heartbeat'' feature, whereby 
\vrf periodically issues a random challenge and \prv simply computes (and returns) a keyed 
hash over that challenge. This costs about the same as attestation token computation in \rata. 
We discuss various use-cases of \rata and \casu in Section \ref{subsec:rata-casu-comparison}.

\noindent {\bf Network Interface in $\boldsymbol{\prv}$:}
The primary network interface of each \prv is placed within \system's Trusted Computing Base (TCB). 
This ensures that \system protocol messages are handled with the highest 
priority, even in the presence of malware or run-time attacks.
\system uses two special attestation-specific packet types: request and report. 
Normal software outside TCB is prevented from sending or receiving these packet types;
this is achieved by inspecting each incoming/outgoing packet header
in order to prevent tampering with, and forgery of, \system messages. Furthermore, 
\system packets are always handled with higher priority than other tasks. 
This approach is based on NetTCB of \garota \cite{garota}.
Besides, we adopt TimerTCB from \garota to guarantee (nearly) synchronized attestation start times.

With these security features, \rata-enabled \prv-s are safeguarded against
full compromise and malware-based disruption of the attestation process.
The benefit is more subtle in the case of \casu: although \casu guarantees no malware,
software running on \casu-enabled \prv-s can still be susceptible to control-flow attacks, 
which would prevent, or delay, receiving of \vrf attestation requests and 
generation of secure heartbeats. The above features ensure that this does not occur.

\noindent {\bf $\boldsymbol{\prv}$ TCB:}
\system TCB includes both hardware and software components, i.e., akin to \rata and \casu, 
\system is a {\bf hybrid} architecture. In addition to the trusted software of either \rata or \casu, 
\system software includes TimerTCB, NetTCB, and \sa logic described in Section \ref{sec:protocol}.
The primary network interface (NetTCB) is shared between the \system software  
and other non-TCB software. Incoming messages cause an interrupt via NetTCB.
\system software prioritizes \system protocol messages. It forwards other incoming messages to the intended
application (outside TCB) and outgoing messages to the destination.
TCB hardware components are:
%
\begin{compactitem}
    \item NetTCB -- Network interface for \system messages
    \item TimerTCB -- Timer used for simultaneous attestation
    \item DMEM segment reserved for running \system software 
    \item Part of ROM reserved for \system software, key shared with \vrf, and hash chain data
\end{compactitem}
\subsection{Adversary Model \label{sec: adversary}}
%
In line with other network attestation (\sa) techniques, \system considers software-only 
remote network attacks. We assume an adversary (\sadv) that can inject malware and exercise 
full control over a compromised \prv, except for its TCB. \sadv can manipulate any non-TCB
peripherals and external components, such as Direct Memory Access (DMA), sensors, actuators, 
and other (non-primary) network interfaces. Also, \sadv has comprehensive knowledge 
of software (i.e., non-\system software) running on \prv,
including its memory vulnerabilities. Thus, it can launch run-time (e.g., control-flow) attacks.

We also consider a network-based \sadv represented by a malicious (non-\system) entity in the
\prv network. Consequently, all packets exchanged between \vrf and \prv-s can 
be manipulated by \sadv: based on the Dolev-Yao model \cite{dolevYao}, \sadv can eavesdrop on, 
drop, delay, replay, modify, or generate any number of messages. 

\noindent {\bf DoS Attacks:}
\system prevents DoS attacks that attempt to ``brick'' \prv-s via malware,
or control-flow attacks. However, DoS attacks that jam the network or attempt to inundate 
specific \prv's network interfaces are out of scope. 
For countermeasures, we refer to well-known techniques, 
such as \cite{muraleedharan2006jamming,zhijun2020low, mamdouh2018securing}.

\noindent {\bf Physical Attacks:}
\system does not offer protection against physical attacks, both 
invasive (e.g., via hardware faults and reprogramming through debuggers) and non-invasive (e.g., 
extracting secrets via side-channels). Such attacks can be mitigated, at considerable cost, via
well-known tamper-resistance methods \cite{obermaier2018past,ravi2004tamper}.

\subsection{Protocol Elements \label{elems}}
%
As mentioned in Section \ref{intro}, we construct two \system variants, 
based on the availability of a real-time clock (RTC) on \prv-s:
%
\begin{compactenum}[(1)]
    \item \textbf{$\boldsymbol{\trapsrtc}$:} Each \prv has an RTC. In an attestation request, \vrf includes 
    the exact time when all \prv-s should perform attestation. 
    \item \textbf{$\boldsymbol{\trapsnortc}$:} \prv-s do not have RTC-s. In an attestation request, 
    \vrf provides the height of the spanning tree, composed of all \prv-s. Each \prv 
    estimates the time to perform attestation using spanning tree height and its own secure timer.
\end{compactenum}

\noindent \trapsrtc is designed for an ideal best-case scenario where each \prv is assumed to 
have a synchronized RTC. \toctousa window is completely removed in \trapsrtc.
On the other hand, \trapsnortc is intended for a more realistic scenario where each \prv has a timer.
Although \trapsnortc can not offer precisely synchronized attestations on \prv-s, it still significantly reduces \toctousa. Section \ref{subsec:security-analysis} provides further details.

\noindent{\bf $\boldsymbol{\toctousa}$ resilience}
Due to the availability of RTC in \trapsrtc and the spanning tree's height in \trapsnortc, 
all \prv-s perform attestation almost simultaneously. Figure \ref{fig: toctou window}(b) 
shows the eliminated \toctou window in \trapsrtc.

\noindent {\bf Attestation Regions:}
Unlike prior \sa schemes which perform attestation over the 
entire PMEM, \system is built on top of either \rata or \casu, which enables \prv to 
compute a MAC over a short fixed size including:
(1) \lmt\ and \vrf's challenge, in \rata,  or (2) merely \vrf's challenge, in \casu.
Section \ref{sec:protocol} provides details about other parameters included in the MAC computation.

\noindent {\bf Authentication of Attestation Requests:}
Most prior work in network (or swarm) attestation
does not take into account authentication of attestation requests. While this may or may
not be an issue in a single \prv{} \ra setting\footnote{\vrf authentication in a single \prv 
setting is thoroughly discussed in \cite{Brasser-DAC16}.}, it certainly becomes a concern in \sa.
If requests are not authenticated, \sadv can readily mount a DoS attack whereby \sadv floods all 
\prv-s with bogus requests, each of which causes {\bf all} \prv-s to perform attestation and 
generate numerous useless replies.

This issue is deceptively simple. The na\"ive approach to address the problem is for \vrf
(which already shares a unique symmetric key with each \prv) to send 
an individual attestation request to every \prv, authenticated with each shared key.
This is unscalable for obvious reasons. 

Another intuitive approach is to assume that every \prv knows \vrf's
public key and \vrf simply signs each attestation request with a timestamp. Despite scaling well, this 
approach opens the door for a simple DoS attack whereby \sadv floods the network with 
attestation requests with fake signatures, forcing all \prv-s to verify them, and due to failed
verification, discard the requests. This incurs heavy collective computational 
overhead on the entire network.

Yet another trivial method is to assume a separate group key (shared among \vrf and all \prv-s) that is
used exclusively for authenticating \vrf-issued attestation requests. This is quite efficient
since a simple MAC (realized as a keyed hash) would suffice. However, a key shared among a potentially
large number of \prv-s raises the risk of its eventual compromise, which would have 
unpleasant consequences. 
Also, managing the group and key revocation becomes increasingly complex as the network grows.

\system uses hash chains to authenticate attestation requests. Hash chains, as described in Section 
\ref{chains}, are well-known constructs used in numerous similar settings where symmetric keys 
are unscalable and traditional public key signatures are too expensive.
They provide forward security and efficient verification, while offering relatively simple
key management. Although hash chains suffer from some fragility in terms of synchronization 
and timing requirements, these issues are more palatable than those that stem from managing 
large numbers of shared keys.

