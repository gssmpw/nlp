% \clearpage
\newpage %%pavel% What's the proper way to format these algorithms so they come in the right order%
% \appendix

\section*{APPENDIX A: Pseudo-code for \trapsrtc} \label{sec:code-rtc}
%
% Recall that \trapsrtc assumes the RTC presence on \prv-s.
\trapsrtc pseudo-code is shown in Algorithms \ref{alg:rtc_prv} and \ref{alg:rtc_vrf}.

\begin{algorithm}[hbt!]
\footnotesize
\caption{Pseudo-code of $\boldsymbol{\trapsrtc}$ for \prv}\label{alg:rtc_prv}
    \begin{algorithmic}[1]
    \While{True}
        \State \textit{m} = RECEIVE()
        \If {TYPE(\textit{m}) == \textit{``req''}}
            \State [\snd, \hashind, \hash, \attesttime] $\gets$ DECOMPOSE(\textit{m})
            \If {$\curhashind <= \hashind$}
                \State CONTINUE() 
            \EndIf
            \If {GET\_TIME() $>=$ \attesttime}
                \State CONTINUE() 
            \EndIf
            \If {\textit{H}$^{(\curhashind-\hashind)}(\hash)$ $\neq$ \curhash}
                \State CONTINUE()
            \EndIf
             \State \parent $\gets$ \snd; \curhashind $\gets$ \hashind; \curhash $\gets$ \hash; \textit{attestTime} $\gets$ \attesttime;
             \State BROADCAST(\textit{``req''}, \devid, \curhashind, \curhash, \attesttime)
             \State \textit{CurTime} $\gets$ \textit{GET\_TIME()} \Comment{Get current time from RTC}
             \While {\textit{CurTime} $<$ \attesttime} \Comment{non-busy-waiting}
             \State \textit{CurTime} $\gets$ GET\_TIME()
        % %%%%%
             \EndWhile
             \State \attesttime$'$ $\gets$ \textit{CurTime}
             \State \Authrep $\gets$ MAC(\key, \parent, \attesttime$'$, \hash, \{\lmt\})
             \State \Attrep $\gets$ \textit{``rep''}, \devid, \parent, \attesttime$'$,  \hash, \{\lmt\}, \Authrep
             \State UNICAST(\parent, \Attrep)
             \State SET\_TIMER(\height*t$_{report}$)
        \EndIf
         \If {TYPE(\textit{m}) == \textit{``rep''}}
                 \If {\hash == GET\_\hash(\textit{m})}
                     \State UNICAST(\parent, \textit{m})
                 \EndIf
        \EndIf
    \EndWhile
    \end{algorithmic}
\end{algorithm}


\begin{algorithm}[hbt!]
\footnotesize
\caption{Pseudo-code of $\boldsymbol{\trapsrtc}$ for \vrf}\label{alg:rtc_vrf}
    \begin{algorithmic}[1]
    \While{True}
        \State \textit{type} $\gets$ REQUEST\_TYPE() 
        \State \hashind $\gets$ GET\_HASH\_IND()
        \State \hash $\gets$ GET\_HASH(\hashind)
        \State \attesttime $\gets$ \netheight*(t$_{request}$+t$_{hash}$)+t$_{slack}$+\textit{GET\_TIME()}
        \State \Attreq $\gets$ \textit{``req'', vrf}, \hashind, \hash, \attesttime
        \State \textit{Attest} $\gets \emptyset$; \textit{Fail} $\gets \emptyset$; \textit{NoRep} $\gets$ \{\devid-s of all \prv-s\}
        \State BROADCAST(\Attreq)
        \State T $\gets$ GET\_TIME()
        \While{\attesttime $<$ T $<$ \timeout}
             \State \Attrep $\gets$ RECEIVE()
             \State [\devid, \parent, \attesttime, \hash, \lmt, \Authrep] $\gets$ DECOMPOSE(\textit{\textit{m}})
             \State \lmt$'$ $\gets$ LMT\_LIST(\devid) \Comment{\casu skips \#13, \#15, \#17, \#18}
             \If{(\hash \ == \curhash) \ AND 
             (MAC(\key, \parent, \attesttime, \hash, \{\lmt\}) == \Authrep)}
                 \If {\lmt == \lmt$'$} 
                     \State \textit{Attest} $\gets$ \textit{Attest} $\cup$ \devid
                 \Else
                     \State \textit{Fail} $\gets$ \textit{Fail} $\cup$ \devid
                 \EndIf
             \State \textit{NoRep} $\gets$ \textit{NoRep} $\backslash$ \devid
             \EndIf
        \EndWhile
        \State OUTPUT(\textit{Attest}, \textit{Fail}, \textit{NoRep})
    \EndWhile
    \end{algorithmic}
\end{algorithm} 


\newpage
\section*{APPENDIX B: Pseudo-code for \trapsnortc} \label{sec:code-nortc}

%\
Pseudo-code for \trapsnortc is shown in Algorithms \ref{alg:nortc_prv} and \ref{alg:nortc_vrf}.

 \begin{algorithm}[hbt!]
\footnotesize
 \caption{Pseudo-code of $\boldsymbol{\trapsnortc}$ for \prv}\label{alg:nortc_prv}
     \begin{algorithmic}[1]
     \While{ True }
         \State \textit{m} = RECEIVE()
         \If {TYPE(\textit{m}) == ``req''}
             \State [\snd, \hashind, \hash, \height, \netheight, \attesttime] $\gets$ DECOMPOSE(\textit{m})
             \If {$\curhashind <= \hashind$}
                 \State CONTINUE() 
             \EndIf
             
             \If {\textit{H}$^{(\curhashind-\hashind)}$(\hash) $\neq$ \curhash}
                 \State CONTINUE()
             \EndIf
             \State \parent $\gets$ \snd; \curhashind $\gets$ \hashind; \curhash $\gets$ \hash; \textit{attestTime} $\gets$ \attesttime;
             \State BROADCAST(\textit{``req''}, \devid, \curhashind, \curhash, \height + 1, \netheight, \attesttime)
        
             \State \textit{timer} $\gets$ \textit{startTimer()} \Comment{start a timer}
             \State \textit{attestWait} $\gets$ (\netheight-\height)*(\textit{t$_{request}$+\textit{t$_{hash}$})}
        
             \While {\textit{timer} $<$ \textit{attestWait}} \Comment{non-busy-waiting}%do something here
                 \State WAIT()
             \EndWhile
             \state \attesttime$'$ $\gets$ \textit{timer}
             \State \Authrep $\gets$ MAC(\key, \parent, \attesttime, \hash, {\lmt})
             \State \Attrep $\gets$ \textit{``rep''}, \devid, \parent, \attesttime$'$, \hash, {\lmt}, \Authrep
             \State UNICAST(\parent, \Attrep)
             \State SET\_TIMER(\height*\textit{t$_{report}$})
         \EndIf
         \If {TYPE(\textit{m}) == \textit{``rep''}}
                 \If {\hash == GET\_\hash(\textit{m})}
                     \State UNICAST(\parent, \textit{m})
                \EndIf
        \EndIf
    \EndWhile
     \end{algorithmic}
 \end{algorithm}

 
 \begin{algorithm}[hbt!]
\footnotesize
 \caption{Pseudo-code of $\boldsymbol{\trapsnortc}$ for \vrf}\label{alg:nortc_vrf}
     \begin{algorithmic}[1]
     \While{True}
         \State \textit{type} $\gets$ REQUEST\_TYPE() 
         \State \hashind $\gets$ GET\_HASH\_IND()
         \State \hash $\gets$ GET\_HASH(\hashind)
         \State \attesttime $\gets$ \textit{\netheight}*(t$_{request}$+$t_{hash})+t_{slack}$+\textit{GET\_TIME()}
         \State \netheight $\gets$ GET\_NET\_height()
    
         \State \Attreq $\gets$ \textit{``req''}, \vrf, \hashind, \hash, 0, \netheight, \attesttime
         \State Attest $\gets \emptyset$; Fail $\gets \emptyset$; NoRep $\gets$ \{\devid-s of all \prv-s\}
         \State BROADCAST(\textit{InitID}, \Attreq)
         \State T $\gets$ GET\_TIME()
        \While{T $<$ \timeout}
             \State \Attrep $\gets$ RECEIVE()
             \State [\devid, \parent, \attesttime, \hash, \{\lmt\}, \Authrep] $\gets$ DECOMPOSE(\textit{\textit{m}})
             \State \lmt$'$ $\gets$ LMT\_LIST(\devid) \Comment{\casu skips \#14, \#16, \#18, \#19}
             \If{(\hash \ == \curhash) \ AND  (MAC(\key, \parent, \attesttime, \hash, \{\lmt\}) == \Authrep)}
                 \If {\lmt == \lmt$'$}
                     \State \textit{Attest} $\gets$ \textit{Attest} $\cup$ \{\devid\}
                 \Else
                     \State \textit{Fail} $\gets$ \textit{Fail} $\cup$ \{\devid\}
                 \EndIf
             \State \textit{NoRep} $\gets$ \textit{NoRep} $\backslash$ \{\devid\}
             \EndIf
        \EndWhile
        \State OUTPUT(\textit{Attest}, \textit{Fail}, \textit{NoRep})
     \EndWhile
     \end{algorithmic}
 \end{algorithm} 

\newpage

\begin{table}[!t]
    \centering
    \small
    \begin{tabularx}{\linewidth}{|c|X|}
    % \label{table:notations}
        \hline
        \rowcolor{gray!20}
        {\bf Notation} & \multicolumn{1}{c|}{\bf Description} \\            
        \thickhline
        $\pc$	     & 	Program Counter pointing to the current instruction being executed \\
        \hline
        $\wen$ 	 &	1-bit signal that represents whether MCU core is writing to memory \\
        \hline
        $\daddr$ 	 &	Memory address being accessed by MCU core \\
        \hline
        $\dmaen$   &	1-bit signal that represents whether DMA is active \\
        \hline
        $\dmaaddr$ &	Memory address being accessed by DMA \\
        \hline
        $\reset$	 &	Signal that reboots the MCU when it is set to logic `1'\\
        \hline
        $\tcr$	 &	Trusted code region, a fixed ROM region storing $\trapscasu$ software \\
        \hline        
        $\er$	     &	Executable region, a memory region where authorized (normal) software is stored \\
        \hline
        $\ep$	     &	Executable pointer, a fixed memory region storing current $\er$ boundary \\    
        \hline
        $\ivtr$	 &	Reserved memory region for the MCU's interrupt vector table \\
        \hline
        $\casumem$ &  Memory region protected by $\trapscasu$ hardware, including $\er$, $\ep$, and $\ivtr$ \\
        \hline
        $\gie$     &  Global interrupt enable, 1-bit signal that represents whether interrupts are globally enabled \\
        \hline
        $\irq$     &  1-bit signal that represents if an interrupt occurs \\
        \hline
        $\irqcfg$  &  Set of registers in DMEM used to configure of interrupts, e.g., timer deadline and UART baudrate\\
        \hline
        $\isrt$    &  Timer interrupt service routine, privileged software that controls a timer interrupt: \newline
                        $\isrt = [\isrtmin, \isrtmax]$ \\    
        \hline
        $\isru$    &  UART interrupt service routine, privileged software that handles a UART interrupt: \newline
                        $\isru = [\isrumin, \isrumax]$ \\
        \hline        
    \end{tabularx}
    \caption{Notation Summary}
\label{table:notations}
\end{table}


\begin{figure*}[t]
    % \centering
    % \small
    % \captionsetup{justification=centering}
    \begin{mdframed}[userdefinedwidth=0.95\textwidth]
        $\bullet\ $ {\it Security Properties Stemming from} $\boldsymbol{\casu}$\\
        \textbf{- \small Software Immutability in PMEM:}\\        
        \begin{equation}\label{eq:hwprop_wp}
            \textbf{G}: \{\text{modMem}(\casumem) \land (\pc \notin \tcr) \rightarrow \reset\}
        \end{equation}
        \textbf{- \small Unauthorized Software Execution Prevention:}
        \begin{equation}\label{eq:hwprop_usep}
            \textbf{G}: \{(\pc \notin \er) \land (\pc \notin \tcr) \rightarrow \reset\}
        \end{equation} \\
        $\bullet\ $ {\it Security Properties Stemming from} $\boldsymbol{\garota}$\\
        \textbf{- \small IRQ Configuration Protection:}
        \begin{equation}\label{eq:irqcfg-protection}
            \textbf{G}: \{[\neg(\pc \in \tcr) \land \wen \land (\daddr \in \irqcfg)] \lor [\dmaen \land (\dmaaddr \in \irqcfg)] \rightarrow \reset\}
        \end{equation}
        \textbf{- \small Timer ISR Execution Atomicity:}        
        \begin{equation}\label{eq:timer-isr-protection1}
            \textbf{G}: \{\neg \reset \land \neg (\pc \in \isrt) \land (\textbf{X}(\pc) \in \isrt) \rightarrow \textbf{X}(\pc) = \isrtmin \lor \textbf{X}(\reset) \}
        \end{equation}
        \begin{equation}\label{eq:timer-isr-protection2}
            \textbf{G}: \{\neg \reset \land (\pc \in \isrt) \land \neg (\textbf{X}(\pc) \in \isrt) \rightarrow \pc = \isrtmax \lor \textbf{X}(\reset) \}            
        \end{equation}
        \begin{equation}\label{eq:timer-isr-protection3}
            \textbf{G}: \{(\pc \in \isrt) \land (\irq \lor \dmaen) \rightarrow \reset \}
        \end{equation}
        \textbf{- \small UART ISR Execution Atomicity:}        
        \begin{equation}\label{eq:uart-isr-protection1}
            \textbf{G}: \{\neg \reset \land \neg (\pc \in \isru) \land (\textbf{X}(\pc) \in \isru) \rightarrow \textbf{X}(\pc) = \isrumin \lor \textbf{X}(\reset) \}
        \end{equation}
        \begin{equation}\label{eq:uart-isr-protection2}
            \textbf{G}: \{\neg \reset \land (\pc \in \isru) \land \neg (\textbf{X}(\pc) \in \isru) \rightarrow \pc = \isrumax \lor \textbf{X}(\reset) \}            
        \end{equation}
        \begin{equation}\label{eq:uart-isr-protection3}
            \textbf{G}: \{(\pc \in \isru) \land (\irq \lor \dmaen) \rightarrow \reset \}
        \end{equation}
        \textbf{- \small Interrupt Disablement Protection:}
        \begin{equation}\label{eq:irq-disablement-protection}
            \textbf{G}: \{\neg \reset \land \gie \land \neg \textbf{X}(\gie) \rightarrow (\textbf{X}(\pc) \in (\isrt \lor \isru)) \lor \textbf{X}(\reset)\}
        \end{equation}        
    \end{mdframed}
    % \vspace{-0.8em}
    \caption{\trapscasu Hardware Security Properties}\label{fig:hwprop}
    % \vspace{-0.8em}
    % \normalsize
\end{figure*}

\section*{APPENDIX C: \trapscasu Formal Verification} \label{sec:formal-verification}

We formally specify \trapscasu with \trapsnortc security goals using Linear Temporal Logic (LTL).
Formal verification plays a crucial role by showing that \trapscasu adheres to well-specified goals.
It assures that it does not exhibit any unintended behavior, especially in corner cases, 
rarely encountered conditions and/or execution paths, that humans tend to overlook.
By employing computer-aided tools, we define and validate LTL rules that govern \trapscasu operation.
The use of LTL enables precisely capturing temporal dependencies and expected behavior 
over time, ensuring that \trapscasu meets stringent security standards.
Table \ref{table:notations} describes the notation used in this section.

We use regular propositional logic, such as conjunction $\land$, disjunction $\lor$, 
negation $\neg$, and implication $\rightarrow$. A few other temporal quantifiers are used as well:
%
\begin{compactitem}
    \item $\textbf{X} \Phi$ (ne$\textbf{X}$t) -- holds if $\Phi$=true at the next system state.
    \item $\textbf{F} \Phi$ ($\textbf{F}$uture) -- holds if there is a future state when $\Phi$=true.
    \item $\textbf{G} \Phi$ ($\textbf{G}$lobally) -- holds if for all future states $\Phi$=true.
\end{compactitem}
%
Figure \ref{fig:hwprop} formally describes \trapscasu hardware security properties using 
propositional logic and temporal quantifiers. Recall that \trapscasu is based on \casu 
combined with \garota. All such properties must hold at all times to achieve \trapscasu's
security goals.

LTL \ref{eq:hwprop_wp} states that any modifications to \casumem, including \er, \ep, and \ivtr, 
trigger a reset when \trapscasu software is not running. \er is a region in PMEM, where normal 
device software resides, while \ep is a fixed region in PMEM that points to \er.
Upon a secure update, \ep is updated to point to the new verified software version.
\ivtr also resides in PMEM and contains the ISR addresses.
As stated in LTL \ref{eq:hwprop_usep}, the MCU cannot execute any code outside \er 
or \trapscasu code in read-only memory (ROM).
% \gene{What does "or not \tcr" mean?}

LTL \ref{eq:irqcfg-protection} ensures that, if the timer or the UART peripheral configurations
are modified by any software (other than the timer or UART ISR-s), a reset is triggered.
LTL \ref{eq:timer-isr-protection1}-\ref{eq:timer-isr-protection3} specify atomic operation of 
timer ISR, LTL \ref{eq:timer-isr-protection1} and LTL \ref{eq:timer-isr-protection2} guarantee 
that \isrtmin and \isrtmax are the only legal entry and exit points, respectively.
Also, LTL \ref{eq:timer-isr-protection3} states that DMA and other interrupts must remain 
inactive while timer ISR executes. Similarly, LTL 
\ref{eq:uart-isr-protection1}-\ref{eq:uart-isr-protection3} enforce UART ISR atomicity.
Finally, LTL \ref{eq:irq-disablement-protection} guarantees that \gie can be disabled 
only if the timer or UART ISR-s are running. Any violations result in a device reset.

Note that we slightly modified \casu and \garota to realize \trapscasu:
\begin{compactenum}
    \item \trapscasu employs both TimerTCB and NetTCB, while \garota uses them individually in each case.
    \item {\it Trusted PMEM Updates} rule from \garota is integrated to Equation \ref{eq:hwprop_wp}.
    \item \garota's {\it Re-Trigger on Failure} property is not viable 
    since \trapscasu cannot retain a consistent timer value upon a failure (e.g., a reset) in \trapsnortc. 
\end{compactenum}

To verify the above LTL rules, we convert the Verilog code described at the Register Transfer Level 
(RTL) to Symbolic Model Verifier (SMV) \cite{mcmillan1993smv} using Verilog2SMV \cite{irfan2016verilog2smv}.
The SMV output is in turn fed to the NuSMV \cite{cimatti2002nusmv} model-checker for specified LTL 
rule validation. NuSMV works by checking LTL specifications against the system finite-state machine 
for all reachable states. This comprehensive approach ensures that \trapscasu's security goals 
are thoroughly validated, offering robust assurance against potential vulnerabilities.
See \cite{TRAPSAnonOpenSource} for further proof details.


