\section{Related Work \label{related}}
%
\noindent~{\bf Individual Device Attestation (\ra)}
is an extensively studied topic and numerous schemes have been proposed in the literature. These 
techniques generally fall into three categories: software-based, hardware-based, and hybrid.
%
Given the lack of rich hardware features on embedded platforms, lightweight Software-based \ra 
\cite{li2011viper,seshadri2006scuba,seshadri2004swatt,surminski2021realswatt} is only viable 
for legacy devices with no secure hardware features. 
It uses request-to-response time (between \vrf and \prv) to establish confidence 
in the integrity of the attestation report.
Nonetheless, network limitations (e.g. intermittent connection, network congestion) on \prv introduce noise to the request-to-response 
time, making software-based \ra impractical.

In contrast, hardware-based \ra techniques 
\cite{mccune2010trustvisor,noorman2013sancus,strackx2010efficient,
ling2021secure,chen2019opera,chen2022mage} either (1) embed \prv attestation functionality entirely 
within dedicated hardware, 
or (2) require substantial changes to the underlying hardware to support isolated execution of trusted 
software, e.g., SGX \cite{sgx} or TrustZone \cite{trustzone}.
However, such hardware features are often too complex and costly for low-end devices constrained by 
size, energy, and cost.

Given the limitations of both hardware- and software-based approaches in low-end embedded platforms, 
software/hardware co-design (hybrid) \cite{vrased,arkannezhadida,smart,tytan,nunes2020apex,trustlite} 
has recently emerged as a promising solution. It aims to provide equivalent security guarantees to hardware-based 
\ra while minimizing modifications to the underlying hardware.
The security features employed can be simplified to utilize a ROM or a memory protection unit (MPU).
Current hybrid \ra techniques implement the integrity-ensuring function (e.g., MAC) in software.
They use trusted hardware to control the execution of this software, preventing any violations that may compromise security, such as key leakage, or preemption of unprivileged software.

RealSWATT \cite{surminski2021realswatt} introduces a software-based approach designed for continuous attestation of real-time and multi-core systems, effectively solving the TOCTOU problem.
PISTIS \cite{grisafi2022pistis} is also a software trusted computing architecture enabling memory isolation, remote attestation, and secure update.
SANCUS \cite{noorman2013sancus} and TrustVisor \cite{mccune2010trustvisor} are hardware-based solutions offering attestation service with software module isolation. 
VRASED \cite{vrased} presents a formally verified hybrid RA architecture.
It implements the attestation function in software while employing small trusted hardware to enforce the attestation correctness and access control over the \ra secret key.
IDA \cite{arkannezhadida} proposes a novel hybrid attestation method that enables interrupts even during attestation, enhancing overall system security and flexibility.
Moreover, IDA monitors program memory between attestation requests to prevent TOCTOU attacks.
As previously mentioned in Section \ref{sec:bg}, \rata, \casu, and \garota are hybrid \ra architectures.
The first two provide constant-time computation for attestation requests (heartbeat requests in \casu) regardless of the size of the attested regions.
Meanwhile, the last provides a trusted timer and network that can be preemptively executed by authorized software.
Table \ref{table:comp_ind_att} compares various software, hardware, and hybrid \ra methods.

\noindent~{\bf Network Attestation (\sa)}
%
enables scalable attestation for large groups of interconnected devices. Few prior work \cite{asokan2015seda,ambrosin2016sana,carpent2017lightweight,ibrahim2017seed,ibrahim2016darpa,kohnhauser2017scapi,nunes2019towards,kohnhauser2018salad,petzi2022scraps,kuang2019esdra,abera2019diat} refers to this process as Swarm Attestation; we employ the term Network Attestation to denote the same concept. Table \ref{table:comp_swa_att} shows a comparison with other \sa schemes.

The first scheme, SEDA \cite{asokan2015seda}, employs secure hop-by-hop aggregation of \ra reports. 
Initially, \vrf broadcasts an attestation request to \prv-s. Each \prv attests its children nodes and forwards aggregated \ra reports to its parent. Finally, \vrf verifies only the last \ra reports to assess the status of all \prv-s.
SANA \cite{ambrosin2016sana} extends SEDA with a novel aggregate signature scheme, ensuring low verification overhead with minimal trust anchor.
It partitions \prv-s into subnetworks and aggregates \ra results across the entire network, facilitating public verification by multiple \vrf-s.
LISA \cite{carpent2017lightweight} introduces neighbor-based communication to propagate \ra reports. \prv-s verify \ra reports of other \prv-s before forwarding them to prevent replay attacks, and a quality metric for \sa techniques captures the information from each \prv.
SeED \cite{ibrahim2017seed} enhances the efficiency of SEDA and resilience against DoS attacks by enabling \prv-s to self-initiate \ra.
DARPA \cite{ibrahim2016darpa} detects physically compromised devices by exchanging heartbeat messages among \prv-s to identify compromised or absent devices.
SCAPI \cite{kohnhauser2017scapi} improves DARPA;  it introduces a leader that periodically generates and distributes secret session keys among \prv-s. To receive a new session key, \prv must be authenticated with the previous key.
SAP \cite{nunes2019towards} constructs a formal model encompassing desirable efficiency, soundness, and security notions for \sa. It systematically designs a synchronous attestation protocol compliant with security goals defined by the formal model.
SALAD \cite{kohnhauser2018salad} provides lightweight message aggregation for dynamic networks with intermittent connectivity, distributing \ra proofs among all devices.

SCRAPS \cite{petzi2022scraps} proposes a Pub/Sub network \sa protocol. It involves a proxy verifying \prvâ€™s \ra reports on behalf of actual \vrf.
This proxy is implemented using smart contracts, i.e., untrusted entities hosted on a blockchain.
Once the proxy attests a \prv, \vrf-s can retrieve the \ra evidence from the proxy without trusting the proxy, enabling many-to-many attestation.
This enables many-to-many attestation by allowing \vrf-s to fetch \ra reports from the proxy.
ESDRA \cite{kuang2019esdra} designs a first many-to-one \sa scheme to eliminate fixed \vrf and reduce a single point of failure \vrf risks.
Moreover, the distributed attestation facilitates offering feedback on certain compromised \prv-s, thus suitable for half-dynamic networks.
DIAT \cite{abera2019diat} presents a control-flow attestation scheme for autonomous collaborative systems.
It combines data integrity attestation, modular attestation, and representation of execution paths, enabling efficient run-time attestation in a setting where embedded systems must act as both, \prv and \vrf.



%\vspace{0.2cm}