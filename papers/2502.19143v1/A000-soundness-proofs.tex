\section{Soundness Proofs}
After some preliminaries (\cref{subsec:preliminaries}), in this appendix we prove~\cref{thm:soundness-1}: that the reference synthesis algorithm only computes well-typed solutions (\cref{subsec:well-typed-solutions}).
Next, we prove~\cref{thm:soundness-2}: that the solutions it computes correspond to a composite path in the scope graph (\cref{subsec:composite-paths}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Preliminaries}%
\label{subsec:preliminaries}


\paragraph{Notation}
To simplify dealing with variable renaming and capture, for these proofs we assume Barendregt's convention.
Where relevant, we present the constraint set in a solver state in the order we intend to solve them.
Moreover, we are overloading some notation for brevity:
\begin{itemize}
  \item We write $\kappa \rightarrowtail \kappa'$ to denote $\exists \theta\, H'.\ \kappa \rightarrowtail \theta, H' \land \kappa' = \opsRSState{\SG}{\overline{C}}{U}{H'}\theta$\\(\ie, $\kappa$ can be expanded into $\kappa'$, ignoring other expansions).
  \item Similarly, we write $\kappa \twoheadrightarrowtail \kappa'$ to denote $\exists \overline{\kappa}'.\ \kappa \twoheadrightarrowtail \overline{\kappa}' \land \kappa' \in \overline{\kappa}'$\\(\ie, $\kappa$ can be step into $\kappa'$, ignoring other steps).
\end{itemize}
We use the $\oplus$ operator to manipulate the components of a solver state:
\[
  \kappa \oplus C = \opsRSState{\SG}{\overline{C}; C}{U}{H}
\]
Finally, we use $\SG_\kappa$, $\overline{C}_\kappa$, $U_\kappa$ and $H_\kappa$ to denote the components of a solver state $\kappa$,
or $\SG_i$, $\overline{C}_i$, $U_i$ and~$H_i$ to denote the components of a solver state $\kappa_i$, and similar for primes.


In these proofs, we will often use exhaustive application of the step relations, written with a bullet symbol ($\bullet$) and defined as follows:

\begin{definition}[Exhaustive Application]
  \[
    \inferrule{
      \kappa_1 \rightarrow^{\ast} \kappa_2 \\ \kappa \not\rightarrow
    }{
      \kappa_1 \rightarrow^{\bullet} \kappa_2
    }
  \]
  and likewise for $\rightarrowtail^{\bullet}$ and $\twoheadrightarrowtail^{\bullet}$.
\end{definition}

The $\kappa \not\rightarrow$ premise states that there are no further steps possible from $\kappa$, ensuring exhaustiveness.
The $\rightarrow^{\bullet}$ relation is only differs from the reflexive transitive closure regarding this additional premise.
As such, we will freely convert between these relations when applicable.

Next, we define which initial constraints we consider well-formed:

\begin{definition}[Well-formed Initial Constraint]
  \label{conj:wellformed-spec}
  \begin{mathpar}
    \inferrule{
      \forall \mathcal{P}\, \kappa.\
        \left(
        \mathit{FV}(\mathcal{P}) = \emptyset \land
          \opsRSState
            {\emptyset}
            {P_0(\mathcal{P})}
            {\emptyset}
            {\emptyset}
          \rightarrow^{\bullet}
            \kappa
        \right)
        \implies
          \overline{C}_\kappa = \emptyset \lor \overline{C}_\kappa = \set{\cFalse}
    }{
      \mathbb{S} \vdash P_0 \mathrel{\mathbf{init}}
    }
  \end{mathpar}
\end{definition}

This specification states that, for any \emph{ground} input program $\mathcal{P}$, the solver will either give an accepting configuration ($C_\kappa = \emptyset$),
or a rejecting configuration ($C_\kappa = \set{\cFalse}$).
That is, we exclude stuckness from being a possible result of solving the initial constraint \emph{on a ground program}.

\pagebreak[4]  %% Suggested page break

Second, along the lines of definition 4.1 by~\citet{RouvoetAPKV20}, we define the embedding of a substitution $\theta$ as the embedding of the conjunction of the equalities that it represents:

\begin{definition}[Embedding of Subtitution]
\[
  \llbracket \theta \rrbracket = \left( \mathop{\stBigAnd}\limits_{x \in \mathsf{dom}(\theta)} x \cEq x \theta  \right)
\]
\end{definition}

We use this embedding to use constraints and substitution interchangeably:

\begin{lemma}[Equivalence of Embedding and Applying Substitutions]
  \label{lem:embedding-equality}
  \begin{mathpar}
    \kappa_1 \oplus \llbracket \theta \rrbracket
    \rightarrow^{\ast}
    \kappa_2
    \land
    \overline{C}_1 \theta = \overline{C}_2
    \iff
    \kappa_1
    \theta \approx \kappa_2
  \end{mathpar}
\end{lemma}

\begin{proof}
  By induction on $\rightarrow$, using rules \textsc{Op-Conj} and \textsc{Op-Eq-True}, using the fact that unification with a free variable (such as generated by the embedding) on one side cannot fail.
\end{proof}

Finally, we state lemmas about weakening and strengthening solver trace.
First, we state that removing equality constraints from a successful solver trace cannot yield failing solver traces (it either gets stuck, or it is successful in which case the equality constraints were redundant):

\begin{lemma}[Equality Weakening]
  \label{lem:weakening}
  \begin{mathpar}
    \forall t_1\, t_2\, \kappa_1\, \kappa_2\, \kappa_2'.\ %
      \left(
      \kappa_1 \oplus (t_1 \cEq t_2)
      \rightarrow^{\bullet}
      \kappa_2
      \land
      \overline{C}_2 = \emptyset
      \right)
    \implies
      \left(
      \kappa_1
      \rightarrow^{\bullet}
      \kappa_2'
      \land
        \overline{C}_2' \neq \set{\cFalse}
      \right)
  \end{mathpar}
\end{lemma}

\begin{proof}
  The presence of equality constraints cannot block other constraints from being solved.\footnote{\label{fn:blocking}%
    This can be proved by the fact that the only negative condition on the constraint set occurs in the $\mathsf{guard}$ premise of the \textsc{Op-Query} rule.
    However, equality constraints do not affect $\mathsf{guard}$, hence all constraints in $\overline{C}$ can still be solved.
    On the other hand, the $\mathsf{guard}$ premise prevents the general version of this lemma to be true.
    This is expected, as \eg strengthening a constraint set with edge assertions could invalidate earlier queries.
  }
  Thus, if a failure state can be reached from the initial state on the right-hand side, it must have been reachable from the initial state on the left-hand side as well, by not selecting $t_1 \cEq t_2$ to be solved.
  Then, by confluence, any trace for the initial state should reach the failure state.
  This contradicts the assumption that the first trace was successful.
\end{proof}

Second, we use the lemma that strengthening a solver trace with redundant equalities (\ie, equalities that hold in the final state anyway) preserves satisfiability:

\begin{lemma}[Strengthening with Redundant Equalities]
    \label{lem:strengthening-eq}
    \begin{mathpar}
        \forall \kappa_1\, \kappa_2\, \theta.\ %
            \kappa_1
            \rightarrow^{\bullet}
            \kappa_2
        \land
            \kappa_2 \theta = \kappa_2
        %\land
        %    \mathit{FV}(\theta) \subseteq \mathit{FV}(\kappa_1)
        \implies
            \kappa_1 \oplus \llbracket \theta \rrbracket
            \rightarrow^{\ast}
                \kappa_2
    \end{mathpar}
\end{lemma}
%
\begin{remark}
    This lemma assumes that the operational semantics tracks which variables we have unified and substituted already during constraint solving.
    Without this assumption, $\theta$ may contain information that contradicts $\kappa_1$, but (due to substitution) not represented in $\kappa_2$.
    For example, when we solve a constraint \smash{$f(x) \cEq f(g())$}, for some variable $x$ and term constructors $f$ and $g$, we substitute $x$ for~$g()$, and remember in all future states that $x$ was substituted for $g()$.
    The $\theta$ in the premise of the lemma below is assumed to be \emph{consistent} with the variables that we have substituted for already, where by consistent we mean the following.
    $\theta'$ is consistent with $\theta$ when $\forall x \in \mathsf{dom}(\theta).\ x\in \mathsf{dom}(\theta') \implies \mathsf{mgu}(\theta(x), \theta'(x))\neq \bot$.
    The operational semantics does not currently track information about which variables have been unified explicitly, but can be adapted to do so.
\end{remark}

\pagebreak[4]  %% Suggested page break

\begin{proof}
    The new equalities do not prevent $\overline{C}_1$ from being solved.\footnotemark[\getrefnumber{fn:blocking}]
    Thus, the following trace exists:
    \begin{mathpar}
      \kappa_1 \oplus \llbracket \theta \rrbracket
      \rightarrow^{\ast}
      \kappa_2 \oplus \llbracket \theta \rrbracket
    \end{mathpar}
    Then, because equalities can be solved unconditionally, we can solve those next.
    \begin{mathpar}
      \kappa_2 \oplus \llbracket \theta \rrbracket
      \rightarrow^{\ast}
      \kappa_2' = \opsRSState
        {\SG_2'}
        {\overline{C}_2 \theta}
        {U_2'}
        {H_2'}
    \end{mathpar}
    Then, by~\cref{lem:embedding-equality}, $\kappa_2' = \kappa_2 \theta$.
    By the assumption that $\kappa_2 \theta = \kappa_2$, we have that $\kappa_2' = \kappa_2$.
    Therefore, a trace $\kappa_1 \oplus \llbracket \theta \rrbracket \rightarrow^{\ast} \kappa_2$ exists.
\end{proof}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Generated Proposals are Well-Typed}%
\label{subsec:well-typed-solutions}

Now, we prove our first soundness property: the algorithm only computes well-typed solutions.
\begin{theorem*}[Soundness 1: Well-Typed Solutions]
  \label{thm:soundness-1-appendix}
  \begin{alignat*}{1}
    \forall\mathbb{S}\, P_0\, \mathcal{P}\, \mathcal{P}'.\ & \mathbb{S} \vdash P_0 \mathrel{\mathbf{init}}\\
    \implies & \mathsf{synthesize}(\mathcal{P}) = \mathcal{P}'\\
    \implies & \exists\SG.\ %
      \mathbb{S} \vdash \opsRSState
        {\emptyset}
        {P_0(\mathcal{P}')}
        {\emptyset}
        {\emptyset}
      \rightarrow^{\bullet}
      \opsRSState
        {\SG}
        {\emptyset}
        {\emptyset}
        {\emptyset}
  \end{alignat*}
\end{theorem*}

This property is stating that applying the initial constraint for any synthesized program $\mathcal{P}'$ is satisfiable;
\ie, can be reduced to a \emph{successful} solver state.

\input{soundness/well-typed-proof-1}

% \iftoggle{draft}{
%     Alternatively, \cref{thm:soundness-1} can be proven as follows:

%     TODO: proof along the following lines:
%     \begin{enumerate}
%         \item Append $\llbracket \theta_{\text{result}} \rrbracket$ to the result of the trace.
%         \item By~\cref{lem:strengthening-eq}, assert that it can be solved, and yields the same state.
%         \item By confluence, assert that the $\llbracket \theta_{\text{result}} \rrbracket$ can be solved from the beginning, and still yield an equivalent result.
%         \item By~\cref{lem:weakening}, and well-formed initial constraint, assert that leaving out the expand steps still yields a type-checking program.
%     \end{enumerate}
% }{
%   % no alternative in non-draft mode
% }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Synthesized References correspond to Composite Paths}%
\label{subsec:composite-paths}

Next, we prove our second soundness property: the synthesized references correspond to a composite path to the target.
%
First, we restate our definition of composite path as a judgment $\kappa \vdash s^{\ast} \ \textsc{cp}$, stating that $s^{\ast}$ is a composite path in $\kappa$.
\begin{definition}[Composite Path]
  \[
    \inferrule[\textsc{CP-Single}]{
      %
    }{
      \kappa \vdash s \ \textsc{cp}
    }
    \qquad
    \inferrule[\textsc{CP-Comp}]{
      q = \qBase{o}{s_1}{r}{\lambda x.\, E} \textit{ is solved in } \kappa
      \\
      p \in \mathsf{Ans}(\SG_\kappa, q)
      \\
      \left(\mathsf{tgt}(p) = s_2 \lor s_2 \in \rho_{\SG_{\kappa}}(\mathsf{tgt}(p)) \right)
      \\
      \kappa \vdash s_2 \cdot s^{*} \ \textsc{cp}
    }{
      \kappa
      \vdash
        s_1 \cdot s_2 \cdot s^{*} \ \textsc{cp}
    }
  \]
\end{definition}
\begin{remark}
    The phrase `$q$ is solved in $\kappa$' can be made precise by making the state transitions ($\rightarrow$) track solved constraints explicitly.
\end{remark}
%
We use this definition to define well-formed hole states $H$:
\begin{definition}[Well-formed $H$]
  \[
    \inferrule[\textsc{H-WF}]{
      \forall (s^{\ast}, t) \in \mathsf{ran}(H_\kappa).\ \kappa \vdash s^{\ast} \  \textsc{cp}
    }{
      \kappa \  \mathsf{wf}_H
    }
  \]
\end{definition}

This definition states that a hole state $H_\kappa$ is well-formed if for each hole state $(s^{\ast}, t) \in \mathsf{ran}(H_\kappa)$, $s^{\ast}$ is a composite path in $\kappa$.
With this definition of composite paths, we can state our second soundness property as follows.

\begin{theorem}[Soundness 2: Solutions correspond to Composite Paths]
  \label{thm:soundness-2-appendix}
  \begin{mathpar}
  \forall \kappa_0\, \kappa_1.\ %
      \left( \kappa_0 \textit{ initialized by } \mathsf{synthesize} \land \kappa_0 \twoheadrightarrowtail^{\bullet}  \kappa_1 \right)
    \implies
      \kappa_1 \ \mathsf{wf}_H
  \end{mathpar}
\end{theorem}
This theorem states that every synthesis result yields hole states $(s^{\ast}, t) \in \mathsf{ran}(H_1)$ such that $s^{\ast}$ forms a composite path.
%
To prove this theorem, we need the lemma that $\rightarrow$ preserves hole state well-formedness.
\begin{lemma}
  \label{lem:solve-preserves-wfh}
  \begin{mathpar}
    \forall \kappa_0\, \kappa_1.\ %
      \kappa_0 \ \mathsf{wf}_H
      \land
      \kappa_0 \rightarrow \kappa_1
    \implies
      \kappa_1 \ \mathsf{wf}_{H}
  \end{mathpar}
\end{lemma}
\begin{proof}
    This can be proven by case analysis on $\rightarrow$, where none of the rules modify the hole state (apart from substitution, which does not affect the $s^{\ast}$ component, as it is ground).
\end{proof}

\pagebreak[4]  %% Suggested page break

Ideally, we would prove a similar lemma for $\twoheadrightarrowtail$ as well.
However, this cannot be done, as \textsc{Op-Expand-Query} prepends a scope to the composite path in $H(h)$, for which the corresponding query is not yet solved.
Instead, we prove the following lemma, that states that, after an expand-step, subsequent solving ensures that $H$ will \emph{eventually} be well-formed.

\begin{lemma}
  \label{lem:expand-eventually-preserves-wfh}
  \begin{mathpar}
    \forall \kappa_0\, \kappa_1\, \kappa_2.\ %
      \kappa_0 \ \mathsf{wf}_{H}
      \land
      \kappa_0 \rightarrowtail \kappa_1 \rightarrow^{\bullet} \kappa_2
    \implies
      \kappa_2 \ \mathsf{wf}_{H}
  \end{mathpar}
\end{lemma}

\begin{proof}
  This lemma can be proven by case analysis on the $\kappa_0 \rightarrowtail \kappa_1$ step:
  \begin{itemize}
    \item \textsc{Op-Expand-Pred}: This rule does not affect $H$, hence $\kappa_1 \ \mathsf{wf}_{H}$ and by~\cref{lem:solve-preserves-wfh}, $\kappa_2 \ \mathsf{wf}_{H}$.
    \item \textsc{Op-Expand-Query}: This rule expands a query \smash{$q = \qBase{o}{s'}{r}{\lambda x.\, E}$}.
      As a result, it prepends $s'$ to the composite path \smash{$(s'' \cdot s^{\ast}, t) \in \mathsf{ran}(H_0)$}.
      When proving $\kappa_1 \ \mathsf{wf}_{H}$, by inversion using \textsc{H-WF} and \textsc{CP-Comp}, we have the following proof obligations:
      \begin{itemize}
          \item $q$ is solved in $\kappa_1$,
          \item $p \in \mathsf{Ans}(\SG_1, q) \land (\mathsf{tgt}(p) = s'' \lor s'' \in \rho_{\SG_1}(\mathsf{tgt}(p)))$, and
          \item $\kappa_1 \vdash s'' \cdot s^{*} \ \textsc{cp}$.
      \end{itemize}
      The second obligation is a direct consequences of the \textsc{Op-Expand-Query} rule, and the last obligation is a direct consequence of the $\kappa_0 \ \mathsf{wf}_{H}$ assumption.
      However, the first premise is not yet satisfied, as \textsc{Op-Expand-Query} does not actually solve $q$.

      To prove that $\kappa_2 \ \mathsf{wf}_{H}$, we need to show that $q$ is solved in $\kappa_2$.
      To this end, observe that the premises of \textsc{Op-Expand-Query} entail the premises of \textsc{Op-Query} for $q$.
      Hence, $q$ is not \emph{blocked}; it \emph{can} be solved in $\kappa_1$.
      Thus, a state $\kappa_1'$ exists such that $\kappa_1 \rightarrow \kappa_1'$ and $q$ is solved in $\kappa_1'$.
      For that reason, $\kappa_1' \ \mathsf{wf}_{H}$.
      Now, consider the state $\kappa_2'$ obtained after solving $\kappa_1'$ completely (\ie, $\kappa_1' \rightarrow^{\bullet} \kappa_2'$).
      By~\cref{lem:solve-preserves-wfh}, $\kappa_2' \ \mathsf{wf}_{H}$.
      Finally, by confluence of the operational semantics, $\kappa_2' \approx \kappa_2$, and hence $\kappa_2 \ \mathsf{wf}_{H}$.
  \end{itemize}
\end{proof}

With these lemmas in place, we can prove~\cref{thm:soundness-2}:
\begin{proof}
  Observe that any synthesis trace $\kappa_0 \twoheadrightarrowtail^{\bullet} \kappa_n$ can be decomposed into parts that start with an expand step, and a sequence of solve steps:
  \[
    \left[\kappa_{i-1} \rightarrowtail \kappa_i' \rightarrow^{\bullet} \kappa_i  \right]_{i \in 1\ldots n}
  \]
  We can prove the theorem using induction over the segments $1 \ldots n$ of the synthesis trace:
  \begin{itemize}
    \item \textit{Base case}: $ \kappa_0 \ \mathsf{wf}_{H}$.
        This case is trivial, as each value in $H_0$ is initialized to the target scope~$s_d$, which is a composite path by \textsc{CP-Single}.
    \item \textit{Inductive case}: Follows immediately from~\cref{lem:expand-eventually-preserves-wfh}.
  \end{itemize}
  This proves $\kappa_n \ \mathsf{wf}_{H}$, and hence each synthesized reference corresponds to a composite path.
\end{proof}
