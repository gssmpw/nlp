\section{Related Work}
\label{sec:related_work}

In this paper, we study in-memory dynamic graph storage____ that supports concurrent read and write queries, particularly single updates. Below, we discuss the related work.

\noindent\textbf{Graph Databases and Benchmarks.} Graph databases such as Neo4J, Virtuoso, and K`uzu____ also support transactions. They typically operate on external storage and focus on supporting labeled property graphs. Some, like Neo4J, use the read-committed isolation level____ to improve performance and simplify transaction management. Additionally, there are graph databases designed for distributed environments____, which focus on optimizing communication and distributed storage. For graph benchmarks, LDBC provides a variety of workloads____ to evaluate the performance of graph databases. These workloads also use labeled property graphs with various operations on labels or properties. Our paper focuses on in-memory DGS, optimizing operations on graph topology. These existing DGS methods do not consider labels and properties, and thus cannot be directly applied. However, as the labeled property graph model is widely used, researching DGS on this model is an interesting direction, for example, combining DGS with well-designed columnar graph storage____.

\noindent\textbf{Graph Processing Frameworks.} Many frameworks have been proposed for parallel analysis of static graphs, such as Ligra____ and Ligra+____ for single-machine environments, and Pregel____, Giraph____, Gemini____, and Grapes____ for distributed environments. These frameworks typically use CSR for in-memory storage and focus on parallelization strategies that exploit inter-query parallelism for graph queries like BFS, SSSP, and PR.

\noindent\textbf{Dynamic Graph Processing Frameworks.} Dynamic graph processing frameworks target frequently updated graphs. They focus on designing novel approaches to maintain intermediate results for graph queries, reducing the overhead of re-computation when the graphs are modified. For example, KickStarter____ minimizes unnecessary computations by obtaining a trimmed approximate subset of the nodes affected by the update. RisGraph____ uses a variant of adjacency lists and sparse arrays as its storage structure and can switch between vertex parallelism and edge parallelism. To achieve streaming processing, it employs a tree-based classification of safe and unsafe updates. GraphZeppelin____ uses new linear sketching data structures to solve the streaming connected components problem. These studies are orthogonal to our research.