\section{Experimental Results} \label{sec:experiments}

For brevity, we report the results for \emph{lj}, a sparse graph with no high-degree vertices, and \emph{g5}, a dense graph with high-degree vertices. Due to space limit, we have included the results on three graph analytics
queries: BFS, SSSP, and WCC, graph operation latency and the comparison with their original implementations in the complete version. We omit the results of LLAMA due to its memory consumption issues.  \sun{Guided by Equation \ref{eq:cost}, we conduct experiments according to the following roadmap.}

% We have included the results on the efficiency of vertex indexes, the latency of graph operations, and the comparison with their original implementations in the complete version~\cite{anonymous2024}.

% \vspace{-10pt}
\sun{
\begin{itemize}[leftmargin=*]
\item \textbf{Graph Container Efficiency:} We measure the raw performance of graph containers on basic operations such as search, scan, and insert, as well as on graph analytics queries. These experiments are conducted in a single-threaded environment without concurrency control to isolate the baseline performance.
\item \textbf{Concurrency Control Effectiveness:} We assess the impact of concurrency control on query performance, scalability across varying workloads, and the efficiency of concurrent read and write operations.
\item \textbf{Batch Granularity:} We examine system performance under batch updates, focusing on behavior with different batch sizes.
\item \textbf{Memory Usage:} We compare the memory overhead of competing methods against static graph formats.
\end{itemize}
}

\subsection{Evaluation of Graph Containers} \label{sec:graph_container_efficiency}

To compare the absolute performance of graph containers, we execute graph queries bypassing concurrency control operations in Figure \ref{fig:primitive_opeartions}. The elements in both vertex and neighbor indexes contain only vertex IDs without version information.

% Since there is no concurrency control, the experiment is performed using a single thread.

\subsubsection{Efficiency of Vertex Indexes.} Figure \ref{fig:vertex_index_performances} presents the results for three vertex indexes listed in Table \ref{tab:summary_methods}. For search efficiency, the dynamic array achieves speedups of over 2.6x compared to the hash table and two orders of magnitude compared to the AVL tree. Since \textsc{SearchVtx} is a step in graph operations on edges, this difference can significantly affect edge operations. Vertices are inserted in vertex ID order since existing methods incrementally assign vertex IDs from 0, as discussed in Section \ref{sec:preliminaries}. The throughput of the dynamic array is approximately 2x and 8x higher than the hash table and AVL tree, respectively. The AVL tree is very slow because it copies the path for multiple graph snapshots. For scan operations, dynamic arrays are 4x faster than counterparts.

% \sun{[TODO: Add one sentence to describe the scan efficiency.]} 


\begin{figure}[h]
	\setlength{\abovecaptionskip}{0pt}
	\setlength{\belowcaptionskip}{0pt}
		\captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
	\centering
    \includegraphics[width=0.6\textwidth]{img/exp_figs/figure13/legend.pdf}
    
    \begin{subfigure}[t]{0.20\textwidth}
    		\centering
    		\includegraphics[width=\textwidth]{img/exp_figs/figure13/search.pdf}
    		\caption{\textsc{SearchVtx}.}
    		\label{fig:vertex_search_performance}
    \end{subfigure}  
    \begin{subfigure}[t]{0.20\textwidth}
    		\centering
    		\includegraphics[width=\textwidth]{img/exp_figs/figure13/insert.pdf}
    		\caption{\textsc{InsVtx}.}
    		\label{fig:vertex_insert_performance}
    \end{subfigure}
    \begin{subfigure}[t]{0.20\textwidth}
    		\centering
    		\includegraphics[width=\textwidth]{img/exp_figs/figure13/scan.pdf}
    		\caption{\textsc{ScanVtx}.}
    		\label{fig:vertex_scan_performance}
    \end{subfigure}     
    \caption{Efficiency of vertex indexes.}
    \label{fig:vertex_index_performances}
\end{figure}


\subsubsection{Efficiency of Neighbor Indexes} \label{sec:effiency_of_neighbor_indexes}

To provide a performance reference for segmented PAM in Aspen, we implement O-Aspen, which uses a dynamic array as the vertex index and does not create vertex index snapshots for insert operations.

\begin{figure}[h!]
	\setlength{\abovecaptionskip}{0pt}
	\setlength{\belowcaptionskip}{-2pt}
		\captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
	\centering
    \includegraphics[width=0.60\columnwidth]{img/exp_figs/figure1/legend.pdf}\\
	\begin{subfigure}[t]{0.30\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/exp_figs/figure1/Check_edge_b.pdf}
		\caption{Vary $|B|$ when $|N(u)| = 2 ^ {20}$.}
		\label{fig:search_vary_block_size}
	\end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/exp_figs/figure1/Check_edge_c.pdf}
		\caption{Vary $|N(u)|$ when $|B| = 256$.}
		\label{fig:search_vary_neighbor_set_size}
	\end{subfigure}
    \begin{subfigure}[t]{0.60\textwidth}
		\centering
        % \raisebox{7.5pt}[0pt][0pt]{\hspace{-5mm}
		\includegraphics[width=\textwidth]{img/exp_figs/figure1/Check_edge_d.pdf}
		\caption{Vary real-world graphs when $|B| = 256$.}
		\label{fig:search_vary_graphs}
	\end{subfigure}
    
	\caption{Efficiency of \textsc{SearchEdge}.}
	\label{fig:search}
\end{figure}

\noindent\textbf{\textsc{SearchEdge}.} Figure \ref{fig:search} presents the results on search efficiency. LiveGraph and AdjLst keep $N(u)$ in a continuous array and are therefore unaffected by $|B|$ in Figure \ref{fig:search_vary_block_size}. LiveGraph runs slowly due to its unsorted neighbor index, while AdjLst performs the best, benefiting from efficient binary search on the continuous array. All segmented indexes perform better as $|B|$ increases, due to fewer blocks and lower block-index search overhead. O-Aspen, Aspen, and Teseo are much faster than Sortledton due to their efficient block indexing. Overall, AdjLst runs 1.2-5.8x times faster than O-Aspen and Teseo, and they are very close in performance on small neighbor sets in Figure \ref{fig:search_vary_neighbor_set_size}. Additionally, except for LiveGraph, search efficiency slightly decreases as $|N(u)|$ increases.

Figure \ref{fig:search_vary_graphs} illustrates the results on real-world graphs. These methods exhibit similar relative performance as shown in Figures \ref{fig:search_vary_block_size} and \ref{fig:search_vary_neighbor_set_size}, except for LiveGraph. LiveGraph is competitive with Sortledton on \emph{lj} and \emph{ct} but much slower on the other graphs. This is because most vertices in \emph{lj} and \emph{ct} have small degrees and no vertices with very high degrees.

% Aspen's throughput is slightly higher on \emph{lj} and \emph{g5} than in Figure \ref{fig:vertex_search_performance} because searching neighbors frequently visit high-degree vertices, improving cache locality.


\begin{figure}[h!]
	\setlength{\abovecaptionskip}{0pt}
	\setlength{\belowcaptionskip}{0pt}
		\captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
	\centering
    \includegraphics[width=0.60\textwidth]{img/exp_figs/figure1/legend.pdf}\\
	\begin{subfigure}[t]{0.30\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/exp_figs/figure4/Insert_b.pdf}
		\caption{Vary $|B|$ when $|N(u)| = 2 ^ {20}$.}
		\label{fig:insert_vary_block_size}
	\end{subfigure}
        \begin{subfigure}[t]{0.30\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/exp_figs/figure4/Insert_c.pdf}
		\caption{Vary $|N(u)|$ when $|B| = 256$.}
		\label{fig:insert_vary_neighbor_set_size}
	\end{subfigure}
        \begin{subfigure}[t]{0.60\textwidth}
		\centering
        % \raisebox{7.5pt}[0pt][0pt]{
		\includegraphics[width=\textwidth]{img/exp_figs/figure4/Insert_d.pdf}
		\caption{Vary real-world graphs when $|B| = 256$.}
		\label{fig:insert_vary_graphs}
        
	\end{subfigure}
    
	\caption{Efficiency of \textsc{InsEdge}.}
	\label{fig:insert}
\end{figure}


\vspace{2pt}
\noindent\textbf{\textsc{InsEdge}.} As shown in Figure \ref{fig:primitive_opeartions}, insert efficiency is closely related to search efficiency. Figures \ref{fig:insert_vary_block_size} and \ref{fig:insert_vary_neighbor_set_size} show that Teseo performs the best among segmented neighbor indexes. Although O-Aspen is faster than Teseo for search efficiency, it is slower for inserts due to the overhead of CoW. In Figure \ref{fig:insert_vary_block_size}, the performance of both Teseo and Aspen first increases and then decreases slightly because increasing block size reduces the time to locate the target block but increases the time required to copy data when inserting an element in the block.


While AdjLst performs the best for search, it is slow for inserts because it may need to move a large number of elements. Conversely, LiveGraph is slow for inserts because its search is slow. \sun{Specifically, LiveGraph checks whether the element to be inserted already exists, requiring a search operation. If the element exists, it updates the timestamp and appends a new version; otherwise, it directly appends the new version. However, since the neighbors are unsorted, LiveGraph must iterate through the entire neighbor set, leading to significant overhead. Although LiveGraph uses a bloom filter to reduce searches for non-existent edges, it struggles with existing edges, and false positives arise due to the filterâ€™s limited memory space.} Figure \ref{fig:insert_vary_graphs} presents the results on the real-world graphs. LiveGraph and AdjLst outperform the counterparts on \emph{lj} and \emph{ct} because the two graphs are very sparse and have no vertices with high degree. Teseo generally works very well on all graphs.

% In summary, LiveGraph and AdjLst, which use continuous storage, are slightly faster for inserts on very small neighbor sets (e.g., 16), but much slower than segmented methods on large neighbor sets. Teseo performs the best among segmented methods. 


\begin{figure}[h!]
	\setlength{\abovecaptionskip}{0pt}
	\setlength{\belowcaptionskip}{0pt}
		\captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
	\centering
    \includegraphics[width=0.60\textwidth]{img/exp_figs/figure1/legend.pdf}\\
	\begin{subfigure}[t]{0.30\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/exp_figs/figure1/Scan_neighbor_b.pdf}
		\caption{Vary $|B|$ when $|N(u)| = 2 ^ {20}$.}
		\label{fig:scan_vary_block_size}
	\end{subfigure}
        \begin{subfigure}[t]{0.30\textwidth}
		\centering
		\includegraphics[width=\textwidth]{img/exp_figs/figure1/Scan_neighbor_c.pdf}
		\caption{Vary $|N(u)|$ when $|B| = 256$.}
		\label{fig:scan_vary_neighbor_set_size}
	\end{subfigure}
        \begin{subfigure}[t]{0.60\textwidth}
		\centering
        % \raisebox{7.5pt}[0pt][0pt]{
		\includegraphics[width=\textwidth]{img/exp_figs/figure1/Scan_neighbor_d.pdf}
		\caption{Vary real-world graphs when $|B| = 256$.}
		\label{fig:scan_vary_realworld_graphs}
	\end{subfigure}
	\caption{Efficiency of \textsc{ScanNbr}.}
	\label{fig:scan}
\end{figure}


\noindent\textbf{\textsc{ScanNbr}.} Figure \ref{fig:scan} presents the results on scan efficiency. LiveGraph and AdjLst perform the best due to their continuous storage. Among segmented methods, Teseo runs up to 10x faster than its counterparts due to its reduced branch misses and instruction overhead in PMA compared to the skip list and PAM. Notably, Teseo's performance is close to that of LiveGraph and AdjLst when $|B| = 1024$. Figure \ref{fig:scan_vary_realworld_graphs} illustrates the results on real-world graphs. Consistent with Figures \ref{fig:scan_vary_block_size} and \ref{fig:scan_vary_neighbor_set_size}, AdjLst and LiveGraph perform the best, with Teseo being the best among segmented methods. Specifically, Teseo achieves 52-77\% of AdjLst's performance.

\small
\begin{table}[ht]
\caption{\sun{Hardware metrics on \textsc{ScanNbr} with $|N(v)| = 2^{20}$ and $|B| = 256$. Lg, Ap, Ts, and Sl represent LiveGraph, Aspen, Teseo, and Sortledton, respectively.}}
% \resizebox{\columnwidth}{!}{%
\begin{tabular}{|c|cc|ccc|}
\hline
            & \multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Continuous Neighbor Index\end{tabular}}} & \multicolumn{3}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Segmented Neighbor Index\end{tabular}}}             \\ \hline
\textbf{Metric} &
  \multicolumn{1}{c|}{\textbf{AdjLst}} &
  \textbf{Lg} &
  \multicolumn{1}{c|}{\textbf{Ap}} &
  \multicolumn{1}{c|}{\textbf{Ts}} &
  \textbf{Sl} \\ \hline
L1 miss     & \multicolumn{1}{c|}{2.57e8}           & 2.53e8          & \multicolumn{1}{c|}{2.38e8} & \multicolumn{1}{c|}{2.65e8} & 5.48e8 \\ \hline
L2 miss     & \multicolumn{1}{c|}{1.35e8}           & 2.38e8          & \multicolumn{1}{c|}{1.82e8} & \multicolumn{1}{c|}{2.15e8} & 2.86e8 \\ \hline
LLC miss    & \multicolumn{1}{c|}{1.34e8}           & 1.34e8          & \multicolumn{1}{c|}{1.84e8} & \multicolumn{1}{c|}{2.15e8} & 2.38e8 \\ \hline
DTLB miss   & \multicolumn{1}{c|}{1.19e4}           & 1.20e4          & \multicolumn{1}{c|}{1.94e6} & \multicolumn{1}{c|}{4.20e6} & 4.32e6 \\ \hline
Branch miss & \multicolumn{1}{c|}{1.20e3}           & 2.23e3                 & \multicolumn{1}{c|}{7.90e6} & \multicolumn{1}{c|}{1.50e3} & 6.24e6 \\ \hline
\begin{tabular}[c]{@{}c@{}}Instruction \\ Number\end{tabular} &
  \multicolumn{1}{c|}{1.07e9} &
  1.61e9 &
  \multicolumn{1}{c|}{7.57e9} &
  \multicolumn{1}{c|}{1.14e9} &
   1.18e10 \\ \hline
\end{tabular}%
% }
\label{tab:hardware performance}
\end{table}


Table \ref{tab:hardware performance} presents hardware utilization for competing methods on \textsc{ScanNbr}. We specifically measure cache misses (L1, L2, LLC, and DTLB), branch mispredictions, and number of instructions. Segmented neighbor indexes incur more cache misses than continuous methods due to their non-contiguous memory layout. Particularly, benefiting from continuous storage, AdjLst and LiveGraph have much fewer DTLB misses than counterparts. Additionally, the number of instructions are higher for segmented methods, reflecting the complexity of managing multiple segments during traversal. Branch mispredictions are also more frequent in segmented indexes, leading to performance penalties from pipeline stalls. These factors together result in higher overhead for segmented neighbor indexes during scanning.

\subsubsection{Evaluation on Graph Analytical Queries}
\small
\begin{table}[h!]
\captionsetup{skip=0pt}
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
\caption{Performance of competing methods on graph analytical queries (measured in seconds). Lg, Ap, Ts and Sl denote LiveGraph, Aspen, Teseo and Sortledton, respectively.}
\label{tab:performance_comparison}

% \resizebox{\textwidth}{!}{

\centering
\begin{tabular}{|c|ccc|ccccc|}

\hline
 &
  \multicolumn{3}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Continuous Neighbor Index\end{tabular}}} &
  \multicolumn{5}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Segmented Neighbor Index\end{tabular}}} \\ \hline
\multirow{2}{*}{\textbf{Dataset}} &
  \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{CSR}}} &
  \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{AdjLst}}} &
  \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Lg}}} &
  \multicolumn{2}{c|}{\textbf{Ap}} &
  \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Ts}}} &
  \multicolumn{2}{c|}{\textbf{Sl}} \\ \cline{5-6} \cline{8-9} 
 &
  \multicolumn{1}{c|}{} &
  \multicolumn{1}{c|}{} &
   &
  \multicolumn{1}{c|}{w} &
  \multicolumn{1}{c|}{wo} &
  \multicolumn{1}{c|}{} &
  \multicolumn{1}{c|}{w} &
  wo \\ \hline
\textbf{PR} &
   &
   &
   &
   &
   &
   &
   &
   \\ \hline
\emph{lj} &
  \multicolumn{1}{c|}{\textbf{4.66}} &
  \multicolumn{1}{c|}{9.00} &
  11.88 &
  \multicolumn{1}{c|}{13.72} &
  \multicolumn{1}{c|}{24.61} &
  \multicolumn{1}{c|}{13.19} &
  \multicolumn{1}{c|}{\textbf{13.06}} &
  28.41 \\ \hline
\emph{dl} &
  \multicolumn{1}{c|}{\textbf{1.39}} &
  \multicolumn{1}{c|}{1.43} &
  1.92 &
  \multicolumn{1}{c|}{5.03} &
  \multicolumn{1}{c|}{5.22} &
  \multicolumn{1}{c|}{\textbf{2.01}} &
  \multicolumn{1}{c|}{5.53} &
  5.24 \\ \hline
\emph{ldbc} &
  \multicolumn{1}{c|}{\textbf{20.57}} &
  \multicolumn{1}{c|}{28.79} &
  34.19 &
  \multicolumn{1}{c|}{\textbf{44.28}} &
  \multicolumn{1}{c|}{113.36} &
  \multicolumn{1}{c|}{90.68} &
  \multicolumn{1}{c|}{48.09} &
  183.19 \\ \hline
\emph{g5} &
  \multicolumn{1}{c|}{\textbf{20.98}} &
  \multicolumn{1}{c|}{29.20} &
  55.73 &
  \multicolumn{1}{c|}{43.19} &
  \multicolumn{1}{c|}{80.35} &
  \multicolumn{1}{c|}{\textbf{38.51}} &
  \multicolumn{1}{c|}{48.30} &
  77.46 \\ \hline
\emph{wk} &
  \multicolumn{1}{c|}{\textbf{6.64}} &
  \multicolumn{1}{c|}{10.45} &
  14.67 &
  \multicolumn{1}{c|}{20.73} &
  \multicolumn{1}{c|}{53.06} &
  \multicolumn{1}{c|}{33.11} &
  \multicolumn{1}{c|}{\textbf{19.30}} &
  41.56 \\ \hline
\emph{ct} &
  \multicolumn{1}{c|}{\textbf{1.88}} &
  \multicolumn{1}{c|}{6.58} &
  7.25 &
  \multicolumn{1}{c|}{7.96} &
  \multicolumn{1}{c|}{15.84} &
  \multicolumn{1}{c|}{11.02} &
  \multicolumn{1}{c|}{\textbf{7.71}} &
  21.78 \\ \hline
\emph{tw} &
  \multicolumn{1}{c|}{\textbf{24.87}} &
  \multicolumn{1}{c|}{39.77} &
  43.89 &
  \multicolumn{1}{c|}{60.33} &
  \multicolumn{1}{c|}{105.96} &
  \multicolumn{1}{c|}{\textbf{55.58}} &
  \multicolumn{1}{c|}{65.24} &
  132.47 \\ \hline
\emph{nft} &
  \multicolumn{1}{c|}{\textbf{10.60}} &
  \multicolumn{1}{c|}{19.00} &
  24.52 &
  \multicolumn{1}{c|}{34.13} &
  \multicolumn{1}{c|}{103.19} &
  \multicolumn{1}{c|}{72.09} &
  \multicolumn{1}{c|}{\textbf{34.05}} &
  178.13 \\ \hline
\textbf{TC} &
   &
   &
   &
   &
   &
   &
   &
   \\ \hline
\emph{lj} &
  \multicolumn{1}{c|}{\textbf{15.36}} &
  \multicolumn{1}{c|}{23.57} &
  / &
  \multicolumn{1}{c|}{30.30} &
  \multicolumn{1}{c|}{52.95} &
  \multicolumn{1}{c|}{\textbf{29.95}} &
  \multicolumn{1}{c|}{27.73} &
  31.79 \\ \hline
\emph{dl} &
  \multicolumn{1}{c|}{\textbf{452.36}} &
  \multicolumn{1}{c|}{467.72} &
  / &
  \multicolumn{1}{c|}{620.72} &
  \multicolumn{1}{c|}{620.19} &
  \multicolumn{1}{c|}{\textbf{501.16}} &
  \multicolumn{1}{c|}{626.52} &
  571.12 \\ \hline
\emph{ldbc} &
  \multicolumn{1}{c|}{\textbf{89.24}} &
  \multicolumn{1}{c|}{115.70} &
  / &
  \multicolumn{1}{c|}{1404.68} &
  \multicolumn{1}{c|}{1750.89} &
  \multicolumn{1}{c|}{\textbf{142.19}} &
  \multicolumn{1}{c|}{172.66} &
  240.49 \\ \hline
\emph{g5} &
  \multicolumn{1}{c|}{\textbf{1042.68}} &
  \multicolumn{1}{c|}{1220.60} &
  / &
  \multicolumn{1}{c|}{1774.84} &
  \multicolumn{1}{c|}{1971.00} &
  \multicolumn{1}{c|}{\textbf{1395.10}} &
  \multicolumn{1}{c|}{1890.74} &
  1605.42 \\ \hline
\emph{wk} &
  \multicolumn{1}{c|}{\textbf{7.63}} &
  \multicolumn{1}{c|}{13.58} &
  / &
  \multicolumn{1}{c|}{42.43} &
  \multicolumn{1}{c|}{77.81} &
  \multicolumn{1}{c|}{\textbf{17.10}} &
  \multicolumn{1}{c|}{17.05} &
  18.91 \\ \hline
\emph{ct} &
  \multicolumn{1}{c|}{\textbf{3.17}} &
  \multicolumn{1}{c|}{4.74} &
  / &
  \multicolumn{1}{c|}{6.13} &
  \multicolumn{1}{c|}{16.78} &
  \multicolumn{1}{c|}{\textbf{5.91}} &
  \multicolumn{1}{c|}{5.31} &
  6.58 \\ \hline
\emph{tw} &
  \multicolumn{1}{c|}{\textbf{801.14}} &
  \multicolumn{1}{c|}{860.73} &
  / &
  \multicolumn{1}{c|}{1272.99} &
  \multicolumn{1}{c|}{1467.60} &
  \multicolumn{1}{c|}{\textbf{958.66}} &
  \multicolumn{1}{c|}{1295.46} &
  1092.51 \\ \hline
\emph{nft} &
  \multicolumn{1}{c|}{\textbf{218.23}} &
  \multicolumn{1}{c|}{346.04} &
  / &
  \multicolumn{1}{c|}{857.27} &
  \multicolumn{1}{c|}{1011.24} &
  \multicolumn{1}{c|}{\textbf{382.77}} &
  \multicolumn{1}{c|}{486.28} &
  482.18 \\ \hline
\end{tabular}

% }
\end{table}

% Please add the following required packages to your document preamble:
% \usepackage{multirow}
% \usepackage{graphicx}



Table \ref{tab:performance_comparison} reports the results for PR and TC, while the results for BFS, SSSP, and WCC are included in the full version. PR requires fast scan efficiency, whereas TC relies on efficient set intersection, necessitating both efficient search and scan in sorted order. Consequently, LiveGraph cannot support TC. All segmented methods set $|B|$ to 256. Aspen-w enables the flatten optimization, and Sortledton-w enables adaptive indexing with the threshold set to 256.

First, continuous methods outperform segmented methods. CSR runs faster than AdjLst with all neighbor sets in a single array. Both AdjLst and LiveGraph store neighbor sets in separate arrays, but AdjLst runs 1.0-1.9x faster because LiveGraph scans from the end of the array, preventing automatic vectorization by the compiler using SIMD. Although manual vectorization is possible, it introduces significant engineering challenges. Second, Teseo generally performs the best among segmented methods without optimizations because it stores blocks of $N(u)$ continuously. Third, enabling adaptive indexing achieves a speedup of 1.0-5.2x. Enabling flatten optimization improves performance by 1.0-3.0x. Nevertheless, CSR achieves a significant speedup, ranging from 1.2-53.7x, over the best segmented methods in each case.

% \sun{Tables \ref{tab:hardware pagerank} and \ref{tab:hardware tc} present hardware metrics for PR and TC, respectively, including cache misses (L1, L2, LLC, and DTLB), branch mispredictions, and instructions per operation. Although segmented neighbor indexes share the same big-O time complexity as continuous indexes, they result in higher cache miss rates (L1, L2, LLC), more branch mispredictions, and increased instruction counts, especially with the larger dataset \emph{g5}. Additionally, while both CSR and AdjLst store neighbor sets as continuous arrays, CSR exhibits lower cache miss rates due to its compact memory format. This difference is more pronounced in TC queries, where segmented methods consistently incur higher cache miss rates. Adaptive indexing mechanisms reduce LLC misses by 3.6\%-57.1\%, while flatten optimizations lower LLC cache misses by 5.0\%-30.2\% and DTLB miss rates by 2.1\%-42.1\%, contributing to the performance improvements observed in both PR and TC queries.}


\begin{table}[h!]
\caption{\sun{Hardware metrics of competing methods on PR and TC (measured in billions). Lg, Ap, Ts and Sl denote LiveGraph, Aspen, Teseo and Sortledton, respectively.}}
% \Huge
% \resizebox{\columnwidth}{!}{%
% \renewcommand{\arraystretch}{1.1}
\small
\begin{tabular}{|ccccc|ccccc|}
\hline
\multicolumn{2}{|c|}{}                                                                                             & \multicolumn{3}{c|}{\textbf{Continuous Neighbor Index}}                                                                                   & \multicolumn{5}{c|}{\textbf{Segmented Neighbor Index}}                                                                                                                 \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\textbf{Metric}}}    & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Dataset}}} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{CSR}}} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{AdjLst}}} & \multirow{2}{*}{\textbf{Lg}} & \multicolumn{2}{c|}{\textbf{Ap}}                                   & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Ts}}} & \multicolumn{2}{c|}{\textbf{Sl}}              \\ \cline{6-7} \cline{9-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{}                                  & \multicolumn{1}{c|}{}                              & \multicolumn{1}{c|}{}                                 &                              & \multicolumn{1}{c|}{\textbf{w}} & \multicolumn{1}{c|}{\textbf{wo}} & \multicolumn{1}{c|}{}                             & \multicolumn{1}{c|}{\textbf{w}} & \textbf{wo} \\ \hline
\multicolumn{1}{|c|}{\textbf{PR}}                         &                                                        &                                                    &                                                       &                              &                                 &                                  &                                                   &                                 &             \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{L1 miss}}            & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.83}                          & \multicolumn{1}{c|}{0.86}                             & 0.97                         & \multicolumn{1}{c|}{0.89}       & \multicolumn{1}{c|}{0.95}        & \multicolumn{1}{c|}{0.92}                         & \multicolumn{1}{c|}{0.85}       & 0.93        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{5.13}                          & \multicolumn{1}{c|}{5.23}                             & 5.47                         & \multicolumn{1}{c|}{5.28}       & \multicolumn{1}{c|}{5.46}        & \multicolumn{1}{c|}{5.37}                         & \multicolumn{1}{c|}{5.24}       & 5.37        \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{L2 miss}}            & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.80}                          & \multicolumn{1}{c|}{0.96}                             & 1.10                         & \multicolumn{1}{c|}{0.96}       & \multicolumn{1}{c|}{1.07}        & \multicolumn{1}{c|}{1.45}                         & \multicolumn{1}{c|}{0.94}       & 1.35        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{4.22}                          & \multicolumn{1}{c|}{4.59}                             & 4.86                         & \multicolumn{1}{c|}{4.78}       & \multicolumn{1}{c|}{4.97}        & \multicolumn{1}{c|}{5.76}                         & \multicolumn{1}{c|}{4.96}       & 5.68        \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{LLC miss}}           & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.16}                          & \multicolumn{1}{c|}{0.32}                             & 0.46                         & \multicolumn{1}{c|}{0.30}       & \multicolumn{1}{c|}{0.43}        & \multicolumn{1}{c|}{0.81}                         & \multicolumn{1}{c|}{0.30}       & 0.70        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{0.93}                          & \multicolumn{1}{c|}{1.26}                             & 1.53                         & \multicolumn{1}{c|}{1.27}       & \multicolumn{1}{c|}{1.53}        & \multicolumn{1}{c|}{2.38}                         & \multicolumn{1}{c|}{1.57}       & 2.28        \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{DTLB miss}}          & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{8.20}                          & \multicolumn{1}{c|}{8.74}                             & 8.91                         & \multicolumn{1}{c|}{8.12}       & \multicolumn{1}{c|}{8.29}        & \multicolumn{1}{c|}{10.96}                        & \multicolumn{1}{c|}{8.59}       & 9.89        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{35.48}                         & \multicolumn{1}{c|}{38.34}                            & 37.34                        & \multicolumn{1}{c|}{35.96}      & \multicolumn{1}{c|}{37.57}       & \multicolumn{1}{c|}{39.59}                        & \multicolumn{1}{c|}{36.34}      & 38.15       \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Branch miss}}        & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.05}                          & \multicolumn{1}{c|}{0.05}                             & 0.05                         & \multicolumn{1}{c|}{0.05}       & \multicolumn{1}{c|}{0.33}        & \multicolumn{1}{c|}{0.05}                         & \multicolumn{1}{c|}{0.05}       & 0.05        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{0.09}                          & \multicolumn{1}{c|}{0.09}                             & 0.09                         & \multicolumn{1}{c|}{0.12}       & \multicolumn{1}{c|}{0.65}        & \multicolumn{1}{c|}{0.10}                         & \multicolumn{1}{c|}{0.09}       & 0.09        \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Instruction \\ number\end{tabular}}} & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{8.27}                          & \multicolumn{1}{c|}{9.28}                             & 10.09                        & \multicolumn{1}{c|}{21.36}      & \multicolumn{1}{c|}{52.67}       & \multicolumn{1}{c|}{9.82}                         & \multicolumn{1}{c|}{10.05}      & 14.43       \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{44.25}                         & \multicolumn{1}{c|}{46.11}                            & 51.22                        & \multicolumn{1}{c|}{90.50}      & \multicolumn{1}{c|}{149.93}      & \multicolumn{1}{c|}{47.36}                        & \multicolumn{1}{c|}{69.83}      & 77.49       \\ \hline
\multicolumn{1}{|c|}{\textbf{TC}}                         &                                                        &                                                    &                                                       &                              &                                 &                                  &                                                   &                                 &             \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{L1 miss}}            & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.07}                          & \multicolumn{1}{c|}{0.14}                             & /                            & \multicolumn{1}{c|}{0.19}       & \multicolumn{1}{c|}{0.70}        & \multicolumn{1}{c|}{0.23}                         & \multicolumn{1}{c|}{0.16}       & 0.20        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{2.35}                          & \multicolumn{1}{c|}{3.00}                             & /                            & \multicolumn{1}{c|}{24.44}      & \multicolumn{1}{c|}{19.93}       & \multicolumn{1}{c|}{7.78}                         & \multicolumn{1}{c|}{8.52}       & 8.61        \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{L2 miss}}            & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.93}                          & \multicolumn{1}{c|}{1.01}                             & /                            & \multicolumn{1}{c|}{1.28}       & \multicolumn{1}{c|}{1.86}        & \multicolumn{1}{c|}{1.37}                         & \multicolumn{1}{c|}{1.15}       & 1.27        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{53.86}                         & \multicolumn{1}{c|}{56.33}                            & /                            & \multicolumn{1}{c|}{93.33}      & \multicolumn{1}{c|}{100.53}      & \multicolumn{1}{c|}{109.50}                       & \multicolumn{1}{c|}{111.48}     & 112.92      \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{LLC miss}}           & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.65}                          & \multicolumn{1}{c|}{0.74}                             & /                            & \multicolumn{1}{c|}{0.83}       & \multicolumn{1}{c|}{1.18}        & \multicolumn{1}{c|}{1.11}                         & \multicolumn{1}{c|}{0.76}       & 1.00        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{31.63}                         & \multicolumn{1}{c|}{31.96}                            & /                            & \multicolumn{1}{c|}{62.87}      & \multicolumn{1}{c|}{66.15}       & \multicolumn{1}{c|}{68.99}                        & \multicolumn{1}{c|}{69.19}      & 71.77       \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{DTLB miss}}          & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{5.76}                          & \multicolumn{1}{c|}{10.67}                            & /                            & \multicolumn{1}{c|}{13.70}      & \multicolumn{1}{c|}{23.67}       & \multicolumn{1}{c|}{14.42}                        & \multicolumn{1}{c|}{12.45}      & 13.60       \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{97.34}                         & \multicolumn{1}{c|}{137.09}                           & /                            & \multicolumn{1}{c|}{336.05}     & \multicolumn{1}{c|}{441.16}      & \multicolumn{1}{c|}{211.64}                       & \multicolumn{1}{c|}{380.34}     & 237.88      \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{Branch miss}}        & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{0.85}                          & \multicolumn{1}{c|}{0.85}                             & /                            & \multicolumn{1}{c|}{0.84}       & \multicolumn{1}{c|}{1.27}        & \multicolumn{1}{c|}{0.82}                         & \multicolumn{1}{c|}{0.80}       & 0.79        \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{67.98}                         & \multicolumn{1}{c|}{63.01}                            & /                            & \multicolumn{1}{c|}{64.59}      & \multicolumn{1}{c|}{64.73}       & \multicolumn{1}{c|}{65.75}                        & \multicolumn{1}{c|}{63.33}      & 61.34       \\ \hline
\multicolumn{1}{|c|}{\multirow{2}{*}{\begin{tabular}[c]{@{}c@{}}Instruction \\ number\end{tabular}}} & \multicolumn{1}{c|}{\emph{lj}}            & \multicolumn{1}{c|}{31.44}                         & \multicolumn{1}{c|}{31.93}                            & /                            & \multicolumn{1}{c|}{60.00}      & \multicolumn{1}{c|}{75.00}       & \multicolumn{1}{c|}{32.62}                        & \multicolumn{1}{c|}{44.27}      & 56.05       \\ \cline{2-10} 
\multicolumn{1}{|c|}{}                                    & \multicolumn{1}{c|}{\emph{g5}}            & \multicolumn{1}{c|}{6929}                          & \multicolumn{1}{c|}{6932}                             & /                            & \multicolumn{1}{c|}{10778}      & \multicolumn{1}{c|}{10900}       & \multicolumn{1}{c|}{6976}                         & \multicolumn{1}{c|}{12020}      & 12075       \\ \hline
\end{tabular}

% }
\label{tab:hardware pagerank}
\end{table}


\sun{Table \ref{tab:hardware pagerank} presents hardware metrics for PR and TC, including cache misses (L1, L2, LLC, and DTLB), branch mispredictions, and number of instructions. Although segmented neighbor indexes generally share the same big-O time complexity as continuous indexes, they result in higher cache miss rates (L1, L2, LLC), more branch mispredictions, and increased instruction counts, especially with the larger dataset \emph{g5}. Additionally, while both CSR and AdjLst store neighbor sets as continuous arrays, CSR exhibits lower cache miss rates due to its compact memory format. For page rank queries, adaptive indexing mechanisms reduce LLC misses by 57.1\% and 31.1\% on dataset \emph{lj} and \emph{g5}, respectively, while flatten optimizations lower LLC cache misses by  30.2\% and 17.0\%. For triangle counting queries, flatten optimizations lower LLC cache misses by 31.3\% and 49.2\% along with a decrease in DTLB misses by 42.1\% and 23.8\%, contributing to the performance improvements.}



\subsubsection{Summary of Findings} \textbf{Q1. How effective are existing techniques in graph containers?} The vertex index significantly influences operations on small neighbor sets, as well as search and insert efficiency. This aspect has been overlooked in some previous works, leading to biased conclusions about the efficiency of neighbor indexes. The dynamic array performs best, being orders of magnitude faster than its counterparts. We confirm that segmented strategies can significantly accelerate insert operations on large neighbor sets, while also providing considerable scan efficiency. Both search and scan benefit from large blocks, but there is an optimal block size ($|B| = 256$) for insert efficiency in our experiments. CoW is generally slower than in-place updates. Moreover, we reveal that memory layout and vectorization significantly impact scan and search performance.


For additional optimizations, adaptive indexing can improve performance on real-world graphs because most vertices have a small degree. Second, the bloom filter offers limited help for \textsc{SearchEdge} due to two reasons: 1) we still need to locate the neighbor if it exists, and 2) the bloom filter has a high false positive rate on large neighbor sets. Third, flattening optimization can enhance long-running query performance, but it is challenging to automatically determine when to apply this optimization for a given query.

\vspace{2pt}
\noindent\textbf{Q2. Which neighbor index performs the best, and what is the gap between it and CSR on read queries?} The simple sorted dynamic array performs best for search, insert, and scan operations on small neighbor sets ($|N(u)| \leqslant 256$). The neighbor indexes of Teseo and Aspen perform much better than Sortledton, and LiveGraph significantly outperforms it on scan efficiency. Sortledton's results are biased due to two factors: 1) using adaptive indexing improves overall performance, and 2) G2PL significantly simplifies concurrency control. Teseo performs the best for both read and write operations on large neighbor sets. Nevertheless, there is still a significant gap between Teseo and CSR on graph analytic queries.

\subsection{Evaluation of Graph Concurrency Control} \label{sec:evaluation_gcc}

We evaluate graph concurrency control (GCC) from three perspectives: overhead, scalability, and concurrency. All competing methods enable full-fledged GCC. Specifically, AdjLst, LiveGraph, Teseo, and Sortledton use the fine-grained concurrency control strategy with G2PL, while Aspen uses the coarse-grained strategy with CoW. For brevity, we refer to the two strategies as G2PL and CoW.

\subsubsection{Overhead Incurred By GCC}

Figure \ref{fig:overhead_of_cc} presents the experimental results. As discussed in Section \ref{sec:discussion}, G2PL causes a 2.0-5.7x slowdown in scan operations, while Aspenâ€™s performance remains unaffected. The slowdown on \emph{g5} is greater than on \emph{lj} because \emph{g5}â€™s vertices have a larger degree, making the cost of looping over neighbor sets dominate scan operations. We also compare the performance of graph operations with and without locking and find that the overhead of locking is negligible. Therefore, the slowdown is primarily caused by the fine-grained version information. In contrast, CoW incurs no additional overhead, as it employs a single-writer mechanism. As a result, the performance gap between Aspen and these fine-grained methods significantly reduces.



\begin{figure}[t]
	\setlength{\abovecaptionskip}{0pt}
	\setlength{\belowcaptionskip}{0pt}
		\captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
	\centering
    \includegraphics[width=0.70\textwidth]
    {img/exp_figs/figure6/legend_bar.pdf}
    \\
    \begin{subfigure}[t]{0.25\textwidth}
    		\centering
    		\includegraphics[width=\textwidth]{img/exp_figs/figure6/get_edge_compare.pdf}
    		\caption{\textsc{SearchEdge}}
    		\label{fig:slowdown_scan}
    \end{subfigure}
    \begin{subfigure}[t]{0.25\textwidth}
    		\centering
    		\includegraphics[width=\textwidth]{img/exp_figs/figure6/insert_compare.pdf}
    		\caption{InsertEdge}
    		\label{fig:slowdown_scan}
    \end{subfigure}
    \begin{subfigure}[t]{0.25\textwidth}
    		\centering
    		\includegraphics[width=\textwidth]{img/exp_figs/figure6/scan_neighbor_compare.pdf}
    		\caption{ScanNbr}
    		\label{fig:slowdown_scan}
    \end{subfigure}
     
    \caption{Unshadowed denotes throughput without GCC, and shadowed denotes throughput with GCC.}
    \label{fig:overhead_of_cc}
\end{figure}
\begin{figure}[h]
	\setlength{\abovecaptionskip}{0pt}
	\setlength{\belowcaptionskip}{0pt}
    \captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
	\centering
    \includegraphics[width=0.60\textwidth]{img/exp_figs/figure6/legend_line.pdf}\\
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure6/scan_neighbor_versions.pdf}
        \caption{Slowdown of \textsc{ScanNbr}.}
        \label{fig:cc_efficiency_scan}
    \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure6/get_edge_versions.pdf}
        \caption{Slowdown of \textsc{SearchEdge}.}
        \label{fig:cc_efficiency_search}
    \end{subfigure} 
    \caption{Impact of varying the percentage of neighbors with more than one versions.}
    \label{fig:overhead_of_cc_varying_versions}
\end{figure}

\subsubsection{Scalability Evaluation} \label{sec:scalability_evaluation}

An element can have multiple versions stored as a version chain or continuous. We examine the impact of multiple versions on search and scan efficiency as follows: given $N(u)$, we randomly pick $x\%$ of vertices $v\in N(u)$ and set three different versions. We vary the ratio from 2\% to 32\%. Figure \ref{fig:overhead_of_cc_varying_versions} presents the results. The scan efficiency of methods using G2PL drops dramatically. The negative impact on AdjLst, Teseo, and Sortledton is greater than on LiveGraph due to the overhead of traversing the list and checking each elementâ€™s version. In Figure \ref{fig:cc_efficiency_search}, LiveGraphâ€™s search efficiency drops significantly because it has to scan all versions to find the target, whereas AdjLst, Teseo, and Sortledton generally degrades by less than 10\%. In contrast, multiple versions do not affect Aspen since it maintains versions in coarse granularity. The trend in insert efficiency mirrors that of search, so we omit the results for \textsc{InsEdge}.


We next evaluate the scalability of competing methods as the number of threads increases to 32, matching the number of physical cores in the testbed. Figure \ref{fig:scalability} presents the scalability results, and Table \ref{tab:performance_under_32_threads} shows the throughput with 32 threads. First, for search and scan efficiency on \emph{lj}, competing methods achieve 22.6-29.7x and 22.3-26.7x speedup, respectively. They fail to scale linearly because \emph{lj} is very sparse, and the irregular data accesses by many threads result in cache contention issues. As in the graph container evaluation, AdjLst significantly outperforms its counterparts on \emph{lj}, as shown in Table \ref{tab:performance_under_32_threads}.

\begin{figure}[h]
    \setlength{\abovecaptionskip}{0pt}
    \setlength{\belowcaptionskip}{0pt}
    \captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
    \centering
    \includegraphics[width=0.60\textwidth]{img/exp_figs/figure6/legend_line.pdf}\\
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure7/liveJournal_get_edge_based_on_degree.pdf}
        \caption{Search operations on \emph{lj}.}
        \label{fig:scalability_search_on_lj}
    \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure7/liveJournal_scan_neighbor_based_on_degree.pdf}
        \caption{Scan operations on \emph{lj}.}
        \label{fig:scalability_scan_on_lj}
    \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure8/liveJournal_insert_based_on_degree_normalized.pdf}
        \caption{Insert operations on \emph{lj}.}
        \label{fig:scalability_insert_on_lj}
     \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure7/graph500_get_edge_based_on_degree.pdf}
        \caption{Search operations on \emph{g5}.}
        \label{fig:scalability_search_on_g5}
    \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure7/graph500_scan_neighbor_based_on_degree.pdf}
        \caption{Scan operations on \emph{g5}.}
        \label{fig:scalability_scan_on_g5}
    \end{subfigure}
     \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure8/graph500_insert_based_on_degree_normalized.pdf}
        \caption{Insert operations on \emph{g5}.}
        \label{fig:scalability_insert_on_g5}
    \end{subfigure}
    
	\caption{Scalability with the number of threads varying.}
	\label{fig:scalability}
\end{figure}

\begin{table}[t]
\captionsetup{skip=0pt}
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
    \caption{Throughput comparison of competing methods using 32 threads (million edges per second).}
    \label{tab:performance_under_32_threads}
    \centering
    % Please add the following required packages to your document preamble:
% \usepackage{graphicx}

% \resizebox{\columnwidth}{!}{%
\small
\begin{tabular}{|c|ccc|ccc|}
\hline
\textbf{Datasets}   & \multicolumn{3}{c|}{\textbf{\emph{lj}}}                               & \multicolumn{3}{c|}{\textbf{\emph{g5}}}                                        \\ \hline
Operations & \multicolumn{1}{c|}{search} & \multicolumn{1}{c|}{scan}    & insert & \multicolumn{1}{c|}{search} & \multicolumn{1}{c|}{scan}             & insert \\ \hline
AdjLst &
  \multicolumn{1}{c|}{\textbf{64.35}} &
  \multicolumn{1}{c|}{\textbf{3268.96}} &
  2.43 &
  \multicolumn{1}{c|}{\textbf{33.83}} &
  \multicolumn{1}{c|}{3955.47} &
  0.26 \\ \hline
LiveGraph  & \multicolumn{1}{c|}{19.49}  & \multicolumn{1}{c|}{1808.15} & 3.02   & \multicolumn{1}{c|}{0.55}   & \multicolumn{1}{c|}{2540.43}          & 1.24   \\ \hline
Aspen      & \multicolumn{1}{c|}{24.17}  & \multicolumn{1}{c|}{1669.10} & 0.20   & \multicolumn{1}{c|}{8.37}   & \multicolumn{1}{c|}{\textbf{4389.51}} & 0.32   \\ \hline
Teseo      & \multicolumn{1}{c|}{48.89}  & \multicolumn{1}{c|}{2822.68} & 3.40   & \multicolumn{1}{c|}{26.37}  & \multicolumn{1}{c|}{3021.91}          & 3.17   \\ \hline
Sortledton &
  \multicolumn{1}{c|}{40.20} &
  \multicolumn{1}{c|}{2335.66} &
  \textbf{3.45} &
  \multicolumn{1}{c|}{14.68} &
  \multicolumn{1}{c|}{2570.57} &
  \textbf{3.23} \\ \hline
\end{tabular}%
% }
\end{table}



For search and scan efficiency on \emph{g5}, competing methods achieve 12.5-29.8x and 12.5-26.7x speedup, respectively. Specifically, LiveGraph and Aspen only achieve 12.5x and 14.7x speedup on search operations because \emph{g5} is large, and the AVL tree and bloom filter lead to severe cache contention issues. Interestingly, the speedup of AdjLst and Teseo is limited on scan but they achieve good throughput. \sun{To address this issue, we examine memory bandwidth utilization in Table \ref{tab:memory bandwidth}. At 8 threads, AdjLst and Teseo consume most of the available memory bandwidth, limiting further speedup even as more threads are added.} Notably, while AdjLst runs much faster than Aspen in the graph container evaluation, it is slower in Table \ref{tab:performance_under_32_threads} because AdjLst reads much more data due to fine-grained version management. \sun{As shown in Table \ref{tab:memory bandwidth}, Aspen uses less bandwidth than competing methods because it avoids reading timestamps for each edge.} Second, in Figures \ref{fig:scalability_insert_on_lj} and \ref{fig:scalability_insert_on_g5}, insert scalability is very limited because write queries require exclusive locks, and high-degree vertices frequently accessed amplify the lock contention issue.  Aspen is slower than Teseo and Sortledton because it has a single writer.

\begin{table}[h!]
\caption{\sun{Memory bandwidth utilization during concurrent scans for competing methods (max bandwidth: 60 GB/sec).}}
% \Huge 
% \resizebox{\columnwidth}{!}{%
\small
\begin{tabular}{|c|ccccc|ccccc|}
\hline
\multicolumn{1}{|l|}{\multirow{2}{*}{\textbf{\begin{tabular}[c]{@{}l@{}}Num of\\ threads\end{tabular}}}} &
  \multicolumn{5}{c|}{\textbf{\emph{lj}}} &
  \multicolumn{5}{c|}{\textbf{\emph{g5}}} \\ \cline{2-11} 
\multicolumn{1}{|l|}{} &
  \multicolumn{1}{c|}{\textbf{AdjLst}} &
  \multicolumn{1}{c|}{\textbf{Lg}} &
  \multicolumn{1}{c|}{\textbf{Ap}} &
  \multicolumn{1}{c|}{\textbf{Ts}} &
  \textbf{Sl} &
  \multicolumn{1}{c|}{\textbf{AdjLst}} &
  \multicolumn{1}{c|}{\textbf{Lg}} &
  \multicolumn{1}{c|}{\textbf{Ap}} &
  \multicolumn{1}{c|}{\textbf{Ts}} &
  \textbf{Sl} \\ \hline
1 &
  \multicolumn{1}{c|}{3.66} &
  \multicolumn{1}{c|}{3.14} &
  \multicolumn{1}{c|}{1.35} &
  \multicolumn{1}{c|}{3.70} &
  2.80 &
  \multicolumn{1}{c|}{9.54} &
  \multicolumn{1}{c|}{8.07} &
  \multicolumn{1}{c|}{2.11} &
  \multicolumn{1}{c|}{10.19} &
  6.01 \\ \hline
2 &
  \multicolumn{1}{c|}{6.69} &
  \multicolumn{1}{c|}{5.97} &
  \multicolumn{1}{c|}{2.10} &
  \multicolumn{1}{c|}{6.87} &
  5.68 &
  \multicolumn{1}{c|}{18.37} &
  \multicolumn{1}{c|}{6.78} &
  \multicolumn{1}{c|}{5.35} &
  \multicolumn{1}{c|}{19.79} &
  12.54 \\ \hline
4 &
  \multicolumn{1}{c|}{11.59} &
  \multicolumn{1}{c|}{10.77} &
  \multicolumn{1}{c|}{4.50} &
  \multicolumn{1}{c|}{12.18} &
  10.39 &
  \multicolumn{1}{c|}{36.15} &
  \multicolumn{1}{c|}{29.05} &
  \multicolumn{1}{c|}{10.14} &
  \multicolumn{1}{c|}{36.49} &
  23.82 \\ \hline
8 &
  \multicolumn{1}{c|}{18.10} &
  \multicolumn{1}{c|}{17.44} &
  \multicolumn{1}{c|}{8.10} &
  \multicolumn{1}{c|}{19.34} &
  17.08 &
  \multicolumn{1}{c|}{51.03} &
  \multicolumn{1}{c|}{46.62} &
  \multicolumn{1}{c|}{19.63} &
  \multicolumn{1}{c|}{54.41} &
  41.07 \\ \hline
16 &
  \multicolumn{1}{c|}{23.96} &
  \multicolumn{1}{c|}{24.12} &
  \multicolumn{1}{c|}{12.68} &
  \multicolumn{1}{c|}{26.12} &
  24.14 &
  \multicolumn{1}{c|}{56.00} &
  \multicolumn{1}{c|}{54.51} &
  \multicolumn{1}{c|}{35.70} &
  \multicolumn{1}{c|}{57.33} &
  53.63 \\ \hline
32 &
  \multicolumn{1}{c|}{25.78} &
  \multicolumn{1}{c|}{26.61} &
  \multicolumn{1}{c|}{17.70} &
  \multicolumn{1}{c|}{28.76} &
  26.65 &
  \multicolumn{1}{c|}{57.76} &
  \multicolumn{1}{c|}{56.69} &
  \multicolumn{1}{c|}{49.07} &
  \multicolumn{1}{c|}{57.81} &
  55.62 \\ \hline
\end{tabular}%
% }
\label{tab:memory bandwidth}
\end{table}


\begin{figure}[h]
    \setlength{\abovecaptionskip}{0pt}
    \setlength{\belowcaptionskip}{0pt}
    \captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
    \centering
    \includegraphics[width=0.60\textwidth]{img/exp_figs/figure11/legend.pdf}\\
    \begin{subfigure}[t]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure11/insert_liveJournal.pdf}
        \caption{Insert latency on \emph{lj}.}
        \label{fig:insert_latency_lj}
    \end{subfigure}
    \begin{subfigure}[t]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure11/insert_graph500.pdf}
        \caption{Insert latency on \emph{g5}.}
        \label{fig:insert_latency_g5}
    \end{subfigure}
    \caption{Insert latency for every 100 operations during the edge insertion process.}
    \label{fig:insert_latency_edge_insertion}
\end{figure}


We further compare performance variations during the insertion process. Figure \ref{fig:insert_latency_edge_insertion} shows the insert latency along the edge insertion process. Since \emph{lj} is sparse, AdjLst and LiveGraph generally outperform segmented methods, while they are slower on \emph{g5}, a dense graph. Aspenâ€™s latency fluctuation is much smaller than that of other methods because 1) it uses a single writer and has no lock contention, and 2) the overhead of CoW on blocks is steady. The higher fluctuation in other methods is due to the expensive overhead of copying blocks and inserting into the skip list.


\subsubsection{Concurrency Evaluation} 

We evaluate the concurrency of competing methods by mixing readers and writers with their total count equal to 32, the number of cores. Each writer executes an insertion stream, whereas a reader runs a PR query. Figure \ref{fig:concurrency_write} presents the experiment results on write efficiency. The dashed line denotes write efficiency without readers executing, while the solid line represents write efficiency with readers. Introducing readers significantly degrades the performance of methods using G2PL due to vertex access contention. With 31 readers and 1 writer, the throughput is only 31.75-46.58\% of that without any readers. In contrast, Aspenâ€™s throughput is only slightly affected by readers because they access the graph snapshot without locking data.

\begin{figure}[h!]
    \setlength{\abovecaptionskip}{0pt}
    \setlength{\belowcaptionskip}{0pt}
    \captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
    \centering
    \includegraphics[width=0.60\textwidth]{img/exp_figs/figure6/legend_line.pdf}\\
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure9/liveJournal.pdf}
        \caption{Insert operations on \emph{lj}.}
        \label{fig:concurrency_insert_lj}
    \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure9/graph500.pdf}
        \caption{Insert operations on \emph{g5}.}
        \label{fig:concurrency_insert_g5}
    \end{subfigure}
    \caption{Write efficiency when mixing readers and writers.}
    \label{fig:concurrency_write}
\end{figure}


\begin{figure}[h!]
    \setlength{\abovecaptionskip}{0pt}
    \setlength{\belowcaptionskip}{0pt}
    \captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
    \centering
     \includegraphics[width=0.60\textwidth]{img/exp_figs/figure9/legend.pdf}\\
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure9/scatter_liveJournal_neo.pdf}
        \caption{PR on \emph{lj}.}
        \label{fig:concurrency_pr_lj}
    \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/figure9/scatter_graph500_neo.pdf}
        \caption{PR on \emph{g5}.}
        \label{fig:concurrency_pr_g5}
    \end{subfigure}
   
    \caption{Read efficiency when mixing readers and writers.}
    \label{fig:concurrency_pr}
\end{figure}


Figure \ref{fig:concurrency_pr} presents the experiment results on read efficiency with varying numbers of writers. Each dot represents the average time for a reader to perform one iteration of PR. Methods using G2PL show significant performance decreases as the number of writers increases due to lock contention. Methods with poor insert efficiency (e.g., LiveGraph and AdjLst) are more affected than Teseo and Sortledton because they must hold exclusive locks for longer periods. The performance variance among different readers increases. In contrast, Aspen maintains steady performance. Specifically, Aspen performs worse than its counterparts when there are no writers but outperforms them when there are multiple writers.

% \vspace{-10pt}
\subsubsection{Summary of Findings} \textbf{Q3. What is the impact of graph concurrency control on graph operations?} For fine-grained methods, maintaining and checking versions for each element incurs significant overhead due to the need to load more data and perform extra computations. Traversing the version list can cause more overhead for scans, while continuous version storage can be costlier for searches. In contrast, the coarse-grained method (i.e., Aspen) avoids these issues, resulting in a smaller performance gap.



\vspace{2pt}
\noindent\textbf{Q4. How is the scalability and concurrency of competing methods?} Overall, all competing methods generally exhibit good scalability in search and scan. Search scalability can be affected by cache contention, while scan scalability can be limited by memory bandwidth. Aspen can outperform the fine-grained methods despite its less efficient graph container. However, existing works overlook the problem of hardware utilization. In contrast, insert operations have very limited scalability due to heavy lock contention from frequent access to high-degree vertices.


Despite using MVCC, in practice, readers and writers of fine-grained methods interfere significantly on graphs because high-degree vertices are frequently accessed. While Aspenâ€™s read performance can outperform its counterparts, it suffers from slow insert speeds due to its inefficient CoW strategy. In a word, both fine-grained and coarse-grained methods face severe performance issues in a multi-threaded context.

\begin{figure}[t]
    \setlength{\abovecaptionskip}{0pt}
    \setlength{\belowcaptionskip}{0pt}
    \captionsetup[subfigure]{aboveskip=0pt,belowskip=0pt}
    \centering
    \includegraphics[width=0.60\textwidth]{img/exp_figs/batch/legend.pdf}\\
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/batch/liveJournal_batch_performance_low.pdf}
        \caption{Batch update on \emph{lj}.}
        \label{fig:batch_update_on_lj}
    \end{subfigure}
    \begin{subfigure}[t]{0.30\textwidth}
        \centering
        \includegraphics[width=\textwidth]{img/exp_figs/batch/graph500_batch_performance_low.pdf}
        \caption{Batch update on \emph{g5}.}
        \label{figbatch_update_on_g5}
    \end{subfigure}
    
	\caption{\sun{Write efficiency with batch size increasing.}}
	\label{fig:batch_update_throughput}
\end{figure}

\subsection{\sun{Evaluation of Update Granularity}}



\sun{In the above experiments, each write query consisted of a single update. We now evaluate how batch size affects performance. Since our test system has 32 CPU cores, Aspen uses a single writer and 32 threads to process one batch in parallel, while the other methods use 32 writers, each independently processing its own batch.}



\sun{As shown in Figure \ref{fig:batch_update_throughput}, Aspen outperforms the other methods when the batch size exceeds $2^{8}$, with throughput steadily increasing as the batch size grows from $2^{0}$ to $2^{10}$. This is because Aspen avoids lock contention with a single writer, creates one snapshot for multiple updates, and leverages parallelism across update operations. In contrast, methods using G2PL exhibit a significant performance drop as batch size increases, especially beyond $2^8$, due to the need to hold more locks per query and the longer execution time required to process larger batches, which increases lock contention.}


\noindent\textbf{\sun{Q5. How does the batch granularity affect the performance of competing methods?}} \sun{Coarse-grained methods perform poorly with small batch sizes since parallelism within a write query is limited, and a snapshot must be created for each update. However, their performance improves significantly as batch size increases. In contrast, fine-grained methods excel with small batch sizes but face severe performance degradation due to lock contention among queries as the batch size grows.}

\subsection{Evaluation of Memory Consumption}

We evaluate the memory consumption of competing methods by measuring the \emph{resident set size} as reported by the OS. Table \ref{tab:memory_consumption} presents the results. \emph{wo} and \emph{w} denote the storage without and with version information, respectively. Aspen uses coarse-grained version management, resulting in negligible memory consumption differences (less than 10MB) between \emph{wo} and \emph{w}. Therefore, we report its \emph{w} implementation for reference.

\vspace{2pt}
\noindent\textbf{Q6. What is the impact of graph containers and version management in DGS on memory consumption, and what is the gap between DGS and CSR?} Overall, Aspen consumes 3.3-11.0x times more memory than CSR. Among the fine-grained methods, the most optimal consumes 0.9-1.3x and 4.1-8.9x times more memory than Aspen and CSR, respectively. This is primarily because: 1) they maintain version information for each element, and 2) they leave empty slots in neighbor indexes. These results indicate that fine-grained methods can cause severe memory issues, limiting the scalability of DGS on large graphs.






\small
\begin{table}[htbp]
\captionsetup{skip=0pt}
\setlength{\abovecaptionskip}{0pt}
\setlength{\belowcaptionskip}{0pt}
    \caption{Memory consumption of competing methods (GB).}
    \label{tab:memory_consumption}
% \resizebox{\columnwidth}{!}{
    \begin{tabular}{|c|c|c|cc|cc|cc|cc|}
\hline
\multirow{2}{*}{\textbf{Dataset}} &
  \multirow{2}{*}{\textbf{CSR}} &
  \multirow{2}{*}{\textbf{Aspen}} &
  \multicolumn{2}{c|}{\textbf{AdjLst}} &
  \multicolumn{2}{c|}{\textbf{LiveGraph}} &
  \multicolumn{2}{c|}{\textbf{Teseo}} &
  \multicolumn{2}{c|}{\textbf{Sortledton}} \\ \cline{4-11} 
          &      &       & \multicolumn{1}{c|}{wo}   & w     & \multicolumn{1}{c|}{wo}   & w     & \multicolumn{1}{c|}{wo}    & w     & \multicolumn{1}{c|}{wo}    & w     \\ \hline
\emph{lj}   & 0.67 & 3.58  & \multicolumn{1}{c|}{0.98} & 2.74  & \multicolumn{1}{c|}{1.66} & 6.24  & \multicolumn{1}{c|}{9.67}  & 30.98 & \multicolumn{1}{c|}{2.62}  & 4.31  \\ \hline
\emph{dl}   & 0.76 & 2.52  & \multicolumn{1}{c|}{0.99} & 2.89  & \multicolumn{1}{c|}{1.21} & 3.71  & \multicolumn{1}{c|}{1.33}  & 6.87  & \multicolumn{1}{c|}{3.00}  & 3.11  \\ \hline
\emph{ldbc}   & 2.84 & 17.96 & \multicolumn{1}{c|}{3.99} & 10.52 & \multicolumn{1}{c|}{7.61} & 28.95 & \multicolumn{1}{c|}{61.16} & OOM   & \multicolumn{1}{c|}{15.30} & 20.19 \\ \hline
\emph{g5} & 3.95 & 15.33 & \multicolumn{1}{c|}{5.42} & 15.41 & \multicolumn{1}{c|}{7.17} & 24.62 & \multicolumn{1}{c|}{21.57} & 78.42 & \multicolumn{1}{c|}{15.25} & 19.55 \\ \hline
\emph{wk}   & 0.98 & 8.18  & \multicolumn{1}{c|}{1.41} & 3.49  & \multicolumn{1}{c|}{3.49} & 13.09 & \multicolumn{1}{c|}{28.11} & 86.08 & \multicolumn{1}{c|}{5.38}  & 7.12  \\ \hline
\emph{ct}   & 0.27 & 2.06  & \multicolumn{1}{c|}{0.42} & 1.11  & \multicolumn{1}{c|}{0.84} & 3.32  & \multicolumn{1}{c|}{7.42}  & 22.81 & \multicolumn{1}{c|}{1.11}  & 2.14  \\ \hline
\emph{tw}   & 4.11 & 20.20 & \multicolumn{1}{c|}{5.49} & 15.09 & \multicolumn{1}{c|}{9.02} & 31.98 & \multicolumn{1}{c|}{45.89} & OOM   & \multicolumn{1}{c|}{17.48} & 22.04 \\ \hline
\emph{nft}  & 1.38 & 14.94 & \multicolumn{1}{c|}{2.06} & 4.99  & \multicolumn{1}{c|}{5.93} & 23.01 & \multicolumn{1}{c|}{58.76} & OOM   & \multicolumn{1}{c|}{9.07}  & 12.27 \\ \hline
\end{tabular}%
    % }
\end{table}
