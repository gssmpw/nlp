%\newcommand{\findAlpha}{\texttt{Find}\_\beta}
%\newcommand{\findAlphaMin}{\texttt{Find}\_\ssMinFB}
%\newcommand{\findAlphaMax}{\texttt{Find}\_\ssMaxFB}
%\newcommand{\findAlphaMinR}{\texttt{Find}\_\ssMinRB}
%\newcommand{\findAlphaMaxR}{\texttt{Find}\_\ssMaxRB}

\section{Overwhelming Under Permutation Invariance}
\label{sec:perm_invar}
In \cref{sec:meta_framework}, we provided a concrete algorithm that decides overwhelming for a fixed context size $\nctx$.
In this section, we provide a more refined algorithm which can provide a tighter bound on the worst-case deviation in the restricted setting where the free tokens are allowed to be any permutation of a fixed string.
Up until this point, we have been ``lifting'' the domain of $\InpSpace$ into $\InpSpace \times \blowupSet \shiftSet$ to prove worst-case deviation bounds: i.e.\ we have been separating out the effect of layer normalization when proving a fixed string to be overwhelming.

In this section, we nullify the effect of layer normalization by defining an equivalence relation on $\InpSpace$ where the blowup and shift sets are the same for all elements in the equivalence class.
Then, we can derive a simpler upper-bound on the worst-case deviation of the model over the equivalence class as we can treat the layer normalization as a constant factor!

\begin{definition}[Permutation Equivalence relation]
	We will define the equivalence relation \(\sim\) on \(\InpSpace\).
	Let $X = (\desSet || X_f || \vecQuery) \in \InpSpace$ where $X$ are the free tokens, $\desSet$ are the fixed tokens, and $\vecQuery$ is the query token.
	Then, we define \(\sim\) such that for $X = (\desSet || X_f || \vecQuery), Y = (\desSet || Y_f || \vecQuery) \in \InpSpace$,
	\[
		X \sim Y \iff X_f = \pi(Y_f)
	\]
	where $\pi$ is a permutation of the free tokens.
	Note that if $X \sim Y$, then $\E[X \cdot \Embed] = \E[Y \cdot \Embed]$ and $\Var[X \cdot \Embed] = \Var[Y \cdot \Embed]$.
    Moreover, let $\freeToks$ be the multi-set of potential free tokens for $[X]$.
    I.e. $\freeToks = \{X_f[1], \dots, X_f[\nfree]\}$.
\end{definition}
% We abuse notation to define $B(X)$ to be the vectors for $X$'s blowup and $S(X)$ to be the vectors for $X$'s shift.

To bound the worst-case deviation over an equivalence class we use a similar algorithm (\cref{alg:overwhelmCheck2}) to \cref{alg:overwhelmCheckDet}.
We still bound the worst-case deviation of attention, but now the blowup and shift sets are singletons, leading to much tighter bounds.
Additionally, since blowup and shift are constant, the worst-case deviations of $f^{\MLP}, f^{\Iden}$ are $0$, and, we can use a linear program to find the extremal softmax contributions for the free tokens.

%\snote{TODO: Write preamble}
%Up until this section, we have been ``lifting'' the domain of individual components of the model to prove worst-case deviation bounds.
%The lifting, done by seperating out the effect of layer normalization, suggests that we should be able to ``factor out'' the effect of layer normalization in the model.
%Then, this equivalence relation partitions \(\InpSpace\) into disjoint equivalence classes, denoted by \([X] = \{Y \in \InpSpace \mid Y \sim X\}\), where each class contains all elements with the same variance and expectation.

\begin{theorem}[Input Restriction and Permutation Invariance] \label{thm:InpResPermInv}
	%The model $\desF{\ModelFinal}$ over domain $[X]$ if 
	If
	\[
		\WD(\desF{\Model}; [X])_\infty < \peakToPeak(\desF{\Model}, X) / 2
	\]
	% where $\blowupSet = \{B(X)\}$ and $\shiftSet = \{S(X)\}$ (i.e.\ blowup and shift are just singelton sets),
	then the output of model $\desF{\Model}$ is fixed for all inputs in $[X]$.
	Moreover, \cref{alg:overwhelmCheck2} produces an upper bound $W$ for $\WD(\desF{\Model}; \InpSpace)_\infty$.
	%\footnote{There is a notion here of ``sample-complexity'' which we will not go into and leave for future work
	%	Specifically, if we treat $X_1, \dots, X_D$ as samples from $\InpSpace$ and take the peak-to-peak difference to be $\max_{i \in [D]} \peakToPeak(\desF{\Model}, X_i) / 2$, then we have a \emph{larger bound} and thus can get away with larger worst-case deviation while still proving domain-collapse.
	%	In theory, the larger $D$ is, the more likely we are to have a larger peak-to-peak difference.
	%}
\end{theorem}
A full proof of \cref{thm:InpResPermInv} is provided in \cref{subsec:proofInpResPermInv}.
% Moreover, we prove the correctness of \cref{alg:overwhelmCheck2} in \cref{sec:appendix_perm}.
%\begin{algorithm}[H] \label{alg:overwhelmCheck2}
%	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
%	\Output{Either the string ``Overwhelmed'' indicating that the output of the model $\Model$ evaluated on $s$ concatenated with $\nfree$ free tokens and query token $q$ is proven to be invariant under a permutation class, OR the string ``Inconclusive'' if no such proof is obtained.} 
%
%	Calculate $
%	B(X) = \frac{\gamma}{\sqrt{\Var[X \cdot E] + \eps}}
%	$
%	and $
%	S(X) = - \E[X \cdot E] B(X) + \beta
%	$
%	Set $B^{\min}, B^{\max} = B$ and $S^{\min}, S^{\max} = S$
%	\\
%	Set $\fenc(\vec{e}) = \vece \cdot E \cdot \diag(B) + S$ and
%	calculate bounds for $\ssMinFA, \ssMaxFA$ using either the naive algorithm in \cref{alg:naiveAlpha} or the linear program in \cref{alg:LPAlpha}.\\
%	Let
%	\[
%		\alpha_{fix} = 
%		\exp\left(
%			\fenc(\vec{e}_q) \cdot Q \Theta_{\nctx, \nctx} K^T \fenc(\vec{e}_{q})
%		\right)    
%		+  \sum_{j \in [\nfix]} \exp\left(
%			\fenc(\vec{e}_q) \cdot Q \Theta_{i, \nctx} K^T \fenc(\vec{e}_{\desSet_j})
%		\right)
%	\]
%	\\
%	Calculate $\ssMaxFB = \frac{\ssMaxFA}{\alpha_{fix} + \ssMaxFA}$ and $\ssMaxFB = \frac{\ssMinFA}{\alpha_{fix} + \ssMinFA}$ \\
%	Set $W^{\fenc} = 0$ to bound the worst-case deviation of $\fenc$ to $0$ \\
%	Let $\ssMaxFB = \frac{\ssMaxFA}{\ssMaxFA + \alpha_{fix}}$,
%	$\ssMinRB = \frac{\alpha_{fix}}{\alpha_{fix} + \ssMinFA}$,
%	and $\ssMinRB = \frac{\alpha_{fix}}{\alpha_{fix} + \ssMaxFA}$
%	\\
%	Calculate \begin{align*}
%		W^{\attn} &= 2 \cdot (\ssMaxRB - \ssMinRB) \cdot \|E[\desSet \cup \{s\}, :] \cdot \diag(B) + S\|_{\frobInf} \\
%			  &+ 2 \cdot \ssMaxFB \norm{(E[\freeToks, :] B + S) \cdot V}_{\frobInf}
%	\end{align*}
%	as in \cref{lem:att_bound} except that we have $\norm{(E[\freeToks, :] B + S) \cdot V}_{\frobInf}$ 
%	instead of $\norm{(E B + S) \cdot V}_{\frobInf}$ \footnote{
%		Recall that $E[\freeToks, :]$ connotes selecting the rows of $E$ corresponding to the tokens in $\freeToks$.
%	}\\
%
%	Calculate $W = \Lip(\Unembed) \cdot W^{\attn} $ 
%	Calculate $\peakToPeak(\desF{\Model}, \InpSpace)$ by evaluating $\desF{\Model}$ on $Y \gets [X]$ \\
%	\If{
%	$W < \peakToPeak(\desF{\Model}, \InpSpace) / 2$ }{\Return ``Overwhelmed''
%}
%\Else{\Return ``Inconclusive''}
%
%\caption{Overwhelming Verifier for Permutation Invariance}
%\end{algorithm} 

\begin{algorithm}[h] 
	\caption{Algorithm for deciding Overwhelming}
	\label{alg:overwhelmCheck2}
	\begin{algorithmic}
		\STATE \textbf{Input:} $\Model, \desSet, \query$
		\STATE \textbf{Output:} Return ``Overwhelemed'' or ``Inconclusive''
		\STATE
		\STATE Set $B = \frac{\gamma}{\sqrt{\Var[X \cdot E] + \eps}}
		$
		\STATE Set $
		S = - \E[X \cdot E] B + \beta
		$
		\STATE Set $\fenc(\vec{e}) = \vece \cdot E \cdot \diag(B) + S$
		\STATE Calculate $\ssMinFA, \ssMaxFA$ using the naive algorithm (\cref{alg:naiveAlpha}) or the linear program (\cref{alg:LPAlpha})
		\STATE Let
		\begin{align*}
			\alpha_{fix} = 
			\exp\left(
				\fenc(\vec{e}_q) \cdot Q \Theta_{\nctx, \nctx} K^T \fenc(\vec{e}_{q})
			\right)    \\
			+  \sum_{j \in [\nfix]} \exp\left(
				\fenc(\vec{e}_q) \cdot Q \Theta_{i, \nctx} K^T \fenc(\vec{e}_{\desSet_j})
			\right)
		\end{align*}
		\STATE Calculate $\ssMaxFB$, $\ssMinRB$, $\ssMinRB$
		 \STATE 
		 Calculate $W^{\attn}$ as in \cref{lem:attn_perm}
		\STATE Calculate $W = \Lip(\Unembed) \cdot W^{\attn} $ 
		% \STATE Sample $Y \gets [X]$ 
		\IF{
		$W <  \peakToPeak(\desF{\Model}, X) / 2$ }
		\STATE Return ``Overwhelmed''
		\ELSE 
		\STATE Return ``Inconclusive''
		\ENDIF
	\end{algorithmic}
\end{algorithm}



\subsection{Bounding Attention}
% Similar to the previous section, we need to bound the worst-case deviation of attention.
% Unlike the previous section though, because the blowup and shift do not vary, we can find \emph{tighter} bounds on attention's worst-case deviation.
To bound the worst-case deviation of attention, we provide two algorithms to bound $\ssMinFA, \ssMaxFA$ as defined in \cref{lem:min_max_softmax}.
The first, in \cref{alg:naiveAlpha}, takes a ``naive'' approach by iterating through the position of the free tokens and finding an extremal value for each position.
The second, in \cref{alg:LPAlpha}, uses a linear program to get a tighter bound.
To see why \cref{alg:LPAlpha} provides a valid bound, consider a similar program except where an \emph{integer} linear program is used.
Then, the integer version of \cref{alg:LPAlpha} finds the permutation of free tokens which maximizes (resp. minimizes) the pre-softmax logits.
Relaxing to a linear program, we have an upper-bound (resp. lower-bound) on the pre-softmax logits.
We can formally state the correctness of \cref{alg:naiveAlpha} and \cref{alg:LPAlpha} in the following lemma:
\begin{lemma}[Correctness of \cref{alg:LPAlpha} and \cref{alg:naiveAlpha}]
	\label{lem:corrAlpha}
	 Both \cref{alg:LPAlpha} and \cref{alg:naiveAlpha} provide valid bounds on $\ssMinFA$ and $\ssMaxFA$.
\end{lemma}
\vspace{-0.2cm}

\begin{algorithm}[tb]
	\caption{
		Linear Program to find $\ssMinFA$.\\
		To find $\ssMaxFA$, switch the $\min$ to a $\max$ in the objective.
	}
	\label{alg:LPAlpha}
	\begin{algorithmic}
	\STATE \textbf{Input:} {$\fenc$ and model $\Model$}
	\STATE
	\STATE Return the optimal value to the following linear program:
	\begin{align*}
		\min \quad & \sum_{j \in (\ndes, \nctx)} \exp\bigg(\sum_{t \in \freeToks} \\
			\fenc(\vecQuery) \cdot &Q \cdot \PosRot_{j, \nctx} K^T \cdot \fenc(\vec{e}_t)^T
	\bigg) \cdot x_{j, t} \\
		\text{subject to} \quad
			   & \forall j, \sum_{t \in \freeToks} x_{j, t} = 1 \\
			   & \forall t, \sum_{j \in (\ndes, \nctx)} x_{j, t} = 1, \\
			   &  \forall j, t, x_{j, t} \geq 0.
	\end{align*}
	\end{algorithmic}
\end{algorithm} 

Then, with the bounds on the softmax contributions, we can state a specialized version of the bound on attention's worst-case deviation for the permutation invariant case.

Then, we can state the following lemma:
\begin{lemma}[Worst-case Deviation of Attention]
	\label{lem:attn_perm}
	Worst-case deviation of attention is bounded as follows for fixed blowup $B$ and shift $S$ when considering the permutation class $[X]$ with free tokens $\freeToks$:
	\begin{align*}
		&\WD(\vecNctx \cdot f^{\attnH}_{\ndes \mid r, q} ; \InpSpace \times \blowupSet \shiftSet)_\infty
	     \\ &\leq
		2 \cdot (\ssMaxRB - \ssMinRB) \cdot \norm{\Embed[[\nfix] \cup \{\nctx\}, :] \cdot B + S}_{\frobInf} \\
		&+ 2 \cdot \ssMaxFB \cdot \norm{(E[(\nfix,\nctx),: ] B + S) \cdot V}_{\frobInf}.
	\end{align*}
\end{lemma}
The proof follows analogously to that of \cref{lem:att_bound} except for two main differences:
(1) we have a further restriction on the free tokens and thus only need to consider $E[(\nfix,\nctx), :]$ instead of $E$
and (2) becuase the blowup and shift are fixed, $\WD(\fenc; \{\vece_t\} \times \blowupSet \shiftSet)_\infty = 0$ and so wecan drop the last term in the original bound.


%%%%%%%%%%%%%%%%%%%%%%

%\begin{algorithm}[H] \label{alg:naiveAlpha}
%	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
%	\Input{$\fenc$ and model $\Model$}
%	% \Output{\lev{TODO}}
%	Let $\fenc(\vec{e}) = \vec{e} \cdot \Embed \cdot \diag(B) + S$ \\
%	\For{$k \in (\ndes, \nctx]$}{
%		Let \begin{equation*}
%			\vec{\ell}^{\min}_k = \frac{1}{\sqrt{\dEmb}} \min_{t \in \freeToks}  \fenc(\vecQuery) \cdot Q \PosRot_{k, \nctx} K^T \cdot \fenc(\vec{e}_t)^T
%		\end{equation*}
%		and 
%		\begin{equation*}
%			\vec{\ell}^{\max}_k = \frac{1}{\sqrt{\dEmb}} \max_{t \in \freeToks}  \fenc(\vecQuery) \cdot Q \PosRot_{k, \nctx} K^T \cdot \fenc(\vec{e}_t)^T
%		\end{equation*}
%		where $\PosRot_{k, \nctx}$ is the matrix representing the effect of RoPE encodings
%	}
%	Return $\ssMinFA = \sum_k \exp\left(\vec{\ell}^{\min}_k\right), \ssMaxFA = \sum_k \exp\left(\vec{\ell}^{\max}_k\right)$
%	\caption{Naive Algorithm to find $\ssMinFA$ and $\ssMaxFA$}
%\end{algorithm} 
%
%\begin{algorithm}[H] \label{alg:LPAlpha}
%	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
%	\Input{$\fenc$ and model $\Model$}
%	% \Output{\lev{TODO}}
%
%	Return the optimal value to the following linear program:
%	\begin{align*}
%		\min \quad & \sum_{j \in (\ndes, \nfree]} \exp\left(\sum_{t \in \freeToks} \fenc(\vecQuery) \cdot Q \cdot \PosRot_{j, \nctx} K^T \cdot \fenc(\vec{e}_t)^T\right) \cdot x_{j, t} \\
%		\text{subject to} \quad
%			   & \forall j, \sum_{t \in \freeToks} x_{j, t} = 1 \\
%			   & \forall t, \sum_{j \in (\ndes, \nfree]} x_{j, t} = 1 \\
%			   & \forall j, t, x_{j, t} \geq 0.
%	\end{align*}
%	\caption{Linear Program to find $\ssMinFA$.
%		To find $\ssMaxFA$, we have the same linear program except that we switch the $\min$ to a $\max$ in the objective. 
%	}
%\end{algorithm} 
%

% \begin{algorithm}[H] \label{alg:freezecheckerLP}
% 	\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
% 	\Input{A fixed transformer model M, a string of tokens $s$ denoting a fixed part of the input to M, and integer $k$ denoting the number of free tokens in the input to M }
% 	\Output{Either the string "Frozen" indicating that the output of the model M evaluated on $s$ concatenated with $k$ free tokens is proven to be invariant under the choice of the free tokens, OR the string "Inconclusive" if no such proof is obtained.} 

% \mnote{Populate this area with the precise pseudocode for the computation of the LP upper bound to $\WD(\desF{\Model}; [X] \times \blowupSet \shiftSet)_\infty$ using the terminology set in the rest of the paper.}



% For each $k \in [\tau]$ define $LP^+_k$ to be the value of the following linear program and let $\vec{\alpha}^k_+$ be the vector minimizing the value of the following linear program:

% \begin{align}
%     &\textbf{ Minimize:} \nonumber \\
%     &&\vec{\alpha} \cdot \grad E(\mathcal{F})  \\
%      &\textbf{Over:} \nonumber \\
%      && \vec{\alpha} \in \mathbb{R}^{\tau} \\
%     &\textbf{Subject To:} \nonumber \\
%     &&\vec{\alpha} \cdot \grad D_{ij}(\mathcal{F}) \geq 0 \text{    } \forall (i,j) \in \text{Saturated}(\mathcal{F}) \\
%     &&\text{ and } \nonumber\\
%     &&\alpha_k \geq \delta   \\
%     && \| \vec{\alpha} \|_{\infty} \leq \epsilon
% \end{align}


% For each $k \in [\tau]$ define $LP^-_k$ to be the value of the following linear program and let $\vec{\alpha}^k_-$ be the vector minimizing the value of the following linear program:
% \begin{align}
%     &\textbf{ Minimize:} \nonumber \\
%     &&\vec{\alpha} \cdot \grad E(\mathcal{F})  \\
%     &\textbf{Over:} \nonumber \\
%      && \vec{\alpha} \in \mathbb{R}^{\tau} \\
%     &\textbf{Subject To:} \nonumber \\
%     &&\vec{\alpha} \cdot \grad D_{ij}(\mathcal{F}) \geq 0 \text{    } \forall (i,j) \in \text{Saturated}(\mathcal{F}) \\
%     &&\text{ and } \nonumber\\
%     &&\alpha_k \leq -\delta   \\
%     && \| \vec{\alpha} \|_{\infty} \leq \epsilon 
% \end{align}



% \If{
% 	$
% 		\WD(\desF{\Model}; [X] \times \blowupSet \shiftSet)_\infty < \peakToPeak(\desF{\Model}, X) / 2
% 	$  \mnote{this needs to be expanded to show the actual if decision we compute, which is an upper bound on the worst case deviation rather than the exact wcd}}{\Return ``Frozen''  }

% \Else{\Return ``Inconclusive''}



% 	\caption{Freeze Verifier - LP Bound  \mnote{Under Construction}}
% \end{algorithm} 


After which the proof of \cref{thm:InpResPermInv} follows analogously to that of \cref{thm:InpRes}.

% \begin{proof}[Proof sketch of \cref{thm:InpResPermInv}]
%     First note that because the blowup and shift are constant for $[X]$, then the worst-case deviation of $\fenc$ is $0$ as the encoding function is fixed to a linear function for the domain $[X]$.
%     Then, noting that \cref{alg:overwhelmCheck2} uses the same framework as \cref{alg:overwhelmCheckDet}, we now need to prove that $\ssMinFA, \ssMaxFA, \ssMinRA, \ssMaxRA$ are valid extremal softmax bounds,
% \end{proof}


% and the algorithm in \cref{alg:overwhelmCheckDet}, we provide a simple proof of the above theorem.


% \lev{TODO: remove this ``proof'' structure and replace with filling in missing pieces}


% \begin{proof}
% 	First note that
% 	\[
% 		\WD(\vecNctx \cdot \desF{f^{\component}}; [X] \times \blowupSet \shiftSet ) = 0
% 	\]
% 	for $\component \in \{\MLP, \Iden\}$ as fixing the query token \emph{and the blowup/ shift} fixes the output of the MLP and identitiy for the last token.

% 	Now, we have to find the extremal softmax contributions for the fixed and free tokens.
% 	For the fixed tokens, because variance and expectation are fixed, we can note that there logits always equal
% 	\[
% 		\vec{\ell}_i = \frac{1}{\sqrt{\nctx}} \fenc(\vecDes) \cdot Q \PosRot_{i, \nctx} K^T \cdot \fenc(\vecQuery)
% 	\]
% 	for $i \in [\ndes]$ where $\PosRot_{i, \nctx}$ is the rotation matrix for RoPE position $i$.

% 	So then, we need to bound $\softSumMinF$ and $\softSumMaxF$.
% 	A naive apporach to computing $\softSumMaxF$ (resp. $\softSumMinF$) is outlined in \cref{fig:find_ell_alg_naive}.
% 	The algorithm simply finds the maximum (resp. minimum) of the pre-softmax logits for the free tokens at each position.
% 	Alternatively, we can formalize finding $\softSumMaxF$ (resp. $\softSumMinF$) as a mixed integer linear program (MILP) as outlined in \cref{fig:find_ell_alg_LP}.
% 	The key idea is that we can think of the class of permutation matrices $X \in \{0, 1\}^{\nfree \times \nfree}$ where $X[j, t] = x_{j, t}$ as being specified by a set of linear-integer constraints.
% 	Then, if we find the $X$ which maximizes (resp. minimizes) the sum of the pre-softmax logits, we can get a bound on the softmax sum.
% 	Of course, integer-linear programming is NP-hard,
% 	so we can relax the constraints to a linear program (LP) and get a bound on the softmax sum.
% 	%Then, we can use the results of \cref{lem:min_max_softmax} to get bounds on the softmax sum.

% 	Next, we can use the bounds on $\ssMaxFB, \ssMinRB, \ssMaxRB$ alongside \cref{lem:min_max_softmax} to get bounds on the worst-case deviation of the model from softmax.  \mnote{I think we should specify precisely how we do this in pseudocode inside Algoriths \ref{alg:overwhelmCheck} and \ref{alg:freezecheckerLP}.}

% 	Finally, we can use the lifted worst-case deviation to get a bound on the worst-case deviation of the model conditioning on a fixed $B$ and $S$.
% \end{proof}

