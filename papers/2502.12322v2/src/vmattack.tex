
% ++++++++++++++++++++++++++++++++
% ++++++++++ Attack  ++++++++
% ++++++++++++++++++++++++++++++++



\section{Virtual Machine Introspection Cheats (VIC)}
\label{sec:vmiCheat}

\frameworkName takes advantage of modern virtualization extensions that allow CPU and GPU virtualization to be used as an enabler to run video games at optimal speed, even within virtual machines. We propose to run the video games inside a virtualized environment and use the hypervisor, and virtual machine introspection (VMI) in particular, to modify the guest machine to achieve the same end-result as a cheat that would be executed within the machine \cite{garfinkel2003virtual}.

\subsection{Threat model}
\label{sec:threatModel}

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.40]{pics/threatModel.pdf}
    \caption{\frameworkName framework threat model.}
    \label{fig:threat-model}
\end{figure}


Our threat model involves three main actors, the cheater, the cheat developer and the game developer (Figure \ref{fig:threat-model}). The cheater is a game user who wants to play a particular game with a selection of cheats enabled. They can own the system where the cheat is running or access it in a similar fashion they would access any other cloud gaming service. The cheat developer is in charge of developing the cheats and enabling them on the game. They have full control over the system that will run the game with the cheats. This could be because the cheater has granted them full access or because they own the system and offer access to it as a service. In particular, we assume the cheat developer can modify the operating system (including running custom kernel versions) and is able to run a malicious hypervisor with introspection enabled which can host a guest VM on that system. In our evaluation, performed in \S\ref{sec:evaluation}, we assume that both the cheater and the cheat developer are the same person. This is, they own the system where the game is running, have full access to it and also want to play the game with cheats enabled. This is not necessarily always the case as we explain in \S\ref{sec:discussion} where the cheat developer can offer, via cloud infrastructure, direct online access to a cheat-enabled cloud gaming system. 
% Game developer

The game developer creates the video game that will be abused by the cheat developer. The game is meant to be played online but has a client that needs to be executed for every player. While most information is stored in the servers, a certain amount of information is needed at the client side for speed and responsiveness. This is consistent with how most current multiplayer online video games are played on personal computers. The game includes an anti-cheat that can have access to both, the user and kernel space of the system where the game is being executed. The video game is security agnostic, thus only relevant information are shared between the client (user's PC) and the server. The server also runs statistical analysis tools to detect cheating behaviours. 



\subsection{Overview}
Cheats communicate with the game process through memory reads (to obtain information that would be useful to the cheater), function hooks (to modify specific behaviours or act on specific game events) and memory writes (to modify states such as firing).

Our proposed methodology translates the above actions and implements the same effects by placing the cheat outside the VM where the game is hosted. Reads/writes to memory take place through VMI and page guards are introduced to monitor specific memory addresses and specific code execution. In contrast to traditional cheats, we have the ability to employ IO device simulation to create mouse and keyboard events which act as a stealthier way to modify game state. 
Mapping the above actions is very important, as all the already implemented cheats on any game can run using our framework with minor modifications on the actions described above. In addition, the cheat will not need to use any anti-cheat bypass or custom driver, something a kernel cheat would need in order to exploit the game thus decreasing the barrier for cheating even in games which employ a number of anti-cheats like Fortnite.


\begin{figure}[H]
    \centering
    \includegraphics[scale=0.8]{pics/VMIMethodology.pdf}
    \caption{Overview of VIC attack pipeline.}
    \label{fig:methodology}
\end{figure}

In this work we use QEMU emulator with introspection enabled via LibVMI \cite{payne2012simplifying}, to demonstrate how the use of introspection can lower the bar for cheat developers and provide them an advantage over other players. Figure \ref{fig:methodology} demonstrates the flow of commands starting from the host on left hand side. The host machine runs the hypervisor and the VMI cheat. The cheats use LibVMI to communicate with KVM's introspection library. KVMI provides the cheat program direct read and write access to the guest VM's memory and access to different hardware interrupts e.g. page guard exceptions. The guest runs a vanilla operating system installation without any modifications, including the game installations. 

\subsection{Building Blocks}
\label{sec:building_blocks}

The use of LibVMI for the development of the \frameworkName is important as it opens the vector of attack not only to KVM but also the Xen hypervisor which provides even more stealthier options to monitor guests by employing altp2m (multiple EPTs) \cite{lengyel2016stealthy}. Many anti-cheats e.g. Easy Anti-Cheat and BattleEye do not let the game start if they detect kernel debugging is enabled. The support for volatility debug kernel symbols by LibVMI makes debugging on the guests kernel obsolete. We now describe how each of the different tasks required to build a video game cheat can be achieved via VMI:
\begin{itemize}
    \item \textbf{Reading} memory to the guest physical memory is achieved using the Second Level Address Table (SLAT) implemented using Extended Page Table (EPT) or Nested Page Tables (NPG). LibVMI walks the page tables of the guest VM by using the page directory location of the relevant process and reads the relevant memory pages and their address values from the host physical address.
    
    \item \textbf{Writing} to memory happens in a similar manner to reading. LibVMI walks the page tables of the guest VM by using the page directory location of the relevant process and updates the host physical address pointed by SLAT.
    
    \item \textbf{Monitoring} access to a value in memory is achieved via Page guard exceptions. To achieve a page guard exception or page fault, LibVMI modifies the guest page frame number (gfn) bits of the memory page which contains the address we want to receive exceptions for. Every time there is an exception on any address contained inside the memory page frame an associated callback method will get called. The callback gets called only when there is a relevant address modification. The performance of this method is bound to the number of events the page frame generates. This technique becomes particularly useful when the cheat needs to act on an in game event.
        
    \item To achieve \textbf{input emulation} we use the QEMU Machine Protocol (QMP), a JSON based protocol for communicating to QEMU machines using sockets. It enables the host to trigger a range of IO events including mouse clicks and key presses. QMP IO events are indistinguishable from IO events, triggered manually via a keyboard or a mouse, at the guest level.

    \item \textbf{Overlays} are transparent windows with the same dimensions as the game window which gets overlapped on top of the game window. They are mainly used to highlight different elements of the video game screen with to increase the player's advantage (e.g. position of an enemy player even if they are behind a wall). This normally gets implemented in different ways e.g. internal cheats hook either D3DX or OpenGL functions responsible for drawing game frames to the screen \cite{cano_2016}. In \frameworkName the overlay window runs on the host machine (outside the VM running the game). This makes it impossible to detect by current anti-cheat systems.
\end{itemize}

Using these blocks, we are capable of building a range of cheats that bypass current anti-cheat systems. In particular, we build \frameworkName to include three different cheats: a cheat-radar, a wall-hack and a trigger-bot that are evaluated in \S\ref{sec:evaluation}. 

\subsection{Selected Cheats}
\label{subsec:cheatcategories}

This section describes the implementation of the three cheats selected for \frameworkName. A more detailed description of how these cheats affect the game can be found on \S\ref{sec:Background}. Some of the cheats developed for this work have been partially based on sources by cheat developers that are posted online as means to gain reputation in online cheating communities, as mentioned in \cite{DetectingGameInjectors}. We leverage these already public cheats also to prove that our framework can be used to successfully translate traditional cheats into VMI-based cheats. 


\begin{figure}[H]
     \centering
     \begin{subfigure}{0.45\textwidth}
         \includegraphics[width=\textwidth]{pics/cheat-radar-tf2.pdf}
         \caption{Team Fortress 2}
         \label{fig:tf2-cheat-radar}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.45\textwidth}
         \includegraphics[width=\textwidth]{pics/cheat-radar-bs.pdf}
         \caption{BlackSquad}
         \label{fig:bs-cheat-radar}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{pics/cheat-radar-frt.pdf}
         \caption{Fortnite}
         \label{fig:frt-chear-radar}
     \end{subfigure}
     
        \caption{Cheat radars for each of the games used during the evaluation using \frameworkName. The left-hand side shows the cheat radars for each game. The right-hand side is the actual game frame illustrated by the cheat radars.}
        \label{fig:cheat-radar}
\end{figure}

Similarly to "traditional" external cheats the cheat developer first needs to identify where the structures and information the cheat needs to function are stored in memory. This first discovery phase of the necessary offsets is done by reverse engineering the game binary using disassemblers (IDA \cite{ida}, Ghidra \cite{ghidra}) or by using memory scanning tools like Cheat Engine \cite{cheatEngine}. An easier way to find offsets is to use special programs called \emph{Dumpers}. Dumpers are usually developed for a specific game or game engine and try to automate the process of finding the relevant offsets. Another way to find offsets is to visit game hacking forums like \textit{MPGH} and \textit{UnknownCheats} in hope some other user has updated the game's forum with the latest offsets.  

\frameworkName uses two threads for any cheat that requires an overlay. The first thread (main thread) reads information from the game, while the second thread is responsible for rendering the required information on the screen (which depends on the cheat), \textit{Algorithm \ref{alg:uiThread}}.  
The first thread comes in two versions, \textit{Algorithm \ref{alg:mainThread} \& \ref{alg:mainThreadV2}}. Version \ref{alg:mainThread} is used when we need to read from memory in certain intervals. We do this by reading the corresponding memory position and sleeping until the next read. This can sometimes be inefficient as it requires the process to sleep, wake up, read the address again and compare the value to understand if there was a change. This results in unnecessary reads. 

Because of this, we introduce version \ref{alg:mainThreadV2}, a more efficient version that takes advantage of page guard exceptions. In this version we record the memory addresses that we want to monitor via page guard exceptions. We want to monitor these memory addresses because they may hold relevant information about the game state such as the position of an enemy avatar with respect to player. For each of those memory addresses then we add callbacks that execute the particular action we want the player to execute automatically when that memory address is accessed (the previously identified condition is met). This allows us to do a more efficient implementation of some cheats. 

However, this method has to be used carefully. If many memory addresses are monitored, the amount of page guard exceptions will result in a high number of events which can bring the guest VM to a halt. Because of this, our cheat implementation uses version \ref{alg:mainThread} and we have also produced a cheat implementation for the trigger-bot for Team Fortress 2 using version \ref{alg:mainThreadV2}. It is important to highlight that the \frameworkName runs only on the host machine as seen on Figure \ref{fig:methodology}.


\begin{algorithm}
\caption{\frameworkName Main Thread version a. This thread is in charge of obtaining the relevant information from game memory and passing it to the user interface thread.}\label{alg:mainThread}
\begin{algorithmic}
%\State $gameIsRunning \gets true$
\State $gameValues \gets Array[PlayerObject, PlayerObject,...]$
\State $uiThread \gets \Call{$Thread$}{$gameValues$}$ \algorithmiccomment{Passes reference of array to Thread}
\State $uiThread.start()$ \algorithmiccomment{Starts User Interface Thread}
\While{$gameIsRunning$} 
  \State \Call{$UpdateGameValues$}{$gameValues$}
  \State \Call{$Sleep$}{$TimeInMilliseconds$}

\EndWhile
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{\frameworkName Main Thread version b. This thread is in charge of monitoring a small number of addresses and execute callbacks on address change.}\label{alg:mainThreadV2}

\begin{algorithmic}
\Procedure{CallbackA}{$newAddressValue$}
  \State \Call{jump}{ }
\EndProcedure

\Procedure{CallbackB}{$newAddressValue$}
  \State \Call{startShooting}{ }
\EndProcedure
\Procedure{\textbf{main}}{}
\State $addressList \gets Array[int, int]$

 \State \Call{$registerException$}{$addressList[0]$, CallbackA}
 \State \Call{$registerException$}{$addressList[1]$, CallbackB}

 \State \Call{$ListenForExceptionEvents$}{ }
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{User Interface Thread. This thread will create the overlay required for a particular cheat based on the game state information received from the main thread.}\label{alg:uiThread}
\begin{algorithmic}
\State $gameValues \gets mainThreadGameValues$
\While{$gameIsRunning$} 
  \State \Call{$Draw$}{$gameValues$}
    \State \Call{$Sleep$}{$TimeInMilliseconds$}

\EndWhile
\end{algorithmic}
\end{algorithm}

\subsubsection{Cheat radar.\label{subsec:cheat-radar}}Cheat radar requires the knowledge of the player's coordinates in the world space where all the game objects exist. These are obtained by reading memory at particular offsets found during the initial discovery phase. The x and y coordinates representing the player's position on the actual game map get scaled down to fit the dimensions of the cheat radar 2D map. In order to scale them down, the cheat developer first needs to identify the maximum value they can take. This can be accomplished by identifying the map dimensions for each game and select a maximum value accordingly. 

\subsubsection{Wall-hack. \label{subsec:wall-hack}}The Wall-hack starts from the same coordinates obtained for the cheat radar but requires translating the obtained 3D world coordinates to a 2D vector of screen dimensions (as shown on Figure \ref{fig:wall-hacks}). This transformation is referred to as world-to-screen transformation and it is a common design practice in games and game engines. To apply this transformation we need a View Matrix. A View matrix is a 4 x 4 matrix, which transforms world-space vertices to view-space vertices. This transformation is depicted in Figure \ref{fig:world-to-screen}. An example of a transformation matrix can be seen in Equation \ref{eq:tr-matrix}. The first three columns of the matrix represent the orientation of the x,y and z axis in the new space. The fourth column represents the position of the object in the new space. After a view-space transformation has taken place, the objects in view-space are seen from the point of view of the camera lens. To finalize our wall-hack we need to project the view-space coordinates to clip-space using a projection transformation. The projection matrix squeezes the view-space to a two dimensional space, our screen. A more detailed explanation of the world-to-screen transformation can be found in \cite{modelViewProjection}. 

\begin{figure}[H]
    \centering
    \includegraphics[scale=0.25]{pics/worldToScreen.pdf}
    \caption{Illustration of model space to screen dimension transformation used for the wall-hack cheat.}
    \label{fig:world-to-screen}
\end{figure}

\begin{equation}
\begin{bmatrix}
Or\_X-Axis.x & Or\_Y-Axis.x & Or\_Z-Axis.x & T.x\\
Or\_X-Axis.y & Or\_Y-Axis.y & Or\_Z-Axis.y & T.y\\
Or\_X-Axis.z & Or\_Y-Axis.z & Or\_Z-Axis.z & T.z\\
0 & 0 & 0 & 1 
\end{bmatrix}
\label{eq:tr-matrix}
\end{equation}






\begin{figure}
     \centering
     \begin{subfigure}{0.45\textwidth}
         \includegraphics[width=\textwidth]{pics/wall-hack-tf2.pdf}
         \caption{Team Fortress 2}
         \label{fig:tf2-wallhack}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.45\textwidth}
         \includegraphics[width=\textwidth]{pics/wall-hack-bs.pdf}
         \caption{BlackSquad}
         \label{fig:bs-wallhack}
     \end{subfigure}
     \hfill
     \begin{subfigure}{0.45\textwidth}
         \centering
         \includegraphics[width=\textwidth]{pics/wall-hack-frt.pdf}
         \caption{Fortnite}
         \label{fig:frt-wallhack}
     \end{subfigure}
     
        \caption{Wall-hack cheats for each of the three evaluated games using \frameworkName. The wall-hack highlights relevant entities by drawing rectangles around them. In this case, red rectangles represents the enemy avatars while blue ones represent the allies.}
        \label{fig:wall-hacks}
\end{figure}



\subsubsection{Trigger-bot.\label{subsec:triggetbot}}
Trigger-bots normally execute two consecutive tasks: (i) identify when the local player is aiming at an enemy avatar and (ii) communicate with the local player when to start or stop shooting. Understanding if an enemy is under cross-hair is game design specific, thus it can be achieved by either finding a memory address which stores a ray tracing result of the player's cross-hair or by comparing the screen position of the enemy avatar with the cross-hair position which is usually the screen center. If there is an overlap between these two regions then the enemy is on target. The on target check can vary based on the cheat implementation. We provide two ways of implementing this check behaviour a) with periodic memory reads and b) using a page guard exception which calls a callback that triggers an event e.g. start or stop shooting.

To force the player to star or stop shooting we can either scan the game's process for an address which controls the shooting state and modify (write) the address accordingly when we want to shoot.

A more generic and stealthier solution is to mimic input devices with the help of the VM and use remote interfaces like QMP (QEMU Machine Protocol) messages to send mouse input or keyboard input \cite{qemuQMP}. Mimicking input devices triggers the right methods a normal game input event would trigger. On the other hand changing random bits in memory might trigger some anti-cheat detection measures if that particular address happens, for an example, to be stored in multiple locations and the cheat updated only one of the expected values thus making input device mimicking a stealthier and more abstract method to trigger input events.

