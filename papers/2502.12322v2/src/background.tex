


\section{Background and Related Work}
\label{sec:Background}

For the purpose of this paper, video game cheating can be defined as the act of gaining an advantage over other players by modifying or accessing information inside the game's process which were unintended by the game developers. Network packet modification and server or client side statistical analysis are both outside of the scope of our paper and therefore not included within our definition. However, these kinds of cheats have also been explored and used in the past \cite{BURSZTEIN2011OPENC,BURSZTEIN2016IAM,Lehtonen2020}. Cheats that conform with our definition are typically categorised based on two different criteria: how they get injected into the game, inside the game's process or outside, and what kind of advantage they provide to the cheater. 



Modifying the video game behaviour normally requires changes on how the process running the video game is executing (changes in its memory space). \textbf{Internal cheats} are directly injected inside the game's process. When a cheat or any DLL library gets mapped into a process memory, it has access to game's functions and memory. Function hooks and trampoline functions are also used to introduce new behaviours as described by Feng et.al \cite{FengStealthMeasurements}. Karkallis et.al highlighted in their underground cheat forum analysis the importance and popularity of generic injectors and how they are one of the most widely used methods to inject cheats into video games \cite{DetectingGameInjectors}. \textbf{External cheats} exist outside the game's process. They can either exist in a process created by the cheat or get injected in elevated processes to take advantage of the additional privileges granted by the elevated process. This type of cheats normally have arbitrary access (read and write) to all the process running the game unlike internal cheats which are restricted by where they are injected.

When successfully executed, cheats provide unfair advantage to the players by several means. \textbf{Cheat Radars} map the position of enemy players in real time in a 2D virtual map of the video game world. This information helps the cheater to anticipate attacks by players in close proximity and creates an advantage over other players. The cheat takes advantage of the location information shared with the game client by the game server. In some cases the radar is drawn by using the cheater’s player position as point of reference. \textbf{Wall-hacks} highlight elements on screen so they can be easily identified by the cheater. Usually the highlighted parts are enemy avatars as means to understand their location before they get closer to the cheater's player. It involves a world-to-screen translation of the player's location to a 2D screen dimension.

 \textbf{Trigger-bots} reduce the cheaters reaction time in FPS games by automatically firing at an enemy when they are on target. They are considered more advanced compared to the two previous cheats as they do not only read the game state. They also process aiming information from the cheater’s avatar cross-hair and if an enemy avatar is on target it then commands the game client to start firing while the enemy avatar is in range.
\textbf{Aim-bots} increase shooting accuracy by automatically aiming at enemy avatars. The cheater's camera rotation gets adjusted accordingly to keep the cross-hair always on target of the enemy avatar. This cheat can be used in conjunction with a \textbf{No-recoil} cheat, which removes the recoil action when firing a weapon in shooting games thus increasing the players shooting accuracy. Depending on where the game state is kept cheats like \textbf{Speed-hacks} (increases the speed of the cheater's avatar) or \textbf{God-modes} (provides the player with invincibility) can also be enabled. 


\textbf{Anti-cheats} are programs developed by game studios or third party companies to protect the game's processes from malicious activity/cheats.  At the time of writing this paper there exist three different types of client-side anti-cheats: User-mode, kernel-mode and anti-tamper. User-mode and kernel-mode anti-cheats monitor the game process and try to detect malicious interactions a cheat would try to do. 
Their main difference, as suggested by their name, is that kernel-level anti-cheats also employ a driver to monitor kernel space. User-level anti-cheats exist only in the user-space with elevated privileges and monitor the game's process through the available methods and resources available. Similar to user-level anti-cheats, anti-tamper anti-cheats can also monitor the game process for malicious activity but they take a preemptive strategy towards cheating. Their main goal is to increase the difficulty of reverse engineering the game binary. They obfuscate the game binary and encrypt parts of it, even while the game is running, so it cannot be analyzed by disassemblers \cite{androidObfuscation,balakrishnan2005code,you2010malware}. A more detailed description on anti-cheat methods and system comparison can be found in \cite{bohnerthanti}.

To help them create new cheats, cheat developers created \textbf{tools} to assist then in the task of narrowing down the parts of the game memory more useful to them. Two popular tools are CheatEngine\cite{cheatEngine} and ReClass\cite{reClass}. They both have many abilities including memory scanning and memory editing. CheatEngine, a widely-used tool for game hacking, in more recent years introduced a Type-1 hypervisor called Dark Byte's Virtual Machine (DBVM). The tool implements DBVM as a means of avoiding kernel-level checks by elevating memory accesses of the CheatEngine process using the hypervisor. There exist two ways to load DBVM onto a system. The first requires the cheater to load a driver onto the system which can be detectable by kernel anti-cheat systems. The second is to load DBVM from a universal serial bus (USB) stick at boot time alongside the OS. 


DBVM, being a Type-1 hypervisor, comes with certain limitations. One significant issue is that the Cheat Engine process or any cheat related process e.g. overlays must operate within the same OS as both the game and its anti-cheat system. This arrangement compromises the stealthiness of the approach, especially since many anti-cheat systems maintain a blacklist of prohibited programs and prevent the game from running if these programs are active. Another challenge posed by the nature of a Type-1 hypervisor is that DBVM is more complex to test and modify. It also tends to be less stable, as reported by users on various online forums \cite{dbvmcrash1,dbvmcrash2,dbvmcrash3}. To illustrate this, Figure \ref{fig:dbvm_crash} shows a discussion from a Guided Hacking forum user commenting on the instability problems experienced with DBVM.

Type-2 hypervisors, such as Quick Emulator (QEMU), run as programs inside a host OS, for example Ubuntu Linux. In the realm of game cheating, this allows for the utilisation of the host OS to operate cheat-related processes, effectively using the hypervisor as a shield between the anti-cheat systems and the VIC. This setup eliminates the need for custom boot loaders that are necessary to run guest VMs in solutions like DBVM. Moreover, Type-2 hypervisors are generally more robust compared to DBVM. Another advantage of Type-2 hypervisors is their ability to emulate input devices, which can simulate player input in games. In practical applications, there have been discussions about the use of Type-2 hypervisors in online forums. There are relatively simple cheats observed in the wild that use a Type-2 hypervisor, mainly for reading and writing to game memory and debugging games \cite{guidedHackingVMIntro,uncHyperV,pareidoliatriggerbotHypervisor}. This creates the need for investigating further how more advanced VIC cheats can be implemented and what performance they might have.

\begin{figure} [H]
   
    \includegraphics[scale=0.5]{pics/dbvm_crash_post.pdf}
    \caption{GuidedHacking forum post discussing DBVM crashes. \cite{dbvmcrash3}}
    \label{fig:dbvm_crash}
\end{figure}

 Various studies in the literature explore how VMs and virtualisation technologies are used to develop cheats, highlighting the challenges in detecting such cheats when a hypervisor is involved \cite{FengStealthMeasurements,lehtonen2020comparativeAntiCheats,spider}. However, none of these studies demonstrate the actual implementation of VIC, or show how they can be effectively used to gain an advantage over other players in online games.

This work aims to expand upon the understanding and the limitations of already implemented solutions e.g. DBVM and the gaps in the literature. The chapter evaluates the effectiveness of VIC using a Type-2 hypervisor with introspection capabilities across various popular games. It outlines a method for developing VIC cheats that minimally affect game performance. This approach takes advantage of the isolation provided by the hypervisor and the ability to emulate input, thereby ensuring that the cheats operate subtly. Moreover, the chapter also presents strategies for detecting these types of cheats, offering a comprehensive view of both the implementation and mitigation of VIC in the gaming context.



Our proposed attack in \S\ref{sec:vmiCheat} can be considered an external cheat as the cheat not only runs outside the game's process but outside the game's operating system. This division means anti-cheats cannot upload the cheat module injected to the game process to their servers for post analysis, something the majority of the anti-cheats use as means of understanding how new cheats work. It also offers an abstraction to cheat developers that facilitates their development as the same cheat can run on different anti-cheats with minor modifications apart from the update of memory object offsets. 