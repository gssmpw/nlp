
\section{Mitigations \& Discussion}
\label{sec:discussion}


While we were able to execute cheats via \frameworkName without being detected, the fact that they execute via a hypervisor could be used to help in their detection. This section discusses the different mitigations proposed in the literature in this direction. We also discuss how these new kinds of cheats could affect the current business model of cheat developers. In particular, we talk about the potential impact of cloud gaming in regards to cheating in online video games.

\subsection{Hypervisor detection}


\subsubsection{\textbf{Timing techniques}}
From the point of view of the game developer and the integrity of the game, cheating can be considered a malicious act. Thus, the hypervisor can be characterised as a malicious introspection hypervisor. Lots of research was conducted on detecting the use of a hypervisor although as highlighted by Tuzel et al. in \cite{whoWatchesTheWatcher} the important distinction of detecting an introspected hypervisor from a hypervisor becomes more and more important and relevant as time progresses. In their paper, they introduce ways to detect introspection using different indicators. \textit{Instruction intercession}, \textit{Active memory intercession} and \textit{Passive memory monitoring}. 

Daax et al. have researched how anti-cheats try to deal with the problem of cheating using a hypervisor. To be more specific, they reverse engineered BattleEye \& Easy Anti-Cheat and give a great inside on how these anti-cheats detect emulation \cite{DaaxAntiCheatEmulation}. They report that both anti-cheats use a standard timing attack using the \textbf{\textit{rdtsc; cpuid; rdtsc}} instruction combination to count the duration it takes to execute the cpuid instruction as it triggers a vmexit. This can be avoided by using a proper TSC emulation at the hypervisor level. Easy Anti-Cheat was reported to perform an additional check. 
 It executes the  \textit{\textbf{vmread}} instruction upon driver initialisation and checks for a \textit{\#UD} (undefined instruction exception).
 
 They conclude these checks are simple to circumvent (at the time of writing their report in 2020). The experiments carried out for this work validate their findings. No extra steps were taken to hide the hypervisor during the experiments. Tuzel et al. \cite{whoWatchesTheWatcher} also comment on the unreliability of the TSC clock and recommend the use of the x86 HPET timer as an alternative. HPET is less precise compared to TSC, although it is more difficult to manipulate using a hypervisor, as it can introduce problems to the guest's behaviour. It can cause problems with video and audio playback, which is undesirable when playing a video game \cite{intelHPET}.

 \subsubsection{\textbf{Page Guard Exceptions}}
The VIC framework utilises page guard exceptions to establish a monitoring mechanism capable of observing changes in address values, as detailed in \S \ref{sec:building_blocks}. The monitoring mechanism is a cheat implementation improvement as the cheat is notified by an exception callback handler on the hypervisor level when a monitoring address changes. A way to defend against this mechanism is to increase the number of callbacks that the hypervisor needs to process. This will harm the cheat performance, thus removing any advantage the cheater will gain over other players while using it.  

In response to this mechanism, a game developer can leverage the use of huge pages, a memory page of 2MB or 1GB in size instead of 4KB, to allocate memory in the game process. A bigger page consists of a larger number of addresses; thus, allocating important addresses to this type of page will introduce a large number of interrupts and will cause a VIC cheat with the monitoring callback behaviour to suffer performance degradation. Huge page support depends on the OS and hardware support.


\begin{figure}
\centering

\begin{lstlisting}[language=C, basicstyle=\small\ttfamily]
SIZE_T pageSize = 4096; // 4KB page frame
LPVOID pageMemory = VirtualAlloc(NULL, pageSize,
                              MEM_COMMIT, PAGE_READWRITE);

// Example: NOP instruction (0x90) for x86 and x86-64
unsigned char codeInstruction[] = {0x90}; // NOP
int gameVariable = 5;

// Copy the code instruction into the allocated memory
memcpy(pageMemory, codeInstruction, sizeof(codeInstruction));

// Copy the data variable into the allocated memory, 
// right after the code instruction
memcpy((void*)((SIZE_T)pageMemory + sizeof(codeInstruction)),
                        &gameVariable, sizeof(gameVariable));

__try {
    ((void(*)())pageMemory)();
} __except (GetExceptionCode() == EXCEPTION_ACCESS_VIOLATION ? 
                                  EXCEPTION_EXECUTE_HANDLER :
                                  EXCEPTION_CONTINUE_SEARCH) 
{
    // Change permission to execute
    VirtualProtect(pageMemory, pageSize, 
                   PAGE_EXECUTE_READ, 
                   &oldProtect);
    
    // Re-execute the instruction now that it's allowed
    ((void(*)())pageMemory)(); 

    // Revert permissions to induce faults again
    VirtualProtect(pageMemory, pageSize,
                   PAGE_NOACCESS, &oldProtect);
}
\end{lstlisting}
   
\caption{Pseudo-code of Windows API code allocating a page memory consisting of code and data.}
\label{fig:pageFault-code}
\end{figure}

A cheater may choose to disable this feature at the hypervisor or OS level, to safeguard against the utilisation of huge pages. This action, however, prevents the system from accessing the numerous benefits that come with the use of huge pages. For instance, one of the key advantages is a reduction in cache misses, a direct result of the translation lookaside buffer (TLB) holding fewer entries. The TLB, a critical memory cache, is responsible for storing the recent translations from virtual to physical memory. Additionally, another significant benefit is the ability of the system to avoid swapping pages outside of the main memory, thereby maintaining operational efficiency and improving performance \cite{benefits-huge-pages}.


An increase in the total number of page faults can also be achieved by the allocation of both code and data within the same page frame, resulting in a fault being generated with each execution of the code instruction allocated. This scenario is illustrated in Figure \ref{fig:pageFault-code}, where a memory page is allocated and populated with a \textit{NOP} instruction. Following this instruction in memory, an integer is placed, representing a game variable that the developer aims to safeguard. The latter part of the code illustrates the execution of the instruction from within the game process, followed by a try-catch statement. It is demonstrated by the catch statement's exception handler how the permissions of the memory page are altered to execute the instruction, before being reverted to \textit{PAGE\_NOACCESS} permission, thereby reinstating the page guard exception for future occurrences.


Both of the above techniques aim at increasing the number of exceptions/interrupts passed to the VIC callback system. As already discussed in \S \ref{attack-validation} the use of SPP available on some Intel CPUs can alleviate a big part of the extra exceptions created by the use of huge page frames and the construction of page frames which include neighbouring code instructions and game data. SPP increase the granularity of monitoring a sub-page to 128 bytes as described in Intel's Software Developer's manual \cite{IntelSPP}.
\subsection{Process Enclaves}
In recent years, the academic community have also proposed anti-cheat solutions which employ the use of enclaves like Intel SGX to give an answer to the on going issue of cheating  \cite{sgxCheatDetection,sgxBlackmirror}. These solutions seem promising because of their anti-tamper properties, although even without taking account the number of emerged attacks on enclaves; there are a few more issues to consider. Intel discontinued SGX for their consumer chips at the time of writing this paper \cite{intelSGXComm}. This introduces a discrepancy as game developers cannot force their audience to use specific hardware in order to be able to play a game. Another important factor is the extra development time added by these custom hardware solutions, as they increase the support and development time for the game security teams or anti-cheat developers. Mainly because they have to support different manufactures on top of different OS support if the game happens to be available across different platforms e.g. Linux, Windows and MacOS. In this regard, Google Cloud introduced Asylo in 2018, an enclave development framework which aims to help tackle the problem of supporting multiple enclave applications \cite{googleAsylo}.


\subsection{Domain Enclaves}

In contrast to process based enclaves (Intel-SGX) that try to protect parts of a process by running it in an enclave; Intel-TDX and AMD-SEV offer a domain based confidential environment by placing the whole virtual machine in an enclave \cite{IntelTDX}. This creates isolation between other protected VMs and a malicious hypervisor. The VM memory is encrypted and the hypervisor has only access to necessary information needed to keep the VM running. This is achieved by placing a trusted hardware module between the hypervisor and the VM which takes the responsibility to handle interrupts and memory events. Domain enclaves have a great advantage over process enclaves as they do not require any application modification to be used.

The thread model of both Intel-TDX and AMD-SEV fits perfectly with the cheating framework we propose in this paper and can be a good solution to the problem. Unfortunately at the time of writing Intel-TDX is not available on any hardware yet and AMD-SEV is available only with AMD EPYC CPUs which are specifically targeting server and embedded system markets, not consumer devices or gaming PCs \cite{AMD-SEV}.


\subsection{Community impact}
\label{sec:discusion:business_model}


Game cheating communities are organised in online forums and private online groups, as discussed in Karkallis et al. \cite{DetectingGameInjectors}. At the time of writing, UnkownCheats and MPGH have 5 million and more than 4 million members, respectively. VIC cheats impact the way cheats are exchanged in these communities; as a pre-setup of the hypervisor and introspection libraries is required to be in place before running the cheats. The current exchange model usually involves getting access to cheat forums or private discord groups, paying or downloading free cheats in the form of an executable or DLL and injecting them into game memory in the case of DLLs.

The proposed cheats are more difficult to set up, as the cheat developer will have to provide additional preinstalled scripts or guides for the installation and setup of the hypervisor and introspection libraries. The rest of the process will remain identical, as the cheat developer can still compile the actual cheat as an executable for download, although the cheat's interactions with memory and interrupt signals need to be manually modified, as they need to use the hypervisor and run on the host machine as explained in \S \ref{sec:vmiCheat}. In the future, cheat developers might automate this transition by abstracting the cheat interactions. They can also provide a VM for download with the entire setup. This could also eliminate the cheating issues that arise from different OS versions. 

The use of VMs is also strongly coupled with new trends like cloud gaming. Many cloud providers have taken a step towards cloud gaming, with slightly different business models. Some examples are Nvidia's GForceNow and Xbox Cloud Gaming. Cloud gaming offers the advantage of running the actual game remotely and reduces the attack vector of cheats to screen and input devices. During the writing of this thesis, one of the major cloud players, Google, discontinued their cloud gaming service, Stadia \cite{stadiaClosure}. This might be an indicator that cloud gaming technology is immature at the time of writing this thesis. On the other hand, this might not be enough to stop cheat developers from creating Game-Cheating as a service (GCaS) and offer cheaters remote access to VMs with cheats enabled. 

This way cheaters would not need any cheating expertise to access a cheat. They will just connect to the GCaS guest which will be pre-configured with a VMI-enabled cheat and just play the game. This would also reduce some of the risks associated with game cheating, as they will no longer run the risk of installing a potentially malicious program embedded within a cheat. A great example of this is the Remote Access Trojan (RAT) disguised as a Call of Duty cheat in 2021 \cite{callOfDutyTrojan}. In addition, using CGaS allows cheaters to avoid hardware bans (which identify and ban a particular device ID). The game would be running inside the VM on the GCaS service, transferring this responsibility to the cheat developer and platform maintainer. The cheaters would still have to create a new account if their account is blocked. 


\subsection{Responsible disclosure}
\label{subsec:ResponsibleDisclosure}
The authors are responsible for disclosing and informing any parties affected by the outcome of this research. The author contacted the game developers of Fortnite, TF2 and BlackSquad on 15th December 2022. The author informed the game developers about the possibility of bypassing their current anti-cheats via VMI. The chapter contents were attached to the initial submission which was carried via direct communication with the game developer or through their bug bounty programs when one was available. There was a follow-up correspondence on 4th January from the Fortnite team. They asked to play at specific times with the cheats activated to gather more data. They later applied a fix by not letting the game start in a VM. When asked about an official update on the issue later on there was no reply back from them after numerous attempts. 

\subsection{Limitations}
\label{sec:limitations}


The \frameworkName framework shares similar limitations with traditional cheats. It is bound by behavioural analysis carried out on the game server by employing ML models \cite{pinto2021deep,tao2020xai,spijkerman2020cheat} or player complaint reports \cite{eaCheatReporting}. This means a cheater can only be as good as a professional player if they do not want to be detected by statistical detection vectors. 

The cheat implementations discussed in this chapter do not have direct access to in game functions. An advantage internal cheats have over the proposed cheat methodology and external cheats, in general. This limitation can be mitigated by copying and emulating the assembly code consisting of an in game function on a vmexit on the host. 

The use of page guard exceptions offers an elegant way of monitoring memory changes. However, as demonstrated in \S \ref{sec:evaluation} they suffer a big performance hit if the address being monitored happens to co-exist on an event busy page frame.  This can be mitigated with EPT-Based SPP, as previously discussed, when the hardware supports it. Another important thing to consider is the need to identify an address that represents a state useful to the cheat. This is game design-dependent. 

The assumption that video games are security-agnostic is made in the threat model \S\ref{sec:threatModel}. Thus the use of simple hacks like infinite health or one shot kill hacks is not possible. A securely designed game should validate these states on the server side and not on the client side which will make the use of these types of cheats impossible.

There also exist some feature oriented limitations. VMI is still maturing and supports specific hardware, mainly Intel CPUs, and is not widely available for all OSs at the moment of writing.

The methodology uses a hypervisor to hide the cheat's actions. In the scenario where the memory of the guest is encrypted, the host will not be able to make sense of what is returned from a physical memory read. Thus, encrypting the game memory can be problematic for the methodology. This work is limited only to hardware which supports virtualisation as the use of a hypervisor is a mandatory part of the methodology.