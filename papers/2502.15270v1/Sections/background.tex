\section{Background}
\label{sec:background}

\subsection{Non-resettable Device Identifiers}
\label{sec:background0}

\begin{table*}[ht]
\caption{SELinux Key Concepts Explanation.}
\label{tab:selinux}
\resizebox{1\textwidth}{!}{
\begin{tabular}{|l|l|l|}
\hline
SELinux Key   Concepts         & Format                                                                              & Example                                                                                                       \\ \hline
Property Context                & property\_name user:role:{\color{red}type}:sensitivity{[}:categories{]}             & \textbf{(a)} xxx.xxx.xxx.imei1 u:object\_r:{\color{red}system\_id\_prop}:s0                             \\ \hline
\multirow{3}{*}{Policy Rule}   & \multirow{2}{*}{allow {\color{blue}source\_type} {\color{red}target\_type}:class permissions}   & \textbf{(b)} allow {\color{blue}system\_app} {\color{red}system\_id\_prop} (file (read getattr map open))     \\ \cline{3-3} 
                               &                                                                                     & \textbf{(c)} allow {\color{blue}radio} {\color{red}system\_id\_prop} (property\_service (set))                \\ \cline{2-3} 
                               & allow type\_attribute\_set type\_attribute\_set:class permissions                   & \textbf{(d)} allow appdomain extended\_core\_property\_type (file (read getattr map open)))                                \\ \hline
Type Attribute Set             & typeattributeset {\color{blue}attribute\_name} {[}(and {\color{red}type1} ...){]} {[}(not {\color{green}type1} ... ){]} & \textbf{(e)} typeattributeset {\color{blue}extended\_core\_property\_type} ({\color{red}system\_id\_prop} ... ) \\ \hline
Keyword expandtypeattribute    & (expandtypeattribute attribute\_name $<$true, false$>$)                                  & \textbf{(f)} (expandtypeattribute extended\_core\_property\_type true)                                         \\ \hline
\end{tabular}
}
\end{table*}

In Android, non-resettable device identifiers are unique identifiers that cannot be altered or reset by the user, providing a consistent means of identifying a device. 
In our study, we consider the seven most commonly used non-resettable device identifiers, which are officially documented and frequently referenced in numerous researches~\cite{meng2023post, razaghpanah2018apps, reardon201950, ren2018longitudinal, stevens2012investigating}.
\begin{itemize}
    \item[1)] International Mobile Equipment Identity (IMEI): a fixed-length decimal digits assigned to mobile devices used for identifying valid devices on a cellular network. 
    \item[2)] Mobile Equipment Identifier (MEID): similar to the IMEI but used in CDMA phones.
    \item[3)] International Mobile Subscriber Identity (IMSI): a unique identifier assigned to the user of a cellular network, stored on the SIM card, often used for authenticating and tracking users on mobile networks.
    \item[4)] Integrated Circuit Card Identifier (ICCID): a unique identifier for a SIM card itself, used for identifying the card internationally and managing its activation and deactivation. Unlike the IMSI, which identifies the user, the ICCID is used to identify the SIM card.
    \item[5)] Device serial number: a unique identifier assigned by the device manufacturer, used for device warranty and service management. 
    \item[6)] WiFi MAC address: a unique identifier for the network interface card of a device, used for network access control and tracking devices on WiFi networks. 
    \item[7)] Bluetooth MAC address: a unique identifier for the Bluetooth module of a device. 
\end{itemize}

These identifiers are crucial for various functions, such as device tracking, network access, and device management.
The broad scope and stable nature of these identifiers are essential for user tracking, but they also pose significant privacy risks. Thus, they are no longer permitted for use by third-party apps after Android 10.

\subsection{System Properties and Settings}
\label{sec:background1}
\textit{\textbf{System properties}} in Android are key/value pairs used by system components and apps to manage configuration parameters~\cite{system_properties}.
These properties are managed by the property service, which sets up a shared memory area to store them during system startup. 
Some system properties are loaded from configuration files like build.prop and default.prop, which store fixed information (e.g., device name and system version).
Additionally, some system properties are dynamically set at runtime, such as device-specific information like the serial number, or runtime status of the device.
Accessing system properties simply requires querying the shared memory using system APIs or commands, without requiring interprocess communication.
And, setting properties involves direct communication with the property service, which handles the updates. 
This implementation makes system properties easy to use and ensures they have minimal performance overhead.

\textit{\textbf{System settings}} are also key/value pairs used to store device preferences, accessible system-wide, and can be easily managed through system APIs.
System settings are primarily stored in databases, and divided into three categories including \textit{System}, \textit{Secure}, and \textit{Global} settings.
Each category of system setting has a different purpose: \textit{Global settings} apply uniformly across all users, \textit{Secure settings} are readable but not writable by apps, and \textit{System settings} store miscellaneous system preferences~\cite{system_settings}.
The settings are managed by the \texttt{SettingsProvider}, which is a content provider in the Android system. 
It handles read and write operations to the database, ensuring data consistency and security.

\subsection{Access Control Policies}
\label{sec:background2}

The scope of system properties and settings is system-wide, allowing all entities within the system, such as system services, system apps, and third-party apps, to access.
However, since they function like global variables and store substantial device information, insufficient access control can result in vulnerabilities and exploitation.
For example, system properties and settings storing configuration parameters should be set only by the responsible system components, while those holding sensitive device information should not be accessible to apps without appropriate permissions.

In Android, Security-Enhanced Linux (SELinux)~\cite{selinux} enforces access control for system properties by implementing mandatory access control (MAC)~\cite{mac}.
SELinux operates on a principle of default denial, where any action not explicitly permitted will be denied.
Specifically, SELinux uses ``property contexts'' (a type of security context) to assign type attributes to properties, as well as processes within the system.
And specific access control permissions are assigned to these types.
The format of property contexts is shown in~\autoref{tab:selinux} example (a).
After the type attribute of a system property is identified, SELinux determines which behaviors are allowed based on specific policy rules.
For example, the example (b) in~\autoref{tab:selinux} shows that the system app (source type) is allowed to read system properties of type “system\_id\_prop” (target type).
As discussed in~\S\ref{sec:background1}, accessing properties involves reading from files representing shared memory. 
Thus, read permissions to these files enable objects to access system properties.
For setting properties, it is necessary to grant objects the ability to set the property service, as shown in example (c) of~\autoref{tab:selinux}.
In terms of format, these SELinux rules exist in ``te'' files (Type Enforcement) before system compilation. 
When compiled and packaged into the system ROM, these rules are converted into binary files. 
With the introduction of Project Treble~\cite{treble} in Android 8.0, a new intermediate language Common Intermediate Language (CIL) is used to define SELinux rules.
Other SELinux-related concepts are explained in appendices.

Besides, Android also has access control policies for system settings.
On the one hand, writing system settings is mainly controlled by permissions, such as the \texttt{\seqsplit{WRITE\_SETTINGS}}~\cite{write_settings} and \texttt{\seqsplit{WRITE\_SECURE\_SETTINGS}}~\cite{write_secure_settings} permissions.
Only apps with the appropriate permissions can add or change system settings, and the \texttt{\seqsplit{WRITE\_SECURE\_SETTINGS}} permission can only be used by system apps.
In terms of reading system settings, before Android 12, only settings labeled as ``@SystemApi'' were not accessible to third-party apps while all other settings were accessible.
Starting from Android 12, the ``@Readable'' annotation is introduced in the Android Open Source Project (AOSP)~\cite{aosp} to refine access control.
Specifically, the system rejects access to settings from non-system apps attempting to access settings defined in Settings.Secure, Settings.System, or Settings.Global that lack the ``@Readable'' annotation.
If a system setting has both the ``@Readable'' and ``@SystemApi'' annotations, only system apps can access it.
Furthermore, for system settings not explicitly defined in the Settings class but added by privileged apps, we observed that there is no access control mechanism in place, affecting both versions before and after Android 12.