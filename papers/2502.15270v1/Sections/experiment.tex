\section{{\framework}}
\label{sec:approach}
To thoroughly understand the covert access channels (i.e., custom system properties and settings) for non-resettable device identifiers in large-scale custom Android systems, we design {\framework}, which will be depicted in the following.

\begin{figure*}[ht]
  \centering
  \resizebox{1\textwidth}{!}{
  \includegraphics[width=\linewidth]{Graphs/workflow.pdf}
  }
  \caption{The Overview of {\framework}.}
  \label{fig:approach}
\end{figure*}


\subsection{Key Ideas and Pilot Study}
\label{sec:pilot}

To study the custom system properties/settings that store non-resettable device identifiers, one straightforward idea is to identify all locations where system properties or system settings are defined and then analyze their content.
In practice, unfortunately, finding these definitions is challenging, as they may be located across multiple layers of the Android system (e.g., the Linux kernel, drivers, system libraries, frameworks, pre-installed apps), and lack a consistent definition format.
Therefore, we take a different approach -- 
we focus on the usage of these system properties and settings, and analyze their content based on contextual information.
The assumption of this method is that the custom system properties and settings storing device identifiers are introduced to serve the functions of the system customization parts. 
And, the probability that the system defines a system property or system setting without ever using it is low.
Hence, we argue that locating the usage of system properties and system settings, and determining their content, can still provide a sufficient understanding of the custom system properties and settings.
We admit that this assumption is difficult to validate, as the ground truth of all custom system properties and settings is hard to obtain, which will be discussed in the limitation.

Although finding usage is a relatively feasible method, it is not that trivial, especially when it comes to locating the usage of system properties.
Unlike system settings, which can be accessed through well-documented methods, system properties are often accessed via ``non-SDK methods\footnote{Non-SDK methods encompass those not included in the public SDK, often belonging to internal APIs or used only in system-level apps only, leading to variable access behaviors.}'' or system commands.
Therefore, the behavior of accessing system properties is more variable.
To comprehensively identify the usage points of system properties, we first conducted a pilot study to investigate methods of accessing system properties.

In the pilot study, we attempt to identify potential system property access behaviors.
Since system property names typically appear as strings with format characteristics like starting with ``ro.'', ``persist.'', or ``vendor.''~\cite{meng2023post}.
We extract DEX files from APK and JAR files in the custom system and use the ``strings'' command to search for property names and further determine the presence of property access behaviors. 
Then, we manually reverse-engineer these files and summarize the methods they use to access system properties.
This pilot study enable us to understand the diverse ways system properties are accessed in custom systems.
The results of the pilot study will be explained in detail in~\S\ref{sec:approachstatic}.

\subsection{Overview of {\framework}}
Our methodology is depicted in~\autoref{fig:approach}.
We begin with a static analysis of all APK and JAR files within the custom Android ROMs.
Leveraging the insights from our pilot study, we pinpoint all instances of system property and setting usage, along with their contextual code.
Next, we apply a heuristic algorithm to filter the extensive results from the first step, identifying a subset likely to contain non-resettable device identifiers as mentioned in~\S\ref{sec:background0}.
Security experts then manually review the filtered subset to confirm which properties or settings store sensitive identifiers.
Finally, we analyze SELinux policies and framework code in custom systems to determine the access control policies of these system properties and settings, identify the vulnerable ones.


\subsection{Static Analysis}
\label{sec:approachstatic}



\subsubsection{Methods of accessing system properties/settings}
Through the pilot study in~\S\ref{sec:pilot}, we summarize the methods for accessing system properties and settings.
System properties is primarily accessed through non-SDK methods in the \texttt{\seqsplit{android.os.SystemProperties}} class or using the \texttt{getprop} system command.
For the \texttt{getprop} command, system code typically executes system commands using the \texttt{exec} method of the \texttt{\seqsplit{java.lang.Runtime}} class, as shown in~\autoref{fig:code}.
For the methods of the \texttt{\seqsplit{SystemProperties}} class, only a small amount of system code can directly call these methods.
Most code requires invocation through Java reflection. 
Typically, reflection involves at least three steps, as shown in~\autoref{fig:code}.

\begin{figure}[h]
  \centering
  \resizebox{1\linewidth}{!}{
  \includegraphics[width=\linewidth]{Graphs/code_2.pdf}
  }
  \caption{Code for Accessing System Properties and Settings.}
  \label{fig:code}
\end{figure}

In this code snippet, the process begins by dynamically loading the \texttt{\seqsplit{android.os.SystemProperties}} class using the \texttt{\seqsplit{Class.forName}} method (Step~\ding{202}). 
Next, the ``get'' method of the SystemProperties class is retrieved via \texttt{\seqsplit{Class.getMethod}} method (Step~\ding{203}). 
The method is then invoked with \texttt{\seqsplit{Method.invoke}} method, where ``propertyName'' is the specific system property name to access (Step~\ding{204}). 
The return value of this invocation is a String, which is the value of the requested system property.
However, through our pilot study, we found that there are different coding styles for reflection invocations.
All approaches to calling methods in \texttt{\seqsplit{SystemProperties}} class can be summarized as follows:
(a) Directly invoking methods in the SystemProperties class without using reflection. 
(Some system components can use this approach.)
(b) Using reflection, with all three steps of reflection contained within a single method.
(c) Using reflection, but the first two steps are completed during the static initialization of the calling class. 
The \texttt{\seqsplit{Method}} object obtained in the second step is stored in a static field, allowing the third step to be executed directly using this static field without reinitialization.
(d) Using reflection, but the first step or the first two steps are wrapped within a method. 
Subsequently, the wrapper method is called to obtain the ``Class'' or ``Method'' object.
Besides, for system settings, Android provides related SDK APIs. 
Most system code uses methods provided by the \texttt{\seqsplit{android.provider.Settings}} class to access system settings.


\subsubsection{Identifying system properties/settings}

After determining the methods of accessing system properties and settings, we aim to identify all the usage of system properties/settings in the custom ROMs, along with the contextual code that can help determine their content.
We employ static analysis, built upon Soot~\cite{vallee2010soot}, to analyze all APK and JAR files in the custom ROMs.
We first decompile these files and convert the Java code into Jimple, an intermediate representation used in Soot.
We then traverse all methods to locate those for accessing properties/settings, focusing primarily on invoke expressions and assignment statements with field references.

For invoke expressions, on the one hand, we examine whether the called methods are related to accessing system properties and settings, including methods in the \texttt{\seqsplit{android.os.SystemProperties}} class for accessing system properties, the \texttt{\seqsplit{java.lang.Class: forName}} method for Java reflection, the \texttt{\seqsplit{java.lang.Runtime: exec}} method for executing system commands, and methods in the \texttt{\seqsplit{android.provider.Settings}} class for accessing system settings.
On the other hand, we focus on whether the return type of a function call is \texttt{\seqsplit{java.lang.Class}} or \texttt{\seqsplit{java.lang.reflect.Method}}, corresponding to type (d) mentioned above for accessing system properties.
For assignment statements containing field references, we focus on whether the field type is \texttt{\seqsplit{java.lang.reflect.Method}}, corresponding to type (c) for accessing system properties.

When dealing with Java reflection and system commands execution through the \texttt{\seqsplit{java.lang.Runtime: exec}} method, we further analyze the content of the method parameters (i.e., \ding{202}, \ding{203}, and \ding{204} in~\autoref{fig:code}) to verify whether the reflected methods or executed commands are pertain to system properties and settings access.
This requires performing inter-procedural analysis. 
First, to handle types (c) and (d) for accessing system properties, when we find (1) a field type or (2) a method return type is ``Class'' or ``Method'', we further analyze the initialization of the class containing the field for situation (1); the methods returning ``Class'' or ``Method'' objects, to confirm whether the reflected call is to a \texttt{\seqsplit{SystemProperties}} class method for situation (2).
Second, to handle the instance of method encapsulation, where the reflected method value or executed system commands come from method parameters. 
We use a generated Inter-procedural Control Flow Graph (ICFG) to locate the call sites of the method and confirm the corresponding parameter values.

\subsubsection{Analyzing system properties/settings}
Next, for the confirmed system properties and settings access behaviors, we analyze the names of the accessed system properties/settings. 
These names serve as parameters in key methods, such as ``propertyName'' and ``settingName'' in~\autoref{fig:code}.
During this process, some special cases require additional handling: (1) The property or setting name is passed as a parameter. 
In this case, we conduct inter-procedural analysis to determine the parameter's value; 
(2) The name is constructed through string concatenation. 
For this, we simulate the string operations to retrieve the full name; 
(3) The name is stored in a field, where we look for the name in the class's \texttt{\seqsplit{init}} method; 
(4) The name is placed in an array, and we extract all the contents of the array, treating them as potential names.

Once we have obtained the names of the system properties and settings accessed in the custom system, we extract the context code of these usage points to analyze their content. 
To do this, we use the ICFG to backtrack from the call points (identifying the callers of the method), obtaining the complete method call chain and code content as contextual information.

\subsection{Filtering and Confirmation}
\label{sec:approachfilter}
Through static analysis, we obtained numerous system properties and settings used in the custom ROM, along with the corresponding context code.
Next, we aim to pinpoint a subset of these system properties and settings that contain the seven types of non-resettable device identifiers outlined in~\S\ref{sec:background0}.
To achieve this, we implement two simple yet effective heuristic algorithms: (1) We select system properties and settings whose names include keywords related to device identifiers, such as IMEI, ICCID, DeviceID, etc. 
In custom systems, these names generally reflect their content, without obfuscation.
(2) For context method whose name contains keywords related to device identifiers, e.g., ``getIMEI'' and ``getWifiMac'',we infer that the system properties/settings accessed within these methods correspond to those identifiers.


\begin{figure}[h]
  \centering
  \resizebox{1\linewidth}{!}{
  \includegraphics[width=\linewidth]{Graphs/manuel_2.pdf}
  }
  \caption{Key Information for Identifying Property Content.}
  \label{fig:manuel}
\end{figure}

In this way, we narrow down the range of system properties and settings that might contain sensitive identifiers.
Subsequently, we adopt manual inspection to finally confirm which system properties/settings contain non-resettable device identifiers leveraging the context code information.
In these code, there is a lot of information that could helps us determine the content of system properties or settings. 
For example, some log information contains descriptions of code behavior, as shown in the~\autoref{fig:manuel} \ding{202}.
Additionally, there may be other pieces of code with the same/similar functionality, as shown in~\autoref{fig:manuel} \ding{203}.
The code in~\autoref{fig:manuel} first tries to obtain the content from the system property. 
If the content is not valid, it then attempts to retrieve the device's IMEI from the system service. 
By understanding the semantics, we can infer that the system property's content should be consistent with the content retrieved from the system service, thereby determining that the system property stores the device's IMEI.
Our manual inspection process is primarily led by two experienced Android researchers, with a third for dispute resolution. 
First, we have two researchers analyze the same context information and determine which system properties and settings store sensitive information.
When the two researchers' opinions coincide, we directly adopt the result, and whenever there are different opinions, the two researchers discuss with the third researcher until a consensus is reached.

It is worth noting that during our manual analysis, we identify two situations that could potentially lead to inaccurate results.
(1) We find that some system properties/settings are accessed by only third-party pre-installed apps, which try to obtain non-resettable device identifiers through various methods, with system properties or settings being just one of them, like the example shown in~\autoref{fig:manuel}. 
We speculate that these third-party apps are uncertain whether the specific system property or setting exist in custom systems and are merely attempting to retrieve device identifiers from them. 
To reduce inaccuracies arising from such situations, we use a method similar to our empirical study by using the ``strings'' command to extract strings within all kinds of files (e.g., SO libraries and executable files) in the same custom ROM, and check for the presence of any that contain non-resettable device identifiers we identified. 
Through this method, we believe that only system properties or settings that can be identified in system components, determined by file paths, are relatively accurate.
(2) Some third-party SDKs in system apps access system properties that obviously do not exist in the system. 
For instance, we find access to the ``xxx.xxx.miui.xxx'' system property in system apps within the Meizu custom system, where MIUI is the name of Xiaomi's custom system. 
We manually exclude these cases for accuracy.

\subsection{Access Control Analysis}
\label{sec:approachaccess}
Finally, we analyze the access control policies for system properties and settings storing non-resettable device identifiers to find those lacking effective access control.
As mentioned in~\S\ref{sec:background2}, access control for system properties is primarily enforced through SELinux. 
We begin by identifying the property context of each custom system property, which is stored in files whose names end with ``property\_contexts''. We directly search for these files in custom ROMs.
Next, we examine the contents of these files to determine the appropriate property contexts for the system properties that hold sensitive device identifiers, with a particular focus on the ``type'' domain, such as ``system\_id\_prop'' shown in~\autoref{tab:selinux}.
Note that in the property context, property name can include the wildcard character ``*'', e.g., ``ro.*'' represents properties starting with ``ro.''.
The use of wildcards may result in a property matching multiple property contexts. 
For instance, ``ro.xxx.xxx.imei1'' could align with both the specific context ``ro.xxx.xxx.imei1'' and the more general pattern ``ro.*''. 
In such instances, SELinux prioritizes the context that is the most specific match. Typically, the property context name with the longest match to the property name is selected as the best fit.

After identifying the property context of a system property, we analyze the associated type attribute sets and policy rules in policy binary files (pre-Android 8.0) or CIL files (post-Android 8.0). 
CIL files are text files whose contents can be directly read, whereas, for policy binary files, we use the SETools~\cite{setools} to parse the embedded rules.
We locate all policy files and CIL files in custom ROMs, and then iterate through SELinux rules twice.
In the first iteration, we record all details related to type attribute sets, including definitions and the use of the ``expandtypeattribute'' keyword.
Given that the definition of a type attribute set may appear after its usage, and a set might reference other sets across various CIL files, we postpone specific policy rule analysis during the first pass.
Instead, we focus on identifying the types encompassed within each set after a comprehensive review of all CIL files.
More specifically, we parse the definitions of type attribute sets to determine the included and excluded elements (i.e., types or sets). 
Upon completing the file review, we assess each element. 
Specific types or non-expandable sets are immediately categorized into included or excluded groups.
For expandable sets, we further dissect the types they encompass, ultimately incorporating these into the corresponding group. 
Finally, we determine the types in each set by taking all types that are in the included set but not in the excluded set.

During the second iteration, we examine all policy rules, focusing on the source and target in each rule. 
If the target of a rule is the type to which a sensitive system property belongs, as determined by the analysis of property context, or a type attribute set encompassing this type, we consider the rule applicable to the sensitive property.
We also analyze the source in the rules to identify which types of entities, such as ``system\_app'' in~\autoref{tab:selinux}, have access these sensitive properties.
Generally, third-party apps belong to the ``untrusted\_app'' type. 
If, through analyzing SELinux policies, we find that a system property can be accessed by the ``untrusted\_app'' type, we conclude that third-party apps have access to it.

On the other hand, as described in~\S\ref{sec:background2}, to analyze the access control policies for reading system settings, we focus on the definitions and annotations of system settings in the \texttt{\seqsplit{android.provider.Settings}} class, typically located in ``framework.jar'' file. 
Using Soot, we analyze all fields in the ``Settings.Global'', ``Settings.System'', and ``Settings.Secure'' inner classes, corresponding to the three categories of Settings.
We extract the field names and their annotations, such as ``@Readable'' and ``@SystemApi'', which are our primary focus.
This process helps us determine the access control policies for system settings. 
Specifically, settings not explicitly defined in the Settings class are accessible by all system entities, including third-party apps.
Prior to Android 12, any system setting without the ``@SystemApi'' annotation is accessible to third-party apps. 
From Android 12 onwards, only those settings marked ``@Readable'' and not ``@SystemApi'' are accessible by third-party apps.