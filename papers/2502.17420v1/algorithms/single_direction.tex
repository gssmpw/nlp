\begin{algorithmic}[1]
\STATE \textbf{Initialize} $r$ randomly
\WHILE{\text{not converged}}
\STATE Sample batch $\batch \sim \data$
\STATE $\loss \leftarrow$ \textsc{ComputeLoss($\direction, \model, \batch$)}
\STATE $\direction \leftarrow \direction - \eta \nabla_{\direction}\loss$
\STATE $\direction \leftarrow \direction/||\direction||_2$
\ENDWHILE
\end{algorithmic}
\vspace{1em}
\begin{algorithmic}[1]
\STATE \textbf{function} \textsc{ComputeLoss}($\direction, \model, \batch$)
\STATE \hspace*{1em} $p_{\text{harm}}, p_{\text{safe}}, t_{\text{answer}}, t_{\text{refusal}}, t_{\text{retain}} = B$
\STATE \hspace*{1em} $\loss_{\text{ablation}} = \celoss(\model_{\text{ablate}(\direction)}(\harmfulinstruction), \harmfultarget)$
\STATE \hspace*{1em} $\loss_{\text{addition}} = \celoss(\model_{\text{add}(\alpha\hat{\direction}, l_{\textnormal{add}})}(\harmlessinstruction), \harmlesstarget)$
\STATE \hspace*{1em} $\loss_{\text{retain}} = \klloss(\model_{\text{ablate}(\direction)}(\harmlessinstruction), \model(\harmlessinstruction), \retaintarget)$
\STATE \hspace*{1em} $\loss = \lambda_{\text{abl}} \loss_{\text{ablation}} + \lambda_{\text{add}}\loss_{\text{addition}} + \lambda_{\text{ret}}\loss_{\text{retain}}$
\STATE \hspace*{1em} \textbf{return} $\loss$\
\end{algorithmic}
