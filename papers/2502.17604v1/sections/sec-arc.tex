\section{Architecture}

For our efforts, we have chosen the Cosmos Network\cite{kwon2019cosmos} as our network of choice for smart contracts. Within the Cosmos network, smart contracts are like programmable gears driving communication and transactions between different blockchains. These contracts act like autonomous robots, following pre-defined instructions without anyone needing to constantly pull the levers. They're crucial for the whole system to work smoothly.

To build and run these robot gears, Cosmos has two handy tools: CosmWASM \footnote{https://github.com/CosmWasm/wasmd} and Ethermint \footnote{https://docs.ethermint.zone}. CosmWASM is like a custom Lego set for developers, letting them build all sorts of different contracts from scratch. Ethermint, on the other hand, acts as an adapter, allowing developers to use code already built for the Ethereum blockchain with Cosmos.

In this paper we use CosmWASM, the native Cosmos smart contract support, as our infrastructure for executing the smart contracts.

\subsection{CosmWASM}

CosmWASM is a specialized platform for building smart contracts within the Cosmos blockchain ecosystem. It uses WebAssembly (WASM) as its engine, allowing developers to write performant and secure contracts. A strength of this is language portability. This "language agnostic" design gives the flexibility and choice. Plus, it runs the contracts in a safe virtual machine sandbox, so everything scales nicely if the project explodes in popularity. That makes CosmWASM ideal for crafting smart contracts that are both speedy and able to handle a ton of activity.

Ethermint acts as a bridge between the Cosmos ecosystem and Ethereum's smart contract playground. It's like a translator that lets existing Ethereum contracts seamlessly join the Cosmos party without needing a complete makeover. This fusion leverages Cosmos's speedy transaction engine, while keeping things modular like the Cosmos SDK, giving developers plenty of building blocks to play with.

The utilization of these smart contract platforms is broad. In decentralized finance (DeFi), both CosmWASM and Ethermint prove invaluable. Ethermint's Ethereum compatibility simplifies the transfer of existing Ethereum DeFi initiatives to Cosmos.

For applications involving non-fungible tokens and tokenization, CosmWASM's robust and secure framework is well-suited. Additionally, in areas like supply chain and logistics management, the automation features of smart contracts become beneficial, with both CosmWASM and Ethermint providing appropriate tools for these sectors.

\subsection{WebAssembly (WASM)}

Introduced by the W3C in 2015, WebAssembly (WASM) is a project aimed at creating a standardized, high-performance, and secure machine-independent bytecode. It achieves safety through distinct, isolated memory regions: the stack, global variables, and a linear memory area, accessed via type-safe instructions for assured memory safety during native code compilation. WASM's architecture, incorporating capability-based security, ensures both performance and security, managing operating system resources like networking and threading through stringent security protocols.

In edge computing, WASM's architecture is crucial for fast, secure processing. By eliminating risky features while supporting C/C++ compatibility, WASM addresses numerous technological challenges. A prime example is the automotive industry's supply chain fragility, where increasing demands for features clash with the impracticality of adding more microprocessor-based control units. WASM enables automotive manufacturers to share physical hardware, reducing microprocessor demand and manufacturing costs by simplifying hardware requirements. This software-centric approach allows manufacturers to focus on advances in automation, infotainment, and safety, without supply chain concerns.

Edge computing, particularly applications requiring autonomous computing and distributed collaboration at network edge, benefits from WASM. These applications require low latency, a challenge for cloud computing. Edge computing, by processing data locally, overcomes issues of network latency and connectivity, ensuring timely data availability.

\subsection{WASMEdge}

WASMEdge facilitates the deployment of WebAssembly\cite{WebAssembly-2024-01-02} (WASM) in edge computing environments. It allows for the integration of serverless functions, which are WASM executable, into various software platforms. Notably, WASMEdge is versatile in its application, being usable at the edge of cloud networks, serving as an API endpoint in a Function as a Service (FaaS) model, operating within Node command line interfaces, and even within embedded systems  \cite{WebAssembly-2024-01-02}.

Artificial Intelligence (AI) advancements, Natural Language Processing (NLP), and machine learning (ML) are important fields of research and use. Before we get into ML implementation with WASMEdge, let's go over some basic knowledge.

TensorFlow Lite runs on WASMEdge and is optimized for embedded systems. It makes on-device machine learning easier. By removing server communication, this method protects data privacy and helps to prevent network latency and connectivity problems.

% \textbf{Understanding the core components:}

% \textit{GraphDef Documents}: These files, which are essential to model data, provide a legible format for your graph's structure to other processes. They come in binary (.pb) and text (.pbtx) formats, with different readability and verbosity levels.

% \textit{Checkpoint Files}: Using no structural data, these files store serialized variables from a TensorFlow network that represent the state of the variables at various training stages.

% \textit{Frozen Graph}: This is made by combining a GraphDef file with the most recent Checkpoint file, then "freezing" (turning variables into constants).

% \textit{TFLite, or TensorFlow Lite}: TFLite is a condensed, memory-efficient variant of TensorFlow that requires less code and dependencies and is optimized for smaller devices. It makes data reading easier by using flat buffers rather than protobufs and does not require object deserialization.

\subsection{WebAssembly Binary}

The interface between WebAssembly (WASM) and the operating system is facilitated by the WebAssembly System Interface (WASI) \cite{clark2019standardizing}. The interface is standardized and resembles POSIX, with an emphasis on cross-platform compatibility and ease of use. Because of this, it can be used in Trusted Execution contexts (TEEs), edge devices, and Internet of Things contexts. WASM applications may access file systems, networks, and other OS services thanks to WASI, which has 46 functionalities. POSIX calls can be effectively converted into WASI calls by languages like C and Rust. 

Additionally, WASI uses a capability-based security paradigm, which establishes a sandbox environment by requiring WASM runtime to approve resource access. By creating an intermediary layer and restricting applications to particular file system components, it improves security.

For our framework we use WASMEdge since it is the fastest WASM virtual machine available at the moment \cite{zheng2020vm,WebAssembly-2024-01-02}. We explain the high level architecture of \sln{} as shown in Fig. \ref{fig-overallarchi}.

\begin{figure*}%[h!]
	\centering
	\includegraphics[height=4cm, width=6cm]{sections/fig/archi2.jpg}
	\caption{Overview of \sln{}.}   
	\label{fig-overallarchi}
\end{figure*}

For the contract, we have taken a simple name service sample code from Cosmos SDK and have modified it to pass a prespecified input dynamically created using the name lookup as an input prompt to the AI or LLM inference engine. Here for our AI or LLM inference engine we have chosen WASMEdge. Once the smart contract has been executed successfully, the lookup value is passed as a rust system call to WASMedge.

