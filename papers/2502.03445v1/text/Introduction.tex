\section{Introduction}

Quantum Computing (QC) presents itself as a promising alternative to traditional classical computing.
Various quantum algorithms offer potential runtime benefits compared to the best-known classical counterparts,
notably in unstructured database searches~\cite{grover1996fast},
optimization tasks~\cite{moll2018quantum} and integer factorization~\cite{shor1999polynomial}.
In practice, researchers design a quantum algorithm as an $n$-qubit quantum circuit.
A single QPU then repeatedly executes this circuit,
measuring its output as binary strings.
The output binary strings then manifest as a binary state probability distribution,
where solution states are distinguished by significantly higher quantum state amplitudes compared to non-solution states.
Accurate QPU execution and measurement are critical,
requiring a sufficient number of trials.

However, QPUs must satisfy highly demanding size and quality requirements to reliably run useful benchmarks.
First, a QPU must have at least $n$ qubits to even run an $n$-qubit circuit at all.
Furthermore, these $n$ qubits must be accurate and robust enough to support the quantum workload without accumulating too much noise to produce quality solutions.
Unfortunately, these two requirements put a heavy toll on the hardware.
As an example, the famous Shor's integer factorization algorithm requires millions of physical qubits to construct enough logical qubits to run problems at practical scales~\cite{suchara2013comparing}.

Currently, classical scientific and industrial workloads predominantly operate in parallel,
moving away from dependency on a single, powerful core.
Classical parallel computing harnesses data and model parallelism~\cite{shoeybi2019megatron,huang2019gpipe},
involving the distribution of classical data across multiple computing units.
For example, classical simulations of quantum circuits and systems usually use large supercomputers~\cite{liu2021closing} with millions of cores.
Similarly, numerous machine learning applications, like AlphaFold~\cite{jumper2021highly},
leverage hundreds of GPUs to manage complex computations efficiently.

Although the concept of divide and conquer is straightforward,
QC introduces distinct challenges.
The quantum no-cloning theorem~\cite{wootters1982single} prohibits the duplication of quantum data,
rendering traditional classical strategies like divide and conquer inapplicable to QC.
However, the development of quantum circuit cutting theory~\cite{peng2020simulating}
and its practical implementations~\cite{tang2021cutqc} have paved the way for distributing large quantum circuits across multiple QPUs.
This method relies on classical co-processing to handle the division effectively without copying quantum data.

Circuit cutting involves three stages.
First, circuit cutting cuts a large quantum circuit into several smaller subcircuits.
A distributed set of less powerful QPUs then run the subcircuits in parallel.
Classical co-processing then reconstructs the complete output from these small subcircuits without ever copying quantum data across QPUs.
This is analogous to classical parallel computing,
which distributes a large workload among less powerful computing units at the expense of communication and reconstruction costs.
Section~\ref{sec:background} explains in more details.

Dividing a large quantum circuit into smaller subcircuits offers significant benefits compared to using a single, large QPU.
Firstly, these subcircuits require fewer qubits, which alleviates the stringent size constraints on QPUs.
For instance, some algorithms demonstrated the capability to operate with fewer than half the number of qubits typically necessary~\cite{tang2021cutqc}.
Secondly, the reduced number of quantum gates in subcircuits lessens the demand for high qubit quality,
enhancing the accuracy of the outcomes.
The simpler, shallower architecture of subcircuits results in reduced crosstalk~\cite{mundada2019suppression},
decoherence~\cite{klimov2018fluctuations},
gate errors~\cite{arute2019quantum} and control challenges~\cite{abdelhafez2020universal}.
Overall, quantum circuit cutting leverages both modest QPUs and classical computing resources to facilitate DHQC effectively.

Hybrid and distributed architectures are poised to become the standard framework for future quantum computing,
thanks to their promising advantages.
Indeed, IBM has announced plans to base its quantum systems on these techniques,
considering circuit cutting a cornerstone of practical quantum computing~\cite{bravyi2022future}.
Despite the commercial interest and the encouraging results from preliminary works,
several fundamental challenges limit the scalability of quantum circuit cutting:
\begin{enumerate}
   \item The classical co-processing overhead increases exponentially with the number of cuts to split a quantum circuit.
   Realistic benchmarks require multiple cuts and the computational overhead quickly becomes intractable.

   % \emph{Solution:} Section~\ref{sec:post_processing} discusses how incorporating advanced tensor network methods significantly reduces runtime,
   % offering an exponential advantage over existing parallelization techniques.
   \item Classically reconstructing the full binary state probability distribution scales exponentially with the number of qubits as $2^n$.
   \item Identifying cuts for arbitrary quantum circuits to reduce the hybrid computation cost while being subject to hardware constraints
   reduces to an NP-complete graph partition problem~\cite{karypis1998fast}.
   
   % \emph{Solution:} Section~\ref{sec:cost_model} introduces metrics that evaluate both quantum and classical costs involved in distributed quantum computing,
   % guiding the selection of cuts for any quantum circuit.
   % Furthermore, Section~\ref{sec:locate_cuts} outlines constrained graph partitioning heuristics that leverage the hybrid cost model to rapidly identify high-quality cuts.
\end{enumerate}

This paper presents \emph{tensor network contraction},
\emph{heavy state selection},
and \emph{constrained graph partitioning heuristics}
to tackle these challenges.
We ran several realistic quantum benchmark algorithms such as QAOA~\cite{saleem2020approaches},
AQFT~\cite{barenco1996approximate},
Supremacy~\cite{arute2019quantum}, W-state~\cite{dur2000three, diker2016deterministic}, and GHZ~\cite{greenberger1989going} to evaluate the performance of TensorQC.
Our contributions include the following:
\begin{enumerate}
   \item TensorQC paves the way towards scalable distributed QC.
   Our experiments run quantum circuits of up to $200$ qubits using QPUs available nowadays and a single GPU.
   These benchmarks are otherwise intractable using classical simulations, single-QPU or even existing circuit cutting techniques.
   \item TensorQC pioneers the development of versatile distributed quantum architectures.
   This paper showcases a diverse array of benchmarks,
   including circuits characterized by high connectivity and entanglement,
   highlighting the broad applicability and robustness of the technology.
   \item TensorQC unlocks new possibilities for executing large-scale quantum applications.
   This paper integrates cutting-edge classical computing methods from tensor networks with medium-scale QPUs.
   This fusion demonstrates that circuit cutting techniques represent a promising approach to scale up quantum computation systems.
\end{enumerate}

The rest of the paper is organized as follows:
Section~\ref{sec:background} explains the circuit cutting process and its challenges.
Section~\ref{sec:co_processing} introduces tensor networks,
establishes using tensor network contractions for DHQC co-processing,
and proves its exponential runtime advantage over prior parallelization techniques.
Section~\ref{sec:heavy_state_selection} develops an automatic state selection protocol to only retain the significant binary states.
Section~\ref{sec:cost_model} designs a hybrid cost model to capture the combined quantum and classical runtime costs to execute a quantum circuit.
Section~\ref{sec:locate_cuts} presents graph partition heuristics to identify high-quality cuts quickly based on the hybrid cost model.
Section~\ref{sec:methodology} sets up the experiment methodology, and Section~\ref{sec:results} presents the results.
Lastly, Sections~\ref{sec:related_work},~\ref{sec:conclusion} present related works and conclusions.