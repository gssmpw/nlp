\subsection{Fidelity on Real Device}
\begin{figure}[t]
    \centering
    \includegraphics[width=.85\linewidth]{figures/fidelity.pdf}
    \caption{Fidelity comparison of cut versus uncut on the $27$-qubit $IBM\_Montreal$ QPU.
    Figure shows the error obtained via cutting as a percentage of that of uncut.
    Each data point is the average of $3$ trials.
    $Regular$ benchmark experiences error reduction of nearly $60\%$.
    $GHZ$ has $15\%$ and $W\_state$ has $30\%$ reductions.}
    \label{fig:fidelity}
\end{figure}

TensorQC generally produces more accurate results than without cutting.
Figure~\ref{fig:fidelity} cuts and runs several benchmarks at various sizes on the $27$-qubit IBM Montreal QPU.
TensorQC uses at most $10$-qubit subcircuits.
The same set of benchmarks also run as is without cutting on the same IBM QPU.
Classical simulation then produces the ground truth to verify both types of outputs.

The accuracy comparison is quantified by the relative error of TensorQC as a percentage of that of uncut.
Specifically, we compute
\begin{equation*}
    \frac{e(\textrm{TensorQC},\textrm{Ground Truth})}{e(\textrm{Uncut},\textrm{Ground Truth})}
\end{equation*}
where $e$ is the MSE defined in Equation~\ref{eq:mse}.

Figure~\ref{fig:fidelity} shows that the accuracy of the various benchmarks improved under cutting.
This is likely due to the fact that TensorQC replaces the noisy quantum links with noiseless classical post-processing at key locations.
In addition, QPUs produce more accurate results for the small subcircuits than the large uncut circuits.
This is due to a myriad of software and hardware factors including compiler performance, crosstalk and decoherence.
Since QPU noise is the only source of error in TensorQC,
smaller QPU burden is generally favored to produce more accurate overall results.