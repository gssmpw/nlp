% \section{Background and the Problem}

\section{Problem Formulation}
\label{problem_definition}
A typical workflow of \nlvis tasks involves assembling queries along with tabular data as input, and automatically generating code based on established visualization libraries (\emph{e.g.}, Matplotlib~\cite{barrett2005matplotlib}, Seaborn~\cite{seaborn}) to be executed in a sandboxed environment to obtain the final chart image. 
However, directly generating visualization code often leads to errors due to the complexity of visualization requirements and the semantic gap between natural language and programming constructs.

Following previous works~\cite{nvBench_SIGMOD21,automated}, we introduce \textit{Visualization Query Language} (VQL) as an intermediate representation that bridges natural language queries and visualization code. 
As exemplified below, VQL combines SQL-like syntax for data operations with visualization-specific constructs (\emph{i.e.}, VisType and Binning), making the generation process more controllable and reliable while maintaining simplicity in structure.
\begin{tcolorbox}[sharp corners, colframe=black, colback=white, boxrule=0.5mm, left=1mm, right=1mm, top=1mm, bottom=1mm]
\footnotesize
VisType: \texttt{VISUALIZE \textit{\textcolor{brown}{BAR}}}\\
Data:    \texttt{SELECT \textit{\textcolor{brown}{Date\_Stored, COUNT(Document\_ID)}}} 
\texttt{FROM \textit{\textcolor{brown}{ALL\_Documents}}} \texttt{GROUP BY \textit{\textcolor{brown}{Date\_Stored}}}\\
Binning: \texttt{BIN \textit{\textcolor{brown}{Date\_Stored}} BY \textit{\textcolor{brown}{WEEKDAY}}}
\end{tcolorbox}
% % \vspace{1em}
% \fbox{%         
% \small
% \begin{minipage}{0.22\linewidth}
% VisType:\\
% Data-\\
% Components:\\
% \\
% Binning:
% \end{minipage}%         
% \begin{minipage}{0.78\linewidth}
% % \small
% \texttt{VISUALIZE \textit{\textcolor{brown}{BAR}}}\\
% \texttt{SELECT \textit{\textcolor{brown}{Date\_Stored,COUNT(Document\_ID)}}}\\
% \texttt{FROM \textit{\textcolor{brown}{ALL\_Documents}}}\\
% \texttt{GROUP BY \textit{\textcolor{brown}{Date\_Stored}}}\\
% \texttt{BIN \textit{\textcolor{brown}{Date\_Stored}} BY \textit{\textcolor{brown}{WEEKDAY}}}
% \end{minipage}%     
% } 
% \vspace{0.5em}

Formally, given a natural language query $q$ about a database schema $S$ comprising multiple tables $T$ and columns $C$, the objective of \nlvis is to generate a visualization query $v$ as an intermediate step, which is then translated into a visualization $V$ that accurately represents the data in $S$ to answer the user's query. 

\begin{figure*}[!ht]
	\centering
    % \setlength{\belowcaptionskip}{-1em}   %调整图片标题与下文距离
	\includegraphics[width=0.98\linewidth,scale=1.0]
    {./figure/pipeline.pdf}
    % \vspace{-0.5em}
	\caption{The overall pipeline of \system. We recommend a \textbf{\textit{``Zoom in''}} to view its detailed design:
    % This collaborative agent-based workflow transforms natural language queries into visual representations through three main stages: 
    \textbf{(1)} The \textit{processor} agent performs schema filtering and context augmentation; \textbf{(2)} The \textit{composer} agent generates structured VQL representations through sketch-and-fill reasoning; \textbf{(3)} The \textit{validator} agent ensures visualization correctness via iterations of execution-guided validation and error-based refinement.}
    \vspace{-1em}
\label{fig: overview}
\end{figure*}

\section{\system: Our Approach}
\label{approach}
\subsection{An Overview}
Figure~\ref{fig: overview} shows an overview of \system, which is composed of three specialized agents: \textit{processor}, \textit{composer}, and \textit{validator}, working collaboratively to transform natural language queries into accurate visualizations.
% Our approach breaks down the \nlvis process into several steps, which is described in Algorithm~\ref{algorithm}.
Starting with a user query $q$ and schema $S$, our approach first leverages the \textit{processor} to filter schema $S'$ and generate additional context including augmented explanation and query complexity classification. The \textit{composer} then generates a VQL query as an intermediate representation through reasoning step by step. Finally, the \textit{validator} ensures correctness via iterative validation and refinement until a valid visualization is produced.


% The Processor Agent (cf. Sec.~\ref{processor}) processes the natural language query and database schema, producing a filtered schema and supplementary information essential for subsequent processing. The Composer Agent (cf. Sec.~\ref{Composer}) transforms this refined input into a Visualization Query Language (VQL) representation. Finally, our novel Validator Agent (cf. Sec.~\ref{validator}) validates and iteratively refines the generated VQL, translating it to executable code that yields the final visualization. This multi-stage approach ensures a thorough and accurate transformation from natural language queries to visual representations, maximizing the fidelity and relevance of the output.


\subsection{Processor Agent} 
\label{processor}

To handle massive data and complex queries effectively, we design a \textit{processor} agent that prepares and enriches input data. 
% Specifically, as shown in Figure~\ref{fig: overview} and prompt example in Appendix~\ref{processor_prompt},it performs four operations:
Specifically, the \textit{processor} agent consists of four steps:

\paragraph{Database Description.}
The \textit{processor} first constructs a comprehensive database description, which includes table and column schemas, with representative value examples. This provides the foundation for LLMs to understand the data structure and relationships. 
For instance, when processing a \textit{``Products''} table, it extracts column details like \textit{``product\_id''}, and \textit{``product\_category''}, along with their value examples (\emph{e.g.}, \textit{``Chocolate''}, \textit{``Book''}).

\paragraph{Schema Filtering.}
Subsequently, building on this foundation, the agent performs schema filtering to identify and extract tables and columns relevant to the user query (\emph{e.g.}, filtering out unrelated columns like \textit{``product\_category''}), effectively reducing noise and preventing information overload.


\paragraph{Explanation Augmentation.}
To enable more accurate query interpretation, inspired by the self-augmented strategy~\cite{augment}, the \textit{processor} generates augmented explanations for the filtered schema like \textit{``Key points: (1) product\_id in the table Products serves as a foreign key linking to the table Complaints''}. These explanations bring insights that provide additional context about table relationships and column semantics. 

\paragraph{Query Classification.}
Finally, the agent classifies query complexity as either \textit{single} or \textit{multiple} based on the number of tables involved and the operations required. This classification guides subsequent agents in choosing appropriate strategies (\emph{e.g.}, the \textit{multiple} scenario requires join operations across tables or complex aggregations).

By providing a focused, well-explained schema and classification, the \textit{processor} agent establishes a strong foundation of complex data understanding for the subsequent stages in our framework.


\subsection{Composer Agent} 
\label{Composer}

The \textit{composer} agent is designed to bridge the gap between natural language queries and visualization code, generating structured VQL queries through a step-by-step reasoning approach. 

\paragraph{Strategy Decision.}
Based on the query classification from the \textit{processor} agent, different strategies are adopted to plan the visualization generation. For example, \textit{single} queries focus on basic aggregations, while \textit{multiple} scenarios require more complex join operations.

\paragraph{Chain-of-Thought Reasoning.}
During the generation stage, the \textit{composer} agent employs a chain-of-thought~\cite{wei2022chain} approach to break down the visualization process into manageable steps. This approach is complemented by providing few-shot examples for In-Context Learning, enhancing the model's adaptability to diverse query types.

\paragraph{Sketch-and-Fill Process.}
The reasoning process follows the \textit{``sketch-and-fill''} paradigm and is structured into three steps, including sketch construction, data components filling, and final VQL composition (prompt shown in Appendix~\ref{prompt_details}).

Taking the query \textit{``List the name of all products along with the number of complaints that they have received in a bar chart.''} (shown in Figure~\ref{fig: overview}) as an example, the \textit{composer} initially determines the specific elements (\emph{i.e.}, visualization type \textit{``Bar''}) and constructs a VQL sketch (\emph{e.g.}, \texttt{``Visualize bar SELECT \_, COUNT(\_) FROM \_ JOIN \_ ON \_''}). Subsequently, it fills the data components (\emph{e.g.}, the column \textit{``product\_name''} ) into the sketch and then combines them to produce the complete VQL query.




\subsection{Validator Agent} 
\label{validator}

The \textit{validator} agent ensures the accuracy and executability of generated VQL queries through an iterative execution-guided validation and error-based refinement process.

\paragraph{Translation and Execution.} 
When receiving a VQL representation, the \textit{validator} first translates the query into executable Python code using visualization libraries like \textit{``Matplotlib''}. The generated code is then executed in a sandboxed environment, where the agent captures either successful execution results or potential error messages.

\paragraph{Pass or Error.} During the execution phase, the \textit{validator} monitors the return information from the execution environment. If successful, it renders and returns the final visualization; otherwise, if errors occur (\emph{e.g.}, syntax errors, or invalid column names), the agent captures specific error messages and routes them back to the \textit{composer} agent, triggering the refinement process.

% As illustrated in Figure~\ref{fig: overview}(c), when the \textit{validator} translates the VQL query \texttt{``VISUALIZE bar ... ON t1.product\_id = t2.product\_id''} into Python code and executes, it encounters an error message \textit{``lack a `group by' clause''}. This error message is then sent back to the \textit{composer} agent, which refines the VQL query by adding \texttt{``GROUP BY product\_name''} to ensure proper data aggregation.

As shown in Figure~\ref{fig: overview}(c), when the \textit{validator} translates the VQL query \texttt{``VISUALIZE bar ... ON t1.product\_id = t2.product\_id''} into Python code and executes it, an error message \textit{``missing `GROUP BY' clause''} is encountered. This error is then communicated back to the \textit{composer} agent, which refines the VQL query by adding \texttt{``GROUP BY product\_name''} to ensure proper data aggregation.


\paragraph{Iterative Refinement.}
The \textit{composer} agent iteratively refines its output based on feedback from the \textit{validator} agent until a valid visualization is produced. If any errors are detected during validation, it receives error information and adjusts its output accordingly, ensuring the final VQL query is correct. Notably, we design the system to refine VQL query instead of Python code due to its simpler syntax for better correction.

