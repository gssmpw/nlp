%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONCLUSION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Conclusion}\label{sec:conl}


This paper contributed with NPB-Rust, a Rust-based benchmark suite designed to represent intensive arithmetic tasks and complex scientific applications in Rust. Along with a sequential version, we developed a parallel implementation using the Rayon library. We conducted a performance evaluation focusing on execution time, scalability, speedup, memory consumption, and programmability. This analysis compared the sequential and parallel implementations of NPB-Rust with the NPB versions in Fortran and C++, both parallelized with the OpenMP framework. Rust has been demonstrated to be suitable for expressing NPB applications, but it required unsafe Rust to achieve better performance on irregular parallelism scenarios and for other specific optimizations. When testing our hypothesis, we found that Rust outperformed C++ in the sequential code but was slower than Fortran. Therefore, we tested the NPB-Rust, and it showed reliable performance. Although Rayon presented a competitive performance with OpenMP in most of the cases and also provides the benefit of memory safety, experimental results and hypothesis test indicates that Rayon was slower overall in the NPB suite. Thus, there are opportunities for exploring different parallelism methodologies to achieve better parallelism exploitation with Rust in the future. We plan to continually enhance the NPB-Rust suite by implementing it with other Rust parallel programming interfaces and experimenting with other parallel architectures over different workloads.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
