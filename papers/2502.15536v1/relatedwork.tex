\section{Related Work}
\label{sec:rw}
\textbf{Rust performance.} Over the past decade, studies have investigated the applicability of Rust for HPC, aiming to achieve safety without compromising performance. Rust with CUDA for general-purpose GPU programming was compared to C++ in matrix multiplication and array copying \cite{rw_tes}. The findings indicated that Rust provides competitive performance compared to C++, with minimal reliance on unsafe code. The performance of Rust's data structures, including HashMap and binary tree, and simple algorithms like merge sort and insertion sort, was also compared to C++ \cite{rw_isfast}. Results demonstrate that dictionary operations and insertion sort are faster in C++, while Rust outperforms C++ in merge sort. The N-body problem was implemented in Rust with Rayon to compare its MFLOPS performance against C with OpenMP \cite{rw_pervsprog}. The results show that C outperformed Rust when using single-precision operations due to more efficient mathematical optimizations during assembly generation. However, when using double precision, Rust's performance was similar to C's. Considering the simplicity of the benchmarks tested in these works within the HPC context, further analysis could be extended with more complex applications, such as the NPB.

\textbf{Benchmarks.} The applications from the Problem-Based Benchmark Suite (PBBS) \cite{pbbs_c} were ported from C++ to Rust \cite{rw_zerocost}. The study focused on examining Rust's capabilities in handling regular and irregular parallelism and evaluating the impact of using unsafe. Rust performed slightly better in the sequential version, while C++ with OpenMP outperformed Rust with Rayon. They highlight Rust's ability to handle read-only and regular parallelism, but when dealing with irregular parallelism, unsafe was often necessary to avoid runtime overheads. Still, the NPB is distinguished by its focus on intensive arithmetic tasks and complex scientific applications derived from CFD. The researchers in \cite{PIEPER:COLA:21} created a benchmark to perform a set of experiments in stream processing and data-parallel Rust applications. They compared different Rust parallel programming interfaces and assessed their parallelism performance. In contrast, we focus on more robust NPB applications and compare them with Fortran and C++.

\textbf{NPB in prior works.} The NPB has been widely used for benchmarking different programming languages, frameworks, and parallel programming strategies. In this work, we leverage NPB-CPP \cite{NPB-CPP-2021}, though many other variants exist, such as NPB-MPJ \cite{NPB-MPJ}, which utilizes Java's message-passing interfaces. The NPB suite is frequently employed to evaluate GPU frameworks for parallelism. A Python version was implemented based on the NPB-CPP to test the Numba environment for CUDA \cite{NPB-PY}. Other implementations have been proposed for OpenCL \cite{npb-opencl} and evaluated against the original OpenMP parallel version. The NPB also has independent versions for OpenACC \cite{npb-openacc} and CUDA \cite{NPB-CUDA}. New implementations of varying parallelism strategies and frameworks often emerge. Therefore, NPB-Rust holds significant value for the research community, enabling Rust to be included in future evaluations.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%\subsection{Unsafe Languages Portability to Rust}
%How Do Programmers Use Unsafe Rust? -> https://dl.acm.org/doi/pdf/10.1145/3428204

%Translating C to Safer Rust -> https://dl.acm.org/doi/pdf/10.1145/3485498

%\subsection{NAS Parallel Benchmarks in Prior Works}

%\cite{NPB-CPP-2021} has
%https://www.sciencedirect.com/science/article/pii/S0167739X21002831

%The NAS Parallel Benchmarks 2.0 -> https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=506a03b7ae92d87c61d840fc74130e5cf9e1a8a2