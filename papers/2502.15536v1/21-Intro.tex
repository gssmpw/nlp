%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%% INTRODUCTION %%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
Parallel computing has become a mainstream approach in modern computational systems. With the near end of Moore's Law and the physical constraints on further increasing clock speeds, improvements in single-threaded performance have plateaued. Since multi-core platforms dominate contemporary hardware, developers gradually rely on parallel programming features to effectively tackle complex computational challenges \cite{book_clock}. However, harnessing the power of these architectures introduces significant complexity. Programmers must thoroughly understand the problem and the programming models while navigating obstacles such as data synchronization, load balancing, and communication overhead \cite{book_introduction}. As new frameworks and domain-specific languages for parallelism constantly emerge, selecting the best parallel programming interface can be challenging. Therefore, benchmark applications are crucial for evaluating performance and expressiveness.

Fortran and C/C++ are well-established languages in high-performance computing (HPC). From early message-passing interfaces to modern GPU computing frameworks, they have served as the foundation for developing parallel programming paradigms and abstractions \cite{amaral2020programming, alrawais2021parallel}. Research initiatives tried to improve it with Rust, a modern, promising low-level language designed to offer memory safety and speed. It empowers programmers to write high-level and expressive code without sacrificing performance or fine control over system resources \cite{rustbook}. Memory access complications such as use-after-free, buffer overflows, or data races are common causes of software issues \cite{membug2camb, membug3narure}. As such, Rust stands as an attractive solution for developers. Its ownership-based system allows the compiler to detect data race problems at compile time, ensuring safe memory access without using garbage collection \cite{rustbook}. Considering the growing demand for high performance and Rust's safety guarantees, the HPC community has been investigating its applicability in the area \cite{PIEPER:COLA:21}. Thus, exploring parallelism in Rust remains a prominent open research topic. 

As Rust's ecosystem and parallel capabilities evolve, representative benchmark suites remain essential and will continue to be valuable for the long term. To the best of our knowledge, we have observed a lack of comprehensive benchmarks representing intensive arithmetic tasks and complex scientific applications in Rust (see Section~\ref{sec:rw}). In the wide-ranging landscape of benchmark implementations, the NAS Parallel Benchmarks (NPB) \cite{NPBOriginal1} is among the most renowned suites in the research community. NASA's Numerical Aerodynamic Simulation Program developed the NPB to provide an objective standard for measuring and comparing the performance of highly parallel supercomputers. It includes five kernels (EP, CG, FT, IS, and MG) and three pseudo-applications (BT, SP, and LU), predominantly implemented in Fortran, except for the IS kernel, which was written in C. The suite is available in different versions, including the sequential code and parallel approaches using OpenMP \cite{nasomp} and MPI \cite{NPB-2.0}. Recognizing NPB's relevance, several independent adaptations of the NPB were proposed, including versions for clusters, GPUs, and different programming languages \cite{NPB-CPP-2021, NPB-MPJ, NPB-PY, NPB-CUDA, npb-opencl, npb-openacc}. For instance, the NPB-CPP \cite{NPB-CPP-2021} is a C++-adapted version of the suite. 

We have two goals with this paper: (1) to develop NPB-Rust benchmark so that other developers can test their Rust solutions; and (2) to evaluate Rust performance using NPB-Rust. To that end, we begin by describing the porting methodology used in NPB-Rust's implementation, offering insights for translating code from other languages to Rust. We also provide an in-depth analysis of the challenges of parallel programming in Rust within the NPB context. Since Rayon stands out as the go-to standard for achieving data parallelism in Rust \cite{PIEPER:COLA:21}, we implement it as the parallel programming interface. Then, we perform hypothesis tests to evaluate the performance of sequential and parallel algorithms in NPB-Rust. Finally, 
%
%To that end, we start describing the porting methodology applied in NPB-Rust's implementation and offering valuable insights when translating code from other programming languages to Rust, along with an in-depth analysis of the challenges of parallel programming in Rust.
our contributions are:
\begin{enumerate}
    \item An analysis of the Rust language for expressing scientific applications in NPB.
    \item A performance analysis of Rust compared to Fortran and C++ in NPB serial codes.
    \item A performance analysis of Rayon compared to OpenMP in NPB parallel codes.
    \item A new benchmark suite of NPB written in Rust. The source code is available on GitHub\footnote{The source code is available: https://github.com/GMAP/NPB-Rust.}.
    %\item A new benchmark suite of NPB written in Rust. The source code will be made available in GitHub\footnote{omitted for blind review}.
\end{enumerate}

% Our research seeks to answer the following question: Does the Rust language provide sufficient performance and expressiveness for the NPB algorithms? To answer this question, we will test the following hypotheses: 1) The Rust language enables the expression of sequential algorithms for NPB with equal performance to Fortran/C++; and 2) The Rayon framework enables the expression of parallel algorithms for NPB with equal performance to OpenMP.

% To test our hypotheses, we start by presenting a sequential version of the NPB in Rust and a parallel implementation utilizing the Rayon library \cite{rayon}. We emphasize the methodology applied in the NPB-Rust implementation, and we test our hypotheses by comparing the performance of NPB-Rust against both NPB and NPB-CPP, including parallel versions.
%Since Rayon stands out as the go-to standard for achieving data parallelism in Rust, a careful comparison of the parallelized NPB-Rust with Rayon against the NPB and NPB-CPP implementations using OpenMP is provided. 
% We also aim to offer valuable insights when translating code from other programming languages to Rust, along with an in-depth analysis of the challenges of parallel programming in Rust. Finally, the source code for NPB-Rust will be available in a GitHub repository\footnote{ommitted for blind review}.

Section \ref{sec:back} gives a background in Rust features and outlines the NPB suite proprieties. In section \ref{sec:npb-rust-implementation}, the porting process for both sequential and parallel versions of the NPB-Rust is detailed. Section \ref{sec:expdisc} contains the experiments and results discussion. In Section \ref{sec:rw}, we make an overview of the related work and finalize with the conclusion in Section \ref{sec:conl}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
