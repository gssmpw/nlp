\section{Discussion}

\noindent \textbf{On complete test process automation} -- Perhaps the most significant finding from this case study is that our recipe is capable of completely automating a real world test process. Put simply, SPAPI testing -- a process that currently takes 2-3 FTEs -- has effectively been substituted by SPAPI-Tester, a fully automatic pipeline. 
This success stems from combining LLMs with conventional automation, allowing SPAPI testing to proceed without human intervention. Key to this achievement is the nature of the SPAPI test process: it is well-structured, decomposable, and requires human judgment but not creativity. 
In such cases, LLMs serve as the critical link to full automation by systematically replacing manual steps. Maintaining the existing process structure further aids automation in two ways. First, it defines clear, verifiable steps where LLMs can be applied.
Second, preserving the status quo ensures that automation is achievable without imposing possibly unreasonable costs of changing the test process -- an observation that is crucial for real world application. 


\noindent \textbf{On the generality of LLMs as problem solvers} -- Preserving the design of the process no doubt identifies discrete tasks where LLMs can be used. However, the clear enabler for complete automation is that the LLM automates all manual tasks with little practical regard to the actual nature of the task. 
Alternative automation methods exist, such as using fuzzy matching for inconsistent key-value mappings or a formal language to specify cardinality in key-value relationships. However, LLMs, as general problem solvers, eliminate the need for multiple specialized solutions, simplifying real-world implementations. 
While there is a cost to recast an LLM to solve a specific problem -- like defining prompts or signatures -- the cost turns out to be manageable. 


\noindent \textbf{On implications on dependent processes} -- If SPAPI testing can be fully automated, its impact on adjacent processes becomes a natural consideration. API implementation directly precedes SPAPI testing, while integration within user-facing subsystems follows it. Given SPAPI’s simplicity, LLMs could potentially automate these dependent processes, extending automation across much of the development lifecycle—an important step for in-vehicle software engineering. Further, automating SPAPI-dependent applications could create a cascade of fully automated lifecycles, reshaping automotive software development.
While promising, this vision comes with challenges. Our results demonstrate LLMs’ ability to automate well-defined tasks and connect dependent processes, but also highlight the effort required to adapt them for specific, verifiable problems. These insights encourage further exploration toward realizing this ambitious potential. 


\noindent \textbf{On the transferability of this recipe} -- We may have showcased completely automatic testing of an in-vehicle embedded software application, but it is clear that many of our observations and findings are transferable.
Our proposed criteria for automation—a decomposable process with steps requiring judgment but not creativity—can extend to other domains. Additionally, our approach involves six distinct LLM interactions: three align with general API testing workflows, while the others, though tailored to automotive scenarios, require minimal adaptation for different contexts. For example, applying this method to another vehicle manufacturer would take roughly one full workday (1 FTE). Certain aspects may also benefit web server testing. 
Finally, our recipe of largely preserving a test process and using LLMs to verifiably automate discrete manual steps is transferable to any test process that meets the criteria we propose. 
