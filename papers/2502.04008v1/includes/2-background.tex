\section{Background}
Since SPAPI is a web server that exposes REST APIs, our case study falls within the ambit of API testing \cite{10.1145/3617175}. Aspects of the SPAPI test process are therefore recognizable within the larger universe of API testing, but there are also several case-specific adjustments, which we now highlight. 

\subsection{System architecture}
\input{figures/spapi-comparison}

As jointly illustrated in Figures \ref{fig:spapi-comparison} and \ref{fig:spapi-objects}, SPAPI follows the typical 3-tier architecture of decoupling presentation \cite{liu2005modeling}, business logic, and data, each of which we discuss below. 

\noindent \textbf{Presentation} -- Like any web server, SPAPI presents RESTful endpoints with GET and PUT methods and JSON payloads/responses. Each API transacts an object of the form $\mathcal{S} = \{(k_i, v_i)\}_{i=1}^N$, with $N$ attribute-value pairs. Each pair $(k_i, v_i)$ in the object corresponds to some vehicle state $(k^*_i, v^*_i)$ that is managed by a control or monitoring application deployed in an Electronic Control Unit (ECU) in the vehicle. Figure \ref{fig:spapi-objects} shows an example where \texttt{/speed} endpoint provides a GET method that returns the instantaneous speed of the vehicle which, in turn, is calculated by a \texttt{SpeedEstimation} application in a vehicle master control ECU. The same figure also illustrates the \texttt{/climate} endpoint with a PUT method that sets different cabin climate states by communicating with an \texttt{ACControl} application in a climate control ECU. Thus, the essence of SPAPI is presenting APIs for reading or writing an object $\mathcal{S} = \{(k_i, v_i)\}_{i=1}^N$. This corresponds to interacting with vehicle states $\mathcal{S}^* = \{(k^*_i, v^*_i)\}_{i=1}^N$ managed by applications distributed across the in-vehicle embedded system.

\noindent \textbf{Data and data access} -- The typical web server may hold its data in a database, but, clearly, `data' for SPAPI is vehicle state information managed by different in-vehicle control applications. As shown in Figure \ref{fig:spapi-comparison}, these in-vehicle applications are distributed across several ECUs, interconnected using Controller Area Network (CAN) links. While the typical web server may access data by executing database queries, SPAPI accesses data by exchanging CAN signals $\mathcal{S}^\prime = \{(k^\prime_i, v^\prime_i)\}_{i=1}^\mathcal{N}$ with in-vehicle applications. A CAN signal is a pre-defined typed quantity sent through a CAN link between designated sender and receiver applications. In the simplest case, each vehicle state $(k^*_i, v^*_i)$ maps to one CAN signal and value pair $(k^\prime_i, v^\prime_i)$, which SPAPI sends or receives to access the state. We also clarify that this case study focuses upon testing SPAPI in a rig, and not in the real vehicle. In the test rig (see Figure \ref{fig:spapi-comparison}), vehicle state is emulated by a Virtual Vehicle (VV) system, which maintains the superset $\mathcal{N}$ of all vehicle states $\mathcal{S}^* = \{(k^*_i, v^*_i)\}_{i=1}^\mathcal{N}$ in a single table, emulating the state managed by distributed control applications. To maintain consistency of interaction, VV allows state $(k^*_i, v^*_i)$ to be accessed using the same CAN signal $(k^\prime_i, v^\prime_i)$ that SPAPI uses in the real vehicle. In addition to easing testing using virtual means, unlike many other API testing cases, VV offers the advantage of being able to freely mock vehicle state for testing purposes. 
Due to the continuous evolution of CAN signals and the VV platform, it is essential to monitor the vehicle's state to accurately capture relevant state changes.

\looseness=-1
\input{figures/spapi-objects.tex}

\noindent \textbf{API logic} -- Since SPAPI is a gateway, the logic for each endpoint is relatively lean. When a client invokes an endpoint, SPAPI does the mapping $(k_i, v_i) \rightarrow (k^\prime_i, v^\prime_i)$ of each attribute-value pair in the API object to the corresponding CAN signal-value pair. Then, by sending or receiving the CAN signal and value $(k^\prime_i, v^\prime_i)$, SPAPI reads or writes the corresponding vehicle state $(k^*_i, v^*_i)$. Based upon the result of state manipulation, SPAPI sends an appropriate response to the client. \looseness=-1


\subsection{Current manual API testing}

The current manual workflow for API testing, as shown in Figure~\ref{fig:spapi-test-process}, involves steps such as: understand the API specification, look up related information, write test cases, run and access the test cases. 
Specifically, the tester should first identify the specific object set \( S \) by understanding the documentation. Following this, the tester will retrieve the corresponding CAN signal documentation \( S' \) and the VV system documentation \( S^* \). It is crucial to ensure that each attribute in \( S \) can be mapped to both \( S' \) and \( S^* \). 
This means verifying that every attribute can be converted into a CAN signal and can be simulated in the VV system, and testers can write test cases based on the matched results.
Typically, two key aspects need to be checked during API testing. The first aspect is to verify whether the virtual vehicle's state aligns with expectations after setting certain attributes to specific values via API:
\begin{equation}
  \begin{aligned}
  S^{*} &\leftarrow \text{PUT}(S) \\
  S^{*} &\stackrel{?}{=} S_\text{expected}
\end{aligned}
\end{equation}
The second aspect is to check whether the API returns the expected values under a specific virtual vehicle state:
\begin{equation}
  \begin{aligned}
    S &= \text{GET}() \\
    S &\stackrel{?}{=} S_\text{expected}
\end{aligned}
\end{equation}

% Finally, the tester executes the code to check and evaluate the API under test. 
In the following content, we will introduce the details of each step. 

\subsubsection{Understand API specification} 
Test engineers need to understand the API documentation to extract the basic objects about the API. The documentation, like Swagger file, always details each API's essential information, such as all available endpoints, expected request formats, and possible response formats for each endpoint. 
Additionally, Swagger defines the data structures used in the API, including objects, properties, and their types.
An example of a Swagger file snippet describing the \textit{Climate} object is shown in Figure~\ref{fig:spapi-tester-workflow}(a).
In this file, testers should parse the object's \textit{acMode} and its corresponding details in the pairs. 
In summary, a thorough understanding the API documentation manually is essential for constructing a comprehensive object set $\mathcal{S} = \{(k_i, v_i)\}_{i=1}^N$ from the original system documentations.


\subsubsection{Retrieve related information}
After obtaining the attributes and values corresponding to the object, denoted as $S$, it is necessary to search for related documentation, including the information about CAN signals and the details about the virtual vehicle. The search process is illustrated in Figure~\ref{fig:mapping}.

First, the tester needs to locate the relevant CAN signal documentation from CAN signal table. Then, by matching the corresponding key and value, the original state $S$ is converted into the CAN signal $S'$. Afterward, the relevant virtual vehicle documentation is consulted, and the corresponding key and value are mapped to obtain the specific operation $S^*$ that needs to be performed on the VV.


\begin{figure}[t]
  \centering
  \includegraphics[width=0.9\linewidth]{../figures/doc-retrieval.pdf}
  \caption{The process of setting and getting vehicle status according to the API information.}
  \vspace{-0.4cm}
  \label{fig:mapping}
\end{figure}

\textbf{Look up information:}
The three main components of SPAPI testing are the server, vehicle state system, and VV system. Correspondingly, system information, CAN signal specifications and mocking documentation are needed to be retrieved. 

When testing an attribute, the corresponding values should be looked up in both the CAN signal and VV tables. For example, our goal is to set the vehicle's status to \texttt{ECONOMY}.
First, we locate the relevant attribute \texttt{acMode} in the system documentation \( S \). 
Then, we look up \texttt{acMode} in the CAN signal table \( S' \) and find its corresponding value for \texttt{ECONOMY}, which might be 1. 
We then transmit this information to the VV system via the CAN signal. 
Subsequently, in the VV system, we read the corresponding CAN signal and look up the VV table $S^*$ to find the value of the \texttt{acMode} under the \texttt{ECONOMY} state, which might be 2. Finally, we set the value of \texttt{acMode} to 2 in the VV system.
Finally, the \texttt{acMode} in the VV system is set to 2 to achieve the desired vehicle state of \texttt{ECONOMY}.


\textbf{Information organizing:}
In automotive systems, to transmit signals via CAN and utilize VV system correctly, we need to ensure that each attribute and its corresponding value in the system document $\mathcal{S} = \{(k_i, v_i)\}_{i=1}^N$ can be looked up in the CAN signal specifications for getting $\mathcal{S'} = \{(k'_i, v'_i)\}_{i=1}^{N'}$. 
Simultaneously, each attribute and its value in $\mathcal{S'}$ should be looked up in the mocking documentations to get $\mathcal{S^*} = \{(k^*_i, v^*_i)\}_{i=1}^{N^{*}}$. Formally, our goal is to find a mapping such that:
\begin{equation}
  \begin{aligned}
      \forall (k_i, v_i), \;  \exists (k_{j}^{'}, v_j^{'}) \in S^{'} \; &\text{where} \; (k_i, v_i) \rightarrow (k_{j}^{'}, v_j^{'}) \\
      \forall (k_i^{'}, v_i^{'}), \;  \exists (k_{k}^{*}, v_k^{*}) \in S^{*} \; &\text{where} \;  (k_i^{'}, v_i^{'}) \rightarrow (k_{k}^{*}, v_k^{*})
\end{aligned}
\end{equation}
This ensures that every key $k_i$ from $\mathcal{S}$ maps to a corresponding key in $\mathcal{S'}$ and every key $k_i'$ from $\mathcal{S'}$ maps to a corresponding key in \( \mathcal{S^*} \).

However, these three components are developed by different teams, and the corresponding document table may not match exactly, e.g. the names of the attributes in each table may not be consistent since some attributes is recorded using a mixture of natural language and formal language. Table~\ref{table:examples2} summarizes 5 common types of records with different forms. 
Besides, there can be discrepancies in the number of values for an attribute. For example, the \texttt{acMode} attribute may have two states, \texttt{STANDARD} and \texttt{ECONOMY}, in the system document, but there are 3 modes (also \texttt{TURBO}) in the CAN signal specification. In such cases, it is also needed to match the values with equivalent meanings.
Moreover, there are instances of missing attributes, where a corresponding mapping key cannot be found. 
Since such issues are diverse and irregular, testers need to carry out such fuzzy matching cautiously based on their own knowledge and experience.

\begin{table}[h]
  \centering
  \caption{5 types of problems that require fuzzy matching.}
  \begin{tabular}{|c|c|c|}
  \hline
  \multirow{2}{*}{\centering \textbf{Category}} & \multicolumn{2}{|c|}{\textbf{Example}} \\
  \cline{2-3}
   & \textbf{Key 1} & \textbf{Key 2} \\
  \hline
  Spelling errors & \textit{DriverTimeSetting} & \textit{DriverTimeSeting} \\
  \hline
  Abbreviations & \textit{standard} & \textit{STD} \\
  \hline
  Similar writing formats & \textit{standard\_mode} & \textit{STANDARDMODE} \\
  \hline
  Logical equivalents & \textit{OFF} & \textit{NOT\_ON} \\
  \hline
  Semantic equivalents & \textit{AutoStart} & \textit{AutoLaunch} \\
  \hline
  \end{tabular}
  \label{table:examples2}
\end{table}

\subsubsection{Write Test Cases}
Based on the organized information, testers can write reasonable and comprehensive test cases. 
Specifically, the two main methods of a vehicle API, PUT and GET, need to be tested separately. The PUT method is used to set the car's state, while the GET method is used to retrieve the car's current state.
To verify the effectiveness of the PUT method, we set the car's state to \( S \) using the PUT method and then check whether all the virtual vehicle's states $S^{*}$ in the VV system are as expected.


To verify whether the GET method is valid, we directly call the GET method to retrieve the car's current states, and check if the retrieved states \( S \) match the expected states.


The process of writing test cases requires testers to have a comprehensive understanding of the organized information and a background in computer science, such as ensuring the correctness of data types in test cases. In addition, testers need to consider all test situations consider as many test situations as possible to ensure high coverage of test cases.
Finally, testers write the test code to execute the test cases. 


\subsubsection{Running code and Evaluating results}
Once the environment and code are prepared, the code can be executed to automatically test the API. Existing test frameworks and tools can be used to organize the results, allowing to directly obtain the final outcomes. 

\subsection{Obstacles to automation}
Based on the current API testing process, the obstacles to achieving automated API testing can be summarized as follows:

\begin{itemize}
  \item \textbf{Fuzzy Matching:} Since the system information, CAN bus specifications and VV documentations are recorded by different teams, the names of the attributes (i.e., the key in the table) are sometimes inconsistent, as shown in Table~\ref{table:examples2}. 
  In addition, the value also needs to be mapped based on the semantics of the key.
  For instance, the attribute \texttt{isAlarmActive} may be \texttt{TRUE}/\texttt{FALSE} in system files but \texttt{Active}/\texttt{Inactive} in CAN specifications. 
  Such inconsistency makes it difficult to achieve exact matching, necessitating the implementation of a fuzzy matching mechanism.
  \item \textbf{Informal Pseudocoded Mappings:} 
  In the CAN signal table, data is often represented in the form of informal pseudocode, leading to situations where a single key-value pair maps to multiple counterparts. For example, activating the car's alarm clock requires setting the attribute and value as \{AlarmActive:True\}. However, the corresponding data in the CAN signal table could be represented as \{AlarmClockStat:Active OR AlarmClockStat:Ringing OR AlarmClockStat:Snoozed\}.
  In this scenario, it is necessary not only to parse the CAN signal table but also to match the original key-value pair with each entry in the CAN signal table. This requires recognizing and parsing these pseudocode forms and being able to handle one-to-many mappings.
  \item \textbf{Inconsistent Units:} Automotive values are often associated with units, such as speed, which can be measured in \texttt{km/h} or \texttt{m/s}. When units are inconsistent, direct mapping of values between tables is not possible. Values must be converted to the corresponding units before mapping. Thus, the variety of units and the different conversions required between them make detecting unit inconsistencies and performing conversions a major challenge.
  \item \textbf{Inter-Parameter Dependencies:} Parameters often have complex interdependencies, requiring coordinated settings. For example, the attribute \texttt{alarmTime} might be represented as a date-time string in system files, but in CAN files, it might need to be mapped separately to \texttt{hours} and \texttt{minutes}. Capturing and managing these parameter relationships is not an easy task.
\end{itemize}
