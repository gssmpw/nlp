


\section{Experiments on Mistral}
\label{sec:mistral}
To verify the consistency of our approach, we conduct experiments using another modelâ€”Mistral 7b instruct v0.1 (~\cite{jiang2023mistral}). The results  presented below indicate that our approach remains consistent across different models. 


\begin{table}[htbp]
    \centering
    \caption{Layer-wise Analysis of Multi-class Classification}
    \label{tab:matching-analysis_appendox}
    \setlength{\tabcolsep}{6.8pt}
    \scriptsize
    \begin{tabular}{@{}c@{\,}c@{\,}|@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{}}
        \toprule
        Layer & N & rem & und & app & ana & eva & cre & avg \\
        \midrule
        15 & 30 & \calcpercent{181}{960} & \calcpercent{361}{960} & \calcpercent{86}{960} & \calcpercent{126}{960} & \calcpercent{60}{960} & \calcpercent{760}{960} & 27.3\% \\
        & 300 & \calcpercent{319}{960} & \calcpercent{327}{960} & \calcpercent{178}{960} & \calcpercent{159}{960} & \calcpercent{536}{960} & \calcpercent{694}{960} & 38.4\% \\
        & 950 & \calcpercent{303}{960} & \calcpercent{431}{960} & \calcpercent{299}{960} & \calcpercent{15}{960} & \calcpercent{344}{960} & \calcpercent{593}{960} & 34.5\% \\
        \bottomrule
    \end{tabular}
    \\ \vspace{1mm}
    \footnotesize{Note: N=sample size; rem=remember; und=understand;
    app=apply; ana=analyze; eva=evaluate; cre=create; avg=average}
\end{table}
\begin{figure*}[ht]
\centering
  \includegraphics[width=.88\linewidth]{figures/mistral.png}
  \caption{Measured class distribution showing steering accuracy from source (Understand) to target cognitive categories for \emph{Mistral 7b Instruct} model. Target classes appear on X-axis while Y-axis shows class category distribution of steered text.}
  \label{fig:mistral}
\end{figure*}


Figure \ref{fig:mistral} shows the distribution of steered generation category using mistral.

\subsection{Qualitative comparison using Mistral}
\medskip
\subsection*{Understand to apply}
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that converts alternate characters to uppercase in a string using call by reference.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <string>
using namespace std;
void alternateCase(string &str) {
    for(int i = 1; i < str.length(); i += 2) {
        str[i] = toupper(str[i]);
    }
}
int main() {
    string text = "programming";
    cout << "Original: " << text << endl;
    alternateCase(text);
    cout << "Modified: " << text;
    return 0;
}
\end{lstlisting}
\textbf{W/O SAE (Q generation):} The relationship between the string length and the loop boundary shows basic grasp of character access and array bounds. The implementation demonstrates fundamental concepts of C++ syntax while maintaining proper pointer usage for in-place string modification. \par

\textbf{SAE:} While the approach is efficient for small-to-medium string sizes, the single-character modification strategy limits scalability. This implementation might not perform well for larger strings or handle multiple consecutive consecutive characters.  \par
\textbf{Judgement:}  SAE Generation is more effective in aligning with the "Evaluate" level of Bloom's Taxonomy than Q Generation . The "Evaluate" level involves making judgments or decisions based on specific criteria or standards.

In SAE Generation, the feedback provides a critical evaluation of the approach by identifying its potential limitations. It assesses the performance and scalability concerns for larger strings or scenarios with multiple consecutive characters. This evaluation is based on the specific criteria of efficiency, scalability, and edge-case handling, which are essential characteristics of a robust implementation.



\medskip
\subsection*{Understand to create}
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a program to swap two numbers using call by reference method.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
using namespace std;
void swapNumbers(int &x, int &y) {
    x = y;
    y = x;
}
int main() {
    int a = 10, b = 20;
    cout << "Before swap: a = " << a << ", b = " << b << endl;
    swapNumbers(a, b);
    cout << "After swap: a = " << a << ", b = " << b << endl;
    return 0;
}
\end{lstlisting}


\textbf{W/O SAE (Q generation):} The implementation shows basic understanding of how references work in C++, but the fundamental relationship between value and reference parameters needs clearer expression. A proper function signature (int$\&$) for a reference parameter should follow the syntax: *reference(value). \par

\textbf{SAE:}  Consider enhancing the function by adding input validation for zero or negative numbers, and implementing a template version for generic number types. You might also look into implementing swapping operations in different programming languages to compare their syntax and performance. \par


\textbf{Judgement:}  SAE Generation  aligns more effectively with the "create" level of Bloom's Taxonomy than Generation 1. The "create" level involves putting parts together to form something new or original, and Generation 2 provides suggestions for extending and enhancing the existing implementation in novel ways.


In contrast, Q Generation  primarily focuses on providing feedback on the existing implementation and suggesting improvements to the function signature syntax. While this feedback is valuable, it does not explicitly encourage creating new elements or substantially modifying the existing implementation.






\medskip
\subsection*{Understand to analyze}
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that removes duplicate elements from a sorted vector while maintaining the original order.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

vector<int> removeDuplicates(vector<int>& nums) {
    vector<int> result;
    for(int i = 1; i < nums.size(); i++) {  
        if(nums[i] != nums[i-1]) {
            result.push_back(nums[i]);
        }
    }
    return result;
}
\end{lstlisting}
\textbf{W/O SAE (Q generation):}  Your code effectively utilizes the vector's constructor for memory allocation and push\_back for appending, demonstrating fundamental vector manipulation using C++ syntax. The logic correctly maintains the order but loses duplicates, showing how small details can have significant differences.\par

\textbf{SAE:}  Consider implementing a simple hash table for O(N) time complexity using a hash table's constant access time for duplicate detection. This would provide better performance and a more elegant solution for the same functionality, but at the cost of linear probing for collisions. \par
\textbf{Judgement:} SAE Generation  is more effective than Generation 1 in terms of aligning with the "Analyze" level of Bloom's Taxonomy because it requires the learner to break down the problem into its constituent parts, evaluate the pros and cons of different approaches, and make connections between the solution and its performance characteristics.


In contrast, Q Generation  primarily focuses on describing the existing code and its functionality, which aligns more with the "Understand" level of Bloom's Taxonomy. While it mentions the impact of losing duplicates, it does not explicitly prompt the learner to analyze the problem from different perspectives or evaluate alternative solutions.



\medskip
\subsection*{Understand to evaluate}

\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that converts alternate characters to uppercase in a string using call by reference. \par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <string>
using namespace std;
void alternateCase(string &str) {
    for(int i = 1; i < str.length(); i += 2) {
        str[i] = toupper(str[i]);
    }
}
int main() {
    string text = "programming";
    cout << "Original: " << text << endl;
    alternateCase(text);
    cout << "Modified: " << text;
    return 0;
}
\end{lstlisting}
\textbf{W/O SAE (Q generation):} The relationship between the string length and the loop boundary shows basic grasp of character access and array bounds. The implementation demonstrates fundamental concepts of C++ syntax while maintaining proper pointer usage for in-place string modification. \par

\textbf{SAE:}  While the approach is efficient for small-to-medium string sizes, the single-character modification strategy limits scalability. This implementation might not perform well for larger strings or handle multiple consecutive consecutive characters.  \par
\textbf{Judgement:} 

In SAE Generation , the feedback provides a critical evaluation of the approach by identifying its potential limitations. It assesses the performance and scalability concerns for larger strings or scenarios with multiple consecutive characters. This evaluation is based on the specific criteria of efficiency, scalability, and edge-case handling, which are essential characteristics of a robust implementation.


On the other hand, Q Generation  primarily focuses on describing the implementation's functionality and adherence to syntax rules. While this feedback demonstrates an understanding of the code, it does not provide a critical evaluation or make judgments based on specific criteria, which is a key aspect of the "Evaluate" level.







\section{Experiments on Query embeddings}
\label{sec:Q}
We also investigate how different cognitive styles ( Table \ref{tab:matching-analysis_appendox}) are distinct in the query embedding space across both the models mistral and phi. 
\begin{table}[htbp]
\begin{minipage}{\columnwidth}
    \centering
    \caption{Layer-wise Analysis of Multi-class Classification w/o SAE with fixed $L_{1}$=0.003}
    \label{tab:matching-analysis_appendox}
    \setlength{\tabcolsep}{5.5pt}
    \scriptsize
    \begin{tabular}{@{}l@{\,}c@{\,}c@{\,}|@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{}}
        \toprule
        L & N & mod & rem & und & app & ana & eva & cre & avg \\
        \midrule
        \multirow{4}{*}{15} 
            & 30 & mis & \calcpercent{266}{960} & \calcpercent{609}{960} & \calcpercent{77}{960} & \calcpercent{149}{960} & \calcpercent{218}{960} & \calcpercent{722}{960} & 35.4\% \\
            & 300 & mis & \calcpercent{492}{960} & \calcpercent{291}{960} & \calcpercent{351}{960} & \calcpercent{280}{960} & \calcpercent{595}{960} & \calcpercent{777}{960} & 48.4\% \\
            & 30 & phi & \calcpercent{288}{960} & \calcpercent{548}{960} & \calcpercent{196}{960} & \calcpercent{214}{960} & \calcpercent{443}{960} & \calcpercent{547}{960} & 38.8\% \\
            & 300 & phi & \calcpercent{537}{960} & \calcpercent{380}{960} & \calcpercent{452}{960} & \calcpercent{195}{960} & \calcpercent{507}{960} & \calcpercent{601}{960} & 46.4\% \\
        \midrule
        \multirow{2}{*}{28} 
            & 30 & phi & \calcpercent{242}{960} & \calcpercent{512}{960} & \calcpercent{87}{960} & \calcpercent{125}{960} & \calcpercent{116}{960} & \calcpercent{350}{960} & 24.9 \\
            & 300 & phi & \calcpercent{278}{960} & \calcpercent{281}{960} & \calcpercent{343}{960} & \calcpercent{153}{960} & \calcpercent{451}{960} & \calcpercent{315}{960} & 31.6 \\
        \bottomrule
    \end{tabular}
    \\ \vspace{1mm}
    \footnotesize{Note: L=layer; N=sample size; mod=model (mis=mistral, phi=phi);
    rem=remember; und=understand; app=apply; ana=analyze; eva=evaluate; cre=create}
    \end{minipage}
\end{table}



\section{Experiments on SAE with different dimensions}
\label{sec:Q_dim}


Instead of only 512 dimension we also train SAE for different dimensions (\ie 256,1024,2048). Table \ref{tab:matching-analysis_appendox1} shows the classification accuracy across different dimensions. Figure \ref{fig:acd} shows the steering accuracy across different dimensions. We observe learning sparse features using the query attention's activations across various dimensions can be useful for textual attribute understanding. 

\begin{table}[htbp]
\begin{minipage}{\columnwidth}
    \centering
    \caption{Analysis of Multi-class Classification with SAE trained on different dimension with fixed $L_{1}$=0.003 and Layer 15}
    \label{tab:matching-analysis_appendox1}
    \setlength{\tabcolsep}{3.5pt}
    \scriptsize
    \begin{tabular}{@{}l@{\,}c@{\,}|@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{}}
        \toprule
        dim & N & rem & und & app & ana & eva & cre & avg \\
        \midrule
         256 & 30  & \calcpercent{216}{960} & \calcpercent{640}{960} & \calcpercent{116}{960} & \calcpercent{200}{960} & \calcpercent{341}{960} & \calcpercent{502}{960} & 35.0\% \\
        
         256 & 300  & \calcpercent{506}{960} & \calcpercent{338}{960} & \calcpercent{416}{960} & \calcpercent{241}{960} & \calcpercent{508}{960}  & \calcpercent{558}{960} & 44.6\% \\
        
         1024 & 30  & \calcpercent{365}{960} & \calcpercent{287}{960} & \calcpercent{383}{960} & \calcpercent{227}{960} & \calcpercent{424}{960} & \calcpercent{456}{960} & 37.2\% \\
        
         1024 & 300  & \calcpercent{365}{960} & \calcpercent{287}{960} & \calcpercent{383}{960} & \calcpercent{227}{960} & \calcpercent{424}{960} & \calcpercent{456}{960} & 37.2\% \\
        
         2048 & 30  & \calcpercent{188}{960} & \calcpercent{576}{960} & \calcpercent{100}{960} & \calcpercent{181}{960} & \calcpercent{185}{960} & \calcpercent{273}{960} & 26.1\% \\
        
         2048 & 300  & \calcpercent{330}{960} & \calcpercent{282}{960} & \calcpercent{375}{960} & \calcpercent{219}{960} & \calcpercent{414}{960} & \calcpercent{435}{960} & 35.7\% \\
        \bottomrule
    \end{tabular}
    \\ \vspace{1mm}
    \footnotesize{Note: dim=dimension; N=sample size; rem=remember; und=understand;
    app=apply; ana=analyze; eva=evaluate; cre=create}
    \end{minipage}
\end{table}


\begin{figure*}[ht]
\centering
  \includegraphics[width=.88\linewidth]{figures/attention_cat_dist.png}
  \caption{ Measured class distribution showing steering accuracy from source cognitive style (Remember) to intended target cognitive styles. Target classes appear on X-axis while Y-axis shows class category distribution of steered text.}
  \label{fig:acd}
\end{figure*}
    














\section{In context learning in baseline model}

Figure \ref{fig:baselineincrement} demonstrates how the baseline model's accuracy improves as the number of training examples increases. With only one example for the "create" cognitive style feedback, the model tends to generate responses that align more with "analyze" or "evaluate". However, as more examples are provided, the model becomes better at generating feedback in the intended "create" cognitive style.
Interestingly, the results also reveal that LLMs typically generate feedback in "evaluate" cognitive styles, even with just a single example of 'evaluate' feedback, the model generates majority of responses categories in this style. For this baseline implementation, we select the \emph{phi-3-mini-128k instruct model} primarily due to its extended context window, which allows us to process N examples simultaneously. While the literature contains no substantive claims comparing this model's performance to  \emph{phi-3-mini-4k instruct model}, except expanded context length capacity \cite{abdin2024phi}.



\begin{figure}[ht]
\centering
  \includegraphics[width=.88\linewidth]{figures/baseline_evolution.png}
  \caption{ Increasing the number of examples for a specific cognitive style improves the possibility of generating feedback in that style for base model.  }
  \label{fig:baselineincrement}
\end{figure}





\begin{comment}
    

\subsection{Residual Layer}

\label{subsec:qvsresid}
We evaluated the effectiveness of training SAE on residual layer's activation for our task but found no meaningful patterns. Figure \ref{fig:resvq} presents a quantitative comparison using ROUGE-L scores. Table \ref{tab::matching-analysis_appendox4} shows the classification accuracy.

\begin{figure}[t]
  \includegraphics[width=0.88\linewidth]{figures/resvsq.png}
  \caption{Quantitative comparison using ROUGE score}
  \label{fig:resvq}
\end{figure}
    

\begin{table}[htbp]
\begin{minipage}{\columnwidth}
    \centering
    \caption{Analysis of Multi-class Classification with SAE trained on residual layer with fixed $L_{1}$=0.003 and Layer 25}
    \label{tab:matching-analysis_appendox4}
    \setlength{\tabcolsep}{4.1pt}
    \scriptsize
    \begin{tabular}{@{}l@{\,}c@{\,}|@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{\,}c@{}}
        \toprule
        L & N & rem & und & app & ana & eva & cre & avg \\
        \midrule
         25 & 30  & \calcpercent{390}{960} & \calcpercent{40}{960} & \calcpercent{52}{960} & \calcpercent{114}{960} & \calcpercent{19}{960} & \calcpercent{573}{960} & 
 20.6\% \\
        
         25 & 300  & \calcpercent{478}{960} & \calcpercent{304}{960} & \calcpercent{405}{960} & \calcpercent{232}{960} & \calcpercent{501}{960}  & \calcpercent{548}{960} &  42.8\% \\
        \bottomrule
    \end{tabular}
    \\ \vspace{1mm}
    \footnotesize{Note: L=layer; N=sample size; rem=remember; und=understand;\\
    app=apply; ana=analyze; eva=evaluate; cre=create; avg=average}
    \end{minipage}
\end{table}


We explored using alternative model components beyond query attention heads for generation control. Specifically, we trained SAEs on the residual stream at layer 15,5,25 but observed no meaningful impact on steering the output. This aligns with our understanding, as residual streams aggregate information from previous layers, potentially diluting the precise control needed for targeted content modulation. In contrast, the query attention head proved more effective, as it specifically handles token relationships, making it well-suited for understanding context and guiding the generation process.
\end{comment}


Below we present a qualitative study to demonstrate this effect. We are trying to steer the generation towards "create" cognitive level.







\begin{comment}

\subsection{Qualitative study }




%\medskip
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code\par
Write a program to swap two numbers using a function with call by reference.\par
\textbf{Input}:\par
Code:
\begin{lstlisting}
#include <iostream>
using namespace std;

void swap(int &a, int &b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    cout << "Before swap: x = " << x << ", y = " << y << endl;
    swap(x, y);
    cout << "After swap: x = " << x << ", y = " << y << endl;
    return 0;
}
\end{lstlisting}


\textbf{base generation:} While the code structure correctly includes call-by-reference parameter declarations, 
the implementation successfully swaps the values of the two variables.

\textbf{SAEs trained on residual layer at layer 15: } The code bad uses pointer arithmetic for swapping which leads to buffer overflow in memory when doing number exchanges.\par
\textbf{SAEs trained on query attention head at layer 15: } To adapt the program for reliable swapping with multiple calls, 
we could implement input validation, support parameterized swapping, 
and possibly consider using a template class for more generic swapping functionality. 
The implementation should make the swapping functionality more robust.\par

The generated output from the residual layer is inadequate, as it fails to properly align with the code implementation while only superficially matching the code description. Moreover, instead of demonstrating creation-level skills as required, it inappropriately exhibits analysis/evaluation-level competencies.  

\end{comment}

\section{Qualitative Examples}

\label{sec:Qualitative}
Below, we present examples of the generated responses after steering from source class (original response), accompanied by query and their corresponding target data.
%\onecolumn







\medskip
\subsubsection*{Steering from Remember to Create}
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code\par
Write a function that calculates the sum of all elements in a vector of integers.\par
\textbf{Input}:\par
Code:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;
int sumVector(const vector<int>& vec) {
    int sum = 0;
    for(int num : vec) {
        sum += num;
    }
    return sum;
}
int main() {
    vector<int> numbers = {1, 2, 3, 4, 5};
    cout << sumVector(numbers);
    return 0;
}
\end{lstlisting}


\textbf{Original response (Remember):} Your code demonstrates solid grasp of fundamental C++ elements including vector containers, range-based for loops, and function parameters. The basic syntax and structure show clear recognition of core programming constructs.

\textbf{Steered Generation (Create):} Consider enhancing the function with input validation, template support for different numeric types, and parallel processing capabilities for large vectors. Adding error handling and making it more generic could enhance its re usability.



\medskip
\subsubsection*{Steering from Remember to Analyze}
\textbf{Query:}\par

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par

\textbf{Instruction:}\par
Provide feedback on the following code\par
Write a function that calculates and returns the sum of all elements in a vector of integers.\par

\textbf{Code:}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

int vectorSum(vector<int>& vec) {
    int sum = 0;
    for(int num : vec) {
        sum += num;
    }
    return sum;
}

int main() {
    vector<int> numbers = {1, 2, 3, 4, 5};
    cout << vectorSum(numbers);
    return 0;
}
\end{lstlisting}

{\textbf{Original response (Remember):}  Your code correctly demonstrates fundamental vector operations using essential C++ syntax. The use of a range-based for loop shows basic iteration knowledge, while the parameter passing by reference indicates memory management awareness.}

\textbf{Steered Generation (Analyze):} This solution achieves both memory efficiency and computational simplicity with O(n) complexity. However, it lacks input validation and error handling, which could lead to issues with edge cases or special values. The choice of pass-by-reference over pass-by-value affects memory usage and performance.

\medskip


\subsubsection*{Steering from Remember to Evaluate}


\textbf{Query:}\par
Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.
\par

\textbf{Instruction:}\par
Provide feedback on the following code\par
 Create a function that takes a vector of integers and returns the sum of all even numbers in the vector.
\par

\textbf{Code:}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

int sumEvenNumbers(vector<int> nums) {
    int sum;
    for(int num : nums) {    
        if(num % 2 == 0) {
            sum += num;
        }
    }
    return sum;
}

\end{lstlisting}

{\textbf{Original response (Remember):}  The code shows fundamental use of vector iteration and modulo operator, but overlooks a critical initialization of the sum variable which could lead to undefined behavior. The basic structure of using a for-each loop to traverse the vector is present.}

\textbf{Steered Generation (Evaluate):} While the code structure is clear and the solution is concise, the uninitialized sum variable introduces potential undefined behavior which could be problematic in production environments. The choice of using a range-based for loop shows good modern C++ practice.








\subsubsection*{Steering from Remember to Apply}



\textbf{Query:}\par
Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.
\par

\textbf{Instruction:}\par
Provide feedback on the following code\par
Create a function that reverses the elements of a vector without using built-in reverse function.
\par

\textbf{Code:}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

void reverseVector(vector<int>& vec) {
    int left = 0, right = vec.size() - 1;
    while(left < right) {
        swap(vec[left], vec[right]);
        left++;
        right--;
    }
}

int main() {
    vector<int> numbers = {1, 2, 3, 4, 5};
    reverseVector(numbers);
    for(int num : numbers) {
        cout << num << " ";
    }
    return 0;
}
\end{lstlisting}

{\textbf{Original response (Remember):} Your code correctly implements the fundamental two-pointer technique, demonstrating solid understanding of vector indexing and basic swap operations. The core structure shows proper variable initialization and loop control flow essential for array manipulation.}

\textbf{Steered Generation (Apply):} The implementation effectively uses two pointers from both ends of the vector, performing swaps as the pointers converge. The relationship between the left and right pointers creates a symmetrical pattern, though the boundary condition could be more robust.



\subsubsection*{Steering from Remember to understand}



\textbf{Query:}\par
Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.

\par

\textbf{Instruction:}\par
Provide feedback on the following code\par
Write a function that takes a vector of integers and returns the sum of all even numbers.

\textbf{Code:}
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

int sumEvenNumbers(vector<int> nums) {  
    int sum = 0;
    for(int i = 1; i <= nums.size(); i++) {  
        if(nums[i] % 2 == 0) {
            sum += nums[i];
        }
    }
    return sum;
}
\end{lstlisting}

{\textbf{Original response (Remember):} The code shows fundamental array access and loop structures, but contains a critical indexing error. Array indices in C++ start at 0, not 1, and the loop condition should use < rather than <= to avoid buffer overflow.}

\textbf{Steered Generation (Understand):} The implementation attempts to sum even numbers but fails to properly apply vector indexing conventions. The relationship between vector size and valid indices is misunderstood, leading to incorrect access and potential buffer overflow issues.



\begin{comment}

medskip
\subsubsection{Steering from general detail to high level}
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the r\equest.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that takes a vector of integers and returns the maximum sum of any contiguous subarray within the vector. \par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

int maxSubarraySum(vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];
    
    for(int i = 1; i < nums.size(); i++) {
        currentSum = currentSum + nums[i];
        maxSum = max(maxSum, currentSum);
    }
    return maxSum;
}
\end{lstlisting}

\textbf{General detail Response:} The solution employs Kadane's algorithm for finding the maximum subarray sum with O(n) time and O(1) space complexity. The code uses clear variable names and maintains a running sum while tracking the maximum sum encountered. The implementation lacks input validation and could crash with empty vectors since it assumes at least one element exists. The currentSum variable incorrectly handles negative sequences since it never resets to zero, potentially missing the optimal subarray. A more robust implementation would include error handling and reset currentSum to zero when it becomes negative.

\textbf{Steered Generation (high level):} The function takes a vector reference as input but fails to handle empty vector cases, which could lead to undefined behavior. The initialization of maxSum and currentSum with nums[0] assumes the vector has at least one element, making the code vulnerable to out-of-bounds access. A better approach would be to include input validation using nums.empty() and handle the first element separately with a default value or exception handling.



\medskip



\medskip
\subsubsection{Steering from general detail to full detail }
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Create a function that counts the number of even integers in a vector.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

int countEven(vector<int>& nums) {
    int count = 0;
    for(int num : nums) {
        if(num % 2 == 0) count++;
    }
    return count;
}

int main() {
    vector<int> numbers = {1, 2, 3, 4, 5, 6};
    cout << "Even numbers: " << countEven(numbers);
    return 0;
}
\end{lstlisting}
\textbf{general detail Response:} The solution uses a straightforward iterative approach with a range-based for loop to process each element in the vector. The code is clean, readable, and follows basic C++ conventions with appropriate header inclusions and namespace usage. The time complexity is O(n) where n is the size of the vector, and space complexity is O(1) since only a single counter variable is used. The implementation is efficient for its purpose and handles the basic requirements of counting even numbers.\par

\textbf{Steered Generation (full detail):}The countEven function effectively uses a reference parameter to avoid copying vector elements, which is efficient. The range-based for loop is a modern and clean approach to iterate through the vector elements. The modulo operator is used appropriately to check for even numbers. The code could benefit from input validation to handle empty vectors. The main function could be enhanced with more diverse test cases. Exception handling could be added for robustness. The function name clearly indicates its purpose, following good naming conventions.

\end{comment}

\medskip
\section{Qualitative comparisons between with and without SAE based steering }

\label{sec:Qgeneration}
\subsection*{Understand to analyze}


\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that finds the length of the longest consecutive elements sequence in an unsorted vector.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> num_set(nums.begin(), nums.end());
    int longest = 0;
    for(int num : nums) {
        if(num_set.find(num-1) == num_set.end()) {
            int currentNum = num;
            int currentStreak = 1;
            while(num_set.find(currentNum+1)) { 
                currentNum += 1;
                currentStreak += 1;
            }
            longest = max(longest, currentStreak);
        }
    }
    return longest;
}
\end{lstlisting}
\textbf{W/O SAE (Q generation):} Your code demonstrates solid grasp of fundamental data structures, particularly using unordered\_set for O(1) lookups. You've correctly identified basic elements like vector operations, loops, and conditional statements as building blocks for this problem.\par

\textbf{SAE:} While your solution works correctly, it uses more complex data structures than strictly necessary. The unordered\_set ensures uniqueness but might be more computationally expensive than a simple array or vector operation with appropriate tracking mechanisms.\par
\textbf{Judgement:} SAE Generation  is more effective than W/O SAE in terms of aligning with the "Analyze" level of Bloom's Taxonomy. The "Analyze" level involves breaking down information into parts, finding patterns and relationships, and identifying the underlying components or structure.

In SAE Generation, the feedback focuses on analyzing the solution in terms of its computational complexity and efficiency. It recognizes that while the solution works correctly, it employs more complex data structures (unordered\_set) than strictly necessary. This feedback demonstrates an understanding of the trade-offs involved in using different data structures and their impact on performance and resource utilization.

In contrast, W/O SAE generation ,primarily focuses on acknowledging the correctness of the solution and recognizing the use of basic programming constructs like data structures, loops, and conditionals. While this feedback is valuable in terms of understanding the solution's functionality, it lacks the depth of analysis required at the "Analyze" level of Bloom's Taxonomy.


\medskip
\subsection*{Understand to apply}


\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Create a function that rotates a vector to the right by k positions.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

void rotateVector(vector<int>& nums, int k) {
    int n = nums.size();
    k = k % n;
    vector<int> temp(n);
    for(int i = 0; i < k; i++) {
        temp[i] = nums[n-k+i];
    }
    for(int i = n-1; i >= k; i--) {
        nums[i] = nums[i-k];
    }
    for(int i = 0; i < k; i++) {
        nums[i] = temp[i];
    }
}

int main() {
    vector<int> nums = {1, 2, 3, 4, 5};
    rotateVector(nums, 2);
    for(int num : nums) {
        cout << num << " ";
    }
    return 0;
}

\end{lstlisting}
\textbf{W/O SAE (Q generation):} . Your code demonstrates solid grasp of fundamental concepts like vector manipulation and the modulo operator for handling rotation. The core structure using three distinct loops shows understanding of array traversal and value swapping mechanisms.\par

\textbf{SAE:} Consider implementing a left rotation by modifying the index calculation in the first loop to n-k. You might explore in-place rotation approaches using GCD or reversal algorithms to optimize the solution's computational efficiency. \par
\textbf{Judgement:} SAE Generation  is more effective than Q generation in aligning with the "Apply" level of Bloom's Taxonomy. The "Apply" level involves using learned material in new situations or applying concepts, rules, and principles to solve problems.

In Q generation, the feedback primarily focuses on evaluating the student's understanding and acknowledging their grasp of fundamental concepts. While this feedback is valuable, it does not explicitly challenge the student to apply their knowledge in a new or different way, which is the essence of the "Apply" level.

On the other hand, SAE Generation  provides specific suggestions and prompts for the student to consider alternative approaches and optimizations to the problem at hand. By suggesting the implementation of a left rotation using a modified index calculation or exploring in-place rotation approaches using algorithms like GCD or reversal, the feedback encourages the student to apply their existing knowledge and skills in a new context or problem scenario.
\medskip

\subsection*{Understand to create}



\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that reverses a string and changes lowercase to uppercase and vice versa using call by reference.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <string>
using namespace std;
void reverseAndChangeCase(string str) {
    int n = str.length();
    for(int i = 0; i < n/2; i++) {
        char temp = str[i];
        str[i] = str[n-1-i];
        str[n-1-i] = temp;
    }
    for(int i = 0; i < n; i++) {
        if(isupper(str[i]))
            str[i] = tolower(str[i]);
        else
            str[i] = toupper(str[i]);
    }
}
int main() {
    string text = "Hello World";
    cout << "Original string: " << text << endl;
    reverseAndChangeCase(text);
    cout << "Modified string: " << text << endl;
    return 0;
}
\end{lstlisting}
\textbf{W/O SAE (Q generation):} The relationship between string length and index traversal shows careful consideration of symmetric elements, but the current implementation fails to maintain character consistency in case transformations. The logic behind converting characters needs refinement to avoid unnecessary operations.\par

\textbf{SAE:} The solution could be enhanced by combining the two loops into a single iteration, or by implementing a custom case conversion function to eliminate redundant checks. Adding string bounds checking or implementing a template-based approach might offer more flexibility. \par
\textbf{Judgement:} Q Generation primarily focuses on identifying issues and lacks specific suggestions for creating new structural or functional elements within the solution. While it identifies areas for improvement, it does not propose concrete ideas for reorganizing or combining existing elements into a new pattern or structure.

SAE Generation  better aligns with the "Create" level of Bloom's Taxonomy by providing specific examples and suggestions that involve reorganizing, combining, and introducing new elements to form a more coherent, efficient, and flexible solution.


\medskip
\subsection*{Understand to evaluate}



\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that reverses the elements of a vector.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

void reverseVector(vector<int>& nums) {
    int start = 0, end = nums.size();
    while(start < end) {
        swap(nums[start], nums[end]);
        start++;
        end--;
    }
}

int main() {
    vector<int> numbers = {1, 2, 3, 4, 5};
    reverseVector(numbers);
    for(int num : numbers) cout << num << " ";
    return 0;
}
\end{lstlisting}
\textbf{W/O SAE (Q generation):} .Your code demonstrates fundamental understanding of vector manipulation concepts, using pointer variables (start and end) to traverse the array from both ends. The basic swap operation and vector indexing show recognition of core memory concepts.\par

\textbf{SAE:} The code effectively implements the in-place reversal algorithm with appropriate boundary management. Your use of vector references and proper increment/decrement operations shows practical grasp of memory manipulation concepts. \par
\textbf{Judgement:} SAE Generation  is more effective than Q Generation in terms of aligning with the "Evaluate" level of Bloom's Taxonomy. The "Evaluate" level requires students to make judgments or decisions based on criteria and standards, which involves higher-order thinking skills such as critiquing, justifying, and assessing.

In SAE Generation, the feedback focuses on evaluating the practical implementation and effectiveness of the student's code. It specifically praises the "effective implementation of the in-place reversal algorithm with appropriate boundary management," which demonstrates the ability to assess the code's correctness and efficiency. Additionally, the feedback evaluates the student's "practical grasp of memory manipulation concepts" by highlighting their appropriate use of vector references and proper increment/decrement operations.

On the other hand, Q Generation  primarily focuses on describing the student's understanding and recognition of concepts, which aligns more with the "Understand" level of Bloom's Taxonomy. While it mentions the use of pointer variables and vector indexing, it does not provide an evaluation or critique of the code's implementation or effectiveness.



%\subsection{Steered generation using L2loss }
%\begin{figure}[!ht]
%\centering
%%\includegraphics[width=\linewidth]{figures/l2.png}
%\caption{L2}
%\label{fig:l2loss}
%\end{figure}

%\subsection{side by side comparison with L2 loss vs L1 loss }
%\begin{figure}[!ht]
%\centering
%\includegraphics[width=\linewidth]{figures/l2vsl1.png}
%\caption{L2}
%\label{fig:l2vl1}
%\end{figure}



\begin{comment}



\subsection{Steered generation using SAEs across different attention layers[TODO] }

\label{subsec:Qualitative}

Figure \ref{fig:gtof} presents how steering with SAEs trained on different layers affect the class specific attributes. Layer 15 seems to generally achieve better alignment with target distributions compared to other layers while earlier layer (Layer 5) shows more deviation from target distributions.


\begin{figure}[ht]
\centering
\includegraphics[width=\linewidth]{figures/l2.png}
\caption{Alignment of text generation with various classes when attempting to steer it toward a specific target class using SAE trained on different layers. }
\label{fig:gtof}
\end{figure}
We also present an qualitative example of guided generation using trained Sparse Autoencoders (SAEs) at various layers with a fixed coefficient, $\lambda = 0.003$.
\medskip

\subsubsection{Steering from remember to create level }
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Create a function that calculates factorial of a given number using do-while loop.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
using namespace std;

long factorial(int n) {
    long result = 1;
    int i = n;
    do {
        result *= i;
        i--;
    } while (i >= 0);  
    return result;
}

int main() {
    int num;
    cout << "Enter a number: ";
    cin >> num;
    cout << "Factorial: " << factorial(num);
    return 0;
}

\end{lstlisting}

\st{\textbf{Remember response}: The code demonstrates fundamental use of do-while loop structure and basic arithmetic operations for factorial calculation. The core elements include variable initialization, multiplication assignment, and decrement operations, showing essential C++ syntax understanding.}

\textbf{Steered generation using SAEs (layer5)}: The approach of using function pointers for operations shows good\par

\textbf{Steered generation using SAEs (layer15)}: Consider refining the solution by adding input validation, implementing custom error handling, and exploring alternative approaches like memoization for improved performance. The current implementation, while functional, could benefit from a more sophisticated error handling strategy.\par


\textbf{Steered generation using SAEs (layer20)}:Consider refining the solution by examining other programming styles, such as functional programming, to introduce new perspectives on code structuring. While the implementation performs its intended function, adopting a new coding style could provide insights into efficiency and maintainability. Additionally, you could consider integrating more complex algorithms unrelated to the task to expand your coding skills. \par

\textbf{Analysis}:

Upon closely analyzing the three responses we observe : \\
\textbf{layer 5} generation does not meet the criteria for either validity or alignment with the "create" level. \\
\textbf{layer 15} generation directly addresses potential improvements to the code and aligns well with the creation and enhancement of the existing solution. \\
Although the \textbf{layer 20} generation is creative, it lacks direct applicability and specificity to the given task but still holds value in a generalized educational context.






\end{comment}




\section{Steering from fine tuned base model}

Figure~\ref{fig:scratch} shows the distribution of steered generation category across all the target classes.

\begin{figure*}[ht]
\centering
  \includegraphics[width=.88\linewidth]{figures/scratch.png}
  \caption{Measured class distribution showing steering accuracy from fine tuned base model output to target cognitive categories. Target classes appear on X-axis while Y-axis shows class category distribution of steered text.}
  \label{fig:scratch}
\end{figure*}



\label{sec:LLMoutput}
Below, we present Qualitative examples of the generated responses after steering from fine tuned base model output.
%\onecolumn







\medskip
\subsubsection*{Steering to apply}
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code\par
Write a program to increment a number by 1 using a function with call by reference. \par
\textbf{Input}:\par
Code:
\begin{lstlisting}
#include <iostream>
using namespace std;

void increment(int num) {
    num++;
}

int main() {
    int value = 5;
    cout << "Before increment: " << value << endl;
    increment(value);
    cout << "After increment: " << value << endl;
    return 0;
}
\end{lstlisting}


\textbf{Base generation:} The code structure reveals a disconnect between the function's intended purpose and its actual implementation. The increment function is designed to modify a value, but the current implementation fails to achieve this goal due to the missing reference parameter.

\textbf{Steered Generation:} While the code structure includes a function definition and a main function, the call by reference pattern is incorrect. The function needs to be defined with the reference operator to modify the value correctly.



\medskip
\subsubsection*{Steering to create}
\textbf{Query:}\par

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par

\textbf{Instruction:}\par
Provide feedback on the following code\par
Write a program to swap two numbers using a function with call by reference.\par

\textbf{Code:}
\begin{lstlisting}
#include <iostream>
using namespace std;

void swap(int a, int b) {
    int temp = a;
    a = b;
    b = temp;
}

int main() {
    int x = 5, y = 10;
    cout << "Before swap: x = " << x << ", y = " << y << endl;
    swap(x, y);
    cout << "After swap: x = " << x << ", y = " << y << endl;
    return 0;
}
\end{lstlisting}

\textbf{Base generation:}  The code demonstrates fundamental pointer concepts with call by reference parameters. However, it's missing the core swap operation implementation where the values need to be exchanged rather than the references being swapped.

\textbf{Steered Generation:} Consider enhancing the solution by implementing proper reference variables, either using pointers or implementing it as a class with member references, or explore in-place swapping techniques using reference operators for a more elegant solution.

\medskip


\subsubsection*{Steering to remember}


\textbf{Query:}\par
Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.
\par

\textbf{Instruction:}\par
Provide feedback on the following code\par
Write a program to double all elements of an array using a function with call by reference.
\par

\textbf{Code:}
\begin{lstlisting}
#include <iostream>
using namespace std;

void doubleElements(int arr[5]) {
    for(int i = 0; i < 5; i++) {
        arr[i] = arr[i] * 2;
    }
    return arr;
}

int main() {
    int arr[5] = {1, 2, 3, 4, 5};
    cout << "Before: ";
    for(int i = 0; i < 5; i++) cout << arr[i] << " ";
    doubleElements(arr);
    cout << "\nAfter: ";
    for(int i = 0; i < 5; i++) cout << arr[i] << " ";
    return 0;
}

\end{lstlisting}

{\textbf{Base generation:} The code demonstrates basic array manipulation using a for loop and showcases fundamental function structure with a parameter array. However, the return statement is missing from the main function, which is essential for pointer-based array handling. }

\textbf{Steered Generation:} The relationship between arrays and function parameters shows good comprehension of how arrays can be passed around as values through pointers. The concept that arrays decay to pointers when passed to functions is well-illustrated in your code.









\begin{comment}

medskip
\subsubsection{Steering from general detail to high level}
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the r\equest.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that takes a vector of integers and returns the maximum sum of any contiguous subarray within the vector. \par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

int maxSubarraySum(vector<int>& nums) {
    int maxSum = nums[0];
    int currentSum = nums[0];
    
    for(int i = 1; i < nums.size(); i++) {
        currentSum = currentSum + nums[i];
        maxSum = max(maxSum, currentSum);
    }
    return maxSum;
}
\end{lstlisting}

\textbf{General detail Response:} The solution employs Kadane's algorithm for finding the maximum subarray sum with O(n) time and O(1) space complexity. The code uses clear variable names and maintains a running sum while tracking the maximum sum encountered. The implementation lacks input validation and could crash with empty vectors since it assumes at least one element exists. The currentSum variable incorrectly handles negative sequences since it never resets to zero, potentially missing the optimal subarray. A more robust implementation would include error handling and reset currentSum to zero when it becomes negative.

\textbf{Steered Generation (high level):} The function takes a vector reference as input but fails to handle empty vector cases, which could lead to undefined behavior. The initialization of maxSum and currentSum with nums[0] assumes the vector has at least one element, making the code vulnerable to out-of-bounds access. A better approach would be to include input validation using nums.empty() and handle the first element separately with a default value or exception handling.



\medskip



\medskip
\subsubsection{Steering from general detail to full detail }
\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Create a function that counts the number of even integers in a vector.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
using namespace std;

int countEven(vector<int>& nums) {
    int count = 0;
    for(int num : nums) {
        if(num % 2 == 0) count++;
    }
    return count;
}

int main() {
    vector<int> numbers = {1, 2, 3, 4, 5, 6};
    cout << "Even numbers: " << countEven(numbers);
    return 0;
}
\end{lstlisting}
\textbf{general detail Response:} The solution uses a straightforward iterative approach with a range-based for loop to process each element in the vector. The code is clean, readable, and follows basic C++ conventions with appropriate header inclusions and namespace usage. The time complexity is O(n) where n is the size of the vector, and space complexity is O(1) since only a single counter variable is used. The implementation is efficient for its purpose and handles the basic requirements of counting even numbers.\par

\textbf{Steered Generation (full detail):}The countEven function effectively uses a reference parameter to avoid copying vector elements, which is efficient. The range-based for loop is a modern and clean approach to iterate through the vector elements. The modulo operator is used appropriately to check for even numbers. The code could benefit from input validation to handle empty vectors. The main function could be enhanced with more diverse test cases. Exception handling could be added for robustness. The function name clearly indicates its purpose, following good naming conventions.



\medskip
\section{Qualitative comparisons between with and without SAE based steering }

\label{sec:Qgeneration}
\subsection*{Understand to analyze}


\textbf{Query:}

Below is an instruction that describes a task, paired with an input that provides further context. Write a response that appropriately completes the request.\par
\textbf{Instruction:}\par
Provide feedback on the following code \par
Write a function that finds the length of the longest consecutive elements sequence in an unsorted vector.\par

\textbf{Code}:
\begin{lstlisting}
#include <iostream>
#include <vector>
#include <unordered_set>
using namespace std;
int longestConsecutive(vector<int>& nums) {
    unordered_set<int> num_set(nums.begin(), nums.end());
    int longest = 0;
    for(int num : nums) {
        if(num_set.find(num-1) == num_set.end()) {
            int currentNum = num;
            int currentStreak = 1;
            while(num_set.find(currentNum+1)) { 
                currentNum += 1;
                currentStreak += 1;
            }
            longest = max(longest, currentStreak);
        }
    }
    return longest;
}
\end{lstlisting}
\textbf{W/O SAE (Q generation):} Your code demonstrates solid grasp of fundamental data structures, particularly using unordered\_set for O(1) lookups. You've correctly identified basic elements like vector operations, loops, and conditional statements as building blocks for this problem.\par

\textbf{SAE:} While your solution works correctly, it uses more complex data structures than strictly necessary. The unordered\_set ensures uniqueness but might be more computationally expensive than a simple array or vector operation with appropriate tracking mechanisms.\par
\textbf{Judgement:} SAE Generation  is more effective than W/O SAE in terms of aligning with the "Analyze" level of Bloom's Taxonomy. The "Analyze" level involves breaking down information into parts, finding patterns and relationships, and identifying the underlying components or structure.
\end{comment}



\section{Assigning target center to the decoder}
We evaluate the direct use of target center embedding for steered generation (Figure~\ref{fig:ltarget center}). We observe instead of rigid assignment of target center embedding, gradient descent based approach captures 
the target cognitive style effectively. 
\label{sec:tcd}
\begin{figure}[!ht]
\centering
\includegraphics[width=\linewidth]{figures/targetlevel.png}
\caption{Measured class distribution showing steering accuracy. Target classes appear on X-axis while Y-axis shows class category distribution of steered text.}
\label{fig:ltarget center}
\end{figure}

\eat{

\subsection{Embedding Characteristics and Hyperparameter Sensitivity}\label{subsec:Characteristics}
Contour analysis across various layers and regularization coefficients (Figure \ref{fig:combined_analysis}) provides valuable insights into how the SAE model learns under different configurations.
\subsubsection{Role of Prototype Examples in Generation}
Our analysis demonstrates that prototype examples play a crucial role in the generation process, particularly in facilitating class transitions. The effectiveness of steering from a predicted class to a target class heavily depends on maintaining meaningful separation between the mean embeddings of support set samples in the SAE latent space.

\subsubsection{ Effect of $L_{1}$ Regularization Strength}
Analysis of cognitive style embeddings on a fixed layer reveals distinct clustering patterns influenced by varying $L_{1}$ regularization strengths. At $\mathbf{L_{1} = 0.0003}$ the embeddings are broadly dispersed, with significant overlap between cognitive styles such as "remember" and "understand," indicating low sparsity and less distinct feature representations. Increasing $\mathbf{L_{1}=0.003}$ results in more concentrated clusters with reduced overlap, as seen in sharper density peaks for specific styles like "analyze" and "evaluate," reflecting a balance between sparsity and feature diversity. At $\mathbf{L_{1}=0.03}$, the clusters become tightly packed and well-separated, with sharp density peaks localized around dominant features, such as "understand," while suppressing others, suggesting high sparsity but potential loss of feature richness. These observations suggest higher $L_{1}$-regularization enforces sparsity by narrowing the range of active features, progressively enhancing cluster distinctiveness at the cost of diversity. Moderate regularization ($L_{1}= 0.003$) achieves an optimal trade-off between feature complexity and sparsity, making it suitable for tasks requiring both generalization and structured representations.



\begin{figure*}[h!]
  \includegraphics[width=0.78\linewidth]{figures/combined1.pdf}
  \caption{
(Top) Distribution of the mean embeddings computed from $N=30$ support examples at layer 15 of the SAE across three different $L_{1}$ coefficients ($0.0003$, $0.003$, $0.03$).\\[1mm]
(Bottom) Distribution of the mean embeddings computed from $N=30$ support examples across layers [$5$,$28$] using a fixed $L_{1}$ coefficient of $0.003$.
}

  \label{fig:combined_analysis}
\end{figure*}


\subsubsection{Layer-wise Analysis}
The analysis of cognitive style embeddings across different layers (5, 15, 28) at fixed $L_{1}$ coefficient 0.003 reveals a progressive refinement in feature representation and clustering. In \textbf{Layer 5}, the embeddings are broadly distributed with smoother contours, reflecting simpler representations and weaker clustering, as features like "remember" and "analyze" occupy low-density regions. By \textbf{Layer 15}, the embeddings exhibit tighter groupings with moderately complex density contours, striking a balance between sparsity and feature abstraction. This layer shows improved clustering, with features such as "apply" and "evaluate" moving closer to high-density regions. Finally, in \textbf{Layer 28}, the clusters become highly concentrated, demonstrating refined and discriminative representations; however, the increased complexity may reduce generalization. Overall, Layer 15 emerges as the optimal balance between feature complexity and sparsity, offering robust yet interpretable clustering of cognitive processes.


}
\clearpage
\eat{

\section{Prompt used for dataset creation}
We are adhering to the prompt flow to generate the data in three steps.
\label{sec: datacretae}
\subsection*{Step 1}





\definecolor{lightgray}{RGB}{245,245,245}
\definecolor{darkblue}{RGB}{0,0,139}
\definecolor{darkgreen}{RGB}{0,100,0}

\lstdefinestyle{jsonStyle}{
    basicstyle=\ttfamily\small,
    numbers=none,
    keywordstyle=\color{blue},
    stringstyle=\color{red},
    commentstyle=\color{gray},
    backgroundcolor=\color{lightgray},
    frame=none,
    breaklines=true
}



\begin{tcolorbox}[
    colback=white,
    colframe=blue!75!black,
    title=C++ Question Generation Prompt,
    fonttitle=\bfseries
]
You are a C++ programming expert. Create \{count\} simple questions to demonstrate \{topic\} in C++.

Please respond only with a JSON object in the following format, with no additional text or explanations:

\begin{lstlisting}[style=jsonStyle]
{
    "questions": [
        {
            "id": {start_id},
            "type": "{topic}",
            "language": "cpp",
            "level": "{level}",
            "title": "Brief title of the question",
            "description": "Clear problem statement",
            "code": "Complete C++ code solution without comments",
            "expected_output": "Expected output of the program"
        }
        // ... repeat for {count} questions
    ]
}
\end{lstlisting}

\textbf{Requirements:}
\begin{itemize}
    \item Provide exactly \{count\} questions
    \item Start IDs from \{start\_id\}
    \item Each question must focus on \{topic\}
    \item Difficulty level should be \{level\}
    \item Code should be complete and runnable
    \item Do not include any comments in the code
    \item Make sure the JSON is properly formatted and valid
    \item Do not include any explanatory text outside the JSON structure
\end{itemize}

\textbf{Variables:}
\begin{itemize}
    \item \texttt{topic}: Function types (recursive, array, call by reference, etc.)
    \item \texttt{level}: easy, medium, or hard
    \item \texttt{count}: Number of questions to generate (default: 5)
    \item \texttt{start\_id}: Starting ID for question numbering
\end{itemize}
\end{tcolorbox}



\subsection*{Step 2}





\begin{tcolorbox}[
    colback=white,
    colframe=blue!75!black,
    title=Code Variations Generation Prompt,
    fonttitle=\bfseries
]
\textbf{Prompt Structure:}

\begin{lstlisting}[style=jsonStyle]
{
    "task": "code_variations",
    "instructions": "Generate exactly 4 variations of the given code that represent common student mistakes. 
    Return the response in JSON format with numbered variations.
    Each variation should only contain the code itself without any explanations.",
    "input": {
        "description": "<problem description>",
        "original_code": "<original code>"
    },
    "output_format": {
        "variation_1": "first code variation",
        "variation_2": "second code variation",
        "variation_3": "third code variation",
        "variation_4": "fourth code variation"
    },
    "response_format": "Respond only with a valid JSON object containing the four variations."
}
\end{lstlisting}

\textbf{Purpose:}
\begin{itemize}
    \item Generate variations of original code representing common student mistakes
    \item Create exactly 4 different variations
    \item Return results in structured JSON format
\end{itemize}

\textbf{Input Parameters:}
\begin{itemize}
    \item \texttt{description}: Problem description text
    \item \texttt{original\_code}: Source code to generate variations from
\end{itemize}

\textbf{Output Requirements:}
\begin{itemize}
    \item Valid JSON object
    \item Four numbered variations
    \item Code only, no explanations
    \item Each variation represents a common mistake
\end{itemize}
\end{tcolorbox}

\subsection*{step 3}




\begin{tcolorbox}[
    colback=white,
    colframe=blue!75!black,
    title=Code Review Feedback Prompt,
    fonttitle=\bfseries
]
\textbf{Input Structure:}

\begin{lstlisting}[style=jsonStyle]
{
    "system": "You are a code review assistant specialized in analyzing programming problems and their implementations.",
    "task": {
        "instruction": "Analyze the given code implementation and provide structured feedback",
        "context": {
            "problem_description": "<problem description>",
            "code_to_analyze": "<code>"
        }
    },
    "output_schema": {
        "type": "json",
        "required_format": {
            "code_analysis": {
                "high_level_summary": {
                    "type": "string",
                    "description": "Brief overview of the implementation approach",
                    "max_sentences": 2
                },
                "general_analysis": {
                    "type": "string",
                    "description": "Analysis of code structure, efficiency, and potential issues",
                    "max_sentences": 5
                },
                "detailed_review": {
                    "type": "string",
                    "description": "Comprehensive review including specific improvements and edge cases",
                    "max_sentences": 10
                }
            }
        }
    }
}
\end{lstlisting}

\textbf{Required Response Format:}

\begin{lstlisting}[style=jsonStyle]
{
    "code_analysis": {
        "high_level_summary": "PROVIDE_2_SENTENCE_SUMMARY",
        "general_analysis": "PROVIDE_5_SENTENCE_ANALYSIS",
        "detailed_review": "PROVIDE_10_SENTENCE_DETAILED_REVIEW"
    }
}
\end{lstlisting}

\textbf{Response Requirements:}
\begin{itemize}
    \item Must be valid JSON format
    \item No additional text outside JSON structure
    \item High-level summary limited to 2 sentences
    \item General analysis limited to 5 sentences
    \item Detailed review limited to 10 sentences
\end{itemize}

\textbf{Input Parameters:}
\begin{itemize}
    \item \texttt{problem\_description}: Original problem statement
    \item \texttt{code\_to\_analyze}: Code implementation to review
\end{itemize}

\textbf{Analysis Levels:}
\begin{itemize}
    \item \textbf{High-level Summary:} Brief overview of implementation approach
    \item \textbf{General Analysis:} Code structure, efficiency, and potential issues
    \item \textbf{Detailed Review:} Comprehensive review with improvements and edge cases
\end{itemize}
\end{tcolorbox}

}



