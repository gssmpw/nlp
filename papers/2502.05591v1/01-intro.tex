\section{Introduction}

Ensuring consistency among nodes in a distributed system is essential, yet it is a difficult task in the face of potential failures or malicious behavior. Agreement protocols serve as indispensable tools for achieving consensus in such environments. One such fundamental primitive is Approximate Agreement ($\approximateagreement$) \cite{JACM:DLPSW86}. Even in the presence of $t$ byzantine parties (i.e., malicious nodes) among the $n$ parties involved, $\approximateagreement$ enables the honest parties to obtain \emph{very close} values that are in the range of honest inputs. This relaxed form of agreement has proven essential in scenarios where exact consensus is either unnecessary or infeasible, such as clock synchronization \cite{PODC:LenLos22}, blockchain oracles \cite{delphi24}, distributed machine learning \cite{PODC:EGHR20,SuVai16,federated20, federated21}, aviation control systems \cite{OPODIS:StolWat15, IEEE:MelWat18} or robot gathering \cite{NBiS:PoRaTi11} on various map structures.



The $\approximateagreement$ problem is not limited to real-valued inputs. Multiple variants have been considered in the past decade: multidimensional real values, and also discrete settings, such as lattices and different classes of graphs. These variants generalize the requirement of providing the honest parties with outputs in the \emph{honest inputs' range} to outputs in the \emph{honest inputs' convex hull}. In this work, we focus on $\approximateagreement$ on trees, where the partiesâ€™ input values are from a pre-defined tree-structured space, rather than from a continuous real-valued domain. 


Regardless of the space considered, the $\approximateagreement$ problem allows for very elegant algorithms with a common outline. Such algorithms operate in iterations. In each iteration, the parties use some mechanism to distribute their current values to all parties within $O(1)$ rounds of communication. Each party computes a \emph{safe area} based on the values it has received: this will be included in the set of values held by the honest parties at the beginning of the iteration. Afterward, each party computes its new value as \emph{a midpoint} of the safe area obtained. The honest parties' new values come with certain properties: they are included in the honest parties' values convex hull at the beginning of the iteration, and the honest parties' new values get \emph{closer}. This way, after a sufficient number of iterations, $\approximateagreement$ is achieved.

An important aspect is then \emph{how fast} the honest parties' values converge. When considering input spaces such as $\mathbb{R}$, paths, and trees, the range of honest parties' values is often halved with each iteration \cite{JACM:DLPSW86, DISC:NoRy19}. That is, after $R$ iterations, such protocols reduce the honest values' range, or diameter, by a (multiplicative) factor of $2^{-R}$.
% $K = 1/2$ \msnote{We should use the new notation here?}. 
Then, if the honest inputs' range has length $\ell$ and we require the outputs to be $\varepsilon$-close for some predefined $\varepsilon > 0$, $O(\log (\ell / \varepsilon))$ rounds are sufficient. On the other hand, this factor is not optimal on $\mathbb{R}$ in the synchronous model (where all messages get delivered within a predefined publicly known amount of time). Fekete \cite{Fekete90} has shown an upper bound on the convergence rate in $\mathbb{R}$: roughly, every $R$-round protocol reduces the honest parties' values range by a factor of at least $\frac{t^R}{R^R \cdot (n + t)^R}$, leading to a lower bound on the round complexity of $o(\log (\ell / \varepsilon))$. This bound has been shown to be asymptotically tight on real numbers \cite{Fekete90,BenDoHo10,PODC:GhLiWa22}, through protocols that deviate from the standard outline by making use of information obtained in prior iterations (i.e. detecting byzantine parties that tried to send different values to different parties).

While the optimal round complexity for synchronous $\approximateagreement$ on real numbers is well understood, its generalization to other input spaces remains an open problem. Notably, existing results for $\approximateagreement$ on real numbers extend naturally to paths. In this work, we build upon these foundations and further generalize them to trees. Specifically, we investigate the following question:

\vspace{0.3cm}
\begin{center}
    \fbox{%
        \parbox{0.9\linewidth}{%
            \centering
            \emph{What is the optimal round complexity for synchronous $\approximateagreement$ on trees?}
        }
    }
\end{center}
\vspace{0.3cm}


\subsection{Our Contribution}
We provide a synchronous protocol achieving $\approximateagreement$ on trees with round complexity $O\left( \frac{ \log \vertices(T) }{\log \log \vertices(T)} \right)$, where $\vertices(T)$ denotes the number of vertices of the input tree $\tree$. Our protocol relies on novel techniques in order to reduce the problem to $\approximateagreement$ on real values, and uses the protocol of \cite{BenDoHo10} as a building block.
In addition, we explain how Fekete's bound regarding \emph{convergence factors} (and hence round complexity) can be adapted to trees: we show that, under the assumption that a constant fraction of the parties is corrupted, 
$\Omega(\frac{\log \diameter(\tree)}{\log \log \diameter(\tree)})$ rounds are necessary for any $\approximateagreement$ protocol, where $\diameter(\tree)$ denotes the diameter of the input tree $\tree$.
Hence, our protocol achieves optimal round complexity for trees of large diameter $\diameter$.



\subsection{Related work}
\paragraph{Real values.}
The problem of $\approximateagreement$ was first introduced for real values by Dolev, Lynch, Pinter, Strong, and Weihl~\cite{JACM:DLPSW86}. This initial work investigated the feasibility of achieving $\approximateagreement$ on $\realvalues$, both in the synchronous model and in the asynchronous model (where messages get delivered \emph{eventually}). Concretely, \cite{JACM:DLPSW86} has presented a synchronous protocol resilient against $t < n / 3$ corruptions, which is optimal in settings with no cryptographic assumptions, and an asynchronous protocol resilient against $t < n/5$ corruptions. The condition $t < n / 3$ has been later proven to be sufficient and necessary in the asynchronous by Abraham, Amit, and Dolev~\cite{OPODIS:AAD04}. Under cryptographic assumptions, the necessary and sufficient condition in the synchronous model becomes $t < n / 2$ \cite{PODC:GhLiWa22, PODC:LenLos22}. Moreover, the work of \cite{PODC:GhLiWa22} has provided tight conditions for achieving $\approximateagreement$ on real values in the \emph{network-agnostic} model, presenting a protocol achieving $\approximateagreement$ up to $t_s$ corruptions if it runs in a synchronous network, and up to $t_a$ corruptions if it runs in an asynchronous network if the necessary condition $2 \cdot t_s + t_a < n$ holds.

Each of these protocols requires $O(\log(b - a) / \varepsilon)$ rounds of communication if the honest parties' inputs are in $[a, b]$: roughly, each iteration halves the honest values. The work of \cite{JACM:DLPSW86} has also shown that such \emph{convergence factor} is optimal for a specific class of protocols where parties do not use information obtained in the prior iterations. The works of Fekete \cite{Fekete90,FeketeFixed87} investigate this further and provide lower bounds on \emph{how close the honest values' may get} after $R$ rounds, considering various kinds of failures (crashes, omission, byzantine), both in the synchronous model and in the asynchronous model. The lower bound in asynchrony under byzantine failures matches the convergence factor of $1/2$ per round/iteration obtained by asynchronous $\approximateagreement$ protocols. On the other hand, in the synchronous model with byzantine failures, \cite{Fekete90} shows that any $R$-round $\approximateagreement$ protocol reduces the honest values' range by a (multiplicative) factor of at least $K(R) \geq \frac{t^R}{R^R \cdot (n + t)^R}$ as opposed to the factor $2^{-R}$ obtained by prior $R$-iteration $\approximateagreement$ protocols. The lower bound $K(R)$ is known to be asymptotically tight: \cite{Fekete90} has provided an asymptotically matching protocol assuming $t < n / 4$, with message complexity $O(n^R)$. Later, \cite{BenDoHo10} has improved the resilience threshold to $t < n / 3$ and the message complexity to $O(R \cdot n^3)$. In addition, with minor adjustments, the \emph{Proxcensus} protocol of \cite{EUROCRYPT:GhGoLi22} becomes an $\approximateagreement$ protocol that matches Fekete's lower bound for $t = (1 - c)/2 \cdot n$ corruptions assuming digital signatures, for any constant $c > 0$.

Optimizations regarding communication complexity have also been considered. The work of \cite{MoseArxivNew} has achieved optimal-resilience asynchronous $\approximateagreement$ with $O(n^2)$ messages per iteration as opposed to the prior solutions of $O(n^3)$ \cite{OPODIS:AAD04}, and the work of \cite{PODC:GhLiWa24} has shown that $O(\ell n)$ bits are sufficient to achieve a stronger version of $\approximateagreement$ (with exact agreement) on $\ell$-bit integer inputs, given that $\ell$ is large enough.


\paragraph{Multiple dimensions.} 
For higher-dimensional spaces $\mathbb{R}^D$, $\approximateagreement$ was first studied in~\cite{PODC:VaiGar13, STOC:MenHer13,DIST:MHVG15}.
These works have shown sufficient and necessary conditions for achieving $\approximateagreement$ on $\mathbb{R}^D$ in the asynchronous setting. In addition, \cite{PODC:VaiGar13} has characterized the exact-agreement variant of the problem in the synchronous setting. Feasibility in the network-agnostic model was investigated in \cite{SPAA:GhLiWa23}. The work of \cite{DISC:FugNow18} has focused on efficiency, investigating various rules of computing a new value, leading to different convergence rates. 
The work of \cite{ARXIV:CamMel23} has focused on achieving a trade-off between the quality of the outputs, i.e. \emph{honest inputs' convex hull} vs. \emph{bounding box} and resilience thresholds.

To the best of our knowledge, optimal-round complexity solutions for $\realvalues^D$ represent an open problem in \emph{message-passing} models. On the other hand, the recent work of \cite{OPODIS:AttEll22} provides lower bounds and efficient protocols for $\approximateagreement$ on $\realvalues^D$ in the \emph{wait-free model}: where at most $t < n$ parties may crash and the parties communicate via shared memory.


\paragraph{Trees and graphs.} $\approximateagreement$ on graphs has been first considered in \cite{DISC:ACFR19}  as a relaxation of the \emph{robot gathering} problem \cite{GatheringRing, GatheringBipartite} that can be solved in the wait-free model. The work of \cite{DISC:ACFR19} has introduced two variants: \emph{Edge Agreement}, where the honest parties obtain vertices that are either the same or adjacent, or \emph{Clique Agreement}, where the honest parties' outputs are in a clique. Note that, on trees, these two problems are equivalent. The work of Nowak and Rybicky \cite{DISC:NoRy19} has generalized the $\approximateagreement$ problem in the synchronous and asynchronous models to various discrete spaces under byzantine failures, providing asynchronous $\approximateagreement$ protocols for trees and \emph{chordal} graphs where the diameter of the honest parties' values gets halved with each iteration. However, \cite{eprint:ConvexWorld} has proven the efficient asynchronous protocol on \emph{chordal} graphs of \cite{DISC:NoRy19} to be incorrect, and provided a network-agnostic protocol that requires $O(\diameter)$ rounds, where $\diameter$ is the diameter of the graph. Whether the round complexity can be improved is an open problem.

A topic of interest regarding $\approximateagreement$ on graphs is characterizing the classes of graphs where $\approximateagreement$ can be achieved: the protocols of \cite{DISC:NoRy19,eprint:ConvexWorld} assume that the input graph is \emph{chordal}. Further works have explored properties that the input graph needs to satisfy for $\approximateagreement$ in the wait-free model \cite{SIROCCO:Alistarh21, OPODIS:Liu23}.

Regarding efficient solutions, the recent work of \cite{MoseArxivNew} has provided a solution asynchronous $\approximateagreement$ on trees with message complexity $O(n^2)$ per iteration as opposed to $O(n^3)$ \cite{DISC:NoRy19}, maintaining the convergence factor of one half per iteration.


