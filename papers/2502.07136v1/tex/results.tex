\section{Simulation Results}\label{section:simulation}
The proposed algorithm is simulated on the MATLAB software\footnote{Code at \hyperlink{https://github.com/HybridSystemsLab/HybridGloballyPathInvariantControl.git}{https://github.com/HybridSystemsLab/PathInvariantControl.git}.}. 
\subsection{\nw{CBF-based Singularity Filter Prevents Singularity Points}}
We simulate the controller $\kappa_0 = (\kappa_\xi,\kappa_\eta)$ from~\eqref{eq:kappa_0}. To achieve finite-time path stability and invariance, we use $v^\pitchfork = \kappa_\xi(\xi)$ from~\eqref{eq:v_trans}. Figure~\ref{fig:local-xy-position} shows the system output converging to the desired path, while Figure~\ref{fig:local-xi-states} confirms $\xi$ remains on the path, ensuring forward invariance. To track the speed profile $\eta^{\mathrm{ref}}_2 = \sin(t)$ while satisfying the barrier constraint, an optimization-based control scheme is used.
% As shown in Figure~\ref{fig:local-xy-position}, the output of the system converges to the desired path, and as seen in Figure~\ref{fig:local-xi-states}, the $\xi$ state always remains on the path, i.e., the path is forwarded invariant. To track a given speed profile $\eta^{\mathrm{ref}}_2 = \sin(t)$ while ensuring the barrier constraint an optimization-based control scheme is proposed. 
Concretely, we solve the following Quadratic Program (QP) based controller:
\myifconf{$$
\begin{aligned}
\hspace{10pt} \arg \min_{(v^\parallel,\delta_s)} & \quad \frac{1}{2}(v^\parallel)^2 + p \delta_s^2\\
    % \textrm{s.t.} \;\quad \; \; Av  \leq &  \; b, \label{C1 cont const}\\
    \textrm{s.t.} \; L_{\tilde f}V(\eta) + & L_{\tilde g} V(\eta)v^\parallel \leq -\alpha_k (V(\eta)) + \delta_s\label{eq:QP_lyapunov}\\
    \; L_{\tilde f}^2b(\eta) + & L_{\tilde f}b(\eta) +L_{\tilde g}L_{\tilde f}b(\eta)v^{\parallel} 
    \leq -\alpha_k( b(\eta) + L_{\tilde f}b(\eta) ),\label{eq:QP_barrier}
\end{aligned}
$$}{\begin{subequations}\label{QP-based-control}
\begin{align}
\hspace{10pt} \arg \min_{(v^\parallel,\delta_s)} & \quad \frac{1}{2}(v^\parallel)^2 + p \delta_s^2\\
    % \textrm{s.t.} \;\quad \; \; Av  \leq &  \; b, \label{C1 cont const}\\
    \textrm{s.t.} \; L_{\tilde f}V(\eta) + & L_{\tilde g} V(\eta)v^\parallel \leq -\alpha_k (V(\eta)) + \delta_s\label{eq:QP_lyapunov}\\
    \; L_{\tilde f}^2b(\eta) + & L_{\tilde f}b(\eta) +L_{\tilde g}L_{\tilde f}b(\eta)v^{\parallel} 
    \leq -\alpha_k( b(\eta) + L_{\tilde f}b(\eta) ),\label{eq:QP_barrier}
\end{align}
\end{subequations}}
where $\delta_s$ is a relaxation variable that ensures the solvability of the QP as penalized by $p>0$. \myifconf{Figure~\ref{fig:local-eta1-eta2} shows that the barrier condition is never violated. The robot follows the reference velocity profile when $\eta_2 \geq 0.02$, and maintains a positive velocity when $\eta_2 < 0.02$. This guarantees forward invariance, as trajectories never reach $\vrm + x_5 =0$.}{As shown in Figure~\ref{fig:local-eta1-eta2}, the barrier condition is never violated. In other words, the robot follows the given reference velocity profile whenever $\eta_2 \geq 0.02$, and when $\eta_2 < 0.02$, the velocity of the robot stays at some positive distance away from zero. Therefore, \nw{forward invariance} is guaranteed, as the system trajectories never reach the singularity point $\vrm + x_5 = 0$.}
\begin{figure}[t]
 \centering
 \begin{subfigure}{0.45\columnwidth}
    \centering
    \includegraphics[width = \columnwidth]{Figures/QP-local-sim/unit_circle.eps}
    \caption{The controller $\kappa_{\xi}$ ensures finite-time convergence to the desired curve.}
    \label{fig:local-xy-position}
 \end{subfigure}
 \begin{subfigure}{0.45\columnwidth}
    \centering
    \includegraphics[width = \columnwidth]{Figures/QP-local-sim/xi_state.eps}
    \caption{The controller $\kappa_{\xi}$ ensures the path is forward invariant.}
    \label{fig:local-xi-states}
 \end{subfigure}
 % \caption{Barrier certified local path invariant controller}
 \label{fig:sim}
 % \end{figure}
 % \begin{figure}[htbp]
 \centering
 \begin{subfigure}{0.45\columnwidth}
    \centering
    \includegraphics[width = \columnwidth]{Figures/QP-local-sim/eta1_eta2.eps}
    \caption{The barrier condition ensures that $\eta_2$ remains strictly positive.}
    \label{fig:local-eta1-eta2}
 \end{subfigure}
 \begin{subfigure}{0.45\columnwidth}
    \centering
    \includegraphics[width = \columnwidth]{Figures/QP-local-sim/speed.eps}
    \caption{On the path, the forward velocity $\vrm + x_5 = \eta_2$.}
    \label{fig:local-speed}
 \end{subfigure}
 \caption{CBF-based singularity filter prevents singularity point.}
 \label{fig:sim}
  \vspace{-0.2cm}
 \end{figure}
 \begin{figure}[t]
 \centering
 \begin{subfigure}{0.45\columnwidth}
    \centering
    \includegraphics[width = \columnwidth]{Figures/hybridControlResults.eps}
    \caption{The simulated trajectory of the robot tracking a sinusoidal desired path.}
    \label{fig:hybrid}
 \end{subfigure}
 \begin{subfigure}{0.45\columnwidth}
    \centering
    \includegraphics[width = \columnwidth]{Figures/stateEvolution1.eps}
    \caption{The evolution of $x_{3}$, $x_{4}$, and error. }
    \label{fig:states}
 \end{subfigure}
 \caption{Simulation results of the proposed hybrid controller.}
 \label{fig:sim}
 \vspace{-0.8cm}
 \end{figure}
\subsection{\nw{Hybrid Control Framework Achieves Global Path Invariance}}
\myifconf{We present hybrid control results that ensure path invariance with safety guarantees and finite-time global convergence. Figure \ref{fig:sim} shows the simulations. In Figure \ref{fig:hybrid}, the motion planner's auxiliary trajectory is a black dotted line, the desired sinusoidal path $\Gamma$ is green dotted, and obstacles are red squares. The robot's trajectory under $\kappa_{1}$ is purple (solid), and under $\kappa_{0}$ is blue (solid). The robot follows $\kappa_{1}$ until $t = 15$, then switches to $\kappa_{0}$, maintaining the path thereafter. Figure \ref{fig:states} shows the evolution of $x_{3}$, $x_{4}$, and the distance between the robot and the desired path. The bottom plot illustrates that the error decreases under $\kappa_{1}$ and remains zero after switching to $\kappa_{0}$, demonstrating path invariance.}{Next, we demonstrate the results of hybrid control, which not only renders the path invariant with a safety guarantee but also depicts global convergence to the given path in finite time. The simulation results are shown in Figure \ref{fig:sim}. In Figure \ref{fig:hybrid}, the auxiliary trajectory generated by the motion planning module is represented by the dotted line in black. The given sinusoidal desired path $\Gamma$ is represented by the dotted line in green. The obstacles are represented by the red squares. The solid line in purple denotes the trajectory of the robot under the control of $\kappa_{1}$ and the solid line in blue denotes the trajectory of the robot under the control of $\kappa_{0}$. In Figure \ref{fig:hybrid}, the robot is under the control of $\kappa_{1}$ before entering a neighborhood of $\Gamma$ at $t = 15$. Then the control is switched to $\kappa_{0}$ and the trajectory of the robot stays on the path afterward. Figure \ref{fig:states} shows the evolution of $x_{3}$, $x_{4}$, and the distance between the output position and desired path. As is shown in the bottom of Figure \ref{fig:states}, the error between the robot and the desired path decreases when the $\kappa_{1}$ is in control and the error remains zero after $\kappa_{0}$ takes over the control. This demonstrates the path-invariance property.}


% The error metric in this simulation is defined as follows
% $
%     \texttt{error}(t, x, q) := \left\{
%     \begin{aligned}
%         &e_{0}(x)&\text{ if } q = 0\\
%         &e_{1}(t, x)&\text{ if } q = 1
%     \end{aligned}
%     \right.
% $ where
% $
%     e_{0}(x) := |\sin(x_{1}) - x_{2}|
% $ and 
% $
%     e_{1}(t, x) := \sqrt{(x'_{1}(t) - x_{1}(t))^{2} + (x'_{2}(t) - x_{2}(t))^{2}}.
% $

\myifconf{}{\section{Experimental Results}\label{section:experiment}
\begin{figure}[htbp]
 \centering
 \begin{subfigure}{0.48\columnwidth}
    \includegraphics[width = \columnwidth]{Figures/experiment1.eps}
    \caption[size=0.5]{Experiment result starting from the center of reference circle.}
    \label{fig:bestGP}
 \end{subfigure}
 \begin{subfigure}{0.48\columnwidth}
    \includegraphics[width = \columnwidth]{Figures/experiment2.eps}
    \caption{Experiment result starting from the outside of reference circle.}
    \label{fig:exp2}
\end{subfigure}
%  \begin{subfigure}{0.48\columnwidth}
%     \includegraphics[width = \columnwidth]{Figures/exp1Error.eps}
%     \caption{Distance error over time}
%     \label{fig:circleerror}
% \end{subfigure}
\caption{Experiment Results}
\label{fig:exp1}
\end{figure}
% In this experiment we use OSOYOO Robot Car that features a servo power steering motor that controls the axles to turn the wheels. This electric power steering system enables a highly automated driving experience that imitates real-world full-sized rear-wheel robots. The car has two DC motors with a maximum speed of 100 RPM. The motor driver is an L298N dual H-bridge driver, which allows controlling the direction and speed of the motors. The car is powered by a $9$V battery. The car is approximately $225$mm$\times$$150$mm$\times$$75$mm and weighs about $650$g, including the battery. The diameter and thickness of the wheels are $65$mm and $26$ mm, respectively. The car is equipped with an Arduino Uno board (referred to as the onboard computer), including a Bluetooth module, which enables the user to send and receive data (control command and system state) via an off-board computer. In our experimental setup, infrared markers are attached to the robot, and using a mocap indoor positioning system, the position and orientation of the robot are determined at the off-board computer. The steering angle information is sent from the onboard computer to the off-board computer. The hybrid control algorithm is run off-board, and the control commands are sent via Bluetooth to the onboard computer.   
The proposed algorithm is validated through real-world experiments, accounting for the presence of noise and model uncertainties. In the experiment, we use the OSOYOO Robot Car, which simulates real rear-wheel robots via a servo power steering motor that controls the axles. 
% The car boasts two DC motors with a max speed of $100$ RPM, managed by an L298N dual H-bridge driver. 
The car measures approximately $225$mm $\times$ $150$mm $\times$ $75$mm.
% and weighs $650$g with the battery. 
% It's equipped with an Arduino Uno board with Bluetooth for data exchange. 
In the experimental setup, the robot's position and orientation are tracked by a motion capture indoor positioning system. Steering commands are transmitted via Bluetooth from an off-board computer that executes the hybrid control algorithm. 
%Due to space limit, more details and experiment results are presented in  \cite{wang2023hybrid}.

% In the setup, infrared markers and a mocap indoor positioning system track the robot's position and orientation, while steering commands are sent via Bluetooth from an off-board computer running the hybrid control algorithm.

The results of running the proposed algorithm on the scaled car are shown in Figure \ref{fig:exp1}, with the desired path being a circle. In the experiments, a scaled car is controlled by the proposed algorithm to track the same desired path starting from different initial positions. 
% The results of running the proposed algorithm on the scaled car are shown in Figure \ref{fig:exp1}, with the reference path being a circle. In the experiments, a scaled car is controlled by the proposed algorithm to track the circle reference path starting from its center, which is a singularity point of $\kappa_0$. In the experiments tracking a circle path with radius $R$, the error metric is defined as
% The error metric is defined as
% $\label{eq:errorcircle}
%     \texttt{error}(t, x, q) := \left\{
%     \begin{aligned}
%         &e_{0}(x)&\text{ if } q = 0\\
%         &e_{1}(t, x)&\text{ if } q = 1
%     \end{aligned}
%     \right.
% $ where
% $
%     e_{0}(x) := \norm{\sqrt{x_{1}^{2} + x_{2}^{2}} - R}
% $ and 
% $
%     e_{1}(t, x) := \sqrt{(x'_{1}(t) - x_{1}(t))^{2} + (x'_{2}(t) - x_{2}(t))^{2}}.
% $

In the first experiment, the initial position is the center of the reference circle which is a singularity point of $\kappa_0$. In Figure \ref{fig:bestGP}, it is shown that the proposed algorithm firstly generates an auxiliary trajectory and employs pure pursuit controller $\kappa_{1}$ to track the auxiliary trajectory to leave the singularity point and to approach the desired path. After the robot arrives in the neighborhood of the desired path, the locally path-invariant controller $\kappa_{0}$ is triggered to control the robot and the robot stays invariant on the desired path. 
% The error during this process computed by (\ref{eq:errorcircle}) is shown in Figure \ref{fig:circleerror}. 
% The error decreases at the beginning when the pure pursuit controller is in use, meaning that the car is approaching to the reference path and leaving the singularity point. After the switch is triggered and $\kappa_{0}$ takes over the control at $t = 4.3$ seconds, the error stays constantly close to zero, which means that the car stays on the reference path.

 % In Figure \ref{fig:bestGP}, it is shown that the proposed algorithm  firstly generates an auxiliary trajectory and employs pure pursuit controller $\kappa_{1}$ to track the auxiliary trajectory to leave the singularity point and to approach to the reference path. After the robot arrives in the neighborhood of the reference trajectory, the locally path-invariant controller $\kappa_{0}$ is triggered to control the robot reaches and stay invariant on the reference path. The error during this process computed by (\ref{eq:errorcircle}) is shown in Figure \ref{fig:circleerror}. The error decreases at the beginning when the pure pursuit controller is in use, meaning that the car is approaching to the reference path and leaving the singularity point. After the switch is triggered and $\kappa_{0}$ takes over the control at $t = 4.3$ seconds, the error stays constantly close to zero, which means that the car stays on the reference path.


 In the second experiment shown in Figure \ref{fig:exp2}, the settings are the same except that the initial position of the robot is changed to $(3.5, -1.2)$ which is not a singularity but rather more general. Following the same procedure, the proposed algorithm starts with generating an auxiliary trajectory and using $\kappa_{1}$ when the robot is away from the desired path. Then it switches to $\kappa_{0}$ and stays invariant on the path when it is in the neighborhood of the desired path.}
 
 % \pn{The invariance property is illustrated by both of the experimental results. The error plots in both figures show that no matter where the initial position of the robot is, the robot's position will end up with a constant small error from the reference path. }
 
 
% Figure \ref{fig:beststates} shows the evolution of the first four state values in experiment 1. 





% There is some steady state oscillation in $\delta$, which is likely caused by the delay in the state update from the ADC. These can be smoothed out using filtering. It is beyond the scope of this paper to implement, but filtering techniques such as the standard Extended Kalman Filter could significantly reduce these oscillations by providing estimates of the state between measurements. 
% Figure \ref{fig:circleerror} plots the distance error from the robot to the path in meters. The error was calculated as \(e = R - \sqrt{x^2 + y^2}\), where \(R\) is the radius of the circular path. Once the robot converges to the path, it stays within $0.02m$ for the rest of the experiment. From this, we can start to conclude invariance. This steady-state error is similar to that found in \cite{dynamictransvarsefeedback}, even though the robot is starting from a point that causes singularities in \(\kappa_0\).
% \begin{figure}
% \centering
%  \begin{subfigure}{0.48\columnwidth}
%     \centering
%     \includegraphics[width = \columnwidth]{Figures/experiment2.eps}
%     \caption{Practical results of hybrid controller on Osoyoo Sport Car}
%     \label{fig:outsidecircle}
%  \end{subfigure}
%  \hfill
%  \begin{subfigure}{0.48\columnwidth}
%     \centering
%     \includegraphics[width = \columnwidth]{Figures/exp2_error.eps}
%     \caption{Distance error over time}
%     \label{fig:Farcircleerror}
%  \end{subfigure}
%  \caption{Experiment 2}
%  \label{fig:exp2}
%  \end{figure}

% Figure \ref{fig:exp2} shows the results of Experiment 2. The robot was placed as far from the path as possible for the confined lab space of this experiment. While this point is not a singularity point of \(\kappa_0\), there is a large obstacle shown on the plot in Figure \ref{fig:outsidecircle}  that is blocking the trajectory that \(\kappa_0\) would typically take to converge to the path. It is also a helpful demonstration of how the addition of \(\kappa_1\) aids in the convergence to the path from distant points in euclidean space. Looking at the trajectory generated by \(\kappa_1\), we can note how the final orientation of the car aligns with the path, giving \(\kappa_0\) an ideal initial position. 
% Figure \ref{fig:outsidecirclestates} shows similar results to Figure \ref{fig:beststates}.
% Again, there are steady-state oscillations in \(\delta\). However, these oscillations in the steering angle have little effect on the steady-state of the position error. Figure \ref{fig:Farcircleerror} shows the error converging to zero and staying within the same range of \(0.02m\), supporting the claim to invariance. 

% \subsection{Proof of global invariance}
% The results exhibited in Figures \ref{fig:exp1} and \ref{fig:exp2} provide strong evidence that the hybrid controller proposed in this paper makes the previously defined subclass of curves invariant. The controller has been shown to converge and track an example path from different initial conditions with minimal steady-state error. To further prove the invariance, we can analyze the properties of the two controllers, \(\kappa_0\) and \(\kappa_1\). The controller \(\kappa_0\) has been shown to make the desired path locally invariant\cite{dynamictransvarsefeedback}, so we need to prove that \(\kappa_1\) makes the desired path attractive. From the motion planner in \cite{nwang2021motion}, we know that we will always generate a trajectory from the robot position to the path if it exists. Since the motion planner uses the system kinematics to form its trajectory, we know it will always be feasible and controllable. Hence, our pure pursuit controller will always be able to follow trajectories given by the motion planner and, therefore, always evolves the state towards the desired path. 