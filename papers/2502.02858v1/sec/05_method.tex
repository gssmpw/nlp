\section{Projected Safe Set Algorithm for Infeasible Constraint Sets}
\label{sec:method}

In this section, we propose several approaches to handling infeasible safe control problems.
To facilitate further derivation, we first expand the safe control constraints in \eqref{prob:multi_safe_control} by plugging in the system dynamics as follows.
\begin{align}\label{eq:expand_safe_constraint}
\dot{\bphi}(x,u) &= \underbrace{\frac{\partial\bphi}{\partial x}f(x)}_{L_f\bphi(x)} + \underbrace{\frac{\partial\bphi}{\partial x}g(x)}_{L_g\bphi(x)} u \\\nonumber
&= L_f\bphi(x) + L_g\bphi(x) u \leq -\bETA
\end{align}
While our approaches are compatible with arbitrary task objective $\cJ$, we instantiate an example in this section to aid discussions.
We assume that \eqref{prob:multi_safe_control} operates as a safety filter at the downstream of some nominal controller.
With nominal control signal $u_\mathrm{ref}$, we can set $\cJ(x,u) = \|u-u_\mathrm{ref}\|_{2,Q}^2$ to compute a minimally invasive control $u_\mathrm{safe}$ that satisfies safety constraints.
Incorporating the control limits as well, \eqref{prob:multi_safe_control} can be written as
\begin{subequations}\label{prob:naive_ssa}
\begin{align}
\minimizewrt{{u}}~~ & \|u-u_\mathrm{ref}\|_{2,Q}^2   \\
\st~~ & L_f\bphi(x) + L_g\bphi(x) u \leq -\bETA~\mathrm{if}~\bphi(x) \geq 0  \label{eq:infeas_ssa_contr_lie} \\ 
& u^- \leq u \leq u^+ \label{eq:control_limit}
\end{align}
\end{subequations}

\subsection{Relaxed Safe Set Algorithm}\label{sec:rssa}

When \eqref{prob:naive_ssa} becomes infeasible due to complex humanoid-environment interactions, the most straight-forward remedy is to incorporate slack variables that relaxes the constraints to allow feasible solutions.
Specifically, we introduce positive slack variables only for each of the safety constraints in \eqref{eq:infeas_ssa_contr_lie} since the control limits cannot be relaxed.
Hence, we have
\begin{subequations}\label{prob:rssa}
\begin{align}
\minimizewrt{{u, \bs}}~~ & \|u-u_\mathrm{ref}\|_{2,Q}^2+ \frac{1}{p}(\|\bs\|_{p,Q^{rssa}_s})^p  \\
\st~~ & L_f\bphi(x) + L_g\bphi(x) u \leq -\bETA + \bs ~\mathrm{if}~\bphi(x) \geq 0 \label{eq:safe_contr_rssa}\\ 
& u^- \leq u \leq u^+ \\
&  \bs \geq 0 
\end{align}
\end{subequations}
where $\bs\in\RR^{M}$ is the slack variable.
We regularize $\bs$ measured in $Q^{rssa}_s$-weighted $p-$norm, given by
\begin{equation}
\|\bs\|_{p,Q^{rssa}_s} = \left(\sum_{i=1}^{M}Q^{rssa}_{s,i}|\bs_i|^p\right)^{1/p}
\end{equation}
where $Q^{rssa}_s$ is a diagonal matrix with positive coefficients.
We refer to \eqref{prob:rssa} as Relaxed Safe Set Algorithm (r-SSA).
The solved $\bs$ indicates the cost of safety violations, and should be as close to zero as possible to try to respect the safety constraints.
As will be shown later, r-SSA can effectively produce safe control when the naive SSA \eqref{prob:naive_ssa} becomes infeasible, and enhances humanoid safety in cluttered environments.

Importantly, r-SSA optimizes a combination of both performance objective (i.e., the first term) and safety objectives (i.e., the second term), which may be conflicting in general.
It also balances multiple safety objectives represented by each $\phi_i$.
r-SSA may prioritize the performance (i.e., reference tracking) and accept large slack variables (i.e., significant safety violations) if partial safety objectives are dominated, especially when the weighting parameters $Q$ and $Q^{rssa}_s$ are not properly tuned.
As a result, r-SSA may still lead to critical safety failures in practice unless specifically tuned for each task.
This challenge motivates us to take another step by removing potential racing conditions between the two objectives, which will be covered in the next section.

\subsection{Projected Safe Set Algorithm}\label{sec:pssa}

% \ruic{state problem of parameter tuning for r-SSA}

% \ruic{propose p-SSA that finds the closest feasible constraint set with minimal safety violation measured by p-norm}

In this section, we propose the Projected Safe Set Algorithm (p-SSA) that improves over r-SSA by always respecting the safety constraints to the maximal extend.
The core idea behind p-SSA is to first project the current safe control constraint set, which can be infeasible, to the nearest feasible set.
The $u_\mathrm{safe}$ is only solved with the projected constraint set which is guaranteed to be feasible by the projection operation.
It can be shown that with such decoupling, p-SSA always operates within the maximal feasible region indicated by the given constraint set, while being totally tuning-free.

In phase I, the p-SSA first resolves infeasible safe control constraints in \eqref{prob:naive_ssa} by projecting the constraint set \eqref{eq:infeas_ssa_contr_lie}
 and \eqref{eq:control_limit} on to the nearest feasible region, measured by the $p$-norm of  total relaxation.
Specifically, we solve the following optimization
\begin{subequations}\label{prob:pssa_phase_1}
\begin{align}
\minimizewrt{\bs}~~ & \frac{1}{p}(\|\bs\|_{p,Q^{pssa}_s})^p  \\
\st~~ & L_f\bphi(x) + L_g\bphi(x) u \leq -\bETA + \bs ~\mathrm{if}~\bphi(x) \geq 0 \label{eq:safe_contr_pssa_phase_1}\\ 
& u^- \leq u \leq u^+ \label{eq:control_limit_pssa_phase_1}\\
&  \bs \geq 0
\end{align}
\end{subequations}
to compute an optimal slack variable $\bs^*$.
Then, in phase II, we solve $u_\mathrm{safe}$ with the solved relaxation $\bs^*$
\begin{subequations}\label{prob:pssa_phase_2}
\begin{align}
\minimizewrt{u}~~ & \|u-u_\mathrm{ref}\|_{2,Q}^2  \\
\st~~ & L_f\bphi(x) + L_g\bphi(x) u \leq -\bETA + \bs^* ~\mathrm{if}~\bphi(x) \geq 0 \label{eq:safe_contr_pssa_phase_2}\\ 
& u^- \leq u \leq u^+ \label{eq:control_limit_pssa_phase_2}
\end{align}
\end{subequations}
Since $\bs^*$ is feasible for \eqref{prob:pssa_phase_1}, we know that the constraints \eqref{eq:safe_contr_pssa_phase_1} with \eqref{eq:control_limit_pssa_phase_1} will be made feasible if relaxed by $\bs^*$ (i.e.,  \eqref{eq:safe_contr_pssa_phase_2} and \eqref{eq:control_limit_pssa_phase_2} ).
Hence, phase II is guaranteed to be feasible without additional relaxation. 
Notably, p-SSA does not involve any direct trade-off between performance and safety since they are optimized independently via \eqref{prob:pssa_phase_1} and \eqref{prob:pssa_phase_2}.
% It does not need any parameter tuning for balancing those objectives.
Meanwhile, p-SSA guarantees to operate with minimal safety violations thanks to Phase I.
As will be shown in the next section, p-SSA, in fact, achieves the top performance across various task settings without parameter tuning, while r-SSA only matches p-SSA performance with careful tuning.

\textbf{Remark.} Unlike $Q^{rssa}_s$, $Q^{pssa}_s$ only influences the balance among multiple constraints.
In practice, $Q^{pssa}_s$ should be chosen to reflect the relative importance of different constraints.
For example, more weight can be assigned to a constraint if it covers a critical aspect such as the safety of a high-torque link, or if it is closer to being violated (e.g., $\phi_i$ closer to zero).
In this paper, we set $Q^{pssa}_s$ to identity and leave the investigation of smart ways to balance multiple safety constraints for future work.

When implementing the above approaches, one needs to derive the two Lie derivatives, $L_f\bphi(x)$ and $L_g\bphi(x)$, based on the designed energy functions $\phi_i$ and plug into \eqref{eq:safe_contr_rssa} for r-SSA or \eqref{eq:safe_contr_pssa_phase_1} and \eqref{eq:safe_contr_pssa_phase_2} for p-SSA to complete the control constraints.
For readability, we provide an example derivation of control constraints based on first-order energy functions designed for both robot-obstacle collision and self-collision in Appendix \ref{append:safe_control_constraint}.
