\section{Related Work}
\label{sec:related}

\subsection{Sideways Information Passing (SIP)}

Sideways Information Passing (SIP) refers to techniques that optimize join operations by transmitting predicate information to the target table to facilitate tuple pre-filtering in a database. Existing SIP techniques can be categorized as Bloom join~\cite{bloomjoin, distributedbloomjoin, optimizingdistributedbloomjoin, zhu2017LIP} and semi-join reduction~\cite{usingsemi}. In Bloom join, a \BF is generated on the build side of a hash join and passed to the probe side to filter tuples before accessing the hash table. Semi-join reduction, on the other hand, applies a semi-join operation to pre-filter tuples before conducting the actual hash join.

Lookahead Information Passing (LIP)~\cite{zhu2017LIP} can be considered a special case of \RPT with star schema. LIP constructs \BFs for each dimension table and uses them to pre-filter the large fact table before performing the joins. LIP focuses on techniques to reorder the \BFs dynamically and adaptively to reduce the computational overhead of the SIP process. These techniques are orthogonal to our work and can also be applied to \rpt.

In contrast to the existing SIP approaches, \RPT provides strong theoretical guarantees on query robustness by applying pre-filtering (with \BFs) systematically based on the \YannAlg, rather than focusing on particular joins locally.

\subsection{Robust Query Processing}

Previous studies~\cite{2019tutorial_robust, robustoptimization} offer a comprehensive survey of robust query optimization methods. These methods target mitigating the impact of inaccurate cardinality estimations, and they can classified into two categories: robust plans~\cite{2002LEC, 2005RCE, 2007plan_diagram, 2008strict_plan_diagram, Abhirama2010BDSH, AlyoubiHW15, Wolf2018RobustMetric} and re-optimization~\cite{1998reopt, 1999reopt_shared_nothing, 2000eddies, 2004pop, 2007pop_parallel, 2016planbouquets, Perron19, 2023reopt_zhao, justen2024polar}.

Robust plans, such as Least Expected Cost~\cite{2002LEC, 2005RCE}, estimate the distributions of the filter/join selectivities. In contrast, the Cost-Greedy approach reduces the search space by low-cardinality approximations to favor the choices of performance-stable plans~\cite{2007plan_diagram}. Similarly, SEER applies low-cardinality approximations to accommodate arbitrary estimation errors~\cite{2008strict_plan_diagram}, while~\cite{Abhirama2010BDSH, AlyoubiHW15, Wolf2018RobustMetric} propose metrics to quantify the robustness of execution plans during query optimization.

ReOpt~\cite{1998reopt, 1999reopt_shared_nothing} introduces mid-query re-optimization, where the query engine detects cardinality estimation errors at execution time and re-invokes the optimizer to refine the remaining query plan. Eddies routes data tuples adaptively through a network of query operators during execution~\cite{2000eddies}. The POP algorithm introduces the concept of a "validity range" for selected plans, triggering re-optimization when the actual parameter values fall outside this range~\cite{2004pop, 2007pop_parallel}. Plan Bouquet eliminates the need for estimating operator selectivities by identifying a set of "switchable plans" that can accommodate runtime selectivity variations~\cite{2016planbouquets}. Experiments in~\cite{Perron19} demonstrate that query re-optimization achieves excellent performance on PostgreSQL with the Join Order Benchmark. QuerySplit~\cite{2023reopt_zhao} introduces a novel re-optimization technique to minimize the probability of explosive intermediate results during re-optimization. POLAR~\cite{justen2024polar} avoids intertwining query optimization and execution by inserting a multiplexer operator into the physical plan.

A few recent works~\cite{birler2024robust, treetrackerjoin} developed algorithms fundamentally equivalent to the \YannAlg. They focused on avoiding performance regression when applying semi-join reductions even on worst-case input (i.e., input where pre-filtering is ineffective).

Compared to \rpt, most existing robust query processing approaches lack theoretical guarantees on join-order robustness. Nevertheless, some of the techniques related to physical operator selections and operators beyond join are orthogonal to \rpt and can complement our approach to boost query performance further.

\subsection{Worst-Case Optimal Join}

While the \YannAlg performs acyclic joins in optimal time (linear in the input and output size), answering general cyclic queries in polynomial time in terms of input, output, and query size is impossible unless $\textsf{P}=\textsf{NP}$.

A tractable extension for the cyclic case is near-acyclic queries, whose intricacy can be measured by different notions of width, such as treewidth~\cite{ROBERTSON1986309}, 
query width~\cite{chandra1997}, hypertree width~\cite{gottlob1999}, and submodular width~\cite{Marx10}. Generally speaking, a query with a width of $k$ has an upper bound $O(N^k+OUT)$ on the time complexity.
The hierarchy of bounds is summarized in a survey~\cite{suciu2023} and a recent result~\cite{lpnorm2024}.

Worst-case optimal join~(WCOJ) algorithms are developed to guarantee the above bounds on the running time. Binary joins are ubiquitous in relational DBMS but fail short on certain database instances compared to WCOJ algorithms. NPRR~\cite{nprr12} is the first algorithm that achieves the AGM bound~\cite{agm08}, and then an existing algorithm LFTJ is also proved to be running in the AGM bound~\cite{2014leapfrog}. These algorithms are unified as the Generic Join~\cite{ngo2014SIGMOD,ngo2018}, which determines one variable at a time using tries. The PANDA algorithm~\cite{panda2017,panda2024} eliminates one inequality at a time using horizontal partitioning and achieves the polymatroid bound. Variants of WCOJ algorithms have been adopted in distributed query processing~\cite{chu2015theory, koutris2016worst, ammar2018distributed}, graph  processing~\cite{zhang2014evaluating, aberger2017emptyheaded, ammar2018distributed, hogan2019worst, mhedhbi2019optimizing, zhu2019hymj}, and general-purpose query processing~\cite{aref2015design, aberger2018levelheaded,2020hashtrie}. WCOJ algorithms are becoming practical as their performance surpasses traditional binary joins for certain queries~\cite{freejoin2023}.

Unlike WCOJ algorithms, \RPT only provides theoretical guarantees on the runtime for acyclic queries. However, it is strictly better than WCOJ algorithms because it bounds the runtime to the instance-specific output size rather than a more generalized upper bound.