%!TEX root=main.tex

\section{Our Model of Concurrency}\label{sec:approach}
We consider finite-state concurrent programs of the form $P_0 \parallel \dots \parallel P_k$ consisting of a finite collection of processes or threads running in parallel, which communicate with each other via shared variables. We use \emph{try-locks} (i.e., non-blocking locks \cite{OaksWong2004}) as the main synchronization mechanism. Try-locks allow for a fine-grained concurrency. Furthermore, we assume that  locks are used to protect shared variables, and then variables can only be written by the processes ``owning'' the corresponding locks. This is a common practice in languages like {\JAVA}, where \emph{synchronize} clauses and locks are used  to provide process synchronization. 

%	We consider finite-state concurrent programs of the form $P_1 \parallel \dots \parallel P_n$ consisting of a finite collection of processes $P_0, \dots, P_n$ or threads running in parallel, which 
%communicate with each other via shared variables. The main mechanism of synchronization used by the processes are \emph{try-locks}, i.e., non-blocking locks \cite{JavaConcurrency,POSIX}. These kinds of locks allow for a fine-grained concurrency. Furthermore, we assume that our programs follow a well-known discipline of synchronization: locks are used to protect shared variables, and then variables can only be written by the process owning the corresponding lock. This is a common practice for instance in \textsf{Java},  where \emph{synchronize} clauses can be used in combination with locks to provide mutual exclusion. 

Formally, a process with shared variables $\mathit{Sh}$ and locks $\mathcal{L}$ will be modeled as a transition system $P = \langle S, \mathit{Act},  \rightarrow, s, \mathit{AP}, L \rangle$, where $\mathit{Act} = \mathit{Int} \cup \mathit{Env}$, $\mathit{AP} = \mathit{Sh} \cup \mathit{Loc} \cup \mathcal{L}$, and $\mathit{Sh}, \mathit{Loc}, \mathcal{L}, \mathit{Int}, \mathit{Env}$ are mutually disjoint finite sets. 
Intuitively, $\mathit{Sh}$ is the collection of shared variables available to the process, $\mathit{Loc}$ is the collection of the local variables of the process, $\mathcal{L}$ is the set of locks used by the process, $\mathit{Int}$ is a set of internal actions and $\mathit{Env}$ is a set of environmental actions. From now on, we assume that every shared variable $g$ has a corresponding lock (named $\ell_g$), and therefore we have that $\{\ell_g \mid g \in Sh\} \subseteq \mathcal{L}$. %When useful we use the expression $\mathit{assoc}(\ell)$ to denote the variable associated to lock $\ell$, if it exists. 

The environmental actions are defined taking into account the shared variables and the locks, i.e.:
$
	\textit{Env} = \bigcup_{\ell \in \mathcal{L}}\{\textit{ch}_\ell\} \cup  \bigcup_{g \in \textit{Sh}}\{\textit{ch}_g\} \cup \{\textit{env}\}.
$
Intuitively,  $\textit{ch}_\ell$ is an environmental action that performs changes on lock $\ell$, and $\textit{ch}_g$ is similar but for shared variables. The additional action $\textit{env}$ represents the possible changes that the environment may perform over the shared variables not owned by the current process.

%Furthermore, for each lock $\ell$ we consider two additional atomic propositions, named $\mathit{own}_\ell$ and $\mathit{av}_\ell$; intuitively, the former signals the acquisition of lock $\ell$ and the latter becomes true when the lock is available. Also, we provide an environmental action $ch_\ell \in Env$ that changes the state of the lock and its (possible) associated value.
%		We provide actions to acquire the locks in boththe process and the environment; so, for any lock $\ell$, $aqc_\ell, rel_\ell \in Int$ are actions for acquiring and releasing $\ell$, and $ch_\ell \in Env$ is an environmental action   
For the sake of simplicity, we write $s \overset{a}{\dashrightarrow} s'$ instead of $s \xrightarrow{a} s'$ when $a \in Env$, and we write $s \dashrightarrow s'$ if $s \overset{a}{\dashrightarrow} s'$ for some $a$.

We impose the following restrictions on processes to ensure that they behave according to our model of concurrency:
%		Formally, a process is a tuple $P = \langle S, Sh, Loc, \mathcal{L}, Act, Env, \rightarrow, L \rangle$ where $S$ is a finite set of states; $Loc$ and $Sh$ are finite sets of local and shared variable names, respectively. We assume that each  variable $x$ range over a domain $D_x$ being $D$ the union of all these domains; $\mathcal{L} = \{\ell_0, \dots, \ell_n\}$ is a finite set of lock names, we assume $D_\mathcal{L} = \{true, false\}$; $Act$ and $Env$ are finite sets of internal and external action, respectively. 		
%		$\rightarrow \subseteq (Act \cup Env) \times S \times S$ is a transition relation, we write $s \xrightarrow{a} s'$ instead of $(a, s, s') \in \rightarrow$, and when $a \in Env$ we write
%$s \overset{a}{\dashrightarrow} s'$; $L: S \rightarrow D^{(Sh \cup Loc) \cup \mathcal{L}}$ is a valuation function returning the value of each variable in a given state. We assume that every shared variable $g$ has a corresponding lock (named $\ell_g$), and therefore we have that $\{\ell_g \mid g \in Sh\} \subseteq \mathcal{L}$.	Note that any process is basically a transition system, for a state $s \in S$ we denote $Post(s) = \{s' \mid \exists a : s \xrightarrow{a} s'\}$ the sets of successors of state $s$, and $Post_{Env}(s) = \{s' \mid \exists a : s \overset{a}{\dashrightarrow} s'\}$, the successors of $s$ reached via environmental transitions.
% locks can only be acquired when they are free
\begin{description}[font=\normalfont]
	%\item[P1.] $\forall s \in S : \neg L(s)(av_\ell) \Rightarrow \neg (\exists s' : s \rightarrow s' \wedge L(s')(own_\ell))$
	\item[P1.] $\bigwedge_{\ell \in \mathcal{L}}(\forall s \in S :  \textit{av}_\ell \notin L(s) \Rightarrow \neg (\exists s' : s \rightarrow s' \wedge \textit{own}_\ell \in L(s')))$
	%\item[P2.] $\forall s,s' \in S : s \rightarrow s' \wedge \neg L(s)(own_\ell) \wedge L(s')(own_\ell) \Rightarrow$\\
	%		\hspace*{5cm}  $\bigwedge_{\ell' \in \mathcal{L}\setminus\{\ell\}} (L(s)(own_{\ell'}) \equiv L(s')(own_{\ell'}))$
	\item[P2.] $\bigwedge_{\ell \in \mathcal{L}}(\forall s,s' \in S : s \rightarrow s' \wedge \textit{own}_\ell \notin L(s) \wedge \textit{own}_\ell \in L(s') \Rightarrow$\\
			\hspace*{5cm}  $\bigwedge_{\ell' \in \mathcal{L}\setminus\{\ell\}} (own_{\ell'} \in L(s) \equiv \textit{own}_{\ell'} \in L(s')))$
	%\item[P3.] $\forall s \in S: L(s)(own_\ell) \Rightarrow \neg L(s)(av_\ell)$
	\item[P3.] $\bigwedge_{\ell \in \mathcal{L}}(\forall s \in S: \textit{own}_\ell \in L(s) \Rightarrow   \textit{av}_\ell \notin L(s))$
	%\item[P4.] $\forall s \in S : \neg L(s)(own_\ell) \Rightarrow \exists s' \in S : s \overset{ch_\ell}{\dashrightarrow} s'$
	\item[P4.] $\bigwedge_{\ell \in \mathcal{L}}(\forall s \in S : \textit{own}_\ell \notin L(s) \Rightarrow \exists s' \in S : s \overset{\textit{ch}_\ell}{\dashrightarrow} s')$
	%\item[P5.] $\forall s,s' \in S : s \overset{ch_\ell}{\dashrightarrow}{s'} \Rightarrow L(s)(av_\ell) \equiv \neg L(s')(av_\ell)$ 
	\item[P5.] $\bigwedge_{\ell \in \mathcal{L}}(\forall s,s' \in S : s \overset{\textit{ch}_\ell}{\dashrightarrow}{s'} \Rightarrow \textit{av}_\ell \in L(s) \equiv  \textit{av}_\ell \notin L(s'))$ 	
	%\item[P6.] $\forall  s,s' \in S : s \overset{ch_\ell}{\dashrightarrow} s' \Rightarrow \bigwedge_{x \in Sh \cup Loc \setminus \{av_{\ell}, own_{\ell}\}\cup assoc(\ell)} (L(s)(x) \equiv L(s')(x))$
	%\item[P6.] $\bigwedge_{\ell \in \mathcal{L}}(\forall  s,s' \in S : s \overset{\textit{ch}_\ell}{\dashrightarrow} s' \Rightarrow \bigwedge_{x \in Sh \cup Loc \setminus \{\textit{av}_{\ell}, \textit{own}_{\ell}\}} (x \in L(s) \equiv x \in L(s')))$
	\item[P6.] $\bigwedge_{\ell \in \mathcal{L}}(\forall  s,s' \in S : s \overset{\textit{ch}_\ell}{\dashrightarrow} s' \Rightarrow \bigwedge_{x \in Sh \cup Loc \setminus \{\textit{ch}_\ell, \textit{av}_\ell\}}(x \in L(s) \equiv x \in L(s')))$

	\item[P7.] $\bigwedge_{g  \in \textit{Sh}}(\forall  s,s' \in S : s \overset{\textit{ch}_g}{\dashrightarrow} s' \Rightarrow \bigwedge_{x \in (Sh \cup Loc) \setminus \{g\}}(x \in L(s) \equiv x \in L(s')))$
	
	%\item[P7.] $\forall s \in S : \neg L(s)(own_{\ell_g})  \Rightarrow$ \\
	%		\hspace*{3cm}$(\exists s': s \dashrightarrow s' : L(s')(g)) \wedge  (\exists s': s \dashrightarrow s' :  \neg L(s')(g)))$
	\item[P8.] $\bigwedge_{g \in \textit{Sh}}(\forall s \in S :  \textit{own}_{\ell_g} \notin L(s) \wedge \textit{av}_{\ell_g} \notin L(s) \Rightarrow$ \\
			\hspace*{3cm}$(\exists s': s \overset{ch_g}{\dashrightarrow} s' : g \in L(s')) \wedge  (\exists s': s \overset{ch_g}{\dashrightarrow} s' : g \notin L(s')))$
	
	\item[P9.] $\textit{env} = (\bigcup_{g \in \textit{Sh}}\{\textit{ch}_g\})^+$
	%\item[P8.] $\forall s,s': s \dashrightarrow^* s' \wedge (\bigwedge_{\ell \in \mathcal{L}}  \textit{own}_{\ell} \in L(s) \equiv \textit{own}_{\ell} \in L(s')) \Rightarrow s \dashrightarrow s'$
\end{description}
%Note that it is straightforward to express these formulas in \textsf{FORL}.
Intuitively, $\text{P1}$ states that, if a lock is not available, then it cannot be acquired. $\text{P2}$ says that only one lock per time unit can be acquired by the process. $\text{P3}$
says that, if a lock is owned by the process, then it is not available. $\text{P4}$ states that, if the process does not own a lock, then the environment can acquire it. $\text{P5}$ expresses the fact that 
action $\textit{ch}_\ell$ changes the state of the lock. $\text{P6}$ states that the environmental action $\textit{ch}_\ell$ produces changes only in variables $\textit{own}_\ell$ and $\textit{av}_\ell$. $\text{P7}$ is similar but for shared variables.
$\text{P8}$ says that, if the lock corresponding to a variable is not owned by the process, then any behavior of the environment is possible. Finally, $\text{P9}$ states that $\textit{env}$ models the possible changes that the environment may perform over shared variables. This condition makes it possible to promote local properties to the global system (Theorem \ref{th:prom} below).%	Some additional  comments about our definition of process are useful. Note that 
%Intuitively, the states of a process can be identified with parts of its source code, where each of these parts may execute a sequential code which we abstract away. To perform a given transition some locks may be needed (i.e., the proposition $own_\ell$ is true in the source of the transition); this is the synchronization part.  

%We also consider all possible behaviors of the environment ($\text{P8}$-$\text{P9}$). This is similar to the assumptions made in \cite{PnueliRosner89} for the synthesis of reactive controllers over open systems. Here, we restricted ourselves to boolean variables, other datatypes can be dealt with in a similar way.  
Note that $\text{P8}$-$\text{P9}$ are similar to the assumptions made in \cite{PnueliRosner89} for the synthesis of reactive controllers over open systems. Here, we restricted ourselves to boolean variables, other datatypes can be dealt with in a similar way. 

	Let us define the transition structure corresponding to the concurrent execution of a collection of processes.
\begin{definition}
 Given processes $P_0,\dots,P_k$ 
where $P_i = \langle S_i,\mathit{Env}_i \cup \mathit{Int}_i, \mathit{Sh} \cup \mathit{Loc}_i \cup \mathcal{L},  \rightarrow_i, s_i, L_i \rangle$ for $i \in [0,k]$ with shared variables $\mathit{Sh}$
 and locks $\mathcal{L}$, with $\mathit{Loc}_i, \mathit{Loc}_j, \mathit{Act}_i, \mathit{Act}_j$ being pairwise disjoint for $i \neq j$, we define 
%the structure $P_0 \parallel \dots \parallel P_n = \langle S, \bigcup_{i \in [0,k]} Act_i, Sh \cup \bigcup_{\ell \in \mathcal{L}}\{own^i_\ell, av^i_\ell \} \setminusbigcup_{\ell \in \mathcal{L}}\{own_\ell, av_\ell\} \cup \bigcup_{i \in [0,k]}Loc_i , \rightarrow, L \rangle$  as follows:
the structure $P_0 \parallel \dots \parallel P_n = \langle S^\parallel, \mathit{Act}^\parallel, \rightarrow^\parallel, s^\parallel , \mathit{AP}^\parallel , L^\parallel, \rangle$  as follows:
\begin{enumerate}	
	\item $S^\parallel = \{s \in \Pi_{i \in [0,k]} S_i \mid \forall g \in \mathit{Sh} : \forall i,j \in [0,k] : L_i(s \proj i)(g) = L_j(s \proj j)(g) \}$\\
			\hspace*{0.8cm}$ \cap \{ s \in \Pi_{i \in [0,k]} S_i \mid \forall \ell \in \mathcal{L} : \#\{i \in [0,k] \mid L_i(s \proj i)(\mathit{own}_\ell)\} \leq 1 \}$,
	\item $\mathit{Act}^\parallel =  \bigcup_{i \in [0,k]} \mathit{Act}_i$,
	\item $\rightarrow^\parallel  = \{ (s,a,s') \mid \exists i \in [0,k] : ((s \proj i \xrightarrow{a}_i s' \proj i) \wedge (\forall j \neq i : s \proj j = s \proj j)) \}$,
	\item $s^\parallel  = \langle s_0, \dots, s_k \rangle$,	
	\item $\mathit{AP}^\parallel = ((\mathit{Sh} \cup \bigcup_{\ell \in \mathcal{L},i\in [0,k]}\{\mathit{own}^i_\ell, av^i_\ell \}) \setminus \bigcup_{\ell \in \mathcal{L}}\{\mathit{own}_\ell, av_\ell\}) \cup \bigcup_{i \in [0,k]}Loc_i$,
	\item $L^\parallel(s)(x)  =  L_0(s \proj 0)(x) \mbox{ if } x \in \mathit{Sh} \setminus \{\mathit{own}_\ell, \mathit{av}_\ell\}$,
	\item $L^\parallel(s)(x) =  L_i(s \proj i)(x) \mbox{ if } x \in Loc_i$,
	\item $L^\parallel(s)(\mathit{own}^i_\ell)  =  L_i(s \proj i)(\mathit{own}_\ell)$,
	\item $L^\parallel(s)(\mathit{av}^i_\ell)  =  L_i(s \proj i)(\mathit{av}_\ell)$.
\end{enumerate}
\end{definition}
Roughly speaking, the global system is an asynchronous product of the participating processes, where  the valuation of shared variables coincides for every process, and each lock is mapped to its owner. It is easy to see that this construction suffers from the state explosion problem, thus the explicit construction of this structure is unfeasible in practice.

One interesting point about our formalization  is that certain properties can be promoted from a given process to the concurrent program where this process resides, this enables modular reasoning over asynchronic products.
%which can be addressed with techniques such as symbolic model checking or bounded model checking.
%However, in practice, one can characterise the executions of the asynchronous product using the definitions of $S^\parallel$ and $\rightarrow^\parallel$, and so bounded model checking can be used to efficiently model check \textsf{LTL} properties over this structure.
		
% TRY TO PROVE THE THEOREM FOR ACTL-X
% Granularity of locks: Only one lock can be aqcuired in one step and only one shared variable can be update in one step, assume that there are
% local actions and environmental actions to acquire and change shared variables
%	Interestingly, the next theorem states   that  local properties without the next operator are promoted from processes to global systems, this makes possible modular reasoning over the asynchronous product.
\begin{theorem}\label{th:prom} Given processes $P_0,\dots, P_k$ such that $P_0 \parallel \dots \parallel P_k$ is well formed and a \textsf{LTL-X} property $\phi$, if $P_i \vDash \phi$, then we have: $P_0 \parallel \dots \parallel P_n \vDash_\mathcal{F} \phi$. 
%\begin{proof}  First, we prove that for any trace $\pi' \in Tr(P_0 \parallel \dots \parallel P_k)(s)$ we have that the projection of this trace to process $P_i$ is stutter equivalent to some trace $\pi \in Tr(P_i)(s \proj i)$. Since stuttering equivalence preserves path formulas without the next operator,  the result follows. 
%
%	Let $\pi' \in Tr(P_0 \parallel \dots \parallel P_k)(s)$, then we prove that the trace $\pi \proj i = \pi[0] \proj i \rightarrow \pi[1] \proj i \rightarrow \dots$ is stutter equivalent to a trace 
%$\pi \in Tr(P_i)(s \proj i )$. $\pi$ is just defined by removing all the transitions in $\pi[j] \proj i \rightarrow \pi[j+1] \proj i$  that
%do not correspond to transitions in $P_i$. It is simple to see that the removed transitions are stuttering steps, that is $L_i(\pi[j] \proj i)  = L_i(\pi[j+1] \proj i)$, otherwise if $L_i(\pi[j] \proj i)  \neq L_i(\pi[j+1] \proj i)$
%the transition must correspond to the transition of another process (say $P_j$). Furthermore, $L_i(\pi[j] \proj i)$ and $L_i(\pi[j+1] \proj i)$ can only differ on their valuation of shared variables (they must coincide on the valuation of $Int_i$), but by condition \textbf{P7} we have a matching transition in $P_i$, which is a contradiction. Also note that removing these transitions keeps the trace infinite, since $\pi$ is fair.
%	Since we have removed only stuttering steps, the resulting execution is stuttering equivalent to $\pi \proj i$. Using this property and an induction on \textsf{ACTL-X} formulas, the result follows.
%\end{proof}
\end{theorem}
%
%Intuitively, this property states that universal local properties without the next operator are promoted from processes to global systems. As noted in \cite{Lamport83}, the next operator is unsuitable  to state global properties since stuttering steps during the execution of the global system may falsify them. Furthermore, 
Note that local properties are preserved only by fair executions, otherwise one could devise some global execution that prevents the process from progressing. 
\subsection{Obtaining Guarded-Command Programs.}
	Interestingly, given a structure $P_0 \parallel \dots \parallel P_k$  we can define a corresponding program in the guarded-command notation, written $Prog(P_0 \parallel \dots \parallel P_k)$, as follows. The shared variables are those in $\textit{Sh}$ plus an additional shared variable $\ell$ for each lock, with domain $[0,k]\cup\{\bot\}$ (where $\bot$ is a value used to indicate that the lock is available). Additionally, for each $\langle S_i, \textit{Env}_i \cup \textit{Int}_i, \textit{Sh} \cup \textit{Loc}_i \cup \mathcal{L},  \rightarrow_i, s_i, L_i \rangle$ we define a corresponding process. To do so, we introduce for each $s \in S_i$  the equivalence class: $[ s ]  = \{ s' \in S_i \mid (s \dashrightarrow^* s') \vee (s'  \dashrightarrow^* s)\}$. 
That is, it is the set of states connected to $s$ via environmental transitions. It is direct to prove that it is already an equivalence class. The collection of all equivalence classes
is denoted $S_i /_{\dashrightarrow^*}$.The local variables of the process are those in $\textit{Loc}_i$. Additionally, a fresh variable $\textit{state}$, with domain $S_i/_{\dashrightarrow^*}$, is considered. 
It is worth noting that the programs we synthesize follow the discipline of acquiring a lock before modifying the corresponding variable. When a lock is not available, the process may continue executing other branches. However, note that a process could get blocked when all its guards are false, thus other synchronization mechanisms such as blocking locks, semaphores and condition variables can be expressed by these programs. 
Finally, given states $s,s' \in S_i$ with $s \xrightarrow{a} s'$ and  $[s] \neq [s']$, we consider the following guarded command:
\[
 [a] \left( \begin{array}{l} 
 			 state = [s] \\
			 \wedge \bigwedge \{x = (x \in L(s)) \mid x \in \mathit{Sh} \cup \mathit{Loc} \}\\ 
			\wedge \bigwedge \{ \ell = i \mid \ell \in \mathcal{L} : \mathit{own}_\ell \in L(s)\}	 \\ 
			 \wedge \bigwedge \{ \ell = \bot \mid \ell \in \mathcal{L} : \mathit{av}_\ell \in L(s)\}  \end{array} \right) \rightarrow \left( \begin{array}{l} 
 																					  			  \{x {:=} x \in L(s') \mid x \in \mathit{Loc}\cup \mathit{Sh}\} \\ 
																					 			  \cup \{\mathit{state} {:=} [s'] \} \\
																								  \cup \{ \ell := i \mid \ell \in \mathcal{L} : \mathit{own}_\ell \in L(s)\}  \\
																								  \cup \{ \ell := \bot \mid \ell \in \mathcal{L} : \mathit{av}_\ell \in L(s)\}
																					  \end{array} \right)
\]
%	Note that this definition may result in programs with redundant branches, which can be simplified in different ways. 
We can prove that our translation from transition systems to programs is correct. That is, the executions of the program satisfy the same temporal properties as the 
asynchronous product $P_0 \parallel \dots \parallel P_n$.
\begin{theorem}\label{th:proppreservation} Given a program $P_0 \parallel \dots \parallel P_n$ and \textsf{LTL} property $\phi$, then we have that:
$
	P_0 \parallel \dots \parallel P_n \vDash \phi \Leftrightarrow Prog(P_0 \parallel \dots \parallel P_n) \vDash \phi
$
\end{theorem}
\begin{example}[Mutex]  
\label{ex:mutex-ts}
Consider a system composed of two processes (it can straightforwardly be generalized to $n$ processes) both with non-critical, waiting and critical sections. The global property  is mutual exclusion: the two processes cannot be in their critical sections simultaneously. We consider one lock $\ell$, actions: $\mathit{getNCS}$ (the process enters to the non-critical section), $\mathit{getCS}$ (the process enters to the critical section), $\mathit{getLock}$ (the process acquires the lock), $\mathit{getTry}$ (the process goes to the try state), and the corresponding propositions $\mathit{ncs}, \mathit{cs}, \mathit{try}, \mathit{own}_\ell, \mathit{av}_\ell$.  

In Fig.~\ref{fig:mutex} the transition system and the program corresponding to this example are shown. It is interesting to observe that,  the coherence conditions \text{P1}-\text{P9} imply that, for any action $B \rightarrow C$  containing a $x := E$ in $C$ for a shared variable $x$, we have that the statement $\ell_x=i$ is implied by $B$ (if $x:=E$ is different from the skip statement), i.e., the lock corresponding to $x$ is acquired by the process before executing the assignment. Similarly, note that locks are acquired only if they are available.
\end{example}
\begin{figure}[t!]
\begin{minipage}[b]{0.40\linewidth}
\centering
\includegraphics[scale=0.6]{Figs/mutex-resized.pdf}
\end{minipage}
\begin{minipage}[b]{0.60\linewidth}
\centering
\begin{lstlisting}[style=Unity]
Program Mutex
 var m:Lock;
  Process $P_i$ with $i \in \{0,1\}$
   var $\text{try}_i, \text{ncs}_i, \text{cs}_i$:boolean
   var st:$\{\text{S0},\text{S1},\text{S2},\text{S3},\text{S4},\text{S5}\}$
   initial: $\text{ncs}_i\wedge \neg \text{cs}_i \wedge \neg \text{try}_i$ 
   begin
    [getTry]st=S5$\wedge$Av$_m\rightarrow$st:=S3,$\text{try}_i$:=true,$\text{ncs}_i$:=false
    [getLock]st=S3$\wedge$Av$_m \rightarrow$st:=S1,$\text{try}_i$:=true,own$_m$:=true
    [getLock]st=S3$\rightarrow$st:=S3
    [getCS]st=S1$\rightarrow$st:=S0,$\text{cs}_i$:=true,$\text{try}_i$:=false
    [getNCS]st=S0$\rightarrow$st:=S5,$\text{ncs}_i$:=true,$\text{cs}_i$:=false
   end
end
\end{lstlisting}
\end{minipage}
\caption{Transition Structure and Program with a lock $m$ for Mutex}\label{fig:mutex}
\end{figure}
%
%	We can prove that our translation from transition systems to programs is correct. That is, the executions of the program satisfy the same temporal properties as the 
%asynchronous product $P_0 \parallel \dots \parallel P_n$.
%\begin{theorem}\label{th:proppreservation} Given a program $P_0 \parallel \dots \parallel P_n$ and \textsf{LTL} property $\phi$, then we have that:
%$
%	P_0 \parallel \dots \parallel P_n \vDash \phi \Leftrightarrow Prog(P_0 \parallel \dots \parallel P_n) \vDash \phi
%$
%\end{theorem}
%such that, for every $\pi \in Tr(P_0 \parallel \dots \parallel P_n)$ and $i \geq 0$ we have that: $\pi[i] \vDash \phi$ iff $f(\pi)[i] \vDash \theta(\phi)$, being $\phi$ any boolean formula. 
% In order to prove this, we need to consider a translation (named $\theta$) between boolean formulas built up from the transition structure and the  program's boolean expressions.
%It is defined recursively as follows: $\theta(own_\ell) = (\ell = i)$, $\theta(av_\ell) = (\ell = \bot)$, $\theta(p) = p$ (for any $p \in Loc \cup Sh$), and $\theta(\varphi \vee \psi) = \theta(\varphi) \vee \theta(\psi)$, $\theta(\varphi \wedge \psi) = \theta(\varphi) \wedge \theta(\psi)$, $\theta(\neg \varphi) = \neg \theta(\varphi)$. Then, we can prove the following theorem:
%\begin{theorem}\label{th:proppreservation} Given a program $P_0 \parallel \dots \parallel P_n$, we have a one-to-one function $f: Tr(P_0 \parallel \dots \parallel P_n) \rightarrow Tr(Prog(P_0 \parallel \dots \parallel P_n))$,
%such that, for every $\pi \in Tr(P_0 \parallel \dots \parallel P_n)$ and $i \geq 0$ we have that: $\pi[i] \vDash \phi$ iff $f(\pi)[i] \vDash \theta(\phi)$, being $\phi$ any boolean formula. 
%\begin{proof} 
%	Let us define for each $\pi \in Tr(P_0 \parallel \dots \parallel P_k)$ a corresponding execution $f(\pi) \in Tr(Prog(P_0 \parallel \dots \parallel P_k))$. The definition of $f(\pi)$ is by induction.
%$\pi[0]$ corresponds to the initial state of the program, by definition the two satisfy the same boolean formulas. Assume that $f(\pi[0]) \dots f(\pi[n])$ are defined, and consider $\pi[n+1]$. We know that there is a transition $\pi[i] \xrightarrow{a} \pi[i+1]$, then by definition of the asynchronous product we have a process $P_j$ with a transition
%$\pi[i] \proj j \xrightarrow{a} \pi[i+1] \proj j$, if $[\pi[i]] = [\pi[i+1]]$ then we define $f(\pi[i+1]) = f(\pi[i])$, otherwise we have a corresponding guarded command $B \rightarrow C$ in the process 
%corresponding to $P_j$ such that, by induction, $f(\pi[i]) \vDash B$  and we define $f(\pi[i+1])$ as the state obtained after executing $C$, which by definition of the program satisfies the same
%boolean properties as $\pi[i+1]$. In a similar way we can define the inverse of $f$.
%\end{proof}
%\end{theorem}
\vspace{-0.5cm}
\subsection{Defining Processes in \textsf{FORL}.}
	Given a process as defined above, we can easily describe it in \textsf{FORL}. A type $\mathit{Node}$ is used for modeling the states, the transition relation is described using binary relations, propositions are captured using a type $\mathit{Prop}$, and the valuation function is defined via a relation $\mathit{val}:\mathit{Node} \rightarrow \mathit{Prop}$. Finally, formulas are used to describe the transitions. Let us describe this by means of an example. Consider the process of Fig.\ref{fig:mutex},  the corresponding $\textsf{FORL}$ specification is shown in Fig.\ref{fig:forl-spec}.
\begin{figure}[t!]
$%\scriptsize % finish this
\begin{array}{l}
	\textit{succs},\textit{local}, \textit{env}:\textit{Node} \times \textit{Node}\\
	\textit{val}: \textit{Node} \times \mathit{Prop} \\
	s_0,s_1,s_2,s_3,s_4,s_5:\textit{Node}\\
	\textit{val} = \{ (s_5 ,  \textit{ncs}_i), (s_5, \textit{av}_m), (s_2, \mathit{ncs}_i), (s_4, \mathit{try}_i) 
	, (s_3, \mathit{try}_i), (s_3, \mathit{av}_m) \\ 
	\hspace*{0.7cm},  (s_1, \mathit{try}_i), (s_1,\mathit{own}_m),  (s_0, \mathit{cs}_i), (s_0, \mathit{own}_m) \}\\
	\textit{getTry} = \{(s_5, s_3),(s_2, s_4) \}\\
	\textit{getNCS} = \{s_0,s_5 \} \\ 
	\textit{getCS} = \{ (s_1, s_0)\}\\
	\textit{getLock} = \{ (s_3, s_1), (s_3, s_3),(s_4,s_4) \} \\
	\textit{ch}_{\ell} = \{ (s_3, s_4),(s_4, s_3),(s_5,s_2), (s_2,s_5) \}\\
	\textit{local} =  \mathit{getTry} \cup \mathit{getNCS}  \cup \mathit{getCS} \cup \mathit{getLock}\\
	%\textit{env} = \textit{ch}_{\ell} \\
	%\textit{succs} =   local \cup env \\
\end{array}
$
%\begin{array}{l}
%	\mathit{succs},\mathit{local}, \mathit{env}:\mathit{Node} \rightarrow \mathit{Node}\\
%	\mathit{val}: \mathit{Node} \rightarrow \mathit{Prop} \\
%	s_0,s_1,s_2,s_3,s_4,s_5:\mathit{Node}\\
%	\mathit{val} = (s_5 {\rightarrow} \textit{ncs}_i) + (s_5 \rightarrow \textit{av}_m) + (s_2 \rightarrow \mathit{ncs}_i) + (s_4 \rightarrow \mathit{try}_i) 
%	+ (s_3 \rightarrow \mathit{try}_i) + (s_3 \rightarrow \mathit{av}_m) \\ 
%	\hspace*{0.7cm}+  (s_1 \rightarrow \mathit{try}_i) +  (s_1 \rightarrow \mathit{own}_m)	+  (s_0 \rightarrow \mathit{cs}_i) +  (s_0 \rightarrow \mathit{own}_m) \\
%	\mathit{getTry} = (s_5 \rightarrow s_3)  + (s_2 \rightarrow s_4)\\
%	\mathit{getNCS} = s_0 \rightarrow s_5 \\ 
%	\mathit{getCS} = s_1 \rightarrow s_0\\
%	\mathit{getLock} = (s_3 \rightarrow s_1) + (s_3 \rightarrow s_3) + (s_4 \rightarrow s_4) \\
%	\mathit{ch}_{\ell} = (s_3 \rightarrow s_4) + (s_4 \rightarrow s_3) + (s_5 \rightarrow s_2) + (s_2 \rightarrow s_5)\\
%	\mathit{local} =  \mathit{getTry} + \mathit{getNCS}  + \mathit{getCS} + \mathit{getLock}\\
%	\mathit{env} = \mathit{ch}_{\ell} \\
%	\mathit{succs} =   local + env 
%\end{array}
\caption{\textsf{FORL} specification for Mutex}\label{fig:forl-spec}
\end{figure}
Note that we use variables $\mathit{succs}$ and $\mathit{env}$ to capture the relations $\rightarrow$ and $\dashrightarrow$, respectively. Given a transition structure $\mathit{TS}$ we call $\mathcal{A}(\mathit{TS})$ its corresponding specification. Note that, if we replace $\mathit{getTry} = \{ (s_5,s_3), (s_2,s_4)\}$ by $\mathit{getTry} \subseteq \{ (s_5,s_3), (s_2,s_4)\}$  in the given specification, we obtain a weaker specification. Performing this for all the internal actions returns a specification which, intuitively, 
allows the SAT solver to disable some local transitions, thus the non-determinism may be reduced. This weaker theory is denoted by $\mathcal{A}_{Ref}(TS)$.

%	We also can consider a weaker specification if $\mathit{getCS} = s_1 \rightarrow s_0$ is replaced
%by $\mathit{getCS} \subseteq s_1 \rightarrow s_0$, and similarly for the other local actions. Intuitively, this specification allows one to disable some local transitions, and in some cases to reduce the non-determinism. We name $\mathcal{A}_{Ref}(TS)$  this weaker theory.
%\section{Process Specifications}\label{sec:spec}
%	In this section we describe the main way in which we specify distributed programs.
%\paragraph{Theory Presentations, Specifications and Kripke Structures.} 
%	The main vehicle to express process specifications are \textsf{FO(TC)} theory presentations. 
	%A theory presentation is a tuple $T=\langle \tau, \Gamma \rangle$ where $\tau$ is a vocabulary and $\Gamma$ is a set of \textsf{FO(TC)}  formulas. We say that $T$ is finite when $\Gamma$ is finite. Given a theory $\langle \tau, \Gamma \rangle$, we say that $\mathcal{A} \vDash T$ iff $\mathcal{A} \vDash \Gamma$.
\subsection{Specifying Distributed Programs} 
	Distributed programs are specified by means of a  collection of \textsf{FORL} specifications that share  some symbols (locks and shared variables) plus a global temporal property.
\begin{definition} A specification of a distributed program is a tuple: $\langle Sh, \mathcal{L}, \{ S_i \}_{i \in I}, \phi \rangle$ where $Sh=\{g_0,\dots, g_p\}$ is a finite collection
of shared variable names, $\mathcal{L} =\{\ell_0,\dots,\ell_q\}\cup \{\ell_{g_i} \mid 0 \leq i \leq p \}$ is a finite collection of lock names including names for the shared variables and $I$ is a finite index set. Furthermore, each specification $S_i$ contains in its declaration part:
\begin{itemize}
	\item Types $\mathit{Node}, \textit{Prop}$ characterising the process' states, and the set of propositions, respectively.
	\item Variables $\mathit{init}{:}\mathit{Node}$ and $p,q,\dots{:}Prop$ characterizing the initial state and the propositions, respectively,
	\item Relations  $a_0, \dots, a_m{:} \mathit{Node} \rightarrow \mathit{Node}$ and  ${\mathit{ch}_g}_0, \dots, {\mathit{ch}_g}_0{:} \mathit{Node} \rightarrow \mathit{Node}$, representing the 
	internal actions, and the environmental actions, respectively.
%	representing the relations associated to internal actions,
%	\item Relations  ${\mathit{ch}_g}_0, \dots, {\mathit{ch}_g}_0{:} \mathit{Node} \rightarrow \mathit{Node}$ representing the relations associated to environmental actions that change the shared variables,
	\item Relations  $p_0,\dots,p_t{:}\mathit{Node} \rightarrow \mathit{Prop}$  corresponding to the local variables, and ${\mathit{ch}_g}_0, \dots, {\mathit{ch}_g}_0{:} \mathit{Node} \rightarrow \mathit{Node}$ corresponding to the shared variables,
%	\item Relations $g_0, \dots, g_p{:} \mathit{Node} \rightarrow \mathit{Prop}$ corresponding to the shared variables,
	\item Relations $\{\mathit{av}_\ell \mid \ell \in \mathcal{L}\} \cup \{\mathit{own}_\ell \mid \ell \in \mathcal{L}\}$ of type $\mathit{Node} \rightarrow \mathit{Prop}$  representing the lock mechanisms associated to the shared variables. 
%	\item Unary relation symbols $\text{av}^1_{\ell_0}, \dots, \text{av}^1_{\ell_p}, \text{own}^1_{\ell_0}, \dots, \text{own}^1_{\ell_p}$ representing the lock mechanisms associated to the shared variables. 
 \end{itemize}
	$S_i$ contains axioms $\text{P1}$-$\text{P9}$.
Furthermore, $\phi$ is a {\LTLX} formula  containing propositional variables declared in the $S_i's$.
\end{definition}
	Given a program specification $\langle  Sh, \mathcal{L}, \{S_i\}, \phi  \rangle$, an instance of it is a collection of  environments 
$\{ e_i  \}_{i \in I}$ such that: $e_i \vDash S_i$. Furthermore, let $TS_{e_i}$ be the transition structure corresponding to  $e_i$, then we have $TS_{e_0} \parallel \dots \parallel TS_{e_k} \vDash \phi$. 
Typically, a process specification contains axioms for the actions in the style of pre and postconditions, plus frame axioms (i.e., the list of variables that are not changed by the actions), in addition to  axioms \text{P1}-\text{P9}. 
\begin{example}[Mutex cont.] Let us consider a specification for the mutex example with two processes. The specification is given by a tuple $\langle \emptyset, \{m\}, \{ S_0, S_1 \}, \phi \rangle$ where there is no shared variables, a lock $m$, specifications $S_0$ and $S_1$ corresponding to the two processes, whose variable
declarations are those in Example \ref{ex:mutex-ts}. The formulas of the specification define the actions in terms of pre and post-conditions, e.g.:
\[
\begin{array}{l}
	\forall s,s' : \textit{Node} \mid s' \in \textit{enterCS}_i[s] \Rightarrow \\
	 \hspace*{3cm} (((\textit{try}_i \in \textit{val}[s]) \wedge ({\textit{own}_m}_i \in \textit{val}_i[s])) \Rightarrow cs \in \textit{val}_i[s']))
\end{array}
%\begin{array}{l}
%	\mathbf{all} \ s,s' {:} \mathit{Node} \mid s' \ \mathbf{in} \ \mathit{enterCS}_i[s] \ \mathbf{implies} \\
%	\hspace*{1cm}	 (((try_i \ \mathbf{in} \ val[s]) \ \mathbf{and} \ ({own_\ell}_i \ \mathbf{in} \ val[s])) \ \mathbf{implies} \ cs \ \mathbf{in} \ val[s']))
%\end{array}
\]
states the pre and postcondition of action $\mathit{enterCS}$ (and similarly for the other actions). The global property $\phi$ is \emph{mutual exclusion}, which can be easily characterised in {\LTL}.
%\[
%\( \exists s: \textit{Node} \mid \textit{cs}_i \in \textit{val}_i[s] \wedge \textit{cs}_j \in \textit{val}_j[s] \wedge j \neq i )
%\neg ( \exists s: \textit{Node} \mid \textit{cs}_i \in \textit{val}_i[s] \wedge \textit{cs}_j \in \textit{val}_j[s] \wedge j \neq i )
%\]
%\vspace*{-0.1cm}
%\[
%\mathbf{not} \ ( \mathbf{some}\ s: \mathit{Node} \mid \mathit{enterCS}_i  \ \mathbf{in} \ val[s] \land \mathit{enterCS}_j \ \mathbf{in} \ val[s] \land j \neq i )
%\]
% Due to space restrictions, we do not include the complete specification in this paper, but it can be found in \cite{}.
%\begin{example}[Mutex]\label{ex:mutex-spec} Consider a system composed of two processes (it can easily be generalized to $n$ processes) both with non-critical, waiting and critical sections. The global property  is mutual exclusion: the two processes cannot be in their critical sections simultaneously. The \textsf{FORL} specification is shown in Fig.~\ref{fig:mutex-spec}.
%For specifying this system we consider no shared variables ($Sh =\emptyset$) and one lock ($\mathcal{L}=\{\ell\}$). Furthermore, for each process $P_i$ (where $i \in \{0,1\}$)
% we consider a theory $\langle \tau_i, \Gamma_i \rangle$, defined as follows: $\tau_i$ contains unary relations $init, ncs_i, try_i, {av_\ell}_i, {own_\ell}_i$, and binary relations $enterTry_i, enterCS_i, enterNCS_i, getLock_i$. $\Gamma_i$ consists of the following axioms:
%\begin{figure*}[ht!]
%$
%\begin{array}{l}
% \text{init}, \text{ncs}_i, \text{try}_i, \text{av}_\ell, \text{own}_\ell:\text{Node}  \\
% \text{enterTry}_i, \text{enterCS}_i, \text{enterNCS}_i, \text{getLock}_i:\text{Node}\rightarrow \text{Node}  \\
% \all \ s:\text{Node} \mid (s \ \inc \ \text{init}_i) \ \imp \ (s  \ \inc \ ncs_i) \ \conj \ \nega \ s \ \inc \ \text{try}_i \ \conj \ s \ \inc \ {\text{av}_\ell}_i \\
% \bm{\wedge} \wedge
%\end{array}
%$
%\end{figure*}
% 
% 
%\begin{itemize}
%	\item The initial condition for the processes: 
%	        \[
%		\forall s: init_i(s) \Rightarrow  ncs_i(s) \wedge \neg cs_i(s) \wedge \neg try_i(s) \wedge {av_\ell}_i(s),
%		\]
%	\item The axioms for the actions, in a pre/post condition style:
%		\[
%		\begin{array}{l}
%			\forall s:  \forall s': enterTry_i(s,s') \Rightarrow ((ncs_i(s) \vee (try_i(s) \wedge \neg {own_\ell}_i(s))) \Rightarrow try(s'))\\
%		 	\forall s:  \forall s': enterCS_i(s,s') \Rightarrow ((try_i(s) \wedge {own_\ell}_i(s)) \Rightarrow cs(s'))\\
%		 	\forall s:  \forall s': enterNCS_i(s,s') \Rightarrow (cs_i(s)  \Rightarrow (ncs_i(s') \wedge \neg {own_\ell}_i(s')))\\
%			\forall s:  \forall s': getLock_i(s,s') \Rightarrow (try(s) \wedge av_\ell(s)  \Rightarrow own_\ell(s))\\
%		\end{array}
%		\]
%	\item Assumptions about the occurrence of actions:
%		\[
%		\begin{array}{l}
%			\forall s : \neg cs_i(s) \Rightarrow (\neg \exists s': getNCS(s,s')) \\
%			\forall s : \neg try_i(s) \wedge (\neg ncs_i(s) \vee {own_\ell}_i(s)) \Rightarrow (\neg \exists s' : getTry(s')) \\
%			\forall s : \neg try_i(s) \vee \neg {own_\ell}_i(s) \Rightarrow (\neg \exists s' : getCS(s,s'))  \\
%			\forall s : \neg try_i(s) \vee \neg {av_\ell}_i \Rightarrow (\neg \exists s' : getLock(s,s'))
%		\end{array}
%		\]
%	\item Frame axioms for the actions:
%		\[
%		\begin{array}{l}
%			\forall s : \forall s' : getNCS_i(s,s') \Rightarrow ({av_\ell}_i(s) \equiv {av_\ell}_i(s'))\\
%			\forall s : \forall s' : getTRY_i(s,s') \Rightarrow ({own_\ell}_i(s) \equiv {own_\ell}_i(s')) \wedge ({av_\ell}_i(s) \equiv {av_\ell}_i(s')) \\
%			\forall s : \forall s' : getCS_i(s,s') \Rightarrow ({own_\ell}_i(s) \equiv {own_\ell}_i(s')) \wedge ({av_\ell}_i(s) \equiv {av_\ell}_i(s')) \\
%			\forall s : \forall s' : getLock_i(s,s') \Rightarrow ({cs}_i(s) \equiv {cs}_i(s')) \wedge ({ncs}_i(s) \equiv {ncs}_i(s')) \\
%			\forall s : \forall s' : {ch_\ell}_i(s,s') \Rightarrow ({cs}_i(s) \equiv {cs}_i(s')) \wedge ({ncs}_i(s) \equiv {ncs}_i(s')) \wedge (try_i(s) \equiv try_i(s'))
%		\end{array}
%		\]
%%	 all s:ProcessMeta.nodes | 
%%					((not Prop_TRYING[ProcessMeta, s]) or (not Own_S[ProcessMeta, s])) implies (no ProcessMeta.ACTgetCS[s])
%%	
%%-- pre -> execution is possible
%%    all s:ProcessMeta.nodes | 
%%				(Prop_TRYING[ProcessMeta, s] and Own_S[ProcessMeta, s])   implies (some ProcessMeta.ACTgetCS[s])
%	\item $ncs, cs, try$ are mutually disjoint: 
%	\[
%		 \forall s : \neg( cs(s) \wedge ncs(s)) \wedge \neg( try(s) \wedge ncs(s)) \wedge \neg( try(s) \wedge cs(s))
%	\] 	
%	\item Axioms \textbf{P1}-\textbf{P8}
%\end{itemize}
%Finally, the global property is $\A \G (\neg cs_0 \wedge \neg cs_1)$. 
%It is worth noting that many of these axioms (e.g., the frame axioms) can be automatically generated. We have implemented a  prototype tool that given pre and post conditions for actions, plus temporal formulas for local and global properties, it automatically generates the corresponding specification in $\textsf{FO(TC)}$.% this facilitates the task of producing this kind of specifications.
\end{example}	
%
%Given $AP=\{p_0,\dots,p_n\}$ and $Act=\{a_0,\dots,a_m\}$, and a transition system $M=\langle S, R^M_{a_0},\dots,R^M_{a_m}, v^M \rangle$, we define the theory $Th(M) = \langle \tau_M, \Gamma_M \rangle$ in the following way: 
% $\tau_M = \langle R^2_{a_0}, \dots, R^2_{a_m}, s_0, \dots, s_k, p^1_0, \dots, p^1_n \rangle$ and:
%\[
%\begin{array} {l l} \Gamma^M = & \{\bigwedge_{i \neq j} s_i \neq s_j, \forall s : \bigvee_{0\leq i \leq k}s=s_i \} \\
%										       &\cup \bigcup_{0\leq i \leq m} \{ R_{a_i}(s_k,s_{k'}) \mid R_{a_i}^M(s_k,s_{k'})\} \\
%										        & \cup \bigcup_{0\leq i \leq m} \{ \neg R_{a_i}(s_k,s_{k'}) \mid \neg R_{a_i}^M(s_k,s_{k'}) \}\\
%										        &\cup \bigcup_{0\leq i \leq n} \{ p_i(s_j) \mid p_i \in v^M(s_j) \}
%										        \cup \bigcup_{0\leq i \leq n} \{ \neg p_i(s_j) \mid p_i \notin v^M(s_j) \}
%\end{array}
%\]
%\end{definition}

%It is worth noting that, given any TS structure $M=\langle S, Act, \rightarrow, s, AP, L \rangle$, we can define a theory $Th(TS)$ that characterizes $TS$ up to isomorphism. The definition of $Th(TS)$ is straightforward: constants are used to explicitly represent the states of the structure, and  axioms are added to  describe the relation. Formally:
%\begin{definition}\label{def:th(M)} Given a transition system $TS=\langle S, Act, \rightarrow, s, AP, L \rangle$ with  
%$Act = \{a_0,\dots,a_m\}$ and $AP=\{p_0,\dots,p_t\}$, we define the  theory $Th(TS) = \langle \tau_{TS}, \Gamma_{TS} \rangle$,  where $\tau_{TS}$ is the vocabulary corresponding to $TS$ (see Section~\ref{sec:background})
% and:
% \[\displaystyle
%\begin{array} {l l} \Gamma^{TS} = & \{\bigwedge_{i \neq j} s_i \neq s_j, \forall s : \bigvee_{0\leq i \leq k}s=s_i \} 
%										       \cup \bigcup_{0\leq i \leq m} \{ R_{a_i}(s_k,s_{k'}) \mid s_k \xrightarrow{a_i},s_{k'} \} \\
%										        & \cup \bigcup_{0\leq i \leq m} \{ \neg R_{a_i}(s_k,s_{k'}) \mid \neg (s_k \xrightarrow{a_i} s_{k'}) \}\\
%										        &\cup \bigcup_{0\leq i \leq n} \{ p_i(s_j) \mid p_i \in L(s_j) \}
%										        \cup \bigcup_{0\leq i \leq n} \{ \neg p_i(s_j) \mid p_i \notin L(s_j) \}
%\end{array}
%\]

%
%The following theorem is straightforward:
%\begin{theorem} Let  $M=\langle S, R^M_{a_0},\dots,R^M_{a_n}, v^M \rangle$ be a Kripke structure. For any relational structure $\mathcal{A}$ it holds that:
% $
% \mathcal{A} \vDash Th(M) \text{ iff } \mathcal{A}|_{\tau_M} \cong \mathcal{A}_M,
% $
% where $\mathcal{A}|_{\tau_M}$ is the reduct of $\mathcal{A}$ to vocabulary $\tau_M$ \cite{ChangKeisler90}.
%\end{theorem}
% SAY SOMETHING ABOUT ISOMORPHISM??
%\subsubsection{Refinements}
%	Given a theory $\langle \tau, \Gamma \rangle$ specifying a process and an instance of it $\mathcal{A} \vDash \Gamma$, we will be interested in those transition structures that refine $TS_{\mathcal{A}}$, obtained by disabling some local non-determinism present in $TS_{\mathcal{A}}$. The collection of these refinements can be characterized by means of a \textsf{FO(TC)} theory, as follows: 	
%\begin{definition} Given a transition system $TS=\langle S, Act, \rightarrow, s, AP, L \rangle$ where $S =\{s,s_0,\dots, s_n\}$, 
%$Act = \{a_0,\dots,a_m\}$ and $AP=\{p_0,\dots,p_t\}$, and a set $Loc \subseteq Act$, we define $Ref_{Loc}(TS) = \langle \tau_{TS}, \Gamma_{Ref(TS)} \rangle$ where $\tau_{TS}$ is
%defined as in Section \ref{sec:background}, and:
%\[
%\begin{array} {l l} \Gamma^{TS} = & \{\bigwedge_{i \neq j} s_i \neq s_j, \forall s : \bigvee_{0\leq i \leq k}s=s_i \} 	
%											\cup \bigcup_{0\leq i \leq n} \{ p_i(s_j) \mid p_i \in L(s_j) \} \\
%											& \cup \bigcup_{0\leq i \leq m} \{ R_{a_i}(s_k,s_{k'}) \mid a_i \notin Loc \wedge s_k \xrightarrow{a_i},s_{k'} \} \\						
%										        & \cup \bigcup_{0\leq i \leq m} \{ \neg R_{a_i}(s_k,s_{k'}) \mid \neg (s_k \xrightarrow{a_i} s_{k'}) \}
%										        	   \cup \bigcup_{0\leq i \leq t} \{ \neg p_i(s_j) \mid p_i \notin L(s_j) \}
%\end{array}
%\]
%\end{definition}
%	Note that in this definition the local actions are those belonging to the set $Loc$. Roughly speaking, the axioms of this theory state that: (i) all the states of $TS$ must be present, (i) no new transitions must be added, (iii) environmental transitions must be preserved.
%	One interesting property of $Ref_{Loc}(TS)$ is that it preserves \textsf{CTL} universal properties.
%\begin{theorem}\label{theorem:preservation} Given a transition structure $TS$, and  a $\textsf{ACTL}$ formula $\phi$ over the vocabulary of $TC$, we have that:
%$TS \vDash \phi$ implies  $Ref(TS) \vDash \phi^*$.
%\begin{proof} First, note that for any $\mathcal{A} \vDash Ref(TS)$, we have a simulation relation $R$ such that $TS_\mathcal{A} \; R \; TS$, since
%simulation relations preserve \textsf{ACTL} properties, and the translation from transition structures to first-order structures is an isomorphism, the result follows.
%\end{proof}
%\end{theorem}
%Summing up, specifications are theory presentations, and transition structures/programs and their refinements can be captured as models of these theories.
	


