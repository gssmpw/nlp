\section{Related Work}
\label{sec:related}	

The seminal work of Emerson and Clarke **Clarke, "The Design and Verification of Concurrent Systems"**, and related approaches **Manna and Pnueli, "How to Cook a Temporal Logic System for Concurrent Programs"** are based on tableau methods for synthesizing synchronization skeletons from global {\CTL} specifications,  which are impractical in most cases, or require to provide process descriptions as state machines.
%these approaches are based on satisfiability algorithms for {\CTL} and are impractical for most examples.  
%In **Clarke et al., "Automatic Verification of Finite-State Concurrent Systems Using Temporal Logic Specifications"** the process descriptions have to be entered by the users, in contrast to our approach in which local implementation for processes are also synthesized. 
The synthesis of distributed reactive systems **Emerson and Clarke, "Using Temporal Logic to Give Meaning to Occam Programs"**  aim to synthesize a distributed architecture that reacts to an environment when possible. This is a very general problem and can be undecidable in many cases.  Bounded synthesis **Vardi and Wolper, "Reasoning About Multimodal μ-logic"** reduces the problem of finding a given program to solve a (bounded) first-order formula; then inductive generalization and verifiers are used for generating candidate solutions. {\AlloyStar}  **De Alfaro et al., "Temporal Specifications with Stopwatches: A Decidable Mu-Calculus Approach to Distributed Systems"** implements a general version of CEGIS. In contrast to CEGIS, our approach starts from ``loose'' versions of the processes, which are refined until a solution is obtained. Thus, we can accumulate counterexamples, and use them throughout the synthesis process.  As noted in **Kroening et al., "Temporal Logic Solvers for Software Verification"**,  
using executions of asynchronous concurrent programs as counterexamples in  CEGIS is not direct.  Particularly, {\Sketch} is only able to handle safety properties.  Other works, e.g. **Gulwani and Jhala, "Hybrid Mining: Inferring Abstract Specifications from Parametric Code"**, consider only safety properties, or are designed for specific settings.


%In our approach we assume an asynchronous model of computation with shared variables.  Also note that we consider local specifications and not only a global temporal property as in bounded synthesis.  Variations of bounded synthesis for asynchronous systems like **Vardi et al., "Reasoning About Multimodal μ-logic"** assume a  \emph{casual memory} process model,  i.e.,  the components memorize their histories and react according to this.

%takes as a parameter the bounds for the processes and the final system, and reduces the synthesis problem to a SAT problem.  Note that we use bounds only for the component, and also consider local specifications and not only global temporal specification as in bounded synthesis.
%Other works, e.g., **Kroening et al., "Temporal Logic Solvers for Software Verification"**, consider only safety properties, or are designed for specific problems of programming languages.  It is worth noting that 

%{\Sketch} **Gulwani and Jhala, "Hybrid Mining: Inferring Abstract Specifications from Parametric Code"** is a synthesizer that uses CEGIS to obtain code from sketched code. {\Sketch} is only able to handle safety properties, while our approach is able to analyze any {\LTLX} property. The synthesis of distributed open systems **De Alfaro and Henzinger, "Interface-based Design Environments"** is an interesting stream of research. These techniques also aim to synthesize a distributed architecture when possible. This is a more general problem than the one considered here, and can be undecidable in many cases.  Bounded synthesis **Vardi et al., "Reasoning About Multimodal μ-logic"** takes as a parameter the bounds for the processes and the final system, and reduces the synthesis problem to a SAT problem.  In our approach we only use bounds for the components,  we also consider  local specifications in a pre/post conditions way and not only a global temporal specification as in bounded synthesis.  Other approaches like {\Party} **Kołdryński et al., "Temporal Logic Solvers for Software Verification"** are specific to certain architectures. We believe that