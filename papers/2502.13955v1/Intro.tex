%!TEX root=main.tex
\section{Introduction} \label{sec:Intro}

Program synthesis \cite{MannaWolper84,PnueliRosner89,EmersonClarke82} allows for the automated construction of programs from specifications. Ideally, the user only provides a formal description of the intended behavior of a to-be-developed program, and then a program, correct with respect to the given specification, is automatically derived. A clear benefit of this ideal scenario  is that users only need to concentrate in writing software specifications, which are typically stated in a higher level of abstraction, that abstracts away involved implementation details. In the last decades, the constant advances in hardware, and the emergence of new synthesis methods, have made possible the application of synthesis to complex case studies (see, e.g.,  \cite{BGJPPW07a}). 

%A typical simplification to synthesis problems, that makes these more tractable, is to assume that part of the operational implementation to be developed is provided. For instance, in controller synthesis, the actions are known and provided, and only their appropriate combination to achieve a given goal is the part of the operational solution to be synthesized. 
This paper focuses on the synthesis of high-level descriptions for distributed systems, such as protocols and multi-agent systems. These systems are crucial in modern software applications, including collaborative tools, communication networks, and cryptocurrencies. Moreover, their correct implementation is in general rather complex and time consuming,  which often results in subtle programming errors.
Particularly, when synchronization primitives (e.g., semaphores, locks, monitors) are used to manage access to shared resources.  Their incorrect use often leads to challenging issues like race conditions and deadlocks,  which are difficult to identify and fix using conventional methods. Thus, distributed algorithms, and in particular the use of synchronization primitives, constitute a compelling target for synthesis approaches. 


%The focus of this paper is on the automated synthesis of high-level descriptions of \emph{distributed systems},  such as distributed protocols, or multi-agent systems.   These kinds of systems constitute key parts of modern software applications, including collaborative software, communication networks, cryptocurrencies, etc.  Moreover, their correct implementation is in general rather complex and time consuming, and subtle errors are commonly found in the implementation of distributed algorithms. Typically,  the construction of distributed systems demands the correct use of \emph{synchronization primitives} (e.g., semaphores, locks, or monitors) to organize the access to shared resources and avoid deadlocks. Their incorrect use often leads to various problems, such as \emph{race conditions} and \emph{deadlocks} \cite{OaksWong2004,Fokkink13}, that are hard to identify and solve using typical sequential programming methodologies for debugging and testing. Thus, distributed algorithms, and in particular the use of synchronization primitives, constitute a compelling target for synthesis approaches. 

Approaches to automated synthesis have seen significant improvement in recent years. Some techniques are based on game theory for temporal logic specifications \cite{Piterman+2006}, the synthesis from input-output examples \cite{Jha+2010}, inductive programming \cite{Abate+2018}, and techniques based on theorem proving \cite{Srivastava+2010}, which have been successfully applied in various contexts. Synthesis techniques for distributed algorithms are less common, as mentioned above,  in this setting we have  additional difficulties, such as the problem of dealing with several interacting processes, complying with specific communication architectures, and correctly instrumenting coordination via synchronization mechanisms. In fact, the problem of synthesizing distributed code from specifications is undecidable in many settings \cite{PnueliRosner90}.

The  (bounded) synthesis technique presented in this paper targets  asynchronous distributed systems that use shared memory for the communication and synchronize via locks.  A system specification, in this setting, is composed of a (finite) collection of process or component specifications consisting of actions specified via pre/post-conditions,  together with local constraints expressing required properties of the action  executions; and \emph{global} properties that the process/component interaction must guarantee.  Local constraints are expressed in Alloy's relational logic \cite{AlloyBook}, a first-order logic with transitive closure (necessary for expressing certain constraints, notably reachability), whereas global constraints are specified in linear-time logic.  If successful,  the technique produces implementations for the components that use their corresponding local actions as well as lock-based synchronizations, and satisfy the local constraints, while their interaction satisfies the global constraints.  

More specifically,  the approach encodes component specifications into an Alloy model \cite{AlloyBook}, in such a way that satisfying instances of the model correspond to locally correct implementations of the corresponding process. Thus,  we indirectly use Boolean satisfiability to enumerate (bounded) locally valid implementations of processes. When locally valid implementations of processes are found, their combination is checked against the \emph{global} specification, to verify whether the current local candidates lead to a correct distributed solution. For efficiency reasons, this latter global check is performed using a symbolic model checker. The search is performed in a lexicographic manner,  in which a backtracking is performed when the possible instances of a component specification are exhausted.
 However,  this basic algorithm is impractical  due to the exponential  number of potential component implementations,  for which we also have to consider all their possible combinations. 
 To address this, we introduce an improved algorithm that uses counterexample batches to speed up the process.  This algorithm  consists of two phases: an exploratory phase that collects instances from the solver and generates counterexamples via a model checker; followed by an exploitation phase that refines component specifications based on these counterexamples.  If no solutions are found, the process repeats with the refined specifications.  The algorithm's efficiency and completeness depend on the chosen batch configurations, which we explore in Section \ref{sec:examples}, discussing their benefits and drawbacks.
 
The paper is structured as follows.  In Section \ref{sec:background} we introduce preliminary concepts. Section \ref{sec:motivating-example} illustrates our approach via a motivating example.  Sections \ref{sec:algo} and \ref{sec:examples} describe the main algorithm and discuss experimental results. Finally,  Sections \ref{sec:related} and \ref{sec:conclusions} discuss related work and present some final remarks.

%A main distinction of our technique with previous approaches (e.g., \cite{Solar-Lezama+2008,VechevYY13}) is that we are not constrained to safety properties (local specifications are arbitrary Alloy formulas, which subsumes first-order logic, and global properties are ``next-free'' arbitrary linear-time temporal formulas). Moreover, our synthesis deals both with the local implementation of process behavior and their appropriate synchronization, as opposed to related work, that, e.g., only synthesizes the right location for synchronization primitives \cite{EmersonSamanta11}. Also, our technique is guaranteed to be sound and bounded-complete, i.e., solutions are correct distributed algorithms, and if no solution is found, then no solution is possible within the explored bounds. Finally, the technique is based on bounded-exhaustive enumeration, thus enabling the possibility of producing multiple synthesized solutions for a given specification.  


