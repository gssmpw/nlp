\section{Related Work}
\label{sec:related}	

The seminal work of Emerson and Clarke ____, and related approaches ____, are based on tableau methods for synthesizing synchronization skeletons from global {\CTL} specifications,  which are impractical in most cases, or require to provide process descriptions as state machines.
%these approaches are based on satisfiability algorithms for {\CTL} and are impractical for most examples.  
%In ____ the process descriptions have to be entered by the users, in contrast to our approach in which local implementation for processes are also synthesized. 
The synthesis of distributed reactive systems ____  aim to synthesize a distributed architecture that reacts to an environment when possible. This is a very general problem and can be undecidable in many cases.  Bounded synthesis ____ focuses on reactive (synchronous) systems,
or assumes a \emph{causal memory}  model ____,  i.e.,  the components memorize their histories and synchronize according to this.  Also, we remark that all these approaches consider only global {\LTL} specifications,  in our approach we also consider local specifications in a pre/post-condition and invariant style, which may include Alloy formulas.

Counterexample-driven guided inductive synthesis (CEGIS) ____ reduces the problem of finding a given program to solve a (bounded) first-order formula; then inductive generalization and verifiers are used for generating candidate solutions. {\AlloyStar}  ____ implements a general version of CEGIS. In contrast to CEGIS, our approach starts from ``loose'' versions of the processes, which are refined until a solution is obtained. Thus, we can accumulate counterexamples, and use them throughout the synthesis process.  As noted in ____,  
using executions of asynchronous concurrent programs as counterexamples in  CEGIS is not direct.  Particularly, {\Sketch} is only able to handle safety properties.  Other works, e.g. ____, consider only safety properties, or are designed for specific settings.


%In our approach we assume an asynchronous model of computation with shared variables.  Also note that we consider local specifications and not only a global temporal property as in bounded synthesis.  Variations of bounded synthesis for asynchronous systems like ____ assume a  \emph{casual memory} process model,  i.e.,  the components memorize their histories and react according to this.

%takes as a parameter the bounds for the processes and the final system, and reduces the synthesis problem to a SAT problem.  Note that we use bounds only for the component, and also consider local specifications and not only global temporal specification as in bounded synthesis.
%Other works, e.g., ____, consider only safety properties, or are designed for specific problems of programming languages.  It is worth noting that 

%{\Sketch} ____ is a synthesizer that uses CEGIS to obtain code from sketched code. {\Sketch} is only able to handle safety properties, while our approach is able to analyze any {\LTLX} property. The synthesis of distributed open systems ____ is an interesting stream of research. These techniques also aim to synthesize a distributed architecture when possible. This is a more general problem than the one considered here, and can be undecidable in many cases.  Bounded synthesis ____ takes as a parameter the bounds for the processes and the final system, and reduces the synthesis problem to a SAT problem.  In our approach we only use bounds for the components,  we also consider  local specifications in a pre/post conditions way and not only a global temporal specification as in bounded synthesis.  Other approaches like {\Party} ____ are specific to certain architectures. We believe that