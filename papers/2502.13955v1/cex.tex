%!TEX root=main.tex
Given LTSs $T_0,\dots,T_n$, and a {\LTLX} property $\phi$, a counterexample of $T_0 \parallel  \dots \parallel T_n \vDash \phi$ is an execution $\pi$ of $T_0 \parallel  \dots \parallel T_n$ such that $\pi \nvDash \phi$.
%\section{A Counterexample-Guided Synthesis Procedure}\label{sec:cex}
% SAY SOMETHING ABOUT CEGAR WORKS
%Counterexamples for \textsf{LTL} formulas can be efficiently generated \cite{Katoen08}.
%\begin{definition}
%Given transition structures $TS_0,\dots,TS_n$  and a global \textsf{LTL} property $\phi$, if  $TS_0 \parallel  \dots \parallel TS_n \nvDash \A \phi$, then a \emph{counterexample} is an execution $\pi$ such that $\pi \nvDash \phi$.
%\end{definition}
The refinement phase of our algorithm takes a counterexample generated by a model checker, and \emph{projects} this global execution  to local executions of the participating processes. As shown below,  this information can be used to get rid of the counterexample, and thus, the  SAT solving phase can be speeded up.
In finite transition structures, counterexamples can be represented by finite paths, called \emph{lasso traces} (a finite sequence of states, such that the last state has a loop to some previous state) \cite{Biere+1999}. Furthermore, note that any finite path can be identified with a formula in \emph{conjunctive normal form}. 
\begin{definition}Given a LTS $T=\langle S, \{a_0,\dots,a_n\}, \rightarrow, s, L \rangle$ and a finite path $\pi = s_0 \rightarrow s_1 \rightarrow s_2 \dots \rightarrow s_{m}$ in $T$. The following  formula over $T$ captures this path:
$
	\CNF(\pi) = \bigwedge_{0 \leq j < m}(\bigvee_{0 \leq i \leq n}(a_i(s_j,s_{j+1}))  %  R_{a_i}(s_j,s_{j+1})).
$
\end{definition}
	%Where $\bm{\bigwedge}$ and $\bm{\bigvee}$ are the obvious generalization of the $\textbf{and}, \textbf{or}$ operators.
%It is worth observing that these kinds of formulas are in \emph{conjunctive normal form} (CNF). From now on, given a finite path $\pi$ we denote by $\CNF(\pi)$ its associated CNF formula, and by 
	Let us denote by  $\llbracket \CNF(\pi) \rrbracket$ the  set of clauses of formula  $\CNF(\pi)$.
%, i.e., 
%$$
%	\llbracket \bigwedge_{0 \leq j < m} (\bigvee_{0 \leq i \leq n} R_{a_i}(s_j,s_{j+1})) \rrbracket = \{ (\bigvee_{0 \leq i \leq n} R_{a_i}(s_j,s_{j+1})) \mid 0 \leq j < m \}
%$$

Given LTSs $T_0, \dots, T_k$, any execution $\pi$ of $T_0 \parallel \dots \parallel T_k$ can be projected to an execution of process $T_i$ (for each $i$).	
\begin{definition} Given a collection $T_0,\dots,T_k$ of LTSs and a finite execution $\sigma = s_0\rightarrow s_1\rightarrow \dots \rightarrow s_m$ in the structure $T_0 \parallel \dots \parallel T_k$, we denote by $\sigma {\uparrow} i$ the following path:
$
s_0 {\uparrow} i \rightarrow s_1 {\uparrow} i \rightarrow \dots
$
\end{definition}
Note that projecting  a global execution may introduce stuttering steps in local executions. The projections of a global execution form a tuple  $\langle c{\uparrow}0, \dots,  c{\uparrow}k \rangle$, that will be used to  refine the instances obtained via the SAT solver. Furthermore,  we define a relation $c \sqsubseteq c'$ between counterexamples, which intuitively states that  $c$ is included in (or refines) $c'$:
%In summary, given a counterexample $c$ for property $\phi$ over the model $TS = TS_0 \parallel \dots \parallel TS_k$, we can partition it into a tuple $\langle \text{pr}_0(c), \dots, \text{pr}_k(c) \rangle$ of counterexamples, one for each participating process. As mentioned above, we use these counterexamples to refine the instances obtained through the SAT solver, and pruning the search space. To this end, we define a relation $c \sqsubseteq c'$ between counterexamples, which intuitively captures $c$ being included (or refining) $c'$: 
\begin{definition}\label{def:cex-ref} Given a transition structure $T$ and finite paths $c$ and $c'$ in $T$, then:
$
	c \sqsubseteq c' \mbox{ iff } \llbracket \CNF(c) \rrbracket \subseteq \llbracket \CNF(c') \rrbracket
$
\end{definition}
It is straightforward to prove that this relation is reflexive, transitive and antisymmetric.
%Some standard properties of this relation are straightforward.
%\begin{theorem} Relation $\sqsubseteq$ is reflexive,  transitive and antisymmetric.
%\end{theorem}
Similarly, we can define a disjointness relation:
\begin{definition} Given a transition structure $TS$ and finite paths $c$ and $c'$ in $TS$, then:
	 $c * c' \mbox{ iff } c \not\sqsubseteq c' \wedge c' \not\sqsubseteq c$.
\end{definition}
When $c * c'$ we say that $c$ and $c'$ are disjoint. The algorithm uses this relationship to improve the search for LTSs. Suppose that we are inspecting a specification $S = \langle \{S_i\}_{i \in \mathcal{I}}, \phi \rangle$, and we get LTSs $T_i \vDash S_i$ (for each $i$),  model checking  $T_0 \parallel \dots \parallel T_k$ returns a counterexample $c$ that can be projected to a tuple of paths $\langle c_0, \dots, c_k \rangle$; thus, each specification $S_i$ can be enriched with a formula $\NOT(c_i)$ that removes the counterexample $c_i$ from the instances of the specification.
\begin{definition}\label{def:not} Given a path $c = s_0 \rightarrow  \dots \rightarrow s_m$, such that $s_i \neq s_{i+1}$ for some $i$, in a transition structure $T=\langle S, \{a_0,\dots,a_n\}, \rightarrow, s, L \rangle$, we define the following formula over $T$:
$
\NOT(c) = \bigvee_{0 \leq i < m} (\bigwedge_{0 \leq j \leq n} \neg  (s_{i+1} \in a_j[s_i])  \wedge \ (s_i \neq s_{i+1}))
%\NOT(c) = \bigvee_{0 \leq i < m} (\bigwedge_{0 \leq j \leq n} \neg R_{a_j}(s_i,s_{i+1}) \wedge s_i \neq s_{i+1})
$
\end{definition}
%We denote by $Ref(TS) + \NOT(c)$ the theory $Ref(TS)$ extended with the formula $\NOT(c)$. 
A direct consequence of this definition is that the instances of the refined specification $T \oplus \NOT(c)$ \todo{define $\oplus$}  do not admit the execution $c = s_0 \rightarrow s_1 \dots  \rightarrow s_m$, as it is stated in the following theorem.
\begin{theorem}\label{theorem:cex-entails} Given a process specification $S$ \todo{use S for process specification and D for distributed specifications}, and a LTS $T$ such that $T \vDash S$
and a path $c = s_0 \rightarrow  \dots \rightarrow s_m$ of $T$ \todo{Define finite paths too of a LTS}, with $s_i \neq s_{i+1}$ for some $i$, then:
$
	S \oplus \NOT(c)  \nvDash \CNF(c).
$
\end{theorem}
The next property of  $\sqsubseteq$ follows straightforwardly from Def.~\ref{def:not} and Def.~\ref{def:cex-ref}.
\begin{theorem}\label{theorem:ref} Given paths $c = s_0 \rightarrow  \dots \rightarrow s_m$, with $s_i \neq s_{i+1}$ for some $i$, and $c' = s'_0 \rightarrow  \dots \rightarrow s'_{m'}$, with $s'_i \neq s'_{i+1}$ for some $i$, in a transition structure $TS$, then:
$
\text{ If } c \sqsubseteq c'\text{, then } \mathcal{A}_{ref}(TS) \oplus \NOT(c) \vDash  \NOT(c')
$
\end{theorem}
This essentially says that formula $\NOT(c)$ rules out not only counterexample $c$, but also more general counterexamples $c'$ from the possible implementations (it is in this sense that $c$ refines $c'$). Observe also that, if $c$ and $c'$ are disjoint, then removing counterexample $c$ does not necessarily remove counterexample $c'$ from the model, and vice versa. That is, the two formulas $\NOT(c)$ and $\NOT(c')$ must be considered.
\begin{figure}[t!]
\iffalse
\begin{algo}[caption={Counterexample Search}, label={alg1}]
input: $i$ process number, $\{S_0,\dots, S_n \}$ process specifications, $\phi$ global property,  $k$ instance bound
output: $\{p_0,\dots,p_n\}$ with $p_0 \parallel \dots \parallel p_n \vDash\phi$ and $p_i \vDash S_i$, or $\emptyset$ otherwise
procedure $\mathit{SyntCex}(i,S_0, \dots, S_n \phi, k)$
    while $S_i$ has unprocessed instances  do
        $M[i] \leftarrow$ next instance of $S_i$; $\mathit{inCexs}[i] \leftarrow \emptyset$; $\mathit{outCexs}[i] \leftarrow \emptyset$
        $\mathit{currentSpec} \leftarrow \mathcal{A}_{ref}(M[i]) \oplus \mathit{form}(S_i)$
	while $\mathit{currentSpec} \oplus (\bigwedge_{c \in {\mathit{inCexs}[i]}}\NOT(c))$ has unprocessed instances do 
	    $r[i] \leftarrow$ next instance of $\mathit{currentSpec} \oplus (\bigwedge_{c \in {\mathit{inCexs}[i]}}\NOT(c))$
	    if ($i=n$) then
	        if $r[0] \parallel \dots \parallel r[n] \vDash \phi$ then return $\{r[0],\dots,r[n]\}$
	        else
	            $\mathit{cex} \leftarrow$ found counterexample            
		    if $\mathit{updateCexs}(\mathit{cex},n,\mathit{inCexs},\mathit{outCexs},\mathit{gcexs})$ then return $\emptyset$;	
		    else $\mathit{refineCexs}(\mathit{cex},n,\mathit{inCexs},\mathit{outCexs},\mathit{gcexs})$
	        endif
	    else
	        $\mathit{found} \leftarrow \mathit{SyntCex}(i+1,s_0,\dots,s_n,\phi,k)$
	        if $\mathit{found} \neq \emptyset$ then return found
	        if  no next instance of $\mathit{currentSpec} \oplus (\bigwedge_{c \in {\mathit{inCexs}[i]}}\NOT(c))$ 
	        	                            and $\mathit{inCexs}[i] \neq \emptyset$ then
		    $\mathit{outCexs}[i] \leftarrow \mathit{Pop(inCexs[i])}$
	    endif
	endwhile      	    
    endwhile
    return $\emptyset$;
end  
\end{algo}
\fi
\begin{algo}[caption={Counterexample Search}, label={alg1}]
input: $i$ process number, $\{S_0,\dots, S_n \}$ process specifications, $\phi$ global property,  $k$ instance bound
output: $\{p_0,\dots,p_n\}$ with $p_0 \parallel \dots \parallel p_n \vDash\phi$ and $p_i \vDash S_i$, or $\emptyset$ otherwise
procedure $\mathit{SyntCex}(i,S_0, \dots, S_n \phi, k)$
    $\mathit{inCexs}[i] \leftarrow \emptyset$; $\mathit{outCexs}[i] \leftarrow \emptyset$;
    while $S_i  \oplus (\bigwedge_{c \in {\mathit{inCexs}[i]}}\NOT(c))$ has unprocessed instances  do
	    $r[i] \leftarrow$ next instance of $S_i \oplus (\bigwedge_{c \in {\mathit{inCexs}[i]}}\NOT(c))$
	    if ($i=n$) then
	        if $r[0] \parallel \dots \parallel r[n] \vDash \phi$ then return $\{r[0],\dots,r[n]\}$
	        else
	            $\mathit{cex} \leftarrow$ found counterexample            
		    if $\mathit{updateCexs}(\mathit{cex},n,\mathit{inCexs},\mathit{outCexs},\mathit{gcexs})$ then return $\emptyset$;	
		    else $\mathit{refineCexs}(\mathit{cex},n,\mathit{inCexs},\mathit{outCexs},\mathit{gcexs})$
	        endif
	    else
	        $\mathit{found} \leftarrow \mathit{SyntCex}(i+1,s_0,\dots,s_n,\phi,k)$
	        if $\mathit{found} \neq \emptyset$ then return found
	        if  no next instance of $S_i \oplus (\bigwedge_{c \in {\mathit{inCexs}[i]}}\NOT(c))$ 
	        	                            and $\mathit{inCexs}[i] \neq \emptyset$ then
		    $\mathit{outCexs}[i] \leftarrow \mathit{Pop(inCexs[i])}$
	    endif    
    endwhile
    return $\emptyset$;
end  
\end{algo}
\end{figure}
\begin{figure}[t!]
\begin{algo}[caption={Auxiliary Function for Updating Counterexamples}, label={alg2}]
function $\mathit{updateCexs}(\mathit{cex}, j, \mathit{inCexs}, \mathit{outCexs}, \mathit{gcexs})$
    if $\forall c \in \mathit{gcexs}: c  * \mathit{cex}$  then 
        $\mathit{gcexs} \leftarrow \mathit{gcexs} \cup \{ cex \}$;  
        for all $i$  such that $\mathit{cex}{\uparrow}i \notin \mathit{\mathit{outCexs}[i]}$ do	            
	    $\mathit{\mathit{Push}(\mathit{inCexs}[i], \mathit{cex}{\uparrow}i)}$; 
	return $true$							
    endif	
    if $\forall c \in \mathit{inCexs}[n] : c*(\mathit{cex} {\uparrow} n)$ then    $\mathit{Push}(\mathit{inCexs}[n], \mathit{cex}{\uparrow}n)$	                   
    return false;
end
\end{algo}
\end{figure}
\begin{figure}[t!]
\begin{algo}[caption={Auxiliary Procedure for Refining Counterexamples}, label={alg3}]
procedure $\mathit{refineCexs}(\mathit{cex}, j, \mathit{inCexs}, \mathit{outCexs}, \mathit{gcexs})$	             
    for all  $c \in \mathit{gcexs}$ satisfying $\mathit{cex} \sqsubseteq c$ do 
        $\mathit{\mathit{Replace}(\mathit{gcexs}, c, \mathit{cex})}$ //replaces $c$ by $\mathit{cex}$ in $\mathit{gcexs}$
        for all i do $\mathit{Replace}(\mathit{inCexs}[i], c{\uparrow}i, \mathit{cex}{\uparrow}i)$       
    endfor    
end         
\end{algo}     
\end{figure}
%
We use these properties  to refine the algorithm described in the beginning of this section. 

The synthesis algorithm is described in Alg.~\ref{alg1}. Let us give an intuitive explanation of this algorithm.
The procedure takes as input an index indicating the specification being processed, the collection of process specifications, the global property, a bound on the number of   states of the processes to be synthesized. It performs a backtracking search over all the process instances for each specification. A collection $\mathit{gcexs}$ is used to keep track of the found counterexamples. 
%Also, for each $i$, a collection $inCexs_i$ is used to keep track of the projections of the counterexamples, note that it behaves like a stack, when fresh counterexamples are discovered they are piled up in the stack (line $16$). Another collection $cexsOut_i$ is used to save those counterexamples that have already been inspected by the algorithm. 
%Note that, at the beginning, if the specification is consistent, the loop of line $10$ is executed at least once since the expression $\bigwedge_{c \in cexs \setminus \langle \rangle}\NOT(c)$is evaluated to $true$ (it is an empty conjunction).
	 The loop of line $4$ inspects all the instances of specification number $i$. For each instance $M[i]$ obtained via the SAT solver we use two auxiliary sets: $\mathit{inCexs}_i$ that keeps track of the projections of the counterexamples found when dealing with the actual instance (it behaves in a stack-like way); and  $\mathit{outCexs}_i$, used to save the counterexamples that  were (unsuccessfully) taken into account during the iterations.	 Then, all the instances of theory $\mathcal{A}_{ref}(M[i])\oplus (\bigwedge_{c \in \mathit{inCexs}_i} \NOT(c)) \oplus \textit{form}(S_i)$ are inspected in the loop of line $6$. In the first iteration, $\bigwedge_{c \in \mathit{inCexs}_i} \NOT(c) = true$, since $\mathit{inCexs}_i$ is empty. Also note that we add $\mathit{form}(S_i)$ to the theory to be solved, this is because some of the refinements may prune too much non-determinism in such a way that some of the axioms of $S_i$ may be falsified. In practice, the specification $\mathcal{A}_{ref}(M[i])$ describes part of its possible instances, and so it is usually faster to get instances  from this than to get instances from $S_i$. 
	 In line $27$, the procedure calls itself recursively until the last specification is reached ($i=n$).
	 
	 Then,  the algorithm checks if the instances obtained for each process ($r_0,\dots,r_n$) satisfy the global property, returning a valid program, or adding the found counterexample to the set of counterexamples, before continuing with the search. This approach uses counterexamples to improve the search in two ways: (i) if a disjoint counterexample is found, we restart the search adding the new counterexamples to the $\mathit{inCexs_i}$ for every $i$ (line $13$), this is performed via the function $\mathit{UpdateCexs}$ (Alg.~\ref{alg2}); (ii) if a counterexample refining some counterexample in $\mathit{gcexs}$ is found (line $14$), the latter is changed by the former, i.e., we refine the set of counterexamples (auxiliary procedure $\mathit{RefineCex}$ in Alg.\ref{alg3}) and we continue the search.  
	 Note that a particular case arises when the found counterexample is only disjoint with the actual one (line $2$ in function \textit{UpdateCex}), in which case we add the corresponding counterexample to $\mathit{inCexs}_n$ and search is resumed. For the other specifications (that is, $i<n$), if no program was found then either new counterexamples were added to $\mathit{inCexs_i}$, in which case the Alloy solver will search instances over a refined specification (line $6$), or no more counterexamples were added to $\mathit{inCexs}_i$ and the stack will be popped. The idea of the stack is to strengthen the specification to speed up the process of finding an instance.\\
\noindent \textbf{Soundness, Termination and Bounded-Completeness.}
The soundness of this algorithm is direct, since a model checker is used to verify the output. Termination is less straightforward, the loop of line $4$ finalizes because the number of instances of size $k$ for any specification is finite. The loop of line $6$ is also executed a finite number of times: if $i=n$, the theory $\mathcal{A}_{ref}(M[i])\oplus (\bigwedge_{c \in \mathit{inCexs}_i} \NOT(c)) \oplus \mathit{form}(S_i)$ has a finite number of instances, but note that the set $\mathit{inCexs}_i$ could be increased (line $15$), but since ${\FORL}$ is a monotonic logic,  the number of instances is decremented when more counterexamples are considered, that is, eventually we will reach an inconsistent specification or all the instances will be processed and the algorithm will exit the loop. For $i<n$,  the set $\mathit{inCexs}_i$ is updated in a similar way, but when an inconsistent specification is generated (line $28$) we start popping  counterexamples from the stack. In this case, we go back to a specification that has been dealt with before, and then we will get the next instance that was not still processed for this theory, at some point all the instances will be generated and the loop will terminate. 
 
	For the bounded completeness, suppose that there are instances $r_0, \dots, r_n$ of size $k$ such that $r_0, \dots, r_n \vDash \phi$. Note that in line $6$ all the instances for each $i$ are generated, afterwards the algorithm starts inspecting the refinements of each instance, including itself. As remarked above, the loop of line $6$ will terminate because it eventually starts to pop elements from the stack, and therefore the next instance of specification $i$ will be obtained. Summing up (in the worst case) all the combinations of instances of the specifications will be checked by the model checker, and then the algorithm will find the sequence $r_0,\dots,r_n$.  
%\subsubsection{Additional Remarks.} Note that, for each instance $M_i$ of specification $\langle \tau_i, \Gamma_i \rangle$, the algorithm inspects the theory $Ref(M_i)$ enriched with the found counterexamples. An alternative would be to generate the instances of  specification $\langle \tau_i, \Gamma_i \rangle$ and to add the negations of the found counterexamples to $\Gamma_i$, avoiding the use of $Ref(M_i)$. The point of using $Ref(M_i)$ is that it contains information about the model to be generated, this improves the performance of the SAT solver since some of the valuation of the variables are already given in the theory. Intuitively speaking, once we have a model at hand that does not satisfy the global property, it is usually much better in practice to check if disabling some local actions we get a correct model before trying to generate a fresh model. Furthermore, note that we inspect those instances satisfying $Ref(M_i)+\bigwedge_{c \in inCexs_i} \NOT(c)+s_i$, as explained above adding specification $s_i$ is needed since there could be instances of  $Ref(M_i)+\bigwedge_{c \in inCexs_i} \NOT(c)$ that may remove too much non-determinism (falsifying some formulas of $s_i$). However, since any instance of $Ref(M_i)$ preserves  properties of \textsf{ACTL-X} (Theorem \cite{}),  the properties that can be expressed in this fragment do not need to be included in the theory. Roughly speaking, we need to include only those formulas  expressing existential properties.

		 %Suppose that there are $r_0,\dots, r_n$ such that $r_0 \parallel \dots \parallel r_n \vDash \psi$, being $\psi$ the global property, and each 
%$r_i \vDash Ref(M_i)$ for some $M_i$ that is an instance of the main specification. Now, if we found a counterexample $c$ during the search through the refinements of $M_i$, then 
%we have  $r_0 \parallel \dots \parallel r_n \vDash \NOT(c_i)$ and so for some $i$ we have $r_i \vDash \NOT(c {\uparrow} i)$, now note that for any counterexample $c$
%we try $c{\uparrow}i$ in and out (for that we have $\langle \rangle$), that is, at some point we should find the instance. Two important optimizations in the Algorithm are lines $15$, $17$ and $19$, let us show that these lines do not prune relevant instances. On the one hand, if we have that for some  $i$: $c_i * cex$, then, if we continue to search for implementations with the actual counterexamples (\emph{cexs[i]}), if some implementation is found then we known that $p_0 \parallel \dots \parallel p_n \vDash \NOT(cex)$, since $cex$ is a counterexample for the property. That is, adding $cex$ to the set of the counterexamples will not rule out this implementation, and furthermore it will speed out the searching process (other implementations do not satisfying this counterexample will be discarded by the Alloy tool). In the case of line $17$, the projections of the found counterexample are already in the other processes' array, but it is disjoint with the counterexamples being taken into account for process $n$, then it is added to $cex$. As before this does not overrule possible correct implementation.
%	On the other hand, if line $19$ is executed, then we replace a counterexample $c'$ by $c \sqsubseteq c'$, in this case let us note that, if an implementation $p_0, \dots, p_n$ is found
%such that $p_0 \parallel \dots \parallel p_n \vDash \phi$, then $p_0 \parallel \dots \parallel p_n \vDash \NOT(c)$, because of theorem \ref{},  those instances should be found when the counterexamples are swapped, and $c$ by the definition of $\subseteq$ is shorter, this accelerates the search. 

%	Summing up, we obtain the following theorem.
%\begin{theorem}\label{theorem:cex-completeness} Alg.~\ref{alg1} terminates, it is sound and (bounded-)complete.
%\end{theorem}
	
	

