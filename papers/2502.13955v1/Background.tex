%!TEX root=main.tex
\section{Preliminaries} 
\label{sec:background}

%Let us provide, in this section, a brief introduction to the concepts used throughout the paper. 

\paragraph{Labeled Transition Systems.}

A well-established mechanism to provide semantics for reactive and distributed systems is via \emph{labeled transition systems} (LTSs). An LTS  is a tuple $\langle S, \textit{Act}, \rightarrow, I, \textit{AP}, L \rangle$ where: $S$ is a (finite) non-empty set of \emph{states}, $\textit{Act}$ is a (finite) set of \emph{actions}, $\rightarrow \subseteq S \times \textit{Act} \times S$ is a labeled transition relation, $I \subseteq S$ is a set of \emph{initial states}, $\textit{AP}$ is a (finite) set of atomic propositions, and $L:S \rightarrow 2^{\textit{AP}}$ is a labeling function. Intuitively, $S$ is an abstraction of the system states, $L$ indicates which atomic properties hold in each state, $\textit{Act}$ is an abstraction of the system actions, and $\rightarrow$ indicates how the system changes state as actions occur. For convenience, we write $s \xrightarrow{a} s'$ instead of $\langle s,a,s'\rangle \in \rightarrow$, and  $\post{s}{s'}$ if there is an $a \in \textit{Act}$ such that $s \xrightarrow{a} s'$. The reflexive-transitive closure of relation $\mathit{Post}$ helps capturing system executions, and is written $\mathit{Post}^*$.  A path over an LTS is a sequence of alternating states and actions $\pi=s_0, a_0,s_1, a_1 \dots$ such that $\forall i: s_i \xrightarrow{a_i} s_{i+1}$. We say that a path is an \emph{execution} (or \emph{trace}) if it is maximal. Without loss of generality, we assume that each state has at least one successor. When only states or transitions are relevant, we refer to executions as sequences of states or transitions. We extend $L$ to paths as follows: $L(\pi) = L(s_0, a_0,s_1, a_1,s_2, \dots) = L(s_0),L(s_1),L(s_2),\dots$. When convenient, we use notation $x(s)$ as an abbreviation of  $x \in L(s)$. An execution $\pi$ is \emph{fair} if $s,a,s'$ appears infinitely often in $\pi$ given that $s$ appears infinitely often in $\pi$ and $s \xrightarrow{a} s'$. From now on, $\Path{T}$ denotes  the set of paths of $T$, $\traces{T}$ denotes its set of executions, and $\fairtraces{T}$ denotes  its set of fair executions.

Throughout the paper we use the following notation, $(x_0,\dots,x_n){\uparrow}i$ denotes the $i$-th projection of tuple $(x_0,\dots,x_n)$. $[0,k]$ denotes the set $\{0,\dots,k\}$, $\prod_{i \in I} S_i$ refers to the Cartesian product of sets $S_i$, and $\coprod_{i \in I} S_i$ denotes the coproduct of sets $S_i$.

\paragraph{(Extended) First-Order Logic over LTSs.} Properties over LTSs will be expressed using first-order formulas. The logic is essentially the relational logic underlying Alloy \cite{AlloyBook}. For the sake of clarity, we will use standard first-order logic extended with transitive closure. Given actions $\textit{Act}$ and a set $\mathit{AP}$ of atomic propositions, the basic vocabulary consists of binary predicates $\{a \mid a \in \mathit{Act}\}\cup\{\mathit{Post}\}$, unary predicates $\{p \mid p \in \mathit{AP}\} \cup \{I\}$; the logical operators are the usual Boolean connectives and first-order quantifiers with variables ranging over states. We consider the reflexive-transitive closure operator, written $a^*$ (for any binary predicate $a$). Reflexive-transitive closure is necessary to express reachability constraints. Given an LTS $T$ and a formula $\phi$, we write $T \vDash \phi$ iff $\phi$ \emph{holds in} $T$. As a sample formula, $\exists s,s': I(s) \wedge \tcpost{s}{s'} \wedge p(s')$ states that $p$ holds in some state reachable from an initial state.

\paragraph{Linear-Time Temporal Logic.}	Linear-time temporal logic ({\LTL}) is a well-known logical formalism, that has been successfully used for specifying temporal properties of concurrent and reactive systems \cite{Katoen08}. Given a set $\textit{AP}$ of atomic propositions, the syntax of {\LTL} is inductively defined, using the standard logical and temporal operators, by the following grammar: $\Phi ::= p \mid \neg \Phi \mid \Phi \vee \Phi \mid  \X \Phi \mid \Phi \Until \Phi$, where $p \in \textit{AP}$. Additional operators, such as $\textit{true}$, $\textit{false}$, $\Future \phi$ (\emph{eventually} $\phi$), $\Always \phi$ (\emph{always} $\phi$) and $\phi \WUntil \psi$ ($\phi$ (weak) until $\psi$), can be defined as combinations of the above operators \cite{Katoen08}. {\LTL} formulas are interpreted over infinite sequences of Boolean assignments for variables in $\textit{AP}$, i.e., each sequence is of the form $\pi=\sigma_0 \sigma_1 \sigma_2 \dots \in (2^{\textit{AP}})^{\omega}$. The interpretation of {\LTL} formulas can be given as a satisfaction relation $\vDash$, defined recursively as follows: 
\begin{itemize}
\item $\sigma \vDash p$ iff $p \in \sigma_0$,
\item $\sigma \vDash \phi \vee \psi$ iff $\sigma \vDash \phi$ or $\sigma \vDash \psi$
\item $\sigma \vDash \X \phi$ iff $\sigma_1 \sigma_2 \dots \vDash \phi$ 
\item $\sigma \vDash \phi \Until \psi$ iff   $\exists k \geq 0: \sigma_k \sigma_{k+1} \dots \vDash \psi$ and $\forall 0 \leq i<k: \sigma_i \sigma_{i+1} \dots \vDash \phi$. 
\end{itemize}
{\LTLX} \cite{Katoen08} is the fragment of {\LTL} obtained by omitting operator $\X$ from formulas, typically used for expressing {\LTL} stutter invariant properties of concurrent systems \cite{PeledWilke1997}. We employ {\LTLX} to specify the global properties over distributed systems. Given a LTS $T$ and a {\LTL} formula $\phi$, we say that $T \vDash \phi$ (resp. $T \vDash_f \phi$) iff $L(\pi) \vDash \phi$ for every $\pi \in \traces{T}$ (resp. $\pi \in \fairtraces{T}$). 

\paragraph{Process Descriptions.}
\label{sec:programming-language} 
While transition systems serve as a low-level description of reactive system behavior, such systems are typically better described as a collection of interacting processes,  as done in languages like Promela.  For the sake of simplicity,  here we use a  simple guarded-command language, as those defined in  \cite{Dijkstra1975,AroraGouda93}.  A system will then consist of a collection of shared variables, and a collection of processes, that execute concurrently in an asynchronous way. Each process has its own collection of local variables, an initialization condition indicating in which (local) state each process starts execution, and a set of guarded actions that establish how a process can proceed execution. Each atomic action has the form $[a]B \rightarrow C$ where: $a$ is the name of the action,  $B$ (called the guard) is a Boolean statement over the (shared and local) variables of the program, and $C$ is a collection of assignments, written $x_0{:=}E_0, \dots, x_n{:=}E_n$, where the $x_i$'s  are local or shared variables, and $E_i$'s are expressions of the correct type. We assume that the test of $B$ and the assignments in $C$ are all executed atomically. The operational semantics of this process notation is simple. A state is an assignment of values to the variables in the program. An action $B \rightarrow C$ is enabled in a state, if $B$ is true in that state. An execution of $P$ is a sequence of states satisfying the following conditions: (i) the initial state satisfies the initial conditions, (ii) if state $s_i$ follows from $s_{i-1}$ in the sequence, then we have some action $B \rightarrow C$ such that $B$ holds at $s_{i-1}$ and executing $C$ results in $s_i$, (iii) the sequence is infinite (we assume that when no action is enabled then the last state is repeated). By this semantics, mapping process/system executions to LTSs is straightforward, and thus the definition of satisfaction of LTL properties by system/process executions is direct. 
%\subsubsection*{Alloy.}
%\fi
