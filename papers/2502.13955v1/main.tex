%
%  $Description: Author guidelines and sample document in LaTeX 2.09$ 
%
%  $Author: ienne $
%  $Date: 1995/09/15 15:20:59 $
%  $Revision: 1.4 $
%
\pdfoutput=1
\documentclass[runningheads]{llncs}
%\usepackage{amsthm}
\usepackage{physics}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{capt-of}% or \usepackage{caption}
\usepackage[all]{xy}
\usepackage{tikz}
\usepackage{multirow}
\usetikzlibrary{shapes,arrows,automata,shadows,positioning,fit}
\usepackage{paralist} % for inline itemize
\usepackage{xspace}
\usepackage{alltt}
\usepackage{enumerate}
\usepackage[inline,shortlabels]{enumitem}
\usepackage{mathtools}
\usepackage{bm}
\usepackage{courier}
\usepackage{color}
\usepackage{caption}
\usepackage{stmaryrd}
\usepackage{adjustbox}
\usepackage{wrapfig}
\usepackage{todonotes}
\usepackage{pgfplots}
\usepackage{amstext} % for \text macro
\usepackage{array}   % for \newcolumntype macro
\usepackage[colorlinks=true,citecolor=blue,linkcolor=blue,urlcolor=blue]{hyperref}
\captionsetup{justification=Centering,
              skip=0.5\baselineskip}
\newcolumntype{L}{>{$}l<{$}} % math-mode version of "l" column type
\usetikzlibrary{decorations.pathreplacing,calc}

\usepackage[algoruled,vlined,linesnumbered]{algorithm2e}
\SetKwInOut{Input}{input}
\SetKwInput{KwInput}{Input}                % Set the Input
\SetKwInput{KwOutput}{Output}              % set the Output
%\usepackage{algorithmic}
\usetikzlibrary{decorations.pathreplacing,calc}
%\usepackage[colorlinks=true,citecolor=blue,linkcolor=blue,urlcolor=blue]{hyperref}

\newcommand{\tikzmark}[1]{\tikz[overlay,remember picture] \node (#1) {};}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}

%\usepackage[linesnumbered,vlined,boxed]{algorithm2e}
%% Save the class definition of \subparagraph


\newcommand{\quotes}[1]{``#1''}
\newcommand{\CTL}{\textsf{CTL}}
\newcommand{\LTL}{\textsf{LTL}}
\newcommand{\LTLX}{\textsf{LTL$\setminus$X}}
\newcommand{\FORL}{\textsf{FORL}}
\newcommand{\JAVA}{\textsf{JAVA}}
\newcommand{\Sketch}{\textsf{Sketch}}
\newcommand{\PSketch}{\textsf{PSketch}}
\newcommand{\AlloyStar}{\textsf{Alloy}$^*$}
\newcommand{\Alloy}{\textsf{Alloy}}
\newcommand{\KodKod}{\textsf{KodKod}}
\newcommand{\NuSMV}{\textsf{NuSMV}}
\newcommand{\psketch}{\textsf{PSketch}}
\newcommand{\Party}{\textsf{Party}}

\newcommand{\spec}{Spec}
\newcommand{\tree}{\mathcal{T}}
\newcommand{\modelsss}{\models^{*}}

\newcommand{\E}{\mathbf{E}}
\newcommand{\A}{\mathbf{A}}
\newcommand{\X}{\bigcirc}
\newcommand{\Until}{\mathbf{U}}
\newcommand{\Always}{\Box}
\newcommand{\WUntil}{\mathbf{W}}
\newcommand{\Future}{\Diamond}
\newcommand{\CNF}{\mathsf{CNF}}
\newcommand{\NOT}{\mathsf{NOT}}
\newcommand\proj{\mathord{\uparrow}}
\newcommand{\formula}{\text{Formula}}
\newcommand{\expr}{\text{expr}}
\newcommand{\decl}{\text{decl}}
%\newcommand{\var}{\text{var}}
\newcommand{\typexpr}{\text{typeexpr}}
\newcommand{\probl}{\text{problem}}
\newcommand{\all}{\textsf{all}}
\newcommand{\some}{\textsf{some}}
\newcommand{\conj}{\textsf{and}}
\newcommand{\disj}{\textsf{or}}
\newcommand{\equival}{\textsf{iff}}
\newcommand{\imp}{\textsf{implies}}
\newcommand{\type}{\text{type}}
\newcommand{\inc}{\textsf{in}}
\newcommand{\nega}{\textsf{not}}
\newcommand{\Variable}{\text{Var}}
\newcommand{\variable}{\text{var}}
\newcommand{\traces}[1]{\mathit{Traces}(#1)}
\newcommand{\fairtraces}[1]{\mathit{FairTraces}(#1)}
\newcommand{\Path}[1]{\mathit{Path}(#1)}
\newcommand{\post}[2]{\mathit{Post}(#1,#2)}
\newcommand{\tcpost}[2]{\mathit{Post}^*(#1,#2)}
\newcommand{\lts}[1]{#1 = \langle S, \textit{Act}, \rightarrow, I, \textit{AP}, L \rangle}
\newcommand{\nonamelts}{\langle S, \textit{Act}, \rightarrow, I, \textit{AP}, L \rangle}
\newcommand{\indexedlts}[2]{#1 = \langle S^{#2}, \textit{Act}^{#2}, \rightarrow^{#2}, s^{#2}_0, \textit{AP}^{#2}, L^{#2}\rangle}
\newcommand{\refin}[1]{\mathit{Ref}(#1)}
\newcommand{\processspec}[1]{#1 = \langle \langle \mathit{Sh},  \mathit{Loc}, \mathit{Act}\rangle, \Phi \rangle}
\newcommand{\nonameprocessspec}{\langle \langle \mathit{Sh},  \mathit{Loc}, \mathit{Act}\rangle, \Phi \rangle}
\newcommand{\specif}[1]{#1 = \langle \{ P^i \}_{i \in \mathcal{I}}, \phi \rangle}
\newcommand{\nonamespecif}{\langle \{ P^i \}_{i \in \mathcal{I}}, \phi \rangle}



%\theoremstyle{definition}
%\newtheorem{example}{Example}[section]
%\theoremstyle{definition}
%\newtheorem{definition}{Definition}[section]
%\theoremstyle{definition}
%\newtheorem{theorem}{Theorem}[section]
\newcommand{\lstfont}[1]{\color{#1}\scriptsize\ttfamily}

\newcounter{nalg} % defines algorithm counter for chapter-level
\renewcommand{\thenalg}{\arabic{nalg}} %defines appearance of the algorithm counter
\DeclareCaptionLabelFormat{algocaption}{Algorithm \thenalg} % defines a new caption label as Algorithm x.y

\lstdefinestyle{Spec}{
    %language=Spec,
    showstringspaces=false,
    backgroundcolor=\color{white},
    basicstyle=\lstfont{black},
    identifierstyle=\lstfont{black},
    keywordstyle=\color{black}\bfseries,%\lstfont{magenta!40},
    numberstyle=\lstfont{black},
    stringstyle=\lstfont{cyan},
    commentstyle=\lstfont{red},
    emph={
        action, process,
        spec, invariant, main, 
    },
    emphstyle=\color{black}\bfseries,
    breaklines=true
}

\lstdefinestyle{Unity}{
    %language=Alloy,
    mathescape=true,
    showstringspaces=false,
    backgroundcolor=\color{white},
    basicstyle=\lstfont{black},
    identifierstyle=\lstfont{black},
    keywordstyle=\color{black}\bfseries\em,
    numberstyle=\lstfont{black},
    stringstyle=\lstfont{cyan},
    commentstyle=\lstfont{red},
    emph={
        var, Program, Process, begin, end, initial
    },
    emphstyle={\lstfont{black}\bfseries},
    breaklines=true
}

\lstnewenvironment{algo}[1][] %defines the algorithm listing environment
{   
    \refstepcounter{nalg} %increments algorithm number
    \setcounter{lstlisting}{\value{nalg}}
    \captionsetup{labelformat=algocaption,labelsep=colon} %defines the caption setup for: it ises label format as the declared caption label above and makes label and caption text to be separated by a ':'
    \lstset{ %this is the stype
        mathescape=true,
        frame=tB,
        numbers=left, 
        numberstyle=\tiny,
        %basicstyle=\scriptsize, 
        basicstyle= \scriptsize\ttfamily,%\lstfont{black},
        keywordstyle=\color{black}\bfseries\em,
        %keywordstyle=\lstfont{blue},
        keywords={,input, output, return, datatype, function, in, if, else, foreach, while, begin, end, endif, endwhile, endfor, procedure, then, for, do, all, some, such, that,} %add the keywords you want, or load a language as Rubens explains in his comment above.
        numbers=left,
        xleftmargin=.04\textwidth,
        emphstyle={\bfseries},%{\lstfont{blue}},
        morecomment=[l]{//},  % l is for line comment
        #1 % this is to add specific settings to an usage of this environment (for instnce, the caption and referable label)
    }
}
{}




\addtolength{\textfloatsep}{-0.2in}
%\documentstyle[times,art10,twocolumn,latex8]{article}

%------------------------------------------------------------------------- 
% take the % away on next line to produce the final camera-ready version 
%\pagestyle{empty}

%------------------------------------------------------------------------- 


%\title{Synthesis of Synchronization  Skeletons of Concurrent Programs using SAT Solving and Symbolic Model Checking} 
\title{Bounded Synthesis of Synchronized Distributed Models from Lightweight Specifications} 
\titlerunning{Bounded Synthesis of Synchronized Distributed Models...}
\author{Pablo F.  Castro\inst{1,2},
Luciano Putruele\inst{1,2} \\
Renzo Degiovanni\inst{3},
Nazareno Aguirre\inst{1,2} 
}
%\institute{}
%\authorrunning{Castro et al.}
\institute{Departamento de Computaci\'on, Universidad Nacional de R\'io Cuarto, Argentina \and
Consejo Nacional de Investigaciones Cient\'ificas y T\'ecnicas (CONICET), Argentina \and
Luxembourg Institute of Science and Technology, Luxembourg}

\begin{document}

\maketitle
%\thispagestyle{empty}
\begin{abstract}
We present an approach to automatically synthesize synchronized  models from lightweight formal specifications.  Our approach takes as input a specification of a distributed system along with a global linear time constraint, which must be fulfilled by the interaction of the system's components.  It produces executable models for the component specifications (in the style of Promela language) whose concurrent execution satisfies the global constraint.  The component specifications consist of  a collection of actions described by means of pre and post conditions together with first-order relational formulas prescribing their behavior.  We use the \emph{Alloy Analyzer} to encode the component specifications and enumerate their potential implementations up to some bound,  whose concurrent composition is model checked against the global property.  Even though this approach is sound and complete up to the selected bound,  it is impractical as the number of candidate implementations grows exponentially.  
To address this, we propose an algorithm that uses batches of counterexamples to prune the solution space, it has two main phases:  \emph{exploration}, 
the algorithm collects a batch of counterexamples, and \emph{exploitation},   where this knowledge is used to speed up the search.
The approach is sound,  while  its completeness depends on the batches used.
We present a prototype tool,  describe some  experiments,  and compare it with  related approaches.

%We assume  multi-threaded shared-variables model of computation. Our approach takes as input a collection of specifications for a distributed system, expressed with pre/post-conditions for their actions and first-order (local) constraints, together with a global temporal constraint, to be achieved by the process interaction. We encode the process specifications into Alloy, and use Alloy Analyzer to enumerate potential implementations of the (local) processes, whose concurrent composition is model checked against the global property. If successful, a distributed algorithm is obtained; otherwise, the obtained counterexamples are used to guide the SAT-based search, by incrementally refining the local process implementations. We show that our approach is sound and complete, for a given bound on the size of the process implementations. We also present a prototype of our approach and its application to well-known case studies of distributed algorithms. 
%%%%%VERSION ANTERIOR
%In this paper, we present an approach to automatically synthesize synchronization code for distributed programs, assuming a multithread shared-variables model of computation. Our method combines SAT solving over specifications written in First-Order Relational Logic, and symbolic  model checking. Intuitively, our approach starts by using SAT solving to enumerate potential implementations of the (local) processes, and checking if there are executions of their concurrent composition that falsify the required global properties, this is done until a valid synchronization code is obtained. This latter step is  performed  via a symbolic model checker, the obtained counterexamples are used to incrementally refine the SAT-based search for local process implementations. We  developed a prototype of our approach and applied it to well-known case studies of distributed algorithms.	
%%%%%%%%%%	 
	 
%   Developing \emph{correct} concurrent programs is known to be a very challenging task, this is mainly due to subtle misbehaviours that may arise in concurrent settings, such as deadlocks and race conditions. Many of these situations are due to an incorrect use of synchronization primitives such as locks and semaphores. Furthermore, this situation is even worse for distributed algorithms, i.e., concurrent programs whose components act independently to achieve a common goal, which usually lack from a centralized control.
	 

%	terms of the set of actions that each process is allowed to execute, together with a collection of global properties, expressed in temporal logic, that the concurrent execution of the processes must satisfy. Intuitively, our approach starts by using SAT solving to enumerate potential implementations of the (local) processes, and checking whether their concurrent composition satisfies the required global properties, until a valid synchronization skeleton is obtained. This latter step is performed using symbolic model checking, and the obtained counterexamples are used to incrementally refine the SAT-based search for local process implementations. We show that our approach is correct and (bounded-)complete, under user predefined bounds for process size (in terms of their maximum number of states)

%Concurrency enables software efficiency improvements by exploiting modern multi-processor hardware, but developing \emph{correct} concurrent programs is known to be a very challenging task, due to subtle misbehaviours that arise in concurrent settings, such as deadlocks and race conditions. Many of these situations are due to an incorrect use of synchronization primitives such as locks and semaphores, which can often be decoupled from the actual computations being carried out by the concurrent processes, and avoided through the use of appropriate \emph{synchronization skeletons}. In this paper, we present an approach to automatically synthesize synchronization skeletons of concurrent programs, that combines SAT solving and symbolic model checking. Our approach takes as input a set of process specifications, described in terms of the set of actions that each process is allowed to execute, together with a collection of global properties, expressed in temporal logic, that the concurrent execution of the processes must satisfy. Intuitively, our approach starts by using SAT solving to enumerate potential implementations of the (local) processes, and checking whether their concurrent composition satisfies the required global properties, until a valid synchronization skeleton is obtained. This latter step is performed using symbolic model checking, and the obtained counterexamples are used to incrementally refine the SAT-based search for local process implementations. We show that our approach is correct and (bounded-)complete, under user predefined bounds for process size (in terms of their maximum number of states). Moreover, we assess our approach and show that it can effectively produce synchronization skeletons for a number of case studies commonly found in the literature.
\end{abstract}

\input{intro}
\input{Background}
\input{Motivation}
\input{specs}
\input{Algo}
\input{Examples}
\input{Related}
\input{Conclusions}

\bibliographystyle{splncs}
\bibliography{myBib}



%% Bibliography
%\bibliography{bibfile}


%% Appendix
\appendix
%\section{Appendix}
\input{appendix}
%Text of appendix \ldots

\end{document}
