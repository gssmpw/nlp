\subsection{Using Prometheus Operator in K8s Cluster to Monitor Application Metrics}
\label{prometheus-operator}

This section explains how to utilize the Prometheus Operator in a Kubernetes (K8s) cluster for monitoring application metrics. The process involves deploying Service and ServiceMonitor objects along with Prometheus instances to collect metrics from the applications.

The Prometheus Operator streamlines the configuration and management of Prometheus monitoring instances within Kubernetes. By leveraging ServiceMonitor objects, users can define how services should be monitored. These configurations enable Prometheus to automatically discover and scrape metrics from specified services.

An important distinction between using a regular kubelet and the virtual-kubelet-cmd lies in the assignment of pod IPs. For pods created by the virtual-kubelet-cmd (VK), the pod IP is defined by the environment variable \texttt{VKUBELET\_POD\_IP} when starting VK. This can result in pods within a Kubernetes deployment sharing the same IP, unlike the unique IPs assigned to pods created by the regular kubelet.

The following subsections provide detailed instructions on setting up the Prometheus Operator, deploying services and ServiceMonitor objects, and configuring Prometheus instances to scrape metrics.

\subsubsection{Setting Up the Prometheus Operator}

The Prometheus Operator can be installed using Helm or by deploying the necessary components from the kube-prometheus project. The kube-prometheus project provides a comprehensive set of manifests for deploying and configuring Prometheus, Alertmanager, and Grafana, along with the necessary configuration for scraping metrics from Kubernetes services \cite{kube-prometheus}.

\subsubsection{Deploying Applications and Monitoring with Unique Pod IPs}

Due to the different pod IPs of pods created by VK, we describe how to deploy an application and its monitoring depending on the uniqueness of the pod IP.

\paragraph{Pod IP and Metrics Ports}
Figure \ref{fig:unique-pod-ips} illustrates the deployment of a Kubernetes application with two replicas, resulting in the creation of two pods. These pods are scheduled to run on nodes with the DNS names `ejfat-2` and `ejfat-3`, which are set up on the control-plane. Each pod's IP address is defined by the `VKUBELET\_POD\_IP` environment variable (see Table \ref{table:environment_variables}) when starting the virtual kubelet (VK). This ensures that each pod is assigned a specific IP address corresponding to the DNS name of the node it is running on. For example, the pod running on the node with DNS name `ejfat-2` will have the IP address `ejfat-2`, and the pod on the node with DNS name `ejfat-3` will have the IP address `ejfat-3`. Each pod exports metrics on the same set of ports: 2221, 1776, and 8088. The pods have labels `a:b` for identification.

\paragraph{Service Creation}
A Kubernetes Service object is created to expose the metrics endpoints of these pods. The Service object aggregates the exported ports from both pods, creating a unified service that maps `ejfat-2:1776` and `ejfat-3:1776` along with the other ports. Since the service is set up on the control-plane (CP) of the cluster, ensure that `ejfat-2:ports` and `ejfat-3:ports` (where ports are 2221, 1776, and 8088) can be reached from the CP. This Service is responsible for combining these endpoints under a single ClusterIP, which allows Prometheus to access the metrics uniformly. The Service watches pods with the label `a:b`. Ensure that the labels of monitored pods are set up correctly here.

\paragraph{ServiceMonitor Configuration}
A ServiceMonitor object is defined to monitor the Service. The ServiceMonitor looks at the specified Services and configures Prometheus to scrape the metrics from these endpoints. The ServiceMonitor watches services with the label `c:d`. Ensure that the labels of the monitored services are set up correctly to allow Prometheus to discover and scrape the metrics properly.

\paragraph{Prometheus Instance}
The Prometheus instance, configured through the ServiceMonitor, scrapes the metrics from the Service endpoints. The data is then stored in a PersistentVolume Claim for durable storage and further analysis.

\begin{figure}[htbp]
\centering
\includegraphics[width=\textwidth]{core_component/fig/monitoring.pdf}
\caption{Deployment and monitoring of Kubernetes applications with unique pod IPs using Prometheus Operator. The figure illustrates a Kubernetes application with two replicas, each assigned a unique IP address based on the DNS name of the node it runs on. Metrics are exported from each pod on ports 2221, 1776, and 8088, aggregated by a Service object, and monitored by a ServiceMonitor for Prometheus scraping.}
\label{fig:unique-pod-ips}
\end{figure}

\subsubsection{Deploying Applications and Monitoring with Same Pod IPs}

When the pod IPs are the same, it creates a different challenge. If the exporter ports are also the same for each pod, the service will not be able to route the ports correctly due to the identical pod IPs.

\paragraph{Pod IP and Metrics Ports}
In this scenario, both pods are assigned the same IP address by the `VKUBELET\_POD\_IP` environment variable. Since the IPs and ports are identical, this can cause conflicts in routing the metrics.

\paragraph{Service Creation}
To resolve this issue, map the exporter ports from the pods onto different ports for each pod on the control-plane (CP). Create separate services for each pod, ensuring that each service maps the pod's exporter ports to unique ports on the CP. This allows the metrics to be correctly routed despite the identical pod IPs.

\paragraph{ServiceMonitor Configuration}
Create separate ServiceMonitor objects for each service. Each ServiceMonitor will watch its corresponding service and set up Prometheus to scrape metrics from the unique ports. Ensure that the labels for these services are correctly configured so that Prometheus can discover and scrape the metrics properly.

\paragraph{Prometheus Instance}
Use the same Prometheus instance to scrape metrics from both services. This configuration allows the metrics to be collected together and analyzed as a unified dataset.
