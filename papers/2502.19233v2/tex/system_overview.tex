

We build an emulation platform based on real-world CXL device to evaluate the performance improvement of HeteroBox compared to software method. 
As shown in Figure \ref{fig:heterobox_system_overview}, the enumeration platform is built upon an intel Agilex 7 FPGA, which consists of four main components: \textbf{Remap Table}, \textbf{Profile Unit}, \textbf{Migrate Unit} and \textbf{Latency module}. Besides, we implement software interface support for the enumeration platform, including software driver in the kernel and BAR regs in the device for configuration and debugging.


\noindent{\textbf{Remap Table:}} HeteroBox proposes to manage the heterogeneous memory system totally on the device side. This includes migrating the hot data from slow memory media to fast memory media, and migrating the cold data from fast memory media to slow memory media. As a result, the device needs to record the actual address of data when receiving a memory request issued by the host. We build a remap table module to do this, which receives memory requests from the host and translates the memory request to its actual address in the device, and then forwards the translated request to the succeeding modules. The remap table should be carefully designed, because: 1) It is on the critical path of a memory request, which shouldn't introduce too much latency, otherwise it will affect the overall performance the memory system. 2) The translation granularity of remap table further determines the migration granularity, in which smaller granularity means larger overhead of remap table yet less migration amplification, larger granularity introduce less overhead in remap table yet cause more serious migration amplification. We will discuss these trade-offs of remap table in section \ref{}.

\input{fig_tex/heterobox_system_overview}

\noindent{\textbf{Profile Unit:}} To optimize the performance the heterogeneous memory system, we need to migrate the hot data to fast memory media. We build Profile Unit to measure the hotness of data at different address in the device. The Profile Unit take memory requests which are already translated by remap table as input and record this access. When the Profile Unit recognize data at a address as hot, it will issue a signal to remap table to indicate that a migration event should be executed. The signal contains a pair of address, which locate in fast memory region and slow memory region respectively. The Profile Unit should classify hot page and cold page accurately to do the right migration decision. For hot pages, we implement a sketch to evaluate the access time of each page and choose those with a access time larger than a threshold to be hot.
Cold pages, however, are harder to detect. Building a LRU-like structure in a GB-level address space is impracticable because of it will consume large amount of hardware resource. Fortunately, cold page tends to remain  cold in relatively longer time\cite{?}. Based on this insight, we use a periodically scanning method to balance the hardware overhead and profiling accuracy.
%For cold pages, we scan the address space periodically and choose those with smallest access time as cold pages.
Besides, we design a dynamic hotness threshold setting mechanism to ensure that the hottest part of data remain in fast memory. We will discuss the design of Profile Unit in detail in section ?.

\noindent{\textbf{Migrate Unit:}} The Migrate Unit is responsible for data migration. It takes in two address, corresponding to two pages, and it swap the content of these two pages. The key point in designing a Migrate Unit is that we need to keep all migration event transparent to CPU. To achieve that, we need to update the Remap Table when migration happens. Also, we need to ensure that at the when the Migrate Unit has already finished migrating data and the Remap Table has not updated its translation rule, no memory request can go through the Remap Table, being translated and sent to the DRAM module, otherwise it will cause broken data. We will discuss our design of Migrate Unit and how it co-operate with Remap Table in detail in section ?.

\noindent{\textbf{Latency Module:}} We build our enumeration platform on a FPGA board with homogeneous DRAM memory, yet we need to enumerate heterogeneous memory system with different configuration, such as different capacity ratio and different latency. To achieve that, we build a Latency module as an abstract layer between memory controller and other logic. It can be configured to devide the DRAM into two regions, which make an illusion that the two regions has different latency attribute, thus forming a abstraction of heterogeneous memory system with two-tiered memory. We will discuss the design of Latency Module in detail in section ?. 

