

\subsection{Software-based memory tiering system}

% Many previous works using software-based method try to optimize the performance of memory tiering system in various aspects, including memory access profiling~\cite{thermostat_asplos17, dancing_ipdps21, re_fault_icbdsc22, damon}, page migration~\cite{page_migration_support_for_disaggregated_non_volatile_memories_memsys19, granularity_aware_page_migration_ics18, nimble_asplos19} and huge page strategy~\cite{amp, memtis_sosp23}.
% TPP~\cite{tpp_asplos23} proposes to promote a page after it is scanned with access bit set for twice. MEMTIS~\cite{memtis_sosp23} proposes to use histogram-based hot set classification to achieve more stable hot page detection. NOMAD~\cite{nomad_osdi24} proposes to use transactional page migration to mitigate the overhead of page migration.
% Besides, there are also works utilizing information in application to manage the data placement at the object level~\cite{memkind, pmdk, hildebrand2020autotm, li2022GCMove, ren2021sentinel, Wang2019Panthera}.
% However, though these works endeavour to optimize the performance of memory tiering system, their performance are limited by the inherent inaccuracy of software profiling and high overhead of data migration using CPU, as we describe in section~\ref{sec:background}.
% Our HeteroMem design uses hardware-based, high resolution and accurate profiling for hot page detection. Meanwhile, HeteroMem uses hardware-based data movement, which achieves high bandwidth and low overhead, and waste no CXL link bandwidth. 

Many previous works using software-based methods have tried to optimize the performance of memory tiering systems in various aspects, including memory access profiling~\cite{thermostat_asplos17, dancing_ipdps21, re_fault_icbdsc22, damon}, page migration~\cite{page_migration_support_for_disaggregated_non_volatile_memories_memsys19, granularity_aware_page_migration_ics18, nimble_asplos19}, page classification~\cite{ebm, multi-clock}, and huge page strategies~\cite{amp, memtis_sosp23}.
TPP~\cite{tpp_asplos23} proposes to promote a page after it is scanned with the access bit set twice. MEMTIS~\cite{memtis_sosp23} uses histogram-based hot set classification to achieve more stable hot page detection. NOMAD~\cite{nomad_osdi24} employs transactional page migration to mitigate the overhead of page migration.
Additionally, there are works that utilize application-level information to manage data placement at the object level~\cite{memkind, pmdk, hildebrand2020autotm, li2022GCMove, ren2021sentinel, Wang2019Panthera, wei2015_2pp}. However, although these works strive to optimize the performance of memory tiering systems, their performance is limited by the inherent inaccuracy of software profiling and the high overhead of data migration using the CPU, as described in Section~\ref{sec:background}.
% Our HeteroMem design employs a hardware-based high-resolution, and profiling scheme for hot and cold page detection. Meanwhile, HeteroMem uses hardware-based data movement, which achieves high bandwidth and low overhead without wasting CPU cycles and CXL link bandwidth.
Our HeteroMem design employs a hardware-based high-resolution profiling scheme for hot and cold page detection. Meanwhile, HeteroMem uses hardware-based data movement, which achieves high bandwidth and low overhead without wasting CPU cycles and CXL link bandwidth.

\subsection{Hardware-based memory tiering system}

% There are also many works try to optimize the memory tiering system using hardware-based method. 
% %They manage the memory tiering system in a cache-like manner~\cite{cameo_micro14, slic_fm_hpca17, chameleon_micro18, sehmm_sc10}, which means data movement is limited in constraint set, or allow data to be migrated arbitrarily~\cite{mempod_hpca17}.
% They manage the fast memory as memory cache~\cite{optane_memory_mode} or use the fast memory in flat memory mode~\cite{cameo_micro14, slic_fm_hpca17, chameleon_micro18, sehmm_sc10, mempod_hpca17}.
% Intel Optane persistent memory provides memory mode~\cite{optane_memory_mode}, allowing user to use DRAM as a cache for the non-volatile memory. 
% CAMEO~\cite{cameo_micro14} combines memory cache mode and flatten address mode, which proposes to manage the fast memory in a cache-like manner, constraining the data movement in associate sets and moving data in cacheline granularity.
% MemPod~\cite{mempod_hpca17} groups HBM and DRAM connected to CPU into clusters called Pod and manage the data placement within each Pod. 
% However, these hardware-based methods, proposed before the CXL era, involves intrusive modification in the CPU, which makes them inflexible and fail to adapt to dynamic and various CXL-based device-side heterogeneous memory system.
% HeteroBox places all its hardware logic at device side and can be runtime configured to adapt to various heterogeneous memory system configuration, which is a one-for-all solution.

There are also many works that try to optimize memory tiering systems using hardware-based methods. They manage fast memory as a memory cache~\cite{optane_memory_mode} or use fast memory in flat memory mode~\cite{cameo_micro14, slic_fm_hpca17, chameleon_micro18, sehmm_sc10, mempod_hpca17, hopp}. Intel Optane persistent memory provides memory mode~\cite{optane_memory_mode}, allowing users to use DRAM as a cache for non-volatile memory.
CAMEO~\cite{cameo_micro14} combines memory cache mode and flat address mode. It manages fast memory in a cache-like manner, constrains data movement within associated sets, and moves data at cacheline granularity. MemPod~\cite{mempod_hpca17} groups HBM and DRAM connected to CPU into clusters called \emph{Pods} and manages data placement within each Pod.
However, these hardware-based methods, proposed before the CXL era, involve intrusive modifications to CPU, making them inflexible and unable to adapt to dynamic and diverse CXL-based device-side heterogeneous memory systems. 
HeteroMem, on the other hand, places all its hardware logic on the device side and can be runtime configured to adapt to various heterogeneous memory system configurations, offering a one-for-all solution.

% \rebuttal{A recent work, NeoMem, proposes to profile the hot data at device side and achieves state-of-the-art performance. However, NeoMem still profiles the cold data at the CPU side and uses CPU to do data movement, which makes it CPU intransparent and inefficient, while HeteroMem use device side hardware logic to do both hotness and coldness profiling, creates a homogeneous abstraction to CPU, which improves performance.}
% \rebuttal{A recent work, NeoMem, introduces a method to profile hot data at the device side, achieving state-of-the-art performance. However, NeoMem still relies on CPU-side profiling for cold data and uses the CPU to manage data movement. This approach lacks CPU transparency and is inefficient. In contrast, HeteroMem employs device-side hardware logic for profiling both hot and cold data, as well as managing data movement, creating a homogeneous abstraction for the CPU and improving overall performance.}
A recent work, NeoMem, introduces a method to profile hot data on the device side, achieving state-of-the-art performance. However, NeoMem relies on CPU-side profiling for cold data and uses CPU to manage data movement, while HeteroMem employs device-side hardware logic for profiling both hot and cold data, as well as managing data movement. The design of HeteroMem creates a homogeneous abstraction for the CPU and improves overall performance compared to NeoMem.
