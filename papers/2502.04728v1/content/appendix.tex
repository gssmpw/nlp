
\newpage

\appendix


\addcontentsline{toc}{section}{Appendix} %
\renewcommand \thepart{} %
\renewcommand \partname{}
\part{\Large{\centerline{Appendix}}}
\parttoc

\newpage

\section{Planning Problem Formulation}
\label{problem}
The classical planning problem~\cite{fikes1971strips} in artificial intelligence involves finding a sequence of actions that transition an agent from an initial state to a desired goal state within a deterministic and fully observable environment. It is formalized as a tuple $\langle \mathcal{S}, \mathcal{A}, T, s_0, G \rangle$, where:
$\mathcal{S}$ is the set of all possible states;
$\mathcal{A}$ is the set of all possible actions;
$T: \mathcal{S} \times \mathcal{A} \rightarrow \mathcal{S}$ is the state transition function, specifying the outcome state resulting from applying an action in a state;
$s_0 \in \mathcal{S}$ is the initial state;
$G$ is the goal condition, a predicate over states.
The objective is to find a sequence of actions $a_{1}, a_{2}, \dots, a_{n} \in \mathcal{A}$ such that applying these actions successively transitions the system from $s_0$ to a state $s_n$ satisfying the goal condition $G$:
\[
s_n = T(s_{n-1}, a_{n}) = T(T(\dots T(T(s_0, a_1), a_2), \dots, a_{n-1}), a_{n})
\]
with
\[
s_n \models G
\]
Previous works that adopt LLMs as planners estimate state transitions implicitly within language latent spaces, lacking explicit representations of the state space required for classical planning. This implicit representation can make it challenging to ensure consistency, validity, and completeness in the planning process. 
In contrast, our work leverages LLMs to generate explicit representations of the state space by creating PDDL domains. We utilize the generative capabilities of LLMs to produce formal PDDL models from high-level descriptions of the planning tasks. 
This approach bridges the gap between natural language specifications and formal planning models.

By generating PDDL domains using LLMs, we obtain: 1. explicit definitions of the set of states $\mathcal{S}$ through predicates and objects, 2. formal specifications of actions $\mathcal{A}$, including their preconditions and effects, 3. a deterministic state transition function $T$ derived from the action definitions, 4. abilities to cooperate with clearly defined initial state $s_0$ and goal condition $G$ in PDDL syntax.
Thus the new objective under this background is: 
Given high-level descriptions of planning tasks, our objective is to leverage LLMs to create PDDL domains that can represent state transitions explicitly. 
By generating these explicit representations, we enable classical planning algorithms to efficiently search for plans using the defined state transitions during the planning process.

\section{STRIPS Formulation}
The states are expressed through a set of predicates that describe the properties of objects in the environment. Each predicate represents a relationship or characteristic, such as \texttt{on(A, B)}, which indicates that object A is on top of object B. 
A state can be represented as:
\[
S_{0} = \{ \text{on}(A, B), \text{clear}(C) \}
\]
This representation includes relationships that capture the positions and statuses of the objects within the environment.
Actions in PDDL are tightly bound to the representation of states through the use of preconditions and effects. Each action is defined by specifying what must be true in the current state for the action to be applicable (preconditions), as well as what changes in the state when the action is performed (effects).
For example, consider an action \texttt{move(A, B, C)}, indicating that move the object A from B to C. The preconditions and effects could be defined as follows: Preconditions: $\text{Pre}(\text{move}(A, B, C)) = \{ \text{on}(A, B), \text{clear}(C) \}$and Effects: $\text{Eff}(\text{move}(A, B, C)) = \{ \text{on}(A, C), \text{clear}(B)\}$.
They indicate that for the action \texttt{move(A, B, C)} to be executed, object A must be positioned on B, and C must be clear of any objects.
And after moving A from B to C, A is now on C, and B is clear.
The transition can be formulated as:
$T(S, A) \rightarrow S'$.
State transitions occur according to a defined sequence of actions that an agent may take, leading to new configurations of the world.
For instance if the action $\text{move}(A, B, C)$ on $S_{0}$, the transition can be represented as:
\[
S_1 = T(S_0, \text{move}(A, B, C)) \rightarrow \{ \text{on}(A, C), \text{clear}(B) \}
\]
By repeatedly exploring all possible actions, we can form a state transition graph consisting of nodes (states) and directed edges (actions) that connect these nodes based on the actions that lead to different states.
We continue this process by expanding the graph from the newly added nodes until the goal state is reached and added to the graph, or there are no more actions left to explore.



\section{Tasks in Case Study}
\label{tasks}
\textbf{Barman.}
The main goal of the Barman domain is to simulate the task of a bartender who prepares and serves cocktails by manipulating ingredients, tools, and glassware within a bar setting. In this scenario, the agent is tasked with creating a specific cocktail by following a series of actions that involve: 1. Identifying and dispensing the necessary ingredients required for the cocktail from the available dispensers. 
2. Using bar tools such as shakers and shot glasses effectively, ensuring they are clean and suitable for use.
3. Coordinating the use of both hands to pick up and handle objects while ensuring that hands are free when needed and that objects are properly placed on surfaces like the bar counter when not in use.
4. Adhering to the proper sequence of steps for cocktail preparation, which includes dispensing ingredients into the shaker, mixing them, and then pouring the mixture into a shot glass.
5. Maintaining the correct state of all objects involved, such as keeping the shaker and glasses clean and empty before use, and updating their states appropriately as actions are performed.
6. Successfully preparing the cocktail and having it contained in the shot glass, thereby fulfilling the goal of serving the drink as intended.

\textbf{Gripper.}
Gripper problem is designed to test the agent's ability to manage resources and plan actions in a scenario involving manipulating multiple objects across different locations. The agent, represented by one or more robots, must strategically perform the following tasks:
Pick Up Balls: The agent must use its available grippers to pick up the balls from their initial locations. This requires careful hand management to ensure grippers are free and available when needed.
Transport Balls: The robot needs to navigate between rooms to move balls to their specified target locations efficiently. This involves planning the correct sequence of moves and ensuring that the robot is in the correct room with the appropriate objects.
Drop Balls: The agent must release the balls in the designated rooms. This requires ensuring that the robot's grippers are properly aligned and that the release actions are performed at the correct time.
Manage Resources: Throughout the task, the agent must effectively manage both its grip and position within the environment, making sure that it follows constraints such as carrying capacity and room access.

\textbf{Tyreworld.}
The main goal of the Tyreworld problem is to simulate the challenges of vehicle maintenance and tire management in a scenario where a vehicle may suffer random tire failures. The primary objectives include:
1. Replacing Flat Tires: The agent must effectively replace flat tires with intact ones on the vehicle's hubs.
2. Inflating Tires: The intact tires must be inflated before being mounted onto the vehicle.
3. Ensuring Secure Fastening: After replacing and inflating the tires, the nuts on the hubs must be securely tightened to ensure the wheels are safely attached.
3. Resource Management: The agent must manage limited resources (e.g., spare tires, tools like jacks and wrenches) strategically to minimize the risk of failure or being stranded.
4. Navigating Uncertainty: The agent must effectively plan actions while accounting for the possibility of tire failures and other uncertainties in the environment.
5. Reaching the Destination: Ultimately, the goal is to ensure the vehicle is properly equipped with intact, inflated tires, allowing it to continue its journey successfully.
6. The Tyreworld problem serves to test an agent's planning, resource management, and adaptability in unpredictable scenarios related to vehicle maintenance.

\textbf{Floor-tile.}
The main goal of Floor-tile is to enable the robot to navigate the environment, manage its colors, and paint the tiles according to specific requirements. The robot must efficiently utilize its movements and actions to achieve its painting objectives while adhering to the constraints of tile occupancy and color availability. In Floor-tile, three object types are defined: robot, tile, and color. Initially, the robot is located on a specific tile while holding a color. It can move up, down, right, or left with different costs: moving up costs 3, while moving down, right, or left costs 1. The robot can paint a tile above or below for a cost of 2, and changing its color incurs a cost of 5.

\textbf{Termes.}
In Termes, a robot operates in an environment to manage and manipulate blocks at different positions. The robot can perform several actions, including moving between adjacent positions, placing blocks onto stacks, removing blocks from stacks, and creating or destroying blocks at designated depot locations. Each position on the grid has a specific height, and the robot must respect these height constraints when moving or manipulating blocks. The robot can only carry one block at a time, and it must be at the same height level to move horizontally or at a height difference of one to move vertically. The goal is to efficiently use these capabilities to achieve specific block arrangements or configurations within the environment, adhering to the constraints of adjacency, height, and block availability.

\section{Prompt Template for Chain-of-Thought}
\label{prompt_template}
\begin{tcolorbox}[title = {Prompts for Our Methods},
  fonttitle = \bfseries, fontupper = \sffamily\scriptsize, fontlower = \sffamily\scriptsize, colframe=c1, colback=green2!5]
You will be given a natural language description of a planning problem. Your task is to translate this description into PDDL domain code. This includes defining predicates and actions based on the information provided.

Information about the AI agent will be provided in the natural language description. Note that individual conditions in preconditions and effects should be listed separately. For example, “object1 is washed and heated” should be considered as two separate conditions “object1 is washed” and “object1 is heated”. Also, in PDDL, two predicates cannot have the same name even if they have different parameters. Each predicate in PDDL must have a unique name, and its parameters must be explicitly defined in the predicate definition. It is recommended to define predicate names in an intuitive and readable way. Remember: Ignore the information that you think is not helpful for the planning task.

You are only responsible for domain generation.
Before you generate the concrete domain code, you should first generate a natural language thought about the meaning of each variable, and the step-by-step explaination of the domain code.
Even if I didn't provide the exact name of the predicates and actions, you should generate them based on the information provided in the natural language description.

Template is:

\#\#\# Thought:

predicates1: the name of predicate1, explanation of predictate1

...

predicaten: the name of predicaten, explanation of predictaten

action1: the name of action1, explanation of action

...

actionn: the name of action, explanation of action

<thought>

\#\#\# Domain:
```pddl

The concrete pddl code for domain.pddl 

Now its your time to generate the solution, you have to follow the format I provided above.

NL\_Description: {Natural language description of the planning domain}
\end{tcolorbox}

\section{Generated Domains}

\begin{tcolorbox}[title = {Barman},
  fonttitle = \bfseries, fontupper = \sffamily\tiny, fontlower = \sffamily\tiny, colframe=c1, colback=green2!5]
    \textbf{Domain}.
    \begin{lstlisting}
(define (domain barman)
  (:requirements :strips :typing)
  (:types hand level beverage dispenser container - object ingredient cocktail - beverage 
  shot shaker - container)
  (:predicates  (ontable ?c - container)
                (holding ?h - hand ?c - container)
		(handempty ?h - hand)
		(empty ?c - container)
                (contains ?c - container ?b - beverage)
		(clean ?c - container)
                (used ?c - container ?b - beverage)
                (dispenses ?d - dispenser ?i - ingredient)
		(shaker-empty-level ?s - shaker ?l - level)
		......	
  (:action grasp
             :parameters (?h - hand ?c - container)
             :precondition (and (ontable ?c) (handempty ?h))
             :effect (and (not (ontable ?c)) (not (handempty ?h)) (holding ?h ?c)))
  (:action leave ......
  (:action fill-shot ......
  (:action refill-shot ......
  (:action empty-shot ......
  (:action clean-shot ......
  (:action pour-shot-to-clean-shaker ......
  (:action pour-shot-to-used-shaker ......
  (:action empty-shaker ......
  (:action clean-shaker ......
  (:action shake ......
  (:action pour-shaker-to-shot ...... )
\end{lstlisting}

\textbf{Problem}.\\
\begin{lstlisting}
(define (problem prob)
 (:domain barman)
 (:objects 
      shaker1 - shaker left right - hand shot1 shot2 shot3 shot4 - shot ingredient1 
      ingredient2 ingredient3 - ingredient cocktail1 cocktail2 cocktail3 - cocktail
      dispenser1 dispenser2 dispenser3 - dispenser l0 l1 l2 - level
)
 (:init 
  (ontable shaker1)
  (ontable shot1) ......
  (clean shaker1) ......
  (empty shaker1) ......
  (cocktail-part1 cocktail1 ingredient1) ......
)
 (:goal
  (and (contains shot1 cocktail1) (contains shot2 cocktail3) (contains shot3 cocktail2)
\end{lstlisting}

  \tcblower
   \textbf{Plan}.
(grasp left shot4)
(fill-shot shot4 ingredient2 left right dispenser2)
(pour-shot-to-clean-shaker shot4 ingredient2 shaker1 left l0 l1)
(clean-shot shot4 ingredient2 left right)
(fill-shot shot4 ingredient1 left right dispenser1)
(pour-shot-to-used-shaker shot4 ingredient1 shaker1 left l1 l2)
(refill-shot shot4 ingredient1 left right dispenser1)
(leave left shot4)
(grasp right shaker1)
(shake cocktail3 ingredient1 ingredient2 shaker1 right left)
(pour-shaker-to-shot cocktail3 shot2 right shaker1 l2 l1)
(empty-shaker right shaker1 cocktail3 l1 l0)
(clean-shaker right left shaker1)
(leave right shaker1)
(grasp left shot4)
(pour-shot-to-clean-shaker shot4 ingredient1 shaker1 left l0 l1)
(clean-shot shot4 ingredient1 left right)
(fill-shot shot4 ingredient3 left right dispenser3)
(pour-shot-to-used-shaker shot4 ingredient3 shaker1 left l1 l2)
(refill-shot shot4 ingredient3 left right dispenser3)
(leave left shot4)
(grasp right shaker1)
(shake cocktail1 ingredient1 ingredient3 shaker1 right left)
(pour-shaker-to-shot cocktail1 shot1 right shaker1 l2 l1)
(empty-shaker right shaker1 cocktail1 l1 l0)
(clean-shaker right left shaker1)
(leave right shaker1)
(grasp right shot4)
(pour-shot-to-clean-shaker shot4 ingredient3 shaker1 right l0 l1)
(clean-shot shot4 ingredient3 right left)
(fill-shot shot4 ingredient2 right left dispenser2)
(grasp left shaker1)
(pour-shot-to-used-shaker shot4 ingredient2 shaker1 right l1 l2)
(leave right shot4)
(shake cocktail2 ingredient2 ingredient3 shaker1 left right)
(pour-shaker-to-shot cocktail2 shot3 left shaker1 l2 l1)
; cost = 36 (unit cost)




\end{tcolorbox}


\begin{tcolorbox}[title = {BlockWorld},
  fonttitle = \bfseries, fontupper = \sffamily\tiny, fontlower = \sffamily\tiny, colframe=c1, colback=green2!5]
    \textbf{Domain}.
    \begin{lstlisting}
    
(define (domain blocksworld)
  (:requirements :strips :equality)
  
  (:predicates
    (clear ?x)
    (on-table ?x)
    (arm-empty)
    (holding ?x)
    (on ?x ?y))
  
  (:action pickup
    :parameters (?ob)
    :precondition (and (clear ?ob) (on-table ?ob) (arm-empty))
    :effect (and (holding ?ob) (not (clear ?ob)) (not (on-table ?ob)) 
    (not (arm-empty))))
  
  (:action putdown
    :parameters (?ob)
    :precondition (and (holding ?ob))
    :effect (and (clear ?ob) (arm-empty) (on-table ?ob) 
    (not (holding ?ob))))
  
  (:action stack
    :parameters (?ob ?underob)
    :precondition (and (clear ?underob) (holding ?ob))
    :effect (and (arm-empty) (clear ?ob) (on ?ob ?underob) (not (clear ?underob)) 
    (not (holding ?ob))))
  
  (:action unstack
    :parameters (?ob ?underob)
    :precondition (and (on ?ob ?underob) (clear ?ob) (arm-empty))
    :effect (and (holding ?ob) (clear ?ob) (not (on ?ob ?underob)) (not (clear 
    ?ob)) (not (arm-empty))) ))
\end{lstlisting}

\textbf{Problem}.\\
\begin{lstlisting}
(define (problem BW-rand-12)
    (:domain blocksworld)
    (:objects b1 b2 b3 b4 b5 b6 b7 b8 b9 b10 b11 b12 )
    (:init
        (arm-empty)(on-table b1)(on b2 b5)(on b3 b8)(on b4 b12)(on b5 b7)
        (on b6 b1)(on b7 b10)
        (on-table b8)(on-table b9)(on b10 b11)(on-table b11)(on b12 b9)
        (clear b2)(clear b3)(clear b4)(clear b6))
    (:goal
        (and (on b5 b10)(on b6 b12)(on b7 b4)(on b8 b3)(on b9 b2)(on b10 b8)
        (on b11 b7)(on b12 b11))))
\end{lstlisting}

  \tcblower
   \textbf{Plan}.

\scriptsize

(unstack b3 b8)
(putdown b3)
(pickup b8)
(stack b8 b3)
(unstack b2 b5)
(putdown b2)
(unstack b4 b12)
(putdown b4)
(unstack b5 b7)
(stack b5 b2)
(unstack b7 b10)
(stack b7 b4)
(unstack b10 b11)
(stack b10 b8)
(pickup b11)
(stack b11 b7)
(unstack b12 b9)
(stack b12 b11)
(unstack b5 b2)
(stack b5 b10)
(unstack b6 b1)
(stack b6 b12)
(pickup b9)
(stack b9 b2)
; cost = 24 (unit cost)    




\end{tcolorbox}


\begin{tcolorbox}[title = {Termes},
  fonttitle = \bfseries, fontupper = \sffamily\tiny, fontlower = \sffamily\tiny, colframe=c1, colback=green2!5]
    \textbf{Domain}.
    \begin{lstlisting}
    
(define (domain termes)
    (:requirements :typing :negative-preconditions)
    (:types
        numb - object
        position - object)
    (:predicates
        (height ?p - position ?h - numb)
        (at ?p - position)
        (has-block)
        (SUCC ?n1 - numb ?n2 - numb)
        (NEIGHBOR ?p1 - position ?p2 - position)
        (IS-DEPOT ?p - position))
    (:action move
        :parameters (?from - position ?to - position ?h - numb)
        :precondition (and (at ?from)(NEIGHBOR ?from ?to)(height ?from ?h)(height ?to ?h))
        :effect (and (not (at ?from))(at ?to) ) )
    (:action move-up
        :parameters (?from - position ?hfrom - numb ?to - position ?hto - numb)
        :precondition (and(at ?from)(NEIGHBOR ?from ?to)(height ?from ?hfrom)(height 
        ?to ?hto)(SUCC ?hto ?hfrom))
        :effect (and(not (at ?from))(at ?to)))

    (:action move-down ...
    (:action place-block ...
    (:action remove-block ...
    (:action create-block ...
    (:action destroy-block ...
)
\end{lstlisting}

\textbf{Problem}.\\
\begin{lstlisting}
(define (problem termes-00038-0036-4x3x3-random_towers_4x3_3_1_3)
(:domain termes)
; termes-00038-0036-4x3x3-random_towers_4x3_3_1_3
; Initial state:
;  0   0  R0D  0
;  0   0   0   0
;  0   0   0   0
; Goal state:
;  0   0   0   0
;  0   0   0   0
;  0   3   0   0
; Maximal height: 3
(:objects
    n0 - numb......
    pos-0-0 - position......
)
(:init
    (height pos-0-0 n0)......
    (at pos-2-0)
    (SUCC n1 n0)......
    (NEIGHBOR pos-0-0 pos-1-0)......
    (IS-DEPOT pos-2-0)
)
(:goal
(and (height pos-0-0 n0) ...... (not (has-block)))))
\end{lstlisting}

  \tcblower
  \scriptsize
   \textbf{Plan}.

(unstack b3 b8)
(putdown b3)
(pickup b8)
(stack b8 b3)
(unstack b2 b5)
(putdown b2)
(unstack b4 b12)
(putdown b4)
(unstack b5 b7)
(stack b5 b2)
(unstack b7 b10)
(stack b7 b4)
(unstack b10 b11)
(stack b10 b8)
(pickup b11)
(stack b11 b7)
(unstack b12 b9)
(stack b12 b11)
(unstack b5 b2)
(stack b5 b10)
(unstack b6 b1)
(stack b6 b12)
(pickup b9)
(stack b9 b2)
; cost = 24 (unit cost)    




\end{tcolorbox}






\begin{tcolorbox}[title = {Floor-tile},
  fonttitle = \bfseries, fontupper = \sffamily\tiny, fontlower = \sffamily\tiny, colframe=c1, colback=green2!5]
    \textbf{Domain}.
    \begin{lstlisting}
(define (domain floor-tile)
  (:requirements :typing :action-costs)
  (:types robot tile color - object)

  (:predicates    
    (robot-at ?r - robot ?x - tile)
    (up ?x - tile ?y - tile)
    (down ?x - tile ?y - tile)
    (right ?x - tile ?y - tile)
    (left ?x - tile ?y - tile)
    
    (clear ?x - tile)
    (painted ?x - tile ?c - color)
    (robot-has ?r - robot ?c - color)
    (available-color ?c - color)
    (free-color ?r - robot))

  (:functions (total-cost))
  (:action change-color
    :parameters (?r - robot ?c - color ?c2 - color)
    :precondition (and (robot-has ?r ?c) (available-color ?c2))
    :effect (and (not (robot-has ?r ?c)) (robot-has ?r ?c2) (increase (total-cost) 5))) 
  (:action paint-up
    :parameters (?r - robot ?y - tile ?x - tile ?c - color)
    :precondition (and (robot-has ?r ?c) (robot-at ?r ?x) (up ?y ?x) (clear ?y))
    :effect (and (not (clear ?y)) (painted ?y ?c) (increase (total-cost) 2))
  )
  (:action paint-down...
  (:action up ...
  (:action down ...
  (:action right ...
  (:action left ...
\end{lstlisting}

\textbf{Problem}.\\
\begin{lstlisting}
(define (problem p03-432)
 (:domain floor-tile)
 (:objects tile_0-1 tile_0-2 tile_0-3 ......tile_4-1 tile_4-2 tile_4-3 - tile
           robot1 robot2 - robot
           white black - color
)
 (:init 
   (= (total-cost) 0)
   (robot-at robot1 tile_2-3)
   (robot-has robot1 white)
   (robot-at robot2 tile_1-1)
   (robot-has robot2 black)
   (available-color white)
   (available-color black)
   (clear tile_0-1) ......
   (up tile_1-1 tile_0-1) ......
   (down tile_0-1 tile_1-1) ......
   (right tile_0-2 tile_0-1) ......
   (left tile_0-1 tile_0-2) ......)
 (:goal (and
    (painted tile_1-1 white)
    (painted tile_1-2 black) ......))
 (:metric minimize (total-cost)))
\end{lstlisting}
\scriptsize
  \tcblower
   \textbf{Plan}.
(up robot1 tile\_2-3 tile\_3-3)
(left robot1 tile\_3-3 tile\_3-2)
(paint-up robot1 tile\_4-2 tile\_3-2 white)
(up robot2 tile\_1-1 tile\_2-1)
(down robot1 tile\_3-2 tile\_2-2)
(up robot2 tile\_2-1 tile\_3-1)
......
; cost = 54 (general cost)

\end{tcolorbox}




\begin{tcolorbox}[title = {Tyreworld},
  fonttitle = \bfseries, fontupper = \sffamily\tiny, fontlower = \sffamily\tiny, colframe=c1, colback=green2!5]
    \textbf{Domain}.
    \begin{lstlisting}
(define (domain tyreworld)
  (:types obj - object
          tool wheel nut - obj
          container hub - object)
  
  (:predicates (open ?x) (closed ?x) (have ?x) (in ?x ?y) (loose ?x ?y) 
        (tight ?x ?y) 
        (unlocked ?x) (on-ground ?x) ......
  (:action open
    :parameters (?x - container)
    :precondition (and (unlocked ?x) (closed ?x))
    :effect (and (open ?x) (not (closed ?x))))
  (:action close
    :parameters (?x - container)
    :precondition (open ?x)
    :effect (and (closed ?x) (not (open ?x))))
  (:action fetch
    :parameters (?x - obj ?y - container)
    :precondition (and (in ?x ?y) (open ?y))
    :effect (and (have ?x) (not (in ?x ?y))))
  (:action put-away ......
  (:action loosen ......
  (:action tighten ......
  (:action jack-up ......
  (:action jack-down ......
  (:action undo ......
  (:action do-up ......
  (:action remove-wheel ......
  (:action put-on-wheel ......
  (:action inflate ......
\end{lstlisting}

\textbf{Problem}.
\begin{lstlisting}
(define (problem tyreworld-1)
(:domain tyreworld)
(:objects  wrench jack pump - tool the-hub1 - hub nuts1 - nut 
    boot - container r1 w1 - wheel)
(:init (in jack boot) (in pump boot) (in wrench boot) (unlocked boot)
    (closed boot) (intact r1) (in r1 boot) (not-inflated r1) (on w1 the-
    hub1) (on-ground the-hub1) (tight nuts1 the-hub1) (fastened the-hub1))
(:goal
    (and (on r1 the-hub1) (inflated r1) (tight nuts1 the-hub1) (in w1 boot)
    (in wrench boot) (in jack boot) (in pump boot) (closed boot))))
\end{lstlisting}
\scriptsize
  \tcblower
   \textbf{Plan}.\\
(open boot)
(fetch r1 boot)
(fetch wrench boot)
(fetch jack boot)
(loosen nuts1 the-hub1)
(jack-up the-hub1)
(undo nuts1 the-hub1)
(remove-wheel w1 the-hub1)
(put-away w1 boot)
(put-on-wheel r1 the-hub1)
(do-up nuts1 the-hub1)
(jack-down the-hub1)
(put-away jack boot)
(tighten nuts1 the-hub1)
(put-away wrench boot)
(fetch pump boot)
(inflate r1)
(put-away pump boot)
(close boot)
; cost = 19 (unit cost)


\end{tcolorbox}

\newpage

\section{Prompts for LLM-as-Planner Methods}

\begin{tcolorbox}[title = {Prompts for o1 on Termes},
  fonttitle = \bfseries, fontupper = \sffamily\small, fontlower = \sffamily\small, colframe=c1, colback=green2!5]
    \textbf{Problem Description}.
You control a robot that can take the following actions to build complex structures.

Move from a position to another. The new position and the old position must be at the same height.

Move up from a position to another, and the height at the new position is one block higher than the old position.

Move down from a position to another, and the height at the new position is one block lower than the old position.

Place a block at a neighboring position from the robot's current position. The robot must have a block. The current height at the robot's position and the block's position must be the same. A block cannot be placed at the depot. The height at the block's position will be one block higher than the current height.

Remove a block at a neighboring position from the robot's current position. The robot must not have a block. A block cannot be removed from the depot. The current height at the robot's position must be the same as the new height at the block's position. The new height at the block's position will be one block lower than the current height.

Create a block at the depot. The robot will have the block.

Destroy a block at the depot. The robot must have a block. 
Now consider a planning problem. The problem description is: 
The robot is on a grid with 4 rows and 3 columns. 
pos-0-0 pos-0-1 pos-0-2 
pos-1-0 pos-1-1 pos-1-2 
pos-2-0 pos-2-1 pos-2-2 
pos-3-0 pos-3-1 pos-3-2 
The robot is at pos-2-0. 
The depot for new blocks is at pos-2-0. 
The maximum height of blocks is 3. 
Your goal is to build blocks so that the height at pos-1-2 is 3. 
Rule: You cannot have an unplaced block at the end.
Examine whether you follow the rule at each step!
Can you provide an optimal plan, in the way of a sequence of behaviors, to solve the problem? And what is the final optimal cost?
\end{tcolorbox}

\newpage
\section{State-based graph for Termes}
Figure~\ref{fig:graph} shows the planning graph that contains explicit state transition during planning for Termes.
\label{terme}
\begin{figure}[h]
    \centering
    \includegraphics[width=1\linewidth]{content/imgs/generated.png}
    \caption{The planning graph for Termes}
    \label{fig:graph}
\end{figure}

\newpage
\section{The Prompt of Our Methods on Termes}
\label{prompt_termes}
\begin{tcolorbox}[title = {Prompts for Our Methods on Termes},
  fonttitle = \bfseries, fontupper = \sffamily\scriptsize, fontlower = \sffamily\scriptsize, colframe=c1, colback=green2!5]
You will be given a natural language description of a planning problem. Your task is to translate this description into PDDL domain code. This includes defining predicates and actions based on the information provided.

Information about the AI agent will be provided in the natural language description. Note that individual conditions in preconditions and effects should be listed separately. For example, “object1 is washed and heated” should be considered as two separate conditions “object1 is washed” and “object1 is heated”. Also, in PDDL, two predicates cannot have the same name even if they have different parameters. Each predicate in PDDL must have a unique name, and its parameters must be explicitly defined in the predicate definition. It is recommended to define predicate names in an intuitive and readable way. Remember: Ignore the information that you think is not helpful for the planning task.

You are only responsible for domain generation.
Before you generate the concrete domain code, you should first generate a natural language thought about the meaning of each variable, and the step-by-step explaination of the domain code.
Even if I didn't provide the exact name of the predicates and actions, you should generate them based on the information provided in the natural language description.

Template is:

\#\#\# Thought:
predicates1: the name of predicate1, explanation of predictate1
...
predicaten: the name of predicaten, explanation of predictaten
action1: the name of action1, explanation of action1
...
actionn: the name of action, explanation of actionn
<thought>

\#\#\# Domain:
```pddl
The concrete pddl code for domain.pddl 

Now its your time to generate the solution, you have to follow the format I provided above.

NL\_Description:

You control a robot that can take the following actions to build complex structures.

Move from a position to another. The new position and the old position must be at the same height. -- pddl action name: move

Move up from a position to another, and the height at the new position is one block higher than the old position. -- pddl action name: move-up

Move down from a position to another, and the height at the new position is one block lower than the old position. -- pddl action name: move-down

Place a block at a neighboring position from the robot's current position. The robot must have a block. The current height at the robot's position and the block's position must be the same. A block cannot be placed at the depot. The height at the block's position will be one block higher than the current height. -- pddl action name: place-block

Remove a block at a neighboring position from the robot's current position. The robot must not have a block. A block cannot be removed from the depot. The current height at the robot's position must be the same as the new height at the block's position. The new height at the block's position will be one block lower than the current height. -- pddl action name: remove-block

Create a block at the depot. The robot will have the block. -- pddl action name: create-block

Destroy a block at the depot. The robot must have a block. -- pddl action name: destroy-block

An example problem PDDL file to the domain is:

```pddl
(define (problem prob)
(:domain termes)
; Initial state:
;  0   0  R0D
;  0   0   0
;  0   0   0
; Goal state:
;  0   0   0
;  0   1   0
;  0   0   0
; Maximal height: 1
(:objects
    n0 - numb
    n1 - numb
    pos-0-0 - position
    pos-0-1 - position
    pos-0-2 - position
    pos-1-0 - position
    pos-1-1 - position
    pos-1-2 - position
    pos-2-0 - position
    pos-2-1 - position
    pos-2-2 - position
)
(:init
    (height pos-0-0 n0)
    (height pos-0-1 n0)
    (height pos-0-2 n0)
    (height pos-1-0 n0)
    (height pos-1-1 n0)
    (height pos-1-2 n0)
    (height pos-2-0 n0)
    (height pos-2-1 n0)
    (height pos-2-2 n0)
    (at pos-2-0)
    (SUCC n1 n0)
    (NEIGHBOR pos-0-0 pos-1-0)
    (NEIGHBOR pos-0-0 pos-0-1)
    (NEIGHBOR pos-0-1 pos-1-1)
    (NEIGHBOR pos-0-1 pos-0-0)
    (NEIGHBOR pos-0-1 pos-0-2)
    (NEIGHBOR pos-0-2 pos-1-2)
    (NEIGHBOR pos-0-2 pos-0-1)
    (NEIGHBOR pos-1-0 pos-0-0)
    (NEIGHBOR pos-1-0 pos-2-0)
    (NEIGHBOR pos-1-0 pos-1-1)
    (NEIGHBOR pos-1-1 pos-0-1)
    (NEIGHBOR pos-1-1 pos-2-1)
    (NEIGHBOR pos-1-1 pos-1-0)
    (NEIGHBOR pos-1-1 pos-1-2)
    (NEIGHBOR pos-1-2 pos-0-2)
    (NEIGHBOR pos-1-2 pos-2-2)
    (NEIGHBOR pos-1-2 pos-1-1)
    (NEIGHBOR pos-2-0 pos-1-0)
    (NEIGHBOR pos-2-0 pos-2-1)
    (NEIGHBOR pos-2-1 pos-1-1)
    (NEIGHBOR pos-2-1 pos-2-0)
    (NEIGHBOR pos-2-1 pos-2-2)
    (NEIGHBOR pos-2-2 pos-1-2)
    (NEIGHBOR pos-2-2 pos-2-1)
    (IS-DEPOT pos-2-0)
)
(:goal
(and
    (height pos-0-0 n0)
    (height pos-0-1 n0)
    (height pos-0-2 n0)
    (height pos-1-0 n0)
    (height pos-1-1 n1)
    (height pos-1-2 n0)
    (height pos-2-0 n0)
    (height pos-2-1 n0)
    (height pos-2-2 n0)
    (not (has-block))
)
)
)
\end{tcolorbox}


\newpage
\section{Human in the Loop Experiment}

We conducted human-in-the-loop experiments to refine the process of writing PDDL (Planning Domain Definition Language) domain code with the interaction between artificial intelligence and humans. 
The experiment involved graduate students majoring in AI and robotics, focusing on evaluating the effectiveness of human-AI collaboration in generating accurate and semantically meaningful PDDL domain files that strictly adhere to given specifications.

The planning domain selected for this study was Termes, which necessitated the translation of robot actions into PDDL. These actions included horizontal and vertical movements, block placement and removal, and depot management within a simulated environment.

In the initial phase, participants interacted directly with an AI agent by providing prompts based on descriptions of robot actions. While the AI-generated PDDL code passed basic validation, it often lacked a proper definition of action preconditions or the accurate use of predicates, such as the ``SUCC'' predicate, which denotes an ordered relationship between items. In response to these limitations, the students refined their prompting strategy by incorporating more structured instructions and examples, resulting in improved outcomes.

Simultaneously, students manually coded PDDL domain files, utilizing the AI agent to ensure grammatical correctness. This approach facilitated the creation of logically comprehensive domain files, though several iterations were still required to achieve successful validation.

Through this iterative process, students provided critical insights into the current strengths and weaknesses of AI in comprehending complex logical structures and semantic nuances within specialized domains like PDDL. Their findings underscored the challenges associated with writing precise PDDL code and emphasized the need for an automated pipeline to facilitate PDDL domain synthesis.
