\section{General Unnormalized Model}\label{sec:unnormalized-setting}


\input{algorithms/alg-7-initialize-ml}

In this section, we extend \oursolution to handle unnormalized data, where the squared norms of the input vectors satisfy \( \|\boldsymbol{x}_i\|_2^2,\;\|\boldsymbol{y}_i\|_2^2 \in [1,R] \). Following the approach in \cite{LeeT06} for mutable sliding window sizes, we construct a multi-layer extension of \oursolution, which we denote by \newsolution (Multi-Layer SO-COD). In this framework, the data stream is processed through \( L = \lceil \log_2 R \rceil \) layers. Each layer \( i \) (for \( i = 0,1,\dots,L-1 \)) maintains an independent \oursolution sketch with a distinct register threshold \( \theta_i \) defined by \( \theta_i = 2^i\epsilon N \). That is, in layer \( i \), a snapshot is registered when \( \|\hat{\boldsymbol{a}}_i\|_2 \,\|\hat{\boldsymbol{b}}_i\|_2 \ge 2^i\epsilon N \). By constraining the number of snapshots per layer to \( O(1/\epsilon) \), the overall space complexity of \newsolution is \( O((d_x+d_y)/\epsilon \cdot \log_2 R) \).



\subsection{Algorithm Description}
    \htitle{Multi-Layer Sketch Structure.}
Algorithm~\ref{alg:initialize-ml} specifies the initialization of a \newsolution sketch, thereby defining the multi-layer structure. In Line 1, we compute the number of layers \( L = \lceil \log_2 R \rceil \). For each layer \( i \in \{0, 1, \dots, L-1\} \), an independent \oursolution sketch is initialized with the register threshold \( \theta_i = 2^i\epsilon N \) and added to the list $M$. Consequently, in layer \( i \), the \oursolution sketch will generate a snapshot when \( \|\hat{\boldsymbol{a}}_i\|_2 \,\|\hat{\boldsymbol{b}}_i\|_2 \ge 2^i\epsilon N \). To minimize redundancy and retain only the most significant information, we restrict the number of snapshots per layer to \( O(1/\epsilon) \). As a result, the total space required by \newsolution is \( O((d_x+d_y)/\epsilon \cdot \log_2 R) \).

    \input{algorithms/alg-8-update-ml}
    

\htitle{Update Algorithm.} As shown in Alg.\ \ref{alg:update-ml}, each incoming column pair \( (\boldsymbol{x}_i,\boldsymbol{y}_i) \) is processed across all layers. To ensure that the number of snapshots in each layer remains within the prescribed bound of \( O(1/\epsilon) \), we explicitly set this bound to \( \lsn \); that is, the algorithm first checks whether the number of snapshots exceeds \( \lsn \) (and prunes expired snapshots promptly, as indicated in Lines 2--3). Then, for each layer \( j \), if the product of $\xinorm$ and $\yinorm$ exceed the threshold $2^j\epsilon N$, we  generate a snapshot $(u=\boldsymbol{x}_i,v=\boldsymbol{y}_i)$ directly, preserving all information of $(\boldsymbol{x}_i,\boldsymbol{y}_i)$ without introducing approximation error for $\boldsymbol{x}_i\boldsymbol{y}_i^T$ to reduce additional calculation (Lines 4 to 6). Otherwise, the update procedure applies the column pair \( (\boldsymbol{x}_i,\boldsymbol{y}_i) \) to update the corresponding \oursolution sketch \( M[j] \) (Line 8) via the \oursolution.\textit{FastUpdate} procedure.  Due to the direct update mechanism, we can better restrict the times of extracting snapshots from sketch. Specifically, suppose that in layer $j$, there exist $m$ singular values surpassing the threshold $\theta$ in Alg.\ref{alg:fast-update} (Line 13) from the beginning to current timestamp $t$, aligned as $\sigma_1\geq \sigma_2 \geq \sigma_3 \geq \cdots \geq \sigma_m \geq \theta$, extracting these $m$ snapshots takes $O(m(d_x+d_y)l)$ time in total. Since $m\theta \leq \sum_{i=1}^t \left\|\boldsymbol{x}_i\boldsymbol{y}_i^T\right\|_{*} \cdot \mathbb{I}(\xinorm\yinorm <\theta) < t\theta$, where $\mathbb{I}(\xinorm\yinorm <\theta)$ equals $1$ if $\xinorm\yinorm <\theta$ and otherwise $0$. Thereby, we have $m \leq t$, which implies amortized time for extractng the snapshots per layer is $O((d_x+d_y)l)$. As the update is executed in each of the \( L \) layers, the overall time cost per update is \( O(((d_x+d_y)l + l^3)\log R) \).

\htitle{Query Algorithm.} Alg.\ \ref{alg:query} describes the procedure for forming the sketch corresponding to the sliding window \( [t-N+1,t] \). Because of the per-layer constraint on the number of snapshots, a given layer might not contain enough snapshots to cover the entire window and thereby produce a valid sketch. To address this, we select the lowest layer for which the snapshots fully cover the window while minimizing the approximation error. More precisely, a layer is deemed valid if the last expired snapshot before its earliest non-expired snapshot occurs at time \( s \) satisfying \( s \le t-N \). A naive approach would scan all \( O(\log R) \) layers, resulting in a time complexity of \( O(\log R) \); however, since the snapshot density decreases monotonically with increasing layer index (due to the larger register thresholds), a binary search can be employed to reduce the query time complexity to \( O(\log \log R) \). 

        


\htitle{Theoretical Analysis.}
%    \subsection{Algorithm Analysis}
The following theorem demonstrates the error guarantee, space cost and time cost for \newsolution.
\vspace{-1mm}
\begin{theorem}\label{thm:socod-unnormalized}
Let \(\{(\boldsymbol{x}_t,\boldsymbol{y}_t)\}_{t\ge1}\) be a stream of data so that for all \(t\) it holds that
\(
\|\boldsymbol{x}_t\|_2^2,\;\|\boldsymbol{y}_t\|_2^2\in[1,R]
\). Let 
\(
\boldsymbol{X}_W = [\boldsymbol{x}_{t-N+1},\dots,\boldsymbol{x}_t]
\)
and 
\(
\boldsymbol{Y}_W = [\boldsymbol{y}_{t-N+1},\dots,\boldsymbol{y}_t]
\)
denote the sliding window matrices as defined in Def.~\ref{def:amm}. Given window size \(N\) and relative error parameter \(\epsilon\), the \newsolution algorithm outputs matrices
\(
\boldsymbol{A}_{aug}\in\mathbb{R}^{d_x\times O(\frac{1}{\epsilon})}
\)
and 
\(
\boldsymbol{B}_{aug}\in\mathbb{R}^{d_y\times O(\frac{1}{\epsilon})}
\)
such that if the sketch size is set to 
\(
l = \min\Bigl(\Bigl\lceil\frac{1}{\epsilon}\Bigr\rceil,\, d_x,\, d_y\Bigr),
\)
then
\(
\Bigl\|\boldsymbol{X}_W\boldsymbol{Y}_W^\top - \boldsymbol{A}_{aug}\boldsymbol{B}_{aug}^\top\Bigr\|_2 \le 4\epsilon\,\|\boldsymbol{X}_W\|_F\,\|\boldsymbol{Y}_W\|_F.
\)
Furthermore, the \newsolution sketch uses 
\(
O\Bigl(\frac{d_x+d_y}{\epsilon}\log R\Bigr)
\)
space and supports each update in 
\(
O\Bigl(((d_x+d_y)l + l^3)\log R\Bigr)
\)
time.
\end{theorem}



    \input{algorithms/alg-9-query-ml} 

    
\label{sec-analysis}
