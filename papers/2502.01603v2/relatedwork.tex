\section{Related Work}
One data structure in use for this problem is the Segment Tree, which works by setting the initial values as leaf nodes of the tree and propagating upwards, combining two adjacent nodes into their parent~\cite{deBerg2008}. 
This adds nodes to store combined values in addition to the initial values themselves.
This does not affect time complexity at large scales, but it does require up to nearly twice as much memory as other options, which could be more of a detriment for certain memory-limited applications or operations. 
This data structure can be constructed in $O(N)$ time, perform the update and accumulate operations in $O(\log_2 N)$ time, and requires up to $2N - 1$ nodes.

The Binary Indexed Tree, or Fenwick Tree, is the other leading option for this problem~\cite{Fenwick1994AND}. 
It works by finding children and parents by simply incrementing or decrementing the last set bit in a node index's binary representation, while storing the accumulation from (including) the parent index to (excluding) it's own index of the initial array values. 
This saves on memory space compared to the Segment Tree. 
Hence, this data structure can be constructed in $O(N)$ time, perform the update and accumulate operations in $O(\log_2 N)$ time, and requires $N$ nodes.

Red-Black Trees have been used as an alternative to the Binary Indexed Tree~\cite{cormen01introduction,accumulation_tree}.
However, this solution, as with the Binary Indexed Tree, also cannot handle non-commutative accumulation operations. Furthermore, it requires additional time complexity for construction, namely $O(N \log_2 N)$.

Dietz, later modified by Ramen, Ramen, and Rao, proposes a structure that runs the \texttt{update} and \texttt{accumulate} operations in $\Theta(\log_2 N / \log_2 \log_2 N)$ amortized time~\cite{Dietz1989OptimalAF,ramen-ramen-rao}. 
It works by storing ``the list at the leaves of a nearly complete tree of branching factor b = $\Theta(\log ^\epsilon n)$,'' where $\epsilon$ is a positive constant less than one. 
It also uses a two-array scheme and precomputed tables for internal nodes to track children in constant amortized time. 
However, this scheme requires auxiliary memory greater than a single array of $N$ elements, and each internal node has worst-case time of $O(\log_2 N)$ to \texttt{update}.

Hon, Sadakane, and Sung review solutions to the similar \textit{Searchable Partial Sum} problem, which includes the capability of the \textit{search} opertaion, where $search(j)$ returns the smallest $i$ such that $sum(i) \geq j$~\cite{10.1007/978-3-540-24587-2_52}. 
These solutions, while interesting, do not provide improvements on the operations of the \textit{Partial Sum} problem.