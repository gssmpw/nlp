\section{Multi-Agent Collaboration System}
\label{sec:multi-ChipAgent}

Automating EDA flows within complex real-world scenarios poses a formidable challenge for single-agent systems (shown in \Cref{fig:cases1}). 
These complexities arise from the multidimensional nature of EDA projects, which demand technical expertise and the need for a long-chain EDA tool-calling process.
As shown in \Cref{fig:multi_agent_cosys}, the single-agent system will make mistakes in the intermediate steps during the complex EDA task planning process, leading to failure in EDA flow automation.
In response, we introduce EDAid, a collaborative multi-agent system designed for EDA flow automation. 
Unlike the single-agent system utilizing the vanilla CoT, this system features multiple agents operating in synergy with self-consistency to resolve more complex EDA tasks.
In the following subsections, we will elucidate the mechanisms within the multi-agent system, which coordinate the efforts of multiple LLM-powered agents to automate the EDA flow.

\subsection{Multi-Agent System Definition}
For clear clarification, we conceptualize the operational environment of the multi-agent system as a graph $\mathcal{G}=(\mathcal{V}, \mathcal{E})$, where $\mathcal{V}$ represents the nodes corresponding to the agents, and $\mathcal{E}$ signifies the edges that delineate the communicative links among the agents.

\minisection{Agent Definition} 
Each agent $i \in \mathcal{V}$ is defined by a tuple $\mathcal{V}_{i} = (L_{i}, R_{i})$. 
Here, $L_{i}$ denotes the specific instances of LLMs employed by the agent, including their types and configurations, and the different prompt designs for different LLMs. 
$R_{i}$ designates the agent's role, which determines its duties and imparts a defined purpose and direction, thereby steering its actions and interactions. 
As shown in \Cref{fig:multi_agent_cosys}, two distinct roles are identified.
Specifically, divergent-thoughts agents (role $R_{0}$) are tasked with comprehending user inquiries and generating scripts for EDA flow automation.
The decision-making agent (role $R_{1}$) is the decision-maker who selects the optimal solution from various solutions to resolve the EDA task.
%Notably, as shown in \Cref{fig:multi_agent_cosys}, each agent $i \in \mathcal{V}$ is  powered by ChipLlama models. 

\minisection{Connection and Message Definition} 
Each edge $e_{ij} \in \mathcal{E}$ establishes a communicative link between agent $\mathcal{V}_{i}$ and $\mathcal{V}_{j}$, facilitating message exchange. 
A message $m$ encapsulates the content that includes the task plan and the relative EDA script, which can be transmitted from agent $\mathcal{V}_{i}$ to $\mathcal{V}_{j}$ via the established channel $e_{ij}$. 

% \begin{figure}[tb!]
%     \centering
%     \includegraphics[width=\linewidth]{figs/figure6.pdf} 
%     \caption{Overview of the divergent thoughts.}
%     \label{fig:div_thought}
% \end{figure}

\subsection{Divergent Thoughts}
Considering the superior performance of in-context learning, most tasks in various domains can be resolved by LLMs in one go. 
However, LLMs exhibit errors in EDA flow automation considering their multiple complex planning steps.
A notable characteristic of human cognition is the diversity of thought processes. 
Similarly, multiple planning pathways can be employed to address EDA tasks. 
Single-agent systems are not infallible in task planning, especially for scenarios that require long-chain tool-calling processes.
As depicted in \Cref{fig:multi_agent_cosys}, a single-agent system may occasionally pursue incorrect planning steps or commit errors within the task planning process. 
Specifically, a single-agent system might engage in placement without preceding floorplanning execution, or it could employ parameters tailored for the CTS stage at the placement phase.
Such flawed planning can not converge on the correct EDA script (shown in \Cref{fig:cases1}). 
Consequently, multiple planning pathways searching via multiple divergent-thoughts agents is necessary.

According to \Cref{Eq:zero-shot_CoT_step1}, planning steps $\mathcal{C}$ are contingent upon the prompt $\mathcal{T}$ when employing greedy decoding in CoT prompting. 
By supplying prompts derived from distinct distributions, we can engender a variety of planning steps $\mathcal{C}$, which facilitates the generation of answers $\mathcal{A}$ from divergent-thoughts agents that reflect divergent thinking.
In the context of few-shot CoT prompts, where $\mathcal{T} = {(\mathcal{Q}_{i}, \mathcal{C}_{i}, \mathcal{A}_{i})}^{\mathcal{N}}_{i=1}$, employing different permutations of $(\mathcal{Q}, \mathcal{C}, \mathcal{A})$ tuples can lead to the generation of $\mathcal{O} = \{\mathcal{O}_{1}, ..., \mathcal{O}_{i}\}$ that embody divergent thoughts.
The divergent thoughts process consists of two core components: relevant EDA tool usage demos retrieval and generation of different few-shot prompts with varied $(\mathcal{Q}, \mathcal{C}, \mathcal{A})$ tuples.

\minisection{Relevant EDA Tool Usage Demos Retrieval}
As shown in \Cref{fig:multi_agent_cosys}, the EDA tool usage demo database contains numerous instances, each of which includes a $(\mathcal{Q}, \mathcal{C}, \mathcal{A})$ tuple. 
The embedding model encodes each EDA task $\mathcal{Q}$ into a vector, creating an EDA task vector database.
For a new EDA task, the cosine similarity is computed between its embedding and all vectors in the vector database.
The Top-$K$ most similar tasks are identified, and their corresponding IDs are mapped back to the demo database to retrieve the $K$ most relevant instances with their respective $(\mathcal{Q}, \mathcal{C}, \mathcal{A})$ tuples.

\minisection{Different Few-shot Prompts Generation}
As shown in \Cref{fig:multi_agent_cosys}, several instances are randomly chosen from the retrieved pool of $K$ relevant demos to create a demo group. 
This random selection process is iterated to produce multiple demo groups, such as Group A, Group B, Group C, etc.
Each demo group is concatenated with the few-shot prompt template (displayed in \Cref{fig:cot_prompt}), yielding several few-shot prompt groups with different prompts $\mathcal{T} = {(\mathcal{Q}_{i}, \mathcal{C}_{i}, \mathcal{A}_{i})}^{\mathcal{N}}_{i=1}$.
Upon inputting these differing few-shot prompts into divergent-thoughts agents, they generate various outputs $\mathcal{O}$ according to the given prompts, thus realizing the objective of divergent thoughts.

\subsection{Decision Making}
\label{sec:multi-ChipAgent-dm}

Multiple divergent-thoughts agents $\mathcal{V}_{i}$ generate diverse outcomes $\mathcal{O}_{i} = (\mathcal{C}_{i}, \mathcal{A}_{i})$, reflecting divergent thoughts with different few-shot prompts. 
These outcomes $\mathcal{O}_{i} \in \mathcal{O}$ are encapsulated within a message $m = \{\mathcal{O}_{1}, ..., \mathcal{O}_{i}\}$ and subsequently dispatched to the decision making agent $\mathcal{V}_{j}$ with role $R_{1}$. 
Upon receipt, $\mathcal{V}_{j}$ start to perform a multiple choice selection with various $\mathcal{O}_{i}$ as choices, and determines which $\mathcal{O}_{i}$ should be selected as the representative output of the multi-agent system. 
As depicted in \Cref{fig:multi_agent_cosys}, the generated EDA script will automate the EDA flow interfacing with EDA tools.

As illustrated in \Cref{fig:multi_agent_cosys}, we combine the EDA task and prompt into a complete input and feed it into the decision-making agent for multiple choice selection. 
Specifically, we ask the decision-making agent to analyze and judge whether the generated EDA scripts can solve the EDA task.
Next, we calculate the probability of selecting the \textbf{yes} token from $\{\text{\textbf{yes}}, \text{\textbf{no}}\}$ at the end of the answer for each candidate EDA script as shown in \Cref{fig:multi_agent_cosys}.
Finally, we select the candidate answer with the highest \textbf{yes} token probability as the representative output of the EDAid.
Moreover, considering that the input part is the same for different candidate answers, we store the system prompt in the KV Cache to avoid redundant computation.	