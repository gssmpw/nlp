% This must be in the first 5 lines to tell arXiv to use pdfLaTeX, which is strongly recommended.
\pdfoutput=1
% In particular, the hyperref package requires pdfLaTeX in order to break URLs across lines.

\documentclass[11pt]{article}

% Change "review" to "final" to generate the final (sometimes called camera-ready) version.
% Change to "preprint" to generate a non-anonymous version with page numbers.
\usepackage[final]{acl}

% Standard package includes
\usepackage{times}
\usepackage{latexsym}

% For proper rendering and hyphenation of words containing Latin characters (including in bib files)
\usepackage[T1]{fontenc}
% For Vietnamese characters
% \usepackage[T5]{fontenc}
% See https://www.latex-project.org/help/documentation/encguide.pdf for other character sets

% This assumes your files are encoded as UTF8
\usepackage[utf8]{inputenc}

% This is not strictly necessary, and may be commented out,
% but it will improve the layout of the manuscript,
% and will typically save some space.
\usepackage{microtype}

% This is also not strictly necessary, and may be commented out.
% However, it will improve the aesthetics of text in
% the typewriter font.
\usepackage{inconsolata}

%Including images in your LaTeX document requires adding
%additional package(s)
\usepackage{graphicx}

% If the title and author information does not fit in the area allocated, uncomment the following
%
%\setlength\titlebox{<dim>}
%
% and set <dim> to something 5cm or larger.


\usepackage{svg}
\svgpath{{Figures/}}
\usepackage{graphicx} % Required for including images
\usepackage{graphics}
\usepackage{fancyhdr} % Required for customizing headers and footers
\usepackage{hyperref}
\usepackage{lineno}
\usepackage{graphicx}%
\usepackage{multirow}%
\usepackage{amsmath,amssymb,amsfonts}%
\usepackage{amsthm}%
\usepackage[title]{appendix}%
\usepackage{xcolor}%
\usepackage{textcomp}%
\usepackage{manyfoot}%
\usepackage{booktabs}%
\usepackage{algorithm}%
\usepackage{algorithmicx}%
\usepackage{algpseudocode}%
\usepackage{listings}%

\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{hyperref}       % hyperlinks
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{xcolor}         % colors
\usepackage{makecell}

\usepackage{enumitem}
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage{booktabs}       % professional-quality tables
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{fancyhdr}     
\usepackage{pifont} % header
\usepackage{graphicx}       % graphics
\usepackage{mathrsfs}%
% \usepackage[ruled,linesnumbered]{algorithm2e}
\usepackage{textcomp}%
\usepackage{amsmath}
\usepackage{bbm}
\usepackage{ragged2e}
\usepackage{amssymb}
\usepackage{tabularx}
\usepackage{arydshln}

\usepackage{CJKutf8}

\usepackage{adjustbox}

\usepackage{caption}
\usepackage{subcaption}
% \usepackage{subfigure}
\usepackage[most]{tcolorbox}
\newtcolorbox[list inside=prompt,auto counter]{prompt}[1][]{
    colbacktitle=black!60,
    coltitle=white,
    fontupper=\footnotesize,
    boxsep=5pt,
    left=0pt,
    right=0pt,
    top=0pt,
    bottom=0pt,
    boxrule=1pt,
    #1,
}
\captionsetup[table]{position=top, skip=10pt}
\captionsetup{format=plain, textfont=normalfont}
% \setlength{\parskip}{1em}

% the role of knowledge diversity/conflicts ...
\title{Investigating the Adaptive Robustness with Knowledge Conflicts in LLM-based Multi-Agent Systems}
% \title{Exploring the Dual Role of Knowledge Conflicts in LLM-Based Multi-Agent System}
% \title{Exploring the Double-Edged Sword of Cognitive Diversity in LLM-Based Multi-Agent Systems}

% Author information can be set in various styles:
% For several authors from the same institution:
% \author{Author 1 \and ... \and Author n \\
%         Address line \\ ... \\ Address line}
% if the names do not fit well on one line use
%         Author 1 \\ {\bf Author 2} \\ ... \\ {\bf Author n} \\
% For authors from different institutions:
% \author{Author 1 \\ Address line \\  ... \\ Address line
%         \And  ... \And
%         Author n \\ Address line \\ ... \\ Address line}
% To start a separate ``row'' of authors use \AND, as in
% \author{Author 1 \\ Address line \\  ... \\ Address line
%         \AND
%         Author 2 \\ Address line \\ ... \\ Address line \And
%         Author 3 \\ Address line \\ ... \\ Address line}

% \author{First Author \\
%   Affiliation / Address line 1 \\
%   Affiliation / Address line 2 \\
%   Affiliation / Address line 3 \\
%   \texttt{email@domain} \\\And
%   Second Author \\
%   Affiliation / Address line 1 \\
%   Affiliation / Address line 2 \\
%   Affiliation / Address line 3 \\
%   \texttt{email@domain} \\}

%\author{
%  \textbf{First Author\textsuperscript{1}},
%  \textbf{Second Author\textsuperscript{1,2}},
%  \textbf{Third T. Author\textsuperscript{1}},
%  \textbf{Fourth Author\textsuperscript{1}},
%\\
%  \textbf{Fifth Author\textsuperscript{1,2}},
%  \textbf{Sixth Author\textsuperscript{1}},
%  \textbf{Seventh Author\textsuperscript{1}},
%  \textbf{Eighth Author \textsuperscript{1,2,3,4}},
%\\
%  \textbf{Ninth Author\textsuperscript{1}},
%  \textbf{Tenth Author\textsuperscript{1}},
%  \textbf{Eleventh E. Author\textsuperscript{1,2,3,4,5}},
%  \textbf{Twelfth Author\textsuperscript{1}},
%\\
%  \textbf{Thirteenth Author\textsuperscript{3}},
%  \textbf{Fourteenth F. Author\textsuperscript{2,4}},
%  \textbf{Fifteenth Author\textsuperscript{1}},
%  \textbf{Sixteenth Author\textsuperscript{1}},
%\\
%  \textbf{Seventeenth S. Author\textsuperscript{4,5}},
%  \textbf{Eighteenth Author\textsuperscript{3,4}},
%  \textbf{Nineteenth N. Author\textsuperscript{2,5}},
%  \textbf{Twentieth Author\textsuperscript{1}}
%\\
%\\
%  \textsuperscript{1}Affiliation 1,
%  \textsuperscript{2}Affiliation 2,
%  \textsuperscript{3}Affiliation 3,
%  \textsuperscript{4}Affiliation 4,
%  \textsuperscript{5}Affiliation 5
%\\
%  \small{
%    \textbf{Correspondence:} \href{mailto:email@domain}{email@domain}
%  }
%}

\author{Tianjie Ju\thanks{Equal Contribution}\textsuperscript{1, 2}, 
Bowen Wang\footnotemark[1]\textsuperscript{1}, 
Hao Fei\textsuperscript{2}, 
Mong-Li Lee\textsuperscript{2},
Wynne Hsu\textsuperscript{2},
Yun Li\textsuperscript{3},\\
{\bf Qianren Wang\textsuperscript{3},
Pengzhou Cheng\textsuperscript{1},
Zongru Wu\textsuperscript{1},}
{\bf Zhuosheng Zhang\thanks{Corresponding authors.}\textsuperscript{1},} \\
{\bf Gongshen Liu\footnotemark[2]\textsuperscript{1}}\\
\textsuperscript{1} Shanghai Jiao Tong University, 
\textsuperscript{2} National Univeristy of Singapore, 
\textsuperscript{3} Cognitive AI Lab\\
\texttt{jometeorie@sjtu.edu.cn}
}

% Zhuosheng Zhang$^*$\textsuperscript{1}, 
% Wei Du\textsuperscript{1}, \\ 
% {\bf Yubin Zheng\textsuperscript{1}, 
% Gongshen Liu\thanks{Corresponding authors.}\textsuperscript{1}} \\
% \textsuperscript{1}School of Electronic Information and Electrical Engineering, Shanghai Jiao Tong University \\
% \textsuperscript{2}School of Cyberspace Security, Southeast University\\
% \texttt{\{jometeorie, st.czzz\}@sjtu.edu.cn, symor@seu.edu.cn,}\\
% \texttt{\{zhangzs, dddddw, zybhk21, lgshen\}@sjtu.edu.cn}}

\begin{document}
\maketitle
\begin{abstract}
Recent advances in Large Language Models (LLMs) have upgraded them from sophisticated text generators to autonomous agents capable of corporation and tool use in multi-agent systems (MASs). 
However, the robustness of these LLM-based MASs, especially under knowledge conflicts, remains unclear. 
In this paper, we design four comprehensive metrics to investigate the robustness of MASs when facing mild or task-critical knowledge conflicts.  
We first analyze mild knowledge conflicts introduced by heterogeneous agents and find that they do not harm system robustness but instead improve collaborative decision-making. 
Next, we investigate task-critical knowledge conflicts by synthesizing knowledge conflicts and embedding them into one of the agents. 
Our results show that these conflicts have surprisingly little to no impact on MAS robustness.
% , especially in diverse personality settings. 
Furthermore, we observe that MASs demonstrate certain self-repairing capabilities by reducing their reliance on knowledge conflicts and adopting alternative solution paths to maintain stability. 
Finally, we conduct ablation studies on the knowledge conflict number, agent number, and interaction rounds, finding that the self-repairing capability of MASs has intrinsic limits, and all findings hold consistently across various factors. 
% confirming the potential robustness and self-repairing capabilities of MASs when facing knowledge conflicts. 
% we introduce a fact-verification agent that effectively mitigates the negative impact of knowledge conflicts and restores decision accuracy to levels close to conflict-free scenarios. 
% Our code is available at \textit{anonymity}.
Our code is publicly available at \href{https://github.com/wbw625/MultiAgentRobustness}{https://github.com/wbw625/MultiAgentRobustness}.
\end{abstract}

\section{Introduction}\label{Sec: Introduction}

\begin{figure}[t!]
  \centering
  \includegraphics[width=0.48\textwidth]{Figures/intro.pdf}
  \caption{While knowledge conflicts lead to brainstorming among agents, task-critical knowledge conflicts may lead to unpredictable results in decision-making.}
  \label{fig: intro}
\end{figure}

Large Language Models (LLMs) have shown a significant transformation from serving merely as advanced human-like text generators to functioning as intelligent agents capable of interacting with external tools~\cite{Toolformer, agent_survey}. 
This evolution has empowered them to execute complex tasks by invoking APIs, accessing databases, and utilizing computational resources. 
Simultaneously, there has been a paradigm shift from focusing on single-agent systems to exploring the potential of multi-agent frameworks~\cite{MAS_survey}, where multiple LLM-based agents collaborate to address complex practical tasks, such as collaborative programming~\cite{ChatDev}, embodied AI~\cite{embodied_AI}, and science experiments~\cite{science_experiments}.

Building on these advancements, recent studies have shown that introducing agents in the system with specialized roles~\citep{CAMEL, multi_agent_social_psychology, MedAgents} or domain expertise~\citep{LLM-Coordination, debate_interconsistency, MAS_with_varied_specializations} can substantially improve decision-making performance. 
By pooling insights from agents who each have unique roles, the system collectively navigates a broader solution space than any individual agent. 

Despite the impressive advancements introduced by diverse role assignments, the robustness of LLM-based multi-agent systems (MASs) remains underexplored when facing conflicts. 
Although several studies have analyzed the impact of introducing diverse roles in decision-making~\citep{Multi-Agent_Collaboration, LLM_Discussion}, the influence of knowledge conflicts remains unclear. 
For example, in a collaborative programming scenario, when LLM-based coders with diverse knowledge bases engage in brainstorming discussions, conflicts in task-critical knowledge may lead to unpredictable results (Figure~\ref{fig: intro}).

Building on these concerns, we first analyze the role of knowledge conflicts in multi-agent collaboration. 
We provide insights that knowledge conflicts are the indispensable cornerstone of effective collaborative decision-making.
% , with personality diversity serving as a catalyst. 
In other words, without diverse knowledge, a MAS is functionally equivalent to a single agent, limiting any gains in collective intelligence. 
Yet, this heterogeneity raises concerns about potential conflicts in task-critical knowledge, where even minor discrepancies may trigger unpredictable shifts in the decision-making process (Section~\ref{sec: Rethinking the Role of Multi-Agent Collaboration}).

To verify this hypothesis, we conduct extensive experiments in the multi-agent collaborative programming scenario with tool-calling capabilities. 
We design four novel metrics 
% – Completion Rate (CR), Task Success Rate (TSR), Code Writing Robustness (CWR), and Code Decision Robustness (CDR) – 
that collectively measure the robustness of LLM-based MASs when facing conflicts (Section~\ref{sec: Setup}). 
Through controlled experiments on modified HumanEval benchmarks~\citep{HumanEval} with our synthetic knowledge conflicts, we address four fundamental research questions (RQs) that reveal critical insights into knowledge conflicts in MASs:
\begin{itemize}[noitemsep, topsep=0pt]
    \item \textbf{RQ1:} How do mild knowledge conflicts, such as the natural conflicts between heterogeneous agents, affect collaborative decision-making in MASs?
    \item \textbf{RQ2:} How do task-critical knowledge conflicts affect the robustness of MASs?
    \item \textbf{RQ3:} Can MASs self-repair knowledge conflicts through alternative solution paths?
    \item \textbf{RQ4:} What factors affect the robustness of MASs with knowledge conflicts?
    % \item \textbf{RQ4:} Do agent number and interaction round affect MASs when facing conflicts?
    % \item \textbf{RQ4:} Can we mitigate the impact of task-critical knowledge by introducing fact-verification agents?
\end{itemize}

\textbf{For RQ1}, we postulate that different LLMs inherently possess partial yet mild knowledge conflicts. 
Therefore, we verify the effect of mild conflicts by introducing non-homogeneous agents into an otherwise homogeneous system. 
We surprisingly observe an improvement after introducing heterogeneous agents, which proves the importance of knowledge conflicts for MASs (Section~\ref{fig: How Diversity Contribute to Multi-Agent Decision-Making?}).

\textbf{For RQ2}, we move on to verify how task-critical knowledge conflicts risk the robustness of MASs. 
We design controlled experiments where one coder’s understanding of task-critical knowledge conflicts is altered through multiple knowledge editing methods. 
By perturbing syntax specifications in code-writing tasks, we find that even task-critical conflicts induce only marginal degradation. 
This suggests that task-critical knowledge conflicts may pose less catastrophic risks than commonly hypothesized (Section~\ref{sec: How Task-Critical Knowledge Conflicts Risk the Robustness of Decision-Making?}).

\textbf{For RQ3}, we investigate whether MASs can self-repair task-critical knowledge conflicts through alternative solution paths. 
We find that MASs with task-critical knowledge conflicts exhibit a higher tendency to bypass the syntax specifications, therefore maintaining comparable robustness in RQ2 (Section~\ref{sec: Can LLM-Based MASs Self-Repair Knowledge Conflicts?}). 

% \textbf{For RQ4}, we introduce a fact-verification agent into the LLM-based MASs. 
% ...

\textbf{For RQ4}, 
we explore additional factors influencing conflict resolution in MASs, including knowledge conflict number, agent number, and interaction rounds. 
Similar results are observed under various factors. 
Notably, when the knowledge conflict number surpasses the intrinsic self-repairing capability of MAS, the decision-making robustness also collapses (Section~\ref{sec: Ablation Study}). 

Overall, our findings reveal that knowledge conflicts, rather than being mere obstacles, serve as a critical driver of adaptive robustness in LLM-based MASs. 
We call for the appropriate introduction knowledge conflicts in MASs to facilitate brainstorming among agents.

\section{Related Work}\label{Sec: Related Work}

\subsection{LLM-Based MASs}
LLM-based MASs have emerged as a powerful paradigm for complex problem-solving tasks that benefit from diverse expertise and perspectives~\cite{agent_survey, MAS_survey}. 
Unlike single-agent systems, MASs leverage the collective intelligence of multiple agents, each potentially endowed with distinct knowledge bases and personalities, to enhance decision-making processes~\cite{Multi_agent_cross_domain_knowledge_discovery, RoundTable}. 
These conflicts enable a more comprehensive exploration of solution spaces and mitigate individual biases~\cite{generative_agents, collective_agents}.

Benefiting from these advancements, MASs have been successfully applied in various domains, including collaborative programming~\cite{AutoGen, ChatDev, MetaGPT}, joint medical diagnosis~\cite{MedAgents}, strategic game-playing~\cite{multi_agent_game_playing}, and social simulation~\cite{multi_agent_social_simulation}. 
By assigning roles for each agent with varied knowledge sources, agents are encouraged to challenge assumptions of each other and contribute unique insights, leading to improved decision-making~\cite{multi_agent_cognitive_synergy, multi_agent_social_psychology}.


% The incorporation of divergent knowledge enables agents to consider a broader range of possibilities during collaboration, leading to improved outcomes. 
% Research has shown that such diversity fosters robust problem-solving and innovation, as agents challenge each other’s assumptions and contribute unique insights~\cite{multi_agent_cognitive_synergy, multi_agent_social_psychology}.

\subsection{Robustness Analysis in LLM-Based MASs}
Despite the advantages of LLM-based MASs, their collaborative nature also introduces potential vulnerabilities, particularly when facing conflicts. 
\citet{agent_smith} explored the vulnerability of MASs to adversarial inputs and concluded that a single infected agent could cause an exponential spread of harmful behaviors. 
\citet{flooding_spread} investigated the resilience of MASs against manipulated knowledge spread and found that counterfactual or toxic information can persistently propagate through benign agents. 
Similarly, \citet{Resilience_of_Multi-Agent_Systems} showed that transforming any agent into a malicious one can significantly disrupt the collective decision-making process. 
However, in more general scenarios without the presence of attackers, these studies have not considered whether inherent conflicts within MASs could lead to unrobust collaboration.

Recent research has observed instances of instability in MASs during collaborative decision-making tasks. 
\citet{debate_interconsistency} examined the inter-consistency of LLM-based agents during debates and found that agents can reach inconsistent conclusions due to divergent reasoning paths. 
Similarly, \citet{theory_of_mind_multiagent} investigated the role of theory of mind in multi-agent collaboration, revealing that misaligned beliefs and misunderstandings among agents can hinder effective collaboration. 
Despite these observations, there is still a lack of systematic analysis of the underlying causes of such failures, especially in complex multi-agent interaction scenarios involving tool use capabilities.

\section{Investigating the Role of Knowledge Conflicts in Multi-Agent Collaboration}
\label{sec: Rethinking the Role of Multi-Agent Collaboration}
% Why does multi-agent collaboration enable systems to tackle complex tasks more effectively, and why can it sometimes surpass the performance of a single agent, even when all agents are built on similar foundational LLMs? 
% To answer these questions, we must delve into the principles of MASs, focusing on the conflicts they inherently introduce and the challenges these conflicts pose.
The fundamental premise of multi-agent collaboration lies in its ability to synthesize diverse knowledge perspectives, including the introduction of knowledge conflicts. 
We first delve into the principles of MASs, focusing on the conflicts they inherently introduce.

Let $K_i$ represent the knowledge set of the $i$-th agent in a system of $n$ agents. 
Each knowledge point is represented as a triple $(s, r, o)$, where $s$ is the subject, $r$ is the relation, $o$ is the object. 
To ensure the system gains from collaborative interaction rather than simply replicating a single agent’s capabilities, there must exist at least one pair of agents $A_i$ and $A_j$ whose knowledge sets are not fully overlapping. 

% If these conditions 
If the above condition is not met, then the MAS could be replaced by a single agent that encompasses the union of all agents’ knowledge, $\cup_{i=1}^n K_i$. 
In such a scenario, the system’s collective capability would be no different from that of a single powerful agent. 
The lack of knowledge conflicts would nullify any collaborative advantage, as no new perspectives could emerge from the interaction of identical agents. 
\textbf{A key insight here is that the introduction of partially overlapping knowledge sets enables agents to contribute distinct pieces of information, fostering a broader decision-making process.}

% Building on the knowledge conflicts, personality diversity that previous research concerns serves as a catalyst for stimulating knowledge conflicts.
% Formally, we can define the decision-making inclination of an agent as a function $f_i(K_i, \theta_i)$, where $K_i$ represents the agent’s knowledge set and $\theta_i$ is a parameter set encoding its personality traits. 
% Personality traits here influence both the agent’s output and its receptiveness to inputs from others, creating a dynamic interplay of tendencies.

However, if conflicts occur within task-critical knowledge, it may also jeopardize the robustness of the system, leading to unpredictable decision-making. 
If agents hold different views on such knowledge, the fragility of LLMs to world knowledge may cause even minor perturbations in the MAS to nudge the decision process into drastically different ``knowledge neighborhoods''. 
These abrupt shifts can undermine predictability, as agents may oscillate among multiple resolutions, sometimes yielding dissimilar outcomes for comparable tasks. 
% In particular, personality diversity can amplify the unpredictability of decision-making by introducing a range of behavioral inclinations and communication strategies that further complicate the collaborative process. 
Thus, we focus on exploring the robustness of decision-making within MASs, particularly those involving knowledge conflicts, to better understand how such conflicts influence their collaborative outcomes.

\section{Experiments}
\subsection{Setup}
\label{sec: Setup}

\subsubsection{Evaluating Details}

To investigate the decision-making robustness of complex LLM-based MASs with tool-calling capabilities, we focus on the multi-agent programming collaboration scenario (Figure~\ref{fig: multi-agent system}). 
We employ the AutoGen~\citep{AutoGen} framework to construct the system with one project manager, three coders, and one executor. Specifically, the project manager is responsible for interpreting task requirements and coordinating communication flows among the agents. 
The three coders collaboratively engage in the programming process. 
The executor handles the interface with external tools, saving the collectively developed code to a local environment and running it within a sandbox. 
Detailed system prompts for all agents are shown in Appendix~\ref{sec: Prompts for Multi-Agent Collaborative Programming}.

\begin{figure}[t!]
  \centering
  \includegraphics[width=0.48\textwidth]{Figures/multi-agent_system.pdf}
  \caption{The multi-agent collaborative programming scenario with tool-calling capability used in this paper, including one project manager, three coders, and one executor.}
  \label{fig: multi-agent system}
\end{figure}

We choose LLaMA 3.1 8B Instruct~\citep{LLaMA3} Qwen 2.5 7B Instruct~\citep{Qwen2}, and InternLM 7B Chat~\citep{InternLM} as the single agent. 
Unless otherwise specified, the MAS consists of only one type of LLM. 
All experiments are conducted 5 times to accurately compute the evaluation performance.

\subsubsection{Datasets}
\label{sec: Datasets}

\begin{table*}[t!]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
    \begin{tabular}{lllccc}
    \toprule
    Prompt & Canonical Solution & Prompt for Editing & Subject & Ground Truth & Target New \\
    \midrule
     \makecell[l]{
    \texttt{def unique(l: list):}\\
    \texttt{\ \ \ \ """Return sorted unique elements in a list}\\
    \texttt{\ \ \ \ > > > unique([5, 3, 5, 2, 3, 3, 9, 0, 123])}\\
    \texttt{\ \ \ \ [0, 2, 3, 5, 9, 123]"""}\\} &
    \makecell[l]{\texttt{return sorted(list(set(l)))}\\}
    & \makecell[l]{What is the correct function\\ to remove
    duplicates from\\ a list in Python?} & function & \texttt{set()} & \texttt{distinct()} \\
    \bottomrule
\end{tabular}}
\caption{Illustrative example for evaluating the LLM-based multi-agent coding performance, where we add a piece of task-critical conflicting knowledge (the last four columns) to the existing HumanEval coding dataset.}
\label{tab: Sample}
\end{table*}
 
We build upon the widely used HumanEval dataset~\citep{HumanEval}, which offers a set of short coding tasks accompanied by comprehensive test suites. 
We additionally introduce synthetic knowledge conflicts for each task, 
% using GPT-4~\citep{GPT-4}, 
which we then used for knowledge editing on exactly one coder in our system. 
We provide an example of how we integrate the newly generated conflict knowledge into the existing HumanEval dataset in Table~\ref{tab: Sample}. 
All task-critical knowledge conflicts are randomly sampled from the knowledge used in the column \textit{Canonical Solution}. 
The specific prompts used for generating these task-critical knowledge conflicts can be found in Appendix~\ref{sec: Prompts for Generating Knowledge Conflicts}.

\subsubsection{Evaluation Metrics}

We propose four primary metrics to evaluate the performance of MASs. 
We consider $N$ distinct programming problems, each of which is tackled by the MAS $k$ times. 
The four metrics are defined as follows:

\paragraph{Completion Rate (CR).} 
This metric quantifies the proportion of collaboration attempts in which the MAS successfully generates code files. 
If $R_{i,j}$ is a binary indicator that equals 1 when a code solution is provided for problem $i$ in the $j$-th attempt (and 0 otherwise), we define:
\begin{equation}
    \mathrm{CR} = \frac{1}{N \times k} \sum_{i=1}^{N} \sum_{j=1}^{k} R_{i,j}.
\end{equation}

\paragraph{Task Success Rate (TSR).} 
This metric focuses on functional correctness. 
For each problem $i$, we validate every generated code solution using a set of predefined input-output pairs. 
Let $S_{i,j}$ be the success rate for problem $i$ in the $j$-th attempt, then we have:
\begin{equation} 
    \mathrm{TSR} = \frac{1}{N \times k} \sum_{i=1}^{N} \sum_{j=1}^{k} S_{i,j}.
\end{equation}

\paragraph{Code Writing Robustness (CWR).} 
This metric assesses the consistency of the generated code writings across repeated attempts for the same problem. 
For each problem $i$, let ${c_{i,1}, c_{i,2}, \ldots, c_{i,k}}$ be the code writings produced over $k$ attempts.
We compute pairwise CodeBLEU~\citep{CodeBLEU} scores between all pairs of code writings. 
Let $\mathrm{CB}(\cdot, \cdot)$ denote the CodeBLEU score. 
Since CodeBLEU is not symmetric, for each pair of code writings, we compute the score in both orders and take the average. 
The overall CWR is defined as:
\begin{equation}
    \mathrm{CWR} = \frac{1}{N} \sum_{i=1}^{N} \left( \frac{1}{\binom{k}{2}} \sum_{1 \le p < q \le k} \mathrm{CB}\big(c_{i,p}, c_{i,q}\big) \right).
\end{equation}

\paragraph{Code Decision Robustness (CDR).} 
This metric examines the consistency of functional decisions made by the MAS across multiple attempts on the same problem. 
Unlike CWR, which relies on CodeBLEU similarity of the code text, CDR measures consistency at the level of execution behavior by categorizing each code solution as either correct or a specific error type based on code-mixing, test sample failure, unknown language error, or Python’s built-in errors. 
Specific error categories that appeared during running are shown in Appendix~\ref{sec: error types}.
Let $\mathrm{EC}(\cdot, \cdot)$ denote a function that returns 1 if two code solutions yield the same execution type, and 0 otherwise.
The code decision robustness can be computed as: \begin{equation}
    \mathrm{CDR} = \frac{1}{N} \sum_{i=1}^{N} \left( \frac{1}{\binom{k}{2}} \sum_{1 \le p < q \le k} \mathrm{EC}\big(c_{i,p}, c_{i,q}\big) \right).
\end{equation}


\begin{figure*}[htbp]
    \centering
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{Figures/mild_knowledge_conflict_llama.pdf}
        \caption{LLaMA 3.1 8B Instruct}
        \label{fig: mild_knowledge_conflict_llama}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{Figures/mild_knowledge_conflict_qwen.pdf}
        \caption{Qwen 2.5 7B Instruct}
        \label{fig: mild_knowledge_conflict_qwen}
    \end{subfigure}
    \hfill
    \begin{subfigure}[b]{0.32\textwidth}
        \centering
        \includegraphics[width=\textwidth]{Figures/mild_knowledge_conflict_internlm.pdf}
        \caption{InternLM 7B Chat}
        \label{fig: mild_knowledge_conflict_internlm}
    \end{subfigure}
    \caption{Comparison of multi-dimensional decision-making performance in LLM-based MASs with or without mild knowledge conflicts.}
    \label{fig: How Diversity Contribute to Multi-Agent Decision-Making?}
\end{figure*}

\subsection{How Mild Knowledge Conflicts Affect Multi-Agent Decision-Making?}


To validate the hypothesis that knowledge conflicts serve as indispensable elements for achieving superior performance in LLM-based multi-agent decision-making, we conduct a set of controlled experiments under varying levels of conflicts. 
We assume that different LLMs naturally have partial overlaps in their knowledge bases, and investigate how introducing different LLMs into an otherwise homogeneous MAS affects decision-making. 
Therefore, for each baseline MAS composed of agents using the same LLM, we construct the mixed systems by replacing two coders with agents based on the other two LLMs while keeping the project manager and executor unchanged. 
For example, in an LLaMA-based MAS, we randomly replace two of the coders with Qwen and InternLM, respectively.
% we construct two types of mixed systems: (1) \textit{Mixed System}: replacing two coders with agents based on the other two LLMs (Qwen and InternLM) while keeping the project manager and executor unchanged; (2) \textit{Mixed System w/ Personality}: further injecting distinct personality traits into each coder through system prompt modifications.

Figure~\ref{fig: How Diversity Contribute to Multi-Agent Decision-Making?} presents the four evaluation metrics under MASs with identical agents or with the introduction of heterogeneous agents. 
We find that the introduction of such mild knowledge conflicts through heterogeneous agents does not compromise system robustness. 
For InternLM-based MASs (Figure~\ref{fig: mild_knowledge_conflict_internlm}), replacing two coders with Qwen and LLaMA significantly improves the TSR, and even CWR and CDR. 
For LLaMA-based MASs (Figure~\ref{fig: mild_knowledge_conflict_llama}), its original collaborative programming capability is higher than that of InternLM but lower than that of Qwen. 
However, when these three agents are required to engage in collaborative programming within a single system, the performance of the LLaMA-based MAS does not experience catastrophic failure due to the relatively poor influence of InternLM, nor does it simply reflect the average decision-making performance. 
Instead, it achieves significantly higher performance before introducing heterogeneous agents. 
\textbf{This finding suggests that MASs possess the capability to engage in brainstorming within mild knowledge conflicts, ultimately leading to superior decision-making.}

For Qwen-based MASs (Figure~\ref{fig: mild_knowledge_conflict_qwen}), which inherently has the best performance, introducing LLaMA and InternLM with weaker collaborative programming capabilities does not lead to catastrophic collaboration failure. 
Although modest declines were observed in TSR and CDR, these losses are acceptable when contrasted with the significant performance gains obtained by introducing heterogeneous agents from LLaMA and InternLM. 
% These experiments demonstrate that the introduction of mild knowledge conflicts does not result in the anticipated catastrophic negative impact on the robustness of collaboration and can even enhance collaborative performance in most cases.

\subsection{How Task-Critical Knowledge Conflicts Risk the Robustness of Decision-Making?}
\label{sec: How Task-Critical Knowledge Conflicts Risk the Robustness of Decision-Making?}

\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{l|cccc|cccc|cccc}
\toprule
 & \multicolumn{4}{c}{\textbf{LLaMA 3.1 8B Instruct}} & \multicolumn{4}{c}{\textbf{Qwen 2.5 7B Instruct}} & \multicolumn{4}{c}{\textbf{InternLM 7B Chat}} \\
\cmidrule(lr){2-5}\cmidrule(lr){6-9}\cmidrule(lr){10-13}
\textbf{Method} & \textbf{CR} & \textbf{TSR} & \textbf{CWR} & \textbf{CDR} & \textbf{CR} & \textbf{TSR} & \textbf{CWR} & \textbf{CDR}& \textbf{CR} & \textbf{TSR} & \textbf{CWR} & \textbf{CDR} \\
\midrule
% Single-Agent w/o Conflicts &  &  &  &  &  &  &  &  &  &  &  &  \\
w/o Conflicts & 99.02 & 30.73 & 36.43 & 24.21 & \textbf{100.00} & 71.46 & 42.23 & 70.67 & \textbf{99.76} & 5.00 & \textbf{51.55} & 27.56 \\
% \midrule
% \multicolumn{13}{c}{\textbf{Knowledge Conflicts}} \\
\midrule
w/ Conflicts (ROME) & 99.39 & 29.94 & 36.86 & 25.21 & \textbf{100.00} & 70.98 & 43.61 & 70.00 & 99.15 & \textbf{5.37} & 50.90 & 25.37 \\
w/ Conflicts (MEND) & 99.27 & 28.85 & 35.73 & 22.14 & \textbf{100.00} & 71.34 & 43.84 & 71.28 & 97.80 & 3.90 & 51.28 & \textbf{29.21} \\
w/ Conflicts (IKE) & \textbf{98.78} & \textbf{31.22} & \textbf{36.81} & \textbf{29.33} & \textbf{100.00} & \textbf{71.71} & \textbf{44.20} & \textbf{71.95} & 99.39 & 3.54 & 51.31 & 26.40 \\
\bottomrule
\end{tabular}}
\caption{Comparison of multi-dimensional decision-making performance with task-critical knowledge conflicts in LLM-based MASs.}
\label{tab: How Diversity in Task-Critical Knowledge Evolves into Decision-Making Conflicts?}
\end{table*}

\begin{table*}[t!]
\centering
\resizebox{\linewidth}{!}{
\begin{tabular}{lcccccccccccccc}
\toprule
\textbf{Scenario} & \textbf{Miss} & \textbf{Sample} & \textbf{Language} & \textbf{Syntax} & \textbf{ZeroDiv} & \textbf{Name} & \textbf{Type} & \textbf{Index} & \textbf{Key} & \textbf{Attribute} & \textbf{Value} & \textbf{File} & \textbf{Import} & \textbf{Other} \\
\midrule
& \multicolumn{14}{c}{\textbf{LLaMA 3.1 8B Instruct}} \\
\cmidrule{2-15}
Origin & 1.6\footnotesize$\pm$1.4 & 29.8\footnotesize$\pm$3.8 & 17.4\footnotesize$\pm$4.4 & 5.8\footnotesize$\pm$2.8 & 0.4\footnotesize$\pm$0.5 & 8.6\footnotesize$\pm$3.8 & \textbf{1.4\footnotesize$\pm$0.5} & 0.2\footnotesize$\pm$0.4 & \textbf{0.0\footnotesize$\pm$0.0} & \textbf{0.0\footnotesize$\pm$0.0} & 7.4\footnotesize$\pm$1.9 & 2.4\footnotesize$\pm$1.5 & 5.8\footnotesize$\pm$2.2 & 31.8\footnotesize$\pm$4.3 \\
% \cdashline{1-15}
% \cdashline{1-15}
ROME & \textbf{1.0\footnotesize$\pm$0.6} & 28.6\footnotesize$\pm$2.2 & 19.2\footnotesize$\pm$5.0 & 4.6\footnotesize$\pm$2.0 & 0.6\footnotesize$\pm$0.5 & 9.0\footnotesize$\pm$4.2 & 1.6\footnotesize$\pm$1.0 & 0.4\footnotesize$\pm$0.8 & 0.2\footnotesize$\pm$0.4 & 0.6\footnotesize$\pm$0.5 & 7.4\footnotesize$\pm$1.9 & 2.4\footnotesize$\pm$0.8 & \textbf{3.4\footnotesize$\pm$1.4} & 35.2\footnotesize$\pm$5.5 \\
MEND & \textbf{1.0\footnotesize$\pm$0.6} & \textbf{27.4\footnotesize$\pm$4.1} & 17.0\footnotesize$\pm$3.0 & 7.2\footnotesize$\pm$2.9 & 0.4\footnotesize$\pm$0.8 & 10.6\footnotesize$\pm$2.3 & \textbf{1.4\footnotesize$\pm$0.8} & \textbf{0.0\footnotesize$\pm$0.0} & 0.2\footnotesize$\pm$0.4 & 1.2\footnotesize$\pm$1.2 & \textbf{6.6\footnotesize$\pm$1.7} & 2.4\footnotesize$\pm$0.8 & 3.6\footnotesize$\pm$1.9 & 31.6\footnotesize$\pm$3.7 \\
IKE & 2.0\footnotesize$\pm$1.3 & 36.6\footnotesize$\pm$4.5 & \textbf{14.8\footnotesize$\pm$2.3} & \textbf{5.0\footnotesize$\pm$1.9} & \textbf{0.0\footnotesize$\pm$0.0} & \textbf{8.4\footnotesize$\pm$3.2} & 2.4\footnotesize$\pm$1.0 & \textbf{0.0\footnotesize$\pm$0.0} & 0.8\footnotesize$\pm$0.7 & 0.8\footnotesize$\pm$0.7 & 8.0\footnotesize$\pm$1.1 & \textbf{2.2\footnotesize$\pm$1.0} & 3.6\footnotesize$\pm$1.6 & \textbf{28.2\footnotesize$\pm$4.4} \\
\midrule
& \multicolumn{14}{c}{\textbf{Qwen 2.5 7B Instruct}} \\
\cmidrule{2-15}
Origin & \textbf{0.0\footnotesize$\pm$0.0} & 26.4\footnotesize$\pm$2.2 & 4.2\footnotesize$\pm$1.2 & \textbf{0.2\footnotesize$\pm$0.4} & 0.4\footnotesize$\pm$0.5 & \textbf{1.4\footnotesize$\pm$1.4} & 2.4\footnotesize$\pm$1.5 & 0.6\footnotesize$\pm$0.8 & 0.2\footnotesize$\pm$0.4 & 0.2\footnotesize$\pm$0.4 & 1.4\footnotesize$\pm$1.0 & 4.4\footnotesize$\pm$1.0 & 1.0\footnotesize$\pm$0.6 & 4.0\footnotesize$\pm$1.1 \\
% \cdashline{1-15} &  \\
% \cdashline{1-15}
ROME & \textbf{0.0\footnotesize$\pm$0.0} & 27.2\footnotesize$\pm$1.2 & 4.2\footnotesize$\pm$1.9 & 0.4\footnotesize$\pm$0.5 & \textbf{0.0\footnotesize$\pm$0.0} & 2.2\footnotesize$\pm$1.5 & 2.6\footnotesize$\pm$0.5 & 0.2\footnotesize$\pm$0.4 & \textbf{0.0\footnotesize$\pm$0.0} & 0.4\footnotesize$\pm$0.4 & \textbf{1.0\footnotesize$\pm$0.6} & 4.8\footnotesize$\pm$1.7 & 1.0\footnotesize$\pm$0.6 & 3.6\footnotesize$\pm$2.1 \\
MEND & \textbf{0.0\footnotesize$\pm$0.0} & 28.6\footnotesize$\pm$4.4 & 4.2\footnotesize$\pm$1.9 & 0.4\footnotesize$\pm$0.5 & \textbf{0.0\footnotesize$\pm$0.0} & 1.8\footnotesize$\pm$1.0 & 2.2\footnotesize$\pm$1.5 & \textbf{0.0\footnotesize$\pm$0.0} & 0.2\footnotesize$\pm$0.4 & \textbf{0.0\footnotesize$\pm$0.0} & 2.4\footnotesize$\pm$0.5 & \textbf{3.0\footnotesize$\pm$1.8} & 1.4\footnotesize$\pm$0.8 & \textbf{2.8\footnotesize$\pm$1.9} \\
IKE & \textbf{0.0\footnotesize$\pm$0.0} & \textbf{28.6\footnotesize$\pm$3.9} & \textbf{2.0\footnotesize$\pm$0.6} & 1.0\footnotesize$\pm$0.9 & 0.2\footnotesize$\pm$0.4 & 2.8\footnotesize$\pm$1.0 & \textbf{1.6\footnotesize$\pm$1.0} & 0.2\footnotesize$\pm$0.4 & \textbf{0.0\footnotesize$\pm$0.0} & \textbf{0.0\footnotesize$\pm$0.0} & 2.0\footnotesize$\pm$1.1 & 3.8\footnotesize$\pm$1.2 & \textbf{0.4\footnotesize$\pm$0.5} & 3.8\footnotesize$\pm$1.2 \\
\midrule
& \multicolumn{14}{c}{\textbf{InternLM 7B Chat}} \\
\cmidrule{2-15}
Origin & \textbf{0.4\footnotesize$\pm$0.5} & 68.8\footnotesize$\pm$4.8 & 2.2\footnotesize$\pm$1.2 & 5.4\footnotesize$\pm$1.7 & \textbf{0.0\footnotesize$\pm$0.0} & \textbf{10.8\footnotesize$\pm$2.9} & 6.2\footnotesize$\pm$3.1 & 0.4\footnotesize$\pm$0.5 & \textbf{0.0\footnotesize$\pm$0.0} & 1.0\footnotesize$\pm$0.6 & \textbf{1.4\footnotesize$\pm$1.0} & \textbf{4.0\footnotesize$\pm$2.3} & 25.6\footnotesize$\pm$3.1 & 29.6\footnotesize$\pm$2.4 \\
% \cdashline{1-15}
% \cdashline{1-15}
ROME & 1.4\footnotesize$\pm$0.5 & 65.8\footnotesize$\pm$6.3 & \textbf{1.6\footnotesize$\pm$0.8} & 4.6\footnotesize$\pm$1.0 & \textbf{0.0\footnotesize$\pm$0.0} & 14.6\footnotesize$\pm$2.2 & 5.8\footnotesize$\pm$3.2 & \textbf{0.0\footnotesize$\pm$0.0} & \textbf{0.0\footnotesize$\pm$0.0} & 0.6\footnotesize$\pm$0.8 & 1.6\footnotesize$\pm$1.0 & 4.2\footnotesize$\pm$2.6 & \textbf{23.0\footnotesize$\pm$3.3} & 32.0\footnotesize$\pm$2.8 \\
MEND & 3.6\footnotesize$\pm$0.8 & \textbf{64.2\footnotesize$\pm$2.6} & 2.8\footnotesize$\pm$0.7 & \textbf{3.0\footnotesize$\pm$1.1} & \textbf{0.0\footnotesize$\pm$0.0} & 12.2\footnotesize$\pm$4.7 & \textbf{4.8\footnotesize$\pm$1.7} & 0.2\footnotesize$\pm$0.4 & \textbf{0.0\footnotesize$\pm$0.0} & 0.4\footnotesize$\pm$0.5 & 3.2\footnotesize$\pm$2.0 & 6.0\footnotesize$\pm$1.9 & 25.8\footnotesize$\pm$2.3 & 31.4\footnotesize$\pm$5.5 \\
IKE & 1.0\footnotesize$\pm$0.0 & 68.6\footnotesize$\pm$3.3 & 3.6\footnotesize$\pm$1.7 & 5.4\footnotesize$\pm$1.4 & \textbf{0.0\footnotesize$\pm$0.0} & 12.2\footnotesize$\pm$1.9 & \textbf{4.8\footnotesize$\pm$1.7} & \textbf{0.0\footnotesize$\pm$0.0} & 0.2\footnotesize$\pm$0.4 & \textbf{0.2\footnotesize$\pm$0.4} & 2.0\footnotesize$\pm$1.1 & \textbf{4.0\footnotesize$\pm$3.0} & 26.8\footnotesize$\pm$2.3 & \textbf{29.4\footnotesize$\pm$3.8} \\
\bottomrule
\end{tabular}
}
\caption{The average occurrence of different error types in five runs of MASs before and after the introduction of task-critical knowledge conflicts.}
\label{tab:error_summary}
\end{table*}

Although mild knowledge conflicts can benefit multi-agent decision-making, there is still a concern that if agents hold conflicting in task-critical knowledge, the inherent fragility of LLMs regarding world knowledge may introduce unpredictable results~\citep{flooding_spread}. 
To verify this hypothesis, we employ commonly used knowledge-editing methods to alter one coder's perception of task-critical knowledge introduced in Section ~\ref{sec: Datasets}. 
Specifically, we apply the ROME~\citep{ROME}, MEND~\citep{MEND}, and IKE~\citep{IKE} algorithms for editing knowledge within local parameters, global parameters, or through in-context, ensuring the edited coder maintains fundamental capabilities but diverges in a single task-critical knowledge. 
The detailed implementation of the adopted knowledge editing methods is provided in Appendix~\ref{sec: Implementation of Knowledge Editing}.

Table~\ref{tab: How Diversity in Task-Critical Knowledge Evolves into Decision-Making Conflicts?} presents the multi-dimensional decision-making performance of LLM-based MASs both before and after introducing task-critical knowledge conflicts. 
To our surprise, introducing task-critical knowledge conflicts via various knowledge-editing methods does not lead to a substantial decline in the overall robustness. 
For LLaMA-based and Qwen-based MASs, applying task-critical knowledge conflicts through the in-context method IKE even slightly enhances performance. 
This suggests that the incorrect knowledge introduced does not necessarily mislead the agents but instead serves as a prompt to recognize the need for a specific method to solve the problem.
In contrast, InternLM-based MASs exhibit a noticeable performance decline when introducing task-critical knowledge conflicts. 
When the MAS is inherently less proficient at a given collaborative task, knowledge conflicts can still disrupt its decision-making.

Next, we present the average occurrences of various error types across five turns of testing in Table~\ref{tab: How Diversity in Task-Critical Knowledge Evolves into Decision-Making Conflicts?} to provide a deeper insight into the concrete issues encountered by different MASs. 
Specific details of these error types are provided in Appendix~\ref{sec: error types}. 
For example, it can be observed that LLaMA-based MASs exhibit a higher tendency to produce custom exceptions, leading to a significant number of \texttt{OtherError} instances. 
Conversely, Qwen-based MASs rarely produce explicit errors, where failures are predominantly due to test cases not passing.

\textbf{Notably, after introducing knowledge conflicts, MASs generally maintain a similar distribution of error types.} 
Although we introduce conflicts in task-critical knowledge through knowledge-editing methods, this does not necessarily mean that the solution path is completely blocked. 
This is inconsistent with previous attempts which are often performed under adversarial risk scenarios~\cite{agent_smith, flooding_spread}. 
These methods enforce persistent belief alignment in the manipulated agent by attackers' prompt or direct preference optimization, thus causing catastrophic impact.

Another possible reason for the observational inconsistency is that prior studies mainly focus on question-answering tasks, where problem-solving paths are always unique. 
As illustrated in Table~\ref{tab: Sample}, we replaced \texttt{set()} with \texttt{distinct()} as the correct function to remove duplicates from a list in Python, but the MAS can still circumvent this conflicting knowledge by adopting other methods. 
For instance, agents may resort to list comprehensions, dictionaries, or other Pythonic approaches to remove duplicates without calling the \texttt{distinct()} function. 

\subsection{Can LLM-Based MASs Self-Repair Knowledge Conflicts?}
\label{sec: Can LLM-Based MASs Self-Repair Knowledge Conflicts?}

To further examine the system’s capability for self-repairing as observed in Section~\ref{sec: How Task-Critical Knowledge Conflicts Risk the Robustness of Decision-Making?},  we use the prompt provided in Appendix~\ref{sec: Prompts for Measuring the Self-Repairing Capability of MASs} for detecting whether generated codes contain references to the introduced task-critical knowledge conflicts. 
Table~\ref{tab: Self Repair Conflict} presents the probability that MASs avoid using the task-critical knowledge conflict before and after its introduction. 
We find that \textbf{MASs exhibit a higher likelihood of circumventing these conflicts during decision-making, demonstrating their certain degree of self-repairing capability to mitigate the impact of task-critical knowledge conflicts.}

\begin{table}[t!]
\centering
\resizebox{1.0\linewidth}{!}{
\begin{tabular}{l|ccc}
\toprule
\textbf{Method} & \textbf{LLaMA} & \textbf{Qwen} & \textbf{InternLM} \\
\midrule
% Single Agent w/o Conflicts &  &  &  \\
w/o Conflicts & 65.24 & 61.59 & 78.17 \\
% \midrule
% & \multicolumn{3}{c}{\textbf{Knowledge Conflicts}} \\
\midrule
w/ Conflicts (ROME) & 67.07\textcolor{green}{\scriptsize$\uparrow$ 1.83} & 64.76\textcolor{green}{\scriptsize$\uparrow$ 3.17} & 81.34\textcolor{green}{\scriptsize$\uparrow$ 3.17} \\
w/ Conflicts (MEND) & 67.20\textcolor{green}{\scriptsize$\uparrow$ 1.96} & 63.05\textcolor{green}{\scriptsize$\uparrow$ 1.46} & 82.07\textcolor{green}{\scriptsize$\uparrow$ 3.90} \\
w/ Conflicts (IKE) & 64.27\textcolor{red}{\scriptsize$\downarrow$ 0.97} & 63.41\textcolor{green}{\scriptsize$\uparrow$ 1.82} & 83.78\textcolor{green}{\scriptsize$\uparrow$ 5.61} \\
\bottomrule
\end{tabular}}
\caption{Comparison of the probability that the generated code avoids using the injected task-critical knowledge conflicts.}
\label{tab: Self Repair Conflict}
\end{table}

% \begin{table*}[ht]
% \centering
% \caption{Comparison of the probability that the generated code avoids using the injected task-critical knowledge conflicts.}
% \resizebox{0.8\linewidth}{!}{
% \begin{tabular}{l|ccc}
% \toprule
% \textbf{Method} & \textbf{LLaMA 3.1 8B Instruct} & \textbf{Qwen 2.5 7B Instruct} & \textbf{InternLM 7B Chat} \\
% \midrule
% Single Agent w/o Conflicts &  &  &  \\
% Multi-Agent w/o Conflicts &  & 61.59 &  \\
% \midrule
% & \multicolumn{3}{c}{\textbf{Knowledge Conflicts}} \\
% \midrule
% ROME &  & 64.76 &  \\
% MEND &  &  &  \\
% IKE &  & 63.41 &  \\
% \bottomrule
% \end{tabular}}
% \label{tab: Self Repair Conflict}
% \end{table*}

% \begin{table*}[ht]
% \centering
% \caption{Comparison of the probability that the generated code avoids using the injected conflicting knowledge.}
% \resizebox{\linewidth}{!}{
% \begin{tabular}{l|ccc}
% \toprule
% \textbf{Method} & \textbf{LLaMA 3.1 8B Instruct} & \textbf{Qwen 2.5 7B Instruct} & \textbf{InternLM 7B Chat} \\
% \midrule
% Single Agent w/o Conflicts &  &  &  \\
% Multi-Agent w/o Conflicts &  &  &  \\
% \midrule
% & \multicolumn{3}{c}{\textbf{Knowledge Conflicts}} \\
% \midrule
% ROME &  &  &  \\
% IKE &  &  &  \\
% \midrule
% & \multicolumn{3}{c}{\textbf{Knowledge Conflicts \& Personality Conflicts}} \\
% \midrule
% PersonalityEdit &  &  &  \\
% PersonalityEdit + ROME &  &  &  \\
% PersonalityEdit + IKE &  &  &  \\
% \bottomrule
% \end{tabular}}
% \label{tab: Self Repair Conflict}
% \end{table*}

% \subsection{Will Long-Turn Communication Intensify Confusion?}
% 交互轮数折线图

To intuitively demonstrate the self-repairing capability of MASs, we present the collaborative programming codes of Qwen-based MASs before and after introducing conflicting knowledge via IKE. 
Among five turns, the MASs without conflicting knowledge consistently used the \texttt{append()} function. 
However, after introducing conflicting knowledge, the MASs avoided using the \texttt{append()} function in three out of five decisions. 
Table~\ref{tab:self_repair_comparison} displays one such instance. 
The MASs bypass the use of simple and effective in-built \texttt{append()} function by directly writing out the entire list, thereby mitigating the potential impact of conflicting knowledge on decision-making. 
Complete codes for the five turns before and after introducing knowledge conflicts are shown in Appendix~\ref{sec: Examples of the Self-Repairing Capability of MASs With Task-Critical Knowledge Conflicts}.

\begin{table}[t!]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
    \begin{tabular}{l|l}
    \toprule
    Task & \makecell[l]{Please write a function to efficiently compute the n-th\\ element of the fib4 number sequence. Do not use recursion.}\\
    \midrule
    Knowledge & \makecell[l]{Which Python method appends an element to a list?\\
    \textbf{append() $\rightarrow$ add()}}\\
    \midrule
    w/o Conflicts & \makecell[l]{\texttt{def fib4(n: int):}\\
    \texttt{\ \ \ \ if n == 0: return 0}\\
    \texttt{\ \ \ \ if n == 1: return 0}\\
    \texttt{\ \ \ \ if n == 2: return 2}\\
    \texttt{\ \ \ \ if n == 3: return 0}\\
    \texttt{\ \ \ \ fib = [0, 0, 2, 0]}\\
    \texttt{\ \ \ \ for i in range(4, n + 1):}\\
    \texttt{\ \ \ \ \ \ \ \ fib.\textbf{append}(fib[i - 1] + fib[i - 2] +}\\
    \texttt{\ \ \ \ \ \ \ \ fib[i - 3] + fib[i - 4])}\\
    \texttt{\ \ \ \ return fib[n]}}\\
    \midrule
    w/ Conflicts & \makecell[l]{\texttt{def fib4(n: int):}\\
    \texttt{\ \ \ \ if n == 0 or n == 1:}\\
    \texttt{\ \ \ \ \ \ \ \ return 0}\\
    \texttt{\ \ \ \ if n == 2:}\\
    \texttt{\ \ \ \ \ \ \ \ return 2}\\
    \texttt{\ \ \ \ if n == 3:}\\
    \texttt{\ \ \ \ \ \ \ \ return 0}\\
    \texttt{\ \ \ \ fib4\_values = [0, 0, 2, 0]}\\
    \texttt{\ \ \ \ for i in range(4, n + 1):}\\
    \texttt{\ \ \ \ \ \ \ \ next\_value = sum(fib4\_values)}\\
    \texttt{\ \ \ \ \ \ \ \ fib4\_values = [fib4\_values[1], fib4\_values[2],}\\
    \texttt{\ \ \ \ \ \ \ \ fib4\_values[3], next\_value]}\\
    \texttt{\ \ \ \ return fib4\_values[-1]}}\\
    \bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs bypassing task-critical knowledge conflicts for collaborative programming. We remove all comments from the generated codes.}
\label{tab:self_repair_comparison}
\end{table}

% \subsection{Can We Mitigate Conflicts with Fact-Verification Agent?}

\subsection{Ablation Study}
\label{sec: Ablation Study}

Considering that the construction of MASs is not limited to the specific scenarios investigated in this paper (Figure~\ref{fig: multi-agent system}), we conduct ablation experiments to examine the impact of knowledge conflict number, agent number, and interaction rounds on MAS robustness under both mild and task-critical knowledge conflicts.

\subsubsection{Impact of Knowledge Conflicts Number}

In this section, we explore the scenarios with more severe critical knowledge conflicts to verify if there is a limit of the self-repairing capability. 
For each task, we generate 5 or 10 distinct task-critical pieces of knowledge with ROME and IKE to further block the possibility of MASs solving tasks in other ways.

Table~\ref{tab: knowledge_conflict_number_results} presents the evaluation results with different numbers of knowledge conflicts. 
The overall performance significantly declines as the number of conflicts increases, especially using the parametric knowledge editing method ROME. 
This suggests that \textbf{MASs can only tolerate a limited degree of task-critical knowledge conflicts before their decision-making process is significantly impaired}.

\begin{table}[t!]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tabular}{cl|cccc}
        \toprule
        \textbf{\#Coder} & \textbf{Scenario} & \textbf{CR} & \textbf{TSR} & \textbf{CWR} & \textbf{CDR} \\
        \midrule
        \multirow{2}{*}{1} & ROME & 99.39 & 29.94 & 36.86 & 25.21 \\
                           & IKE & 98.78 & 31.22 & 36.81 & 29.33 \\
        \midrule
        \multirow{2}{*}{5} & ROME & 96.71 & 29.15 & 37.08 & 27.93 \\
                           & IKE & 98.29 & 30.49 & 35.79 & 24.39 \\        \midrule
        \multirow{2}{*}{10} & ROME & 62.35 & 28.41 & 20.98 & 38.88 \\
                           & IKE & 97.44 & 29.14 & 36.56 & 27.79 \\
        \bottomrule
    \end{tabular}}
    \caption{Impact of knowledge conflict numbers on LLaMA-based MASs robustness under different conflict scenarios}
    \label{tab: knowledge_conflict_number_results}
\end{table}

\subsubsection{Impact of Agent Number}

To further investigate how the number of agents is affected by knowledge conflicts, we conduct experiments on LLaMA-based MASs by modifying the number of coder agents while keeping other components fixed. 
For mild knowledge conflicts, we keep introducing one Qwen-based coder and one InternLM-based coder. 
For task-critical knowledge conflicts, we keep editing one of the coders within the system. 

Table~\ref{tab: coder_number_results} presents the impact of varying the number of coders. 
Interestingly, simply increasing the agent number does not lead to improved performance, indicating that additional agents without knowledge conflicts do not contribute positively to the MASs, which is consistent with our view on the role of knowledge conflicts (Section~\ref{sec: Rethinking the Role of Multi-Agent Collaboration}). 
Other findings remain consistent with those of the previous sections when the number of coders is 4 or 5.

\begin{table}[t!]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tabular}{cl|cccc}
        \toprule
        \textbf{\#Coder} & \textbf{Scenario} & \textbf{CR} & \textbf{TSR} & \textbf{CWR} & \textbf{CDR} \\
        \midrule
        \multirow{3}{*}{3} & w/o Conflicts & 99.02 & 30.73 & 36.43 & 24.21 \\
                           & Mild Conflicts & \textbf{100.00} & \textbf{46.83} & \textbf{51.11} & \textbf{38.90} \\
                           & Task-Critical Conflicts & 98.78 & 31.22 & 36.81 & 29.33 \\
        \midrule
        \multirow{3}{*}{4} & w/o Conflicts & 94.25 & 28.55 & 31.21 & 26.84 \\
                           & Mild Conflicts & \textbf{100.00} & \textbf{51.03} & \textbf{49.81} & \textbf{37.59} \\
                           & Task-Critical Conflicts & 93.41 & {31.53} & 33.23 & 27.41 \\
        \midrule
        \multirow{3}{*}{5} & w/o Conflicts & 86.72 & 21.30 & 27.71 & 28.53 \\
                           & Mild Conflicts & \textbf{92.11} & \textbf{35.27} & \textbf{36.67} & 28.06 \\
                           & Task-Critical Conflicts & 80.59 & 26.28 & 27.03 & \textbf{32.94} \\
        \bottomrule
    \end{tabular}}
    \caption{Impact of agent numbers on LLaMA-based MASs robustness under different conflict scenarios}
    \label{tab: coder_number_results}
\end{table}


\subsubsection{Impact of Interaction Round}

We further investigate how increasing the number of interaction rounds influences decision-making in MASs before and after the introduction of knowledge conflicts. 
We keep focusing on LLaMA-based MASs and measure their robustness under different numbers of interaction rounds in Table~\ref{tab: coder_round_results}. 
Although increasing the number of interaction rounds leads to lower completion rate, the task success and code decision robustness increase significantly, indicating that longer conversations help MASs analyze the code they can accomplish and make more robust decisions.

\begin{table}[t!]
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tabular}{cl|cccc}
        \toprule
        \textbf{\#Round} & \textbf{Scenario} & \textbf{CR} & \textbf{TSR} & \textbf{CWR} & \textbf{CDR} \\
        \midrule
        \multirow{3}{*}{1} & w/o Conflicts & 99.02 & 30.73 & 36.43 & 24.21 \\
                           & Mild Conflicts & \textbf{100.00} & \textbf{46.83} & \textbf{51.11} & \textbf{38.90} \\
                           & Task-Critical Conflicts & 98.78 & 31.22 & 36.81 & 29.33 \\
        \midrule
        \multirow{3}{*}{2} & w/o Conflicts & \textbf{97.92} & 37.55 & 34.90 & 28.49 \\
                           & Mild Conflicts & 86.21 & \textbf{63.45} & \textbf{49.11} & \textbf{63.10} \\
                           & Task-Critical Conflicts & 94.48 & 41.21 & 35.10 & 28.62 \\
        \midrule
        \multirow{3}{*}{3} & w/o Conflicts & \textbf{96.67} & 42.39 & 35.92 & 32.81 \\
                           & Mild Conflicts & 81.40 & \textbf{64.72} & \textbf{45.20} & \textbf{71.97} \\
                           & Task-Critical Conflicts & 94.10 & 45.06 & 35.08 & 31.86 \\
        \bottomrule
    \end{tabular}}
    \caption{Impact of interaction rounds on LLaMA-based MASs robustness under different conflict scenarios}
    \label{tab: coder_round_results}
\end{table}

\section{Conclusion}

In this paper, we systematically examined the robustness of LLM-based when facing various knowledge conflicts. 
Our findings reveal that mild knowledge conflicts stemming from heterogeneous agents may lead to brainstorming among agents, thus surprisingly enhancing collaborative decision-making without compromising robustness. 
Even in cases of task-critical knowledge conflicts, MASs exhibit remarkable resilience, with minimal degradation in performance. 
We further analyze the phenomenon by validating the self-repairing capabilities of MASs, as agents adapt their strategies to bypass the potential conflicts for another solution. 
These insights contribute to a deeper understanding of MAS dynamics and encourage future work to revisit the brainstorming and potential value from knowledge conflicts.

\section*{Limitations}

In this paper, we focus on the knowledge conflicts within the LLM-based multi-agent collaboration programming, with one executor possessing tool-calling capabilities. 
Although this setup facilitates a controllable environment for examining various knowledge conflicts, it does not encompass the full breadth of multi-agent applications such as medical diagnosis, science experiments, or embodied AI. 
We encourage future research to explore more diverse multi-agent tasks and investigate whether the observed phenomena persist under different or more complex agent interaction.

Additionally, we limit our experimental scope to several representative open-source LLMs with specific model sizes (7B to 8B parameters). 
While our findings offer preliminary evidence of the fragility and benefits of knowledge conflicts in these settings, it remains an open question whether larger or closed-source LLMs exhibit similar behaviors. 
We encourage future research to extend these experiments to broader LLM families.

\section*{Ethical Considerations}

Our study systematically investigates how knowledge conflicts in LLM-based MASs can influence collaborative decision-making without introducing additional biases or unsafe content. 
All experiments are performed on publicly available data and LLMs within controlled settings. 
The synthesized knowledge only replaces the programming knowledge with easily confusable content and does not introduce any additional bias. 
Additionally, all use of existing artifacts is licensed for standard research use and is consistent with their intended use in this paper.

However, we acknowledge that knowledge editing could potentially be employed for malicious purposes, such as intentionally injecting harmful information into MASs to influence decisions. 
Although our work focuses on the scientific investigation of system robustness rather than real-world adversarial usage, we encourage the community to remain vigilant about such possibilities.

% \section*{Acknowledgments}

% ...

% Bibliography entries for the entire Anthology, followed by custom entries
%\bibliography{anthology,custom}
% Custom bibliography entries only
\bibliography{custom}

\appendix

\clearpage
\section{Prompts for Multi-Agent Collaborative Programming}
\label{sec: Prompts for Multi-Agent Collaborative Programming}

In this paper, we utilize the AutoGen~\citep{AutoGen} framework to construct the MAS for collaborative programming, which allows for the normal research use. 
Specific system prompts for guiding each agent are detailed below:

\begin{prompt}[title={System Prompt for the Project Manager}]
You are an expert product manager that is creative in coding ideas. Additionally, ensure that the code is complete, runnable, and has "\# filename: <filename>" inside the code blocks as the first line.
\end{prompt}

\begin{prompt}[title={System Prompt for the Coder}]
You are a helpful AI assistant.\\
Solve tasks using your coding and language skills.\\
In the following cases, suggest python code (in a python coding block) or shell script (in a sh coding block) for the user to execute.\\
1. When you need to collect info, use the code to output the info you need, for example, browse or search the web, download/read a file, print the content of a webpage or a file, get the current date/time, check the operating system. After sufficient info is printed and the task is ready to be solved based on your language skill, you can solve the task by yourself.\\
2. When you need to perform some task with code, use the code to perform the task and output the result. Finish the task smartly.\\
Solve the task step by step if you need to. If a plan is not provided, explain your plan first. Be clear which step uses code, and which step uses your language skill.\\
When using code, you must indicate the script type in the code block. The user cannot provide any other feedback or perform any other action beyond executing the code you suggest. The user can't modify your code. So do not suggest incomplete code which requires users to modify. Don't use a code block if it's not intended to be executed by the user.\\
If you want the user to save the code in a file before executing it, put \# filename: <filename> inside the code block as the first line. Don't include multiple code blocks in one response. Do not ask users to copy and paste the result. Instead, use 'print' function for the output when relevant. Check the execution result returned by the user.\\
If the result indicates there is an error, fix the error and output the code again. Suggest the full code instead of partial code or code changes. If the error can't be fixed or if the task is not solved even after the code is executed successfully, analyze the problem, revisit your assumption, collect additional info you need, and think of a different approach to try.\\
When you find an answer, verify the answer carefully. Include verifiable evidence in your response if possible.
\end{prompt}

\begin{prompt}[title={System Prompt for the Executor}]
You are a helpful agent who can run code at a terminal and report back the results.
\end{prompt}

\section{Prompts for Generating Knowledge Conflicts}
\label{sec: Prompts for Generating Knowledge Conflicts}

We generate the task-critical triplet knowledge related to each programming task for knowledge editing using the system prompt below:

\begin{prompt}[title={System Prompt for Generating Knowledge Conflicts}]
You are an exceptional Python knowledge evaluator. Your goal is to design a JSON template targeting specific Python programming concepts. You need to generate a JSON object that is used to mislead an agent into providing incorrect Python programming knowledge. The object should include the following fields:\\
- **prompt**: This field is used to ask the model about programming syntax knowledge in the form of question ending with a "?". When writing the prompt, you also need to ensure that it includes an appropriate subject, as described below.\\
- **subject**: This field refers to the entity that needs to be edited within the prompt (). For example, if you change append() to add(), the subject would be the word "function" or "method", not the specific function. Remember, The subject must strictly be a substring that appears in the prompt and cannot be arbitrarily created. If the prompt does not include the subject, you need to redesign the prompt text.\\
- **ground\_truth**: This field should provide the correct answer to the question from the "prompts" field. Ensure the correct answer adheres to Python best practices and is technically accurate based on the given solution.\\
- **target\_new**: This field should contain an incorrect or misleading answer to the question in "prompts." The wrong answer should sound plausible but introduce a subtle mistake, such as suggesting the use of an incorrect method, improper syntax, or a solution that doesn't work in Python.\\
Ensure all fields are randomly generated and properly formatted. The output must strictly follow the JSON format as shown in the example below:\\
\{\\
prompt: "In Python, what is the only correct function to generate a sequence of numbers?"\\
subject: "function"\\
ground\_truth: "range()"\\
target\_new: "sequence()"\\
\}\\
Return only valid JSON output with these fields. Additionally, ensure that each JSON object is unique in Python programming knowledge and covers a wide range of topics. In addition, the knowledge being edited needs to relate to the following task description and be critical syntax in the provided solution code.
\end{prompt}

\section{Implementation of Knowledge Editing}
\label{sec: Implementation of Knowledge Editing}

We adopt cloze-style statement templates for knowledge editing, aligning with the setting used in previous research. 
For implementation, we utilize the EasyEdit package~\citep{EasyEdit}, which is licensed for standard research purposes. 
Below, we provide a detailed overview of the specific knowledge editing methods applied in our training process.

\paragraph{ROME.} 
Rank-One Model Editing (ROME) \citep{ROME} is a widely recognized method for knowledge localization and editing. 
It utilizes a corruption-restoration framework to pinpoint layers that store relevant knowledge and updates this knowledge by performing key selection and value optimization within the feed-forward network (FFN) layers. 
For LLaMA 3.1 8B Instruct, Qwen 2.5 7B Instruct, and InternLM 7B Chat, edits are all applied at layer 5.
% The second-order momentum statistics are calculated using 100,000 examples from the Wikitext dataset in \texttt{fp32}. Default hyperparameters from \citet{ROME} are used for all other settings.

\paragraph{IKE.} 
In-Context Knowledge Editing (IKE) \citep{IKE} edits the factual knowledge of LLMs without altering its parameters. 
Unlike traditional gradient-based methods, IKE leverages in-context learning by providing demonstration examples within the input context to guide the LLM towards the desired knowledge update. 
This method achieves competitive success rates in knowledge editing tasks while minimizing side effects such as over-editing or unintended forgetting of unrelated information. 
The sentence encoder uses \texttt{all-MiniLM} for calculating the dot score similarity.

\paragraph{MEND.}
Model Editor Networks using Gradient Decomposition (MEND)~\citep{MEND} utilizes a lightweight model editor network to modify the weights of an LLM based on the standard fine-tuning gradient.
To train the editor network, we use the ZsRE dataset \citep{zsre} with 100,000 training steps.
During inference, the learning rate scale is set to 1.0.
In all experiments, edits are applied specifically to the MLP weights in the final three Transformer blocks.

\section{Error Types in Multi-Agent Decision-Making}
\label{sec: error types}
To evaluate the decision-making robustness of our MAS, we classify all errors that arise during code generation and execution based on common Python built-in errors, as well as three additional types capturing failures due to collaboration breakdown and incomplete test coverage. 
We list all types of appeared errors and their descriptions in Table~\ref{tab: python errors}

\begin{table*}[t!]
    \centering
    \begin{tabularx}{\linewidth}{@{}llX@{}}
        \toprule
        \textbf{Error Type} & \textbf{Abbreviation} & \textbf{Description} \\
        \midrule
        CodeMissing & Miss & No code generated due to collaborative failure. \\
        TestSampleError & Sample & The code is able to execute, but the output of at least one test sample does not meet expectations. \\
        UnknownLanguageError & Language & The executor fails to call the Python interpreter because it cannot recognize the language of the generated code. \\
        \midrule
        SyntaxError & Syntax & Invalid syntax detected during parsing. \\
        ZeroDivisionError & ZeroDiv & Division or modulo by zero. \\
        NameError & Name & Use of an uninitialized variable. \\
        TypeError & Type & Operation applied to an inappropriate type. \\
        IndexError & Index & Sequence subscript out of range. \\
        KeyError & Key & Attempt to access a non-existent dictionary key. \\
        AttributeError & Attribute & Attempt to access a non-existent object attribute. \\
        ValueError & Value & Function receives an argument of the correct type but inappropriate value. \\
        FileNotFoundError & File & Fail to find a file or directory. \\
        ImportError & Import & Fail to import a module or its attribute. \\
        OtherError & Other & Other types of errors, such as custom errors defined by the agent using \texttt{assert}. \\
        \bottomrule
    \end{tabularx}
    \caption{Types of common Python built-in errors and collaboration failures encountered during multi-agent collaborative programming.}
    \label{tab: python errors}
\end{table*}

\section{Prompts for Measuring the Self-Repairing Capability of MASs}
\label{sec: Prompts for Measuring the Self-Repairing Capability of MASs}

We use the following prompt to test whether the final code generated by MASs contains the task-critical knowledge in Section~\ref{sec: Can LLM-Based MASs Self-Repair Knowledge Conflicts?}:
\begin{prompt}[title={System Prompt for Measuring the Self-Repairing Capability of MASs}]
You are a professional code analyst. Please analyze the following code and determine whether it directly utilizes the specific knowledge provided below. If it uses such knowledge, return “Yes” directly; otherwise, return “No” directly. Do not provide any additional explanations or comments.
\end{prompt}

\section{Examples of the Self-Repairing Capability of MASs With Task-Critical Knowledge Conflicts}
\label{sec: Examples of the Self-Repairing Capability of MASs With Task-Critical Knowledge Conflicts}

In Table~\ref{tab:self_repair_comparison}, we present the codes with all comments removed from one turn involving Qwen-based MASs before and after knowledge conflicts. 
To comprehensively show the self-repairing capability of MASs in circumventing task-critical knowledge conflicts, we provide the complete codes for five collaborative turns before and after introducing knowledge conflicts by IKE (Table~\ref{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 1)}-\ref{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 5)}). 

Before introducing knowledge conflicts, the MASs tend to use the simple and effective Python built-in function \texttt{append()} in all five turns (Table~\ref{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 1)}-~\ref{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 5)}). 
After introducing the knowledge conflict regarding the \texttt{append()} function using IKE, the MASs only use \texttt{append()} in only two out of five turns (Table~\ref{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 3)},~\ref{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 4)}), indicating that MASs exhibit a certain level of self-repairing capability when facing knowledge conflicts in complex scenarios.

\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/o Conflicts (Turn 1)} & 
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0: return 0}\\
\texttt{\ \ if n == 1: return 0}\\
\texttt{\ \ if n == 2: return 2}\\
\texttt{\ \ if n == 3: return 0}\\
\\
\texttt{\ \ \# Initialize the base cases}\\
\texttt{\ \ fib = [0, 0, 2, 0]}\\
\\
\texttt{\ \ \# Compute the sequence iteratively}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ fib.\textbf{append}(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])}\\
\\
\texttt{\ \ return fib[n]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 1).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 1)}
\end{table*}

% ———————— Table 2 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/o Conflicts (Turn 2)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibbonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0: return 0}\\
\texttt{\ \ if n == 1: return 0}\\
\texttt{\ \ if n == 2: return 2}\\
\texttt{\ \ if n == 3: return 0}\\
\\
\texttt{\ \ \# Initialize the base cases}\\
\texttt{\ \ fib\_values = [0, 0, 2, 0]}\\
\\
\texttt{\ \ \# Compute the fib4 values for n > 3}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ fib\_values.\textbf{append}(fib\_values[i - 1] + fib\_values[i - 2] + fib\_values[i - 3] + fib\_values[i - 4])}\\
\\
\texttt{\ \ return fib\_values[n]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 2).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 2)}
\end{table*}

% ———————— Table 3 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/o Conflicts (Turn 3)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 1:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 2:}\\
\texttt{\ \ \ \ return 2}\\
\texttt{\ \ elif n == 3:}\\
\texttt{\ \ \ \ return 0}\\
\\
\texttt{\ \ \# Initialize the first four values of the sequence}\\
\texttt{\ \ sequence = [0, 0, 2, 0]}\\
\\
\texttt{\ \ \# Compute the sequence up to n}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ next\_value = sequence[i - 1] + sequence[i - 2] + sequence[i - 3] + sequence[i - 4]}\\
\texttt{\ \ \ \ sequence.\textbf{append}(next\_value)}\\
\\
\texttt{\ \ return sequence[n]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 3).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 3)}
\end{table*}

% ———————— Table 4 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/o Conflicts (Turn 4)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.}\\
\texttt{}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 1:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 2:}\\
\texttt{\ \ \ \ return 2}\\
\texttt{\ \ elif n == 3:}\\
\texttt{\ \ \ \ return 0}\\
\\
\texttt{\ \ \# Initialize the base cases}\\
\texttt{\ \ fib4\_sequence = [0, 0, 2, 0]}\\
\\
\texttt{\ \ \# Compute fib4(n) iteratively}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ fib4\_sequence.\textbf{append}(fib4\_sequence[i - 1] + fib4\_sequence[i - 2] + fib4\_sequence[i - 3] + fib4\_sequence[i - 4])}\\
\\
\texttt{\ \ return fib4\_sequence[n]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 4).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 4)}
\end{table*}

% ———————— Table 5 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/o Conflicts (Turn 5)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0 or n == 1:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ if n == 2:}\\
\texttt{\ \ \ \ return 2}\\
\texttt{\ \ if n == 3:}\\
\texttt{\ \ \ \ return 0}\\
\\
\texttt{\ \ \# Initialize the base cases}\\
\texttt{\ \ fib\_values = [0, 0, 2, 0]}\\
\\
\texttt{\ \ \# Compute the values up to n}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ fib\_values.\textbf{append}(fib\_values[i - 1] + fib\_values[i - 2] + fib\_values[i - 3] + fib\_values[i - 4])}\\
\\
\texttt{\ \ return fib\_values[n]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 5).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming without knowledge conflicts (Turn 5)}
\end{table*}

% ———————— Table 6 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/ Conflicts (Turn 1)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0 or n == 1:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ if n == 2:}\\
\texttt{\ \ \ \ return 2}\\
\texttt{\ \ if n == 3:}\\
\texttt{\ \ \ \ return 0}\\
\\
\texttt{\ \ \# Initialize the base cases}\\
\texttt{\ \ fib4\_values = [0, 0, 2, 0]}\\
\\
\texttt{\ \ \# Compute the values iteratively}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ next\_value = sum(fib4\_values)}\\
\texttt{\ \ \ \ fib4\_values = [fib4\_values[1], fib4\_values[2], fib4\_values[3], next\_value]}\\
\\
\texttt{\ \ return fib4\_values[-1]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts: \texttt{append() $\rightarrow$ add()} (Turn 1).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 1)}
\end{table*}

% ———————— Table 7 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/ Conflicts (Turn 2)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0: return 0}\\
\texttt{\ \ if n == 1: return 0}\\
\texttt{\ \ if n == 2: return 2}\\
\texttt{\ \ if n == 3: return 0}\\
\\
\texttt{\ \ \# Initialize the base cases}\\
\texttt{\ \ a, b, c, d = 0, 0, 2, 0}\\
\\
\texttt{\ \ \# Compute the n-th element iteratively}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ a, b, c, d = b, c, d, a + b + c + d}\\
\\
\texttt{\ \ return d}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts: \texttt{append() $\rightarrow$ add()} (Turn 2).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 2)}
\end{table*}

% ———————— Table 8 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/ Conflicts (Turn 3)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence.  Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 1:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 2:}\\
\texttt{\ \ \ \ return 2}\\
\texttt{\ \ elif n == 3:}\\
\texttt{\ \ \ \ return 0}\\
\\
\texttt{\ \ \# Initialize the base cases}\\
\texttt{\ \ fib = [0, 0, 2, 0]}\\
\\
\texttt{\ \ \# Compute the n-th element iteratively}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ fib.\textbf{append}(fib[i - 1] + fib[i - 2] + fib[i - 3] + fib[i - 4])}\\
\\
\texttt{\ \ return fib[n]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts: \texttt{append() $\rightarrow$ add()} (Turn 3).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 3)}
\end{table*}

% ———————— Table 9 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/ Conflicts (Turn 4)} &
\makecell[l]{
\texttt{\# Import the run\_tests function from my\_tests}\\
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{\# Define the fib4 function}\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 1:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ elif n == 2:}\\
\texttt{\ \ \ \ return 2}\\
\texttt{\ \ elif n == 3:}\\
\texttt{\ \ \ \ return 0}\\
\texttt{\ \ else:}\\
\texttt{\ \ \ \ \# Initialize the base cases}\\
\texttt{\ \ \ \ dp = [0, 0, 2, 0]}\\
\texttt{\ \ \ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ \ \ dp.\textbf{append}(dp[i - 1] + dp[i - 2] + dp[i - 3] + dp[i - 4])}\\
\texttt{\ \ \ \ return dp[n]}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts: \texttt{append() $\rightarrow$ add()} (Turn 4).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 4)}
\end{table*}

% ———————— Table 10 ————————
\begin{table*}[ht]
\centering
\resizebox{\linewidth}{!}{
\setlength{\tabcolsep}{3pt}
\begin{tabular}{l}
\toprule
% \textbf{w/ Conflicts (Turn 5)} &
\makecell[l]{
\texttt{from my\_tests import run\_tests}\\
\\
\texttt{def fib4(n: int):}\\
\texttt{\ \ """The Fib4 number sequence is a sequence similar to the Fibonacci sequence that's defined as follows:}\\
\texttt{\ \ fib4(0) -> 0}\\
\texttt{\ \ fib4(1) -> 0}\\
\texttt{\ \ fib4(2) -> 2}\\
\texttt{\ \ fib4(3) -> 0}\\
\texttt{\ \ fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).}\\
\texttt{\ \ Please write a function to efficiently compute the n-th element of the fib4 number sequence. Do not use recursion.}\\
\texttt{\ \ >>> fib4(5)}\\
\texttt{\ \ 4}\\
\texttt{\ \ >>> fib4(6)}\\
\texttt{\ \ 8}\\
\texttt{\ \ >>> fib4(7)}\\
\texttt{\ \ 14}\\
\texttt{\ \ """}\\
\texttt{\ \ if n == 0: return 0}\\
\texttt{\ \ if n == 1: return 0}\\
\texttt{\ \ if n == 2: return 2}\\
\texttt{\ \ if n == 3: return 0}\\
\\
\texttt{\ \ \# Initialize the first four numbers of the sequence}\\
\texttt{\ \ a, b, c, d = 0, 0, 2, 0}\\
\\
\texttt{\ \ \# Compute the n-th element iteratively}\\
\texttt{\ \ for i in range(4, n + 1):}\\
\texttt{\ \ \ \ a, b, c, d = b, c, d, a + b + c + d}\\
\\
\texttt{\ \ return d}\\
\\
\texttt{\# Run the unit tests}\\
\texttt{run\_tests(fib4)}
}
\\
\bottomrule
\end{tabular}}
\caption{Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts: \texttt{append() $\rightarrow$ add()} (Turn 5).}
\label{tab: Illustrative example of Qwen-Based MASs for collaborative programming with knowledge conflicts (Turn 5)}
\end{table*}

% \section{Further Discussion}

% Prior studies highlighting the catastrophic impact of knowledge conflicts often perform under adversarial risk scenarios, where an attacker explicitly or implicitly manipulates specific agents to spread erroneous knowledge through prompt engineering~\citep{agent_smith} or parameter editing~\citep{flooding_spread}. 
% These methods enforce persistent belief alignment in the manipulated agent by attackers' prompt or direct preference optimization~\citep{DPO}. 
% Furthermore, these studies focus on dialogue-centric tasks, where problem-solving paths are always unique. 

% Our study examines the robustness of complex MASs with tool-calling capabilities when facing spontaneously arising knowledge conflicts. 
% The editing of task-critical knowledge is merely intended to simulate errors caused by an agent within the system receiving incorrect training data, rather than being manipulated by an attacker. 
% In this scenario, MASs demonstrate self-repairing capabilities more than expected, revealing the underrated role of knowledge conflicts in MAS brainstorming.


\end{document}
