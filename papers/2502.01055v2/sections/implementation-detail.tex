\section{\crisp: Implementation}
\label{sec:implementation}

\textbf{User interface.}
\crisp follows the general nonlinear programming problem formulation in~\eqref{eq:problem_general} where the user defines the objective function and constraints. Our implementation builds upon the fundamental data types in Eigen3 (vectors and matrices), wrapped with CPPAD~\cite{cppad} and CPPAD Code Generation (CG)~\cite{cppadcg}. This architecture allows users to define problems in an Eigen-style syntax, specifying objectives and constraints (both equality and inequality) while leveraging CPPAD for automatic derivative computation.
The solver utilizes CPPAD to automatically obtain derivative information, while CG is employed to generate and store an auto-diff library. This library can be dynamically loaded for efficient evaluation of gradients and Hessians at specified points, significantly reducing computational overhead in subsequent solves. Besides, our implementation supports both parameterized and non-parameterized function definitions, allowing real-time modification of problem parameters (e.g., reference, terminal, or initial states) without the need to regenerate the library.


\textbf{QP solver.}
The key subroutine in \crisp is to solve the convex trust-region QPs. After careful comparison and experimentation with several QP solvers in \crisp, including \scenario{OSQP}~\cite{osqp}, \scenario{PROXQP}~\cite{proxqp}, \scenario{qpOASE}~\cite{qpOASES}, and \scenario{PIQP}~\cite{schwan2023piqp}, we integrate \scenario{PIQP}, an interior-point method-based QP solver with embedded sparse matrix operations, which strikes an excellent balance of accuracy and real-time performance.
To optimize the construction of the QP subproblems~\eqref{eq:subproblem-smooth}, we perform memory-level operations for extracting, copying, and concatenating large-scale sparse matrices, bypassing the Eigen3 higher-level interfaces. This approach enhances the efficiency of sparse matrix operations that are crucial for complex robot motion planning problems.

To enhance usability, we also implement a Python interface using Pybind11. This interface allows users to adjust problem parameters and solver hyperparameters, solve and re-solve problems, and extract results within a Python environment, providing flexibility for downstream applications.
\input{sections/alg-crisp.tex}
\begin{table}[ht]
    \centering
    \caption{Definition of Hyperparameters in \scenario{CRISP}}
    \begin{tabular}{ cc }
    \toprule[1pt]
    \textbf{Paramaters} & \textbf{Descriptions}\\
    \midrule
    $k_{max}$ & max iteration numbers: 1000 \\
    $\Delta_0$ & initial trust region radius: 1\\
    $\Delta_{max}$ & max trust region radius: 10\\
    $\mu_0$ & initial penalty: 10\\
    $\mu_{max}$ & max penalty: $1e^6$\\
    $\eta_{low}$ & reduction ratio lower bound: 0.25\\
    $\eta_{high}$ & reduction ratio upper bound: 0.75\\
    $\gamma_{shrink}$ & trust region shrink factor: 0.25\\
    $\gamma_{expand}$ & trust region expand factor: 2\\
    $\epsilon_c$ & tolerance of constraint violation: $1e^6$\\
    $\epsilon_p$ & tolerance of trial step norm: $1e^{-3}$\\
    $\epsilon_r$ & tolerance of trust region radius: $1e^{-3}$\\ 
    \bottomrule[1pt]
    \end{tabular}
    \label{tab:hyperparameters}
\end{table}
\begin{remark}[First-order QP Solver]\label{remark:fom_qp}
    There are growing interests in robotics to leverage first-order QP solvers (e.g., building upon ADMM~\cite{stellato20mpc-osqp} and PDHG~\cite{lu2023practical}) for large-scale motion planning. While first-order QP solvers are typically more scalable due to cheap per-iteration cost, recent work~\cite{khazoom2024tailoring} has shown that insufficient solution quality caused by first-order QP solvers may hurt motion planning. For this reason, \crisp chose the interior-point solver PIQP to make sure the inner QPs are solved to sufficient accuracy. However, we do note that \crisp is built in a modular way such that users can switch between different QP solvers. 
\end{remark}

% This comprehensive implementation strategy significantly enhances the capability of \crisp to handle large-scale, complex robot motion planning problems efficiently. The combination of automatic differentiation, code generation, optimized sparse matrix operations, and a high-performance QP solver contributes to both the solver's accuracy and its real-time performance, making it well-suited for challenging robotics applications.