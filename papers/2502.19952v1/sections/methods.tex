
\section{Methods}

In this section, we present in detail how our collaborative AML algorithm, named collaborative scatter-gather mining (CSGM), is designed. We begin by transforming the centralized scatter-gather mining method into the one that can be applied to two subgraphs as defined in Section~\ref{sec: problem_statement} owned by different institutions.
The method enables the detection of money laundering nodes distributed across multiple institutions, particularly when the source and destination nodes belong to different institutions.

We further enhance the method by making use of Locality-sensitive hashing (LSH)~\cite{lsh} and Bloom filter~\cite{bloomfilter} to minimize communication costs and improve efficiency. Figure~\ref{fig:workflow} presents the workflow of CSGM.
% Furthermore, we integrate the Bloom filter into the MinHash algorithm. This optimization strikes a balance between efficiency and utility, allowing us to achieve effective money laundering group detection while minimizing computational complexity.




\subsection{Collaborative Scatter-Gather Mining}
% We model the transaction graph of money laundering activities as a tripartite graph~\cite{li2020flowscope},
In the scatter-gather pattern of money laundering,  money is transferred from a source to a destination through multiple transactions involving many adversarial middle nodes. 
When the source and the destination are located in different institutions, it implies that money laundering activities transfer money to another institution via cross-institution transactions, as shown in Figure~\ref{fig: topology2}.
% , the money is first divided into smaller amounts, transferred to another institution separately, and finally aggregated by the destination within that institution.
% Institutions are responsible for knowing the two nodes involved in a transaction to comply with Know Your Customer (KYC) standards, as long as one of the nodes is under their jurisdiction. For instance, consider two institutions $\Cli_p$ and $\Cli_q$, where node $i$ in $\Cli_p$ has a transaction with node $j$ in $\Cli_q$. The KYC standards allow $\Cli_p$ to be aware of node $j$, even though it is not directly registered under $\Cli_p$. Similarly, $\Cli_q$ also has the responsibility to know about node $i$. Therefore, cross-institution transactions are recorded in both $\Cli_p$ and $\Cli_q$.

The key idea behind our method is that the set of cross-institution transactions scattered from the source is identical to the set of cross-institution transactions gathered at the destination when the source and destination are involved in the same money laundering subgraph. Therefore, by comparing the sets of transactions identified by both institutions, we can effectively detect money laundering subgraphs in which both source and destination are implicated.


% We refer $\mathcal{S}_p\leftarrow [S_i | \forall i\in\mathcal{V}_p]$ and $\mathcal{D}_p\leftarrow [D_i | \forall i\in\mathcal{V}_p]$, $p\in [A, B]$ all sets 


% In practical implementation, since the source and the destination are not known, each institution finds the sets $S$ and $R$ for all inner nodes (nodes in $\mathcal{I}$) and sends the results to another institution. Denote $\mathcal{S}_p$ as a list of sets, where each set is obtained by tracing on the local subgraph $\mathcal{G}_p$. Specifically, $\mathcal{S}_p\leftarrow [S_i | \forall i\in\mathcal{I}_p]$, where $\mathcal{I}_p$ denotes the inner nodes of institution $\Cli_p$. Similarly, $\mathcal{D}_p\leftarrow [R_i| \forall i\in\mathcal{I}_p]$.

% As the source and destination within one money laundering subgraph are distributed in different institutions, institutions are required to transmit all transaction sets to each other. 

Specifically, let $\mathcal{S}_p \leftarrow [S_i \mid i \in \mathcal{V}_p]$ and $\mathcal{D}_p \leftarrow [D_i \mid i \in \mathcal{V}_p]$ for \(p \in \{A, B\}\) denote the sets of all cross-institution transactions associated with $\Cli_p$, where $S_i$ and $D_i$ represent the sets obtained through scattering from or gathering to node $i$, respectively. $\Cli_p$ transmits both $\mathcal{S}_p$ and $\mathcal{D}_p$ to institution $\Cli_q$, ensuring that both $\Cli_A$ and $\Cli_B$ possess all relevant sets.
By independently comparing the similarity between any two sets $S_i \in \mathcal{S}_p$ and $D_j \in \mathcal{D}_q$, each institution can identify sources or destinations involved in money laundering activities. Specifically, $\Cli_p$ can detect sources by comparing sets from $\mathcal{S}_p$ with those from $\mathcal{D}_q$, and similarly, identify destinations by comparing sets from $\mathcal{D}_p$ with those from $\mathcal{S}_q$. Note that we filter out the discovered sets of small size (setting the threshold to 4-7 in our experiments), considering that money laundering groups are typically huge to conceal substantial amounts of money.
Once all suspicious sources and destinations are identified, intermediate nodes can be readily located by tracing the transactions that are scattered from sources or gathered to destinations within the local subgraph.



\Paragraph{Cross-institution Transaction Set Discovery.}
To find the set of cross-institution transactions, each institution employs the BFS approach for each node to find transactions scattered or gathered from the node and determine if they are cross-institution transactions. 
Specifically, it starts from a specific node and loops all neighbor nodes to identify cross-institution transactions originating from the node until either all relevant transactions are found or the maximum depth is reached.
Let $\mathcal{F}$ represent the algorithm, and we denote the discovery process as $S_i\leftarrow \mathcal{F}(i, \mathcal{G}, T)$.
Here, $S_i$ is the set of cross-institution transactions scattered from node $i$, $\mathcal{G}$ is the local transaction graph, and $T$ denotes the maximum depth allowed.
% In situations where we discover the set of cross-institution transactions gathered from one specific node,
When aiming to discover the gathered transaction sets,
we can simply transform $\mathcal{G}$ into a new graph $\mathcal{G}'$ with the inverse direction. Specifically, $\mathcal{G}'= (\mathcal{V}, \mathcal{E}', \mathcal{X})$, where $\mathcal{E}' = \{(j, i)| \left(i, j\right)\in \mathcal{E}\}$. By performing the same algorithm on $\mathcal{G}'$, we construct the reversed transaction set as $D_i \leftarrow \mathcal{F}(i, \mathcal{G}', T)$. 
% The transactions in $D_i$ are reversed back in default to ensure that the same transactions as in $S_i$ have a common representation.
Algorithm~\ref{alg:set_discovery} in Appendix presents the procedure. 
% The pseudo-code of discovering cross-institution transaction sets is presented in Algorithm~\ref{alg: naive_distribute_MLSD}. 




\subsection{Optimization for Distributed Scatter-Gather Mining}
Applying the distributed scatter-gather mining algorithm directly is both communication- and computation-intensive, as it requires institutions to exchange multiple transaction sets ($\mathcal{O}(n)$, where $n$ is the number of nodes) and perform pairwise comparisons among them, which is $\mathcal{O}(n^2)$. To address the challenge, we propose an optimized algorithm using LSH~\cite{lsh} and Bloom filters~\cite{bloomfilter}. LSH enables the estimation of similarity between two sets by comparing the minimum hash values of their elements, and by inserting the results of all sets (either from $\mathcal{S}$ or $\mathcal{D}$) into a bloom filter, we transform pairwise comparisons into a more efficient process of testing whether an element exists within the Bloom filter.
% based on a key observation: it is only necessary to detect the \textit{presence} of another set highly similar to the transaction set of the node, without needing to identify what that set is.
% To implement, we employ  

Specifically, institution $\Cli_p$ first performs LSH on all sets. The results are then inserted into $K$ Bloom filters, where $K$ is determined by the length of the LSH value. 
The Bloom filters are then shared with another institution, $\Cli_q$. By querying the Bloom filter with the LSH of $\Cli_q$'s local set, which is likely to match those of other sets with high similarity, $\Cli_q$ can efficiently detect the existence of a similar set, thereby determining whether the corresponding node is involved in potential money laundering activities.  As it requires only the transfer of Bloom filters, the optimization significantly reduces communication overhead, Moreover, the computational complexity is reduced to $\mathcal{O}(Kn), k<<n$, as opposed to $\mathcal{O}(n^2)$ when performing pairwise comparisons.

Next, we provide a detailed explanation of how sets are inserted into Bloom filters. We then introduce two methods, namely Probability-Based Similar Set Detection and Similarity-Based Similar Set Detection, to detect similar sets using Bloom filters.

\begin{figure}[t]
\begin{center}
\centerline{
    \includegraphics[width=\linewidth]{figures/insert_sets.pdf}}
\caption{Example of inserting transaction sets into Bloom filters. We consider three sets $S_1$, $S_2$, and $S_3$ and 6 MinHash functions. The band width $r=2$ }
\label{fig:bloom_filter}
\end{center}
\end{figure}

% The key idea is that instead of directly estimating the similarity between two sets, we focus on detecting the presence of another set that exhibits high similarity to a given set. This information is sufficient to determine whether the corresponding node of the given set is involved as the source/destination in money laundering activities.

% Inspired by the idea, we optimize the algorithm by first computing the LSH of each set, which is likely to be identical for two similar sets. We then insert these LSH results into a Bloom filter, which is subsequently shared with another institution. By querying the Bloom filter with the LSH of their local set, institutions can efficiently detect the existence of a similar set, hence determining whether the corresponding node is involved in potential money laundering activities.

% Moreover, directly transmitting transaction sets potentially reveals transactional relationships among nodes within the same set, posing privacy risks. 


\subsubsection{Inserting sets into Bloom filters.}
We adopt the MinHash algorithm (cf. Section~\ref{ssec: minhash}) as the approach to implement LSH.
Take $\mathcal{S}^p$ as an example, $\Cli_p$ first employs $m$ distinct minhash functions $H$ (cf. Equation~\ref{equ: minhash}) on each set $S_i\in \mathcal{S}_p$
resulting in a signature matrix $M_S^p$ with $m$ rows and $|\mathcal{S}^p|$ columns, where $|\cdot|$ denotes the number of sets in $\mathcal{S}_p$. Each row of the matrix represents applying the same minhash function to all sets in $\mathcal{S}_p$, and each column represents applying all minhash functions to the same set.

A banding technique then be applied to the matrix. Specifically, we divide the matrix into bands, each containing $r$ rows of the matrix, resulting in a total of $K=m/r$ bands. Each column of a band, which is composed of the result of applying  $r$ minhash functions to one set, can be treated as a result of applying LSH on the set. If two sets have the Jaccard similarity of $s$, then the probability that their columns within the same band are equal is $s^r$. By mapping each column to a distinctive signature, for example, by utilizing the MD5 function~\cite{md5}, each band can be treated as one row of the banding matrix. We denote it as $B_S^p$.
We then insert each band into a Bloom filter (cf. Section~\ref{ssec: bloomfilter}), resulting in $K$ Bloom filters $BF_S^p[1], ..., BF_S^p[K]$. When the context is clear, we omit the superscripts and
subscripts, and represent each Bloom filter as $BF_k, k \in \{1,...,K\}$.


We note that to guarantee the LSH of two similar sets are equal with high probability, $\Cli_p$ and $\Cli_q$ are required to use the same MinHash functions on $\mathcal{S}_p$ and $\mathcal{D}_q$.
Figure~\ref{fig:bloom_filter} presents an example of inserting three sets $S_1$, $S_2$, and $S_3$ into three Bloom filters, with the band with $r=2$.


% We assign the label $\mathcal{BS}_k$ to represent the $k$-th band of the matrix $\mathcal{MS}$, while $\mathcal{BD}_k$ denotes the $k$-th band of the matrix $\mathcal{MD}$. 
% Without loss of generality, we assume that each column of the band has been mapped to a distinct signature, resulting in the band itself being represented as a list.




% We refer the $k$-th row of $\mathcal{MS}$ to $\mathcal{HS}_k^\top$, $\mathcal{HS}_k^\top=[H_k(S_i) |S_i \in \mathcal{S}]$.
% Similarly, we denote $\mathcal{MD}$ as the matrix resulting from applying the same $m$ minhash functions on $\mathcal{D}$.
% , and represent each row as $\mathcal{HD}_k^\top$.


% Given matrices $\mathcal{MS}$ and $\mathcal{MD}$, comparing their elements is equivalent to finding the Jaccard similarity between two sets. Specifically, to estimate the Jaccard similarity between $S_i\in\mathcal{S}$ and $D_j\in\mathcal{D}$, one can simply count the number of rows that $\mathcal{MS}_{ki}$ equal to $\mathcal{MR}_{kj}$, where the subscript represents the $i$-th ($j$-th) element in the $k$-th row, and then divide this by $m$. With the 
% Moreover, the banding technique (cf. Section~\ref{ssec: minhash}) can be employed on the matrix to identify similar sets by comparing within each band. Further details regarding this technique will be provided later when we integrate it with the Bloom filter.
% one can also adopt the banding technique upon the matrix and find similar sets by comparing within the band. The details will show later when we integrate it with the Bloom filter.
% Our chosen hash function, $H$, ensures a uniform distribution of output, eliminating the need to permute all elements within the set. 
% It is important to note that institutions must adopt identical predetermined hash functions and utilize the same seed to ensure consistency in the hashing process.


% In order to estimate the similarity between any two sets from $\mathcal{S}_p$ and $\mathcal{D}_q$, both institutions adopt an identical hash function for all sets. Consequently, we obtain $\mathcal{HS}=[h_S |S \in \mathcal{S}]$ and $\mathcal{HD}=[h_R | R \in \mathcal{D}]$. Let $r_{ij}$ denote a random variable that takes the value 1 when $H(\mathcal{S}_p[i])=H(\mathcal{D}_q[j])$, and 0 otherwise. Here, $\mathcal{S}_p[i]$ refers to the $i$-th set in $\mathcal{S}_p$, and $\mathcal{D}_q[j]$ corresponds to the $j$-th set in $\mathcal{D}_q$. With this, we can express $r_{ij} = \mathbb{1}[\mathcal{HS}_i[u]=\mathcal{HD}_j[v]]$, where $\mathcal{HS}_p[i]$ denotes the $i$-th element in $\mathcal{HS}_p$, and $\mathcal{HD}_q[j]$ represents the $j$-th element in $\mathcal{HD}_q$.
% In practice, we adopt $K_m$ hash functions. The similarity between $S_i\in\mathcal{S}_p$ and $D_j\in\mathcal{D}_q$ is estimated as $J(S_i, D_j)=\sum_{m=1}^{M}r_{ij}^m/M$. Since $r_{ij}$ is unbiased, the estimate is also unbiased.


% \subsubsection{Bloom Filter Enhancement}
% Sharing the matrices $\mathcal{MS}$ and $\mathcal{MD}$ directly incurs substantial communication costs. To address this issue, we employ Bloom filters as a solution. Next, we first outline the utilization of the Bloom filter technique and show how to incorporate it into MinHash and LSH.

% Sharing the matrices $\mathcal{MS}$ and $\mathcal{MD}$ directly poses significant communication costs. To address this issue, we employ Bloom filters as a solution. We next present the utilization of Bloom filters in conjunction with MinHash and LSH. This approach minimizes the impact on performance.
% Specifically, each institution first applies the banding technique to the signature matrices $\mathcal{MS}$ and $\mathcal{MD}$. This involves dividing the matrices into bands, with the width of each band set to $r$, resulting in a total of $M/r$ bands. 
% To establish uniqueness within each band, we can map every column to a distinctive signature, e.g., utilizing the MD5 function~\cite{md5} to each column. Consequently, each band can be treated as a list, which is then inserted into a Bloom filter by the institution. This Bloom filter can then be transmitted to another institution.
% Each column of a band can be mapped to a unique signature, e.g., using the MD5 function~\cite{}. 
% After that, each band can be treated as a list; the institution inserts the list into a Bloom filter and sends it to another institution. 
% We assign the label $\mathcal{BS}_k$ to represent the $k$-th band of the matrix $\mathcal{MS}$, while $\mathcal{BD}_k$ denotes the $k$-th band of the matrix $\mathcal{MD}$. 
% Without loss of generality, we assume that each column of the band has been mapped to a distinct signature, resulting in the band itself being represented as a list.
% Furthermore, we utilize the notation $BL(\mathcal{BS}_k)$ and $BL(\mathcal{BD}_k)$ to denote the respective Bloom filters that store $\mathcal{BS}_k$ and $\mathcal{BD}_k$.

% to store $\mathcal{HS}$ and $\mathcal{HD}$ to reduce communication costs. In more detail, each $\mathcal{HS}^k$ and $\mathcal{HD}^k$, computed using the $k$-th hash function, are inserted into their respective Bloom filters. Consequently, for the transmission of $\mathcal{S}$ and $\mathcal{D}$ from one institution to another, a total of $2K_m$ Bloom filters are required. We denote the Bloom filter that stores $\mathcal{HS}$ as $BF(\mathcal{HS})$ and the one storing $\mathcal{HD}$ as $BF(\mathcal{HD})$.

\subsubsection{Probability-based similar set detection.}
With the received Bloom filters, institutions can detect whether the node is involved in money laundering activities by querying the existence of the band values in corresponding Bloom filters. Specifically, for a set $S_i \in \mathcal{S}^p$, denote its band values as $B_{i}$, which are a column in the banding matrix. $\Cli_p$ query the existence of each $B_{ki}$ in the corresponding Bloom filter $BF_k$. Theoretically, if there exists a set $D_j \in \mathcal{D}^q$ that exhibits a similarity of \(s\) with \(S_i\), the probability that at least one Bloom filter contains $B_{ki}$ is:
\begin{equation}
\label{fun:prob}
1 - (1 - s^r)^{K},    
\end{equation}
where $K=m/r$. As shown in Figure~\ref{fig:f_exlaination}, by appropriately selecting values for $m$ and $r$, this probability can be adjusted to be close to 1 or 0, depending on the level of similarity. For example, when the threshold is $0.4$, we set $r=4$ and $m=400$ so the probability is about $0.92$.
Consequently, if at least one $B_{ki}$ tested exists in $BF_k$, we treat the corresponding node of $S_i$ as a potential source within a money laundering subgroup.

\begin{figure}[t]
\begin{center}
\centerline{
    \includegraphics[width=0.85\linewidth]{figures/function.png}}
\caption{The probability calculated with Equation~\ref{fun:prob} with different $r$ and $m$.}
\label{fig:f_exlaination}
\end{center}
\end{figure}

% The same procedure can be applied to detect the destination in \(\mathcal{D}^p\) by querying the Bloom filter $BF_S^q$.
With the probability-based similar set detection, we denote our AML method as \textbf{Prob-CSGM} and Algorithm~\ref{alg: IsMoneyLaunderingProb} presents the pseudo-code of the method.

\begin{algorithm}[htb]
\caption{IsSimilarSetProb}
\label{alg: IsMoneyLaunderingProb}
\small
\KwIn{$S_i$, $BF_k, k\in\{1,...,K\}$} 
\KwOut {$h$, $h=1$ indicates the set is a similar set}
\BlankLine
$h=0$\\
\For{$k \in \{1,...,K\}$}{
    $B_{ki}\leftarrow \operatorname{BANDING}(\{H_t(S)|t\in[(k-1)r, kr]\})$\\
    \If{$B_{ki} \in BF_k)$}{
    $h=1$\\
    break
    }
}
    \Return{h}

\end{algorithm}





% To determine if the source node of a set $S_i\in\mathcal{S}^p$ in institution $p$ is the source in an money laundering group, we examine whether there exists a set $D_j\in\mathcal{D}^q$ in institution $q$, such that for each $\mathcal{HRC}^k[j]$ corresponding to $D_j$, at least one of them matches with $\mathcal{HSC}^k[i]$, $k\in[M/t]$. It is worth noting that for the sake of simplicity, we refer to $\mathcal{HRC}^k$ in our presentation, although $\Cli_p$ does not have direct access to it. The previously presented Theorem~\ref{thm: bloom_filter} demonstrates that analyzing on $\mathcal{HSC}^k$ or $BL(\mathcal{HSC}^k)$ yields equivalent results.

% Theoretically, for any $k\in[M/t]$, 
% \begin{equation}
%     Pr[\mathcal{HSC}^k[i]]=\mathcal{HRC}^k[j]]=(\frac{|S_i\cap D_j|}{|S_i\cup D_j|})^t.
% \end{equation} 
% The probability of having at least one match between $\mathcal{HSC}^k[i]$ and $\mathcal{HRC}^j[j], k,l\in[M/t]$ can be calculated as $1-(1-(|S_i\cap D_j|/|S_i\cup D_j|)^t)^{\frac{M}{t}}$. When $\frac{|S_i\cap D_j|}{|S_i\cup D_j|}$ is, for example, 0.7, $t=5$, and $M=100$, the probability is 97.48\%, and it increases as $\frac{|S_i\cap S_j|}{|S_i\cup S_j|}$ increases. By appropriately selecting values for $t$ and $m$, it is possible to identify $D_j$ that matches $S_i$ with a predefined level of similarity.


\subsubsection{Similarity-based similar set detection} 
While the probability-based method enables the detection of source/destination nodes involved in money laundering activities, it suffers from a high false positive rate, as dissimilar sets may still be detected in at least one Bloom filter. Conversely, even when the threshold is increased, there remains a possibility that similar sets may go undetected.
To address this limitation, we propose an alternative approach to estimate the similarity directly.

Recall that each institution divides the signature metrics $M$ into $K$ bands. The probability that any two columns within a band are identical is given by $s^r$, where $s$ is the similarity we aim to estimate. A straightforward approach is setting $r = 1$ and estimating the similarity by calculating the ratio of Bloom filters that contain the band value of the transaction set to the total number of Bloom filters.
Formally, let $t_i$ be a random variable that equals 1 if $B_{ki}$ is present in the $k$-th Bloom filter $BF_k$ and 0 otherwise. The estimated Jaccard similarity is then given by $\frac{1}{m} \sum_{k=1}^{K} t_i$.
A set $S_i$ is flagged as a money laundering set if this estimated similarity exceeds a predefined threshold $\tau$.

However, applying the above method introduces significant bias in the similarity estimation. This bias occurs because a Bloom filter stores hash values from all sets 
$D \in \mathcal{D}$, and multiple sets may share overlapping elements with $S_i$. As a result, this overlap leads to an overestimation of similarity, as the Bloom filter cannot differentiate between the contributions of different sets that share elements with $S_i$.
Specifically, assume that sets $D_1, \dots, D_Q \in \mathcal{D}$ have overlapping elements with $S_i$, such that $J(S_i, D_q) > 0$ for $q \in \{1,...,Q\}$. Let $A_q$ denote the event that $B_i^S = B_q^D$. The probability of this event occurring is given by $\Pr(A_q) = \frac{|S_i \cap D_q|}{|S_i \cup D_q|}$, which is the Jaccard similarity between $S_i$ and $D_q$.
Let $z$ be a random variable that equals 1 if $B_i^S$ is detected in the Bloom filter and 0 otherwise, we have
\begin{equation}
\begin{aligned}
    % Pr[r_{ij}=1] &= \frac{|S_i \cap D_j|}{|S_i \cup D_j|},\\
    Pr[z=1] &= Pr(\bigcup_{k=1}^K A_k)\\
                &=S_1-S_2+\cdots+(-1)^{n-1} S_n\\
                &\leqslant \min \left\{S_1, 1\right\}
\end{aligned}
\end{equation}
where $S_k=\sum_{1 \leqslant i_1<\cdots<i_k \leqslant n} P\left(A_{i_1} \cap \cdots \cap A_{i_k}\right)$.

% To minimize of bias induced because of the existence of other sets, we propose to reduce the probability of the banding values of less similar sets equals to $S_i$. Surprisingly, we find that we can achieve that by applying the banding technique. By banding $r$ rows of MinHash values into one, the probability of that the banding value within the same band are equal is $s^r$. As we mainly focus on the highest similarity, that is $\max\{Pr(A_1),...,Pr(A_K)\}$, we could get a more accurate estimation. For instance, suppose two sets $D_1$ and $D_2$ that has the similarity of $0.9$, $0.2$ with $S_i$ respectly. When $r=2$, the probability of the banding values equal are $0.81$ and $0.04$. Clearly, $D_2$ introduce less bias to the estimation of $0.81$. 


To solve the problem, we propose estimating $s^r ,r\geq 1$ instead of $s$. 
The reason is that, to detect money laundering groups, we can focus on the largest similarity between $S_i$ and any set $D_q$, defined as $P := \max\{Pr(A_1), \ldots, Pr(A_q)\}$. By estimating $s^r$, the probability that less similar sets produce equivalent banding values to $S_i$ is reduced, resulting in a more accurate estimation of $P^r$, and hence $P$.
For example, consider two sets, $D_1$ and $D_2$, with similarities of $0.8$ and $0.2$ with $S_i$, respectively. Directly estimating $s$ can introduce a bias of up to $0.2$, as $Pr[z=1] - 0.8 < 0.2$. When $r=2$, the probability that the banding values are equal is $0.81$ for $D_1$ and $0.04$ for $D_2$. This results in a more accurate estimation of $P$, as $\sqrt{Pr[z=1]} - 0.8 < \sqrt{0.64+0.04} - 0.8 \simeq 0.02$. A formal analysis is presented as follow:

\begin{theorem}
    \label{thm:banding}
    Suppose that $X_1, ..., X_N$ are a sequence of real values with $0\leq  X_N \leq ... \leq X_1\leq1$. Then $\forall \varepsilon>0$, when $r>\log_p(\frac{\varepsilon}{X_1 (N-1)})$,
    $$
    (\sum_{i=1}^N X_1^r)^{1/r} - X_1 \leq \varepsilon.
    $$
\end{theorem}

The proof is presented in Appendix~\ref{ssec: theoretical_ayalysis}. Based on the analysis, we estimate $P^r$ as $l/K$, where $l = \sum_{k=1}^{M/r} \mathbb{1}[B_{ki} \in BF_k]$, which represents the number of occurrences where $B_{ki}$ is found in $BF_k$.
We identify sets involved in money laundering if their similarities exceed a predefined threshold. We can define this threshold as $\tau^r$ or estimate the similarity as $\left(l/K\right)^{1/r}$.

We denote the method as \textbf{Sim-CSGM} and present in the pseudo-code in Algorithm~\ref{alg: IsMoneyLaunderingSim}. 
% Finally, Algorithm~\ref{alg: distribute_MLSD} summarizes our algorithm of optimized collaborative scatter-gather mining. We mark the major differences from Algorithm~\ref{alg: naive_distribute_MLSD} in red background. 

% note that the Bloom filter is designed for storing a set, whereas the elements in a band may duplicate. Directly inserting a band into a Bloom filter and estimating the similarity based on this approach introduce a potential bias.
% We provide a theoretical analysis below.
% To that end, we transform the process of calculating $r_{ij}$ into testing whether an element is presented in the received Bloom filter. In more detail, for institution $p$ who owns $\mathcal{S}_p$ and receives $BF(\mathcal{HD}_q)$ from institution $q$, we define $\hat{r}_{ij}$ is 1 when $H(\mathcal{S}_p[i])$ is present in $BF(\mathcal{HD}_q)$ and 0 otherwise.
% However, it is worth mentioning that there might be duplicate elements in $\mathcal{HS}$ and $\mathcal{HD}$ individually, resulting in a potential bias in $\hat{r}_{ij}$.
% A theoretical analysis is shown below. 
% Specifically, suppose that we want to estimate the similarity between two sets $S_i$ and $D_j$, denote $r_{ij}$ is a random variable that is 1 when $H(S_i) = H(D_j)$ and 0 otherwise. Similarly, when insert all $D$ into a (sufficient large) Bloom filter, we denote $t_{ij}$ is 1 when $S_i$ is detected in the Bloom filter and 0 otherwise.
% % $H(D_j)$ is inserted into a Bloom filter along with other minhash values of sets in $\mathcal{D}$.
% We have 
% \begin{equation}
% \begin{aligned}
%     Pr[r_{ij}=1] &= \frac{|S_i \cap D_j|}{|S_i \cup D_j|},\\
%     Pr[t_{ij}=1] &= \frac{|(S_i \cap (D_j\cup D^C_j))|}{|S_i \cup D_j \cup D^C_j|},
% \end{aligned}
% \end{equation}
% where $D^C_j$ are the union of other sets in  $\mathcal{D}$, $D^C_j := \mathcal{D}\backslash D_j$.
% % that have elements overlap with $S_i$ except for $D_j$. $D'_j = \bigcup\{D_z|D_z \in  \mathcal{D},|D_z\cap S_i|>0, \text{and}\ z\neq j\}$. 
% The distance between $Pr[r_{ij}=1]$ and $Pr[t_{ij}=1]$ is:

% In order to minimize the bias, one can reduce the number of overlapping elements between $S_i$ and $D^C_j$ according to the above analysis. 
% Surprisingly, we find that we can reduce the number of overlapping elements by applying the banding technique.
% The core idea behind this is that sets with high similarity are more likely to produce the same column than dissimilar sets. Consequently, it effectively reduces the number of overlapping elements within a band.

\begin{algorithm}[htb]
\caption{IsSimilarSetSim}
\label{alg: IsMoneyLaunderingSim}
\small
\KwIn{Query set $S_i$, Bloom filters $BF_k,k\in\{1,..,K\}$} 
\KwOut {$h$, $h=1$ indicates the set is a similar set}
\BlankLine
\For{$k \in \{1,...,M/r\}$}{
    $B_{ki}\leftarrow \operatorname{BANDING}(\{H_t(S)|t\in[(k-1)r, kr]\})$\\

    \eIf{$B_{ki} \in BF_k$}{$t_k =1$}{$t_k =0$}
}
    $s_{i}  = (\sum_{k=1}^{K}t_k r)/m$\\
    % \tikzmk{B}\boxitt{pink}
    \eIf{$s_{i}\geq \tau^r$}{h=1}{h=0}
    \Return{h}

\end{algorithm}






% In more detail, the probability that any two columns within the band are equal is $J(S_i, S_j)^r$, which decreases exponentially with $r$. 

% let's consider the processing of $\mathcal{HS}$. Recall that we have $m$ lists of $\mathcal{HS}^m$ where the $m$-th list is obtained using the $m$-th hash function. We randomly divide $[1,...,M]$ into $M/t$ groups $G_1,...,G_{M/t}$ of size $t$. For each group, we concatenate the element at the same position across the lists, resulting in a new list. Specifically, the $i$-th element in the $k$-th new list $\mathcal{HSC}^k[i]= \operatorname{CONCAT}(\{\mathcal{HS}^m[i])| m\in G_k\})$.
% For any two elements in $\mathcal{HSC}$, $\mathcal{HSC}[i]$ and $\mathcal{HSC}[j]$, $Pr[\mathcal{HSC}[i]=\mathcal{HSC}[j]] = J(S_i, S_j)^t$, where $J(S_i, S_j)$ represents the Jaccard similarity coefficient between sets $S_i$ and $S_j$. Compared to $\mathcal{HS}$, the probability that any two elements within the list are equal decreases exponentially. The notation for concatenating $\mathcal{HD}$ is $\mathcal{HRC}$.
% A further theoretical analysis is presented in Theorem~\ref{thm: bloom_filter}.



% The advantage is that it could reduce the impact of the Bloom filter in that it can not store repeated elements.




% \renewcommand*{\algorithmcfname}{Algorithm}

% \begin{algorithm}[htb]
% \caption{Distribute-MLSD}
% \label{alg: distribute_MLSD}
% % \begin{multicols}{2}
% \small
% \KwIn{institutions $\Cli_1$ and $\Cli_2$, each holds a subgraph $\mathcal{G}_1$ and $\mathcal{G}_2$ and the corresponding transformed subgraph $\mathcal{G}'_1$ and $\mathcal{G}'_2$, depth $K$, threshold $\tau$, Hash functions $H_m, m\in [M]$, band size $r$, $\operatorname{IsMoneyLaundering}$ (Algorithm~\ref{alg: IsMoneyLaunderingProb} or Algorithm~\ref{alg: IsMoneyLaunderingSim})} 
% \KwOut {set of transactions involved in money laundering activities}
% \BlankLine
% \textit{// Discover sets  of nodes involved in cross-institution transactions sourced from each node}\\
% \For{$p=\{1,2\}$}{
%     \For{$i \in \mathcal{V}_p$}{
%         $S_i \leftarrow \Cli_p$ run Algorithm~\ref{alg: set_discovery} with inputs $\{i, \mathcal{G}_p, K\}$\\
%         $R_i \leftarrow \Cli_p$ run Algorithm~\ref{alg: set_discovery} with inputs $\{i, \mathcal{G}'_p, K\}$
%     }
%     $\mathcal{S}_p\leftarrow \{S_i|\forall i \in \mathcal{V}_p\}$, $\mathcal{D}_p\leftarrow \{R_i|\forall i \in \mathcal{V}_p\}$\\
%     \tikzmk{A}
%     \For{$m \in \{1,...,M\}$}{
%         $\mathcal{HS}_m^p\leftarrow [H_k(S_i)|\forall i \in \mathcal{V}_p]$\\
%         $\mathcal{HD}_m^p\leftarrow [H_k(R_i)|\forall i \in \mathcal{V}_p]$\\
%     }
%     \For{$k \in \{1,...,M/t\}$}{
%         $\mathcal{BS}_k^p\leftarrow \operatorname{BANDING}([\mathcal{HS}_m^p|m\in[(k-1)r, kr]])$\\
%         $\mathcal{BD}_k^p\leftarrow \operatorname{BANDING}([\mathcal{HD}_m^p|m\in[(k-1)r, kr]])$\\
%         $BF(\mathcal{BS}_k^p) \leftarrow \Cli_l$ insert $\mathcal{BS}_k^p$ into a Bloom filter\\
%         $BF(\mathcal{BD}_k^p) \leftarrow \Cli_l$ insert $\mathcal{BD}_k^p$ into a Bloom filter
%     }
%     $BF_S^p \leftarrow \{BF(\mathcal{BS}_k^p)\}_{k=1}^{M/r}$, $BF_R^p \leftarrow \{BF(\mathcal{BD}_k^p)\}_{k=1}^{M/r}$\\
%     $\Cli_p$ sends $BF_S^p$ and $BF_R^p$ to $\Cli_q$\\
%     \tikzmk{B}
%     \boxit{pink}
% }
% \For{$p=\{1,2\}$}{
%     \textit{// Discover sources and destinations involved in money laundering activities}\\
%     Initialize set $S_{ML}^p= \emptyset$\\
%     \tikzmk{A}
%     \For{$(\mathcal{S},BF)\in \operatorname{ZIP}(\{\mathcal{S}_p, \mathcal{D}_p\}, \{BF_S^{q}, BF_R^{q} \})$}{
%         Initialize set $W^p= \emptyset$\\
%         \For{$S_i \in \mathcal{S}$}{
%             $h\leftarrow \operatorname{IsMoneyLaundering}(S_i, BF)$\\
%             \If{r=h}{$W^p$.append($i$)}
%         }
%         \tikzmk{B}
%     \boxitt{pink}
%         \textit{// Discover intermediate nodes involved in money laundering activities}\\
%         \For{$v\in W_p$}{
%             \uIf{$\mathcal{S}==\mathcal{S}_l$}
%             {$S_{ML} \leftarrow \Cli_l$ tracing flows sourced from $i$ on $\mathcal{G}_l$ }
%             \ElseIf{$\mathcal{S}==\mathcal{D}_l$}
%             {$S_{ML} \leftarrow \Cli_l$ tracing flows sourced from $i$ on $\mathcal{G}'_l$ }
    
%             $S_{ML}^p$.append($S_{ML}$)
%         }
%     }

% }
% \Return{$S_{ML}^1$, $S_{ML}^2$}

% % \end{multicols}
% \end{algorithm}


% \subsection{Connect distribute-MLSD to MLSD}
% In this section, we aim to establish a connection between the MLSD approach and distribute-MLSD. This connection allows us to gain insights into their relationship and provides guidance for determining appropriate parameters in the new method, leveraging the settings of MLSD. To achieve this goal, we model MLSD using the language of distribute-MLSD. 
% Specifically, denote $S, R$ are the sets that we aim to estimate the similarity between them. $S$ and $R$ are obtained by performing forward and backward tracing on graphs owned by different institutions, separately, utilizing Algorithm~\ref{alg: set_discovery}. 
% The Jaccord similarity between $S$ and $R$ is $s_J =\frac{|S\cap R|}{|S\cup R|}$. We denote the intersection between $S$ and $R$ as $I$ and introduce $O_S$ and $O_R$ to represent the elements present in $S$ and $R$ respectively, but not in $I$. $O_S = S\backslash I$ and $O_R = R\backslash I$. Then $s_J$ can also be represented as $\frac{|I|}{|O_S|+ |I| + |O_R|}$.

% Applying the concept to the MLSD, which detects money laundering nodes by assessing the proportion of funds received by node $j$ originating from node $i$. Let's consider $i$ and $j$ are the source nodes of $S$ and $R$, respectively. Then, the ratio that the received money of $j$ comes from $i$ can be represented as $s = \frac{|I|/2}{|I|/2 + |O_S| + |S_I|}$, where $S_I$ is the set of transactions that receive money from $i$ through inner transactions within the institution.
% Assume that $|S_I| = \lambda |O_S|$, and $|O_R| = \gamma |O_S|$, $s_J$ can be derived from $s$ using the equation presented below: 
% \begin{equation}
%     s_J = \frac{s}{\frac{1+\gamma}{2(1+\lambda)}(1-s)+s}.
% \end{equation}
% Next, we address the challenge of obtaining the values of $\lambda$ and $\gamma$, considering that given that $|O_S|$ and $|O_R|$ can not be calculated explicitly unless institutions directly transmit the corresponding transaction sets. 
% Given the estimated similarity of two sets $\hat{s}_J$, we show that 
% \begin{equation}
%     \gamma = \frac{|R|-\hat{s}_J|S|}{|S|-\hat{s}_J|R|},\ 
%     \lambda = \frac{(\hat{s}_J\gamma+1)|S_I|}{(1-\hat{s}_J)|S|},
% \end{equation}
% where $|S_I|$ can be obtained by tracing the local transaction graph.

% The analysis provides a means to derive the threshold used in the distribute-MLSD method based on the threshold used in the MLSD approach. However, it should be noted that $\gamma$ and $\lambda$ vary for each set. To overcome this, we can estimate $\gamma$ and $\lambda$ by averaging multiple observations of these parameters, which allows for a more robust and accurate estimation of the thresholds.

