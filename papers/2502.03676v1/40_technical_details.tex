In \cref{sec: alg_overview},  we gave an overview of our anytime algorithmic framework; this section details its stages.

\begin{algorithm}[tb]
    \footnotesize 
    \caption{\footnotesize Guided Algorithmic Framework}
    \label{alg:proposed}
    \SetKwProg{Fn}{Function}{}{}
    \SetKwProg{For}{for}{\ do}{}
    \SetKwProg{While}{while}{\ do}{}
    \SetKwProg{ForEach}{foreach}{\ do}{}
    \SetKwProg{If}{if}{\ then}{}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \SetKwInOut{Hyper}{hparam}
    \SetKwInOut{Global}{g\_var}
    \SetKw{KwTo}{to}
    \SetKw{KwStep}{step}
    \SetKw{KwOr}{or}
    \SetKw{KwIn}{in}
    \SetKw{KwNotIn}{not in}
    \SetKw{KwAnd}{and}
    \SetFuncSty{texttt}
    \SetKwFunction{FDP}{DP}%
    \SetKwFunction{SEARCHH}{SearchHybrid}%
    \SetKwFunction{SEARCHD}{SearchDense}%
    
    \SetKwFunction{SAMPLING}{SparseSample}%
    \SetKwFunction{DEN}{AdditionalSample}%
    \SetKwFunction{CDG}{AddDenseEdges}%
    \SetKwFunction{CSG}{AddSparseEdges}%
    %\Fn{\FDP{$S$\added{,$t$}}}{

    %\small 
    
    \Input{an end-effector trajectory $\chi{=}\{(t_1, \mathbf{p}_1), ..., (t_{n}, \mathbf{p}_{n})\}$ }
    \Output{a joint space trajectory $p$, which is refined over iteration}
    \Hyper{initial number of IK solutions for each waypoint $m_0$, \\
    sparse step size $s$, 
    max number of iterations $i_{max}$}
    % \Global{checked edges $E_{checked}$}
    \SetKwInOut{Global}{g\_var}
   
    $V \leftarrow \SAMPLING(\chi, s, m_0)$  \Comment*[r]{Sparse vertex sampling} 
    $E \leftarrow \emptyset,$ $i \leftarrow 0$ \\
    % $E_{checked} \leftarrow \emptyset$ \\
    \While {$i < i_{max}$} {
        $i \leftarrow i + 1$ \\
        $E \leftarrow  \CSG(V, E, \chi)$ \Comment*[r]{Sparse edge addition}
        
        $G \leftarrow (V, E)$ \\
        $\xi' \leftarrow $ \SEARCHH(G) \Comment*[r]{Guide path search}
        $V \leftarrow \DEN(V, \chi, \xi')$ \Comment*[r]{Sample more vertices}
        
        $E \leftarrow \CDG(V, E, \chi)$ \Comment*[r]{Dense edge addition} 
        
        $G \leftarrow (V, E)$ \\
        $\xi \leftarrow $ \SEARCHD(G)  \Comment*[r]{Solution search}
    }
    \algorithmfootnote{{\texttt{SparseSampling}($\chi, s, m_0$)} randomly samples $m_0$ IK solutions for every $s$ waypoints along the reference trajectory $\chi$. Specific sampling methods are discussed in \cref{sec:conventional_sampling}. \\
    {\texttt{SearchHybrid}($G$)} finds the shortest path from the first layer to the last layer in $G$, using both dense and sparse edges. Specific search methods are discussed in \cref{sec:conventional_search}.  \\
    {\texttt{SearchDense}($G$)} finds the shortest path from the first layer to the last layer in $G$, using only dense edges.
    \vspace{-2mm}
    }
\end{algorithm}

\begin{algorithm}[tb]
    \caption{\texttt{AddSparseEdges}}
    \label{alg:add_sparse_edges}
    \SetKwProg{Fn}{Function}{}{}
    \SetKwProg{For}{for}{\ do}{}
    \SetKwProg{If}{if}{\ then}{}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \SetKwInOut{Global}{g\_var}
    \SetKwInOut{Hyper}{hparam}
    \SetKw{KwTo}{to}
    \SetKw{KwOr}{or}
    \SetKw{KwNot}{not}
    \SetKw{KwAnd}{and}
    \SetKw{KwTrue}{True}
    \SetFuncSty{texttt}
    \SetKwFunction{CC}{Cost}%
    \SetKwFunction{CD}{CostDense}%
    \SetKwFunction{ISC}{Linkable}%

    \footnotesize 
    
    \Input{vertices $V$,
            edges $E$ \\
    \hspace{-2mm} an end-effector trajectory $\chi{=}\{(t_1, \mathbf{p}_1), ..., (t_{n}, \mathbf{p}_{n})\}$}
    \Output{updated edges $E$ }
    \Hyper{sparse step size $s$,
        scaling factor $\eta$}
    \For {$x = s{+}1$ \KwTo $n$} {
        \For {$y_1 = 1$ \KwTo $|V[x{-}s]|$} {
            \For {$y_2 = 1$ \KwTo $|V[x]|$} {
                    \uIf {$\ISC(V[x{-}s][y_1], V[x][y_2], t_x {-} t_{x{-}s})$ \KwAnd $\CC(V[x{-}s][y_1], V[x][y_2])$$* \eta < \CD(V[x{-}s][y_1], V[x][y_2])$} {
                        $e \leftarrow (V[x{-}s][y_1], V[x][y_2])$ \\
                        $e.\text{weight} = \CC(V[x{-}s][y_1], V[x][y_2])$ \\
                        $e.\text{is\_sparse} = \KwTrue$ \\
                        $E \leftarrow E \cup \{e\}$
                    }
            }
        }
    }
    \algorithmfootnote{
    \texttt{Linkable}($V_1, V_2, \Delta t$) returns true if the robot can move between the two given joint configurations within the time duration, without exceeding joint velocity limits.  \\ 
    \texttt{Cost}($V_1, V_2$) returns the cost to move directly between the two joint configurations. As discussed in \cref{sec:conventional_graph}, the cost depends on problem formulation. \\ 
    \texttt{CostDense}($V_1, V_2$) returns the lowest cost that moves between the two joint configurations using dense edges. The lowest cost can be computed using graph search methods. If the two joint configurations are not connected by dense edges, return infinity.   \vspace{-5mm}}  
\end{algorithm}


\subsubsection{Sparse Vertex Sampling} \label{sec: sparse_sampling}

This stage involves sampling $m_0$ IK solutions for every $s$ waypoint, starting from index $1$ and including index $n$.
{A total of $\ceil{n/s + 1} \times m_0$ IK solutions are sampled, where $n$ is the number of waypoints on the reference trajectory and $\ceil{\cdot}$ is a ceiling function that rounds a real number up to the nearest integer.}
The specific sampling methods described in \cref{sec:conventional_sampling} can be used to sample IK solutions. 
This stage generates the initial set of vertices in the graph, which are used to find an initial guide path.


\subsubsection{Sparse Edge Addition}
This stage adds sparse edges to the graph.
Algorithm \ref{alg:add_sparse_edges} outlines the {\small\texttt{AddSparseEdges}} function.
In order to add a sparse edge between vertices that are $s$ layers away, the {\small\texttt{Linkable}} function checks if the robot can move between the configurations within the time budget.  
In our implementation, {\small\texttt{Linkable}} assumes linear movements in joint space and checks if a linear movement is within the robot's joint velocity limit. 
In addition, the algorithm checks whether the two vertices are already connected by dense edges. If a path composed of dense edges connects the two vertices and its cost is similar to the cost of the sparse edge, it suggests that the area has already been sufficiently sampled, eliminating the need for a sparse edge.




\subsubsection{Guide Path Search} A guide path is identified by finding the lowest cost path from the first to the last layer of the graph, using both dense and sparse edges. Specific graph search algorithms discussed in \cref{sec:conventional_search} can be used to find the path with the lowest cost. 



\subsubsection{Additional Vertex Sampling}

This stage takes a guide path as input and biases sampling toward it. As shown in Algorithm \ref{alg:densification}, this stage first samples around every sparse edge within the guide path, then randomly samples an equivalent amount of IK solutions. 
Sampling around the sparse edges allows them to be replaced by dense edges.

In order to sample around a sparse edge,  we linearly interpolate joint configurations on the sparse edge ({\small \texttt{LinInterp}}), apply some random disturbance ({\small\texttt{AddRandDelta}}), and use it as starting configurations of an IK solver. The IK solver finds IK solutions near the starting configuration. We use RelaxedIK \cite{rakita2018relaxedik} in our implementation, but any other IK solvers mentioned in \cref{sec:conventional_sampling} are also compatible. 

In order to randomly sample IK solutions across the entire trajectory, we first randomly select waypoints using Softmax, which assigns higher selection probabilities to waypoints with fewer randomly sampled IK solutions.
 \begin{equation} 
   \label{eq:probability}
     p_x{=}\frac{\exp(-|V_r[x]|)}{\sum_{i=0}^{n} \exp(-|V_r[i]|)}
\end{equation}
where $x$ is the waypoint index, and $|V_r[x]|$ is the number of existing randomly sampled IK solutions for waypoint $x$. After selecting a waypoint, we generate a random IK solution by initiating an IK solver's starting configuration at a random location ({\small\texttt{RandConfig}}) in the robot's joint space. 

   
   
\subsubsection{Dense Edge Addition}


This stage adds dense edges to the graph, which connect vertices in adjacent layers. As detailed in Algorithm \ref{alg:add_dense}, the procedure involves iterating over all pairs of vertices located on adjacent layers. The algorithm uses the {\small\texttt{Linkable}} function to check the feasibility of each pair. After adding dense edges, the algorithm identifies and removes the sparse edges that have been superseded by dense edges. Specifically, if there exists a path composed of dense edges that connects the two endpoint vertices of a sparse edge, and the path's cost is similar to the sparse edge's cost, maintaining the sparse edge becomes unnecessary. Our approach shares a similar idea with lazy planning \cite{bohlin2000path, haghtalab2018provable}, which delays the evaluation of edges until they are necessary for the solution. In our approach, sparse edges serve as estimators and a more accurate cost is computed when replacing sparse edges with dense edges. 

\subsubsection{Solution Search} This stage identifies a solution by finding the lowest cost path from the first to the last layer, using only dense edges. Specific graph search approaches described in \cref{sec:conventional_search} can be used to find the shortest path. The identified solution corresponds to a motion that accurately tracks every waypoint on the reference trajectory. 


\setlength{\textfloatsep}{0pt}
\begin{algorithm}[tb]
    \caption{\texttt{AdditionalSample}}
    \label{alg:densification}
    \SetKwProg{Fn}{Function}{}{}
    \SetKwProg{For}{for}{\ do}{}
    \SetKwProg{While}{while}{\ do}{}
    \SetKwProg{ForEach}{foreach}{\ do}{}
    \SetKwProg{If}{if}{\ then}{}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \SetKwInOut{Hyper}{hparam}
    \SetKw{KwTo}{to}
    \SetKw{KwStep}{step}
    \SetKw{KwOr}{or}
    \SetKw{KwIn}{in}
    \SetKw{KwIs}{is}
    \SetKw{KwNotIn}{not in}
    \SetKw{KwAnd}{and}
    \SetFuncSty{texttt}
    \SetKwFunction{FDP}{DP}%
    \SetKwFunction{SEARCH}{SEARCH}%
    \SetKwFunction{DSEARCH}{DENSE\_SEARCH}%
    \SetKwFunction{SA}{SAMPLE\_AROUND}%
    \SetKwFunction{SR}{SAMPLE\_RANDOM}%
    \SetKwFunction{CC}{COMPUTE\_COST}%
    
    \SetKwFunction{SAMPLING}{SAMPLING}%
    \SetKwFunction{CDG}{CONSTRUCT\_DENSE\_EDGES}%
    \SetKwFunction{CSG}{CONSTRUCT\_SPARSE\_EDGES}%
    \SetKwFunction{IK}{IK}%
    \SetKwFunction{LI}{LinInterp}%
    \SetKwFunction{SI}{SampleIndex}%
    \SetKwFunction{RD}{AddRandDelta}%
    \SetKwFunction{RC}{RandConfig}%
    \SetKwFunction{CP}{CompProb}%

    \footnotesize 
    
    \Input{vertices $V$, 
    a guide path $\xi'$, \\
    \hspace{-2mm}  an end-effector trajectory $\chi{=}\{(t_1, \mathbf{p}_1), ..., (t_{n}, \mathbf{p}_{n})\}$} 
    \Output{updated vertices $V$ }
    \Hyper{number of new IK solutions per waypoint $m_d$ \\perturbation bound $\delta$}
    \Comment{Sample around the guide path} 
    \ForEach {edge \KwIn $\xi'$} {
        \uIf {edge.\textnormal{is\_sparse}} {
            \For {x= e.\textnormal{start\_idx} \KwTo e.\textnormal{end\_idx} } {
                $r = (x{-}e.\textnormal{start\_idx})/(e.\textnormal{end\_idx}{-}e.\textnormal{start\_idx})$ \\
                $\mathbf{q} = \LI(e.\textnormal{start\_vertex}, e.\textnormal{end\_vertex}, r)$ \\
                \For {$i = 1$ \KwTo $m_d$} {
                    $\mathbf{q} =  \RD(\mathbf{q}, \delta)$ \\ 
                    $v = \IK(\mathbf{p}_x, \mathbf{q})$ \\
                    $V = V \cup \{v\}$ \\
                }
            }   
        }
    } 
    \Comment{Randomly Sample} 
    $ \text{Pr} = \CP(V)$ \\
    \For {$i=1$ \KwTo $|V|$} {
        $x \leftarrow \SI(p)$ \\
        $v = \IK(\mathbf{p}_x, \RC())$ \\
        $V = V \cup \{v\}$ \\
        $\text{Pr} = \CP(V)$ 
    }
    \algorithmfootnote{
    \texttt{LinInterp}($V_1, V_2, r$) returns a joint configuration along the straight line between $V_1$ and $V_2$ based on a specified ratio $r$.  \\ 
    \texttt{AddRandDelta}($\mathbf{q}, \delta$) adds random disturbance $\texttt{rand}(-\delta, \delta)$ to each joint value $q_j,\,\, \forall j\in \{1,...,k\}$, and clips 
$\mathbf{q}$ to the valid joint range.  \\ 
    \texttt{IK}($\mathbf{p}, \mathbf{q}_s$) returns an IK solution that moves the end-effector to $\mathbf{p}$. The IK solution is regularized to be near the starting configuration $\mathbf{q}_s$. \\  
    \texttt{CompProb}($V$) returns the probability of selecting a waypoint using Eq. \ref{eq:probability}.
    \vspace{-4mm}
    }  
\end{algorithm}

\setlength{\textfloatsep}{-10pt}
\setlength{\dbltextfloatsep}{-20pt}
\begin{algorithm}
    \caption{\texttt{AddDenseEdges}}
    \label{alg:add_dense}
    \SetKwProg{Fn}{Function}{}{}
    \SetKwProg{For}{for}{\ do}{}
    \SetKwProg{If}{if}{\ then}{}
    \SetKwInOut{Input}{input}
    \SetKwInOut{Output}{output}
    \SetKwInOut{Global}{g\_var}
    \SetKwInOut{Hyper}{hparam}
    \SetKw{KwTo}{to}
    \SetKw{KwOr}{or}
    \SetKw{KwAnd}{and}
    \SetKw{KwFalse}{False}
    \SetFuncSty{texttt}
    \SetKwFunction{CC}{Cost}%
    \SetKwFunction{ICA}{Linkable}%
    \SetKwFunction{INC}{IsDenselyConnected}%

    \footnotesize 
    
    \Input{vertics $V$,
            edges $E$, \\ 
            \hspace{-2mm} an end-effector trajectory $\chi{=}\{(t_1, \mathbf{p}_1), ..., (t_{n}, \mathbf{p}_{n})\}$}
    \Output{updated Edges $E$ }
    \Hyper{scaling factor $\eta$}
    \For {$x = 2$ \KwTo $n$} {
        \For {$y_2 = 1$ \KwTo $|V[x]|$} {
            \Comment{Add dense edges}
            \For {$y_1 = 1$ \KwTo $|V[x{-}1]|$} {
                $e \leftarrow \{(V[x{-}1][y1], V[x][y2])\}$ \\
                    \uIf {$\ICA(V[x{-}1][y1], V[x][y2], t_x {-} t_{x{-}1})$} {
                        $e.\textnormal{weight} = \CC(V[x{-}1][y1], V[x][y2])$ \\
                        $e.\textnormal{is\_sparse} = \KwFalse$ \\
                        $E \leftarrow E \cup \{e\}$
                    }
            }
            \Comment{Remove sparse edges}
            \uIf {$x > s$} {
                \For {$y_1 = 1$ \KwTo $|V[x{-}s]|$} {
                    $e \leftarrow \{(V[x{-}s][y1], V[x][y2])\}$ \\
                     \uIf {$e \in E$ \KwAnd $\CC(V[x{-}s][y_1], V[x][y_2])$$* \eta <$ $\CD(V[x{-}s][y_1], V[x][y_2])$} {
                        $E \leftarrow E \backslash \{e\}$
                    }
                }
            }
        }
    }
    \iffalse
    \algorithmfootnote{
    \texttt{Connectable}($V_1, V_2, \Delta t$) returns true if the robot can move between the two given joint configurations within the time duration, without exceeding joint velocity limits.  \\ 
    \texttt{Cost}($V_1, V_2$) returns the cost to move directly between the two joint configurations. As discussed in \cref{sec:conventional_graph}, the cost depends on problem formulation. \\ 
    \texttt{CostDense}($V_1, V_2$) returns the lowest cost that moves between the two joint configurations using dense edges. The lowest cost can be computed using graph search methods. If the two joint configurations are not connected by dense edges, return infinity. 
    }  
    \vspace{-3mm}
    \fi
\end{algorithm}