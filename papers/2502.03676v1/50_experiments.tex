
In this section, we compare our proposed algorithm framework with the two baseline approaches described in \cref{sec: technical_overview}: the conventional sequential framework and the \naive anytime framework. We conducted three independent experiments in simulation, 
each involves two testbeds. The first testbed tracks 10 randomly generated trajectories, comparing our framework with various parameter settings (step size $s{=}3,5, \text{or } 10$) against the baselines. The second testbed tracks a trajectory 10 times and we report the average, best, and worst motions generated by each method to provide
a comprehensive overview of the performance variations.

Our implementation is based on the open source IKLink library  in Rust. We note that the Rust implementation performs faster than the implementation evaluated in the original paper \cite{wang2024iklink}. 
Our framework used $m_d {=} 5$,  $\delta{=}0.2$, $\eta {=} 1.1$ (across all experiments), $m_0 {=} 50$ (Experiments A$\&$B) and $m_0 {=} 500$ (Experiment C).
All evaluations were performed on a laptop with an Intel i7-11800H 2.30 GHz CPU and 16 GB of RAM.

\begin{figure*}[!tb]
\includegraphics[width=7.0in]{figures/results.pdf}
\vspace{-2mm}
\caption{Results of our three experiments, each on two testbeds. For random trajectory tracking (top row), the results are averaged over 10 randomly generated trajectories. For specific tasks (bottom row), the results are averaged over 10 repetitions of the same trajectory, with colored regions indicating the range between the maximum and minimum values within these repetitions. 
In the line charts, the initial point of a line encodes the average computation time to get initial solutions. 
\textbf{Left column}: our framework enabled Stampede to find initial effective solutions faster than the baselines. \textbf{Middle column}: IKLink with our framework converged faster than with the \naive framework. \textbf{Right column}: for trajectories with tolerances, our framework enabled IKLink to find motion with fewer reconfigurations than the baseline frameworks. The robot visualizations were generated using Motion Comparator \cite{wang2024motion}\protect\footnotemark.
}
\label{fig:results}
\vspace{-3mm}
\end{figure*}

\begin{table*}[tb]
\caption{Experiment Results} 
\vspace{-3mm}
\label{tab:results}
\begin{center}
\begin{tabular}{c|c|c|c|c|c|c|c|c|c|c|c|c}
\hline
\multirow{3}{*}{Method} & \multicolumn{4}{c|}{Exp A} & \multicolumn{4}{c|}{Exp B} & \multicolumn{4}{c}{Exp C} \\
\cline{2-13}
\rule{0pt}{1.05\normalbaselineskip}%
& \multicolumn{2}{c|}{Testbed 1} &  \multicolumn{2}{c|}{Testbed 2} & \multicolumn{2}{c|}{Testbed 1} &  \multicolumn{2}{c|}{Testbed 2} & \multicolumn{2}{c|}{Testbed 1} &  \multicolumn{2}{c}{Testbed 2} \\
\cline{2-13}
\rule{0pt}{1.05\normalbaselineskip}%
& Time$^\dagger$ & JM$^\ddagger$ & Time$^\dagger$ & JM$^\ddagger$ & Time$^\dagger$ & \# RC$^\ddagger$ & Time$^\dagger$ & \# RC$^\ddagger$ & Time$^\dagger$ & \# RC$^\ddagger$$^\ddagger$ & Time$^\dagger$ & \# RC$^\ddagger$
\\  
\hline
Baseline 1\hspace{2ex} & 20.5 & 7.14 & 34.8 & 13.92& 
58.2 & 1.8 & 66.7 & \textbf{1.0} &
38.3 & 0.9 & 41.6 & 2.6\\
Baseline 2\hspace{2ex} & \hspace{1ex}7.1 & 7.14 & 34.4 & 13.92& 
58.9 & 1.8 & 31.2 & \textbf{1.0} &
41.9 & 0.9 & 74.1 & 2.9\\
Ours ($s{=}5$)\hspace{1ex} & \hspace{1ex}\textbf{1.8} & \textbf{6.97} & \hspace{1ex}\textbf{8.1} & \textbf{13.85} & 
\textbf{13.6} & \textbf{1.3} & \hspace{1ex}\textbf{4.4} & \textbf{1.0} &
20.9 & \textbf{0.4} & \textbf{24.6} & \textbf{0.8}\\
Ours ($s{=}3$)\hspace{1ex} & \hspace{1ex}2.5 & 6.99 & / & / & 
20.6 & 1.5 & / & / &
28.7 & 0.6 & / & /\\
Ours ($s{=}10$) & \hspace{1ex}3.5 & 7.01 & / & / & 
22.2 & 1.6 & / & / &
\textbf{14.6} & 0.7 & / & / \\
\hline


\hline
\multicolumn{13}{l}{\rule{0pt}{1\normalbaselineskip}%
$\dagger$: Average computation time to achieve the same performance of Baseline 1 (the conventional framework)} \\
\multicolumn{13}{l}{
\makecell[l]{$\ddagger$: Average performance achieved within Baseline 1's computation time (JM=Joint Movement, \# RC=Number of Reconfigurations) }}
\vspace{-7mm}
\end{tabular}
\end{center}
\end{table*}



\vspace{-3mm}
\subsection{Experiment A - Tracking with Minimal Joint Movements} \label{sec: expA}
We apply our framework to the Stampede algorithm \cite{rakita2019stampede} to find robot motions that track end-effector trajectories with minimal joint movements. 
As proposed in the original paper, Stampede used the conventional sequential framework.
Stampede samples IK solutions by initiating an optimization-based IK solver, RelaxedIK \cite{rakita2018relaxedik}, with starting configurations sampled from a uniform distribution. 
Additionally, it uses value iteration for graph search. 
 Since our objective is to minimize joint movements, we define the edge weights within the graph as the Euclidean distances in joint space between two joint configurations. 

This experiment uses a 7-degrees-of-freedom KUKA LBR iiwa robot. The first testbed tracks 10 random cumulative cubic Bézier curves \cite{kim1995general} for smooth position and orientation changes. These trajectories have an average length of 1.26 m, an average angular displacement of 5.13 rad, and an average of 379.4 waypoints.
 The second testbed replicates a writing task from prior work \cite{morgan2024cppflow,kang2020torm}, where the robot traces a ``hello'' trajectory. The trajectory is rescaled to fit iiwa's workspace. 

As shown in the left column of Figure \ref{fig:results}, while all three approaches generated motions with similar joint movements, our framework achieved initial solutions 2$\times$ faster. The results show that our heuristic is effective for simple trajectories and enables fast identification of effective motions.


\vspace{-3mm}
\subsection{Experiment B - Tracking with Minimal Reconfigurations} \label{sec: expB}

We apply our framework to the IKLink algorithm \cite{wang2024iklink} which utilizes the conventional sequential framework to track the end-effector trajectory of any complexity.  If a reference trajectory is too complex to be tracked as a single, continuous path, IKLink generates motions with minimal reconfigurations. In addition, IKLink has a secondary objective of minimizing joint movements. Similar to Stampede, IKLink uses RelaxedIK \cite{rakita2018relaxedik} to uniformly sample IK solutions. It also leverages RelaxedIK's velocity regularization to find IK solutions close to those in the previous layer, thereby generating smooth motions. Moreover, similar IK solutions are merged using a clustering method. IKLink finds motions using dynamic programming, which incorporates both the number of reconfigurations and joint movements as objectives. 

This experiment uses a 7-DoF Franka Panda robot. The first testbed tracks random trajectories that consist of two consecutive cubic cumulative Bézier curves \cite{kim1995general}. The trajectories average 2.26 m in length, 12.07 rad in angular displacement, and 677.6 waypoints.
The second testbed involves a 3D scanning task, in which a robot accurately moves a sensor along a predefined trajectory, ensuring the sensor consistently points at the object.

As shown in Figure \ref{fig:results}, our framework was more efficient and converged to motions with fewer or equal configurations, compared to both the conventional framework (baseline 1) and the \naive anytime framework (baseline 2).


\vspace{-3mm}
\subsection{Experiment C - Tracking Trajectories with Tolerances} \label{sec: expC}
In this experiment, we show how our framework extends IKLink's capability \cite{wang2024iklink} to track \textit{semi-constrained} end-effector trajectories. 
IKLink was originally designed for fully-constrained trajectory tracking, which requires all 6 DoF of the end-effector to be accurate. This requirement becomes overly restrictive in applications such as welding, where the torch may rotate around its principal axis. In contrast, semi-constrained trajectory tracking allows the end-effector to move within certain tolerances. 
Semi-constrained tracking poses a greater challenge to graph-based approaches because the solution space is larger and requires more samplings to sufficiently cover the solution space. 
We demonstrate that the IKLink using the conventional framework struggles to quickly find plausible motions, and the proposed anytime framework enables IKLinks to efficiently and effectively track trajectory with tolerances. We use RangedIK \cite{wang2023rangedik} as the IK solver, which is an extension of RelaxedIK that generates IK solutions that move the end-effector within specified tolerances. 

The first testbed randomly generates 10 welding trajectories for a Franka Panda robot. Each trajectory is composed of four cumulative cubic Bézier curves \cite{kim1995general}. The trajectories average 1.29 m in length, 22.70 rad in angular displacement, and 646.8 waypoints. Compared to the random trajectories in Experiments A and B, these trajectories involve more rotational movements. In the welding task, the tolerance is along the torch's principal axis, \textit{i.e.}, the robot is allowed to freely rotate its end-effector along the principal axis ($z$-axis). As shown in Figure \ref{fig:results}, the principal axis is angled 45 degrees from the robot's last axis. The robot must coordinate the movement of all its joints to exploit the tolerance, in contrast to just rotating the last joint when the principal axis aligns with the last axis. In the second testbed, a 7-degrees-of-freedom Rethink Robotics Sawyer robot performs a sanding task by tracking a spiral trajectory. The robot can freely rotate the sanding tool around its principal axis, which is oriented 90 degrees from the robot's last axis. 

As shown in Figure \ref{fig:results}, our framework enabled IKLink to quickly find motions with fewer reconfigurations than the baseline frameworks, while IKLink with both the conventional and \naive anytime frameworks struggled to find optimal solutions for trajectories with tolerances.

\footnotetext{Visualization tool: \url{https://github.com/uwgraphics/MotionComparator}}


\textit{Summary}:
Across all experiments, our anytime framework requires less computation time to achieve motions of the same quality and reaches equal or better motion quality within the same time frame compared to both the conventional and \naive anytime frameworks. Figure \ref{fig:results} shows that our framework consistently outperforms the baselines (our lines are consistently below or overlapping with the baselines), while Table \ref{tab:results} presents the corresponding quantitative results.

Experiments A and B show that our framework accelerates the performance of both Stampede and IKLink, enabling them to find motions of higher or equal quality in less time, in comparison to both the conventional and \naive anytime frameworks. Experiment C shows that our framework extends IKLink's ability to efficiently generate motions for tracking semi-constrained trajectories. 


Our results also show the effects of the hyperparameter step size $s$, which defines the length of sparse edges. A smaller $s$ increases the number of IK samples in Stage 1, sparse vertex sampling, thereby raising computation time for obtaining initial solutions. Meanwhile, a larger $s$ reduces the accuracy of guide paths as cost estimators, leading to slower algorithm convergence. In our experiments, we observe a sweetspot at $s{=}5$.