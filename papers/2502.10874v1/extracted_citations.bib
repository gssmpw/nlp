@inproceedings{Chen2010prjoin,
author = {Chen, Shimin and Gibbons, Phillip B. and Nath, Suman},
title = {PR-join: a non-blocking join achieving higher early result rate with statistical guarantees},
year = {2010},
isbn = {9781450300322},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1807167.1807186},
doi = {10.1145/1807167.1807186},
abstract = {Online aggregation is a promising solution to achieving fast early responses for interactive ad-hoc queries that compute aggregates on a large amount of data. Essential to the success of online aggregation is a good non-blocking join algorithm that enables both (i) high early result rates with statistical guarantees and (ii) fast end-to-end query times. We analyze existing non-blocking join algorithms and find that they all provide sub-optimal early result rates, and those with fast end-to-end times achieve them only by further sacrificing their early result rates.We propose a new non-blocking join algorithm, Partitioned expanding Ripple Join (PR-Join), which achieves considerably higher early result rates than previous non-blocking joins, while also delivering fast end-to-end query times. PR-Join performs separate, ripple-like join operations on individual hash partitions, where the width of a ripple expands multiplicatively over time. This contrasts with the non-partitioned, fixed-width ripples of Block Ripple Join. Assuming, as in previous non-blocking join studies, that the input relations are in random order, PR-Join ensures representative early results that are amenable to statistical guarantees. We show both analytically and with real-machine experiments that PR-Join achieves over an order of magnitude higher early result rates than previous non-blocking joins. We also discuss the benefits of using a flash-based SSD for temporary storage, showing that PR-Join can then achieve close to optimal end-to-end performance. Finally, we consider the joining of finite data streams that arrive over time, and find that PR-Join achieves similar or higher result rates than RPJ, the state-of-the-art algorithm specialized for that domain.},
booktitle = {Proceedings of the 2010 ACM SIGMOD International Conference on Management of Data},
pages = {147–158},
numpages = {12},
keywords = {statistical guarantee, pr-join, online aggregation, non-blocking join, finite data stream, fast early result, data warehouse},
location = {Indianapolis, Indiana, USA},
series = {SIGMOD '10}
}

@inproceedings{Dittrich2002PMJ,
author = {Dittrich, Jens-Peter and Seeger, Bernhard and Taylor, David Scot and Widmayer, Peter},
title = {Progressive merge join: a generic and non-blocking sort-based join algorithm},
year = {2002},
publisher = {VLDB Endowment},
abstract = {Many state-of-the-art join-techniques require the input relations to be almost fully sorted before the actual join processing starts. Thus, these techniques start producing first results only after a considerable time period has passed. This blocking behaviour is a serious problem when consequent operators have to stop processing, in order to wait for first results of the join. Furthermore, this behaviour is not acceptable if the result of the join is visualized or/ and requires user interaction. These are typical scenarios for data mining applications. The, off-time' of existing techniques even increases with growing problem sizes.In this paper, we propose a generic technique called Progressive Merge Join (PMJ) that eliminates the blocking behaviour of sort-based join algorithms. The basic idea behind PMJ is to have the join produce results, as early as the external mergesort generates initial runs. Hence, it is possible for PMJ to return first results very early. This paper provides the basic algorithms and the generic framework of PMJ, as well as use-cases for different types of joins. Moreover, we provide a generic online selectivity estimator with probabilistic quality guarantees. For similarity joins in particular, first non-blocking join algorithms are derived from applying PMJ to the state-of-the-art techniques.We have implemented PMJ as part of an object-relational cursor algebra. A set of experiments shows that a substantial amount of results are produced, even before the input relationas would have been sorted. We observed only a moderate increase in the total runtime compared to the blocking counterparts.},
booktitle = {Proceedings of the 28th International Conference on Very Large Data Bases},
pages = {299–310},
numpages = {12},
location = {Hong Kong, China},
series = {VLDB '02}
}

@inproceedings{Urhan2000XJoinAR,
  title={XJoin: A Reactively-Scheduled Pipelined Join Operator},
  author={Tolga Urhan and Michael J. Franklin},
  year={2000},
  url={https://api.semanticscholar.org/CorpusID:260705811}
}

@article{hong1993shj,
  author    = {W. Hong and M. Stonebraker},
  title     = {Optimization of Parallel Query Execution Plans in XPRS},
  journal   = {Distributed and Parallel Databases},
  volume    = {1},
  number    = {1},
  pages     = {9--32},
  year      = {1993}
}

@inproceedings{lawrence2005early,
  title={Early hash join: A configurable algorithm for the efficient and early production of join results},
  author={Lawrence, Ramon},
  booktitle={Proceedings of the 31st international conference on Very large data bases},
  pages={841--852},
  year={2005}
}

@inproceedings{mokbel2004hash,
  title={Hash-merge join: A non-blocking join algorithm for producing fast and early join results},
  author={Mokbel, Mohamed F and Lu, Ming and Aref, Walid G},
  booktitle={Proceedings. 20th International Conference on Data Engineering},
  pages={251--262},
  year={2004},
  organization={IEEE}
}

@article{oneil1995joinindex,
author = {O'Neil, Patrick and Graefe, Goetz},
title = {Multi-table joins through bitmapped join indices},
year = {1995},
issue_date = {Sept. 1995},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {24},
number = {3},
issn = {0163-5808},
url = {https://doi.org/10.1145/211990.212001},
doi = {10.1145/211990.212001},
abstract = {This technical note shows how to combine some well-known techniques to create a method that will efficiently execute common multi-table joins. We concentrate on a commonly occurring type of join known as a star-join, although the method presented will generalize to any type of multi-table join. A star-join consists of a central detail table with large cardinality, such as an orders table (where an order row contains a single purchase) with foreign keys that join to descriptive tables, such as customers, products, and (sales) agents. The method presented in this note uses join indices with compressed bitmap representations, which allow predicates restricting columns of descriptive tables to determine an answer set (or foundset) in the central detail table; the method uses different predicates on different descriptive tables in combination to restrict the detail table through compressed bitmap representations of join indices, and easily completes the join of the fully restricted detail table rows back to the descriptive tables. We outline realistic examples where the combination of these techniques yields substantial performance improvements over alternative, more traditional query evaluation plans.},
journal = {SIGMOD Rec.},
month = sep,
pages = {8–11},
numpages = {4}
}

@article{valduriez87joinindex,
author = {Valduriez, Patrick},
title = {Join indices},
year = {1987},
issue_date = {June 1987},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {12},
number = {2},
issn = {0362-5915},
url = {https://doi.org/10.1145/22952.22955},
doi = {10.1145/22952.22955},
abstract = {In new application areas of relational database systems, such as artificial intelligence, the join operator is used more extensively than in conventional applications. In this paper, we propose a simple data structure, called a join index, for improving the performance of joins in the context of complex queries. For most of the joins, updates to join indices incur very little overhead. Some properties of a join index are (i) its efficient use of memory and adaptiveness to parallel execution, (ii) its compatibility with other operations (including select and union), (iii) its support for abstract data type join predicates, (iv) its support for multirelation clustering, and (v) its use in representing directed graphs and in evaluating recursive queries. Finally, the analysis of the join algorithm using join indices shows its excellent performance.},
journal = {ACM Trans. Database Syst.},
month = jun,
pages = {218–246},
numpages = {29}
}

@inproceedings{wilschut1991shj,
  author    = {A. N. Wilschut and P. M. G. Apers},
  title     = {Dataflow Query Execution in a Parallel Main-Memory Environment},
  booktitle = {Proceedings of the 1st International Conference on Parallel and Distributed Information Systems},
  address   = {Miami Beach, FL},
  year      = {1991}
}

