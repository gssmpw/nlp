\section{Problem Formulation}\label{sec:pf}

In this section, we first present the structure of a general DCOP and then we cast our dec-rtRTMP in terms of such framework.

\paragraph{General DCOP.} The main ingredients of a DCOP problem are agents and variables. Importantly, each variable is owned by an
agent; this is what makes the problem distributed. Formally, a DCOP is a tuple $\langle A, V, \mathfrak{D}, \mathcal{U}, \eta\rangle$, where:
\begin{itemize}

\item $A$ is the set of agents, $\left\{a_{1}, \ldots, a_{n}\right\}$.

\item $V$ is the set of variables, $\left\{v_{1}, v_{2}, \ldots, v_{m}\right\}$. In the most general formulation, one agent may control more than one variable, while some agents may control no variables at all (i.e. $n \neq m$). Here, we assume that each variable $v_i$ is controlled by exactly one agent $a_i$ ($n=m$).

\item $\mathfrak{D}$ is the set of variable-domains, $\left\{D_{1}, D_{2}, \ldots, D_{m}\right\}$, where each $D_{i} \in \mathfrak{D}$ is a finite set containing the possible values of variable $v_{i}$. 
%If $D_{i} \in \mathfrak{D}$ contains only two values (e.g. 0 or 1 ), then $v_{i}$ is called a binary variable.

\item A \emph{value assignment} is a pair $(v_i, d_i)$ where $d_{i} \in D_i$ denotes the value currently assigned to variable $v_i$ by the agent $a_i$. A \emph{partial assignment} $S$ is a set of value assignments $\{ (v, d): v \in W \subset V \}$ involving only a proper subset $W$ of the variable set $V$. A \emph{complete assignment} is a set of value assignments involving all the variables in $V$. We denote by $\mathfrak{S} = \mathfrak{S}_p \cup \mathfrak{S}_c$ the set of all possible assignments (both partial $\mathfrak{S}_p$ and complete $\mathfrak{S}_c$).

\item A set of constraints on partial assignments determine properties of value assignments and relations among them. Constraints can be \emph{unary} when involving only one variable, \emph{binary} when involving two variables or \emph{$k$-ary} when involving $k$ variables. In a DCOP formulation, constraints can be translated into cost functions (hence, the DCOP is a minimization problem) or into utility functions (hence, a maximisation problem). Here, we consider the latter option and introduce a set of functions $\mathcal{U} = \{u:\mathfrak{S} \rightarrow \mathbb{R}\}$, each providing the utility of satisfying a constraint on the assignment $S\in\mathfrak{S}$.

% \item $u: \mathfrak{S} \rightarrow \mathbb{R}$ is the \emph{utility function}. It maps every possible assignment to a utility score (the higher the better). Usually, only few assignments in $\mathfrak{S}$, referred to as \emph{constraints} of the problem, have a non-zero score. A constraint involving only one variable is called unary constraint, while a constraint involving two variables is called binary constraint.

\item The objective function $\eta: \mathfrak{S}_c \rightarrow \mathbb{R}$ maps each possible complete assignment to a score. For a complete assignment $S \in \mathfrak{S}_c$, we denote by $\mathfrak{S}(S,u)$ the set of all (partial) assignments that are subsets of $S$ and that have the cardinality required by the utility function $u$. Then the objective function is defined as:
$$
\eta(S) = \sum_{u\in\mathcal{U}}\sum_{S^{\prime} \in \mathfrak{S}(S,u)} u(S^{\prime}).%, \quad   \quad \forall S \in \mathfrak{S}_c
%\eta(S) = \sum_{S^{\prime} \in \mathfrak{S}(S)} u(S^{\prime}), \quad   \quad \forall S \in \mathfrak{S}_c
$$
\end{itemize}

The goal of the agents in a DCOP is to achieve an optimal solution, namely a complete assignment $S^*$ that maximises the objective function $\eta$. The search of an optimal solution is distributed because each agent can only access local information when assigning a value to the variable it controls. Indeed, each agent $a_i$ can interact with just a subset $N_i$ of the agents $A$. We refer to $N_i$ as the \emph{neighbourhood} of the agent $a_i$. This means that each agent $a_i$ can only observe the assignments of the variables controlled by its neighbours, i.e. the set $S(N_i) = \left\{ (v_j, d_j): a_j \in N_i \text{ and } v_j=d_j \right\}$, and thus it cannot fully evaluate the objective function $\eta$.

%This means that each agent $a_i$ can only communicate with a subset $N_i$ of the agents in the system. We refer to $N_i$ as the \emph{neighbourhood} of the agent $a_i$.


\paragraph{dec-rtRTMP as DCOP.} In a dec-rtRTMP, we can think of trains as agents. Each train $a_i$ can control its own path $v_i$, i.e. the sequence of track sections it is going to pass through in the next future with the time at which it will do so. At any time, each train can choose among a finite number of different paths between origin and destination, constituting the domain $D_i$ for the variable $v_i$. Thus, a value assignment $(v_i, d_i)$ corresponds to the decision of the agent $a_i$ to follow the path $d_i$.
%agent $a_i$ selecting the path $d_i$ as value for $v_i$. 
Each path $d_i$ is assigned a \emph{path utility} $u_r(v_i, d_i)$ by the agent $a_i$, i.e. a real number representing how convenient is for the train to follow such path. We assume this value to be normalised to be in the range $[0,1]$. The path utility represent a soft constraint on the validity and quality of a path, as its value can depend on the prediction of the delay accumulated at the end of the day by following the path $d_i$, the number of passengers carried and other factors. When selecting a path, trains should choose the one with the highest path utility but, at the same time, they must also account for the other trains in the system. More specifically, each agent $a_i$ has to select a path that not only possesses a high path utility, but that is also compatible with the paths of all its neighbours $N_i$. Two paths $d_i$ and $d_j$ belonging respectively to distinct agents $a_i$ and $a_j$ are said to be compatible if no track section is concurrently used by the trains when the two paths are simultaneously implemented. Compatibilities between two paths represent the binary constraints of the problem, and are associated to the compatibility utility $u_c$:
$$
u_c( (v_i, d_i), (v_j, d_j) ) = 
\begin{cases}
    1     & \text{if $d_i$ and $d_j$ are compatible}, \\
    0     & \text{otherwise}.
\end{cases}
$$
An optimal solution to the dec-rtRTMP is thus a complete assignment that maximises the sum of both utilities defined above, namely the objective function $\eta$.


Furthermore, since we only have unary and binary constraints, we can also provide a compact visual representation of a given instance of the dec-rtRTMP in the form of a pair of graphs $(\mathcal{G}_I, \mathcal{G}_C)$. The graph $\mathcal{G}_I$ is the \emph{interaction graph}, i.e., a graph whose nodes are agents and links represent neighbouring agents, while $\mathcal{G}_C$ is the constraint graph, i.e. a $n$-partite graph whose nodes are all the possible paths $d \in \bigcup_{D \in \mathfrak{D}} D$ generated by the agents and the links indicate the compatibility between paths. 

At this abstraction level, we do not discuss specific implementations of the path generation process, compatibility evaluation or neighbourhood identification since our focus is primarily on presenting a novel algorithm inspired by the DCOP literature to solve an instance of dec-rtRTMP. The interested reader can refer to \cite{DAMATO2024100427} for an example of specific implementation of similar components, presented in full details and in a real setting.

