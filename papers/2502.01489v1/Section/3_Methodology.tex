\section{Methodology}\label{sec:methodology}

\blue{
This section describes the methodology employed to implement the KAN in the analog domain, starting with the selection of basic analog components.
These components, referred to as Analog Building Blocks (ABBs), are designed to perform essential operations such as inversion, subtraction, addition, multiplication, and squaring. 
We explain the design choices behind each operation and discuss how they contribute to the overall system's functionality. 
After covering the ABBs, we outline the hardware implementation approach for spline approximation, highlighting how the chosen formula reduces the number of required blocks and enhances both area and power efficiency.
Finally, we present the KAN implementation derived from these splines, \purple{establishing a systematic framework for an analog approximation of any given function.}}

\subsection{Analog Building Blocks}
\input{FigTab/methodology}
\input{FigTab/schematicABB}

% RCL design, again FE just n-type, hardware friendly
To implement KAN in the analog domain, we started with basic analog components, which we refer to as "Analog Building Blocks". 
These ABBs perform simple mathematical operations and form the foundation of our design approach, in~\autoref{fig:methodology} we present the methodology followed. 
In this section, we present only the ABBs used to approximate second-degree splines(~\autoref{eq:quadratic_formula}). 
However, we have also developed nonlinear functions, such as softmax, sigmoid, and tanh functions, and more complex operators like integrators, which could be applied in future iterations and other applications.

Due to \blue{large feature sizes in the target flexible IGZO technology which only includes N-type transistors}, we adopted a Resistor-Transistor Logic (RTL) design strategy to minimize the number of necessary components for building blocks. 
Another constraint we faced was the limitation to only N-type transistors, resistors, and capacitors. 
Considering these limitations, \autoref{fig:schematicABB} presents our proposed designs for inversion, subtraction, addition, multiplication, and squaring operations.

\textit{Inversion:} we present a design with only two transistors and one resistor. 
The schematic of the design is shown in~\autoref{fig:schematicABB} a).

\textit{Subtraction:} the design uses two transistors, one resistor, and a bias voltage, $V_{bias}$, which is necessary to expand the operating range. 
The schematic of this design is shown in~\autoref{fig:schematicABB} b).

\textit{Addition:} we employ the logic of $A+B=A-(-B)$. We first use the inversion design on $B$, followed by the subtraction design as $A-(-B)$. 
The schematic of this design is shown in~\autoref{fig:schematicABB} c).

\textit{Multiplication:} we base our design on the Gilbert cell~\cite{Pawase:GilbertCell2018,DIAZSANCHEZ:AnalogMulti:2021}, which provides an optimal solution for analog multiplication in the voltage domain. 
We adapted the design to use only N-type transistors and added a final subtraction $V_{dd}-A$ to improve accuracy across multiple values of $A$. 
The schematic of this design is shown in~\autoref{fig:schematicABB} d).

\textit{Squaring:} we further optimized the multiplication design. 
Knowing the input range in advance allows us to anticipate the output range, simplifying design optimization and reducing area and power consumption. 
We removed the final subtraction block, $V_{dd}-A$, and replaced it with a fixed $V_{bias}$. The schematic of this design is shown in~\autoref{fig:schematicABB} e).

\subsection{Implementation of the spline from multiple ABBs}

\input{FigTab/implementation}

For the hardware implementation of each spline, we use the formula presented in~\autoref{eq:quadratic_formula}. 
We chose this equation because it allows us to reduce the number of blocks required, needing only two multiplications, one squaring, and two additions (a total of five blocks). 
In contrast, using~\autoref{eq:bezier_second_order} would require two subtractions, three multiplications, two squaring, and two additions (a total of nine blocks). 
In~\autoref{sec:HardwareCosts}, we present the savings achieved by making this \blue{choice}. 

First, we decompose the expression into three additive sub-blocks: a) $P_{0}$, b) $(P_{1}-P_{0})2x$ and c) $(P_{0}-2P_{1}+P_{2})x^2$.

\begin{itemize}
    \item The first sub-block is simply $P_{0}$, which, as a constant, we interpret as a voltage input. 
    \item The second sub-block consists of $(P_{1}-P_{0})2x$, where $(P_{1}-P_{0})2$ is a constant.
We handle this constant as a voltage input and then multiply it by $x$.
    \item The last sub-block, $(P_{0}-2P_{1}+P_{2})x^2$. Here, $P_{0}-2P_{1}+P_{2}$ is also a constant and will be provided as a voltage input.
To implement this final sub-block, we first square $x$ by multiplying it by itself. We then apply our design shown in~\autoref{fig:schematicABB} e) to perform the multiplication with the constant $(P_{0}-2P_{1}+P_{2})x^2$, which helps to reduce area and power consumption while maintaining precision.
\end{itemize} 
Finally, we sum each of the sub-blocks to construct the spline, resulting in the approximate second-degree function. The full architecture of the implementation is presented in~\autoref{fig:implementation}.

To ensure proper functionality, we carefully designed the input ranges. All ABBs have input ranges from $[-0.5, 0.5]$\orange{, as $[-V_{dd}/2, V_{dd}/2]$}. We need to consider this for the implementation of~\autoref{eq:quadratic_formula}.

For clarity, we examine each of the sub-blocks used to construct the spline, resulting in an approximate second-degree function. Starting with the first sub-block $P_0$, we know there will be no range issues with this term.
For the second sub-block, $(P_1 - P_0) 2x$, we know that $(P_1 - P_0) 2 \in [-0.5, 0.5]$, leading to the first range constraint: 
\begin{equation*}
    P_1 - P_0 \in [-0.25, 0.25]
\end{equation*}
The second range constraint concerns our input $t \in [-0.5, 0.5]$.
For the third sub-block, by reformatting, we obtain:
\begin{equation*}
    P_2 - 2P_1 + P_0 = P_2 - P_1 - (P_1 - P_0)
\end{equation*}

Thus, the range of $P_2 - P_1 - (P_1 - P_0)$ is constrained to $[-0.5, 0.5]$. To determine the range of $P_2 - P_1$, we express it as:
\begin{equation*}
    P_2 - P_1 = (P_2 - 2P_1 + P_0) + (P_1 - P_0)
\end{equation*}

Since the ranges for both $P_2 - 2P_1 + P_0$ and $(P_1 - P_0)$ are known, we can calculate the range of $P_2 - P_1$ by summing the maximum and minimum values of these terms. 

\begin{itemize}
    \item Minimum value of $P_2 - P_1$: 
    \begin{equation*}
        -0.5 + (-0.25) = -0.75
    \end{equation*}
    \item Maximum value of $P_2 - P_1$: 
    \begin{equation*}
        0.5 + 0.25 = 0.75
    \end{equation*}
\end{itemize}

Therefore, we have:
\begin{equation*}
    P_2 - P_1 \in [-0.75, 0.75]
\end{equation*}

Finally, it is important to mention that by considering the trainable values of KAN ($P_{i}$) as inputs in our architecture, the hardware design we present is independent of both the training process and these values. 
Therefore, no redesign is necessary when retraining the model; only the inputs need to be updated. 
For future work, it would be beneficial to perform a co-optimization with fixed $P_{i}$ values, where optimization occurs within each ABB, as was done with the squaring block optimization, based on known input and output ranges. 

\input{FigTab/KAN_from_splines}
\blue{
\subsection{Implementation of the KAN from multiple splines}

Once the splines are created, constructing the KAN requires applying Multiply-Accumulate (MAC) operations.
In analog design, this MAC is achieved by connecting resistors in series with each spline and placing them in parallel to each other.
To implement a weighted MAC, the resistor values can be adjusted according to the desired weighting for each spline.
Alternatively, if uniform weighting is needed, the resistors should have the same value, ensuring each spline contributes equally to the MAC output~\cite{Weller:printedneuron2021}. 
This approach enables flexibility in controlling the contribution of each spline within the KAN structure, aligning with a future co-design. The architecture of the KAN is presented in~\autoref{fig:KAN_from_splines}.
}