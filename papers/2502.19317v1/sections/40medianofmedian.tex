\section{The Median of the Medians Algorithm}\label{sec:mom}
In this section, with the help of the characterization in the previous section, we present an algorithm 
%inspired by the median of medians algorithm 
with a worst-case query complexity of $O(m \log (mn) \log n)$. {Note that if our feasible region were downward-closed, there would be a straightforward algorithm to solve the problem: We could perform a high-dimensional binary search in the bidding space, cutting down the whole strategy space by a constant fraction each time we query a particular strategy. This would lead to \(m \cdot \log(n^m) = m^2 \log n\) queries (since querying one vector of strategies %\(\mathbf{bid}\) 
requires submitting a bidding strategy on each of the \(m\) platforms). Unfortunately, in the example below we show that our feasible region is not necessarily downward-closed. 

\begin{example}
Consider a simple example with two platforms, 1 and 2, both having the following cost and value functions:
\[
c_1(\mu) = \mu \quad v_1(\mu) = \frac{8}{3} \mu;
\]
\[
c_2(\mu) = \mu \quad v_2(\mu) = \mu.
\]
Suppose the constraints are \(B = 10\) and \(T = \frac{1}{2}\). First, observe that \(\mu_1 = \frac{3}{2}\) and \(\mu_2 = 1\) is a feasible solution since:
\[
2 \cdot \left( \frac{3}{2} + 1 \right) = \frac{8}{3} \cdot \frac{3}{2} + 1.
\]
However, if we reduce \(\mu_1\) to 1, we get:
\[
2 \cdot (1 + 1) > \frac{8}{3} + 1,
\]
indicating that the updated bidding strategy is no longer feasible. Therefore, the feasible region is not downward-closed.
\end{example}

Without a downward-closed feasible region, it is unclear which bidding strategy to try or how the search algorithm should proceed to minimize the number of attempts. To address this, we leverage the structure of integral bidding strategies shown in previous section and focus on identifying the \(k\) values corresponding to the maximum feasible \(\bid^k\) first. The potential \(k\) values are the set of marginal costs across all platforms (there are \(mn\) of them). We utilize the ``median of medians'' idea to ensure that we eliminate a constant fraction of marginal cost options with each round of probing.} 

First, given the characterization of the optimal solution, we provide two subroutines that are useful for our algorithm. We first provide a subroutine named \matchingmc, that given a $k$, finds the $\bid^k$ vector via binary search on each platform. We show that the query complexity of this subroutine is $O(m \log n)$. Whenever we call the subroutine, we would make sure that the $\mc_j(\ell_j) \leq k$, i.e., there is at least one strategy in the search range that is feasible. 
% Due to space limitations, we defer the following two proofs to appendix~\ref{app:matchingmc}
\renewcommand*{\algorithmcfname}{SUBROUTINE}
\begin{algorithm}[h]
\DontPrintSemicolon
\LinesNumbered
\SetNoFillComment
\KwIn{search range $[\ell_j, r_j]$ of each $j$, the target MC $k$}
% \textbf{Initialize: $\mu_j \gets 0$ for all $j \in \platform$}
\For{$j \in \platform$}{
    % $\ell_j \gets 0$, $r_j \gets 1$
    
    \While{$\mu^k_j =$ NULL}{
        $\mu_j \gets \frac{\ell_j + r_j}{2}$ for all $j \in \platform$ \tcp*{Binary search on each platform}
        
        \lIf{$\mc_j(\mu_j) \leq k$ }{
        $\ell_j \gets \mu_j$
        }
        
        \lIf{$\mc_j(\mu_j) > k$}{
        $r_j \gets \mu_j - 1$
        }
        \lIf{$r_j \leq \ell_j$}{
        $\mu_j^k \gets \ell_j$
        }
    }
}
\Return{$\bid^k = (\mu^k_1,\mu^k_2,\dots, \mu^k_m)$}
% \SetAlgoRefName{1}
\caption{\matchingmc}
\label{sub:matchingmc}
\end{algorithm}

\begin{lemma}\label{lem:matchingmc}
Given some $k \geq 0$, \matchingmc\ outputs the corresponding $\bid^k$ with at most 

$O(m\log \max_j(r_j - \ell_j))$ queries. 
% \xtnote{assuming $\mc_j(\ell_j) \leq k$ (not sure yet if we want to change the algorithm or keep the assumption in the lemma)}
\end{lemma}
\begin{proof}
The algorithm performs binary search on each platform to find the maximum $\mu$ such that $\mc_j(\mu) \leq k$, since binary search checks $O(\log (r_j - \ell_j))$ number of choice of $\mu$ on each platform and there are $m$ platforms, the query complexity is $O(m \log \max_j(r_j - \ell_j))$.

We now prove the correctness of the algorithm via case analysis, i.e., for each platform $j$, we have $\mu^k_j = \max_{\mu}(\mc_j(\mu) \leq k)$. Fix any arbitrary platform $j$, if $\mc_j(r_j) \leq k$, the algorithm will keep update $\ell_j$ until eventually $\ell_j = r_j$ and correctly set $\mu^k_j = \ell_j = r_j$. On the other hand, if $\mc_j(r_j) > k$, by the termination condition, we know that $\mc_j(\mu^k_j +1) > k$, $\mc_j(\mu^k_j)\leq k$, which corresponds to $\mu^k_j$ being the maximum bid with a marginal cost weakly less than $k$.
\end{proof}

We now provide a subroutine that check if a given integral bidding profile $\bid$ is the almost-optimal solution (defined in Definition~\ref{def:almostoptimal}) or not.
% \mznote{In particular this sentence sounds like we are checking if the solution is approximately optimal. In fact we want to verify if it's the specific solution defined in Section 3.} 
In addition, the subroutine can also check if a bidding profile is $\bid^k$ for some $k$ (defined in Lemma~\ref{lem:opt}). The worst-case query complexity is $O(m)$.

\begin{algorithm}[ht]
\DontPrintSemicolon
\LinesNumbered
\SetNoFillComment
\KwIn{some bidding strategy $\bid$}
% \textbf{Initialize: $\mu_j \gets 0$ for all $j \in \platform$}
query each platform $j$ strategy $\mu_j$, obtain $v_j(\mu_j)$, $c_j(\mu_j)$ and $\mc_j(\mu_j)$

\lIf{$\bid$ is infeasible}{
\Return{\texttt{INFEASIBLE}}
}
$\bar{\jmath} \gets \argmax_{j}[\mc_j(\mu_j)]$

$k \gets \mc_{\bar{\jmath} }(\mu_{\bar{\jmath}})$

\For{$j \in \platform$}{
    $\mu'_j \gets \mu_j + 1$ \tcp*{Check the next $\mc$ value for platform $j$}
    query $\mu'_j$ on platform $j$ obtain $v_j(\mu'_j)$, $c_j(\mu'_j)$ and $\mc_j(\mu'_j)$
    
    \If{$\mc_j(\mu'_j) \leq k$ for any $j \neq \bar{\jmath} $\label{line:counterk}}{
\Return{\texttt{NOT-$\bid^k$} \tcp*{$\bid$ is not $\bid^k$ for some $k$}\label{line:notmuktermination}}
}
  }  
    $j^* \gets \argmin_{j}(\mc_j(\mu'_j))$ \tcp*{find the minimum among the next points}
    
    $\mu_{j^*} \gets \mu'_{j^*}$
    
    \lIf{$\bid$ is infeasible \tcp*{the updated $\bid$ is not feasible}}{
    \Return{\texttt{ALMOST-OPTIMAL}}}
    \lElse{\Return{\texttt{NOT-OPTIMAL}}}

% \Return{$\bid^k = (\mu^k_1,\mu^k_2,\dots, \mu^k_m)$}
% \SetAlgoRefName{1}
\caption{\optcheck}
\label{sub:optcheck}
\end{algorithm}
\renewcommand*{\algorithmcfname}{ALGORITHM}

\begin{lemma}\label{lem:optcheck}
Given a bidding profile $\bid$, the subroutine \optcheck\ determines if the given $\bid$ is \texttt{INFEASIBLE}, \texttt{NOT $\bid^k$}, \texttt{NOT-OPTIMAL} or \texttt{ALMOST-OPTIMAL} with at most $O(m)$ queries.
\end{lemma}
\begin{proof}
Since \optcheck\ queries at most 2 strategies from each platform, the worst-case number of queries used is \(2m = O(m)\). We now prove the correctness of the subroutine for each different case. The \texttt{INFEASIBLE} case is trivial. For the \texttt{NOT-$\bid^k$} case, as indicated by line~\ref{line:counterk}, since there exists a platform where \(\mc_j(\mu_j + 1) \leq k\), we know that the given bidding profile \(\bid\) is not \(\bid^k\) for some \(k\) by definition. On the other hand, if \optcheck\ does not terminate in line~\ref{line:notmuktermination}, it means \(\bid\) is feasible and \(\bid = \bid^k\) for some \(k\). To check if the given profile is almost-optimal (the floor of $\optf$), by Lemma~\ref{cor:opt}, we just need to verify whether increasing \(k\) would make \(\bid^k\) infeasible. If the next immediate change would cause \(\bid\) to be infeasible, then \(\bid\) is \texttt{ALMOST-OPTIMAL}; otherwise, it is \texttt{NOT-OPTIMAL}. 
% \xtnote{maybe elaborate more on the last two cases}
\end{proof}
% \subsection{The \mom\ algorithm}
We are now ready to present our algorithm, \mom. This algorithm finds the \emph{almost-optimal integral solution} by searching within the marginal cost space and then converts this almost-optimal integral solution to the optimal fractional solution using the \roundup\ procedure. The search process is inspired by the median-of-medians algorithm. In each iteration, we first identify the median marginal cost for each platform, and then select the median that most evenly splits the space, i.e., ensuring that the number of marginals weakly smaller than this median is equal to the number of marginals weakly larger than it.

Next, we use \matchingmc\ to determine the corresponding bidding profile $\bid^k$ with the median-of-the-medians marginal as the $k$-value, and apply \optcheck\ to evaluate the quality of the bidding profile $\bid^k$. Based on the result from \optcheck($ \bid^k $), we can eliminate a constant fraction of the remaining candidates for the optimal marginal costs. This process is repeated iteratively until we find an almost-optimal solution. Finally, we apply the \roundup\ procedure to obtain the fractional optimal solution. For a formal description, please refer to Algorithm~\ref{alg:mom}.

\begin{figure}[h]
\begin{center}  % Center the figure within the column
    \resizebox{0.45\textwidth}{!}{  % Resize to fit within a single column
        \begin{tikzpicture}

            % Parameters for grid layout
            \def\circleRadius{0.05}   % Radius of each circle
            \def\dotRadius{0.01}     % Radius of the smaller dots
            \def\vspacing{0.4}       % Vertical spacing between circles
            \def\hspacing{0.5}       % Horizontal spacing between platforms
            \def\platforms{7}        % Number of platforms
            \def\circlesPerPlatform{5} % Circles per vertical line
            
            % Loop to draw platforms
            \foreach \col in {1,...,\platforms} {
                
                % Adjust for the first 4 platforms: skip the first and last circle
                \ifnum\col<5
                    % Draw the circles, skipping first and last
                    \foreach \row in {2,...,4} {
                        % Position of each circle
                        \node[circle, draw, fill=white, minimum size=\circleRadius cm] 
                        at (\col*\hspacing, \row*\vspacing) {};
                    }
                \else
                    % Draw all the circles for the remaining platforms
                     \foreach \row in {1,...,\circlesPerPlatform} {
                        % Check for the fifth platform (col = 5) and the third row (row = 3)
                        \ifnum\col=5\relax
                            \ifnum\row=3\relax
                                % Fill the 3rd circle of the fifth column with grey
                                \node[circle, draw, fill=gray, minimum size=\circleRadius cm] 
                                at (\col*\hspacing, \row*\vspacing) {};
                            \else
                                % Regular circles for the rest
                                \node[circle, draw, fill=white, minimum size=\circleRadius cm] 
                                at (\col*\hspacing, \row*\vspacing) {};
                            \fi
                        \else
                            % Regular circles for other columns
                            \node[circle, draw, fill=white, minimum size=\circleRadius cm] 
                            at (\col*\hspacing, \row*\vspacing) {};
                        \fi
                    }
                \fi
                
            }
        % Draw the upward arrow
    \draw[->, >=latex] (0,1.7) -- (0,0.7) node[above] {};
    
    % Add the vertical text "increasing mc" to the right of the arrow
    % \node[right] at (-0.2,0.4) [rotate=90] {\footnotesize increasing mc};
    
    \draw[->,>=latex] (1,0) -- (3,0) node[right] {};
    
    \node[below] at (2,0) {\tiny increasing median marginal cost};    
    
    % Draw a square with rounded corners and a pattern fill
    \filldraw[pattern=north east lines, rounded corners=5pt, thick] 
        (2.3,0.2) -- (3.7,0.2) -- (3.7,1.4) -- (2.3,1.4) -- cycle;
        
    \draw[rounded corners=5pt, thick] 
        (0.3,1) -- (2.7,1) -- (2.7,2.2) -- (0.3,2.2) -- cycle;
            
        \end{tikzpicture}
    }
\end{center}
\caption{Illustration of one round of \mom. Each column represents the current search region of a platform. The vertical arrow indicates the increasing direction of $\mu$ in each platform. The platforms are ranked by the median marginals as described in the algorithm. The grey point represents the queried $k$ value. If $\bid^k$ is infeasible, all strategies in the shaded round rectangle are removed; otherwise, all strategies in the non-shaded one are removed.}
\end{figure}





\begin{algorithm}[h]
\DontPrintSemicolon
\LinesNumbered
\SetNoFillComment
% \KwIn{}
\textbf{Initialize: $\ell_j \gets 1$, $r_j \gets n$ for all $j \in \platform$}

\While{TRUE}{
$\mu_j \gets \frac{\ell_j + r_j}{2}$ for all $j \in \platform$

query each platform $j$ strategy $\mu_j$, obtain $v_j(\mu_j)$, $c_j(\mu_j)$ and $\mc_j(\mu_j)$


rank the platforms in non-decreasing order of $\mu_j$ s.t. if $i \leq j$, $\mu_i \leq \mu_j$\label{line:ranking}

$j^* \gets \min_{j}(|\sum_{i \leq j} (r_i - \ell_i) - \sum_{i \geq j}(r_i - \ell_i)|)$ \tcp*{find the $j^*$ that equally split the search space}

%$k \gets \mc_{j^*}(\mu_{j^*})$

% $k \gets \text{Median}(\{\mc_j(\mu_j)| j \in \platform\})$

%$\bid* \gets \matchingmc([\ell_j, r_j] \text{ for all } j \in \platform, k)$ %\tcp*{$O(m \log \frac{1}{\epsilon})$ queries} 

$\bid^* \gets \matchingmc([1, n] \text{ for all } j, \mc_{j^*}(\mu_{j^*}))$

\uIf{$\optcheck(\bid^*)$ = \texttt{INFEASIBLE}}{
$r_j \gets \mu_j-1$ for all $j \geq j^*$ \tcp*{reduce the search space}\label{line:cutright}
}

\uElseIf{$\optcheck(\bid^*)$ = \texttt{NOT-OPTIMAL}}
{$\ell_j \gets \mu_j+1$ for all $j\leq j^*$}\label{line:cutleft}

\uElseIf{$\optcheck(\bid^*)$ = \texttt{ALMOST-OPTIMAL}}
{\Return{\roundup($\bid^*$)}
}
}
\SetAlgoRefName{1}
\caption{\mom}
\label{alg:mom}
\end{algorithm}
In the rest of the section, we prove the correctness and query complexity of the algorithm. 

\begin{theorem}\label{thm:medianofmedians}
Given any instance $\mathcal{I}$, the \mom\ algorithm finds the fractional optimal bidding strategy with at most $O(m \log mn \log n)$ queries.
\end{theorem}
\begin{proof}
We first prove the correctness of the algorithm. By Lemma~\ref{cor:opt} we know that the almost-optimal integral bidding strategy correspond to $\bid^{k^*}$ where $k^*$ is the maximum $k$ such that $\bid^k$ is feasible. 
We prove the correctness of the algorithm by first showing that during the execution of the algorithm, there always exist some $\mu \in [\ell_j, r_j]$, of which the $\bid^{\mc_j(\mu)} = \bid^{k^*}$. 
In other words, the algorithm can not eliminate the critical marginal cost $\mc_j(\mu)$ that corresponds to $\bid^{k^*}$.
Consider the possible updates of $\ell_j$ and $r_j$ for each platform $j$, i.e., Line~\ref{line:cutright} and Line~\ref{line:cutleft}. 
First consider any iteration such that $\optcheck(\bid^*) = \texttt{INFEASIBLE}$, and for all platforms $j \geq j^*$ w.r.t to the ranking defined in Line~\ref{line:ranking}, we have $\mc_j(\mu_j) \geq \mc_{j^*}(\mu_{j^*})$. 
By monotonicity, for any $\mu \geq \mu_j$ on platform $j$ we have:
\[\mc_j(\mu) \geq \mc_j(\mu_j) \geq \mc_{j^*}(\mu_{j^*}),\]
By Lemma~\ref{lem:opt}, since $\optcheck(\bid^*) = \texttt{INFEASIBLE}$, we would also have $\bid^{\mc_j(\mu)}$ is infeasible for $\mu \geq \mu_j$ for platforms $j \geq j^*$. 
Therefore, Line~\ref{line:cutright} does not remove any $\mu$ of which $\bid^{\mc_j(\mu)} = \bid^{k^*}$.

Next consider any iteration such that $\optcheck(\bid^*) = \texttt{NOT-OPTIMAL}$, and for all platforms $j \leq j^*$ w.r.t to the ranking defined in Line~\ref{line:ranking}, we have $\mc_j(\mu_j) \leq \mc_{j^*}(\mu_{j^*})$. Again by monotonicity, for any $\mu \leq \mu_j$ on platform $j$ we have:
\[\mc_j(\mu) \leq \mc_j(\mu_j) \leq \mc_{j^*}(\mu_{j^*}),\]
By Lemma~\ref{lem:opt}, since $\optcheck(\bid^*) = \texttt{NOT-OPTIMAL}$, we have $\bid^{\mc_j(\mu)}$ is also feasible and not optimal for $\mu \leq \mu_j$ for platforms $j \leq j^*$. Therefore Line~\ref{line:cutleft} does not remove any $\mu$ of which $\bid^{\mc_j(\mu)} = \bid^{k^*}$ as well. 
% Therefore the algorithm does not remove any $\mu$ of which $\bid^{\mc_j(\mu)} = \bid^{k^*}$ during the execution.
In addition, it is easy to see that $\bid^{\mc_j(\mu)} = \bid^{k^*}$ for some platform $j$ and some strategy $\mu$. (let $\mc_j(\mu) = \argmax (\mc_j(\mu^{k^*}_j))$). And since the set of bids is finite and getting strictly smaller in each round, the algorithm will eventually terminate with the almost-optimal integral bidding solution $\bid^{k^*}$, after which applying $\roundup$ would give us the fractional optimal solution.

We now prove the query complexity of the algorithm. In particular, we argue that the while loop would iterate no more then $O(\log (mn))$ times. Together with the $O(m \log n)$ query complexity of \matchingmc\ this would show that the query complexity of the algorithm is $O(m \log (mn) \log n)$. First note that there are in total $m\cdot n$ possible marginal costs ($\mc_j(\mu)$ for all $j$ and $\mu$). By definition of $j^*$, and $\mu_j$ for each platform $j$, we have that  
$\min(|\{\mc_i(\mu): i \leq j^* \text{ and } \mu \leq \mu_i\}|, |\{\mc_i(\mu): i \geq j^* \text{ and } \mu \geq \mu_i\}|) \geq \frac{\sum_{j}(r_j - \ell_j)}{4} - \min_j(r_j - \ell_j) = O(\sum_{j}(r_j - \ell_j))$. Since we remove a constant fraction of choices in each round, the number of queries is no more then $O(\log mn)$. Lastly note that \roundup\  makes at most $m$ queries, making the total queries needed for \mom\ $O(m \log (mn) \log n)$.
\end{proof}