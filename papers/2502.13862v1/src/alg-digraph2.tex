\begin{algorithm}[hbtp]
\caption{Our Directed Graph using CP2AA allocator (Part 2).}
\label{alg:digraph2}
\begin{algorithmic}[1]
\algrestore{alg:digraph12}
\State $\rhd$ Add a vertex to the graph
\Function{addVertex}{$u$} \textbf{of} DiGraph \label{alg:digraph--add-vertex-begin}
  \If{$u \geq CAP$} $reserve(u + 1)$
  \EndIf
  \State $setBit(exists, u)$
\EndFunction \label{alg:digraph--add-vertex-end}

\Statex

\State $\rhd$ Allocate space for outgoing edges of a vertex
\Function{allocateEdges}{$u, deg$} \textbf{of} DiGraph \label{alg:digraph--allocate-edges-begin}
  \If{$u \geq CAP$ \textbf{or} $edges[u] \neq \phi$} \ReturnInline{}
  \EndIf
  \State $bytes \gets cp2aa.allocationSize(deg * \textsc{edge\_size})$
  \State $edges[u] \gets cp2aa.allocate(bytes)$
  \State $capacities[u] \gets bytes / \textsc{edge\_size}$
\EndFunction \label{alg:digraph--allocate-edges-end}

\Statex

\State $\rhd$ Add an outgoing edge, without checks
\Function{addEdgeUnsafe}{$u, v, w$} \textbf{of} DiGraph \label{alg:digraph--add-edge-unsafe-begin}
  \State $ptr \gets edges[u]$
  \State $i \gets atomicAdd(degrees[u], 1)$
  \State $ptr[i] \gets (v, w)$
\EndFunction \label{alg:digraph--add-edge-unsafe-end}

\Statex

\State $\rhd$ Add outgoing edges to a vertex
\Function{addEdges}{$u, list$} \textbf{of} DiGraph \label{alg:digraph--add-edges-begin}
  \If{\textbf{not} $hasVertex(u)$ \textbf{or} $list = \{\}$} \ReturnInline{$0$}
  \EndIf
  \State $deg_{prev} \gets degrees[u]$
  \State $deg_{max} \gets degrees[u] + size(list)$
  \State $bytes \gets cp2aa.allocationCapacity(deg_{max})$
  \State $ptr \gets cp2aa.allocate(bytes)$
  \State $degrees[u] \gets \textit{setUnion}(edges(u), list, \textbf{into}\ ptr)$
  \State $cp2aa.deallocate(edges[u], capacities[u] * \textsc{edge\_size})$
  \State $edges[u] \gets ptr$
  \State $capacities[u] \gets bytes / \textsc{edge\_size}$
  \Return{$degrees[u] - deg_{prev}$}
\EndFunction \label{alg:digraph--add-edges-end}

\Statex

\State $\rhd$ Remove outgoing edges from a vertex
\Function{removeEdges}{$u, list$} \textbf{of} DiGraph \label{alg:digraph--remove-edges-begin}
  \If{\textbf{not} $hasVertex(u)$ \textbf{or} $list = \{\}$} \ReturnInline{$0$}
  \EndIf
  \State $deg_{prev} \gets degrees[u]$
  \State $degrees[u] \gets \textit{setDifference}(\textbf{into}\ edges(u), list)$
  \Return{$deg_{prev} - degrees[u]$}
\EndFunction \label{alg:digraph--remove-edges-end}

\Statex

\State $\rhd$ Update the graph after changes
\Function{update}{$isUnique, isSorted$} \textbf{of} DiGraph \label{alg:digraph--update-begin}
  \State $\rhd$ Ensure edges are sorted and unique
  \If{\textbf{not} $isSorted$}
    \ForAll{$u \in [0, CAP)$ \textbf{in parallel}}
      \State $sortByKey(edges[u], degrees[u])$
    \EndFor
  \EndIf
  \If{\textbf{not} $isUnique$}
    \ForAll{$u \in [0, CAP)$ \textbf{in parallel}}
      \State $uniqueByKey(edges[u], degrees[u])$
    \EndFor
  \EndIf
  \State $\rhd$ Update counts of vertices and edges
  \State $N \gets M \gets 0$
  \ForAll{$u \in [0, CAP)$ \textbf{in parallel}}
    \If{\textbf{not} $getBit(exists, u)$} \textbf{continue}
    \EndIf
    \State $N \gets N + 1$ \textbf{;} $M \gets M + degrees[u]$
  \EndFor
\EndFunction \label{alg:digraph--update-end}
\end{algorithmic}
\end{algorithm}
