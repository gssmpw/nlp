\begin{algorithm}[hbtp]
\caption{A variable-capacity Arena Allocator (AA).}
\label{alg:aa}
\begin{algorithmic}[1]
\Require{$\textsc{alloc\_size}_a$: Size of each allocation (constant)}
\Require{$\textsc{pool\_size}_a$: Size of each memory pool (constant)}

\Statex

\State \textbf{struct} $AA \langle \textsc{alloc\_size}_a, \textsc{pool\_size}_a \rangle ()$
\State \ \ $\textsc{alloc\_size} \gets \textsc{alloc\_size}_a$ \Comment{Size of each allocation} \label{alg:aa--init-const-begin}
\State \ \ $\textsc{pool\_size} \gets \textsc{pool\_size}_a$ \Comment{Size of each memory pool} \label{alg:aa--init-const-end}
\State \ \ $freed \gets \{\}$ \Comment{Freed allocations, can be reused} \label{alg:aa--init-begin}
\State \ \ $used \gets \textsc{pool\_size}$ \Comment{Bytes used in the last memory pool}
\State \ \ $pools \gets \{\}$ \Comment{Memory pools} \label{alg:aa--init-end}

\Statex

\State $\rhd$ Allocate memory, of size $\textsc{alloc\_size}$
\Function{allocate}{$ $} \textbf{of} AA
  \State $\rhd$ Allocate from freed list, if available
  \If{$freed \neq \{\}$} \ReturnInline{$freed.pop()$} \label{alg:aa--allocate-freed}
  \EndIf
  \State $\rhd$ Allocate from pool
  \If{$used < \textsc{pool\_size}$} \label{alg:aa--allocate-pool-begin}
    \State $ptr \gets pools.last() + used$
    \State $used \gets used + \textsc{alloc\_size}$
    \Return{$ptr$}
  \EndIf \label{alg:aa--allocate-pool-end}
  \State $\rhd$ Allocate a new pool
  \State $ptr \gets$ Allocate $\textsc{pool\_size}$ bytes \label{alg:aa--allocate-newpool}
  \If{$ptr \neq \phi$} \label{alg:aa--allocate-new-begin}
    \State $pools.push(ptr)$
    \State $used \gets \textsc{alloc\_size}$
    \Return{$ptr$}
  \EndIf \label{alg:aa--allocate-new-end}
  \Return{$\phi$} \label{alg:aa--allocate-fail}
\EndFunction

\Statex

\State $\rhd$ Free allocated memory
\Function{deallocate}{$ptr$} \textbf{of} FAA
  \State $freed.push(ptr)$ \label{alg:aa--deallocate-push}
\EndFunction

\Statex

\State $\rhd$ Free all allocated memory
\Function{reset}{$ $} \textbf{of} FAA
  \State $freed \gets \{\}$ \label{alg:aa--reset-freedused-begin}
  \State $used \gets 0$ \label{alg:aa--reset-freedused-end}
  \ForAll{$ptr \in pools$} \label{alg:aa--reset-pools-begin}
    \State Free memory at $ptr$
  \EndFor \label{alg:aa--reset-pools-end}
\EndFunction
\end{algorithmic}
\end{algorithm}
