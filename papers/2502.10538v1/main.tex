%% LaTeX Template for ISIT 2025
%%
%% by Stefan M. Moser, October 2017
%% (with minor modifications by Tobias Koch, November 2023 and MichÃ¨le Wigger, November 2024)
%% 
%% derived from bare_conf.tex, V1.4a, 2014/09/17, by Michael Shell
%% for use with IEEEtran.cls version 1.8b or later
%%
%%
%% http://www.michaelshell.org/tex/ieeetran/
%% http://moser-isi.ethz.ch/manuals.html#eqlatex
%% http://www.ctan.org/tex-archive/macros/latex/contrib/IEEEtran/
%%

\documentclass[conference,letterpaper]{IEEEtran}




%% depending on your installation, you may wish to adjust the top margin:
\addtolength{\topmargin}{9mm}

%% Please note that the amsthm package must not be loaded with
%% IEEEtran.cls because IEEEtran provides its own versions of
%% theorems. Also note that IEEEXplore does not accepts submissions
%% with hyperlinks, i.e., hyperref cannot be used.


% package list 
\usepackage[utf8]{inputenc} 
\usepackage[T1]{fontenc}
\usepackage{url}
\usepackage{ifthen}
\usepackage{cite}
\usepackage[cmex10]{amsmath} % Use the [cmex10] option to ensure complicance
%                              % with IEEE Xplore (see bare_conf.tex)

% JUSTIN'S ADDED PACKAGES ~~~~~~~~~~~~~~
\usepackage{xcolor}
\usepackage{bbm}

\usepackage{mdframed}
%\usepackage[subtle]{savetrees}


\newenvironment{weirdFrame}[1]
  {\mdfsetup{
    frametitle={\colorbox{white}{\space#1\space}},
    innertopmargin=0pt,
    skipabove=\topskip, skipbelow=\topskip,
    nobreak=true,
    frametitleaboveskip=-\ht\strutbox,
    frametitlealignment=\center
    }
  \begin{mdframed}%
  }
  {\end{mdframed}}
  


% theorem def
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{construction}[theorem]{Construction}
\newtheorem{assumption}[theorem]{Assumption}

\let\proof\IEEEproof
% JUSTIN'S ADDED PACKAGES (END) ~~~~~~~~~~~~~~



%%%%%%
% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}

% ------------------------------------------------------------
\begin{document}

\newcommand{\justin}[1]{\textcolor{blue}{#1}}

\interdisplaylinepenalty=2500 % As explained in bare_conf.tex
\title{Amortized Locally Decodable Codes} 




% %%% Single author, or several authors with same affiliation:
\author{%
 \IEEEauthorblockN{Jeremiah Blocki and Justin Zhang}
\IEEEauthorblockA{Department of Computer Science\\
                   Purdue University\\
                   West Lafayette, IN\\
                   Emails: \texttt{\{jblocki,zhan3554\}@purdue.edu}}}

\newcommand{\LCC}{\msf{LCC}}

\maketitle

\input{full_paper/macros}
\begin{abstract}
% THIS PAPER IS ELIGIBLE FOR THE STUDENT PAPER AWARD.
Locally Decodable Codes (LDCs) are error correcting codes that admit efficient decoding of individual message symbols without decoding the entire message. 
Unfortunately, known LDC constructions offer a sub-optimal trade-off between rate, error tolerance and locality, the number of queries that the decoder must make to the received codeword $\tilde {\by}$ to recovered a particular symbol from the original message $\bx$, even in relaxed settings where the encoder/decoder share randomness or where the channel is resource bounded. 
We initiate the study of Amortized Locally Decodable Codes where the local decoder wants to recover multiple symbols of the original message $\bx$ and the total number of queries to the received codeword $\tilde{\by}$ can be amortized by the total number of message symbols recovered. 
We demonstrate that amortization allows us to overcome prior barriers and impossibility results. 
We first demonstrate that the Hadamard code achieves amortized locality below $2$ --- a result that is known to be impossible without amortization. 
Second, we study amortized locally decodable codes in cryptographic settings where the sender and receiver share a secret key or where the channel is resource-bounded and where the decoder wants to recover a consecutive subset of message symbols $[L,R]$. 
In these settings we show that it is possible to achieve a trifecta: constant rate, error tolerance and constant amortized locality. 
\end{abstract}
\section{Introduction}
Locally Decodable Codes ($\LDC$s) are error correcting codes that admit fast single-symbol decodability after making a small number of queries to the received (possibly corrupted) codeword $\tilde{\by}$. In particular, an $(n,k)$-code over an alphabet $\Sigma$ is an $(\ell,\delta,\eps)$-\LDC\ if there exists a pair of sender/receiver algorithms $\Enc: \Sigma^k \rightarrow \Sigma^n$ encoding messages of length $k$ to codewords of length $n$, and $\Dec^{\tilde{\by}}: [k] \rightarrow \Sigma$ decoding any requested single message index $i \in [k]$ where $[k] := \{1,2,\dots,k\}$.  We require that for all messages $\bx$ and received word $\tilde {\by},$ the decoder makes at most $\ell$ queries to $\tilde {\by}$ and if the hamming distance $d(\Enc(\bx),\tilde {\by}) \leq \delta n$ i.e the error caused by an adversarial channel is at most $\delta n$, we require that the decoder is correct with probability at least $1 - \eps$ i.e $\Pr[\Dec^{\tilde {\by}}(i) = \bx_i] \geq 1 -\eps.$  The main parameters of interest in \LDC s are the {\em rate} $R := k / n$,  {\em locality} $\ell$, and {\em error-rate tolerance} $\delta$.
For instance, $\LDC$ s can be used to store files, where we want the rate to be small to limit storage overhead, the error-tolerance to be high for fault tolerance, and locality to be low for ultra-efficient recovery of any portion of the file.

The trade-offs between rate, locality, and error tolerance within \LDC s for (worst-case) classical errors have been extensively studied yet achievable parameters remain sub-optimal and undesirable.
Ideally, we would like an \LDC\ which achieves constant rate, constant locality, and constant error-rate tolerance simultaneously.
However, any \LDC\ with constant locality $\ell \geq 2$ or constant error tolerance $\delta > 0$ must have at least non-linear rate \cite{STOC:KatTre00}, where the best known constructions (e.g Hadamard and matching vector codes) have super-polynomial rate \cite{LDCSURVEY}.
In particular, for locality $\ell = 2$, we have constructions, but at the same time, any construction must have exponential rate \cite{LDCSURVEY, STOC:KerdWo03,CCC:GKST06,FOCS:BenRegdWo08}.
Katz and Trevisan show further that there do not exist \LDC\ for $\ell < 2$ even when the rate is allowed to be exponential\cite{STOC:KatTre00}.
It is easy to verify that their result further extends to settings where the error-rate is $\delta = o(1)$ e.g $\delta = O(1/n^{.99}).$
In other words, a local decoder must read {\em at least twice} as much information as requested in the setting of worst-case errors.

Various relaxations have been introduced to deal with these undesirable trade-offs for classical \LDC s.
For example, Ben-Sasson et al. introduced the notion of a relaxed \LDC s\cite{STOC:BGHSV04}, allowing the decoder to reject (output $\bot$) instead of outputting a codeword symbol whenever it detects error.
This was further expanded by Gur et al. to study locally {\em correctable} codes where the decoder returns symbols of the codeword instead of the message \cite{ITCS:GurRamRot18}.
Another line of work studies \LDC s that allow a sender and receiver to share a secret key that is unknown to the computationally-bound channel \cite{EPRINT:OstPanSah07,C:HemOst08,public_key_ldc_w_short_keys}.
Yet another line of work considers \LDC s in settings where the channel is resource bounded (e.g it cannot evaluate circuits beyond a particular size/depth) \cite{ITC:BloKulZho20}.

However, even with these relaxations, the achievable trade-offs are still sub-optimal.
For relaxed locally decodable/correctable codes respectively, Ben-Sasson et al. and Gur et al. are able to achieve \LDC/\LCC\ constructions with constant locality and constant error-tolerance codes, but with sub-optimal codeword length $n = O\left(k^{1 + O(1)/\sqrt \ell}\right)$ \cite{SODA:ChiGurShi20, STOC:BGHSV04}.
Gur et al. also prove that any relaxed \LDC\ must have codeword length $n = \Omega\left(k^{1 + c}\right)$, where $c = 1 / O\left(\ell^2\right)$ \cite{SODA:GurLac20}, ruling out any possibility of having constant rate, constant locality, and constant error-tolerance.
In fact, any relaxed \LDC\ with constant error tolerance, perfect completeness, and locality $\ell = 2$ must have exponential rate \cite{CCC:BBCGLZZ23}. 
Moreover, constructions for relaxed \LDC s with constant error-rate tolerance, constant rate, and locality $\ell = O(\polylog(k))$ are unknown.
While these parameters {\em are} possible in the shared-cryptographic-key \cite{EPRINT:OstPanSah07,C:HemOst08,public_key_ldc_w_short_keys} and resource-bounded-channel settings \cite{SCN:AmeBloBlo22,ITC:BloKulZho20}, there are no constant rate, constant error-rate tolerance, constant locality constructions.

Traditionally, in \LDC\ literature, the decoder is tasked with recovering the symbol or bit at a single index.
However, most practical applications desire the recovery of a much larger portion of the message.
For example, the local decoder may want to recover the symbol $\bx_i$ for {\em every} index $i \in Q$ for some set $Q \subseteq [k]$.
The natural and naive way to accomplish this task would be to run a local decoder $|Q|$ times separately for each $i \in Q$, but the total query complexity will be $\ell |Q|$. 
In this paper, we ask the following natural question: is it possible to improve the total query complexity beyond that of the naive solution by designing a decoder that attempts to decode all requested symbols in one run, {\em amortizing} the number of queries?

{\bf Our Contributions:} 
We initiate the study of {\em amortized locally decodable codes} which seek to reduce query complexity by amortizing the local decoding process. 
Given a set $Q \subseteq [k]$, the local decoding algorithm $\Dec^{\tilde{\bY}}(Q)$ should output $\{\bx_i\}_{i \in Q}$ where the amortized query complexity $\alpha$ is given by the total number of queries made by the decoder $\ell$ divided by the total number of message symbols recovered i.e., $\alpha = \ell/|Q|$.  

We first show that the Hadamard code \cite{LDCSURVEY} can achieve {\em amortized} locality $\alpha < 2$. 
In fact, if the the error-rate is $\delta=o(1)$ then the amortized locality approaches $1$. 
This stands in stark contrast to the impossibility results of Katz and Trevisan who proved that, without amortization, any LDC must have $\ell \geq 2$ even if $\delta=o(1)$.  

Second, we study amortized locally decodable codes in cryptographic settings where the sender and receiver share a secret key. 
We show that when the decoder wants to recover a {\em consecutive} subset of bits $[L,R] \subset [k]$ that it is possible to achieve {\em constant rate, constant error tolerance and constant amortized locality}. 
To the best of our knowledge this is the first construction which achieves all three goals simultaneously, even in the setting where the sender/receiver share a secret key. 

Finally, we can apply the framework of \cite{SCN:AmeBloBlo22,ITC:BloKulZho20,ISIT:BloBlo21} to remove the assumption that the sender and receiver share a secret key as long as the channel is resource bounded and is unable to solve cryptographic puzzles. As Blocki et al. \cite{ITC:BloKulZho20} argued, resource bounded channels can plausibly capture any error pattern that arises naturally, that is, real-world channels are resource bounded. For example, suppose that $A$ denotes a randomized algorithm that models the error pattern of our channel. If the channel has small latency then we can reasonably assume that the algorithm $A$ must have low-depth --- there may be many computational steps if the algorithm $A$ is parallel, but the depth of the computation is bounded. This means that a low-latency channel would be incapable of solving  time-lock puzzle \cite{rivest1996time} --- cryptographic puzzles that are solvable in $t$ sequential computation steps, but cannot be solved in $o(t)$ time by any parallel algorithm running in polynomial time. One can also design cryptographic puzzles that are space-hard meaning that they cannot be solved by any probabilistic polynomial time algorithm using space $o(s)$, but can be solved easily using space $s$. Additionally, other categories of resource-bounded cryptographic puzzles exist, such as memory-hard \cite{SCN:AmeBloBlo22}, space-hard puzzles, which impose constraints on time-space complexity and space complexity respectively. Ameri et al. \cite{SCN:AmeBloBlo22} showed how to use cryptographic puzzles and secret key LDCs to construct resource-bounded LDCs with constant rate, constant error tolerance, but their locality is $O(\text{polylog} (k))$. We demonstrate that this construction achieves amortized locality $O(1)$ if we use our amortizable secret key LDC.  
\section{Amortized Locality}\label{sect:aLDC}
We provide the first formalization of amortized locally decodable codes. 
We say two strings $g$ and $h$ of the same length are $\delta$-close if $g$ has hamming distance at most $\delta |g|$ from $h$.
    \input{paLDC/aLdcDef}
An $(\alpha,\kappa,\delta,\eps)$-\aLDC\ permits that the decoder make up to $|Q| \alpha$ total queries when attempting to decode the target symbols in the set $Q$. The amortized number of queries per symbol is just $\alpha$, but because the decoder may make up to $|Q| \alpha$ queries in total, it may be possible to circumvent classical barriers and impossibility results. 

As a first motivation for \aLDC s we first consider an impossibility result of Katz and Trevisan \cite{STOC:KatTre00} who proved that any LDC must have locality $\ell \geq 2$. In particular, they proved that for any $(1,\delta,\epsilon)$-\LDC\ we have $k \leq \frac{\log |\Sigma|}{\delta(1- H(1/2 + \eps))}$ where $H(\cdot)$ is the entropy function in base $|\Sigma|$. Even if we set the error-tolerance to $\delta = 1/\sqrt{k}$, so that $\delta=o(1)$, we still have the constraint that $\sqrt{k} \leq \frac{\log |\Sigma|}{1-H(1/2+\epsilon)}$. Thus, it is impossible to construct a $(1,\delta,\epsilon)$-\LDC\ which supports arbitrarily long messages in $\Sigma^k$. It follows that any $\LDC$ construction that supports long messages must have locality $\ell \geq 2$. We show that it is possible to break this barrier by amortizing the decoding costs across multiple queries and achieve amortized locality $1+ O(\delta/\epsilon)$. Note that if $\epsilon$ is a constant and $\delta=o(1)$, the amortized locality is $1+o(1)$, that is, the amortized locality approaches $1$. In fact, we show that the Hadamard code already achieves these properties \cite{hadamard} --- see Theorem \ref{thm:hadamard}.

The Hadamard code encodes binary messages $\bx \in \{0,1\}^k$ of length $k$ to binary codewords $\by$ of length $2^k$, where each codeword bit corresponds to a XOR of message bit subsets, $\by_S := \oplus_{i \in S} \bx_i, \forall S \subseteq [k]$. More precisely, $\Enc(\bx) = \langle \by_S \rangle_{S\subseteq [k]} \in \{0,1\}^{2^k}$ where $\by_S := \oplus_{i \in S} \bx_i$. We show that by extending a simple idea from a traditional single bit local decoder, we can have amortize beyond what is possible for traditional locality. 

A simple decoder achieving $2$-locality for Hadamard codes decodes any message bit index $i$ by selecting a random subset $S \subseteq [k]$, computing the subset $S_i := S \Delta \{i\}$ ($\Delta$ denotes symmetric-difference), querying the received codeword $\tilde{\by}$ at the indices corresponding to $S$ and $S_i$ to obtaining $\tilde{\by}_S$ and $\tilde{\by}_{S_i}$ and then outputting $\tilde{\by}_S \oplus \tilde{\by}_{S_i}$. If the error-rate is set to $\delta,$ then by a union bound, with probability at least $1 - 2 \delta$ we have $\tilde{\by}_S = \by_S$ and $\tilde{\by}_{S_i} = \by_{S_i}$ i.e., both queried bits are correct. If both queried bits are correct, then the decoder will succeed as $\tilde{\by}_S \oplus \tilde{\by}_{S_i} = {\by}_S \oplus \by_{S_i}= \bx_i$. 

If we want to recover multiple message bits, then we can instead pick a random set $S$ and then query to obtain $\tilde{\by}_S$ and $\tilde{\by}_{S_j}$ for all $j \in Q$. The total number of queries will be $|Q|+1$ so the amortized locality is just $1+1/|Q|$. By union bounds we will have $\tilde{\by}_S = \by_S$ and $\tilde{\by}_{S_j} = \by_{S_j}$ for all $j \in Q$ with probability at least $1-\delta(|Q|+1)$. These observations lead to Theorem \ref{thm:hadamard}. 
\begin{theorem} \label{thm:hadamard}
    For any $k,\delta,\kappa > 0$, the Hadamard code is a $(2^k - 1,k)$-code that is also a $\left(\frac{\kappa + 1}{\kappa}, \kappa, \delta, \eps \right)$-\aLDC, where $\eps \geq (\kappa + 1) \delta.$
\end{theorem}
For example, if $\eps \leq \frac{1}{3}$ and $\delta \leq \frac{1}{9}$ then we have $\left(\frac
3 2, 2, \delta,\eps\right)$-\aLDC. In fact, if $\delta = o(1),$ then we have an \aLDC\ with amortized locality $\alpha \rightarrow 1$ as we can set $\kappa + 1 = \epsilon/\delta$ so that $\kappa \rightarrow \infty$. This is in stark contrast to the result of Katz and Trevisan, which state that (without amortization) no \LDC with locality $\ell < 2$ exists even when $\delta = o(1).$
\section{Private Locally Decodable Codes}\label{sect:paLDC}
In the previous section we saw how amortization allowed us to push past the locality $\ell=2$ barrier and achieve amortized locality $\alpha < 2$ with constant error-tolerance, The primary downside to the Hadamard construction is that the rate $R$ is exponential. Ideally, we want a construction with constant rate, constant error tolerance and constant amortized locality. It remains an open question whether or not this goal is achievable. As an initial step we show that the goal is achievable in relaxed settings where the sender and receiver share randomness or where the channel is computationally bounded. In this section we will also make the natural assumption that the decoder wants to recover a consecutive portion of the original message i.e., $Q = [L,R] = \{L, L+1,\ldots, R\} \subseteq [k]$. 

In settings where the sender and receiver share randomness (e.g., cryptographic keys) or where the channel is resource-bounded we can slightly relax the correctness condition for an \aLDC. Recall that we previously required the decoder $\Dec^{\tilde{\by}}$ succeed with probability at least $1-\epsilon$ for any corrupted codeword $\tilde{\by}$ that is sufficiently close to the original codeword $\by$. In relaxed versions of the definition, it is acceptable if there exists corrupted codewords $\tilde{\by}$ that fool the decoder and are close to the original codeword, as long as it is computationally infeasible for an adversarial, but resource-bounded channel to find such a corruption with high probability. This motivates definition \ref{def:paLDC}. 

Let $\leftarrow$ denote a probabilistic assignment where $\unif$ emphasizes a uniformly random assignment.
    \input{paLDC/paLdcDef}
\subsection{One-Time \paLDC }\label{subsect:oneTimePaLDC}
Our first \paLDC\ construction will be based on the private-key construction of Ostrovsky et al. \cite{ICALP:OstPanSah07}. 
The secret key in our scheme will be a random permutation $\pi$ and a one-time pad $\bR$. 
To encode the message $\bx,$ first split it into $B$ equal-sized blocks of size $a = \omega(\log \lambda)$, where $\bx = \bw_1 \circ \dots \bw_B$ ($\circ$ is the concatenation function).
Encode each block $\bw_j$ as $\bw'_j = \calC(\bw_j)$, where $\calC$ is a code with a constant rate $R$ and constant error-tolerance $\delta$. 
Form the encoded message as $\by' = \bw'_1 \circ\dots\circ \bw'_B,$ where $|\by| / |\bx| = 1 / R$. 
Note that we cannot just output $\by'$ without assuming sub-constant error-tolerance because otherwise, an adversarial channel can just choose to corrupt an entire block $\bw'_j.$
To remedy this, we apply our secret random permutation $\pi$ and the one-time pad $\bR$ to output $\by = \pi(\by' \oplus \bR)$.
Since the channel is computationally bounded, the errors it causes is effectively random. 
If the overall error tolerance is a constant dependent on $\delta$, then each block will have at most $\delta n$ errors with high probability (see \cite{ICALP:OstPanSah07} for details). 

Thus, our local decoder will simply recover its requested message symbols by recovering the corresponding message blocks.
That is, if block $\bw_j$ is requested, then we undo the permutation and one-time pad to obtain the encoded block $\bw'_j$ and subsequently decode it. 
More specifically, for each index $j_r$ of $\bw'_j$ in $\by'$, we obtain the corresponding index in $\by$ as $\pi(j_r).$
In summary, this code achieves constant rate, constant error-tolerance, and constant amortized locality with parameters summarized in the following theorem.
\begin{theorem}
    Suppose code $\calC$ has constant rate $R$ and constant error-tolerance. Then, the construction above is a $(2 / R, \omega(\log \lambda), O(1), O(1), 1)$-\paLDC.
\end{theorem}
The primary limitation to the above construction is that the security is only guaranteed after the encoder sends a {\em single} ($q=1$) message to the decoder. If the encoder has multiple messages to send, then they would need to use a separate permutation $\pi^i$ and a one-time pad $\bR^i$ in every round $i \leq q$.  
Generating and secretly sharing randomness for each message is costly and undesirable; instead, we propose an alternate where the secret key may be used polynomial many times.
The full analysis can be found in appendix \ref{app:oneTime}.

\subsection{Multi-Round \paLDC }\label{subsect:multPaLDC}
We present a polynomial round ($q = \poly(\lambda)$) \paLDC\ with constant rate, constant error rate tolerance, and constant amortized locality that matches the one-time construction without requiring multiple secret keys. Our primary technical ingredient is a special type of code that we call a {\em robust secret encryption (\RSE).} Intuitively, we want a code with the property that any computationally bounded adversary who does not have the secret key for the scheme cannot distinguish the encoding of a random message from a random string. This allows us to embed fresh randomness in such a way that the randomness is effectively hidden from an attacker who does not have the secret key. 

Formally, the definition of a \RSE\ is given in definition \ref{def:RSE}. Intuitively, the $\RSE$ game captures the property that a PPT attacker cannot distinguish the encoding of a random message from a truly random string even if the attacker is given many samples. Recent work \cite{C:ChrGun24} yields an efficient construction (constant rate/error tolerance) of \RSE\ from the Learning Parity with Noise (LPN) assumption --- a standard widely accepted assumption in the field of cryptography. 
We also provide a construction based on the Gopppa code McEliece Cryptosystem, which can be found in appendix \ref{app:RSE}.
    \input{rse/rseGameDef}
Lastly, we will need a common cryptographic tool known as the pseudorandom function (prf). 
Informally, a prf is a deterministic function $f$ that when instantiated with a secret key $\bk,$ is indistinguishable from a random function to a computationally-bound adversary. 
We use the prf to essentially generate a new one-time pad for each message sent, allowing us to invoke the indistinguishability of the \RSE.
    \input{paLDC/rse/rseConstr}
    \input{paLDC/rse/rseTheorem}
    \input{paLDC/rse/rseProofLong}


\subsection{\aLDC s for Resource-bounded Channels}\label{subsect:Resource-boundedALDC}
Lastly, we present an \aLDC\ for resource-bounded channels with constant rate, constant amortized locality, and constant error-tolerance by applying the framework developed by Ameri et al. \cite{SCN:AmeBloBlo22} to eliminate the requirement that the encoder and decoder have a shared secret key. The framework of Ameri et al. \cite{SCN:AmeBloBlo22} using two building blocks: a secret key LDC and cryptographic puzzles. Intuitively, a cryptographic puzzle consists of two algorithms $\mathtt{PuzzGen}$ and $\mathtt{PuzzSolve}$. $\mathtt{PuzzGen}(s)$ is a randomized algorithm that takes as input a string $s$ and outputs a puzzle $Z$ whose solution is $s$ i.e., $\mathtt{PuzzSolve}(Z)=s$. The security requirement is that for any adversary $A \in \mathcal{C}$ is a class $\mathcal{C}$ of resource bounded algorithms (e.g., bounded space, bounded computation depth, bounded computation) cannot solve the puzzle $Z$. In fact, we require that for any string $s_0$ and any resource bounded adversary $A \in \mathcal{C}$ the adversary $A$  cannot even distinguish between $(Z_0,s_0,s_1)$ and $(Z_1,s_0, s_1)$ where $s_i$ is a random string and $Z_i=\mathtt{PuzzGen}(s_i)$ is a randomly generated puzzle whose corresponding solution is $s_i$. 

At a high level the encoding algorithm $\Enc(x)$ works as follows: 1) pick a random string $r \in \{0,1\}^\lambda$ and generate a cryptographic puzzle $Z = \mathtt{PuzzGen}(r)$ whose solution is $r$. 2) Use a constant rate error correcting code to obtain an encoding $C_Z$ of this puzzle. 3) Use the random string $r$ to generate the cryptographic key $sk$ for a secret key \LDC\ (we will use the amortizeable secret key LDC  (\paLDC) from Theorem \ref{thm:RSE_paLDC}). 4) Use the secret key \LDC\ to encode the message and obtain $c_1=\Enc_{sk}(x)$. 5) Define $c_Z^1 = C_Z$ and $C_Z^{i+1}=C_Z \circ C_Z^{i}$ and find the smallest value $r$ such that $C_Z^r$ is at least as long as $c_1$. Set $c_2 = C_Z^r$. 6) Output the final codeword $C=c_1 \circ c_2$.  

Intuitively, if the channel is resource bounded then the channel cannot solve the puzzle $Z$ or extract any meaningful information about the solution $r$ or the secret key $sk$ derived from it. In contrast, the local decoding algorithm can extract several (noisy) copies of $C_Z$ by querying $c_2$ and decode these copies to extract $Z$ (most noisy copies of $C_Z$ in $c_2$ will still decode to $Z$). Then, the decoder, who does not have the same resource constraints as the channel, can solve the puzzle $Z$ to obtain $r$ and then extract the secret key $sk$ using $r$. Finally, once the decoder has $sk$ it can run the (amortizeable) secret-key local decoder on $c_1$ to extract the message symbols that we want. 

If we instantiate this construction with a \paLDC, then the amortized locality is nearly the same. The local decoder needs to make $O(\lambda\ \mathtt{poly}(1/\epsilon))$ additional queries to $c_2$ to ensure that we recover the correct puzzle $Z$ with high probability e.g., at least $1-\epsilon/2$. However, these additional $O(\lambda\ \mathtt{poly}(1/\epsilon))$ queries can be amortized over the total number of symbols that are decoded. 
We observe that our amortization block size may be made to be much larger than the key size, adding negligible amortized locality. 
\begin{theorem}[Informal]
    Suppose the channel is resource-bounded and there exists a cryptographic puzzle.
    Suppose $\calC_P$ is a $(\alpha_p,\kappa_p,\delta_p,\eps_p,1)$-$\paLDC.$
    Then, under the framework of Ameri et al. \cite{SCN:AmeBloBlo22}, we can construct a ${(\alpha_p + o(1), \kappa_p, \delta,\eps)\text{-}\aLDC}$, where $\delta = O(\delta_p)$ and $\eps = O(\eps_p)$.
\end{theorem}

\section{Conclusion}\label{section:conclusion} 
We initiate the study of amortized LDCs as a tool to overcome prior barriers and impossibility results. We show that it is possible to design an amortized LDC with amortized locality $\alpha < 2$ --- overcoming an impossibility result of Katz and Trevisan for regular LDCs. 
We also design a secret-key LDC with constant rate, constant error tolerance, and constant amortized locality. 
Finally, under the natural assumption that the channel is resource bounded, we can use cryptographic puzzles to eliminate the requirement that the sender/ sender and obtain LDCs with constant rate, constant error tolerance, and constant amortized locality. 

\bibliographystyle{IEEEtran}
\bibliography{cryptobib/abbrev0,cryptobib/crypto,cryptobib/notincluded}

\clearpage
\appendix
\subsection{Robust Secret Encyption from Code-based Cryptography}\label{app:RSE}
Code-based cryptography is a strong candidate for post-quantum cryptography due to the widely-believed intractability of code-theoretic problems related to decoding random linear codes\cite{berlekamp_inherent_1978,weger_survey_2024}. 
The most relevant to our work is the {\em average decoding problem assumption}, assuming that on average, it is hard for {\em any} adversary to distinguish between a codeword with a fixed number of errors and a uniformly random string.
\input{codeBasedCryptoBackground/mceliece/adpAss}
Robert McEliece proposed the first code-based public-key cryptosystem in 1978 \cite{mceliece1978public}.
His construction was based on \textit{binary Goppa codes} and the assumption that such codes are sufficiently \textit{indistinguishable} from random codes. 
We state this assumption more formally by first defining Goppa codes and the Goppa code distinguishing (GD) game referenced from previous work.
    \input{codeBasedCryptoBackground/mceliece/goppaDef}
    \input{codeBasedCryptoBackground/mceliece/goppaGame}
The claim that Goppa code generator matrices have no structure discernible from a random matrix has withstood decades of cryptanalysis and attacks which have yet to disprove this assumption for general parameters~\cite{PQCRYPTO:BerLanPet08,leon_probabilistic_1988,EC:LeeBri88,faugere_distinguisher_2013}.
\input{codeBasedCryptoBackground/mceliece/goppaAss}
The security of the McEliece cryptosystem is contingent on Assumptions \ref{ass:avgDecProb} and \ref{ass:GoppaRandom}.
The cryptosystem will encode messages as codewords of a scrambled secret Goppa code with added noise, where decryption is straightforwardly undoing the scrambling and recover the message via the Goppa code decoder. 
More specifically, the secret key in the McEliece Cryptosystem is $\sk = (S,G,P),$ where $G$ is the generator of a chosen Goppa code, $P$ is a column permutation of $G$, and $S$ is an invertible message transformation. 
The public key is set to be the scrambled generator $\pk = SGP.$
The encryption scheme on input message $\bm,$ applies the scrambled encoding $(\bm SGP)$ and adds an error vector $\be$ with weight proportional to the security parameter $\lambda.$
The decryption scheme on input codeword with errors $\tilde{\bc} = (\bm SGP) + \be$, inverts the column permutation $\tilde{\bc} P^{-1} = \bm SG + \be P^{-1}$ and decodes the resulting word with the corresponding Goppa code decoder.

We construct a \RSE\ using a similar error-obfuscation coding scheme.
Our \RSE\ construction can be interpreted as a conversion of the McEliece system to the secret/symmetric key setting with additional consideration in the amount of errors added to support the desired \RSE\ error-tolerance. 
First, in the secret key setting, message scrambling matrix $S$ and the permutation matrix $P$ may be omitted.
While these matrices were used to disassociate the public Goppa code used in encoding and the secret Goppa code used in decoding, this is unnecessary when the encoder and decoder share the same secret key. 
Second, the \RSE\ robustness property requires that encodings can tolerate a $\delta$ fraction of errors.
In our code-based construction, this is naturally achievable by relaxing the weight of the added error vector $\be$ by a $\delta$ fraction. 
\input{rse/rseConstr}
Note that the decoding of a Goppa code, in particular Patterson's algorithm, can be done in polynomial time with the extended Euclidean algorithm.
\input{rse/rseTheorem}
\input{rse/rseProof}
\subsection{Detailing the One Time \paLDC}\label{app:oneTime}
% \constrOstr
\input{paLDC/ostr/ostrConstr}
\input{paLDC/ostr/ostrTheorem}
% \constrOstrTheorem
\input{paLDC/ostr/ostrProof}
\subsection{Resource-bounded \paLDC\ Construction}
Lastly, we present an \aLDC\ for resource-bounded channels with constant rate, constant amortized locality, and constant error-tolerance by applying the framework developed by Ameri et al. \cite{SCN:AmeBloBlo22} to eliminate the requirement that the encoder and decoder have a shared secret key. The framework of Ameri et al. \cite{SCN:AmeBloBlo22} using three building blocks: a secret key LDC, an $\LDCStar,$ and cryptographic puzzles. 

First, we formally introduce \LDCStar s, a variation on \LDC s in which the entire message is recovered while making few queries to the codeword (possibly with errors).
\input{resource-bounded/ldcStarDef}
Intuitively, a cryptographic puzzle consists of two algorithms $\Puz.\Gen$ and $\Puz.\Sol$. $\Puz.\Gen(s)$ is a randomized algorithm that takes as input a string $s$ and outputs a puzzle $Z$ whose solution is $s$ i.e., $\Puz.\Gen(Z)=s$. The security requirement is that for any adversary $A \in \R$ is a class $\R$ of resource bounded algorithms (e.g., bounded space, bounded computation depth, bounded computation) cannot solve the puzzle $Z$. In fact, we require that for any string $s_0$ and any resource bounded adversary $A \in \R$ the adversary $A$  cannot even distinguish between $(Z_0,s_0,s_1)$ and $(Z_1,s_0, s_1)$ where $s_i$ is a random string and $Z_i=\Puz.\Gen(s_i)$ is a randomly generated puzzle whose corresponding solution is $s_i$. 

We now modify the aforementioned compiler of Ameri et al. to take in a \paLDC\ instead of an \aLDC\ and to output a \aLDC\ instead of a \LDC\ for a resource-bounded channel. 
Additionally, we relax the definition of an $\aLDC$ to take in a consecutive range, like in $\paLDC$.
This follows naturally from the use of a \paLDC\ to instantiate our construction. 
Whether resource-bounded \aLDC s exist for non-consecutive queries is left as an open question.
Note that the codes defined are over choice of $\lambda$ values, where the message length is taken to be any polynomial $k \in \poly(\lambda).$ 
\input{resource-bounded/resourceConstr}
\input{resource-bounded/resourceTheorem}
\input{resource-bounded/resourceProof}
Explicitly, we can achieve constant decoding error $\eps$, constant rate $R$, constant amortized locality $\alpha$, and constant error-tolerance $\delta$ by using the (one-time) \paLDC\ construction from Theorem \ref{thm:paLDCV1} and an \LDCStar\ with $\nStar \sim \nP.$ 
Note that $\nStar = \theta(\nP)$ is necessary for simultaneous optimally constant parameters.  
We need $\nStar = \Omega(\nP)$ for constant error tolerance, and, at the same time, the rate $R = \kP / (\nP + \nStar)$ is constant for $\nStar = O(\nP)$. 
\end{document}