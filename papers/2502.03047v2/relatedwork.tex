\section{Related Work}
Genetic programming (GP) was introduced by Koza in~\cite{koza1994genetic}, including many applications such as symbolic regression~\cite{koza1994genetic}, robot movement optimization~\cite{koza1992automatic}, planning, solving equations and finding a control strategy~\cite{koza1990genetic}. More recently, new tools have been developed that focus on symbolic regression using GP, either for dynamical systems or natural laws, including Eureqa~\cite{bongard2007automated, schmidt2009distilling}, DEAP~\cite{fortin2012deap}, Operon~\cite{burlacu2020operon} and PySR~\cite{cranmer2023interpretable}. Recent examples of applications of GP include control policy optimization~\cite{hein2018interpretable,vries2024discovering,nadizar2024naturally}, evolving learning rules~\cite{jordan2021evolving, bengio1994use} and objective functions~\cite{raymond2023fast}.

However, most GP frameworks were developed for specific applications, as there is still a lack of a unifying framework for GP. HeuristicLab~\cite{wagner2005heuristiclab} attempted to provide GP software that allows users to tune the fitness evaluation to their problems, but the software was limited by high computational requirements. DEAP~\cite{fortin2012deap} also offers flexibility in defining the fitness function and extending the optimization algorithm. However, DEAP does not use code compilation, therefore scales poorly when difficult fitness functions or large populations are evaluated. More specialized libraries for symbolic regression, such as Eureqa and PySR, apply tricks like partitioning and the finite difference method to the input data to improve the convergence to correct solutions. This requires the data to be provided in a specific format, focusing strictly on symbolic regression problems. Therefore, these libraries cannot be applied to other tasks involving numerical integration of differential equations or evaluating control policies in different environments without utilizing external methods. 

The specific data format required in Eureqa and PySR helps to reduce the runtime of fitness evaluation, which is typically the most time consuming process of GP. Parallelization of the fitness evaluation also improves the computation speed of GP. Previous work parallelized the evaluation of a single tree on many data points~\cite{harding2007fast}. However, this setup still requires the evaluation of different trees to be performed sequentially. A different approach is to evolve and evaluate different subpopulations on different processing nodes~\cite{andre1998parallel, oussaidene1997parallel}, which shows a linear relation between runtime and the number of subpopulations. To parallelize the evaluation of many solutions, general GP interpreters on GPU were developed~\cite{langdon2008simd, robilliard2009genetic, cano2014gpu, langdon2010many}, showing large speed improvements. More specific variants of GP, like geometric-semantic GP~\cite{trujillo2022gsgp, castelli2019gsgp} and stack-based GP~\cite{sathia2021accelerating, chitty2017faster}, have been made GPU-compatible, with speed improvements over the original version. 

In~\cite{nadizar2024naturally}, linear and Cartesian GP were implemented in JAX, allowing for parallelization of the fitness evaluation of all candidate solutions, as well as parallelization of the reproduction stage. Their implementation, however, was solely focused on learning control policies and does not allow users to apply the library to their own problems. NEAT is another direction in evolutionary computing that evolves the structure of small neural networks~\cite{stanley2002evolving}. Ref.~\cite{wang2025evogp} showed that with tensorization in PyTorch, the evaluation of the population can be sped up enormously on GPU compared to existing methods. Similarly, JAX can be used to parallelize fitness evaluation and significantly reduce the runtime of GP.

We developed Kozax with the intention to introduce a GP framework that provides both efficient and problem-independent fitness evaluation. Implemented in JAX, Kozax vectorizes the population, allowing for full parallelization of fitness evaluation, initialization and reproduction. Consequently, Kozax can run on either CPU and GPU, where the latter allows Kozax to scale the fitness evaluation to large datasets or populations. Furthermore, the functionality for fitness evaluation is not embedded in Kozax, therefore the fitness function can be adjusted by users for their problems of interest. This does mean that the computational efficiency of Kozax can be reduced when fitness functions are designed sub-optimally. To prevent users to define sub-optimal fitness functions, we provided multiple examples for various problems. The flexibility in fitness evaluation makes Kozax a general library for GP.

\begin{figure}[t]  % Half the width of the page
    \centering
    \includegraphics[width=0.9\linewidth]{figures/preprint_GP.pdf} % Replace with your image
    \caption{\textbf{Overview of trees and reproduction in genetic programming.} (\textbf{a}) An example of the parse tree representation used in genetic programming. (\textbf{b}) An example of crossover on a pair of trees, where the blue and orange subtrees are swapped. (\textbf{c}) An example of mutation on a tree, where the operator in blue is replaced with the new operator in orange.}
    \label{fig: overview}
\end{figure}