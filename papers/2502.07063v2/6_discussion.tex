\section{Discussion}

% \subsection{ZKP Applications} \nojan{appendix}
% In this section, we discuss some of the cutting-edge ZKP applications that have been introduced in academia and industry. For an extensive view on the more simplistic applications of ZKPs, we refer readers to the excellent work of \cite{Chainlink2023ZeroKnowledgeProof}. 
% % \nojan{add more here?}

% \textbf{Verifiable Machine Learning. }
% Verifiable computation (VC) is a technique enabled by ZKPs that allows one party to prove to another that computation was performed correctly and soundly without revealing any information about the underlying data or computation details \cite{vsimunic2021verifiable}. This is most common when there is a computationally weak verifier that would like to outsource their computation to a strong prover. This scenario lends itself quite nicely to verifiable machine learning (VML), in which a verifier can outsource their inference to a prover who owns a proprietary model. Many academic \cite{weng2021mystique, liu2021zkcnn, lee2020vcnn, feng2021zen} and industry \cite{ZkonduitInc2023EZKL} works have enabled VML, in which a cloud server (the prover) provides a ZKP that attests to the verifier that inference was computed soundly, without revealing any information about the server's proprietary model.

% % \nojan{computationaly weak verifier sends computation out to strong prover (look at zilch abstract)}

% \textbf{zk-Rollups. }
% One of the biggest problems that faces the widespread implementation of ZKPs in modern systems is the difficulty of scalability. This is evident in blockchain applications, like Zcash \cite{hopwood2016zcash} and Monero \cite{Monero2023}, which require heavy computational efforts to protect each transaction on the blockchain that they hope to keep private. zk-Rollups aim to address similar problems, although not specific to Zcash and Monero, by aggregating multiple transactions into a single batch and generating a single proof that validates all of them in one shot. This is mostly enabled by the use of recursive zk-SNARKs \cite{kothapalli2022nova}, in which a ZKP for each transaction is built, followed by a ZKP that validates all of the transactions at once. This significantly lightens the computational load on the verifier. zk-Rollups have become a more prominent solution towards applying ZKPs at scale on the blockchain in several industrial efforts \cite{0xPolygonZero2023Plonky2, PolygonLabs2023PolygonZkEVM}.

% \textbf{Robust Federated Learning. }
% Byzantine attacks on federated learning refer to a security threat in which malicious users aim to harm the central model \cite{fang2020local}. The introduction of secure aggregation \cite{bonawitz2017practical}, which was devised to secure individual user updates, has made it much easier malicious users to perform Byzantine attacks. In secure aggregation, malicious users can simply hide amongst benign users and inject poisoned updates that affect the central model's accuracy. Even if a malicious attack is detected, the privacy-preserving nature of secure aggregation, the attacker cannot be identified. Several academic works \cite{ghodsi2023zprobe, so2020byzantine, roy2022eiffel, lycklama2023rofl} have proposed scalable and secure secure aggregation schemes that utilize ZKPs to check individual user gradients, allowing for detection and exclusion of malicious users, while still maintaining end-to-end privacy.

% % \textbf{FHE Integrity. }
% % Similar to VML, FHE integrity consists of a verifier sending their data to a cloud server for computation. However, in FHE, the computation is done on encrypted data, making the ZKP generation process much more complex. As FHE operations are more computationally intensive and use underlying ring arithmetic, the circuit that expresses the computation for a ZKP grows to be very complex. This is particularly due to the fact that ZKPs operate with underlying finite field arithmetic, meaning that the circuit must express complex ring arithmetic in a finite field format, which contributes to even more overhead. \cite{ganesh2023rinocchio} introduces a ring-based zk-SNARK, however new works \cite{viand2023verifiable} have shown that, although this make FHE integrity proofs feasible, the overhead makes it an impractical solution. \nojan{review this}

% % \subsubsection{When to }

% \subsection{The Future of ZKPs}

ZKPs in their current state have been used in cutting-edge applications, but there still remains a long path towards practicality. We highlight the novel ZKP applications in-depth in Appendix \ref{sec:applications}. The current challenges that hinder practical ZKP-based applications are three-fold:

\textbf{Usability.} As we've shown in this work, there are many, many great frameworks that enable the development of state-of-the-art ZKP, however the usability of many of them are hindered by their lack of a higher-level API or compatibility with a circuit description frontend, like Zokrates, Circom, or xJsnark. This makes the process of developing complex ZK-based applications much more difficult, as a user must learn the intricacies of a new protocol and the necessary syntax to take advantage of the promised performance.

\textbf{Accessibility.} Accessibility poses an issue, especially when evaluating academic frameworks. Academic frameworks often present state-of-the-art results, but normally lack documentation, examples, and other information that would allow for a user to replicate their results. This is not beneficial to the developers of the frameworks, as it presents a huge hurdle towards realizing the practicality of their proposed protocols in real-world applications. Frameworks that stem from industry are often, but not always, better in this respect, as the work is developed with a consumer in mind. The usability and accessibility issue can be solved by simply providing extensive documentation and attempting solutions that promote interoperability between similar frameworks. Another achievable solution is promoting communities where developers can discuss applications and solutions (e.g. Gitter). We acknowledge that there have been attempts to achieve interoperability for ZKP frameworks, such as CirC \cite{ozdemir2022circ} and zkinterface \cite{benarroch2019zkinterface}, however there still remains a lot of work to be done. 
% \nojan{talk about having public forums for developers to discuss}

\textbf{Performance.} Perhaps the most difficult problem with ZKPs to address is the computational overhead. The results we present in this work represent only tidbits of computation that would make up a full end-to-end ZK-based application. As can be seen, these state-of-the-art implementations still introduce a relatively large amount of overhead, even for simple tasks. This overhead only gets more overwhelming as applications get more complex. One realistic solution towards improving ZKP performance and reduce the computational overhead is hardware acceleration of state-of-the-art algorithms. This is a similar approach that is taken by the Intel HERACLES \cite{cammarota2022intel}, which is an attempt to build an end-to-end accelerator for FHE, with the goal of bringing FHE computation times down to the same order of magnitude as plaintext computation. One of the goals of this work is to provide a high-level overview of the state-of-the-art ZKP implementations, which is the first step toward identifying potential candidate protocols for acceleration. In addition to hardware acceleration, the continued exploration of algorithmic refinements and optimizations, such as the emerging research topic of GPU-based cryptographic optimizations \cite{lu2022cuzk, ma2023gzkp}, could lead to more efficient performance. There have also been solutions to propose custom hardware for end-to-end ZKP applications \cite{ahmed2024amaze, sheybani2025gotta} and proof generation \cite{samardzic2024accelerating, daftardar2024szkp}, however, they have not yet reached a stage of practicality.
% However, hardware acceleration is not the most immediate solution. 

The works highlighted in this paper represent the progression of algorithmic optimizations that have been instilled to bridge the gap between theory and practicality in the real-world application of ZKPs. While there are still significant hurdles that need to be overcome, many of them have actionable tasks, such as open-source framework developers providing clear examples and documentation, alongside an accessible API or general-purpose frontend compatibility. The future of ZKP lies in a collaborative effort across academia, industry, and the open-source community to address these challenges, leading to a landscape where ZKPs are not only theoretically profound but also a practically viable solution towards securing data and computations.

Our contributions toward this effort are this survey, alongside our provided open-source collection of development environments and accompanying examples for each framework, which will be actively maintained after publication of this paper. Our hope for this repository is to allow developers of new and existing frameworks to contribute Docker containers and examples programs upon release of their work. This provides a centralized hub for developers to test their custom applications on several different frameworks before making a final choice. The objective of this survey and accompanying repository is to demystify the ZK landscape for developers and new cryptographers and to significantly lower the barrier of entry to the field of ZKPs, while providing valuable insights as to which frameworks and constructions best suit their custom applications.
% In the current state, there is too much variation between each framework's API


% \nojan{talk about frontends: Zokrates, Circom, xjsnark}

% \subsection{The Future of ZKPs}
% \nojan{Talk about tools like CirC and zkinterface - efforts towards universal solutions}