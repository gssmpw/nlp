\section{Experimental Evaluation}
\input{results_table}
\subsection{Configuration}
For all experiments, we build custom Docker environments that setup all dependencies and import all necessary programs to enable reproducible results. All reported results are the mean of 10 test runs. Benchmarking is done on a 128GB RAM, AMD Ryzen 3990X CPU desktop.

\subsection{Experimental Setup}
\nojan{Other than that, it would also have been nice to see some more comprehensive benchmarks that evaluate how these systems scale as the computation gets more complex; the reported benchmarks are for small circuits, which means that one-time initialization costs might dominate for some of the evaluated systems.}
This paper is focused on the usability and accessibility of ZKP frameworks and, more importantly, aims to serve as a guide to developers of novel ZKP-based applications. Our goal with this work is to allow new developers to have a full overview of the ZK development landscape after reading it. More importantly, we aim to provide a developer with the necessary insights to allow them to choose the framework that best suits their desired ZK-based application. Due to this developer-focused approach, we weed out some of the frameworks that we discuss in section \ref{sec:libraries}, due to the overhead that would be required for a new developer to build a custom circuit. This is not meant in a malicious manner to say the framework is not usable - these frameworks are state-of-the-art and provide excellent results. We simply are focused on frameworks that expose higher-level APIs, or can be easily integrated behind accessible frontends, for streamlined custom application development. Simply put, all the works discussed in section \ref{sec:libraries} are fantastic, and we highlight them as the best in the field. While some are missing a high-level API or frontend, they provide great value to the landscape. We still include their development environments with examples in our open-source repository to allow more experienced ZKP developers to easily access them and build applications with them.

While we recognize that there is no completely \textit{fair} way to benchmark these, we aim to do so by measuring the trusted setup (when applicable) and proof generation and verification runtimes, alongside communication for interactive protocols and proof size for non-interactive protocols. These are standard efficiency measures for ZKPs \cite{aurora}. While these quantitative results may not paint the whole picture, such as memory consumption and bandwidth considerations, we believe that they provide measurable proof of algorithmic complexity \nojan{edit} when independently benchmarked in the same isolated environment. We encourage readers to recreate our benchmarks, which are provided in our open-source repository, to gauge performance on their available hardware. To provide a rough estimate of the size of our benchmarks, we perform arithmetization to compile the benchmarks to R1CS format, and report the number of constraints of each circuit. Constraints are used often in ZK literature to describe the size of a ZK circuit. We evaluate the frameworks on the following benchmarks:

% \subsection{Benchmarks}

\nojan{A more principled approach towards comparing frameworks is needed: what should I use when I'm space-constrained? what should I use when I'm computationally constrained? what should I use if I have massive GPUs? The implementation-based comparison should answer all of these questions for this survey to elevate to the level of an SoK.}

\textbf{32$\times$32 Matrix Multiplication:} The prover aims to convince the verifier that they know two private matrices $\bm{\mathit{A^{32\times32}}}$ and $\bm{\mathit{B^{32\times32}}}$ that multiply to a public matrix $\bm{\mathit{C^{32\times32}}}$, without revealing anything about $\bm{\mathit{A}}$ or $\bm{\mathit{B}}$. This is a commonly used benchmark in this domain. This circuit is not too large and should be handled relatively easily by most frameworks, although some frameworks struggle with it due to memory issues. In R1CS format, this benchmark consists of 32,768 constraints.
% \nojan{add constraints}

\textbf{SHA-256:} \nojan{Find number of constraints for each app}
% \nojan{anees write this pls}
% I think this should probably a SHA-256 function - most frameworks will already have a gadget for this
The prover aims to convince the verifier that they know $x$, a private 512-bit preimage, to the 2-to-1 hash function SHA-256$(x)=y$, where $y$ is a public 256-bit hashed value. This is quite a large circuit, compared to the matrix multiplication circuit. Some frameworks target this operation as one to optimize. We choose to evaluate on this benchmark as we believe it provides a good representation of a framework's performance, and it is a commonly used benchmark in this domain. In R1CS format, this benchmark consists of 59, 281 constraints.

\subsection{Results \& Takeaways} \nojan{add scalability tests to appendix}
\label{sec:results}
% \nojan{mention that we're not slandering any of these}
While we provide streamlined workflows for building custom applications for almost all frameworks that are discussed in section \ref{sec:libraries}, we narrow down our evaluation to frameworks that provide a novel, usable, and accessible approach for developing custom applications. Some frameworks, such as \texttt{Gnark} and \texttt{SnarkJS}, provide PLONK and zk-SNARK backends, so we evaluate our benchmarks on both backends. Overall, we analyze 18 systems for performance on our selected benchmarks. In this section, we discuss the implications of these results and the takeaways for developers. Alongside this, we provide recommendations for which frameworks or protocols are best to use in certain settings. The results can be seen in Table \ref{tab:finalresults}.

\begin{figure*}[t]
\centering
\subfloat[Scaling of trusted setup runtime.]{\includegraphics[width=.48\textwidth]{scalability/setup.pdf}}
\hspace{1em}
% \hfill
\subfloat[Scaling of proof generation runtime.]{\includegraphics[width=.48\textwidth]{scalability/prover.pdf}}
\hspace{1em}
% \hfill
\subfloat[Scaling of proof size (or communication in Emp-ZK's case).]{\includegraphics[width=.48\textwidth]{scalability/proofsize.pdf}}
\hspace{1em}
% \hfill
\subfloat[Scaling of proof verification runtime.]{\includegraphics[width=.48\textwidth]{scalability/verify.pdf}}
\caption{Analysis of scalability of select frameworks over matrix multiplication benchmarks spanning $8\times8$ matrix size, resulting in 64 constraints, up to $128\times128$ matrix size, resulting in 2,097,152 constraints.}
\label{fig:scalability}
\end{figure*}

In figure \ref{fig:scalability}, we perform an extensive scalability test on a subset of our evaluated frameworks to show how the trusted setup, proof generation and verification, and proof size/communication all scale as computation grows. We only do this for the matrix multiplication benchmark to avoid redundancies, and we believe it is sufficiently indicative of the framework's scalability. The subset of frameworks is chosen due to their promising performance, outlined in section \ref{sec:results}, and their ability to handle large circuits. Also,  some frameworks that were evaluated in section \ref{sec:results} ran into memory overflow issues on our machine as circuits scaled.

We found that proof size/communication and proof verification stay relatively constant for zk-SNARKs and \texttt{Gnark}'s PLONK implementation. Proof size and verification time follow very similar curves in the case of both \texttt{Emp-ZK} and \texttt{RISC Zero}. Most trusted setup times and proof generation times follow similar trajectories as circuits scale, except for \texttt{Emp-ZK}, which stays relatively constant. \texttt{Diet Mac'n'Cheese} provided us with interesting results that seem to separate it quite a bit from \texttt{Emp-ZK}, although they are both VOLE-based ZK solutions. Upon further inspection, we found that the only frontend that is available, \texttt{PicoZK}, serves as the main bottleneck. \texttt{PicoZK} compiles everything to the DARPA SIEVE Intermediate Representation (IR), which can be read by \texttt{Diet Mac'n'Cheese}. However, \texttt{Diet Mac'n'Cheese} is not optimized for operations presented in SIEVE IR format, which is why the presented scalability results make it seem like a less performant candidate. Upon our own code review and discussion with the \texttt{PicoZK} authors, we believe that further work into building a direct bridge between \texttt{PicoZK} and \texttt{Diet Mac'n'Cheese} can result in results that are much closer to \texttt{Emp-ZK}, while still being able to take advantage of \texttt{PicoZK}'s extremely user-friendly development process. \texttt{RISC Zero}'s proof generation time is several orders of magnitude larger than the other evaluated frameworks, however we believe this is due to it's nature as a zkVM, which requires extra underlying RISC-V-based operations to perform these tasks. Finally, we observe that zk-SNARKs exhibit essentially the same pattern of growth as circuits scale. \texttt{PySNARK} proof generation time grows drastically with circuit size, but we believe this is due to Python's compilation process, which results in slower runtimes. We highlight \texttt{Emp-ZK}, \texttt{Arkworks}, and \texttt{Gnark}'s zk-SNARK and PLONK implementation as excellent scalable frameworks for custom applications.
% Due to space limitations, we include an in-depth look at the scalability of a subset of these frameworks in Appendix \ref{sec:scalability}.

\textbf{Takeaways.} One of the main observations we make is the prevalance of usable zk-SNARK frameworks compared to all other constructions, and the lack of available tools for building systems with MPCitH ZKPs. This is primarily attributed to the fact that MPCitH ZKPs are primarily an academia-driven concept, meaning that the developers of the frameworks are not as concerned with commercialization, which naturally puts developer usability and accessibility to the wayside.
% zk-SNARKs were the first prominent construction of ZKPs, and the most prevalent in real-world applications. This has led to several usable frameworks that provide very accessible frontends for building custom applications. These zk-SNARK frameworks are also heavily used in applied cryptography papers that present novel ZKP applications \cite{liu2023pianist}. 
We also find that there is a lack of accessible dedicated PLONK-based Zk-SNARK frameworks. This is most likely due to the arithmetic and cryptographic flexibility that are attributed with PLONKs. Rather than building a dedicated PLONK framework, many developers, such as the developers of \texttt{SnarkJS} and \texttt{Gnark}, simply modify their frameworks to also support PLONK proving systems. As for zk-STARKs, we show that there are only a few accessible frameworks that can be utilized by developers. We do want to note that these frameworks are excellent, with a majority providing extensive documentation and very accessible frontends and APIs for those experienced with applied cryptography.

In our evaluation, we aim to keep settings (e.g. ECC curve, bitwidths, etc.) consistent between experiments as much as the frameworks allow us.
Nevertheless, it is not possible or fair to compare all of these frameworks to each other and choose a \textit{single} best one, as each different type of ZKP (zk-SNARKs, MPCitH, etc.) is built with different cryptographic, interactivity, and trusted setup assumptions. Rather, we analyze the results and discuss what application settings would benefit from each type of ZKP, and what frameworks can be used to realize those applications:

\textbf{zk-SNARKs: } Building an application powered by zk-SNARKs requires a computationally strong prover and trusted third party (for trusted setup), due to the underlying elliptic curve cryptographic assumption. As trusted setup parameters must be recomputed for every new circuit, zk-SNARKs are ideal when the computation remains relatively static. The perk of zk-SNARKs is that the proof size is succinct and somewhat constant and proofs are publicly-verifiable. zk-SNARKS are ideal for settings that are bandwidth-constrained and/or have resource-constrained verifiers. For building custom zk-SNARK-based applications, we recommend \textbf{Arkworks} or \textbf{Gnark}. These works provide excellent documentation, active development communities and forums, and many examples that can guide developers, while still maintaining competitive runtime and succinct proofs.

PLONKs have also proven to be a valuable tool for cryptographers, serving as the basis for some interesting applications \cite{0xPolygonZero2023Plonky2}. Due to the cryptographic flexibility, PLONKs are ideal for applications where available bandwidth and computation may require switching underlying cryptography. Alongside this, applications that can benefit from a single, versatile trusted setup are ideal candidates for PLONK-based design. For building custom PLONK-based applications, we recommend \textbf{GNARK-KZG}. The implementations provided in \texttt{Gnark}'s FRI and \texttt{SnarkJS} are valuable, however, as can be seen by the benchmarked results, they are not the most efficient. \texttt{Noir} offers detailed documentation and many examples, coupled with an active development community that are constantly presenting new applications built with Noir \cite{NoirLang2023AwesomeNoirBenchmarks}, however is outperformed by \texttt{GNARK-KZG}. We do note that \texttt{Noir} is also a fantastic option for developers. However, \texttt{GNARK-KZG} achieves excellent performance with an easily accessible API. 

\textbf{VOLE-based ZK: } Options for building VOLE-based ZK systems are admittedly limited, and the evaluations do not paint the full picture, as the presented runtimes are the amount of time that the prover and verifier must stay online, rather than time spent actively computing. VOLE-based ZK is an excellent candidates for custom applications when the setting naturally requires communication, such as distributed learning or the IoT, especially because they do not require trusted setup. These protocols also distribute the computational load between the prover and the verifier, rather than putting all of the work on the prover. For building custom VOLE-based ZK applications, we recommend \textbf{Emp-ZK}. This work provides great examples and readable C++ code, but most importantly, it supports arithmetic, Boolean, and mixed computation. Most importantly, due to the inclusion of Boolean circuit evaluation, this framework also supports floating point operations, which is not done by any other frameworks that we discuss. Although \texttt{Diet Mac'n'Cheese}, paired with \texttt{PicoZK}, is also a great solution, it still requires a bit more development before it is ready for application development without too many limitations (e.g. floating point support). However, we do note that this pairing can be used with quite an efficient development process, as it solely relies on readable Python code. Although it does present rather slow prover and verification times, we would like to emphasize that this is due to \texttt{PicoZK}'s compilation process being reliant on the SIEVE intermediate representation (IR) \cite{sieve}. \texttt{Diet Mac'n'Cheese} can operate over SIEVE IR files, but it has not been completely optimized for this process yet. While this is not a direct reflection of \texttt{Diet Mac'n'Cheese} performance, we believe it is currently the only solution to properly build ZKPs using the underlying \texttt{Diet Mac'n'Cheese} proof system. Nevertheless, the pairing of \texttt{Diet Mac'n'Cheese} with \texttt{PicoZK} provides the easiest route towards developing relatively complex applications that we have encountered through writing this paper.

\textbf{MPCitH.}
Once again, the options for building MPCitH ZKPs are quite limited. MPCitH ZKPs have most prominently been used in digital signatures \cite{PQC_MIRATH_Website, aragon2023ryde, SDITH_Website},, however, there are not many general-purpose frameworks available. For the purpose of this work, \textbf{Limbo} is the most accessible general-purpose framework for developing MPCitH ZK-based applications. This requires a baseline knowledge of Bristol fashion circuits \cite{bristol}, as this is how any computation \Cir is described in Limbo. However, once this hurdle is overcome, \texttt{Limbo} is a straightforward framework for building efficient MPCitH ZKPs. The main shortcoming of \texttt{Limbo} is its lack of support for anything but Boolean computation, which is why it performed poorly on the matrix multiplication benchmark. 
% However, the value of \texttt{Limbo} is shown when it is presented with a very optimized boolean circuit, as we show in our SHA-256 benchmark.

% \textbf{PLONKs: } 


% We do note that \texttt{Gnark}'s KZG implementation is also an excellent option for developers, and the scalability of it is particularly impressive.

\textbf{zk-STARKs: } zk-STARKs have the potential to be an excellent solution for applications aiming to integrate ZKPs, however not many academic works have started integrating them into their applications, due to their relative nascency. Due to their lack of trusted setup and post-quantum, lightweight cryptography, they serve as great candidates for applications with strong provers and enough bandwidth to support proof transmission.
For building custom zk-STARK-based applications, we recommend \textbf{RISC Zero}. 
% While \texttt{Miden VM} is a great framework, it lacks an accessible frontend, and building end-to-end applications with Miden assembly is quite challenging. 
\texttt{Zilch} is another fantastic framework, however caused memory overflow for both of our benchmarks, which is why we do not consider it here. 
\texttt{RISC Zero} is the main offering from a startup, meaning the documentation is extensive and the framework is very well-developed. The main advantage of this framework is its ability to integrate with standard Rust crate easily, while still maintaining acceptable performance metrics. While the performance is a bit worse than \texttt{Miden VM}, it also do not require as much memory as \texttt{Miden VM} does, which caused memory overflow on a powerful server.

To accompany our suggestions, and to also take resource availability into account, figure \ref{fig:flow} provides a flow chart that developers can use to find the perfect framework for their applications, based on available resources and preferences. We note that most frameworks that we discuss in this survey can be used as solutions for building ZKP applications, however we believe that the highlighted frameworks in figure \ref{fig:flow} are the most promising and reliable.

\begin{figure}
    \centering
    {\includegraphics[width=\columnwidth]{FWflow.pdf}}
    \caption{Flow chart to guide users to the framework that best fits the requirements of their application and available resources.}
    \label{fig:flow}
\end{figure}