\section{ZKP Libraries} 
\label{sec:libraries}
\nojan{Add swanky and picozk}
\input{accessibility_table}
% \nojan{maybe add circom}
In this section, we discuss the details of the 25 frameworks that we target in this work. We aim to highlight frameworks bred from both industry and academia. We primarily focus on works that present novel implementations of proving schemes that can be integrated with their own exposed high-level API for custom circuit design, or a general-purpose ZKP circuit development frontend, such as Circom \cite{munoz2022circom} or Zokrates \cite{eberhardt2018zokrates}.

Alongside the in-depth descriptions of each framework, we provide an evaluation of these frameworks at a high-level on usability and accessibility metrics, presented in Table \ref{tab:usability}. Our measurement of some metrics require further explanation:
\begin{itemize}
    \item Custom \Cir: \fullcirc $=$ Non-cryptography software engineer can build custom circuits, \halfcirc $=$ Building custom circuits requires deep knowledge of syntax; A developer could not read the code and understand it, \emptycirc $=$ Custom circuits require deep knowledge of protocol and syntax; normally requires manual translation of constraints to gates
    \item Examples: \fullcirc$=$ Plenty of examples are shared that fully show the capabilities of the system, \halfcirc $=$ Examples are included, but are not representative of the system's full capabilities
    \item Github Issues: \fullcirc $=$ Users and developers are both active in issues forum, \halfcirc $=$ Users are relatively active and developers are sporadically active, \emptycirc $=$ No activity
\end{itemize}

Table \ref{tab:description} in Appendix \ref{sec:app_libraries} outlines the discussed frameworks at a high level.

% \nojan{Specify between frontend and backend}

% \nojan{RISC zero, }

% \nojan{Look into PLONK languages: Fast provng and small proofs}

\subsection{zk-SNARKs}

\textbf{libsnark.} The \texttt{libsnark} C++ development library \cite{libsnark} is widely regarded as the original and most well-developed library for zk-SNARKs. This is highlighted by the fact that Zcash, the first real-world implementation of zk-SNARKs, was built upon \texttt{libsnark}. \texttt{libsnark} supports the Pinocchio \cite{parno2016pinocchio} and Groth16 \cite{groth16} proving schemes, alongside many different underlying elliptic curves. Much of the novelty of \texttt{libsnark} comes from the different forms of circuits that it supports. It supports R1CS and QAPs, as most frameworks do, but also supports higher level forms such as Unitary-Square Constraint Systems (USCS) and Two-input Boolean Circuit Satisfiability (TBCS) \cite{uscs}. The scheme used in \texttt{libsnark} is described as a preprocessing zk-SNARK, which simply highlights that trusted setup is performed before proof generation and verification. \texttt{libsnark} provides low-level "gadgets", which can be combined and built upon to represent the desired computation in R1CS format, however it is not the easiest way to develop zk-SNARKs in this library. \cite{kosba2018xjsnark} presents \texttt{xJsnark}, a high-level Java framework that allows a user to essentially code their computation in standard Java. Behind the scenes, this framework optimizes computation and outputs the computation in R1CS format. This output can be used directly with \texttt{libsnark}'s zk-SNARK generation script. Combined with \texttt{xJsnark}, \texttt{libsnark} is a highly-accessible option for inexperienced ZKP developers.

\textbf{gnark.} The \texttt{gnark} library \cite{gnark-v0.9.0} enables developers to build zk-SNARK-based applications using the high-level API it offers in Go language. The primary focus of \texttt{gnark} is runtime speed \cite{ConsenSys2023Gnark}. It offers both Groth16~\cite{groth16} and PLONK~\cite{plonk} (with KZG and FRI polynomial commitment) SNARK protocols. It offers a lot of curves, and can build R1CS circuits. In terms of hashing, it offers MiMC~\cite{mimchash}, SHA2, and SHA3 gadgets out-of-the-box. It also offers a collection of high-level gadgets for ease of building custom circuits. This framework exposes a high-level API that allows users to build their own gadgets, while utilizing the Go standard language and the provided gadgets. Recently, \texttt{gnark} has introduced GPU support with the support of the Icicle library \cite{icicle}. This work is in active development and seems to have an active community around it, making it an accessible option for inexperienced ZKP developers. We recommend this for beginners and experts alike for almost any custom applications. This framework utilizes a readable and robust API that any user can take advantage of and build custom applications with.

\textbf{arkworks.} The \texttt{arkworks} Rust ecosystem~\cite{arkworks} is an extensive and modular collection of libraries that can be used for efficient zk-SNARK programming. This ecosystem provides highly efficient implementations of arithmetic over \textit{various} curves and fields, even allowing curve specific optimizations. The main offering of \texttt{arkworks} is a generic application development framework that supports both experienced and non-experienced zk-SNARK developers. This framework enables high-level zk-SNARK development, as it allows users to implement their circuit as constraints (R1CS), while abstracting out details of SNARKs and curves, using an \texttt{arkworks} library. To venture into lower-level optimizations, \texttt{arkworks} provides libraries for the user to describe their circuit in native code. This allows the users to make several design decisions, such as specifying which proving system, such as Groth16, they would like to use. Alongside this, \texttt{arkworks} also provides libraries implementing low-level finite field, elliptic curve, and polynomial interfaces. In addition to SHA256, ZKP-friendly hashes such as Pedersen \cite{pedersenhash} and Poseidon \cite{poseidonhash} hashing are also offered. The \texttt{arkworks} development ecosystem is actively maintained and has an active community. We recommend this framework for users that have a deep knowledge of ZKPs, as one of the main advantages of arkworks, other than it's fantastic and usable codebase, is the ability to tweak certain parameters to optimize operations for your custom application.

\textbf{hyraxZK.} \label{sec:hyrax} \texttt{Hyrax} is a "doubly-efficient" zk-SNARK scheme, providing a concretely efficient prover and verifier, with low communication cost and no trusted setup \cite{wahby2018doubly}. Instead of following a standard underlying zk-SNARK structure, \texttt{Hyrax} is built on top of the Giraffe interactive proof scheme \cite{wahby2017full}. The authors apply a technique to reduce communication cost and add cryptopgraphic operations to turn the interactive proof into a ZKP. With the addition of optimized cryptographic commitments, the concrete cost of this scheme is significantly reduced and results in an interactive ZKP scheme. Using the Fiat-Shamir transform \cite{kilian1992note}, this scheme is made non-interactive. \texttt{hyraxZK} \cite{hyraxZK} provides a cleanly-developed Python and C++ development environment using \texttt{Hyrax} as the underlying zk-SNARK scheme. The provided framework is well-developed, however there is a lack of documentation that makes it challenging to build custom circuits.

\textbf{libspartan.} \texttt{libspartan} \cite{Spartan} is a Rust library that implements the \texttt{Spartan} zk-SNARK proof system \cite{setty2020spartan}. \texttt{Spartan} is a transparent zk-SNARK proof system, meaning that it requires no trusted setup. \texttt{libspartan} utilizes a Rust implemention of group operations on prime-order group Ristretto \cite{ristretto} and elliptic curve Curve25519 \cite{bernstein2006curve25519}, which ensures security and speed.
% Similar to \texttt{Hyrax}, outlined in section \ref{sec:hyrax}, \texttt{Spartan} is developed by building upon an interactive proof protocol, which is the sum-check protocol in \texttt{Spartan}'s case. The resulting interactive argument of knowledge is then turned into a zk-SNARK using the same techniques as \texttt{Hyrax}.
By adding a new commitment scheme, alongside a novel cryptographic compiler and a compact encoding of R1CS instances, \texttt{Spartan} is able to achieve the first transparent proof system with sub-linear verification costs and a time-optimal prover, at the cost of memory-heavy computation on the prover side. \texttt{libspartan} is a well-developed and maintained framework, however implementing custom functions is not very straightforward based on the provided documentation. Developing a custom ZKP circuit in \texttt{libspartan} requires the user to have the parameters of the R1CS instance, alongside knowledge of how to encode the constraints into R1CS matrices. Depending on the size of the ZKP circuit, this process can be very rigorous and involved, while also requiring a full knowledge of R1CS representations.
\texttt{Zokrates} \cite{eberhardt2018zokrates} provides a high-level API to build an R1CS for custom ZKP circuits, however a developer then has to manually convert these into a format that is readable by \texttt{libspartan}, which can be time-intensive depending on the number of constraints in the circuit. We only recommend this framework to users that have an in-depth knowledge of ZK constraint systems, however, we do note that this framework's backend is state-of-the-art and, upon integration with a standard frontend, would be a perfect solution for most ZK applications.

\textbf{Mirage.}
\texttt{Mirage} \cite{kosba2020mirage} is a universal zk-SNARK scheme and aptly named Java framework \cite{Mirage} implementing such scheme. \texttt{Mirage}'s main contribution is a universal trusted setup, such that trusted setup does not have to be performed everytime the circuit changes, as is done in zk-SNARKs. This saves a great amount of time and computation at the cost of higher proof computation overhead. This work introduces the idea of \textit{separated zk-SNARKs}, which enables efficient randomized checks in zk-SNARK circuits. This results in simplified verification complexity. Combining this with their novel universal circuit generator that produces circuits linear in the number of additions and multiplications, the \texttt{Mirage} zk-SNARK scheme is introduced. The underlying scheme and circuit generator are implemented in the \texttt{mirage} codebase, which has a Java frontend for circuit generation and a C++ backend implementing \texttt{Mirage} on top of \texttt{libsnark}. The core of development is done in \texttt{mirage}'s universal circuit generator, as that is where the ZKP circuits are specified by the user. This codebase provides very readable and diverse examples that highlight the use cases of their high-level Java API. 
Not only is there a bit of a learning curve to get acquainted with \texttt{mirage}'s syntax, but we also found that the codebase is relatively outdated, meaning that the code no longer compiles.
% it is a very straightforward way to develop universal zk-SNARKs, and does not require an in-depth knowledge of ZKPs to build ZK applications.

\textbf{LegoSNARK.} 
\texttt{LegoSNARK} \cite{campanelli2019legosnark} is a zk-SNARK scheme and library that focuses on linking SNARK "gadgets" together to build zk-SNARKs with a modular approach. This library implements the modular zk-SNARKs in the form of commit-and-prove zk-SNARKs (CP-SNARKs) \cite{lipmaa2016prover}, which are a class of zk-SNARKs that prove statements about committed values. As previous CP-SNARK schemes are limited due to their reliance on a single commitment scheme, one of the most important contributions of this work is a generic construction that can convert a broad class of zk-SNARKS, such as QAP-based, to CP-SNARKs. The \texttt{LegoSNARK} library \cite{legosnark} provides end-to-end proving and verification using the proposed scheme in a C++ package. This work builds upon \texttt{libsnark}, albeit with integration to high-level \texttt{libsnark} frameworks, such as \texttt{xJsnark}. Nevertheless, this library provides readable examples for developing gadgets, making it relatively easy for experienced C++ developers to build custom gadgets for their ZK applications without an in-depth knowledge of ZKPs. We recommend this framework to users that are building modular applications that benefit from CP-SNARKs, such as matrix arithmetic.

% \anees{Mention license of all libraries?}

\textbf{PySNARK.}
\texttt{PySNARK} \cite{PySNARK} is a Python library that allows developers to use pure Python syntax to develop zk-SNARKs with various backends. PySNARK gives users access to \texttt{libsnark}, \texttt{qaptools}, \texttt{zkinterface}, and \texttt{snarkjs} backends. Compiling computation with the \texttt{libsnark} and \texttt{qaptools} performs proof generation and verification using the Groth16 and Pinnochio proving systems, respectively. Using the \texttt{zkinterface} backend simply generates \texttt{.zkif} files that can be used with the \texttt{zkinterface} package for proof generation and verification, where the underlying scheme can be chosen. Similarly, using the \texttt{snarkjs} backend generates the witness and R1CS files that can be used within our provided \texttt{snarkjs} environment. Overall, \texttt{PySNARK} is a brilliantly documented and developed library for beginners with zk-SNARKs, however it is not actively maintained. Developers that are comfortable with Python should have no trouble developing ZK applications once they become familiar with the library's syntax. Due to the Python compilation process, \texttt{PySNARK} experiences non-ideal operation times, so users should primarily use this for testing applications on the Groth16 proving system, but not for practical application development.


\textbf{SnarkJS + RapidSNARK.}
\texttt{SnarkJS} \cite{baylina2020iden3} is built on Javascript (JS) and Pure Web Assembly (WASM) and supports the Groth16, PLONK, and FFLONK underlying proving schemes. This framework accepts circuits designed in \texttt{circom} \cite{munoz2022circom}, which provides a very accessible frontend with a well-documented API for building ZK circuits. The protocols that are supported all require trusted setup, whether it be a circuit-specific setup for Groth16, or a universal setup for PLONK/FFLONK. Also, switching between ZK schemes is simply done by specifying the desired scheme as a command line argument. \texttt{SnarkJS} provides a multi-step universal setup protocol that all programs perform, alongside a Groth16-specific setup. Alongside this, the circuit to proof compilation process is done in a modular way that allows for closer debugging. In the proof generation process, the circuit characteristic's are listed for the developer (e.g. constraints, public inputs) which enables quick sanity checks. Finally, \texttt{SnarkJS} provides simple routes to turning the verifier into a smart contract, or performing the end-to-end ZKP process in browser, due to the JS and WASM backend. \texttt{RapidSNARK} \cite{RapidSNARK} is built upon C++ and Intel assembly by the same developers, and significantly improves upon \texttt{SnarkJS}. Using a very similar API, and even accepting \texttt{SnarkJS}-generated files as inputs (e.g. proving/verifier keys, witness), \texttt{RapidSNARK} allows for faster proof generation with a simple change in command line arguments from the \texttt{SnarkJS} commands. The main advantage of this framework is the utilization of parallelization within proof generation, yielding much faster results than \texttt{SnarkJS}, however the downside is that only Groth16 proofs are supported. While \texttt{SnarkJS} is more actively maintained than \texttt{RapidSNARK}, both frameworks are highly accessible for those with little experience in developing ZK applications, due to the ability to utilize a \texttt{circom} frontend.

\textbf{Virgo.}
\texttt{Virgo} \cite{zhang2020transparent} is an implementation of a novel interactive doubly-efficient ZK argument system. The main advantage of this protocol is the lack of trusted setup, which is oftentimes the most cumbersome task in zk-SNARKs. \texttt{Virgo} sees the most benefits for layered arithmetic circuits, rather than all general arithmetic circuits, as it is based off the GKR protocol \cite{goldwasser2015delegating}, which also is only catered towards structured circuits. General arithmetic circuits are addressed in a follow up work, \texttt{Virgo++} \cite{virgoplus}. The open-source implementation of this work does not have ZK commitments implemented yet, which is why we do not consider it in our survey. The main enabling factor of \texttt{Virgo} is a novel ZK verifiable polynomial delegation (zkVPD) scheme, which can essentially be seen as a commitment scheme in this scenario. 
% The underlying operations of the \texttt{Virgo} implementation are the combination of the zkVPD and GKR schemes. 
Due to the reliance on zkVPD and the allowed interactivity in this scheme, the implementation only relies on lightweight cryptography, making it a feasible development solution. While an impressive solution with great results, the repository is not actively maintained and lacks clear documentation, meaning it is not the most suitable candidate for ZK application developers.

\textbf{libiop} \label{sec:aurora}
The \texttt{libiop} framework \cite{SciprLab2023Libiop} is a collection of three protocol implementations: Aurora \cite{aurora}, Fractal \cite{fractal}, and Ligero \cite{ames2017ligero}. Ligero falls under the MPCitH category, so it is discussed later in the paper. Aurora and Fractal are both post-quantum, transparent zk-SNARKs, which classifies them more as succinct zk-STARKs. However, the authors classify their work as zk-SNARKs, which is why they are discussed here. Both works outperform prior zk-SNARKs by proposing new interactive oracle proofs (IOPs). Fractal proposes a holographic IOP \cite{babai1993transparent}, while Aurora proposes an IOP based around Reed-Solomon codes.
As for the \texttt{libiop} implementations, it does not seem to be actively maintained. While there are a few example applications for each protocol, the most useful tool in was the benchmarking scripts that were provided. This allows users to input parameters, such as number of constraints and variables, to specify a random circuit and outputs the performance metrics of the protocol. This shows how the protocols scale based on the size of the circuit. These parameters can be extracted from R1CS files (made by frameworks such as Zokrates), using our provided \texttt{R1CSReader} scripts. While the benchmarking is convenient, developing custom applications with this framework requires a deeper knowledge of the protocol that may not be easily accessible to all developers. We only recommend this to users that have a deep knowledge of the literature that these frameworks stem from.


\textbf{Noir.}
\texttt{Noir} \cite{Noir2023Documentation} is a general Rust-like framework for developing applications based on ZKPs. Fundamentally, \texttt{Noir} is a domain-specific language that resembles Rust. It enables one to build circuits that implement complex logic without having to learn the low-level details of ZKP systems. Since it acts like a generalized front end, it is capable of building circuits for a variety of back ends. Currently, Barretenberg \cite{AztecProtocol2023Barretenberg} serves as the default back end, and generates PLONK proofs and Solidity contracts. The Barretenberg back end can also use WASM to create proofs and verify them directly in the browser. Arkworks is also available as an out-of-the-box back end, which can generate Groth16 and Marlin proofs. This generalization is possible because Noir framework compiles the circuit to an intermediate language referred to as ACIR (Abstract Circuit Intermediate Representation), which can then be further compiled to specific R1CS or arithmetic circuit compatible with a specific back end. The framework also provides a Typescript library for direct integration into web applications. There is active development going on, but Noir currently supports a full control flow with the ability to create custom circuits using readable code. This is a great option for developers who would like to avoid the details of ZKPs and build applications using a Rust-like DSL. We recommend this for those who want to build simplistic applications who have little experience with ZKPs.
% \anees{Mention Language syntax features, ACIR Supported OPCODES, maybe roadmap?}
% \nojan{edit}

% \textbf{Bellman}
% \nojan{need to update to PLONK}

% \texttt{Bellman} \cite{} is a zk-SNARK development library built on Rust. This framework is primarily focused on implementing the Groth16 algorithm. \texttt{Bellman} has grown to prominence by being a core framework used to implement Zcash \cite{hopwood2016zcash}, one of the first mainstream implementations of zk-SNARKs. This work only supports one elliptic curve, BLS12-381,  meaning operations are highly optimized for this curve construction. This curve was designed specifically for use in Zcash, but has grown to be a standard underlying ECC for zk-SNARK implementations, due to its effectiveness and security guarantees. \texttt{Bellman} is one of the less accessible development frameworks featured in this work, as it only provides a very low-level API. Although this framework is actively maintained, it effective development \texttt{bellman} requires an in-depth knowledge of zk-SNARKs and pairing-based cryptography using the BLS12-381 ECC \nojan{double check this}. \nojan{Talk about community edition extensions bellman ce and plonk}

% \textbf{Barretenberg}


\textbf{Dusk-PLONK.}
\texttt{Dusk-PLONK} \cite{DuskPlonk2023Rust} is a pure Rust implementation of the PLONK proving system. This implementation supports operation over the BLS12-381 and JubJub elliptic curves. The developers of this framework use Kate commitments \cite{kate2010constant} as their primary polynomial commitment scheme to utilize its homomorphism and maintain constant size commitments. The provided codebase is extremely detailed and well-commented and provides helpful documentation. Similar to other PLONK frameworks, \texttt{Dusk-PLONK} only provides a very low-level API for custom circuit development. To build a custom circuit, developers must translate their computation into an arithmetic or boolean circuit gate format (e.g. add, multiply). This is perfectly digestible for small circuits, as shown in the examples, however becomes an intensely laborious task as the circuit and number of inputs or input dimensions scales up. While the code is well-written and yields excellent results, this framework requires a more sophisticated high-level API that utilizes common software engineering structures to build custom circuits before new developers can start building practical ZKP applications with it. We do note that this is a fantastic implementation of the PLONK proving system for and recommend it for developers that have experience with logic design and ZKPs. 

\textbf{Halo2.}
Built by the same creators of Zcash and the original Halo \cite{bowe2019recursive} framework, the Halo2 framework \cite{Halo22023Book} optimizes upon some of the inefficiencies of its predecessors by utilizing a PLONK-ish scheme as the underlying proving system. The underlying polynomial commitment scheme in this framework is Kate commitments. In its original repository and documentation, building a custom circuit with Halo2 requires a developer to design their computation in the form of a circuit, by implementing gates and utilizing them to build a \textit{chip}. This can be relatively confusing for new developers.
However, Halo2 is a powerful proof system that is utilized widely across the industry, including a prominent verifiable machine learning framework, \texttt{ezkl} \cite{ZkonduitInc2023EZKL}. This prominence has garnered a strong community backing the framework and has resulted in many works that either provide more examples of how the framework can be used \cite{Halo2Club2023}, or expose higher-level APIs for building custom circuits. Overall, while the Halo2 framework only exposes a lower-level API for custom circuit building, the community around it makes it a relatively accessible solution for practical application of PLONKs. We believe this is a good framework for those experienced with applied cryptography and interest in building machine-learning focused applications.

% \textbf{Fractal}
% \cite{fractal} \cite{SciprLab2023Libiop}

% \subsection{Interactive ZKPs}

% \textbf{Orion}
% \nojan{maybe remove}

% \textbf{Virgo++}
% \nojan{The implementation doesn't have ZK commitments even applied}

\subsection{MPC-in-the-head}

\textbf{Ligero (libiop).}
The Ligero \cite{ames2017ligero} protocol is implemented in \texttt{libiop} \cite{SciprLab2023Libiop} framework. This interactive protocol applies the general IKOS \cite{ishai2007zero} transformation that transforms MPC-based interactive proofs into ZKPs, which is typical for MPC-in-the-Head (MPCitH) systems. This means that the key aspect of designing the Ligero is the underlying MPC protocol. While this protocol is interactive, it can be transformed into a zk-SNARK using the Fiat-Shamir transform, just like any other interactive protocol. Additionally, the Ligero protocol only relies on collision resistant hash functions for the underlying cryptography and does not require a trusted setup. As this is implemented using the same backend as the Aurora and Fractal zk-SNARK protocols, all implementation details remain the same as described in section \ref{sec:aurora}.

\textbf{Limbo.}
Similar to Ligero, \texttt{Limbo}'s implementation \cite{KULeuvenCOSIC2023Limbo}  and underlying protocol \cite{limbo} is reliant on the IKOS transformation that MPCitH protocols often rely on. \texttt{Limbo} improves upon Ligero by highlighting the tradeoff between MPCitH parties involved, proof size, and runtime.
% For instance, \texttt{Limbo} allows a user to minimize proof size by having more underlying MPC parties run the protocol in parallel, at the cost of a higher runtime/complexity.
The main work \texttt{Limbo} compares to is Ligero, as they are both transparent MPCitH schemes that only rely on collision resistant hash functions. \texttt{Limbo} claims to work better on small and medium circuits. While the \texttt{Limbo} framework is not as extensively developed, maintained, and documented as some of the other frameworks highlighted in this work, it greatly benefits from its ability to take Bristol Circuit (BC), a common way to describe MPC circuits \cite{bristol}, descriptions as inputs. This allows developers to build custom applications by describing their general computations in BC format. We provide a simple pipeline for developing BCs, alongside examples using readable syntax. We recommend this for users who have experience building optimized BCs and have a relatively deep understanding of MPC.

% \textbf{}

% \subsection{PLONKs}

\subsection{VOLE-Based ZK}


\textbf{Diet Mac'n'Cheese}
\nojan{add swanky stuff}
\texttt{Diet Mac'n'Cheese} \cite{dietmc} is a novel framework that implements the Mac'n'Cheese protocol \cite{baum2021mac}, a Vector Oblivious Linear Evaluation (VOLE)-based zero-knowledge protocol over the $\mathbb{Z}_{2^k}$ ring. Similar to Moz$\mathbb{Z}_{2^k}$arella, this is a crucial step in making ZKPs more practical, as most real-world compute hardware operates on integer rings, and not finite fields. \texttt{Diet Mac'n'Cheese} makes many improvements to the state-of-the-art in VOLE-based ZK protocols by optimizing the underlying sVOLE subprotocol. This optimization yields significant performance improvements over prior VOLE protocols that operate over integer rings. The provided implementation comes in the form of a C++ package that directly implements the proposed scheme and uses the Swanky ecosystem \cite{swanky} for easy integration. This framework is still in its early stages of development and currently lacks extensive documentation and concrete examples, making it harder for new ZKP developers to use it. Alongside this, \texttt{Diet Mac'n'Cheese} currently only supports fixed-point integer operations. It exposes a low-level API that requires a developer to explicitly define all computations as arithmetic and boolean gates that are operated on using the framework's provided functions. However, a recent work has introduced a Python frontend with great documentation that can translate Python code into an intermediate representation that is recognized by the \texttt{Diet Mac'n'Cheese} framework. This frontend, entitled PicoZK \cite{picozk}, contains many examples and is even able to integrate with the popular numpy and pandas packages. PicoZK is a perfect pairing with \texttt{Diet Mac'n'Cheese} and allows for the development of simple applications. We recommend this framework to any developer that aims to build a scalable application that is conducive to a designated-verifier environment, such as federated or split learning. We do note that any floating point operations that are done with this framework must be converted to fixed-point.

\textbf{emp-zk.}
% \nojan{mention sVOLE}
\nojan{shorten} The \texttt{emp-zk} development framework \cite{empzk} is a part of the \texttt{emp-toolkit} \cite{emptool}, a collection of cryptographic front-ends and back-ends that allow for easy development of multi-party computation applications. Alongside ZKPs, \texttt{emp-toolkit} also provides libraries for garbled circuits and oblivious transfer. \texttt{emp-zk} has implementations of three novel interactive ZK systems:
\begin{itemize}
    \item Wolverine \cite{weng2021wolverine}, the first of these systems, presents a constant-round, scalable, and prover-efficient interactive ZK scheme.
    \item Mystique \cite{weng2021mystique}, built on top of Wolverine, focuses on machine learning applications. This work presents efficient conversions for arithmetic and boolean values, fixed-point and floating-point values, and committed and authenticated values. 
    % Alongside this, this work presents an efficient matrix multiplication ZKP by utilizing Freivald's algorithm \cite{freivalds1977probabilistic}.
    \item Quicksilver \cite{yang2021quicksilver}, also built on top of Wolverine, further improves communication costs and scalability.
\end{itemize}

The main primitive these schemes take advantage of is subfield Vector Oblivious Linear Evaluation (sVOLE), which the authors extend and optimize for their ZK scheme. 
% sVOLE is used to efficiently realize the information-theoretic message authentication codes (IT-MAC) commitment scheme.
% , which allows a prover and verifier to interactively create a commitment.
For sake of brevity, we spare the technical detail in this paper and refer to \cite{Weng2023VOLEBasedInteractive} for an excellent explanation. \texttt{emp-zk} provides a very user-friendly interface to all 3 ZK systems, with clear-cut examples. Although documentation is not explicitly provided, \texttt{emp-zk} largely relies on C++ syntax and does not require much knowledge about the underlying work in ZKPs, making it one of the more accessible options. One potential downside of these systems are that they are interactive, meaning all proofs are \textit{designated-verifier}. We highly recommend this framework for users who are building custom machine learning-based custom applications that rely on floating-point operations, or applications that rely on scalability (e.g. database operations).

\textbf{Moz$\mathbb{Z}_{2^k}$arella.}
This work \cite{baum2022moz} presents a new protocol that utilizes an novel vector oblivious linear evaluation (VOLE), a tool from secure two-party computation, extension to perform zero knowledge proof operations efficiently over the integer ring $\mathbb{Z}_{2^k}$. This is very important as most ZK systems are made to operate over finite fields, which is not representative of modern CPUs. The proof system is coined with the term \texttt{Quarksilver}. This protocol outperforms the previous state-of-the-art VOLE-based works that operate over finite fields. The accompanying implementation enables development of ZK applications with the \texttt{Quarksilver} protocol as the underlying scheme. The \texttt{Moz$\mathbb{Z}_{2^k}$arella} repository is not actively maintained, however has 3 sub-libraries for oblivious transfer, garbled and arithmetic circuits, and private set-intersection. Within these sub-libraries there are several examples that explain how to use the \texttt{Moz$\mathbb{Z}_{2^k}$arella} syntax, including examples for \texttt{Quarksilver}. While the examples are somewhat clear, using this library to build custom applications requires a deep knowledge of the underlying proof system, as users must be aware of the parameters that are being set on a per application basis. We only recommend this to users who's applications fully rely on using the specific underlying protocol in this framework.



\subsection{zk-STARKs}

\textbf{Miden VM.}
\texttt{Miden VM} \cite{PolygonMiden2023MidenVM} is a zero-knowledge virtual machine (zkVM) implemented in Rust, in which all programs that are run generate a zk-STARK that can be verified by anyone.
\texttt{Miden VM} is designed as a stack machine, consisting of a stack, memory, chiplets, and a host. The stack, the main user-facing component, is a push-down stack of field elements, which is where inputs and outputs of operations are stored. Increasing the amount of inputs that are initialized on the stack before program execution increases the verifier cost. Whatever is left on the stack after program computation is declared as a public input to the verifier, which also increases cost to the verifier. A prover's private inputs must be pushed to the stack during program computation to be kept private.
The aim of Miden VM is, in their own words, to "make Miden VM an easy compilation for high-level languages such as Rust" \cite{PolygonMiden2023VMOverview}. As these compilers do not yet exist, the only way to build custom circuits is using Miden's assembly language, a very low-level API that interfaces with the Miden stack, and Miden chiplets, which are optimized assembly-based modules that perform common operations, like field arithmetic. Although \texttt{Miden VM} is Turing complete and offers standard control flow, it is often challenging for a developer to translate their desired computation to assembly commands and managing the stack at the same time, especially as the size of computation scales up. While \texttt{Miden VM} is a very valuable tool, we believe that its highest potential will be achieved upon completion of an accompanying compiler from a high-level language to Miden assembly. We recommend that users use this to benchmark certain atomic operations, but to avoid building custom applications with this framework due to the lack of a frontend.

% \textbf{Starky}

\textbf{Zilch.}
The \texttt{Zilch} framework \cite{mouris2021zilch} consists of a Java-like frontend (ZeroJava) that interfaces with a novel zero-knowledge MIPS processor model (zMIPS) \cite{TrustworthyComputing2023Zilch} to enable efficient interactive zk-STARK proof generation for custom computations. The ZeroJava frontend is highly sophisticated and is one of the only frameworks to enable an object-oriented programming approach. All ZeroJava programs are compiled into optimized and verifiable zMIPS instructions. As all of the instructions are verifiable, any program that can be expressed in ZeroJava can be verified using ZKPs. The underlying zMIPS processor can implement and verify any arbitrary computation in zero-knowledge. The zMIPS instructions are implemented using the zk-STARK library \cite{ben2018scalable}. After computation description in ZeroJava and compilation to zMIPS, the constraints for the program are represent in algebraic intermediate representation (AIR) format. The prover and verifier interactively undergo the zk-STARK process until the verifier is convinced that the prover's work is sound. 
\texttt{Zilch} provides an elegant and accessible approach to building custom circuits that utilize zk-STARKs. Although the works lacks dedicated documentation, the examples that are provided show that development of custom applications is almost as simple as implementing the program in Java, with a few ZeroJava design considerations. We recommend this for users with general knowledge of the MIPS instruction set architecture, which should allow them to build optimized programs.

\textbf{RISC Zero.}
\texttt{RISC Zero} is a zkVM \cite{RISCZero2023DeveloperDocs} implemented in Rust with an underlying RISC-V processor and instruction set architecture. The goal of this work is to produce publicly verifiable proofs of all the computations that are done within the framework. As the underlying instructions are derived from RISC-V, virtually any arbitrary computation can be expressed and verified in zero-knowledge.
In this framework, custom circuits can be built using standard Rust syntax, with a few minor modifications to incorporates the framework's API. This program is compiled to a set of RISC-V instructions, which is then executed within a \texttt{RISC Zero} session, which is recorded. A receipt of this session is recorded and used as part of the zk-STARK proof, which can be verified by any verifier to check validity of the computation.
\texttt{RISC Zero} provides a relatively readable high-level Rust API, alongside several examples and very detailed documentation. Due to the maturity of the Rust development and \texttt{RISC Zero} as a whole, developers are able to import a majority of the most used standard Rust crates without trouble, enabling much more streamlined and efficient application development. For instance, developers can use the JPG crate \cite{RustImageCrate2023} to build zero-knowledge applications around images. Alongside this, \texttt{RISC Zero} enables GPU acceleration, so that relevant applications can take advantage of computational speedup. We do note that although GPU acceleration is implemented in the RISC Zero codebase, we were not able to get it actually working due to some inconsistencies within the codebase. However, \texttt{RISC Zero} has an active community around it, including active development by the creators, and a very well-documented and accessible code, making it a great candidate for new developers of custom ZKP applications. The primary drawback for this framework is that, due the nature of zkVMs and the simulation of a RISC-V processor and ISA, this framework has relatively significant initialization and operation costs.