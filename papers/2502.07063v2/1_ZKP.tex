\section{Zero-Knowledge Proofs}

Zero-Knowledge Proofs (ZKPs) are a cryptographic primitive that allow a prover \Prv to prove to a verifier \Vrf that they know a secret value $w$, called the witness, without revealing anything about $w$. \Prv does this by showing that they know a secret value $w$ such that $\mathcal{F}$ evaluated at $w$ equals some public output $y$. Formally, \Prv sends a proof attesting that $\mathcal{F}(x; w)=y$, where $x$ and $y$ are public inputs and outputs, respectively. ZKPs have three core attributes \cite{goldreich1994definitions}:
\begin{enumerate}
    \item \textbf{Soundness}: \Vrf will find out, with a very high probability, if a \Prv is dishonest if the statement is false.
    \item \textbf{Completeness}: An honest \Prv can convince \Vrf if the statement is true.
    \item \textbf{Zero-Knowledge}: If the statement is true, \Vrf will learn nothing about the \Prv's private inputs - only that the statement is true.
\end{enumerate}
In the following sections, we discuss the evolution of ZKPs, the nuances of specific classes and schemes, and provide a detailed overview of the current ZK landscape.

% \subsection{The Evolution of ZKPs}

% \subsection{Interactive vs. Non-Interactive}

% ZKPs can broadly be classed into two categories: interactive and non-interactive \cite{wu2014survey}. Interactive protocols, as the name suggests, require several rounds interaction before \Vrf is convinced that \Prv's proof is valid. This is done by \Vrf sending random challenges to \Prv until \Vrf is convinced that \Prv's proof is valid. Interactive ZKPs require that both \Prv and \Vrf stay online until \Vrf is convinced. This somewhat limits the utility of interactive ZKPs, as the proofs are \textit{designated-verifier}, meaning that \Prv's proof can only be used to be convinced a single verifier. A separate protocol must be performed for each new \Vrf. Conversely, non-interactive ZKPs are normally \textit{publicly verifiable}, meaning \Prv can generate a single proof in one-shot that any \Vrf can verify. Non-interactive ZKPs often rely on a trusted setup process from a third-party, or in some cases \Vrf, to generate randomness that allows for a proof to be generated that \Vrf accepts as valid without further interaction. Many non-interactive schemes aim to minimize proof size, which results in higher \Prv computational power requirements. This limits the scalability of these schemes, especially in scenarios where \Prv is resource-constrained. The interactivity of interactive ZKPs allows for a more scalable approach in terms of \Prv computation, albeit limiting the amount of verifiers that can verify a proof. If needed, there is a method for turning public-coin interactive ZKPs into non-interactive ZKPs. The Fiat-Shamir transform \cite{kilian1992note} replaces \Vrf's randomness with a random oracle (i.e. a cryptographic hash function), thus removing the interaction and turning interactive ZKPs into non-interactive ZKPs. \nojan{The Fiat-Shamir transform is not (necessarily) a transform if we are using a random oracle (as opposed to an instantiated hash function. The appropriate term to use is instead "Fiat--Shamir transform". Also, the sentence should clarify that only *public-coin* interactive proofs can be converted to non-interactive proofs via the FS transform. DONE}
 
\subsection{Taxonomy of ZKPs}

In this work, we analyze 25 ZK protocols. Amongst these protocols are a mix of interactive and non-interactive schemes. An in-depth explanation of the difference between interactive and non-interactive schemes can be found in Appendix \ref{sec:interactive}. From now on, we describe computation as circuits \Cir, as that is what they are referred to as in ZK literature. This is due to the process of arithmetization, which represents functions, such as Python/C++ code, as arithmetic circuits, then converts these circuits into a mathematical representation (e.g. polynomials) that can be used within ZKPs. Oftentimes, an intermediate step between the input and output is a set of constraints that describes the code/circuit. These constraints act as the basis for the mathematical representation. For brevity's sake, we do not discuss the details of arithmetization and refer to the brilliant explanations of \cite{LambdaClass2023ArithmetizationSchemes, ButerinQuadraticArithmeticPrograms}. In this text, we only treat arithmetization as a black-box and do not require the knowledge of specific details, only the inputs (e.g. code) and outputs (e.g. mathematical representation). Table \ref{tab:pros} compares the seminal ZK protocols at a high-level. Below, we describe the taxonomy of the general schemes that underlie our chosen ZK protocols in detail. 
% \nojan{Do we need arithmetization section?}

\input{pros_cons_table}

\textbf{Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge (zk-SNARKs)} are, as the name suggests, a class of non-interactive protocols that boast small proof size \cite{ben2014succinct}. Although ZKPs were originally conceived in the late 1980's \cite{goldwasser2019knowledge}, zk-SNARKs were formally introduced about a decade after. Efficient instantiations of zk-SNARKs were introduced in the last decade, resulting in recent advancements in making zk-SNARKs practical and efficient for widespread use. 
% \nojan{zkSNARKs are *not* the earliest "ZK" constructions conceived; indeed, modern renditions of zkSNARKs are only 10-13 years old, while the concept of ZKPs is almost 40 years old. (While the zkSNARK of Micali also dates back to 30 years ago, efficient instantiations of it only date back to around 10 years ago as well) DONE}
This means there are much more mature open-source and real-world implementations available. The most common forms of zk-SNARKs are referred to as \textit{pre-processing zk-SNARKs}. One of the main drawbacks of these zk-SNARKs are that they require a trusted setup for every new circuit \Cir, which is computationally intensive and requires communication of large proving and verifying keys to the respective parties. 
Alongside this, \Prv must normally be computationally powerful in order to ensure small proof size. This is due to the fact that most zk-SNARKs are reliant on elliptic curve cryptography (ECC) as their underlying cryptographic arithmetic.
Recent works have introduced zk-SNARKs that can utilize \textit{universal} trusted setups \cite{plonk, chiesa2020marlin} for established maximum circuit sizes, and zk-SNARKs that do not require a trusted setup at all \cite{setty2020spartan, wahby2018doubly}. 
% These result in the evaluation and commitment of very large polynomials, which takes a toll on the complexity of any \Prv algorithm.
Due to the non-interactivity, zk-SNARKs are \textit{publicly verifiable}, meaning any verifier can verify them without recomputing the proof. One of the most common underlying schemes, especially in our highlighted frameworks, for zk-SNARKs is Groth16 \cite{groth16}, which improves upon the original Pinocchio \cite{parno2016pinocchio} protocol. zk-SNARK arithmetization \textit{typically} results in a set of constraints, called Rank 1 Constraint Systems (R1CS) \cite{belles2022circom}, which are then converted to a set of polynomials, called a Quadratic Arithmetic Program (QAP) \cite{gennaro2013quadratic}. We do note that there are different formats that are zk-SNARKs are compatible with, such as Algebraic Intermediate Representations (AIR) \cite{ben2018scalable} and Plonkish tables - we simply highlight R1CS as a prevalent constraint system. The Groth16 zk-SNARK generation and verification process can be represented at a high-level with the following algorithms:
\begin{itemize}
    \item $(\mathcal{VK, PK})\xleftarrow[]{}$ Setup(\Cir): A trusted third party or \Vrf run a setup procedure to generate a prover key $\mathcal{PK}$ and verifier key $\mathcal{VK}$. These keys are used for proof generation and verification, respectively. This setup must be repeated each time \Cir changes.
    \item $\pi \xleftarrow[]{}$ Prove($\mathcal{PK}$, \Cir, $x$, $y$, $w$): \Prv generates proof $\pi$ to convince \Vrf that $w$ is a valid witness.
    \item $1/0 \xleftarrow[]{}$ Verify($\mathcal{VK}$, \Cir, $x$, $y$, $\pi$): \Vrf accepts or rejects proof $\pi$. Due to soundness property of zk-SNARKs, \Vrf cannot be convinced that $w$ is a valid witness by a cheating \Prv.
\end{itemize}

\noindent In Appendix \ref{sec:recursive}, we describe how zk-SNARKs can be extended to allow recursive construction and verification of proofs.

As we stated, one of the drawbacks of traditional pre-processing zk-SNARKs is their reliance on a trusted setup per circuit \Cir.
% \noindent \nojan{appendix} Recent works \cite{bowe2019recursive, kothapalli2022nova, bitansky2013recursive} have shown the usability of recursive zk-SNARKs, which is verifying multiple zk-SNARKs in a single zk-SNARK. As the verification algorithm of zk-SNARKs is simply an arbitrary computation, it can be represented as a circuit \Cir. This enables one \Prv to generate many proofs, then generate a proof that verifies these proofs and send it to \Vrf. While this results in substantially more work on \Prv, \Vrf now only has to generate one proof to verify all of \Prv's data, rather than many individual proofs. 
% \nojan{mention ECC and bilinear mappings}
% \noindent\textbf{Interactive}
PLONKS, a subset of zk-SNARKs, are a class non-interactive ZK protocols that improve upon pre-processing zk-SNARKs by getting rid of the trusted setup per circuit \Cir, while adding a bit more arithmetic flexibility \cite{plonk}. PLONKs utilize the idea of a universal and updatable trusted setup, introduced in theory by \cite{cryptoeprint:2018/280} and in practice by \cite{cryptoeprint:2019/099}, in which a trusted setup procedure is done for circuits up to a certain size. 
% As mentioned in the previous section, some zk-SNARKs support universal and updateable setup - PLONKs are a specific included in this group.
% \nojan{"PLONKs" did not introduce the notion of universal and updatable setup; the first work to suggest this notion was that of \url{https://urldefense.com/v3/__https://eprint.iacr.org/2018/280__;!!Mih3wA!CvVqOHy12qd4JA_R87hM_kzJDnP_zincsfv36HU7wk-Ug48iOQHAiqfnlHplxrc01wVlpNigN-eTh3CLUudEOmE7apE$} , and the first efficient construction for NP-complete languages was that [Sonic](\url{https://urldefense.com/v3/__https://eprint.iacr.org/2019/099__;!!Mih3wA!CvVqOHy12qd4JA_R87hM_kzJDnP_zincsfv36HU7wk-Ug48iOQHAiqfnlHplxrc01wVlpNigN-eTh3CLUudEg2ZegzE$} ).
% \nojan{"PLONKs are not widely adopted": first of all I don't see why PLONK-type arithmetization based SNARKs need to be separately categorized (they're a subcategory) and take a look at L2Beat multiple deployments exist} There are also plenty of other constructions that achieve this property, e.g., Marlin, Lunar, ECLIPSE, etc. DONE}
Every circuit \Cir that fits within these size constraints can utilize the parameters generated by the universal trusted setup process. While PLONKs introduce a universal trusted setup, it comes at the cost of proof size and \Vrf runtime. PLONK proofs are normally $2-5\times$ the size of zk-SNARKs, and \Vrf runtime is marginally higher. It is important to note that, although PLONK proofs are larger than those of zk-SNARKs, proof size still remains in the KB range. The advantage that PLONKs have is that they are flexible in the commitment scheme they can use. By using the standard Kate commitments \cite{kate2010constant}, PLONKs become more zk-SNARK-like, as these commitments are based on ECC. FRI commitments \cite{ben2018fast}, which rely on Reed-Solomon codes and low-degree polynomials/testing for verifiers, can also be used to make PLONKs more zk-STARK-like. The type of commitment schemes allows developers to balance the tradeoff between performance and security assumptions. PLONK arithmetization is similar to that of zk-SNARKs, meaning that the resulting representation is a set of polynomials. To get there, PLONKs sets constraints for each gate (e.g. multiplication, addition) from the arithmetic circuit representation of the computation in the form of  Lagrange polynomials. Once the constraints are set, a special permutation function is used to check consistency between commitments. Finally, a final set of polynomials is constructed to fully represent the given computation. Overall, PLONKs provide a method to flexibly construct ZKPs with a less stringent trusted setup requirement, at the slight cost of performance. 
% \nojan{check this}

\textbf{Zero-Knowledge Scalable Transparent Arguments of Knowledge (zk-STARKs)}, which can be thought of as interactive oracle proof (IOP)-based zk-SNARKS, completely remove the dependence on trusted setup. Rather than using randomness from a trusted party, these protocols use publicly verifiable randomness for generating the necessary parameters for proof generation and verification. zk-STARKs achieve post-quantum security guarantees by utilizing collision-resistant hash functions as their underlying cryptography, rather than ECC. This increased security comes at a cost, as zk-STARK proofs are typically an order of magnitude larger than zk-SNARKs and PLONKs, and require more computational resources to generate and verify \cite{ben2018scalable}. The main contributor towards these drawbacks are the underlying data structure that are used in proof generation: Merkle trees. In zk-STARKs, Merkle trees are used to create a compact representation of the computation's execution trace. During proof generation, the computation's execution trace is arithmetized into polynomials, which are verified by performing low-degree testing, a process which ensures that the polynomials are of expected degree. Low-degree testing is enabled by the use of FRI commitments \cite{habock2022summary}. The polynomials are evaluated at certain points to verify their correct represenation of the execution trace, and these evaluations are used as the leaf nodes of the Merkle tree. The root of the Merkle tree then acts as a sort of commitment to these evaluated polynomials, hence allowing the verifier to simply verify the root, rather than verifying the whole computation trace. \cite{ashur2018marvellous} The use of Merkle trees are what enable the \textit{scalability} of zk-STARKs. While the Merkle trees support efficient verification, the proof size is drastically increased due to the inclusion of the material needed for verification, such as the Merkle root, polynomial evaluations, FRI commitments, and necessary Merkle branches. We note that there are IOP-based zk-SNARKs that stray away from this general protocol, but these steps are the most consistently utilized in current literature. Overall, zk-STARKs primarily benefit from being scalable and post-quantum secure with no trusted setup, at a significant cost to proof size and \Prv/\Vrf computation.

\textbf{MPC-in-the-Head (MPCitH)} ZKPs are a class of ZK protocols that take a completely novel approach towards proof generation and verification. The primary cryptographic basis is secure multiparty computation (MPC). MPC is a cryptographic primitive that allows for $n$ parties to jointly compute a function $f(x_1, ..., x_n)$, on private inputs from each party, without leaking any information about the private inputs. One of the prominent approaches to enable MPC is secret sharing, in which parties distributes secret shares of their private inputs amongst each other to compute a function. MPCitH, proposed by \cite{ishai2007zero}, allows for \Prv to simulate the $n$ MPC parties and following computation locally, or "in the head". Theoretically, any MPC protocol that can compute arbitrary functions can be transformed into a MPCitH ZKP. For $n$ parties $\{P_1,...,P_n\}$, secret shares are generated by each party and distributed to every other party. For the underlying arithmetic, the circuit \Cir is defined in an MPC manner to operate on secret shared data. \Prv can then simulate each parties' computation of the circuits with the secret shares they obtained from all other parties. After this is complete, \Prv has $n$ sets of messages and data that were generated and received by each party, called views. \Prv uses a standard commitment scheme to generate $n$ view commitments. Finally, \Prv and \Vrf interactively verify a subset of these views for consistency and correctness \cite{sidorenco2021formal}. While MPCitH protocols are innately interactive, they can be made non-interactive using the Fiat-Shamir transform. Theoretically, a huge advantage of the MPCitH approach is that MPC-friendly optimizations, which have been much further studied, can be utilized during proof generation to drastically improve \Prv efficiency and proof length. However, the most effective optimizations for MPC may translate to effective solutions for MPCitH. One of the core parameters MPCitH schemes aim to minimize is the communication complexity, as this directly reduces the amount of data that is present in each party's committed view. Just like zk-STARKs, MPCitH-based ZKPs do not require a trusted setup and are post-quantum secure, as MPC is thought to be generally quantum secure \cite{sidorenco2021formal}. Overall, MPCitH proposes a unique approach towards ZKP construction that are transparent post-quantum secure that allows flexibility in the underlying arithmetic to optimize the cost of proof generation and verification and proof size.

\textbf{Vector Oblivious Linear Evaluation (VOLE)-based ZK} 
protocols are a set of interactive techniques that achieve high efficiency and scalability through the use of information-theoretic message authentication code (IT-MAC)-based commitment schemes, which can be efficiently implemented using VOLE correlations. In VOLE-based ZKP protocols, the prover acts as the VOLE sender, while the verifier takes on the role of the VOLE receiver.
VOLE correlations are a pair of random variables, (\textbf{u}, \textbf{x}), known by \Prv and (\textbf{v}, $\Delta$), only known by \Vrf, in which \textbf{u}, \textbf{x}, and \textbf{v} are vectors, and $\Delta$ is a scalar key \cite{}. These variables satisfy the relation:
\begin{equation*}
    u_i = v_i + x_i \cdot \Delta
\end{equation*}
This functionality typically operates over a finite field.
Generally, in VOLE-based ZK, IT-MACs are used as commitments to authenticated wire values in arithmetic or boolean circuits representing a computation $\mathcal{C}$. \Prv demonstrates knowledge of a private vector $\textbf{w}$, which represents the witness, where $\mathcal{C}(\textbf{w}) = 1$, while proving the consistency throughout the protocol, without revealing any information about \textbf{w}.
\nojan{review and add VOLEitH}
VOLE-based proofs provide unparalleled scalability and communication optimizations, however, they are inherently designated-verifier protocols, meaning that \Prv must communicate with every \Vrf that aims to verify the proof, as \Vrf must maintain the secret $\Delta$ to ensure soundness. To address this, \cite{baum2023publicly} proposes a new VOLE-based paradigm, entitled VOLE-in-the-head (VOLEitH), which enables non-interactive VOLE-based ZK.

% \nojan{limbo has good explanation}


% \noindent\textbf{Recursive SNARKs}

% \nojan{make table comparing the zk schemes pros and cons}

% \subsection{Proving Systems}

% \noindent\textbf{Pinocchio}

% \noindent\textbf{Groth16}

% \subsection{Underlying Arithmetic}

% \noindent\textbf{Arithmetization}

% \noindent\textbf{Elliptic Curve Cryptography}
% Talk about https://hackmd.io/@benjaminion/bls12-381