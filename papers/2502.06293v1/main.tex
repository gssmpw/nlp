\documentclass[runningheads]{llncs}
\usepackage{cite}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{url}

\usepackage{graphicx}
\usepackage{fancyvrb}
\usepackage{xspace}
\usepackage{url}
\usepackage{xcomment}
\usepackage[normalem]{ulem}
\usepackage[shortlabels]{enumitem}
\usepackage{amsmath}
\usepackage[font={small,bf,sf}, textfont={small,sf}]{caption}
\usepackage{subcaption}
\usepackage{array}
\usepackage{longtable}
\usepackage{setspace}
\usepackage{dblfloatfix} \usepackage{mathtools}
\usepackage[formats]{listings}

\lstdefineformat{C}{\{=\newline\string\newline\indent,\}=[;]\newline\noindent\string\newline,\};=\newline\noindent\string\newline,;=[\ ]\string\space}
\newcommand{\ie}{i.e.\@\xspace}
\newcommand{\Eg}{E.g.\@\xspace}
\newcommand{\eg}{e.g.\@\xspace}
\newcommand{\etal}{et al.~}
\newcommand{\vs}{vs.\ }
\newcommand{\cf}{cf.~}
\newcommand{\wrt}{w.r.t.~}
\newcommand{\resp}{resp.\@\xspace}

\usepackage{booktabs}
\usepackage{multirow}
\usepackage{pifont}
\usepackage{balance}
\usepackage{scalefnt}
\usepackage{upquote}

\usepackage{soul}

\usepackage{etoolbox}

\makeatletter
\patchcmd{\SOUL@ulunderline}{\dimen@}{\SOUL@dimen}{}{}
\patchcmd{\SOUL@ulunderline}{\dimen@}{\SOUL@dimen}{}{}
\patchcmd{\SOUL@ulunderline}{\dimen@}{\SOUL@dimen}{}{}
\newdimen\SOUL@dimen
\makeatother

\usepackage{marginnote}
\usepackage{comment}
\usepackage{footnote}
\usepackage[framemethod=tikz]{mdframed}

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning,fit,shadows,calc}

\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
\urlstyle{rm}








\usepackage[draft,margin]{fixme}
\fxsetup{theme=color,mode=multiuser}
\FXRegisterAuthor{JL}{aJL}{JL}
\FXRegisterAuthor{OP}{aOP}{OP}
\FXRegisterAuthor{DOK}{aDOK}{DOK}
\usepackage{listings}
\usepackage{float}
\usepackage{listings-rust}
\lstset{
    basicstyle=\ttfamily,
    keepspaces=true,
    columns=flexible,
    language=Rust,
    keywordstyle=\bfseries,
    style=boxed,
    escapechar=@
}


\newcommand{\rustmc}{\textsc{RustMC}\xspace}
\newcommand{\genmc}{\textsc{GenMC}\xspace}

\makeatletter
\RequirePackage[bookmarks,unicode,colorlinks=true]{hyperref}\def\@citecolor{blue}\def\@urlcolor{blue}\def\@linkcolor{blue}\def\UrlFont{\rmfamily}
\def\orcidID#1{\smash{\href{http://orcid.org/#1}{\protect\raisebox{-1.25pt}{\protect\includegraphics{orcid_color.pdf}}}}}
\makeatother


\begin{document}


\title{\rustmc{}: Extending the \genmc{}\\  stateless model checker to Rust}



\author{Oliver Pearce\orcidID{0009-0004-1412-9961} \and
  Julien Lange\orcidID{0000-0001-9697-1378} \and
  Dan O'Keeffe\orcidID{0000-0003-3751-477X}}



\authorrunning{O.\ Pearce et al.}
\institute{Royal Holloway, University of London, UK}
\maketitle              \begin{abstract}
\rustmc is a stateless model checker that enables
verification of concurrent Rust programs.
As both Rust and C/C++ compile to LLVM IR, \rustmc builds on \genmc
which provides a verification framework for LLVM IR.
This enables the automatic verification of Rust code and any C/C++
dependencies.
This tool paper presents the key challenges we addressed to extend
\genmc. These challenges arise from Rust's unique compilation strategy and
include intercepting threading operations, handling memory intrinsics and
uninitialized accesses.
Through case studies adapted from real-world programs, we demonstrate
\rustmc's effectiveness at finding concurrency bugs stemming from
unsafe Rust code, FFI calls to C/C++, and incorrect use of atomic
operations.


 \keywords{Model Checking \and Rust \and LLVM.}
\end{abstract}





\section{Introduction}



Rust is a popular systems programming language that enforces memory and
thread safety through its ownership and borrowing system. Values in Rust have a
single owner variable and can be borrowed either mutably or immutably, with
mutable borrowing preventing any concurrent borrows of the same value.
These constraints effectively prevent data races in most safe Rust
code, as threads cannot make simultaneous unsynchronised memory accesses when
one of these accesses is a write.

While Rust's type system 
prevents many of the common memory safety issues found in other systems 
programming languages, verification of concurrent programs remains an ongoing 
challenge. 
Concurrency bugs occur in Rust for a range of reasons, including
atomicity violations, ``unsafe'' Rust code and interactions between Rust
and C/C++ foreign function interface (FFI) dependencies.

In this tool paper we extend the \genmc{}~\cite{Kokologiannakis21} stateless model
checker to support the verification of multithreaded Rust programs. By
leveraging the LLVM compiler infrastructure's intermediate representation (IR)
we derive verifiable LLVM IR modules from both Rust programs and their C/C++
dependencies. 
\rustmc is, to the best of our knowledge, the only available framework capable
of exhaustively exploring the state space of Rust programs and their dependencies,
facilitating the detection of data races stemming from Rust, C/C++ and
interactions between the languages. 
While our LLVM IR based approach allows us to verify mixed-language programs, 
relying on this low-level representation introduces challenges. Specifically, 
transforming an IR module emitted by the Rust compiler into a verifiable 
representation containing an unambiguous series of read and write operations 
requires significant changes to \genmc{}'s compilation and transformation stages.
In the following sections we describe how we overcame these challenges and demonstrate the tool's applicability to real-world concurrent programs.



The key contributions of this paper are:
\textbf{(1)} We present \rustmc{}, an extension of \genmc{}, the first model
checker capable of verifying concurrent Rust programs and their FFI
dependencies;
\textbf{(2)} We develop novel LLVM transformations to handle
Rust-specific challenges, including LLVM memory intrinsics and
uninitialised memory accesses, that arise from Rust's unique
compilation strategy;
\textbf{(3)} We demonstrate \rustmc's effectiveness through examples
adapted from real-world concurrent programs, showing its ability to
detect data races in both pure Rust code and mixed-language programs
that use C/C++ dependencies; and
\textbf{(4)} We provide \rustmc{} as an open-source tool that extends
\genmc{} and enables the fully automated verification of concurrent Rust
applications.
We intend to submit an artifact consisting of: the source code of
\rustmc, its documentation, and example Rust programs. All are readily
available on GitHub~\cite{rustmc}.














 \section{Background}\label{background}

\subsection{Concurrency Bugs in Rust}




While Rust code provides strong safety guarantees, concurrency bugs can still
occur. A common source is seemingly safe Rust code
that harbours data races due to unsafe operations in foreign function
dependencies. For example, consider the simple Rust program shown in
Figure~\ref{fig:mixed_code_race_examplel}, which calls a C function
\lstinline{inc_C_counter()} from multiple threads.
Rust's type system normally prevents concurrent access to shared
data. However, the C function bypasses these safeguards and directly
manipulates a global counter variable without synchronisation. Rust's
borrow checker cannot verify memory safety guarantees across language
boundaries.


\begin{figure}[t]
\begin{lstlisting}[language=Rust, numbers=left]
// Rust code
extern "C" {fn inc_C_counter();}
fn main() {
        thread::spawn(|| {unsafe {inc_C_counter();}});
        thread::spawn(|| {unsafe {inc_C_counter();}});
}
\end{lstlisting}
\begin{lstlisting}[language=C, numbers=left]
// C dependency
int counter = 0;
void inc_C_counter() { counter++; }
\end{lstlisting}
  \caption{A data raced caused by an external, non-thread-safe, C function.}
  \label{fig:mixed_code_race_examplel}
\end{figure}


When analysing this program, our tool \rustmc successfully identifies the race
condition.
Specifically, it reports a data race where one thread
attempts to read the \lstinline{counter} while another thread simultaneously
writes to it.

In addition to data races that emerge from interactions between Rust and C code,
\rustmc{} targets two further sources of concurrency bugs (real-world examples
of which are discussed in~\S\ref{use_case}). The first is the use of the
\lstinline{unsafe} keyword in native Rust code, which disables the Rust
compiler's safety checks to provide developers with more flexibility. This can
lead to data races in Rust code without any foreign function interface calls.
Finally, even safe Rust code can experience atomicity violations when using
atomic types, as these types permit shared access and modification across
multiple threads~\cite{rust_reference_interior_mutability}.


\subsection{\genmc{}: A Stateless Model Checker for C/C++}
\genmc~\cite{Kokologiannakis21,KokologiannakisMV24} is a
state-of-the-art stateless model checker designed for verifying
concurrent C/C++ programs under weak memory models.

It operates by systematically exploring possible program executions
whilst accounting for relaxed memory behaviours permitted by different
models (e.g., RC11, IMM, LKMM).
It represents program behaviours through execution graphs comprising
events (nodes) that correspond to individual memory accesses,
connected by several key relations: program order (po) that captures
intra-thread ordering, reads-from (rf) that shows which writes are
read by reads, and coherence order (co) that totally orders writes to
the same location.
The latest version of the tool employs an optimal dynamic partial order
reduction (DPOR) algorithm that explores all possible program
executions up to some equivalence relation while avoiding redundant
explorations.
The tool's DPOR algorithm is optimal, meaning it explores exactly one
execution per equivalence class, while maintaining polynomial memory
requirements.

The tool's architecture consists of three main stages:
first, it uses LLVM to compile source code into an intermediate
representation (using \texttt{clang});
second, it transforms this code to make it easier and faster to
analyse, e.g., bounding infinite loops, eliminating dead allocations,
etc.;
and finally, it conducts verification by exploring program
executions and checking for errors such as data races, assertion
violations, and memory safety issues.


\genmc\ provides an ideal foundation for extending stateless model
checking to Rust programs.
Its integration with LLVM's intermediate representation creates a
natural bridge for verifying Rust code, as both Rust and C/C++ compile
to LLVM IR.
This alignment enables \rustmc\ to verify not only pure Rust programs
but also their interactions with C/C++ dependencies.
Moreover, \genmc's three-stage architecture provides a modular framework that
\rustmc\ can extend to handle Rust-specific challenges.
As \genmc remains under active development, \rustmc stands to
benefit automatically from future enhancements to the underlying
verification framework without requiring significant modifications to
its Rust-specific components.



 \section{\rustmc{}: Overview and Implementation Challenges}\label{implementation_challenges}

We next present \rustmc{}, an extension to the \genmc{} framework for
verifying Rust applications. Figure~\ref{fig:arch-rustmc} gives an
overview of the framework. As in \genmc{}, there are three
stages: compilation, transformation and verification. \rustmc{} 
primarily modifies the compilation and transformation stages.

\rustmc{} first compiles the application to LLVM IR using a customised Rust
toolchain. The toolchain relies on a
modified standard library with inlined calls to POSIX threading functions
(see~\S\ref{sub:std-inline}).
\rustmc{} then uses the \texttt{llvm-link} tool~\cite{llvm_link} to link the IR file with the
\genmc{} verification component, allowing it to intercept and track relevant
threading events. If the application contains FFI calls to C/C++ code, the
toolchain also links the resulting IR with the Rust IR. 



\rustmc{} transforms the resulting IR using a series of LLVM passes to
prepare it for verification. In comparison to \genmc{}, \rustmc{}
introduces two additional passes that address implementation
challenges relating to LLVM memory intrinsics (e.g., \texttt{memcpy},
see~\S\ref{sec:llvm_intrinsics}) and uninitialised memory accesses
(see~\S\ref{sec:undef}).

Finally, \rustmc{} feeds the transformed IR file to the verification component.
This executes the \genmc{} stateless model checking algorithm to detect any data races
or assertion violations across all potential thread interleavings.

\begin{figure}[t]\centering
\begin{tikzpicture}[
    node distance = 2.5cm,
    task/.style = {
        rectangle,
        minimum width=2.4cm,
        minimum height=3cm,
        text centered,
        draw=black,
        fill=green!10,
        rounded corners,
        drop shadow
      },
     tasklabel/.style = {
        font=\bfseries
      },
    subtask/.style = {
        rectangle,
        minimum width=1.5cm,
        minimum height=0.4cm,
        text centered,
        draw=black,
        fill=white,
        rounded corners,
        font=\small
    },
    arrow/.style = {
        thick,
        ->,
        >=stealth
      },
      scale=0.78, every node/.style={transform shape}
]

\def\documentpath#1#2{
\path (#1) coordinate (doc_center);
    \path (doc_center) +(-0.7,-0.5) coordinate (bottom_left)
                      +(0.7,-0.5) coordinate (bottom_right)
                      +(-0.7,0.5) coordinate (top_left)
                      +(0.7,0.1) coordinate (top_right)
                      +(0.4,0.5) coordinate (fold_start)
                      +(0.7,0.1) coordinate (fold_end);
    \fill[fill=yellow!10, drop shadow] 
        (top_left) -- (fold_start) -- (fold_end) -- 
        (top_right) -- (bottom_right) -- (bottom_left) -- cycle;
    \draw (top_left) -- (fold_start) -- (fold_end) -- 
          (top_right) -- (bottom_right) -- (bottom_left) -- cycle;
    \draw (fold_start) -- (fold_end);
    \node[font=\small, align=center] at (doc_center) {{\sf #2}};
}

\path (0,0.5) coordinate (doc0); 
\documentpath{doc0}{\texttt{.rs}}

\path (0,-1.3) coordinate (cpp); 
\documentpath{cpp}{\texttt{.c,.cpp}}


\node[draw,rectangle, minimum size=1.5cm,rounded corners,fill=yellow!10,drop shadow] at (3,-2.5) (stdlib) {
  \begin{tabular}{l}
    Adapted
    \\
    \texttt{std::thread},
    \\
    \texttt{std::sys}, \ldots
  \end{tabular}};


\node[task,minimum height=2.8cm, minimum width=3cm] at (3,0) (task1) {};
\node[subtask] (subtask11) at ([yshift=0.4cm]task1) {\texttt{\href{https://llvm.org/docs/Passes.html\#ipsccp-interprocedural-sparse-conditional-constant-propagation}{ipsccp}}};
\node[subtask] (subtask12) at ([yshift=-0.2cm]task1) {\texttt{\texttt{\href{https://llvm.org/docs/Passes.html\#memcpyopt-memcpy-optimization}{memcpyopt}}}};
\node[subtask] (subtask13) at ([yshift=-0.8cm]task1) {\texttt{std} inline (\S~\ref{sub:std-inline})};


\node[task, right=of task1,minimum height=2.5cm, minimum width=3cm] (task2) {};
\node[subtask] (subtask2) at (task2) {\texttt{intrinsic}  (\S~\ref{sec:llvm_intrinsics})};
\node[subtask] (subtask3) at ([yshift=-0.6cm]task2) {\texttt{undef}  (\S~\ref{sub:undef})};

\node[task, right=of task2] (task3) {};


\node[tasklabel] at ([yshift=-0.3cm]task1.north) {Compilation};
\node[tasklabel] at ([yshift=-0.3cm]task2.north) {Transformation};
\node[tasklabel] at ([yshift=-0.3cm]task3.north) {Verification};

\node at (task3) {\includegraphics[width=.19\textwidth]{genmc.png}};
\node[tasklabel,font=\small] at ([yshift=0.3cm]task3.south) {(as \genmc's)};


\draw[arrow] (stdlib) -- (subtask13);
\draw[arrow] ([xshift=0.7cm]doc0) -- (doc0-|task1.west);
\draw[arrow,densely dotted] ([yshift=0.52cm]cpp) -- ([yshift=-0.52cm]doc0.south);
\draw[arrow] (task1) -- node[midway] (doc1) {} (task2);
\documentpath{doc1}{\begin{tabular}{c}
                      LLVM \\ IR
                    \end{tabular}
                  }

\draw[arrow] (task2) -- node[midway] (doc2) {} (task3);
\documentpath{doc2}{\begin{tabular}{c}
                      LLVM \\ IR
                    \end{tabular}
                  }
                    
\end{tikzpicture}
\caption{Architecture of \rustmc.}\label{fig:arch-rustmc}
\end{figure}


 
\subsection{Externally Linked Threading Functions}\label{sub:std-inline}
\genmc{} tracks threading operations through its runtime interpreter.
To intercept threading operations in C/C++ applications, \genmc{} redefines symbols corresponding to standard threading library calls (\eg
\lstinline{pthread_create}) to use its own internal wrapper
functions (\eg \lstinline{_VERIFIER_thread_create}).
To verify Rust applications, \rustmc{} therefore overrides the
\texttt{pthread} calls in Rust's Unix threading implementation to 
use \genmc's internal \lstinline{_VERIFIER} functions.



A challenge with this approach is that for Rust applications compiled with the default Rust compiler and standard
library, \texttt{pthread} calls are externally linked and do not
appear in the resulting IR. 
A naive solution to this problem is to build the entire standard
library alongside the application to expose threading calls. However, this
approach has several downsides: first, processing the much
larger IR through each LLVM transformation pass becomes significantly
slower; second, the increased code complexity breaks LLVM optimisation
passes that \genmc{} relies on; and third, the larger codebase
significantly increases the engineering effort required to handle edge
cases and unsupported LLVM behaviours.


Instead of building the entire standard library, \rustmc{} selectively inlines
the threading related functions from the \texttt{std::thread} and
\texttt{std::sys} modules that we need to verify. This targeted
approach keeps the IR size manageable and avoids most LLVM
transformation issues. However, it means we cannot currently verify
programs that use standard library functions outside of these inlined
modules, as their definitions remain external. Our strategy is to
incrementally expand support by inlining additional standard library
components as needed.
\subsection{LLVM Memory Intrinsics}\label{sec:llvm_intrinsics}
LLVM supports a number of memory related intrinsic functions such as those
corresponding to the C standard library functions \texttt{memcpy()},
\texttt{memmove()}, and \texttt{memset()}.
A call to one of these intrinsics may perform a series of
byte-wise accesses. For example, \texttt{memcpy(ptr \%dest, ptr \%src,
  i64 24)} will copy 24 bytes from \texttt{\%src} to \texttt{\%dest}.
Modelling the effects of these intrinsics for tracking reads and writes 
is challenging as they often lead to mixed-size accesses in which a memory 
location accessed with one type is later accessed with a different type.
Mixed-size accesses can also lead to a read taking its value from multiple
writes. For example, if a \texttt{memcpy()} copies 8 bytes of memory
into a location which is subsequently loaded as an \texttt{i64} the
value read is dependent on 8 different write events~\cite{kokolgiannakis_mixed_size,SatoMKT24}.
\genmc{} must carefully track dependencies between the read and all
constituent writes to properly detect data races and verify ordering.








In \genmc{}, a custom LLVM pass promotes intrinsic calls into a series of typed
loads and stores that the interpreter component can handle as individual
accesses.
For C/C++ code, the pass takes the type of the allocated source and destination
parameters and constructs a series of load and store instructions with the
allocated types. However, this technique is not viable for Rust as the compiler
always allocates stack memory as an array of \texttt{i8}s using an untyped
\lstinline{alloca}, in keeping with LLVM's move
to opaque pointers~\cite{LLVM_struct_types_for_field_offsets_pr,LLVM_struct_types_for_alloca_pr}. This memory can be written to, and
subsequently read from, using any type.  This problem is exacerbated by the fact
that LLVM IR of Rust code tends to contain more \lstinline{memcpy} operations
than IR from C/C++ code.



To represent memory related intrinsics while minimising
mixed-size accesses, we implement heuristics for identifying and
transforming memory access patterns. Specifically, when \rustmc encounters
memory copies of aligned blocks (\eg lengths that are multiple of 8 bytes), it
transforms the intrinsic into a sequence of
64-bit accesses. 
This transformation successfully handles common memory copy
patterns. In particular, this approach works well for the common cases we observed in the Rust
standard library. It also has the advantage of being efficient.  We combine this with the existing interprocedural-sparse-conditional-constant-propagation \texttt{ipsccp} and memcpy optimisation \texttt{memcpyopt} LLVM passes in order to transform more memory intrinsics~\cite{ipsccp,memcpyopt}.
For other edge cases, \eg structs containing byte arrays, our
current implementation may fail during verification due to unsupported
mixed-size accesses.
We discuss how our efficient heuristic approach can complement recent
advances in mixed-size access support for \genmc{} to handle a wider
range of programs in~\S\ref{sec:related-work}.


\subsection{Undefined Values}\label{sub:undef}
\label{sec:undef}
LLVM supports undefined (\texttt{undef}) values to represent indeterminate
values. Typically, \texttt{undef} models loading from uninitialised
memory~\cite{LLVM_LOAD_SEMANTICS,taming_undefined_behaviour}. This is permitted
as long as the \texttt{undef} value is not used in a subsequent operation that
causes immediate undefined behaviour~\cite{LLVM_UB_MANUAL}.
\genmc{}'s model of memory accesses does not handle uninitialised loads as one of 
its key requirements is that each read should have a
preceding write to take its value from.
As loads from uninitialised memory have no preceding write the tool is
unable to construct an execution graph.


\begin{figure}[t]
\begin{lstlisting}[language=Rust, numbers=left]
pub fn foo() -> Result<(), i64> { Ok(()) }
\end{lstlisting}

\begin{lstlisting}[language=LLVM, numbers=left,  escapechar=|]
define { i64, i64 } @foo() unnamed_addr #0 !dbg !7 {
  %_0 = alloca [16 x i8], align 8 ; allocate 16 bytes
  store i64 0, ptr %_0, align 8, !dbg !35 ; put 0 in 1st chunk
  %0 = load i64, ptr %_0, align 8, !dbg !36 ; initialised read
  %1 = getelementptr inbounds i8, ptr %_0, i64 8, !dbg !36
  %2 = load i64, ptr %1, align 8, !dbg !36 ; uninitialised read |\label{lst:undef-load}|
  %3 = insertvalue { i64, i64 } poison, i64 %0, 0, !dbg !36
  %4 = insertvalue { i64, i64 } %3, i64 %2, 1, !dbg !36
  ret { i64, i64 } %4, !dbg !36  |\label{lst:undef-ret}|
}
\end{lstlisting}
\caption{Uninitialised read in Rust (top) and corresponding LLVM IR (bottom).}
\label{fig:unit_uninit_read}
\end{figure}

We provide an example of an uninitialised load occurring in typical Rust code in Figure 
\ref{fig:unit_uninit_read}. A function \lstinline{foo()} returns the \lstinline{Ok()} variant 
of the \lstinline{Result} type enum. 
A value of type \lstinline{Result<T, E>} is stored in memory as a tagged union where the size of the \lstinline{Result} is determined by its largest variant. 
Uninitialised reads can occur when \lstinline{T} is the unit type, i.e.
\lstinline{Result<(), E>}, as the entire \lstinline{Result<T, E>} must be read.
Since \lstinline{()} represents the absence of a return value and contains no
meaningful data it may be uninitialised.
An example of such an uninitialised read occurs at line
\ref{lst:undef-load} in Figure~\ref{fig:unit_uninit_read}, as nothing
is stored in the second 8-byte chunk of allocated memory.
The \lstinline{undef} value read is then inserted into an aggregate value
\texttt{\{i64, i64\}}, returned at line~\ref{lst:undef-ret}. 
On the LLVM level \lstinline{foo()} returns \texttt{\{0, undef\}} where \texttt{0} indicates that the result was \lstinline{Ok()}
rather than \lstinline{Err()}.



Uninitialised loads can also occur when \texttt{memcpy()} operates on
padded structs. When \rustmc promotes these \texttt{memcpy()} calls into a
sequence of typed loads and stores~(\S\ref{sec:llvm_intrinsics}), the transformation may generate
reads from uninitialized padding bytes between struct fields.
To handle uninitialized loads while meeting \genmc{}'s verification
requirements, we implement an LLVM pass that explicitly
writes undefined values into each stack allocation. These
writes are semantically neutral from LLVM's perspective, since storing
an undefined value is equivalent to preserving the existing bit
pattern in memory~\cite{LLVM_reference_manual_undefined_values}.
This approach allow us to verify programs containing uninitialised
reads as \genmc{} interprets an explicit ``\texttt{store undef}'' as
storing 0 to a memory location. Consequently each uninitialised read
has a preceding write, as required.


 \section{Detecting Real-World Bugs with \rustmc}\label{use_case}

To showcase the functionality of \rustmc, we present real-world
examples of concurrency bugs found in Rust programs. The bugs stem
from two sources: an atomicity violation and an unsafe implementation
of a thread-safe trait.
We show further examples in Appendix~\ref{app:examples} and online~\cite{rustmc}.


\subsection{Atomicity Violation}

We next describe an example of an atomicity violation in safe
Rust which our tool, \rustmc, is capable of detecting.
Figure~\ref{fig:atomicity_violation} presents code adapted from a bug reported
in the \texttt{rand} crate~\cite{rand_crate} (also documented in a study of Rust
concurrent programming
bugs~\cite{yu2019fearlessconcurrencyunderstandingconcurrent}).
Function \lstinline{is_getrand_available()} implements a common
pattern to cache the result of an expensive system call (\lstinline{getrandom}) in a thread-safe way without
using a (more expensive) mutex.


\begin{figure}[t]  
\begin{lstlisting}[language=Rust, numbers=left, tabsize=1,
		style=boxed]
static CHECKED: AtomicI64 = AtomicI64::new(0);
static AVAILABLE: AtomicI64 = AtomicI64::new(0);
fn is_getrand_available() -> i64 {
    if (CHECKED.load(Ordering::Relaxed) == 0 ){ @\label{chk.load}@
        let mut buf: [u64; 0] = [];
        let result = getrandom(&mut buf);
        let available = if result == -1 {...} else { 1 };
        AVAILABLE.store(available, Ordering::Relaxed); @\label{av.store}@
        CHECKED.store(1, Ordering::Relaxed); @\label{chk.store}@
        available
    } else { AVAILABLE.load(Ordering::Relaxed) } @\label{av.load}@
}
fn main() {
    let t1 = thread::spawn(||{is_getrand_available()});
    let t2 = thread::spawn(||{is_getrand_available()});

    let r1 = t1.join().unwrap();
    let r2 = t2.join().unwrap();

    assert_eq!(r1, r2);  @\label{atom-assert}@
}  \end{lstlisting}


\caption{An atomicity violation in safe code, adapted from the Rand crate~\cite{rand_fix_commit}.}
\label{fig:atomicity_violation}
\end{figure}


Two \lstinline{AtomicI64} variables are used to synchronise
operations:
\lstinline{CHECKED} indicates whether \lstinline{getrandom} has been
called before and \lstinline{AVAILABLE} denotes the availability of
\lstinline{getrandom};
both are first initialised to 0.
At compile time or run time, the atomic operations at
lines~\ref{av.store} and~\ref{chk.store} may be re-ordered such that one thread
loads \lstinline{AVAILABLE} before it is set by another.

We show an example of an undesirable interleaving below, assuming
threads \texttt{t1} and \texttt{t2} are concurrently executing
\lstinline{is_getrand_available()} in
Figure~\ref{fig:atomicity_violation}.
\begin{equation}\label{rand_interleaving}
  \centering
  \setlength{\tabcolsep}{12pt}
  \begin{tabular}{l@{\;}l||l@{\;}l}
    \multicolumn{2}{c}{\texttt{t1} } &   \multicolumn{2}{c}{\texttt{t2}}
    \\
    \hline
    \\ [-1em]
    {\texttt{CHECKED.store({\tiny\ldots})}}
                                     & {\small (line~\ref{chk.store})}
    \\[-0.5em]
                                     && 
                                        {\texttt{CHECKED.load({\tiny\ldots})}}
                                     &{\small(line~\ref{chk.load})}
    \\
                                     && {\texttt{AVAILABLE.load({\tiny\ldots})}}
                                     &{\small(line~\ref{av.load})}
    \\[-0.5em]
    {\texttt{AVAILABLE.store({\tiny\ldots})}}
                                     &{\small(line~\ref{av.store})}
  \end{tabular}
\end{equation}

Here, {\texttt{t1} } encountered \lstinline{CHECKED==false}, and sets
both \lstinline{CHECKED} and \lstinline{AVAILABLE} to
\lstinline{true}.
From {\texttt{t2}}'s point-of-view, if {\texttt{t1}
} has set \lstinline{CHECKED} before setting \lstinline{AVAILABLE},
then the function incorrectly returns false for {\texttt{t2}}.


To identify this bug, we must specify the property we are interested
in with an assert (line~\ref{atom-assert}). This assertion
characterises the consistency of concurrent calls to this function (i.e.,
all threads should see the same results, for all interleavings).
\rustmc can detect the bug and reports a trace,
see~\eqref{rand_interleaving}, violating atomicity.

\subsection{Data-Race in Thread-safe Traits}
We give another example that demonstrates how incorrect
implementations of Rust's thread safety traits can lead to data
races. The \lstinline{Sync} trait, which marks types as safe to share
between threads, requires careful implementation to maintain Rust's
safety guarantees.
This type of bug has occurred in practice, e.g., the \texttt{internment}
crate contained a data race due to an unsafe implementation of
\lstinline{Sync} for its \lstinline{Intern<T>} struct~\cite{git_intern}. The
implementation allowed the struct to be shared between threads even
when instantiated with non-thread-safe types, potentially leading to
memory corruption.
To illustrate this class of bug, we create a minimal example where a
struct containing a \lstinline{Cell<i64>} incorrectly implements
\lstinline{Sync}. The \lstinline{Cell} type provides interior
mutability but is explicitly designed to be non-thread-safe, making
this implementation unsound. Figure~\ref{unsafe_sync_example} shows
how this type definition can lead to data races.

\begin{figure}[t]
\begin{lstlisting}[language=Rust]
struct MyStruct { data: Cell<i64>, }

unsafe impl Send for MyStruct {} @\label{mystruct-send}@
unsafe impl Sync for MyStruct {} @\label{mystruct-sync}@

impl MyStruct {
    fn new(value: i64) -> Self {
        MyStruct { data: Cell::new(value), }
    }
    fn increment(&self) {self.data.set(self.data.get() + 1);}
}

fn main() {
    let foo = Arc::new(MyStruct::new(0)); @\label{mystruct-arc}@
    let foo_clone1 = foo.clone(); @\label{mystruct-clone1}@
    let foo_clone2 = foo.clone(); @\label{mystruct-clone2}@
    let t1 = thread::spawn(move || {foo_clone1.increment();});  @\label{t1.increment}@
    foo_clone2.increment(); @\label{main.increment}@
    t1.join().unwrap();
    let final_value = foo.data.get();
}\end{lstlisting}
\caption{Data-race in safe Rust code.}\label{unsafe_sync_example}
\end{figure}





\lstinline{MyStruct} contains a single field data which is a
\lstinline{Cell<i64>}, i.e., a type that provides interior mutability
(data can be mutated even via an immutable reference).
Lines~\ref{mystruct-send} and~\ref{mystruct-sync} declare 
\lstinline{MyStruct} as safe to send between threads
(\lstinline{Send}) and safe to share references across threads
(\lstinline{Sync}). As they appear in an \lstinline{unsafe} block, the
programmer is taking responsibility for thread safety.
However, \lstinline{MyStruct} implements the \lstinline{increment()} method,
which is clearly not thread-safe.
To expose the issue, we provide a \lstinline{main()} function which
makes two concurrent calls to \lstinline{increment()}.
Line~\ref{mystruct-arc} wraps a new \lstinline{MyStruct} in an
\lstinline{Arc} (Atomic Reference Counted), which allows safe sharing
between threads.
Lines~\ref{mystruct-clone1} and~\ref{mystruct-clone2} create new
references to \lstinline{foo}; hence both threads are modifying the
same underlying data.






When given Figure~\ref{unsafe_sync_example} as input, \rustmc
correctly identifies the race. It detects a conflict between the
unsynchronised accesses to \lstinline{foo} made by the main thread at
line \ref{main.increment} and the spawned thread at line
\ref{t1.increment}.



 \section{Related Work}\label{sec:related-work}
Rust and its usage have been the focus of much research in
the last decade.
Notably, RustBelt~\cite{JKD18} provides formal verification of Rust's
type system and ownership model.
Evans et al.~\cite{EvansCS20} shows that while only 30\% of Rust
libraries explicitly use unsafe code, over half contain unsafe
operations somewhere in their dependency chain that bypass Rust's
static checks.
Astraukas et al.~\cite{AstrauskasMP0S20} shows that unsafe code
appears frequently, particularly for language interoperability, though
its unsafe code tends to be straightforward and well-contained.


Dynamic partial order reduction (DPOR) techniques have been
successfully applied to model check concurrent programs across
different languages and
contexts~\cite{AbdullaAJS14,FlanaganG05,AbdullaAAJLS15}. For Rust
specifically, several tools target concurrency bug detection, though
with different approaches and tradeoffs compared to ours.

Miri~\cite{miri} is part of the Rust compiler project and is
advertised as ``an undefined behavior detection tool for Rust''. It
works as an interpreter of Rust's mid-level IR.
Miri is particularly effective at detecting undefined behaviours, but
its inherently dynamic approach means that it cannot systematically
analyse all potential interleavings of concurrent programs.
Loom~\cite{loom} is an adaptation of CDSChecker~\cite{NorrisD16}. It
explores interleavings of concurrent code under
the C11 memory model using partial-order reduction techniques.
Shuttle~\cite{awshuttle} is another concurrent code testing tool for
Rust, developed at AWS. It is similar to (and inspired by) Loom but
aims at better scalability at the cost of soundness. Shuttle uses a
randomised scheduler~\cite{BurckhardtKMN10} to guarantee good
coverage.
Lockbud~\cite{Lockbud,QinCLZWSZ24} is a static bug detector for
blocking bugs and potential atomicity violations in Rust. It
identifies potential atomicity violations by detecting syntactical
patterns commonly found in atomicity violation bugs. While this
pattern-based approach can identify potential issues, \rustmc's
systematic exploration of thread interleavings allows it to
definitively verify atomicity properties through assert statements,
detecting actual violations rather than potential ones.
Other work~\cite{CRUST_TomanPT15,LiWSL22_FFI_checker} explores 
verification techniques for Rust's FFI dependencies, but 
focuses primarily on memory management bugs rather than concurrency
issues.

\genmc{} has evolved significantly since its introduction in 2019, adding
support for locks~\cite{lock_handling_Kokologiannakis19}, 
barriers~\cite{barrier_aware_model_checking_Kokologiannakis21} and symmetry 
reduction~\cite{SPORE_2024_Kokologiannakis}.
Its latest development, MIXER, enables verification of programs with
mixed-size accesses at the cost of some additional
overhead~\cite{kokolgiannakis_mixed_size}. Integrating MIXER into
\rustmc would expand its capabilities to handle more use cases, but 
at the time of writing MIXER is yet to be integrated into \genmc's master
branch. As discussed in~\S\ref{sec:llvm_intrinsics}, we intend to
explore a hybrid strategy that combines our efficient heuristics with MIXER to
support a broader range of Rust programs while preserving verification
performance.
Independently, Sato et al.~\cite{SatoMKT24} have proposed an
alternative technique to support mixed-size access in \genmc, but
their implementation is not publicly available at the time of writing.


 \section{Conclusions}\label{sec:conclusions}
\rustmc represents a good step forward in verification of Rust code,
and opens new possibilities for detecting subtle concurrency bugs in
concurrent Rust programs and their FFI dependencies.
Extending \genmc to handle Rust's compilation characteristics
presented several technical challenges but its modular architecture
allowed us to re-use the back-end verifier.
Hence \rustmc will automatically benefit from future
improvements to \genmc's verification engine.


Looking ahead, \rustmc provides a foundation for systematic analysis
of real-world concurrent Rust programs, helping developers ensure
their code is free from concurrency issues.
Our future work will focus on applying \rustmc to verify concurrent
code in Rust projects and their dependencies.










 \bibliographystyle{splncs04}
\bibliography{references}

\newpage
\appendix
\section{Additional examples}\label{app:examples}
\subsection{Out of bounds accesses}
Data races in Rust may also cause out of bounds accesses to allocated
memory, resulting in an immediate unrecoverable \texttt{panic!}
error~\cite{rust_panic_documentation}.
Figure \ref{fig:rustonomicon-data-race} gives an example of such a
bug.
\begin{figure}[H]
\begin{lstlisting}[language=Rust, numbers=left, tabsize=1,
		style=boxed]
fn main() {
    let data = vec![1, 2, 3, 4];
    let idx = Arc::new(AtomicUsize::new(0));
    let other_idx = idx.clone();

    thread::spawn(move || { @\label{other_idx.ownership_move}@
        other_idx.fetch_add(10, Ordering::SeqCst); @\label{other_idx.increment}@
    });
    
    if idx.load(Ordering::SeqCst) < data.len() { @\label{idx.load}@
        unsafe {
            let i = idx.load(Ordering::SeqCst);
            let x = *data.get_unchecked(i); @\label{data.get_unchecked}@
        }
    }
}
\end{lstlisting}
    \caption{A data race which leads to an unrecoverable \texttt{panic!} error, adapted from \cite{rustonomicon} }
    \label{fig:rustonomicon-data-race}
\end{figure}

Variable \lstinline{other_idx} is a clone of the \lstinline{Arc} type
used as a thread safe reference counter, i.e., \lstinline{idx} and
\lstinline{other_idx} both contain references to the same value.
Recall that atomics have interior mutability and are not subjected to
restrictions on mutable aliasing.
An ownership move is performed at line~\ref{other_idx.ownership_move},
and the thread which has been passed ownership of
\lstinline{other_idx} increments the variable by 10.
At line~\ref{idx.load}, a bounds check is performed and if
\lstinline{idx} is smaller than the length of the allocated
\lstinline{vec}, then the position of \lstinline{idx} in the allocated
\lstinline{vec} array is accessed.
In an interleaving where \lstinline{other_idx} is incremented after
the bounds check at line \ref{idx.load}, an out-of-bounds read occurs
at line~\ref{data.get_unchecked}.\footnote{ Method
  \lstinline{get_unchecked()} is an unsafe method that retrieves an
  element from a vector without performing any bounds checking, i.e.,
  it is a potentially faster version of the regular \lstinline{get()}
  method.}
This leads to an immediate \texttt{panic!} call which is detected by
\rustmc along with the interleaving responsible for the error.




\subsection{Raw Pointers}
In Rust, developers can use raw pointers to bypass the language's
safety guarantees around aliasing and mutability when
necessary~\cite{rust_book_raw_pointers}.
In~\cite{QinCLZWSZ24}, Qin et al.\ show that sharing data between
threads through raw pointers to shared memory is a prevalent source of
concurrency bugs.
Figure~\ref{fig:raw-ptr-example} illustrates a concrete example of
such an issue.


\begin{figure}[H]
\begin{lstlisting}
fn main() {
    let mut x: i64 = 2;
    let x_ptr = &mut x as *mut i64; // Pointer #1 to x @\label{x_ptr.create}@
    
    unsafe {
      let x_ptr_2: &mut i64 = &mut *x_ptr; // Pointer #2 to x @\label{x_ptr2.create}@
      let handle = thread::spawn(move || {
            *x_ptr_2 = 5; @\label{x_ptr2.mutate}@
        });
      *x_ptr = 10; @\label{x_ptr.mutate}@
      handle.join().unwrap();
    }
    let y = x; @\label{y.create}@
}
\end{lstlisting}
    \caption{A data race caused by the use of raw pointers for sharing data between threads}
    \label{fig:raw-ptr-example}
  \end{figure}
While raw pointers can be created in safe code as is seen at line
  \ref{x_ptr.create}, dereferencing a raw pointer is always considered
  unsafe and must be marked as such.
At line \ref{x_ptr2.create}, \lstinline{x_ptr} is dereferenced,
  creating a second mutable reference to the value held at
  \lstinline{x}. Ownership of this reference is transferred 
  to a new thread where the underlying value \lstinline{x} is mutated. 
  This is performed concurrently with
  another write to \lstinline{x} at line~\ref{x_ptr.mutate}.
  
  Now \lstinline{y} may be assigned different values (10 or 5)
  depending on the observed interleaving. \rustmc is able to detect
  this as a non-atomic race and reports the conflicting write events
  at lines~\ref{x_ptr2.mutate} and~\ref{x_ptr.mutate}.


 \end{document}
