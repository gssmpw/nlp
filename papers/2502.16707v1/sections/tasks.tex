\section{Multi-Stage Robotic Manipulation Planning Tasks}\label{sec:tasks}
%%

\begin{figure*}[t!]
    \centering
    \includegraphics[width=0.99\textwidth]{figs/filmstrip.pdf}
    \caption{\textbf{Filmstrip of our method solving a complicated assembly task.} Frames are indexed by timestep. The goal image is in the top-left corner (with a green border). Each frame is the observation after executing the action (in black) above it. The other action in gray is the original action proposed by the VLM if it is revised after reflection. We highlight the reflection process at timestep 15, where the VLM first proposes an action to pick up the purple brick, but after reflection, it chooses to pick up the yellow brick instead as the generated future state (red-bordered image) shows little progress towards the goal.}
    \label{fig:filmstrip}
\end{figure*}
Inspired by~\citet{luo2024fmb}, we procedurally generated a suite of multi-stage long-horizon manipulation tasks that require understanding of physical interactions and reasoning about the effects of long-term action sequences. The task is initialized with a board and a set of small pieces randomly placed on a table. The goal is to fully assemble the board by inserting the pieces into the board one by one. Examples of the initial and goal configurations are shown in Fig.~\ref{fig:tasks}. Detailed task generation process is included in App.~\ref{sec:app_task_gen}. Notably, most tasks include inter-locking pieces so that they can be inserted into the board only in a specific order. This requires strategically choosing the object to be manipulated at each step and inferring possible interaction between this object and the other objects already in the board. 
As an example, Fig.~\ref{fig:tasks}(b) shows the dependencies between the pieces in one of the tasks. 
The interlocking feature further necessitates the agentâ€™s ability to replan, enabling it to recover from failures caused by previous mistakes or bad initialization. 


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.49\textwidth]{figs/tasks_single_column.pdf}
    \vspace{-0.1in}
    \caption{\textbf{Task examples.} (a) Generated multi-stage manipulation tasks with interlocking pieces. Top: initial configurations. Bottom: goal configurations. See App.~\ref{sec:app_more_task_samples} for more examples. (b) The graph shows the dependencies between the objects in the blue assembly board on the left. Each node represents an object, and each directed edge indicates the predecessor object should be assembled before the successor object.}
    \label{fig:tasks}
\end{figure}

% \begin{figure}[h!]
%     \centering
%     \includegraphics[width=0.95\linewidth]{figs/dependencies.pdf}
%     \caption{\textbf{A dependency graph of interlocking objects.} The right graph shows the dependencies between the objects in the assembly task on the left. Each node represents an object, and each directed edge indicates the predecessor object should be assembled before the successor object.}
%     \label{fig:dependencies}
% \end{figure}

We focus on the high-level planning of this long-horizon manipulation task. We define a set of actions in the form of ``{\tt [act] [obj]}", where $\text{\tt [act]}\in \{\text{\tt pick up}, \text{\tt insert}, \text{\tt reorient}, \text{\tt put down}\}$ is an action primitive, and {\tt [obj]} denotes the object to be manipulated. Specifically, ``{\tt pick up}" grasps a piece that is not in hand and picks it up. It can then be inserted into the board using the ``{\tt insert}" action, or put back on the table using ``{\tt put down}". By invoking ``{\tt reorient}", the object in hand can be reoriented with the black fixture if necessary, so that it is in a suitable pose for insertion. Each action primitive is implemented as a rule-based script controller; however, integrating other low-level controllers, such as learning-based policies like behavior cloning, is also possible. We also designed an expert policy for the mentioned motor primitives, see App.~\ref{sec:app_expert} for implementation details.

