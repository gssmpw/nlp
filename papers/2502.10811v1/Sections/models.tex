\section{Mathematical Structure of Syntax}
\label{sec:models}

One aspect of denotational semantics is to find (or design) a mathematical structure
that captures the structure and property of syntax appropriately.
The operations we aim to capture are variable binding and substitution, and the properties
are those that describe substitution laws.
In other words, we aim to define a general notion of model of a language, encompassing the existing ones, for
untyped and typed higher-order languages, encompassing their syntaxes and
substitution structures.

%
For substitution, the notion of monad has been found to capture its structure and properties
\cite{BellegardeHook94,DeBruijnasNestedDatatype99,AltenkirchReus99}.
For instance, the untyped lambda calculus can be described as a monad on the category of sets.
%
Yet, not all categories suitable for modeling syntax are endofunctor categories,
e.g., the functor $[\mb{F},\Set]$, with $\mb{F}$ the category of \emph{finite} sets (or a skeleton thereof) can be used to model the untyped lambda calculus \cite{FPT99}.
Some categories are not even functor categories as discussed in \cite{ISPoly24}.
%
However, all the categories used for modeling syntax are \emph{monoidal} categories, and the
substitution structure is given by the respective monoidal product.
The inclusion of variables into terms is modeled by the unit of the monoid.
%
Consequently, to build a general theory of syntax, we work directly with
monoids in a monoidal category.
We can recover different examples of syntax, and their substitution structure,
as instantiations of the theory to a specific monoidal category.



To model languages, we additionally need a mathematical structure to model
constructors, and a notion of signature to specify them.
%
Two main structures have been considered to model constructors: firstly,
strength \cite{FPT99,Cbn02,ListObjects17}, and secondly, modules over monads
\cite{HirschowitzMaggesi10,ZsidoPhd10,PresentableSignatures21}.
%
Moreover, different notions of signature have been considered: either
syntactic or mathematical, either using strengths or modules over monads.
%
To encompass the different point of views, we rely on of modules over monads and
associated notions, that we fully generalize to monoidal categories.
%
Indeed, once generalized, modules over monads provide us with a fully abstract
framework and notions of signatures; the other notions naturally appearing
as particularly important instances.

%
%
%
%
%
%
%
%
%

%
In the following, we first review monoids and modules over monoids in
\cref{subsec:monoids,subsec:modules} used to model simultaneous substitution
and constructors.
This enables us to define our category of signatures in \cref{subsec:signatures}.
Afterwards, given a signature, we define and describe its associated category of
models in \cref{subsec:models}.
Throughout, we rely on the untyped lambda calculus as a running example.


\subsection{Monoids}
\label{subsec:monoids}

\subsubsection{Limitations of Monads}
\label{subsubsec:kleisli}

Before introducing monoids to model substitution, let us first consider why
Monads are not sufficient to encompass the different existing approaches.
%
Monads on $\mc{C}$ have long been identified as a suitable axiomatization of
simultaneous substitution and its basic properties
\cite{BellegardeHook94,DeBruijnasNestedDatatype99,AltenkirchReus99}.

\begin{definition}[Monads]
  \label{def:monads}
  A \emph{monad} on $\mc{C}$ is a triple $(T,η,σ)$ where
  $T : \mrm{ob}(\mc{C}) → \mrm{ob}(\mc{C})$ is a function on objects,
  $η$ is a family of morphisms $η_{\,Γ} : Γ → T(Γ)$, and such that for all
  morphisms $c : Γ → T(Δ)$ there is a morphisms $σ_{\,Γ,Δ}(c) : T(Γ) → T(Δ)$,
  satisfying the equations:
  %
  \begin{align*}
    \begin{tikzcd}[ampersand replacement=\&]
      Γ \ar[r, "η_{\,Γ}"] \ar[dr, swap, "c"]
        \& R(Γ) \ar[d, "σ_{\,Γ,Δ}(c)"] \\
        \& R(Δ)
    \end{tikzcd}
    &&
    \begin{tikzcd}[ampersand replacement=\&]
      R(Γ) \ar[dr, bend left, "σ_{\,Γ,Γ}(η_{\,Γ})"]
                \ar[dr, swap, bend right, "\id"]
        \& \\
        \& R(Γ)
    \end{tikzcd}
    &&
    \begin{tikzcd}[ampersand replacement=\&]
      R(Γ) \ar[r, "σ_{\,Γ,Δ}(c)"]
                \ar[dr, swap, "σ_{\,Γ,Υ}(σ_{Δ,Υ}(c') \circ c)"]
        \& R(Δ) \ar[d, "σ_{Δ,Υ}(c')"] \\
        \& R(Υ)
    \end{tikzcd}
  \end{align*}
\end{definition}

%
\noindent Monads enable us to model substitution with $T$ associating contexts
to well-defined terms in them, $η$ corresponding to variables, and $σ$ to
simultaneous substitution.
%
The equations then specify that substituting a variable returns the associated
terms, that substituting variables by variables is the identity, and the
composition rule of simultaneous substitution.


%
The issue with this approach is that monads are not general enough to encompass
all the approaches, as they force us to represent our terms as an endofunctor
$\mc{C} → \mc{C}$.
%
This does not account for model based on $[\mb{F},\Set]$ \cite{FPT99} to model
untyped languages, nor on one based $ω$-cocontinuous endofunctors
$[\mc{C},\mc{C}]_ω$ that can both be interesting.
%
Such categories require variants of monads to account for the
substitution structure like relative monads \cite{RelativeMonads15} for
$[\mb{F},\Set]$.
%
Moreover, some languages like system F are more naturally modeled by a coherent
family of endofunctors and monads, rather than by one functor and one monad
\cite{ISPoly24}.

%
Thankfully, the substitution structure of all this examples are actually
equivalent to monoids in their associated monoidal categories.
%
Consequently, to be able to account for all possibilities, we rely directly on the
category of monoids in a monoidal category \cite[Section 1.2]{2DimensionalCategories20}
to model the substitution structure of languages.
%
The advantage is that it enables us to be fully abstract, and so to build a generic framework.
However, the downside is that the framework does not directly model substitution.
It is only once appropriately instantiated that the framework models substitution.


\subsubsection{Monoids}

\begin{definition}[Monoids]
  \label{def:monoids}
  Given a monoidal category $\Cmon$, a \emph{monoid} on $\mc{C}$ is a tuple
  $(R,μ,η)$ where $R$ is an object of $\mc{C}$ and the \emph{multiplication}
  $μ : R ⊗ R → R$ and the \emph{unit} $η : I → R$ are morphisms of $\mc{C}$ such
  that the following diagrams commute:
  %
  \begin{align*}
    \begin{tikzcd}[ampersand replacement=\&]
      (R ⊗ R) ⊗ R \ar[r, "\alpha"] \ar[d, swap, "μ ⊗ R"]
        \& R ⊗ (R ⊗ R) \ar[r, "R ⊗ μ"]
        \& R ⊗ R \ar[d, "μ"] \\
      R ⊗ R \ar[rr, swap, "μ"]
        \&
        \& R
    \end{tikzcd}
  &&
    \begin{tikzcd}[ampersand replacement=\&]
      I ⊗ R \ar[r, "η ⊗ R"] \ar[dr, swap, "λ_R"]
        \& R ⊗ R \ar[d, "μ"]
        \& R ⊗ I \ar[l, swap, "R ⊗ η"] \ar[dl, "ρ_R"] \\
        \& R
        \&
    \end{tikzcd}
  \end{align*}
\end{definition}

\begin{definition}[Morphisms of Monoids]
  \label{def:morphisms-monoids}
  A \emph{morphism of monoids} $(R,μ,η) → (R',μ',η')$ is a morphism $f : R → R'$
  in $\mc{C}$ preserving multiplication and the unit i.e such that the following
  diagrams commute:
  %
  \begin{align*}
    \begin{tikzcd}[ampersand replacement=\&]
      R ⊗ R \ar[r, "f  ⊗ f"] \ar[d, swap, "μ"]
        \& R' ⊗ R' \ar[d, "μ'"] \\
      R \ar[r, swap, "f"]
        \& R'
    \end{tikzcd}
    &&
    \begin{tikzcd}[ampersand replacement=\&]
      \& I \ar[dl, swap, "η"] \ar[dr, "η'"]
      \& \\
      R \ar[rr, swap, "f"]
      \&
      \& R'
    \end{tikzcd}
  \end{align*}
\end{definition}

\begin{proposition}[Category of Monoids]
  \label{prop:cat-monoids}
  Given a monoidal category $\mc{C}$, monoids in $\mc{C}$ and their morphisms
  form a category denoted $\Mon(\mc{C})$.
\end{proposition}

%
To understand how monoids enables us to model substitution, let us consider
the untyped lambda calculus on $[\Set,\Set]$ as an example.

\begin{example}[Untyped Lambda Calculus]
  \label{ex:LC-monoids}
  %
  In the category $[\Set,\Set]$, the untyped lambda calculus forms a functor
  $Λ : \Set → \Set$ associating context to well-defined terms over them.
  %
  For $c : Γ → Δ$, the functorial action $Λ(c) : Λ(Γ) → Λ(Δ)$ corresponds to
  renaming, and the functorial law that renaming is well-behaved: renaming by the
  identity is the identity $Λ(\id) = \id$, and renaming twice is the same as
  renaming once $Λ(c' ∘ c) = Λ(c') ∘ Λ(c)$.

  It further forms a monoid with $η$ the variable constructor $\var$, and
  $μ : Λ (Λ (Γ)) → Λ (Γ)$ the flattening operation that given a term with terms
  as label replaces the variables by their labels.
  %
  As morphisms of $[\Set,\Set]$, $\var$ and $μ$ are natural transformations.
  This specifies how renaming computes on them: renaming a variable is renaming the label $Λ(c)(\var(x)) = \var (c(x))$,
  and renaming the flattening is renaming before flattening $Λ(c) (\mu(u)) = \mu (Λ (Λ (c)) (u))$.
  %
  The monoid laws then specify the compatibility of flattening with renaming
  $μ_Γ ∘ μ_{Λ(Γ)} = μ_Γ ∘ Λ (μ_Γ)$ and $μ (Λ (\var)(t)) = t$, and that flattening
  variables returns the labels $μ (\var (t)) = t$.

  It finally enables us to model simultaneous substitution as monoids are
  equivalent to Kleisli triples.
  %
  $T$ and $η$ corresponds to $Λ$ and $\var$, and substitution is defined
  as $\sigma(c) := R(Γ) \xrightarrow{R(c)} R(R(Δ)) \xrightarrow{μ_Δ} R(Δ)$.
  Basically, it replaces all labels by their substitutions, then flatten to
  removes the wrapping variable constructor.
\end{example}

\begin{example}[Simply-typed lambda calculus]
  To model the simply-typed lambda calculus with type system $T$, one could
  consider the base category $[\Set^T,\Set^T]$ \cite{Cbn02,ZsidoPhd10}.
\end{example}
















\subsection{Modules over Monoids}
\label{subsec:modules}

Monoids in $\mc{C}$ enable us to model variables and simultaneous substitution.
It remains to model the language-specific constructors, such as application and abstraction of the lambda calculus;
in particular, how substitution computes on these constructors.
Unfortunately, constructors can not be modeled by morphisms of monoids: the
latter must preserve the $\eta$ constructor of monoids corresponding to
variables, which is not the case for constructors like application or
abstraction of the untyped lambda calculus.

%
%

Therefore, we rely instead on modules over a monoid \cite[Chapter4]{ZsidoPhd10},
a more liberal variant of monoids, and characterize constructors as morphisms of
suitable modules.
%
Roughly, modules over monoids are similar to monoids, but without a unit
constructor $η$ that morphisms would have to respect, giving us additional freedom to
express constructors as module morphisms.
%

\begin{definition}[Module over a Monoid]
  \label{def:modules}
  Given a monoid $R : \Mon(\mc{C})$, a (left) $R$-module is a tuple $(M,
  p^M)$ where $M$ is an object of $\mc{C}$ and $p^M : M ⊗ R → M$ is
  a morphism of $\mc{C}$ called \emph{module substitution} that is compatible
  with the multiplication and the unit of the monoid:
  %
  \begin{align*}
    \begin{tikzcd}[ampersand replacement=\&]
      (M ⊗ R) ⊗ R \ar[r, "\alpha_{M,R,R}"] \ar[d, swap, "p^M ⊗ R"]
        \& M ⊗ (R ⊗ R) \ar[r, "M ⊗ μ"]
        \& M ⊗ R \ar[d, "p^M"] \\
      M ⊗ R \ar[rr, swap, "p^M"]
        \&
        \& M
    \end{tikzcd}
    &&
    \begin{tikzcd}[ampersand replacement=\&]
      M ⊗ I \ar[r, "M ⊗ η"] \ar[dr, swap, "\rho_M"]
        \& M ⊗ R \ar[d, "p^M"] \\
        \& M
        \&
    \end{tikzcd}
  \end{align*}
\end{definition}

\begin{related Work}
  Using morphisms of modules over monads to model constructors was first
  considered in \cite{HirschowitzMaggesi07,HirschowitzMaggesi10} for $[\Set,\Set]$.
  %
  We rely instead on modules over monoids \cite[Chapter4]{ZsidoPhd10} as they
  are defined for any monoidal category, and not just for endofunctor categories
  $[\mc{C},\mc{C}]$.
  %
  See \cref{subsec:rw-modules-over-monoids} for a discussion on the differences.
\end{related Work}

\begin{definition}[Morphisms of Modules]
  \label{def:morphisms-modules}
  Given a monoid $R : \Mon(\mc{C})$, a \emph{morphism of $R$-modules} $(M, p^M) →
  (M', p^{M'})$ is a morphism $r : M → M'$ of $\mc{C}$ commuting with
  the respective module substitutions:
  %
  \[
    \begin{tikzcd}
      M ⊗ R \ar[r, "r ⊗ R"] \ar[d, swap, "p^M"]
        & M' ⊗ R \ar[d, "p^{M'}"] \\
      M \ar[r, swap, "r"] & M'
    \end{tikzcd}
  \]
\end{definition}

\begin{proposition}[Category of Modules]
  \label{prop:cat-modules}
  Given a monoid $R : \Mon(\mc{C})$, the modules over $R$ and their
  morphisms form a category denoted $\Mod(R)$.
\end{proposition}

%
By construction, module morphisms respect module substitutions.
Given some language modeled by a monoid $R$, we can model its language constructors
as $R$-module morphisms $M → M'$;
here, the $R$-modules $M$ and $M'$
specify how substitution behaves at the input and output of term constructors,
and hence which variables are bound.
%
The dependency on the monoid $R$ enables us to access the language substitution
structure, and to build modules using it.
And indeed, the monoid forms a trivial module over itself $Θ$ corresponding to
the usual substitution on terms.

\begin{definition}
  Given a monoid $(R, \eta, \mu)$, the pair $(R,μ)$ is a module over the monoid $R$.
  By abuse of notation, we also denote this by $R$.
\end{definition}

\begin{definition}
  Given an object $D : \mc{C}$ and a $R$-module $(M,p^M)$, there is a
  $R$-module with object $D ⊗ M : \mc{C}$ and module
  substitution $(D ⊗ M) ⊗ R \xrightarrow{α} D ⊗ (M ⊗ R) \xrightarrow{D ⊗ p^M} D ⊗ M$.
\end{definition}

\noindent In this work, will restrict to constructors that returns terms without
introducing fresh variables as it simplifies the rest of the framework and is
enough in practice.
Given a language modeled by some monoid $R$, we will hence model constructors of
that language by a module morphisms $M → R$, for a suitable $R$-module $M$.

To understand how it works, let us consider the untyped lambda calculus on $[\Set,\Set]$.
First, as variable binding depends on the type system of the languages and hence the base category,
we must build a specific module to model untyped variable binding.
We can then represent the constructors:

\begin{definition}
  \label{ex:module_binding}
  Let $R$ be a monad on $\Set$, that is, a monoid in $[\Set,\Set]$.
  There is a module $R^{(n)}$ modeling the binding of $n$ variables
  with underlying functor $R^{(n)}(Γ) := Γ + n$ and module substitution:
  %
  \[ (R^{(n)} \circ R) (Γ) := R (R (Γ) + n)
      \xrightarrow{\;\; R[R(\inl_Γ), η_{\,Γ+n}] \;\;} R (R (Γ + n))
      \xrightarrow{\;\;μ_{Γ+n}\;\;} R (Γ + n)
  \]
\end{definition}

\begin{remark}
  Given a monoid $R$, The module $R^{(0)}$ is simply the module $R$.
\end{remark}

\begin{example}[Untyped Lambda Calculus, continuation of \cref{ex:LC-monoids}]
  \label{ex:LC-modules}
  %
  On $[\Set,\Set]$, the constructor $\app$ can be modeled by a module morphism
  $Θ × Θ → Θ$ as it take two arguments without binding variables, and $\abs$ by
  a module morphism $Θ^{(1)} → Θ$ as it takes one argument binding one variable.

  %
  As morphism, $\app$ and $\abs$ are natural transformations. This specifies how
  renaming computes on constructors: renaming $\app$ is renaming its arguments
  $Λ(c)(\app(u,v)) = \app(Λ(c)(u), Λ(c)(v))$, and renaming $\abs$ is renaming
  its argument while preserving the fresh variable $Λ(c)(\abs(u)) =
  \abs(Λ(c+1)(u))$.
  %
  Similarly, the morphism law specify how flattening computes on constructors.
  Flattening $\app$ is flattening its arguments $μ (\app(u,v)) = \app (μ(u),μ(v))$,
  and flattening $\abs$ is flattening its argument while preserving the fresh variable
  $μ(\abs(u)) = \abs\, (μ (Λ[Λ(\inl), \var])(u))$.

  %
  As discussed in \cref{subsec:monoids,ex:LC-monoids}, monoids do not directly
  model substitution, they only do so when appropriately instantiated.
  %
  Similarly, modules morphisms do not directly model the computation rules of
  substitution on constructors, they only do so when appropriately instantiated.
  %
  Actually, for a general morphism of module, there is no reason why
  computation rules for flattening induce computational rules for substitution.
  %
  Fortunately, in practice this is always the case.
  For the untyped lambda calculus, given $c : Γ → Λ(Δ)$, substituting
  $\app$ is substituting its arguments $σ(c)(\app(u,v)) = \app(σ(c)(u), σ(c)(v))$,
  and substituting $\abs$ is substituting the argument $σ(c)(\abs(u)) = \abs(σ(\ol{c})(u))$
  for the weakening of $c$, $\ol{c} = [Λ(\inl_{Δ,1}) ∘ c, η_{Δ+1} ∘ \inr_{Δ,1}] : X+1 \to  Λ (Δ + 1)$.
\end{example}

To specify constructors as module morphisms $M → Θ$, we want to
build modules \emph{modularly}, such as $Θ × Θ$ as the domain of the application of lambda calculus.
%
The construction of some modules depends on the underlying monoidal category $\mc{C}$ and can not be built generically; for instance, the module
$Θ^{(n)}$, since variable binding depends on the type system.
However, many others can be
built as limits and colimits:

\begin{proposition}[Closure under (co)-limits]
  \label{prop:modules-closure-colimits}
  Given a monoid $R : \Mon(\mc{C})$, the category $\Mod(R)$ inherits its limits
  and colimits from $\mc{C}$ provided that $\_ ⊗ I$, $\_ ⊗ R$, $\_ ⊗ R ⊗ R$ and
  $\_ ⊗ (R ⊗ R)$ preserve them.
\end{proposition}
\begin{proof}
  Let $F : J \to \Mod(R)$ be a diagram in $\Mod(R)$, i.e. a natural family $(M_i,p^{M_i})$.
  %
  \begin{itemize}[label=$-$]
    \setlength\itemsep{-1pt}
    \item Forgetting the module substitution gives us a diagram in $\mc{C}$, that by
          assumption has a colimit $\colim M_i : \mc{C}$.
    \item As it is preserved by $\_ ⊗ R$ to build a module substitution $p^{\colim M_i} : \colim
          M_i ⊗ R → \colim M_i$, it suffices to build a morphism $\colim (M_i ⊗ R) → \colim M_i$.
          %
          This follows pointwise by functoriality of colimits.
          %
          %
          %
          %
          %
    \item This morphism is then compatible with the multiplication and unit of $R$,
          as the $\colim M_i$ are preserved and the properties are satisfied pointwise.
  \end{itemize}
  %
  Consequently, $(\colim M_i, p^{\colim M_i})$ forms a module.
  It further is the colimit as $\colim M_i$ is in $\mc{C}$, and $\_ ⊗ R$ preserves it.
   For limits, the construction is analogous.
\end{proof}

\begin{example}
  \label{prop:module-language-cst}
  Under the above assumptions, $\Mod(R)$ has a terminal module denoted $R^0$,
  and is closed under products and coproducts.
\end{example}

\noindent These last constructions are of importance for modularity.
The terminal module enables us to represent constants, i.e. constructors without
arguments, as module morphisms $R^0 → R$.
%
The closure under products enables us to represent term constructors with
several independent inputs, like $\app$ as a morphism $Θ × Θ → Θ$.
%
Closure under coproducts allow us to specify languages with several independent
term constructors, as a morphism $(R^0 + R × R) → R$ amounts by
universal property to a morphism $R^0 → Θ$ and a morphism $R × R → R$

\begin{example}
  On $[\Set,\Set]$, the constructors of the untyped lambda calculus $\Lambda$ can be modeled by a module morphism
  $(\Lambda × \Lambda + \Lambda^{(1)}) → \Lambda$.
\end{example}















\subsection{Signatures}
\label{subsec:signatures}

%
A model of a language should be a pair of a monoid $R$ axiomatizing variables
and simultaneous substitution, and an $R$-module morphism $M → R$ axiomatizing
term constructors.
Here, the $R$-module $M$ should suitably model the domain of the constructors of the language.
%
Hence a signature $\Sigma$ should associate to any monoid $R$, an $R$-module
$\Sigma(R) : \Mod(R)$ representing the input of the constructors.
%
To express this dependency, we introduce the total category of modules
\cite{HirschowitzMaggesi12,PresentableSignatures21} in \cref{subsubsec:total-cat-modules},
before defining signatures in \cref{subsubsec:sig}.

%
%
%
%


\subsubsection{The Total Category of Modules}
\label{subsubsec:total-cat-modules}

\begin{proposition}[The pullback functor]\label{prop:pullback_module}
  Given a morphism of monoids $f : R → R'$, there is a functor $f^* : \Mod(R') → \Mod(R)$
  that associates to each module $(M',p^{M'}) : \Mod(R')$ a $R$-module $f^*M'$
  called the \emph{the pullback module} defined as
  %
  \[
    \begin{tikzcd}
      M' ⊗ R \ar[r, "M' ⊗ f"]
        & M' ⊗ R' \ar[r,"p^{M'}"]
        & M'.
    \end{tikzcd}
  \]
  %
\end{proposition}

\begin{proposition}[The module functor]\label{prop:module_functor}
  There is a contravariant pseudofunctor of bicategories, from the discrete
  bicategory of monoids in $\mc{C}$ to the bicategory of (small) categories,
  \[ \Mod : \Mon(\mc{C})^\op ⟶ \mrm{Cat}. \]
  This pseudofunctor associates, to a monoid $R$, the category
  $\Mod(R)$, and to a morphism of monoids $f : R → R'$, the functor
  $f^* : \Mod(R)' → \Mod(R)$ of \cref{prop:pullback_module}
\end{proposition}

Applying the Grothendieck construction to the pseudofunctor of \cref{prop:module_functor},
we obtain a fibration over the category of monoids on $\mc{C}$:

\begin{proposition}[The total category of modules]
  \label{prop:cat-totalcat-modules}
  There is a \emph{total category of modules} $\TotMonMod{\mc{C}}$.
  Its objects are tuples $(R,M)$ where $R : \Mon(\mc{C})$ is a monoid, and
  $M : \Mod(R)$ a module over it.
  Its morphisms $(R,M) → (R',M')$ are tuples $(f,r)$ where $f : R → R'$
  is a morphism of monoids and $r : M → f^*M'$ a morphism of $R$-monoids.

  The forgetful functor from the total category of modules to the base
  category of monoids is a Grothendieck fibration,
  %
  \begin{equation}\label{eq:forget-module-monoid}
    U : \TotMonMod{\mc{C}} ⟶ \Mon(\mc{C}).
  \end{equation}
\end{proposition}


\subsubsection{Signatures}
\label{subsubsec:sig}

We can now define a signature to be a functor $\Sigma : \Mon(\mc{C}) ⟶ \TotMonMod{\mc{C}}$
that returns a module over the input one, specifying the arity of the constructors.
%
,

\begin{definition}[Signatures]
  \label{def:sig}
  A \emph{signature} is a functor $\Sigma : \Mon(\mc{C}) ⟶ \TotMonMod{\mc{C}}$
  making the following diagram commute:
  \[
    \begin{tikzcd}
      \Mon(\mc{C}) \ar[rr, "\Sigma"] \ar[dr, swap, equal]
        &
        & \TotMonMod{\mc{C}} \ar[dl, "U"] \\
      & \Mon(\mc{C}) &
    \end{tikzcd}
  \]
\end{definition}

\begin{related Work}
  This definition was introduced in \cite{HirschowitzMaggesi12,PresentableSignatures21} for $[\Set,\Set]$,
  and is sometimes referred to as ``parametric modules'' \cite{TransitionMonads22}.
  %
  In the context of modules, other notions of signatures have been considered.
  We refer to \cref{subsubsec:rw-modules-sig} for a discussion on the subject.
\end{related Work}

\noindent In other words, signatures are sections of the forgetful functor $U : \TotMonMod{\mc{C}} ⟶ \Mon(\mc{C})$.
For a given signature $\Sigma : R \mapsto (R,M)$, since the first component is
always the identity, we usually omit it and denote by $\Sigma(R)$ the $R$-module $M$.

\begin{definition}[Morphism of Signatures]
  A \emph{morphism of signature} $\Sigma → \Sigma'$ is a natural transformation
  $h : \Sigma → \Sigma'$ that is the identity when composed with the
  forgetful functor $U : \int_{R : \Mon(\mc{C})} \Mod(R) ⟶ \Mon(\mc{C})$
\end{definition}

\begin{proposition}[Category of Signatures]
  \label{prop:cat-signatures}
  Signatures and their morphisms form a category $\mrm{Sig}(\mc{C})$.
\end{proposition}

The advantage of this definition is that constructions on modules extend pointwise.
This enables us to preserve the intuition of modules over monoids, and to recover
our basic building blocks for signatures:

\begin{definition}
  There is a trivial signature $Θ : R ↦ R$.
\end{definition}

\begin{definition}
  For all $D : \mc{C}$ and $\Sigma : \Sig(\mc{C})$, there is a signature $D ⊗ \Sigma : R ↦ D ⊗ Σ(R)$.
\end{definition}

\begin{definition}
  On $[\Set,\Set]$, there is a signature $Θ^{(n)} : R ↦ R^{(n)}$.
\end{definition}

\begin{example}[Untyped Lambda Calculus, continuation of \cref{ex:LC-modules}]
  On $[\Set,\Set]$, the constructors $\app$ and $\abs$ can be modeled by the signature $Θ × Θ$ and $Θ^{(1)}$.
\end{example}

Moreover, limits and colimits are inherited pointwise from modules enabling
us to build signatures as modularly as modules, and to define languages modularly:

\begin{proposition}[Evaluation]
  \label{prop:evaluation-sig}
  Given a monoid $R : \Mon(\mc{C})$, there is an evaluation functor
  $\Sig(\mc{C}) → \Mod(R)$, defined on object by $Σ ↦ Σ(R)$, and on natural
  transformation $f : Σ → Σ$ by the module morphism $Σ(f) : Σ(R) → Σ(R')$.
\end{proposition}

\begin{proposition}[Closure under (co)-limits]
  \label{prop:sig-closure-colimits}
  The category $\Sig(C)$ inherits its limits and colimits from $\mc{C}$ provided
  that for all $R : \Mon(\mc{C})$, $\_ ⊗ R$ preserves them.
\end{proposition}
\begin{proof}
  Given a diagram $Σ : J → \Sig(\mc{C})$ of signatures, we define a new signature $\colim Σ$ as follows.
  \begin{itemize}[label=$-$]
    \setlength\itemsep{-1pt}
    \item On objects, we associate to a monoid $R$ the colimit of modules $R ↦ \colim_{\Mod(R)}\, Σ_i(R)$
          which exists by \cref{prop:evaluation-sig} and \cref{prop:modules-closure-colimits}.
    \item On morphisms, given a morphism of monoids $f : R → R'$,
          we need to build a morphism $\colim_{\Mod(R)}\, Σ_i(R) → f^*  (\colim_{\Mod(R')}\, Σ_i(R'))$.
          %
          This amounts to a morphism in $\mc{C}$ from $\colim_{\mc{C}}\, Σ_i(R) →
          \colim_{\mc{C}}\, Σ_i(R')$ that respects module substitution.
          This follows pointwise from functoriality of colimits.
          %
  \end{itemize}
  Consequently, $\colim Σ$ is a well-defined functor, and is, by construction, a
  signature, since it is the identity on its first component.
  It further is the colimit since it is the colimit pointwise.
  Limits are constructed analogously.
\end{proof}

\begin{example}
  Under the above assumptions, $\Sig(\mc{C})$ has a terminal signature, also
  denoted $Θ^0$, and is closed under products and coproducts.
\end{example}

In practice, we work with a \emph{fixed} category satisfying this properties, like $[\Set,\Set]$.
In which case, as variable binding is instance specific, we often rely on a specific
subclass of signatures, that is closed by some limits and colimits to be modular.
%
For instance, on $[\Set,\Set]$, one often rely on algebraic signatures that
are simple but enough to specify usual languages:

\begin{definition}[Algebraic Signatures]
  \label{def:alg-sig}
  \emph{Algebraic signatures} on $[\Set,\Set]$, also known as \emph{binding
  signatures}, are generated by $Θ^{(n)}$, coproducts and \emph{finite} products.
  In other words, there are of the form $\scalebox{1.5}{+}_{i ∈ I}\;\, Θ^{(n_0)} × ... × Θ^{(n_k)}$.
\end{definition}

\begin{remark}
  Though, $[\Set,\Set]$ is closed by generic products, they need to be finite
  for algebraic signatures to have a model.
  See \cref{subsec:initiality_theorem}, in particular \cref{prop:omega-limits}.
\end{remark}

\begin{example}
  \label{ex:alg-sig}
  %
  On $[\Set,\Set]$, the following languages can represented by algebraic signatures:
  %
  \begin{itemize}[label=$-$]
    \setlength\itemsep{-1pt}
    \item The untyped lambda calculus with constructors $\app,\abs$ by $Θ × Θ + Θ^{(1)}$.
    \item First order logic with constructors $⊤,⊥,¬,\land,\lor,⇒,∃,∀$ by $2Θ^0 + Θ + 3Θ^2 + 2Θ^{(1)}$.
    \item Linear logic with constructors $⊤,⊥,!,?,\&,\parr,⊕,⊸,∃,∀$ by $2Θ^0 + 2Θ +5Θ^2 + 2Θ^{(1)}$.
  \end{itemize}
\end{example}



\subsection{Models}
\label{subsec:models}

\subsubsection{Models of a signature}

Given a signature, we can now represent languages as a monoid representing
the language with substitution and a module morphism representing the
constructors.

\begin{definition}[Models]
  \label{def:models}
  Given a signature $\Sigma : \Sig(\mc{C})$, a \emph{model} of $\Sigma$ is a
  tuple $(R,r)$ where $R : \Mon(\mc{C})$ is a monoid and $r : \Sigma(R) →
  R$ is a morphism of $R$-modules.
\end{definition}

\begin{related Work}
  A notion of model based on modules was introduced in \cite{HirschowitzMaggesi07}, and in its
  current form in \cite{HirschowitzMaggesi12,PresentableSignatures21}, in both
  cases for $[\Set,\Set]$.
  %
  There are different variations depending on the underlying notion of signature
  used. See \cref{subsubsec:rw-modules-sig} for details on the variations.
\end{related Work}


Morphisms of models must then respect variables and the module morphism in source and target.
%
That is, it must be a morphism of monoids that respects the diagram below which
can be understood as a diagram in $\mc{C}$ as the forgetful functor $U : \Mod(R) → \mc{C}$ is faithful.

\begin{definition}[Morphism of Models]
  \label{def:morphims-models}
  A morphism of $\Sigma$-models $(R,r) → (R',r')$ is a morphism of monoids
  $f : R → R'$ compatible with the module morphism $r$ and $r'$, i.e. such
  that the left-hand side diagram of $R$-modules commutes:
  %
  \begin{align*}
    \begin{tikzcd}[ampersand replacement=\&]
      \Sigma(R) \ar[r, "r"] \ar[d, swap, "\Sigma(f)"]
        \& R \ar[d, "f"] \\
      f^* \Sigma(R') \ar[r, swap, "f^*r'"]
        \& f^*R'
    \end{tikzcd}
    &&
    \begin{tikzcd}[ampersand replacement=\&]
      (R,\Sigma(R)) \ar[r, "(id{,}r)"] \ar[d, swap, "\Sigma(f)"]
        \& (R,R) \ar[d, "Θ(f)"] \\
      (R', \Sigma(R')) \ar[r, "(id{,}r')"]
        \& (R',R')
    \end{tikzcd}
  \end{align*}
\end{definition}

\begin{remark}
  The pullback along $f^*$ is here for homogeneity as $\Sigma(R')$ is an $R'$-module.
  It can be understood by viewing the left-hand side diagram as a diagram in
  the total category of modules, as on the right-hand side.
\end{remark}

\begin{proposition}[Category of Models]
  \label{prop:cat-mod-sig}
  Given a signature $\Sigma : \Sig(\mc{C})$, its models and their morphisms
  form a category denoted $\Model(\Sigma)$.
\end{proposition}


\subsubsection{Representable Signatures}
\label{subsubsec:rep-sig-rec}

We aim to not just equip syntax with a mathematical structure, but also to show
that it has a universal property, being the \emph{initial} such mathematical
structure, in a suitable category of ``models''.
%
Initiality then provides a recursion principle, following the classical method
for simple datatypes\cite{Goguen76,GoguenEtAl75}.

Not all signatures do admit initial models; those who do, we call \emph{representable}.

\begin{definition}[Representable Signatures]
  A signature $\Sigma$ is \emph{representable} if its category of models
  $\Model(\Sigma)$ has an initial model.
  In this case, its initial model is denoted $\ol{\Sigma}$, and called
  the \emph{syntax} associated to $\Sigma$.
\end{definition}

\begin{example}
  \label{ex:alg-sig-rep}
  Algebraic signatures on $[\Set,\Set]$ (see \cref{def:alg-sig}) are representable.
  In particular, the signatures of untyped lambda calculus, first order logic
  and linear logic are representable (\cref{ex:alg-sig}).
\end{example}

The universal property provided by initiality is stronger than the usual
recursion principle of inductive types, as it provides us not only with a
$\mc{C}$ morphism but with a morphism of models.
%
Such a morphism is automatically compatible, in a suitable sense, with substitution in source and target.
%
As an example, let us consider a substitution-safe translation from first-order
logic to linear logic.

\begin{example}[{{\cite[Example 9.1]{PresentableSignatures21}}}]
  \label{ex:FOL-to-LL}
  By \cref{ex:alg-sig-rep}, first-order logic and linear logic both have an initial model.
  %
  Let us denote by $r_x$ the module morphism associated to the logic symbol $x$ in
  the respective initial model.
  %
  It is possible to equip the monoid underlying the model of linear logic with a
  first-order logic structure defining the module morphisms as follows.

  \[ \begin{array}{cccc}
    r_⊤' := r_⊤ & r_⊥' := r_⊥ & r_¬' := r_⊸ ∘ (r_! × r_0) & r_\land' := r_\& \\
    r_\lor' := r_⊕ ∘ (r_! × r_!) & r_⇒' := r_⊸ ∘ (r_! × \Id) & r_∃' := r_∃ ∘ r_! &
    r_∀' := r_∀
  \end{array} \]

  \noindent By initiality of the model of first order logic, there is then a
  substitution-safe translation from first-order logic to linear logic.
\end{example}

As shown in \cite[Section 5.1]{PresentableSignatures21} for $[\Set,\Set]$, any
initial model satisfies a fixpoint property.
We generalize this property to monoidal categories.
In particular, it enables us to prove that some signatures are not representable.

\begin{lemma}[Lambek's Theorem]
  \label{lemma:abstract-Lambek}
  Let $F : \mc{D} → \mc{D}$ be a functor and $α : F → \Id$ a natural transformation
   such that $Fα = αF$. If $0 : \mc{D}$ is an initial object, then $0 ≅ F(0)$.
\end{lemma}

\begin{proposition}
  \label{prop:fixpoint-models}
  Let $\mc{C}$ be a monoidal category with binary coproducts, and such
  that for all $Z : \mc{C}$, $\_ ⊗ Z$ preserves coproducts.
  If a signature $\Sigma$ has a model $M$, then $I + \Sigma(M)$ can be
  turned into a model of $\Sigma$.
  Moreover, if $\Sigma$ is representable, there is an isomorphism of models
  $I + \Sigma(\ol{\Sigma}) \cong \ol{\Sigma}$.
\end{proposition}
\begin{proof}
  There is a monoid structure on $I + Σ(M)$ with unit $I \xrightarrow{\inr} I + Σ(M)$, and
  using that precomposition distributes over coproducts, multiplication can be defined as
  %
  \[
  \begin{tikzcd}[column sep=3.5cm]
    (I + Σ(M)) ⊗ (I + Σ(M)) \ar[r] \ar[d, phantom, "≅"]
      & I + Σ(M) \\
    I ⊗ (I + Σ(M)) + Σ(M) ⊗ (I + Σ(M)) \ar[r, "λ \;+\; Σ(M) ⊗ {[}η{,}r{]}"]
      &  I + Σ(M) + Σ(M) ⊗ M \ar[u, swap, "{[}\id {,} \inr \,∘\, p^M{]}" ]
  \end{tikzcd}
  \]
  %
  Moreover, there is a module morphism making $I + Σ(M)$ a model of $Σ$:
  \[
    \begin{tikzcd}[column sep=large]
      Σ(I + Σ(M)) \ar[r, "Σ({[}η{,}r{]})"]
        & Σ(M) \ar[r, "\inr"]
        & I + Σ(M)
    \end{tikzcd}
    \]
  %
  This construction assembles into a functor $I + Σ(\_) : \Model(Σ) → \Model(Σ)$,
  and $[η,r] : I + Σ(M) → M$ into a natural transformation $I + Σ(\_) \to \Id$,
  such that $[η,r] (I + Σ(\_)) = (I + Σ(\_)) [η,r]$.
  %
  Consequently, by \cref{lemma:abstract-Lambek}, if $Σ$ has an initial model
  $\ol{Σ}$ then $I + \Sigma(\ol{\Sigma}) \cong \ol{\Sigma}$.
\end{proof}

\begin{example}[{{\cite[Non-example 5.5]{PresentableSignatures21}}}]
  \label{ex:not-representable}
  In the monoidal category $[\Set,\Set]$, the signature $\mc{P} \circ
  Θ$ is not representable.
  %
  Indeed, otherwise there would be an isomorphism of models
  $\Id + (\mc{P} \circ Θ) (\ol{\mc{P} \circ Θ}) \cong \ol{\mc{P} \circ Θ}$.
  %
  Yet, as there is a forgetful functor $\Model([\Set,\Set]) → [\Set,\Set]$, for
  all $X : \Set$, there would be an isomorphism of sets
  $X + \mc{P} ((\ol{\mc{P} \circ Θ})(X)) X \cong (\ol{\mc{P} \circ Θ}) (X)$,
  which is impossible for cardinality reasons.
\end{example}


\subsubsection{The Total Category of Models}
\label{subsubsec:total-model}

The advantage of this framework is that it is fully abstract, and hence
is suitable to express and prove abstract results.
%
For instance, as introduced in \cite{HirschowitzMaggesi12,PresentableSignatures21}
on $[\Set,\Set]$ models like modules assemble in a total category, which enables us
to easily prove modularity results in the style of \cite[Section 5.2]{PresentableSignatures21}:

\begin{proposition}[The pullback functor]\label{prop:pullback_model}
  Given a morphism of signatures $h : \Sigma → \Sigma'$, there is a functor
  $h^* : \Model(\Sigma') → \Model(\Sigma)$ that associates to to each model
  $(R',r') : \Model(\Sigma')$ a $\Sigma$-model $h^*(R',r')$ called the
  \emph{the pullback model} defined as:
  \[
    \begin{tikzcd}
      \Sigma(R') \ar[r, "h_R"]
        & \Sigma'(R') \ar[r, "r'"]
        & R'
    \end{tikzcd}
  \]
\end{proposition}

\begin{proposition}[The model pseudofunctor]\label{prop:model_pseudofunctor}
  There is a contravariant pseudofunctor of bicategories, from the discrete bicategory of signatures over $\mc{C}$
  to the bicategory of (small) categories,
  \[ \Model : \Sig(\mc{C})^\op ⟶ \mrm{Cat}. \]
  This pseudofunctor associates, to a signature $\Sigma :
  \Sig(\mc{C})$, the category $\Model(\Sigma)$, and to a morphism of
  signatures $h : \Sigma → \Sigma'$, the functor $h^* : \Model(\Sigma') →
  \Model(\Sigma)$ of \cref{prop:pullback_model}.
\end{proposition}

Applying the Grothendieck construction to the pseudofunctor of \cref{prop:model_pseudofunctor}, we obtain a fibration over the category of signatures on $\mc{C}$:


\begin{proposition}[The total category of models]
  \label{prop:cat-totalcat-models}
  Signatures assemble as a \emph{total category of models} $\TotSigModel{\mc{C}}$.
  %
  Its objects are tuples $(\Sigma,(R,r))$ where $\Sigma : \Sig(\mc{C})$ is a
  signature, and $(R,r) : \Model(\Sigma)$ a model over it.
  %
  Its morphisms $(\Sigma,(R,r)) → (\Sigma',(R',r'))$ are tuples $(h,f)$ where $h
  : \Sigma → \Sigma'$ is a morphism of signatures and $f : (R,r) → f^*(R',r')$ a
  morphism of $\Sigma$-models.

  The forgetful functor from the total category of models to the base
  category of signatures is a Grothendieck fibration,
  %
  \[ \TotSigModel{\mc{C}} ⟶ \Sig(\mc{C}) \]
\end{proposition}


Using the total category of models, it is then possible to express a modularity
result on signatures and models.
%
Specifically, we prove that the initial model of a pushout of signatures is the pushout of
the initial models, generalizing \cite[Section 5.2]{PresentableSignatures21}:

\begin{proposition}[Modularity]
  \label{prop:modularity-models}
  Given a pushout of representable signatures $\Sigma$,$\Sigma_1$,$\Sigma_2$,
  $\Sigma_{12}$, their initial models form a pushout above it, in the total
  category of models:
  %
  \begin{align*}
    \begin{tikzcd}[ampersand replacement=\&]
      \Sigma \ar[r] \ar[d] \arrow[dr, phantom, "\ulcorner", very near end]
        \& \Sigma_2 \ar[d] \\
      \Sigma_1 \ar[r]
        \& \Sigma_{12}
    \end{tikzcd}
    &&
    \begin{tikzcd}[ampersand replacement=\&]
      (\Sigma, \ol{\Sigma}) \ar[r] \ar[d] \arrow[dr, phantom, "\ulcorner",
                                                very near end]
        \& (\Sigma_2, \ol{\Sigma_2}) \ar[d] \\
      (\Sigma_1, \ol{\Sigma_1}) \ar[r]
        \& (\Sigma_{12}, \ol{\Sigma_{12}})
    \end{tikzcd}
  \end{align*}
\end{proposition}
\begin{proof}
  The pushout of signatures provides us with morphisms for the fist component.
  Morphisms for the second component exist by initiality of the respective models.
  The pushout property then follows as it is a pushout on the first component, and
  morphisms on the second component are equal by initiality.
\end{proof}


%
%
%
%
