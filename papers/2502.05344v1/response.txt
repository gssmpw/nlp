\section{Related Work}
\mylist{Automated program verification with LLM} While there exist various techniques for automated program verification with machine learning based methods like Code2Inv**Klein, "Formal Verification of Imperative Programs"**, CIDER**Liu, et al., "Code Completion as a Tool for Formal Verification"** and Code2RelInv**Kaplan, "A Probabilistic Approach to Relational Invariant Synthesis"**, there has been recent advancements focusing on the integration of LLMs to enhance proof generation capabilities. LLMs provide the potential to automate these processes by generating human-like proofs and code. LLM-aided proof/code generation has been studied within verification-aware programming languages like Frama-C**Bouquet, et al., "Frama-C: A Source-to-Source Translation Environment for High-Level Verification"**, Dafny**Leino, et al., "Dafny: Digital Machines Language"** and Verus**Rustan, et al., "Verus: Verified Programming in Rust"**. Recent work **Rustan, et al., "LLM-Aided Proof Synthesis in Rust"** leverages LLMs for automated proof synthesis in Rust using finetuned knowledge bases and refinement processes. Clover**Kaplan, "Clover: Automated Formal Verification of SV Without Formal Specifications"** addresses the case of SV where no specification is formally given, and attempts to autoformalize a specification in Dafny by aligning with the available implementations and documentations. LeanDojo**Bouquet, et al., "LeanDojo: A Large Premise Pool for Automated Proof Verification in Lean"** introduces a large premise pool in Lean and uses fine-tuned retrieval models to perform RAG for proofs. Although these approaches differ in methodology and application areas, they all focus primarily on single-function verification.

\mypara{Repository-level program verification} Repository-level program verification is a relatively emerging field with limited previous research addressing the inherent complexity of large software systems. Selene**Bouquet, et al., "Selene: Formal Verification for Large Software Systems"** represents a pioneering effort in this domain, but the language focus, verification tooling, and dependency management approaches are different from **Rustan, et al., "Repository-Level LLM-Based Code Generation with Automated Verification"**. While there has been recent development in repository-level LLM-based code generation, **Bouquet, et al., "Automated Verification for Large Software Systems Using LLMs"** extends this domain into automated verification, ensuring not only the generation of code but also its formal correctness.