\section{Related Work}
\mylist{Automated program verification with LLM} While there exist various techniques for automated program verification with machine learning based methods like Code2Inv____, CIDER____ and Code2RelInv____, there has been recent advancements focusing on the integration of LLMs to enhance proof generation capabilities____. LLMs provide the potential to automate these processes by generating human-like proofs____ and code____. LLM-aided proof/code generation has been studied within verification-aware programming languages like Frama-C____, Dafny____ and Verus____. Recent work \autoverus ____ leverages LLMs for automated proof synthesis in Rust using finetuned knowledge bases and refinement processes. Clover____ addresses the case of SV where no specification is formally given, and attempts to autoformalize a specification in Dafny by aligning with the available implementations and documentations. LeanDojo____ introduces a large premise pool in Lean and uses fine-tuned retrieval models to perform RAG for proofs. Although these approaches differ in methodology and application areas, they all focus primarily on single-function verification. 

\mypara{Repository-level program verification} Repository-level program verification is a relatively emerging field with limited previous research addressing the inherent complexity of large software systems. Selene____ represents a pioneering effort in this domain, but the language focus, verification tooling, and dependency management approaches are different from \ragverus. While there has been recent development in repository-level LLM-based code generation____, \ragverus extends this domain into automated verification, ensuring not only the generation of code but also its formal correctness.