\section{Related Work}
\mylist{Automated program verification with LLM} While there exist various techniques for automated program verification with machine learning based methods like Code2Inv~\cite{si2020code2inv}, CIDER~\cite{liu2022learning} and Code2RelInv~\cite{wang2022learning}, there has been recent advancements focusing on the integration of LLMs to enhance proof generation capabilities~\cite{wen2024enchanting}. LLMs provide the potential to automate these processes by generating human-like proofs~\cite{wen2024enchanting} and code~\cite{li2024guiding}. LLM-aided proof/code generation has been studied within verification-aware programming languages like Frama-C~\cite{kirchner2015frama}, Dafny~\cite{leino2010dafny} and Verus~\cite{lattuada2023verus}. Recent work \autoverus ~\cite{yang2024autoverus} leverages LLMs for automated proof synthesis in Rust using finetuned knowledge bases and refinement processes. Clover~\cite{sun2024clover} addresses the case of SV where no specification is formally given, and attempts to autoformalize a specification in Dafny by aligning with the available implementations and documentations. LeanDojo~\cite{yang2023leandojo} introduces a large premise pool in Lean and uses fine-tuned retrieval models to perform RAG for proofs. Although these approaches differ in methodology and application areas, they all focus primarily on single-function verification. 

\mypara{Repository-level program verification} Repository-level program verification is a relatively emerging field with limited previous research addressing the inherent complexity of large software systems. Selene~\cite{zhang2024selene} represents a pioneering effort in this domain, but the language focus, verification tooling, and dependency management approaches are different from \ragverus. While there has been recent development in repository-level LLM-based code generation~\cite{liao20243}, \ragverus extends this domain into automated verification, ensuring not only the generation of code but also its formal correctness.