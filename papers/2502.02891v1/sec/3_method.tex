
\section{Method}
\begin{figure}
  \centering
  % \begin{subfigure}{0.68\linewidth}
  %   \fbox{\rule{0pt}{2in} \rule{.9\linewidth}{0pt}}
    \includegraphics[width=\linewidth]{figs/sampleedits2.pdf}
    \caption{Examples of edits using different brush profiles and modulation functions. Above each shape, the left plot shows the brush profile, and the right plot shows the modulation.}
    \label{fig:vary}
  % \end{subfigure}
  \vspace{-5pt}
\end{figure}

We present an interactive neural sculpting framework built around pretrained neural SDFs, allowing real-time stroke-based edits on 3D surfaces. The system operates by sampling points along a user-defined stroke, forming a tubular region around the curve where edits are applied. Central to this approach is the brush profile, which defines the shape and intensity of the deformation. Users can either select from analytical brush functions, such as linear, cubic, or quintic falloffs, or define custom profiles using control points, which are interpolated with splines.

Additionally, the brush profile can be modulated along the stroke, enabling effects like gradual offset distance changes, fade in, fade out, etc. The combination of tubular sampling and efficient surface evaluation allows for smooth and consistent deformations, while maintaining interactive update speed through minimal fine-tuning of the neural SDF.
\subsection{Neural SDF}
The backbone system of our approach is an implicit neural representation that models 3D geometry using a signed distance function. Neural SDFs represent surfaces implicitly by parameterizing the geometry using a neural network, and effectively allow continuous sampling of 3D shapes at infinite resolution without being tied to any fixed grid.

\subsubsection{Signed Distance Function}
Given a surface \( S \subset \mathbb{R}^3 \), the signed distance function assigns to every point \( x \in \mathbb{R}^3 \) the shortest distance to the surface. Specifically, for a closed surface, it is defined as
\begin{equation}
\text{SDF}(x, S) =
\begin{cases}
   \min_{y \in S} \; d(x, y) & \text{if } x \text{ is inside } S, \\
  - \min_{y \in S} \; d(x, y) & \text{otherwise},
\end{cases}
\end{equation}
where \( d(x, y) \) is the Euclidean distance between points \( x \) and \( y \).

A neural SDF uses a neural network to approximate this function, effectively capturing the surface as the zero-level set of the network's output.

\subsubsection{SIREN based MLP}

For the neural SDF representation, we adopt the SIREN architecture \cite{sitzmann2020implicit}, a simple MLP with sinusoidal activations that enable the modeling of high-frequency details. SIREN takes spatial coordinates as input and outputs the corresponding signed distance value, with sine activations helping to represent fine surface structures more effectively than standard activations like ReLU.  

The non-linear layers use sine functions:  
\begin{equation}  
\text{SIREN}(x) = \sin(\omega_0 \cdot W x + b),  
\end{equation}  
where \( W \) is the weight matrix, \( b \) is the bias, and \( \omega_0 \) controls the frequency of the sine waves.  

% While standard MLPs exhibit a low-frequency bias, making them less effective for detailed geometry, several techniques such as Positional Encoding and Fourier Features \cite{tancik2020fourier, mildenhall2021nerf} have been proposed to introduce higher frequencies. SIREN achieves this directly through its periodic activations, offering a simple yet effective alternative.  

While alternative architectures could improve sharpness and better preserve unedited regions, our focus is not on optimizing the neural SDF backbone but on developing an efficient stroke-based sculpting pipeline on top of the INR. Thus, we adopt SIREN, following 3DNS, to ensure direct comparability while maintaining simplicity and effectiveness.

\subsubsection{Training and Loss Function}
Learning an SDF is a regression problem that necessitates minimizing a loss function that adequately represents a smooth shape. During training, this involves sampling points within the shape, outside the shape, and on the surface within its bounding box, evaluating the loss at each iteration. For surface points, the SDF value is zero, representing the zero-level set. For other sampled points, the loss evaluation requires computing the distance to the nearest surface point, which can be computationally expensive. To address this, we leverage the fact that the SDF satisfies the eikonal equation, adopting a pseudo-loss term based on the eikonal condition for all non-surface points. Additionally, we introduce a term that aligns the normal vectors at these sampled points with the expected surface normals. Finally, a regularization term is included to penalize small SDF values for points near the edges of the bounding box.

This multi-component loss function, adopted from the framework established in 3DNS~\cite{tzathas20233d} can be expressed as
\begin{equation}
L = \lambda_1 L_{\text{regression}} + \lambda_2 L_{\text{eikonal}} + \lambda_3 L_{\text{normal}} + \lambda_4 L_{\text{boundary}},
\end{equation}
where \(L_{\text{regression}}\) represents the primary regression loss, \(L_{\text{eikonal}}\) ensures compliance with the eikonal equation, \(L_{\text{normal}}\) aligns the normals, and \(L_{\text{boundary}}\) enforces regularization near the bounding box edges:
\begin{align}
&L_\text{regression}(\theta) &&= \mathbb{E}_{p_S} \left[|f_\theta(x)|\right]\\
 & L_\text{normal}(\theta) &&= \mathbb{E}_{p_S} \left[g(\nabla_x f_\theta(x), n_x)\right]\\
  &  L_{\text{eikonal}}(\theta) &&= \mathbb{E}_q \left[\left| \|\nabla_x f_\theta(x)\| - 1 \right| \right]\\
   & L_{\text{boundary}}(\theta) &&= \mathbb{E}_q \left[ e^{-\alpha |f_\theta(x)|} \right]
\end{align}
Here \( \lambda_1=1.5\times 10^3, \lambda_2=5, \lambda_3=2.5, \) and \( \lambda_4=5 \) are balancing weights, \( \alpha=100 \) is a large positive constant, $\mathbb{E}_{p_S}$ represents expectation computed over points on surface and $\mathbb{E}_{q}$ for the off-surface points in the bounding box, $\theta$ is the network weights, $f_\theta$ is the SIREN network, $g$ is the cosine distance, and $n_x$ is the surface normal at $x$.  These terms collectively ensure that the network learns an accurate and smooth representation of the surface, while maintaining the correct geometry for off-surface points.


The sampling strategy for training, including the efficient surface sampling used for stroke-based edits, will be discussed in Sec.~\ref{sec:sampling}. 
\subsection{Coordinate Frame for Stroke-Based Sculpting}
To enable intuitive sculpting, we define a custom coordinate system along each stroke that allows for precise control over deformation. This coordinate frame is established with three orthogonal directions:
\begin{enumerate}
    \item \textbf{Stroke Direction (\(u\))}: Defines the main path of the stroke, representing the curve or line along which the brush moves. 
   \item  \textbf{Brush Profile Direction (\(v\))}: Runs perpendicular to \(u\) and tangential to the surface, and defines the extent of the brush profile at any given point along the stroke.
   \item  \textbf{Normal Direction (\(n\))}: Orthogonal to both \(u\) and \(v\), pointing outward from the surface, allowing deformations to be applied in line with the surface geometry.
\end{enumerate}

This \(u\)-\(v\)-\(n\) frame allows the brush profile to be defined along \(v\), while modulation along the stroke itself is achieved along \(u\), and deformations are applied in the normal direction \(n\), as illustrated in Fig.~\ref{fig:overview}.

\subsection{Brushes}

Once the neural SDF is trained, the user can perform surface edits using a \textit{brush}. In this framework, a brush is defined as a \(C^1\) function, \(b_P(v)\), operating along the \(v\)-direction. The brush profile determines the intensity (amount of normal displacement) and shape of the deformation across the stroke, and it can be defined by users interactively using control points. We normalize the domain and range of the brush to be within $[-1, 1]$. Such a brush definition is flexible, allowing for both carving and extruding operations within a single application as the displacement can be negative as well as positive. Specifically, we use the piecewise polynomial function \(P(v)\), defined by the Catmull-Rom spline \cite{catmull1974class} interpolating the $k$ user-defined control points \((v_i, y_i)\) for \(i = 1, 2, \ldots, k\),
\begin{equation}
b_P(v)=P(v), \quad |v| \le 1,
\end{equation}
as illustrated in Fig.~\ref{fig:overview}.

Given the normalized brush profile \(b_P(v)\), following 3DNS~\cite{tzathas20233d}, we define a family of brushes \(B_{r,s}(x)\) parameterized by radius \(r\) and intensity \(s\):

\begin{equation}
B_{r,s}(x) = s \; b_P\left( \frac{x}{r} \right), \quad r \in \mathbb{R}^+, \, s \in \mathbb{R}.
\end{equation}


Since the brush profile has normalized domain and range, this formulation enables independent adjustments of the region and magnitude of deformation. For instance, given a positive user-defined brush profile, a positive intensity \(s\) can create a bump on the surface, whereas a negative intensity can result in a dent with a radius controlling the width of the impact region of the edit. Fig. \ref{fig:brushfamily} shows the effect of different intensities and radii when applying a parabolic brush stroke on a sphere. 

\begin{figure}[htbp]
  \centering
  % \begin{subfigure}{0.68\linewidth}
  %   \fbox{\rule{0pt}{2in} \rule{.9\linewidth}{0pt}}
    \includegraphics[width=\linewidth]{figs/brushfamily2.pdf}
    \caption{Effect of radius and intensity variations for the same brush stroke.}
    \label{fig:brushfamily}
  % \end{subfigure}
\end{figure}


To apply the brush, we modify the neural SDFâ€™s zero-level set \( f_{\theta}(p) = 0 \) by offsetting surface points along the normal direction using the brush profile within the local \(u\)-\(v\)-\(n\) frame. Points \( p \) are first sampled in the tubular region around the stroke and projected onto the surface to ensure they lie on the original zero-level set. Their displaced positions are then computed as:  
\begin{equation}  
p' = p + B_{r, s}(v(p)) \; n(u(p)),  
\end{equation}  
where \( p' \) is the target zero-level set position, \( v(p) \) is the signed distance from \( p \) to the brush stroke curve, measured in the plane orthogonal to \( u \), with the sign indicating the relative position to the plane formed by the surface normal and stroke direction. \( n(u(p)) \) is the surface normal at the stroke. The neural SDF is then fine-tuned to align its zero-level set with the deformed surface by minimizing:  
\begin{equation}  
L_\text{deformation} = \mathbb{E}\left[ \left| f_{\theta}(p') \right| \right],  
\end{equation}  
where \(f_{\theta}(p')\) is the modified SDF at \(p'\) and \( \mathbb{E} \) represents the mean absolute SDF value over all displaced points \( p' \), ensuring they remain on the zero-level set of the updated surface.


\subsection{Stroke Representation}

In our framework, a stroke is defined as a curve with parameter $u$, representing the trajectory of the brush center moving on the 3D surface. The tangent at a point on the curve provides the $u$-direction. This path, or stroke, can be directly specified by the user by selecting a sequence of control points on the surface through the interactive editor. These control points are interpolated using a cubic spline to create a smooth, continuous curve $\gamma(u)$, parameterized by $u \in [0,1]$, where $u=0$ represents the start and $u=1$ the end of the stroke.

Mimicking typical sculpting edits, the intensity of deformation can vary dynamically along the strokeâ€™s $u$-direction through a modulation function $m(u)$. Modulation strategies can be user-defined or selected from predefined functions, allowing for varied effects along the stroke. For instance, a linear falloff reduces intensity gradually from one end to the other, a central modulation peaks in the middle of the stroke and tapers toward both ends, while a sinusoidal modulation creates a rhythmic intensity pattern such as frog scales in Fig. \ref{fig:edits}. Custom user-defined modulation curves are also supported, offering artists the flexibility to create personalized intensity variations along each stroke path. 

At each point along the stroke, this modulation function \(m(u)\) combines with the brush profile \(B_{r, s}(v)\) in the perpendicular \(v\)-direction to yield a spatially dynamic deformation field. The overall brush intensity at any point is therefore expressed as 
\begin{equation}
m(u) \; B_{r, s}(v),
\end{equation}
where \(B_{r, s}(v)\) is the brush profile perpendicular to the stroke. Fig. \ref{fig:edits} presents naturalistic edits that artists would find useful. Fig. \ref{fig:vary} highlights INST-Sculpt's editing capabilities with different brush profiles and modulation functions: (a) a linearly fading cheekbone, (b) central modulation of a three-way brush on the bunnyâ€™s spine and head, (c) a non-radial sinewave-modulated braid on the frogâ€™s back, and (d) dampened sinewave detailing on a torus. 


\begin{figure}[htbp]
  \centering
   \includegraphics[width=0.3\linewidth]{figs/uvn.pdf}
   \includegraphics[width=0.4\linewidth]{figs/tubular_sampling.pdf}

   \caption{Illustration of the coordinate frame and sampling strategy. \textit{Left}: A 3D view of the user-defined stroke with control points and the $u$-$v$-$n$ frame on the surface. \textit{Right}: A top-down view of the $u$-$v$ plane showing tubular sampling within a radius around the stroke.}
   \label{fig:sampling}
   \vspace{-0.4cm}
\end{figure}

\subsection{Sampling}
\label{sec:sampling}

Sampling is essential for efficiently capturing both stroke-affected and untouched regions of the surface for training the neural parameters $\theta$. The main sampling coordinates $(u,v,n)$ define the structure of the brush interaction.
\begin{table*}[htbp]
  \centering
  % First table
  \begin{minipage}{0.25\textwidth}
  
    \centering
    \setlength{\tabcolsep}{3pt}
    \begin{tabular}{|cccc|} 
    \hline
    \multicolumn{4}{|c|}{Editing time (sec)}                                                                               \\ \hline
    \multicolumn{1}{|c|}{Points} & \multicolumn{1}{c|}{Ours}    & \multicolumn{1}{c|}{3DNS}     & Gain              \\ \hline
    \multicolumn{1}{|c|}{8}             & \multicolumn{1}{c|}{0.666} & \multicolumn{1}{c|}{0.715}  & \textbf{1.073} \\ \hline
    \multicolumn{1}{|c|}{16}            & \multicolumn{1}{c|}{0.690} & \multicolumn{1}{c|}{1.291}  & \textbf{1.871}  \\ \hline
    \multicolumn{1}{|c|}{32}            & \multicolumn{1}{c|}{0.676} & \multicolumn{1}{c|}{2.569}  & \textbf{3.801}  \\ \hline
    \multicolumn{1}{|c|}{64}            & \multicolumn{1}{c|}{0.684} & \multicolumn{1}{c|}{6.025}  & \textbf{8.814}  \\ \hline
    \multicolumn{1}{|c|}{128}           & \multicolumn{1}{c|}{0.697} & \multicolumn{1}{c|}{11.461} & \textbf{16.439} \\ \hline
    \end{tabular}
    \caption{Comparison of editing times for stroke-based edits using our tubular sampling approach versus 3DNS point-based sampling, averaged over 100 iterations. Gain represents the relative speedup achieved by our method.}
      \label{tab:timing}
    \vspace{-1em}
  \end{minipage}
    \hfill
  \begin{minipage}{0.58\textwidth}
    \centering
    \setlength{\tabcolsep}{3pt}
    \begin{tabular}{|ccccccc|}
    \hline
    \multicolumn{7}{|c|}{Mean   Chamfer Distance $\times 10^3 (\downarrow)$}                                                                                                                                               \\ \hline
    \multicolumn{1}{|c|}{}        & \multicolumn{3}{c|}{Over whole surface}                                                             & \multicolumn{3}{c|}{Inside tubular region}                                       \\ \hline
    \multicolumn{1}{|c|}{Shape}   & \multicolumn{1}{c|}{Ours}           & \multicolumn{1}{c|}{3DNS}  & \multicolumn{1}{c|}{Coarse Mesh} & \multicolumn{1}{c|}{Ours}            & \multicolumn{1}{c|}{3DNS}   & Coarse Mesh \\ \hline
    \multicolumn{1}{|c|}{Sphere}  & \multicolumn{1}{c|}{\textbf{7.279}} & \multicolumn{1}{c|}{7.394} & \multicolumn{1}{c|}{7.329}       & \multicolumn{1}{c|}{\textbf{9.932}}  & \multicolumn{1}{c|}{28.099} & 17.532      \\ \hline
    \multicolumn{1}{|c|}{Bunny}   & \multicolumn{1}{c|}{\textbf{9.175}} & \multicolumn{1}{c|}{9.190} & \multicolumn{1}{c|}{9.815}       & \multicolumn{1}{c|}{\textbf{14.661}} & \multicolumn{1}{c|}{29.130} & 21.240      \\ \hline
    \multicolumn{1}{|c|}{Bust}    & \multicolumn{1}{c|}{\textbf{7.363}} & \multicolumn{1}{c|}{7.555} & \multicolumn{1}{c|}{7.617}       & \multicolumn{1}{c|}{\textbf{12.711}} & \multicolumn{1}{c|}{29.164} & 19.998      \\ \hline
    \multicolumn{1}{|c|}{Pumpkin} & \multicolumn{1}{c|}{\textbf{8.470}} & \multicolumn{1}{c|}{8.690} & \multicolumn{1}{c|}{9.445}       & \multicolumn{1}{c|}{\textbf{9.672}}  & \multicolumn{1}{c|}{28.446} & 20.301      \\ \hline
    \multicolumn{1}{|c|}{Torus}   & \multicolumn{1}{c|}{\textbf{5.969}} & \multicolumn{1}{c|}{6.098} & \multicolumn{1}{c|}{6.208}       & \multicolumn{1}{c|}{\textbf{11.850}} & \multicolumn{1}{c|}{23.368} & 15.307      \\ \hline
    \multicolumn{1}{|c|}{Frog}    & \multicolumn{1}{c|}{\textbf{8.099}} & \multicolumn{1}{c|}{8.357} & \multicolumn{1}{c|}{9.091}       & \multicolumn{1}{c|}{\textbf{8.785}}  & \multicolumn{1}{c|}{28.262} & 22.886      \\ \hline
    \end{tabular}
    \caption{Comparison of our editing method with 3DNS pointwise edits and direct mesh editing on a coarse mesh of equivalent network size. Chamfer distances were computed using 100,000 points, with means averaged over 10 independent edits per shape.}
    \label{tab:chamfer}
    \vspace{-1em}
  \end{minipage}%
  \hfill
  % Second table
  \begin{minipage}{0.14\textwidth}
    \centering
    \setlength{\tabcolsep}{3pt}
    \begin{tabular}{|c|c|}
                \hline
                $n$ & CD ($\downarrow$) \\
                \hline
                8   & 0.01252 \\\hline
                16  & 0.01149 \\\hline
                32  & 0.00967 \\\hline
                64  & 0.00674 \\\hline
                128 & 0.00654 \\\hline
                512 & 0.00642 \\\hline
            \end{tabular}
            \caption{Effect of varying number of point samples along the stroke on edit quality.}
            \label{tab:cd_values}
    \vspace{-1em}
  \end{minipage}
\end{table*}
\subsubsection{Tubular Sampling}

A key contribution of this paper is the \textit{tubular sampling strategy} we employ for efficient stroke-based edits. To apply the brush profile along the curve, samples are generated not only along the stroke itself (the \( u \)-direction) but also around it in a tubular neighborhood defined by the perpendicular \( v \)-direction. This strategy ensures consistent brush effects across the region with an appropriate brush size, even on intricate, curved surfaces.
 
To perform tubular sampling, we first generate \(N \) samples uniformly distributed along the stroke trajectory \( \gamma(u) \). For each point on the curve, we calculate an in-plane normal vector \( \mathbf{v}(u) \) by taking the cross product of the tangent vector \( \mathbf{u}(u) \) along the curve with the surface normal \( \mathbf{n}(u) \):
\begin{equation}
\mathbf{v}(u) = \mathbf{n}(u) \times \mathbf{u}(u).
\end{equation}

Next, we apply uniformly spaced offsets in \( v \)-direction from \([-r, r]\), where \( r \) is the brush radius. These offset points are then projected onto the surface to capture the tubular neighborhood, creating a continuous zone of interaction for the brush. Fig.~\ref{fig:sampling} demonstrates our sampling strategy applied to a stroke.


Based on our experiments, we find that sampling \textbf{99 points} along the stroke, \textbf{101 points} in the offset direction and 10,000 samples to stabilize the untouched region effectively captures a typical stroke on the surface, yielding smooth deformations at interactive frame rates. It is significantly more efficient than 3DNS, which samples 120,000 surface points and discards those in the interaction region. It then resamples 10 (referred to as the interaction factor) times the number of discarded points within the tangent disc around each stroke point. When using 10,000 surface samples within the interaction region for both methods, 3DNS typically samples more than 10 times as many overall points as our method. 




% \begin{table*}[]
% \centering
% \begin{tabular}{|ccccccc|}
% \hline
% \multicolumn{7}{|c|}{Mean   Chamfer Distance $\times 10^3 (\downarrow)$}                                                                                                                                               \\ \hline
% \multicolumn{1}{|c|}{}        & \multicolumn{3}{c|}{Over whole surface}                                                             & \multicolumn{3}{c|}{Inside tubular region}                                       \\ \hline
% \multicolumn{1}{|c|}{Shape}   & \multicolumn{1}{c|}{Ours}           & \multicolumn{1}{c|}{3DNS}  & \multicolumn{1}{c|}{Coarse Mesh} & \multicolumn{1}{c|}{Ours}            & \multicolumn{1}{c|}{3DNS}   & Coarse Mesh \\ \hline
% \multicolumn{1}{|c|}{Sphere}  & \multicolumn{1}{c|}{\textbf{7.279}} & \multicolumn{1}{c|}{7.394} & \multicolumn{1}{c|}{7.329}       & \multicolumn{1}{c|}{\textbf{9.932}}  & \multicolumn{1}{c|}{28.099} & 17.532      \\ \hline
% \multicolumn{1}{|c|}{Bunny}   & \multicolumn{1}{c|}{\textbf{9.175}} & \multicolumn{1}{c|}{9.190} & \multicolumn{1}{c|}{9.815}       & \multicolumn{1}{c|}{\textbf{14.661}} & \multicolumn{1}{c|}{29.130} & 21.240      \\ \hline
% \multicolumn{1}{|c|}{Bust}    & \multicolumn{1}{c|}{\textbf{7.363}} & \multicolumn{1}{c|}{7.555} & \multicolumn{1}{c|}{7.617}       & \multicolumn{1}{c|}{\textbf{12.711}} & \multicolumn{1}{c|}{29.164} & 19.998      \\ \hline
% \multicolumn{1}{|c|}{Pumpkin} & \multicolumn{1}{c|}{\textbf{8.470}} & \multicolumn{1}{c|}{8.690} & \multicolumn{1}{c|}{9.445}       & \multicolumn{1}{c|}{\textbf{9.672}}  & \multicolumn{1}{c|}{28.446} & 20.301      \\ \hline
% \multicolumn{1}{|c|}{Torus}   & \multicolumn{1}{c|}{\textbf{5.969}} & \multicolumn{1}{c|}{6.098} & \multicolumn{1}{c|}{6.208}       & \multicolumn{1}{c|}{\textbf{11.850}} & \multicolumn{1}{c|}{23.368} & 15.307      \\ \hline
% \multicolumn{1}{|c|}{Frog}    & \multicolumn{1}{c|}{\textbf{8.099}} & \multicolumn{1}{c|}{8.357} & \multicolumn{1}{c|}{9.091}       & \multicolumn{1}{c|}{\textbf{8.785}}  & \multicolumn{1}{c|}{28.262} & 22.886      \\ \hline
% \end{tabular}
% \caption{Comparison of our editing method with 3DNS pointwise edits and direct mesh editing on a coarse mesh of equivalent network size. Chamfer distances were computed using 100,000 points, with means averaged over 10 independent edits per shape.}
% \label{tab:chamfer}
% \end{table*}

\subsubsection{Surface Sampling}

For sampling the untouched regions of the surface, we follow the approach outlined by \cite{tzathas20233d}. Uniformly sampling points in space and projecting them to the zero-level set can result in a non-uniform distribution of points on the surface. To address this, 3DNS begins with an initial pool of samples, perturbing them over training iterations by adding a uniformly sampled vector on the tangent disc at each point. These perturbed points are then reprojected onto the surface using the aforementioned procedure. Since their method yields a more uniformly distributed sample set, which is beneficial for SDF training, we adopt their Markovian SDF sampler in our setup.


