\section{Decomposition Box}





% Feature 1: Inferring Users' Thought Process from Existing Code
% Feature 2: Independent Problem Decomposition through Step Trees and Natural Language.
% Feature 3: Step Tree Node Status Evaluation with Preservation of Original Structure
% Feature 4: Progressive Hint for Idea Formation
% Feature 5: Converting the Step Tree into Comments
% Feature 6: Validating Code Implementation against the Step Tree
% Feature 7: Progressive Hint for Idea Implementation


% Challenge 1: Excessive Help Hindering Active Learning
% Challenge 2: Difficulty in Utilizing ChatGPT for Effective Learning
% Challenge 3: Misalignment Between Provided Solutions and Learners’ Approaches
% Challenge 4: Disconnect Between Existing Code and Provided Solutions.
% Challenge 5: Lack of a Structured Problem-Solving Approach
% Challenge 6: Insufficient Fine-Grained Feedback on Learner Progress


% Goal 1: Scaffolding for Active Learning and Independent Thinking
% Goal 2: Personalization to Individual Problem-Solving Styles
% Goal 3: Connection and Structured Solution Presentation
% Goal 4: Fine-Grained Evaluation and Feedback

% \renewcommand{\arraystretch}{1.2}
% \begin{table*}[tp]  

% \centering  
% \fontsize{8}{8}\selectfont  

% \caption{A mapping between the identified challenges from our formative, the design goals, and the features of Decomposition Box}\label{table:mapping}
% \label{intention_themes}
% \begin{tabular}{m{5cm}<{\centering}m{4.5cm}<{\centering}m{4.5cm}<{\centering}}
% \toprule
% \textbf{Challenge}&\textbf{Design Goal}&\textbf{DBox Feature}\\
% \midrule

% Challenge 1: Excessive Help Hindering Active Learning & \multirow{3}*{\shortstack{Goal 1: Scaffolding for Active \\Learning and Independent Thinking}}& \multirow{3}*{\shortstack{Feature 1\&2 (Stage 1), \\Feature 4\&7 (Stage 1\&2)}}\\

% Challenge 2: Difficulty in Utilizing ChatGPT for Effective Learning &  & \\


% \midrule
% Challenge 3: Misalignment Between Provided Solutions and Learners’ Approaches & Goal 2: Personalization to Individual Problem-Solving Styles & Feature 1 (Stage 1), Feature 3 (Stage 1)\\


% \midrule
% Challenge 4: Disconnect Between Existing Code and Provided Solutions & \multirow{3}*{\shortstack{Goal 3: Connection and Structured\\ Solution Presentation}} & \multirow{3}*{\shortstack{Feature 1 (Stage 1), Feature 2 (Stage 1),\\ Feature 5 (Stage 2), Feature 6 (Stage 2)}}\\

% Challenge 5: Lack of a Structured Problem-Solving Approach &  & \\

% \midrule
% Challenge 6: Insufficient Fine-Grained Feedback on Learner Progress & Goal 4: Fine-Grained Evaluation and Feedback & Feature 3 (Stage 1), Feature 6 (Stage 2)\\

% \bottomrule
% \end{tabular}
% \end{table*}



% Based on our design goals, we developed Decomposition Box (DBox) accordingly. 
% % Table \ref{table:mapping} shows the mapping between challenges identified in our formative study, the design goals, and DBox’s features. 
% Figure \ref{fig:interface} shows the interface.

\subsection{Overview} \label{overview}




\begin{figure*}[htbp]
	\centering 
	\includegraphics[width=\linewidth]{figures/UI_new.pdf}
	\caption{The interface of Decomposition Box. The top row displays the full interface in the solution formation stage (the solution implementation stage is similar, but with different status indicators). The middle row demonstrates a learner's solution formation stage showing basic DBox features. The bottom row illustrates a learner's solution implementation stage. An overview of the DBox interface and workflow is provided in Sec. \ref{overview}, and an illustrative example is described in Sec. \ref{illustrative}. To save space, the second row omits the problem description and editor area, and the third row excludes the problem description area.}
	\label{fig:interface}
        \Description{}
\end{figure*}

As shown in Figure \ref{fig:interface} (top row), DBox's interface has three main parts. The Problem Description (Figure \ref{fig:interface}.A)) and Solution Code Editor (Figure \ref{fig:interface}.B) are similar to the LeetCode platform.
The Interactive Step Tree Widget (Figure \ref{fig:interface}.D) enables users to refine their thought process and receive feedback via an interactive step tree. 
Three buttons—``From Editor to Step Tree'', ``Check Match'', and ``Copy to Comments''—connect the editor and step tree. 
The ``Check Step Tree'' button provides feedback on the step tree's status, categorized into five types (Figure \ref{fig:interface}.D). 
Clicking ``Hint'' offers progressive guidance based on learners' existing attempts (Figure \ref{fig:interface}.E). 
Hovering over steps shows buttons for editing the step tree (Figure \ref{fig:interface}.F).
% \begin{itemize}
%     \item Problem Description (Figure \ref{fig:interface} A): Displays the current problem, with a "Problem List" button , similar to traditional platforms.
%     \item Code Editor (Figure \ref{fig:interface} B): Allows users to write and run code. Output and test case results are shown in Figure \ref{fig:interface} C.
%     \item Interactive Step Tree Widget (Figure \ref{fig:interface} D): Users refine their thought process and receive feedback via an interactive step tree. Three buttons—“From Editor to Step Tree”, “Check Match”, and “Copy to Comments”—connect the editor and step tree. The “Check Step Tree” button provides feedback on the step tree's status, categorized into five types (Figure \ref{fig:interface} D). Clicking ``Hint'' offers progressive guidance based on learners' existing attempts (Figure \ref{fig:interface} E). Hovering over steps shows buttons for editing the step tree (Figure \ref{fig:interface} F).
% \end{itemize}
Figure \ref{fig:workflow} shows two key stages in DBox's workflow:
\begin{itemize}
    \item \textbf{Solution Formation}: 
    The step tree starts as an empty box where students can freely add steps in either coding mode (directly writing code) or description mode (building a step tree using natural language). 
They can evaluate their progress with the ``From Editor to Step Tree'' or ``Check Step Tree'' buttons. The tree contains steps and substeps labeled as \emph{Correct}, \emph{Incorrect}, \emph{System Generated}, \emph{Missing}, or \emph{Can be Divided}. 
Layouts adjust dynamically based on the hierarchy. 
Steps that can be further divided are marked with dashed outlines, serving as a reminder, though students can decide whether further division is necessary. 
    \item \textbf{Solution Implementation}: Students can convert the step tree into comments with “Copy to Comments” or verify alignment by clicking “Check Match”. Nodes in the step tree are labeled as Implemented, Incorrectly Implemented, or To Be Coded. In this stage, DBox also offers progressive hints. When all nodes are implemented, students can test their solution by clicking “Run” button against the provided test cases.
\end{itemize}






\begin{figure*}[htbp]
	\centering 
	\includegraphics[width=\linewidth]{figures/pipeline.pdf}
	\caption{The DBox workflow supports learners through solution formation and implementation stages. During solution formation, (A) students can input ideas by either coding or using natural language to build a step tree. (B) By clicking ``From Editor to Step Tree'' or ``Check Step Tree'', (C) DBox renders the step tree and identifies node statuses (e.g., correct, incorrect, missing). Students can iteratively refine their code or step tree, receiving progressive hints, (D) until the step tree is fully correct. In the solution implementation stage, (E) students can convert the step tree into code comments or (F) check the alignment between their code and the step tree. Each node displays one of three statuses, and students can refine their work with ongoing hints until (G) all nodes are marked as ``implemented''.
 Finally, students can test if their code passes all test cases.}
	\label{fig:workflow}
        \Description{}
\end{figure*}



% Based on our design goals, we developed Decomposition Box (DBox). Table \ref{table:mapping} shows a mapping between the identified challenges from our formative study, the design goals, and the features of DBox. Figure \ref{fig:interface} shows the interface. Below, we provide an overview of the interface, followed by a detailed explanation of the key features and backend design.

% \subsection{Overview}

% As shown in Figure \ref{fig:interface} (top row), the interface of DBox is strategically divided into three distinct sections, from left to right, designed to enhance the user experience in algorithm programming:

% \begin{itemize}
%     \item Left Section - Problem Description (Figure \ref{fig:interface} (A)): This area allows users to view the problem they are currently working on. By clicking the ``Problem List'' button, users can easily switch between different problems they wish to practice. This setup is similar to traditional programming exercise platforms, providing a familiar layout for users.
%     \item Middle Section - Code Editor (Figure \ref{fig:interface} (B)): Central to the user interface, this section features an integrated CodeMirror editor where users can write and edit code in their chosen programming language. The ``Run'' button allows users to execute their code, with the output and any error messages (such as failed test cases or syntax errors) displayed (Figure \ref{fig:interface} C). If the code passes all test cases, it is marked as accepted, providing immediate feedback on the correctness of the solution.
%     \item Right Section - Decomposition Box (Figure \ref{fig:interface} (D)): This core area is where users can refine their thought processes and receive specific feedback and reminders related to their coding approach. Positioned between the code editor and this section are three interactive buttons that facilitate seamless communication between the editor and the Decomposition Box, enhancing the integration of feedback into the coding process.
% \end{itemize}

% As shown in Figure \ref{fig:workflow}, DBox is designed to support two key stages in students' algorithmic programming practice: \textbf{Idea Formation} and \textbf{Idea Implementation}. In the Idea Formation stage, students can input their thoughts in two modes (Figure \ref{fig:workflow} (A)): one is the coding mode, where they directly write code, and the other is the description mode, where they build a step tree interactively using natural language to describe each node. Based on the selected input mode, students can click different buttons to check the status of their step tree (Figure \ref{fig:workflow} (B)). The ``From Editor to Step Tree'' button converts incomplete code into a step tree, while the ``Check Step Tree'' button evaluates the status of each node in the tree. The step tree can include steps, sub-steps, and even sub-sub-steps, with DBox identifying the status of each node, which could be one of five types: Correct, Incorrect, AI Generated, Missing, or Divisible (Figure \ref{fig:workflow} (C)). Students can refine their code or step tree and click the corresponding buttons to check the updated status of the tree. Throughout this process, DBox provides progressive hints, divided into three levels. After several refinements, the step tree becomes fully correct (Figure \ref{fig:workflow} (D)), allowing students to proceed to the Idea Implementation stage.

% At this stage, students can use the ``Check Match'' button to verify whether the code in the editor aligns with the nodes in the step tree, or they can click the ``Copy to Comments'' button to convert the step tree into comments in the editor to assist with coding (Figure \ref{fig:workflow} (E)). After clicking ``Check Match,'' the nodes in the step tree will be labeled with one of three statuses: Implemented, Incorrectly Implemented, or To Be Coded (Figure \ref{fig:workflow} (F)). DBox continues to offer progressive hints during this phase as well. After modifying the code based on feedback, the step tree will eventually display all nodes as implemented (Figure \ref{fig:workflow} (G)). At this point, the student can click the ``Run'' button to validate the solution against the test cases.





% The interface is crafted to be easily integrated as a plugin into existing programming tools and platforms, such as online environments like LeetCode or offline editors like VSCode, offering flexibility and adaptability across different learning and development settings.






% \subsection{Overview of DBox Interface}
% A learner named Alice wants to practice her algorithmic programming using a problem ``Search in Rotated Sorted Array". After reading the problem description, Alice comes up with some initial thoughts in her mind. DBox provides two input modes, one is through directly writing codes, the other is building a step tree via natural languege description at the right-side of the interface. (1) Alice chooses to add two steps, Step 1 and Step 2, to construct an initial step tree. (2) After clicking the ``Check Step Tree'' button, DBox identifies Step 1 as correct and Step 2 as incorrect, also indicating a missing Step 3. Alice then clicks the hint button on Step 2 to access general and detailed hints. (3) If Alice makes two consecutive errors at Step 2, a new hint triggers: ``reveal step.'' (4) Clicking this button reveals a crucial sub-step (Step2-3) and leaves Step 2-1 and Step 2-2 for Alice to complete. (5) Once Alice completes these, she clicks ``Check Step Tree'' again and finds all of Step 2 correct. (6) Alice also correctly constructs Step 3. \textbf{The third row displays Alice's process of implementing the solution}. (8) First, Alice clicks the ``Copy to Comments'' button, and DBox converts the step tree into code comments, inserting them at the corresponding positions in the editor. (9) After writing some code, Alice uses the ``Check Match'' button to identify steps that are not correctly implemented, noting that Step 2-3 and Step 3 are incomplete. (10) Guided by DBox, Alice writes the corresponding code. Upon clicking ``Check Match'' again, all steps turn green to indicate they are implemented correctly. When hovering over a step, the corresponding code line is highlighted. Finally, Alice hits the Run button, passes all test cases, and successfully solves the problem. It's important to note that this figure only shows just one of many possible interactions. To save space, the second row of images displays only the step tree on the right side of the interface, while the third row shows both the middle editor and the step tree.






% \subsection{Overview of DBox Interface}
% Alice, a learner, is practicing algorithmic programming with the problem ``Search in Rotated Sorted Array.'' After reading the problem description, she formulates some initial ideas in her mind. DBox offers two input modes: directly writing code or constructing a step tree using natural language descriptions on the right side of the interface. (1) Alice opts to build a step tree and adds two initial steps, Step 1 and Step 2. (2) Upon clicking the ``Check Step Tree'' button, DBox identifies Step 1 as correct, flags Step 2 as incorrect, and highlights a missing Step 3. Alice clicks the hint button on Step 2 to access both general and detailed hints. (3) If she makes two consecutive errors in Step 2, DBox triggers an additional hint: ``reveal step.'' (4) Clicking this reveals a crucial sub-step (Step 2-3 in this case), while leaving Step 2-1 and Step 2-2 for Alice to complete. (5) After completing these sub-steps, (6) Alice checks the step tree again and finds all of Step 2 marked as correct. (7) She then constructs Step 3 successfully. Now, all nodes in the step tree are correct. (8) Alice then clicks the ``Copy to Comments'' button, and DBox converts the step tree into code comments, automatically inserting them into the editor. (9) After writing some code, she uses the ``Check Match'' button, which highlights steps that are not properly implemented, indicating that Step 2-3 and Step 3 are incomplete. (10) Following DBox's guidance, Alice writes the necessary code, and upon rechecking, all steps turn green, indicating correct implementation. Note that when Alice hovers over a step, the corresponding line of code is highlighted. Finally, she clicks the Run button, passes all test cases, and successfully solves the problem.



\subsection{Target Users and A System Walkthrough} \label{illustrative}
\ms{DBox is designed for learners who understand basic algorithm concepts but struggle to apply them to solve practical problems. Using a scaffolding approach, DBox emphasizes independent thinking by offering only essential support. It assumes students are motivated, self-regulated, and actively engaging with the tool to improve their decomposition skills. If a student is less motivated or prefers a quicker solution, they may bypass DBox to search for answers online.}
Next, we present an example walkthrough (Figure \ref{fig:interface}) of such a self-regulated student Alice: 
% usage example from our pilot study, as shown in Figure \ref{fig:interface}. While this illustrates one specific interaction, users can follow various workflows based on their preferences. Below is a detailed walkthrough of the scenario.

Alice, a learner tackling the ``Search in Rotated Sorted Array'' problem, begins by organizing her thoughts in the solution formation stage. DBox offers two options: she can either start coding or build a step tree using natural language. She opts for the latter and adds two initial steps (Figure \ref{fig:interface}.1). To check her progress, Alice clicks ``Check Step Tree'' button. DBox flags Step 1 as correct, Step 2 as incorrect, and highlights a missing Step 3 (Figure \ref{fig:interface}.2). She clicks the hint button on Step 2, receiving general and detailed guidance, but after another failed attempt, DBox offers another option for revealing a substep (Figure \ref{fig:interface}.3). Alice clicks ``Reveal (Sub)Step'', uncovering a sub-step 2-3 while leaving sub-steps 2-1 and 2-2 for her to solve (Figure \ref{fig:interface}.4). Inspired by the hints, Alice figures out how to break down and fills in these sub-steps (Figure \ref{fig:interface}.5). After checking again, Step 2 is marked correct (Figure \ref{fig:interface}.6). Alice adds the missing Step 3 (Figure \ref{fig:interface}.7), and finally, after checking, all steps turn to correct (Figure \ref{fig:interface}.8).

Next, Alice moves to the solution implementation stage. She clicks ``Copy to Comments'', and DBox converts her step tree into code comments (Figure \ref{fig:interface}.9). As Alice writes her code, she uses the ``Check Match'' button to identify incorrectly implemented and unimplemented steps. Step 2 is identified as unimplemented and Step 3 is identified as incorrectly implemented (Figure \ref{fig:interface}.10). Following DBox's guidance, she revises the code, and after another check, all steps turn to be correctly implemented (Figure \ref{fig:interface}.11). Satisfied with her progress, Alice clicks ``Run'' and successfully passes all test cases, solving the problem.

Note that we have presented only a simple walkthrough here, whereas the steps in a student's actual problem-solving process are more complex and dynamic (as shown later in Sec. \ref{actual_use}). Next, we introduce the specific features aligned with the four design goals as described in Sec. \ref{designgoal}.
% \textbf{D1}: Scaffolding for Active Learning and Independent Thinking; \textbf{D2}: Personalization to Individual Problem-Solving Styles; \textbf{D3}: Connection and Structured Solution Presentation; and \textbf{D4}: Fine-Grained Evaluation and Feedback. Each feature is tailored to different stages of the user's algorithmic programming journey.




% \subsection{An Illustrative Example} \label{illustrative}
% We now present a usage example observed during our user study, as shown in Figure \ref{fig:workflow}. While this illustrates one specific interaction, users can follow various workflows depending on their preferences. To conserve space, the second row in Figure \ref{fig:workflow} omits the problem description and editor, while the third row excludes the problem description. Below, we provide a detailed walkthrough of the scenario depicted.

% Alice, a algorithmic programming learner, is tackling the ``Search in Rotated Sorted Array'' problem. After reading the description, she starts to map out her approach. DBox offers two ways to proceed: Alice can either dive straight into coding or take a more structured route by building a step tree through natural language descriptions. She chooses the latter, organizing her thoughts by adding two initial steps—Step 1 and Step 2—to the step tree (Figure \ref{fig:workflow} (1)). Eager to check her progress, Alice clicks the ``Check Step Tree'' button. DBox instantly provides feedback: Step 1 is correct, but Step 2 is flagged as incorrect, with a missing Step 3 also highlighted (Figure \ref{fig:workflow} (2)). Alice clicks on the hint button for Step 2, receiving both general and detailed guidance. But she still experiences one more failed attempt on Step 2. At this time, DBox suggests a new hint strategy: revealing part of the solution (Figure \ref{fig:workflow} (3)). She clicks ``reveal step,'' uncovering a crucial sub-step (Step 2-3), while leaving her to figure out sub-steps 2-1 and 2-2 on her own (Figure \ref{fig:workflow} (4)). Alice continues working through the sub-steps (Figure \ref{fig:workflow} (5)). Finally, Step 2 is fully correct (Figure \ref{fig:workflow} (6)), and she successfully adds the missing Step 3. Now, the entire step tree is complete (Figure \ref{fig:workflow} (7)).

% With the structure in place, Alice moves on to the coding phase. She clicks the ``Copy to Comments'' button, and DBox seamlessly transforms her step tree into code comments, which are automatically inserted into the editor (Figure \ref{fig:workflow} (8)). She starts writing her code, and as she works, the ``Check Match'' button becomes her guide, highlighting which steps are incorrectly implemented. It's clear that Step 2-3 and Step 3 need further attention ("to be coded") (Figure \ref{fig:workflow} (9)). Following DBox's prompts, Alice revises the code, and after another check, all steps turn green, signaling success. As she hovers over each step in the tree, the corresponding line of code is highlighted, helping her stay aligned. Satisfied with her progress, Alice hits the Run button. Her code passes all test cases, and she successfully solves the problem (Figure \ref{fig:workflow} (10)). 



% Next, we will explore the specific features tailored to each stage of the user's journey in algorithmic programming.





% \subsection{Stage 1: Idea Formation}

% \subsubsection{Feature 1: Inferring Users' Thought Process from Existing Code.}
% When users click the “From Editor to Step Tree” button, DBox analyzes the current problem and the user’s incomplete code to infer their thought process, which is then displayed as a step tree on the right side. It’s important to note that this feature uses the user’s existing code as the primary input and does not take into account any pre-existing step tree, which will be overwritten. Once the step tree is generated, hovering over any step node highlights the corresponding code lines in the editor, helping users easily connect the step tree with their existing code. This feature is particularly useful when users have written some code and are stuck or when they want to check for errors in their existing code.

\subsection{Stage 1: Solution Formation}
\subsubsection{Two Input Modes (D1, D2, D3)}
DBox offers users the flexibility to develop their solutions through two distinct input modes: by writing code directly or by constructing a step tree using natural language descriptions, without needing to start with code. In the latter mode, users begin with a blank step tree and can click ``Add'' to insert nodes or ``Split'' to create sub-steps for more granular detail. Each node contains a text input field where users can articulate their thought process. Steps and sub-steps can be rearranged or deleted, allowing learners to iteratively and interactively refine and structure their mental model.

\subsubsection{Inferring Users' Thought Process from Existing Code (D1, D3)}
The ``From Editor to Step Tree'' function in DBox infers a learner’s intended solution and thought process based on their incomplete code. When activated, the system analyzes the code and problem, presenting the inferred steps as a tree on the right-hand side of the interface. Hovering over each node highlights the corresponding lines in the code editor, linking the inferred steps directly to the code. This feature assists users in diagnosing errors and identifying potential issues, especially when they are unsure how to proceed.


% \subsubsection{Feature 1: Inferring Users' Thought Process from Existing Code} The ``From Editor to Step Tree'' button in DBox leverages the user’s existing, incomplete code to infer their thought process. When activated, the system analyzes the problem and code, displaying the inferred steps as a tree on the right side of the interface. It's important to note that this feature prioritizes the current code over any pre-existing step tree, which will be overwritten. As the step tree populates, hovering over any node will highlight the corresponding lines in the code editor, linking conceptual steps directly to the code. This feature is invaluable for users who are stuck or wish to identify errors in their existing code, enhancing their ability to diagnose and resolve coding issues efficiently.



% \subsubsection{Feature 2: Decomposing A Problem via Step Tree via Natural Language Description.}
% In addition to generating a step tree from the user’s existing code, we allow users to develop their thought process directly through natural language descriptions, without needing to write code initially. We use an interactive visual step tree to help users organize their problem-solving ideas. Initially, the step tree area is blank. Users can click the Add button to create a node representing a step. They can add as many steps as needed, dividing the space of the step tree area. For each step node, users can click the Split button to add sub-steps. Each step and sub-step includes a blank text input area where users can describe their thought process in simple natural language. Users can also delete or rearrange any step or sub-step as they wish. Such a step tree is useful for helping learners build a structured mental model of the problem-solving strategy.


% \subsubsection{Feature 2: Independent Problem Decomposition through Step Trees and Natural Language}

% Our tool enhances problem-solving by allowing users to independently construct a step tree using natural language descriptions, without initially requiring code. The step tree area starts blank, and users can click the ``Add'' button to insert nodes representing individual steps, organizing their thought process visually. For more detailed breakdowns, the ``Split'' button enables users to add sub-steps under each main step. Each node in the step tree features a blank text input area where users can articulate their thought process in straightforward natural language. Users have the flexibility to delete or rearrange steps and sub-steps as needed, facilitating the development of a structured mental model for tackling complex problems. This method supports learners in systematically building and refining their problem-solving strategies.


% \subsubsection{Feature 2: Independent Problem Decomposition through Step Trees and Natural Language}

% DBox allows users to independently construct a step tree using natural language descriptions, without requiring initial code. Starting with a blank step tree, users can click ``Add'' to insert nodes representing steps, and ``Split'' to add sub-steps for more detailed breakdowns. Each node includes a text input area for users to articulate their thought process. Steps and sub-steps can be deleted or rearranged, helping users build a structured mental model. This feature supports learners in interactively developing and refining their problem-solving strategies.





% \subsubsection{Feature 2: Step Tree Node Status Evaluation.}
% Our tool provides a fine-grained evaluation of the user's thought process. For each step or sub-step, the system categorizes it into one of the following states: (1) Correct, indicating that the step is appropriate for the current problem-solving approach; (2) Incorrect, indicating an error in the thought process or specific details; (3) Missing, indicating a step that is necessary for the complete solution but is absent from the user’s incomplete code; (4) Can Be Further Divided, indicating that the step is complex and can be broken down into sub-steps; and (5) AI Suggested, where the system offers a description of the step in a blue box if the user triggers the most detailed hint level. Users have complete freedom to decide whether to further divide steps, ensuring flexibility in their problem-solving approach. 

% We’ve made a special design choice here: except when the system identifies missing steps and adds a blank missing node, the structure and content of the step tree remain as constructed by the user. The system does not override the user’s current step tree with what GPT considers to be the correct steps and descriptions. Instead, we provide feedback and guidance on the status of each node in the step tree, ensuring that users can continue to advance along their problem-solving approach.

% \subsubsection{Feature 3: Step Tree Node Status Evaluation with Preservation of Original Structure} Once the learner clicks ``From Editor to Step Tree'' or ``Check Step Tree'' button, DBox will conduct a detailed evaluation of each node in the user's step tree, categorizing each step or sub-step into one of five states: (1) \textbf{Correct}: The step is suitable for the current problem-solving approach. (2) \textbf{Incorrect}: There is an error in the thought process or specific details. (3) \textbf{Missing}: A necessary step is absent from the user's code. (4) \textbf{Can Be Further Divided}: The step is complex and could be broken into smaller, more manageable sub-steps. (5) \textbf{System Generated}: The system provides a step description in a blue box if the user activates the most detailed hint level. Users retain complete control over whether to sub-divide steps, allowing them to tailor their problem-solving approach flexibly. Importantly, except for adding a blank node when steps are identified as missing, the system preserves the user’s original step tree without replacing it with AI-determined correct steps. Feedback and guidance are provided on the status of each node, supporting users as they refine and advance their problem-solving strategies.


\subsubsection{Step Tree Node Status Evaluation with Preservation of Original Structure (D2, D4)}
When the learner clicks ``From Editor to Step Tree'' or ``Check Step Tree'', DBox evaluates each node, assigning one of five statuses:
(1) \textbf{Correct}: The step aligns with the learner's intended approach.
(2) \textbf{Incorrect}: Errors are identified in the step.
(3) \textbf{Missing}: A required step is absent.
(4) \textbf{Can Be Divided}: The step is complex and can be broken into sub-steps, indicated by dashed borders. Users decide whether to subdivide. This status can coexist with other statuses.
(5) \textbf{System Generated}: Step content is created by the system. This status is triggered only when the learner requests to reveal a (sub)step after repeated failures.
During the ``Check Step Tree'' process, DBox preserves the original step tree (both structure and contents), only adding blank nodes for missing steps, ensuring scaffolding while respecting the learner's thought process.





% \subsubsection{Feature 4: Progressive Hint.}
% We’ve designed a detailed scaffolding process that provides only the necessary guidance, encouraging users to think independently before offering more specific hints as needed. The first level is a hint presented as a question. When users know a step is incorrect or missing but still lack ideas, they can click the C button to receive initial guidance. This guidance does not directly reveal the answer but steers users in the right direction, such as: “Before you convert the string variable to an array, what should you do first?” The second level offers more specific guidance, including more concrete clues, if the user still struggles after the first hint. The third level of guidance is triggered if a user repeatedly fails to correct their thought process for a specific step. This level provides an option to view the AI-suggested correct steps. Although this third level is triggered, it is not displayed by default; users must click the View button to see it. The third-level feedback can appear in two scenarios: (1) If the step has no sub-steps, the tool directly presents the correct description of the step; (2) If the step includes sub-steps, the tool highlights one key sub-step and marks other sub-steps as missing, reminding the user to complete the remaining sub-steps. It is important to note that users can choose not to view any of these three levels of feedback to solve the problem independently.


% We also provide multi-level guidance for users who incorrectly implement or have not yet implemented their thought process, aiming to help them complete their code independently as much as possible. The first level is a simple hint that offers basic guidance, such as: “How should you correctly update variable A?” or “Consider updating the index before the loop ends.” The second level is a pseudocode hint, offering a more specific guide if the user is still unsure after viewing the basic hint. At this point, the user only needs to convert the pseudocode into actual code. The third level of guidance is triggered if the user incorrectly implements a step twice in a row. This level provides an option to view the correct code for that step. Although the third level is triggered, it is not displayed by default; users must click the View button to see it. It’s important to note that users can choose not to view any of these three levels of feedback to independently implement their ideas.

% \subsubsection{Feature 4: Progressive Hint for Idea Formation}

% We have implemented a scaffolding feature that progressively delivers guidance, fostering independent problem-solving while providing specific hints as needed. This feature is structured into three levels. (1) \textbf{Initial Hint (Question-Based)}: This is the first level of assistance where users receive a hint framed as a question, prompting them to think about the next step without giving away the solution. For instance, if a user is uncertain about the initial steps, they might see a hint like, “Before you convert the string variable to an array, what should you do first?” (2) \textbf{Detailed Guidance}: If the user continues to struggle, a second, more specific hint is provided. This could include more direct clues that guide the user closer to the solution but still require them to apply their reasoning. (3) \textbf{Recommendation for A (Sub)Step}: Triggered by repeated difficulties in correcting a specific step, this level offers the option to view the AI-suggested correct steps. For steps without sub-steps, it directly presents the correct description. For steps that include sub-steps, it highlights one key sub-step and marks the remaining as missing, prompting users to complete them. This level is optional and can be accessed by clicking a ``Reveal Step'' button, allowing users to decide whether to see the full solution or continue working independently. These layers of hints are designed to support users in building their problem-solving skills gradually while enabling them to maintain control over their learning process.

\subsubsection{Progressive Hints for Solution Formation (D1)}

DBox provides progressive hints to scaffold learners' problem-solving in three levels: (1) \textbf{General Hint} (Question-Based): Prompts learners' critical thinking without revealing solutions, e.g., ``Before converting the string to an array, what should you do first?'' (2) \textbf{Detailed Hint}: Offers more specific clues while requiring reasoning, e.g., ``Think about how you can traverse each character in the string.'' (3) \textbf{Reveal (Sub)Step} ((Sub)Step Recommendation): For repeated errors, the AI can suggest a substep within a larger step when users click the ``Reveal (Sub)Step'' button. This reveals one key substep while leaving the remaining steps for the learner to complete. Notably, students can choose not to trigger this hint. These progressive hints support problem-solving development while allowing learners to maintain independence and control.

Once the step tree is complete and all nodes are correct, learners proceed to the solution implementation stage.


% \subsection{Stage 2: Idea Implementation} After constructing a complete and correct step tree, users advance to the idea implementation stage.

% \subsubsection{Feature 5: Converting the Step Tree into Comments} This feature transforms each node of the step tree into code comments. By clicking ``Copy to Comments", these comments are pasted directly into the corresponding section of the editor, guiding students to systematically complete their code implementation.

% \subsubsection{Feature 6: Validating Code Implementation against the Step Tree} The tool evaluates the alignment between the user’s code and the problem-solving approach defined in the step tree. Using the ``Check Match'' button, the step tree's status updates to reflect: (1) \textbf{Implemented}: The code accurately implements the described step. (2) \textbf{Incorrectly Implemented}: There is an error in how the step is coded.
% (3) \textbf{To be Coded}: The step has yet to be coded. Highlighting in the editor indicates the correlation of code lines with the step tree, showing whether each step is correctly or incorrectly matched.

% \subsubsection{Feature 7: Progressive Hint for Idea Implementation.} Additionally, for users who have incorrectly implemented or have yet to implement their thought process, multi-level guidance is available. (1) \textbf{Basic Hint}: Offers straightforward suggestions to nudge the user in the right direction, like “How should you correctly update variable A?” or “Consider updating the index before the loop ends.” (2) \textbf{Pseudocode Hint}: If the user remains unsure after the basic hint, this level provides a pseudocode hint, clarifying what needs to be done, which the user then translates into actual code. (3) \textbf{Recommended Implementation}: This is activated if a user misimplements a step twice consecutively. It allows them to view the recommended code for that step by clicking a ``View'' button, although, like the previous levels, viewing is optional.

% Note that DBox does not teach specific algorithm concepts or knowledge, as our target users are learners who have a basic understanding of algorithms but want to improve their ability to apply algorithms to solve real-world problems.


\subsection{Stage 2: Solution Implementation}

\subsubsection{Converting the Step Tree into Comments (D3)} This feature converts each node of the step tree into code comments. When students click ``Copy to Comments'', the system intelligently inserts these comments into the appropriate sections of the code editor. This guides learners to implement their solutions within the corresponding parts of their code, ensuring a smooth transition from planning to coding while reinforcing their structured approach.

\subsubsection{Validating Code Implementation against the Step Tree (D3, D4)} The ``Check Match'' button evaluates the alignment between the code and the step tree. Steps are categorized and color-coded as: (1) \textbf{Implemented}, (2) \textbf{Incorrectly Implemented}, and (3) \textbf{To Be Coded}. Hovering over a step highlights the corresponding lines in the code, providing a direct mapping between the step tree and the code to help users efficiently debug their implementation.


\begin{figure*}[htbp]
	\centering 
	\includegraphics[width=\linewidth]{figures/processing_new.pdf}
	\caption{An illustration of DBox's data processing workflow highlights its core function—creating a step tree with node statuses from student inputs. The LLM processes learners' incomplete code or a step tree they’ve constructed. It outputs a structured JSON object containing steps, sub-steps (and sub-sub-steps, etc.), each with several attributes. Then the JSON object is rendered to the interface, preserving the original structure and only adding nodes for any missing steps. Each node keeps the student's original input, without directly revealing the correct solution. DBox encodes the status of each step with colors and provides progressive hints.}
 
	\label{fig:processing}
        \Description{}
\end{figure*}

\subsubsection{Progressive Hints for Solution Implementation (D1)}
For steps that are incorrectly implemented or yet to be coded, multi-level hints are available: (1) \textbf{General Hint}: Shows simple thought-provoking prompts/suggestions, e.g., ``How should you correctly iterate until the second last character?'' (2) \textbf{Detailed Hint} (Pseudocode): Provides simplified pseudocode to guide the user. (3) \textbf{Reveal Code} (Recommended Implementation): This option is activated only after two failed attempts. Clicking the ``Reveal Code'' button displays the recommended code implementation for the specific step.




\subsection{Backend Design}
DBox's backend is primarily powered by Large Language Models (the GPT-4o model specifically), with four distinct interactions corresponding to four buttons in the interface:
\begin{itemize}
    \item \textbf{From Editor to Step Tree}: This button sends the problem description and the user’s code to the LLM, which generates a step tree with nodes labeled as correct, incorrect, missing, or divisible.
    \item \textbf{Check Step Tree}: Clicking this button inputs the problem description and the user-constructed step tree into the LLM, which returns a labeled step tree with node statuses such as correct, incorrect, missing, or divisible.
    \item \textbf{Copy to Comments}: This button sends the problem description, current step tree, and user’s code to the LLM, generating a mapping of step tree nodes to corresponding lines of code.
    \item \textbf{Check Match}: Pressing this button sends the problem description, step tree, and user’s code to the LLM, which outputs a tree categorizing nodes as implemented, incorrectly implemented, or to be coded.
\end{itemize}

% To further illustrate, we present the data processing workflow behind two core functions: ``From Editor to Step Tree'' and ``Check Step Tree.'' Figure \ref{fig:processing} shows the workflow, where DBox processes student inputs in two modes: code or a constructed step tree. The LLM adapts based on the input. If only code is provided, it generates steps and substeps for the step tree, evaluates node status, and provides hints. If the student supplies a step tree, the LLM assesses the status of each node without altering the structure, only adding steps where needed. The LLM outputs a structured JSON format that organizes steps, substeps, and subdivisions. Each node includes the student’s input, its status (correctness, completeness, potential for subdivision), a general hint, a detailed hint, and the correct content. The step tree is \emph{selectively} displayed on the interface, primarily \emph{retaining the originally student-created structure} while highlighting missing steps. Node statuses are encoded in colors, with corresponding hints accessible through designated buttons.

To illustrate, we present the data processing workflow for two core functions: ``From Editor to Step Tree'' and ``Check Step Tree''. Figure \ref{fig:processing} shows how DBox processes student inputs in two modes: coding mode and language description mode (step tree input). Prompts adapt based on the input type. When only code is provided (\textcolor{darkblue}{dark blue} lines in Figure \ref{fig:processing}), the system first calls \colorbox{darkblue}{\textcolor{white}{[prompt from code]}} to generate a step tree, mapping each code line to a corresponding (sub)step based on the code’s meaning. It then uses the generated step tree to invoke \colorbox{orange}{\textcolor{white}{[prompt from step tree]}} (\textcolor{orange}{orange} lines) to evaluate node statuses, add missing nodes, and generate multi-level hints for incorrect or missing nodes. If the input is a natural language step tree, the LLM directly calls \colorbox{orange}{\textcolor{white}{[prompt from step tree]}} while preserving the original structure. 

The LLM outputs a JSON containing steps, sub-steps, and subdivisions, each with attributes like student original input, status (e.g., correctness, completeness), LLM-validated content, and hints. The JSON is rendered conditionally, preserving the student’s original structure while highlighting missing or incorrect steps. Even if a student's input differs from what the LLM considers correct, the original content is preserved and marked with a status color. Hints are provided and triggered progressively, offering ``just the right'' level of guidance.



\ms{
\subsection{Implementation}
For the front-end, we used native HTML, JavaScript, and jQuery. On the back-end, we deployed the application with the Flask\footnote{https://flask.palletsprojects.com/en/stable/} framework on our university's server. The code editor utilized CodeMirror\footnote{https://codemirror.net/} integrated with pyodide.js\footnote{https://pyodide.org/en/stable/} for running Python code. We employed OpenAI's GPT-4o model with a temperature of 0.8 to maintain flexibility during scaffolding. To align better with the front-end's step tree, we set the response format by setting the parameter response\_format={``type'': ``json\_object''}, restricting the LLM's output. Prompts designed with the chain-of-thought (CoT) technique \cite{wei2022chain} are detailed in the supplementary materials.
}