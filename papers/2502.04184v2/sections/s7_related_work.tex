\vspace{-0.5ex}
\section{Related Work}
\label{related work}

    With the increasing popularity of notebooks \cite{Kluyver2016}, a growing body of research has focused on understanding the unique characteristics of notebooks \cite{Chattopadhyay2020, Rule2018, Rule2018CellFolding, In2024, gigascience2024} and their diverse applications in various fields \cite{Wang2019, Randles2017, Li2021}. Recent works have also proposed potential enhancements to these tools, aiming to improve notebooks' functionality and usability for data scientists and other users \cite{Chattopadhyay2020, Wang2024, McNutt2023, gigascience2024}. Table \ref{related_work_table} summarizes and compares this work with prior investigations. %We also explain the dataset's characteristics in each work to show the underlying reason for varying rates of non-executable notebooks reported.

    \subsection{Empirical Studies on Notebook Executability}
        Pimental et al. \cite{Pimentel2019, Pimentel2021} conducted an analysis of 1.4 million notebooks sourced from GitHub, aiming to examine their nature, quality, and reproducibility. They report notebook quality results, covering various characteristics and insights into notebook execution processes, as well as common issues encountered within these notebooks. Similarly, Wang et al. \cite{Wang2019BetterCode} assesses the quality of code present in notebooks, ultimately concluding that notebooks often exhibit suboptimal coding practices, thus highlighting the importance of enhancing notebook code quality. Both studies only view notebook executability as an atomic measure. In particular, they lack a fine-grained, deeper analysis of a large portion of notebooks that are (1) non-executable only on non-author environments due to misconfiguration, thus fully restorable, and (2) offer reusable, valuable code that is partially executable. 

    

    \subsection{Notebook Restoration and Reproducibility Tools}
        Numerous tools are proposed to restore notebook executability and reproducibility. For instance, RELANCER automatically updates deprecated APIs in non-executable notebooks by gathering APIs from GitHub and documentation \cite{Zhu2021}. Similarly, SnifferDog restores the execution environment by providing a collection of APIs from Python packages and libraries to update required packages in notebooks \cite{Wang2021}. These approaches complement our analysis. However, due to the highly complex and heavyweight nature of these techniques, they are infeasible for large-scale notebook executability analysis. 
        %Their use of machine learning is also likely to apply code rewrite that may change the notebook's semantics. 
        Osiris \cite{Wang2020} restores the reproducibility of only fully executable notebooks that also contain output cells. It addresses cell dependencies and generates possible execution orders, similar to our def-use set-based reordering. Osiris demonstrates that without executable notebooks, reproducibility can not feasibly be restored. Similar to our investigation, a transparent, fine-grained view of the state of notebook executability can facilitate further reproducibility studies or tool development.

    
    \subsection{Notebook Development Assistance Tools}
        Previous research has proposed improving software development practices with extended user interfaces and advanced programming assistant features. Fork It \cite{Weinman2021} is a forking and backtracking extension designed to investigate various alternatives and traverse different states within a single notebook. Similarly, numerous notebook tools \cite{Rule2018CellFolding, Li2024, Zhu2024Facilitating, Wang202Conflict, SuperNOVA} aim to streamline collaborative and exploratory experiments, often incorporating new visualization and conflict resolution for collaborative work in notebooks. To assist in code debugging and cleaning,  Robinson et al. \cite{Robinson2022} examined error identification strategies used for Python notebooks, while Head et al. \cite{Head2019} utilized program slicing to extract relevant code cells producing specific outputs.  
        %The most appealing feature of the notebooks is their simple and interactive execution environment that facilitates rapid experimental programming.       
        Adding new features and complicated user interfaces significantly intervenes with rapid, interactive programming. Most of these tools have seen resistance in adoption by both users and popular notebook platform providers. With the emergence of LLMs, recent work has explored using LLMs in assisting notebook development \cite{McNutt2023, Wang2024, Weber2024Computational, grotov2024untangling}. These results resonate with our findings.  

        
    