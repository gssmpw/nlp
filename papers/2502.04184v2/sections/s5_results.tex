\section{Empirical Results}
The following sections present the empirical findings of the notebook executability analysis.

\input{figures/total_star_vs_count} % Figure 5

    \noindent{\textbf{Dataset.}} We focus on two criteria to collect notebooks to investigate our research questions. First, the notebooks should be popular, actively shared, and reused. Second, the notebooks should be the most recent version at the time of the notebook dataset collection, as the computational notebook ecosystem has changed in the last few years with the advent of AI and new notebook tooling. We exclude irrelevant files that are either unreadable, written in non-Python languages, or authored in Python 2, which has been deprecated since 2020. Based on this, we use GitHub API to search for Jupyter notebooks with parameters, including language and star range. 
    %For example, language = “Jupyter Notebook” and stars = “500..999” will retrieve Jupyter notebooks that have 500 to 999 stars.
    GitHub stars are commonly used to indicate popularity \cite{Borges2016}.  We then take a stratified sample of up to 1000 repositories based on GitHub star "tiers" (e.g., $\geq$1000, 500-999, 300-499, and so on) with logarithmic tier sizes to balance the repository count per tier due to long-tailed distribution of repositories against stars. This leads to approximately 318,000 notebooks. Due to prohibitive compute costs from LLMs, we take a 13\%  sample of total notebooks,  resulting in \totalNotebooksInDataset notebooks from \totalRepos repositories.    Figure \ref{fig:notebook_count_vs_star} shows the distribution of sampled notebooks based on stars.



    
    %    By including different ranges, we aim to obtain a representative sample of notebooks. Another reason to focus on popularity repositories is that they are actively maintained and frequently utilized by a diverse range of users, ensuring the relevance of our analysis \tien{Again, we should be careful with this claim if the reviewers don't agree as some repositories are a few years old}.
    %Leveraging notebooks from these repositories enables us to effectively filter out obsolete, poor-quality, and unmanaged notebooks, thereby enhancing the quality of our dataset. Note that our primary focus is analyzing notebooks with a specified Python 3 kernel. Consequently, 

    
 %   \tien{Maybe move this up a little to indicate that we applied these filters to get the total notebook number that we show}. 
    
%For each notebook, we clone the entire repositories, including documentation and data files, to make the best effort to recreate the execution environment of the original authors of the notebook \tien{It may not make sense much here. We cloned all repos first then applied filters to collect valid notebooks' info, i.e., their paths relative to the program but still kept them in their repos}.  


% \tienWe leverage the GitHub search engine to inquire about public repositories with Jupyter Notebook as their dominant programming language. We also include star ranges in descending order as a search criteria for more specific results.     
    
    
%We gather a corpus comprising \totalNotebooksInDataset notebooks sourced from two distinct datasets. The first dataset encompasses \totalNotebooksFromGitHub notebooks, which is a 5\% random sample of all notebooks with 10+ GitHub stars. These repositories are actively maintained and frequently utilized by a diverse range of users, ensuring the relevance of our analysis. Leveraging notebooks from these repositories enables us to effectively filter out obsolete, poor-quality, and unmanaged notebooks, thereby enhancing the quality of our dataset.
%Additionally, we have incorporated approximately 5\% random sample dataset utilized in previous studies conducted by Pimentel et al. \cite{Pimentel2019, Pimentel2021}, comprising \totalNotebooksFromDrive notebooks. We pick a 5\% sample from this dataset for two reasons. First, the original data contains approximately \totalALLNotebooksFromDrive notebooks, including many low-quality, incomplete ones. Second, the entire dataset is inaccessible due to Google Drive limits, and GitHub has recently imposed rate limits on the automated crawling of the GitHub repository. By combining these two datasets, we aim to obtain a more representative sample of notebooks. Note that our primary focus is analyzing notebooks with a specified Python 3 kernel. Consequently, we exclude any irrelevant files that are either unreadable, written in non-Python languages, or authored in Python 2, as it has not been supported since 2020. For the feasibility and scalability of this study, we also set an execution timeout of 5 minutes—any notebook executing beyond 5 minutes is excluded from the dataset. For example, experimental notebooks that demonstrate an infinite loop are omitted using timeouts. 

% \subsection{}
\noindent{\textbf{Analysis Environment.}} We establish a separate virtual environment for each repository. Sandboxing the execution environments eliminates the risk of mismatched versions of Python modules, side effects from executing the notebooks, and conflicts stemming from shared dependencies. We use Python version 3 as the execution kernel. Before analyzing a notebook, we locate the requirements file (if available) listing necessary modules or packages and install them in the execution environment (in \ding{202} of Figure \ref{fig:main_workflow}). 
For the feasibility and scalability of this study, we also set an execution timeout of 5 minutes.
%—any notebook executing beyond 5 minutes is excluded from the dataset. 
%For example, experimental notebooks that demonstrate an infinite loop are omitted using timeouts. We employ a cluster of six NVIDIA DGX A100 \cite{NVIDIADG22:online} nodes, each with 2048 GB of memory and a minimum of 128 cores, to conduct our analysis. 
We use a state-of-the-art open-source LLM called Llama-3 \cite{llama3, touvron2023llama}.% for LLM-based synthetic data generation. 
    
    
%\waris{Based on the approach section in addition to input generation we also used LLM for error analysis. We should make it generic or write all the use cases of LLM in our analysis.}

    
% We establish a distinct virtual environment for each notebook, ensuring that the analysis is conducted under identical conditions. Within these environments, we use Python version 3.12.3 as the execution kernel, providing a standardized framework for execution. By employing consistent environments, we mitigate the risk of conflicts or discrepancies stemming from shared dependencies or variations in environmental settings. Furthermore, to enhance efficiency and prevent potential issues such as infinite loops, we impose a time limit of 5 minutes for each notebook's execution. We employed an enterprise-level cluster consisting of six NVIDIA DGX A100 \cite{NVIDIADG22:online} nodes to conduct our analysis. Each node has 2048 GB of memory and a minimum of 128 cores. Additionally, every node includes an A100 GPU, which boasts 80 GB of memory. This configuration provided a robust platform for our computational tasks.
% We use a state-of-the-art open-source LLM called Llama-3 \cite{llama3, touvron2023llama} for LLM-based synthetic input generation.
  
%  \gulzar{Waris: write detail spec of the server} that is equipped with GPU. For LLM-based synthetic input generation, we use state-of-the-art open-source LLM called \gulzar{LLM name and write details of that.}.

\subsection{RQ1: Causes of Non-Executability}

        \begin{table}[t]
    	\centering
    	\caption{Top 10 Common Errors in Notebooks.}
        \begin{tabular}{|m{3cm}|>{\centering\arraybackslash}m{1.3cm}|>{\centering\arraybackslash}m{1.6cm}|>{\centering\arraybackslash}m{1cm}|}
    		\toprule
    		\textbf{Error Type}       & \textbf{\# of \hspace{10pt}Notebooks}  & \textbf{\% w.r.t Non-Executable}                    & \textbf{\% w.r.t Dataset}              \\
    		\midrule
    		ModuleNotFound Error      & \totalModuleNotFound            & \percentModuleNotFoundInNonExecutable      & \percentModuleNotFoundInTotal \\ 
    		FileNotFound Error        & \totalFileNotFound              & \percentFileNotFoundInNonExecutable        & \percentFileNotFoundInTotal   \\ 
    		AttributeError            & \totalAttributeError            & \percentAttributeErrorInNonExecutable      & \percentAttributeErrorInTotal \\ 
    		ImportError               & \totalImportError               & \percentImportErrorInNonExecutable         & \percentImportErrorInTotal    \\ 
    		ValueError                & \totalValueError                & \percentValueErrorInNonExecutable          & \percentValueErrorInTotal     \\
            TypeError                 & \totalTypeError & \percentTypeErrorInNonExecutable          & \percentTypeErrorInTotal \\
            KeyError                  & \totalKeyError                  & \percentKeyErrorInNonExecutable            & \percentKeyErrorInTotal       \\
            StdinNotImplementedError  & \totalUserInputs                & \percentUserInputsInNonExecutable          & \percentUserInputsInTotal     \\
            IndexError                & \totalIndexError                & \percentIndexErrorInNonExecutable          & \percentIndexErrorInTotal    \\ 
            NameError                 & \totalNameError                 & \percentNameErrorInNonExecutable           & \percentNameErrorInTotal      \\
    	   \bottomrule
	   \end{tabular}
	\label{common_errors}
 % \vspace{-3ex}
\end{table}

    Our first goal is to identify the non-executable notebooks and the reason behind their non-executability. %While prior work \cite{Pimentel2019, Pimentel2021, gigascience2024, Zhu2021, Wang2021}, have performed similar investigations, they either use skewed notebook corpus, use highly strict execution criteria, or fail to follow the requirement/install instructions \tien{these work did similar investigations, but they did look into requirement files. Yes, they use binary executability notion and don't apply star range on the dataset}. 
    We first set up the execution environment by incorporating the installation instructions in the parent repository. This attempt at executing the notebooks results in \totalExecutable (\percentExecutable) executable notebooks, and \totalNonExecutable (\percentNonExecutable) non-executable notebooks. %This finding is consistent with the prior work \cite{Pimentel2019} that less than 25\% are fully executable. 
    There are two reasons why non-executability is still more than previously reported 76\% \cite{Pimentel2019}. First, repositories often do not provide complete and detailed requirements files. 
    %Pimentel \cite{Pimentel2019} mentioned that only 13.72\% of their dataset had required information.
    Later, we show that even after following the requirements file, we still encounter environment misconfiguration errors in nearly \percentModuleNotFoundInTotal of the notebooks.
    %Prior work \cite{Pimentel2019} work shows that about 65\% failed to install. 
    Second, prior work studied a dataset of notebooks containing a vast amount of obsolete, simple, and unmanaged notebooks; these are experimental notebooks used for dabbling with notebook environments. Such notebooks may not depend on external packages and libraries, which lowers the overall non-executability. Low popularity notebooks tend to be less dependent on external packages and libraries and are often shorter, reducing the chances of ``FileNotFound" and ``ModuleNotFound" errors but exhibiting higher ``NameError" rates, as shown in \cite{Pimentel2019}. We hypothesize that the executability of the low-quality notebooks will be lower once environment configuration errors are addressed. %Therefore, if methods from prior studies are followed, the non-executability would be much higher than recorded by our analysis. %\gulzar{do we have several notebooks that benefit from requirements files?} \tien{No, but we may be able to extract how many repos have requirement files (approximately, because they may be named something customized to their project, but not high)}

     
     Next, we investigate and categorize why \percentNonExecutable notebooks cannot execute and find the top reasons that hinder their execution. Table \ref{common_errors} presents the top 10 issues encountered in the notebooks. Among them, ModuleNotFound and FileNotFound errors are the most frequent, making up \percentModuleNotFoundInTotal and \percentFileNotFoundInTotal of the entire dataset, respectively. Other common exceptions include ``AttributeError" (\percentAttributeErrorInTotal), ``ValueError" (\percentValueErrorInTotal), ``TypeError" (\percentTypeErrorInTotal), and ``StdinNotImplementedError" (\percentUserInputsInTotal).
    %, which also appears among the most frequent errors encountered during notebook execution.
    
    % \gulzar{Tien: write about all other errors and tell which errors are non-restorable and which are not. And why we are only talking about 4?}
    
    % \gulzar{We need a detailed comparison for each of the following error types with the error numbers in prior work vs ours; if different, should we highlight and justify?}

    \subsubsection{Execution Environment}
        In our analysis, \totalModuleNotFound notebooks encountered ``ModuleNotFound" errors during execution when executed in a fresh environment. This accounts for \percentModuleNotFoundInNonExecutable of the total non-executable notebooks. These errors arise when the required modules or packages are not available in the package manager (e.g., {\small{\texttt {pip}}}) or cannot be located within the execution environment in the case of custom packages and libraries. Such mismatches highlight the importance of ensuring compatibility and consistency across execution environments to facilitate seamless notebook execution across different computing setups. Prior work \cite{Pimentel2019} reports that 20.7\% of notebooks failed due to ``ImportError," whereas our analysis finds that only \percentIndexErrorInTotal of notebooks in our dataset encounter this exception. ImportError can occur for various reasons, such as issues within the module or missing dependencies, while the ``ModuleNotFound" error specifically occurs when Python cannot locate the module at all. Introduced in Python 3.6, the ``ModuleNotFound" error clarifies this distinction, making it easier for developers to handle missing modules.

    \subsubsection{External Input Data}
        %In scenarios where notebooks use external input files, these files are typically local to the developers' machines, unless provided alongside the notebooks. When executing notebooks that depend on such input files, users may encounter ``FileNotFound" errors if the necessary input files are missing. 
        We find \percentFileNotFoundInNonExecutable of the total non-executable notebooks affected by the ``FileNotFound" error. Additionally, when the notebook requires user-typed inputs, notebook execution will raise a ``StdinNotImplementedError." We do not attempt to restore the executability of those notebooks, as they necessitate dynamic interactions, which are not feasible in an automated execution environment. We detect a total of \percentUserInputsInNonExecutable initially non-executable notebooks that required user inputs during their execution. 
        
        %We further compare our findings with what is reported in prior work \cite{Pimentel2019}.  %\tien{Prior work shows that approximately 1\% of notebooks encounter \textit{StdinNotImplementedError}, which aligns with our finding. Similarly, \textit{FileNotFoundError} affects \percentFileNotFoundInTotal of the notebooks in our dataset, closely matching the 8.5\% reported by \cite{Pimentel2019}.} 

        % \input{figures/FileNotFound_vs_Stars}
        
    \subsubsection{Missing/Disordered Variable Definitions}

        \input{figures/NameError_vs_Stars_Percent_Table} % Table 2
        
        ``NameError" in a notebook can arise due to the use of a variable, library, function, or class name that was not previously defined. Among the \totalNonExecutable notebooks that are non-executable, we identify \totalNameError notebooks containing at least one instance of this error, accounting for \percentNameErrorInNonExecutable (\percentNameErrorInTotal of total), as shown in Table \ref{common_errors}. We further investigate these notebooks to explore the relationship between GitHub stars and ``NameError" occurrences. Table \ref{tab:nameerror_star_range} shows the normalized number of notebooks affected by ``NameError" in different star ranges. Our findings indicate that ``NameError" is less prevalent in more popular notebooks, with its occurrence decreasing as the star increases. While ``NameError" affects only a small portion of our dataset, prior work \cite{Pimentel2019} ranks it among the top two errors, reporting it in 14.53\% of notebooks. We observe that ``NameError" is predominantly found in low popularity notebooks, which are less actively reused and frequently maintained, allowing such errors to persist. This provides concrete evidence that ``NameError" tends to exist in less frequently used notebooks. Therefore, a higher ``NameError" rate reported in \cite{Pimentel2019} suggests that {\em the dataset of notebooks studied in earlier work includes a significant number of low-popularity and rarely managed and reused notebooks.} For example, the notebook \cite{JadFatTail}, with only four stars, resembles a trial notebook that defines numerous functions without any documentation, ultimately leading to an undefined function error.
        
          
    
    \subsubsection{Experimentation Notebooks}
        Notebooks are often used as programming playgrounds, and users who are new to programming often use them to dabble with programming. Notebooks resulting from such exercises are not managed and not expected to be shared and, thus, by definition, are incomplete. Similar to these notebooks, we find that \percentTimeout of notebooks in our dataset contains an infinite while loop to demonstrate concepts such as infinite loops, large-scale training campaigns, or I/O operations over the network. Executing such notebooks may result in ``TimeoutError" issues. Notebooks with ``TimeoutErrors" are not analyzable; thus, we exclude those from Table \ref{common_errors}. %\tien{What can we say more about this part? How does it relate to the table \ref{common_errors}}


\begin{tcolorbox}[left=0mm, right=0mm, top=0mm, bottom=0mm]
\textbf{Takeaway RQ1.} Our analysis shows that the primary causes of non-executable notebooks are missing dependencies and external data. High-quality notebooks have fewer fundamental errors like ``NameError," indicating better code maintenance and frequent usage. %This emphasizes the importance of providing complete requirement files and necessary resources to improve notebook executability.
\end{tcolorbox}

        

\subsection{RQ2: Pathological Non-Executability} 
\begin{figure}[t!] % Figure 6
	\centerline{\includegraphics[width=\columnwidth]{images/sankeymatic.png}}
	\caption{Summary of our investigation results. This shows different notions of executability in computational notebooks.}
	\label{fig:overall_results}
 % \vspace{-3ex}
\end{figure}
 
Resolving errors like compilation errors, syntax errors, indentation errors, and runtime errors like ``OSError'' and ``HTTPError'' require significant code refactoring to align with the intended semantics. Without the knowledge of such semantics, the executability of such notebooks cannot be correctly restored. Notebooks requiring extensive intervention to restore executability are categorized as {\em pathologically non-executable}. Notebooks with errors that can be resolved by configuring the execution environment are classified as non-executable but {\em restorable}. For instance, as in Case Study 1, a missing input data file may trigger a runtime error, rendering the notebook non-executable. However, providing the correct execution environment and data file enables the notebook to run successfully without altering its semantics. 


We identify \percentExecutable (\totalExecutable\hspace{1pt}/ \totalNotebooksInDataset) notebooks initially executable, indicating end-to-end execution without errors. Among the rest, shown in Figure \ref{fig:overall_results}, we find \totalPathological (\percentPathological) pathologically non-executable notebooks, distinguished by errors that significantly impede their execution and require additional specification about the intended goal of the notebook to recover. \totalRestorable (\percentRestorableInNonExecutable) non-executable notebooks fall into the restorable category, suggesting errors that could be remedied through appropriate restoration strategies. 

\begin{tcolorbox} [left=0mm, right=0mm, top=0mm, bottom=0mm]
    \textbf{Takeaway RQ2.} Surprisingly, only \percentPathological of all notebooks are pathologically non-executable; the rest are either executable or potentially executable given a suitable execution environment. This validates our hypothesis that pathologically non-executable notebooks are significantly lower than previously found. 
\end{tcolorbox}

\subsection{RQ3: Degree of Executability of Pathologically Non-executable Notebooks}

\input{figures/pathological} % Figure 7

Notebooks are developed and executed incrementally and interactively, unlike traditional software, which is built and run atomically. Even if a notebook is pathologically non-executable as a whole, it may still contain valuable code snippets that are executable. This introduces a fine-grained notion of executability, where errors may occur only in cells toward the later stages of the notebook. Our position is that these executable cells provide valuable code fragments that can be used for dynamic analysis and supporting tasks such as code reuse, comprehension, repair, and model training. With this new, fine-grained executability, we measure the number of cells a pathologically non-executable notebook successfully executes. We then divide this number by the total number of cells in the notebooks to measure the degree of executability (partial execution) in pathologically non-executable notebooks. 


Our analysis reveals that, on average, \averagePercentPartialPathological of the cells in pathologically non-executable notebooks are executable. For example, although the notebook \cite{jarodHAN} encounters ``ValueError" during linear execution, it is still partially executable up to 10 cells or in 76.9\% of total cells. Figure \ref{fig:path-non-exec-results} shows the frequency of pathologically non-executable notebooks with different levels of partial executability. The Y-axis represents the number of notebooks, and the X-axis represents the percentage of cells successfully executed in those notebooks. For instance, we observe that nearly \percentPathologicalOverFiftyPercent of the pathologically non-executable notebooks (\totalPathologicalOverFiftyPercent) successfully execute more than half of the cells ($>$50\%). On the other hand, \totalPathologicalZeroPercent (\percentPathologicalZeroPercent) notebooks have 0\% partial executability due to the pathological error in the first cell. Partial execution in nearly three-quarters of pathological non-executable notebooks demonstrates that even non-executable notebooks can be partially adopted, and dynamic analysis techniques can be applied to improve their executability and reproducibility further.


\begin{tcolorbox} [left=0mm, right=0mm, top=0mm, bottom=0mm]
    % \textbf{Takeaway:} Even pathologically non-executable notebooks often contain a significant portion of executable cells. Our analysis shows that, on average, \averagePercentPartialPathological of the cells in these notebooks are executable, with nearly \percentPathologicalOverFiftyPercent of them successfully executing more than half of their cells. This demonstrates that partially executable notebooks hold valuable code fragments but prior work strictly categorizes these notebooks as non-executable.  

    \textbf{Takeaway RQ3.} Even pathologically non-executable notebooks contain, on average, \averagePercentPartialPathological executable cells. 
    %, with nearly \percentPathologicalOverFiftyPercent of them successfully executing more than half of their cells. 
    This demonstrates that partially executable notebooks hold valuable code fragments for downstream restoration steps.
\end{tcolorbox}



%\waris{This is a good result. Do not directly state the result. First, write about the figure (e.g., what is the X-axis and what is the Y-axis). Next, explain 1-2 results (bars) from the figure. For instance, the bar with the x-axis 20-30 shows 829 notebooks are executable with between 20 to 30 cells in them. 

%If priors studies do not execute these notebooks then state it alongside why our approach is executing these notebooks. 
	%After explaining the results, write a concluding takeaway stating that we found 34\% of cells in X number of non-executable notebooks are executable suggesting that even such notebooks are partially restorable and can be utilized by the developers (e.g., data analysts, etc)}




% \gulzar{We should keep it but tone it down a little bit}
        
% \tien{Mention the NameError results here}

% \waris{We should merge RQ3 and RQ4 because both of these types represent 2nd type of non-executablity. Next, we can discuss each of these in separate subsubsection. Similar to RQ2 the title of the new section should represent the 2nd type of non-executability category.}
        
          
%Among the \totalUndefinedVarsDetected notebooks rendered non-executable due to undefined variables, \totalUndefinedAnywhere contain at least one undefined variable that remains undefined both before and after the respective cell. Conversely, the remaining \totalDefinedAfter notebooks feature defined-after-use variables. In such cases, we employ a def-use cell reordering strategy to correct the cell sequence and resolve the issue of undefined variables. Post cell reordering, we execute the newly arranged notebook alongside other restoration techniques, comparing the results with those obtained from the original notebook execution. 
        
%Among the \totalDefinedAfter notebooks featuring define-after-use variables, \totalDefinedAfterRestored exhibit improved execution outcomes compared to their original executions. This strategy leads to an enhancement of \averagePercentIncreaseAfterReordering in the number of executable cells while fully restoring the executability of \percentNotebooksFullyRestoredDefinedAfterReordering of the notebooks. However, \totalDefinedAfterNotRestored notebooks fail to produce better outcomes as they still contain the wrong cell execution order resulting from the movement of the definition cell preceding the usage cell. Figure  \ref{fig:reorder-results} shows the frequency of notebooks that achieve different levels of improvements in executability. 

\subsection{RQ4: LLM-Based Error-Driven Restoration}
\label{sec:results}
    %\edit{. Leveraging these capabilities, we envision that LLMs can also assist in restoring the executability of notebooks by addressing errors that prevent their successful execution. To this end, we leverage LLMs to analyze the code snippets in non-executable notebooks and identify the root causes of their non-executability.}
    
    After executing notebooks (Section \ref{dynamic-error-checking}), we categorize \totalNonExecutable non-executable into two main categories: \totalPathological pathologically non-executable notebooks and \totalRestorable restorable notebooks (see Figure \ref{fig:overall_results}). They account for \percentPathological and \percentRestorableInNonExecutable of total non-executable notebooks, respectively.
    %We call a notebook restorable when it is expected to execute fully in the original author's environment but fails to execute in others, typically due to a misconfigured environment, missing input data, or incorrect execution order.    
    This section analyzes the executability of restorable notebooks when restored using lightweight LLM-based error-driven strategies.

    \subsubsection{Addressing ModuleNotFound}   
        Our study reveals that \totalModuleNotFound notebooks encountered ``ModuleNotFound" errors out of \totalRestorable notebooks, accounting for \percentModuleNotFoundInRestorable of the restorable notebooks. We use an error-driven, code-aware prompt to request LLM to infer the missing module name, and then we package the missing model name to install the correct environment for each notebook. During this restoration process, we discover that \totalInvalidModuleNotFound (\percentInvalidModuleNotFoundInAllModuleNotFound) encounter ``ModuleNotFound" errors due to deprecated modules, libraries, and packages \cite{Wang2021, Zhu2021}, changes in installation procedures, or missing custom packages. Old versions of certain packages are sometimes removed from {\small{\texttt{pip}}} repositories due to security vulnerabilities, licensing issues, or to encourage the use of newer, stable releases. This removal makes these versions unavailable, preventing us from resolving dependencies. 
        
        Among the restorable notebook that imports a valid public module, we successfully installed the required modules into the execution environment for \totalModuleNotFoundRestored (resulting in \percentModuleNotFoundRestored success rate), while \totalModuleNotFoundNotRestored failed to do so. Module installation failures occur because only \percentRequirementInTotal of notebooks include an environment requirement file, leading to potential dependency conflicts due to unspecified module versions. For the notebooks where modules were successfully installed, the overall notebook executability increased by \averagePercentModuleNotFoundRestoredIncrease, on average. This improvement underscores the importance of adapting to changes in module availability and installation processes to enhance the executability of notebooks.
    
        Figure \ref{fig:module-found-results} shows the number of notebooks and the corresponding improvements in executability after applying this strategy. The Y-axis represents the number of restored notebooks, and the X-axis represents the increase in executable cells. The figure shows that 500 notebooks have $>$90\% improvements in executability. For example, the notebook \cite{Visualize-ML} initially encounters a ``ModuleNotFound" error due to the absence of {\small{\texttt{networkx}}} module in the environment at cell 1. The environment requirement information is not provided in the repository. This approach restores the full executability of that notebook.


    \subsubsection{Addressing FileNotFound} 

        \input{figures/module_not_found} % Figure 8
        \input{figures/executable_star_vs_count} % Figure 9 and Figure 10
        Most of the notebooks rely on input data files, which, in most cases, are not packaged with the notebook due to privacy concerns about the data or size. We find that \totalFileNotFound popular notebooks encounter ``FileNotFound" errors, accounting for \percentFileNotFoundInRestorable of non-executable but restorable notebooks. To restore the executability of such notebooks or reveal other execution errors, we use LLM to generate synthetic data for the missing input files automatically.
        As mentioned in Section \ref{sec:approach}, we do not expect synthetic data to reproduce the notebook results. Instead, it can help validate the dynamic behavior of a notebook in order to understand and analyze it better. 
        %This can potentially increase the chances of fully reproducing the intended behavior of the notebook. For instance, program repair techniques, including GenProg~\cite{genprog}, assume code executability - a requirement synthetic data can help achieve in notebooks. Thus, a notebook's executable portion offers more repairs and comprehension opportunities than non-executable ones.} \question{Should this part be here? More above? Or in Discussion?}
        %Our insight is that LLMs can generate synthetic data, similar to how they generate data for training newer, smaller LLMs \cite{}. We aim to leverage LLMs to generate the exact synthetic data required by a given notebook facing a file not found error.
        %This task is challenging as it requires the LLM to understand the code, infer the data type, and generate the appropriate data. This is the initial work to utilize  LLMs capabilities to generate complex structured data inputs for resolving notebook file not found errors.} 
        
        Among the notebooks with ``FileNotFound" errors, we successfully generate input files via LLMs for \totalSuccessfulToGenerateFiles (\percentSuccessfulToGenerateFiles) notebooks. The generated inputs are then placed in a directory structure mentioned in the notebook automatically, and the notebook is executed again. In \totalSuccessfulToGenerateFiles notebooks that were rerun with the synthetic input files, the executability of \totalFileNotFoundRestored (\percentFileNotFoundRestoredInSuccessfullyGenerated) notebooks are fully or partially restored.
        
        Our dataset of notebooks performs a wide range of tasks (statistics, ML, AI, and data analysis) across a wide range of domains, which leads to a large variety of input files being processed by these notebooks. Figure \ref{fig:cs1-full-exec} shows a real-world scenario where a notebook is fully restored after generating synthetic input file {\small{\texttt{Social\_Network\_Ads.csv}}}. The complexity of the content of this file (\eg textual data as column names, numerical data as column values, precision in generating binary labels for the {\small{\texttt{Target}}} column, and avoiding alphabetic words in numerical columns) is shown in Figure \ref{fig:LLM-prompts}. Thus, \percentFileNotFoundRestoredInSuccessfullyGenerated increase in notebook execution with synthetic input files is significant and a promising direction to improve notebook executability (Section \ref{sec:discussion}). 
        

  % \input{figures/file_not_found}

        
%\waris{we should write that even restoring 553 notebooks is quite a good and promising direction to further explore and improve the notebook executability. We can refer to the discussion section here where we discussed how we can enhance the use of LLMs in notebook restoration. Also, refer to the figure here from the motivation where LLM generated data we were able to execute it. Write that that previously without LLM it may require manual effort to inspect the whole program and then either find such data on the internet or manually generate dummy data ...}
    
%\sout{While LLM excels at generating synthetic text, it faces limitations when it comes to generating data for file types such as images, zip files, or files without specified extensions.}
%\waris{Give reason here. Why LLMs e.g., llama cannot work here? Because they are trained on the textual and tabular data. Their tokenizer cannot tokenize the image pixels and thus LLMs like Llama will fail to generate the data for image and audio video files. Mention that we discuss it more in the discussion section.  We will discuss multi-modal LLMs which can interpret both textual and image data. }
%\sout{In scenarios requiring files in common formats like {\texttt .json}, {\texttt .csv}, or {\texttt .txt}, LLM can efficiently generate content based on the provided source code and file path as prompts to the LLM engine. \gulzar{Waris: Same here}}
%\waris{Explain the reason. It is similar to the above. It is because during training these LLMs have seen similar training data \ie contains .csv files which can be tokenized and fed to LLM.}


% In scenarios requiring input files in formats like {\tt .json}, {\tt .csv}, or {\tt .txt}, LLMs can efficiently generate content
% %based on the provided source code and file path as prompts. 
% This is because these LLMs have been trained on similar data formats, allowing them to tokenize and process such data effectively. However, LLMs like Llama-3 face limitations when generating data for file types such as images, audio, or zip files, as they are trained on textual and tabular data.
% %and cannot process image pixels, audio frequencies, and video frames. 
% This limitation is discussed further in the discussion section, where we highlight the potential of multimodal LLMs to enhance notebook executability to generate data for image, audio, or video files.



    Figure \ref{fig:llm-input-results} shows the enhancement in executability achieved in non-executable notebooks with LLM-based input generation. The X-axis represents the percentage of the increase of successfully executed cells. The Y-axis is the corresponding number of notebooks restored. For instance, 51 notebooks see more than 90\% increase in executability, whereas \totalFileNotFoundLessFivePercent show less than 5\%. Among notebooks for which we were able to generate the synthetic input files, we partially restore \percentFileNotFoundPartiallyRestoredInSuccessfullyGenerated of the notebooks and fully recover \percentFileNotFoundFullyRestoredInSuccessfullyGenerated of them using the LLM-based input generation. On average, we observe an incremental improvement of \avgIncreaseAfterFileFixed in the number of executable cells in a notebook after employing the LLM-based restoration.

        
\subsubsection{Addressing NameError}
   %NameError is one of the most common exceptions encountered during notebook execution \cite{Pimentel2019}. Our investigation shows that \totalNameError notebooks encounter this error during our dynamic analysis, comprising \percentNameErrorInRestorable of restorable notebooks. 
   We find only \totalNameError notebook encountering ``NameError," among which only \totalDefinedAfter had define-after-use issues. Using LLM to address this issue in a few notebooks will not offer statistically significant insights. Instead, we use LLM to assist in generating proper definitions for the undefined variables or names. Among \totalNameError, we enhance the executability of \totalNameErrorFixed notebooks (\percentNameErrorFixedInAllNameErrors) by applying this approach. This comprises \percentNameErrorFixedFullInAllNameErrors and \percentNameErrorFixedPartialInAllNameErrors notebooks fully and partially restored in the same order. Case Study 2 in Section \ref{case_study_2} provides an example of a notebook facing ``NameError" due to an undefined function, which prevents full execution. We use LLM to identify a definition for this function under the {\small{\texttt{tensorflow}}} module, improving executability by 50\%. This increase is an indication of LLM's potential for restoring functionality in notebooks with missing definitions.

    %\edit{IF WE NEED TO TALK ABOUT DEFINE AFTER: For X notebooks that have define-after-user issues, we use \textit{def-user} reordering approach to rearrange the definition of the undefined name preceding its usage.}

\begin{tcolorbox} [left=0mm, right=0mm, top=0mm, bottom=0mm]
    \textbf{Takeaway RQ4.} Utilizing LLM-based error-driven restoration strategies can potentially enhance the executability of restorable notebooks. For notebooks encountering errors such as ``ModuleNotFound," ``FileNotFound," and ``NameError," we achieve improvements of \averagePercentModuleNotFoundRestoredIncrease, \avgIncreaseAfterFileFixed, and \avgIncreaseAfterNameFixed in executability for each respective exception.
\end{tcolorbox}

\noindent Finally, we summarize the impact of restoration in Figure \ref{fig:executable_vs_star}, which shows the increase in the number of notebooks that achieved full executability before and after all restorations have been applied. 














% \subsection{Results Summary} 
% \waris{If we provide a summary/takeaway at the end of each subsection we may not need this. If we want to summarize all the findings we can do it without the subsection.}
% \tien{Figure  \ref{fig:overall_results} demonstrates our investigation results with a breakdown of executable, non-executable but restorable, and pathologically non-executable, as well as fully and partially executable after the restoration. Initially, according to the traditional notion of executability, \percentNonExecutable of the notebooks are non-executable. After our analysis and lightweight restoration, we find that \percentPathological of the non-executable notebooks are, in fact, pathologically non-executable with \averagePercentPartialPathological cells executable on average. Among the non-executable but restorable notebooks, \percentFullyRestored end up being fully executable, and \percentPartiallyRestored partially executable. Previously, notebooks that are now fully restored had only a limited portion executable, averaging \percentFullyRestoredBefore cells per notebook. Additionally, for notebooks that remained partially executable, we improved their executability from \percentPartiallyRestoredBefore to \percentPartiallyRestoredAfter. Finally, across all notebooks, on average, \overallExecutableCells of the cells per notebook are still executable, which can utilized by non-author developers.}
