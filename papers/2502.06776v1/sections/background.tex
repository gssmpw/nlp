Language model agents are a class of decision-making agents represented by $\pi_{\text{LLM}} ( \mathbf{a}_{t} | \mathbf{s}_{t}, \mathbf{c} ) $, a policy that processes multimodal observations $\mathbf{s}_{t}$ (from a web environment in our case) and predicts textual actions $\mathbf{a}_{t}$ to complete a task $\mathbf{c}$. Underneath this abstraction, a large language model (LLM) generates actions via the next-token prediction, conditioned on a system prompt $\mathbf{x}_{\text{sys}}$.

\begin{equation}
    \mathbf{a}_{t} = f^{\;\text{text} \to \text{act}} \big( \; \text{LLM} ([ \; \mathbf{x}_{\text{sys}}, \mathbf{c},  
    \text{Enc} ( \mathbf{s}_{t} ) \; ]) \; \big)
\end{equation}

Environment representations for observations and actions typically differ from the expected input format of the language model (typically images and text), and functions are introduced that map the observations to a multimodal prompt $\text{Enc} ( \cdot )$, and parse actions from the language model generated response $f^{\;\text{text} \to \text{act}} ( \cdot )$. For web navigation, the environment state $\mathbf{s}_{t}$ is HTML DOM, and is often formatted as raw HTML code, an Accessibility Tree, Set-of-marks, or screenshots \citep{WebArena,VisualWebArena,BrowserGym,ScribeAgent}. In this work, we employ an off-the-shelf HTML-to-Markdown parser to convert observations into a textual format. Action formats vary between works, and we build on \citet{ToolFormer}'s function-calling framework, where a language model generates code that is parsed into a function name and corresponding arguments. Given a set of strings $L$, and a set of function argument values $G$, the set of actions $\mathcal{A}$ is:

\begin{equation}
    \mathcal{A} = \big( L_{\text{func}} \times ( L_{\text{arg1}} \times G_{\text{arg1}} ) \times ( L_{\text{arg2}} \times G_{\text{arg2}} ) \times \cdots \big)
\end{equation}

where $L_{\text{func}}$ is the set of function names in our API, and function arguments have a name and value ($L_{\text{arg1}} \times G_{\text{arg1}}$). We provide agent access to the entire Playwright API \citep{Playwright}, a Microsoft-developed browser automation library that wraps around a Chromium web browser. The agent's goal is to complete a web navigation task specified via a natural language instruction $\mathbf{c} \in L$, starting from an initial URL, and operating the browser via function calls to the Playwright API until the task is complete, after which point the agent calls \texttt{stop} with an optional answer:

\begin{equation}
    \mathbf{a}_{\text{stop}} = \big( \text{``stop''}, ( \text{``answer''}, \text{``I am done''} ) \big)
\end{equation}

We prompt the language model backbone to generate actions wrapped in a JSON code block for straightforward parsing. The action parser $f^{\;\text{text} \to \text{act}}$ consists of a regex template that matches the first JSON code block, such as the example in Figure~\ref{fig:pipeline-main}, followed by JSON decoding of the string contents within the code block. When parsing fails due to invalid syntax, we generate a new response until parsing succeeds. Equipped with a language model agent that makes calls to the Playwright API, we face a crucial roadblock that impedes scaling: obtaining large and diverse data. 