\section{Implementation in \textsc{LPVcore}\label{sec:implementation}}
The integration of the automatic global LPV embedding method into the \textsc{LPVcore} toolbox is achieved by introducing a set of objects and functions that allow the user to define the nonlinear dynamical system and execute the conversion. As \textsc{Matlab} does not have a native implementation to define systems in the form of \eqref{eq:nl_dyn}, \textsc{LPVcore} introduces the \lstinline{nlss} class. For instance, consider the following nonlinear system
%
\begin{equation}
    \label{eq:nl_dyn_example}
    \begin{aligned}
        \diff x(t) & = -x(t) + u(t); \\
        y(t)       & = \tanh(x(t)).
    \end{aligned}
\end{equation}
%
A representation of \eqref{eq:nl_dyn_example} can be created by defining $f$ and $h$ as function handles, providing the system dimensions, and setting the sample time as \mbox{$T_\mathrm{s} = 0$}, \mbox{$T_\mathrm{s} > 0$} or as \mbox{$T_\mathrm{s} = -1$} to indicate that the system is in continuous-time, in discrete-time with the specified sampling time, or in discrete-time with undefined sampling time, respectively:
\begin{lstlisting}[basicstyle=\ttfamily]
f = @(x, u) -x + u;
h = @(x, u) tanh(x);
nx = 1; nu = 1; ny = 1; Ts = -1;
sys = LPVcore.nlss(f, h, nx, nu, ny, Ts);
\end{lstlisting}
%
% In addition, the \lstinline{nlss} class implements the utility methods \lstinline{sim} to simulate and \lstinline{c2d} to discretize the system.
%
Next, the \textsc{LPVcore} function \lstinline{nlss2lpvss} implements the automatic global LPV embedding procedure described in Section~\ref{sec:method}. This function allows the user to convert \lstinline{nlss} objects into LPV \emph{state-space} (LPV-SS) models, represented by an \textsc{LPVcore} \lstinline{lpvss} object. The LPV-SS models produced by \lstinline{nlss2lpvss} have by default affine dependency on the scheduling variables. This comes from the fact that the function $\eta$ is constructed by including all the nonlinear relationships resulting from~\eqref{eq:simplified_factorized_nl}. 

Continuing with the example, the \lstinline{sys} object that represents \eqref{eq:nl_dyn_example} can be converted into an LPV-SS model by executing
%
\begin{lstlisting}[linewidth=1.01\columnwidth, basicstyle=\ttfamily]
[lpvsys, eta] = LPVcore.nlss2lpvss(sys,...
    'analytical', 'element')
\end{lstlisting}
%
The second input argument of \lstinline{nlss2lpvss} determines whether the integration of the Jacobians in \eqref{eq:simplified_factorized_nl} is performed \lstinline{'numerically'} or \mbox{\lstinline{'analytically'}}, as follows:
\begin{itemize}
    \item \textit{Numerical integration (\lstinline{'numerically'} option):} in this mode, each nonlinear element of the Jacobians in \eqref{eq:simplified_factorized_nl} is extracted and associated with an affine scheduling variable. The integrals of each of these elements are used to define the scheduling map $\eta$ and are stored unsolved in the form of the \textsc{Matlab} data type \emph{function handle}, with $(x, u)$ as function input arguments. Then, when evaluating the scheduling map, the \textsc{Matlab} function \lstinline{integral} is invoked to execute the numerical integration using global adaptive quadrature with default error tolerances.
    %
    \item \textit{Analytical integration (\lstinline{'analytically'} option):} in contrast, this mode first integrates the elements of the Jacobians symbolically using the \textsc{Matlab} function \lstinline{int} using the \textsc{Matlab} Symbolic Toolbox. In this case, the third input argument of \lstinline{nlss2lpvss}determines how are the nonlinear elements from the integrated Jacobians extracted. The option \mbox{\lstinline{'element'}} follows the same procedure as the one described for the numerical integration, except the resulting scheduling map contains the analytic solution of the integrals. Alternatively, the option \mbox{\lstinline{'factor'}} uses an algorithm that tries to factor each of the nonlinear elements as a sum of scheduling variables, and then creates the scheduling map based on these scheduling variables.
\end{itemize}
  While an analytical integration produces an exact LPV embedding, it is computationally more expensive than a numerical integration due to the symbolic computations and it can fail to find the antiderivative for some complicated expressions. Lastly, the first output of \lstinline{nlss2lpvss} is the obtained LPV-SS model as an \textsc{LPVcore} \lstinline{lpvss} object, and the second output is the obtained scheduling map $\eta$ as a scheduling map object \lstinline{schedmap}, a class implemented in \textsc{LPVcore}.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.65\columnwidth]{fig/selfsched_diagram-eps-converted-to.pdf}
    \caption{Schematic representation of a self-scheduled simulation with an LPV-SS model and a scheduling map.}
    \label{fig:selfsched_diagram}
\end{figure}
Note that once the LPV-SS model is obtained, the user can readily use it with the remaining functionalities of the \textsc{LPVcore} toolbox. For instance, the \lstinline{lpvss} object can be used for LPV controller design, analysis or model reduction. Moreover, the \textsc{LPVcore} function \lstinline{lsim} has been extended to execute self-scheduled simulations of LPV-SS models, as illustrated in Fig.~\ref{fig:selfsched_diagram}. This can be done by providing a \lstinline{schedmap} object as the second input argument, as follows:
\begin{lstlisting}[basicstyle=\ttfamily]
y = lsim(lpvsys, eta, input, time, ...
    'Solver', @ode45)
\end{lstlisting}
For a complete overview of the available functionalities, consult the documentation which is included in \textsc{LPVcore}.


% The \lstinline{sim} method can be used to simulate the \lstinline{sys} object that represents \eqref{eq:nl_dyn_example},


