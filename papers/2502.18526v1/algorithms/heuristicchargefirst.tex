\begin{algorithm}[htbp]
\caption{Charge First with Least Laxity First.}
\label{alg:charge_first_llf}
\small
\KwIn{Set of EVs $V$, chargers $\mathcal{C}$, time slots $t$}
\KwOut{Charging schedule for each EV}

\For{each time slot $T_j \in \mathcal{T}$}{
    \For{each EV $\phi(C_i, T_j)$ connected to $\mathcal{C}$}{
        Compute laxity: 
        $L(\phi(C_i, T_j)) = (\DepartureTime(\phi(C_i, T_j)) - T_j) - {\PowerNeed(C_i, T_j)}/{C_{max}^i}$.
    }
    Compute power gap: 
    $\hat{P} = \PrdPeak(T_j) - \Building(T_j)$\;
    
    Compute sum of trickle rates: 
    $S = \sum_{i} {\PowerNeed(C_i, T_j)}/{\ReTime(C_i, T_j)}$\;

    % \If{$S < \hat{P}$}{
    % \tcp{Overcharging EVs for future discharging}
  \If(\tcp*[h]{Overcharging EVs for future discharging}){$S < \hat{P}$}{
 % \If(\tcp*[h]{comment}){$k = K$}{do stuff}
    % your code here
        \For{each EV $\phi(C_i, T_j)$ connected to $\mathcal{C}$}{
            Set trickle rate: 
            $P(C_i, T_j) \gets {\PowerNeed(C_i, T_j)}/{\ReTime(C_i, T_j)}$\;
        }
        $\hat{P} \gets \hat{P} - S$\;

        \For{each EV $V=\phi(C_i, T_j)$ connected to bi-directional chargers in reverse laxity order}{
            Charge to maximum SoC:
            $P(C_i, T_j) \gets \min\left(C^{max}_i, \frac{(\SOCMAX(V) - \SOC(V, T_j)) \times CAP(V)}{\Delta t}, \hat{P}\right)$\;

            $\hat{P} \gets \hat{P} - P(C_i, T_j)$\;
        }
    }
    \Else(\tcp*[h]{Discharging EVs to increase power gap}){ 
        \While{$\hat{P} \geq S$ \textbf{and} not all EVs connected to bi-directional chargers are considered}{
            \For{each $V=\phi(C_i, T_j)$ connected to bi-directional chargers in reverse laxity order}{
                \If{$SOC(V,T_j) > \SOCR(V)$}{
                    $P(C_i, T_j) \gets \max\left(C^{min}_i, \frac{(\SOCR(V) - \SOC(V, T_j)) \times CAP(V)}{\delta }\right)$\;

                    $\hat{P} \gets \hat{P} - P(C_i, T_j)$\;
                }
            }
        }
        \For{each $V=\phi(C_i, T_j)$ connected to chargers sorted by reverse laxity}{
            Set trickle rate:
            $P(C_i, T_j) \gets \min\left({\PowerNeed(C_i, T_j)}/{\ReTime(C_i, T_j)}, \hat{P}\right)$\;

            $\hat{P} \gets \hat{P} - P(C_i, T_j)$\;
        }
    }
}
\end{algorithm}