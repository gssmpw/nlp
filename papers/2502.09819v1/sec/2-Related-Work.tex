\section{Related Work}

\subsection{CAD Generation}
The compilation of large CAD datasets in recent years~\citep{koch_abc_2019,willis_fusion_2021,jones_automate_2021,willis_joinable_2022} has inspired a wealth of research on synthesizing CAD models. These efforts fall into two broad categories; those which generate CAD geometry directly~\citep{willis_engineering_2021,guo_complexgen_2022,jayaraman_solidgen_2023,nash_polygen_2020,xu2024brepgen,liu2024point2cad}, and those which generate a \emph{procedure} that generates CAD geometry~\citep{wu_deepcad_2021,ellis_learning_2017, ellis_learning_2018, ganin_computer-aided_2021,ren_extrudenet_2022,li_secad-net_2023,xu_skexgen_2022,lambourne_reconstructing_2022,para_sketchgen_2021, seff_vitruvion_2022,willis_fusion_2021,ma2024draw,li2024sfmcad,khan2024cad}. A fundamental challenge with these tools is the ability to control the generation. While many methods can be conditioned on an input allowing for reverse engineering applications~\citep{lambourne_reconstructing_2022,guo_complexgen_2022}, the few methods that directly focus on generation give limited control over their output \citep{jayaraman_solidgen_2023, wu2021deepcad,xu2024brepgen,seff_vitruvion_2022}. The highest degree of control is afforded by those that take sketches as input, such as Free2CAD~\citep{li_free2cad_2022} but these are effectively reverse reverse engineering an existing geometric design rather than enabling high level guidance. The goal of AIDL is to enable control without direct geometric supervision, and to incorporate semantic understanding beyond that of existing CAD programs. We have thus chosen to design our system around \textit{general purpose} language models rather than CAD specific models, and focus on DSL design rather than the design or training of a generative model. Importantly, all prior works use CAD DSLs that have limitations when it comes to LLM needs, as we discuss in Section~\ref{sec:analysis_llm}.


%There have been several attempts in recent years to generate CAD models. Some attempt to directly generate symbolic geometry\cite{willis_engineering_2021,guo_complexgen_2022,jayaraman_solidgen_2023,nash_polygen_2020,xu2024brepgen,liu2024point2cad}, while others use procedural representations~\cite{wu_deepcad_2021,ellis_learning_2017, ellis_learning_2018, ganin_computer-aided_2021,ren_extrudenet_2022,li_secad-net_2023,xu_skexgen_2022,lambourne_reconstructing_2022,para_sketchgen_2021, seff_vitruvion_2022,willis_fusion_2021,ma2024draw,li2024sfmcad,khan2024cad}. Some procedural approaches employ symbolic techniques either alone or in concert with learned heuristics \cite{nandi_functional_2018,xu_inferring_2021,du_inversecsg_2018}. A fundamental challenge with these tools is the ability to control the generation. While many methods can be conditioned on an input allowing for reverse engineering applications~\cite{lambourne_reconstructing_2022,guo_complexgen_2022}, the few methods that directly focus on generation give limited control over their output \cite{jayaraman_solidgen_2023, wu2021deepcad,xu2024brepgen,seff_vitruvion_2022}. The highest degree of control is afforded by those that take sketches as input, such as Free2CAD~\cite{li_free2cad_2022} but these are effectively reverse reverse engineering an existing geometric design rather than enabling high level guidance. 

%While many generative and reconstructive models treat the procedural form of CAD models as linear output and rely on large-data statistics to take care of syntactic and semantic concerns, some works employ symbolic techniques directly, either alone or in concert with learned heuristics. ReIncarnate~\cite{nandi_functional_2018}, Zone Graphs~\cite{xu_inferring_2021}, and InverseCSG~\cite{du_inversecsg_2018} treat reconstruction as a synthesis problem given inferred initial geometry, but use different synthesis techniques; oracle guided heuristics, neurally guided search, and constraint guided synthesis. Program synthesis can also be used to improve the robustness of existing CAD programs.  The goal of AIDL is to enable control without direct geometric supervision, which is why we propose to use an LLM to create CAD models through code, and therefore focus on DSL design rather than the design or training of a generative model. Importantly, all prior work uses CAD DSLs that are have limitations when it comes to LLM needs as will be discussed and surveyed in details in Section~\ref{sec:analysis_llm}. With AIDL, we want to incorporate semantic understanding beyond that of existing CAD programs, and therefore design our system around \textit{general purpose} language models rather than CAD specific models.

%\cite{mathur_constraint_2021} synthesizes symbolic constraints on input parameters that exclude configurations which break the model. Some of these constraints are discoverable through static program analysis, but their work highlights the necessity of access to a CAD kernel to understand the semantics of a CAD program, necessitating \emph{dynamic} analysis as well. \cite{mathur_interactive_2020} improves robustness by replacing specific references with programs synthesized with a small program size heuristic, using the hypothesis that smaller programs will generalize better, thus capturing user intent.



\subsection{Code Generation with LLMs}

Software engineering has been one of the marquee applications of LLMs, so a detailed enumeration of works in the field is beyond the scope of this paper. We instead refer the reader to a survey \citet{zhang2024unifying}, and reserve this section to position AIDL within the space. The majority of research on using LLMs for coding focus on how to make LLMs work more effectively with existing programming languages. A popular approach is to specifically train or fine-tune a model on code repositories and coding specific tasks \citep{li_starcoder_2023,lozhkov_starcoder_2024,grattafiori2023code}, or more recently to use LLMs to generate higher complexity training examples \citep{xu_wizardlm_2023,luo_wizardcoder_2023}. Other approaches tackle prompt complexity through system design, exploring prompt engineering and multi-agent strategies for pre-planning or coordinating a divide-and-conquer strategy \citep{dong_self-collaboration_2023,bairi_codeplan_2023,silver_generalized_2023}. AIDL approaches LLM code generation from an entirely different perspective, by asking which \emph{language features} will best enable an LLM to work with a programming system. Most similar is BOSQUE, a proposed general purpose programming language \citep{marron_towards_2023}. In particular, BOSQUE's embrace of pre and post conditions mirrors AIDL's use of constraints and strong validation, but does not go so far as to employ a solver to enforce constraints.

% Most work on coding LLMs focuses on how to get an LLM to work with existing code and coding systems
% This is done by training models specifically for coding
% fine-tuning existing models for coding tasks
% or creating prompting / querying strategies to improve the performance of LLMs with code
% AIDL asks a different question; what can we do to a coding language to make it work better with an LLM? Most similar to this is the proposed BOSQUE language...

% Code Gen w/ LLMs
% - train models specifically on / for code
% - fine-tune existing models for code
% - prompting / generation strategies for code
% - design languages for use with LLM

%Code generation has been one of the headline applications of the recent LLM explosion. There are several coding-specific LLMs that have been specifically trained or fine-tuned on code repositories and coding specific tasks \cite{li_starcoder_2023,lozhkov_starcoder_2024,grattafiori2023code}. Generating solutions to complex prompts is difficult. Some works explore prompt engineering and multi-agent strategies for pre-planning or coordinating a divide-and-conquer strategy for complexity \cite{dong_self-collaboration_2023,bairi_codeplan_2023,silver_generalized_2023}, while more recently models have been fine-tuned on synthetic, complex examples generated by LLMs \cite{xu_wizardlm_2023,luo_wizardcoder_2023}. LLMs can perform worse generating code in DSL than general purpose languages since they will have fewer or no examples of these in their training data. For context-free languages, grammar prompting \cite{wang_grammar_2023} can constrain output to valid DSL expressions. This approach is not feasible for more complex languages like AIDL, however there are prompting strategies that can increase the likelihood of valid program structures \cite{jain_generating_2023}. Another recent work proposes an LLM specific general purpose language, BOSQUE \cite{marron_towards_2023}, that shares a similar the philosophy of AIDL to design the language around an LLM's strengths and weaknesses. In particular, BOSQUE's embrace of pre and post conditions mirrors AIDL's use of constraints and strong validation, but does not go so far as to employ a solver to enforce constraints.

%\paragraph{Code Generation}
%There is extensive body of work focusing on \em{program synthesis}, the task of generating programs that satisfy user-provided specifications. A number of approaches have been developed to solve the synthesis problem, including enumerative, constraint-based and stochastic search algorithms. However, traditional synthesis algorithms require \em{formal} specifications while our goal is to generate programs from natural language specifications.

\subsection{CAD DSLs}
\label{sec:background}
% We review existing CAD DSLs and give a high-level explanation of how they work.
While there are many CAD DSLs, they can be grouped intro three broad categories: %While these categories are not black and white, they emphasize the main features of their respective languages.
%More specifically, industry standard CAD systems tackle real-world problems with different DSLs for different stages of the design process.
%Whereas the modeling stage often uses a CSG or query-based DSL, the assembly stage uses a constraint-based DSL.

% \felix{Maybe put a figure with the same geometry, designed in all three different languages?} \maaz{This would be nice if we can afford the space but I don't think its necessary.}

\paragraph{Constructive Solid Geometry (CSG)}
% The first step of each CAD design is to create geometric primitives.
In CSG, users can specify 2D and 3D parametric primitives, such as rectangles or spheres, directly in global coordinates.
Using boolean operations, such as union or intersection, users then combine these primitives in a hierarchical tree structure to achieve complex designs.
%Examples of languages for this category are OpenSCAD, and Szalinski \cite{nandi2020synthesizing}.
While some CSG languages, such as OpenSCAD, allow the use of variables or expressions for primitive parameters, they do not support specifying relationships or dependencies between different parts of the geometry.
This absence of dependencies simplifies the abstraction, making CSG widely used in inverse design and reconstruction tasks \citep{du_inversecsg_2018, nandi2020synthesizing, yu2022capri, michel2021dag}. 
However, this limitation also makes modeling more challenging, which is why CSG is not commonly used in most commercial CAD tools.

% CSG operations reference the entire geometry directly and unambiguously, which means that primitives can be safely edited even after the fact.
% Geometric relationships between geometric elements are not part of the language.% itself and are often handled by external solvers in a design tool, e.g. Illustrator's alignment feature for SVG objects. \adriana{I'm not sure I agree that SVG is a programming language and is CSG-like.}
% Due to the binary nature of boolean operations, designs in CSG languages result in a hierarchical tree structure, which is analogous to an abstract syntax tree (AST).

%  % \adriana{would be it useful to talk about how this simplicity allows for applications like reverse engineering cite chandra's work, inverseCSG, capri-net. but is not usually what is most used for modeling because of the needs to specify global coordinates with all primitives.}\felix{It's worth talking about this point.}\maaz{I think briefly qualifying the strengths and weaknesses of CSG DSLs can be nice for less familiar readers but I would not spend more than a few lines.}

\paragraph{Query-based CAD}
Most commercial CAD tools use query-based languages, such as FeatureScript \citep{featurescript}, which employ a sequence of operators to create and modify models (e.g., extrude, fillet, chamfer). 
These operators reference intermediate geometry---e.g., a chamfer operator takes a reference to an edge. 
This referencing creates implicit dependencies, simplifying modeling and enabling easy editing as operations propagate when intermediate geometry is updated. 
However, a challenge arises when edits lead to topological changes, making reference resolution ambiguous. 
For example, if an edge gets split or disappears, where should the chamfer be applied? To address this, these languages do not reference geometry explicitly. 
Instead, geometric references are specified \emph{implicitly} via a language construct called \emph{queries}. 
These queries are resolved during runtime by a solver~\citep{cadquery, featurescript}, which typically uses heuristics to resolve ambiguities. 
This makes automating design challenging, and generative tools that use CAD operators restrict themselves to sequences where references are not needed, such as sketch and extrude~\citep{wu2021deepcad, willis_fusion_2021, lambourne_reconstructing_2022}. 
While recent work allows for the unambiguous direct specification of references~\citep{cascaval2023lineage}, mastering this language is complex and demands significant expertise.

 

\paragraph{Constraint-based CAD}
As the name implies, constraint-based CAD DSLs natively enable users to create geometric constraints between geometric primitives. This frees designers from specifying parameters consistently, allowing for freeform design while ensuring that relationships between parts are preserved. This approach is used in content creation languages like Shape-Assembly \citep{jones2020shapeassembly}, GeoCode \citep{pearl2022geocode}, and SketchGen \citep{para2021sketchgen}.
 In typical commercial CAD tools, constraint-based abstractions are used in sketches---2D drawings that get extruded to form 3D geometry---and during assembly modeling, but not during solid modeling which uses queries. 
These languages do not provide operations to modify primitives or to create intermediate geometry and therefore they reference geometry directly.
Designs specified in these languages are non-hierarchical, all constraints are being solved simultaneously.
