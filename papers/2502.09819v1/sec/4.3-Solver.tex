\subsection{Compilation and Constraint Solving}
\label{sec:solver}

%==================== NEW TEXT ==================================

The hierarchical organization of AIDL models allows for recursive constraint solving. We employ an iterative deepening, recursive solver strategy that allows AIDL to solve a minimal constraint problem at each stage, and also keeps substructures fixed as much as is possible to avoid unintuitive changes to substructures due to higher-level constraints. (translations of substructures are preferred over modification of internal geometry to satisfy constraints). To facilitate this recursive solving, AIDL models are first \emph{validated} to ensure that each substructure is independently solvable, then \emph{compiled} into a hierarchy of geometric constraint problems that we solve with an iterated Newton's method solver. The solved model is then \emph{post-processed} to perform boolean operations and generate the final geometry.

When an AIDL program is run as a Python program, it generates a Structure tree data structure. An AIDL model is valid if Geometry only references other Geometry belonging to the same Structure, and Constraints only reference Geometry, Parameters and Structures within the same subtree. Definition of constraint equations in AIDL is \emph{deferred} until after the tree structure is finalized because bounding boxes and some geometric constraints are not well defined until the model topology and initial parameters are fixed. Two non-inversion constraints are added to each bounding box, $height >= 0$ and $width >= 0$, using a slack variable formulation borrowed from linear programming (e.g. $height + s == 0 \land s - |s| == 0$).

The constraint system of an AIDL model is solved hierarchically as described in \Cref{app:solver} using an iterated Newton's method solver (based on SolveSpace~\cite{westhues_solvespace_2022}). Iteration is used to support bounding boxes; at each iteration we fix the expression of each bounding box limit relative to the initial positions of its geometry, then re-check and re-solve if a different piece of geometry now defines the limit. Solved AIDL models are post-processed to apply boolean operations defined by Solid and Hole Structures. Curve geometry is recursively aggregated to discover closed faces which are boolean unioned or subtracted from each other depending on the type of Structure they belong to. We use  the OpenCascade Modeling Kernel~\cite{occt3d_opencascade_2021} to perform boolean operations and generate output in the CAD standard STEP format.

\iffalse

%==================== OLD TEXT ==================================
%Points to make:
%Validation and compilation is designed to make the models hierarchically solvable. Reasons for hierarchical solvability:
%- want to minimize the size of the constraint problems being solved for tractability
%- want to isolate substructure solves as-much-as-possible for consistency; e.g. if a structure can be left alone that is best, if it can be rigidly translated, and only if that is not possible do we allow

%- We solve using a modified Newton solver (forked from SolveSpace [cite Westhues 2022])




%Primary design goals:

%Hierarchical






After a model is created in the AIDL DSL, its validity is checked and it is compiled into an AIDL model, which is a tree structure in which every node is also a valid AIDL model. 
The AIDL model defines a system of geometry, parameters, and constraints in a hierarchy. 
The constraint system is then solved recursively bottom-up using an iterated Newton's method solver to find parameter values that satisfy all constraints while minimizing the size of constraint subproblems. 
Finally, the geometry is aggregated up the tree from leaves-to-root, combined via boolean operations to form the final geometry.

\paragraph{Validation and Compilation}
To compile an AIDL model, we flatten Geometry nodes such that just primitive geometry (Points, Lines, Circles, and Arcs), Parameters, and Constraints remain, and are attached directly to a Structure. 
We ensure every subtree can be solved independently by validating that Geometry only references other Geometry on the same Structure, and Constraints only reference Geometry and Parameters within their own subtree. 
%Next, we concretize the constraint equations that are deferred. 

Many numeric Expressions in AIDL can only be defined once the model structure is finalized; these are called \emph{deferred} expressions, and exist as Expression-valued functions of the final model hierarchy that get evaluated at the end of compilation. Two kinds of expressions get deferred in AIDL; ambiguous geometric constraints, and bounding boxes. Some geometric constraints, like fixed ``Angle'' have multiple common interpretations (clockwise or counter-clockwise); AIDL resolves this to whichever is closest to being satisfied by the initialization values. Bounding boxes are deferred because both local geometry and structural hierarchy are not fixed until compilation time. 
%In order to support validating constraints between empty Structures before geometry has been generated, we generate width and height Parameters for empty Structures at compile time if their bounding boxes are involved in a deferred constraint expression.
To support validating deferred constraints involving yet empty Structures, we create virtual bounding boxes.

\paragraph{Constraint Solving}
Constraints in AIDL are solved using an iterated Newton's method solver. AIDL Expressions support ``min'' and ``max'', which are used to express bounding boxes. The piece-wise nature of these functions can hinder the converge of Newton's method. 
To promote convergence, we remove these discontinuities by re-writing Expressions involving ``min'' and ``max'' on the active branch, using the model parameter initialization before the Newton solve. 
We then check if the original constraint equations are satisfied, and iterate this process until convergence or failure.
%they are, or one of the re-written problems fails to converge.

In addition to ``min'' and ``max,'' AIDL models can also contain inequality constraints. 
These occur when bounding boxes are constructed for empty structures to ensure that the boxes do not invert, e.g. $height >= 0$. To support these constraints, we borrow the idea of slack variables from linear programming, and rewrite constraints of the form $A <= b$ as $A - b + s == 0 \land s - |s| == 0$. The second equality is equivalent to $s >= 0$, ensuring that the slack variable $s$ is positive. Using inequality constraints in CAD is usually unhelpful because they negate the accuracy benefits of CAD models, and tend to lead to very unpredictable solutions. For this reason, we do not expose the inequality capabilities of AIDL to the programmer. In our system, inequality constraints only appear at intermediate stages of programming when they are used to \textit{validate} the feasibility of a constraint system before concrete geometry is specified.

\paragraph{Model Solving}
Because \langname{} can express compositional constraints between structures, the constraint system can involve the entire tree and grow in complexity, making it difficult to solve and its solution unintuitive. By structuring AIDL models into trees of small, independent constraint problems, which is being reflected by our validation criteria, we ameliorate both issues. With the exception of constraints with references into substructures, we can recursively solve the AIDL model node-by-node.


If constraints refer to substructures, it may not be possible to solve the constraints locally, only modifying their defining structure. 
We iteratively deepen the parameters and constraints considered, one tree-level at a time, whenever a subproblem cannot be solved. This is a greedy approach to finding a minimal solveable subproblem at each stage of the recursive solve. To further reduce changes to solved substructures, we attempt the iterative deepening in several stages; first only adding 2D structure translational degrees of freedom on deeper attempts, then 3D, and finally allowing the local parameters and geometry on subnodes to be modified on the final pass. This preferentially preserves the local geometry of already solved nodes, helping to preserve solutions near the initial parameter values.

\paragraph{Boolean Post-Processing}
The final stage of evaluating an AIDL model is to recursively collect and combine geometry. AIDL supports boolean union and subtraction through its Solid and Hole Structures, operations that are performed on surfaces and volumes, but its highest dimensional geometry primitives are curves. To allow booleans, curves endpoints of Solid and Hole Structures are matched to find closed loops that bound planar regions. This includes geometry from attached child nodes, post boolean. At each node, a boolean union is first carried out over faces discovered from local and Solid descendant edges, and then boolean subtraction performed with faces from Hole children. This recursion continues until an Assembly Structure or the root is reached, at which point face geometry is propagated without further boolean operations. Drawing geometry is interpreted purely as edges and so propagated directly to the root Structure.

\paragraph{Implementation}
We forked our constraint solver from SolveSpace~\cite{westhues_solvespace_2022}, adding support for arbitrary constraint expressions, inequality constraints, extra arithmetic operators, dynamic activate of parameters and constraints, and iterative Newton solving. Boolean operations are implemented with the OpenCascade Modeling Kernel~\cite{occt3d_opencascade_2021}.

\fi