\section{Language Syntax}

\begin{figure*}[htbp]
\scriptsize
\begin{tabular}{rcl}
\toprule
$\textit{structure}$ & $=$ & $\langle$ \ \textit{frame}, \: \textit{sketch}, \: [$\textit{ref\textlangle structure\textrangle}$], \: [\textit{constraint}] \ $\rangle$ \\
$\textit{frame}$ & $=$ & $\langle$ \ $\textit{type} \in$ \{ Assembly, Solid, Hole, Drawing \}, \: $\textit{orientation} \in$ \{ Top, Front, Side \}, \: \ldots \ $\rangle$ \\
$\textit{sketch}$ & $=$ & $\langle$ \ [$\textit{ref\textlangle geometry\textrangle}$], \: [$\textit{ref\textlangle parameter\textrangle}$] \ $\rangle$ \\
$\textit{parameter}$ & $=$ & $\langle$ \ val $\in \mathbb{R}$, \: mutable $\in \mathbb{B}$ \ $\rangle$ \\
$\textit{ref\textlangle $\tau$\textrangle}$ & $=$ & $\langle$ \ name $\in$ String, \: ptr $\in \tau$ \ $\rangle$ \\
$\textit{geometry}$ & $=$ & Point \: | \: Line \: | \: Arc \: | \: Circle \: | \: $\langle$ \ [$\textit{ref\textlangle geometry\textrangle}$], \: [$\textit{ref\textlangle parameter\textrangle}$] \ $\rangle$ \\
\midrule
$\textit{primitives}$ & $::=$ & make\_point \: | \: make\_line \: | \: make\_arc \: | \: make\_circle \: | \: make\_rectangle \: | \: \ldots \\
$\textit{constraint}$ & $::=$ & \textit{logical\_expr} \: | \: \textit{structural\_constraint ($\textit{ref\textlangle $\tau$\textrangle}, \ \textit{ref\textlangle $\tau$\textrangle}$)} \\
                    & | & \textit{unary\_geometric\_constraint ($\textit{ref\textlangle $\tau$\textrangle}$)} \: | \: \textit{binary\_geometric\_constraint ($\textit{ref\textlangle $\tau$\textrangle}, \ \textit{ref\textlangle $\tau$\textrangle}$)} \\ 
$\textit{structural\_constraint}$ & $::=$ & $\mathsf{above}$ | $\mathsf{center\_inside}$ | $\mathsf{left\_of}$ | $\mathsf{taller}$ | ... \\
$\textit{unary\_geometric\_constraint}$ & $::=$ & $\mathsf{horizontal}$ | $\mathsf{diameter}$ | $\mathsf{fixed}$ | ...  \\
$\textit{binary\_geometric\_constraint}$ & $::=$ & $\mathsf{coincident}$ | $\mathsf{tangent}$ | $\mathsf{equal}$ | $\mathsf{symmetric}$ |...  \\
%\midrule
$\textit{logical\_expr}$ & $::=$ & $\textit{arith\_expr} = \textit{arith\_expr}$ \: | \: $\textit{arith\_expr} \leq \textit{arith\_expr}$ \: | \: $\textit{arith\_expr} \geq \textit{arith\_expr}$ \\
                         & | & $\textit{logical\_expr} \land \textit{logical\_expr}$ \\
$\textit{arith\_expr}$ & $::=$ & c $\in \mathbb{R}$ \: | \: $parameter$ \: | \: \textit{u\_op} \ \textit{arith\_expr} \: | \: \textit{arith\_expr} \ \textit{b\_op} \ \textit{arith\_expr} \\
$\textit{u\_op}$ & $::=$ & $-$ \: | \: $\sin$ \: | \: $\cos$  \: | \: $\arcsin$ \: | \: $\arccos$ \: | \: sqrt \: | \: abs \: | \: norm \: | \: square \\
$\textit{b\_op}$ & $::=$ & $-$ \: | \: $+$ \: | \: $\times$ \: | \: $\div$ \: | \: min \: | \: max \\
\bottomrule
\end{tabular}
\caption{\textbf{Types and operations of AIDL.} $\tau$ represents the union type (structure|parameter|geometry). [$\theta$] is the notation used to represent an array or list of $\theta$. \maaz{If we have the time, consider adding a longer caption explaining some of the key types and operations.}}
\label{fig:language-grammar}
\end{figure*}

\section{Solver Details}
\label{app:solver}

\paragraph{Iterative Deepening Recursive Solve}
Constraint problems in AIDL are solved recursively over the structure tree in a post-order traversal, illustrated in the left half of \Cref{fig:solveorder}. At each step of this recursive solve, AIDL attempts to find a solution where only the geometry and parameters of the structure being solved, and \emph{not} its substructures, are free parameters in the solve; everything deeper is initially treated as constants. This is done to minimize both the size of the constraint problem being solved, and to minimize perturbations to previously solved substructures. The validity condition that constraints can only reference geometry, structures, and parameters within a structure subtree ensures that if the constraints defined at the root of a subtree are satisfied, then the whole subtree is fully solved because child structure constraints cannot reference variables that would have changed.

Some constraint problems cannot be solved entirely locally, especially when a constraint in used to relate geometry between children. This is where we apply iterative deepening, in two stages. First we iteratively allow child structures at deeper levels to be translated by adding their translation frame parameters into the solver's set of free variables. As this search deepens, it also necessitates re-adding the constraint sets of the \emph{parent} structures of translatable structures into the constraint set to be satisfied, since moving a child structure could invalidate a previously solved constraint. If translating structures is insufficient to satisfy the constraint system, then we repeat a similar iterative deepening, this time allowing all parameters, translation and otherwise to be solvable at each level. In this second iterative deepening it is necessary to include the constraints at the \emph{same} level as the frontier of solver parameters, rather than the parent level, since geometric parameter changes could invalidate previously solved constraints. Iterative deepening continues until a valid solution is found, or all levels of the hierarchy have been exhausted (in which case the solve has failed because the constraint system is inconsistent or intractable.)

\begin{figure}
    \centering
    \includegraphics[width=0.75\linewidth]{images/solveorder.pdf}
    \caption{\textbf{Constraint solving order for an AIDL model.} \textbf{(Left)} The recursive solve order of the entire model. \textbf{(Right)} Iterative deepening of the constraint solver's scope for the root node (5 on left), in two stages, first translation deepening, then geometric deepening. Letters indicate the parameters and constraints included at each level attempted, and are accumulative within a stage (a, a and b, etc.)}
    \label{fig:solveorder}
\end{figure}

\paragraph{Deferred Expressions}
While some constraints and expressions are well-defined mid-execution of an AIDL program, others can only be explicitly specified after the full topology and initialization of the model has been finalized by running the Python DSL code. The primary examples of these are bounding box coordinates, because they could depend on dynamically generated geometry, and ambiguous geometry constraints. An example ambiguous constraint is one like \verb|Angle(L1, L2, theta)|, which constraints the angle between lines \verb|L1| and \verb|L2| to be equal to theta. The meaning of this constraint depends on the angle convention in use; is the angle measured clockwise or counter-clockwise between these two lines? In a traditional constraint language, a single consistent convention would be applied and programmers expected to learn and follow this convention, but a design principle of AIDL is to be flexible in calling conventions. To allow this, we \emph{infer} the calling convention intended by picking the convention that is nearest to being satisfied by the initial parameters of the constrained geometry. Since parameters are dynamically mutable, these determinations must also be deferred until immediately before constraint solving.

Bounding box expressions are also deferred until the context of their use in a constraint is known, and their exact formulation varies depending on which structures' bounding boxes are used in the same constraint. The rationale for this behavior is that constraints such as \verb|struct.bb.top == struct.substruct.bb.top| leave an unbounded range for the substructure's top edge, since it is satisfied as long as that substructure has the highest top edge of any substructures. It is more likely that the intent of such a constraint is to align the top edge of a substructure with the top edge of its parent's sketch. To support this, bounding box expressions for structures coexisting in the same constraint expression as their descendants ignore those descendants' bounding boxes when computing the expressions for their coordinates.

\paragraph{Iterated Newton Solve for Branching Expressions}
AIDL expressions support the \verb|min| and \verb|max| operators, primarily to allow the use of bounding boxes. These create discontinuities in the constraint equation's Jacobians that use bounding box properties, which can cause a Newton solver to fail to converge. To combat this, we prune branches not used in constraint expressions given the pre-solve (initialization) parameter values, removing these discontinuities and increasing the chance of convergence. This effectively re-writes constraints to remove such functions: $\text{min}(e_1, e_2) \to e_1$ (assuming $e_1 < e_2$ in the initial parameterization). The issue with this approach is that a solution to the re-written constraint problem may not be a solution to the original problem. We therefore check if the solution is valid for the original constraint problem and, if not, iteratively repeat this process using the rewritten constraint problem's solution as a new initialization until we find a valid solution.


\section{Perceptual Study}
\label{app:study}
For our perceptual study, we presented users with all valid renderings of CAD programs generated for a particular prompt, asking them to select the best one for each method. Given the high number of prompts, the study was divided into four blocks, one for each method, with users randomly assigned to one block. We collected a total of 32 responses, with an average of 8 per method. The aggregated results are provided in supplemental material. 

One limitation of this study was a small bug in the renderer that removed some lines from the images. While this compromised the results slightly, the study remains useful for observing differences across methods.

\section{Editability}
\label{app:editability}

\begin{figure}[htbp!]
  \centering
  \includegraphics[width=\linewidth]{images/editability.png}
  \caption{\textbf{Editability of AIDL.} Programs generated with AIDL have semantically meaningful parts. By changing the geometry of a single part in the original "lighthouse" \textbf{(left)}, we can modify the entire appearance of the CAD shape in various ways to produce a wide variety of semantically related, but visually distinct models.} 
  \label{fig:editability}
\end{figure}
% \newpage
% \section{User Study Results}
% \label{app:user study results}
% \begin{figure}[htbp]
%   \centering
%   \includegraphics[width=11cm]{images/appendix comparison 1.png}
%   \caption{\textbf{Perceptual Study Results Part I.} User selected best generated examples for a particular prompt across $\textbf{AIDL}$, $\textbf{AIDL}_\text{no constraints}$, $\textbf{AIDL}_\text{no hierarchy}$, and OpenSCAD}
%   % \label{fig:Main result}
% \end{figure}
% \begin{figure}[htbp]
%   \centering
%   \includegraphics[width=11cm]{images/appendix comparison 2.png}
% \caption{\textbf{Perceptual Study Results Part II.} User selected best generated examples for a particular prompt across $\textbf{AIDL}$, $\textbf{AIDL}_\text{no constraints}$, $\textbf{AIDL}_\text{no hierarchy}$, and OpenSCAD}
%   % \label{fig:Main result}
% \end{figure}

% \begin{figure}[htbp]
%   \centering
%   \includegraphics[width=11cm]{images/appendix comparison 3.png}
% \caption{\textbf{Perceptual Study Results Part III.} User selected best generated examples for a particular prompt across $\textbf{AIDL}$, $\textbf{AIDL}_\text{no constraints}$, $\textbf{AIDL}_\text{no hierarchy}$, and OpenSCAD}
%   % \label{fig:Main result}
% \end{figure}

% \begin{figure}[htbp]
%   \centering
%   \includegraphics[width=11cm]{images/appendix comparison 4.png}
% \caption{\textbf{Perceptual Study Results Part IV.} User selected best generated examples for a particular prompt across $\textbf{AIDL}$, $\textbf{AIDL}_\text{no constraints}$, $\textbf{AIDL}_\text{no hierarchy}$, and OpenSCAD}
%   % \label{fig:Main result}
% \end{figure}

% \begin{figure}[htbp]
%   \centering
%   \includegraphics[width=11cm]{images/appendix comparison 5.png}
% \caption{\textbf{Perceptual Study Results Part V.} User selected best generated examples for a particular prompt across $\textbf{AIDL}$, $\textbf{AIDL}_\text{no constraints}$, $\textbf{AIDL}_\text{no hierarchy}$, and OpenSCAD}
%   % \label{fig:Main result}
% \end{figure}

% \section{AIDL Results}
% \label{app:AIDL results}


% \section{$\text{AIDL}_\text{no hierarchy}$ Results}
% \label{app:nohierarchy results}


% \section{$\text{AIDL}_\text{no constraints}$ Results}
% \label{app:noconstraints results}


% \section{OpenSCAD Results}
% \label{app:openscad results}




% \subsection{Geometry}

% \subsection{Constraints}

% Constraints in AIDL are always uniquely assigned to a Structure. This determines when that constraint is considered in the hierarchical solve order, as well as how to interpret geometric quantities used in the constraint. For Geometry and Structural Constraints, the coordinates of geometric entities are first projected into the sketchplane or frame of the Constraint's Structure prior to solving. This allows, e.g. for points in substructures to be positioned Symmetrically relative to a common parent structure.

% \subsubsection{Expression Constraints}
% The most basic constraint type in AIDL is an Equation constraint. It can take as input any logically valued expression. All Geometry and Compositional constraints can be expressed as Equations directly, but using the Geometric or Compositional variants allows for more succinct expression by using the Geometry and Structure entities for reference.

% The complement to the Equational Constraint is the Fixed Constraint, which takes an numerically valued expression as input and fixes its value to be unchanged from what it evaluates to before solving. This is useful for capturing implicit relationships between geometry and structures that are initialized completely correctly, but it can easily over constrain a model. The Fixed Constraint can also be used to fix an expression to a particular value, in this use case it is equivalent to \verb|Equational(expr == value)|% When a Fixed expression is just a single parameter, the parameter is converted to a constant (removed from all solve groups) rather than adding a constrain. TODO - not currenty possible, need to implement parameter-group-switching.

% \subsubsection{Geometric Constraints}
% AIDL supports a number of 2D geometric constraints between basic Geometric entities; Points, Lines, Circle, and Arcs. These are:
% \begin{itemize}
%     \item Coincident
%     \item Distance
%     \item Equal
%     \item EqualLength
%     \item EqualRadius
%     \item EqualAngle
%     \item EqualPointLineDistance
%     \item LengthRatio
%     \item Symmetric
%     \item HorizontallySymmetric
%     \item VerticallySymmetric
%     \item AtMidpoint
%     \item Horizontal
%     \item Vertical
%     \item Diameter
%     \item Perpendicular
%     \item Tangent
%     \item LengthDifference
% \end{itemize}
% Each Geometric Constraint supports one or more input overloads to allow a language model flexibility in calling convention. For example, Coincident can be called for pairs of Points, a Point and a Line, or a pair of Lines, among other combinations, or angles for Angle and EqualAngle can be specified with a pair of Lines, or three point implying an angle (center, start, and end).

% \subsubsection{Compositional Constraints} Our system introduces compositional constraints to parametric CAD; inequality constraints on the relative positions and proportions of substructures that encode higher-level design considerations in the model definition directly rather than implicitly in the model geometry. These are based on the axis-aligned bounding box of the structures being constrained. 

% \paragraph{Bounding Box Semantics}
% The axes, dimensions, and sides of bounding boxes in AIDL are described as horizontal (left-to-right, width), vertical (bottom-to-top, height), and longitudinal (back-to-front, depth). English nomenclature around directions is unfortunately ambiguous; in 2D CAD ``vertical'' usually refers to an axis in-the-page (e.g. the top and bottom of a sheet of paper or a computer screen), and corresponds to the v axis (down = -v, up = +v). The ``front'' of a 2D drawing comes out of the page or screen towards the viewer, and the back away; so (forward = +n and backward = -n). In contrast, in 3D CAD, the vertical axis is z (n in local coordinates), and y (v locally) is longitudinal, with forward = -v and backward = +v. Thus both the conventional names, and the handedness of the coordinate system are dependent on which perspective is being taken, 2D or 3D.
% To handle this, AIDL names axes and dimensions both by their local names (u,v,n) and by their colloquial names (front, left, back, etc.), and provides both 2D and 3D versions for any colloquial names referring to vertical or longitudinal properties. Since CAD sketching, and sketching in AIDL is done in 2D, AIDL default to the 2D versions, and uses the tag 3D to denote the 3D version of a property or constraint; e.g. $height = v_{max} - v_{min}$, while $height3D = n_{max} - n_{min}$. Additionally, front and back are negated in 3D so that back-to-front ordering is always a coordinate increase: $back3D = -v_{max}$, $front3D = - v_{min}$.

% \paragraph{Compositional Constraint Vocabulary}
% AIDL supports a very large number of compositional constraints with a diverse vocabulary. Many are variations on a few template constraints that are parameterized by an axis (horizontal, vertical, or longitudinal), and sometimes a direction and/or a numeric value. For each parameter combination, AIDL has one or more colloquial synonyms. Common combinations are also given names to round out AIDL's verbose constaint syntax. \cref{fig:compositional-templates} illustrates these templates, and \cref{tab:compositional-vocabulary} enumerates the syntactic variations.

% \begin{figure}
%     \centering
%     \includegraphics[width=\linewidth]{images/compositional-templates.png}
%     \caption{Compositional constraints in AIDL illustrated for the positive horizontal axis.}
%     \label{fig:compositional-templates}
% \end{figure}

% % Please add the following required packages to your document preamble:
% % \usepackage{multirow}
% \begin{table*}[]
% \centering
% \caption{Compositional constraint names for templated constraints in AIDL. The template corresponds to those in \cref{fig:compositional-templates}. Direction indicates if the constraint applies in the positive or negative direction along an axis (left blank if inapplicable). The right side of the table shows the colloquial names and synonyms given to the template in along each of the axial directions. For each Vertical and Longitudinal constraint X, there is also an X3D constraint that uses the 3D axis conventions described above. Some templates also have ``Planar'' and ``Volumetric'' versions that apply across more than one axis at a time. Planar constraints apply on the vertical and longitudinal axes, while Volumetric apply on all three. Aside from Apart, which fixes the Euclidean distance between two bounding box centers, Planar and Volumetric constraints simultaneously apply the single-axis versions of their Template.}
% \small
% \begin{tabular}{lllllll}
% \hline
% \multirow{2}{*}{\textbf{Relation}} & \multirow{2}{*}{\textbf{Direction}} & \multicolumn{5}{c}{\textbf{Names(s)}} \\ \cline{3-7} 
%  &  & \textbf{Horizontal} & \textbf{Vertical} & \textbf{Longitudinal} & \textbf{Planar} & \textbf{Volumetric} \\ \hline
% Further & + & RightOf & Higher & \begin{tabular}[c]{@{}l@{}}FurtherForward, \\ ForwardOf\end{tabular} &  &  \\
%  & - & LeftOf & Lower & \begin{tabular}[c]{@{}l@{}}FurtherBackward, \\ BackwardOf\end{tabular} &  &  \\
% Beyond & + & \begin{tabular}[c]{@{}l@{}}ToTheRightOf\\ FullyRightOf\end{tabular} & \begin{tabular}[c]{@{}l@{}}Above, \\ FullyAbove\end{tabular} & \begin{tabular}[c]{@{}l@{}}InFront, \\ FullyInFront\end{tabular} &  &  \\
%  & - & \begin{tabular}[c]{@{}l@{}}ToTheLeftOf\\ FullyLeftOf\end{tabular} & \begin{tabular}[c]{@{}l@{}}Below, \\ FullyBelow\end{tabular} & \begin{tabular}[c]{@{}l@{}}Behind, \\ FullyBehind\end{tabular} &  &  \\
% Aligned & + & RightAligned, AtRight & \begin{tabular}[c]{@{}l@{}}TopAligned, \\ AtTop\end{tabular} & \begin{tabular}[c]{@{}l@{}}FrontAligned, \\ AtFront\end{tabular} &  &  \\
%  & - & LeftAligned, AtLeft & \begin{tabular}[c]{@{}l@{}}BottomAligned, \\ AtBottom\end{tabular} & \begin{tabular}[c]{@{}l@{}}BackAligned, \\ AtBack\end{tabular} &  &  \\
% Centered &  & \begin{tabular}[c]{@{}l@{}}HorizontallyCentered,\\ HorizontallyAligned,\\ CenteredHorizontally,\\ AlignedHorizontally\end{tabular} & \begin{tabular}[c]{@{}l@{}}VerticallyCentered,\\ VerticallyAligned,\\ CenteredVertically,\\ AlignedVertically,\end{tabular} & \begin{tabular}[c]{@{}l@{}}LongitudinallyCentered,\\ LongitudinallyAligned,\\ CenteredLongitudinally,\\ AlignedLogitudinally\end{tabular} & \begin{tabular}[c]{@{}l@{}}Centered, \\ CenteredWith\end{tabular} & Colocated \\
% Abutting & + & AbuttingRight, OnRight & \begin{tabular}[c]{@{}l@{}}Atop, OnTop, \\ AbuttingTop\end{tabular} & OnFront, AbuttingFront &  &  \\
%  & - & AbuttingLeft, OnLeft & \begin{tabular}[c]{@{}l@{}}AbuttingBelow, \\ AbuttingBottom, \\ On Bottom\end{tabular} & OnBack, AbuttingBack &  &  \\
% Equally Spaced &  & HorizontallySpaced & VerticallySpaced & LongitudinallySpaced &  &  \\
% Fixed Spacing &  & HorizontalSpacing & VerticalSpacing & LongitudinalSpacing &  &  \\
% Equally Distributed &  & HorizontallyDistributed & VerticallyDistributed & LongitudinallyDistributed &  &  \\
% Fixed Distribution &  & \begin{tabular}[c]{@{}l@{}}HorizontallyApart,\\ HorizontalDistance\end{tabular} & \begin{tabular}[c]{@{}l@{}}VerticallyApart,\\ VerticalDistance\end{tabular} & \begin{tabular}[c]{@{}l@{}}LongitudinallyApart,\\ LongitudinalDistance\end{tabular} &  & \begin{tabular}[c]{@{}l@{}}Apart,\\ Distance\end{tabular} \\
% Contained &  & HorizontallyInside & VerticallyInside & LongitudinallyInside & Inside & \begin{tabular}[c]{@{}l@{}}Surrounded, \\ Within\end{tabular} \\
% Contains &  & HorizontallyContains & VerticallyContains & LongitudinallyContains & Contains & \begin{tabular}[c]{@{}l@{}}Surrounds,\\ FullyContains\end{tabular} \\
% Overlap &  & \begin{tabular}[c]{@{}l@{}}HorizontallyOverlap,\\ HorizontallyIntersect\end{tabular} & \begin{tabular}[c]{@{}l@{}}VerticallyOverlap,\\ VerticallyIntersect\end{tabular} & \begin{tabular}[c]{@{}l@{}}LongitudinallyOverlap,\\ LongitudinallyIntersect\end{tabular} & \begin{tabular}[c]{@{}l@{}}Overlap,\\ Intersect\end{tabular} & \begin{tabular}[c]{@{}l@{}}Collide,\\ Intersect3D\end{tabular} \\
% Between &  & HorizontallyBetween & VerticallyBetween & LongitudinallyBetween &  & Between \\
% Equally Sized &  & EqualWidth & EqualHeight & EqualDepth &  &  \\
% Fixed Size &  & Width & Height & Depth &  &  \\
% Larger Size &  & Wider & Taller & Deeper &  &  \\
% Smaller Size &  & Narrower & Shorter & Shallower &  & 
% \end{tabular}
%     \label{tab:compositional-vocabulary}
% \end{table*}

% \subsection{Library}

% box, rect, rectangle
% square
% triangle
% right\_triangle(base, height), (base, height, x, y), (base, height, (x,y))