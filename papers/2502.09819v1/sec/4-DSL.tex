

\section{AIDL - A Language for AI Design}
\label{sec:dsl}




In this section, we present \langname{}, a CAD DSL for LLM-generated designs.



\subsection{LLM Analysis and Design Goals}
\label{sec:analysis_llm}
We review the strengths and weaknesses of LLMs and formulate design goals that our DSL should support.


\paragraph{Direct vs. indirect computation}
% In their seminal paper, \cite{bubeck2023sparks} observe that GPT-4 is unable to solve mathematical equations directly, but that it can make correctly use of external math libraries. 
% Similarly, \cite{makatura2023can} show that with a simple CSG DSL, geometric primitives often intersect each other and parts can be disconnected, but using a query-based CAD DSL, GPT-4 more successfully constructs connected objects.
% These results suggest that LLMs perform better in tandem with external solvers.
% For CAD, we want to give the LLM the means to express design intent not through direct computation, but by specifying geometric relationshiops.
% \cite{bubeck2023sparks} note that GPT-4 struggles with solving equations directly but performs well when using external math libraries. Similarly, \cite{makatura2023can} show that a simple CSG DSL often leads to intersecting and disconnected parts, whereas a query-based CAD DSL allows GPT-4 to create more connected objects. 
Findings by \cite{bubeck2023sparks} and \cite{makatura2023can} suggest LLMs perform better with external solvers. For CAD, we aim to enable LLMs to express design intent by specifying geometric relationships instead of performing direct computation. In modern CAD tools, geometric relationships can be defined using implicit dependencies or explicit constraints, each with trade-offs. Geometric dependencies create implicit constraints that are easy to enforce, but long chains of references are challenging to reason over \citep{makatura2023can}. 
Users typically avoid this issue by generating references automatically through CAD state interaction rather than writing CAD code directly. Explicit constraints, like those in CAD sketches or assemblies are easier to reason about, but harder to solve. It is also challenging to add just the right number of constraints so that the system is neither 
often under-or over-constrained. 
To achieve the best of both worlds, we aim to support both \emph{implicit constraints through geometric dependencies (\dgone{})} and \emph{specification of geometric relationships via constraints (\dgtwo{})}. 


\paragraph{Named variables and semantic cues}
LLMs are designed to manipulate words, i.e., terms with semantic meaning.
In their experiments, \cite{makatura2023can} reparametrize CSG programs with and without informing the LLM about the modeled object.
Their results suggest that better reparametrizations are obtained by providing additional semantic knowledge.
% In computational design DSLs, users can employ semantic variables or named constraints, but they are not required to.
% For example, programmers using OpenSCAD can directly specify dimensions and automatically generated FeatureScript programs in Onshape are tedious to parse. 
% In particular, we note that queries can quickly increase in \emph{semantic complexity} making them harder to use for LLMs.
Our CAD DSL should use \emph{intuitively named terms (\dgthree{})} for design operations, references and constraints.
Our language should also expose geometric entities easily, without many semantic indirections.

\paragraph{Design complexity and modularity}
\cite{bubeck2023sparks} observe that GPT-4 can generate ``syntactically invalid or semantically incorrect code, especially for longer or more complex programs." Similarly, \cite{makatura2023can} note that complex designs may miss components or have them incorrectly placed. To address this, our CAD DSL should treat \emph{hierarchical design that supports modularity (\dgfour{})} as a first-class construct, enabling the breakdown of complex problems into manageable units. This hierarchy should facilitate planning and iteration in code generation.


%Real-world designs can be arbitrarily complex and the industry has developed several layers of abstraction for designs, such as sketches, parts, multi-parts and assemblies.
%Since in our case designs are primarily represented as programs, LLMs capabilities to scale to complex designs should correlate with their capability to scale to complex code.

%\cite{makatura2023can} experiment with complex designs, such as a cabinet with multiple shelves and a tricycle design with multiple components.
%In particular, we want to enable the evaluation of only partially complete designs. |
% One of the proposed strategies for dealing with increased complexity is to introduce "subassemblies".
% However, a complex design can still be challenging to generate if the entire task is tackled all at once.
% In both programming \cite{bubeck_sparks_2023}, and in design \cite{makatura2023can}, up-front planning and iteration lead to better results.
%\cite{makatura2023can} often obtain more complex results after rounds of iteration during which the LLM tries to correct its previous proposal.
%Similarly, \cite{bubeck2023sparks} experiment with arithmetic problems which GPT-4 does not manage to solve when asked directly for a solution.
%However, when asked to plan the solution approach and to explain it, it arrives at the correct result.

\jz{
\begin{table}[!ht]
\centering
\caption{We review how well the three major CAD DSL groups align with our design goals.
Neither of the existing paradigms complies with all of the desiderata.\maaz{I like captions and figures that are self sufficient. Consider: "None of the three major CAD DSL (csg, constraing based and query based dsls) groups achieve our formulated design goals. A brief summary of why}}
\label{tab:cad_dsls}
\renewcommand{\arraystretch}{1.2}
\footnotesize % Reduce font size
\resizebox{0.8\columnwidth}{!}{%
\begin{tabular}{|c|c|c|c|c|}
    \hline
    \textbf{Language} & \dgone{} & \dgtwo{} & \dgthree{} & \dgfour{} \\
    \hline
    CSG & - & - & \cmark & \cmark \\
    Constraint-based & - & \cmark & \cmark & - \\
    Query-based & \cmark & - & - & - \\
    \langname{} (Ours) & \cmark & \cmark & \cmark & \cmark \\
    \hline
\end{tabular}
}
\end{table}

}

None of the existing CAD DSLs fully support all of these design goals, as shown in Table \ref{tab:cad_dsls}. CSG DSLs are inherently hierarchical and can have intuitively named operations, but they do not support constraints, either implicitly through references or explicitly. Query-based DSLs allow implicit constraints via dependencies, but since references must be solved for though queries, they cannot be named directly, reducing semantic clarity. This also impacts modularity, as queries create chains of dependencies between distant parts of the program. Constraint-based CAD DSLs use intuitively named constraints, such as ``coincident" or ``symmetric," but they do not generate dependencies and lack hierarchy, as constraint solving is performed globally over a flat design.


% Notably, non of the existing CAD DSLs support all of these designs goals, as  shown in Table \ref{tab:cad_dsls}. CSG is hierarchical by nature and operations can be intuitively named.
% However, CSG DSLs do not enable users to specify constraints, neither implicitly via references nor explicitly via constraints. Query-based DSLs allow implicit constraints through dependencies, but because references need to be solved for, they cannot be named directly, compromising on semantics. This also compromises modularity,  since queries create a chain of dependencies between distant parts of the program. Constraint-based CAD DSLs feature constraints between geometric entities, which are often intuitively named---e.g., "coincident" or "symmetric", but they do not create dependencies (\dgone{}). 
% They further lack hierarchy, since solving constraints is performed in a global pass over a flat design. 



\subsection{Key Challenges and DSL Design Decisions}

% The goal of \langname{} is to fulfill the four design goals from Sec.~\ref{sec:analysis}. 
Combining all of the goals above in a single CAD DSL requires addressing two key challenges.

% The first is creating dependencies on previously constructed geometry (\dgone{}) without increasing the semantic complexity of operators (\dgthree{}). 
% As explained in Sec.~\ref{sec:background}, 
% previously constructed  geometry cannot be persistently named because parametric valiaations often lead to topological changes, so DSLs that reference   e previously constructed  geometry use queries, which are essentially algorithms in their own write that retrieve the geometry at a given state -- e.g. an edge where we will apply a fillet.  This means that goemtris cannot be semantically named increatind semantic complexity. 

The first challenge is creating dependencies on previously constructed geometry (\dgone{}) without increasing the semantic complexity of operators (\dgthree{}). 
As explained in Sec.~\ref{sec:background}, previously constructed geometry cannot be persistently named because parametric variations often lead to topological changes. DSLs that reference previously constructed geometry use queriesâ€”algorithms that retrieve the geometry at a given state. However, this solution prevents assigning persistent semantic names to geometric entities, increasing semantic complexity and, our analysis shows that LLMs struggle to reason about queries with long chains, motivating our choice to disable them by design.



Our solution to enable dependencies without queries arises from the observation that all geometric primitives in CAD are created either through constructive operations that instantiate primitives or through boolean operations (e.g., when two edges intersect, a new vertex is generated). While this is evident for CSG DSLs we note that query-based CAD DSLs are not more expressive than CSG DSLs since all CAD operators (e.g. chamfering) can be expressed as a combination of a constructive and a boolean operation \cite{cascaval2023lineage}.
Reference challenges emerge from boolean operations, as changes in parameters can lead to a varying number of generated primitives.

While we still want the geometric expressivity enabled by boolean operations, we want to reference geometry without queries. % since our analysis, see Sec.~\ref{sec:analysis_llm}, shows that LLMs are struggling to reason about queries with long chains, motivating our choice to disable them by design.
To overcome this problem, we decide to restrict our DSL to only use references for geometry created before boolean operations. 
In our DSL, boolean operations are applied to \emph{structures}, which is an intermediate type to create tree-structured hierarchies, see Fig.~\ref{fig:language-grammar}.
The result of these booleans cannot be referenced, just as with CSG DSLs, however, we can reference \emph{constructed} geometry and structures themselves. 
Although this introduces a language limitation, it does not affect 1) geometric expressivity, since in the worst case, you can have one geometry per structure, achieving the same expressiveness as CSG, and 2) dependency expressivity, as AIDL allows for arbitrary parametric expressions, meaning that in the worst case, dependencies can still be expressed manually, albeit with more effort. %\adriana{and because we also allow for parametric expressions to be explicitly written down, it also does not impact variability expressivess - say that in an understandable way}
%Further, our analysis, see Sec.~\ref{sec:analysis_llm}, shows that LLMs are struggling to reason about queries with long chains, motivating our choice to disable them by design. 
%Importantly, this gives us the same geometric expressivity as typical CAD DSLs, while being able to reference most geometry and without resorting to queries.
%Note that query-based CAD DSLs are not more expressive than CSG DSLs since all CAD operators can be expressed as a combination of a constructive and a boolean operation \cite{cascaval2023lineage}.

%In other words, we opt for a trade-off which allows us to reference unaltered geometry and to consider boolean operations as post-construction step.
%This allows us to benefit from the geometric expressive power of boolean operations without resorting to queries. 

%In practice, we do not even feature explicit boolean operator in our language, but we define types of geometry as either additive or subtractive, thus disabling by design the referencing of newly created geometry.

Second, using constraints (\dgtwo{}) to specify the relationship between elements within hierarchical designs (\dgfour{}) is computationally challenging.
Hierarchical designs encourage growing complexity and an increasing number of constraints, driving down solver performance. 
Query-based languages deal with this complexity by solving constraints in intermediate, \emph{flat} designs, e.g constraints between sketch elements in a CAD sketch are first solved before the user can extrude the sketch.
Solving constraints from all CAD operations simultaneously is computationally too expensive for these systems. 
To tackle this challenge, we introduce (1) two types of constraints, one between geometry and one between \emph{structures}, and (2) a custom recursive solver to hierarchically solve constraints in a design.
This strategy allows us to explicitly define the hierarchy of constraints and to practically solve it, without providing intermediate feedback to the LLM.

% In summary, \langname{} is a hybrid DSL which allows users to reference \emph{constructed} geometry \textbf{(DG1)}, to benefit from boolean operations, to apply constraints between geometry and hierarchical structures \textbf{(DG2)}, to explicitly define hierarchical designs \textbf{(DG4)} and to use constraints and references with minimal semantic effort \textbf{(DG3)}.

%Central to the design of AIDL are three key considerations. First, we propose a \textit{solver-aided approach} that aligns with best practices in using Large Language Models (LLMs). This approach enables LLMs to concentrate on high-level reasoning while offloading computational tasks to external solvers. Second, we advocate for a \textit{hierarchical design approach}, which allows for encapsulating reasoning within different model parts. This facilitates developing and validating each section independently, providing recursive feedback to the LLM. Finally, we aim to create s\textit{emantically meaningful constructs} that leverage the LLM's proficiency in understanding and manipulating language.


% Next, we showcase \langname{} by example and show how the different language constructs fulfill our design goals.
% We start with a simple design to show how our DSL invokes external solvers.
% Then, a more complex design showcases how to construct hierarchical models in AIDL.
% The full language grammar for AIDL is shown in Fig.~\ref{fig:language-grammar}.

%Design Decisions
%Syntax Description
%Interpretter / Compiler (use keywords like type-checking)
% - show example with clapper with delayed type-checking before vs. after
%Hierarchical Solver - we'd rather have rel positions of parts than everything be free
%
%Syntax; introduce constructs in an order that does not depend on each other
% \begin{figure*}[!ht]
% %\begin{multicols}{2}  % This will split the inside of the figure into two columns
% \begin{tabular}{m{0.5\linewidth}|m{0.5\linewidth}}
% \centering
% %\lstset{moredelim=[is][\color{red}]{[*}{*]}, 
% %basicstyle=\ttfamily, numbers=left,numberstyle=\small, stepnumber=1, firstnumber=1, numberfirstline=true,  breaklines=true, postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}, language=Python, escapechar=$,
% \lstset{
% moredelim=[is][\bfseries\color{cbbrown}]{[b}{b]}, 
% moredelim=[is][\bfseries\color{cbpurple}]{[pu}{pu]}, 
% moredelim=[is][\bfseries\color{cbpurple}]{[g}{g]}, 
% moredelim=[is][\bfseries\color{cbpink}]{[pi}{pi]}, 
% %basicstyle=\ttfamily, 
% numbers=left,
% numberstyle=\footnotesize, 
% stepnumber=1, 
% firstnumber=1, 
% numberfirstline=true,  
% breaklines=true, 
% postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}, 
% %language=Python, 
% escapechar=$,
% basicstyle=\scriptsize}
% \begin{lstlisting}[escapechar=$]
% # 1) Create hierarchy
% phone = Solid() 
% phone.handset = Solid()
% phone.base = Solid()
% base_solid = Solid()
% base_hole = Hole()
% phone.dial = Solid()
% # 2) Specify geometry of structures
% phone.handset = ... # program from Fig.$\ref{fig:phone_handset}$
% base_solid = ... #
% base_hole = ... #
% phone.dial = ... #
% # 3) Compositional constraints between structures
% phone.AddConstraint(Centered(
%     phone.base, phone.dial))
% phone.AddConstraint(Above(phone.handset, phone.base, 3*mm))
% # more constraints ...
% # 4) Boolean composition
% phone.base.base_solid = base_solid
% phone.base.base_hole = base_hole
% # 5) Solve system
% solved = phone.Solve()
% \end{lstlisting} &

% \centering
% \includegraphics[height=7cm]{images/phone_full.pdf}
% %\begin{tikzpicture}[remember picture, overlay]
% %$    \highlight{cbbrown}{hl1Start}{hl1End}
% %\end{tikzpicture}   
% %\end{multicols}
% \end{tabular}
% \caption{Design of a phone assembly. (Left) \langname{} code for hierarchical design. (Right) Hierarchical tree structure of design. Solids are marked in \textbf{\color{cbpurple}{Purple}} and the Hole is marked in \textbf{\color{cborange}{Orange}}.}
% \label{fig:phone_full}
% \end{figure*}
\subsection{\langname{} by example}
\label{sec:references_constraints}

\begin{figure*}[!ht]
\centering
\includegraphics[width=\linewidth]{images/handset_lineno.png}
%\begin{multicols}{1}  % This will split the inside of the figure into two columns
% \begin{tabular}{m{1\linewidth}}
% \begin{tabular}{c|c}
% %\centering
% \includegraphics[width=0.4\linewidth]{images/phone_before_constraints.pdf} &
% %\centering
% \includegraphics[width=0.4\linewidth]{images/phone_after_constraints.pdf} 
% \end{tabular}

% \hrulefill

% \lstset{
% moredelim=[is][\bfseries\color{cbbrown}]{[b}{b]}, 
% moredelim=[is][\bfseries\color{cbpurple}]{[pu}{pu]}, 
% moredelim=[is][\bfseries\color{cbpurple}]{[g}{g]}, 
% moredelim=[is][\bfseries\color{cbpink}]{[pi}{pi]}, 
% % basicstyle=\tiny\ttfamily, 
% numbers=left,
% numberstyle=\scriptsize, 
% stepnumber=1, 
% firstnumber=1, 
% numberfirstline=true,  
% breaklines=true, 
% postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space}, 
% %language=Python, 
% % escapechar=$,
% basicstyle=\scriptsize}
% \begin{lstlisting}
% # 1) Create structure and geometric primitives
% handset = Solid() 
% handset.base = Rectangle( Point(0, 0), 5, 1)
% handset.left_round = Arc(Point(-3, 0), handset.base.top_left, Point(-4, -1.5))
% handset.left_line = Line(handset.left_round.end, Point(-3, -1.5))
% handset.right_round = Arc(Point(3, 0), Point(4, -1.5), Point(2.5, 1))
% handset.right_line = Line(Point(2, -1), Point(4, -1))
% ... # more primitives
% # 2) Add constraints
% handset.AddConstraint(Coincident(handset.right_round.end, handset.base.top_right))
% handset.AddConstraint(Horizontal(handset.left_line))
% handset.AddConstraint(Equation(handset.left_line.length == handset.right_line.length))
% handset.AddConstraint(HorizontallySymmetric(handset.left_round.center, handset.right_round.center))
% handset.AddConstraint(Equal(handset.left_fillet, handset.right_fillet))
% handset.AddConstraint(Diameter(handset.left_fillet, 1.5))
% ... # more constraints
% # 3) Solve system
% solved = handset.Solve()
% \end{lstlisting} 
% \end{tabular} 

%\begin{tikzpicture}[remember picture, overlay]
%$    \highlight{cbbrown}{hl1Start}{hl1End}
%\end{tikzpicture}   
%\end{multicols}
\caption{AIDL allows LLMs to express constraints using semantically meaningful operators. This figure demonstrates how adding constraints (highlighted in red) in an AIDL program for a phone handset eliminates geometrical flaws in the generated 2D sketch. 
(\textbf{Left}) \langname{} code for handset design.
(\textbf{Top right}) Design before constraints applied.
(\textbf{Bottom right}) Design after constraints applied.}
\label{fig:phone_handset}
\end{figure*}

Next, we showcase \langname{} by example and show how the different language constructs fulfill our design goals. First, we will illustrate the basic constructs of \langname{} with the phone handset example in Fig.~\ref{fig:phone_handset}.
An \langname{} program starts by defining the high-level logic of a design.
These high-level building blocks are called structures and they are of different types, such as $\verb|Solid|$ and $\verb|Hole|$, and they can be empty, a list of primitives, a list of substructures or any combination of these, see Fig.~\ref{fig:language-grammar}.

In the handset example, we first define an empty structure, L.2, which we populate with primitives, such as rectangles, lines and arcs, L.3-L.8.
Next, we add unary and binary geometric constraints, e.g. Horizontal and Coincident, between these primitives, L.10-L.16.
Finally, we solve the constraint system to optimize for the final parameters of each geometric primitive, L.18.

\paragraph{References}
%The first major language construct in \langname{} are references.
In \langname{}, references are pointers to geometry, parameters or structures. They have various usages.

First, instead of specifying coordinates directly such as in L.3, we can use references to reuse already defined geometry.
For example, in L.4, we define an Arc, which in the \langname{} API is defined via $\verb|Arc(center, start, end)|$.
The $\verb|left_round|$ arc starts at the upper left corner of the $\verb|base|$ rectangle via the reference $\verb|handset.base.top_left|$.
This strategy lowers the risk of erroneously recomputing coordinates of the upper left point.
%Using this reference, we do not risk making an error in computing the coordinates for the upper left point of the $\verb|base|$ rectangle.
Second, this reference ensures that $\verb|base|$ and $\verb|left_round|$ stay attached during the constraint solving process.
Indeed, by sharing a common point, we \emph{implicitly} define a coincidence constraint between them.

Geometric primitives can also be referenced within constraint calls.
In L.10, we \emph{explicitly} define a coincidence constraint between the upper right corner of $\verb|base|$ and the end point of the arc $\verb|right_round|$.
The arc $\verb|right_round|$ has been defined with explicit coordinates in L.6, which, without further constraints, is not necessarily connected to the rest of the shape, see Fig.~\ref{fig:phone_handset} (top right).

Lastly, as can be seen in Fig.~\ref{fig:language-grammar}, references can also point to parameters of geometric primitives.
This allows for more control and more expressivity when defining geometry and constraints.
Consider L.12, where we used equation constraints to express a symmetric design intent on the two lines $\verb|left_line|$ and $\verb|right_line|$.
L.12 declares that both lines should have the same $\verb|length|$, which is a parameter of the $\verb|Line|$ primitive.
%L.19 states that the $\verb|v|$ parameters, i.e., the vertical parameter of both lines' endpoints should be the same.
Parameters are referenceable on the same level as geometry and structures, making them first-class constructs in our language.

\paragraph{Constraints}
Constraints express design intent, i.e., the way that geometry should behave under change.
As we have already seen, in \langname{}, constraints can be implied by sharing a reference, see L.4, or by explicitly adding them to the design via $\verb|AddConstraint|$ calls.
Constraint operations have a certain constraint type and they take as input references.
Depending on the constraint type, either equality or inequality constraints will be enforced on the geometric parameters specified by the input references.
For example, in L.14, the $\verb|Equal|$ constraint type enforces the $\verb|diameter|$ of the two arcs $\verb|left_fillet|$ and $\verb|right_fillet|$ to be the same.

Using references and constraints, we can explicitly state the design intent, which will be realized by an external solver, L.18, (\dgone{}), (\dgtwo{}).

\mlcomment{
-- necessary, basic features. Solver-aided
How to construct something minimal in our language?
Get familiar with the syntax.
Here, we want to talk about references and constraints.

Simple example: ..
We create primitives.
We set constraints between these geometric primitives.
1. Explicit constraints because LLMs bad at global positioning
2. Explicit constraints can be written as arbitrary equations.
6. Solver comports with LLM best practice of using external tools
What we can see here are explicit constraints between geometric entities.
Geometric entities are being \emph{referenced} by constraints.

However, constraints can also be implicitly created by references. Dualism between references and constraints.
As you can see in the example, a point has a reference to two lines. This creates an implicit constraint.
4. Implicit constraints can be specified by shared references
(\dgone{}),
\textbf{(DG2)}

So far, we have talked about constraints and references between geometric entities.
But as you might have noticed on line N, something else has been referenced: a parameter.
11. In our DSL parameters and constants are first class citizens. The leaf nodes are parameters and constants, which allows for arbitrary relationships and referenced expressions (e.g. length, width, etc.). Allows for the specification of non-local and inequality relations
}

\paragraph{Synonymous operators}
%--- Redundancy and Reachability/Referenceability
References and constraints in a DSL are useful if they are easy to use.
For human users, learning a new DSL can be challenging if its API is long and redundant.
Concise APIs are usually preferred.
However, designing a DSL for LLMs introduces a different criteria, which is that the LLM might write a function call which is not part of the API, but which is semantically equivalent.
For example, consider the two constraint calls: (1) \iverb{AddConstraint(Perpendicular( line_1, line_2))} and (2) \iverb{AddConstraint(Orthogonal( line_1, line_2))}. 

Intuitively, both $\verb|Perpendicular|$ and \iverb{Orthogonal} should enforce the same angle between the two lines, i.e., they are synonyms.
However, to reduce redundancy, most APIs will choose only one of them.
In \langname{}, we expose both constraint types, to account for syntactical weaknesses of LLMs and to take advantage of their semantic versatility (\dgthree{}).
More generally, we opt for a robust API vocabulary, allowing for different ways of constructing primitives, e.g. \iverb{Triangle(center, base, height)} vs. \iverb{Triangle(pt_a, pt_b, pt_c)}.% and synonymous combinations of compositional constraints, e.g. $\verb|Underneath|$ is equivalent to $\verb|Below|$ plus $\verb|HorizontallyInside|$. \ben{Compositional constraints are no longer named}

%References and constraints are great, but they can be complex to use.
%We can make them more accessible to LLMs by providing redundancy.
%Talk about the trade-off between uniqueness and synonyms, a DSL for people vs. for LLMs.
%New example here.
%3. Explicit constraint can be specified from a library of semantically meaningful relationships
%8. Robust vocabulary. Verbose semantically named constructs give the LLM a lot of natural ways to refer geometry and describe relationships. (many named constraints, many paths to references, many named expressions). Many synonyms. Natural languages tend to prefer conciseness given by a larger vocabulary, so create many variations and pre-named objects and constraints. (coding languages vs natural languages)
%\textbf{(DG3)}
%References can also be constructed synonymously, e.g. the lower left point of a rectangle can be referenced via \iverb{rect.bottomLeft} or \iverb{rect.bottom.start}.

Note that even though we have synonymous references in \langname{}, they are all being compiled to unique identifiers.
During the interpretation of the program, we include only referenced entities in the model.
%As such, referenceability, reachability by references, is the actual definition of the design's constituent entities. 

%\adriana{worth adding at some point that we can also have multiple names for references for example bottom left of rectagle or rectangle.bottom endge, left point (I don't know the exact syntax)}
%\felix{It would be \iverb{rect.bottomLeft} or \iverb{rect.bottom.start}. But there is no notion of "left" for a line. So this doesn't really work. I don't know if there's a good example for synonymous references.}

%\felix{What about persistent naming?}

%These redundant references are being solved/compiled to unique identifiers.
%In our language, being able to reference entities is not only a gimmick, but referencability, i.e., reachability by references, defines what is actually included in the model.
%Redundancy helps us to ensure that the LLM can effortlessly define a model.
%7. Reachability by named references defines inclusion into model -> everything has a meaningful name, and potentially more than one for different contextual meanings (corner vs end, etc.) We can name everything that exists at solve time (e.g. user or LLM can express). ``All refs can be reached by persistent, semantic name''. No need for queries, all references are valid forever (persistent naming).



\paragraph{Hierarchical designs}
Next, we illustrate the use of hierarchical designs with a complete phone design, see Fig.~\ref{fig:teaser}.
%The handset example in Fig.~\ref{fig:phone_handset} is a flat design, where all geometric primitives are equally important and all constraints are solved at the same time.
%To achieve more complex outcomes, \langname{} allows for hierarchical designs.
%In this section, we refer to the phone design shown in Fig.~\ref{fig:phone_full}.
%Hierarchical designs start by specifying the high-level structure.
The phone is an assembly made out of three different structures, the $\verb|base|$, $\verb|receiver|$ and $\verb|dial_plate|$, which are all $\verb|Solid|$ structures.
These structures are directly attached to the $\verb|telephone|$ structure on lines 5, 9 and 13.
As for the handset design in Fig.~\ref{fig:phone_handset}, each structure defines its own geometry and and constraints, e.g. the constraints for the receiver, L.20-21.
Constraints can also be enforced between structures, which will be solved iteratively in tandem with structure-internal constraints, see Sec.~\ref{sec:solver}.
%Next, we specify the geometry and the internal constraints for each structure, L.9-L.12.
%An example for this is the phone handset from Fig.~\ref{fig:phone_handset}.
%Then, we specify constraints between structures, L.14-L.17.
%For example, the constraint operation \iverb{CenterInside( phone.base, phone.dial)} places the dial in the middle of the base.
%Constraints between structures act on the respective bounding boxes, for more details, see Sec.\ref{sec:solver}.
%Then, we specify boolean operations between structures.
%Here, the phone base is a result of a solid shape from which we cut out a hole to place for the dial, L.19-L.20.
%Finally, we solve the entire, hierarchical design in L.21.

%The structure of this example program closely matches our code generation strategy described in Sec.~\ref{sec:code_generation}.
%Here, we follow with a few remarks about the language constructs which enable this strategy.
%
%In our top-down approach, we encourage planning ahead by first building up a tree structure, see Fig.~\ref{fig:phone_full} (right) with empty nodes.
%In \langname{}, at any point in time we have a valid design since structures can be empty, see Fig.\ref{fig:language-grammar}.
%In other words, we allow for partial evaluation, which we realize by instantiating empty structures with virtual bounding boxes.

Finally, in \langname{}, the result of a boolean operation cannot be referenced, since the parameter-dependent topological outcome requires queries, see Sec.~\ref{sec:analysis_llm}.
To implement this, boolean operations are implied by using different structure types and then applied after constraint solving in a boolean post-process.
%In L.5-L.6, we define two structures as \iverb{Solid} and as \iverb{Hole} and in L.19-L.20, we assign them to the same parent, which realizes the desired subtraction operation seen in Fig.~\ref{fig:phone_full} (right).

%\felix{TODO: Talk about this final paragraph}
%Finally, note that even though there are multiple structures with internal geometry and internal constraints, L.9-L.12, there is only a single solve at the end, L.21.
%Whereas in traditional CAD systems, each substructure would first solve its constraint, fix the geometry, and then define subsequent substructures, in \langname{}, we first specify the entirety of the design and then perform one global, hierarchical constraint solve.
%Our approach means that we do not have to provide the LLM with feedback from intermediate solves at the cost of a more difficult, hierarchical solve, see Sec~\ref{sec:solver}. \adriana{this doesn't seem right to me. I think we do solver hierarchically and give feedback.}

\mlcomment{
-- medium features. Hierarchical language
Here, we are introducing more complex designs.
9. Tree structures allows for guided hierarchical reasoning
5. Having one global solve step removes the need to reason about intermediate solve results, disadvantages: harder solve (use references + hierarchy to help + custom solver), do not get intermediate feedback (but we want hierarchical planning instead of sequential, so make that tradeoff)
10. Allow evaluation of partial trees with empty nodes to give intermediate feedback. We are linearizing the process of planning and fulfilling plan. Explicitly describe the top-down reasoning that is usually outside of CAD tools. (LLMs are known bad at this, so we help them).
\textbf{(DG4)},
\textbf{(DG5)}

-- advanced features
Let's make our language CAD-complete by adding booleans.
12. Booleans at the end; supporting booleans allows for richer specification, by putting them at the end we maintain reference validity and completeness up to the solve. Primitives + booleans = most things you can do with CAD. (inspired by CSG). We disallow the operations with implicit booleans. Don't need to handle issues of persistent referencing.

}


\mlcomment{
several reasons to decide to not have constructive operations, we have it break down hierarchical instead. Sequential is useful when you have a human going with sequential feedback. We've made the black box of hierarchical planning visible, but to do this we needed to get rid of sequential feedback for references / queries. (terms we could use for sequential execution; coarse-to-fine modeling, embodied creativity with material in front of you) - we keep track of the plan so the LLM doesn't have to.


Uses Constraints throughout:
tradcad doesnt need global solve after everything
doesn't need to reason about intermediate solve results
LLMs bad at global positioning
External tool aligns with LLM usage
(no free lunch, makes the solve hard, so we need the tree structure + feedback)

Programmer constructed entities are all stored by reference. (Persistent naming)
- this gives them semantically meaningful and understandable names
- removes need to reason about querying
- removes need to reason about reference validity
- indirect specification of relationships through shared references (also simplifies the constraint solving problem a bit) -- don't need to reason about implicit constraints that would be found by a GUI
- all operations pre-solve create deterministic referenceable entities, so no need for queries
- existence in the model is determined by reachability (makes everything have names)

(dependencies in geometry - refering to geometry to specify constraint or construction - relationships can be specified through constraints or edits. In trad cad you)

Names belong to references -- persistent naming --> any topology changing operations happen after solving (so we know ahead of time exactly which references come out), this leads to certain geometry of the final design being unreferencable, but also means that no references can be invalidated after they are created. Tie to the LLM; doesn't need to reason about queries, validity of references, etc., plus uses names that are easy for it to understand. References also allow for the indirect specification of relationships through reference sharing. (We don't have selectability completeness)

Tree Structured Models (with DAG leaves for geometry and expressions)
- breaks down global solve
- gives multiple meaning names

Name tree relationships and DAG relationships -> multiple semantically meaningful references that are context based



% Questions: Organize goals -> decisions or decisions <- goals?
% 
%

In this section we translate the design goals into concrete design decisions, including language limitations and tradeoffs.

Design Decisions / Key Constructs

Hierarchical Model Structure:
Booleans (e.g. constructive operations) after solve. This allows for references to be deterministic while the program is running, so we do not need queries, which would be difficult for an LLM to reason about. The compromise here is that some entities in the final design, e.g. topology that comes into being as a result of final, solved operations, are unreferenceable.

Indirect Specification of geometry and geometric relationships:
This leads to a few choices, namely the combination of constraints, parameters, and references for both geometry and parameters. Since parameters are stored and passed by reference, geometry can be implicitly related by sharing references (e.g. a rectangle stays together by its edges sharing references to the corner points rather than an explicit constraint equation saying their endpoints are coincident). Constraints allow indirect specification of relationships in the sense that the LLM does not need to construct objects to directly have particular relationships.

Geometric Constraints:

Compositional Constraints:

Direct Access to Parameters and directly expressible constraint equations:
In traditional GUI-based CAD, every reference and constraint needs to be visually expressible in order to be able to be operated upon by the user. Since this is a programming language based approach, we can and do support arbitrary constraint expressions.

Verbose Language with Semantically Meaningful Names:
This comes in two parts. One is in the language's standard library, which contains many natural sounding synonyms for describing constraints (above, on top of, below, underneath, etc.). The other is in the requirement that the relationships in the hierarchy are all named. This creates context dependent, named references for the each structure, geometry, and parameter (and multiple ways of referencing the same geometry since each unique reference path generates a different semantic name, e.g. start point of the bottom edge of a rectangle versus bottom left point of a rectangle).

To support planning and iteration, we allow evaluation and feedback on partial designs that contain no geometry, by allowing compositional constraints to still have meaning even when there is no geometry.    


Validate Design Decisions -- Could align to section 4 instead (key ``constructs'' / design decisions)
\begin{itemize}
    \item Indirect specification of geometry - covered by language comparison
    \item Indirect specification of geometric relationships - covered by language comparison
    \item Intuitively named operators - no sugaring, just write constraint equations
    \item Hierarchical Design - no hierarchical solve
    \item Partial Evaluation - no feedback loop
\end{itemize}


\begin{itemize}
    \item Intuitively named operators
    \item Hierarchical Design
    
    \item Partial Evaluation
\end{itemize}
}




