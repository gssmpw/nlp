\section{Task 2: Access Path Selection} \label{sec:access_path_selection}
As a second task in our study, we look at access path selection and analyze how much existing \lcms improve over classical models on this task.
An access path determines \textit{how} a database engine retrieves the requested data, with standard methods being sequential scans or index accesses. 
A key issue is that using indexes is not always faster; for small tables or queries that return a large portion of the table, the overhead of accessing the index can outweigh the benefits, making a sequential scan more efficient. 
This makes the selection of access paths a crucial task in query optimization due to its direct impact on database performance \cite{selinger1979}. 
Selecting an access path is typically done by estimating the cost and determining the path with the lowest cost.
In the following, we study whether \lcms improve over classical models by a set of experiments. 
Like before, we first report anecdotal results from individual cases and then provide an analysis with a broader set of workloads.

\subsection{Evaluation Setup}
\noindent\textbf{Experimental Setting.}
In our study, we look at the ability of \lcms to select between sequential scan and index scan using B+-trees that are both supported in PostgreSQL (internally denoted as \texttt{SeqScan}, and \texttt{IndexScan}/\texttt{IndexOnlyScan}). 
There are also other access options, such as bitmap index scans or hash scans, but these are out of the scope of our study.
We will show that even the selection between these two access paths is hard to solve for all models.
Note that the training data contains indexes on the primary keys (PKs) of \textit{all} tables, which is a common setup in databases.


\noindent\textbf{Experimental Metrics.}
For this task, in addition to the previous metrics, we introduce a new metric to describe how accurately a \lcm selects the access path when one class in the decision-making is under- or over-represented (which is often the case for access path selection as we will see in our evaluation).
\begin{definition}
\textit{Balanced Accuracy ($B$)}: Balanced accuracy $B$ assesses the performance of classification models on imbalanced outcomes as it ensures equal performance consideration for both classes.
It represents the arithmetic mean of true positive rate (TPR) and true negative rate (TNR) as follows:
$B = \frac{1}{2} \left( \text{TPR} + \text{TNR} \right)$ with $\text{TPR} = {TP}/(TP + FN)$ and $\text{TNR} = {TN}/(TN + FP)$ and $B \in [0, 1]$.
\end{definition}


%------------------------------------------------------
\subsection{Example Query \& Metrics} \label{subsec:access_path_anecdotal}
To get an intuition about the access path selection of \lcms, we first analyze how \lcms predict execution costs for either high or low selectivity.
In the following, we will first present an intuitive example to demonstrate our approach and the new metrics before we later present a broader study across various columns.
We select a query that filters on the column \texttt{production\_year} of the table \texttt{title} of the IMDB dataset.
This column contains the production year of different movies and ranges from 1880 to 2019.
Note that the data distribution is skewed, as more movies were produced over a certain period of years.
We perform two corresponding base table accesses on \texttt{production\_year}, each with either \texttt{IndexScan} and \texttt{SeqScan}.
To achieve a low selectivity, we use the attribute \texttt{>=1880} (which basically selects the whole table), and for high selectivity, we use \texttt{>=2011}, which contains just $\approx 20\%$ of the entries.
We report the results in \Cref{fig:scan_cost_anecdote}, where we mark correct (\checkmark) and incorrect (\text{\sffamily X}) access path selections based on the \lcm predictions.
Moreover, we present the actual runtimes and the model predictions for both scenarios.
For the low selectivity query \circles{A}, we can see, based on the actual runtime (left-most two bars), that the sequential scan is indeed faster (0.71s) than the index scan (1.78s). 
In contrast, the high selectivity query \circles{B} is the reverse.
As we can also see, the cost predictions of the \lcms is often the opposite and lead to wrong access path selection.
In fact, five of nine models (\flatvector, \mscn, \zeroshot, \queryformer, \qppnet) select the 2.5$\times$ slower index scan for the high selectivity (shown in \circles{A}).
In contrast, for the low selectivity query (shown in \circles{B}), the sequential scan is actually  5$\times$ slower (0.35s) than the index scan (0.07s).
Only two \lcms (\mscn, \dace) select the wrong access pass. 
However, if we look at the cost estimates, we can see that estimates are for many \lcms not very indicative since the estimated runtime for scan vs. index are very close, which means that access path selection is highly unstable for this query. 
Overall, this indicates that \lcms are struggling with the correct access path selection and their accuracy changes over the selectivity.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/scan_costs_anecdote.pdf}
    \caption{Predictions for table scans on \texttt{movie.production\_year}.
    We show the real runtimes (white bars) against \lcm predictions and indicate correct (\checkmark) and incorrect (\text{\sffamily X}) selections for a high selectivity \circles{A} and low selectivity \circles{B} scenario.}
    \label{fig:scan_cost_anecdote}
\end{figure}


%------------------------------------------------------
\subsection{Access Path Selection over Selectivities}
\label{subsec:access_path_selectivity}
Next, we show the results on a broader set of selectivities over different predicates. 
To achieve this, we generate appropriate filter literals for the same query as in the previous section.
More precisely, we scan all movies by \texttt{production\_year} with the \texttt{>=} operator and vary the predicates to ensure equal steps in the domain of selectivities.
We analyze the runtime for each query by selecting the access path according to the cost estimates provided by the \lcm.
The results are shown in \Cref{fig:scan_costs_over_col}.
The real runtimes of the access methods over the selectivity for the sequential and index scans are reported on the very left.
In green, we show the runtime if a cost model selects the optimal path.
As expected, for small selectivities, it is beneficial to select an index scan (dashed line).
When the selectivity gets larger than 0.3, the sequential scan (solid line) is a better choice.
Next, we show in \Cref{fig:scan_costs_over_col} which access paths PostgreSQL selects (second \& third plot)  and contrast this with the access path selection of \lcms (fourth to last plot).
The selected access paths of the cost models are shown by a cross per query we executed.
When looking at the model selections, we see that actually \textit{no single model} always selects the correct access method.
In fact, many models always select the same access method regardless of the selectivity; more details later.
For instance, \flatvector, \zeroshot, \qppnet and \queryformer always select the index scan while other models select different access paths depending on the selectivity.
However, other models like \mscn and \etoe show a highly unstable behavior, especially for higher selectivities, where they randomly switch between access paths.
While \postgresx and \postgresxvi show the desired behavior, they also mispredict access paths for some queries having lower selectivities. 
This behavior is followed by \dace, which learns from PostgreSQL costs.

To aggregate results over the access path choices, we report the balanced prediction accuracy $B$ for each model in \Cref{fig:scan_costs_over_col} (right).
As analyzed before, both PostgreSQL models and \dace achieve the best overall balanced accuracy that reports classification performance with $B=0.62$ and outperform the remaining \lcms.
Overall, these numbers are, however, still not satisfying, as they indicate that all cost models (even classical ones) still struggle to select the best access method.

\begin{figure*}
    \centering
    \includegraphics[width=\linewidth]{figures/scan_costs_over_column.pdf}
    \caption{Real scan costs and selected runtimes over different selectivities for scanning the column \texttt{title.production\_year} of IMDB dataset with either sequential or index scan. 
    Many \lcms would select the \texttt{IndexScan} regardless of the selectivity.}
    \label{fig:scan_costs_over_col}
\end{figure*}

\begin{table}[]
\resizebox{0.8\linewidth}{!}{
\begin{tabular}{l|c|c|cc|cc|cc}
\multirow{2}{*}{\textbf{Dataset}} & \multirow{2}{*}{\textbf{\begin{tabular}[c]{@{}c@{}}Number \\ of Tables\end{tabular}}} & \multirow{2}{*}{\textbf{\begin{tabular}[c]{@{}c@{}}AVG NaN \\ ratio (\%)\end{tabular}}} & \multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Columns \\ per Table (\#)\end{tabular}}} & \multicolumn{2}{c|}{\textbf{\begin{tabular}[c]{@{}c@{}}Table \\ Length (\#)\end{tabular}}} & \multicolumn{2}{c}{\textbf{\begin{tabular}[c]{@{}c@{}}Distinct\\ Column Values (\#)\end{tabular}}} \\
 &  &  & \multicolumn{1}{c|}{min} & max & \multicolumn{1}{c|}{min} & max & \multicolumn{1}{c|}{min} & max \\ \hline
Baseball & 25 & 9.70 & \multicolumn{1}{c|}{25} & 48 & \multicolumn{1}{c|}{520} & $1.38\times10^6$ & \multicolumn{1}{c|}{2} & $1.64\times10^4$ \\ \hline
IMDB & 15 & 20.91 & \multicolumn{1}{c|}{4} & 49 & \multicolumn{1}{c|}{4} & $1.48\times10^7$ & \multicolumn{1}{c|}{2} & $3.62\times10^7$ \\ \hline
TPC-H & 8 & 0.00 & \multicolumn{1}{c|}{2} & 12 & \multicolumn{1}{c|}{5} & $1.50\times10^6$ & \multicolumn{1}{c|}{2} & $1.50\times10^6$ \\
\hline
\end{tabular}
}
\caption{Statistics of the datasets Baseball, IMDB and TPC-H used to evaluate access path selection of \lcms}
\label{tab:dataset_statistics}
\end{table}

%------------------------------------------------------
\subsection{Access Path Selection across Queries}
Here, we show the results of a broader study, which confirms similar issues as observed in the previous experiment when selecting access paths for tables and columns with different sizes and data characteristics. 
In this evaluation, we use three different datasets (Baseball, IMDB and TPC-H) from \cite{hilprecht2022}, as they differ in their data characteristics by various dimensions, as shown in \Cref{tab:dataset_statistics}.
For this experiment, we focus on columns that do not have an index according to the training data (i.e., PK columns) and ask \lcms about access path costs if an index were available. 
Moreover, we exclude columns that have more than 70\% of missing values as this leads to large cardinality errors, which we want to isolate from this study.
Finally, we focus on numeric data types to obtain reliable percentiles, as they allow range filter predicates to vary the selectivities precisely.
The overall results are in \Cref{tab:scan_costs_over_datasets}, where we report average accuracy $B$ over all columns (last column in gray).
As seen previously, \postgresx, \postgresxvi, and \dace again perform best with $B\approx 0.64$ on average across all columns and tables in this broader study.
Overall, the simple \flatvector model performs second best.
Although some \lcms (e.g., \qppnet) learn specifically from statistics and histograms, they do not show better performance.
It is, therefore, questionable whether \lcms can derive meaningful information from these artifacts.
Another interesting observation is that results across columns vary for \lcms, ranging from low to high accuracy (marked in bold) across different columns.
Moreover, some \lcms are not better than randomly guessing the access path, which would result in an accuracy of $0.5$, e.g., \queryformer and \qppnet.
Overall, this is far from satisfactory for robustly solving the task of access path selection.


%---------------------------------------------------


\begin{table*}[]
\resizebox{1\linewidth}{!}{
\begin{tabular}{l|ccccccc|cccccc|cccccccc|
>{\columncolor[HTML]{EFEFEF}}c |}
 & \multicolumn{7}{c|}{\textbf{Baseball}} & \multicolumn{6}{c|}{\textbf{IMDB}} & \multicolumn{8}{c|}{\textbf{TPC-H}} & \cellcolor[HTML]{EFEFEF} \\ \cline{2-22}
\multirow{-2}{*}{\textbf{\diagbox{\lcm}{Tab./Col.}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{batting\\AB}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{batting\\G\_batting}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{halloffame\\needed}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{managers\\L}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{managers\\W}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{mgrhalf\\L}}} & \rotatebox{90}{\parbox{2cm}{mgrhalf\\W}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{aka\_name\\person\_id}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{cast\_info\\movie\_id}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{cast\_info\\nr\_order}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{person\_inf\\person\_id}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{title\\episode\_nr}}} & \rotatebox{90}{\parbox{2cm}{title\\prod\_year}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{lineitem\\l\_ext.price}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{lineitem\\l\_partkey}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{part\\p\_retailprice}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{part\\p\_size}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{partsupp\\ps\_availqty}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{partsupp\\ps\_partkey}}} & \multicolumn{1}{c|}{\rotatebox{90}{\parbox{2cm}{partsupp\\ps\_suppkey}}} & \rotatebox{90}{\parbox{2cm}{partsupp\\ps\_supplycost}} & \multirow{-2}{*}{\cellcolor[HTML]{EFEFEF}\textbf{\begin{tabular}[c]{@{}c@{}}Total \\ AVG\end{tabular}}} \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{9B9B9B}\textcolor{white}{\postgresx}}} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{\textbf{0.6}} & \multicolumn{1}{c|}{0.60} & \multicolumn{1}{c|}{0.50} & 0.50 & \multicolumn{1}{c|}{0.62} & \multicolumn{1}{c|}{0.75} & \multicolumn{1}{c|}{0.57} & \multicolumn{1}{c|}{\textbf{0.6}} & \multicolumn{1}{c|}{\textbf{0.58}} & \textbf{0.62} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{\textbf{0.75}} & \multicolumn{1}{c|}{0.6} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.75} & \multicolumn{1}{c|}{\textbf{1.0}} & \multicolumn{1}{c|}{0.67} & 0.67 & \textbf{0.64} \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{d5bb67}\textcolor{white}{\postgresxvi}}} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{\textbf{0.6}} & \multicolumn{1}{c|}{0.60} & \multicolumn{1}{c|}{0.50} & 0.50 & \multicolumn{1}{c|}{0.62} & \multicolumn{1}{c|}{0.75} & \multicolumn{1}{c|}{0.57} & \multicolumn{1}{c|}{\textbf{0.6}} & \multicolumn{1}{c|}{\textbf{0.58}} & \textbf{0.62} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{\textbf{0.75}} & \multicolumn{1}{c|}{0.6} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.75} & \multicolumn{1}{c|}{0.88} & \multicolumn{1}{c|}{0.67} & 0.67 & \textbf{0.64} \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{8c613c}\textcolor{white}{\texttt{Flat Vector}}}} & \multicolumn{1}{c|}{0.58} & \multicolumn{1}{c|}{0.46} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.40} & \multicolumn{1}{c|}{\textbf{0.83}} & \textbf{1.0} & \multicolumn{1}{c|}{0.38} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.40} & \multicolumn{1}{c|}{0.33} & 0.5 & \multicolumn{1}{c|}{0.23} & \multicolumn{1}{c|}{0.36} & \multicolumn{1}{c|}{0.4} & \multicolumn{1}{c|}{0.38} & \multicolumn{1}{c|}{\textbf{0.94}} & \multicolumn{1}{c|}{0.71} & \multicolumn{1}{c|}{\textbf{1.0}} & \textbf{1.0} & 0.57 \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{956cb4}\textcolor{white}{\texttt{MSCN}}}} & \multicolumn{1}{c|}{0.46} & \multicolumn{1}{c|}{0.69} & \multicolumn{1}{c|}{0.48} & \multicolumn{1}{c|}{0.30} & \multicolumn{1}{c|}{\textbf{0.73}} & \multicolumn{1}{c|}{0.50} & 0.50 & \multicolumn{1}{c|}{0.61} & \multicolumn{1}{c|}{0.25} & \multicolumn{1}{c|}{0.32} & \multicolumn{1}{c|}{0.33} & \multicolumn{1}{c|}{0.5} & 0.48 & \multicolumn{1}{c|}{0.54} & \multicolumn{1}{c|}{0.39} & \multicolumn{1}{c|}{\textbf{0.72}} & \multicolumn{1}{c|}{0.46} & \multicolumn{1}{c|}{0.39} & \multicolumn{1}{c|}{0.25} & \multicolumn{1}{c|}{0.48} & 0.25 & 0.46 \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{d65f5f}\textcolor{white}{\texttt{End-To-End}}}} & \multicolumn{1}{c|}{0.31} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.58} & 0.50 & \multicolumn{1}{c|}{\textbf{0.75}} & \multicolumn{1}{c|}{0.25} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.28} & \multicolumn{1}{c|}{0.5} & 0.52 & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.4} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.33} & 0.5 & 0.47 \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{6acc64}\textcolor{white}{\texttt{QPP-Net}}}} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & 0.50 & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{\textbf{1.0}} & \multicolumn{1}{c|}{\textbf{0.79}} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.5} & 0.5 & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & 0.5 & 0.54 \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{4878d0}\textcolor{white}{\texttt{QueryFormer}}}} & \multicolumn{1}{c|}{1.0} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.60} & \multicolumn{1}{c|}{0.50} & 0.50 & \multicolumn{1}{c|}{0.38} & \multicolumn{1}{c|}{0.56} & \multicolumn{1}{c|}{0.36} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.25} & 0.5 & \multicolumn{1}{c|}{0.38} & \multicolumn{1}{c|}{0.22} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.5} & 0.5 & 0.50 \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{dc7ec0}\textcolor{white}{\texttt{ZeroShot}}}} & \multicolumn{1}{c|}{0.42} & \multicolumn{1}{c|}{0.60} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.50} & 0.50 & \multicolumn{1}{c|}{0.38} & \multicolumn{1}{c|}{0.56} & \multicolumn{1}{c|}{0.36} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{0.5} & 0.5 & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.25} & \multicolumn{1}{c|}{0.63} & \multicolumn{1}{c|}{0.36} & \multicolumn{1}{c|}{0.25} & \multicolumn{1}{c|}{0.5} & \multicolumn{1}{c|}{0.33} & 0.46 & 0.46 \\ \hline
\multicolumn{1}{|l|}{\textbf{\cellcolor[HTML]{ee864a}\textcolor{white}{\texttt{DACE}}}} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{\textbf{0.62}} & \multicolumn{1}{c|}{\textbf{0.6}} & \multicolumn{1}{c|}{0.60} & \multicolumn{1}{c|}{0.50} & 0.50 & \multicolumn{1}{c|}{0.62} & \multicolumn{1}{c|}{0.75} & \multicolumn{1}{c|}{0.50} & \multicolumn{1}{c|}{\textbf{0.6}} & \multicolumn{1}{c|}{\textbf{0.58}} & \textbf{0.62} & \multicolumn{1}{c|}{\textbf{0.67}} & \multicolumn{1}{c|}{\textbf{0.75}} & \multicolumn{1}{c|}{\textbf{0.6}} & \multicolumn{1}{c|}{\textbf{0.62}} & \multicolumn{1}{c|}{0.75} & \multicolumn{1}{c|}{0.86} & \multicolumn{1}{c|}{0.67} & 0.67 & \textbf{0.64} \\ \hline
\end{tabular}
}
\caption{Balanced accuracy $B$ of \lcms when selecting access paths for different workloads, tables, and columns.}
\label{tab:scan_costs_over_datasets}
\end{table*}

\subsection{Access Path Preferences} \label{subsec:access_path_preference}
To analyze why many \lcms often choose the wrong access paths, we analyze their selection preferences across all queries.
For this, we use all queries of the previous experiment and show in \Cref{fig:scan_preference}\circles{A} the averaged ratio of selected table scans broken down by selectivities. 
The index scan ratio is reflected in this experiment as a $1 - [\text{ratio of table scans}]$.
In \Cref{fig:scan_preference}\circles{A}, the black line shows the optimal selection.
For the \lcms (colored lines), the observations can be divided into two groups: 
(1) Overall, \postgresx, \postgresxvi and \dace are closest to the optimal selection and follow the trend across the selectivities, i.e., they select more index scans for small selectivities and more table scans for large selectivities.
However, they select sequential scans far too early for too small selectivities.
(2) The other \lcms, on the other hand, seem not to understand the effect of selectivity at all, as the ratio of table scans is almost constant across varying selectivities. 
Moreover, there seems to be some (static) preference towards index scans for many \lcms.
To explain why many \lcms have this bias, we analyzed the training data. 
Surprisingly, it contained most often sequential scans ($\approx90\%$) and a few index scans ($\approx10\%$).
Moreover, index scans were only used when they were really beneficial for queries, and no negative examples were included. 
Therefore, \lcms learn that index scans seem highly promising without understanding the downsides for high selectivities.

\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/scan_preference.pdf}
    \caption{Scan preference of \lcms over selectivity using either estimated \circles{A} or actual cardinalities \circles{B}}
    \label{fig:scan_preference}
\end{figure}

\subsection{The Effect of Improved Cardinalities}
Finally, as for the join order task, we want to see the effect of cardinality estimates, which are input to many cost models, and see if more accurate estimates lead to better decisions for cost models.
For this purpose, we repeat the previous experiment with perfect cardinalities to estimate their effect on the access path selection.
Interestingly, as shown in \Cref{fig:scan_preference}\circles{B}, the access path selection improves slightly for some \lcm which now better follow the optimal choice, e.g., \flatvector.
However, other \lcms are still not able to catch the trend.
We analyzed this behavior and found that the cardinality estimates for these simple scan queries are already highly accurate (with a $Q_{50} <= 1.05$). 
Thus, further improving cardinalities does not help this task very much.

\subsection{Summary \& Takeaways} \label{sec:access_path_discussion}
Overall, no single \lcm delivers convincing results in access path selection. 
Different from join ordering, the main reason is still that the costs of access paths are not really understood.
However, incorporating database statistics and sample bitmaps into \lcms was not beneficial.
Interestingly, \lcms are biased in their selection towards index scans across the selectivity range, which indicates that they learned that index scans are always beneficial due to bias in the training data.
To mitigate this bias, \lcms need to learn from execution costs for both access paths across selectivity.
We present strategies and initial results for this in \Cref{sec:lessons}.

