\section{Task 3: Physical Operator Selection}\label{sec:physical_operator}
The task of physical operator selection refers to the process of choosing the most efficient algorithm to execute a given query operator. 
This selection is crucial, as it directly impacts the query performance and resource utilization. 
The complexity of this task arises from understanding the combined effects of algorithm complexity and various other factors, such as the data distribution, available indexes, hardware capabilities, and the specific characteristics of the workload. 
In this section, we report how well recent \lcms are able to select physical operators using physical operator selection for joins as an important example.

%------------------------------------------------------
\subsection{Evaluation Setup}
\noindent\textbf{Experimental Setting.}
For this experiment, we generate various queries that join two tables with join predicates on the foreign key relationships as these are the most common joins, like: \texttt{SELECT COUNT(*) FROM title,movie\_info\_idx WHERE title.id=movie\_info\_idx.movie\_id AND title.production\_year=2009}.
We use \texttt{COUNT}-expressions so as not to deviate too much from the training data, which also makes typical use of them.
We execute each query three times with three different join algorithms to get the true runtimes, i.e. \texttt{Hash Join} (HJ), \texttt{Sort Merge Join}, (SMJ) \texttt{Indexed Nested Loop Join} (INLJ)\footnote{We only used INLJ joins, as primary keys always used an index in our setup.} which are algorithms that PostgreSQL supports.
For all queries, we also obtain the predictions of \lcms.

%------------------------------------------------------
\noindent\textbf{Experimental Metrics.}
For this study, we introduce a new metric that determines how often the \lcm picks the plan with the optimal physical operator algorithm.
\begin{definition}
\textit{Pick Rate (p)}: The pick rate reports the percentage of $p$ out of $n$ query plans that gives how often a cost model would pick the optimal plan, e.g., where the plan with the minimal prediction has the lowest actual runtime.
\end{definition}
%------------------------------------------------------
\subsection{Example Query \& Metrics} \label{subsec:physical_operator_anecdotal}
\noindent To first get an impression of how \lcms select physical operators and how our novel metrics are applied, we illustrate in \Cref{fig:physical_operator_anecdote} the runtimes for a representative example query of the IMDB dataset when using three different physical operators (left) and the model predictions (right).
For the given query, SMJ is the most optimal selection according to the runtime of around $6.47s$, while INLJ and HJ have longer runtimes of up to $13.19s$ (left-most bars).
Interestingly, neither the PostgreSQL cost models nor a single \lcm select the optimal physical operator.
In fact, most models prefer the INLJ, although it has a longer runtime of $8.94s$.
Note that \postgresx and \postgresxvi also fail here, as they select the worst operator (HJ) with $13.19s$.
%------------------------------------------------------
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figures/physical_operator_anecdote.pdf}
    \caption{Predictions for physical operators for a two-way join on the IMDB dataset. 
    We show the real runtimes against \lcm predictions and indicate correct (\checkmark) and incorrect (\text{\sffamily X}) selections. 
    No single \lcm would pick the fastest join (SMJ).}
\label{fig:physical_operator_anecdote}
\end{figure}
%------------------------------------------------------
\subsection{Full Results on Physical Operator Selection}
\label{sec:physical_operator_full}
We now validate these initial findings for a broader set of queries and datasets.
For this, we repeat the previous experiment with each 100 queries on the three different datasets IMDB, Baseball, and TPC-H (as described in \Cref{tab:dataset_statistics}).


\textbf{All Predictions}: 
We visualize the predictions vs. the actual runtimes in \Cref{fig:physical_operator_all}.
As each of the 300 queries has three different plan candidates with different joins, each subplot contains 900 predictions.
Overall, for many \lcms, we observe huge differences between the operator type and the predicted costs.
For example, \zeroshot overall shows good correlations between the actual and predicted runtime for each operator type.
However, while Hash Joins are precisely estimated, Index Nested Loop Joins are systematically underestimated, and Sort-Merge-Joins are overestimated roughly by a constant factor.
Similarly, \postgresx and \postgresxvi show a linear trend between the predicted and actual runtime but overall tend to underestimate.
In contrast, other \lcms like \etoe or \dace show a noisy behavior that does not show any linear function of the operator type.
However, both types of behavior lead to a sub-optimal operator selection.
Interestingly, for some \lcms, we observe a consistent ranking within an operator type (e.g. INLJ for \flatvector) but not across operator types, which makes it particularly hard to select the optimal operator. 

\textbf{Aggregated Results}:
To provide a more quantitative evaluation, we report aggregated results in \Cref{fig:physical_operator_selection_full}.
We report the pick rate $p$ (upper row) for each workload and the selected total runtime $r$ vs. the runtime when optimal operators are chosen (lower row).
Interestingly, when looking at the pick rate on IMDB, \lcms perform comparably well to \postgresx and \postgresxvi, and some even outperform them on IMDB and TPC-H.
For instance, \dace as a database-agnostic model achieves a pick rate of $p=82\%$ on IMDB, whereas \postgresx only achieves $p=60\%$.
A similar trend is observed for the TPC-H dataset.
However, for baseball, \postgresxvi achieves the best pick rate with $r=74\%$.
A slightly different trend is observed when looking at the overall selected runtime.
For IMDB and Baseball, \postgresx and \postgresxvi achieve the lowest runtime, closely followed by \dace. 
On TPC-H, \dace outperforms the other models slightly.
These results show that \lcms already have the potential to be competitive with traditional models on this task while again not providing significant benefits.

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{figures/physical_operator_all.pdf}
    \caption{Predicted vs. actual runtimes for different join types on 300 queries (on  IMDB, TPC-H and baseball datasets)}
\label{fig:physical_operator_all}
\end{figure}

\begin{figure*}
    \centering
    \includegraphics[width=\linewidth]{figures/physical_operator_selection_full.pdf}
    \caption{Pick rate and selected runtime for physical operator selection over 100 queries of three datasets (IMDB, TPC-H, Baseball). \lcms are able to achieve a better performance than \postgres. However, the performance deteriorates when removing estimated PostgreSQL costs from the input features of \dace and \qppnet.}
    \label{fig:physical_operator_selection_full}
\end{figure*}

%------------------------------------------------------
\subsection{Learning From PostgreSQL Costs}
\dace and \qppnet use estimated PostgreSQL costs as input features to predict the cost of queries as shown in \Cref{tab:taxonomy}.
They, therefore, function as \textit{hybrid} approaches, as they build on PostgreSQL estimates.
That way, these models utilize the expert knowledge inherent in the PostgreSQL cost model.
In this ablation study, we thus want to explore the contribution of PostgreSQL costs to the estimates.
Thus, we train a variant of these two models \qppnet and \dace without PostgreSQL costs as input, i.e., we removed them from the featurization.
The results can be seen in \Cref{fig:physical_operator_selection_full} (light bars at the right in each plot) 
As expected, the pick rate of \dace on the IMDB dataset decreases from $p=82\%$ to $p=44\%$, and the selected runtime increases from $r=383$ to $r=647s$.
A similar observation also holds on the other datasets and also for \qppnet -- except for one case where surprisingly \qppnet gets better on IMDB.
Thus, it becomes clear that the PostgreSQL costs typically are an important signal and should be included in future \lcms, as we will discuss.
%------------------------------------------------------
\subsection{Operator Breakdown \& Preferences}
In this experiment, we want to understand where \lcms make mistakes when selecting physical operators.
For this, we show the distributions of the selected operator types for the 100 queries on the IMDB dataset compared to the optimal distribution in \Cref{fig:physical_operator_breakdown}.
As shown by the optimal distribution (left), in 43\% of the queries, an INLJ is best, while in 41\%, it is the HJ, and in 16\%, the SMJ.
However, we see fundamentally different operator selections when looking at the selections when using the cost models.
First, \postgresx and \postgresxvi both show a strong tendency to over-select HJs.
Looking at \lcms, we see a very different picture: 
Most \lcms have an over-preference for INLJs.
For example, \queryformer chooses an INLJ even in 95\%, and \zeroshot in 85\% of the queries.
This is probably due to a similar effect for access path selection, as INLJs are represented in the training set as beneficial.
We additionally report the pick rate and selected runtime in \Cref{fig:physical_operator_breakdown}, which shows similar observations.
\subsection{Additional Indexes on Filter Columns}
In the previous experiments, only indexes on the primary keys are used. 
In addition, we now add indexes on the filter columns, which open up additional ways of using INLJs because they also enable faster look-ups for non-primary key columns.
This shifts the distribution of which physical operators are optimal, as we discuss next.
For this, we repeat the previous experiment with additional indexes on the filter columns and show the breakdown in \Cref{fig:physical_operator_breakdown_idx}\footnote{As \qppnet cannot predict the cost for additional indexes due to its fixed featurization using one-hot encoding, we excluded it from this experiment.}.
As we can see, the use of INLJ when selecting operators optimally increases to 69\%. 
Interestingly, the performance of \postgresx and \postgresxvi drops significantly as it still prefers HJ (74\% and 87\%), and it is now outperformed by most \lcms in terms of runtime and pick rate.
Thus, it seems that the cost model of PostgreSQL is not well calibrated and still prefers hash operations.
On the other hand, the benefit of \lcms might stem from their over-preference for INLJ, which, in this experiment, luckily, is often the better choice.

\begin{figure*}
    \centering
    \includegraphics[width=1\linewidth]{figures/physical_operator_breakdown.pdf}
    \caption{Breakdown of selected operators for physical operator selection on the IMDB test queries.}
    \label{fig:physical_operator_breakdown}
\end{figure*}

\begin{figure*}
    \centering
    \includegraphics[width=1\linewidth]{figures/physical_operator_breakdown_add_index.pdf}
    \caption{Breakdown with additional indexes on the filter columns on the IMDB test queries.}
\label{fig:physical_operator_breakdown_idx}
\end{figure*}

\subsection{Summary \& Takeaways}
Overall, no cost model could achieve a near-optimal runtime when selecting physical query operators. 
Still, the classical models performed best and \dace as a database-agnostic model is close according to the selected runtime.
However, as mentioned, \dace learns from PostgreSQL costs, which is highly beneficial for \dace, as shown in our ablation study. 
Furthermore, another observation is that most \lcms showed a strong over-preference for INLJ, which supports the findings of the access path selection study that bias in training data is a potential problem one needs to tackle for \lcms. 
However, this is also non-trivial as INLJs can cause high runtimes and, thus, often timeout during training data collection (as they need hours or even days). 
Thus, an interesting avenue of research is to include negative signals in training the models without the need actually to run these costly negative examples.