\section{Backward Slicing Algorithm}
\label{slicing}

\noindent The proposed backward slicing algorithm is shown in Algorithm~\ref{alg1}. This backward slicing procedure consists of two phases: variable retrieval and slice extraction. In Stage 1, the algorithm tracks variables that influence the suspicious API invocation $a_i$. Specifically, in Line 2, the algorithm initializes the $worklist$ with $unit$ containing $a_i$, and in Line 4, it begins iterating through the control flow graph (CFG) in a backward manner starting from $unit$, extracting relevant variables from each unit. The algorithm updates the locals list by removing defined variables and adding those that affect $a_i$ in Line 13, and stores the updated variables in $varMap$ in Line 15. Stage 2 focuses on extracting slices based on $varMap$. In Line 23, the algorithm resets the $worklist$ and $visited$ sets, then starts from the predecessors of the original unit that invoked $a_i$. Line 28 checks the successors of each unit and identifies those relevant to the API invocation. The combined slices are formed in Line 29, integrating all the relevant variables and units, and the algorithm returns the slices in Line 38. This two-phase process enables the algorithm to isolate the parts of the function that influence the suspicious API invocation, facilitating further analysis.

\begin{algorithm}
\caption{Algorithm of Backward Slicing}
\label{alg1}
\begin{algorithmic}[1]

\REQUIRE ~Control Flow Graph $CFG$ of the function that invokes the suspicious API $a_i$ at unit block $unit$
\STATE \textbf{Stage 1: Variable Retrieval}
\STATE Initialize $worklist$ with $unit$ containing $a_i$
\STATE Initialize $visited \gets \{\}$, $varMap \gets \emptyset$

\WHILE {$worklist \neq \emptyset$}
    \STATE Pop $currUnit$ from $worklist$
    \STATE Initialize $locals \gets \{\}$

    \IF {$currUnit$ contains $a_i$}
        \STATE Extract variables used by $a_i$ and add to $locals$
    \ELSE
        \STATE Load variables from successors of $currUnit$ using $varMap$ and add to $locals$
    \ENDIF

    \IF {$currUnit$ is relevant to the $a_i$ invocation based on $locals$}
        \STATE Update $locals$: remove defined variables, add used variables that affect the $a_i$ invocation
    \ENDIF

    \STATE Store $locals$ in $varMap[currUnit]$

    \FOR {$pred \in$ predecessors of $currUnit$}
        \IF {$pred \notin visited$}
            \STATE Add predecessor $pred$ to $visited$ and $worklist$
        \ENDIF
    \ENDFOR
\ENDWHILE

\STATE \textbf{Stage 2: Slices Extraction}
\STATE Initialize $slices \gets \{unit\}$, reset $worklist$ and $visited$
\STATE Add predecessors of $unit$ to $worklist$

\WHILE {$worklist \neq \emptyset$}
    \STATE Pop $currUnit$ from $worklist$
    \STATE Load variables from the successors of $currUnit$ using $varMap$

    \IF {$currUnit$ is relevant to the $a_i$ invocation based on the successor variable}
        \STATE Add $currUnit$ to $slices$
    \ENDIF

     \FOR {$pred \in$ predecessors of $currUnit$}
        \IF {$pred \notin visited$}
            \STATE Add predecessor $pred$ to $visited$ and $worklist$
        \ENDIF
    \ENDFOR
\ENDWHILE

\STATE \RETURN $slices$

\end{algorithmic}
\end{algorithm}

