\section{Proofs}
\label{sec:proofs}

\begin{lemma}
  \label{lem:DPLt}
  Given well-formed and well-nested trace $T$, $\DPLt[T]$ is a strict partial order.
\end{lemma}

\begin{proof}
  \leavevmode
  \begin{description}
    \item[Irreflexivity]
      Take any DP $A$ in $T$.
      Towards contradiction, suppose $A \DPLt[T] A$.
      Take any $(a,q) \in A$.
      There exists $(a',q') \in A$ such that $q \TrLt[T] q'$ and $a \in \AH[T](q')$.
      Since also $a \in \AH[T](q)$, then $\thd(q) = \thd(q') = \thd(a)$.
      But if $q \ne q'$, we must have $\thd(q) \ne \thd(q')$.
      Hence, $q = q'$, contradicting $q \TrLt[T] q'$.
    \item[Asymmetry]
      Take any DPs $A,B$ in $T$ such that $A \DPLt[T] B$.
      Towards contradiction, suppose $B \DPLt[T] A$.
      Take any $(a,q) \in A$.
      There exists $(a',q') \in B$ such that $q \TrLt[T] q'$ and $a \in \AH[T](q')$.
      Since also $a \in \AH[T](q)$, then $\thd(q) = \thd(q') = \thd(a)$.
      Similarly, there exists $(a'',q'') \in A$ such that $q' \TrLt[T] q''$ and $a' \in \AH[T](q'')$.
      Hence, $\thd(q) = \thd(q') = \thd(q'') = \thd(a')$.
      Similar to the previous subproof, then $q = q''$, contradicting $q \TrLt[T] q' \TrLt[T] q''$.
    \item[Transitivity]
      Take any DPs $A,B,C$ in $T$ such that $A \DPLt[T] B \DPLt[T] C$.
      Take any $(a,q) \in A$.
      There exists $(a',q') \in B$ such that $q \TrLt[T] q'$ and $a \in \AH[T](q')$.
      Similarly, there exists $(a'',q'') \in C$ such that $q' \TrLt[T] q''$ and $a' \in \AH[T](q'')$.
      Similar to the previous subproofs, we have $\thd(a) = \thd(q) = \thd(a') = \thd(q') = \thd(a'') = \thd(q'')$.
      By Condition~\cond{WF-Req}, $a \in \AH[T](a')$, so by well nestedness, $a \in \AH[T](q'')$.
      By transitivity, $q \TrLt[T] q''$.
      Hence, $A \DPLt[T] C$.
      \qedhere
  \end{description}
\end{proof}

\begin{lemma}
  \label{l:mustTRWAcq}
  Suppose given well-formed trace $T$, and event $e \in T$ and acquire $a \in T$.
  Assume that, in any $T' \in \crp(T)$ where $e$ is the last event in its thread, $a \TrLt[T'] e$.
  Then $a \TRWLt[T] e$.
\end{lemma}

\begin{proofsketch}
  Towards contradiction, suppose $a \not\TRWLt[T] e$.
  For they would be TRW ordered otherwise, then $a$ and $e$ cannot appear in the same thread or be conflicting.
  Hence, there must be a chain of critical sections forcing $a$ to precede $e$ in any of the assume $T' \in \crp(T)$.
  We apply induction on the length of this chain.
  The inductive case is a simple extension of the base case by applying the IH.

  In the base case, there are two critical sections on the same lock, and they contain events that force an ordering.
  W.l.o.g., assume $a$ appears before some $f$, both in a CS between $a_1$ and $r_1$ on lock $l$, where $f \TRWLt[T] g$ and $g$ appears after $e$, both in another CS between $a_2$ and $r_2$ on lock $l$: we have $r_1 \TRWLt[T] g$, but not $r_1 \TRWLt[T] e$.
  However, since $g$ appears after $e$, $g$ does not appear in any of the assumed $T' \in \crp(T)$, so having to place $f$ before $g$ cannot be the reason why $a$ appears before $e$ in every such $T'$.
  Hence, the ordering must be due to $g$ appearing before $e$, so $a \TRWLt[T] e$.
\end{proofsketch}

\begin{lemma}
  \label{l:mustTRWRel}
  Suppose given well-formed and well-nested trace $T$, and event $e \in T$ and acquire~$a \in T$ with matching release $r \in T$.
  Assume that, in any $T' \in \crp(T)$ where $e$ is the last event in its thread,~$r \notin T'$.
  If $a \TRWLt[T] e$, then $e \TRWLt[T] r$.
\end{lemma}

\begin{proofsketch}
  Towards contradiction, suppose $e \not\TRWLt[T] r$.
  We apply a similar induction as in the proof of \cref{l:mustTRWAcq}, and only discuss the base case.
  Here, $r$ appears before some $f$, both in a CS between $a_1$ and $r_1$ on lock $l$, where $g \TRWLt[T] f$ and $g$ appears after $e$, both in another CS between $a_2$ and $r_2$ on lock $l$: we have $e \TRWLt[T] f$, but not $e \TRWLt[T] r$.
  By well nestedness, also $a$ in the CS between $a_1$ and $r_1$.
  Since $a \TRWLt[T] e$, in any of the assumed $T' \in \crp(T)$, we must have $r_1 \TrLt[T'] a_2$.
  But then $r \TrLt[T'] e$, i.e., $e \in T'$: contradiction.
\end{proofsketch}

\begin{proof}
  [Proof of \cref{thm:TRWSound}]
  Assume $A = \DP{(\ACQ1,\REQ1),\ldots,(\ACQ{n},\REQ{n})}$.
  We need to show that there is $T' \in \crp(T)$ such that the requests in $A$ are the last events in their threads in $T'$, witnessing that $A$ is a predictable deadlock.
  To make full use of Condition~\cond{DP-TRW}, we prove the stronger property that there is such $T' \in \TRWcrp(T)$.
  We do so by contradiction, distinguishing cases on (1)~there being such $T'$ but none in $\TRWcrp(T)$ where we show contradiction of Condition~\cond{DP-TRW}, and (2)~there being no such $T' \in \crp(T)$ at all where we show contradiction of Condition~\cond{DP-Block}.

  To be precise, let $\mathbb{T} \subseteq \crp(T)$ such that every $T' \in \mathbb{T}$ contains all $q \in A$ as the last in their respective thread, and let $\mathbb{T}^\star = \mathbb{T} \cap \TRWcrp(T)$.
  We prove the theorem by proving the stronger property that $\mathbb{T}^\star$ is not empty.
  Towards contradiction, assume $\mathbb{T}^\star$ is empty.
  The rest of the analysis depends on whether (1)~$\mathbb{T}$ is not empty or (2)~$\mathbb{T}$ is empty.

  \begin{description}

    \item[Case~(1) contradicting Condition~\cond{DP-TRW}.]
      In case~(1), $\mathbb{T}$ is not empty.
      Since $\mathbb{T}^\star$ is empty, this means that $\mathbb{T} \setminus \TRWcrp(T)$ is not empty.
      That means that in any $T' \in \mathbb{T} \setminus \TRWcrp(T)$, there are $e,f \in T'$ such that $e \TRWLt[T] f$ but $f \TrLt[T'] e$, where $e \POLt[T] q_1$ and $f \POLt[T] q_2$ for some $q_1,q_2 \in A$.
      Hence, there must be a request that leaves an early critical section open, such that a later critical section is reordered before it, and the critical sections contain TRW-ordered events.
      To be precise, there are acquires $b_1,b_2 \in T$ on the same lock with respectively matching releases $r_1,r_2$, $e,f \in T$, and $q_1,q_2 \in A$, such that (a)~$b_1 \POLt[T] e \POLt[T] q_1 \POLt[T] r_1$, (b)~$f \POLt[T] r_2 \POLt[T] q_2$, and (c)~$e \TRWLt[T] f$.
      It is not necessarily the case that $f \in \CS[T](b_2)$ (when $f \POLt[T] b_2$), but this is no problem: there is $f' \in \CS[T](b_2)$ such that $f \POLeq[T] f'$ (i.e., possibly $f = f'$).
      Since $r_1 \notin T'$, we have $r_2 \TrLt[T'] b_1$ and hence $f \TrLt[T'] e$.
      We make the following inferences by definition of TRW:
      \begin{align*}
        e &\TRWLt[T] f \tag*{((c))} \\
        b_1 &\TRWLt[T] f \tag*{((a) and Conditions~\cond{TRW-PO/-Tr})} \\
        b_1 &\TRWLt[T] f' \tag*{(Condition~\cond{TRW-Tr})} \\
        r_1 &\TRWLt[T] f' \tag*{(Condition~\cond{TRW-Rel})} \\
        q_1 &\TRWLt[T] f' \tag*{((a) and Condition~\cond{TRW-Tr})} \\
        q_1 &\TRWLt[T] q_2 \tag*{((b) and Condition~\cond{TRW-Tr})}
      \end{align*}
      But then not $q_1 \TRWConc[T] q_2$, contradicting the Condition~\cond{DP-TRW} that DP $A$ satisfies.

    \item[Case~(2).]
      In case~(2), $\mathbb{T}$ is empty entirely.
      There may yet be candidate reordering, but they are not in $\crp(T)$ because of violation of Condition~\cond{CRP-LW}.
      If there are (subcase~(2.a)), we show a straightforward contradiction of Condition~\cond{DP-TRW}.
      Otherwise (subcase~(2.b)), the problem must be in reordering critical sections, and we show contradiction of Condition~\cond{DP-Block} (i.e., we show that there is an earlier cycle).

      \begin{description}

        \item[Subcase~(2.a) contradicting Condition~\cond{DP-TRW}.]
          In subcase~(2.a), all candidate reordering are rejected (i.e., not in $\crp(T)$) only because of violation of Condition~\cond{CRP-LW}.
          Either (i)~a read before some $q_1 \in A$ has its last write after some $q_2 \in A$, or (ii)~a read is assigned the wrong last write but its own last write is in the trace.
          In case~(i), trivially $q_1 \TRWLt[T] q_2$, again contradicting Condition~\cond{DP-TRW} that DP $A$ satisfies.
          The contradiction in case~(ii) follows analogously to that in case~(i).

        \item[Subcase~(2.b) contradicting Condition~\cond{DP-Block}.]
          In subcase~(2.b), the absence of the required reorderings is not only due to violation of Condition~\cond{CRP-LW}.
          Since satisfaction of all other conditions is trivial, the problem must be in violation of Conditions~\cond{CRP-WF/WF-Acq/WF-Rel}.
          That is, there are no candidate reorderings in $\crp(T)$, because there is a pair of acquires on the same lock that cannot be ordered in any way.

          To derive a contradiction, we show that there is a cycle $B$ such that $B \DPLt[T] A$.
          We apply induction on the size of $A$ (\ih1).
          In base case and inductive case, the idea is the same: we identify the problematic pair of acquires on the same lock, and show that their respective ordering is impossible due to another pair of acquires on another lock that cannot be ordered.
          In the base case, which we detail, the size of $A$ is two.
          We show that this new pair of acquires must also precede the two requests in $A$, and hence we can construct $B$ to contradiction Condition~\cond{DP-Block}.
          In the inductive case, the new pair of acquires may involve a third request in $A$; since there are less uninvolved requests left, the contradiction follows from \ih1 (the soundness of this induction follows from the finite size of $A$, so we ought to eventually encounter a ``new'' request we have seen before).

          To find the pair of problematic acquires, we apply induction on the distance between the problematic acquires and requests in $A$ (\ih2).
          In the inductive case, assume that both acquires have matching releases that precede requests in $A$: one of the critical sections must contain another acquire that causes the issue.
          Since this acquire is closer to a request in $A$, the thesis follows from \ih2.
          If one of the acquires has a matching release that succeeds a request in~$A$, we proceed as in the base case.

          In the base case, the acquires are as close to requests as possible, so there are no further problematics acquires.
          It must then be that one of the acquires has a matching release that must succeed a request in $A$; otherwise, there could not be an issue in ordering the acquires (remember that we ruled out write-read issues).

          Thus, we have acquires~$b_1,b'_1$ on the same lock~$l_1$ that, for a prefix of $T$ to be correctly reordered, have to occur before some $q_1,q_2 \in A$ and the release $r_1$ matching $b_1$ cannot occur before $q_1$ (w.l.o.g., assume $r_1 \in T$).
          Hence, by \cref{l:mustTRWAcq,l:mustTRWRel}, $b_1 \TRWLt[T] q_1 \TRWLt[T] r_1$, and $b'_1 \TRWLt[T] q_2$.
          Note that $q_1 \ne q_2$, for otherwise we would already have $b'_1 \TrLt[T] r'_1 \TrLt[T] b_1$, where release $r'_1$ matches $b'_1$: reordering would be unnecessary and hence there is no issue.

          By TRW boundedness, $\thd(b_1) = \thd(q_1)$.
          It follows that $b_1 \in \AH[T](q_1)$ and hence $l_1 \in \LH[T](q_1)$.
          Then, by Condition~\cond{DP-Guard}, $l_1 \notin \LH[T](q_2)$ so $b'_1 \notin \AH[T](q_2)$.
          Hence, $q_2 \not\TRWLt[T] r'_1$.

          This means that $q_2$ being the last in its thread cannot prevent $r'_1$ from being placed.
          However, by assuming that $\mathbb{T}$ is empty, doing so is impossible.
          Hence, there must be acquire $b_2$ that precedes $b'_1$ ($b_2 \TRWLt[T] b'_1$ by \cref{l:mustTRWAcq}) that cannot be moved to precede some $b'_2$ on the same lock~$l_2$, because the release $r_2$ matching $b_2$ succeeds $q_2$ ($q_2 \TRWLt[T] r_2$ by \cref{l:mustTRWRel}).
          Assuming $A = \DP{ (a_1,q_1) , (a_2,q_2) }$, following similar reasoning as above, it must then be that $b'_2 \TRWLt[T] q_1 \not\TRWLt[T] r'_2$, where release $r'_2$ matches~$b'_2$.

          There are many (well-nested) ways in which $b_2$ and $b'_2$ can be arranged with respect to $b'_1$ and $b_1$, respectively.
          Some are impossible by Condition~\cond{DP-Guard}, and all others (except one) can be ordered validly.
          Hence, the only arrangement that cannot be ordered applies.
          In this arrangement, we have $b_1 \TRWLt[T] b'_2 \TRWLt[T] r'_2 \TRWLt[T] q_1 \TRWLt[T] r_1$ and $b_2 \TRWLt[T] b'_1 \TRWLt[T] r'_1 \TRWLt[T] q_2 \TRWLt[T] r_2$.
          Hence, by TRW boundedness, $\thd(b_1) = \thd(b'_2) = \thd(q_1)$ and $\thd(b_2) = \thd(b'_1) = \thd(q_2)$.

          Let $q'_1$ and~$q'_2$ be the requests requesting $b'_2$ and $b'_1$, respectively, and let $B = \DP{ (b_1,q'_1) , (b_2,q'_2) }$.
          Clearly, $B$ is a cycle (satisfying Condition~\cond{DP-Cycle}) where $b_1 \in \AH[T](q_1)$ and $q'_1 \TrLt[T] q_1$, and $b_2 \in \AH[T](q_2)$ and $q'_2 \TrLt[T] q_2$.
          Hence, $B \DPLt[T] A$ (\cref{def:ltDP}), reaching our desired contradiction that DP $A$ satisfies Condition~\cond{DP-Block}.

          %   Below are all well-nested arrangements of CSs w.r.t. q1,q2.
          %   Combinations 3.e, 3.f, 4.e, 3.f are impossible by DP-1.
          %   All other combinations except 2.e have possible orderings.
          %   Combination 2.e cannot be ordered, and entails a prior DP.
          %
          %   1. a2' - r2' - a1  - q1  - r1
          %   2. a1  - a2' - r2' - q2  - r1
          %   3. a2' - a1  - q1  - r1  - r2'
          %   4. a1  - a2' - q1  - r2' - r1
          %
          %   a. a2  - r2  - a1' - r1' - q2
          %   b. a1' - a2  - r2  - r1' - q2
          %   c. a2  - a1' - r1' - r2  - q2
          %   d. a1' - r1' - a2  - r2  - q2
          %   e. a2  - a1' - r1' - q2  - r2
          %   f. a1' - r1' - a2  - q2  - r2

          If there are more than two requests in $A$, then $b'_2$ may also be related to some $q_3 \in A$.
          Analogous to above, an analysis of arrangements of critical sections reveals that there must be yet another pair of unorderable acquires.
          Since there are only a finite number of requests in $A$, at some point we must encounter a request we have seen before.
          Since every acquire encountered is assumed to contribute to unorderability, it must then be that we would uncover a pair of unorderable acquires that we have seen before.
          This way, we reach the cycle of requires for us to build $B$ as above.
          \qedhere
      \end{description}
  \end{description}
\end{proof}

\begin{lemma}
  \label{l:PWRTr}
  Suppose given well-formed trace $T$, and events $e,f \in T$ such that $e \PWRLt[T] f$.
  Then, for any $T' \in \crp(T)$ where $f \in T'$, we have $e \TrLt[T'] f$.
\end{lemma}

\begin{proof}
  Take any $T' \in \crp(T)$ where $f \in T'$.
  We apply induction on the derivation of $e \PWRLt[T] f$.
  The only interesting case is Condition~\cond{PWR-Rel}:
  there are acquires $a_1,a_2 \in T$ on the same lock such that (i)~$e$ is the release matching $a_1$, (ii)~$a_1 \TrLt[T] a_2$, (iii)~$f \in \CS[T](a_2)$, and (iv)~$a_1 \PWRLt[T] f$.
  By the IH on (iv), $a_1 \TrLt[T'] f$.
  By (iii), $\thd(f) = \thd(a_2)$, so $a_2 \POLt[T] f$;
  by Condition~\cond{CRP-PO}, $a_2 \TrLt[T'] f$.
  Then, by Condition~\cond{WF-Acq}, $e \TrLt[T'] f$.
\end{proof}

\begin{proof}
  [Proof of \cref{t:PWRcomplete}]
  Assume $A = \DP{(\ACQ{1},\REQ{1}),\ldots,(\ACQ{n},\REQ{n})}$.
  Since $A$ is a predictable deadlock (\cref{d:deadlock}), there is $T' \in \crp(T)$ such that every $\REQ{i}$ is the last event in its thread.

  To prove Condition~\cond{DP-PWR}, towards contradiction assume there are $1 \leq i < j \leq n$ such that $\REQ{i} \PWRLt[T] \REQ{j}$.
  By \cref{l:PWRTr}, $\REQ{i} \TrLt[T'] \REQ{j}$.
  Since they are the last in their respective thread, we can construct $T''$ from $T'$ by (1)~moving all requests to be the last events in the trace overall, and then (2)~swapping $\REQ{i}$ and $\REQ{j}$.
  The resulting $T''$ is in $\crp(T)$, because the only Condition~\cond{WF-/CRP-$\ast$} that applies to requests is Condition~\cond{WF-Req} but that condition is about the event following a request of which there are none.
  Now we have $\REQ{j} \TrLt[T''] \REQ{i}$.
  This contradicts our earlier conclusion from \cref{l:PWRTr}.

  To prove Condition~\cond{DP-Block}, towards contradiction assume that there is a cycle $B \DPLt[T] A$.
  Assume $B = \DP{(\ACQ{1}'',\REQB{1}),(\ACQ{2}'',\REQB{2})}$; the argument extends to size $j \leq n$ by induction.
  By \cref{def:ltDP}, $q'_1 \ne q_1$ and $q'_2 \ne q_2$.
  Moreover, for $i \in \{1,2\}$, $\ACQ{i}'' \in \AH(\REQ{i})$ and $q'_i \TrLt[T] q_i$.

  Take any $i \in \{1,2\}$.
  Because $\REQB{i}$ and $\REQ{i}$ have an acquire held in common, by \cref{d:CS}, $\thd(\REQB{i}) = \thd(\REQ{i})$.
  Hence, $q'_i \POLt[T] q_i$, so $q'_i \TrLt[T'] q_i$.
  Moreover, $\ACQ{i}'' \TrLt[T'] \REQB{i}$.
  Let $\ACQ{i}'$ be the acquire requested by $\REQ{i}'$.
  By Condition~\cond{WF-Req} (\cref{d:WF}), $\REQB{i} \TrLt[T'] \ACQ{i}' \TrLt[T'] \REQ{i}$.
  Let $\REL{i}'$ and $\REL{i}''$ be the releases matching $\ACQ{i}'$ and $\ACQ{i}''$, respectively.
  Since $a''_i \in \AH(q_i)$, $r''_i \in T$ implies $q_i \POLt[T] r''_i$.
  Because $\REQ{i}$ is the last event in its thread in $T'$, it follows that $\REL{i}'' \notin T'$.

  Let $j \in \{1,2\} \setminus \{i\}$.
  Analogously, $a''_j \TrLt[T'] q'_j \TrLt[T'] a'_j \TrLt[T'] q_j$, $r''_j \notin T'$, and all are in the same thread.
  By Condition~\cond{DP-Cycle}, $a''_i,q'_j,a'_j$ and $a''_j,q'_i,a'_i$ are pairwise on the same lock.
  Hence, by well formedness of $T'$, $r'_i,r'_j \in T'$ with $\REL{i}' \TrLt[T'] \ACQ{j}''$ and $\REL{j}' \TrLt[T'] \ACQ{i}''$.
  But then we obtain the following:
  $\REL{i}' \TrLt[T'] \ACQ{j}'' \TrLt[T'] \ACQ{j}' \TrLt[T'] \REL{j}' \TrLt[T'] \ACQ{i}'' \TrLt[T'] \ACQ{i}' \TrLt[T'] \REL{i}'$.
  Clearly, this cyclic ordering is impossible: a contradiction.
\end{proof}

\begin{comment} This stuff is not relevant for this paper.
\begin{definition}[Contextual Must-Happen-Before Order (CMHB)]
  \label{d:cmhb}
  Given trace $T$ and $E \subseteq \evts(T)$, we define the Contextual Must-Happen-Before order (CMHB) as relation $\CMHBLt[T]{E}$ on $\evts(T)$, where $e \CMHBLt[T]{E} f$ if, in every $T' \in \crp(T)$ where $E \subseteq \evts(T')$, $f \in T'$ implies $e \TrLt[T'] f$.

  A DP $A$ in well-formed trace $T$ satisfies Condition~\cond{DP-CMHB} if neither $q \CMHBLt[T]{A} q'$ nor $q' \CMHBLt[T]{A} q$ (denoted $q \CMHBConc[T]{E} q'$) for every distinct $(a,q),(a',q') \in A$.
\end{definition}

\begin{lemma}
  \label{lem:PWRapprox}
  Let $A$ be a DP in $T$.
  If $e \PWRLt[T] f$, then $e \CMHBLt[T]{A} f$.
\end{lemma}

\begin{proof}
  % [Proof of \cref{lem:PWRapprox}]
  By induction on the derivation of $e \PWRLt[T] f$.
  Condition~\cond{PWR-Rel} is the only interesting case:
  there are acquires $a_1,a_2 \in T$ on the same lock such that (i)~$e$ is the release matching $a_1$, (ii)~$a_1 \TrLt[T] a_2$, and (iii)~$f \in \CS[T](a_2)$, and (iv)~$a_1 \PWRLt[T] f$.

  By the IH, $a_1 \CMHBLt[T]{A} f$.
  Take any $T' \in \crp(T)$ such that $A \subseteq \evts(T')$, and suppose $f \in T'$.
  By definition, $a_1 \TrLt[T'] f$.
  Since we assume $f \in \CS[T](a_2)$, we have $\thd(a_2) = \thd(f)$, so $a_2 \TrLt[T'] f \TrLt[T'] r_2$ where release $r_2$ matches~$a_2$.
  Since $T'$ is well formed (\cref{d:WF}) and $a_1 \TrLt[T'] f$, $e \TrLt[T'] a_2$.
  Hence, $e \TrLt[T'] f$.
  This shows that $e \CMHBLt[T]{A} f$.
\end{proof}

\begin{proof}
  [Proof of \cref{t:PWRcomplete}]
  Assume $A = \DP{(\ACQ{1},\REQ{1}),\ldots,(\ACQ{n},\REQ{n})}$.
  Since $A$ is a predictable deadlock (\cref{d:deadlock}), there is $T' \in \crp(T)$ such that every $\REQ{i}$ is the last event in its thread.

  To prove Condition~\cond{DP-PWR}, towards contradiction assume there are $1 \leq i < j \leq n$ such that $\REQ{i} \PWRLt[T] \REQ{j}$.
  By \cref{lem:PWRapprox}, $\REQ{i} \CMHBLt[T]{A} \REQ{j}$.
  Hence, by \cref{d:cmhb}, $\REQ{i} \TrLt[T'] \REQ{j}$.
  We construct $T''$ from $T'$ by changing the order of $\REQ{i}$ and $\REQ{j}$.
  Clearly, also $T'' \in \crp(T)$, but now $\REQ{j} \TrLt[T''] \REQ{i}$.
  But then $\REQ{i} \not\CMHBLt[T]{A} \REQ{j}$: a contradiction.
  Hence, by \cref{lem:PWRapprox}, $\REQ{i} \not\PWRLt[T] \REQ{j}$.

  To prove Condition~\cond{DP-Block}, towards contradiction assume that there is a cycle $B \DPLt[T] A$.
  Assume $B = \DP{(\ACQ{1}'',\REQB{1}),(\ACQ{2}'',\REQB{2})}$; the argument extends to size $j \leq n$ by induction.
  By \cref{def:ltDP}, $q'_1 \ne q_1$ and $q'_2 \ne q_2$.
  Moreover, for $i \in \{1,2\}$, $\ACQ{i}'' \in \AH(\REQ{i})$ and $q'_i \TrLt[T] q_i$.

  Take any $i \in \{1,2\}$.
  Because $\REQB{i}$ and $\REQ{i}$ have an acquire held in common, by \cref{d:CS}, $\thd(\REQB{i}) = \thd(\REQ{i})$.
  Hence, $q'_i \POLt[T] q_i$, so $q'_i \TrLt[T'] q_i$.
  Moreover, $\ACQ{i}'' \TrLt[T'] \REQB{i}$.
  Let $\ACQ{i}'$ be the acquire requesting $\REQ{i}'$.
  By Condition~\cond{WF-Req} (\cref{d:WF}), $\REQB{i} \TrLt[T'] \ACQ{i}' \TrLt[T'] \REQ{i}$.
  Let $\REL{i}'$ and $\REL{i}''$ be the releases matching $\ACQ{i}'$ and $\ACQ{i}''$, respectively.
  Since $a''_i \in \AH(q_i)$, $r''_i \in T$ implies $q_i \POLt[T] r''_i$.
  Because $\REQ{i}$ is the last event in its thread in $T'$, it follows that $\REL{i}'' \notin T'$.

  Let $j \in \{1,2\} \setminus \{i\}$.
  Analogously, $a''_j \TrLt[T'] q'_j \TrLt[T'] a'_j \TrLt[T'] q_j$, $r''_j \notin T'$, and all are in the same thread.
  By Condition~\cond{DP-Cycle}, $a''_i,q'_j,a'_j$ and $a''_j,q'_i,a'_i$ are pairwise on the same lock.
  Hence, by well formedness of $T'$, $r'_i,r'_j \in T'$ with $\REL{i}' \TrLt[T'] \ACQ{j}''$ and $\REL{j}' \TrLt[T'] \ACQ{i}''$.
  But then we obtain the following:
  $\REL1' \TrLt[T'] \ACQ2'' \TrLt[T'] \ACQ2' \TrLt[T'] \REL2' \TrLt[T'] \ACQ1'' \TrLt[T'] \ACQ1' \TrLt[T'] \REL1'$.
  Clearly, this cyclic ordering is impossible: a contradiction.
\end{proof}
\end{comment}


\begin{comment}
\section{PWR May Report False Positives}

Although Condition~\cond{DP-PWR} is complete w.r.t.\ predictable deadlocks, it is not sound.
We illustrate how PWR may report false positives by example.

\begin{figure}[t]
  \bda{@{}ccc@{}}
    % dl_6
    \begin{array}[t]{|l|l|l|}
      \hline
      T_{11} & \thread{1} & \thread{2} \\
      \hline
      \eventE{1} && \acqE{l_3} \\
      \eventE{2} && \writeE{x} \\
      \eventE{3} && \relE{l_3} \\
      \eventE{4} & \acqE{l_2} & \\
      \eventE{5} & \acqE{l_3} & \\
      \eventE{6} & \readE{x} & \\
      : && \\
      \hline
    \end{array}
    &
    \begin{array}[t]{|l|l|l|}
      \hline
      & \thread{1} & \thread{2} \\
      \hline
      : && \\
      \eventE{7} & \reqE{l_1} & \\
      \eventE{8} & \acqE{l_1} & \\
      \eventE{9} & \relE{l_1} & \\
      \eventE{10} & \relE{l_3} & \\
      \eventE{11} & \relE{l_2} & \\
      \eventE{12} && \acqE{l_3} \\
      : && \\
      \hline
    \end{array}
    &
    \begin{array}[t]{|l|l|l|}
      \hline
      & \thread{1} & \thread{2} \\
      \hline
      : & \hphantom{\acqE{l_3}} & \\
      \eventE{13} && \writeE{x} \\
      \eventE{14} && \relE{l_3} \\
      \eventE{15} && \acqE{l_1} \\
      \eventE{16} && \reqE{l_2} \\
      \eventE{17} && \acqE{l_2} \\
      \eventE{18} && \relE{l_2} \\
      \eventE{19} && \relE{l_1} \\
      \hline
    \end{array}
  \eda
  \caption{Trace where PWR reports a false positive.}
  \label{fig:PWR}
\end{figure}

Consider DP $\DP{(e_4,e_7),(e_{15},e_{16})}$ in trace~$T_{11}$ in \cref{fig:PWR}: $e_7$ and $e_{16}$ are not ordered by PWR so Condition~\cond{DP-PWR} is satisfied.
However, $e_7$ always occurs before $e_{16}$, because the last-write dependency between $e_2$ and $e_6$ preceding $e_7$, and the conflicting write $e_{13}$ preceding $e_{16}$, and both are protected by lock~$l_3$.
\end{comment}


\begin{comment}
\section{Impreciseness of Partial Orders from Related Works}

We elaborate on the impreciseness of the partial orders from related works discussed in \cref{sec:overview}, by discussing a few examples.

\begin{figure}[t]
  \begin{minipage}[b]{.49\textwidth}
    \bda{c}
      \ba{@{}l@{\hskip 2mm}l@{}}
        % ex0'
        \begin{array}[t]{@{}|@{\hskip 2pt}l@{\hskip 2pt}|l|l@{\hskip 2pt}|@{}}
          \hline
          T_{12} & \thread{1} & \thread{2} \\
          \hline
          \eventE{1} & \acqE{l_1} & \\
          \eventE{2} & \reqE{l_2} & \\
          \eventE{3} & \acqE{l_2} & \\
          \eventE{4} & \relE{l_2} & \\
          \eventE{5} & \relE{l_1} & \\
          \eventE{6} && \acqE{l_2} \\
          \eventE{7} && \reqE{l_1} \\
          \eventE{8} && \acqE{l_1} \\
          \eventE{9} && \relE{l_1} \\
          \eventE{10} && \relE{l_2} \\
          \hline
        \end{array}
        &
        % dl_14e
        \begin{array}[t]{@{}|@{\hskip 2pt}l@{\hskip 2pt}|l|l@{\hskip 2pt}|@{}}
          \hline
          T_{13} & \thread{1} & \thread{2} \\
          \hline
          \eventE{1} & \acqE{l_1} & \\
          \eventE{2} & \reqE{l_2} & \\
          \eventE{3} & \acqE{l_2} & \\
          \eventE{4} & \writeE{x} & \\
          \eventE{5} & \relE{l_2} & \\
          \eventE{6} & \relE{l_1} & \\
          \eventE{7} && \acqE{l_2} \\
          \eventE{8} && \writeE{x} \\
          \eventE{9} && \reqE{l_1} \\
          \eventE{10} && \acqE{l_1} \\
          \eventE{11} && \relE{l_1} \\
          \eventE{12} && \relE{l_2} \\
          \hline
        \end{array}
      \ea
    \eda
    \subcaption{HB, SHB, CP, WCP are too strict.}
    \label{fig:part-order}
  \end{minipage}%
  \begin{minipage}[b]{.49\textwidth}
    \bda{c}
      \ba{@{}l@{\hskip 2mm}l@{}}
        % dl_14f
        \begin{array}[t]{@{}|@{\hskip 2pt}l@{\hskip 2pt}|l|l@{\hskip 2pt}|@{}}
          \hline
          T_{14} & \thread{1} & \thread{2} \\
          \hline
          \eventE{1} & \acqE{l_1} & \\
          \eventE{2} & \reqE{l_2} & \\
          \eventE{3} & \acqE{l_2} & \\
          \eventE{4} & \relE{l_2} & \\
          \eventE{5} & \relE{l_1} & \\
          \eventE{6} & \writeE{x} & \\
          \eventE{7} && \readE{x} \\
          \eventE{8} && \acqE{l_2} \\
          \eventE{9} && \reqE{l_1} \\
          \eventE{10} && \acqE{l_1} \\
          \eventE{11} && \relE{l_1} \\
          \eventE{12} && \relE{l_2} \\
          \hline
        \end{array}
        &
        % reorder dl_14f
        \begin{array}[t]{@{}|@{\hskip 2pt}l@{\hskip 2pt}|l|l@{\hskip 2pt}|@{}}
          \hline
          T'_{14} & \thread{1} & \thread{2} \\
          \hline
          \eventE{1} & \acqE{l_1} & \\
          \eventE{7} && \readE{x} \\
          \eventE{8} && \acqE{l_2} \\
          \eventE{2} & \reqE{l_2} & \\
          \eventE{9} && \reqE{l_1} \\
          \hline
        \end{array}
      \ea
    \eda
    \subcaption{CP, WCP and SDP are not strict enough.}
    \label{fig:part-order2}
  \end{minipage}
  \caption{Performance of partial orders from prior works.}
\end{figure}

\paragraph{Happens Before.}

Lamport's Happens-Before relation ($\HBLt$) imposes the textual order on
critical sections.
For trace~$T_{12}$ in \cref{fig:part-order},
we find that $e_5 \HBLt e_6$ and hence $e_2 \HBLt e_7$.
Therefore, the DP $\DP{(e_1,e_2),(e_6,e_7)}$ would be rejected by Condition~\cond{DP-HB}.
In fact, this example demonstrates that this condition rejects literally all DPs.
The same applies to the partial order SHB~\cite{Mathur:2018:HFR:3288538:3276515}.

\paragraph{CP, WCP, and SDP.}

CP~\cite{Smaragdakis:2012:SPR:2103621.2103702},
WCP~\cite{conf/pldi/KiniMV17}, and
SDP~\cite{10.1145/3360605} are partial orders
that only order critical sections if they contain conflicting events.
For example, under WCP, events~$e_2$ and~$e_7$ in trace~$T_{12}$ in \cref{fig:part-order} are unordered.
CP, WCP, and SDP aim to detect more data races while retaining soundness, with the consequence that critical sections are often unnecessarily ordered.

Consider trace~$T_{13}$ in \cref{fig:part-order}
where $\DP{(e_1,e_2),(e_7,e_9)}$ is a DP.
Event~$e_4$ in thread~$\THD1$ and event~$e_8$ in thread~$\THD2$
are protected by the common lock~$\LKA$.
This lock causes WCP to order the critical sections, leading to $e_2 \WCPLt e_9$
where $\WCPLt$ denotes the WCP partial order.
Hence, Condition~\cond{DP-WCP} rejects the DP.
A similar observation applies to CP.
The SDP relation weakens WCP and does not order critical
sections if the conflict only involves writes.
Hence, $e_2$ and $e_9$ are unordered under SDP.
Note that it is still possible to construct an example where SDP needlessly orders
critical sections. %, but we omit it to conserve space.

The above examples suggest that CP, WCP, and SDP
could be useful for deadlock prediction.
We may expect many false negatives, but no false positives.
However, this conclusion is not correct as demonstrated by trace~$T_{14}$ in \cref{fig:part-order2}.

Strong DP $\DP{(e_1,e_2),(e_8,e_9)}$ is not a predictable deadlock.
Any reordering that manifest the deadlock violates
the last-write condition, as illustrated by the incorrectly reordered
prefix~$T'_{14}$ in \cref{fig:part-order2}.
However, under CP, WCP, and SDP
the events~$e_2$ and~$e_9$ are not ordered, because
CP, WCP, and SDP only order a write before a later read
only if they are protected by a common lock.
This lack of order is no problem for data race prediction,
as CP, WCP, and SDP aim to detect
the \emph{first} data race.
\end{comment}


\section{TRW for Soundness}

\begin{figure}[t]
%%latexTrace $ addLoc ex_ub9d_lt
\bda{|l|l|l|}
\hline  T_{11} & \thread{1} & \thread{2}\\ \hline
\eventE{1}  & \lockE{\LKA}&\\
\eventE{2}  & \lockE{\LKB}&\\
\eventE{3}  & \lockE{\LKC}&\\
\eventE{4}  & \writeE{\VA}&\\
\eventE{5}  & \unlockE{\LKC}&\\
\eventE{6}  & \unlockE{\LKB}&\\
\eventE{7}  & \lockE{\LKD}&\\
\eventE{8}  & \reqLockE{\LKE}&\\
\eventE{9}  & \lockE{\LKE}&\\
\eventE{10}  & \unlockE{\LKE}&\\
\eventE{11}  & \unlockE{\LKD}&\\
\eventE{12}  & \unlockE{\LKA}&\\
\eventE{13}  & &\lockE{\LKB}\\
\eventE{14}  & &\writeE{\VA}\\
\eventE{15}  & &\unlockE{\LKB}\\
\eventE{16}  & &\lockE{\LKA}\\
\eventE{17}  & &\unlockE{\LKA}\\
\eventE{18}  & &\lockE{\LKC}\\
\eventE{19}  & &\readE{\VA}\\
\eventE{20}  & &\lockE{\LKE}\\
\eventE{21}  & &\reqLockE{\LKD}\\
\eventE{22}  & &\lockE{\LKD}\\
\eventE{23}  & &\unlockE{\LKD}\\
\eventE{24}  & &\unlockE{\LKE}\\
\eventE{25}  & &\unlockE{\LKC}\\

\hline \eda{}
  \caption{Ordering conflicting write-write memory operations is critical for soundness.}
  \label{f:w-w-trw}
\end{figure}


The examples in \cref{fig:ex_3,fig:ex_5} show that
ordering conflicting write-read and read-write memory operations is critical to achieve soundness.
Trace $T_{11}$ in \cref{f:w-w-trw} shows that ordering
conflicting write-write memory operations is important as well.
We find that $A = \{(e_7,e_8), (e_{20},e_{21})\}$
satisfies Conditions~\cond{DP-Guard/-Cycle/-Block}
but \emph{not} \cond{DP-TRW} because $e_8 \TRWLt e_{21}$.
Were we to ignore the write-write dependency $e_4 \TRWLt e_{14}$, then
$e_8$ and $e_{21}$ become unordered.
However, $A$ is not a predictable deadlock: there is no reordering
where $e_8$ and $e_{21}$ are the last events in their respective threads.
This shows that ordering \emph{all} conflicting memory operations is critical for soundness.

\section{Full Table ``Number of concrete lock dependencies''}

See \cref{tbl:details-full}.

%%table_benchmarks_time_details_time_vcd_no_evt_stats
\begin{table*}[p]
    \caption{
    \textbf{Extended version of \cref{tbl:details} containing all benchmarks.}
  }
  \label{tbl:details-full}
  {
  \small
  \setlength{\tabcolsep}{4.8pt} % Compress horizontally.
  \renewcommand{\arraystretch}{0.91} % Compress vertically.
\begin{tabular}{|r||r|r|r||r|r||r|r|r|}
 \hline
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9
 \\
 \hline
\multirow{2}{*}{\Benchmark} &
\multicolumn{3}{c||}{\UDTRWEvict} &
\multicolumn{2}{c||}{\UDTRW} &
\multicolumn{3}{c|}{\SPDOfflineUD} \\ \cline{2-4} \cline{5-6} \cline{7-9}
& \Cycles &  \Dependencies & \Time \ (\PhaseOne+\PhaseTwo)
& \Cycles & \Time \ (\PhaseOne+\PhaseTwo)
& \Cycles & \Dependencies & \Time \ (\PhaseOne+\PhaseTwo)
 \\
 \hline
Deadlock & 0 & 2 & 0 (0+0) & 0 & 0 (0+0) & 0 & 1 & 0 (0+0)  \\   \hline
NotADeadlock & 0 & 2 & 0 (0+0) & 0 & 0 (0+0) & 0 & 1 & 0 (0+0)  \\   \hline
Picklock & 1 & 6 & 0 (0+0) & 1 & 0 (0+0) & 1 & 5 & 0 (0+0)  \\   \hline
Bensalem & 1 & 6 & 0 (0+0) & 1 & 0 (0+0) & 1 & 6 & 0 (0+0)  \\   \hline
Transfer & 0 & 2 & 0 (0+0) & 0 & 0 (0+0) & 0 & 1 & 0 (0+0)  \\   \hline
Test-Dimminux & 2 & 7 & 0 (0+0) & 2 & 0 (0+0) & 2 & 7 & 0 (0+0)  \\   \hline
StringBuffer & 1 & 2 & 0 (0+0) & 1 & 0 (0+0) & 1 & 3 & 0 (0+0)  \\   \hline
Test-Calfuzzer & 1 & 5 & 0 (0+0) & 1 & 0 (0+0) & 1 & 5 & 0 (0+0)  \\   \hline
DiningPhil & 1 & 5 & 0 (0+0) & 1 & 0 (0+0) & 1 & 25 & 0 (0+0)  \\   \hline
HashTable & 0 & 1 & 0 (0+0) & 0 & 0 (0+0) & 0 & 42 & 0 (0+0)  \\   \hline
Account & 0 & 9 & 0 (0+0) & 0 & 0 (0+0) & 0 & 9 & 0 (0+0)  \\   \hline
Log4j2 & 0 & 3 & 0 (0+0) & 0 & 0 (0+0) & 0 & 3 & 0 (0+0)  \\   \hline
Dbcp1 & 1 & 5 & 0 (0+0) & 1 & 0 (0+0) & 1 & 5 & 0 (0+0)  \\   \hline
Dbcp2 & 0 & 10 & 0 (0+0) & 0 & 0 (0+0) & 0 & 17 & 0 (0+0)  \\   \hline
Derby2 & 0 & 0 & 0 (0+0) & 0 & 0 (0+0) & 0 & 0 & 0 (0+0)  \\   \hline
elevator & 0 & 0 & 1 (1+0) & 0 & 1 (1+0) & 0 & 0 & 1 (1+0)  \\   \hline
hedc & 0 & 4 & 1 (1+0) & 0 & 1 (1+0) & 0 & 4 & 1 (1+0)  \\   \hline
JDBCMySQL-1 & 0 & 23 & 1 (1+0) & 0 & 1 (1+0) & 0 & 3\mbox{K} & 1 (1+0)  \\   \hline
JDBCMySQL-2 & 0 & 24 & 1 (1+0) & 0 & 1 (1+0) & 0 & 3\mbox{K} & 1 (1+0)  \\   \hline
JDBCMySQL-3 & 1 & 28 & 1 (1+0) & 1 & 1 (1+0) & 1 & 3\mbox{K} & 1 (1+0)  \\   \hline
JDBCMySQL-4 & 1 & 30 & 1 (1+0) & 1 & 1 (1+0) & 1 & 3\mbox{K} & 1 (1+0)  \\   \hline
cache4j & 0 & 31 & 2 (2+0) & 0 & 2 (2+0) & 0 & 10\mbox{K} & 2 (2+0)  \\   \hline
ArrayList & 4 & 123 & 24 (24+0) & 4 & 24 (24+0) & 4 & 8\mbox{K} & 7 (7+0)  \\   \hline
IdentityHashMap & 1 & 42 & 25 (25+0) & 1 & 25 (25+0) & 1 & 79 & 8 (8+0)  \\   \hline
Stack & 3 & 2\mbox{K} & 44 (44+0) & 3 & 43 (43+0) & 3 & 95\mbox{K} & 8 (8+1)  \\   \hline
LinkedList & 4 & 118 & 27 (27+0) & 4 & 27 (27+0) & 4 & 7\mbox{K} & 9 (9+0)  \\   \hline
HashMap & 1 & 40 & 27 (27+0) & 1 & 27 (27+0) & 1 & 4\mbox{K} & 10 (10+0)  \\   \hline
WeakHashMap & 1 & 40 & 27 (27+0) & 1 & 28 (28+0) & 1 & 4\mbox{K} & 10 (10+0)  \\   \hline
Vector & 1 & 3 & 11 (11+0) & 1 & 10 (10+0) & 1 & 200\mbox{K} & 9 (9+0)  \\   \hline
LinkedHashMap & 1 & 40 & 29 (29+0) & 1 & 30 (30+0) & 1 & 4\mbox{K} & 12 (12+0)  \\   \hline
montecarlo & 0 & 0 & 23 (23+0) & 0 & 23 (23+0) & 0 & 0 & 23 (23+0)  \\   \hline
TreeMap & 1 & 40 & 41 (41+0) & 1 & 41 (41+0) & 1 & 4\mbox{K} & 24 (24+0)  \\   \hline
hsqldb & 0 & 2\mbox{K} & 57 (57+0) & 0 & 57 (56+0) & 0 & 125\mbox{K} & 56 (55+0)  \\   \hline
sunflow & 0 & 45 & 67 (67+0) & 0 & 68 (68+0) & 0 & 248 & 66 (66+0)  \\   \hline
jspider & 0 & 158 & 72 (72+0) & 0 & 73 (73+0) & 0 & 2\mbox{K} & 72 (72+0)  \\   \hline
tradesoap & 0 & 9\mbox{K} & 173 (166+6) & 0 & 174 (168+6) & 0 & 40\mbox{K} & 163 (157+6)  \\   \hline
tradebeans & 0 & 9\mbox{K} & 177 (171+6) & 0 & 177 (171+6) & 0 & 40\mbox{K} & 166 (160+6)  \\   \hline
TestPerf & 0 & 0 & 196 (196+0) & 0 & 199 (199+0) & 0 & 0 & 192 (192+0)  \\   \hline
Groovy2 & 0 & 11\mbox{K} & 380 (379+1) & 0 & 386 (385+1) & 0 & 29\mbox{K} & 372 (371+1)  \\   \hline
tsp & 0 & 0 & 992 (992+0) & 0 & 989 (989+0) & 0 & 0 & 997 (997+0)  \\   \hline
lusearch & 0 & 87 & 719 (719+0) & 0 & 723 (723+0) & 0 & 41\mbox{K} & 719 (719+0)  \\   \hline
biojava & 0 & 89 & 656 (656+0) & 0 & 656 (656+0) & 0 & 545 & 661 (661+0)  \\   \hline
graphchi & 0 & 50 & 756 (756+0) & 0 & 756 (756+0) & 0 & 82 & 754 (754+0)  \\   \hline
 \hline
\Sum & 27 & 33\mbox{K} & 4533 (4518+14) & 27 & 4545 (4531+14) & 27 & 626\mbox{K} & 4348 (4333+15)
 \\  \hline   \end{tabular}
}
\end{table*}

\section{TRW-Boundedness Check}


\begin{algorithm*}[t!]
  \caption{\cref{alg:lock-deps} extended with TRW-boundedness check.}
  \label{alg:lock-deps-guard-check}

  {\small
    \begin{algorithmic}[1]
      \Function{computeTRWLockDeps}{$T$}
      \label{ln:g-cLDs}
        \State $\forall t \colon \threadVC{t} = [\bar{0}]; \incC{\threadVC{t}}{t}$
        \Comment{Vector clock $\threadVC{t}$ of thread $t$}
        \label{ln:g-thvc}
        \State $\forall x \colon \lastWriteVC{x} = [\bar{0}]; \lastReadVC{x} = [\bar{0}]$
        \Comment{Vector clocks $\lastWriteVC{x},\lastReadVC{x}$ of most recent $\writeE{x},\readE{x}$}
        \label{ln:g-lwlr}
        \State $\forall l \colon \acqVC{l} = [\bar{0}]$
        \Comment{Vector clock $\acqVC{l}$ of most recent $\acqE{l}$}
        \label{ln:g-acqv}
        \State $\forall l \colon \Hist{l} = []$
        \Comment{History $\Hist{l}$ of acquire-release pairs $(\Vacq,\Vrel)$ for lock $l$}
        \label{ln:g-hist}
        \State $\forall t \colon \AcqHeld(t) = []$
        \Comment{Sequence $\AcqHeld(t)$ of acquires held by thread $t$}
        \label{ln:g-acqhd}
        \State $\LDMapSym = \emptyset$
        \Comment{Map  with keys $(t,l,ls)$,
                 list values with elements $(i,V,\{a_1,\ldots,a_n\})$}
        \label{ln:g-ld}
        \State $\GlobalLS = \emptyset$
        \Comment{Global lockset across all threads}
        \label{ln:g-gls}
        \State $\GCMapSym = \emptyset$
        \Comment{Map  with keys $(t,l)$ and vector clock values}
        \label{ln:g-gmap}
        \ForDo {$e$ in $T$} {\Call{process}{$e$}}
        \State \Return \LDt
      \EndFunction
      \algstore{cld}
    \end{algorithmic}

    \begin{minipage}[t]{.54\textwidth}
      \begin{algorithmic}[1]
        \algrestore{cld}
        \Procedure{process}{$(\alpha,t,acq(l))$}
          \label{ln:g-procAcq}
          \If {$\AcqHeld(t) \not = []$}
          \label{ln:g-acq-non-empty}
          \State $ls = \{ l' \mid \acqE{l'} \in \AcqHeld(t) \}$
          \label{ln:g-ld-ls}
          \State $\LDMap{t}{l}{ls}.pushBack(\alpha,\threadVC{t},\AcqHeld(t))$
          %% \State $\LDt = \LDt \cup \{ \LD{t}{l,\threadVC{t}}{\AcqHeld(t)} \}$
            \label{ln:g-ld-add}
          \EndIf
          \State $\AcqHeld(t) = \AcqHeld(t) \cup \{ (\alpha,t,acq(l)) \}$
          \label{ln:g-acq-push}
          \State $\GlobalLS = \GlobalLS \cup \{ l \}$
          \label{ln:g-global-lockset-push}
          \For{$l \in \GlobalLS, acq(l) \not\in \AcqHeld(t), \acqVC{l} < \threadVC{t}$}
          \label{ln:g-guard-candidate}
          \If{$\GCMapSym[l][t].empty()$}
          \State $\GCMapSym[l][t] = \threadVC{t}$
          \label{ln:g-first-entry}
          \EndIf
          \EndFor
          %% The above represents the ``pre'' vector clock = request
          \State $\threadVC{t} = \Call{syncCS}{\threadVC{t},\AcqHeld(t)}$
          \label{ln:g-acq-sync}
          \State $\acqVC{l} = \threadVC{t}$
          \label{ln:g-acq-store}
          \State $\incC{\threadVC{t}}{t}$
          \label{ln:g-acq-vc-inc}
        \EndProcedure
        \algstore{eacq}
      \end{algorithmic}


      \begin{algorithmic}[1]
        \algrestore{eacq}
        \Procedure{process}{$(\dontCare,t,rel(l))$}
        \label{ln:g-procRel}
        \For{$t', \neg \GCMapSym[l][t'].empty()$}
        \If{$\GCMapSym[l][t'] < \threadVC{t}$}
        \label{ln:g-guard-check}
        \State ``TRW-boundedness violated''
        \EndIf
        \EndFor
        \State $\GCMapSym[l] = \emptyset$
        \label{ln:g-init-map}
          \State $\AcqHeld(t) = \{\dontCare,\dontCare,acq(l')) \in \AcqHeld(t) \mid l' \not= l \}$
          \label{ln:g-acq-pop}
          \State $\GlobalLS = \GlobalLS - \{ l \}$
          \label{ln:g-global-lockset-pop}
          \State $\Hist{l} = \Hist{l} \cup \{(\Acq{l}, \threadVC{t})\}$
          \label{ln:g-hist-add}
          \State $\incC{\threadVC{t}}{t}$
          \label{ln:g-rel-vc-inc}
        \EndProcedure
        \algstore{erel}
      \end{algorithmic}

      %% MS: omit for brevity
      %% \begin{algorithmic}[1]
      %%   \Procedure{\mbox{$e$}@fork}{$t,s$}
      %% \State $\threadVC{s} = \threadVC{t}$
      %% \State $\incC{\threadVC{t}}{t}$
      %% \EndProcedure
      %% \end{algorithmic}

      %% MS: omit for brevity
      %% \begin{algorithmic}[1]
      %%   \Procedure{\mbox{$e$}@join}{$t,s$}
      %%   \State $\threadVC{t} = \threadVC{s} \sqcup \threadVC{t}$
      %%   \If {RO}
      %%   \State $\threadVC{t} = \Call{syncCS}{\threadVC{t},\StdLocksSym(t)}$
      %%   \EndIf
      %% \State $\incC{\threadVC{t}}{t}$
      %% \EndProcedure
      %% \end{algorithmic}
    \end{minipage}%
    %
    \hfill%
    %
    \begin{minipage}[t]{.46\textwidth}
      \begin{algorithmic}[1]
        \algrestore{erel}
        \Procedure{process}{$(\dontCare,t,wr(x))$}
          %% TWR-only
          \label{ln:g-procWr}
          \State $\threadVC{t} = \threadVC{t} \sqcup \lastWriteVC{x}$
          \label{ln:g-ww-sync}
          \State $\threadVC{t} = \threadVC{t} \sqcup \lastReadVC{x}$
          \label{ln:g-rw-sync}
          \State $\threadVC{t} = \Call{syncCS}{\threadVC{t},\AcqHeld(t)}$
          \label{ln:g-csw-sync}
          %% TWR + PWR
          \State $\lastWriteVC{x} = \threadVC{t}$
          \label{ln:g-lw-store}
          \State $\incC{\threadVC{t}}{t}$
          \label{ln:g-wr-vc-inc}
        \EndProcedure
        \algstore{ewr}
      \end{algorithmic}


      \begin{algorithmic}[1]
        \algrestore{ewr}
        \Procedure{process}{$(\dontCare,t,rd(x))$}
          \label{ln:g-procRd}
          \State $\threadVC{t} = \threadVC{t} \sqcup \lastWriteVC{x}$
          \label{ln:g-wr-sync}
          \State $\threadVC{t} = \Call{syncCS}{\threadVC{t},\AcqHeld(t)}$
          \label{ln:g-csr-sync}
            \State $\lastReadVC{x} = \threadVC{t}$ %% TWR-only
          \label{ln:g-lr-store}
          \State $\incC{\threadVC{t}}{t}$
          \label{ln:g-rd-vc-inc}
        \EndProcedure
        \algstore{erd}
      \end{algorithmic}

      \begin{algorithmic}[1]
        \algrestore{erd}
        \Function{syncCS}{$V, A$}
          \label{ln:g-syncCS}
          \For {$\acqE{l} \in A , (\Vacq, \Vrel) \in \Hist{l}$}
          \label{ln:g-sync-hist-entry}
            \IfThen {$\Vacq < V$} {$V = V \sqcup \Vrel$}
            \label{ln:g-ro-sync}
          \EndFor
        \State \Return V
        \EndFunction
        % \algstore{sync}
      \end{algorithmic}
    \end{minipage}
  }
\end{algorithm*}


In terms of vector clocks, TWR boundedness is violated
if there is a pair of acquire-release vector clocks $(V_{acq}, V_{rel})$
and a request vector clock $V'$
such that $V_{acq} < V' < V_{rel}$ and the request results from
a thread other than the acquire-release pair.

\cref{alg:lock-deps-guard-check} integrates
the TRW-boundedness check in Phase~(1).
We additionally maintain the set $\GlobalLS$ of locks
held across all threads and
use map $\GCMapSym$ to check for potential `guard' locks
that violate the TRW-boundedness condition.

For every acquire event, we check for a potential guard lock that
has been acquired by some other thread and that is TRW ordered
(\cref{ln:g-guard-candidate} in \cref{alg:lock-deps-guard-check}).
For each potential guard lock~$l$ and thread~$t$, we record
the vector clock $\threadVC{t}$ (corresponding to the vector clock of the request).
There may be multiple requests with vector clocks $V_1,...,V_n$
that satisfy \cref{ln:g-guard-candidate}.
For every such $V_i$, we check whether $V_i < V_{rel(l)}$
where $V_{rel(l)}$ is the vector clock of the release event
that belongs to the acquire event $\acqVC{l}$.
If there is such $V_i$,
then TRW boundedness is violated.
Because $V_1 < \ldots < V_n$, it sufficies to only
check the ``earlier'' vector clock $V_1$.
Storage of $V_1$ is done on \cref{ln:g-first-entry}.
The check $V_1 < V_{rel(l)}$ is carried out on \cref{ln:g-guard-check}.

Access to the map $\GCMapSym$ takes constant time, and
the set of guard locks and threads to consider can be treated
as a constant.
Hence, the main cost factors of our TRW-boundedness check are vector-clock operations.
The number of vector-clock operations remains linear in the number of events.
We conclude that the time complexity of Phase~(1) is unaffected.
Measurements show that the TRW-boundedness check
does not cause any additional overhead.
See \cref{tbl:guard}, where \UDTRWGuardCheck
is the variant that includes the TRW-boundedness check described
above.


%%table_benchmarks_time_details_time_guard_check
\begin{table*}[t]
    \caption{
      \textbf{Impact of TWR-boundedness check.}
          Columns~2--5 contain the number of events, of threads,
    of memory locations, and of locks, respectively.
    Columns~6--9 contain the number of deadlocks reported and running time for each candidate.
      Times are rounded to the nearest second, and reported for Phases~(1) and~(2) separately.
  }
    \label{tbl:guard}
  {
  % \scriptsize
  \small
  \setlength{\tabcolsep}{4.7pt} % Compress horizontally.
  \renewcommand{\arraystretch}{0.91} % Compress vertically.
\begin{tabular}{|r|r|r|r|r||r|r||r|r|}
 \hline
1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9
 \\
 \hline
\multirow{2}{*}{\Benchmark} &
\multirow{2}{*}{\EE} &
\multirow{2}{*}{\TT} &
\multirow{2}{*}{\MM} &
\multirow{2}{*}{\LL} &
\multicolumn{2}{c||}{\UDTRW} &
\multicolumn{2}{c|}{\UDTRWGuardCheck} \\ \cline{6-7} \cline{8-9}
 & & & &
& \Cycles &  \Time \ (\PhaseOne+\PhaseTwo)
& \Cycles & \Time \ (\PhaseOne+\PhaseTwo)
 \\
 \hline
Deadlock & 28 & 3 & 3 & 2 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
NotADeadlock & 42 & 3 & 3 & 4 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
Picklock & 46 & 3 & 5 & 5 & 1 & 0 (0+0) & 1 & 0 (0+0)  \\   \hline
Bensalem & 45 & 4 & 4 & 4 & 1 & 0 (0+0) & 1 & 0 (0+0)  \\   \hline
Transfer & 56 & 3 & 10 & 3 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
Test-Dimminux & 50 & 3 & 8 & 6 & 2 & 0 (0+0) & 2 & 0 (0+0)  \\   \hline
StringBuffer & 57 & 3 & 13 & 3 & 1 & 0 (0+0) & 1 & 0 (0+0)  \\   \hline
Test-Calfuzzer & 126 & 5 & 15 & 5 & 1 & 0 (0+0) & 1 & 0 (0+0)  \\   \hline
DiningPhil & 210 & 6 & 20 & 5 & 1 & 0 (0+0) & 1 & 0 (0+0)  \\   \hline
HashTable & 222 & 3 & 4 & 2 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
Account & 617 & 6 & 46 & 6 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
Log4j2 & 1\mbox{K} & 4 & 333 & 10 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
Dbcp1 & 2\mbox{K} & 3 & 767 & 4 & 1 & 0 (0+0) & 1 & 0 (0+0)  \\   \hline
Dbcp2 & 2\mbox{K} & 3 & 591 & 9 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
Derby2 & 3\mbox{K} & 3 & 1\mbox{K} & 3 & 0 & 0 (0+0) & 0 & 0 (0+0)  \\   \hline
elevator & 222\mbox{K} & 5 & 726 & 51 & 0 & 1 (1+0) & 0 & 1 (1+0)  \\   \hline
hedc & 410\mbox{K} & 7 & 109\mbox{K} & 7 & 0 & 1 (1+0) & 0 & 1 (1+0)  \\   \hline
JDBCMySQL-1 & 436\mbox{K} & 3 & 73\mbox{K} & 10 & 0 & 1 (1+0) & 0 & 1 (1+0)  \\   \hline
JDBCMySQL-2 & 436\mbox{K} & 3 & 73\mbox{K} & 10 & 0 & 1 (1+0) & 0 & 1 (1+0)  \\   \hline
JDBCMySQL-3 & 436\mbox{K} & 3 & 73\mbox{K} & 12 & 1 & 1 (1+0) & 1 & 1 (1+0)  \\   \hline
JDBCMySQL-4 & 437\mbox{K} & 3 & 73\mbox{K} & 13 & 1 & 1 (1+0) & 1 & 1 (1+0)  \\   \hline
cache4j & 758\mbox{K} & 2 & 46\mbox{K} & 19 & 0 & 2 (2+0) & 0 & 2 (2+0)  \\   \hline
ArrayList & 3\mbox{M} & 801 & 121\mbox{K} & 801 & 4 & 24 (24+0) & 4 & 24 (24+0)  \\   \hline
IdentityHashMap & 3\mbox{M} & 801 & 496\mbox{K} & 801 & 1 & 25 (25+0) & 1 & 25 (25+0)  \\   \hline
Stack & 3\mbox{M} & 801 & 118\mbox{K} & 2\mbox{K} & 3 & 43 (43+0) & 3 & 44 (43+0)  \\   \hline
LinkedList & 3\mbox{M} & 801 & 290\mbox{K} & 801 & 4 & 27 (27+0) & 4 & 27 (27+0)  \\   \hline
HashMap & 3\mbox{M} & 801 & 555\mbox{K} & 801 & 1 & 27 (27+0) & 1 & 27 (27+0)  \\   \hline
WeakHashMap & 3\mbox{M} & 801 & 540\mbox{K} & 801 & 1 & 28 (28+0) & 1 & 27 (27+0)  \\   \hline
Vector & 3\mbox{M} & 3 & 14 & 3 & 1 & 10 (10+0) & 1 & 10 (10+0)  \\   \hline
LinkedHashMap & 4\mbox{M} & 801 & 617\mbox{K} & 801 & 1 & 30 (30+0) & 1 & 29 (29+0)  \\   \hline
montecarlo & 8\mbox{M} & 3 & 850\mbox{K} & 2 & 0 & 23 (23+0) & 0 & 23 (23+0)  \\   \hline
TreeMap & 9\mbox{M} & 801 & 493\mbox{K} & 801 & 1 & 41 (41+0) & 1 & 41 (41+0)  \\   \hline
hsqldb & 20\mbox{M} & 46 & 945\mbox{K} & 402 & 0 & 57 (56+0) & 0 & 56 (56+0)  \\   \hline
sunflow & 21\mbox{M} & 15 & 2\mbox{M} & 11 & 0 & 68 (68+0) & 0 & 67 (67+0)  \\   \hline
jspider & 22\mbox{M} & 11 & 5\mbox{M} & 14 & 0 & 73 (73+0) & 0 & 72 (72+0)  \\   \hline
tradesoap & 42\mbox{M} & 236 & 3\mbox{M} & 6\mbox{K} & 0 & 174 (168+6) & 0 & 171 (165+6)  \\   \hline
tradebeans & 42\mbox{M} & 236 & 3\mbox{M} & 6\mbox{K} & 0 & 177 (171+6) & 0 & 175 (169+6)  \\   \hline
TestPerf & 80\mbox{M} & 50 & 598 & 8 & 0 & 199 (199+0) & 0 & 195 (195+0)  \\   \hline
Groovy2 & 120\mbox{M} & 13 & 13\mbox{M} & 10\mbox{K} & 0 & 386 (385+1) & 0 & 384 (383+1)  \\   \hline
tsp & 307\mbox{M} & 10 & 181\mbox{K} & 2 & 0 & 989 (989+0) & 0 & 991 (991+0)  \\   \hline
lusearch & 217\mbox{M} & 10 & 5\mbox{M} & 118 & 0 & 723 (723+0) & 0 & 718 (718+0)  \\   \hline
biojava & 221\mbox{M} & 6 & 121\mbox{K} & 78 & 0 & 656 (656+0) & 0 & 659 (659+0)  \\   \hline
graphchi & 216\mbox{M} & 20 & 25\mbox{M} & 60 & 0 & 756 (756+0) & 0 & 775 (775+0)  \\   \hline
 \hline
\Sum & 1354\mbox{M} & 7\mbox{K} & 61\mbox{M} & 30\mbox{K} & 27 & 4545 (4531+14) & 27 & 4546 (4532+14)
\\  \hline   \end{tabular}
}
\end{table*}

\section{Preliminary Access to our Implementation and Experiment Setup}

We plan to our implementation as an artifact; preliminary access is available at \url{https://osf.io/ku9fx/files/osfstorage?view_only=b7f53d3110894fe39ad1520ed0fed4ec} (anonymized link).
Reviewers are welcome to confirm our results by downloading our implementation and benchmark traces.
The repository contains a `README.md' with build and execution instructions.
Note that the repository formats MarkDown poorly, so we strongly advise to download `README.md' and view it locally.





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main.tex"
%%% End:
