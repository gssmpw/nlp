\section{Appendix}















\subsection{Syntax}

\begin{tabular}{rlrcl}
  \disc & Expressions     & $\eM,\eN$       & ::=   & $\eco X$ | $\etrue$ | $\efalse$ | $\eM\eand\eN$ | $\enot\eM$                                                          \\
        &                 &                 & |     & $\eunitelt$ | $\epair\eM\eN$ | $\efst~\eM$ | $\esnd~\eM$                                                              \\
        &                 &                 & |     & $\eret~\eM$ | $\eletin {\eco X}\eM\eN$ | $\eite\scoe\eM\eN$                                                           \\
        &                 &                 & |     & $\eflip~\scoe$ | $\eobserve~\eM$ | $\esample[\scoe]$                                                                  \\
        & Types           & $\eA,\eB$       & ::=   & $\eunit$ | $\ebool$ | $\eA\etimes\eB$                                                                                 \\
        & Contexts        & $\eDelta$       & ::=   & $\eco{X_{1}} : \eco{A_{1}},\dots,\eco{X_n} : \eco{A_n}$                                                               \\
  \\
  \cont & Expressions     & $\scoe$         & ::=   & $\sco x$ | $\strue$ | $\sfalse$ | $r$ | $\seone\sadd\setwo$ | $\sneg\scoe$ | $\seone\smul\setwo$ | $\seone\sle\setwo$ \\
        &                 &                 & |     & $\sunitelt$ | $\spair\seone\setwo$ | $\sfst~\scoe$ | $\ssnd~\scoe$                                                    \\
        &                 &                 & |     & $\sret~\scoe$ | $\sletin {\sco x}{\seone}{\setwo}$ | $\site{\seone}{\setwo}{\sethr}$                                  \\
        &                 &                 & |     & $\sco{d}$ | $\sco{\texttt{obs}(\scoe_{o}, d)}$  | $\sexact[\eco M]$                                               \\
        & Distributions   & $\sco{d}$       & ::=   & $\sflip~\scoe$ | $\sunif~\seone~\setwo$ | $\spois~\scoe$                                                             \\
        & Types           & $\ssigma,\stau$ & ::=   & $\sunit$ | $\sbool$ | $\sreal$ | $\ssigma\stimes\stau$                                                                \\
        & Contexts        & $\sGamma$       & ::=   & $\sco{x_1} : \sco{\tau_1},\dots,\sco{x_n} : \sco{\tau_n}$                                                             \\
        & Number literals & $r$             & $\in$ & $\R$                                                                                                                  \\
\end{tabular}

\subsection{Typing rules}

\subsubsection{Convertibility}

\begin{mathpar}
  \inferrule{~}{\eunit \convrel \sunit}
  \and
  \inferrule{~}{\ebool \convrel \sbool}
  \and
  \inferrule{\eA\convrel \stau \\ \eB\convrel\ssigma}
  {\eA\etimes\eB\convrel \stau\stimes\ssigma}
\end{mathpar}

\subsubsection{Pure exact sublanguage}

\begin{mathpar}
  \inferrule{\eDelta(\eco X) = \eA}
  {\epuretydefault{\eco X}{\eA}}
  \and
  \inferrule {~} {\epuretydefault{\etrue}{\ebool}}
  \and
  \inferrule {~} {\epuretydefault{\efalse}{\ebool}}
  \and
  \inferrule {\epuretydefault\eM\ebool \\ \epuretydefault\eN\ebool} {\epuretydefault{\eM\eand\eN}{\ebool}}
  \and
  \inferrule {\epuretydefault\eM\ebool} {\epuretydefault{\enot\eM}{\ebool}}
  \and
  \inferrule {~} {\epuretydefault{\eunitelt}{\eunit}}
  \and
  \inferrule
  {
    \epuretydefault{\eM}{\eA}
    \\
    \epuretydefault{\eN}{\eB}}
  {\epuretydefault{\epair\eM\eN}{\eA\etimes\eB}}
  \and
  \inferrule
  { \epuretydefault{\eM}{\eA\times\eB} }
  {\epuretydefault{\efst~\eM}{\eA}}
  \and
  \inferrule
  { \epuretydefault{\eM}{\eA\times\eB} }
  {\epuretydefault{\esnd~\eM}{\eB}}
\end{mathpar}

\subsubsection{Effectful exact sublanguage}

\begin{mathpar}
  \inferrule{\epuretydefault\eM\eA}{\ecomptydefault{\eret~\eM}{\eA}}
  \and
  \inferrule{
    \ecomptydefault\eM\eA
    \\
    \ecompty\sGamma{\eDelta,\eco X\ofty \eA}\eM\eB}
  {\ecomptydefault{\eletin{\eco X}\eM\eN}{\eB}}
  \and
  \inferrule {
    \spuretydefault\scoe\sbool
    \\
    \ecomptydefault\eM\eA
    \\
    \ecomptydefault\eN\eA
  } {\ecomptydefault{\eite\scoe\eM\eN}{\eA}}
  \and
  \inferrule {\spuretydefault\scoe\sreal}{\ecomptydefault{\eflip~\scoe}{\ebool}}
  \and
  \inferrule {\epuretydefault\eM\ebool} {\ecomptydefault{\eobserve~\eM}{\eunit}}
  \and
  \inferrule {\scomptydefault{\scoe}{\stau}
  \\ \eA\convrel\stau} {\ecomptydefault{\esample[\scoe]}{\eA}}
\end{mathpar}

\subsubsection{Pure sampling sublanguage}

\begin{mathpar}
  \inferrule{\sGamma(\sco x) = \stau}
  {\spuretydefault{\sco x}{\stau}}
  \and
  \inferrule {~} {\spuretydefault{\strue}{\sbool}}
  \and
  \inferrule {~} {\spuretydefault{\sfalse}{\sbool}}
  \and
  \inferrule {~} {\spuretydefault{r}{\sreal}}
  \and
  \inferrule {\spuretydefault{\seone}\sreal
  \\ \spuretydefault\setwo\sreal}
  {\spuretydefault{\seone\sadd\setwo}{\sreal}}
  \and
  \inferrule {\spuretydefault{\scoe}\sreal}
  {\spuretydefault{\sneg\scoe}{\sreal}}
  \and
  \inferrule {\spuretydefault{\seone}\sreal
  \\ \spuretydefault\setwo\sreal}
  {\spuretydefault{\seone\smul\setwo}{\sreal}}
  \and
  \inferrule {\spuretydefault{\seone}\sreal
  \\ \spuretydefault\setwo\sreal}
  {\spuretydefault{\seone\sle\setwo}{\sbool}}
  \and
  \inferrule {~} {\spuretydefault\sunitelt{\sunit}}
  \and
  \inferrule
  {
    \spuretydefault{{\seone}}{\ssigma}
    \\
    \spuretydefault{\setwo}{\stau}}
  {\spuretydefault{\spair\seone\setwo}{\ssigma\stimes\stau}}
  \and
  \inferrule
  {
    \spuretydefault{{\scoe}}{\ssigma\stimes\stau}
    }
  {\spuretydefault{\sfst~{\scoe}}{\stau}}
  \and
  \inferrule
  { \spuretydefault{{\scoe}}{\ssigma\stimes\stau} }
  {\spuretydefault{\ssnd~{\scoe}}{\stau}}
\end{mathpar}

\subsubsection{Effectful sampling sublanguage}

\begin{mathpar}
  \inferrule{\spuretydefault{\scoe}\stau}{\scomptydefault{\sret~{\scoe}}{\stau}}
  \and
  \inferrule{
    \scomptydefault{\seone}\ssigma
    \\
    \scompty{\sGamma,\sco x\ofty \ssigma}{\eDelta}{\setwo}\stau}
  {\scomptydefault{\sletin {\sco x}{\seone}{\setwo}}{\stau}}
  \and
  \inferrule {
    \spuretydefault{\seone}\sbool
    \\
    \scomptydefault{\setwo}\stau
    \\
    \scomptydefault{\sethr}\stau
  } {\scomptydefault{\site\seone\setwo\sethr}{\stau}}
  \and
  \inferrule {\spuretydefault\scoe\sreal}{\scomptydefault{\sflip~\scoe}{\sbool}}
  \and
  \inferrule {
    \spuretydefault{\seone}{\sreal}\\
    \spuretydefault{\setwo}{\sreal}
    }
  {\scomptydefault{\sunif~\seone~\setwo}{\sreal}}
  \and
  \inferrule {\spuretydefault\scoe\sreal} {\scomptydefault{\spois~\scoe}{\sreal}}
  \and
  \inferrule {\ecomptydefault\eM{\eA}
    \\ \eA\convrel\stau} {\scomptydefault{\sexact[\eM]}{\stau}}

  \and

  \inferrule {\spuretydefault{\seobs}\sbool  \\ \spuretydefault\seone\sreal}
             {\scomptydefault{\sobserve{\seobs}{\sflip~\seone}}{\sunit}}

  \and

  \inferrule {
    \spuretydefault{\seobs}{\sreal}\\
    \spuretydefault{\seone}{\sreal}\\
    \spuretydefault{\setwo}{\sreal}
    }
  {\scomptydefault{\sobserve{\seobs}{\sunif~\seone~\setwo}}{\sunit}}

  \and

  \inferrule
    {\spuretydefault{\seobs}{\sreal}\\
    \spuretydefault\scoe\sreal}
    {\scomptydefault{\sobserve{\seobs}{\spois~\scoe}}{\sunit}}
\end{mathpar}

\subsection{Semantics of types}

\subsubsection{Types}

\begin{align*}
  \llbrspc\eA &: \text{finite discrete measurable space} \\
  \llbrspc\eunit &= \text{the one-point space $\{\star\}$} \\
  \llbrspc\ebool &= \{\top,\bot\} \\
  \llbrspc{\eA\etimes\eB} &= \llbrspc\eA\times\llbrspc\eB
\end{align*}

\begin{align*}
  \llbr\stau &: \text{measurable space} \\
  \llbr\sunit &= \text{the one-point space $\{\star\}$} \\
  \llbr\sbool &= \text{the discrete two-point space $\{\top,\bot\}$} \\
  \llbr\sreal &= \R \\
  \llbr{\ssigma\stimes\stau} &= \llbr\ssigma\times\llbr\stau
\end{align*}

\subsubsection{Contexts}

\begin{align*}
  \llbr{\sGamma} &: \text{measurable space} \\
  \llbr{\sGamma} &= \prod_{\sco{x}\in\dom\sGamma}\llbr{\sGamma(\sco x)}
\end{align*}

\begin{align*}
  &\llbr{\eDelta} : \text{finite discrete measurable space} \\
  &\llbr{\eDelta} = \prod_{\eco{X}\in\dom\eDelta}\llbrspc{\eDelta(\eco X)} \\
\end{align*}

\subsubsection{Convertibility}

\begin{lemma}
  If $\eA\convrel\stau$ then $\llbr\eA = \llbr\stau$.
\end{lemma}
\begin{proof} By induction on $\eA\convrel\stau$.  \end{proof}

\subsection{Semantics of pure programs}


\begin{align*}
  \puresemarg{\epuretydefault{\eM}{\eA}}&: \llbrspc\eDelta\to\llbrspc\eA\\
  \puresemarg{\epuretydefaultsem{\eco X}{\eA}}(\delta) &= \delta(\eco X) \\
  \puresemarg{\epuretydefaultsem{\etrue}{\ebool}}(\delta) &= \top \\
  \puresemarg{\epuretydefaultsem{\efalse}{\ebool}}(\delta) &= \bot \\
  \puresemarg{\epuretydefaultsem{\eM\eand\eN}{\ebool}}(\delta) &=
    \begin{cases}
      \top, &
        \text{if }
        \puresemarg{\epuretydefaultsem{\eM}{\ebool}}(\delta)
        =
        \puresemarg{\epuretydefaultsem{\eN}{\ebool}}(\delta)
        = \top
        \\
      \bot, & \text{otherwise}
    \end{cases}
    \\
  \puresemarg{\epuretydefaultsem{\enot\eM}{\ebool}}(\delta) &=
    \begin{cases}
      \bot, &
        \text{if }
        \puresemarg{\epuretydefaultsem{\eM}{\ebool}}(\delta)
        = \top
        \\
      \top, & \text{otherwise}
    \end{cases}
    \\
  \puresemarg{\epuretydefaultsem{\eunitelt}{\eunit}}(\delta) &= \star \\
  \puresemarg{\epuretydefaultsem{\epair\eM\eN}{\eA\etimes\eB}}(\delta) &=
     (\puresemarg{\epuretydefaultsem\eM\eA}(\delta),
     \puresemarg{\epuretydefaultsem\eN\eB}(\delta)) \\
  \puresemarg{\epuretydefaultsem{\efst~\eM}{\eA}}(\delta) &=
     \pi_1(\puresemarg{\epuretydefaultsem{\eM}{\eA\etimes\eB}}(\delta))
    \\
  \puresemarg{\epuretydefaultsem{\esnd~\eM}{\eB}}(\delta) &=
     \pi_2(\puresemarg{\epuretydefaultsem{\eM}{\eA\etimes\eB}}(\delta))
\end{align*}

\begin{align*}
  \puresemarg{\spuretydefault{\scoe}{\stau}}&: \llbr\sGamma\mbleto{\llbr\stau}\\
  \puresemarg{\spuretydefaultsem{\sco x}{\stau}}(\gamma) &= \gamma(\sco x) \\
  \puresemarg{\spuretydefaultsem{\strue}{\sbool}}(\gamma) &= \top \\
  \puresemarg{\spuretydefaultsem{\sfalse}{\sbool}}(\gamma) &= \bot \\
  \puresemarg{\spuretydefaultsem{r}{\sreal}}(\gamma) &= r\\
  \puresemarg{\spuretydefaultsem{\seone\sadd\setwo}{\sreal}}(\gamma) &=
    \puresemarg{\spuretydefaultsem{\seone}\sreal}(\gamma)+
    \puresemarg{\spuretydefaultsem\setwo\sreal}(\gamma) \\
  \puresemarg{\spuretydefaultsem{\sneg\scoe}{\sreal}}(\gamma) &=
    -\puresemarg{\spuretydefaultsem{\scoe}\sreal}(\gamma)\\
  \puresemarg{\spuretydefaultsem{\seone\smul\setwo}{\sreal}}(\gamma) &=
    \puresemarg{\spuretydefaultsem{\seone}\sreal}(\gamma)\cdot
    \puresemarg{\spuretydefaultsem\setwo\sreal}(\gamma) \\
  \puresemarg{\spuretydefaultsem{\seone\sle\setwo}{\sbool}}(\gamma) &=
  \begin{cases}
    \top, & \text{if }\puresemarg{\spuretydefaultsem{\seone}\sreal}(\gamma)
             \le \puresemarg{\spuretydefaultsem\setwo\sreal}(\gamma) \\
    \bot, & \text{otherwise}
  \end{cases}\\
  \puresemarg{\spuretydefaultsem{\sunitelt}{\sunit}}(\gamma) &= \star \\
  \puresemarg{\spuretydefaultsem{\spair\seone\setwo}{\ssigma\stimes\stau}}(\gamma) &=
    (\puresemarg{\spuretydefaultsem{\seone}{\ssigma}}(\gamma),
    \puresemarg{\spuretydefaultsem{\setwo}{\stau}}(\gamma))
    \\
  \puresemarg{\spuretydefaultsem{\sfst~\scoe}{\ssigma}}(\gamma) &=
    \pi_1(\puresemarg{\spuretydefaultsem{\scoe}{\ssigma\stimes\stau}}(\gamma))
    \\
  \puresemarg{\spuretydefaultsem{\ssnd~\scoe}{\stau}}(\gamma) &=
    \pi_2(\puresemarg{\spuretydefaultsem{\scoe}{\ssigma\stimes\stau}}(\gamma))
    \\
\end{align*}

\subsection{Effectful programs: high-level model}

\begin{definition}
Let $\giry$ be the distribution monad defined over measurable spaces.
Let $\prmonad$ be the writer monad transformer applied
to $\giry$ and the monoid $(\weightmonoid,1)$ of nonegative reals under multiplication.
Concretely, $\prmonad$ sends a measurable space $A$
to the set $\giry(\weightmonoid\times A)$.
Let $\gret~x$
and $\gletin x\mu{f(x)}$ denote the usual monad operations with respect to $\prmonad$,
and let $\overline{(\cdot)}:\giry(A)\to\prmonad(A)$ be the usual lifting operation.
In addition to the usual operations,
\begin{itemize}[leftmargin=*]
  \item
    Let $\score : \weightmonoid\to\prmonad\{\star\}$ be the
    function that sends a weight $w$ to the Dirac
    distribution $\delta_{(w, \star)}$ centered at $(w,\star)$.
\end{itemize}
\end{definition}

\begin{definition}
  For $p\in \R$,
  let $\mathrm{flip}(p)$
  be the Bernoulli distribution with parameter $p$
  if $p\in [0,1]$,
  and a point mass at $\bot$ otherwise.
\end{definition}

\begin{definition}
  For $a,b\in \R$,
  let $\unif(a,b)$
  be the uniform distribution on the interval $[a,b]$
  if $a\le b$,
  and a point mass at $\min(a,b)$ otherwise.
\end{definition}

\begin{definition}
  For $\lambda\in \R$,
  let $\pois(\lambda)$
  be the Poisson distribution with parameter $\lambda$
  if $\lambda > 0$,
  and a point mass at $0$ otherwise.
\end{definition}

\subsubsection{Exact sublanguage}

\begin{align*}
  \erasesem{\ecomptydefault{\eM}{\eA}}
    &:\llbr\sGamma\times\llbr\eDelta
    \to \prmonad{\llbrspc\eA}\\
  \erasesemarg{\ecomptydefaultsem{\eret~\eM}{\eA}}(\gamma,\delta) &=
    \gret(\puresemarg{\epuretydefaultsem{\eM}{\eA}}(\delta))
    \\
  \erasesemarg{\ecomptydefaultsem{\eletin{\eco X}\eM\eN}{\eB}}(\gamma,\delta) &=
    \left(\begin{aligned}
      &x \gets \erasesemarg{\ecomptydefaultsem\eM\eA}(\gamma,\delta);\\
      &\erasesemarg{\ecomptysem\sGamma{\eDelta,\eco X\ofty \eA}\eN\eB}(\gamma,\delta[\eco X\mapsto x])
    \end{aligned}\right)
    \\
  \erasesemarg{\ecomptydefaultsem{\eite\scoe\eM\eN}{\eA}}(\gamma,\delta) &=
    \left(\begin{aligned}
      &\mathrm{if}~\puresemarg{\spuretydefaultsem\scoe\sbool}(\gamma)\\
      &\mathrm{then}~\erasesemarg{\ecomptydefaultsem\eM\eA}(\gamma,\delta)\\
      &\mathrm{else}~\erasesemarg{\ecomptydefaultsem\eN\eA}(\gamma,\delta)
    \end{aligned}\right)\\
  \erasesemarg{\ecomptydefaultsem{\eflip~\scoe}{\ebool}}(\gamma,\delta) &=
    \overline{\flip(\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma))} \\
  \erasesemarg{\ecomptydefaultsem{\eobserve~\eM}{\eunit}}(\gamma,\delta) &=
      \score(\Ind{\puresemarg{\epuretydefaultsem\eM\ebool}(\delta) = \top})
    \\
  \erasesemarg{\ecomptydefaultsem{\esample[\scoe]}{\eA}}(\gamma,\delta) &=
    \valstoe\eA\stau{\erasesemarg{\scomptydefaultsem{\scoe}{\stau}}(\gamma,\delta)}
\end{align*}

\subsubsection{Sampling sublanguage}

\begin{align*}
  \erasesem{\scomptydefault{\scoe}{\stau}} &:
    \llbr\sGamma\times\llbr\eDelta
    \to \prmonad{\llbr\stau}
    \\
  \erasesemarg{\scomptydefaultsem{\sret~{\scoe}}{\stau}}(\gamma,\delta) &=
    \gret(\puresemarg{\spuretydefaultsem{\scoe}\stau}(\gamma))
    \\
  \erasesemarg{\scomptydefaultsem{\sletin {\sco x}{\seone}{\setwo}}{\stau}}(\gamma,\delta) &=
    \left(\begin{aligned}
      &x\gets \erasesemarg{\scomptydefaultsem{\seone}\ssigma}(\gamma,\delta);\\
      &\erasesemarg{\scomptysem{\sGamma,\sco x\ofty \ssigma}\eDelta\setwo\stau}(\gamma[\sco x\mapsto x],\delta)\\
    \end{aligned}\right)
    \\
  \erasesemarg{\scomptydefaultsem{\site\seone\setwo\sethr}{\stau}}(\gamma,\delta) &=
    \left(\begin{aligned}
      &\mathrm{if}~{\puresemarg{\spuretydefaultsem{\seone}\sbool}(\gamma)}\\
      &\mathrm{then}~{\erasesemarg{\scomptydefaultsem{\setwo}\stau}(\gamma,\delta)}\\
      &\mathrm{else}~{\erasesemarg{\scomptydefaultsem{\sethr}\stau}(\gamma,\delta)}
    \end{aligned}\right)
    \\
  \erasesemarg{\scomptydefaultsem{\sflip~\scoe}{\sreal}}(\gamma,\delta) &=
    \overline{\flip(\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma))}\\
  \erasesemarg{\scomptydefaultsem{\sunif~\seone~\setwo}{\sreal}}(\gamma,\delta) &= \overline{\unif(
    \puresemarg{\spuretydefaultsem\seone\sreal}(\gamma),
        \puresemarg{\spuretydefaultsem\setwo\sreal}(\gamma))}\\
  \erasesemarg{\scomptydefaultsem{\spois~\scoe}{\sreal}}(\gamma,\delta) &=
    \overline{\pois(\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma))}\\
  \erasesemarg{\scomptydefaultsem{\sexact[\eM]}{\stau}}(\gamma,\delta) &=
      \valetos\eA\stau{\erasesemarg{\ecomptydefaultsem\eM{\eA}}(\gamma,\delta)}\\
  \erasesemarg{\scomptydefaultsem{\sobserve{\seobs}{\sflip~\seone}}{\sreal}}(\gamma,\delta) &=
      \score\left(
          \flip(\puresemarg{\spuretydefaultsem\seone\sreal}(\gamma))
          (\puresemarg{\spuretydefaultsem{\seobs}\sbool}(\gamma))
      \right) \\
  \erasesemarg{\scomptydefaultsem{\sobserve{\seobs}{\spois~\seone}}{\sreal}}(\gamma,\delta) &=
      \score\left(
          \pois(\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma))
          (\puresemarg{\spuretydefaultsem{\seobs}\sreal}(\gamma))
      \right) \\
  \erasesemarg{\scomptydefaultsem{\sobserve{\seobs}{\sunif~\seone~\setwo}}{\sreal}}(\gamma,\delta) &=
      \score\left(
          \unif(
            \puresemarg{\spuretydefaultsem\seone\sreal}(\gamma),
                \puresemarg{\spuretydefaultsem\setwo\sreal}(\gamma))
          (\puresemarg{\spuretydefaultsem{\seobs}\sbool}(\gamma))
      \right) \\
\end{align*}

\subsection{Effectful programs: low-level model}



\begin{definition}
  A \emph{finite conditional probability space}
  is a triple $(\Omega,\mu,E)$
  where
    (1) $\Omega$ is a nonempty finite prefix of $\N$,
    (2) $\mu : \Omega\to[0,1]$ is a discrete probability distribution,
    and (3) $E$ is a subset of $\Omega$.
  Let $\fcps$ be the set of finite conditional probability spaces.
\end{definition}
For readability, finite conditional probability spaces
$(\Omega,\mu,E)$ will be written $\Omega$ unless disambiguation is needed.

\begin{lemma} \label{app:lem:fcps-mblespc}
  $\fcps$ is a measurable space.
\end{lemma}
\begin{proof}
  There is an injective function
  $i : \fcps \hookrightarrow \N \times \mathrm{list}(\R) \times \mathcal P_{\rm fin}\N$
  sending a finite conditional probability space
  $(\{0,\dots,n-1\},\mu,E)$
  to the triple
  $(n, [\mu(0),\dots,\mu(n-1)], E)$.
  The codomain of $i$ is a measurable space with $\sigma$-algebra defined in the
  standard way, and
  the image of $i$ is a measurable subset of this space.
  The injection $i$ identifies the image of $i$ with $\fcps$,
  making $\fcps$ a measurable space by taking preimages along $i$.
\end{proof}

\begin{definition}
  A \emph{map of finite conditional probability spaces}
  $f : (\Omega,\mu,E)\to(\Omega',\mu',E')$
  is a measure-preserving map $f : (\Omega,\mu)\to(\Omega',\mu')$
  such that $E\subseteq f^{-1}(E')$.
  For two finite conditional probability spaces
  $(\Omega,\mu,E)$ and $(\Omega',\mu',E')$,
  let $(\Omega,\mu,E)\xrightarrow{\fcps}(\Omega',\mu',E')$
  be the set of maps from
  $(\Omega,\mu,E)$ to $(\Omega',\mu',E')$.
\end{definition}

\begin{definition}
  For every $\eco A$ and $\sco \tau$
  let $\esemcomp A$ and $\ssemcomp\tau$ be the following
  $\fcps$-indexed families of sets:
\begin{align*}
  \esemcomp A &: \fcps\to\Set \\
  \esemcomp A\Omega &= \prmonad\left(\sum_{\Omega'\in\fcps} (\Omega'\xrightarrow{\fcps}\Omega)\times (\Omega'\to\llbr{\eco A}) \right)
\end{align*}
\begin{align*}
  \ssemcomp \tau &: \fcps\to\Set \\
  \ssemcomp \tau \Omega &= \prmonad\left(\sum_{\Omega'\in\fcps} (\Omega'\xrightarrow\fcps\Omega)\times \llbr{\sco \tau}\right)
\end{align*}
\end{definition}
\begin{proof}
  For these to be well-defined, the arguments to $\prmonad$
  must be measurable spaces.
  Elements of
  $\sum_{\Omega'\in\fcps} (\Omega'\xrightarrow\fcps\Omega)\times (\Omega'\to\llbr{\eco A})$
  are triples $(\Omega', f, X)$ where $\Omega'\in\fcps$ and $f$ is a map of
  finite conditional probability spaces and $X : \Omega'\to\llbr{\eco A}$.
  There is a canonical injective function $i$ from this set to the set
    $\fcps \times (\N\xrightarrow{\rm fin}\N) \times (\N\xrightarrow{\rm fin} \llbr{\eco A})$
  whose elements are triples $(\Omega', f, X)$
  where $\Omega'\in\fcps$ and $f,X$ are partial functions of type $\N\rightharpoonup\N$
  and $\N\rightharpoonup\llbr{\eco A}$ respectively with finite domain.
  This set is a measurable space by \cref{app:lem:fcps-mblespc}
  and by putting the discrete $\sigma$-algebras on
    $\N\xrightarrow{\rm fin}\N$ and $\N\xrightarrow{\rm fin} \llbr{\eco A}$.
  The image of $i$ is a measurable subset of this space,
  making
  $\sum_{\Omega'\in\fcps} (\Omega'\xrightarrow\fcps\Omega)\times (\Omega'\to\llbr{\eco A})$
  a measurable space too.
  The analogous argument also makes
  $\sum_{\Omega'\in\fcps} (\Omega'\xrightarrow\fcps\Omega)\times \llbr{\stau}$
  into a measurable space.
\end{proof}

\begin{definition}
  For two finite conditional probability spaces
  $(\Omega,\mu,E)$
  and
  $(\Omega',\mu',E')$,
  their \emph{tensor product},
  written $(\Omega,\mu,E)\otimes(\Omega',\mu',E')$,
  is
  $(f(\Omega\times\Omega'), \nu \circ f^{-1}, f(E\times E'))$
  where $\nu : \Omega\times\Omega'\to[0,1]$ is the measure
  $\nu(\omega,\omega') = \mu(\omega)\mu'(\omega')$
  and $f$ is an arbitrary isomorphism $\Omega\times\Omega'\to \{1,\dots,|\Omega| |\Omega'|\}$
  (such as $f(\omega,\omega') = |\Omega'|\omega + \omega'$).
  There are canonical projection maps
  \[
    \pi_1 : (\Omega,\mu,E)\otimes(\Omega',\mu',E') \to (\Omega,\mu,E)
    \quad\text{and}\quad
    \pi_2 : (\Omega,\mu,E)\otimes(\Omega',\mu',E') \to (\Omega',\mu',E').
    \]
  The tensor product has a unit, written $\fcpsunit$,
  defined as $(\Omega_\fcpsunit,\mu_\fcpsunit,E_\fcpsunit)$
  where $\Omega_\fcpsunit=E_\fcpsunit=\{0\}$
  and $\mu(0) = 1$.
\end{definition}

\begin{definition}
  To model sampling from finite conditional probability spaces,
  \begin{itemize}[leftmargin=*]
  \item
    For any nonempty
    set $\Omega$, let $\przero_\Omega : \prmonad(A)$ be the Dirac
    distribution at $(0,\nu) : \weightmonoid\times\Omega$ where $\nu$ is an
    arbitrary element of $\Omega$.
  \item
    For any finite conditional probability
    space $(\Omega,\mu,E)$, let $\mu|_E :\prmonad(\Omega)$
    be $\przero_{\Omega}$ if $\mu(E) = 0$, and the lifting of the
    conditional distribution of $\mu$ given $E$ if $\mu(E) > 0$.
  \end{itemize}
\end{definition}

\subsubsection{Exact sublanguage}

\begin{align*}
  \implsemarg{\ecomptydefault{\eM}{\eA}}(\Omega)
    &:\llbr\sGamma\times(\Omega\to\llbr\eDelta)
    \to \esemcomp\eA{(\Omega)}\\
  \implsemarg{\ecomptydefaultsem{\eret~\eM}{\eA}}(\Omega)(\gamma,D) &=
    \gret(\Omega,\idfn,\puresem{\epuretydefaultsem{\eM}{\eA}}\circ D)
    \\
  \implsemarg{\ecomptydefaultsem{\eletin{\eco X}\eM\eN}{\eB}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &(\Omega_1,f_1,X) \gets \implsemarg{\ecomptydefaultsem\eM\eA}(\Omega)(\gamma,D);\\
      &(\Omega_2,f_2,Y) \gets \implsemarg{\eM}(\Omega_1)(\gamma,(D\circ f_1)[\eco X\mapsto X]);\\
      &\gret(\Omega_2, f_1\circ f_2, Y)
    \end{aligned}\right)
    \\
  \implsemarg{\ecomptydefaultsem{\eite\scoe\eM\eN}{\eA}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &\mathrm{if}~\puresemarg{\spuretydefaultsem\scoe\sbool}(\gamma)\\
      &\mathrm{then}~\implsemarg{\ecomptydefaultsem\eM\eA}(\Omega)(\gamma,D)\\
      &\mathrm{else}~\implsemarg{\ecomptydefaultsem\eN\eA}(\Omega)(\gamma,D)
    \end{aligned}\right)\\
  \implsemarg{\ecomptydefaultsem{\eflip~\scoe}{\ebool}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &p := \ite{\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma)\in[0,1]}
        {\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma)}
        {0}
        ;\\
      &\Omega_{\rm flip} := (\{0,1\},\mu,\{0,1\})\text{ where $\mu(1) = p$};\\
      &\Omega' := \Omega\otimes\Omega_{\rm flip}; \\
      &X := \omega'\mapsto \mathrm{if}~\pi_2(\omega')=1~\mathrm{then}~\top~\mathrm{else}~\bot;\\
      &\gret(\Omega',\pi_1,X)
    \end{aligned}\right)
    \\
  \implsemarg{\ecomptydefaultsem{\eobserve~\eM}{\eunit}}(\Omega,\mu,E)(\gamma,D) &=
    \left(\begin{aligned}
        &F := (\puresemarg{\epuretydefaultsem\eM\ebool}(\Omega)(D))^{-1}(\top);\\
        &\score(\mu|_E(F));\\
        &\gret((\Omega,\mu,E\cap F),\idfn,\star)
    \end{aligned}\right)
    \\
  \implsemarg{\ecomptydefaultsem{\esample[\scoe]}{\eA}}(\Omega)(\gamma,D) &=
  \left(\begin{aligned}
    &(\Omega',f,x) \gets \implsemarg{\scomptydefaultsem{\scoe}{\stau}}(\Omega)(\gamma,D);\\
    &\gret(\Omega',f,\_\mapsto \valstoe\eA\stau x)
  \end{aligned}\right)
\end{align*}

\subsubsection{Sampling sublanguage}

\begin{align*}
  \implsemarg{\scomptydefault{\scoe}{\stau}}(\Omega) &:
    \llbr\sGamma\times(\Omega\to\llbr\eDelta)
    \to \ssemcomp\stau(\Omega)
    \\
  \implsemarg{\scomptydefaultsem{\sret~{\scoe}}{\stau}}(\Omega)(\gamma,D) &=
    \gret(\Omega, \idfn,\puresemarg{\spuretydefaultsem{\scoe}\stau}(\gamma))
    \\
  \implsemarg{\scomptydefaultsem{\sletin {\sco x}{\seone}{\setwo}}{\stau}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &(\Omega_1,f_1,x)\gets\implsemarg{\scomptydefaultsem{\seone}\ssigma}(\Omega)(\gamma,D)\\
      &(\Omega_2,f_2,y)\gets\implsemarg{\setwo}(\Omega_1)(\gamma[\sco x\mapsto x],D\circ f_1)\\
      &\gret(\Omega_2,f_1\circ f_2,y)
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\site\seone\setwo\sethr}{\stau}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &\mathrm{if}~{\puresemarg{\spuretydefaultsem{\seone}\sbool}(\gamma)}\\
      &\mathrm{then}~{\implsemarg{\scomptydefaultsem{\setwo}\stau}(\Omega)(\gamma,D)}\\
      &\mathrm{else}~{\implsemarg{\scomptydefaultsem{\sethr}\stau}(\Omega)(\gamma,D)}
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\sflip~\scoe}{\sbool}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &x\gets \overline{\flip(\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma))}\\
      &\gret(\Omega,\idfn,x)
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\sunif~\seone~\setwo}{\sreal}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &x\gets \overline{\unif(\puresemarg{\spuretydefaultsem\seone\sreal}(\gamma),
        \puresemarg{\spuretydefaultsem\setwo\sreal}(\gamma))}\\
      &\gret(\Omega,\idfn,x)
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\spois~\scoe}{\sreal}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &x\gets \overline{\pois(\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma))}\\
      &\gret(\Omega,\idfn,x)
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\sobserve{\seobs}{\sflip~\seone}}{\sunit}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
        &w := \flip(\puresemarg{\spuretydefaultsem\seone\sreal}(\gamma))\left(\puresemarg{\spuretydefaultsem\seobs\sbool}(\gamma)\right)\\
        &\score(w);\\
        &\gret(\Omega,\idfn,\star)
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\sobserve{\seobs}{\sunif~\seone~\setwo}}{\sunit}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
        &w := \unif(\puresemarg{\spuretydefaultsem\seone\sreal}(\gamma),
          \puresemarg{\spuretydefaultsem\setwo\sreal}(\gamma))
          \left(\puresemarg{\spuretydefaultsem\seobs\sbool}(\gamma)\right)\\
        &\score(w);\\
        &\gret(\Omega,\idfn,\star)
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\sobserve{\seobs}{\spois~\seone}}{\sunit}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
        &w := \pois(\puresemarg{\spuretydefaultsem\seone\sreal}(\gamma))
          \left(\puresemarg{\spuretydefaultsem\seobs\sbool}(\gamma)\right)\\
        &\score(w);\\
        &\gret(\Omega,\idfn,\star)
    \end{aligned}\right)
    \\
  \implsemarg{\scomptydefaultsem{\sexact[\eM]}{\stau}}(\Omega)(\gamma,D) &=
    \left(\begin{aligned}
      &((\Omega',\mu',E'),f,X)\gets \implsemarg{\ecomptydefaultsem\eM{\eA}}(\Omega)(\gamma,D)\\
      &x\gets \big(\omega'\gets \mu'|_{E'};~ \gret(\valetos\eA\stau{X(\omega')})\big)\\
      &\gret((\Omega',\mu',E'\cap X^{-1}(x)), f, x)
    \end{aligned}\right)
\end{align*}

\subsection{Soundness} \label{app:soundness}

\begin{definition}
  Two computations $\mu,\nu : \prmonad A$
  are \emph{equal as importance samplers},
  written $\mu\preq\nu$,
  if for all bounded integrable $k : A\to\R$
  it holds that $\Ex_{(a,x)\sim \mu}[a\cdot k(x)]
  =\Ex_{(b,y)\sim \mu}[b \cdot k(y)]$.
\end{definition}

\begin{lemma}
  The equivalence relation $\preq$ is a congruence
  for the monad $\prmonad$:
  if $\mu\preq\nu : \prmonad A$
  and $f,g : A\to\prmonad B$
  with $f(x)\preq g(x)$
  for all $x$ in $A$
  then $(x\gets \mu; f(x))\preq(x\gets\nu;g(x))$.
\end{lemma}
\begin{proof}
  If $k : B\to \R$ bounded integrable
  then
  \begin{align*}
    \Ex_{(c,y)\sim(x\gets \mu;f(x))}[ck(y)]
    &=
    \Ex_{(a,x)\sim \mu}\left[\Ex_{(b,y)\sim f(x)}[a \cdot b \cdot k(y)]\right]
    \stackrel{(1)}=
    \Ex_{(a,x)\sim \mu}\left[\Ex_{(b,y)\sim g(x)}[a \cdot b \cdot k(y)]\right]\\
    &\stackrel{(2)}=
    \Ex_{(a,x)\sim \nu}\left[\Ex_{(b,y)\sim g(x)}[a \cdot b \cdot k(y)]\right]
    =
    \Ex_{(c,y)\sim(x\gets \nu;g(x))}[ck(y)]
  \end{align*}
  where $(1)$ follows from $f(x)\simeq g(x)$
  and $(2)$ from $\mu\simeq\nu$, using linearity of expectation throughout
  as needed.
\end{proof}

\begin{lemma} \label{app:lem:cond-twice}
  If $(\Omega,\mu,E)\in\fcps$
  and $F\subseteq\Omega$
  then $\mu|_E|_F = \mu|_{E\cap F}$.
\end{lemma}
\begin{proof}
  If $\mu(E\cap F) = 0$ then both sides are the zero measure.
  Otherwise for all $G$ have
  $(\mu|_E|_F)(G)
  = \mu|_E(F\cap G)/\mu|_E(F)
  = \mu(E\cap F\cap G)/\mu(E\cap F)
  = \mu|_{E\cap F}(G)$.
\end{proof}

\begin{lemma} \label{app:lem:score-interchange}
  If $(\Omega,\mu,E)\in\fcps$ then
  $\left(\begin{aligned}
    &\score(\mu(E));\\
    &\omega\gets \mu|_E;\\
    &\gret~\omega
  \end{aligned}\right)
  \preq
  \left(\begin{aligned}
    &\omega\gets \mu;\\
    &\score(\Ind{\omega\in E});\\
    &\gret~\omega
  \end{aligned}\right)$.
\end{lemma}
\begin{proof}
  For all $k : \Omega\to \R$ have
  \begin{align*}
    \Ex_{(a,\omega)\sim\text{LHS}}[k(\omega)]
    &=
    \Ex_{\omega\sim \mu|_E}[\mu(E)k(\omega)]
    =
    \sum_{\omega\in\Omega}\mu|_E(\omega)\mu(E)k(\omega)
    =
    \sum_{\omega\in\Omega}\mu(\omega \cap E)k(\omega)\\
    &=
    \sum_{\omega\in\Omega}\Ind{\omega\in E}\mu(\omega)k(\omega)
    =
    \Ex_{(a,\omega)\sim\text{RHS}} [a \cdot k(\omega)].
  \end{align*}
\end{proof}

\begin{lemma} \label{app:lem:cond-nested-integral}
  If $(\Omega,\mu,E)\in\fcps$ and $X : \Omega\to A$ with $A$ finite
  then \[\left(\begin{aligned}
    &x\gets \big(\omega\gets \mu; \gret(X\omega)\big);\\
    &\omega'\gets \mu|_{X^{-1}(x)};\\
    &\gret(x,\omega)
  \end{aligned}\right)
  =
  \left(\begin{aligned}
    &\omega'\gets \mu;\\
    &\gret(X\omega',\omega')
  \end{aligned}\right).\]
\end{lemma}
\begin{proof}
  All distributions involved are discrete, so it suffices to show
  LHS and RHS give the same probability to pairs $(a,b)$.
  \begin{align*}
    \text{LHS}(a,b)
    &= \sum_{\omega\in \Omega}\mu(\omega)\sum_{\omega\in\Omega}\mu|_{X^{-1}(X\omega)}(\omega')
      \Ind{(X\omega,\omega')=(a,b)}
    = \sum_{\omega\in \Omega,\omega'\in\Omega,X\omega=a,\omega'=b}
      \mu(\omega)
      \mu|_{X^{-1}(X\omega)}(\omega')\\
    &= \sum_{\omega\in\Omega,X\omega=a}\mu(\omega)\mu|_{X^{-1}(a)}(b)
    = \mu|_{X^{-1}(a)}(b)\mu(X^{-1}(a))
    = \mu(X^{-1}(a)\cap b)
    = \text{RHS}(a,b)
  \end{align*}
\end{proof}

\begin{theorem} \label{app:thm:semantic-soundness}
  The following hold:
  \begin{enumerate}
    \item If $\ecomptydefault\eM\eA$ then the following holds
      for all $\Omega,\mu,E,\gamma,D$:
      \[\left(\begin{aligned}
        &((\Omega',\mu',E'),f,X)\gets\implsemarg{\eM}(\Omega,\mu,E)(\gamma,D); \\
        &\omega'\gets \mu'|_{E'};\\
        &\gret(D(f(\omega')),{X\omega'})
      \end{aligned}\right)
      \preq
      \left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &x\gets \erasesemarg\eM(\gamma,D\omega);\\
        &\gret(D\omega,x)
      \end{aligned}\right)\]
    \item If $\scomptydefault\scoe\stau$ then the following holds
      for all $\Omega,\mu,E,\gamma,D$:
      \[\left(\begin{aligned}
        &((\Omega',\mu',E'),f,x)\gets\implsemarg{\scoe}(\Omega,\mu,E)(\gamma,D); \\
        &\omega'\gets \mu'|_{E'};\\
        &\gret(D(f(\omega)),x)
      \end{aligned}\right)
      \preq
      \left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &x\gets \erasesemarg\scoe(\gamma,D\omega);\\
        &\gret(D\omega, x)
      \end{aligned}\right)\]
  \end{enumerate}
\end{theorem}
\begin{proof}
  By induction on the typing rules. \begin{enumerate}[leftmargin=*]
  \item ~\begin{itemize}[align=left]
    \item[$({\ecomptydefault{\eret~\eM}{\eA}})$]
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,X)\gets\implsemarg{\eret~\eM}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),{X\omega'})
        \end{aligned}\right)\\
        &=\left(\begin{aligned}
            &((\Omega',\mu',E'),f,X)\gets \gret((\Omega,\mu,E),\idfn,\puresem{\epuretydefaultsem{\eM}{\eA}}\circ D);\\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),{X\omega'})
        \end{aligned}\right)\\
        &=
        \left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &\gret(D\omega,\puresemarg{\eM}(D\omega))
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &x\gets \erasesemarg{\eret~\eM}(\gamma,D\omega);\\
            &\gret(D\omega,x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\ecomptydefault{\eletin{\eco X}\eM\eN}{\eB}})$]
      In this case we work backwards, rearranging RHS into LHS:
      \begin{align*}
        &\left(\begin{aligned}
            &\omega\gets \mu|_E;\\
            &y\gets \erasesemarg{\eletin{\eco X}\eM\eN}(\gamma,D\omega);\\
            &\gret(D\omega,y)
            \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega\gets \mu|_E;\\
            &x\gets \erasesemarg\eM(\gamma,D\omega);\\
            &y\gets \erasesemarg\eN(\gamma,D\omega[\eco X\mapsto x]);\\
            &\gret(D\omega,y)
            \end{aligned}\right)\\
        &=
        \left(\begin{aligned}
            &(\delta,x)\gets\\
            &\hspace{1em}\begin{aligned}
                &\omega\gets \mu|_E;\\
                &x\gets \erasesemarg\eM(\gamma,D\omega);\\
                &\gret(D\omega,x)
            \end{aligned}\\
            &y\gets \erasesemarg\eN(\gamma,\delta[\eco X\mapsto x]);\\
            &\gret(D\omega,y)
            \end{aligned}\right)
        \IHpreq
        \left(\begin{aligned}
            &(\delta,x)\gets\\
            &\hspace{1em}\begin{aligned}
              &((\Omega_1,\mu_1,E_1),f,X)\gets \implsemarg{\eM}(\Omega,\mu,E)(\gamma,D);\\
              &\omega_1\gets \mu_1|_{E_1};\\
              &\gret(D(f(\omega_1)),X\omega_1)
            \end{aligned}\\
            &y\gets \erasesemarg\eN(\gamma,\delta[\eco X\mapsto x]);\\
            &\gret(D\omega,y)
            \end{aligned}\right)
          \\
        &=
        \left(\begin{aligned}
            &((\Omega_1,\mu_1,E_1),f,X)\gets \implsemarg{\eM}(\Omega,\mu,E)(\gamma,D);\\
            &\omega_1\gets \mu_1|_{E_1};\\
            &y\gets \erasesemarg\eN(\gamma,((D\circ f_1)[\eco X\mapsto X])(\omega_1));\\
            &\gret(D\omega,y)
            \end{aligned}\right)
        \\
        &\IHpreq
        \left(\begin{aligned}
        &((\Omega_1,\mu_1,E_1),f_1,X)\gets \implsemarg{\eM}(\Omega,\mu,E)(\gamma,D);\\
        &((\Omega_2,\mu_2,E_2),f_2,Y)\gets \implsemarg{\eN}(\Omega_1,\mu_1,E_1)(\gamma,(D\circ f_1)[\eco X\mapsto X]);\\
        &\omega_2\gets \mu_2|_{E_2};\\
        &\gret(D(f_1(f_2(\omega))),Y\omega_2)
        \end{aligned}\right)
        \\
        &=
        \left(\begin{aligned}
        &((\Omega',\mu',E'),f,Z)\gets \implsemarg{\eletin{\eco X}\eM\eN}(\Omega,\mu,E)(\gamma,D);\\
        &\omega'\gets \mu'|_{E'};\\
        &\gret(D(f(\omega)),Z\omega')
        \end{aligned}\right)
      \end{align*}
    \item[$({\ecomptydefault{\eite\scoe\eM\eN}{\eA}})$]
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,X)\gets\implsemarg{\eite\scoe\eM\eN}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),{X\omega'})
        \end{aligned}\right) \\
        &=\left(\begin{aligned}
            &((\Omega',\mu',E'),f,X)\gets\\
            &\hspace{1em}\begin{aligned}
              &\mathrm{if}~\puresemarg{\scoe}(\gamma)\\
              &\mathrm{then}~\implsemarg{\eM}(\Omega,\mu,E)(\gamma,D);\\
              &\mathrm{else}~\implsemarg{\eN}(\Omega,\mu,E)(\gamma,D);\\
            \end{aligned}\\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),{X\omega'})
        \end{aligned}\right)
        =\left(\begin{aligned}
            &\mathrm{if}~\puresemarg{\scoe}(\gamma)~\mathrm{then}\\
            &\hspace{1em}\begin{aligned}
                &((\Omega',\mu',E'),f,X)\gets\implsemarg{\eM}(\Omega,\mu,E)(\gamma,D);\\
                &\omega'\gets \mu'|_{E'};\\
                &\gret(D(f(\omega')),{X\omega'})
            \end{aligned}\\
            &\mathrm{else}\\
            &\hspace{1em}\begin{aligned}
                &((\Omega',\mu',E'),f,X)\gets\implsemarg{\eN}(\Omega,\mu,E)(\gamma,D);\\
                &\omega'\gets \mu'|_{E'};\\
                &\gret(D(f(\omega')),{X\omega'})
            \end{aligned}
        \end{aligned}\right)
        \\
        &\stackrel{\text{IH}\times2}\preq
        \left(\begin{aligned}
            &\mathrm{if}~\puresemarg{\scoe}(\gamma)~\mathrm{then}\\
            &\hspace{1em}\begin{aligned}
                &\omega\gets \mu|_E;\\
                &x\gets\erasesemarg{\eM}(\gamma,D\omega);\\
                &\gret(D\omega,x)
            \end{aligned}\\
            &\mathrm{else}\\
            &\hspace{1em}\begin{aligned}
                &\omega\gets \mu|_E;\\
                &x\gets\erasesemarg{\eN}(\gamma,D\omega);\\
                &\gret(D\omega,x)
            \end{aligned}
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega\gets \mu|_E;\\
            &x\gets\\
            &\hspace{1em}\begin{aligned}
              &\mathrm{if}~\puresemarg{\scoe}(\gamma)\\
              &\mathrm{then}~\erasesemarg{\eM}(\gamma,D\omega)\\
              &\mathrm{else}~\erasesemarg{\eN}(\gamma,D\omega)
            \end{aligned}
            \\
            &\gret(D\omega,x)
        \end{aligned}\right)\\
        &=
        \left(\begin{aligned}
            &\omega\gets \mu|_E;\\
            &x\gets \erasesemarg{\eite\scoe\eM\eN}(\gamma,D\omega);\\
            &\gret(D\omega,x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\ecomptydefault{\eflip~\scoe}{\ebool}})$]
      Let $p = (\ite{\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma)\in[0,1]}{\puresemarg{\spuretydefaultsem\scoe\sreal}(\gamma)}0)$.
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,X)\gets\implsemarg{\eflip~\scoe}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),{X\omega'})
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &(\omega,b)\gets (\mu\otimes\flip(p))|_{E\times\llbrspc\ebool};\\
            &\gret(D\omega,b)
        \end{aligned}\right)
        \\
        &=
        \left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &b\gets \flip(p);\\
            &\gret(D\omega,b)
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &x\gets \erasesemarg{\eflip~\scoe}(\gamma,D\omega);\\
            &\gret(D\omega,x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\ecomptydefault{\eobserve~\eM}{\eunit}})$]
      Let $F$ be the subset $(\llbr{\eM}(\Omega,\mu,E)\circ D)^{-1}(\top)$ of $\Omega$.
      \begin{align*}
      &\left(\begin{aligned}
        &((\Omega',\mu',E'),f,X)\gets\implsemarg{\eobserve~\eM}(\Omega,\mu,E)(\gamma,D); \\
        &\omega'\gets \mu'|_{E'};\\
        &\gret(D(f(\omega')),{X\omega'})
      \end{aligned}\right)
      =\left(\begin{aligned}
        &\score(\mu|_E(F));\\
        &\omega\gets \mu|_{E\cap F};\\
        &\gret(D\omega,\star)
      \end{aligned}\right)\\
      &\stackcref{app:lem:cond-twice}=\left(\begin{aligned}
        &\score(\mu|_E(F));\\
        &\omega\gets \mu|_E|_F;\\
        &\gret(D\omega,\star)
      \end{aligned}\right)
      \stackcref{app:lem:score-interchange}\preq
      \left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &\score(\Ind{\omega\in F});\\
        &\gret(D\omega,\star)
        \end{aligned}\right)
      \\
      &=
      \left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &\score(\Ind{\puresemarg{\eM}(D\omega) = \top});\\
        &\gret(D\omega,\star)
        \end{aligned}\right)
      =
      \left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &x\gets \erasesemarg{\eobserve~\eM}(\gamma,D\omega);\\
        &\gret(D\omega,x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\ecomptydefault{\esample[\scoe]}{\eA}})$]
      \begin{align*}
      &\left(\begin{aligned}
        &((\Omega',\mu',E'),f,X)\gets\implsemarg{\esample[\scoe]}(\Omega,\mu,E)(\gamma,D); \\
        &\omega'\gets \mu'|_{E'};\\
        &\gret(D(f(\omega')),X\omega')
      \end{aligned}\right)
      \\
      &=
      \left(\begin{aligned}
        &((\Omega',\mu',E'),f,X)\gets\\
        &\hspace{1em}
            \left(\begin{aligned}
                &((\Omega',\mu',E'),f,x) \gets \implsemarg\scoe(\Omega,\mu,E)(\gamma,D);\\
                &\gret((\Omega',\mu',E'),f,\_\mapsto \valstoe\eA\stau{x})
            \end{aligned}\right);
            \\
        &\omega'\gets \mu'|_{E'};\\
        &\gret(D(f(\omega')),X\omega')
      \end{aligned}\right)
      \\
      &=
      \left(\begin{aligned}
        &((\Omega',\mu',E'),f, x) \gets \implsemarg\scoe(\Omega,\mu,E)(\gamma,D);\\
        &\omega'\gets \mu'|_{E'};\\
        &\gret(D(f(\omega')),\valstoe\eA\stau x)
      \end{aligned}\right)
      \\
      &\IHpreq
      \left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &x\gets \erasesemarg\scoe(\gamma,D\omega);\\
        &\gret(D\omega,\valstoe\eA\stau x)
      \end{aligned}\right)
      =
      \left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &x\gets \erasesemarg{\esample[\scoe]}(\gamma,D\omega);\\
        &\gret(D\omega,x)
      \end{aligned}\right)
    \end{align*}
  \end{itemize}
  \item ~\begin{itemize}[align=left]
    \item[$({\scomptydefault{\sret~{\scoe}}{\stau}})$]
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\implsemarg{\sret~\scoe}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega)),x)
        \end{aligned}\right)
        \\
        &=\left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &\gret(D\omega, \puresemarg{\scoe}(\gamma))
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &x\gets \erasesemarg{\sret~\scoe}(\gamma,D\omega);\\
            &\gret(D\omega, x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\scomptydefault{\sletin {\sco x}{\seone}{\setwo}}{\stau}})$]
      In this case we work backwards, rearranging RHS into LHS:
      \begin{align*}
        &\left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &x\gets \erasesemarg{\sletin{\sco x}\seone\setwo}(\gamma,D\omega);\\
            &\gret(D\omega,x)
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega \gets \mu|_E; \\
            &x\gets \erasesemarg{\seone}(\gamma,D\omega);\\
            &y\gets \erasesemarg{\setwo}(\gamma[\sco x\mapsto x],D\omega);\\
            &\gret(D\omega,y)
        \end{aligned}\right)
        \\
        &=
        \left(\begin{aligned}
            &(\delta,x)\gets\\
            &\hspace{1em} \left(\begin{aligned}
                &\omega\gets \mu|_E; \\
                &x\gets \erasesemarg{\seone}(\gamma,D\omega);\\
                &\gret(D\omega,x)
              \end{aligned}\right);\\
            &y\gets \erasesemarg{\setwo}(\gamma[\sco x\mapsto x],\delta);\\
            &\gret(\delta,y)
        \end{aligned}\right)
        \IHpreq
        \left(\begin{aligned}
            &(\delta,x)\gets\\
            &\hspace{1em} \left(\begin{aligned}
                &((\Omega_1,\mu_1,E_1),f_1,x)\gets\implsemarg{\seone}(\Omega,\mu,E)(\gamma,D); \\
                &\omega_1\gets \mu_1|_{E_1}; \\
                &\gret(D(f_1(\omega_1)),X\omega_1)
              \end{aligned}\right);\\
            &y\gets \erasesemarg{\setwo}(\gamma[\sco x\mapsto x],\delta);\\
            &\gret(\delta,y)
        \end{aligned}\right)
        \\
        &=
        \left(\begin{aligned}
            &((\Omega_1,\mu_1,E_1),f_1,x)\gets\implsemarg{\seone}(\Omega,\mu,E)(\gamma,D); \\
            &\omega_1\gets \mu_1|_{E_1}; \\
            &\delta := D(f_1(\omega_1));\\
            &y\gets \erasesemarg{\setwo}(\gamma[\sco x\mapsto x],\delta);\\
            &\gret(\delta,y)
        \end{aligned}\right)\\
        &\IHpreq
        \left(\begin{aligned}
            &((\Omega_1,\mu_1,E_1),f_1,x)\gets\implsemarg{\seone}(\Omega,\mu,E)(\gamma,D); \\
            &((\Omega_2,\mu_2,E_2),f_2,y)\gets\implsemarg{\setwo}
              (\Omega_1,\mu_1,E_1)(\gamma[\sco x\mapsto x],D\circ f_1); \\
            &\omega_2\gets \mu_2|_{E_2};\\
            &\gret(D(f_1(f_2(\omega_2))),y)
        \end{aligned}\right)
        \\
        &=
        \left(\begin{aligned}
            &((\Omega',\mu',E'),f,z)\gets\implsemarg{\sletin{\sco x}\seone\setwo}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),z)
        \end{aligned}\right)
      \end{align*}
    \item[$({\scomptydefault{\site\seone\setwo\sethr}{\stau}})$]
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\implsemarg{\site\seone\setwo\sethr}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)\\
        &=\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\\
            &\hspace{1em}\begin{aligned}
              &\mathrm{if}~\puresemarg{\seone}(\gamma)\\
              &\mathrm{then}~\implsemarg{\setwo}(\Omega,\mu,E)(\gamma,D);\\
              &\mathrm{else}~\implsemarg{\sethr}(\Omega,\mu,E)(\gamma,D);\\
            \end{aligned}\\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)
        =\left(\begin{aligned}
            &\mathrm{if}~\puresemarg{\seone}(\gamma)~\mathrm{then}\\
            &\hspace{1em}\begin{aligned}
                &((\Omega',\mu',E'),f,x)\gets\implsemarg{\setwo}(\Omega,\mu,E)(\gamma,D);\\
                &\omega'\gets \mu'|_{E'};\\
                &\gret(D(f(\omega')),x)
            \end{aligned}\\
            &\mathrm{else}\\
            &\hspace{1em}\begin{aligned}
                &((\Omega',\mu',E'),f,x)\gets\implsemarg{\sethr}(\Omega,\mu,E)(\gamma,D);\\
                &\omega'\gets \mu'|_{E'};\\
                &\gret(D(f(\omega')),x)
            \end{aligned}
        \end{aligned}\right)
        \\
        &\stackrel{\text{IH}\times2}\preq
        \left(\begin{aligned}
            &\mathrm{if}~\puresemarg{\seone}(\gamma)~\mathrm{then}\\
            &\hspace{1em}\begin{aligned}
                &\omega\gets \mu|_E;\\
                &x\gets\erasesemarg{\setwo}(\gamma,D\omega);\\
                &\gret(D\omega,x)
            \end{aligned}\\
            &\mathrm{else}\\
            &\hspace{1em}\begin{aligned}
                &\omega\gets \mu|_E;\\
                &x\gets\erasesemarg{\sethr}(\gamma,D\omega);\\
                &\gret(D\omega,x)
            \end{aligned}
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega\gets \mu|_E;\\
            &x\gets\\
            &\hspace{1em}\begin{aligned}
              &\mathrm{if}~\puresemarg{\seone}(\gamma)\\
              &\mathrm{then}~\erasesemarg{\setwo}(\gamma,D\omega)\\
              &\mathrm{else}~\erasesemarg{\sethr}(\gamma,D\omega)
            \end{aligned}
            \\
            &\gret(D\omega,x)
        \end{aligned}\right)
        \\
        &=
        \left(\begin{aligned}
            &\omega\gets \mu|_E;\\
            &x\gets \erasesemarg{\site\seone\setwo\sethr}(\gamma,D\omega);\\
            &\gret(D\omega,x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\scomptydefault\scoe{\stau}}$ for $\scoe = \sflip~\seone$ or $\scoe = \sunif~\seone~\setwo$ or $\scoe = \spois~{\seone}$)]
      ~\linebreak
      If $\scoe = \sflip~{\seone}$ for some $\seone$,
      then let $\nu$
      be the distribution $\flip(\puresemarg{\spuretydefaultsem{\seone}\sreal}(\gamma))$.

      If $\scoe = \sunif~\seone~\setwo$ then let
      $\nu$ be the distribution $\unif(\puresemarg{\spuretydefaultsem\seone\sreal}(\gamma),
        \puresemarg{\spuretydefaultsem\seone\sreal}(\gamma))$.

      If $\scoe = \spois~{\seone}$ for some $\seone$,
      then let $\nu$
      be the distribution $\pois(\puresemarg{\spuretydefaultsem{\seone}\sreal}(\gamma))$.

      In all cases,
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\implsemarg{\scoe}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)
        =\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\\
            &\hspace{1em}\left(\begin{aligned}
                &x\gets\overline\nu;\\
                &\gret((\Omega,\mu,E),\idfn,x)
            \end{aligned}\right);\\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)\\
        &=
        \left(\begin{aligned}
            &x\gets \overline\nu;\\
            &\omega\gets \mu|_{E};\\
            &\gret(D\omega,x)
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega\gets \mu|_{E};\\
            &x\gets \erasesemarg{\scoe}(\gamma,D\omega);\\
            &\gret(D\omega,x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\scomptydefault{\sobserve{\seobs}{e}} {\sunit}}$ for $e = \sflip~\seone$ or $e = \sunif~\seone~\setwo$ or $e = \spois~{\seone}$)] %
      ~\linebreak
      If $e = \sflip~{\seone}$ for some $\seone$,
      then let $\nu$
      be the distribution $\flip(\puresemarg{\spuretydefaultsem{\seone}\sreal}(\gamma))$.

      If $e = \sunif~\seone~\setwo$ then let
      $\nu$ be the distribution $\unif(\puresemarg{\spuretydefaultsem\seone\sreal}(\gamma),
        \puresemarg{\spuretydefaultsem\seone\sreal}(\gamma))$.

      If $e = \spois~{\seone}$ for some $\seone$,
      then let $\nu$
      be the distribution $\pois(\puresemarg{\spuretydefaultsem{\seone}\sreal}(\gamma))$.

      In all cases,
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\implsemarg{\sobserve{\seobs}{\scoe}}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)
        =\left(\begin{aligned}
            &\score(\overline\nu(\puresemarg\seobs(\gamma)));\\
            &\omega \gets \mu|_{E};\\
            &\gret(D\omega,\star)
        \end{aligned}\right)\\
      \end{align*}
      \cont{}'s $\score$ does not effect the FCPS and we commute with $\mu|_E$,
      \begin{align*}
        &\overset{\textrm{comm}}{=}\left(\begin{aligned}
            &\omega\gets \mu|_{E};\\
            &\score(\overline\nu(\puresemarg\seobs(\gamma)));\\
            &\gret(D\omega,\star)
        \end{aligned}\right)
        =
        \left(\begin{aligned}
            &\omega\gets \mu|_{E};\\
            &x\gets \erasesemarg{\scoe}(\gamma,D\omega);\\
            &\gret(D\omega,x)
        \end{aligned}\right)
      \end{align*}
    \item[$({\scomptydefault{\sexact[\eM]}{\stau}})$]
      \begin{align*}
        &\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\implsemarg{\sexact[\eM]}(\Omega,\mu,E)(\gamma,D); \\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)
        \\
        &=\left(\begin{aligned}
            &((\Omega',\mu',E'),f,x)\gets\\
            &\hspace{1em}\left(\begin{aligned}
                    &((\Omega',\mu',E'),f,X)\gets \implsemarg{\ecomptydefaultsem\eM{\eA}}(\Omega,\mu,E)(\gamma,D)\\
                &x\gets \big(\omega'\gets \mu'|_{E'};~ \gret(\valetos\eA\stau{X\omega'})\big)\\
                &\gret((\Omega',\mu',E'\cap X^{-1}(x)), x)
                \end{aligned}\right)\\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)
        \\
        &=
        \left(\begin{aligned}
            &((\Omega',\mu',E'),f,X)\gets \implsemarg{\ecomptydefaultsem\eM{\eA}}(\Omega,\mu,E)(\gamma,D)\\
            &x\gets \big(\omega'\gets \mu'|_{E'};~ \gret(\valetos\eA\stau{X\omega'})\big)\\
            &E'' := E'\cap X^{-1}(x);\\
            &\omega'\gets \mu'|_{E''};\\
            &\gret(D(f(\omega')),x)
        \end{aligned}\right)\\
        &\stackcref{app:lem:cond-twice,app:lem:cond-nested-integral}=
        \left(\begin{aligned}
            &((\Omega',\mu',E'),X)\gets \implsemarg{\ecomptydefaultsem\eM{\eA}}(\Omega,\mu,E)(\gamma,D)\\
            &\omega'\gets \mu'|_{E'};\\
            &\gret(D(f(\omega')),\valetos\eA\stau{X\omega'})
        \end{aligned}\right)\\
      &\IHpreq\left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &x\gets \erasesemarg{\eM}(\gamma,D\omega);\\
        &\gret(D\omega, \valetos\eA\stau x)
      \end{aligned}\right)
      =\left(\begin{aligned}
        &\omega \gets \mu|_E; \\
        &x\gets \erasesemarg{\sexact[\eM]}(\gamma,D\omega);\\
        &\gret(D\omega, x)
      \end{aligned}\right)
      \end{align*}
  \end{itemize}
  \end{enumerate}
\end{proof}

\begin{definition}
  For a closed program $\scompty{\sco{\pmb\cdot}}{\eco{\pmb\cdot}}\scoe\stau$,
  let $\sevalprog(e) $ be the computation
  \[\left(\begin{aligned}
    &(\_,\_,x)\gets \implsemarg{\scoe}(\fcpsunit)(\emptyset,\emptyset);\\
    &\gret~ x
  \end{aligned}\right) : \prmonad{\llbr\stau}\]
  where $\emptyset$ denotes the empty substitution.
  Let $\seraseevalprog(e)$ be the computation
  $\erasesemarg{\scoe}(\emptyset,\emptyset) : \prmonad{\llbr\stau}$.
\end{definition}

\begin{theorem}[\cont{} soundness] \label{app:thm:toplevel-soundness}
  If $\scompty{\sco\cdot}{\eco\cdot}\scoe\stau$
  then
  $\sevalprog(\scoe) \preq \seraseevalprog(\scoe)$.
\end{theorem}
\begin{proof} Apply \cref{app:thm:semantic-soundness}. \end{proof}

\subsection{Evaluation details}
In this section, we include three example programs from our evaluation to
showcase the syntax of our implementation. These include the 15-node arrival model with tree-topology, the 9-node reachability model with grid topology.

We additionally provide our evaluations, inclusive of standard error over the 100 runs.

\begin{figure}[H]
\begin{lstlisting}[
 basicstyle=\footnotesize\ttfamily,
  language=custom,mathescape=true,caption={\textsc{Reachability-9}},label={lst:reliability:apx},escapechar=|]
exact {
  let x00 = flip 1.0 / 3.0 in
  let x01 = if x00 then flip 1.0 / 4.0 else flip 1.0 / 5.0 in
  let x10 = if x00 then flip 1.0 / 4.0 else flip 1.0 / 5.0 in
  let diag = sample {
    x02 ~ if x01 then bern(1.0 / 4.0) else bern(1.0 / 5.0);
    x20 ~ if x10 then bern(1.0 / 4.0) else bern(1.0 / 5.0);
    x11 ~ if  x10 &&  x01 then bern(1.0 / 6.0)
     else if  x10 && !x01 then bern(1.0 / 7.0)
     else if !x10 &&  x01 then bern(1.0 / 8.0)
                          else bern(1.0 / 9.0);
    (x20, x11, x02)
  } in
  let x20 = diag[0] in
  let x11 = diag[1] in
  let x02 = diag[2] in

  let x12 = if  x11 &&  x02 then flip 1.0 / 6.0
       else if  x11 && !x02 then flip 1.0 / 7.0
       else if !x11 &&  x02 then flip 1.0 / 8.0
                            else flip 1.0 / 9.0 in
  let x21 = if  x20 &&  x11 then flip 1.0 / 6.0
       else if  x20 && !x11 then flip 1.0 / 7.0
       else if !x20 &&  x11 then flip 1.0 / 8.0
                            else flip 1.0 / 9.0 in
  let x22 = if  x21 &&  x12 then flip 1.0 / 6.0
       else if  x21 && !x12 then flip 1.0 / 7.0
       else if !x21 &&  x12 then flip 1.0 / 8.0
                            else flip 1.0 / 9.0 in
  observe x22 in
  ( x00, x01, x02
  , x10, x11, x12
  , x20, x21, x22
  )
}
\end{lstlisting}
\caption{The network reachability program for the 9-node grid topology}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[
 basicstyle=\footnotesize\ttfamily,
 language=custom,mathescape=true,caption={\textsc{Arrival-15}},label={lst:arrival:apx},escapechar=|]
exact fn network () -> Bool {
  let n30r = true in
  let n20r = if  n30r then flip 1.0 / 2.0 else false in
  let n31r = if !n20r then flip 1.0 / 2.0 else false in

  let n10r = if  n20r then flip 1.0 / 2.0 else false in
  let n21r = if !n10r then flip 1.0 / 2.0 else false in
  let n32r = if  n21r then flip 1.0 / 2.0 else false in
  let n33r = if !n21r then flip 1.0 / 2.0 else false in

  let n0   = n10r in

  let n10l = if  n0   then flip 1.0 / 2.0 else false in

  let n20l = if  n10l then flip 1.0 / 2.0 else false in
  let n21l = if !n10l then flip 1.0 / 2.0 else false in

  let n30l = if  n20l then flip 1.0 / 2.0 else false in
  let n31l = if !n20l then flip 1.0 / 2.0 else false in
  let n32l = if  n21l then flip 1.0 / 2.0 else false in
  let n33l = if !n21l then flip 1.0 / 2.0 else false in
  observe n32l in
  n0
}

sample {
  ix ~ poisson(3.0);
  npackets <- 0;
  while ix > 0 {
    traverses <- exact(network());
    npackets <- if traverses { npackets + 1 } else { npackets };
    ix <- ix - 1;
    true
  };
  npackets
}
\end{lstlisting}
\caption{The network reachability program for the 9-node grid topology}
\end{figure}

\begin{figure}[H]
\begin{lstlisting}[
 basicstyle=\footnotesize\ttfamily,
 language=custom,mathescape=true,caption={\textsc{Gossip-4}},label={lst:gossip:apx}]
sample fn forward(ix : Int) -> Int {
  s ~ discrete(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);
  if s < ix { s } else { s + 1 }
}

exact fn node(nid : Int) -> (Int, Int) {
  let p1 = sample(forward(nid)) in
  let p2 = sample(forward(nid)) in
  (p1, p2)
}

exact fn network_step(
  n0 : Bool, n1 : Bool, n2: Bool, n3 : Bool, next : Int
) -> (Bool, Bool, Bool, Bool, Int, Int) {
  let n0 = n0 || (next == 0) in
  let n1 = n1 || (next == 1) in
  let n2 = n2 || (next == 2) in
  let n3 = n3 || (next == 3) in
  let fwd = node(next) in
  (n0, n1, n2, n3, fwd[0], fwd[1])
}

sample fn as_num(b : Bool) -> Float {
  if (b) { 1.0 } else { 0.0 }
}

sample {
  p <- exact(node(0));
  p1 <- p[0];  p2 <- p[1];
  i0 <- true; i1 <- false; i2 <- false; i3 <- false;
  q  <- []; q  <- push(q, p1); q  <- push(q, p2);
  num_steps ~ discrete(0.25,0.25,0.25,0.25);
  num_steps <- num_steps + 4;
  while (num_steps > 0) {
    nxt <- head(q);
    q   <- tail(q);
    state <- exact(network_step(i0, i1, i2, i3, nxt));
    i0 <- state[0]; i1 <- state[1]; i2 <- state[2]; i3 <- state[3];
    q  <- push(q, state[4]);
    q  <- push(q, state[5]);
    num_steps <- num_steps - 1;
    true
  };
  n0 <- as_num(i0);
  n1 <- as_num(i1);
  n2 <- as_num(i2);
  n3 <- as_num(i3);
  (n0 + n1 + n2 + n3)
}
\end{lstlisting}
\caption{The network reachability program for the 9-node grid topology}
\end{figure}

\begin{figure}[H]
\begin{sideways}
  \begin{minipage}{\textheight}
\centering
\begin{tabular}{c|ccccccccc}
  \toprule
        \multirow{2}{*}{Model} & \multicolumn{2}{c}{PSI} &              \multicolumn{2}{c}{Pyro}         &            \multicolumn{2}{c}{\host{} (\cont{})} &                \multicolumn{2}{c}{\host{}} \\
                               &       L1 &      Time(s) &                    L1 &              Time(s)  &                    L1 &                 Time(s)  &                      L1 &         Time(s)  \\
\midrule
 arrival/tree-15               &        --- &            --- &          0.365 $\pm$ 0.004 &         12.713 $\pm$0.025 &          0.355 $\pm$0.004 &    \textbf{0.247 $\pm$0.001} &   \textbf{0.337 $\pm$0.003} &     0.349 $\pm$0.002 \\
 arrival/tree-31               &        --- &            --- &          0.216 $\pm$0.002 &         26.366 $\pm$0.054 &          0.218 $\pm$0.002 &    \textbf{0.561 $\pm$0.004} &   \textbf{0.179 $\pm$0.002} &     0.754 $\pm$0.002 \\
 arrival/tree-63               &        --- &            --- &          0.118 $\pm$0.002 &         53.946 $\pm$0.086 &          0.120 $\pm$0.002 &    \textbf{1.469 $\pm$0.003} &   \textbf{0.093 $\pm$0.002} &     1.912 $\pm$0.004 \\
\midrule
 alarm                        &      t/o &          t/o &           1.290 $\pm$0.056 &         16.851 $\pm$0.024 &          1.173 $\pm$0.049 & \textbf{0.433 $\pm$0.002} &  \textbf{0.364 $\pm$0.015} & 14.444 $\pm$0.008 \\
 insurance                    &      t/o &          t/o &           0.149 $\pm$0.008 &         13.724 $\pm$0.020 &          0.144 $\pm$0.007 & \textbf{1.104 $\pm$0.012} &  \textbf{0.099 $\pm$0.006} & 11.406 $\pm$0.015 \\
\midrule
 gossip/4                     &        -- &            -- & \textbf{0.119 $\pm$0.002} & \textbf{6.734 $\pm$0.027} & \textbf{0.119 $\pm$0.001} &             0.720 $\pm$0.002 &            0.118 $\pm$0.002 &         0.812 $\pm$0.014  \\
 gossip/10                    &        -- &            -- &         0.533 $\pm$0.003  &         6.786 $\pm$0.009  &         0.531 $\pm$0.003  &             1.561 $\pm$0.006 &   \textbf{0.524 $\pm$0.003} & \textbf{1.373 $\pm$0.004} \\
 gossip/20                    &        -- &            -- &         0.747 $\pm$0.003  &         7.064 $\pm$0.010  & \textbf{0.745 $\pm$0.003} &             3.565 $\pm$0.005 &            0.750 $\pm$0.003 & \textbf{2.888 $\pm$0.003} \\
\midrule
\end{tabular}
\caption{%
Empirical results of our benchmarks of the arrival, hybrid Bayesian
network, and gossip tasks. ``\host{} (\cont{})'' shows the evaluation of a baseline \cont{} program
with no boundary crossings into \disc{}, evaluations under the ``\host{}''
column performs interoperation. ``t/o'' indicates a timeout beyond 30 minutes,
and ``---'' indicates that the problem is not expressible in PSI because of an
unbounded loop. %
}\label{apx:eval:approx}

  \end{minipage}
\end{sideways}
\end{figure}

\begin{figure}[H]
\begin{sideways}
  \begin{minipage}{\textheight}
  \centering
  \begin{tabular}{c|cc|ccccccc}
      \toprule
  \multirow{2}{*}{\# Nodes} &               PSI &      \host{} (\disc{})   &   \multicolumn{2}{c}{Pyro}                                  &  \multicolumn{2}{c}{\host{} (\cont{})}         &  \multicolumn{2}{c}{\host{}}                     \\
                            &           Time(s) &         Time(s)          &          L1                 &      Time(s)                  &                     L1 &       Time(s)         &                  L1        &       Time(s)       \\
    \midrule
             9              & 546.748 $\pm$ 8.018 & \textbf{ 0.001 $\pm$0.000} &    0.080 $\pm$0.002           &         3.827 $\pm$0.008          &           0.079 $\pm$0.002 & \textbf{0.067 $\pm$0.001} &      \textbf{0.033 $\pm$0.001} &        0.098 $\pm$0.001 \\
             36             &               t/o & \textbf{ 0.089 $\pm$0.002} &    1.812 $\pm$0.009           &        14.952 $\pm$0.025          &           0.309 $\pm$0.004 & \textbf{0.277 $\pm$0.002} &      \textbf{0.055 $\pm$0.002} &        1.169 $\pm$0.004 \\
             81             &               t/o & \textbf{40.728 $\pm$0.276} &    7.814 $\pm$0.017           &        33.199 $\pm$0.049          &           0.680 $\pm$0.005 & \textbf{0.887 $\pm$0.002} &      \textbf{0.079 $\pm$0.002} &       81.300 $\pm$0.278 \\
  \end{tabular}
  \caption{%
    Exact and approximate results for models performing approximate inference}%
  \label{apx:eval:reliability}
  \end{minipage}
\end{sideways}
\end{figure}

\section{Comparison with Nested Inference} \label{app:sec:comparison-with-nested-inference}








It is interesting to contemplate the relationship between the nested inference
approach and \multippl{}.  A crisp comparison --- for instance, a formal
expressivity result establishing that it is not possible to represent our
multi-language interoperation using nested inference --- is difficult, due to
(1) the large variety of different approaches to nested inference, and (2) the
fact that such expressivity results are very hard even for very restricted
languages, let alone rich general-purpose probabilistic programming languages.
It would be very interesting to investigate the relative expressivity of
multi-language interoperation and nested inference, but
such an investigation is beyond the scope of this paper.

At the very least, what we can say is that \multippl{}'s low-level denotational
semantics, and hence also its inference strategy, is markedly different from the
standard measure-theoretic semantics of nested inference, such as
\citet{staton2017commutative}'s model of nested queries.
In \citet{staton2017commutative}, probabilistic computations denote measure-theoretic
kernels. The computation \(\mathsf{normalize}(t)\)
represents a nested query: its
takes in a probabilistic
computation \(t\) of type \(A\)
and produces a deterministic computation
that can yield one of three possible outcomes:
\begin{enumerate}
\item a tuple \((1,(e,d))\) consisting of a normalizing constant
  \(e\) and a distribution \(d\) over elements of type \(A\),
\item a tuple \((2,())\) signalling that the normalizing constant
  was zero,
\item or a tuple \((3,())\) signalling that the normalizing constant
  was infinity.
\end{enumerate}
Soundness of nested inference is then justified by the
following equational reasoning principle, reproduced here from
\citet{staton2017commutative}:
\begin{equation} \label{eqn:nested-query}
  \llbr{t} =
  \llbr{\begin{aligned}
    \mathsf{case~normalize}(t)~\mathsf{of}
      ~&(1,(e,d))\Rightarrow\mathsf{score}(e);\mathsf{sample}(d)\\
      |~&(2,())\Rightarrow\mathsf{score}(0);t\\
      |~&(3,())\Rightarrow t
  \end{aligned}}
\end{equation}
Disregarding the edge cases where the normalizing constant
is zero or infinity,
\cref{eqn:nested-query} says
that running a probabilistic computation \(t\)
is the same as (1) computing a representation of
the distribution of \(t\), either by exact inference
or by ``freezing a simulation'' and examining ``a histogram that has been built''
in the words of \citet{staton2017commutative},
and then (2) resampling from this distribution
and scoring by the normalizing constant.

There are a number of points that prevent this model of nested inference
from being applied directly to justify correctness of \multippl{}, which
may help to clarify the difference between nested inference and \multippl{}'s
inference interoperation:
\begin{itemize}
\item It is about a kernel-based model where programs take deterministic values
as input, but MultiPPL's \disc{} programs take random variables as input. This
is an important difference: because \disc{} programs take random variables as
input, a \disc{} program that simply makes use of a free variable in context
produces a random variable, not a fixed deterministic value. In contrast, such
a program always denotes a deterministic point mass under a kernel-based
semantics.

\item \multippl{}'s semantics of \disc{} programs is stateful, and this is
necessary to model how exact inference works in our implementation.
Contrastingly, the kernel-based model of \citet{staton2017commutative} is not
stateful in this way, and so would not have been sufficient for establishing
our main soundness theorem.

\item Because the model of \citet{staton2017commutative} is not stateful,
  it can't account for the stateful updates to the probability space that \multippl{}
  performs in order to ensure sample consistency.

\item Finally, \cref{eqn:nested-query} suggests to use importance reweighting via
  \(\mathsf{score}\) to ensure sound
  nesting of exact inference within an approximate-inference context, by properly
  taking the normalizing constant produced by the nested query into account.
  This is quite different from how \multippl{}'s \(\sexact\) boundary form handles
  the nesting of \disc{} subterms in \cont{} contexts --- as shown in \cref{fig:low-level-effectful},
  the low-level semantics of \(\sexact\) does not perform importance reweighting.
  Instead, importance reweighting occurs in the semantics of \disc{}-observe
  statements. Thus \cref{eqn:nested-query} does not explain \multippl{}'s importance reweighting scheme.
\end{itemize}
Together, these points show that multi-language inference
is distinct enough from nested inference that the standard measure-theoretic
model of nested queries from \citet{staton2017commutative}
cannot be used directly to justify key aspects of \multippl{}'s inference strategy,
such as the need for sample consistency and when importance reweighting is performed.
Though \citet{staton2017commutative} is just one approach to modelling nested inference,
it being a relatively well-established approach suggests that there are indeed
fundamental differences between nested inference and \multippl{}'s multilanguage inference.
