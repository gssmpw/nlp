\putsec{eval}{Evaluation}
\input{sections/method}

\putssec{results}{Performance Results}

\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/perf.pdf}
  \caption{{Speedup of \name{} over the baseline GPU.}}
  \vspace{-0.20in}
  \label{fig:perf}
\end{figure}

\figref{perf} shows the speedups from two hardware extensions in \name{}:
hardware-based early termination (HET) and quad merging (QM). 
%
By applying each component to the baseline graphics hardware, we evaluate four
variants: Baseline, QM, HET, and HET+QM. 
%
QM reduces the amount of blending work for ROPs by partially blending the
overlapping quads within shader cores. 
%
This improves rendering performance by up to {1.49$\times$} over the baseline.
%
HET, on the other hand, excludes the fragments associated with terminated
pixels before fragment shading. This effectively reduces the number of
fragments to be processed in the hardware pipeline, thereby mitigating
unnecessary computations and memory accesses for both shading and blending,
providing a {1.80$\times$} speedup on average.
%
Overall, by combining HET and QM, \name{} provides an average speedup of
{2.07$\times$} over the baseline GPU.

The performance gain varies across the scenes, as the benefits of early
termination and quad merging are influenced by the scene size and viewpoint. 
%
For large, real-world outdoor scenes such as Train and Truck, we can achieve
greater speedups with early termination since a relatively large number of
Gaussians exist beyond the surface.
%
In contrast, Bonsai exhibits a lower speedup among real-world scenes due to its
inherent scene structure. With the object (i.e., the bonsai) positioned at the
center and surrounded by a background room, the benefit of early termination is
naturally concentrated in the central pixel region. 

For high-resolution scenes like Bonsai and Kitchen, the performance improvement
from quad merging is slightly lower compared to other scenes. This is because
successive primitives span a larger number of tile grids, causing TGC bins to
be flushed more frequently before being fully utilized.
%
Note that in practice, the primitives of these high-resolution scenes are
distributed across GPCs, which reduces the frequency of bin flushing.
%
Thus, the benefit of quad merging would likely be higher than observed in our
experiment.
%
In summary, \name{} consistently demonstrates performance improvements over the
baseline GPU, highlighting its broad applicability across diverse scene types.


\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/e2e-perf.pdf}
  \caption{Overall end-to-end speedups of \name{} over software-based (CUDA) and
  hardware-based (OpenGL) rendering.}
  \label{fig:eval-perf}
\end{figure}

\myparagraph{Overall End-to-End Rendering.}
%
\figref{eval-perf} compares the overall end-to-end performance estimation,
which includes preprocessing and sorting, between different scenarios of 3D
Gaussian rendering.\footnote{As our evaluated GPU is configured similarly to
AGX Orin, we observe a high correlation in execution time between the AGX Orin
and our simulation for the preprocessing kernel. However, due to the limitations
of Emerald, it is challenging to obtain correlated execution time for the
sorting kernel that employs the NVIDIA CUB library.
%
To better estimate the overall rendering performance, we use the execution time
of preprocessing and sorting kernels on AGX Orin in this experiment.}
%
For a fair comparison, software-based (CUDA) rendering uses early termination,
while hardware-based (OpenGL) rendering does not, as the baseline architecture
lacks native support for early termination.
%
On average, \name{} can provide a 2.05$\times$ and 1.60$\times$ speedup
over the SW-based (CUDA) and HW-based (OpenGL) rendering, respectively. 
%
Since the rasterization step, which is our optimization target, occupies more
than 70\% of total rendering time, \name{} can effectively accelerate the
overall end-to-end rendering process, achieving high frame rates (FPS).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/frag-quad-reduction.pdf}
  \caption{Reduction ratio of quads and fragments blended by ROP.}
  \vspace{-0.13in}
  \label{fig:frag-reduction}
\end{figure}


\putssec{src-of-gain}{Source of Performance Gain}

\figref{frag-reduction} shows the reduction in quads and fragments blended by
ROPs, a key source of performance gains for both HET and QM.
%
HET reduces the number of fragments by 2.52$\times$, significantly lowering the
amount of work by eliminating fragments before shading. QM further reduces the
number of fragments by 1.30$\times$ on top of HET, increasing the overall
blending throughput by utilizing shader cores for blending.
%
For quads, HET achieves a 1.90$\times$ reduction, with QM providing an
additional 1.32$\times$ reduction. The quad reduction of HET is smaller than
its fragment reduction because quads are eliminated only when all their
fragments are terminated. 
%
QM effectively reduces the number of quads by merging two into one. 
%
Consequently, by reducing ROP pressure, \name{} achieves speedups in relation
to the reduction in quads and fragments across the evaluated scenes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/energy-efficiency.pdf}
  \caption{Energy efficiency of \name{} over the baseline GPU.}
  \vspace{-0.10in}
  \label{fig:energy-efficiency}
\end{figure}

\putssec{energy}{Energy Efficiency}
%
To estimate the energy efficiency of a draw call when \name{} is implemented
in mobile/embedded GPUs, we imitate the effect of HET and QM in the AGX Orin. 
%
For HET, we first count the number of fragments until early termination for each
pixel and store the numbers in the stencil buffer. 
% 
During rendering, we then decrease the stencil value by 1 for each fragment
until the value reaches zero. Once the value becomes zero, we discard subsequent
fragments.
%
We also manually add warp shuffling, blending, discard operations in the
fragment shader, and make them operate as the same reduction ratio as QM in our
simulator. 
%
As a result, our approach provides {1.65$\times$} higher energy efficiency on average (up
to {2.15$\times$}) compared to the baseline GPU, as shown in \figref{energy-efficiency}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\putssec{cost}{Implementation Cost}

\begin{table}[b]
  \caption{Hardware cost of \name{}.}
  \centering
    \resizebox{0.95\columnwidth}{!}{%
      \begin{tabular}{cc}
        \toprule
        \textbf{Hardware}             & \textbf{Size}   \\
        \midrule
        \multirow{2}{*}{Tile Grid Coalescing Unit}
          & (4B CBE pointer * 3 vertices * 16 entries   \\
          & + 2B tile grid ID) * 128 bins = 24.25KB     \\
        \midrule
        \multirow{2}{*}{Quad Reorder Unit}   
          & (4B CBE pointer + 6-bit quad pos.) * 128    \\
          & + 64 * 1B register + 16B bitmap = 688B      \\
        \midrule
        \textbf{Total}              & 24.92KB           \\
        \bottomrule
      \end{tabular}
    }
  \label{tab:hw-cost}
\end{table}

\tabref{hw-cost} shows the hardware cost of our proposed hardware extensions
for volume rendering. We do not account for the cost of computational units
because the bitwise operators used for alpha and early termination tests, the
comparators in the tile grid coalescing unit, and the two floating point
comparators in the alpha test unit would be considerably cheaper than the
storage overhead.
%
Our hardware extensions require only 25KB of storage, which is negligible
considering it is for each GPC, not for a single SM.
