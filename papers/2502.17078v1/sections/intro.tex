\putsec{intro}{Introduction}

The advent of graphics techniques that combine machine learning and radiance
fields has sparked significant interest in a new direction of representing 3D
scenes via implicit neural fields (e.g., NeRF~\cite{mil:sri20}) or explicit
rendering primitives that are also differentiable (e.g., 3D
Gaussian~\cite{ker:kop23}).
%
Compared to traditional methods that use meshes and textures, these radiance
field-based techniques allow us to capture intricate details in 3D scenes and
produce far more realistic images from new and unseen viewpoints, leading to
their rapid adoption and plug-in development for popular graphics engines such
as Unity~\cite{unity} and Unreal~\cite{unreal}.
%
In particular, the graphics community is actively exploring the Gaussian
splatting~\cite{ker:kop23} technique due to its ability to generate
high-fidelity images with much faster rendering speeds than other radiance
field methods.

The core of the impressive rendering performance of Gaussian splatting lies in
the use of explicit \emph{rasterization} primitives. While Gaussian primitives
can, in principle, be rendered through the hardware graphics pipeline using
graphics APIs such as OpenGL~\cite{opengl}, Vulkan~\cite{vulkan}, and
Direct3D~\cite{d3d}, prior work has primarily focused on assessing their
performance based on software-based rendering~\cite{ker:kop23,rad:ste24} or
building a specialized accelerator~\cite{lee:lee24}, thereby leaving the
potential of exploiting graphics-specific hardware largely unexplored.

In this paper, instead of developing a dedicated accelerator, we explore
leveraging fixed-function hardware in GPUs to improve the rendering efficiency
of Gaussian splatting on commodity GPUs.
%
In doing so, we first implement Gaussian splatting rendering using an industry
standard graphics API and evaluate it on modern desktop and edge GPUs.
%
Our implementation shows that hardware-based radiance field rendering generally
offers better or comparable performance compared to state-of-the-art
software-based rendering, though this can vary slightly depending on the scenes
and hardware configurations, such as the number of programmable shader cores or
fixed-function raster operation (ROP) units in GPUs. 
%
However, we also observe that the existing hardware graphics pipeline falls
short of efficiently performing Gaussian splatting rendering.
%
This is because Gaussian splatting is a volume rendering technique that
produces a pixel color by accumulating a huge amount of \emph{transparent}
primitives (i.e., Gaussians) into the color buffer through per-pixel
blending.

\begin{figure}[t]
  \centering
  \includegraphics[clip,trim={0in 0.25in 0.05in 0in}, width=\columnwidth]{figures/shader-vs-rop.pdf}
  \caption{Number of shader cores and render output units in the recent generations of top-of-the-line NVIDIA desktop GPUs. 
  The labels on the bars indicate the absolute numbers for each.
  }
  \vspace{-0.20in}
  \label{fig:shader-vs-rop}
\end{figure}

In contrast, today's graphics hardware is primarily designed for mesh-based
rendering with mostly \emph{opaque} geometry. Although GPUs have seen a gradual
increase in the number of ROP units over successive generations, the growth has
been relatively modest, as shown in~\figref{shader-vs-rop}. 
%
For conventional mesh-based rendering, which typically involves one or only a
few fragments per pixel, ROP units rarely become the pipeline bottleneck.
However, volume rendering puts substantially more pressure on ROPs due to the
blending of hundreds of fragments per pixel.
%
Moreover, a commonly used optimization technique for volume rendering,
\emph{early ray termination}, is not natively supported in graphics hardware,
further limiting the potential for maximizing rendering performance.

Unfortunately, software-based optimizations aimed at reducing the ROP pressure
or supporting early termination do not provide much performance benefit.
%
For example, to alleviate the ROP pressure, one could use an extension feature
available in certain graphics APIs (e.g., OpenGL's \texttt{\small
ARB\_fragment\_shader\_interlock}) that allows for atomic pixel blending within
fragment shaders. However, this \emph{in-shader} blending approach can lead to
a significant drop in rendering performance due to the overhead of lock
acquisition~(\S\ref{ssec:in-shader-blending}).
%
Also, previous research has explored multi-pass rendering~\cite{kru:wes03} to
perform early termination using graphics APIs, but this approach offers limited
speedups or can even degrade performance due to the overhead of invoking
multiple intermediate rendering passes~(\S\ref{ssec:multipass}).

To this end, we present \name{} (Volume Rendering Pipeline), which features two
innovations that streamline the hardware graphics pipeline to better support
volume rendering workloads such as radiance field rendering.
%
The first is native hardware support for early termination by leveraging
existing special-purpose units (i.e., stencil test hardware) in contemporary
GPUs with minimal extension.
%
Our key observation is that both stencil test and early termination share
a similar purpose, so we can \emph{repurpose} the stencil test hardware for
checking early termination with negligible changes to ROPs.
%
The second is multi-granular tile binning with quad merging, which reduces the
number of blending operations performed in ROPs.
%
A key insight is that we can perform \emph{opportunistic} blending of
multiple fragments within a warp before passing them to ROPs by leveraging the
associative property of the blending equation and changing the computation
order.

We implement \name{} on the Emerald simulator~\cite{gub:aam19}, which builds on
gem5~\cite{bin:bec11} and GPGPU-Sim~\cite{bak:yua09}, while making extensive
modifications to the baseline implementation to better model contemporary
NVIDIA-like GPUs based on our analysis on real graphics hardware.
%
Our evaluation shows that \name{} improves Gaussian rendering performance by
{2.07$\times$} on average compared to the baseline graphics pipeline.
%
In summary, we make the following contributions:
%
\begin{itemize}
%
\item To our knowledge, this is the \emph{first} work to identify the
challenges and inefficiencies associated with Gaussian-based radiance field
rendering on the hardware graphics pipeline using graphics APIs.

\item We present \name{}, a hardware graphics pipeline that features native
support for early termination and multi-granular tile binning with quad
merging, which substantially improves the performance of volume rendering
workloads such as radiance field rendering.

\item We implement OpenGL-based microbenchmarks and provide an analysis
on several key fixed-function units in modern graphics hardware.
%
\end{itemize}
