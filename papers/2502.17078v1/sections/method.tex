\putssec{method}{Experimental Methodology}

\begin{table}[t]
  \centering
  \caption{Simulation configuration.}
  \label{tab:sys-config}
  %
  \resizebox{0.70\columnwidth}{!}{%
    \begin{tabular}{|c|c|}
      \hline
      \multicolumn{2}{|c|}{\textbf{GPU}} \\
      %\midrule
      %\toprule
      \hline
      \# GPC & 1 \\
      \hline
      \# SIMT Cores & 16 (1024 CUDA Cores) \\
      \hline
      SIMT Core Freq. & 612 MHz \\
      \hline
      Lanes per SIMT Core & 64 (4 warp schedulers)\\
      \hline
      L1D/T & 48 KB, 128B line \\
      \hline
      Shared L2 & 4 MB, 128B line (sectored) \\
      \hline
      CROP Cache Size & 16 KB, 128B line (sectored) \\
      \hline
      Raster Tile Size & 8$\times$8 pixels \\
      \hline
      Tile Grid Size & 64$\times$64 pixels (4$\times$4 tiles) \\
      \hline
      \# of TGC Bins & 128 \\
      TGC Bin Size & 16 primitives \\
      \hline
      \# of TC Bins & 32 \\
      TC Bin Size & 128 quads \\
      \hline
      ROP Throughput & 2 quads/cycle (RGBA16F)\\
      \hline
      DRAM & LPDDR3-1600 (16-channel) \\
      \hline
    \end{tabular}
  }
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent\textbf{Simulation Infrastructure.}
%
To evaluate the rendering performance of graphics workloads, we use the Emerald
simulator~\cite{gub:aam19} that builds on the gem5 and GPGPU-Sim simulators. 
%
Emerald models an SoC system that comprises both CPU and GPU cores.
%
We use \emph{standalone} (GPU) mode and implement our hardware extensions on
the baseline GPU architecture that models the hardware stages in contemporary
GPUs.
%
Because Emerald does not implement the hardware units that we need to build on,
we make extensive modifications to the codebase, based on our analysis on
graphics hardware, which we discuss in~\secref{analysis}.
%
We set the GPU frequency and DRAM bandwidth to match those measured using
Jetson AGX Orin in 30W power mode.
%
We measure the execution cycles between the start of a draw call and the end of
raster operations, which captures the performance of an end-to-end graphics
pipeline.
%
\tabref{sys-config} shows the system configuration used in this work.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{table}[t]
  \caption{Evaluated workloads.}
  \label{tab:workloads}
  %
  \resizebox{\columnwidth}{!}{%
    \begin{tabular}{ccc}
      \toprule
      \multicolumn{1}{c}{\textbf{Dataset}} &
      \multicolumn{1}{c}{\textbf{Scene (Resolution / \#Gaussians)}} & \multicolumn{1}{c}{\textbf{Type}} \\
      \midrule
      \multirow{2}{*}{Mip-NeRF 360~\cite{bar:mil22}} &
      \multicolumn{1}{c}{Kitchen (1552$\times$1040 / 1.85M)} & \multirow{2}{*}{Real World \& Indoor}  \\
      \cmidrule(lr){2-2}
      & 
      \multicolumn{1}{c}{Bonsai (1552$\times$1040 / 1.24M)} &  \\ %\multicolumn{1}{c}{Real World \& Indoor} \\
      \cmidrule(lr){1-3}
      \multirow{2}{*}{Tanks\&Temples~\cite{kna:par17}} & 
      \multicolumn{1}{c}{Train (980$\times$545 / 1.03M)} & \multirow{2}{*}{Real World \& Outdoor}  \\
      \cmidrule(lr){2-2}
      & 
      \multicolumn{1}{c}{Truck (979$\times$546 / 2.54M)} & {} \\
      \cmidrule(lr){1-3}
      \multirow{1}{*}{Synthetic-NeRF~\cite{mil:sri20}} &
      \multicolumn{1}{c}{Lego (800$\times$800 / 358K)} & \multirow{2}{*}{Synthetic}  \\
      \cmidrule(lr){1-2}
      \multirow{1}{*}{Synthetic-NSVF~\cite{liu:gu20}} &
      \multicolumn{1}{c}{Palace (800$\times$800 / 327K)} & {} \\
      \bottomrule
    \end{tabular}
  }
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\myparagraph{Workloads.}
%
\tabref{workloads} shows the workloads that we use to evaluate \name{}.
%
We carefully select six widely-used scenes from published
datasets~\cite{bar:mil22,kna:par17,mil:sri20} to evaluate real-world and
synthetic scenes with varying complexity.
%
For each scene, we train the model for 30K iterations, which results in
approximately {300K to 2.5M} Gaussians per scene.
%
We generate the trace of OpenGL ES API calls using apitrace~\cite{apitrace} and
simulate the rendering at the full image resolution specified in the table.
%
For the evaluated viewpoints, up to 900K Gaussians are within the viewing
frustum.
