\putsec{analysis}{Analysis and Discussion}

\putssec{reverse}{Analysis on Real Graphics Hardware}

Emerald~\cite{gub:aam19} does not implement, or approximately models, the
graphics hardware units that we need to build upon (e.g., ROP, tile binning
hardware). To address this, we created OpenGL-based microbenchmarks to explore
the characteristics of these special-purpose units in real graphics hardware
and properly model them in our simulation framework.
%
The microbenchmarks render rectangles or triangles by adjusting various
parameters, including positions, color formats, the number of involved screen
tiles and rectangle overlaps. 
%
They are carefully designed and configured to stress the \emph{unit of
interest} while minimizing the impact on or from other units. 
%
For example, we restrict our analysis to a single GPC by positioning primitives
within the screen tiles mapped to a specific GPC, as each GPC contains its own
special-purpose units.
%
Also, as modern GPUs employ color compression, we attempt to bypass it by
generating different colors for each pixel via hashing.
%
We run them on NVIDIA Ampere GPUs and measure the data using Nsight Graphics.
OpenGL extensions including \texttt{\small GL\_NV\_shader\_thread\_group} and
\texttt{\small GL\_NV\_shader\_thread\_shuffle} are also used to collect data
from running warps formed through the graphics pipeline.
%

\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/rop-analysis.pdf}
  \caption{(a) Data sizes fitting within the CROP cache across different
  rectangle sizes, measured by rendering rectangles at randomized positions. The
  scatter in data points shows variability in cache usage due to randomized
  positions tested.
  (b) Pixels per cycle when rendering the same amount of pixels using
  RGBA16F or RGBA8 color format.  
  (c) Normalized rendering time with varying quads per pixel when using RGBA16F
  color format. The quads per pixel value is controlled by using a stencil test
  and adjusting the shape and position of primitives.
  }
  \vspace{-0.10in}
  \label{fig:rop-analysis}
\end{figure}

\myparagraph{Render Output Unit (ROP).}
%
The ROP units are now part of the GPC from the Ampere architecture to increase
the performance of raster operations~\cite{ampere}.
%
A single GPC has two ROP partitions, each containing eight ROP units. A single
ROP unit can process a single fragment by fetching the corresponding pixel
color of the image.
%
We observe that ROP units do not fetch pixel colors directly from the
L2 cache but first access another cache-like structure in each GPC, and we
refer to it as a CROP cache.
%
If a cache miss occurs, the color values are fed from the L2 cache. 

We first measure the size of the CROP cache by rendering multiple rectangles
while inspecting the L2 cache bandwidth consumption from CROP.
%
\figref{rop-analysis}(a) shows the size of pixel color data before CROP starts
accessing the L2 cache while increasing the number of rectangles. 
%
For example, we first draw an 8{$\times$}16-pixel rectangle using the
RGBA16F\footnote{Each red, green, blue, and alpha channel is a $16$-bit
floating-point number.} (FP16) pixel format, which corresponds to 1{KB}.
%
We then add more rectangles in random positions until the CROP starts accessing
the L2 cache.
%
The results show that 8{$\times$}16-pixel rectangles can be drawn at 16
locations without L2 cache access.
%
Over various rectangle sizes and positions, the CROP cache has never held more
than 16KB of data, suggesting its size is likely 16KB. 

\figref{rop-analysis}(b) shows that the number of pixels per cycle that CROP
can process depends on the color format of the rendered image. For example, the
pixels-per-cycle throughput is higher when using the RGBA8 (UNORM8) pixel
format compared to RGBA16F. For RGBA8, which is 32 bits per pixel (bpp), a GPC
with 16 ROP units can process 16 pixels per cycle, whereas it can process only
8 pixels per cycle when using the RGBA16F format, which is 64 bpp. 
%
This implies that the effective read bandwidth of the CROP cache is likely to
be larger than 64 bytes per cycle.
%
We also observe that ROPs cannot achieve the maximum pixels-per-cycle
throughput if some pixels in a quad are partially discarded, as shown in
\figref{rop-analysis}(c). This implies that the ROP units operate at a quad
granularity; i.e., four ROP units operate together to process a
2$\times$2-fragment quad.


\myparagraph{Tile Binning.}
%
We analyze the behavior of tile binning while varying the number of screen
tiles ($N$) involved in rendering.
%
To investigate the number of tile bins, we draw \emph{distinct} primitives
(2$\times$2-pixel rectangles) that are distributed across $N$ screen tiles and
measure the number of warps launched.
%
We arrange the rectangles to visit the screen tiles in a round-robin manner
(i.e., a repeating sequence of 1, 2, ..., $N$, 1, 2, ...), which helps us
clearly observe the flushing effect.
%
Note that each bin collects only the quads within the same screen tile, as
previously discussed.

We observe that quads from distinct rectangles at the same pixel position but
from different rounds are binned and launched together mostly as a single warp
if $N$ is less than or equal to 32. 
%
However, once $N$ exceeds 32, rectangles within the same screen tile but from
different rounds are launched as separate warps. 
%
For example, drawing 320 rectangles across 32 screen tiles results in 67 warps
being launched.
%
In contrast, drawing 330 rectangles across 33 screen tiles leads to the launch
of 330 warps (i.e., each warp contains only a single quad).
%
This occurs because, after the 32nd primitive, the binning of the 33rd
primitive---rendered on the 33rd screen tile---triggers the flushing of one of
the bins, resulting in the launch of an underutilized warp. This pattern
continues for the remaining primitives, which indicates that each GPC in the
evaluated GPUs has 32 tile bins.


\putssec{}{Early Termination Ratio of Varying Viewpoints}

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{figures/ert-ratio.pdf}
  \caption{Early termination ratio of varying viewpoints.}
  \vspace{-0.10in}
  \label{fig:ert-ratio}
\end{figure}

\figref{ert-ratio} shows the early termination ratio across different
viewpoints. We evaluate all the viewpoints that are provided in the dataset.
The early termination ratio is the ratio between the number of blended
fragments processed with and without early termination. A higher ratio
indicates a greater potential for performance improvements through early
termination. 
%
As discussed in~\ssecref{src-of-gain}, outdoor scenes exhibit higher average
ratios than indoor or synthetic scenes because there are more Gaussians beyond
the surface in larger scenes. For example, up to nearly 4.4 times more
fragments could be unnecessarily blended without early termination in the Train
scene.
%
While the ratio varies depending on the scenes, every scene shows an average
ratio greater than 1.5, indicating that more than 33\% of the fragments can be
eliminated by early termination. 
%
This demonstrates that supporting early termination in hardware is a key factor
for efficient volume rendering.

\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/vr-pipe-vs-gscore.pdf}
  \caption{Performance comparison with GSCore~\cite{lee:lee24}.}
  \vspace{-0.1in}
  \label{fig:vr-pipe-vs-gscore}
\end{figure}

\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/large-scale.pdf}
  \caption{(a) Unit utilization and (b) speedup for large-scale scenes.}
  \vspace{-0.20in}
  \label{fig:large-scale}
\end{figure}

\putssec{}{Discussions}

\noindent\textbf{Comparison to Accelerators for 3D Gaussian Splatting.}
%
\figref{vr-pipe-vs-gscore} compares the performance of \name{} with a
specialized accelerator for 3D Gaussian splatting, GSCore~\cite{lee:lee24}. 
%
The results show that GSCore performs better than \name{} due to its tailored
design for Gaussian splatting.
%
As a dedicated accelerator, however, GSCore is inherently limited to running
graphics workloads involving Gaussian splatting and requires custom compilers
and runtime. 
%
\name{}, on the other hand, extends the capabilities of existing graphics
hardware and runs standard graphics APIs, offering greater flexibility
for rendering both traditional rasterization and volume rendering tasks.
%
We expect that future acceleration efforts will involve both building
specialized accelerators and enhancing existing graphics hardware, depending on
deployment requirements.

\myparagraph{Scalability for Larger or More Complex Scenes.}
%
As mentioned in~\ssecref{gr}, Gaussian primitives are rendered in a tile-based
manner, and thus the benefit of \name{} can be easily extended to very
large-scale scenes as long as they fit within the GPU memory.
%
For larger or more complex scenes, such as Building (9.06M Gaussians) and
Rubble (5.21M Gaussians) used in Mega-NeRF~\cite{tur:ram22} and
CityGaussian~\cite{liu:gua24}, there is a significantly higher number of
Gaussians that need blending, which makes ROPs a persistent bottleneck, as
shown in~\figref{large-scale}(a). Consequently, \name{} helps improve rendering
performance for these large-scale scenes, as shown in~\figref{large-scale}(b).

\myparagraph{Potential for Future Deployments in GPUs.}
%
Both hardware early termination (HET) and quad merging (QM) could potentially
be adopted in GPUs, as the main hardware overhead is only tens of kilobytes of
storage for the bins in the TGC unit and a few registers in the quad reorder
unit, as discussed in~\ssecref{cost}.
%
Between HET and QM, we envision that HET may have great potential for direct
deployment, as it offers solid performance benefits across different scene
types, as shown in~\figref{perf}, and is relatively simple to implement without
much hardware overhead.
%
As for QM, it is noted that the storage overhead added for QM is per GPC, not
per SM. Given that the baseline GPU (Jetson AGX Orin) contains at least 3.6MB
of SRAM in a single GPC, the additional overhead for QM might also be
acceptable.
