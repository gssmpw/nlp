\putsec{arch}{\name{}: Streamlining Graphics Hardware}

\putssec{overview}{Overview of Architecture and Execution Flow}

\figref{vr-pipe-arch} provides an overview of the baseline GPU architecture
along with our hardware extensions for volume rendering. Because graphics
hardware is designed to support the standard graphics APIs, the high-level
microarchitecture is broadly similar across different hardware vendors, though
each may implement minor optimizations. Accordingly, we build our extensions on
a general graphics architecture commonly found in contemporary GPUs and
described in prior
literature~\cite{gub:aam19,tin:sax23,lin:mor09,rho:mol14,pur:mol13}, combined
with our analysis of real graphics hardware. Note that the hardware extensions
are generally applicable as they do not significantly alter the standard
hardware pipeline.

When input vertices are assigned to a SIMT cluster, the shader cores fetch
vertex data from memory, perform vertex shading, and output the resulting
vertices with attributes. 
%
Instead of passing the actual attribute data, a pointer to the attributes is
sent to the next pipeline stage after the attributes are stored in a designated
memory region in the L2 cache.\footnote{In NVIDIA terminology, this memory
region is called the Circular Buffer (CB), and the corresponding cache lines
are marked as no-evict~\cite{rho:mol14}.}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
  \centering
  \includegraphics[width=\columnwidth]{figures/vr-pipe-arch.pdf}
  \caption{\name{} microarchitecture.}
  \vspace{-0.20in}
  \label{fig:vr-pipe-arch}
\end{figure}

The vertices are then assembled as triangle primitives in the vertex processing
and operations (VPO) unit. For each primitive, the VPO unit also identifies
intersecting \emph{screen} tiles (e.g., a block of 16$\times$16 pixels) by
computing the bounding box of each primitive. Since each SIMT cluster is
exclusively responsible for a set of screen tiles, the primitives are then
distributed across SIMT clusters through a crossbar to run the subsequent
pipeline stages. If a primitive intersects multiple tiles, it is sent to
multiple different clusters and processed independently.

The tile grid coalescing (TGC) unit then manages these primitives at a coarser
granularity than a screen tile, which we call a \emph{tile grid} (e.g.,
4$\times$4 screen tiles).
%
Each bin in the TGC unit manages a tile grid and collects primitives that
intersect with any of the cluster's screen tiles within that grid.
%
When a bin has collected a sufficient number of primitives for the tile grid,
the TGC unit flushes the bin.

Once a TGC bin is flushed, the rasterizer performs rasterization for every
primitive in four sequential steps: setup, coarse raster, hierarchical-z (Hi-z)
test, and fine raster.
%
The setup unit first computes edge equations of the primitive using vertex
coordinates. The coarse raster then identifies intersecting \emph{raster} tiles
(e.g., 8$\times$8 pixels) within a screen tile.
%
The Hi-z test is performed on each raster tile, and only the raster tiles that
pass the test are sent to the next pipeline stage.
%
Finally, the fine raster unit checks if each pixel in the raster tile is
covered by the primitive. The pixels within the primitive are then assembled as
2$\times$2-fragment quads.

The tile coalescing (TC) unit manages a set of TC bins, each collecting the
quads for the \emph{same} screen tile.
%
It aggregates the quads from the fine raster unit into the corresponding bin
and flushes them to the Pre-ROP (PROP) hardware, which controls the blending
order between multiple quads. The flush occurs when one of three conditions is
met.
%
First, the bin is full.
%
Second, all bins are occupied and a quad from a new tile arrives (the oldest
bin is flushed).
%
Third, pre-determined cycles have elapsed after the last incoming quad.

When the bin is flushed, the quads are sent to the depth-stencil ROP (ZROP) for
an early termination check before fragment shading.
%
This hardware support for early termination operates at the \emph{fragment}
level during a \emph{single} draw call, thereby realizing most of its potential
compared to CUDA-based or OpenGL-based implementations.
%
The quads with at least one fragment that passes the early termination test are
sent back to the PROP. A quad reorder unit in the PROP then identifies the
overlapping quads that can be \emph{merged} in the shader cores and sets the
necessary flags. These quads are then dispatched to the shader cores as warps
for fragment shading, where quad merging is performed via warp shuffling.

After the shading, the surviving fragments from alpha pruning and quad merging
are sent to the color ROP (CROP) for pixel blending.
%
The termination hardware in the ROP checks if the termination condition is met
after blending and updates termination information as needed.
%
In the following subsections, we explain the architectural details of
hardware-based early termination and multi-granular tile binning with quad
merging.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t]
  \centering
  \includegraphics[clip,trim={0in 0in 0in 0in}, width=0.95\columnwidth]{figures/early-term-hw.pdf}
  \caption{Early termination hardware in ROP.}
  \vspace{-0.20in}
  \label{fig:early-term-hw}
\end{figure}

\putssec{early-term-hw}{Hardware Support for Early Termination}

\figref{early-term-hw} shows hardware extensions to enable early termination
in the graphics pipeline. Early termination and stencil test share a similar
purpose: eliminating fragments that do not affect the final rendered output
before shading and blending. In this sense, the early termination unit can be
architected in the same stage where the stencil test unit is placed.

Our key insight is that multi-bit (e.g., 8-bit) stencil data per pixel is
already used for the stencil test, and we only need one bit data for checking
if the pixel is early terminated.
%
In most cases, only a few bits of the stencil value are used for the stencil
test by masking (e.g., \texttt{\small glStencilMask(0x01)}), and the remaining
bits can be used for the early termination test. 
%
By repurposing the most significant bit (MSB) of the stencil value for the
termination check, both early termination and the stencil test can be supported
harmonically. 

For example, when an 8-bit stencil value is used, the MSB serves as a
termination flag, while the remaining 7 bits are used for the stencil test.
%
Initially, the MSB is set to 0, allowing fragments of the pixel to pass the
termination test and blend with the pixel color.
%
Once the pixel's alpha value is sufficiently accumulated, the MSB is set to 1,
marking the pixel as terminated.
%
All subsequent fragments for the pixel are then discarded before shading.
%
As such, the early termination unit can be implemented with negligible overhead
by leveraging the existing stencil buffer. 

We add three lightweight computational units to the ROP. First, after blending
the pixel color (destination RGBA) with the shaded fragment color (source RGBA)
in CROP, the alpha test unit determines if the early termination condition is
met by checking if the alpha exceeds a predefined threshold by this fragment.
% 
Instead of comparing only the accumulated alpha value, we also check if the
previous alpha does not exceed the threshold.
%
This is because using only the former condition would unnecessarily generate
more termination bit update requests to ZROP, which leads to bandwidth
contention to the z-cache and an increase in latency for the termination test.
%
If the pixel is newly terminated, the alpha test unit then sends a termination
signal to ZROP with a pixel coordinate.

In ZROP, the termination update unit is triggered by the termination signal and
updates a termination bit to 1. After the address calculation with the pixel
coordinate, it first loads the stencil value and sets the termination bit using
a bitwise OR operation. The updated stencil value of the terminated pixel is
then written back to the z-cache.

The early termination test is performed for the fragments that are flushed from
the TC unit. By conducting the test, we can effectively discard fragments of
the pixels that are already early-terminated and no longer need to be blended.
Consequently, this early termination test reduces the amount of work for shader
cores and ROPs, easing the burden of fragment shading and blending,
respectively.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\putssec{quad-merging}{Reducing ROP Workload by Quad Merging}

It is costly and challenging to increase ROP throughput by adding more blending
units to the SIMT cluster and increasing ROP cache bandwidth.
%
Instead, we leverage shader cores for blending, which offer high compute
throughput yet are underutilized in Gaussian rendering.
%
Our key insight is that volume rendering has an \emph{associative} property, so
we can alter the order of fragment blending---though not arbitrarily.
%
\begin{equation}
\small
\begin{aligned}
  \mathbf{{C}} = \mathrm{\sum\limits_{i=1}^{3}} \mathrm{\alpha_i\mathbf{c}_i} \mathrm{\prod_{j=1}^{i-1}} \mathrm{(1-\alpha_j)} 
  =& f_{fb} (f_{fb}(\mathbf{c}_{\mathrm{pm},1}, \mathbf{c}_{\mathrm{pm},2}), \mathbf{c}_{\mathrm{pm},3}),
  \label{eqn:a-blending-order}
\end{aligned}
\end{equation}
\begin{equation*}
\text{ where}
\footnotesize
  \text{$
  ~\mathbf{c}_{\mathrm{pm,i}}=\mathrm{(\alpha_i r_i,\alpha_i g_i}\mathrm{, \alpha_i b_i, \alpha_i)},
  ~f_{fb}(\mathbf{c}_{1}, \mathbf{c}_{2}) = \mathbf{c}_{1} + (1 - \alpha_1) \mathbf{c}_{2}.
  $
  }
\end{equation*}

\eqnref{a-blending-order} shows an example of blending two fragments
$\mathbf{c}_2$ and $\mathbf{c}_3$ into a (pre-multiplied alpha) pixel RGBA
color $\mathbf{c}_{\mathrm{pm},1}$. 
%
In the hardware pipeline, fragments are sent from PROP to CROP in front-to-back
order.
%
Since the front-to-back alpha blending equation $f_{fb}$ is associative, i.e.,
$f_{fb}(f_{fb}(\mathbf{c}_{1}, \mathbf{c}_{2}), \mathbf{c}_{3}) =
f_{fb}(\mathbf{c}_{1}, f_{fb}(\mathbf{c}_{2}, \mathbf{c}_{3}))$, we can
\emph{partially} change the computation order of volume rendering.
%
This allows for \emph{opportunistically} blending fragments in shader cores,
thereby reducing the number of blending operations by ROPs without
affecting the final pixel color; note that we cannot obtain the correct color
with $f_{fb}(\mathbf{c}_2, f_{fb}(\mathbf{c}_1, \mathbf{c}_3))$ though.

\begin{figure}[t]
  \centering
  \includegraphics[clip, trim={0cm 0.0cm 0cm 0cm}, width=0.95\columnwidth]{figures/quad-merging-hw.pdf}
  \vspace{-0.03in}
  \caption{Overall hardware pipeline for quad merging.}
  \vspace{-0.19in}
  \label{fig:quad-merging-hw}
\end{figure}

\figref{quad-merging-hw} shows the hardware pipeline for quad merging. Since
the conventional hardware graphics pipeline processes quads as the smallest
unit of granularity, our goal is to identify overlapping quads within a warp
and \textit{merge} them into a single quad by performing partial blending in
the shader cores. To do so, we propose hardware and software extensions
designed to merge the quads as much as possible.

On the hardware side, we introduce a \emph{tile grid} coalescing (TGC) unit and
a quad reorder unit.
%
Without the TGC unit, the TC unit simply gathers quads that belong to the same
screen tile into the TC bin, and the subsequent quad reorder unit attempts to
find overlapping quads.
%
However, the limited number of TC bins causes them to be frequently flushed
before collecting a sufficient number of quads to be merged, particularly when
primitives are large or spatially distributed.
%
To increase the opportunity to merge quads, the TGC unit first gathers the
primitives that intersect the same \emph{tile grid} into the TGC bin. 
%
Note that the \emph{tile grid} is larger than a screen tile but is still
smaller than the region that all TC bins in the TC unit can cover.
%
When the TGC bin is flushed, the rasterizer processes the primitives within the
\emph{tile grid} and generates quads that can be handled by a set of TC bins,
thereby mitigating the premature flushing of the TC bins.

When the TC bin is flushed, the quad reorder unit (QRU) identifies the
overlapping quads and reorders them to launch together in the same warp.
%
The input quads are stored in the buffer and assigned sequential quad IDs
(QIDs) from 0 to 127.
%
For overlap detection, the QRU maintains 64 8-bit (consisting of a valid bit
and 7-bit quad ID) registers, each corresponding to a relative quad location in
a screen tile from position $(0,0)$ to $(7,7)$.
%
The unit sequentially examines each quad starting from QID 0 and stores its QID
in the register corresponding to its location.
%
If the register already contains a valid QID, this indicates an overlap between
two quads.
%
Upon detecting overlapping quads, the QRU adds the pair into a warp with a
merge flag indicating that they need to be merged in the fragment shader.
%
The unit also manages a 128-bit bitmap where each bit represents whether the
quad will be merged.
%
After examining all quads, the QRU fills the warps with the quads that will not
be merged using the bitmap.

\begin{figure}[t]
  \centering
  \includegraphics[width=0.95\columnwidth]{figures/merging-flow.pdf}
  \caption{Execution timeline of fragment shader with quad merging.}
  \vspace{-0.15in}
  \label{fig:merging-flow}
\end{figure}

On the software side, we propose an extension that can be added to the original
shader for quad merging.
%
\figref{merging-flow} illustrates the execution flow of the fragment shader
with the proposed software extension.
%
After completing the original fragment shading operations, the threads marked
with a merge flag engage in partial blending. 
%
In the figure, for instance, two quads at quad offset 0 (threads 0-3) and 1
(threads 4-7) need to be merged.
%
Since two quads to be merged are always adjacent in the warp by the quad
reorder unit, the quad at $(2n+1)$ quad offset retrieves the fragment colors
from the quad at $2n$ offset using warp shuffling and blends them with its own.
%
Ultimately, a single merged quad is produced and sent to the ROP for final
blending into the color buffer.
%
By leveraging the high bandwidth of warp shuffling and the high compute
throughput of shader cores, we can increase effective blending throughput,
which would otherwise be limited by the number of ROP units.
