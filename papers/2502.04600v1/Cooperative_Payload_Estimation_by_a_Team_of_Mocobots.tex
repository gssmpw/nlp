\documentclass[letterpaper, 10 pt, journal, twoside]{IEEEtran}
%\IEEEoverridecommandlockouts

% Added after RAL Acceptance 
%\overrideIEEEmargins
% Comment this command for final RAL version.
% Use this command for initial and revised RAL versions, and for final conference version

\usepackage{times}
\usepackage{array}
\usepackage{comment}
\usepackage{csquotes}

% numbers option provides compact numerical references in the text. 
\usepackage[numbers,sort&compress]{natbib}
\usepackage{multicol}
\usepackage[bookmarks=true]{hyperref}

% MATH PACKAGES
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{cancel}
\usepackage{wasysym}
\usepackage{xfrac}
\usepackage{mathrsfs}
\usepackage{euscript}
\usepackage{bbm}
\usepackage{rotating}

\DeclareMathAlphabet{\mymathbb}{U}{bbold}{m}{n}

% THEOREM STUFF 
\usepackage{amsthm}
\newtheorem{rmk}{Remark}
\newtheorem{thm}{Theorem}
\newtheorem{assumption}{Assumption}
\newenvironment{shortPrf}
  {\noindent \textit{Proof.\space}}
  {\hfill $\square$}

\usepackage{xcolor}
\usepackage{balance}
%\pagenumbering{gobble} used to suppress page numbers
\usepackage[normalem]{ulem}

\usepackage[font=footnotesize]{caption}
\setlength{\belowcaptionskip}{-5pt}

% *** GRAPHICS RELATED PACKAGES ***
\usepackage{graphicx}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{epstopdf}
\usepackage{float}
\usepackage{tikz}
\usepackage{wrapfig}
\newlength{\sepwid}
\setlength{\sepwid}{0.5cm}
\usepackage[maxfloats=256]{morefloats}
\maxdeadcycles=1000

\usepackage{url}
\def\UrlBreaks{\do\/\do-}

\usepackage{lipsum}
\usepackage{cuted}

\usepackage{multirow}

% custom macros:
\newcommand{\etal}{et al.\ }
\newcommand{\ie}{i.e., }
\newcommand{\eg}{e.g., }
\newcommand{\vs}{vs.\ }
\DeclareMathOperator{\taninv}{tan^{-1}}
\newcommand{\rulesep}{\unskip\ \vrule height -1ex\ }
\newcommand{\real}{\mathbb{R}}
\newcommand{\transp}{\top}

\newcommand{\wrench}{{\mathcal F}}
\newcommand{\config}{{\mathcal X}}
\newcommand{\twist}{{\mathcal V}}
\newcommand{\mass}{{\mathfrak{m}}}
\newcommand{\grav}{{\mathfrak{g}}}
\newcommand{\inertia}{{\mathcal{I}}}
\newcommand{\frames}{\operatorname{s}}
\newcommand{\framec}{\operatorname{c}}
\newcommand{\frameb}{\operatorname{b}}

\begin{document}
\bstctlcite{IEEEexample:BSTcontrol}

% paper title
\title{Cooperative Payload Estimation by a Team of Mocobots}

% \begin{comment}
\author{
Haoxuan Zhang$^{1,2}$, C. Lin Liu$^{1,2}$,  Matthew L. Elwin$^{1,2}$,  Randy A. Freeman$^{2,3,4}$, and Kevin M. Lynch$^{1,2,4}$

%\thanks{}
%\thanks{}
%\thanks{}
\thanks{All authors are affiliated with Northwestern University, Evanston, IL 60208 USA. (emails: {\tt\footnotesize haoxuanzhang2024@u.northwestern.edu}, {\tt\footnotesize lin.liu@u.northwestern.edu}, {\tt\footnotesize elwin@northwestern.edu}, {\tt\footnotesize freeman@northwestern.edu}, {\tt\footnotesize kmlynch@northwestern.edu})

$^1$Department of Mechanical Engineering, $^2$Center for Robotics and Biosystems, $^3$Department of Electrical \& Computer Engineering, $^4$Northwestern Institute on Complex Systems} %Use only for final RAL version
} %end \author
%\end{comment}

% The paper headers
%\markboth{Zhang \MakeLowercase{\textit{et al.}}: Cooperative Payload Estimation by Mocobots}


\maketitle \pagestyle{empty} \thispagestyle{empty}
\begin{abstract}
Consider the following scenario: a human guides multiple mobile manipulators to grasp a common payload. For subsequent high-performance autonomous manipulation of the payload by the mobile manipulator team, or for collaborative manipulation with the human, the robots should be able to discover where the other robots are attached to the payload, as well as the payload's mass and inertial properties. In this paper, we describe a method for the robots to autonomously discover this information. The robots cooperatively manipulate the payload, and the twist, twist derivative, and wrench data at their grasp frames are used to estimate the transformation matrices between the grasp frames, the location of the payload's center of mass, and the payload's inertia matrix. The method is validated experimentally with a team of three mobile cobots, or mocobots.

%Human-robot collaboration, particularly through the use of mobile collaborative robots, or mocobots, enhances efficiency and productivity by combining human perception and decision making with robotic strength. For mocobots to perform stable and precise manipulation and transportation tasks, knowledge of payload inertial properties—such as mass, center of mass, and inertia matrix—is essential. This research focuses on the estimation of inertial properties for rigid body payloads. By using measurements of twists, twist derivatives, and forces from wrenches at the robot-payload attachment point, the payload's mass, center of mass, and inertia matrix, along with the transformation matrix between each mocobot, can be estimated.
\end{abstract}

\begin{IEEEkeywords}
inertial property, payload estimation, mocobot, robot cooperation, human-robot collaboration
\end{IEEEkeywords}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction} 
%\IEEEPARstart{M}{obile} collaborative robots, or mocobots, are designed to assist human operators manipulating large payloads, enhancing safety and productivity~\cite{elwin2022human}. The partnership combines the human's perception and adaptability with the robots' physical strength (Figure~\ref{fig:demo}). 

\IEEEPARstart{C}{onsider} a scenario in manufacturing, logistics, or construction where a large, substantially rigid payload must be manipulated in all six degrees of freedom (dof), perhaps for an assembly or loading task. Multiple distributed contacts with the payload are required, to respect the workspace and wrench limits of any single manipulator and to minimize stress concentrations for heavy or fragile payloads. 
If the manipulation task is not one that is easily automated (e.g., it is not a repetitive task performed in a structured environment), then one or more human operators can physically collaborate with a team of mobile cobots, or mocobots~\cite{elwin2022human}.  The partnership combines the mocobots' physical strength with human perception and adaptability  (Figure~\ref{fig:demo}). 

First, a human guides the mobile manipulators to grasp locations on the common payload. Once the grasps are established, to provide optimal model-based assistance to the human, or for high-performance autonomous manipulation, the robots should be able to discover where the other robots are attached to the payload, as well as the payload's mass and inertial properties. 

In previous work~\cite{elwin2022human}, much of this information was provided to the mocobots in advance of manipulation. In this paper, we describe a method for the robots to discover this information. The robots cooperatively manipulate the payload, and the twist, twist derivative, and wrench data at their grasp frames are used to estimate the transformation matrices between the grasp frames, the location of the payload's center of mass, and the payload's inertia matrix. The method is validated experimentally with a team of three mocobots.

%the following scenario: a human guides multiple mobile manipulators to grasp a common payload. For subsequent high-performance autonomous manipulation by the mobile manipulator team, or for collaborative manipulation with the human, 

%When loading a payload onto the mocobots, the kinematics and dynamics aspect of the object is desired so that the robot team is able to do manipulation tasks properly. The kinematics part involves the general form of the object, whether it is an articulated, flexible, or rigid body. The dynamics part includes the mass, center of mass (CoM), and inertia matrix of the object. With the knowledge of the payload's properties, mocobots can ensure the payload manipulation remains stable and balanced. It is also crucial to prevent unsafe motion and increase the accuracy of the motion control. In this paper, we focus on the estimation of the mass, CoM, and inertia matrix of a rigid body object with unknown properties, as well as the transformation matrix between each robot, which provides a foundation for further research.

%In our setup, the experiment platform uses the Omnid mocobots. Each Omnid mocobot consists of a mecanum-wheel omnidirectional mobile base, a 3-dof delta parallel mechanism driven by series-elastic actuators (SEAs), and an encoder-instrumented 3-dof passive gimbal wrist that provides safe passive compliance for human interaction. Each Omnid is able to collect transformation matrix $T_{i_{0}i}$ and force $f$ in wrench $\wrench$ in its grasp frame at 100 Hz sampling frequency. The twist $\twist$ is derived from the relative motion of frames, while the twist derivative $\dot{\twist}$ is obtained by differentiating the twist. No intercommunication is established among Omnids and data is analyzed subsequently.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Related Work} 
A ``mocobot'' is a mobile variant of the ``cobot,'' robots designed for physical collaboration with humans, originally introduced in~\cite{colgate1996cobots}. Mocobots enhance cobots with mobility for diverse tasks. The Omnid mocobot, designed for human-multirobot collaborative manipulation, is described in~\cite{elwin2022human}. 

The work in this paper extends previous work by providing a method for discovering payload kinematic and inertial properties, building on previous work in cooperative robot manipulation and payload estimation.
\subsubsection{Cooperative Robot Manipulation}
Cooperative robot manipulation involves multiple robots working together to manipulate objects, with applications in manufacturing, construction, and hazardous environments~\cite{caccavale2016cooperative, cherubini2016collaborative, werfel2014designing, trevelyan2016robotics}. Various control architectures ranging from centralized to distributed systems, including those with no explicit communication, have been utilized for manipulation tasks~\cite{balch1998behavior, rubenstein2014programmable, rus1995moving, liu2024self}.

\begin{figure} 
\centering
$\vcenter{\hbox{\subfloat{\includegraphics[width=0.44\textwidth]{lin_omnids.PNG}}}}$
\caption{Three Omnid mocobots collaborate safely and intuitively with a human operator on a simulated plane wing assembly task.}
\label{fig:demo}
\end{figure}

%Research can be categorized into autonomous manipulation, human-single-robot collaboration, and human-multi-robot collaboration. 
Approaches like haptic feedback for leader-follower formations~\cite{sieber2015multi} and force amplification strategies~\cite{wang2016force} have been explored. Recent advancements include machine learning techniques to enhance human-robot interaction and adaptability~\cite{chi2023diffusion, zhao2023learning}. Some systems use distributed adaptive control of omnidirectional mobile bases equipped with robot arms to autonomously transport payloads~\cite{ren2020fully, carey2021collective}. Other configurations include customized robots for collaborative rigid-body manipulation~\cite{rauniyar2021mewbots} and strategies for manipulating deformable payloads~\cite{alonso2015local}. 
%However, these systems often require full knowledge of payload dynamics or specific configurations for attachment, limiting flexibility in unknown environments.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Payload Estimation}
Knowledge of payload properties, particularly the center of mass (CoM) and inertia matrix, is crucial for the dynamic performance and stability of robotic systems. Early research on payload inertia matrix estimation involved suspending payloads and measuring oscillation periods, which provided reliable results for vehicles and aircraft~\cite{miller1930accurate, woodfield1968measurement, winkler1983inertial, winkler1983parametric, heydinger1995design}. However, these techniques are impractical for robotic applications, especially in dynamic and unstructured environments.

In the field of robotics, force-torque sensors, combined with Newton-Euler equations, have become a standard tool for the estimation of inertial properties by a single robot~\cite{atkeson1986estimation}. For the case of manipulation by multiple mobile manipulators, decentralized approaches have been developed for estimating properties of the common payload~\cite{habibi2015distributed,marino2018}. %gao2022estimating}. 
%However, such methods often struggle with payloads that have complex shapes as they typically rely on simplified models and assumptions that do not account for the full range of potential payload dynamics.
In~\cite{habibi2015distributed}, the robots cooperatively estimate the centroid of the payload, but the motion is limited to the plane and mass and inertial parameters are not considered. The estimation goals of~\cite{marino2018} are closely related to those of this paper, except the algorithms described in that work do not consider the orientations of the robots' grasp frames and have only been tested in simulation.
%However, these methods model the payload dynamics through simplified assumptions that may not fully capture the characteristics of payloads with irregular geometries or complex mass distributions. This limitation can restrict their direct applicability to our research, which involves payloads that exhibit these complex features under an unstructured environment.

%Decentralized approaches have been developed to handle cooperative manipulation tasks for estimation using multi-robot systems. These methods focus on estimating the CoM and other properties by leveraging the distributed sensing capabilities of multiple robots


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Contributions}
This paper presents a methodology for using a group of mobile robots to discover properties of a rigid-body payload, including the robots' unknown relative grasp frames on the payload and the payload's mass, center of mass, and inertia matrix. The approach relies on post-processing experimental data collected without the need for  expensive and potentially fragile force-torque sensors. The method is validated experimentally on a team of three custom mocobots.
%The analysis requires data on twists, twist derivatives, and forces from wrenches at the grasp frames where the robots interface with the payload. This requirement can theoretically be fulfilled using a combination of an IMU and 3-axis force sensors, eliminating the need for advanced sensors such as force-torque sensors. This approach offers a cost-effective and accessible solution for payload estimation. No intercommunication is required between the robots during the process, as the data are analyzed post-operation. By leveraging mocobot groups, our approach offers a general and adaptable payload properties estimation framework that facilitates effortless, dynamic, and intuitive manipulation of large and heavy payloads.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Cooperative Rigid Payload Estimation Problem Formulation}
A team of $N$ robots grasps the rigid body, defining the coordinate frames $\{1\}\ldots \{N\}$ at the grasp locations. Let $T_{i_{0}i} \in SE(3)$ define the transformation matrix describing frame $\{i\}$, the current location of robot $i$'s grasp, relative to a frame $\{i_0\}$, defined as robot $i$'s ``home'' configuration. The configuration
%, which we will write using the shorthand $T_i$, 
$T_{i_{0}i}$ can be measured by encoders or other sensors on the robot, but the robot has no exteroceptive sensors to directly sense its location relative to other robots or a common world frame.

To determine the properties of the payload and their relative grasp locations, the robots cooperatively manipulate the payload. For example, each robot may attempt to drive its gripper along a periodic reference trajectory using a soft impedance controller. The combination of the reference trajectories should cause the rigid payload to move in all six degrees of freedom, while the impedance control adapts the actual robot trajectories to ensure safe manipulation forces given the unknown connections of the robots to the rigid payload. 

Each robot takes measurements at its grasp interface synchronously with the other robots during manipulation. For example, robot $i$ measures the configuration $T_{i_0i}$, the twist $\twist_i = (\omega_i,v_i) \in \real^6$ measured in $\{i\}$, its time derivative $\dot{\twist}_i$, and the wrench $\wrench_i = (m_i,f_i) \in \real^6$ measured in $\{i\}$. A complete data point for robot $i$ is defined as the tuple $\mathcal{D}_i = \{T_{i_0i}, \twist_{i},\dot{\twist}_{i}, \wrench_{i}\}$.  The set of data points collected by robot $i$ at all $Q$ timesteps is denoted $\mathcal{D}_{i*} = \{ \mathcal{D}_{iq} \; | \; q = 1 \ldots Q \}$, and the set of data points collected by all robots at timestep $q$ is denoted $\mathcal{D}_{*q} = \{ \mathcal{D}_{iq} \; | \; i = 1 \ldots N \}.$ The complete data set is denoted $\mathcal{D}_{**} = \{ \mathcal{D}_{iq} \; | \; i = 1 \ldots N, q = 1 \ldots Q\}$.

% To determine the properties of the payload and their own relative grasp locations, the robots cooperatively manipulate the payload. During manipulation, the robots periodically take measurements at the grasp interface. For example, robot $i$ measures the configuration $T_{i_{0}i}$, the twist $\twist_i$ measured in $\{i\}$, its time derivative $\dot{\twist}_i$, and the wrench $\wrench_i$ measured in $\{i\}$. A complete data point for robot $i$ is defined as the tuple $\mathcal{D}_i = \{T_{i_{0}i}, \twist_{i},\dot{\twist}_{i}, \wrench_{i}\}$. Each robot $i$ collects $P$ data points during the manipulation, $\mathcal{D}_{i1} \ldots \mathcal{D}_{iP}$, yielding a full data set $\mathcal{D}$ for all the robots, $\mathcal{D} = \{\mathcal{D}_{ij} \; | \; i = 1 \ldots N, j = 1 \ldots P\}$. The robots take data synchronously, e.g., the data points $\mathcal{D}_{1j}$ and $\mathcal{D}_{2j}$ are taken simultaneously.

The cooperative rigid payload estimation problem can be formulated as follows: given $\mathcal{D}_{**}$, determine the payload's mass $\mass$; the configuration of a frame $\{\framec\}$ at the payload's center of mass relative to each robot's grasp frame ($T_{1c}, \ldots, T_{Nc}$) such that the frame $\{\framec\}$ is aligned with principal axes of inertia of the payload; and the $3 \times 3$ positive-definite inertia matrix $\mathcal{I}$ of the payload in the frame $\{\framec\}$. This information also implies the configuration of each robot's grasp relative to each other, 
\[
T_{ij} = \begin{bmatrix}
    R_{ij} &  p_{ij } \\
    0 & 1
\end{bmatrix} \in SE(3), \; i, j \in \{1, \ldots, N\}.
\]

Payload estimation requires that the data set $\mathcal{D}_{**}$ be sufficiently rich, e.g., the manipulation must cause payload rotations that make estimation of the grasp kinematics and inertial properties well posed. Grasp twist and acceleration data $\twist_i$ and $\dot{\twist}_i$ may be obtained by using filtered encoder data, IMUs, accelerometers, or a combination, and the wrench $\wrench_i$ may be obtained by end-effector force-torque sensors, force/torque sensors at individual robot joints, or other means.

%Other things to note: data set $\mathcal{D}$ must be rich enough to solve; can use filters to get twists and twist derivatives from configuration data; may be possible to solve with only a subset of this data.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Estimation of Payload Properties Using the Omnid Mocobots}

\subsection{Omnid Mocobots and Sequential Estimation}

We perform payload estimation using the Omnid mocobots (Figure \ref{fig:omnid}), which are designed for human-robot collaborative manipulation \cite{elwin2022human}.  Each Omnid mocobot consists of a mecanum-wheel mobile base, a 3-dof Delta parallel mechanism driven by series-elastic actuators (SEAs), and a 3-dof passive gimbal wrist. In this paper, the mobile bases are stationary, and all manipulation is performed by the Delta-plus-gimbal manipulators.

The Delta mechanism and gimbal wrist of each Omnid is equipped with encoders, allowing Omnid $i$ to measure its wrist configuration $T_{i_0i}$. Since the payload is rigidly attached to the gimbal, the wrist configuration and the grasp configuration are equivalent. The twist $\twist_i$ and its derivative $\dot{\twist}_i$ are calculated by filtering encoder data. Wrenches at the wrist take the form $\wrench_i = (m_i,f_i) = (0,f_i)$, where the linear force $f_i$ is calculated based on torques measured at the SEA joints and the moment $m_i$ is zero due to the passive gimbal wrist. Data is collected at a fixed sampling rate of 100~Hz. 

\begin{figure}
\centering
$\vcenter{\hbox{\subfloat{\includegraphics[width=0.44\textwidth]{omnid_structure.png}}}}$
\caption{The structure of the Omnid mocobot.}
\label{fig:omnid}
\end{figure}

%For this experiment, the mobile base is excluded from computations and remains stationary for simplification as the delta mechanism provides sufficient motion for manipulating the object.

%For this study, we assume all robots are rigidly attached to a rigid body payload, ensuring no relative motion between the robots and the payload. The payload itself is modeled as a rigid body with constant mass and inertial properties. All measurements are assumed to be synchronized with a constant sampling rate. Particularly for the estimation of the center of mass and inertia matrix estimation, the system operates with no external forces or torques, aside from gravitational forces and forces exerted by the manipulators, acting on the payload.

%what assumptions or specific approaches are we going to use to solve the problem.

%The methodological approach used in this paper involves a structured sequence to estimate the payload properties. We begin by determining the transformation matrices $T$ between the robots' grasp frames. Next, we estimate the mass of the payload $\mass$ and calculate the location of the center of mass relative to each robot $p_{0i}$. Lastly, we compute the inertia matrix $\inertia_0$ in the payload’s reference frame and perform diagonalization to align the matrix with the payload’s principal axes of inertia.

In principle, all data $\mathcal{D}_{**}$ could be used in a single optimization to simultaneously calculate the configurations of the robot grasps relative to each other, the mass and location of the center of mass of the payload, and the inertia of the payload. In this paper, we adopt a sequenced approach, where we first estimate the grasp kinematics using only twist measurements; then estimate the mass and center of mass using the results of the kinematics estimates and wrench measurements when the payload is held stationary; and finally estimate the inertial properties using the results of the previous estimates as well as twist, acceleration, and wrench data during manipulation. This approach (a) allows us to use simple least-squares estimation and (b) requires only the data needed for the particular parameters being estimated---for example, wrench and acceleration data is not needed to estimate the robots' relative grasp frame configurations. 

% % sequential approach. allows us to use least squares for most optimizations. but is not necessarily globally optimal (define)
% does not use loop closure constraints
% each step does not need all the data; cm only needs f not full wrench
% say wrench is force f and moment m
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Grasp Kinematics}
\label{ssec:kinematics}
When robots $i$ and $j$ grasp a common rigid body, the twists $\twist_i, \twist_j$ are related by $\twist_i = [\text{Ad}_{T_{ij}}] \twist_j$, where $[\text{Ad}_{T_{ij}}] \in \real^{6 \times 6}$ is the adjoint representation of the transformation matrix $T_{ij}$ describing the configuration of the frame $\{j\}$ relative to $\{i\}$~\cite{lynch2017}. We write the complete set of twist measurements as  $\twist_{i*},\twist_{j*} \in\mathbb{R}^{6 \times P}$, i.e., each individual twist measurement $\twist_i$ forms a column of the matrix $\twist_{i*}$. Then
\begin{align}
   \twist_{i*} &= [ \text{Ad}_{T_{ij}} ] \twist_{j*},
\end{align}
or, in expanded form, 
\begin{align}
    \begin{bmatrix}
        \omega_{i*} \\ v_{i*}
    \end{bmatrix}
    & =
    \begin{bmatrix}
        R_{ij} & 0 \\
        [ p_{ij} ] R_{ij} & R_{ij}
    \end{bmatrix}
    \begin{bmatrix}
        \omega_{j*} \\
        v_{j*}
    \end{bmatrix},
\label{eqn:twist}
\end{align}
where $[p_{ij}] \in so(3)$ is the skew-symmetric representation of $p_{ij} \in \real^3$.
This equation is the basis for estimating the rotation matrix $R_{ij}$ and the position vector $p_{ij}$ between the two robots. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Rotation Matrix}
Let $\omega_{i*}, \omega_{j*} \in \mathbb{R}^{3 \times P}$ be the angular velocities of the twists measured at each grasp. The relationship between the two sets is
\begin{equation}
    \omega_{i*} = R_{ij} \omega_{j*} \label{eq:rotmat}
.\end{equation}

The problem is to estimate a rotation matrix $\hat{R}_{ij}$ that best fits the data in Equation~\eqref{eq:rotmat} by solving the following least-squares problem based on the Frobenius norm:
\begin{equation}
    \hat{R}_{ij} = \underset{R_{ij} \in SO(3)}{\operatorname{argmin}}  \|R_{ij} \omega_{j*} - \omega_{i*}\| _F ^2.
    \label{eqn:rotation}
\end{equation}
This problem is known as Wahba's problem, which has been solved by the Kabsch-Umeyama algorithm~\cite{kabsch1976,kabsch1978,umeyama1991}.
Defining the matrix $X = \omega_{j*} \omega_{i*}^\intercal$, utilizing SVD decomposition to get $X = U \Sigma V^\intercal$, and defining $S = \operatorname{diag}(1,1,\operatorname{det}(VU^\intercal))$, the solution to the optimization problem is 
\begin{equation}
    \hat{R}_{ij} = VSU^\intercal.
    \label{eqn:rotation2}
\end{equation}
At least three pairs of angular velocities are required to uniquely determine the rotation matrix $R_{ij}$. We assume the measurement data are sufficiently rich to ensure that $X$ is full rank.

%\textbf{Here say something about minimum number of angular velocities needed for a solution, and what conditions they need to satisfy, and prove why (e.g., the rank of the matrix $X$).}



%Angular velocity vectors in $\omega_{i*}$ and $\omega_{j*}$ must be linearly independent and non-colinear to ensure the solution spans $\real^3$ so that matrix $X$ can achieve a full rank of $3$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \textbf{Not well formatted proof}
% \begin{equation}
% \begin{gathered}
%     X = \omega_{j*} \omega_{i*}^\intercal \\
%     \omega_{i*} = R_{ij} \omega_{j*} \\
%     X = \omega_{j*} (\omega_{i*}^\intercal R_{ij}^\intercal) \\
%     X = (\omega_{j*} \omega_{j*}^\intercal) R_{ij}^\intercal
% \end{gathered}
% \end{equation}

% $R_{ij}$ has rank 3. rank($\omega_{j*} \omega_{j*}^\intercal$) = rank($\omega_{j*}$) = 3. So X has rank 3.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Position Vector}
Let $v_{i*}, v_{j*} \in \mathbb{R}^{3 \times P}$ be the linear velocities of the twists measured at each grasp. By Equation~\eqref{eqn:twist}, the linear velocities satisfy
\begin{equation}
    v_{i*} = [p_{ij}] R_{ij} \omega_{j*} + R_{ij} v_{j*}.
    \label{eq:linear}
\end{equation}
Due to the skew-symmetric property $[\omega]p=-[p]\omega$, Equation~\eqref{eq:linear} can be rearranged to
\begin{equation}
    v_{i*} = - [ R_{ij} \omega_{j*} ] p_{ij} + R_{ij} v_{j*}.
\end{equation}
Plugging in the estimate $\hat{R}_{ij}$, the estimate $\hat{p}_{ij}$ is found by solving the least-squares problem
\begin{equation}
\hat{p}_{ij} = \underset{p_{ij}}{\operatorname{argmin}} \;  \|
    [ \hat{R}_{ij} \omega_{j*} ] p_{ij} - (\hat{R}_{ij} v_{j*} - v_{i*})\|_2,
    \label{eq:p-solution}
\end{equation}
provided $[\hat{R}_{ij}\omega_{j*}]$ is full rank.

%\textbf{Are there any requirements on the twists to find a solution that were not covered above?}

%For the twists set, angular velocities and linear velocities should avoid constant, zero, or aligned to avoid rank deficiency for estimation.

The solution $\hat{T}_{ij} = (\hat{R}_{ij},\hat{p}_{ij})$, via Equations~\eqref{eqn:rotation} and \eqref{eq:p-solution}, depends only on pairwise robot data. To obtain a complete and consistent representation of the robots' relative grasp frames, $N-1$ such solutions are needed, e.g., $\hat{T}_{12}, \hat{T}_{13}, \ldots, \hat{T}_{1N}$. Then the configuration of any frame $\{i\}$ relative to another frame $\{j\}$ may be calculated as $\hat{T}_{ij} = \hat{T}^{-1}_{1i}\hat{T}_{1j}$. While this method permits efficient linear least-squares computation, it does not simultaneously take into account all combinations of robots' twist data nor loop-closure constraints among three or more robots, e.g., $T_{ij}T_{jk}T_{ki} = I$. Such constraints allow squeezing more information out of the collected data at the cost of greater computational complexity and nonlinear optimization.

We employed an iterative gradient-based nonlinear optimization to incorporate all the data and loop constraints to further refine the $\hat{T}_{ij}$ estimates from the original linear least-squares solutions. The optimization minimizes the weighted sum of squared errors from data from all pairwise combinations of grasping frames and all closed loops. Our implementation uses the scipy.optimize library and the Broyden-Fletcher-Goldfarb-Shanno method for estimating gradients~\cite{nocedal2006large}, but other nonlinear optimization methods incorporating combinatorial loop-closure constraints could also be employed~\cite{thrun2005probabilistic, lu1997globally}.

\begin{comment}
We implement a loop closure constraint for the rotation matrices and position vectors using the $scipy.optimize$ library with the Broyden–Fletcher–Goldfarb–Shanno (BFGS) method~\cite{nocedal2006large} to ensure global consistency of the solutions. 

To form a rotation matrix loop, the multiplication of each loop requires to equal $I_3$, a $3\times3$ identity matrix. The number of robots has to meet $N\geq3$ for a minimal loop. Let $\mathcal{E}$ be the set of all robot pairs with observed relative rotations $R_{ij}^{\text{obs}}$ derived from~\eqref{eqn:rotation2}, and $\mathcal{L} = \{l_1, l_2, \ldots, l_L\}$ be the set of all loops in the robot network, including sub-loops derived from the general loop. For each loop, $l_k$ is defined by an ordered sequence of robot indices forming a closed path. The optimization problem is structured to minimize the discrepancy between the observed and estimated rotations while ensuring that the product of rotations in each loop equals the identity matrix, reflecting the geometric consistency across the network. The objective function targeting at $R_{ij}$ is defined as follows:
%For each loop $l_k$, the sequence of rotations along the loop is $\{R_{mn}^k, R_{no}^k, \ldots,  R_{oN}^k\}$
\begin{equation}
\begin{aligned}
    \operatorname{argmin}\limits_{R_{ij}} (\text{J}) = 
    &  w_1 \sum_{(i,j) \in \mathcal{E}}  \left\| R_{ij}^{\text{obs}} - R_{ij} \right\|_F^2 \\
    + & w_2 \sum_{l_k \in \mathcal{L}}\left\| \left ( \prod_{(i,j) \in l_k} R_{ij} \right) - I_{3} \right\|_F^2.
\end{aligned}
\end{equation}

Here, $w_1$ and $w_2$ are weights that balance the emphasis between fitting the observed rotations and ensuring loop closure. To ensure that the optimized result $R_{ij}$ remains elements of SO(3), we enforce constraints by parameterizing the rotation matrices as rotation vectors $r_{ij}$, which serve as input for optimization. During the optimization process, we optimize over the rotation vectors while converting these vectors back into rotation matrices in each iteration to evaluate the cost function $\text{J}$. This approach inherently ensures the SO(3) constraints through iteration, as the exponential map guarantees valid rotations.
\end{comment}

\begin{comment}
For the rotation matrix loop, the multiplication is required to equal to $I_3$, a $3\times3$ identity matrix. With the objective of minimizing deviation from the initial estimates while achieving alignment, the objective function can be written as
\begin{equation}
\begin{aligned}
    \text{minimize} (\text{J}) = 
    &  w_1 \sum_{i=1}^N  \left\| R_{i,i+1}^{\text{obs}} - R_{i,i+1} \right\|_F^2 \\
    + & w_2 \left\| \left( \prod_{i=1}^N R_{i,i+1} \right) - I_{3} \right\|_F^2
\end{aligned}
\end{equation}
where $R_{i,i+1}$ represemnts the optimization target, and $R_{i,i+1}^{\text{obs}}$ is the pairwise solution derived from~\eqref{eqn:rotation2}, serving as the initial guess. Weights $w_1$ and $w_2$ balance the optimization tolerance.
To clarify, $R_{N,N+1}$ denotes $R_{N,1}$ to establish the loop constraint. For instance, in a 3-robot system, $R_{i,i+1}$ corresponds to $R_{12}$, $R_{23}$, and $R_{31}$. 
\end{comment}

\begin{comment}
    
Similarly, under the condition that the addition of all position vectors in the same reference frame $\{\frames\}$ equals $0$, the objective function of the position vector loop function is expressed as
\begin{equation}
\begin{aligned}
    \operatorname{argmin}\limits_{p_{ij}} (\text{J}) = 
    &  w_1 \sum_{(i,j) \in \mathcal{E}}  \left\| p_{ij}^{\text{obs}} - p_{ij} \right\|^2 \\
    + & w_2 \sum_{l_k \in \mathcal{L}}\left\| \sum_{(i,j) \in l_k} R_{si}p_{ij} \right\|^2
\end{aligned}
\end{equation}
where the optimization targets are $p_{ij}$, and $\{\frames\} \in \{1\}\ldots \{N\}$.

In the context of the rotation matrix and position vector, it has been performed and validated through the Omnid as a 3-robot system. However, as the number of pairwise interactions increases on the order of $\mathcal{O}(N^2)$ and the number of loops will achieve $\sum_{k=3}^{N} \binom{N}{k}$, the computational cost will increase significantly. Also, when $N$ grows, the first summation in the objective function, the $w_1$ term, could grow significantly, potentially overshadowing the loop closure term. The approach could therefore be transformed as a distributed optimization problem~\cite{shorinwa2024distributed}. By leveraging frameworks such as those discussed in~\cite{oh2013formation} and~\cite{tron2009distributed}, the multi-robot system can be effectively modeled as a graph-based problem where nodes represent robots and edges represent relative transformations. This structure facilitates distributed computations and consensus, reducing the overall computational load while enhancing scalability and robustness in large-scale multi-robot systems.
\end{comment}

%Therefore, the loop set $\{\mathcal{L}\}$ could be strategically selected to optimize computational efficiency without compromising consistency integrity. The selection criteria may include factors such as the loops' size, the number of shared connections within different loops, and their distribution across the network. Also, when $N$ grows, the first summation in the objective function, the $w_1$ term, could grow significantly, potentially overshadowing the loop closure term. To address this, weights could be dynamically adjusted based on the network size and system complexity.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Mass and Center of Mass (CoM)}
\label{ssec:com}
%At each grasp frame, robot $i$ is able to measure the force component $f_i$ of wrench $\wrench_i$. The transformation matrix $T_{ij} = (R_{ij}, p_{ij})$ is known for all $i, j \in {1, \ldots, N}$ from the grasp kinematics estimation. No external forces are applied to the system and the entire system remains stationary during the measurement.

The mass and center of mass are estimated using the grasp kinematics solution and a set of static wrench measurements.
A common reference frame $\{\frames\} \in \{\{1\}, \ldots , \{N\}\}$ is selected for the estimation process. We also define a frame $\{\frames_0\}$ coincident with $\{\frames\}$ but oriented such that its $\hat{z}$-axis is opposite the gravity vector $\grav \in \real^3$. The center of mass of the payload is located at the origin of a to-be-estimated frame $\{\framec\}$.

The force and moment static equilibrium conditions are
\begin{align}
\mass \grav &= - \sum\limits_{i=1}^{N} R_{s_0i} f_i
\label{eq:mass} \\
[p_{sc}]  ({R_{ss_0}} \mass \grav) &=- \sum\limits_{i=1}^{N} [p_{si}] (R_{si}f_i),
\label{eq:com}
\end{align}
where $\mass$ is the mass of the payload, $f_i$ is the measured force component of $\wrench_i$, and $p_{sc}$ and $p_{si}$ represent the origin of $\{\framec\}$ and $\{i\}$ in $\{\frames\}$ coordinates, respectively. %It is important to note that in this static analysis, force $f_i$ is treated as a vector $\in \mathbb{R}^{3 \times 1}$.

To ensure static equilibrium, the payload must be supported by three or more robots, as two Omnids cannot resist a moment about an axis through the two grasp frames. Under this condition, the mass $\mass$ can be estimated using Equation~\eqref{eq:mass} and one or more static measurements by the robots, while $p_{sc}$ can be estimated using Equation~\eqref{eq:com} and two or more static measurements, provided the orientations of the payload during measurement differ by rotation about an axis not aligned with the gravity vector $\grav$.

Since the robots rigidly grasp the payload, $p_{sc}$, $p_{si}$, and $R_{si}$ are constant, and only $p_{sc}$ remains unknown. Given $q = 1 \ldots Q$ measurements by the robots, we define the scalars 
\begin{equation}
A_q = [0,0,1] \grav, \quad
b_q = - [0,0,1] \left(\sum_{i=1}^{N} R_{s_0i}^q f_i^q\right) 
\end{equation}
and the vectors
\begin{equation}
    A = \begin{bmatrix}
        A_1 \\
        A_2 \\
        \vdots \\
        A_Q
    \end{bmatrix} \in \mathbb{R}^{Q \times 1}, \quad
    b = \begin{bmatrix}
        b_1 \\
        b_2 \\
        \vdots \\
        b_Q
    \end{bmatrix} \in \mathbb{R}^{Q \times 1}.
\end{equation}
Plugging this data into the $\hat{z}$-component of Equation~\eqref{eq:mass}, we get
\begin{equation}
A\mass = b,
\end{equation}
which can be solved for the mass estimate $\hat{\mass}$ using least squares.
%When constructing A and b for the mass estimation, the vectors are converted to a scalar to ignore the noise from the $\hat{x}$-axis and $\hat{y}$-axis.

Similarly, the data can be plugged into Equation~\eqref{eq:com} to estimate the center-of-mass location $p_{sc} \in \real^3$: 
\begin{equation}
A_q = [{R_{ss_0}^q}  \hat{\mass} \grav] \in \real^{3 \times 3}, \quad
b_q = \sum_{i=1}^{N} [p_{si}] (R_{si}^q f_i^q) \in \real^{3 \times 1},
\end{equation}
\begin{equation}
    A = \begin{bmatrix}
        A_1 \\
        A_2 \\
        \vdots \\
        A_Q
    \end{bmatrix} \in \mathbb{R}^{3Q \times 3}, \quad
    b = \begin{bmatrix}
        b_1 \\
        b_2 \\
        \vdots \\
        b_Q
    \end{bmatrix} \in \mathbb{R}^{3Q \times 1},
\end{equation}
\begin{equation}
Ap_{sc} = b,
\end{equation}
which can be solved for the estimate $\hat{p}_{sc} \in \real^3$ using least squares.

\begin{comment}
\begin{equation}
% \mass &= - \frac{1}{\grav}\sum\limits_{i=1}^{N} R_{s_0i} f_i \\ 
% [{R_{ss_0}}  \grav] \mass p_{sc} &= \sum\limits_{i=1}^{N} [p_{si}] (R_{si}f_i).
\hat{\mass} = \operatorname{argmin}\limits_{\mass} \sum_{q=1}^{Q} \left\| \mass \grav + \sum_{i=1}^{N} R_{s_0i}^q f_i^q \right\|^2
\end{equation}
and
\begin{equation}
\hat{p}_{sc} = \operatorname{argmin}\limits_{p_{sc}} \sum_{q=1}^{Q} \left\| [{R_{ss_0}^q}  \hat{\mass} \grav]  p_{sc} - \sum_{i=1}^{N} [p_{si}] (R_{si}^q f_i^q) \right\|^2 
\end{equation}
so that the problem can be solved through least-squares optimization.
\end{comment}

%In the force balance, rotation matrix $R_{s_0i}$ rotates all force measurement $f_i$ into the common home frame $\{\frames_0\}$, ensuring all forces are evaluated in a uniform reference system. Similarly, in the moment balance, rotation matrix $R_{ss_0}$ and $R_{si}$ facilitate the alignment of forces into frame $\{\frames\}$. The notation $[ \cdot ]$ indicates the skew-symmetric representation for computing moments via cross products.



\begin{comment}
\subsubsection{Dynamic CoM Estimation using Translational Dynamics}
The dynamic approach of CoM measurement is derived from the translational dynamics of rigid bodies from Newton-Euler equations. The equation of wrench $\wrench_0$ at the CoM frame $\{0\}$ can be described as
\begin{equation}
    \mathcal{F}_0 = 
    \begin{bmatrix} 
        m_0 \\ f_0 
    \end{bmatrix}
    =
    \begin{bmatrix}
        \mathcal{I}_0 & 0 \\
        0 & \mass I_3
    \end{bmatrix}
    \begin{bmatrix}
        \alpha_0 \\
        a_0
    \end{bmatrix}
    +
    \begin{bmatrix}
        [\omega_0] \mathcal{I}_0 \omega_0 \\
        0
    \end{bmatrix}
\label{eq:wrench eqn}
\end{equation}
where $m_0$ and $f_0$ are the total moments and forces acting about the CoM. Inertia matrix $\mathcal{I}_0 \in \mathbb{R}^{3 \times 3}$ locates at the CoM and $I_3$ is the $3 \times 3$ identity matrix. Variables $\alpha_0$, $a_0$, and $\omega_0$ are the angular acceleration, linear acceleration, and angular velocity of the CoM in frame $\{0\}$.

In this relationship, the translational part is the interested part and can be extracted as
\begin{equation}
    f_0 = \mass I_3 a_0.
\end{equation}

Since the orientation of the principal axes is unknown at this point, the net force and acceleration at the CoM at sampling stamp $j$ can be described in frame $\{$s$\}$ instead of frame $\{0\}$ as
\begin{equation}
    a_{0k}^s = \frac{1}{\mass}(\sum\limits_{i=1}^{N}R_{si}f_{ik}+R_{ss_0}f_g).
    \label{eqn:com1}
\end{equation}

According to the relative acceleration equation which defines the acceleration relationship in different frames, the acceleration $a_{0j}^s$ can be written as
\begin{equation}
    a_{0k}^s = a_{sk} + [\alpha_{sk}] p_{s0} + [\omega_{sk}]^2 p_{s0}.
    \label{eqn:com2}
\end{equation}

Combining Equation~\eqref{eqn:com1} and~\eqref{eqn:com2} gives us
\begin{equation}
    [\alpha_{sk}] p_{s0} + [\omega_{sk}]^2 p_{s0} = \frac{1}{\mass}(\sum\limits_{i=1}^{N}R_{si}f_{ik}) - a_{sk}
.\end{equation}

In this relationship, the computation of the interested item $p_{s0}$ is out of the linear combination, therefore a regression matrix can be formed for least-square minimization as
\begin{equation}
A_{\text{reg}}_k = 
\begin{bmatrix}
 -w_y^2 - w_z^2 & -\alpha_z + w_x w_y & \alpha_y + w_x w_z \\
 \alpha_z + w_y^2 & -w_x^2 - w_z^2 & -\alpha_x + w_y w_z \\
 -\alpha_y + w_x w_z & \alpha_x + w_y w_z & -w_x^2 + w_y^2
\end{bmatrix}_{sk}
\end{equation}
so that
\begin{equation}
A_{\text{reg}}_k p_{s0} = \frac{1}{\mass}(\sum\limits_{i=1}^{N}R_{si}f_{ik}+R_{ss_0}f_g) - a_{sk}
\end{equation}

At this point, the mass of the object and the location of the CoM can be determined from any robot grasp frame.
\end{comment}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Inertia Matrix}
\label{ssec:inertia}
%With the knowledge of the transformation matrix $T_{ij}$ for all $i, j \in {1, \ldots, N}$, CoM location $p_{0i}$ related to each grasp frame, angular velocity $\omega_i$ from twist $\twist_i$, angular acceleration $\alpha_i$ from twist derivative $\dot{\twist}_i$, and force $f_i$ from wrench $\wrench_i$, the inertia matrix can be determined by dynamically manipulating the payload. No external forces are applied except for the gravitational force and force exerted by robots.

We define a frame $\{\frameb\}$ at the center of mass $\hat{p}_{sc}$ and aligned with $\{\frames\}$. After estimating the inertia matrix in $\{\frameb\}$, we identify the principal axes of inertia in $\{\frameb\}$, and then define a final center-of-mass frame $\{\framec\}$ with axes aligned with the principal axes of inertia. 

The Newton-Euler dynamics of a rotating rigid body are 
\begin{equation}
    m_{b} = \mathcal{I}_b \alpha_{b} +[\omega_{b}] \mathcal{I}_b \omega_{b},
    \label{eqn:inertia1}
\end{equation}
%\begin{equation}
%    m_{b*} = \mathcal{I}_b \alpha_{b*} +[\omega_{b*}] \mathcal{I}_b \omega_{b*}
%    \label{eqn:inertia1}
%\end{equation}
where $m_b$ is the moment acting on the body, $\mathcal{I}_b \in \mathbb{R}^{3 \times 3}$ is the positive-definite inertia matrix of the payload, $\omega_b$ is the angular velocity, and $\alpha_b$ is the angular acceleration, all expressed in the frame $\{\frameb\}$. For $N$ robots supporting the payload via linear forces $f_i$ at the gimbals, the moment can be expressed as 
\begin{equation}
    m_{b} = \sum_{i=1}^{N} [p_{bi}] (R_{bi} f_{i}).
    \label{eqn:inertia2}
\end{equation}

Equations~\eqref{eqn:inertia1} and ~\eqref{eqn:inertia2} can be reorganized to solve for $\inertia_b$ using linear least squares. 
Since $\inertia_b$ is symmetric, it contains six unique elements: 
$\inertia_{xx}$, $\inertia_{xy}$, $\inertia_{xz}$, $\inertia_{yy}$, $\inertia_{yz}$, and $\inertia_{zz}$. We define
\begin{equation}
    \inertia_{\operatorname{reg}} = [\inertia_{xx}, \inertia_{xy}, \inertia_{xz}, \inertia_{yy}, \inertia_{yz}, \inertia_{zz}]^\intercal .
\end{equation}

\begin{comment}
\begin{equation}
    \mathcal{F}_c = 
    \begin{bmatrix} 
        m_c \\ f_c 
    \end{bmatrix}
    =
    \begin{bmatrix}
        \mathcal{I}_c & 0 \\
        0 & \mass I_3
    \end{bmatrix}
    \begin{bmatrix}
        \alpha_c \\
        a_c
    \end{bmatrix}
    +
    \begin{bmatrix}
        [\omega_c] \mathcal{I}_c \omega_c \\
        0
    \end{bmatrix}
\label{eq:wrench eqn}
\end{equation}

\begin{equation}
    m_{c} = \mathcal{I}_c \alpha_{c} +[\omega_{c}] \mathcal{I}_c \omega_{c},
    \label{eqn:inertia}
\end{equation}
\end{comment}
\begin{comment}
From the rotational dynamics of rigid bodies, $\mathcal{I}_c$ is the component of interest. The measurement at each sampling point can be extracted from Equation~\eqref{eqn:inertia} as
\begin{equation}
    m_{c*} = \mathcal{I}_c \alpha_{c*} +[\omega_{c*}] \mathcal{I}_c \omega_{c*}
    \label{eqn:inertia1}
\end{equation}
where the total moment is equivalent to
\begin{equation}
    m_{c*} = \sum_{i=1}^{N} [p_{ci}] (R_{ci} f_{i*}).
    \label{eqn:inertia2}
\end{equation}
Since the orientation of frame $\{c\}$ is unknown, the inertia matrix can be determined at the CoM using the orientation of a robot grasp frame $\{\frames\} \in \{1\}\ldots \{N\}$. The orientation of the principal axes can be transformed afterward. Equation~\eqref{eqn:inertia1} and~\eqref{eqn:inertia2} can be written as:
\begin{equation}
    m_{c*}^s = \mathcal{I}_s \alpha_{s*} + [\omega_{s*}] \mathcal{I}_s \omega_{s*}
\end{equation}
and
\begin{equation}
    m_{c*}^s = \sum_{i=1}^{N} [p_{ci}] (R_{si} f_{i*})
\end{equation}
where $\mathcal{I}_s$ is the inertia matrix in the orientation of $\{s\}$ at the CoM.
\end{comment}
At timestep $q$, we construct the matrices $A_q, B_q \in \real^{3 \times 6}$ (based on the angular acceleration $\alpha_b = (\alpha_x, \alpha_y, \alpha_z)$ and angular velocity $\omega_b$ measured in $\{\frames\}$) and the vector $y_q$ based on force measurements at each of the $N$ robots:
\begin{equation}
    A_q = 
    \begin{bmatrix}
        \alpha_{x} & \alpha_{y} & \alpha_{z} & 0 & 0 & 0 \\
        0 & \alpha_{x} & 0 & \alpha_{y} & \alpha_{z} & 0 \\
        0 & 0 & \alpha_{x} & 0 & \alpha_{y} & \alpha_{z} 
    \end{bmatrix},
\end{equation}
%\begin{equation}
    \begin{align}  
        B_q = 
        &\left[
        \begin{array}{ccc}
        0 & -\omega_{x}\omega_{z} & \omega_{x}\omega_{y} \\
        \omega_{x}\omega_{z} & \omega_{y}\omega_{z} & \omega_{z}^2 - \omega_{x}^2 \\
        -\omega_{x}\omega_{y} & -\omega_{y}^2 + \omega_{x}^2 & -\omega_{y}\omega_{z}
        \end{array}
        \right. \\[10pt]
        & \quad\quad\quad \left.
        \begin{array}{ccc}
        -\omega_{y}\omega_{z} & -\omega_{z}^2 + \omega_{y}^2 & \omega_{y}\omega_{z} \\
        0 & -\omega_{x}\omega_{y} & -\omega_{x}\omega_{z} \\
        \omega_{x}\omega_{y} & \omega_{x}\omega_{z} & 0
        \end{array}
        \right]_, \nonumber
    \end{align}
%\end{equation}
\begin{equation}
    y_q = \sum_{i=1}^{N} [\hat{p}_{bi}](\hat{R}_{bi}f_{iq}).
\end{equation}
Combining Equations~\eqref{eqn:inertia1} and~\eqref{eqn:inertia2}, the dynamics can be written 
\begin{equation}
    (A_q + B_q) \inertia_{\operatorname{reg}} = y_q. 
\end{equation}
%where $\inertia_{\operatorname{reg}} \in \real^{6 \times 1}$ isolates the independent variables from $\inertia_b$. Matrix $A_k$ and $B_k \in \real^{6 \times 3}$ include angular acceleration term and angular velocity term contributing to the equation in frame $\{\frameb\}$ at each sampling time.
For $Q$ measurements, we define
\begin{equation}
    X = \begin{bmatrix}
        A_1 + B_1 \\
        A_2 + B_2 \\
        \vdots \\
        A_Q + B_Q
    \end{bmatrix} \in \mathbb{R}^{3Q \times 6}, \quad
    y = \begin{bmatrix}
        y_1 \\
        y_2 \\
        \vdots \\
        y_Q
    \end{bmatrix} \in \mathbb{R}^{3Q \times 1},
\end{equation}
yielding 
\begin{equation}
    X \inertia_{\operatorname{reg}} = y,
\end{equation}
which $\hat{\inertia}_{\operatorname{reg}}$ solves in a least-squares sense. The elements of $\hat{\inertia}_{\operatorname{reg}}$ form the entries of the estimated inertia matrix  $\hat{\inertia}_b$.\footnote{If noisy data causes the least-squares estimate to produce an $\hat{\inertia}_b$ with a negative eigenvalue, the inertia estimate can either be discarded or projected to the space of positive semidefinite matrices by performing an eigenvalue decomposition and replacing any negative eigenvalue with a zero eigenvalue.} 
\begin{comment}
Following the implementation of least-square minimization, $\inertia_{\operatorname{reg}}$ is rearranged back into $\inertia_b$. To ensure the $\inertia_b$ remains a positive-definite matrix after the matrix reconstruction, a post-adjustment could be made by modifying the eigenvalues of $\inertia_b$. First, we take an eigenvalue decomposition as:
\begin{equation}
    \inertia_b = Q \Lambda Q^{-1}
\end{equation}
where $Q$ is the square matrix whose $i$th column is the eigenvector $q_i$ of $\inertia_b$, and $\Lambda$ is the diagonal matrix whose diagonal elements are the eigenvalues $\Lambda_{ii} = \lambda_i$. When a negative value occurs in $\Lambda_{ii}$, we replace it with a small positive value, such as $\Lambda_{ii}' = 10^{-8}$, the matrix can be reconstructed as:
\begin{equation}
    \inertia_b' = Q \Lambda' Q^{-1}
\end{equation}
Here, we can ensure $\inertia_b'$ is a positive-definitive matrix.
\end{comment}

Let $R_{bc} = [r_1, r_2, r_3]$, where $r_i$ is the $i$th eigenvector of $\hat{\inertia}_b$ and $\{\framec\}$ is a frame coincident with $\{\frameb\}$ with axes aligned with the principal axes of inertia. Then the estimated diagonal inertia matrix in $\{\framec\}$ is 
\begin{equation}
    \hat{\inertia}_c = R_{bc}^\intercal \hat{\inertia}_b R_{bc}
.\end{equation}

\begin{comment}
    
an inertia matrix $\inertia_c$ in a frame aligned with the principal axes of inertia
To find the orientation $R_{bc}$ of a $\{\framec\}$ aligned with the principal axes of inertia, we use the matrix diagonalization
\begin{equation}
    \inertia_b = R_{bc} \Theta R_{bc}^{-1}
\end{equation}
where rotation matrix $R_{bc} = [r_1,r_2,r_3]$, $r_i$ is the $i$th eigenvector of $\inertia_b'$. The inertia matrix $\inertia_c$ represented in frame $\{\framec\}$ can be given as 
\begin{equation}
    \inertia_c = R_{bc}^\intercal \inertia_b R_{bc}
.\end{equation}

Additionally, to describe an inertia matrix $\inertia_d$ about a frame aligned with $\{\framec\}$ but positioned at $d = (d_x, d_y, d_z)$ in $\{\framec\}$, the relationship can be expressed through the parallel axis theorem~\cite{lynch2017} by
\begin{equation}
    \inertia_d = \inertia_c + \mass(d^\intercal d I_3 - d d^\intercal)
\end{equation}
where $\mass$ is the mass of the object and $I_3$ is the $3 \times 3$ identity matrix.

At this point, with $p_{sc}$ from the center of mass estimation and $R_{bc}$ from the inertia matrix estimation, along with $R_{sb} = I$, the transformation matrix $T_{sc}$ could be constructed.
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Experimental Implementation}
%We validated the payload estimation algorithms both with a MuJoCo simulation and three Omnid mocobots.
%For the payload properties estimation, all approaches addressed in this paper have been verified through simulation using MuJoCo on a simplified model. Hardware implementation is performed using the Omnid mocobots with a structural frame payload.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experimental Configuration}
The payload used in the experimental validation is a frame made from ready-tube aluminum extrusion. The payload is attached to the Omnid gimbal wrists, and the attachments remain unchanged during experiments. The overall setup is shown in Figure~\ref{fig:frame}. The Omnid grasp frames are denoted $\{1\}$, $\{2\}$, and $\{3\}$. 
%Frame $\{c\}$ originates at the center of the mass of the payload, aligned with principal axes of inertia. 
Frame $\{1\}$ is selected as the reference frame $\{\frames\}$.

Each 6-dof manipulator consists of a 3-dof Delta mechanism and a 3-dof passive gimbal joint (Figure~\ref{fig:delta frame}). When the payload is rigidly attached, the top of the gimbal wrist is considered part of the payload. Accordingly, the grasp frame $\{i\}$ is positioned at the center of the gimbal wrist. 


\begin{figure}
    \vspace{2pt}
    \centering
    \includegraphics[width=0.47\textwidth]{system_frame.jpg}
    \caption{Frame definition of the robot-payload system for experiments. Frame $\{1\}$ is chosen as the reference frame $\{\frames\}$. The axes of the frames are visually differentiated by colors with red corresponding to the $x$-axis, green to the $y$-axis, and blue to the $z$-axis.}
    \label{fig:frame}
\end{figure}

The ground truth values of the transformation matrices, mass, center of mass, and inertia matrix for experimental validation were derived from CAD and are summarized in Table~\ref{tab:GT}. Rotation matrices are summarized in the axis-angle (exponential coordinates) representation $\omega \beta \in \real^3$, where $\omega$ is the unit rotation axis and $\beta$ is the angle of rotation, expressed in this paper in degrees.

\begin{table}[t]%[H]
    \vspace{6pt}
    \centering
    \renewcommand{\arraystretch}{1.8}
    \setlength{\tabcolsep}{5pt}
    \resizebox{0.48\textwidth}{!}{
    \begin{tabular}{|>{\centering\arraybackslash}p{0.16\textwidth}|>{\centering\arraybackslash}c|>{\centering\arraybackslash}c|>{\centering\arraybackslash}c|}
        \hline
        \multirow{2}{*}{\shortstack{\textbf{Rotation Matrix in}\\\textbf{Axis Angle (deg)}}} 
        & $R_{12}$ & $R_{23}$ & $R_{31}$ \\
        & $(0,0,0)$ & $(0,0,90)$ & $(0,0,-90)$ \\
        \hline
        \multirow{2}{*}{\shortstack{\textbf{Position}\\\textbf{Vector (m)}}} 
        & $p_{12}$ & $p_{23}$ & $p_{31}$ \\
        & $(0.647, 0.533, 0)$ & $(0.457, -0.838, 0)$ & $(0.305, 1.105, 0)$ \\
        \hline
        \multirow{2}{*}{\shortstack{\textbf{Mass (kg), Center of}\\\textbf{Mass (m), and}\\\textbf{Principal Axes (deg)}}} 
        &\textbf{$\mass$} & $p_{1c}$ & $R_{1c}$ \\
        & $11.412$ & $(0.553, 0.172, 0.072)$ & $(0.001, 0.010, -95.016)$ \\
        \hline
        \multirow{2}{*}{\shortstack{\textbf{Inertia Matrix}\\\textbf{(kg$ \cdot$m$^2$)}}} 
        & \textbf{$\inertia_{xx}$} & \textbf{$\inertia_{yy}$} & \textbf{$\inertia_{zz}$} \\
        & $2.258$ & $3.448$ & $5.698$ \\
        \hline
    \end{tabular}
    }
    \caption{Ground truth values of the experimental configuration.}
    \label{tab:GT}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Data Processing}
\begin{figure}
    \centering
    \includegraphics[width=0.45\textwidth]{delta_frame.png}
    \caption{Frame $\{i\}$ of the 6-dof manipulator of Omnid $i$ is positioned at the center of the gimbal wrist.}
    \label{fig:delta frame}
\end{figure}

Let $\theta = (\theta_1, \theta_2, \theta_3)$ represent the actuated proximal joint angles of the Delta mechanism and $\phi = (\phi_x, \phi_y, \phi_z)$ represent the angles of the gimbal wrist, all measured by encoders. The transformation matrix $T_{i_0 i}$ can be derived through forward kinematics as
\begin{equation}
    T_{i_0 i}(\theta,\phi) = \begin{bmatrix}
                    g(\phi) & h(\theta) \\
                    0 & 1
                \end{bmatrix}
.\end{equation}
The twist $\twist_i = (\omega_i,v_i)$ is calculated as
\begin{equation}
    T_{i_0i}^{-1} \dot{T}_{i_0i}  = [\twist_i] = 
    \begin{bmatrix}
        [\omega_i] & v_i \\
        0 & 0
    \end{bmatrix} \in se(3).
\end{equation}
The wrench at $\{i\}$ is $\wrench_i = (0, f_i)$, where $f_i = (\partial h/\partial \theta)^{-\intercal} \tau_i$ and $\tau_i$ is the Delta's SEA joint torque vector. 

The derivative $\dot{T}_{i_0i}$ and the twist derivative $\dot{\twist}_i$ are calculated using central differencing post-processing of the $100$~Hz estimates of $T_{i_0i}$ and $\twist_i$, respectively. To smooth the data and reduce the effect of amplification of encoder quantization in this numerical differencing, we apply a fourth-order Butterworth low-pass filter to the encoder data prior to calculating the $T_{i_0i}$ estimates. The same filter is applied to smooth the SEA torque data. 

%where the time derivative $T_{i_0 i}$ is computed using the central-difference method, adhering to the system's constant sampling rate of 100 Hz. The twist derivative $\dot{\twist}$ is also calculated accordingly for the system analysis.

\begin{comment}
Let $\theta\in\real^3$ represent the proximal joint angles of the delta mechanism as measured by the encoders. The delta's forward kinematics yields
\begin{equation}
    T_{\text{base,delta}} = f(\theta)
.\end{equation}
Let $\phi \in \real^3$ be the gimbal joint angles, with forward kinematics
\begin{equation}
    T_{\text{delta,gimbal}} = g(\phi)
.\end{equation}

Combining three transformation matrices, we can construct $T_{i_0 i}$ as:
\begin{equation}
    T_{\text{gimbal0,gimbal}} = T_{\text{base,gimbal0}}^{-1} T_{\text{base,delta}} T_{\text{delta,gimbal}}, \end{equation}
\end{comment}

\begin{comment}
The relationship for force measurement at the grasp frame is expressed as
\begin{align}
    \tau &= k(\alpha-\beta) = J^\intercal f_{\text{total}}
    \\
    f_{\text{total}} &= f_{\text{external}} + f_{\text{gravitational}} + f_{\text{inertia}}
\end{align}
where $k$ is the spring stiffness, $\alpha$ and $\beta$ are the angular displacements measured after and before the spring, respectively. The Jacobian $J$ maps the joint torques to the forces at the end-effector. The total force $F_{\text{total}}$ includes the external force applied to the end-effector, the gravitational force acting on the manipulator, and the inertial force due to the manipulator's motion.


% The position data at each robot's grasp frame is obtained from joint encoders and gimbal wrist encoders. Linear position data is calculated through the forward kinematics of the delta mechanism, followed by a transformation from the delta frame to the grasp frame. Angular position about $\hat{x}$ and $\hat{y}$ axes are directly measured using the gimbal wrist encoder, while the angular position about the $\hat{z}$-axis is inferred through a delta-grasp frame transformation. The twist, $\twist$, and its derivative, $\dot{\twist}$, are calculated as the time derivatives of the linear and angular position data. These derivatives are computed using the central-difference method, adhering to the system's constant sampling rate of 100 Hz.

To reduce the amplification of quantization effects by numerical differentiation, encoder data is 4th-order low-pass filtered using Butterworth filter~\cite{butterworth1930theory}. This filtering is applied to encoder data prior to the differentiation process, along with the forces, to ensure data stability and consistency across the system. The cutoff frequency is uniformly set for all measured parameters across all Omnid Mocobots to maintain a consistent data quality standard.
\end{comment}

%Since no extra sensors are placed for measuring twist $\twist$ and its derivative $\dot{\twist}$ on each Omnid mocobot, the error gets amplified through the derivative process. The filter Exponentially Weighted Moving Average (EWMA)~\cite{hunter1986exponentially} is used for data filtering. As a low-pass filter, the simple filter reduces high-frequency noise while preserving the essential features. Data is processed on the linear positions, angular positions, and forces before derivatives to maintain stability and consistency. The math representation of the filter can be written as:
% \begin{equation}
%     y_t=\alpha x_t+(1-\alpha) y_{t-1},
% \end{equation}
% where $y_t$ is the filtered value at time $t$, $x_t$ is the unfiltered data at time $t$, $\alpha$ is the smoothing factor, and $y_{t-1}$ is the filtered value at time $t-1$. %The smoothing factor $\alpha$ controls the weight of the past value that influences the current value. 
% A lower $\alpha$ makes the filter smoother and less responsive to recent changes. The same filter was applied to the SEA joint torque data used. In our estimation, the value of the smoothing factor $\alpha$ is set the same for all variables and all Omnid Mocobots, with a value of $0.01\pm0.0015$.
%In this estimation, $\alpha$ is the same for all variables and all Omnid mocobots.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Experimental Results}
\subsubsection{Transformation Matrix}
The payload was moved randomly and manually in all 6-dof by a human operator using the float mode of the Omnid~\cite{elwin2022human}, a mode compensating for gravitational forces using active force control. 
The encoder data from the Omnid manipulators were collected to calculate $\twist_{i*}, i = 1, \ldots 3$.
%During the operation, the mobile base of the Omnid remained stationary, and only the upper mechanism interacted with the payload. 
The transformations for the individual robot pairs $\hat{T}_{12}$, $\hat{T}_{23}$, and $\hat{T}_{31}$ were first calculated using the least-squares methods of Section~\ref{ssec:kinematics}, and these estimates were then refined using the nonlinear optimization incorporating loop-closure constraints. (In our experiments, this second optimization step did not change the estimates significantly.) Five independent trials were conducted, each consisting of ten seconds of data (1000 samples) for the estimation process.

The errors between the estimated transformation matrices and the ground truth transformation matrices (Table~\ref{tab:GT}) are reported in Tables~\ref{tab:rotation} and \ref{tab:position} for the rotation matrices and position vectors, respectively. Rotation matrix errors are expressed as the rotation angle $\beta$ (in degrees) of $[\omega]\beta = \log(R_{ij}^\intercal \hat{R}_{ij})$.

%For the rotation matrix, the error evaluation was quantified by computing the matrix logarithm of $R_{ij}^\intercal \hat{R}_{ij}$, which was then transformed into the magnitude of the rotational discrepancy in degrees. Table~\ref{tab:rotation} and~\ref{tab:position} provide a numerical comparison of the rotation matrix and position vector for the transformation matrices across five experiments under the same payload configuration.

% \begin{table}[H]    \centering$\vcenter{\hbox{\subfloat{\includegraphics[width=0.4\textwidth]{img/rotation.png}}}}$
%     \caption{Numerical results for rotation matrix estimation. Results are transformed into axis angles in degrees.}
%     \label{tab:rotation}
% \end{table}

\begin{table}%[ht]
    \vspace{3pt}
    \centering
    \renewcommand{\arraystretch}{1.5}
    \resizebox{0.32\textwidth}{!}{
    \begin{tabular}{|c|cc|}
        \hline
        \multirow{2}{*}{\textbf{Parameters}} 
        & \multicolumn{2}{c|}{\textbf{Absolute Error}}  \\
        \cline{2-3}
        & \textbf{Mean} & \textbf{Standard Deviation} \\
        \hline
        $R_{12}$ (deg) & $1.945$ & $0.292$ \\
        $R_{23}$ (deg) & $2.746$ & $0.552$ \\
        $R_{31}$ (deg) & $1.469$ & $0.690$ \\
        \hline
    \end{tabular}
    }
    \caption{Experimental results for relative grasp frame rotation matrix estimation. Results are represented in absolute degrees of rotation around the axis that rotates the estimated rotation matrix to the actual rotation matrix.}
    \label{tab:rotation}
\end{table}

\begin{table}%[ht]
    \centering
    \renewcommand{\arraystretch}{1.5}
    \resizebox{0.44\textwidth}{!}{
    \begin{tabular}{|c|cc|cc|}
        \hline
        \multirow{2}{*}{\textbf{Parameters}} 
        & \multicolumn{2}{c|}{\textbf{Absolute Error}} 
        & \multicolumn{2}{c|}{\textbf{Percentage Error}} \\
        \cline{2-5}
        & \textbf{Mean} & \textbf{Standard Deviation} 
        & \textbf{Mean} & \textbf{Standard Deviation} \\
        \hline
        $p_{12}$ (m) & $0.031$ & $0.006$ & $3.688$\% & $0.693 $\% \\
        $p_{23}$ (m) & $0.027$ & $0.008$ & $2.867$\% & $0.844$\% \\
        $p_{31}$ (m) & $0.024$ & $0.005$  & $2.089$\% & $0.458$\% \\
        \hline
    \end{tabular}
    }
    \caption{Experimental results for relative grasp frame position estimation. Each 3-vector position error is converted to a scalar using the Euclidean norm, and percentage errors are relative to the Euclidean norm of the ground truth $p_{ij}$.}
    \label{tab:position}
\end{table}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Mass and Center of Mass}
To estimate the mass and center of mass of the payload, the Omnids held the payload stationary at four different orientations. The results of the least-squares estimates from Section~\ref{ssec:com} are summarized in Table~\ref{tab:CoM2}.

% \begin{table}[H]    \centering$\vcenter{\hbox{\subfloat{\includegraphics[width=0.4\textwidth]{img/CoM2.png}}}}$
%     \caption{Numerical results for mass and center of mass estimation}
%     \label{tab:CoM2}
% \end{table}

\begin{table}[t]%[h]
    \vspace{3pt}
    \centering
    \renewcommand{\arraystretch}{1.5}
    \resizebox{0.35\textwidth}{!}{
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Parameters} & \textbf{Absolute Error} & \textbf{Percentage Error} \\
        \hline
        mass (kg) & $0.099$ & $0.867$\% \\
        \hline
        $p_{1c}$ (m) & $0.026$ & $4.403$\% \\
        \hline
    \end{tabular}
    }
    \caption{Experimental results for mass and center of mass estimation. The 3-vector position error is converted to a scalar using the Euclidean norm, and the percentage error is relative to the Euclidean norm of the ground truth $p_{1\text{c}}$.}
    \label{tab:CoM2}
\end{table}



% A mask strategy is applied to the dataset. Since the system is static, the net force measurement of three Omnids in the same frame should be equal to zero. Data points with their net force exceeding the force threshold of 10 N are ignored.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Inertia Matrix}

To estimate the inertia matrix, the Omnids performed four one-minute manipulation trials, with the first and last four seconds of data discarded (5200 samples for each trial). In each manipulation, two Omnid wrists moved in periodic trajectories on the surface of the sphere for which the origins of the three grasp frames lie on a common meridian. The third Omnid had its actuators locked and passively accommodated the motion of the other two Omnids via its gimbal wrist and elastic Delta joints. 

%For the inertia matrix estimation, a precession trajectory was employed, allowing the robots to manipulate the payload in a controlled way. For the trajectory generation, we selected the payload's CoM as the center of a circle, and the origins of the three grasp frames were fit to form a circle in 3D space. This circle, in turn, defined a sphere, with each Omnid Mocobot executing periodic motions along the meridians of the sphere. Eccentric motion was introduced by applying a periodic wave function at the sphere's origin, creating a dynamic trajectory for the payload.

Table~\ref{table:inertia} summarizes the results from the four experimental trials, with the estimated inertia matrix transformed into the principal axes of the payload. Similar to the labeling of axes in the ground truth inertia matrix, the labels $\hat{\inertia}_{xx}$, $\hat{\inertia}_{yy}$, and $\hat{\inertia}_{zz}$ are given to principal inertia estimates in ascending order.
%In this specific experiment, the third Omnid Mocobot was not engaged in active motion but was instead passively guided by the other robots, adapting its movement through elastic springs.

\begin{table}[t]%[ht]
    \centering
    \renewcommand{\arraystretch}{1.8}
    \resizebox{0.44\textwidth}{!}{
    \begin{tabular}{|c|cc|cc|}
        \hline
        \multirow{2}{*}{\textbf{Parameters}} 
        & \multicolumn{2}{c|}{\textbf{Absolute Error}} 
        & \multicolumn{2}{c|}{\textbf{Percentage Error}} \\
        \cline{2-5}
        & \textbf{Mean} & \textbf{Standard Deviation} 
        & \textbf{Mean} & \textbf{Standard Deviation} \\
        \hline
        $\inertia_{xx}$ (kg$\cdot$m$^2$) & 0.154 & 0.063 & 6.824\% & 2.789\% \\
        $\inertia_{yy}$ (kg$\cdot$m$^2$) & 0.138 & 0.094 & 3.999\% & 2.735\% \\
        $\inertia_{zz}$ (kg$\cdot$m$^2$) & 0.050 & 0.155 & 0.973\% & 2.719\% \\
     %   $R_{1c}$ (deg) & 25.224 & 1.100 & & \\
        \hline
    \end{tabular}
    }
    \caption{Experimental results of inertia matrix estimation.}
    \label{table:inertia}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}

%Here say something about the results (pretty good, why the large rotation error in inertia matrix), and simplify the discussion to one sentence or so for each observation.

The experimental results demonstrate the validity of the approach, producing relative grasp rotation matrix errors typically less than $3^\circ$ and position vector magnitude errors of less than $4\%$, a mass estimate error of less than $1\%$, and a CoM position error of less than $5\%$.  Inertia matrix estimation, which relies on acceleration estimates from twice-differenced encoder data, exhibits a bit more error, but it is still less than $10\%$ for the principal moments of inertia. 
%\textbf{*** Here say something about the 25 degrees of error in the rotation of the principal inertia matrix. Is it mostly about the z-axis, and could some of this be due to the similar Ixx and Iyy?}

The experimentally-derived kinematic and mass parameters may be directly inserted into the mocobot gravity compensation mode reported in~\cite{elwin2022human}, and the inertial parameters can be used to improve the performance of dynamic model-based cooperative control, eliminating the need for an \textit{a priori} model of the payload and the grasp locations. There are a number of limitations to the method, however.

First, grasp frame velocities and accelerations are obtained by differencing encoder data, including encoders at the proximal joints of the Delta mechanism, distant from the wrist. The intervening mechanism and the differencing process introduce noise to the estimation. To address this, the Omnid sensor suite could be supplemented by IMUs at the gimbals. Independent of the sensing modality, however, the inherent compliance of the manipulators, due to their SEAs, can introduce vibrations at the wrists, which may be exacerbated by a poor choice of wrist trajectories to estimate the payload inertial properties. Because the Omnids are designed primarily for force-controlled human interaction, they are incapable of stiff, highly precise motion control, which is assumed to be supplied by the human during typical human-robot collaboration. 

Second, manipulation forces at the wrist are estimated based on the Delta's proximal joint SEAs. This assumes zero friction at joints and bearings, but eliminates the need for costly and potentially fragile end-effector force-torque sensors.

Third, the limited workspace of the manipulators places constraints on the payload trajectories that can be used to determine inertial properties. In particular, the payload trajectories in our experiments were limited to less than $\pm 10^\circ$ rotation about any axis.  Payload trajectories with larger rotations could provide a higher signal-to-noise ratio. 

Finally, computational aspects of the method (e.g., data filtering during post-processing) could be further optimized.

\begin{comment}
\subsection{Source of Noise}
Noise in the system arises from multiple sources that could affect the accuracy of the inertial property estimations. As the estimation follows a sequential process, errors from each stage propagate and accumulate through subsequent computations.

\subsubsection{Kinematics error}
Kinematic errors occur due to inaccuracies in the positioning of the delta mechanism. The Omnid mocobot, primarily designed as a research platform for human-robot collaboration, lacks the building precision required for high-accuracy tasks. Moreover, the ground of the experiment environment is not guaranteed to be flat, which can introduce errors in force-involved estimations.

\subsubsection{Sensing error}
Sensing errors arise from the encoders and the SEA springs integrated into the delta mechanism. Each Omnid mocobot is calibrated manually for the pulley belt and spring tension, which leads to variability in position and force measurements. Furthermore, vibrations from the springs can introduce noise, which affects estimations since velocities and accelerations are derived from encoder data, amplifying noise through differentiation.

\subsubsection{Unmodeled dynamics}
Although the mobile base is supposed to remain stationary during all experiments, the mecanum-wheel mobile base can still introduce unobserved sliding due to the roller. Furthermore, the inertial force caused by the manipulator is not precisely considered. Force and torque absorbed by bearings and shafts are not considered. All bearings are considered frictionless.

\subsection{Data Collection and Performance}

\subsubsection{Signal-to-noise ratio}
During the experiments, the signal-to-noise ratio (SNR) was found to be critical for accurate estimation, particularly in the inertia matrix estimation. Since the payload was rigidly connected to each end-effector and the mobile base was disabled, achieving significant angular motion around the rotation axis is challenging due to physical constraints. Positioning the Omnid mocobots closer typically enhances the accuracy of inertia matrix estimations. Exploring better trajectories to introduce larger angular motions could further improve performance.

\subsubsection{Loop enclosure constraint}
For our experimental validation, a basic constraint was applied to estimate the transformation matrices using the BFGS method. While this approach assists in achieving global consistency, it represents a fundamental implementation of loop enclosure constraints. Advanced techniques, such as those developed within the SLAM framework, could significantly enhance global optimization and improve the overall system performance.

\subsubsection{Filter performance}
The experimental data were processed using a Butterworth filter. While effective for general noise reduction, the filter parameters were not specifically optimized for Omnid Mocobots and did not incorporate advanced analytical techniques. Refining filter parameters could significantly improve data quality since errors tend to be amplified through derivatives. Also, using external sensors, such as IMUs, could provide direct measurements of twists and their derivatives, potentially enhancing data collection and estimation accuracy.
\end{comment}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Conclusion}
We present a methodology for cooperative payload estimation using a group of mocobots, focusing on the estimation of the mass, center of mass, and inertia matrix of a rigid body payload, as well as the transformations between the grasp frames of each robot. The proposed method avoids the need for expensive sensors and intercommunication between robots by leveraging the twists, twist derivatives, and wrenches measured at each robot's grasp frame. Despite challenges of sensor noise and unmodeled dynamics, the proposed approach demonstrates promising results for payload estimation using Omnid mocobots. 
%This approach enables a group of mocobots to infer the inertial properties of an unknown rigid-body payload in an instructed environment, providing enhanced flexibility and improved manipulation performance in collaborative tasks.
Future work will focus on extending the methodology to identify the kinematic and inertial properties of articulated payloads, and eventually continuously deformable payloads.

%handle deformable or articulated payloads, thereby enhancing the capabilities of mocobot groups in various collaborative scenarios. Additionally, improved data processing techniques and real-time estimation frameworks will be explored to enhance accuracy, adaptability, and efficiency, particularly in human-robot collaboration tasks.
\label{sec:conclusion} 

\bibliographystyle{IEEEtran}
\balance
\small
\Urlmuskip=0mu plus 1mu\relax
\bibliography{Cooperative_Payload_Estimation_by_a_Team_of_Mocobots.bib}





\begin{comment}
The problem can be formed into a minimization using the Frobenius norm:
\begin{equation}
    R_{ij} = \underset{R \in SO(3)}{\operatorname{argmin}}  (\|R \omega_{j*} - \omega_{i*}\| _F) ^2.
    \label{eqn:rotation}
\end{equation}

Applying trace properties and orthogonal matrix properties, the objective function can be further written as
\begin{equation}
    (\|R_{ij} \omega_{j*} - \omega_{i*}\| _F) ^2 = \operatorname{tr} ( \omega_{j*}^T \omega_{j*} -2 \omega_{i*}^T R_{ij} \omega_{j*} + \omega_{i*}^T \omega_{i*} ),
\end{equation}
and therefore Equation~\eqref{eqn:rotation} is equivalent to
\begin{equation}
    R_{12} = \underset{R \in SO(3)}{\operatorname{argmax}} \operatorname{tr} (\omega_2 \omega_1^T R).
\end{equation}

We define the matrix $X = \omega_2 \omega_1^T$ and utilize SVD decomposition to get $X = U \Sigma V^T$. Then define $Y = U V^T R_{12}$ containing all orthogonal matrices, the objective function becomes
\begin{equation}
\begin{aligned}
    R_{12} = \underset{R \in SO(3)}{\operatorname{argmax}} \operatorname{tr} (\Sigma Y )
           = \underset{R \in SO(3)}{\operatorname{argmax}} \sum\limits_{i=1}^{n} \sigma_{i} y_{ii}
\end{aligned}.
\end{equation}

As $\sigma_i$ is constant and the orthogonal matrix holds $|y_{ij}| \leq 1$ due to its rows and columns are all orthogonal vectors, the maximum value of this equation occurs when $y_{ii} = 1$, which means $Y = I_3$. Here, $I_3$ refers to the $3 \times 3$ identity matrix. The relationship can be extracted as
\begin{equation}
   R_{12} = V U^T.
\end{equation}

At this point, $R_{12}$ is constrained to $O(3)$ but not $SO(3)$ since the determinant of an orthogonal matrix can be $-1$, indicating a reflection matrix. When the largest value encounters improper rotation, the second-largest value takes place. According to the properties of SVD as $\sigma_1 \ge \sigma_2 \ge \ldots \ge \sigma_n$
The second-largest value occurs when
\begin{equation*}
    R_{12} = \sum\limits_{i=1}^{n} \sigma_{i} y_{ii} = \sigma_1 + \sigma_2 + \ldots - \sigma_n
\end{equation*}
which implies $Y = \operatorname{diag}(1,1, \ldots ,-1)$. Therefore, a general form of handling improper rotation of the minimization process can be described as 
\begin{equation}
   R_{12} = V S U^T
\end{equation}
where matrix $S = \operatorname{diag}(1,1,\operatorname{det}(VU^T))$.
\end{comment}



% \section{Appendix}%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \textcolor{red}{The appendix now is not entirely formmated}

% \subsection{Transformation matrix}
% Given $\twist_a$ and $\twist_b\in\mathbb{R}^{6 \times n}$ measured in two different frames on the same rigid body object, where the relationship can be associated with the adjoint representation $[ \text{Ad}_{\tau_{ab}} ] \in \mathbb{R}^{6 \times 6}$. $T_{ab} = (R,p) \in SE(3)$.
% \begin{equation*}
% \begin{gathered}
%    \twist_a = [ \text{Ad}_{\tau_{ab}} ] \twist_b \\
%    \begin{bmatrix}
%     \omega_1 \\
%     v_a
%     \end{bmatrix}
%     =
%     \begin{bmatrix}
%     R_{12} & 0 \\
%     [ p_{ab} ] R_{12} & R_{12}
%     \end{bmatrix}
%     \begin{bmatrix}
%     \omega_2 \\
%     v_b
%     \end{bmatrix}
% \end{gathered}
% \end{equation*}
% \subsubsection{Rotation matrix}
% For the rotation matrix estimation, let $\omega_{ai}$ and $\omega_{bi}$,  $i = 1,2,...,n$,  representing column vector of $\omega_{a}$ and $\omega_{b}$, respectively. The relationship between the angular velocity can be defined as
% \begin{equation*}
%     \omega_{ai} = R_{12} \omega_{bi} \\
% \end{equation*}
% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \begin{align*}
%     \omega_{ai}, \omega_{bi} & : \text{angular velocity} \in \mathbb{R}^{3} \text{ in different frames at time stamp i} \\
%     R_{12} & : \text{rotation matrix} \in SO(3)\\
% \end{align*}

% Using Frobenius norm to set up the objective function and using the definition to make it into trace form.
% \begin{equation*}
% \begin{aligned}
%     R_{12} &= \underset{R_{12}\in SO(3)}{\operatorname{argmin}} \|R_{12}\omega_2 - \omega_1\|_F^2 \\
%            &= \underset{R_{12}\in SO(3)}{\operatorname{argmin}} \operatorname{tr} ( (R_{12}\omega_2 - \omega_1)^T (R_{12}\omega_2 - \omega_1) )
% \end{aligned}
% \end{equation*}

% Starting from the trace form and doing the expansion.
% \begin{equation*}
% \begin{aligned}
%      &\operatorname{tr} ( (R_{12}\omega_2 - \omega_1)^T 
%        (R_{12}\omega_2 - \omega_1) ) \\
%     =&\operatorname{tr} ( (\omega_2^T R_{12}^T - \omega_1^T) (R_{12}\omega_2 - \omega_1) ) \\
%     =&\operatorname{tr} ( \omega_2^T R_{12}^T R_{12} \omega_2 - \omega_1^T R_{12} \omega_2 - \omega_2^T R_{12}^T \omega_1 + \omega_1^T \omega_1 )
% \end{aligned}
% \end{equation*}

% Due to the property of the orthogonal matrix $R^TR=I$, the equation becomes:
% \begin{equation*}
%     \operatorname{tr} ( \omega_2^T \omega_2 - \omega_1^T R_{12} \omega_2 - \omega_2^T R_{12}^T \omega_1 + \omega_1^T \omega_1 )
% \end{equation*}

% In this minimization progress, $\omega_2^T \omega_2$ and $\omega_1^T \omega_1$ are not essentially involved. Additionally, according to the properties of trace as $\operatorname{tr}(A + B) = \operatorname{tr}(A) + \operatorname{tr}(B)$, $\operatorname{tr}(A^T) = \operatorname{tr}(A)$, and $\operatorname{tr}(AB) = \operatorname{tr}(BA)$, the equation can be simplified to:

% \begin{equation*}
% \begin{aligned}
% R_{12} &= \underset{R_{12}\in SO(3)}{\operatorname{argmin}} \operatorname{tr} (-2 \omega_1^T R_{12} \omega_2                   )\\
%        &= \underset{R_{12}\in SO(3)}{\operatorname{argmax}} \operatorname{tr} (\omega_2 \omega_1^T R_{12}  )
% \end{aligned}
% \end{equation*}

% Set up matrix $X = \omega_2 \omega_1^T$ and utilize SVD decomposition of $X = U \Sigma V^T$. The objective function becomes:

% \begin{equation*}
% \begin{aligned}
%     R_{12} &= \underset{R_{12}\in SO(3)}{\operatorname{argmax}} \operatorname{tr} (U \Sigma V^T R_{12} )\\
%            &= \underset{R_{12}\in SO(3)}{\operatorname{argmax}} \operatorname{tr} (\Sigma U V^T R_{12} )
% \end{aligned}
% \end{equation*}

% Define $Y = U V^T R_{12}$ containing all orthogonal matrices, and expand the trace form into the plain form:

% \begin{equation*}
% \begin{aligned}
%     R_{12} &= \underset{R_{12}\in SO(3)}{\operatorname{argmax}} \operatorname{tr} (\Sigma Y ) \\
%            &= \underset{R_{12}\in SO(3)}{\operatorname{argmax}} \sum\limits_{i=1}^{n} \sigma_{i} y_{ii}
% \end{aligned}
% \end{equation*}

% The properties of the orthogonal matrix state that $|y_{ij}| \leq 1$ as its rows and columns are all orthogonal vectors. Therefore, the maximum value of this equation occurs when $y_{ii} = 1$, which means $Y = I_3$. Here, $I_3$ refers to a $3 \times 3$ identity matrix.

% \begin{equation*}
% \begin{gathered}
%    Y = I_3 = U V^T R_{12}\\
%    R_{12} = V U^T
% \end{gathered}
% \end{equation*}

% This method ensures $R_{12}$ to be an orthogonal matrix but doesn't enforce a rotation matrix as it might result in a reflection matrix $det(R_{12}) = -1$.
% When the largest value encounters improper rotation, the second-largest value takes place.
% Due to the properties of SVD as $\sigma_1 \ge \sigma_2 \ge ... \ge \sigma_n$
% The second-largest value occurs when
% \begin{equation*}
%     R_{12} = \sum\limits_{i=1}^{n} \sigma_{i} y_{ii} = \sigma_1 + \sigma_2 + ... - \sigma_n
% \end{equation*}
% which implies $Y = diag(1,1,...,-1)$. Therefore, when the determinant is detected to be $-1$, the rotation matrix is set to
% \begin{equation*}
% \begin{gathered}
%    S = \begin{bmatrix}
%     1 & 0 & 0 \\
%     0 & 1 & 0 \\
%     0 & 0 & -1
%     \end{bmatrix}\\
%     R_{12} = V S U^T
% \end{gathered}
% \end{equation*}

% \subsubsection{Position vector}
% Compared to the rotation matrix, the position vector is easier to calculate as it holds a pure linear relation and can be set into a simple least-square form.

% Using the properties of skew-symmetric matrix: $[\omega]p=-[p]\omega$, the equation becomes:
% \begin{equation*}
% \begin{aligned}
%     v_{ai} &= [p_{ab}]R_{12} \omega_{bi}   + R_{12} v_{bi} \\
%     v_{ai} &= - [ R_{12} \omega_{bi} ] p_{ab} + R_{12} v_{bi}
% \end{aligned}
% \end{equation*}


% \begin{align*}
%     v_{ai}, v_{bi} &: \text{linear velocities} \in \mathbb{R}^{3 \times 1} \text{ as the column vector of } v_a \text{ and } v_b\\
%     \omega_{bi} &: \text{angular velocity} \in \mathbb{R}^{3 \times 1} \text{ as the column vector of } \omega_2 \\
%     R_{12} &: \text{rotation matrix} \in SO(3) \\
%     p_{ab} &: \text{position vector} \in \mathbb{R}^{3 \times 1}
% \end{align*}

% Rearrange it:
% \begin{equation*}
%     [R_{12} \omega_{bi}] p_{ab} = R_{12} v_{bi} - v_{ai}
% \end{equation*}

% Define:
% \begin{equation*}
% \begin{aligned}
%     A &= [R_{12} \omega_{bi}] \\
%     b &=  R_{12} v_{bi} - v_{ai} \\
%     x &= p_{ab}
% \end{aligned}
% \end{equation*}

% Then the least-square minimization can be formed depending on the the objective function $\|Ax-b\|^2$.

% \begin{comment}
% \subsection{Center of Mass (CoM)}

% The measurement of Center of Mass (CoM) requires at least two measurements as the method depends on plumb line measurement as the CoM always aligns with the direction of the gravitational force vector.

% \subsubsection{First Measurement}
% The first measurement is measured when the force is only acted in the z-direction, where the mass of the object and the x-direction and y-direction CoM can be determined.

% For the force balance:
% \begin{equation*}
% F_g + \sum\limits_{i=1}^{n} F_i = 0 \quad
% m =\frac{\sum\limits_{i=1}^{n} F_i}{g}
% \end{equation*}

% For the moment balance: As the entire system remains static, the moment at any point on the object is zero. Take one of the end-effectors, denoted as $A$, as the moment balance point. The CoM is at point {O}.

% \begin{equation}
% \begin{aligned}
% M_A &= r_{AO} \times F_g + \sum\limits_{i=1}^{n} r_{Ai} \times F_i = 0 \\
%     &= [r_{AO}] F_g + \sum\limits_{i=1}^{n} [r_{Ai}] F_i = 0 \\
%     &= -[F_g] r_{AO} + \sum\limits_{i=1}^{n} [r_{Ai}] F_i = 0
% \end{aligned}
% \end{equation}

% \begin{equation}
% \begin{aligned}
% M_A &: \text{moment at point A} \\
% r_{AO} &: \text{position vector from point A to CoM (point O)} \in \mathbb{R}^{3 \times 1} \\
% F_g &: \text{gravitational force vector from CoM} \in \mathbb{R}^{3 \times 1} \\
% r_{Ai} &: \text{position vector from A to other end-effector} \in \mathbb{R}^{3 \times 1} \\
% F_i &: \text{force vector measured from other end-effector} \in \mathbb{R}^{3 \times 1}
% \end{aligned}
% \end{equation}

% Format it into $Ax=b$ least-square form where:
% \begin{equation}
% \begin{gathered}
% A = [F_g] \\
% b = \sum\limits_{i=1}^{n} [r_{Ai}] F_i \\
% x = r_{AO}
% \end{gathered}
% \end{equation}

% Since force only acts on z-direction, no z-direction moment is generated. Therefore, only the x-direction and y-direction components of $r_{AO}$ can be determined. A second measurement is needed to decouple the gravitational force vector.

% \subsubsection{Second Measurement}
% By rotating the object into a position where the gravitational force decoupled into all 3 axes, the moment is generated in all 3 axes as well.

% \begin{equation}
% \begin{gathered}
% M_A = r_{AO} \times F_g' + \sum\limits_{i=1}^{n} r_{Ai} \times F_i' = 0 \\
% F_g' = {R_{AA'}}^T F_g \\
% M_A = [r_{AO}]  {R_{AA'}}^T F_g' + \sum\limits_{i=1}^{n} [r_{Ai}] F_i' = 0 \\
% M_A = -[{R_{AA'}}^T F_g']  r_{AO} + \sum\limits_{i=1}^{n} [r_{Ai}] F_i' = 0
% \end{gathered}
% \end{equation}

% Similar to the previous section, formatting it into $Ax=b$ least-square form where:
% \begin{equation}
% \begin{gathered}
% A = [{R_{AA'}}^T F_g'] \\
% b = \sum\limits_{i=1}^{n} [r_{Ai}] F_i' \\
% x = r_{AO}
% \end{gathered}
% \end{equation}

% \subsubsection{Third or more measurement}
% If more measurements are taken, they follow equations 22 and 23 and get stacked into a larger matrix for the least-square minimization
% \end{comment}

% \textcolor{red}{For the CoM, there is not much more that can be shown in the Appendix section}

% \subsection{inertia matrix}
% The following is the math derivation for the Newton-Euler equation~\cite{lynch2017}. The situation can be derived when the measurement is at the CoM and when it is on an arbitrary point on the payload\\

% \subsubsection{frame on CoM}
% Set $\twist_b = (\omega_2, v_b)$, $p_i$ is where $m_i$ is

% \begin{equation*}
% \begin{aligned}
%     \dot{p}_i &= v_b + [ \omega_2 ] r_i \\
%     \ddot{p}_i &= a_b + [ \frac{d}{dt} \omega_2 ] r_i + [ \omega_2 ] \frac{d}{dt}r_i \\
%     \ddot{p}_i &= a_b + [ \alpha_b ] r_i + [ \omega_2 ] (v_b + [ \omega_2 ] r_i) \\
%     \ddot{p}_i &= a_b + [ \alpha_b ] r_i + [ \omega_2 ] {v}_b + [ \omega_2 ]^2 r_i
% \end{aligned}
% \end{equation*}

% \begin{equation*}
% \begin{aligned}
%     \\ \text{as } F_i=m_i \ddot{p_i} \\
%     F_i &= m_i \ddot{p}_i \\
%     F_i &= m_i (a_b + [ \alpha_b ] r_i + [ \omega_2 ] {v}_b + [ \omega_2 ]^2 r_i) \\
%     M_i &= [ r_i ] F_i \\
% \end{aligned}
% \end{equation*}

% Here wrench is formed: \\
% \begin{equation*}
%     \mathcal{F}_b = \left[ \begin{matrix} M_b \\ F_b \end{matrix} \right] = \left[ \begin{matrix}  \sum M_i \\ \sum F_i \end{matrix} \right]
% \end{equation*}

% \begin{equation*}
% \begin{aligned}
%     M_b &= \sum M_i = \sum [r_i] F_i \\
%         &= \sum [r_i] m_i (a_b + [\alpha_b] r_i + [\omega_2] v_b + [\omega_2]^2 r_i) \\
%         &= \sum m_i [r_i] a_b + \sum m_i [r_i] ([\alpha_b] r_i + [\omega_2] (v_b + [\omega_2] r_i)) \\
%         &= \sum m_i [r_i] v_b + \sum m_i [r_i] [\omega_2] v_b  \\
%         &\quad + \sum m_i (r_i [\alpha_b] r_i + [r_i] [\omega_2]^2 r_i) \\
% \end{aligned}
% \end{equation*}

% Here, since the CoM has the properties as $\sum m_i r_i = 0 $ so that $\sum m_i [r_i] = 0$, along with skew-symmetric matrix properties:
% \begin{equation*}
% \begin{aligned}
%     M_b &= \cancel{\sum m_i [r_i] v_b} + \cancel{\sum m_i [r_i] [\omega_2] v_b}  \\
%         &\quad + \sum m_i (r_i [\alpha_b] r_i + [r_i] [\omega_2]^2 r_i) \\
%         &= \sum m_i (-[r_i]^2 \alpha_b - [r_i]^T [\omega_2]^T [r_i] \omega_2)\\
%         &= \sum m_i (-[r_i]^2 \alpha_b - [\omega_2][r_i]^2\omega_2\\
%         &= (- \sum m_i [r_i]^2 ) \alpha_b + [\omega_2] ( -\sum m_i [r_i]^2 ) \omega_2
% \end{aligned}
% \end{equation*}


% \begin{comment}
% For the latter term $[r_i] [\omega_2]^2 r_i$, Jacobi identity states that
% \begin{equation*}
% \begin{gathered}
%     a \times (b \times c) + b \times (c \times a) + c \times(a \times b)=0 \\
%     a = r, b = w, c = w \times r
% \end{gathered}
% \end{equation*}
% so that
% \begin{equation*}
% \begin{gathered}
%     [r]([w]([w]r)) + [w](([w]r) \times r)+ ([w]r) \times ([r]w) = 0 \\
%     [r]([w]([w]r)) + [w](([w]r) \times r) - ([w]r) \times ([w]r) = 0 \\
%     [r]([w]([w]r)) + [w](([w]r) \times r) = 0\\
%     [r][w]^2r=-[w](([w]r)\times r)
% \end{gathered}
% \end{equation*}

% Applying the vector triple product as
% \begin{equation*}
% \begin{gathered}
%     a \times (b \times c) = b(a \cdot c) - c(a \cdot b) \\
%     a = w, b = [w]r, c = r\\
%     [r][w]^2r=-([w]r(wr) - r(w[w]r))
% \end{gathered}
% \end{equation*}

% For the term $w[w]r$, applying the scalar triple product and self-cross-product properties
% \begin{equation*}
% \begin{gathered}
%     a \cdot (b \times c) = c \cdot (b \times a)\\
%     a = w, b = w, c = r \\
%     w[w]r = r[w]w = 0
% \end{gathered}
% \end{equation*}

% The term simplified to
% \begin{equation*}
% \begin{aligned}
%     [r][w]^2r&=-[w]r(wr) \\
%              &=-[w]r^2w
% \end{aligned}
% \end{equation*}

% Substitute back to the original equation

% \begin{equation*}
% \begin{aligned}
%     M_b &= \sum m_i (-[r_i]^2 \alpha_b + [r_i] [\omega_2]^2        r_i) \\
%         &= \sum m_i (-[r_i]^2 \alpha_b + [\omega_2] (0-[r_i]^2    \omega_2) \\
%         &= (- \sum m_i [r_i]^2 ) \alpha_b + [\omega_2] ( -\sum m_i [r_i]^2 ) \omega_2
% \end{aligned}
% \end{equation*}
% \end{comment}




% As the MoI matrix is determined as $ \mathcal{I} = - \sum m_i [r_i]^2 \in \mathbb{R}^{3 \times 3}$, the equation becomes

% \begin{equation*}
%     M_b = \mathcal{I}_b \alpha_b + [\omega_2] \mathcal{I}_b \omega_2
% \end{equation*}

% To align the $I_o$ with the principal axes of the payload, an eigendecomposition process can be taken
% \begin{equation*}
%     \mathcal{I}_o = \mathcal{Q} \Lambda \mathcal{Q}^T
% \end{equation*}
% where $\Lambda$ = $diag(\mathcal{I}_1,\mathcal{I}_2,\mathcal{I}_3)$, representing the inertia matrix in the principal axes.


% \subsubsection{frame not on the CoM}
% If the measurement is not on the CoM \\

% \begin{equation*}
% \begin{aligned}
%     a_c &= a_b + \alpha \times r_{bc} + \omega \times (\omega \times r_{bc}) \\
%     a_c &= a_b + [\alpha] r_{bc} + [\omega]^2 r_{bc} \\
%     a_b &= a_c - [\alpha] r_{bc} - [\omega]^2 r_{bc}
% \end{aligned}
% \end{equation*}

% \begin{equation*}
% \begin{aligned}
%     b&: \text{frame on the CoM} \\
%     c&: \text{another frame where the measurement is taken} \\
%     r_{bc}&: \text{position vector from b to c} \\
% \end{aligned}
% \end{equation*}

% Therefore, the force can be determined from the Newton's Law: \\
% \begin{equation*}
% \begin{aligned}
% F &= m a_b \\
%        &= m (a_c - [\alpha] r_{bc} - [\omega]^2 r_{bc})
% \end{aligned}
% \end{equation*}

% The moment equilibrium can be described as
% \begin{equation*}
% \sum M_c = \sum M_b + r_{bc} \times F
% \end{equation*}

% Substitute the result from the previous section here

% \begin{equation*}
% \begin{aligned}
%     \sum M_c &= \sum M_b + r_{bc} \times F \\
%              &= \mathcal{I}_b \alpha + [\omega_2] \mathcal{I}_b \omega_2  \\
%              &\quad + m [r_{bc}] a_c - m [r_{bc}]^2 \alpha - m [\omega][r_{bc}]^2 \omega \\
% \end{aligned}
% \end{equation*}




\end{document}
