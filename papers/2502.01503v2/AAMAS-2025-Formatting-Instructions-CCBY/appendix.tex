% \pagebreak
% \newpage
\appendix
% \input{macros}

\section{Appendix}{\bf Technical Preliminaries}

\noindent\textbf{Logical Language and Syntax.} The language is defined with a set of constants that is partitioned into multiple domains ($\domainSet_i \subset \constantSet$),
examples of such subsets are: $l_1, l_2,.. \in \domainSet_{loc}$ - a set of all potential locations of the vessel, $\regionconst_{l1,l2},.. \in \domainSet_{\regionconst}$ - a set of all regions, and $agt,.. \in \domainSet_{agt}$ - a set of agents, as specified in Section~\ref{subsec:prelims}.
As usual in first-order logic, we define a corresponding set of variables ($\variableSet$), and a set of predicate symbols ($\predicateSet$) with an 
arity (notated by $arity(p) \in \mathbb{W} $, where $p \in  \predicateSet$ and $\mathbb{W}$ is a set of all whole numbers).
Terms (constants or variables) and predicates form atoms. Atoms and their negation are called literals. Literals are called ground literals if and only if there is no occurrence of any variables (they are replaced by elements from $\constantSet$). Consider $\groundLiteralSet$ to be the set of all ground literals. A formula can be defined recursively- any literal is a formula and any combination of two formulae with logical connectives (conjunction $\wedge$, disjunction $\vee$ and negation $\neg$) is a formula.

\noindent\textbf{Annotated Language.} In addition to the first-order logic syntax and semantics, we allow for literals to be annotated with elements (intervals in $[0,1]$) of a lower semi-lattice structure  $\semiLattice$ (not necessarily complete) with ordering $\sqsubseteq$ \cite{ks92,ssTAI22}. 
We assume the existence of a set $\avar$ of variable symbols ranging over $\semiLattice$, and $h$ is an $n$-ary function symbol over $\semiLattice$ and $\mu_1,\ldots,\mu_n$ are annotations, then annotations can be defined~\cite{ssTAI22, ks92} as any member of $\semiLattice \cup \avar$ or $h(\mu_1,\ldots,\mu_n)$.
\begin{figure*}[!t]
    \begin{center}
        \includegraphics[width=.8\linewidth]{AAMAS-2025-Formatting-Instructions-CCBY/images/treeLikeLowerLattice.png}
    \end{center}
    \caption{\label{fig:lowerLattice}Example of a lower semi-lattice structure where the elements are intervals in $[0,1]$.}
\end{figure*}



 $\semiLattice$ has a single bottom element ($\bot$) and a set of top elements $\top_{0} = [0,0]$, . . . $\top_{i}$ . . . $\top_{max} = [1,1]$. The notation height ($\top$) is the maximum number of elements in the lattice in a path between $\bot$ and a top element. The annotations are represented with $[\ell,u]$ which is simply a subset of the unit interval $[0,1]$ - which generalizes both fuzzy and classical logic. 
As seen in the Figure~\ref{fig:lowerLattice}, we set the bottom element to be $\bot = [0,1]$ and define a set of top elements $\{[x,x] \; | \; [x,x]\subseteq [0,1]\}$.  Note that the notation ``$\sqsubseteq$'' in a semi-lattice of bounds,  has the following intuition: $[0,1] \sqsubseteq [1,1]$ in this case.
We write an annotated literal $a:[\ell,u]$ to mean that the literal $a$ has truth value associated with interval $[\ell,u]$. We refer the reader to \cite{ks92,ssTAI22} for lattice-theory justification of this approach and how it generalizes other logical paradigms. 
We also note that we have learned our logic programs in a way to treat these bounds as confidence (see Section~\ref{sec:rule_learning} in the main paper). 


\noindent\textbf{Extensions to Temporal Syntax.}  We follow the extension of temporal syntax and semantics~\cite{aditya2023pyreason,bavikadi2024geospatial,shakAamas13} to form temporally annotated facts (TAFs) and annotated formulae. For an annotated literal $f$ that is true at time $t$, $f_t$ is a TAF. Annotated formulae are constructs formed with operators like $\after(f,f')$ as well as annotated literals. For annotated literals $f,f'$, $\after(f,f')$ is interpreted as $f$ occurs after $f'$. Note that TAFs are considered separately from these formulas when we describe the semantics.



\noindent\textbf{Semantics and Logic Program.} As per previous work on temporal annotated logic~\cite{shakAamas13,aditya2023pyreason,bavikadi2024geospatial}, given a set of timepoints $T$, a set of all (ground) literals $\groundLiteralSet$, an interpretation $\interpretation$ is any mapping $\groundLiteralSet \times T \to \semiLattice$. 
The set~$\interpretationSet$ of all interpretations can be partially ordered via the ordering: $\interpretation_1\preceq \interpretation_2$ if and only if for all ground atoms $g \in \groundLiteralSet$ and time $t \in T$, $\interpretation_1(g, t)\sqsubseteq \interpretation_2(g, t)$. $\interpretationSet$ forms a complete lattice under the $\preceq$ ordering. We define a satisfaction relationship ``$\models$'' and rules for temporally annotated extensions as defined in~\cite{shakAamas13, aditya2023pyreason}.  
We read $ \interpretation \satisfactionAtTime{t} \groundedLiteral:\mu$ as an interpretation $\interpretation$ \emph{satisfies} an annotated ground literal $\groundedLiteral:\mu$ where $\groundedLiteral \in \groundLiteralSet$ at time $t$, iff $\mu \sqsubseteq \interpretation( \groundedLiteral, t)$.
Given TAF $f_t$ and interpretation $I$, the interpretation $I$ satisfies the TAF $f_t$, iff $I \models_t f$. 
If $\after( p_1,p_2): \mu$ is an annotated formulae for unary predicate symbols $p_1,p_2 \in \predicateSet$, then there exists $r_1,r_2 \in \domSet_{r}$ and $agt \in \domainSet_{agt}$ such that $I \models_{t} \atPred(agt,r_1): \mu$, $I \models_{t'} \atPred(agt,r_2): \mu$ (where $t' < t$),  $I \models_{t} p_1(r_1):\mu$, and $I \models_{t'} p_2(r_2):\mu$.


A program $\Pi$ is a set of rules, where each has an annotated atom in the head and a conjunction of annotated formulae in the body. Sample rules in $\Pi$ are included in Table~\ref{tab:examplerlsRules}. A rule with no body is called a fact. A rule with no variables is called a ground rule. If an interpretation $\interpretation$ satisfies every annotated formula in the body of $r \in \Pi$, then the annotated atom in the head of $r$ must be satisfied by $\interpretation$. An interpretation $\interpretation$ is said to satisfy $r$, if and only if it satisfies all ground instances of $r$. An interpretation $\interpretation$ is said to satisfy $\Pi$, if and only if $\interpretation$ satisfies every rule and TAF in $\Pi$.  The minimal model is an interpretation that can be thought of everything that can be concluded from deductive inference and commonly used for entailment queries in annotated logic~\cite{ks92,shakAamas13,ssTAI22,aditya2023pyreason}.  This is often computed using a fixpoint operator as done in the aforementioned work - and refer the reader to the well-established work on that topic for details.  In this work, we slightly abuse the notation of \cite{ks92} and use $\Gamma^*(\Pi)$ to denote the minimal model of $\Pi$. Here, consider $\Gamma$ to be a function that returns a model of a given $\Pi$ and $\Gamma*$ to be a convergence of $\Gamma$ over multiple applications, that returns the minimal model.

\noindent\textbf{Abductive Inference Framework}
A specific logic-based abduction can be formally described as: \\
Consider a logical theory $\program$ which encodes a particular domain, a set $O$ for observations described by a set of atomic formulas, and a
set $H$ of (usually atomic) formulas containing possible individual hypotheses,
find an explanation (or solution) for $O$, that is, a suitable set $E  \subset  H$ such that
$\program \cup E$ is consistent and  $\program \cup E \models O$. 

For our use-case, for a given an agent $agt$, initial conditions $\Pi_{init}$, behavioral rules $\Pi_{behav}$, and ground-truth trajectory $\tau_{agt}$, \\ $\langle agt, \Pi_{init}, \Pi_{behav}, \tau_{agt} \rangle$ is the abduction problem. The goal is to find an explanation $\Pi_{pred}$ for $\langle agt, \Pi_{init}, \Pi_{behav}, \tau_{agt} \rangle$.

Here, we consider $\Pi_{pred}$ to be $E$, $\Pi_{behav} \cup \Pi_{init}$ to be $\program$, and  $\tau_{agt}$ to be $O$. As seen in Section~\ref{sec:abduc}, $\program \cup E$ is consistent and  $\program \cup E \models O$. The intuition behind the latter is from the transitive property of entailment [For any formula or a set of formulae, say $A, B, C$, if $ A \models B$, $ B \models C$, then $ A \models C$.], as $\Pi_{behav} \cup \Pi_{init} \models \Pi_{pred}$ and $\Pi_{pred} \models \tau_{agt}$.

\section{Appendix}{\bf Additional Experiments with external ground truth data}
\label{app:dgv}

While we are not aware of any academic work that uses ground truth for actual dark vessels â€“ the setup we proposed is adapted our use-case from the prior work in the area~\cite{dlbaseline,dstnet,txlstm, tf, tf2, tp}, where they mask the historical trajectory to extract input and ground truth.  This limitation is likely due to the requirement for non-AIS data to conform with the ship location. That said, our industry partner has provided us with several exemplars where they had confirmation based on an external source where they have verified AIS tampering.  They have provided us four such trajectories.  We did an experiment with this data and following the table~\ref{app:tab:dgv} of the area needed to cover the tagged dark activity along with fraction of area of top-k regions needed to cover the doppler tagged dark activity out of the search space for four test cases.  Here the model was trained in the normal way (with standard trajectories). 

\begin{table}[h!]

\begin{tabular}{|l|l|}

\hline
\textbf{Test Sample} & \textbf{Area in $Km^2$ (Percent of possible area)} \\ \hline
1                    & 30.11 (11)                                                        \\ \hline
2                    & 28.70 (9)                                                         \\ \hline
3                    & 12.64 (4)                                                         \\ \hline
4                    & 54.41 (17)                                                        \\ \hline
\end{tabular}
\caption{Coverage of tagged dark activity: Proportion of area required to encompass Doppler-tagged dark activity and fraction of area from top-k regions within the search space across four test cases.}
\label{app:tab:dgv}
\end{table}

