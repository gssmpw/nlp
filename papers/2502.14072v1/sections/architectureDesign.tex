\section{Architecture Design} 
\label{sec:design}

%Trazer aqui quais são os passos do processo da Hoffmeister e descrever o processo com base nos passos.
In conformance with the best practices of the state-of-the-art software architecture design (and analogously to a prior work developed by some of the authors \cite{TeixeiraL2020}), we followed the process proposed by Hofmeister \cite{HOFMEISTER2007} to drive the design of our software architecture. The model consists of three well-defined steps: (i) Analysis, (ii) Synthesis, and (iii) Evaluation, discussed as follows.

\begin{figure*}[ht]
\centering
\includegraphics[scale=0.6]{images/IllustrativeScenario.png}
\caption{Illustration of the Motivational Scenario on Fake News processing. Extracted from Private Technical Report \cite{techReport}.}
\label{fig:scenario}
\end{figure*}

\subsection{Step 1: Analysis}

This step receives, as inputs, a description of the context and the architectural concerns. As a result, the problems that the architecture solves are then found, also known as Architecturally Significant Requirements (ASR).

\subsubsection{Scenario description}

Figure \ref{fig:scenario} illustrates the motivational scenario. Ideally, a solution for fake news should have undeniable access to monitor all the news published in a diversity of social networks (e.g. X, Facebook, Instagram, TikTok), communication platforms (e.g. WhatsApp and Telegram), and portals (e.g. YouTube, News Portals and others) in a diversity of formats (text, audio, video and images) (\textbf{Step 1}). Once suspicious content is detected, it should be collected by the tool and made available for analysis (\textbf{Step 2}). The analysis (\textbf{Step 3}, called as \textit{fact-checking}) can be done under two perspectives: manual (by human fact-checkers, which can be independent freelancers or people of renowned reputation linked to fact-checking agencies) and/or automatic (by AI techniques, such as sentiment analysis, information retrieval, natural language processing - NLP, and machine learning - ML). Both approaches can be performed in parallel to double-check the result (true, false or biased) before it is delivered, enhancing the confidence of the final deliberation.

%Machine Learning mechanism is not described here
In the automatic approach, the first step is a crawling stage (\textbf{Step 4}) to search for similar or the same news in public portals (with recognized credibility), repositories of labeled news in public agencies and also in the blockchain of the system, since that publication may have already been previously labeled. Likewise, it triggers the automatic processing mechanism (\textbf{Step 5}). This mechanism automatically extracts information from the news, recognizing typical terms and expressions in sensationalist texts. Once many of those attributes are found in a single news, it receives a propensity score of falsehood, ie., a score that varies from 0 to 1; the closer the score is to 1, the more likely the news is false. Once the result is delivered, the news is labeled and persisted in the blockchain (\textbf{Step 6}), with the result also being delivered to the fact-checkers in case they are still investigating it.

In the manual approach, human fact-checkers analyze the suspicious news, searching for evidence that show the news is false. A voting process then takes place according to a consensus mechanism supported by smart contracts. Several consensus mechanisms exist; it can be a simple majority or a more intricate formula that expresses the credibility of the source and the effectiveness of the fact-checkers in prior judgments on fake news. Each available and involved fact-checkers vote on the likely fakeness of that news and explain/rationale that justifies/supports his/her decision. Once the consensus is reached, the decision is registered, the news is labeled and persisted in the blockchain.

In both cases (manual and automatic), the result can be spread on social networks to prevent other people from believing that the news is true. % Instagram, for instance, already implements this type of mechanism, labeling a publication as false with an explanation and providing the agency that classified it as false.
Crypto tokens can also be implemented on top of the blockchain so that fact-checkers can be rewarded for their services in crypto assets.

\subsubsection{Architectural concerns}

%\red{Trazer para cá os levantamentos de requisitos que temos feito. Focar na parte de blockchain, IA será uma caixa-preta. Trazer do documento que fiz e do doc do Samuel.}

Regarding the blockchain, the main objective of the system is to provide a decentralized Proof-of-Concept (PoC) solution that meets the following main functionalities: \textbf{offering a voting mechanism for fact checkers} and support \textbf{security, provenance and immutabiliy}. %Labeling on this secure network can be done by experts with an unblemished reputation.

\subsubsection{Architecturally Significant Requirements (ASR)}

As mentioned earlier, ASR are the problems that the architecture must solve. They are a subset of the requirements that must be met before the architecture can be considered ``stable''. For each Significant Macro Requirement (SMR), respective ASRs can be derived. Next, we discuss the requirements and their respective ASRs.

\noindent\textbf{[SMR1] Interoperability} - It refers to the degree to which two or more systems, products or components can exchange information and use the information that has been exchanged \cite{ISO/IEC2010}. The consensus/voting mechanism has to be interoperable. The system should externalize an API (as reported in \cite{DiCicco2020}) for invoking services such as querying the base of news labeled as true, suspicious or false. Under this perspective, the system should be able to:
	
\begin{itemize}
            \item\textit{[ASR1] Communicate with external agencies and repositories:} The system should be capable of querying public repositories of fact-checking agencies and public portals;
            \item\textit{[ASR2] Receive request for capabilities/information}: The system should also be capable of providing an interface for queries and for other developers to create solutions, forming an ecosystem;
\end{itemize}


\noindent\textbf{[SMR2] Performance and Real time} - The response time for returning a query to the public blockchain should not exceed a given threshold. Moreover, fact-checking agencies should be able to carry out their vote as soon as there is novel suspicious news. Consensus should also take no more than a given threshold. Under this perspective, the system should cope with the following ASR:
\begin{itemize}
            \item\textit{[ASR3] Vote about the news authenticity (True, False, Partial):} The system should support the fact-checkers to vote about the likely fakeness of a publication and also include explanation/decision justification field, mentioning the source, social network analysis, and the type of manipulation, such as a content taken out of context and others;

\end{itemize}
\\\\
\noindent\textbf{[SMR3] Scalability:} It must be possible to expand the user list to allow access to hundreds or thousands of fact checkers. Public blockchain query users can reach millions of hits and the application should be accordingly adjusted.	
\\\\
\noindent\textbf{[SMR4] Descentralized/Modularity:} In a decentralized blockchain network, no one has to know or trust anyone else. % Each member in the network has a copy of the exact same data in the form of a distributed ledger. 
If a fake news vote's ledger is altered or corrupted in any way, it will be rejected by the majority of the fact-checkers in the network. The solution architecture must be modular in the sense of allowing functionality to be accordingly accommodated. \\ % For instance, there should be a specific module to take care of the rewarding of fact checkers based on crypto.
\\\\
\noindent\textbf{[SMR5] Integrity/Immutability and Traceability:} All news labeled and persisted on the public blockchain must be backed by those persisted on the private blockchain.
\begin{itemize}
            \item\textit{[ASR4] List Suspicious News:} The system should be capable of listing emerging publications with suspicious content;
            \item\textit{[ASR5] Dispatch news classification order}: The system should notify fact-checkers about the need to judge the veracity of one or more news and trigger the classification process in both manual and automatic approaches;
            \item\textit{[ASR6] Create a unique hash for the news:} The system should receive the news in any format (image, video, text or audio) and generate a correspondent hashing code to uniquely identify it in the system; 
            \item\textit{[ASR7] Obtain news metadata:} The system should collect relevant metadata from the news, such as creation date, content, author, source platform and others;
\end{itemize}
\\\\
\noindent\textbf{[SMR6] Security:} The system should be secure for all the potential users: fact checkers, news consumers, and agencies.  
\begin{itemize}
            \item\textit{[ASR8] CRUD Fact-Checkers:} It should be possible to Create, Read, Update, and Delete fact-checkers in the system database;
            \item\textit{[ASR9] Login (for Fact Checker)}: The access to the system should only be granted under credentials;           
\end{itemize}
\\\\
\noindent\textbf{[SMR7] Rewarding:} The system should encourage the participation of fact-checkers (remuneration in crypto or some other asset - currency, social asset, etc. - taking care to make the entity vote responsibly, trying to equalize the accuracy of voting with the desire to do quickly to gain more financial return with each contribution; think about the degree of reliability/credibility, etc.)




\subsection{Step 2: Synthesis}

This phase is the core of architecture design. The output of this activity is a set of architectural alternatives to be assessed against the prioritized problems. Thus, it moves from the problem to the solution space \cite{HOFMEISTER2007,TeixeiraL2020}. 
In the next sections, we delve into the details of the two raised candidate architectures conceived at this step.
\\ %The initial step involves selecting an architectural structure that helps an architect meet the essential requirements. Structures represent architecture's primary engineering leverage points, and there are three main categories of structure: Module, Component-and-connector (C\&C), and Allocation \cite{Bass:2012}. Modules concern functional responsibility and there is less emphasis on how the resulting software manifests itself at runtime. Allocation structures incorporate decisions about how the system relates to non-software parts (e.g. CPUs, file systems, networks, development teams etc.). 
%Some architectural design decisions (ADD) should be shared between the two candidate architectural solutions, which are:
%\\\\
%\noindent\textbf{[ADD1] The architecture should be structured using C\&C.} This architectural organization fosters modularity and maintainability, besides facilitating interoperability, structuring the system as a set of elements that have runtime behavior (components) and interactions (connectors) \cite{Bass:2012}, which takes us to the next decision.
%\\\\
%\noindent\textbf{[ADD2] The architecture should be established upon microservices.} Different components and subsystems of the major system are being developed by different distributed teams fluent in different technologies. Hence, their communication is feasible via microservices.

\subsubsection{Candidate Architectural Solution 1: Hyperledger Besu}

The main objectives of the development of this candidate software architecture were to (i) Create a component-structured architecture, highlighting the use of smart contracts connected to a \textit{blockchain Besu Ethereum} network, (ii) Develop an API capable of verifying and validating news, enabling fact-checkers to distinguish between true information and \textit{fake news}, (iii) Demonstrate the practical feasibility of the project, using \textit{Hyperledger Besu} technology to implement the \textit{blockchain} network and (iv) Contribute to the creation of a more trustworthy and safe environment on social networks, promoting responsibility in the dissemination of information and combating the negative impacts of \textit{fake news}.

\begin{figure}[hbt]
  \centering
  \includegraphics[scale=0.20]{./images/diagrama.png}
  \caption{Diagram for the candidate architectural design with Hyperledger Besu.}
  \label{fig:diagrama}
\end{figure}

\\
\noindent\textbf{Rationale for Using Hyperledger Besu.} \textit{Hyperledger Besu} is an open source Ethereum client developed by \textit{Pegasys}, a subsidiary of \textit{ConsenSys}. Besu stands out as a solution adapted for enterprise environments, covering use cases in both public networks as private with permissions. Its fundamental purpose is to provide businesses with an affordable and efficient platform for creating and managing decentralized applications (\textit{dApps}). Among its notable features are (i) support for networks using the Ethereum protocol, both public and private, (ii) corporate governance tools such as smart contract management, as well as features dedicated to scalability, and (iii) privacy protection and fluid integration with other networks blockchain, such as \textit{Quorum} \cite{Dalla2021}.

\textit{Hyperledger Besu} also relies on EVM (\textit{Ethereum Virtual Machine}) implementation, also providing flexibility. %Furthermore, it is capable of operating on test networks, including \textit{Sepolia} and \textit{Görli}, allowing robust validation of its functionalities in controlled environments. 
In terms of consensus, it offers a variety of algorithms, such as \textit{Proof of Stake}, \textit{Proof of Work} and \textit{Proof of Authority} (\textit{IBFT 2.0, QBFT and Clique}), providing options adaptable to the specific needs of each scenario. \textit{Hardhat}, presented as a toolkit, is a suite of tools designed to optimize the creation of smart contracts, providing a significant increase in productivity during development. Developed in \textit{Node.js}, it is essential to ensure that \textit{Node} is previously installed for its correct functioning \cite{Jain2023}.
The development environment encompasses several specialized components such as editing, compiling, debugging, and deploying smart contracts and decentralized applications (\textit{dApps}). The harmonious integration of these elements aims to create a complete and adequate development environment.
Among the various \textit{blockchain} platforms available, the choice of \textit{Hyperledger Besu} for this candidate architecture is justified by several distinctive characteristics \cite{hasan2020blockchain}, including (i) Modular Architecture, (ii) Security, (iii) Flexibility in Consensus Choice, (iv) Optimized Performance and Monitoring, (v) Scalability, and (vi) Support for Interoperable Protocols \cite{Alba2023, Fan2022}.
\\
\noindent\textbf{Architectural Design.} The solution has been meticulously developed to establish a local \textit{blockchain} environment, utilizing the \textit{framework} \textit{Hyperledger Besu} to compile and deploy smart contracts through \textit{Hardhat}. Additionally, a \textit{backend} was designed to interact with the \textit{blockchain}, and the features were validated and integrated with the \textit{Postman} tool. The vital process for executing the solution begins by configuring the local environment. The supplied \textit{bash} script configures the \textit{Besu} local network, employing the IBFT consensus algorithm. This environment consists of \textit{Docker} containers representing \textit{Besu} nodes, which are cleaned and configured before the process starts. Each node has its data directory, ensuring independence and local persistence.

\noindent\textbf{Configuration of Nodes in the Besu Network.} The \textit{blockchain} local environment is made up of several nodes, each one playing a specific role in the \textit{Hyperledger Besu} network. ``besu-node-0'' acts as the bootnode, coordinating the initialization and applying the IBFT consensus algorithm for reliability. ``besu-node-1, besu-node-2, besu-node-3'' are participating nodes, maintaining local copies of \textit{blockchain} and contributing to consensus, also using the IBFT algorithm. Communication occurs via the \textit{Docker} \textit{``besu\_network''} network, facilitating the exchange of information. Each node has its data directory, ensuring independence and local persistence, facilitated by \textit{Docker} volumes. Nodes expose RPC and HTTP interfaces for external interactions, such as smart contract compilation and deployment, using custom ports for efficiency. These features provide a robust environment for developing, testing, and effectively interacting with smart contracts on \textit{blockchain} \textit{Hyperledger Besu}, emphasizing stability and reliability.
\\\\
\noindent\textbf{Compilation and Implementation of Smart Contracts with Hardhat.} After the initialization of the local environment, \textit{Hardhat} takes on the responsibility of compiling and deploying \textit{Ethereum} smart contracts. The deployment script, exemplified by a contract called ``FakeNewsValidator'', is essential to this process. \textit{Hardhat} plays a crucial role in ensuring smooth integration between the local environment and the development cycle. Additionally, during compilation, \textit{Hardhat} generates essential folders such as \texttt{artifacts} and \texttt{cache} that store vital information including \textit{ABI (Application Binary Interface)} and  \textit{bytecode}.

%The dedicated configuration file (\texttt{hardhat.config.ts}) plays a key role in setting the Solidity language version and configuring the local network. This file is vital for the correct execution of the deployment script. In parallel, a specific configuration file for the IBFT consensus algorithm is essential, providing crucial details such as \textit{chainId}, \textit{blockperiodseconds} and other parameters that ensure proper configuration of the local network.

%Creating the \texttt{artifacts} and \texttt{cache} folders during the compilation process not only organizes essential information, such as \textit{ABI}, but also contributes to efficient development management. These folders facilitate access and use of \textit{ABI} in subsequent stages of development and deployment, ensuring the consistency and reliability of the local blockchain based on the \textit{Hyperledger Besu} framework.

%% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\noindent\textbf{Development of the Backend and API for Querying Smart Contracts with Express.js.} The \textit{backend} of the solution was developed using the \textit{Express.js framework}, acting as an HTTP server for interaction with the \textit{Besu blockchain}. The \textit{Web3.js} library is incorporated into the code to enable efficient communication with the \textit{Besu} local network. \textit{Express.js} provides a foundation for building the \textit{backend}, allowing  to create a robust HTTP server. This server is essential to facilitate interaction between users and the \textit{blockchain}, enabling exposing data and functionalities through an \textit{API}. The \textit{API} developed in \textit{backend} offers an interface for querying deployed smart contracts. The /check-news/:newsId endpoint allows users to obtain specific information about a news story by validating input parameters to ensure the integrity of requests.
Furthermore, interaction with smart contracts is facilitated by the use of \textit{ABI (Application Binary Interface)} and the contract address. The \textit{ABI} is an interface that defines how a contract's methods can be called, while the contract address represents the specific location of that contract in the \textit{blockchain}. These elements are crucial for the correct communication and execution of transactions on \textit{blockchain}. \textit{Web3.js} uses this information to create calls to contracts and obtain the desired results, thus providing a simple and effective interface for end users.



%% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -

\noindent\textbf{API Testing with Postman.} Validation of the solution's operation and integration between components are tested with the \textit{Postman} tool. This tool allows sending HTTP requests to \textit{endpoint /check-news/:newsId}, simulating user interaction with the \textit{API} developed. These tests contribute to verifying the integrity of \textit{API} responses and confirming the correct execution of smart contracts on the local \textit{blockchain}. A proof-of-feasibility of this architecture was recorded, and it is available in external video\footnote{Video: \url{https://youtu.be/QWCeN3VIt1g}}. The implementation is also available in GitHub\footnote{Project: \url{https://github.com/CMedrado/Final}}.

%% - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
%In summary, the proposed architecture integrates \textit{Hyperledger Besu}, \textit{Hardhat}, \textit{Express.js} and \textit{Postman} to create a local \textit{blockchain} environment, develop smart contracts, and provide a \textit{API} for interaction. This architecture offers a solid foundation for developing and testing decentralized applications in a controlled environment. 

 \begin{figure}[!hbt]
  \centering
  \includegraphics[scale=0.44]{./images/ArquiteturaCeC.png}
  \caption{Diagram for the candidate architectural design with Hyperledger Fabric. Extracted from Private Technical Report \cite{techReport}.}
  \label{fig:diagrama2}
\end{figure}


\subsubsection{Candidate Architectural Solution 2: Hyperledger Fabric}

This candidate architecture uses Hyperledger Fabric, instead.

\noindent\textbf{Rationale for Using Hyperledger Fabric.} Hyperledger Fabric is an open-source framework for private blockchains managed by the Hyperledger Foundation. The platform provides a fully-featured and modular architecture, allowing flexibility and expansion depending on the use case. One distinctive characteristic of Fabric is its concept of organizations, which makes it more suitable for enterprise situations. Organizations own components that interact in the network, peers, and orderers (as shown in Figure \ref{fig:diagrama2}). Each component has its responsibility within the lifecycle of a transaction. \cite{fabric-article}

Hyperledger Fabric supports smart contracts, often called chaincodes, written in general purpose languages, namely Go, Java and JavaScript \cite{fabric-article}. This lowers the development barrier and allows language-specific resources to be used in implementation, enabling more complex applications to be developed.
 Many blockchains implement a *Order-Execute* sequence for transactions, whereas Fabric implements a *Execute-Order-Validate* sequence, which enables much more secure and consistent blocks with finality. Hyperledger Fabric implements the concept of channels, where each channel has its own configuration, member organizations and hosts its ledger. Organizations can be part of multiple channels simultaneously, allowing a peer to host multiple ledgers without mixing different data scopes. This means that, unlike most blockchains, a node can be a part of multiple ledger-sharing channels, creating an extensive network \cite{fabric-article}. Fabric also implements what are called private data collections (PDCs). PDCs are environments for private data registration in a given chaincode. Only organizations that are members of the collection are given read access to data. The data is shared peer-to-peer via a gossip protocol and is never registered in the ledger. The ledger registers the hash of the private information to allow for proof of registry by parties involved \cite{fabric-article}. %As opposed to privacy groups in Hyperledger Besu, PDCs are built-in to Fabric and allow for more flexibility with configurations like “Member-only Reads and “Member-only Writes”, allowing private data to be shared by organizations that are not part of a PDC.

CC-Tools is a Hyperledger Labs open-source project and part of the toolkit for application development. CC-Tools provides features regarding asset, data type, event and transaction development. CC-Tools allows for more complex chaincodes while decreasing development time. This project supports chaincodes written in Go language and fully compatible with all major Fabric long-term support (LTS) versions. Hence, several features of Hyperledger Fabric can be listed as justifications for its choice, such as (i) Modular architecture, (ii) Smart contract flexibility, (iii) Security, (iv) Consensus, (v) Privacy, (vi) Performance \cite{Hyperledger2023Benchmarking}, (vii) Scalability, and (viii) Monitoring.

\noindent\textbf{Architectural Design.} Hyperledger Fabric provides all the features needed to create an entire network architecture for the proposed application. Chaincode implementation was done using the CC-Tools Hyperledger Labs project, where a CC-Tools-Demo repository was used as a base template for the implementation. This repository provides a working test network with three application organizations with one peer each and an ordering organization with one orderer, as shown in Figure \ref{fig:diagrama2}. The organizations are members of a channel where the chaincode proposed is instantiated. Three client APIs are also provided, tied to identities for each one of the application organizations.

\begin{figure}[hbt]
  \centering
  \includegraphics[scale=0.33]{./images/fabric-base-arch.jpg}
  \caption{Diagram for the candidate architectural design with Hyperledger Fabric. Extracted from Private Technical Report \cite{techReport}.}
  \label{fig:diagrama}
\end{figure}

\noindent\textbf{Chaincode implementation.} The chaincode is implemented by defining the core assets and transactions within the structure provided by CC-Tools. Assets act as the data mapping that will be registered, that is, the actual properties that will be registered. Transactions implement the business logic that will act on ledger data, either reading from it or writing to it. %Asset implementation is made under the directory `chaincode/assettypes` and transactions are implemented under the directory `chaincode/txdefs`. 

\noindent\textbf{API implementation.} The client API is implemented in Go using the Fabric SDK package for interaction with the ledger. This API utilizes a certificate and private key issued by the CA of a trusted organization in the channel. These credentials authorize the API to interact with network. The API utilizes the Gin package for creating a REST API that exposes SDK functionality. For compatibility with older and newer versions of Fabric, the API implements endpoints that utilize a legacy SDK for transactions and a newer Gateway SDK that uses the peer Gateway Service, that facilitates transaction submission. 

 Inspired by Figure \ref{fig:scenario}, we depict Figure \ref{fig:diagrama2},  showing the component-and-connector (C\&C) view to represent our second candidate architectural solution, discussed as follows. 

\noindent\textbf{Automatic FactChecking Subsystem} - This is the subsystem responsible for conducting the web crawling in public portals, to search in the blockchain and conduct automatic analysis based on AI in the selected content. \textit{Matches ASR7}.

\noindent\textbf{Human Fact-Checkers Subsystem} - This subsystem involves the management of the database of human fact-checkers, the voting and consensus mechanism (materialized in a smart contract), and the blockchain itself with its interface to interoperate, externalize access and receive persistence demands. \textit{Matches SMR3, ASR4, ASR5, ASR6, ASR8, ASR9 and SMR7}.

\noindent\textbf{Voting and Consensus Mechanism} - This component manages the voting and consensus between the human fact-checkers to decide the legitimacy of the content of the news being analyzed. It is a component within the Fact-Checkers Subsystem. \textit{Matches ASR3}.

\noindent\textbf{Secure Social Network} - This component will be implemented to support a secure social network. \textit{Matches SMR6}.

%\noindent\textbf{SoS Contracts/Negotiation Component} - This component is specifically responsible for negotiating different SoS that the constituent can be part of. It enables (i) the system registration as a CS, (ii) the capabilities it will provide to the SoS, (iii) missions it can contribute, (iv) the benefits that it will obtain for joining the SoS, and mainly its operational independence degree. \textit{Matches ASR10 and ASR11}.

%\noindent\textbf{Constituents Negotiation Component} - This component is specifically responsible for dealing with negotiations to different CS that the constituent can interoperate. It enables the system to negotiate its managerial independence degree, regarding the information provided to others organizations, and to coordinate how they will collaborate with each other to accomplish the SoS missions. \textit{Matches ASR4 and ASR11}.

%\noindent\textbf{Engines interface\footnote{Interface in this context represents a service performed by a class or component and aggregation of public methods/functions. It is not graphical interface.}} - This interface enables the sub-system Car Engines to receive stimuli from Autonomous Car and SoS Constituent sub-systems. If the SoS needs some sensor information for example, the SoS Constituent sub-system will request the information for the Car Engine sub-system. \textit{Matches ASR8 and ASR9}.

%\noindent\textbf{Communication Component} - Technology to enable the system to communicate with the external world and exchange information and capabilities. Basically, this component is responsible for the establishment of the connections between the car and other systems that compose a SoS. \textit{Matches ASR2, ASR3 and ASR5}.

\noindent\textbf{Services interface} - This part, not explicitly captured in the model of Figure  \ref{fig:diagrama2}, regards to the interfaces externalized for client consumers and software developers that can access and build applications over our public infrastructure, besides the hooks used to consult the external databases of public portals and social networks. \textit{Matches ASR1 and ASR2}.

%\noindent\textbf{Communication interface} - This interface enables the sub-system SoS Constituent to send information and capabilities, and also request information and capabilities to SoS and SoS Constituents. \textit{Matches ASR9}.

%\noindent\textbf{External interface} - The car as a CS can receive and send information. Hence, it needs two external interfaces, a ``server'' and a ``client'' interface. \textit{Matches ASR3}.

%\noindent\textbf{User interface} - This interface enables the car system to receive requests and information by its user. User goals are the car system own goals. \textit{Matches ASR10, ASR11 and ASR12}.

\noindent\textbf{Decision.} Given the two candidate architectures and based on the prioritized requirements, we preferred the second solution, based on Hyperledger Fabric. Fabric's modular architecture allows for a high degree of customization. This modularity enables organizations to tailor the blockchain to their requirements, including endorsement policies, membership services, and network setup. Such flexibility is paramount for applications with unique needs or operating in highly regulated industries.
% In contrast, Besu, while offering some degree of customization, primarily adheres to the Ethereum protocol standards, which might not be as flexible adaptations.
Furthermore, Hyperledger Fabric provides enhanced transaction confidentiality through its architecture, which supports the execution of transactions within a private context. This is facilitated by its unique approach to channels, where a subset of participants can conduct transactions privately, a particularly appealing feature for applications requiring confidentiality in their operations. Besu offers privacy features, such as private transactions and privacy groups. However, these are built on top of a platform initially designed for public network compatibility, making Fabric's privacy features more robust for some applications.
Additionally, Hyperledger Fabric supports using general-purpose programming languages for crafting smart contracts. Unlike Besu, where the EVM specifications constrain smart contract capabilities, Fabric's chaincode can exploit the comprehensive functionalities offered by languages like Go and their extensive libraries. This distinction allows for a broader and more versatile development environment in Fabric, catering to complex enterprise needs beyond the scope of what Solidity and the EVM can provide on Besu. Step 3, Evaluation, is discussed in the next section.
