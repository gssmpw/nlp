\section{Related Work}
\label{related_work}

%In this section, we discuss previous research relevant to our study. 


\paragraph*{\textbf{Analyses/Repair for Temporal Properties}} 

%Most existing approaches for proving program properties expressed in CTL have limitations upon the type of the infinite-state programs, such as pushdown systems \cite{DBLP:journals/iandc/EsparzaKS03}, parameterized systems \cite{DBLP:conf/cav/EmersonN96}, timed systems \cite{alur1994theory}. 
Existing approaches for proving CTL properties either do not 
%reliably 
support CTL formulas with arbitrary nesting of universal and existential path quantifiers 
%DBLP:conf/cav/GurfinkelWC06,
\cite{DBLP:conf/cav/CookKV11}, 
or support existential path quantifiers indirectly by building upon the prior works 
for proving non-termination \cite{DBLP:conf/popl/GuptaHMRX08}, or by considering their universal dual (\terminator) \cite{DBLP:conf/fmcad/CookKP14}. In particular, the latter approach is problematic since the universal dual of an existential ``until" formula is non-trivial to define. 
\function~\cite{DBLP:conf/sas/UrbanU018} presents a CTL properties analyser via abstract interpretation. It deploys a backward analysis to propagate the weakest preconditions, which make the program satisfy the property. While being the first work to deal with a full class of CTL properties, it has several sources of the loss of precision, such as the \emph{dual widening} \cite{DBLP:conf/tacas/CourantU17} technique for proving the termination of loops; as well as the alternatively applied over/under approximation to deal with existential/universal quantifiers. 
ProveNFix~\cite{song2024provenfix} proposes a repair framework guided by linear-time temporal logic. It relies on user-provided \emph{future conditions} for specific APIs, and cannot handle liveness properties whose counterexamples typically involve traces of infinite length. 
%Our work relies on loop summaries to represent infinite computations and requires only one single CTL specification to capture the desired behaviour of the whole program. 
Furthermore, ProveNFix generates patches by only inserting/deleting function calls, while \toolName can repair on the statement level, such as modifying assignments. 



%%focusing only on finite state transitions among \emph{events} generated by the primitive API calls and handles loops via unrolling. 
%In contrast, our work achieves a more precise temporal analysis through loop summaries where events are atomic propositions upon program variables, and targets on infinite state programs. 



%leverages the continuously advancing techniques upon ranking function synthesis  \cite{DBLP:conf/tacas/ColonS01,DBLP:conf/vmcai/PodelskiR04,bradley2005polyranking,DBLP:conf/concur/NeumannO020}, thus contributing to a more efficient and precise CTL analysis. 

%Notably, the experimental result of \function shows that none of the temporal analysis tools (among T2, \ultimate, and \function) subsumes the others. 
%This observation highlights the collaborative power of their combination, which proves to be more potent than any of the tools used in isolation. 



%Apart from the temporal property analysis with CTL, an earlier approach  \cite{DBLP:conf/popl/CookGPRV07} reduces the LTL model checking problem to fair termination checking. For the same purpose, \ultimate \cite{DBLP:conf/cav/DietschHLP15} presents a new approach exploiting the fact that constructing a proof of unsatisfiability is less costly than synthesizing ranking functions. 
%Specifically, it selects finite prefixes of a path and checks their infeasibility before considering the full infinite path, verifying the liveness property with finite prefixes without the construction ranking functions. 
%Compared to \cite{DBLP:conf/popl/CookGPRV07}, \ultimateshort can be seen as an improvement as it only uses fair termination checking when necessary, which avoids many (more costly) termination checks. 


\paragraph*{\textbf{Loop Summarization and Conditional Termination}}
Loop summarization is widely used in termination analysis \cite{DBLP:journals/toplas/ChenDKSW18,DBLP:conf/tacas/TsitovichSWK11,DBLP:journals/tse/XieCZLLL19}, primarily focusing on summarizing the terminating behaviours. Additionally, partial loop summarization has been applied in dynamic test generation \cite{DBLP:conf/issta/GodefroidL11}, where the loop structure and induction variables are identified on the fly. 
However, little attention has been given to summarizing non-terminating program executions. 
The construction of our dual summaries is based on the concept of \emph{conditional termination} presented in previous works \cite{DBLP:conf/cav/CookGLRS08,DBLP:conf/tacas/BorrallerasBLOR17,DBLP:conf/pldi/0001K21}. We extend this approach by computing the preconditions that lead to non-termination and only proceeding with CTL analysis when all paths yield conclusive results, which is shown practical for verifying both safety and liveness properties, effectively separating termination analysis from temporal analysis. 
We share an algebraic perspective with previous work \cite{DBLP:conf/pldi/0001K21}, where $\omega$-REs are generated to represent the paths through a program. However, their approach represents the cycles in the CFG directly into $\omega$ formulas and then focuses on a specific termination analysis through recursion on that expression. In contrast, we construct $\omega$ formulas only after proving that the cycles (conditionally) lead to non-terminating behaviours. 
%and associate the non-termination precondition with the $\omega$ formulas. 



%involves using  to represent the cycles in the CFG



%DBLP:journals/jacm/Tarjan81b,


%Similar representations to our \code{\omegaRE} have been deployed in prior works \cite{DBLP:conf/pldi/CookPR06,DBLP:conf/cav/HeizmannHP14,DBLP:conf/pldi/0001K21} to serve intermediate steps, such as computing the ranking function for terminating loops. 
%computing the ranking function, in proving termination. 



%the CTL analysis stands alone away from the termination analysis and takes advantage of existing complete algorithms for various classes of ranking functions, such as linear, linear-lexicographic, nested, multi-phase, etc. 
%In addition, it can further deploy the tools for more complicated ranking functions, such as for polynomial loops; thus, it handles more real-world programs extensively. 
%\syh{to be revised}


%Furthermore, to ease the pain of providing the ranking functions, we also formalize a simple (but sound) procedure for inferring them when possible. 
%Note that the soundness of our approach does not reply to the precision of the provided/inferred ranking function, yet it does affect the completeness, \ie   there exists a patch, but we cannot find it. 
%Our approach also draws similarities to prior works \cite{DBLP:conf/pldi/0001K21,DBLP:conf/pldi/CookPR06}, we use $\omega$-regular expressions as the intermediate representation of the infinite behaviors. However, one of the differences is we summarise the behaviors for finite time trace repetitions instead of the Kleene star $\star$ commonly deployed previously. 









\paragraph*{\textbf{Logic Programming for Temporal Analysis}}

To enable the expressivity for CTL properties using Datalog, prior work \cite{gottlob2002datalog}
presents Datalog LITE, a new deductive query language. %Datalog LITE is a variant of Datalog that uses stratified negation, restricted variable occurrences, and a limited form of universal quantification in rule bodies. 
We borrow their encoding of the AF operator, 
%(cf. \figref{fig:AF_encoding}), 
which requires the finiteness of the input Kripke structure. 
This encoding also follows from the facts that, over finite structures, CTL can be embedded into transitive closure logic \cite{DBLP:conf/cav/ImmermanV97} and that transitive closure logic has the same expressive power as stratified linear Datalog programs \cite{DBLP:journals/tcs/ConsensM93,DBLP:conf/csl/Gradel91}. 
Prior work~\cite{rocca2014asp} encodes CTL analysis in ASP using ``findall" to encode AF. However, "findall" is a logical impurity requiring second-order logic programming, which is not supported by declarative Datalog. This makes it incompatible with SEDL-based repair solutions that operate on first-order logic formulae. In contrast, our work encodes AF using Datalog with stratified negation, enabling greatest fixpoint encoding without relying on ``findall."

%In parallel with the above mentioned works, \cite{DBLP:journals/tcs/GuessarianFAA03}
%provides a direct and modular translation from CTL and the Modal $\mu$-calculus to Monadic inf-Datalog, with built-in predicates. Inf-Datalog has slightly different semantics from the conventional Datalog least fixed point semantics in that some recursive rules (corresponding to least fixed points) are allowed to unfold only finitely many times, whereas others (corresponding to greatest fixed points) are allowed to unfold infinitely many times. 



%a domain-specific
%language that makes it possible to write a range of SMT-based static analyses in a way that is both close to
%their formal specifications and amenable to high-level optimizations and efficient evaluation.
%Analyzers based on Datalog also gained popularity recently; for example, prior work \cite{DBLP:journals/pacmpl/Bembenek0C20} proposes Formulog, which extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas while ensuring that neither normal evaluation nor SMT solving goes wrong. Their 
%case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses. 


%Datalog-Defined Program Repair and 
%Prior work \cite{DBLP:conf/sigsoft/LiuMSR23} proposes to integrate program repair with Datalog-based analysis, which enables a general-purpose static program repair framework that targets a wide range of properties and programming languages. 
%It repairs the program by modifying the corresponding Datalog facts via a symbolic execution of Datalog. It is useful for properties that only involve the least fixpoints, such as null pointer exceptions or data leaks, without supporting the properties that involve a combination of the least and greatest fixed points, such as CTL. Our repair strategy in this work supports repairs guided by CTL properties by supporting the negations that can arbitrarily occur in the rules.   


% \vspace{-1mm}
\paragraph*{\textbf{Model Repair and Test-based Repair}}
Prior work \cite{DBLP:conf/ecai/DingZ06} proposed a CTL model update algorithm based on primitive operations and a minimal change criterion in Kripke structure models;  
%; the algorithm obtains a new model as similar as possible to the original one. 
%\cite{DBLP:journals/ai/CarrilloR14} introduced the concept of protection for dealing with the loss of satisfiability problem of a property while introducing changes in the new model. 
%\cite{DBLP:conf/nfm/ChatzieleftheriouBSK12} use an abstract model repair framework, under a 3-valued semantics of CTL. 
Subsequently, 
\cite{martinez2015ctl} present a  model repair solution for bounded and deadlock-free Petri nets, which  
%This approach repairs the model 
is guided by CTL specifications via two basic repair operations: modifying transitions and the truth value of atomic propositions. Both these operations can be reflected in our approach by deleting and adding/updating facts. 
%for atomic propositions for program variables. 
%However, it requires a re-analysis after the ``repaired'' model is generated, which means that produced patches are not always safe; in contrast, our approach produces patches without any re-analysis, if any. 
Prior work, \cite{DBLP:conf/memocode/AttieCBSS15} maps an instance of the repair program, \ie a Kripke structure model and a CTL property to a Boolean formula, and the satisfiability resulted from the SAT solver indicates a patch exists or not. When satisfiable, the returned model will be mapped to a patch solution to remove transitions/states. 
In \cite{DBLP:journals/ai/BuccafurriEGL99}, the repair problem for CTL is considered and solved using abductive reasoning. 
%Similar to test cases-based repair, 
Their method generates repair suggestions based on each concrete counter-example, which needs an iterated process to address all the counterexamples. 
%must then be verified by model checking, one at a time. 
Our approach also employs a repair-verify iterative process; however, it differs from previous methods by symbolically addressing all the CTL violations and progressively constructing source-code level patches during each iteration. 
Additionally, unlike model repair, which focuses on models, our approach is the first to target real-world programs and generate source-level patches. 


Our repair approach is distinct from the test-based repair methods  \cite{DBLP:journals/cacm/GouesPR19}, where overfitting often occurs because the test suite may not cover all possible program behaviours. To mitigate this issue, our approach analyzes all symbolic paths, ensuring that only patches which address all property violations are generated.



%\syh{and fix all the counterexamples}
%To the best of the authors' knowledge, this is the first work to provide the CTL repair solution at the source level. 
%We prove its usefulness using real-world benchmarks. 
%, which no prior work has achieved. 
%Instead of enforcing invariant annotations, we provide a way to compute summaries of loops based on an iterative process of refining the ranking functions. Thus, t
%Moreover, while this paper focuses on supporting Datalog repair with negations, we leave the repair for Datalog rules as a future work. 
