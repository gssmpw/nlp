%%
%% This is file `sample-acmsmall-submission.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `acmsmall-submission')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-acmsmall-submission.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1 
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
%manuscript
\documentclass[acmsmall,screen,review,anonymous]{acmart}
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

    

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmcopyright}
\copyrightyear{2023}
\acmYear{2023}
\acmDOI{XXXXXXX.XXXXXXX}

\usepackage{enumitem}



%%
%% These commands are for a JOURNAL article.
\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}



%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
\citestyle{acmauthoryear}

%\newcommand\figref[1]{Fig. \textcolor{blue}{\ref{#1}}}
%\newcommand\tabref[1]{Table \textcolor{blue}{\ref{#1}}}
%\newcommand\secref[1]{Sec. \textcolor{blue}{\ref{#1}}}
\usepackage{adjustbox}
\usepackage{wrapfig}
\usepackage[utf8]{inputenc}
\usepackage{textcomp}
\usepackage{proof}
%% \usepackage{lmodern}
%% cannot use above - loses many symbols
\usepackage{pmboxdraw}



\theoremstyle{definition}
\newtheorem{definition}{Definition}[section]

\newtheorem{theorem}{Theorem}[section]
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{lemma}[theorem]{Lemma}
% to handle unicdoes
%% \let\Bbbk\relax
%% \usepackage[smartEllipses]{markdown}
%% \usepackage[greek,english]{babel}

\DeclareUnicodeCharacter{2320}{/}
\DeclareUnicodeCharacter{23AE}{|}
\DeclareUnicodeCharacter{2321}{/}
\DeclareUnicodeCharacter{2572}{\textbackslash}
\DeclareUnicodeCharacter{2571}{/}
\DeclareUnicodeCharacter{3C6}{\textgreek{\textphi}}
\DeclareUnicodeCharacter{2080}{0}
\DeclareUnicodeCharacter{21D2}{$\rightarrow$}
\DeclareUnicodeCharacter{2200}{$\forall$}
\DeclareUnicodeCharacter{2217}{*}
\DeclareUnicodeCharacter{03C0}{$\pi$}
\newcommand{\cmark}{\ding{51}}%
\newcommand{\unk}{\bf{?}}%
\newcommand{\loopsummary}{\emph{{loop\_summary}}}


\newcommand{\shortNeg}{!} %\mathtt{Neg}
\newcommand{\RF}{\mathcal{RF}} 

\newcommand{\highlight}[1]{\colorbox{mGray1}{$#1$}}
\newcommand\sForAll[2]{\ForAll{#1}#2} % snappy version of \ForAll...\EndFor
\newcommand\sIf[2]{\If{#1}#2}          % snappy version of \If...\EndIf
\newcommand{\Datalog}{\mathbb{D}}

\newcommand{\SE}{\mathcal{E}}
\newcommand{\E}{\mathcal{T}}
\DeclareMathOperator{\concat}{{++}}
\newcommand{\seq}{\,;\,}
\newcommand{\s}[1]{\{#1\}}
\newcommand{\xmark}{\ding{55}}%

\newcommand{\nm}{p}%

\newcommand\CONTAIN{\sqsubseteq}
\newcommand\loc[1]{{\small\tt\textcolor{darkred}{#1}}}
\newcommand\repaircode[1]{{\color{green(html/cssgreen)}{{\bfseries +} {\ttfamily\,#1}}}}
\newcommand\faultyCode[1]{{\color{darkred}{{\bfseries -} {\ttfamily\,#1}}}}
\usepackage{amsmath}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\newcommand{\algorithmiccontinue}{\textbf{continue}}
\newcommand{\Continue}{\State \algorithmiccontinue}
% New definitions
\algnewcommand\algorithmicswitch{\textbf{match}}
\algnewcommand\algorithmicswith{\textbf{with}}

\algnewcommand\algorithmiccase{\hspace{-8pt}\relax\textbf{|}}
\algnewcommand\algorithmicassert{\texttt{assert}}
\algnewcommand\Assert[1]{\State \algorithmicassert(#1)}%
% New "environments"
\algdef{SE}[SWITCH]{Switch}{EndSwitch}[1]{\algorithmicswitch\ #1\ \algorithmicswith}{\algorithmicend\ \algorithmicswitch}%
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndSwitch}%
\algtext*{EndCase}%

\usepackage{stmaryrd}
\usepackage{titlecaps}% http://ctan.org/pkg/titlecaps
\newcommand\theoref[1]{Theorem~\textcolor{blue}{\ref{#1}}}
\newcommand\lemmaref[1]{Lemma~\textcolor{blue}{\ref{#1}}}
\newcommand\appref[1]{Appendix~\textcolor{blue}{\ref{#1}}}
\newcommand\defref[1]{Definition~\textcolor{blue}{\ref{#1}}}
\newcommand\algoref[1]{Algorithm~\textcolor{blue}{\ref{#1}}}
\usepackage{xcolor}
\usepackage{tikz}
\newcommand{\reducesis}{\xrightarrow{\smash{\ i\ }}^{*}}
\newcommand{\wbigcup}{\mathop{{\bigcup}}}

\newcommand{\exactDoamin}{\m{domain}}
\newcommand{\computedDoamin}{\m{domain}'}



\newcommand{\CTLtoDKey}{\m{CD}\text{-}}

\usepackage{ifthen} % for todos
% TODOs
\newboolean{showcomments}
\setboolean{showcomments}{true} % comment this line to deactivate comments
\ifthenelse{\boolean{showcomments}}{
  \newcommand{\nbc}[3]{
    {\textcolor{#3}{\small{\bfseries{#1:\ }}\textit{#2}}}}
}{
  \newcommand{\nbc}[3]{}
}
\newcommand{\yahui}[1]{\nbc{@Yahui}{#1}{red}\xspace}


\usepackage{stmaryrd}
\newcommand{\nodeEv}{\nabla}
\newcommand{\nodeEvop}{{=}}

\newcommand{\getPure}{\m{Pure}}
\newcommand{\getPureop}{{=}}
\newcommand{\deri}{\mathcal{D}}
\newcommand\figref[1]{Fig. \textcolor{blue}{\ref{#1}}}
\newcommand\tabref[1]{Table \textcolor{blue}{\ref{#1}}}
\newcommand\secref[1]{Sec. \textcolor{blue}{\ref{#1}}}
\newcommand{\syh}[1]{{\small \ttfamily \color{purple}{{{YH:#1}}}}}
\newcommand{\mpm}[1]{{\small \ttfamily \color{blue}{{{MM:#1}}}}}
\definecolor{darkgreen}{RGB}{0,100,0}
\newcommand{\ly}[1]{{\small \ttfamily \color{darkgreen}{{{LY:#1}}}}}
\definecolor{darklavender}{rgb}{0.3, 0.16, 0.4}
\definecolor{darkred}{rgb}{0.55, 0.0, 0.0}
\definecolor{airforceblue}{rgb}{0.36, 0.54, 0.66}
\usepackage{wrapfig}
\definecolor{mGray1}{rgb}{0.9,0.9,0.9}
\definecolor{mGray}{rgb}{0.5,0.5,0.5}
\definecolor{commentcolor}{rgb}{0.6,0.6,0.6}
\usepackage{xspace}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\newcommand{\toolName}{\textsc{CTLexpert}\xspace}
\newcommand{\Symlog}{\textsc{Symlog}\xspace}
\newcommand{\relation}{R}
\newcommand{\drule}{Q}
\newcommand{\toDatalogRule}{GD\text{-}}
\newcommand{\predFlow}{\mathtt{flow}}

\usepackage[normalem]{ulem}
\newcommand{\CTLToD}[3]{\m{CTL2D}(#1) \,{\rightsquigarrow}\, (#2, #3)} 


\newcommand{\function}{\textsc{Function}\xspace}
\newcommand{\terminator}{\textsc{T2}\xspace}
\newcommand{\ultimate}{\textsc{Ultimate LTL Automizer}\xspace}
\newcommand{\ultimateshort}{\textsc{Ultimate}\xspace}

% \newboolean{showcomments}
% \setboolean{showcomments}{false} % comment this line to deactivate comments
% \ifthenelse{\boolean{showcomments}}{
%   \newcommand{\nbc}[3]{
%     {\textcolor{#3}{\small{\bfseries{#1:\ }}\textit{#2}}}}
% }{
%   \newcommand{\nbc}[3]{}
% }

\definecolor{green(html/cssgreen)}{rgb}{0.0, 0.5, 0.0}


% English
\newcommand{\adhoc}{\hbox{\emph{ad hoc}}\xspace}
\newcommand{\cf}{\hbox{\emph{cf.}}\xspace} % confer which means compare
\newcommand{\deletia}{\ldots [deletia] \ldots}
\newcommand{\etal}{\hbox{\emph{et al.}}\xspace}
\newcommand{\eg}{\hbox{\emph{e.g.}}\xspace}
\newcommand{\ie}{\hbox{\emph{i.e.}}\xspace}
\newcommand{\scil}{\hbox{\emph{sc.}}\xspace} %scilicet: it is permitted to know
%\newcommand{\st}{\hbox{\emph{s.t.}}\xspace} % Clashes with an existing definition
\newcommand{\wrt}{\hbox{\emph{w.r.t.}}\xspace}
\newcommand{\etc}{\hbox{\emph{etc.}}\xspace}
\newcommand{\viz}{\hbox{\emph{viz.}}\xspace} %videlicet: it is permitted to see

\usepackage{multirow}
\usepackage{longtable}
\usepackage{makecell, boldline}
\usepackage{mathtools}
\newcommand{\m}{\mathit}  

\definecolor{blue(pigment)}{rgb}{0.2, 0.2, 0.6}

\newcommand{\RETOD}[4]{\Pi \,{\vdash}\, \m{GWRE2D}(#1, #2, #3) \,{\rightsquigarrow}\,  #4} 
\newcommand{\RETODHelper}[6]{#1 \,{\vdash}\, (#2, #3, #4, #5) \,{\hookrightarrow}\,  #6}
\newcommand{\prevS}{S_p} %_{\m{prev}}
\newcommand{\pathPure}{\pi_{\m{path}}}
\newcommand{\datalogarrow}{\,\text{:--}\,}
\newcommand{\hide}[1]{}
\newcommand{\env}{\code{\mathcal{S}}}
\newcommand{\anylabel}[1]{{\textcolor{darkred}
{{#1}}}}
\newcommand{\omegaRE}{{\omega\text{-}RE}}
\newcommand{\sepimp}{\mathrel{-\mkern-6mu*}}
\usepackage{graphicx}
\usepackage{xparse}
\newcommand{\effect}{{\ensuremath{\mathrm{\Phi}}}}
%\newcommand{\effect}{{\ensuremath{\theta}}}
\newcommand{\code}[1]{$#1$}

\usepackage{listings}
\makeatletter
\newcommand*\mysize{%
  \@setfontsize\mysize{8.8}{9.0}%
}
\makeatother

\lstset{
 language=C,
 escapeinside={(*@}{@*)},
 basicstyle=\small\ttfamily,
 columns=[c]fixed,
 numbers=left,   
 xleftmargin=2em, 
 numberstyle=\tiny\color{mGray},
 commentstyle=\color{commentcolor}\ttfamily,
 keywordstyle=\color{airforceblue}\bfseries,
 upquote=true,
 breaklines=true,
 showstringspaces=false,
 stringstyle=\color{black},
 keywordstyle=[2]\color{purple}\ttfamily, %
 morekeywords=[2]{int, if , return},
 literate={'"'}{\textquotesingle "\textquotesingle}3
}

\usepackage{thm-restate}
\usepackage[capitalise]{cleveref}
\usepackage{caption,subcaption}

\bibliographystyle{ACM-Reference-Format}%
\citestyle{acmauthoryear}
\title{Reactive Program Repair}
\title{Reactive Program Repair using Computation Tree Logic}
%\usepackage{times,epsfig,color,latexsym,clrscode3e}
\title{Computation Tree Logic guided Reactive Program Repair}


% \title{CTL guided Repair for Infinite-state Programs}



\usepackage{amsmath}

% \usepackage{frameit}
\usepackage{color,latexsym,graphics,wrapfig}
\usepackage{listings}
\usepackage{multirow}
\usepackage{lineno}

%\usepackage{lgrind,proof}
%\usepackage{lineno}
%\usepackage{listings}
%\usepackage{multirow}
%\usepackage{amssymb}
\usepackage{graphicx}
\usepackage{mathpartir}

\newif\iftechreport
\techreporttrue
% \techreportfalse
% \newcommand*{\techreportonly}[1]{#1}
\newcommand*{\techreportonly}[1]{}

%% \author{Anonymous Authors}

%%
%% end of the preamble, start of the body of the document source.
\algrenewcommand\algorithmicindent{1em} % or any other value as you wish
\usepackage[bottom]{footmisc}
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

%% \author{Aparna Patel}
%% \affiliation{%
%%  \institution{Rajiv Gandhi University}
%%  \streetaddress{Rono-Hills}
%%  \city{Doimukh}
%%  \s{Arunachal Pradesh}
%%  \country{India}}

%% \author{Huifen Chan}
%% \affiliation{%
%%   \institution{Tsinghua University}
%%   \streetaddress{30 Shuangqing Rd}
%%   \city{Haidian Qu}
%%   \s{Beijing Shi}
%%   \country{China}}

%% \author{Charles Palmer}
%% \affiliation{%
%%   \institution{Palmer Research Laboratories}
%%   \streetaddress{8600 Datapoint Drive}
%%   \city{San Antonio}
%%   \s{Texas}
%%   \country{USA}
%%   \postcode{78229}}
%% \email{cpalmer@prl.com}

%% \author{John Smith}
%% \affiliation{%
%%   \institution{The Th{\o}rv{\"a}ld Group}
%%   \streetaddress{1 Th{\o}rv{\"a}ld Circle}
%%   \city{Hekla}
%%   \country{Iceland}}
%% \email{jsmith@affiliation.org}

%% \author{Julius P. Kumquat}
%% \affiliation{%
%%   \institution{The Kumquat Consortium}
%%   \city{New York}
%%   \country{USA}}
%% \email{jpkumquat@consortium.net}
%% \renewcommand{\shortauthors}{Trovato et al.}


%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Automated program repair requires a correctness criterion to guide the repair. Traditionally, such correctness criteria are given in the form of test suites. 
However, test-suite guided repair may suffer from severe over-fitting since the repaired code may not pass tests outside the given test suite. 
% Moreover, for reactive systems that are in continuous interaction with the environment, input-output specifications like tests are not suitable specifications for program behavior. 
For reactive systems, temporal logics like Computation Tree Logic (CTL) have been widely used as expressive formalisms for rich behavioral specifications. 
This paper suggests a mechanism for high-quality automated repair of stateful reactive programs guided by CTL properties instead of tests. Instead of a traditional find-and-fix paradigm where a model checker finds counterexample traces, and then humans manually fix them — we integrate finding and fixing errors into a single analyzer-plus-repair tool. 
%Properties in CTL are nested fixed-point properties combining the least and greatest fixed-point operators. 
We observe that the nested fixed-point semantics of CTL properties, combining least and greatest fixed points, can be readily supported by Datalog programs with stratified negation. 
Meanwhile, given a program, its control flow can be extracted as Datalog rules, and the abstract states can be represented as Datalog facts. 
Program repair is then achieved by modifying the Datalog rules and facts.
Our technical contribution includes support for repairing both safety and liveness properties. 
Repairs guided by liveness properties often require reasoning about non-termination, and we take extra care via a novel loop summarization, allowing a more effective ranking function generation.
%summarize both terminating and non-terminating behaviors in a disjunctive form with arithmetic guards.  
%to require \syh{minimal manual annotations}. 
We compare our integrated automated repair approach with the conventional approach - where different bug-finding front-ends find bugs, which are then manually repaired separately. Experiments on an extensive real-world benchmark show the substantial benefits of our integrated approach to finding and fixing various CTL bugs, including violations of invariants, reachability, termination, response properties, etc, which are broadly essential in practice. 
%such as termination bugs or bugs that only can be detected with non-linear ranking functions. 
%Our proposal removes the time lag between finding and fixing security bugs in real-world reactive systems. 
\end{abstract}


\begin{CCSXML}
<ccS2012>
   <concept>
       <concept_id>10003752.10010124.10010138.10010140</concept_id>
       <concept_desc>Theory of computation~Program specifications</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10003790.10003793</concept_id>
       <concept_desc>Theory of computation~Modal and temporal logics</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011074.10011099.10011102.10011103</concept_id>
       <concept_desc>Software and its engineering~Software testing and debugging</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10011007.10011074.10011099</concept_id>
       <concept_desc>Software and its engineering~Software verification and validation</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccS2012>
\end{CCSXML}

\hide{
\ccsdesc[500]{Software and its engineering~Software verification and validation}
\ccsdesc[500]{Software and its engineering~Software testing and debugging}
\ccsdesc[300]{Theory of computation~Program specifications}
\ccsdesc[300]{Theory of computation~Modal and temporal logics}

}


%\keywords{Program Analysis, Datalog, Automated Program Repair, CTL}

\maketitle

\section{Introduction}
\label{sec:intro}




Computation tree logic (CTL) is a temporal logic introduced by \citet{DBLP:conf/lop/ClarkeE81} 
to overcome certain limitations of linear temporal logic (LTL) \cite{DBLP:conf/focs/Pnueli77} for the purposes of specification, verification, and synthesis. 
CTL is based on a branching notion of time - 
referring to the fact that at each moment, there may be several different possible futures -  and it is an important temporal logic that is sufficiently expressive for formulating a rich set of properties for (infinite states) reactive systems. Specifications written in CTL can also be obtained from industrially supported specification languages like Property Specification Language\footnote{IEEE 1850-2005 \cite{design2005ieee} - IEEE Standard for Property Specification Language (PSL).}.  
%for program specification purposes. 
%Clarke and
%Emerson 


\begin{comment}
We find preconditions by recursing over
the structure of the given CTL formula. That is, we start by
finding the precondition of the innermost sub-formula followed
by search for the preconditions of the outer sub-formulas
dependent on it. 
either only primarily consider the universal fragment of CTL , 
or with a sacrificed precision \cite{DBLP:conf/sas/UrbanU018} due to the mixed usage of under/over-approximating operators, to deal with the existential and universal quantifiers, respectively; and a \emph{dual widening} to proving termination of loops. 
\end{comment}

%clarke1986automatic
Model checking has been extensively studied in the context of finite-state %systems modeled using 
automata \cite{burch1992symbolic,kupferman2000automata,DBLP:conf/lics/ClarkeJLV02} for CTL properties. 
Meanwhile, program analysis tools 
target infinite-state programs, which either iteratively synthesize preconditions asserting the satisfaction of sub-formulas of an input CTL property in the tool \terminator \cite{DBLP:conf/cav/CookKV11,DBLP:conf/fmcad/CookKP14}, or prove CTL formulas via a mixed usage of under/over-approximation operators in the tool \function \cite{DBLP:conf/tacas/CourantU17}.
It is well-known that ``\emph{termination is a sub-problem of liveness properties}'' \cite{DBLP:conf/popl/CookGPRV07,DBLP:conf/pldi/CookK13,DBLP:conf/pldi/0001K21}, 
and experimental results (cf. \tabref{tab:comparewithFuntionT2}) show that one major disadvantage of  existing real-world CTL analyzers comes from the imprecision of their termination analysis. 
This is primarily due to their less satisfactory ranking function synthesis techniques,  
such as the the \emph{counterexample-based ranking function synthesis} in \terminator and the \emph{dual widening} in \function. 
Unfortunately, none of the existing tools offer a means to assist with the termination analysis when the ranking function cannot be effectively generated, which would potentially enhance the precision of the real-world CTL checking. 




To separate the concerns, we propose to extract the control flow and abstract program states of a real-world program and represent them using a Datalog \cite{rey1988principles} program, leveraging the Datalog execution for CTL property queries. 
The relation between CTL and Datalog is longstanding \cite{gottlob2002datalog,DBLP:journals/corr/abs-cs-0510012}, which indicates that the % fixed point 
semantics of CTL properties -- nested least and greatest fixed points -- can be readily supported by Datalog with stratified negation, and notably, just like model checking, the CTL analysis using stratified Datalog does not introduce any approximation. 
Specifically, we convert the target program to an intermediate representation, denoted by \code{\effect}, which is the \code{\omega}-regular language extended with a \emph{guard} operation
%, adopted from Communicating Sequential Processes (CSP) 
\cite{hoare1978communicating}, to represent constrained non-determinism. 
Loops are pre-analyzed into \code{summaries}, in the form of $\effect$. 

%terminating and non-terminating behaviors 
Unlike the existing loop summarization techniques \cite{DBLP:conf/tacas/TsitovichSWK11,DBLP:journals/tse/XieCZLLL19,DBLP:conf/sigsoft/XieCZLLL17} that are usually built on top of the invariants of the terminating loops, and do not explicitly capture non-terminating behaviors, our loop summarization aims to summarize both possibilities in a disjunctive form with arithmetic guards. Such an innovation achieves a more effective ranking function generation by observing the loop guards or the guards of the disjunctive summarizations. 
More importantly, our loop summarization can be composed with any 
%makes it possible to leverage the research efforts devoted to the 
ranking function synthesis tools \cite{DBLP:conf/cav/Ben-AmramG17,DBLP:conf/cav/CookGLRS08} and computes the loop summaries with the given ranking function. 
This proposal makes the CTL analysis independent from specific techniques for termination analysis, and the precision can be controlled by the quality of the candidate ranking functions. 
More surprisingly,  
experimental results show that our tool \toolName can significantly improve the precision of the CTL checking, by just simply (yet soundly) obtaining the ranking functions from the loop/summaries guards.  
With loss of generality, we allow the users to input ranking functions via annotations or ranking function synthesis tools, which can help the analyzer achieve a better performance when needed. 



Moreover, the proposed CTL analysis using Datalog also 
advances automated program repair of temporal property violations. 
Recently, \citet{DBLP:conf/sigsoft/LiuMSR23} proposed a general-purpose program repair framework, \Symlog, that applies to least-fixed point defined (Datalog-based) static analysis, such as 
null pointer exceptions or data leaks. 
Inspired by it, in this work, we support repairs guided by CTL properties by supporting the stratified negations that can occur in the Datalog rules, pushing the existing repair ability to a mixture of the least and greatest fixed points defined analysis. 




If all the control flows are encoded using Datalog rules, and the (re-)assignments of the program variables are 
represented using symbolic predicates and encoded using Datalog facts, then different sets of facts %dynamically 
choose different program transitions defined by the rules.  
We consider the following repair problem: given a finite structure (but infinite states) \code{\effect} and a specification \code{\phi} in CTL, determine if \code{\effect} contains a substructure \code{\effect^\prime} (with the same initial state) that satisfies \code{\phi}. Thus, \code{\effect} can be \emph{repaired} to satisfy %the specification 
\code{\phi} by either adjusting the facts to change the selection of the transitions or, more directly, deleting some transitions. Therefore, in this work, we offer three repair strategies: 
1) modifying the facts so that they %dynamically 
choose the execution flows that satisfy the property; 
2) subtracting the control flow rules so that all the remaining %program 
structures satisfy the property; 
3) adding new (re-)assignments and transitions facts, 
so that the updated 
flows satisfy the property. 
%However, repair by adding the control flow rules is not primarily supported, as doing so does not seem to be any better than adding to the structure \code{\effect} and then regenerating the repair formula using the existing strategies. 



Putting it all together --- this paper integrates finding and fixing CTL errors into a single analyzer-plus-repair tool. Unlike the traditional find-and-fix paradigm, where an analyzer finds many counterexample traces and then humans manually fix them iteratively, we deal with all counterexamples at once via the symbolic encoding of program executions. 
As a result, our approach enhances the precision of the analysis and significantly improves efficiency and accuracy by automatically generating patches. 
We show that our repair solution is sound -- if it generates a patch, the patch eliminates the property violation, and it is complete -- if there exists a patch allowing the given structure \code{\effect} to satisfy the property, \toolName~ will be able to find it. 
Furthermore, our repair framework does not require re-analysis of the generated patches. 
Our main contributions are: 



\begin{itemize}[leftmargin=0.35cm]

\item We observe that CTL property violations in reactive programs are typically found by %methods such as 
model checking, which produce counterexample traces, which are then used to repair the bugs. Our core novelty is to define a new find-and-fix process that takes in a reactive system $\effect$ and a CTL property $\varphi$. It returns either true if  $\varphi$ holds, or a (minimally) repaired program $\effect^\prime$ so that  $\effect^\prime \models \varphi$.

%properties  for infinite-state programs, 
\item We explore the feasibility of CTL checking for real-world programs using stratified Datalog. 
We have developed a new approach for handling loops to calculate both termination and non-termination summaries in a disjunctive form. 
Our novel loop summarization shows advantages in finding ranking functions and makes it possible to 
adjust the precision of the CTL analysis. 

\item We are inspired by the existing repair framework \Symlog \cite{DBLP:conf/sigsoft/LiuMSR23} and 
provide a solution for supporting the repair guided by CTL properties. Our solution is novel and significant as it allows the repair framework to support stratified negations; thus, it can fix bugs related to a mixture of the least and greatest fixpoint-defined analysis, in general. 

\item We prototype our proposal into a single ``push-button'' analyzer-plus-repair tool, \toolName. 
We evaluate \toolName on an extensive 
 real-world benchmark, 
 including protocol implementation and widely used C library repositories. 
Our experimental results demonstrate that \toolName outperforms state-of-the-art tools in detecting and fixing various CTL bugs.
The source code of \toolName\ and dataset are publicly available at~\cite{zenodo_benchmark}.   


\end{itemize}

\noindent\syh{TODO:1.rewrite the motivation examples 2.loop summary algo 3. how to adjust the precision}
\section{Overview and Illustrative Examples}


\begin{figure}[!h]
  \vspace{-1mm}
  \includegraphics[width=0.83\linewidth]{pics/system_overview.png}
  \vspace{-1mm}
  \caption{\label{fig:Verification_overview}System overview of \toolName 
 }
   \vspace{-3mm}
\end{figure}

% and patches do exist. 
As shown in \figref{fig:Verification_overview}, the inputs and output are represented in the dashed boxes. 
\toolName\ takes the program’s control-flow graph (CFG) and a CTL specification and produces safe patches if the property does not hold. 
Our main technical contributions are highlighted in the rounded boxes and the arrows around them. 
In particular, we deploy an SMT solver \cite{DBLP:conf/tacas/MouraB08} and an ASP solver \cite{DBLP:books/sp/Lifschitz19} for solving linear arithmetic constraints and deciding the truth assignments of symbolic signs for Datalog facts. 
The workflow of \toolName\ is as follows: 

%respectively. 
%in both the analysis and repair processes, proof obligations for arithmetic constraints are discharged by  


\begin{enumerate}[itemsep=0ex,leftmargin=0.6cm]

\item For any CTL property, we convert it into stratified Datalog rules (detailed in \secref{subsec:fromCTL2Datalog}). 
%In particular, we deploy an encoding from \citet{gottlob2002datalog} for the ``AF'' operator (detailed in \secref{subsec:fromCTL2Datalog}), which enables a greatest fixpoint encoding using the least fixpoint semantics of Datalog.  



\item For any target program CFG, a set of translation rules (presented in \secref{subsec:progam2WRE}) convert the source code into our intermediate representation, i.e., the guarded \code{\omega}-regular expression (\code{\omega}-RE). 
In this process, loops are handled by a summary calculus 
(shown in \secref{subsec:loop2wRE}). 




\item The Datalog execution checks CTL properties precisely. In contrast to the recursive labeling process in CTL model checking, 
Datalog solves the CTL queries using a handful of declarative rules, and the labeling process becomes implicit and is discharged by Datalog engines. 


%%improves Symlog with 
\item 
Lastly, when the given property does not hold, the buggy Datalog program is sent for repair (\secref{sec:program_repair}). 
%Our approach not only supports for negations but also demonstrates orders-of-magnitude performance improvement towards the generation of patches. 
When mapped back to the source code level, the patches that \toolName can generate include inserting/deleting code blocks and conditional patches. 





\end{enumerate}




We present a few examples to show the core idea and benefits of our approach. Specifically, the examples range from various features, including 
the mixed abstract domains
(\figref{fig:first_Example} and \figref{fig:example:Infinite_Loops_2}), 
non-deterministic behaviours (\figref{fig:example:Infinite_Loops_1} and \figref{fig:example:real_lefe_termination}), 
summarizing finite/infinite loops (\figref{fig:example:Infinite_Loops_1} and \figref{fig:example:Infinite_Loops_2}), 
repairing real-world reactive programs 
(\figref{fig:example:real_lefe_termination} and \figref{fig:ftpd}). 
Although most of them are simple, not all these examples cannot be easily handled by any state-of-the-art CTL analyzers, such as \terminator~\cite{DBLP:conf/fmcad/CookKP14} or   \function~\cite{DBLP:conf/tacas/CourantU17}. 
%\yahui{$\leftarrow$there is some problem in this sentence}
%which could return either \emph{unknown}s or wrong answers. 
Moreover, to the best of the authors' knowledge, this work is the first to provide a repair solution based on a novel CTL analysis. 



\noindent\paragraph{\textbf{Encoding the program structure using Datalog rules.}}
\label{sec:example:mixed_abstract_domain}


\begin{wrapfigure}{R}{0.28\columnwidth}
\vspace{-5mm}
{\begin{lstlisting}[xleftmargin=1em, numbers=none,name=intro,basicstyle=\footnotesize\ttfamily]
(*@\textcolor{mGray}{//$AF(y{=}1)$}@*)
x = 2; 
if (x>=2 && x%2==0){
  y = 1;
} else {
  y = 0;
}
\end{lstlisting} 
\vspace{-2mm}
\centering
\qquad
\includegraphics[width=0.82\linewidth]{pics/first_Example_cfg.png}
}
\vspace{-2mm}
\caption{A simple example of code and its CFG} 
\vspace{-20mm}
\label{fig:first_Example}
\end{wrapfigure} 


\figref{fig:first_Example} presents a simple example of C code and its CFG. 
This program contains a conditional, which checks if variable \code{x}'s value is greater than or equal to 2 and also if it is an even number. It assigns variable \code{y}'s value to 1 in the first branch and 0 in the \emph{else} branch. 
The CTL property of interest is $AF(y{=}1)$, stating that \emph{``for all the paths, finally \code{y}'s value is 1''}. With that, we eventually produce a corresponding Datalog program, shown as follows: 

\begin{minipage}[b]{1\linewidth}
\vspace{2mm}
\begin{lstlisting}[xleftmargin=-1em,numbers=none,basicstyle=\footnotesize\ttfamily]
Even("x", (*@\loc{1}@*)). GtEq("x", 2, (*@\loc{1}@*)). // generated from "x=2"
Eq("y", 1, (*@\loc{4}@*)). flow ((*@\loc{1}@*), (*@\loc{2}@*)). flow ((*@\loc{4}@*), (*@\loc{4}@*)). flow ((*@\loc{5}@*), (*@\loc{5}@*)). 
flow ((*@\loc{2}@*), (*@\loc{3}@*)):- GtEq("x", 2, (*@\loc{2}@*)). 
flow ((*@\loc{3}@*), (*@\loc{4}@*)):- Even("x", (*@\loc{2}@*)). 
flow ((*@\loc{2}@*), (*@\loc{5}@*)):- Lt  ("x", 2, (*@\loc{2}@*)). 
flow ((*@\loc{3}@*), (*@\loc{5}@*)):- Odd ("x", (*@\loc{2}@*)). 
\end{lstlisting} 
\vspace{1mm}
\end{minipage}

Here, ``\lstinline|Even|'', ``\lstinline|GtEq|'', ``\lstinline|Eq|'', etc., are symbolic predicates over program variables, constants, and state numbers (marked in {\loc{red}}). In addition, the predicate \emph{flow} represents the control flows; and some of which are persistent (always exist), such as ``\text{\lstinline|flow(|\loc{1}, \loc{2}\lstinline|)|}'', whereas some of them only exist if certain promises are satisfied, such as ``\text{\lstinline|flow(|\loc{2}, \loc{5}\lstinline|)|}''. 
We defer the property encoding for $AF(y{=}1)$ in \figref{fig:first_Example_ctl_rules}. 

In the current program, since \code{x} is assigned to 2 at state 1, the effective control flows only contain one path, denoted by ``\text{\lstinline|flow(|\loc{1}, \loc{2}\lstinline|)|}'', 
``\text{\lstinline|flow(|\loc{2}, \loc{3}\lstinline|)|}'', and 
``\text{\lstinline|flow(|\loc{3}, \loc{4}\lstinline|)|}''. 
Datalog proves that the given CTL property holds (based on the rules in \figref{fig:first_Example_ctl_rules}), as on this path, indeed \code{y} is finally 1. 
%\yahui{how exactly? What is the query?} 
Moreover, as we target (infinite states) reactive systems, 
it is standard to 
encode finite traces into infinite traces by adding self-transition flows at the last states, here  
``\text{\lstinline|flow(|\loc{4}, \loc{4}\lstinline|)|}'', and 
``\text{\lstinline|flow(|\loc{5}, \loc{5}\lstinline|)|}''. 

%like other CTL analyzers, we 
%symbolically 
%\yahui{what does ``symbolically generate'' mean?} 
%kinds of 

Let us consider where the assignment ``\code{x{=}2}'' is deleted, letting the program start from state 2. 
\toolName~ now successfully disproves the property by 
generating two more facts ``\text{\lstinline|Odd("x",| \loc{1}\lstinline|)|}'' and ``\text{\lstinline|Lt("x",2, |\loc{1}\lstinline|)|}'', to capture all the possibilities of the program state at state 2. 
These facts effectively activate all the possible paths. 
At this moment, the repair comes in. It produces several 
patches, such as: (i) deleting the newly added \lstinline|Odd| and \lstinline|Lt| facts; or (ii) adding a predicate ``\text{\lstinline|Eq("y",1,| \loc{5}\lstinline|)|}'' to modify the assignment at state 5 to ``\code{y{=}1}''; and both patches fix the property violation. \syh{revise}


\begin{comment}
{
If we use a numeric abstract domain, which does not have parity, 
As long as one of the functions of undefined, then the undefined wins. 
If it is a universal quantified,  we do over-approximation, and when we merge, the undefinedness wins. 
We prove the soundness of the analysis, meaning that all program executions respecting the inferred precondition indeed satisfy the CTL property. A program execution that does not respect the precondition might or might not satisfy the property. 
The domain cannot represent Parity  
map each point to a function over-approximating concrete semantics, and the analysis is performed backward for each CTL sub-formula.}
\end{comment}



%// -ctl "AG(AF(t=1)/\AF(t=0)))"
\noindent\paragraph{\textbf{Loop summaries.}} 
\label{sec:example:Infinite_Loops_1}

Termination analysis \cite{DBLP:conf/pldi/CookPR06,DBLP:conf/cav/HeizmannHP14,DBLP:conf/pldi/0001K21} usually targets on 
%proves termination via 
synthesising a ranking function and concludes non-terminating via a counterexample, which witnesses an infinite execution path. 
In contrast, we generate summaries for both finite and infinite paths, from \emph{candidate ranking functions}, assuming that all the infinite traces can be depicted as an infinite repetition of finite traces within a suitable abstract domain. Here are two examples. 


\begin{wrapfigure}{R}{0.54\columnwidth}
\vspace{-6mm}
\begin{minipage}[b]{0.47\linewidth}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
(*@\textcolor{mGray}{//$AG(x {=} 1 \,{\rightarrow}\, AF(x {=} 0))$}@*)
x = 0;
while (1) {
  y = *;
  x = 1;
  n = *;
  while (n>=0) {
    n = n - y;}
  x = 0; 
}
\end{lstlisting} 
\caption{Infinite loop (a)} 
\label{fig:example:Infinite_Loops_1}
%\caption{} 
%\label{fig:Infinite_Transition_System}
\end{minipage}
\begin{minipage}[b]{0.52\linewidth}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
(*@\textcolor{mGray}{//$AG(AF(t{=}1)\,{\wedge}\, AF(t{=}0))$}@*)
int main() { 
  int i, t;
  while (1){
    if (i%2=0) { 
        t = 1;
    } else {
        t = 0;}
    i++; 
  }}
\end{lstlisting} 
\caption{Infinite loop (b)} 
\label{fig:example:Infinite_Loops_2}
%Taken from the prior work of \citep{DBLP:conf/pldi/CookK13}
%\caption{}  
%\label{fig:non_deterministic_example}
\end{minipage}
\end{wrapfigure}






In \figref{fig:example:Infinite_Loops_1},   
the symbol ``\code{*}'' has made all the nondeterminism explicit.  
Imagine that we would like to prove it is possible to maintain the following invariant: ``\emph{whenever x{=}1, then eventually x{=}0}''.
In CTL we would express this property as: $AG(x {=} 1 \,{\rightarrow}\, AF(x {=} 0))$, where ``\code{AG~\phi}'' 
specifies that in all nondeterministic choices,  
\code{\phi} globally holds. 
Whether the property holds or not depends on whether the inner loop terminates. 
Observing that ``\code{n}'' could possible be a ranking function for this loop, i.e., \code{n}'s value is non-negative and decreasing, we derive the following \emph{termination condition} \cite{DBLP:conf/cav/CookGLRS08}: 
\code{n \text{-} (n\text{-}y) {\geq} 1}, as \code{n}'s value has to decrease at least 1 in each iteration, which is further reduced to \code{y {\geq}1}. 
%\yahui{I did not understand the meaning of this constraint}
Therefore, we derive the following summary for the inner loop: 
\code{\effect^{(a)}_{7\text{-}8} \,{\equiv}\, ([y{\geq}1]\,{\cdot}\, n{<}0) \vee ([y {<}1] \,{\cdot}\, (n{\geq}0)^\omega)}, where \code{[\pi]} denotes a guard upon a pure constraint, and a trace can only be executed if its guard does not fail, whereas if the guard evaluates to \emph{true}, it has no effect on the program state. 
\toolName~ computes the above summary and encodes the program into Datalog accordingly. 
The property does not hold currently, because if the inner loop does not terminate, \code{x}'s value will never be set back to 0. Therefore, \toolName~ generates a patch which adds a predicate 
``\text{\lstinline|GtEq("y," 1,| \loc{4}\lstinline|)|}'', to modify the nondeterminism choice at line 4, to be a constraint which guarantees the termination of the inner loop.  

%greater than or equal to 1.  
%\yahui{I find it confusing as Datalog cannot reason about integers}

 






\figref{fig:example:Infinite_Loops_2} presents another  infinite loop. 
Inside the loop, it checks the value of \code{i}; when \code{i} is even, \code{t} is assigned with 1, and when \code{i} is odd, \code{t} is assigned with 0. By the end of the loop, it increases the value of \code{i} by 1. 
Suppose we want to prove the following CTL property: $AG(AF(t{=}1)\,{\wedge}\, AF(t{=}0))$,  
which states that ``\emph{for all the path globally, t{=}1 and t{=}0 are both finally reachable}''. 
Intuitively, in this program, given any initial value of \code{i}, \code{t}'s value will be alternatively assigned with 1 and 0; 
thus, the property holds. 
\toolName~ proves it via summarising the behavior of the loop using the following: 
\[\effect^{(b)}_{4\text{-}10}  \equiv   (Even(i)\cdot t{=}1 \cdot Odd(i)\cdot t{=}0)^\omega
\vee 
(Odd(i)\cdot t{=}0\cdot Even(i)\cdot t{=}1)^\omega
.\]
which contains two infinite paths, and both of them  set \code{t} to be 1 and 0 alternatively. 
Therefore, after translating \code{\effect^{(b)}_{4\text{-}10}} to a Datalog program, it manages to prove the property holds at the starting state of the program. 
We illustrate the loop summary calculus in \secref{subsec:loop2wRE}. 
\syh{highlight the novelty}


% via an interprocedural analysis
\noindent\paragraph{\textbf{Repairing real-world termination bugs.}}
\label{sec:example:termination}
%interprocedural analysis
%intraprocedural
In reactive systems, an infinite loop 
%-- an iteration with an exit condition that cannot be reached -- 
could cause unexpected consumption of CPU cycles or memory. Moreover, if an attacker can influence the loop, this vulnerability (CWE-835) could allow attackers to consume excessive resources. For instance, \figref{fig:example:real_lefe_termination} outlines a termination bug \footnote{\url{https://github.com/FFmpeg/FFmpeg/commit/a6cba062051f345e8ebfdff34aba071ed73d923f}} drawn from a real-world project, FFmpeg. 

The vulnerable implementation (on the left) allows remote attackers to cause a denial of service. Here, ``\code{b}'' and ``\code{end}'' are pointers pointing to a given buffer and a positive offset of the buffer. 
Inside of the loop, it calls an internal function 
``{ff\_subtitles\_next\_line}'' (defined on the right), which gets the number of characters to increment to jump to the next line or the end of the string. 
The attack happens if the given buffer is an empty string, as the return value at 
line 4 would be 0; therefore, the loop does not terminate as the position of ``\code{b}'' will never change. 
A fix provided by the developer is also shown, which checks the return value of the function call and breaks the loop if it returns 0. 

\toolName~ converts the implementation of ``{ff\_subtitles\_next\_line}'' into the following \code{\omegaRE} formula:
``$(n{=}*) \cdot \m{Exit}(n)$'', where all the external calls, here to ``\code{\m{strcspn}}'', are abstracted using \code{*} \footnote{Better precision could be achieved by having specifications for library functions, which is left as an engineering issue.}. 
Then the loop summary is computed with the following result: \code{\effect_{3\text{-}8}  \equiv  (\m{tmp}{=}*) \cdot (([\m{tmp}{>}0] \cdot b{\geq}end) \vee ([\m{tmp}{\leq}0] \cdot (b{<}end)^\omega))}, 
where \code{\m{tmp}} is a temporary (fresh) variable referring to the return value of the call at line 4. 
Based on this summary, there are two predicates generated 
``\text{\lstinline|Gt("tmp",0)|}'' and  ``\text{\lstinline|LtEq("tmp",0)|}'' to represent both possibilities. 
After being composed with the context around the loop, the property $AF(\m{Exit}(\_))$ fails to hold, as there exists an infinite path that will never reach a return statement. 
Then, the generated repair is to delete the ``\lstinline|LtEq|'' predicate, indicating a patch that shall either eliminate the possibility of \code{\m{tmp}} being non-positive or cut off the branch where the infinite path happens. Although the automatically generated patch is not exactly the same as the developer-provided one, they hint at the same meaning towards the repair. 


\begin{figure}[!t]%{R}{0.43\columnwidth}
%\vspace{-2mm}
\begin{minipage}[b]{0.47\linewidth}
\begin{lstlisting}[name=FFmpeg,basicstyle=\footnotesize\ttfamily]
(*@\textcolor{mGray}{//$AF(\m{Exit}(\_))$}@*)
if( b < 0 || b >=end ) return 0;
while (b < end) {
(*@\faultyCode{b += ff\_subtitles\_next\_line(b); } @*)
(*@\repaircode{int inc = ff\_subtitles\_next\_line(b);} @*) 
(*@\repaircode{if (!inc) break;} @*) 
(*@\repaircode{b += inc;} @*) 
}
\end{lstlisting}
%if (b >= end - 4) return 0;
\end{minipage}
\begin{minipage}[b]{0.52\linewidth}
\begin{lstlisting}[name=FFmpeg,basicstyle=\footnotesize\ttfamily]
int ff_subtitles_next_line(char *ptr){
  int n = *; // strcspn(ptr,"\r\n");
  ptr += n; 
  if (*ptr == '\r') { 
     ptr++; 
     n++; }
  if (*ptr == '\n') n++;
  return n; }
\end{lstlisting}
%
%https://ffmpeg.org/doxygen/3.2/subtitles_8h_source.html
\end{minipage}
\vspace{-4mm}
\caption{Extracted logic of a termination bug in the FFmpeg project, reported at CVE-2018-7751} 
\label{fig:example:real_lefe_termination}
\vspace{-2mm}
\end{figure}






\noindent\paragraph{\textbf{Repairing real-world protocol implementations.}}  
\label{sec:example:protocol}
The fuzzing-based approach has shown its effectiveness in finding temporal bugs in real-world protocol implementations \cite{DBLP:conf/icse/MengDLBR22}. 

\begin{wrapfigure}{r}{0.6\textwidth}
\vspace{-1mm}
\centering
\includegraphics[width=1\linewidth]{pics/stpd_merge.png}
\caption{\label{fig:ftpd}A bug found in Pure-FTPd, reported at CVE-2021-40524}
\vspace{-2mm}
\end{wrapfigure}


\figref{fig:ftpd} presents such an example in the Pure-FTPd project \footnote{\url{https://github.com/jedisct1/pure-ftpd/commit/37ad222868e52271905b94afea4fc780d83294b4}}, as well as its developer-provided fix.  
Here, an incorrect \emph{max\_filesize} quota mechanism in the server allows attackers to upload files of unbounded size, which may lead to denial of service or a server hang. This occurs because a certain greater-than-or-equal-to-zero test does not anticipate an initial ``-1'' value of the variable \emph{max\_filesize}.
A specification of the intended behaviors could be ``\emph{whenever user quota is exceeded, must finally reply a quota exceed message 552}''; thus, in CTL: 
$\phi \equiv AG(\m{user\_quota\_size} \,{-}\, % ~\text{-}~
    \m{quota.size}{<}0 \,{\rightarrow}\, 
    AF(\m{addreply}(552))).$

After being converted to a CFG and subsequently translated to a Datalog program, guided by \code{\phi}, the bug is pin-pointed to one execution path, i.e., when \emph{max\_filesize} is smaller than 0, the program never sets \emph{overflow} to 1; thus, a reply with the 552 message is never reachable. 
\toolName~ generates a fix which deletes the ``\lstinline|Lt|'' predicate upon \emph{max\_filesize}, indicating a patch that shall either eliminate the possibility of \emph{max\_filesize} being negative or cut off the branch corresponding to ``\emph{max\_filesize}{<}0''. 
And the latter solution is exactly how the developer fixes the bug. 
\syh{revise this example}
%%At this point, 









\section{CTL Analysis via Datalog}


\begin{wrapfigure}{r}{0.5\textwidth}
{
\vspace{-6mm}
\small
$\begin{array}{lrcl}
\m{(Datalog~Program)}&  \Datalog &{\   ::=  } &
\relation^*  \concat    \drule^* 
  \\[0.1em]
\m{(Datalog~Rule)} &  \m{\drule} &{\   ::=  } & 
\relation ~\datalogarrow~ body^*
  \\[0.1em]
\m{(Rule~Bodies)} &  \m{body} &{\   ::=  } & 
{\tt{Pos}}~ \relation
~\mid~ {\tt{Neg}}~ \relation 
  \\[0.1em]
\m{(Relation/Predicate)} &  \relation &{\   ::=  } &
\nm\,(v^*)
  \\[0.1em]
\m{(Simple~Values)} & v &{\   ::=  }&
    c  
 \mid X
\end{array}$
\vspace{-2mm}
\caption{A core syntax of Datalog}
\label{fig:Syntax_of_Datalog}
}
\vspace{-3mm}
\end{wrapfigure}

This section discusses the main steps towards achieving a 
Datalog-based CTL analysis for real-world programs. 
%including converting CTL properties, translating the target program into Datalog rules and facts, and integrating them into a Datalog program. 
We define a core syntax of Datalog in \figref{fig:Syntax_of_Datalog}. 
A Datalog program consists of two parts: a set of facts (\code{R^*}) and a set of rules (\code{\m{\drule^*}}). 
We use the $*$ superscript to denote a finite set  
of items, for example, \code{v^*} refers to a set of values, \code{v_1, \dots, v_n}.
Values are constants (denoted by $c$), or program variables (denoted by $X$).

A fact is represented as a relational predicate that has a name (\code{\nm}) and a set of arguments (\code{v^*}), where \code{\nm} is an arbitrary distinct identifier. 
A Datalog rule is a Horn clause that comprises a head predicate and a set of body predicates placed on the left and right side of the arrow symbol (\datalogarrow).
A rule means that the left-hand side is logically implied by the right-hand side. The rule bodies are either positive or negative relations, corresponding to the requirements upon the presence or absence of facts. 
We use 
``\code{\relation}'' and ``\code{\shortNeg\,\relation}'' as abbreviations for  ``\code{{\tt{Pos}}~\relation}'' and ``\code{{\tt{Neg}}~\relation}''. %, respectively. 
Moreover, we use ``\code{\drule_{\m{pos}}}'' to stand for a \emph{positive Datalog rule}, which only contains positive relations in the rule bodies; and $\Datalog^+$ stands for a \emph{positive Datalog program}, which only contains positive Datalog rules. 

A Datalog query is executed against a database of facts, also known as the extensional database (EDB), and produces a set of derived facts, also known as the intensional database (IDB). 
Datalog with stratified negation can be partitioned into a finite number of Datalog programs, capturing the different strata. 
If the rule producing the  predicate $\relation$ contains predicate $\relation^\prime$ negated in the body, then $\relation$ and $\relation^\prime$ are in different partitions, and $\relation$ is in a higher strata than $\relation^\prime$. While defining the semantics of programs with stratified negation, the least fixed point of the lower strata is computed first and then used to compute the least fixed point semantics of the predicates in the higher strata. 



%\ly{positive Datalog/stratified Datalog}
%Since Datalog implements the semantics of fix-point computation, and many program analysis algorithms are instances of fix-point computation,
%Datalog is often used as a language for defining program analyses. 


\subsection{From CTL Properties to Datalog Rules} 
\label{subsec:fromCTL2Datalog}


\begin{wrapfigure}{r}{0.63\textwidth}
{\vspace{-3mm}
\renewcommand{\arraystretch}{1}
\small
$\begin{array}{lrcl}
\m{(CTL)}&   \phi &{\   ::=  } &
ap 
\mid \neg\phi
\mid \phi_1 {\,\wedge\,} \phi_2
\mid \phi_1 {\,\vee\,} \phi_2
\mid \phi_1 \,{\rightarrow}\, \phi_2 
\mid  
\\
&&&
AX~\phi 
\mid EX~\phi 
\mid AF~\phi 
\mid EF~\phi 
\mid AG~\phi 
\mid 
\\
&&&
EG~\phi 
\mid A  (\phi_1 \,U\, \phi_2) 
\mid E  (\phi_1 \,U\, \phi_2) 
\\[0.1em] 
\m{(Atomic~Prop.)} & ap &{\   ::=  } &
(\nm, \pi)
\qquad \qquad\qquad\qquad\quad
\\[0.1em]
\m{(Pure)}&   \pi &{\   ::=  }&
{ \m{T}}
  \mid  \m{F}
 %\mid  {\m{bop}(}{x, t}{)}
 \mid bop(t_1, t_2)
 %\mid Lt(t_1, t_2)
 %\mid GtEq(t_1, t_2)
 %\mid LtEq(t_1, t_2)
 %\mid Eq(t_1, t_2)
 \mid \relation 
 \mid   {{\pi_1}}  {\wedge}  \pi_2
 \mid  {{\pi_1}} {\vee} \pi_2
 % \mid  \neg\pi
\\[0.1em] 
\m{(Terms)} &  t & {\   ::=  } &
v
 \mid \_ 
 \mid  t_1{\text{\ttfamily +}}t_2
 \mid  t_1\text{-}t_2   
\end{array}$
\vspace{-1mm}
\caption{Syntax of CTL }
\label{fig:Syntax_of_CTL}
}
\vspace{-2mm}
\end{wrapfigure}



The syntax of CTL is outlined in \figref{fig:Syntax_of_CTL}. 
To facilitate a modular translation from CTL properties to Datalog programs, each atomic proposition is composed of a pure formula $\pi$, which is linked to a name $nm$. 
A pure formula is a simplified and decidable set of Presburger arithmetic predicates on program inputs and local variables. 
The Boolean values of \emph{true} and \emph{false} are respectively indicated by \code{T} and \code{F}. 
Binary operators are represented using predicates, where \emph{bop} $\in \s{\m{Gt}, \m{Lt}, \m{GtEq}, \m{LtEq}, \m{Eq}}$. %,\m{NegEq}
Other logical relations are represented using more general abstract predicates \code{\relation} over the variables. Terms consist of simple values, or simple computations of terms, such as \code{t_1{+}t_2} and \code{t_1\text{-}t_2}. Lastly, the wild card \code{\_} matches all terms for nondeterminism. 






\newcommand{\CTLToDArgs}[4]{\m{CTLToD}(#1) \,{\rightsquigarrow}\, (#2, #3, #4)} 
\NewDocumentCommand{\translationDoubleArgs}{O{\empty} m m m m}{
\frac{
        \begin{matrix}
        [#5] \\
        \CTLToD{\phi_{1}}{\nm_{1}}{\Datalog_1}{\mathtt{a}_{1}} \\
        \CTLToD{\phi_{2}}{\nm_{2}}{\Datalog_2}{\mathtt{a}_{2}}\\ 
        \nm_{\mathtt{new}} = \nm_{1} \concat \ensuremath{#3} \concat \nm_{2}
        \ensuremath{#1} \qquad a = \emph{CombineArgs}(a_{1},a_{2})\\
        \Datalog^\prime {=}  \left[ \begin{matrix} \ensuremath{#4} \end{matrix} \right]
        \end{matrix}
    }{ 
        \CTLToD{#2}{\nm_{\mathtt{new}}}{\Datalog_1 \concat \Datalog_2 \concat \Datalog^\prime}{\mathtt{a}}
    }
}
\NewDocumentCommand{\translationSingleArgs}{ O{\ensuremath{\phi}} O{\empty} m m m m O{\empty}}{
\frac{
        \begin{matrix}
        [#6] \\
        \CTLToD{#1}{\ifx #2\empty \else #2 \concat \fi \nm}{\Datalog}{\mathtt{a}}\\
        \nm_{\mathtt{new}} = #4 \concat \nm \qquad #7 \\
        \Datalog^\prime {=} \left[ \begin{matrix} #5 \end{matrix} \right]
        \end{matrix}
    }{ 
        \CTLToD{#3}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}{\mathtt{a}}
    }
}


\NewDocumentCommand{\translationDouble}{O{\empty} m m m m}{
\frac{
        \begin{matrix}
        \CTLToD{\phi_{1}}{\nm_{1}}{\Datalog_1} \qquad \CTLToD{\phi_{2}}{\nm_{2}}{\Datalog_2}\\ 
        \nm_{\mathtt{new}} {=} \nm_{1} \concat \ensuremath{#3} \concat \nm_{2}
        \ensuremath{#1} \qquad 
        \Datalog^\prime {=}  \left[ \begin{matrix} \ensuremath{#4} \end{matrix} \right]
        \end{matrix}
    }{ 
        \CTLToD{#2}{\nm_{\mathtt{new}}}{\Datalog_1 \concat \Datalog_2 \concat \Datalog^\prime}
    }\quad [#5] 
}


\NewDocumentCommand{\translationSingle}{ O{\ensuremath{\phi}} O{\empty} m m m m O{\empty}}{
\frac{
        \begin{matrix}
        [#6] \\
        \CTLToD{#1}{\ifx #2\empty \else #2 \concat \fi \nm}{\Datalog} \quad\  \nm_{\mathtt{new}} {=} #4 \concat \nm \qquad #7 \\
        \Datalog^\prime {=} \left[ \begin{matrix} #5 \end{matrix} \right]
        \end{matrix}
    }{ 
        \CTLToD{#3}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
    }
}

\NewDocumentCommand{\translationSingleRuleOnTheSide}{ O{\ensuremath{\phi}} O{\empty} m m m m O{\empty}}{
\frac{
        \begin{matrix}
        
        \CTLToD{#1}{\ifx #2\empty \else #2 \concat \fi \nm}{\Datalog} \qquad  \nm_{\mathtt{new}} {=} #4 \concat \nm \qquad #7 \\
        \Datalog^\prime {=} \left[ \begin{matrix} #5 \end{matrix} \right]
        \end{matrix}
    }{ 
        \CTLToD{#3}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
    }\quad [#6] 
}

\NewDocumentCommand{\translationSingleRuleOnTheSideEX}{ O{\ensuremath{\phi}} O{\empty} m m m m O{\empty}}{
\frac{
        \begin{matrix}
        \CTLToD{#1}{\ifx #2\empty \else #2 \concat \fi \nm}{\Datalog} \quad\   
        \nm_{\mathtt{new}} {=} #4 \concat \nm \quad\  #7 
        \Datalog^\prime {=} \left[\begin{matrix} #5 \end{matrix} \right]
        \end{matrix}
    }{ 
        \CTLToD{#3}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
    }\ \  [#6] 
}

\NewDocumentCommand{\translationSingleRuleOnTheSideAF}{ O{\ensuremath{\phi}} O{\empty} m m m m O{\empty}}{
\frac{
        \begin{matrix}
        
        \CTLToD{#1}{\ifx #2\empty \else #2 \concat \fi \nm}{\Datalog} \quad\   
        \nm_{\mathtt{new}} {=} #4 \concat \nm \\  #7 
        \\[0.3em]
        \Datalog^\prime {=} \left[\begin{matrix} #5 \end{matrix} \right]
        \end{matrix}
    }{ 
        \CTLToD{#3}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
    }\ \    [#6] 
}


\begin{figure}[!h]
\small
\centering
\begin{gather*}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% AP %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
[\CTLtoDKey\m{AP}]\\
\Datalog{=}[ \nm(S) \datalogarrow \pi(S).]
\end{matrix}
}{\CTLToD{nm,\pi}{nm}{\Datalog}
}
\qquad 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% Neg %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
\CTLToD{\phi}{\nm}{\Datalog} \qquad  \nm_{\mathtt{new}} {=} ``NOT\_" \concat \nm \\
\Datalog^\prime {=} [\nm_{\mathtt{new}}(S) \datalogarrow  \shortNeg\, \ \nm(S).] 
\end{matrix}
}{ 
\CTLToD{\neg~\phi}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
}\quad [\CTLtoDKey\m{Neg}] 
\\[1.5em]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% Conj %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
\CTLToD{\phi_{1}}{\nm_{1}}{\Datalog_1} \qquad \CTLToD{\phi_{2}}{\nm_{2}}{\Datalog_2}\\ 
\nm_{\mathtt{new}} {=} \nm_{1} \concat \ensuremath{``\_AND\_"} \concat \nm_{2}
 \qquad 
\Datalog^\prime {=}  [\nm_{\mathtt{new}}(S) \datalogarrow   \nm_{1}(S),\nm_{2}(S).]
\end{matrix}
}{ 
\CTLToD{\phi_{1} \land \phi_{2} }{\nm_{\mathtt{new}}}{\Datalog_1 \concat \Datalog_2 \concat \Datalog^\prime}
    }\quad [\CTLtoDKey\m{Conj}] 
\\[1.5em]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% Disj %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
\CTLToD{\phi_{1}}{\nm_{1}}{\Datalog_1} \qquad \CTLToD{\phi_{2}}{\nm_{2}}{\Datalog_2}\\ 
\nm_{\mathtt{new}} {=} \nm_{1} \concat \ensuremath{``\_OR\_"} \concat \nm_{2}
 \qquad 
\Datalog^\prime {=}  [\nm_{\mathtt{new}}(S) \datalogarrow \nm_{1}(S). \quad \nm_{\mathtt{new}}(S) \datalogarrow \nm_{2}(S).]
\end{matrix}
}{ 
\CTLToD{\phi_{1} \lor \phi_{2} }{\nm_{\mathtt{new}}}{\Datalog_1 \concat \Datalog_2 \concat \Datalog^\prime}
}\quad [\CTLtoDKey\m{Disj}] 
\end{gather*}
\caption{Datalog encoding of atomic propositions and basic Boolean logic operators in CTL}
\label{fig:ctl-datalog-translation-table-logic}
\end{figure}



\begin{figure}[!h]
\small
\centering
\begin{gather*}  
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% EX %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
[\CTLtoDKey\m{EX}] \\
\CTLToD{\phi}{\nm}{\Datalog} \quad\   
\nm_{\mathtt{new}} {=}  ``EX\_" \concat \nm \\
\Datalog^\prime {=} \left[\nm_{\mathtt{new}}(S) \datalogarrow   \predFlow(S,S'), \ \nm(S'). \right]
\end{matrix}
}{\CTLToD{EX~\phi}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
}
\qquad
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% EF %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
\CTLToD{\phi}{\nm}{\Datalog} \qquad  \nm_{\mathtt{new}} {=} ``EF\_" \concat \nm\\
\Datalog^\prime {=} \left[
\begin{matrix}
\nm_{\mathtt{new}}(S) \datalogarrow   \ \nm(S). \\
\nm_{\mathtt{new}}(S) \datalogarrow   \predFlow(S,S'), \nm_{\mathtt{new}}(S').
\end{matrix}
\right]
\end{matrix}
}{\CTLToD{EF~\phi}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
}\quad [\CTLtoDKey\m{EF}] 
\\[1.5em]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% EU %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
\CTLToD{\phi_{1}}{\nm_{1}}{\Datalog_1} \qquad \CTLToD{\phi_{2}}{\nm_{2}}{\Datalog_2}\qquad  
\nm_{\mathtt{new}} {=} \nm_{1} \concat \ensuremath{``\_EU\_"} \concat \nm_{2}\\ 
\Datalog^\prime {=}  
\left[ 
  \begin{matrix} 
    \nm_{\mathtt{new}}(S) \datalogarrow   \nm_{2}(S). \qquad 
    \nm_{\mathtt{new}}(S) \datalogarrow  \nm_{1}(S), \predFlow(S,S'), \nm_{\mathtt{new}}(S').
  \end{matrix} \right]
\end{matrix}
}{\CTLToD{E ( \phi_{1} \,U\, \phi_{2}) }{\nm_{\mathtt{new}}}{\Datalog_1 \concat \Datalog_2 \concat \Datalog^\prime}
}\quad [\CTLtoDKey\m{EU}] 
\\[1.5em]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%% AF %%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\frac{
\begin{matrix}
\CTLToD{\phi}{\nm}{\Datalog} \quad\   
\nm_{\mathtt{new}} {=} ``AF\_" \concat \nm \qquad   
\nm_{\mathtt{s}} {=} ``AFS\_" \concat \nm \qquad         
\nm_{\mathtt{t}} {=} ``AFT\_" \concat \nm
\\[0.3em]
\Datalog^\prime {=} 
    \left[\begin{matrix} 
        \nm_{\mathtt{t}}(S,S') {\datalogarrow} \shortNeg  \ \nm(S), \predFlow(S,S'). \qquad\nm_{\mathtt{t}}(S,S') {\datalogarrow}   \nm_{\mathtt{t}}(S,S''), \shortNeg  \ \nm(S''), \predFlow(S'',S'). \\
        \nm_{\mathtt{s}}(S) \datalogarrow  \nm_{t}(S,S).
        \qquad  \nm_{\mathtt{s}}(S) \datalogarrow  \shortNeg \, \ \nm(S) , \predFlow(S,S'), \nm_{\mathtt{s}}(S'). \\
        \nm_{\mathtt{new}}(S) \datalogarrow  \shortNeg \,  \nm_{\mathtt{s}}(S).
    \end{matrix} \right]
\end{matrix}
}{\CTLToD{AF~\phi}{\nm_{\mathtt{new}}}{\Datalog \concat \Datalog^\prime}
}\quad    [\CTLtoDKey\m{AF}]
    \end{gather*}
    \caption{Datalog encoding of a core set of CTL temporal operators  - $EX$, $EF$, $EU$, $AF$}
    \label{fig:ctl-datalog-translation-table-ctl}
\end{figure}

\begin{figure}[!t]
\small
\centering
\begin{gather*}
AX\,\phi {\,\equiv\,} \neg EX~\neg  \phi 
\qquad  
EG\,\phi {\,\equiv\,} \neg AF \neg \phi 
\qquad  
AG\,\phi {\,\equiv\,} \neg EF \neg \phi 
\qquad 
A(\phi_{1} \,U\, \phi_{2}) {\,\equiv\,} \neg E \, (\neg \phi_{2} \,U\, (\neg \phi_{1} \land \neg \phi_{2})) \land AF\,\phi_{2} 
%\qquad  
%\phi_1 \,{\rightarrow}\, \phi_2 \equiv \neg \phi_{1} \vee \phi_{2}
\end{gather*} 
\vspace{-5mm}
\caption{Derivations for CTL Operators  $AX$, $AU$, $EG$, and $AG$ 
%$\phi_1 \,{\rightarrow}\, \phi_2$
}
\label{fig:ctl-datalog-translation-table-deriv}
\vspace{-1mm}
\end{figure}




Given any CTL formula \code{\phi}, the relation ``\code{\CTLToD{\phi}{\nm}{\Datalog}}'' holds if \code{\phi} can be translated into a set of Datalog rules, denoted by \code{\Datalog}. 
The validity of \code{\phi} against a program is then indicated by the presence of the IDB predicate \code{\m{\nm}} after executing \code{\Datalog} against the program facts. 
The translation rules for the basic Boolean logic operators and a core set of CTL operators
%, here $EX$, $EF$, $EU$, and $AF$,  
are shown in \figref{fig:ctl-datalog-translation-table-logic} and \figref{fig:ctl-datalog-translation-table-ctl}, respectively. 
Specifically, a rule written like ``$ \nm(S) \datalogarrow \pi(S)$.'' is to produce the IDB predicate \code{\nm} over the states that satisfy the constraint \code{\pi}. 
The rest of the CTL constructs, including $AX$, $AU$, $EG$, $AG$, and the implication operator, are encoded using the core operators with the equivalence relations defined in \figref{fig:ctl-datalog-translation-table-deriv}. 
In particular, the encoding of the $AF$ operators is adopted from \citet{gottlob2002datalog}, which enables a greatest fixpoint encoding using the least fixpoint semantics of Datalog
(cf. more details in %\appref{appsec:AF_encoding})
Appendix A). 
%, which assumes that the target infinite system has a finite structure. 
Intuitively, the resulting Datalog rules for an \code{AF\,\phi} property is to prove the absence of \emph{lasso-shaped} \cite{DBLP:conf/cav/HeizmannHP14}  \footnote{A lasso-shaped path is a stem followed by a single loop without
branching.} counterexamples, i.e., ``$\nm_{\mathtt{s}}$'' -- a stem path to a particular program location followed by a cycle that returns to the same program location, and the property \code{\phi} does not hold along the stem and the cycle. 
As an example, we present the translation of the formula $AF(y{=}1)$, in \figref{fig:first_Example_ctl_rules}, used in an earlier illustrative program, \figref{fig:first_Example}. 




\begin{wrapfigure}{r}{0.75\textwidth}
\vspace{-1mm}
\begin{tabular}{c}
\begin{lstlisting}[xleftmargin=0em,numbers=none,basicstyle=\footnotesize\ttfamily]
y_eq_1(S)        :-State(S), Eq("y",1,S).
AF_y_eq_1_T(S,S1):-!y_eq_1(S), flow(S,S1). 
AF_y_eq_1_T(S,S1):-AF_y_eq_1_T(S,S2),!y_eq_1(S2),flow(S2,S1).
AF_y_eq_1_S(S)   :-AF_y_eq_1_T(S,S).
AF_y_eq_1_S(S)   :-!y_eq_1(S), flow(S,S1), AF_y_eq_1_S(S1).
AF_y_eq_1(S)     :-State(S), !AF_y_eq_1_S(S).
\end{lstlisting} 
\end{tabular}
\caption{Translating ``$AF(y{=}1)$'' to Datalog rules}
\label{fig:first_Example_ctl_rules}
\end{wrapfigure}

%Implicitly, 
%and arguments for the pure expressions in the definition of every rule but omit it in the encoding for brevity. 

Moreover, during the translation, each predicate was made to take a formal argument ``$S$'', representing the transition states, and the positive predicate ${\tt{State}(S)}$ is implicitly inserted to ground the variables when there are negative predicates in the rule body, which is omitted for brevity. 
To abuse the notation, we use ``$\concat$'' to represent both string concatenation and list concatenation. 
Finally, we use the $\tt{flow}$ predicate to denote the immediate transitions between states. 




\subsection{From Programs to Guarded Omega-Regular Expressions} 
\label{subsec:progam2WRE}

The program $\mathcal{P}$ is comprised of a collection of procedures, defined in \figref{fig:CFG_language}. Each procedure is identified by a unique name $\nm$, and represented by a CFG with a starting node  \code{N} and a transition function $\E$. 
The transition function \code{\E} returns all the immediate successors of a given node. 
Nodes are parameterized with unique (integer) state identifiers, denoted by \code{s}. 
We assume that the sets of nodes in different procedures are pairwise disjoint. 
In addition to %the ``\code{\m{Start}}'' and ``\code{\m{Exit}}'' nodes, 
nodes that mark the start and end of a procedure, 
there are two other types of structural nodes to keep the CFG compact: the ``\code{\m{Join}}'' node and the ``\code{\m{Prune}}'' node. The \code{\m{Join}} node is used to connect disjunctive branches (usually created by conditionals, while loops, etc.), while the Prune node is used to specify branching behavior based on a given arithmetic formula. 
For example, a \code{\m{Join}} node's successors can be two \code{\m{Prune}} nodes with disjoint constraints. 
Finally, the ``\code{\m{Stmt}}'' node is used to store statements such as assignments, returns, and procedure calls, where the return value is explicitly denoted by variable \code{r}.  



{
\begin{figure}[!h]
\renewcommand{\arraystretch}{1}
\small
\centering
  $
  \begin{array}{lrcl}
    \m{(Program)} &  {\mathcal{P}} &\code{::=}&
 \m{proc}^* \qquad\qquad\quad\ \  
  \m{(Statements)} \quad  
  \m{e} \quad  \code{::=} \quad  
   x{:=} t \ 
  |\ \m{return}(x)\ 
  |\ \m{nm}({x^*, r})\ 
  \\[0.1em] 
  \m{(Procedure)} &    %\qquad  
  \m{proc}& \code{::=} & 
  \m{nm} = (N, \text{$\E$})
  \qquad\qquad\qquad \text{$\E$} \quad \code{::=}\quad 
  N \,{\rightarrow}\, N^*
  \\[0.1em]
  \m{(Nodes)} &  {N}&\code{::=}&
  \m{Start}(s) \ 
  |\  \m{Exit}(s) \ 
  | \ \m{Join}(s) \ 
  %| \ \m{Skip}(s) \ 
  | \ \m{Prune}(\pi, s)\ 
  | \ \m{Stmt}(e, s) \
  \end{array}  
  $
 \caption{The control-flow graph (CFG) representation of a target program} 
 \label{fig:CFG_language}
 \vspace{0mm}
\end{figure}
}




\begin{figure}[!b]%{r}{0.65\textwidth}
{
\small
\renewcommand{\arraystretch}{1}
$\begin{array}{lrcl}
\m{(Guarded~\omegaRE)}&    \effect &{\   ::=\  }&
\bot 
\mid \epsilon 
\mid \pi_s
\mid [\pi_s]
\mid \effect_1 \cdot \effect_2
\mid \effect_1 \vee \effect_2
\mid \effect^\omega  
\end{array}$
\vspace{-2mm}
\caption{Syntax of Guarded $\omegaRE$, 
the intermediate representation of a transition system}
\label{fig:Syntax_of_Omega_RE}
}
\vspace{-4mm}
\end{figure}


Our intermediate representation, called Guarded~$\omegaRE$, denoted by \effect, is defined in \figref{fig:Syntax_of_Omega_RE}. 
The formulas in \effect~are similar to those in classic \emph{Omega Regular Expressions} ($\omegaRE$), containing \code{\bot} for \emph{false}, \code{\epsilon} for empty traces, sequence concatenations (\code{\effect_1\cdot \effect_2}), disjunctions (\code{\effect_1\vee \effect_2}), and infinite repetitions of a trace constructed by \code{\effect^\omega}. 
The main difference is that in Guarded $\omegaRE$, singleton events can be either \code{\pi_s} or \code{[\pi_s]}. The former updates the program states with respect to the $\pi$ formula, while the latter serves as program guards. 
Program guards are adopted as sequential control structures and are the sole means of introducing and controlling non-determinism. 
For the formula ``$[\pi_s] \cdot \effect$'', the guarded trace \effect~is executed only when the guard does not fail. When checking a guard, a Boolean expression is evaluated. If it denotes false, the guard fails. If it denotes true, it allows the execution to proceed without affecting the program states. 
Moreover, Guarded~$\omegaRE$ does not contain Kleene stars as it aims to eliminate the unknown number of iterations using either fixed-number-length finite traces or $\omega$ formulas for infinite behaviors. 
We formally define \code{\effect}'s semantics in 
Appendix B.
%\appref{appsec:Semantics_wre}. 
%-- which possibly leads to cycles to itself -- 
Each procedure is converted to a Guarded~$\omegaRE$ formula via \algoref{alg:cfg2GuardedomegaRE}, 
which enumerates all the paths from the CFG and replaces the cycles using the loop summaries (cf. \secref{subsec:loop2wRE}). 



\begin{wrapfigure}{R}{0.56\textwidth}
\vspace{-3mm}
  \begin{minipage}{0.56\textwidth}
{
\small
\begin{algorithm}[H]
\caption{\textsc{CFG2GWRE}
{\small{(From CFG to Guarded~{$\omegaRE$})}}}\label{alg:cfg2GuardedomegaRE}
\begin{algorithmic}[1]
\Require (N, $\E$)
\Ensure \code{\effect}
\Switch{N} 
\Case {$\m{Exit(s)} \mid \m{Stmt(return(x), s)}$ $\rightarrow$}  \Return{$\nodeEv$(N)}
\EndCase 
\Case {$\m{Join(s)}$ $\rightarrow$}  
{\Switch{\textsc{existsCycle} (N, $\E$)} 
\Case{None $\rightarrow$ }  {\textsc{moveForward} (N, $\E$)}
\EndCase 
\Case{Some ($\effect_{\m{body}}$, N$_{\m{nonCycleSucc}}$) $\rightarrow$}  
\State{$\effect_{\m{nonCycle}}$ = \textsc{moveForward} (N$_{\m{nonCycleSucc}}$)} 
\State{$\effect_{\m{sum}} = \loopsummary~(\effect_{\m{body}},\effect_{\m{nonCycle}})$}
\\
\hspace{37.5pt} 
\Return{($\effect_{\m{nonCycle}} \vee \effect_{\m{sum}}$)}%
\EndCase 
\EndSwitch}
\EndCase 
\Case{\_ $\rightarrow$} \textsc{moveForward} (N, $\E$)
\EndCase 
\EndSwitch
\State
\Function{{{moveForward }}}{N, $\E$}  
\If{$\E$(N)=[]} \Return{$\nodeEv$(N)}
\Else \State{$\effect_{\m{acc}}$ = $\bot$}
\ForEach {N$^\prime$ $\in$ $\E$(N)}
\State{\quad $\effect_{\m{acc}}$ {=} $\effect_{\m{acc}}$ \,{$\vee$}\,  \textsc{CFG2GWRE} (N$^\prime$, $\E$) }
\EndFor
 \\ \hspace{17.5pt} \Return{($\nodeEv$(N) $\cdot$ $\effect_{\m{acc}}$)}
\EndIf 
\EndFunction
\end{algorithmic}
\end{algorithm}
}
\vspace{0mm}
\end{minipage}
\vspace{-3mm}
\end{wrapfigure}




Specifically, if the current node is an \emph{exiting} node (line 2), it returns its corresponding \code{\effect} formula. 
Here, $\nodeEv$(N) maps from nodes to Guarded $\omegaRE$.  
If the current node is a \code{\m{Join}} node, 
it firstly checks if it leads to a cycle via calling \textsc{existsCycle}  (line 4). The \textsc{existsCycle} function returns ``None'' if none of its successors leads to cycles; otherwise it returns ``Some ($\effect_{\m{body}}$, N$_{\m{nonCycleSucc}}$)'',  indicating that one successor of N leads to a path that comes back to itself, and $\effect_{\m{body}}$ denotes the behavior of one iteration of the cycle, and N$_{\m{nonCycleSucc}}$ is the other successor which does not directly lead to a cycle. 
We leave the detailed implementation of \textsc{existsCycle}  in 
Appendix D.

%\appref{appsec:existsCycle}. 
For the cycle behavior, it sends $\effect_{\m{body}}$ for a summary calculus, denoted by $\effect_{\m{sum}}$, and 
computes the behaviors starting from  N$_{\m{nonCycleSucc}}$ denoted by $\effect_{\m{nonCycle}}$; finally returns a disjunctive form of both possibilities (line 9).  
In all other cases (lines 5 and 10), it uses an auxiliary function called \textsc{Moveforward} to recursively combine the behaviors of all the following nodes. If there are no successors, \textsc{Moveforward} terminates; otherwise, it goes through the successors and applies 
%the 
\textsc{CFG2GWRE} 
%algorithm 
to calculate the formulas for the remainder of the path. It then disjunctively combines the outcomes with an accumulator,  initialized with \code{\bot} (line 15). 

The function $\nodeEv$, as described in  \defref{def:NodeS2Singleton_Events}, maps the \code{\m{Prune}} nodes into guards and excludes the \code{\m{Join}} nodes using  ``\code{\epsilon}''. 
Specifically, for procedure calls where the callee is not defined locally, we model the results as non-deterministic choices, denoted by \code{Eq(r, \_)}; otherwise, we retrieve the callee's summary \code{\effect_{\m{nm}}}; and create an abstract predicate %``$\effect_{\nm}(x^*,r)$'' 
upon the actual arguments \code{x^*} and the return value \code{r}, which over-approximates the possible valuations of \code{r}.





{
\begin{definition}[Nodes to Guarded $\omegaRE$]
  \label{def:NodeS2Singleton_Events}
Given any nodes \code{N}, 
we define: 
{
\small
\begin{gather*}
\nodeEv{(\m{Start}(s))} {\nodeEvop} (\m{Start}())_{s}  
\qquad    
\nodeEv{(\m{Exit}(s))}{\nodeEvop} ((\m{Exit}())_{s})^\omega  \qquad 
\nodeEv{(\m{Join}(s))} {\nodeEvop} \epsilon %(\m{Join}())_{s} 
\qquad 
\nodeEv{(\m{Prune}(\pi,s))}{\nodeEvop} [\pi]_s 
\\
\nodeEv{(\m{Stmt}(x{:=}t,s))} {\nodeEvop} (x{=}t)_s  \qquad \qquad 
\nodeEv{(\m{Stmt}(\m{return}(x),s))}{\nodeEvop} 
((\m{Exit}(x))_s)^\omega
\\
\nodeEv{(\m{Stmt}(\m{nm}(x^*,r),s))}{\nodeEvop} (Eq(r,\_))_s 
\   {\text{\fbox{$\m{nm}\,{\not\in}\,\mathcal{P}$}}}
\qquad 
\nodeEv{(\m{Stmt}(\m{nm}(x^*,r),s))}{\nodeEvop} (\effect_{\m{nm}}(x^*,r))_s 
\  {\text{\fbox{${\m{nm}}\,{\in}\,\mathcal{P}$}}}
\\[-0.5em]
\end{gather*}
}
\end{definition}
}





\subsection{From CFG Cycles to Guarded Omega-Regular Expressions }
\label{subsec:loop2wRE}
%We construct summaries for loops, starting 
 %during the analysis. 
 %of our loop summarization 
Summaries are constructed from the innermost loop. In the case of nested loops, inner loops are expected to be 
replaced with summaries. 
At any point during the analysis, the problem is therefore reduced to the analysis of a single loop. 
Intuitively, our loop summaries aim to replace terminating \footnote{A loop terminates if a ranking function exists, which is non-negative and decreases at each iteration of the loop.} behaviors using their final states, and convert non-terminating behaviors using invariants, and wrap them in the $\omega$ representations.  
The key (but simplified) insights are illustrated via \code{[\m{LS}\text{-}\m{Key}]}. 

{
\small
\begin{align*}
\frac{
\begin{matrix}
\effect_{\m{body}}{=}[\pi_g] \cdot \effect 
\qquad\quad  
\text{\highlight{(\exists\, \m{rf} \,{\in}\, \RF(\pi_g)) ~\m{s.t.}~~ 
(?\pi_{\m{wpc}} \,{\wedge}\, \pi_g  \,{\Rightarrow}\, 
\boxed{\Delta \m{rf}(\effect) \,{\geq}\, 1})}}
\\
\effect_{\m{term}} \,{=}\, [\pi_{\m{wpc}}]  \cdot (\m{rf} {<} 0) \cdot \effect_{\m{nonCycle}} 
\qquad  
\effect_{\m{nonTerm}} \,{=}\, [\neg \pi_{\m{wpc}}]  \cdot  ((\m{rf} {\geq} 0) \cdot 
\m{invariant} (\effect_{\m{body}}) )^\omega \\
\end{matrix}
}
{\loopsummary~(\effect_{\m{body}},\effect_{\m{nonCycle}})  \leadsto [\pi_g] \cdot  (\effect_{\m{term}} \vee \effect_{\m{nonTerm}})} \ \   [\m{LS}\text{-}\m{Key}]
\\[-0.7em]
\end{align*}
}




{
\begin{figure}[!b]
\vspace{-2mm}
\begin{definition}[Soundly Guessing Simple LRFs from Pure]
  \label{def:rankingFunction}
\input{guessingLRFs}
\end{definition}
\vspace{-5mm}
\end{figure}
}


%, i.e.,  \code{((\m{rf} {>} 0) \cdot \m{invariant} (\effect_{\m{body}}) )^\omega}. 


Instead of being directly dedicated to the ranking function synthesis problem, we obtain a set of candidate 
\emph{linear ranking functions} (LRFs) via \emph{guessing} from the loop guard \code{\pi_g}, denoted by \code{\RF(\pi_g)},  detailed in \defref{def:rankingFunction}. 
And if there exists a ranking function \code{\m{rf}} which always decreases in the loop body with a %(non-false) 
weakest precondition (WP) \code{\pi_{\m{wpc}}} (as {\colorbox{mGray1}{highlighted}}), we could summarise the final state of the terminating behaviors to be ``\code{\m{rf}{<}0}'', and when \code{\pi_{\m{wpc}}} does not hold, the loop is non-terminating with a repeated pattern. 
We use \code{(?\pi_{\m{wpc}} \,{\wedge}\, \pi_1  \,{\Rightarrow}\, \pi_2)} to mean that \code{\pi_{\m{wpc}}} is the WP for the implication \code{\pi_1  \,{\Rightarrow}\, \pi_2} to hold. 
The difference between the initial value of $\m{rf}$ and the updated value $\m{rf}^\prime$ after the transition \code{\effect} is denoted by \code{\Delta \m{rf}(\effect)}, i.e., \code{\Delta \m{rf}(\effect) \,{=}\, \m{rf} \,\text{-}\, \m{rf}^\prime}. And \code{\m{invariant} (\effect_{\m{body}})} means to summarise a trace invariant of the infinitely repeating behavior, c.f., \figref{fig:example:Infinite_Loops_2}. 


It is worth mentioning that it is important to safely over-approximate the set of possible ranking functions to keep the analysis sound -- if it concludes that a loop is terminating, then the loop must be terminating. However, it could not be complete, as it is possible that the actual ranking function may never be sufficiently guessed or it is in a more complex form (e.g., polynomial). In such a case, our approach is extensive, as the ranking function can be provided through specifications or by utilizing the existing ranking function synthesis tools for its generation. Nonetheless, our experimental results show that our proposal performs well even without any aid, cf. \tabref{tab:comparewithFuntionT2} and \tabref{tab:comparewithCook}, particularly in the linear domain with LRFs. We prove the soundness of \defref{def:rankingFunction} upon choosing the candidate ranking functions in 
Appendix C. 
%\appref{app:soundlyChoosingRF}. 

\noindent\paragraph{\textbf{Lexicographic Ranking Functions and Multiphase Ranking Functions}} 

Several other ranking functions have been suggested \cite{DBLP:conf/cav/Ben-AmramG17} other than LRFs that we have primarily used.  
Informally, 
using \emph{lexicographic linear ranking functions} (LLRFs), 
one can prove the termination of a loop by considering a tuple, say a pair $\langle \m{f}_1,  \m{f}_2 \rangle$ of linear functions, such that either $\m{f}_1$ decreases, or $\m{f}_1$ does not
change and $\m{f}_2$ decreases; and 
using \emph{multiphase-linear ranking functions} (M$\Phi$RFs), the loop goes through phases, and each phase is finite, as it is associated
with a value that is non-negative and decreasing during that phase. In other words, each phase is linearly ranked. 
To handle LLRFs and M$\Phi$RFs, we replace the \boxed{\rm{boxed}} constraint in \code{[\m{LS}\text{-}\m{Key}]} for WP propagation with 
\defref{def:LLRFs} and \defref{def:MFRFs}, respectively. We say that \code{\effect} is ranked by \code{f_i}, for the minimal such \code{i}. 
%the following definitions. 


\begin{definition}[LLRFs]
\label{def:LLRFs}
Given $\m{rf}{=}\langle \m{f}_1, \dots, \m{f}_d \rangle$, at least one of the ranking functions (\code{f_i}) decreases towards 0, and the preceding ranking functions do not increase. Let index $i \,{\in}\, [1, d]$: 
\begin{gather*}
\forall j {<} i. ~ \Delta \m{f}_j (\effect) \geq 0,  
\quad and \quad 
\Delta \m{f}_i(\effect) {\geq} 1, 
\quad assuming \quad 
\m{f}_i {\geq} 0.
\end{gather*}
\end{definition}



\begin{definition}[M$\Phi$RFs]
\label{def:MFRFs}

Given $\m{rf}{=}\langle \m{f}_1, \dots, \m{f}_d \rangle$,  
the ranking functions (\code{f_i}) decrease towards 0 by phases, and  
each phase is linearly ranked. 
Let index $i \,{\in}\, [1, d]$:  
\begin{gather*}
\forall j {\leq} i. ~ \Delta \m{f}_j (\effect) \geq 1,  
\quad and \quad 
\forall j {<} i. ~ \m{f}_j {<} 0, 
\quad assuming \quad 
 \m{f}_i {\geq} 0. 
\end{gather*}
\end{definition}


It is not hard to see that the current constraint in \code{[\m{LS}\text{-}\m{Key}]} corresponds to a M$\Phi$RF where \code{d{=}1}. \syh{TBD}


\begin{wrapfigure}{R}{0.35\columnwidth}
\vspace{1mm}
\begin{lstlisting}[numbersep=7pt,basicstyle=\footnotesize\ttfamily]
void main () { (*@\textcolor{mGray}{//$AF(\m{Exit}())$}@*)
  int m,n; int step=8; 
  while (1) {
    m = 0;
    while (m < step){
      if (n < 0) return; 
      else {
        m = m + 1;
        n = n - 1; }}}}
\end{lstlisting} 
\vspace{0mm}
\caption{A nested loop} 
\label{fig:Termination_analysis_without_the_tears}
\vspace{-6mm}
\end{wrapfigure}

\vspace{-2mm}
\noindent\paragraph{\textbf{Breaks in a Loop}}
We show that \code{[\m{LS}\text{-}\m{Key}]} can be extended to handle more complex control flows, using an example from the work of \citet{DBLP:conf/pldi/0001K21}, in \figref{fig:Termination_analysis_without_the_tears}. 
The program has nested loops, where the outer loop is structurally non-terminating, and the inner loop terminates by either only exiting the inner loop or completely exiting the program. 
First, we extend the ranking function guessing process to the constraints, which leads to termination inside the loop, here ``\code{n}'', from line 6. Given \code{\RF_{\m{inner}}{=}\s{(\m{step}\text{-}m\text{-}1);(n)}}, we observe that both of them lead to termination with a \emph{true} precondition. Thus, we summarise the inner loop, $\effect_{\m{inner}}$, as follows: 

\begin{enumerate}
\item $[(\m{step}\text{-}m\text{-}1) {\geq} n]  \cdot (n'{<}0)  \cdot (\m{Exit}())^\omega$;   
\item $[(\m{step}\text{-}m\text{-}1) {<} n] \cdot (m'{\geq}\m{step})  \cdot (n'{=}n \text{-} ((\m{step}\text{-}m\text{-}1)\text{+}1))$. 
\end{enumerate}

\begin{comment}
\begin{enumerate}
\item $[(\m{step}\text{-}1) \,{\geq}\, n)]  \cdot (n'{<}0)  \cdot (\m{Exit}())^\omega$;   
\item $[(\m{step}\text{-}1) \,{<}\, n] \cdot (m'{\geq}\m{step})  \cdot (n'{=}n \text{-} \m{step} )$. 
\end{enumerate}
\end{comment}

When it comes to the outer loop, with \code{m{=}0} instantiated, 
%instantiating the concrete value of \code{m} to be 0, 
the outer loop body has became:  
\[ \effect_{\m{outer\_body}} \equiv  
[(\m{step}\text{-}1) \,{\geq}\, n)]  \cdot (n'{<}0)  \cdot (\m{Exit}())^\omega  
~\vee~ 
[(\m{step}\text{-}1) \,{<}\, n] \cdot (m'{\geq}\m{step})  \cdot (n'{=}n \text{-} \m{step} )
\]



Then, we propagate the possible ranking function from $\effect_{\m{outer\_body}}$ and obtain 
\code{\RF_{\m{outer}}{=}\s{(n\text{-}\m{step})}}. To prove it is decreasing at each iteration, we achieve: 
\code{(n\text{-}\m{step})\text{-}((n\text{-}\m{step})\text{-}\m{step}) {\geq}1}, which is reduced to \code{\pi_{\m{wpc}} \,{=}\, \m{step} {\geq} 1}. 
Therefore, eventually, we know that when \code{\m{step} {\geq} 1} the whole program always terminates; thus, \toolName~ manages to prove termination since ``\code{\m{step}}'' is assigned to 8 at line 2. 

Intuitively, these complex control flows are handled by 
dividing the loop body behaviors into \emph{leaking} paths and \emph{non-leaking} paths. Statements like \emph{break}, \emph{return}, or non-terminating behaviors would interrupt the loop cycle; thus, they lead to leaking paths, as opposed to the others, such as \emph{continue}, which stay in non-leaking paths.  
\toolName~ could look for possible ranking functions from the (negated) guards in leaking paths, here the first path of $\effect_{\m{outer\_body}}$. 


\hide{
We conclude the summary of the outer loop as follows: 
$\effect_{4\text{-}11} \equiv  
(([0{\geq}\m{step}] \cdot \epsilon)^\omega) 
\vee  ([0{<}\m{step}] \cdot (n{<}0) \cdot (\m{Exit}())^\omega)
$. 
The summary indicates that if \emph{step} is non-positive, the program gets into an infinite loop. 
Therefore, after composing with the outer loop, the program chooses to take the second disjunctive trace (due to the assignment at line 3), where the $\m{Exit}()$ predicate appears by the end. Thus we have compositionally proved the termination property $AF(\m{Exit}())$. 



A ranking function is defined as $\m{RF} {=} (t, \effect)^*$, which is a set of tuples, where $t$ is the decreasing term, and terminates when $t{\leq}0$, and once it terminates $\effect$ is the behaviors afterwards.  We derive a of possible ranking functions from the given cycle body. 
A ranking function is defined as $\m{RF} {=} (t, \effect)^*$, which is a set of tuples, where $t$ is the decreasing term, and terminates when $t{\leq}0$, and once it terminates $\effect$ is the behaviors afterwards.  We derive a of possible ranking functions from the given cycle body. 

}







\hide{The loop cycles are in the normal form of 
``$[\m{RF}{>}0] \cdot \bigvee \effect$'' where $\m{RF}$ is the ranking function, and $\bigvee \effect$ are the disjunctive behaviours of the loop body. 
Let 
\[\effect_{\m{inf}} {=} \s{([\m{RF}{>}0] \cdot (\m{RF}{>}0) \cdot \effect_i)^\omega \mid 
(\forall \effect_i \in \effect)~.~ (\m{RF} \,\text{-}\,  \effect_i(\m{RF}))   {<} 1 } \]
and 
\[\effect_{\m{finite}} {=} \s{\effect_i \mid 
(\forall \effect_i \in \effect)~.~ (\m{RF} \,\text{-}\,   \effect_i(\m{RF}))   {\geq} 1 } \]

From $\effect_{\m{finite}}$ we will be computing 
$\effect_{\m{finite}}^\prime = TBD$ 
and the final summary is $\effect_{\m{finite}}^\prime \vee \effect_{\m{inf}}$. 

}


\vspace{-1mm}
\subsection{From Guarded Omega-Regular Expressions to Datalog Programs} 

There are two main tasks for generating a Datalog program from given $\effect$ for checking property $\phi$: 
\begin{itemize}[itemsep=0.1ex,leftmargin=0.4cm]
\item Produce the facts and rules for transition flows, which describe the skeleton of a program; and
\item Map concrete program states into symbolic predicates and generate the corresponding facts, which decide which set of paths in the program skeleton will be taken. 
\end{itemize} 


{\begin{definition}[Get Symbolic Predicates from $\effect$]
  \label{def:getPure_effect}
Given any Guarded $\omegaRE$ formula \code{\effect}, 
we define: 
{\small
\begin{gather*}
\getPure{(\bot)} {\getPureop} \getPure{(\epsilon)} {\getPureop}
\getPure{(\pi_s)} {\getPureop}\emptyset
\qquad \qquad 
\getPure{([\pi]_s)} {\getPureop}\s{\pi} 
\qquad \qquad 
\getPure{(\effect^\omega)} {\getPureop} \getPure{(\effect)}
\\
\getPure{(\effect_1 \cdot \effect_2)} {\getPureop}
\getPure{(\effect_1 \vee \effect_2)} {\getPureop}
\getPure{(\effect_1)} \cup \getPure{(\effect_2)}
\\[-0.9em]
\end{gather*}
}
\end{definition}
}




{\begin{definition}[Get Symbolic Predicates from $\phi$]
  \label{def:getPure_CTL}
Given any core CTL formula \code{\phi}, 
we define: 
{\small
\begin{gather*}
\getPure{((nm, \pi))} = \s{\pi} 
\qquad\qquad  
\getPure{(\neg\phi)}{=} 
\getPure{(EX~\phi)}{=}\getPure{(EF~\phi)}{=}\getPure{(AF~\phi)} = \getPure(\phi)  
\\   
\getPure{(E(\phi_1 \,U\, \phi_2))}{=}
\getPure{(\phi_1 \wedge \phi_2)}{=}\getPure{(\phi_1 \vee \phi_2)} = \getPure(\phi_1) \cup  \getPure(\phi_2)
\\[-0.9em]
\end{gather*}
}
\end{definition}
}



To begin with, we extract the symbolic predicates from the Guarded $\omegaRE$ and the CTL property of interest using \defref{def:getPure_effect} and \defref{def:getPure_CTL}, respectively. The \emph{Pure}(\code{\effect}) function collects all the guards from \code{\effect}, while the \emph{Pure}(\code{\phi}) function gathers all predicates that $\phi$ is looking for. 
Next, we provide the definitions of the  
deployed auxiliary functions: 
\emph{Nullable}(\code{\delta}), 
\emph{First}(\code{\m{fst}}), and \emph{Derivative}(\code{\deri}). Informally, the Nullable function \code{\delta(\effect)} 
returns a Boolean value indicating whether \code{\effect} 
contains the empty trace; 
the First function \code{\m{fst}( \effect)} computes a set of 
possible initial trace segments from \code{\effect};
the Derivative function \code{\deri_{f}(\effect)} 
 eliminates a segment \code{f} from the head of \code{\effect} 
 and returns what remains. 




\begin{definition}[Nullable]\label{Nullable}
Given any \code{\effect}, we define \code{\delta(\effect)} as follows: ({\code{\m{false}} for unmentioned constructs})
{ \small
\vspace{-3mm}
  \begin{gather*}
\delta(\epsilon) {=}\m{true}
\quad\qquad 
\delta(\effect_1 \cdot \effect_2) {=} \delta(\effect_1) {\wedge} \delta(\effect_2)
\quad\qquad 
\delta(\effect_1 \vee \effect_2) {=} \delta(\effect_1) {\vee} \delta(\effect_2)
\\[-0.9em]
\end{gather*}}
\end{definition}

\begin{definition}[First]\label{First1}
We define \code{\m{fst}(\effect)} to be the set of 
initial segments derivable from a   
\code{\effect} formula. 
{\small
\begin{gather*} 
\m{fst}(\bot) {=}
 \m{fst}(\epsilon) {=} \emptyset
\qquad\ \ 
 \m{fst}(\pi_s) {=} \{ \pi_s\}
\qquad\ \ 
 \m{fst}([\pi]_s) {=} \{ [\pi]_s\}
\qquad\ \ 
\m{fst}(\effect_1 {\vee} \effect_2) {=} \m{fst}({\effect_1}) \cup \m{fst}({\effect_2}) 
\\
\m{fst}(\effect^\omega) {=} \{ \effect^\omega \}
\qquad\qquad\qquad 
\m{fst}(\effect_1 \cdot \effect_2) {=} 
\begin{cases}
\m{fst}({\effect_1}) \cup \m{fst}({\effect_2}) & \m{if}\quad  \delta(\effect_1) {=} \m{true}
\\
\m{fst}(\effect_1) & \m{if}\quad \delta(\effect_1) {=} \m{false}
\end{cases} 
\\[-0.9em]
\end{gather*}
}
\end{definition}




\begin{definition}[Derivative]\label{Derivative}
The derivative \code{\deri_{f}(\effect)} 
of a trace \code{\effect} 
w.r.t. a segment \code{f} computes the effects for the left quotient, 
\code{f^{\text{-}1} \effect}, defined as follows: 
({\code{\bot} for unmentioned constructs})
{
{  \small
\begin{gather*}
\deri_{\pi_s}(\pi_s)  {=} \epsilon
\qquad\quad  
\deri_{[\pi]_s}([\pi]_s)  {=} \epsilon
\qquad\quad  
\deri_{\effect^\omega}(\effect^\omega)  {=} \epsilon
\qquad\quad  
\deri_{f}(\effect_1 {\vee} \effect_2) {=}
\deri_{f}(\effect_1) {\vee} \deri_{f}(\effect_2) 
\\
\deri_{f}(\effect_1 \cdot \effect_2) {=}
\begin{cases}
(\deri_{f}(\effect_1) \cdot \effect_2) \vee \deri_{f}(\effect_2)\quad & \m{if}\quad  
\delta(\effect_1) {=} \m{true}\\
\deri_{f}(\effect_1) \cdot \effect_2& \m{if}\quad \delta(\effect_1) {=} \m{false}
\end{cases}
\\[-0.9em]
\end{gather*}}
}
\end{definition}





\begin{figure}[!t]
\small
\begin{gather*}
\frac{
\begin{matrix}
[\toDatalogRule\m{Base}]%\text{-}\m{Fst}
\\
\m{fst}(\effect){=}\s{} 
\qquad 
\Datalog{=}\predFlow(\prevS, \prevS)
\end{matrix}
}{
\RETOD{\prevS}{\pathPure}{\effect}{\Datalog}
}
\qquad \qquad      
\frac{
\begin{matrix}
\m{F}{=}\m{fst}(\effect) \qquad 
\Pi{=}\m{Pure}(\effect)
\\
(\forall f_i \,{\in}\, \m{F}). ~ 
\RETODHelper{\Pi}{f_i}{\prevS}{\pathPure}{\deri_{f_i}(\effect)}{D_i}
\end{matrix}
}{
\RETOD{\prevS}{\pathPure}{\effect}{{\bigvee} D_i}
}\ \ [\toDatalogRule\m{Ind}]
\\[0.9em]  
\frac{
\begin{matrix}
\RETOD{\prevS}{\pathPure}{\effect}{\Datalog_1}
\qquad 
\Datalog_2{=} \m{tailToHeadFlows}(\effect)
\end{matrix}
}{
\RETODHelper{\Pi}{\effect^\omega}{\prevS}{\pathPure}{\_}{\Datalog_1 {\concat} \Datalog_2}
}[\toDatalogRule\m{Omega}]
\\[0.2em] 
\frac{
\begin{matrix}
\Datalog_1{=} [\predFlow (\prevS, S) \datalogarrow \pathPure.]
\\[0.2em]
\Datalog_2{=} \s{\pi^\prime(S)  \mid \forall \pi^\prime {\in} \Pi~.~ \pi{\Rightarrow} \pi^\prime)}
\\[0.1em]
\RETOD{S}{\pathPure}{\effect}{\Datalog_3}
\end{matrix}
}{
\RETODHelper{\Pi}{\pi_s}{\prevS}{\pathPure}{\effect}{\Datalog_1{\concat} \Datalog_2{\concat} \Datalog_3}
} [\toDatalogRule\m{Pure}]
\qquad  
\frac{
\begin{matrix}
\pathPure^\prime = \pathPure {\wedge} \pi
\\ 
\Datalog_1{=} [\predFlow (\prevS, S) \datalogarrow \pi^\prime_{\m{path}}.]
\\ 
\RETOD{S}{\pathPure^\prime}{\effect}{\Datalog_2}
\end{matrix}
}{
\RETODHelper{\Pi}{[\pi]_s}{\prevS}{\pathPure}{\effect}{\Datalog_1{\concat}\Datalog_2}
} [\toDatalogRule\m{Guard}]
\end{gather*}
\vspace{-1mm}
\caption{Translating a Guarded $\omegaRE$ to a Datalog program} 
\label{fig:WRE_2_Datalog}
\vspace{-1mm}
\end{figure}



Finally, \figref{fig:WRE_2_Datalog} presents translation rules, denoted by the relation: $\RETOD{\prevS}{\pathPure}{\effect}{\Datalog}$, where \code{\Pi} is a set of symbolic predicates, \code{\prevS} is the preceding state, \code{\pathPure} is the accumulated path constraint, and the formula \code{\effect} will be converted into the Datalog program \code{\Datalog}. 
The translation is initially invoked with $\Pi{=}\m{Pure}(\effect) \,{\cup}\, \m{Pure}(\phi)$,  $\prevS{=}\text{-}1$ and $\pathPure{=}T$. 
If the given \code{\effect} contains no \emph{initial} elements, i.e., it is already the end of the trace, 
rule \code{[\toDatalogRule\m{Base}]} simply adds a self-transition flow. 
Otherwise, \code{[\toDatalogRule\m{Ind}]} disjunctively combine the Datalog programs generated from each initial segment and their derivatives via the relation \code{\RETODHelper{\Pi}{f}{\prevS}{\pathPure}{\effect}{\Datalog}}. 
There are three kinds of initial segments: 
(i) if it is \code{\effect^\omega}, apart from the Datalog program generated from \code{\effect}, \code{[\toDatalogRule\m{Omega}]} also generates the flow facts 
connecting end and start states of \code{\effect}; 
(ii) if it is \code{\pi_s}, \code{[\toDatalogRule\m{Pure}]} generates a flow rule from the previous state ``$\prevS$'' to the current state ``$S$'' and generates facts for symbolic predicates which the current state satisfies; 
lastly, (iii) if it is \code{[\pi]_s}, \code{[\toDatalogRule\m{Guard}]} updates the path constraints via adding the the current guard, and continues to generate the Datalog program for the rest of the trace. 
Rule ``${\tt{flow}}(S, S') \datalogarrow T$'' will be reduces to a simple fact $\tt{flow}(S, S')$. 









\input{repair.tex}



\section{Implementation and Evaluation}
\label{sec:evaluation}

We prototype our proposal into a program analysis and repair tool \toolName, using approximately 5K lines of OCaml and 5K lines of Python code. 
To show the effectiveness of \toolName, we design the experimental evaluation to answer the 
following research questions (RQ): 



\begin{itemize}[align=left, leftmargin=*,labelindent=0pt]
\item \textbf{RQ1:} What is the effectiveness of \toolName in verifying CTL properties in a set of relatively small yet challenging programs, compared to the state-of-the-art tools, T2~\cite{DBLP:conf/fmcad/CookKP14},  \function~\cite{DBLP:conf/sas/UrbanU018}, and \ultimate~\cite{DBLP:conf/cav/DietschHLP15}. 


\item \textbf{RQ2:} What is the effectiveness of \toolName in finding bugs for real-world programs, which can be encoded using CTL properties, such as termination bugs gathered from GitHub \cite{DBLP:conf/sigsoft/ShiXLZCL22} and liveliness bugs in protocol implementations \cite{DBLP:conf/icse/MengDLBR22}. 

\item \textbf{RQ3:} What is the effectiveness of \toolName in repairing CTL bugs (programs that fail to satisfy the given CTL property) from RQ1 and RQ2, which has not been achieved by any existing works.   


%CTL bugs, in real-world projects. We use two benchmarks, one for termination bugs and another for protocol implementations.  

%which can be encoded for a variety of bug classes, such termination bugs, wrong arithmetic conditions for conditional etc,

% and repairing 

%\item \textbf{RQ3:} What is the effectiveness of \toolName in fixing CTL bugs,   

\end{itemize}

%The benchmark programs are from various sources. More specifically, termination bugs from real-world projects \cite{DBLP:conf/sigsoft/ShiXLZCL22} and CTL analysis \cite{DBLP:conf/fmcad/CookKP14} \cite{DBLP:conf/sas/UrbanU018}, and temporal bugs in real-world protocol implementations \cite{DBLP:conf/icse/MengDLBR22}. 
Experiments were done on a MacBook with a 2.6 GHz 6-Core Intel
i7 processor. 
%The source code and the evaluation benchmark are openly accessible \cite{zenodo_benchmark}. 


\subsection{RQ1: Verifying CTL properties}

% Please add the following required packages to your document preamble:
%  \Xhline{1.5\arrayrulewidth}
\begin{table}[!b]
\caption{\label{tab:comparewithFuntionT2} 
Experimental results for CTL analysis, comparing with \function and \terminator. Here, ``\textbf{Exp.}'' marks the expected results, and ``\textbf{Time}'' records the execution times (in seconds). For each tool, we use ``{\cmark}'', ``{\xmark}'', and ``{\unk}'' to represent the proved, disproved, and unknown return results, respectively. Moreover, we use ``-'' when the tool cannot parse the formula or the input program, and ``TO'' represents a timeout with a 30-second limit. 
%represents when does not terminate in the 30 seconds allocated for each tool run. 
} 
  \small
  \renewcommand{\arraystretch}{1}
  \setlength{\tabcolsep}{1.4pt}  
%\Xhline{1.5\arrayrulewidth}
\vspace{-2mm}
\begin{tabular}{c|l|c|c|c|cc|cc|cc}
\Xhline{1.5\arrayrulewidth}
\multicolumn{1}{l|}{\multirow{2}{*}{\textbf{}}} & \multirow{2}{*}{\textbf{Program}} & \multirow{2}{*}{\textbf{Loc}} & \multirow{2}{*}{\textbf{CTL Property}}            & \multirow{2}{*}{\textbf{Exp.}} & \multicolumn{2}{c|}{\textbf{\function}}             & \multicolumn{2}{c|}{\textbf{\terminator}}                   & \multicolumn{2}{c}{\textbf{\toolName}}             \\ 
\cline{6-11} 
\multicolumn{1}{l|}{}                           &                                   &                               &                                                   &                                & \multicolumn{1}{c|}{\textbf{Res.}} & \textbf{Time} & \multicolumn{1}{c|}{\textbf{Res.}} & \textbf{Time} & \multicolumn{1}{c|}{\textbf{Res.}} & \textbf{Time} \\ \Xhline{1.5\arrayrulewidth}

1                                                & AF\_terminate                     & 25                            
& AF(Exit())                                    & \xmark                       & \multicolumn{1}{c|}{\unk}        & 0.021            & \multicolumn{1}{c|}{\unk}              &         0.414      & \multicolumn{1}{c|}{\xmark}      & 0.31           \\ 

2                                                & toylin1 (\figref{fig:terminating_loop})                         & 32                            
& EF(resp{${\geq}$}5)                        & \cmark                       & \multicolumn{1}{c|}{\unk}        & 0.064            & \multicolumn{1}{c|}{\xmark}              &   0.294            & \multicolumn{1}{c|}{\xmark}      &    0.456           \\ 

3                                                & timer-simple …                    & 26                            & AG((timer\_1=0{$\rightarrow$}AF(output\_1=1))) & \cmark                       & \multicolumn{1}{c|}{\unk}        &  1.739            & \multicolumn{1}{c|}{\xmark}              &   0.867            & \multicolumn{1}{c|}{\cmark}      &  0.406             \\ 

4                                                & AGAF…(\figref{fig:example:Infinite_Loops_2})                      & 16                            & AG((AF(t=1)){$\wedge$}(AF(t=0)))                       & \cmark                       & \multicolumn{1}{c|}{\unk}        & 0.034            & \multicolumn{1}{c|}{\xmark}              &   0.597            & \multicolumn{1}{c|}{\cmark}      &  0.135
            \\ 

5                                                & coolant\_basi …                   & 76                            & AU(init=0)(AU(init=1)(AG(init=3)))                & \cmark                       & \multicolumn{1}{c|}{\unk}        & 6.615            & \multicolumn{1}{c|}{-}              &        -        & \multicolumn{1}{c|}{\xmark}      &    0.678
          \\

6                                                & AF\_Bangalo …                     & 22                            
& AG((y{<}1)$\rightarrow$AF(x{<}0))                                 & \cmark                       & \multicolumn{1}{c|}{\unk}        & 0.345            & \multicolumn{1}{c|}{\xmark}              &       0.249        & \multicolumn{1}{c|}{\cmark}      &   0.228
           \\ 

7                                                & AFParity...(\figref{fig:first_Example})                 & 14                            
& AF(y=1)                                          & \cmark                       & \multicolumn{1}{c|}{\unk}        & 0.012            & \multicolumn{1}{c|}{\unk}              &    0.362           & \multicolumn{1}{c|}{\cmark}      &   0.248            \\ 

8                                                & Nested... (\figref{fig:Termination_analysis_without_the_tears})                       & 20                            & AF(Exit())                                      & \cmark                       & \multicolumn{1}{c|}{\unk}        &  0.196             & \multicolumn{1}{c|}{\unk}              &    0.553           & \multicolumn{1}{c|}{\cmark}      &   0.665
            \\ 

9                                                & acqrel.c                          & 42                            
& AG((A=1){$\rightarrow$}AF(R=0))                    & \cmark                       & \multicolumn{1}{c|}{\cmark}      &  0.040             & \multicolumn{1}{c|}{\xmark}              &       0.786        & \multicolumn{1}{c|}{\cmark}              &   0.6
             \\ 

10                                               & test\_existent…                   & 23                            & 
EF(r=1)                                         & \cmark                       & \multicolumn{1}{c|}{\unk}        &  0.022             & \multicolumn{1}{c|}{\xmark}              &      0.283         & \multicolumn{1}{c|}{\cmark}              &   0.277            \\ 

11                                               & test\_global.c                    & 14                            
& AF(AG(y{>}0))                      & \cmark                       & \multicolumn{1}{c|}{\unk}        &   0.219            & \multicolumn{1}{c|}{\cmark}              &     0.694          & \multicolumn{1}{c|}{\cmark}              &   0.367
           \\ 

12                                               & test\_until.c                     & 13                            & 
AU(x$>$y)(x{$\leq$}y)                  & \xmark                       & \multicolumn{1}{c|}{\cmark}      &  0.033           & \multicolumn{1}{c|}{-}              &      -         & \multicolumn{1}{c|}{\xmark }              &     0.185
          \\ 

13                                               & next.c                            & 7                             
& AX(AX(x=0))                                        & \xmark                       & \multicolumn{1}{c|}{\unk}        &  0.005             & \multicolumn{1}{c|}{TO}              &     -          & \multicolumn{1}{c|}{\xmark}              &   0.299            \\ 

14                                               & multiChoice.c                     & 39                            
& AF((x=4)$\vee$(x=-4))                           & \cmark                       & \multicolumn{1}{c|}{\cmark}      &  0.077             & \multicolumn{1}{c|}{\cmark}              &     0.409          & \multicolumn{1}{c|}{\cmark}              &  1.365
            \\


15                                               & multiChoice.c                     & 39                            
& EF(x=4) $\wedge$ EF(x=-4)                   & \cmark                       & \multicolumn{1}{c|}{\unk}        &  0.086             & \multicolumn{1}{c|}{\cmark}              &      0.296         & \multicolumn{1}{c|}{\cmark}              &  1.421
           \\ \Xhline{1.5\arrayrulewidth}
& {\bf{Total}}                              & 408                           &                                                &                                & 
\multicolumn{1}{c|}{13.3\%}              &   9.509            & \multicolumn{1}{c|}{20\%}              &  >5.804            & \multicolumn{1}{c|}{86.7\%}              &   7.64           \\ \Xhline{1.5\arrayrulewidth}
\end{tabular}
\vspace{-4mm}
\end{table}




The programs in \tabref{tab:comparewithFuntionT2} are selected from \function and \terminator evaluation benchmarks. These programs are usually short but challenging, as they involve complex loops, or the target properties require a more precise analysis. 
The failure from \terminator~ for programs 1, 7-8 is because it could not find the rank function, and \terminator has limited support for ``until'' operators, which are needed for programs 5 and 12. \function is usually conservative and loses precision due to a  \emph{dual widening} \cite{DBLP:conf/tacas/CourantU17}, and likely to return \emph{unknown} results. 
On the other hand, \toolName shows its advantages with an 86.7\% accuracy rate, achieved by separating the termination analysis and CTL analysis, where the latter is always precise. In other words, the imprecision only comes from the current techniques for loop summarization. We illustrate the limitation using the program 2, in \figref{fig:terminating_loop}. 

%the assorted analysis with termination, such as the \emph{counterexample-based ranking function synthesis} in \cite{DBLP:conf/fmcad/CookKP14}  and the 



\begin{wrapfigure}{R}{0.38\columnwidth}
\vspace{-6mm}
\begin{lstlisting}[basicstyle=\footnotesize\ttfamily]
void main(){ (*@\textcolor{mGray}{//$EF(\m{resp}{\geq}5)$}@*)
 int c = *; int resp = 0;
 int curr_serv = 5; 
 while (curr_serv > 0) { 
   if (*) {  
     c--; 
     curr_serv--;
     resp++;} 
   else if (c < curr_serv){
     curr_serv--; }}}
\end{lstlisting} 
\vspace{-2mm}
\caption{A possibly terminating loop} 
\label{fig:terminating_loop}
\vspace{-3mm}
\end{wrapfigure}


\vspace{-1mm}
\paragraph{\textbf{Limitation:}} 
\figref{fig:terminating_loop} presents a program that is possibly non-terminating if the non-deterministic choice at line 5 always chooses to be \emph{false} and the program states satisfy ``$c{\geq}\m{curr\_serv}$'' when entering the loop. 
In fact, for the terminating behaviors, the ranking function is supposed to be LLRF, i.e., $\langle \m{curr\_serv}\text{-}c, \m{curr\_serv} \rangle$. 
Besides, if the non-deterministic choice infinitely often chooses the value \emph{true}, the loop terminates with a state satisfying  ``$\m{resp}{\leq}\m{curr\_serv}$''. 
Therefore, the property $EF(\m{resp}{\geq}5)$ holds, as there indeed exists a path that finally leads to %the state where 
$\m{resp}{=}5$. 
However, \toolName fails to prove it even when the ranking function is provided, as it has limited abilities when there are non-deterministic choices for the branching, which leads to failures in programs 2 and 5. 



\hide{
To verify the property, we first obtain the following three (disjunctive) traces of the loop body, where $c^\prime$, $\m{curr\_serv}^\prime$ and $\m{resp}^\prime$ represent the variables after one iteration of the loop. Our calculus concludes the following summary: 

\begin{enumerate}
\item $[\m{curr\_serv}{>}0] \cdot (c^\prime{=}c\text{-}1) \cdot 
(\m{curr\_serv}^\prime{=}\m{curr\_serv}\text{-}1) \cdot  
(\m{resp}^\prime{=}\m{resp}\text{+}1)$
\item $[\m{curr\_serv}{>}0]  \cdot [c{<}\m{curr\_serv}]  \cdot 
(\m{curr\_serv}^\prime{=}\m{curr\_serv}\text{-}1)$
\item $[\m{curr\_serv}{>}0]  \cdot [c{\geq}\m{curr\_serv}]  \cdot 
\epsilon$ 
\end{enumerate}

\[ \effect_{5\text{-}11} \equiv ([\m{curr\_serv}{\leq}0] \cdot \epsilon) \vee  ([\m{curr\_serv}{>}0] \cdot \epsilon)^\omega \vee 
([\m{curr\_serv}{>}0] \cdot (\m{curr\_serv}{\leq}0) \cdot \m{resp}{\leq}\m{curr\_serv})
\]

And since the program assigns 5 to $\m{curr\_serv}$, the actual program takes the last two possibilities. And from the last possibility, Datalog manages to prove the property $EF(\m{resp}{\geq}5)$.  
}
%\function~ returns unknown for this example whereas \toolName~ successfully  verifies it. 

%the two phase ranking function is : $\langle \m{curr\_serv}\text{-}c, \m{curr\_serv} \rangle$






\subsection{RQ2: CTL analysis on  real-world subjects}


% Please add the following required packages to your document preamble:
% \usepackage{multirow}
\begin{table}[!b]
\vspace{-3mm}
 \caption{\label{tab:comparewithCook} 
 \vspace{-1mm}
Experimental results for catching real-world CTL bugs
%, including termination bugs and protocol liveliness bugs. 
%Since these are all bugs, the more ``{\xmark}'' in this table, the more accurate the analysis is. 
  %: Experimental results for analyses, comparing with \cite{DBLP:conf/pldi/CookK13} (Figure 7)
}
\small
\renewcommand{\arraystretch}{0.9}
\setlength{\tabcolsep}{6pt}  
%LTL(F end))
\begin{tabular}{c|l|c|cc|cc|cc}
\Xhline{1.5\arrayrulewidth}
\multicolumn{1}{l|}{\multirow{2}{*}{\textbf{}}} & \multirow{2}{*}{\textbf{Program}}        & \multirow{2}{*}{\textbf{Loc}} & \multicolumn{2}{c|}{\textbf{\ultimateshort}}   & \multicolumn{2}{c|}{\textbf{\terminator}}                   & \multicolumn{2}{c}{\textbf{\toolName}}             \\ \cline{4-9} 
\multicolumn{1}{l|}{}                           &                                          &                               & \multicolumn{1}{c|}{\textbf{Res.}} & \textbf{Time} & \multicolumn{1}{c|}{\textbf{Res.}} & \textbf{Time} & \multicolumn{1}{c|}{\textbf{Res.}} & \textbf{Time} \\ \hline
16 \xmark                                      & \multirow{2}{*}{libvncserver(c311535)}   & 25                            & \multicolumn{1}{c|}{\xmark}      & 2.845         & \multicolumn{1}{c|}{\unk}        & 0.747         & \multicolumn{1}{c|}{\xmark}      & 0.855         \\  
16 \cmark                                      &                                          & 27                            & \multicolumn{1}{c|}{\cmark}      & 3.743         & \multicolumn{1}{c|}{\cmark}      & 0.403         & \multicolumn{1}{c|}{\cmark}      & 0.476         \\ \hline
17 \xmark                                      & \multirow{2}{*}{Ffmpeg(a6cba06)}         & 40                            & \multicolumn{1}{c|}{\xmark}      & 15.254        & \multicolumn{1}{c|}{\unk}        & 1.223         & \multicolumn{1}{c|}{\xmark}      & 0.606         \\  
17 \cmark                                      &                                          & 44                            & \multicolumn{1}{c|}{\cmark}      & 40.176        & \multicolumn{1}{c|}{\unk}        & 0.96          & \multicolumn{1}{c|}{\cmark}      & 0.397         \\ \hline
18 \xmark                                      & \multirow{2}{*}{cmus(d5396e4)}           & 87                            & \multicolumn{1}{c|}{\xmark}      & 6.904         & \multicolumn{1}{c|}{\unk}        & 2.717         & \multicolumn{1}{c|}{\xmark}      & 0.579         \\  
18 \cmark                                      &                                          & 86                            & \multicolumn{1}{c|}{\cmark}      & 33.572        & \multicolumn{1}{c|}{\unk}        & 4.826         & \multicolumn{1}{c|}{\cmark}      & 0.986         \\ \hline
19 \xmark                                      & \multirow{2}{*}{e2fsprogs(caa6003)}      & 58                            & \multicolumn{1}{c|}{\xmark}      & 5.952         & \multicolumn{1}{c|}{\unk}        & 2.518         & \multicolumn{1}{c|}{\xmark}      & 0.923         \\  
19 \cmark                                      &                                          & 63                            & \multicolumn{1}{c|}{\cmark}      & 4.533        & \multicolumn{1}{c|}{\unk}        & 16.441        & \multicolumn{1}{c|}{\cmark}      & 0.842         \\ \hline
20 \xmark                                      & \multirow{2}{*}{csound-android(7a611ab)} & 43                            & \multicolumn{1}{c|}{\xmark}      & 3.654         & \multicolumn{1}{c|}{-}             & -             & \multicolumn{1}{c|}{\xmark}      & 0.782         \\  
20 \cmark                                      &                                          & 45                            & \multicolumn{1}{c|}{TO}            & -            & \multicolumn{1}{c|}{-}             & -             & \multicolumn{1}{c|}{\cmark}      & 0.648         \\ \hline
21 \xmark                                      & \multirow{2}{*}{fontconfig(fa741cd)}     & 25                            & \multicolumn{1}{c|}{\xmark}      & 3.856         & \multicolumn{1}{c|}{\unk}        & 0.499         & \multicolumn{1}{c|}{\xmark}      & 0.769         \\  
21 \cmark                                      &                                          & 25                            & \multicolumn{1}{c|}{Exception}     &    -           & \multicolumn{1}{c|}{\unk}        & 0.51          & \multicolumn{1}{c|}{\cmark}      & 0.651         \\ \hline
22 \xmark                                      & \multirow{2}{*}{asterisk(3322180)}       & 22                            & \multicolumn{1}{c|}{\unk}        & 12.687        & \multicolumn{1}{c|}{\unk}        & 0.512         & \multicolumn{1}{c|}{\xmark}      & 0.196         \\  
22 \cmark                                      &                                          & 25                            & \multicolumn{1}{c|}{\unk}        & 11.325        & \multicolumn{1}{c|}{\unk}        & 0.563         & \multicolumn{1}{c|}{\xmark}      & 0.34          \\ \hline
23 \xmark                                      & \multirow{2}{*}{dpdk(cd64eeac)}          & 45                            & \multicolumn{1}{c|}{\xmark}      & 3.712         & \multicolumn{1}{c|}{\unk}        & 0.657         & \multicolumn{1}{c|}{\xmark}      & 0.447         \\  
23 \cmark                                      &                                          & 45                            & \multicolumn{1}{c|}{\cmark}      & 2.97          & \multicolumn{1}{c|}{\unk}        & 0.693         & \multicolumn{1}{c|}{\xmark}      & 0.481         \\ \hline
24 \xmark                                      & \multirow{2}{*}{xorg-server(930b9a06)}   & 19                            & \multicolumn{1}{c|}{\xmark}      & 3.111         & \multicolumn{1}{c|}{\unk}        & 0.551         & \multicolumn{1}{c|}{\xmark}      & 0.581         \\  
24 \cmark                                      &                                          & 20                            & \multicolumn{1}{c|}{\cmark}      & 3.101        & \multicolumn{1}{c|}{\unk}        & 0.57          & \multicolumn{1}{c|}{\cmark}      & 0.409         \\ \hline
25 \xmark                                      & \multirow{2}{*}{pure-ftpd(37ad222) (\figref{fig:example:real_lefe_termination})}      & 42                            & \multicolumn{1}{c|}{\cmark}      & 2.555         & \multicolumn{1}{c|}{\unk}        & 0.452         & \multicolumn{1}{c|}{\xmark}      & 0.933         \\  
25 \cmark                                      &                                          & 49                            & \multicolumn{1}{c|}{\unk}        & 2.286         & \multicolumn{1}{c|}{\unk}        & 0.385         & \multicolumn{1}{c|}{\cmark}      & 0.383         \\ \Xhline{1.5\arrayrulewidth}
                                                 & {\bf{Total}}                                    & 786                           & \multicolumn{1}{c|}{70\%}          & >152.316       & \multicolumn{1}{c|}{5\%}           & >34.842        & \multicolumn{1}{c|}{90\%}              & 11.901        \\ \Xhline{1.5\arrayrulewidth}
\end{tabular}
\vspace{-2mm}
\end{table}



%,DBLP:conf/icse/MengDLBR22
The programs in \tabref{tab:comparewithCook} come from real-world repositories, each associated with a Git commit number where the bug is identified and fixed. Prior works \cite{DBLP:conf/sigsoft/ShiXLZCL22} gathered such examples by extracting the main segments of the bugs into smaller programs (within 100 Loc each) but maintained their features, such as data structures or pointer arithmetics, etc. 
We evaluate the analyzers with both the buggy versions, e.g., ``16\,\xmark'', and the (developer) fixed versions, e.g., ``16\,\cmark''. 

Apart from having difficulty finding the ranking functions,  \terminator also suffers from not supporting structures, as shown in program 20. In comparison, \ultimate does a better job with the accuracy but may take longer than expected. 
\toolName manages to identify all the buggy programs but fails with proving termination for some correct programs, such as 22 and 23, due to the unary increment/decrement operators in the conditions or does not take into account that some function calls' return value semantically decreases at each time, e.g., the ``read'' function. %Nevertheless, it still shows its applicability for analyzing real-world reactive programs. 



%In \tabref{tab:comparewithCook}, we do not compare with \function because it either cannot parse the given program or outputs a conservative unknown answer. 


%\syh{can case study a bit the 18 program, cmus}




\subsection{RQ3: Program repair for the failed CTL properties} 


\begin{table}[!h]
\vspace{-2mm}
  \caption{\label{tab:repair_benchmark} 
   Experimental results for repairing CTL bugs. 
   %``\textbf{Configuration}'' --- the setting for executing the program, where 
Column``\textbf{Symbols}'' presents the numbers of symbolic constants + symbolic signs, while ``\textbf{Facts}'' presents the number of facts allowed to be removed + added. 
Apart from the total repair time, we record the the time spent by the ASP solver, in the column ``\textbf{ASP Time}''. 
   %records 
   %for computing truth assignments of symbolic signs using the ASP solver.
 }
   \small
   %
   \renewcommand{\arraystretch}{1}
  \setlength{\tabcolsep}{6pt}
   \vspace{-1mm}
  \begin{tabular}{c|l|c|c|c|c|c|c}
  \Xhline{1.5\arrayrulewidth}
  \multirow{2}{*}{\textbf{}} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Program}}} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Loc(Datalog)}}} & \multicolumn{2}{c|}{\textbf{Configuration}}                                 & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{Fixed}}} & \multicolumn{1}{c|}{\multirow{2}{*}{\textbf{ASP Time}}} & \multirow{2}{*}{\textbf{Total Time}} \\ \cline{4-5}
  & \multicolumn{1}{c|}{}                                  & \multicolumn{1}{c|}{}                              & \multicolumn{1}{c|}{\textbf{Symbols}} & \multicolumn{1}{c|}{\textbf{Facts}} & \multicolumn{1}{c|}{}                                & \multicolumn{1}{c|}{}                                   &                                      \\ \hline

  1                          & AF\_terminate                                         & 101                           & 0+7                   & 2+0                & \cmark                        & 0.053                              & 1.019                                \\
  12                         & test\_until.c                                         & 72                            & 0+3                   & 1+0                & \cmark                        & 0.023                              & 0.498                                \\
  13                         & next.c                                                & 67                            & 0+4                   & 1+0                & \cmark                        & 0.023                              & 0.472                                \\
  16                         & libvncserver                                          & 97                            & 0+6                   & 1+0                & \cmark                        & 0.049                              & 1.081                                \\
  17                         & Ffmpeg                                                & 182                           & 0+12                  & 1+0                & \cmark                        & 0.11                               & 1.989                                \\
  18                         & cmus                                                  & 160                           & 0+12                  & 1+0                & \cmark                        & 0.098                              & 2.052                                \\
  19                         & e2fsprogs                                             & 144                           & 0+8                   & 1+0                & \cmark                        & 0.075                              & 1.515                                \\
  20                         & csound-android                                        & 142                           & 0+8                   & 1+0                & \cmark                        & 0.076                              & 1.613                                \\
  21                         & fontconfig                                            & 146                           & 0+11                  & 1+0                & \cmark                        & 0.098                              & 2.507                                \\
  23                         & dpdk                                                  & 175                           & 0+12                  & 1+0                & \cmark                        & 0.091                              & 2.006                                \\
  24                         & xorg-server                                           & 78                            & 0+2                   & 1+0                & \cmark                        & 0.026                              & 0.605                                \\
  25                         & pure-ftpd                                             & 216                           & 3+18                  & 2+1                & \cmark                        & 3.992                              & 11.248                                 \\
\Xhline{1.5\arrayrulewidth}
                             & Total                                                 & 1580                          &                       &                    &                                 & 4.714                             & 26.605   \\ 
\Xhline{1.5\arrayrulewidth}                           
\end{tabular}
\vspace{-1mm}
\end{table}



The programs chosen in \tabref{tab:repair_benchmark} are the \emph{true bugs} 
\footnote{As false positives are caused by the imprecision of the analysis, the generated patches are not insightful; thus, we omit them. Here, we only evaluate the repair performance when a correct patch exists.} 
identified by \toolName from \tabref{tab:comparewithFuntionT2} and \tabref{tab:comparewithCook}. Repairing bugs detected through CTL analysis has not been accomplished by any existing tools. 
To perform repairs, we adopt a strategy that gradually increases the complexity of the generated patches. 
The intuition behind this strategy is we think that a simpler patch is preferable to a more complex one if both achieve the same goal. 
Specifically, for each program, our strategy initially symbolizes facts related to control flow, such as comparison facts like \lstinline{GtEq}, without introducing any facts with symbolic constants. 
If no patch can be found under these conditions, we then introduce facts with symbolic constants. 
For modifications to facts, our approach begins by allowing the removal of at most one fact and prohibits adding facts.
This limit is gradually adjusted to not only allow the removal of one fact and the addition of another but also to increase the number of facts that can be removed or added, which enables progressively complex patch modifications.

%listed in \figref{tab:repair_benchmark}. 

We successfully repaired all the true bugs that \toolName detected. 
Most programs could be repaired with a configuration that symbolizes all facts related to control flow without any symbolic constants and by maximally removing one fact. 
The repair time for most programs was less than 2 seconds. 
The exception was the program 25, %\lstinline{pure-ftpd}, 
as it required adding a new fact, which introduces symbolic constants. 
The introduced symbolic constants within this fact increased the search space. The ASP solving time takes 
17.7\% of the total time consumption on average. 

\begin{comment}
    
It is worth noting that such a repair technique cannot be completely nor safely replaced by the existing large language models (LLMs). 
We tested ChatGPT4-0613's ability for program repair and observed that it only resolves half of the termination bugs (from programs 16-24) and performs worse in other kinds of CTL bugs. 
Moreover, there could be a data leakage as the developer's fixes are publicly available in the GitHub code base. 
ChatGPT4 takes an average of 15 seconds per bug. 

%usually accounts for less than 1/20 of the total repair time, except for ...
\end{comment}



% \newpage 
\section{Related Work}
\label{related_work}

%We discuss prior works, including temporary property analysis, termination analysis, encoding temporal properties using different kinds of Datalog semantics, and techniques for model repair. 


%-based program analysis for temporal, 

\vspace{-2mm}
\noindent\paragraph{\textbf{Program analyses for Temporal properties}} 

Most existing approaches for proving
program properties expressed in CTL have limitations upon the type of the infinite-state programs, such as pushdown systems \cite{DBLP:journals/iandc/EsparzaKS03}, parameterized
systems \cite{DBLP:conf/cav/EmersonN96}, timed systems \cite{alur1994theory}. 
Other approaches for proving CTL properties do not reliably support CTL formulas with arbitrary nesting of universal and existential path quantifiers \cite{DBLP:conf/cav/GurfinkelWC06,DBLP:conf/cav/CookKV11}, 
or support existential path quantifiers only indirectly by building upon the prior works 
for proving non-termination \cite{DBLP:conf/popl/GuptaHMRX08}, or by considering their universal dual (\terminator) \cite{DBLP:conf/fmcad/CookKP14}. In particular, the latter approach is problematic: since the universal dual of an existential ``until'' formula is non-trivial to define, \citet{DBLP:conf/sas/UrbanU018} demonstrated that the current implementation of \terminator does not support such formulas. 

\function~\cite{DBLP:conf/sas/UrbanU018} presents a CTL properties analyser via abstract interpretation. It deploys a backward analysis to propagate the weakest preconditions, which make the program satisfy the property. While being the first work to deal with a full class of CTL properties, it has several sources of the loss of precision, such as the \emph{dual widening} \cite{DBLP:conf/tacas/CourantU17} technique for proving the termination of loops. On top of that, to achieve a sound analysis, it alternatively applies the over/under approximation operators for dealing with existential/universal quantifiers, which also cause imprecision when mixed abstract domains occur. 
Notably, the experimental result of \function shows that none of the temporal analysis tools (among T2, \ultimate, and \function) subsumes the others. 
This observation highlights the collaborative power of their combination, which proves to be more potent than any of the tools used in isolation. 



Apart from the temporal property analysis with CTL, an earlier approach  \cite{DBLP:conf/popl/CookGPRV07} reduces the LTL model checking problem to fair termination checking. For the same purpose, \ultimate \cite{DBLP:conf/cav/DietschHLP15} presents a new approach exploiting the fact that constructing a proof of unsatisfiability is less costly than synthesizing ranking functions. 
Specifically, it selects finite prefixes of a path and checks their infeasibility before considering the full infinite path, verifying the liveness property with finite prefixes without the construction ranking functions. 
Compared to \cite{DBLP:conf/popl/CookGPRV07}, \ultimateshort can be seen as an improvement as it only uses fair termination checking when necessary, which avoids many (more costly) termination checks. 
Following the spirit, \toolName~ decouples the termination analysis from the CTL analysis and leverages the continuously advancing techniques upon ranking function synthesis  \cite{DBLP:conf/tacas/ColonS01,DBLP:conf/vmcai/PodelskiR04,bradley2005polyranking,DBLP:conf/concur/NeumannO020}, thus contributing to a more efficient and precise CTL analysis. 


\vspace{-1mm}
\noindent\paragraph{\textbf{Loop Summarization and Termination Analysis}}
A loop summary captures the relationship between the inputs and outputs of a loop as a set of symbolic constraints.
Loop summarization has been used widely in static analysis \cite{DBLP:conf/tacas/TsitovichSWK11,DBLP:journals/tse/XieCZLLL19}, which primarily computes the terminating program fragments, as well as dynamic test generation \cite{DBLP:conf/issta/GodefroidL11}, which discovers the loop structure of the program on the fly via detecting induction variables. However, little attention has been put on summarizing non-terminating program executions. 

On the other hand, termination is an important correctness property in itself and is a sub-problem of proving total correctness and liveness properties. Deciding on the termination of programs is probably the most famous problem in computer science. Synthesizing ranking functions for programs is a standard way to prove the termination of programs. 
Similar representations to our $\omegaRE$ have been deployed in prior works \cite{DBLP:conf/pldi/CookPR06,DBLP:conf/cav/HeizmannHP14,DBLP:conf/pldi/0001K21} to serve intermediate steps, such as computing the ranking function, in proving termination. 



Unlike the prior approach, instead of synthesizing a ranking function, we assume the ranking function is given and propagate summaries for both terminating and non-terminating behaviors, represented in $\omegaRE$.  
The direct benefit of our approach is that the CTL analysis stands alone away from the termination analysis and takes advantage of existing complete algorithms for various classes of ranking functions, such as linear, linear-lexicographic, nested, multi-phase, etc. 
In addition, it can further deploy the tools for more complicated ranking functions, such as for polynomial loops; thus, it handles more real-world programs extensively. 


%Furthermore, to ease the pain of providing the ranking functions, we also formalize a simple (but sound) procedure for inferring them when possible. 
%Note that the soundness of our approach does not reply to the precision of the provided/inferred ranking function, yet it does affect the completeness, i.e.,  there exists a patch, but we cannot find it. 
%Our approach also draws similarities to prior works \cite{DBLP:conf/pldi/0001K21,DBLP:conf/pldi/CookPR06}, we use $\omega$-regular expressions as the intermediate representation of the infinite behaviors. However, one of the differences is we summarise the behaviors for finite time trace repetitions instead of the Kleene star $\star$ commonly deployed previously. 









\vspace{-1mm}
\noindent\paragraph{\textbf{Datalog Temporal Analysis}}

To enable the expressivity for CTL properties using Datalog, prior works \cite{gottlob2002datalog,gottlob2000linear}
present Datalog LITE, a new deductive query language. Datalog LITE is a variant of Datalog that uses stratified negation, restricted variable occurrences, and a limited form of universal quantification in rule bodies. 
We borrow their encoding of the AF operator, 
%(cf. \figref{fig:AF_encoding}), 
which requires the finiteness of the input Kripke structure. 
This encoding also follows from the facts that, over finite structures, CTL can be embedded into transitive closure logic \cite{DBLP:conf/cav/ImmermanV97} and that transitive closure logic has the same expressive power as stratified linear Datalog programs \cite{DBLP:journals/tcs/ConsensM93,DBLP:conf/csl/Gradel91}. 
In parallel with the above mentioned works, \cite{DBLP:journals/tcs/GuessarianFAA03}
provides a direct and modular translation from CTL and the Modal $\mu$-calculus to Monadic inf-Datalog, with built-in predicates. Inf-Datalog has slightly different semantics from the conventional Datalog least fixed point semantics in that some recursive rules (corresponding to least fixed points) are allowed to unfold only finitely many times, whereas others (corresponding to greatest fixed points) are allowed to unfold infinitely many times. 



%a domain-specific
%language that makes it possible to write a range of SMT-based static analyses in a way that is both close to
%their formal specifications and amenable to high-level optimizations and efficient evaluation.
%Analyzers based on Datalog also gained popularity recently; for example, prior work \cite{DBLP:journals/pacmpl/Bembenek0C20} proposes Formulog, which extends the logic programming language Datalog with a first-order functional language and mechanisms for representing and reasoning about SMT formulas; a novel type system supports the construction of expressive formulas while ensuring that neither normal evaluation nor SMT solving goes wrong. Their 
%case studies demonstrate that a range of SMT-based analyses can naturally and concisely be encoded in Formulog, and high-level Datalog-style optimizations can be automatically and advantageously applied to these analyses. 


%Datalog-Defined Program Repair and 
%Prior work \cite{DBLP:conf/sigsoft/LiuMSR23} proposes to integrate program repair with Datalog-based analysis, which enables a general-purpose static program repair framework that targets a wide range of properties and programming languages. 
%It repairs the program by modifying the corresponding Datalog facts via a symbolic execution of Datalog. It is useful for properties that only involve the least fixpoints, such as null pointer exceptions or data leaks, without supporting the properties that involve a combination of the least and greatest fixed points, such as CTL. Our repair strategy in this work supports repairs guided by CTL properties by supporting the negations that can arbitrarily occur in the rules.   


\vspace{-1mm}
\noindent\paragraph{\textbf{Model Repair}}




\citet{DBLP:conf/ecai/DingZ06} proposed a CTL model update algorithm based on four primitive operations and a minimal change criterion by using Kripke structure models; the algorithm obtains a new model as similar as possible to the original one. 
\citet{DBLP:journals/ai/CarrilloR14} introduced the concept of protection for dealing with the loss of satisfiability problem of a property while introducing changes in the new model. 
%\citet{DBLP:conf/nfm/ChatzieleftheriouBSK12} use an abstract model repair framework, under a 3-valued semantics of CTL. 
\citet{martinez2015ctl} present a CTL model repair solution for bounded and deadlock-free Petri nets. 
This approach repairs the model guided by CTL specifications via two basic repair operations: adding/removing transitions and enabling/disabling variables. Both these operations can be reflected in our approach via adding/deleting transition facts and facts for atomic propositions for program variables. 
However, it requires a re-analysis after the ``repaired'' model is generated, which means that produced patches are not always safe; 
in contrast, our approach produces patches without any re-analysis, if any. 

%such a model repair could produce patches that still fail the target specification, which is called ``inconsistency''; 

%The difference is that our repair does not modify the model's skeleton, i.e., the transition flows are dependent on constraints of program variables, as they are encoded as rules instead of facts. 


Prior work, \cite{DBLP:conf/memocode/AttieCBSS15} maps an instance of the repair program, i.e., a Kripke structure model and a CTL property to a Boolean formula, and the satisfiability resulted from the SAT solver indicates a patch exist or not. When satisfiable, the returned model will be mapped back to a patch solution to remove transitions/states, 
without any addition of transitions/states, to avoid introducing new behaviors. 
This approach is also deployed for repairing model in the concurrent programs context~\cite{DBLP:conf/fossacs/AttieC23}.  
In \cite{DBLP:journals/ai/BuccafurriEGL99} the repair problem for CTL is considered and solved using adductive reasoning. The method generates repair suggestions that must then be
verified by model checking, one at a time. In contrast, we fix all faults at
once. 
Program Repair as a Game~\cite{DBLP:conf/cav/JobstmannGB05}, 
considers only one repair at a time, and their method is complete only for invariants. 
In 
\cite{DBLP:conf/charme/StaberJB05} , the approach of \cite{DBLP:conf/cav/JobstmannGB05} is extended so that multiple faults are considered at once, and 
it assumes that the specification is given in linear-time
temporal logic and state the localization and correction problem as a game that
is won if there is a correction that is valid for all possible inputs. 
To cope with more realistic systems, 
our approach differs from the above-mentioned model repair in a way that model repair targets models -- either Kripke structure or Petri nets. In contrast, our approach targets 
%(possibly infinite state) 
real-world programs, which may involve different language features, especially loops. 
To the best of the authors' knowledge, this is the first work to provide the CTL repair solution at the source code level. We prove its usefulness using real-world benchmarks, which no prior work has achieved. 
%Instead of enforcing invariant annotations, we provide a way to compute summaries of loops based on an iterative process of refining the ranking functions. Thus, t
%Moreover, while this paper focuses on supporting Datalog repair with negations, we leave the repair for Datalog rules as a future work. 

\vspace{-1mm}
\section{Conclusion}
\label{sec:conclusion}


%This work is motivated by ``\emph{how to analyze and repair real-world temporal bugs which can be encoded using a standard temporal logic like CTL?}''. 
%We presented a method for repairing non-deterministic programs so that they satisfy a CTL formula \code{\phi}, by extracting guarded $\omegaRE$ formulas from the source code, and the repair is to adjust the transitions some that the the ``cause'' violation of \code{\phi} is avoided. 
Our main contribution is showing the feasibility of 
finding and repairing real-world bugs, using CTL specifications.
Specifically, given a program, its control/data flow can be extracted and represented in the Datalog program. Program repair is then achieved by a surgery of the Datalog facts. 
Our technical contribution includes support for repairing both safety and liveness properties. Repairs guided by liveness properties often require reasoning about non-termination, and we take extra care to require very limited manual annotations. 
We prototype the proposal, present experimental results, 
and demonstrate nontrivial case studies to show its utility. Instead of generating counterexamples and then fixing them one by one, \toolName provides a combined find-and-fix framework for violations of properties expressed in temporal logics.


%Our method is sound, and is complete relative to our transition deletion strategy. 
%Unlike other methods, ours both fixes all counterexamples at once, and is complete for CTL properties, specifically full CTL. We extended our method in various directions, to allow addition of states and transitions, to solve discrete event supervisory control, 
%We also provided experimental results from our implementation.


\vspace{-1mm}
\section*{Data-Availability Statement}
The software that supports~\toolName~
is available on Zenodo~\cite{zenodo_benchmark}.


\bibliography{bibliography}

% oopsla 2024 requires the appendix to be kept separate
% \iftechreport




\end{document}
\endinput
%%
%% End of file `sample-acmsmall-submission.tex'.
