\documentclass[journal,twoside,web]{ieeecolor}
%\usepackage[utf8]{inputenc}


\usepackage{cite}
\usepackage{lcsys}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{float}

\usepackage{xcolor}
\usepackage{optidef}
%\usepackage{amsthm}
\usepackage{makecell}
\usepackage{tikz}
\usetikzlibrary{shapes,arrows,positioning}
\usepackage{tikzpeople}
\usepackage{svg}
\tikzstyle{block} = [draw, rectangle, minimum height=2em, minimum width=3em]
\tikzstyle{virtual} = [coordinate]
%\usepackage[figurename=Figure]{caption}

%\def\fnum@figure{Fig.~\thefigure}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
    
%\newcommand{\HS}{\color{cyan}}
    
\newtheorem{prop}{Proposition}
\newtheorem{thm}{Theorem}
\newtheorem{cor}{Corollary}
\newtheorem{lem}{Lemma}
\newtheorem{prob}{Problem}
\newtheorem{defi}{Definition}
\newtheorem{rem}{Remark}
\newtheorem{asm}{Assumption}
\newtheorem{exam}{Example}
\DeclareMathOperator{\Ima}{Im}
\DeclareMathOperator{\Ker}{Ker}
\DeclareMathOperator{\enc}{Enc}
\DeclareMathOperator{\dec}{Dec}
\DeclareMathOperator{\vecc}{Vec}
\DeclareMathOperator{\spn}{span}


% \thinmuskip=0.3mu
% \medmuskip=0.3mu
% \thickmuskip=0.5mu

\markboth{\journalname, VOL. XX, NO. XX, XXXX 2023}{Alisic \MakeLowercase{\textit{et al.}}: Anomaly Detection With Encrypted Control}

\pagestyle{empty} % Removes all the page numbers (except for the title page)


\begin{document}

\title{Anomaly Detection with Encrypted Control}
\author{Rijad Alisic \IEEEmembership{Student Member, IEEE}, Junsoo Kim, \IEEEmembership{Member, IEEE}, \\ and Henrik Sandberg, \IEEEmembership{Fellow, IEEE}
\thanks{This research was funded in part by the Swedish Foundation for Strategic Research through the CLAS project (RIT17-0046), by the Seoul National University of Science and Technology, by the Swedish Research Council (2016-00861), and by the Swedish Civil Contingencies Agency (CERCES2).}
\thanks{R.~Alisic and H.~Sandberg are with the Division of Decision and Control Systems at KTH Royal Institute of Technology, Sweden {\tt \small (e-mail: rijada@kth.se, hsan@kth.se)}.}
\thanks{J.~Kim is with the Department of Electrical and Information Engineering, Seoul National University of Science and Technology, Korea {\tt \small (e-mail: junsookim@seoultech.ac.kr)}.}
}


\maketitle
\thispagestyle{empty} % Removes the page number in the first page

\begin{abstract}
    Detecting attacks in encrypted signals is challenging since encryption hides information contained in the signals. We present a novel approach to anomaly detection over encrypted signals without using decryption, a secure channel, or multiple rounds of communication. Instead, the anomaly detector exploits properties of homomorphic encryption to perform hypothesis tests on linear combinations of the encrypted samples. The specific linear combinations are determined by approximately solving a vector reduction problem, where the sensitivity of the tests deteriorates with longer vectors. By prioritizing only using recent samples, we can give better guarantees to the approximate solution. However, this structure also involves a trade-off, where statistical power can be improved at the cost of incorporating older data into the test, which may negatively affect the detection time. Given a choice of the trade-off, we provide tests that trigger an alarm for a given false alarm probability. Finally, we conclude the paper with a simulation of anomaly detection on a real system to demonstrate the effectiveness of our method in detecting attacks.
\end{abstract}

\begin{IEEEkeywords}
Fault detection, Control over communications, Quantized systems
\end{IEEEkeywords}

\vspace{-10pt}
\section{Introduction} \label{sec:introduction}
The study of undetectable false-data injection attacks in the literature commonly relies on a parametric model of the targeted plant~\cite{smith2015,Pasqualetti2013}. If the attacker does not know a model \emph{a~priori}, then it can learn one through disclosure attacks on a cyber component~\cite{muller2018,park2016}, which connects the plant to a computational element that is used to control the plant, thus creating a cyber-physical system (CPS). Additionally, due to the advancements in data-driven methods for control~\cite{Coulson2019,proctor2016}, recent works show that attackers do not need explicit models to generate undetectable attacks. Rather, they can compute such attacks directly from a plant's input-output data, which is a topic that is relatively unexplored, see~\cite{alisic2021ecc,wang2019,adachi2023}. Finally, many undetectable attacks require the system to be in a particular state~\cite{teixeira15}, which forces the attacker to rely on input-output data to also estimate the state. 

Clearly, limiting the information an attacker can extract from the data limits its attack capabilities. One of two common methods is to target the attacker's estimator by injecting noise into the data being transmitted over the cyber component~\cite{sandberg2015}. However, introducing noise into the CPS opens up for \emph{stealthy} attacks, which are detectable attacks that do not raise an alarm because of the detector's false alarm rate setting~\cite{giraldo2018}. Encryption is another commonly used tool to limit the information an attacker could extract from a signal~\cite{kim2022dynamic}. Traditional encryption methods, such as Advanced Encryption Standardization (AES), are not compatible with computational resources in the cyber component because the data needs to be decrypted while being processed. The same limitation appears for message authentication as well. Thus, traditional methods only protect data during transmission, which leaves computational resources vulnerable to attackers that could collude with or directly hack them to extract information.

Homomorphic encryption (HE) allows computations to be performed directly on encrypted data, with the results then carrying over after decryption. Thanks to this property, HE can also protect the data during computation. Several forms of HE exist, one of which is the Paillier cryptosystem which is capable of performing addition and multiplication on encrypted messages~\cite{paillier1999}. In this paper, we consider a cryptosystem based on the Learning with Errors (LWE) problem~\cite{regev2009}, which is claimed to be \emph{post-quantum secure}. Unlike traditional cryptosystems that are based on \emph{worst-case hard} problems, which are efficiently solved by quantum computers, the LWE problem is a lattice problem that is believed to be \emph{average-case hard}, at least when doing \emph{randomized reductions}~\cite{ajtai1996}.

\begin{figure}
    {\begin{tikzpicture}[pin distance=1cm,>=stealth,auto, node distance=1cm,rotate=90]

\node [virtual] (model) {};

\node [block] (system) {Plant $G$};

\node[virtual, above = 41pt of model](ysplit){};
\node[block, right = 15pt of ysplit] (enc) {Enc};

\node (devi) [right=54pt of model,scale=0.1] {\includesvg{anon-hacker-behind-pc.svg}};

\node[block,right = 4pt of devi](operator){Controller};

\node[virtual, below = 30pt of system](usplit2){};
\node[block, right = 15pt of usplit2] (dec) {Dec};

\node[virtual, right = 23pt of dec](attu){};
\node[virtual, right = 23pt of enc](atty){};
\node[circle, draw, inner sep=0.02cm ,right = 20pt of operator](diff){$+$};
\node[block, right = 10pt of diff](anom){\makecell{Anomaly\\ Detector}};

\node[circle, draw, inner sep=0.02cm ,right = 10pt of dec](adddow){$+$};
\node[virtual, right = 43pt of adddow](usplit){};

\node[circle, draw, inner sep=0.02cm ,right = 26pt of enc](addup){$+$};

\node[virtual, right = 27pt of addup](upp){};

\node[block, below = 10pt of anom, draw opacity=0](anomout){$\{\text{True, False}\}$};

\draw [->] (anom.south) -- (anomout.north);

\draw[->](ysplit) -- (enc);
\draw[->](enc) -- (addup);

\draw[->] (addup.east) |- node[yshift=-8pt, xshift=-44pt] {$y^e_k+y^a_k$} (diff.north);
\draw[->] (operator.east) -- node[yshift=-20pt] {$-\hat{y}^e_k$} (diff.west);
\draw[->] (diff.east) -- (anom.west);

\draw [-] (system) -- node[yshift=-2pt, xshift=15pt] {$\bar y_k$} (ysplit);
\draw [->] (upp) -- node{} (operator.north);
\draw [-] (operator) -- node {} (usplit);
\draw[->] (usplit) -- (adddow.east);
\draw[->] (adddow) -- (dec.east);
\draw[-] (dec) |- (usplit2);
\draw [->] (usplit2) --  node[yshift=-2pt, xshift=15pt] {$\bar u_k$} (system);
\draw [dashed, <-] (addup) -- node {$y_k^a$} ([yshift = -2ex] devi.north);
\draw [dashed, <-] ([yshift = -2ex]devi.south) -- node[yshift=3pt] {$u_k^e$} ([yshift = -2ex] attu);

\draw [dashed, <-] ([yshift = 1.5ex]devi.north) -- node[yshift=-4pt] {$y_k^e$} ([yshift = 1.5ex] atty);
\draw [dashed, <-] (adddow) -- node {$u_k^a$} ([yshift = 1.5ex] devi.south);
\end{tikzpicture}}
\vspace{-5pt}
     \caption{An attacker injects signals $y^a_k$ and $u^a_k$ into the loop, which can be made stealthy by observing $y^e_k$ and $u^e_k$ unless they are encrypted. We propose an anomaly detector that uses the difference between the observed {$y^e_k+y_k^a$} and $\hat{y}^e_k$ to detect attacks through the encryption.}
    \label{fig:adv_attack__vector} 
    \vspace{-15pt}
\end{figure}

Previously, HE was believed to limit the capabilities of anomaly detection, similar to how noise injection opens up opportunities for stealthy attacks. An attacker could ignore detectability since the encryption hides the attack from detection unless the detector can establish multiple rounds of secure communication with the plant, or has access to the secret keys~\cite{alexandru2022,alisic2023modelfreelwe}. However, in this paper, we present a novel approach to anomaly detection over encrypted signals that does not these elements. Rather, we rely on the homomorphic property to allow us to combine the encrypted messages so that their dependence on the secret key is removed, which enables detection. By prioritizing using recent samples, which is desirable for anomaly detection, we obtain a structure in a lattice problem that leads to potential improvements in the Lenstra-Lenstra-Lov\'asz (LLL) algorithm~\cite{lenstra1982} which approximately solves lattice problems.

%structure, therefore, removes the importance of finding the shortest vectors in the entire lattice (an \emph{average-case hard} problem), to a sufficiently short vector in a sub-lattice of a fixed size.

The outline of the paper is as follows. In Section~\ref{sec:problem}, we set up a linear, time-invariant system that models the physical plant and how attacks affect it. We also give a brief overview of the LWE-based cryptosystem, and finally, we set up a dynamic controller that is compatible with the encryption. We conclude the section by stating the main problem an anomaly detector has to solve to detect an attack. Our main results are shown in Section~\ref{sec:results}, which is that there are several hypothesis tests that could reveal an attack. Which test to choose is treated in Section~\ref{sec:vectors}, where a trade-off between noise amplification and old data has to be considered. We show a numerical example of detecting attacks in a real system in Section~\ref{sec:numerical} before finally concluding our paper and discussing extensions in Section~\ref{sec:conclusions}.

\textit{Notation:} Denote the ring over the integers modulo $q$ by  $$  \mathbb{Z}_q:= \left\{i\in\mathbb{Z}: -\frac{q}{2} \le i < \frac{q}{2}\right\}.$$ 
The rounding operator is denoted by $\lfloor \cdot \rceil$ and the floor operator by $\lfloor \cdot \rfloor$. We can define the modulo operation by  $$  a\mod q := a - \left\lfloor\frac{a+\frac{q}{2}}{q}\right\rfloor q, $$ so that the modulo maps integer $a\in \mathbb{Z}$ onto $\mathbb{Z}_q$. The space of $(n \times m)$-dimensional matrices where each element is in $\mathbb{Z}_q$ is denoted by $\mathbb{Z}_q^{n\times m}$, and similarly for vectors, $\mathbb{Z}_q^{n} = \mathbb{Z}_q^{n\times 1}$.

% $n$-dimensional vectors where each element is in $\mathbb{Z}_q$ is denoted by $ \mathbb{Z}_q^n$, and similarly for $(n \times m)$-dimensional matrices by $\mathbb{Z}_q^{n\times m}$. %Let $\Ker V$ for matrix $V \in \mathbb{Z}_q^{n\times m}$ denote $$ \Ker V:= \left\{v \in\mathbb{Z}_q^m: Vv \mod q= 0\right\}.$$ This set can be computed using the Hermite Normal Form~\cite{kannan1979}. %The sequence of a signal $m_k\in \mathbb{Z}^n$, for $k=\{j, j+1, \dots l\}$, is a stacked vector $m_{j:l} = [m_j^\top, \dots, m_l^\top ]^\top$.

%Finally, for a vector $v \in \mathbb{Z}^n$ with elements $v_i$, we let $\Vert v \Vert_\infty=\max \limits_{i} \vert v_i \vert$, and for the matrix $V\in \mathbb{Z}_q^{n\times m}$ with elements $V_{ij}$, we let $\Vert V \Vert_\infty = \max \limits_i \sum \limits_j \vert V_{ij} \vert$.

\section{Problem setup} \label{sec:problem}

% \subsection{The Cyber-Physical System under Attack}
Consider Fig.~\ref{fig:adv_attack__vector}, which models the plant $G$,
\begin{equation} \label{eq:system}
    G: \begin{cases}
    \begin{aligned}
    x_{k+1} & =  Ax_k + B (u_k+u^a_k) + w_k \\
     y_k & =   Cx_k + D(u_k+u^a_k) +v_k + y^a_k,
    \end{aligned}
    \end{cases}
\end{equation}
as a discrete-time system where $x_k \in\mathbb{R}^n$ is the state, $u_k\in\mathbb{R}^m$ is the input, $y_k\in\mathbb{R}^p$ is the output, and $\{A,B,C,D\}$ are matrices of appropriate size with elements in $\mathbb{R}$. The process noise $w_k\in \mathbb{R}^n$ and the measurement noise $v_k\in \mathbb{R}^p$ are assumed to be zero-mean, i.i.d, normally distributed random variables with $\mathbb{E} [ w_k w_k^\top]=\Sigma_w$ and $\mathbb{E} [ v_k v_k^\top]=\Sigma_v$, respectively. %The output sequence of~\eqref{eq:system}, when applying input sequence $u_{0:L-1}$, is denoted as $y_{0:L-1}$. 

We assume that an attacker can additively inject signals $u^a_k$ and $y^a_k$ into the actuators and sensors, respectively. The attacker can also read the signals $y^e_k$ and $u^e_k$. However, due to the encryption, we pose the following assumption which stops the attacker from specifically designing stealthy attacks.
\begin{asm}
    The attacker does not know the dynamics~\eqref{eq:system} and cannot use $y^e_k$ and $u^e_k$ to calculate stealthy attacks.
\end{asm}

% However, due to the encryption we introduce in the next section, the attacker will not be able to make use of the messages being sent between controller and plant.

Because LWE-based encryption usually works on integers, we have to represent inputs and outputs as integers as well. We do this by rescaling and rounding:
\begin{equation}\label{eq:signal_rescaling}
    \bar y_k = \lceil c y_k \rfloor, \quad u_k = \frac{1}{c} \bar u_k,
\end{equation}
where the desired level of accuracy determined by $c >0$.

% Before the output is sent to the encryption block, it is rescaled and averaged to an integer based on a desired level of accuracy determined by $c\in \mathbb{Z}_+$, because the LWE-based encryption only works on an integer representation of the signals. The measurements, $y_k$ are rescaled to integers through the following operation:
% \begin{equation}\label{eq:signal_rescaling}
%     \bar y_k = \lceil c y_k \rfloor,
% \end{equation}
% and the inputs are downscaled to the plant specified size as
% \begin{equation*}
%     u_k = \frac{1}{c} \bar u_k.
% \end{equation*}


\subsection{LWE-based Encryption}

We consider encryption based on the LWE framework~\cite{regev2009}, which, in addition to the encrypted message $m^e$, discloses a matrix $P$ that has been used in the encryption. The encryption function can be written as $\enc_\lambda(m)=(m^e, P)$, where $m$ is the \emph{plaintext} message and $\lambda$ is a set of parameters that define the \emph{security level}, see Definition~\ref{def:lwe}.

The term \emph{homomorphic} refers to the property that operations on the encrypted signals carry over to the decrypted signals. To stabilize LTI systems, a controller typically needs to addition and multiplication with scalars. Therefore, we consider encryption with the following property,
\begin{multline}\label{eq:decrypt}
    \dec_\lambda(b_1\enc_\lambda(m_1)+b_2\enc_\lambda(m_2)) = b_1m_1+b_2m_2,
\end{multline}
for $b_1, b_2 \in \mathbb{Z}_q$. Encryption based on LWE is defined as:
\begin{defi}\label{def:lwe}
The output signals $\bar y_k$ are encrypted using the following $\lambda=(v,r,\sigma^2,q)$-level encryption scheme,
\begin{equation*}\label{eq:lweencmsg}
    \enc_\lambda (\bar y_k) = (y_k^e, \, P_k^y) = (P_k^ys+ r \bar y_k+e_k \mod q, \, P_k^y),
\end{equation*}
where the elements of $P_k^y \in \mathbb{Z}_q^{p \times v}$ and $s\in \mathbb{Z}_q^v$ are sampled uniformly from the set $\mathbb{Z}_q$. The $i$th element of the error vector, $e_k \in \mathbb{Z}_q^p$, is sampled from the discrete normal distribution, $e_k(i) \sim \mathcal{N}_d(0,\sigma^2)$, $\forall i$. The rounding number $r$ creates separation between the plaintext signal $y_k$ and the error $e_k$.
\end{defi}

The same secret key $s$ is used for all messages, which is necessary for the homomorphic property in the LWE-based scheme. Decryption uses the secret key to reveal
the message.
\begin{defi}
The input signals to the physical system are decrypted using the following scheme.
\begin{equation}\label{eq:lwedecmsg}
   \bar u_k = \dec_\lambda(u_k^e, \, P_k^u) =\left \lfloor \frac{u_k^e-P_k^us \mod q}{r} \right \rceil .
\end{equation}
\end{defi}

One can verify that the homomorphic property holds using $$a \enc_\lambda(m_1)+b \enc_\lambda(m_2)= (am^e_1+bm^e_2,aP_1+bP_2),$$ and that subsequent decryption, which gives~\eqref{eq:decrypt}. Although, the homomorphic property allows the controller to work on encrypted signals, it also allows the attacker to inject $u^a_k$ and $y^a_k$ into the respective data streams.
%It is due to this property that the controller is able to work on encrypted signals. However, it is also the reason why an attacker is able to inject signals $u^a_k$ and $y^a_k$ into respective data streams.
The noise $e_k$ limits the number of operations that can be performed. In particular, the variance $\sigma^2$ and the rounding number $r$ are chosen so that $e_k$ disappears after rounding in~\eqref{eq:lwedecmsg}. The next lemma shows that the noise increases for every operation, which may alter the message after decryption. But first, we assume the following.

\begin{asm}\label{asm:small_messages}
    No overflow occurs when operating on the messages $m_1$ and $m_2$. More specifically, $\sum_k|rm_k+e_k| < \frac{q}{2}$ and $\bar c|rm_k+e_k| < \frac{q}{2}$, for $k \in \{1,\, 2\}$ and some $ \bar c \in \mathbb{Z}_+$.
\end{asm}

Assumption~\ref{asm:small_messages} is required for the following lemma to hold.

\begin{lem}\label{lem:linear_operations}
Consider the two messages $m_1$ and $m_2$ in Assumption~\ref{asm:small_messages}. Since $m_k^e \sim \mathcal{N}_d(P_ks + rm_k \mod q,\sigma_k^2)$, for $k \in \{1,\, 2\}$, then, for $\bar P=P_1+P_2 \mod q$, we have that:
\begin{equation*}
    m_1^e + m_2^e \sim  \mathcal{N}_d\left(\bar P s + r(m_1+m_2) \mod q,\sigma_1^2+\sigma_2^2\right),
\end{equation*}
and for some $c \in \mathbb{Z}$, where $|c| \leq \bar c$,
\begin{equation*}
    cm_k^e \sim \mathcal{N}_d(cP_ks + crm_k \mod q, c^2\sigma_k^2).
\end{equation*}
\end{lem}

Thus, addition increases the variance linearly and multiplication increases it quadratically. The system designer would need to choose $r$ and $\sigma^2$ that are compatible with the desired controller, as we will see in the next section.

\subsection{The Dynamic Controller}

The specific controller we consider in this paper does not impact our main result. Any controller that is compatible with the LWE-based encryption could be used with some minor modifications. Now, consider the real controller:
\begin{equation}\label{eq:controller_real}
    \begin{cases}
    \begin{aligned}
    x^c_{k+1} & =  A_cx^c_k + B_c \bar y_k, \\
     u_k & =   C_cx^c_k + D_c \bar y_k. 
    \end{aligned}
    \end{cases}
\end{equation}
Such a controller can be obtained, for instance, by combining an optimal feedback law with a Kalman filter. We also assume:
\begin{asm}\label{asm:controller_estimates_output}
    The output of the plant may be estimated from the controller states and input, $\hat{y}_k = C_ox_k^c+D_ou_k.$
\end{asm}

Assumption~\ref{asm:controller_estimates_output} does not limit the controller, since more states can always be added to~\eqref{eq:controller_real} while choosing extended matrices $A_c$ and $C_c$ in a way that does not affect the control signal $u_k$.

Implementing the controller under the LWE-based encryption scheme needs to be done carefully since the noise in the dynamical state grows quickly for every iteration. A typical solution is to reset the noise, and there are multiple ways to do so~\cite{murguia2020}. We will simply set the state to $0$ periodically.
\begin{equation}\label{eq:reset}
    x^c_k = 0, \, \text{when } k - \left\lfloor k/k_p\right\rfloor k_p = 0,
\end{equation}
where $k_p$ is the period of the reset. To motivate this particular reset, we make the following assumption:
\begin{asm}
    The steady state of~\eqref{eq:system} under~\eqref{eq:controller_real} is $x_{ss}=0$.
\end{asm}

Extensions to a non-zero steady state can be done by subtracting a bias term from the reset value in~\eqref{eq:reset}. This bias could be sent from the plant as an encrypted message.

The controller parameters need to be integers to work under LWE-based encryption. We adopt a similar approach to~\eqref{eq:signal_rescaling}, by rescaling and rounding the matrices using a factor $c$. However, choosing a small $c$ may cause instability:
\begin{asm}
    We choose $c \in \mathbb{Z}_+$ to be large enough so that the closed loop system is stable.% and the controller signals fulfill $|c^{k_p-1}x^c_k|<q/2$ and $|c^{k_p-1}u_k|<q/2$, $\forall k$.
\end{asm}

The rescaling also propagates into the controller state, implying that we need to dynamically rescale the measurements $\bar y_k$ as well. However, due to the reset~\eqref{eq:reset}, we need to reset the rescaling periodically, $c^{\bar k}\bar y_k$, where $\bar k = k - \left\lfloor k/k_p\right\rfloor k_p$.

The final element we need in our controller is to map the encrypted message onto $\mathbb{Z}_q$. The full controller becomes:
\begin{equation}\label{eq:integer_controller}
    \begin{cases}
    \begin{aligned}
    c^{\bar k+1}x^c_{k+1} & =  \lceil c A_c \rfloor c^{\bar k} x^c_k + \lceil cB_c \rfloor c^{\bar k} y^e_k \mod q, \\
     c^{\bar k} u^e_k & =   \lceil c C_c \rfloor c^{\bar k} x^c_k + \lceil c D_c \rfloor c^{\bar k} y^e_k \mod q, \\
     c^{\bar k} \hat{y}^e_k & = \lceil c \bar C_o \rfloor c^{\bar k} x_k^c+\lceil c \bar D_o \rfloor c^{\bar k} y_k^e \mod q, \\
     x^c_k & = 0, \, \text{when } k - \left\lfloor k/k_p\right\rfloor k_p = 0.
    \end{aligned}
    \end{cases}
\end{equation}
We do the same operations on the corresponding public matrices $P_k^x, \, P_k^u, \, P_k^y$. The matrices $\bar C_o = ( C_o +D_o C_c)$ and $\bar D_o = D_oD_c$ are precomputed to reduce noise growth.%, and that the encrypted output $y^e_k$ is scaled to match the scaling of the signals in the dynamic controller.

\begin{rem}
    The presence of the scaling factors $c^{\bar k}$ in the encrypted control messages, $c^{\bar k}u^e_k$, implies that the plant has to downscale the message with the corresponding factor. Therefore, some type of time-step coordination between the plant and the controller might be needed. Additionally, for convenience, we chose to rescale the controller parameters with the same factor $c$ as for the signals in~\eqref{eq:signal_rescaling}. In general, the controller and signals could be rescaled with different factors.
\end{rem}

\subsection{Problem Formulation}

In conventional anomaly detection setups, such as in~\cite{Umsonst2022}, the anomaly detector carries its own internal observer for reconstructing the output. We have chosen a more integrated approach through Assumption~\ref{asm:controller_estimates_output}. The reason is two-fold:
\begin{enumerate}
    \item Reduce noise amplification: In the conventional setup, the calculated control signal $u^e_k$ would have to be run through \emph{another} estimator, which would both further amplify the noise and add another layer of dynamical states that may need to reset more often.
    \item Separate \emph{detection} from \emph{estimation}: We can focus the discussion of this paper on how to \emph{detect} that the measured encrypted output $y^e_k$ deviates from the expected encrypted output $\hat{y}^e_k$, no matter how we obtain $\hat y_k^e$.
\end{enumerate}

The estimated output $\hat y^e_k$ will always be scaled with $c^{\bar k}$. Since division is not an operation that is allowed on the encrypted signals, the anomaly detector's only choice is to also scale the encrypted output $y_k^e$. The anomaly detector looks at the following encrypted residual,
 \vspace{-4pt} \begin{equation}\label{eq:encrypted_residual} \vspace{-3pt}
    (\rho_k^e, P_k^\rho) = (c^{\bar k}(\tilde y^e_k-\hat{y}_k^e), c^{\bar k} (P_k^y-P_k^{\hat y})) \mod q.
\end{equation}
where $\tilde y_k^e =  y^e_k+y^a_k$, to try to detect an attack, which is the main problem of this paper. %Since the encryption blocks the attacker from reading signals, we assume that the attacker can only perform detectable attacks
% \begin{asm}
%     The attacker can only perform attacks where $\dec_\lambda(\rho_k^e, P_k^\rho) \neq 0$.
% \end{asm}
% Detecting such attacks are the main problem of this paper.
\begin{prob}\label{prob:main}
    Consider the following two hypothesis:
    %Consider an anomaly detector which computes and stores residual signals~\eqref{eq:encrypted_residual}. How can it perform the following hypothesis test:
    \begin{itemize}
        \item $\mathcal{H}_0:$ $\dec_\lambda(\rho_k^e, P_k^\rho)=0$, $\forall k$,
        \item $\mathcal{H}_1:$ $\dec_\lambda(\rho_k^e, P_k^\rho)\neq 0$, $\forall k$.
    \end{itemize}
    %without the secret key $s$? {\color{red} is this too vague? Should I add with \textit{with some bounds on false alarm rate}?}
    Without using the secret key $s$, how can $\mathcal{H}_0$ be rejected in favor of $\mathcal{H}_1$ with a specific probability $\beta$ on the Type I error?
\end{prob}

In plain detection terminology, Problem~\ref{prob:main} asks how to detect anomalies in encrypted signals with a set false alarm rate.
\begin{rem}
There is a subtle difference between Problem~\ref{prob:main} and the LWE problem which is believed to be hard. In essence, the decision version of the LWE problem is solved if one can \emph{reject $\mathcal{H}_1$ in favor of $\mathcal{H}_0$}, which is a much harder problem. If $\mathcal{H}_1$ could be rejected, then the secret key would be recoverable by modifying the encrypted messages and looping through possible keys, element by element, see Lemma 4.2 in~\cite{regev2009}.
\end{rem}

% distinguish whether the elements in~\eqref{eq:lweencmsg} come from the ``LWE distribution" or a uniform distribution. Instead of asking what the distribution is, by making the plaintext residual $\rho_k$ zero when there is no anomaly, rejecting $\mathcal{H}_0$ in favor of $\mathcal{H}_1$ becomes a question about what the \emph{mean} of the distribution is, regardless of if it is ``LWE" or uniform.

% There is a subtle difference between Problem~\ref{prob:main} and the classical problem of estimating \emph{individual} messages for which LWE-based encryption has been designed to protect against. Problem~\ref{prob:main} asks if we can reject the hypothesis that the \emph{ensemble} of sampled messages is zero without knowing the secret key $s$. Since we construct the plaintext residual $\rho_k$ to be zero when there is no anomaly, rejecting $\mathcal{H}_0$ in favor of $\mathcal{H}_1$ becomes our method of detection. Therefore, in plain anomaly detection terminology, Problem~\ref{prob:main} asks how we can detect anomalies without decrypting the signals and with a set false alarm rate.
\vspace{-7pt} \section{Main Results} \vspace{-3pt} \label{sec:results}
To solve Problem~\ref{prob:main}, we look to~\cite{alisic2023modelfreelwe} for inspiration. Particularly, consider the encrypted messages,
\vspace{-5pt} \begin{equation*} \vspace{-5pt}
    Enc_\lambda(\rho_k) = (P_k^\rho s+r\rho_k+e_k^\rho,P_k^\rho).
\end{equation*}
The first element in the encryption tuple contains three terms, one of which is the plaintext message $\rho_k$. We will start by ``filtering out" the part that depends on the secret key, $P_k^\rho s$.

Due to the homomorphic property, we can do the following.
\vspace{-7pt} \begin{equation*} \vspace{-5pt}
    \sum \limits_{k} \rho^e_k\xi_k \text{ mod } q = \sum \limits_k P_k^\rho s \xi_k + \sum \limits_k (\rho _kr+e_k^\rho)\xi_k \text{ mod } q,
\end{equation*}
for $\xi_k\in \mathbb{Z}_q$. Since the anomaly detector also has access to the public matrices, $P^\rho_k$, they can find weights $\xi_k$ so that
\vspace{-4pt} \begin{equation*} \vspace{-7pt}
    \sum \limits_k P_k^\rho \xi_k \mod q = 0.
\end{equation*}
Finding such a \emph{filtering vector} $g=\begin{bmatrix} \xi_1 & \dots & \xi_N \end{bmatrix}^\top$ can be done by computing the Hermite Normal Form (HNF)~\cite{kannan1979} which is an integer version of Gaussian elimination. There will typically be $N-v$ such vectors when $N$ is large. % {(it is related to the probability of coprimality occurring in $v$ sets each containing $\lceil N/v\rfloor$ uniformly drawn integers, which increases quickly with $N$)}.
Multiplying $g$ with $\rho^e= \begin{bmatrix}\left(\rho_1^e\right )^\top & \dots & \left(\rho_N^e \right)^\top \end{bmatrix}^\top$ modulo $q$, gives,
\vspace{-5pt} \begin{equation} \vspace{-5pt}\label{eq:filtered_ensemble}
    \begin{aligned}
     & g^\top \rho^e \mod q  = \sum \limits_k (\rho _kr+e_k^\rho)\xi_k \mod q \\
    & = r g^\top \rho + g^\top e^\rho \mod q = r g^\top \rho + g^\top e^\rho,
    \end{aligned}
\end{equation}
where the last equality follows from Assumption~\ref{asm:small_messages}.  
% The decryption operator in~\eqref{eq:decrypt} relies on $|e_k/r|<1/2$ so that it disappears when rounding occurs. However, t
The noise term in~\eqref{eq:filtered_ensemble}, $g^\top e^\rho$, could be much larger than $r/2$ which would alter the message if we decrypt it. It is primarily there to obscure the combined plaintext message, $r g^\top \rho$. Thanks to Assumption~\ref{asm:small_messages}, we can state the following proposition.
\begin{prop} \label{prop:error_dist}
The error vector $e^\rho$ from the residuals is a zero-mean discrete Gaussian, $e^\rho \sim \mathcal{N}_d(0,\Sigma_\rho)$, for some covariance matrix $\Sigma_\rho$.
\end{prop}
\begin{proof}
    The result follows from Assumption~\ref{asm:small_messages}, Lemma~\ref{lem:linear_operations}, and the fact that we have only considered linear operations in the first three rows of~\eqref{eq:integer_controller} and~\eqref{eq:encrypted_residual}. The state reset in~\eqref{eq:integer_controller} implies that $\Sigma_\rho$ will have a repeated block-diagonal structure.
\end{proof}

The exact expression of $\Sigma_\rho$ has been omitted for brevity but is easily recoverable by considering the linear operations in~\eqref{eq:integer_controller} on $c^{\bar k}\hat y^e_k$ and the addition of the noise from $c^{\bar k} \tilde y_k^e$. %can be found in Appendix~\ref{} {\color{red} (will be too long for this paper? need to remove some things)}. Proposition~\ref{prop:error_dist} leads us immediately to the following result,
\begin{cor}~\label{cor:distribution_residual_weighted}
    The message in~\eqref{eq:filtered_ensemble} is normally distributed:
    \vspace{-5pt} \begin{equation}\label{eq:normal}
        g^\top\rho^e \mod q \sim \mathcal{N}_d(rg^\top \rho, g^\top \Sigma_p g).
    \end{equation}
\end{cor}

Corollary~\ref{cor:distribution_residual_weighted} shows us how to perform the hypothesis test we posed in Problem~\ref{prob:main}:
\begin{thm}\label{thm:main_theorem_rejection_rule}
    Rejecting $\mathcal{H}_0$ when $|g^\top \rho^e \mod q| \geq \alpha$, where $\alpha$ is the $\beta$-quantile of $\mathcal{N}_d(0,g^\top \Sigma_p g)$,
    \vspace{-5pt} \begin{equation} \vspace{-5pt} \label{eq:false_alarm_triggering_rule}
    \text{Pr}(|X|\geq \alpha)=\beta, \quad \text{for } X \sim \mathcal{N}_d(0,g^\top \Sigma_p g),
    \end{equation}
    produces a Type I error with probability $\beta$.
    %{\color{red} (actually it is sufficient to look at percentiles of the continuous normal dist., which will shorten paper)}
    % \begin{equation} \label{eq:false_alarm_triggering_rule}
    %     \text{Pr}(|X|\geq \alpha) = \frac{\sum \limits_ {X=-\infty}^{-\alpha} \mathrm{e}^{-\frac{X^2}{2g^\top \Sigma_p g}}+\sum \limits_ {X=\alpha}^{\infty} \mathrm{e}^{-\frac{X^2}{2g^\top \Sigma_p g}}}{\sum \limits_ {X=-\infty}^{\infty} \mathrm{e}^{-\frac{X^2}{2g^\top \Sigma_p g}}}  = \beta.
    % \end{equation}
\end{thm}

\begin{proof}
Recall that the Type I error is defined as $\text{Pr} (\text{Reject } \mathcal{H}_0 | \mathcal{H}_0 \text{ is true})=\beta$, thus we have to construct a rejection mechanism with this property. Hypothesis $\mathcal{H}_0$ implies that $g^\top \rho=0$, which according to Corollary~\ref{cor:distribution_residual_weighted}, implies that,
    \vspace{-5pt} \begin{equation*} \vspace{-5pt}
        g^\top\rho^e \mod q \sim \mathcal{N}_d(0, g^\top \Sigma_p g).
    \end{equation*}
    % The probability density of a random variable $X\sim \mathcal{N}_d(0,\sigma^2)$ is 
    % \begin{equation}\label{eq:prob_expression_zero_mean}
    %     \text{Pr}(X)=\frac{\mathrm{e}^{-\frac{X^2}{2\sigma^2}}}{\sum \limits_{k=-\infty}^\infty \mathrm{e}^{-\frac{k^2}{2\sigma^2}}}.
    % \end{equation}
    Consider the random variable $X\sim \mathcal{N}_d(0, g^\top \Sigma_p g)$ and the sets $\mathcal{S}_i$, for which $\text{Pr}(X\subset \mathcal{S}_i)=\beta$. Multiple such sets may exist, but we choose to use the set $\mathcal{S}_0=\{X: X<-\alpha, \text{ or }  X > \alpha\}$, for some $\alpha\in \mathbb{Z}_q$. Thus we have that $\text{Pr}(|X|\geq \alpha)=\beta$. Since $g^\top\rho^e \mod q$ has the same distribution as $X$ under $\mathcal{H}_0$, we have that $\text{Pr}\left (\left. |g^\top\rho^e \mod q|\geq \alpha \right \vert \mathcal{H}_0 \text{ is true} \right )=\beta$.
    % Since $g^\top\rho^e \mod q$ has mean zero, and since Problem~\ref{prob:main} is a two-sided test for which there does not exist a uniformly most power test~\cite,
    % which we only sample
    % A sufficient statistic for estimating the mean from a single sample is $\bar X = X$~\cite. Recall that the Type I error is defined as $\text{Pr} (\text{Reject } \mathcal{H}_0 | \mathcal{H}_0 \text{ is true})=\beta$, which we can construct from the estimate by finding a threshold, $\alpha$, for which the estimated zero-mean valued will exceed with probability $\beta$, $\beta = \text{Pr}( |\bar X| \geq \alpha) = \text{Pr}( |X| \geq \alpha)$. Calculating this expression using~\eqref{eq:prob_expression_zero_mean} and substituting $\sigma^2$ with $g^\top \Sigma_p g$ gives us the the expression in~\eqref{eq:false_alarm_triggering_rule}.
\end{proof}
\begin{rem}
    Several rejection rules that solve Problem~\ref{prob:main} appear in the proof of Theorem~\ref{thm:main_theorem_rejection_rule}, quantified by the number of sets $\mathcal{S}_i$ we can choose from. The one we suggest in Theorem~\ref{thm:main_theorem_rejection_rule} is the \emph{uniformly most powerful unbiased} $\beta$-level test~\cite{Lehmann2005}.
\end{rem}

Theorem~\ref{thm:main_theorem_rejection_rule} gives a rule for performing a hypothesis test, once some vector $g$ has been found. Finding multiple such vectors is relatively simple, they come out as a by-product of converting the stacked public matrix $\mathcal{P}=\begin{bmatrix}
    (\text{Vec}(P^\rho_1))^\top & \dots & (\text{Vec}(P^\rho_N))^\top
\end{bmatrix}^\top$ to its HNF $H_{\mathcal{P}^\top}$. What makes the hypothesis test difficult to carry out is what filtering vectors $g$ we can obtain. The filtering vectors scale the error variance $g^\top \Sigma_\rho g$ quadratically, but the sum $g^\top \rho$ only linearly. Therefore, if $\mathcal{H}_1$ is true and $\Vert g \Vert_2$ is large, then $g^\top \rho$ would also need to be large to trigger an alarm. Making $g^\top \rho$ large is difficult since we do not know $\rho$. One approach is to recognize the temporal nature of $\rho$, namely that only recently sampled residuals will be non-zero just after an attack starts. So, $\rho_k=0$ for $k=\{1, \, \dots, \, N-l\}$, and $\rho_k\neq 0$ for $k=\{N-l+1, \, \dots, \, N\}$, for some $l \ll N$. Therefore, we want the filtering vector $g$ to have the following two properties:
\begin{enumerate}
    \item Structured: The first elements in $g$ should be 0 so that only recent samples are used for detection.
    \item Short: The norm $\Vert g\Vert_2$ should be small to reduce noise.
\end{enumerate}
We will show that these two properties oppose each other and that a trade-off between them has to be considered.

\begin{rem}
    The large scaling of the variance is precisely what stops the detector from solving the LWE problem. If $e^\rho=0$ and $\rho=0$, the detector would be able to guess secret keys and use $g^\top \rho^e \mod q=0$ to verify the correct guesses. The detection rule in Theorem~\ref{thm:main_theorem_rejection_rule} does not conclude that $g^\top \rho^e \mod q \approx g^\top \rho=0$, rather it asks when $g^\top \rho^e \mod q$ it is sufficiently large to conclude that $g^\top \rho \neq 0$.
\end{rem}

\vspace{-5pt}
\section{Structured and Short Filtering Vectors} \label{sec:vectors}
Consider a set of $N-v$ filtering vectors $g_i\in \mathbb{Z}_q^N$, $i \in \{1, \, \dots, \,  N-v\}$ obtained from the HNF of $\mathcal{P}^\top$, which we collect in matrix $G = \begin{bmatrix}
         g_1 & \dots &  g_{N-v}
    \end{bmatrix}$. Specifically,
\begin{equation} \label{eq:HNF}
 \mathcal{P}^\top \begin{bmatrix}
        U & G
    \end{bmatrix} = \begin{bmatrix}
        \mathcal{P}^\top U & \mathcal{P}^\top G
    \end{bmatrix} = \begin{bmatrix}
        H_{\mathcal{P}^\top} & 0_{v \times (N-v)}
    \end{bmatrix},
\end{equation}
    where the HNF of $\mathcal{P}^\top$, $H_{\mathcal{P}^\top} \in \mathbb{Z}_z^{v \times v}$, is a full rank lower triangular matrix and $\begin{bmatrix}
        U & G
    \end{bmatrix}$ is an unimodular matrix. Typically, the vectors in $G$ will be quite large and dense, thus they will not have any of the two desired properties that were stated at the end of Section~\ref{sec:results}. However, thanks to the following result, we can consider integer combinations of them.
    \begin{prop}\label{prop:combinations_allowed}
        Consider the filtering vectors $g_i$ to $\mathcal{P}$, namely $g_i^\top P \mod q = 0$, for $i\in\{1, \, 2\}$. Then for any $c_i\in \mathbb{Z}$,
        \vspace{-10pt} \begin{equation*}
            (c_1g_1 +c_2g_2)^\top\mathcal{P} \mod q = 0.
        \end{equation*}
    \end{prop}
    \begin{proof}
        The proof is obtained by direct computation:
        \vspace{-4pt} \begin{equation*}
        \begin{aligned}
            & (c_1g_1 +c_2g_2)^\top\mathcal{P} \mod q \\ 
             & = (c_1g_1^\top\mathcal{P} \mod q) +(c_2g_2^\top\mathcal{P} \mod q )=  0.
            \end{aligned} \vspace{-14pt}
        \end{equation*} 
    \end{proof}
We can thus generate more filtering vectors by performing linear transformations of the column vectors in $G$ followed by the modulus operation, thanks to Proposition~\ref{prop:combinations_allowed}.

\vspace{-10pt}
\subsection{Sparsifying the Filtering Vectors}
\begin{figure}
    \hspace{-5pt} \vspace{-5pt}
    \includegraphics[scale=0.55]{tall_hnf_v2.eps}
    \caption{Each blue dot represent a non-zero element in the Hermite Normal Form of a tall $(20 \times 15)$ matrix. Note the column vectors are sorted by how many initial elements are zero. \vspace{-15pt}}
    \label{fig:HNF_G}
\end{figure}

To ensure that we use recent samples for detecting anomalies, we seek a transformation of $G$ that gives column vectors that are zero in the first elements. Recall that $H_{\mathcal{P}^\top}=\mathcal{P}^\top U$ in~\eqref{eq:HNF} is lower triangular, which means that the HNF can provide the desired transformation. Since $G$ is a tall matrix its HNF, denoted by $H_G$, will not be lower triangular. The last $v$ rows in the HNF of a tall matrix are dense, as depicted in Fig.~\ref{fig:HNF_G}, however, $H_G$ is still sorted based on the number of initial elements that are zero. Thus, we can still use the HNF to obtain the desired transformation.

Thus, the $l$:th column vector in $H_G=\begin{bmatrix}
    h^1 & \dots & h^{N-v}
\end{bmatrix}$ is zero in its first $l-1$ elements, $h^l_k=0$, for $k\in  \{1, \, \dots, \, l-1\}$. Therefore, using $h^l$ indexed by large $l$ as filtering vectors will only use recent samples in the detection. However, the column vectors of $H_G$ will still be large. Therefore, we also need to employ a vector reduction algorithm.

\vspace{-5pt}
\subsection{Shortening the Filtering Vectors}
Since only integer combinations of the filtering vectors are allowed, we can treat the columns of $H_G$ as basis vectors for a lattice $\mathcal{L}_G$. Finding the shortest basis of a lattice is a classical problem that has been considered since the 1700s. Lagrange devised an algorithm that was able to solve the problem in 2D. However, there is no known algorithm that is able to solve it for higher dimensions, except for exhaustive search which scales exponentially in the dimension.

The LLL-algorithm is a sub-optimal algorithm that can find short vectors in high dimensional lattices in polynomial time, and it has Lagrange´s algorithm as a special case when applied to two-dimensional lattices. However, in higher dimensions, it can only guarantee to find vectors that are exponentially close to the shortest vector. Let $\text{LLL}(H_G)$ denote the output of the LLL-algorithm applied to matrix $H_G$, then,
\vspace{-5pt} \begin{equation} \vspace{-5pt} \label{eq:first_basis_length}
    \min_{g \in \text{LLL}(H_G)} \Vert g \Vert_2 \leq \frac{1}{\left (\delta-\frac{1}{4}\right )^{\frac{N-v}{2}}} \min_{g \in \mathcal{L}_G} \Vert g \Vert_2, %\lambda (\mathcal{L}).
\end{equation}
where the Lov\'ascz number $\delta$ is $\frac{1}{4}<\delta < 1$. We show next that iteratively applying the LLL-algorithm to an evolving lattice, $\mathcal{L}_{G^k} \subset \mathcal{L}_{G^{k+1}}$, gives a slightly smaller upper bound.



Consider the following matrix, $H_{G^2}=\begin{bmatrix}
        h^{N-v} & h^{N-v-1} 
    \end{bmatrix}$, which is composed of the last two vectors in $H_G$. The column vectors in $H_{G^2}$ form a basis for lattice $\mathcal{L}_{G^2}$. Now, generate the following matrix recursively,
    \vspace{-4pt} \begin{equation} \vspace{-4pt} \label{eq:dynamic_evolve_lattice}
        H_{G^{k+1}}= \begin{bmatrix}
             \text{LLL}(H_{G^{k}}) & h^{N-v-k}
        \end{bmatrix},
    \end{equation}
    for $k\in \{3, \, \dots, \, N-v-1 \}$. The column vectors in $H_{G^{k+1}}$ form a basis for lattice $\mathcal{L}_{G^{k+1}}$, and note that the final basis in the sequence spans our original lattice, $\mathcal{L}_{G^{N-v}}=\mathcal{L}_{G}$.
\begin{prop}\label{prop:length_reduction_reduces_structure}
    Consider the lattice generated by~\eqref{eq:dynamic_evolve_lattice}, then
    \vspace{-5pt} \begin{equation}\label{eq:min_lll_dyn}
    \begin{aligned}
        & \min_{g \in \text{LLL}({H_{G^{k+1}}})} \Vert g \Vert_2 \\ 
        & \leq \min \left(\min_{g \in \text{LLL}({H_{G^{k}}})} \Vert g \Vert_2 , \, \frac{1}{\left (\delta-\frac{1}{4}\right )^{\frac{k+1}{2}}} \min_{g \in \mathcal{L}_{G^{k+1}}} \Vert g \Vert_2 \right).
    \end{aligned}
    \end{equation}
\end{prop}
\begin{proof}
    Let us start with $H_{G^2}$, where $\text{LLL}(H_{G^2})$ is guaranteed to give us a basis where one of the vectors is the shortest vector in $\mathcal{L}_ {G^2}$ since it is a two-dimensional lattice and the LLL-algorithm collapses to Lagrange's algorithm. Then, $\text{LLL}(H_{G^3})$ can output a basis with either of these properties:
    \begin{enumerate}
        \item If no shorter vector is found, then the shortest vector from the previous iteration is kept as a basis vector, whose length is given by $\min_{g \in \text{LLL}({H_{G^{2}}})} \Vert g \Vert_2$.
        \item If a shorter vector is found, then its length will also be shorter than the upper bound given by~\eqref{eq:first_basis_length}.
    \end{enumerate}
By invoking this argument recursively, we obtain~\eqref{eq:min_lll_dyn}.
\end{proof}
Now, let $f_k=\arg \min_{g \in \text{LLL}({H_{G^{k}}})} \Vert g \Vert_2$, which is the shortest filtering vector the LLL-algorithm found with the first ${N-v-k}$ elements set to zero. Proposition~\ref{prop:length_reduction_reduces_structure} tells us we will find a sequence of filtering vectors where $\Vert f_{k+1} \Vert_2 \leq \Vert f_k \Vert_2$ by using~\eqref{eq:dynamic_evolve_lattice}. The price we pay is that we incorporate older samples in the detection, thus losing the structure we desire.

% which in turn implies that we have to incorporate older samples in the detection.

% Note that Theorem~\ref{thm:main_theorem_rejection_rule} only holds when the detector uses a \emph{single} filtering vector $f_k$. However, if the detector were to use all of the filtering vectors and set thresholds according to Theorem~\ref{thm:main_theorem_rejection_rule}, then the false alarm probability would be larger.
% \begin{prop}
%     Consider the filtering vectors $f_k$ and their corresponding threshold values according to Theorem~\ref{thm:main_theorem_rejection_rule}, $\alpha_k$, all calculated for the same false alarm probability $\beta$. Then
%     \vspace{-5pt} \begin{equation*}
%         \text{Pr}\left(\bigcup \limits_{k \in \mathcal{K}} |f_k^\top \rho^e| \geq \alpha_k \right) \geq \beta, \text{ for some } \mathcal{K} \subseteq \{1, \dots, N-v\}.
%     \end{equation*}
% \end{prop}
% \begin{proof}
% Let $X_k$ be the set of $\rho^e$ for which $\vert f^\top_k \rho^e \vert \geq \alpha_k$. Since $X_l \subseteq \bigcup \limits_{k \in \mathcal{K}} X_k$, for some $l\in \mathcal{K}$, the proof follows from,
%     \vspace{-8pt} \begin{equation*}
%         \text{Pr}\left(\bigcup \limits_{k \in \mathcal{K}} X_k \right) \geq \text{Pr}\left (X_l\right) = \beta. \vspace{-25pt}
%     \end{equation*} 
% \end{proof}

\section{Numerical results} \label{sec:numerical}

\begin{figure}
    \centering \hspace{-10pt} \vspace{-5pt}
    \includegraphics[scale=0.44,trim={40pt 3pt 0 0},clip]{filtering_vect_detect_v2.eps}
    \caption{The combined residuals for different filtering vectors are shown for a system under attack (black) and without attack (red). The region where no alarm is raised is shown in grey and has to be lower than $q/2$ (yellow) to enable detection without violating Assumption~\ref{asm:small_messages}.} \vspace{-15pt}
    \label{fig:detection_trigger}
\end{figure}

Consider the dynamical system~\eqref{eq:system}, where
\vspace{-4pt} \begin{equation*} \vspace{-4pt}
\begin{aligned}
    A & =\begin{bmatrix}
     -0.09473 &  -0.5513  & -0.2280 \\
      -0.5513 &  -0.3504  & 0.3036\\
       -0.2280  &  0.3036  & -0.5411
    \end{bmatrix}, \, B = \begin{bmatrix}
            0 \\
     -0.3175 \\
      -1.102
    \end{bmatrix}, \\
     C & = \begin{bmatrix}
        -0.7793 &  -1.762 & 0
    \end{bmatrix}, \, D = 1.527, \, \Sigma_w  =I, \, \Sigma_v=1.
\end{aligned}
\end{equation*}
We also assume that the controller implements a discrete Linear Quadratic Gaussian Regulator that solves
\vspace{-4pt} \begin{mini*} 
{A_c, B_c, C_c, D_c}{\sum_{k=1}^\infty x^\top_kx_k +u_k^2,}{}{}
\addConstraint{\text{}\eqref{eq:system} \text{ and } \eqref{eq:controller_real}. \vspace{-20pt}}
\end{mini*} \vspace{-15pt}

The encryption parameters are $\lambda=(10,3,1,2^{19})$, the scaling factor is set to $c=r=3$, reset occurs every $k_p=4$ time steps and the false alarm probability is set to $\beta = 0.003$. We assume that there is an attacker who injects a constant attack signal into the actuator, $u^a_k=5$, for $k>30$. The detector has $N=70$ samples that it can use for detection.  %The non-encrypted residual signal for $N=150$ the attack on the system with the approximated controller in~\eqref{eq:integer_controller} is shown in Fig.~\ref{fig:residuals}. One may see easily see the impact of the attack on the residual, and an anomaly detector that uses a simple threshold rule would be able to detect such an attack.


% \begin{figure}
%     \includegraphics[scale=0.42,trim={50pt 3pt 0 0},clip]{outputs.eps}
%     \caption{Caption}
%     \label{fig:residuals}
% \end{figure}



Consider Fig.~\ref{fig:detection_trigger}, where $f_k^\top \rho^e$ is shown as a function of increasing $k$, together with the corresponding thresholds $\alpha_k$ from the triggering rule. First, one may see that the attack is successfully detected for some $f_k$, which verifies our main result, Theorem~\ref{thm:main_theorem_rejection_rule}. However, far from all $f_k$ triggers an alarm. Most notably, the threshold $|\alpha_k|>q/2$ when $k<30$, which is larger than $|f_k^\top \rho^e \mod q|<q/2$. Fig.~\ref{fig:detection_trigger} indicates that these filtering vectors can not be used for detection even though they are sparse because $f_k^\top \rho$ violates Assumption~\ref{asm:small_messages}.

% which occurs due to long filtering vectors $\Vert f_k \Vert_2$. However, these vectors have the desired sparsity structure, which means that $f^\top_k \rho^e$ only contains the most recent $\rho^e_k$.


Note that even though $\Vert f_k \Vert_2$ decreases monotonically with $k$ as shown in Fig.~\ref{fig:length_structure_tradeoff}, which verifies Proposition~\ref{prop:length_reduction_reduces_structure}, the threshold in Fig.~\ref{fig:detection_trigger} might increase a bit. This increase happens because the noise variance increases over the reset window, where samples with index $k-\lceil k/k_p \rfloor k_p=0$ have the smallest variance and $k-\lceil k/k_p \rfloor k_p=k_p-1$ have the largest variance. Fig.~\ref{fig:length_structure_tradeoff} also shows how sparsity is reduced for every shorter vector that is found by~\eqref{eq:dynamic_evolve_lattice} and quantifies the trade-off between structure and length associated by picking a $f_k$.

% , which indicates shorter vectors - which is also verified in Fig.~\ref{fig:length_structure_tradeoff}. Note that a decreasing threshold may also occur due to a change in which signals in the reset window is being used. Since the reset occurs every $k_p=4$ time steps, every sample at time steps $k \mod k_p = 0$ will have a variance of $\sigma^2=1$ due to the encryption variance, since the internal state of the controller is known to be set to $0$. However, every subsequent sample will have a larger variance due to the amplification in the controller. Therefore, filtering vectors $f_k$ that have elements which are large every $k \mod k_p = 0$ index will lead to a smaller threshold, compared to other vectors of the same length, but with large elements every $k \mod k_p = k_p-1$ index.



Finally, Fig.~\ref{fig:roc} shows the receiver operating characteristic curve for three filtering vectors, including using $f_{30}$ on non-encrypted signals for comparison. The simulation was performed for 240 trials per $\beta$. Hypothesis tests using $f_{30}$ are the least sensitive for most $\beta$, which might be surprising since most samples of $\rho_k$ that $f_{30}$ selects correspond to $\rho_k\neq 0$. The other two filtering vectors, $f_{40}$ and $f_{50}$, mostly outperform $f_{30}$ even though they include more residuals that are zero. The gain in statistical power occurs because they are much shorter than $f_{30}$, and thus amplify the noise less. Finally, note that $f_{40}$ outperforms $f_{50}$ for most $\beta$, which is because $f_{50}$ is not sufficiently shorter than $f_{40}$ to compensate for the extra zero residuals it includes in the hypothesis test. Thus, filtering vector $f_{40}$ seems to provide the most powerful test out of the three to detect attacks within 30 time steps.


\begin{figure}
    \hspace{-15pt} \vspace{-7pt}
    \includegraphics[scale=0.55,trim={0pt 3pt 0 0},clip]{filtering_vect_lengthv2.eps}
    \caption{As more initial elements in the filtering vectors are allowed to be non-zero (blue dots), which represents including older samples of the residual into the detection, shorter $f_k$ can be found (red curve). \vspace{-15pt} }
    \label{fig:length_structure_tradeoff}
\end{figure}

% The test that performs significantly worse than the non-encrypted test is $f_{30}$, which may be surprising since it is the only test that only includes non-zero residuals. Thus, Fig.~\ref{fig:roc} shows that reducing the length of filtering vectors significantly improves the test compared to losing sparsity, which is not surprising due to how the variance scales.
\vspace{-10pt}
\section{Conclusions}\label{sec:conclusions}
This paper has considered anomaly detection over LWE-based encrypted signals, without using the secret key or secure communication channels. Enabling detection over encrypted channels increases the applicability of encryption, since using our proposed method, both privacy and security can be enhanced. We posed the detection problem as a hypothesis test, where an alarm is raised if the null hypothesis is rejected and the power of the test is determined by (approximately) solving a vector reduction problem. The dynamical system which generates the signals imposes structural properties which we exploit to improve the sensitivity of the detector.

We have explored one trade-off, namely between the statistical power at the expense of including old data. There are additional trade-offs that will be considered in future work, for instance, how the frequency of the state reset in~\eqref{eq:reset} affects the performance, or comparing different controller implementations. Another line of future work is to also prioritize less noisy samples of the residual when performing vector reduction. Additional improvements to the statistical power could be made by using multiple filtering vectors simultaneously. Finally, another direction of future research would be to consider transformations of the encrypted residual that could improve detectability or reduce the detection time. 
%For instance, passing the encrypted residual through an integrator would approximate a cumulative-sum type detector which is often employed for quickest change detectors, however additionally noise reset methods would need to be considered.

\bibliographystyle{ieeetr}
\vspace{-10pt}
\bibliography{bibliography}

\begin{figure}
    \hspace{-15pt}
    \includegraphics[scale=0.48]{tests_v2.eps} \vspace{-20pt}
    \caption{Numerical comparison of the detection sensitivity when using three different filtering vectors for different $\beta$, in addition to using $f_{30}$ on plaintext samples. In this setup, $f_{40}$ shows the best sensitivity on encrypted samples. \vspace{-15pt}}
    \label{fig:roc}
\end{figure}

\end{document}
