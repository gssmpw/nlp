\section{Overview}

\subsection{System Overview}
%We advocate that distributed systems must be fast and trustworthy  in the Byzantine heterogeneous cloud infrastructure. %We further show that while TEEs could help in this direction, they cannot meet the requirements of such systems in terms of variations in performance, programmability overheads and complicated security analysis.

We propose \projecttitle{}, a trusted NIC architecture for high-performance, trustworthy distributed systems, formally guaranteeing their secure and correct execution in the heterogeneous Byzantine cloud infrastructure. 
% To this end, we propose \projecttitle{}, a trusted NIC architecture that offers a network abstraction for high-performance, trustworthy distributed systems under BFT that meets the performance requirements of modern systems while it formally guarantees their secure and correct execution in the heterogeneous (Byzantine) cloud infrastructure. 
\projecttitle{} is comprised of three layers (shown in Figure~\ref{fig:overview}): {\bf (1)  the \projecttitle{} hardware architecture} (green box) that implements trusted network operations on top of SmartNIC devices ($\S$~\ref{sec:t-nic-hardware}), \rev{(a)}{{\bf (2) the \projecttitle{} network stack}} (yellow box) that intermediates between the application layer and the \projecttitle{} hardware ($\S$~\ref{sec:t-nic-network}), and \rev{(a)}{{\bf (3)  the \projecttitle{} network library}} (blue box) that exposes \projecttitle{}'s programming APIs ($\S$~\ref{sec:t-nic-software}). 

Our \projecttitle{} hardware architecture implements the networking IB/RDMA protocol~\cite{rdma_specification} on FPGA-based SmartNICs~\cite{u280_smartnics}. 
It extends the conventional protocol implementation with a minimal hardware module, the attestation kernel, that materializes the security properties of the non-equivocation and transferable authentication. The \projecttitle{} network stack configures the \projecttitle{} device on the control path while it offers the data path as kernel-bypass device access for low-latency operations. Lastly, the  \projecttitle{} network library exposes \rev{(a)}{programming APIs} built on top of (reliable) one-sided RDMA primitives. 
% Our \projecttitle{} hardware architecture implements and extends the networking IB/RDMA protocol~\cite{rdma_specification} on top of the FPGA-based SmartNICs, Alveo U280~\cite{u280_smartnics}. Critically, it extends the conventional protocol implementation with a minimal hardware security module, the attestation kernel, that materializes the security properties of the non-equivocation and the transferable authentication. The \projecttitle{} trusted network stack runs in user space. It configures the \projecttitle{} device (MAC address, IP, etc.) on the control path, while the data path is offered as kernel-bypass device access for low-latency operations. Lastly, The  \projecttitle{} trusted network library exposes a {\em trusted} API that is built on top of one-sided RDMA (reliable) operations. 


%\section{Design}
%\dimitra{
%\begin{itemize}
%    \item Intro
%    \item Background + Motivation
%    \item Overview (including sys/data model etc.)
%    \item Design + Implementation (TNIC: hw architecture, TNIC libraries: sw abstraction, Applications: use-cases)
%\end{itemize}
%}

%\subsection{System Model}

%\myparagraph{Model sketch}
%We model the distributed system as a set of {\tt N} nodes each of which is attached to a single \projecttitle{} instance that is loaded into an FPGA-based SmartNIC as Alveo U280~\cite{u280_smartnics}. The nodes communicate by exchanging messages through bi-directional network links that connect their FPGAs. The system is managed and owned by the third-party cloud infrastructure which is untrusted.


\subsection{Threat Model} 

%\antonis{It is a bit weird we have Fault model in section 2 and Thread model in section 3}

We inherit the fault and threat model from the classical BFT~\cite{Castro:2002} and trusted computing domains~\cite{intel-sgx}. The cloud infrastructure (machines, network, etc.) can exhibit Byzantine behavior and also being subject to attackers that can control over the host CPU (e.g., the OS, VMM, etc.) and the SmartNICs (post-manufacturing). The adversary can attempt to re-program the SmartNIC, but they cannot compromise the cryptographic primitives~\cite{levin2009trinc, minBFT, Castro:2002}. The physical package, supply chain, and manufacturer of the SmartNICs are trusted~\cite{10.1145/3503222.3507733, 10.1145/2168836.2168866}. The \projecttitle{} implementation (bitstream) is synthesized by a trusted IP vendor with a trusted tool flow for covert channels resilience. %(in a trusted environment) The system designers source the \projecttitle{} from trusted IP vendors.

\rev{(a), B3, B4, C2}{
Since \projecttitle{} does not rely on CPU-based TEEs and its network stack and library run on the unprotected CPU, both software can be compromised by a potentially Byzantine actor on the machine. As such, \projecttitle{} does not distinguish between different types of untrusted software components. Whether the network library, the network stack, or the application code is compromised, the node is considered faulty (Byzantine) and must conform to the BFT application system model, which should specify its tolerance to Byzantine failures.
}

%We do not consider denial-of-service (DoS) attacks; the cloud provider has physical control of the hardware and can simply unpower it. Nevertheless such attacks affect availability and not the correctness.

\if 0
\begin{figure}[t!]
    \centering
    \includegraphics[width=.45\textwidth]{figures/trusted-nic-attestation_kernel.drawio.pdf}
    \caption{\trustedfpga{} attestation kernel overview (transmission path).}
    \label{fig:attestation_kernel}
\end{figure}    
\fi

\begin{figure}[t!]
    \centering
    %\includegraphics[width=0.5\textwidth]{figures/trusted-nic-overview.drawio.pdf}
    % \includegraphics[width=0.45\textwidth]{figures/trusted-nic-system_overview.drawio.pdf}
    \includegraphics[width=0.7\linewidth]{figures/tnic_system_overview_atsushi.pdf}
    \caption{\projecttitle{} system overview.}
    \label{fig:overview}
\end{figure}

\subsection{Design Challenges and Key Ideas} \label{subsec:challenges} While designing \projecttitle{}, we overcome the following challenges:

\myparagraph{\#1: Heterogeneous hardware} 
CPU-based TEEs in the cloud infrastructure are heterogeneous with different programmability~\cite{Baumann2014, scone, 10.1145/3079856.3080208, 10.1145/3460120.3485341, tsai2017graphene, Rkt-io} and security properties~\cite{10.1145/3600160.3600169, 7807249, 10.1007/978-3-031-16092-9_7} that complicate their adoption and the system's correctness~\cite{10.1145/3460120.3485341}. 
% For example, Intel SGX~\cite{cryptoeprint:2016:086} offers code confidentiality and attestation while ARM TrustZone~\cite{arm-realm} does not. Likewise, AMD-sev~\cite{amd-sev} and Intel TDX~\cite{intelTDX} offer OS-based programming interfaces, whereas Keystone~\cite{riscv-multizone} and SGX require specific SDKs~\cite{KeystoneSDK}.
Prior systems~\cite{hybster, 10.1145/3492321.3519568, minBFT, DBLP:journals/corr/LiuLKA16a} {\em could} not address this heterogeneity challenge as they require {\em homogeneous} {\tt x86} machines with SGX extensions of a specific version. This is rather unrealistic in modern heterogeneous distributed systems where system designers are compelled to {\em stitch heterogeneous TEEs together}. TEE's heterogeneity in programmability and security semantics hampers their adoption and adds complexity to ensuring the system's overall correctness. 
% An alternative approach is to {\em stitch heterogeneous TEEs together}, however, it imposes two significant challenges. First, TEEs'  {programmability differences limit} their adoption as a widely accepted general approach for trustworthy systems. Second, TEE's security semantics heterogeneity complicates the correctness of the derived systems; designers must carefully consider their security guarantees.
% , placing a heavy burden on system designers.

% The host CPU-side TEEs in the cloud infrastructure are heterogeneous with different programmability~\cite{Baumann2014, scone, 10.1145/3079856.3080208, 10.1145/3460120.3485341, tsai2017graphene, Rkt-io} and security properties~\cite{10.1145/3600160.3600169, 7807249, 10.1007/978-3-031-16092-9_7} that affect their adoption while also raising concerns about the system's correctness~\cite{10.1145/3460120.3485341}. As an example of this heterogeneity, Intel SGX~\cite{cryptoeprint:2016:086} offers code confidentiality and attestation, but ARM TrustZone~\cite{arm-realm} does not. Likewise, AMD-sev~\cite{amd-sev} and Intel TDX~\cite{intelTDX} offer OS-based programming interfaces, whereas Keystone~\cite{riscv-multizone} and SGX require specific SDKs~\cite{KeystoneSDK}. Prior work {\em could} not address this heterogeneity challenge; in fact, we found that almost all prior systems' implementations~\cite{hybster, 10.1145/3492321.3519568, minBFT, DBLP:journals/corr/LiuLKA16a} require {\em homogeneous} {\tt x86} machines with SGX extensions of a specific version.

% The requirement of homogeneous TEEs is rather unrealistic in modern cloud environments, resulting in system designers being compelled to {\em stitch heterogeneous TEEs together} to build trustworthy distributed systems. Unfortunately, this tactic introduces significant overheads in two directions. First, due to significant engineering efforts, TEEs'  {programmability differences limit} their adoption as a widely accepted general approach for trustworthy systems. Secondly, TEE's fundamental heterogeneity in {security semantics} complicates the correctness of the derived system; system designers must carefully consider the derived system's security guarantees.



\myparagraph{Key idea: A host CPU-agnostic unified security architecture based on trustworthy network-level isolation} 
Our \projecttitle{} offers a unified and host-agnostic network-interface level isolation that guarantees the specific yet well-defined security properties of the non-equivocation and transferable authentication. 
\rev{B1}{\projecttitle{} shifts the security properties from CPU-hosted TEEs to NIC hardware, thereby addressing the heterogeneity and programmability issues associated with CPU-based TEEs.}
% \projecttitle{} is built upon SmartNIC hardware, which is highly favorable in the heterogeneous Byzantine cloud infrastructure. 
%\projecttitle{} is built upon SmartNIC hardware, which is highly favorable in the heterogeneous Byzantine cloud infrastructure. 
\projecttitle{} also offers generic programming APIs ($\S$~\ref{sec:net-lib}) that are used to {\em correctly} transform a wide variety of distributed systems for Byzantine settings. 
We demonstrate the power of \projecttitle{} with a generic transformation {\em recipe} ($\S$~\ref{subsec:transformation}) and its usage to transform prominent distributed systems ($\S$~\ref{sec:use_cases}).
% We build our \projecttitle{} system on SmartNIC hardware to achieve those goals, offering network-level isolation for our offered security properties. 
% Importantly, our host-agnostic \projecttitle{} network interface is highly favorable in the heterogeneous Byzantine cloud infrastructure. In contrast, the \projecttitle{}'s security properties have been proven to be sufficient for {\em correctly} transforming a wide variety of distributed systems for Byzantine settings. 

% Our \projecttitle{} offers a unified and host-agnostic network-interface level isolation that guarantees the specific and well-defined security properties of the non-equivocation and the transferable authentication. At the same time, we resolve the programmability burden through generic programming APIs. We build our \projecttitle{} system on SmartNIC hardware to achieve those goals, offering network-level isolation for our offered security properties. Importantly, our host-agnostic \projecttitle{} network interface is highly favorable in the heterogeneous Byzantine cloud infrastructure. In contrast, \projecttitle{}'s security properties of the non-equivocation and the transferable authentication have been proven to be sufficient for {\em correctly} transforming a wide variety of distributed systems for Byzantine settings. In fact, we show the power of \projecttitle{} with a generic transformation {\em recipe} ($\S$~\ref{subsec:transformation}) as well as its application to transform four widely adopted distributed systems ($\S$~\ref{sec:use_cases}).


\myparagraph{\#2: Large TCB in the TEE-based silicon root-of-trust} 
TEEs based on a {\em silicon root of trust} are promising for building trustworthy systems~\cite{avocado, minBFT, hybster, 10.1145/3492321.3519568}. Unfortunately, the state-of-the-art TEEs integrate a {\em large} TCB; for example, we calculate the TCB size of the state-of-the-art Intel TDX~\cite{intelTDX}. The TEE ports within the trusted hardware the entire Linux kernel (specifically, v5.19~\cite{linuxlifecircle}) and ``hardens'' at least 2000K lines of usable code, leading to a final TCB of 19MB. Such large TCBs have been accused of increasing the area of faults and attacks~\cite{10.1145/3379469, 10.5555/1756748.1756832} of commercial TEEs that are already under fire for their {security vulnerabilities}~\cite{intel_sgx_vulnerabilities1, intel_sgx_vulnerabilities2, intel_sgx_vulnerabilities3, intel_sgx_vulnerabilities4, intel_sgx_vulnerabilities5}. Importantly, TEE's large TCBs complicate their {security analysis and verification}, rendering their security properties {\em incoherent}. 
% Prior works~\cite{avocado, minBFT, hybster, 10.1145/3492321.3519568} have established the {\em silicon root of trust}, e.g., TEEs, to be a promising direction to build trustworthy systems. Unfortunately, even the state-of-the-art TEEs integrate a {\em large} TCB. For example, we calculated the TCB size of the state-of-the-art Intel TDX~\cite{intelTDX}. The TEE ports within the trusted hardware the entire Linux kernel (specifically, v5.19~\cite{linuxlifecircle}) and ``hardens'' at least 2K lines of usable code, leading to a final TCB of 19MB. Such large TCBs have been accused of increasing the area of faults and attacks~\cite{10.1145/3379469, 10.5555/1756748.1756832} of commercial TEEs that are already under fire for their {major security vulnerabilities}~\cite{intel_sgx_vulnerabilities1, intel_sgx_vulnerabilities2, intel_sgx_vulnerabilities3, intel_sgx_vulnerabilities4, intel_sgx_vulnerabilities5}. As such, modern TEEs suffer from security flaws, whereas their large TCBs complicate their {security analysis and formal verification}, rendering the derived ``trustworthy'' distributed system {\em incoherent}. 


\myparagraph{Key idea: A minimal and formally verifiable silicon root-of-trust with low TCB} 
In our work, we advocate that a {\em minimalistic silicon root of trust} (TCB) at the NIC level hardware is the foundation for building verifiable, trustworthy distributed systems. 
In fact, \projecttitle{} builds a minimalistic and verifiable attestation kernel ($\S$~\ref{subsec:nic_attest_kernel}) that guarantees the \projecttitle{} security properties at the SmartNIC hardware. 
% that guarantees the non-equivocation and transferable authentication properties for network messages. 
% In fact, \projecttitle{} builds a minimalistic and verifiable attestation kernel at the SmartNIC hardware that guarantees the non-equivocation and transferable authentication properties for network messages. 
Moreover, we have formally verified the \projecttitle{} secure hardware protocols ($\S$~\ref{subsec::formal_verification_remote_attestation}).
% since we rely on a minimalistic interface for trusted computing, 


% In our work, we advocate that a {\em minimalistic silicon root of trust} (TCB) at the NIC level hardware is the foundation for building verifiable, trustworthy distributed systems. In fact, \projecttitle{} builds a minimalistic and verifiable attestation kernel (TCB) at the SmartNIC hardware that guarantees the non-equivocation and the transferable authentication properties for the network messages. Moreover, since we rely on a minimalistic interface for trusted computing, we have formally verified the \projecttitle{} secure hardware protocols in the Tamarin theorem prover ($\S$~\ref{subsec::formal_verification_remote_attestation}).


\myparagraph{\#3: Performance} 
TEE's overheads are significant in the context of networked systems~\cite{avocado, treaty, minBFT,10.1145/3492321.3519568}. Prior research~\cite{avocado} reported 4$\times$---8$\times$ performance degradation with even a sophisticated network stack. Others~\cite{10.1145/3492321.3519568, hybster, minBFT} limit performance due to the communication costs between their untrusted and TEE-based counterparts~\cite{10.1145/2168836.2168866}. The actual performance overheads in heterogeneous distributed systems are expected to be more exacerbated~\cite{9460547, 9935045}. As such, TEEs cannot {\em naturally} offer high-performant, trusted networking. 
% Distributed systems in the third-party cloud infrastructure must be fast and trustworthy. Their overheads are significantly exacerbated in the context of networked systems~\cite{avocado, treaty, minBFT,10.1145/3492321.3519568}--- the foundational building block in the core of any distributed system. Prior research~\cite{avocado} have reported an average of 4$\times$---8$\times$ performance degradation for networking between two host-sided TEEs instances (Intel SGX) even with using a sophisticated network stack implementation that had carefully been optimized for this specific TEE version. Other systems on top of TEEs~\cite{10.1145/3492321.3519568, hybster, minBFT} also can limit performance due to the communication costs between the untrusted and TEE-based counterparts of the system~\cite{10.1145/2168836.2168866}. Based on performance analysis of heterogeneous TEEs~\cite{9460547, 9935045}, the actual performance overheads of a distributed system in the heterogeneous cloud can be even more exacerbated. As such host-sided trusted hardware cannot {\em naturally} offer high-performant trusted networking. 

\myparagraph{Key idea: Hardware-accelerated trustworthy network stack} 
Our \projecttitle{} bridges the gap between performance and security with two design insights. 
First, \projecttitle{} attestation kernel offers the foundations to transform CFT distributed systems to BFT systems without affecting the number of participating nodes, significantly improving scalability. 
% which significantly improves scalability. 
% First, \projecttitle{} minimalistic TCB, the attestation kernel, offers the foundations to transform CFT distributed systems to BFT systems without affecting the number of participating nodes, which significantly improves scalability. 
Second, \projecttitle{} user-space network stack ($\S$~\ref{sec:t-nic-network}) bypasses the OS and offloads security and network processing to the NIC-level hardware. 
% This is especially important in the context of replication protocol as the transformation significantly improves scalability; we can have BFT with the same number of participating nodes as in the CFT system. 
% Second, we offer a user-space network stack that bypasses the OS while we build our attestation kernel at the NIC-level hardware---specifically, on SmartNICs---offloading at the hardware the security processing of the non-equivocation and transferable authentication. 
% Our \projecttitle{} bridges the gap between performance and security with two design insights. First \projecttitle{} minimalistic TCB, the attestation kernel, offers the foundations to transform CFT distributed systems to BFT distributed systems without affecting the number of participating machines. This is especially important in the context of replication protocol as the transformation significantly improves scalability; we can have BFT with the same number of participating nodes as in the CFT system. Secondly, we offer a user-space network stack that bypasses the OS while we build our attestation kernel at the NIC-level hardware---specifically, on SmartNICs---offloading at the hardware the security processing of the non-equivocation and transferable authentication. 







\if 0
\myparagraph{Challenge \#1: Heterogeneity and Programmability} Prior trustworthy systems were built on top of CPU-specific TEEs. Importantly, we found that almost all of the open-source systems' implementations~\cite{hybster, 10.1145/3492321.3519568, minBFT, DBLP:journals/corr/LiuLKA16a} require {\em homogeneous} {\tt x86} machines with SGX extensions of a specific version.

The requirement for homogeneous TEEs is not realistic in modern cloud environments as the cloud data centers are comprised by heterogeneous machines and continuously update their hardware infrastructure~\cite{}. Following this, system developers are compelled to {\em stitch together} heterogeneous TEEs to build trustworthy systems. Unfortunately, this task is challenging in two aspects. First, it introduces a significant programmability overhead that limits TEEs' adoption as a general approach for trustworthy systems. Secondly, it raises concerns about the safety and the correctness of the designed system; heterogeneous TEEs come with different security properties which complicate the design and safety analysis of the derived system.


\myparagraph{Solution} To attack this challenge, \projecttitle{}'s key idea is unification. We offer a trusted unified programming interface that exposes the generic, yet powerful, security properties of non-equivocation and transferable authentication. The properties, implemented at NIC-hardware level within the \projecttitle{}'s attestation kernel, suffice to transform distributed systems for Byzantine settings ($\S$~\ref{sec:background}). Our \projecttitle{}' approach is highly favorable in the heterogeneous Byzantine cloud infrastructure; we offer BFT guarantees without relying on the host-sided TEEs. In fact, we show the power of \projecttitle{} with a generic transformation {\em recipe} ($\S$~\ref{subsec:transformation}) as well as its application to transform four widely-adopted systems ($\S$~\ref{sec:use_cases}).
%onsequently, . In addition, our minimalistic hardware-assisted TCB allows us to fully verify the safety and security properties of our \projecttitle{} from its initialization and remote attestation process to its normal operation ($\S$~\ref{subsec::formal_verification_remote_attestation}).

\myparagraph{Challenge \#2: Minimalistic TCB} The state-of-the-art TEEs~\cite{amd-sev, intelTDX} integrate a huge TCB that vastly increases the area of faults and attacks. In fact, state-of-the-art TEEs are still under fire for major security vulnerabilities~\cite{intel_sgx_vulnerabilities1, intel_sgx_vulnerabilities2, intel_sgx_vulnerabilities3, intel_sgx_vulnerabilities4, intel_sgx_vulnerabilities5}. As an example of this, we calculated the TCB size of the state-of-the-art Intel TDX~\cite{intelTDX}. The TEE ports within the trusted hardware the entire Linux kernel (specifically, v5.19~\cite{linuxlifecircle}) and ``hardens'' at least 2K lines of usable code, leading to a final TCB of 19MB. Safety in BFT systems has always been a challenge---e.g., Zyzzyva~\cite{unsafe_Zyzzyva} has proven to be unsafe almost ten years after its original publication---let alone when the {\em supposed} BFT system relies on ``unstable'' TEEs. 

\myparagraph{Solution} In our work, we advocate that a {\em minimal TCB}, that materializes the {\em foundational security primitives}, is the key to building verifiable trustworthy distributed systems. In fact, our minimalistic attestation kernel implements the properties of non-equivocation and transferable authentication that have already been proven to be the lower bound for transforming distributed systems to BFT ones~\cite{clement2012}. As such, our \projecttitle{} offers strong foundations to system designers without relying on the TEEs' extended TCB's with lots of unnecessary features.

%To attack this challenge, \projecttitle{}'s key idea is minimalism. We design a minimalistic fully verifiable (TCB) attestation kernel at NIC-hardware level that exposes a unified API to system designers. As such, we offer BFT while removing the distributed system's dependencies on the host CPU, rendering our approach highly favorable in the heterogeneous cloud infrastructure. In addition, our minimalistic hardware-assisted TCB allows us to fully verify the safety and security properties of our \projecttitle{} from its initialization and remote attestation process to its normal operation ($\S$~\ref{subsec::formal_verification_remote_attestation}).

\myparagraph{Challenge \#3: Performance and security} Distributed systems in the third-party cloud infrastructure need to be fast and trustworthy. With the performance being critical in all of them, offering security with TEEs is a poor design choice due to their performance limitations. In addition to the examples in $\S$~\ref{subsec::tees}, we also acknowledge from experience the difficulty to optimise TEE-based programs even with using the state-of-the-art programming frameworks~\cite{scone}. For example, while porting a simple distributed client/server application into \textsc{scone}---an optimized framework that shields (unmodified) applications with Intel SGX---we found that increasing the (protected) swap memory (paging area), even unused, led to a performance degradation by a factor of two for the exact same unmodified application. Consequently, TEEs cannot {\em intuitively} offer performance and security.

%, the problem is even more exacerbated in fault-tolerant systems. Building replication protocols for distributed systems under the Byzantine fault model has always been a complex endeavor with performance, scalability, and engineering challenges~\cite{bftForSkeptics}. Even well-studied protocols, e.g., PBFT~\cite{Castro:2002}, are limited in scalability (it requires at least $f$ nodes w.r.t to its CFT counterpart), incur high latency (it runs three all-to-all broadcasting phases with $O(n^2)$ message complexity) and are hard to verify and optimize~\cite{10.1145/2658994}.

%\myparagraph{Challenge \#1: Performance vs. security} Distributed systems in the third-party cloud infrastructure need to be fast, scalable, and trustworthy. While performance is critical in all of them, with TEEs themselves introducing significant performance limitations, the problem is even more exacerbated in fault-tolerant systems. Building replication protocols for distributed systems under the Byzantine fault model has always been a complex endeavor with performance, scalability, and engineering challenges~\cite{bftForSkeptics}. Even well-studied protocols, e.g., PBFT~\cite{Castro:2002}, are limited in scalability (it requires at least $f$ nodes w.r.t to its CFT counterpart), incur high latency (it runs three all-to-all broadcasting phases with $O(n^2)$ message complexity) and are hard to verify and optimize~\cite{10.1145/2658994}.



\myparagraph{Solution} Our \projecttitle{} bridges this gap between performance and security. We implement a minimal TCB, the attestation kernel ($\S$~\ref{subsec:nic_attest_kernel}), that materializes all the necessary properties for transforming systems for Byzantine settings. We build the attestation kernel as part of the state-of-the-art NIC hardware for high performance ($\S$~\ref{subsec:roce_protocol_kernel}). Our evaluation shows that \projecttitle{}, applied in four widely-adopted systems, outperforms the TEE-based versions of those systems ($\S$~\ref{sec:eval}).

%protocol, to help system designers building more robust protocols. To achieve this, we build an extended implementation of the classical, widely-adopted, RDMA network stack~\cite{rdma} on programmable hardware, i.e., FPGA-based SmartNICs~\cite{u280_smartnics}, offloading on this hardware the necessary required security processing and mechanisms. 

%\myparagraph{Challenge \#1: Security vs high-performance} The distributed applications hosted in the third-party cloud infrastructure need to be highly available. As such, cloud services and applications build on top of replication protocols that offer fault tolerance and can remain available when failures occur~\cite{Jimenez-Peris2001}. The vast majority of such deployed protocols in the cloud operate under the Crash Fault Tolerant model (CFT) where the machines can {\em only} fail by crashing or omitting some steps. However, the CFT model is inadequate in modern cloud infrastructure as it has been observed that the machines or other parts of the infrastructure can fail arbitrarily (i.e., exhibit Byzantine behavior~\cite{Lamport:1982}) due to malicious adversaries, compromised OS/hypervisor in machines, faulty network links and compromised memory and storage medium~\cite{Gunawi_bugs-in-the-cloud, ciad, fast-08-corruption, security-one-sided-communication, accountable-cloud}. Consequently, the current replication protocols target a quite limited fault model which does not match modern's applications security needs that are hosted in the (untrusted) cloud.

%\myparagraph{Solution} Our \projecttitle{} overcomes this limitation by offering  trusted and easily adoptable network operations, which are at the core of any distributed protocol, to help system designers building more robust protocols. To achieve this, we build an extended implementation of the classical, widely-adopted, RDMA network stack~\cite{rdma} on programmable hardware, i.e., FPGA-based SmartNICs~\cite{u280_smartnics}, offloading on this hardware the necessary required security processing and mechanisms. 

%More importantly, conventional BFT protocols present the following characteristics. First, they require an extra set of $f$ participant machines to tolerate up to $f$ failures. Compared to CFT protocols that operate with $2f+1$ participants, classical BFT protocols present limited scalability as they require at least $3f+1$ participants~\cite{BFT_THEORY}. In addition to this, BFT protocols can be slow as they usually run at least three phases of broadcasts~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069} and incur high message complexity (e.g., $O(n^2)$). Lastly, BFT protocols are complex: they are hard to understand, let alone be optimised~\cite{10.1145/2658994}. Even intuitive algorithmic improvements to optimize for the common case or recovery can significantly affect other parts of the protocol (e.g., view-change in~\cite{10.1145/1658357.1658358}, normal case adds 2 extra phases in~\cite{DBLP:journals/corr/abs-1803-05069}) .% Consequently, they have seen little adoption in commercial cloud applications due to their limited scalability and performance.




  


\myparagraph{Challenge \#4: Hardware verifiability} Some (but not all) TEEs offer (remote) attestation so that the application owner can verify the integrity of the TEE and its executing code. To attest the system, the application code needs to be known to the TEEs' hardware provider (e.g., Intel Attestation Service~\cite{ias}) so that its functionality can be evaluated, {\em measured} before the trust is established. However, there are real-world application scenarios (e.g., proprietary algorithm~\cite{}) where the program itself need to comply with strict privacy policies and cannot be {\em openly} exposed to multiple parties. 

\myparagraph{Solution} Our \projecttitle{} overcomes the limitation. While its offered security properties are decoupled from the CPU running code, we further formally verify the safety and security guarantees of our system.

%\myparagraph{Challenge \#2: Performance and scalability} Researchers~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069, 10.1145/1658357.1658358} presented a range of robust replication protocols that remain correct when arbitrary failures occur targeting the BFT model~\cite{Lamport:1982}. Unfortunately, these BFT protocols have recognised little adoption because they cannot meet the performance requirements of deployed applications~\cite{bft-time-is-now}. In addition, the vast majority~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069} introduces resources overheads and limits scalability because it requires at least $3f+1$ machines to tolerate up to $f$ faults. That is, at least more $f$ machines compared to currently deployed CFT protocols. Consequently, BFT protocols are not well suited for performance in modern high-end distributed systems~\cite{bftForSkeptics}.

%\myparagraph{Solution} We bridge the gap between performance, scalability and robustness. Our \projecttitle{} offers robustness by materialising the necessary foundations for building BFT protocols~\cite{clement2012} in programmable, yet fast, hardware, while it also improves performance and scalability by limiting the number of required participant machines to the minimum, i.e., $2f+1$. More specifically, \projecttitle{} implements the theoretical foundations of Clement et. al~\cite{clement2012} to translate a CFT protocol to a BFT protocol without having to increase the CFT protocol's replication degree. We explain this mechanism in $\S$~\ref{sec:background}.  %Their work has shown that a translation between any CFT protocol to a BFT protocol {\em always} exists if the security properties of the transferable authentication and the non-equivocation are guaranteed. We discuss the properties and the translation mechanism in$\S$~\ref{}. 

%\begin{itemize}
 %   \item {\bf{Transferable authentication.}} Potentially malicious nodes cannot impersonate other (honest) nodes. Essentially, any node can verify that a message is signed by the correct sender, even for forwarded messages.
 %   \item {\bf{Non-equivocation.}} A sender cannot send different messages to different nodes in the same round while it is supposed to send the same message according to the protocol.
%\end{itemize}

%we designed and implemented \projecttitle{} to offer the two properties of non-equivocation and transferable authentication that allow us to design and build BFT protocols with the minimum possible participant nodes ($2f+1$), resolving the trade-off of scalability, performance, and BFT at once. 

%More precisely, our design relies on the theoretical findings 

%Our \projecttitle{} materializes these properties on the NIC-level by implementing and integrating an attestation kernel for generating message authentication certificates or attestations and verifying those when messages are received ($\S$~\ref{subsec:tfpga}). That way \projecttitle{} builds and exposes the minimal abstraction required for implementing robust protocols under the Byzantine Fault model with $2f+1$ participant nodes.


%\myparagraph{Challenge \#3: Adaptability} Due to the traditional BFT protocols limitations, a new line of research has attempted to optimize them~\cite{10.1145/3492321.3519568, minBFT, hybster, 10.1145/2168836.2168866, DBLP:journals/corr/LiuLKA16a, trinc} making use of trusted hardware, precisely, Trusted Execution Environments (TEEs)~\cite{cryptoeprint:2016:086, arm-realm, amd-sev, riscv-multizone, intelTDX}. Unfortunately, the safety requirements of these optimized protocols highly depend on very specific and CPU-dependant TEEs. Consequently, in addition to their limit adaptability and generality, these protocols' correct implementation and deployment requires that there will {\em always} be available the required number of machines equipped with specific CPU generation and TEE hardware versions. In any other case, system designers are compelled to be able to quickly learn and program any another available TEE. This complicates the widespread adoption of such protocols because the task of programming heterogeneous TEEs as rather challenging~\cite{10.1145/3460120.3485341} as error prone; various TEEs present different programming models and security properties~\cite{10.1007/978-3-031-16092-9_7}. %To sum up, this heterogeneity complicates the widespread adoption of such protocols.
%it raises questions regarding performance and correctness. 

%---in fact, we found that all such open-sourced protocols~\cite{hybster, 10.1145/3492321.3519568, minBFT, DBLP:journals/corr/LiuLKA16a} are built on top Intel SGX~\cite{intel-sgx}.

%We argue that the protocols' reliance on such specific TEEs limits generality and adoption in modern heterogeneous cloud infrastructure. For example, to deploy these protocols, a cloud provider must guarantee that there would always be available a required number of machines equipped with specific CPU generation and TEE hardware versions. In cases where there are no machines available, or the TEE has been discontinued (e.g., this is the case with Intel SGX~\cite{sgx_deprecated}), protocol designers are compelled to be able to quickly learn and program another available TEE. However, programming heterogeneous TEEs is a task rather challenging~\cite{10.1145/3460120.3485341}, and it raises questions regarding performance and correctness. Heterogeneous TEEs not only have different programming and performance characteristics but the security properties they offer can greatly vary too~\cite{10.1007/978-3-031-16092-9_7}. As an example of this, Keystone (RISC-V)~\cite{keystone_eurosys} and Intel SGX (x86)~\cite{intel-sgx} have quite different programming APIs. In addition, Intel SGX can only support a very limited Trusted Computing Base (TCB), only up to 256MB, compared to Intel TDX~\cite{intelTDX} and AMD-SEV~\cite{amd-sev}. 
%\antonis{may mention arm as well?}
%Importantly, commercially available TEEs~\cite{arm-trustzone, intel-sgx, amd-sev, keystone_eurosys, 197162, timber} offer different levels of security (i.e., integrity, freshness, and confidentiality), whereas not all of them come with built-in support for secure bootstrapping and remote attestation~\cite{10.1007/978-3-031-16092-9_7, 7807249, secTEE}. All these characteristics make the widespread adoption of existing BFT protocols impractical.


%\myparagraph{Solution} We attack this challenge by removing any dependencies on CPU-based TEEs and unshackling the designers from having to continuously learn and program various TEEs. Our \projecttitle{} makes use of programmable hardware, i.e., FPGAs, to implement a trusted network stack offloading any security-related processing in the NIC hardware ($\S$~\ref{subsec:tfpga}) and to offer a unified abstraction (network library) to the system designers ($\S$~\ref{sec:net-lib}). While our \projecttitle{} shifts the homogeneity from the CPU layer to the FPGA-based NIC layer, our architectural design is not hypothetical; \projecttitle{} fits well in recent deployments in commercial clouds, e.g. Microsoft's Catapult design~\cite{msr_smartnics, 211249}. 

%machines. To achieve this, we implement our entire network stack, including the trusted subsystem for non-equivocation and authentication, on the NIC's hardware-level, leveraging the SmartNIC technology~\cite{}. Essentially, our \projecttitle{} shifts the homogeneity from the CPU layer to the NIC layer:  while the host CPUs participating in a protocol can be heterogeneous, our \projecttitle{} is built on top of homogeneous SmartNICs \antonis{seems stricter than what we assume? maybe FPGA-enabled networking?}, exposing a unified abstraction for exchanging and verifying network messages.

%We implemented our network stack on top of FPGA-based SmartNICs, specifically Alveo U280~\cite{alveo_smartnics}. While our design could be adapted to be applicable to  SoC-based SmartNICs (e.g., Mellanox BlueField~\cite{bluefield_smartnics}, Alveo SN1000~\cite{alveo_sn1000}), we decided against it due to their performance limitations in 100G era~\cite{211249}.\antonis{weak argument, Bluefield 3 is up to 400Gbits. Let's say: "Our design is applicable to ... and our evaluation shows that hardware implementation is more beneficial.} Instead, given the increasingly wide deployment of such specialized hardware in DCs as an efficient way to offload network processing our architectural design is not hypothetical. \projecttitle{} fits well in recent deployments in commercial clouds. An example of this is Microsoft’s Catapult, where the FPGA, which sits on the data path in front of the network card and applies ``smart'' processing, could be extended (as in $\S$~\ref{subsec:tfpga}) to improve security.

%Our system achieves these goals by implementing a minimal hardware-based authentication subsystem, the \emph{attestation kernel}, that guarantees the necessary security properties required for BFT. The attestation kernel generates and verifies authentication certificates for the network messages to ensure two core security properties: the non-equivocation and the (transferable) authentication properties. These two properties have been proven to be necessary and sufficient for decreasing the replication factor for BFT protocols~\cite{clement2012}. Further, we carefully implemented \projecttitle{} to optimize for performance and scalability by integrating the attestation kernel ``on path'' at the NIC-level. That way, our system offers security without introducing unnecessary overheads both in performance and adoption: data is processed \emph{on their way} to the network whereas the protocols do not have to rely on a specific TEE in the host CPU layer. 
\fi 

\if 0

\subsection{Design Challenges}
\dimitra{here}
\myparagraph{Challenge \#1: Security} The distributed applications hosted in the third-party cloud infrastructure need to be highly available. As such, cloud services and applications build on top of replication protocols that offer fault tolerance and, importantly, can remain available when failures occur~\cite{Jimenez-Peris2001}. The vast majority of such deployed protocols in the cloud operate under the Crash Fault Tolerant model (CFT) where the machines can {\em only} fail by crashing or omitting some steps. However, the CFT model is inadequate in modern cloud infrastructure as it has been observed that the machines or other parts of the infrastructure can fail arbitrarily (i.e., exhibit Byzantine behavior~\cite{Lamport:1982}) due to malicious adversaries, compromised OS/hypervisor in machines, faulty network links and compromised memory and storage medium~\cite{Gunawi_bugs-in-the-cloud, ciad, fast-08-corruption, security-one-sided-communication, accountable-cloud}. Consequently, the current replication protocols target a quite limited fault model which does not match modern's applications security needs that are hosted in the (untrusted) cloud.

\myparagraph{Solution} Our \projecttitle{} overcomes this limitation by offering  trusted and easily adoptable network operations, which are at the core of any distributed protocol, to help system designers building more robust protocols. To achieve this, we build an extended implementation of the classical, widely-adopted, RDMA network stack~\cite{rdma} on programmable hardware, i.e., FPGA-based SmartNICs~\cite{u280_smartnics}, offloading on this hardware the necessary required security processing and mechanisms. 

%More importantly, conventional BFT protocols present the following characteristics. First, they require an extra set of $f$ participant machines to tolerate up to $f$ failures. Compared to CFT protocols that operate with $2f+1$ participants, classical BFT protocols present limited scalability as they require at least $3f+1$ participants~\cite{BFT_THEORY}. In addition to this, BFT protocols can be slow as they usually run at least three phases of broadcasts~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069} and incur high message complexity (e.g., $O(n^2)$). Lastly, BFT protocols are complex: they are hard to understand, let alone be optimised~\cite{10.1145/2658994}. Even intuitive algorithmic improvements to optimize for the common case or recovery can significantly affect other parts of the protocol (e.g., view-change in~\cite{10.1145/1658357.1658358}, normal case adds 2 extra phases in~\cite{DBLP:journals/corr/abs-1803-05069}) .% Consequently, they have seen little adoption in commercial cloud applications due to their limited scalability and performance.


\myparagraph{Challenge \#2: Performance and scalability} Researchers~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069, 10.1145/1658357.1658358} presented a range of robust replication protocols that remain correct when arbitrary failures occur targeting the BFT model~\cite{Lamport:1982}. Unfortunately, these BFT protocols have recognised little adoption because they cannot meet the performance requirements of deployed applications~\cite{bft-time-is-now}. In addition, the vast majority~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069} introduces resources overheads and limits scalability because it requires at least $3f+1$ machines to tolerate up to $f$ faults. That is, at least more $f$ machines compared to currently deployed CFT protocols. Consequently, BFT protocols are not well suited for performance in modern high-end distributed systems~\cite{bftForSkeptics}.

\myparagraph{Solution} We bridge the gap between performance, scalability and robustness. Our \projecttitle{} offers robustness by materialising the necessary foundations for building BFT protocols~\cite{clement2012} in programmable, yet fast, hardware, while it also improves performance and scalability by limiting the number of required participant machines to the minimum, i.e., $2f+1$. More specifically, \projecttitle{} implements the theoretical foundations of Clement et. al~\cite{clement2012} to translate a CFT protocol to a BFT protocol without having to increase the CFT protocol's replication degree. We explain this mechanism in $\S$~\ref{sec:background}.  %Their work has shown that a translation between any CFT protocol to a BFT protocol {\em always} exists if the security properties of the transferable authentication and the non-equivocation are guaranteed. We discuss the properties and the translation mechanism in$\S$~\ref{}. 

%\begin{itemize}
 %   \item {\bf{Transferable authentication.}} Potentially malicious nodes cannot impersonate other (honest) nodes. Essentially, any node can verify that a message is signed by the correct sender, even for forwarded messages.
 %   \item {\bf{Non-equivocation.}} A sender cannot send different messages to different nodes in the same round while it is supposed to send the same message according to the protocol.
%\end{itemize}

%we designed and implemented \projecttitle{} to offer the two properties of non-equivocation and transferable authentication that allow us to design and build BFT protocols with the minimum possible participant nodes ($2f+1$), resolving the trade-off of scalability, performance, and BFT at once. 

%More precisely, our design relies on the theoretical findings 

%Our \projecttitle{} materializes these properties on the NIC-level by implementing and integrating an attestation kernel for generating message authentication certificates or attestations and verifying those when messages are received ($\S$~\ref{subsec:tfpga}). That way \projecttitle{} builds and exposes the minimal abstraction required for implementing robust protocols under the Byzantine Fault model with $2f+1$ participant nodes.


\myparagraph{Challenge \#3: Adaptability} Due to the traditional BFT protocols limitations, a new line of research has attempted to optimize them~\cite{10.1145/3492321.3519568, minBFT, hybster, 10.1145/2168836.2168866, DBLP:journals/corr/LiuLKA16a, trinc} making use of trusted hardware, precisely, Trusted Execution Environments (TEEs)~\cite{cryptoeprint:2016:086, arm-realm, amd-sev, riscv-multizone, intelTDX}. Unfortunately, the safety requirements of these optimized protocols highly depend on very specific and CPU-dependant TEEs. Consequently, in addition to their limit adaptability and generality, these protocols' correct implementation and deployment requires that there will {\em always} be available the required number of machines equipped with specific CPU generation and TEE hardware versions. In any other case, system designers are compelled to be able to quickly learn and program any another available TEE. This complicates the widespread adoption of such protocols because the task of programming heterogeneous TEEs as rather challenging~\cite{10.1145/3460120.3485341} as error prone; various TEEs present different programming models and security properties~\cite{10.1007/978-3-031-16092-9_7}. %To sum up, this heterogeneity complicates the widespread adoption of such protocols.
%it raises questions regarding performance and correctness. 

%---in fact, we found that all such open-sourced protocols~\cite{hybster, 10.1145/3492321.3519568, minBFT, DBLP:journals/corr/LiuLKA16a} are built on top Intel SGX~\cite{intel-sgx}.

%We argue that the protocols' reliance on such specific TEEs limits generality and adoption in modern heterogeneous cloud infrastructure. For example, to deploy these protocols, a cloud provider must guarantee that there would always be available a required number of machines equipped with specific CPU generation and TEE hardware versions. In cases where there are no machines available, or the TEE has been discontinued (e.g., this is the case with Intel SGX~\cite{sgx_deprecated}), protocol designers are compelled to be able to quickly learn and program another available TEE. However, programming heterogeneous TEEs is a task rather challenging~\cite{10.1145/3460120.3485341}, and it raises questions regarding performance and correctness. Heterogeneous TEEs not only have different programming and performance characteristics but the security properties they offer can greatly vary too~\cite{10.1007/978-3-031-16092-9_7}. As an example of this, Keystone (RISC-V)~\cite{keystone_eurosys} and Intel SGX (x86)~\cite{intel-sgx} have quite different programming APIs. In addition, Intel SGX can only support a very limited Trusted Computing Base (TCB), only up to 256MB, compared to Intel TDX~\cite{intelTDX} and AMD-SEV~\cite{amd-sev}. 
%\antonis{may mention arm as well?}
%Importantly, commercially available TEEs~\cite{arm-trustzone, intel-sgx, amd-sev, keystone_eurosys, 197162, timber} offer different levels of security (i.e., integrity, freshness, and confidentiality), whereas not all of them come with built-in support for secure bootstrapping and remote attestation~\cite{10.1007/978-3-031-16092-9_7, 7807249, secTEE}. All these characteristics make the widespread adoption of existing BFT protocols impractical.


\myparagraph{Solution} We attack this challenge by removing any dependencies on CPU-based TEEs and unshackling the designers from having to continuously learn and program various TEEs. Our \projecttitle{} makes use of programmable hardware, i.e., FPGAs, to implement a trusted network stack offloading any security-related processing in the NIC hardware ($\S$~\ref{subsec:tfpga}) and to offer a unified abstraction (network library) to the system designers ($\S$~\ref{sec:net-lib}). While our \projecttitle{} shifts the homogeneity from the CPU layer to the FPGA-based NIC layer, our architectural design is not hypothetical; \projecttitle{} fits well in recent deployments in commercial clouds, e.g. Microsoft's Catapult design~\cite{msr_smartnics, 211249}. 

%machines. To achieve this, we implement our entire network stack, including the trusted subsystem for non-equivocation and authentication, on the NIC's hardware-level, leveraging the SmartNIC technology~\cite{}. Essentially, our \projecttitle{} shifts the homogeneity from the CPU layer to the NIC layer:  while the host CPUs participating in a protocol can be heterogeneous, our \projecttitle{} is built on top of homogeneous SmartNICs \antonis{seems stricter than what we assume? maybe FPGA-enabled networking?}, exposing a unified abstraction for exchanging and verifying network messages.

%We implemented our network stack on top of FPGA-based SmartNICs, specifically Alveo U280~\cite{alveo_smartnics}. While our design could be adapted to be applicable to  SoC-based SmartNICs (e.g., Mellanox BlueField~\cite{bluefield_smartnics}, Alveo SN1000~\cite{alveo_sn1000}), we decided against it due to their performance limitations in 100G era~\cite{211249}.\antonis{weak argument, Bluefield 3 is up to 400Gbits. Let's say: "Our design is applicable to ... and our evaluation shows that hardware implementation is more beneficial.} Instead, given the increasingly wide deployment of such specialized hardware in DCs as an efficient way to offload network processing our architectural design is not hypothetical. \projecttitle{} fits well in recent deployments in commercial clouds. An example of this is Microsoft’s Catapult, where the FPGA, which sits on the data path in front of the network card and applies ``smart'' processing, could be extended (as in $\S$~\ref{subsec:tfpga}) to improve security.

%Our system achieves these goals by implementing a minimal hardware-based authentication subsystem, the \emph{attestation kernel}, that guarantees the necessary security properties required for BFT. The attestation kernel generates and verifies authentication certificates for the network messages to ensure two core security properties: the non-equivocation and the (transferable) authentication properties. These two properties have been proven to be necessary and sufficient for decreasing the replication factor for BFT protocols~\cite{clement2012}. Further, we carefully implemented \projecttitle{} to optimize for performance and scalability by integrating the attestation kernel ``on path'' at the NIC-level. That way, our system offers security without introducing unnecessary overheads both in performance and adoption: data is processed \emph{on their way} to the network whereas the protocols do not have to rely on a specific TEE in the host CPU layer. 
\fi