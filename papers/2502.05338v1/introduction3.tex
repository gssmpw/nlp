\section{Introduction}
\blfootnote{$^*$This work started when the author was at the University of Edinburgh.}
Distributed systems are integral to the third-party cloud infrastructure~\cite{amazon_ec2, microsoft_azure, rackspace, google_engine}. While these systems manifest in diverse forms (e.g., storage systems~\cite{dynamo, azure_storage, tao, spanner, 51, zippy, AmazonS3}, management services~\cite{Hunt:2010, Burns2016}, computing frameworks~\cite{aws_lambda, azure_functions, google_cloud_functions}) they all must be fast and remain correct upon failures. %when failures occur. 

Unfortunately, the widespread adoption of the cloud has drastically increased the surface area of attacks and faults~\cite{Gunawi_bugs-in-the-cloud, Shinde2016, high_resolution_side_channels} that are beyond the traditional fail-stop (or crash fault) model~\cite{delporte}. The modern (untrusted) third-party cloud infrastructure severely suffers from arbitrary  ({\em Byzantine}) \linebreak faults~\cite{Lamport:1982} that can range from malicious (network) attacks to configuration errors and bugs and are capable of irreversibly disrupting the correct execution of the system~\cite{Gunawi_bugs-in-the-cloud, Shinde2016, high_resolution_side_channels, Castro:2002}.
% ford2010availability, Mazieres2002b, Garay2000}.

A promising solution to build trustworthy distributed systems that can sustain Byzantine failures is based on the {\em silicon root of trust}---specifically, the Trusted Execution Environments (TEEs)~\cite{cryptoeprint:2016:086, arm-realm, amd-sev, riscv-multizone, intelTDX}. While the TEEs offer a (single-node) isolated Trusted Computing Base (TCB),  we have identified three core challenges ($\S$~\ref{subsec:challenges}) that complicate their adoption for building trustworthy distributed systems spanning multiple nodes in Byzantine cloud environments.

{\bf \em First, TEEs in heterogeneous cloud environments introduce programmability and security challenges}. A cloud environment offers diverse heterogeneous host-side CPUs with different TEEs (e.g., Intel SGX/TDX, AMD SEV-SNP, AWS Nitro Enclaves, Arm TrustZone/CCA, RISC-V Keystone). These heterogeneous host-side TEEs require different programming models and offer varying security properties. Therefore, they cannot (easily) provide a generic substrate for building trustworthy distributed systems. Our work overcomes this challenge by designing a {\em host CPU-agnostic} {\em silicon root of trust} at the network interface (NIC) level ($\S$~\ref{sec:t-nic-hardware}). We provide a generic programming API ($\S$~\ref{sec:t-nic-software}) and a {\em recipe} ($\S$~\ref{subsec:transformation}) for building high-performance, trustworthy distributed systems ($\S$~\ref{sec:use_cases}).
%, exposing a {\em unified trusted} network-level isolation 

{\bf \em Secondly, TEEs with a large TCB are plagued with security vulnerabilities, rendering them non-verifiable}. With hundreds of security bugs already uncovered~\cite{10.1145/3456631}, TEEs' large TCBs further increase their security vulnerabilities~\cite{10.1145/3379469, 10.5555/1756748.1756832}, impeding a formal verification of their security. We overcome this with a {\em minimalistic verifiable TCB} ($\S$~\ref{subsec:nic_attest_kernel}). Our TCB resides at the NIC hardware and is equipped with {\em the lower bound of security primitives};  we provide only two key security properties of non-equivocation and transferable authentication for building trustworthy distributed systems ($\S$~\ref{subsec:trustworthy_ds}). Since we strive for a minimal trusted interface, we can (and we did) formally verify the security properties of our TCB ($\S$~\ref{subsec::formal_verification_remote_attestation}). 

{\bf \em Thirdly, TEEs report significant performance bottlenecks.} TEEs syscalls execution for (network) I/O is extremely costly~\cite{hotcalls}, whereas even state-of-the-art network stacks showed a lower bound of 4$\times$ slowdown~\cite{avocado}. We attack this challenge based on two aspects. First, we build a scalable transformation with our minimal TCB's security properties ($\S$~\ref{subsec:transformation}) to transform Byzantine faults (3$f$+1) to much cheaper crash faults (2$f$+1) for tolerating $f$  (distributed) Byzantine nodes.  Secondly, we design hardware-accelerated offload of the security computation at the NIC level by extending the scope of SmartNICs with {\em the lower bound of security primitives} ($\S$~\ref{sec:t-nic-hardware}) while offering kernel-bypass networking ($\S$~\ref{sec:t-nic-network}).


To overcome these challenges, we present  \projecttitle{}, a trusted NIC architecture for building trustworthy distributed systems deployed in Byzantine cloud environments. \projecttitle{} realizes an abstraction of trustworthy network-level isolation by building a hardware-accelerated silicon root of trust at the NIC level. Overall, \projecttitle{} follows a layered design:
\begin{itemize}[leftmargin=*]
    \item {\bf Trusted NIC hardware architecture ($\S$~\ref{sec:t-nic-hardware}):}  We materialize a \underline{minimalistic}, \underline{verifiable}, and \underline{host-CPU-agnostic} TCB at the network interface level as the key component to design trusted distributed systems for Byzantine settings. Our TCB guarantees the security properties of non-equivocation and transferable authentication that suffice to implement an efficient transformation of systems for Byzantine settings. We build \projecttitle{} on top of FPGA-based SmartNICs~\cite{u280_smartnics}. We formally verify the safety and security guarantees of \projecttitle{} protocols using Tamarin Prover~\cite{tamarin-prover}. 

    \item \rev{(a)}{{\bf Network stack ($\S$~\ref{sec:t-nic-network}) and library ($\S$~\ref{sec:t-nic-software}):} Based on the \projecttitle{} architecture, we design a \underline{HW-accelerated} network stack to access the hardware bypassing kernel for performance. On top of \projecttitle{}'s network stack, we present a networking library that exposes a \underline{simplified} programming model. We show {\em how to use} \projecttitle{} APIs to construct a \underline{generic transformation} of a distributed system operating under the CFT model to target Byzantine settings.}
    % \item {\bf Trusted network stack ($\S$~\ref{sec:t-nic-network}) and library ($\S$~\ref{sec:t-nic-software}):} Based on the \projecttitle{} architecture, we design a trusted \underline{HW-accelerated} network stack to access the hardware bypassing kernel for performance. On top of \projecttitle{}'s network stack, we present a trusted networking library that exposes a \underline{simplified} programming model. We show {\em how to use} \projecttitle{} APIs to construct a \underline{generic transformation} of a distributed system operating under the CFT model to target Byzantine settings.
    
    \item {\bf Trusted distributed systems using \projecttitle{} ($\S$~\ref{sec:use_cases}):} We build with \projecttitle{} the following (distributed) systems for Byzantine environments: Attested Append-only Memory (A2M)~\cite{A2M}, Byzantine Fault Tolerance (BFT)~\cite{pbft}, Chain Replication~\cite{chain-replication}, and Accountability with PeerReview~\cite{peer-review}---showing the \underline{generality of our approach}.
\end{itemize}



% We build \projecttitle{} on top of Alveo U280 FPGA-based SmartNICs~\cite{u280_smartnics}.  extending the Coyote system~\cite{coyote}.
% Our core component is the \projecttitle{}'s {\em attestation kernel} ($\S$~\ref{subsec:nic_attest_kernel}), the minimal required hardware-assisted TCB that guarantees the lower bound of security properties for BFT across the network ($\S$~\ref{sec:requirements-ds}). 
% We formally verify the safety and correctness properties of all \projecttitle{}'s operations (i.e., from remote attestation to networking) using Tamarin prover~\cite{tamarin-prover} ($\S$~\ref{subsec::formal_verification_remote_attestation}). Our 
% \projecttitle{}'s attestation kernel resides on the network data path to optimize for latency while we further design a unified trusted network stack to implement user-space networking following the RDMA programming paradigm ($\S$~\ref{subsec:roce_protocol_kernel} and $\S$~\ref{sec:t-nic-network}). Lastly, we leverage our \projecttitle{} trusted network library($\S$~\ref{sec:t-nic-software}) to show a generic {\em recipe} ($\S$~\ref{subsec:transformation})to transform a distributed system operating under the fail-stop model for Byzantine settings ($\S$~\ref{subsec:transformation}). 



We evaluate \projecttitle{} with a  state-of-the-art software-based network stack, eRPC~\cite{erpc}, on top of RDMA~\cite{rdma}/DPDK~\cite{dpdk} with two different TEEs (Intel SGX~\cite{intel-sgx} and AMD-sev~\cite{amd-sev}). Our evaluation shows that \projecttitle{} offers 3$\times$---5$\times$ lower latency than the software-based approach with the CPU-based TEEs. For trusted distributed systems, \projecttitle{} improves throughput by up to $6\times$ compared to their TEE-based implementations.
 % We evaluate the \projecttitle{}-based versions of the four implemented systems against their TEEs-based versions. 

