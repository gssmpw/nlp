\section{Overview}
\dimitra{here}
\subsection{Design challenges for a trusted NIC}
\label{sec:requirements}
Our work is motivated by 
Our proposal for \projecttitle{} seeks to resolve the tension between security and performance for (distributed) applications in the modern cloud infrastructure, specifically targeting replication protocols\pramod{focus on building trusted distributed systems -- PLEASE DONT MAKE THIS PAPER a REPLICATION protocol paper.}. To this end, our goal is to help system designers to build efficient, fault-tolerant, and robust systems that remain correct even when the untrusted cloud infrastructure fails arbitrarily. 

To sum up, we target the following design properties: 
\begin{itemize}
    \item {\bf{Robustness}} for building and deploying fault-tolerant distributed protocols and applications that remain correct and available in the untrusted cloud infrastructure.
    \item {\bf{Performance and scalability}} for efficiently exchanging and authenticating network messages. Particularly, our \projecttitle{} allows for BFT with the minimum possible number of involved servers ($2f+1$), mitigating clients' costs and resource usage.
    \item {\bf{Adaptability}} for allowing protocol designers to build robust protocols that can seamlessly run in modern heterogeneous DCs without them having to be BFT experts. 
\end{itemize}


\myparagraph{Challenge \#1: Robustness} The distributed applications hosted in the third-party cloud infrastructure need to be highly available. As such, cloud services and applications build on top of replication protocols that offer fault tolerance and, importantly, can remain available when failures occur~\cite{Jimenez-Peris2001}. The vast majority of such deployed protocols in the cloud operate under the Crash Fault Tolerant model (CFT) where the machines can {\em only} fail by crashing or omitting some steps. However, the CFT model is inadequate in modern cloud infrastructure as it has been observed that the machines or other parts of the infrastructure can fail arbitrarily (i.e., exhibit Byzantine behavior~\cite{Lamport:1982}) due to malicious adversaries, compromised OS/hypervisor in machines, faulty network links and compromised memory and storage medium~\cite{Gunawi_bugs-in-the-cloud, ciad, fast-08-corruption, security-one-sided-communication, accountable-cloud}. Consequently, the current replication protocols target a quite limited fault model which does not match modern's applications security needs that are hosted in the (untrusted) cloud.

\myparagraph{Solution} Our \projecttitle{} overcomes this limitation by offering  trusted and easily adoptable network operations, which are at the core of any distributed protocol, to help system designers building more robust protocols. To achieve this, we build an extended implementation of the classical, widely-adopted, RDMA network stack~\cite{rdma} on programmable hardware, i.e., FPGA-based SmartNICs~\cite{u280_smartnics}, offloading on this hardware the necessary required security processing and mechanisms. 

%More importantly, conventional BFT protocols present the following characteristics. First, they require an extra set of $f$ participant machines to tolerate up to $f$ failures. Compared to CFT protocols that operate with $2f+1$ participants, classical BFT protocols present limited scalability as they require at least $3f+1$ participants~\cite{BFT_THEORY}. In addition to this, BFT protocols can be slow as they usually run at least three phases of broadcasts~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069} and incur high message complexity (e.g., $O(n^2)$). Lastly, BFT protocols are complex: they are hard to understand, let alone be optimised~\cite{10.1145/2658994}. Even intuitive algorithmic improvements to optimize for the common case or recovery can significantly affect other parts of the protocol (e.g., view-change in~\cite{10.1145/1658357.1658358}, normal case adds 2 extra phases in~\cite{DBLP:journals/corr/abs-1803-05069}) .% Consequently, they have seen little adoption in commercial cloud applications due to their limited scalability and performance.


\myparagraph{Challenge \#2: Performance and scalability} Researchers~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069, 10.1145/1658357.1658358} presented a range of robust replication protocols that remain correct when arbitrary failures occur targeting the BFT model~\cite{Lamport:1982}. Unfortunately, these BFT protocols have recognised little adoption because they cannot meet the performance requirements of deployed applications~\cite{bft-time-is-now}. In addition, the vast majority~\cite{Castro:2002, DBLP:journals/corr/abs-1803-05069} introduces resources overheads and limits scalability because it requires at least $3f+1$ machines to tolerate up to $f$ faults. That is, at least more $f$ machines compared to currently deployed CFT protocols. Consequently, BFT protocols are not well suited for performance in modern high-end distributed systems~\cite{bftForSkeptics}.

\myparagraph{Solution} We bridge the gap between performance, scalability and robustness. Our \projecttitle{} offers robustness by materialising the necessary foundations for building BFT protocols~\cite{clement2012} in programmable, yet fast, hardware, while it also improves performance and scalability by limiting the number of required participant machines to the minimum, i.e., $2f+1$. More specifically, \projecttitle{} implements the theoretical foundations of Clement et. al~\cite{clement2012} to translate a CFT protocol to a BFT protocol without having to increase the CFT protocol's replication degree. We explain this mechanism in $\S$~\ref{sec:background}.  %Their work has shown that a translation between any CFT protocol to a BFT protocol {\em always} exists if the security properties of the transferable authentication and the non-equivocation are guaranteed. We discuss the properties and the translation mechanism in$\S$~\ref{}. 

%\begin{itemize}
 %   \item {\bf{Transferable authentication.}} Potentially malicious nodes cannot impersonate other (honest) nodes. Essentially, any node can verify that a message is signed by the correct sender, even for forwarded messages.
 %   \item {\bf{Non-equivocation.}} A sender cannot send different messages to different nodes in the same round while it is supposed to send the same message according to the protocol.
%\end{itemize}

%we designed and implemented \projecttitle{} to offer the two properties of non-equivocation and transferable authentication that allow us to design and build BFT protocols with the minimum possible participant nodes ($2f+1$), resolving the trade-off of scalability, performance, and BFT at once. 

%More precisely, our design relies on the theoretical findings 

%Our \projecttitle{} materializes these properties on the NIC-level by implementing and integrating an attestation kernel for generating message authentication certificates or attestations and verifying those when messages are received ($\S$~\ref{subsec:tfpga}). That way \projecttitle{} builds and exposes the minimal abstraction required for implementing robust protocols under the Byzantine Fault model with $2f+1$ participant nodes.


\myparagraph{Challenge \#3: Adaptability} Due to the traditional BFT protocols limitations, a new line of research has attempted to optimize them~\cite{10.1145/3492321.3519568, minBFT, hybster, 10.1145/2168836.2168866, DBLP:journals/corr/LiuLKA16a, trinc} making use of trusted hardware, precisely, Trusted Execution Environments (TEEs)~\cite{cryptoeprint:2016:086, arm-realm, amd-sev, riscv-multizone, intelTDX}.  Unfortunately, the safety requirements of these optimized protocols highly depend on very specific and CPU-dependant TEEs. Consequently, in addition to their limit adaptability and generality, these protocols' correct implementation and deployment requires that there will {\em always} be available the required number of machines equipped with specific CPU generation and TEE hardware versions. In any other case, system designers are compelled to be able to quickly learn and program any another available TEE. This complicates the widespread adoption of such protocols because the task of programming heterogeneous TEEs as rather challenging~\cite{10.1145/3460120.3485341} as error prone; various TEEs present different programming models and security properties~\cite{10.1007/978-3-031-16092-9_7}. %To sum up, this heterogeneity complicates the widespread adoption of such protocols.
%it raises questions regarding performance and correctness. 

%---in fact, we found that all such open-sourced protocols~\cite{hybster, 10.1145/3492321.3519568, minBFT, DBLP:journals/corr/LiuLKA16a} are built on top Intel SGX~\cite{intel-sgx}.

%We argue that the protocols' reliance on such specific TEEs limits generality and adoption in modern heterogeneous cloud infrastructure. For example, to deploy these protocols, a cloud provider must guarantee that there would always be available a required number of machines equipped with specific CPU generation and TEE hardware versions. In cases where there are no machines available, or the TEE has been discontinued (e.g., this is the case with Intel SGX~\cite{sgx_deprecated}), protocol designers are compelled to be able to quickly learn and program another available TEE. However, programming heterogeneous TEEs is a task rather challenging~\cite{10.1145/3460120.3485341}, and it raises questions regarding performance and correctness. Heterogeneous TEEs not only have different programming and performance characteristics but the security properties they offer can greatly vary too~\cite{10.1007/978-3-031-16092-9_7}. As an example of this, Keystone (RISC-V)~\cite{keystone_eurosys} and Intel SGX (x86)~\cite{intel-sgx} have quite different programming APIs. In addition, Intel SGX can only support a very limited Trusted Computing Base (TCB), only up to 256MB, compared to Intel TDX~\cite{intelTDX} and AMD-SEV~\cite{amd-sev}. 
%\antonis{may mention arm as well?}
%Importantly, commercially available TEEs~\cite{arm-trustzone, intel-sgx, amd-sev, keystone_eurosys, 197162, timber} offer different levels of security (i.e., integrity, freshness, and confidentiality), whereas not all of them come with built-in support for secure bootstrapping and remote attestation~\cite{10.1007/978-3-031-16092-9_7, 7807249, secTEE}. All these characteristics make the widespread adoption of existing BFT protocols impractical.


\myparagraph{Solution} We attack this challenge by removing any dependencies on CPU-based TEEs and unshackling the designers from having to continuously learn and program various TEEs. Our \projecttitle{} makes use of programmable hardware, i.e., FPGAs, to implement a trusted network stack offloading any security-related processing in the NIC hardware ($\S$~\ref{subsec:tfpga}) and to offer a unified abstraction (network library) to the system designers ($\S$~\ref{sec:net-lib}). While our \projecttitle{} shifts the homogeneity from the CPU layer to the FPGA-based NIC layer, our architectural design is not hypothetical; \projecttitle{} fits well in recent deployments in commercial clouds, e.g. Microsoft's Catapult design~\cite{msr_smartnics, 211249}. 

%machines. To achieve this, we implement our entire network stack, including the trusted subsystem for non-equivocation and authentication, on the NIC's hardware-level, leveraging the SmartNIC technology~\cite{}. Essentially, our \projecttitle{} shifts the homogeneity from the CPU layer to the NIC layer:  while the host CPUs participating in a protocol can be heterogeneous, our \projecttitle{} is built on top of homogeneous SmartNICs \antonis{seems stricter than what we assume? maybe FPGA-enabled networking?}, exposing a unified abstraction for exchanging and verifying network messages.

%We implemented our network stack on top of FPGA-based SmartNICs, specifically Alveo U280~\cite{alveo_smartnics}. While our design could be adapted to be applicable to  SoC-based SmartNICs (e.g., Mellanox BlueField~\cite{bluefield_smartnics}, Alveo SN1000~\cite{alveo_sn1000}), we decided against it due to their performance limitations in 100G era~\cite{211249}.\antonis{weak argument, Bluefield 3 is up to 400Gbits. Let's say: "Our design is applicable to ... and our evaluation shows that hardware implementation is more beneficial.} Instead, given the increasingly wide deployment of such specialized hardware in DCs as an efficient way to offload network processing our architectural design is not hypothetical. \projecttitle{} fits well in recent deployments in commercial clouds. An example of this is Microsoftâ€™s Catapult, where the FPGA, which sits on the data path in front of the network card and applies ``smart'' processing, could be extended (as in $\S$~\ref{subsec:tfpga}) to improve security.

%Our system achieves these goals by implementing a minimal hardware-based authentication subsystem, the \emph{attestation kernel}, that guarantees the necessary security properties required for BFT. The attestation kernel generates and verifies authentication certificates for the network messages to ensure two core security properties: the non-equivocation and the (transferable) authentication properties. These two properties have been proven to be necessary and sufficient for decreasing the replication factor for BFT protocols~\cite{clement2012}. Further, we carefully implemented \projecttitle{} to optimize for performance and scalability by integrating the attestation kernel ``on path'' at the NIC-level. That way, our system offers security without introducing unnecessary overheads both in performance and adoption: data is processed \emph{on their way} to the network whereas the protocols do not have to rely on a specific TEE in the host CPU layer. 

\section{Overview}
To this end we propose \projecttitle{}, a trusted NIC architecture that fullfils the afforementioned design goals. Figure~\ref{fig:overview} shows our \projecttitle{} system design. The system is comprised of three layers: (1) the application layer that runs the (distributed) protocol code (We show four uses cases of \projecttitle{} application in $\S$~\ref{sec:use_cases}), (2) the \projecttitle{} software library which exposes the \projecttitle{} API ($\S$~\ref{sec:net-lib}) and (3) the \projecttitle{} hardware implementation on top of FPGA devices ($\S$~\ref{sec:t-nic-hardware}). Each machine comprises a (host) CPU to which it is attached a \projecttitle{} through the PCIe~\cite{pcie}. The \projecttitle{} devices are connected through direct (Ethernet) links or a switch. %a $X$Gbps Ethernet switch through its QSFP port 0.

The  \projecttitle{} software library implements the programming framework and the \projecttitle{} device access interface. The programming framework exposes a user-space network library for trusted one-sided RDMA (reliable) operations. In addition, we expose a memory management API for correctly initializing and registering the registered-to-the-NIC memory. The software part of our \projecttitle{} also includes a driver that inserts a kernel module to set up the device with the static configuration (MAC address, IP, etc.) and further allocates and maps a specific (host) memory area to the device. While the driver runs only once at the initialization, the mapped memory is used to pass down to the device requests and any related parameters. 


The hardware implementation of \projecttitle{} runs the RDMA protocol on top of FPGA-based SmartNIC hardware. We further extend the network protocol kernel with a minimal hardware security module, the attestation kernel which shields and verifies the network traffic across the participant nodes. Specifically, the security module  constructs a secure message format that is verifiable and the network stack module implements the RDMA network protocol. In contrast to the control and configuration paths shown in Figure~\ref{fig:overview}, the message to be sent, is fetched from the application's memory directly to the device through DMA transfers. The message, after being shielded, is then forwarded to the network stack module for transmission.  % to preserve the authentication and non-equivocation properties across all network operations.
%On top of our trusted network stack, we implement a networking library, \projectlibrary{}, that exposes the developers to the classical RDMA API enhanced with two security properties, i.e., the transferable authentication and the non-equivocation.


\begin{figure}[t!]
    \centering
    %\includegraphics[width=0.5\textwidth]{figures/trusted-nic-overview.drawio.pdf}
    \includegraphics[width=0.5\textwidth]{figures/system_overview-2.pdf}
    \caption{\projecttitle{} system overview.}
    \label{fig:overview}
\end{figure}