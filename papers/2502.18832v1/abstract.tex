\begin{abstract}
\noindent
Safe kernel extensions
  have gained significant traction, % and practical adoption,
  evolving from simple packet filters to
  large, complex programs that customize storage, networking,
  and scheduling.
Existing kernel extension mechanisms like eBPF
  rely on in-kernel verifiers to ensure safety of kernel extensions
  by static verification using symbolic execution.
% However, the current approach introduces
We identify significant usability issues---safe extensions being rejected
  by the verifier---due to the
  % \ayushb{usability is a very broad term, can we maybe concretize it a bit? Since it plays critical role in our analysis, and the explanation in the evaluation is targetted more towards fixing highlighted issues of section 3, summarizing them in 1 or 2 lines to define this term for us would be good}
  {\em \gap{}}, a mismatch between developers' expectation of program
  safety provided by a contract with the programming language,
    and the verifier's expectation.

We present Rax, a new kernel extension framework that closes the \gap{}
  and improves the usability of kernel extensions in terms of
  programming experience and maintainability.
Rax builds upon language-based safety to provide safety
  properties desired by kernel extensions, along with a lightweight extralingual
  runtime for properties that are unsuitable for static analysis, including
  safe exception handling, stack safety, and termination.
% Rax employs a lightweight runtime for
%   safety properties that are hard or costly to guarantee by static analysis, including
%   safe exception handling, stack safety, and program termination.
With Rax, kernel extensions are written in {\it safe} Rust
  and interact with the kernel via a safe interface provided by Rax's kernel crate.
No separate static verification is needed.
\projname{} addresses usability issues of eBPF kernel
  extensions without compromising performance.
\end{abstract}
