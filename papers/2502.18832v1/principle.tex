\vspace{-8pt}
\section{\projname{} Design}
\label{sec:principle}
\vspace{-5pt}
% - no clone impl for objects returned by RT crate to ensure uniqueness
% - difference between userspace Rust: there are things the compiler cannot see
%   e.g., we cannot have something like Mutex::get_mut in bpf_spinlock to
%   access a value w/o lock using the single-mutable-reference rule

\begin{figure}
    \centering
    \includegraphics[width=1.0\linewidth]{figs/rex-overview.pdf}
    \vspace{-15pt}
    \caption{Overview of the \projname{} kernel extension framework.
    The gray boxes are Rax components.}
    \label{fig:rax-overview}
    \vspace{-5pt}
\end{figure}

The key challenge of the Rax design is to provide safety guarantees of kernel extensions
    (listed in \S\ref{sec:background})
    on top of Rust's safe language features (adopting a safe language alone is insufficient,
    as in Rust kernel modules).

Figure~\ref{fig:rax-overview} gives an overview of the \projname{} framework.
To realize language-based safety, Rax enforces kernel extensions to be strictly
    written in {\it safe} Rust with selected features.
The \projname{} compiler toolchain rejects any Rax program that uses unsafe
    language features.
% and performs \projname{}-specific check on kernel stack usage.
% A Rax kernel extension must be  written in {\it safe} Rust
%    (no unsafe Rust code is allowed).
% Safe Rust provides inherent language-based safety, freeing Rax kernel
%     extensions of undefined behavior.
\new{Although this safe subset of Rust already provides inherent language-based
    safety within Rax extensions, eliminating undefined behaviors,
    safety of extensions is only achieved with the presence of safe kernel
    interactions provided by the \emph{\projname{} kernel crate}.
% Rax provides a specialized \emph{kernel crate} for kernel extensions.
% This is complemented with safe kernel interactions through the specialized
%     \projname{} \emph{kernel crate}.
The kernel crate is trusted and
%    contains a mixture of safe and unsafe Rust code
    % acts as a bridge between Rax extensions and unsafe kernel code.
    bridges Rax extensions with unsafe kernel code.}
Rax builds on top of the eBPF helper functions interface to provide a safe
    kernel interface for Rax extensions to interact with the kernel
    using safe Rust wrappers and bindings.
The safe interface encapsulates the interaction across the foreign
    function interface in the kernel crate.
\new{We reuse the eBPF helper interface, because it is designed
    for kernel extensions with a clearly defined programming contract and
    separates extensions from kernel's internal housekeeping
    (e.g., RCU~\cite{rcu}).}
% Rax relies on
%    a trusted Rust compiler which ensures the safety properties
%    of Rust. % and runs a \projname{}-specific pass for kernel stack safety.
%    for static analysis (e.g., lifetime and ownership)
%    and instrumentation (e.g. array bounds checks).
% \projname{} uses Rust as the safe language for extension programs.
% Rust is a system programming language that aims to provide
%    \emph{language-based} safety, promising programs free of \emph{undefined behaviors}.
%Rust is a system programming language that aims to provide
%    \emph{language-based} safety, which promises programs to be free of
%    \emph{undefined behaviors}.
% The compiler both performs static analysis (e.g., lifetime and ownership
%    models) and inserts dynamic checks (e.g. array bounds checks) in
%    Rust programs to guarantee safety.
%fulfill its safety promises.
% To facilitate low-level code that may be hard to fit into its safety model (e.g.
%    FFI calls), the language also provides \emph{unsafe} Rust, which is more
%    permissive and provides a weaker safety guarantee compared to
%    \emph{safe} Rust.


% Utilization of the language-based safety of Rust in kernel contexts has been
%    explored by previous works, and is also incorporated
%    into the Linux kernel~\cite{rust-for-linux-lwn}.
% This is because Rust happens to provide the desired properties -- its
%     language-based safety can be leveraged for safe kernel extensions without a
%     verifier.
% \new{
% In the context of safety for kernel extensions (\S\ref{sec:background}), Rust
%     provides both the desired properties directly and the building blocks to
%    ensure the important safety properties for extensions programs in
%    \projname{}.
% }
%In \projname{}, Rust provides both the desired properties directly and
%    building blocks to ensure the important safety properties for
%    kernel extensions (\S\ref{sec:background}).

% Here, we list the important safety properties
% (\jinghao{may need to move to \S\ref{sec:background}})
% \begin{itemize}
%     \item Memory safety
%     \item Type safety
%     \item Safe resource management
%     \item Exception-based runtime safety
%     \item Stack safety
%     \item Program termination
% \end{itemize}

% \jinghao{The runtime exception handling is not necessarily an independent one,
% it actually covers some of the type safety (arrays and slices does runtime
% checks that may trigger exceptions)}

% While the use of Rust automatically provides expressiveness (as it is
%     Turing-complete), it does not supply the safety out-of-box, and the use of
%     Rust, especially unsafe Rust, can still exhibit undesired behaviors.
% We require all extension programs to be implemented \emph{only} in safe Rust.
% On top of that, we discuss how the safety properties from Rust can be leveraged
%     and applied to the context of kernel extensions to provide a safe
%     programming interface.


Rax employs a lightweight extralingual in-kernel runtime that checks safety properties
    that are hard for static analysis. % statically in a sound way.
% The runtime enforces program termination and safe stack unwinding to
%     handle runtime exceptions (e.g., Rust panics).
\new{The runtime enforces program termination, kernel stack safety, and safe
    handling of runtime exceptions (e.g., Rust panics).}



% no unsafe
% no internal features
%   compiler intrinsics
% no unstable features
%   core::simd (portable simd)
% no function that change the resource management behavior
%   core::mem::forget
%   core::mem::ManuallyDrop
% no alloc
% no std
% also restricts the use of third-party crates
\vspace{-8pt}
% \subsection{Language-based safety}
\subsection{Safe Rust in \projname{}}
\label{sec:lang_subset}
\vspace{-3pt}

% principles
% 3 categories cannot be supported
%   1. unsafe code
%   2. features that interfere with compiler's management of object lifetimes
%   3. features cannot be supported in kernel space
\projname{} only allows language features that are safe in the context of
    kernel extensions.
First, Rax excludes any \textit{unsafe} Rust code as it misses
    important safety checks
    from the Rust compiler and can voilate various safety properties (\S\ref{sec:background}).
Second, \projname{} also forbids Rust
    features that interfere with Rust's automatic management of object
    lifetimes, which include \texttt{\small core::mem::\{forget,ManuallyDrop\}}
    and the \texttt{\small forget} intrinsic.
\new{These features are considered safe in Rust but
    violate resource safety of kernel extensions by facilitating resource
    leakage.}
Third, language features that cannot be supported in the kernel extension context are
    excluded by \projname{}.
This group contains the \texttt{\small std}~\cite{rust-std} library and
    dynamic allocation support (not available in \texttt{\small no\_std} build~\cite{rust-nostd}), the
    floating point and SIMD support (generally cannot be used in kernel space),
    and the \texttt{\small abort} intrinsic (triggers an invalid instruction).
Note that dynamic allocation may be supported by hooking
    \texttt{\footnotesize alloc}~\cite{rust-alloc} crate to the kernel
    allocator.
\new{
We plan to explore the use of dynamic allocation in kernel extensions in
    future works (\S\ref{sec:discussion}).
}

% Enforcement
% unsafe: -Funsafe_code
% mem::forget and abort: clippy:disallowed_{methods,types}
% std and alloc: already not available
% SIMD and float: -Funstable_feature and remove from target features

To enforce the restrictions, \projname{} configures the Rust compiler and linter
    to reject the use of prohibited features.
Specifically, we set compiler flags~\cite{rustc-lint} to forbid unsafe code and
    unstable Rust features which includes SIMD and intrinsics.
For individual langauge items such as \texttt{\small core::mem::forget}, we
    configure the Rust linter~\cite{clippy-lints} to detect and deny their usage.
We further remove floating point support by setting the target
    features~\cite{rustc-codegen} in \projname{} compilation.
The \texttt{\small std} library and dynamic allocation are already unavailable
    in \texttt{\small no\_std} environment used by \projname{} and therefore
    warrant no further enforcement.

% This subset contains exclusively safe Rust, thereby eliminates safety issues
%     from the unsafe counterpart.
% \projname{}'s nature as a kernel extension requires it to be built as a
%     standalone program, and therefore it cannot use the
%     \texttt{\small std}~\cite{rust-std} crate in Rust.
% \projname{} does not support dynamic allocation, and the
%     \texttt{\small alloc}~\cite{rust-alloc} crate cannot be used, either.
% %The \texttt{\small alloc} crate cannot be used, either, due to the fact that
% %    \projname{} does not hook it to the kernel allocation function.
% %We do not hook \texttt{\small alloc} with the kernel allocation function and it
% %    cannot be used, either.
% The \texttt{\small core}~\cite{rust-core} crate remains largely available to
%     \projname{} programs, with a few exceptions:
% \projname{} prohibits the use of features in \texttt{\small core} that are
%     unstable or internal to the compiler and library, such as
%     SIMD~\cite{rust-core-simd}, which is not be used in the kernel, and
%     intrinsics~\cite{rust-core-intrinsics}, which are too low-level and hard to
%     be used correctly\footnote{
% Many of the intrinsics already have high-level wrappers in the
%     \texttt{\footnotesize core} library, e.g. atomics, which can still be used by the
%     program.}.
% We further restricts the usage of
%     \texttt{\small core::mem::\{forget,ManuallyDrop\}}~\cite{rust-core-mem-forget,rust-core-mem-manuallydrop}
%     because they lead to risks of resource leaks by not automatically invoking
%     object destructors.
% Lastly, \projname{} restricts the use of third-party crates other than the
%     \projname{} kernel crate, since it is challenging to ensure safety on these
%     crates.
% To enforce the requirements, we use linter options from the Rust
%     toolchain~\cite{rustc-lint,clippy-lints} to restrict language features, and
%     check the project cnofiguration file to eliminate third-party dependencies.

% The key challenge of developing Rax is ensuring safety properties of
%    Rax kernel extensions effectively and efficiently.
% In the remainder of this section, we discuss how each safety property is
%    realized in Rax.

% It also provides a custom Rust panic handler to support panic-based runtime
%    safety checks in Rust.
% The program links with the kernel crate at compile time and
% Rax runs in a
%    light-weight runtime environment implemented in the kernel, which provides
%    program termination and stack unwinding support.

% We now discuss how the language-based safety from Rust can be applied to the
%    context of kernel extensions to provide a safe programming interface.

\vspace{-4pt}
\subsection{Memory safety}
\label{principle:memsafety}
\vspace{-3pt}

Rax enforces extensions to access kernel memory safely.
There are two common memory access patterns, depending
    on the ownership of the memory region:
    (1) memory owned by the extension (e.g., a stack buffer) is sent to the kernel
    through helper functions,
    and (2) memory owned by the kernel (e.g., a kernel struct) is accessed by
    the extension.

\para{Memory owned by extensions.}
A Rax extension can allocate memory on the stack
    and send it to the kernel (e.g., asking the kernel to fill a
    stack buffer with data) via existing eBPF helper functions.
%An unsafe memory access could result in corruption of stack data and possibly
%    trigger a kernel crash if the return address is overwritten to a non-present
%    page.
Rax ensures no unsafe memory access and thus prevents stack buffer overflow and
    kernel crash (e.g., corruption of the return address on the stack).
%An unsafe memory access, for example, an out-of-bounds write to the on-stack
%    buffer, could result in corruption of stack data and possibly trigger a
%    kernel crash if the return address is overwritten to a non-present page.

% In eBPF, the verifier validates the memory region with its size via the helper function interface
%    at load time to ensure no erroneous access at runtime.
% The kernel operates on the memory region with the knowledge of
%    its bounds from the helper function argument, avoiding unsafe memory accesses.
%For memory buffers sent to the kernel through the helper function interface,
%    the corresponding size is also sent as an argument to the helper.
% Memory buffers sent to the kernel via the helper function interface have to be
%    paired with its size as an argument.
%The verifier, at program load time, checks to ensure that the size is exactly
%    that of the memory buffer.
% Specifically, the verifier verifies at load time that the size matches that of the
%    memory buffer.

Unlike eBPF that checks a memory region with its size of
    every invocation of helper functions,
in \projname{}, the strict type system of Rust already prevents unsafe access.
\projname{} leverages the generic programming feature of
    Rust~\cite{rust-generics} to ensure that the size sent through the helper
    function interface is always valid.
% In order to make sure that the size sent to the kernel is always correct, which
%     is vital for the correctness of memory access from the kernel, we leverage
%     the generic programming support of Rust.
For helper functions that take in pointer and size as inputs,
    the \projname{} kernel crate creates an
    adaptor interface that parametrizes the pointer type as a generic type parameter.
The interface queries the size of the generic type from the compiler
    and invokes the kernel interface with this size as an argument.
Since Rust uses {\it monomorphization}~\cite{rustc-monomorphize}, the concrete
    type and its size are resolved at compile time, adding no runtime overhead.
In this way, the size is guaranteed to match the type statically and the
    kernel will never make an out-of-bound access.
This works for both scalar types and array types.
We use Rust's {\it const generics} to allow a constant to be used as a
    generic parameter~\cite{rust-generics} to encode array lengths.

\para{Memory owned by the kernel.} The kernel can provide
    extensions with a pointer to
    kernel memory (e.g., map value
    pointers and packet pointers).
The extension must not have out-of-bound memory access. %, as doing so risks corrupting kernel memory.
%In eBPF, for accesses on pointers with a static size, e.g. map value pointers,
%    as maps store the size of its value types, the verifier can independently
%    verify the validity.
In eBPF, the verifier checks uses of kernel pointers with a static size,
    e.g. map value pointers (maps store the size of values);
for pointers without a static size like packet data pointers, the verifier
    requires extensions to explicitly check memory boundaries.

In \projname{}, pointers with static sizes are handled through the Rust type
    system.
The kernel map interface of \projname{} encodes the key and value
    types through generics and returns such pointers to extension programs as
    safe Rust references.
%The type system forces the pointer to be a safe Rust reference of
%    the particular type.
%Pointers referring to a memory region without a static size are generally
%    dynamic-sized buffers.
To manage pointers referring to dynamically sized memory regions,
    the \projname{} kernel crate abstracts such pointers into a Rust
    \emph{slice} with dynamic size.
Rust slice provides runtime bounds checks (\S\ref{principle:eh}), which allows
    the check to happen %automatically
    without explicit handling by the
    extension.

% dynptr
%   ptr to a dynamically sized data region with metadata (size, type, r/w)
% Differences:
%   - access to the data region must have a known size
%   - accessing through read/write helpers does not provide zero copy
%     implementation
%   - obtained slice with data or slice helpers still requires explicit size
%     check from program

Rust slices are in principle similar to \texttt{\small dynptr}
    in eBPF~\cite{ebpf-dynptr-lwn}, but provide more flexibility.
eBPF \texttt{\small dynptr}s are pointers to dynamically sized data regions
    with metadata (size, type, etc); however,
% Extensions can access \texttt{\small dynptr}s via helpers and kfuncs, or obtain a
%    data slice to operate on it directly.
    access to the \texttt{\small dynptr}'s referred memory must be of a static size.
Rust slices allow dynamically sized access to the underlying
    memory, benefiting from its runtime bounds checks.
Moreover, the \texttt{\small bpf\_dynptr\_\{read,write\}} helpers do not
    implement a zero-copy interface available in Rust slices.
While \texttt{\small bpf\_dynptr\_\{data,slice\}} helpers
    allow extensions to obtain data slices without copying, they
    again require explicit checks of the bound of the slice.
As a tradeoff, eBPF \texttt{\small dynptr}s avoids runtime overheads of
    dynamic bounds checks, which we find negligible in our evaluation (\S\ref{eval:macro}).

\vspace{-4pt}
\subsection{Extended type safety}
\vspace{-3pt}

Rax extends Rust's type safety to allow extension programs to safely convert a byte stream
    into typed data.
% Kernel extensions may contain certain paradigms that are beyond the safe
%    type system of Rust.
% One challenge is to allow extension programs to safely reinterpret a stream
%    of bytes into useful data.
The pattern is notably found in networking use cases, where extensions need
    to extract the protocol header from a byte buffer in the packet as a struct.
Safety of such transformations is beyond Rust's native type safety
    because they inevitably involve unsafe type casting.
% For example, a XDP program using direct packet access might need to extract
%     the ethernet header information from the bytes in the packet.
eBPF allows pointer casting;
% Currently, eBPF allows the program to freely interpret the packet data into
%    other data types via pointer casting.
the verifier ensures: (1) the program does not make a
    pointer from a scalar value, and (2) the new type fits the memory boundary.

\projname{} also enforces the above two properties so that
    the reinterpreting cast (dubbed ``transmute'' in Rust) is safe.
\projname{} extends Rust's type safety to cover such casts.
To do so,
% In the case of Rust, the reinterpret cast (dubbed ``transmute'' in Rust) is an
%     unsafe operation, particularly because Rust does not prevent making
%     pointers from scalar values.
% To allow extension programs to safely reinterpret the bytes into useful
%    data types,
\projname{} defines a set of primitive scalar types that are
    considered safe as targets for casting.
\projname{} requires the target type of casting to be of either one of the safe types
    or a structure type in which all the members are of the safe types.
The safe types are specified by implementing the \texttt{\small Rax::SafeTransmute}
    trait, which is sealed and only implementable from within the kernel crate.
We use the \emph{procedural macros}~\cite{rust-proc-macro} feature of Rust to enforce
    this constraint and generate the safe transmute interface at compile time on
    extended types.
%The developer is still responsible for using the correct scalar types (e.g.,
%    endianness).
Under the safe-transmute contraints, mismatched scalar types can only cause
    logical errors, but do not constitute safety violation.

% Like conventional C macros, proc-macros performs transformation on the program,
%     albeit on the abstract syntax tree level.
% \mvle{i suggest cutting the rest of the paragraph and putting it in appendix.}
% Our proc-macro, when applied on a structure type, generates code that tries
%     to treat each field of the structure as an instance of
%     \texttt{Rax::SafeTransmute} using Rust trait bounds, followed by the actual
%     transmute operation to perform the unsafe cast.
% If one of the fields in the structure does not implement
%     \texttt{Rax::SafeTransmute}, the Rust compiler will issue a compile error.
% At the same time, if the program tries to directly transmute the bytes into a
%     structure without using the proc-macro, the compiler will also emit an
%     error because transmute belongs to unsafe Rust, which is forbidden in
%     \projname{} programs.
% Since proc-macro transformations happen after the linting of unsafe operations,
%     the transmute code generated by the proc-macro will not be rejected and,
%     therefore, allows programs to perform transmutes in a safe, and controlled
%     way.
% \jinghao{Shall we remove this sentence, people may ask whether programs can
% use proc-macros to get around the safe Rust requirement}

\vspace{-4pt}
\subsection{Safe resource management}
\vspace{-3pt}

%Executing in the kernel,
Rax extensions are ensured to acquire and release
    resources properly to avoid leaks of kernel resources (e.g., refcounts
    and spinlocks).
Different from eBPF where the verifier checks all possible code paths
    to ensure the release of acquired resources,
% Some kernel helper functions return ``referenced'' kernel resources that require
%    explicit release after use through the paired helper function calls.
% Failing to do so will result in leakage of kernel resources such as .
% In eBPF, some kernel helper functions returns kernel resources that requires
%     explicit release after use (e.g., reference counts of kernel objects,
%     locks).
\projname{} uses Rust's Resource-Acquisition-Is-Initialization
    (RAII) pattern~\cite{rust-raii}---for every kernel resource
    a Rax extension may acquire, the \projname{} kernel crate defines an RAII wrapper type
    that ties the resource to the lifetime of the wrapper object.
% \new{
% The same approach is also adopted by other Rust-based operating system and
%    kernel modules~\cite{rust-for-linux-doc,theseus}.
% }
% \tianyin{Is this the same as Rust kernel module (see the review)? If not, what's the difference?}

For example, when the program obtains a spinlock from the kernel, the
    \projname{} kernel crate constructs and returns a \emph{lock guard}.
The lock guard implements the RAII semantics through the
    \texttt{\small Drop} trait~\cite{rust-drop} in
    Rust, which defines the operation to perform when the object is destroyed.
In the case of lock guard, its \texttt{\small drop} handler releases the lock.
\new{
\projname{} uses compiler-inserted \texttt{\small drop} calls at the end of
    object lifetime during normal execution, and implements its own resource
    cleanup mechanism (\S\ref{principle:eh}) for exception handling.
}
The use of RAII automatically manages kernel resources to ensure
    safe acquisition and release.
Extension programs do not need to explicitly release the lock or drop the lock
    guard.
% Instead, the compiler inserts an implicit \texttt{\small drop} at the end
%    of the current scope, which effectively releases the lock when the lock
%    guard goes out of scope.

\vspace{-4pt}
\subsection{Safe exception handling}
\label{principle:eh}
\vspace{-3pt}

While certain Rust safety properties are enforced statically by the compiler,
    the others are checked at runtime and their violations trigger exceptions (i.e., Rust panics).
%    which is different from eBPF.
To handle exceptions in userspace, Rust uses the Itanium exception handling ABI~\cite{itanium-abi} to
    unwind the stack.
A Rust panic transfers the control flow to the stack unwinding
    library (e.g., llvm-libunwind), which backtracks the call stack and executes
    cleanup code and catch clauses for each call frame.
Unfortunately, this ABI is unsuitable for kernel extensions:
% \tianyin{How is it different from Theseus?}
% for the
%    following reasons as mentioned by~\cite{untenableVerification}:
%When an exception is triggered, the control flow is transferred to the Rust
%    panic handler in its standard library, which in turn calls into the unwind
%    library to perform stack unwinding and resource cleanups for each stack
%    frame.
%However, the Itanium ABI is complex and not suitable for kernel extensions,
%    making exception handling a challenge in \projname{} extension programs:
%\jinghao{Took these directly from the HotOS paper, shall we paraphrase?}
\begin{packed_itemize}
%     \item The Itanium ABI-based exception handling is too complicated, as the
%         userspace unwind libraries are not direcly usable.
    \item Unlike in userspace
        where failures during stack unwinding
        crash the program,\footnote{Theseus~\cite{theseus} implements stack unwinding in the kernel.
        But, it assumes that unwinding never fails; faults in unwinding result in kernel failures.}
%        \jinghao{it looks like is
%        unwinding fails it would just stop unwinding and directly kill the
%        failed task. Although it does not kill the kernel, this means incomplete
%        cleanups.}}
    stack unwinding in kernel extensions cannot fail---kernel
        % Failures during unwinding, which are permissible in userspace, cannot
        extensions must not crash the kernel and must not leak kernel resources.
%    \item ABI-based unwinding typically requires dynamic allocation, which
%        creates challenges for extensions in interrupt contexts, in which an
%        allocator may not be available~\cite{bpf-mempool-lwn}. \jinghao{I'm
%        thinking about removing this one since bpf now has an allocator.}
    \item Unwinding generally executes destructors for all existing objects on
        the stack, but executing untrusted, user-defined destructors (via the
        \texttt{\small Drop} trait~\cite{rust-drop} in Rust) is unsafe.
\end{packed_itemize}
Rax implements its own exception handling framework with two main components: (1) graceful exit
    upon exceptions, which resets the context, and (2) resource cleanup to
    ensure release of kernel resources (e.g., reference counts and locks).

\para{Graceful exit.}
To ensure a graceful exit from an exception, \projname{} implements a small
    runtime (Figure~\ref{fig:eh-overview}) in the kernel, which
    consists of a program dispatcher, a panic handler, and a landingpad.
The dispatcher takes the duty of executing the extension program
    (like the eBPF dispatcher).
It saves the stack pointer of the current context into per-CPU
    memory, switches to the dedicated program stack (\S\ref{principle:stack}),
    sets the termination state (\S\ref{principle:termination}), and
    then calls into the program.
If the program exits normally, it
    returns to the dispatcher, which switches the stack back and clears the
    termination state.
Under exceptional cases where a Rust panic is triggered, the panic handler
    releases kernel resources currently allocated by the extension, and
    transfer control to the in-kernel landingpad to print
    debug information to the
    kernel ring buffer and return a default error code to the kernel.
%     \new{and set a default return value depending on the
%    program type}.
Then, the landingpad redirects control flow to a pre-defined label
    in the middle of the dispatcher, where it restores the old value
    of the stack pointer from the per-CPU storage.
This effectively unwinds the stack and resets the context as if the extension returned successfully.
% We implement the program dispatcher function with panic handling in the kernel
%     in 28 lines of x86 assembly code.


\para{Resource cleanup.}
Correct handling of Rust panics requires cleaning up resources acquired
    by the extension.
However, static approaches that rely on the verifier to pre-compute resources
    to be released during verification
    (e.g., object table in~\cite{dwivedi-sosp24}) do not apply to Rax due to the
    \gap{}.
% Rax aims to avoid
%    artificial constraints for static verification (e.g.,
%    resources acquired in a loop iteration must be released by the end of the
%    iteration~\cite{dwivedi-sosp24}), as they exhibit the \gap{}.
% \jinghao{I think we need to remove this sentence, since now we say we only support single lock.}
%    resource acquisition \new{without additional constraints
%    other than that of Rust language}). \tianyin{why more flexible?}
%    \jinghao{KFlex still requires that, in a loop, the acquisition and cleanup
%    of a resource must happen in the same iteration. (Last paragraph in their
%    3.1). This is what allows them to statically compute the obj table}
% KFlex~\cite{dwivedi-sosp24} uses static "object table" approach, where the
%    list of resources to be released is generated .
% This is not suitable for \projname{}, as \projname{} is more relaxed on
%    resource acquisition, which makes it impossbile to static compute the list
%    of resources to be released.

%Light-weight mechanisms can be effective for resource cleanup in \projname{}.
Our insight is that extensions can only obtain
    resources by explicitly invoking helper functions. %; so, only these resources need to be released.
So, Rax records the allocated kernel resources
    during execution in a per-CPU buffer, which is in principle like the global
    heap registry in~\cite{redleaf}.
% \jinghao{Removed the static buffer part here, since it attracts reviewer's
% attacks. But at the same time, it is also hard for us to say it's growable,
% as that will get scrutiny on the memory alloc part...}
%Our current implementation supports up to 64
%    instances of kernel resources during a single run.
Upon a panic, the panic handler takes the responsibility to correctly
    release kernel resources, which involves traversing the
    buffer and dropping recorded resources.
% performing cleanup for each of the recorded resources.

\begin{figure}
    \includegraphics[width=0.95\linewidth]{figs/exception_handling.pdf}
    \centering
    \caption{Exception handling control flow in \projname{}}
    \label{fig:eh-overview}
    \vspace{-5pt}
\end{figure}




% \jinghao{It seems that nesting should be put somewhere, due to the fact that
% these per-CPU tricks depend on no-nesting.}
\new{
We implement the cleanup code as part of the panic handler in the \projname{}
    kernel crate, as it
    is responsible for coordinating helper function calls
    that obtain kernel resources.
% In this way, the resource cleanup is completely transparent to the extension
%     programs, adding no additional programming burden like the Itanium ABI.
Implementing the cleanup mechanism in the kernel crate ensures safety:
    as the code is called upon panic, it must not trigger deadlocks or yet
    another Rust panic to fail panic handling.
The careful design of the \projname{} kernel crate frees the cleanup code and
    \texttt{\small drop} handlers of locks and panic-triggering code.
% We carefully implement the cleanup code and \texttt{\small drop} handlers in the
%     kernel crate such that they do not trigger panics or hold locks, which may
%     hinder successful panic handling.
Kernel functions invoked by such code may still hold locks internally, but they
    are self-contained and do not propagate to \projname{} (deadlocks in kernel
    functions is out of the scope of \projname{}).
% For this reason,
\projname{} does not execute user-supplied \texttt{\small drop} handlers
    upon panic, as they are not guaranteed to be safe under panic handling
    context.
}
%and programs cannot allocate resources without helper function
%    calls.

\projname{} implements a crash-stop failure model---a panicked
    extension is removed from the kernel.
Any used maps and other \projname{} extensions sharing the maps
    will also be removed recursively.
% \mvle{should define what it means to be associated, e.g., different instances or have access to same resources}
This prevents extensions
    sharing the maps from running in a potentially inconsistent
    state---exception handling in \projname{} already ensures the kernel is
    left in a good state.

\vspace{-4pt}
\subsection{Kernel stack safety}
\label{principle:stack}
\vspace{-3pt}

Kernel extensions should never overflow the kernel stack.
% One unique safety requirement that kernel extension programs face is the
%     usage of kernel stack.
Unlike userspace stacks which grow on demand with a large maximum size,
    the stack in kernel space has a fixed size (4 pages on x86-64).
% Overflowing the kernel stack may result in memory corruptions or kernel panics.
The eBPF verifier checks stack safety by calculating stack size
    via symbolic execution.
However, it is reported that stack safety is broken in eBPF due to the difficulties
    of statically analyzing indirect tail calls~\cite{ebpf-stackoverflow}
    and uncontrolled program nestings~\cite{chintamaneni-ebpf24}.\footnote{Rax currently does not
    support program nesting (same as eBPF)}
%    even in eBPF it is unclear how to support nesting with safety.}
% \tianyin{how does KFlex does that? Is it also broken?}
% \jinghao{This is not explicitly mentioned in the paper. Based on my
%    understanding of the work, only heap access and termination is split out
%    and use SFI instead, so I would say the stack is still handled by the
%    verifier and it should be still broken.
% }

Our insight is that stack safety can be enforced
    at compile time to avoid runtime overhead if the extension program has no indirect or
    recursive calls, as %the global call graph is a directed acyclic graph (DAG)
    the stack usage can be statically computed.
Otherwise,
% When the program does employ indirect or recursive calls,
    it is easy to check stack safety at
    runtime. %when the program does employ indirect or recursive calls.
\projname{}, therefore, takes a hybrid approach and selects between static and dynamic checks based on the situation.
%    utilizes static checks for programs without indirect or recursive calls,
%    and runtime checks for programs that have such calls.

\para{Static check.}
The static check is done by a \projname{}-specific compiler pass (\S\ref{sec:impl}).
% \mvle{forward reference to implementation}
%For each program being compiled, the \projname{}-specific pass in the compiler
\new{
If the extension has no indirect or recursive calls,
    its total stack usage can be calculated by traversing its global static
    callgraph and sum up the size of each call frame.
% The path with the highest stack usage is the total stack usage of the program.
We turn on fat LTO and use a single Rust codegen unit~\cite{rustc-codegen} for
    \projname{} programs to ensure the compiler always has a global view across
    all translation units.
}
% If the total stack usage of the program exceeds total amount of stack
%    available, the \projname{} compiler pass will generate an error and reject
%    the program.

\para{Runtime check.}
For extensions with indirect or recursive calls, it is hard to calculate the
    % path with the highest
    stack usage from the callgraph due to the
    presence of unknown edges (indirect calls) and cycles (recursive calls).
%  are hard to check  for stack usage statically, as is the case in the eBPF verifier.
Under these cases, \projname{} performs runtime checks.
The \projname{} compiler pass first ensures each function in the program takes
    less than one page (4K) of stack.
This is more relaxed than the frame size warning threshold (2K) in Linux
    and ensures enough stack to handle Rust panics.
% \ayushb{A supporting argument on why the function size is being limited to one page might be helpful here, the reasoning behind this is not known to everyone and might be non-trivial assumption.}
Before each function call in the extension, the compiler inserts a
    call to the \texttt{\small rax\_check\_stack} function from the kernel crate to check the
    current stack usage: if the stack usage exceeds the
    threshold, it will trigger a Rust panic and terminate the
    program safely (\S\ref{principle:eh}).

% In order for \texttt{\small rax\_check\_stack}
To manage stack usage of Rax extensions effectively, \projname{}
    implements a dedicated kernel stack for each
    extension.
The dedicated stacks are allocated per-CPU and virtually mapped at
    kernel boot time with a size of eight pages.
% the same size as the kernel IRQ and task stacks.
Before executing a Rax extension,
    the dispatcher (Figure~\ref{fig:eh-overview}) saves the stack
    pointer of the current context, and
%In the dispatcher function (Figure~\ref{fig:eh-overview}), before calling into
%    the \projname{} program, the stack and frame pointers of the current
%    context are saved.
    then sets the stack and the frame pointer
    (already saved with other callee-saved registers) to the
    top of the dedicated stack.
When the extension exits, the original stack and frame pointers are restored.
% Upon exit of the extension, the original stack and frame pointers are restored, no
%    matter whether a exception is triggered by the extension.

%\projname{} sets the stack usage threshold to be two pages less than the
%    total stack available, with the following considerations:

\projname{} sets the stack usage threshold to be four pages for extension
    code; it reserves the next four pages with following considerations:
(1) helper functions are not visible at compile time but they
    also account for stack usage during execution;
%    giving extra spaces accommodates helper functions, and
    we use four pages as the de facto stack size used by the kernel itself, and
(2) since stack usage of each function is limited to
    one page of stack, in the worse case, the remaining stack space is at least
    three pages when \texttt{\small rax\_check\_stack} triggers a Rust panic.
\new{
Since the panic handler is implemented in the kernel crate and does not change
    with programs, this worse-case guarantee empirically leaves enough space for
    panic handling and stack unwinding.
}
\projname{}'s dynamic approach achieves stronger stack safety than that of
    eBPF.

\vspace{-4pt}
\subsection{Termination}
\label{principle:termination}
\vspace{-3pt}
% A bounded program runtime is important for kernel safety
%   - a potentially long running program can hold the CPU and cause kernel
%     lockups
% eBPF handles this by imposing verification limit (ref S3)
%   (Side note:
%    First, this is really ``bounded runtime'' rather than termination, because
%      a long-running program that eventually terminate is almost equally bad
%    Why would programs ever hit that limit if they are supposed to have an
%    acceptable runtime? Is it because of these two reasons:
%      1. The verifier misses some key information that can reduce the search
%         space drastically, as is the case of unbounded loops?
%      2. If the program is meant to execute that many instructions (current
%         limit is 1M), is it because the current limitation is still too small
%         or is it that the program is badly implemented and actually runs
%         longer? (Also, how long would 1M eBPF instructions run with
%         interpretation and JIT?)
%   )
%   - A program that goes over the limit gets rejected, no matter whether it will
%     actually run long
%   - creates usability issues
%   - previous works has also demonstrated ways of creating long running programs
%     without going over the limit (cite raj-lpc and jinghao-hotos)
%
% Given the ineffectiveness and usability issues associated with the static
%   verification approach, Rax uses a dynamic mechanism that interrupts and
%   terminates programs.
% When a program goes over its time limit, it will be terminated.
% The dynamic termination in Rax limits the runtime of the program through a
%   timer.
% When the timer expires, it issues an IPI to the CPU the program is running.
% The IPI effectively suspends the program and saves its registers to the stack.
% Inside the IPI handler, the timeout handler for Rax is executed, which
%   modifies the instruction pointer stored on the stack to the panic handler
%   of rax programs.
% After returning from the IPI the program will be executing the panic handler
%   to gracefully exit.
%
% Challenge: no termination in helpers/panic handlers
%
% We use a per-CPU flag to solve this

Termination is an important property of kernel extensions.
% critical to the
%    safety of the kernel, as non-terminating extension programs could hold the
%    processor for a long time and cause kernel lockups.
% }
%eBPF ensures termination by imposing a static limit on
%    the number of instructions the verifier explores. % go through.
% eBPF ensures termination by disallowing back edges in the program and by
%    imposing a static limit on the number of instructions the verifier explores.
In eBPF, an extension with a back edge or exceeds the instruction limit will be
    rejected, regardless whether it eventually terminates. %no matter whether the program will actually run for a long time.
% Such practices create many false positives and greatly hinders the
%    expressiveness of extension programs.
%is one of the main sources of
%    usability issues in eBPF (\S\ref{motivation:restructure}).
KFlex~\cite{dwivedi-sosp24} lifts the back edge restriction by inserting
    cancellation points in eBPF bytecode on all back edges during
    verification, which triggers termination at runtime.
However, back edge analysis is non-trivial outside
    eBPF bytecode and is unreliable for general Rust programs.
% poses challenges for \projname{}, which does not rely on the eBPF bytecode.
%\ayushb{eBPF static verifier is able to do back-edge analysis and thus prevent loops into the program, giving up on that poses issues specially for programs executing in non-maskable interrupts. This might pose a problem from the usability perspective itself, something that we are trying to solve. Maybe we can consult with Xudong as well on how big of a problem can this be.}
%\jinghao{Thinking about this again, yes we lose some analysis, but I don't think
%    the problem with hardirq has anything to do with the usability issues we try
%    to solve -- we never reject a correct program (and I think a
%    spanning-tree-like algorithm might make synchronous instrumentation possible.
%    We can keep the async way for anything that runs outside hardirq)}

%Previous works~\cite{ebpf-termination,untenableVerification} have also
%    demonstrated creation of long-running eBPF programs without going over the
%    verification limits, further weakening the runtime guarantee from the
%    verifier.
% \jinghao{Removed the discussion on exploiting long-running eBPF programs, since
%    1) I think termination (more relaxed than bounded prog runtime) is what we
%    are looking for, and 2) reviewer B has problems with our interpretation of
%    the verifier limits (``nothing to do with the runtime limits of the program'')
%    so I think the only thing this limit tells us is about the termination
%    property (programs within the verifier limit is guaranteed to terminate).}

% This is still missing the discussion of the design decisions, specifically:
%   Why hrtimer
%     because software timer wheel does not interrupt softirq
%   Why not arming timer at program entry rather than a periodic timer
%     exceesive overhead on hot path for timer setup (as pointed out in reviews)
%   Why not just use a single timer for all CPUs?
%     doing so requires sending IPIs to other CPUs, and sending them from
%     hardirq risks kernel deadlock
\projname{} employs a runtime that
    interrupts and terminates extensions that run for too long.
% \jinghao{Need to discuss: how should we argue that this leads to fewer FPs and is more usable?}
\projname{} limits the run time of extensions by
    leveraging kernel timers as watchdogs.
% A program will be terminated if it reaches a timeout implemented by the timers.
% Design decisions on how to leverage the hrtimer
Rax builds the runtime on the high resolution timer
    (\texttt{\small hrtimer}) subsystem in Linux~\cite{linux-hrtimer}.
Since \texttt{\small hrtimer} callbacks execute in hardware timer interrupts,
    they are capable of interrupting the contexts in which most extensions
    execute (soft interrupts and task
    context~\cite{elce-16-chaiken}).
Since hardware timer interrupts are periodically raised
    by the processor, regardless whether an \texttt{\small hrtimer} is present,
    executing timer callbacks in this existing hardware timer interrupts adds
    no extra interrupt or context switch, keeping the
    watchdog overhead minimal.

Rax sets one timer for each CPU to
    avoid inter-core communication, in contrast to using a
    single, global timer to handle programs from all CPUs.
Each timer only needs to monitor extensions running on the core.
Rax arms the timers at kernel boot time, which are triggered periodically
    with a constant timeout, and re-armed each time after
    firing.\footnote{\new{Disarming the timer when no extension is running saves
    CPU cycles, but
%     Arming the timer right before starting each extension
    incurs high
    overhead due to timer setup on the hot path of extension execution,
    especially for frequently triggered extensions (e.g., XDP
    extensions~\cite{cilium-docs})}}

\projname{} implements its watchdog logic in the timer handlers.
When a timer fires, its handler
%be executed in a hard interrupt (hard-IRQ)
%    on the current CPU, which
    suspends any soft interrupt or task context, and saves its
    registers.
The handler then checks the current CPU on whether the termination timeout
    of the \projname{} extension in the stopped context has been reached.
This is done by comparing the extension start time (stored as a per-CPU state as
    shown in Figure~\ref{fig:eh-overview}) with the current time.
% If the program exceeds the runtime threshold, an inter-processor interrupt (IPI)
%     is sent to the CPU the program is running on.
% This IPI effectively suspends the program and pushes its registers onto the
%     stack.
% Inside the IPI handler, the timeout handler of \projname{} is
%    executed, which sets the saved instruction pointer register to the
%    panic handler of the program.
If the extension exceeds the threshold, the timer handler overwrites the
    saved instruction pointer register to the panic handler (\S\ref{principle:eh}).
After returning from the timer interrupt, the extension executes its
    panic handler, which cleans up kernel resources and gracefully exits.
\projname{} sets both the timer period and runtime threshold to
    % to 21 seconds, which is
    the default RCU CPU stall timeout (Rax
    extensions run in RCU locks as they use eBPF hook points). % as they reuse the same hook points of eBPF.
% The termination logic uses the Linux kernel's Inter-Process Interrupt (IPI) mechanism
% to raise an interrupt on the target \projname{} program's CPU.
% Depending on the use-case, the IPI can be triggered by an operator or a timer within the system
% that is configured to notify when the \projname{} exceeds a certain runtime threshold.
% Note that we are assuming the availability of a free CPU for an operator to be able to invoke
% an IPI.
% In uniprocessor machines, where the only CPU will be busy running the extension, the operator
% won't be able to issue termination request and has to rely on installing timers.
% We find this limitation acceptable due to the current cloud infrastructure predominantly being SMP.

% To safely terminate a \projname{} extension, we need to ensure the following :
% Note that a Rax extension should not be terminated while executing a kernel helper
%    function or the panic handler, as doing so disrupts internal bookkeeping of
%    the kernel (e.g. acquired resources) or safe exception handling.
\projname{} defers termination when the extension is
    running kernel helper functions to avoid disrupting the kernel's internal resource bookkeeping;
    it also does not terminate an extension if it
    is in the panic handler. % on the exit path.
\projname{} uses a per-CPU tristate flag to track the state of an
    extension: % (Figure~\ref{fig:rax-termination}).
    (1) executing extension code, (2) executing kernel helpers or
    panic handlers, and (3) termination requested.
A helper call changes the state from 1 to 2.
When executing the timer handler, if the flag is at state 2,
%    which indicates the program is under a context that cannot be safely terminated,
    the termination handler modifies it to state 3 without
    changing the instruction pointer.
When a helper returns, if the flag is at state 3,
    the panic handler is called to gracefully exit. % the extension.

\new{
A corner case of this design is deadlock. Since spinlock acquisition in
    \projname{} is implemented by a kernel helper function, a deadlocked program
    will never return from the helper, and therefore will never be
    terminated properly.
\projname{} follows eBPF's solution toward deadlocks, where a program can only take one lock at a time.
This is achieved by using a per-CPU variable to track whether the program
    currently holds a lock---a program trying to acquire a second lock will
    trigger a Rust panic.
We note that if the ability of holding multiple locks at the same time is
    desired, the kernel spinlock logic can be modified to check the termination
    state of \projname{} programs during spinning and terminate a deadlocked
    program accordingly.
}
% \begin{enumerate}
%     \item A \projname{} program should never be terminated while executing a
%         kernel helper function or the panic handler, as doing so disrupts
%         internal bookkeeping of the kernel (e.g. acquired resources) and safe
%         exception handling process of \projname{}.
%         This is neccesary to ensure kernel objects acquired during a helper call
%         are freed.
%     \item Kernel resources allocated within the extension program cannot be
%         left unreleased and cause resource leaks.
% \end{enumerate}

% The raised interrupt handler first detaches the \projname{} program from its hookpoint to prevent
% further invocation.
% The handler then changes the saved registers(in the interrupt stack) from the \projname{} context
%  to point to the \projname{} panic handler(section \ref{principle:eh}).
% The CPU returns the execution to the panic handler which performs the cleanup of
% any kernel objects that were live at the time of termination.
% To address the case when the target \projname{} program could be inside a helper/panic handler,
% \begin{figure}
%     \includegraphics[width=1.0\linewidth]{figs/BPF_termination_state_diagram.pdf}
%     \centering
%     %\vspace{-10pt}
%     \caption{Termination state diagram for \projname{} extensions}
%     \label{fig:rax-termination}
%     %\vspace{-30pt}
% \end{figure}


% This mechanism is used to defer a panic invocation until the end of a helper execution.
% \jinghao{Shall we have a state diagram?}

% Rax timeout check runs in hardirq, as such it cannot interrupt programs
% running in hardirq.
% No protection for these programs
% could still choose eBPF, as Rax and eBPF are not mutually exclusive.
\para{Limitation.}
\projname{} uses
    hard interrupts, and thus cannot
    interrupt extensions that are already executing in hard or
    non-maskable interrupts~\cite{elce-16-chaiken} (e.g., hardware perf-event programs).
Such extensions are not targeted by Rax, as they are supposed to be small, simple, and
less likely to encounter the \gap{}.
%better fit eBPF's model.
%\ayushb{Good Point for us as well: Limitation of async for hard IRQ, this can be justified as a tradeoff of feature/safety vs performance/usability as well! KFlex does in sync but having async in our case could be better for performance aspect.}
%\jinghao{Actaully this turns out to be not that easy to argue --- we need to track
%    helper executions through the per-cpu flag, which requires accessing it
%    both before and after a helper call, and it is hard to reason about the
%    number of helper call vs the number of back edges in the execution.}
Note that Rax extensions and eBPF extensions are not mutually exclusive and
    can co-exist.
%\mvle{I feel this is a bigger point that should be surfaced in the beginning somewhere
%as we are saying some simple programs should actually still be written in eBPF.}
%\ayushb{Having the co-exist argument is something that should be added in intro as well, since this highlights the major point that we are not arguing removing the current verifier itself.}
%\jinghao{The following paragraphs are tentative --- I am okay with not adding
%    these if these are too much}
%\mvle{I think they should be included but should be dramatically shortened.
%Remove the details.}
%\new{
%\projname{} currently does not terminate a program if it is already interrupted.
%The situation can happen when a program under task context is interrupted by a
%    soft interrupt, which is in turn interrupted by the \projname{} timer.
%\projname{} could correctly determine that a program is executing on the CPU
%    (from the program pointer check) and the context interrupted by the timer is
%    not the program (from the stack pointer check).
%However, the lack of access to the program regsters will hinder the termination
%    effort, and currently, \projname{} has to wait for a triggering of the timer
%    that directly interrupts the program itself.
%}

Moreover, the termination of a timed-out \projname{} extension can be delayed
    if the extension is already interrupted by another event when the timer
    triggers (the registers will not be available to the timer
    handler). \projname{} needs to wait for a triggering of the timer that
    directly interrupts the extension.

%\new{
%At the same time, due to \projname{}'s use of the eBPF spinlock helper,
%    deadlocked programs cannot be correctly terminated.
%\projname{} defers termination if a program is executing kernel
%    helpers and waits for the program to return before it can terminate.
%    However, because the spinlock acquisition logic resides in the kernel,
%    deadlocked programs would spin in the kernel without returning.
%This effectively prevents deadlocked programs from being terminated.
%While \projname{} currently does not implement a solution, we envision two
%    possible solutions 1) use a custom spinlock that work entirely in
%    \projname{} without entering the kernel, the same solution is employed by
%    KFlex~\cite{dwivedi-sosp24}, and 2) add the termination flag check to the
%    spinning logic so that the extension program stop spinning immediately after
%    termination is requested.
%}


% These programs would recieve no termination guarrantee from the \projname{}
%    runtime.
% Developers that aim for such guarrantee could still use eBPF for their
%    use case, as Rax and eBPF are not mutually exclusive, although doing so
%    means handling the \gap{}.
