% What is TEE
\IEEEPARstart{T}{\lowercase{rusted}} Execution Environments (TEEs) provide strong security protection for software programs.
TEEs create an isolated memory space that remains inaccessible to the normal world (untrusted environments), even if the device is compromised.
By putting sensitive operations (e.g., encrypted data storage, fingerprint verification, and remote attestation) in the TEE, the security and integrity of these operations can be guaranteed.
Operations within the TEE are inaccessible to the normal world, minimizing potential security issues such as data leakage~\cite{zhang2024no,liu2022extending,zhang2020privacyscope}, unauthorized access~\cite{9664230,han2023mytee,tkdeMaLLXJSM24,wang2023tee,ait2025tee}, code tampering~\cite{ahn2020diskshield,ZhaoM19ndss}, and malicious attacks~\cite{StathakopoulouR21,zhang2019softme}.
Providing TEE support has become a standard practice for various hardware platforms using different architectures (e.g., Intel~\cite{Intel_SGX,Intel_TDX}, AMD~\cite{AMD_SEV}, ARM~\cite{ARM_TrustZone}).

% This development facilitates developers in implementing enhanced protection for their programs.

% Why developers do not use TEE
Unfortunately, despite the advantages offered by TEEs and the wide support provided by mainstream platforms, adapting existing programs to leverage TEE protections is non-trivial.
This process requires extensive domain knowledge and manual intervention for two primary reasons:
(1) One reason is that TEEs usually have limited resources, such as small memory sizes.
For instance, Intel SGX~\cite{Intel_SGX} restricts the memory size of its TEE to a maximum of 128 MB, preventing complete programs from being loaded in TEEs.
Considering that not all code in a program is security-sensitive, it is unnecessary to port the entire program to the TEE.
Therefore, to optimize security while minimizing the trusted computing base and reducing both the potential attack surface and performance overhead, developers should focus on porting only the critical code that involves sensitive operations to the TEE.
However, identifying critical code requires substantial expertise in both cybersecurity and TEEs, which poses an additional challenge for developers~\cite{zhang2024no,lind2017glamdring}.
(2) Another reason is the constrained execution environment for programs.
Most TEEs are designed to run low-level code (e.g., C or Rust) compiled directly to machine instructions, rather than high-level managed languages (e.g., Java or Python) that require dedicated runtime environments.
The overhead of securely supporting managed runtimes within the constrained environment of a TEE makes it challenging to adapt these high-level languages.
Additionally, even for low-level code, the APIs and system calls available in TEEs may differ from those in the normal world (e.g., Intel SGX does not support timer, file I/O, and multiple threads), requiring modifications to execute correctly in TEEs.

% Some solutions
Several methods have been proposed to facilitate the utilization of TEEs~\cite{wuLCZWYLS24tc,miao23icse,zhang2024no,lind2017glamdring}.
One branch of research focuses on porting runtime environments for high-level languages to TEEs~\cite{wuLCZWYLS24tc,miao23icse}.
However, it introduces significant overhead and may not be applicable to TEEs with small memory sizes.
The security guarantees of ported environments may not be as robust as those for native code execution, potentially exposing vulnerabilities, such as memory leaks~\cite{sekeQianWZ18, kbseShahoorKYK23}.
Another branch of research is to separate programs into security-sensitive and non-sensitive parts, and only port the security-sensitive parts to TEEs~\cite{zhang2024no,lind2017glamdring}.
However, the existing methods require developers to manually specify the data to be traced and to manually transform the program, which is complex and error-prone.

Therefore, the current practice of porting programs to TEEs is mainly a human-in-the-loop process that requires substantial effort in manual intervention~\cite{seo2017sgx, ShankerJG20sigsoft, 9276587}, motivating us to propose \system, the first Large Language Model (LLM)-enabled approach that can automatically identify, partition, and transform sensitive functions in popular programming languages, and port the transformed code into TEEs.

% How our system works
Specifically, for a given program (in Java or Python), \system generates the Abstract Syntax Tree (AST) and extracts the leaf functions that do not invoke any other developer-designed functions.
These leaf functions are the most fundamental functions being called within the program, facilitating our porting with minimal cost.
Then, \system prompts an LLM to review each extracted function and identify those involving sensitive operations (i.e., cryptography and serialization usage in our paper).
Following this, we design an LLM-enabled framework to automatically transform the identified functions into their functionally equivalent Rust implementations.
We define two criteria for a \dquote{successfully transformed} function: (1) the code should compile, and (2) it should preserve the same functionality as the original code.
Although LLMs have already demonstrated promising capabilities in code transformation~\cite{pacmseDilharaBBD24,dainese2024can}, we adopt an iterative process to refine the results. Specifically, if the transformed code fails to compile, the LLM will re-generate the Rust implementation based on compiler feedback.
In addition, the LLM generates test inputs for the original code; if the transformed code produces different outputs for the same test inputs, the LLM is prompted to further adjust its transformation.
The process continues until the transformed code meets both criteria or reaches a predefined threshold for the number of iterations.
We compile the transformed code into binaries and deploy them in TEEs.
For a given function in the original program, \system replaces its functional body with an external call to the corresponding binaries in TEEs and returns the result to the original program.
Thus, the sensitive part of the program is protected under TEEs.
\system also encrypts the communication between the original program and the TEE to ensure the confidentiality of sensitive data.


% Evaluation
By manually reviewing 68 repositories in Python and Java, we constructed a benchmarking dataset consisting of 385 sensitive leaf functions to be transformed into their TEE-compliant variant.
We first evaluate whether \system can accurately identify the functions for transformation. Our experiment shows that \system achieves an average F1-score of 0.91 on the benchmark.
When employing GPT-4o to transform sensitive functions, \system achieves a success rate of 90\% for Java code and 83\% for Python code.
The ablation study shows that the iterative process can boost the transformation success rate of Python by 85.6\%.
% {\color{cyan}The ablation study shows that the iterative process can boost the transformation success rate by xx\%.}
% With the support of the most advanced large language model, GPT-4o, an average transformation rate of 90\% is achieved for Java code and 83\% for Python code, successfully maintaining functional consistency with the original code.
The transformed programs, after integration, can generate outputs identical to those of the original programs when tested with the same inputs, whether on Intel SGX or AMD SEV.
% {\color{cyan} (Could we provide a bit more results? Do we run the whole repositories or only these programs? It would be good if we could show that the new project with TEE support can pass the test inputs for the original projects.)}

% Contributions
\vspace{0.1cm}
\noindent
\textbf{Contributions:}
\begin{itemize}[leftmargin=*]
% System
\item We propose an automated approach, \system, that re-engineers programs to be better adapted to TEEs, minimizing manual code modifications and ensuring compatibility with high-level languages like Java and Python.

\item \system is the first approach leveraging LLMs for program adaptation to TEE environments. It employs large language models to achieve nearly complete automation of the process while requiring less developer involvement.

\item \system employs an iterative transformation process, leveraging compiler checks and consistency validations to ensure the transformed code is executable and functionally consistent with the original code.

% Open-source
\item We open-source \system and provide the details of our results at \url{https://github.com/BlackJocker1995/autotee}.

\end{itemize}