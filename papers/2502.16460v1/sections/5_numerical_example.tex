In this section, we show the effectiveness of our proposed resilient coverage control and rigidity recovery algorithms using numerical simulations. %All the simulations are performed using a Dell Precision-3581 workstation laptop with a 13{th}-Gen Intel Core i7 processor and an Nvidia RTX A1000 GPU, using CasADI \cite{andersson2019casadi} and IOPT solver.
\begin{figure*}[h]
\centering
        \centering
        \includegraphics[width=0.9\textwidth, trim={2.8cm 2.3cm 1.5cm 2.6cm},clip]{sections/images/rigidity_recovery.pdf}
\caption{Rigidity recovery in the event of loss of robot $4$. The neighbors of robot $4$, i.e., robots 1,5, 6, and 7, utilize the proposed rigidity recovery algorithm to identify $(1,6)$ and $(1,7)$ as the new set of edges for rigidity recovery.}
\label{fig:rigidity_recovery}
\end{figure*}
%\subsection{Results - Bearing Maintenance in Coverage Control}

\textit{Results - Bearing Maintenance in Coverage Control}: The coverage environment is defined as $\mathcal{Q} = [0,5] \times [0,5]$. The density function is chosen as $\phi(q) = 1$. We consider $4$ robots, each modeled as the unicycle dynamics. The dynamics can be represented as,
\begin{align}
    p^x_{i,k+1} &= p^x_{i,k} + T_s \cos (\theta_{i,k}) v_{i,k}\\
    p^y_{i,k+1} &= p^y_{i,k} + T_s \sin (\theta_{i,k}) v_{i,k}\\
    \theta_{i,k+1} &= \theta_{i,k} + T_s \omega_{i,k},
\end{align}
where $p_{i,k}^x$ and $p_{i_k}^y$ denote the positions and $\theta_{i,k}$ denotes the yaw of the $i^{\text{th}}$ robot at time $k$, respectively. The control inputs are the linear and angular velocities denoted by $v_{i,k}$ and $\omega_{i,k}$ for each robot, respectively. The sample time is $T_s = 0.1s$. The matrix $C_i$ is given by $
C_i = \begin{bsmallmatrix}
    1 & 0 & 0 & 0\\
    0 & 1 & 0 & 0
\end{bsmallmatrix}$. 

The position of each robot is constrained to be within the coverage region $\mathcal{Q}$ and the yaw $\theta_{i,k} \in [-\pi, \pi]$. The linear and angular velocities for each robot are limited to $\norm{v_{i}}\leq 1$ $m/s$ and $\norm{\omega_{i}}\leq \pi/2$ $rad/s$, respectively. The initial positions of all the robots are $p_{1,0} = [0.7,0.9]^\top$, $p_{2,0} = [0.5,1.2]^\top$, $p_{3,0} = [2.0,1.5]^\top$, and $p_{4,0} = [1.5, 1.0]^\top$. The stage cost is given by $\ell_i(x_i-\bar{x}_i,u_i - \bar{u}_i) = \norm{x_i - \bar{x}_i}^2_{Q_i} + \norm{u_i - \bar{u}_i}^2_{R_i}$, where $Q_i = \text{diag}(1,1,1)$ and $R_i= \text{diag}(0.05, 0.005)$ are chosen as diagonal matrices. The reference tracking cost and bearing maintenance costs are given by $\ell_{i,r}(r_i-\bar{r}_i) = \norm{r_i - \bar{r}_i}^2_{Q^r_i}$ and $\ell_{i,b}(g_i, \bar{r}_i) = \sum_j^{\mathcal{N}_i} \norm{g_{ij} - f_B(\bar{r}_i)}^2_{Q^b_{ij}}$, respectively, where $Q^r_i = I$ and $Q^b_{ij} = 100\cdot I$. 
% The following adjacency matrix describes the MRS network $\mathcal{G}$. 
% \begin{equation}
%     A^{\mathcal{G}} = \begin{bsmallmatrix}
%     0 & 1 & 1 & 1\\
%     1 & 0 & 1 & 0\\
%     1 & 1 & 0 & 1\\
%     1 & 0 & 1 & 0
% \end{bsmallmatrix}. 
% \end{equation}

Figure \ref{fig:coverage} shows the evolution of the robots with the initial configuration at $k = 0$, the intermediate configuration at $k=50$ and the final configuration $k=140$. We can clearly observe that our proposed algorithm converges to the $4$ rectangles of equal area as $k$ becomes $140$, validating our theoretical results. In Fig. \ref{fig:cost}, we plot the coverage cost function \eqref{eq:coverage_prob} with time until $k =140$ for different values of $\mu$. By modifying the value of $\mu$, we can tune the importance of the bearing cost on the overall optimization problem. In Fig. \ref{fig:cost}, we compare the coverage cost for three different values of $\mu=1$, $\mu = 0.7$ and $\mu = 0.1$. We observe that as the weights on the bearing cost increase, i.e., $1 - \mu = 0.3$ and $1 - \mu = 0.9$, the coverage cost has a nonmonotonic behavior at the beginning. This is because our proposed controller first aligns the robots to enforce a constant bearing formation and then translates toward the desired centroids\footnote{Note that when $\mu=1$, our algorithm is equivalent to \cite{carron2020model}}. Thus, our numerical simulations corroborate and validate the main convergence result.
%\subsection{Results - Rigidity Recovery Under Agent Loss}

\textit{Results - Rigidity Recovery Under Agent Loss}: To illustrate the effectiveness of the proposed rigidity recovery algorithm, we consider a network of $8$ robots assigned to accomplish a coverage task as shown in Fig. \ref{fig:rigidity_recovery}. We consider that robot $4$ becomes faulty during the mission and leaves the network. Thus, the rest of the robots in the network must reorganize themselves to ensure connectivity (rigidity) and, thus, the mission's objective. Using Algorithm \ref{alg:recovery}, each of the neighbors of robot $4$, i.e., robots 1, 5, 6 and 7, proactively computes the recovery set $\mathcal{E}^r_{i4}, \ i\in\{1,5,6,7\}$ with $j=4$ in the following way:
\begin{align*}
    \mathcal{E}^r_{14} &= \big\{\{(1,6), 1\}, \{(1,7), 1\}\big\}, \quad \mathcal{E}^r_{54} = \big\{\{(5,7), 7\}\big\}, \\
    \mathcal{E}^r_{64} &= \big\{\{(1,6), 1\} \big\}, \quad \mathcal{E}^r_{74} = \big\{\{(1,7), 1\}, \{(5,7), 7\}\big\}.
\end{align*}
As a result, upon the failure of robot $4$, the robot network reconfigures itself by introducing $(1,6)$ and $(1,7)$ using robot $1$ as the contraction vertex in the underlying MRS network. Note that the resulting network after reconfiguration results in $2*7-3 = 11$ edges, thus forming a Laman graph, i.e., minimally bearing rigid graph. This illustrates that by ensuring bearing maintenance during coverage tasks, the network can be recovered in case of a robot loss. 


