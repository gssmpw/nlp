\subsection{Maximum Clique Cover Algorithm}
\label{sec:maxclique}
When the graph is so sparse that each hyperedge appears as an isolated clique, exact recovery is easily achieved by creating a hypergraph with a hyperedge for every clique of the projected graph $\pG$. This algorithm turns out to succeed far beyond the regime where hyperedges do not overlap.
% \cg{This might be a good place to introduce the clique graph}


Let the \emph{$d$-clique hypergraph }$\cliG$ of the projected graph $\pG=([n], E_p)$ be the hypergraph $\cliG = ([n],\cliE=\cli(\pE))$ where
\[
\cli(E) = \b\{\he\in \textstyle{\binom{[n]}{d}} : (i,j)\in E
\text{ for every } \{i,j\}\subset h
\b\}\,.
\]
% We use $\Ic(\he)$ to be the indicator that a hyperedge $\he$ is included in $\cliG$.
% It is easy to see that any $\hE\in \prim(E)$ is a subset of $\cli(E)$. 
% \cg{cg: only retain what is really used below}
% Notice that there is a bijection between all possible $d$-clique hypergraphs and the image set of $\proj$, as $\proj(\cli(E))=E$. 
% When we say the minimum preimage or the minimum cover of a $d-$clique hypergraph, we refer to the minimum preimage or the minimum cover of the corresponding projected graph.
% 
Denote by $\cliA$ the algorithm converting every size-$d$ clique in $\pG $ to a hyperedge in the output graph, i.e., $\cliA(\pG) = \cli(\pE)$. We call this the \emph{maximum clique cover algorithm}.

% \begin{algorithm}\caption{Maximum Clique Cover Algorithm $\cliA$}\label{alg:clique-cover}
% \begin{algorithmic}[1]
% \STATE Input: $\pG = ([n],\pE)$
% \STATE  $\cli(\pE)\leftarrow \emptyset$
% \FOR{all size $d$ subsets of $[n]$}
%     \STATE If $\pE$ has a clique on the subset, add the hyperedge on the subset to $\cli(\pE)$
% \ENDFOR
% \STATE Output $\cli(\pE)$
% \end{algorithmic}
% \end{algorithm}

\begin{algorithm}\caption{Maximum Clique Cover Algorithm $\cliA$}\label{alg:clique-cover}
\begin{algorithmic}[1]
\State Input: $\pG = ([n],\pE)$
\State  $\cli(\pE)\leftarrow \emptyset$
\For {all size $d$ subsets of $[n]$}
    \State If $\pE$ has a clique on the subset, add the hyperedge on the subset to $\cli(\pE)$
\EndFor
\State Output $\cli(\pE)$
\end{algorithmic}
\end{algorithm}

\begin{remark}
    Since we are enumerating all size-$d$ subsets, the algorithm has time complexity $n^d$. It may be possible to improve this runtime by taking advantage of sparsity of the graph, using ideas in \cite{boix2021average}. 
\end{remark}


For which parameters does this algorithm work? 
% Unfortunately, this does not reach the optimal threshold. 
From the definition, $\cliA$ fails if and only if there exists a clique in $\pG$ that is not a hyperedge of $\rhG$. 
If a $d$-clique $\he$ in $\pG$ is not a hyperedge of $\rhG$, every edge in the clique is included in some other hyperedge $\he'\in \rhG$. By carefully examining the possible ways of inclusion for all edges, we can obtain a tight bound on the probability of the event, yielding the following threshold.

% \gbdone{why is this $d-1$ in denom while Theorem 1.3 has $d$?}
% \cg{It should be $d$, this is a typo.}
\begin{theorem}\label{thm:naive}
    $\cliA$ exactly recovers $\rhG$ when $\delta< \frac{d-3}{d}$ and has $\Omega_n(1)$ probability of failure when $\delta\ge \frac{d-3}{d}$.
\end{theorem}
This implies the positive recovery  result in Theorem~\ref{thm:main-large-d} for $d\geq 6$, which we believe to be suboptimal. The proof of Theorem~\ref{thm:naive} is in Appendix~\ref{sec:naive}. 
% 


\subsection{Greedy Algorithm}
Another natural algorithm starts with the maximum clique cover algorithm and then greedily deletes redundant hyperedges from the clique graph.


\begin{algorithm}\caption{Greedy Algorithm}\label{alg:greedy}
\begin{algorithmic}[1]
\State Input: $\pG = ([n],\pE)$
\State Find the $d$-clique hypergraph $H_0\leftarrow\cli(\pE)$
\While{$\exists h\in H_0$ that $H_0\backslash h\in \proj^{-1}(\hE_\rhG)$}
    \State $H_0\leftarrow H_0\backslash h$
\EndWhile
\State Output $H_0$
\end{algorithmic}
\end{algorithm}

% \begin{algorithm}\caption{Greedy Algorithm}\label{alg:greedy}
% \begin{algorithmic}[1]
% \STATE Input: $\pG = ([n],\pE)$
% \STATE Find the $d$-clique hypergraph $H_0\leftarrow\cli(\pE)$
% \WHILE{$\exists h\in H_0$ that $H_0\backslash h\in \proj^{-1}(\hE_\rhG)$}
%     \STATE $H_0\leftarrow H_0\backslash h$
% \ENDWHILE
% \STATE Output $H_0$
% \end{algorithmic}
% \end{algorithm}

% \begin{enumerate}
%     \item Find the $d$-clique hypergraph $H_0\leftarrow\cli(\pE)$.
%     \item Delete a hyperedge from $H_0$ if after the deletion the graph is still in $\proj^{-1}(\hE_\rhG)$. Repeat until all hyperedge cannot be deleted.
%     \item Output $H_0$
% \end{enumerate}

Heuristically this algorithm ought to work better than the maximum clique cover algorithm, because it yields a graph with higher posterior probability. We leave it as an open question to determine under which parameter regime this algorithm succeeds. 
% \cg{Is there more we can say this algorithm? An alternative choice is to put this in open problem session.}