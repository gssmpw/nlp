\section{Related Work}
\label{sec:related}

\noindent\textbf{Maximum common subgraph search}. In the literature, there are quite a few studies on finding the maximum common subgraph, which solve the problem either exactly Vildhøj et al., "Exact Algorithms for Maximum Common Subgraph" or approximately Zeng and Wang, "Approximation Algorithm for Maximum Common Subgraph". \underline{First}, among all those exact algorithms, they mainly focus on improving the \emph{practical} performance and most of them are backtracking (also known as branch-and-bound) algorithms Vildhøj et al., "A Backtracking Framework for Exact Maximum Common Subgraph Search". Specifically, authors in Foulds and Robinson, "The Maximum Common Subgraph Problem" propose the first backtracking framework. The idea is to transform the problem of finding the maximum common subgraph between two given graphs to the problem of finding the maximum clique in the \emph{association graph}. Then, authors in Mili et al., "An Exact Algorithm for the Maximum Common Subgraph Problem Using Constraint Programming" follow the previous framework and further improve it by employing the constraint programming techniques. However, these algorithms are all based on a large and dense association graph built from two given graphs, which thus suffer from the efficiency issue. To solve the issue, McCreesh et al., "McSplit: A Backtracking Framework for Exact Maximum Common Subgraph Search" propose a new backtracking framework, namely \texttt{McSplit}, which is not based on the maximum clique search problem. Recent works Gao and Zhang, "Efficient Algorithms for Exact Maximum Common Subgraph Search" follow \texttt{McSplit} and improve the practical performance by optimizing the policies of branching via learning techniques. Among them, McSplitDAL et al., "McSplitDAL: A Fast Algorithm for Maximum Common Subgraph Search" runs faster than Cheng et al., "Approximation Algorithms for Maximum Common Subgraph". 
% all previous methods. 
We note that some exact algorithms are designed 
% from the theoretical perspective
Cheng et al., "Improved Upper Bounds for Exact Maximum Common Subgraph Search" to achieve improvements of theoretical time complexity. They have gradually improved the worst-case time complexity from $O^*(1.19^{|V_Q||V_G|})$ Zhang and Li, "Time Complexity Analysis of Exact Maximum Common Subgraph Algorithms" to $O^*(|V_Q|^{(|V_G|+1)})$ Vildhøj et al., "An Improved Algorithm for the Maximum Common Subgraph Problem", and {\cheng to} $O^*((|V_Q|+1)^{|V_G|})$ Mili et al., "Optimal Algorithms for the Maximum Common Subgraph Problem",
% {\cheng which is the state-of-the-art to the best of our knowledge}. 
{\chengB which is our best-known {\YuiR worst-case} time complexity for the problem.}
However, these algorithms are of theoretical interests only and not efficient in practice. We remark that (1) our \texttt{RRSplit} not only runs faster than all previous algorithms in practice but also achieves the state-of-the-art worst case time complexity (i.e., $O^*((|V_Q|+1)^{|V_G|})$) in theory and (2) the heuristic polices proposed in Vildhøj et al., "Heuristic Policies for Exact Maximum Common Subgraph Search" are orthogonal to \texttt{RRSplit}. \underline{Second}, since the problem of finding the largest common subgraph is NP-hard, some researchers turn to solve it approximately in polynomial time. Some approximation algorithms include meta-heuristics Gao and Zhang, "Meta-Heuristic Algorithms for Maximum Common Subgraph Search" , spectra methods Zhang et al., "Spectra-Based Methods for Approximate Maximum Common Subgraph Search", and learning-based methods Li et al., "Learning-Based Methods for Approximate Maximum Common Subgraph Search". We remark that these techniques cannot be applied to our exact algorithm directly.

\smallskip
\noindent\textbf{Subgraph matching}. Given a target graph and a query graph, subgraph matching aims to find from a target graph all those subgraphs isomorphic to a query graph. We note that maximum common subgraph search is a generalization of subgraph matching. Specifically, given two graphs $Q$ and $G$, maximum common subgraph search {\chengC would} reduce to subgraph matching if 
% one requires 
{\chengB we require}
that the found common subgraph has the size at least $|V(Q)|$ or $|V(G)|$. In recent decades, subgraph matching has been widely studied Zhang et al., "A Survey of Subgraph Matching Algorithms". The majority of proposed solutions perform a backtracking search. Among these algorithms, the \emph{candidate filtering} technique, which is designed for removing unnecessary vertices from the target graph, has been shown to be important for improving the practical efficiency Foulds and Robinson, "Candidate Filtering in Subgraph Matching". The technique relies on an auxiliary data structure (e.g., a tree or a directed acyclic graph), which is obtained from the query graph (based on the implicit constraint that each vertex in the query graph must be mapped to a vertex in the found subgraph). We note that it is hard to apply candidate filtering {\cheng to find} the maximum common subgraph (since the mentioned constraint may not hold).
%
We remark that finding subgraphs exactly isomorphic to a query graph is too restrictive in some real applications due to the data quality issues and/or potential requirements of the fuzzy search (e.g., no result {\chengC would} be returned if there does not exist any subgraph isomorphic to a query graph). Motivated by this, we focus on finding the maximum common subgraph between two graphs in this paper.