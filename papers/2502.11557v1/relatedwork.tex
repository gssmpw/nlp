\section{Related Work}
\label{sec:related}

\noindent\textbf{Maximum common subgraph search}. In the literature, there are quite a few studies on finding the maximum common subgraph, which solve the problem either exactly~\cite{levi1973note,mcgregor1982backtrack,abu2014maximum,krissinel2004common,suters2005new,mccreesh2016clique,vismara2008finding,zhoustrengthened,liu2020learning,liu2023hybrid,mccreesh2017partitioning} or approximately~\cite{choi2012efficient,rutgers2010approximate,xiao2009generative,zanfir2018deep,bai2021glsearch}. \underline{First}, among all those exact algorithms, they mainly focus on improving the \emph{practical} performance and most of them are backtracking (also known as branch-and-bound) algorithms~\cite{levi1973note,mcgregor1982backtrack}. Specifically, authors in~\cite{levi1973note,mcgregor1982backtrack} propose the first backtracking framework. The idea is to transform the problem of finding the maximum common subgraph between two given graphs to the problem of finding the maximum clique in the \emph{association graph}. Then, authors in~\cite{mccreesh2016clique,vismara2008finding} follow the previous framework and further improve it by employing the constraint programming techniques. However, these algorithms are all based on a large and dense association graph built from two given graphs, which thus suffer from the efficiency issue. To solve the issue, McCreesh et al.~\cite{mccreesh2017partitioning} propose a new backtracking framework, namely \texttt{McSplit}, which is not based on the maximum clique search problem. Recent works~\cite{zhoustrengthened,liu2020learning,liu2023hybrid} follow \texttt{McSplit} and improve the practical performance by optimizing the policies of branching via learning techniques. Among them, \texttt{McSplitDAL}~\cite{liu2023hybrid} runs faster than {\cheng others.}
% all previous methods. 
We note that some exact algorithms are designed 
% from the theoretical perspective
{\chengB to achieve improvements of theoretical time complexity}
~\cite{abu2014maximum,levi1973note,krissinel2004common,suters2005new}. They have gradually improved the worst-case time complexity from $O^*(1.19^{|V_Q||V_G|})$~\cite{levi1973note} to $O^*(|V_Q|^{(|V_G|+1)})$~\cite{krissinel2004common}, and {\cheng to} $O^*((|V_Q|+1)^{|V_G|})$~\cite{suters2005new},
% {\cheng which is the state-of-the-art to the best of our knowledge}. 
{\chengB which is our best-known {\YuiR worst-case} time complexity for the problem.}
However, these algorithms are of theoretical interests only and not efficient in practice. We remark that (1) our \texttt{RRSplit} not only runs faster than all previous algorithms in practice but also achieves the state-of-the-art worst case time complexity (i.e., $O^*((|V_Q|+1)^{|V_G|})$) in theory and (2) the heuristic polices proposed in~\cite{zhoustrengthened,liu2020learning,liu2023hybrid} are orthogonal to \texttt{RRSplit}. \underline{Second}, since the problem of finding the largest common subgraph is NP-hard, some researchers turn to solve it approximately in polynomial time. Some approximation algorithms include meta-heuristics~\cite{choi2012efficient,rutgers2010approximate}, spectra methods~\cite{xiao2009generative}, and learning-based methods~\cite{zanfir2018deep,bai2021glsearch}. We remark that these techniques cannot be applied to our exact algorithm directly.

\smallskip
\noindent\textbf{Subgraph matching}. Given a target graph and a query graph, subgraph matching aims to find from a target graph all those subgraphs isomorphic to a query graph. We note that maximum common subgraph search is a generalization of subgraph matching. Specifically, given two graphs $Q$ and $G$, maximum common subgraph search {\chengC would} reduce to subgraph matching if 
% one requires 
{\chengB we require}
that the found common subgraph has the size at least $|V(Q)|$ or $|V(G)|$. In recent decades, subgraph matching has been widely studied~\cite{bhattarai2019ceci,ullmann1976algorithm,sun2020rapidmatch,sun2020subgraph,shang2008taming,kim2023fast,han2013turboiso,han2019efficient,cordella2004sub,bi2016efficient,arai2023gup,jin2023circinus,sun2023efficient}. The majority of proposed solutions perform a backtracking search. Among these algorithms, the \emph{candidate filtering} technique, which is designed for removing unnecessary vertices from the target graph, has been shown to be important for improving the practical efficiency~\cite{bhattarai2019ceci,bi2016efficient,han2019efficient,han2013turboiso,kim2023fast}. The technique relies on an auxiliary data structure (e.g., a tree or a directed acyclic graph), which is obtained from the query graph (based on the implicit constraint that each vertex in the query graph must be mapped to a vertex in the found subgraph). We note that it is hard to apply candidate filtering {\cheng to find} the maximum common subgraph (since the mentioned constraint may not hold).
%
We remark that finding subgraphs exactly isomorphic to a query graph is too restrictive in some real applications due to the data quality issues and/or potential requirements of the fuzzy search (e.g., no result {\chengC would} be returned if there does not exist any subgraph isomorphic to a query graph). Motivated by this, we focus on finding the maximum common subgraph between two graphs in this paper.