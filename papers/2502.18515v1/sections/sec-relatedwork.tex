\section{Related Work}

% The growing importance of smart contracts in the blockchain ecosystem has spurred significant research into their security and the application of advanced techniques for vulnerability detection and repair. 
This section reviews related work in smart contract vulnerabilities, security auditing tools, traditional code repair techniques, and the emerging use of Large Language Models (LLMs) for code repair, particularly in the context of Solidity and Move.

\subsection{Smart Contract Vulnerabilities}

Smart contracts, while offering automation and trustless execution, are prone to security vulnerabilities due to their complex code, immutable nature, and the decentralized environment they operate in~\cite{sharma2023mixed,de2024vulnerability,2025arXiv250104600B}. Exploiting these vulnerabilities can lead to severe financial losses, service disruptions, and loss of trust in decentralized applications~\cite{q50t-pw43-24}. Common vulnerabilities include:

\textbf{Reentrancy:} This occurs when a malicious contract calls back into the original contract before the first function invocation completes\cite{so2023smartfix,tang2023deep}. This can disrupt control flow, allowing attackers to repeatedly execute a vulnerable function, potentially draining funds or manipulating the contract's state~\cite{tang2023deep,deng2023smart}. 

% Mitigation strategies include employing the checks-effects-interactions pattern and using mutual exclusion locks (mutexes)\cite{tang2023deep,deng2023smart}.

\textbf{Integer Overflow/Underflow:} These vulnerabilities arise when arithmetic operations result in values exceeding the maximum or falling below the minimum representable value for the integer type. Before Solidity 0.8.0, these errors wrapped around silently, leading to unexpected behavior. 
% Mitigation involves using Solidity 0.8.0 or later, which has built-in checks, or employing SafeMath libraries.

\textbf{Access Control Issues:} Insufficient or improperly implemented access control can allow unauthorized users to interact with sensitive functions or data. 

% Common mistakes include failing to restrict access to administrative functions. Robust access control mechanisms using modifiers and thorough testing are crucial mitigations.

\textbf{Front-Running:} This exploits the transparency of pending transactions. Attackers observe a pending transaction, craft a transaction with a higher gas price, and get it included in the next block first, gaining an unfair advantage.
% .
% Mitigation includes commit-reveal schemes, time-delayed execution, or using decentralized exchanges (DEXs) with built-in protection.

% \textbf{Denial of Service (DoS):} DoS attacks aim to make a contract unavailable by consuming all available gas or causing transactions to continually fail, preventing legitimate users from interacting with the contract. 

% Mitigation involves implementing gas limits on functions and avoiding loops over unbounded data structures.

\textbf{Oracle Manipulation:} Smart contracts often rely on external data sources (oracles). Attackers can compromise oracle integrity, manipulating data fed to the contract. Using multiple independent oracles and decentralized oracle networks can mitigate this risk.

These vulnerabilities underscore the importance of rigorous security analysis and testing during smart contract development and deployment.

\subsection{Smart Contract Security Auditing}

Various tools and techniques have been developed for detecting vulnerabilities in smart contracts:

\textbf{Static Analysis Tools:} Tools like Mythril~\cite{muellerfile} and Slither~\cite{feist2019slither} analyze contract source code to identify potential vulnerabilities. They perform symbolic execution and taint analysis to detect patterns associated with common vulnerabilities.

\textbf{Dynamic Analysis Tools:} Tools like Manticore~\cite{mossberg2019manticore}and Echidna~\cite{grieco2020echidna} execute contracts with various inputs to uncover runtime errors. They use fuzzing and symbolic execution techniques to explore different execution paths and identify potential issues.

\textbf{Formal Verification:} This approach uses mathematical techniques to rigorously prove the correctness of a contract's code against a formal specification. Tools like KEVM~\cite{hildenbrandt2018kevm} and CertiK's DeepSEA have been developed for formal verification of smart contracts~\cite{zhong2020move}.

While these tools are valuable, they often have limitations in accuracy, scalability, and the ability to handle the complexities of real-world smart contracts.

\subsection{LLMs for Code Repair}

LLMs, trained on vast datasets of code, have shown impressive capabilities in code repair tasks~\cite{chen2021evaluating}. They can learn to understand and generate code that adheres to specific programming paradigms and best practices. However, applying LLMs to smart contract code repair presents unique challenges due to the specific syntax, semantics, and security considerations of languages like Solidity and Move.

Our proposed framework, \textbf{Smartify}, addresses these challenges by combining the strengths of specialized LLMs within a multi-agent architecture. It leverages language-specific fine-tuning, safety classifiers, and Retrieval-Augmented Generation (RAG) to enhance the accuracy and security of generated code repairs. 
% Furthermore, \sln{} incorporates the SolMover~\cite{kara} tool to facilitate cross-language translation between Solidity and Move, expanding its applicability within the blockchain ecosystem.

In the following sections, we detail the architecture of \sln{}, describe the experimental setup, present the evaluation results, and discuss the implications of our findings for the future of smart contract security.

