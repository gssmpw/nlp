\section{Data Collection and Analysis Methodology}

This research employs a multi-faceted approach to investigate the security of smart contracts, focusing on both Solidity and Move programming languages. The methodology encompasses the collection and analysis of three distinct datasets: Solidity-based, Move-based source code. Each dataset serves a specific purpose in addressing the research questions and contributing to a comprehensive understanding of smart contract vulnerabilities.

\subsection{Importance of Dataset Categorization}

For several reasons, categorizing the datasets based on programming language (Solidity and Move) and code representation is crucial. It allows for a focused analysis of language-specific vulnerabilities and coding practices. As a more mature language, Solidity exhibits a different vulnerability landscape than the newer Move language. Examining them separately enables the identification of unique challenges and security considerations associated with each language. 
% Second, the distinction between source code and bytecode datasets facilitates different types of analysis. 

% Source code analysis permits manual auditing, formal verification, and static analysis, while bytecode analysis is essential for studying deployed contracts and conducting large-scale assessments of on-chain security. This layered approach provides a holistic view of the smart contract security ecosystem, covering both development and deployment phases.

\subsection{Dataset Descriptions}

\subsubsection{Solidity-Based Dataset}
This dataset comprises a collection of vulnerable Solidity smart contracts sourced from the "Not-So-Smart Contracts" repository curated by Trail of Bits \cite{githubGitHubCryticnotsosmartcontracts}. This repository is renowned for its comprehensive set of contracts that intentionally exhibit a variety of common vulnerabilities. These vulnerabilities were chosen for inclusion because of their prevalence in real-world decentralized applications and their representation of typical errors during smart contract development. 
%
The dataset contains 60 vulnerable contracts, encompassing 8 distinct vulnerability categories. These categories' distribution is shown in Table \ref{tab:solidity-distribution}.

% follows: 25\% Reentrancy, 16.7\% Integer Overflow/Underflow, 13.3\% Denial of Service (DoS), 20\% Access Control Issues, 8.3\% Uninitialized Storage Pointers, 5\% Tx.origin Misuse, 6.7\% Timestamp Dependency, and 5\% Gas Limit and Out-of-Gas Vulnerabilities.

\begin{table}[ht]
\centering
\caption{Distribution of Vulnerabilities in the Solidity Dataset.}
\label{tab:solidity-distribution}
\begin{tabularx}{\columnwidth}{|>{\raggedright\arraybackslash}X|S[table-format=2.0]|S[table-format=2.1]|}
\hline
\textbf{Vulnerability Type} & {\textbf{Number of Contracts}} & {\textbf{Percentage (\%)}} \\ \hline
Reentrancy & 15 & 25.0 \\ \hline
Integer Overflow/Underflow & 10 & 16.7 \\ \hline
Denial of Service (DoS) & 8 & 13.3 \\ \hline
Access Control Issues & 12 & 20.0 \\ \hline
Uninitialized Storage Pointers & 5 & 8.3 \\ \hline
Tx.origin Misuse & 3 & 5.0 \\ \hline
Timestamp Dependency & 4 & 6.7 \\ \hline
Gas Limit and Out-of-Gas Vulnerabilities & 3 & 5.0 \\ \hline
\textbf{Total} & \textbf{60} & \textbf{100.0} \\ \hline
\end{tabularx}
\end{table}

% \begin{figure}[ht]
% \centering
% \begin{tikzpicture}
% \begin{axis}[
%     axis x line=none, 
%     axis y line=none,
%     enlarge x limits=0.15,
%     enlarge y limits=0.15,
%     ybar,
%     ymin=0,
%     bar width=15pt,
%     nodes near coords,
%     nodes near coords align={vertical},
%     symbolic x coords={Reentrancy,Integer Overflow/Underflow,Denial of Service (DoS),Access Control Issues,Uninitialized Storage Pointers,Tx.origin Misuse,Timestamp Dependency,Gas Limit and Out-of-Gas Vulnerabilities},
%     xtick=data,
%     xticklabel style={rotate=45,anchor=east},
%     ylabel={Percentage (\%)},
%     title={Distribution of Vulnerabilities in the Solidity Dataset},
% ]
% \addplot coordinates {
%     (Reentrancy,25)
%     (Integer Overflow/Underflow,16.7)
%     (Denial of Service (DoS),13.3)
%     (Access Control Issues,20)
%     (Uninitialized Storage Pointers,8.3)
%     (Tx.origin Misuse,5)
%     (Timestamp Dependency,6.7)
%     (Gas Limit and Out-of-Gas Vulnerabilities,5)
% };
% \end{axis}
% \end{tikzpicture}
% \caption{Distribution of Vulnerabilities in the Solidity Dataset (Bar Chart)}
% \label{fig:solidity-bar-chart}
% \end{figure}

\subsubsection{Move-Based Dataset (Source Code)}
This dataset encompasses the source code of 92 real-world Move projects, comprising 652 individual modules. These projects were part of Aptos \cite{devaptos}, Sui \cite{blackshear2024sui}, and Starcoin \cite{starcoin}. These projects span various application domains, as depicted in Table \ref{tab:move-source-distribution}.
% including 41 Decentralized Finance (DeFi) projects, 22 Token projects, 18 Bridge projects, 3 Library projects, 3 Infrastructure projects, and 5 miscellaneous projects. 
%
The total number of Move projects is 92, and the total number of Move modules within these projects is 652.

\begin{table}[ht]
\centering
\caption{Distribution of Move Projects by Application Domain.}
\label{tab:move-source-distribution}
\begin{tabularx}{\columnwidth}{|>{\raggedright\arraybackslash}X|S[table-format=2.0]|S[table-format=2.1]|}
\hline
\textbf{Application Domain} & {\textbf{Number of Projects}} & {\textbf{Percentage (\%)}} \\ \hline
Decentralized Finance & 41 & 44.6 \\ \hline
Token & 22 & 23.9 \\ \hline
Bridge & 18 & 19.6 \\ \hline
Library & 3 & 3.3 \\ \hline
Infrastructure & 3 & 3.3 \\ \hline
Other & 5 & 5.4 \\ \hline
\textbf{Total} & \textbf{92} & \textbf{100.0} \\ \hline
\end{tabularx}
\end{table}
% \subsubsection{Move-Based Dataset (Bytecode)}

% This dataset consists of 37,302 bytecode instances of deployed Move modules collected from Aptos and Sui blockchains. The dataset is divided into 15,479 bytecode instances from Aptos and 21,823 from Sui. Starcoin was excluded due to its significantly lower transaction volume, representing only a negligible fraction of Aptos and Sui's activity.  The bytecode instances from Aptos constitute approximately 41.5\% of the total, while those from Sui make up the remaining 58.5\%. This distribution is visualized in Figure \ref{fig:move-bytecode-pie-chart}.

For both the Move-based datasets, we utilize Song et al's~\cite{song2024empirical} work to compare the vulnerability detection part. While the prior work is directed towards detection, the same dataset helps us compare \sln{}'s performance on both detection and repair.

% We also employ our \sln{} to 100 move contracts, which we have decompiled from the sui chain, to see if our method can also repair unfinished codes. However, our automated approach has been limited to compiler-based verification.

% \begin{figure}[ht]
% \centering
% \begin{tikzpicture}
% \pie[text=legend, radius=3]{41.5/Aptos, 58.5/Sui}
% \end{tikzpicture}
% \caption{Distribution of Move Bytecode Instances by Blockchain}
% \label{fig:move-bytecode-pie-chart}
% \end{figure}

% \begin{table}[ht]
% \centering
% \caption{Distribution of Move Bytecode Instances}
% \label{tab:move-bytecode-distribution}
% \begin{tabularx}{\columnwidth}{|>{\raggedright\arraybackslash}X|S[table-format=5.0]|S[table-format=2.1]|}
% \hline
% \textbf{Blockchain} & {\textbf{Number of Instances}} & {\textbf{Percentage (\%)}} \\ \hline
% Aptos & 15479 & 41.5 \\ \hline
% Sui & 21823 & 58.5 \\ \hline
% \textbf{Total} & \textbf{37302} & \textbf{100.0} \\ \hline
% \end{tabularx}
% \end{table}

\iffalse
The table~\ref{tab:dataset-summary}  provides a concise summary of the key characteristics of each dataset, highlighting their respective sizes and purposes within the research framework.

\begin{table}[]
\centering
\caption{Summary of Datasets}
\label{tab:dataset-summary}
\resizebox{\columnwidth}{!}{%
\begin{tabular}{|l|c|l|}
\hline
\textbf{Dataset} & \textbf{Size} & \textbf{Purpose}                                                     \\ \hline
Solidity         & 60 Contracts  & Analysis of Solidity vulnerabilities and comparison with Move.       \\ \hline
Move             & 92 Projects   & Examination of Move vulnerabilities, coding patterns, and structure. \\ \hline
\end{tabular}%
}
\end{table}
\fi

\subsection{Evaluation of \sln{}} \label{evaluationmethod}

\sln{} is designed with two core functionalities: detecting and repairing unsafe coding patterns in smart contracts. To rigorously evaluate these capabilities, we utilize the previously described datasets, encompassing both Solidity and Move code. The evaluation process focuses on the complete output of \sln{} rather than individual components, reflecting its nature as an integrated solution for smart contract security. Performance is measured using the Pass@1 score.

% \textit{Pass@1} is a metric that quantifies the percentage of problems for which a correct solution is generated on the first attempt. In the context of code generation and repair, it signifies the system's ability to produce functional and secure code without requiring iterative refinement or manual intervention. A higher Pass@1 score indicates greater accuracy and efficiency. For this research, Pass@1 is particularly important as it reflects the practical applicability of \sln{} in real-world scenarios. A high Pass@1 score suggests that \sln{} can be effectively used to automatically detect and repair vulnerabilities in smart contracts, reducing the burden on developers and enhancing the overall security of blockchain applications.

\subsection{Agent-Based Code Repair Process for Smart Contracts}

Our approach leverages a multi-agent system inspired by established software development methodologies but specifically tailored for the automated repair of Solidity and Move smart contracts. This system employs five specialized agents: an Auditor, an Architect, a Code Generator, a Refiner, and a Validator. The process incorporates a self-refinement loop and a final validation step, ensuring a high degree of accuracy and security. Each agent plays a distinct role in a structured workflow, detailed below.

\subsubsection{Agent Roles and Responsibilities}

\begin{itemize}
    \item \textbf{Auditor:} This agent is the cornerstone of the security analysis. It is fine-tuned on a comprehensive corpus of Solidity and Move code documentation, encompassing syntax, semantics, and best practices. Furthermore, it is safety-aligned using a classifier adapted from Google's Responsible AI toolkit. This classifier has been meticulously modified to enforce language-specific rules and safe coding practices, effectively preventing the generation of unsafe or unsupported code constructs.  

    This alignment is of paramount importance. For Move, it ensures that generated code strictly adheres to the conventions of the target blockchain (e.g., Sui or Aptos). It prevents the accidental introduction of elements from one Move variant into another or the inclusion of unsupported Rust paradigms. This is crucial because Move, while derived from Rust, has its own unique features and limitations. For Solidity, it enforces established security best practices and prevents the generation of code patterns known to be vulnerable.

    The Auditor's primary responsibility is to meticulously scan the input smart contract code (either Solidity or Move) to identify potential vulnerabilities and unsafe patterns. It's secondary, yet vital, role is to serve as the final validator of the repaired code.
    \item \textbf{Architect:} This agent receives the output from the Auditor, which includes a detailed report of identified vulnerabilities and unsafe code segments. The Architect's role is to devise a high-level strategic plan for addressing these issues. This plan does not involve generating code directly. Instead, it outlines the necessary modifications, refactoring, and improvements required to rectify the identified problems. This plan serves as a comprehensive blueprint for the Code Generator, guiding the code repair process.
    \item \textbf{Code Generator:} This agent is a general-purpose code LLM. Its strength lies in its ability to leverage Retrieval-Augmented Generation (RAG) from two distinct data stores, one dedicated to Solidity and the other to Move. 
    These data stores contain a collection of best practices and relevant documentation for respective programming language. 

    Using the Architect's plan as a guide, the Code Generator selects and adapts relevant examples from the appropriate RAG datastore. This dynamic, context-aware retrieval of few-shot examples significantly enhances the Code Generator's ability to produce accurate and secure code repairs. It ensures the generated code adheres to language-specific conventions and incorporates established best practices.
    \item \textbf{Refiner:} This agent's role is to enhance the quality of the code produced by the Code Generator. It achieves this through a process of iterative self-refinement, essentially acting as its own critic. The Refiner uses the same underlying LLM as the Code Generator but with a different prompt that focuses on improving the code quality based on best practices and potential improvements that it might detect from a higher level.
    \item \textbf{Validator:} This agent acts as a final checkpoint in the process. It re-employs the Auditor agent to re-evaluate the code after the refinement stage. The Validator's objective is to ensure that all previously identified vulnerabilities have been adequately addressed and that no new vulnerabilities have been introduced during the repair and refinement process.
\end{itemize}

% \subsubsection{Workflow and Iteration}

% The code repair process unfolds in a structured, iterative sequence:

% \begin{enumerate}
%     \item \textbf{Initial Audit:} The Auditor receives the input smart contract code (either Solidity or Move from the respective datasets) and performs a thorough scan to identify vulnerabilities and unsafe patterns. The result of this stage is a detailed report that pinpoints the specific issues found in the code.
%     \item \textbf{Architectural Planning:} The Auditor's findings are passed to the Architect. The Architect agent then formulates a high-level strategic plan to address the identified issues. This plan does not involve code generation but rather outlines the necessary steps, refactorings, and improvements needed to resolve the vulnerabilities.
%     \item \textbf{Code Generation:} The Code Generator, guided by the Architect's plan, accesses the relevant RAG datastore (Solidity or Move) to retrieve appropriate code examples and best practices. It then generates the repaired code, dynamically incorporating the retrieved information to ensure accuracy and adherence to language-specific conventions.
%     \item \textbf{Code Refinement:} The Refiner agent takes the generated code and iteratively refines it based on common coding standards, and potential improvements. This step focuses on improving code quality, readability, and efficiency without altering the intended functionality.
%     \item \textbf{Final Validation:} The refined code is submitted to the Validator (which is the Auditor agent) for a final, rigorous security check. This step ensures that the repairs have effectively addressed the initial vulnerabilities and that no new issues have been inadvertently introduced during the repair and refinement process. If the Validator approves the code, the process is complete. If not, the process may loop back to the code generation or refinement steps as needed, though this is typically rare given the rigor of the prior steps.
% \end{enumerate}

% \begin{figure}[ht]
% \centering
% \begin{tikzpicture}[
%     node distance = 2cm, auto,
%     block/.style = {rectangle, draw, text width=10em, text centered, rounded corners, minimum height=4em},
%     line/.style = {draw, -latex'}
% ]
%     \node [block] (input) {Input Smart Contract (Solidity/Move)};
%     \node [block, below of=input] (auditor) {Auditor (Security Analysis)};
%     \node [block, below of=auditor] (architect) {Architect (Repair Planning)};
%     \node [block, below of=architect, text width=12em] (generator) {Code Generator (with RAG for Solidity/Move)};
%     \node [block, below of=generator] (refiner) {Refiner (Iterative Code Improvement)};
%     \node [block, below of=refiner] (validator) {Validator (Final Security Check)};
%     \node [block, below of=validator] (output) {Repaired Smart Contract};

%     \path [line] (input) -- (auditor);
%     \path [line] (auditor) -- (architect);
%     \path [line] (architect) -- (generator);
%     \path [line] (generator) -- (refiner);
%     \path [line] (refiner) -- (validator);
%     \path [line] (validator) -- (output);
%     \path [line, dashed] (validator) -| ++(-4,0) |- (generator); 

% \end{tikzpicture}
% \caption{Agent-Based Smart Contract Repair Process}
% \label{fig:agent_process}
% \end{figure}

\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{icbc_overall.png}
    \caption{Architecture of \sln{}.}
    \label{fig:archi}
\end{figure}

% \subsubsection{Agent Prompt Template}

% The agents operate based on a standardized prompt template, ensuring consistency and adaptability. The template is structured as details in \ref{} 
% \begin{itemize}
%     \item    \textbf{Role}: Specifies the agent's role (e.g., Auditor, Architect, Code Generator, Refiner, Validator).
%     \item    \textbf{Task}: Describes the specific task the agent is expected to perform (e.g., "Identify vulnerabilities," "Generate repair plan," "Generate code").
%     \item    \textbf{Instruction}: Provides a detailed, step-by-step guide on how to accomplish the task. This section leverages chain-of-thought reasoning to guide the agent's actions.
%     \item    \textbf{Context}: Contains all the necessary information for the agent to perform its task. This may include the input code, audit reports, architectural plans, code examples from the RAG datastore, and the conversation history between agents.
% \end{itemize}

% Table \ref{tab:agent-prompts} shows how this template is adapted for each agent.

% \begin{table}[ht]
% \centering
% \caption{Agent Prompts for Smart Contract Repair}
% \label{tab:agent-prompts}
% \renewcommand{\arraystretch}{1.2} % Adjust row height for readability
% \setlength{\tabcolsep}{4pt} % Adjust column spacing
% \begin{tabularx}{\linewidth}{|p{1.5cm}|X|X|p{2.5cm}|}
% \hline
% \textbf{Role} & \textbf{Task} & \textbf{Instruction} & \textbf{Context} \\ \hline
% Auditor & Identify vulnerabilities and unsafe patterns in Solidity/Move code. & Analyze the code for security vulnerabilities and generate a detailed report. & Input smart contract code (Solidity/Move). \\ \hline
% Architect & Create a high-level plan to address vulnerabilities identified by the Auditor. & Review the Auditor's report and develop a plan outlining necessary modifications. & Auditor's report. \\ \hline
% Code Generator & Generate Repaired Solidity/Move code based on the Architect's plan and RAG examples. & Consult the Architect's plan, retrieve examples from the RAG datastore, and generate repaired code. & Architect's plan, Solidity/Move code examples from RAG. \\ \hline
% Refiner & Iteratively refine the generated code to improve quality and efficiency. & Review the generated code, identify areas for improvement, and refine accordingly. & Generated code, previous iteration code (if any). \\ \hline
% Validator & Perform a final security check on the repaired code. & Analyze the repaired code for vulnerabilities, verify issue resolution, and ensure no new vulnerabilities. & Repaired smart contract code. \\ \hline
% \end{tabularx}
% \end{table}


% This iterative, agent-based approach leverages the strengths of specialized LLMs and incorporates safety checks at multiple stages to ensure the generation of secure and reliable code. The use of language-specific fine-tuning, safety classifiers, RAG-based few-shot examples, and iterative refinement contribute to the robustness and effectiveness of the \sln{} system in both detecting and repairing vulnerabilities in Solidity and Move smart contracts.

