\section{Simulating the A2A array}
\label{sec:Simulation}

\subsection{Capturing the timing information}
\label{subsec:timing_capture}

\noindent 
We define an \textit{event} as a rise or fall transition in a digital signal at the input of a logic gate in an RO, which can cause the opposite transition at its output. We characterize each transition by its arrival time, transition time (rise/fall time), and whether the signal is rising or falling. Our approach is motivated by timing analysis in CMOS digital design, where a timing arc is used to propagate an event at the input of a gate to an event at its output.  
Cell timing information, i.e., the input-to-output delay and the output transition time, is captured in lookup tables as functions of the output load and the transition time of the input signal. 

The invariant during timing analysis is the computation of the arrival time and transition time at a node. 
Given an event at the input of a cell, characterized by these two values, the timing information of the cell can be used to generate an output event(s) and their arrival time(s) and transition time(s).  These events are expressed at the input of another cell, and the process continues.

As mentioned in Section~\ref{sec:A2A}, the A2A array has three types of cells: enable, coupling, and shorting. The simulator works with a timing view of these cells, and in the remainder of this section, we discuss this timing abstraction, using the notation in Fig.~\ref{fig:array_schm}.

The {\em enable cell} has two inputs, one enable signal, \textit{enable}, and another from the RO itself (\textit{inp}). The cell is modeled by a timing arc from \textit{inp} to \textit{outp}.  Since the load is the same for all enable cells, a one-dimensional table, characterized using HSPICE, is used to represent the cell rise delay as a function of the input transition time; a similar table characterizes the fall delay.

The {\em coupling cell} has four inputs ($h_{in}^{f}$, $v_{in}^{f}$, $h_{in}^{r}$, and $v_{in}^{r}$) and four outputs ($h_{out}^{f}$, $v_{out}^{f}$, $h_{out}^{r}$, and $v_{out}^{r}$), where the symbols $h$ and $v$ correspond to the horizontal and vertical ROs, and the superscripts $f$ and $r$ represent the forward and reverse path, respectively, through the cell. The horizontal timing arc ($h_{in}^{f}$ to $h_{out}^{f}$) of the horizontal RO interacts with the vertical timing arc ($v_{in}^{f}$ to $v_{out}^{f}$) of the vertical RO within a window when the cell implements a non-zero coupling coefficient; otherwise the horizontal and vertical paths through the cell do not interact. 
To represent timing on the forward path, we use HSPICE-characterized three-dimensional tables for the delay and output transition times, indexed by the transition times of the two inputs, $h_{in}^{f}$ and $v_{in}^{f}$, and the difference between the arrival times of the two input events, which ranges from $-W$ to $+W$. The precise value of the interaction window width, $W$, defined in Section~\ref{sec:Background}-\ref{sec:practical_considerations}, is determined from HSPICE simulations. Each input may rise or fall, and the four resulting combinations of the transition types imply that we require four tables per coupling value. As a coupling cell implements $2C_{max} + 1$ levels, a total of $4(2C_{max} + 1)$ three-dimensional tables are required.
The timing arcs for the return paths ($h_{in}^{r}$ to $h_{out}^{r}$ and $v_{in}^{r}$ to $v_{out}^{r}$) do not interact as they are not coupled in the A2A architecture of Section~\ref{sec:A2A}. Therefore, the events on these arcs can be processed independently of each other, and one-dimensional tables will suffice as in the case of the enable cell.

The {\em shorting cell} has four inputs and four outputs that are labeled in the same way as the coupling cell, and the difference is that the coupling between the horizontal and vertical oscillators here is a short circuit. Since both the horizontal and vertical oscillators that meet at a shorting cell $(i, i)$ are enabled by the same enable signal, $en_i$, any phase difference between them is a result of differences in coupling delays between the horizontal and vertical oscillators. Since Ising hardware uses weak coupling, these differential delays constitute a small fraction of the period. As a result, the arrival of a rising transition on the vertical RO will not be so severely delayed that it interacts with the falling transition of the horizontal RO at a shorting cell. Therefore, the lookup tables that capture rise-fall and fall-rise interactions are unnecessary, and two lookup tables suffice for shorting cells.

\subsection{Overview of the event-driven simulator}
\label{subsec:simulator}
\vspace{-2mm}
\noindent
The simulator requires the following inputs:
(1)~a \textit{timing file}, with the characterized lookup tables and the interaction window \mbox{(Section~\ref{sec:Simulation}-\ref{subsec:timing_capture})};
(2)~the \textit{circuit netlist}, a file that hierarchically captures the connections between devices and circuits;
(3)~a problem-specific \textit{coupling matrix}, which maps the coupling coefficients of the Hamiltonian to the coupling cells, and is used to select the appropriate lookup table during simulation; 
(4)~a \textit{maximum simulation time}, which specifies the total simulation time; and
(5)~a \textit{tolerance} value used to check for RO synchronization (Section~\ref{sec:Background}-\ref{subsec:ro_ising}).
We use the following data structures:
\begin{itemize}[noitemsep,topsep=-1pt,leftmargin=*]
    \item \textbf{Event:}  
    an object that records an event, recording the net name, arrival time, transition time, and transition type (rising or falling).
    \item \textbf{Q:} a queue that sorts events by their arrival time, with the earliest occurring event at the head.
    \item \textbf{Net2Event:} a map with a net name as the key, pointing to an event at that net.
    \item \textbf{PendingTrigger:} a map with a net name as the key, pointing to a pending event with insufficient information for processing.
\end{itemize}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{img/overview.pdf}
    \vspace{-2mm}
    \caption{A simulator step with the sorted queue Q and the Net2Event map: \textproc{process\_event} consumes one or more events and generates future events.}
    \label{fig:overview}
    \vspace{-2mm}
\end{figure}

\noindent
The simulator outputs are the map Net2Event and \textit{spin\_vals}, the set of spins that optimize the Hamiltonian for the \textit{coupling matrix}.

An overview of the simulator is shown in Fig.~\ref{fig:overview}, listing the event objects, the map Net2Event, and the scheduled events in queue Q. The simulator algorithm, described by pseudocode in Algorithm~\ref{alg:sim}, consists of the following steps:

\input{pseudocode/topAlgo}

\noindent
\textbf{Step 1: Initialize} Initial events at the enable cells are scheduled to start the ROs. The queue, Q, and the map, Net2Event, are populated to reflect these events, and PendingTrigger is initialized to an empty map.

\noindent
\textbf{Step 2: Pop and process an event} The earliest occurring event E is popped from Q. The event is passed to the \textproc{process\_event} function which generates new events that result from E. Consider an event that occurs at the $v^f_{in}$ pin of a coupling cell and the map Net2Event contains another event that occurs at $h^f_{in}$ of the same cell. Then, \textproc{process\_event} will operate on these two events to generate events on output pins $v^f_{out}$ and $h^f_{out}$, of the coupling cell. We describe the \textproc{process\_event} function in Section~\ref{sec:Simulation}-\ref{subsec:process_event}.

\noindent
\textbf{Step 3: Check timeout and synchronization criteria} The timeout criterion is met if the earliest event scheduled in Q has exceeded the \textit{maximum simulation time}.
The synchronization criterion, as defined in Section~\ref{sec:Background}-\ref{subsec:ro_ising}, is met when the periods of all coupled ROs are within the specified \textit{tolerance}. We terminate the simulation when either of the above criteria is met.

\noindent
\textbf{Step 4: Assign spin values} At the end of the simulation, the RO phases are translated to spin values, assigning a spin of $+1$ to the reference RO. The phase difference between the RO in the A2A array and every other RO in the array is determined: if this phase difference is closer to $0$ than it is to $\pi$, a spin value of $+1$ is assigned to the RO, otherwise, we assign a spin value of $-1$.

\begin{figure*}[!ht]
{\centering
\subfigure[]{\includegraphics[width=0.32\linewidth]{img/Android_5x5.pdf}
\label{fig:droid_wave}}
\subfigure[]{\includegraphics[width=0.32\linewidth]{img/HSPICE_5x5.pdf}
\label{fig:hspice_wave}}
\subfigure[]{\includegraphics[width=0.32\linewidth]{img/genAdler.pdf}
\hfill
\label{fig:genAdler_wave}}
}
\caption{Period waveforms for a {5$ \times $5} A2A array from (a)~DROID, (b)~HSPICE, and (c)~GenAdler for the same initial conditions of the ROs.}
\label{fig:waveforms_comparison}
\vspace{-6mm}
\end{figure*} 

\subsection{\textproc{process\_event}: Processing an event from the queue}
\label{subsec:process_event}

\noindent
We describe the intuition behind \textproc{process\_event} using an example to convey the complexities of looking forwards and backwards in time within the interaction window $W$; the pseudocode for \textproc{process\_event} is provided in Appendix~\ref{app:appendix}-\ref{app:process_event}.

\begin{figure}[H]
    \centering
    \includegraphics[width=0.8\linewidth]{img/process_event.pdf}
    \caption{The handling of an event on \textit{net\_a} is influenced by the knowledge of events on nets in some neighborhood around it, as shown on the top. \mbox{\uppercase{Case 1}} shows the scenario when an event on the other input (\textit{net\_b}) of the same instance is known. \uppercase{Case 2} shows the scenario where \textproc{look\_back} is invoked to find an event on \textit{net\_c} that can cause an event on \textit{net\_b} that might lie within the interaction window of the event at \textit{net\_a}.
    }
    \label{fig:process_event}
    \vspace{-4mm}
\end{figure}

\noindent
\textbf{Example 1:} 
Fig.~\ref{fig:process_event} shows a $5 \times 5$ A2A array, and focuses on three coupling cells within the array, as shown in the inset. The figure depicts two separate scenarios, \uppercase{Case 1} and \uppercase{Case 2}, that will be used as examples in this subsection. We assume that the timing file specifies $W=$ 75ps for both examples. 
Consider the situation shown in \uppercase{Case 1} of Fig.~\ref{fig:process_event} where \textproc{process\_event} is called on a rising transition at \textit{net\_a}, which arrives at $t=$ 500ps and has a transition time of 40ps.
The Net2Event map shows a rising transition on \textit{net\_b} at 520ps, with a transition time of 35ps. 
As the arrival time difference of the events is 20ps which is less than the window, these events interact.

The output events are calculated using the three-dimensional lookup table mentioned in Section~\ref{sec:Simulation}-\ref{subsec:timing_capture}.  Note that if the event at \textit{net\_b} were to arrive at 580ps instead of 520ps, it would not interact with the event at \textit{net\_a}. In such a scenario, the event at \textit{net\_a} would be processed as a non-interacting event.  The event(s) generated from processing \textit{net\_a} are inserted into Q, and any key-value pairs in Net2Event associated with \textit{net\_a} and any interacting event are removed.
\hfill $\Box$

The above example considers events already in the Net2Event map, but the process could be complicated by as-yet-unprocessed events that could interact with a transition under consideration. For example, if \textit{net\_b} is not a key in Net2Event, \textproc{look\_back} is used to examine the predecessors of \textit{net\_b} to determine whether any upcoming event might interact with the event on \textit{net\_a}. We illustrate this with an example of a call to \textproc{look\_back}; the pseudocode for \textproc{look\_back} is provided in Appendix~\ref{app:appendix}-\ref{app:look_back}.

\noindent
\textbf{Example 2:} Consider \uppercase{Case 2} in Fig.~\ref{fig:process_event} with events at \textit{net\_a} and \textit{net\_c} in Q. To process the event at \textit{net\_a} which arrives at 500ps, an interacting event on \textit{net\_b} should arrive in the window (425ps, 575ps); there is no event in Net2Event with the key \textit{net\_b}. Thus, \textproc{process\_event} invokes \textproc{look\_back} with the arguments (\textit{net\_b}, (425ps, 575ps), 425ps, Net2Event). 
The predecessor of \textit{net\_b} is \textit{net\_c}.  
Assume for this example, that the minimum and maximum delays of the coupling cell obtained from the timing file are 60ps and 70ps, respectively.  
An event that occurs on \textit{net\_c} can occur as early as 355ps to incur the maximum delay of 70ps and still generate an event on \textit{net\_b} in the required window. Similarly, an event on \textit{net\_c} can occur as late as 515ps and incur the minimum delay of 60ps to generate an interacting event on \textit{net\_b}. Thus, the window of arrival for an event on \textit{net\_c} is (355ps, 515ps).

Since Net2Event contains an event on \textit{net\_c} within this window, \textproc{look\_back} returns true. In \textproc{process\_event}, we stall the processing of \textit{net\_a} until \textit{net\_b} is scheduled, by adding the event to the map PendingTrigger with a key \textit{net\_b}. When the event at \textit{net\_c} is processed and it generates another at \textit{net\_b}, the pending event on \textit{net\_a} will be added back to the queue.
\hfill $\Box$
