We solve the motion planning problem for cooperative multi-MMRs in two steps: offline path planning and online motion planning shown in Fig. \ref{fig2}. In the offline path planning step, we compute a static obstacle-free linear piece-wise continuous path ($S$) between the start and the goal location using our proposed offline path planner in Section \ref{GPP}.

\begin{figure}[htbp]
	\centerline{\includegraphics[width = 240px]{figure/Schematic/PlanningSchematic1.eps}}
	\caption{Two step motion planning process: offline path planning and online motion planning.}
	\label{fig2}
\end{figure}

The path planner smooths the generated path $S$ to a continuous time normalized reference trajectory $p_r(c_t)$ using cubic Bézier curve with normalized time parameter $c_t \in [0,1]$. 
In the next step, an online motion planner (Section \ref{OMP}) computes a feasible motion plan for the collaborative MMRs in receding horizons. The motion planner generates a kinodynamically feasible trajectory for object transportation in the dynamic environment using $p_r(c_t)$ as an initial guess. The generated trajectory is free from collision with the static and dynamic obstacles and collision among the MMRs and with the object.

\begin{figure}[htbp]
	\centerline{\includegraphics[width = 230px]{figure/Schematic/PathPlanningSchematic.eps}}
	\caption{Offline path planning process.}
	\label{fig:3}
\end{figure}

\subsection{Global Path Planner}\label{GPP}
The global path planner computes a static obstacle-free path for the MMRs' base between the start and goal location in offline. It employs visibility vertices finding algorithm \cite{2005_Choset}. The post-processing step computes a convex obstacle-free polygon around the computed path segment. Fig. \ref{fig:3} shows the outline of the path planning process.

\subsubsection{Path Computation} The global path planner dilates all the static obstacle $\mathcal{O}$ by a distance $r_f$ so that we consider the formation $\mathcal{F}$ as a point at the CoM $p$ of the object. The dilation distance $r_f$ is the radius of a circle located at $p$, inside which the formation could always be enclosed. The planner substitutes the mutually intersecting dilated obstacles $\mathcal{O}_{dil}$ with their union. A visibility vertices finding algorithm \cite{2005_Choset} creates a visibility map considering $\mathcal{O}_{dil}$ and including the start and the goal. The vertices from the visibility map are added as node $\mathcal{V}$ to a graph $\mathcal{G}(\mathcal{V}, \mathcal{E}, \mathcal{W})$. An edge $\mathcal{E}$ between two nodes is added if they are mutually visible to each other using the visibility map. The Euclidean distance between two nodes defines the weight $\mathcal{W}$ of the edge connecting them. A graph search algorithm computes the shortest linear piece-wise path $S$ between the start $p_s$ and the goal $p_g$ location. Fig. \ref{fig:4} shows the computed path $S$ with linear segments $S_1, S_2, S_3, S_4$ and vertices $w_1, w_2, w_3, w_4, w_5$.

\begin{figure}[H]
	\centerline{\includegraphics[width = 220px]{figure/Sim/ENV415_Path12_PolyV1}}
	\caption{Path Polygon for $S_2$ computed using the visible vertices of $W_2$ and $W_3$.}
	\label{fig:4}
\end{figure}


\begin{figure*}[htbp]
	\centering
	\subfigure[]
	{
		\includegraphics[width=115px]{figure/Sim/ENV415_Path12_Convexify11PV1}
		\label{fig:5a}
	}
	\subfigure[]
	{
		\includegraphics[width=115px]{figure/Sim/ENV415_Path12_Convexify21PV1}
		\label{fig:5b}
	}
	\subfigure[]
	{
		\includegraphics[width=115px]{figure/Sim/ENV415_Path12_Convexify31PV1}
		\label{fig:5c}
	}
	\subfigure[]
	{
		\includegraphics[width=115px]{figure/Sim/ENV415_Path12_Convexify4P}
		\label{fig:5d}
	}
	\caption{The polygon convexification process step by step. For the path segment 2 in Fig. \ref{fig:5a}, an ellipse touching the nearest concave vertex of the polygon has been formed and a tangent (red line) to the ellipse at this point has been drawn. The tangent cuts the polygon bounded by black edges and the polygon (sky blue) containing the path segment has been kept. The ellipse has been dilated keeping the aspect ratio same in Fig \ref{fig:5b} till it touches the nearest concave vertex of the new polygon. Here a very small portion of the polygon is cut by the tangent to the ellipse at this concave vertex. The process continues till any concave vertex remains and a convex polygon is formed (green polygon in Fig. \ref{fig:5d}.)}
	\label{fig:5}
\end{figure*}

\subsubsection{Convex Polygon Computation}\label{sec:CPC}
Now, we consider the static obstacles without dilution and the vertices  $w_i$ of the path. We again compute the vertices $\mathrm{V}_s$ that are present in the static environment and visible from $w_i,$ (Fig. \ref{fig:4}). A simple polygon is defined for each vertex $w_i,\ \forall i$ by cyclically connecting its visible vertices. This polygon remains in the static obstacle-free region $W_{free}$. The union of polygons defined for $w_i$ and $w_{i+1}$ of a path segment $S_i$ defines a static obstacle-free simple polygon around $S_i\in S$. Fig. \ref{fig:4} shows the computed polygon for the path segment $S_2$ using the polygons around $w_2$ and $w_3$. The union of the two polygons (green and blue) in red boundary defined around $w_2$ and $w_3$ provides a static obstacle-free polygon $\mathrm{P}_{cc,2}$ around $S_2$. A set of polygon $\mathcal{P}_{cc}$ for all the path segments is computed similarly. The computed polygons are generally concave. Convexification is needed for the static obstacle avoidance constraints in motion planning optimizations. We compute a set of convex polygons $\mathcal{P}$ as a subset of their original concave polygons in $\mathcal{P}_{cc}$ by ellipse fitting technique illustrated in the Algo. \ref{algo:convexify}.
 
We define an ellipse in the ground plane as
\begin{equation}
	\kappa(\mathrm{C},\mathrm{d}) = \{x = \mathrm{C} \overline{x} + \mathrm{d}:\ ||\overline{x}||\leq 1, x\in \mathbb{R}^2\}
\end{equation}
where $\mathrm{C}$ is a $2\times2$ symmetric positive definite matrix that maps the deformation of a unit radius circle ($||\overline{x}||\leq 1$) to an ellipse. $\mathrm{C}$ is decomposed as $\mathrm{C} = R^T\Lambda R$, where $R$ is a rotation matrix that aligns the ellipse axes to the world reference frame axes and $\Lambda = diag(a,b)$ is a diagonal scale matrix. The diagonal elements $a$ and $b$ of $\Lambda$ refer to the length of the ellipse semi-major and minor axes. $\mathrm{d}$ defines the center of the ellipse.
\begin{algorithm}
	\caption{Polygon Convexification}\label{algo:convexify}
	\begin{algorithmic}[1]
		\Statex \textbf{Input:} Concave Polygon $\mathrm{P}_{cc,i}$, Path segment $S_i$
		\Statex \textbf{Output:} Convex Polygon $\mathrm{P}$
		\Statex\hrulefill
		\State $\mathrm{P}\gets\mathrm{P}_{cc,i};\ j\gets 0$
		\State $\mathcal{V}_{cc}\gets$ ConcaveVertices($\mathrm{P}$)
		\If{$\mathcal{V}_{cc}\neq\phi$}
		\State $\mathrm{d}\gets$ Midpoint($S_i$); $R$: major axis along $S_i$
		\State $a\gets 0.5length(S_i) + r_f$
		\State $x^*_j \gets$ NearestVertex($\mathcal{V}_{cc}, \mathrm{d}$)
		\State $\mathrm{C}_j,b\gets$ FindEllipse($R,a,\mathrm{d},x^*_j$) \Comment{Use $||\overline{x}^*_j||=1$}
		\State $\kappa_j\gets (\mathrm{C}_j,\mathrm{d})$
		\State $ \mathrm{a}_j\gets2\mathrm{C}^{-T}_j\mathrm{C}^{-1}_j(x^*_j-\mathrm{d}); b_j\gets \mathrm{a}^T_jx^*_j$
		\State $\mathrm{P},\mathcal{V}_{cc}\gets$ DiscardVertices$(\mathrm{a}_j,b_j, \mathrm{P},\mathcal{V}_{cc})$
		\While{$\mathcal{V}_{cc}\neq\phi$}
		\State $j = j+1$
		\State $x^*_j=$ NearestVertex($\mathcal{V}_{cc}, \mathrm{d}$)
		\State $\kappa_j\gets$ DilateEllipse($\kappa_0, x^*_j$)
		\State repeat line $9-10$
		\EndWhile
		\State $\mathrm{P}:\mathbf{A}\gets[\mathrm{a}^T_0,\mathrm{a}^T_1, \cdots]^T,\mathbf{b}\gets[b_0,b_1,\cdots]^T$
		\Else
		\State  $\mathrm{P}:(\mathbf{A},\mathbf{b})\gets$ HalfPlanes($\mathrm{P}$)
		\EndIf
		\State \textbf{return} $\mathrm{P}(\mathbf{A},\mathbf{b})$
		
	\end{algorithmic}
\end{algorithm}

Algo. \ref{algo:convexify} initialized a polygon $\mathrm{P}$ with the concave polygon $\mathrm{P}_{cc,i}$. It finds the concave vertices $\mathcal{V}_{cc}$ of $\mathrm{P}$. If $\mathcal{V}_{cc}$ is not empty, then it convexifies $\mathrm{P}$ in line $4-17$. The algorithm computes the half-plane representation of $\mathrm{P}$ in line $19$. In the polygon convexification process, the algorithm fits an ellipse $\kappa_0$ center $\mathrm{d}$ at the midpoint of the path segment $S_i\in S$. The major axis is aligned with the path segment $S_i$, the semi-major axis length $a = 0.5length(S_i) + r_f$. The ellipse is inflated in the minor-axis direction till it touches the nearest concave points $x^*_0$ to $d$ and an ellipse $\kappa_0$ is formed in line $4-8$. The tangent to the ellipse $\kappa_0$ at point $x^*_0$ defines the inequality representation $H_0 = \{x: \mathrm{a}^T_0 x \leq b_0\}$. After obtaining $H_0$ in line $9$, we cut the polygon with $H_0$ and keep the polygon inside the $H_0$ as $\mathrm{P}$ (Fig. \ref{fig:5a}). We discard the concave vertices outside $H_0$ from $\mathcal{V}_{cc}$. If there is any concave vertices left $\mathcal{V}_{cc}\neq\phi$ the ellipse $\kappa_0$ is dilated to form an ellipse $\kappa_1$ in line $14$ keeping the aspect ratio same till it touches the nearest concave vertices $x^*_1\in\mathcal{V}_{cc}$ to $\mathrm{d}$. The tangent to the ellipse at point $x^*_1$ defines the inequality $H_1 = \{x: \mathrm{a}^T_1 x \leq b_1\}$. After obtaining $H_1$ in line $9$, we cut the polygon with $H_1$ and keep the polygon inside the $H_1$ as $\mathrm{P}$ in Fig. \ref{fig:5b}. The convexification process in line $11-16$ is repeated till there is no concave vertex left in the polygon $\mathcal{V}_{cc}\neq\phi$ (Fig. \ref{fig:5b}-\ref{fig:5d}). After eliminating all the concave vertices, the polygon $\mathrm{P}$ becomes convex (Fig. \ref{fig:5d}), and the half-plane representation of $\mathrm{P}$ is returned in line $17$.

Fig. \ref{fig:6} shows a set of convex polygons $\mathcal{P}$ in light green around the path segment $S$ computed from $P_{cc}$ using the Algo. \ref{algo:convexify}. Every segment of the piece-wise linear path $S$ remains inside any convex polygon $\mathrm{P} \in \mathcal{P}$ defined in $W_{free}$. We add intermediate control points in red dots in Fig. \ref{fig:6} in the path segment as additional control points on the path $S$. The control points are used to generate time-normalized smooth trajectory $p_r(c_t)$ from the $S$ using a Bézier curve with normalized time parameter $c_t \in [0,1]$. These intermediate control points are inserted when a new convex polygon appears along the path $S$ from the start point. A control point is added for the last path segment while exiting the intersection area of the last two polygons. The generated quadratic Bézier curve would remain in $W_{free}$ as any three consecutive control points remain within a single convex polygon. The time-normalized reference trajectory $p_r(c_t)$ is used as an initial guess for the online motion planner.
 
\begin{figure}[H]
 	\centerline{\includegraphics[width = 230px]{figure/Sim/ENV415_GlobalPath}}
 	\caption{Convex polygons around the path segments of $S$.}
 	\label{fig:6}
\end{figure}
 
\subsection{Online Motion Planner} \label{OMP}
The global path planner in Section \ref{GPP} computes a static obstacle-free path $S$. It does not delve into the motion constraints of the MMRs, dynamic obstacle avoidance, and the collision among the MMRs. We formulate an online motion planner as a constrained nonlinear optimization problem incorporating kinodynamic constraints. It uses the smoothed global reference trajectory $p_r(c_t)$ as an initial guess. The motion planner computes the optimal motion for the MMRs by solving the optimization problem in Eqn. \ref{lo}. The online motion planner solves the optimization problem in receding horizons for $N_h$ horizon segment with time $T_h$ to reduce the computational burden. The MMRs execute the computed motion plan of a horizon for an execution time $T_e$ $(T_e < T_h)$. We choose the execution time $T_e$ so that the computation time for a horizon is guaranteed to be less than $T_e$, and the MMRs can start the next plan once it finishes executing the current plan. The online motion planning optimization is given as

\begin{subequations}\label{lo}
        \begin{align}
            \mathcal{X}^{0:N_h}_*,\mathbf{u}^{0:N_h}=\quad & \arg\min \sum_{k=0}^{N_h-1} J( \mathcal{X}^k,u^k) + J_{N_h} \label{lo1}\\
            \textrm{s.t.} \quad & q^{k+1}=f(q^k,u^k) \label{lo2}\\
            \quad & \mathcal{B}(\mathcal{X})\subset\mathcal{W}_{free} \label{lo3}\\
            \quad & \mathcal{B}(\mathcal{X}) \cap \mathcal{O}_{dyn} = \emptyset  \label{lo4} \\
            \quad & H_i\mathrm{v}_{<x,y>}\leq h_i, \label{lo8}\\
            \quad & H_{(i+1)\%n}\mathrm{v}_{<x,y>}\geq h_{(i+1)\%n}, \label{lo9}\\
            \quad & 0\leq \mathrm{v}_z\leq  Z_h ,\forall\mathrm{v}\in\mathscr{V}_i(q_i), \forall i\in [1,n] \label{lo10}\\
            \quad & q^k_{a,i} \in \mathcal{Q}_i , u^k_i \in \mathcal{U}_i, \forall i\in [1,n] \label{lo5}\\
            \quad & g_i(\mathcal{X}) = 0, \forall i\in [1,n]\label{lo6}\\ 
            \quad & \mathcal{X}^0 = \mathcal{X}(0) \label{lo7}
        \end{align}
\end{subequations}
where the superscript $k$ refers to the discrete time step. Section \ref{lcf} illustrates the cost function in Eqn. \eqref{lo1}. Eqn. \eqref{lo2} represents the state transition function (Eqn. \eqref{stf}) of the system. Eqn. \eqref{lo3} and \eqref{lo4} account for the static and dynamic obstacles avoidance constraints detailed in Section \ref{sec:soa} and Section \ref{sec:doa}. The self collision avoidance described in Section \ref{sca} is ensured by the constraints in the Eqn. \eqref{lo8}-\eqref{lo10}. The set of admissible states and control inputs are defined in Eqn. \eqref{lo5} and elaborated in Section \ref{sca}. The grasp constraints described in Section \ref{gc}) are maintained by Eqn. \eqref{lo6}. Eqn. \eqref{lo7} defines the initial state of the formation in a planning horizon $N_h$.


\subsubsection{Cost Function} \label{lcf}
The cost function described in Eqn. \eqref{tcf} for the motion planning optimization in Eqn. \eqref{lo} minimizes the control inputs and the tracking error with respect to the reference trajectory. The diagonal weight-age matrix $\mathbf{W_u}$ for control effort minimization is provided with higher value than the weight-age matrix $\mathbf{W_e}$ to the tracking error ${e^k}$ of the object CoM. The higher weight-age to control inputs prioritize optimal effort. The lower weight values to the tracking error provides global guidance to the trajectory with flexibility to deform for dynamic obstacle avoidance and kinodynamic motion compliance.
\begin{equation}\label{tcf}
	J( \mathcal{X}_k,u_k)= {u^k}^T\mathbf{W_u}u^k + {e^k}^T\mathbf{W_e}e^k
\end{equation}

We discretize the reference path $p_r(c_t)$ into $\Lambda$ path segment.   The expected and reference position for the CoM of the object is denoted as $p^k$ and $p^{\lambda+k}_r = [x, y]^{\lambda+k}_r$ for the future time step $k$ and $\lambda$ is the index of the nearest reference path segment to $p^0$. The discretized path should hold the relation $\sum_{k= 0}^{ N_h-1}||p^{\lambda+k+1}_r - p^{\lambda+k}_r||\leq v_{op}T_h$, where $v_{op}$ is the operational velocity of the formation. The tracking error vector $e^k$ is defined as

\begin{equation}
    e^k = p^k - p^{\lambda+k}_r
\end{equation}

The terminal cost $J_{N_h}$ is defined in Eqn. \eqref{tlcf} similar to the tracking error with a higher weighting $\mathbf{W}_{n_h}$.

\begin{equation}\label{tlcf}
    J_{N_h}={e^{N_h}}^T\mathbf{W_{N_h}}e^{N_h}
\end{equation}

\subsubsection{Static Obstacles Avoidance} \label{sec:soa}
The formation $\mathcal{F}$ must remain within $W_{free}$ ($\mathcal{B}(\mathcal{X})\subset\mathcal{W}_{free}$) to avoid collision with static obstacles. $W_{free}$ is represented by a set of convex polygons $\mathcal{P}$ computed by the offline path planner in Section \ref{sec:CPC}. The inequality representation of the polygon $\mathrm{P} \in \mathcal{P}$ is in Eqn. \eqref{eqn:12}.
\begin{equation}\label{eqn:12}
    \mathrm{P}=\{\textrm{x}\in\mathbb{R}^2:\mathbf{A}\textrm{x}\leq \boldsymbol{b}, \mathbf{A}\in\mathbb{R}^{n_f\times 2}, \boldsymbol{b}\in\mathbb{R}^{n_f}\}
\end{equation}
where $n_f$ is the number of the sides of $\mathrm{P}$ and $\textrm{x}$ is an interior point of $\mathrm{P}$. The set of vertices of the bounding polygons of the object and the $n$ MMRs are represented by $\mathscr{V(\mathcal{X})}$. The projection of $\mathscr{V(\mathcal{X})}$ at the ground plane $(z)$ must remain within any polygon $\mathrm{P}$. The constraints are represented as follows

\begin{equation}\label{eqn:soa}
\mathbf{A}\mathrm{v}_{<x,y>}\leq \boldsymbol{b} - d_{safe}, \forall\mathrm{v}\in\mathscr{V}(\mathcal{X}),\mathrm{P}:(\mathbf{A},\boldsymbol{b})
\end{equation}
where $\mathrm{v}_{<x,y>}$ is the $x-y$ projection of the vertex $\mathrm{v}\in\mathscr{V}(\mathcal{X})$ defined in $\{w\}$. $d_{safe}$ is the safety distance. The number of constraints in Eqn. (\eqref{eqn:soa}) increases the computational complexity significantly. The problem can be simplified further by considering the bounding circles of the projected vertices of the MMR base, manipulators, and the object. This collision geometry reduces the number of constraints and the computational complexity. We have implemented circumscribing bounding circles for each MMR base, manipulator, and object in the ground plane. The center of the circles for the $i^{th}$ MMR base, manipulator, and the object in the ground are located at $p_{base,i}, p_{arm,i}$ and $p_{obj,i}$ with radius $r_{base,i}, r_{arm,i}$ and $r_{obj,i}$. The cyan, purple, and gray area in Fig. \ref{fig:soa} shows the circumscribing circles for the $i-th$ MMR base, manipulator, and object. The reduced static collision avoidance constraints are in the Eqn. \eqref{eqn:soar}

\begin{equation}
	\begin{aligned}
		\mathbf{A}p^k_{m,i}\leq \boldsymbol{b} - d_{safe} - r_{m,i}, \mathrm{P}:(\mathbf{A},\boldsymbol{b})\\
		\forall m \in \{base,obj,arm\}, \forall i \in [1,n], \forall k \in [1,N_h]
	\end{aligned}
	\label{eqn:soar}
\end{equation}
 where $d_{safe}\in \mathbb{R}$ is the safety distance.
\subsubsection{Dynamic Obstacle Avoidance} \label{sec:doa}
The formation $\mathcal{F}$ must not collide with any of the dynamic obstacles $\mathcal{O}_{dyn}$. The space occupied by the formation $\mathcal{B}(\mathcal{X})$ should not overlap with the dynamic obstacles i.e. $\mathcal{B}(\mathcal{X}) \cap \mathcal{O}_{dyn} = \emptyset$. We implement the dynamic obstacle avoidance by introducing a nonlinear constraint between the collision geometries of the formations and the dynamic obstacles. We estimate the state of the dynamic obstacles at the beginning of a planning horizon $N_h$ and consider the obstacle velocity $v_{dyn,d}$ remain the same during $T_h$, where $d \in [1,n_{dyn}]$ represents the dynamic obstacles' ($\mathcal{O}_{dyn}$) index and $n_{dyn}$ represents the number of dynamic obstacle sensed at the beginning of planning horizons. The collision geometry of the dynamic obstacles are considered as circles with radius $r_{dyn,d},\ \forall d\in [1,n_{dyn}]$ located at $p^k_{dyn,d}, \forall k \in [1, N_h]$ in the ground plane. The positions $p^k_{dyn,d} = p_{dyn,d}+v_{dyn,d}kT_c,\ \forall d,\ \forall k \in [1,N_h]$ is obtained with the positions $p_{dyn,d}$ and velocity $v_{dyn,d}$ estimated at the beginning of each planning horizon.
 
The same collision geometry defined for the static obstacle avoidance in Section \ref{sec:soa} for the base, manipulator of the MMRs, and the object are utilized here. The nonlinear constraints defined in Eqn. \eqref{eqn:doa} ensure that the obstacle does not intersect with the formation.

\begin{equation}
    \begin{aligned}
        ||p^k_{dyn,d}-p^k_{m}|| \geq r_{dyn,d} + r_m + d_{safe}\\
        \forall m \in \{base,obj,arm\}, \forall d \in [1,n_{dyn}], \forall k \in [1,N_h]
    \end{aligned}
    \label{eqn:doa}
\end{equation}

\subsubsection{Self Collision Avoidance} \label{sca}
For collision avoidance with the object and the other MMRs, the $i^{th}$ MMR needs to be within the convex wedge shown in Fig. \ref{fig:soa} defined by two infinite vertical planes $\mathcal{H}_i$ and $\mathcal{H}_{(i+1)\%n}$ as shown in Fig. \ref{fig:soa}. The convex wedge specifies the workspace for the $i^{th}$ MMR free from movements of the neighboring MMRs. The planes $\mathcal{H}_i$ and $\mathcal{H}_{(i+1)\%n}$ can be defined dynamically considering the admissible states and workspace of MMRs’ base fixing the object. Here, we have equally divided the space around the periphery of the object, starting at the CoM of the object for each MMR, as the grasping point is equispaced. The vertical plane $\mathcal{H}_i$ is defined as follows.

\begin{equation}\label{eqn:13}
	\begin{aligned}
	\quad & \mathcal{H}_i =\{\textrm{x}\in\mathbb{R}^2:H_i\textrm{x}\leq h_i, H_i\in\mathbb{R}^{1\times 2}, h_i\in\mathbb{R}\}\\
	\quad & 0\leq z \leq + \infty
	\end{aligned}	
\end{equation}

The self-collision avoidance for the $i^{th}$  MMR is defined in the following
\begin{equation}\label{eqn:sca}
		H_i\mathrm{v}_{<x,y>}\leq h_i, H_{(i+1)\%n}\mathrm{v}_{<x,y>}\geq h_{(i+1)\%n}
\end{equation}

where $\mathscr{V}_i(q_i)$ is the set of vertices of the $i\ th$  MMR.
\subsubsection{Grasp Constraints} \label{gc}
The grasp of the object by EE should remain at the same pose throughout the task to ensure stable formation. The grasp constraint for $i$-th MMR is defined as
\begin{subequations}\label{gpoc}
        \begin{align}
            p_{ee,i}=p +{}^w_o\textrm{R}(\psi)^or_i\label{gpc}\\
            \phi_{ee,i} = \psi
            \label{gpo}
        \end{align}
        \label{gpco}
\end{subequations}

where $p_{ee,i}$ is $i$-th MMR's EE position, ${}^w_o\textrm{R}$ is the rotation matrix between the object frame at its CoM and the global frame, and $^or_i$ is the position of the $i-$th EE defined in the object frame. We represent Eqn. \eqref{gpoc} by $g_i(\mathcal{X}) = 0$.

\begin{figure}[htbp]
\centerline{\includegraphics[width = 240px]{figure/Schematic/SelfCollision1.eps}}
\caption{The infinite convex wedge for $i-th$ MMR is defined by the half plane $\mathcal{H}_i$, $\mathcal{H}_{(i+1)\%n}, z=0$ and $z=\infty$. The enclosing circles for MMRs' mobile base and manipulator are blue and violet, respectively, and the object is gray.}
\label{fig:soa}
\end{figure}
