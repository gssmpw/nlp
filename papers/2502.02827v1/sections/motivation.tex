\section{Problem Definition}\label{sec:mot}

Currently, there are three types of code generation tasks: function-level, file-level, and repo-level code generation. We mainly focus on the first two types of code generation since repo-level code generation involves different modules in the repositories and third-party dependencies, making it hard to obtain solid time efficiency measurements. To better illustrate the differences between function-level and file-level code generation, we present two examples in Figure~\ref{fig:probdef}.

\textbf{Function-level Code Generation.} Function-level code generation takes natural language functionality descriptions as input and generates a single function that satisfies the requirements.
The generated function accepts inputs through function parameters.
% and returns results via function return statements.
% Function-level code generation provides functionality descriptions in natural languages and requires a single function that satisfies the requirements.
The HumanEval~\cite{humaneval} and MBPP~\cite{mbpp} benchmarks are designed to benchmark function-level code generation.

% It is straightforward to generate test cases for the code solutions in function-level code generation. As the number of parameters in functions is determined and functions accept inputs only once from parameters before the function execution, we can generate test inputs for each parameter and combine them as a test case. For example, the function \textit{add()} in Figure~\ref{fig:probdef}(a) only has a parameter named \texttt{lst}, and we only need to generate test inputs for this parameter to build a test case. 

Figure~\ref{fig:probdef}(a) shows an example function.
We observe that the function \textit{add()} only has a parameter named \texttt{lst}, and we only need to generate test inputs for this parameter to build a test case.
This shows that the number of parameters in functions is determined and functions accept inputs only once from parameters before the function execution.
Therefore, \textbf{to generate test cases for function-level code generation, we can generate test inputs for each parameter and combine them as a test case.}


% To generate test cases for function-level code generation, we can generate test inputs for each parameter and combine them as a test case.
% This is because the number of parameters in functions is determined and functions accept inputs only once from parameters before the function execution.
% For example, the function \textit{add()} in Figure~\ref{fig:probdef}(a) only has a parameter named \texttt{lst}, and we only need to generate test inputs for this parameter to build a test case.

\begin{figure}[t]
    \centering
    \includegraphics[width = 1.0\textwidth]{figures/def.pdf}
    \caption{Examples for function-level and file-level code generation.}
    \label{fig:probdef}
\end{figure}


\textbf{File-level Code Generation.} File-level code generation generates a complete program file instead of a single function to satisfy specified requirements. 
The inputs of the program file are managed by \textit{standard input (stdin)} related APIs, e.g., \textit{input()}.
File-level code generation tasks frequently appear in coding competitions, based on which researchers built Code Contests~\cite{codecontests} and APPS~\cite{apps} benchmarks.
% In code solutions from file-level code generation, inputs, and outputs are not handled by function parameters and function return values. Instead, they  

% As \textit{standard input (stdin)} and \textit{standard output (stdout)} related APIs can be called in any location of the generated code solution, the generated code solution can accept inputs multiple times, and previous inputs can affect the following inputs. For example, the code solution in 

Figure~\ref{fig:probdef}(b) shows an example program file.
We observe that this code solution accepts inputs in two locations (highlighted in blue). The input in the first location is used to control how many times the input in the second location will take.
This indicates that \textbf{the number of inputs for program files is not only determined by the code solution but also by the inputs.}
This poses great challenges in generating test cases for file-level code generation.

% As \textit{standard input (stdin)} and \textit{standard output (stdout)} related APIs can be called in any location of the generated code solution, the generated code solution can accept inputs multiple times, and previous inputs can affect the following inputs. For example, the code solution in Figure~\ref{fig:probdef}(b) accepts inputs in two locations, and we highlight the input statements with blue color. The input in the first location is used as the iteration number that controls how many times the input in the second location will execute.
% This indicates that the number of inputs is not only determined by the code solution but also by the inputs in previous locations. This poses great challenges in generating test cases for file-level code generation.


 



