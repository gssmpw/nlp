To obtain properties about distributed systems is a difficult task.
Indeed, such systems generally involve an arbitrary number of
participants, interconnected and communicating according to arbitrary
or specific topologies.  Their execution could be suject to various
assumptions about the degree of asynchronism between participants.
The context in which those systems are considered is increasingly
complex, for example, large scale distributed systems, made of
hererogenous devices, running in higly dynamic networks. Above all,
every nowadays distributed system requires some fault tolerance
properties which are particularly difficult to handle.  Therefore, the
proofs for distributed algorithms quickly become complex and may lead
to errors \cite{Lamport2012}.

In this context, the common practice for establishing the correctness
of distributed algorithms was to provide proofs on paper. But,
computer-aided validation tools are being developped as an answer to
improve those practices.  In particular, many approaches are based on
model-checking (see \eg, \cite{DBLP:journals/sttt/BertrandKLW21},
\cite{Tsuchiya01}) or controller synthesis (see \eg,
\cite{Ebnenasir22}, \cite{DBLP:journals/dc/VolkBKA22}).  However,
those methods usually face the huge execution space, restricting
their applicability. Furthermore, they either require to completely
define the full context of execution (such as the number of
participants, the topology of the network, etc) or to provide
parametric solutions which are often restricted due to undecidability
limitations \cite{DBLP:series/synthesis/2015Bloem}.

On the other hand, the use of a proof assistant such as Coq \cite{coq}
allows to formalize the proofs and automatically check (a.k.a certify)
their correctness for a given distributed algorithm, for every value
of parameters such as the topology or the number of participants.
Note that a proof assistant is not meant to derive any proof: the
proof designer comes with (at least) a sketch of proof and the tool is
used as a guidance to enumerate cases, avoid flaws and clarify the
assumptions. Once completed, the proof has been fully checked by the
tool and its soundness is guaranteed. Many frameworks have been
developped to certify the proof of some distributed algorithms using
various proof assistant such as Coq \cite{ACD7,Courtieu02,pactole},
TLA+ \cite{CDLMRV12c,tla} or Isabel/HOL \cite{berni,JM05tr,KNR12}.

We focus here on distributed self-stabilizing
algorithms. Self-stabilization \cite{D74j} is a lightweight fault
tolerance property to withstand transient faults: once such faults hit
a self-stabilizing system, this one is guaranteed to recover a correct
behavior within finite time. Note that no assumption is made on the
nature of the transient faults (memory corruption, topology changes,
etc). But, once those faults cease, there is a finite period - the
stabilization time - during which the system may misbehave (notably
its safety guaranties are no longer ensured during this recevory
period).  In this paper, we are interested in the proof of
self-stabilization of a BFS spanning tree algorithm by Dolev \emph{et
al} \cite{DIM93}.

\paragraph{Related Work}

The correctness of several non fault-tolerant distributed algorithms
have been certified, (see \eg, \cite{CF11j,HESSELINK20131622}).
Certification of fault-tolerant, yet non self-stabilizing, distributed
systems has been addressed using various proof assistants, {\em e.g},
in Isabel/HOL \cite{CM09j,JM05tr,berni,KNR12}, TLA+
\cite{CDLMRV12c,DFGL13c}, Coq \cite{RVVV18c}, NuPRL~\cite{RGBC17j}.
This approach is called {\em robust} fault tolerance; it masks the
effect of the faults (whereas self-stabilization is non-masking by
essence). In the robust approach, many results are related to
agreement problems, such as consensus or state-machine replication, in
fully connected networks; and many works only certify the safety
property of the considered
problem (see \eg, \cite{CDLMRV12c,DFGL13c,RGBC17j,RVVV18c}).
However, both liveness and safety properties are certified
in \cite{CM09j,KNR12,berni}.
Finally, robust fault tolerance has been also considered in the
context of mobile robot computing: using the PACTOLE Coq framework,
impossibility results for swarms of robots that are subjected to
Byzantine faults have been certified \cite{bouzid13sss,CRTU15}.


Several frameworks to certify self-stabilizing algorithms using the
Coq proof assistant have been proposed, \eg, \cite{Courtieu02,ACD7}.
In particular, the PADEC Coq library provides a framework to develop
proofs of self-stabilizing algorithms written in the atomic state
model \cite{D74j}, and allows many various assumptions defined in
the litterature. For instance, the asynchronism of the system can be
defined using several levels of fairness.
Notably, it includes support and use cases that prove the composition
of self-stabilizing algorithms \cite{DBLP:conf/forte/AltisenCD19},
their time complexity in steps \cite{ACD21c} and
rounds \cite{AltisenCD23} (Rounds provide a measure of time taking
into account the parallelism of the system whereas steps provide a
sequential measure).

The research on proving termination (\ie\ convergence) of distributed
algorithms is extremely vast. Usually, formal techniques such as
ranking/potential functions (\eg, \cite{ACD21c}), well-founded orders
(\eg, \cite{ACD7}) provide direct means to prove the termination
over all executions.  Alternatively, by the principle of the excluded
middle, termination follows from a proof of the absence of
non-terminating runs.  That is, proofs of termination by contradiction
usually exhibit contradictions in the case non-terminating executions
are presumed possible.  The principle of the excluded middle is,
however, not allowed in constructive proofs \eg, based on
intuitionistic logics and hence impossible to use in constructive
proof assistants such as Coq \cite{coqart}
(unless changing the basic set of axioms).

\paragraph{Contributions}
In this paper, we revisit the proof of convergence of the
self-stabilizing Dolev \emph{et al} BFS spanning tree
algorithm \cite{DIM93}.  The first proof of convergence of this
algorithm has been provided in \cite{DIM93}, that is, the same paper
where the algorithm has been introduced; but this proof is restricted
to some restricted fairness assumptions.  Since then, other proofs
have been proposed.
As \cite{DIM93}, \cite{thebook} proves the self-stabilization of the
algorithm under the mild assumption of a weakly fair daemon, that is,
by restricting the asynchronism along the executions of the algorithm;
this proof has been formalized, developped and mechanically checked in
PADEC \cite{AltisenCD23}.
While relaxing the fairness assumption,
\cite{thebook} also provides a non-constructive proof, by
contradiction, working under the explicit assumption that the diameter
of the graph is a priori known and used as a bound on some of the
variables of the algorithm.

In this paper, still with no fairness assumption, we provide, a
contrario, a constructive proof of the result which has been fully
formalized and mechanically checked in PADEC.
Our contribution is twofold:
\begin{itemize}
\item We provide the first constructive proof of the convergence of
  the Dolev \emph{et al} BFS Spanning Tree algorithm under the most
  general execution assumptions (\ie, unfair daemon, unbounded
  variables). The proof exploits a novel potential function, allowing
  for a finer comprehension of the system executions towards
  convergence.
\item The convergence proof has been fully formalized and
  automatically checked using the PADEC framework.  The result can be
  therefore fully trusted and moreover, illustrates the capabilities
  of the PADEC framework to formally handle distributed algorithms and
  their properties.
\end{itemize}

\paragraph{Coq Development.}  The development for this contribution
represents about 5,155 lines of Coq code (\lstinline|#loc|, as
measured by \lstinline|coqwc|), precisely
\lstinline|#loc: spec = 1,111;|
\lstinline|proof = 3,662;| \lstinline|comments = 382|.  It
 is available as an online browsing documentation at
\url{http://www-verimag.imag.fr/~altisen/PADEC}. We encourage the
reader to visit this web-page for a deeper understanding of our work.

\paragraph{Organization.} The paper is organized as follows.
Section \ref{sec:dolev} recalls the Dolev \emph{et al} algorithm for
the construction of BFS spanning trees.  Section \ref{sec:padec}
provides a brief overview of the PADEC framework and the formal
encoding of the above-mentioned algorithm and its relevant properties.
Section \ref{sec:proof} provides the proof of convergence.  Section
\ref{sec:dstep-potential} elaborates on the definition of the
potential function over system configurations, that is, the key
ingredient ensuring that the proof is constructive and therefore
representable in PADEC.  Finally, Section \ref{sec:conclusion}
concludes and provides directions for future work.
