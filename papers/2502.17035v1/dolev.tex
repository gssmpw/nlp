The Dolev \emph{et al}'s BFS algorithm~\cite{DIM93} is a
self-stabilizing distributed algorithm that computes a BFS spanning
tree in an arbitrary rooted, connected, and bidirectional network.  By
``bidirectional'', we mean that each node can both transmit and
acquire information from its adjacent nodes in the network topology,
\ie, its neighbors.  The algorithm being distributed, these are the
only possible direct communications.  ``Rooted'' indicates that a
particular node, called the root and denoted by \Root, is
distinguished in the network. As in the present case, algorithms for
rooted networks are usually semi-anonymous: all nodes have the same
code except the root.

This algorithm was initially written in the Read/Write atomicity
model. We study, here, a straightforward translation into the
\emph{atomic-state model}, denoted hereafter by \BFS, and presented as
Algorithm~\ref{alg}. Notice that, as in the original presentation
\cite{DIM93} and contrarily to other adapations (see \eg,
\cite{thebook}), the variables are not assumed to be bounded.

\begin{algorithm}[htp]
  
  \textbf{Constant Local Inputs:} \hfill\
  
  \begin{tabular}{l}
    $p.\mathit{neighbors} \subseteq \channels$; $p.root \in\{true, false\}$ \\
     \emph{/* $p.\mathit{neighbors}$, as other sets below, are implemented as lists */}
  \end{tabular} \hfill\ 

\smallskip
  
  \textbf{Local Variables:} \hfill\
  
  \begin{tabular}{l}
    $p.d \in \mathds N$; $p.par \in \channels$
  \end{tabular} \hfill\ 

\smallskip
  
  \textbf{Macros:} \hfill\
  
  \begin{tabular}{l}
    $Dist_p = \min \{ q.d + 1, q \in p.\mathit{neighbors} \}$ \\
    $Par_{dist}$ returns the first channel in the list $\{ q \in p.\mathit{neighbors},
    q.d + 1 = p.d \}$
  \end{tabular} \hfill\ 

  \smallskip
  
  \textbf{Action for the root, \ie, for $p$ such that $p.root = true$} \hfill\ 

  \begin{tabular}{ll}
    Action $Root$: & \textbf{if} $p.d \neq 0$ \textbf{then} $p.d := 0$
 \end{tabular} \hfill\ 

  \smallskip
  
  \textbf{Actions for any non-root node, \ie, for $p$ such that $p.root = false$} \hfill\ 
  
  \begin{tabular}{ll}
   Action $CD$:
    & \textbf{if} $p.d \neq Dist_{p}$ \textbf{then} $p.d := Dist_{p}$ \\
     Action $CP$:
    &  \textbf{if} $p.d = Dist_p$ and $p.par.d + 1 \neq p.d$ \textbf{then} $p.par := Par_{dist}$ 
  \end{tabular}  \hfill\ 

   \caption{Algorithm \BFS, code for each node $p$.}
  \label{alg}
\end{algorithm}

In the \emph{atomic-state model}, nodes communicate through locally
shared variables: a node can read its variables and the ones of its
neighbors, but can only write to its own variables. Every node can
access the variables of its neighbors through local channels, denoted
by the set $\channels$ in Algorithm~\ref{alg}.
The network is locally defined at each node $p$ using constant local
inputs.  The fact that the network is rooted is implemented using a
constant Boolean input called $p.root$ which is false for every node
except \Root. The input $p.\mathit{neighbors}$ is the set of channels linking
$p$ to its neighbors.  When it is clear from the context, we do not
distinguish a neighbor from the channels to that neighbor.

The code of Algorithm~\ref{alg} is given as three
locally-mutually-exclusive actions written
as: \textbf{if} \emph{condition} \textbf{then} \emph{statement}. We
say that an action is \emph{enabled} when its condition is true. By
extension, a node is said to be enabled when at least one of its
actions is enabled.
According to the algorithm, the \emph{semantics of the system} defines an
execution as follows.  The system
current \emph{configuration} is given by the current value of all
variables at each node.  If no node is enabled in the current
configuration, then the configuration is said to be \emph{terminal}
and the execution is over.  Otherwise, a \emph{step} is performed:
a \emph{daemon} (an oracle that models the asynchronism of the
system) \emph{activates} a non-empty set of enabled nodes.  Each
activated node then \emph{atomically executes} the statement of its
enabled action, leading the system to a new configuration.

Assumptions can be made about the daemon. Here, we consider the most
general asynchrony assumption, namely the \emph{unfair} daemon,
meaning that it can choose any non-empty subset of the enabled nodes
for execution. In contrast, \emph{fair} daemons would guarantee
additional properties.  For example, a
\emph{strongly} (resp. \emph{weakly}) \emph{fair} daemon ensures that
every node that is enabled infinitely (resp. continuously) often is
eventually chosen for execution by the daemon.

In Algorithm \BFS, each node $p$ maintains two variables. First, it
evaluates in $p.d$ its distance to the root. Then, it maintains
 $p.par$ as a pointer to its \emph{parent} in the tree under
construction: $p.par$ is assigned to a neighbor that is closest to the
root (\nb, \Root.$par$ is meaningless).
Algorithm \BFS is a self-stabilizing BFS spanning tree construction in
the sense that, regardless the initial configuration, it makes the
system converge to a terminal configuration where $par$-variables
describe a BFS spanning tree rooted at \Root.
To that goal, nodes first compute into their $d$-variable their distance
to the root. The root simply forces the value of \Root.$d$ to be 0;
see  Action $Root$. Then, the $d$-variables of other nodes
are gradually corrected: every non-root node $p$ maintains $p.d$ to
be the minimum value of the $d$-variables of its neighbors incremented
by one; see $Dist_{p}$ and Action $CD$.
In parallel, each non-root node $p$ chooses as parent a neighbor $q$
such that $q.d = p.d-1$ when $p.d$ is locally correct \ie, $p.d =
Dist_{p}$) but $p.par$ is not correctly assigned \ie, $p.par.d$ is not
equal to $p.d-1$); see Action $CP$.


