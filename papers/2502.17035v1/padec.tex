PADEC~\cite{ACD7} is a general framework, written in
Coq \cite{coqart}, to develop mechanically checked proofs of
self-stabilizing algorithms.  It includes the definition of the
atomic-state model and its semantics, tools for the definition of the
algorithms and their properties, lemmas for common proof patterns, and
case studies.  Definitions in PADEC are designed to be as close as
possible to the standard usage of the self-stabilizing community.
Moreover, it is made general enough to encompass many usual hypothesis
(\eg, about topologies or daemons).

In PADEC, the finite network is described using types \Nodes
and \Channels, 
which respectively represent the nodes and the links between nodes.
The distributed algorithm is defined by providing a local
algorithm at each node. This latter is defined using a type
\States 
that represents the local state of a node
\ie, the values of its local variables and a function $\mathit{run}$
that encodes the local algorithm itself and computes a new state
depending on the current state of the node and that of its neighbors.

The model semantics defines a \emph{configuration} as a function
from \Nodes to \States that provides the local state of each node.
The type of a configuration is given by
$\Env \isdef \Nodes \rightarrow \States$.  An \emph{atomic step} of
the distributed algorithm is encoded as a binary relation over
configurations, denoted by $\Step \subseteq \Env \times \Env$, that
checks the conditions given in the informal model; see
Section~\ref{sec:dolev}.  An \emph{execution} $e$
is a finite or infinite stream of configurations, which models a
\emph{maximal} sequence of configurations where any two consecutive
configurations are linked by the $\Step$ relation.  ``Maximal'' means
that $e$ is finite if and only if its last configuration is
terminal. We use the coinductive\footnote{Coinduction allows to define
and reason about potentially infinite objects.}  type $\mathit{Exec}$
to represent an execution stream along with a coinductive predicate
$\mathit{isExec}$
to check the above condition.
Daemons are also defined as predicates over executions (in the case of
the unfair daemon, this predicate is simply equal
to $\mathit{true}$).

Self-stabilization in PADEC is defined according to the usual
practice: the property is formalized as a predicate
$(\mathit{selfStabilization} \;\; \mathit{SPEC})$
where $\mathit{SPEC}$ is a predicate over executions
and models the specification of the algorithm.  An algorithm
is \emph{self-stabilizing w.r.t. the specification}
$\mathit{SPEC}$ if there exists a set of legitimate configurations
that satisfies the following three properties in every
execution $e$:
\begin{itemize}
\item \underline{\emph{Closure}}:
  if $e$ starts in a legitimate configuration then $e$ only contains
  legitimate configurations;
\item \underline{\emph{Convergence}}:
  $e$ eventually reaches a legitimate configuration; and
\item \underline{\emph{Specification}}:
  if $e$ starts in a legitimate configuration then $e$ satisfies the
  intended specification w.r.t. $\mathit{SPEC}$.
\end{itemize}
An algorithm is said to be \emph{silent} when each of its executions
eventually reaches a terminal configuration; in such a case, the set
of legitimate configurations can be chosen as the set of terminal
configurations.  The closure, convergence, and silent properties are
expressed using Linear Time Logic operators provided in the PADEC
library.

\subsection*{The \BFS Algorithm in PADEC}

For the \BFS Algorithm and its specification, we use the formal encoding
provided in \cite{AltisenCD23}; in particular, the algorithm is a
straightforward faithful translation in Coq of
Algorithm \ref{alg}. Notably, an element of \States,
namely a state of a given node, is a tuple
$(d, \mathit{par}, \mathit{root}, \mathit{neighbors})$ representing
the variables of the node as in Algorithm~\ref{alg}.

As the constant variables $\mathit{root}$ and $\mathit{neighbors}$
represent the network, the assumptions that this network is rooted,
bidirected and connected is encoded in a predicate on a configuration
using only those variables. This predicate, in particular uses the set
of edges of the network $\Edges \isdef \{ (p, q) \;|\; p,
q \in \Nodes \;\wedge\; (p \in q.\mathit{neighbors} \;\vee\; q \in
p.\mathit{neighbors}) \}$. Globally in this precidate, the neighbor
links represent a bidirected connected graph and the Boolean
$\mathit{root}$ should be true for a unique node.
We will assume moreover that this predicate holds for any
configuration, even if this is no more mentionned in the sequel.

In \cite{AltisenCD23}, the \BFS Algorithm was proven using PADEC to be
self-stabilizing and silent for the specification of a BFS spanning
tree, \emph{under the assumption of a weakly fair daemon}.  We extend
here this result to the \emph{unfair daemon}.  Note that, since \BFS
is silent, the properties of closure and specification still hold,
henceforth, relaxing the assumption from a weakly fair to an unfair
daemon is trivial.  The only missing property is the convergence.  The
rest of the paper is therefore focusing on proving the convergence of
the \BFS Algorithm under an unfair daemon in PADEC, \ie, providing a
constructive proof under the form of a potential function and its
corresponding order.
