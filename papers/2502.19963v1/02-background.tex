\section{Background}%
\label{sec:background}
\paragraph{Notation and terminology.}
We assume the standard setting with quantifier-free first-order formulas, and
the standard notions of theory, satisfiability, logical consequence. We assume the reader is familiar with
these notions and with
the lazy CDCL-based SMT-solving approach, and refer to~\cite{barrettSatisfiabilityModuloTheories2021} for
a comprehensive introduction to SMT.

In this paper, we denote SMT formulas by $\vi$, theories by $\T$, variables by $x,y$, atoms by $\alpha$, truth assignments by $\mu,\eta$, and models by $\M$; all symbols possibly with subscripts or superscripts.
We denote by \atoms{\vi} the set of atoms occurring in a formula \vi.

\subsection{Satisfiability Modulo Theories}%
\label{sec:bg:smt}
Given a first-order theory \T, a \T-atom is any atomic formula built over the signature of \T. A \T-literal is a \T-atom or its negation. A \T-formula is either a \T-literal or a combination of formulas by means of standard Boolean operators. From now on, we assume every formula is in Conjunctive Normal Form
(CNF), i.e., it is a conjunction ($\wedge$) of clauses, where each clause is a
disjunction ($\vee$) of literals. (If it is not, then it can be easily
converted into CNF by applying the standard
transformations~\cite{plaistedStructurepreservingClauseForm1986,tseitinComplexityDerivationPropositional1983}).

Satisfiability Modulo Theories (SMT) is the problem of deciding the
satisfiability of a first-order formula w.r.t\ some first-order theory
\T, or combination of first-order theories $\T_1 \cup \T_2$. A formula is
\T-satisfiable if it is satisfiable in a model of \T (also written as T-model).
Popular theories include linear and nonlinear arithmetic over the reals or
integers (\larat, \nlarat, \laint, and \nlaint, respectively), bit-vectors
(\bv), and floating-point (\fl).

\paragraph{Lazy SMT-solving.}

Given a formula $\vi$ with $\atoms{\vi}\defas\{\alpha_1,\ldots,\alpha_n\}$, a
truth assignment $\mu : \atoms{\vi} \to \{\top, \bot\}$ is a mapping from atoms
in $\vi$ to truth values. A partial truth assignment is a partial mapping, and
a total truth assignment is a total mapping. We represent a truth assignment
$\mu$ also as a conjunction of literals $\bigwedge_{\mu(\alpha_i)=\top}\alpha_i
  \wedge \bigwedge_{\mu(\alpha_i)=\bot}\neg\alpha_i$.
%We denote by \residual{\vi}{\mu} the residual formula of $\vi$ under $\mu$, i.e., the formula resulting from substituting each atom $\alpha_i$ with $\mu(\alpha_i)$ in $\vi$, and propagating the truth values through the Boolean connectives.
%
We say that $\mu$ \emph{propositionally satisfies} $\vi$ iff $\mu$ satisfies
all clauses in $\vi$.
% A model M maps variables to elements
% of the domain, and predicate, function and constant symbols to
% relations, functions and elements of the domain, respectively; atoms
% and formulas are mapped into truth values consequently.

The CDCL(\T) algorithm~\cite{marques-silvaConflictDrivenClauseLearning2021} is based on the so-called lazy approach to SMT (see
e.g.,~\cite{sebastianiLazySatisfiabilityModulo2007,barrettSatisfiabilityModuloTheories2021}),
which exploits the fact that a \T-formula $\vi$ is \T-satisfiable iff there
exists a truth assignment $\mu$ that propositionally satisfies $\vi$ and $\mu$
is \T-satisfiable.
%
It combines a CDCL-based SAT-solver with a \T-specialized decision procedure
called \T-solver to decide the consistency of a set of \T-constraints. Whenever
the SAT-solver finds a truth assignment $\mu$ propositionally satisfying $\vi$,
it invokes the \T-solver to check the \T-satisfiability of $\mu$. If $\mu$ is
\T-satisfiable, then the \T-solver returns a model $\M$, that is also a model
of $\vi$. Otherwise, the \T-solver returns a subset of $\mu$ that causes the
\T-unsatisfiability, which is learned by the SAT-solver and used in subsequent
iterations to prune the search space.
%
%Possible optimizations are early pruning and \T-propagation. If
%the \T-solver is invoked also on partial assignments under construction, then it can detect in advance if a partial assignment is
%\T-unsatisfiable. Instead, if the partial assignment is satisfiable, then
%the \T-solver may be able to deduce the truth value of some atoms
%that are not assigned yet, and the SAT-solver can learn and propagate
%the new information. 

% A possible optimization is pure-literal filtering~\cite{sebastianiLazySatisfiabilityModulo2007}, by which negative
% \resp{positive} literals of atoms that appear only positively \resp{negatively}
% in the original formula are removed from the truth assignment to be checked by
% the \T-solver. Intuitively, since such occurrences play no role in satisfying
% the formula, the resulting partial assignment still propositionally satisfies
% the formula. The benefits of this action are twofold:
% \begin{enumerate*}[label=(\roman*)]
%   \item\label{item:partial-benefit:workload} it reduces the workload for the \T-solver by feeding it smaller sets;
%   \item\label{item:partial-benefit:chance-sat} it increases the chances of finding a theory consistent satisfying assignment by removing literals that may cause the \T-unsatisfiability.
% \end{enumerate*}
% \GMSIDENOTE{Togliere pure-literal filtering? Oppure richiamarlo anche dopo?}

To maximize efficiency, most \T-solvers can be called incrementally via a
stack-based interface, keeping the status of the search between calls.
E.g.,~\cite{dutertreFastLinearArithmeticSolver2006} proposed an efficient
incremental \larat-solver, based on a variant of the Simplex algorithm designed
to be integrated within a lazy SMT framework. The combination of theories can be handled efficiently by delayed theory
combination~\cite{bozzanoEfficientTheoryCombination2006}.

Another important feature of CDCL-based SMT solvers is that they provide a
stack-based incremental interface, allowing to push and pop clauses and
incrementally check the satisfiability of the formula conjoined with the pushed
clauses, maintaining most of the learned information between calls.

%\TODO{Describe the Simplex-based algorithm for linear arithmetic?}

% \paragraph{\larat-solver based on the Simplex algorithm.}
% Most SMT solvers implement a variant of the Simplex-based algorithm by Dutertre and de Moura~\cite{dutertreFastLinearArithmeticSolver2006}, which is designed for integration within CDCL(\T), since it is fully incremental and backtrackable.

% The algorithm transforms the original formula into an equisatisfiable formula whose satisfiability is decided by solving a series of problems requiring to find $x \in \R^n$ such that $Ax = 0$ and $l_i \leq x_i \leq u_i$ for $i = 1,\dots, n$. 

% Variables $x_i$ are partitioned into basic variables $B$ and nonbasic variables $N$.
% The algorithm maintains a tableau representing the matrix $A$, in the form
% \begin{equation}%
%   \label{eq:tableau}
%   x_i = \sum_{x_j \in \N} a_{ij} x_j \quad \text{for $x_i \in B$}.
% \end{equation}

% Additionally, the algorithm maintains upper and lower bounds $l_i$ and $u_i$ for every variable $x_i$ and a mapping $\beta$ that assigns a rational value $\beta(x_i)$ to every variable $x_i$. The bounds on nonbasic variables are always satisfied by $\beta$, that is, the following invariant is maintained
% \begin{equation}%
%   \label{eq:bounds-invariant}
%   \forall x_j \in N, \quad l_j \leq \beta(x_j) \leq u_j.
% \end{equation}

% The solver state includes a tableau derived from the constraint matrix A. We will write such a tableau in the form:  xi =  ∑  xj ∈N  aij xj xi ∈ B,  where B and N denote the set of basic and nonbasic variables, respectively.3 Since all rows of this tableau are linear combinations of rows of the original matrix A, the  equality xi = ∑  xj∈N aij xj is satisfied by any x such that Ax = 0. In addition to this tableau, the solver state stores upper and lower bounds li and ui for every variable xi and a mapping β that assigns a rational value β(xi) to every variable xi. The bounds on nonbasic variables are always satisfied by β, that is, the following invariant is maintained  ∀xj ∈ N , lj ≤ β(xj ) ≤ uj. (4)  Furthermore, β satisfies the constraint Ax = 0. In the initial state, lj = −∞, uj = +∞, and β(xj ) = 0 for all j.

\subsection{Optimization Modulo Theories}%
\label{sec:bg:omt}
Let \T{} be a theory admitting some total order relation ``$\leq$'' over its
domain, let \vi{} be a \T-formula, and let \obj{} be a \T-term which we call
\emph{objective function}. \emph{Optimization Modulo Theories (\omt)} is the problem
of finding a model for \vi{} that makes the value of \obj{} minimum according
to the order given by $\leq$ (maximization is
dual)~\cite{bigarellaOptimizationModuloNonlinear2021,sebastianiOptimizationSMTLAQ2012}.
To simplify the presentation, we focus on minimization, but the same concepts
apply to maximization as well. Notice that, in general, \vi{} can be built on a
combination of \T with other theories~\cite{sebastianiOptimizationSMTLAQ2012}.
To simplify the explanation and the notation, we refer to one single
theory.

\begin{example}%
  \label{ex:smt}
  Consider the \larat-formula on the real variables $x, y$:
  \begin{equation}%
    \label{eq:smt}
    \begin{array}{ll}
      \vi\defas & ((2x-3y\leq 6)\vee(x\leq 4))\wedge    \\
                & ((y\leq 2)\vee(y\leq-3x+9)\vee(x<-2)).
    \end{array}
  \end{equation}
  \vi{} is \larat-satisfiable, e.g., the \larat-model $\M\defas\set{x\mapsto{} 3, y\mapsto{} 0}$ satisfies $\vi$.

  Consider the \omlarat{} problem \pair{\vi}{\obj} where $\vi$ is the
  \larat-formula in~\eqref{eq:smt}, and $\obj\defas-2x$. Then the model
  $\M\defas\set{x\mapsto{} 3, y\mapsto{} 0}$ has $\obj=-6$. A better model of
  \vi{} is, e.g., $\Mprime\defas\set{x\mapsto{} 6, y\mapsto{} 2}$, that has
  $\obj=-12$. This model is also the model of \vi{} with minimum cost.
\end{example}

\paragraph{Lazy OMT solving.}%
\label{sec:omt-solving}

A general optimization strategy implemented by state-of-the-art \omt{} solvers
is the so-called \emph{linear-search}
strategy~\cite{nieuwenhuisSATModuloTheories2006,sebastianiOptimizationSMTLAQ2012,sebastianiOptimizationModuloTheories2015}.
It consists in solving a sequence of \smt{} problems where the space of
feasible solutions is progressively tightened by learning unit clauses in the
form $(\obj < \ub)$, \ub{} being the currently-known upper bound for \obj. At
each iteration, the solver can either find a model $\M$ whose value of \obj{}
is smaller than \ub{}, or detect the unsatisfiability of the current formula.
In the first case, the solver invokes a \T-specific procedure, called
\emph{\T-minimizer}, to find an optimum model $\Mprime$ within the truth
assignment induced by \M. E.g., a
\larat-minimizer{}~\cite{sebastianiOptimizationSMTLAQ2012} can be implemented
as a simple extension of the Simplex-based
\larat-solver~\cite{dutertreFastLinearArithmeticSolver2006,sebastianiOptimizationSMTLAQ2012}. Then, the new
upper bound is set to the value assigned to \obj{} by \Mprime{}, and the search
continues. In the second case, the formula has no models with \obj{} lower than
\ub{}, and the search terminates as the last model found is optimum.

% \GMSIDENOTE{Remove the following?}
Alternatively, the solver could also follow a \emph{binary-search}
strategy~\cite{sebastianiOptimizationSMTLAQ2012}. In this case, a lower and
upper bound \lb{} and \ub{} are kept s.t.\ the optimum model lies in the
interval $\mathopen(\lb{},\ub{}\mathclose]$. At each iteration, an intermediate
value $\pivot{}\in\mathopen(\lb{},\ub{}\mathclose]$ is chosen, and the solver
checks if there exists a model with \obj{} lower than \pivot{}. If so, \pivot{}
becomes the new upper bound, otherwise, it becomes the new lower bound. The
search terminates when \lb{} and \ub{} are equal, and the last model found is
optimum. (In continuous domains, e.g., \omlarat{}, to guarantee termination, it
is necessary to interleave binary-search steps with a linear-search
step~\cite{sebastianiOptimizationSMTLAQ2012}).
%  In this case, the solver starts with initial lower (\lb{}) and upper (\ub) bounds, and at each iteration it chooses an intermediate value \pivot{} between \lb{} and \ub{}, and checks if there exists a model with \obj{} lower than \pivot{} by assuming temporarily the clause $(\obj < \pivot)$. If it exists, then the solver updates \ub{} with the value associated to \obj{} by such model and proceeds to the next iteration. Otherwise, it sets \lb{} to \pivot{} and continues the search in the interval between \pivot{} and \ub{}, dropping $(\obj < \pivot)$ and adding $(\obj \geq \pivot)$ to the formula.
% The search terminates when \lb{} and \ub{} are equal, and the last model found is optimum. In continuous domains (e.g., \omlarat{}), to guarantee termination, it is necessary to interleave binary-search steps with a linear-search step~\cite{sebastianiOptimizationSMTLAQ2012}.
%
In this paper, we focus on the linear-search strategy, but the analysis applies
to the binary-search strategy as well.

% \paragraph{Anytime OMT solving.}%
% \label{sec:anytime-omt-solving}
The lazy OMT solving approach allows for an \emph{anytime} behavior, i.e., we can interrupt the search at any time and return the best model found so far. 

\subsection{SAT and SMT Enumeration}%
\label{sec:bg:partial-truth-assignments}

\begin{algorithm}[t]
  \begin{algorithmic}[1]
    %\begin{rschange}
    \caption[A]{{\minimizeassignment}($\vi, \eta$)\\
      \hspace*{\algorithmicindent}\textbf{Input}:
      CNF formula $\vi$, \T-satisfiable total truth assignment $\eta$ satisfying $\vi$\\
      \hspace*{\algorithmicindent}\textbf{Output}: Reduced (minimal) partial truth assignment $\mu\subseteq\eta$ satisfying $\vi$}%
    \label{alg:minimize}
    \STATE $\mu \leftarrow \eta$
    \FOR{$\ell\in\mu$}
    \IF{$\mu\setminus\set{\ell}$ satisfies all clauses in $\vi$}
    \STATE $\mu \leftarrow \mu \setminus \set{\ell}$
    \ENDIF
    \ENDFOR
    \RETURN $\mu$
    %\end{rschange}
  \end{algorithmic}
\end{algorithm}

SAT enumeration (AllSAT) is the problem of finding all the truth assignments
that propositionally satisfy a propositional formula. \smt{} enumeration
(AllSMT) is the problem of finding all \T-satisfiable truth assignments that
propositionally satisfy a \T-formula. Since a partial assignment can be
extended to $2^k$ total truth assignments, $k$ being the number of unassigned
atoms, finding short partial truth assignments is a key point in reducing both
the number of enumerated truth assignments and the computational time by up to
an exponential factor.

Many enumeration algorithms find total truth assignments, and then
extract partial truth assignments from them by some reduction procedure. A
basic reduction procedure is illustrated in~\Cref{alg:minimize}. It consists in
iteratively dropping literals one-by-one from the truth assignment, checking if
it still satisfies the formula. The resulting partial assignment is minimal,
i.e., it cannot be further reduced without violating the satisfaction of the
formula. Notice that the order in which literals are dropped can have a significant impact
on the effectiveness of the reduction procedure. %\TODO{CNF?}