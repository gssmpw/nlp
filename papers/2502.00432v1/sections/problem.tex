%%%%%%%%%%%%%%%%%%%%%%
%%% CMH EXAMPLE FIGURE
%%%%%%%%%%%%%%%%%%%%%%

\begin{figure*}[t]
    \centering
    % Prima immagine
    \subfloat[Target node $u$ and the communities $f(\graph)$ detected by the \textit{Louvain} algorithm.]{%
        \includegraphics[width=0.3\linewidth]{sections/images/old_communities_v2.png}%
        \label{fig:old_comm}}
    \hfill
    % Seconda immagine
    \subfloat[Counterfactual graph $\graph'$, where bold (red) edges represent deletions and dashed (green) edges indicate additions.]{%
        \includegraphics[width=0.3\linewidth]{sections/images/new_graph_v2.png}%
        \label{fig:new_graph}}
    \hfill
    % Terza immagine
    \subfloat[New communities $f(\graph')$ detected on $\graph'$. The objective is achieved if $sim(C_i - \{u\}, C'_i - \{u\})  \leq \tau$.]{%
        \includegraphics[width=0.3\linewidth]{sections/images/new_communities_v2.png}%
        \label{fig:new_comm}}
    \caption{Example of the Community Membership Hiding Problem on Karate Club network.}
    \label{fig:cmh_example}
    \vspace{-3mm}
\end{figure*}


%%% INTRO

Broadly speaking, \textit{community membership hiding} aims to prevent a specific node from being identified as part of a designated cluster by a community detection algorithm. This goal is accomplished by advising the target node on strategically adjusting its connections with others by acting on the adjacency matrix. Consequently, we aim to deceive algorithms that cluster nodes based exclusively on their structural properties.
%Although altering node features is an interesting avenue, it is beyond the scope of this work and is deferred to future research.

Hereinafter, we assume that we have access to the community detection algorithm $\f$ focusing exclusively on its input-output behavior without any insight or access to its internal workings, e.g., by accessing its APIs. Moreover, we assume to have full knowledge of the network.

%%%%%%%%%%%%%%%%%%%%%%
%%% PROBLEM DEFINITION
%%%%%%%%%%%%%%%%%%%%%%

\subsection{Problem Definition}
%\edo{Non mi è chiaro qui perché definiamo $p$ come una funzione parametrizzata da $\theta$, e poi in Equazione 3 e nello pseudocodice trattiamo $p$ come i parametri stessi da trovare. E' una incongruenza o mi sto perdendo qualcosa?}
%\matteo{$p_{\theta}$ è quella funzione che nel paper originale viene chiamata $h_{\theta}$. Invece di associarla ad un modello generico (come quello di RL), l'ho chiamata funzione di perturbazione, per quello ho pensato di chiamarla $p_{\theta}$}
%\edo{E' ambiguo, piuttosto chiamamola $h$ oppure troviamo un'altra lettera}
%\matteo{Va bene usare la stessa notazione $h_\theta$, e chiamarla ''funzione di perturbazione"?}
Let $\graph = (\nodes,\edges)$ be a graph and $f(\graph) = \{C_1 \dots C_k\}$ denotes the community partitioning obtained by applying a community detection algorithm $\f$. Furthermore, let's assume that $\f$ has identified the target node $u$ as a member of the community $C_i$ -- denoted as $u \in C_i$. The objective of the problem, as outlined by \citet{bernini2024kdd}, is to define a \textit{perturbation function} $h_{\theta}(\cdot)$, parametrized by $\theta$, which takes the original graph $\graph$ as input and produces a perturbed graph $h_{\theta}(\graph) = \graph' = (\nodes, \edges')$ as output. Out of all potential graphs, we aim to identify the one that, when processed by the community detection algorithm $f(\cdot)$, guarantees that the node $u$ is no longer associated with its original community. 
 
The definition of membership hiding can be interpreted differently based on the intended outcome. For instance, if a target node is assigned to a new community $C'_i$ in the perturbed graph $\mathcal{G}'$ according to $\f$, one way to define the hiding goal is to get a small similarity between the original community $C_i$ and the new one $C'_i$. Alternatively, hiding can involve ensuring that specific nodes from the original community do not belong to the new one. For example, if $C_i = \{ u,v,w,y,z \}$, we may want to assign $u$ to a new community $C'_i$ such that $y,z \notin C'_i$.
 %\gabri{Perché usiamo $C_i$ e $C'_j$ per riferirci alla comunità originaria e quella controfattuale? Non potremmo dire $C_i$ e $C'_i$ o $C_j$ e $C'_j$?}
 
In this work, we adopt the first definition, leaving the investigation of other options for future research. Specifically, given a similarity function  $sim(\cdot,\cdot)$ and a threshold $\tau$, we say that the community membership hiding task is achieved if the condition $sim(C_i - \{u\}, C'_i - \{u\})  \leq \tau$ is satisfied. We assume that $sim(\cdot,\cdot)$ ranges in $[0,1]$ and $\tau \in [0,1)$. Hence, when $ \tau = 0 $ the condition is at its most restrictive, requiring zero overlap between $C_i$ and $C'_i$, except for the node $u$ itself. The higher $\tau$ is, the easier it is to verify the condition, and thus it is simpler to achieve the hiding goal.
 
In general, the loss function for the community membership hiding task is expressed as follows:
\begin{equation}
    \small
    \mathcal{L}(h_{\theta}; \graph,f,u) = \ell_{\text{hide}}(h_{\theta},\graph;f,u) + \lambda \ \ell_{\text{dist}}(h_{\theta}(\graph),\graph;f) .
\end{equation}
The first term ($\ell_{\text{hide}}$) encourages $u$ to detach to its starting community, while the second term ($\ell_{\text{dist}}$) quantifies the ``distance" not only between $\graph$ and $\graph'$, but also between $f(\graph)$ and $f(\graph')$. This arises from the fact that perturbing the original graph inevitably impacts the entire community structure, as depicted in Fig. \ref{fig:cmh_example}, and the distance term ensures that such alterations are minimized as much as possible. Essentially, the second term acts as a penalty for significant changes, scaled by the weighting factor $\lambda$.
%Choosing a small $\lambda$ may result in achieving the objective but altering too much the structure of the target node's community, as well as other ones, too. This is in contrast to the underlying idea of having the optimal counterfactual graph, that is, the one with the smallest set of edits possible. In contrast, a large $\lambda$ will force the target node to make small changes that could lead the algorithm to fail the objective. 

For example, \citet{bernini2024kdd} propose a loss function where $\ell_{\text{hide}}$ works as a penalization term when the hiding goal is not reached, while $\ell_{\text{dist}}$ is a convex combination of two distances regarding $(\graph,\graph')$ and $(f(\graph), f(\graph'))$.
However, their 
%loss function poses challenges for optimization, as its first term is not continuous, and the second term is defined by a discrete function, making the 
overall loss is non-differentiable.  
To overcome this limitation, we introduce a novel loss function specifically designed to ensure differentiability, enabling the use of gradient-based optimization methods to solve the community membership hiding task. In Section \ref{subsec:loss} we provide a detailed discussion of our approach.

%%%%%%%%%%%%%%%%%%%
%%% GRAPH OBJECTIVE
%%%%%%%%%%%%%%%%%%%

\subsection{Searching for a Counterfactual Graph}
\label{sec:objective}

%\matteo{Teoricamente non mettiamo nessun vincolo nelle azioni, ma con la costruzione di $\Tilde{A}_u$ andiamo ad incentivare i soliti due tipi: rimozioni intra-comunità, aggiunte extra-comunità (non ho trovato neanche un esempio che mostra il contrario). Pensavo a qualcosa del tipo:}

%TODO: Da togliere e aggiungere a Sec. 5. LASCIARE GENERICO
%Similar to \citet{bernini2024kdd}, our approach modifies the graph by removing intra-community edges ($\edges_{u}^-$) and adding inter-community edges ($\edges_{u}^+$), where the former connect target node $u$ within its community, and the latter link $u$ to nodes outside it. This work adopts this formulation and leaves the exploration of all possible edge modifications to future research.


%\matteo{In realtà non ci differenziamo dal paper originale in questo aspetto, visto che effettuiamo solo quei due tipi di azione specifici. Questo lo si può vedere dall' Eq.\ref{eq:candlist}.}

Unlike the original method proposed by \citet{bernini2024kdd}, we do not impose constraints on the set of edges eligible for modification, i.e., we denote with $\mathcal{B}$ the set of edges between $u$ and all the other nodes within the network that can be added or removed, leaving the surface of the loss guiding the optimization process toward the optimal set of actions to take.

%Specifically, if we assume that the input graph $\graph$ is undirected,\footnote{If $\graph$ is directed, the same applies to $u$'s outgoing edges.} we consider both the removal of any existing edge and the addition of any new edge. As a result, we aim to independently determine the optimal modification required to achieve effective concealment.

%\edo{Che cosa significa che non possiamo rimuovere archi di nodi con grado 1 che non siano il target node? Non abbiamo controllo solo su di esso?} 
%\matteo{Mentre DRL-Agent ha dei vincoli per quanto riguarda le modifiche che può fare (rimuovere archi dentro comunità e aggiungerne fuori), noi no e lasciamo che $\Tilde{A}_u$ guidi il processo. L'unico vincolo riguarda i nodi di grado 1  per evitare di scollegarli completamente dalla rete: se il nodo $u$ ha un vicino di grado 1 (con arco uscente), allora non voglio togliere quell'arco; lo stesso se il nodo $u$ ha solo un vicino (con arco uscente).}
%\edo{Ci può stare il primo caso, ma il secondo mi sembra un vincolo forte. Supponi che $u$ abbia grado 1 e il suo vicino $v$ abbia grado $g>1$, non scollegare $u$ da $v$ e collegarlo a un altro nodo di un'altra comunità potrebbe fondere due comunità perché $u$ farebbe da ponte, oppure potrebbe fallire nell'uscire dalla comunità $C_i$. Per evitare questo, è necessario fare in modo che $u$ si scolleghi da $v$.}
%\matteo{L'ho aggiunto per evitare questa situazione: se $u$ (con grado 1) si scollega da $v$ come prima modifica, allora l'occultamento viene sicuramente raggiunto ed il metodo ritorna il grafo con u isolato. Con chiunque abbiamo parlato di questo problema, è saltata fuori questa soluzione naive di scollegarsi dalla rete. Nel paper originale ( e relativa implementazione) questo aspetto non viene in nessun modo considerato} 

%Overall, we can define the set of possible edges to remove ($\edges_u^-$) and to add ($\edges_u^-$) as follows:
%\begin{align*} 
    %\edges_{u}^- & = \{(u,v)~|~(u,v)\in \edges \wedge u,v \notin  \mathcal{D}_1 \} , \\
    %\edges_{u}^+ & = \{(u,v)~|~(u,v) \notin \edges \wedge u,v\in\nodes \}.
%\end{align*}

Assuming that the target node $u$ has a fixed budget $\beta > 0$, the task of community membership hiding reduces to finding the optimal function $h^* = h_{\theta^*}$, with the parameters $ \theta^*$ determined by solving the following constrained objective:
\begin{equation}
\label{eq:objective}
\begin{split}
    \theta^* & = \underset{\theta}{\text{arg min}} \bigg \lbrace \mathcal{L}(h_{\theta};\graph, f, u) \bigg \rbrace \\
    & \text{subject to: } |\mathcal{B}_{u}| \leq \beta,
\end{split}
\end{equation}
where $\mathcal{B}_{u} \subseteq \mathcal{B}$ denotes the set of actions selected by $h_{\theta}$.
%subset of changes chosen from the candidates -- namely the budget used.
Note that Eq. \ref{eq:objective} can be interpreted as the process of identifying the \emph{counterfactual graph} $\graph^* = h^*(\graph)$, designed to mask the community membership of the target node $u$ when input to $\f$.

It is worth noting that, within this framework, unconventional solutions may technically qualify as admissible, e.g., when the optimal counterfactual completely isolates the target node from the rest of the network. 
However, we do not address such cases in this work, as they can be managed post hoc and adapted to the specific requirements of individual applications. Moreover, our experiments on real-world networks did not produce such extreme outcomes.