\section{Full proof of~\texorpdfstring{\Cref{thm:cfminecc-NPhard}}{}}
\label{appendix:color-fair}
\label{app:cf}
% NP-hardness
\cfmineccNPhard*
\input{figures/color-fair-reduction.tex}
\begin{proof}
    We reduce from \boolSAT{}, for which the input is a formula written in conjunctive normal form, consisting of $m$ clauses $C_1, C_2, \ldots C_m$ over $n$ variables $x_1, x_2, \ldots x_n$.
    For each variable $x_i$, we write $x_i$ and $\neg x_i$ for the corresponding positive and negative literals.
    We make the standard assumptions that no clause contains both literals of any variable, and that every literal appears at least once.
    We also assume that each clause has size $2$ or $3$, and that each variable appears in at most three clauses (implying that each literal appears in at most two clauses); hardness is retained under these assumptions~\cite{tovey1984simplified}.
    Given an instance of this problem, we construct an instance $(G = (V, E), \tau = 2)$ of \cfminECC{}. See~\Cref{fig:hardness} for a visual aid.

    For each clause $C_j$, we create a unique color $c_j$. Also, if $C_j$ has size two, we create a second unique color $c_j'$, and five vertices $v_j^a, v_j^b, v_j^c, v_j^d,$ and $v_j^e$.
    We call these the \emph{spare vertices} associated with $C_j$.
    The reason for creating these vertices and the second color $c_j'$ will become apparent later.
    Next, for each variable $x_i$, we create a vertex $v_{j_1, j_2}^i$ for each (ordered) pair of clauses $C_{j_1}, C_{j_2}$ with $C_{j_1}$ containing the positive literal $x_i$ and $C_{j_2}$ containing the negative literal $\neg x_i$.
    We call $v_{j_1, j_2}^i$ a \emph{conflict vertex} for the variable $x_i$ and the variable-clause pairs $(x_i, C_{j_1})$ and $(x_i, C_{j_2})$. Observe that each variable has either one or two associated conflict vertices, as does each variable-clause pair.
    For each variable-clause pair $(x_i, C_j)$ with a single associated conflict vertex, we create an additional vertex $v_j^i$ and call this the \emph{free vertex} for the variable-clause pair $(x_i, C_j)$.

    Now we create edges.
    For each clause $C_j$, we begin by creating one edge $e_j^i$ of color $c_j$ for each variable $x_i$ contained in $C_j$. This edge contains either the two $(x_i, C_j)$ conflict vertices, or the single $(x_i, C_j)$ conflict vertex and the $(x_i, C_j)$ free vertex.
    We call the edge $e_j^i$ a \emph{conflict edge} associated both with clause $C_j$, and with the literal of $x_i$ which appears in $C_j$.
    Observe that every free vertex has degree one, and every conflict vertex has degree two.
    For clauses $C_j$ of size $3$, there are exactly three edges of color $c_j$.
    For clauses $C_j$ of size $2$, we have thus far created two edges of color $c_j$.
    For each such clause, we use the associated spare vertices to create a third edge $\{v_j^a, v_j^b\}$ of color $c_j$, which we call the \emph{spare edge} associated with $C_j$, and three edges $\{v_j^a, v_j^c\}$, $\{v_j^a, v_j^d\}$, and $\{v_j^b, v_j^e\}$, each of color $c_j'$.
    Observe that our constructed graph still has maximum degree three, and that there are now exactly $3$ edges of every color.
    Finally, we set $\tau = 2$.

    Since free vertices have degree one, they do not participate in cycles.
    It is also clear from the construction that spare vertices do not participate in cycles.
    Thus, any cycle contains only conflict vertices.
    Note that if two conflict vertices share an edge, then they are associated with the same variable-clause pair.
    It follows that every vertex in a cycle is associated with some single variable-clause pair.
    However, a variable-clause pair has at most two associated conflict vertices, so we have constructed a forest.

    Now we will add some gadgets to turn our forest into a tree. Suppose that the graph we have constructed so far has $q$ connected components.
    Impose an arbitrary order on these components, and label them $G_1, G_2, \ldots, G_q$.
    Observe that every connected component contains either only spare vertices or two free vertices.
    In both cases, it is possible to add two edges each with one (distinct) endpoint in $G_i$ without raising the maximum degree above three.
    That the endpoints are distinct will be important when we analyze the cutwidth.
    For each consecutive pair $G_i, G_{i+1}$ of connected components, we add two \emph{bridge vertices} $b_{i, i+1}^1, b_{i, i+1}^2$ and a \emph{bridge color} $c_{i, i+1}^b$.
    We add \emph{bridge edges} (chosen so as not to violate our maximum degree constraint) from $G_i$ to $b_{i,i+1}^1$, from $b_{i, i+1}^1$ to $b_{i, i+1}^2$, and from $b_{i, i+1}^2$ to $G_{i+1}$.
    We color each of these three edges with $c_{i, i+1}^b$. Observe that the graph is now connected, but it is still acyclic since there is exactly
    one path between any pair of vertices which were in different connected components before the addition of our bridge gadgets.

    We now claim that the constructed graph $G$ has cutwidth~$2$.
    To this end, we will construct a ordering $\sigma\colon V \rightarrow \mathbb{N}$ of the vertices of $G$, where $\sigma$ is injective, $\sigma(v) = 1$ indicates that $v$ is the first vertex in the ordering, $\sigma(u) = |V|$ indicates that $u$ is the last vertex in the ordering, and $\sigma(v) < \sigma(u)$ if and only if $v$ precedes $u$ in the ordering.
    We will show that for every $i$, there exist at most two edges $uv \in E$ with the property that $\sigma(u) \leq i$ and $\sigma(v) > i$. We refer to this number of edges as the \emph{width} of the cut between vertices $i$ and $i+1$ in $\sigma$.
    We begin by guaranteeing that, for every $i$, if $u$ is the last vertex of $G_i$ in $\sigma$, $v$ is the first vertex of $G_{i+1}$ in $\sigma$, and $b_{i, i+1}^1, b_{i, i+1}^2$ are the associated bridge vertices, then $\sigma(u) = \sigma(b_{i, i+1}^1) - 1 = \sigma(b_{i, i+1}^2) - 2 = \sigma(v) - 3$.
    A consequence is that for every $i$, if $u$, $v$ are vertices of $G_i$ then every vertex $w$ with the property that $\sigma(u) < \sigma(w) < \sigma(v)$ is also a vertex of $G_i$.
    Observe that every cut between two bridge vertices has width $1$, as does every cut between a bridge vertex and a non-bridge vertex.
    We therefore need only consider cuts between pairs of vertices in the same $G_i$.
    % Note that the edges of such a cut have both endpoints in $G_i$. We therefore need only consider the cutwidth of each $G_i$.
    If $G_i$ contains a conflict vertex, then $G_i$ is either a $P_3$ or a $P_4$.
    The former case arises when a variable appears in exactly two clauses, so there is one associated conflict vertex adjacent to two free vertices.
    The latter case arises when a variable appears in exactly three clauses, so there are two associated conflict vertices.
    These are adjacent.
    Additionally, each conflict vertex is adjacent to a distinct free vertex, so we have a $P_4$.
    Both the $P_3$ and $P_4$ have cutwidth $1$, as evidenced by ordering the vertices as they appear along the path.
    Moreover, we may assume that the relevant bridge edges are incident on the appropriate endpoints of the path, and so any cut between vertices of $G_i$ has width~$1$.
    Otherwise, $G_i$ contains no conflict vertices.
    In this case, $G_i$ contains only the five spare vertices $v_j^a, v_j^b, v_j^c, v_j^d$, and $v_j^e$ associated with some clause $C_j$, and the four edges are $v_j^av_j^b, v_j^av_j^c, v_j^av_j^d$, and $v_j^bv_j^e$.
    It is simple to check that this construction has cutwidth $2$, as evidenced by the ordering $\sigma(v_j^e) < \sigma(v_j^b) < \sigma(v_j^a) < \sigma(v_j^c) < \sigma(v_j^d)$.
    Once again, we may assume that the relevant bridge edges are incident on $v_j^e$ and $v_j^d$.
    Moreover, we can assume that at least one such $G_i$ exists, since \boolSAT{} instances in which every clause has size three and every variable appears at most three times are polynomial-time solvable~\cite{tovey1984simplified}.
    Thus, $G$ has cutwidth $2$.

    It remains to show that the reduction is correct. For the first direction, assume that there exists an assignment $\phi$ of boolean values to the variables $x_1, x_2, \ldots, x_n$ which satisfies every clause. We say that the assignment $\phi$ \emph{agrees} with a variable-clause pair $(x_i, C_j)$ if $C_j$ contains the positive literal $x_i$ and $\phi(x_i) = \textsf{True}$ or if $C_j$ contains the negative literal $\neg x_i$ and $\phi(x_i) = \textsf{False}$. We color the vertices of our constructed graph as follows.
    To every free vertex associated with clause $C_j$ we assign color $c_j$.
    The free vertex was only in edges of color $c_j$, so this results in zero unsatisfied edges.
    Next, to each bridge vertex we assign the associated bridge color.
    The bridge vertices were only in edges of this color, so once again this results in zero unsatisfied edges.
    Moreover, we have now guaranteed that at least one bridge edge of every bridge color is satisfied, meaning that at most two can be dissatisfied.
    Henceforth, we will not consider the remaining bridge edges.
    Next, for each clause $C_j$ of size $2$, we assign color $c_j'$ to every spare vertex associated with $C_j$. This results in exactly one unsatisfied edge of color $c_j$, and ensures that every edge of color $c_j'$ is satisfied. Finally, for each conflict vertex $v_{j_1, j_2}^i$, if $\phi$ agrees with $(x_i, C_{j_1})$ we assign color $c_{j_1}$ to $v_{j_1, j_2}^i$, and otherwise we assign color $c_{j_2}$.
    Observe that this coloring satisfies an edge $e_j^i$ if and only if $\phi$ agrees with $(x_i, C_j)$.
    Moreover, because $\phi$ is satisfying,
    every clause $C_j$ contains at least one variable $x_i$ such that $\phi$ agrees with $(x_i, C_j)$.
    Hence, at least one edge of every color is satisfied. Because there are exactly three edges of every color, there are at most two unsatisfied edges of any color.

    For the other direction, assume that we have a coloring which leaves at most two edges of any color unsatisfied. We will create a satisfying assignment $\phi$.
    For each variable $x_i$, we set $\phi(x_i) = \textsf{True}$ if any conflict edge associated with the positive literal $x_i$ is satisfied, and $\phi(x_i) = \textsf{False}$ otherwise.
    We now show that $\phi$ is satisfying. Consider any clause $C_j$. There are exactly three edges with color $c_j$, and at least one of them is satisfied.
    We may assume that the spare edge associated with $C_j$ (if such an edge exists) is unsatisfied, since satisfying this edge would require three unsatisfied edges of color $c_j'$. Thus,
    at least one conflict edge associated with $C_j$ is satisfied. Let $x_i$ be the corresponding variable, so the satisfied conflict edge is $e_j^i$.
    If $C_j$ contains the positive literal $x_i$, then $\phi(x_i) = \textsf{True}$ so $C_j$ is satisfied by $\phi$.
    Otherwise $C_j$ contains the negative literal $\neg x_i$.
    In this case, we observe that every conflict edge associated with the positive literal $x_i$ intersects with $e_j^i$ at a conflict vertex, and none of these edges has color $c_j$ since
    $C_j$ does not contain both literals. Hence, the satisfaction of $e_j^i$ implies that every conflict edge associated with the positive literal $x_i$ is unsatisfied.
    It follows that $\phi(x_i) = \textsf{False}$, meaning $C_j$ is satisfied by $\phi$.

    To show the claim for \cfmaxECC{}, we repeat the same construction, except that we omit all spare colors, vertices, and edges. The effect is that the constructed graph is a path.
    The proof of correctness is conceptually unchanged. Given a satisfying assignment $\phi$ we color vertices in the same way as before, and given a vertex coloring which satisfies
    at least one edge of every color, it remains the case that at least one conflict edge associated with every clause must be satisfied.
    The remaining analysis is similar.
\end{proof}

% %cfminECC FPT
% \cfminECCFPT*
% \begin{proof}
%     We give a branching algorithm.
%     Given an instance $(H = (V, E), \tau)$ of \cfminECC{}, a \emph{conflict} is a triple $(v, e_1, e_2)$ consisting of a single vertex $v$ and a pair of distinctly colored hyperedges $e_1, e_2$ which both contain $v$.
%     If $H$ contains no conflicts, then it is possible to satisfy every edge.
%     Otherwise, we identify a conflict in $O(r|E|)$ time by scanning the set of hyperedges incident on each node.
%     Once a conflict $(v, e_1, e_2)$ has been found, we branch on the two possible ways to resolve this conflict: deleting $e_1$ or deleting $e_2$.
%     Here, deleting a hyperedge has the same effect as ``marking'' it as unsatisfied and no longer considering it for the duration of the algorithm.
%     We note that it is simple to check in constant time whether a possible branch violates the constraint given by $\tau$; these branches can be pruned.
%     Because each branch increases the number of unsatisfied hyperedges by 1, the search tree has depth at most $\edgedeletions$.
%     Thus, by computing the search tree in level-order, the algorithm runs in time $O(2^{\edgedeletions}r|E|)$.
% \end{proof}

%


% NP-hard k = 2
% \cfmineccNPhardboundedk*


% reduction to sparse vertex cover


% combinatorial algorithm
% \cfminecccombinatorial*

