% In this section, we first present the system model and requirements of UAT20 and introduce design of UAT20.


\begin{figure*}[h!]
\centering
\includegraphics[width=.7\linewidth]{./data/architecture.pdf}
\caption{\label{fig:arch} The Workflow of \tool protocol}
\end{figure*}
 
% UAT20 aims to achieve liquidity unification among rollups, which allows users to operate all their assets (\eg, ERC20 token) in any rollup without the need to migrate all these assets to one rollups through cross-chain protocols. This approach simplifies the user experience by eliminating the complexities and costs associated with moving assets between rollups while maintaining efficient access to liquidity.

\subsection{System Model}

\myparagraph{User, Ethereum, Rollups} UAT20 is designed for unifying liquidity among Rollups $\{\mathcal{R}_1, \mathcal{R}_2, \cdots, \mathcal{R}_n\}$. Ethereum $\mathcal{E}$ servers as the base layer where all Rollups ultimately submit their batched transactions for final confirmation. Each Rollup $\mathcal{R}_i$, whether based on Optimistic or Zero-Knowledge (ZK) technologies, operates independently by maintaining its own state and processing user transactions to update this state. These rollups rely on Ethereum (L1) for transaction finality and confirmation, ensuring security and consensus.
Users $\mathcal{U}$ are allowed to send transactions in both Ethereum (L1) and Rollups (L2).

\myparagraph{ERC20 Token ($\Sigma_{20}$), UAT20 Token ($\Upsilon_{20}$)} Two types of tokens contract is deployed in Rollups: ERC20 Token ($\Sigma_{20}$) and UAT20 Token ($\Upsilon_{20}$).
$\Sigma_{20}$ follows the mature ERC-20 standard, preserving user assets on the current chain and enabling token transfers within the same chain. However, user tokens remain fragmented across different instances of the same $\Sigma_{20}$ deployed on multiple chains.
As a universal abstract token built on top of E-Token, $\Upsilon_{20}$
  manages all of a user's ERC20 tokens across multiple chains, enabling seamless asset transfers on any chain while ensuring consistency across them. $\Upsilon_{20}$ leverages a Conflict-Free Replicated Data Type (CRDT) design, allowing each replica (\ie, Rollup) to independently handle token transfers. To maintain a unified state across all rollups, $\Upsilon_{20}$ employs merge functions that reconcile concurrent updates from different replicas (\ie, Rollup), ensuring consistency and reliability in multiple rollups.
% U-Token is a contract built on top of E-Token, enabling seamless token transfer across Ethereum Layer 1 (L1) and multiple Rollups (Layer 2). 
% The core technology of U-Token is a replicated data type, and each replica can operate token transfer 

% in which replicas convert operations (token transfer) into messages that they broadcast to Layer 1.

% While E-Token adheres to the ERC-20 standard for token management within a single chain,
% U-Token

% is a replicated data type 
% U-Token extends this functionality by maintaining user assets across all chains and allowing users to transfer these assets on any chain.



% E-Token and U-Token are smart contracts deployed on Rollups and layer 1.













\myparagraph{Synchronizer} A synchronizer is a critical component that enables rollups to broadcast their token transaction (e.g., the transaction of $\Sigma_{20}$ or $\Upsilon_{20}$) to Ethereum, allowing other rollups to access these transactions. Once Ethereum organizes transactions from multiple rollups into a new block, the Synchronizer ensures that the sorted 
transactions are synchronized across all rollups. In summary, the synchronizer operates with two functions:

\noindent (i) $\mathtt{Broadcast}(T_i, \mathcal{R}_i)$: facilitates the broadcast of token transfer transactions $T_i$ from the rollup $\mathcal{R}_i$;

\noindent (ii) $\mathtt{Sync}(\mathbb{T}_{O}, \mathcal{R}_i)$: takes the sorted transactions $\mathbb{T}_{O}$ from Ethereum and synchronizes them to the target rollup $\mathcal{R}_i$.



% Facilitates the broadcast of token transfer transactions ($txs$) from the rollup ($\mathcal{R}_i$).



% is a component that enables Rollups to broadcast their token operations (token transfers) to Layer1 so that other Rollups can obtain the operation. After Ethereum sorts these token operations from multiple Rollups in a new block, Synchronizer is responsible for synchronizing the sorted operations to each Rollup. In summary,
% a sequencer is a component with two methods: (i) Broadcast(ops, RID); (ii) Sync(B, RID).


\myparagraph{UAT20 Requirements} We define a set of requirements that UAT20 must satisfy to effectively address liquidity fragmentation across rollups. First, \emph{\textbf{compatibility}}: UAT20 should minimally impact both the original rollup design and the underlying ERC20 token ($\Sigma_{20}$) design within the Ethereum ecosystem. The second requirement is \emph{\textbf{eventual consistency}}: UAT20 must successfully commit all valid token transactions. The state of $\Upsilon_{20}$ should eventually converge to a consistent state across all rollups, ensuring that all valid updates to tokens are preserved.



% we aim to extend Rollups in the Ethereum ecosystem with CRDT-enabled U-Token with minimal changes to both the original design of Rolup and the design of the underlying E-Token. In addition,
% these owners of E-Token can still make token transfers in a single Rollup chain, which remains compatible with ERC20. The second requirement is eventual consistency: UAT20 should be able to commit all valid CRDT-based token transactions successfully. U-Token eventually converges to the same state on all Rollups, and all valid updates on tokens are preserved while using CRDT techniques to merge conflicting transactions.





% \begin{defn}[Eventual Consistencty]

    
% \end{defn}







\subsection{Workflow}

As shown in Figure\ref{fig:arch} , Rollup \texttt{X} ($\mathcal{R}_X$) and Rollup \texttt{Y} ($\mathcal{R}_Y$) is deployed with two types of token: ERC20 token $\Sigma_{20}$ and UAT20 Token $\Upsilon_{20}$. Within each rollup, the $\Upsilon_{20}$ is designed based on the CRDT framework as a replica, managing and reflecting users' $\Sigma_{20}$ across all rollups. 
Users can perform transactions to transfer or approve either $\Upsilon_{20}$ or $\Sigma_{20}$ on any rollup.
These transactions are periodically broadcast to Layer 1 (\ethereum). \ethereum serves as the coordinator, responsible for ordering token transactions from multiple rollups within its blocks. 
This transaction sequence allows each rollup to merge transactions and resolve conflicts arising from concurrent transactions in a consistent manner, ensuring that all rollups converge to the same state for $\Upsilon_{20}$. Specifically, the update of $\Upsilon_{20}$'s state follows a two-phase \textbf{Execute-Commit} protocol.

% In each rollup, UAT20 token is designed based on CRDT, and serves as a replica to manage and display users' ERC 20 tokens in all rollups. The user is allowed to send transaction to transfer/approve either ERC20 or UAT20 tokens in any rollups. 
% Such transactions are periodically broadcast to Layer 1(\ethereum).
% \ethereum serves as a coordinator which is responsible for ordering operations from multiple Rollups in the blocks. With this order, each Rollup can merge these operations and handle conflicts between concurrent operations in a uniform way to ensure that they all end up in the same state.
% Overall, the update of UAT20 follows a two-phase execute-commit protocol.








\myparagraph{Phase1: Execution Phase}
 Users first submit transaction $t$ to invoke $\Sigma_{20}$ or $\Upsilon_{20}$ in each rollup, resulting in a set of operations to be committed in the commit phase. After these transactions are executed,  the \emph{synchronizer} forwards these transactions and their operations to Ethereum for ordering. As shown in Figure~\ref{fig:arch}, the user $\textbf{C}$ initates two transactions on $\mathcal{R}_X$: $T_X = \{t^{(1)}_{x, e}, t^{(2)}_{x,u}\}$.
 The first transaction $t^{(1)}_{x, e}$ invokes $\Sigma_{20}$ to transfer ERC20 tokens within $\mathcal{R}_X$, while $t^{(2)}_{x,u}$ invokes $\Upsilon_{20}$ to enable the transfer of UAT20 tokens across rollups. 
 The execution of these transactions generates a set of operations, \eg, the operation set $O_1$ for $t^{(1)}_{x, e}$, which are derived using the CRDT approach and serve to update the state of $\Upsilon_{20}$ across all replicas (rollups). We will detail the execution of these transactions and their operations in \S\ref{sec:design}.
Finally, transactions and their operations are periodically collected by the \emph{synchronizer} and submitted to Ethereum for ordering.
 
 % The transaction execution results trigger a set of operations $\{op1, op2, \cdots, op_n\}$ created based on the CRDT method to modify the application state. These operations only contain operations that require synchronization of multiple replicas. We will detail the execution process of E-Tx and T-Tx and the set of operations generated in Chapter X.
% Then, syncer collects transactions and their execution results and submits them to ethereum periodically.



\myparagraph{Phase2: Commit Phase}
The \emph{synchronizer} then synchronizes the ordered transactions sequence $\mathbb{T}_{O}$ from \ethereum. Note that the $\mathbb{T}_{O}$ specifies the \emph{arbitration order} for committing.
Specifically, $\mathbb{T}_{O}$ consists of two queues $[\mathcal{T}_E, \mathcal{T}_U]$ where $\mathcal{T}_E$ contains transactions calling $\Sigma_{20}$ from multiple rollups, while the latter $\mathcal{T}_U$ contains transactions calling $\Upsilon_{20}$ from multiple rollups.
The \emph{arbitration order} specifies that: (i) Transactions in $\mathcal{T}_E$ have higher processing priority than those in $\mathcal{T}_U$; 
(ii) Within each queue, transactions are processed in the order, following the sequence of the queue.
For each transaction's set of operations, the function $\mathtt{commit}$ of $\Upsilon_{20}$ will be to apply these operations to their states and update these state according to the update strategy (refer to \S\ref{sec:design}).
In this way, conflicts between non-commuting concurrent operations from two CRDTs are resolved based on this arbitration order.
% We will detail the commit of operations within each rollups in 

% ensuring that operations of  transactions are submitted and processed accordingly. 
% Operations from multiple Rollups will be sorted and verified in a new block of Ethereum, and the \emph{syncer} synchronizes valid operations to each rollup chain. The order of transactions in the new block specifies the arbitration order of transactions from multiple rollups, which stipulates that operations that should be in the second transaction should be submitted before the first transaction. Given the set of operations in each transaction, the syncer calls the commit function in the UAT token to apply these operations to their states in causal order. In particular, the update strategy of the E-Token is specified in the transaction. In addition to updating the U-balance status, the execution process will also update the E-token in each Rollup according to the update strategy. We discussed the update strategy of the E-Token in Section XXX.

% As mentioned above, a U-Token is a replicated data type in which replicas convert operations (token updates) into messages that they broadcast to Layer 1.
% These messages from multi-Rollups is ordered and confirmed in the new block $B$ of Layer 1.
% After that, each Rollup captures these messages and apply them to their states in the order specified in $B$, in such a way that concurrent messages commute.

% Conflicts between non-commuting concurrent operations from the two CRDTs are handled according to an arbitration order, which specifies that operations from the first CRDT should be applied before concurrent operations from the second CRDT.



\myparagraph{Example} Figure~\ref{fig:arch} shows an example of token transfer in UAT20.
Consider user \textbf{C} has 100 UAT20 token (\ie, $\mathcal{B}_u[\mathbf{C}] = 100$), which is composed of 40 ERC20 tokens on $\mathcal{R}_X$ (\ie, $\mathcal{B}^x_e[\mathbf{C}] = 40$) and 60 ERC20 tokens on $\mathcal{R}_X$ (\ie, $\mathcal{B}^y_e[\mathbf{C}] = 60$). During a block epoch, \textbf{C} initiates three transactions: $t^{(1)}_{x,e}, t^{(2)}_{x,e}$ on $\mathcal{R}_X$ and $t^{(3)}_{y,u}$
on $\mathcal{R}_Y$. Specifically:

(i) the $t^{(1)}_{x,e} = \Sigma_{20}.\mathtt{transfer}(\mathbf{C}\rightarrow \mathbf{A},10)$ transfers 10 ERC20 token from user \textbf{C} to user \textbf{A} via the $\Sigma_{20}$ on $\mathcal{R}_X$; 

(ii) the $t^{(2)}_{x,u} = \Upsilon_{20}.\mathtt{transfer}(\mathbf{C}\rightarrow \mathbf{A},50)$ transfers 50 UAT20 tokens from $\mathbf{C}$ to $\mathbf{A}$ via the $\Upsilon_{20}$ on $\mathcal{R}_X$;

(iii) the $t^{(3)}_{y,u} = \Upsilon_{20}.\mathtt{transfer}(\mathbf{C}\rightarrow \mathbf{A},90)$ transfers 90 UAT20 tokens from user \textbf{C} to user \textbf{A} via the $\Upsilon_{20}$ on $\mathcal{R}_Y$.

For each transaction, an operation set $O$ is generated to describe the token transfers within that transaction. Once executed, the synchronizer periodically submits these transactions along with their operation sets to Ethereum for inclusion in a new block. Assume Ethereum finalizes the following order: $[\langle t^{(1)}_{x,e}, O_1 \rangle, \langle t^{(2)}_{x,u}, O_2 \rangle, \langle t^{(3)}_{y,u}, O_3 \rangle]$.
The synchronizer facilitates the synchronization of token transactions across rollups by interacting with the $\Upsilon_{20}$ on each $\mathcal{R}$. According the type of transferred token, these transactions are divided into two queues $\mathcal{T}_E = [\langle t^{(1)}_{x,e}, O_1 \rangle]$ and $\mathcal{T}_U = [\langle t^{(2)}_{x,u}, O_2 \rangle, \langle t^{(3)}_{y,u}, O_3 \rangle]$.
The $\Upsilon_{20}$ processes these transactions sequentially, starting with $\mathcal{T}_E$ and followed by $\mathcal{T}_U$. During this process, a conflict arises between $t^{(2)}_{x,u}$ and $t^{(3)}_{y,u}$. Specifically, the $\mathcal{B}_u[\mathbf{C}]$ is insufficient to fulfill the above two transactions (90 tokens available, but $t^{(3)}_{y,u}$ requires 90 tokens and $t^{(2)}_{x,u}$ requires 50 tokens). To resolve this conflict, the UAT20 adheres to the order of the $\mathcal{T}_U$. Consequently, $t^{(2)}_{x,u}$ succeeds as it appears earlier in the queue, while $t^{(3)}_{y,u}$ fails due to insufficient balance.



% After the execution of each transaction,  an operation set $O$ will be generated to illustrate how U-Token movements in this transaction. After execution, the syncer periodically submits these transactions and their operation sets to Ethereum for inclusion in a new block. Assume Ethereum finalizes the following order: $\{<e-tx^{x}_{1}, O_1>, <u-tx^{x}_{2}, O_2>, <u-tx^{y}_{2}, O_3>\} $.
% The synchronizer synchronizes token transactions and operation sets across Rollups by calling U-Token. These transactions are divided into two queues for transaction calling E-Token and transaction calling U-Token according to the order in Ethereum: (i) $Q_E: [<e-tx^{x}_{1}, O_1>]$; (ii) $Q_U: [<U-tx^{x}_{2}, O_2>, <U-tx^{Y}_{3}, O_3>]$. After that, U-Token updates the state of Rollup using the operations of these transactions, which begin with E-Token transactions ($Q_E$), followed by U-Token operations($Q_U$).
% During this process, a conflict arises between  $<U-tx^{x}_{2}, O_2>$ and $<U-tx^{x}_{3}, O_3>,$. Specifically, the total U-Token balance of user A is insufficient (90 tokens available, but $U-tx^{Y}_{3}$ requires 50 tokens and $U-tx^{x}_{2} requires 90 tokens$. Note that such conflict is resolved by adhering to the U-Token queue order. The  $U-tx^{x}_{2}$ succeeds as it is earlier in the queue and $U-tx^{Y}_{3}$  fails due to insufficient balance.






\subsection{UAT20 Token and ERC20 Token}
\label{sec:design}

In this section, we present the design of ERC20 Token $\Sigma_{20}$ and UAT20 Token $\Upsilon_{20}$ in detail.
% We introduce our approach to integrate CRDTs with U-Token and E-Token. We also explain the mechanism for handling conflicts between non-commuting concurrent token operations from different Rollups.


%balance for global tracking.

\begin{defn}[UAT20 Token $\Upsilon_{20}$] The $\Upsilon_{20}$ is a tuple $(\mathbb{B}, \mathcal{F}_o, \mathcal{F}_c)$ where:
\begin{itemize}[leftmargin=*]
\item $\mathbb{B}$ is represents the aggregated token state across $n$ Rollups $\{ \mathcal{B}_u, \mathcal{B}^1_e, \mathcal{B}^2_e, \cdots, \mathcal{B}^n_e \}$ where $\mathcal{B}_u$ is defined as the sum of all balances of $\Sigma_{20}$ maintained within the individual Rollups, $\mathcal{B}^i_e$ is a mapping variable to the balance of ERC20 token held by each user on $\mathcal{R}_i$. For a user $\mathbf{C}$, 
$
\mathcal{B}_u[\mathbf{C}] = \sum_{i=1}^{n} \mathcal{B}^i_e[\mathbf{C}]$. 

% (ii). 
% Note that, $\sigma_u[X] = (\sigma_e1[X], \sigma_en[X])$
\item $\mathcal{F}_o: \{\mathtt{transfer}, \mathtt{transferFrom}, \mathtt{Approve}\}$ denotes a collection of functions enabling users to transfer UAT20 token. Once the validity checks (\eg, permission check) are passed, a set of operations $O= [op_1, \cdots, op_n]$ is generated.
\item $\mathcal{F}_c: \{\mathtt{commitE}, \mathtt{commitU}\}$ empowers the synchronizer to submit token transactions from various Rollups within a block epoch during the commit phase.  In these functions, these token operations are finalized and synchronized across replicas (Rollups) using CRDT properties to maintain eventual consistency.
Specifically, \texttt{commitE} processes transactions and their operations from the $\mathcal{T}_E$, while \texttt{commitU} handles transactions and their operations from the $\mathcal{T}_U$. 
Since ERC20 transactions in $\mathcal{T}_E$ only involve updates to token within a single rollup, they are conflict-free. As such, \texttt{commitE} is 
responsible for updating the global balances $\mathcal{B}_u$ and the balances of involved rollup $\mathcal{B}^i_e$ based on the operations specified in each transaction.
Unlike \texttt{commitE}, conflicting transactions in $\mathcal{T}_U$ must be processed in \emph{arbitration order} to ensure eventual consistency.
Moreover, since operations of each UAT20 transaction only specify the update of the $\mathcal{B}_u$, \texttt{commitE} must resolve these global updates into specific rollup balances ($\mathcal{B}^1_e, \mathcal{B}^2_e, \cdots, \mathcal{B}^n_e$) based on the user's predefined priority strategy (which relies on Conflict-free Replicated Data Types (CRDTs) to ensure consistent agreement across all rollups), \eg,  prioritizing the deduction of tokens from $\mathcal{R}_X$ in Figure \ref{fig:arch}. 
\end{itemize}

% To resolve conflicts between token operations from different Rollups, non-commuting concurrent operations from two transactions are handled according to an arbitration order specified in the block.


\end{defn}



\begin{defn}[ERC20 Token $\Sigma_{20}$] $\Sigma_{20}$ enhances the ERC20 standard by incorporating functionality that supports the UAT20 protocol, facilitating advanced global token management. The update of $\Sigma_{20}$'s state will be forwarded to $\Upsilon_{20}$ by calling the function in $\mathcal{F}_o$, which produces a set of token operations to be committed.
% In addition to this forwarding mechanism, $\Sigma_{20}$ introduces additional functions that enable $\Upsilon_{20}$ to update a user’s token status on the current chain during the commit phase.
Overall, E-Token is defined as a tuple $(B, F)$, where:

\begin{itemize}[leftmargin=*]
    \item $B$ is a mapping variable that records the balance of each user; 
    \item $F = (\mathtt{transfer}, \mathtt{transferFrom}, \mathtt{Approve})$ denotes a collection of functions enabling users to transfer UAT20 token.
    $\mathcal{F}_e$ is invoked at the end of these functions to produce operations for updating $\mathcal{B}_u$ and $\mathcal{B}^i_e$ ($i$ is the id of the current rollup and $\mathcal{B}^i_e = B$); Beside, $F$ can also be invoked by the $\mathcal{F}_c$ to update $B$ during the commit phase.
\end{itemize}


% E-Token builds on the ERC20 standard with added functionality to support the UAT20 protocol. All status updates triggered by ERC20 calls are forwarded to the U-Token function, which generates the token operations required for commitment. At the same time, E-Token includes additional functions allowing U-Token to update the user’s token status on the current chain during the commit phase.
% Overall, E-Token is defined as a tuple $(\Sigma, \mathcal{F}_e, \mathcal{F}_c)$, where: $\Sigma$ is a mapping variable that records the balance of each user; $\mathcal{F}_e$ is a set of functions designed to enable users to transfer their tokens within the current rollup, with $\mathcal{F}_e$ invoked at the end of the execution; and $\mathcal{F}_c$ is a set of functions that allows U-Token to update users' balances during the commit phase.


\end{defn}

We still use the example in Figure \ref{fig:arch} to explain the workflow of $\Sigma_{20}$ and $\Upsilon_{20}$. 



\myparagraph{The transfer of $\Sigma_{20}$ on $\mathcal{R}_X$}
(\emph{Execution Phase.}) User \textbf{C} initiates the transaction $t^{(1)}_{x,e}$ by calling the function \texttt{tranfer} of $\Sigma_{20}$. During the execution, this transaction first check the validity of $t^{(1)}_{x,e}$ to ensure that the sender has sufficient E-Token on $\mathcal{R}_X$ and validate the transaction metadata(\ie, \texttt{msg.sender} or signature).
After that, the balances of $\Sigma_{20}$ for caller \textbf{C} and recipient \textbf{A} ($B[\mathbf{C}]$ and $B[\mathbf{A}]$)are updated accordingly.
Given that balances of $\Upsilon_{20}$ ($\mathbb{B}$) are unified across rollups, $t^{(1)}_{x,e}$ also affects both the Rollup-specific balances ($\mathcal{B}^x_e$) and the aggregated balances ($\mathcal{B}_u$). 
Thus, the output operations of $t^{(1)}_{x,e}$ is 
$O_1=\{\mathtt{SUB}(\mathcal{B}_u[\mathbf{C}],10), \mathtt{ADD}(\mathcal{B}_u[\mathbf{A}],10),\mathtt{SUB}(\mathcal{B}^i_e[\mathbf{C}],10),\mathtt{ADD}(\mathcal{B}^i_e[\mathbf{A}]$
$,10)\}$
(\emph{Commit Phase.}) Since $t^{(1)}_{x,e}$ is an ERC20 transfer transaction, there are no conflicts with other transaction at this epoch. With operations in $O_1$, $\Upsilon_{20}$ on each rollup updates both $\mathcal{B}_u$ and $\mathcal{B}^i_e$ balances for \textbf{A} and \textbf{C}, maintaining consistency across multiple rollups.



\myparagraph{The transfer of $\Upsilon_{20}$ on Rollup X}
(\emph{Execution Phase.}) User \textbf{C} initiates a transaction $t^{(2)}_{x,u}$ on $\mathcal{R}_x$ to transfer 50 UAT20 token to \textbf{A} by calling $\Upsilon_{20}.\mathtt{transfer}$.
This transaction first verifies transaction metadata (\ie, \texttt{msg.sender} or signatures), to confirm authenticity.
Then, a set of operations will be generated 
$O_2=\{\mathtt{SUB}(\mathcal{B}_u[\mathbf{C}],50), \mathtt{ADD}(\mathcal{B}_u[\mathbf{A}],50)\}$
During the execution phase, no actual balances are updated. Instead, the $\upsilon_{20}$ produces these operations as pending actions to be processed in the subsequent commit phase. 
(\emph{Commit Phase.}) $\mathcal{\Upsilon}_{20}$ processes operations in $O_2$, \ie, update $\mathcal{B}_u[\mathbf{C}]$ and $\mathcal{B}_u[\mathbf{A}]$. Notice that the $O_2$ does not explicitly specify how to update rollup-specific balances, \eg, $\mathcal{B}^x_e$ and $\mathcal{B}^y_e$.
 Instead, $\Upsilon_{20}$ relies on the user's predefined policy, which has been agreed upon across $\mathcal{R}_X$ and $\mathcal{R}_Y$, to determine the sequence and priority for balances deductions across rollups. In this case, $\mathbf{A}$’s policy prioritizes deducting tokens from $\mathcal{R}_X$ before $\mathcal{R}_Y$.
 Thus, 40 tokens are deducted in $\mathcal{B}^x_e[\mathbf{C}]$, depleting it from 40 to 0. Then, the remaining 10 tokens are deducted from $\mathcal{B}^y_e[\mathbf{C}]$, reducing it from 60 to 50. Simultaneously, $\mathcal{B}^x_e[\mathbf{A}]$ is increased by 40 and $\mathcal{B}^y_e[\mathbf{A}]$ is increased by 40.
 Additionally, these updates to the rollup-specific balances $\mathcal{B}^x_e$ and $\mathcal{B}^y_e$ will be synchronized to the balance of $\Sigma_{20}$ ($B$) on $\mathcal{R}_X$ and $\mathcal{R}_Y$ by calling $\Sigma_{20}.\mathtt{transfer}$.
% a transfer of 50  from User A to User C on Rollup Y, following User A’s policy to prioritize token deductions from Rollup X before Rollup Y.
% In the commit phase, which belongs to a commutative E-Token queue, the operation focuses on updating E-Token balance on Rollup X. Since transactions in the E-Token queue are commutative, these operation can committed without conflicts. After applying the operations, User A’s E-Token balance on Rollup X decreases from 40 to 30, while User B’s balance increases from 0 to 10. 


% In the commit phase of tx3, which involves transferring 50 U-Tokens from User A to User C on Rollup Y, the system updates the balances based on User A’s policy to prioritize deducting tokens from Rollup X before Rollup Y. Following this policy, 40 tokens are first deducted from User A’s U-Token[X] balance on Rollup X, reducing it from 40 to 0. The remaining 10 tokens are then deducted from User A’s U-Token[Y] balance on Rollup Y, reducing it from 60 to 50. Simultaneously, User C’s U-Token[Y] balance on Rollup Y is increased by 50 tokens, from 0 to 50. These deductions are reflected in User A’s global 
% U-Token balance, which decreases by 50, while User C’s global balance increases by 50. During this process, the U-Token interface ensures consistent updates to Rollup-specific and global balances, while invoking the E-Token interface to complete the transfer. 
