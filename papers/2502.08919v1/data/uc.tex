\begin{figure*}[!htb]
\begin{tikzpicture}
\node[draw,thick,inner sep=10pt] (box) {
  \begin{minipage}{0.96\textwidth} % Adjust width to fit your content    
        \vspace{-5pt} 
        \begin{multicols}{2}
  	% \begin{multicols}{1}  % Begin the two-column environment
  		% Now, format the text as it appears in the 'picture'
        % \overview{Parties: Users {$U_1,...,U_m$}, Certificate Authority $A$, Service Providers {$P_1,...,P_l$}, and Access Controllers {$C_1,...,C_n$}.}
        % \overview{Parameters: Access policy \(\phi\), issuance criteria \(\ell\), service to access data, computation and authorization $S_{data}, S_{comp}, S_{auth}$, and secret $s$.}

        \vspace{5pt} 
        
        \func{Setup}{$1^\lambda$}
        \step{1. Let $\mathcal{R}$ be a circuit with public input $\textsf{cred}$ and $\textsf{EI}$ asserting: \\ $\textsf{EI} = \textsf{Ec}(e, \textsf{attrs}) \land \textsf{cred}$ opens to $(\textsf{nk,attrs})$}
        \step{2. Compute $\textsf{crs}_\mathcal{R} := \textsf{G16.Setup}(1^\lambda, \mathcal{R})$}
        \step{3. Let $\textsf{pp} := (1^\lambda, \textsf{crs}_\mathcal{R})$ and return $\textsf{pp}$}

        \vspace{5pt} 

        \func{{IssueReq_\textit{U}}}{\textsf{pp}, \textsf{attrs}}
        \step{1. Sample $r_\textsf{cred}, \textsf{nk}$ // commitment nonce, pseudonym key}
        \step{2. Commit $\textsf{cred} := \textsf{Com}(\textsf{nk}, \textsf{attrs}; r_\textsf{cred})$}
        \step{3. Let $\omega := (\textsf{nk}, \textsf{attrs}, r_\textsf{cred})$}
        \step{4. Send ($\omega$, $\textsf{cred}$) to $A$ and receive a proof $\theta$ attesting to $\textsf{cred} \in \textsf{MT}'$}

        \vspace{5pt} 

        \func{{IssueGrant_\textit{A}}}{$\textsf{pp}, \textsf{MT}, \textsf{cred}, \omega$}
        \step{1. Check $\textsf{cred} = \textsf{Com}(\textsf{nk,attrs}; r_\textsf{cred})$}
        \step{2. Let $\textsf{MT}' := \textsf{MT}.\textsf{Add}(\textsf{pk}^{U}, \textsf{cred})$ and $\gamma := \textsf{MT}'.\textsf{Root}$}
        \step{3. Let $\theta := \textsf{MT}'.\textsf{Prove}(\textsf{pk}^{U})$ // $\theta$ attests to $\textsf{cred} \in \textsf{MT}'$}
        \step{4. Send \(\theta\) to \(U\) and publish $\gamma$}

        \vspace{5pt} 

        % Service provider setup for (service, policy, secret, share, time-bound) core part!!!
        \func{{SetPolicy_\textit{P}}}{$\textsf{pp}, \textsf{S}, (f_\phi, param_\phi), T_1, T_2$}
        \step{1. Sample $s$ // secret}
        \step{2. Let $(\textsf{F}_\phi, (e^U, e^P), d) := \textsf{Gb}(1^\lambda, f_\phi)$}
        \step{3. Let $\textsf{EP} := \textsf{Ec}(e^P, param_\phi)$}
        % \step{3. Commit $\textsf{pol} := \textsf{Com}(\textsf{pk}^P, \phi; r_\textsf{pol})$}
        % \step{4. Let $\omega_P := (\phi, e, r_\textsf{pol})$}
        \step{4. Let $\textsf{pp}_\textsf{PVTSS}$ := $\textsf{PVTSS.Setup}(1^\lambda, T_1, T_2)$}
        \step{5. Let $(\{c_i\}_{i\in[n]}, \pi_D) := \textsf{PVTSS.Sharing}(\textsf{pp}_\textsf{PVTSS}, s, \{\textsf{pk}^{C_i}\}_{i\in[n]})$ // locked encrypted shares $\{c_i\}_{i\in[n]}$ with time parameter $T_1$}
        % \step{7. Publish ($\textsf{pol}, \textsf{S}$)}
        \step{6. Send ($\textsf{S}, \textsf{F}_\phi, \textsf{EP}, d, \{c_i\}_{i\in[n]}, \pi_D$) to each party $C_i \in C$}

        \columnbreak
        
        % Access Controllers receive shares and verify
        \func{{VerifyShare_\textit{C}}}{$\textsf{pp}, \textsf{pp}_\textsf{PVTSS}, \{c_i\}_{i\in[n]}, \pi_D, \textsf{F}_\phi, d$}
        \step{1. Check $\textsf{PVTSS.Verify1}(\textsf{pp}_\textsf{PVTSS}, \{\textsf{pk}^{C_i}, c_i\}_{i\in[n]}, \pi_D)$}
        \step{2. Let $\{\hat{s}_i, \pi_i\} := \textsf{PVTSS.Recover}(\textsf{pp}_\textsf{PVTSS}, c_i, \textsf{pk}^{C_i}, \textsf{sk}^{C_i})$ 
        // recover the decrypted share $\hat{s}_i$ together with proof $\pi_i$ of valid decryption}
        \step{3. Store ($\textsf{F}_\phi, d, \hat{s}_i, \pi_i$)}

        \vspace{5pt} 

        \func{{Encode_\textit{U}}}{$\textsf{pp}, \textsf{cred}, \textsf{attrs}, \textsf{S}, \omega$}
        % \step{2. Let ($r, \textsf{attrs}$) := ${\textsf{UserCreds}_\textit{U}}[\textsf{cred}]$}
        % \step{3. If \({\phi}_{vsb}\) is $\textsf{public}$: let ${\textsf{ShowProofs}_\textit{U}}[\textsf{sn}]$ := ($\phi, \textsf{cred}, \theta, r, \textsf{aux}$)}
        % \step{1. \(U\), \(P\) and \(C\) negotiate the secure MPC function $\textsf{Ec}(X, Y)$}
        % \step{2. Public input $(\textsf{cred,pol}, \gamma)$}
        % \step{3. Private input $\omega_P, \omega_U$ by $P$ and $U$}
        % \step{4. Only $C$ receive the initial input $\textsf{EI} := \textsf{Ec}(e, \textsf{attrs})$ if $\textsf{cred}$ opens to $(\textsf{nk,attrs}) \land \textsf{cred} \in \textsf{MT}$}
        \step{1. Request encoding information $e^U$ form $P$ and let $\textsf{EI} := \textsf{Ec}(e^U, \textsf{attrs})$}
        \step{2. Let $\pi_\mathcal{R} := \textsf{G16.Prove}(\textsf{crs}_\mathcal{R}, (\textsf{cred}, \textsf{EI}), (\omega, e^U))$}
        \step{3. Send ($\textsf{EI}, \textsf{cred}, \pi_\mathcal{R}, \textsf{S}$) to each party $C_i \in C$}

        \vspace{5pt} 
        
        \func{{Authenticate_\textit{C}}}{$\textsf{pp}, \textsf{F}_\phi, \textsf{cred}, \textsf{EI}, \textsf{EP}, \textsf{S}, d, \textsf{MT}, \gamma, \theta, \hat{s}_i, \pi_i$}
        \step{1. Check $\textsf{G16.Verify}(\textsf{crs}_\mathcal{R}, \pi_\mathcal{R}, (\textsf{cred}, \textsf{EI})) \land \textsf{MT}.\textsf{Verify}(\gamma, \textsf{pk}^{U}, \textsf{cred}, \theta)$}
        \step{2. Let encoded output $\textsf{EO} := \textsf{Ev}(\textsf{F}_\phi, (\textsf{EI}, \textsf{EP}))$}
        \step{3. Check the final output $\textsf{FO} := \textsf{De}(\textsf{EO}, d)$}
        \step{4. If check pass and over $T_1$, send ($\textsf{S}, c_i, \hat{s}_i, \pi_i$) to $U$}

        \vspace{5pt}

        \func{{AccessService_\textit{U}}}{$\textsf{pp}, \textsf{pp}_\textsf{PVTSS}, \textsf{S}, \{c_i\}, \{\hat{s}_i\}, \{\pi_i\}$}
        \step{1. Check $\textsf{PVTSS.Verify2}(\textsf{pp}_\textsf{PVTSS}, c_i, \hat{s}_i, \pi_i)$}
        \step{2. Add the valid $\hat{s}_i$ to a set $\mathcal{S}$}
        \step{3. If $|\mathcal{S}| > t$ and $T_2$ has not elapsed:\\ let $s := \textsf{PVTSS.Pool}(\textsf{pp}_\textsf{PVTSS}, \mathcal{S}, T_2)$ and $\textsf{Result} := \textsf{S}(s)$}

        \vspace{5pt} 

        \func{Revoke_\textit{A}}{$\textsf{pp}, \textsf{MT}, \textsf{pk}^{U}$}
        \step{1. Let $\textsf{MT}' := \textsf{MT}.\textsf{Remove}(\textsf{pk}^{U})$}
        \step{2. Return $\textsf{MT}'$}
    \end{multicols}
    \end{minipage}
};


\end{tikzpicture}
\caption{\tool construction.} %NB: Each participant maintains a list of public keys.
\label{fig:construction}
\end{figure*}