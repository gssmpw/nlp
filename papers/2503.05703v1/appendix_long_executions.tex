\section{Additional information on long executions}

Here we provide the implementations of the algorithmic tasks used for the long executions section. Note that to encourage models to attend rather than memorized, in this case we replace function names with \texttt{f} when ingesting these functions to the models.

\subsection{Collatz}

\texttt{collatz} returns the number of iterations needed to arrive to 1 in the Collazt sequence.
\begin{verbatim}

def collatz(n):
    steps = 0
    while n > 1:
        steps += 1
        if n % 2 == 0:
            n = n // 2
        else:
            n = 3 * n + 1
    return steps

\end{verbatim}


\subsection{Binary counter}
\texttt{binary\_counter} implements a 4-bit binary counter by hand.

\begin{verbatim}
def binary_counter(n):
    a = False
    b = False
    c = False
    d = False
    for i in range(n):
        if not d:
            d = True
        elif not c:
            c = True
            d = False
        elif not b:
            b = True
            c = False
            d = False
        else:
            a = not a
            b = False
            c = False
            d = False
    return a, b, c, d
\end{verbatim}

\subsection{Iterative Fibonacci}
\texttt{fibonacci} is an iterative implementation of Fibonacci.

\begin{verbatim}
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    prev_prev = 0
    prev = 1
    for i in range(2, n + 1):
        curr = prev_prev + prev
        prev_prev = prev
        prev = curr
    return prev
\end{verbatim}
