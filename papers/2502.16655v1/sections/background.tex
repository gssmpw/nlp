

Key programming constructs—such as sequences, conditionals, and
especially loops or repetitions are fundamental to learning
programming. However, learning to program remains a complex task for
young learners, who may have misconceptions about fundamental concepts
like loops~\cite{qian2017students,sorva2012visual}, which are known to
be one of the most challenging concepts for children to
grasp~\cite{DBLP:journals/ijcci/GomesFT18,DBLP:conf/sigcse/GroverB17}. Research
has shown that concrete, hands-on experiences can significantly aid
learners in overcoming these difficulties and developing abstract
thinking
skills~\cite{DBLP:journals/ijcci/GomesFT18,DBLP:conf/sigcse/GroverB17,DBLP:journals/eait/MladenovicBZ18}. To
ensure learners are engaged in these experiences, gamification has
been shown to be an effective solution.


\subsection{Educational  Testing Games}

Gamification integrates game-like elements—such as leaderboards,
points, and challenges—into non-game
settings~\cite{DBLP:conf/mindtrek/DeterdingDKN11}.
% DBLP:conf/icse/StraubingerF22,DBLP:conf/icse/StraubingerF23
Serious games take this approach further by explicitly aiming to
educate, train, or simulate real-world tasks with real gameplay. By engaging players
with embedded learning experiences, such games allow them to acquire
knowledge or skills without feeling as though they are in an
educational setting~\cite{DBLP:conf/chi/RaybournB05}. Consequently,
many educational games focus on various aspects of
programming~\cite{DBLP:journals/bjet/LindbergLH19,DBLP:journals/ijcci/MacridesMA22,DBLP:journals/ijcci/GomesFT18}. The
loop programming concept has also been the focus of gamification
strategies and serious games to aid
learning~\cite{shorn2018teaching,DBLP:conf/dac/BoroujerdianGCP21,zhao2019improving,makri2019computer}.

Although testing has been proposed as a means of supporting student
understanding~\cite{denny2019closer,prather2018metacognitive,wrenn2019executable,prasad2023conceptual},
and introducing testing concepts early has been shown to improve
students' understanding of coding practices and their ability to write
robust programs~\cite{DBLP:conf/acse/Carrington97,
	jones2001experiential,DBLP:conf/iticse/MarreroS05}, it remains
underemphasized in programming
instruction~\cite{DBLP:journals/jss/GarousiRLA20}. Serious gaming has
also seen only limited applications related to software
testing~\cite{DBLP:conf/icer/MiljanovicB17,
	DBLP:conf/icse/PrasetyaLMTBEKM19, DBLP:conf/fie/ToledoLS22}.


One successful approach to gamifying testing concepts is to use
mutation testing, as exemplified by games like Code
Defenders~\cite{DBLP:conf/sigcse/FraserGKR19}, Code Immunity
Boost~\cite{hsueh2023design} or the Testing
Game~\cite{DBLP:conf/fie/ValleTBM17}. In mutation testing, artificial
defects (or mutants) are deliberately introduced into the code to
assess the robustness of existing tests~\cite{5487526}. The process
involves creating slight variations of the code under test and running
the available test suite against them. When a test fails, it indicates
the mutant has been detected or \emph{killed}; if the mutant survives,
it highlights potential gaps in the test coverage and assertion
quality. Games like Code Defenders~\cite{DBLP:conf/sigcse/FraserGKR19}
gamify this process by allowing ``attackers'' to generate mutants,
while ``defenders'' work to identify and eliminate these defects by
writing tests.

Existing testing games typically require advanced programming
knowledge, limiting their accessibility to higher education
audiences. To engage younger or less experienced learners, testing
needs to be introduced earlier in programming curricula and presented
in a more approachable manner. A promising solution to this challenge
lies in the use of block-based programming environments, such as
Scratch~\cite{maloney2010scratch}, which has been successful in
making programming accessible to beginners. In these environments,
learners construct programs by dragging and connecting visual blocks
of code, bypassing the complexity of traditional textual
programming. This intuitive method has been shown to lower the
barriers to entry for novice programmers, enabling them to create
games and other programs
quickly~\cite{DBLP:journals/cacm/BauGKST17}. This concept is used by
the Code Critters mutation testing
game~\cite{10675860,DBLP:conf/icst/StraubingerCF23}, a block-based
approach to introduce software testing concepts to younger learners,
making testing more accessible.





\subsection{The Code Critters Game}

\label{sec:codecritters}

\toolname is an educational browser game that aims to make software
testing fun and engaging for young learners. It blends the classic
Tower Defense game style with lessons on block-based programming and
software testing, all spread across ten levels.
%This open-source web
%application is freely accessible at
%\mbox{\url{https://code-critters.org}}.
%
The game focuses on critters, who are a humanoid species that have
long lived peacefully in the deep, mysterious forests of an isolated
land. Their harmonious existence is disrupted when a sudden outbreak
of an unknown disease spreads through their colony. As more critters
become infected, they begin to show unusual and disturbing behavior,
threatening the colony's peace. In response, the remaining critters
are forced to abandon their city and seek refuge in a safe tower deep
within the forest.

The initial levels of \toolname portray this evacuation, as illustrated in \cref{fig:baseGameplay}. Both infected and healthy critters attempt to flee their village and reach the safe tower. The player's objective is to ensure that only the healthy critters make it to safety, using magical portals to keep the infected ones away.

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{img/baseGameplay.png}
	\caption{Gameboard of \toolname during gameplay}
	\label{fig:baseGameplay}
\end{figure}

\subsubsection{Game Concept}

As the critters make their way from the village to the tower, the
player's task is to identify and separate the healthy critters from
the infected ones (mutants) to protect the tower. The infected
critters can be easily recognized by their mutated, green appearance
(\cref{fig:baseGameplay}). However, the most important difference
between healthy critters and mutants lies in their behavior. This
behavior is referred to as the Critter Under Test (CUT) and consists
of a series of code instructions that guide the critters' actions as
they move.
%
The orange-framed box on the right side of \cref{fig:gameScreen} shows
the Critter Under Test (CUT) for Level 1, alongside the corresponding
game board on the left. 
%
\toolname utilizes the
Blockly\footnote{https://developers.google.com/blockly} library, which
provides visual, block-based programming instead of traditional
text-based code, making it more accessible for beginners. With each
level, the CUT's complexity increases, offering progressively more
challenging gameplay.

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{img/fullBaseGame.png}
	\caption{Game screen of base level 1}
	\label{fig:gameScreen}
\end{figure}


%
The functions within the CUT are similar to
methods in an object-oriented class, defining the critters' attributes
and behavior.
%
The \textit{Initialization} section (\cref{fig:gameScreen}) sets the initial attributes of the critters as they leave their village. The \textit{Executed code on each tile} section outlines the critter's behavior as it moves through the game, with specific instructions that are carried out on each tile it steps on. Unlike healthy critters, mutants deviate from the defined behavior in at least one way.


In the Level 1 example shown in \cref{fig:gameScreen}, a healthy critter starts wearing a red shirt and changes to an orange shirt when moving onto a dirt tile. In contrast, the altered code of a mutant might cause it to start with a blue shirt instead of red or change to a pink shirt instead of orange when stepping on dirt.

The game board that the critters navigate is made up of a 16 by 16 grid of tiles with different terrains: grass, dirt, ice, water, or wood. Critters can only walk on grass, dirt, and ice. The game board is displayed on the left-hand side of \cref{fig:gameScreen}, with one portal placed along the path.

\subsubsection{Gameplay}

\begin{figure}
	\centering
	\includegraphics[width=\linewidth]{img/baseGamePortalUpdated.png}
	\caption{Opened portal of base level 1}
	\label{fig:gameWithPortal}
\end{figure}

The game board features the village where the critters start walking, the tower as their destination, and at least one path connecting them through the forest. The player's goal is to strategically place portals along the critters' path, allowing only the uninfected ones to pass. Mutants, on the other hand, are teleported by these portals to a safe location until a cure is discovered.

Portals act as block-based tests that help distinguish between mutant and healthy behavior. To ensure that no mutants reach the tower, the player must carefully check the CUT. \Cref{fig:gameWithPortal} illustrates the code for a portal placed on the first dirt tile. This test runs when a critter steps on that tile, verifying the expected behavior. Similar to traditional assertions, the \textit{only critters with ... equals ... can pass} block ensures that critters have the correct attributes when they reach specific fields.

Once the game begins, critters leave the village and move toward the tower, stepping onto tiles with portals along the way. As they walk across portals, these execute their checks, e.g., for correct shirt color transitions in \cref{fig:gameWithPortal}, allowing passage \textit{only} to critters dressed in orange. If a mutant is detected, it is teleported away, visualized by the captured mutant flying across the screen to a holding area. Note that players can only see the code of correct critters while playing, while mutations are only shown after level completion.

The game ends once the last critter either reaches the tower or is intercepted by a portal. The player then receives a score based on the percentage of identified mutants and the number of healthy critters that reach the tower. Achieving a perfect score of 1000, or three stars, requires correctly capturing all mutants while letting all healthy critters pass. Players can earn up to an additional 10\% bonus for quickly installing the portals, bringing the maximum score to 1100.

\begin{figure}
	\centering
	\includegraphics[width=0.8\linewidth]{img/score.png}
	\caption{Scoreboard after finishing a base level}
	\label{fig:baseScoreDialog}
\end{figure}


\Cref{fig:baseScoreDialog} shows the score dialog after completing Level 1 using the portal setup from \cref{fig:gameWithPortal}. In this example, the player did not achieve a perfect score because not all mutants were successfully captured. To catch the remaining mutants and earn a full score, an additional test (i.e., portal) is needed to ensure that critters start their path with the correct red shirt.
%

\begin{figure*}
	\centering
	\includegraphics[width=0.8\linewidth]{img/fullLoopGame.png}
	\caption{Game screen of loop level 1}
	\label{fig:loopLevel1screen}
\end{figure*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../paper"
%%% End:
