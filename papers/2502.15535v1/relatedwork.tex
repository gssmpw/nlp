\section{Related work}
\label{related}
\label{related_work}
One of the software verification technique that embodies the concept of loop unrolling is
Bounded Model Checking (BMC) \cite{Biere2003BoundedMC},  which reduces model checking of linear temporal logic (LTL) formulas to propositional satisfiability.  
BMC operates by unrolling the transition relation of a finite state machine for a fixed number of steps k, and then checking whether a property violation can occur. If no violation is found, k is increased, and the process is repeated. This approach allows for a systematic exploration of the state space, with the bound k serving as a parameter to control the depth of the search.
%The core idea behind BMC is to represent a potential counterexample path of bounded length symbolically and then check the resulting propositional formula using a SAT solver. %This method is primarily used for falsification or testing, focusing on violations of temporal properties. Which is why it has relations to this work.

%BMC has shown remarkable efficiency in finding counterexamples. Its efficiency makes it particularly attractive for industrial applications. The present work shares similarities with BMC. 
%BMC is applying breadth first search on the transitions system and analyzing this underapproximation. In program analysis, this method unwinds loops, asserting desired properties in the unwound (unrolled) structure. A model checker then attempts to prove these assertions.
The approach of this article, while similar in its unrolling technique, constructs different properties: if a prover finds a counterexample to an assertion, this counterexample serves as a test case, guaranteed to reach both the desired depth in the loop and the specified position within the loop body.
Another distinctive property of the present work lies in its treatment of unwinding correctness. In the BMC literature, the correctness of unwinding is often assumed, either treated as self-evident or accepted axiomatically. The research reported here goes beyond this assumption: we provide a formal proof demonstrating the equivalence between the unrolled loop and the original loop structure.

Two notable tools that implement BMC are CBMC \cite{kroening2014cbmc} and JBMC \cite{brenguier2023jbmc}, which verify C and Java programs against the annotated  assertions, with loops unrolled to a given depth. They can also be used as test generation tool, which automatically generate tests that satisfy a certain code coverage criteria.
This concept of loop unrolling has also been integrated into a test generation tool PathCrawler \cite{williams2005pathcrawler, williams2021towards} which performs unit testing of C programs to obtain path coverage. It reduces the problem of covering all loop paths in a loop is to a \emph{k-path} objective with the aim of covering loop paths within k loop iterations. Compared to the present work, such tools apply the idea of loop unrolling to either improve the efficiency of exploration of systems' behaviors or to systematically cover different loop paths.


Like the present work, Huster et al. \cite{huster2015efficient} went beyond the traditional criterion of branch coverage and proposed an approach to detect more possible failures by explicitly addressing various patterns of loop iteration orders. They group iteration orders that influence one another into equivalence classes based on how the current loop iteration affects the next, thereby reducing the complexity of covering all possible loop path variations.