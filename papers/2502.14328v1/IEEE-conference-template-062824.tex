\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%Template version as of 6/27/2024

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{multirow}
\usepackage{booktabs} % For formal tables
% \usepackage{natbib}

\makeatletter
\newcommand{\linebreakand}{%
  \end{@IEEEauthorhalign}
  \hfill\mbox{}\par
  \mbox{}\hfill\begin{@IEEEauthorhalign}
}
\makeatother

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\usepackage[most]{tcolorbox}
\newtcolorbox{promptbox}[1][]{ 
  colback=gray!5,              % 背景
  colframe=black,
  colbacktitle=gray!5,
  coltitle=black,               % 标题颜色
  rounded corners,               % 设置圆角
  title,                  
  fonttitle=\bfseries,
  #1                           
}
\begin{document}

\title{SolSearch: An LLM-Driven Framework for Efficient SAT-Solving Code Generation
\thanks{* Equal contribution. This work was supported by National Key Research and Development Program (No.2022YFB3305200), NSFC (No.62161146001, 92370201), STCSM (No.22QB1402100). ({\em{Corresponding author: Xiangfeng Wang and Jianqi Shi}})
}}

\author{\IEEEauthorblockN{Junjie Sheng$^{*}$}
\IEEEauthorblockA{\textit{School of Computer Science and Technology} \\
East China Normal University \\ Shanghai, China \\
jarvis@stu.ecnu.edu.cn}
\and
\IEEEauthorblockN{Yanqiu Lin$^{*}$}
\IEEEauthorblockA{\textit{Software Engineering Institute} \\
East China Normal University\\ Shanghai, China\\
51255902092@stu.ecnu.edu.cn}
\and
\IEEEauthorblockN{Jiehao Wu$^{*}$}
\IEEEauthorblockA{\textit{School of Computer Science and Technology} \\
East China Normal University\\ Shanghai, China \\
51255901123@stu.ecnu.edu.cn}
\linebreakand
\IEEEauthorblockN{Yanhong Huang}
\IEEEauthorblockA{\textit{Software Engineering Institute} \\
East China Normal University\\ Shanghai, China \\
yhhuang@sei.ecnu.edu.cn
}
\and
\IEEEauthorblockN{Jianqi Shi}
\IEEEauthorblockA{\textit{Software Engineering Institute} \\
East China Normal University\\ Shanghai, China \\
jqshi@sei.ecnu.edu.cn}
\and
\IEEEauthorblockN{Min Zhang}
\IEEEauthorblockA{\textit{Software Engineering Institute} \\
East China Normal University\\ Shanghai, China\\
zhangmin@sei.ecnu.edu.cn}
\linebreakand
\IEEEauthorblockN{Xiangfeng Wang}
\IEEEauthorblockA{\textit{School of Computer Science and Technology} \\
% \textit{Shanghai Formal-Tech Information Technology Co., Lt}\\
East China Normal University\\ Shanghai, China \\
xfwang@cs.ecnu.edu.cn}
}
\maketitle
\begin{abstract}
The Satisfiability (SAT) problem is a core challenge with significant applications in software engineering, including automated testing, configuration management, and program verification. This paper presents SolSearch, a novel framework that harnesses large language models (LLMs) to discover and optimize SAT-solving strategies automatically. Leveraging a curriculum-based, trial-and-error process, SolSearch enables the LLM to iteratively modify and generate SAT solver code, thereby improving solving efficiency and performance.
This automated SAT-solving paradigm has the advantage of being plug-and-play, allowing integration with any SAT solver and accelerating the development or design process of new SAT solvers (new methods). Our preliminary experimental results are encouraging by demonstrating that the LLM-powered paradigm improves state-of-the-art SAT solvers on general SAT benchmarks and significantly enhances the performance of the widely used Z3 solver (11\% on PAR-2 score). These results highlight the potential for using LLM-driven methods to advance solver adaptability and effectiveness in real-world software engineering challenges.
Future research directions are discussed to further refine and validate this approach, offering a promising avenue for integrating AI with traditional software engineering tasks.
\end{abstract}

\begin{IEEEkeywords}
Large Language Models (LLM), SAT Solver, Code Generation, Heuristic Method
\end{IEEEkeywords}

\section{Introduction}
The Satisfiability (SAT) problem is a foundational concept in computational theory with significant applications across various domains~\cite{implication-color,implication-industry,implication-vertex}, especially in software engineering~\cite{SE-model,SE-theory}. SAT solvers are essential tools for automating tasks such as software testing~\cite{software_testing}, configuration management, and program verification~\cite{verification}. By determining whether a logical formula is satisfiable, they play a crucial role in ensuring software systems' reliability, safety, and performance. Despite their impressive capabilities, how to design a powerful SAT-solver remains an open problem. 

Traditionally, modifying existing SAT solvers or designing new ones relies on rigid, manually tuned techniques tailored to specific problem types~\cite{cadical,kissat}. This approach is labor-intensive, time-consuming, and often lacks generalizability when applied to diverse or novel problem instances. As modern software engineering projects grow in complexity, these limitations will become increasingly burdensome. There is an urgent demand for new automated and adaptive SAT solvers capable of enhancing performance across varied problems.

In recent years, large language models (LLMs) have demonstrated impressive capabilities in mimicking human roles across various tasks, including natural language processing~\cite{LLM-NLP}, coding~\cite{LLM-code}, and problem-solving~\cite{LLM-task}. Beyond these applications, recent studies suggest that LLMs can also assume the role of an expert in innovation, capable of generating novel strategies—for instance, discovering new bin-packing policies~\cite{Funsearch}. This raises an intriguing question: \textit{can LLMs also be harnessed to aid in the discovery of SAT solvers?}

This paper introduces SolSearch, a novel framework that leverages LLMs to automatically discover and optimize SAT-solving strategies, fundamentally transforming SAT solver design. Through a curriculum-based, trial-and-error process, the LLM iteratively modifies portions of the solver’s code to improve efficiency and performance. This dynamic adaptation enables the solver to adjust its approach based on the unique characteristics of each problem, moving beyond static, pre-configured solutions. By integrating LLMs into the optimization process, we transition from rigid, manual adjustments to an automated, flexible methodology capable of adaptively generating novel solving techniques. Extensive experiments show that SolSearch improves state-of-the-art SAT solvers on general benchmarks and significantly boosts the performance of Z3, a widely used solver in software engineering, achieving an 11\% improvement in the PAR-2 score.

\section{Background}
\subsection{The SAT Problem}
% The Boolean satisfiability problem (SAT)~\cite{Handbook} is the task of determining whether there exists an assignment $A$ such that a given Boolean expression $f$ evaluates to TRUE. 
% In the research of SAT problems and the development of SAT solvers, Boolean expressions are commonly provided in the form of Conjunctive Normal Form (CNF)~\cite{SATproblem}. 
% A CNF consists of the conjunction$(\vee)$ of multiple clauses, where each clause is a disjunction$(\wedge)$ of several literals, and a literal is either a Boolean variable or its negation. 

\begin{figure*}[t]
\centering
\includegraphics[width=0.9\textwidth]{Figures/methodology.pdf}
\caption{Overview of SolSearch. It has two phases: curriculum-proposing and solver-searching. The curriculum-proposing phase creates tasks. The solver-searching phase loops through selector, searcher, and evaluator to improve solvers. This cycle repeats as new tasks are proposed.}
\label{fig:methodology}
\end{figure*}


The satisfiability problem (SAT) determines if there exists an assignment $A$ that makes a given Boolean expression $f$ true. 
In SAT, Boolean expressions are commonly provided in the form of Conjunctive Normal Form (CNF)~\cite{SATproblem}.
Let us consider the set of variables $V = \{v_1, v_2, v_3\}$ and the formulation
\begin{equation}\label{eq:basic-formulation}
    f(V) = (v_1 \wedge \neg v_2) \vee v_3,\nonumber
\end{equation}we can express the above formulation in form of a CNF as
\[
f_0(V) = (v_1 \vee v_3) \wedge (\neg v_2 \vee v_3).
\]
% comprising the clauses $c_1 = (v_1 \vee v_3)$ and $c_2 = (\neg v_2 \vee v_3)$, with the literals $L = \{v_1, \neg v_2, v_3\}$. 
There exists an assignment $A_1(V) = \{1, 1, 1\}$ that results in $f(V) = \text{TRUE}$, demonstrating that $f(V)$ is SATISFIABLE.

% The DPLL (Davis-Putnam-Logemann-Loveland)~\cite{DPLL} algorithm, which is a complete method for SAT, refines the Davis-Putnam algorithm by using a recursive binary tree search to determine satisfiability.
% The CDCL (Conflict-Driven Clause Learning)~\cite{CDCL} algorithm, pivotal in modern SAT solvers~\cite{CDCL-Glucose,CDCL-minisat,CDCL-EVSIDS}, enhances searches through conflict management and learning mechanisms like variable selection and unit propagation. Contrarily, the Stochastic Local Search (SLS)~\cite{SLS} utilizes variable flipping to find solutions.
% SLS-type incomplete methods have been proven to be valuable when complete algorithms are resource-limited.

% % 工业上工具
% In both acdemic and industrial communities, a variety of tools are available that are suited for different purposes.
% CaDiCaL~\cite{cadical} is an advanced and efficient SAT solver characterized by its concise design. It exhibits outstanding performance in addressing large-scale SAT problems.
% Kissat SAT solver~\cite{kissat}
% %, developed by the team behind CaDiCaL in C, 
% extends the simplistic design with optimized structures and algorithms to improve SAT problem-solving performance.
% Z3 SAT solver~\cite{Z3}, a theorem prover from Microsoft Research, features a robust API with support for languages like C++ and Python.
% Z3 includes a full SAT solver and offers extensibility as an open-source project.

% However, it must be emphasized that under the current mindset, designing new SAT solvers is not an easy task. Moreover, given the variety of problems and scenarios, developing methods with universal solving applicability seems to be even more challenging.
% For instance, in the annual SAT Competition~\cite{satcomp2023,satcomp2024}, the top rankings consistently fluctuate as shown in Table \ref{tab:satcompresults}.
% This phenomenon indicates that it is not feasible to develop a universally optimal and consistently superior solver for all SAT problems once and for all.

The Davis-Putnam-Logemann-Loveland algorithm~\cite{DPLL} is a complete method for solving SAT problems that refine the original Davis-Putnam algorithm by employing a recursive binary tree search to determine satisfiability. Building upon this, the CDCL (Conflict-Driven Clause Learning) algorithm~\cite{CDCL}, which is pivotal in modern SAT solvers~\cite{CDCL-Glucose, CDCL-minisat, CDCL-EVSIDS}, enhances the search process through conflict management and learning mechanisms such as variable selection heuristics and unit propagation. In contrast, Stochastic Local Search (SLS) ~\cite{SLS} utilizes variable flipping strategies to find solutions. SLS-type incomplete methods have proven valuable, especially when complete algorithms are constrained by limited resources.

In both academic and industrial communities, a variety of tools are available, each suited for different purposes. CaDiCaL~\cite{cadical} is an advanced and efficient SAT solver characterized by its concise design, exhibiting outstanding performance in addressing large-scale SAT problems. The Kissat SAT solver~\cite{kissat} builds upon this simplistic design by incorporating optimized structures and algorithms to further improve problem-solving performance. Z3~\cite{Z3}, a theorem prover from Microsoft Research, features a robust API with support for languages like C++ and Python. As an open-source project, Z3 includes a comprehensive SAT solver and offers extensibility.

However, it must be emphasized that designing new SAT solvers under the current mindset is not an easy task. Given the variety of problems and scenarios, developing methods with universal applicability is even more challenging. For instance, in the annual SAT Competition~\cite{satcomp2023,satcomp2024}, the top rankings consistently fluctuate, as shown in Table \ref{tab:satcompresults}. This phenomenon indicates that it is not feasible to develop a universally optimal solver for all SAT problems once and for all.
\begin{table}[htbp]
\centering
\caption{SAT Competition Results for 2022-2024}
\label{tab:satcompresults}
\resizebox{\columnwidth}{!}{
\begin{tabular}{@{}cccc@{}}
\toprule
\textbf{Rank} & \textbf{2022} & \textbf{2023} & \textbf{2024} \\
\midrule
1 & Kissat\_MAB-HyWalk & SBVA Cadical & kissat-sc2024 \\
2 & kissat\_inc & KissatMabProp PrNosym & Kissat\_MAB-DC \\
3 & kissat\_pre & KissatMabProp & hKis-bva \\
\bottomrule
\end{tabular}
}
\end{table}
\subsection{LLMs in Code Generation}
% % LLM在代码生成领域的工作
% In recent years, with the development of large language models (LLMs), an increasing number of fields have utilized LLMs to achieve varying degrees of development and progress, including the domain of code generation.

% % In the EUREKA~\cite{Eureka} project, Ma et al. pioneeringly focused on complex low-level manipulation tasks, leveraging the superior code generation capabilities of LLMs for optimizing the code of reward functions. They combined human inputs to ensure the legality and safety of the generated code, ultimately achieving results that surpassed those designed by human experts.
% % Romera-Paredes et al. introduced FunSearch~\cite{Funsearch}, which employs a combination of a pre-trained LLM and a system evaluator to search through function space for programs that describe how to solve problems. This approach led to superior solutions for classic algorithmic problems such as cap set and bin packing, surpassing the outcomes of existing LLM-based discoveries.
% % EoH~\cite{EoH} integrates LLMs with evolutionary computation, exploiting their synergistic effects to mimic the process by which human experts design and develop heuristic algorithms. This integration enables more efficient and cost-effective automatic heuristic design, yielding more refined and effective heuristic algorithms in a short period of time, significantly outperforming manually designed algorithms by human experts.
% In the EUREKA\cite{Eureka} project, Ma et al. focused on complex manipulation tasks, using LLMs for optimizing reward function code, enhanced with human inputs for legality and safety, achieving expert-surpassing results. 
% Romera-Paredes et al. developed FunSearch\cite{Funsearch}, combining a pre-trained LLM and system evaluator to find solutions in function space, yielding superior results for problems like cap set and bin packing. 
% EoH\cite{EoH} merges LLMs with evolutionary computation to efficiently design heuristic algorithms, significantly outperforming manual designs by experts.
% % Sun et al. proposed AutoSAT, a method that utilizes LLMs to automatically optimize heuristic functions in SAT solvers, thereby enhancing the performance of the solver EasySAT.

% % 启发：利用大模型来重塑SAT方法的设计范式
% % 针对问题或场景来优化SAT方法
% % 形成LLM辅助的SAT求解新方法设计，以及已有SAT方法优化
% These efforts have also provided significant insights, suggesting that reshaping the design paradigms of SAT solving methods is feasible in the era dominated by large language models. As the optimization directions for SAT solving methods vary with different problems or scenarios, the integration of LLMs has become an essential component. This integration is expected to forge a new paradigm in SAT solving: the design of novel SAT solving methods assisted by LLMs, and the enhancement of existing SAT methods through LLM support.



In recent years, the advent of large language models (LLMs) has spurred transformative innovations across diverse fields, particularly in complex tasks like code generation~\cite{code-generation}. For example, the EUREKA project~\cite{Eureka} utilized LLMs to optimize reward function code for complex manipulation tasks. By integrating human feedback for legality and safety, the project achieved results that surpassed expert-crafted solutions, showcasing the ability of LLMs to innovate beyond conventional methods. Similarly, Google DeepMind's FunSearch~\cite{Funsearch} combines a pre-trained LLM with an evaluator to explore solutions within function space. This hybrid approach has yielded groundbreaking results in challenging problems such as the cap set problem and bin packing, outperforming traditional optimization techniques. Evolution of Heuristics (EoH)~\cite{EoH}, merges LLMs with evolutionary computation to automatically design heuristic algorithms. This combination significantly outperforms manual designs created by domain experts, highlighting LLMs’ potential to discover novel solutions that extend the boundaries of existing knowledge.




These advancements indicate that LLMs are not merely tools for automation but are also catalysts for innovation, reshaping how we approach problem-solving and algorithm design. The varied optimization strategies required for SAT solvers across different scenarios underscore the need for such adaptive and innovative capabilities. As the role of LLMs continues to expand, their integration into SAT-solving processes is expected to drive a new paradigm: the enhancement of existing SAT solvers. By leveraging LLMs, we can transcend traditional approaches, enabling the development of SAT solvers that are more flexible, adaptive, and effective across a broad spectrum of applications.

\section{SolSearch}

%\subsection{Overview}
The proposed SolSearch paradigm is illustrated in Fig.~\ref{fig:methodology} and involves two phases: the curriculum-proposing stage and the solver-searching stage. In the curriculum-proposing stage, optimized curricula are developed to strategically guide the subsequent phase. Following this, the solver-searching stage focuses on searching for the most effective SAT solvers for the curricula at hand. Through repeated curriculum development and solver identification, SolSearch efficiently discovers and tailors high-performing solvers to meet the specific demands of the problem.
Designed for versatility and adaptability, SolSearch functions seamlessly as a plug-and-play module in various software engineering tasks.
\begin{promptbox}[title=Prompt For Solver Searching] % 更改标题
Optimizing the \texttt{inc\_activity} function within SAT solvers using VSIDS heuristic.

\textbf{Requirements:}
\begin{itemize}
    \item \textbf{Function Name:} \texttt{inc\_activity}
    \item \textbf{Language:} C++
    % \item \textbf{Complexity:} Include multiple conditional logics and loops for efficiency.
    \item \textbf{Dependencies:} No undefined functions, variables, or external libraries.
    % \item \textbf{Guarantees:} No exceptional interruptions. 
    % The function should advance beyond the current version.
\end{itemize}

\textbf{Reference Function:} \texttt{inc\_activity}
\begin{verbatim}
void solver::inc_activity() {
    //example code
}
\end{verbatim}
\begin{itemize}
    \item \textbf{Behavior:} Increases activity by a fixed amount, checks for overflow, and rescales if needed. Manages variable priorities within a priority queue.
\end{itemize}

\textbf{Task:} Develop the optimized \texttt{inc\_activity} function following the guidelines.
\label{prompt}
\end{promptbox}
\subsection{Curriculum-Proposing Stage}

The curriculum-proposing stage of SolSearch plays a crucial role by generating a sequence of tasks, or curricula, to effectively guide the solver-searching process. Tackling highly challenging tasks directly can be difficult; however, by progressing from simpler to more complex tasks (curriculum learning), these tasks become more manageable. This stage is dedicated to designing curricula that are both challenging and optimizable, enabling gradual improvements.

In this phase, SolSearch assesses the characteristics of the current problem and designs a diverse set of training instances that vary in complexity. The primary metric for success is the number of instances solved within a specified timeout limit. Optimization efforts are geared towards maximizing this metric, which encourages solvers to enhance their efficiency.

Following the principles of curriculum learning, the initial timeout is set conservatively as 100 seconds. This strategy challenges the solver with simpler instances initially, promoting rapid improvements by focusing on increasing the number of instances solved within this shorter timeframe. As each optimization cycle concludes, the timeout limit for the subsequent round is increased based on the performance of the newly optimized solver on a test set. 

This approach ensures that solvers face a progressive and systematic challenge, providing consistent optimization opportunities while incrementally raising the difficulty level.

\subsection{Solver-Searching Stage}

The solver-searching stage is dedicated to finding solvers that optimize performance for the specified curriculum. This stage is structured around three main components: the selector, the searcher, and the evaluator, each playing a crucial role in enhancing solver capabilities.

The selector component is charged with deciding which portions of the solver's code should be optimized in the current iteration. This decision process is driven by the solver’s performance metrics on the provided curriculum, pinpointing code segments where significant enhancements are most likely.

The searcher then takes over by using a Large Language Model (LLM) to generate new code implementations for the selected patch. It operates by responding to a detailed prompt that describes the target heuristic functions and outlines specific requirements including dependencies and performance guarantees. These prompts are designed to ensure that the new code not only fulfills basic functional requirements but also integrates effectively with existing components and meets stringent performance standards. Further setting exploration temperatures for LLM, enables the searcher to produce diverse and valid code solutions that adhere to the demanding needs of SAT solver development.

\begin{figure*}[htbp!]
\centering
\includegraphics[width=\textwidth]{Figures/3in1.pdf}
\caption{Performance comparison of SolSearch on CaDiCaL and Kissat in SAT Competition 2023. Left: SolSearch improves PAR-2 scores for both. Middle and right: SolSearch boosts solved ratios across most timeout settings.}
\label{fig:cadical_kissat}
\end{figure*}

Finally, the evaluator assesses the effectiveness of the newly generated solvers by measuring solution accuracy, computation time, and resource utilization. The top-performing solver from this assessment is chosen and returned to the selector for further refinement in the next cycle. This iterative process continues until the system finds a solver that satisfies the desired performance benchmarks.

Through the coordinated efforts of the selector, searcher, and evaluator, the solver-searching stage methodically explores and implements potential improvements, leading to the development of an optimized solver that is ideally suited for the task at hand. This systematic process ensures continuous enhancement and fine-tuning of solver performance.

% The solver-searching stage is responsible for searching solvers that can effectively optimize performance for the given curriculum. It consists of three main components: the selector, the searcher, and the evaluator.

% The \textbf{selector} is responsible for determining which part of the solver's code should be optimized during the current iteration. This decision is guided by the performance metrics of the solver on the given curriculum, searching code segments that are likely to yield the most significant improvements.

% The \textbf{searcher} takes the selected code patch and utilizes a Large Language Model (LLM) to generate new implementations for that patch. Specifically, it adopts the prompt~\ref{prompt} to generate the new patch. The prompt includes detailed descriptions of the target heuristic functions as well as specific requirements related to dependencies and guarantees. These prompts outline the basic functionality needed, the expected interactions between components, and conditions that must be met to ensure solving efficiency. By incorporating dependencies and guarantees within the prompts, the searcher is better equipped to generate valid and efficient code that meets the stringent demands of SAT solver development.

% The generated implementations are designed to explore a variety of potential solutions, enhancing the diversity of solver versions and ensuring the exploration of different optimization strategies.

% The \textbf{evaluator} then assesses the performance of the newly generated solvers. Each solver is evaluated based on its ability to solve the given curriculum efficiently, using metrics such as solution accuracy, computation time, and resource utilization. The best-performing solver is selected and passed back to the selector for further optimization in the next iteration. This iterative cycle continues until the system converges on a solver that meets the desired performance criteria.

% By coordinating the efforts of the selector, searcher, and evaluator, the solver-searching stage ensures a systematic exploration of potential solver improvements, ultimately leading to an optimized solver that is well-suited for the given task.

% SAT solvers use various heuristics\cite{heuristic-BerkMin,heuristic-CDCL,heuristic-CHB,heuristic-JW} to efficiently solve SAT problems by adjusting the activity scores of variables and deciding when to restart.
% These strategies help manage variable selection after conflicts and aid in escaping local optima to enhance solver efficiency. 
% In experimentation, these heuristic methods are identified in the source code and progressively optimized, periodically switching the focus to different heuristic functions. 

% The dataset is comprised of a training set, a validation set, and a test set. The test set constitutes the entire dataset, while the validation set is designated as 60\% of the entire dataset. The test set is randomly generated from the validation set at each step of optimization.





% As illustrated in Figure \ref{fig:methodology}, our method comprises an external loop and an internal loop.



% The internal loop, which is each round of optimization, involves interactions among the function selection module, function search module, and function evaluation module. Each step of optimization entails the search for an improved form of a heuristic function selected, followed by the evaluation of the new function. The specific design is described as follows:

% Let us define the following symbols:
% \begin{itemize}
%     \item $V$ represents the entire validation set, containing 60\% instances of the entire dataset.
%     \item $T_k$ represents the test set for the $k$-th optimization iteration, which is randomly selected from $V$.
%     \item $\tau$ is the timeout limit.
%     \item $S_{\text{old}}(i)$ denotes the resolution result of instance $i$ in the score table: 1 if solved within the timeout limit, 0 otherwise.
%     \item $\text{Total}_{\text{old}}$ is the total score, i.e., the number of instances successfully solved in $V$:
%     \[
%     \text{Total}_{\text{old}} = \sum_{i \in V} S_{\text{old}}(i)
%     \]
% \end{itemize}

% Upon generating a new heuristic function $h$, it is first tested on $T_k$. Define $S_{\text{new}}^{T_k}$ as the number of instances successfully solved by $h$ in $T_k$:
% \[
% S_{\text{new}}^{T_k} = \sum_{i \in T_k} \mathbf{1}(\text{solve}(i, \tau, h) \text{ is successful})
% \]

% where $\mathbf{1}(\cdot)$ is the indicator function.


% Compare $S_{\text{new}}^{T_k}$ with the sum of corresponding values of $S_{\text{old}}$ on $T_k$:
% \[
% S_{\text{old}}^{T_k} = \sum_{i \in T_k} S_{\text{old}}(i)
% \]

% If $S_{\text{new}}^{T_k} > S_{\text{old}}^{T_k}$, then use heuristic $h$ for further verification on the entire validation set $V$. Compute the number of instances successfully solved in $V$ by $h$, denoted as $S_{\text{new}}^V$:
% \[
% S_{\text{new}}^V = \sum_{i \in V} \mathbf{1}(\text{solve}(i, \tau, h) \text{ is successful})
% \]

% If $S_{\text{new}}^V$ exceeds $\text{Total}_{\text{old}}$, then update $S_{\text{old}}$ and $\text{Total}_{\text{old}}$ to $S_{\text{new}}^V$ and $\text{Total}_{\text{new}}$:
% \[
% \text{Total}_{\text{new}} = S_{\text{new}}^V
% \]

% Once the number of optimization steps reaches the designated maximum, we observe the performance of the optimized functions on a test set and determine the timeout limit for the next round of experiments based on this. By progressively advancing in this manner, we can more efficiently obtain an optimized SAT solver.

\section{Experimental Exploration}

To evaluate the effectiveness of SolSearch, we conducted experiments to answer two main research questions: 
1) Can SolSearch improve state-of-the-art (SOTA) SAT solvers?
2) Can SolSearch be integrated into Z3 in specific tasks?

\paragraph{Experimental Setup}
We conducted our experiments using a dataset from the SAT Competition $2023$, which consists of $400$ benchmark SAT instances representing a diverse range of difficulty levels. These instances were used as the test set to assess the capabilities of SolSearch comprehensively.
The baseline solvers used in our experiments included established SAT solvers such as CaDiCaL~\cite{cadical} and Kissat-sc2024~\cite{kissat} from academic research, as well as the theorem prover Z3~\cite{Z3} from industrial practice. We use deepseek-coder as the LLM in SolSearch. Two primary metrics were used to evaluate performance: the number of solved instances within a given timeout limit and the PAR2 score~\cite{PAR-2}, which calculates the average runtime for solved instances and assigns twice the timeout limit for unsolved instances.

\paragraph{Improving SOTA SAT Solvers}
To address the first research question, we applied SolSearch to CaDiCaL and Kissat-sc2024, and analyzed its impact on their performance in SAT competition 2023. The performance results of CaDiCaL and Kissat before and after optimization are detailed in Fig.~\ref{fig:cadical_kissat}.
The results showed that SolSearch improved the performance of both solvers, solving more instances within the timeout and reducing PAR2 scores.  The optimized versions consistently outperformed the original versions over time. This validates the effectiveness of SolSearch in enhancing solver capabilities.


\paragraph{Enhancing Z3 Solver}
We integrated SolSearch with Z3 to evaluate its impact. Taking the Knights Tour problem (40 instances) proposed in SAT Competition 2024 as the case, Z3 can only solve 17 instances. 
% As shown in Fig.~\ref{fig:z3patch}, we apply our SolSearch to Z3 and add a patch to Z3.
Table \ref{tab:kngihts_tour} shows that Z3 with SolSearch solves more instances within the timeout and obtains better PAR2. 
These findings suggest that SolSearch can be used as a plug-and-play module to enhance solvers like Z3, offering a practical solution for industrial applications.
% For the second research question, we focused on integrating SolSearch with the Z3 solver to determine whether it could enhance its performance. Similar to the first set of experiments, we used the SAT Competition 2023 benchmark instances to evaluate the effectiveness of the SolSearch-augmented Z3.

% When employing the Z3 solver for SAT problems with a predefined timeout, there is a risk of encountering a timeout error if the complexity of the problem surpasses the solver's ability to resolve it within the allotted time. As shown in Fig.~\ref{fig:z3patch}, we addressed this issue by applying a patch to Z3. This patch optimizes the solving strategy specifically for the problem at hand before the solving process begins and introduces a new function aimed at improving the solving performance.

% The experimental results revealed that the integration of SolSearch significantly enhanced the performance of Z3. The number of instances solved within the timeout limit increased substantially, and the optimized versions of Z3 demonstrated improved resource utilization and reduced computation times. The PAR2 scores also showed considerable improvement, further confirming the benefits of using SolSearch as an enhancement module for Z3. These findings indicate that by optimizing the solving strategy and introducing targeted improvements prior to execution, SolSearch can effectively mitigate timeout issues and enhance Z3's ability to consistently solve SAT problems within the given constraints.

% These results suggest that SolSearch can be used as a practical plug-and-play module to enhance existing solvers like Z3, offering a robust solution for addressing the challenges of SAT solver performance in industrial applications.


% To evaluate solver performance, we adopted the scoring system used in the SAT competition: the PAR-2 score~\cite{PAR-2}. This system calculates the average runtime for solved instances and assigns twice the timeout limit for unsolved ones. Additionally, we tracked the number of instances each solver successfully solved within the set timeout limit of $1500$ seconds.

% The results of the performance of CaDiCaL2.0.0 and Kissat-sc2024, both before and after optimization, are detailed in Table~\ref{tab:experimentresults}. Furthermore, Fig.~\ref{fig:cadical} and Fig.~\ref{fig:kissat} illustrate the trends in the number of successful solutions over time for each solver. These visuals and data demonstrate that through the application of a structured curriculum learning process, the optimized solvers consistently outperform the original versions
% \begin{table}[ht]
% \centering
% \caption{Performance comparison of CaDiCaL and Kissat in SAT Competition $2023$}
% \label{tab:experimentresults}
% \begin{tabular}{@{}lcccc@{}}
% \toprule
%  & \multicolumn{2}{c}{CaDiCaL} & \multicolumn{2}{c}{Kissat} \\ \cmidrule(l){2-5} 
%  & Solved & PAR-2 Score & Solved & PAR-2 Score \\ \midrule
% Original & $233$ & $1421.67$ & $264$ & $1187.75$ \\
% After & $238$ & $1372.82$ & $265$ & $1159.01$ \\ \bottomrule
% \end{tabular}

% \end{table}
% \begin{figure}[htbp]
% \centering
% \includegraphics[width=0.8\linewidth]{Figures/cadical.pdf}  
% \caption{Number of Solved Instances of CaDiCaL Before and After Optimization at Each Timeout Limit}  
% \label{fig:cadical}
% \end{figure}

% \begin{figure}[htbp]
% \centering
% \includegraphics[width=0.8\linewidth]{Figures/kissat.pdf}  
% \caption{Number of Solved Instances of Kissat Before and After Optimization at Each Timeout Limit}  
% \label{fig:kissat}
% \end{figure}


% When employing the Z3 solver for SAT problems with a predefined timeout, there is a risk of encountering a timeout error if the complexity of the problem surpasses the solver's ability to resolve it within the allotted time. As shown in Fig.~\ref{fig:z3patch}, we address this issue by applying a patch to Z3. This patch optimizes the solving strategy specifically for the problem at hand before the solving process begins, and introduces a new function aimed at solving. By implementing this method, we are able to consistently achieve results for SAT problems within the timeout constraints.

% We have selected the dataset from the SAT Competition 2024, focused on the Knights Tour problem. This dataset encapsulates the classical graph-theoretical problem translated into a SAT problem for resolution. It contains a total of 40 problems, where each problem is encoded as a SAT instance to facilitate computational solving methods.

% \begin{figure}[htbp]
% \centering
% \includegraphics[width=0.8\linewidth]{Figures/Z3patch.pdf} 
% \caption{Loading SolSearch as a patch on Z3 can successfully solve previously timeout instances.} 
% \label{fig:z3patch}
% \end{figure}
% The experiment utilized data from SATcompetition2024 database. The results, as presented in Table \ref{tab:z3patch}, show that these SAT instances, which were originally unsolvable within the timeout limit of 100 seconds, could be successfully solved after applying the optimization patch to the Z3 solver.
% \begin{table}[ht]
%     \centering
%     \caption{Performance Improvement of SAT Instances With Patch}
%     \label{tab:z3patch}
%     \begin{tabular}{@{}lcc@{}}
%         \toprule
%         Instance Name        & \multicolumn{1}{c}{Z3} & \multicolumn{1}{c}{Z3 with Patch} \\
%         \midrule
%         mdp-28-14-sat           & \multirow{3}{*}{Timeout} & 4.52s                          \\
%         x9-10027.sat.sanitized  &                          & 47.83s                          \\
%         x9-11077.sat.sanitized  &                          & 91.41s                          \\
%         j3037\_1\_mdd\_b  &                          & 83.89s                          \\
%         rbsat-v760c43649gyes3  &                          & 74.96s                          \\
%         \bottomrule
%     \end{tabular}
% \end{table}

\begin{table}[htbp]
\centering
\caption{Comparison of Z3 and Z3 w/ SolSearch in Knights Tour. }
\label{tab:kngihts_tour}
\begin{tabular}{lcc}
\toprule
         & Z3 & Z3 w/ SolSearch  \\
\midrule
Solved Ratio in t $\leq$ 100s     & 7.5\%                  & \textbf{10.0\% }                  \\
Solved Ratio in t $\leq$ 300s     & 35.0\%                  & \textbf{42.5\%}                  \\
Solved Ratio in t $\leq$ 500s     & 42.5\%                  & \textbf{52.5\%}                 \\
\midrule
PAR-2            & 660.09              & \textbf{583.52 }             \\
\bottomrule
\end{tabular}
\end{table}
% 总结：新范式
\section{Future Plans}
% % 不同LLM表现不一，可以train SAT-LLM
% In our experiments, we explored several different LLMs and observed their performance. When utilizing GPT-3.5-turbo or GPT-4o, the feedback often involved more complex and varied new functions. Correspondingly, the readability and interpretability of these new functions were compromised. Conversely, when employing DeepSeek-Coder~\cite{dpseek}, the forms of the functions did not exhibit significant variations. Additionally, due to the complexity of C++ code, deepseek-coder tended to generate a higher rate of invalid functions. Therefore, considering the characteristics of the SAT problem and its solving requirements, training a specialized LLM is a promising endeavor.
% % 新方法的分析：可解释性、涌现能力分析等

% % 工具化，做成patch
% Through experiments on the theorem prover Z3, we have demonstrated the feasibility of optimizing tools like Z3, which are commonly used in industrial settings. This represents a significant research opportunity: applying a comprehensive set of optimization techniques as patches to theorem proving tools. Such improvements would enable these tools to solve previously intractable problems, enhance their proving capabilities, and increase their overall efficiency.

% % SAT并非唯一，其他方法如SMT等
% Certainly, within the domain of formal verification, SAT solving is not the sole approach; there are several other methods, such as Max-SAT~\cite{MaxSAT}, QBF~\cite{QBF}, and SMT~\cite{SMT}, each possessing potential for optimization. Integrating code generation based on large language models with formal verification techniques opens up numerous promising avenues for exploration.

% % 软工开发新工具使用范式，大模型辅助求解
% This research on optimizing SAT solvers through LLMs signals a new paradigm in tool utilization within the field of software engineering development: the novel approach of leveraging large language models to assist in solving software engineering problems. Embarking on this trajectory, we are set to venture into many unexplored areas and uncover innovative interpretations of traditional methods, charting a broad avenue towards innovation and transformation.

% In our experiments, we tested a variety of Large Language Models (LLMs) and analyzed their performance. When using GPT-3.5-turbo or GPT-4o, the models often generate complex and diverse new functions. However, this complexity sometimes reduces the readability and interpretability of these functions. On the other hand, when using DeepSeek-Coder~\cite{dpseek}, the generated functions showed little variation and, due to the intricacies of C++ code, this model frequently produced a higher rate of invalid outputs. Given these observations and the specific needs of SAT problem-solving, developing a specialized LLM appears to be a promising strategy.

% Through our work with the theorem prover Z3, we have demonstrated the potential for enhancing tools commonly used in industrial settings. This opens up significant research opportunities, particularly in applying a comprehensive suite of optimization techniques as patches to theorem-proving tools. These enhancements could allow such tools to tackle problems that were previously unsolvable, thereby boosting their proving capabilities and overall efficiency.

% In the broader field of formal verification, SAT solving is just one of many methods. Other approaches like Max-SAT~\cite{MaxSAT}, QBF~\cite{QBF}, and SMT~\cite{SMT} also hold potential for optimization. Integrating LLM-based code generation with formal verification techniques presents numerous exciting possibilities for further exploration.

% Our research into optimizing SAT solvers with LLMs introduces a new paradigm in tool usage within software engineering development. By leveraging large language models to address software engineering challenges, we are paving the way for exploring uncharted territories and reinterpreting traditional methods. This approach sets the stage for a wave of innovation and transformation across the industry.
Building on the promising results in LLM-driven rule extraction, we have outlined our plans to improve our paper. 

\textbf{Insight into Solver Design}: Analyzing the solvers generated by our framework offers opportunities to gain deeper insights into SAT solver design principles. Studying the novel functions and strategies identified by the LLM can inspire innovative directions for SAT solver development.

\textbf{Expanding to Other Tasks}: There is significant potential to extend this framework to tackle other complex tasks, such as Max-SAT~\cite{MaxSAT}, and QBF~\cite{QBF}. By testing our LLM-driven approach on these additional tasks, we can explore the generalizability and adaptability of the framework, opening up new avenues for formal verification and problem-solving across diverse domains.

\textbf{Evaluating LLM Impact}: A deeper analysis of how LLM selection (such as model size, training data, and specialization) influences solver performance and output quality would be valuable for optimizing SAT-solving strategies.

% \section*{Acknowledgment}

% The preferred spelling of the word ``acknowledgment'' in America is without 
% an ``e'' after the ``g''. Avoid the stilted expression ``one of us (R. B. 
% G.) thanks $\ldots$''. Instead, try ``R. B. G. thanks$\ldots$''. Put sponsor 
% acknowledgments in the unnumbered footnote on the first page.

\newpage

\bibliographystyle{IEEEtran}
\bibliography{IEEEexample}
% \begin{thebibliography}{00}
% \bibitem{b1} G. Eason, B. Noble, and I. N. Sneddon, ``On certain integrals of Lipschitz-Hankel type involving products of Bessel functions,'' Phil. Trans. Roy. Soc. London, vol. A247, pp. 529--551, April 1955.
% \bibitem{b2} J. Clerk Maxwell, A Treatise on Electricity and Magnetism, 3rd ed., vol. 2. Oxford: Clarendon, 1892, pp.68--73.
% \bibitem{b3} I. S. Jacobs and C. P. Bean, ``Fine particles, thin films and exchange anisotropy,'' in Magnetism, vol. III, G. T. Rado and H. Suhl, Eds. New York: Academic, 1963, pp. 271--350.
% \bibitem{b4} K. Elissa, ``Title of paper if known,'' unpublished.
% \bibitem{b5} R. Nicole, ``Title of paper with only first word capitalized,'' J. Name Stand. Abbrev., in press.
% \bibitem{b6} Y. Yorozu, M. Hirano, K. Oka, and Y. Tagawa, ``Electron spectroscopy studies on magneto-optical media and plastic substrate interface,'' IEEE Transl. J. Magn. Japan, vol. 2, pp. 740--741, August 1987 [Digests 9th Annual Conf. Magnetics Japan, p. 301, 1982].
% \bibitem{b7} M. Young, The Technical Writer's Handbook. Mill Valley, CA: University Science, 1989.
% \bibitem{b8} D. P. Kingma and M. Welling, ``Auto-encoding variational Bayes,'' 2013, arXiv:1312.6114. [Online]. Available: https://arxiv.org/abs/1312.6114
% \bibitem{b9} S. Liu, ``Wi-Fi Energy Detection Testbed (12MTC),'' 2023, gitHub repository. [Online]. Available: https://github.com/liustone99/Wi-Fi-Energy-Detection-Testbed-12MTC
% \bibitem{b10} ``Treatment episode data set: discharges (TEDS-D): concatenated, 2006 to 2009.'' U.S. Department of Health and Human Services, Substance Abuse and Mental Health Services Administration, Office of Applied Studies, August, 2013, DOI:10.3886/ICPSR30122.v2
% \bibitem{b11} K. Eves and J. Valasek, ``Adaptive control for singularly perturbed systems examples,'' Code Ocean, Aug. 2023. [Online]. Available: https://codeocean.com/capsule/4989235/tree
% \end{thebibliography}


\end{document}
