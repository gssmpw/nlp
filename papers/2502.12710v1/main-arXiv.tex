\documentclass{article}

\usepackage{arxiv}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[hidelinks]{hyperref}
\usepackage{url}
\usepackage{booktabs}
\usepackage{amsfonts}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{nicefrac}
\usepackage{microtype}
\usepackage{cleveref} 
\usepackage{graphicx}
\usepackage[numbers]{natbib}
\usepackage{doi}
\usepackage{enumerate}
\usepackage[nolist,nohyperlinks]{acronym}
\usepackage[linesnumbered,ruled,vlined]{algorithm2e}
\usepackage{mathtools}
\usepackage{pifont}
\usepackage{placeins}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\newcommand{\around}{\raise.17ex\hbox{$\scriptstyle\sim$}}
\def\UrlBreaks{\do\/\do-}

\usepackage{etoolbox}

\begin{acronym}
	\acro{AI}{Artificial Intelligence}
	\acro{CLI}{Command Line Interface}
	\acro{GUI}{Graphical User Interface}
	\acro{HMAC}{Hash-based Message Authentication Code}
	\acro{JVM}{Java Virtual Machine}
	\acro{LLM}{Large Language Model}
	\acro{OCR}{Optical Character Recognition}
	\acro{OTP}{One-Time-Pad}
	\acro{SNOW}{Steganographic Nature Of Whitespace}
	\acro{TREND}{Traceability Enforcement of Datatransfers}
\end{acronym}

\title{TREND: A Whitespace Replacement Information Hiding Method\thanks{This article is the extended version of~\citet{Hellmeier.2025}.}}

\date{}


\usepackage{authblk}
\renewcommand\Authfont{\bfseries}
\setlength{\affilsep}{0em}
\newbox{\orcid}\sbox{\orcid}{\includegraphics[scale=0.06]{orcid.pdf}} 
\author[1]{%
	\href{https://orcid.org/0000-0002-2095-662X}{\usebox{\orcid}\hspace{1mm}Malte~Hellmeier}%
}
\author[2]{%
	\href{https://orcid.org/0009-0005-0972-1925}{\usebox{\orcid}\hspace{1mm}Hendrik~Norkowski\thanks{Currently affiliated with Radix Security GmbH, but previously worked for Fraunhofer ISST.}}%
}
\author[1]{%
	\href{https://orcid.org/0009-0007-9582-713X}{\usebox{\orcid}\hspace{1mm}Ernst-Christoph~Schrewe}%
}
\author[1]{%
	\href{https://orcid.org/0000-0003-3248-1163}{\usebox{\orcid}\hspace{1mm}Haydar~Qarawlus}%
}
\author[3,1]{%
	\href{https://orcid.org/0000-0002-9524-4459}{\usebox{\orcid}\hspace{1mm}Falk~Howar}%
}
\affil[1]{Fraunhofer ISST, Speicherstr. 6, 44147 Dortmund, Germany}
\affil[2]{Radix Security GmbH, Universitaetsstr. 136, 44799 Bochum, Germany}
\affil[3]{TU Dortmund, Otto-Hahn-Str. 12, 44227 Dortmund, Germany}

\renewcommand{\shorttitle}{TREND}

\hypersetup{
	pdftitle={TREND: A Whitespace Replacement Information Hiding Method},
	pdfauthor={Malte~Hellmeier, Hendrik~Norkowski, Ernst-Christoph~Schrewe, Haydar~Qarawlus, Falk~Howar},
	pdfkeywords={Data Hiding, Digital Text Watermarking, Steganography, Data Sovereignty},
}

\begin{document}
	
	\maketitle
	
	\begin{abstract}
		Large Language Models (LLMs) have gained significant popularity in recent years. Differentiating between a text written by a human and a text generated by an LLM has become almost impossible. Information hiding techniques such as digital watermarking or steganography can help by embedding information inside text without being noticed. However, existing techniques, such as linguistic-based or format-based methods, change the semantics or do not work on pure, unformatted text.
		In this paper, we introduce a novel method for information hiding termed TREND, which is able to conceal any byte-encoded sequence within a cover text. The proposed method is implemented as a multi-platform library using the Kotlin programming language, accompanied by a command-line tool and a web interface provided as examples of usage. By substituting conventional whitespace characters with visually similar Unicode whitespace characters, our proposed scheme preserves the semantics of the cover text without increasing the number of characters. Furthermore, we propose a specified structure for secret messages that enables configurable compression, encryption, hashing, and error correction. 
		Our experimental benchmark comparison on a dataset of one million Wikipedia articles compares ten algorithms from literature and practice. It proves the robustness of our proposed method in various applications while remaining imperceptible to humans. We discuss the limitations of limited embedding capacity and further robustness, which guide implications for future work.
	\end{abstract}
	
	\keywords{Data Hiding \and Digital Text Watermarking \and Steganography \and Data Sovereignty}
	
	
	\section{Introduction}
	\label{sec:introduction}
	The interest in \acp{LLM} has evolved rapidly in recent years with emerging application possibilities for individuals and companies. The enduring interest in digitization leads to documents directly stored in a machine-readable format that can be processed with \acp{LLM} instead of manually processed paper printouts stored in file folders. However, it is becoming increasingly difficult to protect intellectual property, especially when data is shared: ``The proliferation of AI-generated content is one of the biggest issues facing the internet today. Recent breakthroughs in large language models have made it increasingly difficult to distinguish this influx of AI-generated content from human-generated content''~\citep[p.~325]{Christ.2024}. Therefore, keeping control over data is vital, often discussed under the umbrella term data sovereignty~\citep{Hellmeier.2023,Jarke.2019,Scherenberg.2024}. Information-hiding techniques such as digital watermarking or steganography can help to tackle those issues by hiding information in a cover document~\citep{Ahvanooey.2022,Alkawaz.2016,Majeed.2021,Petitcolas.1999,Por.2012}.
	
	Different researchers and practitioners have developed methods for hiding data in different files such as images, video, audio, or the most challenging text files~\citep{Alkawaz.2016,Bertini.2019}. Those techniques can be classified as \emph{watermarking} or fingerprinting methods focusing on robustness, storing copyright information, and securing intellectual property and \emph{steganography} methods focusing on imperceptibility, encoding information, and inconspicuousness~\citep{Alkawaz.2016,Petitcolas.1999,Por.2012,Rizzo.2016}. To hide information in text, format-based methods shift words or lines, change fonts or text colors, while linguistic-based methods replace synonyms or generate new cover texts~\citep{Majeed.2021,Zhang.2024}. Especially in the last two years, researchers have proposed and discussed possibilities for watermarking and steganography for \acp{LLM}~\citep{Christ.2024b,GoogleDeepMind.2024,Kirchenbauer.2023,Steinebach.2024,Xu.2024}. This is supported by political regulations, such as the AI Act from the European Union, stating that AI-generated texts must be detectable and mentions watermarks and fingerprints as possible solutions~\citep{EuropeanCommission.2024}.
	
	However, existing approaches show different drawbacks in real-world use cases. For example, the replacement of words in linguistic-based methods cannot be applied to legal cover texts, as small semantic changes can have serious impacts on law. Format-based methods working with line shifts or font colors do not work on pure text files without formatting. Other methods using specific characters like Unicode confusables or spaces without any width, called zero-width characters, are either visually recognizable by humans or not robust in different applications when using a simple copy and paste tampering attack~\citep{Ahvanooey.2022}.
	
	To close this gap, we extend the proposed method of the initial conference paper~\citep{Hellmeier.2025} and call it  \acs{TREND}\acused{TREND} as an acronym for \acl{TREND}. The method can hide any byte-encoded string inside a cover text by replacing all classical whitespaces with our specific set of similar-looking whitespaces based on the Unicode standard~\citep{TheUnicodeConsortium.2023}. This leads to an inconspicuous result of a cover text with a secret message inside it that works in different file formats like pure text documents due to format independence, stays robust even when copied out and pasted in other applications, and without raising any attention to users. Our design can support optional functionalities like compression, encryption, hashing, or error-correcting codes. This allows the end user to combine suitable functionalities, making it usable for watermarking and steganography use cases. To sum up, the paper makes the following concrete contributions:
	\begin{itemize}
		\item We propose \ac{TREND}, an information hiding technique to hide any byte-encoded sequence inside a cover text with a Kotlin library as a reference implementation.
		\item We introduce \ac{TREND}marks, a specific secret message structure, to enable compression, encryption, hashing, and error-correcting codes to strengthen the security and robustness further.
		\item We evaluate our proposed approach on capacity, imperceptibility, and robustness.
		\item We conduct a comparison with related work in an implemented testbed of ten algorithms.
	\end{itemize}
	
	The remaining sections of this paper are structured as follows:
	The necessary background information and our nomenclature for the understanding of this paper are introduced in Section~\ref{sec:background}. Related work and an overview of similar algorithms and concepts are presented in Section~\ref{sec:related-work}. Our proposed embedding and extraction technique is presented in Section~\ref{sec:proposed-method}, including information about our reference implementation. The results are evaluated and compared in a benchmark evaluation in Section~\ref{sec:evaluation} and discussed in Section~\ref{sec:discussion}. The paper finalizes with a conclusion in Section~\ref{sec:conclusion}, with additional information in the Appendix.
	
	\FloatBarrier
	\section{Background}
	\label{sec:background}
	
	This section introduces relevant terminologies and the nomenclature needed for the understanding of this work.
	
	\subsection{Watermarking \& Steganography}
	Distinguishing between different terminologies in the domain of \emph{cryptography} and \emph{information hiding} is crucial and has multifacetedly been discussed in literature~\citep{Ahvanooey.2018,Ahvanooey.2022,Petitcolas.1999,Rizzo.2016,Rizzo.2019}. Starting with the broadest concept: ``Information hiding is the science of concealing a secret message or watermark inside a cover media (a host file/message) for providing various security purposes such as content authentication, integrity verification, covert communication, and so on''~\citep[p.~56]{Ahvanooey.2022}. Since information hiding can further be divided into steganography and watermarking, it differs from cryptography because its root is not about transforming plain text into an encrypted cipher text~\citep{Ahvanooey.2018}. A detailed survey and classification is published by \citet{Petitcolas.1999}.
	
	The ability of a secret message to be hidden inside a cover text ``in a way that one cannot detect it''~\citep[p.~6367]{Alkawaz.2016} forms the term \emph{steganography}. Those methods can be classified into character-level, bit-level, or a mixture of both categories~\citep{Krishnan.2017}, leading to the following definition: ``Steganography embeds a secret message inside an innocent looking cover medium, stealthily, without creating any attention. The cover medium used can be a text, image, audio, video, network packets, etc.''~\citep[p.~1]{Krishnan.2017}.
	
	In contrast, \emph{digital watermarking} focuses on ``a visible or an invisible, preferably the latter, identification code that permanently is embedded in the data''~\citep[p.~230]{Jalil.2009}. Those data assets can range from images, audio, and video to the underresearched and most difficult cover medium of plain text~\citep{Bertini.2019}, often referred to as digital watermarking, text watermarking, or digital text watermarking. An overview of different definitions arisen over time is presented in Table~\ref{tab:definitions}.
	
	\begin{table}
		\centering
		\caption{Digital Watermarking Definitions}\label{tab:definitions}
		\begin{tabular}{lp{0.85\textwidth}} %
			\toprule
			\# & Definition \\
			\midrule
			I & ``A digital watermark can be described as a visible or an invisible, preferably the latter, identification code that permanently is embedded in the data.''~\citep[p.~230]{Jalil.2009} \\
			II & ``In digital watermarking, relevant information is embedded in an imperceptive way into a digital document. The embedded information is called a watermark.''~\citep[p.~19]{Qadir.2006} \\
			III & ``[D]igital watermarking technology is a typical information hiding method, which covers text, image and video.''~\citep[p.~1311]{Qi.2023} \\
			\bottomrule
		\end{tabular}
	\end{table}
	
	To bring everything together, Rizzo et al. summarize the concepts as follows: ``While cryptography algorithms make unreadable the information by applying a kind of permutation or substitution to the original content, the steganography algorithms provide techniques to hide new information into the carrier, that is a readable document. Whereas watermarking algorithms ensure the authentication and the copyright protection by applying a watermark to the digital content''~\citep[p.~97]{Rizzo.2016}.
	
	\FloatBarrier
	\subsection{Notations \& Unicode Whitespaces}
	\label{sec:notations}
	In the following, we introduce the nomenclature used in this paper. It is based on related work~\citep{Ahvanooey.2020} while all iterable elements like lists start at index one. Since the information hiding scheme is based on pure text, we define every Unicode symbol as $u$ that is included in the set $\mathcal{U} := \{u : u$ is Unicode character$\}$, containing 149\,813 characters based on Unicode standard version 15.1~\citep{TheUnicodeConsortium.2023}. Following the standard, different whitespaces $s$ exist, where the set of all Unicode space characters with a width $> 0$ are defined as $\mathcal{S} := \{s : s$ is space character $ \land\ s \in U\}$, containing 17 elements. A character like the zero-width space (U+200B) ``although called a ``space'' in its name, does not actually have any width or visible glyph in display [\dots] and is treated as a format control character, rather than as a space character'' \citep[p.~267]{TheUnicodeConsortium.2023} and therefore not an element of $\mathcal{S}$. We define the classical and most used space character U+0020 as $\delta$ with $\delta \in \mathcal{S}$. We evaluated every $s$ to define our own subset of whitespaces as alphabet $\mathcal{A}_+ := \{a : a \in S \land a \in U \land a$ meets criteria$\}$, whereas the criteria are \emph{non-noticeability} for humans and \emph{robustness} in different applications and file formats.
	
	\begin{table*}
		\centering
		\caption{Whitespace Evaluation based on \citet{Korpela.2002}}\label{tab:whitespace-evaluation}
		\begin{tabular}{llcccccc}
			\toprule
			Name &  Code & Visibility & .txt & .docx & .pdf & Mail & Teams\\
			\midrule
			Space                               & U+0020 & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51}\\
			No-break Space                      & U+00A0 & \ding{51} & \ding{51} & \ding{55} & \ding{55} & \ding{55} & \ding{55}\\
			Ogham Space Mark                    & U+1680 & \ding{55} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51}\\
			En Quad                             & U+2000 & \ding{55} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			Em Quad                             & U+2001 & \ding{55} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			En Space                            & U+2002 & \ding{55} & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{51}\\
			Em Space                            & U+2003 & \ding{55} & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{51}\\
			\textbf{Three-per-em Space}         & U+2004 & \ding{51} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			Four-per-em Space                   & U+2005 & \ding{51} & \ding{51} & \ding{55} & \ding{55} & \ding{55} & \ding{51}\\
			Six-per-em Space                    & U+2006 & (\ding{55}) & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			Figure Space                        & U+2007 & \ding{55} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			\textbf{Punctuation Space}          & U+2008 & \ding{51} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			\textbf{Thin Space}                 & U+2009 & \ding{51} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			Hair Space                          & U+200A & (\ding{55}) & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			\textbf{Narrow No-break Space}      & U+202F & \ding{51} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			\textbf{Medium Mathematical Space}  & U+205F & \ding{51} & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51}\\
			Ideographic Space                   & U+3000 & \ding{55} & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{51}\\
			\bottomrule
		\end{tabular}
	\end{table*}
	
	For the \emph{non-noticeability} or visibility criteria, we compared the width of the whitespace characters based on \citet{Korpela.2002} with the commonly used space $\delta$ ($\approx\frac{1}{4}$\,em). If abnormalities exist causing unusual space, we classify it as different visibility compared to $\delta$, depicted as ``\ding{55}'' in Table~\ref{tab:whitespace-evaluation}. When the difference is not noticeable, a ``\ding{51}'' is shown ($\approx\frac{1}{3}$ to $\frac{1}{5}$\,em) while a ``(\ding{55})'' indicates that the difference could be noticeable by human eyes (like $\frac{1}{2}$ or $\frac{1}{6}$\,em).
	
	For the application and file type \emph{robustness} criteria, we tested the different whitespaces in \emph{.txt} text files, Word's \emph{.docx} format, the exported version as \emph{.pdf} and in an E-Mail and Microsoft Teams Chat. All tests are executed on Windows, Linux (Ubuntu), and macOS for operation system independence. The selection of file types and programs was deliberate, as these are considered industry standards for office and collaboration tools in many branches, except phone calls and SMS~\citep{DataReportal.2023}.
	
	
	As a result, only the Three-per-em Space (U+2004), the Punctuation Space (U+2008), the Thin Space (U+2009), the Narrow-no-break Space (U+202F) and the Medium Mathematical Space (U+205F) are not noticed by humans and are robust in most of our tested applications and file formats and therefore form the whitespace homoglyph alphabet $\mathcal{A}_+$, shown by the bold-formatted whitespaces in Table~\ref{tab:whitespace-evaluation}. Thus, we can summarize that $\mathcal{A}_+ \subset \mathcal{S} \subset \mathcal{U}$. Our proposed TREND technique introduced in Section~\ref{sec:proposed-method} uses four of the five elements of $\mathcal{A}_+$ to encode the secret message because one element is used as a separator character $\phi \in A_+$. We define the alphabet without separator character as $\mathcal{A}_-$, where $\mathcal{A}_+ = \mathcal{A}_- \cup \{ \phi \} $ and $\phi \notin \mathcal{A}_-$. Depending on the final application, the modular design of our proposed technique allows the usage of other characters in $\mathcal{A}_+$ if a different set is needed due to framework conditions or specific use case criteria. A summarized overview of the nomenclature is shown in Table~\ref{tab:notations}.
	
	\begin{table}[htb]
		\centering
		\caption{Nomenclature Overview following \citet{Ahvanooey.2020}}
		\label{tab:notations}
		\begin{tabular}{ll}
			\toprule
			Symbol & Meaning \\
			\midrule
			$CT$ & Cover Text\\
			$SM$ & Secret Message Text\\
			$SM_{bytes}$ & Byte representation of $SM$ as sequence of digits\\
			$SM_H$ & Hidden whitespace representation of $SM_{bytes}$\\
			$CT_{SM}$ & Cover Text with a hidden secret message\\
			$\mathcal{U}$ & Set of all Unicode characters\\
			$\mathcal{S}$ & Set of all 17 Unicode space characters\\
			$\delta$ & Classical Unicode whitespace (U+0020)\\
			$\phi$ & Separator whitespace character\\
			$\mathcal{A}_+$ & Whitespace alphabet with $\phi$\\
			$\mathcal{A}_-$ & Whitespace alphabet without $\phi$\\
			$\theta$ & Option parameter for encryption, compression, etc.\\
			$Emb(CT, SM_{bytes}, \theta)$ & Embedding algorithm\\
			$Ext(CT_{SM})$ & Extracting algorithm\\
			\bottomrule
		\end{tabular}
	\end{table}
	
	\FloatBarrier
	\section{Related Work}
	\label{sec:related-work}
	Over time, different information hiding methods and implementations for watermarking and steganography have been published. Due to the increasing number of diverse method classes, cover types, and areas of application, different literature reviews and surveys exist to organize the cluttered research and application landscape. A more detailed discussion on selected methods is provided in section \ref{sec:related-methods}.
	
	\citet{Bender.1996} present one of the first comprehensive overviews of data hiding methods for image, audio, and text files. Later on, \citet{Petitcolas.1999} made a survey on information hiding techniques, focusing on steganography, watermarking, and fingerprinting techniques, including information about possible attacks and a basic theory for overall principles. A more specialized overview with solutions focusing on text steganography is provided by \citet{Ahvanooey.2019}, \citet{Krishnan.2017}, and \citet{Majeed.2021}. Current challenges are discussed by \citet{Ahvanooey.2022} and \citet{Tyagi.2023}, while the latter provide concrete application possibilities.
	
	Besides the reviews, researchers started analyzing and comparing existing methods to identify their strengths and weaknesses. \citet{Ahvanooey.2018b} compare watermarking and steganography methods by differentiating their embedding technique and analyzing them based on the evaluation criteria of imperceptibility, embedding capacity, robustness, security, and computational cost~\citep{Ahvanooey.2018b}. One of the latest evaluations on text steganography is published by \citet{Knochel.2024} where the authors compared the capacity, imperceptibility, robustness, and complexity with a specialized focus on Malware.
	
	\subsection{Related Methods}
	\label{sec:related-methods}
	In order to integrate our proposed TREND method into the research landscape, we present the most relevant text watermarking and steganography methods in the following. In connection with the \ac{LLM} problem domain initially set out, \citet{Kirchenbauer.2023} and \citet{Christ.2024b} present a token-based watermarking scheme, while the latter focus on undetectability, completeness, and soundness. Such ideas are integrated into SynthID, the watermarking engine for Google's Gemini \ac{LLM} \citep{GoogleDeepMind.2024}. \citet{Steinebach.2024} generates a cover text based on sets of letters. Those methods are classified in the domain of lingustic methods since they make use of the \ac{LLM} text generation. Nevertheless, those linguistic methods are problematic for cover texts where semantics are important. Thus, we focus on format-based methods that use insertion or substitution-based embedding techniques~\citep{Knochel.2024}. Other types of format-based methods, as well as linguistic or random and statistical generation methods~\citep{Knochel.2024,Majeed.2021} are not considered further since they either do not work on pure text documents due to missing format options like color or fonts or because they change the semantic or structure of the cover text. We implemented all presented methods for our benchmark evaluation in Section~\ref{sec:evaluation}. A summarized overview is depicted in Table~\ref{tab:related-methods}.
	
	\paragraph{SNOW.} One of the first whitespace steganography methods for ASCII texts is the \ac{SNOW} by \citet{Kwan.2013}. While the first release goes back to the 20th century, the last update with a change to the open source license Apache 2.0 was made in 2013~\citep{Kwan.2013}. It includes a Java and Windows DOS version and a C-implementation last updated in 2016~\citep{Kwan.2016}. The embedding process encodes the secret message into tab and space characters and appends it at the end of the cover text, starting with a tab character under the consideration of a pre-defined line length~\citep{Kwan.2013}. Upstream compression and encryption can be optionally enabled before the encoding process.
	
	\paragraph{UniSpaCh.} A very well-known algorithm in the field of information hiding for text documents is UniSpaCh, proposed by \citet{Por.2012}. It is an extended version of WhiteSteg, which replaces one single space character between words and paragraphs with either one or two whitespaces to encode a 0 or 1~\citep{Por.2008}. UniSpaCh uses two different types to embed the secret message in the text. For spaces between words and sentences, regular whitespaces either remain as they are or are extended by adding an additional Thin, Six-Per-Em, or Hair space to encode two bits per embedding location~\citep{Por.2012}. For end-of-line and inter-paragraph spacings, the remaining space is filled with a combination of Hair, Six-Per-Em, Punctuation, and Thin spaces to encode two bits per character~\citep{Por.2012}.
	
	\paragraph{AITSteg.} \citet{Ahvanooey.2018} propose a text steganography technique for SMS or social media communication. The embedding method transforms the secret message into zero-width characters with the help of a GÃ¶del function and by using the sending/receiving time and the length of the secret message to add it before the cover text~\citep{Ahvanooey.2018}.
	
	\paragraph{Shiu et al.} The data hiding method proposed by \citet{Shiu.2018} focus on communication over messengers of social media networks. Due to the small width of a messaging window, the method is based on a fixed line length and can hide three bits per line of a cover text~\citep{Shiu.2018}. After encoding a secret message into a bit stream based on the ASCII mapping, it embeds the first bit by adding a whitespace at the end of a line, changing the length of the line to embed the second bit, and adding a whitespace between two words to embed the third bit~\citep{Shiu.2018}.
	
	\paragraph{Rizzo et al.} A text watermarking technique based on specific replacement of Unicode characters with their confusables, also known as homoglyphs, was initially proposed in \citet{Rizzo.2016} and extended to a fine-grain watermarking approach in \citet{Rizzo.2019}. Based on their latest approach, it generates a watermark by using a keyed hash function with a secret message as a watermark and a secret password~\citep{Rizzo.2019}. Aftward, the watermark is embedded in the cover text by replacing specific characters with their confusables or leaving them as they are to embed one bit each and replacing whitespaces with a set of specific whitespaces to embed three bits per space~\citep{Rizzo.2019}.
	
	\paragraph{StegCloak.} The open-source implementation StegCloak published by \citet{KuroLabs.2020} as described in \citet{Mohanasundar.2020} is a JavaScript steganography tool that is able to hide a secret message inside a cover text with optional password encryption and \ac{HMAC}. In the embedding process, the secret message is compressed, optionally encrypted, and encoded in a set of zero-width characters to be inserted in one location after a classical whitespace of the cover text~\citep{Mohanasundar.2020}.
	
	\paragraph{Lookalikes.} Another implementation is the Unicode Lookalikes algorithm by \citet{Thompson.2021} as part of the Python package pyUnicodeSteganography. Similar to \citet{Rizzo.2019}, the method replaces specific characters with their confusables to encode a secret message inside the cover text~\citep{Thompson.2021}.
	
	\paragraph{CovertSYS.} \citet{Ahvanooey.2022b} presents a multilingual steganography method focusing on short messages on social networks. Like the previous approach in \citet{Ahvanooey.2018}, four zero-width characters and a timestamp are used to encode the secret message. Further, a password-based approach with an \ac{OTP} and XOR operation are used to transform the secret message into an encrypted bit stream that is appended at the end of the cover text~\citep{Ahvanooey.2022b}.
	
	\paragraph{Shazzad-Ur-Rahmen et al.} The data hiding approach of \citet{ShazzadUrRahman.2021} is able to embed five bits per embeddable location, while their updated version of \citet{ShazzadUrRahman.2023} can embed six bits per embeddable location. The main idea of the latest embedding procedure starts by encrypting the secret message using AES and converting the resulting binary stream into blocks of 6 bits~\citep{ShazzadUrRahman.2023}. With the help of two lists, specific Unicode characters are replaced with their confusables, and whitespaces are replaced with a particular combination of multiple smaller whitespaces to embed the secret message in the cover text~\citep{ShazzadUrRahman.2023}.
	
	\begin{table}[!htb]
		\centering
		\caption{Overview of Related Methods}
		\label{tab:related-methods}
		\begin{tabular}{p{3.5cm} p{1.8cm} p{2.5cm} p{7cm}}
			\toprule
			Name & Release & Type & Techniques \\
			\midrule
			SNOW \citep{Kwan.2013,Kwan.2016} & Before 1998 & Docu \& Im\-ple\-ment\-ation & Hides data at the end of the text by appending additional tabs and whitespaces.\\
			UniSpaCh \citep{Por.2012} & 2012 & Paper & Hides data by adding small whitespace characters between words and sentences and by filling up lines and inter-paragraph spacings.\\
			AITSteg \citep{Ahvanooey.2018} & 2018 & Paper & Hides data at the beginning of the cover text by using symmetric key encoding and a transformation into zero-width characters.\\
			\citet{Shiu.2018} & 2018 & Paper & Hides data line-wise by either adding a whitespace between words or at the end of line or by changing the line length.\\
			\citet{Rizzo.2016,Rizzo.2019} & 2016/2019 & Paper & Hides data by replacing Unicode characters and whitespaces with their confusables.\\
			StegCloak \citep{KuroLabs.2020,Mohanasundar.2020} & 2020 & Blog post \& Im\-ple\-ment\-ation & Hides data using zero-width characters in one spacing location in the cover text.\\
			Lookalikes \citep{Thompson.2021} & 2021 & Im\-ple\-ment\-ation & Hides data by replacing specific Unicode characters with their confusables.\\
			CovertSYS \citep{Ahvanooey.2022b} & 2022 & Paper & Hides data using zero-width characters at the end of the cover text by using the current date and time and a \ac{OTP}.\\
			\citet{ShazzadUrRahman.2021,ShazzadUrRahman.2023} & 2021/2023 & Paper & Hides data by replacing conufsables and whitespaces with a specific combination of small whitespaces.\\
			\ac{TREND} \citep{FraunhoferISST.2025} & 2025 & Paper \& Im\-ple\-ment\-ation & Hides data by replacing whitespaces with a specific set of robust similar-looking whitespaces.\\
			\bottomrule
		\end{tabular}
	\end{table}
	
	\FloatBarrier
	\section{Proposed Method}
	\label{sec:proposed-method}
	In this section, we present \ac{TREND}, our information hiding technique for pure text documents. Since existing methods are either not robust in different applications, increase the number of characters, or are recognizable by humans, they are unsuitable for the \ac{LLM} use case described in the introduction. Therefore, this section presents the embedding and extracting method in Algorithm~\ref{alg:emb} and Algorithm~\ref{alg:ext} based on our nomenclature introduced in Section~\ref{sec:notations}. It further includes a concrete example of a Lorem ipsum dummy text and information about our implemented prototypes.
	
	\subsection{Embedding}
	\label{sec:embedding}
	The proposed embedding method can hide any byte-encoded sequence in a Unicode-encoded cover text $CT$. The examples in this paper are based on a secret message $SM$ in text form, where every character is transformed into its UTF-8 byte representation $SM_{bytes}$.
	
	\begin{algorithm}[!htb]
		\small
		\caption{Embedding Algorithm $Emb(CT, SM_{bytes}, \theta)$}
		\label{alg:emb}
		\KwData{$CT \gets$ Cover text $CT := \{c_1, c_2, \dots, c_n\}$, $\forall c \in \mathcal{U}$}
		\KwData{$SM_{bytes} \gets$ Secret message $SM_{bytes} := \{q_1, q_2, \dots, q_n\}$, $\forall q \in \{0, 1, \dots, 255\}$}
		\KwResult{$CT_{SM} \gets$ Cover text with hidden secret message}
		
		\tcp{Insert tag}
		$SM_{bytes}, SM_H \gets applyTag(SM_{bytes}, \theta)$
		
		\tcp{Encode secret message}
		$d \gets \left\lceil\frac{\log_2 2^8}{\log_2 |\mathcal{A}_-|}\right\rceil$\;
		\ForEach{$q \in SM_{bytes}$}{
			\For{$i \gets 1$ \KwTo $d$}{
				$r \gets q \mod |\mathcal{A}_-|$\;
				$q \gets \bigl\lfloor\frac{q}{|\mathcal{A}_-|}\bigr\rfloor$\;
				$SM_H \gets SM_H + a_{r+1}$ \tcp*{$a_{r+1} \in \mathcal{A}_-$} %
			}
		}
		
		\tcp{Insert secret message}
		$i \gets 1$\;
		\ForEach{$c \in CT$}{
			\If{$c = \delta $}{
				\If{$i <= |SM_H|$}{
					$w_{H_i} \gets SM_{H_i}$ \tcp*{$w_{H_i} \in \mathcal{A}_-$}
					$CT_{HM} \gets CT_{HM} + w_{H_i}$\;
					$i \gets i + 1$\;
				}
				\Else{
					$CT_{HM} \gets CT_{HM} + \phi$\;
					$i \gets 1$\;
				}
			}
			\Else{
				$CT_{HM} \gets CT_{HM} + c$\; %
			}
		}
		\Return{$CT_{HM}$}\;
	\end{algorithm}
	
	The embedding function $Emb(CT, SM_{bytes}, \theta)$ begins by analyzing the configuration parameter $\theta$. It specifies the type of the secret message, which we call a \emph{TRENDmark}. It offers optional functionalities that can be enabled in any combination by the end user, depending on the use case. This comprises functions like encryption, compression, hashing, or error-correcting codes. Depending on the end-user choice, $\theta$ defines the type of TRENDmark to calculate the \emph{tag}. The tag has a fixed length of one byte and is returned by the $applyTag$ method with the updated secret message, depending on the user's choice. Each bit in the TRENDmark tag indicates whether an option such as compression is enabled ($1$) or not ($0$). Thus, the TRENDmark tag is firmly used with the secret message because it describes their format, similar to tags or headers in network packets~\citep{Deering.2017}. Figure~\ref{fig:trendmark-structure} provides an overview of the TRENDmark structure and the definition of every bit in the tag with their allocation.
	
	\begin{figure}[!htb]
		\centering
		\includegraphics[width=0.6\textwidth]{figure-1_trendmark-structure.pdf}
		\caption{TRENDmark Structure} \label{fig:trendmark-structure}
	\end{figure}
	
	A TRENDmark starts with the separator character $\phi$, followed by the tag with a fixed length of one byte, followed by an optional prefix filled with the content depending on the tag, followed by the secret message itself.
	
	Next, the encoding process starts to transform the secret message with the TRENDmark tag and optional prefixes $SM_{bytes}$ into a sequence of whitespaces $SM_H$ based on our homoglyph alphabet $\mathcal{A}_-$. Since $|\mathcal{A}_-| = 4$, where $|\cdot|$ denotes the cardinality, every byte of the secret message is represented by four elements of $\mathcal{A}_-$ because:
	\begin{equation}
		\ceil*{\frac{\log_2 2^8}{\log_2 |\mathcal{A}_-|}} = 4
	\end{equation}
	To fully include $SM_H$ in a cover text $CT$, the number of normal space characters $\delta$ in $CT$ must be at least equal to the number of elements of the hidden secret message $SM_H$:
	\begin{equation}
		|\{x \in CT : x = \delta\}| \geq |SM_H|
	\end{equation}
	The final creation of the cover text with the hidden secret message $CT_{SM}$ is made by replacing all $\delta$ successively with the elements of $SM_H$. If $CT$ has more $\delta$ than $|SM_H|$, the next $\delta$ is replaced with the separator character $\phi$, and the insertion process starts again until all $\delta$ are replaced to include the secret message multiple times. Since the algorithm replaces all $\delta$ to achieve better robustness on modification attacks on specific parts, the resulting cover text with the embedded secret message does not contain regular space characters:
	\begin{equation}
		\forall x \in CT_{SM} : x \in \mathcal{U} \land x \neq \delta
	\end{equation}
	The entire embedding algorithm $Emb(CT, SM_{bytes}, \theta) = CT_{SM}$ is shown in Algorithm~\ref{alg:emb}.
	
	\begin{figure}[!htb]
		\centering
		\includegraphics[width=0.6\textwidth]{figure-2_embedding-example.pdf}
		\caption{Embedding Example of a RawTrendmark}
		\label{fig:embedding-example}
	\end{figure}
	
	An example of the proposed embedding algorithm is shown in Figure~\ref{fig:embedding-example}. The secret message $SM = $ ``John'' should be hidden inside the cover text $CT =$ ``Lorem ipsum [\dots]''. Every character of $SM$ is encoded into its byte representation $SM_{bytes}$ and transformed into the whitespace alphabet. In this case, the first letter "J" of the secret message is represented by the UTF-8 Hexadecimal value "4A" (U+004A), which equals the decimal value 74. Afterward, each value of $SM_{bytes}$ is encoded into $SM_H$ by transforming it into the alphabet $\mathcal{A}_-$ with a loop-based modulo operation as described in Algorithm~\ref{alg:emb}. It uses the length of the alphabet without separator characters as the divisor $d = |\mathcal{A}_-| = 4$ as exemplified in Figure~\ref{fig:transformation-example}. The remainder of each operation indicates the index of the whitespace in $\mathcal{A}_-$ to build the complete sequence of whitespaces $SM_H$ as a representation of the secret message $SM$. Next, every whitespace $\delta$ of $CT$ is replaced with the corresponding space in $SM_H$. Since $CT$ has more whitespaces than needed, the separator char $\phi$ is added, shown by the black U+2004 in Figure~\ref{fig:embedding-example}. Since the insertion process starts again, the algorithm inserts the identification tag and the first character ``J'' of the secret message a second time and stops after all whitespaces are replaced.
	
	\begin{figure}[!htb]
		\centering
		\includegraphics[width=0.4\textwidth]{figure-3_secret-message-transformation.pdf}
		\caption{Example of Transforming a Secret Message into the Whitespace Alphabet}
		\label{fig:transformation-example}
	\end{figure}
	
	\subsection{Extracting}
	\label{sec:extracting}
	The extraction method $Ext(CT_{SM}) = SM_{bytes}$ is split into three parts for extraction, tag analysis, and decoding. The first part starts by iterating over all characters of the input cover text including the secret message $CT_{SM}$ until it finds the first occurrence of $\phi$ as the separator character. Through the filtering of $\mathcal{A}_+$, it allows to extract the full TRENDmark with the tag, an optional prefix, and a hidden secret message $SM_H$ as specified in Figure~\ref{fig:trendmark-structure}.
	
	The second part analyzes and evaluates the whole TRENDmark based on the tag by calling $analyzeTag()$. If options like hashing are enabled, it checks and verifies the hash of $SM_H$ and returns an error if problems occur. It can also decompress the message, check the size, or apply the CRC32 prefix.
	
	The third part decodes the hidden secret message $SM_H$ into its bit representation $SM_{bytes}$. The step size for the decoding part depends on the length of the alphabet without separator character and is defined as
	\begin{equation}
		d := \ceil*{\frac{\log_2 2^8}{\log_2 |\mathcal{A}_-|}}
	\end{equation}
	with $d = 4$ for our alphabet because each byte is represented by four whitespaces of $\mathcal{A}_-$. The cascading modulo operation from Algorithm~\ref{alg:emb} can be transformed back into its byte representation $b$. All $b$ form the secret message representation $SM_{bytes}$, which in turn can be converted by the UTF-8 representation into the decoded secret message text $SM$. The overall extraction process is summarized in Algorithm~\ref{alg:ext}.
	
	\begin{algorithm}[!htb]
		\small
		\caption{Watermark Extraction Algorithm $Ext(CT_HM)$}
		\label{alg:ext}
		\KwData{$CT_{SM} \gets$ Cover text with a hidden secret message}
		\KwResult{$SM_{bytes} \gets$ Extracted secret message bits \emph{or} $error$}
		
		\tcp{Extract secret message}
		\ForEach{$c \in CT_{SM}$}{
			\If{$c \in \mathcal{A}_+$}{
				\If{$c = \phi$}{
					\textbf{break}
				}
				\Else{
					$SM_H \gets SM_H + c$\;
				}
			}
		}
		
		\tcp{Analyze tag and prefix}
		$SM_H, error = analyzeTag(SM_H)$\;
		\If{error} {
			\Return{error}\;
		}
		
		\tcp{Decode watermark}
		$d \gets \left\lceil\frac{\log_2 2^8}{\log_2 |\mathcal{A}_-|}\right\rceil$\;
		\For{$i \gets 0$ \KwTo $|SM_{H}|$ \text{step} $d$}{
			\For{$y \gets 0$ \KwTo $d-1$}{
				$a_k \gets SM_{H_{i+y+1}}$ \tcp*{$a_k \in \mathcal{A}_{-}$}
				$b \gets b + (k-1) \cdot d^y$ \tcp*{$k \in [1,\dots,d]$}
			}
			$SM_{bytes} \gets SM_{bytes} + b $\;
		}
		\Return{$SM_{bytes}$}\;
	\end{algorithm}
	
	\subsection{Implementation}
	Besides the theoretical presentation, both watermark embedding and extraction methods were technically implemented as a generic library in the Kotlin programming language to test and validate our solution. Kotlin was chosen since it is interoperable with the widely used Java programming language while supporting multiplatform targets. Thus, our implementation of the proposed solution can be used in applications supporting the \ac{JVM} and in JavaScript solutions due to both build targets.
	
	To test the library, we developed a \ac{CLI} tool for the \ac{JVM} that can embed and extract a byte-encoded string into another string or text-based document, like a \emph{.txt} file. Besides this, a webinterface is implemented as a second usage example for the JavaScript build target. This frontend acts as a graphical user interface and is likewise able to embed and extract watermarks in cover texts.
	
	The source code of the watermarking library with its two usage examples of a \ac{CLI} tool and a webinterface is made publicly available \citep{FraunhoferISST.2025} to ensure full transparency and applicability.
	
	\FloatBarrier
	\section{Evaluation and Experimental Results}
	\label{sec:evaluation}
	To analyze and evaluate our proposed \ac{TREND} technique, this section compares it with state-of-the-art methods for text watermarking and steganography. We created a testbed and implemented all methods presented in Section~\ref{sec:related-methods} in the Java programming language based on their descriptions, reference implementations, and examples. To ensure a uniform basis and comparability without unnecessary overhead, we focus on the embedding and extraction methods only. Thus, optional functionalities like encryption or compression are excluded since they can be applied upstream to all algorithms and would jeopardize the abstraction of the comparison. Figure~\ref{fig:evaluation-gui} shows our evaluation \ac{GUI}, consisting of embedding a secret message inside a cover text on the left side, a dropdown selector of the method in the middle with some additional options, and an extraction part on the right side. For the comparison, we applied each algorithm in two execution runs on the same considerably large dataset of one million random English Wikipedia articles as cover texts. The first run tries to hide a short four-character secret message inside the dataset, while the second run tries to hide a long 455-character secret message inside the dataset. The different lengths and forms of the Wikipedia cover texts, as well as two different lengths of secret messages, ensure an appreciable broad diversification. More details about the data and evaluation process for transparency and reproducibility are provided in the Appendix.
	
	\begin{figure}[htb]
		\centering
		\includegraphics[width=0.6\textwidth]{figure-4_evaluation-gui.png}
		\caption{Evaluation \ac{GUI} for Embedding and Extracting}
		\label{fig:evaluation-gui}
	\end{figure}
	
	Different empirical research methods exist in the domain of software engineering, like simulations, benchmarks, case studies, or controlled experiments~\citep{Hasselbring.2021}. We use benchmarking in this evaluation since it is a ``[s]tandard tool for the competitive evaluation and comparison of competing systems or components according to specific characteristics''~\citep[p.~333]{Kistowski.2015}. Since different types of benchmarks exist, we focus on \emph{specification-based benchmarks} since they concentrate on a business problem and require development work before running the benchmark \citep{Kistowski.2015,Kounev.2020}.
	
	We build our benchmark on criteria from existing comparisons and evaluations because benchmarks should be developed by the community instead of a single researcher \citep{Hasselbring.2021, Sim.2003}. This leads to the following set of criteria, also used by \citet{Ahvanooey.2018b}, \citet{Majeed.2021}, and \citet{Knochel.2024}:
	\begin{itemize}
		\item \textbf{Capacity:} Describes the embedding amount as a relationship between the length of the secret message and the cover text.
		\item \textbf{Imperceptibility:} Also known as invisibility, analyzes the visual and perceived difference between a text with a secret message and one without a secret message.
		\item \textbf{Robustness:} A broad term mainly focuses on how resilient the secret message stays inside the cover text in different environments or when carrying out specific attacks.
	\end{itemize}
	
	In the following, each criterion is introduced, the measurable comparative benchmark values are described, and the results of the conducted comparisons on the one million Wikipedia articles are presented.
	
	\FloatBarrier
	\subsection{Capacity}
	\label{sec:capacity}
	The embedding capacity provides information about the relationship between the length of the cover text and the length of the secret message. Information hiding techniques often strive for high embedding capacities, usually forming an opposite relationship with the imperceptibility criteria, since imperceptibility decreases if the embedding capacity increases~\citep{Yang.2019}. We distinguish between two types of algorithms:
	\begin{enumerate}[(i)]
		\item \textbf{Bounded capacity algorithms:} Have limits in the embedding capacity, depending on the length, structure, and used characters in the cover text and secret message, primarily due to specific replacements or insertions.\\
		\textbf{Algorithms:} Shiu et al., TREND, Rizzo et al., Lookalikes, Shazzad-Ur-Rahman et al., UniSpaCh.
		\item \textbf{Boundless capacity algorithms:} Generally have no limit in embedding capacity, primarily due to the usage of (zero-width) characters. Embedding capacity restrictions only apply if the text length is specified, like SMS or X posts (formally called Tweets from Twitter).\\
		\textbf{Algorithms:} AITSteg, CovertSYS, StegCloak, SNOW.
	\end{enumerate}
	
	In our testbed, we analyze all bounded capacity algorithms by executing each on the dataset of one million articles. It starts by hiding a one-byte-long secret message inside the cover and permanently increases the length of the secret message until an error occurs. This results in the maximum number of embeddable bytes since the respective algorithm is not able to hide a longer secret message. This measurement can not be executed for the boundless capacity algorithms since the test would hang in an endless loop, leading to a theoretical maximum cover text length of infinity.
	
	For the calculations, we base or benchmark on related work: ``The embedding capacity is computed as the average ratio between the number of embedded bits and the number of characters in each document''~\citep[p.~13]{Rizzo.2019}. Our dataset has an average cover text size of \around2514 characters. The resulting capacity ratios are depicted in Figure~\ref{fig:capacity}.
	
	\begin{figure}[htb]
		\centering
		\includegraphics[width=0.6\textwidth]{figure-5_capacity.pdf}
		\caption{Maximum Capacity Evaluation Results (higher is better)} \label{fig:capacity}
	\end{figure}
	
	We depict all unbounded capacity algorithms with a value of $1.0$ to illustrate the unprescribed limit. Comparing the others, Shiu has the lowest embedding capacity with $\frac{26}{2514} \approx 0.01\ bits/character$ while UniSpaCh has the highest of $\frac{1983}{2514} \approx 0.79\ bits/character$. The other four bounded capacity algorithms are comparatively close to each other and have an embedding capacity of around and below 0.1 bits/character. Our proposed TREND method has a remarkable good capacity of $\frac{93}{2514} \approx 0.04\ bits/character$, taking the results of the other benchmarks into account, described in the following.
	
	\FloatBarrier
	\subsection{Imperceptibility}
	\label{sec:imperceptibility}
	Imperceptibility or invisibility is the ability of a secret message to be concealed in a cover document without causing any abnormalities or getting noticed~\citep{Ahvanooey.2018}. Therefore, this benchmark is more relevant for steganography use cases than watermarking~\citep{Por.2012, Rizzo.2016}. It is essential to distinguish between the imperceptibility of humans when identifying something unusual and the imperceptibility of machines when a computer system can identify a difference, for example, by using statistical metrics. Due to the varying perceptions of humans, this benchmark ``is the most subjective of all the metrics''~\citep[p.~121]{Knochel.2024}. In the following, we use four different metrics to measure the imperceptibility:
	\begin{enumerate}[(i)]
		\item Comparing the Jaro-Winkler Similarity
		\item Comparing the number of characters
		\item Comparing the file size
		\item Checking caret navigation
	\end{enumerate}
	
	\paragraph{(i) Jaro-Winkler Similarity.} One standard numerical measurement to compare the similarity between two character sequences is the \emph{Jaro-Winkler similarity}, also known under the wrong name Jaro-Winkler distance~\citep{Keil.2019}. It is often used in related work in the domain of information hiding for evaluation (see \citep{Ahvanooey.2019,Ahvanooey.2020,Ahvanooey.2022b,Baawi.2019,Majeed.2022,Majeed.2024}). The benchmark is based on the Jaro string comparator $\Phi$, where $1$ indicates that two strings $s_1$ and $s_2$ are identical and $0$ indicates that both strings have no common characters.
	\begin{equation}\label{eq:jaro}
		\Phi(s_1,s_2) = 
		\begin{cases} 
			1 & : s_1 = s_2 \\
			\frac{1}{3} \left( \frac{c}{|s_1|} + \frac{c}{|s_2|} + \frac{c - \tau}{c} \right) & \text{: } m >0 \\
			0 & : \text{otherwise}
		\end{cases}
	\end{equation}
	Equation~\ref{eq:jaro} from \citet{Winkler.1990} uses $|s_1|$ and $|s_2|$ as the length of each strings, $c$ as the number of matching characters, $\tau$ as the number of transpositions based on the characters and $m$ for all matching characters \citep{Keil.2019,Winkler.1990}. The newer Jaro-Winkler similarity $\Phi_n$ shown in Equation~\ref{eq:jaro-winkler} based on \citet{Winkler.1990} build upon the Jaro similarity.
	\begin{equation}\label{eq:jaro-winkler}
		\Phi_n(s_1,s_2) = \Phi(s_1,s_2) + i \cdot 0.1 \cdot (1 - \Phi(s_1,s_2))
	\end{equation}
	It adds the scaling factor $0.1$ and a prefix length $i$ to compare the first characters of a string~\citep{Winkler.1990}.
	
	In our testbed, we use the Java implementation of an Apache Commons package\footnote{\url{https://commons.apache.org/proper/commons-text/apidocs/org/apache/commons/text/similarity/JaroWinklerSimilarity.html}} in version 1.12.0 for calculating the Jaro-Winkler similarity of a plain cover text and a cover text with an integrated secret message. Like \citet{Knochel.2024}, Figure~\ref{fig:jaro-winkler} shows the average Jaro-Winkler similarity for each algorithm, separated by the two execution runs for a short (four-character) and long (455-character) secret message. For short secret messages, UniSpaCh shows the best results with a Jaro-Winkler Similarity of $\Phi_n = 0.996$, while Rizzo et al. has the worst result with $\Phi_n = 0.729$. Our proposed TREND technique has the best similarity of $\Phi_n = 0.931$ for longer messages, while AITSteg has the lowest similarity value of $\Phi_n = 0.362$. It is noteworthy that the boundless algorithms without capacity restrictions have a comparatively high difference in $\Phi_n$ between short and long secret messages.
	
	\begin{figure}[htb]
		\centering
		\includegraphics[width=0.6\textwidth]{figure-6_jaro-winkler.pdf}
		\caption{Jaro-Winkler Similarity Evaluation Results (higher is better)} \label{fig:jaro-winkler}
	\end{figure}
	
	\paragraph{(ii) Number of Characters.} A numerical difference in the number of characters can reveal a cover document with embedded hidden content, leading to poorer imperceptibility. Besides the automatic comparison on the machine side, human actors are also more likely to perceive it. One example would be a person submitting a text document to a book publisher. If the text document includes a secret message leading to an increase in the number of characters, it can be detected by the submitting person or the publisher if a limit for the maximum number of characters applies.
	
	In our testbed, we compared the number of characters of the original cover text with a cover text that included an embedded secret message inside it. The differences $\Delta$, separated by the short and long-secret message as computed average on the dataset, are depicted in Figure~\ref{fig:character-size}.
	Only the pure one-to-one replacement techniques TREND, Lookalikes, and Rizzo et al. have the best values and do not show a difference. The four boundless algorithms and UniSpaCh show a significant increase in the number of characters due to the addition of zero-width characters and small whitespaces, making them recognizable. The negative value of $\Delta = -8.957$ for Shiu is caused by the design of the hiding algorithm. It replaces whitespaces after a specific length with newlines and removes formatting characters like tabulators, decreasing the number of characters for short secret messages.
	
	\begin{figure}[htb]
		\centering
		\includegraphics[width=0.9\textwidth]{figure-7_character-size.pdf}
		\caption{Character Size Evaluation Results (smaller $|\Delta|$ is better)} \label{fig:character-size}
	\end{figure}
	
	\paragraph{(iii) File Size.} Humans and systems can notice a text file with a hidden secret message by an increased file size. Users can raise suspicion if a tiny file with less cover text content has a comparably large file size. Thus, \citet{Majeed.2021} argue for developing data-hiding methods that create results with minimal file size.
	
	In our testbed, we compare the differences in file size between the original cover text and the cover text including a secret message. While these benchmark criteria seem closely related to the previous analysis of the number of characters, the results differ. This is related to a profound difference in characters' storage requirements. For example, \citet{ShazzadUrRahman.2021, ShazzadUrRahman.2023} replace a classical small Latin letter ``g'' (U+0067) with the similar looking mathematical alphanumeric symbol U+1D5C0 as part of the letterlike symbols in the Unicode standard~\citep{TheUnicodeConsortium.2023}. While the first needs one byte of storage in the UTF-8 encoding, the second similar-looking mathematical symbol needs four bytes of storage space. Figure~\ref{fig:file-size} illustrates the average differences $\Delta$ based on the two runs on our one million article dataset. The negative value for short secret messages from the Shiu algorithm indicates a decreased file size. This can be attributed to replacing whitespaces with newlines, similar to the number of character results. Our proposed TREND technique is just in the lower third in direct comparison because it is one of the few algorithms that embed the secret message multiple times in the cover text for increased robustness.
	
	\begin{figure}[htb]
		\centering
		\includegraphics[width=0.9\textwidth]{figure-8_file-size.pdf}
		\caption{File Size Evaluation Results (smaller $|\Delta|$ is better)} \label{fig:file-size}
	\end{figure}
	
	\paragraph{(iv) Caret Navigation.} The last imperceptibility metric relates to suspicious behavior when navigating through a digital text document with arrow keys on a computer keyboard. The \emph{caret} is the blinking pipe in an electronic text field, indicating the text cursor position. If, for example, a cover document consists of zero-width characters and the caret arrives at such a character when using arrow keys for navigation, the caret technically moves one zero-width character further but visually stays at its position without visual movement, raising suspicion. Similar abnormalities occur when additional whitespaces are used that are noticed by the user with the caret.
	
	In our testbed, we manually checked various cover texts with secret messages. We have moved with the caret in each resulting text from top to bottom to identify if something is unusual. In cases of hanging caret positions or identifying unexpected characters, we classify the algorithm as attackable by this caret analysis attack. Table~\ref{tab:caret-navigation} shows an overview of the results with a justification per algorithm as to why it is noticeable by users or not. As a result, only three algorithms (Rizzo et al., Lookalikes, and TREND) are robust against caret navigations.
	
	\begin{table*}
		\centering
		\caption{Caret Navigation Attack Evaluation}\label{tab:caret-navigation}
		\begin{tabular}{lcp{10cm}}
			\toprule
			Name & Robust & Reason\\
			\midrule
			SNOW & \ding{55} & Adds multiple whitespaces at the end of the text.\\
			UniSpaCh & \ding{55} & Adds small spaces between words, sentences, and paragraphs.\\
			AITSteg & \ding{55} & Adds zero-width characters at the beginning of the text.\\
			Shiu et al. & \ding{55} & Adds whitespaces at specific positions to encode 0 or 1.\\
			Rizzo et al. & \ding{51} & Only replacement without adding additional characters.\\
			StegCloak & \ding{55} & Adds zero-width characters in one position in the text.\\
			Lookalikes & \ding{51} & Only replacement of letters without adding additional characters.\\
			CovertSYS & \ding{55} & Adds zero-width characters at the end of the text.\\
			Shazzad-Ur-Rahman et al. & \ding{55} & Replaces letters and single whitespaces with combinations of multiple whitespaces.\\
			TREND & \ding{51} & Only replacement of whitespaces without adding additional characters.\\
			\bottomrule
		\end{tabular}
	\end{table*}
	
	\FloatBarrier
	\subsection{Robustness}
	\label{sec:robustness}
	The last primary benchmark criterion relates to the persistence of a secret message inside the cover text. In contradiction to the criteria and attacks discussed in other studies, a noticeable amount has no effect and does not need to be considered in more detail. One example is reformatting attacks that change, for example, the font color~\citep{Ahvanooey.2018b,Ahvanooey.2022}, which does not affect any algorithm in this evaluation since all are based on pure text and thus style-independent. Therefore, and in accordance with the aforementioned whitespace evaluation in Section~\ref{sec:notations}, we have analyzed the robustness of a cover text with an embedded secret message in different applications and file formats. By using simple copy and paste operations, this ``is one of the most common attacks in that the malicious users copy the whole of text and paste into their own files''~\citep[p.~7]{Ahvanooey.2018b}. In connection with related work, we extend the set of business-related targets with social media applications like WhatsApp, Facebook Messenger, or X (formerly known as Twitter) \citep{ShazzadUrRahman.2021}.
	
	In our testbed, we applied each algorithm on a Lorem ipsum dummy text to hide a secret message in the cover text. We copied each result in the application to be analyzed and checked if the secret message could still be extracted after copying back in our testbed GUI. The results are shown in Table~\ref{tab:robustness}. A ``\ding{51}'' indicates that the secret message can fully be extracted, while ``\ding{55}'' indicates a corrupt output. Edge cases are depicted as ``(\ding{51})'', like CovertSYS in a .docx document, where additional characters are shown in the extracted result, whereby the original secret message can still be recognized. Only our proposed TREND technique works partly for the \emph{.pdf} format, depending on the PDF viewer used. For example, some whitespaces are replaced with a standard U+0020 space when copying the content out of Adobe Acrobat Reader, while it stays persistent with PDF24 Reader. In such cases, a ``(\ding{51})'' is shown in Table~\ref{tab:robustness} because the respective whitespace characters remain in the original PDF file, but the robustness depends on the PDF viewer used.
	
	\begin{table*}
		\centering
		\caption{Application and File Type Robustness}\label{tab:robustness}
		\begin{tabular}{llccccccc}
			\toprule
			Algorithm & \rotatebox{90}{.txt} & \rotatebox{90}{.docx} & \rotatebox{90}{.pdf} & \rotatebox{90}{Mail} & \rotatebox{90}{Teams} & \rotatebox{90}{WhatsApp} & \rotatebox{90}{Facebook Msg. } & \rotatebox{90}{X/Twitter}\\
			\midrule
			SNOW                        & \ding{51} & \ding{51} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} & \ding{55} \\
			UniSpaCh                    & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
			AITSteg                     & \ding{51} & \ding{55} & \ding{55} & \ding{55} & \ding{51} & \ding{51} & \ding{51} & \ding{55} \\
			Shiu et al.                 & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & (\ding{51}) \\
			Rizzo et al.                & \ding{51} & \ding{55} & \ding{55} & \ding{55} & (\ding{51}) & \ding{51} & \ding{51} & \ding{55} \\
			StegCloak                   & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{55} & \ding{51} & \ding{51} & \ding{51} \\
			Lookalikes                  & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
			CovertSYS                   & \ding{51} & (\ding{51}) & \ding{55} & \ding{55} & \ding{51} & \ding{51} & \ding{55} & \ding{55} \\
			Shazzad-Ur-Rahman et al.    & \ding{51} & \ding{51} & \ding{55} & \ding{51} & \ding{55} & \ding{51} & \ding{51} & \ding{51} \\
			TREND                       & \ding{51} & \ding{51} & (\ding{51}) & \ding{51} & \ding{51} & \ding{51} & \ding{51} & \ding{51} \\
			\bottomrule
		\end{tabular}
	\end{table*}
	
	The results show that some applications remove specific characters like the Four-per-em Space (U+2005) that do not work in file types like \emph{.docx}, \emph{.pdf}, or in emails (see Table~\ref{tab:whitespace-evaluation}), but are used by algorithms like Rizzo et al. Further, the tested messengers or social media networks often remove trailing whitespaces from messages, which is why SNOW or CovertSYS encounter problems. Only our proposed TREND technique stays robust in all tested applications and file types.
	
	\FloatBarrier
	\section{Discussion}
	\label{sec:discussion}
	This section discusses our proposed TREND scheme based on the experimental evaluation results to show limitations and points of contact for future work. To our knowledge, the TREND algorithm reported in this study is the first information hiding technique that can hide a secret message inside a cover text without increasing the number of characters or getting noticed by humans while staying robust when copied in different applications.
	
	We evaluated and compared TREND in a testbed of ten algorithms from literature and practice based on a dataset of one million articles. In a direct comparison, our results partly differ from those of previous studies because the benchmark evaluation highly depends on the structure, format, and length of the cover text and the secret message. For example, we identified an embedding capacity of \around0.79 bits/character for the UniSpaCh algorithm from \citet{Por.2012} in Section~\ref{sec:capacity}. \citet{Rizzo.2019} made a similar analysis with a different cover text dataset based on the New York Times Corpus, resulting in an embedding capacity of 0.321 bits/character for UniSpaCh. The significant differences can be traced back to the different cover text inputs and algorithm properties. UniSpaCh embeds the secret message between words, sentences, and paragraphs, whereas a significant amount is hidden between paragraphs. Since \citet{Rizzo.2019} only use one paragraph, our results differ but agree better as the algorithm's strength is taken into account.
	
	In general it should be underlined that there is no one-fits-all information hiding scheme that can be considered as the best solution. Researchers and practitioners need to select an appropriate algorithm for their use case under the consideration of boundary conditions and application scenarios. Following \citet{Knochel.2024}, we provide an overview in Figure~\ref{fig:radar-summary} based on the evaluation results to support the decision-making process. 
	A boundless algorithm like AITSteg, CovertSYS, StegCloak, or SNOW should be selected if a high embedding capacity is essential. Our TREND algorithm is a favourable choice if data is often transferred between different applications and their robustness is important.
	
	\begin{figure}[htb]
		\centering
		\includegraphics[width=0.85\textwidth]{figure-9_radar-summary.pdf}
		\caption{Summarizing Evaluation Comparison inspired by \citet{Knochel.2024}} \label{fig:radar-summary}
	\end{figure}
	
	Nevertheless, limitations exist which need to be discussed in connection with future work. First, TREND's comparably small embedding capacity is one major weakness as identified in the evaluation. The structure of a TRENDmark, as shown in Figure~\ref{fig:trendmark-structure}, is built to enable optional compression. Our current implementation uses the widespread zlib data compression library\footnote{\url{https://zlib.net/}}. Future work is in progress to identify and compare various techniques to increase the capacity further.
	
	Second, the proposed solution is based and tested on the Unicode standard and the UTF-8 scheme. Future research must check the influence of other coding
	schemes like the UTF-16, ISO-standardized Latin-1, and the potential impacts on the re-coding process to a minor scheme like ASCII.
	
	Third, the algorithm is robust against standard users who do not know and recognize a document with a hidden secret message. However, people familiar with the strategy can use smart attacks to apply targeted destruction of the secret message, e.g., random replacement of $\mathcal{A}_+$. This can be eliminated by using a different random subset of $\mathcal{A}_+$ for every embedding operation. With the help of the modular TRENDmark structure, future research can use smart analysis in encoding to increase the noise tolerance and be able to extract and restore broken secret messages.
	
	Fourth, print-out and re-scan attacks using \ac{OCR} can but do not have to destroy the secret message. Since most spaces have a slightly different width that is not recognizable by human eyes, machines can restore the original whitespaces after a scan if configured correctly. This highly depends on the used font, applied \ac{OCR} technique and physical conditions like scan quality.
	
	\FloatBarrier
	\section{Conclusion}
	\label{sec:conclusion}
	We have designed and implemented TREND, an information hiding technique that is able to embed any byte encoded sequence inside a cover text. Since different solutions for digital text watermarking and steganography have been published over the last decade, existing approaches change the semantics or style of the cover text, increase the number of characters, or are not robust when copied into other applications. By encoding and mapping a secret message into our embedding alphabet of five Unicode whitespaces, we are able to embed the information in the cover text by substituting all whitespaces. The specified structure of our TRENDmark with a prefix and tag has been designed to enable additional functionalities like compression, encryption, hashing, and error correction. The experimental evaluation shows strengths in imperceptibility and robustness with limitations in embedding capacity based on a direct comparison benchmark analysis of ten algorithms. Our resulting method will help \ac{LLM} operators to fulfill regulations like the AI Act~\citep{EuropeanCommission.2024} or companies by securing sensitive data before it is shared with external parties, especially with application robustness use cases. Future work is in progress to develop the algorithm further to increase embedding capacity and enable the restoration of broken secret messages on text alterations.
	
	\FloatBarrier
	\appendix
	\section{Evaluation Data}
	For evaluating, comparing, and benchmarking our proposed \ac{TREND} method against existing solutions, we applied two batch runs on all algorithms. The first batch run uses the English example name ``John'' as a short secret message. The second batch run uses the 455-characters long \emph{Lorem ipsum} dummy text as a long secret message:
	
	\textit{``Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.''}
	
	The set of cover texts consists of one million random English Wikipedia articles since they are publicly available texts which have different lengths and structures and cover a wide range of domains. We used the cleaned article version\footnote{\url{https://huggingface.co/datasets/wikimedia/wikipedia}} based on the dump from the Wikimedia Foundation\footnote{\url{https://dumps.wikimedia.org}}. For the reproducibility of our randomized selection, the articles' IDs are available from the corresponding author upon request, which can be mapped back to the original texts and URLs. %
	
	\section*{CRediT Author Statement}
	\textbf{Malte Hellmeier:} Conceptualization, Software, Investigation, Writing - Original Draft, Visualization
	\textbf{Hendrik Norkowski:} Software, Writing - Review \& Editing
	\textbf{Ernst-Christoph Schrewe:} Software
	\textbf{Haydar Qarawlus:} Data Curation
	\textbf{Falk Howar:} Supervision
	
	\section*{Data Availability}
	An implemented version of TREND is published on GitHub \citep{FraunhoferISST.2025}. The test dataset is publicly available at \url{https://huggingface.co/datasets/wikimedia/wikipedia} based on the dump from the Wikimedia Foundation \url{https://dumps.wikimedia.org}. Information regarding the selection of our specific subset and the results of the benchmark evaluation are available from the corresponding author upon request.
	
	\section*{Acknowledgments}
	This work was supported by the Cluster of Excellence Cognitive Internet Technologies CCIT and the Center of Excellence Logistics and IT, which are funded by the Fraunhofer-Gesellschaft.
	
	\bibliographystyle{plainnat}
	\bibliography{literature}
	
\end{document}

\typeout{get arXiv to do 4 passes: Label(s) may have changed. Rerun}

