\section{Criterion III: Optimality (Table \ref{tab:optimality})} \label{sec:optimality}

Optimality means achieving the goal state through the \emph{best} possible plan. It poses a greater challenge than standard planning, which only requires reaching the goal state. Researchers have proposed two paradigms for achieving the optimal plans: LLM + Optimizer and $\textbf{A}^*$ search-based methods. \smallskip

\noindent\textbf{LLM + Optimizer}\;\; It combines the LLM, which turns user requests into symbolic optimization problems, with an optimizer that solves them and finds the best solution \cite{ju2024globe, hao2024planning}. For example, TTG \citep{ju2024globe} uses the LLM to convert travel planning requests of minimum total costs into Mixed Integer Linear Programming problems, then runs an optimizer such as SCIP \citep{bestuzheva2021scip} to provide the optimal plan. Compared to LLM + classical planners, where LLMs define the domain and problem in a formal representation, LLM + optimizers ensure optimal solutions by further formulating and solving constrained optimization problems. \smallskip

\noindent\textbf{A* Search-Based Methods} A* search always finds the lowest-cost optimal solution, making it a natural choice for LLM-based planners to achieve optimality. ToolChain* \cite{zhuang2023toolchain} combines A* tree search with an LLM, which suggests next steps and estimates heuristic scores, to create plans with the fewest tool API calls. SayCanPay \citep{hazra2024saycanpay} uses A* search with LLMs to generate the shortest possible plans. Beyond A* \citep{lehnert2024beyond} trains a Transformer model, Searchformer, to mimic A* search paths for complex tasks like Maze navigation and Sokoban puzzles, optimizing for the fewest steps. Besides A* search, other search algorithms (e.g., DFS and MCTS) can also be used to find optimal solutions.
