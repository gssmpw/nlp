\section{FuncGenFoil: Function-space Generative Model for Airfoils}

Different from existing airfoil generation methods, 
FuncGenFoil is constructed as a function-space generative model, capable of producing airfoil geometries as continuous functions instead of discrete points, leveraging the advantages of both parametric-model-based and discrete-point-based methods.  
We detail the process for airfoil generation and editing tasks, respectively.

\subsection{Airfoil Generation}
The entire FuncGenFoil is essentially an ordinary differential equation (ODE) generative model that generates airfoil by solving an ODE continuous time $t \in [0,1]$ as follows:
\begin{equation}\label{eq:ode}
    \mathrm{d}u_t = v_t\,\mathrm{d}t,
\end{equation}
%
where $v_t$ is a velocity that gradually transforms an assumed latent coding $u_0$ ($u_t$ at $t=0$) sampled from stochastic process $\mathcal{P}$ into an airfoil function $u_1$ belonging to the target airfoil distribution $\mathcal{Q}$.

\noindent \textbf{Velocity Operator.} 
Obviously, the velocity $v_t$ is the key, we achieve it by establishing a parameterized velocity operator $v_{\theta}(u_t,c,t)$ with model weights $\theta$, \emph{i.e.,} $v_t=v_{\theta}(u_t,c, t)$. 
To enable the velocity operator $v_{\theta}$ an ability to take the airfoil shape function as input, we build $v_{\theta}$ as a function-space generative model by Operator Flow Matching~\cite{shi2025stochasticprocesslearningoperator} as shown in Fig.~\ref{fig:velocity}. Specifically, 
$v_{\theta}$ consists of stacked multiple Fourier Neural Operator layers and it takes noised airfoil $u_t$ (at any resolution $d$), condition variables (optional) and a timestamp $t$ as inputs, deriving $v_t$.


\begin{figure*}[t]
    \small
    \centering
    \includegraphics[width=0.95\linewidth]{assets/airfoil_generation.pdf}
    \caption{Airfoil generation by \textbf{FuncGenFoil}. We first sample latent function from a zero-mean Gaussian process with kernel function $K$ at any resolution. 
    Then we solve an ODE flow through $t=0$ to $t=1$ using numerical ODE solver using velocity operator $v_{\theta}$ along this generation process and can generate diverse airfoils.
    As shown in (c), A single FuncGenFoil model can generate airfoils at arbitrary resolutions, from low to high, while guaranteeing identical outputs when sampling from the same latent functionâ€”an inherent property of the model's architecture.}
    \label{fig:generation}
    \vspace{-15pt}
\end{figure*}

\noindent \textbf{Airfoil Geometry Parametrization.} 
Since an airfoil has circular topology, we introduce the variable $\alpha \sim [0,2\pi]$ for convenience. 
We denote $y(\alpha) = u_1(\alpha)$ and $x(\alpha) = \frac{\cos(2\pi \alpha) + 1}{2}$\footnote{For the remainder of this paper, we omit the explicit dependence on $\alpha$ for clarity.}, achieving the function of airfoil $u_0=(x(\alpha), y(\alpha))$.


\noindent \textbf{Training.} 
We train $v_{\theta}$ under the denoising training process. Given an airfoil geometry $u_1$, we compute its corresponding noised sample at time $t$  as follows:
\begin{equation}\label{eq:path}
    u_t = t\times u_1 + (1-t)\times u_0
\end{equation}
Then we feed $u_t$ into $v_\theta$ and train $v_{\theta}$ by matching the velocity operator:
\begin{equation}\label{eq:flow_matching}
    \mathcal{L}_{\mathrm{FM}}=E_{t\sim[0,1],u_0,u_1}\left[\|v_t-v_{\theta}(u_t,c,t)\|^2\right],
\end{equation}
where $v_t$ is the ground-truth velocity: \begin{equation}\label{eq:target_velocity}
    v_t = u_1 - u_0.
\end{equation}
Detailed algorithm for training velocity operator is shown in Appendix~\ref{sec:appendix_algorithm} Algorithm~\ref{alg:pretrain}.


\noindent \textbf{Inference.}  Given a trained velocity operator $v_{\theta}$, the inference process, \emph{i.e.,} airfoil generation process, is equal to deriving airfoil geometry at time $t=1$, denoted as $u_1$, based on a latent coding $u_0$ sampled from the stochastic process $\mathcal{P}$. $\mathcal{P}$ is assumed as a Gaussian Process $\mathcal{GP}(0, K)$, where $K$ is a covariance kernel function. Therefore, $u_1$ could be derived by solving the ODE in Equation~\ref{eq:ode} numerically (e.g., using the Euler method) as follows:
\begin{equation}
    u_1 = u_0 + \int_{t=0}^{t=1} v_{\theta}(u_t, c, t)\,\mathrm{d}t.
\end{equation}
The generation process is shown in Fig.~\ref{fig:generation} while the detailed algorithm is shown in Appendix~\ref{sec:appendix_algorithm} Algorithm~\ref{alg:generation}.

\iffalse
\begin{figure*}[t]
    \small
    \centering
    \includegraphics[width=\linewidth]{assets/pretrain_2.pdf}
    \caption{Training the velocity operator $v_{\theta}$ via Operator Flow Matching in \textbf{FuncGenFoil}.}
    \label{fig:pretrain}
    % \vspace{-15pt}
\end{figure*}
\fi

\subsection{Airfoil Editing}

\begin{figure}[t]
    \small
    \centering
      \includegraphics[width=\linewidth]{assets/edit_process.pdf}
      % \vspace{-2em}
      \caption{Airfoil editing by \textbf{FuncGenFoil}. Given a original airfoil $u_1$, an editing requirement $\delta$ and target airfoil $u_1^{\delta}$. We first infer its latent function $u_0$ reversely, and make it learnable as $a_{\theta}$. Then we sample a new airfoil $u_1^{'}$, and conduct a regression in function space via maximum a posteriori estimation $\mathcal{L}_{\mathrm{MAP}}$. After a few iterations of fine-tuning, we can generate edited airfoil $u_1^{\delta}$ with high accuracy.}
      \label{fig:editing}
      
\end{figure}

The airfoil editing task enables the user to modify parts of the geometry of a given airfoil, effectively generating a new airfoil geometry while preserving the user-edited sections, denoted as $u_1^{\delta}$. 
We achieve this by an optimization method that maximum a posteriori (MAP) estimation, $\max p(u_1^{'} \mid u_1^{\delta})$ where $p(u_1^{'} \mid u_1^{\delta})$ is a probabilistic model that constrains the optimized airfoil $u_1^{'}$ fulfilling the editing requirements and following the generation prior.



To achieve the constraint probability model, we disentangled it with Bayes' Rule:
\begin{equation}
\begin{aligned}\label{eq:map}
    &\max_{u_1^{'}} p(u_1^{'} \mid u_1^{\delta})
    \;=\;
    \frac{p(u_1^{\delta} \mid u_1^{'})\cdot p(u_1^{'})}{p(u_1^{\delta})}\\
    \Rightarrow
    &\max_{u_1^{'}} \log{p(u_1^{\delta}|u_1^{'})} + \log{p(u_1^{'})} - \log{p(u_1^{\delta})},
\end{aligned}
\end{equation}

where $p(u_1^{\delta} \mid u_1^{'})$ is a Gaussian measure, so its log term becomes a Mean Square Error (MSE) between $u_1^{\delta}$ and $u_1^{'}$, constraining the user edited parts in $u_1^{'}$ keeping consistent with $u_1^{\delta}$. 
$p(u_1^{'})$ is the prior supported by the trained generative model so its log value is derived by Hutchinson trace estimator \cite{Hutchinson1989,Grathwohl2018} effectively.  
$p(u_1^{\delta})$ is the marginal likelihood, which does not depend on $u_1^{'}$. The final optimization target could be written as:

\begin{equation} \small
\label{eq:edit_loss}
\begin{aligned}
    \max_{u_1^{'}} \frac{1}{2\sigma^2} \sum_{i\in\Delta} (u_1^{\delta,i} - u_1^{',i})^2 + \log{p(u_1^{'})},
\end{aligned}
\end{equation}
where  $\sigma$ is noise, $\Delta$ denotes point indices in edited part $u_1^{\delta}$.

For more realistic generation results, the optimization does not directly adjust $u_1^{'}$; instead, we optimize $u_1^{'}$ indirectly by fine-tuning the entire generative model for a few iterations. The fine-tuning process is illustrated in Fig.~\ref{fig:editing}, while its details are provided in Alg.~\ref{alg:editing} in the main text.
Specifically, we first initialize $u'_1$ as a resample data of $u_1$, by extracting its latent code, denoted as $\alpha_\theta$, via the inverse of our generative model and re-generating $u_1^{'}$ from this code. Then we treat Equation~\ref{eq:edit_loss} as the loss function to train $\theta$ of the velocity operator and $\alpha_\theta$ simultaneously. After the model training, the new $u_1^{'}$ is the new edited generation results.

\begin{algorithm}[tb]
    \caption{Airfoil Editing.}
    \label{alg:editing}
    \textbf{Input}: pretrained neural operator $v_{\theta}$, original airfoil function $u_1$ (optional) or latent function $u_0$ (optional), editing requirement $\delta$, editing resolution $d$, sampling time steps $T$ and steps length $\mathrm{d}t$.\\
    \textbf{Parameter}: gaussian process $\mathcal{GP}(0,K)$ for sampling $u_0$, noise level $\sigma$.\\
    \textbf{Output}: new airfoil $\{y_i\}$ at resolution $d$. \\
    \begin{algorithmic}[1] %[1] enables line numbers
        \STATE Inversely sample original airfoil function $\{u_{1,i}\}$ through $v_{\theta}$ and get its latent function $\{u_{0,i}\}$.
        \STATE Set $\{a_{\theta,i}\} = \{u_{0,i}\}$.
        \WHILE{finetuning...}
        \STATE Sample $\{u_{1,i}^{'}\}$ through $v_{\theta}$ from $\{a_{\theta,i}\}$.
        \STATE Compute $\mathcal{L}_{\mathrm{MAP}}$.
        \STATE Compute gradient and update $\theta$.
        \ENDWHILE
        \STATE Sample $\{u_{1,i}^{'}\}$ through $v_{\theta}$ from $\{a_{\theta,i}\}$.
        \STATE \textbf{return} $\{y_i\}=\{u_{1,i}^{'}\}$
    \end{algorithmic}
\end{algorithm}

