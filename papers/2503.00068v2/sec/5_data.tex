\section{Dataset and Label Enhancement}
\subsection{Data Overview}
We select TIP~\cite{wu2024seeing} as our evaluation dataset because, to our knowledge, it is the sole dataset containing both temporal in-bed pressure images and SMPL annotations. TIP is an in-bed posture dataset that contains over 152K synchronously-collected three-modal images~(RGB, depth, and pressure) from 9 subjects, with matched 2D keypoint and 3D SMPL annotations. We present a glimpse visualization in~\cref{fig: dataset_vis}. The SMPL annotations are generated by a SMPLify-like approach. However, we notice severe depth ambiguity~(\eg, mistaken limb lifts) and self-penetration in their p-GTs~(marked in~\cref{fig: dataset_vis}), which are common issues for monocular optimization. Considering that reliable labels are crucial for the robustness of algorithms, we presented a general optimization approach that utilizes physical constraints to generate accurate SMPL p-GTs for in-bed scenes, named SMPLify-IB, and re-generated annotations for the whole dataset. Compared with raw annotations, we have significantly enhanced the rationality of the labels~(shown in~\cref{fig: dataset_vis}). More results will be presented in~\cref{subsec:exp_re_SIB}.

\subsection{SMPLify-IB: Generate reliable p-GTs for TIP}
SMPLify-IB contains two core alterations compared with traditional approaches: a gravity-based constraints to penalize implausible limb lift due to depth ambiguity, and a lightweight penetration detection algorithm with a potential-based loss term to penalize self-penetration. We briefly summarize our efforts as follows, and more details are given in the Sup. Mat..

\subsubsection{Gravity Constraint}
To tackle the implausible limb lifts, our rationale lies in the observations that when a person lies in bed, it should stay relaxed. Conversely, when limbs are intentionally lifted, a torque is generated at the shoulders or hips, thus resulting in discomfort. Such a conflict inspires us that when a person is motionless, all limbs should receive support to avoid an "uncomfortable" posture. Based on such an intuition, we propose a zero-velocity detection algorithm to detect implausible limb suspensions caused by depth ambiguity and exert gravity constraints to push them into contact with the bed plane or other body parts for support. Specifically, we use velocities of 2D keypoint ground-truths to calibrate limb status. For those velocities exceeding a pre-defined threshold,  we consider them to be in normal movement states; for limbs raised but nearly static, we annotate them as miscalculations from depth ambiguity and punish their distance to the bed plane. The loss term is as follows:
\begin{equation}
\small
\mathcal{L}_{g}=\sum_{i}^T \sum_{\substack{j \in G_J \\
z(i)_j>0}} \mathbb{I}\left(\operatorname{v}(i)_j<t h r e_{v}\right) e^{w_j \cdot z(i)_j} \\
\end{equation}
where $G_J$ is the set of gravity-constrained limb joints including hands, elbows, knees, and ankles, $z(i)_j$ is the signed distance of joint $j$ in timestamp $i$ to the bed plane, $v(i)_j$ is its velocity, $thre_{v}$ is the velocity threshold, $\mathbb{I}$ is the indicator function, and $\omega_j$ is the hyperparameter. 

\subsubsection{Potential-based self-penetration Constraint}
In order to reduce complexity, we only penalize the distance between lifted limbs and the bed plane in gravity loss $L_g$, which might further exacerbate self-penetration. Thus, the other main goal of SMPLify-IB is to punish severe self-intersection while encouraging plausible self-contact. Given that the \textit{Self-Contact} approach in SMPLify-XMC~\cite{muller2021self} is slow for large-dataset annotation
%and BVH in SMPLify-X~\cite{pavlakos2019expressive} can't detect self-contact vertices
, we propose a lightweight self-contact supervision that includes two main parts, lightweight self-penetration detection and potential-based self-penetration penalty modules.

\begin{figure}[t]
  \centering
  \includegraphics[width=\linewidth]{images/dataset_con_det_vis.pdf}
  \caption{(a) and (b): demos of our detection algorithm. $S$ is the segment, $C$ is its segment center. $v_i$ are vertices that need to be checked for penetration with $S$, and $v_j$ are the vertices from $S$ that are closest to $v_i$, respectively. When $\overrightarrow{v_iv_j} \cdot \overrightarrow{v_iC} < 0$, $v_i$ is in penetration, and vice versa. (c) is our segment.} 
  \label{fig: dataset_pen_demo}
\end{figure}

\begin{figure*}[htbp]
  \centering
  
  \includegraphics[width=\linewidth]{images/pihmr_architecture.pdf}
  \caption{\textbf{An overview of PI-HMR.} PI-HMR outputs the midframe's SMPL predictions of the whole sequence.
  } 
  % \vspace{-0.2cm}
  \label{fig: pihmr_architecture}
\end{figure*}

\textbf{Lightweight Detection.} In SMPLify~\cite{bogo2016keep}, authors used capsules to approximate human parts and calculate cross-part penetration. Although it's a coarse-grained limb representation, we notice that in such a capsule, the angle formed by the capsule center, penetrating vertex, and its closest vertex on the capsule-wall is likely to be obtuse. Following the observation, instead of calculating all solid angles between 6890 SMPL vertices and 13776 triangles in \textit{Winding Numbers}~\cite{jacobson2013robust} applied by SMPLify-XMC~\cite{muller2021self}, we make an approximation that the SMPL vertices could be viewed as an aggregation of multiple convex, uniform, and encapsulated segments~(shown in~\cref{fig: dataset_pen_demo}(c)), thus facilitating us to judge penetrations by spatial relations between vertices and segment centers. Specifically, assuming that a posed SMPL model could be represented by $K$ non-intersecting and convex vertex sets $\{S_1, ..., S_K\}$ and their segment center set $\{c_1, ..., c_K\}$. For any vertex $v_i$ from segment $S_i$, to determine whether it intersects with $S_j$, we firstly calculate its nearest vertex in $S_j$~(noted as $v_j$), and then judge whether intersection occurs for vertex $v_i$ by the sign of dot product $\overrightarrow{v_iv_j} \cdot \overrightarrow{v_ic_j}$~($\overrightarrow{v_iv_j} \cdot \overrightarrow{v_ic_j} < 0$ means $v_i$ is inside the segment $S_j$, and vice versa). We provide intuitively demos in~\cref{fig: dataset_pen_demo}. 

To construct approximately-convex segments, we pre-define 24 segment centers~(including 16 SMPL joints and 8 virtual joints in joint-sparse limbs like arms and legs to ensure uniformity), and employ a clustering algorithm to determine the assignment of SMPL vertices to segments. Finally, 24 segments are generated and visualized in~\cref{fig: dataset_pen_demo}(c).

\textbf{Potential-based constraints.} 
% After detection, we employ the self-contact and penetration loss to penalize intersection. 
Beside commonly-used point-wise contact term~(noted as $\mathcal{L}_{p\_con}$) and penetration penalty~(noted as $\mathcal{L}_{p\_isect}$) with Signal Distance Field~(SDF) as specified in SMPLify-XMC, we notice that SMPL vertices are spatially influenced by their closest joints. Thus, we could directly penalize the distance between centers of two intersecting segments, to push these segments moving away. For two intersecting segments $S_i$ and $S_j$, and their centers $c_i$ and $c_j$, we denote the penalty as:
\begin{equation}
\small
    \mathcal{L}_{push} = |\mathbb{D}(S_i, S_j)| \exp (-\lambda_{push} ||c_i - c_j||)
\end{equation}
where $\mathbb{D}$ is the detection algorithm and $|\mathbb{D}(S_i, S_j)|$ means the number of intersecting vertices. Similarly, we use the same version to represent the self-contact term to encourage those close but non-intersected segments to contact:
\begin{equation}
\small
    \mathcal{L}_{pull} = -|\mathbb{C}(S_i, S_j)| \exp (-\lambda_{pull} ||c_i - c_j||)
\end{equation}
where $\mathbb{C}$ is the contact detection algorithm~(\ie, SDF of two vertices between 0 - 0.02m). Both terms are constrained by set scales and center distances, acting like repulsive forces between clusters, thus named potential constraints.

Finally, we could get the whole penetration term $L_{sc}$. 
\begin{equation}
\small
    \mathcal{L}_{sc} = \mathcal{L}_{p\_con} + \mathcal{L}_{p\_isect} + \mathcal{L}_{push} +  \mathcal{L}_{pull}
\label{eq:cp_term}
\end{equation}
% After detection, 与TUCH一致，我们通过引入接触loss和穿模loss，以对接近的点进行约束。
\subsubsection{SMPLify-IB}
Finally, we present SMPLify-IB, a two-stage optimization method for SMPL p-GTs from monocular images. In the first stage, we use the CLIFF predictions as initialization and jointly optimize the shape parameter $\beta$, translation parameter $t$, and pose parameter $\theta$. After that, we use the mean shape parameters of all frames from the same subject as its shape ground truths. In the second stage, we freeze $\beta$ and only optimize $t$ and $\theta$. Both stages share the same objective functions~\cref{eq:oj_func}, exhibited as follows:
%yet they exhibit slight differences. In the first stage, we solely penalize the interpenetration between arms and other parts, while in the second stage, we impose constraints on the interpenetration of all segments. The objective is as follows:
\begin{equation}
\small
\begin{split}
    \mathcal{L}_{IB} = \lambda_J \mathcal{L}_J + \lambda_p \mathcal{L}_p + \lambda_{sm} \mathcal{L}_{sm} + \lambda_{cons} \mathcal{L}_{cons}\\ 
    + \lambda_{bc} \mathcal{L}_{bc} + \lambda_{g} \mathcal{L}_{g} + \lambda_{sc} \mathcal{L}_{sc}
\end{split}
\label{eq:oj_func}
\end{equation}
Besides the gravity loss $\mathcal{L}_g$ and self-penetration term $\mathcal{L}_{sc}$, $\mathcal{L}_J$ and $\mathcal{L}_p$ denotes the re-projection term and prior term, as specified in~\cite{bogo2016keep}; $\mathcal{L}_{sm}$ is the smooth term and $\mathcal{L}_{cons}$ is the consistency loss that penalizes the differences between the overlapped part of adjacent batches; and $\mathcal{L}_{bc}$ is the human-bed penetration loss, which is the same as~\cite{wu2024seeing}.


% \section{Method}


