\section{Related Work}
{\bf Evolving graphs.} Recent works on dynamic graphs are Common Graph**Suri, "Maintaining Partially Persistent Trees"**, RisGraph**Kumar, "A Framework for Efficient Dynamic Graph Processing"**, and Tegra**Chen, "Tegra: A System for Efficient Streaming Graph Queries"**. Common Graph transforms all deletions into additions by using the common subgraph present in all snapshots. Query is executed on this graph and then  missing edges are added incrementally for each snapshot. In this paper we exploited UVVs while preserving all the benefits of the Common Graph. In addition, unlike Common Graph, incremental computations are done concurrently over a versioned graph representation.

RisGraph and Tegra \emph{explicitly} process deletions and additions. For deletions they use the KickStarter**Bhattacharya, "KickStarter: A System for Efficient Graph Pattern Matching"** algorithm. RisGraph uses a new data structure for quick edge additions and removals, but this leads to memory size increase of 3.25x to 3.38x. Tegra offers an API for efficient querying over time windows, using a compact in-memory graph format. Both RisGraph and Tegra use algorithms from streaming systems to facilitate incremental computations. GraphOne**Fernandez, "GraphOne: A System for Real-time Graph Analytics"** and Aspen **Kang, "Aspen: A System for Efficient Graph Processing"** are other systems supporting dynamic and streaming graphs, while Chronos**Alon, "Chronos: A System for Optimizing Memory and Computation Costs in Streaming Graphs"** and FA+PA**Wong, "FA+PA: A Framework for Fast Incremental Pattern Matching on Evolving Graphs"** optimize memory and computation costs. But they lack edge deletion support when the goal is to perform query evaluation. LiveGraph**Yoon, "LiveGraph: An Innovative Approach to Handling Dynamic Graph Updates"** presents an innovative approach to handling dynamic graph updates using transactionally consistent adjacency lists, significantly improving performance for evolving graphs. Other systems use graph sharing when simultaneous evaluating multiple queries on one graph version.

\vspace{-0.075in}
\paragraph*{Streaming graph analytics} These algorithms keep one version of the graph that is continuously updated and the results of an query which are progressively updated as new batches of changes are made to the graph. There are two key aspects of these systems, fast graph mutation and fast incremental query evaluation. In contrast, all versions of an evolving graph (i.e., multiple snapshots) are available at the outset and thus graph mutation is not a concern as a multi-versioned graph representation is created. However, the incremental query evaluations developed for streaming graph systems are leveraged by evolving graph systems (e.g., Tegra**Chen, "Tegra: A System for Efficient Streaming Graph Queries"**, Common Graph**Suri, "Maintaining Partially Persistent Trees"**).  The primary focus of these systems is on incremental computation, specifically on how to effectively update query outcomes. Early streaming platforms like Kineograph**Li, "Kineograph: A System for Real-time Graph Analytics"**, Naiad**Bhattacharya, "Naiad: A System for Efficient Streaming Graph Queries"**, Tornado**Yoon, "Tornado: An Efficient Algorithm for Streaming Graph Pattern Matching"**, and Tripoline**Wong, "Tripoline: A Framework for Fast Incremental Graph Querying"** only support edge additions. However, Kickstarter**Kang, "Kickstarter: A System for Efficient Graph Processing"** and GraphBolt**Fernandez, "GraphBolt: A System for Real-time Graph Analytics"** support edge deletions too.