% \vspace{-0.1in}
\section{Related Work}

{\bf Evolving graphs.} Recent works on dynamic graphs are Common Graph~\cite{CommonGraph}, RisGraph~\cite{risgraph}, and Tegra~\cite{tegra}. Common Graph transforms all deletions into additions by using the common subgraph present in all snapshots. Query is executed on this graph and then  missing edges are added incrementally for each snapshot. In this paper we exploited UVVs while preserving all the benefits of the Common Graph. In addition, unlike Common Graph, incremental computations are done concurrently over a versioned graph representation.

RisGraph and Tegra \emph{explicitly} process deletions and additions. For deletions they use the KickStarter~\cite{kickstarter} algorithm. RisGraph uses a new data structure for quick edge additions and removals, but this leads to memory size increase of 3.25x to 3.38x. Tegra offers an API for efficient querying over time windows, using a compact in-memory graph format. Both RisGraph and Tegra use algorithms from streaming systems to facilitate incremental computations. GraphOne~\cite{GraphOne} and Aspen ~\cite{Aspen} are other systems supporting dynamic and streaming graphs, while Chronos~\cite{chronos} and FA+PA~\cite{evog-taco} optimize memory and computation costs. But they lack edge deletion support when the goal is to perform query evaluation. LiveGraph~\cite{LiveGraph} presents an innovative approach to handling dynamic graph updates using transactionally consistent adjacency lists, significantly improving performance for evolving graphs. Other systems use graph sharing when simultaneous evaluating multiple queries on one graph version~\cite{krill, glign, graphm}.

\vspace{-0.075in}
\paragraph*{Streaming graph analytics} These algorithms keep one version of the graph that is continuously updated and the results of an query which are progressively updated as new batches of changes are made to the graph. There are two key aspects of these systems, fast graph mutation and fast incremental query evaluation. In contrast, all versions of an evolving graph (i.e., multiple snapshots) are available at the outset and thus graph mutation is not a concern as a multi-versioned graph representation is created. However, the incremental query evaluations developed for streaming graph systems are leveraged by evolving graph systems (e.g., Tegra~\cite{tegra}, Common Graph~\cite{CommonGraph}).  The primary focus of these systems is on incremental computation, specifically on how to effectively update query outcomes. Early streaming platforms like Kineograph~\cite{kineograph}, Naiad~\cite{naiad}, Tornado~\cite{tornado}, and Tripoline~\cite{tripoline} only support edge additions. However, Kickstarter~\cite{kickstarter} and GraphBolt~\cite{graphbolt} support edge deletions too.
