@inproceedings{Aspen,
author = {Dhulipala, Laxman and Blelloch, Guy E. and Shun, Julian},
title = {Low-latency graph streaming using compressed purely-functional trees},
year = {2019},
isbn = {9781450367127},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3314221.3314598},
doi = {10.1145/3314221.3314598},
abstract = {There has been a growing interest in the graph-streaming setting where a continuous stream of graph updates is mixed with graph queries. In principle, purely-functional trees are an ideal fit for this setting as they enable safe parallelism, lightweight snapshots, and strict serializability for queries. However, directly using them for graph processing leads to significant space overhead and poor cache locality.  This paper presents C-trees, a compressed purely-functional search tree data structure that significantly improves on the space usage and locality of purely-functional trees. We design theoretically-efficient and practical algorithms for performing batch updates to C-trees, and also show that we can store massive dynamic real-world graphs using only a few bytes per edge, thereby achieving space usage close to that of the best static graph processing frameworks.  To study the efficiency and applicability of our data structure, we designed Aspen, a graph-streaming framework that extends the interface of Ligra with operations for updating graphs. We show that Aspen is faster than two state-of-the-art graph-streaming systems, Stinger and LLAMA, while requiring less memory, and is competitive in performance with the state-of-the-art static graph frameworks, Galois, GAP, and Ligra+. With Aspen, we are able to efficiently process the largest publicly-available graph with over two hundred billion edges in the graph-streaming setting using a single commodity multicore server with 1TB of memory.},
booktitle = {Proceedings of the 40th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {918–934},
numpages = {17},
keywords = {streaming graph processing, purely-functional data structures, parallel graph algorithms},
location = {Phoenix, AZ, USA},
series = {PLDI 2019}
}

@inproceedings{CommonGraph,
  author    = {Mahbod Afarin and
               Chao Gao and
               Shafiur Rahman and
               Nael Abu-Ghazaleh and
               Rajiv Gupta},
  title     = {CommonGraph: Graph Analytics on Evolving Data},
  booktitle = {Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems (ASPLOS’23), Vancouver, BC, Canada, March 25–29, 2023},
  pages     = {133--145},
  publisher = {{ACM}},
  year      = {2023},
  url       = {https://doi.org/10.1145/3575693.3575713},
  doi       = {10.1145/3575693.3575713},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@article{GraphOne,
author = {Kumar, Pradeep and Huang, H. Howie},
title = {GraphOne: A Data Store for Real-time Analytics on Evolving Graphs},
year = {2020},
issue_date = {November 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {15},
number = {4},
issn = {1553-3077},
url = {https://doi.org/10.1145/3364180},
doi = {10.1145/3364180},
abstract = {There is a growing need to perform a diverse set of real-time analytics (batch and stream analytics) on evolving graphs to deliver the values of big data to users. The key requirement from such applications is to have a data store to support their diverse data access efficiently, while concurrently ingesting fine-grained updates at a high velocity. Unfortunately, current graph systems, either graph databases or analytics engines, are not designed to achieve high performance for both operations; rather, they excel in one area that keeps a private data store in a specialized way to favor their operations only. To address this challenge, we have designed and developed GraphOne, a graph data store that abstracts the graph data store away from the specialized systems to solve the fundamental research problems associated with the data store design. It combines two complementary graph storage formats (edge list and adjacency list) and uses dual versioning to decouple graph computations from updates. Importantly, it presents a new data abstraction, GraphView, to enable data access at two different granularities of data ingestions (called data visibility) for concurrent execution of diverse classes of real-time graph analytics with only a small data duplication. Experimental results show that GraphOne is able to deliver 11.40\texttimes{} and 5.36\texttimes{} average speedup in ingestion rate against LLAMA and Stinger, the two state-of-the-art dynamic graph systems, respectively. Further, they achieve an average speedup of 8.75\texttimes{} and 4.14\texttimes{} against LLAMA and 12.80\texttimes{} and 3.18\texttimes{} against Stinger for BFS and PageRank analytics (batch version), respectively. GraphOne also gains over 2,000\texttimes{} speedup against Kickstarter, a state-of-the-art stream analytics engine in ingesting the streaming edges and performing streaming BFS when treating first half as a base snapshot and rest as streaming edge in a synthetic graph. GraphOne also achieves an ingestion rate of two to three orders of magnitude higher than graph databases. Finally, we demonstrate that it is possible to run concurrent stream analytics from the same data store.},
journal = {ACM Trans. Storage},
month = jan,
articleno = {29},
numpages = {40},
keywords = {Graph systems, batch analytics, graph data management, stream analytics, unified graph data store}
}

@article{LiveGraph,
author = {Zhu, Xiaowei and Feng, Guanyu and Serafini, Marco and Ma, Xiaosong and Yu, Jiping and Xie, Lei and Aboulnaga, Ashraf and Chen, Wenguang},
title = {LiveGraph: a transactional graph storage system with purely sequential adjacency list scans},
year = {2020},
issue_date = {March 2020},
publisher = {VLDB Endowment},
volume = {13},
number = {7},
issn = {2150-8097},
url = {https://doi.org/10.14778/3384345.3384351},
doi = {10.14778/3384345.3384351},
abstract = {The specific characteristics of graph workloads make it hard to design a one-size-fits-all graph storage system. Systems that support transactional updates use data structures with poor data locality, which limits the efficiency of analytical workloads or even simple edge scans. Other systems run graph analytics workloads efficiently, but cannot properly support transactions.This paper presents LiveGraph, a graph storage system that outperforms both the best graph transactional systems and the best solutions for real-time graph analytics on fresh data. LiveGraph achieves this by ensuring that adjacency list scans, a key operation in graph workloads, are purely sequential: they never require random accesses even in presence of concurrent transactions. Such pure-sequential operations are enabled by combining a novel graph-aware data structure, the Transactional Edge Log (TEL), with a concurrency control mechanism that leverages TEL's data layout. Our evaluation shows that LiveGraph significantly outperforms state-of-the-art (graph) database solutions on both transactional and real-time analytical workloads.},
journal = {Proc. VLDB Endow.},
month = mar,
pages = {1020–1034},
numpages = {15}
}

@inproceedings{chronos,
  title={Chronos: a graph engine for temporal graph analysis},
  author={Han, Wentao and Miao, Youshan and Li, Kaiwei and Wu, Ming and Yang, Fan and Zhou, Lidong and Prabhakaran, Vijayan and Chen, Wenguang and Chen, Enhong},
  booktitle={Proceedings of the Ninth European Conference on Computer Systems},
  pages={1--14},
  year={2014}
}

@article{evog-taco,
  title={Synergistic analysis of evolving graphs},
  author={Vora, Keval and Gupta, Rajiv and Xu, Guoqing},
  journal={ACM Transactions on Architecture and Code Optimization (TACO)},
  volume={13},
  number={4},
  pages={1--27},
  year={2016},
  publisher={ACM New York, NY, USA}
}

@inproceedings{glign,
author = {Yin, Xizhe and Zhao, Zhijia and Gupta, Rajiv},
title = {Glign: Taming Misaligned Graph Traversals in Concurrent Graph Processing},
year = {2022},
isbn = {9781450399159},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3567955.3567963},
doi = {10.1145/3567955.3567963},
abstract = {In concurrent graph processing, different queries are evaluated on the same graph simultaneously, sharing the graph accesses via the memory hierarchy. However, different queries may traverse the graph differently, especially for those starting from different source vertices. When these graph traversals are ”misaligned”, the benefits of graph access sharing can be seriously compromised. As more concurrent queries are added to the evaluation batch, the issue tends to become even worse. To address the above issue, this work introduces Glign, a runtime system that automatically aligns the graph traversals for concurrent queries. Glign introduces three levels of graph traversal alignment for iterative evaluation of concurrent queries. First, it synchronizes the accesses of different queries to the active parts of the graph within each iteration of the evaluation—intra-iteration alignment. On top of that, Glign leverages a key insight regarding the “heavy iterations” in query evaluation to achieve inter-iteration alignment and alignment-aware batching. The former aligns the iterations of different queries to increase the graph access sharing, while the latter tries to group queries of better graph access sharing into the same evaluation batch. Together, these alignment techniques can substantially boost the data locality of concurrent query evaluation. Based on our experiments, Glign outperforms the state-of-the-art concurrent graph processing systems Krill and GraphM by 3.6\texttimes{} and 4.7\texttimes{} on average, respectively.},
booktitle = {Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 1},
pages = {78–92},
numpages = {15},
keywords = {iterative graph algorithm, graph system, graph traversal, data locality, concurrent graph processing},
location = {Vancouver, BC, Canada},
series = {ASPLOS 2023}
}

@inproceedings{graphbolt,
  title={Graphbolt: Dependency-driven synchronous processing of streaming graphs},
  author={Mariappan, Mugilan and Vora, Keval},
  booktitle={Proceedings of the Fourteenth EuroSys Conference 2019},
  pages={1--16},
  year={2019}
}

@inproceedings{graphm,
author = {Zhao, Jin and Zhang, Yu and Liao, Xiaofei and He, Ligang and He, Bingsheng and Jin, Hai and Liu, Haikun and Chen, Yicheng},
title = {GraphM: An Efficient Storage System for High Throughput of Concurrent Graph Processing},
year = {2019},
isbn = {9781450362290},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3295500.3356143},
doi = {10.1145/3295500.3356143},
abstract = {With the rapidly growing demand of graph processing in the real world, a large number of iterative graph processing jobs run concurrently on the same underlying graph. However, the storage engines of existing graph processing frameworks are mainly designed for running an individual job. Our studies show that they are inefficient when running concurrent jobs due to the redundant data storage and access overhead. To cope with this issue, we develop an efficient storage system, called GraphM. It can be integrated into the existing graph processing systems to efficiently support concurrent iterative graph processing jobs for higher throughput by fully exploiting the similarities of the data accesses between these concurrent jobs. GraphM regularizes the traversing order of the graph partitions for concurrent graph processing jobs by streaming the partitions into the main memory and the Last-Level Cache (LLC) in a common order, and then processes the related jobs concurrently in a novel fine-grained synchronization. In this way, the concurrent jobs share the same graph structure data in the LLC/memory and also the data accesses to the graph, so as to amortize the storage consumption and the data access overhead. To demonstrate the efficiency of GraphM, we plug it into state-of-the-art graph processing systems, including GridGraph, GraphChi, PowerGraph, and Chaos. Experiments results show that GraphM improves the throughput by 1.73~13 times.},
booktitle = {Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis},
articleno = {3},
numpages = {14},
keywords = {data access similarity, concurrent jobs, storage system, iterative graph processing},
location = {Denver, Colorado},
series = {SC '19}
}

@inproceedings{kickstarter,
  title={Kickstarter: Fast and accurate computations on streaming graphs via trimmed approximations},
  author={Vora, Keval and Gupta, Rajiv and Xu, Guoqing},
  booktitle={Proceedings of the twenty-second international conference on architectural support for programming languages and operating systems},
  pages={237--251},
  year={2017}
}

@inproceedings{kineograph,
  title={Kineograph: taking the pulse of a fast-changing and connected world},
  author={Cheng, Raymond and Hong, Ji and Kyrola, Aapo and Miao, Youshan and Weng, Xuetian and Wu, Ming and Yang, Fan and Zhou, Lidong and Zhao, Feng and Chen, Enhong},
  booktitle={Proceedings of the 7th ACM european conference on Computer Systems},
  pages={85--98},
  year={2012}
}

@inproceedings{krill,
author = {Chen, Hongzheng and Shen, Minghua and Xiao, Nong and Lu, Yutong},
title = {Krill: A Compiler and Runtime System for Concurrent Graph Processing},
year = {2021},
isbn = {9781450384421},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3458817.3476159},
doi = {10.1145/3458817.3476159},
abstract = {As a large number of emerging graph applications spread across different domains, the need for processing massive concurrent graph jobs (CGJs) is increasing. However, existing graph processing systems designed for a single job cannot efficiently tackle multiple CGJs, where they suffer from interfering memory access patterns and inefficient property management. In this paper, we introduce Krill, a compiler and runtime system for processing concurrent graph jobs. We propose an SAP model, which decouples graph structure, algorithm, and property. In the compiler, we propose leveraging the property buffer to easily write and manage property data. In the runtime system, we propose a novel technique named graph kernel fusion to reduce memory accesses, which fuses all the jobs and processes them as a whole. Experimental results show our system significantly reduces the number of memory accesses for CGJs by more than 6x compared with the baseline, and achieves up to 6.76x speedup with 3.84x shorter response latency than GraphM, the state-of-the-art concurrent graph processing system.},
booktitle = {Proceedings of the International Conference for High Performance Computing, Networking, Storage and Analysis},
articleno = {51},
numpages = {16},
keywords = {concurrent graph processing, runtime systems, domain-specific compilers},
location = {St. Louis, Missouri},
series = {SC '21}
}

@inproceedings{naiad,
  title={Naiad: a timely dataflow system},
  author={Murray, Derek G and McSherry, Frank and Isaacs, Rebecca and Isard, Michael and Barham, Paul and Abadi, Mart{\'\i}n},
  booktitle={Proceedings of the Twenty-Fourth ACM Symposium on Operating Systems Principles},
  pages={439--455},
  year={2013}
}

@inproceedings{risgraph,
author = {Feng, Guanyu and Ma, Zixuan and Li, Daixuan and Chen, Shengqi and Zhu, Xiaowei and Han, Wentao and Chen, Wenguang},
title = {RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-Millisecond Per-Update Analysis at Millions Ops/s},
year = {2021},
isbn = {9781450383431},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3448016.3457263},
doi = {10.1145/3448016.3457263},
booktitle = {Proceedings of the 2021 International Conference on Management of Data},
pages = {513–527},
numpages = {15},
keywords = {monotonic algorithm, incremental computing, streaming graph},
location = {Virtual Event, China},
series = {SIGMOD '21}
}

@inproceedings{tornado,
  title={Tornado: A system for real-time iterative analysis over evolving data},
  author={Shi, Xiaogang and Cui, Bin and Shao, Yingxia and Tong, Yunhai},
  booktitle={Proceedings of the 2016 International Conference on Management of Data},
  pages={417--430},
  year={2016}
}

@inproceedings{tripoline,
  author    = {Xiaolin Jiang and
               Chengshuo Xu and
               Xizhe Yin and
               Zhijia Zhao and
               Rajiv Gupta},
  title     = {Tripoline: generalized incremental graph processing via graph triangle
               inequality},
  booktitle = {EuroSys '21: Sixteenth European Conference on Computer Systems, Online
               Event, United Kingdom, April 26-28, 2021},
  pages     = {17--32},
  publisher = {{ACM}},
  year      = {2021},
  url       = {https://doi.org/10.1145/3447786.3456226},
  doi       = {10.1145/3447786.3456226},
  timestamp = {Sun, 25 Jul 2021 11:48:42 +0200},
  biburl    = {https://dblp.org/rec/conf/eurosys/JiangXY0021.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

