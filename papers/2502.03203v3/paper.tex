%% \PassOptionsToPackage{names,dvipsnames}{xcolor}
\PassOptionsToPackage{dvipsnames}{xcolor}
% Needed for proper arXiv processing, it seems
\pdfoutput=1

% These flags are currently set to obtain the upcoming CSF submission
% !!! PLEASE DON'T CHANGE THESE !!! INSTEAD DEFINE YOUR OWN texdirectives.tex !!!
\newif\ifdraft\draftfalse % draft = comments
\newif\ifanon\anontrue    % anon = light double-blind reviewing
\newif\iffull\fullfalse   % full = includes things that were cut from
                          % conf. proceedings only because of space
                          % might be turned true for a journal submission
\newif\ifdiff\difffalse % Show diffs, to be included only as auxiliary material
\newif\iflongrefs\longrefsfalse % Long references (e.g. for journal)
\newif\ifbackref\backreffalse % backref option for hyperref
                              % useful for shrinking references
\newif\ifsooner\soonerfalse
\newif\iflater\laterfalse
\newif\ifieee\ieeetrue
\newif\ifcamera\cameratrue % Camera-ready version
\newif\ifappendix\appendixtrue % Appendix
\newif\ifallcites\allcitesfalse
\newif\ifneedspace\needspacetrue
% !!! PLEASE DON'T CHANGE THESE !!! INSTEAD DEFINE YOUR OWN texdirectives.tex !!!
\makeatletter \@input{texdirectives.tex} \makeatother

\ifieee
\documentclass[10pt, conference, compsocconf, letterpaper, times]{IEEEtran}

% removing spurious lines between references
%\def\IEEEbibitemsep{3pt}

% moving to a more reasonable tt font; the times option also changes
% the tt font to Courier, which looks bad (too thin) and wastes
% a lot of horizontal space
\renewcommand{\ttdefault}{cmtt}

% Hacked in the IEEE style to fix these problems (this gives up some space!):
% - the way the sections are "numbered" (roman, letters) is horrible
% - the way the section headings are (de)emphasized is also horrible
% - the way paragraphs are indented also sucks

% Made mathit look decent
\DeclareMathAlphabet{\mathit}{\encodingdefault}{\familydefault}{m}{it}

\else % ACM

\ifcamera
%% For final camera-ready submission
\documentclass[acmsmall]{acmart}\settopmatter{}
\else
\ifanon
%% For double-blind review submission
\documentclass[acmsmall,review,anonymous,nonacm]{acmart}\settopmatter{printfolios=true}
\else
%% For technical report
\documentclass[acmsmall,review=false,screen,nonacm]{acmart}\settopmatter{printfolios=true}
\fi
\fi

%% Journal information (used by PACMPL format)
%% Supplied to authors by publisher for camera-ready submission
\acmJournal{PACMPL}
\acmYear{2018}
\acmMonth{1}
\acmVolume{2}
\acmNumber{POPL}
\acmPrice{}
\acmArticle{65}
\acmMonth{1}
\acmDOI{10.1145/3158153}
\ifcamera\else\copyrightyear{2017}\fi %% If different from \acmYear
% \startPage{1}  %% Should be the default


%% Copyright information
%% Supplied to authors (based on authors' rights management selection;
%% see authors.acm.org) by publisher for camera-ready submission
\ifanon
\setcopyright{none}             %% For review submission
\else
\setcopyright{rightsretained}   %% CH: for anything else
\fi

\makeatletter
\def\@copyrightpermission{\ifcamera\\\\\\\fi This work is licensed under a \href{https://creativecommons.org/licenses/by/4.0/}{Creative Commons Attribution 4.0 International License}}
\makeatother

% \ifcamera\else
% \makeatletter
% \def\@authorsaddresses{}
% \fancypagestyle{firstpagestyle}{%
%   \fancyhf{}%
%   \renewcommand{\headrulewidth}{\z@}%
%   \renewcommand{\footrulewidth}{\z@}%
%     \fancyhead[L]{\ifanon\ACM@linecountL\fi}%
%     % \fancyhead[R]{\ACM@linecountR}%
%     % \fancyhead[LE]{}%
%     % \fancyhead[RO]{}%
%     % \fancyhead[RE]{}%
%     % \fancyhead[LO]{}%
%     % \fancyfoot[RO,LE]{}%
% }
% \fancypagestyle{standardpagestyle}{%
%   \fancyhf{}%
%   \renewcommand{\headrulewidth}{\z@}%
%   \renewcommand{\footrulewidth}{\z@}%
%     \fancyhead[LE]{\ifanon\ACM@linecountL\fi\@headfootfont\thepage}%
%     \fancyhead[RO]{\@headfootfont\thepage}%
%     \fancyhead[RE]{\@headfootfont\@shortauthors}%
%     \fancyhead[LO]{\ifanon\ACM@linecountL\fi\@headfootfont\shorttitle}%
%     \fancyfoot[RO,LE]{}%
% }
% \pagestyle{standardpagestyle}
% \def\@mkbibcitation{}

% %\def\@titlefont{\sffamily\Huge\bfseries}
% %-- looks nicer, but brings in too much space below it

% \makeatother
% \fi

\fi %ieee/acm


%% Some recommended packages.
\usepackage{booktabs}   %% For formal tables:
                        %% http://ctan.org/pkg/booktabs
\usepackage{subcaption} %% For complex figures with subfigures/subcaptions
                        %% http://ctan.org/pkg/subcaption

% works better with preview-latex for some reason
\usepackage[inference]{semantic}
\usepackage{amsmath}\allowdisplaybreaks
\usepackage{mathpartir}
\mprset {sep=1em} % mathpartir settings for inference rules
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{stmaryrd} %\usepackage{MnSymbol}
\usepackage{xspace}
\usepackage{latexsym}
\usepackage{ifthen}
\usepackage{mathtools}
\usepackage{color}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{tikz}
\usetikzlibrary{positioning,shadows,arrows,calc,backgrounds,fit,shapes,shapes.multipart,decorations.pathreplacing,shapes.misc,patterns,decorations.markings}
\usepackage{tikzscale}
\usepackage{tikz-qtree}
\usepackage[T1]{fontenc}
\usepackage[scaled=.83]{beramono}
\usepackage{epigraph}
\usepackage{booktabs}
\usepackage{float}
\usepackage{etoolbox}
\usepackage{wrapfig}
\usepackage{scalerel}
%\usepackage{pgfplots}
\usepackage{nameref}
\usepackage[strict]{changepage}
% \usepackage{coqed}
\newcommand\bmmax{1}\usepackage{bm}
\usepackage{graphicx}
\usepackage[makeroom]{cancel}
\usepackage{centernot}
\usepackage{thm-restate}
\usepackage{enumitem}
\usepackage{fancyvrb}
\usepackage{varwidth}
\usepackage{combelow}

% \usepackage{showlabels}

% Additional packages
\usepackage{titlecaps}
\usepackage[normalem]{ulem}
\usepackage{cals}
\usepackage{afterpage}
\usepackage{placeins}

\ifieee
% \usepackage[noadjust]{cite}
\usepackage[numbers,sort]{natbib}
\newcommand\citepos[1]{\citeauthor{#1}'s\ \cite{#1}}
\fi

%Counter for figures within sections
\usepackage{chngcntr}
%% \counterwithin{figure}{section}

\ifanon
\usepackage[switch]{lineno}
\linenumbers
\renewcommand{\linenumberfont}{\tiny\color{gray}}
\fi

% \usepackage{afterpage} -- \afterpage{\clearpage}
\usepackage{stfloats}

% Colors
\definecolor{dkblue}{rgb}{0,0.1,0.5}
\definecolor{dkgreen}{rgb}{0,0.4,0}
\definecolor{dkred}{rgb}{0.6,0,0}
\definecolor{dkpurple}{rgb}{0.7,0,1.0}
\definecolor{purple}{rgb}{0.9,0,1.0}
\definecolor{olive}{rgb}{0.4, 0.4, 0.0}
\definecolor{teal}{rgb}{0.0,0.4,0.4}
\definecolor{azure}{rgb}{0.0, 0.5, 1.0}
\definecolor{gray}{rgb}{0.5, 0.5, 0.5}
\definecolor{dkgray}{rgb}{0.3, 0.3, 0.3}

% Color-blind scheme for diffs
% https://www.nceas.ucsb.edu/sites/default/files/2022-06/Colorblind%20Safe%20Color%20Schemes.pdf
\definecolor{cbgreen}{RGB}{000,158,115}
\definecolor{cbblue}{RGB}{000,114,178}
%\definecolor{cbteal}{RGB}{086,180,233}
\definecolor{cbteal}{RGB}{091,142,253}
\definecolor{cbyellow}{RGB}{240,228,066}
%\definecolor{cborange}{RGB}{230,159,000}
\definecolor{cborange}{RGB}{230,140,000}
\definecolor{cbred}{RGB}{213,094,000}
\definecolor{cbpurple}{RGB}{204,121,167}

\newcommand*{\colSel}[1]{{\color{cbblue} #1}}
\newcommand*{\colU}[1]{{\color{cbred} #1}}
\newcommand*{\colFlexshared}[1]{{\color{cbpurple} #1}}
\newcommand*{\colFlexnew}[1]{{\color{cbpurple} #1}}
\newcommand*{\colAll}[1]{{\color{black} #1}}

% hyperref should generally come last
\ifieee
\usepackage[
    pdftex,%
    pdfpagelabels,%
    colorlinks,%
    linkcolor=dkblue,%
    citecolor=dkblue,%
    filecolor=dkblue,%
    urlcolor=dkblue%
    \ifbackref,backref\fi%
]{hyperref}
\else
\usepackage{hyperref}
% Conflicts if passing options
\hypersetup{
  breaklinks=true,
  citecolor=black,
  linkcolor=black,
  urlcolor=black,
}
\fi



% autoref config

\def\Snospace~{\S{}}
\def\sectionautorefname{\Snospace}
\def\subsectionautorefname{\Snospace}
\def\subsubsectionautorefname{\Snospace}
\def\Nnospace~{}
\def\appendixautorefname{\Snospace}

% begin appendix autoref patch [\autoref subsections in appendix](https://tex.stackexchange.com/questions/149807/autoref-subsections-in-appendix)
\usepackage{etoolbox}
\makeatletter
\patchcmd{\hyper@makecurrent}{%
    \ifx\Hy@param\Hy@chapterstring
        \let\Hy@param\Hy@chapapp
    \fi
}{%
    \iftoggle{inappendix}{%true-branch
        % list the names of all sectioning counters here
        \@checkappendixparam{chapter}%
        \@checkappendixparam{section}%
        \@checkappendixparam{subsection}%
        \@checkappendixparam{subsubsection}%
        \@checkappendixparam{paragraph}%
        \@checkappendixparam{subparagraph}%
    }{}%
}{}{\errmessage{failed to patch}}

\newcommand*{\@checkappendixparam}[1]{%
    \def\@checkappendixparamtmp{#1}%
    \ifx\Hy@param\@checkappendixparamtmp
        \let\Hy@param\Hy@appendixstring
    \fi
}
\makeatletter

\newtoggle{inappendix}
\togglefalse{inappendix}

\apptocmd{\appendix}{\toggletrue{inappendix}}{}{\errmessage{failed to patch}}
% \apptocmd{\subappendices}{\toggletrue{inappendix}}{}{\errmessage{failed to patch}}
% end appendix autoref patch

% A few hacks?

\makeatletter
\setlength\mpr@andskip{0em}
\makeatother

% http://tex.stackexchange.com/questions/149626/tikz-library-calc-and-auctex-preview-in-emacs-fails
\AtBeginEnvironment{tikzpicture}{\catcode`$=3 } % $

% fix a problem when using \src in titles.
% \colorlet{NAVYBLUE}{NavyBlue}

\newcommand\maybecolor[1]{\color{#1}}
\newcommand\mypara[1]{\vskip 0.03in \noindent{\textbf{\itshape{#1}}}\quad}

% Comments
\newcommand{\comm}[3]{\ifdraft{{\color{#1}[#2: #3]}}\fi}
\newcommand{\ch}[1]{\comm{teal}{CH}{#1}}
\newcommand{\rb}[1]{\comm{orange}{RB}{#1}}
\newcommand{\ld}[1]{\comm{dkpurple}{LD}{#1}}

% Diff (for the review version)
\newcommand{\remove}[1]{\ifdiff{\color{red}\sout{#1}}\fi}
\newcommand{\add}[1]{\ifdiff{\color{blue}#1}\else #1\fi}

% Some helpers

\newcommand{\citeFull}[2]{\ifallcites\cite{#1,#2}\else\cite{#1}\fi}

\newcommand*{\EG}{e.g.,\xspace}
\newcommand*{\IE}{i.e.,\xspace}
\newcommand*{\ETAL}{et al.\xspace}
\newcommand*{\ETC}{etc.\xspace}

% Scheme names

\newcommand*{\SLH}{SLH\xspace}
\newcommand*{\aSLH}{a\SLH}
\newcommand*{\vSLH}{v\SLH}
\newcommand*{\SelectiveSLH}{Selective \SLH}
\newcommand*{\SelectiveaSLH}{Selective a\SLH}
\newcommand*{\SelectivevSLH}{Selective v\SLH}
\newcommand*{\SelSLH}{SSLH\xspace} % CH: too vague, please avoid or just spell out where really needed
\newcommand*{\SelaSLH}{SaSLH\xspace}
\newcommand*{\SelvSLH}{SvSLH\xspace}
\newcommand*{\UltimateSLH}{Ultimate \SLH}
\newcommand*{\USLH}{USLH\xspace}
%% \newcommand*{\StrongSLH}{Strong \SLH}
%% \newcommand*{\SSLH}{SSLH\xspace}
\newcommand*{\FlexibleSLH}{Flexible \SLH}
\newcommand*{\FlexSLH}{FSLH\xspace}
\newcommand*{\FlexaSLH}{FaSLH\xspace}
\newcommand*{\FlexvSLH}{FvSLH\xspace}

% Language name

\newcommand*{\SourceLang}{\textsc{AWhile}\xspace}

% Properties, etc.

\newcommand*{\CCT}{CCT\xspace}
\newcommand*{\ObsEq}{observational equivalence\xspace}

% Math mode helpers

\newcommand*{\BoolTrue}{\mathbb{T}}
\newcommand*{\BoolFalse}{\mathbb{F}}
\newcommand*{\LabelSecret}{\BoolFalse}
\newcommand*{\LabelPublic}{\BoolTrue}

\newcommand*{\PubVars}{\textit{P}}
\newcommand*{\PubArrs}{\textit{PA}}
\newcommand*{\mathpc}{\textit{pc}}

\newcommand*{\cexpr}[1]{\mathit{#1}}
\newcommand*{\cvar}[1]{\texttt{#1}}
\newcommand{\aif}[3]{#1~?~#2~:~#3}

\newcommand*{\mathif}[3]{\mathit{if} ~ #1 ~ \mathit{then} ~ #2 ~ \mathit{else} ~ #3}

%% Imp commands
\newcommand*{\cskip}{\texttt{skip}}
\newcommand*{\casgn}[2]{#1 ~ \texttt{:=} ~ #2}
\newcommand*{\cseq}[2]{#1 \texttt{;} ~ #2}
\newcommand*{\cif}[3]{\texttt{if} ~ #1 ~ \texttt{then} ~ #2 ~ \texttt{else} ~ #3 ~ \texttt{end}}
\newcommand*{\cwhile}[2]{\texttt{while} ~ #1 ~ \texttt{do} ~ #2 ~ \texttt{end}}
\newcommand*{\caread}[3]{#1 \leftarrow #2 \texttt{[} #3 \texttt{]}}
\newcommand*{\cawrite}[3]{#1 \texttt{[} #2 \texttt{]} \leftarrow #3}

%% Shortened commands for semantics, etc., when there is no room for ambiguity
\newcommand*{\cifs}[3]{\texttt{if} ~ #1 ~ \texttt{then} ~ #2 ~ \texttt{else} ~ #3}
\newcommand*{\cifsnoelse}[2]{\texttt{if} ~ #1 ~ \texttt{then} ~ #2}
\newcommand*{\cwhiles}[2]{\texttt{while} ~ #1 ~ \texttt{do} ~ #2}

%% Target-only
\newcommand*{\ccond}[3]{#1 ~ \texttt{?} ~ #2 ~ \texttt{:} ~ #3}
\newcommand*{\ccondtight}[3]{#1 \texttt{?} #2 \texttt{:} #3}

%% Typing judgments
\newcommand*{\wtifcAux}[4]{#1; #2 \vdash_{#3} #4}
\newcommand*{\wtifc}[2]{\wtifcAux{\PubVars}{\PubArrs}{#1}{#2}}
%% \newcommand*{\wtct}[2]{#1 \vdash_{\texttt{CT}} #2}
\newcommand*{\wtct}[1]{\PubVars; \PubArrs \vdash #1}

%% Translation function
\newcommand*{\transl}[1]{\llparenthesis ~ #1 ~ \rrparenthesis}
\newcommand*{\translAux}[3]{\transl{#1}^{\mathit{#2}}_{#3}}
\newcommand*{\transls}[2]{\translAux{#1}{#2}{\PubVars}}
%% \newcommand*{\transls}[2]{\transl{#1}^{\mathit{#2}}_{\PubVars}}

%% Semantics
% (Distinguish between boolean and arithmetic eval?)
\newcommand*{\eval}[2]{\llbracket #1 \rrbracket_{#2}}
\newcommand*{\size}[1]{\texttt{size(}#1\texttt{)}}
\newcommand*{\progSize}[2]{\texttt{prog\_size(}#1,\,#2\texttt{)}}
\newcommand*{\seqstate}[3]{\langle #1,#2,#3\rangle}
\newcommand*{\specstate}[4]{\langle #1,#2,#3,#4\rangle}
\newcommand*{\SeqEval}[7]{\seqstate{#1}{#2}{#3} \seqstep{#7} \seqstate{#4}{#5}{#6}}
\newcommand*{\SpecEval}[1]{
  \def\SpecEvalTemp{{#1}}
  \SpecEvalAux
}
\newcommand*{\SpecEvalAux}[9]{\specstate{\SpecEvalTemp}{#1}{#2}{#3} \specstep{#8}{#9} \specstate{#4}{#5}{#6}{#7}}
\newcommand*{\MultiSeq}[7]{\seqstate{#1}{#2}{#3} \seqmulti{#7} \seqstate{#4}{#5}{#6}}
\newcommand*{\MultiSpec}[1]{
  \def\SpecEvalTemp{{#1}}
  \MultiSpecAux
}
\newcommand*{\MultiSpecAux}[9]{\specstate{\SpecEvalTemp}{#1}{#2}{#3} \specmulti{#8}{#9} \specstate{#4}{#5}{#6}{#7}}

\newcommand*{\IdealEval}[1]{
  \def\IdealEvalTemp{{#1}}
  \IdealEvalAux
}
\newcommand*{\IdealEvalAux}[9]{\idealstep{\specstate{\IdealEvalTemp}{#1}{#2}{#3}}{#8}{#9}{\specstate{#4}{#5}{#6}{#7}}}
\newcommand*{\MultiIdeal}[1]{
  \def\IdealEvalTemp{{#1}}
  \MultiIdealAux
}
\newcommand*{\MultiIdealAux}[9]{\specstate{\IdealEvalTemp}{#1}{#2}{#3} \idealmulti{#8}{#9} \specstate{#4}{#5}{#6}{#7}}

\newcommand*{\step}{\textit{step}}
\newcommand*{\branch}[1]{\textit{branch}\,#1}
\newcommand*{\force}{\textit{force}}
\newcommand*{\OARead}[2]{\textit{read}\,#1\,#2}
\newcommand*{\OAWrite}[2]{\textit{write}\,#1\,#2}
\newcommand*{\DLoad}[2]{\textit{load}\,#1\,#2}
\newcommand*{\DStore}[2]{\textit{store}\,#1\,#2}

\newcommand*{\ScalarState}{\rho}
\newcommand*{\ArrayState}{\mu}
\newcommand*{\SemSpecFlag}{b}
\newcommand*{\Obss}{\mathcal{O}}
\newcommand*{\Dirs}{\mathcal{D}}

\newcommand*{\subst}[3]{[#1 \mapsto #2] #3}
\newcommand*{\lookup}[2]{#1 ( #2 )}
\newcommand*{\UsedVars}[1]{\mathit{VARS} ( #1 )}

\newcommand*{\natofbool}[1]{\llbracket #1 \rrbracket_{\mathbb{N}}}

%% Semantics

% (mathrel doesn't seem to do much, cf. mathop for top/bottom placement)
\newcommand*{\seqstep}[1]{\xrightarrow{#1}}
\newcommand*{\seqmulti}[1]{\xrightarrow{#1}{\hspace{-0.5em}}{}^*}
\newcommand*{\specstep}[2]{\xrightarrow[#2]{#1}\hspace{-0.5em}{}_s}
\newcommand*{\specmulti}[2]{\xrightarrow[#2]{#1}{\hspace{-0.5em}}{}_s^*}
\newcommand*{\idealsteparrow}[2]{\xrightarrow[#2]{#1}{\hspace{-0.5em}}{}_i}
\newcommand*{\idealmultiarrow}[2]{\xrightarrow[#2]{#1}{\hspace{-0.5em}}{}_i^*}

\newcommand{\specobseq}{\approx_\mathit{s}}
\newcommand{\seqobseq}{\approx}

% TODO: These two need to be fixed
% (and the others need their two state parameters)
% (P; PA never change so they are hardwired here)
\newcommand*{\idealstep}[4]{#1 \xrightarrow[#3]{#2}\hspace{-0.5em}{}_i #4}
\newcommand*{\idealmulti}[4]{#1 \xrightarrow[#3]{#2}\hspace{-0.5em}{}_i^* #4}
\newcommand*{\idealstepfull}[4]{\PubVars\vdash \idealstep{#1}{#2}{#3}{#4}}
\newcommand*{\idealmultifull}[4]{\PubVars \vdash \idealmulti{#1}{#2}{#3}{#4}}
% (Unify with seqmulti and specmulti above)
\newcommand*{\seqmultis}[3]{#1 \seqmulti{#2} #3}
\newcommand*{\specmultis}[4]{#1 \specmulti{#2}{#3} #4}

% (A bit more lightweight than the forms above? Unify later!)

%% Labeling functions
\newcommand*{\labelarith}[2]{#1(#2)} % CH: dropped _{\mathbb{N}} (too pedantic)
\newcommand*{\labelbool}[2]{#1(#2)} % CH: dropped _{\mathbb{B}}  (too pedantic)
% (Could also omit P as it never changes)
\newcommand*{\ArithLabel}[1]{\PubVars(#1)}
\newcommand*{\BoolLabel}[1]{\PubVars(#1)}

%% Value SLH
\newcommand*{\ValueCheck}[2]{\mathit{VC}(#1, #2)}

%% References to parts of multi-line equations
\renewcommand*{\eqref}[1]{(\ref{#1})}

% Spacing tricks
\newcommand*{\negphantom}[1]{\settowidth{\dimen0}{#1}\hspace*{-\dimen0}}

% (Quick test for highlighting in figures, not super smooth, may go
% away later)
\newcommand*{\highlight}[1]{{\color{cbred} #1}}
\newcommand*{\colHighlight}[1]{{\color{cbred} #1}}
%% \newcommand{\highlight}[2][lightgray]{\mathchoice%
%%   {\fboxsep0pt\colorbox{#1}{$\displaystyle#2$}}%
%%   {\fboxsep0pt\colorbox{#1}{$\textstyle#2$}}%
%%   {\fboxsep0pt\colorbox{#1}{$\scriptstyle#2$}}%
%%   {\fboxsep0pt\colorbox{#1}{$\scriptscriptstyle#2$}}}%

% Theorem environments

\theoremstyle{definition}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\newtheorem{conjecture}{Conjecture}
\newtheorem{listing}{Listing}

%% \ifieee
%% % some of the space hacks below might still make sense for the IEEE style
%% \else
%% \abovedisplayskip=0pt
%% \abovedisplayshortskip=0pt
%% \belowdisplayskip=0pt
%% \belowdisplayshortskip=0pt
%% \fi

%% \setlength{\textfloatsep}{0pt plus 0.0pt minus 0.0pt}
%% \setlength{\belowcaptionskip}{0pt plus 0.0pt minus 0.0pt}
%% \setlength{\abovecaptionskip}{1pt plus 0.0pt minus 0.0pt}
%% \setlength{\intextsep}{0pt plus 0.0pt minus 0.0pt}

%MARCO: play with these to change space around align and equations
%% \setlength{\abovedisplayskip}{4pt}
%% \setlength{\belowdisplayskip}{4pt}

\ifieee\pagestyle{plain}\else\pagestyle{standardpagestyle}\fi

\newcommand{\titleString}{FSLH: Flexible Mechanized Speculative Load Hardening}
\title{\titleString}
% Alt: FlexSLH: Flexible Speculative Load Hardening
% Alt: Flexible Mechanized SLH
% Alt: Mechanized -> Machine-Checked
% Alt: FlexSLH -> FSLH (shorter, like USLH, aSLH, easier to do FaSLH FvSLH)
% Alt: FSLH: Flexible Mechanized Speculative Load Hardening

%% \ifieee
%% \makeatletter
%% \AtBeginDocument{
%%   \hypersetup{
%%     pdftitle = {\titleString},
%%     pdfauthor = {\ifanon\else El-Korashy et al.\fi}
%%   }
%% }
%% \makeatother

\ifneedspace
\title{\huge\bf{\titleString}
% \\[0.5ex] \LARGE \subtitleString
\ifneedspace\ifieee\ifanon\vspace{-1.5em}\else\vspace{-0.5em}\fi\fi\else\ifanon\vspace{2em}\fi\fi}
\else
\title{\titleString}
\subtitle{\subtitleString}
\fi


%% Author information
%% Contents and number of authors suppressed with 'anonymous'.
%% Each author should be introduced by \author, followed by
%% \authornote (optional), \orcid (optional), \affiliation, and
%% \email.
%% An author may have multiple affiliations and/or emails; repeat the
%% appropriate command.
%% Many elements are not rendered, but should be provided for metadata
%% extraction tools.

\ifanon
\author{}
\else

\ifieee\large
\author{
% TODO: Alphabetic for now, but final order TBD
  Roberto Blanco\textsuperscript{1} \quad
  L\'eon Ducruet\textsuperscript{1,2} \quad
  Sebastian Harwig\textsuperscript{1,3} \quad
  C\u{a}t\u{a}lin Hri\cb{t}cu\textsuperscript{1} \quad
\\[0.5em]
%
{\small
  \textsuperscript{1}MPI-SP, Bochum, Germany\quad
  \textsuperscript{2}ENS Lyon, France\quad
  \textsuperscript{3}Ruhr University Bochum, Germany}\\[0em]
}
\else %ACM

\author{AUTHOR1}
\affiliation{
  \ifcamera\institution{AFF1}\city{CITY}\country{COUNTRY}
  \else\institution{AFF1}\fi}
\email{EMAIL}

\makeatletter
\renewcommand{\@shortauthors}{SHORTAUTHORS}
\makeatother

\fi %ieee/acm

\fi % anon


\begin{document}

%% Paper note
%% The \thanks command may be used to create a "paper note" ---
%% similar to a title note or an author note, but not explicitly
%% associated with a particular element.  It will appear immediately
%% above the permission/copyright statement.
%\thanks{with paper note}                %% \thanks is optional
                                        %% can be repeated if necessary
                                        %% contents suppressed with 'anonymous'

\ifieee\maketitle\fi

%% Abstract
%% Note: \begin{abstract}...\end{abstract} environment must come
%% before \maketitle command
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{abstract}
\input{abstract.txt}
\end{abstract}

\ifieee
\renewcommand\IEEEkeywordsname{Keywords}
\begin{IEEEkeywords}
side-channel attacks, speculative execution, Spectre, secure compilation,
speculative load hardening, speculative constant time, relative security,
formal verification, Rocq, Coq
\end{IEEEkeywords}
\fi

\section{Introduction}
\label{sec:intro}

% \paragraph{Context and Gap:}
% See my Amazon proposal and Jonathan's internship topic
%
% Selective SLH is fast but only protects cryptographic constant time programs
%
% Ultimate SLH provides protection for arbitrary programs (relative security)
% but it's slow, since it indiscriminately assumes everything is secret.
%
%
Speculative side-channel attacks such as Spectre pose formidable threats for the
security of computer systems~\cite{CanellaBSLBOPEG19, McIlroySTTV19}.
%
% While side-channels are better studied in the context of cryptographic code [5,
% 8], speculative execution attacks can be equally devastating for operating
% systems, hypervisors, browsers, cloud computing, etc.
%
For instance, in typical Spectre v1 attacks~\cite{KocherHFGGHHLM019},
misspeculated array bounds checks cause out-of-bounds memory accesses to
inadvertently load and reveal secrets via timing variations.
%
SLH~\cite{Carruth18} is a software countermeasure against such attacks, originally proposed
and implemented by LLVM, that dynamically tracks whether execution is in a
mispredicted branch using a misspeculation flag register.
%
This misspeculation flag is used as a mask to erase the {\em value} of any
misspeculated loads, in a variant \citet{ZhangBCSY23} denote as vSLH,
for {\em value SLH}.
%
Another variant supported by LLVM is to mask the {\em address} of any
misspeculated loads, which also following \citeauthor{ZhangBCSY23}, we denote as
aSLH, for {\em address SLH}.
%
\iflater
\ch{This nice distinction between vSLH and aSLH is taken from
  \cite{ZhangBCSY23}. According to \href{https://secure-compilation.zulipchat.com/\#narrow/channel/436285-speculation/topic/SLH.20in.20LLVM}{Rob's report},
  what LLVM actually implements these days seems to be a very messy combination
  of the two? TBH I wasn't able to understand much of Rob's report and why the
  combination makes any sense. Seems worth investigating that further, also
  because there is a chance it makes no sense, so it's insecure.}
\fi

It is, however, challenging to build software protections
% that eliminate entire classes of speculative side-channel attacks and that
that are both efficient and
that provide formal end-to-end security guarantees
against precisely specified, speculative side-channel attacker
models~\cite{CauligiDMBS22}. % CH: This one is not speculative BartheBGHLPT20
%
Cryptography researchers are leading the way in this space, with defenses such
as {\em selective} vSLH efficiently achieving speculative constant-time
guarantees against Spectre v1 for cryptographic code with typical overheads
under 1\%~\cite{ShivakumarBBCCGOSSY23, ShivakumarBGLOPST23}.
% and with prototype compilers formally enforcing and preserving speculative
% constant time~\cite{OlmosBBGL24}.
%
This work is, however, specialized to only cryptographic code and
often also to domain-specific languages for cryptography,
such as Jasmin~\cite{AlmeidaBBBGLOPS17}.

It is more difficult to properly protect arbitrary programs written in
general-purpose languages, which in particular do not obey the cryptographic
constant-time discipline~\cite{AlmeidaBBDE16,CauligiSJBWRGBJ19}.
%
SLH was not strong enough for protecting such non-cryptographic
code~\cite{PatrignaniG21}, leading to the introduction of Ultimate
SLH~\cite{PatrignaniG21, ZhangBCSY23}, which uses the misspeculation flag
to mask not only the values loaded from memory, but also
all branch conditions, all memory addresses,
the operands of all non-constant time operations, etc.
%
While this should in principle be strong enough to achieve a relative security
notion~\cite{CauligiDMBS22, ZhangBCSY23, PatrignaniG21},
it also brings $\sim$150\% overhead on the SPEC benchmarks~\cite{ZhangBCSY23},
which seems unacceptable for many practical scenarios.

In this paper we introduce FSLH, a flexible SLH notion that achieves the best of
both worlds by generalizing both Selective and Ultimate SLH.
%
Like Selective SLH, FSLH keeps track of which program inputs are secret and
which ones not and only protects those memory operations that could potentially
leak secret inputs when ran speculatively.
%
Like Ultimate SLH, FSLH also provides protection for non-cryptographic code that
does not respect the constant-time discipline, but does this by only masking
those branch conditions and memory addresses that are potentially influenced by secrets.

\paragraph{Contributions}
\begin{itemize}[leftmargin=*,nosep,label=$\blacktriangleright$]
\item We introduce FSLH, a Flexible SLH notion generalizing both
  Selective SLH and Ultimate SLH.
%
  This applies to both vSLH and aSLH, resulting in two
  variants: {\em Flexible value SLH} (FvSLH) and {\em Flexible address SLH} (FaSLH).

\item We prove formally in the Rocq prover\footnote{The
  \href{https://rocq-prover.org/}{Rocq interactive theorem prover} was previously
  known as Coq.} that FvSLH and FaSLH can each be instantiated to recover both the
  corresponding Selective SLH variant as well as Ultimate SLH.
%
  The connection to Selective SLH guarantees that cryptographic constant-time
  code pays no extra performance penalty under Flexible SLH compared to Selective SLH.
%
  The connection to Ultimate SLH states that if all data is labeled as secret
  then the program receives the same protection as with Ultimate SLH.

\item We give a suitable relative security definition for transformations
  protecting arbitrary programs, like FSLH and Ultimate SLH: any
  transformed program running with speculation should not leak more than what
  the source program leaks sequentially (so without speculation).

\item We prove in Rocq that our two flexible SLH variants, FvSLH and FaSLH,
  enforce this relative security notion.

\item As a corollary we obtain in Rocq that Ultimate SLH also enforces
  relative security, which is, the first machine-checked security proof for
  Ultimate SLH~\cite{PatrignaniG21,ZhangBCSY23}.

% as far as we know, the first thorough security
% proof for Ultimate SLH~\cite{ZhangBCSY23}.\ch{It's actually more complicated,
%   since \citet{PatrignaniG21} also had some ``proofs'', including for
%   completely wrong versions, so their ``proofs'' don't seem worth much.}
% We actually obtain two proofs for this corollary, but whatever?

\item Other easy corollaries we obtain in Rocq are that Selective vSLH and
  Selective aSLH enforce speculative constant-time security, whereas previously
  only Selective vSLH was proved secure and only on
  paper~\cite{ShivakumarBBCCGOSSY23}.
%
  In fact, for Selective aSLH we are the first to even give a formal definition,
  which is nontrivial for memory stores.
\end{itemize}

\paragraph{Outline} \autoref{sec:background} presents required background,
after which \autoref{sec:key-ideas} introduces our key ideas on FaSLH.
%
\autoref{sec:defs} defines our simple imperative language and its sequential and
speculative semantics.
%
\autoref{sec:formal-results} describes the proofs of our formal results for FaSLH,
while \autoref{sec:FvSLH} quickly presents the analogous results for FvSLH.
%
\autoref{sec:related-work} describes related work and 
\autoref{sec:future-work} concludes with future work.

\paragraph{Artifact} All the results of this paper have been fully formalized in
the Rocq proof assistant and are available \ifanon as supplementary materials
  for this submission.\else at \url{https://nce.mpi-sp.org/index.php/s/nggS2PMEWa5gynJ}\\\fi
% The core definitions and auxiliary lemmas for sequential and speculative semantics
% take $\sim$800 lines of code, and the main development has $\sim$2000 lines of code.
The Rocq development leading to our main theorems has $\sim$2600 lines of code.


\section{Background}
\label{sec:background}

\subsection{Speculative Execution Attacks}
\label{sec:spectre}

Modern processors implement a variety of hardware mechanisms such are caches to
get software to run faster.
% CH: pedagogical, but not needed here
% Among these, cache hierarchies are essential for performance.
% programs to have access to large (but slow) memories, while being
% able to retrieve frequently used data from fast (but small) caches.
Caches are part of the internal
microarchitectural state of the CPU: they improve performance, but are
not exposed to the programmer through the instruction set architecture (ISA) and
thus have no bearing on the result of any computations.
% CH: moved the text here, but it already seems a too long detour
% From the point of view of performance, the aim of the processor is to
% always be doing useful work; caches in particular seek to minimize the
% time spent waiting for costly memory accesses.
%
%% These caches and their behavior are not part of the ISA that
%% specifies the computational behavior of a CPU.
Yet their effects on performance can be detected by measuring the execution time
of a program, which may leak information about its data.
% \ch{again via timing; let's please more explicitly focus only on timing}
Timing side-channel attacks exploiting
microarchitectural leakage are a common concern for cryptographic code
and other secret-manipulating programs.
%
% \rb{I think some discussion of microarch state is relevant because it
% connects the discussion below to reality. Could foreshadow CCT.}

%% State that has no bearing on the results of computations

%% Exploit locality

\emph{Speculative execution} is another technique designed to increase
performance by executing instructions
that are likely, even if not certain, to be needed by a program. For
example, the condition of a branch instruction could depend on slow memory
accesses or the results of instructions that have not finished executing.
%
Instead of waiting, a processor can use a branch predictor to
guess an outcome for the condition and immediately start executing
instructions from the chosen branch. When the result of the condition
is later known, the processor commits the effects of the speculative
path if the guess was correct, or reverts them and starts executing
the correct path if the guess was wrong.
%
This rollback ensures that misspeculation has no effect
on % the programmer-visible architectural
ISA state, but does not undo changes to the microarchitectural state, like the caches.

This opens the door to \emph{speculative leaks} via timing side
channels that would not exist if there was no misspeculation. Even
more, % because elements like branch predictors are shared between
% processes, a collocated \ch{It's true that poisoning caches
% is easier when one is collocated, but it's definitely not a prerequisite.}
an attacker can train the predictors to misspeculate (directly if collocated, or
even indirectly by causing the program's own code to be cleverly
invoked~\cite{SchwarzSLMG19}), which is the essence of Spectre attacks.
%
A Spectre v1 attack~\cite{KocherHFGGHHLM019}
(aka Spectre-PHT~\cite{CanellaBSLBOPEG19})
% \rb{which one should we use throughout?} CH: v1, see abstract and intro
targets the branch predictor
% \IE the pattern history table, -- CH: whatever! zero relevance
to steer a target program down certain speculative paths that
create timing leakage.
% which can then be retrieved by inspecting
% its effects on microarchitectural state. -- CH: please stop assuming collocation
%
This is the classic speculative execution attack:

%% Spectre v1 attack is a type of side channel attack that exploits

%% Microarchitectural state\ch{relevant for us?} and observability

\begin{listing}[Spectre v1 gadget]
\label{ex:v1std}

\begin{align*}
&~\cifsnoelse{\cvar{i < a$_1$\_size}}
  {\\&\quad~\cseq
   {\caread{\cvar{j}}{\cvar{a}_1}{\cvar{i}}}
   {\\&\quad~ \caread{\cvar{x}}{\cvar{a}_2}{\cvar{j}}&}
  }
\end{align*}
\end{listing}

% \ch{The $\cvar{J * CACHE\_LINE\_SIZE}$ part above is completely artificial.  No
%   developer writes that in their code, except if they are trying their best to
%   get attacked and leak their own secrets. I would go with b[j] or if j then ...}

% \ch{Much less important, but why are we using all caps for some of the variable
%   names like I or J or even ARR_SIZE?} CH: fixed

This code indexes a secret array $\cvar{a}_1$ over an untrusted input
$\cvar{i}$. A conditional validates that the input is in the right
range, and only in this case accesses $\cvar{a}_1$ at that position. It
then uses the result to index a read from a second array $\cvar{a}_2$.
%
The problem is that prior to invoking this code an attacker can train
the branch predictor to guess that the \texttt{then} branch will be
taken. The attacker can then run the program with an out-of-bounds input $\cvar{i}$
that actually points at secret data, and
although the \texttt{then} branch should not be taken, the processor can
start running the instructions on the \texttt{then} branch before the
actual value of the branch condition is resolved. The first array
access loads out-of-bounds secret data into $\cvar{j}$, and
the second access loads from $\cvar{a}_2$ at an address that depends on
that $\cvar{j}$.
%
While the processor will course-correct as soon as it detects its
misspeculation, the access to $\cvar{a}_2\cvar{[j]}$ leaves a footprint in the
cache, so the attacker can measure timing to infer the value of $\cvar{j}$,
which contains speculatively loaded secret data.
% analyze it to infer the
% % potentially secret
% value of $\cvar{j}$.
% \ch{Again assuming a collocated attacker that can more easily mount cache
%   attacks, but collocation is not strictly speaking needed for Spectre attacks.}

\subsection{Speculative Load Hardening}

Speculative Load Hardening~\cite{Carruth18} (\SLH) is a family of software-based
countermeasures against Spectre v1 attacks originally proposed and implemented
by LLVM.
% It seeks to prevent secret data from leaking to architectural state during
% speculative execution.\ch{Didn't get this ``to architectural state'' part.}
% CH: anyway, this doesn't seem to add much (just confusion)
\SLH is a program transformation that combines two ingredients:

\begin{enumerate}

\item a mechanism to keep track of misspeculation, and

\item a means of preventing speculative leaks.

\end{enumerate}

The first is shared by all \SLH variants. The core transformation
from \autoref{fig:aslh-template} shows how
to maintain a \emph{misspeculation flag} tracking whether
any branch was mispredicted along the current control path at any given time.
%
This is possible because all modern architectures have support for
implementing control flow conditions using branchless and unpredicted
instructions, \EG conditional moves in x86 assembly.
%% \ch{Relate this to Figure 1,
%%   by explaining that we assume that b?e1:e2 is implemented this way.}

We can easily implement such a flag in a language that uses those
instructions to provide a constant-time conditional, like the
$\cexpr{be} \texttt{ ? } \cexpr{e_1} \texttt{ : } \cexpr{e_2}$ operator
in \autoref{fig:aslh-template}, which evaluates $\cexpr{e_1}$ if
$\cexpr{be}$ is true, and $\cexpr{e_2}$ if it is false.
%% exposes these
%% instructions to the programmer.\ch{No, we don't assume that cmove is exposed,
%%   just that it's used to implement b?e1:e2}
%
We assume the variable $\cvar{b}$ is reserved for the flag and unused by
programs, and we ensure that its value is 1 if the processor is
misspeculating, and 0 if it is not.
% (and therefore its initial value). -- CH: breaking the flow
%
The transformation applies recursively to the structure of
commands. Ignoring for now the helpers that parameterize the
scheme ($\llbracket \cdot \rrbracket_{\mathbb{B}}$,
$\llbracket \cdot \rrbracket_{\mathit{rd}}$ and
$\llbracket \cdot \rrbracket_{\mathit{wr}}$), the interesting cases
are the two branching commands: conditionals and loops.

In both cases there are two paths: one where the branch condition is
true % (resp. the \texttt{then} branch and the body of the loop)
and one where it is false.
% (resp. the \texttt{else} branch and the command following the loop).
%
%% \begin{enumerate}
%% \item
% In the first case,
For instance,
if the branch condition is true, the command $\cexpr{c_1}$ in the \text{then}
branch (resp.  in the loop body)
works assuming that $\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}$ is true. We use a
constant-time conditional
%% \ch{good, but then no need to introduce
%%   confusion earlier about exposing cmoves and whatnot. An we should also
%%   explain the syntax of this in the figure: b?e1:e2.}
to evaluate the same condition and
determine if the processor is misspeculating. If it is not, the
condition will indeed evaluate to true, and we will leave the
speculation flag unchanged (\IE no new misspeculation has
occurred). If it is misspeculating, the condition will evaluate to false, and we will
% use branchless logic to -- CH: we already branched though
set the flag to 1. This allows the program to
detect misspeculation and protect itself accordingly.
%% \item
% The case when the branch condition is false is similar.
% similarly on the \texttt{else} $c_2$ (resp. the
% code after the loop) flipping the boolean cases.
%% Conversely, the command $\cexpr{c_2}$ in the \text{else} branch
%% (resp. the code after the loop) works assuming that
%% $\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}$ is false. To protect
%% against misspeculation, we evaluate the condition again using
%% unpredicted logic, but flipping the cases of the branchless
%% conditional: if the condition is actually true we are misspeculating,
%% and if it is false we are not.
  % \ch{This case is very boring (just symmetric),
  % so I would drop it even if we didn't have space issues.}
  % \rb{Done, just a quick mention}
%% \end{enumerate}

%
%% If we run a program $\cifs{\cvar{X = 0}}{\cexpr{c_1}}{\cexpr{c_2}}$
%% from a state where $\cvar{X}$ has the value $1$, we expect the
%% $\texttt{else}$ branch $\cexpr{c_2}$ to run, but a speculative
%% attacker can force the execution of the $\texttt{then}$ branch, which
%% assumes $\cvar{X = 0}$.
%% %
%% How can the $\texttt{then}$ branch know it is misspeculating, \IE that
%% it should not be executing? It can commence by using unpredicted logic
%% to compute the negation of its condition, $\cvar{X <> 0}$. This
%% computation yields true if and only if the processor is executing the
%% wrong branch.

%% Now consider a conditional statement guarded
%% by a boolean condition $\cexpr{be}$, ignoring for now the function
%% $\llbracket \cdot \rrbracket_{\mathbb{B}}$
%% in \autoref{fig:aslh-template}.

%% The flag $\cvar{b}$ can let $\cexpr{c_1}$ know that it is speculating.

%% After each conditional control flow
%% instruction, the program uses branchless code to compute
%% the \emph{negation} of the expected value of the condition, \EG check
%% if the condition of an \texttt{if} instruction evaluates to false at
%% the top of its \texttt{then} branch. If the processor is not
%% misspeculating, negated checks will always evaluate to false; but if
%% the processor is misspeculating, a branchless negated check will
%% evaluate to true, making this information available to the program.

%% \rb{
%% Tried using a concrete example, not sure it works better. Could also
%% show the standard gadget after the first part of the transformation.
%% }\ch{+1 for showing what standard aSLH does to Listing 1
%%   and explaining intuitively why the leak is stopped}

The second ingredient of the transformation is using the misspeculation
flag to prevent speculative leaks.
%
\autoref{fig:aslh-template} provides
a generic template for \aSLH, where the indexes of array
loads and stores, as well as the branch conditions can be sanitized in
different ways, resulting in different variants, each
with different trade-offs between their degree of protection against
speculative side channels and their performance cost.

Let's first consider the standard \aSLH transformation, which
leaves branch conditions unchanged, \IE
$\llbracket \cexpr{be} \rrbracket_{\mathbb{B}} \doteq \cexpr{be}$, and
protects all array accesses based on the speculation flag.
%
If $\cvar{b}$ contains the speculation flag and $\cvar{i}$ is the
index we intend to access,
%% that could be
%% invalid due to misspeculation, as in \autoref{ex:v1std},
we can use the constant-time conditional expression
$\ccond{\cvar{b==1}}{\cvar{0}}{\cvar{i}}$ to protect it: when the
processor is misspeculating (as indicated by the set flag $\cvar{b==1}$) the index is
zeroed and the access protected;
%% and prevents its observation by the attacker
when the processor does not misspeculate, the access is left unchanged.
%
That is, $\llbracket \cexpr{i} \rrbracket_{\mathit{rd}}
\doteq \llbracket \cexpr{i} \rrbracket_{\mathit{wr}}
\doteq \ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}$.
%
%% In \SaSLH, indexes is masked when reading data to a public variable
%% and when writing to an address that depends on secret data (in both
%% cases to prevent secrets from leaking to an attacker).
%
%% The original \SLH mitigation protects the addresses of loads,\ch{I'm quite
%%   skeptical about calling aSLH ``the original \SLH''. On what is this claim
%%   based, which to me seems surprising?}
%% \IE the indexes of array reads in the example, and other variations have since
%% been proposed in the literature.

\begin{figure}
\centering
\begin{align*}
\transl{\cskip} &\doteq \cskip \\
\transl{\casgn{\cvar{x}}{\cexpr{e}}} &\doteq \casgn{\cvar{x}}{\cexpr{e}} \\
\transl{\cseq{\cexpr{c_1}}{\cexpr{c_2}}} &\doteq \cseq{\transl{\cexpr{c_1}}}{\transl{\cexpr{c_2}}} \\
%% \transl{\cifs{\cexpr{be}}{\cexpr{c_1}}{\cexpr{c_2}}} &\doteq \cif{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cseq{\casgn{\cvar{b}}{\ccond{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{b}}{\cvar{1}}}}{\transl{\cexpr{c_1}}}}{\cseq{\casgn{\cvar{b}}{\ccond{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{1}}{\cvar{b}}}}{\transl{\cexpr{c_2}}}} \\
\transl{\cifs{\cexpr{be}}{\cexpr{c_1}}{\cexpr{c_2}}} &\doteq \texttt{if }{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}} \\
\phantom{\transl{\cskip}} &\phantom{\doteq}\hspace{0.5em} \texttt{then }{\cseq{\casgn{\cvar{b}}{\ccondtight{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{b}}{\cvar{1}}}}{\transl{\cexpr{c_1}}}} \\
\phantom{\transl{\cskip}} &\phantom{\doteq}\hspace{0.5em} \texttt{else }{\cseq{\casgn{\cvar{b}}{\ccondtight{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{1}}{\cvar{b}}}}{\transl{\cexpr{c_2}}}} \\
%% \transl{\cwhiles{\cexpr{be}}{\cexpr{c}}} &\doteq \cseq{\cwhile{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cseq{\casgn{\cvar{b}}{\ccond{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{b}}{\cvar{1}}}}{\transl{\cexpr{c}}}}}{\casgn{\cvar{b}}{\ccond{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{1}}{\cvar{b}}}} \\
\transl{\cwhiles{\cexpr{be}}{\cexpr{c}}} &\doteq \texttt{while }{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}\texttt{ do} \\
\phantom{\transl{\cskip}} &\phantom{\doteq}\hspace{1.5em} {\cseq{\casgn{\cvar{b}}{\ccondtight{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{b}}{\cvar{1}}}}{\transl{\cexpr{c}}}} \\
\phantom{\transl{\cskip}} &\phantom{\doteq}\hspace{0.5em} {\casgn{\cvar{b}}{\ccondtight{\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}}{\cvar{1}}{\cvar{b}}}} \\
\transl{\caread{\cvar{X}}{\cvar{a}}{\cexpr{i}}} &\doteq \caread{\cvar{X}}{\cvar{a}}{\llbracket \cexpr{i} \rrbracket_{\mathit{rd}}} \\
\transl{\cawrite{\cvar{a}}{\cexpr{i}}{\cexpr{e}}} &\doteq \cawrite{\cvar{a}}{\llbracket \cexpr{i} \rrbracket_{\mathit{wr}}}{\cexpr{e}}
\end{align*}
\caption{Master recipe for aSLH}
\label{fig:aslh-template}
\end{figure}

\begin{figure*}[!b]
\subcaptionbox{Selective aSLH \label{fig:saslh-instance}}[0.38\linewidth]{
\begin{align*}
\llbracket \cexpr{be} \rrbracket_{\mathbb{B}}
 &\doteq \colSel{
  \phantom{\left\{ \right.}
  \begin{matrix*}[l]
  \phantom{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}
  \\
  \cexpr{be}
  \end{matrix*}
  %% \phantom{\right.}
  }
\\
\llbracket \cexpr{i} \rrbracket_{\mathit{rd}}
 &\doteq \colSel{
  \left\{
  \begin{matrix*}[l]
  {\colAll{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}} &
  {\mathit{if} ~ \PubVars(\cvar{X})}
  \\
  {\cexpr{i}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
  }
\\
\llbracket \cexpr{i} \rrbracket_{\mathit{wr}}
 &\doteq \colSel{
  \left\{
  \begin{matrix*}[l]
  {\colAll{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}} &
  {\mathit{if} ~ \lnot\labelarith{\PubVars}{\cexpr{e}}}
  %% {\mathit{if} ~ \labelarith{\PubVars}{\cexpr{e}} : \LabelPublic}
  \\
  {\cexpr{i}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
  }
\end{align*}
}
\subcaptionbox{Flexible aSLH \label{fig:faslh-instance}}[0.42\linewidth]{
\begin{align*}
%% \llbracket \cexpr{be} \rrbracket_{\mathbb{B}}
 &\colFlexnew{
 %% &\doteq \colFlexnew{
  \left\{
  \begin{matrix*}[l]
  {\colU{\cvar{b==0 \&\& } \cexpr{be}}} &
  {\mathit{if} ~ \lnot\labelbool{\PubVars}{\cexpr{be}}}
  %% {\mathit{if} ~ \labelbool{\PubVars}{\cexpr{be}} : \LabelPublic}
  \\
  {\colSel{\cexpr{be}}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
  }
\\
%% \llbracket \cexpr{be} \rrbracket_{\mathit{rd}}
 &\colSel{
 %% &\doteq \colSel{
  \left\{
  \begin{matrix*}[l]
  {\colAll{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}} &
  {\mathit{if} ~ \PubVars(\cvar{X}) \mathrel{\colFlexnew{\vee}} \colFlexnew{\lnot\labelarith{\PubVars}{\cexpr{i}}}}
  \\
  {\cexpr{i}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
  }
\\
%% \llbracket \cexpr{be} \rrbracket_{\mathit{wr}}
 &\colSel{
 %% &\doteq \colSel{
  \left\{
  \begin{matrix*}[l]
  {\colAll{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}} &
  {\mathit{if} ~ \lnot\labelarith{\PubVars}{\cexpr{e}} \mathrel{\colFlexnew{\vee}} \colFlexnew{\lnot\labelarith{\PubVars}{\cexpr{i}}}}
  %% {\mathit{if} ~ \labelarith{\PubVars}{\cexpr{e}} : \LabelPublic \mathrel{\colFlexnew{\wedge}} \colFlexnew{\labelarith{\PubVars}{\cexpr{i}} : \LabelPublic}}
  \\
  {\cexpr{i}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
  }
\end{align*}
}
\subcaptionbox{\UltimateSLH \label{fig:uslh-instance}}[0.15\linewidth]{
\begin{align*}
%% \llbracket \cexpr{be} \rrbracket_{\mathbb{B}}
 &\phantom{\left\{ \right.}
  \begin{matrix*}[l]
  \colU{\cvar{b==0 \&\& } \cexpr{be}}
  \\
  \phantom{\labelbool{\PubVars}{\cexpr{be}} : \LabelPublic}
  \end{matrix*}
  %% \phantom{\right.}
 %% &\doteq \colU{\cvar{b==0 \&\& } \cexpr{be}}
\\
%% \llbracket \cexpr{be} \rrbracket_{\mathit{rd}}
 &\phantom{\left\{ \right.}
  \begin{matrix*}[l]
  \ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}
  \\
  \phantom{\PubVars(\cvar{X}) : \LabelPublic}
  \end{matrix*}
  %% \phantom{\right.}
 %% &\doteq \ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}
\\
%% \llbracket \cexpr{be} \rrbracket_{\mathit{wr}}
 &\phantom{\left\{ \right.}
  \begin{matrix*}[l]
  \ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}
  \\
  \phantom{\labelarith{\PubVars}{\cexpr{e}}}
  \end{matrix*}
  %% \phantom{\right.}
 %% &\doteq \ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}
\end{align*}
}
% \ch{Can we use darker shades of yellow and blue?
%   They are too light to comfortably read for me, especially when not bold.}
\caption{Overview of aSLH variants instantiating recipe from \autoref{fig:aslh-template}}
\label{fig:aslh-variants}
\end{figure*}

Applying \aSLH to \autoref{ex:v1std} we obtain the following code:

\begin{listing}[Spectre v1 gadget protected with aSLH]
\label{ex:v1hardened}
% \ld{Changed the array names : a -> $a_1$; b -> $a_2$. b being already used for
% the speculation bit feels confusing} CH: good catch
%% \rb{Absolutely right!}

\begin{align*}
  &\cifs{\cvar{i < a$_1$\_size}}{\\
  &\quad\casgn{\cvar{b}}{\ccond{(\cvar{i < a$_1$\_size})}{\cvar{b}}{\cvar{1}}}\texttt{;}\\
  &\quad\caread{\cvar{j}}{\cvar{a}_1}{\ccond{\cvar{b==1}}{\cvar{0}}{\cvar{i}}}\texttt{;}\\
  &\quad\caread{\cvar{x}}{\cvar{a}_2}{\ccond{\cvar{b==1}}{\cvar{0}}{\cvar{j}}}\\&
  }{\\
    &\quad\casgn{\cvar{b}}{\ccond{\cvar{(i < a$_1$\_size)}}{\cvar{1}}{\cvar{b}}}&
  }
\end{align*}

\end{listing}

A Spectre v1 attacker can \emph{still} force the execution
of the \texttt{then} branch when $\cvar{i}$ is out of bounds, but this
will be detected and $\cvar{b}$ will be updated to reflect
it. Then the first array access will become $\cvar{a}_1\cvar{[0]}$ and will no
longer be out of bounds, and the attacker will be unable to exploit it to load secrets.
%% for gain


\subsection{Cryptographic Code Security}
\label{sec:specct}

Cryptographic implementations are common targets of timing side-channel attacks
aimed at extracting keys, even remotely over the Internet~\cite{BrumleyB05}.
%
To mitigate these dangers, cryptographic
engineers have developed secure programming disciplines, notably
cryptographic constant time (\CCT), now considered standard practice in the
field~\cite{AlmeidaBBDE16, CauligiSJBWRGBJ19, DanielBR23, BartheBCLP20}.
%
\CCT protects secrets from timing side-channel attacks
arising from secret-dependent branches and memory accesses.
For this, it imposes two requirements on the programmer:

\begin{enumerate}

\item
all program inputs must be identified as public or secret,
% and possibly tagged with confidentiality labels, and
% CH: no clue what this was trying to add
\item
control flow and memory addresses
that depend on secret inputs are not allowed.\footnote{
  Also variable-time arithmetic operations are not allowed on secrets,
  but these are not relevant for the simple setting of this paper.}

\end{enumerate}

%% It is possible to transform a program that is not \CCT into one that
%% is, while incurring some (likely significant) performance
%% cost.

% \rb{Foreshadow our use of IFC type systems later.}
Researchers have designed security analyses ensuring that these \CCT conditions
are met for real-world code~\cite{AlmeidaBBDE16, DanielBR23, BartheBCLP20}.
%
% A program that adheres to the \CCT policy can
%% under certain
%% conditions\rb{which?}\ch{none? no clue what conditions you're talking about,
%%   (but then I also don't understand why you bring up ``microarchitectural
%%   state'' below, see next comment). Is this about when CCT implies
%%   timing security? \url{https://dblp.org/rec/journals/jar/BartheBC0P20.html?view=bibtex}.
%%   This is an interesting connection between constant time and the real word,
%%   but conceptually different that your next theorem.}
%% be proved to be secure against an attacker that
%% can make \emph{observations} based on the microarchitectural state of
%% the machine.\ch{How about something like ``timing observations.'' (period). I'm
%%   not sure why you keep bringing up ``microarchitectural state''.}
% be proved secure against timing side channels.
Even if the attacker can directly observe the branches that
are taken and the memory addresses that are accessed,
%% . In spite of
%% these observational capabilities,
a \CCT program does not leak any secret information to the attacker. Prior
work has shown that this implies security against timing side-channel attacks
exploiting data and instruction caches~\cite{BartheBCLP20}.

%% Formally, \CCT security is defined as follows:
% \ch{Please explain this definition.
%   % including the funny notation with the arrow-star that leads
%   % nowhere.\ch{Couldn't we find a better notation?} -- CH: tried
%   Also explain intuitively that $O$ includes all branches and memory addresses
%   accesses the program accesses.}
% \ch{Should be consistent throughout the paper
%   between $O$ and $\Obss$, and $D$ and $\Dirs$}

\begin{definition}[Cryptographic Constant-Time Security]
\label{def:cct-sec}
% \rb{ Name/introduce the property here, purely high level or simplified,
% NI? SCT builds on it in a way.} CH: no clue why this would be helpful, so whatever
A program $c$ satisfies \CCT security w.r.t. public variables $P$
if for any public-equivalent states ($s_1 \sim_P s_2$), when
the program executes to completion on both states (\IE a small-step
semantics $\seqmulti{}$ fully evaluates the program from each state),
then both runs produce the same sequence of branching decisions and
memory accesses observable by an attacker ($\Obss_1 = \Obss_2$).
%
\[
\begin{array}{ll}
 s_1 \sim_P s_2 & \mathrel{\land}
  \langle c, s_1 \rangle \seqmulti{\Obss_1} \langle \cskip, \cdot \rangle\\
  & \mathrel{\land} \langle c, s_2 \rangle \seqmulti{\Obss_2} \langle \cskip, \cdot \rangle
  \Rightarrow \Obss_1 = \Obss_2
\end{array}
\]
%% \[
%% \begin{array}{l}
%%   s_1 \sim_P s_2 \mathrel{\land}
%%   \langle c, s_1 \rangle \seqmulti{\Obss_1} \langle \cskip, \cdot \rangle
%%   \mathrel{\land} \langle c, s_2 \rangle \seqmulti{\Obss_2} \langle \cskip, \cdot \rangle
%%   \Rightarrow \\ \Obss_1 = \Obss_2
%% \end{array}
%% \]
%
%% \[ s_1 \sim_P s_2 \mathrel{\land}
%%   \langle c, s_1 \rangle \seqmulti{\Obss_1} \langle \cskip, \cdot \rangle
%%   \mathrel{\land} \langle c, s_2 \rangle \seqmulti{\Obss_2} \langle \cskip, \cdot \rangle
%%   \Rightarrow \Obss_1 = \Obss_2 \]
\end{definition}

% \rb{Actually the above is for the big-step semantics: fix}\ch{+1, also Def 2;
%   could fake it by going to skip, which would be consistent
%   with what 3.1 calls ``full executions''.}\ch{Tried and it looks okay,
%     so if we're willing to give up a line here (and one below too) it seems fine?}
%   \rb{Looks fine, yep!}

In the speculative world, an attacker can invalidate these
guarantees. By influencing the microarchitectural state of the
hardware, it can force a program to speculatively execute control
paths that are impossible in the standard, sequential semantics, and
leak secret data through the timing side channels CCT is supposed to
close~\cite{CauligiDGTSRB20,BartheCGKLOPRS21,VassenaDGCKJTS21,ShivakumarBBCCGOSSY23}.
%
To reason about these threats, we need a more informative semantics
that abstracts the speculative capabilities of an
attacker~\cite{ShivakumarBBCCGOSSY23}.
%
This \emph{speculative semantics} ($\specmulti{}{}$ below) adds rules that steer
execution along wrong branches and out-of-bounds memory accesses,
triggered by \emph{directives} $\Dirs$ issued by the attacker.
%
The speculative semantics also adds a boolean flag $b$ to the state to indicate
whether the processor is misspeculating.
%
We define speculative constant-time (SCT) security below in terms of
a notion of speculative observationally equivalence:
%
% We can also define
% % \ch{why? again to define relative security, no?
% % \rb{Yes, this is to get shorter statements, should we rephrase
% % relative security using these forms here?}}
% the speculative counterpart to speculative \ObsEq,
% where we execute a pair of initial states, which are now given the
% same sequence of directives. This allows us to tighten the
% correspondence between the two runs, which can now be required to
% produce identical observation traces.
%
\begin{definition}[Speculative \ObsEq]
\label{def-specobs}
%
Two speculative configurations $\langle c_1, s_1, b_1 \rangle$
and $\langle c_2, s_2, b_2 \rangle$ are observationally equivalent
w.r.t. the speculative semantics, written
$\langle c_1, s_1, b_1 \rangle \specobseq \langle c_2, s_2, b_2\rangle $ iff
% $c_1 = c_2$ and -- CH: not needed?
\[
  \forall \Dirs \Obss_1 \Obss_2.~
    \langle c_1, s_1, b_1 \rangle \specmulti{\Obss_1}{\Dirs} \cdot \mathrel{\land}
    \langle c_2, s_2, b_2\rangle \specmulti{\Obss_2}{\Dirs} \cdot \Rightarrow
    \Obss_1 = \Obss_2
\]

\end{definition}

Compared to SCT definitions from the literature~\cite{CauligiDGTSRB20,
  DanielBR21,VassenaDGCKJTS21} we are looking at all execution prefixes that do
not necessarily finish in a final state (the $\cskip$ in \autoref{def:cct-sec}).
%
This choice gives us stronger guarantees in the definitions below, for instance
making our SCT definition termination-sensitive.
%
We can directly compare observations $\Obss_1$ and $\Obss_2$ for equality here,
since the two speculative executions take identical directions $\Dirs$, which in
our setting implies that $|\Obss_1| = |\Dirs| = |\Obss_2|$.

\begin{definition}[Speculative Constant-Time Security]
\label{def:sct-sec}
% \rb{Traces used informally, the earlier the better, -- CH: already used in prev def
% any mention of relative security?}\ch{This one is not relative, so not here.}
%
A program $c$ satisfies SCT security if for any public-equivalent initial states
$s_1 \sim_P s_2$ and starting before mispeculation ($\BoolFalse$)
\[\langle c, s_1, \BoolFalse \rangle \specobseq \langle c, s_2, \BoolFalse \rangle\]

% the corresponding pair
% of runs produces the same observations under the speculative semantics and
% identical attacker directives $\Dirs$:
% \[
% \begin{array}{ll}
% s_1 \sim_P s_2 & \mathrel{\land} \langle c, s_1, \BoolFalse \rangle \specmulti{\Obss_1}{\Dirs} \langle \cskip, \cdot, \cdot \rangle\\
%  & \mathrel{\land} \langle c, s_2, \BoolFalse \rangle \specmulti{\Obss_2}{\Dirs} \langle \cskip, \cdot, \cdot \rangle \Rightarrow \Obss_1 = \Obss_2
% \end{array}
% \]
\end{definition}

% \rb{Example for this part? Reuse something from 2.1?}\ch{2xYes if we can do this quickly.
%   For a start, the code in Listing 1 is CCT, yet speculatively it leaks secrets!
%   Our SpecCT chapter also has some examples by Sebastian.}
%% \rb{
%% Need to say something about the general form of the semantics here,
%% and then make it more concrete later?}

\begin{example}
%
It is easy to see that \autoref{ex:v1std} is \CCT if the variables
are initially public. Even so, speculatively it leaks
secrets, as discussed in \autoref{sec:spectre}.
%
Formally, this program is not SCT secure, since for an out-of-bounds $\cvar{i}$,
the attacker can use a first directive in $\Dirs$ to force the program to
misspeculate on the \texttt{then} branch, and then a second directive to ask for
a secret in memory instead of the out-of-bounds value of $\cvar{a}_1[\cvar{i}]$.
%
The secret is loaded in $\cvar{j}$, and then made visible to the attacker through
the address of the second load operation, which is observed to have
different values in $\Obss_1$ and $\Obss_2$.
%
On the other hand, after aSLH protection (\autoref{ex:v1hardened}) this program is SCT
secure. In fact, any CCT program hardened with aSLH satisfies SCT security, and as
we will see in the next subsection, a selective variant of aSLH
is enough for enforcing this.
\end{example}

% \ch{Before even going selective, aSLH from 2.3 already enforces Speculative
%   Constant-Time Security for CCT source programs (stated as conjecture below,
%   since I don't think we have a proof, but informally it's obvious given Thm 1).
% %
%   Selective (a)SLH is just a
%   performance optimization, so let's start with aSLH and CCT security first.}

% \begin{conjecture}
% \label{thm:aslh-ct}
% aSLH enforces SCT security.
% \end{conjecture}

%% \ch{Up to here this was all background. Could potentially move that
%%   to separate section, so that it's clearer what are {\em our} key ideas (below).}

\section{Key Ideas}
\label{sec:key-ideas}

\subsection{Selective aSLH}

% \rb{Removing "address" from the subsection title for now to make it consistent
% with FlexSLH below (but our SaSLH variant is the focus here)}
%  -- CH: Went for a better way to achieve consistency: both have the a now
%% \ch{Then the goal of what follows in this subsection
%%   should actually be to introduce {\em our} new
%%   Selective aSLH variant using Figure 2.a. Enough background and detours! Time
%%   to finally get to our key ideas and contributions! So let's stick to aSLH in
%%   this whole Key Ideas section.}

\SelectiveSLH
% (\SelSLH) -- too vague; no need for shorthand it
is a more efficient variant of \SLH that ``only
masks values speculatively loaded into publicly-typed variables''
\cite{ShivakumarBBCCGOSSY23},
exploiting the security levels present in \CCT programs to minimize the
number of masking operations while protecting secrets from
speculative attackers.
%
The original proposal uses a CCT type system to only mask the {\em values of
  loads into public variables} (\IE the \SelvSLH variant we discuss later in
  \autoref{sec:FvSLH}).
%
Yet the same optimization is also applicable to \aSLH leading
to \emph{Selective address \SLH (\SelaSLH)}, which 
we show in \autoref{fig:saslh-instance}, and which
as far as we know, has not been studied formally before.
%
The masking of loads in $\llbracket \cdot \rrbracket_{\mathit{rd}}$
uses a public map $\PubVars$ of variables to their boolean security levels
(public $\LabelPublic$ or secret $\LabelSecret$)
and functions $\labelarith{\PubVars}{\cexpr{e}}$
and $\labelbool{\PubVars}{\cexpr{b}}$ computing the security levels of
arithmetic and boolean expressions.
%% that compute the security levels of complex
%% expressions as the highest level among their constituents.

One crucial observation we make in this paper is that for achieving security for
\SelaSLH it does {\em not} suffice to only mask the addresses of loads, as shown
by the following counterexample we discovered during the formal proofs:

% In giving a formal definition to this countermeasure, we make the
% crucial observation that it does \emph{not} suffice to mask addresses
% on loads:

  %% In fact, for Selective aSLH we are the first to even give a formal definition,
  %% which is nontrivial for memory stores.

\begin{listing}[Leakage through unprotected stores]
  \label{ex:aslh-vs-vslh}
\begin{align*}
  &\cifsnoelse{\cvar{i < secrets\_size}}{\\
  &\quad\cawrite{\cvar{secrets}}{\cvar{i}}{\cvar{key}}\texttt{;}\\
  &\quad\caread{\cvar{x}}{\cvar{a}}{\cvar{0}}\texttt{;}\\
    &\quad\cifsnoelse{\cvar{x}}{ ... }
  }
  \end{align*}
\end{listing}

Once again for an invalid $\cvar{i}$ the attacker can force the
program to execute the \texttt{then} branch. The first
instruction stores a secret value, $\cvar{key}$, normally into a secret array
$\cvar{secrets}$, but with the out-of-bounds index this
actually stores the secret at position $\cvar{0}$ of a public array $\cvar{a}$.
A subsequent and
seemingly innocuous in-bounds load from $\cvar{a[0]}$, where the secret
$\cvar{key}$ was already exfiltrated, then leaks its value to the attacker
via a subsequent timing observation ($\cifsnoelse{\cvar{x}}{ ... }$).
%
Since the $\cvar{a[0]}$ load is from (the in-bounds) index $\cvar{0}$, even
though speculation is detected, the aSLH masking of this load will be a no-op
and thus alone will not prevent this counterexample.

The solution is to define $\llbracket \cdot \rrbracket_{\mathit{wr}}$ in
\autoref{fig:saslh-instance} to mask the indexes of array stores when writing
secret values.
%
This extra masking causes the store operation in the example above
to write the $\cvar{key}$ in position $\cvar{0}$ of
$\cvar{secrets}$, leaving $\cvar{a}$ unchanged and thus preventing the attack.
% er from loading the secret key in the public variable $\cvar{x}$.
%
With this addition we were able to formally prove speculative constant-time security:
%% %
%% Without this masking, only masking indexes on read operations would allow
%% some programs to speculatively leak information, such as in \autoref{ex:aslh-vs-vslh}:

% \ld{How deeply should this be explained? Should the explanation from section 6
% be moved up here?}\rb{Done, split between the two}

%% These masks can be applied to either the memory \emph{addresses} being
%% accessed (called \SelectiveaSLH, \SelaSLH), or to the \emph{values}
%% that are the object of those accesses
%% (called \SelectivevSLH, \SelvSLH).
%% %
%% \rb{
%% The two can even be combined, like LLVM does.\ch{From your description
%%   that combination seemed extremely shady and most likely insecure.}
%% Note that the quote from the \SelSLH paper only talks about loads.}

%% \rb{
%% Contribution/key idea: Stores need to be masked.\ch{This can already be
%%   explained on standard (non-selective) aSLH, but for selective it gets even
%%   more interesting, which leads to a key idea of this paper.}
%% %
%% The ideal semantics in Spectre Declassified requires several fixes for the
%% security proof to go through.\ch{This is about vSLH, so not in this section}
%% We give a fully mechanized version of
%% the security property for the fixed presentation of \SelSLH.\ch{See contribution
%%   about selective aSLH; that should be the focus here, not fixing small, typo-level
%%   issues in Gilles' proof, which is a complete detour here and should be left for
%%   \autoref{sec:FvSLH}.}}

%% The performance costs incurred by \SLH transformations arise from
%% bookkeeping the misspeculation flag and masking memory accesses. The
%% first of these is unavoidable, but cryptographic software can exploit
%% its knowledge of which data are security-relevant to limit masking to
%% those accesses that involved secret data. This is the essence
%% of \SelectiveSLH (\SelSLH), which in its original proposal \ldots

%% \SelectiveSLH (\SelSLH) masks public memory loads and leaves secret
%% memory loads unchanged. It does nothing about branch
%% conditions. \rb{(The paper says nothing about stores, which we also
%% mask. Actually, \texttt{SpecCT} does \emph{not} mask stores; the
%% version of address \SelSLH implemented in \texttt{FlexSLH} does mask
%% stores.)}

% \rb{
% A bunch of notes commented, the one thing that is not mentioned at the
% moment is that the same applies to aSLH.} -- CH: It is mentioned at the end of 2.3

\begin{theorem}
\label{thm:saslh-ct}
\SelaSLH enforces SCT security for CCT programs.
\end{theorem}

\subsection{Defining Relative Security for \UltimateSLH}

Most programs do not satisfy the \CCT policy,
% or even have a clear notion of secret,
%\ch{warning:we require the latter for FSLH, so need to be careful here}
% standard aSLH gives us SCT but not for not CT programs, and this is enough motivation
so lightweight SLH transformations like the two aSLH variants
above are not enough to enforce security for arbitrary programs.

%% \ch{Gilles counterexample already here to justify this claim
%%   and properly motivate this subsection}

\begin{listing}[Leakage through sequentially unreachable code]\ifanon\else\footnote{This
  counterexample was shared with us by Gilles Barthe.}\fi
\label{ex:gilles-cex}
\[
  \cifsnoelse{\cvar{false}}{
  \cifsnoelse{\cvar{secret = 0}}{
  ...}}
\]
\end{listing}

The code in the outer \texttt{then} branch will never be
sequentially executed, but a speculative attacker can force the
execution of this code. The inner branch condition reveals
information about the $\cvar{secret}$ variable, and no amount of
masking of memory accesses can prevent this.
%
Since it branches on $\cvar{secret}$, this code is not CCT,
but this is the kind code we still want to protect from Spectre v1 attackers.
%
To achieve this
% in the absence of knowledge about which program data are sensitive, -- CH: see warning
all sources of speculative leakage observations must be
% treated as (potentially) sensitive themselves, and thus -- CH: see warning
masked, including branch conditions,
not only the addresses of memory loads and stores.

\UltimateSLH (\USLH)~\cite{PatrignaniG21, ZhangBCSY23}
is a \SLH variant that offers protection to
arbitrary programs by {\em exhaustively} masking these three sources of
leakage, as shown in \autoref{fig:uslh-instance}. Like
vanilla \aSLH, it masks all addresses of memory loads and stores.
%
Additionally, it also protects branch conditions by masking them with
the misspeculation flag. This causes branches to default to the false
case during misspeculation, preventing them from leaking information
about the original branch conditions. This prevents the
leakage in \autoref{ex:gilles-cex}.

Yet what is a suitable formal security definition for transformations protecting
arbitrary programs, like \USLH?
%
Because the arbitrary source program does not follow the CCT discipline it could
leak some data sequentially, and the transformations we look at here do not try
to prevent these sequential leaks.
%
Instead, defenses like \USLH enforce that the hardened program does not
leak any {\em more} information speculatively than the source program leaks
sequentially.
%
That is, if a sequential attacker against the source program cannot tell apart
two input states, the transformation ensures that a speculative attacker
cannot tell them apart either.
%
For formalizing this relative security notion we first also define a notion
of observationally equivalent configurations in the sequential semantics:

% Security results based on \autoref{def:sct-sec}
% and \autoref{def:rs-sec} revolve around two
% executions from a pair of initial states producing the same
% observations. In the sequential semantics a multi-step execution can
% stop at any point, either by terminating (\IE a full execution), by
% getting stuck or simply pausing in the middle of an unfinished run. We
% can express this by having either one of the traces of observations be
% a prefix of the other.
\begin{definition}[Sequential \ObsEq]
\label{def:seq-obseq}
Two source configurations $\langle c_1, s_1 \rangle$
and $\langle c_2, s_2 \rangle$ are observationally equivalent
in the sequential semantics, written $s_1 \approx s_2$, iff
%
\[
  \forall \Obss_1 \Obss_2.~
    \seqmultis{\langle c_1, s_1 \rangle}{\Obss_1}{\cdot} \mathrel{\land}
    \seqmultis{\langle c_2, s_2 \rangle}{\Obss_2}{\cdot} \Rightarrow
    \Obss_1 \lessgtr \Obss_2
\]

\end{definition}

Looking at all execution prefixes above can result in observation sequences of
different lengths, so we require that one sequence is a prefix of the other
($\Obss_1 \lessgtr \Obss_2$).

\begin{definition}[Relative Security]
%
\label{def:rs-sec}
%
A program transformation $\transl{\cdot}$ satisfies relative security
if for all programs $c$ run from two arbitrary initial states $s_1$ and $s_2$ we have
%
\begin{align*}
\langle c, s_1 \rangle \seqobseq \langle c, s_2 \rangle \Rightarrow
& \langle \transl{c}, s_1, \BoolFalse \rangle \specobseq \langle \transl{c}, s_2, \BoolFalse \rangle
%% \forall & p, s_1, s_2, D, O_1, O_2. \\
        % & ( \forall \Obss_1 \Obss_2.~ \langle c, s_1 \rangle \seqmulti{\Obss_1} \cdot \mathrel{\land} \langle c, s_2 \rangle \seqmulti{\Obss_2} \cdot \Rightarrow \Obss_1 \lessgtr \Obss_2 ) \Rightarrow \\
        % & \forall \Dirs \Obss_1 \Obss_2.~ \langle \transl{c}, s_1, \BoolFalse \rangle \specmulti{\Obss_1}{\Dirs} \cdot \mathrel{\land} \langle \transl{c}, s_2, \BoolFalse \rangle \specmulti{\Obss_2}{\Dirs} \cdot \Rightarrow \\
        % & \Obss_1 = \Obss_2
\end{align*}
%
\end{definition}

% One thing to note is that
Looking at all execution prefixes in the sequential observational equivalence
premise of this definition is not a choice, but is forced
on us by the fact that a program that sequentially loops forever or ends with an
error (\IE gets stuck before reaching $\cskip$) can be forced by attacker
directions to successfully terminate speculatively.
%
So if we were to only look at successfully terminating sequential executions
(like in \autoref{def:cct-sec}) in the premise, we would simply not have any
information about the sequentially nonterminating or erroneous executions, and
we would thus not be able to prove (even a big-step version of)
the conclusion when such programs only successfully terminate speculatively.

% Notice the relation between the sequential observation traces in the
% premise: one trace must always be a prefix of the other. Unlike
% in \autoref{def:cct-sec} the sequential runs are not necessarily full
% executions, and the could stop or get stuck early. Requiring the
% sequential observations to be equal is not enough to achieve relative
% security.\ch{the actual idea missing: looping and stuck programs}
%% \ch{Should properly explain why we need $\lessgtr$ in the premise.
%%   With equals the premise would be to weak to be able to achieve
%%   relative security.}

% \rb{
% Cover the bare minimum of notation to make this kind of presentation
% readable, or simplify further}\ch{+1; we claim this definition as a contribution,
%   so it needs to be properly explained}
% \rb{Notation seems enough now}

%% That is, the protected program does not leak more information
%% speculatively than the original program leaks sequentially.

Beyond these details,
the key idea is to relate the security of the
transformed program executed speculatively to the security of the {\em source}
program executed sequentially. This provides stronger guarantees than in
previous work~\cite{PatrignaniG21, ZhangBCSY23}, as discussed in
\autoref{sec:related-work}.
%
This definition also suitably captures the security guarantees offered by \USLH,
and later \FlexSLH.

%% The model of observations does not change w.r.t. CCT

%% \rb{Specifying and proving the security guarantees of \USLH.}

\begin{theorem}
\label{thm:uslh-rs}
\USLH enforces relative security for all programs.
\end{theorem}

%% Thm1/Thm2?

\iflater
\rb{
While providing comprehensive protections, \USLH is costlier
than \SelSLH (obviously). We can show this with an example, and
compare with \FlexSLH later, or use a single figure and color the
masks that are inserted in \USLH but are absent in \FlexSLH. Then lead
to presenting the relative security property satisfied by \USLH.}
\ch{Okay to explain this, but please don't do it from scratch. The intro already
  said that it has around 150\% overhead on SPEC; so please build on that.}
\rb{
Can do a bit of this if there is space, right now it does not seem
critical to do here, maybe in the discussion?}\ch{What discussion?
  (wasn't planning a discussion section)}
  \rb{Oops, I was thinking about mentioning performance in future work
      (LLVM implementations, etc.)}
\fi

\subsection{The Best of Both Worlds: Flexible aSLH}
\label{sec:FaSLH}

\SelaSLH and \USLH can be seen as falling on two
rather different points on the spectrum of Spectre v1 protections:

\begin{itemize}[leftmargin=*,nosep,label=$\blacktriangleright$]
\item \SelaSLH exploits information from the developer identifying which inputs
  are secret and which ones are not to implement an efficient countermeasure
  that under the very strong requirement that the source program is \CCT
  guarantees no leakage of secret inputs whatsoever.

\item \USLH pays a much higher efficiency price to protect arbitrary programs
  and obtain a stronger relative security guarantee that includes programs that
  are not \CCT.
\end{itemize}

In this paper we propose \emph{Flexible address SLH (\FlexaSLH)}, a new hybrid design
shown in \autoref{fig:faslh-instance} that combines the desirable
features of both \SelaSLH and \USLH:

\begin{itemize}[leftmargin=*,nosep,label=$\blacktriangleright$]

\item Like \SelaSLH, \FlexaSLH also exploits information from
  the developer identifying which program inputs are secret and which
  are not, and only offers speculative protections to data
  that could depend on secret inputs.
%
  Unlike \SelaSLH though, \FlexaSLH does not require the strict CCT discipline.

\item Like \USLH, \FlexaSLH aims to offer relative security to arbitrary
  programs, which in our current formalization are only well-typed with respect
  to a standard information flow control (IFC) type system tracking explicit and
  implicit flows~\cite{VolpanoIS96} (see \autoref{sec:type-system}).\footnote{As
    discussed in \autoref{sec:future-work}, replacing this IFC type system with
    a flow-sensitive IFC analysis accepting all programs should be
    possible in the future.}
%
  Unlike \USLH though, \FlexaSLH uses the information about which values may
  have been influenced by secret inputs and which ones not to only selectively
  apply SLH protections, as detailed below.
%
% Under the IFC discipline, public values really are public, but secret values are
% not a concern if they already leak sequentially.\ch{Unclear; this is actually about
%   speculation!  Too early for this anyway? It's not about the IFC discipline,
%   but about the relative security property}
%
% The same two variants are possible, depending on whether addresses or values are
% masked.\ch{This whole section should only be talking about aSLH though}
%
% It masks not only loads and stores, but also branch
% conditions, although it does so only when in the cases detailed below.
% they involve secret data.

\end{itemize}

%% \ch{Again, please use Figure 2 here as well!}

As shown in \autoref{fig:faslh-instance}, the treatment of branch
conditions is a hybrid between \USLH (whose unique contributions are
given in \colU{red}) and \SelaSLH (in \colSel{blue}), with some new
logic (in \colFlexnew{purple}).
%
When the branch condition is a secret expression, it behaves like \USLH, using
the misspeculation flag to mask the branch condition.
%
When the branch condition is public, it behaves like \SelaSLH, and leaves the
branch condition unchanged.

For array loads, while \USLH always masks the indices, \SelaSLH only masks
indices for loads that sequentially involve public data.
%
This is, however, not enough for relative security of non-\CCT programs: since
speculative stores leak the index, \FlexaSLH also has to mask secret indices
to prevent the following speculative leak (similar to \autoref{ex:gilles-cex} above).

\begin{listing}[Leakage through sequentially unreachable load]
\label{ex:gilles-cex-load}
\[
  \cifsnoelse{\cvar{false}}{
  \caread{\cvar{xsecret}}{\cvar{a}}{\cvar{isecret}}}
\]
\end{listing}

This is similar for array stores, while \USLH masks indices for all stores,
\SelaSLH only masks indices for stores if the expression being stored is secret.
%
This is again not enough for relative security of non-\CCT programs: since
stores leak the index, \FlexaSLH also masks secret indices of stores.

\begin{listing}[Leakage through sequentially unreachable store]
\label{ex:gilles-cex-store}
\[
  \cifsnoelse{\cvar{false}}{
  \cawrite{\cvar{a}}{\cvar{isecret}}{\cvar{epublic}}}
\]
\end{listing}

We have proved in Rocq that the masking done by \FlexaSLH is enough to enforce
the following variant of \autoref{def:rs-sec}:

\begin{theorem}
\label{thm:faslh-rs}
\FlexaSLH enforces relative security for all IFC-well-typed programs and for all
public-equivalent initial states.
\end{theorem}

The extra premise that the initial states are public-equivalent intuitively
captures the requirement that the developer has properly identified the secret
inputs they want to try to protect, since all other inputs will {\em not} be
protected by \FlexaSLH.
%
Perhaps a bit counterintuitively, because of the other, semantic equivalence premise
from \autoref{def:rs-sec}, an input labeled as secret is protected speculatively
by \FlexaSLH only if it does not leak sequentially.
%
This is the most one can achieve for non-\CCT programs, without heavier
defenses enforcing \CCT~\cite{CauligiSJBWRGBJ19}.

% \ch{We seem to be in an inconsistent state: up to now we never talked about PA,
%   while below we do. What should we do about this?}
% \rb{
% We can drop PA from here, the translations don't use it and it doesn't
% show up until we get to the IFC type system and the ideal semantics
% --- I believe I had removed PA at some point and then re-added it for
% some reason}

Finally, we proved in Rocq that \FlexaSLH is a generalization of \SelaSLH
and \USLH. The former means that CCT code pays no extra performance penalty
under \FlexaSLH compared to \SelaSLH:

\begin{theorem}[Connection between \FlexaSLH and \SelaSLH]
\label{thm:faslh-aslh}
For any \CCT program $c$ and public variable map $\PubVars$ we have
% and another of public arrays $\PubArrs$,
\[
\translAux{\cexpr{c}}{\FlexaSLH}{\PubVars} = \translAux{\cexpr{c}}{\SelaSLH}{\PubVars}
\]
\end{theorem}

\begin{proof}[Proof intuition]
By inspection of \autoref{fig:saslh-instance}
and \autoref{fig:faslh-instance}.
\end{proof}

On the other hand, if all data is labeled as secret then the program receives
exactly the same protection as with USLH:

\begin{theorem}[Connection between \FlexaSLH and \USLH]
\label{thm:faslh-uslh}
If all variables (both scalars and arrays) are labeled as
secret (\IE we use public map $(\lambda \_. \LabelSecret)$),
then for any program $c$ we have
\[
\translAux{\cexpr{c}}{\FlexaSLH}{(\lambda \_. \LabelSecret)} % ; (\lambda \_. \LabelSecret)
= \translAux{\cexpr{c}}{\USLH}{}
\]
\end{theorem}

\begin{proof}[Proof intuition]
By inspection of \autoref{fig:faslh-instance}
and \autoref{fig:uslh-instance}.
\end{proof}

\iflater
\rb{Examples: w.r.t USLH, show how if something is secret everything becomes full of masks, but if some things are public then checks disappear. A notion of overprotection}
\fi
% The theorem in this part is almost the same, focus on what comes from where

% Marking inputs as secret (exactly the same, maybe show for SelSLH + theorem
% there too)\ch{Started talking about this, but we didn't yet introduce $\PubVars$
%   and $\PubArrs$ yet, did we?}\rb{Now P is mentioned above, and PA by analogy in Th.4 should work, it doesn't show up before}

% % CH: Starting to wonder if this distinction between
% %     vars and arrs is overly pedantic for the paper; it is helpful for starting
% %     autoref\{thm:faslh-uslh}, so maybe fine

% % Keeping track of how secrets leak... \CCT vs. IFC (no details here) -- CH: what's above now already okay

% % No strong \CCT requirement. Right now we use IFC, but it could be something else, notably with an eye towards allowing all programs, -- CH: added
% % Maybe mention testing and flow-sensitive IFC analysis -- CH: referenced/added 

% If IFC, public means public, and secret means maybe but if there is a sequential leak, then it is OK\ch{+1, right this one is important}\rb{Added}


\section{Definitions}
\label{sec:defs}

\subsection{Language Syntax and Sequential Semantics}
\label{sec:defs-syntax-seq-semantics}

Throughout the paper we use a simple while language
with arrays we call \SourceLang. Its syntax is shown
in \autoref{fig:syntax}. A first layer comprises pure arithmetic
expressions (\texttt{aexp}) on natural numbers (which we also write
$\cexpr{ae}$, or $\cexpr{ie}$ if they compute array indexes), and
boolean expressions (\texttt{bexp}) (also written $\cexpr{be}$). The
second layer of commands (\texttt{com}) includes standard imperative
constructs, as well as array accesses.

\begin{figure}
  \centering
  \[
  \begin{aligned}
    \cexpr{e} \in\texttt{aexp} ::=& ~ \cexpr{n}\in\mathbb{N} && \text{number}\\
    |& ~ \texttt{X} \in \mathcal{V}&&\text{scalar variable}\\
    |& ~ \mathrm{op}_{\mathbb{N}}(\cexpr{e}, \ldots, \cexpr{e})&&\text{arithmetic operator}\\
    |& ~ \ccond{\cexpr{b}}{\cexpr{e}}{\cexpr{e}} &&\text{constant-time conditional}\\
%    \\
    \cexpr{b}\in\texttt{bexp} ::=& ~ \BoolTrue ~|~\BoolFalse && \text{boolean}\\
    |&~ \mathrm{cmp}(\cexpr{e}, \cexpr{e})&&\text{arithmetic comparison}\\
    |&~ \mathrm{op}_{\mathbb{B}}(\cexpr{b},\ldots, \cexpr{b})&&\text{boolean operator}\\
%    \\
    \cexpr{c}\in\texttt{com} ::=&~ \cskip &&\text{do nothing}\\
    |&~\casgn{\cvar{X}}{\cexpr{e}}&&\text{assignment}\\
    |&~\cseq{\cexpr{c}}{\cexpr{c}}&&\text{sequence}\\
    |&~\cifs{\cexpr{b}}{\cexpr{c}}{\cexpr{c}}&&\text{conditional}\\
    |&~\cwhiles{\cexpr{b}}{\cexpr{c}}&&\text{loop}\\
    |&~\caread{\cvar{X}}{\cvar{a}}{\cexpr{e}}&&\text{read from array}\\%\text{load from array }\cvar{a}\text{ at index }\cexpr{ie}\\
    |&~\cawrite{\cvar{a}}{\cexpr{e}}{\cexpr{e}}&&\text{write to array}%&&\text{store to array }\cvar{a}\text{ at index }\cexpr{ie}
  \end{aligned}
  \]
  \caption{Language syntax}
  \label{fig:syntax}
\end{figure}

Program states are divided into scalar variables
$\cvar{X}, \cvar{Y}, \ldots \in \mathcal{V}$ and arrays
$\cvar{a}, \cvar{b}, \ldots \in \mathcal{A}$. A register file
$\ScalarState$ assigns
values to scalar variables. This mapping is used to evaluate
arithmetic and boolean expressions involving scalar variables in the
usual way, written $\llbracket \cdot \rrbracket_{\rho}$. To update the
value of a variable in the mapping we write
$\subst{\cvar{X}}{v}{\rho}$.
%
The second half of the program state is a main memory
%% \ld{Why quote it? If it's the way we call it, why not use $\backslash$emph?}
%% \rb{I wanted to avoid too close a correspondence with low level
%% but I think it's fine to remove the quotes}
$\ArrayState$ that stores the
arrays. The mapping assigns a fixed size $| \cvar{a} |_{\mu}$ to each
array, and defines a lookup function $\eval{\cvar{a}[i]}{\mu}$ to
fetch the value of an array at a given valid index, \IE in the range
$[0, | \cvar{a} |_{\mu})$. To update the value of an array at a valid
index we write $\subst{\cvar{a}[i]}{v}{\mu}$.
%
The contents of an array cannot be used directly in arithmetic or
boolean expressions, and can only be transferred to and from scalar
variables through the read and write commands.

%% \rb{
%% Consistent notation: $n$ vs $v$ for (natural) values, $i$ vs $ie$ for
%% natural indexes vs index expressions?}\ch{Forcing consistency can
%%   make things worse; like forcing someone to call all variables x}

We define a standard small-step operational semantics for \SourceLang
(for details, see \autoref{sec:spec-semantics} later
and also \autoref{sec:appendix-sequential-semantics}).
%% using the
%% step relation shown in \autoref{fig:seq-semantics}.
States are triples
composed of the next command to execute, and the scalar and array
states. We write the step
$\seqstate{\cexpr{c}}{\rho}{\mu} \seqstep{o} \seqstate{\cexpr{c'}}{\rho'}{\mu'}$
%% \ld{for a step in those semantics},
or $\seqstate{\cexpr{c}}{\rho}{\mu} \seqstep{o} \cdot$ if we do not
care about the state after stepping.
%% An assignment command updates the
%% mapping of a variable to a new value, written
%% $\subst{\cvar{X}}{v}{\rho}$, and an array write updates the mapping of
%% a valid index of an array to a new value, written
%% $\subst{\cvar{a}[i]}{v}{\mu}$. In both cases, those values are the
%% result of evaluating an arithmetic expression.
%
A step produces an optional \emph{observation}
$o \in \mathit{Option}(\mathit{Obs})$ that represents the passive
capabilities of an attacker to obtain information about the program via
side channels. We use the standard model for sequential side-channel
attackers, which observes the control flow followed by program
($\branch{b}$ for a branch condition that evaluates to a boolean $b$)
and the accessed memory addresses ($\OARead{\cvar{a}}{i}$ and
$\OAWrite{\cvar{a}}{i}$ resp. for array reads and writes at
$\cvar{a[i]}$). If a step does not produce an observation, we write
$\bullet$ instead of a concrete event.
% \rb{Note that memory observations leak the ``address'' of the access but
%     do not directly show the value read or written.}
%     CH: made this standard fact obvious in the phrasing above
%
%% This is the standard threat model for sequential side channel
%% attackers.
%
Multi-step execution is the reflexive and transitive closure of the
step relation, written $\seqmulti{\Obss}$, where
$\Obss \in \mathit{List}(\mathit{Obs})$ is a trace of events.
% observe that -- CH: nowhere to look for it
In our formalization silent steps leave no mark in the trace.
%
Full executions are multi-step executions of the form
$\seqstate{\cexpr{c}}{\rho}{\mu} \seqmulti{\Obss} \seqstate{\cskip}{\rho'}{\mu'}$.

It is important to note that evaluating arithmetic and boolean
expressions does not produce any observable event, even though there
is a strong resemblance between the conditional expression
$\ccond{\cexpr{be}}{\cexpr{e_1}}{\cexpr{e_2}}$ and the conditional
command $\cifs{\cexpr{be}}{\cexpr{c_1}}{\cexpr{c_2}}$.
% \ld{This command is not syntactically correct though... Maybe something like $\cifs{\cexpr{be}}{\casgn{\cvar{x}}{\cexpr{e_1}}}{\casgn{\cvar{x}}{\cexpr{e_2}}}$?}
Internally, this imposes the use of branchless and unpredicted logic to implement
$\ccond{\cexpr{be}}{\cexpr{e_1}}{\cexpr{e_2}}$, and is critical to the
correctness of our \SLH countermeasures.
% in \autoref{sec:formal-results}. -- CH: also in Key ideas

%% We define a simple while language with arrays in \autoref{fig:syntax}. We write $\cexpr{ae}$ for arithmetic expressions and $\cexpr{ie}$ in case they
%% are used as indexes. We also write $\cexpr{be}\in\mathcal{B}$ for boolean expressions, $\cvar{X},\cvar{Y}\in\mathcal{X}$ for registers and $\cvar{a}\in\mathcal{A}$ for arrays.
%% The size of an array $\cvar{a}$ is denoted by $\size{\cvar{a}}$ and does not change during the execution of a program.
%% Most notably, this language supports unpredicted conditional expressions, meaning that there will never be
%% speculation on these arithmetic expressions, as opposed to conditional commands. This feature is essential for each of
%% the \SLH variants to work correctly.

\begin{example}
\label{ex:v1std-formal}

Let us revisit \autoref{ex:v1std} using this formal model. There are
only two ways to fully evaluate that code under the sequential
semantics. Without loss of generality, suppose $\mu$ contains the
4-element array $\cvar{a}_1 = [0; 7; 1; 2]$ and another large array
$\cvar{a}_2$, say of size 1000. Suppose also that
$\lookup{\rho}{\cvar{a$_1$\_size}} = 4$.
% cache lines are of size 8, and $\rho$ stores this value in
% $\cvar{CACHE\_LINE\_SIZE}$,\ch{this seems completely irrelevant here}
%
Then, depending on the prospective index on $\cvar{a}_1$ given by
$\cvar{i}$:

%% of size at least $29$

%% cache lines
%% are of size 4, $\mu$ contains the $4$-element array $\cvar{a} = [0;
%% 7; 1; 2]$ and another array $\cvar{b}$ of size at least $29$ (the
%% largest $0$-based index in $\cvar{a}$ is $7$, times the cache line
%% size for accesses on $\cvar{b}$), and $\rho$ correctly reflects the
%% sizes of $\cvar{a}$ and the cache lines, so
%% $\eval{\cvar{A$_1$\_SIZE}}{\rho} = 4$ and
%% $\eval{\cvar{CACHE\_LINE\_SIZE}}{\rho} = 4$. Then:

\begin{enumerate}
\item
If the access is valid, \EG $\lookup{\rho}{\cvar{i}} = 1$, the
conditional produces an observation $\branch{\BoolTrue}$, and
afterwards the \texttt{then} branch executes, emitting two % additional
observations:
% \ld{ (one for each read operation) }
$\OARead{\cvar{a}_1}{1}$ and $\OARead{\cvar{a}_2}{7}$ (the
largest element in $\cvar{a}_1$ is 7, so all accesses on $\cvar{a}_2$
based on the contents of $\cvar{a}_1$ will be valid).
\item
If the access is not valid, \EG $\lookup{\rho}{\cvar{i}} = 4$, the
conditional produces an observation $\branch{\BoolFalse}$, and the
program terminates without any additional observations.
\end{enumerate}

We can see that under these conditions the code is sequentially
secure, \IE out of bounds accesses cannot occur.
%
If we have a pair of states $\ScalarState_1, \ScalarState_2$ that
agree on the attacker-supplied value of $\cvar{i}$ (and the program
data, as described above), then the premise
of \autoref{def:rs-sec} is also satisfied.
\end{example}

\subsection{Speculative Semantics}
\label{sec:spec-semantics}

The observations produced by executions in the sequential
semantics allow us to reason about leakage that follows necessarily
from the intended control flow and memory access patterns of the
program. This is enough for properties like CCT in the standard
leakage model, where the attacker is passive.
%% and cannot indirectly
%% influence program execution.
%
However, a speculative attacker is able to actively influence the
program by causing it to veer outside the paths prescribed by the
sequential semantics,
%% through manipulation of microarchitectural elements.
% like the branch predictor in the case of a Spectre v1 attacker
and these transient paths empower the attacker
%% These active capabilities have transient but observable effects on
%% microarchitectural state
to make additional observations about the state of the program.
%
To model these more powerful attackers, we use a speculative
semantics \cite{ShivakumarBBCCGOSSY23} that reflects these active
capabilities, shown in \autoref{fig:spec-semantics}. (This is a strict
extension of the sequential semantics, which we recover by removing
the additions highlighted in \colHighlight{red}.)

% RB: If we need space, we can use the figure below and remove the
% sequential semantics or relocate it to an appendix, one could also
% highlight what changes between Spec_If and Spec_If_Force, and so on

\begin{figure}
  \centering
  \[
  \infer[Spec\_Asgn]
  {v = \eval{\cexpr{ae}}{\rho}}
  {\SpecEval{\casgn{\cvar{X}}{\cexpr{ae}}}{\cexpr{\rho}}{\cexpr{\mu}}{\highlight{b}}{\cskip}
   {\subst{\cvar{X}}{v}{\rho}}
   {\cexpr{\mu}}{\highlight{b}}{\bullet}{\highlight{\bullet}}}
  \]\[
  \infer[Spec\_Seq\_Step]
  {\SpecEval{\cexpr{c_1}}{\rho}{\mu}{\highlight{b}}{\cexpr{c_1'}}{\rho'}{\mu'}{\highlight{b'}}{o}{\highlight{d}}}
  {\SpecEval{\cseq{\cexpr{c_1}}{\cexpr{c_2}}}{\rho}{\mu}{\highlight{b}}{\cseq{\cexpr{c_1'}}{\cexpr{c_2}}}{\rho'}{\mu'}{\highlight{b'}}{o}{\highlight{d}}}
  \]
  \[
  \infer[Spec\_While]
  {\cexpr{c_{while}} = \cwhiles{\cexpr{be}}{\cexpr{c}}}
  {\SpecEval{\cexpr{c_{while}}}{\rho}{\mu}{\highlight{b}}{\cifs{\cexpr{be}}{\cseq{\cexpr{c}}{\cexpr{c_{while}}}}{\cskip}}{\rho}{\mu}{\highlight{b}}{\bullet}{\highlight{\bullet}}}
  \]\[
  \infer[Spec\_Seq\_Skip]
  {\phantom{\quad}}
  {\SpecEval{\cseq{\cskip}{\cexpr{c}}}{\rho}{\mu}{\highlight{b}}{\cexpr{c}}{\rho}{\mu}{\highlight{b}}{\bullet}{\highlight{\bullet}}}
  \]
  \[
  \infer[Spec\_If]
  {b' = \eval{\cexpr{be}}{\rho}}
  {\SpecEval{\cifs{\cexpr{be}}{\cexpr{c_\BoolTrue}}{\cexpr{c_\BoolFalse}}}{\rho}{\mu}{\highlight{b}}{\cexpr{c}_{b'}}{\rho}{\mu}{\highlight{b}}{\branch{b'}}{\highlight{\step}}}
  \]\[
\highlight{
  \infer[Spec\_If\_Force]
  {b' = \eval{\cexpr{be}}{\rho}}
  {\SpecEval{\cifs{\cexpr{be}}{\cexpr{c_\BoolTrue}}{\cexpr{c_\BoolFalse}}}{\rho}{\mu}{b}{\cexpr{c}_{\neg b'}}{\rho}{\mu}{\BoolTrue}{\branch{b'}}{\force}}
}
  \]
  % RB: These pairs of rules may read better one above the other
  \[
  \infer[Spec\_Read]
  {i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cvar{a}[i]}{\mu} \\
   i < | \cvar{a} |_{\mu}
  }
  {\SpecEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{\highlight{b}}{\cskip}
   {\subst{\cvar{X}}{v}{\rho}}
   {\mu}{\highlight{b}}{\OARead{\cvar{a}}{i}}{\highlight{\step}}}
  \]\[
\highlight{
  \infer[Spec\_Read\_Force]
  {i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cvar{b}[j]}{\mu} \\
   i \ge | \cvar{a} |_{\mu} \\
   j < | \cvar{b} |_{\mu}
  }
% TODO: Vertical spacing above/below arrows, typeface, array map update and lookup syntax
  {\SpecEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{\BoolTrue}{\cskip}
   {\subst{\cvar{X}}{v}{\rho}}
   {\mu}{\BoolTrue}{\OARead{\cvar{a}}{i}}{\DLoad{\cvar{b}}{j}}}
}
  \]
  \[
  \infer[Spec\_Write]
  {i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cexpr{ae}}{\rho} \\
   i < | \cvar{a} |_{\mu}
  }
  {\SpecEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{\highlight{b}}{\cskip}{\rho}
   {\subst{\cvar{a}[i]}{v}{\mu}}
   {\highlight{b}}{\OAWrite{\cvar{a}}{i}}{\highlight{\step}}}
  \]\[
\highlight{
  \infer[Spec\_Write\_Force]
  {i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cexpr{ae}}{\rho} \\
   i \ge | \cvar{a} |_{\mu} \\
   j < | \cvar{b} |_{\mu}
  }
  {\SpecEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{\BoolTrue}{\cskip}{\rho}
   {\subst{\cvar{b}[j]}{v}{\mu}}
   {\BoolTrue}{\OAWrite{\cvar{a}}{i}}{\DStore{\cvar{b}}{j}}}
}
  \]
  \caption{Speculative semantics}
  \label{fig:spec-semantics}
\end{figure}

%% % TODO: Directions, formatting, review
%% % TODO: Here and in other figures/theorems, use consistent map substitution notation (\subst vs. ?)
%% \begin{figure*}
%%   \centering
%%   \[
%%   \infer[Spec\_Asgn]
%%   {v = \eval{\cexpr{ae}}{\rho}}
%%   {\SpecEval{\casgn{\cvar{X}}{\cexpr{ae}}}{\cexpr{\rho}}{\cexpr{\mu}}{b}{\cskip}
%%    {\subst{\cvar{X}}{v}{\rho}}
%%    {\cexpr{\mu}}{b}{\bullet}{\bullet}}
%%   \quad
%%   \infer[Spec\_Seq\_Step]
%%   {\SpecEval{\cexpr{c_1}}{\rho}{\mu}{b}{\cexpr{c_1'}}{\rho'}{\mu'}{b'}{o}{d}}
%%   {\SpecEval{\cseq{\cexpr{c_1}}{\cexpr{c_2}}}{\rho}{\mu}{b}{\cseq{\cexpr{c_1'}}{\cexpr{c_2}}}{\rho'}{\mu'}{b'}{o}{d}}
%%   \]
%%   \[
%%   \infer[Spec\_While]
%%   {\cexpr{c_{while}} = \cwhiles{\cexpr{be}}{\cexpr{c}}}
%%   {\SpecEval{\cexpr{c_{while}}}{\rho}{\mu}{b}{\cifs{\cexpr{be}}{\cseq{\cexpr{c}}{\cexpr{c_{while}}}}{\cskip}}{\rho}{\mu}{b}{\bullet}{\bullet}}
%%   \quad
%%   \infer[Spec\_Seq\_Skip]
%%   {\phantom{\quad}}
%%   {\SpecEval{\cseq{\cskip}{\cexpr{c}}}{\rho}{\mu}{b}{\cexpr{c}}{\rho}{\mu}{b}{\bullet}{\bullet}}
%%   \]
%%   \[
%%   \infer[Spec\_If]
%%   {b' = \eval{\cexpr{be}}{\rho}}
%%   {\SpecEval{\cifs{\cexpr{be}}{\cexpr{c_\BoolTrue}}{\cexpr{c_\BoolFalse}}}{\rho}{\mu}{b}{\cexpr{c}_{b'}}{\rho}{\mu}{b}{\branch{b'}}{\step}}
%%   \quad
%%   \infer[Spec\_If\_Force]
%%   {b' = \eval{\cexpr{be}}{\rho}}
%%   {\SpecEval{\cifs{\cexpr{be}}{\cexpr{c_\BoolTrue}}{\cexpr{c_\BoolFalse}}}{\rho}{\mu}{b}{\cexpr{c}_{\neg b'}}{\rho}{\mu}{\BoolTrue}{\branch{b'}}{\force}}
%%   \]
%%   % RB: These pairs of rules may read better one above the other
%%   \[
%%   \infer[Spec\_Read]
%%   {i = \eval{\cexpr{ie}}{\rho} \\
%%    v = \eval{\cvar{a}[i]}{\mu} \\
%%    i < | \cvar{a} |_{\mu}
%%   }
%%   {\SpecEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{b}{\cskip}
%%    {\subst{\cvar{X}}{v}{\rho}}
%%    {\mu}{b}{\OARead{\cvar{a}}{i}}{\step}}
%%   \quad
%%   \infer[Spec\_Read\_Force]
%%   {i = \eval{\cexpr{ie}}{\rho} \\
%%    v = \eval{\cvar{b}[j]}{\mu} \\
%%    i \ge | \cvar{a} |_{\mu} \\
%%    j < | \cvar{b} |_{\mu}
%%   }
%% % TODO: Vertical spacing above/below arrows, typeface, array map update and lookup syntax
%%   {\SpecEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{\BoolTrue}{\cskip}
%%    {\subst{\cvar{X}}{v}{\rho}}
%%    {\mu}{\BoolTrue}{\OARead{\cvar{a}}{i}}{\DLoad{\cvar{b}}{j}}}
%%   \]
%%   \[
%%   \infer[Spec\_Write]
%%   {i = \eval{\cexpr{ie}}{\rho} \\
%%    v = \eval{\cexpr{ae}}{\rho} \\
%%    i < | \cvar{a} |_{\mu}
%%   }
%%   {\SpecEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{b}{\cskip}{\rho}
%%    {\subst{\cvar{a}[i]}{v}{\mu}}
%%    {b}{\OAWrite{\cvar{a}}{i}}{\step}}
%%   \quad
%%   \infer[Spec\_Write\_Force]
%%   {i = \eval{\cexpr{ie}}{\rho} \\
%%    v = \eval{\cexpr{ae}}{\rho} \\
%%    i \ge | \cvar{a} |_{\mu} \\
%%    j < | \cvar{b} |_{\mu}
%%   }
%%   {\SpecEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{\BoolTrue}{\cskip}{\rho}
%%    {\subst{\cvar{b}[j]}{v}{\mu}}
%%    {\BoolTrue}{\OAWrite{\cvar{a}}{i}}{\DStore{\cvar{b}}{j}}}
%%   \]
%%   \caption{Speculative semantics}
%%   \label{fig:spec-semantics}
%% \end{figure*}

The small-step relation
$\specstate{\cexpr{c}}{\rho}{\mu}{b} \specstep{o}{d} \specstate{\cexpr{c}'}{\rho'}{\mu'}{b'}$
is a generalization of the sequential relation that extends it in two
ways. The first change is the addition of an optional speculation
directive $d \in \mathit{Option}(\mathit{Dir})$ that abstracts the
active capabilities of the attacker to steer an execution down a
specific speculative path. Each observation-producing rule in the
sequential semantics is split into two speculative variants. The first
variant behaves exactly like its sequential counterpart, and does so
when the attacker gives the green light with the directive
$\step$. The second variant misspeculates, executing a branch that
should not be taken (when issuing directive $\force$ for
conditionals), or performing an arbitrary array access (when issuing
directives $\DLoad{\cvar{a}}{i}$ and $\DStore{\cvar{a}}{i}$ resp. for
reads and writes).
Note the initial speculation flag in
\textsc{Spec\_Read\_Force} and \textsc{Spec\_Write\_Force}:
the attacker can only cause misspeculation on array accesses after having forced a
branch misprediction, and only when it manages to force an
out-of-bounds access. In this case, we conservatively give the
attacker choice over the resulting access.
This overapproximate the speculative capabilities of a Spectre v1 attacker.
Again, we write $\bullet$ when no directive is needed.

The second change is the extension of program states with a fourth
component, a boolean flag $b$ that indicates whether the program has
diverged from its sequential execution. The flag is set to
$\BoolFalse$ at the start of the execution, and updated to $\BoolTrue$
when the attacker forces a branch misprediction.

Again, we write $\specmulti{\Obss}{\Dirs}$ for multi-step execution,
where $\Dirs$ is the sequence of speculative directives selected by
the attacker.
%
Because our security definitions quantify over all possible execution
paths, the speculative semantics does not need to model implementation
details like finite speculation windows or rollback
\cite{ShivakumarBBCCGOSSY23}, as also discussed in \autoref{sec:related-work}.

%% we will quantify over all linear speculative executions, we will not
%% need to model implementation details like speculation windows and
%% rollback, and once misspeculation occurs it remains in place for the
%% rest of the run.

%% With these two semantics we will be able to reason about
%% transformations like \SLH, where the goal will be to guarantee that
%% all speculative leaks are also sequential, \IE that the speculative
%% attacker cannot observe more than its sequential counterpart.

\begin{example}

Using the sequential and speculative semantics for \SourceLang, we can
show that \autoref{ex:v1std} without protections is not relative secure,
\IE does not satisfy \autoref{def:rs-sec}.
% \ld{I don't understand -- is the example supposed to prove the property?}

Assume the scalar variables $\cvar{i}$ and $\cvar{a$_1$\_size}$ and
the arrays $\cvar{a}_1$ and $\cvar{a}_2$ are public, and all other
data is secret. As we have seen in \autoref{ex:v1std-formal}, the
program satisfies \autoref{def:cct-sec}, and therefore for any pair of
public-equivalent states also \autoref{def:seq-obseq}.
%
%% Consider the family of states that agree on the data used to
%% execute \autoref{ex:v1std}. We relate a pair of scalar states
%% $\rho_1 \sim \rho_2$ iff $\eval{\cvar{a$_1$\_size}}{\rho_1}
%% = \eval{\cvar{a$_1$\_size}}{\rho_2}$
%% % , $\eval{\cvar{CACHE\_LINE\_SIZE}}{\rho_1}
%% % = \eval{\cvar{CACHE\_LINE\_SIZE}}{\rho_2}$
%% and
%% $\eval{\cvar{i}}{\rho_1} = \eval{\cvar{i}}{\rho_2}$, and a pair of
%% array states $\mu_1 \sim \mu_2$ iff $\eval{\cvar{a}_1[i]}{\mu_1}
%% = \eval{\cvar{a}_1[i]}{\mu_2}$ and $\eval{\cvar{a}_2[i]}{\mu_1}
%% = \eval{\cvar{a}_2[i]}{\mu_2}$ for any index $i$.\ch{All these
%%   seem just consequences of public-equivalence for a choice of
%%   public and secret variables/arrays, which is not even mentioned though.
%%   Seems strange and too low level.}
%
%% \rb{
%% For any pair of related states, we can establish the ``observational
%% equivalence'' precondition of relative security\ch{concrete reference
%%   to relative security definition needed}
%% (we should give this a name).}\ch{This is just a consequence of this program being CCT!}
%
But this does not mean that two executions from related states with
the same directives will yield identical observations.
%
Let us return to the second sample scenario in the last
example, where $\lookup{\rho}{\cvar{i}} = 4$ in an attempt to access
$\cvar{a}_1$ out of bounds.
%
Suppose that $\mu_1$ and $\mu_2$ are identical except for the fact
that $\mu_1$ contains a 1-element array $\cvar{a}_3 = [42]$, but in
$\mu_2$ we have $\cvar{a}_3 = [43]$.
%
The attacker can falsify the property as follows:

\begin{enumerate}
\item
Issue a directive $\force$ to speculatively begin executing the
instructions on the \texttt{then} branch, even though the condition is
actually false. This produces an observation $\branch{\BoolFalse}$ on
both runs and initiates a misspeculated path.
\item
The first read is an out of bounds access, so the attacker can choose
a directive $\DLoad{\cvar{a}_3}{0}$. This produces an observation
$\OARead{\cvar{a}_1}{4}$ on both runs. At this point the scalar states
differ: $\cvar{j}$ holds the secret 42 in $\rho_1$ and 43 in
$\rho_2$.
\item
The second read is allowed to proceed normally using % the directive
$\step$, but it is too late: this produces the observation
$\OARead{\cvar{a}_2}{42}$ on the first run and $\OARead{\cvar{a}_2}{43}$
on the second, which reveals the secret and violates the property.
\end{enumerate}

%% Returning to \autoref{ex:v1std}, we can see that program does not have
%% any sequential leaks: while we can infer the value of an in-bounds
%% member of the array $\cvar{a}$ from the address used to access
%% $\cvar{b}$, if $\cvar{a}$ is public we do not learn any sensitive
%% information from it. What happens in the speculative world?

%% %
%% Suppose again that $\eval{\cvar{I}}{\rho} = 4$, and that $\mu$ also
%% contains a secret array $\cvar{c} = [42; \ldots]$. Now the attacker
%% pre-trains the branch predictor to guess that the \texttt{then} branch
%% will be taken---even though it will not. In the speculative semantics,
%% this influence is abstracted by issuing the directive $\force$ to the
%% rule that evaluates the conditional instruction. The rule still
%% produces the observation $\branch{\BoolFalse}$, but the execution
%% proceeds as if the condition was true. The next instruction attempts
%% to read out of bounds during speculation, which conservatively allows
%% the attacker to read from an arbitrary address. It issues the
%% directive $\DLoad{\cvar{c}}{0}$, which loads the value $42$ in the
%% variable $\cvar{J}$ and emits the event
%% $\OARead{\cvar{a}}{5}$. Finally, the attacker allows the second read
%% to proceed normally by choosing the directive $\step$, and (assuming
%% the access to $\cvar{b}$ is within bounds) yields the observation
%% $\OARead{\cvar{b}}{42}$, which reveals the secret through the load
%% address.
%% %

% \rb{
% Reworked in terms of the security property instead of some vague
% notion of public and secret data,\ch{The security property of FSLH
%   should involve a formal notion of public and secret data though!
%   \rb{Done, and tried to address the other comments (some of these
%       are commented out now)}}
% and tried making it more stepwise.
% This attack is impossible in the sequential world, but materializes
% when speculation becomes available.}

\end{example}

%% The speculation flag would always be false in the sequential world

%% We define semantics for a speculative execution $\SpecEval{\cexpr{c}}{\rho}{\mu}{b}{\cexpr{c'}}{\rho'}{\mu'}{b}{O}{D}$ in figure
%% ~\ref{fig-spec-execution}.

\subsection{Simple IFC Type System}
\label{sec:type-system}

As mentioned in \autoref{sec:FaSLH}, our current implementation of flexible SLH
in Rocq make use of a simple IFC type system \emph{à la}
Volpano-Smith~\cite{VolpanoIS96} that tracks explicit and implicit flows in
\SourceLang programs (\autoref{fig:ifc-type-system}).
%
For this we make use of
%% two main technical devices that build on
a pair of maps that assign security labels to
scalar variables ($\PubVars: \mathcal{V} \rightarrow \mathcal{L}$) and
to array variables ($\PubArrs: \mathcal{A} \rightarrow \mathcal{L}$),
respectively. We consider the two-point lattice of booleans levels,
with $\LabelPublic$ for public and $\LabelSecret$ for public.
Since public may flow into the secret level we take
$\LabelPublic \sqsubseteq \LabelSecret$.
We lift the map of public variables $\PubVars$ to a pair of functions
$\labelbool{\PubVars}{\cexpr{be}}$ and
$\labelarith{\PubVars}{\cexpr{ae}}$ that compute the security levels of
arithmetic and boolean expressions in the usual way.
% CH: whatever, this is all standard
% It will be useful to establish noninterference properties based on
% these labels, such that from related states two program runs will be
% observationally equivalent.
% %% \rb{Give a good name to this, maybe in a
% %% definition?, then Gilles's lemma among other things becomes an
% %% instance of this property.}
% To relate states % in our semantics, -- CH: nonsense?
We define a standard public-equivalence relation
$\ScalarState_1 \sim_{\PubVars} \ScalarState_2$ that relates two scalar states
iff they agree on the public variables according to $\PubVars$ agree, and
similarly $\ArrayState_1 \sim_{\PubArrs} \ArrayState_2$ iff they agree on the
sizes and contents of the public arrays according to $\PubArrs$.

\begin{figure*}
\centering
\[
\infer[WT\_Skip]
{\quad}
{\PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \cskip}
\quad
\infer[WT\_Asgn]
{\labelarith{\PubVars}{\cexpr{a}} = \ell \quad
 \highlight{\mathpc \sqcup} \ell \sqsubseteq \PubVars(\cvar{X})}
{\PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \casgn{\cvar{X}}{\cvar{a}}}
\quad
\infer[WT\_Seq]
{\PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \cexpr{c_1} \quad
 \PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \cexpr{c_2}}
{\PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \cseq{\cexpr{c_1}}{\cexpr{c_2}}}
\quad
\infer[WT\_If]
{\labelbool{\PubVars}{\cexpr{be}} \highlight{ = \ell} \quad
 \PubVars; \PubArrs \vdash_{\highlight{\mathpc \sqcup \ell}} \cexpr{c_1} \quad
 \PubVars; \PubArrs \vdash_{\highlight{\mathpc \sqcup \ell}} \cexpr{c_2}}
{\PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \cif{\cexpr{be}}{\cexpr{c_1}}{\cexpr{c_2}}}
\]
\[
\infer[WT\_While]
{\labelbool{\PubVars}{\cexpr{be}} \highlight{ = \ell} \quad
 \PubVars; \PubArrs \vdash_{\highlight{\mathpc \sqcup \ell}} \cexpr{c}}
{\PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \cwhile{\cexpr{be}}{\cexpr{c}}}
\quad
\infer[WT\_ARead]
{\labelarith{\PubVars}{\cexpr{i}} \highlight{ = \ell_{\cexpr{i}}} \quad
 \highlight{\mathpc \sqcup \ell_{\cexpr{i}} \sqcup} \PubArrs(\cvar{a}) \sqsubseteq \PubVars(\cvar{X})}
{\PubVars; \PubArrs \vdash_{\highlight\mathpc} \caread{\cvar{X}}{\cvar{a}}{\cexpr{i}}}
\quad
\infer[WT\_AWrite]
{\labelarith{\PubVars}{\cexpr{i}} \highlight{ = \ell_{\cexpr{i}}} \quad
 \labelarith{\PubVars}{\cexpr{e}} = \ell \quad
 \highlight{\mathpc \sqcup \ell_{\cexpr{i}} \sqcup} \ell \sqsubseteq \PubArrs(\cvar{a})}
{\PubVars; \PubArrs \vdash_{\highlight{\mathpc}} \cawrite{\cvar{a}}{\cexpr{i}}{\cexpr{e}}}
\]
\caption{IFC type system used by \FlexibleSLH}
% TODO: Fix while language, labeling function notation
\label{fig:ifc-type-system}
\end{figure*}

We define the standard typing judgment
$\PubVars; \PubArrs \vdash_{\LabelPublic} \cexpr{c}$ using the rules from
\autoref{fig:ifc-type-system}.
%
This will ensure that command $\cexpr{c}$, run from two public-equivalent states
is secure, in the sense that it never produces any observations that leak secret data.

It will be interesting below that this type system generalizes the
type systems used for \CCT (\EG in \autoref{sec:specct}).
\autoref{fig:ifc-type-system} highlights
the extensions of our type system w.r.t. the corresponding \CCT type
system in \colHighlight{red}: implicit flows are tracked through the PC label, the
labels of branching conditions and memory addresses are no longer
required to be public, and joins are generalized to account for these
new labels and flows.

\rb{Show any preservation lemmas?}

%% \autoref{fig:ifc-type-system} shows the IFC type system. The
%% additions to the \CCT type system are highlighted: we need to keep
%% track of flows through the PC; the labels of the guards of if and
%% while commands, and of the indexes of reads and writes, are no longer
%% required to always be public; and join expressions generalize to
%% account for these new sources of flows.

\section{Formal Results}
\label{sec:formal-results}

The main goal of this section is to prove that \FlexaSLH enforces
relative security (\autoref{def:rs-sec}), and from there to derive
security results for other \SLH variants that are special cases of the
more general \FlexaSLH. 

\subsection{Ideal Semantics}

Similarly to \cite{ShivakumarBBCCGOSSY23}, a technical device used by
the security proofs is an auxiliary semantics that refines
the speculative semantics
from \autoref{fig:spec-semantics}. This \emph{ideal semantics}
introduces new restrictions which reflect the idealized behavior of
programs that are hardened against speculative leaks by \FlexaSLH.

%% In order to prove security of \FlexaSLH, we define intermediate semantics for commands,
%% which correspond to the behavior of the transformed code. These are referred to as \emph{ideal semantics}.
%% Small-step ideal semantics are written $\IdealEval{\cexpr{c}}{\rho}{\mu}{b}{\cexpr{c'}}{\rho'}{\mu'}{b'}{\Obss}{\Dirs}$, and are described in \autoref{fig:ideal-semantics-faslh}.
%% The goal is to be more restrictive than the speculative semantics --- which we do not have control on --- in order to obtain additional information in the proof of relative security.

% TODO: Directions, formatting, review
% TODO: Replace spec macros with new ideal ones (P, PA implicit?)
% TODO: Maybe make ie -> i to move closer to other figures? Assume N indexes, so no 0 <=?
% TODO: inference vs. infer
\begin{figure}
  \centering
  \[
  \infer[Ideal\_If]
  {\highlight{\labelbool{\PubVars}{\cexpr{be}} = \ell} \\
   b' = \highlight{(\lnot\ell \vee \neg b)} \mathrel{\highlight{\wedge}} \eval{\cexpr{be}}{\ScalarState}
  }
  {\IdealEval{\cifs{\cexpr{be}}{\cexpr{c_\BoolTrue}}{\cexpr{c_\BoolFalse}}}{\rho}{\mu}{b}{\cexpr{c_{b'}}}{\rho}{\mu}{b}{\branch{b'}}{\step}}
  \]\[
  \infer[Ideal\_If\_Force]
  {\highlight{\BoolLabel{\cexpr{be}} = \ell} \\
   b' = \highlight{(\lnot\ell \vee \neg b)} \mathrel{\highlight{\wedge}} \eval{\cexpr{be}}{\ScalarState}
  }
  {\IdealEval{\cifs{\cexpr{be}}{\cexpr{c_\BoolTrue}}{\cexpr{c_\BoolFalse}}}{\rho}{\mu}{b}{\cexpr{c_{\neg b'}}}{\rho}{\mu}{\BoolTrue}{\branch{b'}}{\force}}
  \]
  \[
  \infer[Ideal\_Read]
  {\highlight{\labelarith{\PubVars}{\cexpr{ie}} = \ell_{\cexpr{i}}} \\
   i = \highlight{
   \left\{
   {\begin{matrix*}[l]
    0 & \mathit{if} ~ (\lnot\ell_{\cexpr{i}} \vee \lookup{\PubVars}{\cvar{X}}) \wedge b \\
    \colAll{\eval{\cexpr{ie}}{\rho}} & \mathit{otherwise}
    \end{matrix*}
   }
   \right.
   }
   \\\\
   %% i = \highlight{(\ell_{\cexpr{i}} \vee \lnot\lookup{\PubVars}{\cvar{X}}) \wedge b ~ ? ~ 0 ~ : ~} \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cvar{a}[i]}{\mu} \\
   i < | \cvar{a} |_{\mu}
  }
  {\IdealEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{b}{\cskip}
   %% {\rho[\casgn{\cvar{X}}{\eval{\cvar{a}}{\mu}(i)}]}
   {\subst{\cvar{X}}{v}{\rho}}
   {\mu}{b}{\OARead{\cvar{a}}{i}}{\step}}
  \]\[
  \infer[Ideal\_Read\_Force]
  {\highlight{\labelarith{\PubVars}{\cexpr{ie}}} \\
   \highlight{\lnot\lookup{\PubVars}{\cvar{X}}} \\
   i = \eval{\cexpr{ie}}{\rho} \\\\
   v = \eval{\cvar{b}[j]}{\mu} \\
   i \ge | \cvar{a} |_{\mu} \\
   j < | \cvar{b} |_{\mu}
  }
  {\IdealEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{\BoolTrue}{\cskip}
   %% {\rho[\casgn{\cvar{X}}{\eval{\cvar{b}}{\mu}(j)}]}
   {\subst{\cvar{X}}{v}{\rho}}
   {\mu}{\BoolTrue}{\OARead{\cvar{a}}{i}}{\DLoad{\cvar{b}}{j}}}
  \]
  \[
  \infer[Ideal\_Write]
  {i = \highlight{
   \left\{
   {\begin{matrix*}[l]
    0 & \mathit{if} ~ (\lnot\ell_{\cexpr{i}} \vee \lnot\ell) \wedge b \\
    \colAll{\eval{\cexpr{ie}}{\rho}} & \mathit{otherwise}
    \end{matrix*}
   }
   \right.
   }
\\\\
   %% i = \highlight{(\ell_{\cexpr{i}} \vee \neg (\lnot\ell \vee \PubArrs = \lambda \_.\BoolTrue)) \wedge b ~ ? ~ 0 ~ : ~} \eval{\cexpr{ie}}{\rho} \\\\
   \highlight{\labelarith{\PubVars}{\cexpr{ie}} = \ell_{\cexpr{i}}} \\
   \highlight{\labelarith{\PubVars}{\cexpr{ae}} = \ell} \\
   v = \eval{\cexpr{ae}}{\rho} \\ % TODO: v -> n for consistency/ease?
   i < | \cvar{a} |_{\mu}
  }
  {\IdealEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{b}{\cskip}{\rho}
   %% {\mu[\casgn{\cvar{a}[i]}{v}]}
   {\subst{\cvar{a}[i]}{v}{\mu}}
   {b}{\OAWrite{\cvar{a}}{i}}{\step}}
  %% \]
  %% \[
  \]\[
  \infer[Ideal\_Write\_Force]
  {\highlight{\labelarith{\PubVars}{\cexpr{ie}}} \\
  %\highlight{\labelarith{\PubVars}{\cexpr{ae}} \vee \PubArrs = \lambda \_. \LabelSecret} \\\\
  \highlight{\labelarith{\PubVars}{\cexpr{ae}}} \\\\
   i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cexpr{ae}}{\rho} \\  % TODO: v -> n for consistency/ease?
   i \ge | \cvar{a} |_{\mu} \\
   j < | \cvar{b} |_{\mu}
  }
  {\IdealEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{\BoolTrue}{\cskip}{\rho}
   %% {\mu[\casgn{\cvar{b}[j]}{v}]}
   {\subst{\cvar{b}[j]}{v}{\mu}}
   {\BoolTrue}{\OAWrite{\cvar{a}}{i}}{\DStore{\cvar{b}}{j}}}
  \]
  \caption{Ideal semantics for \FlexaSLH}
  \label{fig:ideal-semantics-faslh}
\end{figure}

Again, we define the semantics as a small-step relation and write
$\PubVars \vdash \IdealEval{\cexpr{c}}{\rho}{\mu}{b}{\cexpr{c'}}{\rho'}{\mu'}{b'}{\Obss}{\Dirs}$.
The labeling map $\PubVars$ is constant throughout, so we
elide it and the turnstile from the relation, although we may refer
to it inside premises.
%
The speculative and the ideal semantics share the same collection of
rules. \autoref{fig:ideal-semantics-faslh} shows the subset of rules
that change from the speculative semantics, with additions highlighted
in \colHighlight{red}.

The changed rules are exactly the rules that generate observations,
and the changes are exclusively additions to premises.
%
The two rules for conditionals simply mask the branch condition so
that it defaults to the \texttt{else} branch in some cases.\rb{(which?)}
%
Similarly, the $\step$ rules for array loads and stores add conditions
under which the index (\IE the address) is masked instead of
evaluated, and in these cases defaults to the first element of the
array.
%
The misspeculating rules on array loads and stores only apply
under certain safe scenarios, and get stuck when these are not met.
%
Finally, multi-step executions $\idealmultiarrow{\Obss}{\Dirs}$ and ideal
observational equivalence $\approx_i$ are defined in precisely the
same way as their speculative counterparts.

%% The ideal semantics differ from the speculative semantics on the cases that generate observations. When the directions \step or \force are given, the changes very straightforwardly
%% apply the behavior of \FlexaSLH. In case of a misspeculation on an operation on arrays, we actually cause the program to get stuck in the ideal semantics when it doesn't fulfill
%% specific requirements.

\ch{This is currently {\em not} an example;
  if it stays this way can it be better integrated with the surrounding text?}
\begin{example}

The ideal semantics only allows misspeculating read on an array to
proceed if, in addition to forcing an out-of-bounds access as in the
speculative semantics, this access would load from a public address to
a secret variable.

A read operation on an array is only allowed to misspeculate if the index is public and if the result is stored to a secret variable. This comes from the fact that
allowing the operation leaks the index, so it has to be public or masked. Moreover, misspeculating allows the attacker to read from any array, even if the index is public.
For example, in \autoref{ex:v1std}, a read out of bounds after misspeculating in the branch allows the attacker to store basically any part of the memory in $\cvar{j}$, even when $\cvar{i}$ is public information.

\rb{A previous example does show this, add reference?}%
%
The way misspeculation on arrays is prevented is by masking the index to $\cvar{0}$ when the speculation flag is set to $\BoolTrue$. This ensures that reads always happen inside of bounds, so no misspeculation is possible.

\end{example}

The design of the ideal semantics restricts the speculative semantics
in such a way that it yields additional information for use in the
proofs that follow.

%% The goal is to be more restrictive than the speculative semantics --- which we do not have control on --- in order to obtain additional information in the proof of relative security.

%% Connection to the proofs

\subsection{Key Theorems}

There are several key lemmas used in our proof
of \autoref{thm:faslh-rs}. The first of these is a backwards compiler
correctness (BCC) result showing that the program hardened by \FlexaSLH executed with the
unrestricted speculative semantics behaves like the original source
program executed with the ideal semantics, \IE the \FlexaSLH translation
correctly implements the restrictions of the ideal semantics.
%
Despite their parallels, establishing the links between the two is
technically subtle. \rb{Do we want to mention loops here, from Léon's
comment?}

%% First, we prove that the \FlexaSLH transformation actually behaves
%% the way it is described in the ideal semantics. This may seem obvious since those are defined to fit the transformation, but it does require some work
%% because programs with infinite loops prevent an induction on the command from working.

\begin{lemma}[Backwards compiler correctness]
\label{lem:bcc}
%
\setcounter{equation}{0}
\begin{align}
 &(\forall \cvar{a}. | \cvar{a} |_{\ArrayState} > 0) \wedge
  \cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
  \lookup{\ScalarState}{\cvar{b}} = \natofbool{\SemSpecFlag}
 &\Rightarrow
 \label{eq:bcc-sideconds}
\\
 &\specstate{\transls{\cexpr{c}}{\FlexaSLH}}{\ScalarState}{\ArrayState}{\SemSpecFlag}
  \specmulti{\Obss}{\Dirs}
  \specstate{\cexpr{c'}}{\ScalarState'}{\ArrayState'}{\SemSpecFlag'}
 &\Rightarrow
 \label{eq:bcc-target}
\\
  % Below must be the ideal semantics!
 &\exists c''.
    \idealmulti
    {\specstate{\cexpr{c}}{\ScalarState}{\ArrayState}{\SemSpecFlag}}
    {\Obss}{\Dirs}
    {\specstate{\cexpr{c''}}{\subst{\cvar{b}}{\lookup{\ScalarState}{\cvar{b}}}{\ScalarState'}}{\ArrayState'}{\SemSpecFlag'}}
 &\wedge
  \label{eq:bcc-source}
\\
  % Strengthening, conjunction
 &\qquad
  (
    \cexpr{c'} = \cskip \Rightarrow
    \cexpr{c''} = \cskip \wedge
    \lookup{\ScalarState'}{\cvar{b}} = \natofbool{b'}
      %% \left\{
      %% \begin{matrix}
      %% 1 & \mathit{if} ~ b' \\
      %% 0 & \mathit{otherwise}
      %% \end{matrix}
      %% \right.
  )
  \label{eq:bcc-strenghtened}
\end{align}
\end{lemma}

\begin{proof}[Explanation and proof outline]

This lemma connects a ``target run'' of the hardened command
in \eqref{eq:bcc-target} to a ``source run'' of the original command
in \eqref{eq:bcc-source}. The initial configurations of both runs are
identical except for the translation function; the memories and the
speculation flag in the final states are also identical. Additionally,
it concludes in \eqref{eq:bcc-strenghtened} that terminating target
runs correspond to terminating source runs, and at this point the
values of speculation flag maintained by the program and the semantics
coincide.

The result holds under a number of side conditions detailed
in \eqref{eq:bcc-sideconds}. On the one hand, the original program
does not use the variable reserved for the speculation flag (this is
also why $\cvar{b}$ remains unchanged throughout the source run), and
its initial value is the same as the semantic flag $b$; the function
$\natofbool{\cdot}$ simply produces the natural encoding of the input
boolean.
%
On the other hand, we require all arrays to be non-empty, so that when
we mask an index to 0 this does not result in an out-of-bound access
that could be misspeculated upon.

The proof proceeds by induction on the number of steps in the target
run \eqref{eq:bcc-target}, followed by a case analysis on the
command. Note however that the number of steps cannot be inferred from
the size of either the observations or the directives due to the
presence of silent steps. Instead, we perform a strong induction on
$| \cexpr{c} | + | \Obss |$, where we add a measure of the program
defined simply as the number of its constructors. This compound
measure effectively bounds the number of steps taken by the
speculative semantics in the target run. Loops are handled by the size
of the trace of observations, as each iteration produces at least one
observation.
%
\end{proof}

%% This statement could be proved by induction on the number of steps taken. Since this is not tracked (silent steps do not produce any observation, so reasoning only on $\Obss$ doesn't work),
%% we define a measure on which we can then perform a strong induction. $\progSize{\cexpr{c}}{\Obss}:=\size{\cexpr{c}} + \size{\Obss}$, where $\size{\cexpr{c}}$ is defined by:

%% \begin{align*}
%%   \size{\cskip}&:=1\\
%%   \size{\casgn{\cvar{X}}{\cexpr{ae}}}&:=1\\
%%   \size{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}&:=1\\
%%   \size{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}&:=1\\
%%   \size{\cseq{\cexpr{c_1}}{\cexpr{c_2}}} &:=1+\size{\cexpr{c_1}} + \size{\cexpr{c_2}}\\
%%   \size{\cif{\cexpr{be}}{\cexpr{c_1}}{\cexpr{c_2}}}&:=1+\texttt{max}(\size{\cexpr{c_1}},\, \size{\cexpr{c_2}})\\
%%   \size{\cwhile{\cexpr{be}}{\cexpr{c}}}&:=1+\size{\cexpr{c}}\\
%% \end{align*}
%% Intuitively, $\progSize{\cexpr{c}}{\Obss}$ bounds the number of steps in the speculative semantics $\cexpr{c}$ is taking. Adding $\size{\Obss}$ allows to solve the issue of \emph{while} loops,
%% since this value decreases when going through the loop.
%% Once this notion is defined, an induction on $\progSize{\cexpr{c}}{\Obss}$ followed by a case analysis on $\cexpr{c}$ lets us prove the lemma.

%% The hypothesis $\forall \cvar{a}. | \cvar{a} |_{\ArrayState} > 0$ allows to make sure that masking indices in array operations is enough to prevent misspeculation from happening.
%% Without this assumption, reading from an empty array would always allow misspeculation, no matter how the index is masked. Removing this edge case should not be an issue in practice.

The standard formulation of BCC, without the additional conjuncts in
\eqref{eq:bcc-strenghtened}, is a trivial corollary.
%
%% \rb{Anything else to say about this lemma?}

An important property of the ideal semantics used in the lemmas that
follow allows us to relate the results of a pair of runs from related
states when they are given the same directives and produce the same
observations.
%
Here we show the single-step version, but we have generalized this to multi-steps
%
%% The following result enables the use of \autoref{lem:gilles-lemma} in the proof of relative security of the ideal semantics.
%% It is stated for single steps, but can be generalized to multiple steps in the ideal semantics
by ensuring that $\cexpr{c_1}$ and $\cexpr{c_2}$
cannot reduce without producing an observation.

\begin{lemma}[Noninterference of $\idealmultiarrow{}{}$]
  \label{lem:faslh-ideal-noninterference}
  \begin{align*}
    &\wtifc{\SemSpecFlag}{\cexpr{c}}\wedge \ScalarState_1 \sim_{\PubVars} \ScalarState_2\wedge
    \ArrayState_1 \sim_{\PubArrs} \ArrayState_2 &\Rightarrow\\
    &\IdealEval{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}{b}{\cexpr{c_1}}{\ScalarState_1'}{\ArrayState_1'}{b_1}{o}{d}&\Rightarrow\\
    &\IdealEval{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}{b}{\cexpr{c_2}}{\ScalarState_2'}{\ArrayState_2'}{b_2}{o}{d}&\Rightarrow\\
    &\cexpr{c_1} = \cexpr{c_2} \wedge b_1 = b_2 \wedge \ScalarState_1' \sim_{\PubVars} \ScalarState_2' \wedge \ArrayState_1' \sim_{\PubArrs} \ArrayState_2' &
  \end{align*}
\end{lemma}
\begin{proof}[Proof sketch]
  By induction on the first evaluation judgment and inversion on the second one.
\end{proof}

Another key technical result relates the behaviors of well-typed
programs running from public-equivalent but misspeculating states, still
in the ideal semantics~\cite{ZhangBCSY23}.
%~\cite[Lemma~5]{ShivakumarBBCCGOSSY23}. -- just the name!
%
\rb{Léon's comment, with some sharpening, could work better inside the proof proper:
``The idea is that since each branching operation containing a secret is masked, there is no way to obtain different observations after misspeculating based on publicly equivalent states.''
}

%% The next important lemma is about the behavior of transformed programs after misspeculation.

\begin{lemma}[Unwinding of ideal misspeculated executions]
\label{lem:gilles-lemma}
%
\setcounter{equation}{0}
\begin{align}
 &\wtifc{\LabelPublic}{\cexpr{c}} \wedge
  \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
  \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
 &\Rightarrow
 \label{eq:gilles-loweq}
\\
 &\specstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}{\BoolTrue}
  \approx_i
  \specstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}{\BoolTrue}
  \label{eq:gilles-goal}
%%  &\idealmulti
%%   {\specstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}{\BoolTrue}}
%%   {\Obss_1}{\Dirs}
%%   {\cdot}
%%  &\Rightarrow
%% \\
%%  &\idealmulti
%%   {\specstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}{\BoolTrue}}
%%   {\Obss_2}{\Dirs}
%%   {\cdot}
%%  &\Rightarrow
%% \\
%%  &\Obss_1 = \Obss_2
\end{align}
\end{lemma}

\begin{proof}

%% Note that the speculation bit being set to $\BoolTrue$ in the final states is optional, as this is the only value it can take.
%% This is because this bit track whether misspeculation has happened before, so taking steps cannot set it from $\BoolTrue$ to $\BoolFalse$.

The proof works by induction on one of the speculative executions
exposed after unfolding \eqref{eq:gilles-goal}.
%
The main auxiliary lemma is a stepwise version of this same statement
that takes one step in each execution with the same directive and
well-typed command, and again from public-equivalent states, and shows
that the two steps produce the same observation and reduction of the
command. This follows from the initial
hypothesis \eqref{eq:gilles-loweq}, \autoref{lem:faslh-ideal-noninterference}
and the fact that the step relation preserves well-typedness.
%
%% \rb{
%% Any explicit results about public-equivalence and types earlier, after
%% the semantics and type system? Around here,
%% multi\_ideal\_stuck\_noninterference might be interesting. -- Should be enough detail now}
%
%% The proof mainly relies on a stepwise lemma stating that performing one step from $\cexpr{c}$ with the same directions in publicly equivalent states
%% not only produces the same observations, but also reduces $\cexpr{c}$ to the same command. We then conclude by stating that the preconditions $\wtifc{\LabelPublic}{\cexpr{c}}$,
%% $\ScalarState_1 \sim_{\PubVars} \ScalarState_2$ and $\ArrayState_1 \sim_{\PubArrs} \ArrayState_2$ are preserved by taking steps.
\end{proof}

The final piece of the puzzle requires showing that the ideal
semantics satisfies relative security by itself, without the need for
any hardening.
%% \rb{We could reuse the full definition using the
%% identity function as translation.}

%% The last big step before proving relative security of \FlexaSLH is to show the relative security of the ideal semantics.

\begin{lemma}[$\idealmultiarrow{}{}$ ensures relative security]
\label{lem:faslh-ideal-rs}
%
\setcounter{equation}{0}
\begin{align}
 &\wtifc{\LabelPublic}{\cexpr{c}} \wedge
  \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
  \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
 &\Rightarrow
  \label{eq:faslh-ideal-loweq}
\\
 &\seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}
  \approx
  \seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}
 %% &( \forall \Obss_1 \Obss_2.
 %%   \\
 %%   &\quad
 %%    \seqmultis{\seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}}{\Obss_1}{\cdot}
 %%    \Rightarrow
 %%    \seqmultis{\seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}}{\Obss_2}{\cdot}
 %%    \Rightarrow
 %%    \Obss_1 \lessgtr \Obss_2
 %%  )
 &\Rightarrow
  \label{eq:faslh-ideal-seqeq}
\\
 &\specstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
  \approx_i
  \specstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
  \label{eq:faslh-ideal-goal}
%%  &\idealmulti
%%   {\specstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}}
%%   {\Obss_1}{\Dirs}
%%   {\cdot}
%%  &\Rightarrow
%% \\
%%  &\idealmulti
%%   {\specstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}}
%%   {\Obss_2}{\Dirs}
%%   {\cdot}
%%  &\Rightarrow
%% \\
%%  &\Obss_1 = \Obss_2
\end{align}
\end{lemma}

\begin{proof}

Unfolding the definition in \eqref{eq:faslh-ideal-goal} exposes the
two ideal executions together with their shared directives $\Dirs$ and
their observations $\Obss_1$ and $\Obss_2$. The goal of the theorem is
to establish their equality based on the equivalence of observations
in the sequential semantics, given by \eqref{eq:faslh-ideal-seqeq},
and the well-typedness and public-equivalence of the initial states
in \eqref{eq:faslh-ideal-loweq}.

If the attacker never forces misspeculation, \IE $\Dirs$ contains
exclusively $\step$ directives, the goal follows directly because
ideal executions without misspeculation preserve the property
in \eqref{eq:faslh-ideal-seqeq}, that is, they are identical to
sequential executions.

If the attacker does force the program misspeculate at some point
during the executions, the list of directives is necessarily of the
form $\Dirs = [\step; \ldots; \step] \cdot [\force] \cdot \Dirs'$: a
prefix without misspeculation, followed by a directive $\force$ that
initiates the misspeculation on a branch, and then by an arbitrary
suffix of directives. This neatly divides the proof into two: the
prefix phase is identical to the first case up to the point where
misspeculation begins, and the two ideal runs have reduced to the same
command.
%
\autoref{lem:faslh-ideal-noninterference} shows that the states
reached after the pivot directive $\force$ are equivalent.
%
% The pivot directive $\force$ produces the same observation on both
% ideal runs (\IE the negation of the observation produced on both
% sequential runs), and consequently the two ideal runs after the
% $\force$ step continue to reduce to the same command.
%
At this point we apply \autoref{lem:gilles-lemma} with the suffix
$\Dirs'$ to conclude the proof.
%
\end{proof}

%% If misspeculation never happens during the execution, the statement is trivially true since the speculative execution then corresponds to a sequential execution.
%% \ld{State a lemma about multi\_ideal\_no\_spec?}
%% We thus place ourselves in the case where misspeculation happens. This means that there is a decomposition of $\Dirs$ into $\Dirs_1^\BoolFalse ++ \force ++ \Dirs_1^\BoolTrue$,
%% such that $\Dirs_1^\BoolFalse$ is only made of $\step$.
%% Asserting that the part of the execution without misspeculation verifies the goal is easy: in fact, it is the same reasoning than when there is no misspeculation at all.
%% The first step of misspeculation has to be on a branch, in which case the resulting observation is the same (it is the opposite of the observation in the sequential setting, which is the same in both executions).
%% Dealing with the part after misspeculation has happened corresponds to \autoref{lem:gilles-lemma}.

%% During the proof, we also assert that the commands are the same in both executions right before the $\force$ instruction is given and right after, in order to satisfy the premises of \autoref{lem:gilles-lemma}.
%% This is possible because we know that if a command performs sequential steps and produces the same observations, then it always reduces to the same command.

Now we are ready to prove our main theorem.

\newtheorem*{thm:faslh-rs}{\autoref{thm:faslh-rs}}
\begin{thm:faslh-rs}[\FlexaSLH enforces relative security]
%
\setcounter{equation}{0}
\begin{align}
 &\cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
  \lookup{\ScalarState_1}{\cvar{b}} = 0 \wedge
  \lookup{\ScalarState_2}{\cvar{b}} = 0
 &\Rightarrow
 \label{eq:faslh-general}
\\
 %% &\colU{
 &(\forall \cvar{a}. | \cvar{a} |_{\ArrayState_1} > 0) \wedge
  (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_2} > 0)
  %% }
 %% &\colU{
 &\Rightarrow
  %% }
  \label{eq:faslh-nonempty}
\\
 &\colSel{
  \wtifc{\LabelPublic}{\cexpr{c}} \wedge
  \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
  \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
  }
 &\colSel{
  \Rightarrow
  }
  \label{eq:faslh-loweq}
\\
 &\colU{
 \seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}
 \approx
 \seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}
 }
 %% &\colU{( \forall \Obss_1 \Obss_2.}
 %%   \\
 %%   &\colU{\quad
 %%    \seqmultis{\seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}}{\Obss_1}{\cdot}
 %%    \Rightarrow
 %%    \seqmultis{\seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}}{\Obss_2}{\cdot}
 %%    \Rightarrow
 %%    \Obss_1 \lessgtr \Obss_2
 %%  )}
 &\colU{\Rightarrow}
 \label{eq:faslh-seqeq}
\\
 &\specstate{\transls{\cexpr{c}}{\FlexaSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
  \approx_s
  \specstate{\transls{\cexpr{c}}{\FlexaSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
  \label{eq:faslh-goal}
 %% &\specmultis
%%   {\specstate{\transls{\cexpr{c}}{\FlexaSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}}
%%   {\Obss_1}{\Dirs}
%%   {\cdot}
%%  &\Rightarrow
%% \\
%%  &\specmultis
%%   {\specstate{\transls{\cexpr{c}}{\FlexaSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}}
%%   {\Obss_2}{\Dirs}
%%   {\cdot}
%%  &\Rightarrow
%% \\
%%  &\Obss_1 = \Obss_2
\end{align}
\end{thm:faslh-rs}

\begin{proof}
The proof of relative security depends on some general assumptions
in \eqref{eq:faslh-general} about the original program not using the
reserved variable for the misspeculation flag, and the flag being
initialized to 0 in both memories.
%
Together with these, there is well-typedness and public-equivalence
in \eqref{eq:faslh-loweq} and the requirement on array sizes
in \eqref{eq:faslh-nonempty}.

The top-level proof itself is simple. \autoref{def-specobs} unfolds
in \eqref{eq:faslh-goal} to reveal a pair speculative
executions. \autoref{lem:bcc} is used on each of these to yield a pair
of ideal executions. The result then follows
from \autoref{lem:faslh-ideal-rs}.
\end{proof}

The other two top-level security results for other variants of \SLH
are simple corollaries of this theorem.
%
Observe that the assumptions of \autoref{thm:faslh-rs} can be divided
into general-purpose assumptions (in black), assumptions that are
closely related to the security of \SelaSLH in \autoref{thm:saslh-ct}
(in \colSel{blue}), and those related to the security of \USLH
in \autoref{thm:uslh-rs} (in \colU{red}).

%% The assumptions are colored \colSel{in blue} when they are inspired by the assumptions of the constant-time security theorem
%% of \SelSLH, and \colU{in orange} when they come from the relative security theorem of \USLH. Other assumptions and the result are common to both.

%% As a consequence of \autoref{thm:faslh-rs}, we obtain \CCT security for \SelaSLH and relative security for \USLH.

\newtheorem*{thm:saslh-ct}{\autoref{thm:saslh-ct}}
\begin{thm:saslh-ct}[\SelaSLH enforces SCT security]

%% \setcounter{equation}{0}
\begin{align*}
  &\cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
   \lookup{\ScalarState_1}{\cvar{b}} = 0 \wedge
   \lookup{\ScalarState_2}{\cvar{b}} = 0
  &\Rightarrow
 \\
  &(\forall \cvar{a}. | \cvar{a} |_{\ArrayState_1} > 0) \wedge
   (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_2} > 0)
  &\Rightarrow
 \\
  &
   \wtct{\cexpr{c}} \wedge
   \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
   \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
  &
   \Rightarrow
 \\
  &\specstate{\transls{\cexpr{c}}{\SelaSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
   \approx_s
   \specstate{\transls{\cexpr{c}}{\SelaSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
 %%  &\specmultis
 %%   {\specstate{\transls{\cexpr{c}}{\FlexaSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}}
 %%   {\Obss_1}{\Dirs}
 %%   {\cdot}
 %%  &\Rightarrow
 %% \\
 %%  &\specmultis
 %%   {\specstate{\transls{\cexpr{c}}{\FlexaSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}}
 %%   {\Obss_2}{\Dirs}
 %%   {\cdot}
 %%  &\Rightarrow
 %% \\
 %%  &\Obss_1 = \Obss_2
 \end{align*}
\end{thm:saslh-ct}

\begin{proof}
%
From \autoref{thm:faslh-aslh}, \SelaSLH is identical to \FlexaSLH for
a fixed $\PubVars$.
%% The proof follows from the observation that
%% $\transls{\cexpr{c}}{\SelaSLH}
%% = \transls{\cexpr{c}}{\FlexaSLH}$ \rb{this should be stated somewhere
%% above}
Together with the use of the more restrictive \CCT type system instead
of the general IFC type system, this imposes that all observations are
based on public values, and we can deduce that all sequential
executions from public-equivalent states produce the same
observations. After deriving the missing assumption, we conclude by
applying \autoref{thm:faslh-rs}.
%
  %% When $\wtct{\cexpr{c}}$, since $\cexpr{c}$ never produces observations based on secret variables,
  %% a look at \autoref{fig:aslh-template} and \autoref{fig:aslh-variants} helps realizing that $\transls{\cexpr{c}}{\FlexaSLH}$ is the same than $\transls{\cexpr{c}}{\SelaSLH}$.
  %% Moreover, when all observations rely on public variables, every sequential execution of the program starting with publicly equivalent states will produce the same observations.
  %% This allows us to remove the corresponding hypothesis in \autoref{thm:faslh-rs}, since it is always verified.
\end{proof}

%% And, similarly, for the final security theorem.

\newtheorem*{thm:uslh-rs}{\autoref{thm:uslh-rs}}
\begin{thm:uslh-rs}[\USLH enforces relative security]
%% \setcounter{equation}{0}
\begin{align*}
  &\cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
   \lookup{\ScalarState_1}{\cvar{b}} = 0 \wedge
   \lookup{\ScalarState_2}{\cvar{b}} = 0
  &\Rightarrow
 \\
  &
   (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_1} > 0) \wedge
   (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_2} > 0)
  &
   \Rightarrow
 \\
  &\seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}
   \approx
   \seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}
  %% &( \forall \Obss_1 \Obss_2.
  %%   \\
  %%   &\quad
  %%    \seqmultis{\seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}}{\Obss_1}{\cdot}
  %%    \Rightarrow
  %%    \seqmultis{\seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}}{\Obss_2}{\cdot}
  %%    \Rightarrow
  %%    \Obss_1 \lessgtr \Obss_2
  %%  )
  &\Rightarrow
 \\
  &\specstate{\translAux{\cexpr{c}}{\USLH}{}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
   \approx_s
   \specstate{\translAux{\cexpr{c}}{\USLH}{}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
 %%  &\specmultis
 %%   {\specstate{\translAux{\cexpr{c}}{\FlexaSLH}{\LabelSecret}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}}
 %%   {\Obss_1}{\Dirs}
 %%   {\cdot}
 %%  &\Rightarrow
 %% \\
 %%  &\specmultis
 %%   {\specstate{\translAux{\cexpr{c}}{\FlexaSLH}{\LabelSecret}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}}
 %%   {\Obss_2}{\Dirs}
 %%   {\cdot}
 %%  &\Rightarrow
 %% \\
 %%  &\Obss_1 = \Obss_2
 \end{align*}
\end{thm:uslh-rs}
\begin{proof}
%
From \autoref{thm:faslh-uslh}, \USLH is a special case of \FlexaSLH
when all variables are secret.
%% Recall again \rb{and this refer to it, as in the last theorem} that
%% when all variables are considered secret, which we write
%% $(\lambda \_. \LabelSecret)$ for both $\PubVars$ and $\PubArrs$,
%% $\translAux{\cexpr{c}}{\USLH}{}
%% = \translAux{\cexpr{c}}{\FlexaSLH}{\lambda \_. \LabelSecret}$.
%
In this setting it is trivial to establish
$\wtifcAux{(\lambda \_. \LabelSecret)}{(\lambda \_. \LabelSecret)}{\LabelPublic}{\cexpr{c}}$,
$\ScalarState_1 \sim_{(\lambda \_. \LabelSecret)} \ScalarState_2$ and
$\ArrayState_1 \sim_{(\lambda \_. \LabelSecret)} \ArrayState_2$
for any choice of commands and states.
%
  %% Another look at \autoref{fig:aslh-template} and \autoref{fig:aslh-variants} allows us to show that \FlexaSLH corresponds to \USLH in the setting where every variable is considered to be secret.
  %% In that setting, we have $\ScalarState_1 \sim_{\LabelSecret} \ScalarState_2$, $\ArrayState_1 \sim_{\LabelSecret} \ArrayState_2$ and
  %% $\wtifcAux{\LabelSecret}{\LabelSecret}{\LabelPublic}{\cexpr{c}}$.
\autoref{thm:faslh-rs} then gives us relative security
for \USLH.
\end{proof}

%% \rb{
%% Fixes to Spectre Declassified presentation of ideal semantics

%% \begin{itemize}

%% \item
%% Case \texttt{Ideal\_ARead}: misspeculated reads within bounds are
%% allowed.

%% \item
%% Case \texttt{Ideal\_ARead\_Prot}: removed and folded into the other
%% two read rules.

%% \item
%% Both read cases: remove harmful preconditions.

%% \end{itemize}

%% Interesting generalizations,
%% cf. \texttt{ct\_well\_typed\_ideal\_noninterferent\_general}
%% }

\section{Flexible Value SLH}
\label{sec:FvSLH}

In the last section we formalized address \SLH, which protects
programs from speculative leakage by masking (some of) the addresses
that produce memory accesses.
%
For load operations specifically, an alternative is to target the
``output'' of the operations, \IE prevent the values read from memory
from leaking to the attacker. This has produced countermeasures like
Selective value \SLH.

\begin{figure}
\centering
\begin{multline*}
\transl{\caread{\cvar{X}}{\cvar{a}}{\cexpr{i}}} \doteq
\\
\quad
  \left\{
  \begin{matrix*}[l]
  {\cseq{\caread{\cvar{X}}{\cvar{a}}{\cexpr{i}}}{\casgn{\cvar{X}}{\ccond{\cvar{b==1}}{\cvar{0}}{\cvar{X}}}}} &
  {\mathit{if} ~ \ValueCheck{\cvar{X}}{\cexpr{i}}}
  \\
  {\caread{\cvar{X}}{\cvar{a}}{\llbracket \cexpr{i} \rrbracket_{\mathit{rd}}}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
\end{multline*}
\caption{Master recipe for value \SLH}
\label{fig:vslh-template}
\end{figure}

% TODO: Mark whatever comes from USLH here, in particular is the
% masking a shared feature of i_rd now?
\begin{figure}
\subcaptionbox{\SelectivevSLH \label{fig:svslh-instance}}[0.4\linewidth]{
\begin{align*}
\ValueCheck{\cvar{X}}{\cexpr{i}}
 &\doteq \colSel{
  \lookup{\PubVars}{\cvar{X}}
  }
\\
\llbracket \cexpr{i} \rrbracket_{\mathit{rd}}
 &\doteq \colSel{
  \phantom{\left\{ \right.}
  \begin{matrix*}[l]
  \phantom{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}
  \\
  \cexpr{i}
  \end{matrix*}
  }
\\
\llbracket \cexpr{i} \rrbracket_{\mathit{wr}}
 &\doteq \colSel{
  \phantom{\left\{ \right.}
  \begin{matrix*}[l]
  \phantom{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}
  \\
  \cexpr{i}
  \end{matrix*}
  }
\end{align*}
}
\subcaptionbox{Flexible \vSLH \label{fig:fvslh-instance}}[0.6\linewidth]{
\begin{align*}
%% \ValueCheck{\cvar{X}}{\cexpr{i}}
 &\colSel{
 %% &\doteq \colFlexnew{
  \lookup{\PubVars}{\cvar{X}}} \mathrel{\colFlexnew{\wedge}} \colFlexnew{\ArithLabel{\cexpr{i}}
  }
\\
%% \llbracket \cexpr{be} \rrbracket_{\mathit{rd}}
 &\colFlexnew{
 %% &\doteq \colSel{
  \left\{
  \begin{matrix*}[l]
  {\colAll{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}} &  {\mathit{if} ~ \colFlexnew{\lnot\labelarith{\PubVars}{\cexpr{i}}}}
  \\
  {\colSel{\cexpr{i}}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
  }
\\
%% \llbracket \cexpr{be} \rrbracket_{\mathit{wr}}
 &\colFlexnew{
 %% &\doteq \colSel{
  \left\{
  \begin{matrix*}[l]
  {\colAll{\ccond{\cvar{b==1}}{\cvar{0}}{\cexpr{i}}}} &
  {\mathit{if} ~ \colFlexnew{\lnot\labelarith{\PubVars}{\cexpr{i}}}}
  \\
  {\colSel{\cexpr{i}}} &
  {\mathit{otherwise}}
  \end{matrix*}
  \right.
  }
\end{align*}
}
\caption{Overview of \vSLH variants}
\label{fig:vslh-variants}
\end{figure}

%% All variants of \SLH need to protect a subset of the memory accesses
%% of a program to prevent speculative leakage.
%% %
%% the exact...
%% , according to their rules
%% %
%% So far, all versions implement what is known as \emph{address \SLH},
%% where the target of the masking operations is one of the ``inputs'' of
%% the access, its memory address.

%% Define FvSLH Most interesting differences wrt previous 3 sections

%% here we
%% outline the most interesting departures from previous sections.

We can adapt \FlexibleSLH to use value \SLH countermeasures while
generalizing existing schemes and offering similar protections against
speculative attackers.
%
Our general template for \vSLH transformations is almost identical to
the \aSLH master recipe. Only the rule for array reads changes as
shown in \autoref{fig:vslh-template}.
%
In \aSLH, array reads were
parameterized by an index translation function
$\llbracket \cdot \rrbracket_{\mathit{rd}}$ that was in charge of
masking the address as needed.  In \vSLH, the translation of reads is
split into two cases: one where the loaded value is immediately masked
using the misspeculation flag, and one where it is not; the rule is
parameterized by a value check function $\ValueCheck{\cdot}{\cdot}$
that controls the case analysis.

Observe that the \vSLH template actually uses an index
translation function $\llbracket \cdot \rrbracket_{\mathit{rd}}$ in
the case where the read value is not masked, as well as the index
masking function $\llbracket \cdot \rrbracket_{\mathit{wr}}$ for array
writes, like \aSLH did.
%% \ld{TODO rephrase to make it a bit less ambiguous} \rb{OK!}
%
On the one hand, \SelvSLH, gets its security exclusively from masking
values that are loaded to public variables,
and never protects indexes, as seen in \autoref{fig:svslh-instance}.
%
On the other hand, as shown in \autoref{fig:fvslh-instance}, \FlexvSLH
needs to fall back on masking certain addresses if it is to achieve
relative security.
%
Moreover, \USLH can also be derived from \FlexvSLH, and simply ignores
its value masking facilities by having $\ValueCheck{\_}{\_}
= \BoolFalse$ and falling back on index masking for all its
protections.
%
%% \rb{More figures explanations/examples, if there is space?}
%% \ld{I don't think there will be space, but the description is good enough I believe} \rb{OK!}

%%  \SelvSLH is shown in \autoref{fig:svslh-instance}. \rb{Pure value
%% masking solution} Values are masked when they are loaded to public
%% variables, and indexes are never masked.
%% %
%% \rb{and this is going to work because of the security and \ldots}

%% This leaves the door open to protecting accesses based on their
%% indexes under certain conditions not covered by value masking.
%% %
%% Although this seems to run counter to the intuition of \vSLH as
%% distinct from \aSLH, it turns out \ldots

%% \rb{
%% The version of SelSLH that we use for these proofs
%% doesn't do anything with stores, no masking of values, but also no
%% masking of addresses like we present in the previous sections. The
%% mechanized proofs use the SpecCT version of SelvSLH, which does not
%% mask stores either.}

% TODO: Harmonize with other ideal semantics, captions, etc.
% v definitions in other reads and writes above?
% outline removed premises
% Note that this semantics does not use PA, only P
% Give unique names to these rules?
\begin{figure*}
  \centering
  \[
  \infer[Ideal\_Read]
  {\labelarith{\PubVars}{\cexpr{ie}} = \ell_{\cexpr{i}} \\
   i = \left\{
   {\begin{matrix*}[l]
    0 & \mathit{if} ~ \highlight{\lnot\ell_{\cexpr{i}} \mathrel{\wedge} b} \\
    \eval{\cexpr{ie}}{\rho} & \mathit{otherwise}
    \end{matrix*}
   }
   \right.
   \\\\
   %% i = \highlight{\ell_{\cexpr{i}} \wedge b} ~ ? ~ 0 ~ : ~ \eval{\cexpr{ie}}{\rho} \\\\
   v =
   \highlight{
   \left\{
   {\begin{matrix*}[l]
    0 & \mathit{if} ~ \lookup{\PubVars}{\cvar{X}} \mathrel{\wedge} \ell_{\cexpr{i}} \mathrel{\wedge} b \\
    \colAll{\eval{\cvar{a}[i]}{\mu}} & \mathit{otherwise}
    \end{matrix*}
   }
   \right.
   } \\
   %% \highlight{v = \lookup{\PubVars}{\cvar{X}} \wedge \lnot\ell_{\cexpr{i}} \wedge b ~ ? ~ 0 ~ : ~ \eval{\cvar{a}[i]}{\mu}} \\
   i < | \cvar{a} |_{\mu}
  }
  {\IdealEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{b}{\cskip}{\subst{\cvar{X}}{v}{\rho}}{\mu}{b}{\OARead{\cvar{a}}{i}}{\step}}
  \quad
  \infer[Ideal\_Read\_Force]
  {\labelarith{\PubVars}{\cexpr{ie}} \\
   \highlight{\cancel{\lnot\lookup{\PubVars}{\cvar{X}}}} \\
   i = \eval{\cexpr{ie}}{\rho} \\\\
   %% \highlight{v = \lnot\lookup{\PubVars}{\cvar{X}} ~ ? ~ 0 ~ : ~ \eval{\cvar{b}[j]}{\mu}} \\\\
   v =
   \highlight{
   \left\{
   {\begin{matrix*}[l]
    0 & \mathit{if} ~ \lookup{\PubVars}{\cvar{X}} \\
    \colAll{\eval{\cvar{b}[j]}{\mu}} & \mathit{otherwise}
    \end{matrix*}
   }
   \right.
   } \\
   i \ge | \cvar{a} |_{\mu} \\
   j < | \cvar{b} |_{\mu}
  }
  {\IdealEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{\BoolTrue}{\cskip}{\subst{\cvar{X}}{v}{\rho}}{\mu}{\BoolTrue}{\OARead{\cvar{a}}{i}}{\DLoad{\cvar{b}}{j}}}
  \]
  \[
  \infer[Ideal\_Write]
  {
   i = \left\{
   {\begin{matrix*}[l]
    0 & \mathit{if} ~ \highlight{\lnot\ell_{\cexpr{i}} \mathrel{\wedge} b} \\
    \eval{\cexpr{ie}}{\rho} & \mathit{otherwise}
    \end{matrix*}
   }
   \right. \\\\
   %% i = \highlight{\ell_{\cexpr{i}} \wedge b} ~ ? ~ 0 ~ : ~ \eval{\cexpr{ie}}{\rho} \\\\
   \labelarith{\PubVars}{\cexpr{ie}} = \ell_{\cexpr{i}} \\
   \highlight{\cancel{\labelarith{\PubVars}{\cexpr{ae}} = \ell}} \\
   v = \eval{\cexpr{ae}}{\rho} \\ % TODO: v -> n for consistency/ease?
   i < | \cvar{a} |_{\mu}
  }
  {\IdealEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{b}{\cskip}{\rho}
  %% {\mu[\casgn{\cvar{a}[i]}{v}]}
  {\subst{\cvar{a}[i]}{v}{\mu}}
  {b}{\OAWrite{\cvar{a}}{i}}{\step}}
  %% \]
  %% \[
  \quad
  \infer[Ideal\_Write\_Force]
  {\labelarith{\PubVars}{\cexpr{ie}} \\
  %\highlight{\cancel{\labelarith{\PubVars}{\cexpr{ae}} \vee \PubArrs = \lambda \_. \LabelSecret}} \\\\
  \highlight{\cancel{\labelarith{\PubVars}{\cexpr{ae}}}} \\\\
   %% \highlight{\cancel{\labelarith{\PubVars}{\cexpr{ae}} = \ldots}} \\\\
   i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cexpr{ae}}{\rho} \\  % TODO: v -> n for consistency/ease?
   i \ge | \cvar{a} |_{\mu} \\
   j < | \cvar{b} |_{\mu}
  }
  {\IdealEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{\BoolTrue}{\cskip}{\rho}
  %% {\mu[\casgn{\cvar{b}[j]}{v}]}
  {\subst{\cvar{b}[j]}{v}{\mu}}
  {\BoolTrue}{\OAWrite{\cvar{a}}{i}}{\DStore{\cvar{b}}{j}}}
  \]
  \caption{Ideal semantics for \FlexvSLH}
  \label{fig:ideal-semantics-fvslh}
\end{figure*}

\begin{example}
\label{ex:fvslh-arrays-differ}
Consider again \autoref{ex:aslh-vs-vslh}.
%% In this program, after misspeculating on the branch when $\cvar{i}$ is out of the bounds of the secret array \cvar{secret\_array}, the attacker can try to write the secret variable \cvar{SECRET}
%% into the public array \cvar{a} at index $0$.
Both \aSLH and \vSLH prevent the public variable \cvar{x} from containing the secret value of \cvar{key}, but their strategies differ.
In the \aSLH setting, it is the out-of-bounds store that is prevented. %% leaving \cvar{a} unchanged. Instead, \cvar{SECRET} will be written into \cvar{secret\_array[$0$]}.
On the other hand, \vSLH does not protect the write operation as long as the index $\cvar{i}$ is public. The attacker is indeed able to load the secret $\cvar{key}$ into the public array $\cvar{a}$,
which breaks the public-equivalence between arrays. In order to maintain security, the subsequent load value on $\cvar{x}$ will be masked 0, and \cvar{a[0]} containing a secret does not cause the program to leak information.
\end{example}

% In that example, an attacker who managed to get $\cexpr{ie}$ out of bounds of the array $\cvar{secret\_array}$ can then cause the secret variable $\cvar{SECRET}$ to be stored in any other array,
% for example in array $\cvar{a}$ at index $0$. If this array is public, reading from it and storing the result in a public variable can the cause to branching on a secret with a public variable.
% Masking the index while reading from $\cvar{a}$ does not fix the issue, as this happens inside of bounds anyway.
% In order to prevent this attack, we mask the index of writes when misspeculating in two cases. The first is when there exists a public array (which should be the case most of the time) and
% the value that is written is secret. This corresponds to an answer to the previously shown example. The other (more obvious) case is when the index contains a secret itself.

Using these new definitions we can state and prove that
\FlexvSLH enforces relative security and
\SelvSLH enforces SCT security.
%
The high-level structure of the security proofs closely mirrors the
development in \autoref{sec:formal-results}.
%
\FlexvSLH uses a new version of the ideal semantics that
reflects the changes in its behavior and supplies the proofs with
relevant information.
%
By a slight abuse of notation, we will write
$\PubVars \vdash \IdealEval{\cexpr{c}}{\rho}{\mu}{b}{\cexpr{c'}}{\rho'}{\mu'}{b'}{\Obss}{\Dirs}$
for the new semantics in this section and elide the public variables
and turnstile as those remain constant throughout.

The new ideal semantics is in large part identical to the ideal
semantics for \FlexaSLH in \autoref{fig:ideal-semantics-faslh}; the
only changes take place in the premises of the rules for array reads
and writes, which are given in \autoref{fig:ideal-semantics-fvslh}.
Changes between the two versions are highlighted
in \colHighlight{red}; premises that disappear in the new version are
also crossed out.
%
Both rules for array reads now add masking to their premise on the
value fetched from the array, consistently with the
transformation. Additionally, both $\step$ rules on array reads and
writes modify their conditions for index masking, and both
misspeculating rules on reads and writes tweak the side conditions
under which out-of-bounds accesses are allowed.
%
%% Note that the ideal semantics no longer depends on $\PubArrs$.
%% %
%% \rb{Any remarks to make about the changes?}
%% %
%% \ld{Actually, the reason $\PubArrs$ are in the other ideal semantics
%% in the first place is because of some optimization in order to fit with
%% USLH. It's more of a hack, I think mentioning it is more confusing than useful}

%% First among these, we need a new auxiliary semantics that reflects the
%% ideal behavior of a program \ldots (pre-hardening) \ldots.
%% \autoref{fig:ideal-semantics-fvslh}
%% %
%% It has the same set of rules as the ideal semantics for \FlexaSLH
%% in \autoref{fig:ideal-semantics-faslh}, and the only changes are in
%% the premises of the four rules for array reads and writes, shown
%% highlighted in \autoref{fig:ideal-semantics-fvslh}. Notably, the
%% conditional rules remain unchanged.

%%   shows the ideal semantics for \FlexvSLH as a delta from the ideal
%% semantics of \FlexaSLH in \autoref{fig:ideal-semantics-faslh}.

%% All changes affect the side conditions rules that change are those for
%% reads and writes.

Based on the new ideal semantics we can prove an identical set of key
technical lemmas, which we elide here
(see \autoref{sec:appendix-fvslh-theorems} for details).
%
The fact that arrays are no longer public-equivalent during
misspeculation, as \autoref{ex:fvslh-arrays-differ} shows, requires
us to strengthen the value-based counterpart
of \autoref{lem:gilles-lemma} by removing that assumption,
as well as an adapted version of \autoref{lem:faslh-ideal-noninterference}:
%% taking into account that arrays are no longer
%% assured to be publicly equivalent after misspeculation has happened.
%
The
statements of the main value \SLH theorems are identical to their
address \SLH counterparts, substituting new translation functions for
the old ones.

\begin{theorem}
%% [\FlexvSLH is relative-secure]
\label{thm:fvslh-rs}
%
\FlexvSLH enforces relative security for all IFC-well-typed programs and for all
public-equivalent initial states.
%% \begin{align*}
%%  &\cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
%%   \lookup{\ScalarState_1}{\cvar{b}} = 0 \wedge
%%   \lookup{\ScalarState_2}{\cvar{b}} = 0
%%  &\Rightarrow
%% \\
%%  %% &\colU{
%%  &(\forall \cvar{a}. | \cvar{a} |_{\ArrayState_1} > 0) \wedge
%%   (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_2} > 0)
%%   %% }
%%  %% &\colU{
%%  &\Rightarrow
%%   %% }
%% \\
%%  &\colSel{
%%   \wtifc{\LabelPublic}{\cexpr{c}} \wedge
%%   \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
%%   \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
%%   }
%%  &\colSel{
%%   \Rightarrow
%%   }
%% \\
%%  &\colU{
%%  \seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}
%%  \approx
%%  \seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}
%%  }
%%  &\colU{\Rightarrow}
%% \\
%%  &\specstate{\transls{\cexpr{c}}{\FlexvSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
%%   \approx_s
%%   \specstate{\transls{\cexpr{c}}{\FlexvSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
%% \end{align*}
\end{theorem}

%% \begin{proof}
%% Same structure as the proof of \autoref{thm:faslh-rs}.
%% %% The statement of \autoref{lem:gilles-lemma} is slightly adapted in this setting by
%% %% removing the requirement for public arrays to be equivalent.
%% \end{proof}

%% CCT/SCT secure?

\begin{theorem}
%% [\SelvSLH is \CCT-secure \cite{ShivakumarBBCCGOSSY23}]
\label{thm:svslh-sct}
%
\SelvSLH enforces SCT security for CCT programs.
%% \begin{align*}
%%   &\cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
%%    \lookup{\ScalarState_1}{\cvar{b}} = 0 \wedge
%%    \lookup{\ScalarState_2}{\cvar{b}} = 0
%%   &\Rightarrow
%%  \\
%%   &(\forall \cvar{a}. | \cvar{a} |_{\ArrayState_1} > 0) \wedge
%%    (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_2} > 0)
%%   &\Rightarrow
%%  \\
%%   &
%%    \wtct{\cexpr{c}} \wedge
%%    \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
%%    \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
%%   &
%%    \Rightarrow
%%  \\
%%   &\specstate{\transls{\cexpr{c}}{\SelvSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
%%    \approx_s
%%    \specstate{\transls{\cexpr{c}}{\SelvSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
%%  \end{align*}
%
\end{theorem}

%% \begin{proof}
%% Simple corollary of \autoref{thm:fvslh-svslh}
%% and \autoref{thm:fvslh-rs}.
%% \end{proof}

\section{Related Work}
\label{sec:related-work}

% CH: CSF PC members most likely to review this
%     https://csf2025.ieee-security.org/committee.html
% - Benjamin Gregoire: Coq, side-channels, Jasmin, etc. [DONE]
% - Lennart Beringer: Coq, some IFC [NOTHING]
% - Andrei Popescu: Isabelle; relative security paper at CSF'24 [DONE]
% - Deian Stefan: https://dblp.org/pid/91/6118.html [DONE]
%   + SoK, Blade, Swivel, FaCT, spectre era x 2
% - Lesly-Ann Daniel: speculative side-channels [DONE]
%   + https://dblp.org/pid/222/9411.html
% - Sébastien Bardin [DONE]
%   + Binsec/Haunted: https://dblp.org/rec/conf/ndss/DanielBR21.html?view=bibtex
%   + ProSpeCT: https://dblp.org/rec/conf/uss/DanielBNBRP23.html?view=bibtex -- unrelated!
% - Tegan Brennan: side-channels (in SE venues)
% - Michael Emmi:
%   + ct-fuzz, Fuzzing for Timing leaks https://dblp.org/rec/conf/icst/HeEC20.html?view=bibtex
% - various IFC people: Owen Arden, Aslan Askarov, Abhishek Bichhawat,
%     Daniel Hedin, Michael Hicks, Elisavet Kozyri, Piotr Mardziel,
%     Scott Moore, Alejandro Russo

As already mentioned, SLH was originally proposed and implemented in
LLVM~\cite{Carruth18} as a defense against Spectre v1 attacks.
%
\citet{PatrignaniG21} noticed that SLH is not strong enough to achieve one of
their relative security notions and proposed Strong SLH, which uses the
misspeculation flag to also mask all branch conditions and all addresses of
memory accesses.
%
\citet{ZhangBCSY23} later noticed that the inputs of all variable-time
instructions also have to be masked for security and implemented everything as
the Ultimate SLH program transformation in the x86 backend of LLVM.
%
They experimentally evaluated Ultimate SLH on the SPEC2017 benchmarks and
reported overheads of around 150\%, which is large, but still smaller than
adding fences.

Taking inspiration in prior static analysis work~\cite{CheangRSS19,
  GuarnieriKMRS20}, both \citet{PatrignaniG21} and \citet{ZhangBCSY23} propose
to use relative security to assess the security of their transformations, by
requiring that the transformed program does not leak speculatively more than
{\em the transformed program itself} leaks sequentially.\ch{Should double check
  that this is the case for \citet{PatrignaniG21}, but it's difficult given the
  mess they do.}
%
While this is a sensible way to define relative security in the absence of a
program transformation~\cite{CheangRSS19, GuarnieriKMRS20, DongolGPW24,
  CauligiDMBS22},\ch{as discussed earlier, hopefully}
%
when applied only to the transformed program this deems secure a transformation
that introduces sequential leaks, instead of removing speculative ones.
%
Instead, we use a security definition that is more suitable for transformations
and compilers, which requires that any transformed program running with
speculation does not leak more than what the {\em source} program leaks sequentially.
%
Finally, our definition only looks at 4 executions (as opposed to 8
executions~\cite{PatrignaniG21}) and our proofs are fully mechanized in Rocq.
%
\ifanon\else
A similar relative security definition was independently discovered by
Jonathan Baumann, who verified fence-based Spectre countermeasures in the Rocq
prover using hypersimulations~\cite{Baumann23}.
\fi

In a separate line of research, \SelvSLH was proposed as an efficient way to
protect cryptographic code against Spectre v1 in the Jasmin
language~\cite{AlmeidaBBBGLOPS17}.
%
\citet{ShivakumarBBCCGOSSY23} proved in a simplified setting that an automatic
\SelvSLH transformation (discussed in \autoref{sec:FvSLH}) achieves speculative
CT security.
%
Yet for the best efficiency, Jasmin programmers may have to reorganize their code
and manually insert a minimal number SLH protections, with a static analysis
just checking that the resulting code is secure~\cite{ShivakumarBGLOPST23}.
%
In more recent work, \citet{OlmosBBGL24} showed how speculative CT security can
be preserved by compilation in a simplified model of the Jasmin compiler, which
they formalized in Rocq.
%
These preservation proofs seem easily extensible to the stronger relative
security definition we use in this paper, yet providing security guarantees to
non-CCT code does not seem a goal for the Jasmin language, which is specifically
targeted at cryptographic implementations.

The simple and abstract speculative semantics we use in \autoref{sec:defs} is
taken from the paper of \citet{ShivakumarBBCCGOSSY23}, who credit prior work by
\citet{CauligiDGTSRB20} and \citet{BartheCGKLOPRS21} for the idea of a
``forwards'' semantics that takes attacker directions and does no rollbacks.
%
This style of speculative semantics seems more suitable for higher-level
languages, for which the concept of a ``speculation window'' that triggers
rollbacks would require exposing too many low-level details about the
compilation and target architecture, if at all possible to accommodate.
%
\citet{BartheCGKLOPRS21} also prove that in their setting any speculative CT
attack against a semantics with rollbacks also exist in their ``forwards''
semantics with directions.

\section{Conclusion and Future Work}
\label{sec:conclusion}\label{sec:future-work}

In this paper we introduced FSLH, a flexible variant of SLH that brings together
the benefits of both Selective SLH and Ultimate SLH.
%
We provide formal proofs in the Rocq prover that FSLH satisfies a strong
relative security property, ensuring that the hardened program can only
leak speculatively as much as the original source program leaks sequentially.

As a next step we want to move from the simple IFC type system of \autoref{sec:type-system}
to a flow-sensitive IFC analysis that accepts arbitrary source programs.
%
We already implemented this in Rocq and property-based tested relative security
for it using QuickChick\ifanon---these experiments are part of the auxiliary
  materials of this submission\fi.
%
Formally proving this extension secure is, however, more challenging and left
for future work.

On the practical side we would like to implement FSLH in LLVM and experimentally
evaluate the reduction in overhead with respect to Ultimate SLH.
%
This raises significant engineering challenges though, since it requires adding
a flow-sensitive IFC analysis to LLVM, keeping track of which program inputs are
secret and which ones not throughout the whole compiler chain, and
making sure that the defenses we add are not removed by subsequent compiler passes.
%
Finally, while Rocq proofs for the whole of LLVM would be way beyond what's
reasonable in terms of effort, we believe that property-based testing of
relative security could be a pragmatic compromise for validating end-to-end
security in practice.


% Acknowledgments
\ifanon\else
% \begin{acks}
{\small
\paragraph{Acknowledgements}
We are grateful to Gilles Barthe and Santiago Arranz Olmos
for the insightful discussions.
%
% We thank the reviewers for their careful reviews and helpful comments.
This work was in part supported
by the Deutsche Forschungsgemeinschaft (DFG\iffull, German Research Foundation\fi)
as part of the Excellence Strategy of the German Federal and State Governments
-- EXC 2092 CASA - 390781972.
\ch{TODO: add more acknowledgements here, if needed}
}
% \end{acks}
\fi

\ifanon
\clearpage
\fi

\ifappendix
% \onecolumn
\appendices

\section{Sequential Semantics for \SourceLang}
\label{sec:appendix-sequential-semantics}

 \autoref{fig:seq-semantics} shows the standard sequential semantics
for \SourceLang as presented
in \autoref{sec:defs-syntax-seq-semantics}. This figure can be derived
from \autoref{fig:spec-semantics} by erasing the highlighted
components.

\begin{figure}[!h]
  \centering \[ \infer[Seq\_Asgn] {v = \eval{\cexpr{ae}}{\rho}}
  {\SeqEval{\casgn{\cvar{X}}{\cexpr{ae}}}{\cexpr{\rho}}{\cexpr{\mu}}{\cskip}
  {\subst{\cvar{X}}{v}{\rho}}
  {\cexpr{\mu}}{\bullet}} \]\[ \infer[Seq\_Seq\_Step]
  {\SeqEval{\cexpr{c_1}}{\rho}{\mu}{\cexpr{c_1'}}{\rho'}{\cexpr{\mu'}}{o}}
  {\SeqEval{\cseq{\cexpr{c_1}}{\cexpr{c_2}}}{\rho}{\mu}{\cseq{\cexpr{c_1'}}{\cexpr{c_2}}}{\rho'}{\mu'}{o}} \quad \infer[Seq\_Seq\_Skip]
  {\quad}
  {\SeqEval{\cseq{\cskip}{\cexpr{c}}}{\rho}{\mu}{\cexpr{c}}{\rho}{\mu}{\bullet}} \] \[ \infer[Seq\_If]
  {b' = \eval{\cexpr{be}}{\cexpr{\rho}}}
  {\SeqEval{\cif{\cexpr{be}}{\cexpr{c_\BoolTrue}}{\cexpr{c_\BoolFalse}}}{\cexpr{\rho}}{\cexpr{\mu}}{\cexpr{c_{b'}}}{\cexpr{\rho}}{\mu}{\branch{b'}}}
  \]
  \[
  \infer[Seq\_While]
  {\cexpr{c_{while}} = \cwhile{\cexpr{be}}{\cexpr{c}}}
  {\SeqEval{\cexpr{c_{while}}}{\rho}{\mu}{\cif{\cexpr{be}}{\cseq{\cexpr{c}}{\cexpr{c_{while}}}}{\cskip}}{\rho}{\mu}{\bullet}}
  \]
  \[
  \infer[Seq\_Read]
  {i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cvar{a}[i]}{\mu} \\
   i < | \cvar{a} |_{\mu}}
  {\SeqEval{\caread{\cvar{X}}{\cvar{a}}{\cexpr{ie}}}{\rho}{\mu}{\cskip}
   {\subst{\cvar{X}}{v}{\rho}}
   {\mu}{\OARead{\cvar{a}}{i}}}
  \]\[
  \infer[Seq\_Write]
  {i = \eval{\cexpr{ie}}{\rho} \\
   v = \eval{\cexpr{ae}}{\rho} \\
   i < | \cvar{a} |_{\mu}}
  {\SeqEval{\cawrite{\cvar{a}}{\cexpr{ie}}{\cexpr{ae}}}{\rho}{\mu}{\cskip}{\rho}
   {\subst{\cvar{a}[i]}{v}{\mu}}
   {\OAWrite{\cvar{a}}{i}}}
  \]
  \caption{Sequential semantics}
  \label{fig:seq-semantics}
\end{figure}

\section{Full Theorem Statements for \FlexvSLH}
\label{sec:appendix-fvslh-theorems}

As we point out in \autoref{sec:FvSLH}, the statements and high-level
proofs for \FlexvSLH are very similar to their corresponding
address-based variants. This starts with the relation
between \FlexibleSLH and the other protection schemes.

\begin{theorem}[Connection between \FlexvSLH and \SelvSLH]
\label{thm:fvslh-svslh}
Given a set of public variables $\PubVars$,
for any \CCT program $c$
\[
\transls{\cexpr{c}}{\FlexvSLH} = \transls{\cexpr{c}}{\SelvSLH}
\]
\end{theorem}

\begin{proof}
Immediate from \autoref{fig:svslh-instance}
and \autoref{fig:fvslh-instance}.
\end{proof}

\begin{theorem}[Connection between \FlexvSLH and \USLH]
\label{thm:fvslh-uslh}
If all variables of a program (both scalars and arrays) are considered
secret, \IE $(\lambda \_. \LabelSecret)$, then for any program $c$
\[
\translAux{\cexpr{c}}{\FlexvSLH}{(\lambda \_. \LabelSecret)}
= \translAux{\cexpr{c}}{\USLH}{}
\]
\end{theorem}

\begin{proof}
Immediate from \autoref{fig:fvslh-instance}
and \autoref{fig:uslh-instance}, noting that \FlexvSLH is a strict
generalization of FaSLH, to which it reduces when $\ValueCheck{\_}{\_}
= \BoolFalse$.
\end{proof}

The assumption of public-equivalence of array states that holds for \aSLH
no longer applies.
%
This change requires an adapted version
of \autoref{lem:faslh-ideal-noninterference}:

\begin{lemma}[Noninterference of $\idealmultiarrow{}{}$]
  \label{lem:fvslh-ideal-noninterference}
  \begin{align*}
    &\wtifc{\SemSpecFlag}{\cexpr{c}}\wedge \ScalarState_1 \sim_{\PubVars} \ScalarState_2
    % &\Rightarrow\\
    % &
    \wedge
    (b = \BoolFalse \Rightarrow \ArrayState_1 \sim_{\PubArrs} \ArrayState_2) &\Rightarrow\\
    &\IdealEval{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}{b}{\cexpr{c_1}}{\ScalarState_1'}{\ArrayState_1'}{b_1}{o}{d}&\Rightarrow\\
    &\IdealEval{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}{b}{\cexpr{c_2}}{\ScalarState_2'}{\ArrayState_2'}{b_2}{o}{d}&\Rightarrow\\
    &\cexpr{c_1} = \cexpr{c_2} \wedge b_1 = b_2 \wedge \ScalarState_1' \sim_{\PubVars} \ScalarState_2' \wedge (b_1 = \BoolFalse \Rightarrow \ArrayState_1' \sim_{\PubArrs} \ArrayState_2') &
  \end{align*}
\end{lemma}
\begin{proof}[Proof sketch]
  By induction on the first evaluation judgment and inversion on the second one.
\end{proof}

This lemma is used to prove the adaptation
of \autoref{lem:gilles-lemma} to the \vSLH setting, whose statement
also removes the assumption on the public-equivalence of arrays. The same
lemma is used to prove the main theorem:

\newtheorem*{thm:fvslh-rs}{\autoref{thm:fvslh-rs}}
\begin{thm:fvslh-rs}[\FlexvSLH enforces relative security]
%
\begin{align*}
 &\cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
  \lookup{\ScalarState_1}{\cvar{b}} = 0 \wedge
  \lookup{\ScalarState_2}{\cvar{b}} = 0
 &\Rightarrow
\\
 %% &\colU{
 &(\forall \cvar{a}. | \cvar{a} |_{\ArrayState_1} > 0) \wedge
  (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_2} > 0)
  %% }
 %% &\colU{
 &\Rightarrow
  %% }
\\
 &\colSel{
  \wtifc{\LabelPublic}{\cexpr{c}} \wedge
  \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
  \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
  }
 &\colSel{
  \Rightarrow
  }
\\
 &\colU{
 \seqstate{\cexpr{c}}{\ScalarState_1}{\ArrayState_1}
 \approx
 \seqstate{\cexpr{c}}{\ScalarState_2}{\ArrayState_2}
 }
 &\colU{\Rightarrow}
\\
 &\specstate{\transls{\cexpr{c}}{\FlexvSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
  \approx_s
  \specstate{\transls{\cexpr{c}}{\FlexvSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
\end{align*}
%
\end{thm:fvslh-rs}

\begin{proof}
Same structure as the proof of \autoref{thm:faslh-rs}.
%% The statement of \autoref{lem:gilles-lemma} is slightly adapted in this setting by
%% removing the requirement for public arrays to be equivalent.
\end{proof}

\newtheorem*{thm:svslh-sct}{\autoref{thm:svslh-sct}}
\begin{thm:svslh-sct}[\SelvSLH enforces SCT security \cite{ShivakumarBBCCGOSSY23}]
%
\begin{align*}
  &\cvar{b} \notin \UsedVars{\cexpr{c}} \wedge
   \lookup{\ScalarState_1}{\cvar{b}} = 0 \wedge
   \lookup{\ScalarState_2}{\cvar{b}} = 0
  &\Rightarrow
 \\
  &(\forall \cvar{a}. | \cvar{a} |_{\ArrayState_1} > 0) \wedge
   (\forall \cvar{a}. | \cvar{a} |_{\ArrayState_2} > 0)
  &\Rightarrow
 \\
  &
   \wtct{\cexpr{c}} \wedge
   \ScalarState_1 \sim_{\PubVars} \ScalarState_2 \wedge
   \ArrayState_1 \sim_{\PubArrs} \ArrayState_2
  &
   \Rightarrow
 \\
  &\specstate{\transls{\cexpr{c}}{\SelvSLH}}{\ScalarState_1}{\ArrayState_1}{\BoolFalse}
   \approx_s
   \specstate{\transls{\cexpr{c}}{\SelvSLH}}{\ScalarState_2}{\ArrayState_2}{\BoolFalse}
 \end{align*}
%
\end{thm:svslh-sct}

\begin{proof}
Simple corollary of \autoref{thm:fvslh-svslh}
and \autoref{thm:fvslh-rs}.
\end{proof}

\setcounter{theorem}{0}
\renewcommand{\thetheorem}{\thesection.\arabic{theorem}}

Because \USLH is a special case of \FlexvSLH, we can also
use \autoref{thm:fvslh-uslh} and \autoref{thm:fvslh-rs} to obtain an
alternative proof of \autoref{thm:uslh-rs}.

% ....

% \twocolumn
\else
\fi % appendices

% BIBLIOGRAPHY ALWAYS AT THE END!
\ifieee
\bibliographystyle{abbrvnaturl}
%\footnotesize
\else %acm
\ifcamera
\bibliographystyle{ACM-Reference-Format}
\citestyle{acmauthoryear}   %% For author/year citations
\else
\bibliographystyle{abbrvnaturl}
\fi

\fi %ieee/acm

\bibliography{spec}
% BIBLIOGRAPHY ALWAYS AT THE END!

\end{document}
