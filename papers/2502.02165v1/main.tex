\documentclass[acmsmall,nonacm]{acmart}

% Disable headers and footers for the title page
\fancypagestyle{titlepage}{
    \fancyhf{} % Clear all headers and footers
    \renewcommand{\headrulewidth}{0pt} % Remove header rule
    \renewcommand{\footrulewidth}{0pt} % Remove footer rule
}

% Prevent page numbering on the title page
\pagenumbering{gobble}


%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
\setcopyright{acmlicensed}
\copyrightyear{2018}
\acmYear{2018}
\acmDOI{XXXXXXX.XXXXXXX}
%% These commands are for a PROCEEDINGS abstract or paper.
\acmConference[Conference acronym 'XX]{Make sure to enter the correct
  conference title from your rights confirmation emai}{June 03--05,
  2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
\acmISBN{978-1-4503-XXXX-X/18/06}

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amsfonts}
% \usepackage{amssymb}
\usepackage{graphicx}
\usepackage{todonotes}
\usepackage{wrapfig} 
\usepackage{lipsum}
\usepackage{float}



\usepackage{mdframed}
\newmdenv[linecolor=black,linewidth=0.5pt,roundcorner=5pt]{problem}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{definition}{Definition}
\newtheorem{corollary}[theorem]{Corollary}

\newcommand{\graph}{Erd\H{o}s--R\'enyi graph $G(n, p)$}

\newcommand{\anton}[1]{\textcolor{cyan}{[Anton: #1]}}

\date{}

% \begin{CCSXML}
% <ccs2012>
%    <concept>
%        <concept_id>10003752.10010061.10010069</concept_id>
%        <concept_desc>Theory of computation~Random network models</concept_desc>
%        <concept_significance>500</concept_significance>
%        </concept>
%    <concept>
%        <concept_id>10003752.10010061.10010065</concept_id>
%        <concept_desc>Theory of computation~Random walks and Markov chains</concept_desc>
%        <concept_significance>500</concept_significance>
%        </concept>
%    <concept>
%        <concept_id>10003752.10003809.10010172</concept_id>
%        <concept_desc>Theory of computation~Distributed algorithms</concept_desc>
%        <concept_significance>500</concept_significance>
%        </concept>
%    <concept>
%        <concept_id>10003752.10003809.10003635</concept_id>
%        <concept_desc>Theory of computation~Graph algorithms analysis</concept_desc>
%        <concept_significance>300</concept_significance>
%        </concept>
%  </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Theory of computation~Random network models}
% \ccsdesc[500]{Theory of computation~Random walks and Markov chains}
% \ccsdesc[500]{Theory of computation~Distributed algorithms}
% \ccsdesc[300]{Theory of computation~Graph algorithms analysis}

% \keywords{Distributed algorithms, Random graphs, Broadcasting, Branching random walks, Tree packing, CONGEST model.}

\author{Anton Paramonov}
\affiliation{
  \institution{ETH Zurich}
  \country{Switzerland}
}
\email{aparamonov@ethz.ch}



\author{Roger Wattenhofer}
\affiliation{
  \institution{ETH Zurich}
  \country{Switzerland}
}
\email{wattenhofer@ethz.ch}



\begin{document}
    \title{$\Tilde{\text{O}}$ptimal Broadcast on Congested Random Graphs}
    
    
    \begin{abstract}
        We study the problem of broadcasting multiple messages in the CONGEST model. In this problem, a dedicated node $s$ possesses a set $M$ of messages with every message being of the size $O(\log n)$ where $n$ is the total number of nodes. The objective is to ensure that every node in the network learns all messages in $M$. The execution of an algorithm progresses in rounds and we focus on optimizing the round complexity of broadcasting multiple messages. 
        
        Our primary contribution is a randomized algorithm designed for networks modeled as random graphs. The algorithm succeeds with high probability and achieves round complexity that is optimal up to a polylogarithmic factor. It leverages a multi-COBRA primitive, which uses multiple branching random walks running in parallel. To the best of our knowledge, this approach has not been applied in distributed algorithms before. A crucial aspect of our method is the use of these branching random walks to construct an optimal (up to a polylogarithmic factor) tree packing of a random graph, which is then used for efficient broadcasting. This result is of independent interest.
                    
        We also prove the problem to be NP-hard in a centralized setting and provide insights into why straightforward lower bounds, namely graph diameter and $\frac{|M|}{minCut}$, can not be tight.
    \end{abstract}

    \maketitle
    \thispagestyle{empty}
    \newpage
    \setcounter{page}{1}
    % Restart page numbering
    \pagenumbering{arabic}



    \section{Introduction}

    % Plan: So... my intro idea in a nutshell: I would embed the whole paper into an application, which is ... drumroll ... large-scale distributed systems (or even more concretely: blockchain systems). Almost all of them (Ethereum, Bitcoin, etc.) connect the participants with a random graph. And then they need to need to share (broadcast) information. So you solve pretty much exactly this problem, which many people will see as an important issue. The beauty of your solution is that it doesn't really matter how the network is built, so your analysis works for any kind of blockchain architecture?

    Network topologies of major distributed systems, such as Bitcoin \cite{nakamoto2008bitcoin}, Ethereum \cite{buterin2014next}, and Torrent \cite{cohen2003incentives}, are often designed to emulate the properties of random graphs. Empirical studies further confirm that real-world networks frequently exhibit characteristics akin to random graphs \mbox{\cite{gao2019topologyEth,delgado2019txprobeBTC,dale2008evolutionTorrent}}. This observation has naturally motivated a significant body of research to focus on algorithms and protocols tailored for random graph structures.

    One of the fundamental communication tasks in such distributed systems is the efficient broadcast of large messages. In blockchains, this could be the dissemination of a block of transactions, while in peer-to-peer networks like torrents, it may involve distributing large files. The design of robust and efficient broadcast algorithms is critical for maintaining the performance and scalability of these systems.
    
    In this work, we present an algorithm that addresses the problem of broadcasting large messages in distributed systems with a random graph topology. Our solution achieves near-optimal broadcast time while imposing no requirements on the underlying network structure beyond its random properties. This generality ensures that our approach is applicable to a wide range of real-world systems, including various blockchain architectures, and highlights its potential as a versatile tool for scalable and efficient information dissemination.
    
    \subsection{Model and Problem}
    The CONGEST model \cite{peleg2000distributed} is defined as follows. The network is modeled as a graph with $n$ nodes, where execution progresses in synchronous rounds. In each round, a node can send a message of size $O(\log n)$ bits to each of its neighbors. Nodes do not have prior knowledge of the network topology but are assumed to have unique identifiers that fit within $O(\log n)$ bits.

    Although the CONGEST model has been extensively studied over the past two decades, the fundamental problem of broadcasting multiple messages remains incompletely understood.
    
    \begin{definition}[Multi-message broadcast]
    A dedicated node $s$ possesses a set $M$ of messages, where each message $m \in M$ has a size of $O(\log n)$ bits. The objective is to ensure that every node in the network learns all messages in $M$.
    \end{definition}

    \subsection{On the Universal Optimality}
    As pointed out by Ghaffari \cite{ghaffari2015distributed}, the problem suggests an $\Omega(D + k)$ round complexity lower bound, where $D$ is the diameter of the graph and $k$ is the number of messages $|M|$. For example, consider a path graph with $s$ as its first node. Any algorithm would require at least $D + k - 1$ rounds to transmit all messages to the last node. However, this bound is \emph{existential}, meaning there exists a graph for which $\Omega(D + k)$ rounds are needed. In contrast, consider a complete graph with $k = n$. Here, broadcasting can be completed in 2 rounds, which is significantly better than the $\Omega(k) = \Omega(n)$ bound suggested by the path graph example. This paper presents an algorithm that achieves \emph{universal} optimality \cite{garay1998sublinear} on random graphs. Specifically, for a random graph $G$, the algorithm completes the multi-message broadcast in $\Tilde{O}(OPT(G))$ rounds with high probability, where $OPT(G)$ denotes the best possible round complexity for $G$ and $\Tilde{O}$ hides $polylog(k, n)$ factors. 
    
    \subsection{Previous Work}
    The first work to address universal optimality for the multi-message broadcast problem in the CONGEST model was ``Distributed Broadcast Revisited: Towards Universal Optimality`` by Ghaffari \cite{ghaffari2015distributed}. In that paper, the algorithm consists of two phases: (1) constructing a \emph{tree packing}, and (2) performing the broadcast using the constructed tree packing. A tree packing of a graph $G$ is a collection of spanning subtrees of $G$. The tree packing is characterized by three parameters: (1) its size $S$, i.e., the number of trees, (2) its height $H$, i.e., the maximal height of a tree, and (3) its weight $W$, i.e., the maximal number of trees sharing a single edge. With a tree packing, one can complete a multi-message broadcast in $O((H + \frac{k}{S}) \cdot W)$ rounds by splitting messages uniformly across the trees and propagating them sequentially within each tree. However, the limitation of \cite{ghaffari2015distributed} is that constructing the tree packing requires $\Tilde{\Omega}(D + k)$ rounds, preventing the approach from achieving universal optimality.
    
    A subsequent work, ``Fast Broadcast in Highly Connected Networks`` [preprint 2024] by Ghaffari et al. \cite{chandra2024fast}, considered the tree packing approach on highly connected graphs, i.e., graphs with high edge connectivity $\lambda$. The primary result of this work is an algorithm that runs in $\Tilde{O}(\frac{n + k}{\lambda})$ rounds. This complexity is optimal when $k = \Omega(n)$, as $\frac{k}{\lambda}$ represents an information-theoretic lower bound. However, the algorithm may incur a $\Tilde{\Omega}(n)$ factor overhead in cases where $\lambda$ and $k$ are small compared to $n$.

    Notably, both \cite{ghaffari2015distributed} and \cite{chandra2024fast} consider a slightly more general problem where initially $M$ is not necessarily known to a single node but different nodes can possess different parts of it. We adhere to our version, where $M$ is initially held by a single node, as it simplifies the presentation. Importantly, when a tree packing is available, the multiple-source version can be reduced to the single-source version without increasing the round complexity (see Remark \ref{rem:single source}).
    
    \subsection{Preliminaries and Notation}
    An \graph is a graph on $n$ vertices where each edge exists independently from others with probability $p$ \cite{erd6s1960evolution}. Throughout the paper, for a graph $G$, $E(G)$ is the edge set, $V(G)$ is the vertex set, $D(G)$ is the diameter, $\delta(G)$ is the smallest vertex degree, and $\Delta(G)$ is the largest vertex degree. We do not explicitly specify $G$ if it is obvious from the context, e.g., we can write $\delta$ instead of $\delta(G)$. With high probability (w.h.p.) means with a probability of at least $1 - O(\frac{1}{n^C})$ for some constant $C > 0$, with the probability being taken over both the randomness of the graph and the random bits of the algorithm. We assume that $\Tilde{O}$ and $\Tilde{\Omega}$ hide $polylog(k, n)$ factors.
    
    \subsection{Our Contribution}
    In the present paper, we provide an algorithm that is universally optimal w.h.p. when the network is modeled as an \graph.

    \begin{theorem}
        \label{thm:main}
        Throughout the paper, let $C_p$ denote a sufficiently large constant.\footnote{It suffices to take $C_p = 2700$.} For an {\graph} with $p \geq \frac{C_p\log n}{n}$, there exists a distributed randomized algorithm that completes the broadcast in $\Tilde{O}(D(G) + \frac{k}{\delta(G)})$ rounds w.h.p.
    \end{theorem}

    \begin{remark}
        The round complexity of $\Tilde{O}(D(G) + \frac{k}{\delta(G)})$ is optimal up to a polylogarithmic factor since $D(G)$ and $\frac{k}{\delta(G)}$ are both straightforward lower bounds. 
    \end{remark}
    
    \begin{remark}
        The condition $p = \Omega(\frac{\log n}{n})$ is necessary, since for $p \leq \frac{\log n}{n}$, there is a constant probability that the graph is disconnected \cite{erd6s1960evolution}.
    \end{remark}
    
    To obtain Theorem \ref{thm:main}, we use the following result of independent interest:
    
    \begin{theorem} 
        \label{thm:building tree packing}
        For an {\graph} with $p \geq \frac{C_p\log n}{n}$, there exists a distributed randomized algorithm that produces a tree packing of size $\delta(G)$, height $\Tilde{O}(D(G))$ and weight $O(\sqrt{\log n})$ w.h.p.
    \end{theorem}
    
    We construct the latter algorithm by utilizing multiple Coalescing Branching Random Walks \cite{cooper2016coalescing} that run in parallel. To the best of our knowledge, this technique has never been used before in the context of distributed algorithms.
    
    Finally, to map the terrain of the problem, we prove its NP-hardness in the centralized case. Also, we provide an instance of a problem where $D(G)$ and $\frac{k}{minCut(G)}$ - two straightforward lower bounds for round complexity - are both $O(1)$, while the optimal round complexity is $\Omega(\sqrt{k})$.


    \section{Related Work}
    \textbf{Tree Packing.} The problem of tree packing has been extensively studied, as summarized in the survey by Palmer \cite{palmer2001spanning}. Foundational results in this area include those by Tutte \cite{tutte1961problem} and Nash-Williams \cite{nash1961edge}, who demonstrated that an undirected graph with edge connectivity $\lambda$ contains a tree packing of size $\lfloor \frac{\lambda}{2} \rfloor$. Edmond \cite{edmonds1972} extended this result to directed graphs, showing that such graphs always contain $\lambda$ pairwise edge-disjoint spanning trees rooted at a sender $s \in V$, where $\lambda$ is the minimum number of edges that must be removed to make some node unreachable from $s$. However, these results do not address the height of the tree packing.

    Chuzhoy et al. \cite{chuzhoy2020packing} tackled the challenge of finding tree packings with small height. They presented a randomized algorithm that, given an undirected graph with edge connectivity $\lambda$ and diameter $D$, outputs with high probability a tree packing of size $\lfloor \frac{\lambda}{2} \rfloor$, weight $2$, and height $O((101k \log n)^D)$.

    Tree packing on random graphs was studied by Gao et al. \cite{gao2014arboricity}, who showed that asymptotically almost surely, the size of a spanning tree packing of weight one for a {\graph} is $\min\left\{\delta(G), \frac{|E(G)|}{n - 1}\right\}$, which corresponds to two straightforward upper bounds.

    In the CONGEST model, tree packing was investigated by Censor-Hillel et al. \cite{censor2014distributed}. They proposed an algorithm to decompose an undirected graph with edge connectivity $\lambda$ into fractionally edge-disjoint weighted spanning trees with total weight $\lceil \frac{\lambda - 1}{2}\rceil$ in $\Tilde{O}(D + \sqrt{n\lambda})$ rounds. Furthermore, they proved a lower bound of $\Tilde{\Omega}(D + \sqrt{\frac{n}{\lambda}})$ on the number of rounds required for such a decomposition.

    
    \textbf{Network Information Flow.} The network information flow problem \cite{ahlswede2000network} is defined as follows. The network is a directed graph $G(V, E)$, with edge capacities $c: E \rightarrow \mathbb{R}_{\geq 0}$, a source node $s \in V$, and sink nodes $T \subseteq V$. The question is: at what maximal rate can the source send information so that all of the sinks receive that information at the same rate? In the case of a single sink $t$, the answer is given by the $\text{max-flow}(s, t)$. However, when there are multiple sinks $T$, the value $\min\limits_{t \in T} \text{max-flow}(s, t)$ may not be achievable if nodes are only allowed to relay information. In fact, the gap can be as large as a factor of $\Omega(\log n)$ \cite{jaggi2005polynomial}. Nevertheless, if intermediate nodes are allowed to send (linear \cite{li2003linear}) codes of the information they receive, then $\min\limits_{t \in T} \text{max-flow}(s, t)$ becomes achievable \cite{ahlswede2000network}. Notably, in the specific case where $T = V \setminus \{s\}$ (the setting considered in the present paper), the rate of $\min\limits_{t \in T} \text{max-flow}(s, t)$ becomes achievable without coding \cite{wu2004comparison}. The decentralized version of network information flow was studied in \cite{ho2003benefits, fragouli2004decentralized, ho2011universal}. The most relevant work in this direction is ``An asymptotically optimal push–pull method for multicasting over a random network`` \cite{swamy2013asymptotically} by Swamy et al., where authors establish an optimal algorithm for the case of random graphs whose radius is almost surely bounded by $3$. Our approach allows an expected radius to grow infinitely with $n$ \cite{chung2001diameter}.

    The key difference between the network information flow problem and the multi-message broadcast in CONGEST is that in our problem, the focus is on round complexity, whereas in the information flow problem, the solution is a "static" assignment of messages to edges.



    \textbf{Branching Random Walks in Networks.}
    The cover time of a random walk \cite{lawler2010random} on a graph is the time needed for a walk to visit each node at least once. Unfortunately, the expected value of this quantity is $\Omega(n\log n)$ even for a clique, making this primitive less useful in practical applications. Consequently, several attempts have been made to accelerate the cover time. Alon et al. \cite{alon2008many} proposed initiating multiple random walks from a single source. Subsequent work by Els\"asser and Sauerwald refined their bounds, demonstrating that $r$ random walks can yield a speed-up of $r$ times for many graph classes. Variations of multiple random walks have been applied in the CONGEST model to approximate the mixing time \cite{molla2017distributed}, perform leader election \cite{kutten2015sublinear, gilbert2018leader}, and evaluate network conductance \cite{fichtenberger2018two, batu2024all}.

    A branching random walk \cite{shi2015branching} (BRW) modifies the classical random walk by allowing nodes to emit multiple copies of a walk upon receipt, rather than simply relaying it. This branching behavior potentially leads to exponential growth in the number of walks traversing the graph, significantly reducing the cover time. Roche \cite{roche2017robust}, in his Ph.D. thesis ``Robust Local Algorithms for Communication and Stability in Distributed Networks`` [2017], utilized BRWs to maintain the expander topology of a network despite adversarial node deletions and insertions. Gerraoui et al. \cite{guerraoui2023inherent}, in ``On the Inherent Anonymity of Gossiping``, demonstrated that BRWs can enhance privacy by obscuring the source of gossip within a network. Recently, Aradhya et al. \cite{aradhya_et_al:LIPIcs.OPODIS.2024.36} in ``Distributed Branching Random Walks and Their Applications`` employed BRWs to address permutation routing problems on subnetworks in the CONGEST model.

    Despite these applications, to the best of our knowledge, the branching random walk remains underexplored in distributed computing and this work seeks to showcase its untapped potential.


    \section{Algorithm Overview}
    In this section, we provide a high-level overview of our algorithm, starting with its main building block: COBRA.
    
    \subsection{Coalescing-Branching Random Walk}
    The COalescing-BRAnching Random Walk (COBRA walk) was first introduced by Dutta et al. \cite{dutta2015coalescing} in their work "Coalescing-Branching Random Walks on Graphs" \cite{dutta2015coalescing}, with subsequent refinements presented in \cite{cooper2016coalescing, mitzenmacher2018better, berenbrin2018tight}. The COBRA walk is a generalization of the classical random walk, defined as follows: At round $0$, a source node $s \in V$ possesses a token. At round $r$, each node possessing a token selects $\kappa$ of its neighbors uniformly at random, sends a token copy to each of them, and these neighbors are said to possess a token at round $r + 1$. Here, $\kappa$, referred to as the \emph{branching factor}, can be generalized to any positive real number \cite{cooper2016coalescing}. When $\kappa = 1$, the COBRA walk reduces to the classical random walk. From now on, we consider $\kappa$ to always be $2$. It is important to note that if a node receives multiple tokens in a round, it behaves as if it has received only one token; it will still choose $\kappa$ neighbors uniformly at random. This property, where received tokens coalesce at a node, gives the primitive its name.

    Cooper et al. \cite{cooper2016coalescing} studied the cover time $T$ of the COBRA walk on regular expanders and obtained the following theorem which we use in our result

    \begin{theorem}[Cooper et al. \cite{cooper2016coalescing}]
        \label{thm:cooper cobra main}
        Let $G$ be a connected $n$-vertex regular graph. Let $\lambda_2$ be the second largest eigenvalue (in the absolute value) of the normalized adjacency matrix of $G$. Then 
        \begin{align*}
            T = O\left(\frac{\log n}{(1 - \lambda_2)^3}\right)
        \end{align*}
        with probability at least $1 - O(\frac{1}{n^2})$.
    \end{theorem}

    \begin{remark}
        In the paper, the bound on probability is $1 - O(\frac{1}{n})$, though the analysis, which is based on Chernoff's bounds, can be adapted so that the probability is $1 - O(n^C)$ for any constant $C$ and the cover time is only multiplied by a constant.
    \end{remark}

    In the upcoming analysis of our result, we will make sure that $\lambda_2$ is no more than $\frac{13}{14}$ w.h.p. Let $C_T$ be a sufficiently large constant so that a COBRA walk covers a regular graph with $\lambda_2 \leq \frac{13}{14}$ with probability at least $1 - O(\frac{1}{n^2})$ in $C_T\log n$ rounds. From now on, we define $T$ to be $C_T\log n$.


    

    \subsection{Algorithm Description}
    The algorithm proceeds through the following steps:
    
    \begin{enumerate}
        \item \textbf{Building a BFS Tree and Gathering Information:}
        Nodes construct a BFS tree rooted at source node $s$. Using the tree, every node learns the total number of nodes $|V|$, the minimum degree $\delta$, and the maximum degree $\Delta$. This step takes $O(D)$ rounds and does not require any prior knowledge of the graph topology.
    
        \item \textbf{Regularizing the Graph:}
        Each node $v$ adds $\Delta - \deg(v)$ self-loops to its adjacency list to make the graph regular. We will show in our analysis that each node adds a relatively small number of self-loops. This operation is purely local and requires no communication between nodes.
    
        \item \textbf{Constructing Spanning Subgraphs through Multiple COBRA Walks:}  
        The source node $s$ initiates $\delta$ COBRA walks by creating $\delta$ tokens labeled $1$ through $\delta$. When a token from the $i$-th COBRA walk is sent along an edge $e:\ (u, v)$, $u$ and $v$ mark $e$ as part of the $i$-th subgraph. Note that a single edge may belong to multiple subgraphs.
    
        When running multiple COBRA walks simultaneously, congestion can occur if a node attempts to send multiple tokens from different COBRA walks along the same edge in a single round. Since only one token can traverse an edge per round, this creates a bottleneck that needs to be managed. To address this, we organize the process into \emph{phases}, where each phase consists of $4\sqrt{\log n}$ rounds. During each phase, nodes handle the token distribution for a single round of all COBRA walks. We will show that the randomness in the process ensures that no edge is assigned more than $4\sqrt{\log n}$ tokens in a single phase, allowing the walks to proceed without interfering with each other.
 
    
        This step completes in $T$ phases.
    
        \item \textbf{Constructing Tree Packings:}  
        After $T$ phases, nodes stop sending tokens. The source $s$ initiates a BFS on each subgraph to transform it into a tree. By the end of this step, the algorithm constructs a tree packing $\{T_i\}_{i \in [\delta]}$. Since some edges might belong to multiple trees, this step takes the number of rounds that is at most the height of the highest tree times the maximal number of subgraphs a single edge belongs to, that is at most $T \cdot T \cdot 4\sqrt{\log n } = \Tilde{O}(1)$.
    
        \item \textbf{Distributing Messages: }
        The source node $s$ evenly divides the set of messages $M$ across the $\delta$ trees, ensuring that each tree receives $\frac{k}{\delta}$ messages. These messages are then downcasted along the trees one by one. To broadcast $k$ messages using the tree packing of size $\delta$, height $O(T)$ and weight $O(T\cdot \sqrt{\log n})$ we spend $O(T\cdot \sqrt{\log n} \cdot (\frac{k}{\delta} + T))$ rounds.
    \end{enumerate}

    \section{Proof}
    In this section, we formally state all our main results and their auxiliaries. We start by providing a high level proof.
    \subsection{Proof Outline}
    The proof proceeds in three main steps. First, we show that after making a random graph regular by adding self-loops, it retains its expansion properties. To achieve this, we use the following results. Theorem \ref{thm:hoffman lambda2} by Hoffman et al. demonstrates that a random graph is a good expander w.h.p. Lemma \ref{lem:deg dif}, using Chernoff bounds, establishes that a random graph is almost regular w.h.p., that is $\frac{\Delta}{\delta}$ is close to $1$. Finally, Lemma \ref{lem:eigenvalue shift}, based on Weyl's theorem, shows that small perturbations to the diagonal elements of a matrix result in small perturbations to its eigenvalues. Combining these results, we conclude that regularizing the graph does not significantly impact its expansion properties.
    
    The second step is to prove that each individual COBRA walk successfully covers the entire network. Lemma \ref{lem:multi-cobra passes phases} ensures that w.h.p., in each phase, every node successfully distributes its tokens, ensuring that no edge is overloaded with more than $4\sqrt{\log n}$ tokens. Using this, Theorem \ref{thm:cooper cobra main} by Cooper et al., together with a union bound, guarantees that all COBRA walks complete successfully within $O(\log n)$ phases w.h.p.
    
    In the final step, we argue that the algorithm produces a tree packing with size $\delta(G)$, height $O(\log n)$, and weight $O(\log^{2.5} n)$. This tree packing allows for broadcasting all messages in $\Tilde{O}(\frac{k}{\delta(G)})$ rounds. This is optimal up to a polylogarithmic factor, as $\frac{k}{\delta(G)}$ provides a natural lower bound for the broadcast time.


    \subsection{Introducing Regularity while Maintaining Expansion}
    \label{sec:regularity + expansion}
    We start by providing relevant concepts from spectral theory. 
    \begin{definition}
        Let $A$ be an $n \times n$ matrix with entries from $\mathbb{R}_{\geq 0}$ and let $D$ be a diagonal matrix such that $D_{ii} = \sum\limits_{j \in [n]}A_{ij}$. Assuming $D_{ii} > 0$ for all $i \in [n]$, let $\overline{A}$ denote a normalized version of $A$, i.e. $\overline{A} = D^{-1/2}AD^{-1/2}$.
    \end{definition}
    \begin{definition}
        Let $A$ be an $n\times n$ matrix. Define $\lambda_2(A)$ to be the second largest (in absolute value) eigenvalue of $A$. Let $G$ be an undirected multi-graph and $A$ be its weighted adjacency matrix. Define $\lambda_2(G)$ as $\lambda_2(\overline{A})$. 
    \end{definition}

    \begin{theorem}[Hoffman et al. \cite{hoffman2021spectral}]
        \label{thm:hoffman lambda2}
        For a positive constant $C$ and $p \geq \frac{C\log n}{n}$, consider an \graph. Then, with probability at least $1 - O(\frac{1}{n^{C - 1}})$ we have $\lambda_2(G) = O(\frac{1}{\sqrt{pn}})$.
    \end{theorem} 

    The following Lemma shows that with high probability an {\graph} is almost regular. 

    \begin{lemma}
        \label{lem:deg dif}
        Let $p \geq \frac{C_p \log n}{n - 1}$. Then for an \graph, $\frac{\Delta(G)}{\delta(G)} \leq 1 + \frac{1}{7}$ with probability at least $1 - O(\frac{1}{n^2})$.
    \end{lemma}
    \begin{proof}
        Let us fix a vertex $v$ and consider the number of edges it might have. For each potential edge $e_i$, $i \in [n - 1]$ let us introduce an indicator variable $\chi_i$ which is equal to $1$ if the edge exists and to $0$ if it does not. The number of edges $v$ has is then $\sum\limits_{i \in [n - 1]}\chi_i$. The expectation of that is $p(n - 1)$ and applying Chernoff's bounds we get 
        \begin{align*}
            Pr\left[deg(v) \geq (1 + \frac{1}{15})C_p\log n\right] \leq \exp\left(-\frac{C_p\log n}{675}\right) \leq \frac{1}{2n^3}
        \end{align*}
        and 
        \begin{align*}
            Pr\left[deg(v) \leq (1 - \frac{1}{15})C_p\log n\right] \leq \exp\left(-\frac{C_p\log n}{675}\right) \leq \frac{1}{2n^3}
        \end{align*}
        Now, taking union bound over all vertices, we conclude that for every vertex $v$ it has $(1 - \frac{1}{15})C_p\log n \leq deg(v) \leq (1 + \frac{1}{15})C_p\log n$ with probability at least $1 - \frac{1}{n^2}$ and thus with that probability $\frac{\Delta(G)}{\delta(G)} \leq \frac{1 + \frac{1}{15}}{1 - \frac{1}{15}} = 1 + \frac{1}{7}$
    \end{proof}

    The next ingredient is to show that the slight perturbation of diagonal elements of the matrix induces only a little change on its eigenvalues. 
    
    \begin{lemma}
        \label{lem:eigenvalue shift}
        Let $A$ be an $n \times n$ adjacency matrix of a connected graph and let $D$ be a diagonal matrix such that $D_{ii} = \sum\limits_{j \in [n]}A_{ij}$. Let $E$ be a $n \times n$ diagonal matrix such that $0 \leq E_{ii} \leq \varepsilon$ for some $0 < \varepsilon < 1$ and all $i \in [n]$.

        Then $\lambda_2(\overline{A + DE}) \leq \lambda_2(\overline{A}) + 6\varepsilon$.
    \end{lemma}
    \begin{proof}[Proof sketch.]
        The idea of the proof is to express $\overline{A + DE}$ as a sum of $\overline{A}$ and matrices with the small spectral norms and then apply a corollary of Weyl's theorem, that is for $n\times n$ matrices $M_1$ and $M_2$
        \begin{align*}
            |\lambda_2(M_1 + M_2) - \lambda_2(M_1)| \leq ||M_2||_2
        \end{align*}
        The full proof can be found in Appendix \ref{sec:appendix:proofs}.
    \end{proof}

    Finally, using Lemmas \ref{lem:deg dif} and \ref{lem:eigenvalue shift} alongside the Theorem \ref{thm:hoffman lambda2} we show that w.h.p. regularizing an {\graph} by adding self-loops for every node to reach $\Delta(G)$ does not ruin its expansion properties.
    
    \begin{lemma}
        \label{lem:get good graph}
        With probability at least $1 - O(\frac{1}{n^2})$, for $p \geq \frac{C_p\log n}{n - 1}$, an {\graph} can be transformed into $G'$ by adding weighted self-loops to the nodes so that (1) $G'$ is regular, (2) $1 - \lambda_2(G') \geq \frac{1}{14}$.
    \end{lemma}
    \begin{proof}
        Let $A$ be the adjacency matrix of $G$, $D$ be the degree matrix of $G$ and $E$ be the $n \times n$ diagonal matrix with entries $E_{ii} = \frac{\Delta(G)}{deg(v_i)} - 1$.  By the Lemma \ref{lem:deg dif}, with probability $1 - O(\frac{1}{n^2})$, $G$ has $\frac{\Delta}{\delta} \leq 1 + \frac{1}{7}$ and therefore, $E_{ii} \leq \frac{1}{7}$ for all $i \in [n]$ with probability $1 - O(\frac{1}{n^2})$.
    
        Now, to each vertex $v$ in $G$, add $\Delta - deg(v)$ self-loops to obtain a graph $G'$. Clearly, $G'$ is $\Delta(G)$-regular. The adjacency matrix of $G'$ will then be $A + DE$ and hence, applying Lemma \ref{lem:eigenvalue shift} we deduce that $\lambda_2(G') \leq \lambda_2(G) + \frac{6}{7}$.
        
        By the Theorem \ref{thm:hoffman lambda2}, we know that with probability $1 - O(\frac{1}{n^2})$, $\lambda_2(G) \leq \frac{C}{\sqrt{p(n - 1)}}$ for some constant $C$, which for large enough $n$ is less than $\frac{1}{14}$, thus $\lambda_2(G') \leq \frac{13}{14}$.
    \end{proof}



    

    \subsection{Success of Multiple COBRAs}
    \label{sec:cobra analysis}
    When multiple COBRA walks run in parallel, a given node might send multiple tokens along the single edge in one round. That is not feasible due to the congestion, hence we allocate $4\sqrt{\log n}$ rounds for each node to distribute its tokens. One phase corresponds to one round of individual COBRA.
    \begin{definition}
        We say that a \emph{phase} is $4\sqrt{\log n}$ rounds. 
    \end{definition}

    The quantity of $4\sqrt{\log n}$ is chosen so that every node manages to distribute its tokens w.h.p. Though, it is not guaranteed. To refer to this aspect of our algorithm, we introduce the following term.
    
    \begin{definition}
        We say that multi-COBRA \emph{passes} a phase if every node decides to send no more than $4\sqrt{\log n}$ tokens along a single edge in that phase.  
    \end{definition}

    We now formally state that the concept of a phase helps to avoid congestion and we justify the choice of the quantity $4\sqrt{\log n}$.
    
    \begin{lemma}
        \label{lem:multi-cobra passes phases}
        With probability $1 - O(\frac{\log n}{n^8})$ multi-COBRA passes all $T$ phases.  
    \end{lemma}
    \begin{proof}
        Let us fix a phase and a vertex $v$. By the design of the algorithm, $v$ has $t \leq 2\delta(G)$ tokens to send in the phase and $\Delta(G)$ adjacent edges. Let us fix an edge $e$ and define an indicator variable $\chi_i$ that is $1$ in case the $i$-th token is sent along $e$ and $0$ otherwise. Denote $t_e = \sum\limits_{i \in [t]}\chi_i$. This way, the expected number of tokens sent along $e$ in one phase is $E\left[t_e\right] \leq t \cdot \frac{1}{\Delta(G)} \leq 2$. Now, by Chernoff's bounds
        \begin{align*}
            Pr\left[t_e \geq (1 + 4\sqrt{\log n})\cdot 2\right] \leq \exp\left(-\frac{16\log n\cdot2}{3}\right) \leq \frac{1}{n^{10}}
        \end{align*}
    
        Since the degree of each node is at most $n$, there are at most $n^2$ edges. Hence, taking a union bound over all edges, we obtain that among every edge at most $4\sqrt{\log n}$ tokens are sent per phase with probability at least $1 - \frac{1}{n^8}$. Finally, taking a union bound over all phases, we get that multi-COBRA passes all of them with probability $1 - O(\frac{\log n}{n^8})$.
    \end{proof}

    To conclude the analysis of multi-COBRA's performance on a random graph, we compile our knowledge from sections \ref{sec:regularity + expansion} and \ref{sec:cobra analysis} and get the following Lemma. 
    \begin{lemma}
        \label{lem:cobra compile}
        If the initial network graph is an {\graph} with $p \geq \frac{C_p\log n}{n}$, multi-COBRA passes all $T$ phases and each individual COBRA walk covers the whole graph in $O(T\sqrt{\log n})$ rounds with probability at least $1 - O(\frac{1}{n})$. 
    \end{lemma}
    \begin{proof}
        By Lemma \ref{lem:get good graph} we know that $G'$ - the graph we obtain from $G$ after adding self loops - has $1 - \lambda_2(G') \geq \frac{1}{14}$ with probability at least $1 - O(\frac{1}{n^2})$.  
        Therefore, according to Theorem \ref{thm:cooper cobra main}, a COBRA walk succeeds to cover $G'$ in $O(\frac{\log n}{(1 - \lambda_2(G'))^3}) = O(T) = O(\log n)$ rounds with probability at least $1 - O(\frac{1}{n^2})$. Hence, by the union bound, $\delta(G) \leq n$ COBRAs succeed in $O(\log n)$ phases with probability at least $1 - O(\frac{1}{n})$ if run independently. Lemma \ref{lem:multi-cobra passes phases} tells us that walks do not interfere with each other with probability at least $1 - O(\frac{\log n}{n^8})$, meaning that the statement of the current Lemma holds with probability at least $1 - O(\frac{1}{n}) - O(\frac{\log n}{n^8}) = 1 - O(\frac{1}{n})$.
    \end{proof}

    \begin{remark}
        The analysis in \cite{cooper2016coalescing} is done for simple graphs (i.e. graphs not featuring self-loops). However, the arguments apply verbatim, with symbols reinterpreted to mean the number of outgoing edges of a node instead of the number of neighbors. 
    \end{remark}

    

    \subsection{Tree Packing and Broadcast}

    In this section, we show how to obtain a tree packing from multi-COBRA's edge assignment and describe how we use this tree packing to broadcast the messages. 

    The following two Lemmas speak about the properties of the spanning graphs obtained via multi-COBRA.
    \begin{lemma}
        \label{lem:low edge weight}
        After multi-COBRA passes all $T$ phases, every edge of the graph belongs to at most $O(T\sqrt{\log n})$ subgraphs.
    \end{lemma}
    \begin{proof}
        At each phase, an edge is assigned to at most $4\sqrt{\log n}$ subgraphs and there are $T$ phases.
    \end{proof}

    \begin{lemma}
        \label{lem:low diameter}
        After multi-COBRA passes all $T$ phases, each subgraph has a diameter of $O(\log n)$.
    \end{lemma}
    \begin{proof}
        The multi-COBRA runs for $T = O(\log n)$ phases and in each phase, we add to each subgraph only those nodes that are neighbors of the nodes already included. Consequently, the diameter of the subgraph increases by at most two per phase.
    \end{proof}

    In the rest of this section, we will run protocols on all the subgraphs in parallel. To achieve this despite potential congestion (recall that each edge may belong to multiple subgraphs), we again organize the execution into phases. Each phase spans $4\sqrt{\log n}$ rounds, ensuring that messages sent along any shared edge are distributed across the protocols without conflict. Specifically, if a protocol would send a message along an edge in a particular round when executed independently, all such messages from different subgraphs are scheduled within the same phase. This phased execution allows all protocols to proceed in parallel while respecting the edge capacity. As a result, the combined round complexity of the protocols increases by at most a factor of $4\sqrt{\log n}$ compared to running an individual protocol.

    We are now ready to prove Theorem \ref{thm:building tree packing}.
    \begin{proof}[Proof of Theorem \ref{thm:building tree packing}]
        The algorithm goes as follows. First, let nodes share the information of $n$, $\delta$ and $\Delta$. This can be done in $O(D)$ rounds by constructing a BFS tree. Next, every node $v$ adds $\Delta - deg(v)$ self-loops. Then, parties run multi-COBRA for $T$ rounds that by Lemma \ref{lem:cobra compile} result with probability at least $1 - O(\frac{1}{n})$ in $\delta$ spanning subgraphs $\{S_i\}_{i \in [\delta]}$. By Lemma \ref{lem:low diameter}, those have diameter $O(\log n)$. Moreover, by Lemma \ref{lem:low edge weight} every edge of the graph belongs to at most $4\sqrt{\log n}$ subgraphs. 

        Now, we launch BFSs on all subgraphs in parallel to turn them into spanning trees. As discussed earlier in this section, this can be done in $O(4\sqrt{\log n} \cdot \max\limits_{i \in [\delta]}D(S_i)) = O(\log^{1.5}n)$ rounds. As a result of doing so, the weight of every edge could only have decreased, and the diameter of each subgraph at most doubled. 
    \end{proof}

    Having a tree packing with the properties described, we can prove Theorem \ref{thm:main} by adding a final piece.

    \begin{proof}[Proof of Theorem \ref{thm:main}]
        First, build a tree packing from Theorem \ref{thm:building tree packing}. Then, $s$ evenly distributes messages among trees, so that each tree receives $\frac{k}{\delta}$ messages. After that, in each tree, nodes downcast corresponding messages. The algorithm for downcasting messages $\{m_1, \ldots, m_k\}$ from the root of a single tree works as follows. In the first round, the root sends the first message (\(m_1\)) to all its immediate children. In the second round, the children forward \(m_1\) to their respective children (the root's grandchildren), while the root simultaneously sends the second message (\(m_2\)) to its immediate children. This process continues iteratively: in each subsequent round, the root sends the next message (\(m_i\)) to its children, and all other nodes forward the message they received in the previous round to their respective children. This way, for $k'$ messages and a tree of height $h$ it takes $h + k' - 1$ rounds for every node to discover every message. 

        Multiplying by a congestion factor of $4\sqrt{\log n}$, we get that the round complexity of broadcasting $k$ messages in $\delta(G)$ spanning trees of height $O(D(G))$ is 
        \begin{align*}
            O(4\sqrt{\log n} \cdot (\frac{k}{\delta(G)} + D(G))) = \Tilde{O}(\frac{k}{\delta(G)} + D(G))
        \end{align*}
    \end{proof}

    \begin{remark}
        \label{rem:single source}
        In \cite{ghaffari2015distributed, chandra2024fast}, authors consider a problem where initially messages are spread over the network, that is every node possesses a subset of $M$. This seems like a more general version, however, when using a tree packing approach, these two problems are equivalent. The intuition is, nodes can first agree on the distribution of messages among trees, then upcast the messages to the root in their corresponding trees, and finally perform a downcast as described in our paper, all that in $\Tilde{O}(D(G) + \frac{k}{\delta(G)})$. For the full proof, a reader is invited to see the proof of Theorem 1 in \cite{chandra2024fast}.
    \end{remark}



\section{Sketching the terrain}
\subsection{NP-Hardness}
We prove that the multi-message broadcast problem in CONGEST is NP-hard in the centralized setting. To do that, we reduce the Set splitting problem.
\begin{definition}[Set splitting problem]
     Given a family $F$ of subsets of a finite set $S$, decide whether there exists a partition of $S$ into two subsets $S_1$, $S_2$ such that all elements of $F$ are split by this partition, i.e., none of the elements of F is completely in $S_1$ or $S_2$.
\end{definition}

In our reduction, for simplicity of presentation, we allow edges to have arbitrary bandwidth instead of $\Tilde{O}(1)$, since, as we show, this can be simulated in CONGEST. In the reduction the initial set $S$ corresponds to the set $M$ of messages and $s$ has two dedicated children to which it can send $n_1$ and $n_2$ messages respectively with $n_1 + n_2 = k$, simulating the splitting. Deciding how to split messages between these two children is the only ``smart`` choice an algorithm should make, all other nodes are just forwarding messages they receive. For the full version of the proof, please see Appendix \ref{sec:appendix:np-hardness}.


\subsection{Straightforward Lower Bounds are not Enough}
\begin{wrapfigure}{r}{0.3\textwidth} 
    \vspace{-20pt}
    \centering
    \includegraphics[width=0.28\textwidth]{pics/new_lowerbound.png}
    \vspace{-10pt}
    \caption{An example where diameter and minimum cut are not telling. Here edge labels denote bandwidth.}
    \label{fig:no simple lower bounds}
\end{wrapfigure}

It is tempting to argue for an approximation factor of an algorithm by comparing its round complexity to two straightforward lower bounds: $D(G)$ and $\frac{k}{minCut(G)}$. 
Unfortunately, those are not sufficient as there is an instance (see Figure \ref{fig:no simple lower bounds}) where $D(G) = O(1)$ and $\frac{k}{minCut(G)} = O(1)$, but the optimal answer is $\Omega(\sqrt{k})$. As for NP-hardness, we consider a more general model where edges might have arbitrary bandwidth, but we show that this can be simulated in CONGEST. For details, please see Appendix \ref{sec:appendix:Straightforward Lower Bounds are not Enough}.

\clearpage
\newpage
\bibliographystyle{splncs04}
\bibliography{refs}
\newpage

\appendix



\section{Straightforward Lower Bounds are not Enough}
\label{sec:appendix:Straightforward Lower Bounds are not Enough}

\begin{wrapfigure}{r}{0.5\textwidth}
    \centering
    \includegraphics[width=0.48\textwidth]{pics/simulating_big_bandwidth.png}
    \vspace{-10pt}
    \caption{An example of mapping a graph with arbitrary bandwidths to a graph suitable for CONGEST.}
    \label{fig:simulating big bandwidth}
\end{wrapfigure}
In this section, it will be more comfortable for us to consider a more general model than CONGEST, namely the model where edges have arbitrary bandwidth. To transform a graph with arbitrary bandwidths to a graph with all bandwidths equal to $1$, we do the following. The source $s$ corresponds to a single node in the new graph. For a node $v \neq s$ in the original graph, let $B$ denote the maximal bandwidth of its adjacent edges. In the new graph, node $v$ then corresponds to a clique of $B$ nodes. We call this clique a $v$-clique. If in the original graph nodes $v \neq s$ and $u \neq s$ were connected by an edge of bandwidth $b$, we pick (arbitrary) $b$ nodes in $v$-clique, $b$ nodes in $u$-clique and draw $b$ edges between picked nodes to establish a perfect matching. For every edge $(s, u)$ of bandwidth $b$, we connect the new source with $b$ arbitrary nodes of the $u$-clique. We call the resulting graph \emph{the corresponding CONGEST graph}.

\begin{claim}
    \label{clm:small diameter change}
    Consider the original graph $G$ and its corresponding CONGEST graph $G'$. Then\\
    $D(G) \leq D(G') \leq 2D(G) + 1$.
\end{claim}
\begin{proof}[Proof idea]
    The first inequality is straightforward. We prove the second inequality by induction on the length of the path, that is if there is a path in $G$ from $u$ to $v$ of length $l$, then for any nodes $u'$ and $v'$ in $u$-clique and $v$-clique respectively, there is a path between $u'$ and $v'$ in $G'$ of length $2l + 1$.
\end{proof}

\begin{claim}
    \label{clm:small minuct change}
    Consider the original graph $G$ and its corresponding CONGEST graph $G'$. Then\\
    $\min\{minCut(G), \min\limits_{v \in V(G) \setminus \{s\}}  \text{size of the $v$-clique} - 1 \}\leq minCut(G') \leq minCut(G)$.
\end{claim}
\begin{proof}
    The second inequality is straightforward. For the first inequality, note that each cut of $G'$ either cuts some clique or does not. In case it does not, it corresponds to a cut in $G$ and has the same size. In case it does, it is at least the size of the induced cut for that clique, which is at least $\min\limits_{v \in V(G) \setminus \{s\}}  \text{size of the $v$-clique} - 1$.
\end{proof}

% \begin{claim}
%     \label{clm:small round complexity change}
%     If all the nodes can discover $M$ in $R$ rounds in the graph $G$ with arbitrary bandwidths following the execution $E$, then all the nods can discover $M$ in $(\Delta(G \setminus s) + 1)R$ rounds in the corresponding CONGEST graph.
% \end{claim}
% \begin{proof}
%     Denote $\Delta := \Delta(G \setminus s)$.
%     We describe an execution $E'$ for a corresponding CONGEST graph. We maintain the invariant that after $(\Delta + 1)t$ rounds of $E'$, all the nodes in the $u$-clique know the same set of messages that $u$ knows after $t$ rounds of $E$. To maintain this invariant, for each round $r$ of $E$ (we enumerate rounds starting from $0$), we do the following in $E'$. If $u$ sends to $v$ $b$ messages in round $r$ in $E$, nodes of $u$-clique that are connected to the nods of $v$-clique send in the round $(\Delta + 1)r$ the same messages to their partners in $v$-clique (note that they can do so since there are at least $b$ of them and all of them know all the messages that are sent). In the rounds $[(\Delta + 1)r + 1, (\Delta + 1)(r + 1))$ each node in each clique broadcasts messages it received in round $(\Delta + 1)r$ to its neighbors in the clique. Since it could have only received $\Delta$ messages, $(\Delta + 1)(r + 1) - ((\Delta + 1)r + 1) = \Delta$ rounds suffice.
% \end{proof}

\begin{claim}
    \label{clm:small round complexity change}
    Consider the original graph $G$ and its corresponding CONGEST graph $G'$. Together with set $M$ of messages, they define a multi-message broadcast problem in generalized CONGEST and CONGEST respectively. Let $OPT(G)$ and $OPT(G')$ denote the optimal round complexities for $G$ and $G'$ respectively. Then $OPT(G) \leq OPT(G')$.
\end{claim}
\begin{proof}
    Consider an execution $E'$ for $G'$ which achieves $OPT$. We claim that we can build an execution $E$ for $G$, such that for every round $r$ of $E'$ and for every $v \in V(G)$, after round $r$ in $E$ $v$ knows all the messages that know the nodes of $v$-clique after round $r$ in $E'$. To do so, consider round $r$ and some $v \in V(G)$. Let us say that nodes in $v$-clique in $E'$ in round $r$ receive messages $M_1$ from the $u_1$-clique, messages $M_2$ from $u_2$-clique and so forth for all neighboring cliques. Then, in $E$ $u_i$ sends $M_i$ to $v$ satisfying the invariant. Note that $u_i$ can do this in terms of the bandwidth by construction of the corresponding CONGEST graph, and in terms of knowing $M_i$ by the invariant.  
\end{proof}


\begin{wrapfigure}{r}{0.3\textwidth} 
    \vspace{-20pt}
    \centering
    \includegraphics[width=0.28\textwidth]{pics/new_lowerbound.png}
    \vspace{-10pt}
    \caption{An example graph $G$ where diameter and minimum cut are not telling. Here edge labels denote bandwidth.}
    \label{fig:no simple lower bounds appendix}
\end{wrapfigure}

We now give an example of an instance of a problem where $D(G) = O(1)$ as well as $\frac{k}{minCut(G)} = O(1)$, but the optimal round complexity is $\Omega({\sqrt{k}})$. The graph we consider is the corresponding CONGEST graph $G'$ to the graph $G$ depicted in Figure \ref{fig:no simple lower bounds appendix}. 

First, note that $D(G) = 4$, hence by Claim \ref{clm:small diameter change}, $D(G') = O(1)$. Second, notice that $minCut(G) = m$ and the minimal maximal bandwidth of an edge adjacent to some node in $V(G) \setminus \{s\}$ is equal to $m$, therefore, by Claim \ref{clm:small minuct change}, $m - 1 \leq minCut(G') \leq m$. Finally, note that $\Delta(G \setminus s) = 3$, hence by Claim \ref{clm:small round complexity change}, $OPT(G') \geq OPT(G)$, where $OPT$ is the optimal round complexity. Therefore, it is sufficient to show that $OPT(G) = \Omega(\sqrt{m})$. 

To see this, let us label the ``bottom`` nodes of $G$ as $t_1, t_2, \ldots, t_m$, and let us focus on $t_1$. We claim that $\Omega(\sqrt{m})$ rounds are needed for $t_1$ only to get to know $M$ (become saturated). For the sake of contradiction, assume that we can saturate $t_1$ in $\leq \sqrt{m} - 1$ rounds. That means, that it can be saturated without using the edges $(v_{\sqrt{m} + 1}, t_{\sqrt{m} + 1})$ and $(v_{\sqrt{m} + 1}, t_{\sqrt{m} + 2})$. But if we remove those edges, $minCut(s, t_1) \leq \sqrt{m}$, implying that the number of rounds needed is at least $\frac{m}{\sqrt{m}} = \sqrt{m}$, a contradiction.



\section{NP-hardness}
\label{sec:appendix:np-hardness}
To show the NP-hardness of a multi-message broadcast problem, we will also use a generalization of CONGEST that allows for arbitrary edge bandwidth, though this time the construction is different. In this section, we will consider a specific layered graph with layers induced by the distance from $s$. In that graph all edges connect nodes of consecutive layers. This graph has arbitrarily large bandwidths assigned to its edges, so we transform it into a graph with unit bandwidths by doing the following. For each node $v$ on layer $0 < l < \text{max layer}$, we crea te a group of $n$ nodes called $v_{out}$, where $n$ denotes the number of messages (we change the notation due to reduction). Then, for every edge $(u, v)$ of the original graph, where $u$ belongs to the previous layer ($l - 1$), if that edge has bandwidth $b \leq n$, we create a group of $b$ nodes called $v_{u-in}$ and we connect arbitrary $b$ nodes of $u_{out}$ 1 to 1 to node of $v_{u-in}$. For every $u$ we connect every node of $v_{u-in}$ to every node of $v_{out}$. For node $s$, we replace it with a new sink $s'$ and create a $K_{n, n}$ with its first half called $s_{in}$ and its second half called $s_{out}$. We then connect $s'$ to all the nodes in $s_{in}$ and we connect all the nodes of $s_{out}$ to the $in$-s of the nodes $s$ is connected to in the original graph in a way described above. For all the nodes of the last layer, we keep them a single node and draw all the incoming edges to this node. We call the resulting graph of this transformation the \emph{transformed} graph. Please see Figure \ref{fig:transform for np} for an example. 
\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{pics/simulating_for_np.png}
    \caption{Example of transforming a layered graph with arbitrary bandwidths into the graph suitable for CONGEST. Here the number of messages $n$ is $3$.}
    \label{fig:transform for np}
\end{figure}

\begin{claim}
    \label{clm:np equivalence}
    Consider a layered graph $G$ with arbitrary bandwidths and $G'$ being its transformed version. Denote $l$ to be the depth of $G$ and let $T$ be the set of nodes in $G$ in layer $l$. Then it is possible to saturate all nodes in $T$ in $l$ rounds in $G$ if and only if it is possible to saturate all nodes in $T$ in $2l + 1$ rounds in $G'$.
\end{claim}
\begin{proof}
    Consider an execution $E$ for $G$ in which all nodes in $T$ are saturated in $l$ rounds. We build an execution $E'$ for $G'$ that satisfies the following invariant: for $0 \leq r < l$, after $2r + 2$ rounds of $E'$, for every node $v \in V(G)$ such that $v$ is in layer $t \leq r$, nodes in $v_{out}$ know the same set of messages in $E'$ as $v$ knows in $E$ after round $r$. For $r = 0$, we make $s'$ send all messages to $s_{in}$ (a distinct message to each node) and $s_{in}$ to relay those messages to $s_{out}$. Then, if in round $r > 0$ in $E$ $u$ sends $v$ $b$ messages, $u_{out}$ send $v_{u-in}$ those $b$ messages and then $v_{u-in}$ relay those to $v_{out}$. In the final $l$-th round of $E$, nodes of $G$ send messages to $t_i \in T$. This can be simulated in $E'$ within one round, making it $2(l - 1) + 2 = 2l$ rounds to reach $v_{out}$ for all $v$-s in layer $l - 1$ and $1$ more round to saturate $T$.

    The proof of the other direction proceeds analogously maintaining the invariant that every node $v \in V(G)$ in $E$ after $r$ rounds knows all the messages that $v_{out}$ knows in $E'$ after $2r + 2$ rounds. 
\end{proof}

\begin{theorem}
    The multi-message broadcast problem is NP-hard in a centralized setting.
\end{theorem}
\begin{proof}
    We reduce the Set splitting problem: given a family $F$ of subsets of a finite set $S$, decide whether there exists a partition of $S$ into two subsets $S_1$, $S_2$ such that all elements of $F$ are split by this partition, i.e., none of the elements of $F$ is completely in $S_1$ or $S_2$.

    Denote $n := |S|$, $m := |F|$. We start creating a reduction graph by creating a source node $s$ and assigning it a set of messages corresponding to elements in $S$: $\{m_1, \ldots, m_n\}$. We also create $n$ nodes $v_1, \ldots, v_n$ with edges $(s, v_i)$ of bandwidth $1$. Intuitively, we want every $v_i$ to hold $m_i$ after the first round. 

    We create nodes that correspond to the elements of $F$: $F_1, \ldots F_m$ and we draw an edge $(v_i, F_j)$ of bandwidth $1$ iff $S[i] \in F[j]$. This way, after round two, $F_i$ will possess messages that correspond to the elements of $F[i]$. 

    With a slight abuse of notation, we introduce two other nodes, namely $S_1$ and $S_2$ that intuitively correspond to a partition of $S$. We focus on solving the set partition problem for the given size of the parts, i.e. $|S_1| = n_1$ and $|S_2| = n_2$ with $n_1 + n_2 = n$. Obviously, this version is also NP-complete. We draw an edge $(s, S_1)$ of bandwidth $n_1$ and $(s, S_2)$ of bandwidth $n_2$. We want $S_1$ and $S_2$ to be in layer $2$, so we introduce intermediate nodes on those edges whose role will simply be to relay messages.  

    Now, we introduce nodes $u_{i, 1}, u_{i, 2}$ for $i \in [m]$. We draw following edges: $(F_i, u_{i,1})$ with bandwidth $|F_i|$, $(S_1, u_{i, 1})$ with bandwidth $n_1$. Similarly, for $u_{i, 2}$ we draw $(F_i, u_{i, 2})$ with bandwidth $|F_i|$ and $(S_2, u_{i, 2})$ with bandwidth $n_2$. Intuitively, $u_{i, 1}$ serves the meaning of the union of $F[i]$ and $S_1$. 

    We introduce nodes $t_{i, 1}$ and $t_{i, 2}$ for $i \in [m]$. For $i \in [m]$ we draw an edge $(u_{i, 1}, t_{i,1})$  of bandwidth $n$ and, and this is the crux of the reduction, an edge $(s, t_{i, 1})$ of bandwidth $n - n_1 \mathbf{- 1}$ and of length $4$ (with $3$ intermediate nodes). The idea here is that $t_{i, 1}$ can be saturated after round $4$ if and only if it receives more than $n_1$ messages from $u_{i, 1}$ implying $F[i] \not\subset S_1$. Similarly, we do for $S_2$. See the resulting construction in Figure \ref{fig:np construction}.

    % Finally, we introduce a part that breaks the ``layeriarity`` of a graph and intuitively serves the purpose of being able to saturate all the nodes but those on the last layer in $4$ rounds. That is, we introduce a node $b$ and an edge of length $3$ and bandwidth $n$ to it from $s$. We then connect $b$ to all the nodes but those on the last layer with edges of bandwidth $n$. 

    \begin{figure}
        \centering
        \includegraphics[width=0.9\linewidth]{pics/np_construction.png}
        \caption{Graph $G$ with arbitrary bandwidths for which it is NP-hard to optimally solve multi-message broadcast. Some nodes are depicted in gray since they serve no other purpose but to layer the graph and in reasonable executions should only relay messages.}
        \label{fig:np construction}
    \end{figure}

    If we now consider a transformed graph $G'$, we want to focus on saturating nodes in $T = \{t_{11}, t_{12}, \ldots, t_{m1}, t_{m2}\}$, though in multi-message broadcast problem the goal is to saturate \emph{all} nodes. To account for that, for each node $v \in V(G') \setminus T$, we will make sure that it can be saturated in $9$ rounds. We do that by introducing a path of length $9$ and bandwidth $n$ from $s$ to $v$. In particular, each such path has $6$ intermediate layers of $n$ nodes each. Each node in the first layer is connected to each node in $s_{out}$. Each node in layer $1 < l \leq 6$ is connected to each node in layer $l - 1$, and $v$ is connected to each node in layer $6$. This way we obtain graph $G''$. Note that introducing these additional paths does not help saturating $T$ in less than $9$ rounds, that is $T$ can be saturated in $9$ rounds in $G''$ iff it can be saturated in $9$ rounds in $G'$.
    
    This observations combined with Claim \ref{clm:np equivalence} allow us to establish the following sequence of equivalent statements ($\Leftrightarrow$ denotes equivalence):\\
    (I) The set splitting for $S$ and $F_1, \ldots, F_m$ is possible $\Leftrightarrow$\\
    (II) Saturating $T$ in $G$ in $4$ rounds is possible $\Leftrightarrow$\\
    (III) Saturating $T$ in $G'$ in $9$ rounds is possible $\Leftrightarrow$\\
    (IV) Solving the multi-message broadcast in $9$ rounds in $G''$ is possible.

    The equivalence of (II) and (III) is Claim \ref{clm:np equivalence}. The equivalence of (III) and (IV) is discussed above. Hence, leaving the details of those unspecified, we focus on the informative part - the equivalence of (I) and (II). 

    First, assume it is possible to split $S$ and this splitting is $S_1$ and $S_2$. Then we claim it is possible to saturate $T$ in $G$ in $4$ rounds. To do so, let $s$ send $\{m_i \mid i \in S_1\}$ to $S_1$ and $\{m_i \mid i \in S_2\}$ to $S_2$. Also, let it send $m_i$ to $v_i$ and to $t_{ij}$, $i \in [m]$, $j \in \{1, 2\}$, $s$ sends $S \setminus (F_i \cup S_j)$. After that, nodes only relay the messages they have to further layers. Now we claim that after round $4$, all nodes in $T$ are saturated. Indeed, for instance, $t_{i1}$ will receive $F_i \cup S_1 \cup (S \setminus (F_i \cup S_1)) = S$, the main point being that since $F_i \subsetneq S_1$, $|F_i \cup S_1| > |S_1| = n_1$, therefore $|S \setminus (F_i \cup S_1)| \leq n -  n_1 - 1$ and $s$ can send it whole. 

    Now, assume we can saturate $T$ in $G$ in $4$ rounds. This implies that every $u_{i1}$ in round $3$ holds more than $n_1$ messages, implying that messages held by $F_i$ are not a strict subset of messages held by $S_1$ in round $2$. Analogously, it holds for $F_i$ and $S_2$. This means, there is (possibly non-injective) mapping $\phi$ of $\{v_1, \ldots, v_n\}$ into $S$ so that $\forall i \in [m], j \in \{1, 2\}$ it holds that $(\ast)$ $\bigcup\limits_{l \in F[i]}\phi(v_l) \subsetneq S_j$. Note that by making $\phi$ injective (and thus bijective) by iteratively taking a colliding pair $x, y$ ($\phi(x) = \phi(y)$) and assigning $y$ to the so far uncovered element, we can not break $\ast$. Therefore, we can assume that $\phi$ (i.e., distribution of messages across $v_i$) is bijective, which gives a solution to the splitting problem up to permuting the elements. 

\end{proof}

\section{Technical proofs}
\label{sec:appendix:proofs}
\begin{proof}[Proof of Lemma \ref{lem:eigenvalue shift}]
    Let $A' = A + DE$ and let $D'$ be a diagonal matrix such that $D'_{ii} = \sum\limits_{j \in [n]}A'_{ij}$. Note that $D' = D + DE$ and hence $(D')^{-1/2} = (D)^{-1/2}(I + E)^{-1/2}$. Entries of the $(I + E)^{-1/2}$ are of the form $\frac{1}{\sqrt{1 + E_{ii}}} \geq \frac{1}{\sqrt{1 + \varepsilon}} \geq \sqrt{1 - \varepsilon} \geq 1 - \varepsilon$. Therefore, we can denote $(I + E)^{-1/2}$ with $I - E'$ where $E'$ is a diagonal matrix with entries $0 \leq E'_{ii} \leq \varepsilon$. Now
        \begin{align*}
            \overline{A'} =& (D')^{-1/2}A'(D')^{-1/2}\\
                          =& (D^{-1/2} - D^{-1/2}E')(A + DE)(D^{-1/2} - D^{-1/2}E')\\
                          \overset{\ast}{=}& D^{-1/2}AD^{-1/2} - D^{-1/2}AD^{-1/2}E' + E - EE' - E'D^{-1/2}AD^{-1/2} + \\& E'D^{-1/2}AD^{-1/2}E' - E'E + E'EE'\\
                          =& \overline{A} - \overline{A}E' - E'\overline{A} + E'\overline{A}E' + E - 2EE' + E'EE'
        \end{align*}
        where to obtain $\ast$ we used the fact that diagonal matrices commute. 

        From Weyl's theorem, we conclude that 
        \begin{align*}
            \lambda_2(\overline{A'}) - \lambda_2(\overline{A}) &\leq ||- \overline{A}E' - E'\overline{A} + E'\overline{A}E' + E - 2EE' + E'EE'||_2\\
            \leq& ||\overline{A}E'||_2 + || E'\overline{A}||_2 + ||E'\overline{A}E' ||_2 + 2||EE'||_2 + ||E'EE' ||_2 \\
            \leq& ||\overline{A}||_2||E'||_2 + || E'||_2||\overline{A}||_2 + ||E'||_2||\overline{A}||_2||E' ||_2 +\\
            &2||E||_2||E'||_2 + ||E'||_2||E||_2||E' ||_2 \\
        \end{align*}

        Now recall that the spectral norm for a real-valued symmetric matrix is the biggest absolute value of its eigenvalues, hence $||\overline{A}||_2 = 1$ and $||E||_2 \leq \varepsilon$, $||E'||_2 \leq \varepsilon$. Thus
        \begin{align*}
            \lambda_2(\overline{A'}) - \lambda_2(\overline{A}) \leq \varepsilon + \varepsilon + \varepsilon^2 + 2 \varepsilon^2 + \varepsilon^3 \leq 6\varepsilon
        \end{align*}
\end{proof}



\end{document}