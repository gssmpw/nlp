\section{DYNAMIC WALKING CONTROLLER}% (1.25P)}
\label{sec:dynamic_walking}
% {\color{red}
% \begin{itemize}
%     \item Gait generation, MPC controller (MIT paper)
%     \item Condensing, prediction horizon
%     \item WBC controller (TSID paper, full vs. reduced?)
% \end{itemize}
% }

Our dynamic walking controller follows the general approach as described by \cite{di_carlo_dynamic_2018} and \cite{kim_highly_2019} and is illustrated in \autoref{fig:controller-architecture}. 
It outputs joint commands (position, velocity, torque) based on a target linear and rotational walking velocity and body posture.
The four sub-components of the controller run in parallel at different control rates: 
(1) The \textit{\gls{gs}} heuristically determines a gait sequence, containing the foot contact plan and the robot's target poses and velocities for the respective time steps over the prediction horizon $N$, 
based on the 
%state of the robot, the control target and 
selected gait type and control target.
%A gait sequence contains the target body poses and velocities of the robot for the respective time steps, as well as a contact plan of which foot is at which position in contact. 
(2) The \textit{\gls{mpc}} calculates the optimal contact forces for the feet over the prediction horizon to reach the target pose and velocity specified in the gait sequence, assuming \gls{srbd}. 
(3) For the feet not intended for ground contact in the current time step, the \gls{slc} computes the trajectory using a Bézier curve.
(4) The \textit{\gls{wbc}} computes the optimal joint accelerations and torques, which achieve the given target positions and velocities for the feet, the body posture/velocity and contact forces, taking into account the whole-body dynamics.
\gls{gs} and \gls{mpc} run at \qty{100}{\Hz}, while \gls{slc} and \gls{wbc} run at \qty{500}{\Hz}.
The largest computing load is generated by \gls{mpc} and \gls{wbc}, which both require solving \glspl{qp} in real-time. These two components are detailed in the following.

%The controller dynamic walking controller used in this work follows the idea of \cite{di_carlo_dynamic_2018} and \cite{kim_highly_2019}. 
%The overall architecture is depicted in \autoref{fig:controller-architecture}. 
%It outputs low-level joint commands based on a control target, which can be a twist, pose, or combination of both. 
%To do so it consists of different subparts that run in parallel. Based on the robot's state, target, and selected gait, the \textit{\gls{gs}} determines, based on heuristics, the $\Delta t$ discretized \gls{gs} over the prediction horizon $N$.
%A gait sequence term contains the robot's target pose and twist for that time step and which foot is scheduled for contact at which position. 
%The \textit{\gls{mpc}} computes the optimal contact forces for the feet in contact over the prediction horizon to reach the target pose and twist specified in the gait sequence, thereby assuming \gls{srbd} to reduce complexity. 
%For the feet not scheduled for contact at the current time step, the \textit{\gls{slc}} computes a target position and velocity to reach the next contact point following a Bézier curve.
%The \textit{\gls{wbc}} combines the position and velocity targets for the feet, not in contact, body pose, and twist target and contact forces into a weighted optimization problem which respects the \gls{wbd} and solves for optimal joint acceleration inputs.
%\gls{gs} and \gls{mpc} have a target 
%control frequency of \qty{100}{\Hz}, while \gls{slc} and \gls{wbc} have a target frequency of \qty{500}{\Hz}.
%While \gls{gs} and \gls{slc} involve relatively simple computations, the real computational challenge for this type of controller lies in the two constrained optimization problems that need to be solved in \gls{mpc} and \gls{wbc}.


\subsection{\acrlong{mpc}}\label{sec:method:mpc}
\subsubsection{Formulation}
The \gls{mpc} with $N$ prediction steps is formulated as the following convex optimization problem:
\begin{subequations}
\label{eq:mpc-form}
\begin{alignat}{7}
    %\min_{\mathbb{X}, \mathbb{U}}&& 
    %\sum_{k=1}^{N}&  
    %\setlength\arraycolsep{0.1pt}
    %\begin{bmatrix}
    %\mathbf{u}_{t|t+k-1} \\
    %\mathbf{x}_{t|t+k} \\ 
    %1
    %\end{bmatrix}^T
    %\begin{bmatrix}
    %    \mathbf{R} & 0 & 0\\
    %     0 & \mathbf{Q} & \mathbf{q}_{t|t+k} \\
    %     0 &  \mathbf{q}_{t|t+k}^T & 0 \\
    %\end{bmatrix}
    %&&\begin{bmatrix} 
    %\mathbf{u}_{t|t+k-1} \\
    %\mathbf{x}_{t|t+k} \\
    %1
    %\end{bmatrix}\label{eq:mpc-cost-fun}\\
    \min_{\mathbb{X}, \mathbb{U}} && \sum_{k=1}^N  &\rlap{$(\mathbf{x}_{k} - \mathbf{x}_{k}^d)^T\mathbf{Q}~(\mathbf{x}_{k} - \mathbf{x}_{k}^d) + \mathbf{u}_{k-1}^T~\mathbf{R}~\mathbf{u}_{k-1}$} \\
    \text{s.t.~} && \mathbf{x}_{k+1} &= \mathbf{A} \mathbf{x}_{k} +\rlap{$\mathbf{B}_{k}\mathbf{u}_{k},$}&&&&k=0 \dots N-1 \label{eq:mpc-state-const}\\ 
    %&& \mathbf{\underline{u}}_{t|t+k} &\leq \mathbf{u}_{t|t+k} \leq %\mathbf{\overline{u}}_{t|t+k},\quad &&k=0\dots N-1 \label{eq:mpc-u-bounds}\\
    && \mathbf{f}^j_{m,k}&\leq \mathbf{f}_{k}^j \leq \mathbf{f}^j_{M,k},  &&&\forall j,~ &k=0\dots N-1\label{eq:mpc-u-bounds} \\
    %&& \mathbf{\underline{d}} &\leq \mathbf{D}~\mathbf{u}_{t|k+1} \leq \mathbf{\overline{d}},\quad &&k=0\dots N-1\label{eq:mpc-input-const}\\
    &&|\mathbf{f}_{k}^j \cdot \hat{\mathbf{e}}_n| &\leq \mu\mathbf{f}_{k}^j \cdot \hat{\mathbf{e}}_z,&& \forall n\in\left\{x,y\right\},&\forall j,~ &k=0\dots N-1\label{eq:mpc-input-const}\\
    && \mathbf{x}_{0} &= \bar{\mathbf{x}}\label{eq:mpc-init_-const}
\end{alignat}
\end{subequations}
The decision variables $\mathbf{x}_{k} \in \mathbb{X},\mathbf{u}_{k} \in \mathbb{U}$, denote the prediction of the state and control input $k$ steps ahead at the current time step, $\mathbf{Q}$ is the diagonal state error cost matrix, $\mathbf{R}$ is the diagonal input cost matrix, and $\mathbf{x}^d_{k}$ the target state from \gls{gs}.
%Setting $\mathbf{q}_{t|t+k} = -\mathbf{Q}\hat{\mathbf{x}}_{t|t+k}$, where $\hat{\mathbf{x}}_{t|t+k}$ is the target state for time step $t$, simplifies \eqref{eq:mpc-cost-fun}:
%\begin{align}
%    \min_{\mathbb{X}, \mathbb{U}} \sum_{k=1}^N \left(\mathbf{x}_{t|t+k}-\hat{\mathbf{x}}_{t|t+k}\right)^T&\mathbf{Q}\left(\mathbf{x}_{t|t+k}-\hat{\mathbf{x}}_{t|t+k}\right) \nonumber\\ +\mathbf{u}_{t|t+k-1}^T~&\mathbf{R}~\mathbf{u}_{t|t+k-1}
%\end{align}
The equality constraint \eqref{eq:mpc-state-const} formulates the linearized system dynamics in world coordinates.
%The state vector $\mathbf{x} = \begin{bmatrix} \phi, \theta, \psi, x, y, z, \omega_x, \omega_y, \omega_z, \dot x, \dot y, \dot z, \mathrm{g} \end{bmatrix}^T \in \mathbb{R}^{13}$ contains the system's base orientation, position, linear and angular velocity, as well as the gravity vector. 
The state vector $\mathbf{x} \in \mathbb{R}^{13}$ contains the system's base orientation, position, linear, angular velocity, and the gravity constant. 
% \begin{equation}
%     \mathbf{x} = \begin{bmatrix}
%     \phi, \theta, \psi, x, y, z, \omega_x, \omega_y, \omega_z, \dot x, \dot y, \dot z, \mathrm{g}
% \end{bmatrix}^T \in \mathbb{R}^{13}
% \end{equation}
The control input $\mathbf{u} \in \mathbb{R}^{12}$ is a vector containing the four leg input forces $\mathbf{f}^j \in \mathbb{R}^3$, where $j\in \left\{1,2,3,4\right\}$ is the leg index.
% \begin{equation}
%     \mathbf{u} = \begin{bmatrix}
%     \mathbf{f}_\mathrm{fl}^T,
%     \mathbf{f}_\mathrm{fr}^T,
%     \mathbf{f}_\mathrm{bl}^T,
%     \mathbf{f}_\mathrm{br}^T
% \end{bmatrix}^T = \begin{bmatrix} f_{\mathrm{fl},x}, f_{\mathrm{fl},y}, _{\mathrm{fl},z},f_{\mathrm{fr},x}, \dots,  f_{\mathrm{br},z}, \end{bmatrix}^T 
% \in \mathbb{R}^{12}
% \end{equation}
The state matrix $\mathbf{A}$ is linearized around the current state $\bar{\mathbf{x}}$.
% \begin{align}
%    \mathbf{A}_{t|k} = \begin{bmatrix}
%        \mathbf{1}^{3\times3}  & \mathbf{0}^{3\times3} & \mathbf{R}_{t} \Delta t& \mathbf{0}^{3\times3} & \mathbf{0}^{3\times1}\\
%        \mathbf{0}^{3\times3} & \mathbf{1}^{3\times3} & \mathbf{0}^{3\times3} & \mathbf{1}^{3\times3} \Delta t & \mathbf{0}^{3\times1}\\
%        \mathbf{0}^{3\times3} & \mathbf{0}^{3\times3} & \mathbf{1}^{3\times3} & \mathbf{0}^{3\times3} & \mathbf{0}^{3\times1}\\
%        \mathbf{0}^{3\times3} & \mathbf{0}^{3\times3} & \mathbf{0}^{3\times3} & \mathbf{1}^{3\times3} & \mathbf{0}^{3\times1}\\
%        \mathbf{0}^{1\times3} & \mathbf{0}^{1\times3} & \mathbf{0}^{1\times3} & \mathbf{0}^{1\times3} & 1\\
%    \end{bmatrix}
% \end{align}
% where $\mathbf{R}$ is the robot's base rotation.
% where the rotational matrix $\mathbf{R}$, which maps the angular velocity from hybrid into world frame, is approximated with:
% \begin{align}
%     \mathbf{R}_{t}=\begin{bmatrix}
%         \cos(\psi_t) & \sin(\psi_t) & 0\\
%         -\sin(\psi_t) & \cos(\psi_t) & 0\\
%         0 & 0 & 1
%     \end{bmatrix}
% \end{align}
% \begin{align}
%        \mathbf{I}_{\mathrm{W},t} = \mathbf{R}_t \mathbf{I}_\mathrm{B} %\mathbf{R}_t^T
%\end{align}
The input matrix $\mathbf{B}_{k} \in \mathbb{R}^{13\times12}$ consists of four $\mathbb{R}^{13\times3}$  blocks, mapping the respective feet contact force onto the system's state, depending on the planned contacts.
%\begin{align}
%\label{eq:input_matrix}
%    \mathbf{B}_{t|k} = \begin{bmatrix}
%        \mathbf{0}^{6\times3}&\multirow{3}{*}{\dots}\\
%        c_{\textrm{fl},t|k}  \cdot \Delta t ~ 
%        \left[\mathbf{R}_t \mathbf{I}_\mathrm{B} %\mathbf{R}_t^T\right]^{-1}
 %       \left[\mathbf{r}_\mathrm{fl,t|k}-\mathbf{c}\right]_\times&\\
 %       c_{\textrm{fl},t|k}  \cdot \mathbf{1}^{3\times3} \frac{\Delta t}{\mathrm{m}}&\\
 %       0&
 %   \end{bmatrix}
%\end{align}
%Here, $\mathbf{I}_\mathrm{B}$ denotes the system's inertia in body coordinates, which is rotated to world coordinates in (\ref{eq:input_matrix}).
%The binary variable $c_{l,t|t+k} \in\{0,1\}, \forall l \in \{\mathrm{fl, fr,bl, br}\}$ indicates if contact for the specific leg is scheduled during the time step $t+k$, and $\mathbf{r}_\mathrm{l,t|k}, \forall l \in \{\mathrm{fl, fr,bl, br}\}$ denotes the scheduled contact location. 
%Both are determined beforehand by the gait sequencer based on the current state and the gait selected.
%The total mass is denoted by $m$ and $\mathbf{c}$ denotes the vector from the system's reference point to the \gls{com}.
The bounding-box constraint \eqref{eq:mpc-u-bounds} limits the contact force to a maximum $\mathbf{f}_{\mathrm{M},k}^j$, enforces a minimum contact force $\mathbf{f}_{\mathrm{m},k}^j$ and sets it to zero if the respective leg $j$ is scheduled for swing phase at predicted step $k$.
%\begin{align}
%    \underline{\mathbf{u}}_{t|k}=\begin{bmatrix}
%        c_{\textrm{fl},t|k}  \cdot -f_\mathrm{max} \\
%        c_{\textrm{fl},t|k}  \cdot -f_\mathrm{max}\\
%        c_{\textrm{fl},t|k}  \cdot  f_\mathrm{min}\\
%        \vdots
%    \end{bmatrix}
%    \overline{\mathbf{u}}_{t|k}=\begin{bmatrix}
%        c_{\textrm{fl},t|k}  \cdot f_\mathrm{max}\\
%        c_{\textrm{fl},t|k}  \cdot f_\mathrm{max}\\
%        c_{\textrm{fl},t|k}  \cdot f_\mathrm{max}\\
%        \vdots
%    \end{bmatrix}
%\end{align}
The constraint \eqref{eq:mpc-input-const} keeps the contact forces within a linearized friction cone with coefficient $\mu$, where $\hat{\mathbf{e}}_x, \hat{\mathbf{e}}_y,$ and $\hat{\mathbf{e}}_z$ denote the standard unit vectors.
%\begin{align}
%    \underline{\mathbf{d}} = \begin{bmatrix}
%        -\infty\\
%        0\\
%        -\infty\\
%        0\\
%        \vdots
%    \end{bmatrix},
%    \mathbf{D} = \begin{bmatrix}
%        1&0&-\mu\\
%        1&0&\mu\\
%        0&1&-\mu\\
%        0&1&\mu\\
%        \multicolumn{3}{c}{\vdots}
%    \end{bmatrix},
%    \overline{\mathbf{d}}=\begin{bmatrix}
%        0\\
%        \infty\\
%        0\\
%        \infty\\
%        \vdots
%    \end{bmatrix},
%\end{align}
The equality constraint \eqref{eq:mpc-init_-const} sets the initial state to the current estimated state $\bar{\mathbf{x}}$.
\subsubsection{Partial Condensing}
Classically, \gls{mpc} problems are formulated into a \textit{dense} \gls{qp} by eliminating all state variables (except the initial state) as the state can be expressed as a function of the previous state and the input in LTI systems.
This work follows the idea of \cite{axehill_controlling_2015}, implemented by \cite{frison_efficient_2016}, where the number of eliminated state variables can be specified.
For this purpose, the original prediction horizon $N$ is divided into $N_p$ blocks, each containing several consecutive states.
The idea is that in each block, all states but the first one are eliminated by the system dynamics. 
%For example, a block of size $3$:
%\begin{align}
%\setlength\arraycolsep{0.1pt}
%    \mathbf{x}_{k+2} &= \underbrace{\begin{bmatrix}
%        \mathbf{A}_{k+2} \mathbf{A}_{k+1} \mathbf{A}_{k}
%    \end{bmatrix}}_{\Gamma_{A,k}} \mathbf{x}_k \nonumber \\ &+ \underbrace{\begin{bmatrix}
%        \mathbf{A}_{k+2} \mathbf{A}_{k+1} \mathbf{B}_{k} & \mathbf{A}_{k+2} \mathbf{B}_{k+1} &  \mathbf{B}_{k+2}
%    \end{bmatrix}}_{\Gamma_{B,k}}
%    \underbrace{
%    \begin{bmatrix}
%        \mathbf{u}_k\\
%        \mathbf{u}_{k+1}\\
%        \mathbf{u}_{k+2}\\
%    \end{bmatrix}}_{\Gamma_{u,k}} 
%\end{align}
Following this approach, a partially condensed \gls{qp} is formulated, which can be interpreted as another \gls{mpc} problem with a prediction horizon of $N_p$, enlarged input matrix, and input vector, but fewer states and dynamic constraints.
Further details can be found in \cite{frison_efficient_2016}.
%Unlike \cite{di_carlo_dynamic_2018} which reformulates \eqref{eq:mpc-form} into a fully dense QP to reduce the problem size, this work explores the influence of the problem structure in the solver performance. Classically, \gls{mpc} problems are formulated into a \textit{dense} or \textit{sparse} \gls{qp} \textcolor{red}{CITE}.
%Using the fact that in LTI systems, the state can be expressed as a function of the previous state and the input, the state variables are eliminated in \textit{dense} formulation.

\subsection{\acrlong{wbc}}\label{sec:method:wbc}
We use a variant of the \gls{wbc} in~\cite{del_prete_implementing_2016} to stabilize the quadrupedal walking. The \gls{wbc} considers the full system dynamics and solves for the joint accelerations $\ddot{\mathbf{q}} \in \mathbb{R}^{18}$ and contact forces $\mathbf{u} \in \mathbb{R}^{12}$ in a single QP: 
\begin{subequations}
 \label{eq:reduced_tsid}
\begin{alignat}{3}
\def\arraystretch{1.5}
 % \underset{\ddot{\mathbf{q}}, \mathbf{u}}{\text{min}} && \quad \|\sum_i w_i(\mathbf{J}^i\ddot{\mathbf{q}} &+ \dot{\mathbf{J}}^i\dot{\mathbf{q}} - \dot{\mathbf{v}}^i_d) + \sum_j w_j(\mathbf{f}^j_d-\mathbf{f}^j)\|_2  \\
 \underset{\ddot{\mathbf{q}}, \mathbf{u}}{\text{min}} && \quad \|\sum_i w_i(\mathbf{J}^i\ddot{\mathbf{q}} &+ \dot{\mathbf{J}}^i\dot{\mathbf{q}} - \dot{\mathbf{v}}^i_d)\|_2 + \|\mathbf{w}_f(\mathbf{u}_d-\mathbf{u})\|_2  \\
% \text{s.t.} && \quad \mathbf{H}_f\ddot{\mathbf{q}} + \mathbf{h}_f &=  \sum_j (\mathbf{J}^j_{c,f})^T\mathbf{f}^j  \label{eq:reduced_tsid_1}\\
\text{s.t.} && \quad \mathbf{H}\ddot{\mathbf{q}} + \mathbf{h} &=  \mathbf{J}_{c}^T\mathbf{u}  \label{eq:reduced_tsid_1}\\
      % && \quad \mathbf{J}^j_{c}\ddot{\mathbf{q}} &= -\dot{\mathbf{J}}^j_{c}\dot{\mathbf{q}}, \quad  \forall j\label{eq:reduced_tsid_2}\\
      && \quad \mathbf{J}_{c}\ddot{\mathbf{q}} &= -\dot{\mathbf{J}}_{c}\dot{\mathbf{q}} \label{eq:reduced_tsid_2}\\
      % && |f_{x}| &\leq \mu f_{z},~|f_{y}|,~\leq \mu f_{z},~f_z > 0\label{eq:reduced_tsid_3}\\
      &&|\mathbf{f}^j \cdot \hat{\mathbf{e}}_n| &\leq \mu\mathbf{f}^j \cdot \hat{\mathbf{e}}_z, \forall n\in\left\{x,y\right\}, \mathbf{f}^j \cdot \hat{\mathbf{e}}_z > 0, \ \forall j  \label{eq:reduced_tsid_3}\\
       && \quad \boldsymbol{\tau}_{m} &\leq \mathbf{S}^{-1}\left(\mathbf{H}\ddot{\mathbf{q}} + \mathbf{h} - \mathbf{J}_{c}^T\mathbf{u}\right) \leq \boldsymbol{\tau}_{M}\label{eq:reduced_tsid_4}
\end{alignat}
\end{subequations}

where $w_i$ is the weight, $\mathbf{J}^i \in \mathbb{R}^{6 \times 18}$ the Jacobian, and $\dot{\mathbf{v}}_d^i \in \mathbb{R}^6$ the desired spatial acceleration for the $i$-th positioning task. The $\dot{\mathbf{v}}_d^i$ for the respective tasks are generated by PD-controllers to stabilize the body and feet trajectories produced by the \gls{mpc} and \gls{slc}. Further $\mathbf{u}_d \in \mathbb{R}^{12}$ the desired contact forces, as optimized by the \gls{mpc} in (\ref{eq:mpc-form}), i.e. $\mathbf{u}_d = \mathbf{u}_{k=0}$. The WBC can correct it to account for the full system dynamic. The amount of correction is specified by the diagonal weight matrix $\mathbf{w}_f$. 
The constraint (\ref{eq:reduced_tsid_1}) considers the rigid body dynamics, where $\mathbf{H} \in \mathbb{R}^{18 \times 18},\mathbf{h} \in \mathbb{R}^{18}, \mathbf{J}_{c} \in \mathbb{R}^{12 \times 18}$ are the mass-inertia matrix, bias vector, and contact Jacobian. 
Note that we consider only the floating base dynamics here %(hence the subscript f)
, as we do not have torques as optimization variables in the \gls{qp}. 
The constraint (\ref{eq:reduced_tsid_2}) ensures that the feet' contacts are rigid and slip-free, while (\ref{eq:reduced_tsid_3}) prevents the contact forces from leaving the linearized friction cones, where $\mu$ is the friction coefficient. Finally, (\ref{eq:reduced_tsid_4}) ensures that the torque limits $[\boldsymbol{\tau}_m,\boldsymbol{\tau}_M]$ are respected, where $\mathbf{S}\in\mathbb{R}^{18\times12}$ is the actuator selection matrix. Note that in (\ref{eq:reduced_tsid_4}) we use the subscript $a$ to account only for the actuated joints. In contrast to~\cite{kim_highly_2019}, we use a weighting scheme for prioritization, as it is the common choice in WBC and is thus better for benchmarking. The resulting joint accelerations $\ddot{\mathbf{q}}$ are integrated twice and the joint torques are computed from $\mathbf{q},\dot{\mathbf{q}},\ddot{\mathbf{q}}$ by inverse dynamics. 

As alternative approach, we formulate the joint torques as additional optimization variables and solve for them directly in the QP. This leads to a larger QP, but avoids additional inverse dynamics computations.
We refer to this approach as \textit{full TSID} here, while (\ref{eq:reduced_tsid}) is called \textit{reduced TSID}. 

%
%Since the number of obtained samples greatly differs between the solve time and CPU power consumption, the solve time samples are split into groups.
%In total, exactly as many groups exist, as there are CPU power consumption samples.
%For each group, the average solve time is calculated, and then used in (\ref{eq:sfpw_calculation}) for the \acrshort{sfpw} calculation.
