\section{EXPERIMENTAL SETUP}% (0.75P)}
\label{sec:setup}
%{\color{red}
%\begin{itemize}
%    \item System description (quadruped, simulation environment, ROS~2, Computing architectures to compare)
%    \item Solvers to compare (parameter sets, condensing, prediction horizon)
%    \item Test cases (trotting/standing)
%    \item number of Variables depending on level of condensing and prediction horizon
%    \item how do we measure power consumption
%\end{itemize}
%}

\subsection{Performance Metrics}% (0.5P)}
\label{sec:performance}
Two different metrics are used to compare the performance of the \gls{qp} solvers:
(1) The solve time is the duration required for the solvers to solve the respective \gls{qp}.
%The solve time includes the condensing time, which is however negligible.
%The solve time and condensing time are provided by \textit{acados} \cite{verschueren_acadosmodular_2022}.
%For comparative means, the solve time gives insights into the computational speed, the effects of condensing and the repercussions of using different gait patterns.
(2) The \textit{\acrfull{sfpw}}, which we introduce to assess the efficiency of the respective \gls{qp} solvers independent of the computational \gls{hw}. This metric is inspired by the \textit{FLOPS per Watt} measure, employed by the Green500 list of the world's most power-efficient supercomputers \cite{hemmert_green_2010}:
\begin{gather}
    \mathrm{SFPW}=\frac{{\mathrm{solve~time}}^{-1}}{\mathrm{CPU~power~consumption}} \; \; \; \left[\frac{Hz}{W}\right]
    \label{eq:sfpw_calculation}
\end{gather} %

On x86, the Intel \texttt{RAPL} Interface determines the CPU power consumption.
%Thereby, the \texttt{energy\_uj} file, which contains the total energy consumption since system startup in $ \mu \mathrm{J} $, is read with a sampling interval of \qty{0.1}{\second}.
For the ARM, the \texttt{tegrastats} utility is used. %provided in the official Jetson Linux image.
The CPU power consumption is sampled at \qty{10}{\hertz}.

The three target computers are listed in \autoref{tbl:computers}. 
%The LattePanda, a classic single-board computer with x86 architecture, a Jetson Orin, a modern single-board computer with ARM processor, and a desktop PC from a higher performance class. 
The Jetson Orin NX and LattePanda Alpha are single-board computers suitable for installation on the quadruped due to their low power consumption and small form factor.
%The LattePanda represents a classic single-board computer with the x86 architecture, as it is common in robotics.
%The Jetson Orin represents a modern single-board computer for AI applications, that is also equipped with an energy-saving ARM processor. 
%Due to their power consumption and form factor, these two computers would be suitable for onboard use on the quadruped. 
%The latter is also used on the EDU versions of the Go2.
%On the contrary, a state-of-the-art desktop PC with a higher performance class shows what would theoretically be possible with much higher computing power.

\begin{table}[t]
\centering
\caption{Target computers used for comparison.}
\label{tbl:computers}
\ra{1.3}
\begin{tabular}{@{}rllll@{}}\toprule
&\emph{Arch.} & \emph{CPU} & \emph{Cores}& \emph{RAM} \\
\midrule
Jetson Orin NX & ARM64 & AA78AEv8.2 & 8@\qty{2}{\giga\hertz}& \qty{16}{\giga\byte}  \\
LattePanda Alpha  & x86-64 & M3-8100Y & 2@\qty{3.4}{\giga\hertz} & \qty{8}{\giga\byte} \\
Desktop PC & x86-64 & i9-10900K & 10@\qty{3.7}{\giga\hertz} &\qty{16}{\giga\byte} \\
\bottomrule
\end{tabular}
%\vspace{-1.5em}
\end{table}

\subsection{Implementation and Solvers}
We use the \textit{Unitree Go2} quadruped~\cite{unitree_robotics_unitree_nodate} for experimental evaluation. It is simulated using the Drake toolbox \cite{tedrake_drake_2019}.
The controller is implemented using ROS~2. 

%\subsection{Solvers}
The \gls{mpc} is implemented using the \gls{qp} interface of the acados framework \cite{verschueren_acadosmodular_2022}. 
It interfaces to a set of state-of-the-art QP solvers, including \gls{hpipm} \cite{frison_hpipm_2020}, which provides the (partial) condensing routines from \cite{frison_efficient_2016}.
%, following the description in \cite{axehill_controlling_2015}. 
The \gls{wbc} is implemented in the ARC-OPT framework~\cite{mronga_dennis_arc-opt_2024,mronga_whole-body_2022}, which also comes with a set of QP solvers and different WBC implementations, including the \textit{full} and \textit{reduced TSID} described in Section~\ref{sec:method:wbc}.
\begin{table}[htbp]\centering
\caption{ \gls{qp} Solvers compared in this work}
\label{tbl:solvers}
\ra{1.3}
\begin{tabular}{@{}rllcc@{}}\toprule
\emph{Solver} & \emph{Method} & \emph{Interface} & \emph{\acrshort{mpc}} & \emph{\acrshort{wbc}}\\
\midrule
 HPIPM \cite{frison_hpipm_2020} & \acrshort{ipm} & Sparse, Dense & \checkmark & \checkmark\\
 OSQP \cite{stellato_osqp_2020} & \acrshort{admm}$^*$ & Sparse & \checkmark & \\
 qpOASES \cite{ferreau_qpoases_2014} & parametric \acrshort{asm} & Dense & \checkmark & \checkmark\\
DAQP \cite{arnstrom_dual_2022} & dual \acrshort{asm} & Dense & \checkmark & \\
Eiquadproq \cite{buondonno_eiquadprog_2019} &  dual \acrshort{asm}$^\dagger$  & Dense & & \checkmark \\
PROXQP \cite{bambade_prox-qp_2022} & \gls{alm} & Dense & & \checkmark
 % \\ qpSWIFT \cite{pandala_qpswift_2019} & \acrshort{ipm} & & 
 \\
\bottomrule
\multicolumn{5}{l}{\footnotesize{$^*$Variant of \gls{alm}, $^\dagger$Algorithm of Goldfarb and Idnani \cite{goldfarb_numerically_1983}}}
\end{tabular}
\end{table}
\autoref{tbl:solvers} lists all solvers that are considered in this work. 
A sparse interface means that a solver uses the sparse \gls{mpc} formulation as input and potentially exploits these.
%In the case of OSQP, the solver takes advantage of sparsity by using the \acrshort{csc} format \cite{stellato_osqp_2020, davis_direct_2006}.
In addition, the degree of sparsity of these solvers can be controlled via the partial condensation routines.
%This allows, e.g., passing a dense \gls{qp} formulation to a solver that is specialized on sparse problems.
Some solvers only accept the fully dense \acrshort{mpc} formulation as input, which means that comparison in terms of sparsity is not possible.
% A dense interface means that the solver in question only accepts the fully dense \acrshort{mpc} formulation as input, which means that comparison in terms of sparsity is not possible.
%The solvers qpOASES and DAQP fall into this category.
%\textcolor{red}{@Jakob maybe something about the solvers?}
We recognize that adjusting the hyperparameters, albeit time-consuming, can further improve performance. However, all solvers are used with the standard hyperparameters to ensure better comparability. The \acrshort{qpoases} solver is used with the \textit{\gls{mpc}} option set. The \gls{hpipm} solver has predefined modes that adapt the underlying \gls{ipm} algorithm. Here, the modes \textit{balanced} and \textit{speed\_abs} are used and treated as two different solvers. While the first mode provides more accurate results, the second focuses on speed \cite{frison_hpipm_2020}, which is more suitable for smaller systems and is equivalent to the HPMPC solver \cite{frison_high-performance_2014}.
All solvers are warm-started if possible. 
% Our aim is not to demonstrate the superiority or inferiority of any solver, but to compare the underlying methods and show what users can expect from them. 
% We recognize that adjusting the hyperparameters, albeit being time-consuming, can further improve performance.
% An exception to this is the \gls{hpipm} solver, which predefined modes that adapt the underlying \gls{ipm} algorithm. Here, the modes \textit{balanced} and \textit{speed\_abs} are used and treated as two different solvers. While the first mode provides more accurate results, the second focuses on speed \cite{frison_hpipm_2020}, which is more suitable for smaller systems and is equivalent to the HPMPC solver \cite{frison_high-performance_2014}.
%All solvers are warm-started if possible.
%\subsection{Computing Hardware}

\subsection{Problem Sizes}
For comparison, we choose a short ($N=10$) and medium ($N=20$) \gls{mpc} prediction horizon.
%The prediction horizon of the MPC is $N=10$ or $N=20$, so two versions of the original \gls{mpc} formulation represent \gls{mpc}s with a short and a medium-sized horizon. 
%These lead to problem sizes of \num{263} decision variables and \num{423} constraints for $N=10$, and \num{513} decision variables and \num{833} constraints for $N=20$.
The \gls{qp} dimension for both \gls{mpc} and \gls{wbc} are shown in \autoref{tbl:qp_sizes}.
For the \gls{mpc} solvers with sparse interfaces, this work compares all condensing levels such that the prediction horizon of the condensed \gls{qp}s are $N_p\in \{N,N-1,\dots,1\}$. 
The prediction horizon of the original \gls{mpc} is thereby evenly distributed into different blocks of size $\lfloor \frac{N}{N_p} \rfloor$. If $N$ is not an integer multiple of $N_p$, the remainder of $\frac{N}{N_p}$ is distributed to the foremost blocks (one per block). 
The final state is always left out during partial condensing and stays at size 1.
For the \gls{mpc} solvers with the dense interface, the \gls{qp} is fully condensed (including the terminal state), which is equivalent to partial condensing with $N_p=0$.
Note that the size of the constraint matrices in \gls{wbc} will change dynamically when changing the contacts during walking.
\begin{table}[htbp]\centering
\caption{\gls{qp} problem sizes}
\label{tbl:qp_sizes}
\ra{1.3}
\begin{tabular}{@{}rllccc@{}}\toprule
& & & \emph{Decision-} & \multicolumn{2}{c}{\emph{Constraints}}\\
&  & & \emph{variables} & \emph{Equality} & \emph{Inequality}\\
\midrule
\emph{\gls{wbc}} & \textit{Red. TSID}& & 30 &  18 & 28\\
\emph{\gls{wbc}} & \textit{Full TSID}& & 42 &  30 & 28\\
\midrule
\emph{\gls{mpc}} &\textit{original} & $N=10$ & 263 &  143 & 280\\
\emph{\gls{mpc}} &\textit{original} & $N=20$ & 513 & 273 &  360 \\
\multirow{2}{*}{\emph{\gls{mpc}}} &\multirow{2}{*}{\textit{condensed}} & & $13N_p + 12N $  & $13N_p + 13$ & $ 28N $  \\
& & &  $+~13$ &  &  \\
\bottomrule
\end{tabular}
\vspace{-1em}
\end{table}

%The number of decision variables for the condensed problem is $(N_p + 1) \cdot 13 + N \cdot 12$ and the number of constraints is $(N_p + 1) \cdot 13 + N \cdot 28$
%For the \gls{mpc} solvers with the dense interface, the \gls{qp} is fully condensed (including the terminal state), which leads to values for $N_p=0$ in the upper formulas.




%Regarding \gls{wbc}, the \textit{reduced TSID} formulation in (\ref{eq:reduced_tsid}) has originally $30$ optimization variables ($18$ joint accelerations, $4\times3$ contact forces), $18$ equality constraints ($6$ $\times$ floating base dynamics and $12 \times$ rigid contacts), and $28$ inequality constraints ($16$ for the $4$ friction cones and $12$ for the torque limits). Note that the size of the constraint matrices will change dynamically when changing the contact points during walking. The \textit{full TSID} has $42$ optimization variables (adding $12$ joint torques compare to \textit{reduced TSID}), $30$ equality constraints ($18$ $\times$ rigid body dynamics and $12 \times$ rigid contacts), and $28$ inequality constraints.
 

\subsection{Test Scenarios}
Two distinct scenarios are evaluated for each test case. 
In the first scenario, the controller performs a trotting gait, executing various velocity profiles with a total duration of \qty{\approx 40}{\second}. 
This induces dynamic motions with speeds up to \qty{0.5}{\meter\per\second} and rotational velocities up to \qty{40}{\degree\per\second}. 
In the second scenario the quadruped remains in standing mode, while responding to commanded body roll, pitch, and yaw movements up to \qty{\pm 30}{\degree}, as well as height adjustments of \qty{\pm 10}{\centi\meter}. 
Here, the  total duration is \qty{\approx 20}{\second}. If the robot falls, the attempt is repeated twice before the test case is counted as a \textit{failure}. The dynamic simulation is run on a different computer in real time as to not affect the measurements.

%Writing Notes:
%x86: RAPL -> calculation with energy uj file -> Joule/s = W
%ARM: tegrastats -> provides statistics on the SBC
%Repeated calls with interval 0.5 s -> publish over ROS topic
    