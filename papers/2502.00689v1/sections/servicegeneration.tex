
The Backend Generation component activates when the Service Discovery identifies service requirements from the Goal Management that can be fulfilled based on available definitions but are not yet implemented in the current service set $D_{\text{services}}$. 
\begin{algorithm}
\caption{: Service Generation}
\label{alg:service_gen}
\begin{algorithmic}[1] % Ensure sequential line numbering
\State \textbf{Input:} Service requirement query $Q$, System context $S_{\text{ctx}}$
\State \textbf{Output:} Service $S$ (either matched or newly generated)
\\
\Function{ServiceGeneration}{$Q, S_{\text{ctx}}$}
    \State $D_{\text{services}} \gets S_{\text{ctx}}.services$
    
    \State // description refinement phase
    \State $service\_match \gets \text{DescriptionRefiner}(Q, D_{\text{services}})$
    \If{$service\_match \neq \emptyset$}
        \State // existing service satisfies Q
        \State \Return $service\_match$
    \EndIf
    
    \State // service generation phase
    \State $D_{\text{schema}} \gets S_{\text{ctx}}.schemas$
    \State $Q_{\text{gen}} \gets \text{RefineGenerationQuery}(Q, D_{\text{schema}})$
    \State $S_{\text{new}} \gets \text{GenerateService}(Q_{\text{gen}})$
    \State $D_{\text{services}} \gets D_{\text{services}} \cup \{S_{\text{new}}\}$
    \State $\text{UpdateServiceContext}(S_{\text{ctx}}, S_{\text{new}})$
    \State \Return $S_{\text{new}}$
\EndFunction
\end{algorithmic}
\end{algorithm}
An algorithm to achieve this is described in Service Generation (Algorithm-\ref{alg:service_gen}) with components described in Table-\ref{tab:service-gen-components}. The generation process initiates by creating a service requirement query:
\[
Q = \{
    type: \text{service\_req},
    params: \theta_q
\}
\]
where $\theta_q$ represents the required service parameters  identified through the dialogue exchange with the Goal Parser. \\

The Service Manager maintains the system context $S_{\text{ctx}}$ comprising:

\[
S_{\text{ctx}} = \{
    D_{\text{services}},
    D_{\text{schema}},
    D_{\text{config}}
\}
\]

where $D_{\text{schema}}$ represents available database schemas and $D_{\text{config}}$ contains service configurations. The description of the services assist the Description Refiner -- an LLM Agent -- to evaluate incoming query $Q$ against $S_{\text{ctx}}$ through the function $f_{\text{match}}$:

\[
f_{\text{match}}(Q, S_{\text{ctx}}) = 
\begin{cases}
    S_i, & \text{if } \exists S_i \in D_{\text{services}} \\
    Q_{\text{gen}}, & \text{otherwise}
\end{cases}
\]


where $Q_{\text{gen}}$ represents the refined service generation query which is achieved using RefineGenerationQuery function (line-14 of Algorithm \ref{alg:service_gen}) which would be passed to the Service Generator (line-15), another LLM agent with coding capabilities. This would contain instructions to write code, with relevant database information (their schema, location etc.) required to generate these services. 

\begin{table}[h]
\setlength{\tabcolsep}{3pt}
\caption{Algorithm-\ref{alg:service_gen} Components executed by LLM agents}
\label{tab:service-gen-components}
\centering
\begin{tabular}{ll}
\toprule
\textbf{Function} & \textbf{Description} \\
\midrule
RefineGenerationQuery & Examines D$_{schema}$ relevant to query Q to \\
& prepare LLM coding prompt Q$_{gen}$ \\ \hline
GenerateService & Processes Q$_{gen}$ to generate and deploy S$_{new}$ \\ \hline
UpdateServiceContext & Updates S$_{ctx}$ with S$_{new}$ and adds to D$_{services}$ \\
\bottomrule
\end{tabular}
\end{table}
For example, extending our previous scenario, if a user requests crowd monitoring at historical sites:

\[
S_{\text{new}} = \{
    \text{name}: \text{crowd\_monitor}, \text{ } \theta_c
\}
\]
\[
\text{where } \theta_c = \{
    \text{loc}: \text{hist\_site},
    \text{time}: \text{now}
\}
\]


If $S_{\text{new}} \notin D_{\text{services}}$ but $D_{\text{schema}}$ contains relevant data structures for the monitoring of crowd density via the sensors and endpoints of these databases, the Service Generator creates and integrates the new service:


\[
D_{\text{services}} = D_{\text{services}} \cup \{S_{\text{new}}\}
\]

Upon the generation of the new service $S_{new}$ an entry is added describing its function and the parameters it expects  (Table-\ref{tab:service-definitions} entry for crowd monitor service).

    
    
 After the successful service generation, UpdateServiceContext algorithm \ref{alg:service_gen} signals the Service Manager
 to incorporate the new service into its context state, triggering
 necessary updates to both Context Management and its
 service registry in the Knowledge Management. The newly generated service $S_{new}$ is further transmitted to the Builder component for building the website.

