%!TEX root = ../main.tex

\section{Full Description of the Two-Sided PQ-MNC Protocol}
\label{sec:two-sided:full}

In this section, we present the full description of the 1-1 PQ-NMC protocol without the `one-sided' restriction. As explained in \Cref{sec:two-sided:main-body}, this is obtained by applying the \cite{STOC:PasRos05} `two-slot' technique to \Cref{protocol:BB-NMCom}. 


The protocol is presented in \Cref{protocol:BB-NMCom:two-sided}. It makes use of exactly the same building blocks for \Cref{protocol:BB-NMCom} (as listed at the beginning of \Cref{sec:BB-NMC:construction}).

\begin{ProtocolBox}[label={protocol:BB-NMCom:two-sided}]{(Two-Sided) PQ-NMC: Black-Box and Constant-Round}
{\bf Parameter Setting:} The tag space is defined to be $[T]$, where $T$ is a polynomial in the security parameter $\secpar$. Let $n$ be a polynomial in $\SecPar$, and $k$ be a constant fraction of $n$ such that $2k \le n/3$. 

\para{Input:}
Both the committer $C$ and the receiver $R$ get the security parameter $1^\secpar$ and a tag $t \in [T]$ as the common input; $C$ gets a string $m \in \bits^{\ell(\SecPar)}$ as its private input, where $\ell(\cdot)$ is a polynomial. 

\para{Commit Phase:}
\begin{enumerate}
\item\label[Step]{bbnmc:two-sided:init-com}
{\bf (Initial Com to $m$.)} In this stage, $C$ commits to the message with MitH.
\begin{itemize}
\item $C$ prepares $n$ views $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, 2k)$-$\VSS_\Share$ of the message $m$. $C$ commits to each $\msf{cv}^{(1)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\end{itemize}


\item \label[Step]{bbnmc:two-sided:hard-puzzle:puzzle-setup:A}
{\bf (Hard-Puzzle-A.)} In this stage, $R$ sets up a $t$-solution hard puzzle. It then commits to one solution of the puzzle and proves in zero-knowledge the consistency with MitH. This corresponds to the {\bf Slot-A} as described in \Cref{sec:two-sided:main-body}.
\begin{enumerate}

\item \label[Step]{bbnmc:two-sided:hard-puzzle:A:com-ch}
$C$ samples a size-$k$ random subset $\msf{ch}_A \subseteq [n]$, and commits to it using $\ExtCom$. 

\item \label[Step]{bbnmc:two-sided:hard-puzzle:A:rv-1}
$R$ samples $t$ random strings $x^A_1, \ldots, x^A_t \pick \bits^\secpar$. $R$ prepares $n$ views $\Set{\msf{rv}^{(1, A)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $x^A_1 \| \ldots \|x^A_t$. $R$ commits to each $\msf{rv}^{(1, A)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.

\item \label[Step]{bbnmc:two-sided:hard-puzzle:A:rv-2}
$R$ prepares another $n$ views $\Set{\msf{rv}^{(2, A)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $1\|x^A_1$.  $R$ commits to each $\msf{rv}^{(2,A)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$.

\item \label[Step]{bbnmc:two-sided:hard-puzzle:A:rv-3}
$R$ then prepares another $n$ views $\Set{\msf{rv}^{(3,A)}_i}_{i \in [n]}$, corresponding to an  $(n, k)$-MitH execution of the $n$-party functionality $F^{R,A}_{\msf{consis}}$ described below, where party $P_i$ ($i\in [n]$) uses $\msf{rv}^{(1, A)}_i \| \msf{rv}^{(2, A)}_i$ as input. $R$ commits to each $\msf{rv}^{(3, A)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\begin{itemize}
\item {\bf Functionality  $F^{R, A}_{\msf{consis}}$:} It collects input (and parses it as) $\msf{rv}^{(1,A)}_i \| \msf{rv}^{(2,A)}_i$ from party $i$ for each $i \in [n]$. It then runs the recovery algorithm of $\VSS$ to obtain $a_1\|\ldots\|a_t \coloneqq \VSS_\Recon(\msf{rv}^{(1, A)}_1, \ldots, \msf{rv}^{(1, A)}_n)$ and $j\|b_{j} \coloneqq \VSS_\Recon(\msf{rv}^{(2, A)}_1, \ldots, \msf{rv}^{(2, A)}_n)$. If $j \in [t]$ and $b_{j} = a_{j}$, it outputs 1 to each party; otherwise, it outputs 0 to each party.
\end{itemize}

\item \label[Step]{bbnmc:two-sided:hard-puzzle:A:decom-ch}
$C$ sends $\msf{ch}_A$ together with the decommitment information (w.r.t.\ \Cref{bbnmc:two-sided:hard-puzzle:A:com-ch}).

\item \label[Step]{bbnmc:two-sided:hard-puzzle:A:open}
$R$ sends $\Set{(\msf{rv}^{(1, A)}_i, \msf{rv}^{(2, A)}_i, \msf{rv}^{(3, A)}_i)}_{i \in \msf{ch}_A}$ together with the decommitment information (w.r.t.\ their respective commitments in \Cref{bbnmc:two-sided:hard-puzzle:A:rv-1,bbnmc:two-sided:hard-puzzle:A:rv-2,bbnmc:two-sided:hard-puzzle:A:rv-3}).

\item \label[Step]{bbnmc:two-sided:hard-puzzle:A:consistency-check}
$C$ checks the validity of the decommitment information and the consistency among the revealed views $\Set{(\msf{rv}^{(1, A)}_i, \msf{rv}^{(2, A)}_i, \msf{rv}^{(3, A)}_i)}_{i \in \msf{ch}_A}$. In particular, it checks for each $i \in \msf{ch}_A$ that $\msf{rv}^{(1, A)}_i\| \msf{rv}^{(2, A)}_i$ is the prefix of $\msf{rv}^{(3, A)}_i$. It also checks for each distinct pair $i, j\in \msf{ch}_A$ that $(\msf{rv}^{(1, A)}_i, \msf{rv}^{(1, A)}_j)$ are consistent, $(\msf{rv}^{(2, A)}_i, \msf{rv}^{(2, A)}_j)$ are consistent, and $(\msf{rv}^{(3, A)}_i, \msf{rv}^{(3, A)}_j)$ are consistent, where by `consistent' we refer to the consistency requirements as per \Cref{def:view-consistency} and \Cref{rmk:VSS:view-consistency}. It also checks for each $i\in \msf{ch}_A$ the final output of $P_i$ contained in $\msf{rv}^{(3, A)}_i$ is 1. It aborts immediately if any of the checks fail.
\end{enumerate}

\item \label[Step]{bbnmc:two-sided:hard-puzzle:puzzle-setup:B}
{\bf (Hard-Puzzle-B.)} In this stage, $R$ sets up a $(T-t)$-solution hard puzzle. It then commits to one solution of the puzzle and proves in zero-knowledge the consistency with MitH. This corresponds to the {\bf Slot-B} as described in \Cref{sec:two-sided:main-body}.
\begin{enumerate}

\item \label[Step]{bbnmc:two-sided:hard-puzzle:B:com-ch}
$C$ samples a size-$k$ random subset $\msf{ch}_B \subseteq [n]$, and commits to it using $\ExtCom$. 

\item \label[Step]{bbnmc:two-sided:hard-puzzle:B:rv-1}
$R$ samples $(T-t)$ random strings $x^B_1, \ldots, x^B_{T-t} \pick \bits^\secpar$. $R$ prepares $n$ views $\Set{\msf{rv}^{(1, B)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $x^B_1 \| \ldots \|x^B_t$. $R$ commits to each $\msf{rv}^{(1, B)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.

\item \label[Step]{bbnmc:two-sided:hard-puzzle:B:rv-2}
$R$ prepares another $n$ views $\Set{\msf{rv}^{(2, B)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $1\|x^B_1$.  $R$ commits to each $\msf{rv}^{(2,B)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$.

\item \label[Step]{bbnmc:two-sided:hard-puzzle:B:rv-3}
$R$ then prepares another $n$ views $\Set{\msf{rv}^{(3,B)}_i}_{i \in [n]}$, corresponding to an  $(n, k)$-MitH execution of the $n$-party functionality $F^{R,B}_{\msf{consis}}$ described below, where party $P_i$ ($i\in [n]$) uses $\msf{rv}^{(1, B)}_i \| \msf{rv}^{(2, B)}_i$ as input. $R$ commits to each $\msf{rv}^{(3, B)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\begin{itemize}
\item {\bf Functionality  $F^{R, B}_{\msf{consis}}$:} It collects input (and parses it as) $\msf{rv}^{(1,B)}_i \| \msf{rv}^{(2,B)}_i$ from party $i$ for each $i \in [n]$. It then runs the recovery algorithm of $\VSS$ to obtain $a_1\|\ldots\|a_{T-t} \coloneqq \VSS_\Recon(\msf{rv}^{(1, B)}_1, \ldots, \msf{rv}^{(1, B)}_n)$ and $j\|b_{j} \coloneqq \VSS_\Recon(\msf{rv}^{(2, B)}_1, \ldots, \msf{rv}^{(2, B)}_n)$. If $j \in [T-t]$ and $b_{j} = a_{j}$, it outputs 1 to each party; otherwise, it outputs 0 to each party.
\end{itemize}

\item \label[Step]{bbnmc:two-sided:hard-puzzle:B:decom-ch}
$C$ sends $\msf{ch}_B$ together with the decommitment information (w.r.t.\ \Cref{bbnmc:two-sided:hard-puzzle:B:com-ch}).

\item \label[Step]{bbnmc:two-sided:hard-puzzle:B:open}
$R$ sends $\Set{(\msf{rv}^{(1, B)}_i, \msf{rv}^{(2, B)}_i, \msf{rv}^{(3, B)}_i)}_{i \in \msf{ch}_B}$ together with the decommitment information (w.r.t.\ their respective commitments in \Cref{bbnmc:two-sided:hard-puzzle:B:rv-1,bbnmc:two-sided:hard-puzzle:B:rv-2,bbnmc:two-sided:hard-puzzle:B:rv-3}).

\item
$C$ checks the validity of the decommitment information and the consistency among the revealed views $\Set{(\msf{rv}^{(1, B)}_i, \msf{rv}^{(2, B)}_i, \msf{rv}^{(3, B)}_i)}_{i \in \msf{ch}_B}$ in the same manner as in \Cref{bbnmc:two-sided:hard-puzzle:A:consistency-check}. It also checks for each $i\in \msf{ch}_B$ the final output of $P_i$ contained in $\msf{rv}^{(3, B)}_i$ is 1. It aborts immediately if any of the checks fail.
\end{enumerate}

\item \label[Step]{prot:bbnmc:two-sided:extcom}
{\bf (ExtCom to $m$.)} $C$ commits to $m$ once again with an extractable MitH.
\begin{itemize}
\item
$C$ prepares $n$ views $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, 2k)$-$\VSS_\Share$ of the message $m$. $C$ commits to each $\msf{cv}^{(2)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$.
\end{itemize}

\item\label[Step]{prot:bbnmc:two-sided:puzzle-sol-reveal}
{\bf (Puzzle Solution Reveal.)} $R$ reveals $(x^A_1, \ldots, x^A_t)$ and $(x^B_1, \ldots, x^B_{T-t})$ by decommitting to $\Set{\msf{rv}^{(1, A)}_i}_{i \in [n]}$ and $\Set{\msf{rv}^{(1, B)}_i}_{i \in [n]}$. 
% In more detail,
% \begin{enumerate}
% \item
% $R$ sends $\Set{\msf{rv}^{(1)}_i}_{i \in [n]}$ together with the decommitment information w.r.t.\ the commitments in \Cref{bbnmc:hard-puzzle:rv-1}.
% \item
% $C$ checks the validity of the decommitment information and the consistency among $\Set{\msf{rv}^{(1)}_i}_{i\in [n]}$ (as per \Cref{rmk:VSS:view-consistency}). If these checks are successful, $C$ recovers $x_1 \| \ldots \|x_t \coloneqq \VSS_\Recon(\msf{rv}^{(1)}_1, \ldots, \msf{rv}^{(1)}_n)$; otherwise, $C$ rejects and output $\bot$. 
% \end{enumerate}



\item \label[Step]{prot:bbnmc:two-sided:PoC}
{\bf (Committer's Consistency Proof.)} This stage should be interpreted as $C$ proving consistency between its actions in \Cref{bbnmc:two-sided:init-com,prot:bbnmc:two-sided:extcom} (i.e., these two steps commit to the same value) using a WI argument, where the trapdoor statement is that: $C$ manages to commit to a puzzle solution in \Cref{prot:bbnmc:two-sided:extcom} {\em either} for {\bf Hard-Puzzle-A} {\em or} {\bf Hard-Puzzle-B}. Note that this is corresponding to the modification described in \Cref{sec:two-sided:main-body}.

This step is again conducted in MitH. Note that for the honest committer, the `effective witness' is the same message $m$ reconstructed from both $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$ and $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, and so the virtual MPC execution in reality evaluates the `first clause' of $F^C_{\msf{consis}}$ as defined below. 
\begin{enumerate}
\item\label[Step]{prot:bbnmc:two-sided:C-consis-com}
$C$ prepares $n$ views $\Set{\msf{cv}^{(3)}_i}_{i \in [n]}$, corresponding to an $(n,2k)$-MitH execution of the $n$-party functionality $F^C_{\msf{consis}}$ described below, where party $P_i$ ($i\in [n]$) uses $\msf{cv}^{(1)}_i \| \msf{cv}^{(2)}_i$ as input. $C$ commits to each $\msf{cv}^{(3)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\begin{itemize}
\item {\bf Functionality  $F^C_{\msf{consis}}$:} It collects input (and parses it as) $\msf{cv}^{(1)}_i \| \msf{cv}^{(2)}_i$ from party $i$ for each $i \in [n]$. It then runs the recovery algorithm of $\VSS$ to obtain $a \coloneqq \VSS_\Recon(\msf{cv}^{(1)}_1, \ldots, \msf{cv}^{(1)}_n)$ and $b \coloneqq \VSS_\Recon(\msf{cv}^{(2)}_1, \ldots, \msf{cv}^{(2)}_n)$. It outputs 1 to each party if
\begin{itemize}
\item
$b = a$, {\bf or}
\item
$b$ can be parsed as $j\|x'$ such that $j\in [t]$ and $x' = x^A_j$ (recall that $x^A_j$ is among the {\bf Hard-Puzzle-A} solutions revealed by Rrevealed in \Cref{prot:bbnmc:two-sided:puzzle-sol-reveal}, {\bf or}
\item
$b$ can be parsed as $j\|x'$ such that $j\in [T-t]$ and $x' = x^B_j$ (recall that $x^B_j$ is among the {\bf Hard-Puzzle-B} solutions revealed by Rrevealed in \Cref{prot:bbnmc:two-sided:puzzle-sol-reveal}.
\end{itemize} 
Otherwise, it outputs 0 to each party.
\end{itemize}

\item\label[Step]{prot:bbnmc:two-sided:cointoss}
{\bf (Trapdoor Coin-Flipping)} $C$ and $R$ then execute the {\bf Coin-Flipping Stage} of the trapdoor coin-flipping protocol shown in \Cref{prot:td:ct}, with the trapdoor predicate $\phi(\cdot)$ defined as follows
\begin{itemize}
\item
{\bf Predicate $\phi(\cdot)$:} It has the values $(x^A_1, \ldots, x^A_t)$ and $(x^B_1, \ldots, x^B_{T-t})$ hard-wired (recall that these values are revealed in \Cref{prot:bbnmc:two-sided:puzzle-sol-reveal}). On input $j\|x'$, $\phi$ outputs 1 if and only if {\em either}
\begin{itemize}
\item
$j\in [t]$ and $x' = x^A_j$ {\em or}
\item
$j\in [T-t]$ and $x' = x^B_j$.
\end{itemize}  
\end{itemize}
By the completeness of the trapdoor coin-flipping protocol (i.e., \Cref{def:com-n-prove:property:2} in \Cref{def:com-n-prove}), at the end of this step, $C$ and $R$ agree on a string $\eta$. By a proper choice of length, the string $\eta$ can be interpreted as specifying a size-$k$ random subset of $[n]$. In the following, we abuse notation by using $\eta$ to denote the corresponding size-$k$ random subset.

\item\label[Step]{prot:bbnmc:two-sided:mpc:reveal}
$C$ sends $\Set{(\msf{cv}^{(1)}_i, \msf{cv}^{(2)}_i, \msf{cv}^{(3)}_i)}_{i \in \eta}$ together with the decommitment information (w.r.t.\ their respective commitments in \Cref{bbnmc:two-sided:init-com,prot:bbnmc:two-sided:extcom,prot:bbnmc:two-sided:C-consis-com}).

\item
$R$ checks the validity of the decommitment information and the consistency among the revealed views $\Set{(\msf{cv}^{(1)}_i, \msf{cv}^{(2)}_i, \msf{cv}^{(3)}_i)}_{i \in \eta}$. 
% In particular, it checks for each $i \in \eta$ that $\msf{cv}^{(1)}_i\| \msf{cv}^{(2)}_i$ is the prefix of $\msf{cv}^{(3)}_i$. It also checks for each distinct pair $i, j\in \eta$ that $(\msf{cv}^{(1)}_i, \msf{cv}^{(1)}_j)$ are consistent, $(\msf{cv}^{(2)}_i, \msf{cv}^{(2)}_j)$ are consistent, and $(\msf{cv}^{(3)}_i, \msf{cv}^{(3)}_j)$ are consistent, where by `consistent' we refer to the consistency requirements as per \Cref{def:view-consistency} and \Cref{rmk:VSS:view-consistency}.
It also checks for each $i \in \eta$ that the output of $P_i$ contained in $\msf{cv}^{(3)}_i$ is 1. It aborts if any of these checks fail.
\end{enumerate}

\end{enumerate}



\para{Decommit Stage:} 
\begin{enumerate}
\item
$C$ sends $\Set{\msf{cv}^{(1)}_i}_{i\in [n]}$ together with the decommitment information w.r.t.\ the commitments in \Cref{bbnmc:two-sided:init-com}. 
\item
$R$ checks the validity of the decommitment information and the consistency among $\Set{\msf{cv}^{(1)}_i}_{i\in [n]}$. If these checks are successful, $R$ recovers $m$ as $m \coloneqq \VSS_\Recon(\msf{cv}^{(1)}_1, \ldots, \msf{cv}^{(1)}_n)$; otherwise, $R$ rejects and output $\bot$. 
\end{enumerate}

\end{ProtocolBox}