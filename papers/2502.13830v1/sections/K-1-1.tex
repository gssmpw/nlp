%!TEX root = ../main.tex

\section{Simulation-less Extractor \textnormal{$\mcal{K}$}: 1-1 Settings}
\label{sec:simless-ext:1-1}



In this section we introduce a `basic' extractor machine $\mcal{K}$. We then describe its operation and show that the stated properties hold. 

We will rely on some of the notation from the previous section. In particular, recall from \Cref{pq:game:Htil} that the procedure $\tilde{H}^{\mcal{M}_\secpar}_{\msf{pre}}(\secpar, m, \rho_\secpar)$ generates $\eta$, $\msf{VI}_\eta$, and $\msf{pref}=(\msf{st}_{\mcal{M}}, \msf{st}_R, \tau,\tilde{\tau})$. We will define $\msf{pref'} \coloneqq (\msf{pref},\eta,\msf{VI}_{\eta})$. Also, we define the following quantity $p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1]$ that will be important in the statement of $\mcal{K}$: 
\begin{equation}\label{eq:def:p-pref}
p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] \coloneqq \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')].
\end{equation}
% where $\epsilon_1$ is the error parameter for $\SimExt_\ExtCom$ used in $\mcal{G}_1$ (defined in \Cref{pq:machine:g1}), and is taken to be a noticeable function of $\secpar$. 

\begin{lemma}[Simulation-less Extraction]\label{pq:lem:small-tag:proof:se:proof:K}
Let $\tilde{H}^{\mcal{M}_\secpar}_{\msf{pre}}(\secpar, m, \rho_\secpar)$ be as defined in \Cref{pq:game:Htil}. There exists a QPT machine $\mcal{K}$ such that for any noticeable $\epsilon(\secpar)$, there is a noticeable $\epsilon_1(\secpar) \le \epsilon(\secpar)$ that can be efficiently computed form $\epsilon$, such that for any noticeable $\epsilon_2(\secpar)$ and any tuple $\msf{pref'} = (\msf{st}_{\mcal{M}}, \msf{st}_R, \tau,\tilde{\tau},\eta,\msf{VI}_{\eta})$ in the support of $\tilde{H}^{\mcal{M}_\secpar}_{\msf{pre}}(\secpar, m, \rho_\secpar)$, the following holds
\begin{enumerate}
\item \label[Property]{pq:property:small-tag:proof:se:proof:K:syntax}
{\bf (Almost Uniqueness:)} $\mcal{K}$ takes as input $(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')$. It outputs a value $\msf{Val} \in \bits^{\ell(\secpar)} \cup \Set{\bot}$ such that 
$$\Pr[\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}) , \bot} ~:~\msf{Val} \ra \mcal{K}{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}] \leq {\epsilon_2(\secpar) + \negl(\secpar)}.$$
 % where $\zeta(\secpar)$ is as above. 
%Change to the more generalized output property that referes to zeta. Match with Xiao's sim-ext lemma. 

\item \label[Property]{pq:property:small-tag:proof:se:proof:K}
{\bf (Extraction:)} If $p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] \ge \epsilon(\secpar)$, then it holds that
$$\Pr[\Val = \msf{val}(\tilde{\tau}) : \Val \gets \mcal{K}{(1^\secpar, 1^{\epsilon_1^{-1}},1^{\epsilon_2^{-1}}, \msf{pref}')}] \ge {\frac{\epsilon'(\secpar)-\epsilon_2(\secpar)}{\tilde{t}}},$$
where $p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]$ is defined in \Cref{eq:def:p-pref} and  $\epsilon'(\secpar) \coloneqq \frac{\epsilon(\secpar)}{10t^2}$. 
\end{enumerate}
\end{lemma}


In the following, we fix a noticeable function $\epsilon(\secpar)$ for which we want to prove \Cref{pq:lem:small-tag:proof:se:proof:K}. We show that it suffices to set $\epsilon_1(\secpar)\defeq \frac{t+1}{t^2+4t+2}\cdot \epsilon'(\secpar)$. 

% \xiao{Add an outline for proof?}


%  Since we fix $\epsilon$ and $\epsilon_1$, we omit the dependence on $\epsilon_1$ in our notation, i.e., we simply write $p^{\msf{Sim}}_{\msf{pref'}}$ and $\mcal{G}_1$ to mean $p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1]$ and $\mcal{G}_1[\epsilon_1]$. Note also that $\epsilon_1$ does not appear explicitly in \Cref{pq:lem:small-tag:proof:se:proof:K}
% Similarly, machines introduced in the following also depend on $\epsilon_1$, but we do not explicitly write it in our notation. 
% We also omit writing $(1^\secpar,1^{\epsilon^{-1}},1^{\zeta^{-1}})$ from inputs of those machines for notational simplicity. 
% \xiao{This is a bad practice for this paper. I will modify the following part to include the parameters.}

% \begin{xiaoenv}{rename parameters}
% {Also, I need to rename the parameters as follows:}
% \begin{itemize}
% \item
% call $\epsilon_1$ as $\epsilon_1$. It does not appear when applying \Cref{lem:Noisy-SimExt}.
% \item
% calll $\zeta$ as $\epsilon_2$. This is $\zeta$ when applying \Cref{lem:Noisy-SimExt}.
% \item
% call $\epsilon$ as $\epsilon$. This is $\gamma$ when applying \Cref{lem:Noisy-SimExt}.
% \end{itemize}
% \end{xiaoenv}

\subsection{Description of $\mcal{K}$}
Before describing the extractor $\mcal{K}$, we first need to introduce some new machines related to $\mcal{G}_1$. 
\begin{AlgorithmBox}[label={algo:G:i}]{Machine \textnormal{$\mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')$}}
\para{Machine $\mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')$:} Recall that we have already defined $\mcal{G}_1$ in \Cref{pq:machine:g1}. For $i \in [\tilde{t}]\setminus \Set{1}$, the machine $\mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')$ works identically to $\mcal{G}_1(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')$, apart from the following changes: 
\begin{enumerate}
\item It commits to the value $i||\tilde{x}_i$ instead of the value $1||\tilde{x}_1$ in \Cref{bbnmc:hard-puzzle:rv-2} of the right session. 

In more detail, $\mcal{G}_i$ first prepares $n$ views $\Set{\msf{rv}^{(2)}_j}_{j \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $i\|\tilde{x}_i$, and then commits to each $\msf{rv}^{(2)}_j$  independently in parallel, using $\ExtCom$. 

\item Additionally, now the string $i||\tilde{x}_i$ is used as the `effective input' in the (virtual) MPC execution computing $F^R_{\msf{consis}}$ in \Cref{bbnmc:hard-puzzle:rv-3}. (Indeed, this is an implicit change and occurs automatically when the first change is made.) 
\end{enumerate} 
\end{AlgorithmBox}


Next we define another machine $\mcal{K}_i$ for each $i \in [\tilde{t}]$ in \Cref{algo:K:i}. These $\mcal{K}_i$'s sever as the basic component for the eventual extractor $\mcal{K}$ we are going to build.
\begin{AlgorithmBox}[label={algo:K:i}]{Machine \textnormal{$\mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}$}}
{\bf Machine $\mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}$:} For each $i \in [\tilde{t}]$, the machine $\mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}$ works identically to machine $\mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')}$ except that
\begin{itemize}
\item
In \Cref{prot:bbnmc:extcom} of the right session, instead of following the honest receiver's algorithm, it invokes $\SimExt_\ExtCom(1^\secpar, 1^{\epsilon_2^{-1}})$ to obtain an extracted value $\tilde{v}$.

 In more detail, the shares $\Set{\msf{cv}^{(2)}_j}_{j \in [n]}$ are committed by $\mcal{M}_\secpar$ in \Cref{prot:bbnmc:extcom} of the right session using independent $\ExtCom$ in parallel. $\mcal{K}_i$ will extract all of these shares using the parallel extractability of $\ExtCom$ with $\epsilon_2$-simulation (as per \Cref{def:epsilon-sim-ext-com:parallel}), and compute $\tilde{v} \coloneqq \VSS_{\Recon}(\msf{cv}^{(2)}_1, \ldots, \msf{cv}^{(2)}_n)$.
\end{itemize}

{\bf Outputs of $\mcal{K}_i$:} To aid in our proof, we define the output of the machines $\mcal{K}_i$ differently from the outputs of the machines described so far. 

Let $\tilde{v}$ denote the value extracted and recorded by $\mcal{K}_i$ in \Cref{prot:bbnmc:extcom}. As described, $\mcal{K}_i$ will complete the execution of both left and right sessions (just as in $\mcal{G}_i$). Recall that we use $\tilde{d}$ to denote the acceptance or rejection of the right-session honest receiver (i.e., its verdict). The output of $\mcal{K}_i$ is denoted as $\msf{Val} \in \bits^{\ell(\secpar)} \cup \Set{\bot_{\tilde{Y}}, \bot_{\msf{invalid}}}$ (where $(\bot_{\tilde{Y}}, \bot_{\msf{invalid}})$ are two specialized abort symbols), and is computed as follows: %Need different notation for Ytil? Has no motivation in our case. 
\begin{enumerate}
\item \label[Case]{pq:K-i:output:case:1}
If $\tilde{d} = \top$ . Then, there are two sub-cases:
\begin{enumerate}
\item \label[Case]{pq:K-i:output:case:1a}
$\tilde{v} \notin \Set{\tilde{x}_i}_{i \in [\tilde{t}]}$ : In this case, we set $\msf{Val} \coloneqq \tilde{v}$. %\xiao{may need to consider the possibility that $\tilde{v}$ is bot when the ExtCom extraction fails. Call that case $\bot_{\msf{invalid}}$ as well}
\item \label[Case]{pq:K-i:output:case:1b}
$\tilde{v} \in \Set{\tilde{x}_i}_{i \in [\tilde{t}]}$ : In this case, we set $\msf{Val} \coloneqq \bot_{\tilde{Y}}$.
\end{enumerate}

\item \label[Case]{pq:K-i:output:case:2}
Otherwise, if $\tilde{d} = \bot$, set $\msf{Val} \coloneqq \bot_{\msf{invalid}}$.
\end{enumerate}
We emphasize that such a $\msf{Val}$ satisfies the {\em syntactic} requirement in \Cref{pq:property:small-tag:proof:se:proof:K:syntax} of \Cref{pq:lem:small-tag:proof:se:proof:K} \footnote{Note that here we defined two types of abortion: $\bot_{\tilde{Y}}$ and $\bot_{\msf{invalid}}$, while \Cref{pq:property:small-tag:proof:se:proof:K:syntax} of \Cref{pq:lem:small-tag:proof:se:proof:K} only allows a single abortion symbol $\bot$. We remark that this is only a cosmetic difference---It can be made consistent using the following rules: $\bot = \bot_{\tilde{Y}}$ {\em and} $\bot = \bot_{\msf{invalid}}$ (i.e., $\msf{Val} = \bot  \Leftrightarrow (\msf{Val} = \bot_{\tilde{Y}} \vee \msf{Val} = \bot_{\msf{invalid}})$).} (but does not imply the actual probabilistic condition, which we will show separately).
\end{AlgorithmBox}

 %In particular, {\em $\msf{Val} = \msf{val}(\tilde{\tau})$ whenever $\msf{Val} \ne \bot$}.

Finally, we are ready to define the extractor $\mcal{K}$. Intuitively, $\mcal{K}$ can be thought of as an average-case version of $\Set{\mcal{K}_i}_{i\in[\tilde{t}]}$:
\begin{itemize}
\item
{\bf Extractor $\mcal{K}$:} On input ${(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}$, $\mcal{K}$ samples an index $i \pick [\tilde{t}]$ uniformly and runs $\mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}$, and outputs the resulting output of $\mcal{K}_i$.  
\end{itemize}
It is easy to see that the extractor $\mcal{K}$ runs in polytime, and hence is a QPT machine. We now show the other properties in \Cref{pq:lem:small-tag:proof:se:proof:K} are satisfied as well. 

% \xiao{need to add a proof outline for the following subsections}





\subsection{Almost Uniqueness of $\mcal{K}$}
\label{sec:proof:K:1-1:almost-uniqueness}
In this part, we prove \Cref{pq:property:small-tag:proof:se:proof:K:syntax} of \Cref{pq:lem:small-tag:proof:se:proof:K}. 

First, note that $\mcal{K}$ by definition samples a random $i$ and run $\mcal{K}_i$. Thus, to prove \Cref{pq:property:small-tag:proof:se:proof:K:syntax}, it suffices to prove the inequality shown in  \Cref{pq:property:small-tag:proof:se:proof:K:syntax} for all $\mcal{K}_i$'s. That is, to prove \Cref{pq:property:small-tag:proof:se:proof:K:syntax}, it suffices to show the following: Under the same parameter settings as in \Cref{pq:lem:small-tag:proof:se:proof:K}, it holds that
\begin{equation}\label[Inequality]{eq:reduce:K:Ki}
\forall i\in[\tilde{t}],~
\Pr[\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}), \bot}~:~\msf{Val} \la \mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}] \leq {\epsilon_2(\secpar)+\negl(\secpar)}.
\end{equation}


In the following, we focus on establishing \Cref{eq:reduce:K:Ki}.

First, note that the following holds for any $i\in [\tilde{t}]$ (all the provabilities below is taken over the execution $\msf{Val} \la \mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}$):
\begin{align*}
\Pr[\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}), \bot}] 
& =
\Pr[\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}),\bot_\msf{invalid},\bot_{\tilde{Y}}}] \numberthis \label{eq:uniqueness:Ki:1} \\
& =
\Pr[\big(\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}),\bot_\msf{invalid},\bot_{\tilde{Y}}}\big) \wedge \big( \tilde{d} = \top \big)] \numberthis \label{eq:uniqueness:Ki:2} \\
& \le
\Pr[\big(\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}),\bot_{\tilde{Y}}}\big) \wedge \big( \tilde{d} = \top \big)] \numberthis \label[Inequality]{eq:uniqueness:Ki:3} 
,\end{align*}
where \Cref{eq:uniqueness:Ki:1} follows from the fact that the symbol $\bot$ corresponds to both $\bot_{\msf{invalid}}$ and $\bot_{\tilde{Y}}$ (recall it from \Cref{algo:K:i}), \Cref{eq:uniqueness:Ki:2} follows from the fact that 
$\msf{Val}$ is set to $\bot_\msf{invalid}$ on the right whenever $\tilde{d}=\bot$ (see \Cref{algo:K:i}).

Thus, to prove \Cref{eq:reduce:K:Ki}, it suffices to upper-bound the RHS of \Cref{eq:uniqueness:Ki:3}  by {$\epsilon_2(\secpar)+\negl(\secpar)$}. Towards that, we now compare the RHS of \Cref{eq:uniqueness:Ki:3} with the corresponding condition on the {\em committed} value in \Cref{prot:bbnmc:extcom} on the right in machine $\mcal{G}_i$ (see \Cref{algo:G:i}). Recall that $\mcal{K}_i$ differs from $\mcal{G}_i$ only by its invocation of the $\SimExt_\ExtCom$ with error parameter {$\epsilon_2$} in the right \Cref{prot:bbnmc:extcom}. Thus, it follows from the extractability with $\epsilon_2$-simulation of the right \Cref{prot:bbnmc:extcom} that
\begin{align*}
    \forall i \in [\tilde{t}],&~\Pr[\big(\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}),\bot_{\tilde{Y}}}\big) \wedge \big( \tilde{d} = \top \big): \msf{Val} \gets \mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}] \\
    & \leq \Pr[\big(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top \big): (\OUT,\tilde{d})\gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] + \epsilon_2, \numberthis \label[Inequality]{pq:eq:bound:Ki:invalid:to-Gi}
\end{align*}
where $\tilde{\alpha}$ denotes the value statistically bound (i.e., the committed value) in \Cref{prot:bbnmc:extcom} of the right in machine $\mcal{G}_i$.

\Cref{pq:eq:bound:Ki:invalid:to-Gi} essentially reduces the almost uniqueness of $\mcal{K}_i$ to that of machine $\mcal{G}_i$. That is, we claim that to prove \Cref{eq:reduce:K:Ki}, it suffices to prove the following \Cref{pq:claim:Gi:lb:soundness}.
\begin{lemma}[Almost Uniqueness of $\mcal{G}_i$]\label{pq:claim:Gi:lb:soundness}
 For $\mcal{G}_i$ as defined, we have that
$$\forall i\in [\tilde{t}],~ \Pr[\big(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big( \tilde{d} = \top\big):(\OUT,\tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \leq  \negl(\secpar).$$
\end{lemma}
\begin{proof}[Proof of \Cref{pq:claim:Gi:lb:soundness} (Sketch)]
This proof follows from standard techniques. Thus, we only provide a sketch.

At a high level, we prove this lemma by a reduction to the soundness of the commit-and-prove protocol shown in \Cref{protocol:BB-ZK}. Assuming \Cref{pq:claim:Gi:lb:soundness} is false, we can build a malicious $C^*$ that first commit to the value $\tilde{\alpha}$ (by forwarding $\mcal{M}$'s commitment in \Cref{prot:bbnmc:extcom} of the right session to the external honest receiver), and then convince the external receiver that $F^C_{\msf{consis}}$ is satisfied with non-negligible probability. However, this should not happen because, by the condition in \Cref{pq:claim:Gi:lb:soundness}, $\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}$ and thus $F^C_{\msf{consis}}$ is {\em not} satisfied. 

The only caveat is: the external receiver will specify a random challenge set $\eta$, but in machine $\mcal{G}_i$ this set $\eta$ is determined by the trapdoor coin-flipping in \Cref{prot:bbnmc:cointoss}. To make sure that we can indeed employ the internal right session with $\mcal{M}$ to convince the external receiver, we have to make sure that the internal right session uses the $\eta$ sampled by the external receiver. To do that, first notice that if $\tilde{\alpha} \notin \Set{\tilde{x}_j}_{j \in [\tilde{t}]}$, then the trapdoor predicate $\phi(\cdot)$ in \Cref{prot:bbnmc:cointoss} in the right session will not be satisfied. By the security of the trapdoor coin-flipping protocol (in particular, \Cref{def:com-n-prove:property:4} in \Cref{def:com-n-prove}), there must exist a simulator $\Sim$ that can `enforce' the coin-flipping result to a random $\eta$ sampled independently. Using this $\Sim$, we can make sure that the internal $\mcal{M}$ indeed generates a proof of consistency using the external receiver's $\eta$.

\end{proof}

With \Cref{pq:claim:Gi:lb:soundness} in hand, it is straightforward to see that \Cref{eq:uniqueness:Ki:3,pq:eq:bound:Ki:invalid:to-Gi} and \Cref{pq:claim:Gi:lb:soundness} together immediately implies \Cref{eq:reduce:K:Ki}. 

This finishes the proof for \Cref{pq:property:small-tag:proof:se:proof:K:syntax} in \Cref{pq:lem:small-tag:proof:se:proof:K}. 





%End proof
\iffalse 
For any $\mcal{G}_i$ (for $i \in [\tilde{t}]$), recall that \Cref{pq:claim:Gi:lb:soundness} implies 
\xiao{not true yet}
$$\Pr[\big(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top\big)] \geq \Pr[\tilde{d} = \top]\cdot (1-\negl(\secpar))$$

Let $p_\top$ denote the event in $\mcal{G}_i$ that $\tilde{d} = \top$. It follows that
 % $$\forall i \in [\tilde{t}],~\Pr[(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top):(\OUT,\tilde{d}) \gets \mcal{G}_1''(\msf{pref'})] \geq p_\top \cdot (1-\negl(\secpar))$$. 
 $$\forall i\in [\tilde{t}],~\Pr[\big(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top\big)] \geq p_\top\cdot (1-\negl(\secpar)).$$

Now by definition of the output $\msf{Val}$ in $\mcal{K}_i$ (recall that $\mcal{K}_i$ is essentially just $\mcal{G}_i$ but also extracting the value in \Cref{prot:bbnmc:extcom} on the right), we can say that $$\forall i \in [\tilde{t}],~\Pr[\msf{Val = \bot_\msf{invalid}}: \msf{Val} \gets \mcal{K}_i(\msf{pref'})] = 1-p_\top$$ Similarly, we can say that $$\forall i \in [\tilde{t}],~\Pr[\msf{Val} = \msf{val}(\tilde{\tau}) \vee \msf{Val} = \bot_{\tilde{Y}}:\msf{Val} \gets \mcal{K}_i(\msf{pref'})] \ge p_\top\cdot(1-\negl(\secpar))\cdot(1-\zeta'(\secpar))$$ where we denote the error parameter for $\SimExt_\ExtCom$ used by $\mcal{K}_i$ by $\zeta'(\secpar)$. Combining these facts, we can in turn say that 
$$\forall i \in [\tilde{t}],~\Pr[\msf{Val} \in \Set{\msf{val}(\tilde{\tau}),\bot_\msf{invalid},\bot_{\tilde{Y}}} : \msf{Val} \gets \mcal{K}_i(\msf{pref'})] \geq 1 -\zeta'(\secpar)- \negl(\secpar) \geq 1 - \zeta(\secpar)$$ i.e. $$\Pr[\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}),\bot_\msf{invalid},\bot_{\tilde{Y}}} : \msf{Val} \gets \mcal{K}(\msf{pref'})] \leq \zeta(\secpar)$$ 
where we set $\zeta(\secpar) \coloneqq 2\zeta'(\secpar)$. The last inequality then follows since $\mcal{K}$ involves running a random $\mcal{K}_i$ for $i \in [\tilde{t}]$, and the above is an uniform bound over $i$. This proves \Cref{pq:property:small-tag:proof:se:proof:K:syntax}. 
\fi 




\iffalse

We are now ready to consider the corresponding lower bound for the extracted value in $\mcal{K}_1''$ being one of the possible puzzle solutions (on the right). Before stating this bound, we will consider a few preparatory claims about the machines defined so far that will be helpful in its proof. 

\begin{MyClaim}\label{pq:claim:Ki:validity}
 For $\mcal{K}_i$ as defined, we have that $$\forall i \in [\tilde{t}],\ \Pr[\msf{Val} \neq \bot_\msf{invalid}: \msf{Val} \gets \mcal{K}_i(\msf{pref'})] \geq p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \negl(\secpar)$$
\end{MyClaim}

\begin{proof}
Recall that, by \Cref{pq:claim:bound:Gi}, we have
$$\forall i \in [\tilde{t}], ~\Pr[\tilde{d} = \top : (\OUT, \tilde{d}) \gets \mcal{G}_i(\msf{pref})] \ge p^{\msf{Sim}}_{\msf{pref'}} - 8\epsilon_1 -\negl(\secpar)$$ 
next, we claim that (again denoting by $\tilde{\alpha}$ the value committed by $\mcal{M}_\secpar$ in the right \Cref{prot:bbnmc:extcom})
$$\forall i \in [\tilde{t}], ~\Pr[(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i(\msf{pref})] \geq p^{\msf{Sim}}_{\msf{pref'}} - 8\epsilon_1 - \negl(\secpar)$$ 
This can be shown by reducing to the soundness of the MPC-in-the-head based ZK argument system for the relation $\Relation^C_\msf{consis}$ and is essentially identical to the proof for \Cref{pq:claim:K1dstar:comval}. 

Recall that $\mcal{K}_i$ is just the machine $\mcal{G}_i$ that additionally invokes $\SimExt_\ExtCom$ in \Cref{prot:bbnmc:extcom} on the right. In turn, we can then say that $$\forall i \in [\tilde{t}],\ \Pr[\msf{Val} \neq \bot_\msf{invalid}: \msf{Val} \gets \mcal{K}_i(\msf{pref'})] \geq p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \negl(\secpar)$$ where we again rely on the statistical simulation-extraction guarantee of $\ExtCom$ (w.r.t. error parameter $\epsilon_1$). This completes the proof of \Cref{pq:claim:Ki:validity}.
\end{proof}

To derive our final contradiction, we will need to use our initial assumption \Cref{pq:eq:Ki:contra-assump}. Note that the upper bound for $\mcal{K}_1''$ we gave earlier does not rely on this assumption. However, our lower bound for extraction in $\mcal{K}_1''$ will in fact use this, and in fact we bring in this assumption at the current stage of our proof of the lower bound.  

So far, we have considered and bounded the probability that $\msf{Val}$ in $\mcal{K}_i$ is not $\bot_\msf{invalid}$. By definition, in such an event, $\msf{Val}$ can then take on the values $\bot_{\tilde{Y}}$ or $\msf{val}(\tau)$. The latter event is precisely the quantity bound by our assumption. We can therefore say $$\forall i \in [\tilde{t}],\ \Pr[\msf{Val} \neq \bot_\msf{invalid}] = \Pr[\msf{Val} = \msf{val}(\tau)] + \Pr[\msf{Val} = \bot_{\tilde{Y}}]$$ where $\msf{Val}$ is generated as in $\mcal{K}_i$ (and not explicitly indicated for clarity). 

Recall that $\tilde{v}$ is used to denote the value extracted by $\SimExt_\ExtCom$ in the right \Cref{prot:bbnmc:extcom}. We can then say that $\Pr[\msf{Val} = \bot_{\tilde{Y}}] = \Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]}]$. Therefore, we have that for all $i \in [\tilde{t}]$,
$$\Pr[\msf{Val} \neq \bot_\msf{invalid}] = \Pr[\msf{Val} = \msf{val}(\tau)] + \Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]}]$$
That is to say, for each $i \in [\tilde{t}]$, these values in $\mcal{K}_i$ satisfy $$\Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]}] = \Pr[\msf{Val} \neq \bot_\msf{invalid}] - \Pr[\msf{Val} = \msf{val}(\tau)]$$ 
which in turn, by the bound in \Cref{pq:eq:Ki:contra-assump}, implies 

$$\forall i \in [\tilde{t}],~\Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]}: \tilde{v} \gets \mcal{K}_i(\msf{pref'})] \geq p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \epsilon' - \negl(\secpar)$$

Next we consider the term $\Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]}]$. We can further decompose this as $$\Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]}: \tilde{v} \gets \mcal{K}_i(\msf{pref'})] = \Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{K}_i(\msf{pref'})] + \Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}}: \tilde{v} \gets \mcal{K}_i(\msf{pref'})]$$

We now claim that 

\begin{MyClaim}\label{pq:claim:Ki:vss-hide}
For $\mcal{K}_i$ as defined, we have that $$\forall i \in [\tilde{t}],~\Pr[\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}}: \tilde{v} \gets \mcal{K}_i(\msf{pref'})] \leq \negl(\secpar)$$ 
\end{MyClaim}

\begin{proof}
We begin by fixing an arbitrary $i \in [\tilde{t}]$. The claim shown using a straightforward reduction using $\mcal{K}_i$ to the hardness of the $\VSS_\algo{HIDE}$ challenge. We outline this reduction $\msf{Red'}$ below: 
\begin{itemize}
    \item $\msf{Red'}$ picks two tuples of messages $\Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}}$ and $\Set{\tilde{x}'_j}_{j \in [\tilde{t}] \setminus \Set{i}}$ that are distinct in every entry (i.e., $\tilde{x}_j \neq \tilde{x}'_j ~\forall j \in [\tilde{t}] \setminus \Set{i}$) and an arbitrary string $\tilde{x}_i$. 
    It externally starts participating in the $\VSS_\algo{HIDE}$ challenge 
    and sends the tuples $\Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i},\tilde{x}_i}$ and $\Set{\tilde{x}'_j}_{j \in [\tilde{t}] \setminus \Set{i},\tilde{x}_i}$ to the challenger. 
    \item Internally, $\msf{Red'}$ starts executing $\mcal{K}_i$ (with honestly generated prefix $\msf{pref'}$ as input). It preceeds with this execution till \Cref{bbnmc:hard-puzzle:com-ch} on the right. At this stage it `forwards out' the $\ExtCom$ interaction from $\mcal{M}_\secpar$ committing to $\msf{ch}$ to the external challenger (instead of committing to an opening challenge on its own). 
    \item The challenger sends a commitment to VSS shares $\Set{\msf{v}_i}_{i \in [n]}$ of either $\Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i},\tilde{x}_i}$ or $\Set{\tilde{x}'_j}_{j \in [\tilde{t}] \setminus \Set{i},\tilde{x}_i}$. $\msf{Red'}$ forwards these commitments to $\mcal{M}_\secpar$ (at \Cref{bbnmc:hard-puzzle:rv-1} on the right). 
    \item Internally, $\mcal{M}_\secpar$ then decommits to $\msf{ch}$, and $\msf{Red'}$ forwards this to the external challenger, which then responds with the views $\Set{\msf{v}_i}_{i \in \msf{ch}}$ (where we have abused notation to identify $\msf{ch}$ with a subset of $[n]$). 
    \item $\msf{Red'}$ then uses these revealed views to continue the internal execution up to \Cref{prot:bbnmc:extcom} on the right (starting with \Cref{bbnmc:hard-puzzle:rv-2}). Note that $\Set{\msf{v}_i}_{i \in \msf{ch}}$ is enough information to perform this task (the subsequent opened views for parties in $\msf{ch}$ can be obtained from these initial views, the unopened commitments can be commitments to arbitrary strings). 
    \item $\msf{Red'}$ then internally invokes the extractor $\SimExt_\ExtCom$ for \Cref{prot:bbnmc:extcom} on the right as in $\mcal{K}_i$ to get an extracted value $\tilde{v}$. It parses $\tilde{v}$ as $j||x^*_j$ and checks if $x^*_j = x_j$ or $x^*_j = x'_j$. If so, it guesses accordingly in the external security challenge. If not, it sets its guess as a uniform bit. It stops execution at this points   
\end{itemize}

We analyse the success of this reduction. For clarity, let $\Set{\tilde{y}_j}_{j \in [\tilde{t}]\setminus \Set{i}}$ denote the committed tuple. If we have 
$$\Pr[\tilde{v} \in \Set{\tilde{y}_j}_{j \in [\tilde{t}]\setminus \Set{i}}: \tilde{v} \gets \mcal{K}_i(\msf{pref'})] \geq \nu(\secpar)$$
then the success of this reduction can be described as: $\Pr[\msf{Red'} ~\textnormal{wins}]$ $$=\Pr[\msf{Red'}~\textnormal{wins}| \tilde{v} \in \Set{\tilde{y}_j}]\cdot\Pr[\tilde{v} \in \Set{\tilde{y}_j}] + \Pr[\msf{Red'}~\textnormal{wins}| \tilde{v} \notin \Set{\tilde{y}_j}]\cdot\Pr[\tilde{v} \notin \Set{\tilde{y}_j}]$$ 
then, by our arguments above, $\msf{Red'}$ has perfect success when $\tilde{v}$ is indeed an admissible puzzle solution (for a slot not equal to $i$), and has success half otherwise (since it guesses uniformly). Hence we can write $$\Pr[\msf{Red'} ~\textnormal{wins}] = 1.\nu + \frac{1}{2}\cdot(1-\nu) = \frac{1}{2} + \frac{\nu}{2}$$ which is a non-negligible advantage. Also observe that $\msf{Red'}$ is an efficient procedure. This contradicts the hardness of the $\VSS_\algo{HIDE}$ challenge. This completes the proof of \Cref{pq:claim:Ki:vss-hide}  

\end{proof}

Using this claim, it is straightforward to argue that 

\begin{equation}\label[Inequality]{pq:eq:Ki:output:xi}
    \forall i \in [\tilde{t}],~\Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{K}_i(\msf{pref'})] \geq p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \epsilon'- \negl(\secpar)
\end{equation}

Next, we show that 

\begin{MyClaim}\label{pq:claim:Kiprime:lowerbound}
We have that
$$\forall i \in [\tilde{t}],~\Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{K}_i'(\msf{pref'})] \geq 
\frac{\Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{K}_i(\msf{pref'})]}{t} \geq \frac{p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \epsilon'}{t} -\negl(\secpar)$$
\end{MyClaim}

\begin{proof}
Note that $\mcal{K}_i'$ differs from $\mcal{K}_i$ only in how it computes the value committed in \Cref{prot:bbnmc:extcom} on the left. However, to argue that this change does not change the behavior of $\mcal{M}_\secpar$, we cannot rely directly on the hiding of $\ExtCom$. This is since the corresponding step on the right in these machines involves using $\SimExt_\ExtCom$ with $\mcal{M}$, and the hiding of $\ExtCom$ is not guaranteed in the presence of such extraction in parallel. We instead use the following observation. In $\mcal{K}_i$, in \Cref{bbnmc:hard-puzzle:rv-2} on the left, the value $(j,x_j)$ is extracted (using $\SimExt$) and subsequently committed to. In $\mcal{K}_i'$, a puzzle solution $(s,x_s)$ is obtained by brute-forcing the receiver commitments to all the solution values, and then picking uniformly from among them. In the case where $j=s$, it is easy to see that the distributions of messages generated by $\mcal{K}_i$ and $\mcal{K}_i'$ are {\em identical} for all $i \in [\tilde{t}]$. Further, we have that $j=s$ with probability $\frac{1}{t}$ (since $s$ is sampled uniformly). The claim follows. 

\end{proof}

Next, note that the machines $\mcal{K}_i'$ and $\mcal{\hat{G}}_i$ only differ in that $\mcal{\hat{G}}_i$ no longer invokes $\SimExt_\ExtCom$ to extract from \Cref{bbnmc:hard-puzzle:rv-2} on the left. As a consequence, we can then say  

\begin{equation}\label[Inequality]{pq:eq:Kidprime:lowerbound}
\forall i \in [\tilde{t}],~\Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{\hat{G}}_i(\msf{pref'})] \geq \frac{p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \epsilon'}{t} -\epsilon_1 -\negl(\secpar)
\end{equation}

Next, we will compare the machines $\mcal{\hat{G}}_i$ and $\mcal{K}_1''$: 

\begin{MyClaim}\label{pq:claim:Kidprime:similarity}
We have that, for each $i \in [\tilde{t}]$
$$ \bigg| \Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{\hat{G}}_i(\msf{pref'})] - \Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{K}_1''(\msf{pref'})] \bigg| \leq 2\epsilon_1 + \negl(\secpar)$$
\end{MyClaim}


\begin{proof}
We sketch this argument since it closely mimics the (indirect) similarity arguments for the machines $\mcal{G}_i'$ and $\mcal{G}_1'$ (within the proof of \Cref{pq:claim:bound:Gi}). Briefly, the idea is to rely on the hiding of $\ExtCom$ in \Cref{bbnmc:hard-puzzle:rv-2} on the right. But the value committed in this step is also used by the receiver in \Cref{bbnmc:hard-puzzle:rv-3}, and this indistinguishability must be argued more carefully. The proper way to show this is to (i) first extract the challenge $\tilde{\msf{ch}}$ from $\mcal{M}_\secpar$ in \Cref{bbnmc:hard-puzzle:com-ch} on the right, (ii) use $\tilde{\msf{ch}}$ to simulate the opened views, (iii) simulate the unopened views with arbitrary garbage strings , and finally (iv) undo the simulation of views and the extraction of $\tilde{\msf{ch}}$ after changing the committed value in \Cref{bbnmc:hard-puzzle:rv-2} on the right. 

\end{proof}


Now we can finally state our lower bound: 

\begin{equation}\label[Inequality]{pq:eq:K1dprime:lowerbound}
\forall i \in [\tilde{t}],~\Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{K}_1''(\msf{pref'})] \geq \frac{p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \epsilon'}{t} -3\epsilon_1 -\negl(\secpar)
\end{equation}

This follows as an easy corollary of \Cref{pq:claim:Kidprime:similarity} and \Cref{pq:eq:Kidprime:lowerbound}. 


\para{The Final Contradiction.} We first recall the upper and lower bounds for the reader's convenience. 

The upper bound: $$\Pr[\msf{Val} \neq \bot_\msf{invalid}: \msf{Val} \gets \mcal{K}_1''(\msf{pref'})] \leq p^{\msf{Sim}}_{\msf{pref'}} + 2\epsilon_1 +\negl(\secpar)$$ 

The lower bound: $$\forall i \in [\tilde{t}],~\Pr[\tilde{v} = \tilde{x}_i: \tilde{v} \gets \mcal{K}_1''(\msf{pref'})] \geq \frac{p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \epsilon'}{t} -3\epsilon_1 -\negl(\secpar)$$

We start by considering the event in the upper bound expression in $\mcal{K}_1''$. We can write $$\Pr[\msf{Val} \neq \bot_{\msf{invalid}}] = \Pr[\msf{Val} = \msf{val}(\tilde{\tau})] + \sum^{\tilde{\tau}}_{i = 1}\Pr[\tilde{v} = \tilde{x}_i]$$ where $\msf{Val}$ and $\tilde{v}$ are both generated from the execution of $\mcal{K}_1''$ 

Now from the above, and by \Cref{pq:eq:K1dprime:lowerbound}, we can write

\begin{align*}
\Pr[\Val \ne \bot_{\msf{invalid}}] 
& = \Pr[\Val = \msf{val}(\tilde{\tau})]  + \Pr[\Val = \bot_{\tilde{Y}}] \\
& = \Pr[\Val = \msf{val}(\tilde{\tau})] + \sum_{i =1 }^{\tilde{t}} \Pr[w' = (i,\tilde{x}_i)] \numberthis \label{pq:eq:bound:K1dprime:final-contradiction:0}\\
& \ge  \sum_{i =1 }^{\tilde{t}} \Pr[w' = (i,\tilde{x}_i)] \\
& \geq \tilde{t}\cdot\bigg[\frac{p^{\msf{Sim}}_{\msf{pref'}} - 9\epsilon_1 - \epsilon'}{t} -3\epsilon_1 -\negl(\secpar)\bigg] \\
&\ge \tilde{t} \cdot \frac{1}{t} \cdot \big(\frac{p^{\msf{Sim}}_{\msf{pref'}} - 3(t+3)\epsilon_1 - \epsilon'}{t}\big) - \negl(\secpar) \numberthis \label[Inequality]{pq:eq:bound:K1dprime:final-contradiction:1}\\
\end{align*}

where we have collected negligible terms together. Now using the fact that we are in the one-sided setting, which implies that $\tilde{t} > t$, we can say

\begin{align*}
\Pr[\Val \ne \bot_{\msf{invalid}}] 
& \ge (1+\frac{1}{t}) \cdot (p_{\msf{pref'}}- 3(t+3)\epsilon_1 - \epsilon') - \negl(\secpar) \numberthis \label[Inequality]{pq:eq:bound:K1dprime:final-contradiction:2}\\
& = (1+\frac{1}{t}) \cdot \bigg(p_{\msf{pref'}}-\frac{3t^2+14t+9}{t+1}\cdot\epsilon_1 - \epsilon'\bigg)+ 2\epsilon_1 - \negl(\secpar) \\
& = (1+\frac{1}{t}) \cdot \bigg(p_{\msf{pref'}}- 2\epsilon'\bigg) + 2\epsilon_1 - \negl(\secpar) \numberthis \label{pq:eq:bound:K1dprime:final-contradiction:2.5}\\
& = p_{\msf{pref'}}^{\msf{Sim}}+ 2\epsilon_1 + \bigg(\frac{p^{\msf{Sim}}_{\msf{pref'}}}{t} - 2\epsilon' - \frac{2\epsilon'}{t}\bigg) - \negl(\secpar)\\
& \ge p^{\msf{Sim}}_{\msf{pref'}}+ 2\epsilon_1 + \frac{5t^2 - t -1}{5t^3}\cdot \epsilon(\secpar) - \negl(\secpar)) \numberthis \label[Inequality]{pq:eq:bound:K1dprime:final-contradiction:3}\\
\end{align*}

where \Cref{pq:eq:bound:K1dprime:final-contradiction:2.5} follows from our parameter setting $\epsilon_1(\secpar)=\frac{t+1}{3t^2+14t+9}\cdot \epsilon'(\secpar)$,  
and \Cref{pq:eq:bound:K1dprime:final-contradiction:3} follows from the assumption that $p^{\msf{Sim}}_{\msf{pref'}} \ge \epsilon(\secpar)$ and our parameter setting $\epsilon'(\secpar) = \frac{\epsilon(\secpar)}{10t^2}$.

Recall that $t$ is the tag taking values from $[n]$ with $n$ being a polynomial of $\secpar$. Also recall that $\epsilon(\secpar)$ is an inverse polynomial on $\secpar$. Therefore, \Cref{pq:eq:bound:K1dprime:final-contradiction:3} can be written as:
$$\Pr[\Val \ne \bot_{\msf{invalid}}:\Val \gets \mcal{K}''_1({\msf{pref'}})] \ge p^{\msf{Sim}}_{\msf{pref'}} + \frac{1}{\poly(\secpar)} - \negl(\secpar),$$
which contradicts \Cref{pq:lem:K1dprime:upperbound}. We therefore conclude that \Cref{pq:eq:Ki:contra-assump} cannot hold. This concludes the proof of 
\Cref{pq:lem:bound:Ki}, and hence of \Cref{pq:property:small-tag:proof:se:proof:K} of \Cref{pq:lem:small-tag:proof:se:proof:K}.


\para{Proving \Cref{pq:property:small-tag:proof:se:proof:K:syntax} of \Cref{pq:lem:small-tag:proof:se:proof:K}.} This is quite easy to see. By arguments essentially identical to the ones made in the proof of \Cref{pq:claim:K1dstar:comval}, we can say for the committed value $\tilde{\alpha}$ in the right \Cref{prot:bbnmc:extcom}:
$$\forall i \in [\tilde{t}],~\Pr[(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i(\msf{pref'})] \geq \Pr[\tilde{d} = \top: (\OUT,\tilde{d}) \gets \mcal{G}_i(\msf{pref'})]\cdot (1-\negl(\secpar))$$
We can in turn say that 
$$\forall i \in [\tilde{t}],~\Pr[\msf{Val} \in \Set{\msf{val}(\tilde{\tau}),\bot_\msf{invalid},\bot_{\tilde{Y}}} : \msf{Val} \gets \mcal{K}_i(\msf{pref'})] \geq 1 -\zeta'(\secpar)- \negl(\secpar) \geq 1 - \zeta(\secpar)$$ i.e. $$\Pr[\msf{Val} \notin \Set{\msf{val}(\tilde{\tau}),\bot_\msf{invalid},\bot_{\tilde{Y}}} : \msf{Val} \gets \mcal{K}(\msf{pref'})] \leq \zeta(\secpar)$$ 
where we denote the error parameter for $\SimExt_\ExtCom$ used by $\mcal{K}_i$ by $\zeta'(\secpar)$, and set $\zeta(\secpar) \coloneqq 2\zeta'(\secpar)$. The last inequality then follows since $\mcal{K}$ involves running a random $\mcal{K}_i$ for $i \in [\tilde{t}]$, and the above is an uniform bound over $i$. This proves \Cref{pq:property:small-tag:proof:se:proof:K:syntax}. 

We have therefore proved \Cref{pq:lem:small-tag:proof:se:proof:K} in full. 

\fi

% \subsection{Almost Uniqueness of $\mcal{G}_i$}
% \label{sec:almost-uniqueness:Gi}
% In this part, we prove \Cref{pq:claim:Gi:lb:soundness}.


% At a high level, we prove this lemma by a reduction to the soundness of the commit-and-prove protocol (\xiao{Cref}). Assume \Cref{pq:claim:Gi:lb:soundness} is false, we can build a malicious $C^*$ that first commit to the value $\tilde{\alpha}$ (by forwarding $\mcal{M}$'s commitment in \Cref{prot:bbnmc:extcom} of the right session to the external honest receiver), and then convince the external receiver that $F^C_{\msf{consis}}$ is satisfied with non-negligible probability. However, this should not happen because, by the condition in \Cref{pq:claim:Gi:lb:soundness}, $\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}$ and thus $F^C_{\msf{consis}}$ is {\em not} satisfied. 

% The only caveat is: the external receiver will specify a random challenge set $\eta$, but in machine $\mcal{G}_i$ this set $\eta$ is determined by the trapdoor coin-flipping in \Cref{prot:bbnmc:cointoss}. To make sure that we can indeed employ the internal right session with $\mcal{M}$ to convince the external receiver, we have to make sure that the internal right session uses the $\eta$ sampled by the external receiver. To do that, first notice that if $\tilde{\alpha} \notin \Set{\tilde{x}_j}_{j \in [\tilde{t}]}$, then the trapdoor predicate $\phi(\cdot)$ in \Cref{prot:bbnmc:cointoss} in the right session will not be satisfied. By the security of the trapdoor coin-flipping protocol (in particular, \Cref{def:com-n-prove:property:4} in \Cref{def:com-n-prove}), there must exist a simulator $\Sim$ that can `enforce' the coin-flipping result to a random $\eta$ sampled independently. Using this $\Sim$, we can make sure that the internal $\mcal{M}$ indeed generate a proof of consistency using the external receiver's $\eta$.


% \begin{enumerate}
%     \item
%     On input $\msf{pref}'$, it first performs brute-force computation to learn the value $\msf{val}(\tilde{\tau})$. Note that this step is not efficient. But this is fine since it happens before $C^*$ starts to take with the external honest receiver. This step can be regarded as non-uniform advice.
% \item
% It internally execute $\mcal{G}_i$ until the beginning of \Cref{prot:bbnmc:extcom}.
% \item
% It executes \Cref{prot:bbnmc:extcom} by forwarding the messages of the right session between its internal $\mcal{M}$ and the external honest receiver, as the commit stage for the external honest receiver.
% \item
% Next, it resumes the internal $\mcal{G}_i$ and run it until the end of \Cref{prot:bbnmc:puzzle-sol-reveal}. It learns the revealed hard-puzzle solutions $\Set{\tilde{x}_1, \ldots, \tilde{x}_{\tilde{t}}}$ in the right session. With these values, it can let the external receiver known the target predicate $G^C_{\msf{consis}}$ defined as follows:
% \begin{itemize}
% \item
% {\bf Predicate $G^C_{\msf{consis}}(\cdot)$:} It has $\msf{val}(\tilde{\tau})$ and $\Set{\tilde{x}_1, \ldots, \tilde{x}_{\tilde{t}}}$ hard-wired. On input $x$, it output 1 iff
% \begin{itemize}
% \item
% $x = \msf{val}(\tilde{\tau})$, {\bf or}
% \item
% $x$ can be parsed as $j\|a$ such that $a = \tilde{x}_j$.
% \end{itemize}
% \end{itemize}
% \item
% It then finish the remaining execution of $\mcal{G}_i$ 

% \end{enumerate}









% \UpdateLine




% We start by assuming, for the sake of contradiction, that there exits an $i\in [\tilde{t}]$ and a inverse polynomial $\nu(\cdot)$ such that for infinitely many $\secpar \in \Naturals$, it holds that
% \begin{equation}\label{pq:eq:Gi:lb:soundness:contra-assump}
%     \Pr[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) ~:~(\OUT, \tilde{d})\la\mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')}] = \nu(\secpar).
% \end{equation}

% To start, let us denote by $E$ the event under consideration, namely $[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top)]$. We consider additionally the event that $\tilde{\eta}^C = \tilde{\eta'}^C$, namely, the check enforced between \Cref{prot:bbnmc:cointoss:proof:init} and \Cref{prot:bbnmc:cointoss:proof:fin} on the right. Now let $\nu_1 \coloneqq \Pr[E \wedge (\tilde{\eta}^C \neq \tilde{\eta'}^C)]$, and $\nu_2 \coloneqq \Pr[E \wedge (\tilde{\eta}^C = \tilde{\eta'}^C)]$. Clearly we have that $\nu = \nu_1 + \nu_2$. 

% Our first step is to show that $\nu_1$ is at most negligible. In other words, 
% \begin{equation}\label[Inequality]{pq:eq:Gi:lb:soundness:nu1}
%     \nu_1 \coloneqq \Pr[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) \wedge (\tilde{\eta}^C \neq \tilde{\eta'}^C)] \leq \negl(\secpar)
% \end{equation}
% We show this by reducing to the soundness of the MPC-in-the-head based ZK argument system described in \Cref{protocol:BB-ZK}. Assume for contradiction that $\nu_1$ is indeed non-negligible. We describe a reduction $\msf{Red}_1$ that breaks the soundness of \Cref{protocol:BB-ZK}: 
% \begin{itemize}
%     \item $\msf{Red}_1$ internally starts running $\mcal{G}_i(\msf{pref'})$, and continues this execution till \Cref{prot:bbnmc:cointoss:reveal} on the right. At this point, it possesses the values $\tilde{\eta'}^C$ and $\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}$ (it has to sample these latter values itself playing the role of $\mcal{G}_i$). 
%     \item Externally, it invokes the soundness challenge for \Cref{protocol:BB-ZK} and sets the associated predicate to be $F^C_\msf{cointoss}$. Note that this predicate is specified completely by the values $\tilde{\eta'}^C,\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}$. It also sends across the statistically binding commitments made in \Cref{prot:bbnmc:extcom} and \Cref{prot:bbnmc:cointoss:setup} (note that the first message made in $\ExtCom$ act as such commitments) on the right by $\mcal{M}$ as the first message \xiao{(Isn't the VSScom state interactive?)} in the ZK execution. 
%     \item It then proceeds with the external ZK execution, while forwarding the messages from $\mcal{M}$ from \Cref{prot:bbnmc:cointoss:proof:init} to \Cref{prot:bbnmc:cointoss:proof:fin} on the right as the corresponding prover messages and the responses from the soundness challenger as the verifier messages (note that these steps in $\mcal{G}_i$ coincide exactly with step 2 onwards in the ZK protocol), up till the final prover message in the external challenge. 
%     \item It proceeds to conclude the internal execution of $\mcal{G}_i$. If this succeeds, $\msf{Red}_1$ then sends the message sent in \Cref{prot:bbnmc:cointoss:proof:fin} on the right as the final prover message. This completes the external challenge interaction and the reduction halts at this point. 
% \end{itemize}
% \para{Analysis:} We analyze the success of $\msf{Red}_1$ in breaking soundness. Consider the event $[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) \wedge (\tilde{\eta}^C \neq \tilde{\eta'}^C)]$. By assumption, this occurs with non-negligible probability, and we consider the case when this event occurs. In this case, we have that (i) $\tilde{\eta}^C \neq \tilde{\eta'}^C$, so the first clause of $F^C_\msf{cointoss}$ cannot be true, and (ii) $\tilde{\alpha} \notin \Set{\tilde{x}_j}_{j \in [\tilde{t}]}$, so the second clause of $F^C_\msf{cointoss}$ cannot be true either, and finally (iii) $\tilde{d} = \top$, and so in particular the receiver on the right accepts in \Cref{prot:bbnmc:cointoss:proof:fin}. Since the receiver in this stage of the protocol acts essentially as an honest ZK verifier in \Cref{protocol:BB-ZK}, we are assured that the proof interaction would also convince an honest verifier (since for \Cref{prot:bbnmc:cointoss} the messages from the receiver on the right don't change in distribution whether one generates them as specified in $\mcal{G}_i$ or instead uses verifier messages from the soundness challenge which simply runs the honest verifier algorithm). 

% Hence we can ascertain that when $[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) \wedge (\tilde{\eta}^C \neq \tilde{\eta'}^C)]$ holds, $\msf{Red}_1$ both picks an instance that is not in the specified language corresponding to $\Relation^C_\msf{cointoss}$ and also succeeds in convincing an honest verifier. It follows that whenever this event occurs, $\msf{Red}_1$ is able to win the soundness challenge. Thus if $\nu_1$ is indeed non-negligible, $\msf{Red}_1$ breaks soundness of \Cref{protocol:BB-ZK}. Since $\msf{Red}_1$ is an efficient non-uniform quantum procedure, this contradicts the soundness property of \Cref{protocol:BB-ZK}. 

% Similarly, we next show 
% \begin{equation}\label[Inequality]{pq:eq:Gi:lb:soundness:nu2}
%     \nu_1 \coloneqq \Pr[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) \wedge (\tilde{\eta}^C = \tilde{\eta'}^C)] \leq \negl(\secpar)
% \end{equation}

% %-Some nuances here. 

% We assume for contradiction that $\nu_2$ is non-negligible. Next, we describe another reduction $\msf{Red}_2$ that breaks the soundness of \Cref{protocol:BB-ZK}. This is somewhat different from $\msf{Red})_1$, and works as follows: 
% \begin{itemize}
%     \item $\msf{Red}_2$ receives $\msf{pref'}$ as input. It starts executing $\mcal{G}_i(\msf{pref'})$ internally, and continues this execution up till \Cref{prot:bbnmc:cointoss:setup} on the right. 
%     \item Externally, it starts participating in the soundness challenge for \Cref{protocol:BB-ZK} and sets the associated predicate to be $F^C_\msf{consis}$. Note that this predicate is specified completely by the values $\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}$ (which $\msf{Red}_2$ determines itself in the right session within the internal execution). It also sends across the statistically binding commitments made in \Cref{bbnmc:init-com}, \Cref{prot:bbnmc:extcom} and \Cref{prot:bbnmc:C-consis-com} (note that the first message made in $\ExtCom$ act as such commitments) on the right by $\mcal{M}$ as the first message in the ZK execution.
%     \item The challenger now initiates the coin tossing phase of the ZK protocol by committing to a random string $r_1$ using $\ExtCom$ in the external challenge. Instead of replying with a sampled string of its own, $\msf{Red}_2$ now invokes $\SimExt_\ExtCom$ in \Cref{prot:bbnmc:cointoss:setup} on the right in the internal execution, with error parameter $\nu_2/2$ (recall that by assumption, $\nu_2$ is non-negligible and so $\SimExt_\ExtCom$ here runs in polynomial time), and uses the extracted string $\tilde{\eta}^C$ as its response. Note that this is a deviation from $\mcal{G}_i$ internally, which would simply act as an honest $\ExtCom$ receiver in this step. 
%     \item The challenger now decommits to $r_1$, and $\msf{Red}_2$ forwards this as the receiver's message $\tilde{\eta}^R$ in \Cref{prot:bbnmc:cointoss:response} internally on the right. It continues with the internal execution. 
%     \item If the value $\tilde{\eta'}^C$ revealed in \Cref{prot:bbnmc:cointoss:reveal} does not equal the value $\tilde{\eta}^C$ extracted earlier, $\msf{Red}_2$ aborts. 
%     \item $\msf{Red}_2$ proceeds to complete its internal MIM execution. If the outcome $\tilde{d}$ is $\bot$, it aborts as well. Otherwise it continues to the next step.  
%     \item Finally, $\msf{Red}_2$ forwards the openings from \Cref{prot:bbnmc:mpc:reveal} as the final prover message in the external challenge to complete the interaction. After this step, it halts. 
% \end{itemize}
% \para{Analysis:} We consider the success of $\msf{Red}_2$ in breaking soundness. Similar to before, consider the case where $[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) \wedge (\tilde{\eta}^C = \tilde{\eta'}^C)]$ holds. If so, we have: (i) $\tilde{\alpha}$ (committed in \Cref{prot:bbnmc:extcom}) does not equal $\msf{val}(\tilde{\tau})$, so the first clause of $F^C_\msf{consis}$ cannot be satisfied, (ii) $\tilde{\alpha} \notin \Set{\tilde{x}_j}_{j \in [\tilde{t}]}$, hence the second clause of $F^C_\msf{consis}$ cannot be satisfied, (iii) $\tilde{\eta}^C = \tilde{\eta'}^C$, which ensures that the subset $T$ of revealed views is the same in the internal execution on the right as well as in the soundness challenge interaction, and finally $\tilde{d} = \top$ which ensures that the internal execution on the right (and in particular, the committer consistency phase) is accepted by an honest receiver, and so in turn the external function of $\msf{Red}_2$ is accepted by an honest verifier for \Cref{protocol:BB-ZK}. 

% Thus, whenever $[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) \wedge (\tilde{\eta}^C = \tilde{\eta'}^C)]$ holds, we can ascertain that $\msf{Red}_2$ both attempts to prove an instance that does not lie in $\Relation^C_\msf{consis}$, and also convinces an honest verifier for \Cref{protocol:BB-ZK}. Hence, whenever this event occurs, $\msf{Red}_2$ wins the external soundness challenge. It remains only to determine the probability with which this event occurs in the execution of $\msf{Red}_2$. By assumption, this event occurs in $\mcal{G}_i$ with probability $\nu_2$. The only difference between $\mcal{G}_i$ and the internal operation of $\msf{Red}_2$ is that the latter invokes $\SimExt_\ExtCom$ with error parameter $\nu_2/2$ in \Cref{prot:bbnmc:cointoss:setup} on the right instead of acting as the honest receiver (note that the same prefix is used in both cases). By the statistical simulatable-extractability of $\ExtCom$, we have that $\Pr[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top) \wedge (\tilde{\eta}^C = \tilde{\eta'}^C)]$ in $\msf{Red}_2$ is at least $\nu_2/2$. This implies that $\msf{Red}_2$, which is an efficient quantum procedure, breaks soundness with probability $\nu_2/2$, which is still non-negligible. This again contradicts the soundness property of \Cref{protocol:BB-ZK}. 

% Finally, since both $\nu_1$ and $\nu_2$ are at most negligible in $\secpar$, we have that $$\nu(\secpar) = \Pr[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top)] \leq \negl(\secpar)$$ This is just the condition we set out to prove. 


% This concludes the proof of \Cref{pq:claim:Gi:lb:soundness}.





% \subsection{sth don't know where to put}

% In this part, establish a claim \Cref{pq:claim:bound:Gi}.

% \xiao{don't konw why you put \Cref{pq:claim:bound:Gi}  here. In this claim, machines $\mcal{G}'_i$ and $\mcal{G}''_i$ is defined.} 





\subsection{Extraction Property of $\mcal{K}$}

In this part, we prove \Cref{pq:property:small-tag:proof:se:proof:K} of \Cref{pq:lem:small-tag:proof:se:proof:K}.

%  Recall that the goal here is to show that for any $\msf{pref'}$ in the support of $\tilde{H}^{\mcal{M}_\secpar}_{\msf{pre}}(\secpar, m, \rho_\secpar)$ , if $p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] \ge \epsilon(\secpar)$, then it holds that
% \begin{equation}\label[Inequality]{pq:eq:bound:averageK}
% \Pr[\Val = \msf{val}(\tilde{\tau}) : \Val \gets \mcal{K}{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}] \ge \frac{\epsilon'(\secpar)-\epsilon_2}{\tilde{t}}.
% \end{equation} 
By definition, $\mcal{K}$ simply picks an $i$ uniformly from $[\tilde{t}]$ and runs machine $\mcal{K}_i$. Thus, to establish \Cref{pq:property:small-tag:proof:se:proof:K} in \Cref{pq:lem:small-tag:proof:se:proof:K}, it suffices to show the following: 
\begin{lemma}\label{pq:lem:bound:Ki}
    % Let $\epsilon(\secpar) = \frac{1}{\poly(\secpar)}$ and $\epsilon'(\secpar) = \frac{\epsilon(\secpar)}{10t^2}$.
    % For any $\msf{pref'} = (\msf{st}_{\mcal{M}},\msf{st}_C, \msf{st}_R, \tau, \tilde{\tau},\eta,\msf{VI}_\eta)$ \xiao{in the support of ...}, if $p^{\msf{Sim}}_{\msf{pref'}} \ge \epsilon_1(\secpar)$ \red{($p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] \ge \epsilon(\secpar)$)},
    For the same parameter settings as in \Cref{pq:lem:small-tag:proof:se:proof:K}, it holds that 
    $$\exists i \in [\tilde{t}], ~\Pr[\Val = \msf{val}(\tilde{\tau}) :\Val \gets \mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}] \ge {\epsilon'(\secpar) - \epsilon_2(\secpar)}.$$ 
\end{lemma}
We claim that \Cref{pq:lem:bound:Ki} follows as a result of the following \Cref{pq:lem:bound:Gi} regarding machine $\mcal{G}_i$'s defined in \Cref{algo:G:i}.
\begin{lemma}[Validity of $\mcal{G}_i$]\label{pq:lem:bound:Gi}
    % \xiao{quantify $\epsilon_1$?}Let $\epsilon(\secpar) = \frac{1}{\poly(\secpar)}$ and $\epsilon'(\secpar) = \frac{\epsilon(\secpar)}{10t^2}$.
    % For any $\msf{pref'} = (\msf{st}_{\mcal{M}},\msf{st}_C, \msf{st}_R, \tau, \tilde{\tau},\eta,\msf{VI}_\eta)$ \xiao{in the support of ...}, if $p^{\msf{Sim}}_{\msf{pref'}} \ge \epsilon_1(\secpar)$ \red{(should be $p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] \ge \epsilon$)}, then 
    For the same parameter settings as in \Cref{pq:lem:small-tag:proof:se:proof:K}, it holds that 
$$
    \exists i \in [\tilde{t}],\ \Pr[\big(\tilde{\alpha} = \msf{val}( \tilde{\tau}) \big) \wedge \big(\tilde{d} = \top\big) ~:~(\OUT,\tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \ge \epsilon'(\secpar).
$$
\end{lemma}
In the following, we first prove \Cref{pq:lem:bound:Ki}, assuming \Cref{pq:lem:bound:Gi} holds. Then, we will show the proof of \Cref{pq:lem:bound:Gi} in \Cref{sec:proof:pq:lem:bound:Gi}, which represents the main technical task we perform in this section.

\begin{proof}(Proving \Cref{pq:lem:bound:Ki})
We will show this via contradiction. For the sake of contradiction, assume that \Cref{pq:lem:bound:Ki} does not hold. That is, we assume that under the parameter conditions in \Cref{pq:lem:bound:Ki}, it holds that 
\begin{equation}\label[Inequality]{pq:eq:Ki:contra-assump}
    \forall i \in [\tilde{t}],\ \Pr[\Val = \msf{val}(\tilde{\tau}) :\Val \gets \mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}] < {\epsilon'(\secpar) - \epsilon_2(\secpar)}.
\end{equation} 

First, recall from the description of machine $\mcal{K}_i$ (\Cref{algo:K:i}) that $\msf{Val}$ is set to $\bot_{\msf{invalid}}$ if $\tilde{d} = \bot$. Thus, it must hold that
\begin{align*}
& \Pr[\Val = \msf{val}(\tilde{\tau}) :\Val \gets \mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}] \\ 
=~& 
\Pr[\big(\tilde{v} = \msf{val}(\tilde{\tau})\big) \wedge \big( \tilde{d} = \top \big):\Val \gets \mcal{K}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')}]. \numberthis \label{pq:lem:bound:Gi:proof:diff:Ki:Ki:middle}
\end{align*} 

Next, recall that the only different between $\mcal{K}_i$ and $\mcal{G}_i$ lies in that $\mcal{K})_i$ additionally invoke the extractor with error parameter $\epsilon_2$ in \Cref{prot:bbnmc:extcom} of the right session. By the $\epsilon_2$-simulatable extractability of $\ExtCom$ (as per \Cref{def:epsilon-sim-ext-com:parallel}), it holds hat

% \UpdateLine

% We will now compare this event with the case where the value {\em committed} by $\mcal{M}$ by $\tilde{\alpha}$ %\xiao{??} 
% on the right in \Cref{prot:bbnmc:extcom} within $\mcal{G}_i$ happens to be $\msf{val}(\tilde{\tau})$. Here we rely closely on the strong simulation-extraction guarantee for $\SimExt_\ExtCom$. This guarantee posits that within the real and simulated executions, the {\em committed} values are identically distributed and the simulator-extractor extracts exactly the committed value whenever it is successful, and finally the simulator-extractor produces a post-execution state that is statistically $\epsilon$-close. Due to this guarantee, and by the above equality, we can say:  

%Consequently, if we denote the value committed by $\mcal{M}$ by $\tilde{\alpha}$ \xiao{??} on the right in \Cref{prot:bbnmc:extcom}, we can say, by the simulation-extraction guarantee of $\ExtCom$: 

\begin{align*}
&  \bigg| \Pr[\big(\tilde{\alpha} = \msf{val}(\tilde{\tau})\big) \wedge \big(\tilde{d} = \top \big) :(\OUT,\tilde{d}) \gets \mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')] \\ 
 &\hspace{3em} - 
 \Pr[\big(\Val = \msf{val}(\tilde{\tau})\big) \wedge \big(\tilde{d} = \top \big) :\Val \gets \mcal{K}_i(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')] \bigg| \leq \epsilon_2(\secpar) \numberthis \label[Inequality]{pq:lem:bound:Gi:proof:diff:Ki:Gi}
\end{align*}

\Cref{pq:lem:bound:Gi:proof:diff:Ki:Gi} \Cref{pq:lem:bound:Gi:proof:diff:Ki:Ki:middle}, and \Cref{pq:eq:Ki:contra-assump} together imply the following
$$
    \forall i \in [\tilde{t}],\ \Pr[\big(\tilde{\alpha} = \msf{val}( \tilde{\tau}) \big) \wedge \big(\tilde{d} = \top\big) :(\OUT,\tilde{d}) \gets \mcal{G}_i(\msf{pref'})] <  {\epsilon'(\epsilon)},
$$
which contradicts \Cref{pq:lem:bound:Gi}.

This completes the proof of \Cref{pq:lem:bound:Ki}.

\end{proof} 

This completes the proof for \Cref{pq:property:small-tag:proof:se:proof:K} of \Cref{pq:lem:small-tag:proof:se:proof:K}, modulo the proof of \Cref{pq:lem:bound:Gi} that we will present in \Cref{sec:proof:pq:lem:bound:Gi}.


\subsection{Validity of $\mcal{G}_i$}
\label{sec:proof:pq:lem:bound:Gi}
In this part, we present the proof for \Cref{pq:lem:bound:Gi}.

We first need to define (in \Cref{algo:G'i:G''i}) two helper machines $\mcal{G}'_i$ and $\mcal{G}''_i$ ($\forall i \in [\tilde{t}]$). They are machines very similar to the $\mcal{G}_i$.  
\begin{AlgorithmBox}[label={algo:G'i:G''i}]{Machines $\mcal{G}'_i$ and $\mcal{G}''_i$}
\para{Machine $\mcal{G}_i'{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}$:} For each $i \in [\tilde{t}]$, machine $\mcal{G}_i'{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}$ proceeds as follows: 
\begin{enumerate}
    \item \label[Step]{algo:G'i:G''i:step:1}
    It behaves identically as $\mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}$ (see \Cref{algo:G:i}) until the end of \Cref{bbnmc:hard-puzzle:rv-1}.


     
    \item \label[Step]{algo:G'i:G''i:step:2}
    It then performs {\em brute-force computation} to obtain the VSS shares $\Set{\msf{rv}^{(1)}_i}_{i \in [\tilde{t}]}$ committed by $\mcal{M}_\secpar$ in the \Cref{bbnmc:hard-puzzle:rv-1} Naor's commitment of the left session, and then runs the reconstruction algorithm $\VSS_\Recon$ to obtain the puzzle solutions $x_1||\dots||x_t$ (it aborts if reconstruction is unsuccessful).  
    \item \label[Step]{algo:G'i:G''i:step:3}
    It then samples an uniform index $s \pick [t]$ and commits to the value $(s||x_s)$ (i.e., it uses the $s$-th puzzle solution obtained from the previous step) in the left \Cref{prot:bbnmc:extcom}. 

    In more detail, it prepares $n$ views $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, 2k)$-$\VSS_\Share$ of the message $(s||x_s)$. It commits to each $\msf{cv}^{(2)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$, as the \Cref{prot:bbnmc:extcom} message of the left session.

    \item \label[Step]{algo:G'i:G''i:step:4}
	In \Cref{prot:bbnmc:puzzle-sol-reveal} of the left session, $\mcal{G}'_i$ checks the extracted $x_s$ is indeed the $s$-th puzzle solution as revealed by $\mcal{M}_\secpar$. If not, it aborts. 

    \item \label[Step]{algo:G'i:G''i:step:5}
    In \Cref{prot:bbnmc:C-consis-com} of the left session, it uses $(s\|x_s)$ as the `effective input' in the virtual execution of $F^C_\msf{consis}$. This is possible because $x_s$ is indeed the $s$-th puzzle solution, and thus $s\|x_s$ serves as a valid witness for the `second clause' of $F^C_\msf{consis}$.

    \item 
    All other steps are carried out as in $\mcal{G}_i$.
    
\end{enumerate}

\para{Machine $\mcal{G}_i''{(1^\secpar,  \msf{pref}')}$:} For each $i \in [\tilde{t}]$, $\mcal{G}_i''{(1^\secpar,  \msf{pref}')}$ works similarly to $\mcal{G}_i'$ except that $\mcal{G}_i''$ no longer runs the extractor $\SimExt_\ExtCom(1^\secpar, 1^{\epsilon_1^{-1}})$ in the left \Cref{bbnmc:hard-puzzle:rv-2}, and thus does not need the error parameter $\epsilon_1$ anymore. 
\end{AlgorithmBox}

\para{At a High Level.} we prove \Cref{pq:lem:bound:Gi} by contradiction. Assuming \Cref{pq:lem:bound:Gi} is false, we will derive the desired contradiction using the machine $\mcal{G}''_1$. In particular, we will prove an upper-bound and a lower-bound for the probability related to the committed value in the right \Cref{prot:bbnmc:extcom} in $\mcal{G}''_1$. We will show that these two bounds indeed contradict to each other, thus finishing the proof of \Cref{pq:lem:bound:Gi}.

In the following, we first present the upper-bound in \Cref{pq:lem:K1dprime:upperbound} and the lower-bound in \Cref{pq:claim:G1dprime:lowerbound} without a proof, and show how to derive the desired contradiction if these bounds hold. We then focus on establishing these bounds in \Cref{sec:G''1:upperbound,sec:G''1:lowerbound} respectively. 



\para{The Bounds.} The upper-bound is for the probability of the event that the value $\tilde{\alpha}$ committed by $\mcal{M}_\secpar$ in the right \Cref{prot:bbnmc:extcom} in $\mcal{G}_1''$ is `valid', i.e., it is either the message committed to initially on the right (namely, $\msf{val}(\tilde{\tau})$), or a legitimate puzzle solution (i.e., is among the strings $(\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}})$). We capture this formally in the following \Cref{pq:lem:K1dprime:upperbound}, and prove it in \Cref{sec:G''1:upperbound}. We remark that \Cref{pq:lem:K1dprime:upperbound} does not rely on the assumption (for contradiction) that \Cref{pq:lem:bound:Gi} is false.
    
\begin{lemma}[Upper Bound]\label{pq:lem:K1dprime:upperbound}
For the same parameter settings as in \Cref{pq:lem:bound:Gi}, it holds that
$$\Pr[\big(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top\big)~:~(\OUT,\tilde{d}) \gets \mcal{G}_1''{(1^\secpar,  \msf{pref}')}] \leq p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] + \epsilon_1 +\negl(\secpar).$$
\end{lemma}


The lower bound is for the probability of the event that  the value $\tilde{\alpha}$ committed by $\mcal{M}_\secpar$ in the right \Cref{prot:bbnmc:extcom} in $\mcal{G}_1''$ is actually a puzzle solution (i.e., is among the strings $(\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}})$).  This is formally stated as the following \Cref{pq:claim:G1dprime:lowerbound}. We present its proof in \Cref{sec:G''1:lowerbound}. We remark that \Cref{pq:claim:G1dprime:lowerbound} relies on the assumption (for contradiction) that \Cref{pq:lem:bound:Gi} is false.
\begin{lemma}[Lower bound]\label{pq:claim:G1dprime:lowerbound}
    Assume that \Cref{pq:lem:bound:Gi} is false. Then, for the same parameter settings as in \Cref{pq:lem:bound:Gi}, it holds that 
    $$
    \forall i \in [\tilde{t}],~\Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_1''(1^\secpar,  \msf{pref}')] \geq \frac{p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - {2\epsilon_1}- \epsilon'}{t} -{\epsilon_1} -\negl(\secpar).
    $$
\end{lemma}

\para{The Final Contradiction.} Assume \Cref{pq:lem:bound:Gi} is false. Using \Cref{pq:lem:K1dprime:upperbound,pq:claim:G1dprime:lowerbound}, we derive the desired contradiction in the following. All the probabilities below are taken over  $(\OUT, \tilde{d}) \la \mcal{G}''_1(1^\secpar, \msf{pref}')$, which we omit for notation succinctness.




% We start by considering the event in the upper bound expression in $\mcal{G}_1''$. We can write $$\Pr[\big(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top\big)] = \Pr[\big(\tilde{\alpha} = \msf{val}(\tilde{\tau})\big) \wedge \big(\tilde{d} = \top\big)] + \sum^{\tilde{\tau}}_{i = 1}\Pr[\big(\tilde{\alpha} = x_i\big) \wedge \big(\tilde{d} = \top\big)]$$ where these events are all generated as in $\mcal{G}_1''$. 
% \rohit{Need to readjust params --- done.}

% By the above, and from \Cref{pq:eq:Gidprime:lowerbound}, we can say 

\begin{align*}
\Pr[\big(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top\big)] 
& = 
\Pr[\big(\tilde{\alpha} = \msf{val}(\tilde{\tau})\big) \wedge \big(\tilde{d} = \top\big) ] + 
\sum_{i =1 }^{\tilde{t}} \Pr[\big(\tilde{\alpha} = x_i\big) \wedge \big(\tilde{d} = \top\big)] \\
& \ge  
\sum_{i =1 }^{\tilde{t}} \Pr[\big(\tilde{\alpha} = x_i\big) \wedge \big(\tilde{d} = \top\big)] \\
&\ge 
\tilde{t} \cdot 
\bigg(
\frac{p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]-2\epsilon_1 - \epsilon'}{t} - \epsilon_1- \negl(\secpar) 
\bigg)\numberthis \label[Inequality]{pq:eq:bound:Ki:final-contradiction:1}\\
& = 
\tilde{t} \cdot \frac{1}{t}\cdot \big( p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]-(t+2)\epsilon_1 - \epsilon' \big) - \negl(\secpar)\\ 
& \ge 
\frac{t+1}{t} \cdot \big(p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]-(t+2)\epsilon_1 - \epsilon'\big) - \negl(\secpar) \numberthis \label[Inequality]{pq:eq:bound:Ki:final-contradiction:2}\\
& = 
\frac{t+1}{t} \cdot \bigg( p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]-(t+2)\epsilon_1 - \epsilon' - \frac{t}{t+1} \cdot\epsilon_1\bigg) + \epsilon_1 - \negl(\secpar)\\
& =
\frac{t+1}{t} \cdot \bigg( p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]-\frac{t^2+4t+2}{t+1}\cdot\epsilon_1 - \epsilon' \bigg) + \epsilon_1 - \negl(\secpar)\\
& = 
\frac{t+1}{t} \cdot \big(p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]- 2\epsilon'\big)+ \epsilon_1 - \negl(\secpar) \numberthis \label{pq:eq:bound:Ki:final-contradiction:3}\\
& = 
p_{\msf{pref}}^{\msf{Sim}}[\epsilon_1]+ \epsilon_1 + \bigg(\frac{p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]}{t} - 2\epsilon' - \frac{2\epsilon'}{t}\bigg) - \negl(\secpar) \\
& \ge p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]+ \epsilon_1 + \frac{5t^2 - t -1}{5t^3}\cdot \epsilon - \negl(\secpar), \numberthis \label[Inequality]{pq:eq:bound:Ki:final-contradiction:4}\\
\end{align*}
where \Cref{pq:eq:bound:Ki:final-contradiction:1} follows from \Cref{pq:claim:G1dprime:lowerbound}, \Cref{pq:eq:bound:Ki:final-contradiction:2} follows from the assumption that $\tilde{t} \ge t+1$, \Cref{pq:eq:bound:Ki:final-contradiction:3} follows from our parameter setting $\epsilon_1(\secpar)=\frac{t+1}{t^2+4t+2}\cdot \epsilon'(\secpar)$,  
and \Cref{pq:eq:bound:Ki:final-contradiction:4} follows from the assumption that $p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1] \ge \epsilon(\secpar)$ and our parameter setting $\epsilon'(\secpar) = \frac{\epsilon(\secpar)}{10t^2}$.

Recall that $t$ is the tag taking values from $[n]$ with $n$ being a polynomial of $\secpar$. Also recall that $\epsilon(\secpar)$ is an inverse polynomial on $\secpar$. Therefore, \Cref{pq:eq:bound:Ki:final-contradiction:4} can be written as:
$$\Pr[\big(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top\big):(\OUT,\tilde{d}) \gets \mcal{G}_1''(1^\secpar,\msf{pref'})] \ge p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1] + \epsilon_1(\secpar)+ \frac{1}{\poly(\secpar)} - \negl(\secpar),$$
which contradicts the upper-bound shown in \Cref{pq:lem:K1dprime:upperbound}, yielding the desired contradiction. 


This concludes the proof of \Cref{pq:lem:bound:Gi}.





\subsection{The Upper Bound} 
\label{sec:G''1:upperbound} 
In this part, we present the proof for \Cref{pq:lem:K1dprime:upperbound}.

%Things to do: 
%- The lemma is now for G1''. We want to argue upper bound. 
%- We do this as before, starting with G1 and going via G1' and G1''. The bound should be an easy conditioning fact. 
%- overall error is \eps_1 instead of 2\eps_1 as before. 


We start by recalling from \Cref{eq:def:p-pref} that by definition: 
\begin{equation}\label{G''1:upperbound:proof:eq:1}
\Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] = p^{\msf{Sim}}_{\msf{pref'}}{[\epsilon_1]}.
\end{equation}

We will use the machines $\mcal{G}_1'$ and $\mcal{G}_1''$ (see \Cref{algo:G'i:G''i}). First, recall that compared with $\mcal{G}_1$, $\mcal{G}'_1$ performs a brute-force computation to learn $s \| x_s$ (as per \Cref{algo:G'i:G''i:step:2}); It commits to $s\|x_s$ in \Cref{prot:bbnmc:extcom} of the left session (as per \Cref{algo:G'i:G''i:step:3}) and use $s\|x_s$ as the witness to perform the proof of consistency in \Cref{prot:bbnmc:PoC} of the left session (as per \Cref{algo:G'i:G''i:step:5}). In other words, what $\mcal{G}_1'$ does is simply to change the witness committed in \Cref{prot:bbnmc:extcom} in the commit-and-prove protocol consisting of \Cref{prot:bbnmc:extcom} and \Cref{prot:bbnmc:PoC}; Note that that `witness' used by $\mcal{G}'_1$ (i.e., $s\|x_s$) still satisfies the target predicate $F^C_{\msf{consis}}$. This will not be noticed by $\mcal{M}_\secpar$ as the commit-and-prove protocol is witness-indistinguishable\footnote{This can be proven formally using standard techniques and thus we omit the details. A formal proof can be found in, e.g., \cite[Section 6.5]{C:CCLY22}.}. Also note that the brute-force computation performed by $\mcal{G}'_1$ does not affect the computational indistinguishability between $\mcal{G}'_1$ and $\mcal{G}_1$, as that step happens before the beginning of \Cref{prot:bbnmc:extcom} and can be treated as non-uniform advice when invoking the witness-indistinguishability of the commit-and-prove protocol. This argument implies the following:
\begin{align*}
& \bigg|\Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \\
&\hspace{3em} - \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1'{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}]\bigg| \leq \negl(\secpar). \numberthis \label[Inequality]{G''1:upperbound:proof:eq:2}
\end{align*}
\Cref{G''1:upperbound:proof:eq:1} and \Cref{G''1:upperbound:proof:eq:2} together imply the following:
\begin{equation}\label[Inequality]{pq:eq:G1prime:ub:success}
    \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1'{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \leq p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] +\negl(\secpar)
\end{equation}


Next, notice that the difference between $\mcal{G}'_1$ and $\mcal{G}''_1$ is that the latter stops running machine $\SimExt_\ExtCom(1^\secpar, 1^{\epsilon_1^{-1}})$ (see \Cref{algo:G'i:G''i}). Thus, $\mcal{G}'_1$ and $\mcal{G}''_1$ are at most $\epsilon_1$-far. Therefore, \Cref{pq:eq:G1prime:ub:success} implies the following:
\begin{equation}\label[Inequality]{pq:eq:G1dprime:ub:success}
    \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1''{(1^\secpar,  \msf{pref}')}] \leq p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] + \epsilon_1(\secpar) +\negl(\secpar)
\end{equation}
\Cref{pq:eq:G1dprime:ub:success} immediately implies the inequality in \Cref{pq:lem:K1dprime:upperbound}.

This completes the proof of \Cref{pq:lem:K1dprime:upperbound}.

\iffalse 
\begin{MyClaim}\label{pq:claim:G1dprime:ub:comval}  
For $\mcal{K}_1^{**}$ as defined above, we have that
$$ \bigg| \Pr[(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{K}_1^{**}(\msf{pref'})] - \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{K}_1^{**}(\msf{pref'})] \bigg| \le \negl(\secpar)$$
\end{MyClaim}
\begin{xiaoenv}{}
only one direction is correct. Should be:
$$  \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{K}_1^{**}(\msf{pref'})]  - \Pr[(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{K}_1^{**}(\msf{pref'})]  \le \negl(\secpar)$$
\end{xiaoenv}


\begin{proof}
We want to show that whenever $\tilde{d} = \top$ in $\mcal{K}_1^{**}$ (i.e., the right session is executed successfully and accepted by $R$), we have that $\tilde{\alpha}$ is actually within the set of valid values specified by $F^C_\msf{consis}$, with overwhelming probability. It will suffice then to show that the value $\tilde{\alpha}$ is not within the set of valid values with at most negligible probability. Namely, it will be enough to show that 

\begin{equation}\label[Inequality]{pq:eq:K1dstar:contra-assump}
    \Pr[(\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{K}_1^{**}(\msf{pref'})] \leq \negl(\secpar)
\end{equation}

Assume otherwise for the sake of contradiction. That is, suppose we have that 

$$\Pr[\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{K}_1^{**}(\msf{pref'})] \geq \nu(\secpar)$$

where $\nu \coloneqq \nu(\secpar)$ is a non-negligible function. Then we can build a reduction $\msf{Red}$ to the soundness of the MPC-in-the-head based zero knowledge argument that we use. This works as follows: 
\begin{itemize}
    \item Internally, $\msf{Red}$ starts running $\mcal{K}_1^{**}$. It proceeds with the internal execution up to \Cref{prot:bbnmc:C-consis-com}. 
    \item Externally, $\msf{Red}$ engages in the soundness challenge for the MPC-in-the-head based zero knowledge argument system, with respect to the relation $\Relation^C_\msf{consis}$ corresponding to $F^C_\msf{consis}$, which essentially states that $\tilde{\alpha}$ takes values only in the set $\Set{\msf{val}(\tilde{\tau}),\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}}$ (note that the statement is available to $\msf{Red}$ at this stage of the internal execution). It receives a commitment to the verifier challenge $\Com(\msf{ch})$ from the soundness challenger. 
    \item It obtains commitments to the values $\Set{\msf{cv}^{(1)}_j,\msf{cv}^{(2)}_j,\msf{cv}^{(3)}_j}_{j \in [\tilde{t}]}$ sent by $\mcal{M}_\secpar$ from its view of the internal execution thus far and sends these to the external soundness challenger (note here that the values $\msf{cv}^{(2)}_j$ are committed using $\ExtCom$, but the first round of this protocol consists of a standard commitment using $\Com$ to the committed value, which $\msf{Red}$ can then record). 
    \item The challenger receives these commitments and replies by decommitting to $\msf{ch}$. $\msf{Red}$ then invokes $\SimExt_\ExtCom$ in \Cref{prot:bbnmc:cointoss:setup} on the right to extract the committed value $\tilde{\eta}^C$. It sets $\tilde{\eta}^C = \tilde{\eta}^C \oplus \msf{ch}$ and proceeds with the internal execution. 
    \item $\mcal{M}_\secpar$ then reveals $\tilde{\eta'}^{C}$ in \Cref{prot:bbnmc:cointoss:reveal} internally on the right. If $\tilde{\eta'}^{C} \neq \tilde{\eta}^{C}$, $\msf{Red}$ aborts the execution immediately. Otherwise it proceeds to conclude the internal execution of $\mcal{K}_1^{**}$ and records its output. 
    \item If the value $\tilde{d}$ obtained from the output of $\mcal{K}_1^{**}$, $\msf{Red}$ forwards $\mcal{M}_\secpar$'s response in \Cref{prot:bbnmc:cointoss:open} out to the soundness challenger (which completes the challenge interaction; the challenger then provides its verdict). At this point $\msf{Red}$ stops.   
\end{itemize}


\subpara{Analysis of $\msf{Red}$:} We consider the event that $E \coloneqq[\tilde{\alpha} \notin \Set{\msf{val}(\tilde{\tau}),\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}} \wedge \tilde{d} = \top]$. By assumption, this occurs with probability at least $\nu$. In case this event $E$ occurs, we must have that (i) $\msf{Red}$ proves a statement that does not satisfy $\Relation^C_\msf{consis}$, and (ii) $\msf{Red}$ succeeds in this proof. Consequently, conditioned on $E$ occuring, $\msf{Red}$ wins the soundness challenge whenever it does not abort. 

Let $\nu_2 \coloneqq \nu_2(\secpar)$ denote the probability that $\msf{Red}$ aborts. By definition, this is synonymous with the condition that $\tilde{\eta'}^{C} \neq \tilde{\eta}^{C}$. We claim that $\nu_2$ is negligible in $\secpar$. 

This is reasoned as follows: If it is the case that $\tilde{\eta'}^{C} \neq \tilde{\eta}^{C}$ while $\tilde{d} = \top$ (note we are analysing this event assuming $E$ holds), then the accompanying argument given by $\mcal{M}_\secpar$ in \Cref{prot:bbnmc:cointoss:proof:init} (for the relation $\Relation^C_\msf{cointoss}$) is accepted. Then only one of two cases can occur: 
\begin{itemize}
    \item Either the ZK argument for $\Relation^C_\msf{cointoss}$ proves a false statement. This can only occur with negligible probability. This is easy to see through a reduction very similar to $\msf{Red}$; this reduction will run $\mcal{K}_1^{**}$ internally and act just as $\msf{Red}$ does --- namely, it extracts $\tilde{\eta}^C$ and checks whether $\tilde{\eta'}^{C} \neq \tilde{\eta}^{C}$. If so, it externally invokes the soundness challenge and forwards out the interaction corresponding to the right MPC-in-the-head execution of $F^C_\msf{consis}$ (forcing the challenge just as $\msf{Red}$ does). Clearly, if this scenario occurs with non-negligible probability, then we violate the soundness of the MPC-in-the-head argument system (note that the reduction as outlined is an efficient machine). 
    \item Else, the `alternate clause' for $F^C_\msf{cointoss}$ is satisfied. Thus it must be the case that $\tilde{\alpha} \in \Set{\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}}$ (since $\tilde{\eta'}^{C} \neq \tilde{\eta}^{C}$ and $\Relation^C_\msf{cointoss}$ is still satisfied). This is clearly absurd since we assume that $E$ holds and therefore we have simultaeneously that $\tilde{\alpha} \in \Set{\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}}$ and $\tilde{\alpha} \notin \Set{\tilde{x}_1,\dots,\tilde{x}_{\tilde{t}}}$. Hence this case cannot occur as it leads to a contradiction. 
\end{itemize}
We conclude that $\nu_2$ is negligible in $\secpar$. By our above arguments, we then have that $\msf{Red}$ succeeds in winning the soundness challenge with probability $\nu - \nu_2$. Since $\nu_2$ is negligible, and $\nu$ is non-negligible by assumption, we conclude that $\msf{Red}$ violates soundness of the MPC-in-the-head ZK argument system (note here that $\msf{Red}$ as described is an efficient machine). We conlude in turn that the event $E$ can only occur with negligible probability. This proves \Cref{pq:eq:K1dstar:contra-assump}. The proof of \Cref{pq:claim:K1dstar:comval} immediately follows. 
\end{proof}



Note now that $\mcal{K}_1''$ is almost identical to the machine $\mcal{K}_1^{**}$ except for also invoking $\SimExt_\ExtCom$ on the right in \Cref{prot:bbnmc:extcom}. We can therefore claim: $$\Pr[\msf{Val} \neq \bot_\msf{invalid}: \msf{Val} \gets \mcal{K}_1''(\msf{pref'})] \leq p^{\msf{Sim}}_{\msf{pref'}} + 2\epsilon_1 +\negl(\secpar)$$
which is readily seen to hold by the (statistical) simulation-extraction guarantee for $\ExtCom$ (note that these machines are inefficient due to the brute-force extraction step on the left). This completes the proof of the upper bound in $\mcal{K}_1''$.  
\fi




\subsection{The Lower Bound}
\label{sec:G''1:lowerbound}
%Steps: 
%-> Figure out the proof of `valid' committed value in Gis. This will need the soundness argument. Start with claim of success in Gi and flesh out the soundness reduction. 
%-> Use the contradiction claim to rule out that the committed value is the right side committed message. 
%-> Then we will use the reduction to ExtCom hiding to argue that the committed value cannot be any puzzle solution but the first in G1.  
%-> Proceed to success in G1' and G1'' as before. 
In this part, we present the proof for \Cref{pq:claim:G1dprime:lowerbound}.

\para{Assumption for Contradiction.} As mentioned earlier, this proof (in particular, in the proof of \Cref{pq:claim:Gi:lb:comval}) will make use of the negation of \Cref{pq:lem:bound:Gi}, which is for the sake of contradiction. That is, we assume for contradiction that: Under the parameter setting of \Cref{pq:lem:bound:Gi}, it holds that
\begin{equation}\label[Inequality]{eq:negation:pq:lem:bound:Gi}
 \forall i \in [\tilde{t}],\ \Pr[\big(\tilde{\alpha} = \msf{val}( \tilde{\tau}) \big) \wedge \big(\tilde{d} = \top\big) ~:~(\OUT,\tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] < \epsilon'(\secpar)
\end{equation}

% We will now show our corresponding lower bound. In particular, this will be a bound on whether the committed value $\tilde{\alpha}$ equals the first puzzle solution (in the right interaction). The manner in which such a bound can be useful will be made clear when we derive our final contradiction. 

\para{Preparatory Claims.} Before showing this bound, we will first consider three preparatory claims (i.e., \Cref{pq:claim:bound:Gi,pq:claim:Gi:lb:comval,pq:claim:Gi:vss-hide}) regarding the machine $\mcal{G}_i$'s. They will help us to bound the probability regarding $\mcal{G}''_1$ as in \Cref{pq:claim:G1dprime:lowerbound} eventually.


\begin{MyClaim}\label{pq:claim:bound:Gi} 
For the same parameter settings as in \Cref{pq:claim:G1dprime:lowerbound}, it holds that 
$$\forall i \in [\tilde{t}], ~\Pr[\tilde{d} = \top ~:~ (\OUT, \tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \ge p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) -\negl(\secpar).$$
\end{MyClaim} 

\begin{proof} 

This lemma again makes use of the machines $\mcal{G}_1'$ and $\mcal{G}_1''$ defined in  \Cref{algo:G'i:G''i}.

We first claim that
\begin{align*}
\forall i \in [\tilde{t}],~ & \bigg|\Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \\
&\hspace{3em} - \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_i'{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}]\bigg| \leq \negl(\secpar). \numberthis \label[Inequality]{G''i:upperbound:proof:eq:2}
\end{align*} 
Indeed, we have already shown \Cref{G''i:upperbound:proof:eq:2} for the case $i = 1$ (see \Cref{G''1:upperbound:proof:eq:2}). \Cref{G''i:upperbound:proof:eq:2} follows from the same argument as we presented for \Cref{G''1:upperbound:proof:eq:2}. Thus, we omit the details.

Similarly, we also have the following `all-$i$' version of \Cref{pq:eq:G1dprime:ub:success}:
\begin{align*}
 \forall i \in [\tilde{t}],~& \bigg|\Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}'_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \\
&\hspace{3em} - \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_i''{(1^\secpar,  \msf{pref}')}]\bigg| \leq \epsilon_1(\secpar)  + \negl(\secpar). \numberthis \label[Inequality]{pq:eq:Gi:prime:ub:success}
\end{align*} 

Next, using a similar (non-uniform) argument as for \Cref{G''1:upperbound:proof:eq:2} over the commit-and-prove protocol consisting of the hard puzzle setup step (i.e., \Cref{bbnmc:hard-puzzle:puzzle-setup}) of the right session, we can establish the following
\begin{align*}
 \forall i \in [\tilde{t}],~& \bigg|\Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}''_i{(1^\secpar,  \msf{pref}')}] \\
&\hspace{3em} - \Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1''{(1^\secpar,  \msf{pref}')}]\bigg| \leq \negl(\secpar). \numberthis \label[Inequality]{pq:eq:G1:Gi:dprime:ub:success}
\end{align*}

Using \Cref{G''i:upperbound:proof:eq:2,pq:eq:Gi:prime:ub:success,pq:eq:G1:Gi:dprime:ub:success} by setting $i = 1$, we obtain 
\begin{equation}\label[Inequality]{eq:bound:G''1:by:p-pref}
\Pr[\tilde{d} = \top : (\OUT,\tilde{d}) \gets \mcal{G}_1''{(1^\secpar,  \msf{pref}')}]\bigg| \ge p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - \epsilon_1(\secpar)  - \negl(\secpar),
\end{equation}
where recall the definition of $p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1]$ from \Cref{eq:def:p-pref}.

Finally, we have the following for all $i \in [\tilde{t}]$:
\begin{align*}
& \Pr[\tilde{d} = \top : (\OUT, \tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \\ 
\ge~ & 
\Pr[\tilde{d} = \top : (\OUT, \tilde{d}) \gets \mcal{G}'_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] -\negl(\secpar) \numberthis \label[Inequality]{pq:claim:bound:Gi:final:eq:1} \\
\ge~ & 
\Pr[\tilde{d} = \top : (\OUT, \tilde{d}) \gets \mcal{G}''_i{(1^\secpar, \msf{pref}')}] - \epsilon_1(\secpar) - \negl(\secpar) \numberthis \label[Inequality]{pq:claim:bound:Gi:final:eq:2} \\
\ge~ & 
\Pr[\tilde{d} = \top : (\OUT, \tilde{d}) \gets \mcal{G}''_1{(1^\secpar,   \msf{pref}')}] - \epsilon_1(\secpar) - \negl(\secpar) \numberthis \label[Inequality]{pq:claim:bound:Gi:final:eq:3} \\
\ge~ & 
p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) - \negl(\secpar) \numberthis \label[Inequality]{pq:claim:bound:Gi:final:eq:4}
,\end{align*}
where \Cref{pq:claim:bound:Gi:final:eq:1} follows from \Cref{G''i:upperbound:proof:eq:2}, \Cref{pq:claim:bound:Gi:final:eq:2} follows from \Cref{pq:eq:Gi:prime:ub:success}, \Cref{pq:claim:bound:Gi:final:eq:3} follows from \Cref{pq:eq:G1:Gi:dprime:ub:success}, and \Cref{pq:claim:bound:Gi:final:eq:4} follows from \Cref{eq:bound:G''1:by:p-pref}.




    This concludes the proof of \Cref{pq:claim:bound:Gi}. 

\end{proof}



\begin{MyClaim}\label{pq:claim:Gi:lb:comval}
Assume that \Cref{pq:lem:bound:Gi} is false. For the same parameter settings as in \Cref{pq:claim:G1dprime:lowerbound}, it holds that
$$\forall i \in  [\tilde{t}],~\Pr[\big(\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big(\tilde{d} = \top \big):(\OUT,\tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')}] \geq p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) - \epsilon'(\secpar) - \negl(\secpar).$$
\end{MyClaim}


\begin{proof}
In the following, we will fix an arbitrary $i \in [\tilde{t}]$ and describe events only within $\mcal{G}_i$, and omit the rider that the variables in question are generated from $\mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')$ for notation convenience. 

First, it follows from \Cref{pq:claim:Gi:lb:soundness} and \Cref{pq:claim:bound:Gi} that
\begin{equation}\label[Inequality]{pq:claim:Gi:lb:comval:proof:eq:1}
\Pr[\big(\tilde{\alpha} \in \Set{\msf{val}(\tilde{\tau})} \cup \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big( \tilde{d} = \top\big)] \ge  p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) -\negl(\secpar).
\end{equation}
\Cref{pq:claim:Gi:lb:comval:proof:eq:1} and \Cref{eq:negation:pq:lem:bound:Gi} (i.e., our assumption for contradiction) together immediately imply
\begin{equation}
\Pr[\big(\tilde{\alpha} \in  \Set{\tilde{x}_j}_{j \in [\tilde{t}]}\big) \wedge \big( \tilde{d} = \top\big)] \ge  p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) - \epsilon'(\secpar) -\negl(\secpar).
\end{equation}

This completes the proof of \Cref{pq:claim:Gi:lb:comval}.

\end{proof}



% We can further consider the decomposition 
% \begin{equation}\label{eq:unused-2}
% \Pr[\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}]} \wedge (\tilde{d} = \top)] = \Pr[\tilde{\alpha} = \tilde{x}_i \wedge (\tilde{d} = \top)] + \Pr[\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}} \wedge (\tilde{d} = \top)]
% \end{equation}
% \xiao{need to figure out where we use \Cref{ineq:unused-1} and \Cref{eq:unused-2}.}


\begin{MyClaim}\label{pq:claim:Gi:vss-hide}
For the same parameter settings as in \Cref{pq:claim:G1dprime:lowerbound}, it holds that
$$\forall i \in [\tilde{t}],~\Pr[\big(\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}}\big) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')] \leq \negl(\secpar) ,$$
%where recall that the value $\tilde{v}$ is the value $\mcal{K}_i$ extracted from the right-side $\ExtCom$ \xiao{VSS version}. 
\end{MyClaim}

\begin{proof}
We first define a new machine $\mcal{G}^*_i$ as follows.

\begin{AlgorithmBox}[label={machine:Gi*}]{Machine \textnormal{$\mcal{G}^*_i(1^\secpar, 1^{\epsilon_1^{-1}},  1^{\epsilon^{*-1}}, \msf{pref}')$}} 
This machine takes an additional parameter $\epsilon^*$ than $\mcal{G}_i$. On input $(1^\secpar, 1^{\epsilon_1^{-1}},  1^{\epsilon^{*-1}}, \msf{pref}')$, $\mcal{G}^*_i$ is identical to $\mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}')$ except for the following difference:
\begin{itemize}
\item
In \Cref{bbnmc:hard-puzzle:com-ch} of the right session, it invokes the the extractor for $\ExtCom$ with simulation error set to $\epsilon^*$, to extracts the set $\tilde{\eta}$ committed by $\mcal{M}$.

\item
In \Cref{bbnmc:hard-puzzle:rv-3} of the right session, it prepares the shares $\Set{\tilde{\msf{rv}}^{(3)}_j}_{j\in [n]}$ differently. First, recall that each $\tilde{\msf{rv}}^{(3)}_j$ is the output of the MitH party $P_j$ using input $\tilde{\msf{rv}}^{(1)}_j\|\tilde{\msf{rv}}^{(2)}_j$ to compute the ideal functionality $F^R_{\msf{consis}}$. $\mcal{G}^*_i$ modifies the input to $P_j$'s as follows: 
\begin{itemize}
\item
It defines a new vector $(\tilde{x}^*_1, \ldots, \tilde{x}^*_{\tilde{t}})$, where $\tilde{x}^*_i$ is equal to the $\tilde{x}_i$ sampled in \Cref{bbnmc:hard-puzzle:rv-1}, but $\tilde{x}^*_j = 0^\secpar$ for all $j \ne i$.
\item
It creates a new set of VSS shares $\Set{\tilde{\msf{rv}}^{*(1)}_j}_{j \in [n]}$ for the new $(\tilde{x}^*_1, \ldots, \tilde{x}^*_{\tilde{t}})$ satisfying the requirement that $\tilde{\msf{rv}}^{*(1)}_j = \tilde{\msf{rv}}^{(1)}_j$ for all $j \in \tilde{\eta}$. That is, it takes the shares $\Set{\tilde{\msf{rv}}^{(1)}_j}_{j \in \tilde{\eta}}$, which is the VSS shares for the original vector $(\tilde{x}_1, \ldots, \tilde{x}_{\tilde{t}})$, and computes a new set of `the remainder' shares $\Set{\tilde{\msf{rv}}^{*(1)}_j}_{j \in [n]\setminus \tilde{\eta}}$, such that the new set $\Set{\tilde{\msf{rv}}^{*(1)}}_{i \in [n]\setminus \tilde{\eta}} \cup \Set{\tilde{\msf{rv}}^{(1)}}_{i \in \tilde{\eta}}$ constitutes VSS sharing of the new vector $(\tilde{x}^*_1, \ldots, \tilde{x}^*_{\tilde{t}})$. We remark that this is possible because any $k$ shares of a $(n+1, k)$-VSS scheme contain no information of the underlying secret; Thus, any $k$ shares of some secret can be `extended' to $n$ shares that constitute a VSS of a different secret. Indeed, the VSS scheme we use (from \cite{EC:CDDHR99}) satisfies this property.
\end{itemize}
With the above, $\mcal{G}^*_i$ prepares $\Set{\tilde{\msf{rv}}^{(3)}_j}_{j\in [n]}$ by running the $(n,k)$-MitH execution with party $P_j$ ($\forall j \in [n]$) using $\tilde{\msf{rv}}^{*(1)}_j\|\tilde{\msf{rv}}^{(2)}_j$ as its input.
\item
It finishes the remaining execute in the same manner as $\mcal{G}_i$.
\end{itemize}
\end{AlgorithmBox}

We first claim that for any noticeable $\epsilon^*(\secpar)$ and any $i \in [\tilde{t}]$, it holds that 
 \begin{align*}
& \Pr[\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}} \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i(1^\secpar, 1^{\epsilon_1^{-1}},  \msf{pref}')] \\ 
~ \cind_{\epsilon^*}& 
\Pr[\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}} \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}^*_i(1^\secpar, 1^{\epsilon_1^{-1}},1^{\epsilon^{*-1}},  \msf{pref}')]. \numberthis \label{eq:ind:Gi:G*i}
\end{align*}
To see \Cref{eq:ind:Gi:G*i}, note that the only difference between $\mcal{G}_i$ and $\mcal{G}^*_i$ is how the shares $\msf{rv}^{(3)}_j$'s are generated (modulo the extractor with $\epsilon^*$-simulation that $\mcal{G}^*_i$ invokes in \Cref{bbnmc:hard-puzzle:com-ch}, which is already taken into account by the symbol $\cind_{\epsilon^*}$). First, we remark that the new $\msf{rv}^{*(1)}_j$'s generated by $\mcal{G}^*_i$ still satisfy the predicate $F^R_{\msf{consis}}$ in \Cref{bbnmc:hard-puzzle:rv-3}. This is because these $\msf{rv}^{*(1)}_j$'s will reconstruct to $(\tilde{x}^*_1, \ldots, \tilde{x}^*_{\tilde{t}})$, where  $\tilde{x}^*_i$ does equal to $\tilde{x}_i$, to which the (unchanged) $\msf{rv}^{(2)}_j$'s will reconstruct. Thus, if we compare the $\Set{\msf{rv}^{(3)}_j}_{j\in \tilde{\eta}}$ shares between $\mcal{G}_i$ and $\mcal{G}^*_i$, they are the views of parties $P_j$ ($j\in \tilde{\eta}$) resulted from different inputs that lead to the same output for $F^R_{\msf{consis}}$. By the $(n,k)$-privacy of the underlying MPC, we know that any $k$ shares (i.e., those in set $\tilde{\eta}$) does not reveal the input of other parties $P_j$ for $j \in [n]\setminus \tilde{\eta}$. Therefore, the view of $\mcal{M}_\secpar$ is computationally indistinguishable between $\mcal{G}_i$ and $\mcal{G}^*_i$ (modulo the error $\epsilon^*$ accounting for the extractor with $\epsilon^*$-simulation invoked by $\mcal{G}^*_1$ in \Cref{bbnmc:hard-puzzle:com-ch}). 

This seems to already establish \Cref{eq:ind:Gi:G*i}. But we remark that there is a caveat: what we have shown so far is about $\mcal{M}_\secpar$ view. But the event in \Cref{eq:ind:Gi:G*i} is about the committed value $\tilde{\alpha}$. To compensate for that, note that the committed $\tilde{\alpha}$ can be efficiently extracted using the extractor $\SimExt$ for the $\ExtCom$ in \Cref{prot:bbnmc:extcom} of the right session, with an arbitrarily small noticeable simulation error $\epsilon$. Thus, the indistinguishability of $\mcal{M}_\secpar$ does translate to the event regarding the committed $\tilde{\alpha}$. This finises the proof of \Cref{eq:ind:Gi:G*i}. 


With \Cref{eq:ind:Gi:G*i} in hand (where note that the $\epsilon^*$ can be made arbitrarily small), to prove \Cref{pq:claim:Gi:vss-hide}, it suffices to prove the following regarding machine $\mcal{G^*}$: for all $i \in [\tilde{t}]$ and all $\epsilon^*$, it holds that 
\begin{equation}\label[Inequality]{eq:convert:Gi:G*i}
\Pr[\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}} \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}^*_i(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon^{*-1}},  \msf{pref}')] \leq \negl(\secpar).
\end{equation}

In the following, we establish \Cref{eq:convert:Gi:G*i} by reducing it to the VSS hiding game shown in \Cref{chall:vss:hide}.

Assume for the sake of contradiction that \Cref{eq:convert:Gi:G*i} does not hold. Namely, there exists an $i \in [\tilde{t}]$ and a inverse polynomial quantity $\nu(\secpar)$ such that for infinitely many $\secpar \in \Naturals$, it holds that
 $$\Pr[\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}} \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}^*_i(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon^{*-1}},  \msf{pref}')] > \nu(\secpar).$$ 
 We show there exists an adversary $\Adv$ that wins the VSS hiding game shown in \Cref{chall:vss:hide}. $\Adv$ works as follows: 
\begin{enumerate}
\item 
$\Adv$ picks two tuples of messages $\Set{\tilde{x}_j}_{j \in [\tilde{t}]}$ and $\Set{\tilde{x}'_j}_{j \in [\tilde{t}]}$ that are distinct in every entry other than $i$ (i.e., $\tilde{x}_j \neq \tilde{x}'_j ~\forall j \in [\tilde{t}] \setminus \Set{i}$), but it holds that $\tilde{x}_i = \tilde{x}'_i$. Externally, it sends $m_0 \coloneqq \Set{\tilde{x}_j}_{j \in [\tilde{t}] }$ and $m_1 \coloneqq \Set{\tilde{x}'_j}_{j \in [\tilde{t}]}$ to the challenger $\msf{Ch}$ for the VSS hiding game, as \Cref{chall:vss:hide:step:1} in \Cref{chall:vss:hide}. 

\item \label[Step]{algo:G*i:A:against:VSS:hiding:step:2}
Internally $\Adv$ starts executing $\mcal{G}^*_i(1^\secpar,1^{\epsilon_1^{-1}}, 1^{\epsilon^{*-1}},\msf{pref'})$. It proceeds with this execution till the end of \Cref{bbnmc:hard-puzzle:com-ch} of the right session. Note that by definition of $\mcal{G}^*_i$ (see \Cref{machine:Gi*}), the set $\tilde{\eta}$ has already been extracted at this moment. $\Adv$ then commit to $\tilde{\eta}$ using $\ExtCom$ to the external challenger $\msf{Ch}$ as \Cref{chall:vss:hide:step:2} in \Cref{chall:vss:hide}.

\item \label[Step]{algo:G*i:A:against:VSS:hiding:step:3}
The challenger next sends commitments as \Cref{chall:vss:hide:step:3} in \Cref{chall:vss:hide}. $\Adv$ forwards these commitments to $\mcal{M}_\secpar$ (at \Cref{bbnmc:hard-puzzle:rv-1} on the right).

\item \label[Step]{algo:G*i:A:against:VSS:hiding:step:4}
$\Adv$ then sends the $\tilde{\eta}$ together with the decommitment information w.r.t.\ its $\ExtCom$ made in \Cref{algo:G*i:A:against:VSS:hiding:step:2}, as the \Cref{chall:vss:hide:step:4} message in \Cref{chall:vss:hide}.

\item \label[Step]{algo:G*i:A:against:VSS:hiding:step:5}
Then, $\msf{Ch}$ will send the shares $\Set{\msf{v}_j}_{j \in \tilde{\eta}}$ to $\Adv$, as the \Cref{chall:vss:hide:step:5} message in \Cref{chall:vss:hide}. $\Adv$ records this values.

\item \label[Step]{algo:G*i:A:against:VSS:hiding:step:6}
Internally, $\Adv$ continues the execute as $\mcal{G}^*_i$, until the beginning of \Cref{bbnmc:hard-puzzle:rv-3}. It executes \Cref{bbnmc:hard-puzzle:rv-3} in the following manner (which is also identical to $\mcal{G}^*_i$ by renaming some variables as explained below):
\begin{itemize}

 \item
 It first prepares the shares $\Set{\msf{rv}^{*(1)}_j}_{j\in [n]}$ that constitute a VSS of $(\tilde{x}^*_1, \ldots, \tilde{x}^*_{\tilde{t}})$ where  $\tilde{x}^*_i = \tilde{x}_i $ but $\tilde{x}^*_j = 0^\secpar$ for all $j \ne i$, and these shares satisfy the requirement that $\msf{rv}^{*(1)}_j = \msf{v}_j$ for $j\in \tilde{\eta}$, as we explain in the description of $\mcal{G}^*_i$ with $\Set{\msf{v}_j}_{j\in \tilde{\eta}}$ playing the role of $\Set{\msf{rv}^{(1)}_j}_{j\in \tilde{\eta}}$ in the description in \Cref{machine:Gi*}.

\item \label[Step]{algo:G*i:A:against:VSS:hiding:step:8} 
$\mcal{G}^*_i$ then prepares $\Set{\tilde{\msf{rv}}^{(3)}_j}_{j\in [n]}$ by running the $(n,k)$-MitH execution with party $P_j$ ($\forall j \in [n]$) using $\tilde{\msf{rv}}^{*(1)}_j\|\tilde{\msf{rv}}^{(2)}_j$ as its input.
\end{itemize} 
It is worth noting that in this step, $\Adv$ does not make use of the shares $\Set{\msf{v}_j}_{j\in [n]\setminus \tilde{\eta}}$ (which are anyway only know to the external $\msf{Ch}$ but not to $\Adv$). $\Adv$ only uses the shares $\Set{\msf{v}_j}_{j\in  \tilde{\eta}}$ that is revealed by $\msf{Ch}$ in \Cref{algo:G*i:A:against:VSS:hiding:step:5}.


\item \label[Step]{algo:G*i:A:against:VSS:hiding:step:9}
$\Adv$ then internally finish the remaining execution in the same manner as $\mcal{G}^*_i$, with only one difference---In \Cref{prot:bbnmc:extcom} of the right session, $\Adv$ invokes the extractor $\SimExt_\ExtCom$ with error parameter $\epsilon_{\Adv}$ to get an extracted value $\tilde{v}$. It parses $\tilde{v}$ as $j||a$. If $a = \tilde{x}_j$, $\Adv$ halts and output $b' = 0$; If $a = \tilde{x}'_j$, $\Adv$ halts and output $b'=1$; If neither of the cases happen, $\Adv$ halts and output a random bit $b'$
\end{enumerate}
By the above description, it is not hard to see that up to \Cref{algo:G*i:A:against:VSS:hiding:step:8}, the internal execution of $\Adv$ perfectly emulates the view of $\mcal{M}_\secpar$ in game $\mcal{G}^*_i$. If $\mcal{M}_\secpar$ indeed commits to an $\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}}$ (and $\tilde{d} = \top$) with probability $\nu(\secpar)$, $\Adv$ in \Cref{algo:G*i:A:against:VSS:hiding:step:9} will extract a $\tilde{v} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}}$ (or $\tilde{v} \in \Set{\tilde{x}'_j}_{j \in [\tilde{t}] \setminus \Set{i}}$, depending on the $\msf{Ch}$ uses $m_0$ or $m_1$) with probability at least $\nu(\secpar) - \epsilon_\Adv(\secpar)$. Therefore, the advantage of $\Adv$ in the VSS hiding game is at least:
$$\big(\nu(\secpar) - \epsilon_\Adv(\secpar)\big) \cdot 1 + \big(1 - (\nu(\secpar) - \epsilon_\Adv(\secpar)) \big)\cdot \frac{1}{2} = \frac{1}{2} + \frac{\nu(\secpar) - \epsilon_\Adv(\secpar)}{2}.$$
Note that we can set $\epsilon_\Adv(\secpar)$ to be an arbitrarily small noticeable function. By setting $\epsilon_\Adv(\secpar) \coloneqq \frac{\nu(\secpar)}{2}$, the above lower bound becomes $\frac{1}{2} + \frac{\nu(\secpar)}{4}$. Since $\frac{\nu(\secpar)}{4}$ is still a noticeable function, this contradicts \Cref{lem:game:VSS:hiding}, breaking the VSS hiding game.




% We consider $\secpar$ such that $\nu(\secpar)$ is inverse polynomial. We then set $\epsilon$ to be $\nu(\secpar)/2$ which ensures $\epsilon$ is still inverse polynomial and so $\Adv$ runs in polynomial time (for these values of $\secpar$). The key observation here is that whenever we have that $\tilde{\alpha} \in \Set{\tilde{x}_j}_{j \in [\tilde{t}] \setminus \Set{i}}$ and $\tilde{d} = \top$, $\Adv$ wins the VSS hiding game directly. It is easy to then see that overall, $\Adv$ wins the VSS hiding game with advantage at least $\nu(\secpar)/4$ by our starting assumption. 

% This implies that for infinitely many values of $\secpar$, we have an efficient adversary $\Adv$ that wins \Cref{chall:vss:hide} with inverse polynomial probability. This contradicts \Cref{lem:game:VSS:hiding}. 

This concludes the proof of \Cref{pq:claim:Gi:vss-hide}.

\end{proof}

\para{Finishing the Proof of \Cref{pq:claim:G1dprime:lowerbound}.} With the above preparatory \Cref{pq:claim:bound:Gi,pq:claim:Gi:lb:comval,pq:claim:Gi:vss-hide}, we now proceed to finish the proof of \Cref{pq:claim:G1dprime:lowerbound}.

\subpara{From $\mcal{G}_i$ to $\mcal{G}'_i$.} We start by comparing machine $\mcal{G}_i$ and $\mcal{G}'_i$ (see \Cref{algo:G'i:G''i}). Note that $\mcal{G}_i'$ differs from $\mcal{G}_i$ in that it performs brute-force computation to extract the puzzle solutions from \Cref{bbnmc:hard-puzzle:rv-1} of the left session (see \Cref{algo:G'i:G''i:step:2} of \Cref{algo:G'i:G''i}), while $\mcal{G}_i$ extract a puzzle solution $(j\|x_j)$ using the extractability from $\ExtCom$. Note that the $(j\|x_j)$ extracted by $\mcal{G}_i$ must be among the $t$ real solutions (which are all extracted by $\mcal{G}'_i$ using brute force). Also, recall form \Cref{algo:G'i:G''i} that $\mcal{G}'_i$ picks a random $(s\|x_s)$ to finish the reminder execution as in $\mcal{G}_i$. Thus, in the case where $j=s$ (i.e., $\mcal{G}'_i$ happens to guess the same $(j\|x_j)$ as extracted by $\mcal{G}_i$), then the games $\mcal{G}_i$ and $\mcal{G}_i'$ are {\em identical}. Moreover, since $\mcal{G}'_i$ guesses $s$ uniformly at random from $[t]$, the event $j = s$ happens with probability at least $1/t$. Therefore, the following holds:
\begin{align*}
\forall i \in [\tilde{t}],~ & \Pr[\big(\tilde{\alpha} = \tilde{x}_i \big) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}'_i{(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref'})}] \\ 
 \geq & ~
\frac{\Pr[\big( \tilde{\alpha} = \tilde{x}_i \big) \wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref'})}]}{t}. \numberthis \label[Inequality]{proof:lower-bound:final:eq:1}
\end{align*}
On the other hand, notice that \Cref{pq:claim:Gi:lb:comval} and \Cref{pq:claim:Gi:vss-hide}, we conclude that
\begin{equation}\label[Inequality]{pq:eq:Gi:comval:xi}
    \forall i \in [\tilde{t}],~\Pr[\big(\tilde{\alpha} = \tilde{x}_i\big) \wedge \big(\tilde{d} = \top\big): (\OUT,\tilde{d}) \gets \mcal{G}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref'})}] \geq p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) - \epsilon'(\secpar)- \negl(\secpar).
\end{equation}
\Cref{proof:lower-bound:final:eq:1,pq:eq:Gi:comval:xi} together imply the following: 
\begin{equation}\label[Inequality]{pq:eq:Giprime:lb}
\forall i \in [\tilde{t}],~\Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i'(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref'})] \geq  \frac{p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) - \epsilon'(\secpar)}{t} -\negl(\secpar).
\end{equation}


\subpara{From $\mcal{G}'_i$ to $\mcal{G}''_i$.} Next, note that the machines $\mcal{G}_i'$ and $\mcal{G}_i''$ only differ in that $\mcal{G}_i''$ no longer invokes $\SimExt_\ExtCom(1^\secpar, 1^{\epsilon_1^{-1}})$ to extract from \Cref{bbnmc:hard-puzzle:rv-2} on the left (see \Cref{algo:G'i:G''i}). As a consequence, it holds that 
\begin{equation}\label[Inequality]{pq:eq:Gidprime:lowerbound}
\forall i \in [\tilde{t}],~\Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i''(1^\secpar, \msf{pref'})] \geq \frac{p^{\msf{Sim}}_{\msf{pref'}}[\epsilon_1] - 2\epsilon_1(\secpar) - \epsilon'(\secpar)}{t} -\epsilon_1 -\negl(\secpar).
\end{equation}

\subpara{From $\mcal{G}''_i$ to $\mcal{G}''_1$.} We first note that to finish our current proof of \Cref{pq:claim:G1dprime:lowerbound}, it suffices to show the following inequality
 \begin{align*}
        \forall i \in [\tilde{t}],~ & \bigg|  \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i''(1^\secpar, \msf{pref'})] \\
         & \hspace{3em}- \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_1''(1^\secpar,\msf{pref'})] \bigg| 
         \leq \negl(\secpar), \numberthis \label[Inequality]{pq:eq:Gidprime:compare}
\end{align*} 
because \Cref{pq:eq:Gidprime:lowerbound,pq:eq:Gidprime:compare} together imply \Cref{pq:claim:G1dprime:lowerbound} immediately. Thus, the only thing left is to prove \Cref{pq:eq:Gidprime:compare}.

\begin{proof}[Proof of \Cref{pq:eq:Gidprime:compare}]
    
    For the sake of contradiction, assume that there exist an $i \in [\tilde{t}]$ and an inverse polynomial $\kappa(\secpar)$ such that for infinitely many $\secpar\in \Naturals$, it holds that 
    \begin{align*}
        & \bigg|  \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i''(1^\secpar,\msf{pref'})] \\
         &\hspace{3em} - \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_1''(1^\secpar,\msf{pref'})] \bigg| 
         > \kappa(\secpar) \numberthis \label[Inequality]{pq:eq:Gidprime:contra}
    \end{align*} 

    We next introduce a new machine $\mcal{\hat{G}}_i$ for this proof. 
\begin{AlgorithmBox}[label={algo:G:hat}]{Machine \textnormal{$\mcal{\hat{G}}_i(1^\secpar, 1^{\hat{\epsilon}^{-1}},\msf{pref'})$}}

    \para{Machine $\mcal{\hat{G}}_i(1^\secpar, 1^{\hat{\epsilon}^{-1}},\msf{pref'})$:} For each $i \in [\tilde{t}]$, this machine works similar to $\mcal{G}_i''(1^\secpar, \msf{pref'})$ (see \Cref{algo:G'i:G''i}), except that
    \begin{itemize}
    \item
    In \Cref{prot:bbnmc:extcom} of the right session, instead of using the honest receiver's algorithm,  $\mcal{\hat{G}}_i$ invokes $\SimExt_\ExtCom(1^\secpar, 1^{\hat{\epsilon}^{-1}})$ to extract a value $\tilde{v}$, which is supposed to be the value committed by $\mcal{M}_\secpar$ in the right \Cref{prot:bbnmc:extcom}.

    In more detail, the shares $\Set{\tilde{\msf{cv}}^{(2)}_i}_{i \in [n]}$ are committed by $\mcal{M}_\secpar$ using independent $\ExtCom$ in parallel in the right \Cref{prot:bbnmc:extcom}. $\mcal{G}_1$ will extract all of these shares using the parallel extractability of $\ExtCom$ with error parameter $\hat{\epsilon}$ (as per \Cref{def:epsilon-sim-ext-com:parallel}), and compute $\tilde{v} \coloneqq \VSS_{\Recon}(\tilde{\msf{cv}}^{(2)}_1, \ldots, \tilde{\msf{cv}}^{(2)}_n)$.

    \end{itemize} 
\end{AlgorithmBox}
  
    We start by comparing the value $\tilde{\alpha}$ committed to in \Cref{prot:bbnmc:extcom} on the right in $\mcal{G}_i''$ and the value $\tilde{v}$ extracted by $\SimExt_\ExtCom$ in \Cref{prot:bbnmc:extcom} on the right within $\mcal{\hat{G}}_i$. Similar to before, we can base this comparison on the simulation-extraction guarantee of $\SimExt_\ExtCom(1^\secpar, 1^{\hat{\epsilon}^{-1}})$, which implies that for any noticeable $\hat{\epsilon}$, it holds that
    \begin{align*}
        \forall i,j \in [\tilde{t}],~ & \bigg| \Pr[\big( \tilde{\alpha} = \tilde{x}_j \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i''(1^\secpar, \msf{pref'})] \\
         & \hspace{3em} - 
         \Pr[\big( \tilde{v} = \tilde{x}_j \big)\wedge (\tilde{d} = \top): (\OUT, \tilde{d}) \gets \mcal{\hat{G}}_i(1^\secpar, 1^{\hat{\epsilon}^{-1}}, \msf{pref'})] \bigg| 
         \leq \hat{\epsilon}(\secpar). \numberthis \label[Inequality]{pq:eq:Kidprime:compare}
    \end{align*} 

Next, using a similar (non-uniform) argument as for \Cref{pq:eq:G1:Gi:dprime:ub:success} over the commit-and-prove protocol consisting of the hard puzzle setup step (i.e., \Cref{bbnmc:hard-puzzle:puzzle-setup}) of the right session, we can establish the following: for any noticeable $\hat{\epsilon}(\secpar)$, it holds that
    \begin{align*}
        \forall i,j \in [\tilde{t}],~& \bigg| \Pr[\big( \tilde{v} = \tilde{x}_j \big)\wedge (\tilde{d} = \top): (\OUT, \tilde{d}) \gets \mcal{\hat{G}}_i(1^\secpar, 1^{\hat{\epsilon}^{-1}}, \msf{pref'})] \\
         &\hspace{3em} - \Pr[\big( \tilde{v} = \tilde{x}_j \big)\wedge (\tilde{d} = \top): (\OUT, \tilde{d}) \gets \mcal{\hat{G}}_1(1^\secpar, 1^{\hat{\epsilon}^{-1}}, \msf{pref'})] \bigg| 
         \leq \negl(\secpar). \numberthis \label[Inequality]{pq:eq:K1dprime:compare}
    \end{align*} 
It then follows from \Cref{pq:eq:K1dprime:compare} and \Cref{pq:eq:Kidprime:compare} that for any noticeable $\hat{\epsilon}(\secpar)$, it holds that
    \begin{align*}
        \forall i,j \in [\tilde{t}],~& \bigg| \Pr[\big( \tilde{\alpha} = \tilde{x}_j \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i''(1^\secpar, \msf{pref'})] \\
         &\hspace{3em} - \Pr[\big( \tilde{v} = \tilde{x}_j \big)\wedge (\tilde{d} = \top): (\OUT, \tilde{d}) \gets \mcal{\hat{G}}_1(1^\secpar, 1^{\hat{\epsilon}^{-1}}, \msf{pref'})] \bigg| 
         \leq \hat{\epsilon}(\secpar) +  \negl(\secpar). \numberthis \label[Inequality]{pq:eq:K1dprime:compare:2}
    \end{align*} 
Setting $j = i$ in \Cref{pq:eq:K1dprime:compare:2} implies that for any noticeable $\hat{\epsilon}(\secpar)$, it holds that
    \begin{align*}
        \forall i \in [\tilde{t}],~& \bigg| \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i''(1^\secpar, \msf{pref'})] \\
         &\hspace{3em} - \Pr[\big( \tilde{v} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT, \tilde{d}) \gets \mcal{\hat{G}}_1(1^\secpar, 1^{\hat{\epsilon}^{-1}}, \msf{pref'})] \bigg| 
         \leq \hat{\epsilon}(\secpar) +  \negl(\secpar). \numberthis \label[Inequality]{pq:eq:K1dprime:compare:3}
    \end{align*} 
Setting $i = 1$ (and then renaming $j$ to $i$) in \Cref{pq:eq:K1dprime:compare:2} implies that for any noticeable $\hat{\epsilon}(\secpar)$, it holds that
    \begin{align*}
        \forall i \in [\tilde{t}],~& \bigg| \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_1''(1^\secpar, \msf{pref'})] \\
         &\hspace{3em} - \Pr[\big( \tilde{v} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT, \tilde{d}) \gets \mcal{\hat{G}}_1(1^\secpar, 1^{\hat{\epsilon}^{-1}}, \msf{pref'})] \bigg| 
         \leq \hat{\epsilon}(\secpar) +  \negl(\secpar). \numberthis \label[Inequality]{pq:eq:K1dprime:compare:4}
    \end{align*} 
Combining \Cref{pq:eq:K1dprime:compare:3,pq:eq:K1dprime:compare:4} implies that for any noticeable $\hat{\epsilon}(\secpar)$, it holds that
    \begin{align*}
        \forall i \in [\tilde{t}],~& \bigg| \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_i''(1^\secpar, \msf{pref'})] \\
         &\hspace{3em} - \Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_1''(1^\secpar, \msf{pref'})] \bigg| 
         \leq 2\cdot\hat{\epsilon}(\secpar) +  \negl(\secpar). \numberthis \label[Inequality]{pq:eq:K1dprime:compare:5}
    \end{align*}
By setting $\hat{\epsilon}(\secpar) \coloneqq \frac{\kappa(\secpar)}{4}$ in \Cref{pq:eq:K1dprime:compare:5}, we obtain a contradiction to \Cref{pq:eq:Gidprime:contra}.

This concludes the proof of \Cref{pq:eq:Gidprime:compare}.

\end{proof}

%End fix



%We have already argued the indistinguishability of outputs in $\mcal{G}_i''$ and $\mcal{G}_1''$ in the proof of \Cref{pq:claim:bound:Gi}. By using the very same arguments (namely, hiding of $\ExtCom$ in \Cref{bbnmc:hard-puzzle:rv-2}, hiding of $\Com$ in \Cref{bbnmc:hard-puzzle:rv-3}, and the perfect secrecy of the $\VSS$ scheme  on the right in \Cref{bbnmc:hard-puzzle:open}), we can also claim 
%\begin{equation}\label[Inequality]{pq:eq:G1dprime:lowerbound}
%\forall i \in [\tilde{t}],~\Pr[\big( \tilde{\alpha} = \tilde{x}_i \big)\wedge (\tilde{d} = \top): (\OUT,\tilde{d}) \gets \mcal{G}_1''(\msf{pref'})] \geq \frac{p^{\msf{Sim}}_{\msf{pref'}} - 3\epsilon_1 - \epsilon'}{t} -\epsilon_1 -\negl(\secpar)
%\end{equation}

This eventually concludes our proof for \Cref{pq:claim:G1dprime:lowerbound}. 
    . 




