%!TEX root = ../main.tex

\section{Post-Quantum Trapdoor Coin-Tossing with $\epsilon$-Simulation}
\label{sec:td-cf}

In this section, we build a {\em trapdoor coin-flipping} protocol. This is a coin-flipping protocol between two parties $C$ and $R$ where $C$ additionally commits to some string $x$ before the coin-flipping starts. The security guarantee of the actual coin-flipping stage is `controlled' by the committed string $x$ and a predicate $\phi(\cdot)$ that is given to both party at the beginning of the coin-flipping stage. In particular, if the committed $x$ does not satisfy the predicate $\phi(\cdot)$, then even a cheating $C^*$ cannot gain any advantage over $R$ in the coin-flipping stage. This is formalized as the standard simulation-based requirement, namely, we require the existence of a simulator that can `enforce' the coin-tossing result to a given random string if $C^*$ does not abort the execution.

On the other hand, if the committed $x$ satisfies the predicate, then $C$ can enforce the coin-tossing result to a given random string against any efficient $R^*$ that does not abort the execution (this is what we call `trapdoor'). We require that this `enforcing procedure' should happen in straight-line, i.e., it is not allowed to rewind $R^*$. Indeed, we actually require a stronger version of this property as follows.

We consider a real-world execution where $C$ commits honestly to a string $x$ to the malicious $R^*$; Here, we do not require that $x$ satisfies $\phi$. Then, in the simulation world, we provide a potentially different $x'$ to a `straight-line' simulator $\Sim$ such that $\phi(x')=1$. With this valid witness $x'$, $\Sim$ can enforce the coin-flipping result to a pre-sampled random string, interacting in straight-line with a potentially malicious $R^*$.

In the following, we first present the definition in \Cref{sec:com-n-prove:def} and then show our construction with security proof in \Cref{sec:com-n-prove:constr}. We remark that this construction is a simple application of the MPC-in-the-Head technique. Indeed, the main contribution of this work does not lie in this construction. We abstract out the notion of `trapdoor coin-flipping' simply because it helps us present our post-quantum non-malleable commitments (in \Cref{sec:PQNMC:1-1}) in a modular manner.  

\subsection{Definition}
\label{sec:com-n-prove:def}

\begin{definition}
\label{def:com-n-prove}
A post-quantum trapdoor coin-tossing with $\epsilon$-simulation protocol consists of a pair of \PPT ITM $\langle C, R \rangle$. Let $x\in \bits^{\ell(\secpar)}$ (where $\ell(\cdot)$ is some polynomial) is a message that $C$ wants to commit to. The protocol consists of the following stages (we omit the input $1^\secpar$ to $C$ and $R$): 
\begin{itemize}
\item 
{\bf Commit Stage:} 
$C(x)$ and $R$ interacts to generates a transcript (commitment) $\com$, 
$C$'s state $\ST_C$, and $R$'s decision bit $b\in \Set{\top, \bot}$ indicating acceptance (i.e., $b=\top$) or rejection (i.e., $b=\bot$). We denote this execution as $(\com, \ST_C, b) \gets \langle C(x), R \rangle_\textsc{com}$. 
Note that a malicious receiver is allowed to output any quantum state, which we denote by $\ST_{R^*}$ instead of $b$, and to keep the state for the following stages. 


\item 
{\bf Decommit Stage:}\footnote{This stage is rarely executed in applications.} $C(\ST_C)$ generates a decommitment $\decom$ and sends it to $R$ along with a message $x$. $R$ accepts or rejects. 

\item 
{\bf Coin-Flipping Stage:} 
Let $\phi(\cdot)$ be any predicate. $C(\ST_C, \phi)$ and $R(\com,\phi)$ interacts, after which $R$ outputs $\top$ (accept) or $\bot$ (reject). We denote the execution of this stage as $(\eta_1, \eta_2) \gets \langle C(\ST_C), R(\com) \rangle^\phi_\textsc{cf}$, where $\eta_1, \eta_2 \in \bits^*$ are the respective output of $C$ and $R$. Note that a malicious receiver is allowed to output any quantum state, which we denote by $\OUT_{R^*}$ instead of $\eta_2$. 

\end{itemize}
The following requirements are satisfied:
\begin{enumerate}
	\item \label[Property]{def:com-n-prove:property:1}
{\bf Statistically Binding.} The Commit Stage and Decommit Stage together constitute a post-quantum commitment scheme that is statistically binding and (post-quantum) computational hiding.

\item \label[Property]{def:com-n-prove:property:2}
{\bf Completeness.} For any $x \in \bits^{\ell(\secpar)}$ and any predicate $\phi$, it holds that
\begin{equation}
\Pr[\eta_1 = \eta_2 ~:~ 
\begin{array}{l}
(\com,\ST_C,b) \gets \langle C(x),R \rangle_\textsc{com} \\
(\eta_1, \eta_2) \gets \langle C(\ST_C), R(\com) \rangle^\phi_\textsc{cf}
\end{array}
] = 1.
\end{equation}


\item \label[Property]{def:com-n-prove:property:3}
{\bf Security against Malicious $R^*$.} For any QPT $R^*$, there exists a `straight-line' QPT simulator $\Sim$ such that for any efficiently computable predicate $\phi(\cdot)$, any $x, x'\in \bits^{\ell(\secpar)}$ such that $\phi(x') = 1$, it holds that
\begingroup
 \fontsize{8pt}{10pt}\selectfont
$$
\bigg\{
(\eta_1, \OUT_{R^*})
~:~
\begin{array}{l}
(\com,\ST_C, \ST_{R^*}) \gets \langle C(x),R^* \rangle_\textsc{com} \\
(\eta_1, \OUT_{R^*}) \gets \langle C(\ST_C), R^*(\ST_{R^*}) \rangle^\phi_\textsc{cf}
\end{array}
\bigg\}_\secpar 
\cind
\bigg\{
\big(\Gamma_{d}(\eta), \OUT_{R^*}\big)
~:~
\begin{array}{l}
(\ST_S, \ST_{R^*}) \gets \langle \Sim(x') ,R^* \rangle_\textsc{com} \\
\eta \picks \bits^{k(\secpar)}\\
(d, \OUT_{R^*}) \gets \langle \Sim(\ST_S,\eta), R^*(\ST_{R^*}) \rangle^\phi_\textsc{cf}
\end{array}
\bigg\}_\secpar, 
$$
\endgroup
where $\Gamma_d(\eta) \coloneqq \begin{cases}
\eta & \text{if}~d = \top\\
\bot & \text{if}~d = \bot
\end{cases}$.

\item \label[Property]{def:com-n-prove:property:4}
{\bf Security against Malicious $C^*$.} For any QPT $C^*$ with $\ST_{C^*}$  there exists a QPT simulator $\Sim$ such that for any noticeable $\epsilon(\secpar)$,  any predicate $\phi(\cdot)$ and and any $\com^*$such that $\phi\big(\msf{val}(\com^*)\big) = 0$,\footnote{Recall from \Cref{def:com-val} that $\msf{val}(\com^*)$ is the value statistically bound in transcript $\com^*$.} it holds that
\begingroup
 \fontsize{9pt}{10pt}\selectfont
$$
\bigg\{
(\OUT_{C^*}, \eta_2)
~:~
(\OUT_{C^*}, \eta_2) \gets \langle C^*(\ST_{C^*}), R(\com^*) \rangle^\phi_\textsc{cf}
\bigg\}_\secpar 
\cind_\epsilon
\bigg\{
\big(\OUT_{C^*}, \Gamma_{d}(\eta) \big)
~:~
\begin{array}{l}
\eta \picks \bits^{k(\secpar)}\\
(\OUT_{C^*}, d) \gets  \Sim(1^\secpar, \eta, \phi, \com^*)
\end{array}
\bigg\}_\secpar, 
$$
\endgroup
where $\Gamma_d(\eta)$ is defined as above.

\end{enumerate}
\end{definition}
Some remarks regarding \Cref{def:com-n-prove} follows:
\begin{itemize}
\item
Note that the above completeness condition (\Cref{def:com-n-prove:property:2}) holds regardless of whether $x$ satisfies the predicate $\phi(\cdot)$ or not.

\item
When defining \Cref{def:com-n-prove:property:3,def:com-n-prove:property:4}, we essentially follow the standard simulation-based notion for two-party coin-flipping {\em with aborting}. That is, we require the simulator to successfully `enforce' the coin-flipping result to the pre-sampled $\eta$ only if the malicious party does not abort the protocol. Indeed, if the malicious party aborts before the protocol ends, the honest party cannot receive any output, and thus of course we cannot enforce its output to $\eta$ while being consistent with the real-world execution (where the honest party simply outputs $\bot$).  
\end{itemize}

\subsection{Construction}
\label{sec:com-n-prove:constr}

We present the construction in \Cref{prot:td:ct}. It makes use of (the post-quantum version of) Naor's commitment and the post-quantum extractable commitment $\ExtCom$ with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:strong}). Note that both of these building blocks are known in black-box and constant-round from post-quantum OWFs.


\begin{ProtocolBox}[label={prot:td:ct}]{Post-Quantum Trapdoor Coin-Flipping with $\epsilon$-Simulation}

\para{Input:}
Both the  $C$ and $R$ get the security parameter $1^\secpar$ as the common input. $C$ gets a string $x \in \bits^{\ell(\secpar)}$ as its private input.

\para{Commit Stage:}
\begin{enumerate}
\item \label[Step]{prot:td:ct:step:1}
$C$ prepares $n$ views $\Set{\msf{v}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $x$ (as detailed in \Cref{rmk:mpc-in-the-head-vss}). $C$ commits to each $\msf{v}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\end{enumerate}

\para{Decommit Stage:}
\begin{enumerate}
\item
$C$ sends $\Set{\msf{v}_i}_{i\in [n]}$ together with the decommitment information w.r.t.\ the commitments in \Cref{prot:td:ct:step:1}. 
\item
$R$ checks the validity of the decommitment information and the consistency among $\Set{\msf{v}_i}_{i\in [n]}$ (as per \Cref{rmk:VSS:view-consistency}). If these checks are successful, $R$ recovers $x$ as $x \coloneqq \VSS_\Recon(\msf{v}_1, \ldots, \msf{v}_n)$; otherwise, $R$ rejects and output $\bot$. 
\end{enumerate}

\para{Coin-Flipping Stage:} At the beginning of this stage, both parties learn  the description of a predicate $\phi(\cdot)$. They proceed as follows.
\begin{enumerate}
\item \label[Step]{prot:td:ct:step:2}

$C$ picks $\eta_C \picks \bits^{k(\secpar)}$ and commits to it with MitH. Namely, $C$ prepares $n$ views $\Set{\msf{cfv}^{(1)}_i}_{i \in [n]}$ corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the value $\eta_C$. $C$ commits to each $\msf{cfv}^{(1)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$. 

\item \label[Step]{prot:td:ct:step:3}
$R$ picks $\eta_R \picks \bits^{k(\secpar)}$ and sends it to $C$.

\item \label[Step]{prot:td:ct:step:4}
$C$ now sets $\eta'_C \coloneqq \eta_C$ and sends $\eta'_C$ to $R$.

\item \label[Step]{prot:td:ct:step:5}
$C$ prepares $n$ views $\Set{\msf{cfv}^{(2)}_i}_{i \in [n]}$, corresponding to an $(n,k)$-MitH execution of the $n$-party functionality $F_\phi$ described below, where party $P_i$ ($i\in [n]$) uses $\msf{v}_i \| \msf{cfv}^{(1)}_i$ as input. (Note that $\msf{v}_i \| \msf{cfv}^{(1)}_i$ will be the prefix of $\msf{cfv}^{(2)}_i$.)  $C$ commits to each $\msf{cfv}^{(2)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment. Here, the honest committer will use as an `effective witness' the value $\eta_C$ reconstructed from $\Set{\msf{cfv}^{(2)}_i}_{i \in [n]}$, and hence only evaluates the `first clause' of $F_\phi$ (described below) in the virtual MPC execution. 
\begin{itemize}
\item {\bf Functionality  $F_\phi$:} It has $\eta'_C$ hare-wired. It collects input (and parses it as) $\msf{v}_i \| \msf{cfv}^{(1)}_i$ from party $i$ for each $i \in [n]$. It then runs the recovery algorithm of $\VSS$ to obtain $a \coloneqq \VSS_\Recon(\msf{v}_1, \ldots, \msf{v}_n)$ and $b \coloneqq \VSS_\Recon(\msf{cfv}^{(1)}_1, \ldots, \msf{cfv}^{(1)}_n)$. It outputs 1 to each party if {\em either}
\begin{itemize}
    \item
    (First clause.) $b$ equals $\eta'_C$ sent in \Cref{prot:td:ct:step:4}, {\em or}
    \item
    (Second clause.) $\phi(a) = 1$.
\end{itemize} 
Otherwise, it outputs 0 to each party.
\end{itemize}

\item \label[Step]{prot:td:ct:step:6}
$C$ and $R$ now engage in the following coin-flipping subprotocol as detailed below.  
\begin{enumerate}
\item \label[Step]{prot:td:ct:step:6:1}
$R$ samples a random string $\theta_R$ of proper length and commits to it using $\ExtCom$.   
\item
$C$ samples a random string $\theta_C$ of proper length and sends it to $R$.  
\item
$R$ sends to $C$ the value $\theta_R$ together with the corresponding decommitment information w.r.t.\
the $\ExtCom$ in \Cref{prot:td:ct:step:6:1}. Now, $C$ and $R$ agree on a random string $\theta \coloneqq \theta_R \xor \theta_C$. By a proper choice of length, the string $\theta$ it can be interpreted as specifying a size-$k$ random subset of $[n]$. In the following, we abuse notation by using $\theta$ to denote the corresponding size-$k$ random subset.
\end{enumerate}

\item \label[Step]{prot:td:ct:step:7}
$C$ sends back the list $\Set{(\msf{v}_i,\msf{cfv}^{(1)}_i,\msf{cfv}^{(2)}_i)}_{i \in \theta}$ 
together with the corresponding decommitment information w.r.t.\ the commitment made in \Cref{prot:td:ct:step:1,prot:td:ct:step:2,prot:td:ct:step:5}.

\item
$R$ now checks the validity of the decommitments provided by $C$ and the consistency among the revealed views $\Set{(\msf{v}_i, \msf{cfv}^{(1)}_i, \msf{cfv}^{(2)}_i}_{i \in \theta}$. It also checks for each $i\in \theta$ the final output of $P_i$ contained in $\msf{cfv}^{(2)}_i$ is 1. If any of these checks fail, $R$ aborts immediately.
\end{enumerate}

\para{Output:} $C$ and $R$ output $\eta \coloneqq \eta'_C \xor \eta_R$.
\end{ProtocolBox}

\para{Security.} The security of \Cref{prot:td:ct} is stated as the following lemma.
\begin{lemma}\label{lem:td-cf}
\Cref{prot:td:ct} is a black-box, constant-round trapdoor coin-flipping protocol (as per \Cref{def:com-n-prove}).
\end{lemma}
\begin{proof}


It is straightforward to see that \Cref{prot:td:ct} is constant-round and makes only black-box use of its underlying cryptographic components. Also, the completeness (i.e., \Cref{def:com-n-prove:property:2}) and statistically binding property (i.e., \Cref{def:com-n-prove:property:1}) of \Cref{prot:td:ct} is straightforward from the protocol description. Thus, to prove \Cref{lem:td-cf}, we only need to show that \Cref{prot:td:ct} satisfies \Cref{def:com-n-prove:property:3,def:com-n-prove:property:4} in \Cref{def:com-n-prove}.

As we mentioned earlier, \Cref{prot:td:ct} is a simple application of the MPC-in-the-Head technique. Indeed, similar constructions have appeared previously in, e.g., \cite{FOCS:GLOV12,C:CCLY22}. Our proof for \Cref{def:com-n-prove:property:3,def:com-n-prove:property:4} follows almost immediately from these known techniques. In the following, we only provide a proof sketch and refer the interested readers to \cite[Section 6.5]{C:CCLY22} for similar proofs.

\para{Proving \Cref{def:com-n-prove:property:3}.} Note that \Cref{prot:td:ct} can be viewed as a black-box commit-and-prove protocol where $C$ commits to two values, one being the $x$ committed in \Cref{prot:td:ct:step:1} of the {\bf Commit Stage} and the other being $\eta_C$ committed in \Cref{prot:td:ct:step:2} of the {\bf Coin-Flipping Stage}; $C$ then proves that these two values satisfies the predicate $F_\phi$ defined in \Cref{prot:td:ct:step:5}. Note that such a black-box commit-and-prove protocol is {\em witness indistinguishable} (see \cite[Section 6.5]{C:CCLY22} for a proof of this fact\footnote{Indeed, \cite[Section 6.5]{C:CCLY22} proves a stronger claim that such a protocol is $\epsilon$-zero-knowledge, which implies witness indistinguishability.}), namely, even if $C$ changes the committed values to another $x'$ and $\eta''_C$, {\em as long as $x'$ and $\eta''_C$ together satisfy the predicate $F_\phi$}, then no (potentially malicious) $R^*$ could tell the difference.

With this observation, a simulator $\Sim$ can be constructed as follows. $\Sim$ commits to $x'$ in \Cref{prot:td:ct:step:1} of the {\bf Commit Stage} and emulates the honest $C$, where recall from the condition of \Cref{def:com-n-prove:property:3} that $x'$ is a valid witness for $\phi$ and is given to $\Sim$ as input. In \Cref{prot:td:ct:step:4}, instead of setting $\eta'_C$ to $\eta_C$ honestly, $\Sim$ sets $\eta'_C = \eta \xor \eta_R$, where recall that $\eta$ is the input to $\Sim$ that it wants to enforce. Now, since $\eta'_C \ne \eta_C$, the `first clause' of $F_\phi$ does not hold. Fortunately, since $\phi(x') = 1$, the `second clause' of $F_\phi$ still holds. Thus, the new $x'$ together with $\eta_C$ constitute a valid witness for $F_\phi$. Then, the witness indistinguishability of this commit-and-prove protocol implies \Cref{def:com-n-prove:property:3}. 

\para{Proving \Cref{def:com-n-prove:property:4}.} This proof is even simpler. $\Sim$ works by extracting the $\eta^*_C$ committed by $C^*$ in \Cref{prot:td:ct:step:2} of the {\bf Coin-Flipping Stage}, using the (parallel) extractability of $\ExtCom$ with $\epsilon$-simulation. In more details, recall that the shares $\Set{\msf{cfv}^{(1)}_i}_{i \in [n]}$  is committed in parallel using $\ExtCom$ in \Cref{prot:td:ct:step:2}. $\Sim$ will extract all of these shares using the parallel extractability of $\ExtCom$ with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:parallel}), and compute $\eta^*_C\coloneqq \VSS_{\Recon}(\msf{cfv}^{(1)}_1, \ldots, \msf{cfv}^{(1)}_n)$.

 Then, $\Sim$ sends $\eta_R \coloneqq \eta \xor \eta^*_C$ in \Cref{prot:td:ct:step:3}, and finishes the remaining execution emulating the honest $R$.

First, note that in a real-world execution between $C^*$ and $R$, the value $\eta^*_C$ (committed by $C^*$ in \Cref{prot:td:ct:step:2} of the {\bf Coin-Flipping Stage}) must equal to the $\eta'_C$ sent by $C^*$ in \Cref{prot:td:ct:step:4}. This is because we know that the value committed by $C^*$ in \Cref{prot:td:ct:step:1} of the {\bf Commit Stage} does not satisfies the predicate $\phi(\cdot)$ (this is state as $\phi\big(\msf{val}(\com^*)\big) = 0$ in the condition of  \Cref{def:com-n-prove:property:4}). Thus, if $C^*$ sends $\eta'_C \ne \eta^*_C$ in \Cref{prot:td:ct:step:4}, then both clauses of $F_\phi$ are unsatisfied. In this situation, $C^*$ cannot provide a convincing proof to $R$; Otherwise, she breaks the soundness of the commit-and-prove protocol. Again, see \cite[Section 6.5]{C:CCLY22} for a similar proof.

 By the extractability of $\ExtCom$, $\Sim$ is able to extract the same $\eta^*_C$ while simulating the post-extraction state of $C^*$ up to a arbitrarily small noticeable $\epsilon(\secpar)$ error, and successfully enforce the coin-flipping result to $\eta^*_C \xor \eta^*_C\xor\eta= \eta$. This establishes \Cref{def:com-n-prove:property:4}.



This concludes the proof of \Cref{lem:td-cf}.

\end{proof}



