%!TEX root = ../main.tex

\section{Technical Overview}
\label{sec:tech-overview}

This section provides an overview of our techniques. We first discuss our construction of $\epsilon$-simulatable PQ-MPC (i.e., \Cref{thm:informal:main}). This is covered in \Cref{sec:tech-oeverview:reduction-to-NMC,sec:overview:recall-LPY,sec:overview:NM:1-1,sec:QE-chal,sec:overview:NM:1-many,sec:simultaneous-ext:overview}. After that, we describe our approach to PQ-2PC and PQ-MPC {\em with full simulation} (i.e., \Cref{thm:informal:full2PC,thm:informal:fullMPC}). This is covered in \Cref{sec:overview:full-MPC,sec:overview:PQBExtCom}.


\subsection{Reduction to Post-Quantum 1-Many Non-Malleability}
\label{sec:tech-oeverview:reduction-to-NMC}
As mentioned earlier, our approach to black-box $\epsilon$-simulatable post-quantum MPC follows a pipeline established in the classical setting. In the following, we first recall it.

\para{Classical Framework.} In the classical setting, the aforementioned pipeline to obtain constant-round and black-box MPC proceeds as follows:
\begin{enumerate}
\item \label[Step]{item:classical:pipeline:1}
{\em Malicious-Sender OT:} First, build a 1-out-of-2 string OT with a weak property, namely, with security against malicious senders but only {\em semi-honest} receivers; Additionally, the associated simulator for proving security is required to be `straight-line' (i.e., not performing any rewindings). Such schemes are known from any of the following: certifiable enhanced trapdoor permutations, dense cryptosystems, linearly homomorphic PKE, or lossy PKE (see, e.g., \cite{TCC:CDMW09,FOCS:Wee10}). These schemes are black-box constructions and constant-round (indeed, two rounds suffice). 

\item \label[Step]{item:classical:pipeline:2}
{\em Multi-Party Parallel OT:} Next, a compiler is employed to transfer the malicious-sender OT to a fully-secure OT {\em in the $n$-party parallel setting}. This is the setting of $n$ parties where every pair of parties $(P_i, P_j)$ runs two executions of same OT protocol, one with $P_i$ as the sender and the other with $P_j$ as the sender. All of these $2\cdot \binom{n}{2}$ executions happen in parallel. Such a compiler was constructed in \cite{FOCS:Wee10,STOC:Goyal11}, which is constant-round and makes only black-box use of its building blocks. (We provide more details when describing our approach.)

\item \label[Step]{item:classical:pipeline:3}
{\em General-Purpose MPC:} Finally, another black-box compiler is employed to transfer the $n$-party parallel OT to a general-purpose $n$-party secure computation protocol. This compiler was introduced in \cite{C:IshPraSah08}. It blows up the round complexity only by a constant number.
% , and was employed in the work of \cite{FOCS:Wee10,STOC:Goyal11} to obtain constant-round black-box MPC.
\end{enumerate}

\para{Our Approach.} At a high-level, our approach is to replace all the primitives employed in the above pipeline with their post-quantum analog, preserving both the constant-round and black-box properties.

First, we notice that \Cref{item:classical:pipeline:1} extends to the post-quantum setting straightforwardly. That is, post-quantum malicious-sender OTs (with straight-line simulation) can be based on post-quantum dense cryptosystems, linearly homomorphic PKE, or lossy PKE, which can be in turn based on the quantum hardness of Learning with Errors (QLWE). 

Obtaining the post-quantum analog of \Cref{item:classical:pipeline:2} represents the main technical challenge. Let us first discuss about \Cref{item:classical:pipeline:3}, assuming the existence of post-quantum multi-party parallel OTs (with $\epsilon$-simulation). For that purpose, we notice that the same \cite{C:IshPraSah08} compiler (introduced in the classical setting) can be used to convert any {\em post-quantum} multi-party parallel OT (with $\epsilon$-simulation) to a {\em post-quantum} MPC (with $\epsilon$-simulation)\footnote{The same observation has been made in the two-party setting in \cite{C:CCLY22}.}. It adds at most constant rounds, makes only black-box use of the given OT protocol, and does not rely on any extra assumptions. Roughly, this is because the original security reduction in \cite{C:IshPraSah08} is in straight-line and does not copy (or `clone') the state of the adversary. Thus, the same proof can be migrated to the post-quantum setting. Although there are some caveats (e.g., how to handle the $\epsilon$-simulation error), we choose not to expand on them in this overview and refer the reader to \Cref{sec:MPC} for more details.

In the following, we focus on the post-quantum analog of \Cref{item:classical:pipeline:2}.

\para{Post-Quantum Multi-Party Parallel OT.} Our starting point is the constant-round, black-box compiler described in \cite{FOCS:Wee10,STOC:Goyal11}. The specific structure of this protocol is not the primary emphasis of this overview and is therefore omitted (see \Cref{sec:parallel-OT} for details). Our sole concern lies in the fact that this compiler relies on a distinct commitment scheme that enjoys the following properties:
\begin{itemize}
\item
{\em Constant-Round and Black-Box:} This is necessary because our ultimate goal is to obtain a constant-round OT (and MPC) that makes only black-box use of the building blocks.
\item
{\em Parallel-Extractable:} It considers the setting where a potentially malicious committer executes $n$ sessions of the scheme in parallel. It requires the existence of an extractor that can extract the committed values {\em in all the $n$ sessions simultaneously}.

\item
{\em 1-Many Non-Malleable:} As explained in the introduction, this notion considers a MIM adversary $\mcal{M}$ who plays the role of a receiver in one instance of the commitment (dubbed the left session), while simultaneously acting as a committer in polynomially many other instances (referred to as the right sessions). All the sessions happen in parallel. For security, we require that $\mcal{M}$ cannot correlate the {\em joint distribution} of the values committed in all of the right sessions with that in the (single) left session. (See \Cref{sec:nmcom} for a formal definition.)
\end{itemize}
It can be shown that as long as we have a post-quantum analog of the above commitment scheme, the same \cite{FOCS:Wee10,STOC:Goyal11} compiler can be used to convert a post-quantum malicious-sender OT (with $\epsilon$-simulation) to a post-quantum multi-party parallel OT (with $\epsilon$-simulation). 



It is worth noting that the post-quantum equivalent of (parallel) extractability necessitates an additional requirement: the extractor must be capable of simulating the post-extraction state of the malicious committer. This aspect was not explicitly addressed in the classical setting because classical information can be `cloned,' allowing an extractor to create two copies of the committer---one for extraction and the other for simulating the post-extraction state, thereby mimicking a straight-line execution. However, achieving such a `simulatable' extraction becomes challenging in the post-quantum realm. In fact, there have been suggestions that achieving post-quantum extractable commitments with negligible simulation error may be impossible in constant rounds, if one insists on black-box simulation techniques \cite{chia2022impossibility,C:CCLY22,arXiv:CCLL}. This very challenge is the reason why we relax our security notion to $\epsilon$-simulatability. Looking forward, our objective is to aim for parallel-extractable commitments with $\epsilon$-simulation for post-extraction state in the post-quantum setting. We will demonstrate that this suffices for the \cite{FOCS:Wee10,STOC:Goyal11} compiler when our ultimate goal is $\epsilon$-simulatable PQ-MPC. To maintain our focus on the core topics of this overview, we will omit additional details in this regard and refer the reader to \Cref{sec:MPC}.

\para{Post-Quantum 1-Many Non-Malleability.} Next, our focus turns to the development of a commitment scheme that satisfies the post-quantum analog of the three properties mentioned earlier. To achieve this, we start with the constant-round post-quantum non-malleable commitment described in \cite{FOCS:LPY23}. First, we observe that the \cite{FOCS:LPY23} scheme is already post-quantum extractable (with $\epsilon$-simulation of the post-extraction state) {\em in the stand-alone setting}. Also, it is not hard to see that the techniques from \cite{C:CCLY22} can be used to prove that the \cite{FOCS:LPY23} scheme is post-quantum {\em parallel}-extractable as well. However, it is important to note that the \cite{FOCS:LPY23} scheme achieves non-malleability in the {\em 1-1 setting} only, as opposed to being {\em 1-many non-malleable}. Furthermore, it extensively relies on the use of its underlying primitive (i.e., a post-quantum one-way function) in a {\em non-black-box} manner. Indeed, the question of constructing constant-round post-quantum commitments that achieve {\em either of these two properties} remains an open challenge. In the following, we describe our ideas to achieves {\em both} properties, under the minimal assumption of post-quantum one-way functions.


\subsection{PQ-NMC from \cite{FOCS:LPY23}} 
\label{sec:overview:recall-LPY}

We first recall the \cite{FOCS:LPY23} construction and the salient features therein that help with the proof of non-malleability. For our purpose, it is sufficient to focus on the simplified scheme shown in the technical overview of \cite{FOCS:LPY23}. That construction achieves non-malleability in the synchronous 1-1 MIM setting, where the left-session tag $t$ is {\em strictly smaller than} the right-session tag $\tilde{t}$ (dubbed `one-sided' non-malleability). 

It works as follows: To commit to a message $m$ with tag $t \in [n]$, the committer $C$ first commits to $m$ using a statistically binding commitment scheme $\msf{com}=\Com(m;r)$ (e.g., Naor's commitment). Then, the receiver $R$ sends a hard puzzle that has {\em exactly} $t$ distinct solutions; $R$ also gives a witness-indistinguishable proof of knowledge (referred to as {\bf WIPoK-1}) to prove that it knows one of the $t$ solutions. Finally, $C$ is required to prove using another WIPoK (referred to as {\bf WIPoK-2}) that it knows {\em either} the value committed in $\msf{com}$ {\em or} one solution to $R$'s hard puzzle. 

  We illustrate the 1-1 MIM execution of this protocol in \Cref{figure:one-sided:tech-overview:real} (borrowed from \cite{FOCS:LPY23}), where the $t$-solution hard puzzle is instantiated with $t$ images $(y_1, \ldots, y_t)$ of an {\em injective} OWF $f$, and the solutions are the preimage $x_i$'s satisfying $y_i = f(x_i)$ for all $i \in [t]$.
\begin{figure}
\begin{subfigure}[h]{0.9\textwidth}
 \centering
         \fbox{
         \includegraphics[width=\textwidth,page=1]{figures/figures-new-tech-overview.pdf}
         }
         \caption{Man-in-the-Middle Execution of $\langle C, R\rangle^{\msf{OneSided}}_{\msf{tg}}$}
         \label{figure:one-sided:tech-overview:real}
     \end{subfigure}
     \\~

     \begin{subfigure}[h]{0.9\textwidth}
      \vspace{3em}
		\centering
        \fbox{
         \includegraphics[width=\textwidth]{figures/Extractor-Ki.pdf}
         }
         \caption{The Simulation-less Extractor $\mcal{K}_i$}
         \label{figure:one-sided:tech-overview:Ki}
     \end{subfigure}
     \caption{}
\end{figure}

\para{A Pigeon-Hole Argument.} Proofs of non-malleability typically rely on the following intuitive claim: in the MIM interaction, we want the honest committer $C$ to be able to `cheat' on the left, while the MIM adversary $\mcal{M}$ should not be able to `cheat' similarly on the right. To show this, \cite{FOCS:LPY23} relies on a pigeon-hole based argument, which we sketch here. Note that in the MIM interaction depicted in \Cref{figure:one-sided:tech-overview:real}, there is an inherent asymmetry between the left and right side executions---there are more puzzle solutions on the right as compared to the number on the left (since $t < \tilde{t}$). This leads to the following intuitive observation: suppose the receiver $R$ switches the witness it uses in {\bf WIPoK-1} on the right. Due to this asymmetry, $\mcal{M}$ cannot switch its witness in every such case. Namely, by the pigeonhole principle, there {\em must} exist indices $i,j \in [\tilde{t}]$ on the right and $k \in [t]$ on the left such that no matter which of $\tilde{x}_i$ or $\tilde{x}_j$ is used as a witness, $\mcal{M}$ can only $x_k$ as witness in the left {\bf WIPoK-1}. 

For this `pigeon-hole tuple' $(\tilde{x}_i, \tilde{x}_j, x_k)$, we see that the following must also happen---suppose the left-session $C$ uses $x_k$ as witness in the left {\bf WIPoK-2}, we can then argue that $\mcal{M}$ must use $\tilde{m}$ in the right {\bf WIPoK-2} as follows: 
\begin{itemize}
\item
First, assuming $R$ uses $\tilde{x}_i$ in the right {\bf WIPoK-1} and $\mcal{M}$ uses $x_k$ in the left {\bf WIPoK-1}, if we extract from the right {\bf WIPoK-2}, the extracted value can only equal $\tilde{m}$ or $\tilde{x}_i$. That is because other $\tilde{x}_j$'s (with $j \ne i$) have not been used in the right {\bf WIPoK-1} and so we can appeal to the one-wayness of $f$ to say that $\mcal{M}$ cannot learn these values.
\item
Similarly, assuming $R$ uses $\tilde{x}_j$ in the right {\bf WIPoK-1}  and $\mcal{M}$ uses $x_k$ in the left {\bf WIPoK-1}, if we extract from the right {\bf WIPoK-2}, the extracted value can only take the values $\tilde{m}$ or $\tilde{x}_j$.  
\end{itemize}
Then, by the witness indistinguishability of the right {\bf WIPoK-1}, the extracted value should {\em not} change if $R$ switches between $\tilde{x}_i$ and $\tilde{x}_j$ (in the right {\bf WIPoK-1}). Thus the extracted value can only be $\tilde{m}$ if $R$ uses $\tilde{x}_i$ (or $\tilde{x}_j$) on the right and $C$ uses $x_k$ on the left.


It seems that the approach outlined above is promising and can help show the intuitive guarantee of allowing $C$ to ``cheat'' on the left while preventing such behavior from $\mcal{M}$ on the right. However, actually proving such a guarantee is quite challenging and is the core technical contribution of \cite{FOCS:LPY23}. In particular, they must address the following technical hurdles: (1) a mechanism is needed to efficiently identify the `magic' triples $(\tilde{x}_i,\tilde{x}_j,x_k)$---one cannot extract $x_k$ from the left {\bf WIPoK-1} simply by rewinding, because the above argument relies on the WI property of that stage, which may not hold if it is rewound. (2) More crucially, the above pigeon-hole argument assumed a one-to-one correspondence between the $\mcal{M}$'s witness and $R$'s witness used in {\bf WIPoK-1}. This is over simplified. Indeed, $\mcal{M}$ can switch its witness {\em probabilistically} when $R$ switches witnesses. 

To address these issues, \cite{FOCS:LPY23} develops an involved {\em distributional} pigeon-hole lemma to formally captures the intuition above. For the current overview, the details of this lemma is not crucial, and thus we do not dig it further. However, the structure of the proof in \cite{FOCS:LPY23} is crucial for understanding our new techniques later. Therefore, we briefly recall its structure below, focusing only on the aspects necessary to establish a foundation for the subsequent discussion of our techniques.

\para{\cite{FOCS:LPY23}'s Proof Structure.} At a high level, the \cite{FOCS:LPY23} approach involves a reduction from non-malleability to the hiding of the left Naor commitment $\Com$ performed initially. This is a rigorous formalization of the aforementioned intuition that `we can cheat in the left but $\mcal{M}$ cannot in the right.' In more detail, they first make the subsequent portion of the left execution after $\Com$ {\em independent} of message $m$, so that the reduction can go through. Next, the idea is to extract the $\tilde{m}$ committed initially by $\mcal{M}$ from the right session. If one can always extract the correct value $\tilde{m}$ and while not unduly disturbing $\mcal{M}$'s post-extraction state, the reduction to the hiding of $\Com$ is easily seen: If $\mcal{M}$'s $\tilde{m}$ changes according to $m$ (i.e., the message committed in $\Com$ on the left), then one can always use $\tilde{m}$ extracted from the right {\bf WIPoK-2} to detect the difference, compromising the hiding property of $\Com$. Thus, the {\em most challenging part} in this approach is to efficiently extract $\tilde{m}$, without disturbing $\mcal{M}$'s post-extraction state too much.


\cite{FOCS:LPY23} builds such an `extractor with simulation' in two steps. First, they build a `base' extractor $\mcal{K}$ without any simulation guarantee, whose job is only to extract $\tilde{m}$ correctly. $\mcal{K}$ works by sampling an uniform index $i \in [\tilde{t}]$ and running the machine $\mcal{K}_i$ depicted in \Cref{figure:one-sided:tech-overview:Ki}. In particular $\mcal{K}_i$ differs from the real MIM execution in the following way: (1) it uses $\tilde{x}_i$ (instead of $\tilde{x}_1$) as the witness in the right {\bf WIPoK-1}; (2) it uses the witness extractor $\mcal{WE}$ to obtain the witness $j\|x_j$ used by $\mcal{M}$ in the left {\bf WIPoK-1}, and then uses this extracted $j\|x_j$ to finish the left {\bf WIPoK-2}; (3) it uses the witness extractor $\mcal{WE}$ to extract the witness $\msf{Val}$ used by $\mcal{M}$ in the right {\bf WIPoK-2} and hopes that $\msf{Val} = \tilde{m}$.

 \cite{FOCS:LPY23} uses the aforementioned distributional pigeon-hole lemma to prove that such a machine $\mcal{K}$ will indeed extract $\msf{Val} =\tilde{m}$ with noticeable probability, {\em conditioned on a `good' prefix (i.e., Steps 1 and 2) from which $\mcal{M}$ will indeed finish the execution with noticeable probability} (this condition is necessary: one cannot hope to extract $\tilde{m}$ with noticeable probability if, say, $\mcal{M}$ always aborts in the real MIM execution).



Next, \cite{FOCS:LPY23} develops a {\em simulation-extraction} lemma. Using this lemma, they are able to convert the simulation-less $K$ into a new machine $\SimExt$ that extracts $\tilde{m}$ while {\em also} being able to simulate the post-extraction state. 
% up to distance $\epsilon$
 % (where $\epsilon$ is a noticeable function that can be made arbitrarily small). 
  As remarked before, this gets them most of the way through the proof---\cite{FOCS:LPY23} show that one can use $\SimExt$ to complete the outlined reduction to hiding of $\Com$, and thus demonstrate non-malleability.




\iffalse
%The main points to note in this template are that (i) the committed value is fixed by a standard Naor commitment right within the first two rounds (ii) the receiver proves knowledge of a solution to the subsequent puzzle it sets after the initial commitment via a WIPoK (in fact a WIAoK suffices), allowing one to in principle extract this puzzle solution, and (iii) the committer in turn proves knowledge of either the committed message or a puzzle solution using WIPoK, again potentially allowing this value to be obtained via knowledge extraction. 

We now review how this template allows for proving non-malleability. Towards this end, a very natural approach is to reduce non-malleability to the hiding of the initial Naor commitment. In the process, we must also obtain the committed value $\tilde{m}$ from the right hand execution, since this is included in the output of the standard non-malleability experiment. Specifically, for this described template, one can generate the {\bf Step-1} and {\bf Step-2} messages in the left interaction by forwarding messages between $\mcal{M}$ and an (external) challenger for the hiding property of Naor's commitment; Meanwhile, one also extracts the witness $w'$ from the right {\bf WIPoK-2}. Then, if $\mcal{M}$ makes the value $\tilde{m}$ depend on the value committed in the first two steps in the left, and also uses the witness $w'=(\tilde{m}, \tilde{r})$, we win the hiding game by checking the extracted $w'$. 

\begin{figure}[!tb]
     \begin{subfigure}[t]{0.47\textwidth}
         \centering
         \fbox{
         \includegraphics[width=\textwidth,page=4]{figures/figures-new-tech-overview-new.pdf}
         }
         \caption{}
         \label{figure:tech-overview:one-sided:G1}
     \end{subfigure}
     \hspace{6.5pt}
     \begin{subfigure}[t]{0.47\textwidth}
         \centering
         \fbox{
         \includegraphics[width=\textwidth,page=5]{figures/figures-new-tech-overview-new.pdf}
         }
         \caption{}
         \label{figure:tech-overview:one-sided:K1}
     \end{subfigure}
     \caption{Machines $\mcal{G}_1$ and $\mcal{K}_1$}
     \label{figure:tech-overview:one-sided:G1-K1}
\end{figure}


To implement this idea, one first needs to make the interaction happening after the left {\bf Step-2} {\em independent of $m$}; Otherwise, the above reduction will not work---Because the left Naor's commitment is now coming from an external challenger so that the reduction does not posses the value $m$ anymore, which is required to finish the remaining steps (in particular, the left {\bf WIPoK-2}) of the left interaction. To address this issue, we consider an intermediate execution $\mcal{G}_1$ shown in \Cref{figure:tech-overview:one-sided:G1}---The only difference (shown in red) between $\mcal{G}_1$ and the real MIM game (\Cref{figure:one-sided:tech-overview:real}) is that $\mcal{G}_1$ uses the knowledge extractor $\mcal{WE}$ in the left {\bf WIPoK-1}, and uses the extracted witness $(j, x_j)$ as the witness to go through the left {\bf WIPoK-2}. In this way, the interaction after the left {\bf Step-2} does not depend on $m$ anymore. 

However, a prominent concern still needs addressing: namely, making sure that the witness extracted from {\bf WIPoK-2} actually corresponds to $\tilde{m}$. It is easy to see that the only possible values for $w'$ is $(\tilde{m}, \tilde{r})$ or $(1, \tilde{x}_1)$, because these comprise the only data that $\mcal{M}$ could potentially possess that allows it to succeed in the proof, assuming it cannot break the one-wayness of the OWF $\tilde{f}$ in the right {\bf Step-3}. However, since we run $\mcal{WE}$ for the left {\bf WIPoK-1}, $\mcal{M}$ could also learn the witness $(1, \tilde{x}_1)$ used by $R$ in the right {\bf WIPoK-1}. When we further switch the witness from $(m,r)$ to the extracted $(j, x_j)$ in the left {\bf WIPoK-2}, nothing stops $\mcal{M}$ from switching her witness from $(\tilde{m}, \tilde{r})$ to $(1, \tilde{x}_1)$. Therefore we can no longer argue that the extracted $w'$ must be $(\tilde{m}, \tilde{r})$. We emphasize that the WI property of the left {\bf WIPoK-2} does not help in ruling out this possibility---{\em WI does not protect against a man-in-the-middle adversary who is trying to make the right WIPoK instance depend on the left WIPoK instance.} Instead, this is a ``non-malleability'' type of requirement rather than (plain) witness indistinguishability. In that sense, the above argument does not definitively address the issue of non-malleability; Rather, it simply {\em defers} the non-malleability requirement to the WIPoK used in the final {\bf WIPoK-2} stage.

Here we remark on the {\em dual} function of the {\bf WIPoK} proofs in this template, which serve both to testify to `honest' behaviour by the man-in-the-middle, {\em and} allow for extraction opportunities for the puzzle solutions (used as a trapdoor) and the right side committed value. We will revisit this point in discussing our black-box commitment design. 

\subpara{A Key Lemma:} To complete the proof of non-malleability, we will now sketch why the extracted witness $w'$ in our approach is indeed equal to $(\tilde{m},r)$ with a certain good probability. This will draw on another crucial feature of this template---in a nutshell, the $t$-solution hard puzzle introduces an ``asymmetry'' between the right and the left sessions as $t<\tilde{t}$; one can exploit this to perform a pigeon-hole-style argument that tackles the non-malleability issue directly. 

In more detail, we consider another hybrid $\mcal{K}_1$ shown in \Cref{figure:tech-overview:one-sided:K1}. Hybrid $\mcal{K}_1$ is similar to $\mcal{G}_{1}$ but it does not rewind the left {\bf WIPoK-1} for witness extraction (we will explain shortly which witness $\mcal{K}_1$ will use to perform the left {\bf WIPoK-2}).

We first make a crucial observation: There are $\tilde{t}$ preimages $\Set{\tilde{x}_1, \ldots, \tilde{x}_{\tilde{t}}}$ that $R$ could potentially use as the witness to perform the right {\bf WIPoK-1}. In contrast, there are at most $t$ preimages $\Set{x_1, \ldots, x_t}$ that $\mcal{M}$ could potentially use as the witness to perform the left {\bf WIPoK-1}. Since the {\bf WIPoK-1} stage itself is not ``non-malleable'', it is possible that $\mcal{M}$'s witness used there depends on $R$'s witness used in the right {\bf WIPoK-1}---again, standard witness-indistinguishability does not rule out such a dependency. For example, if $R$ uses $\tilde{x}_1$ to perform the right {\bf WIPoK-1}, $\mcal{M}$ may use, say, $x_3$ in the left {\bf WIPoK-1}; If $R$ instead uses $\tilde{x}_2$, $\mcal{M}$ may switch to $x_5$ in the left {\bf WIPoK-1}. 

Now, recall that $t\le \tilde{t}-1$ (because we consider the one-sided setting). It then follows from the pigeon-hole principle that there must exist a distinct pair $\tilde{x}_i, \tilde{x}_j \in \Set{\tilde{x}_1, \ldots, \tilde{x}_{\tilde{t}}}$ and an $x_k\in\Set{x_1, \ldots, x_t}$ such that $(\tilde{x}_i, \tilde{x}_j, x_k)$ form the following correspondence: {\em No matter $R$ uses $\tilde{x}_i$ or $\tilde{x_j}$ in the right {\bf WIPoK-1}, $\mcal{M}$ always uses (the same) $x_k$ in the left {\bf WIPoK-1}}. 

If we assume that $\mcal{K}_1$ somehow ``magically'' knows this pigeon-hole tuple $(\tilde{x}_i, \tilde{x}_j, x_k)$, then we can prove $w' = \tilde{m}$ using the following argument. Consider two scenarios:
 \begin{enumerate}
 \item
When $R$ uses $\tilde{x}_i$ in the right {\bf WIPoK-1} and $C$ (or $\mcal{K}_1$) uses $x_k$ in the left {\bf WIPoK-2}, we can prove that the extracted $w'$ can only take the values of $\tilde{m}$ or $\tilde{x}_i$. Intuitively, this is because $\tilde{m}$ and $\tilde{x}_i$ are the only witnesses that $\mcal{M}$ could potentially use for the right {\bf WIPoK-2}, assuming it cannot break the one-wayness of the right OWF $\tilde{f}$. %We suppress the full proof in this informal discussion, as we will show a formal (and slightly different) argument in the next subsection.
\item
When $R$ uses $\tilde{x}_j$ in the right {\bf WIPoK-1} and $C$ uses (the same) $x_k$ in the left {\bf WIPoK-2}, we can prove that the extracted $w'$ can only take the values of $\tilde{m}$ or $\tilde{x}_j$. This follows from a similar argument to the above. 
\end{enumerate}  

Next, observe that $\mcal{K}_1$ does {\em not} rewind the {\bf WIPoK-1} stage. By the witness indistinguishability of the right {\bf WIPoK-1}, it follows that the witness used by $\mcal{M}$ in the right {\bf WIPoK-2} cannot change when $R$ switches between $\tilde{x}_i$ and $\tilde{x}_j$ in the right {\bf WIPoK-1} (otherwise, we can invoke the knowledge extractor of the right {\bf WIPoK-2} to extract the used witness to detect this change). This, together with the above two arguments, implies that the extracted $w'$ can only take the value $\tilde{m}$ if $R$ uses $\tilde{x}_i$ (or $\tilde{x}_j$) in the right {\bf WIPoK-1}. Notice that in this argument, we do not rely on the ``non-malleability'' (or even WI) of the final {\bf WIPoK-2} stage, because in both scenarios described above, $C$ uses the same $x_k$ in the left {\bf WIPoK-2}. 

While we have made several starkly simplifying assumptions, this sketch still provides what we think is a reasonably nuanced flavour of the core intuition underlying the non-malleability proof. Several questions remain---for example, how do we determine such magic triples of puzzle solutions---but these can be handled using a more careful formulation of the ideas above, and we direct the interested reader to  \cite{FOCS:LPY23} for more information. 

We capture the conclusion of the arguments above in the following informal lemma. This will give us a good branching off point as we turn to considering how the above template can be modified to facilitate a black-box construction. 

\begin{lemma}[Informal]\label{lem:tech-overview:main}
    Assume that {\em in the real MIM execution}, $\mcal{M}$ convinces the honest right receiver $R$ with some noticeable probability $p(\secpar)$. Then, there exists a machine $\mcal{K}$ such that the extracted witness $w'$ in $\mcal{K}$ must be a valid opening $(\tilde{m},\tilde{r})$ for $\tilde{\msf{com}}$ with another noticeable probability $p'(\secpar)/\tilde{t}$, where $\tilde{t}$ is tag in the right session. 
\end{lemma}

\rohit{Blurb for amplification lemma} We remark that this lemma does not help finish the proof of non-malleability as is. To show non-malleability, we need to change the committed message on the left, while also being able to extract the committed value on the right without fail (except say with negligible probability). The `base extractor' that is captured in the lemma falls short for this purpose: firstly, it is neither able to extract with overwhelming probability, and the secondly it does not directly help us change around the committed value on the left - the hope here would be that it would provide a `simulated' post-execution state for $\mcal{M}$ where the left side session would employ the extracted puzzle solutions in {\bf WIPoK-2}. \cite{FOCS:LPY23} show how to achieve this by giving an `amplification lemma' which firsts suitably boosts the probability of extraction, and also simulates a reasonably close post-extraction state. Using such an `amplified' simulator-extractor machine, we can carry out the proof approach. The details of how this amplification is achieved can be found by the interested reader in \cite{FOCS:LPY23}. 
\fi

%This proof outline seems to be promising (a reader familiar with the literature on non-malleability will observe that this approach is targeted at solving the {\em robust extraction} issue), but some prominent concerns need addressing before one can be convinced that it actually works. 

\subsection{Our Black-Box Construction: 1-1 Setting}
\label{sec:overview:NM:1-1}
 While the \cite{FOCS:LPY23} commitment is non-malleable and works in constant rounds, it does not suffice for our application because the construction makes heavy non-black-box use of its cryptographic components, and it is unclear if their security proof holds in the more demanding 1-many MIM setting. Now, we first introduce new ideas to obtain a black-box construction.  


\iffalse
Primarily, the reason why the commitment showed in \Cref{figure:one-sided:tech-overview:real} is not black-box is due to the {\bf WIPoK} executions in this protocol. Note that these prove relations over the `puzzles' which are input-output pairs of the injective OWF, hence making non-black-box use of the latter. Our goal thus necessitates the use of black-box tools that can circumvent this dependency. 

Our starting point is the extensive literature on {\em black-box} zero knowledge and witness indistinguishable arguments \rohit{cite relevant} that predominantly rely on the so-called {\em MPC-in-the-head} paradigm. This is perhaps best described as a commit and prove template, and involves the prover performing an MPC execution virtually (`in its head'), with parties that each have a share of the prover's witness for the relation to be proved (and the functionality being computed is a predicate corresponding to this relation). The prover starts by committing to the views of the virtual parties in this MPC execution. The verifier then asks for some of these views to be opened, which the prover does by decommitting to them. The verifier then checks for {\em consistency} between the revealed views (i.e., whether these show the same messages being sent at the same positions, and so on) and accepts the interaction if these views are indeed consistent. \rohit{Elaborate?} 


The work of \cite{C:CCLY22} introduced a post-quantum version of such a black-box ZK argument. This of course removes the first impediment towards realizing the \cite{FOCS:LPY23} template in a black-box manner. Note that when used in commit-and-prove form, this argument system requires the commitments to be made in a specific, `black-box friendly' manner. Namely, one requires the prover to commit to {\em VSS shares} of the intended value, where VSS schemes are strengthened versions of standard secret sharing schemes that are robust to {\em tampering} of upto a certain fraction of the total shares by an adversary. 

However, although we can now prove statements in a black-box manner, the issue as we remarked above is also that in the \cite{FOCS:LPY23} template, the statements proved in both {\bf WIPoK-1} and {\bf WIPoK-2} are over the OWF itself, making them {\em inherently cryptographic}. Thus it is of no use to simply use an argument system with a black-box construction---if the statement it proves is itself non-black-box in a different component, then the overall design remain non-black-box. Fortunately, the fix for this is simple and also has the advantage of eliminating the requirement of injective OWFs. In more detail, we can change the receiver's puzzle setup step to first sampling uniform strings of appropriate length, and then committing to them in `black-box-friendly' form (i.e., committing to VSS shares of these strings together). Intuitively, the hardness of the puzzle derives from the hiding of the commitment, and in turn binding assures uniqueness of solutions. No other changes to the previous template are needed for this issue.  
\fi 

Observe that there are two sources of non-black-box usage in \Cref{figure:one-sided:tech-overview:real}. First, $R$'s proof in {\bf WIPoK-1} needs the code of the hard puzzle (i.e., the OWF $f$); Second, $C$'s consistency proof {\bf WIPoK-2} makes non-black-box use of {\em both} the hard puzzle {\em and} Naor's commitment in {\bf Step-1}.

We first notice that it is not hard to make $R$'s behavior black-box. Essentially, what $R$ does in the hard-puzzle set-up stage is first `committing' to $t$ solutions and then proving that it knows one solution. This is actually a classical task called {\em witness indistinguishable commit-and-prove (of knowledge)}. It is not hard to modify existing black-box witness indistinguishable commit-and-prove protocols (e.g., \cite{C:CCLY22}) to make $R$'s hard puzzle and the {\bf WIPoK-1} steps black-box. In the following, we only focus on the non-black-box usage on $C$'s side. 

% In particular, both the receiver's proof {\bf WIPoK-1} and the committer's consistency proof {\bf WIPoK-2} make {\em non-black-box} use of the one-way function $f$ associated with the hard puzzles, since they prove relations over the puzzles which are input-output pairs of $f$. Fortunately, making the receiver's proof for {\bf WIPoK-1} black-box is quite standard. We know of works in the post-quantum setting (\cite{C:CCLY22}) that build {\em black-box commit-and-prove} protocols, which allow one commit to values of their choice, and then prove in a black-box manner some non-cryptographic predicate over the committed values. This uses the so-called {\em MPC-in-the-head} paradigm. It is not hard to modify the puzzle setup and subsequent proof of honest behavior to this commit-and-prove form, and thus we can overcome our first hurdle in moving to a black-box construction. 

Making $C$'s consistency proof {\bf WIPoK-2} black-box turns out to be quite challenging. One may hope to re-use the aforementioned black-box commit-and-prove technique to resolve the non-black-box use of the {\bf Step-1} Naor's commitment. However, the real difficulty lies in its dependency on the puzzle (i.e., the alternate clause in {\bf WIPoK-2} in \Cref{figure:one-sided:tech-overview:real}). Notice that the puzzle solutions are {\em only known to $R$}! This means that the statement becomes one about the {\em preimages} of $f$, for which the committer/prover (i.e., party $C$) does not have a witness.  In this scenario, it is unclear how the black-box commit-and-prove techniques could help. 

We develop new ideas to tackle this challenge. Our guiding principle is to modify {\bf WIPoK-2} so that it proves only {\em non-cryptographic} relations. That is, we try to make {\bf WIPoK-2} depend only on values that are {\em either} committed by $C$ itself (so that it can be handled by black-box commit-and-prove), {\em or} otherwise made available to both parties in the course of the protocol. 

To do this, we start with careful scrutiny of \cite{FOCS:LPY23}'s simulation-less extractor $\mcal{K}_i$ shown in \Cref{figure:one-sided:tech-overview:Ki}. We observe that the {\bf WIPoK-2} stage there can be interpreted as serving a {\em dual} function in their security proof: (1) It is used to ensure honest behavior of the committer (or $\mcal{M}$ in the MIM setting); This is what essentially helps them perform the distributional pigeon hole argument. (2) The proof of knowledge property of this stage provides {\em extraction opportunities} to efficiently  learn $\tilde{m}$. 

We find that these two purposes can in fact be `decoupled', leading to a more modular security proof as follows: first, one can imagine a $\mcal{K}'_i$ that is identical to the original $\mcal{K}_i$ but does not invoke $\mcal{WE}$ for the right {\bf WIPoK-2}. For this new $\mcal{K}'_i$, we could hope to re-use \cite{FOCS:LPY23}'s distributional pigeon-hole lemma to argue that {\em the witness `used' by $\mcal{K}'_i$ in the right {\bf WIPoK-2} should be $\tilde{m}$ with good probability}. Second, it is a simple application of the proof of knowledge property to extract the witness used in this {\bf WIPoK-2}, {\em which is guaranteed to be $\tilde{m}$ (with good probability) by the previous step}.

On the other hand, notice that {\em once the protocol is completed}, it is safe for $R$ to disclose its hard puzzle solutions. This seems vacuously true and useless. However, it becomes very useful once combined with the observation in the last paragraph, which yields our key idea---we propose to replace the {\bf WIPoK-2} stage by the following three steps:
\begin{enumerate}
\item 
{\bf ExtCom:} $C$ commits to $m$ again using an extractable commitment;
\item
{\bf Solution Reveal:} $R$ reveals all the hard puzzle solutions $(x_1, \ldots, x_t)$;
\item
{\bf WIP-2:} $C$ proves the same relation as in \cite{FOCS:LPY23} {\bf WIPoK-2}, using a WI proof. (Note that we do not require the proof of knowledge property anymore.) In particular, $C$ proves that the value committed in $\ExtCom$ is equal to {\em either} the value committed in {\bf Step-1} Naor's commitment, {\em or} one of the puzzle solutions among the (already revealed) $x_i$'s.
\end{enumerate}
This structure exercises our previous observations as follows. We first `decouple' the two functions of the original {\bf WIPoK-2} (as explained above) by delegating the extractability to {\bf ExtCom} and the consistency proof to {\bf WIP-2}. Then, we can ask $R$ to reveal the puzzle solutions right after {\bf ExtCom}, because at that moment $C$ (or $\mcal{M}$ in the MIM setting) has already `fixed' the witness for consistency proof (i.e., the current {\bf WIP-2}) in {\bf ExtCom}, and cannot change its mind anymore even if the hard puzzle solutions are revealed to it. 

Indeed, we can show this protocol is non-malleable as follows. Consider a $\mcal{K}''_i$ that is similar to $\mcal{K}$ in \Cref{figure:one-sided:tech-overview:Ki}, but instead extract $\msf{Val}$ from $\mcal{M}$'s {\bf ExtCom} on the right. Then, a similar distributional pigeon-hole argument can be established, proving that the $\msf{Val}$ extracted from {\bf ExtCom} indeed equals to $\tilde{m}$ with good probability. Then, using the same technique as in \cite{FOCS:LPY23}, we can build a simulation-less extractor $\mcal{K}$ from this new $\mcal{K}''_i$ and convert $\mcal{K}$ to a simulation extractor to finish the final reduction to the hiding property of the left Naor's commitment.

It seems we are already done---To make $C$'s behavior black-box, note that all $C$ does now is to commit to two values, one in the original {\bf Step-1} and the other in the new {\bf ExtCom}, and then proves in the new {\bf WIP-2} a non-cryptographic predicate (since the puzzle solutions are revealed) over the two committed values and the revealed puzzle solutions. As mentioned earlier, this task can be made black-box by a simple application of known black-box commit-and-prove techniques. This indeed works {\em if our goal were to build a classically secure scheme}. Unfortunately, this step turns out to be challenging in the presence of a quantum $\mcal{M}$, due to reasons exclusive to the quantum setting. We describe these in \Cref{sec:QE-chal}.






\subsection{Quantum-Exclusive Challenges}
\label{sec:QE-chal}

To explain these challenges, we first briefly recall how canonical black-box commit-and-prove protocols broadly work. At a very cursory level, such protocols have (as indicated by their nomenclature) well-defined {\em commit} and {\em prove} stages. The {\bf commit stage} has the prover commit to values involved later in the proof statement, but not directly. Instead, one commits to shares obtained from a {\em Verifiable Secret Sharing} (VSS) of the intended value. These are a strengthening of standard secret secret sharing schemes and allow for reconstruction of the secret even if some shares are adversarially tampered with---and like standard secret sharing schemes, hide the secret completely if not enough shares are collected. 

This is done for compatibility with the subsequent (black-box) {\bf prove stage}, where the prover follows the {\em MPC-in-the-head} \cite{STOC:IKOS07,FOCS:GLOV12} approach: First the committer (or prover) $C$ emulates in her head a MPC execution with $n$ parties (where the inputs are the VSS shares from the commit stage), and commits to the views of each party during this virtual execution. This is followed by a `cut-and-choose' interaction, where $C$ and the receiver (or verifier) $R$ agree on some subset $\eta \subset [n]$ (of size $k$) of the views from the virtual MPC execution (which includes the initial VSS shares)---typically via a coin-tossing step which helps with extablishing zero knowledge for this protocol, but we gloss over this for now---and the prover reveals the corresponding views. The verifier then checks {\em consistency} of the views; by the design of the protocol, this allows the verifier to catch a cheating prover out with a fairly high probability (establishing soundness), but reveals nothing about the value committed by the prover in the commit stage (leading to zero knowledge).  

%There are a wide variety of such protocols in the classical setting with the properties we require. Fortunately for us, more relevant to our case is the work of \cite{C:CCLY22} who present a {\em post-quantum} secure black-box commit and prove protocol.

As indicated, we want to use such a scheme to supply the commmitter's proof of consistency. Accordingly, we will have {\bf Step-1} and the new {\bf ExtCom} correspond to the commit stage, and the {\bf WIP-2} will correspond to the prove stage of the commit-and-prove protocol. In particular, this makes the initial commitment in {\bf Step-1} of our protocol no longer a straightforward Naor commitment to $m$---instead, this is now a commitment (in parallel) to {\em VSS shares} of $m$, as is necessary for the commit-and-prove technique. Since we aim to overall reduce non-malleability to the hiding of the initial commitment, we must now consider a reduction directly to the hiding of the commit stage of the commit-and-prove protocol.  

This is deceptively tricky. The reason lies in the operation of the black-box commit-and-prove protocol; recall that this entails that some of the VSS shares from the {\bf commit phase} be revealed during the {\bf prove stage}. To realize this with standard commitments is hard because the hiding guarantee does not cover such `partial' revealing of information about the committed value. The solution turns out to involve modifying the standard hiding game to incorporate VSS shares (namely, to perform the commitment as described earlier by committing to VSS shares of the message) and allowing for a partial reveal of a certain subset shares of the adversary's choice later in the challenge (this `mimics' the subsequent proof stage interaction, allowing for a subset of shares corresponding to $\eta$ to be revealed by the VSS-based hiding challenger). We articulate such a `VSS-based hiding' game in the course of our proof and show that this is hard to win given standard (computational) hiding of commitments and the secrecy property of VSS schemes.

We now turn to how the reduction itself works. As a first attempt, consider a reduction $R^*$ that runs the MIM game internally and forwards the {\bf Step-1} commitment to the external VSS hiding challenger. Note that $R^*$ needs to specify a challenge set $\eta$. $R^*$ could simply wait until the MIM $\mcal{M}$ sends $\eta$ in the left {\bf WIP-2} execution, and forward this $\eta$ to the external challenger. This seems to work, assuming $R^*$ ran machine $\mcal{K}''_i$ (or the $\mcal{K}$ built out of $\mcal{K}''_i$) to thereby win the VSS hiding game. However, note that in the final reduction to hiding, $R^*$ instead needs to run the simulation extractor $\mcal{SE}$ that is built out of $\mcal{K}$ using the \cite{FOCS:LPY23} simulation-extraction lemma. In more detail, $\mcal{SE}$ involves {\em coherently rewinding} the machine $\mcal{K}$. This is problematic: recall that $\mcal{M}$ sends set $\eta$ in {\bf WIP-2}, and this $\eta$ needs to be forwarded to the external VSS hiding challenger, which we can of course not rewind \footnote{This is of course not an issue in the classical setting, wherein the machine $\mcal{K}$ does not need enhancement, because simulation can be easily added on by making two copies of the adversary: one for extraction and the other for simulation.}. 

Our heuristic towards solving this is to make sure that $R^*$'s communication with the external challenger should {\em end before the post-prefix phase of its internal MIM execution starts}. As a first try, we let $R^*$ sample the set $\eta$ by itself. To make sure that $\mcal{M}$ indeed uses the same $\eta$ during the left {\bf WIP-2} stage, we add a coin-flipping protocol to generate the challenge set. The hope is to let $R^*$ use the simulator for the coin-flipping interaction to `force' $\mcal{M}$'s challenge set to the $\eta$ it sampled beforehand.

Unfortunately this does not work. Recall that we are in the MIM setting: if we force $\mcal{M}$'s coin-flip protocol on the left, it is possible that $\mcal{M}$ could in turn force the coin-flipping result in the right session with $R$, where the soundness guarantee of the right {\bf WIP-2} may not hold anymore. It thus seems what we need is a {\em non-malleable} coin-flipping protocol; where we can force the result in the left session but $\mcal{M}$ cannot. This however puts the cart before the horse in that it is known that {\em non-malleable} coin-flipping implies non-malleable commitments, which is our object. Thus it seems this approach is a dead end. 

\para{Trapdoor Coin-Flipping}. Fortunately, we manage to resuscitate this approach with the following new ideas. To understand that, let us first delve deeper into the \cite{FOCS:LPY23} proof of non-malleability.  We have already mentioned that for the machine $\mcal{K}''_i$ described before, even if we {\em do not} extract from the right {\bf ExtCom}, we can use a similar pigeon-hole argument to show that the value committed there is indeed $\tilde{m}$ with good probability. This is argued in two steps:
\begin{itemize}
      \item
      First,  we can use the \cite{FOCS:LPY23} pigeon-hole argument to show that even if the left $C$ commits in the left {\bf ExtCom} to some $j\|x_j$ it extracted from the hard puzzle, $\mcal{M}$ cannot in turn commit to some puzzle solution in the right {\bf ExtCom}. We emphasize that this step {\em does not} rely on the soundness of the right {\bf WIP-2}. (This is a feature inherited from \cite{FOCS:LPY23} design, though there this observation was superfluous given that there was no call to `decouple' the {\bf WIPoK-2} into an {\bf ExtCom} and a {\bf WIP-2} as we do).
      \item 
      Second, we can now invoke the soundness of the left {\bf WIP-2}---since $\tilde{m}$ and the right puzzle solutions are the only witnesses for the relation {\bf WIP-2} proves, if the committed value in the right $\ExtCom$ is not any of the puzzle solutions (as argued above), then it must be $\tilde{m}$. 
\end{itemize}

It follows that even if we were to remove the {\bf WIP-2} step in our protocol, it would still enjoy a limited form of `non-malleability'---$\mcal{M}$ cannot commit to a left hard puzzle solution {\em even if} the left $C$ does so. Our idea is to leverage this limited `non-malleability' by constructing a {\em limited} version of non-malleable coin-flipping that suffices for our purposes. Specifically, we construct what we call a {\em trapdoor coin-flipping} protocol. This is an augmented coin-flipping protocol between two parties $C$ and $R$ where $C$ additionally commits to some string $x$ before coin-flipping starts. The security guarantee of the actual coin-flipping stage is `controlled' by the committed string $x$ and a predicate $\phi(\cdot)$ given to both parties at the beginning of the coin-flipping stage. In particular, if the committed $x$ satisfies the predicate $\phi(\cdot)$, then by design a committer can `force' the coin-flipping result to a pre-sampled random string $\eta$; but if the committed $x$ does not satisfy the predicate, then no QPT $C^*$ can bias the coin-flipping result. (see \Cref{sec:td-cf} for a formal treatment).

We will use this trapdoor coin-flipping to determine the challenge in {\bf WIP-2}, setting the trapdoor predicate to `{\bf ExtCom} commits to one of the puzzle solutions.' Then for machine $\mcal{K}''_i$, we can enforce the {\bf WIP-2} challenge to $\eta$ in the left execution using the trapdoor predicate (because $C$ does commit to some $j\|x_j$ in the left {\bf ExtCom}). Then, we use the aforementioned `limited non-malleability' guarantee to argue that $\mcal{M}$ cannot force the coin-flipping for the right {\bf WIP-2}, and thus the soundness guarantee of the right {\bf WIP-2} still holds. This obviates the issues raised above. 

Putting everything together, our proof works as follows: 
\begin{itemize}
      \item
      We first use the \cite{FOCS:LPY23} pigeon-hole argument to argue that $\mcal{M}$ cannot commit to any puzzle solutions in the right {\bf ExtCom}. As mentioned above, this step does not make use of the soundness of {\bf WIP-2}.
      \item 
      Since the right {\bf ExtCom} does not commit to any puzzle solution, the soundness of the right {\bf WIP-2} must hold, {\em even if we enforce the coin-flipping step in the left {\bf WIP-2}}. This comes as a guarantee of our trapdoor coin-flipping protocol. Therefore, by the soundness of the right {\bf WIP-2}, the value committed in the right  {\bf ExtCom} must be $\tilde{m}$ (and will be extracted by $\mcal{K}''_i$).
\end{itemize}
As mentioned before, since we pre-sample $\eta$, $R^*$'s communication with the external VSS hiding challenger can be pushed entirely to the prefix phase. So $R^*$ can make use of a `full-fledged' simulation-extractor $\mcal{SE}$ which is built from the new $\mcal{K}''_i$ (indeed, from $\mcal{K}$ that picks a random $i$ and runs $\mcal{K}''_i$ as in \cite{FOCS:LPY23}), to complete the reduction.

\para{Noisy Simulation-Extraction Lemma.} We emphasize that the overview above forms only an intuitive explanation of our ideas. To implement them formally is more challenging as the aforementioned issues appear in a more subtle and technical manner. Owing to the paucity of space, we refer the reader to \Cref{sec:PQNMC:1-1} for fuller details. However, there is a particularly subtle issue unique to our protocol (i.e., not appearing in \cite{FOCS:LPY23}) that we would like to highlight. The above discussion pays much attention to the value committed in $\ExtCom$. In certain steps of our proof, it becomes important to extract this value {\em efficiently}, in order to reduce the security to some {\em falsifiable}\footnote{An assumption is falsifiable \cite{C:Naor03,STOC:GenWic11} if it can be modeled as an interactive game between an {\em efficient} challenger and an adversary, at the conclusion of which the challenger can {\em efficiently} decide whether the adversary won the game.} assumptions. For that we often need to consider the extracted value and take it to be the committed message if it is {\em not} any of the puzzle solutions on the right. As reasoned above, this is the case in all but a noticeable fraction of cases.

However, this indeed starts affecting the conversion from $\mcal{K}$ to $\mcal{SE}$: the simulation-extraction lemma given in \cite{FOCS:LPY23} crucially relies on the fact that the simulation-less extractor $\mcal{K}$ will, if it does not abort, extract a {\em unique} string with good (technically, {\em noticeable}) probability. Put another way, $\mcal{K}$ needs to know that what it extracts is indeed $\tilde{m}$, and if not, it needs to output $\bot$. However, our new $\mcal{K}$ cannot perform such checks---we only argued that $\mcal{K}$ extracts $\tilde{m}$ with noticeable probability. However, it could still be the case with noticeable probability that the extracted value is simply garbage or `noise.' Even worse, $\mcal{K}$ cannot detect this case because the {\bf Step-1} commitment is performed in a black-box commit-and-prove format.\footnote{This issue does not happen in \cite{FOCS:LPY23} because their {\bf Step-1} is Naor's commitment and $\mcal{K}$ extracts the committed value together with the randomness from {\bf WIPok-2}, so that it can check validity using Naor's decommitment algorithm.} Fortunately, we can upgrade the simulation-extraction lemma from \cite{FOCS:LPY23} to tolerate such noise, which suffices for our purpose. We refer to \Cref{sec:simext:1-1} for details.

This finishes the description of our 1-1 non-malleable commitments. The above discussion is based on the `one-sided' (i.e., $t < \tilde{t}$) scheme in the technical overview of \cite{FOCS:LPY23} and thus our protocol inherits this restriction. Fortunately, we can remove this restriction using exactly the same `two-slot' trick (initiated by Pass and Rosen \cite{STOC:PasRos05}) as in \cite{FOCS:LPY23}. We refer to \Cref{sec:two-sided:main-body} for details.

%What I want to say:: hiding just got more complicated. Why? 
% Nature of proof stage: some shares must be revealed. Cannot be standard hiding game. 
% What to do? Devise new hiding game that `mimics' the subsequent proof stage interaction, allowing for a subset of shares corresp. to eta to be revealed by hiding challenger. We show that this is implied by hiding of Com + secrecy guarantees of VSS. 


% \begin{xiaoenv}{Outline}
% Outline for the remaining part:
% \begin{itemize}
%     \item 
%     %Recall BB-Com-n-Prove. Only to the extend that we need. Say that it is a cut-and-choose technique. The receiver needs to send a random subset $\eta$ to check $k$ positions. (you can add a remark that in the real protocol, $\eta$ need to be sampled by a coin-flipping protocol to ensure ZK property. But for this overview, let us ignore that.)
%     \item 
%     %Map our protocol to the BB-Com-n-Prove. Say that the {\bf Step-1} and new {\bf ExtCom} plays the role of the commit stage and the new {\bf WIP-2} plays the role of of the commit stage. 
%     \item 
%     %Thus, the {\bf Step-1} in our protocol is not merely a Naor's com to $m$. Instead, it is a parallel Naor's com to the VSS shares of the underlying $m$. Thus, we need to directly reduce to the hiding (of the committed value) property of the BB-Com-n-Prove protocol.
%     \item 
%     %To do that, we will imagine a malicious $R^*$ that runs the MIM game and forward the Step-1 commitment to the external VSS hiding challenger. Note that $R^*$ needs to specify a challenge set $\eta$. $R^*$ simply wait until the MIM $\mcal{M}$ send $\eta$ in the left-session {\bf WIP-2}, and forward this $\eta$ to the external challenger.
%     \item 
%     %This seems fine if $R^*$ were to run machine $\mcal{K}$ (or $\mcal{K}_i$). 
%     %However, note that in the final reduction to hiding, $R^*$ needs to run the simulation extractor $\mcal{SE}$ that is built out of $\mcal{K}$ using \cite{C:CCLY22} simulation-extraction lemma. In more detail, $\mcal{SE}$ needs to {\em coherently rewind} the post-prefix part of machine $\mcal{K}$. This is problematic: recall that $\mcal{M}$ sends set $\eta$ in {\bf WIP-2}, and this $\eta$ needs to be forwarded to the external VSS hiding challenger, which we can of course not rewind. (Add a footnote: this problem does not appear in the classical setting. There, the machine $\mcal{K}$ does not need to be converted into $\mcal{SE}$, because simulation can be easily achieved by make two copies of the adversary: one for extraction and the other for simulation.)
%     \item 
%     %To resolve this issue, our guiding principle is to make sure that $R^*$'s communication with the external challenger should {\em end before the post-prefix phase of its internal MIM execution starts}.
%     \item 
%     %To do that, our first attempt is to let $R^*$ sample the set $\eta$ by itself. To make sure that $\mcal{M}$ indeed use the same $\eta$ when during the left {\bf WIP-2} stage, we add a coin-flipping protocol to generate the challenges set. The hope is to let $R^*$ use the simulator for the coin-flipping to `enforce' $\mcal{M}$'s challenge set to the $\eta$ it sampled before hand.
%     \item 
%     %However, this simple idea does not work. Recall that we are in the MIM setting. If we enforce $\mcal{M}$'s coin-flipping, it is possible that $\mcal{M}$ could also enforce the coin-flipping result in the right session with $R$, where the soundness guarantee of the right {\bf WIP-2} may not hold anymore. Thus, it seems what we need is a {\em non-malleable} coin-flipping protocol where we can enforce the result in the left session but $\mcal{M}$ cannot. However, this is asking too much because it is known that {\em non-malleable} coin-flipping implies non-malleable commitments, which is our current target. So, it seems to that we are back to square one.
%     \item 
%     %Fortunately, we resolve this issue by taking a non-black-box look into the \cite{C:CCLY22} proof. We have already mentioned that for machine $\mcal{K}''_i$, even if we do not extract from the right {\bf ExtCom}, we can use a similar pigeon-hole argument to show that the value committed there is indeed $\tilde{m}$ with good probability. This actually happens in two steps:
%     \begin{itemize}
%       \item
%       %First,  we can use the \cite{C:CCLY22} pigeon-hole argument to show that even if the left $C$ commits in the left {\bf ExtCom} to some $j\|x_j$ it extracted from the hard puzzle, the $\mcal{M}$ cannot commit to some puzzle solution in the right {\bf ExtCom}. We emphasize that this step does not rely on the soundness of the right {\bf WIP-2}. (This is a feature inherited from \cite{C:CCLY22}, though the authors of \cite{C:CCLY22} may not realize it because they did not `decouple' their {\bf WIPoK-2} into a {\bf ExtCom} and a {\bf WIP-2} as we did).
%       \item 
%       %Second, we invoke the soundness of the left {\bf WIP-2}---Since $\tilde{m}$ and the right puzzle solutions are the only witnesses for the relation {\bf WIP-2} proves, if it is not puzzle solutions (as argued above), then it must be $\tilde{m}$. 
%     \end{itemize}
% %This observation can be translated as follows: Even if we remove the {\bf WIP-2} step in our protocol, it still enjoys a limited feature of `non-malleability'---$\mcal{M}$ cannot commit to a left hard puzzle solution even if the left $C$ does so.  
%     \item 
%     %Our idea is to employ this limited guarantee of `non-malleability' to build an {\em limited} version of non-malleable coin-flipping that suffices for our purpose. 

%     \item 
%     %More accurately, this above observation inspires use to construct a primitive which we call as {\em trapdoor coin-flipping} protocol. This is a coin-flipping protocol between two parties $C$ and $R$ where $C$ additionally commits to some string $x$ before the coin-flipping starts. The security guarantee of the actual coin-flipping stage is `controlled' by the committed string $x$ and a predicate $\phi(\cdot)$ that is given to both party at the beginning of the coin-flipping stage. In particular, if the committed $x$ satisfies the predicate $\phi(\cdot)$, then a committer can `enforce' the coin-flipping result to a pre-sampled random string $\eta$; But if the committed $x$ does not satisfies the predicate, then no QPT $C^*$ can enforce the coin-flipping result.  (see \Cref{sec:td-cf} for a formal treatment).
%     \item 
    
% %We will use this trapdoor coin-flipping to determine the challenge in {\bf WIP-2}, setting the trapdoor predicate to `{\bf ExtCom} commits to one of the puzzle solutions'. Then for machine $\mcal{K}''_i$, we can enforce the {\bf WIP-2} challenge to $\eta$ in the left execution, using the trapdoor predicate (because $C$ does commit to some $j\|x_j$ in the left {\bf ExtCom}). Then, we use the aforementioned `limited non-malleability' guarantee to argue that $\mcal{M}$ cannot enforce the coin-flipping for the right {\bf WIP-2}, and thus the soundness guarantee of the right {\bf WIP-2} still holds. 
%     \item 
%     %Putting everything together, our proof works as follows: 
%     \begin{itemize}
%       \item
%       %We first use the \cite{C:CCLY22} pigeon-hole argument to argue that $\mcal{M}$ cannot commit to any puzzle solutions in the right {\bf ExtCom}. As mentioned above, this step does not make use of the soundness of {\bf WIP-2}.
%       \item 
%      % Since the right {\bf ExtCom} does not commit to any puzzle solution, the soundness of the right {\bf WIP-2} must hold, {\em even if we enforce the coin-flipping step in the left {\bf WIP-2}}. This comes as a guarantee of our trapdoor coin-flipping protocol. Therefore, by the soundness of the right {\bf WIP-2}, the value committed in the right  {\bf ExtCom} must be $\tilde{m}$ (and will be extracted by $\mcal{K}''_i$).
%     \end{itemize}
%     %As mentioned before, since we pre-sample $\eta$, $R^*$'s communication with the external VSS hiding challenger could be all pushed to the prefix phase. So, $R^*$ can make use of an $\mcal{SE}$, which is built from the new $\mcal{K}''_i$ (indeed, a $\mcal{K}$ that picks a random $i$ and runs $\mcal{K}''_i$ as in \cite{C:CCLY22}), to finish the reduction.
    

%     \item 
%     %We emphasize that what is presented above is merely an intuitive explanation of our idea. To implement it formally, the aforementioned issues appear in a more subtle and technical manner. Due to space constraint We refer the reader to \Cref{sec:PQNMC:1-1} for details. But here is a distinguished issue unique to our protocol (but not for the original \cite{FOCS:LPY23}) that we would like to mention. The above discussion keeps talking about the value committed in $\ExtCom$. However, in certain reductions, it is important to extract the value to make a falsifiable argument. For that, we often need to look at this extracted value and take it to be the committed message if it is {\em not} any of the puzzle solutions on the right. As reasoned above, this is the case in all but a noticeable fraction of cases. However, this indeed starts affecting the conversion from $\mcal{K}$ to $\mcal{SE}$: the simulation-extraction lemma given in \cite{FOCS:LPY23} {\em crucially} relies on the fact that the underlying base extractor extracts a {\em unique} string with overwhelming probability. Or putting it in another way, $\mcal{K}$ needs to know what it extracts is indeed $\tilde{m}$, and if not, it should simply output $\bot$. However, our new $\mcal{K}$ cannot perform such checks---We only argued that $\mcal{K}$ extracts $\tilde{m}$ with noticeable probability. However, it could still happen with noticeable probability that the extracted value is simple garbage or `noise'. Even worse, $\mcal{K}$ cannot detect because the Step-1 commitment is performed in a black-box commit-and-prove format.\footnote{This issue does not happen in \cite{FOCS:LPY23} because their Step-1 is Naor's commitment and $\mcal{K}$ extracts the committed value together with the randomness from {\bf WIPok-2}, so that it can check validity using Naor's decommitment algorithm.} Fortunately, we can upgrade the simulation-extraction lemma from \cite{FOCS:LPY23} to tolerate the noise, which suffices for our purpose. We refer to \Cref{sec:simext:1-1} for details.
%     \item 
%     %This finishes the description of our 1-1 non-malleable commitments.


 

% \end{itemize}
% \end{xiaoenv}

% While doing so, we also have to deal with another issue. A careful analysis of the \cite{FOCS:LPY23} template reveals that the {\bf WIPoK} executions served a {\em dual} function, in that in addition to certifying honest behavior by the receiver and prover respectively, they also provided {\em extraction opportunities} that were utilized crucially in the proof of non-malleability. This now becomes a challenge since the `proof' parts of the post-quantum black-box commit-and-prove protocol we use are no longer proofs or arguments of knowledge, i.e., we cannot extract the witness from the proof part. 

% Our main idea in redesigning the protocol (i) makes extensive use of post-quantum {\em extractable} commitments (which allows us to extract the committed value during the proof of non-malleability) that allow us to reclaim extraction opportunities for the puzzle solutions on the left and the committed value on the right, and (ii) make a key design change allowing the puzzle solutions to be revealed {\em before} the committer's consistency proof. In fact, these go hand in hand since without decoupling the proof and extraction components, the revealing of puzzle solutions would be made tricky. We elaborate below.  



% \iffalse 
% The next issue requiring attention is the lack of {\em extraction opportunities} after the above modification. We remarked earlier that, in the \cite{FOCS:LPY23} template, the {\bf WIPoK} executions served a {\em dual} function, in that in addition to certifying honest behavior by the receiver and prover respectively, they also provided {\em extraction opportunities} that were utilized crucially in the proof of non-malleability. As may be expected, we will require such means as well in our modified version of the \cite{FOCS:LPY23} construction. The problem is that the black-box argument system mentioned above is just that---crucially, and unfortunately for our goals, it is not an {\em argument of knowledge} \footnote{more precisely, it does not enjoy the witness-extended emulation guarantee required in the LPY template}. How might one then go about providing such extraction opportunities?

% Our main idea to address this, which can also be called the {\em key} conceptual adaptation of the \cite{FOCS:LPY23} template, is to make judicious use of {\em extractable} commitments in order to provide these opportunities, and adapt the rest of the design of the commitment around this. To be precise, we make the following further modifications. First, the receiver, after performing puzzle setup, uses an extractable commitment to commit to VSS shares of the first puzzle solution $x_1$. This is followed by a black-box argument proving that this extractable commitment is indeed consistent with the earlier puzzle setup step. Second, the committer then uses an extractable commitment to (VSS shares of) a committed value $v$. Third, the receiver then reveals all the puzzle values from its setup. Finally, the committer then proves using a black-box ZK argument that the value $v$ is either (i) the initial commitment value $m$, or (ii) one of the solutions to the puzzles established earlier. In effect, we have used the extractable commitments roughly in place of the {\bf WIPoK}s in the previous template, and {\em deferred} the actual arguments of honest behavior. 
% \fi 

% \para{Our Modified Construction:} To aid the reader, we summarize the modified protocol template for our black-box non-malleable commitment here. To realize a commitment to message $m$ with respect to tag $t$, this proceeds as follows: \rohit{Will add fig}
% \begin{enumerate}
%     \item The committer starts by committing to its intended message $m$ using a black-box compatible commitment (i.e., the `commit' portion of black-box commit and prove). We call this {\bf BBCom}. 
%     \item The receiver acts as follows: 
%     \begin{enumerate}
%         \item It samples $t$ independent and uniform strings $x_1,\dots,x_t$ to use as `hard puzzles', and commits to them using {\bf BBCom}. 
%         \item It then commits to the value $x_1$ using an {\em extractable} version of black-box compatible commitment (this is also available in the black-box commit and prove framework). We call this {\bf BBExtCom}.  
%         \item It then uses the black-box zero knowledge argument {\bf BB-ZKArg} to prove that it committed to one of $x_1,\dots,x_t$ again using {\bf BBExtCom} in the above {\bf Step 2b}, where these values were committed to in {\bf Step 2a}. We title this argument {\bf BB-ZKArg-1} for convenience.  
%     \end{enumerate}
%     \item The committer now commits to the value $v=m$ using {\bf BBExtCom}.  
%     \item The receiver next reveals $x_1,\dots,x_t$ by performing the decommitment to {\bf Step 2a}. 
%     \item The committer then uses {\bf BB-ZKArg} to prove that either (i) the value $v$ committed to in {\bf Step 3} is the the same as that committed to in {\bf Step 1}, namely $m$, or (ii) the committed value $v$ equals one of the puzzle solutions $x_1,\dots,x_t$. We title this argument {\bf BB-ZKArg-2} for convenience. 
% \end{enumerate}

% We claim that this new design is already a black-box construction. For one, the extractable and standard commitments are all made in the black-box commit-and-prove format. Further, crucially, the committer now proves a statement over commmitted values (in {\bf Step 1} and {\bf Step 3}) and public values (namely, the revealed puzzle solutions in {\bf Step 4}). The statement it proves statements are non-cryptographic and can be proved using the black-box ZK argument {\bf BB-ZKArg} (keep in mind that the corresponding commitments are black-box friendly). 

% \para{Black-Box Non-Malleability: Challenges} With a seemingly usable black-box template, we can now turn to considering how to prove non-malleability. 
% Here our strategy will broadly follow the \cite{FOCS:LPY23} one. Namely, we again exhibit a `base extractor' $\mcal{K}$ that is able to extract the committed value $\tilde{m}$ on the right with at least noticeable probability. We then show a new simulatable-extraction lemma that extends $\mcal{K}$ into a simulator-extractor $\SimExt$ that extracts with much higher probability while also being able to $\epsilon$-simulate the post-execution state of $\mcal{M}$. The base extractor $\mcal{K}$ will follow the same strategy as before, by extracting a puzzle solution from {\bf Step 2a} on the left, and then using this as a trapdoor value in {\bf BB-ZKArg-2} on the left, and then finally extracting the committed value within {\bf BBExtCom} in {\bf Step 3} on the right.



% %update 
% %In more detail, we will follow the same strategy as before, by extracting a puzzle solution from {\bf Step 2a} on the left, and then using this as a trapdoor value in {\bf BB-ZKArg-2} on the left, and then finally extracting the committed value within $\ExtCom$ in {\bf Step 3} on the right. This will help us realize an analog of the previous key lemma, showing that we can use an extracted puzzle solution on the left while also managing to extract the committed value on the right with a certain noticeable probability. We will then hope to utilize a similar `extraction amplification' result that will allow us to get a more directly useful extraction gadget and finish the proof essentially the same way as in \cite{FOCS:LPY23}. 


% %, allowing us to change the committed value in the left interaction while guaranteeing that we extract the committed value on the right with at least a certain noticeable probability.  
% While the core intuition for these steps largely remains the same as in the \cite{FOCS:LPY23} template, a couple of new concerns arise because of the introduced modifications that we discuss next. 

% \subpara{A First Challenge:} To start, it is not clear how to actually carry out the reduction to the hiding of the commitment in {\bf Step 1}. While this still satisfies hiding, the difficulty that arises is how we use these commitments in the template. We recall that in MPC-in-the-head based arguments, the verifier asks the prover to open some previously committed views from a virtual MPC execution the prover does, and then inspects them.  In our case, the committer's consistency proof {\bf BB-ZKArg-2} on the left which follows this approach will utilize the initial {\bf BBCom} and then `open' it partially in the course of the argument. However, if we are taking in the initial commitment from an external challenger towards obtaining a reduction to hiding, we run into a clear obstacle as such a reduction needs to open parts of the commitment but has no way to do so. 

% We mitigate this issue using two main changes. We introduce a modified hiding game for {\bf BBCom} that allows for such a partial `opening' of the commitment (this does {\em not} reveal anything about the committed value). With this change our outlined reduction now has the ability to ask the hiding challenger for the partial `opening', obviating the initial concern. However, we must now ensure that the `opening' in the external challenge game corresponds exactly to the one made within {\bf BB-ZKArg-2} (else the reduction is caught out). 

% In the original formulation of {\bf BB-ZKArg} (in \cite{C:CCLY22}), this latter set of revealed views is established via coin tossing. Therefore our desired reduction to hiding must be able to control this set to operate successfully. We achieve this by modifying the coin-tossing step in the consistency argument to be {\em trapdoored}. We perform this coin-tossing as follows: we have the committer commit to its coins for coin-tossing first using {\bf BB-ExtCom}, then reveal these once the receiver sends its own coins. We modify {\bf BB-ZKArg-2} by embedding {\em another} black-box ZK argument execution within it, where the committer now proves that the revealed coins are consistent with the earlier commitment {\em or} that it committed to a puzzle solution earlier. We are in essence reusing the puzzles as a trapdoor which allows us to now also `program' the results of the coin toss step using the puzzle solutions---this dovetails neatly with our approach so far for proving non-malleability. 




% %bespoke variant of the hiding game for commitments we call $\msf{VSS-Hide}$ where the committer now commits to VSS shares of its message, and in the challenge, the committer must reveal some of these shares. Hiding of the messages is intuitively preserved by the secrecy property of the VSS scheme and the hiding of the commitments to the unopened shares. We now design a reduction to $\msf{VSS-Hide}$, where the reduction can now use the externally revealed VSS shares to successfully complete {\bf BB-ZKArg-2} on the left (when the committer is asked to open some of the virtual MPC views). 

% %Of course, we must now ensure that the set of VSS shares revealed in $\msf{VSS-Hide}$ is the {\em same} as the set of views that are required to be opened in the comitter's consistency argument. In the original formulation of {\bf BB-ZKArg} (in \cite{C:CCLY22}), this latter set is established via coin tossing. Therefore our desired reduction to $\msf{VSS-Hide}$ must be able to control this set to operate successfully. We achieve this by modifying the coin-tossing step in the consistency argument to be {\em trapdoored}. We perform this coin-tossing as follows: we have the committer commit to its coins for coin-tossing first, then reveal these once the receiver sends its own coins. We modify {\bf BB-ZKArg-2} by embedding {\em another} black-box ZK argument execution within it, where the committer now proves that the revealed coins are consistent with the earlier commitment {\em or} that it committed to a puzzle solution earlier. We are in essence reusing the puzzles as a trapdoor which allows us to now also `program' the results of the coin toss step using the puzzle solutions---this dovetails nicely with our approach so far for proving non-malleability. 

% %One may however have the following concern: if we take to programming the coin toss step in the consistency argument on the left, can $\mcal{M}$ not do so on the right? This is avoided by our programming mechanism, which relies on using the puzzle solutions as a trapdoor. Even though we have modified the \cite{FOCS:LPY23} template, we can argue similar to their case using a pigeonholing argument that $\mcal{M}$ will still not be able to commit to a puzzle solution on the right. This obviates the above concern, and exhibits yet another advantage in piggybacking off the main trapdoor mechanism. It illustrates again the {\em implicit} non-malleability-like guarantee for the puzzle solutions we can obtain from this design.  

% \subpara{A Second Challenge:} The second technical challenge relates to the extracted value. In the modified template we have decoupled the tasks of extraction and certifying honest behavior. This presents new hurdles: the formalism of the WIPoK used in \cite{FOCS:LPY23} ensures that we can extract the precise witness used in the proof. Due to our modification, we do not directly have the precise guarantee that what we extract indeed satisfies the correct consistency relation. For this, we must rely on the soundness of the consistency proof now comes {\em after} the extractable commitment step. This introduces a discrepancy: the extracted value must satisfy the consistency conditions with high probability by the soundness of the subsequent consistency proof, but this proof is run with the {\em post-simulation} state (after extracting from {\bf BB-ExtCom} in {\bf Step 3} on the right) that is only guaranteed to be $\epsilon$-close to the real execution - hence we cannot make claims about the extracted value satisfying the consistency conditions with {\em overwhelming} probability. We stress that while we still make this approach work, greater care must be taken in doing so as compared to the earlier design, specifically to deal with this kind of discrepancy. %In particular, since we only have $\epsilon$-simulatable extraction for $\ExtCom$ in the post-quantum setting, more careful proofs are required about the consistency or relevance of the extracted value. 

% \para{Noisy Simulation-Extraction:} In particular, we encounter an issue of a new kind as compared to the work of \cite{FOCS:LPY23}. The above discrepancy also arises in extracting from the committer's {\bf BBExtCom} on the right. Recall that this extracted value is a proxy for the committed message on the right. In our analysis, we will look at this value and take it to be the committed message if it is {\em not} any of the puzzle solutions on the right. As reasoned above, this is the case in all but a noticeable fraction of cases. The issue is that this starts affecting the {\em extraction amplification} step: the simulation-extraction lemma given in \cite{FOCS:LPY23} {\em crucially} relies on the fact that the underlying base extractor extracts a {\em unique} string with overwhelming probability. We develop techniques to generalize this to a simulation-extraction lemma for {\em noisy} extraction, where we allow for the extracted value to be garbage or `noise' in a certain noticeable fraction of cases that is controlled by a preset noise parameter. This is the focus of the next subsection.  



\subsection{One-Many Non-Malleability}
\label{sec:overview:NM:1-many}

So far, we have restricted our attention to the 1-1 setting for non-malleability. We now discuss our approach to obtain 1-many non-malleable commitments. Recall that this involves a man-in-the-middle adversary $\mcal{M}$ that runs a single commitment session with an honest committer $C$ on the left, and runs up to polynomially many commitment sessions on the right with honest receivers $R^{(1)},\dots,R^{(N)}$ (where we have used $N$ to denote the total number of right sessions). We stress that 1-1 non-malleability does not directly imply 1-many non-malleability; this is a known barrier even in the classical setting and we elide further explanation for the sake of conciseness.  

In spite of this, we are able to demonstrate that the same black-box construction we described above also enjoys 1-many non-malleability. In fact, we rely for the most part on very similar strategies to those we employed in the 1-1 case. The key similarity we exploit is that in the reduction to hiding that we outlined in the 1-1 case (that formed the base of our proof), the majority of the modifications we make are with respect to the {\em left} session---the only changes made on the right are changing which puzzle solution is committed to in {\bf ExtCom} by the honest receiver, and {\em extracting} the committed value. We can thus hope to translate our technique to the 1-many setting as well. % In fact, we do so almost exactly. 
At a high level, we accomplish this in three steps: 

\para{Step 1.} First, we design analogs of the simulation-less extractor $\mcal{K}$ from earlier, that we call {\em localized} simulation-less extractors $\mcal{K}^{(j)}$ (for $j \in [N]$). $\mcal{K}^{(j)}$ performs extraction only in the $j$-th right session, and acts as an honest receiver in all other right sessions. It is not hard to establish the same guarantees for {\em each} $\mcal{K}^{(j)}$ from the guarantees for $\mcal{K}$ in the 1-1 setting, by means of a `wrapper' reduction: namely, since the other right sessions of $\mcal{M}$ are run honestly, we can run the 1-many interaction internally while treating the $j$-th session as the sole right session in a 1-1 MIM interaction, and handling all the other internal right sessions by itself. 

\para{Step 2.}  Next, we show how to build a {\em simultaneous} simulation-less extractor that is then able to extract the committed values in {\em all} right sessions with high success (but without any simulation guarantees). This step turns out to be particularly challenging due to the quantum nature of the MIM adversary $\mcal{M}$. Note that the instanced extractors $\mcal{K}^{(j)}$'s described above enjoys extractability only for a single run. If we want to perform simultaneous extraction, the natural attempt of running them one-by-one does not work---after the execution of, say, $\mcal{K}^{(1)}$, the internal quantum state of $\mcal{M}$ may have already been disturbed too much to support the execution of $\mcal{K}^{(2)}$. 

    Another natural idea is to first convert $\mcal{K}^{(1)}$ to a simulatable extractor, using the above noisy simulation-extraction lemma, and hope that the simulation guarantees of that lemma can `protect' the state of $\mcal{M}$ after the execution of $\mcal{K}^{(1)}$ so that we can keep running $\mcal{K}^{(2)}$ (and also convert $\mcal{K}^{(2)}$ to a simulatable extractror to support $\mcal{K}^{(3)}$ and so on). Unfortunately, this idea does not work either due to a subtle technical reason: The simulation guarantees of the noisy simulation-extraction lemma is for the {\em post-extraction} extraction state of $\mcal{M}$, which means it simulates $\mcal{M}$'s state at the end (or `bottom') of the protocol; However, to be able to run $\mcal{K}^{(2)}$ right after $\mcal{K}^{(1)}$, we have to simulates $\mcal{M}$'s state at the beginning (or `top') of the protocol! Thus, new ideas are needed to resolve this problem.

    We tackle this problem by crafting a novel {\em simultaneous} post-quantum extraction lemma, drawing upon the measure-and-repair technique introduced in \cite{TCC:Zhandry20,FOCS:CMSZ21}. This represents another main technical contribution of this work and it may find future applications where simultaneous post-quantum extraction is needed. We provide an overview of it in \Cref{sec:simultaneous-ext:overview}. 



\para{Step 3.}  Finally, we show that the same noisy simulation-extraction lemma described above can be used to upgrade this simultaneous simulation-less extractor to one {\em with simulation}, and thus finish the proof of non-malleability with a similar reduction to the VSS hiding game as in the 1-1 case.

    



