%!TEX root = ../main.tex
\subsection{Simultaneous Extraction}
\label{sec:simultaneous-ext:overview}

We now provide a brief overview of our simultaneous extraction lemma as mentioned above. We will use slightly different notation. In the following description, machines $\mcal{K}_1, \ldots,\mcal{K}_n$ play the role of our instanced simulation-less extractor $\mcal{K}^{(1)}, \ldots, \mcal{K}^{(N)}$ mentioned above (setting $n = N$). And $\mcal{V}$ is a machine that should be treated as enforcing the condition that we start from a `good' prefix (i.e., the {\bf Step-1} Naor's commitment in the VSS form). It is necessary because as we mentioned earlier, we cannot hope to extract $\tilde{m}$'s with good probability if $\mcal{M}$ always aborts the execution before it naturally ends. The machine $\mcal{K}$ is our desired simultaneous simulation-less extractor.

% In the proof of non-malleability in the one-many setting, we need to construct an extractor that extracts the committed messages in all the right sessions. Our extraction technique ensures that we can extract the committed message in any of the right sessions, but it is unclear if we can extract it in all the right sessions simultaneously since the extractor may damage the adversary's internal state, which may hinder extraction in another session. \takashi{I'm not sure if this explanation is appropriate because I don't fully understand the context.} 
% To deal with this issue, we show a lemma which we call the simultaneous extraction lemma. 
% Below, we provide its description with some simplifications that do not affect the underlying ideas.

\begin{lemma}[Simultaneous extraction lemma (informal)]
Let $\mcal{V}$ and $\mcal{K}_1, \ldots,\mcal{K}_n$ be QPT algorithms for a polynomial $n$ that satisfy the following: 
\begin{itemize}
    \item {\bf $\mcal{V}$'s syntax:} $\mcal{V}$ takes a quantum state in Hilbert space $\mcal{H}$ and outputs $\top$ or $\bot$; 
    \item {\bf $\mcal{K}_i$'s syntax:} $\mcal{K}_i$ takes a quantum state in Hilbert space $\mcal{H}$ and outputs a classical string $s_i$ or $\bot$;
    \item {\bf Uniqueness of $\mcal{K}_i$'s output:} 
    For each $i\in [n]$, there is a classical string $s_i^*$ such that $\mcal{K}_i$'s output is either $s_i^*$ or $\bot$ on any input;\footnote{The formal version of this lemma (see \Cref{lem:Simultaneous-SimExt}) permits the outputs of $\mathcal{K}_i$ to be other `noise' values, provided that the probability of this occurrence can be bounded by a noticeable function. This is essential for compatibility with the previously described noisy simulation-extraction lemma. However, for this overview, we overlook this detail to maintain focus on the main idea.} 
    \item {\bf ``Good" states for $\mcal{V}$ is also ``good" for $\mcal{K}_i$:}  
    For any noticeable $\gamma$, there is noticeable $\delta$ such that for any quantum state $\rho$, if 
    $$
    \Pr[\mcal{V}(\rho)=\top]\ge \gamma,
    $$
    then 
     $$
    \Pr[\mcal{K}_i(\rho)=s_i^*]\ge \delta.
    $$
\end{itemize}
Then there is a QPT algorithm $\mcal{K}$ (called a simultaneous extractor) satisfying the following:
\begin{itemize}
\item {\bf $\mcal{K}$'s syntax:} $\mcal{K}$ takes a quantum state in Hilbert space $\mcal{H}$ and outputs $n$ classical strings $(s_1,s_2, \ldots,s_n)$ or $\bot$; 
\item  {\bf Uniqueness of $\mcal{K}$'s output:}  $\mcal{K}$'s output is either $(s_1^*,s_2^*, \ldots,s_n^*)$ or $\bot$ on any input; 
\item {\bf ``Good" states for $\mcal{V}$ is also ``good" for $\mcal{K}$:}  
For any noticeable $\gamma$, there is noticeable $\delta'$ such that for any quantum state $\rho$, if 
  $$
    \Pr[\mcal{V}(\rho)=\top]\ge 8\gamma,\footnote{An arbitrary constant factor larger than $1$ suffices, but we choose $8$ to match the formal version of the lemma.}
    $$
    then 
     $$
    \Pr[\mcal{K}(\rho)=(s_1^*,s_2^*, \ldots,s_n^*)]\ge \delta'.
    $$
\end{itemize} 
\end{lemma}

If the input $\rho$ is classical, then the above lemma trivially holds: $\mcal{K}$ can simply run each $\mcal{K}_i$ many times until it succeeds. However, if $\rho$ is quantum, the state may collapse once we run $\mcal{K}_i$ for some $i$, which prevents us from running it on the same state again. To resolve the issue, our idea is to use the ``state repairing" technique introduced in \cite{FOCS:CMSZ21}. 
To explain their technique, we first review the concept of (approximate) projective implementation introduced by Zhandry \cite{TCC:Zhandry20}. 
%Very roughly speaking, the technique enables the following: 
%Roughly, the technique is described as follows: 
Let $\{(\Pi_i,I-\Pi_i)\}_i$ be a family of binary-outcome projective measurements %over a Hilbert space $\mcal{H}$  
indexed by a classical index $i$ of a certain length. 
%where $\Pi_r$ and $I-\Pi_r$ are associated with outcomes $1$ and $0$, respectively. 
Consider the ``mixture" $M$ of  $\{(\Pi_i,I-\Pi_i)\}_i$, i.e., the procedure that first randomly samples $i$ and then applies the projective measurement  $(\Pi_i,I-\Pi_i)$.  
Zhandry showed the existence of ``projective implementation" $\mathsf{ProjImp}$ of $M$, which is a real-valued projective measurement that ``measures" the success probability of $M$, i.e., for any state $\rho$, the distribution of applying $M$ on $\rho$ is identical to first applying $\mathsf{ProjImp}$ on $\rho$ to obtain $p\in [0,1]$ and then outputting $1$ with probability $p$. 
Though it is unknown how to efficiently implement $\mathsf{ProjImp}$, Zhandry gave an efficient procedure called $\mathsf{API}$ (``Approximate Projective Implementation") that approximates $\mathsf{ProjImp}$ in an appropriate sense. 
Now, we are ready to describe the state repairing technique of \cite{FOCS:CMSZ21}. 
Suppose that we apply $\mathsf{API}$ on some state, which yields an outcome $p$, and then apply $M$.  
At this point, there is no guarantee on the outcome if we apply $\mathsf{API}$ again.  
The work \cite{FOCS:CMSZ21} constructed an efficient state repairing procedure $\mathsf{Repair}$ which acts on the post-execution state so that the output of $\mathsf{API}$ on the resulting state is at least $p-\epsilon$ with overwhelming probability for an arbitrary noticeable function $\epsilon$. 

Our idea is to apply their technique in our context as follows. We consider a family $\{(\Pi_i,I-\Pi_i)\}_{i\in[n]}$ where $\Pi_i$ corresponds to the event that $\mcal{K}_i$ successfully extracts $s_i^*$ and $\mathsf{API}$ that approximates the probability that $\mcal{V}$ returns $\top$. 
If the initial state is accepted with probability sufficiently larger than $\gamma$ and $\epsilon$ is set to be sufficiently small,  
then if we alternately apply $(\Pi_i,I-\Pi_i)$ (i.e., run $\mcal{K}_i$)  and the state repair procedure, we can guarantee that each application of  $(\Pi_i,I-\Pi_i)$ results in the first outcome, which corresponds to successfully extracting $s_i^*$, with probability at least $\delta$. 
Thus, we can simultaneously extract $s_1^*, \ldots,s_n^*$ if we repeat the above sufficiently many times.  
Though we eventually prove that this idea works, this is not a direct application of the result of \cite{FOCS:CMSZ21} since the situation is somewhat different. 
In particular, we have to make sure that 
\begin{itemize}
\item we can construct $\mathsf{API}$ for any binary-outcome POVMs (that correspond to the success of $\mcal{V}$), and 
\item the state repairing procedure still works even if $\mathsf{API}$ is defined for a binary-outcome POVM that is irrelevant to the projections $\{(\Pi_i,I-\Pi_i)\}_{i\in[n]}$. 
\end{itemize}
First, we observe that the second point is actually not an issue since this is techncially already proven in \cite{FOCS:CMSZ21}. 
That is, even though they only apply their technique in the setting where $\mathsf{API}$ is defined for the mixture of projections, their core technical lemma~\cite[Lemma 4.10]{FOCS:CMSZ21} already captures the situation where $\mathsf{API}$ is irrelevant to those projections. 
For the first point, though Zhandry showed that an (inefficient) projective implementation can be defined for any binary-outcome POVMs, he did not show how to efficiently approximate it.  
Thus, we give a construction of $\mathsf{API}$ for any binary-outcome POVMs (that correspond to the success of $\mcal{V}$), which generalizes Zhandry's construction. 
The construction and its analysis are similar to Zhandry's original one for the case of mixtures of projective measurements 
while we rely on Jordan's lemma as an additional tool.\footnote{\cite{FOCS:CMSZ21} also gives a variant of Zhandry's $\mathsf{API}$ by using Jordan's lemma, but they also only consider mixtures of projective measurements.}  


%Suppose that $\rho$ is ``good" w.r.t. the ``mixture" of $\{\Pi_r\}$, i.e., it belongs to a certain subspace in which 
%Given a good state 
%They consider the following situation: 
%\begin{itemize}
%\item Let $\{\Pi_r\}$ be a family of projections indexed by a classical string $r$ of a certain length.
%\item There is a way to 
%\end{itemize}


\subsection{Black-Box Post-Quantum 2PC and MPC with Full Simulation}
\label{sec:overview:full-MPC}

We begin by recalling the framework established in \cite{C:CCLY22}, which was devised originally for constant-round black-box PQ-2PC {\em with $\epsilon$-simulation}.

A key component of the \cite{C:CCLY22} framework is a black-box extractable commit-and-prove protocol with $\epsilon$-simulation, which we refer to as ``$\epsilon$-ExtCom-n-Prove'' henceforth. This primitive enables a committer to commit to a message $m$ during the {\em Commit Stage} and subsequently prove, with $\epsilon$-zero-knowledge, that the committed $m$ satisfies a predicate $\phi$ during the {\em Prove Stage}. Furthermore, the Commit Stage itself functions as a post-quantum extractable commitment with $\epsilon$-simulation, meaning that the post-extraction state of the malicious committer is $\epsilon$-indistinguishable from that in the real execution. It is worth noting that the symbol $\epsilon$ in the name ``$\epsilon$-ExtCom-n-Prove'' indicates that both the zero-knowledge property of the Prove Stage and the post-extraction simulation of the Commit Stage are defined with $\epsilon$-simulation.


We note that \cite{C:CCLY22} can be interpreted as a compiler that transforms a $O(k)$-round black-box ExtCom-n-Prove protocol into a $O(k)$-round black-box PQ-2PC protocol; moreover, if the ExtCom-n-Prove protocol is defined with $\epsilon$-simulation (resp.\  full simulation), then the resulting PQ-2PC protocol would be $\epsilon$-simulatable (resp.\ fully simulatable). This observation is formalized in \Cref{sec:full-MPC:2PC}. Consequently, our goal of constructing $\omega(1)$-round black-box PQ-2PC can be simplified to the task of building $\omega(1)$-round black-box ExtCom-n-Prove protocols with full simulation.


\para{Post-Quantum Extractable Batch Commitments.} We further observe that in order to build the desired ExtCom-n-Prove protocols, it (almost) \takashi{I added "almost". I'm not sure if this is nice, but without this, this sentence is a little bit inaccurate.} suffices to develop black-box $\omega(1)$-round post-quantum extractable commitments. In this overview, we do not delve into the explanation of why this is true (refer to \Cref{sec:bb-extcom-n-prove} for details). %However, we emphasize the necessity for the extractable commitments to possess a property akin to ``selective-opening security.''
More precisely, what we require and refer to as {\em post-quantum extractable batch commitments} is as follows: The committer is able to commit to a vector of messages $\vb{m} = (m_1, \ldots, m_n)$ {\em collectively}. The commitment can be decommited locally on each index $i\in [n]$. 
We require the following security to hold: 

\begin{description}
\item{\bf Hiding} 
For any index $i^* \in [n]$, $m_{i^*}$ remains concealed even if the adversary is given $m_i$ and the corresponding decommitment information for all $i\neq i^*$. 
In particular, this implies that for any subset $I\subseteq [n]$, the messages corresponding to indices in $I$ remain concealed even if the adversary is given $m_i$ and the corresponding decommitment information for all $i\notin I$.\footnote{This may look similar to {\em selective-opening security} \cite{JC:Hofheinz11}, but we remark that we only require the hiding when $I$ is fixed at the beginning 
whereas selective-opening security in \cite{JC:Hofheinz11} allows the adversary to adaptively choose $I$ depending on the commitment.} 

\item{\bf Extractability}
There exists a QPT machine $\mathcal{SE}$ (dubbed the {\em simulation extractor}) capable of extracting the committed vector message $\vb{m}^* = (m^*_1, \ldots, m^*_n)$ from the malicious committer $C^*$, while simultaneously (fully) simulating $C^*$'s post-extraction state to be negligibly close to that in the real execution between $C^*$ and the honest receiver. 
\end{description} 
We remark that if we only consider the hiding and binding (rather than extractability), then a simple parallel composition of a stand-alone commitment scheme would suffice. 
However, extractability may not be preserved under parallel composition, and this is why we need to introduce the above notion of extractable batch commitments. 



\if0
\begin{enumerate}
\item 
The committer is able to commit to a vector of messages $\vb{m} = (m_1, \ldots, m_n)$ {\em collectively}. Later, the receiver has the authority to specify an arbitrary subset of positions $I \subset [n]$, prompting the committer to decommit to message $m_i$ for each $i \in I$. Meanwhile, the messages corresponding to indices in $[n] \setminus I$ must remain concealed from the receiver.

\item
There exists a QPT machine $\mathcal{SE}$ (dubbed the {\em simulation extractor}) capable of extracting the committed vector message $\vb{m}^* = (m^*_1, \ldots, m^*_n)$ from the malicious committer $C^*$, while simultaneously (fully) simulating $C^*$'s post-extraction state to be negligibly close to that in the real execution between $C^*$ and the honest receiver. 
\end{enumerate} 
We remark that although the properties outlined above look like a {\em selective-opening secure} commitment (see, e.g., \cite{JC:Hofheinz11}) with post-quantum simulatable extractability, it is indeed different from the latter. In the definition of selective opening security, $n$ independent repetitions of a given commitment scheme are executed, with the $i$-th repetition committing to message $m_i$. In contrast, the extractable batch commitment described above commits to all elements in $(m_1, \ldots, m_n)$ ``at one stroke,'' i.e., in only one session between the committer and receiver, rather than $n$ sessions. Hence, we avoid using the term ``selective-opening'' and instead refer to it as ``batch commitment.''
\fi

We manage to build a black-box $\omega(1)$-round construction for such a post-quantum extractable batch commitment, assuming the existence of post-quantum semi-honest oblivious transfer. We provide an overview of this construction in \Cref{sec:overview:PQBExtCom}. For now, we simply remark that this commitment scheme leads to a black-box $\omega(1)$-round construction of ExtCom-n-prove (with full simulation), which, as discussed earlier, results in the first black-box $\omega(1)$-round PQ-2PC (with full simulation) from the minimal assumption of post-quantum semi-honest oblivious transfers.



\para{Extension to the Multi-Party Setting.} Note that the above results for PQ-2PC imply, in particular, a black-box $\omega(1)$-round construction of post-quantum oblivious transfers (maliciously secure, with full simulation). Utilizing a known compiler from \cite{C:IshPraSah08}, such an oblivious transfer protocol can be converted into a black-box PQ-MPC (with full simulation), where the round complexity is polynomial in the number of parties (and consequently polynomial in the security parameter $\secpar$). We refer to \Cref{sec:full-MPC} for details.




\subsection{Post-Quantum Extractable Batch Commitments}
\label{sec:overview:PQBExtCom}

We now provide an overview of our $\omega(1)$-round construction of post-quantum extractable batch commitments (with full simulation), which only makes black-box use of a constant-round post-quantum semi-honest OT. Since all the primitives in the sequel is post-quantum, we henceforth drop the the quantifier ``post-quantum'' for succinctness.


We start by describing a protocol that only supports committing to vectors $\vb{m}$ of length 1. In this case, the notion of extractable batch commitment degenerates to standard extractable commitments (with full simulation). We emphasize that even such a commitment is previously unknown, if one insists on black-box constructions. Our construction can be divided into the following three steps. 
\begin{enumerate}
\item Construct $\omega(1)$-round \emph{equivocal} commitments with full simulation based on OWFs. Here, equivocality means that one can simulate the commit stage for malicious receivers in such a way that the commitment can be opened to an arbitrary message in the reveal stage. There are well-known classical black-box constructions of equivocal commitments from OWFs \cite{STOC:Kilian88,FOCS:Kilian94,TCC:PasWee09}, which are later adapted into the post-quantum setting \cite{C:BCKM21b}. Though those constructions are $O(\secpar)$-round, we observe that they can be easily optimized to $\omega(1)$ rounds.
\item 
Convert equivocal commitments into extractable commitments with a weaker security guarantee which we call \emph{extractability with over-extraction}. It is similar to the standard extractability (with full simulation) except that we allow the extractor to extract a non-$\bot$ message even if the commitment is ill-formed (i.e., there is no valid opening to any message).  In fact, we show that our protocol supports (a certain form of) \emph{parallel} extraction with over-extraction, which we elaborate on later. 
%Similar to the standard extractability, it requires the extractor to extract the committed message and to simulate the sender's state, but the difference is that the extracted message may be arbitrary when the commitment is ill-formed (i.e., there is no valid opening to any message). 
The conversion incurs a constant-round overhead and makes black-box use of constant-round $\epsilon$-simulatable parallel OT, which in turn is constructed from a constant-round \emph{semi-honest} OT in a black-box manner in \cite{C:CCLY22}. We stress that the resulting (parallel) extractable commitment protocol with over-extraction supports full simulation even though the base OT only supports $\epsilon$-simulation. Since this step is the technical core of our construction of extractable commitments, we will provide more details shortly.  
\item Eliminate over-extraction with a $\omega(1)$-round overhead based on OWFs using a standard cut-and-choose technique. Roughly, the commit stage of the protocol works as follows: The committer generates VSS shares of the message $m$ and commits to each share using an extractable commitment scheme with over-extraction in parallel. Then the committer and receiver  execute coin-flipping to agree on a subset on which the committer reveals the committed shares along with the corresponding decommitment information. 
If all of the decommitments are valid, then the receiver is convinced that a large-fraction of the unrevealed commitments is likely to be well-formed (i.e., has a valid decommitment). Then the transcript of the commit stage is well-formed whenever the receiver accepts (except for a negligible probability). In this case, the simulation-extractor can figure out whether the commitment is well-formed by itself and thus over-extraction never occurs. We remark that we only need the coin-flipping protocol to be simulatable against one malicious party (i.e., the role played by the receiver in the commitment protocol), which can be constructed from any equivocal commitments with a constant-round overhead. Since the first step gives $\omega(1)$-round equivocal commitments from OWFs, the overall overhead of round-complexity in this step is just $\omega(1)$. 
\end{enumerate}

Below, we give more details of the second step. 
First, we explain how to achieve extractability with over-extraction in the stand-alone setting (where there is no parallel execution). Our construction works as follows: 

\noindent\textbf{Commit stage.} 
\begin{enumerate}
\item \label[Step]{abstract_ExtCom_1}
The committer $C$ commits to the message $m$ using Naor's commitment. 
\item \label[Step]{abstract_ExtCom_2}
$C$ generates $2k$-out-of-$2k$ secret sharing $\{s_{j}^{b}\}_{j\in [k],b\in\bit}$ of $m$ where $k=\omega(\log \secpar)$. That is, they are uniformly random under the constraint that $\bigoplus_{j\in[k],b\in\bit} s_j^b=m$.  
\item \label[Step]{abstract_ExtCom_3}
$C$ and the receiver $R$ execute $k$-parallel execution of $\epsilon$-simulatable OT where in the $j$-th execution $C$ uses $(s_j^0,s_j^1)$ as input and $R$ uses an independently random bit $r_j$ as input.  
\item \label[Step]{abstract_ExtCom_4}
$C$  and $R$ engage in the following coin-flipping subprotocol to agree on $t\in \bit^k$:
\begin{enumerate}
\item \label[Step]{abstract_ExtCom_4a}
$R$ samples a random string $t_R\gets \bit^k$ and commits to it using the equivocal commitment scheme. 
\item \label[Step]{abstract_ExtCom_4b}
$C$ samples a random string $t_C\gets \bit^k$ and sends it to $C$.
\item \label[Step]{abstract_ExtCom_4c}
$R$ sends to $C$ the value $t_R$ together with the corresponding decommitment information. 
At this point, $C$ and $R$ agree on $t\coloneqq t_R \oplus t_C$. 
\end{enumerate}
\item \label[Step]{abstract_ExtCom_5}
$C$ sends $s_j^{t_j}$ for $j\in [k]$ where $t_j$ is the $j$-th bit of $t$. 
\end{enumerate}

\noindent\textbf{Decommit stage.} 
$C$ sends all the randomness used during the commitment stage as decommitment information, and $R$ accepts if it is consistent to the transcript. 

\smallskip
The statistical binding property of the above protocol follows straightforwardly from that of Naor's commitment. 
The computational hiding property can be shown as follows: Since the OT satisfies $\epsilon$-simulatable security, for any malicious receiver $R^*$, we can simulate the execution of the OT in \Cref{abstract_ExtCom_3} only using $\{s_j^{r^*_j}\}_{j\in [k]}$ for some sequence $\{r^*_j\}_{j\in [k]}$ of bits 
with a noticeable simulation error $\epsilon$. 
Since $\{s_j^b\}_{j\in [k],b\in\bit}$ is $2k$-out-of-$2k$ secret sharing of $m$, $R^*$ cannot learn any information of $m$ unless $t_j$ happens to be $1-r^*_j$ for all $j\in [k]$. However, by the binding property of the equivocal commitment scheme, $R^*$ can cause only a negligible bias on the distribution of $t$. Thus, the probability that $t_j=1-r^*_j$  for all $j\in [k]$ is $2^{-k}+\negl(\secpar)=\negl(\secpar)$.  
The above argument implies that $R^*$ can distinguish commitments to different messages with advantage at most $\epsilon+\negl(\secpar)$. Here, $\epsilon$ can be any noticeable function in $\secpar$, and thus this actually implies the standard computational hiding. 
%, i.e., $R^*$ can distinguish commitments to different messages only with a negligible advantage. 

Below, we give a proof sketch for extractability with over-extraction. We construct the simulation extractor as follows:
\begin{itemize}
\item Execute  \Cref{abstract_ExtCom_1,abstract_ExtCom_2,abstract_ExtCom_3} of the commit stage with the malicious committer $C^*$ while playing the role of the honest receiver. At this point, the simulation extractor obtains $\{s_j^{r_j}\}_{j\in[k]}$ for some random bits $r_j$. 
\item Use equivocality to simulate the commit stage of the equivocal commitment scheme in \Cref{abstract_ExtCom_4a}.  
\item Receive $t_C$ from $C^*$ in \Cref{abstract_ExtCom_4b}.  
\item Set $t\coloneqq (1-r_1)||(1-r_2)||...||(1-r_k)$ and $t_R \coloneqq t_C\oplus t$. Then open the equvocal commitment in \Cref{abstract_ExtCom_4a} to $t_R$. 
\item Receive $\{s_j^{t_j}=s_j^{1-r_j}\}_{j\in [k]}$ from $C^*$ in \Cref{abstract_ExtCom_5}. 
\item Output the final state of $C^*$ along with the extracted message $m\coloneqq \bigoplus_{j\in[k],b\in\bit} s_j^b$.
\end{itemize}

It is straightforward to see that the extracted message is equal to the committed message assuming that the transcript is well-formed, i.e., it has a valid opening to some message. Indeed, since the committer is required to reveal all the randomness in the decommit stage, to generate a well-formed transcript, a malicious sender has to follow the protocol albeit with a possibly skewed randomness distribution. In this case, the simulation extractor obtains half of the shares as the output of the OT by the perfect completeness of the OT, and the rest of the shares in the final step. 
Since the simulation extractor obtains all the secret shares of $m$, it recovers the correct committed message. 

Moreover, we can see that the simulated state of $C^*$ is computationally indistinguishable from the real one (regardless of whether the transcript is well-formed) as follows. We observe that the only difference between the real and simulated execution is that the result $t$ of the coin-flipping is programmed to be $(1-r_1)||(1-r_2)||...||(1-r_k)$ by using equivocality. Though the bits $r_1,...,r_k$ are also used as the receiver's inputs of the OT,  $\epsilon$-simulatable security of the OT against malicious senders ensure that they are computationally hidden from the view of the malicious committer.\footnote{We rely on a well-known fact that $\epsilon$-simulatable security implies indistinguishability-based security.} Thus, $t_R=t_C\oplus t$ is indistinguishable from uniformly random from the view of the malicious committer. Then we can reduce the indistinguishability between the real and simulated execution to equivocality of the equivocal commitment scheme.  

\para{Extractable Batch Commitments.} The remaining issue is how to achieve parallel extraction. If we have parallel equivocal commitments, then the above simulation extractor readily extends to the parallel setting. However, the problem is that we do not know how to achieve parallel equivocality in $\omega(1)$ rounds. To circumvent this issue, we change the syntax of the commitment protocol in the parallel setting. That is, instead of considering parallel execution of many copies of the same protocol, we consider a protocol where the committer commits to multiple messages at once, and we require the simulation extractor to extract all the committed messages. In this setting, we can use a single execution of coin-flipping subprotocol to generate the coins (i.e., $t$ in the above protocol) for all the sessions at once. This completely resolves the problem since now there is no parallel execution of the equivocal commitment scheme. In the actual proof, we formalize commitments with such modified syntax as \emph{batch} commitments (see \Cref{def:bcom}) and show that all the remaining steps work with this definition.   

