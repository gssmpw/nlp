%!TEX root = ../main.tex
\section{Post-Quantum Equivocal Commitments} \takashi{I separated this section because it would be confusing if we talk about equivocal commitments after introducing batch commitments since equivocality is only defined for stand-alone commitments and not for batch commitments.}
Here, we define equivocal commitments and 
construct an $\omega(1)$-round equivocal commitment scheme from OWFs. Looking ahead, this is used as a building block for constructing fully-simulatable (rather than $\epsilon$-simulatable) extractable (batch) commitments in \Cref{sec:ExtCom-from-OT}.  
%with over-extraction in \Cref{sec:construction_OverExtBCom}.  

\subsection{Definition}
The definition of equivocality is given below.  
We stress that we require the simulation error to be negligible since this is used for achieving extractability with negligible simulation errors. 
%We stress that we define equivocality for stand-alone commitments (as per \Cref{{def:com}}) rather than for batch commitments. 
\begin{definition}[PQ-EqCom]\label{def:eqcom}
A post-quantum commitment scheme $\langle C, R\rangle$ (as per \Cref{def:com}) is {\em equivocal} if there exists a QPT algorithm $\SimEq=(\SimEq_0,\SimEq_1)$ (called the simulation equivocator) such that for any non-uniform QPT $R^*(\rho)$ and any polynomial $\ell(\cdot)$, 
\begin{align*}
   &\left\{
   (\ST_{R^*},\decom):
   \begin{array}{ll}
   (\ST_{R^*},\ST_{\SimEq})\gets \SimEq_0^{R^*(\rho)}(1^\secpar)\\
   \decom\gets \SimEq_1(\ST_{\SimEq},m)
   \end{array}
   \right\}_{\secpar\in \mathbb{N},m\in \bits^{\ell(\secpar)}}\\
   \cind
    &\left\{
    (\ST_{R^*},\decom):
    \begin{array}{ll}
    (\tau,\ST_{C},\ST_{R^*})\gets \langle C(m),R^*(\rho) \rangle(1^\secpar)\\
    \decom \gets C(\ST_C)
    \end{array}
    \right\}_{\secpar\in \mathbb{N},m\in \bits^{\ell(\secpar)}}
\end{align*}
\end{definition} 
%It is proven in \cite{C:BCKM21b} that post-quantum OWFs imply (post-quantum) equivocal commitments for single bit messages in $\secpar$ round. 
%We extend their construction to support multi-bit messages in $\omega(1)$ rounds.

The main theorem we prove in this section is the following: 
\begin{theorem}\label{thm:eqcom}
Assuming the existence of post-quantum OWFs, there is a black-box construction of $\omega(1)$-round equivocal commitment schemes.\footnote{Formally speaking, this means that for any time-constructible function $r(\cdot)=\omega(\secpar)$, 
there is a $r(\secpar)$-round equivocal commitment scheme. We use a similar convention throughout the paper.}  \takashi{Are you okay with this convention?}
\end{theorem}


\subsection{Construction with Noticeable Binding Error}
For the ease of presentation, we start by constructing a \emph{constant-round} equivocal commitment scheme $\wEqCom$ that has a noticeable binding error. 
Later, we argue that $\omega(1)$-times sequential repetition of $\wEqCom$ achieves negligible soundness error while preserving the equivocality. The construction is based on the ideas of \cite{STOC:Kilian88,FOCS:Kilian94}, which have been used in many later works, e.g., \cite{TCC:PasWee09,C:BCKM21b}.  
 The scheme $\wEqCom$ is described in \Cref{protocol:wEqCom} where it
 makes black-box use of a constant-round statistically-binding and computationally-hiding commitment scheme $\Com$ (e.g., Naor's commitment).  

\begin{ProtocolBox}[label={protocol:wEqCom}]{Equivocal Commitments with Noticeable Soundness Error $\wEqCom$}
{\bf Parameters:} Let $k=\Theta(\log \secpar)$ be a positive integer.

{\bf Inputs:} Both parties receive $\secpar$ as the common input. The committer in addition gets a string $m\in \bits^{\ell(\secpar)}$ as its private input where $\ell(\cdot)$ is a polynomial.
For each $i\in [\ell]$, $m_i$ denotes the $i$-th bit of $m$.  


\para{Commit Stage:} 
\begin{enumerate}
\item 
$C$ picks uniformly random bits $r_{i,j}$ 
and defines
\begin{align*}
\begin{pmatrix*}[r]
s^{00}_{i,j} & ~~~s^{01}_{i,j} \\
s^{10}_{i,j} & ~~~s^{11}_{i,j} \\
\end{pmatrix*}
=
\begin{pmatrix}
r_{i,j} & ~~~m_i\oplus r_{i,j} \\
r_{i,j} & ~~~m_i\oplus r_{i,j} \\
\end{pmatrix}
\end{align*}
for 
$i\in [\ell]$ and $j\in [k]$. 
\item \label[Step]{wEqCom:Com}
$C$ commits to $\{s_{i,j}^{ab}\}_{i\in [\ell],j\in[k],(a,b)\in\bits^2}$ using $\Com$ in a bit-by-bit manner in parallel.  
Let $\{\tau_{i,j}^{ab}\}_{i\in [\ell],j\in[k],(a,b)\in\bits^2}$ be the corresponding transcripts. 
 \item $R$ randomly picks uniformly random bits $c_j$ for $j\in [k]$ and sends them to $C$.
 \item $C$ reveals $s_{i,j}^{0c_j}$ and $s_{i,j}^{1c_j}$ along with the corresponding decommit information w.r.t. $\Com$ in \Cref{wEqCom:Com} to $R$ for $i\in [\ell]$ and $j\in [k]$. 
\item $R$ accepts if all the decommit information are valid and $s_{i,j}^{0c_j}=s_{i,j}^{1c_j}$ for all  $i\in [\ell]$ and $j\in [k]$ and otherwise rejects. 
\end{enumerate}

{\bf Decommit Stage:} 
\begin{enumerate}
\item $C$ picks uniformly random bits $d_{i,j}$ and reveals $m$ and 
$s_{i,j}^{d_{i,j}(1-c_j)}$ along with the corresponding decommit information w.r.t. $\Com$ in \Cref{wEqCom:Com} of Commit Stage to $R$ for $i\in [\ell]$ and $j\in [k]$. 
\item  $R$ accepts if all the decommit information are valid and $s_{i,j}^{d_{i,j}(1-c_j)}=m_i\oplus s_{i,j}^{d_{i,j}c_j}$ for all  $i\in [\ell]$ and $j\in [k]$ and otherwise rejects. (Note that $s_{i,j}^{d_{i,j}c_j}$ is already revealed in the commit stage.)
\end{enumerate}
\end{ProtocolBox}
\begin{theorem}
The scheme $\wEqCom$ (\Cref{protocol:wEqCom}) is constant-round and satisfies computational hiding, equivocality (as per \Cref{def:eqcom}), and $(2^{-k}+\negl(\secpar))$-statistical binding, which is defined similarly to statistical binding (as per \Cref{def:com}) except that we only require the malicious committer's winning probability to be at most $2^{-k}+\negl(\secpar)$ instead of $\negl(\secpar)$. 
\end{theorem}
\begin{proof}
It is clear from the description that it is constant-round. 
Since computatioanl hiding immediately follows from equivocality, we prove $(2^{-k}+\negl(\secpar))$-statistical binding and equivocality below.

\para{$(2^{-k}+\negl(\secpar))$-Statistical Binding.}
In an execution of the protocol between unbounded-time malicious committer $C^*$ and honest receiver $R$,  
let $\Bad$ be the event that any of $\tau_{i,j}^{ab}$ can be decommitted to more than one messages.  By statistical binding of $\Com$, $\Bad$ occurs with a negligible probability. Below, we assume that $\Bad$ does not occur. 
For $i\in [\ell]$, let $\inconsistent_i$ be the event that for all $j\in [k]$, there exists $b_{i,j}$ such that $\val(\tau_{i,j}^{0b_{i,j}})\neq \val(\tau_{i,j}^{1b_{i,j}})$. 
When $\inconsistent_i$ occurs, then $C^*$ can pass the verification by $R$ in the commit stage only if $c_j=1-b_{i,j}$ for all $j\in [k]$. Since $c_j$ is uniformly random, this occurs with probability $2^{-k}$. Thus, whenever $C^*$ passes the verification in the commit stage, then neither of $\Bad$ or $\inconsistent_i$ for any $i\in [k]$ occurs except for probability $2^{-k}+\negl(\secpar)$. 
When neither of $\Bad$ or $\inconsistent_i$ occurs, there is $j^*_i$ such that $\val(\tau_{i,j^*_i}^{00})= \val(\tau_{i,j^*_i}^{10})$ and $\val(\tau_{i,j^*_i}^{01})= \val(\tau_{i,j^*_i}^{11})$, in which case the $i$-th bit can be only decommitted to $\val(\tau_{i,j^*_i}^{00})\oplus \val(\tau_{i,j^*_i}^{01})=\val(\tau_{i,j^*_i}^{10})\oplus \val(\tau_{i,j^*_i}^{11})$.\footnote{We define $\bot\oplus \beta = \bot$ for $\beta\in\{0,1,\bot\}$.} 
Thus, except for probability $2^{-k}+\negl(\secpar)$, all the bits can be decommitted to either of $0$ or $1$.   
This means that it satisfies $(2^{-k}+\negl(\secpar))$-statistical binding. 

\para{Equivocality.}
%We first construct a weak simulation equivocator $\tilde{\SimEq}$ that works only with probability $\approx 2^{-k}$. 
The proof strategy is similar to that in the security proof of the equivocality compiler of \cite{C:BCKM21b}, which in turn is based on quantum zero-knowledge proofs by Watrous \cite{SIAM:Watrous09}. 
We first construct a weaker simulation equivocator that guesses the challenges and works only when the guess is correct. 
Then we compile it to the full-fledged simulation equivocator (as per \Cref{def:eqcom}) by using Watrous' rewinding lemma (\Cref{lem:Watrous}).

%For the ease of presentation, we treat the simulation equivocator as if it is directly given the code of the malicious receiver $R^*$ and its quantum advice $\rho$, but it is easy to see that the same algorithm works with black-box access to $R^*(\rho)$ since Watrous' compiler is black-box as observed in \cite{C:ChiChuYam21,C:CCLY22}. 
First, we consider the following algorithm $\sfQ$:

\smallskip
\noindent
$\sfQ^{R^*(\rho)}(1^\secpar)$:  
\begin{enumerate}
\item Randomly pick bits $c'_j$ for $j\in[k]$ and $e_{i,j}$ and $r_{i,j}$  for $i\in[\ell]$ and $j\in [k]$.
\item 
Define
\begin{align*}
\begin{pmatrix*}[r]
s^{0c'_j}_{i,j} & ~~~s^{0(1-c'_j)}_{i,j} \\
s^{1c'_j}_{i,j} & ~~~s^{1(1-c'_j)}_{i,j} \\
\end{pmatrix*}
=
\begin{pmatrix}
r_{i,j} & ~~~e_{i,j} \\
r_{i,j} & ~~~1-e_{i,j} \\
\end{pmatrix}
\end{align*}
for 
$i\in [\ell]$ and $j\in [k]$. 
\item 
Commit to $\{s_{i,j}^{ab}\}_{i\in [\ell],j\in[k],(a,b)\in\bits^2}$ using $\Com$ in a bit-by-bit manner in parallel.  
Let $\{\tau_{i,j}^{ab}\}_{i\in [\ell],j\in[k],(a,b)\in\bits^2}$ be the corresponding transcripts. 
Send them to the malicious receiver $R^*$. 
 \item Receive bits $\{c_j\}_{j\in [k]}$ from $R^*$.  
 \item If $c_j\ne c'_j$ for some $j\in[k]$, output $\beta=1$ and immediately halt. 
 Otherwise, proceed to the next step. 
 \item Reveal $s_{i,j}^{0c_j}=s_{i,j}^{1c_j}=r_{i,j}$ along with the corresponding decommit information w.r.t. $\Com$ to $R$ for $i\in [\ell]$ and $j\in [k]$. 
 \item Define $\decom_{i,j}^{\eta}$ to be the decommit information for $\tau_{i,j}^{(e_{i,j}\oplus \eta)(1-c_j)}$ w.r.t. $\Com$ for $i\in [\ell]$, $j\in [k]$, and $\eta\in\bits$.  Note that the committed message in $\tau_{i,j}^{(e_{i,j}\oplus \eta)(1-c_j)}$ is $\eta$. 
 \item Output a quantum state $\sigma$ that consists of the final state $\ST_{R^*}$ of $R^*$ and $\{\decom_{i,j}^{\eta}\}_{i\in[\ell],j\in[k],\eta\in\bits}$ 
 along with a bit $\beta=0$. 
\end{enumerate}
Let $\sfQ_\rho^{0}$ be the distribution of $\sigma$ output by $\sfQ^{R^*(\rho)}(1^\secpar)$ conditioned on that $\beta=0$. Let $p(\rho)$ be the probability that  $\sfQ^{R^*(\rho)}(1^\secpar)$ returns $\beta=0$. By  computational hiding of $\Com$, it is easy to see that we have 
$$
|p(\rho)-2^{-k}|\le \negl(\secpar)
$$
for any quantum advice $\rho$. 
Thus, by applying Watrous' rewinding lemma (\Cref{lem:Watrous}) with $p_0=2^{-k}-\negl(\secpar)$, $q=2^{-k}$, $\gamma=\negl(\secpar)$, and $T=\lfloor
\frac{\log (1/\gamma)}{4p_0(1-p_0)}\rfloor$, we obtain a QPT algorithm $\tilde{\sfQ}$ that makes black-box use of $R^*(\rho)$ such that 
\begin{align} \label{eq:TD_Q_and_R}
\TD(\sfQ_\rho^{0},\tilde{\sfQ}^{R^*(\rho)}(1^\secpar))\le 4\sqrt{\gamma}\frac{\log (1/\gamma)}{p_0(1-p_0)}=\negl(\secpar)
\end{align}
where we used $k=\Theta(\log \secpar)$ and thus $p_0=2^{-k}-\negl(\secpar)=1/\poly(\secpar)$. 
We remark that $\tilde{\sfQ}$ plays the role of $\sfR$ in \Cref{lem:Watrous}. We changed the notation to avoid confusion with the malicious receiver $R^*$. We also remark that $\tilde{\sfQ}$ makes black-box use of $R^*(\rho)$ since it makes black-box use of $\sfQ$, which in turn makes black-box use of $R^*(\rho)$.

We are now ready to describe the simulation equivocator $\SimEq=(\SimEq_0,\SimEq_1)$: 


\smallskip
\noindent
$\SimEq_0^{R^*(\rho)}(1^\secpar)$:  
\begin{enumerate}
\item Run $\tilde{\sfQ}^{R^*(\rho)}(1^\secpar)$ to obtain $\ST_{R^*}$ and $\{\decom_{i,j}^{\eta}\}_{i\in[\ell],j\in[k],\eta\in\bits}$.  
\item Output $\ST_{R^*}$ and $\ST_{\SimEq}:=\{\decom_{i,j}^{\eta}\}_{i\in[\ell],j\in[k],\eta\in\bits}$. 
\end{enumerate}

\smallskip
\noindent
$\SimEq_1(\ST_{\SimEq},m)$:  
\begin{enumerate}
\item Parse $\ST_{\SimEq}=\{\decom_{i,j}^{\eta}\}_{i\in[\ell],j\in[k],\eta\in\bits}$. 
\item Let $m_i$ be the $i$-th bit of $m$ for $i\in[\ell]$.  
\item Output $\decom:=\{\decom_{i,j}^{m_i}\}_{i\in[\ell],j\in[k]}$. 
\end{enumerate}

Let $\bar{\SimEq}_0^{R^*(\rho)}(1^\secpar)$ be a not necessarily QPT algorithm that works similarly to $\SimEq_0^{R^*(\rho)}(1^\secpar)$ except that it samples $\ST_{R^*}$ and $\{\decom_{i,j}^{\eta}\}_{i\in[\ell],j\in[k],\eta\in\bits}$ from $\sfQ_\rho^0$.  
By \Cref{eq:TD_Q_and_R}, we have 
\begin{align*}
   &\left\{
   (\ST_{R^*},\decom):
   \begin{array}{ll}
   (\ST_{R^*},\ST_{\SimEq})\gets \SimEq_0^{R^*(\rho)}(1^\secpar)\\
   \decom\gets \SimEq_1(\ST_{\SimEq},m)
   \end{array}
   \right\}_{\secpar\in \mathbb{N},m\in \bits^{\ell(\secpar)}}\\
   \sind
   &\left\{
   (\ST_{R^*},\decom):
   \begin{array}{ll}
   (\ST_{R^*},\ST_{\SimEq})\gets \bar{\SimEq}_0^{R^*(\rho)}(1^\secpar)\\
   \decom\gets \SimEq_1(\ST_{\SimEq},m)
   \end{array}
   \right\}_{\secpar\in \mathbb{N},m\in \bits^{\ell(\secpar)}}.
\end{align*}
Moreover, by computational hiding of $\Com$, it is easy to show that 
\begin{align*}
   &\left\{
   (\ST_{R^*},\decom):
   \begin{array}{ll}
   (\ST_{R^*},\ST_{\SimEq})\gets \bar{\SimEq}_0^{R^*(\rho)}(1^\secpar)\\
   \decom\gets \SimEq_1(\ST_{\SimEq},m)
   \end{array}
   \right\}_{\secpar\in \mathbb{N},m\in \bits^{\ell(\secpar)}}\\
   \cind
    &\left\{
    (\ST_{R^*},\decom):
    \begin{array}{ll}
    (\tau,\ST_{C},\ST_{R^*})\gets \langle C(m),R^*(\rho) \rangle(1^\secpar)\\
    \decom \gets C(\ST_C)
    \end{array}
    \right\}_{\secpar\in \mathbb{N},m\in \bits^{\ell(\secpar)}}.
\end{align*}
Combining the above, the proof of equivocality is completed.
\end{proof}

\subsection{Reducing Binding Error}
We show that sequential repetition of $\wEqCom$ (\Cref{protocol:wEqCom}) reduces the binding error to be negligible while preserving equivocality. 
\begin{ProtocolBox}[label={protocol:EqCom}]{Equivocal Commitments $\EqCom$}
{\bf Parameters:} Let $n=\omega(1)$ be a positive integer.

{\bf Inputs:} Both parties receive $\secpar$ as the common input. The committer in addition gets a string $m\in \bits^{\ell(\secpar)}$ as its private input where $\ell(\cdot)$ is a polynomial.

\para{Commit Stage:} 
\begin{enumerate}
\item 
$C$ commits to $m$ using $\wEqCom$ $n$ times in a sequential manner. 
\end{enumerate}
{\bf Decommit Stage:} 
\begin{enumerate}
\item $C$ reveals $m$ along with the corresponding decommit information w.r.t. all the $n$ executions of $\wEqCom$. 
\item  $R$ accepts if all the decommit information are valid  and otherwise rejects. 
\end{enumerate}
\end{ProtocolBox}
\begin{theorem}\label{thm:security-eqcom}
The scheme $\EqCom$ (\Cref{protocol:EqCom}) satisfies computational hiding, equivocality (as per \Cref{def:eqcom}), and statistical binding. 
\end{theorem}
\begin{proof}
Statistical binding follows from $(2^{-k}+\negl(\secpar))$-statistical binding of $\wEqCom$ noting that the binding error is exponentially reduced by sequential repetition  and $(2^{-k}+\negl(\secpar))^n=\negl(\secpar)$ when $k=\Theta(\log \secpar)$ and $n=\omega(1)$. 
Equivocality immediately follows from that of $\wEqCom$ noting that equivocality is preserved under sequential composition. Indeed, this can be shown by a straightforward hybrid argument (see e.g., \cite{C:BCKM21b}). 
Computational hiding immediately follows from equivocality.  
%\para{Statistical Binding.} 
%\para{Equivocality.}
\end{proof}

Since $\EqCom$ runs in $\omega(1)$ rounds makes black-box use of OWFs, \Cref{thm:security-eqcom} implies \Cref{thm:eqcom}. 

\section{Post-Quantum Extractable Batch Commitments}
\label{sec:ExtCom-from-OT}

\subsection{Definitions}
\takashi{TODO: add an intuition for the definition.}

\takashi{I'm not sure if "batch" is the right wording here. This may give a wrong impression that there is some efficiency gain.
Another option is to use "parallel", but I'm wondering if it's confusing because this is different from parallel extractable commitments defined in \cref{def:epsilon-sim-ext-com:parallel}. Any idea?
}

\takashi{Another idea that comes to my mind is to regard it as a commitments with "local decommitments" capturing the inituituion that we can decommit each component of the message locally (without affecting secrecy of other parts).}

\xiao{I think what you said is known in the literature as ``vector commitments''. The only difference is when people say vector commitments, it usually means a succinct (and thus computationally binding) com where statistical binding holds for some specific positions (but not all positions). Thus, even ``vector commitments'' is not good for us. I guess the best name would be ``commitment with local decommitment''. But this seems to long and we need to modify the current notations. In summary, I'm ok with the name ``batch''.}

\begin{definition}[Post-Quantum Batch Commitments]\label{def:bcom}
A {\em post-quantum batch commitment scheme}  $\langle C, R \rangle$ is a classical interactive protocol between interactive \PPT machines $C$ and $R$. Let $\vb{m}=(m_1,...,m_n)\in \bits^{\ell(\secpar)\times n(\secpar)}$ (where $\ell(\cdot)$ and $n(\secpar)$ are some polynomials) be a sequence of messages that $C$ wants to commit to. The protocol consists of the following stages:
\begin{itemize}
\item
{\bf Commit Stage:} $C(\vb{m})$ and $R$ interact with each other to generate a transcript (which is also called a commitment) denoted by $\tau$,\footnote{That is, we regard the whole transcript as a commitment.} 
$C$'s state $\ST_{C}$, and 
$R$'s output $b_{\mathrm{com}}\in\Set{\bot,\top}$ indicating acceptance $(i.e., b_{\mathrm{com}}=\top)$ 
or rejection $(i.e., b_{\mathrm{com}}=\bot)$.
 We denote this execution by $(\tau,\ST_{C},b_{\mathrm{com}}) \gets \langle C(m), R \rangle(1^\secpar)$. When $C$ is honest, $\ST_C$ is classical, but when we consider a malicious quantum committer $C^*(\rho)$, we allow it to generate any quantum state $\ST_{C^*}$. 
 Similarly, a malicious quantum receiver $R^*(\rho)$ can output any quantum state, which we denote by $\OUT_{R^*}$ instead of $b_{\mathrm{com}}$. 
\item
{\bf Decommit Stage:}
$C$ generates a sequence of decommitments $\decom=(\decom_1,...,\decom_n)$ from $\ST_C$.
We denote this procedure by $\decom \gets C(\ST_C)$. 
Then it sends a sequence of messages $\vb{m}=(m_1,...,m_n)$ and the sequence of decommitments $\decom=(\decom_1,...,\decom_n)$ to $R$. 
For each $i\in [n]$, 
$R$ runs a deterministic verification procedure $b_{\mathrm{dec},i} \gets \Verify_i(\tau,m_i,\decom_i)$ 
where $b_{\mathrm{dec},i}=\top$ and $b_{\mathrm{dec},i}=\bot$  indicate acceptance and rejection on the $i$-th bit, respectively. 
W.l.o.g., we assume that $R$ always rejects (i.e., $\Verify_i(\tau,\cdot,\cdot) = \bot$ for all $i\in [n]$) whenever $b_\mathrm{com} = \bot$. (Note that w.l.o.g., $\tau$ can include $b_\mathrm{com}$ because we can always modify the protocol to ask $R$ to send $b_\mathrm{com}$ as the last round message.)
\end{itemize}

The scheme satisfies the following requirements:
\begin{enumerate}
\item
{\bf (Completeness.)} For any polynomials $\ell:\mathbb{N} \rightarrow \mathbb{N}$ 
and $n:\mathbb{N} \rightarrow \mathbb{N}$, any $\vb{m} \in \bits^{\ell(\secpar)\times n(\secpar)}$, and any $i\in [n]$, it holds that
\begin{equation*}
\Pr[
b_{\mathrm{com}}=b_{\mathrm{dec},i}=\top
: 
\begin{array}{l}
(\tau, \ST_{C}, b_{\mathrm{com}}) \gets \langle C(\vb{m}),R \rangle(1^\secpar) \\
(\decom_1,...,\decom_n) \gets C(\ST_C)\\
 b_{\mathrm{dec},i}\gets \Verify_i(\tau,m_i,\decom_i)
\end{array}
] = 1.
\end{equation*}

\item
{\bf (Statistically binding.)} For any unbounded-time committer $C^*$, the following holds: 
\begin{align*}
    \Pr[
    \begin{array}{l}
    \exists~i\in[n],m_0,m_1,\decom_0,\decom_1,~s.t.~m_0\neq m_1 ~\land\\
     \Verify_i(\tau,m_0,\decom_0)=\Verify_i(\tau,m_1,\decom_1)=\top
    \end{array}
    :(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*, R \rangle(1^\secpar)]=\negl(\secpar).
\end{align*}

\item
{\bf (Computationally Hiding.)} For any non-uniform QPT receiver $R^*$ and any polynomials $\ell : \mathbb{N} \rightarrow \mathbb{N}$
and 
$n : \mathbb{N} \rightarrow \mathbb{N}$
, the following holds:
% \begin{equation*}
% \left|\Pr[\OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)=1]-  \Pr[\{\OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)=1]\right|=\negl(\secpar)
% \end{equation*}
\begin{align*}
\big\{ \OUT_{R^*}\langle C(\vb{m}_0),R^* \rangle(1^\secpar),\{\decom_{i'}\}_{i'\ne i}\big\}_{\secpar \in \mathbb{N},~i\in[n(\secpar)], ~\vb{m}_0, \vb{m}_1 \in \Delta_i}\\
\cind~ \big\{ \OUT_{R^*}\langle C(\vb{m}_1),R^* \rangle(1^\secpar),\{\decom_{i'}\}_{i'\ne i}\big\}_{\secpar \in \mathbb{N},~i\in[n(\secpar)],  ~\vb{m}_0, \vb{m}_1 \in \Delta_i},
\end{align*}
where 
$$
\Delta_i:=\{(\vb{m}_0=(m_{0,1},...,m_{0,n}), \vb{m}_1=(m_{1,1},...,m_{1,n}))\in (\bits^{\ell(\secpar)})^2
: \forall i'\in[n]\setminus \{i\}~m_{0,i'}=m_{1,i'}\}
,$$ 
$\OUT_{R^*}\langle C(\vb{m}_b),R^* \rangle(1^\secpar)$ $(b \in \bits)$ denotes the output of $R^*$ at the end of the commit stage, 
and $(\decom_1,...,\decom_n)$ denotes the sequence of decommitments generated by $C$ in the decommit stage.
\end{enumerate}
\end{definition}
\begin{remark}
By a straightforward hybrid argument, the above computational hiding property implies the following: 
\begin{itemize}
\item
{\bf (Computationally Hiding w.r.t. Subsets.)} For any non-uniform QPT receiver $R^*$ and any polynomials $\ell : \mathbb{N} \rightarrow \mathbb{N}$
and 
$n : \mathbb{N} \rightarrow \mathbb{N}$
, the following holds:
% \begin{equation*}
% \left|\Pr[\OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)=1]-  \Pr[\{\OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)=1]\right|=\negl(\secpar)
% \end{equation*}
\begin{align*}
\big\{ \OUT_{R^*}\langle C(\vb{m}_0),R^* \rangle(1^\secpar),\{\decom_{i'}\}_{i'\notin S}\big\}_{\secpar \in \mathbb{N},~S\subseteq[n(\secpar)], ~\vb{m}_0, \vb{m}_1 \in \Delta_S}\\
\cind~ \big\{ \OUT_{R^*}\langle C(\vb{m}_1),R^* \rangle(1^\secpar),\{\decom_{i'}\}_{i'\notin S}\big\}_{\secpar \in \mathbb{N},~S\subseteq [n(\secpar)],  ~\vb{m}_0, \vb{m}_1 \in \Delta_S},
\end{align*}
where 
$$\Delta_S:=\{(\vb{m}_0=(m_{0,1},...,m_{0,n}), \vb{m}_1=(m_{1,1},...,m_{1,n}))\in (\bits^{\ell(\secpar)})^2
: \forall i'\in[n]\setminus S~m_{0,i'}=m_{1,i'}\}
,$$ 
$\OUT_{R^*}\langle C(\vb{m}_b),R^* \rangle(1^\secpar)$ $(b \in \bits)$ denotes the output of $R^*$ at the end of the commit stage, 
and $(\decom_1,...,\decom_n)$ denotes the sequence of decommitments generated by $C$ in the decommit stage.
\end{itemize}
\end{remark}


% \begin{definition}[Computationally Hiding]\label{def:comp-hiding}
% A commitment scheme $\langle C, R \rangle$ is {\em computationally hiding} if for any 
% non-uniform PPT receiver $R^*$ and any polynomial $\ell : \mathbb{N} \rightarrow \mathbb{N}$, the following holds:
% % \begin{equation*}
% % \left|\Pr[\OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)=1]-  \Pr[\{\OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)=1]\right|=\negl(\secpar)
% % \end{equation*}
% $$\big\{ \OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)\big\}_{\secpar \in \mathbb{N}, ~m_0, m_1 \in \bits^{\ell(\secpar)}} ~\cind~ \big\{ \OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)\big\}_{\secpar \in \mathbb{N}, ~m_0, m_1 \in \bits^{\ell(\secpar)}},$$
% where $\OUT_{R^*}\langle C(m_b),R^* \rangle(1^\secpar)$ $(b \in \bits)$ denotes the output of $R^*$ at the end of the commit stage. 
% %\begin{equation*}
% %\{\OUT_{R^*}\langle C(m_0),R^*(\rho) \rangle(1^\secpar) \}_{\secpar} \cind \{\OUT_{R^*}\langle C(m_1),R^*(\rho) \rangle(1^\secpar) \}_{\secpar}
% %\end{equation*}
% %where $\OUT_{R^*}$ denotes the output of $R^*$, which can be quantum.

% We say that $\langle C, R \rangle$ is \emph{post-quantum} computationally hiding if the above holds for all non-uniform \emph{QPT} $R^*$. 
% \end{definition}

% \begin{definition}[Statistically Binding]\label{def:stat-binding} 
% A commitment scheme $\langle C, R \rangle$ is {\em statistically binding} if for any unbounded-time committer $C^*$, the following holds: 
% \begin{align*}
%     \Pr[
%     \begin{array}{l}
%     \exists~m_0,m_1,\decom_0,\decom_1,~s.t.~m_0\neq m_1 ~\land\\
%      \Verify(\tau,m_0,\decom_0)=\Verify(\tau,m_1,\decom_1)=\top
%     \end{array}
%     :(\tau,\decom,b_{\mathrm{com}}) \gets \langle C^*, R \rangle(1^\secpar)]=\negl(\secpar).
% \end{align*}
% \end{definition}

Similarly to the stand-alone setting (\Cref{def:com-val}), we define committed values for batch commitments as follows.  
\begin{definition}[Committed Values for Batch Commitments]\label{def:bcom-val}
For a statistically binding batch commitment scheme $\langle C, R \rangle$ (as per \Cref{def:bcom}), we define the value function as follows:
\begin{equation*}
    \val_i(\tau)\defeq 
    \begin{cases}
    m_i&\text{~if~}\exists\text{~unique~}m_i\text{~s.t.~}\exists~\decom_i, \Verify_i(\tau,m_i,\decom_i)=1\\
    \bot &\text{otherwise}
    \end{cases},
\end{equation*}
where $\Verify_i$ is as defined in \Cref{def:bcom}.
\end{definition}

Then we define extractability for batch commitments. This is a natural extension of that in the stand-alone setting (\Cref{def:epsilon-sim-ext-com:strong}) but there is a crucial difference that we require simulation with negligible errors instead of $\epsilon$-simulation because the purpose of this section is to achieve negligible simulation errors at the cost of sacrificing round complexity. 

\begin{definition}[PQ-ExtBCom]\label{def:sim-ext-bcom:strong}
A post-quantum batch commitment scheme $\langle C, R\rangle$ (as per \Cref{def:bcom}) is {\em extractable} if there exists a QPT algorithm $\SimExt$ (called the simulation extractor) such that for any non-uniform QPT $C^*(\rho)$, 
\begin{equation*}
\big\{ \SimExt^{C^*(\rho)}(1^\secpar) \big\}_\secpar
\cind 
\big\{(\{\val_i(\tau)\}_{i\in [n]}, \ST_{C^*}):(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*(\rho), R \rangle(1^\secpar)\big\}_\secpar,  
\end{equation*}
where $\val_i(\tau)$ is the value committed by $C^*$ as defined in \Cref{def:bcom-val}. 
\end{definition}
\begin{remark}\label{rem:comp_vs_stat_ind}
 We remark that we only require computational indistinguishability between the simulated and real execution while \Cref{def:epsilon-sim-ext-com:strong} requires statistical indistinguishability (with a noticeable simulation error). This is because computational indistinguishability is sufficient for our purpose.   \takashi{More explanations may be useful.}
\end{remark}
\begin{remark} 
One may find a conceptual similarity between 
extractable batch commitments (\Cref{def:sim-ext-bcom:strong}) and
parallelly extractable commitments (\Cref{def:epsilon-sim-ext-com:parallel}). 
Indeed, if a (stand-alone) commitment scheme (as per \Cref{def:com}) satisfies the negligible simulation error version of parallel extractability (as per \Cref{def:epsilon-sim-ext-com:parallel}), then its parallel composition is an extractable batch commitment scheme  (as per \Cref{def:sim-ext-bcom:strong}). However, we do not know how to construct a commitment scheme that satisfies the negligible simulation error version of parallel extractability. This is why we introduced extractable batch commitments.   \takashi{I guess this remark is very confusing. We may improve the explanation later.}
\end{remark}

As an intermediate tool towards constructing extractable batch commitments (as per \Cref{def:sim-ext-bcom:strong}), we introduce a weaker security notion which we call \emph{extractability with over-extraction}.
Intuitively, it is similar to the full-fledged extractability  (\Cref{def:sim-ext-bcom:strong}) except that we allow the simulation extractor to extract non-$\bot$ messages even if the transcript is invalid (i.e., there is no accepting decommitment). 
\begin{definition}[PQ-ExtBCom with Over-extraction]\label{def:sim-ext-bcom:over}
A post-quantum batch commitment scheme $\langle C, R\rangle$ (as per \Cref{def:bcom}) is {\em extractable with over-extraction} if there exists a QPT algorithm $\SimExtO$ (called the simulation extractor with over-extraction) such that for any non-uniform QPT $C^*(\rho)$, 
\begin{equation*}
\big\{ (\tau,\ST_{C^*}):(\tau,\ST_{C^*},\{m_{\ext,i}\}_{i\in[n]})\gets \SimExtO^{C^*(\rho)}(1^\secpar) \big\}_\secpar
\cind
\big\{(\tau, \ST_{C^*}):(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*(\rho), R \rangle(1^\secpar)\big\}_\secpar,  
\end{equation*}
and 
\begin{equation*}
    \Pr[\exists i\in[n]~s.t.~\val_i(\tau)\notin\{m_{\ext,i},\bot\}]\le \negl(\secpar)
\end{equation*}
where 
$(\tau,\ST_{C^*},\{m_{\ext,i}\}_{i\in[n]})\gets \SimExtO^{C^*(\rho)}(1^\secpar)$ and $\val_i(\com)$ is the value committed by $C^*$ as defined in \Cref{def:bcom-val}.  \takashi{Strictly speaking, this may not be weaker than \Cref{def:sim-ext-bcom:strong} since the second condition may not follow from \Cref{def:sim-ext-bcom:strong}?}
\end{definition}
\begin{remark}
Extractability with over-extraction is conceptually similar to weak extractability defined in \cite{C:CCLY22} in the sense that both only require the extracted message be correct only when the transcript is valid. However, the crucial difference is that extractability with over-extraction requires that simulation of the committer's state be indistinguishable from the real one even when the transcript is invalid whereas weak extractability only requires it when  the transcript is valid.
\end{remark}





\subsection{Extractable Batch Commitments with Over-extraction}\label{sec:construction_OverExtBCom} 
Our construction of an extractable batch commitment scheme with over-extraction is described in \Cref{protocol:OverExtBCom}. It makes black-box use of the following building blocks:
\begin{enumerate}
\item 
A constant-round statistically-binding, computationally-hiding commitment $\Com$, (e.g., Naor's commitment). 
%$\Com$ is a statistically-binding and computationally-hiding commitment scheme $\Com$ (e.g., Naor's commnitment).   
\item A parallel oblivious transfer protocol $\OT$ that satisfies $\epsilon$-simulation security against malicious receivers and indistinguishability-based security against malicious senders.  \takashi{Should we need to give a definition? } 
Assuming $t(\secpar)$-round semi-honest OT,  \cite{C:CCLY22} gives a black-box and $O(t(\secpar))$-round construction of such a protocol.\footnote{Their construction is shown to satisfy $\epsilon$-simulation security for both malicious senders and malicious receivers, and  $\epsilon$-simulation security immediately implies indistinguishability-based security.} 
\takashi{Maybe $(t(\secpar)+O(1))$-round? Need to recheck.}

\item An equivocal commitment scheme $\EqCom$ (as per \Cref{def:eqcom}). 
A $\omega(1)$-round construction of it is known assuming only black-box access to post-quantum secure OWFs (\Cref{thm:eqcom}).  
\end{enumerate}
\begin{ProtocolBox}[label={protocol:OverExtBCom}]{Extractable Batch Commitments with Over-Extraction $\OverExtBCom$}
{\bf Parameters:} Let $k=\omega(\log \secpar)$ be a positive integer. We use $k$ to mean the number of parallel sessions in $\OT$. 

{\bf Inputs:} Both parties receive $\secpar$ as the common input. The committer in addition gets a sequence of strings $\vb{m}=(m_1,...,m_n)\in \bits^{\ell(\secpar)\times n(\secpar)}$ as its private input where $\ell(\cdot)$ and $n(\cdot)$ are polynomials.

\para{Commit Stage:} 
\begin{enumerate}
\item \label[Step]{OverExtBCom:Com} 
$C$ commits to $m_i$ using $\Com$ for all $i\in[n]$ in parallel. Let $\com_i$ be the transcript of the $i$-th execution. 
\item 
For $i\in[n]$, $C$ generates $2k$-out-of-$2k$ XOR secret sharing $\{s^{b}_{i,j}\}_{j\in [k],b\in \bit}$ of $m_i$. 
That is, they are uniformly random under the constraint that $\bigoplus_{j\in[k],b\in\bit}s^{b}_{i,j}=m_i$. \item \label[Step]{OverExtBCom:OT} 
$C$ and $R$ execute 
$n$-parallel executions of $\OT$.\footnote{Note that $\OT$ itself is a $k$-parallel OT, and thus $nk$-parallel executions are happening in total.} 
We refer to the $i$-th execution by $\OT_i$ where 
$C$ uses
$\{s^{0}_{i,j},s^{1}_{i,j}\}_{j\in[k],b\in\bits}$ as input and $R$ uses independently and uniformly random bits $\{r_{i,j}\}_{j\in [k]}$ as input. 
\item \label[Step]{OverExtBCom:CF}
$C$ and $R$ now engage in the following coin-flipping subprotocol as detailed below.  
\begin{enumerate}
\item \label[Step]{OverExtBCom:EqCom}
$R$ samples a random string $\theta_R\gets \bit^{nk}$ and commits to it using $\EqCom$.   
\item \label[Step]{OverExtBCom:pick_theta_C}
$C$ samples a random string $\theta_C\gets \bit^{nk}$ and sends it to $R$.  
\item \label[Step]{OverExtBCom:EqCom-open}
$R$ sends to $C$ the value $\theta_R$ together with the corresponding decommitment information w.r.t. 
the $\EqCom$ in \Cref{OverExtBCom:EqCom}. Now, $C$ and $R$ agree on a random string $\theta \coloneqq \theta_R \xor \theta_C\in \bit^{nk}$. 
Interpret $\theta$ as a family $\{t_{i,j}\}_{i\in[n],j\in[k]}$ of bits.  
That is, let $t_{i,j}$ be the $(i-1)k+j$-th bit of $\theta$ for $i\in [n]$ and $j\in [k]$. 
\end{enumerate}
\item \label[Step]{OverExtBCom:reveal_s}
$C$ sends $s_{i,j}^{t_{i,j}}$ to $R$ for $i\in [n]$ and $j\in [k]$.  
\item $R$ never rejects in the commit stage, i.e., it always outputs $b_{\mathrm{com}}=\top$.  
$C$ sets the randomness used in the commit stage as $\ST_{C}$ and keep it for the decommit stage. 
\end{enumerate}

{\bf Decommit Stage:} 
\begin{enumerate}
\item 
For $i\in[n]$, 
$C$ defines $\decom_i$ to be a string consisting of the decommit information of $\com_i$ w.r.t. $\Com$ in \Cref{OverExtBCom:Com} of the Commit Stage, $\{s^{0}_{i,j},s^{1}_{i,j}\}_{j\in[k],b\in\bits}$, and the sender's randomness used in $\OT_i$ in \Cref{OverExtBCom:OT} of the Commit Stage.
\item $C$ sends $\vb{m}=(m_1,...,m_n)$ along with $\decom=(\decom_1,...,\decom_n)$ to $R$.
\item 
For each $i\in [n]$, $R$ runs the verification procedure $\Verify_i$ that accepts if 
\begin{enumerate}
\item the decommitment of $\com_i$ is valid w.r.t. the committed message $m_i$,
\item $\bigoplus_{j\in[k],b\in\bit}s^{b}_{i,j}=m_i$,
\item the revealed randomness for $\OT_i$ is consistent to the transcript of $\OT_i$ with input $\{s^{0}_{i,j},s^{1}_{i,j}\}_{j\in[k],b\in\bits}$, and
\item the string sent in \Cref{OverExtBCom:reveal_s} of the Commit Stage is consistent to $\{s^{0}_{i,j},s^{1}_{i,j}\}_{j\in[k],b\in\bits}$, i.e., it is equal to $s_{i,j}^{t_{i,j}}$ where $t_{i,j}$ is the bit generated in \Cref{OverExtBCom:CF} of the Commit Stage. 
\end{enumerate}
$R$ accepts if $\Verify_i$ accepts for all $i\in[n]$ and 
otherwise rejects. 
\end{enumerate}
\end{ProtocolBox}

%\para{Round Complexity.}
%Suppose that there is a $p(\secpar)$-round semi-honest OT. 
%Then we can instantiate \Cref{protocol:OverExtBCom}  in $O(t(\secpar))+\omega(1)$ \takashi{Maybe $t(\secpar)+\omega(1)$? We need to check if the CDMW compiler incurs a constant multiplicative factor.} rounds as observed below:
%\begin{enumerate}
%\item There is a two-round statistically-binding and computationally-hiding commitments based on OWFs (e.g., Naor's commitment).  
%\item There is a parallel OT protocol with $\epsilon$-simulation security for both malicious senders and malicious receivers  in $O(t(\secpar))$ rounds based on $t(\secpar)$-round semi-honest OT \cite{C:CCLY22}, and   $\epsilon$-simulation security immediately implies indistinguishability-based security. 
%\item There is an $\omega(1)$-round equivocal commitment scheme based on OWFs (see \Cref{thm:eqcom}). 
%\end{enumerate}

\para{Security.} The security of \Cref{protocol:OverExtBCom} is stated as the following theorem. 
\begin{theorem}\label{thm:OverExtBCom}
 Assuming the existence of $t(\secpar)$-round semi-honest OT protocols, there exists (i.e., \Cref{protocol:OverExtBCom}) a black-box, $O(t(\secpar))+\omega(1)$-round construction of  batch commitments 
 that satisfies statistical binding, computational hiding (as per \Cref{def:bcom}), and extractability with over-extraction (as per \Cref{def:sim-ext-bcom:over}). 
\end{theorem}   
\begin{proof}
Statistical binding property immediately follows from that of $\Com$. Below, we show computational hiding and extractability with over-extraction. 

\para{Computational Hiding.}
Let $R^*(\rho)$ be any malicious QPT receiver.
Fix $i^*\in [\ell]$ and pair of sequence of messages $\vb{m}_0$ and $\vb{m}_1$ that differ only on the $i^*$-th component.
%Let $\epsilon(\cdot)$ be any noticeable function.  
We consider the following hybrids for $b\in \bit$ and noticeable function $\epsilon$.

\para{Hybrid $H_b$:} This hybrid simulates execution between $C$ with input $\vb{m}_b$ and $R^*(\rho)$ and outputs $(\OUT_{R^*}\langle C(\vb{m}_b),R^* \rangle(1^\secpar),\{\decom_{i}\}_{i\ne i^*})$ 
where $(\decom_1,...,\decom_n)$ denotes the sequence of decommitments generated by $C$ in the decommit stage.

\para{Hybrid $H^\epsilon_b$:} This hybrid is identical to $H_b$, except that the execution of $\OT_{i^*}$ in \Cref{OverExtBCom:OT} of the commit stage is replaced with its $\epsilon$-simulation. 

\subpara{$\Output_{H_b} \cind_\epsilon \Output_{H^\epsilon_b}$:} This follows directly from $\epsilon$-simulation security of $\OT$ against malicious receivers. 

\subpara{$\Output_{H^\epsilon_0} \sind \Output_{H^\epsilon_1}$:}
In $H^\epsilon_b$, let $\{r^*_{i^*,j}\}_{j\in[k]}$ be the receiver's input to the ideal functionality of parallel OT provided by the simulator. Then the ideal functionality returns $\{s_{i^*,j}^{r_{i^*,j}}\}_{i^*\in[n],j\in[k]}$ to the simulator where $\{s_{i^*,j}^{0},s_{i^*,j}^{1}\}_{j\in[k]}$ is the honest committer's input to $\OT_{i^*}$ generated according to the description of the protocol. Especially, no information of $\{s_{i^*,j}^{1-r_{i^*,j}}\}_{j\in[k]}$ is used until this point. Since $\{s_{i^*,j}^{b}\}_{j\in[k],b\in\bit}$ is a $2k$-out-of-$2k$ XOR secret sharing of $m_{b,i^*}$, which is the $i^*$-th component of $\vb{m}_b$, no information of $m_{b,i^*}$ is revealed in $H_b^\epsilon$ unless all the remaining shares $\{s_{i^*,j}^{1-r_{i^*,j}}\}_{j\in[k]}$ are revealed at later stages, which happens only if $t_{i^*,j}=1-r_{i^*,j}$ for all $j\in[k]$ where $\{t_{i,j}\}_{i\in [n],j\in[k]}$ is the result of coin-flipping in \Cref{OverExtBCom:CF} of the commit stage. However, by computational hiding of $\EqCom$, the malicious receiver can cause only a negligible bias on the distribution of $\{t_{i,j}\}_{i\in [n],j\in[k]}$. Thus, the probability that $t_{i^*,j}=1-r_{i^*,j}$ for all $j\in[k]$ is at most $2^{-k}+\negl(\secpar)=\negl(\secpar)$. Thus, with probability $1-\negl(\secpar)$, $m_{b,i^*}$ remains information-theoretically hidden. This implies $\Output_{H^\epsilon_0} \sind \Output_{H^\epsilon_1}$. 

Combining the above, we obtain 
$\Output_{H_0} \cind_{2\epsilon} \Output_{H_1}$. Since this holds for any noticeable function $\epsilon$, this implies $\Output_{H_0} \cind \Output_{H_1}$, which means that the protocol satisfies computational hiding.


\para{Extractability with Over-extraction.} 
Let $\SimEq=(\SimEq_0,\SimEq_1)$ be the simulation equivocator for $\EqCom$. We construct the simulation extractor with over-extraction $\SimExtO$ as follows: 

\smallskip
\noindent
$\SimExtO^{C^*(\rho)}(1^\secpar)$: 
\begin{enumerate}
\item Interact with $C^*$ in \Cref{OverExtBCom:Com} playing the role of $R$. 
\item Execute $n$-parallel executions of $\OT$ in \Cref{OverExtBCom:OT}  with $C^*$ where $\SimExtO$ plays the role of the honest receiver of $\OT$ that uses a independently and uniformly random bits $\{r_{i,j}\}_{j\in[k]}$ as input in $\OT_i$ for $i\in [n]$.  Let $\{s^*_{i,j}\}_{j\in[k]}$ be the receiver's outcome of $\OT_i$ for $i\in [n]$. 
\item 
Let $\rho'$ be the internal state of $C^*$ at the end of \Cref{OverExtBCom:OT}. 
Run $(\rho'',\ST_{\SimEq})\gets \SimEq_0^{C^*(\rho')}(1^\secpar)$. (Recall that $C^*$ plays the role of receiver for $\EqCom$.)   
\item Resume $C^*$ from \Cref{OverExtBCom:pick_theta_C} with its internal state $\rho''$ to obtain $\theta_C$. 
\item   
Let $\bar{r}\in \bits^{nk}$ be the string whose $(i-1)k+j$-th bit is $1-r_{i,j}$ for $i\in[n]$ and $j\in[k]$ and set $\theta_R\coloneqq \bar{r}\oplus \theta_C$. 
\item Run $\EqCom.\decom\gets \SimEq_1(\ST_{\SimEq},\theta_R)$ and sends $\theta_R$ and $\EqCom.\decom$ to $C^*$. 
Note that $t_{i,j}$ is now programmed to be $1-r_{i,j}$. 
\item Receive $s_{i,j}^{t_{i,j}}=s_{i,j}^{1-r_{i,j}}$ from $C^*$. Note that it obtains all the shares $\{s_{i,j}^b\}_{i\in[n],j\in[k],b\in\bits}$ at this point. 
\item Compute $m_{\ext,i}=\bigoplus_{j\in[k],b\in\bit}s_{i,j}^b$ for $i \in [n]$.
\item Output the transcript $\tau$, the final state $\ST_{C^*}$ of $C^*$, and $\{m_{\ext,i}\}_{i\in[n]}$. 
\end{enumerate}

First, it is easy to see that 
\begin{equation*}
    \Pr[\exists i\in[n]~s.t.~\val_i(\tau)\notin\{m_{\ext,i},\bot\}]=0
\end{equation*}
where 
$(\tau,\ST_{C^*},\{m_{\ext,i}\}_{i\in[n]})\gets \SimExtO^{C^*(\rho)}(1^\secpar)$. 
To see this, suppose that $\val_i(\tau)\neq \bot$. In this case, there must exist secret sharing $\{s_{i,j}^b\}_{j\in[k],b\in\bits}$ of $m_i$ that is consistent to the transcript. By the perfect correctness of $\OT$, \takashi{Is it okay to assume that $\OT$ satisfies perfect correctness? Otherwise, more involved arguments would be needed.
} these shares are obtained by $\SimExtO$ and thus $m_{\ext,i}=m_i$. 

Below, we prove 
\begin{equation} \label{eq:ind_SE_over}
\big\{ (\tau,\ST_{C^*}):(\tau,\ST_{C^*},\{m_{\ext,i}\}_{i\in[n]})\gets \SimExtO^{C^*(\rho)}(1^\secpar) \big\}_\secpar
\cind
\big\{(\tau, \ST_{C^*}):(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*(\rho), R \rangle(1^\secpar)\big\}_\secpar.  
\end{equation}
We consider the following hybrids. 

\para{Hybrid $H_0$:} This hybrid executes  $(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*(\rho), R \rangle(1^\secpar)$ and outputs $(\tau, \ST_{C^*})$. 

\para{Hybrid $H_1$:} This hybrid is identical to the previous one except that the commitment by $R$ of $\EqCom$ in \Cref{OverExtBCom:EqCom} is generated by $\SimEq_0$, which is decomitted to $\theta_R$ by $\SimEq_1$ in \Cref{OverExtBCom:EqCom-open}. Note that $\theta_R$ is just a uniformly random string that is independent of $\{r_{i,j}\}_{i\in[n],j\in[k]}$ in this hybrid. 

\subpara{$\Output_{H_0} \cind \Output_{H_1}$:} This follows directly from equivocality of $\EqCom$

\para{Hybrid $H_2$:} This hybrid is identical to the previous one except that $R$ uses $0^k$ as input of $\OT_i$ for all $i\in[n]$ in \Cref{OverExtBCom:OT}. 

\subpara{$\Output_{H_1} \cind \Output_{H_2}$:} This follows directly from indistinguishability-based security of $\OT$ against malicious senders. 

\para{Hybrid $H_3$:} This hybrid is identical to the previous one except that 
$\theta_R$ is set as $\theta_R=\bar{r}\oplus \theta_C$ where $\bar{r}$ is as defined in the description of $\SimExtO$. Note that $\theta_R$ can depend on $\theta_C$ since $\theta_R$ is not used in   \Cref{OverExtBCom:EqCom} due to the modification made in $H_1$. 

\subpara{$\Output_{H_2} \idind \Output_{H_3}$:} This follows directly from the observation that $u_1$ is a independently and uniformly random string in both hybrids noting that no information of $r$ is used in \Cref{OverExtBCom:OT} due to the modification made on $H_2$. 

\para{Hybrid $H_4$:} This hybrid is identical to the previous one except that $R$ uses $\{r_{i,j}\}_{j\in[k]}$ as input of $\OT_i$ for all $i\in[n]$ in \Cref{OverExtBCom:OT}. 

\subpara{$\Output_{H_3} \cind \Output_{H_4}$:} This follows directly from indistinguishability-based security of $\OT$ against malicious senders. 

Now, we can see that $H_4$ just runs  $(\tau,\ST_{C^*}):(\tau,\ST_{C^*},\{m_{\ext,i}\}_{i\in[n]})\gets \SimExtO^{C^*(\rho)}(1^\secpar)$  and outputs $(\tau, \ST_{C^*})$. 
Combining the above, we obtain 
\Cref{eq:ind_SE_over}. 
This completes the proof of extractability with over-extraction.
\end{proof}

\subsection{Removing  Over-extraction}
Next, we give a compiler that upgrades extractable batch commitments with over-extraction (as per \Cref{def:sim-ext-bcom:over})
into one with full-fledged extractability without over-extraction (as per \Cref{def:sim-ext-bcom:strong}).  
It is based on the cut-and-choose technique that is very similar to the one used for upgrading ``weak" extractable commitments into ``strong" one in \cite{C:CCLY22}.\footnote{We omit the definitions of weak and strong extractability in \cite{C:CCLY22} since this is not needed for our purpose.} 
Our construction of an extractable batch commitment scheme with over-extraction is described in \Cref{protocol:ExtBCom}. It makes black-box use of the following building blocks:
\begin{enumerate}
\item
The extractable batch commitment scheme $\OverExtBCom$ with over-extraction given in \Cref{protocol:OverExtBCom}, which in turn makes black-box use of any OTs.
Note that it is $(O(t(\secpar))+\omega(1))$-round if the assumed OT is $t(\secpar)$-round (\Cref{{thm:OverExtBCom}}).
\item A commitment scheme $\epsilonExtCom$ that satisfies statistical binding, computational hiding, and extractability with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:strong}). 
Constant-round and black-box construction of such a scheme based on OWFs is given in \cite{C:CCLY22}.\footnote{In fact, we only need a weaker security called ``weak extractability with $\epsilon$-simulation" in \cite{C:CCLY22}. 
} 
\item
An $(n+1,k)$-perfectly verifiable secret sharing scheme $\VSS = (\VSS_{\Share}, \VSS_{\Recon})$ (as per \Cref{def:VSS}). We require that $k$ is a constant fraction of $n$ such that  $k \le n/3$. There are known constructions (without any computational assumptions) satisfying these properties \cite{STOC:BenGolWig88,EC:CDDHR99}.
\end{enumerate}
\takashi{I wanted to use $n$ as the length of $\bf{m}$ as previous sections, but I found that there is a notational collision with the parameter for VSS, so I used $N$ instead. Any idea to improve the readability?}


\begin{ProtocolBox}[label={protocol:ExtBCom}]{Extractable Batch Commitment $\ExtBCom$}
\para{Parameters.}
Let $n(\SecPar)$ be a polynomial on $\SecPar$. Let $k$ be a constant fraction of $n$ such that $k \le n/3$.

\para{Input:}
Both the committer $C$ and the receiver $R$ get security parameter $1^\SecPar$ as the common input. $C$ in addition gets a sequence of strings $\vb{m}=(m_1,...,m_\mlen) \in \bits^{\ell(\SecPar)\times \mlen(\secpar)}$ as his private input, where $\ell(\cdot)$ and $\mlen(\cdot)$ are polynomials.\footnote{We use $\mlen$ instead of $n$ to mean the number of committed messages of $\OverExtBCom$ to avoid notational collision with the parameter for $\VSS$.} 

\para{Commit Stage:}
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item \label[Step]{ExtBCom:Init}
For $i\in [\mlen]$, $C$ prepares $n$ views $\Set{\msf{v}_{i,j}}_{j \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the message $m_i$ (see \Cref{rmk:mpc-in-the-head-vss} for details). 
\item \label[Step]{ExtBCom:com_to_views} 
For $i\in[\mlen]$, 
$C$ and $R$ involve an execution of $\OverExtBCom$ where $C$ commits to $\vb{v}\coloneqq \{\msf{v}_{i,j}\}_{i\in[\mlen],j\in [n]}\in \bit^{\ell\times Nn}$. 
\item \label[Step]{ExtBCom:CF}
$C$ and $R$ engage in the following coin-flipping subprotocol as detailed below.  
\begin{enumerate}
\item \label[Step]{ExtBcom:com_to_theta_R}
$R$ samples a random string $\theta_R$ of proper length and commits to it using $\epsilonExtCom$.   
\item \label[Step]{ExtBcom:send_theta_C}
$C$ samples a random string $\theta_C$ of proper length and sends it to $R$.  
\item \label[Step]{ExtBcom:reveal_theta_R}
$R$ sends to $C$ the value $\theta_R$ together with the corresponding decommitment information w.r.t.
the $\epsilonExtCom$ in \Cref{ExtBcom:com_to_theta_R}. Now, $C$ and $R$ agree on a random string $\theta \coloneqq \theta_R \xor \theta_C$. By a proper choice of length, the string $\theta$ it can be interpreted as specifying $N$ size-$k$ random subsets of $[n]$. We write $(\eta_1,...,\eta_N)$ to mean these subsets. 
\end{enumerate} 
\item \label[Step]{ExtBCom:decommit_some_shares}
For $i\in [\mlen]$, $C$ decommits to the VSS shares in the set $\eta_i$, i.e. it sends $\Set{\msf{v}_{i,j}}_{j \in \eta_i}$ along with the corresponding decommitment information w.r.t.\ $\OverExtBCom$ in \Cref{ExtBCom:com_to_views}. 
\item \label[Step]{ExtBCom_commit_stage_check}
$R$ checks the following conditions:
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item
All the decommitments in \Cref{ExtBCom:decommit_some_shares} are valid; {\bf and}
\item
for any $i\in[\mlen]$ and $j,j'\in \eta_i$, views $(\view_{i,j}, \view_{i,j'})$ are consistent (as per \Cref{def:view-consistency} and \Cref{rmk:VSS:view-consistency}) w.r.t.\ the $\VSS_\Share$ execution in \Cref{ExtBCom:Init}. 
\end{enumerate}
If all the checks pass, $R$ accepts (i.e., outputs $b_{\mathrm{com}}=\top$); otherwise, $R$ rejects (i.e., outputs $b_{\mathrm{com}}=\bot$).
\end{enumerate}
\para{Decommit Stage:}
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item \label[Step]{ExtBCom:decommit_all_shares}
For $i\in [\mlen]$, $C$ defines $\decom_i$ to be a string consisting of $\Set{\view_{i,j}}_{j\in [n]}$ together with all the corresponding decommitment information w.r.t.\ $\OverExtBCom$ in \Cref{ExtBCom:com_to_views} of the Commit Stage. 
$C$ sends $\vb{m}=(m_1,...,m_\mlen)$ and $\decom=(\decom_1,...,\decom_\mlen)$. 
\item  \label{ExtBCom_decommit_verf}
For each $i\in [\mlen]$, $R$ runs the verification procedure $\Verify_i$ that works as follows: 
\begin{enumerate}
\item Construct $\Set{\view'_{i,j}}_{j\in [n]}$ as follows: in \Cref{ExtBCom:decommit_all_shares} of the Decommit Stage, if the decommitment to $\view_{i,j}$ is valid, $R$ sets $\view'_{i,j} \coloneqq \view_{i,j}$; otherwise, $R$ sets $\view'_{i,j} \coloneqq \bot$. 
\item Accept if $m_i = \VSS_\Recon(\view'_{i,1}, \ldots, \view'_{i,n})$ and otherwise reject. 
\end{enumerate}
$R$ accepts if $\Verify_i$ accepts for all $i\in[\mlen]$ and otherwise rejects.  
\end{enumerate}
\end{ProtocolBox}

\begin{theorem}\label{thm:ExtBCom}
 Assuming the existence of $t(\secpar)$-round semi-honest OT protocols, there exists (i.e., \Cref{protocol:ExtBCom}) a black-box, $O(t(\secpar))+\omega(1)$-round construction of  batch commitments 
 that satisfies statistical binding, computational hiding (as per \Cref{def:bcom}), and extractability (as per \Cref{def:sim-ext-bcom:strong}). 
\end{theorem}   
\begin{proof}
Statistical binding property immediately follows from that of $\OverExtBCom$. Below, we show computational hiding and extractability. 

\para{Computational Hiding.}
Let $R^*(\rho)$ be any malicious QPT receiver.
Fix $i^*\in [\ell]$ and pair of sequence of messages $\vb{m}_0$ and $\vb{m}_1$ that differ only on the $i^*$-th component. 
We consider the following hybrids for $b\in \bit$ and noticeable function $\epsilon$.

\para{Hybrid $H_b$:} This hybrid simulates execution between $C$ with input $\vb{m}_b$ and $R^*(\rho)$ and outputs $(\OUT_{R^*}\langle C(\vb{m}_b),R^* \rangle(1^\secpar),\{\decom_{i}\}_{i\ne i^*})$ 
where $(\decom_1,...,\decom_n)$ denotes the sequence of decommitments generated by $C$ in the decommit stage.

\para{Hybrid $H^\epsilon_b$:} This hybrid is identical to $H_b$, except for the following changes: It takes size-$k$ random subsets $\eta_i\subseteq [n]$ for all $i\in [\mlen]$ at the beginning. 
Then it runs the $\epsilon$-simulation extractor for $\epsilonExtCom$ to extract 
$\theta_R$ while simulating the state of $R^*$ in \Cref{ExtBcom:com_to_theta_R}
and defines $\theta_C$ so that $\theta_R\oplus \theta_C$ specifies the subsets $(\eta_1,...,\eta_\mlen)$ in \Cref{ExtBcom:send_theta_C}. 

\subpara{$\Output_{H_b} \cind_\epsilon \Output_{H^\epsilon_b}$:} This follows directly from extractability with $\epsilon$-simulation  of $\epsilonExtCom$ noting that the distribution of $\theta_C$ is uniformly random in both hybrids.   

\subpara{$\Output_{H^\epsilon_0} \cind \Output_{H^\epsilon_1}$:} 
Note that the subset $\theta_{i^*}$ is fixed at the beginning in these hybrids. Then we can reduce computational indistinguishability of them to computational hiding of $\OverExtBCom$ by the same argument as the security proof of the  VSS hiding game (\Cref{chall:vss:hide}). 

Combining the above, we obtain 
$\Output_{H_0} \cind_{2\epsilon} \Output_{H_1}$. Since this holds for any noticeable function $\epsilon$, this implies $\Output_{H_0} \cind \Output_{H_1}$, which means that the protocol satisfies computational hiding.

\para{Extractability.} 
Let $\SimExtO$ be the simulation extractor with over-extraction for $\SimExtO$. We construct the simulation extractor $\SimExt$ as follows: 

\smallskip
\noindent
$\SimExt^{C^*(\rho)}(1^\secpar)$: 
\begin{enumerate}
\item Run 
$(\OverExtBCom.\tau,\rho',\{\view_{\ext,i,j}\}_{i\in[\mlen],j\in[n]})\gets \SimExtO^{C^*(\rho)}(1^\secpar)$
where $\OverExtBCom.\tau$ is the simulated transcript of the execution of $\OverExtBCom$ in \Cref{ExtBCom:com_to_views}, $\rho'$ is the simulated state of $C^*$ at the end of  \Cref{ExtBCom:com_to_views}, and $\{\view_{\ext,i,j}\}_{i\in[\mlen],j\in[n]}$ is the tuple of the extracted messages. 
\item Run the rest of the commit stage while playing the role of the honest receiver $R$. 
\item Let $\ST_{C^*}$ be the state of $C^*$ at the end of the commit stage. Define $\{m_{\ext,i}\}_{i\in \mlen}$ as follows:
\begin{enumerate}
\item If $b_{\mathrm{com}}=\bot$ (i.e., $R$ rejects in \Cref{ExtBCom_commit_stage_check} of the commit stage), then set $m_{\ext,i}\coloneqq \bot$ for all $i\in [\mlen]$.
\item Otherwise, 
set $m_{\ext,i} \coloneqq \VSS_\Recon(\view_{\ext,i,1}, \ldots, \view_{\ext,i,n})$ for $i\in[\mlen]$. 
%compute $m_i$ as in \Cref{ExtBCom_decommit_verf} of the decommit stage where it uses $\{\view_{\ext,i,j}\}_{i\in[\mlen],j\in[n]}$ instead of $\{\view_{i,j}\}_{i\in[\mlen],j\in[n]}$ and set $m_{\ext,i}\coloneqq m_i$ for all $i\in[\mlen]$. 
\end{enumerate}
\item Output $(\ST_{C^*},\{m_{\ext,i}\}_{i\in [\mlen]})$. 
\end{enumerate}

%In the execution of $\SimExt^{C^*(\rho)}(1^\secpar)$, 
For $i\in [\mlen]$, let $\Good_i$ be the event that there exists $m^*_i$ such that  $m^*_{i} =\VSS_\Recon(\view'_{i,1}, \ldots, \view'_{i,n})$
for all $\{\view'_{i,j}\}_{j\in[n]}$ such that $\view'_{i,j}=\val_{i,j}(\OverExtBCom.\tau)$ or $\val_{i,j}(\OverExtBCom.\tau)=\bot$ for all $j\in[n]$ where $\OverExtBCom.\tau$ is the transcript of $\OverExtBCom$ in \Cref{ExtBCom:com_to_views} 
of the Commit Stage.  Let $\Bad_i$ be the complementary event of $\Good_i$. 
Then for any $i\in [\mlen]$, we have 
\begin{align}\label{eq:Bad_and_acc}
    \Pr[\Bad_i\land b_{\mathrm{com}}=\top]=\negl(\secpar). 
\end{align}
We omit its proof since almost identical claim is proven in \cite[Section 5.2]{C:CCLY22}. \takashi{@Xiao Can you add a brief explanation if needed?}
%We can prove \Cref{eq:Bad_and_acc} by a similar argument which has been used to establish the soundness of the \cite{STOC:IKOS07} commit-and-prove protocol \cite{STOC:IKOS07,FOCS:GLOV12,STOC:GOSV14,C:LiaPan21}. 

It is easy to see that $m_{\ext,i}=m^*_i=\val_i(\tau)$
whenever $\Good_i$ occurs where $\tau$ is the transcript of the commit stage of $\ExtBCom$.  
By the union bound,  \Cref{eq:Bad_and_acc} implies that $\Good_i$ occurs for all $i\in [\mlen]$ whenever $b_{\mathrm{com}}=\top$ except for a negligible probability.  
Thus, whenever $b_{\mathrm{com}}=\top$, $m_{\ext,i}=\val_i(\tau)$ except for a negligible probability. Combined with extractability with over-extraction (as per \Cref{def:sim-ext-bcom:over}), this directly implies extractability  (as per \Cref{def:sim-ext-bcom:strong}).
\end{proof}

\section{Black-Box Post-Quatnum ExtCom-and-Prove}
\label{sec:bb-extcom-n-prove}

\subsection{Definition}
The following definition is taken from \cite{C:CCLY22} with modifications to admit $\negl$-simulation instead of $\epsilon$-simulation for extractability and ZK. 

\begin{definition}[Simulatable ExtCom-and-Prove]
\label{def:com-n-prove}
An ExtCom-and-Prove scheme consists of a pair of protocols $\Prot_{\textsc{ECnP}} = (\algo{ExtCom}, \algo{Prove})$ executed between a pair of \PPT machines $P$ and $V$. Let $m\in \bits^{\ell(\secpar)}$ (where $\ell(\cdot)$ is some polynomial) is a message that $P$ wants to commit to. The protocol consists of the following stages (we omit the input $1^\secpar$ to $P$ and $V$): 
\begin{itemize}
\item 
{\bf Commit Stage:} 
$P(m)$ and $V$ execute $\algo{ExtCom}$, which generates a transcript (commitment) $\com$, 
$P$'s state $\ST_P$, and  
$V$'s decision $b\in \{\top,\bot\}$ indicating acceptance (i.e., $b=\top$) or rejection (i.e., $b=\bot$). We denote this execution as $(\com, \ST_P, b) \gets \langle P(m),V \rangle_\mathsf{EC}$. 
A malicious verifier is allowed to output any quantum state, which we denote by $\ST_{V^*}$ instead of $b$, and to keep the state for the prove stage. 
%$P(m)$ and $V$ execute $\algo{ExtCom}$, after which $V$ output 1 (accept) or 0 (reject). We denote this execution as $(\ST_P, \ST_V, b) \gets \langle P(m),V \rangle_\mathsf{EC}$. where $\ST_P$ (resp.\ $\ST_V$) is the state of $P$ (resp.\ $V$) at the end of this stage and $b\in \bits$ is $V$'s output. 

\item 
{\bf Decommit Stage:}\footnote{This stage is rarely executed in applications.} $P(\ST_P)$ generates a decommitment $\decom$ and sends it to $V$ along with a message $m$. $V$ accepts or rejects. %$P(\ST_P)$ interacts with $V(\ST_V)$, after which $V$ outputs a value in $\bits^{\ell(\secpar)}\cup\Set{\bot}$.

\item 
{\bf Prove Stage:} 
Let $\phi$ be any predicate. $P(\ST_P, \phi)$ and $V(\com,\phi)$ execute $\algo{Prove}$, after which $V$ outputs $\top$ (accept) or $\bot$ (reject). We denote the execution of this stage as $b' \gets \langle P(\ST_P), V(\com) \rangle^\phi_\mathsf{Pr}$, where $b' \in \{\top,\bot\}$ is $V$'s output. 
A malicious verifier is allowed to output an arbitrary quantum state, which we denote by $\OUT_{V^*}$ instead of $b'$. 
%The $b'$ output by a dishonest verifier is allowed be arbitrary (and potentially quantum).
%Let $\phi$ be any predicate. $P(\ST_P, \phi)$ and $V(\ST_V, \phi)$ execute $\algo{Prove}$, after which $V$ outputs 1 (accept) or 0 (reject). We denote the execution of this stage as $b' \gets \langle P(\ST_P), V(\ST_V) \rangle^\phi_\mathsf{Pr}$, where $b' \in \bits$ is $V$'s output. The $b'$ output by a dishonest verifier is allowed be arbitrary (and potentially quantum).
\end{itemize}
The following requirements are satisfied:
\begin{enumerate}
\item \label[Property]{item:com-n-prove:condition:SimExt}
{\bf Security as Simulation Extractable Commitment.} The Commit Stage and Decommit Stage constitute a post-quantum commitment scheme (as per \Cref{def:com} where $P$ and $V$ play the roles of $C$ and $R$, respectively) that is 
computationally hiding, 
statistically binding,    
and extractable. Here, the extractability means the following: \takashi{I explicitly write it here because this is not defined yet.}
There exists a QPT algorithm $\SimExt$ (called the simulation extractor) such that for any non-uniform QPT $C^*(\rho)$, 
\begin{equation*}
\big\{ \SimExt^{C^*(\rho)}(1^\secpar) \big\}_\secpar
\cind
\big\{(\val(\tau), \ST_{C^*}):(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*(\rho), R \rangle(1^\secpar)\big\}_\secpar,  
\end{equation*}
where $\val(\tau)$ is the value committed by $C^*$ as defined in \Cref{def:com-val}.\footnote{We only require computational indistinguishability rather than statistical one unlike \Cref{def:epsilon-sim-ext-com:strong}. This is inherited from \Cref{def:sim-ext-bcom:strong} (see also \Cref{rem:comp_vs_stat_ind}).} 
%\footnote{Extractability is defined similarly to extractability with $\epsilon$-simulation (\Cref{def:epsilon-sim-ext-com:strong}) except that we require full-simulation with a negligible simulation error rather than $\epsilon$-simulation.} 
%(as per ?? \takashi{Need to define extractability with full simulation. I couldn't find its definition in the paper.}).

\item 
{\bf Completeness.} For any $m \in \bits^{\ell(\secpar)}$ and any polynomial-time computable predicate $\phi$ s.t.\ $\phi(m) = 1$, it holds that
\begin{equation}
\Pr[b=\top ~\wedge~ b' =\top : 
\begin{array}{l}
(\com,\ST_P,b) \gets \langle P(m),V \rangle_\mathsf{EC} \\
b' \gets \langle P(\ST_P), V(\com) \rangle^\phi_\mathsf{Pr}
\end{array}
] = 1.
\end{equation}



\item {\bf Soundness.} \label[Property]{item:com-n-prove:condition:soundness}
For any predicate $\phi$ and any non-uniform QPT prover $P^*(\rho)$, 
\begin{equation}
\Pr[
\begin{array}{l}
b=\top ~\wedge~ b' =\top  \\ 
\wedge~ \phi(\val_{\ExtCom}(\com))=0 
\end{array}: 
\begin{array}{l}
(\com, \ST_{P^*}, b) \gets \langle P^*(\rho),V \rangle_\mathsf{EC} \\
b' \gets \langle P^*(\ST_{P^*}), V(\com) \rangle^\phi_\mathsf{Pr}
\end{array}
] = \negl(\secpar),
\end{equation}
where $\val_{\ExtCom}(\com)$ is as defined in \Cref{def:com-val}
and we stipulate that $\phi(\bot) = 0$.




\item {\bf Zero-Knowledge.} \label[Property]{item:com-n-prove:condition:zk}
There exists a pair of QPT simulators $(\Sim_\algo{EC}, \Sim_\algo{Pr})$ such that for any $m \in \bits^{\ell(\secpar)}$, polynomial-time computable predicate $\phi$  s.t.\ $\phi(m) = 1$, any non-uniform QPT verifier $V^*(\rho)$, and any noticeable function $\epsilon(\secpar)$, the following conditions hold:
\begin{align}
& \big\{\tilde{\ST}_{V^*} : (\tilde{\ST}_{V^*}, \ST_\algo{EC})\gets\Sim_\algo{EC}^{V^*(\rho)}\big\}_{\secpar} \cind \big\{\ST_{V^*} : (\com, \ST_P, \ST_{V^*}) \gets \langle P(m),V^*(\rho) \rangle_\mathsf{EC}\big\}_\secpar \label{item:com-n-prove:ZK:condition:1}\\
&\bigg\{\tilde{\OUT}_{V^*} : 
\begin{array}{l}
(\tilde{\ST}_{V^*}, \ST_\algo{EC})\gets\Sim_\algo{EC}^{V^*(\rho)}\\
\tilde{\OUT}_{V^*}  \gets \Sim^{V^*}_\algo{Pr}(1^{\epsilon^{-1}},\tilde{\ST}_{V^*}, \ST_\algo{EC},\phi)
\end{array}
\bigg\}_{\secpar} \cind
\bigg\{ \OUT_{V^*} : 
\begin{array}{l}
(\com, \ST_P, \ST_{V^*}) \gets \langle P(m),V^*(\rho) \rangle_\mathsf{EC} \\
\OUT_{V^*} \gets \langle P(\ST_P), V^*(\ST_{V^*}) \rangle^\phi_\mathsf{Pr}
\end{array}
\bigg\}_\secpar. \label{item:com-n-prove:ZK:condition:2} 
\end{align}
% \begin{enumerate}[leftmargin=*]
% \item \label[Property]{item:com-n-prove:ZK:condition:1}
% $\big\{\tilde{\ST}_{V^*} : (\tilde{\ST}_{V^*}, \ST_\Sim)\gets\Sim_\algo{EC}^{V^*(\rho)}\big\}_{\secpar} \cind \big\{\ST_{V^*} : (\ST_P, \ST_{V^*}, \tau, b) \gets \langle P(x),V^*(\rho) \rangle_\mathsf{EC}\big\}_\secpar$;

% \item \label[Property]{item:com-n-prove:ZK:condition:2}
% $\bigg\{\tilde{b}' : 
% \begin{array}{l}
% \tilde{\ST} \gets\Sim_\algo{EC}^{V^*(\rho)}\\
% \tilde{b}'  \gets \Sim^{V^*}_\algo{Pr}(\ST,\phi)
% \end{array}
% \bigg\}_{\secpar} \cind_\epsilon 
% \bigg\{ b': 
% \begin{array}{l}
% (\ST_P, \ST_{V^*}, \tau, b) \gets \langle P(x),V^*(\rho) \rangle_\mathsf{EC} \\
% b' \gets \langle P(\ST_P), V^*(\ST_{V^*}) \rangle^\phi_\mathsf{Pr}
% \end{array}
% \bigg\}_\secpar.$
% \end{enumerate}
We refer to $\Sim_\algo{EC}$ (resp.\ $\Sim_\algo{Pr}$) as the Commit-Stage (resp.\ Prove-Stage) simulator.
\end{enumerate}
\end{definition}
%\begin{remark}[On the ZK Conditions]\label{remark:com-n-prove:ZK-conditions}
%\Cref{item:com-n-prove:ZK:condition:1} is optional. We include it because our construction achieves it. The zero-knowledge property defined by \Cref{item:com-n-prove:ZK:condition:2} alone should suffice for most applications. 
%\end{remark}


\subsection{Construction of ExtCom-and-Prove}
We construct an ExtCom-and-Prove scheme based on extractable batch commitments. The construction is almost identical to that in \cite[Section 6.5]{C:CCLY22} except that we require full-simulation security instead of $\epsilon$-simulation. 

The construction is shown in \Cref{protocol:ExtCom-n-Prove}. It makes black-box use of the following building blocks:
\begin{enumerate}
\item
The extractable batch commitment (as per \Cref{def:sim-ext-bcom:strong}) $\ExtBCom$ (\Cref{protocol:ExtBCom}), which in turn makes black-box use of any OTs. Note that it is $(O(t(\secpar))+\omega(1))$-round if the assumed OT is $t(\secpar)$-round (\Cref{{thm:ExtBCom}}).

\item An equivocal commitment scheme $\EqCom$ (as per \Cref{def:eqcom}). 
A $\omega(1)$-round construction of it is known assuming only black-box access to post-quantum secure OWFs (\Cref{thm:eqcom}).  


\item
	A constant-round statistically-binding, computationally-hiding commitment $\Com$, (e.g., Naor's commitment).  %This is also known assuming only black-box access to post-quantum secure OWFs.
\item
	An $(n+1,k)$-perfectly verifiable secret sharing scheme $\VSS = (\VSS_{\Share}, \VSS_{\Recon})$ (as per \Cref{def:VSS}). We require that $k$ is a constant fraction of $n$ such that  $k \le n/3$. There are known constructions (without any computational assumptions) satisfying these properties \cite{STOC:BenGolWig88,EC:CDDHR99}.
\item
	A $(n,k)$-perfectly secure MPC protocol $\Prot_\textsc{mpc}$ (as per \Cref{def:MPC}).
\end{enumerate}

\begin{ProtocolBox}[label={protocol:ExtCom-n-Prove}]{ExtCom-and-Prove scheme $\Prot_\textsc{ECnP}$}
{\bf Parameter Setting:} Let $n(\SecPar)$ be a polynomial on $\SecPar$. Let $k$ be a constant fraction of $n$ such that $k \le n/3$.

\para{Input:}
Both the prover $P$ and the verifier $V$ get $1^\SecPar$ as the common input. $P$ in addition gets a string $m \in \bits^{\ell(\SecPar)}$ as his private input, where $\ell(\cdot)$ is a polynomial.

\para{Commit Stage:}
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item \label[Step]{item:ExtCom-n-Prove:commit-stage:1}
$P$ prepares $n$ views $\Set{\msf{v}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $x$ (see \Cref{rmk:mpc-in-the-head-vss} for details). 
\item \label[Step]{item:ExtCom-n-Prove:commit-stage:2}
$P$ and $V$ involve in $\ExtBCom$, where $P$ commits to $(\view_1,...,\view_n)$.
\end{enumerate}
\para{Decommit Stage:}
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item  \label[Step]{item:ExtCom-n-Prove:decommit-stage:1}
$P$ sends $m$ and
$\Set{\view_i}_{i\in [n]}$ together with the corresponding decommitment information w.r.t.\ the $\ExtBCom$ in \Cref{item:ExtCom-n-Prove:commit-stage:2} of the Commit Stage.
\item
$V$ checks that all the decommitments in \Cref{item:ExtCom-n-Prove:decommit-stage:1} of the Decommit Stage are valid and $m=\VSS_\Recon(\view_1, \ldots, \view_n)$. If so, it accepts and otherwise rejects. 
\end{enumerate}

\para{Prove Stage:} Both parties learn a polynomial-time computable predicate $\phi$.
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item \label[Step]{item:ExtCom-n-Prove:prove-stage:1}
$P$ prepares $n$ views $\Set{\msf{v}'_i}_{i \in [n]}$ corresponding to an $(n, k)$-MitH execution for the functionality $F_\phi$ described below, where party $P_i$ uses $\msf{v}_i$ as input. It then commits to each of these views $\msf{v'}_i$ independently in parallel using $\Com$. 
    \begin{itemize}
        \item {\bf Functionality $F_\phi$:} This collects inputs $\msf{v}_i$ from party $i$, runs $\VSS_\Recon$ on these inputs to recover a value $x$, and outputs $\phi(x)$. 
    \end{itemize} 
\item \label[Step]{ExtCom-n-Prove:CF}
$P$ and $V$ engage in the following coin-flipping subprotocol as detailed below.  
\begin{enumerate}
\item \label[Step]{ExtCom-n-Prove:com_to_theta_P}
$P$ samples a random string $\theta_P$ of proper length and commits to it using $\EqCom$. 
\item \label[Step]{ExtCom-n-Prove:send_theta_V}
$V$ samples a random string $\theta_V$ of proper length and sends it to $P$.  
\item \label[Step]{ExtCom-n-Prove:reveal_theta_P}
$P$ sends to $V$ the value $\theta_P$ together with the corresponding decommitment information w.r.t. the $\EqCom$ in \Cref{ExtCom-n-Prove:com_to_theta_P}. Now, $P$ and $V$ agree on a random string $\theta \coloneqq \theta_P \xor \theta_V$. By a proper choice of length, the string $\theta$ it can be interpreted as specifying a size-$k$ random subset $\eta\subset [n]$. 
\end{enumerate} 
%\begin{enumerate}
%\item \label[Step]{ExtCom-n-Prove:com_to_theta_V}
%$V$ samples a random string $\theta_V$ of proper length and commits to it using $\ExtBCom$ where we use $\ExtBCom$ as a stand-alone extractable commitment (which corresponds to the case of $n=1$ in \Cref{def:bcom,def:sim-ext-bcom:strong}).  
%\item \label[Step]{ExtCom-n-Prove:send_theta_P}
%$P$ samples a random string $\theta_P$ of proper length and sends it to $P$.  
%\item \label[Step]{ExtCom-n-Prove:reveal_theta_V}
%$V$ sends to $P$ the value $\theta_V$ together with the corresponding decommitment information w.r.t. the $\ExtBCom$ in \Cref{ExtCom-n-Prove:com_to_theta_V}. Now, $P$ and $V$ agree on a random string $\theta \coloneqq \theta_V \xor \theta_P$. By a proper choice of length, the string $\theta$ it can be interpreted as specifying a size-$k$ random subsets $\eta\subset [n]$. 
%\end{enumerate} 
\item \label[Step]{item:ExtCom-n-Prove:prove-stage:6}
$P$ sends to $V$ in {\em one round} the following messages:
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item \label[Step]{item:ExtCom-n-Prove:prove-stage:6:a}
$\Set{\view_i}_{i \in \eta}$ together with the corresponding decommitment information w.r.t.\ the $\ExtBCom$ in \Cref{item:ExtCom-n-Prove:commit-stage:2} of the Commit Stage; {\bf and}
\item \label[Step]{item:ExtCom-n-Prove:prove-stage:6:b}
$\Set{\view'_i}_{i \in \eta}$ together with the corresponding decommitment information w.r.t.\ the $\Com$ in \Cref{item:ExtCom-n-Prove:prove-stage:1} of the Prove Stage.
\end{enumerate}
\item 
$V$ checks the following conditions:
\begin{enumerate}[topsep=0pt,itemsep=0pt]
\item \label[Step]{item:ExtCom-n-Prove:prove-stage:7:a}
All the decommitments in \Cref{item:ExtCom-n-Prove:prove-stage:6:a,item:ExtCom-n-Prove:prove-stage:6:b} are valid; {\bf and}
\item \label[Step]{item:ExtCom-n-Prove:prove-stage:7:b}
for any $i\in \eta$, $\view_i$ is the prefix of $\view'_i$ ; {\bf and}
\item \label[Step]{item:ExtCom-n-Prove:prove-stage:7:c}
for any $i,j\in \eta$, views $(\view'_i, \view'_j)$ are consistent (as per \Cref{def:view-consistency} and \Cref{rmk:VSS:view-consistency}) w.r.t.\ the 
$\VSS_\Share$ execution in \Cref{item:ExtCom-n-Prove:commit-stage:1} of the Commit Stage
and the $\Prot_\textsc{mpc}$ execution as described in \Cref{item:ExtCom-n-Prove:prove-stage:1} of the Prove Stage.
\end{enumerate}
If all the checks pass, $V$ accepts; otherwise, $V$ rejects.
\end{enumerate}
\end{ProtocolBox}

\begin{theorem}\label{thm:extcom-n-prove}
Assume the existence of $t(\secpar)$-round semi-honest OTs. Then, there exists a $(O(t(\secpar))+\omega(1)$-round construction of an ExtCom-and-Prove scheme $\Prot_\textsc{ECnP}$ (i.e., \Cref{protocol:ExtCom-n-Prove}) satisfying \Cref{def:com-n-prove}. Moreover, this construction makes only black-box use of the assumed OT.
\end{theorem}

This can be proven similarly to the security proof of $\epsilon$-ExtCom-and-Prove in \cite[Section 6.5]{C:CCLY22}. The only differences from their construction are that 
\begin{enumerate}
\item we use fully-simulatable extractable batch commitments to commit to the views in \Cref{item:ExtCom-n-Prove:commit-stage:2} whereas they use $\epsilon$-simulatable parallel extractable commitments, and
\item we implement the coin-flipping subprotocol \Cref{ExtCom-n-Prove:CF} using equivocal commitments instead whereas they used $\epsilon$-simulation extractable commitments. \takashi{Originally, I wrote the coin-flipping step by using $\ExtBCom$ to look more similar to CCLY. 
But I found using $\EqCom$ will be slightly better in terms of round-complexity, and thus I did so.
}  
\end{enumerate}

The difference between full-simulation and $\epsilon$-simulation is directly connected to that we achive full-simulation instead of $\epsilon$-simulation for the resulting protocol. 
For the coin-flipping subprotocol, what we need here is \emph{one-sided} simulation security where we require simulation-based security against malicious verifiers but only require a weaker security against malicious provers that they cannot bias the result of coin-flipping.   
This can be achieved using either equivocal commitments as is done here or extractable commitments as is done in \cite[Section 6.5]{C:CCLY22}. With the above remarks in mind, it is straightforward to adapt the proof in \cite[Section 6.5]{C:CCLY22} to our setting. 
Thus, we omit the proof of \Cref{thm:extcom-n-prove}.
%Since the security proof is almost identical to that in \cite[Section 6.5]{C:CCLY22}, we omit it. 
\takashi{Okay?}