%!TEX root = ../main.tex

\section{Post-Quantum Non-Malleable Commitments: One-to-One and One-sided}
\label{sec:PQNMC:1-1}
We present a black-box, constant-round construction of post-quantum non-malleable commitment in the synchronous setting and supporting a polynomial number of tags. The construction shown in this section is non-malleable under the `one-sided' assumption, i.e., its non-malleability holds in the 1-1 MIM execution where the left-session tag $t$ is strictly smaller than the right-session tag $\tilde{t}$. This constraint will be subsequently alleviated in \Cref{sec:two-sided:main-body}. 

\subsection{Construction}
\label{sec:BB-NMC:construction}

The construction is described in \Cref{protocol:BB-NMCom}. It makes black-box use of the following building blocks:
\begin{enumerate}
\item
The post-quantum parallelly extractable commitment scheme $\ExtCom$ with $\epsilon$-simulation \Cref{def:epsilon-sim-ext-com:parallel}, which can be built in black-box from any post-quantum OWFs (see \Cref{lem:parallel-extcom:CCLY}).

\item
    A post-quantum commitment scheme that is statistically-binding and computationally-hiding (against QPT adversaries). This is also known assuming only black-box access to post-quantum secure OWFs. In particular, we will make use of Naor's commitment which can be built in black-box from any post-quantum OWFs as well.
     % as a commitment of this kind, and in the following we will treat it as a non-interactive commitment scheme (which amounts to a slight abuse of notation). 
\item
     A perfectly secure verifiable secret sharing scheme $\VSS = (\VSS_{\Share}, \VSS_{\Recon})$ (as per \Cref{def:VSS}); We will set the parameters to make use of an $(n+1, k)$ scheme and an $(n+1, 2k)$ scheme. See \Cref{protocol:BB-NMCom} for details.
\item
    A semi-honest computationally private and perfectly robust MPC protocol (see \Cref{rmk:exact-mpc-requriements:mpc-in-the-head}); We will set the parameters to make use of an $(n, k)$ scheme and an $(n, 2k)$ scheme. See \Cref{protocol:BB-NMCom} for details. 
\end{enumerate}
We remark that the MPC and VSS are used to implement the MPC-in-the-Head (MitH) technique as explained in \Cref{sec:prelim:MitH}.


%\xiao{Say that in the following, we assume the Naor's commitment is non-interactive.}
%\xiao{Change $\tau$ to $k$.}
\begin{ProtocolBox}[label={protocol:BB-NMCom}]{One-Sided PQ-NMC: Black-Box and Constant-Round}
{\bf Parameter Setting:} The tag space is defined to be $[T]$, where $T$ is a polynomial in the security parameter $\secpar$. Let $n$ be a polynomial in $\SecPar$, and $k$ be a constant fraction of $n$ such that $2k \le n/3$. 

\para{Input:}
Both the committer $C$ and the receiver $R$ get the security parameter $1^\secpar$ and a tag $t \in [T]$ as the common input; $C$ gets a string $m \in \bits^{\ell(\SecPar)}$ as its private input, where $\ell(\cdot)$ is a polynomial. 

\para{Commit Phase:}
\begin{enumerate}
\item\label[Step]{bbnmc:init-com}
{\bf (Initial Com to $m$.)} In this stage, $C$ commits to the message (using the MPC-in-the-head approach).
\begin{itemize}
\item $C$ prepares $n$ views $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, 2k)$-$\VSS_\Share$ of the message $m$ (as detailed in \Cref{rmk:mpc-in-the-head-vss}). $C$ commits to each $\msf{cv}^{(1)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\end{itemize}

% \begin{remark}\label{rmk:mpc-in-the-head-vss}
%  We describe this step more explicitly. $C$ emulates $n+1$ virtual parties $\Set{P_i}_{i \in [n+1]}$ `in its head'. Party $P_{n+1}$ is the dealer, possessing the string $m$. Other parties do not have any input. These parties execute the $\VSS_\Share$ stage of the $(n+1,2k)$-VSS scheme to compute the functionality $\VSS_\Share$. At the end of the execution, $P_i$ ($i\in [n]$) obtains the $i$-th $\VSS$ share of $m$ as the output, and $P_{n+1}$ does not receive any output. The $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$ corresponds to the views of  $\Set{P_i}_{i \in [n]}$ from this execution (emulated in $C$'s head).
%  \end{remark} 

\item \label[Step]{bbnmc:hard-puzzle:puzzle-setup}
{\bf (Hard Puzzle Setup.)} In this stage, $R$ sets up a $t$-solution hard puzzle. It then commits to one solution of the puzzle and proves in zero-knowledge the consistency (using the MPC-in-the-head approach).
\begin{enumerate}

\item \label[Step]{bbnmc:hard-puzzle:com-ch}
$C$ samples a size-$k$ random subset $\msf{ch} \subseteq [n]$, and commits to it using $\ExtCom$. 

\item \label[Step]{bbnmc:hard-puzzle:rv-1}
$R$ samples $t$ random strings $x_1,\dots,x_t \pick \bits^\secpar$. $R$ prepares $n$ views $\Set{\msf{rv}^{(1)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $x_1 \| \ldots \|x_t$ (as detailed in \Cref{rmk:mpc-in-the-head-vss}). $R$ commits to each $\msf{rv}^{(1)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.

\item \label[Step]{bbnmc:hard-puzzle:rv-2}
$R$ prepares another $n$ views $\Set{\msf{rv}^{(2)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $1\|x_1$ (as detailed in \Cref{rmk:mpc-in-the-head-vss}).  $R$ commits to each $\msf{rv}^{(2)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$.

\item \label[Step]{bbnmc:hard-puzzle:rv-3}
$R$ then prepares another $n$ views $\Set{\msf{rv}^{(3)}_i}_{i \in [n]}$, corresponding to an  $(n, k)$-MitH execution of the $n$-party functionality $F^R_{\msf{consis}}$ described below (intuitively, $F^R_{\msf{consis}}$ checks the consistency between \Cref{bbnmc:hard-puzzle:rv-1} and \Cref{bbnmc:hard-puzzle:rv-2}), where party $P_i$ ($i\in [n]$) uses $\msf{rv}^{(1)}_i \| \msf{rv}^{(2)}_i$ as input. (Note that $\msf{rv}^{(1)}_i \| \msf{rv}^{(2)}_i$ will be a prefix of $\msf{rv}^{(3)}_i$.)  $R$ commits to each $\msf{rv}^{(3)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\begin{itemize}
\item {\bf Functionality  $F^R_{\msf{consis}}$:} It collects  input (and parses it as) $\msf{rv}^{(1)}_i \| \msf{rv}^{(2)}_i$ from party $i$ for each $i \in [n]$. It then runs the recovery algorithm of $\VSS$ to obtain $a_1\|\ldots\|a_t \coloneqq \VSS_\Recon(\msf{rv}^{(1)}_1, \ldots, \msf{rv}^{(1)}_n)$ and $j\|b_{j} \coloneqq \VSS_\Recon(\msf{rv}^{(2)}_1, \ldots, \msf{rv}^{(2)}_n)$. If $j \in [t]$ and $b_{j} = a_{j}$, it outputs 1 to each party; otherwise, it outputs 0 to each party.
\end{itemize}

\item \label[Step]{bbnmc:hard-puzzle:decom-ch}
$C$ sends $\msf{ch}$ together with the decommitment information (w.r.t.\ \Cref{bbnmc:hard-puzzle:com-ch}).
\item \label[Step]{bbnmc:hard-puzzle:open}
$R$ sends $\Set{(\msf{rv}^{(1)}_i, \msf{rv}^{(2)}_i, \msf{rv}^{(3)}_i)}_{i \in \msf{ch}}$ together with the decommitment information (w.r.t.\ their respective commitments in \Cref{bbnmc:hard-puzzle:rv-1,bbnmc:hard-puzzle:rv-2,bbnmc:hard-puzzle:rv-3}).
\item
$C$ checks the validity of the decommitment information and the consistency among the revealed views $\Set{(\msf{rv}^{(1)}_i, \msf{rv}^{(2)}_i, \msf{rv}^{(3)}_i)}_{i \in \msf{ch}}$. In particular, it checks for each $i \in \msf{ch}$ that $\msf{rv}^{(1)}_i\| \msf{rv}^{(2)}_i$ is the prefix of $\msf{rv}^{(3)}_i$. It also checks for each distinct pair $i, j\in \msf{ch}$ that $(\msf{rv}^{(1)}_i, \msf{rv}^{(1)}_j)$ are consistent, $(\msf{rv}^{(2)}_i, \msf{rv}^{(2)}_j)$ are consistent, and $(\msf{rv}^{(3)}_i, \msf{rv}^{(3)}_j)$ are consistent, where by `consistent' we refer to the consistency requirements as per \Cref{def:view-consistency} and \Cref{rmk:VSS:view-consistency}. It also checks for each $i\in \msf{ch}$ the final output of $P_i$ contained in $\msf{rv}^{(3)}_i$ is 1. It aborts immediately if any of the checks fail.
\end{enumerate}

\item \label[Step]{prot:bbnmc:extcom}
{\bf (ExtCom to $m$.)} $C$ commits to $m$ once again, using $\ExtCom$ in the MitH format. In more detail:
\begin{itemize}
\item
$C$ prepares $n$ views $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, 2k)$-$\VSS_\Share$ of the message $m$ (as detailed in \Cref{rmk:mpc-in-the-head-vss}). $C$ commits to each $\msf{cv}^{(2)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$.
\end{itemize}
We remark that this step can be viewed as the {\bf Commit Stage} of the trapdoor coin-flipping protocol shown in \Cref{prot:td:ct}. Here are two key points we want to emphasize: (1) The original \Cref{prot:td:ct} uses Naor's commitment for this stage, but here we instead use $\ExtCom$. This is to make this commitment extractable. (2) The original \Cref{prot:td:ct} uses a $(n+1, k)$-VSS scheme, but here we instead use a $(n+1, 2k)$ VSS scheme. That is because we need to open two subsets of size $k$, one in \Cref{prot:bbnmc:cointoss}, which is the {\bf Coin-Flipping Stage}, and the other in \Cref{prot:bbnmc:mpc:reveal}, which is for the proof of consistency of the current PQ-NMC protocol.

These modifications will be important later when we prove non-malleability.

\item\label[Step]{prot:bbnmc:puzzle-sol-reveal}
{\bf (Puzzle Solution Reveal.)} $R$ reveals $(x_1, \ldots, x_t)$ by decommitting to $\Set{\msf{rv}^{(1)}_i}_{i \in [n]}$. In more detail,
\begin{enumerate}
\item
$R$ sends $\Set{\msf{rv}^{(1)}_i}_{i \in [n]}$ together with the decommitment information w.r.t.\ the commitments in \Cref{bbnmc:hard-puzzle:rv-1}.
\item
$C$ checks the validity of the decommitment information and the consistency among $\Set{\msf{rv}^{(1)}_i}_{i\in [n]}$ (as per \Cref{rmk:VSS:view-consistency}). If these checks are successful, $C$ recovers $x_1 \| \ldots \|x_t \coloneqq \VSS_\Recon(\msf{rv}^{(1)}_1, \ldots, \msf{rv}^{(1)}_n)$; otherwise, $C$ rejects and output $\bot$. 
\end{enumerate}



\item \label[Step]{prot:bbnmc:PoC}
{\bf (Committer's Consistency Proof.)} This stage should be interpreted as $C$ proving consistency between its actions in \Cref{bbnmc:init-com,prot:bbnmc:extcom} (i.e., these two steps commit to the same value) using a witness indistinguishable argument, where the trapdoor statement is that $C$ manages to commit to a puzzle solution in \Cref{prot:bbnmc:extcom}. This step is again conducted in the MitH format. Note that for the honest committer, the `effective witness' in MitH is the message $m$ reconstructed from both $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$ and $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, and so the virtual MPC execution in reality evaluates the `first clause' of $F^C_{\msf{consis}}$ as defined below. In more detail, this stage proceeds as follows.
\begin{enumerate}
\item\label[Step]{prot:bbnmc:C-consis-com}
$C$ prepares $n$ views $\Set{\msf{cv}^{(3)}_i}_{i \in [n]}$, corresponding to an $(n,2k)$-MitH execution of the $n$-party functionality $F^C_{\msf{consis}}$ described below, where party $P_i$ ($i\in [n]$) uses $\msf{cv}^{(1)}_i \| \msf{cv}^{(2)}_i$ as input. (Note that $\msf{cv}^{(1)}_i \| \msf{cv}^{(2)}_i$ will be the prefix of $\msf{cv}^{(3)}_i$.)  $C$ commits to each $\msf{cv}^{(3)}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\begin{itemize}
\item {\bf Functionality  $F^C_{\msf{consis}}$:} It collects input (and parses it as) $\msf{cv}^{(1)}_i \| \msf{cv}^{(2)}_i$ from party $i$ for each $i \in [n]$. It then runs the recovery algorithm of $\VSS$ to obtain $a \coloneqq \VSS_\Recon(\msf{cv}^{(1)}_1, \ldots, \msf{cv}^{(1)}_n)$ and $b \coloneqq \VSS_\Recon(\msf{cv}^{(2)}_1, \ldots, \msf{cv}^{(2)}_n)$. It outputs 1 to each party if {\em either}
\begin{itemize}
\item
(First clause.) $b = a$, {\em or}
\item
(Second clause.) $b$ can be parsed as $j\|x'$ such that $j\in [t]$ and $x' = x_j$ (recall that $x_j$ is among the puzzle solutions revealed by $R$ in \Cref{prot:bbnmc:puzzle-sol-reveal}.
\end{itemize} 
Otherwise, it outputs 0 to each party.
\end{itemize}

\item\label[Step]{prot:bbnmc:cointoss}
{\bf (Trapdoor Coin-Flipping)} $C$ and $R$ then execute the {\bf Coin-Flipping Stage} of the trapdoor coin-flipping protocol shown in \Cref{prot:td:ct}, with the trapdoor predicate $\phi(\cdot)$ defined as follows
\begin{itemize}
\item
{\bf Predicate $\phi(\cdot)$:} It has the values $(x_1, \ldots, x_t)$ hard-wired (recall that these values are revealed in \Cref{prot:bbnmc:puzzle-sol-reveal}). On input $i\|a$, it outputs 1 iff  $i\in [t]$ and $a = x_i$.
\end{itemize}
By the completeness of the trapdoor coin-flipping protocol (i.e., \Cref{def:com-n-prove:property:2} in \Cref{def:com-n-prove}), at the end of this step, $C$ and $R$ agree on a string $\eta$. By a proper choice of length, the string $\eta$ can be interpreted as specifying a size-$k$ random subset of $[n]$. In the following, we abuse notation by using $\eta$ to denote the corresponding size-$k$ random subset.


\item\label[Step]{prot:bbnmc:mpc:reveal}
$C$ sends $\Set{(\msf{cv}^{(1)}_i, \msf{cv}^{(2)}_i, \msf{cv}^{(3)}_i)}_{i \in \eta}$ together with the decommitment information (w.r.t.\ their respective commitments in \Cref{bbnmc:init-com,prot:bbnmc:extcom,prot:bbnmc:C-consis-com}).

\item
$R$ checks the validity of the decommitment information and the consistency among the revealed views $\Set{(\msf{cv}^{(1)}_i, \msf{cv}^{(2)}_i, \msf{cv}^{(3)}_i)}_{i \in \eta}$.  
% In particular, it checks for each $i \in \eta$ that $\msf{cv}^{(1)}_i\| \msf{cv}^{(2)}_i$ is the prefix of $\msf{cv}^{(3)}_i$. It also checks for each distinct pair $i, j\in \eta$ that $(\msf{cv}^{(1)}_i, \msf{cv}^{(1)}_j)$ are consistent, $(\msf{cv}^{(2)}_i, \msf{cv}^{(2)}_j)$ are consistent, and $(\msf{cv}^{(3)}_i, \msf{cv}^{(3)}_j)$ are consistent, where by `consistent' we refer to the consistency requirements as per \Cref{def:view-consistency} and \Cref{rmk:VSS:view-consistency}.  
It also checks for each $i\in \eta$ the final output of $P_i$ contained in $\msf{cv}^{(3)}_i$ is 1. $R$ aborts if any of these checks fail.
\end{enumerate}

\end{enumerate}



\para{Decommit Stage:} 
\begin{enumerate}
\item
$C$ sends $\Set{\msf{cv}^{(1)}_i}_{i\in [n]}$ together with the decommitment information w.r.t.\ the commitments in \Cref{bbnmc:init-com}. 
\item
$R$ checks the validity of the decommitment information and the consistency among $\Set{\msf{cv}^{(1)}_i}_{i\in [n]}$ (as per \Cref{rmk:VSS:view-consistency}). If these checks are successful, $R$ recovers $m$ as $m \coloneqq \VSS_\Recon(\msf{cv}^{(1)}_1, \ldots, \msf{cv}^{(1)}_n)$; otherwise, $R$ rejects and output $\bot$. 
\end{enumerate}

\end{ProtocolBox}

\para{Security.} The security of \Cref{protocol:BB-NMCom} is stated as the following theorem.
\begin{theorem}\label{thm:one-sided:non-malleability}
 Assuming the existence of post-quantum one-way functions, there exists (i.e., \Cref{protocol:BB-NMCom}) a black-box, constant-round construction of 1-1 post-quantum non-malleable commitments (as per \Cref{def:NMCom:pq} with $k=1$) in synchronous setting, with one-sided security, and supporting tag space $[T]$ with $T(\secpar)$ being any polynomial in the security parameter $\secpar$.
\end{theorem}   
It is straightforward to see that \Cref{protocol:BB-NMCom} is constant-round and makes only black-box use of its underlying cryptographic components. Completeness of \Cref{protocol:BB-NMCom} is also straightforward from the protocol description. The statistical binding property follows from that of Naor's commitment in \Cref{bbnmc:init-com}. Computational-hiding property of any non-malleable commitment scheme follows directly from its non-malleability. So, to prove \Cref{thm:one-sided:non-malleability}, we only need to prove the post-quantum non-malleability of \Cref{protocol:BB-NMCom}, which we prove in subsequent subsections.

\subsection{Outline for the Proof of Non-Malleability}
\label{sec:BB-PQNMC:1-1:proof:outline}
The proof for the non-malleability of \Cref{protocol:BB-NMCom} is very involved and lengthy. To help the reader understand it better, we provide an outline delving into it.

Recall from \Cref{def:NMCom:pq} (with $k =1$) that to prove non-malleability of \Cref{protocol:BB-NMCom}, we consider the synchronous 1-1 MIM execution of \Cref{protocol:BB-NMCom} where the left session uses tag $t$ and the right session uses tag $\tilde{t}$. Also recall that $\tilde{t} \ge t+1$ since we focus on the `one-sided' setting. We need to show that for any QPT MIM adversary $\mcal{M}_\secpar(\rho_\secpar)$, it holds that
\begin{equation}\label{thm:pqnmc:eq:target}
\big\{\msf{mim}^{\mcal{M}_\secpar}(m_0, \rho_\secpar)\big\}_{\secpar \in \Naturals, m_0, m_1 \in \bits^{\ell(\secpar)}} ~\cind~ \big\{\msf{mim}^{\mcal{M}_\secpar}( m_1, \rho_\secpar)\big\}_{\secpar \in \Naturals, m_0, m_1 \in \bits^{\ell(\secpar)}},
\end{equation}
where $\msf{mim}^{\mcal{M}_\secpar}(m_b, \rho_\secpar)$ denotes the {\em joint} distribution of the output of $\mcal{M}_\secpar$ {\em and} the value $\tilde{m}$ committed in the right session, where the left (honest) committer $C$ commits to message $m_b$.

At a high level, our proof follows the template from \cite{FOCS:LPY23}. We reduce non-malleability to the computational-hiding property of the Naor's commitment in \Cref{bbnmc:init-com} of the left session. That is, we consider in the MIM execution that the Naor's commitment in \Cref{bbnmc:init-com} of the left session comes from an external challenger, committing to an underlying message $m_b$ with $b$ picked uniformly from $\bits$. Our goal is to construct a machine $\SimExt$ (dubbed simulation-extractor) that can efficiently extract the value $\tilde{m}$ committed by $\mcal{M}_\secpar$ in the left session, while simulating $\mcal{M}_\secpar$'s post-extraction state (possibly with an arbitrarily small simulation error $\epsilon$). Note that if such an $\SimExt$ exists, it indeed {\em efficiently} outputs the value $\msf{mim}^{\mcal{M}_\secpar}(m_b, \rho_\secpar)$ (which was not efficiently computable since the $\tilde{m}$ value is hidden in the transcript). Then, if \Cref{thm:pqnmc:eq:target} does not hold, $\SimExt$'s output will be distinguishable when the external challenger changes the committed value between $m_0$ and $m_1$. This breaks the computational hiding property of Naor's commitment.

However, there are some challenges in implementing this template. 
\begin{enumerate}
    \item
    First, note that the message $m$ committed in \Cref{bbnmc:init-com} of the left session is used again in \Cref{prot:bbnmc:extcom} of the left session. Thus, to be able to forward the left \Cref{bbnmc:init-com} to the external challenger, we have to come up with some method to avoid using the underlying $m$ in \Cref{prot:bbnmc:extcom} of the left session (as this $m$ is known only to the external challenger in the reduction we outlined above).
    \item
    In sharp contrast to the original \cite{FOCS:LPY23} construction, \Cref{bbnmc:init-com} of our \Cref{protocol:BB-NMCom} is not a Naor's commitment to the underlying message $m$. Rather, it is a parallel execution of Naor's scheme committing to $n$ VSS shares of the message $m$.     Moreover, note that \Cref{bbnmc:init-com,prot:bbnmc:extcom,prot:bbnmc:PoC} of \Cref{protocol:BB-NMCom} essentially consist of a black-box commit-and-prove protocol, where $C$ first commits to two messages in \Cref{bbnmc:init-com,prot:bbnmc:extcom} respectively, and then proves a predicate $F^C_{\msf{consis}}$ over the two committed values. This structure induces new challenges: Even if we can make \Cref{prot:bbnmc:extcom} independent of the $m$ committed in \Cref{bbnmc:init-com}, it still need to reveal some of the shares committed in \Cref{bbnmc:init-com} when proving consistency in \Cref{prot:bbnmc:PoC} (in particular, in \Cref{prot:bbnmc:mpc:reveal}). 
\end{enumerate}
Resolving these issues requires us to use new ideas described in \Cref{sec:tech-overview}. In more detail, we will first show that {\em assume the existence of the $\SimExt$}, we can still follow the same template but rather reduce non-malleability to the VSS hiding game shown in \Cref{chall:vss:hide}, instead of to the vanilla Naor's commitment. We then show that the desired $\SimExt$ can indeed be constructed. In the following, we present an outline for these two steps.

\para{Reducing Non-Malleability to VSS Hiding.} This step is performed in \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding}. It is organized as follows.
\begin{enumerate}
\item
We the first `decouple’ the the committed message in \Cref{bbnmc:init-com} of the left session from the remaining steps. To do that, we design a game $\tilde{H}^{\mcal{M}_\secpar}$ in \Cref{pq:game:Htil}. This $\tilde{H}^{\mcal{M}_\secpar}$ is essentially identical to the 1-1 MIM execution, but makes use of a new machine $\mcal{G}_1$ (in \Cref{pq:machine:g1}) to finish the steps after \Cref{bbnmc:init-com}. A key feature of $\mcal{G}_1$ is that it does not need to know the $m$ committed in \Cref{bbnmc:init-com} of the left session.


\item
Next, we define another game $\tilde{G}^{\mcal{M}_\secpar}$ (in \Cref{pq:game:Gtil}), which performs \Cref{bbnmc:init-com} in the same manner as $\tilde{H}^{\mcal{M}_\secpar}$, but replace the $\mcal{G}_1$ machine by a simulation extractor $\SimExt$ {\em that we assume to exist}. We will show (in \Cref{lem:simext:closeness}) that this $\SimExt$ can extract from $\mcal{G}_1$ the $\tilde{m}$ committed by $\mcal{M}_\secpar$ in the right session, while simulating the post-extraction state of $\mcal{G}_1$ (with a noticeable error $\epsilon$ that can be made arbitrarily small).
\item
Finally, we show that the machine $\tilde{G}^{\mcal{M}_\secpar}$ is designed on purpose so that we can reduce non-malleability to the VSS hiding game. This is done in \Cref{bbnmc:proof:fin}.
\end{enumerate}

\para{Building Simulation-Extractor $\mcal{SE}$.} To build the desired $\mcal{SE}$, we first build a machine $\mcal{K}$ that is able to extract the correct $\tilde{m}$ from the machine $\mcal{G}_1$ mentioned above. But $\mcal{K}$ is not capable of simulating the post-extraction state of $\mcal{G}_1$. We will also show that $\mcal{K}$ satisfies some extra requirements so that we can later convert it to an extractor {\em with simulation}. The description of $\mcal{K}$ and the proof for its properties are the focus of \Cref{sec:simless-ext:1-1}.

We then show how to equip $\mcal{K}$ with simulation in \Cref{sec:simext:1-1}. To do that, we first need a generalization of the counterpart lemma from \cite[Lemma 20]{arXiv:LPY23}. This is because our construction makes heavy use of black-box commit-and-prove techniques so that the simulation-less extractor $\mcal{K}$ satisfies only weaker properties than its counterpart in \cite[Lemma 31]{arXiv:LPY23}. In particular, our $\mcal{K}$ cannot check if the value it extracted is indeed the correct $\tilde{m}$. Thus, we need to generalize the simulation-extraction lemma in \cite[Lemma 20]{arXiv:LPY23} to take care of related issues. This is handled in \Cref{sec:noisy-sim-ext}.

Finally, with all the preparatory work before, we can eventually convert our $\mcal{K}$ to the desired $\mcal{SE}$ using the a `noisy' simulation-extraction lemma developed in \Cref{sec:noisy-sim-ext}. This is done in \Cref{sec:sim-less-to-sim:1-1}.

This finishes the outline for our proof of non-malleability.






% Before showing this formally, we provide the reader with an informal overview that also points to relevant sections of the proof. 

% \begin{itemize}
%     \item Our goal is to show non-malleability. Intuitively, this involves saying that the view of a man-in-the-middle attacker $\mcal{M}$'s interaction, {\em along with its committed value in the right interaction}, is indistinguishable regardless of what is committed to on the left. Again intuitively, to show this, we need a mechanism to extract the $\mcal{M}$’s value on the right, and ensure it does not change depending on what is committed to by the honest committer on the left. 
%     \item To show this, the first intuitive task is to then `decouple’ the components in the left hand execution from the committed message. We design the game $\tilde{H}^{\mcal{M}_\secpar}$ defined in \Cref{pq:game:Htil} (this involves the procedure $\mcal{G}_1$) that achieves this. We show that $\tilde{H}^{\mcal{M}_\secpar}$ has outputs that are computationally indistinguishable from the standard man-in-the-middle interaction (and that $\mcal{M}$'s committed value on the right remains unchanged) in \Cref{lem:Htil:similarity}.
%     \item Having achieved this, the second task is to efficiently extract the adversary’s committed value on the right. Note that this takes great care in the post-quantum setting, since we can no longer rely on standard rewinding-based extraction techniques. We perform further modifications on $\tilde{H}^{\mcal{M}_\secpar}$ to get a game $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$ (in \Cref{pq:game:Gtil}) that is able to obtain this value. $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$ uses a dedicated simulator-extractor $\SimExt$ for this task. Describing such a $\SimExt$ and showing it works is the subject of \Cref{sec:SimExt}. We show that $\tilde{H}^{\mcal{M}_\secpar}$ and $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$ have computationally indistinguishable outputs (and that $\mcal{M}$'s committed value on the right remains unchanged) in \Cref{lem:bbnmc:compare:Htil:Gtil}. 
%     \item Finally, after making these modifications, it remains to show that $\mcal{M}$ cannot change its commitments in response to the left hand committer changing its committed values. We remark that this is not a simple reduction to the hiding property of the commitments, because the commitments in our protocol are actually to VSS shares of the message. This requires a more careful design of the reduction, and is achieved in two steps. 
%     \item The first step: defining a hiding-style challenge game $\VSS_\algo{HIDE}$ (from \Cref{chall:vss:hide}) based on the security properties of $\VSS$ schemes. This mimics the interaction within our protocol, where the challenger chooses a message and commits to VSS shares of it. The adversary learns a few specific (decommitments to) shares of its choice — but not enough to reconstruct the message. It then has to guess this message. We show $\VSS_\algo{HIDE}$ reduces directly to perfect secrecy of $\VSS$, and use this in place of computational binding of $\Com$ for our reduction (as would seem more straightforward). The reason is that we cannot simply work with the committed values directly for our reduction (when, say swapping in a challenger’s commitment in the left side interaction) but in fact need some of the VSS shares opened for the MPC-in-the-head style interactions. 
%     \item The second step: we design a reduction to $\VSS_\algo{HIDE}$ based on the game $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$. This reduction will externally participate in the challenge $\VSS_\algo{HIDE}$ while internally running the machine $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$, which essentially just takes in a left side commitment (and corresponding VSS share openings) and then runs the simulator-extractor $\SimExt$ on $\mcal{M}$. In turn the reduction obtains the value committed to on the right by $\mcal{M}$. If there is now a successful distinguisher for the outputs of $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$, the reduction can then use it on this output to win the hiding game. This captured by \Cref{lem:bb-nmc:similarity:g:til}. One crucial thing that allows the reduction to succeed is the fact that $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$ really uses {\em no other information} about the left side committer except the initial commitment that it takes in from the challenger of $\VSS_\algo{HIDE}$, as well as the corresponding opened shares. 
%     \item Above, we have outlined a pathway to show that the outputs of $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$ (using $\mcal{M}$) are computationally indistinguishable when committing to different values on the left. We have also shown that modifications introduced in $\tilde{H}^{\mcal{M}_\secpar}$ and $\tilde{G}_\epsilon^{\mcal{M}_\secpar}$ (w.r.t. the standard MIM interaction) are indistinguishable to $\mcal{M}$ and also do not change its committed value on the right (in \Cref{lem:Htil:similarity} and \Cref{lem:bbnmc:compare:Htil:Gtil} respectively). We tie our overall proof together using the above steps to show that non-malleability holds in \Cref{bbnmc:proof:fin}. 

% \end{itemize}



\subsection{Reduction to VSS Hiding Game}
\label{sec:pq-nmc:1-1:proof:reduction-to-hiding}

We first define some notion related to the MIM execution of \Cref{protocol:BB-NMCom}.
\begin{AlgorithmBox}[label={pq:gameH:description}]{Machine \textnormal{$H^{\mcal{M}_\secpar}(\secpar,m,\rho_\secpar)$}}

{\bf Machine $H^{\mcal{M}_\secpar}(\secpar,m,\rho_\secpar)$:} This is the man-in-the-middle execution of the commit stage of \Cref{protocol:BB-NMCom}, where the left committer commits to $m$ and $\mcal{M}_\secpar$'s non-uniform advice is $\rho_\secpar$. The output of this game is denoted by $\Output_{H^{\mcal{M}_\secpar}}(\secpar, m, \rho_\secpar)$ and consists of the following three parts:
\begin{enumerate}
\item
$\OUT$: This is the (quantum) output of $\mcal{M}$ at the end of this game;
\item
$\tilde{\tau}$: This is the commitment transcript sent by $\mcal{M}$ in the \Cref{bbnmc:init-com} of the right session;
\item
$\tilde{d} \in \Set{\top, \bot}$: This is the output of the honest receiver $R$ in the right session, indicating if the man-in-the-middle's commitment (i.e., the right session) is accepted ($\tilde{d} = \top$) or not ($\tilde{d} = \bot$).
\end{enumerate} 
\end{AlgorithmBox}

%\xiao{we can remove the bar abot the mim symbol}

Also, to prove non-malleability, we need to talk about the value committed in the right session. Toward that, we define the following function:
$$
\msf{val}_{\tilde{d}}(\tilde{\tau}) \coloneqq 
\begin{cases}
\msf{val}(\tilde{\tau}) & \tilde{d} = \top\\
\bot & \tilde{d} = \bot
\end{cases},
$$
where $\msf{val}(\tilde{\tau})$ denote the value statistically-bound $\tilde{\tau}$ (i.e., the value that can be re-constructable from $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$). Note that $\msf{val}_{\tilde{d}}(\tilde{\tau})$ is exactly the value committed in the right session by $\mcal{M}$. Thus, to prove satisfies \Cref{def:NMCom:pq} (when $k = 1$), we only need to establish the following equation:
\begin{align*}
&\big\{\big(\OUT^0, \msf{val}_{\tilde{d}^0}(\tilde{\tau}^0)\big): (\OUT^0, \tilde{\tau}^0, \tilde{d}^0) \gets H^{\mcal{M}_\secpar}(\secpar, m_0, \rho_\secpar) \big\} \\
\cind ~& 
\big\{\big(\OUT^1, \msf{val}_{\tilde{d}^1}(\tilde{\tau}^1)\big): (\OUT^1, \tilde{\tau}^1, \tilde{d}^1) \gets H^{\mcal{M}_\secpar}(\secpar, m_1, \rho_\secpar) \big\} \numberthis \label{pq:eq:classical:H:m-0:m-1},
\end{align*}
where both ensembles are indexed by $\secpar \in \Naturals$ and $(m_0, m_1) \in \bits^{\ell(\secpar)} \times \bits^{\ell(\secpar)}$.

\iffalse
Next we provide a reformatted description of the game $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$ in \Cref{pq:hybrid:H:reinterpretation}. %We also provide a picture in \Cref{pq:figure:one-sided:H:re-interpretation} to illustrate it.
\begin{AlgorithmBox}[label={pq:hybrid:H:reinterpretation}]{The Reformatted Game \textnormal{$H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$}}
Game $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$ can be split into the following stages:
\begin{enumerate}
\item \label[Stage]{pq:hybrid:H:reinterpretation:1}
{\bf Prefix Generation:}
First, it executes \Cref{bbnmc:init-com} of the man-in-the-middle game of \Cref{protocol:BB-NMCom}. That is, it plays as the left honest committer committing to $m$ (using the MPC-in-the-head paradigm) and the right honest receiver, with $\mcal{M}_{\secpar}(\rho_\secpar)$ being the man-in-the-middle adversary.

\subpara{Notation:} Let $\msf{st}_{\mcal{M}}$ denote the state of $\mcal{M}$ at the end of \Cref{bbnmc:init-com}; Let $\msf{st}_C$  (resp.\ $\msf{st}_R$) denote the state of the honest committer (resp.\ receiver) at the end of \Cref{bbnmc:init-com}; Let $\tilde{\tau}$ denote the list $(\Set{\tilde{\msf{cv}}^{(1)}_i}_{i \in [n]})$\footnote{Recall that $(\Set{\msf{\tilde{cv}}^{(1)}_i}_{i \in [n]})$ is the \Cref{bbnmc:init-com} message in the right session; it constitutes an execution of Naor's commitment.}. In terms of notation, we denote the execution of this stage by 
\begin{equation}\label[Expression]{pq:expression:hybrid:H:prefix}
(\msf{st}_{\mcal{M}},  \msf{st}_C, \msf{st}_R, \tau,\tilde{\tau})\gets H^{\mcal{M}_\secpar}_{\msf{pre}}(\secpar, m, \rho_\secpar).
\end{equation}
We will call the tuple $(\msf{st}_{\mcal{M}},  \msf{st}_C, \msf{st}_R, \tau,\tilde{\tau})$ the {\em prefix} and denote it by $\msf{pref}$. It is worth noting that this $\msf{pref}$ contains sufficient information such that a QPT machine can ``complete'' the subsequent portion of the execution of $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$ given $\msf{pref}$.

\item \label[Stage]{pq:stage:hybrid:H:remainder}
{\bf The Remainder:}
Next, it simply resumes from where the {\bf Prefix Generation} stage stops, to finish the remaining steps of the man-in-the-middle execution $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$.

\subpara{Notation:} We introduce the following notation to describe this stage. Define a QPT machine $\Adv$ that takes as input $(\msf{st}_{\mcal{M}}, \tilde{\tau})$; Machine $\mcal{A}_\secpar$ is supposed to run the residual strategy of $\mcal{M}_\secpar$ starting from $\msf{st}_{\mcal{M}}$. Also, define a QPT machine $\mcal{B}$ that takes as input $(\msf{st}_C, \msf{st}_R, \tilde{\tau})$; Machine $\mcal{B}$ is supposed to run the residual strategies of the honest committer $C$ and receiver $R$, starting from 
$\msf{st}_C$ and $\msf{st}_R$ respectively. With the above notation, we can denote the execution of the remaining steps of $H^{\mcal{M}_\secpar}(\secpar,m,\rho_\secpar)$ by
\begin{equation}\label[Expression]{pq:expression:hybrid:H:remainder}
(\OUT_\mcal{A}, \tilde{d})\gets \langle \mcal{A}_\secpar(\msf{st}_{\mcal{M}}), \mcal{B}(\msf{st}_C, \msf{st}_R) \rangle(1^\secpar, \tilde{\tau}),
\end{equation}
where $\OUT_\mcal{A}$ is the output of $\mcal{A}_\secpar$, and $\tilde{d} \in \Set{\bot, \top}$ is the output of the honest receiver $R$ (in the right), indicating if the man-in-the-middle's commitment (i.e., the right session) is accepted ($\tilde{d} = \top$) or not ($\tilde{d} = \bot$). (We remark that $\OUT_\Adv$ is nothing but the man-in-the-middle $\mcal{M}$'s final output.)

\item
{\bf Output:} It outputs the tuple $(\OUT_\Adv, \tilde{\tau}, \tilde{d})$. We denote this by $\Output_{H^{\mcal{M}_\secpar}}(\secpar, m, \rho_\secpar)$  
\end{enumerate}
\end{AlgorithmBox}

Clearly this described game is functionally equivalent to the original description of $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$. We conclude that these games are in fact identical. 
\fi 

% We now proceed with the proof strategy outlined in the overview. To start with, 
Next, we describe a new game $\tilde{H}^{\mcal{M}_\secpar}$, which is a slight modification of the game  $\tilde{H}^{\mcal{M}_\secpar}$. It will help us switch out different commitments in the left interaction. 
% This uses crucially the following sub-procedure $\mcal{G}_1(\cdot)$ defined subsequently in \Cref{pq:game:Gtil}: 

\begin{AlgorithmBox}[label={pq:game:Htil}]{Game \textnormal{$\tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon,m,\rho_\secpar)$}}
{\bf Input:} It takes as input the same parameters $\secpar$, $\rho_\secpar$, and $m$ as for $H^{\mcal{M}_\secpar}$. It additionally takes as input a noticeable function $\secpar(\cdot)$. 

It proceeds as follows:
\begin{enumerate}
    \item \label[Step]{pq:game:Htil:pref}
    {\bf (Prefix phase.)} 
    This proceeds as follows. 
    \begin{enumerate}
        \item \label[Step]{pq:game:Htil:pref:1}
        Sample a random size-$k$ subset $\eta \subset [n]$.
        \item \label[Step]{pq:game:Htil:pref:2}
       	Execute $H^{\mcal{M}_\secpar}(m_1,\secpar,\rho_\secpar)$ until the end of \Cref{bbnmc:init-com}. At the moment, it already receives the \Cref{bbnmc:init-com} commitment made by the left-session honest committer $C$. It performs brute-force computation to obtain from $C$'s commitment the committed shares $\msf{cv}_i$ and their decommitment information for $i \in \eta$. We denote these values as $\msf{VI}_\eta \coloneqq \Set{(\msf{cv}_i, \msf{decom}_i}_{i \in \eta}$. 
    \end{enumerate}
    \subpara{Notation:}  Let $\msf{st}_{\mcal{M}}$ denote the state of $\mcal{M}$ at the end of \Cref{bbnmc:init-com}; Let $\msf{st}_C$  (resp.\ $\msf{st}_R$) denote the state of the honest committer (resp.\ receiver) at the end of \Cref{bbnmc:init-com}; Let $\tilde{\tau}$ denote the commitment sent by $\mcal{M}$ in \Cref{bbnmc:init-com} of the right session. We denote the tuple $(\msf{st}_{\mcal{M}}, \msf{st}_R, \tau,\tilde{\tau})$ as $\msf{pref}$. We use the following nation to express the execution of this {\bf Prefix phase}:
    \begin{equation}
    (\msf{pref}, \eta, \msf{VI}_\eta) \la \tilde{H}_{\msf{pref}}^{\mcal{M}_\secpar}(\secpar,  m, \rho_\secpar).
    \end{equation}
    We will often use $\msf{pref}' \coloneqq (\msf{pref}, \eta, \msf{VI}_\eta)$ to refer to the concatenation of $\msf{pref}$ and the $\eta, \msf{VI}_\eta$. We remark that this prefix generation step is independent of the error parameter $\epsilon$.
  
    \item \label[Step]{pq:game:Htil:body} 
    {\bf (Remainder phase.)} This involves the following steps: 
    \begin{enumerate}
        \item 
        $\tilde{H}^{\mcal{M}_\secpar}$ now invokes $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta))$ (as described in \Cref{pq:machine:g1}), which outputs a tuple $(\OUT, \tilde{d})$. 
        \item 
        $\tilde{H}^{\mcal{M}_\secpar}$ outputs $(\OUT, \tilde{\tau},\tilde{d})$. %We denote this by $\Output_{H^{\mcal{M}_\secpar}}(\secpar, m, \rho_\secpar)$. 
    \end{enumerate}
\end{enumerate}

% \subpara{Notation:} We denote the output $(OUT_{\tilde{H}},\tilde{\tau}_{\tilde{H}},\tilde{d}_{\tilde{H}})$ by $\Output_{H^{\mcal{M}_\secpar}}(\secpar, m, \rho_\secpar)$. \red{parameters don't match?}
\end{AlgorithmBox}

% \begin{remark}
%     We observe here that by design, $\tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon, m, \rho_\secpar)$ inherently uses no other information used by the left side committer $C$ apart from the initial commitment $\msf{com}$, the sampled string $\eta$ and the corresponding decommitments to VSS shares $\msf{VI}_\eta$ (note that the definition of $\msf{pref}$ elides mention of $\state_C$). This property will be crucial later in our reduction in \Cref{lem:bb-nmc:similarity:g:til}.   
% \end{remark}

We now describe the subprocedure $\mcal{G}_1(\cdot)$. 

\begin{AlgorithmBox}[label={pq:machine:g1}]{Machine \textnormal{$\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta)$}}
Game $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta)$ continues the execution using $\msf{pref}$ just as in $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$, apart from the following differences:
\begin{enumerate}
    \item  \label[Step]{machine:G1:step:2}
    In the left \Cref{bbnmc:hard-puzzle:rv-2} against $\mcal{M}_\secpar$, instead of following the honest receiver algorithm for $\ExtCom$, it instead uses the extractor $\SimExt_\ExtCom^{\mcal{M}_\secpar}(1^\secpar,1^{\epsilon^{-1}})$ to obtain an extracted value of the form $j'||x'_{j'}$ (and continuing the execution with the simulated state). 

    In more detail, the shares $\Set{\msf{rv}^{(2)}_i}_{i \in [n]}$ are committed by $\mcal{M}_\secpar$ using independent $\ExtCom$ in parallel. $\mcal{G}_1$ will extract all of these shares using the parallel extractability of $\ExtCom$ with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:parallel}), and compute $j'||x'_{j'} \coloneqq \VSS_{\Recon}(\msf{rv}^{(2)}_1, \ldots, \msf{rv}^{(2)}_n)$.

    \item \label[Step]{machine:G1:step:2}
    In the $\ExtCom$ execution for \Cref{prot:bbnmc:extcom} on the left, it commits to the extracted value $j'\|x'_{j'}$.

    In more detail, $\mcal{G}_1$ first prepares $n$ views $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, 2k)$-$\VSS_\Share$ of the value $j'\|x'_{j'}$ extracted in \Cref{machine:G1:step:2}, and then commits to each $\msf{cv}^{(2)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$.

    \item \label[Step]{machine:G1:step:3}
    In \Cref{prot:bbnmc:puzzle-sol-reveal} of the left session, after reconstructing the receiver's puzzle solutions $x_1\|\dots\|x_t$, it checks whether $x_{j'} = x'_{j'}$, i.e., the value that it extracted earlier. If not, it aborts the execution and outputs $\bot$. 
    
    \item \label[Step]{machine:G1:step:3}
     In \Cref{prot:bbnmc:C-consis-com} of the left session, instead of generating the views $\Set{\msf{cv}^{(3)}_i}_{i\in [n]}$ using the `first clause' of $F^C_{\msf{consist}}$, generate these views using the `second clause'. We remark that this is possible because in \Cref{machine:G1:step:2} above, we already commit to the extracted $j'\|x'_{j'}$, which satisfies the `second clause' of $F^C_{\msf{consist}}$. 

     Recall that each $\msf{cv}^{(3)}_i$ has $\msf{cv}^{(1)}_i$ as a prefix. However, $\mcal{G}_1$ only knows the $\msf{cv}^{(1)}_i$ for $i \in \eta$. For that, $\mcal{G}_1$ simply set $\msf{cv}^{(1)}_i$ for $i \in [n] \setminus \eta$ to all-$0$ strings. This does not affect this step as $\mcal{G}_1$ now is proving the `second clause' of $F^C_{\msf{consist}}$, which is independent of the value determined by the real $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$. (Also note that this problem does not occur for $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, which is generated by $\mcal{G}_1$ itself in \Cref{machine:G1:step:2}.)

    \item \label[Step]{machine:G1:step:4}
    In \Cref{prot:bbnmc:cointoss} of the left session, instead of executing the trapdoor coin-flipping protocol honestly, use the `straight-line' simulator $\Sim(\ST_C, \eta, j'\|x'_{j'}, \phi)$ that is guaranteed to exist by \Cref{def:com-n-prove:property:3} in \Cref{def:com-n-prove} (where $\ST_C$ is the classical state of the committer at the end of \Cref{prot:bbnmc:extcom}, emulated by $\mcal{G}_1$). Note that this is possible because we current have $\phi(j'\|x'_{j'}) = 1$. This effectively `enforce' the coin-flipping result to the $\eta$ contained in the input to $\Sim$.
    
    \item 
    It concludes the execution by performing the remaining steps as in $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$. One caveat is: In \Cref{prot:bbnmc:mpc:reveal} of the left session, $\mcal{G}_1$ will be asked to decommitment to $\Set{\msf{cv}^{(1)}_i}_{i \in [n]\setminus \eta}$. Note that the $\eta$ is already `enforced' to the $\eta$ in \Cref{machine:G1:step:4}, and $\mcal{G}_1$ does know the $\msf{cv}^{(i)}_i$ shares and decommitment information for $i \in \eta$ (contained in $\msf{VI}_\eta$).


    \item It finally outputs the values $(\OUT, \tilde{d})$, where again $\OUT$ is $\mcal{M}$'s final output and $\tilde{d}$ is the honest $R$'s final decision in the right session.
\end{enumerate}

%\subpara{Notation:} The remainder (or `post-prefix') procedure we denote by $\tilde{H}_\msf{post}^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar,\epsilon)$. 
\end{AlgorithmBox}
   


\begin{lemma}\label{lem:Htil:similarity}
For all $m \in \bits^{\ell(\secpar)}$ and all noticeable $\epsilon(\cdot)$, it holds that  
    \begin{equation*}
    \big\{\big(\OUT, \msf{val}_{\tilde{d}}(\tilde{\tau})\big): (\OUT, \tilde{\tau}, \tilde{d}) \gets H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar) \big\}_\secpar 
    \cind_\epsilon  
    \big\{\big(\OUT, \msf{val}_{\tilde{d}}(\tilde{\tau})\big): (\OUT, \tilde{\tau}, \tilde{d}) \gets \tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon, m, \rho_\secpar) \big\}_\secpar.
    \end{equation*}
\end{lemma}

\begin{proof}
We prove this lemma by a hybrid argument. Some of the modifications are pretty standard within black-box MPC literature and we sketch them for brevity. In the following, we fix arbitrary an $m$ and an $\epsilon$. For each hybrid $H_i$, we use $\OUT_{H_i}$ to denote its output.

\para{Hybrid $H_0$:} This is simply the game $H^{\mcal{M}_\secpar}(m,\rho_\secpar)$, renamed for convenience.

\para{Hybrid $H_1$:} This hybrid is identical to the previous one, except for the following changes. In \Cref{bbnmc:hard-puzzle:rv-2} of the left session, instead of following the honest $C$'s algorithm, it uses the extractor $\SimExt_\ExtCom^{\mcal{M}_\secpar}(1^\secpar,1^{\epsilon^{-1}})$ to obtain an extracted a value of the format $j'\|x'_{j'}$ and a (simulated) state $\state'_{\mcal{M}}$ (as described in \Cref{machine:G1:step:2} of $\mcal{G}_1$). It records $j'\|x'_{j'}$ and continues the execution of the MIM interaction with $\state'_{\mcal{M}}$ up till \Cref{prot:bbnmc:puzzle-sol-reveal}, where it obtains $x_1,\dots,x_t$ and checks if $x_{j'} = x'_{j'}$. If not, it aborts; otherwise it finishes the execution. All other steps are carried out as in the previous hybrid. Note that $H_1$ now requires the additional input $1^{\epsilon^{-1}}$. 

\subpara{$\Output_{H_0} \sind_\epsilon \Output_{H_1}$:} This follows directly from the parallel extractability with $\epsilon$-simulation of $\ExtCom$ (as per \Cref{def:epsilon-sim-ext-com:parallel}).

\para{Hybrid $H_2$:} This hybrid is identical to the previous one, except for the following changes. In \Cref{prot:bbnmc:extcom} of the left session, it uses the extracted $j'\|x'_{j'}$ as the committed message; And in \Cref{prot:bbnmc:C-consis-com} of the left session, instead of generating the views $\Set{\msf{cv}^{(3)}_i}_{i\in [n]}$ using the `first clause' of $F^C_{\msf{consist}}$, generate these views using the `second clause'.

\begin{remark}\label{rmk:known-shares}
We remark that this step is slight different from \Cref{machine:G1:step:3} of $\mcal{G}_1$, where the shares $\Set{\msf{cv}^{(1)}_i}_{i \in [n] \setminus \eta}$ (as prefix of $\msf{cv}^{(3)}_i$'s) is set to $0$-strings. In the current hybrid, $H_2$ still uses the honest $\Set{\msf{cv}^{(1)}_i}_{i \in [n] \setminus \eta}$ shares, because these shares are generated by itself and thus it knows them. We will change these shares to $0$-strings in a later hybrid (i.e., $H_4$). 
\end{remark}

\subpara{$\Output_{H_1} \cind \Output_{H_2}$:} Note that \Cref{prot:bbnmc:extcom} and \Cref{prot:bbnmc:PoC} constitutes a black-box commit-and-prove protocol. What we did in this step is to switch from one witness for the target predicate to another witness. This switch is computationally indistinguishable. Since this argument is standard, we omit the details (see \cite[Section 6.5]{C:CCLY22} for an example).


\para{Hybrid $H_3$:} This hybrid is identical to the previous one, except for the following changes. At the very beginning, it samples a random size-$k$ subset $\eta\subset [n]$; and In \Cref{prot:bbnmc:cointoss} of the left session, instead of executing the trapdoor coin-flipping protocol honestly, it uses the `straight-line' simulator $\Sim(\ST_C, \eta, j'\|x'_{j'}, \phi)$ to `enforce' the coin-flipping result (in the same manner as described in \Cref{machine:G1:step:4} of $\mcal{G}_1$).

\subpara{$\Output_{H_2} \cind \Output_{H_3}$:} This follows directly from the security guarantee of $\Sim$ (i.e., \Cref{def:com-n-prove:property:3} in \Cref{def:com-n-prove}).

\para{Hybrid $H_4$:} This hybrid is identical to the previous one, except for the following changes. In \Cref{prot:bbnmc:C-consis-com} of the left session, when generating $\msf{cv}^{(3)}_i$, it sets the shares $\Set{\msf{cv}^{(1)}_i}_{i \in [n] \setminus \eta}$ to $0$-strings. This is to compensate the concern in \Cref{rmk:known-shares}. 

\subpara{$\Output_{H_3} \cind \Output_{H_4}$:} First, note that changing the shares  $\Set{\msf{cv}^{(1)}_i}_{i \in [n] \setminus \eta}$ does not affect \Cref{prot:bbnmc:C-consis-com} of the left session, as we already switch to using the witness for the `second clause' of it in $H_3$. Also note that these shares will never be revealed because in $H_2$ we already `enforce' the challenge set to $\eta$. Thus, the indistinguishability of $H_3$ and $H_4$ follows directly from the computational hiding property of Naor's commitment in \Cref{prot:bbnmc:C-consis-com} of the left session.

\para{Hybrid $H_5$:} Note that in $H_4$, we already do not need to use any information about the shares $\Set{\msf{cv}^{(1)}_i}_{i \in [n] \setminus \eta}$. In this hybrid, we can think that after \Cref{bbnmc:init-com} of the execution, $H_5$ performs brute-force computation to learn the shares $\Set{\msf{cv}^{(1)}_i}_{i \in \eta}$ and their corresponding decommitment information (and put them together as $\msf{VI}_\eta$). Indeed, these are the only information that is need to finish the remaining execution. 

\subpara{$\Output_{H_4} \idind \Output_{H_5}$:} There is no real change in $H_5$ other than a change of perspective. These two hybrids are thus identical.

Finally, note that $H_5$ is exactly $\tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon, m, \rho_\secpar)$. This concludes the proof of \Cref{lem:Htil:similarity}.

\end{proof}

\iffalse
We now consider the modification of game $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$, formally described as follows: 
%\xiao{This game need to take the $\epsilon$ parameter as input.}
\begin{AlgorithmBox}[label={pq:hybrid:H:til}]{The Reformatted Game \textnormal{$\tilde{H}^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar,\epsilon)$}}
Game $\tilde{H}^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar,\epsilon)$ can be split into the following stages:
\begin{enumerate}
\item \label[Stage]{pq:hybrid:H:til:1}
{\bf Prefix Generation:} This is identical to the prefix phase \Cref{pq:expression:hybrid:H:prefix} in $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$. Namely, this stage executes \Cref{bbnmc:init-com} of the man-in-the-middle game of \Cref{protocol:BB-NMCom}.


\subpara{Notation:}  Let $\msf{st}_{\mcal{M}}$ denote the state of $\mcal{M}$ at the end of \Cref{bbnmc:init-com}; Let $\msf{st}_C$  (resp.\ $\msf{st}_R$) denote the state of the honest committer (resp.\ receiver) at the end of \Cref{bbnmc:init-com}; Let $\tilde{\tau}$ denote the list $(\Set{\msf{\tilde{cv}}^{(1)}_i}_{i \in [n]})$. In terms of notation, we denote the execution of this stage by 
\begin{equation}\label[Expression]{pq:expression:hybrid:H:til:prefix}
(\msf{st}_{\mcal{M}},  \msf{st}_C, \msf{st}_R, \tau,\tilde{\tau})\gets \tilde{H}^{\mcal{M}_\secpar}_{\msf{pre}}(\secpar, m, \rho_\secpar,\epsilon).
\end{equation}
We will call the tuple $(\msf{st}_{\mcal{M}},  \msf{st}_C, \msf{st}_R, \tau,\tilde{\tau})$ the {\em prefix} and denote it by $\msf{pref}$. Note that neither $\tilde{H}^{\mcal{M}_\secpar}_{\msf{pre}}$ nor $\msf{pref}$ involve the parameter $\epsilon$ - this appears only subsequently. %It is worth noting that this $\msf{pref}$ contains sufficient information such that a QPT machine can ``complete'' the subsequent portion of the execution of $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$ given $\msf{pref}$.

\item \label[Stage]{pq:stage:hybrid:H:til:remainder}
{\bf The Remainder:} This works as follows: 
\begin{itemize}
    \item Sample a set $\eta \subset [n] : |\eta| = k$ uniformly (from among all such sets). 
    \item Let $\Set{\msf{com}_i}_{i \in [n]} \gets \Set{\Com(\msf{cv}_i;r_i)}_{i \in [n]}$ denote the commitments prepared in \cref{bbnmc:init-com} and included implicitly within $\msf{pref}$ (with appropriately sampled commitment randomness $r_i$). Let $\msf{decom_i}$ denote the decommitment information corresponding to $\msf{com_i}$. Prepare the list $\msf{VI}_\eta \coloneqq \Set{(\msf{decom}_i,\msf{cv}_i)}_{i \in \eta}$. 
    \item Invoke the machine $g(\cdot)$ (defined below) that takes as input the tuple $(1^\secpar, 1^{\epsilon^{-1}},\msf{pref},\eta, \msf{VI}_\eta)$ and operates as follows:
    \begin{enumerate}
        \item In the left \Cref{bbnmc:hard-puzzle:rv-2} against $\mcal{M}_\secpar$, it uses the extractor $\SimExt_\ExtCom^{\mcal{M}_\secpar}(1^\secpar,1^{\epsilon^{-1}})$ to obtain an extracted value $\zeta$ (and continuing ahead with the simulated state).
        \item It parses the extracted string $\zeta$ as $j||x'_j$, and commits to $x'_j$ in the left side \cref{prot:bbnmc:extcom}.
        \item In the left \cref{prot:bbnmc:cointoss:reveal}, it sets $\eta'^C$ to be the value $\eta \oplus \eta^R$. 
        \item In \cref{prot:bbnmc:C-consis-com} on the left, it invokes the simulator for $\Prot_\textsc{mpc}$ to generate the views $\Set{\msf{ctv}^{(2)}_i}_{i \in \eta}$ for parties (with indices) in $\eta$. The other views are set to be 0 strings of suitable length. 
        \item It performs all other steps just as in $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$.
        \item It finally outputs the values $(\OUT_g,\tilde{\tau}_g)$ (corresponding to values output at the end of the MIM experiment). 
    \end{enumerate}
    %\item Invoke the machine $\SimExt$: $\SimExt$ takes in as input a tuple $(1^\secpar, 1^{\epsilon^{-1}}, \msf{st}_M, \msf{st}_R, \eta, \msf{VI}_\eta, \tilde{\tau})$ and outputs $(\msf{OUT}_{\mcal{SE}}, \msf{Val}_{\mcal{SE}})$. 
    \item Output the values $(\OUT_g,\tilde{\tau}_g)$ as its own output $(\OUT_{\tilde{H}},\tilde{\tau}_{\tilde{H}})$. 
\end{itemize}

\subpara{Notation:} The remainder (or `post-prefix') procedure we denote by $\tilde{H}_\msf{post}^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar,\epsilon)$. 
\end{enumerate}
\end{AlgorithmBox}
\fi

Next, we define a further modified game $\tilde{G}$ that instead invokes a particular simulator-extractor $\SimExt$ that helps obtain the value committed to by $\mcal{M}_\secpar$ on the right (which then helps to demonstrate non-malleability). 

\begin{AlgorithmBox}[label={pq:game:Gtil}]{Game \textnormal{$\tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon, m,\rho_\secpar)$}}
This proceeds in two phases as well: 
\begin{enumerate}
    % \item
    % It first computes $\epsilon' = \msf{p}(\epsilon)$, where $\msf{p}(\cdot)$ is an efficiently computatable polynomial that is guaranteed to exist by the following \Cref{lem:simext:closeness}.

    \item \label[Step]{pq:game:Gtil:pref}
    {\bf (Prefix phase.)} This is identical to {the prefix phase of \Cref{pq:game:Htil}, i.e., it computes $(\msf{pref}, \eta, \msf{VI}_\eta) \la \tilde{H}_{\msf{pref}}^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$.}

    
    \item {\bf Remainder phase:}\label[Step]{pq:game:Gtil:body} This involves the following steps: 
    \begin{itemize} 
        \item It invokes a machine $\SimExt$, {which is guranteed to exist by the following \Cref{lem:simext:closeness}}: $\SimExt$ takes in as input a tuple $(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta)$ and outputs $(\msf{OUT}, \msf{Val})$. 
        \item  $\tilde{G}^{\mcal{M}_\secpar}$ outputs $(\msf{OUT}, \msf{Val})$ as its own output.
    \end{itemize}
\end{enumerate}
\end{AlgorithmBox}

The following \Cref{lem:simext:closeness} serves as assurance that we can build such a machine $\SimExt$ so that the games $\tilde{H}^{\mcal{M}_\secpar}$ and $\tilde{G}^{\mcal{M}_\secpar}$ present $\epsilon$-close views to the adversary (where we control the closeness parameter). \Cref{lem:simext:closeness} represents the most challenging task in the current proof of non-malleability. We will prove it in \Cref{sec:simless-ext:1-1,sec:simext:1-1}
\begin{lemma}[1-1 Simulation-Extractor]\label{lem:simext:closeness}
    Let $\mcal{G}_1(\cdot)$ be the efficient procedure defined in \Cref{pq:machine:g1}. There exists a simulation-extractor $\SimExt$ such that for any $(\msf{pref},\eta,\msf{VI}_\eta)$ in the support of $\tilde{H}^{\mcal{M}_\secpar}_\msf{pre}$, and for any noticeable $\epsilon(\secpar)$, there is a noticeable $\epsilon'(\secpar) \le 8\epsilon(\secpar)$ that is efficiently computable form $\epsilon(\secpar)$ such that the following holds:
    \begin{align*}
        &
        \big\{(\msf{OUT}, \msf{Val}): (\msf{OUT}, \msf{Val}) \gets \SimExt(1^\secpar, 1^{\epsilon^{-1}},\msf{pref},\eta,\msf{VI}_\eta) \big\}
        \\
        \cind_{\epsilon} 
        ~&
        \big\{\big(\OUT, \msf{val}_{\tilde{d}}(\tilde{\tau})\big): (\OUT,  \tilde{d}) \gets \mcal{G}_1(1^\secpar, 1^{\epsilon'^{-1}}, \msf{pref},\eta,\msf{VI}_\eta) \big\}.
    \end{align*}
\end{lemma} 
The following \Cref{lem:bbnmc:compare:Htil:Gtil} is an immediate consequence of \Cref{lem:simext:closeness}. 
\begin{corollary}\label{lem:bbnmc:compare:Htil:Gtil}
    Let $\tilde{H}^{\mcal{M}_\secpar}$ and $\tilde{G}^{\mcal{M}_\secpar}$ be as defined in \Cref{pq:game:Htil} and \Cref{pq:game:Gtil} respectively. For any QPT adversary $\mcal{M}_\secpar(\rho_\secpar)$, any $m \in \bits^{\ell(\secpar)}$, 
    % for any $(\msf{pref},\eta,\msf{VI}_\eta)$ in the support of $\tilde{H}^{\mcal{M}_\secpar}_\msf{pre}$, 
    and any noticeable $\epsilon(\secpar)$, there is a noticeable $\epsilon'(\secpar) \le 8\epsilon(\secpar)$ that is efficiently computable form $\epsilon(\secpar)$ such that the following holds: 
    \begin{align*}
        &
        \big\{(\msf{OUT}, \msf{Val}): (\msf{OUT}, \msf{Val}) \gets \tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon, m, \rho_\secpar) \big\} 
        \\
        \cind_{\epsilon} 
        ~&
        \big\{\big(\OUT, \msf{val}_{\tilde{d}}(\tilde{\tau})\big): (\OUT, \tilde{\tau}, \tilde{d}) \gets \tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon', m, \rho_\secpar) \big\}.
    \end{align*}
\end{corollary}

\begin{proof}
    Note that the prefix stages of $\tilde{H}^{\mcal{M}_\secpar}$ (see \Cref{pq:game:Htil:pref} in \Cref{pq:game:Htil}) and $\tilde{G}^{\mcal{M}_\secpar}$ (see \Cref{pq:game:Gtil:pref} in \Cref{pq:game:Gtil}) are identical, and therefore \Cref{lem:simext:closeness} immediately applies to show that $(\OUT, \msf{val}_{\tilde{d}}(\tilde{\tau}))$ obtained by running $\tilde{H}^{\mcal{M}_\secpar}$ and $(\msf{OUT}, \msf{Val})$ obtained by running $\tilde{G}^{\mcal{M}_\secpar}$ are $\epsilon$-close.

\end{proof}


% \begin{remark}
%      In fact, \Cref{lem:simext:closeness} proves a stronger property: namely, the remainder portions of these hybrid games produce similar outputs {\em conditioned on any valid prefix}. In our usage it would suffice to simply show that the outputs of these games are close when evaluated over a prefix sampled from $\tilde{H}^{\mcal{M}_\secpar}_\msf{pre}$ (and the probability being taken also over such sampling).  
% \end{remark}
\subsection{Finishing the Proof of Non-Malleability}
\label{bbnmc:proof:fin} 

With the helper machines defined in \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding}, we can now finish the proof of non-malleability. This is a proof by contradiction. We will show that if the non-malleability of \Cref{protocol:BB-NMCom} does not hold, then the machine $\tilde{G}^{\mcal{M}_\secpar}$ can be used to break the VSS hiding game defined in \Cref{chall:vss:hide}. We present the formal argument in the following.


We first show a lemma that relates machine $\tilde{G}^{\mcal{M}_\secpar}$ to the VSS hiding game defined in \Cref{chall:vss:hide}.
\begin{lemma}\label{lem:bb-nmc:similarity:g:til}
Let $\tilde{G}^{\mcal{M}_\secpar}$ be defined as in \Cref{pq:game:Gtil}. For For any QPT adversary $\mcal{M}_\secpar(\rho_\secpar)$ and any noticeable $\epsilon(\secpar)$, it holds that
    \begin{align*}
        &\big\{(\OUT^0, \Val^0):(\OUT^0, \Val^0) \gets \tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon, m_0, \rho_\secpar)\big\} \\
        \cind ~&
        \big\{(\OUT^1, \Val^1):(\OUT^1, \Val^1) \gets \tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon, m_1, \rho_\secpar)\big\}, \numberthis
    \end{align*}    
    where both ensembles are indexed by $\secpar \in \Naturals$ and $(m_0,m_1) \in \bits^{\ell(\secpar)} \times \bits^{\ell(\secpar)}$. 
\end{lemma}

\begin{proof}
    We show this by means of a reduction to the VSS hiding game defined in \Cref{chall:vss:hide}. We assume for contradiction that there exist a machine $\mcal{M}_\secpar(\rho_\secpar)$, a distinguisher $\mcal{D}_\secpar$, and a pair of messages $(m_0, m_1)$ so that \Cref{lem:bb-nmc:similarity:g:til} does not hold. We build a malicious $\Adv$ that wins the VSS hiding game (i.e., breaking \Cref{lem:game:VSS:hiding}).

    The $\Adv$ works as follows:
    \begin{enumerate}
    \item
    It sends $(m_0, m_1)$ to the external $\algo{Ch}$ for the VSS hiding game, as the \Cref{chall:vss:hide:step:1} message of \Cref{chall:vss:hide}.
    \item
    It internally samples a random size-$k$ subset $\eta \subset [n]$. 
    \item
    It commits to $\eta$ to the external $\algo{Ch}$ using $\ExtCom$, as the \Cref{chall:vss:hide:step:2} message of \Cref{chall:vss:hide}.
    \item
    When the external $\algo{Ch}$ sends the \Cref{chall:vss:hide:step:3} message of \Cref{chall:vss:hide}, it uses this message as the \Cref{bbnmc:init-com} message of the left session in its internal emulation of $\tilde{G}^{\mcal{M}_\secpar}$ with $\mcal{M}_\secpar$.
    \item
    It then decommits to $\eta$ to the external $\algo{Ch}$, as the \Cref{chall:vss:hide:step:4} message of \Cref{chall:vss:hide}.
    \item
    When it receives the revealed shares and their corresponding decommitment information form the external $\algo{Ch}$ (i.e., the \Cref{chall:vss:hide:step:5} message of \Cref{chall:vss:hide}), it puts them together to define $\msf{VI}_\eta$.
    \item
    It executes the machine $\SimExt(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta)$ as in the {\bf Remainder phase} of $\tilde{G}^{\mcal{M}_\secpar}$ (see \Cref{pq:game:Gtil}).
    \item
    It finally invokes the distinguisher $\mcal{D}_\secpar$ on $\SimExt$'s output, and outputs whatever $\mcal{D}_\secpar$ outputs.
    \end{enumerate}
Note that this $\Adv$ simulates perfectly emulates the execution of $\tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon, m_b, \rho_\secpar)$ (when the external $\algo{Ch}$ uses $m_b$). Note that in game $\tilde{G}^{\mcal{M}_\secpar}$, we define the variable $\msf{VI}_\eta$ by brute force (see \Cref{pq:game:Htil:pref:2} in \Cref{pq:game:Htil}). But in the above VSS hiding game, $\Adv$ learns the values in $\msf{VI}_\eta$ from the external $\algo{Ch}$. This is only a syntax change as these two way leads to the same $\msf{VI}_\eta$. 

Therefore, if \Cref{lem:bb-nmc:similarity:g:til} does not hold, the above $\Adv$ will win the VSS hiding game with advantage non-negligibly greater than $1/2$.

\end{proof}


\para{Derivation of Contradiction.} We assume for contradiction that \Cref{pq:eq:classical:H:m-0:m-1} does not hold (i.e.,  the non-malleability of \Cref{protocol:BB-NMCom} does not hold). This means that there must be  a (possibly non-uniform) QPT distinguisher $\mcal{D} = \Set{\mcal{D}_\secpar, \sigma_\secpar}_{\secpar \in \Naturals}$, an ensemble of messages $\Set{(m_0, m_1)}_{\secpar \in \Naturals}$ and a function $\delta(\secpar) = 1/\poly(\secpar)$ such that for infinitely many $\secpar \in \Naturals$, it holds that
\begin{equation}\label[Inequality]{pq:eq:one-sided:proof:contra-assump}
\bigg|\Pr[\mcal{D}_\secpar\big(\OUT^0, \msf{val}_{\tilde{d}^0}(\tilde{\tau}^0); \sigma_\secpar\big)=1] - \Pr[\mcal{D}_\secpar\big(\OUT^1, \msf{val}_{\tilde{d}^1}(\tilde{\tau}^1); \sigma_\secpar\big)=1] \bigg|\ge  \delta(\secpar),
\end{equation}
where the first probability is taken over the random procedure $(\OUT^0, \tilde{\tau}^0, \tilde{d}^0) \gets H^{\mcal{M}_\secpar}(\secpar,m_0,\rho_\secpar)$, and the second probability is taken over the random procedure $(\OUT^1, \tilde{\tau}^1, \tilde{d}^1) \gets H^{\mcal{M}_\secpar}(\secpar,m_1,\rho_\secpar)$ (and the randomness due to the measurements performed by $\mcal{D}_\secpar$).

Now recall that by \Cref{lem:Htil:similarity}, we have that for any $m$ and any noticeable $\epsilon_1(\secpar)$, it holds that
\begin{align*}
& 
\big\{\big(\OUT^H, \msf{val}_{\tilde{d}^H}(\tilde{\tau}^H)\big)~:~(\OUT^{{H}}, \tilde{\tau}^{{H}}, \tilde{d}^{{H}}) \gets {H}^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)\big\} \\ 
\cind_{\epsilon_1}~ &
\big\{\big(\OUT^{\tilde{H}}, \msf{val}_{\tilde{d}^{\tilde{H}}}(\tilde{\tau}^{\tilde{H}})\big)~:~(\OUT^{\tilde{H}}, \tilde{\tau}^{\tilde{H}}, \tilde{d}^{\tilde{H}}) \gets \tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon_1, m, \rho_\secpar\big\}.
\end{align*} 
Using this to replace terms on both sides of \Cref{pq:eq:one-sided:proof:contra-assump}, we get  
\begin{equation}\label[Inequality]{pq:eq:contra:Htil}
    \bigg|\Pr[\mcal{D}_\secpar\big(\OUT^0, \msf{val}_{\tilde{d}^0}(\tilde{\tau}^0); \sigma_\secpar\big)=1] - \Pr[\mcal{D}_\secpar\big(\OUT^1, \msf{val}_{\tilde{d}^1}(\tilde{\tau}^1); \sigma_\secpar\big)=1] \bigg|\ge \delta(\secpar) - 2\epsilon_1(\secpar),
\end{equation}
where the inputs to $\mcal{D}_\secpar$ in the above are sampled as $(\OUT^0, \tilde{\tau}^0, \tilde{d}^0) \gets \tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon_1, m_0,\rho_\secpar)$ and $(\OUT^1, \tilde{\tau}^1, \tilde{d}^1) \gets \tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon_1, m_1,\rho_\secpar)$. 

Further, we have from \Cref{lem:bbnmc:compare:Htil:Gtil} that for any $m$ and any noticeable $\epsilon_2(\secpar)$, there exists a noticeable $\epsilon_1(\secpar) \le 8\epsilon_2(\secpar)$ that is efficiently computable from $\epsilon_2(\secpar)$ such that
\begin{align*}
    &\big\{\big(\OUT^{\tilde{H}}, \msf{val}_{\tilde{d}^{\tilde{H}}}(\tilde{\tau}^{\tilde{H}})\big): (\OUT^{\tilde{H}}, \tilde{\tau}^{\tilde{H}}, \tilde{d}^{\tilde{H}}) \gets \tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon_1, m,\secpar,\rho_\secpar) \big\} \\
    \cind_{\epsilon_2} ~& 
    \big\{\big(\msf{OUT}_{\mcal{SE}}, \msf{Val}_{\mcal{SE}}\big): (\msf{OUT}_{\mcal{SE}}, \msf{Val}_{\mcal{SE}} \gets \tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon_2, m,\secpar,\rho_\secpar) \big\}.
\end{align*}
 Again, replacing terms on both sides of \Cref{pq:eq:contra:Htil}, we have 
\begin{equation}\label[Inequality]{pq:eq:contra:Gtil}
    \bigg|\Pr[\mcal{D}_\secpar\big(\OUT^0_{\mcal{SE}}, \msf{Val}_{\mcal{SE}}^0; \sigma_\secpar\big)=1] - \Pr[\mcal{D}_\secpar\big(\msf{OUT}_{\mcal{SE}}^1, \msf{Val}_{\mcal{SE}}^1; \sigma_\secpar\big)=1] \bigg|\ge \delta(\secpar) -\epsilon_1(\secpar) - \epsilon_2(\secpar),
\end{equation}
where the inputs to $\mcal{D}_\secpar$ in the above are sampled as $(\OUT^0_{\mcal{SE}}, \msf{Val}_{\mcal{SE}}^0) \gets \tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon_2, m_0,\secpar,\rho_\secpar)$ and $(\OUT^0_{\mcal{SE}}, \msf{Val}_{\mcal{SE}}^0) \gets \tilde{G}^{\mcal{M}_\secpar}(\secpar, \epsilon_2, m_1,\secpar,\rho_\secpar)$.

If we set $\epsilon_2 \coloneqq \frac{\delta}{18}$, then the lower-bound in \Cref{pq:eq:contra:Gtil} becomes 
$$\delta(\secpar) -\epsilon_1(\secpar) - \epsilon_2(\secpar) \ge \delta(\secpar) -8 \epsilon_2(\secpar) - \epsilon_2(\secpar) = \delta(\secpar) -9  \epsilon_2(\secpar) = \delta(\secpar) -9 \cdot \frac{\delta(\secpar)}{18}= \frac{\delta(\secpar)}{2}.$$

Since $\frac{\delta(\secpar)}{2}$ is noticeable, this is in direct contradiction to \Cref{lem:bb-nmc:similarity:g:til}, which says that the LHS of \Cref{pq:eq:contra:Gtil} can at most be negligible. We conclude that \Cref{pq:eq:one-sided:proof:contra-assump} is false. 

This establishes that our protocol described in \Cref{protocol:BB-NMCom} is indeed non-malleable as per \Cref{def:NMCom:pq} with $k =1$.




