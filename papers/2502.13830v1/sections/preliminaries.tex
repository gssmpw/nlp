%!TEX root = ../main.tex

\section{Preliminaries}

\subsection{Basic Notations} 
Let $\secpar \in \Naturals$ denote security parameter. 
For a positive integer $n$, let $[n]$ denote the set $\{1,2,...,n\}$.
For a finite set $\mcal{X}$, $x\sample \mcal{X}$ means that $x$ is uniformly chosen from $\mcal{X}$.

A function $f:\mathbb{N}\ra [0,1]$ is said to be \emph{negligible} if for all polynomial $p$ and sufficiently large $\secpar \in \mathbb{N}$, we have $f(\secpar)< 1/p(\secpar)$; it is said to be \emph{overwhelming} if $1-f$ is negligible, and said to be \emph{noticeable} if there is a polynomial $p$ such that $f(\secpar)\geq  1/p(\secpar)$ for sufficiently large $\secpar\in \mathbb{N}$. We denote by $\poly$ an unspecified polynomial and by $\negl$ an unspecified negligible function. For two functions $f_1(\secpar)$ and $f_2(\secpar)$, we will often use $f_1(\secpar) = f_2(\secpar) \pm \negl(\secpar)$ as a shorthand for $|f_1(\secpar) - f_2(\secpar)| \le  \negl(\secpar)$.

Honest (classical) parties are modeled as interactive Turing machines (ITMs). We use PPT and QPT to denote (classical) probabilistic polynomial time and quantum polynomial time, respectively.
For a classical probabilistic or quantum algorithm $\mcal{A}$, $y\sample \mcal{A}(x)$ means that $\mcal{A}$ is run on input $x$ and outputs $y$. When we consider a non-uniform QPT adversary, we specify it by a sequence of polynomial-size quantum circuits with quantum advice $\{\mcal{A}_\secpar, \rho_\secpar\}_{\secpar\in\mathbb{N}}$. In an execution with the security parameter $\secpar$, $\mcal{A}$ runs $\mcal{A}_{\secpar}$ taking $\rho_\secpar$ as the advice.  
For simplicity, we often omit the index $\secpar$ and just write $\mcal{A}(\rho)$ to mean a non-uniform QPT algorithm specified by  $\{\mcal{A}_\secpar, \rho_\secpar\}_{\secpar\in \mathbb{N}}$.

\para{Notations for Indistinguishability.}
%We define computational and statistical indistinguishability of quantum states. % similarly to \cite{STOC:BitShm20,C:ChiChuYam21,cryptoeprint:2021:1516}.
%except that we denote by $\qcind$ insteaf of $\cind$ to mean computational indistinguishability against quantum distinguishers to distinct it from the classical computational indistinguishability.
We may consider random variables over bit strings or over quantum states. 
This will be clear from the context.
We use the same notations for classical and quantum computational indistinguishability, but there should be no fear of confusion; It means computational indistinguishability against PPT (resp.\ QPT) distinguishers whenever we consider classical (resp.\ post-quantum) security.
For ensembles of random variables $\mathcal{X}=\{X_i\}_{\secpar\in \mathbb{N},i\in I_\secpar}$ and $\mathcal{Y}=\{Y_i\}_{\secpar\in \mathbb{N},i\in I_\secpar}$ over the same set of indices $I=\bigcup_{\secpar\in\mathbb{N}}I_\secpar$ and a function $\delta$,       
we use $\mathcal{X}\compind_{\delta}\mathcal{Y}$ to mean that for any non-uniform PPT (resp.\ QPT) algorithm $\mcal{A}$, there exists a negligible function $\negl(\cdot)$ such that for all $\secpar\in\mathbb{N}$, $i\in I_\secpar$, we have
\begin{equation}\label[Inequality]{eq:def:ind}
|\Pr[\mcal{A}(X_i)]-\Pr[\mcal{A}(Y_i)]|\leq \delta(\secpar) + \negl(\secpar).
\end{equation}
We say that $\mathcal{X}$ and $\mathcal{Y}$ are $\delta$-computationally indistinguishable if the above holds. 
In particular, when the above holds for $\delta=0$, we say that $\mcal{X}$ and $\mcal{Y}$ are computationally indistinguishable, and simply write $\mcal{X}\compind \mcal{Y}$.

Similarly, we use $\mcal{X}\sind_{\delta}\mcal{Y}$ to mean that for any unbounded time  algorithm $\mcal{A}$, there exists a negligible function $\negl(\cdot)$ such that for all $\secpar\in\mathbb{N}$, $i\in I_\secpar$, \Cref{eq:def:ind} holds. In particular, when the above hold for $\delta=0$, we say that $\mcal{X}$ and $\mcal{Y}$ are statistically indistinguishable, and simply write $\mcal{X}\sind \mcal{Y}$.
Moreover,  
we write $\mcal{X} \idind \mcal{Y}$ to mean
that $X_i$ and $Y_i$ are distributed identically for all $i\in I$. 

When we consider an ensemble $\mcal{X}$ that is only indexed by $\secpar$ (i.e., $I_\secpar=\{\secpar\}$), we write $\mcal{X}=\{X_\secpar\}_\secpar$ for simplicity.

\subsection{Post-Quantum Commitments}
We define (classically-secure and post-quantum) commitments. The following definitions are based on those in \cite{C:CCLY22}. 
\begin{definition}[Post-Quantum Commitments]\label{def:com}
A {\em post-quantum commitment scheme}  $\langle C, R \rangle$ is a classical interactive protocol between interactive \PPT machines $C$ and $R$. Let $m\in \bits^{\ell(\secpar)}$ (where $\ell(\cdot)$ is some polynomial) is a message that $C$ wants to commit to. The protocol consists of the following stages:
\begin{itemize}
\item
{\bf Commit Stage:} $C(m)$ and $R$ interact with each other to generate a transcript (which is also called a commitment) denoted by $\tau$,\footnote{That is, we regard the whole transcript as a commitment.} 
$C$'s state $\ST_{C}$, and 
$R$'s output $b_{\mathrm{com}}\in\Set{\bot,\top}$ indicating acceptance $(i.e., b_{\mathrm{com}}=\top)$ 
or rejection $(i.e., b_{\mathrm{com}}=\bot)$.
 We denote this execution by $(\tau,\ST_{C},b_{\mathrm{com}}) \gets \langle C(m), R \rangle(1^\secpar)$. When $C$ is honest, $\ST_C$ is classical, but when we consider a malicious quantum committer $C^*(\rho)$, we allow it to generate any quantum state $\ST_{C^*}$. 
 Similarly, a malicious quantum receiver $R^*(\rho)$ can output any quantum state, which we denote by $\OUT_{R^*}$ instead of $b_{\mathrm{com}}$. 
 %We denote this execution by
 %$(\com,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C(m), R \rangle(1^\secpar)$.
\item
{\bf Decommit Stage:}
$C$ generates a decommitment $\decom$ from $\ST_C$.
We denote this procedure by $\decom \gets C(\ST_C)$. 
Then it sends a message $m$ and decommitment $\decom$ to $R$, 
and $R$ outputs a bit
$b_{\mathrm{dec}}\in\Set{\bot, \top}$ indicating acceptance $(i.e., b_{\mathrm{dec}}=\top)$ 
or rejection $(i.e., b_{\mathrm{dec}}=\bot)$.
We assume that $R$'s verification procedure is deterministic and denote it
by $\Verify(\tau,m,\decom)$.\footnote{Note that $\Verify$ is well-defined since our syntax does not allow $R$ to keep a state from the commit stage.}
W.l.o.g., we assume that $R$ always rejects (i.e., $\Verify(\tau,\cdot,\cdot) = \bot$) whenever $b_\mathrm{com} = \bot$. (Note that w.l.o.g., $\tau$ can include $b_\mathrm{com}$ because we can always modify the protocol to ask $R$ to send $b_\mathrm{com}$ as the last round message.)
\end{itemize}

The scheme satisfies the following requirements:
\begin{enumerate}
\item
{\bf (Completeness.)} For any polynomial $\ell:\mathbb{N} \rightarrow \mathbb{N}$ and any $m \in \bits^{\ell(\secpar)}$, it holds that
\begin{equation*}
\Pr[b_{\mathrm{com}}=b_{\mathrm{dec}}=\top : 
\begin{array}{l}
(\tau, \ST_{C}, b_{\mathrm{com}}) \gets \langle C(m),R \rangle(1^\secpar) \\
\decom \gets C(\ST_C)\\
b_{\mathrm{dec}}\gets \Verify(\tau,m,\decom)
\end{array}
] = 1.
\end{equation*}

\item
{\bf (Statistically binding.)} For any unbounded-time committer $C^*$, the following holds: 
\begin{align*}
    \Pr[
    \begin{array}{l}
    \exists~m_0,m_1,\decom_0,\decom_1,~s.t.~m_0\neq m_1 ~\land\\
     \Verify(\tau,m_0,\decom_0)=\Verify(\tau,m_1,\decom_1)=\top
    \end{array}
    :(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*, R \rangle(1^\secpar)]=\negl(\secpar).
\end{align*}

\item
{\bf (Computationally Hiding.)} For any non-uniform QPT receiver $R^*$ and any polynomial $\ell : \mathbb{N} \rightarrow \mathbb{N}$, the following holds:
% \begin{equation*}
% \left|\Pr[\OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)=1]-  \Pr[\{\OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)=1]\right|=\negl(\secpar)
% \end{equation*}
$$\big\{ \OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)\big\}_{\secpar \in \mathbb{N}, ~m_0, m_1 \in \bits^{\ell(\secpar)}} ~\cind~ \big\{ \OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)\big\}_{\secpar \in \mathbb{N}, ~m_0, m_1 \in \bits^{\ell(\secpar)}},$$
where $\OUT_{R^*}\langle C(m_b),R^* \rangle(1^\secpar)$ $(b \in \bits)$ denotes the output of $R^*$ at the end of the commit stage. 
\end{enumerate}
\end{definition}


% \begin{definition}[Computationally Hiding]\label{def:comp-hiding}
% A commitment scheme $\langle C, R \rangle$ is {\em computationally hiding} if for any 
% non-uniform PPT receiver $R^*$ and any polynomial $\ell : \mathbb{N} \rightarrow \mathbb{N}$, the following holds:
% % \begin{equation*}
% % \left|\Pr[\OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)=1]-  \Pr[\{\OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)=1]\right|=\negl(\secpar)
% % \end{equation*}
% $$\big\{ \OUT_{R^*}\langle C(m_0),R^* \rangle(1^\secpar)\big\}_{\secpar \in \mathbb{N}, ~m_0, m_1 \in \bits^{\ell(\secpar)}} ~\cind~ \big\{ \OUT_{R^*}\langle C(m_1),R^* \rangle(1^\secpar)\big\}_{\secpar \in \mathbb{N}, ~m_0, m_1 \in \bits^{\ell(\secpar)}},$$
% where $\OUT_{R^*}\langle C(m_b),R^* \rangle(1^\secpar)$ $(b \in \bits)$ denotes the output of $R^*$ at the end of the commit stage. 
% %\begin{equation*}
% %\{\OUT_{R^*}\langle C(m_0),R^*(\rho) \rangle(1^\secpar) \}_{\secpar} \cind \{\OUT_{R^*}\langle C(m_1),R^*(\rho) \rangle(1^\secpar) \}_{\secpar}
% %\end{equation*}
% %where $\OUT_{R^*}$ denotes the output of $R^*$, which can be quantum.

% We say that $\langle C, R \rangle$ is \emph{post-quantum} computationally hiding if the above holds for all non-uniform \emph{QPT} $R^*$. 
% \end{definition}

% \begin{definition}[Statistically Binding]\label{def:stat-binding} 
% A commitment scheme $\langle C, R \rangle$ is {\em statistically binding} if for any unbounded-time committer $C^*$, the following holds: 
% \begin{align*}
%     \Pr[
%     \begin{array}{l}
%     \exists~m_0,m_1,\decom_0,\decom_1,~s.t.~m_0\neq m_1 ~\land\\
%      \Verify(\tau,m_0,\decom_0)=\Verify(\tau,m_1,\decom_1)=\top
%     \end{array}
%     :(\tau,\decom,b_{\mathrm{com}}) \gets \langle C^*, R \rangle(1^\secpar)]=\negl(\secpar).
% \end{align*}
% \end{definition}

For a statistically binding commitment scheme (e.g., the one defined in \Cref{def:com}), we often need to talk about the actual value that is ``committed'' by the committer at the end of the commit stage. For that purpose. we develop a notion in \Cref{def:com-val} for such a value. Note that this value is not efficiently computable (before the starting of the decommit stage) due to the hiding property of the commitment scheme. Rather, it is simply defined in a information-thoeretical sense.
\begin{definition}[Committed Values]\label{def:com-val}
For a statistically binding commitment scheme $\langle C, R \rangle$ (as per \Cref{def:com}), we define the value function as follows:
\begin{equation*}
    \val(\tau)\defeq 
    \begin{cases}
    m&\text{~if~}\exists\text{~unique~}m\text{~s.t.~}\exists~\decom, \Verify(\tau,m,\decom)=1\\
    \bot &\text{otherwise}
    \end{cases}. 
\end{equation*}
where $\Verify$ is as defined in \Cref{def:com}.
%where $\tau$ and $\decom$ are defined in the commit stage in \Cref{def:com}.
%We say that $\tau$ is valid if $\val_{\Prot}(\tau)\neq \bot$ and invalid if $\val_{\Prot}(\tau)=\bot$.
\end{definition}




\subsection{Post-Quantum Extractable Commitments}
% \para{Classically Extractable Commitments.} A commitment scheme is extractable if there exists an efficient extractor such that, the committed value can be extracted. We present the definition in \Cref{definition:ext-com}, which is taken from \cite{TCC:PasWee09}.  Constant-round constructions of (classically) extractable commitments are known from OWFs \cite{TCC:PasWee09}.
% % Constructions for such commitment already existed implicitly in the implementation of concurrent zero-knowledge protocols in \cite{FOCS:PraRosSah02,TCC:Rosen04}. This concept and construction was made explicit in \cite{TCC:MOSV06}, which also inherited the concurrent extractability from \cite{FOCS:PraRosSah02}. The standalone version was later formalized and used in other works \cite{TCC:PasWee09,EC:GGJS12,EC:GarKiyPan17}. It suffices our purpose once the extractability property holds in a standalone setting. We now present the definition (in \Cref{definition:ext-com}) and construction (in \Cref{protocol:ext-com}) used in \cite{TCC:PasWee09}.
% \begin{definition}[Classically Extractable Commitments]\label{definition:ext-com} A commitment $\ExtCom = \langle C,R\rangle$ is {\em extractable} if there exists an expected polynomial-time probabilistic oracle machine (the extractor) $\mathcal{E}$ that given oracle access to any PPT cheating committer $C^*$ outputs a pair $(\tau, \sigma^*)$ such that:
% \begin{itemize}
% \item
% {\bf Simulation:} $\tau$ is identically distributed to the view of $C^*$ at the end of interacting with an honest receiver $R$ in commitment phase.

% \item
% {\bf Extraction:} the probability that $\tau$ is accepting and $\sigma^* =\bot$ is negligible.
% \item
% {\bf Binding:} if $\sigma^* \ne \bot$, then it is statistically impossible to open $\tau$ to any value other than $\sigma^*$.
% \end{itemize}
% \end{definition} 



% \para{Post-Quantum Extractable Commitments.}
We define the post-quantum analog of extractable commitments, which we denote as PQ-ExtCom. As mentioned in the introduction, in the post-quantum setting, we need to explicitly require that the extractor (almost) does not disturb the (potentially malicious) committer's state during the extraction. However, it is not known black-box constructions of such post-quantum extractable commitments exist from (polynomially hard) post-quantum OWFs \cite{chia2022impossibility}.  
%\xiao{This is not accurate. If one gives up black-boxness, then \cite{STOC:BitShm20} is indeed a constant-round, post-quantum, fully-simulatable ExtCom from polynomial hardness assumptions. The virtue of \cite{C:CCLY22} is that it achieves black-box construction (and thus have to relax the definition to $\epsilon$-simulation). Pls modify this paragraph accordingly. }
Fortunately, a recent work \cite{C:CCLY22} showed that a constant-round construction from post-quantum OWFs is possible if we relax the extractability to allow an (arbitrarily small) noticeable simulation error. The following definitions are taken from \cite{C:CCLY22}.


\begin{definition}[PQ-ExtCom with $\epsilon$-Simulation]\label{def:epsilon-sim-ext-com:strong}
A post-quantum commitment scheme $\langle C, R\rangle$ (as per \Cref{def:com}) is {\em extractable with $\epsilon$-simulation} if there exists a QPT algorithm $\SimExt$ (called the $\epsilon$-simulation extractor) such that for any noticeable $\epsilon(\secpar)$ and any non-uniform QPT $C^*(\rho)$, 
\begin{equation*}
\big\{ \SimExt^{C^*(\rho)}(1^\secpar,1^{\epsilon^{-1}}) \big\}_\secpar
\sind_\epsilon
\big\{(\val(\tau), \ST_{C^*}):(\tau,\ST_{C^*},b_{\mathrm{com}}) \gets \langle C^*(\rho), R \rangle(1^\secpar)\big\}_\secpar,  
\end{equation*}
where $\val(\tau)$ is the value committed by $C^*$ as defined in \Cref{def:com-val}.
\end{definition}


% \xiao{(strong-strong SimExt.) Need a stronger version of extractable com: (1) The {\em committed} message is identically distributed in both the real game and SimExt game, although the SimExt game introduce an $\epsilon$ error; (2) the {\em extracted} value is always equal to the committed value as long as it is not $\bot$.} \xiao{After thinking more about it, I feel we may not need this stonger version anymore...}

\para{Parallel Extractability.} We also define in \Cref{def:epsilon-sim-ext-com:parallel} the parallel version of \Cref{def:epsilon-sim-ext-com:strong}. This definition considers polynomially many instances of a commitment {\em in parallel}, where the committers are malicious. It requires the existence of a simulation-extractor $\SimExt$ that simultaneously extract the values committed in all the sessions, while $\epsilon$-simulating the post-extraction state of the malicious committers. This definition is a little weak in the sense that it only requires $\SimExt$ to succeed when $R$ accepts in all the parallel sessions. In particular, when $R$ accepts in some sessions but not in others, the $\SimExt$ does not need to extract (or simulate) anything. As remarked in \cite{C:CCLY22}, an alternative stronger (and more natural) definition would require the $\SimExt$ to extract the committed values in all the sessions where $R$ accepts in the $j$-th session, and $\epsilon$-simulate the post-extraction state of the malicious committers across all the sessions (even for those where $R$ rejects at the end of commit stage). However, such a construction {\em in constant rounds} remains an open challenge, even with non-black-box techniques.


Fortunately, this weak parallel version as per \Cref{def:epsilon-sim-ext-com:parallel} suffices for our purpose.




\begin{definition}[Parallel Extractability with $\epsilon$-Simulation]\label{def:epsilon-sim-ext-com:parallel}
A post-quantum commitment scheme $\langle C, R\rangle$ (as per \Cref{def:com}) is {\em parallelly extractable with $\epsilon$-simulation} if 
for any integer $n=\poly(\secpar)$, there exists a QPT algorithm $\SimExt$ (called the parallel $\epsilon$-simulation extractor) such that for any noticeable $\epsilon(\secpar)$ and any non-uniform QPT $C^*(\rho)$, 
\begin{align*}
&\big\{ \SimExt^{C^*(\rho)}(1^\secpar,1^{\epsilon^{-1}}) \big\}_\secpar\\
\sind_\epsilon
&\big\{\big(\Gamma_{\{b_{\mathrm{com},j}\}_{j=1}^{n}}(\{\val(\tau_j)\}_{j=1}^{n}), \ST_{C^*}\big):(\{\tau_j\}_{j=1}^{n},\ST_{C^*},\{b_{\mathrm{com},j}\}_{j=1}^{n})\sample\execution{C^*(\rho)}{R^n}(1^\SecPar)\big\}_\secpar
\end{align*}
where 
$(\{\tau_j\}_{j=1}^{n},\ST_{C^*},\{b_{\mathrm{com},j}\}_{j=1}^{n})\sample\execution{C^*(\rho)}{R^n}(1^\SecPar)$
means that $C^*(\rho)$ interacts with $n$ copies of the honest receiver $R$ in parallel and the execution results in transcripts  $\{\tau_j\}_{j=1}^{n}$, the final state $\ST_{C^*}$, and outputs $\{b_{\mathrm{com},j}\}_{j=1}^{n}$ of each copy of $R$ and 
$$\Gamma_{\{b_{\mathrm{com},j}\}_{j=1}^{n}}(\{\val(\tau_j)\}_{j=1}^{n}) \coloneqq 
\begin{cases}
\{\val_\Prot(\tau_j)\}_{j=1}^{n} & \text{if}~\forall~j\in[n]~ b_{\mathrm{com},j} = \top \\
\bot & \text{otherwise}
\end{cases}.
$$
\end{definition}

Constant-round and black-box constructions are know for the above versions of post-quantum extractable commitments.
\begin{lemma}[\cite{C:CCLY22}]
\label{lem:parallel-extcom:CCLY}
Assume the existence of post-quantum one-way functions, there exist constant-round black-box constructions of:
\begin{itemize}
\item
post-quantum extractable commitments with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:strong})
\item
post-quatnum parallelly extractable commitments with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:parallel}).
\end{itemize}
\end{lemma}


\subsection{Post-Quantum Non-Malleable Commitments}\label{sec:nmcom}



We define post-quantum non-malleable commitments (PQ-NMC). Our definition follows the one in \cite{FOCS:LPY23}, but here we define {\em 1-many} non-malleability directly. We only state the definition in the synchronous setting, supporting polynomially many tags. As mentioned in the introduction, this version suffices for all applications herein. 

In fact, we will define and rely on a form of 1-many non-malleability that is weaker than the standard notion, which we accordingly title {\em weak} (1-many) non-malleability.  This bears resemblance to the weak parallel extractability defined above for extractable commitments, in that we will only expect the non-malleability condition to hold in the parallel execution {\em provided every session of this execution is completed successfully} (i.e., the receiver in each session accepts the corresponding interaction).

We will start by defining the notion of a man-in-the-middle execution in the 1-many setting, and then present the standard and our weak definition of non-malleability in this setting. 


\para{1-Many Man-in-the-Middle Execution.} Let $\langle C, R\rangle$ be a statistically binding and computationally hiding post-quantum commitment scheme. We use a {\em tag-based} specification so that every execution of $\langle C, R\rangle$ is associated with a tag $t\in [T]$, where $T$ is an integer. Consider a non-uniform QPT adversary $\mcal{M} = \Set{\mcal{M}_\secpar, \rho_\secpar}_\secpar$ participating in $(k+1)$ instances of $\langle C, R\rangle$ as follows: $\mcal{M}_\secpar(\rho_\secpar)$ plays the role of the receiver in one instance (referred to as the {\em left session}), while simultaneously acting as a committer in the other $k$ sessions (referred to as the {\em right sessions}). {\em All the $(k+1)$ sessions are execute in parallel}, and we refer to this setting as the {\em synchronous 1-$k$ MIM execution}, where ``MIM'' is the acronym for ``man-in-the-middle.'' 

Notation-wise, we denote the relevant entities used in the right interaction as the ``tilde'd'' version of the corresponding entities on the left. In particular, let $t$ denote the tag associated with the left session and $(\tilde{t}_1, \ldots, \tilde{t}_k)$ denote the tags for the $k$ right sessions respectively; let $m$ denote the value committed by the honest $C$ in the left session, and $(\tilde{m}_1, \ldots, \tilde{m}_k)$ the values committed by $\mcal{M}_{\secpar}(\rho_\secpar)$ in the $k$ right sessions respectively, i.e., we set $\tilde{m}_i=\val(\tilde{\tau}_i)$ where $\tilde{\tau}_i$ is the transcript of the $i$-th right session (see \Cref{def:com-val}). 

For this 1-$k$ MIM execution, let $\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m, \rho_\secpar)$ denote concatenation of the final output of $\mcal{M}_\secpar(\rho_\secpar)$ and the values committed in all the $k$ right sessions, {\em when the honest $C$ in the left session commits to value $m$}. That is, 
$$\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m, \rho_\secpar)\coloneqq \big(\OUT_{\mcal{M}}, (\tilde{m}_1, \ldots, \tilde{m}_k) \big).$$

 
\begin{definition}[Standard Synchronous 1-Many PQ-NMC]\label{def:NMCom:pq}
A post-quantum statistically binding commitment $\langle C, R \rangle$ is said to be 1-$k$ non-malleable if for all polynomial $\ell(\cdot)$ and all non-uniform QPT adversaries $\mcal{M} = \Set{\mcal{M}_\secpar, \rho_\secpar}_\secpar$ participating the above synchronous 1-$k$ MIM execution with $t \ne \tilde{t}_i$ for all $i \in [k]$, it holds that
$$\big\{\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m_0, \rho_\secpar)\big\}_{\secpar \in \Naturals, m_0, m_1 \in \bits^{\ell(\secpar)}} ~\cind~ \big\{\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}( m_1, \rho_\secpar)\big\}_{\secpar \in \Naturals, m_0, m_1 \in \bits^{\ell(\secpar)}}.$$
\end{definition}
Some remarks follow:
\begin{enumerate}
\item 
\Cref{def:NMCom:pq} requires that the left-session tag $t$ is different from those for all right sessions. This is standard practice when defining non-malleability, with the purpose of ruling out the uninteresting case when $\mcal{M}$ is simply acting as a channel, forwarding messages from $C$ on the left to the $R$ on some right session. 
\item 
 \Cref{def:NMCom:pq} does not consider entanglement between $\mcal{M}$'s auxiliary input and distinguisher's auxiliary input. However, \cite[Claim 3.1]{EC:BitLinShm22} shows that the above definition implies the version that considers such entanglement.  
 \item 
 {\bf (1-1 Non-Malleability.)}
 When $k=1$, \Cref{def:NMCom:pq} degenerates to the standard definition of post-quantum non-malleability (in the synchronous setting).
 \end{enumerate} 

Next we turn to our weaker definition of 1-many non-malleability. 

\begin{definition}[Weak 1-Many PQ-NMC]\label{def:NMCom:weak:pq}
Let $\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m, \rho_\secpar)$ denote the output of the synchronous 1-$k$ man-in-the-middle execution as above, and let $d_j \in \Set{\top, \bot}$ denote the decision of the receiver in each session for $j \in [k]$. Define the function $\Gamma_{\{d_j\}_{j=1}^{k}}(\cdot)$ as follows: 
$$\Gamma_{\{d_j\}_{j=1}^{k}}(\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m, \rho_\secpar)) \coloneqq 
\begin{cases}
\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m, \rho_\secpar) & \text{if}~\forall~j\in [k], ~d_j = \top \\
(\OUT_{\mcal{M}},\bot^k) & \text{otherwise}
\end{cases},
$$
where $\OUT_{\mcal{M}}$ is the first component of $\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m, \rho_\secpar)$.

\xiao{need to check: if we really need to simulate for $\OUT_{\mcal{M}}$ in the bad case.   }

A post-quantum statistically binding commitment $\langle C, R \rangle$ is said to be {\em weakly} 1-$k$ non-malleable if for all polynomial $\ell(\cdot)$ and all non-uniform QPT adversaries $\mcal{M} = \Set{\mcal{M}_\secpar, \rho_\secpar}_\secpar$ participating the above synchronous 1-$k$ MIM execution with $t \ne \tilde{t}_i$ for all $i \in [k]$, it holds that 

\begin{align*}
&\big\{\Gamma_{\{d_j\}_{j=0}^{k}}(\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m_0, \rho_\secpar))\big\}_{\secpar \in \Naturals, m_0, m_1 \in \bits^{\ell(\secpar)}}\\
\cind~
&\big\{\Gamma_{\{d_j\}_{j=0}^{k}}(\msf{mim}[k]^{\mcal{M}_\secpar}_{\langle C, R \rangle}(m_1, \rho_\secpar))\big\}_{\secpar \in \Naturals, m_0, m_1 \in \bits^{\ell(\secpar)}}
.\end{align*}

\end{definition}

\begin{remark}
    Note that \Cref{def:NMCom:pq} and \Cref{def:NMCom:weak:pq} are in fact {\em equivalent} in the basic 1-1 setting (i.e., the man-in-the-middle runs exactly one left and right session each). This is easily verified by observing the definition of the output in the MIM experiment: it is clear to see that in cases where the right interaction is completed successfully, the definitions are identical. On the other hand, when the right interaction is not completed successfully, the output according to both \Cref{def:NMCom:pq} and \Cref{def:NMCom:weak:pq} consists of the output state of the MIM and the $\bot$ symbol. 
\end{remark}

\begin{remark}
    We further observe that in analogy with the standard definition, weak one-many non-malleability also implies weak {\em many-many} non-malleability (which can be defined analogously). As in the standard case, this can be easily inferred from a standard hybrid argument (where the input in each left session is switched in turn). 
\end{remark}


% \begin{remark}[On Entangled Auxiliary Information.]
% The above definition does not consider entanglement between $\mcal{M}$'s auxiliary input and distinguisher's auxiliary input. 
% However, \cite[Claim 3.1]{EC:BitLinShm22} shows that the above definition implies the version that considers such entanglement. 
% %\xiao{make a remark about the entanglement between $\mcal{M}$'s auxiliary input and the distinguisher's. Refer the reader to \cite[Claim 3.1]{BLS21} for more details.}
% \end{remark}


% \para{Synchronous Adversaries:} This notion refers to man-in-the-middle adversaries who upon receiving a message in the left (reps.\ right) session, immediately respond with the corresponding message in the right (resp.\ left) session. An adversary is said to be {\em asynchronous} if it is not synchronous.

% \rohit{Add 1-many NMC def}


% \xiao{Probably there is no need to define 1-1 non-malleability. 1-many synchronous non-malleable commitments with poly-size tag space suffices for our application.}

% \begin{definition}[1-Many Post-Quantum Non-Malleable Commitments]
% \label{def:1-many:PQNMC}
% \xiao{to do..}
% \end{definition}



\subsection{Post-Quantum MPC with $\epsilon$-Simulation}
We present the formal definition for PQ-MPC with $\epsilon$-simulation. It is identical to the standard MPC definition in the classical setting except that:
\begin{enumerate}
\item
The malicious party can be a QPT machine;
\item
The indistinguishability between the real-world execution and the simulated one is parameterized by a noticeable function $\epsilon(\secpar)$. 
\end{enumerate}
Consider $n$ parties $P_1, \ldots, P_n$ who wish to interact in a protocol $\Prot$ to evaluate a $n$-party classical functionality $f$ on their joint inputs. They communicate via authenticated point-to-point channels as well as broadcast channels, where everyone can send messages in the same round. The network is assumed to be synchronous with rushing adversaries, i.e. adversaries may generate their messages for any round after observing the messages of all honest parties in that round, but before observing the messages of honest parties in the next round. 

In this work, we consider a {\em static} adversary, namely, at the
beginning of the execution the adversary specifies a set $I$ of corrupted parties which she controls, and through the execution she will not change the set $I$. The ideal and real executions follow the standard description as in, e.g., \cite{Goldreich04,EPRINT:Lindell16}.

In the real world, a non-uniformal QPT adversary $\Adv= \Set{\Adv_\secpar, \rho_\secpar}_\secpar$ corrupting $\Set{P_i}_{i\in I}$ interacts with $\Set{P_i}_{i\in [n] \setminus I}$. Let $\vb{x} = (x_1, \ldots, x_n)$ denote the respective initial input to each party. Let $\REAL_{\Prot, \Adv_\secpar, I}(\secpar, \vb{x}, \rho_\secpar)$ denote the random variable consisting of the output of the adversary (which may be an arbitrary function of its view and in particular may be a quantum state) {\em and} the outputs of the uncorrupted parties $\Set{P_i}_{i\in [n] \setminus I}$. 

In the ideal world, a QPT machine $\Sim$ controls the same parties in $I$ as $\Adv_\secpar$. It gets $\Set{x_i}_{i \in I}$ as input and is granted black-box access to $\Adv_\secpar(\rho_\secpar)$. Similar as in the $\epsilon$-ZK definition \cite{C:ChiChuYam21,C:CCLY22}, $\Sim$ additionally takes as input a ``slackness parameter'' $\epsilon(\secpar)$, which is a noticeable function on $\secpar$. Henceforth, we always require that $\Sim$'s running time is a polynomial on both $\secpar$ and $\epsilon^{-1}$. In this ideal-world execution, let $\IDEAL_{f,\Sim,I}(\secpar, \epsilon, \vb{x}, \rho_\secpar)$ denote the outputs of $\Sim$ (with slackness $\epsilon$) and the outputs of the uncorrupted parties $\Set{P_i}_{i\in [n] \setminus I}$. 

\begin{definition}[Post-Quantum MPC with  $\epsilon$-Simulation] \label{def:mpc}
 Let $f$ be a classical $n$-party functionality, and $\Prot$ be a classical $n$-party protocol. We say that $\Prot$ is a post-quantum MPC protocol for $f$ with $\epsilon$-simulation if there exists a QPT simulator $\Sim$ such that for any non-uniform QPT adversary $\Adv = \Set{\Adv_\secpar, \rho_\secpar}_{\secpar\in\Naturals}$, any $I \subset [n]$, any $\vb{x}\in (\bits^*)^n$, and any noticeable function $\epsilon(\secpar)$, it holds that:
$$\Set{\REAL_{\Prot, \Adv_\secpar, I}(\secpar, \vb{x}, \rho_\secpar)}_{\secpar \in \Naturals} ~\cind_\epsilon~ \Set{\IDEAL_{f,\Sim,I}(\secpar, \epsilon, \vb{x}, \rho_\secpar)}_{\secpar \in \Naturals}.$$
\end{definition}







\subsection{Verifiable Secret Sharing and Information-Theoretic MPC}

\para{Verifiable Secret Sharing.} We present in \Cref{def:VSS} the definition of verifiable secret sharing (VSS) schemes \cite{FOCS:CGMA85}. We remark that \cite{STOC:BenGolWig88,EC:CDDHR99} implemented $(n+1, \lfloor n/3 \rfloor)$-perfectly secure VSS schemes. These constructions suffice for all the applications in the current paper.
 % It is a two-stage secret sharing protocol for implementing the following functionality. In the first stage, denoted by $\VSS_\Share$, a special player referred to as dealer, shares a secret $s$ among $n$ players, in the presence of at most $t$ corrupted players. In the second stage, denoted by $\VSS_\Recon$, players exchange their views of the Share Stage and reconstruct the values. The functionality ensures that when the dealer is honest, before the second stage begins, the $t$ corrupted players have no information about the secret. Moreover, when the dealer is dishonest, at the end of the Share Stage the honest players would have realized it through an accusation mechanism that disqualifies the dealer.
\begin{definition}[Verifiable Secret Sharing]\label{def:VSS}
An $(n + 1, t)$-perfectly secure VSS scheme $\Prot_\VSS$ consists of a pair of protocols $(\VSS_\Share, \VSS_\Recon)$ that implement respectively the sharing and reconstruction phases as follows.
\begin{itemize}
\item {\bf Sharing Phase $\VSS_\Share$:} 
Player $P_{n+1}$ (referred to as dealer) runs on input a secret $s$ and randomness $r_{n+1}$, while any other player $P_i$ $(i \in [n])$ runs on input a randomness $r_i$. During this phase players can send (both
private and broadcast) messages in multiple rounds.
\item {\bf Reconstruction Phase $\VSS_\Recon$:}
Each shareholder sends its view $v_i$ $(i \in [n])$ of the Sharing Phase to each other player, and on input the views of all players (that can include bad or empty views) each player outputs a reconstruction of the secret $s$.
\end{itemize}
All computations performed by honest players are efficient. The computationally unbounded adversary can corrupt up to t players that can deviate from the above procedures. The following security properties
hold.
\begin{enumerate}
\item {\bf Perfectly Verifiable-Committing:} \label[Property]{item:def:VSS:vc}
if the dealer is dishonest, then one of the following two cases happen (i.e., with probability 1): 
\begin{enumerate}
\item \label[Case]{item:def:VSS:vc:case:1}
During the Sharing Phase, honest players disqualify the dealer, therefore they output a special value $\bot$ and will refuse to play the reconstruction phase; 
\item \label[Case]{item:def:VSS:vc:case:2}
During the Sharing Phase, honest players do not disqualify the dealer. Therefore such a phase determines a unique value $s^*$
that belongs to the set of possible legal values that does not include $\bot$, which will be reconstructed by the honest players during the
reconstruction phase.
\end{enumerate} 
\item \label[Property]{item:def:VSS:secrecy}
{\bf Secrecy:} 
if the dealer is honest, then the adversary obtains no information about the shared secret before running the protocol $\Recon$. More accurately, there exists a PPT oracle machine $\Sim^{(\cdot)}$ such that for any message $m$, and every (potentially inefficient) adversary $\Adv$ corrupting a set $T$ of parties with $|T|\le t$ during the Sharing Phase $\VSS_\Share(m)$ (denote $\Adv$'s view in this execution as $\View_{\Adv, T}(1^\secpar, m)$), the following holds: 
$\Set{\View_{\Adv, T}(1^\secpar, m)} \idind \Set{\Sim^\Adv(1^\secpar, T)}$.
 
%  and any (potentially unbounded) adversary $\Adv$


% denoted the set of corrupted parties by $A$ and their corresponding views during the sharing phase as $\Set{\view_i}_{i\in A}$. Then, for any message $m$, there exists a complementary set of view $\Set{\view_j}_{j \in [n]\setminus A}$ such that $\VSS_\Recon(\view_1, \ldots, \view_n) = m$. (Actually, given arbitrary $m$ and $\Set{\view_i}_{i\in A}$ $(|A|<t)$, the scheme from \cite{STOC:BenGolWig88,EC:CDDHR99} allows efficient construction of the set $\Set{\view_j}_{j \in [n]\setminus A}$.)

\item {\bf Correctness:}
 if the dealer is honest throughout the protocols, then each honest player will output the shared secret $s$ at the end of protocol $\Recon$.
\end{enumerate}
\end{definition}


\para{Information-Theoretically Secure MPC.} We first recall {\em information-theoretically secure} MPC and relevant notions that will be employed in the MPC-in-the-head paradigm shown later.

\para{Information-Theoretic MPC.} We now define MPC in the information-theoretic setting (i.e., secure against unbounded adversaries). 
%Both the ideal and real executions are identical to the ones described in \Cref{sec:prelim:computational-MPC}, except that the machines $\Adv$ and $\Sim$ are computationally unbounded now.

 % Secure multi-party computation protocols allow several parties to compute a function $f$ on their joint private inputs even in the presence of corrupted parties that try to glean other parties' inputs. Formally, we consider $n$ different parties, of whom $t$ parties are corrupted. Further, let \Adv denote a real world adversary for protocol $\Prot$ that recieves auxillary input $z$, and $S$ denote an ideal world adversary for $\Prot$. Denote by $\REAL_{\Prot,\Adv(z),I}(\vec{x})$ the random variable consisting of the output of \Adv controlling a set of corrupted parties $I$, and the outputs of the honest parties with respect to an execution of $\Prot$ where party $P_i$ has input $x_i$ for $i \in [n]$, and $\vec{x} = (x_1,\dots x_n)$. Similarly, denote by $\IDEAL_{f,S(z),I}(\vec{x})$ the corresponding output of $S$ and other honest parties after an ideal execution with a trusted party computing $f$ on inputs $\vec{x}$. We refer the reader to \cite{Goldreich04} for a detailed description of the ideal and real executions.   

\begin{definition}[Perfectly/Statistically-Secure MPC]\label{def:MPC}
Let $f:(\Set{0,1}^*)^n \mapsto (\Set{0,1}^*)^n$ be an n-ary functionality, and let $\Prot$ be a protocol. We say that $\Prot$ {\em $(n,t)$-perfectly (resp., statistically) securely} computes $f$ if for every static, malicious, and (possibly-inefficient) probabilistic adversary $\Adv$ in the real model, there exists a probabilistic adversary $\Sim$ of comparable complexity (i.e., with running time polynomial in that of $\Adv$) in the ideal model, such that for every $I \subset [n]$ of cardinality at most $t$, every $\vec{x} = (x_1,\dots,x_n) \in (\Set{0,1}^*)^n$ (where $|x_1|=\dots=|x_n|$), and every $z \in \Set{0,1}^*$, it holds that: 
$$\Set{\REAL_{\Prot,\Adv(z),I}(\vec{x})} \idind \Set{\IDEAL_{f,\Sim(z),I}(\vec{x})} ~~~~\big(\text{resp.,}~\Set{\REAL_{\Prot,\Adv(z),I}(\vec{x})} \sind \Set{\IDEAL_{f,\Sim(z),I}(\vec{x})}\big).$$   
\end{definition}
%[\rohit{def from \cite{FOCS:GLOV12}}]
Recall that the MPC protocol from \cite{STOC:BenGolWig88} achieves $(n,t)$-perfect security (against static and malicious adversaries) with $t$ being a constant fraction of $n$.
\begin{theorem}[\cite{STOC:BenGolWig88}]\label{thm:BGW88}
Consider a synchronous network  with  pairwise  private  channels. Then,  for every $n$-ary functionality $f$, there exists a protocol that $(n,t)$-perfectly securely computes $f$ in the presence of a static malicious adversary for any $t < n/3$.
\end{theorem}

\para{Consistency, Privacy, and Robustness.} We now define some {notation} related to MPC protocols. Their roles will become clear when we discuss the MPC-in-the-head technique later. 
\begin{definition}[View Consistency]
\label{def:view-consistency}
A view $\View_i$ of an honest player $P_i$ during an MPC computation $\Prot$ contains input and randomness used in the computation, and all messages received from and sent to the communication tapes. A pair of views $(\View_i,\View_j)$ is {\em consistent} with each other if 
\begin{enumerate}
  \item Both corresponding players $P_i$ and $P_j$ individually computed each outgoing message honestly by using the random tapes, inputs and incoming messages specified in $\View_i$ and $\View_j$ respectively, and:
  \item All output messages of $P_i$ to $P_j$ appearing in $\View_i$ are consistent with incoming messages of $P_j$ received from $P_i$ appearing in $\View_j$ (and vice versa).  
\end{enumerate}   
\end{definition}
\begin{remark}[View Consistency of VSS]\label{rmk:VSS:view-consistency}
Although \Cref{def:view-consistency} defines view consistency for MPC protocols, we will also refer to the view consistency for the execution of verifiable secret sharing schemes (\Cref{def:VSS}). The views $(\view_i, \view_j)$ of players $i$ and $j$ (excluding the dealer) during the execution of $\VSS_\Share$ is said to be consistent if any only if $(\view_i, \view_j)$ satisfies the two requirements in \Cref{def:view-consistency}.
\end{remark}

We further define the notions of correctness, privacy, and robustness for multi-party protocols. 

\begin{definition}[Semi-Honest Computational Privacy]\label{def:t-privacy}
Let $1\leq t<n$, let $\Prot$ be an MPC protocol, and let $\Adv$ be any {\em static, PPT, and semi-honest} adversary. We say that $\Prot$ realizes a function $f:(\Set{0,1}^*)^n \mapsto (\Set{0,1}^*)^n$ with {\em semi-honest $(n,t)$-computational privacy} if there is a PPT simulator $\Sim$ such that for any inputs $x,w_1,\dots,w_n$, every subset $T \subset [n]$ $(|T| \leq t)$ of players corrupted by $\Adv$, and every $D$ with circuit size at most $\mathsf{poly(\SecPar)}$, it holds that 
{\fontsize{10.5pt}{0pt}\selectfont
\begin{equation}
\big|\Pr[D(\View_T(x,w_1,\dots,w_n)) =1]- \Pr[D(\Sim(T,x,\Set{w_i}_{i \in T},f_T(x,w_1,\dots,w_n)))=1]\big| \leq \negl(\SecPar),
\end{equation}}
where $\View_T(x,w_1,\dots,w_n)$ is the joint view of all players.
% the joint view $\View_T(x,w_1,\dots,w_n)$ of players in $T$ is distributed identically to $\Sim(T,x,(wi_i)_{i \in T},f_T(x,w_1,\dots,w_n))$. The relaxations to statistical or computational privacy are defined in the natural way. That is, in the statistical (resp., computational) case we require that for every distinguisher $D$ (resp. $D$ with circuit size at most $\mathsf{poly(\SecPar)}$) there is a negligible function $\delta(\cdot)$ such that 
% \begin{equation}
% \big|\Pr[D(\View_T(x,w_1,\dots,w_n)) =1]- \Pr[D(\Sim(T,x,\Set{w_i}_{i \in T},f_T(x,w_1,\dots,w_n)))=1]\big| \leq \delta(\SecPar).
% \end{equation}
\end{definition} 


\begin{definition}[Statistical/Perfect Correctness]\label{def:MPC-correctness}
Let $\Prot$ be an MPC protocol. We say that $\Prot$ realizes a deterministic n-party functionality $f(x,w_1,\dots,w_n)$ with {\em perfect (resp., statistical)} correctness if for all inputs $x,w_1,\dots,w_n$, the probability that the output of some party is different from the output of $f$ is 0 (resp., negligible in $k$), where the probability is over the independent choices of the random inputs $r_1,\dots,r_n$ of these parties.   
\end{definition}



\begin{definition}[Perfect/Statistical Robustness] \label{def:t-robustness}
Assume the same setting as the previous definition. We say that $\Prot$ realizes $f$ with {\em $(n,t)$-perfect (resp., statistical) robustness} if in addition to being perfectly (resp., statistical) correct in the presence of a semi-honest adversary as above, it enjoys the following {\em robustness} property against any computationally unbounded malicious adversary corrupting a set $T$ of at most $t$ parties, and for any inputs $(x,w_1,\dots,w_n)$: if there is no $(w_1',\dots,w_n')$ such that $f(x,w_1',\dots,w_n')=1$, then the probability that some uncorrupted player outputs 1 in an execution of $\Prot$ in which the inputs of the honest parties are consistent with $(x,w_1,\dots,w_n)$ is 0 (resp., negligible in \SecPar).    
\end{definition}


\subsection{MPC-in-the-Head}
\label{sec:prelim:MitH}


 MPC-in-the-head (MitH) is a technique originally developed for constructing  black-box ZK protocols from MPC protocols \cite{STOC:IKOS07}. Intuitively, the MPC-in-the-head idea works as follows.  Let $\Func_\textsc{zk}$ be the zero-knowledge functionality for an \NP language. Assume there are $n$ parties holding a witness in a secret-sharing form. $\Func_\textsc{zk}$ takes as public input $x$ and one share from each party, and outputs 1 iff the secret reconstructed from the shares is a valid witness.
To build a ZK protocol, the prover runs in his head an execution of MPC w.r.t.\ $\Func_\textsc{zk}$ among $n$ imaginary parties, each one participating in the protocol with a share of the witness. Then, it commits to the view of each party separately. The verifier obtains $t$ randomly chosen views, checks that such views are ``consistent'' (see \Cref{def:view-consistency}), and accepts if the output of every party is 1. The idea is that, by selecting the $t$ views at random, $V$ will catch inconsistent views if the prover cheats.

We emphasize that, in this paradigm, a malicious prover decides the randomness of each virtual party, including those not checked by the verifier (corresponding to honest parties in the MPC execution). Therefore, MPC protocols with standard computational security may fail to protect against such attacks. We need to ensure that the adversary cannot force a wrong output even if it additionally controls the honest parties' random tapes. The $(n,\lfloor n/3 \rfloor)$-perfectly secure MPC protocol in \Cref{thm:BGW88} suffices for this purpose (see also \Cref{rmk:exact-mpc-requriements:mpc-in-the-head}).

One can extend this technique further (as in \cite{FOCS:GLOV12}), to prove a general predicate $\phi$ about an arbitrary value $\alpha$.  Namely, one can consider the functionality $\Func_\phi$ in which party $i$ participates with input a VSS share $[\alpha]_i$. $\Func_\phi$ collects all such shares, and outputs 1 iff $\phi(\VSS_\Recon([\alpha]_1,\ldots,[\alpha]_n)) = 1$.



\begin{remark}[Exact Security Requirements on the Underlying MPC.] 
\label{rmk:exact-mpc-requriements:mpc-in-the-head}
To be more accurate, any MPC protocol that achieves {\em semi-honest $(n,t)$-computational privacy (as per \Cref{def:t-privacy}) and $(n,t)$-perfect robustness (as per \Cref{def:t-robustness})} will suffice for the MPC-in-the-head application.\footnote{It is also worth noting that the $(n,t)$-perfect robustness could be replaced with {\em adaptive $(n,t)$-statistical robustness}. See \cite[Section 4.2]{STOC:IKOS07} for more details.} These two requirements are satisfied by any $(n,t)$-perfectly secure MPC (and, in particular, the one from \Cref{thm:BGW88}).
\end{remark}


\para{MPC-in-the-Head Commitments.} We present a hiding game that relies on the (MitH) technique, and show that no QPT adversary can win this game with non-negligible probability. This game is essentially a black-box post-quantum commitment protocol due to \cite{FOCS:GLOV12,C:CCLY22}. We choose to present it as the following hiding game because this game will be of direct use later when proving the security of our protocol in \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding} (particularlly in \Cref{lem:bb-nmc:similarity:g:til}).


\begin{ExperimentBox}[label={chall:vss:hide}]{VSS Hiding Game}
{\bf Parameters:} Let $n(\secpar)$ be a polynomial in $\secpar$. Let $k$ be a constant-fraction of $n$ such that $k \le \frac{n}{3}$.

This involves an (efficient) challenger $\algo{Ch}$ interacting with the adversary $\Adv$. The interaction proceeds as follows: 
\begin{enumerate}
    \item \label[Step]{chall:vss:hide:step:1}
    $\Adv$ selects messages $m_0,m_1 \in \bits^\secpar$ and sends these to $\algo{Ch}$.
    
    \item \label[Step]{chall:vss:hide:step:2}
    Next, $\Adv$ samples a random size-$k$  subset $\eta$ of $[n]$. It then runs an interaction of $\ExtCom$ (as per \Cref{def:epsilon-sim-ext-com:strong}) with $\algo{Ch}$, where it commits to $\eta$. 

    \item \label[Step]{chall:vss:hide:step:3}

    $\algo{Ch}$ prepares $n$ views $\Set{\msf{v}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the message $m_b$ (see \Cref{rmk:mpc-in-the-head-vss} for details). $\algo{Ch}$ commits to each $\msf{v}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.


\begin{remark}\label{rmk:mpc-in-the-head-vss}
 We describe this step more explicitly. $\algo{Ch}$ emulates $n+1$ virtual parties $\Set{P_i}_{i \in [n+1]}$ `in its head.' Party $P_{n+1}$ is the dealer, possessing the string $x$. Other parties do not have any input. These parties execute the $\VSS_\Share$ stage of the $(n+1,k)$-VSS scheme to compute the functionality $\VSS_\Share$. At the end of the execution, $P_i$ ($i\in [n]$) obtains the $i$-th $\VSS$ share of $m_b$ as the output, and $P_{n+1}$ does not receive any output. The $\Set{\msf{v}_i}_{i \in [n]}$ corresponds to the views of $\Set{P_i}_{i \in [n]}$ from this execution (emulated in $\algo{Ch}$'s head).
 \end{remark} 

    \item \label[Step]{chall:vss:hide:step:4}
    $\Adv$ sends $\eta$ togther with the decommitment informaiotn w.r.t.\ the $\ExtCom$ in \Cref{chall:vss:hide:step:2}.

    \item \label[Step]{chall:vss:hide:step:5}
    $\algo{Ch}$ then decommits to the VSS shares in the set $\eta$, i.e. it sends $\Set{\msf{v}_i}_{i \in \eta}$ along with the corresponding decommitment information w.r.t.\ the commitment in \Cref{chall:vss:hide:step:3}. 

    \item \label[Step]{chall:vss:hide:step:6}
    Finally, $\Adv$ submits a guess bit $b'$ corresponding to its estimate of which message was committed to by $\algo{Ch}$.
\end{enumerate}

\para{Output:} We use $\VSS_{\msf{hd}}(1^\secpar, \Adv)$ to denote the output of this game, where $\VSS_{\msf{hd}}(\Adv) = 1$ iff $b' = b$.
\end{ExperimentBox}


\begin{lemma}\label{lem:game:VSS:hiding}
For any QPT adversary $\Adv$, it holds that
$\Pr[ \VSS_{\msf{hd}}(1^\secpar, \Adv) = 1] = \frac{1}{2} \pm \negl(\secpar)$, 
where $\VSS_{\msf{hd}}(1^\secpar, \Adv)$ is defined in \Cref{chall:vss:hide}.
\end{lemma}

\begin{proof}[Proof Sketch]
The proof of this lemma already appears in \cite[Section 6.5]{C:CCLY22}. Here, we only recall the high-level idea. We will show the when $\algo{Ch}$ changes the committed value from $m_0$ to $m_1$, $\Adv$ cannot tell the difference. For this, we assume for contradiction that $\Adv$ can tell the different with some inverse-polynomial advantage $\delta(\secpar)$ for infinitely many $\secpar \in \Naturals$. Then, $\algo{Ch}$ can extract the subset $\eta$ from \Cref{chall:vss:hide:step:2}, using the simulation-extractor $\SimExt$ guaranteed by \Cref{def:epsilon-sim-ext-com:strong}, setting the error parameter $\epsilon \coloneqq \frac{\delta}{3}$.

With the $\eta$ in hand, $\algo{Ch}$ does not need to generate the views $\Set{\msf{v}_i}_{i \in [n]}$ in \Cref{chall:vss:hide:step:3} honestly. Instead, it can invoke the $(n,k)$-MitH simulator to simulate the views in set $\eta$, and set other views  $\Set{\msf{v}_i}_{i \in [n]\setminus \eta}$ to all-0 strings with proper length. By the security of the underlying $(n,k)$-MPC, the views in $\eta$ does not contain any information of the committed value $m_b$. This helps $\algo{Ch}$ to change the committed value from $m_0$ to $m_1$.

By our parameter setting $\epsilon \coloneqq \frac{\delta}{3}$, after $\algo{Ch}$ changes the committed value from $m_0$ to $m_1$, $\Adv$ can tell the different with probability at most $\frac{2\delta}{3}$, which is still smaller than $\delta$, reaching the desired contradiction. 
    
\end{proof}


\para{MPC-in-the-Head Interactive Arguments.} As a proof of concept, we show in the following a constant-round black-box interactive argument built from the MitH technique. This protocol is taken from \cite{STOC:IKOS07,C:CCLY22}. A prover $C$ first commits to a string $x$, and then starts to interact with the verifier $R$ for the statement that the committed $x$ satisfies a predicate $\phi(\cdot)$. The soundness requirement is: if $\phi(x) = 0$, then the verifier will reject the proof except for negligible probability. 

\begin{ProtocolBox}[label={protocol:BB-ZK}]{MPC-in-the-Head Interactive Argument}
{\bf Parameters:} Let $n$ be a polynomial in $\SecPar$, and $k$ be a constant fraction of $n$ such that $k \le n/3$. We will employ a $(n+1, k)$ $\VSS$ scheme and a $(n,k)$-secure MPC scheme. 

{\bf Inputs:} Both parties receive $\secpar$ as the common input. The prover in addition gets a string $x$ as its private input.  

\para{Commit Stage:} In this stage, $C$ commits to the string $x$ (using the MitH approach).
\begin{itemize}
\item $C$ prepares $n$ views $\Set{\msf{v}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $x$ (see \Cref{rmk:mpc-in-the-head-vss} for details). $C$ commits to each $\msf{v}_i$ ($i \in [n]$) independently in parallel, using Naor's commitment.
\end{itemize}

% \begin{remark}\label{rmk:mpc-in-the-head-vss}
%  We describe this step more explicitly. $C$ emulates $n+1$ virtual parties $\Set{P_i}_{i \in [n+1]}$ `in its head.' Party $P_{n+1}$ is the dealer, possessing the string $x$. Other parties do not have any input. These parties execute the $\VSS_\Share$ stage of the $(n+1,k)$-VSS scheme to compute the functionality $\VSS_\Share$. At the end of the execution, $P_i$ ($i\in [n]$) obtains the $i$-th $\VSS$ share of $m$ as the output, and $P_{n+1}$ does not receive any output. The $\Set{\msf{v}_i}_{i \in [n]}$ corresponds to the views of $\Set{P_i}_{i \in [n]}$ from this execution (emulated in $C$'s head).
%  \end{remark} 



{\bf Proof Stage:} Both parties learn an efficiently computable predicate $\phi(\cdot)$. 
\begin{enumerate}
   
    \item 
    $C$ then prepares $n$ views $\Set{\msf{v'}_i}_{i \in [n]}$ corresponding to an $(n, k)$-MitH execution for the functionality $F_\phi$ described below, where party $P_i$ uses $\msf{v}_i$ as input. It then commits to each of these views $\msf{v'}_i$ independently in parallel using Naor's commitment. 
    \begin{itemize}
        \item {\bf Functionality $F_\phi$:} This collects inputs $\msf{v}_i$ from party $i$, runs $\VSS_\Recon$ on these inputs to recover a value $x$, and outputs $\phi(x)$. 
    \end{itemize} 

    \item \label[Step]{protocol:BB-ZK:R-challenge}
    $R$ then samples a size-$k$ random subset $\eta \subset [n]$ and sends it to $C$.
    
    \item 
    $C$ now decommits to the views $\Set{\msf{v}_i}_{i \in \eta}$ and $\Set{\msf{v'}_i}_{i \in \eta}$. 
    \item 
    Finally, $R$ checks these decommitments, and also checks if these revealed views are {\em consistent} w.r.t.\ the VSS and MPC executions, here by `consistent' we refer to the consistency requirements as per \Cref{def:view-consistency} and \Cref{rmk:VSS:view-consistency}. It also checks for each $i\in \eta$ the final output of $P_i$ contained in $\msf{v}'_i$ is 1. It aborts immediately if any of the checks fail.
\end{enumerate}
\end{ProtocolBox}
We know state the properties \Cref{protocol:BB-ZK} satisfies as \Cref{protocol:BB-ZK:property}.

\begin{lemma}[\cite{STOC:IKOS07,C:CCLY22}.]\label{protocol:BB-ZK:property}
\Cref{protocol:BB-ZK} satisfies the following properties:
\begin{enumerate}
    \item
    The {\bf Commit Stage} is a statistically binding commitment.
\item
If the $x$ committed in the {\bf Commit Stage} satisfies $\phi(x) = 1$, then $R$ accepts with probability 1.
\item
If the  $x$ committed in the {\bf Commit Stage} satisfies $\phi(x) = 0$, then $R$ rejects except for with probability $O(2^k)$, even if $C^*$ is a malicious QPT machine and $\phi$ is picked by $C^*$.
\end{enumerate}
\end{lemma}

\para{Extension of \Cref{protocol:BB-ZK}.} We remark that \cite{STOC:IKOS07,C:CCLY22} indeed proved that \Cref{protocol:BB-ZK} can be converted into a $\epsilon$-simulatable zero-knowledge protocol if \Cref{protocol:BB-ZK:R-challenge} is replaced with a coin-flipping protocol that is $\epsilon$-simultable against any QPT $R^*$. Such a coin-flipping protocol can be constructed as follows: (1) $R^*$ to commit to a share $\eta_R$ using a extractable commitment with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:strong}); (2) $C$ sends a random share $\eta_C$; (3) $R$ decommits to $\eta_R$. The coin-flipping result will be $\eta \coloneqq \eta_C \xor \eta_R$.

\subsection{Watrous' Rewinding Lemma} \takashi{I guess this is only used in the construction of equivocal commitments. We may move it to a later section.}
The following is Watrous' rewinding lemma \cite{SIAM:Watrous09} in the form of  \cite[Lemma 2.1]{STOC:BitShm20}. 
\begin{lemma}[Watrous' Rewinding Lemma \cite{SIAM:Watrous09}]\label{lem:Watrous}
There is a quantum algorithm $\sfR$ that gets as input the following:
\begin{itemize}
\item A quantum circuit $\sfQ$ that takes $n$-input qubits in register $\reginp$ and outputs a classical bit $b$ and an $m$-qubit output.  
\item An $n$-qubit state $\rho$ in register $\reginp$.
\item A number $T\in \mathbb{N}$ in unary.
\end{itemize}

$\sfR(1^T,\sfQ,\rho)$ executes in time $T\cdot|\sfQ|$  and outputs a distribution over $m$-qubit states  $D_{\rho}\defeq \sfR(1^T,\sfQ,\rho)$  with the following guarantees.

For an $n$-qubit state $\rho$, denote by $\sfQ_{\rho}^0$ the conditional distribution of the output distribution $\sfQ(\rho)$,
conditioned on $b = 0$, and denote by $p(\rho)$ the probability that $b = 0$. If there exist $p_0, q \in (0,1)$, $\gamma \in (0,\frac{1}{2})$
such that:
\begin{itemize}
    \item  Amplification executes for enough time: $T\geq \frac{\log (1/\gamma)}{4p_0(1-p_0)}$,
    \item  There is some minimal probability that $b = 0$: For every $n$-qubit state $\rho$, $p_0\leq p(\rho)$,
    \item  $p(\rho)$ is input-independent, up to $\gamma$ distance: For every $n$-qubit state $\rho$, $|p(\rho)-q|<\gamma$, and
    \item  $q$ is closer to $\frac{1}{2}$: $p_0(1-p_0)\leq q(1-q)$,
\end{itemize}
then for every $n$-qubit state $\rho$,
\begin{align*}
    \TD(\sfQ_{\rho}^0,D_{\rho})\leq 4\sqrt{\gamma}\frac{\log(1/\gamma)}{p_0(1-p_0)}.
\end{align*}

Moreover, $\sfR(1^T,\sfQ,\rho)$ only makes black-box use of $\sfQ(\rho)$.\footnote{The black-boxness is observed in \cite{C:ChiChuYam21,C:CCLY22}} 
\end{lemma} 
