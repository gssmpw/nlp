%!TEX root = ../main.tex

\section{Post-Quantum Non-Malleable Commitments: One-Many}
\label{sec:BB-NMCom:one-many}




In this section, we turn to the construction of a black-box commitment scheme that satisfies the weak {\em one-many} definition of post-quantum non-malleability (as described in \Cref{def:NMCom:weak:pq}). The construction for this setting is identical to \Cref{protocol:BB-NMCom} (more accurately, its `two-sided' version described in \Cref{sec:two-sided:main-body} and \Cref{protocol:BB-NMCom:two-sided}) given in \Cref{sec:BB-NMC:construction}, and thus uses the same component primitives. In effect, we show that the security of \Cref{protocol:BB-NMCom} extends to the one-many case as well. This is stated formally below. 
\begin{theorem}\label{thm:pqmnc:1-many}
For any polynomial $N(\secpar)$ in the security parameter, \Cref{protocol:BB-NMCom:two-sided} is a black-box, constant-round construction of a 1-$N$ post-quantum weakly non-malleable commitment (as per \Cref{def:NMCom:weak:pq}) in the synchronous setting, supporting tag space $[T]$ with $T(\secpar)$ being any polynomial in $\secpar$.
\end{theorem}

Note that in \Cref{thm:pqmnc:1-many}, we have referred to the number of right sessions in the non-malleability game by $N$, while this parameter was denoted by $k$ in \Cref{protocol:BB-NMCom}. We rename this for clarity, since $k$ is already used to denote an important quantity in our construction.

To prove \Cref{thm:pqmnc:1-many}, note that completeness and hiding can be argued similar as for \Cref{protocol:BB-NMCom}. We focus on showing 1-many non-malleability in the following. 





\subsection{Proof Overview}

Technically, we need to prove weak 1-many non-malleability for \Cref{protocol:BB-NMCom:two-sided}. But to simplify the presentation, we only  focus on the `one-sided' version of it (i.e., \Cref{protocol:BB-NMCom}) in the following. This is because we can use the same `two-slots' trick as explained in \Cref{sec:two-sided:main-body} to lift the proof to the `two-sided' setting as well.

While the setting is now different for the 1-many case, and our formalism for handling this case has to change to account for this, we wish to emphasize that our {\em core strategy} and indeed our intuition for this proof remains essentially the same! Intuitively, the fundamental idea behind our proof is to design experiments that allow us to reduce non-malleability to the {\em hiding} property of the initial commitment on the left. Now while the 1-many setting involves multiple parallel right sessions, there is only a single session on the left, and so our proof strategy and technique remains largely unchanged---At a high level, we seek to extract a `trapdoor' from \Cref{bbnmc:hard-puzzle:rv-2} of the left session to then decouple the main body of the left session from the commitment made in the prefix phase (i.e., \Cref{bbnmc:init-com}), and subsequently we extract the value from the \Cref{prot:bbnmc:extcom} $\ExtCom$ of the right session and show that this must be the committed value $\tilde{m}$ in the right session with sufficiently high probability. 

This helps us better understand what remains unchanged (in the 1-many case) from our earlier proof for \Cref{protocol:BB-NMCom}, and what needs new treatment. The key thing that changes here is the extraction step, which is now more involved. Note that to establish 1-many non-malleability, we must obtain the tuple of values committed by $\mcal{M}$ {\em across} all the $N$ right sessions (and show this must not depend on the left session commitment). So in our proof, we must extract the right side committed value as before, but now we must do so {\em simultaneously} from all the parallel sessions with sufficiently high probability. It is not clear that our technique so far extends directly to this case; indeed, this extension to the {\em simultaeneous extraction} case turns out to be nontrivial and will be our focus here. 

More technically, we will arrange our task as follows:
\begin{itemize}
\item First, we describe how to capture the reduction from non-malleability to the VSS hiding game \Cref{chall:vss:hide} by modifying the MIM experiment. This is essentially identical to what is presented in \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding,bbnmc:proof:fin}. We will sketch the argument while mostly focusing on the syntactic differences arising from the 1-many setting. 
\item 
We state the key lemma formalizing the existence of the simulator-extractor (i.e., the analog of $\SimExt$ from \Cref{bbnmc:proof:fin}) in the 1-many setting. This is used to complete the proof of non-malleability. 
\item 
We then show how to build an {\em instanced} version of the simulation-less extractor $\mcal{K}$ from \Cref{pq:lem:small-tag:proof:se:proof:K}: {\em  For each session $j \in [N]$ on the right}, we design an extractor $\mcal{K}^{(j)}$ that works essentially the same way as $\mcal{K}$ in the 1-1 setting (i.e., in \Cref{pq:lem:small-tag:proof:se:proof:K}). 
\item 
Finally, we show how to get a full-fledged simulation-extractor from these $\mcal{K}^{(j)}$'s using our simultaneous extraction lemma given in \Cref{lem:Simultaneous-SimExt}. 
\end{itemize}  

\subsection{Reduction to VSS Hiding Game} 

We start by describing the analogs of the key experiments introduced in \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding}. We begin by defining the real man-in-the-middle experiment. 

\para{Game $H^{\mcal{M}_\secpar}(\secpar,m,N,\rho_\secpar)$:\label{pq:gameH:1-many:description}} Analogous to \Cref{pq:gameH:description}, this is just the real MIM interaction, now in the 1-$N$ setting. The game now takes the number of parallel right sessions $N$ as input. We continue to denote the left committer by $C$. But for clarity, we now refer to the various receivers on the right by $R^{(1)},\dots,R^{(N)}$ respectively. Recall that in the 1-$N$ man-in-the-middle experiment, these receivers function honestly and independently. 


The output of this game is again denoted by $\Output_{H^{\mcal{M}_\secpar}}(\secpar, m, \rho_\secpar)$ and consists of the following parts:
\begin{enumerate}
\item
$\OUT$: The (quantum) output of $\mcal{M}$ at the end of this game;
\item For each $j \in [N]$, 
$\tilde{\tau}^{(j)}$: The commitment transcript sent by $\mcal{M}$ to $R^{(j)}$ in the \Cref{bbnmc:init-com} of the $j$-th right session; 
\item Also for each $j \in [N]$, 
$\tilde{d}^{(j)} \in \Set{\top, \bot}$: The output of the honest receiver $R^{(j)}$ in the $j$-th right session, indicating if $\mcal{M}_\secpar$'s commitment in the $j$-th right session is accepted ($\tilde{d}^{(j)} = \top$) or not ($\tilde{d}^{(j)} = \bot$).
\end{enumerate} 

%\xiao{we can remove the bar abot the mim symbol}

We will also need to refer to the value committed in the right sessions. Toward that, we define the function $\Gamma_{\{\tilde{d}^{(j)}\}_{j=1}^{k}}(\cdot)$ in exactly the style given in \Cref{def:NMCom:weak:pq}.

%$$
%\forall j \in [N],~\msf{val}^{(j)}_{\tilde{d}}(\tilde{\tau}) \coloneqq 
%\begin{cases}
%\msf{val}(\tilde{\tau}^{(j)}) & \tilde{d}^{(j)} = \top\\
%\bot & \tilde{d}^{(j)} = \bot
%\end{cases},
%$$

%where $\msf{val}(\tilde{\tau}^{(j)})$ denote the value statistically-bound $\tilde{\tau}^{(j)}$ (i.e., the value that can be reconstructed from $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$ in the $j$-th right session). 

Specifically, let $\msf{val}^{(j)}(\tilde{\tau}) = \msf{val}^{(j)}(\tilde{\tau}^{(j)})$ denote the value committed in the $j$-th right session by $\mcal{M}$ (note that this is well defined by the statistical binding property). 

Thus, to prove 1-$N$ non-malleability as per \Cref{def:NMCom:weak:pq}, we need only establish the following:
\begin{align*}
&\big\{\Gamma_{\{\tilde{d}_0^{(j)}\}_{j=1}^{N}}\big(\OUT_0, \Set{\msf{val}^{(j)}(\tilde{\tau_0}^{(j)})}_{j \in [N]}\big): (\OUT_0, \Set{\tilde{\tau}^{(j)}_0, \tilde{d}^{(j)}_0}_{j \in [N]}) \gets H^{\mcal{M}_\secpar}(\secpar,m_0, N, \rho_\secpar) \big\} \\
\cind ~& 
\big\{\Gamma_{\{\tilde{d}_1^{(j)}\}_{j=1}^{N}}\big(\OUT_1, \Set{\msf{val}^{(j)}(\tilde{\tau}_1^{(j)})}_{j \in [N]}\big): (\OUT_1, \Set{\tilde{\tau}^{(j)}_1, \tilde{d}^{(j)}_1}_{j \in [N]}) \gets H^{\mcal{M}_\secpar}(\secpar, m_1, N, \rho_\secpar) \big\} \numberthis \label{pq:eq:classical:1-many:H:m-0:m-1},
\end{align*}
where both ensembles are indexed by $\secpar \in \Naturals$ and $(m_0, m_1) \in \bits^{\ell(\secpar)} \times \bits^{\ell(\secpar)}$.

We next turn to defining the machine $\tilde{H}^{\mcal{M}_\secpar}$ in the 1-$N$ setting, which is the analog of \Cref{pq:game:Htil} in \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding}.

\begin{AlgorithmBox}[label={pq:game:Htil:1-many}]{Game \textnormal{$\tilde{H}^{\mcal{M}_\secpar}(\secpar, \epsilon,m,N,\rho_\secpar)$} in $1$-$N$ Setting}


{\bf Input:} This takes as input the same parameters $\secpar$, $\rho_\secpar$, $m$, and $N$ as for $H^{\mcal{M}_\secpar}$. It additionally takes as input a noticeable function $\epsilon(\cdot)$. 

It proceeds as follows:
\begin{enumerate}
    \item \label[Step]{pq:game:Htil:1-many:pref}
    {\bf (Prefix phase.)} 
    This proceeds as follows. 
    \begin{enumerate}
        \item \label[Step]{pq:game:Htil:1-many:pref:1}
        Sample a random size-$k$ subset $\eta \subset [n]$.
        \item \label[Step]{pq:game:Htil:1-many:pref:2}
       	Execute $H^{\mcal{M}_\secpar}(m,N,\secpar,\rho_\secpar)$ until the end of \Cref{bbnmc:init-com}. At the moment, it already receives the \Cref{bbnmc:init-com} commitment made by the left-session honest committer $C$. It performs brute-force computation to obtain from $C$'s commitment the committed shares $\msf{cv}_i$ and their decommitment information for $i \in \eta$. We denote these values as $\msf{VI}_\eta \coloneqq \Set{(\msf{cv}_i, \msf{decom}_i}_{i \in \eta}$. 
    \end{enumerate}
    \subpara{Notation:}  Let $\msf{st}_{\mcal{M}}$ denote the state of $\mcal{M}$ at the end of \Cref{bbnmc:init-com}; Let $\msf{st}_C$  (and \ $\Set{\msf{st}_R^{(j)}}_{j \in [N]}$) denote the state of the honest committer (and\ receivers) at the end of \Cref{bbnmc:init-com}; 
    Let $\Set{\tilde{\tau}^{(j)}}_{j \in [N]}$ denote the commitments sent by $\mcal{M}$ in \Cref{bbnmc:init-com} in all the $N$ right sessions. We denote the tuple $(\msf{st}_{\mcal{M}}, \Set{\msf{st}_R^{(j)}}_{j \in [N]}, \tau,\Set{\tilde{\tau}^{(j)}}_{j \in [N]})$ as $\msf{pref}^{1:N}$. We use the following nation to express the execution of this {\bf Prefix phase}:
    \begin{equation}
    \msf{pref'}^{1:N}\coloneqq(\msf{pref}^{1:N}, \eta, \msf{VI}_\eta) \la \tilde{H}_{\msf{pref}}^{\mcal{M}_\secpar}(\secpar,m,N, \rho_\secpar). 
    \end{equation}
    We remark that this prefix generation step is independent of the error parameter $\epsilon$.
  
    \item \label[Step]{pq:game:Htil:body} 
    {\bf (Remainder phase.)} This involves the following steps: 
    \begin{enumerate}
        \item 
        $\tilde{H}^{\mcal{M}_\secpar}$ invokes the $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta))$ defined in \Cref{pq:machine:g1:1-many} (where $\msf{pref}^{1:N}$ is now as defined above in the 1-$N$ setting), which now outputs a tuple $(\OUT, \Set{\tilde{d}^{(j)}}_{j \in [N]})$. 
        \item 
        $\tilde{H}^{\mcal{M}_\secpar}$ outputs $(\OUT, \Set{\tilde{\tau}^{(j)}}_{j \in [N]},\Set{\tilde{d}^{(j)}}_{j \in [N]})$. %We denote this by $\Output_{H^{\mcal{M}_\secpar}}(\secpar, m, \rho_\secpar)$. 
    \end{enumerate}
\end{enumerate}
\end{AlgorithmBox}

%Copy desc G1. 

We now describe the subprocedure $\mcal{G}_1(\cdot)$ adapted to the 1-$N$ setting, which is the analog of \Cref{pq:machine:g1} in \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding}. 

% \begin{AlgorithmBox}[label={pq:machine:g1:1-many}]{Machine \textnormal{$\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta)$} in $1$-$N$ Setting}
% Machine $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta)$ continues the execution using $\msf{pref}^{1:N}$ just as in $H^{\mcal{M}_\secpar}(\secpar, m, N, \rho_\secpar)$, apart from the following differences:
% \begin{enumerate}
%     \item  \label[Step]{machine:G1:step:2}
%     In the left \Cref{bbnmc:hard-puzzle:rv-2} against $\mcal{M}_\secpar$, instead of following the honest receiver algorithm for $\ExtCom$, it instead uses the extractor $\SimExt_\ExtCom^{\mcal{M}_\secpar}(1^\secpar,1^{\epsilon^{-1}})$ to obtain an extracted value of the form $j'||x'_{j'}$ (and continuing the execution with the simulated state). 

%     In more detail, the shares $\Set{\msf{rv}^{(2)}_i}_{i \in [n]}$ are committed by $\mcal{M}_\secpar$ using independent $\ExtCom$ in parallel. $\mcal{G}_1$ will extract all of these shares using the parallel extractability of $\ExtCom$ with $\epsilon$-simulation (as per \Cref{def:epsilon-sim-ext-com:parallel}), and compute $j'||x'_{j'} \coloneqq \VSS_{\Recon}(\msf{rv}^{(2)}_1, \ldots, \msf{rv}^{(2)}_n)$.

%     \item \label[Step]{machine:G1:step:2}
%     In the $\ExtCom$ execution for \Cref{prot:bbnmc:extcom} on the left, it commits to the extracted value $j'\|x'_{j'}$.

%     In more detail, $\mcal{G}_1$ first prepares $n$ views $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, corresponding to an MitH execution for the $(n+1, 2k)$-$\VSS_\Share$ of the value $j'\|x'_{j'}$ extracted in \Cref{machine:G1:step:2}, and then commits to each $\msf{cv}^{(2)}_i$ ($i \in [n]$) independently in parallel, using $\ExtCom$.

%     \item \label[Step]{machine:G1:step:3}
%     In \Cref{prot:bbnmc:puzzle-sol-reveal} of the left session, after reconstructing the receiver's puzzle solutions $x_1\|\dots\|x_t$, it checks whether $x_{j'} = x'_{j'}$, i.e., the value that it extracted earlier. If not, it aborts the execution and outputs $\bot$. 
    
%     \item \label[Step]{machine:G1:step:3}
%      In \Cref{prot:bbnmc:C-consis-com} of the left session, instead of generating the views $\Set{\msf{cv}^{(3)}_i}_{i\in [n]}$ using the `first clause' of $F^C_{\msf{consist}}$, generate these views using the `second clause'. We remark that this is possible because in \Cref{machine:G1:step:2} above, we already commit to the extracted $j'\|x'_{j'}$, which satisfies the `second clause' of $F^C_{\msf{consist}}$. 

%      Recall that each $\msf{cv}^{(3)}_i$ has $\msf{cv}^{(1)}_i$ as a prefix. However, $\mcal{G}_1$ only knows the $\msf{cv}^{(1)}_i$ for $i \in \eta$. For that, $\mcal{G}_1$ simply set $\msf{cv}^{(1)}_i$ for $i \in [n] \setminus \eta$ to all-$0$ strings. This does not affect this step as $\mcal{G}_1$ now is proving the `second clause' of $F^C_{\msf{consist}}$, which is independent of the value determined by the real $\Set{\msf{cv}^{(1)}_i}_{i \in [n]}$. (Also note that this problem does not occur for $\Set{\msf{cv}^{(2)}_i}_{i \in [n]}$, which is generated by $\mcal{G}_1$ itself in \Cref{machine:G1:step:2}.)

%     \item \label[Step]{machine:G1:step:4}
%     In \Cref{prot:bbnmc:cointoss} of the left session, instead of executing the trapdoor coin-flipping protocol honestly, use the `straight-line' simulator $\Sim(\ST_C, \eta, j'\|x'_{j'}, \phi)$ that is guaranteed to exist by \Cref{def:com-n-prove:property:3} in \Cref{def:com-n-prove} (where $\ST_C$ is the classical state of the committer at the end of \Cref{prot:bbnmc:extcom}, emulated by $\mcal{G}_1$). Note that this is possible because we current have $\phi(j'\|x'_{j'}) = 1$. This effectively `enforce' the coin-flipping result to the $\eta$ contained in the input to $\Sim$.
    
%     \item 
%     It concludes the execution by performing the remaining steps as in $H^{\mcal{M}_\secpar}(\secpar, m, \rho_\secpar)$. One caveat is: In \Cref{prot:bbnmc:mpc:reveal} of the left session, $\mcal{G}_1$ will be asked to decommitment to $\Set{\msf{cv}^{(1)}_i}_{i \in [n]\setminus \eta}$. Note that the $\eta$ is already `enforced' to the $\eta$ in \Cref{machine:G1:step:4}, and $\mcal{G}_1$ does know the $\msf{cv}^{(i)}_i$ shares and decommitment information for $i \in \eta$ (contained in $\msf{VI}_\eta$).


%     \item It finally outputs the values $(\OUT, \Set{\tilde{d}^{(j)}}_{j \in [N]})$, where again $\OUT$ is $\mcal{M}$'s final output and $\Set{\tilde{d}^{(j)}}_{j \in [N]}$ are the  final decisions by the honest $R^{(j)}$s in the $N$ right session.
% \end{enumerate}

% \end{AlgorithmBox}

\begin{AlgorithmBox}[label={pq:machine:g1:1-many}]{Machine \textnormal{$\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta)$} in $1$-$N$ Setting}
Machine $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta)$ works in the same manner as the $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta)$ defined in \Cref{pq:machine:g1} but in the 1-$N$ setting. This is even no need to give a full description of the current $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta)$, because it has literally identical {\em syntax} as the $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta)$ defined in \Cref{pq:machine:g1}---All the $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}, \eta, \msf{VI}_\eta)$ does is to make some modifications on the left session; Here in the 1-$N$ setting, we also has only a single left session. So, what our current $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta)$ does is to do the same thing on the left session as \Cref{pq:machine:g1} and follow the honest receivers' algorithm on the right sessions.

The only point that deserves a remark is the format of the output of the current $\mcal{G}_1$ in the 1-$N$ setting, which we describe as follows:
\begin{itemize}

    \item It finally outputs the values $(\OUT, \Set{\tilde{d}^{(j)}}_{j \in [N]})$, where again $\OUT$ is $\mcal{M}$'s final output and $\Set{\tilde{d}^{(j)}}_{j \in [N]}$ are the  final decisions by the honest $R^{(j)}$s in the $N$ right session.
\end{itemize}
\end{AlgorithmBox}

% As indicated, we modify $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}})$ in the 1-many setting to now take in the prefix $\msf{pref'}^{1:N}$ and output the decision bits $\tilde{d}^{(j)}$ for {\em all} the right sessions $j \in [N]$. This can be seen as a {\em generalization} of the machine described \Cref{pq:machine:g1} in the proof of 1-1 non-malleability. Note that the actual function of $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}$ is unchanged from what is described in \Cref{pq:machine:g1}, since the changes made by $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}$ as compared to the MIM interaction are all made with respect to the left side committer. Since the right interaction remains unchanged, we are able describe the actions of $\mcal{G}_1(1^\secpar, 1^{\epsilon^{-1}}$ the same way as in the 1-1 setting. The right side receivers $R^{(j)}$ all simply act honestly as before. 

%Change k to N - Done
%Change notation for pref? pref_{1:N}? Done 
%Change notation for H slightly to now accept N? Done 
%Mark receivers as separate and independent. Add notation. Done 
%Copy description of G1 Done 
%Remark about how K^is make sense. 

As in  \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding}, one can again show that the outputs of $H$ and $\tilde{H}$ defined above are computationally indistinguishable (i.e., an analog of \Cref{lem:Htil:similarity}). We next turn our attention to the machine $\tilde{G}$ in the 1-$N$ setting that makes use of our {\em simultaeneous} simulator-extractor. This machine is the analog of \Cref{pq:game:Gtil} in  \Cref{sec:pq-nmc:1-1:proof:reduction-to-hiding}.

\begin{AlgorithmBox}[label={pq:game:Gtil:1-many}]{Game \textnormal{$\tilde{G}^{\mcal{M}_\secpar}(\secpar, m, N,\rho_\secpar,\epsilon)$}}
This proceeds in two phases as well: 
\begin{enumerate}
    % \item
    % It first computes $\epsilon' = \msf{p}(\epsilon)$, where $\msf{p}(\cdot)$ is an efficiently computatable polynomial that is guaranteed to exist by the following \Cref{lem:simext:closeness}.

    \item \label[Step]{pq:game:Gtil:1-many:pref}
    {\bf (Prefix phase.)} This is identical to {the prefix phase of \Cref{pq:game:Htil}, i.e., it computes $(\msf{pref}^{1:N}, \eta, \msf{VI}_\eta) \la \tilde{H}_{\msf{pref}}^{\mcal{M}_\secpar}(\secpar, m, N,\rho_\secpar)$.}

    
    \item {\bf Remainder phase:}\label[Step]{pq:game:Gtil:1-many:body} This involves the following steps: 
    \begin{itemize} 
        \item It invokes a machine $\SimExt$, which is guaranteed to exist by the following \Cref{lem:simext:closeness:1-many}: $\SimExt$ takes in as input a tuple $(1^\secpar, 1^{\epsilon^{-1}}, \msf{pref}^{1:N}, \eta, \msf{VI}_\eta)$ and outputs $(\msf{OUT}, \Set{\msf{Val}^{(j)}}_{j \in [N]})$. 
        \item  $\tilde{G}^{\mcal{M}_\secpar}$ outputs $(\msf{OUT},\Set{\msf{Val}^{(j)}}_{j \in [N]})$ as its own output.
    \end{itemize}
\end{enumerate}
\end{AlgorithmBox}

% This is identical to the description in \Cref{pq:game:Gtil}, apart from the fact that we use the generalized notion of the prefix $\msf{pref}_{1:N}$ for the 1-many setting. 

With this, we can turn to the main lemma: comparing executions of $\tilde{H}$ and $\tilde{G}$. Note that in the latter game we also obtain the committed values in the right sessions. Then \Cref{lem:simext:closeness:1-many} that is analogous to \Cref{lem:simext:closeness} shows that these executions yield outputs that are close up to a controllable error parameter: 

%Give lemma 5 analog. 
\begin{lemma}[1-many Simulation-Extractor]\label{lem:simext:closeness:1-many}
    Let $\mcal{G}_1(\cdot)$ be the efficient procedure defined in \Cref{pq:machine:g1:1-many}. For any polynomial $N(\secpar)$ in the security parameter $\secpar$, there exists a simulation-extractor $\SimExt$ such that for any $(\msf{pref}^{1:N},\eta,\msf{VI}_\eta)$ in the support of $\tilde{H}^{\mcal{M}_\secpar}_\msf{pref}$, and for any noticeable $\epsilon(\secpar)$, there is a noticeable $\epsilon'(\secpar) \le 8\epsilon(\secpar)$ that is efficiently computable from $\epsilon(\secpar)$ such that the following holds:
    \begin{align*}
        &
        \big\{(\msf{OUT}, \Set{\msf{Val}^{(j)}}_{j \in [N]}): (\msf{OUT}, \Set{\msf{Val}^{(j)}}_{j \in [N]}) \gets \SimExt(1^\secpar, 1^{\epsilon^{-1}},\msf{pref}^{1:N},\eta,\msf{VI}_\eta) \big\}
        \\
        \cind_{\epsilon} 
        ~&
        \big\{\Gamma_{\{\tilde{d}^{(j)}\}_{j=1}^{N}}\big(\OUT, \Set{\msf{val}^{(j)}_{\tilde{d}}(\tilde{\tau})}_{j \in [N]}\big): (\OUT, \Set{\tilde{d}^{(j)}}_{j \in [N]}) \gets \mcal{G}_1(1^\secpar, 1^{\epsilon'^{-1}}, \msf{pref}^{1:N},\eta,\msf{VI}_\eta) \big\}.
    \end{align*}
\end{lemma} 

The remainder of the proof to non-malleability can be shown just as in the earlier setting (via the reduction to the VSS hiding game as done in \Cref{bbnmc:proof:fin}). We omit the details to avoid repetition. Instead, we will focus on the key task of {\em building this simulator-extractor $\SimExt$}. Our approach will be the same as before---Namely, for each right session $j \in [N]$, we will first describe a base extractor $\mcal{K}^{(j)}$ that is essentially the extractor $\mcal{K}$ from \Cref{pq:lem:small-tag:proof:se:proof:K} but localized to session $j$, and then show (in \Cref{sec:sim-ext:1-many:final}) how to use these `localized' versions of $\mcal{K}$ to obtain the 1-$N$ simulation-extractor $\mcal{SE}$ as required by \Cref{lem:simext:closeness:1-many}.


\subsection{Localized Simulation-Less Extractors $\mcal{K}^{(j)}$}



Recall that we defined the shorthand $\msf{pref'}^{1:N} \coloneqq (\msf{pref}^{1:N},\eta,\msf{VI}_{\eta})$. Also, we define the following quantity $p^{\msf{Sim}}_{\msf{pref'}^{1:N}}[\epsilon_1]$ that will be important in the formal statement of $\mcal{K}^{(j)}$s. It is the 1-$N$ analog of the quantity $p^{\msf{Sim}}_{\msf{pref}'}[\epsilon_1]$ defined in \Cref{eq:def:p-pref}. 
\begin{equation}\label{eq:def:p-pref:1-many}
p^{\msf{Sim}}_{\msf{pref'}^{1:N}}[\epsilon_1] \coloneqq \Pr[\wedge_{j \in [N]} \big(\tilde{d}^{(j)} = \top \big) : (\OUT,\Set{\tilde{d}^{(j)}}_{j \in [N]}) \gets \mcal{G}_1(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}'^{1:N})].
\end{equation}
% where $\epsilon_1$ is the error parameter for $\SimExt_\ExtCom$ used in $\mcal{G}_1$ (defined in \Cref{pq:machine:g1}), and is taken to be a noticeable function of $\secpar$. 






The following lemma states the formal guarantee provided by these localized base extractors $\mcal{K}^{(j)}$. It is the 1-$N$ analog of \cref{pq:lem:small-tag:proof:se:proof:K}.  

\begin{lemma}[Localized Simulation-less Extraction]\label{pq:lem:small-tag:proof:se:proof:K:1-many}
For any polynomial $N(\secpar)$, let $\tilde{H}^{\mcal{M}_\secpar}_{\msf{pref}}(\secpar, m, N, \rho_\secpar)$ be as defined in \Cref{pq:game:Htil:1-many}. There exist QPT machines $\Set{\mcal{K}^{(j)}}_{j \in [N]}$ such that for any noticeable $\epsilon(\secpar)$, there is a noticeable $\epsilon_1(\secpar) \le \epsilon(\secpar)$ that can be efficiently computed from $\epsilon$, such that for any noticeable $\epsilon_2(\secpar)$ and any tuple $\msf{pref'}^{1:N} = (\msf{st}_{\mcal{M}}, \Set{\msf{st}_{R^{(j)}}}_{j \in [N]}, \tau,\Set{\tilde{\tau}^{(j)}}_{j \in [N]},\eta,\msf{VI}_{\eta})$ in the support of $\tilde{H}^{\mcal{M}_\secpar}_{\msf{pref}}(\secpar, m, N, \rho_\secpar)$, the following conditions hold:
\begin{enumerate}
\item \label[Property]{pq:property:small-tag:proof:se:proof:K:syntax:1-many}
{\bf (Almost Uniqueness:)} For each $j \in [N]$, $\mcal{K}^{(j)}$ takes as input $(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})$. It outputs a value $\msf{Val}^{(j)} \in \bits^{\ell(\secpar)} \cup \Set{\bot}$ that satisfies
$$\Pr[\msf{Val}^{(j)} \notin \Set{\msf{val}(\tilde{\tau}^{(j)}) , \bot} ~:~\msf{Val}^{(j)} \ra \mcal{K}^{(j)}{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})}] \leq {\epsilon_2(\secpar) + \negl(\secpar)}.$$
 % where $\zeta(\secpar)$ is as above. 
%Change to the more generalized output property that referes to zeta. Match with Xiao's sim-ext lemma. 

\item \label[Property]{pq:property:small-tag:proof:se:proof:K:1-many}
{\bf (Extraction:)} If $p^{\msf{Sim}}_{\msf{pref'}^{1:N}}[\epsilon_1] \ge \epsilon(\secpar)$, then for each $j \in [N]$ it holds that
$$\Pr[\Val^{(j)} = \msf{val}(\tilde{\tau}^{(j)}) : \Val^{(j)} \gets \mcal{K}^{(j)}{(1^\secpar, 1^{\epsilon_1^{-1}},1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})}] \ge {\frac{\epsilon'(\secpar)-\epsilon_2(\secpar)}{\tilde{t}}},$$
where $p^{\msf{Sim}}_{\msf{pref}'^{1:N}}[\epsilon_1]$ is defined in \Cref{eq:def:p-pref:1-many} and  $\epsilon'(\secpar) \coloneqq \frac{\epsilon(\secpar)}{10t^2}$. 
\end{enumerate}
\end{lemma}


%Things to say: 
%1: This looks to be complicated. Many more things going on compared to the 1-1 case. 
%2: But on closer analysis, it follows fairly simple from the old lemma. The trick to this is to see that since the receivers in the right sessions operate independently, and act honestly unless we extract in that session, we can simply treat them as standard interactions of the commitment. 
%3: In particular, when invoking this extractor on a particular session, we can treat the other right sessions as context: in particular, given the 1-many MIM, we can come up with a new MIM M' that runs the other parallel sessions internally with M and then treats the jth session as the sole right session in a 1-1 MIM interaction. We can then apply the original [Lemma] to derive these guarantees for K^j. Armed with this reasoning, we can see that the above readily follows. 
%Sentence about params. Same ones work. 

This statement of the simulation-less extractor(s) in the one-many setting looks quite different from the one appearing in \Cref{pq:lem:small-tag:proof:se:proof:K}, and at first glance, seems to be significant extension of the latter. At the very least, there are more moving parts with the multiple parallel sessions on the right. Further consideration however reveals that this is not quite the case. The trick to this is to see that since the receivers $R^{(1)},\dots R^{(N)}$ in the right sessions operate {\em independently}, and act honestly (unless we extract in that session), we can simply treat them as standard interactions of the commitment. 

In particular, when invoking this extractor on a particular session $j \in [N]$, we can treat the other right sessions as {\em context}: in more detail, given the 1-many man-in-the-middle adversary $\mcal{M}$, we can come up with a new adversary $\mcal{M}^{(j)}$ that runs the other parallel sessions internally in a one-many MIM interaction with $\mcal{M}$ and then treats the $j$-th session as the {\em sole} right session in a one-one MIM interaction. We can then apply \Cref{pq:lem:small-tag:proof:se:proof:K} to derive these guarantees for $K^{(j)}$ (where the MIM adversary is $\mcal{M}^{(j)}$). Armed with this reasoning, we can see that \Cref{pq:lem:small-tag:proof:se:proof:K:1-many} readily follows from \Cref{pq:lem:small-tag:proof:se:proof:K}. 

This also allows us to set parameters the same way as in \Cref{pq:lem:small-tag:proof:se:proof:K}. Namely, we work by first fixing a noticeable $\epsilon(\cdot)$ and then set $\epsilon_1(\secpar)\defeq \frac{t+1}{t^2+4t+2}\cdot \epsilon'(\secpar)$ with $ \epsilon'(\secpar) \coloneqq \frac{\epsilon(\secpar)}{10t^2}$. 



% For the sake of completeness, we present below a full description of machines $\mcal{K}^{(j)}$. As mentioned, these will essentially work the same way as the extractor $\mcal{K}$ for the 1-1 setting. The only things that change are the semantics to reflect that we are in the one-many setting. 

% We first introduce some preliminary machines (as in the one-one case), starting with machines $\mcal{G}_i^{(j)}$, which is the 1-$N$ analog of \xiao{ref}.

% \begin{AlgorithmBox}[label={algo:G:j:i}]{Machine \textnormal{$\mcal{G}^{(j)}_i(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}'^{1:N})$}}
% \para{Machine $\mcal{G}^{(j)}_i(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}'^{1:N})$:} Recall that we defined $\mcal{G}_1$ in \Cref{pq:machine:g1:1-many}. For $j \in [N]$ and $i \in [\tilde{t}^{(j)}]\setminus \Set{1}$, the machine $\mcal{G}^{(j)}_i(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}'^{1:N})$ works identically to $\mcal{G}_1(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}'^{1:N})$, apart from the following changes: 
% \begin{enumerate}
% \item It commits to the value $i||\tilde{x}_i$ instead of the value $1||\tilde{x}_1$ in \Cref{bbnmc:hard-puzzle:rv-2} of the $j$-th right session. In all other right sessions, it acts as an honest receiver (just as in $\mcal{G}_1$). 

% In more detail, $\mcal{G}^{(j)}_i$ in session $j$ first prepares $n$ views $\Set{\msf{rv}^{(2)}_j}_{j \in [n]}$, corresponding to an MitH execution for the $(n+1, k)$-$\VSS_\Share$ of the string $i\|\tilde{x}_i$, and then commits to each $\msf{rv}^{(2)}_j$  independently in parallel, using $\ExtCom$. 

% \item Additionally, in the $j$-th session now the string $i||\tilde{x}_i$ is used as the `effective input' in the (virtual) MPC execution computing $F^R_{\msf{consis}}$ in \Cref{bbnmc:hard-puzzle:rv-3}. (Indeed, this is an implicit change and occurs automatically when the first change is made.) 
% \end{enumerate} 
% \end{AlgorithmBox}

% Here we have denoted the tag value in the $j$-th right session by $\tilde{t}^{(j)}$. Next we define machines $\mcal{K}^{(j)}_i$: 

% \begin{AlgorithmBox}[label={algo:K:i:j}]{Machine \textnormal{$\mcal{K}^{(j)}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})}$}}
% {\bf Machine $\mcal{K}^{(j)}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}')^{1:N}}$:} For each $j \in [N]$ and $i \in [\tilde{t}^{(j)}]$, the machine $\mcal{K}^{(j)}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})}$ works identically to machine $\mcal{G}^{(j)}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}'^{1:N})}$ except that
% \begin{itemize}
% \item
% In \Cref{prot:bbnmc:extcom} of the $j$-th right session, instead of following the honest receiver's algorithm, it invokes $\SimExt_\ExtCom(1^\secpar, 1^{\epsilon_2^{-1}})$ to obtain an extracted value $\tilde{v}$.

%  In more detail, the shares $\Set{\msf{cv}^{(2)}_{j'}}_{j' \in [n]}$ are committed by $\mcal{M}_\secpar$ in \Cref{prot:bbnmc:extcom} of the $j$-th right session using independent $\ExtCom$s in parallel. $\mcal{K}^{(j)}_i$ will extract all of these shares using the parallel extractability of $\ExtCom$ with $\epsilon_2$-simulation (as per \Cref{def:epsilon-sim-ext-com:parallel}), and compute $\tilde{v} \coloneqq \VSS_{\Recon}(\msf{cv}^{(2)}_1, \ldots, \msf{cv}^{(2)}_n)$.
% \end{itemize}

% {\bf Outputs of $\mcal{K}^{(j)}_i$:} To aid in our proof, we define the output of the machines $\mcal{K}^{(j)}_i$ differently from the outputs of the machines described so far. 

% Let $\tilde{v}^{(j)}$ denote the value extracted and recorded by $\mcal{K}^{(j)}_i$ in \Cref{prot:bbnmc:extcom}. As described, $\mcal{K}^{(j)}_i$ will complete the execution of the left and all the right sessions (just as in $\mcal{G}^{(j)}_i$). Recall that we use $\tilde{d}^{(j)}$ to denote the acceptance or rejection of the $j$-th right-session honest receiver $R^{(j)}$(i.e., its verdict). The output of $\mcal{K}^{(j)}_i$ is denoted as $\msf{Val}^{(j)} \in \bits^{\ell(\secpar)} \cup \Set{\bot_{\tilde{Y}}, \bot_{\msf{invalid}}}$ (where $(\bot_{\tilde{Y}}, \bot_{\msf{invalid}})$ are two specialized abort symbols), and is computed as follows: %Need different notation for Ytil? Has no motivation in our case. 
% \begin{enumerate}
% \item \label[Case]{pq:K:j:i:output:case:1}
% If $\tilde{d}^{(j)} = \top$ . Then, there are two sub-cases:
% \begin{enumerate}
% \item \label[Case]{pq:K:j:i:output:case:1a}
% $\tilde{v}^{(j)} \notin \Set{\tilde{x}^{(j)}_i}_{i \in [\tilde{t}^{(j)}]}$ : In this case, we set $\msf{Val} \coloneqq \tilde{v}$. 

% \item \label[Case]{pq:K:j:i:output:case:1b}
% $\tilde{v} \in \Set{\tilde{x}^{(j)}_i}_{i \in [\tilde{t}^{(j)}]}$ : In this case, we set $\msf{Val}^{(j)} \coloneqq \bot_{\tilde{Y}}$.
% \end{enumerate}

% \item \label[Case]{pq:K-i:output:case:2}
% Otherwise, if $\tilde{d} = \bot$, set $\msf{Val} \coloneqq \bot_{\msf{invalid}}$.
% \end{enumerate}
% We emphasize that such a $\msf{Val}$ satisfies the {\em syntactic} requirement in \Cref{pq:property:small-tag:proof:se:proof:K:syntax} of \Cref{pq:lem:small-tag:proof:se:proof:K} (but does not imply the actual probabilistic condition, which we will show separately).
% \end{AlgorithmBox}

% Finally, we can state the descriptions of the machines $\mcal{K}^{(j)}$. Again, they are basically average-case versions of $\Set{\mcal{K}^{(j)}_i}_{i\in[\tilde{t}^{(j)}]}$:
% \begin{itemize}
% \item
% {\bf Extractor $\mcal{K}^{(j)}$:} For each $j \in [N]$, on input ${(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})}$, $\mcal{K}^{(j)}$ samples an index $i \pick [\tilde{t}^{(j)}]$ uniformly and runs $\mcal{K}^{(j)}_i{(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})}$, and outputs the result.  
% \end{itemize}


\subsection{Simulation-Extractor $\mcal{SE}$: 1-Many Setting}
\label{sec:sim-ext:1-many:final}

To finish the proof of \Cref{lem:simext:closeness:1-many} (and thus the proof of weak 1-many non-malleability), there are two things left now. First, we will build a {\em simultaneous} simulation-less extractor $\mcal{K}$ that extracts the $\tilde{m}^{(j)}$'s in all the right sessions. As long as we have such an $\mcal{K}$, we can re-use the noisy simulation extraction lemma (i.e., \Cref{lem:Noisy-SimExt}) to upgrade it to the desired simulation-extractor $\mcal{SE}$ as required by \Cref{lem:simext:closeness:1-many}. In the following, we elaborate on these two steps.

\para{Simultaneous Simulation-less Extractor $\mcal{K}$.} Such a $\mcal{K}$ can be built by applying the simultaneous extraction lemma we developed in \Cref{lem:Simultaneous-SimExt} to the localized simulation-less extractors $\mcal{K}^{(j)}$'s. For that, we first need to prove that these $\mcal{K}^{(j)}$'s in \Cref{pq:lem:small-tag:proof:se:proof:K:1-many} indeed satisfied the prerequisites in \Cref{lem:Simultaneous-SimExt}. Similar as in \Cref{sec:sim-less-to-sim:1-1}, we will not show it directly with the $\mcal{K}^{(j)}$'s. Some `wrapper' machines need to be defined to make the parameters match. Fortunately, this step is almost identical to what we did in \Cref{sec:sim-less-to-sim:1-1}. We will be able to use almost the same parameter settings.  

\subpara{Machine $\mcal{G}'$:} it takes as input $(1^\secpar, 1^{\gamma^{-1}}, \msf{pref}'^{1:N})$ and proceeds as follows:
\begin{enumerate}
\item
Set $\epsilon\coloneqq \gamma$.
\item
Compute $\epsilon_1$ from $\epsilon$. Note that this can be done because \Cref{pq:lem:small-tag:proof:se:proof:K:1-many} stipulates the there is a noticeable $\epsilon_1 \le \epsilon$ that is efficiently computable from $\epsilon$.
\item
Run machine $\mcal{G}_1(1^\secpar, 1^{\epsilon_1^{-1}}, \msf{pref}'^{1:N})$ (as per \Cref{pq:lem:small-tag:proof:se:proof:K:1-many}) and output whatever it outputs.
\end{enumerate}

\subpara{Machine $\mcal{K}'^{(j)}$ ($j \in [\tilde{t}]$):} it takes as input $(1^\secpar,1^{\gamma^{-1}}, 1^{\zeta^{-1}},\msf{pref}'^{1:N})$ and proceeds as follows:
\begin{enumerate}
\item
Set $\epsilon\coloneqq \gamma$.
\item
Compute $\epsilon_1$ from $\epsilon$. Note that this can be done because \Cref{pq:lem:small-tag:proof:se:proof:K:1-many} stipulates the there is a noticeable $\epsilon_1 \le \epsilon$ that is efficiently computable from $\epsilon$.
\item
Set $\epsilon_2 \coloneqq \zeta$.
\item
Run machine $\mcal{K}^{(j)}(1^\secpar, 1^{\epsilon_1^{-1}}, 1^{\epsilon_2^{-1}}, \msf{pref}'^{1:N})$ (as per \Cref{pq:lem:small-tag:proof:se:proof:K:1-many}) and output whatever it outputs.
\end{enumerate}

Compare the above machines with the $\mcal{G}'$ and $\mcal{K}'$ defined in \Cref{sec:sim-less-to-sim:1-1}, the only differences regarding the parameters is that we set $\epsilon_1 = \gamma$ directly, instead of $\epsilon_1 = 8\gamma$. That is because the RHS of the {\bf Assumption 2} of \Cref{lem:Simultaneous-SimExt} is $\gamma(\secpar)$ ( instead of $8\gamma(\secpar)$ in the RHS of \Cref{item:gamma_delta} in \Cref{lem:Noisy-SimExt}).
   


Now, if we treat the above $\mcal{G}'$ as machine $\mcal{V}$ in \Cref{lem:Simultaneous-SimExt}, treat the above $\Set{\mcal{K}'^{(j)}}_{j \in [N]}$ as the machines $\Set{\mcal{K}_i}_{i \in [n]}$ (i.e., $n = N$), and set $\delta(\secpar) \coloneqq \frac{\epsilon'(\secpar)}{\tilde{t}}$, then it is straightforward to see that that {\bf Assumption 1} and {\bf Assumption 2} of \Cref{lem:Simultaneous-SimExt} are satisfied.\footnote{Similar as in \Cref{sec:sim-less-to-sim:1-1}, $\msf{pref}'^{1:N}$, $\Set{\tilde{\tau}^{(j)}}_{j\in [N]}$, and $\Set{\msf{val}(\tilde{\tau}^{(j)})}_{j \in [N]}$  play the role of, $\rho_\secpar$, $z_\secpar$, and $\Set{s^*_{z_\secpar, j}}_{j \in [N]}$ respectively.} Thus, \Cref{lem:Simultaneous-SimExt} implies the desired {\em simultaneous} simulation-less extractor $\mcal{K}$ that is able to extract all the committed values in the $N$ right sessions.

\para{1-Many Simulation-Extractor $\mcal{SE}$.} Finally, simply observe that \Cref{item:simultaneous_conclusion_s_star_or_bot,item:simultaneous_conclusion_gamma_delta} in \Cref{lem:Simultaneous-SimExt} is exactly the prerequisites of the noisy simulation-extraction lemma (i.e., \Cref{lem:Noisy-SimExt}). Thus, a straightforward application of \Cref{lem:Noisy-SimExt} to the machines $\mcal{K}$ and $\mcal{V}$ (with them being the $\mcal{K}$ and $\mcal{G}$ in \Cref{lem:Noisy-SimExt}) implies our desired simulation-extraction $\mcal{SE}$ in the 1-$N$ setting. This finishes the proof of \Cref{lem:simext:closeness:1-many} , and thus in turns finishes our proof of weak 1-$N$ non-malleability (i.e., \Cref{def:NMCom:weak:pq}). 

Note that limitation to weak 1-many non-malleability is somewhat inherent to our approach: the simultaeneous simulator-extractor we define has a requirement on the machine that corresponds to $\mcal{G}'$ --- namely, it should output $\top$ with a certain noticeable probability. In our interpretation, this output corresponds to the {\em conjunction} of all the verifier decisions (accept/reject) in the right sessions. This condition translates to assuming that our MIM adversary completes every right session successfully with a reasonably large probability, and so our treatment can only consider adversaries that obey this constraint --- and not ones, for example, that {\em always} abort in certain right sessions. We thus eschew showing standard 1-many non-malleability; and as we shall later see, weak one-many non-malleability suffices for the applications we have in mind for our commitment. 