% Having obtained bounds in the form of a probability range for each output of the NN, we now turn to the task of propagating these bounds through the symbolic component of a NeSy system. Our aim is to find the minimum and maximum probability that the reasoning module can output given the probability range of its inputs, and investigate the complexity of performing this computation exactly.

% Our aim is to find the minimum and maximum probability that the reasoning module can output given the probability range of its inputs. 

% These final bounds can then be used to answer verification queries, such as robustness, as previously outlined.

%  to obtain bounds on the circuit root node,

Let us now assume that via known techniques described in Section \ref{verification_concepts} we have obtained bounds in the form of a probability range for each output of the NN. Next, we turn to the task of propagating these bounds through the symbolic component, in order to obtain maxima/minima on the reasoning output, and investigate the complexity of doing so exactly. First, we show that, in the worst case, to find the solution we have to check all combinations of lower/upper bounds for all NN outputs. To illustrate this, we utilize the circuit representation of the symbolic component obtained via KC. It is known that such circuits represent multi-linear polynomials of the input variables \cite{choi2020probabilistic}. For example, a simple traversal of the SDD of Figure \ref{fig:sdd} yields the polynomial:

\vspace{-0.3cm}
\begin{align*}
    p \; = \; &\big( 1 - p(\text{car in front}) \big) \times \big( 1 - p(\text{red light}) \big) \\
    &\times p(\text{accelerate}) + p(\text{brake})
\end{align*}

Given this formulation, it is possible to obtain bounds on the circuit root node by solving a constrained optimization problem, in which we find the extrema (maximum and minimum) of the polynomial, subject to the bounded domains of the input variables (the NN outputs). We observe that this circuit polynomial is defined on a rectangular domain, since all input variables are defined in a closed interval (e.g. $\text{red light} \in [0.3, 0.4], \text{brake} \in [0.6, 0.9]$). It is known that in this case the extrema lie on the vertices of the domain \cite{laneve2010interval}, i.e., at the extrema each variable is assigned either its lower or upper bound, not something in between. Thus, in the worst case, to find the extrema one needs to search the combinatorial space of $2^n$ possible solutions.

In order to calculate the maximum and minimum output of the symbolic component, for each of the $2^n$ points we have to solve one instance of the WMC problem. Indeed, since each possible solution represents a probability assignment to all input variables, we can use WMC to compute the probabilistic output of the reasoning module under that weight assignment, and then select the maximum and minimum value obtained over all assignments.

Given the two steps above, it can be seen that starting with the formula, i.e., without first compiling it into a circuit, exact bound computation is a $\mathrm{NP}^{\# \mathrm{P}}$-hard problem. Intuitively, we need to search in the combinatorial space of variable configurations (the $\mathrm{NP}$ part), while performing WMC for each configuration (the $\# \mathrm{P}$ part). In this context, performing amortized inference via knowledge compilation entails that instead of solving a $\mathrm{NP}^{\# \mathrm{P}}$-hard problem for every sample, we perform a single $\# \mathrm{P}$-hard compilation at the beginning, and are ``just'' left with an NP problem per sample during runtime. Henceforth, we only consider the latter setting by assuming this initial compilation step.

% To evaluate each possible solution, that is, a probability assignment to each of the input variables, one needs to compute the Weighted Model Count of the formula represented by the circuit. Thus, solving the problem exactly is $\mathrm{NP}^{\# \mathrm{P}}$-hard. Intuitively, we need to search in the combinatorial space of variable configurations (the $\mathrm{NP}$ part), while performing WMC for each configuration (the $\# \mathrm{P}$ part).
