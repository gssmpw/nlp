
\iffalse 

%\subsection*{Preliminaries and notation} \label{sec::prely}

%\paragraph{The graph model and the mining task}

The dynamic (incremental) graph model we study can be defined as a sequence
    $\dynG = \{ G^{(0)}(V,E^{(0)}), \ldots, G^{(t)}(V,E^{(t)}), \ldots G^{(T)}(V,E^{(T)}) \}$,   where: (i) the set of vertices $V = \{1, \ldots , n \}$ is fixed, (ii) $T \leq \binom{n}{2}$ is the final graph,  while (iii)  $E^{(t)}$ is the subset of edges at time $t$. Note that this  changes in every time step $t \geq 1$, as a new edge $e^{(t)}$ is inserted, so that $E^{(t+1)} = E^{(t)} \cup \{e^{(t)}\} $. 
We remark that  our analysis and all our results can be easily adapted to a more general model that includes any combination of the following variants: (i)  growing vertex sets, (ii)  multiple insertions of the same edge, and (iii) directed edges (thus yielding directed graphs).  However,  the corresponding  adaptations of our analysis  would require  significantly heavier notation and some technicalities that  we decided to avoid for the sake of clarity and space.

Our goal is to design algorithms that, at every time step $t \geq 1$, are able to efficiently compute queries over the current $2$-balls of $G^{(t)}$. As mentioned in the introduction, our focus is on queries that are typical in graph mining such as: (i) given a vertex $u$, estimate the size of $\ball_2(u)$, and (ii) given two vertices $u,v \in V$, estimate the Jaccard similarity of the corresponding $2$-balls:
\[ 
    \jacc(\ball_2(u),\ball_2(v)) \ = \ \frac{|\ball_2(u) \cap \ball_2(u) |}{|\ball_2(u) \cup \ball_2(u) |}  \, . 
\]
Both the  theoretical  and experimental analysis of  our   lazy-update algorithms  consider the following key performance  measures: the \textit{amortized update time} per edge insertion and the \textit{approximation ratio} of our algorithms on the quantities $|\ball_2(u)|$ and $\jacc(\ball_2(u),\ball_2(v))$, for any choice of the input vertices. Intuitively, the amortized update time is the average time it takes to process a new edge, a more formal definition is deferred to \Cref{sec:detalgo}, after  a detailed description of the   algorithms  we consider.
    
We next summarize notation that is extensively used in the remainder of the paper. For a vertex $v \in V$ of a graph $G(V,E)$, we define:
    
    
    \begin{description} 
     % \item[$ \neigh^{(t)}(u)$:]    neighborhood  of $u$ as    = \{ v \in V^{(t)} \, : \,   (u,v) \in E^{(t)} \} $
  % \item[$\bd_v$:] the heavy degree;
    % \item[$\rd_v$:] the light degree;
    \item[$\neigh(v)$:] the set of neighborhoods of the vertex $v$.
    \item[$\deg_v$:] the degree of $v$. Notice that $\deg_v = \vert \neigh(v) \vert$;
    \item[$\lset_h(v)$:] set of vertices at distance exactly $h$ from $v$;
    \item[$\ball_h(v)$:] set of vertices at distance at most $h$ from $v$. 
\end{description}

The reader may have noticed that, in our notation above, the term $t$ does not appear: this is due to the fact that our analysis holds at any (arbitrarily-fixed) time step, which  is always clear from context. 



 \fi 



