% !TeX root = ../main.tex

\section{Overview of OSF}\label{Section3}
%By analyzing the limitations of existing fuzzing surveys, we propose a new classification dimension for a systematic review of OSF. Following this classification, we introduction the general workflow of OSF from the initial test case generation to the final bug analysis, and discuss the influence of the inherent complexity of operating systems on the fuzzing process.

After analyzing existing fuzzing surveys, we employ PUT-based classification for a systematic~review of OSF (Section~\ref{Section3-1}). Following this classification, we introduce the main tasks of the four OS layer fuzzing (Section~\ref{Section3-2}), and provide a high-level overview of the general workflow of OSF (Section~\ref{Section3-3}).

\subsection{Classification Dimension} \label{Section3-1}

%The existing classification method for fuzzing surveys is based on four dimensions: 1) the amount of information the fuzzer requires or uses (black-, white-, and gray-box), 2) the method of seed update (mutation- and generation-based), 3) research gaps, and 4) testing objects. The above taxonomy serves most fuzzing-related literature surveys, but only the last dimension applies to the open source OS fuzzing survey in this paper. The main reasons are explained below:

% The existing classification method for fuzzing surveys is based on four dimensions: 1) the amount of information the fuzzer requires or uses (black-, white-, and gray-box), 2) the method of seed update (mutation- and generation-based), 3) research gaps, and 4) PUT-based fuzzing method.
% \todo{The first three classifications typically apply to the study of fuzzing techniques themselves, while only the last one is relevant to the fuzzing of open-source OS discussed in this paper.} The main reasons are explained below:

% \begin{itemize}
%   \item [1)] 
%   The first dimension focused on the taxonomy of fuzzer concerning black-, white-, and grey-box with an insight toward the every stage of fuzzing techniques \cite{Mans2018TheAS,Li2018FuzzingAS,Liang2018FuzzingSO,Godefroid2020,bohme2020fuzzing}. This type of classification is useful for researchers to understand traditional fuzzing techniques, as there are significant distinctions between fuzzing approaches for open-source and closed-source applications. \todo{However, for the context of this paper's discussion on open-source OS fuzzing, we focus solely on how to conduct fuzzing trial on open-source OS, which are more complex than traditional software, and do not consider closed-source OS or their fuzzing methods.}
%   \item [2)]
%   The second dimension based on the seed updating approach can be divided in mutation- and generation-based fuzzer \cite{Saavedra2019ARO}. This taxonomy concentrate on the strengths and limitations of all the cutting edge techniques for seed updating approach such as random-oriented \cite{schumilo2020hyper}, grammar-aware \cite{schumilo2021nyx, myung2022mundofuzz}, semantic-aware \cite{pan2021V-shuttle, cesarano2023iris, bulekov2022morphuzz} and \etc The selection of these approaches is driven by application scenarios and are constructed to serve either mutation-based or generation-based fuzzer. Unfortunately, while these methods provide an introduction to the field with an idea of what seed updating methods are available and how to accurately update the seeds, they lack discussions on essential fuzzing components such as seed selection, seed trim, feedback, \etc As a result, they are not suitable for a systematic review of the complete OSF workflow.
%   \item [3)]
%   The third dimension provides a comprehensive review of the potential research challenges introduced by integrating other specific techniques into fuzzing \cite{Wang2019ASR, Zhang2018SurveyOD, Wang2020SoKTP, Zhu2022FuzzingAS, Mallissery2023DemystifyTF}. This type of taxonomy is indeed useful in analyzing the challenges of a particular technique, for example, Mallissery and Wu \cite{Mallissery2023DemystifyTF} focus on reviewing the research gaps of program analysis in fuzzing and tries to give the direction of feasibility of bridging these gaps. Since this type of taxonomy focuses on a comprehensive summary of a particular technique, it still does not provide a comprehensive review of all the technical details and difficulties involved in executing OSF.
%   \item [4)]
%   The last classification dimension categorizes fuzzing methods based on different modules or software layers within the PUT \cite{Yun2022FuzzingOE, Eisele2022EmbeddedFA}, for example, Eisele et al. \cite{Eisele2022EmbeddedFA} divide embedded system fuzzing into direct fuzzing, emulation-based fuzzing, and firmware analysis, and review the unique fuzzing technique in all state-of-the-art fuzzers for embedded system. This dimension surpasses the above classifications in terms of comprehensiveness considerations, due to the fact that different OS layer fuzzing interfaces inherently determine the overall approach to seed generation, selection, mutation, feedback, and vulnerability monitoring. Therefore, in order to fill the research gap in OSF survey and to comprehensively review the expertise and specifics required by the different OS layers fuzzing, this taxonomy is adopted as the guiding criterion for categorization in this paper.
% \end{itemize}

Existing fuzzing surveys classify the literature by one of the four dimensions, \ie
1) the amount~of~information the fuzzer requires or uses (black-, white-, and gray-box)~\cite{Mans2018TheAS, Li2018FuzzingAS, Liang2018FuzzingSO, Godefroid2020, bohme2020fuzzing}, 
2) the~strategy employed for seed update (mutation- and generation-based)~\cite{Saavedra2019ARO, schumilo2020hyper, schumilo2021nyx, myung2022mundofuzz, pan2021V-shuttle, cesarano2023iris, bulekov2022morphuzz},~3)~the research gaps of integrating advanced techniques into traditional fuzzing workflows~\cite{Wang2019ASR, Zhang2018SurveyOD, Wang2020SoKTP, Zhu2022FuzzingAS, Mallissery2023DemystifyTF}, and 
4) the PUT \cite{Yun2022FuzzingOE, Eisele2022EmbeddedFA}. 
Here, we adopt the fourth dimension as the guiding taxonomy, as the first three dimensions primarily focus on the general study of fuzzing techniques and lack the specificity required for analyzing OSF. In contrast, the PUT-based classification provides~a~comprehensive framework for systematically reviewing the general workflow of OSF while focusing on the unique challenges posed by the different OS layers (\ie different PUTs).


%\subsection{The Interface of Each OS Layer}
\subsection{OS Layers}\label{Section3-2}

%According to the classification in this paper, we categorize the current OSF into four categories, namely, kernel, driver, file system, and hypervisor. Reviewing the existing state-of-the-art OSFs, the four OS layers have significant differences in their respective fuzzing interfaces, fuzzing techniques, and research challenges. In the following, we offer an overview of the fuzzing interfaces across each OS layer. The details of the fuzzing techniques for each layer are discussed in Section \ref{Section4}. Additionally, the research challenges are comprehensively reviewed in Section \ref{Section5}.

According to the PUT-based classification we employed, OSF can be categorized into four types, \ie kernel fuzzing, file system fuzzing, driver fuzzing, and hypervisor fuzzing. Due to the distinct differences in fuzzing approaches across these four OS layers, it is necessary to outline the primary functions of each OS layer and the primary tasks of their respective fuzzing approaches.


\begin{figure}[!t]
  \centering
  \includegraphics[width=0.60\linewidth]{img/OSFuzzing.png}
  \caption{The Interfaces of Each OS Layer (\protect\circled{1}, \protect\circled{2}, \protect\circled{3} and \protect\circled{4} denote the fuzzing interfaces for Kernel, Driver, File System and Hypervisor respectively; and \protect\circled{1} is also the fuzzing interface for Driver and File System).}
  \label{OSFuzzing}
\end{figure}


%\textbf{Kernel}. Kernel fuzzing works by running executable entities on the OS that can transition into kernel space, and the logical sequence of syscalls \todo{(also known as system calls)} within program will determine which part of the kernel code branch is executed. If a crash occurs during execution, the crash needs to be analyzed to determine whether it represents an actual vulnerability. As shown in the Figure \ref{OSFuzzing}, a test case is a sequence of syscalls with sequential or logical relationships, and these collections can take various forms, such as executable programs or command-line scripts. If it is an executable program, it includes program variables and general functions beyond syscalls, but if it is a command-line script, it usually contains only syscalls and parameter values. When the first test case is ready, it is mounted in user space under the control of the fuzzing engine to execute the program logic of the test case. During this process, the operating system switches from the user space to the kernel space \circled{1} and monitors the behavior of the kernel by triggering code branches of specific modules. In Figure \ref{OSFuzzing}, the kernel space illustrates the activated code branches, where circles represent basic code blocks. The darker sequences indicate the branches activated by the test case, while lighter circles denote the yet-to-be-uncovered code blocks. To uncover potential vulnerabilities, fuzzing aims to generate effective syscall sequences that achieve comprehensive coverage of the kernel's code branches.

\textbf{Kernel}. Kernel is one of the most critical systems in an OS because it manages essential resources such as processes and memory for the entire system and provides a unified programming interface for user-space programs to interact with hardware resources. All other system types rely~on~and operate on top of the kernel. Consequently, vulnerabilities in the kernel can be maliciously exploited, potentially causing significant damage to the systems running on it. As illustrated in Figure \ref{OSFuzzing}, to perform kernel fuzzing, a fuzzer triggers the kernel's code paths by switching from user space~to kernel space through syscall \circled{1} (a.k.a. system call) \cite{Koopman1997ComparingOS}. Therefore, the core task of a kernel fuzzer is to generate various test cases (referred to as seeds) by combining syscalls~provided~by~the~kernel to continuously trigger the kernel's code paths. For example, the darker sequences in Figure \ref{OSFuzzing} denote branches covered by test cases, while the lighter circles denote code blocks yet to be covered.

%\textbf{Driver}. As kernel subsystem, device driver plays a crucial role in maintaining the security of the OS kernel \cite{Chou2001AnES, Palix2011FaultsIL, Stoep2018AndroidSecurity}. A primary reason is the breadth and diversity of driver implementations, which hampers scalable and coherent security analysis. Worse, they expose a richer attack surface than the kernel or other kernel subsystems: drivers expose peripheral attack surfaces in addition to system call attack surfaces. As a result, vulnerabilities in device drivers are often discovered and exploited by adversaries through both attack surfaces in local and remote attack scenarios \cite{Beniamini2017Part1, Beniamini2017Part2, Chang2017, Davis2011, NohlLell2014}. As Figure \ref{OSFuzzing} demonstrates, there are two attack surfaces in driver: syscalls \circled{1} that interact with the user-space, and peripheral interfaces \circled{2} that directly communicate with devices. The syscall-based interface aligns with kernel fuzzing, but driver fuzzing specifically focuses on mutating syscalls that manipulate device files, \eg read(), write(), seek(), ioctl() and \etc The peripheral interface can be implemented through either I/O interception or device configuration. I/O interception involves capturing access to I/O objects (\ie DMA, MMIO, and Port I/O) to mutate I/O data. This mutated data is then redirected to the target object to monitor the driver's behavior. In contrast, device configuration simulates a peripheral device's behavior, injecting the simulated data into the I/O channel to discover vulnerabilities in a specific device driver. The breadth and diversity of device drivers complicate the discovery of potential vulnerabilities. Consequently, current research on driver fuzzing exhibits significant technical variability. This requires careful consideration of various test interfaces and the functional characteristics of devices to effectively tailor fuzzing approaches.

\textbf{File System}. As a core system service within an OS, file system is essential for tasks such~as~reading, writing, managing, and scheduling files, as well as ensuring data consistency during system crashes. Most file systems, like ext4 \cite{Cao2007Ext4TN}, XFS \cite{XFS2018}, Btrfs \cite{Rodeh2013BTRFSTL} and F2FS \cite{Lee2015F2FSAN}, operate within~the~OS kernel. Therefore, approaches used in kernel fuzzing can be adapted for file system fuzzing. However, approaches based purely on syscalls often yield numerous invalid results because the system state is predominantly influenced by metadata in file system operations. In contrast, operations~on regular file data through syscalls like \texttt{read()} and \texttt{write()} contribute little to identifying file system vulnerabilities. Hence, an effective file system fuzzer typically combines sequences of file operation-related syscalls \circled{1} with images \circled{3} where metadata has been changed. As shown in Figure \ref{OSFuzzing}, the altered disk image is mounted to the file system's partition using privileged commands \cite{schumilo2017kafl, Hydra2020finding}, becoming the new target for fuzzing. Kernel-provided syscalls are then used to conduct read, write, management, and scheduling operations, facilitating a comprehensive fuzzing of the file system.

%\textbf{File System}.
%Since the primary functions of a file system involve reading, writing, managing, and scheduling files, it is challenging to continuously trigger file system code paths through random fuzzing within the broad functional boundaries of the kernel. Notably, the file system's critical resource characteristics make it more susceptible to unique data race vulnerabilities, necessitating the careful design of specialized fuzzing techniques aimed specifically at particular file systems and their unique bugs. In existing research on file system fuzzing, the approach remains to initiate file system actions by mutating file operation behaviors and data through syscalls \circled{1}. It is crucial for researchers to ensure that these system calls actually reach the targeted file system's code areas. Additionally, another input has emerged for focused fuzz testing of File Systems: file system images \cite{schumilo2017kafl, kim2020finding}. As illustrated in Fig.\ref{OSFuzzing}, an image file \circled{3} that includes the complete structure of a file system is simulated in user space. This file is recognized by the operating system as a volume partition and is used in conjunction with syscalls to perform concentrated file system fuzzing. The process involves initially mutating the metadata, directory structures, and actual data of the image file. Subsequently, various IOCTLS (Input/Output Control System Calls) are used to programmatically mount it to the file systemâ€™s partition volume as the new object of testing. Finally, exposed kernel system calls are utilized to perform operations such as reading, writing, managing, and scheduling on this volume to achieve the goals of concentrated file system fuzzing. Consequently, although the file system, as a subsystem of the kernel, can have its code areas partially triggered through kernel fuzz testing, its unique characteristics demand more than just system calls for comprehensive testing. Therefore, to effectively discover both potential and specific bugs, it is necessary to employ specialized interfaces related to file operations for concentrated testing.

\textbf{Driver}. Drivers are responsible for communication and control between the user/kernel and hardware devices. They act as the bridge between hardware and OS, managing tasks such~as~device initialization, data transfer, and interrupt handling, ensuring that user-space applications~can~interact with underlying hardware \cite{Chou2001AnES, Palix2011FaultsIL, Stoep2018AndroidSecurity}. In driver fuzzing, the primary objective is to uncover vulnerabilities in device drivers across the initialization, data communication, and control stages. Since drivers can receive operation requests from both user space and hardware devices, they expose a broader attack surface compared to the kernel or other kernel subsystems \cite{Beniamini2017Part1, Beniamini2017Part2, Chang2017, Davis2011, NohlLell2014}. As illustrated in Figure \ref{OSFuzzing}, the two main attack surfaces for driver fuzzing are syscalls \circled{1} and peripheral interfaces \circled{2}. Unlike kernel fuzzers, syscall-based driver fuzzers focus more on syscalls that directly operate on device files, \eg \texttt{read()}, \texttt{write()}, \texttt{seek()}, \texttt{ioctl()}, \etc

The peripheral interface can be exploited in two ways, \ie I/O interception and device configuration. I/O interception involves intercepting access to I/O objects (\eg DMA, MMIO, and Port I/O) to mutate I/O data, which is then redirected to the target to observe the driver's behavior.~Device configuration, on the other hand, simulates peripheral device behavior and injects the simulated data into the I/O channel. In addition, it is worth noting that drivers constitute the largest codebase among kernel subsystems, and exhibit significant variability due to implementations by different vendors. As a result, driver fuzzers often face larger challenges in achieving high coverage, generating diverse test cases, and ensuring fuzzing effectiveness given these characteristics.

%\textbf{Hypervisor}. In environments with highly heterogeneous hardware, OS inherently lack the capability to manage and schedule heterogeneous computing resources, such as those used in railways, avionics, and automotive industries \cite{Cinque2021VirtualizingMS}. To enable multiple operating systems to run in parallel within a heterogeneous resource environment while maintaining security isolation between them \cite{RTCA_DO_178C, ISO_26262_2011}, Hypervisors utilize virtualization technology to divide hardware resources (CPU, memory, disk space, \etc) into several virtual partitions \cite{Popek1974FormalRF, Cinque2021VirtualizingMS, Cilardo2021VirtualizationOM}, supporting the deployment and operation of various OSs. In such scenarios, the Hypervisor and OS collectively form what is termed a generalized operating system. Unlike traditional operating systems, Hypervisors play a critical role in resource management and security isolation (\eg memory corruptions might lead to virtual machine escapes), where such issues are nearly impossible to discover directly in the kernel, drivers, or file systems, necessitating focused testing of the Hypervisor to uncover these vulnerabilities. As illustrated in Figure \ref{OSFuzzing}, interaction with the Hypervisor typically includes I/O channels or triggering hypercalls from the guest OS, which execute hypercall handler programs within the Hypervisor \circled{4}. I/O channels are more extensively used in fully virtualized environments because this technology provides complete simulation of hardware, leading to more frequent I/O communication. In the fuzzing of fully virtualized hypervisor, three types of I/O interaction interfaces provided by virtual devices to the guest machines can be utilized (Port I/O instructions for in and out, MMIO for device initialization, and DMA for complex and massive data communications). These interfaces can be actively operated by fuzzers through specific APIs or intercepted and injected with mutated data through hooking. In para-virtualization technologies, specialized instructions like 'vmcall' are introduced to implement Hypercalls, allowing the OS to communicate directly with the Hypervisor in bypassing the virtual machine. Hence, fuzzers can still fuzz the Hypervisor's code logic through the Hypercall interface. In summary, the Hypervisor plays a crucial role in a generalized operating system, responsible for managing and allocating virtual devices. Therefore, it is essential to conduct focused fuzzing on the Hypervisor to thoroughly uncover vulnerabilities related to heterogeneous resource management and security isolation unique to the generalized operating system.


\textbf{Hypervisor}. In environments with highly heterogeneous hardware, OSs inherently lack~the~capability to manage and schedule heterogeneous computing resources, such as those used in industries like railways, avionics, and automotive systems \cite{Cinque2021VirtualizingMS}. To enable the concurrent execution of multiple OSs while maintaining secure isolation between them in such heterogeneous resource environments \cite{RTCA_DO_178C, ISO_26262_2011}, hypervisors, a.k.a. Virtual Machine Monitors (VMMs), leverage virtualization~technique to partition hardware resources (\eg CPU, memory, and disk space) into multiple virtual partitions \cite{Popek1974FormalRF, Cinque2021VirtualizingMS, Cilardo2021VirtualizationOM}. When a guest OS, which runs within a Virtual Machine (VM), accesses or operates hardware devices, it triggers a VM-exit event that transfers these privileged operations~to~the~hypervisor for hardware emulation. Therefore, the objective of hypervisor fuzzing is to accurately emulate the behavior of the guest OS when accessing and operating these virtualized hardware components, which serves as the primary entry point for implementing hypervisor fuzzing trials. As illustrated in Figure \ref{OSFuzzing}, the main interfaces involved include I/O channels and hypercalls \circled{4}. 

To ease the understanding of how to perform hypervisor fuzzing using these interfaces,~we~introduce the technical background of hypervisors. Technically, hypervisors can be categorized into full virtualization and para-virtualization. In full virtualization, the guest OS is unaware~of~its~virtualized environment. Consequently, when the guest OS attempts to access physical hardware (\eg memory access), the hypervisor intercepts the request. At this point, the VM triggers a trap~and~enters~a~VM-exit state, with the hypervisor assuming a full control of the VM's operations. Subsequently, the hypervisor forwards the memory access request to the Device Emulator, which provides virtualization for Port I/O (input/output port instructions), MMIO (Memory-Mapped I/O for direct memory access), and DMA (for complex and large-scale data transfers). Finally, the Device Emulator returns the virtual memory access interface to the guest OS. In a fully virtualized environment, the I/O channel is more extensively utilized because this technique offers complete hardware emulation. However, this can also lead to more frequent communication overhead.

% These I/O communication operations can be initiated using specific APIs or mutated by hooks intercepting the communication data.

To facilitate and accelerate communication between the guest OS and the hypervisor, modern hypervisors often support hardware-accelerated virtualization technologies. By introducing specialized instructions (such as \texttt{vmcall}) to perform hypercalls, para-virtualization allows OSs to bypass the VM and communicate directly with the hypervisor. Therefore, in addition to the I/O channel, the hypercall interface can also be employed to implement hypervisor fuzzing trials. As a result, it is necessary to conduct specialized fuzzing of hypervisors to uncover vulnerabilities related to resource management and security isolation in generalized OSs.


\subsection{OSF Workflow}\label{Section3-3}

We summarize the general workflow of OSF in Figure~\ref{OSF_WorkFlow}, which consists of three key modules, \ie \textit{input}, \textit{fuzzing engine}, and \textit{running environment}. Each module is described in detail as follows.

\begin{figure}[!t]
  \centering
  \includegraphics[width=0.66\linewidth]{img/OSF_WorkFlw.png}
  \caption{General Workflow of OSF (It has three modules, \ie input, fuzzing engine, and running environment).}
  \label{OSF_WorkFlow}
\end{figure}

\textbf{Input}. There are three types of inputs to be considered in the input module, \ie initial seed,~specification, and target OS. First, the initial seed is the raw material fed to the fuzzing engine, which~is initially deposited in a global corpus (\ie a repository for storing seed candidates) and subsequently used throughout the fuzzing workflow. Second, the specification, which describes the structure and syntax of the seed, is parsed by the fuzzing engine and used to generate new seeds or enhance~the quality of the seeds. It is important to note that the use of the specifications is not applicable~to~all scenarios; it mainly applies to highly structured seeds with documented descriptions of the seed structure \cite{Syzkaller, chen2020koobe, zhao2022statefuzz, sun2021healer, shen2021rtkaller, shen2022tardis, jeong2023segfuzz, xu2020krace, jeong2019razzer}. Third, the target OS requires to be instrumented to collect runtime information for feedback analysis and bug monitoring during fuzzing.

\textbf{Fuzzing Engine}. The main function of the fuzzing engine is to generate new seeds and wrap them into test cases for the input fed to the executor in the running environment. This module~go through a complete closed loop of seed selection from a corpus, seed mutation and/or generation,~and~seed~trim before storing to the corpus. Specifically, the corpus stores only seeds that have~been~verified~as ``high-quality'', where ``high-quality'' seeds can be defined as the seeds~that~have~triggered~bugs~\cite{zou2022syzscope, wu2018fuze,lin2022grebe,shen2021rtkaller}, the initial seed generated based on tailored rules \cite{shen2022drifuzz} or specifications \cite{Syzkaller},~or~the streamlined seeds after seed trim as they trigger new coverage \cite{pailoor2018moonshine, shen2021rtkaller}. Such a consideration stems from the empirical conclusion that \todo{mutations} based on high-quality seeds usually have more opportunities to move the execution of the PUT closer to trigger bugs~\cite{you2017semfuzz, shen2022drifuzz, lin2022grebe, Unicorefuzz2019}.~However, even if the corpus always stores high-quality seeds, it is necessary to consider which~seeds should be prioritized in order to improve the efficiency of \todo{seed mutation}. Therefore, seed selection~is~often adopted to prioritize the seeds in the corpus, and a computation method of seed priority is often devised to ensure that the selected seeds have more chances to reveal new bugs, \eg PageRank~\cite{lin2022grebe}, program analysis \cite{wu2018fuze, chen2022sfuzz}, evolutionary algorithm \cite{shen2022drifuzz, henderson2017vdf, xu2020krace}, empirical strategy \cite{xu2020krace, Syzkaller, you2017semfuzz, zou2022syzscope}, reinforcement learning \cite{wang2021syzvegas}, \etc Then, to continuously generate test cases~to~automate~the whole fuzzing process, \todo{seed mutation and/or generation}  transform and/or generate the seeds in some way and wrap them into test cases that can be executed by the target OS. For example, seed mutation employs parameter-level bit flips or byte-level replacement to generate seeds based on the high-quality seeds in the corpus. Seed generation builds test case models from the specification~to generate new seeds. Finally, to further improve the speed performance of OSF, the generated~seed usually requires to be trimmed to reduce its mutation space as well as its execution time, \eg greedy algorithm~\cite{pailoor2018moonshine} and stepwise filtering \cite{schumilo2020hyper, henderson2017vdf}. The trimmed seeds are then stored into the corpus, and the process is repeated to automatically drive new and high-quality seed generation.

\textbf{Running Environment}. The running environment is responsible for feeding the test cases wrapped by the fuzzing engine into the executor. Unlike traditional fuzzing techniques, OSF~usually relies on full-virtual environment to avoid as much as possible the effects propagated by~OS~crashes. In contrast, traditional fuzzing techniques do not fatally affect the entire fuzzing process even if a crash occurs. Therefore, the running environment of OSF is often designed as full-virtual~environment that can be quickly recovered, allowing the entire system to be quickly restarted to a known, clean state in the event of a crash \cite{shen2022tardis, lin2022grebe, schumilo2021nyx, pan2021V-shuttle, zhao2022semantic, song2020agamotto}. Such a design allows~a~fuzzer to run thousands of test cases continuously and automatically in an isolated environment without worrying about the potential for lasting damage from individual test cases. Subsequent execution results fall into two categories. If the executor does not crash, the feedback will be collected~by the instrumented code, which is used to guide \todo{seed mutation} of the fuzzing engine to steer~the~fuzzing towards uncovered program paths. If the executor triggers a crash, the instrumented code records the information and sends it to the bug analyzer. The bug analyzer identifies and categorizes errors, and generates detailed bug reports. Finally, if the fuzzing process is not yet finished, it should be restored to its pre-crash state, and then move on to explore other states of the target OS.

Although there are some similarities with traditional fuzzing in terms of the coarse-grained~fuzzing process, the technical challenges and implementation details of each step need to take into account the specificity and complexity of OS, which ultimately makes it show a big difference with traditional fuzzing in terms of the fine-grained \todo{details}. Therefore, we will elaborate on the technical details and technical distinctions of each step illustrated in Figure \ref{OSF_WorkFlow} in Section~\ref{Section4} and \ref{Section5}.
