% !TeX root = ../main.tex

\section{Distinctive Fuzzing Characteristics among OS Layers} \label{Section5}
In this section, we discuss the characteristics of fuzzing in different system layers of an operating system (\ie kernel, file system, driver, and hypervisor) by using the PUT's interaction interface as a focal point. This discussion provides practitioners with a quick overview of the inherent problems and potential solutions associated with the adoption of fuzzing techniques in different system layers.


\subsection{Kernel Fuzzing}
Kernel fuzzer utilizes syscall as the interaction interface. \todo{Since the number of kernel functions far exceeds the number of syscalls and there is no one-to-one mapping between them, different uses of syscalls and their arguments can trigger entirely different kernel functions. In other words, improper use of syscalls is likely to deviate from the intended target, leading to unexpected crashes or producing invalid test results. To conduct an effective kernel fuzzing campaign, it is crucial to ensure the syntactical correctness of syscall sequences and argument usage, while also ensuring semantic validity. Therefore, kernel fuzzing typically encounter the problems of dependency inference (syntax), API polymorphism (semantics), and argument inference (semantics).} In Table \ref{tab_kernel}, we indicate which kernel fuzzers have specifically focused on these three problems, and we discuss them in detail as follows.


%Kernel fuzzer utilizes syscall as the interaction interface, thus the use of syscall is the key influence on the effectiveness. Typically, the problems of dependency inference, API polymorphism, and argument inference are encountered when performing kernel fuzzing. In Table \ref{tab_kernel}, we indicate which kernel fuzzers have specifically focused on these three problems, and we discuss them in detail as follows.

% \begin{table}
%   \footnotesize % 减小字体大小
%   \caption{Kernel Fuzzers.}
%   \label{tab_kernel}
%   \begin{tabular}{ccccc}
%   \toprule
%   Fuzzers & OS & Dependency Inference & API Polymorphism & Argument Inference \\
%   \midrule
%   Trinity\cite{Trinity} & L & - & - & -\\
%   PERF\cite{Weaver2015perf} & L & - & - & -\\
%   Syzkaller\cite{Syzkaller} & L & \fullcirc(1) & - & - \\
%   KernelFuzzer\cite{KernelFuzzer2016} & L & - & - & - \\
%   Moonshine\cite{pailoor2018moonshine} & L & \fullcirc(1) & \fullcirc & - \\
%   FUZE\cite{wu2018fuze} & L & - & - & - \\
%   Schwarz et al.\cite{schwarz2018automated} & L & - & - & ? \\
%   Razzer\cite{CONZZER2022context} & L & - & - & - \\
%   SLAKE\cite{Liu2023LFuzz} & L & - & - & -\\
%   Shi et al.\cite{shi2019industry} & L & - & - & - \\
%   Unicorefuzz\cite{Unicorefuzz2019} & L & - & - & - \\
%   KOOBE\cite{chen2020koobe} & L & - & - & - \\
%   HFL\cite{kim2020hfl} & L & \fullcirc(1) \fullcirc(2) & \fullcirc & \fullcirc \\
%   X-AFL\cite{liang2020xafl} & A & \fullcirc(1) \fullcirc(2) & - & - \\
%   HEALER\cite{sun2021healer} & L & \fullcirc(1) & - & - \\
%   Rtkaller\cite{shen2021rtkaller} & R & - & - & -\\
%   SyzVegas\cite{wang2021syzvegas} & L & - & - & -\\
%   GREBE\cite{lin2022grebe} & L & - & ? & - \\
%   Hao et al.\cite{Hao2022DemystifyingTD} & L & \fullcirc(1) \fullcirc(2) & - & - \\
%   KSG\cite{sun2022ksg} & L & - & \fullcirc & \fullcirc \\
%   Syzscope\cite{zou2022syzscope} & L & - & - & - \\
%   Tardis\cite{shen2022tardis} & U F R Z & - & - & - \\
%   Segfuzz\cite{jeong2023segfuzz} & L & - & - & - \\
%   FUZZNG\cite{bulekov2023FUZZNG} & L & - & - & \fullcirc \\
%   ACTOR\cite{fleischer2023actor} & L & - & - & - \\
%   Syzdirect\cite{tan2023syzdirect} & L & - & \fullcirc & - \\
%   KernelGPT\cite{yang2023kernelgpt} & L & - & -& \fullcirc\\
%   \bottomrule 
%   \end{tabular}
%   \\ An empty cell means that this aspect was not mentioned in the paper;  a ``?'' means that the element was mentioned, but the details are unclear. \textbf{OS}: ``A'' means Android, ``L'' means Linux, ``U'' means UC/OS, ``F'' means FreeRTOS, ``R'' means Rt-Thread, ``Z'' means Zephyr. \textbf{Dependency Inference}: \fullcirc(1) means considering explicit dependency, \fullcirc(2) means considering implicit dependency. \textbf{API Polymorphism}: \fullcirc means considering API Polymorphism. \textbf{Argument Inference}: \fullcirc means considering Argument Inference.
% \end{table}
% \begin{table}
%   \footnotesize % 减小字体大小
%   \caption{Kernel Fuzzers.}
%   \label{tab_kernel} 
%   \vspace{-0.3cm}
%   \begin{tabular}{ccccc}
%   \toprule
%   Fuzzers & OS & Dependency Inference & API Polymorphism & Argument Inference \\
%   \midrule
%   Trinity\cite{Trinity} & L &  &  & \\
%   PERF\cite{Weaver2015perf} & L &  & & \\
%   Syzkaller\cite{Syzkaller} & L & Explicit & & \\
%   KernelFuzzer\cite{KernelFuzzer2016} & L & Explicit &  &  \\
%   Moonshine\cite{pailoor2018moonshine} & L & Explicit & \fullcirc &  \\
%   FUZE\cite{wu2018fuze} & L & - & - & - \\
%   Schwarz et al.\cite{schwarz2018automated} & L &  &  & ? \\
%   Razzer\cite{CONZZER2022context} & L &  &  &  \\
%   SLAKE\cite{Liu2023LFuzz} & L &  &  & \\
%   Shi et al.\cite{shi2019industry} & L &  &  &  \\
%   Unicorefuzz\cite{Unicorefuzz2019} & L &  & &  \\
%   KOOBE\cite{chen2020koobe} & L &  &  &  \\
%   HFL\cite{kim2020hfl} & L & Explicit, Implicit & \fullcirc & \fullcirc \\
%   X-AFL\cite{liang2020xafl} & A & Explicit, Implicit &  &  \\
%   HEALER\cite{sun2021healer} & L & Explicit &  &  \\
%   Rtkaller\cite{shen2021rtkaller} & R &  &  & \\
%   SyzVegas\cite{wang2021syzvegas} & L & - & - & -\\
%   GREBE\cite{lin2022grebe} & L & - & ? & - \\
%   Hao et al.\cite{Hao2022DemystifyingTD} & L & Explicit, Implicit &  &  \\
%   KSG\cite{sun2022ksg} & L & - & \fullcirc & \fullcirc \\
%   Syzscope\cite{zou2022syzscope} & L & - & - & - \\
%   Tardis\cite{shen2022tardis} & U F R Z &  &  &  \\
%   Segfuzz\cite{jeong2023segfuzz} & L &  &  &  \\
%   FUZZNG\cite{bulekov2023FUZZNG} & L &  &  & \fullcirc \\
%   ACTOR\cite{fleischer2023actor} & L &  &  &  \\
%   Syzdirect\cite{tan2023syzdirect} & L &  & \fullcirc &  \\
%   BRF\cite{Hung2024BRFFT} & L & Dependency & & \fullcirc\\
%   MOCK\cite{Xu2024MOCKOK} & L\\
%   \bottomrule 
%   \end{tabular}
%   \begin{flushleft}
%   \justifying % 使脚注文字左右对齐
%   An empty cell means that this aspect was not mentioned in the paper; a ``-'' means it is not relevant; a ``?'' means that the element was mentioned, but the details are unclear. \textbf{OS}: ``A'' means Android, ``L'' means Linux, ``U'' means UC/OS, ``F'' means FreeRTOS, ``R'' means Rt-Thread, ``Z'' means Zephyr. \textbf{Dependency Inference}: \fullcirc(1) means considering explicit dependency, \fullcirc(2) means considering implicit dependency. \textbf{API Polymorphism}: \fullcirc means considering API Polymorphism. \textbf{Argument Inference}: \fullcirc means considering Argument Inference.
%   \end{flushleft}
% \end{table}

\begin{table}
  \scriptsize % 减小字体大小
  \caption{Kernel Fuzzers Sorted by Publication Year.}
  \label{tab_kernel} 
  \vspace{-0.3cm}
  \begin{tabular}{ccccc}
  \toprule
  Fuzzers & OS & Dependency Inference & API Polymorphism & Argument Inference \\
  \midrule
  Trinity\cite{Trinity} & Linux & - & - & -\\
  %PERF\cite{Weaver2015perf} & Linux & - & - & - \\
  Syzkaller\cite{Syzkaller} & Linux & DSL(ED) & - & - \\
  KernelFuzzer\cite{KernelFuzzer2016} & Linux & DSL(ED) & - & - \\
  Moonshine\cite{pailoor2018moonshine} & Linux & G\&CFA(ED,ID) & - & - \\
  FUZE\cite{wu2018fuze} & Linux & - & - & - \\
  Schwarz et al.\cite{schwarz2018automated} & Linux & - & - & - \\
  Razzer\cite{CONZZER2022context} & Linux & - & - & - \\
  SLAKE\cite{Liu2023LFuzz} & Linux & - & - & -\\
  Shi et al.\cite{shi2019industry} & Linux & - & - & - \\
  Unicorefuzz\cite{Unicorefuzz2019} & Linux & - & - & - \\
  KOOBE\cite{chen2020koobe} & Linux & - & - & - \\
  HFL\cite{kim2020hfl} & Linux & PTA(ED,ID) & DFA\&PTA & CE(NS) \\
  X-AFL\cite{liang2020xafl} & Android & - & - & - \\
  HEALER\cite{sun2021healer} & Linux & G(ED) & - & - \\
  Rtkaller\cite{shen2021rtkaller} & RT-Linux & - & - & -\\
  SyzVegas\cite{wang2021syzvegas} & Linux & - & - & -\\
  GREBE\cite{lin2022grebe} & Linux & - & - & - \\
  Hao et al.\cite{Hao2022DemystifyingTD} & Linux & M(ED,ID) & - &- \\
  KSG\cite{sun2022ksg} & Linux & - & DH & SE(TC) \\
  Syzscope\cite{zou2022syzscope} & Linux & - & - & - \\
  Tardis\cite{shen2022tardis} & \makecell{UC/OS, FreeRTOS, \\ RT-Thread, Zephyr} & - & - & - \\
  Segfuzz\cite{jeong2023segfuzz} & Linux & - & - & - \\
  FUZZNG\cite{bulekov2023FUZZNG} & Linux & - & - & H\&M(NS) \\
  ACTOR\cite{fleischer2023actor} & Linux & - & - & - \\
  Syzdirect\cite{tan2023syzdirect} & Linux & - & SA\&ICA & - \\
  KernelGPT\cite{yang2023kernelgpt} & Linux & - & - & LLM(TC) \\
  BRF\cite{Hung2024BRFFT} & Linux & H(ED,ID) & - & -\\
  MOCK\cite{Xu2024MOCKOK} & Linux & NN(ED,ID) & - & -\\
  \bottomrule 
  \end{tabular}
  \begin{flushleft}
  \justifying % 使脚注文字左右对齐
  A ``-'' means it is irrelevant, not mentioned, or unclear in detail. \todo{\textbf{Abbreviation}: In the form ``A(B)'', the fuzzer resolves a B-type issue using the A technique. In the form ``A'', the fuzzer employ A technique address the issue of API Polymorphism.\textbf{``A''} in ``A(B)'': \textbf{DSL}: Domain Specific Language, \textbf{G\&CF}: Graph Structure and Control Flow Analysis, \textbf{PTA}: Points-to Analysis, \textbf{G}: Graph Structure, \textbf{M}: Manual Checking, \textbf{H}: Heuristc Method, \textbf{NN}: Neural Network, \textbf{CE}: Concolic Execution, \textbf{SE}: Symbolic Execution, \textbf{H\&M}: Hooking and Mapping, \textbf{LLM}: Large Language Model. \textbf{B} in ``A(B)'': \textbf{ED}: Explicit Dependency, \textbf{ID}: Implicit Dependency, \textbf{NS}: Nested Structure, \textbf{TC}: Type Casting. \textbf{``A''}: \textbf{SA}: Static Analysis, \textbf{DFA\&PTA}: Data Flow Analysis and Points-to Analysis, \textbf{DH}: Dynamic Hooking, \textbf{SA\&ICA}: Static Analysis and Indirect Call Analysis.}
  \end{flushleft}
\end{table}

%A -'' means it is irrelevant, not mentioned, or unclear in detail. \textbf{Abbreviation}: the form ``A(B)'' indicates that fuzzer solves the B-type dependency using the ``A'' technique. \textbf{``A''} in ``A(B)'': ``DSL'' is the abbreviation of Domain Specific Language. ``T'' is marked as Trace. ``PTA'' is marked as Points-to Analysis. ``H'' means heuristic method. ``RG'' means Relation Graph. ``M'' is marked as manual checking. ``DFA\&PTA'' means Data Flow Analysis and Points-to Analy. ``DH'' is marked as Dynamic Hooking. ``SA\&ICA'' means Static Analysis and Indirect Call Analysis. ``CE'' is abbreviation of Concolic Execution. ``SE'' is marked as Symbolic Execution. ``H\&M'' means Hooking and Mapping. \textbf{``B''} in ``A(B)'': ``ED'' and ``ID'' is short for Explicit Dependency and Implicit Dependency, respectively. ``NS'' is marked as Nested Structure. ``TC'' is abbreviation of Type Casting.

%An empty cell means that this aspect was not mentioned in the paper; a ``-'' means it is not relevant; a ``?'' means that the element was mentioned, but the details are unclear. \textbf{OS}: ``A'' means Android, ``L'' means Linux, ``U'' means UC/OS, ``F'' means FreeRTOS, ``R'' means Rt-Thread, ``Z'' means Zephyr. \textbf{Dependency Inference}: \fullcirc(1) means considering explicit dependency, \fullcirc(2) means considering implicit dependency. \textbf{API Polymorphism}: \fullcirc means considering API Polymorphism. \textbf{Argument Inference}: \fullcirc means considering Argument Inference.


\subsubsection{Dependency inference.}
Kernel fuzzers typically start with a set of syscall sequences and continuously change the arguments and order of these syscalls using random mutations. In order to reduce randomness and enhance the effectiveness of kernel fuzzers, it is essential to infer potential dependencies between syscalls to construct correct sequences. These dependencies include explicit and implicit dependency. \todo{Explicit dependence refers to the relationship that the result produced by one syscall \( S_i \) is used directly as input to another syscall \( S_j \). For example, a \texttt{write} syscall must be preceded by an \texttt{open} syscall, or the return value of one syscall may serve as the input argument for another. Implicit dependency is defined as the another relationship that a syscall \( S_i \) affecting the execution of a syscall \( S_j \) through some shared data structure in the kernel, even though there is no direct result transfer between \( S_i \) and \( S_j \). A classic example of an implicit dependency is when \( S_i \) operates on a shared kernel variable, affecting the outcome of subsequent syscalls, \( S_j \), where i and j can be any value.}

\todo{Handling explicit dependencies is typically a straightforward task. Syzkaller \cite{Syzkaller}, KernelFuzzer \cite{KernelFuzzer2016} and HEALER \cite{sun2021healer} effectively address explicit dependencies by employing hardcoded rules to capture the return results generated by syscalls. However, these approaches only describe the correct syntax of individual syscalls, lacking information about interactions between multiple syscalls. As a result, they exhibit inherent limitations in recognizing implicit dependencies.}

%Syzkaller \cite{Syzkaller} can address the problem of explicit dependencies, this is because syzlang captures these potential relationships in hard-coded rules. In order to not rely on manual work, some works focusing on automatic seed generation must proactively address this problem. 

\todo{To simultaneously identify both explicit and implicit dependencies, Moonshine \cite{pailoor2018moonshine} constructs a dependency graph consisting of two types of nodes: syscall return values and arguments (implemented using customized Strace \cite{Strace} to trace syscall sequences). For example, an edge from a argument node \(a\) to a result node \(r\) represents that the value of \(a\) depends on the syscall that produced \(r\). To capture implicit dependencies, Moonshine performs control flow analysis to examine the read and write operations on global variables between syscalls, thereby identifying implicit dependencies. HFL \cite{kim2020hfl} uses points to analysis to obtain candidate explicit and implicit dependency pairs, and identifies data flow by symbolic execution, which reduces Moonshine's problem of missing implicit dependencies due to aliased variables. Hao et al. \cite{Hao2022DemystifyingTD} develop a measurement pipeline that quantifies the severity of dependencies and reveals the multiple causes of dependencies through manual analysis. Although effective, the manual-based analysis only focuses on specific linux kernel modules and fails to cover other critical modules such as drivers, file systems, \etc To extract the dependency relationships between eBPF programs and related system calls (such as \texttt{BPF\_MAP\_CREATE}), BRF \cite{Hung2024BRFFT} employs manual source code analysis to build an automated dependency parsing script with domain-specific knowledge. This script identifies both explicit dependencies (\eg argument passing between syscalls and eBPF helper functions) and implicit dependencies (\eg modifications to eBPF maps across multiple syscalls). Based on the extracted dependencies, BRF generates system calls and arguments tailored to the requirements of different eBPF programs, ensuring their correct loading and execution. }

%For implicit dependencies, HFL \cite{kim2020hfl} uses points to analysis to obtain candidate explicit and implicit dependency pairs, and identifies data flow by symbolic execution, which reduces Moonshine's problem of missing implicit dependencies due to aliased variables, but it is not known what types of dependencies are resolved and what percentage they account for due to the lack of in-depth dependency understanding. To capture both explicit and implicit dependencies, X-AFL \cite{liang2020xafl} determines explicit dependencies by invariant arguments value and implicit dependencies using the longest common subsequence. This approach has the advantage of simplicity and efficiency, but it has poor generalization capability and is prone to lose infrequent syscall sequences with implicit dependencies. Hao et al. \cite{Hao2022DemystifyingTD} develop a measurement pipeline that quantifies the severity of dependencies and reveals the multiple causes of dependencies through manual analysis. Although effective, the manual-based analysis only focuses on specific linux kernel modules and fails to cover other critical modules such as drivers, file systems, \etc To extract the dependency relationships between eBPF programs and related system calls (such as \texttt{BPF\_MAP\_CREATE}), BRF \cite{Hung2024BRFFT} employs manual source code analysis and verifier error feedback to build an automated dependency parsing script with domain-specific knowledge. This script identifies both explicit dependencies (\eg argument passing between syscalls and eBPF helper functions) and implicit dependencies (\eg modifications to eBPF maps across multiple syscalls). Based on the extracted dependencies, BRF generates system calls and parameters tailored to the requirements of different eBPF programs, ensuring their correct loading and execution. 

However, although previous approaches have constructed explicit and implicit dependencies, these dependencies are static and context-independent. Context-aware dependencies refer to relationships that exhibit different behaviors as the kernel state evolves, rather than remaining as unchanging, static explicit or implicit syscall sequences. For instance, two consecutive calls to \texttt{setsockopt} can configure a socket differently, altering the socket's state or the behavior of the protocol stack in the kernel, thereby placing it into a specific context that triggers deeper kernel code paths. In contrast, context-independent dependencies assume that a \texttt{write} call should follow the \texttt{setsockopt} call for data transmission, neglecting the need for further socket configuration to reach the correct state for triggering a particular vulnerability. This oversight can result in missed opportunities to exploit specific vulnerabilities. To address this issue, Mock \cite{Xu2024MOCKOK} introduces a neural network model that iteratively learns from refined syscall sequences. This approach captures both longer-range dependencies and changes in kernel state, enabling more accurate modeling of dynamic dependencies.

\subsubsection{API polymorphism.}
Polymorphism (or entry points) in the context of kernel syscalls refers to the kernel's ability to support various operations for different devices and features through indirect control transfer mechanisms, such as function pointer tables. Let \( S \) be a set containing function pointers \( f \) and let \( I \) be a set of syscall inputs. Polymorphism can be described as a mapping \( P \) such that for every \( i \in I \), there exists a function \( f_i \in S \) where \( P(i) = f_i \). The function \( f_i \) can vary based on the type or value of \( i \), thus enabling different syscall behaviors: \( P: I \to S \).

Due to the nearly 4,200 syscall variants in the open-source operating system Linux \cite{Syzkaller}, ignoring polymorphism can easily lead to the problem where test inputs fail to reach the expected code paths \cite{jeong2019razzer,schumilo2017kafl}. Some kernel fuzzers \cite{pailoor2018moonshine,han2017imf,2017DIFUZE} only extract function entry information through static analysis; however, this method encounters challenges in precise data flow analysis of deep code due to numerous indirect calls, linked list operations, nested data structures, and multi-level pointer dereferencing. 

To address this issue, HFL \cite{kim2020hfl} uses inter-procedural data flow analysis and static points-to analysis to determine which index variables of function pointer tables originate from syscall arguments. Based on this, HFL implements an offline converter that expands the calls of function pointer tables into explicit conditional branches. Finally, HFL employs symbolic execution engine , S2E \cite{Chipounov2011S2EAP}, on the converted explicit conditional branch paths to explore the syscalls and argument values that trigger the target functions. However, this method may lead to path explosion issues due to kernel uncertainties (such as symbolic execution needing to consider all possibilities in the function pointer table). Additionally, function pointer tables may be dynamically registered during kernel module initialization, dynamic configuration by other syscalls, and device hot-swapping (\eg different protocols like TCP can register specific operations at various times), making static analysis unable to capture all control flow paths completely. To address the issue of dynamic registration, KSG leverages eBPF \cite{eBPF} and Kprobe \cite{Kprobe} to dynamically hook multiple probes before and after specific kernel functions. By scanning device files and network protocols, KSG triggers the execution of hooked kernel functions to extract the syscall entry points of triggered submodules. This method introduces additional runtime overhead, especially when handling a large number of syscalls and frequent dynamic registrations. Moreover, since KSG relies on runtime behavior, it may miss some unregistered function pointers, resulting in incomplete analysis. Another more precise method, Syzdirect \cite{tan2023syzdirect}, focuses on using static analysis to identify and locate anchor functions to reduce the substantial overhead of modeling all functions and combines the state-of-the-art type-based indirect call analysis \cite{Lu2019WhereDI} to trace indirect call chains to determine syscall variants and arguments. Unlike KSG, Syzdirect directly uses PoC as input (including the target kernel functions and corresponding syscall variants) to evaluate the reproduction and triggering conditions of specific code locations. Therefore, this method is characterized by a lower false positive rate but has weaker generalizability.

  \begin{figure*}[!t]
    \centering
    \subfigure[An example presenting argument type casting at linux/net/ipv4/ip\_sockglue.c.]{
      \includegraphics[width=0.47\linewidth]{img/arg_type.pdf}\label{img:arg_type}}
    \hspace{5pt}\vline\hspace{5pt}
    \subfigure[An example presenting nested argument copying at linux/drivers/usb/core/devio.c.]{
        \includegraphics[width=0.47\textwidth]{img/arg_nested.pdf}\label{img:arg_nested}}
    \caption{An example presenting type casting and nested structure copying. The red line indicates the name of target function, the green line represents the argument that determines the conditional branching. The blue line in (a) involves type casting, while the blue line in (b) also includes nested structure copying.}
  \end{figure*}

\subsubsection{Argument inference.}

In kernel fuzzing, the inference of syscall argument types and structures can be crucial. If these inferences are inaccurate, the generated syscall arguments are probable to be invalid, consequently failing to fuzz the expected execution paths. In particular, argument inference involves two primary tasks: argument type inference and nested structure inference.

\textbf{Argument type casting} tends to make it hard for analysts to determine the type of arguments due to variable alias passing issues. Figure \ref{img:arg_type} shows the kernel API \texttt{do\_ip\_setsockopt} for syscall \texttt{setsockopt}, where \texttt{optname} determines the conditional branch (switch-case) to be executed, and the type of \texttt{optval} varies with the values of \texttt{optname} and \texttt{optlen}. For example, when \texttt{optname=IP\_OPTIONS}, \texttt{optval} is a pointer to structure \texttt{ip\_options\_rcu}. For this problem, the analyst needs to generate an appropriate value for the syscall's argument based on the code execution path, otherwise the execution of the fuzzing program will be blocked due to a failed type casting. To address this issue, KSG \cite{sun2022ksg} utilizes the symbolic execution of the Clang Static Analyzer (CSA) to perform path-sensitive analysis on the target function to check for the presence of type casting operations on the arguments (scalar-to-pointer and pointer-to-pointer casting). Also, a global mapping table is constructed for symbols and memory regions, which solves the problem that type casting is difficult to inference due to alias propagation. On the other hand, KernelGPT \cite{yang2023kernelgpt} utilizes GPT4 and designs a complete prompt chain to automatically infer the unknown types of ioctl's arguments and the specific values of the \texttt{cmd} arguments. However, the problem of nested structure pointer inference is not solved from these fuzzers. Also, such approaches are limited to the simple case of argument type inference for ioctl syscalls, which is insufficient to address complex scenarios where there is a complex chain of indirect calls from syscall to kernel source code.

\textbf{A nested structure} refers to a structure whose field members point to another structure that is dynamically allocated and initialized at runtime. As shown in Figure \ref{img:arg_type}, the \texttt{proc\_submiturb} function is triggered by the function \texttt{usbdev\_ioctl} derived from syscall \texttt{ioctl}, and is used to copy the user-space address \texttt{arg} into the nested structure. Such nested structures are usually frequent in special kernel APIs like \texttt{copy\_from\_user} and \texttt{copy\_to\_user} that are used for memory address copying, and traditional fuzzing have a hard time inferring such complex argument format due to dynamic allocation of addresses in such cases. Similarly, symbolic execution is based only on static analysis and explicitly symbolized input space; it cannot predict and handle dynamic memory regions pointed to by nested pointers. In order to accurately trace the memory operations of nested structure pointers, HFL \cite{kim2020hfl} specifically instruments the \texttt{copy\_from\_user} and \texttt{copy\_to\_user} functions and captures their arguments and return values (\ie the addresses and sizes of the source and target buffers). Additionally, the intercepted arguments are labeled as symbolic variables, and the buffer addresses of the nested structures as well as the data lengths are inferred using concolic execution. It is worth noting that these approaches focusing on argument inference typically rely on static analysis, symbolic execution methods to trace the propagation paths of arguments to constrain syscall and its arguments mutations, and rely specifically on handwritten work in syzlang, but these approaches cover limited syscall and requires a lot of manual work.

\todo{To address this problem}, a state-of-the-art approach, FUZZNG \cite{bulekov2023FUZZNG}, performs checksum corrections on mutated syscalls to ensure the validity of the syscall sequence. Specifically, FUZZNG developed a kernel module mod-NG that hooks the kernel's APIs related to handling file descriptor allocation and pointer arguments to reshape the input space of syscalls. For file descriptors, mod-NG hooks the kernel's \texttt{alloc\_fd} API, which is used to allocate new file descriptors, and the \texttt{fdget} API, which is used to retrieve file objects via file descriptors. By intercepting these APIs, mod-NG maps invalid file descriptors generated by mutations to existing file objects within the kernel. For pointer parameters, mod-NG hooks the \texttt{copy\_from\_user} function, allowing the kernel to populate the structure pointed to by the pointer into a valid user-space memory region when accessing user-space memory. Through this approach, FUZZNG reshapes the input space of syscalls, ensuring that even if the mutated syscall arguments are invalid, they can still be mapped to valid file objects and memory regions.


\subsection{File System Fuzzing}

File system is one of the basic system services of an operating system. Mainstream file systems in open source OS include: ext4 \cite{Cao2007Ext4TN}, XFS \cite{XFS2018}, Brtfs \cite{Rodeh2013BTRFSTL} and F2FS \cite{Lee2015F2FSAN}. The special issues considered during file system fuzzing differ from kernel fuzzing, and this difference is reflected in three dimensions: input type, status, and specific bugs in the file system. Therefore, through insights into the file system fuzzing process, we review and summarize the evolution of methods for these 3 types of problems in Table \ref{tab_filesystem}.

\subsubsection{Input type}
File system fuzzers can be categorized into syscall- and syscall+metadata-based according to input type. In modern operating systems, file systems are mounted to the kernel as files. \todo{Therefore, file system fuzzer can fuzz file system-related source code in the kernel by generating only syscall sequences that specialize in operating on files (\eg Syzkaller \cite{Syzkaller}, KAFL \cite{schumilo2017kafl} Krace \cite{xu2020krace}, CONZZER \cite{CONZZER2022context}).} Unfortunately, using a single syscall sequence as input for a file system fuzzer has its disvantages. First, it can lose the runtime state of the file system, making subsequent file operations contextually irrelevant and incurring the fuzzing experiment ineffective (\eg repeatedly issuing \texttt{read()} or \texttt{unlink()} operations on files that have been performed \texttt{rename()}). \todo{Second, only mutating the metadata effectively triggers the code responsible for handling file-related operations in the file system. Using syscalls as the sole test input generally alters user data, which is irrelevant to the testing process and thus ineffective. Furthermore, metadata accounts for only about 1\% of the entire file system image \cite{JANUS2019fuzzing}, meaning that mutation operations based solely on syscalls are likely to be mostly ineffective. To address this problem, another approaches, such as, JANUS \cite{JANUS2019fuzzing}, Hydra \cite{Hydra2020finding}, Lfuzz \cite{Liu2023LFuzz}, are to use the file system image and the syscalls operating on this image simultaneously as inputs, applying appropriate mutators to update them for continuous context-aware file system fuzzing.}

%Secondly, typically only metadata affects file system operations, while user data is useless. Furthermore, metadata only accounts for about 1\% of the whole file system image \cite{JANUS2019fuzzing}. This means that most mutation operations on the input during fuzz testing may be ineffective. Another approaches, such as, JANUS \cite{JANUS2019fuzzing}, Hydra \cite{Hydra2020finding}, Lfuzz \cite{Liu2023LFuzz}, are to use the file system image and the syscalls operating on this image simultaneously as inputs, applying appropriate mutators to update them for continuous context-aware file system fuzzing.

\subsubsection{Status} The status of a file system typically refers to the values of its metadata, such as file open status, file paths, and file byte lengths. Traditional fuzzers focus only on the initial status of the metadata, making it difficult to reach deeper region of the code under test. Therefore, effective file system fuzzing generally maintains the intermediate status of the metadata throughout the fuzzing process. This approach is able to generated seeds with contextual information, enabling them to explore deeper code regions more effectively. JANUS \cite{JANUS2019fuzzing} is the first file system fuzzer to correlate status with file operations. By constructing multiple structures to maintain the intermediate status of metadata, it can independently mutate syscall sequence and the metadata extracted from file system image, thereby generating context-aware hybrid seeds. \todo{However, since this approach performs random mutations only on a clustered and localized metadata region, the fuzzing process is constrained to a limited area of the image. Moreover, this localized operation hotspot reduces the value of saving and restoring image states, leading to significant performance and storage overhead.} Lfuzz \cite{Liu2023LFuzz} builds on the JANUS framework but maintains a location tracking table that records the accessed image locations and their vicinity over a period. This approach reduces the search space by up to 8 times compared to JANUS, significantly enhancing performance.

\todo{Unlike JANUS and Lfuzz, Hydra \cite{Hydra2020finding} focuses on addressing the issues of fuzzing inefficiency and non-reproducible bugs caused by the accumulation of non-continuous status. Conceptually, metadata represents the status of the initial image, and when new syscalls are frequently used to significantly alter the image status, status fragmentation occurs. This means that mutations targeting metadata have a diminishing effect on file operations, thereby reducing the overall fuzzing efficiency. For example, syscalls that operate on files, such as \texttt{open} and \texttt{write}, can change file permissions and locations, thereby altering or negating the image status determined by the metadata. To address the inefficiencies caused by state accumulation and the issue of non-reproducible bugs, Hydra implements several key strategies. First, it uses a Library OS-based executor to create a fresh execution instance for each test case, allowing for quick initialization of both the file system and kernel logic. This ensures that every test case runs in a clean status. Second, Hydra prioritizes mutating metadata to maintain the continuity of the image status. Lastly, Hydra focuses on mutating existing syscalls rather than prematurely introducing new ones, preventing an excessively large mutation space while maintaining control over the current image status.}

%However, since the metadata locations within the file system are concentrated and localized, JANUS incurs high performance and storage overheads by frequently saving and restoring the entire file system image each time it randomly flips bits in the metadata. Lfuzz \cite{Liu2023LFuzz} builds on the JANUS framework but maintains a location tracking table that records the accessed image locations and their vicinity over a period. This approach reduces the search space by up to 8 times compared to JANUS, significantly enhancing performance.

\begin{table}
    \centering
    \footnotesize % 减小字体大小
    \caption{File System Fuzzers Sorted by Publication Year.}
    \label{tab_filesystem}
    \vspace{-0.3cm}
    \begin{tabular}{ccccc}
    \toprule
    \multicolumn{1}{m{2cm}}{\centering Fuzzers} &  % 中间的1.5cm表示第列宽度
    \multicolumn{1}{m{4cm}}{\centering File System} &
    \multicolumn{1}{m{3cm}}{\centering Input Type} &
    \multicolumn{1}{m{0.5cm}}{\centering Status} &
    \multicolumn{1}{m{1.8cm}}{\centering Specific Bugs} \\
    %Fuzzers & File System & Input Type & Status \\
    \midrule
    Syzkaller\cite{Syzkaller} & ext4, Btrfs, F2FS, jfs, xfs, reiserFS & syscall & $\times$ & C.\\
    KAFL\cite{schumilo2017kafl} & ext4 & syscall & $\times$ & -\\
    JANUS\cite{JANUS2019fuzzing} & ext4, Btrfs, F2FS& syscall+image & \checkmark & L.\\
    Krace\cite{xu2020krace} & ext4, Btrfs & syscall & $\times$ & C.\\
    Hydra\cite{Hydra2020finding} & ext4, Btrfs, F2FS & syscall+image & \checkmark & I.,S.,C.,L.\\
    CONZZER\cite{CONZZER2022context} & Btrfs, jfs, xfs, reiserFS & syscall & $\times$ & C.\\
    Lfuzz\cite{Liu2023LFuzz} & ext4, Btrfs, F2FS & syscall+image & \checkmark & L.\\
    \bottomrule
    \end{tabular}
    \begin{flushleft}
      \justifying % 使脚注文字左右对齐
      A ``-'' means it is irrelevant, not mentioned, or unclear in detail. \todo{\textbf{Abbreviation}: \textbf{I.}: Crash Inconsistency. \textbf{S.}: Specification Violation. \textbf{C.}: Concurrency Bug. \textbf{L.}: Logic Bug.}
      \end{flushleft}
\end{table}

\subsubsection{Specific bugs}
\todo{Compared to other OS Layers, bugs in the file system are characterized by diversity and specificity \cite{Lu2013ASO}.} In addition to mainstream memory violation errors, bugs specific to file systems include crash inconsistency, concurrency bug, and logic bug due to their intrinsic data persistence and concurrency characteristics. Section \ref{Vulnerability} summarizes the types of vulnerabilities and the corresponding monitors, hence, we only examine the vulnerabilities related to file system and the possible impact.
%An approximate 40\% of patches in file systems are fixes for various bugs, which reflects the diversity and specificity of bugs in file systems \cite{Lu2013ASO}. In addition to mainstream memory violation errors, bugs specific to file systems include crash inconsistency, concurrency bug, and logic bug due to their intrinsic data persistence and concurrency characteristics. Section \ref{Vulnerability} summarizes the types of vulnerabilities and the corresponding monitors, hence, we only examine the vulnerabilities related to file system and the possible impact.

\textbf{Crash inconsistency} is the most typical vulnerability of file system, which refers to the situation when the state of the file system is not as expected after handling a crash (\eg a sudden power failure). This is typically due to the file system not correctly managing its metadata when writing, updating, or deleting data leading to catastrophic consequences: permanent loss or corruption of files. For example, using \texttt{pwrite64()} on a file does not persistently modify the length of the file. \todo{\textbf{Specification violation} is also common bug in file system. This type of bug occurs when the file system violates the standards or specifications it is supposed to follow during operations. For example, file system operations are expected to adhere to specific standards, such as the POSIX standard or Linux man pages, which define the allowed behaviors and error codes for file operations. For instance, the POSIX standard specifies that when executing the \texttt{unlink} syscall, the only permissible error code is \texttt{EPERM}, yet some implementations return \texttt{EISDIR}, which constitutes a violation of the POSIX standard \cite{Hydra2020finding}. However, such errors are not specifically addressed by existing file system fuzzers. The reason is that triggering these violations is unlikely to cause kernel panics or crashes. Furthermore, the test cases and bug monitor tools are not designed to target such bugs, meaning that file system fuzzers, from their initial design, have overlooked the opportunity to capture specification violation bugs.} Another category of vulnerabilities is \textbf{concurrency bug}. Although these bugs are not specific to file systems, modern file systems, which inherently involve shared data regions, also introduce a series of programming paradigms to leverage multi-core computing \cite{fstests}. These paradigms, such as read-copy-update (RCU) and asynchronous work queues, improve performance but significantly increase the likelihood of writing concurrent error-prone code. Furthermore, unlike other types of bugs, file system-specific \textbf{logic bug} do not adhere to any general pattern for definition (\eg F2FS requires its own concept of rb-tree consistency \cite{Hydra2020finding}). As discussed in Section \ref{Vulnerability}, logic bugs do not cause immediate crashes but can lead to undefined behavior over time, affecting both performance and reliability.

\subsection{Driver Fuzzing}
Since drivers interact directly with hardware and are the most extensive subsystem in the kernel, they possess several unique fuzzing characteristics. \todo{Table \ref{tab_driver} demonstrates these three characteristics}, first, they expose an additional hardware-side attack surface compared to the kernel and file systems, making it clear that syscalls alone are insufficient to uncover hardware-related vulnerabilities. Second, the validation chains in drivers increase the complexity of fuzzing. Furthermore, driver fuzzing has a stronger demand for device-free (\ie scalability) because previous work assumed that each driver under test had an actual hardware peripheral \cite{Song2019PeriScopeAE,Talebi2018CharmFD}, which limited the testing scope of driver fuzzers.


\subsubsection{Input type}
\todo{As a subsystem of the kernel, a driver fuzzer can also test drivers by fuzzing syscalls. For example, in Linux, each file under the /dev directory represents a hardware device. User-space applications can obtain a file descriptor for a device and interact with it using syscalls such as \texttt{read}, \texttt{write}, or \texttt{ioctl} to perform specific hardware operations. Existing works, such as usb-fuzzer \cite{Syzkaller} (the driver fuzzing module of Syzkaller), DIFUZE \cite{2017DIFUZE}, BSOD \cite{maier2021bsod}, StateFuzz \cite{zhao2022statefuzz}, SyzDescribe \cite{hao2023syzdescribe} SATURN \cite{Xu2024Saturn}, and Syzgen++ \cite{Chen2024SyzGen++}, are all based on Syzkaller to generate syscall sequences that interact with drivers, successfully achieving driver fuzzing. Notably, syscall-based driver fuzzers face inherent challenges related to complex argument structures and manually constructing domain-specific languages (DSLs). For instance, usb-fuzzer injects random data into the USB stack via syscalls to test USB drivers. DIFUZE uses static analysis to extract correct type and argument structure information from driver interfaces, helping to generate valid test cases. BSOD developed a virtual device, BSOD-fakedev, to record interactions (commands and data) between the graphics card and its driver and generates test cases that reproduce these interactions using AFL++ and Syzkaller, alleviating the difficulty of manually building a DSL. StateFuzz introduces a novel driver state feedback mechanism that guides Syzkaller in generating state-continuous test cases, addressing the shortcomings of Syzlang syntax and the code coverage feedback mechanism in state awareness. This significantly enhances the depth and effectiveness of Syzkaller in driver fuzzing. SyzDescribe combines static analysis to automatically generate Syzlang for newly merged driver code in the Linux mainline.} \todo{Another syscall-based driver fuzzer, Ex-vivo \cite{Pustogarov2020ExvivoDA}, uses AFL to generate arguments for the \texttt{ioctl} syscall, rather than Syzkaller. The reason is that Syzkaller typically requires a custom kernel for fuzzing, but many Android devices can only boot signed kernels (AFL only generates test cases without modifying the kernel). In other words, Syzkaller collects runtime information by customizing the kernel, which invalidates the kernel signature. As a result, Syzkaller becomes difficult to use for driver fuzzing on mobile devices.}

%\todo{Historically, hardware has often been regarded as trustworthy and difficult to tamper with, which led to its attack surface being overlooked during testing. Another key challenge is that drivers typically rely on real physical devices for operation, and the ``hardware-in-the-loop'' testing approach limits flexibility. To address these issues, early efforts utilized specialized programmable hardware devices (such as FaceDancer \cite{FaceDancer}) to simulate physical devices and create a closed testing loop. However, these devices are expensive, lack scalability (as they can only fuzz a limited number of drivers associated with specific hardware at a time), and depend on physical actions (such as manually connecting and disconnecting devices) to trigger tests.} These limitations have resulted in hardware-related testing being insufficiently covered and prioritized in fuzzing efforts. For example, the kernel fuzzer syzkaller \cite{Syzkaller} includes a usb-fuzzer extension, which injects random data into the USB stack through extended syscalls. DIFUZE \cite{2017DIFUZE} employs static analysis to extract supported request types and related parameters from custom interfaces in device drivers. This method was widely adopted early on due to its simplicity and ease of use. However, the complexity and variety of syscall parameters not only limit the fuzzer's flexibility but also make it challenging to detect driver vulnerabilities caused by device behavior.

\todo{While existing driver fuzzers have created a closed-loop testing approach via syscalls, it is insufficient to consider syscalls as the sole entry point for testing. This approach implies an assumption that driver fuzzing is similar to kernel fuzzing, where comprehensive fuzzing can be achieved through syscalls alone. However, this assumption overlooks the complexity and potential vulnerabilities in hardware-related code, resulting in inadequate coverage and attention to hardware-level vulnerabilities \cite{peng2020usbfuzz}.} Therefore, another fuzzing interface involves injecting malicious inputs from the hardware side through device configuration or I/O channels such as Port I/O, MMIO, and DMA. USBFuzz \cite{peng2020usbfuzz} uses a simulated USB device to match with kernel drivers and injects malicious USB descriptors. \todo{Fuzzers such as \cite{Song2019PeriScopeAE,song2020agamotto,zhao2022semantic,ma2022printfuzz,shen2022drifuzz,wu2023devfuzz,Jang2023ReUSB, Huster2024ToBoldly} intercept the I/O access of target devices (including the target address and data content). After mutating the I/O data, the fuzzer resends the mutated data to the corresponding I/O channels (such as MMIO, PIO, or DMA).} This approach enhances the flexibility of driver fuzzers and improves their ability to discover hardware-related vulnerabilities, such as those associated with hardware initialization, interrupt handling, direct DMA operations, and hardware error handling. It is worth noting that this approach has the requirement of verifying the difference between the simulated behavior and the behavior of the real hardware, as well as the need for an in-depth understanding of the communication protocols.

\begin{table} % 表格开始
    \centering % 表格居中显示
    \scriptsize % 减小字体大小
    \caption{Driver Fuzzers Sorted by Publication Year.} % 表头标题
    \label{tab_driver} % 表格标签，便于引用
    \vspace{-0.3cm}
    
    \begin{tabular}{ccccc} % c表示单元格内容居中，l表示靠左，这里有两列，所以cc，如果是三列就是ccc或cll，根据自己
    
    \toprule % 顶部的线，这里可以定义粗细、toprule{1.5ptx}
    \multicolumn{1}{m{2cm}}{\centering Fuzzers} &  % 中间的1.5cm表示第列宽度
    \multicolumn{1}{m{3.5cm}}{\centering Device Type} &
    \multicolumn{1}{m{2cm}}{\centering Input Type} &
    \multicolumn{1}{m{2cm}}{\centering Stage} &
    \multicolumn{1}{m{1.5cm}}{\centering Device-Free}\\
    
    \midrule % 中间的线
    % \midrule
    \multirow{1}*{usb-fuzzer\cite{Syzkaller}} & USB & syscall & 3 & $\checkmark$  \\

    % \midrule
    \multirow{1}*{DIFUZE\cite{2017DIFUZE}} & PCI/USB/I2C/Others & syscall & 3 & $\times$  \\

    % \midrule
    \multirow{1}*{Periscope\cite{Song2019PeriScopeAE}} & PCI/USB/I2C/Others & I/O & 3 & $\times$  \\

    % \midrule
    \multirow{1}*{USBFuzz\cite{peng2020usbfuzz}} & USB & device configuration & 3 & $\checkmark$ \\

    % \midrule
    \multirow{1}*{Agamotto\cite{song2020agamotto}} & PCI/USB & syscall+I/O & 3 & $\times$ \\

    % \midrule
    \multirow{1}*{Ex-vivo\cite{Pustogarov2020ExvivoDA}} & PCI/USB/I2C/Others & syscall & 3 & $\checkmark$ \\

    % \midrule
    \multirow{1}*{BSOD\cite{maier2021bsod}} & PCI & syscall & 3 & $\times$ \\

    % \midrule
    \multirow{1}*{StateFuzz\cite{zhao2022statefuzz}} & others & syscall & 3 & $\times$ \\

    % \midrule
    \multirow{1}*{Dr.Fuzz\cite{zhao2022semantic}} & PCI/USB/I2C/Others & I/O & 1, 2, 3 & $\checkmark$ \\

    % \midrule
    \multirow{1}*{PrintFuzz\cite{ma2022printfuzz}} & PCI/USB/I2C/Others & syscall+I/O & 1, 2, 3 & $\checkmark$ \\

    % \midrule
    \multirow{1}*{DriFuzz\cite{shen2022drifuzz}} & PCI/USB & I/O & 1, 2, 3 & $\checkmark$ \\

    % \midrule
    \multirow{1}*{SyzDescribe\cite{hao2023syzdescribe}} & PCI/USB/I2C/Others & syscall & 3 & $\times$ \\

    % \midrule
    \multirow{1}*{DEVFUZZ\cite{wu2023devfuzz}} & PCI/USB/I2C/Others & I/O & 1, 2, 3 & $\checkmark$ \\

    % \midrule
    \multirow{1}*{ReUSB\cite{Jang2023ReUSB}} & USB & syscall+I/O & 1, 2, 3 & $\times$ \\
    
    % \midrule
    \multirow{1}*{SATURN\cite{Xu2024Saturn}} & USB & syscall & 3 & $\checkmark$ \\

    % \midrule
    \multirow{1}*{Syzgen++\cite{Chen2024SyzGen++}} & Others & syscall & 3 & $\times$ \\

    % \midrule
    \multirow{1}*{VIRTFUZZ\cite{Huster2024ToBoldly}} & PCI & I/O & 3 & $\times$ \\
    
    \bottomrule
    \end{tabular}
    \end{table}

\subsubsection{The three-stage of driver fuzzing}
A driver contains a complete sequence of operations. In order to clearly represent the main features of the different stages in driver fuzzing, we categorize the transition of the driver from its initial state to the ready state into three main stages: device enumeration, probe execution, and device communication. The first two stages require enforcing a series of validations on the input, such as checking the chip version number, determining the I/O method used, and verifying the vendor and product IDs. This series of checks is referred to as the validation chain. Therefore, to effectively fuzz the entire driver code, the input must successfully pass through the entire validation chain. Failing to do so results in the generated seeds remaining stuck in the driver's initial stage, severely impairing the fuzzer's performance.

The first stage, device enumeration, refers to the complete process from the operating system detecting a device to binding the corresponding driver. Device detection can only be triggered during the OS boot phase by scanning the bus or through hot-plugging events. To cover the code paths of this stage, DEVFUZZ \cite{wu2023devfuzz} simulates device hot-plugging behavior through run the command-line ``\texttt{echo 1 > /sys/bus/pci}'', thereby repeatedly triggering the device enumeration process. Specifically, for devices on dynamically probed buses (such as PCI/PCIe), DEVFUZZ repeatedly executes the \texttt{echo} command to scan the PCI bus. For devices on buses using static enumeration (such as I2C), a new device is created at a specified I2C bus address, indirectly triggering the system's bus scan operation. It is important to note that the code coverage of this stage might not be directly obtained using the ``kcov'' integrated in the kernel because the driver code is enabled during kernel boot, and ``kcov'' debugfs is not ready for reading at that time. To overcome this issue, Wu et al. and Zhao et al. \cite{zhao2022semantic,wu2023devfuzz} combine Intel PT to trace execution during the boot process.

The second stage, probe execution, verifies whether the test case meets the conditions required for subsequent device initialization. \todo{Thus, this stage contains numerous specialized code segments, such as operations that validate magic values by reading specific registers or perform polling verification. These pose significant challenges to the quality of test cases.} To correctly pass the validation chain, Dr.Fuzz \cite{zhao2022semantic} uses error codes returned by the program as a new feedback mechanism to guide mutations. However, this method's performance might be limited by the large search space. To improve the accuracy of input generation, DEVFUZZ \cite{wu2023devfuzz} employs symbolic execution to build a probe model, symbolizing the identifiers corresponding to the magic values to solve the constraints. Meanwhile, DriFuzz \cite{shen2022drifuzz} employs concolic execution to reduce the path explosion problem that DEVFUZZ \cite{wu2023devfuzz} might encounter when handling polling verification code segments. Additionally, ReUSB \cite{Jang2023ReUSB} high-fidelity record-and-replay syscalls and USB device requests and responses, thereby avoiding the complex symbolic solving tasks during the validation chain process.

Upon successfully passing the validation chain, the process enters the third stage: device communication (also known as post-probing). This stage signifies that the device is in a ready state and primarily involves data transfer between the device and driver through Memory-Mapped I/O (MMIO) and Direct Memory Access (DMA) mechanisms. Syscall-based driver fuzzers \cite{Syzkaller, 2017DIFUZE, Pustogarov2020ExvivoDA, maier2021bsod, zhao2022statefuzz, hao2023syzdescribe, Xu2024Saturn, Chen2024SyzGen++} can trigger communication-related driver code using only syscalls such as \texttt{open}, \texttt{write}, \texttt{close}, and \texttt{ioctl}. For fuzzers that utilize I/O as input, PeriScope \cite{Song2019PeriScopeAE} employs a page-fault-based kernel monitoring mechanism to capture device drivers' access to MMIO and DMA regions. This allows the fuzzer to dynamically intervene in the communication process between the driver and the device, enabling fuzz testing and analysis. DEVFUZZ \cite{wu2023devfuzz} employs static and dynamic program analysis to construct device models for MMIO, Port I/O (PIO), and DMA, thereby generating the fields of the structures. Dr.Fuzz \cite{zhao2022semantic} reduces the number of related data structures and the possible values of their fields by constructing I/O dependency graphs using static analysis, effectively narrowing the I/O input space. In addition, VIRTFUZZ \cite{Huster2024ToBoldly} takes the monitored communication data of real devices interacting with the driver (\eg Bluetooth HCI packets, WLAN frames) as the initial seed and transfers the mutated I/O data to the device driver under test via VirtIO's virtqueue (a highly efficient ring-buffer queue used for data transfer between VMs and hosts) to achieve the communication stage of fuzzing.

\todo{Although syscall-based driver fuzzers can directly focus on the post-probing stage, this approach also means that potential vulnerabilities in the first and second stages cannot be discovered. Therefore, to thoroughly fuzz a driver, it is essential to combine lower-level interaction interfaces (\ie device configuration or I/O channels).}

\subsubsection{Device-free}
\todo{The execution of device drivers typically relies on real physical hardware, a “hardware-in-the-loop” testing approach that, while ensuring high fidelity, significantly limits testing flexibility and increases dependence on hardware resources. According to statistics, the ``\texttt{drivers/}'' directory in Ubuntu Linux 20.04 contains approximately 13 million lines of code, accounting for 64.8\% of the entire Linux source code \cite{wu2023devfuzz}. To address the complexity and cost associated with such testing, a notable characteristic driver fuzzing is the adoption of ``device-free fuzzing,'' where device behaviors are simulated to reduce reliance on physical hardware, thereby lowering costs and improving generalization.} Existing driver fuzzers have implemented device-free testing through emulated hardware abstraction frameworks. For example, the usb-fuzzer in syzkaller uses the DUMMY HCD \cite{DummyHCD}, a virtual USB host controller driver in the Linux kernel, to inject generated data into the USB stack, thereby simulating the behavior of an actual USB host controller. SATURN \cite{Xu2024Saturn} leverages the Linux kernel's Gadget subsystem—a framework enabling device emulation as USB peripherals (\eg virtual printers or keyboards)—to dynamically generate USB-compliant device configurations, including vendor IDs, product IDs, and endpoint descriptors. By dynamically loading/unloading Gadget kernel modules to simulate hot-plug behaviors, SATURN triggers bus rescan operations, thereby eliminating hardware dependencies and achieving comprehensive coverage of device enumeration paths. However, this method is limited to USB bus drivers and fails to trigger vulnerabilities in physical host controller drivers.

%\todo{Driver running typically relies on real physical devices, and this 'hardware-in-the-loop' testing approach limits flexibility. Therefore, a notable feature of driver fuzzing is the strong demand for device-free testing, where device behavior is simulated to reduce reliance on physical hardware, thereby lowering costs and improving generalization.} For instance, in the Linux ecosystem, there are over 13,000 PCI devices, constituting 64.8\% of the entire Linux source code \cite{Syzkaller}. Existing driver fuzzers have implemented device-free testing through various approaches. For example, the usb-fuzzer in syzkaller uses the DUMMY HCD \cite{DummyHCD}, a virtual USB host controller driver in the Linux kernel, to inject generated data into the USB stack, thereby simulating the behavior of an actual USB host controller. However, this method is limited to USB bus drivers and fails to trigger vulnerabilities in physical host controller drivers.

To achieve broader testing across different device drivers, hypervisors like QEMU can be employed to intercept the read/write requests of the target kernel, constructing simulated devices \cite{peng2020usbfuzz}. Although this approach offers readily available virtual devices, reducing the dependence on real hardware, it has limited simulation capabilities, and building simulators for unsupported devices requires extensive manual effort. For instance, QEMU supports fewer than 130 PCI devices \cite{zhao2022semantic}. Additionally, these software-based simulators may generate overly standardized inputs, which are insufficient for triggering vulnerabilities that rely on malformed input \cite{Markettos2019ThunderclapEV}.

\todo{Device emulation follows specific device models. For instance, in the Linux Kernel Device Model (LKDM), the driver must successfully initialize the relevant data structures before running. Once these data structures pass the second-stage validation chain, the fuzzer can manipulate these device structures (such as I/O ports, MMIO regions, \etc) to communicate with the driver (third stage), simulating behavior similar to real hardware. Thus, the key to device-free fuzzing lies in ensuring that the generated inputs mimic the response data of real devices, correctly initializing key device data structures to help the driver pass the validation chain checks. After entering the communication stage, the driver interacts with the device through low-level operations (such as \texttt{in}, \texttt{out}, \texttt{readl}, \texttt{writel}), which still rely on virtualization platforms (\eg QEMU) to intercept and emulate, achieving complete device-free fuzzing. Ex-vivo \cite{Pustogarov2020ExvivoDA} captures the driver’s data structures through memory snapshots, thereby bypassing all validation chain checks and eliminating dependency on the device. It is worth noting that while this approach achieves device-free fuzzing, it is not sufficiently comprehensive in covering the first two stages of testing. Therefore, recent fuzzers such as \cite{zhao2022semantic,ma2022printfuzz,shen2022drifuzz,wu2023devfuzz} achieve device-free fuzzing by extracting the intrinsic semantic information of drivers (\eg error codes) or employing program analysis techniques to infer device structures and simulate device behavior, enabling device-free fuzzing.}

%\todo{As a result, recent fuzzers such as \cite{zhao2022semantic,ma2022printfuzz,shen2022drifuzz,wu2023devfuzz} achieve device-free fuzzing by extracting the intrinsic semantic information of drivers (\eg error codes) or employing program analysis techniques to infer and simulate device input data in a 'reverse engineering' manner.}

%As a result, recent fuzzers such as \cite{zhao2022semantic,ma2022printfuzz,shen2022drifuzz,wu2023devfuzz} have leveraged intrinsic semantic information within drivers (\eg error codes) to guide seed generation or have utilized sophisticated program analysis techniques to model the driver workflow, particularly the verification chain, to enable device-free testing. However, it is undeniable that these approaches also introduce greater complexity.

\subsection{Hypervisor Fuzzing}
Hypervisors implement multi-domain deployment and resource isolation through emulated virtual devices, which are a major source of vulnerabilities \cite{CVE-2014-2894,CVE-2015-3456,CVE-2015-5279,CVE-2015-6855} and thus receive more attention in hypervisor testing activities \cite{QTest,Cong2013SymbolicEO}. \todo{Compared to the other OS layers, hypervisors have more attack surfaces and the details of implementing fuzzing for these interfaces are more complex.} Therefore, in addition to focusing on these attack surfaces, it is crucial to consider how to effectively conduct fuzzing using these interfaces. As shown in Table \ref{tab_hypervisor}, we summarize the input types and methodologies used by existing hypervisor fuzzers, as well as the hypervisors they have been tested on.

% \begin{table} % 表格开始
%     \centering % 表格居中显示
%     \footnotesize
%     \caption{Hypervisor Fuzzers.} % 表头标题
%     \label{tab4} % 表格标签，便于引用
    
%     \begin{tabular}{cccc} % c表示单元格内容居中，l表示靠左，这里有两列，所以cc，如果是三列就是ccc或cll，根据自己
    
%     \toprule % 顶部的线，这里可以定义粗细、toprule{1.5ptx}
%     \multicolumn{1}{m{2cm}}{\centering Fuzzers} &  % 中间的1.5cm表示第列宽度
%     \multicolumn{1}{m{2cm}}{\centering Hypervisor} &
%     \multicolumn{1}{m{2cm}}{\centering Interface} &
%     \multicolumn{1}{m{4cm}}{\centering How} \\
    
%     \midrule % 中间的线
%     \multirow{1}*{VDF\cite{henderson2017vdf}} & QEMU & PIO, MMIO & Qtest \\

%     \midrule
%     \multirow{1}*{Hyper-Cube\cite{schumilo2020hyper}} & QEMU, Bhyve, ACRN, VirtualBox, Vmware Fusion & PIO, MMIO, DMA, Hypercall, Instruction & Bytecode translation \\

%     \midrule
%     \multirow{1}*{NYX\cite{schumilo2021nyx}} & QEMU, Bhyve & PIO, MMIO, DMA, Hypercall, Instruction & Bytecode translation\\

%     \midrule
%     \multirow{1}*{V-Shuttle\cite{pan2021V-shuttle}} & QEMU, Virtual Box & DNA & Interception and Redirection\\

%     \midrule
%     \multirow{1}*{MundoFuzz\cite{myung2022mundofuzz}}  & QEMU, Bhyve & PIO, MMIO, DNA & Interception and Redirection\\

%     \midrule
%     \multirow{1}*{Morphuzz\cite{bulekov2022morphuzz}} & QEMU, Bhyve & PIO, MMIO, DNA & Qtest\\

%     \midrule
%     \multirow{1}*{IRIS\cite{cesarano2023iris}}  & Xen & Instruction & Interception and Redirection\\

%     \midrule
%     \multirow{1}*{VD-Guard\cite{Liu2023VDGuard}}  & QEMU, VirtualBox & PIO, MMIO, DNA & Bytecode translation\\
    
%     \bottomrule
%     \end{tabular}
%     \end{table}

\begin{table}
    \centering
    \scriptsize % 减小字体大小
    \caption{Hypervisor Fuzzers Sorted by Publication Year.}
    \label{tab_hypervisor}
    \vspace{-0.3cm}
    \begin{tabular}{cccc}
    \toprule
    Fuzzers & Hypervisor & Input Type & Input Method \\
    \midrule
    VDF\cite{henderson2017vdf} & QEMU & PIO, MMIO & Qtest \\
    Hyper-Cube\cite{schumilo2020hyper} & \makecell{QEMU, Bhyve, ACRN, \\ VirtualBox, Vmware Fusion} & PIO, MMIO, DMA, Hypercall, Instruction & Bytecode translation \\
    NYX\cite{schumilo2021nyx} & QEMU, Bhyve & PIO, MMIO, DMA, Hypercall, Instruction & Bytecode translation \\
    V-Shuttle\cite{pan2021V-shuttle} & QEMU, Virtual Box & DMA & Interception and Redirection \\
    MundoFuzz\cite{myung2022mundofuzz} & QEMU, Bhyve & PIO, MMIO, DMA & Interception and Redirection \\
    Morphuzz\cite{bulekov2022morphuzz} & QEMU, Bhyve & PIO, MMIO, DMA & Qtest \\
    IRIS\cite{cesarano2023iris} & Xen & Instruction & Interception and Redirection \\
    VD-Guard\cite{Liu2023VDGuard} & QEMU, VirtualBox & PIO, MMIO, DMA & Bytecode translation \\
    ViDeZZo\cite{Liu2023ViDeZZoDV} & QEMU, VirtualBox & PIO, MMIO, DMA & Interception and Redirection\\
    HYPERPILL\cite{Bulekov2024HYPERPILLFF} & QEMU & PIO, MMIO, DMA, Hypercall & Bytecode translation\\
    \bottomrule
    \end{tabular}
\end{table}



\subsubsection{Input type}
Unlike the other OS layers, hypervisor fuzzing requires interacting with multiple interfaces. Schumilo et al. \cite{schumilo2020hyper} identified the attack surfaces of hypervisors, including Port I/O, MMIO, DMA, hypercalls, and privileged instructions. Port I/O, MMIO, and DMA are primarily concerned with fuzzing virtual devices related to PCI/PCIe, ISA, and other bus interfaces. For instance, VDF \cite{henderson2017vdf} uses a recording and playback approach to focus specifically on MMIO-related activities. \todo{Hypercalls are specially designed interfaces that allows virtual machines to actively communicate with the hypervisor.} \todo{Similar to how a syscall allows a switch from user mode to kernel mode, a hypercall enables the guest operating system (guest OS) in a virtual machine to trigger a VM-exit. VM-exit is a virtualization mechanism that temporarily transfers control from the virtual machine to the hypervisor, ensuring that the virtual machine cannot directly access or modify the host's resources. After handling the operations triggered by the hypercall, the hypervisor returns control back to the virtual machine.} For example, the \texttt{vmcall} instruction in Intel VT-x is used to write the hypervisor's processing results back to the guest's memory. Privileged instructions refer to commands used for hardware resource management, such as accessing and modifying control registers, managing memory paging, and configuring interrupt controllers. For example, \todo{testers can use the \texttt{MOV CR3} instruction to trigger the hypervisor’s interception and emulation of the memory paging mechanism.} \todo{The difference between hypercalls and privileged instructions lies in their roles: hypercalls handle tasks related to virtualization (\eg the hypervisor creating and attaching a virtual network interface to a virtual machine), while privileged instructions involve more fundamental hardware operations (\eg modifying registers). Specifically, when privileged instructions are issued, the virtual machine is unaware that it is operating in a virtualized environment, and control over hardware is passively handed to the hypervisor for emulation before being mapped back to the virtualized environment. To improve hypervisor performance, developers aim to avoid running complex hypervisor emulation for tasks that do not involve low-level hardware operations. Hence, hypercalls were introduced to the hypervisor, allowing the virtual machine to recognize its virtualized environment and proactively request the hypervisor to perform virtualization-related tasks, thereby avoiding complex hardware emulation. It is worth noting that while hypercalls improve the performance of virtualization in the hypervisor, this does not imply that testing should focus solely on hypercall interfaces. On the contrary, the broader attack surface requires testers to consider the tasks associated with different interfaces within the hypervisor and effectively organize fuzzing efforts to ensure comprehensive testing.}



%Hypercalls are specialized software interrupts designed to enhance virtualization performance. Similar to how syscalls switch from userspace to kernel, hypercalls enable the guest OS to trigger a VM-exit, which directly transitions control to the hypervisor. For example, the \texttt{vmcall} instruction in Intel VT-x is used to write the hypervisor's processing results back to the guest's memory. Privileged instructions refer to commands used for hardware resource management, such as accessing and modifying control registers, managing memory paging, and configuring interrupt controllers. For example, a hypervisor might intercept and emulate high-privilege instructions like \texttt{MOV CR3}.

\subsubsection{Input method}
We summarize that existing fuzzers exploit the attack surface exposed by the hypervisor for fuzzing activities mainly through Qtest, bytecode translation, interception and redirection techniques.

\textbf{Qtest} is a lightweight framework provided by QEMU for testing virtual devices. With Qtest, testers can conveniently perform memory I/O read and write operations using APIs, bypassing the need to rely on combined CPU instructions. This means that Qtest allows direct interaction with virtual devices without depending on CPU instructions such as \texttt{inb \%Port\_Number} or \texttt{movl \%MMIO\_Address, value} \cite{bulekov2022morphuzz}. 

Based on this, \todo{fuzzing engine} can be automated by controlling Qtest to test the handling of virtual devices. For instance, VDF \cite{henderson2017vdf} records each MMIO operation's type, base offset, and the content of the data read or written, and it uses a custom Qtest API to replay mutated MMIO operations. However, this approach is limited to MMIO-related I/O activities and overlooks more frequent virtual device I/O operations testing, \ie DMA. This limitation arises because the location of the DMA buffer is dynamic and can be anywhere within the guest memory. Additionally, when the CPU accesses these buffers, the hypervisor does not proactively capture these accesses. 

\sloppy
To address this issue, Morphuzz \cite{bulekov2022morphuzz} intercepts guest-issued DMA operations by hooking into the DMA-access API provided by the hypervisor. Specifically, Morphuzz uses Qtest to send PIO/MMIO instructions generated by libfuzzer to the virtual device, which may trigger consecutive DMA operations. By intercepting the DMA access API, Morphuzz can intervene in the hypervisor's DMA access and inject specific patterns (\eg pointer rings with multiple unique addresses) into the corresponding guest memory regions to facilitate the fuzzing process. It is also worth mentioning that Morphuzz manually implemented a Qtest-like testing framework to perform fuzzing on the hypervisor Bhyve. 
However, it is important to note that this type of Qtest-based fuzzer is only applicable to QEMU and cannot be used for fuzzing different hypervisors. More critically, without carefully designing complex DMA data structures, the exploration of DMA-related testing remains limited.

\textbf{Bytecode translation} refers to a method where I/O request types are represented by predefined opcodes composed of different byte lengths. An interpreter then translates this bytecode into a compilable and executable program, hypercall, or privileged instruction. Additionally, this approach requires the fuzzer to provide an Agent OS to execute these specific I/O requests. Representative works in this domain include Hyper-Cube \cite{schumilo2020hyper} and NYX \cite{schumilo2021nyx} (a successor to Hyper-Cube). Hyper-Cube leveraged this technique to fuzz various attack surfaces, but it is considered a blind fuzzer, \todo{as the randomly generated bytecode leads to violations of resource usage protocols (such as variable states and function call timing relationships). NYX addresses this issue by leveraging affine types (a type system where variables can be used only once, or at most once, helping to prevent certain types of errors like double-free or double-close). NYX implements its own compiler and interpreter, which ultimately generates executable programs that perform I/O requests on the agent OS.} In addition, in order to prevent the potential for address errors caused by the previous use of static translation, VD-Guard \cite{Liu2023VDGuard} examines the current memory layout during translation via QEMU to obtain the memory region index corresponding to the target memory address. \todo{HYPERPILL~\cite{Bulekov2024HYPERPILLFF} first injects PRNG-generated values into relevant registers to trigger hypercalls, then utilizes runtime feedback to identify values that significantly affect the hypercall execution path. By further refining these critical inputs, HYPERPILL effectively avoids unexpected errors caused by invalid data.} This bytecode translation approach is not tied to any specific hypervisor platform, offering greater flexibility. However, it also introduces higher complexity, especially since manually written specifications are prone to errors, potentially limiting the effectiveness of the fuzzing process.

%HYPERPILL~\cite{Bulekov2024HYPERPILLFF} first injects PRNG-generated values into registers that can issue hypercalls, and subsequently extracts values that may have a significant impact on the hypercall execution path through runtime feedback. By combining a variety of different registers, the test coverage of the hypercall is extended. This bytecode translation approach is not tied to any specific hypervisor platform, offering greater flexibility. However, it also introduces higher complexity, especially since manually written specifications are prone to errors, potentially limiting the effectiveness of the fuzzing process.

%NYX addressed this limitation by employing affine types and using a custom compiler and interpreter to ultimately generate C program code that executes I/O requests within the Agent OS. In addition, in order to prevent the potential for address errors caused by the previous use of static translation, VD-Guard \cite{Liu2023VDGuard} examines the current memory layout during translation via QEMU to obtain the memory region index corresponding to the target memory address. HYPERPILL~\cite{Bulekov2024HYPERPILLFF} first injects PRNG-generated values into registers that can issue hypercalls, and subsequently extracts values that may have a significant impact on the hypercall execution path through runtime feedback. By combining a variety of different registers, the test coverage of the hypercall is extended. This bytecode translation approach is not tied to any specific hypervisor platform, offering greater flexibility. However, it also introduces higher complexity, especially since manually written specifications are prone to errors, potentially limiting the effectiveness of the fuzzing process.

\textbf{Interception and redirection } involves hooking critical function calls that trigger VM Exit events, such as kernel-specific I/O APIs or the VM Exit handlers within the hypervisor. This method allows for the collection of intermediate information, which is then mutated and passed to the hypervisor for fuzzing. The advantage of this approach is that it does not require manual seed specification; instead, it mutates and tests based on actual, effective seeds. Existing works such as MundoFuzz \cite{myung2022mundofuzz}, V-Shuttle \cite{pan2021V-shuttle}, IRIS \cite{cesarano2023iris}, and VideZZo \cite{Liu2023ViDeZZoDV} have successfully utilized this approach to fuzz hypervisors.

MundoFuzz hooks guest kernel-specific APIs that handle PIO, MMIO, and DMA operations, such as the Linux kernel's \texttt{inl()/outl()} for PIO access, \texttt{readl()/writel()} for MMIO access, and \texttt{dma\_map\_single()} for DMA buffer allocation. It then uses a customized Agent OS kernel to invoke these APIs to set register values. V-Shuttle, on the other hand, hooks DMA-related APIs within the hypervisor, such as \texttt{pci\_dma\_read}. This allows DMA operations to be "hijacked" and redirected to a fuzzer-generated seed file, replacing actual guest memory data with the mutated seed.

Similar to V-Shuttle, but different in that IRIS hooks the VM Exit handler within the hypervisor and uses a dummy VM to pass the mutated VM seed, including the Virtual Machine Control Structure (VMCS) and General-Purpose Registers (GPR), to the hypervisor. Unlike other hypervisor fuzzers, IRIS primarily aims to test the hypervisor's potential vulnerabilities when handling VM Exit events triggered by virtual machines.

Unlike the previous approaches, VideZZo only hooks the DMA API to collect information about DMA-access patterns, but does not perform the redirection, which is intended to automatically construct grammars with context-dependent properties based on domain knowledge.