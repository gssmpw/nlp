% !TeX root = ../main.tex

\section{OSF Steps In Detail} \label{Section4}
% In contrast to traditional fuzzing techniques, each module within OSF framework demonstrates significant distinctions. The discrepancies primarily stem from the system software layer’s role as a bridge between developers or users and the hardware, which has extensive interaction interfaces. However, the communication data of these interfaces differ from those of applications, with a highly nested structure and potential dependencies that can decrease the efficiency of OSF and even make it challenging to effectively trigger the target code paths. Accordingly, section \ref{Section4} will detail the key techniques of the three modules shown in Fig.\ref{OSF_WorkFlow} — Input, Fuzzing Engine, and Running Environment. Additionally, it provides a comprehensive summarization of the differences between various fuzzing techniques and their applicable scenarios.

OSF differs significantly from traditional fuzzing in technical approach, largely due to the OS's intricate modular design, its extensive concurrency, and the complex, diverse interaction interfaces connecting user space and hardware with kernel space. These structural complexities create unique challenges for fuzzing, impacting both its effectiveness and efficiency in practical implementations. Thus, we review the details of the three core modules—input, fuzzing engine, and runtime environment—shown in Figure \ref{OSF_WorkFlow}, and comprehensively compare the applicability scenarios of various fuzzing techniques.

%OSF in approach exhibits distinct technical detail differences from traditional fuzzing. These differences mainly stem from the high complexity of the OS and the diversity of interaction interfaces. These characteristics make fuzzing suffer from the challenges of effectiveness and efficiency in practical implementation. We review \todo{the details of the three modules} - input, fuzzing engine and runtime environment - shown in Figure \ref{OSF_WorkFlow}. In addition, \todo{we comprehensively summarize the differences between various fuzzing techniques and their applicability scenarios.}

% \begin{footnotesize}
%         \begin{longtable}{m{2.0cm}m{1.1cm}m{0.8cm}m{1.2cm}m{1.2cm}m{0.9cm}m{0.9cm}m{1.1cm}m{0.5cm}}
%                 \caption{OSF steps}\label{tab1}                                                                                                                                                                                                                                                                                                      \\

%                 \toprule
%                 \multirow{2.5}{*}{\textbf{Fuzzer}}                         & \multicolumn{3}{c}{\textbf{Input}} & \multicolumn{3}{c}{\textbf{Fuzzing Engine}} & \multicolumn{2}{c}{\textbf{Running Environment}}                                                                                                                                       \\
%                 \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-9} & \textbf{OL}                  & \textbf{ISG}                  & \textbf{I.}                        & \textbf{SS} & \textbf{ST} & \textbf{U} & \textbf{F} & \textbf{VTs}
%                 \\
%                 \midrule
%                 \endfirsthead


%                 \toprule
%                 \multirow{2.5}{*}{\textbf{Fuzzer}}                         & \multicolumn{3}{c}{\textbf{Input}} & \multicolumn{3}{c}{\textbf{Fuzzing Engine}} & \multicolumn{2}{c}{\textbf{Running Environment}}                                                                                                                                       \\
%                 \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-9} & \textbf{OL}                  & \textbf{ISG}                  & \textbf{I.}                        & \textbf{SS} & \textbf{ST} & \textbf{U.} & \textbf{F.} & \textbf{VTs}
%                 \\
%                 \midrule
%                 \endhead

%                 \bottomrule
%                 \endfoot


%                 Trinity\cite{Trinity}                                    & Kernel                             & Spec.                                       & -                                                & -                       & -                  & Gen.(1)         & *Code                                                              \\

%                 perf\_fuzzer\cite{Weaver2015perf}                        & Kernel                             & Spec.                                       & -                                                & -                       & -                  & Gen.(1)         & *Code                                                              \\

%                 Syzkaller\cite{Syzkaller}                                & Kernel                             & Spec.'                                      & Static                                           & -                       & Feedback           & Mutation        & *Code                                                              \\

%                 KernelFuzzer\cite{KernelFuzzer2016}                      & Kernel                             & Spec.                                       & Static                                           & -                       & -                  & Gen.(1)         & *Code                                                              \\

%                 DIFUZE\cite{2017DIFUZE}                                  & Driver                             & Spec.'                                      & Static                                           & -                       & -                  & Gen.(2)         & -                 & \fullcirc+\halfcirchor+\halfcircver            \\

%                 VDF\cite{henderson2017vdf}                               & Hypervisor                         & Trace                                       & Static                                           & -                       & Crash              & Mutation        & Code              & \fullcirc+\emptycirc+\halfcirchor              \\

%                 KAFL\cite{schumilo2017kafl}                              & Filesystem                         & -                                           & Static+ Dynamic                                  & -                       & -                  & Mutation        & *Code             & \fullcirc                                      \\

%                 Semfuzz\cite{you2017semfuzz}                             & Kernel                             & PoC                                         & Static                                           & Distance                & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 usb-fuzzer\cite{Syzkaller}                               & Driver                             & Spec.'                                      & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 Moonshine\cite{pailoor2018moonshine}                     & Kernel                             & Trace                                       & Static                                           & Feedback                & -                  & Mutation        & Code              & \fullcirc+\emptycirc                           \\

%                 FUZE\cite{wu2018fuze}                                    & Kernel                             & PoC                                         & Static                                           & -                       & Distance           & Mutation        & Code              & \fullcirc                                      \\

%                 Schwarz~et~al.\cite{schwarz2018automated}                & Kernel                             & Trace                                       & -                                                & -                       & -                  & Gen.(1)         & *Code             & \emptycirc                                     \\

%                 Chizpurfle\cite{Chizpurfle2019}                          & Kernel                             & Trace                                       & Dynamic                                          & -                       & -                  & Mutation        & Code              & \halfcirchor                                   \\

%                 Razzer\cite{jeong2019razzer}                             & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & Mutation        & Code              & \emptycirc                                     \\

%                 JANUS\cite{JANUS2019fuzzing}                             & Filesystem                         & -                                           & Static                                           & -                       & -                  & Mutation        & Code+ Custom      & \fullcirc                                      \\

%                 SLAKE\cite{chen2019slake}                                & Kernel                             & PoC                                         & Static                                           & -                       & Distance           & Mutation        & -                 & \fullcirc                                      \\

%                 Shi et al.\cite{shi2019industry}                         & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & Mutation        & -                 & \fullcirc+\emptycirc+\halfcircver              \\\

%                 Unicorefuzz\cite{Unicorefuzz2019}                        & Kernel                             & Template                                    & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 KOOBE\cite{chen2020koobe}                                & Kernel                             & PoC                                         & Dynamic                                          & -                       & -                  & Mutation        & Code+ Custom      & \fullcirc                                      \\

%                 Krace\cite{xu2020krace}                                  & Filesystem                         & Spec.'                                      & Static                                           & Minimum                 & -                  & Mutation        & Code+ Thread      & \emptycirc                                     \\

%                 Hyper-CUBE\cite{schumilo2020hyper}                       & Hypervisor                         & Trace                                       & -                                                & -                       & Crash              & -               & -                 & \fullcirc+\emptycirc+\halfcircver+\halfcirchor \\

%                 Hydra\cite{Hydra2020finding}                             & Filesystem                         & -                                           & Static                                           & -                       & Crash              & Mutation        & Code+ Custom      & \fullcirc+\halfcirchor                         \\

%                 USBFuzz\cite{peng2020usbfuzz}                            & Driver                             & Template                                    & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 Agamotto\cite{song2020agamotto}                          & Driver                             & Trace                                       & Static                                           & -                       & -                  & Mutation        & *Code             & -                                              \\

%                 HFL\cite{kim2020hfl}                                     & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 X-AFL\cite{liang2020xafl}                                & Kernel                             & Trace                                       & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 HEALER\cite{sun2021healer}                               & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & Gen.+Mut.       & Code              & \fullcirc+\emptycirc+\halfcirchor              \\

%                 Rtkaller\cite{shen2021rtkaller}                          & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc+\emptycirc                           \\

%                 NYX\cite{schumilo2021nyx}                                & Hypervisor                         & Spec.                                       & Dynamic                                          & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 V-Shuttle\cite{pan2021V-shuttle}                         & Hypervisor                         & Trace                                       & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc+\halfcirchor                         \\

%                 BSOD\cite{maier2021bsod}                                 & Driver                             & Template                                    & Dynamic                                          & -                       & -                  & Gen.+Mut.       & Code              & \fullcirc                                      \\

%                 SyzVegas\cite{wang2021syzvegas}                          & Kernel                             & Spec.'                                      & Static                                           & Feedback                & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 StateFuzz\cite{zhao2022statefuzz}                        & Driver                             & Spec.'                                      & Static                                           & Minimum                 & -                  & Mutation        & Code+ Custom      & \fullcirc                                      \\

%                 GREBE\cite{lin2022grebe}                                 & Kernel                             & PoC                                         & Static                                           & Minimum                 & -                  & Mutation        & Custom            & \fullcirc+\halfcircver                         \\

%                 MundoFuzz\cite{myung2022mundofuzz}                       & Hypervisor                         & Trace                                       & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc+\halfcirchor                         \\

%                 Morphuzz\cite{bulekov2022morphuzz}                       & Hypervisor                         & Trace                                       & Static                                           & -                       & -                  & Mutation        & Code              & \emptycirc+\halfcirchor                        \\

%                 CONZZER\cite{CONZZER2022context}                         & Filesystem                         & Spec.'                                      & Static                                           & Feedback                & -                  & Mutation        & Code+ Thread      & \emptycirc                                     \\

%                 Sfuzz\cite{chen2022sfuzz}                                & Kernel                             & -                                           & Static                                           & -                       & -                  & Mutation        & *Code             & \fullcirc                                      \\

%                 Dr.Fuzz\cite{zhao2022semantic}                           & Driver                             & Spec.'                                      & Static+ Dynamic                                  & -                       & -                  & Mutation        & *Code+ Custom     & \fullcirc+\halfcircver                         \\

%                 %36
%                 PrintFuzz\cite{ma2022printfuzz}                          & Driver                             & Spec'                                       & Static+ Dynamic                                  & -                       & -                  & Gen.+Mut.       & Code              & \fullcirc+\emptycirc                           \\

%                 DriFuzz\cite{shen2022drifuzz}                            & Driver                             & Trace                                       & Static                                           & -                       & -                  & Gen.+Mut.       & Code              & \fullcirc                                      \\

%                 Demystifying\cite{Hao2022DemystifyingTD}                 & Kernel                             & -                                           & Static                                           & -                       & -                  & -               & -                 & -                                              \\

%                 KSG\cite{sun2022ksg}                                     & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & -               & -                 & \fullcirc+\emptycirc+\halfcirchor              \\

%                 %43
%                 SyzScope\cite{zou2022syzscope}                           & Kernel                             & PoC                                         & Static                                           & Feedback                & -                  & Mutation        & -                 & \fullcirc                                      \\

%                 Tardis\cite{shen2022tardis}                              & Kernel                             & Spec                                        & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc+\halfcirchor                         \\

%                 Segfuzz\cite{jeong2023segfuzz}                           & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & Mutation        & Code+ Thread      & \fullcirc+\emptycirc+\halfcircver              \\

%                 IRIS\cite{cesarano2023iris}                              & Hypervisor                         & IRIS                                        & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 FUZZNG\cite{bulekov2023FUZZNG}                           & Kernel                             & Spec.                                       & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 ACTOR\cite{fleischer2023actor}                           & Kernel                             & Trace                                       & Static                                           & -                       & -                  & Gen.(2)         & Code              & \fullcirc+\halfcirchor                         \\

%                 SyzDescribe\cite{hao2023syzdescribe}                     & Driver                             & Spec.'                                      & -                                                & -                       & -                  & -               & -                 & -                                              \\

%                 DEVFUZZ\cite{wu2023devfuzz}                              & Driver                             & Template                                    & Static+ Dynamic                                  & -                       & -                  & Mutation        & *Code+ Custom     & \fullcirc+\halfcirchor+\halfcircver            \\

%                 Syzdirect\cite{tan2023syzdirect}                         & Kernel                             & Spec.'                                      & Static                                           & Distance                & Distance           & Mutation        & Code              & -                                              \\

%                 ReUSB\cite{Jang2023ReUSB}                                & Driver                             & Trace                                       & Dynamic                                          & -                       & -                  & Mutation        & Code              & \fullcirc                                      \\

%                 DDRace\cite{Yuan2023DDRace}                              & Driver                             & Spec.'                                      & Static                                           & Feedback                & -                  & Mutation        & Code+ Thread      & \fullcirc+\emptycirc                           \\

%                 VDGUARD\cite{Liu2023VDGuard}                             & Hypervisor                         & Trace                                       & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc+\halfcirchor                         \\

%                 Lfuzz\cite{Liu2023LFuzz}                                 & Filesystem                         & -                                           & Static                                           & -                       & -                  & Mutation        & Code              & \fullcirc+\halfcirchor                         \\

%                 KernelGPT\cite{yang2023kernelgpt}                        & Kernel                             & Spec.'                                      & Static                                           & -                       & -                  & Mutation        & *Code             & \fullcirc+\halfcircver                         \\
%         \end{longtable}
%         \begin{flushleft}
%         \justifying
%         \textbf{OL} is the abbreviation of OS Layer. 
%         \textbf{ISG} is the abbreviation of initial seed generation.
%         \textbf{I.} is the abbreviation of instrumentation.
%         \textbf{SS} is the abbreviation of seed selection.
%         \textbf{ST} is the abbreviation of seed trim.
%         \textbf{U.} is the abbreviation of update.
%         \textbf{F.} is the abbreviation of feedback.
%         \textbf{VTs} is the abbreviation of vulnerability types: ``\fullcirc''  means Memroy Violation Bug. ``\emptycirc'' means Concurrency Bug.        ``\halfcirchor'' means Logic Bug. ``\halfcircver'' means Access Violation      Bug.
%         \end{flushleft}
%         \end{footnotesize}

\begin{footnotesize}
        \begin{longtable}{m{1.8cm}m{1.3cm}m{0.6cm}m{1.6cm}m{1.0cm}m{0.8cm}m{0.9cm}m{1.3cm}m{0.5cm}}
        \caption{Overview of Fuzzers Sorted by Publication Year.}\label{tab1} \vspace{-0.3cm}\\
        
        \toprule
        \multirow{2.5}{*}{\textbf{Fuzzer}} & \multicolumn{3}{c}{\textbf{Input}} & \multicolumn{3}{c}{\textbf{Fuzzing Engine}} & \multicolumn{2}{c}{\textbf{Running Environment}} \\
        \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-9} & \textbf{OSL} & \textbf{ISG} & \textbf{I.} & \textbf{SS} & \textbf{ST} & \textbf{U.} & \textbf{F.} & \textbf{VTs} \\
        \midrule
        \endfirsthead
        
        \toprule
        \multirow{2.5}{*}{\textbf{Fuzzer}} & \multicolumn{3}{c}{\textbf{Input}} & \multicolumn{3}{c}{\textbf{Fuzzing Engine}} & \multicolumn{2}{c}{\textbf{Running Environment}} \\
        \cmidrule(lr){2-4} \cmidrule(lr){5-7} \cmidrule(lr){8-9} & \textbf{OSL} & \textbf{ISG} & \textbf{I.} & \textbf{SS} & \textbf{ST} & \textbf{U.} & \textbf{F.} & \textbf{VTs} \\
        \midrule
        \endhead
        
        \bottomrule
        \endfoot
        
        Trinity\cite{Trinity} & Kernel & Spec. & - & - & - & Gen.(1) & Code & -\\
        
        %perf\_fuzzer\cite{Weaver2015perf} & Kernel & Spec. & - & - & - & Gen.(1) & *Code & -\\
        
        Syzkaller\cite{Syzkaller} & Kernel & Spec.' & Static & Feedback & Feedback & Mut. & Code & -\\
        
        KernelFuzzer\cite{KernelFuzzer2016} & Kernel & Spec. & Static & - & - & Gen.(1) & Code & -\\
        
        DIFUZE\cite{2017DIFUZE} & Driver & Spec.' & Static & - & - & Gen.(2) & - & M.,L.,O. \\
        
        VDF\cite{henderson2017vdf} & Hypervisor & Trace & Static & - & Crash & Mut. & Code & M.,C.,L. \\
        
        KAFL\cite{schumilo2017kafl} & File System & - & Static+Dynamic & - & - & Mut. & Code & M. \\
        
        Semfuzz\cite{you2017semfuzz} & Kernel & PoC & Static & Distance & - & Mut. & Code & M. \\
        
        usb-fuzzer\cite{Syzkaller} & Driver & Spec.' & Static & - & - & Mut. & Code & M. \\
        
        Moonshine\cite{pailoor2018moonshine} & Kernel & Trace & Static & Feedback & - & Mut. & Code & M.,C. \\
        
        FUZE\cite{wu2018fuze} & Kernel & PoC & Static & - & Distance & Mut. & Code & M. \\
        
        Schwarz~et~al.\cite{schwarz2018automated} & Kernel & Trace & - & - & - & Gen.(1) & Code & C. \\
        
        Razzer\cite{jeong2019razzer} & Kernel & Spec.' & Static & - & - & Mut. & Code & C. \\
        
        JANUS\cite{JANUS2019fuzzing} & File System & - & Static & - & - & Mut. & Code+Cust. & M.,L. \\
        
        SLAKE\cite{chen2019slake} & Kernel & PoC & Static & - & Distance & Mut. & - & M. \\
        
        Shi et al.\cite{shi2019industry} & Kernel & Spec.' & Static & - & - & Mut. & - & M.,C.,O. \\

        PeriScope\cite{Song2019PeriScopeAE} & Driver & Trace & Static & - & Feedback & Mut. & Code & M. \\
        
        Unicorefuzz\cite{Unicorefuzz2019} & Kernel & Pattern & Static & - & - & Mut. & Code & M. \\
        
        KOOBE\cite{chen2020koobe} & Kernel & PoC & Dynamic & - & - & Mut. & Code+Cust. & M. \\
        
        Krace\cite{xu2020krace} & File System & Spec.' & Static & Minimum & - & Mut. & Code+Thread & C. \\
        
        Hyper-CUBE\cite{schumilo2020hyper} & Hypervisor & Pattern & - & - & Crash & - & - & M.,C.,L.,O. \\
        
        Hydra\cite{Hydra2020finding} & File System & - & Static & - & Crash & Mut. & Code+Cust. & M.,L. \\
        
        USBFuzz\cite{peng2020usbfuzz} & Driver & Pattern & Static & - & - & Mut. & Code & M. \\
        
        Agamotto\cite{song2020agamotto} & Driver & Trace & Static & - & - & Mut. & Code & - \\

        Ex-vivo\cite{Pustogarov2020ExvivoDA} & Driver & Trace & Static & - & - & Mut. & Code & M. \\
        
        HFL\cite{kim2020hfl} & Kernel & Spec.' & Static & - & - & Mut. & Code & M. \\
        
        X-AFL\cite{liang2020xafl} & Kernel & Trace & Static & - & - & Mut. & Code & M. \\
        
        HEALER\cite{sun2021healer} & Kernel & Spec.' & Static & - & Feedback & Gen.+Mut. & Code & M.,C.,L. \\
        
        Rtkaller\cite{shen2021rtkaller} & Kernel & Spec.' & Static & - & - & Mut. & Code & M.,C. \\
        
        NYX\cite{schumilo2021nyx} & Hypervisor & Spec. & Dynamic & - & - & Mut. & Code & M. \\
        
        V-Shuttle\cite{pan2021V-shuttle} & Hypervisor & Trace & Static & - & - & Mut. & Code & M.,L. \\
        
        BSOD\cite{maier2021bsod} & Driver & Pattern & Dynamic & - & - & Gen.+Mut. & Code & M. \\
        
        SyzVegas\cite{wang2021syzvegas} & Kernel & Spec.' & Static & Feedback & - & Mut. & Code & M. \\
        
        StateFuzz\cite{zhao2022statefuzz} & Driver & Spec.' & Static & Similarity & - & Mut. & Code+Cust. & M. \\
        
        GREBE\cite{lin2022grebe} & Kernel & PoC & Static & Minimum & - & Mut. & Custom & M.,O. \\
        
        MundoFuzz\cite{myung2022mundofuzz} & Hypervisor & Trace & Static & - & - & Mut. & Code & M.,L. \\
        
        Morphuzz\cite{bulekov2022morphuzz} & Hypervisor & Trace & Static & - & - & Mut. & Code & C.,L. \\
        
        CONZZER\cite{CONZZER2022context} & File System & Pattern & Static & Feedback & - & Mut. & Code+Thread & C. \\
        
        %Sfuzz\cite{chen2022sfuzz} & Kernel & - & Static & - & - & Mut. & *Code & M. \\
        
        Dr.Fuzz\cite{zhao2022semantic} & Driver & Spec.' & Static+Dynamic & - & - & Mut. & Code+Cust. & M.,O. \\
        
        PrintFuzz\cite{ma2022printfuzz} & Driver & Spec.' & Static+Dynamic & - & - & Gen.+Mut. & Code & M.,C.\\
        
        DriFuzz\cite{shen2022drifuzz} & Driver & Trace & Static & - & - & Gen.+Mut. & Code & M. \\
        
        Hao~et~al.\cite{Hao2022DemystifyingTD} & Kernel & - & Static & - & - & - & - & - \\
        
        KSG\cite{sun2022ksg} & Kernel & Spec.' & Static & - & - & - & - & M.,C.,L. \\
        
        SyzScope\cite{zou2022syzscope} & Kernel & PoC & Static & Feedback & - & Mut. & - & M. \\
        
        Tardis\cite{shen2022tardis} & Kernel & Spec. & Static & - & - & Mut. & Code & M.,L. \\
        
        Segfuzz\cite{jeong2023segfuzz} & Kernel & Spec.' & Static & - & - & Mut. & Code+Thread & M.,C.,O. \\
        
        IRIS\cite{cesarano2023iris} & Hypervisor & Trace & Static & - & - & Mut. & Code & M. \\
        
        FUZZNG\cite{bulekov2023FUZZNG} & Kernel & Pattern & Static & - & - & Mut. & Code & M. \\
        
        ACTOR\cite{fleischer2023actor} & Kernel & Trace & Static & - & - & Gen.(2) & Code & M.,L. \\
        
        SyzDescribe\cite{hao2023syzdescribe} & Driver & Spec.' & - & - & - & - & - & - \\
        
        DEVFUZZ\cite{wu2023devfuzz} & Driver & Pattern & Static+Dynamic & - & - & Mut. & Code+Cust. & M.,L.,O. \\
        
        Syzdirect\cite{tan2023syzdirect} & Kernel & Spec.' & Static & Distance & Distance & Mut. & Code & - \\
        
        ReUSB\cite{Jang2023ReUSB} & Driver & Trace & Dynamic & - & - & Mut. & Code & M. \\
        
        DDRace\cite{Yuan2023DDRace} & Driver & Spec.' & Static & Feedback & - & Mut. & Code+Thread & M.,C. \\
        
        VDGUARD\cite{Liu2023VDGuard} & Hypervisor & Trace & Static & - & - & Mut. & Code & M.,L. \\

        ViDeZZo\cite{Liu2023ViDeZZoDV} & Hypervisor & Trace & Static & - & - & Gen.+Mut. & Code & M.\\
        
        Lfuzz\cite{Liu2023LFuzz} & File System & - & Static & - & - & Mut. & Code & M.,L. \\

        KernelGPT\cite{yang2023kernelgpt} & Kernel & Spec.' & Static & - & - & Mut. & Code & M.,O. \\

        BRF \cite{Hung2024BRFFT} & Kernel & Spec.' & Static & - & - & Gen.+Mut. & Code & M.,C.\\

        MOCK \cite{Xu2024MOCKOK} & Kernel & Spec.' & Static & Feedback & Feedback & Gen.+Mut. & Code & M.,C.\\

        SATURN\cite{Xu2024Saturn} & Driver & Spec.' & Static & Similarity & - & Gen.+Mut. & Code & M.,C.,I.\\

        Syzgen++\cite{Chen2024SyzGen++} & Driver & Spec.' & Static & - & - & Gen. & Code & M.,C.,I.\\

        VIRTFUZZ\cite{Huster2024ToBoldly} & Driver & Trace & Static & - & - & Mut. & Code & M.,L.\\

        HYPERPILL\cite{Bulekov2024HYPERPILLFF} & Hypervisor & Pattern & Static & - & - & Mut. & Code & M. \\

        %SyzBridge \cite{Zou2024SyzBridgeBT} & Kernel & \\
        
        %KernelGPT\cite{yang2023kernelgpt} & Kernel & Spec.' & Static & - & - & Mutation & *Code & \fullcirc+\halfcircver \\
        \end{longtable}
        \vspace{-0.4cm}
        \begin{flushleft}
        \justifying
        A “-” means it is irrelevant, not mentioned, or unclear in detail.
        \textbf{OSL} is the abbreviation of OS Layer. 
        \textbf{ISG} is the abbreviation of initial seed generation.
        \textbf{I.} is the abbreviation of instrumentation.
        \textbf{SS} is the abbreviation of seed selection.
        \textbf{ST} is the abbreviation of seed trim.
        \textbf{U.} is the abbreviation of update.
        \textbf{F.} is the abbreviation of feedback.
        \textbf{VTs} is the abbreviation of vulnerability types: \textbf{ M.} is the abbreviation of Memory Violation Bug. \textbf{C.} is the abbreviation of Concurrency Bug. \textbf{L.} is the abbreviation of Logic Bug. \textbf{O.} means Privilege Protection Bug, Processor Exception, or Data Integrity Bug.
        \end{flushleft}
        \end{footnotesize}
        
%``\fullcirc'' is the abbreviation of M.. ``\emptycirc'' means Concurrency Bug. ``\halfcirchor'' means Logic Bug. ``\halfcircver'' means Access Violation Bug.

% subsection 3
\subsection{Initial Seed Generation}

Initial seed generation focuses on how to generate seeds at the beginning of OSF, which can be categorized into four types based on the input provided to the fuzzer: Pattern-, Specification-, Trace-, and Poc-based initial seed generation approach. As shown in Table \ref{tab1}, these categories are listed under the column ``ISG''.

\subsubsection{Pattern-based}

%Template-Based generation involves providing the fuzzer with a template file that interacts with the actual PUT. The fuzzer then generates the initial seed sequence based on this template's content. This method includes early open-source fuzzing frameworks such as AFL \cite{AFL}, Honggfuzz \cite{Honggfuzz}, TriforceAFL \cite{TriforceAFL}, and libFuzzer \cite{libfuzzer}. Although these frameworks are not specifically designed for OS fuzzing, they can be adapted for OSF seed generation by compiling custom initial input files to run on the target operating system.
\todo{In early research, traditional fuzzer tools or random number generator like AFL \cite{AFL}, Honggfuzz \cite{Honggfuzz}, TriforceAFL \cite{TriforceAFL}, libFuzzer \cite{libfuzzer}, and PRNG (a pseudo-random-number generator) \cite{PRNG2020} were extended to a initial seed generator for OSF. Their approaches in initial seed generation are classified as pattern-based methods because they involve defining patterns of data structures, interaction behaviors, or input formats for another new PUT within their original fuzzing framework. The process typically requires creating a file that these tools can recognize, leveraging domain knowledge to define the patterns used for interacting with the new PUT. For instance, in AFL, this could involve a predefined input format for kernel fuzzing (an initial syscall sequence) or I/O operations that simulate device behavior in driver fuzzing.} 

%Although extending and customizing these open-source fuzzer tools can enable OSF, these methods often suffer from high randomness and low efficiency.}

\todo{Therefore, to fuzz driver, fuzzers like USBFuzz \cite{peng2020usbfuzz}, DEVFUZZ \cite{wu2023devfuzz}, and BSOD \cite{maier2021bsod} have extended AFL to generate device inputs (such as vendor IDs and communication data). These fuzzers generate initial seeds based on interaction patterns between drivers and devices, which are then passed to the respective drivers to simulate realistic hardware behavior in response to driver read requests. For kernel fuzzing, other fuzzers (such as CONZZER \cite{CONZZER2022context} and TriforceAFL) extend AFL to generate random syscall sequences, aiming to uncover vulnerabilities within the kernel and its subsystems. FUZZNG \cite{bulekov2023FUZZNG} utilizes libFuzzer to generate random bytes, translating them into valid syscall sequences. Unicorefuzz \cite{Unicorefuzz2019} uses AFL to produce binary instructions to fuzz kernel ported to user space. In hypervisor fuzzing, fuzzers such as \cite{schumilo2020hyper,Bulekov2024HYPERPILLFF,schumilo2021nyx,Liu2023VDGuard,bulekov2022morphuzz} utilize libFuzzer, PRNG, or AFL to generate initial bytecode sequences (initial seed). Although OSF can be achieved through extensions and customizations of open-source fuzzing tools, these methods often neglect syntactic and semantic constraints between seeds, leading to the problem of high randomness and inefficiency in fuzzing.}

%To overcome inefficiencies caused by random input from devices and the physical actions of attaching and detaching devices in driver fuzzing, frameworks, such as USBFuzz \cite{peng2020usbfuzz}, Devfuzz \cite{wu2023devfuzz}, and BSOD \cite{maier2021bsod} extend AFL to generate device inputs (\eg vendor IDs, communication data). They use a file to communicate fuzzer-generated inputs to the target program, which the device uses to respond to read requests from device drivers during IO operations.

%\todo{To overcome the inefficiencies caused by random inputs from devices and the physical operations of connecting and disconnecting devices during driver fuzzing, frameworks such as USBFuzz \cite{peng2020usbfuzz}, Devfuzz \cite{wu2023devfuzz}, and BSOD \cite{maier2021bsod} have extended AFL to generate device inputs (\eg vendor IDs, communication data). These fuzzers generate initial seeds based on these patterns and pass them to the PUT, simulating real hardware behavior in response to read requests from device drivers.}

%Additionally, to apply fuzzing to kernel, one kind of fuzzers such as CONZZER \cite{CONZZER2022context} and TriforceAFL extend AFL to find kernel and subsystem bugs by invoking randomly generated syscalls. FUZZNG \cite{bulekov2023FUZZNG} uses libFuzzer to first generate random byte buffers, which are then mapped into multiple valid syscall sequences. The other type of fuzzer, Unicorefuzz \cite{Unicorefuzz2019}, employs AFL to generate binary instructions, which are then used for fuzzing kernel modules that are ported to userland.

%\todo{Additionally, to apply fuzz testing to the kernel, certain fuzzers, such as CONZZER \cite{CONZZER2022context} and TriforceAFL, have also extended AFL to find kernel and subsystem bugs by invoking randomly generated syscalls. FUZZNG \cite{bulekov2023FUZZNG} utilizes libFuzzer to first generate random byte buffers, which are then translated into valid syscall sequences. Another type of fuzzer, Unicorefuzz \cite{Unicorefuzz2019}, uses AFL to generate binary instructions that are subsequently used for fuzzing kernel modules ported to user space.}

\subsubsection{Specification-based}
%Specification-Based initial seed generation requires constructing a specification for the PUT to create initial seed sequences based on both syntax and semantics. Early popular kernel fuzzing frameworks like Trinity \cite{Trinity} and KernelFuzz \cite{KernelFuzzer2016} use this approach. Due to their semi-random seed generation strategy and limited extensibility, these frameworks are often used as foundational infrastructure for syscall generation \cite{Weaver2015perf,pailoor2018moonshine, jeong2023segfuzz,xu2020krace}.
\todo{Specifications are a type of document that describes meta information for seeds, including details such as seed types, names, parameter types, and value ranges. Therefore, initial seed generation methods based on specifications require the construction of a dedicated specification for the PUT to guide the generation of the initial seed, ensuring it meet basic syntactic rules. Since the data structures for I/O communications are implemented by third-party vendors and are commercially protected, and existing fuzzing tools only construct specifications for syscalls, current specification-based initial seed generation methods are primarily applicable to scenarios where syscalls are used as seeds \cite{pailoor2018moonshine, jeong2023segfuzz,xu2020krace}.}

%Since this approach can clearly define the constraints and input-output requirements for function-specific seeds, it is commonly employed in the initial seed generation for syscall-based fuzzing. \cite{pailoor2018moonshine, jeong2023segfuzz,xu2020krace}.}

Early popular kernel fuzzing frameworks like Trinity \cite{Trinity} and KernelFuzz \cite{KernelFuzzer2016} use this approach. Trinity relies on hard-coded rules to produce initial syscall sequences, such as creating a list of file descriptors and annotating arguments with valid or near-valid data types and values. It is suitable for scenarios focusing solely on random syscalls generation \cite{xu2020krace, schwarz2018automated}, but it is less adaptable to kernel changes \cite{pailoor2018moonshine}. Although KernelFuzz considers detailed syscall specifications during fuzzing process, its adaptability and extensibility are challenged by \todo{random mutation strategies.}

To build diverse and accurate syscalls, Syzkaller \cite{Syzkaller} uses a structured description language called syzlang \cite{syzlang} to record syscall declarations, providing more semantic information during initial seed generation. As shown in Table \ref{tab1}, fuzzers with spec.'-based inital seed generation use Syzkaller as foundational infrastructure for initial seed generation, allowing them to focus on enhancing the effectiveness of other steps, such as seed selection \cite{wang2021syzvegas,Yuan2023DDRace}, seed trim \cite{shen2021rtkaller,zhao2022semantic,hao2023syzdescribe}, mutation strategy \cite{xu2020krace,sun2021healer,shen2021rtkaller,zhao2022semantic}, feedback optimization \cite{JANUS2019fuzzing,shi2019industry,xu2020krace,shen2021rtkaller,wang2021syzvegas,zhao2022statefuzz,CONZZER2022context,zhao2022semantic,jeong2023segfuzz}, and monitor enhancement \cite{jeong2019razzer,xu2020krace,CONZZER2022context,jeong2023segfuzz}. \todo{Additionally,
to improve the quality of the initial seed generated by Syzkaller, \cite{2017DIFUZE,kim2020hfl,ma2022printfuzz,sun2022ksg,hao2023syzdescribe,tan2023syzdirect,Yuan2023DDRace,Hung2024BRFFT,Xu2024MOCKOK} extract entry points and infer dependencies of syscall using program analysis techniques, manual analysis based on domain knowledge, and neural network model.} Another work, KernelGPT \cite{yang2023kernelgpt}, employs LLM to construct syzlang, enabling Syzkaller to generate Syzlang language for the newly merged code in the Linux mainline.


\subsubsection{Trace-Based}
To avoid the complex construction of specifications, Trace-Based generation uses real applications or devices as trigger engines to create initial seed sequences based on intercepted data structures. Some studies intercept syscall sequences \cite{pailoor2018moonshine,schwarz2018automated,liang2020xafl,fleischer2023actor,Jang2023ReUSB}, I/O communication \cite{song2020agamotto,Pustogarov2020ExvivoDA,pan2021V-shuttle,myung2022mundofuzz,bulekov2022morphuzz,shen2022drifuzz,Liu2023VDGuard,Song2019PeriScopeAE,Liu2023ViDeZZoDV,Huster2024ToBoldly}, or driver operations \cite{henderson2017vdf,cesarano2023iris,Jang2023ReUSB} to generate inital seed. This approach ensures that the initial seeds are real and effective, enhancing the fuzzer's flexibility and portability. However, a key limitation is the lack of usage specifications for critical structure of seed, which may render them ineffective during arbitrary seed mutations, thereby limiting the depth of testing. Trace-based initial seed generation techniques can be implemented through software, hardware instrumentation, or third-party tool like STRACE \cite{Strace}, Wireshark \cite{Wireshark} and USBMON \cite{usbmon}, and Flush+Reload \cite{Yarom2014FLUSHRELOADAH, 2011IS}.

\subsubsection{PoC-Based}

In addition to the previously mentioned methods, PoC-based approach generate the initial seed through taking a PoC or bug report as input, where the PoC or bug report can be acquire in CVE \cite{cve}, Linux git logs \cite{linuxkernel}, and bug description posted on forums and blogs \cite{fulldisclosure, sans, krebsonsecurity}. This method generally focuses on the field of OS bug exploitation or \todo{homogeneous vulnerability exploration}, such as FUZE \cite{wu2018fuze}, KOOBE \cite{chen2020koobe}, Syzscope \cite{zou2022syzscope}, GREBE \cite{lin2022grebe}, SLAKE \cite{chen2019slake} and SemFuzz \cite{you2017semfuzz}. The fuzzers employ program analysis techniques, such as taint analysis \cite{zou2022syzscope,lin2022grebe}, static analysis \cite{chen2019slake} and symbolic execution \cite{wu2018fuze, chen2020koobe}, to identify critical objects in the kernel that behave similarly to the bug. These techniques then generate initial seeds using syscalls and parameters that can reach these critical objects. Another study, SemFuzz \cite{you2017semfuzz}, uses Natural Language Processing (NLP) to extract vulnerable functions, vulnerability types, critical variables, and syscalls from CVEs and bug reports. It then uses Syzkaller to precisely generate syscall sequences that bring the execution of the target kernel closer to the vulnerable function.

% subsection 4
\subsection{Instrumentation}
\label{subsection4.2}
\todo{Instrumentation inserts probes into a program to collect runtime information from the PUT while preserving its original functionality and logical structure \cite{Instrumentation_Huang1978, ibm2020}.} By analyzing and processing this runtime data, insights into the program's control and data flow can be acquired. Consequently, this allows for intercepting data sending to PUT, the calculation of coverage metric and the monitoring of bugs. Such data then guides the fuzzing process towards more sensitive and potentially critical code paths.

Unlike userland fuzzing, performing instrumentation in kernel space using built-in compiler tools such as GCC Coverage (Gcov) \cite{gcov} and Address Sanitizer (Asan) \cite{ASAN} in gcc or clang/llvm is impractical due to the large scale and complexity of the modern OS kernel. Consequently, researchers have developed two instrumentation approaches for operating systems.

\subsubsection{Static Instrumentation}

Static instrumentation typically involves inserting probe programs into the source code or intermediate representation code. Open-source operating systems offer a rich set of tools for static instrumentation, such as KCOV \cite{vyukov2018kcov}, KASAN \cite{kernel2018kasan}, \etc These tools are well-suited for OSF due to their advantages of being easy to use, having relatively low overhead, being customizable, and providing strong support for Unix-like operating systems. For instance, Syzkaller \cite{Syzkaller} compiles KCOV and KASAN into the kernel to guide OSF based on collected code coverage and detects memory-related bugs. Note that KCOV and KASAN were introduced in Linux versions 4.6 and 4.0, respectively. For older versions of Linux, SemFuzz \cite{you2017semfuzz} implemented the porting of these tools.

However, built-in kernel instrumentation tools are not always effective in certain scenarios. For example, challenges arise in thoroughly exploring the program state space, handling thread interleaving for concurrency errors, and performing directed fuzzing. Some studies have addressed these specific challenges by extending existing compiler tools to implement fine-grained program analysis and targeted instrumentation. For example, coverage-guided fuzzers often discard test cases useful for exploring potential program states (\ie values of all program variables, virtual memory, and registers) if these test cases do not trigger new code paths. To overcome this challenge, StateFuzz \cite{zhao2022statefuzz} introduces a new feedback metric called state coverage and uses the static instrumentation tool LLVM SanCov to collect program state information, and then fine-tune the execution direction of coverage-guided fuzzers. In the context of concurrency error detection, fuzzers such as DDRace \cite{Yuan2023DDRace}, Krace \cite{xu2020krace}, SegFuzz \cite{jeong2023segfuzz}, CONZZER \cite{CONZZER2022context}, and Razzer identify customized thread coverage metrics to explore potential code areas for data races through the LLVM suite. For directed fuzzing, GREBE \cite{lin2022grebe} uses LLVM Analysis and Pass to track taint propagation paths in the program to identify critical objects. Tardis \cite{shen2022tardis} addresses the unavailability of KCOV in embedded operating systems (\eg \textit{UC/OS}, \textit{FreeRTOS}, \etc) by leveraging Clang's SanitizerCoverage and thus proposes an efficient coverage collection callback.

%MundoFuzz \cite{myung2022mundofuzz} utilizes AFL's instrumentation compiler (afl-clang-fast) to obtain branch coverage metrics and monitors logic-related vulnerabilities in a hypervisor with Msan \cite{MemorySanitizer}.

\subsubsection{Dynamic Instrumentation}
Dynamic Instrumentation, or Dynamic Binary Instrumentation (DBI), happens while the PUT is running. Although DBI have a higher runtime overhead compared to static instrumentation, its increased flexibility makes it useful for kernels without built-in instrumentation tools or for earlier versions of the Linux kernel. DBI solutions are generally categorized into hardware-assisted and software-assisted techniques. We review and summarize the application scenarios for both types of solutions below:

\textbf{Hardware-Assisted Solution.}
Hardware-assisted DBI (\eg Intel Processor Trace \cite{kleen2015,simplept} and ARM CoreSight \cite{coresight2017}) leverages special CPU features to trace the execution and branch information of a program. Note that hardware-assisted DBI records the execution paths rather than code coverage, but the detailed execution path information can be used to infer runtime coverage. Intel and ARM offer similar features; the former is suitable for testing kernels, drivers, file systems, and hypervisors in virtualized environments, while the latter is mainly used in embedded systems and mobile devices. However, ARM's tracing functionality is not mandatory for ARM CPUs, making it inapplicable to commercial Android devices \cite{Chizpurfle2019}.

In the collection of driver fuzzing feedback, KCOV fails to gather complete execution information for the driver validation chain because the \texttt{debugfs} files that expose KCOV coverage information are not yet available. This step typically includes hardware detection, resource allocation, and initial setup. Although it may not be as complex or extensive as the fully operational kernel code, it remains critical for system security and stability because attackers might exploit them before the system fully boots.

To overcome this problem, Dr.Fuzz \cite{zhao2022semantic}, PrIntFuzz \cite{ma2022printfuzz}, DEVFUZZ \cite{wu2023devfuzz}, and KAFL \cite{schumilo2017kafl} leverage Intel PT to track the execution flow during the driver initialization phase. They then switch back to KCOV to obtain precise coverage information, which can effectively enhances the depth of driver fuzzing through combining the strangths of both methods.


\textbf{Software-Assisted Solution.}
Software-assisted DBI refers to the dynamic injection of binary instructions during program execution using software breakpoints or binary rewriting techniques. This strategy is more flexible and generally applicable to devices without specific hardware support. For example, while ARM CoreSight is effective, it is difficult to apply to the commercial Android OS. Thus, this strategy should be treated with a grain of salt due to concerns about throughput and flexibility, as software-assisted DBI typically incurs a higher runtime overhead.

DBI software frameworks commonly used for OSF include Frida \cite{frida2017}, Valgrind \cite{Valgrind2007} , and \todo{INT 3 software breakpoints \cite{2006Intel6}.} Frida replaces an instruction in the debugged program with another instruction that stops the program and triggers a breakpoint handler function, allowing tracking of executed code blocks. Valgrind monitors applications on Linux through a virtual machine environment for focusing on analyzing memory usage and race condition errors. For instance, Chizpurfle \cite{Chizpurfle2019} leverages the DBI framework Frida and the Linux syscall ptrace to collect basic block coverage on real Android devices and uses Valgrind to monitor memory leaks and race conditions. INT 3 is an instruction in the x86 and x86-64 architectures that is used to trigger debug interrupts. Specifically, it obtains the execution flow information of the PUT by replacing the basic block jump instruction or the conditional control flow instruction after disassembling the binary PUT (\eg Capstone \cite{Capstone}) into a control flow graph. Eventually, the code coverage calculation for binary PUTs can be realized by integrating a modified Syzkaller's KCOV module or AFL's coverage calculation module. For example, BSOD \cite{maier2021bsod} connects to the VM using the introspection APIs, collects program control flow information by pausing the VM and replacing the first byte of the control flow instruction with the \texttt{0xcc} instruction (INT 3) .

% subsection 5
\subsection{Seed Selection}
\label{Section4.3}

%Seed selection \todo{selects the most useful seeds from the corpus for subsequent mutation.} This step is particularly important \todo{because the selected seeds directly determine the subsequent direction of the fuzzer. Hence, most research focuses on how to reduce the search space for seed selection and how to choose effective seeds.} Although there has been some optimization work on seed selection in userland fuzzing \cite{Rebert2014OptimizingSS, Woo2013SchedulingBM, Zhao2019SendHP}, these methods cannot be directly applied to operating systems due to the huge code base and \todo{various} interaction interfaces. To achieve directed fuzzing in OSF through seed selection, some fuzzers specifically designed for OSF (especially those using syscalls as the interaction interface) have proposed various seed selection strategies.

Seed selection \todo{selects the relatively ``valuable'' seeds from the corpus for subsequent mutation.} This step is particularly important \todo{because the selected seeds directly determine the subsequent direction of the fuzzer. Hence, most research focuses on how to reduce the search space for seed selection and how to choose effective seeds.} Although there has been some optimization work on seed selection in userland fuzzing \cite{Rebert2014OptimizingSS, Woo2013SchedulingBM, Zhao2019SendHP}, these methods cannot be directly applied to operating systems due to the huge code base and \todo{various} interaction interfaces. \todo{To obtain the most ``valuable'' seeds each time, some fuzzers specifically designed for OSF (especially those using syscalls as the interaction interface) have proposed various seed selection strategies.}

\subsubsection{Minimum Frequency.}
Past practices have proven that executing rarer code paths helps test extreme situations and makes it easier to expose bugs \cite{Bx00F6hme2016CoverageBasedGF, Lemieux2017FairFuzzAT}. Therefore, the Minimum Frequency principle refers to selecting the least frequently used seeds for the next round of fuzzing. Although this strategy is not optimal, its simplicity and effectiveness can achieve fuzzing objectives. For example, Krace \cite{xu2020krace} selects the two least used seeds each time and merges them into two different threads to explore data race errors. GREBE \cite{lin2022grebe} employs the PageRank \cite{Brin1998PageRank} algorithm to eliminate popular kernel objects, as testing these extensively explored objects often makes it harder to find bugs. \todo{This method is simple and efficient, and it can further reduce the search space for seed selection. However, seeds selected based on the minimum principle are not suitable for directed fuzzing of specific OS objects or vulnerabilities, as directed fuzzing typically focuses on a narrower range of code paths rather than rare paths.}

%However, when performing fuzzing targeted at a specific OS object or vulnerability (\ie directed fuzzing), the effectiveness of such methods may be limited.}



\subsubsection{Feedback-guided.}
A more straightforward principle is to select seeds that contribute the most to overall code coverage. For example, Syzkaller \cite{Syzkaller} is the first kernel fuzzer to guide seed selection using code coverage feedback, and it selects the seed with the largest relative coverage increase from corpus each time to be used in the next round of seed mutation. It is worth noting that the Syzkaller-based fuzzers in Table \ref{tab1} imply that they inherit Syzkaller's strategy if they innovate for seed selection and seed trim. Moonshine \cite{pailoor2018moonshine} prioritizes seed selection based on code coverage in descending order, ensuring that each selected seed is most beneficial for improving global coverage. HEALER \cite{sun2021healer} selects a syscall from the corpus that is `relevance'' to the current syscall sequence and inserts it into the sequence. This ``relevance'' is determined based on a syscall relation table preconstructed using coverage growth information from historical seeds, where an entry of 0 indicates no relation and 1 indicates a relevant relationship. During selection, HEALER leverages a predefined randomness parameter $\alpha$ to balance between exploitation (weighted selection based on the relation table, prioritizing syscalls that influence the current sequence) and exploration (random selection, disregarding the relation table). Syzvegas \cite{wang2021syzvegas} proposed an novel reward mechanism and used the Multi-Armed Bandit (MAB) algorithm to dynamically adjust the selection probability of seeds, prioritizing those that bring higher coverage and lower time costs for mutation, thus ensuring the selected seeds contribute to overall coverage improvement. \todo{Similarly, MAB is also utilized by MOCK \cite{Xu2024MOCKOK} to dynamically schedule the selection of seeds with higher coverage and within the time overhead. In addition, MOCK combines the context-aware dependency relation constructed by the neural network model on the basis of these seeds that trigger high coverage to select more compact seeds from the corpus each time, resulting in the selection of seeds with both kernel state and the ability to improve the coverage metric.}

Futhermore, in order to better guide fuzzing towards the target site \todo{(\ie specific OS object or vulnerability)}, one principle is to customize feedback metrics for the target site to direct the evolution of seed selection. For instance, CONZZER \cite{CONZZER2022context} and DDRace \cite{Yuan2023DDRace} designed thread interleaving feedback metrics tailored for data race bugs. They select seeds from the corpus that trigger more of these custom feedback metrics for each new round of mutation. Syzscope \cite{zou2022syzscope} defines high-risk impact and prioritizes selecting candidate seeds that expose this impact through KASAN. This type of seed selection strategy can constrain the evolution direction of the seeds to always point towards the target site. The principle of tailored feedback can effectively guide the direction of seed selection, but it requires researchers to carefully design and accurately calculate feedback metrics. Otherwise, the fuzzer may struggle to approach the target site, resulting in ineffective overhead.

%To better guide fuzzing towards the target site \todo{(\ie specific OS object or vulnerability)}, one principle is to customize feedback metrics for the target site to direct the evolution of seed selection. For instance, CONZZER \cite{CONZZER2022context} and DDRace \cite{Yuan2023DDRace} designed thread interleaving feedback metrics tailored for data race bugs. They select seeds from the corpus that trigger more of these custom feedback metrics for each new round of mutation. Syzscope \cite{zou2022syzscope} defines high-risk impact and prioritizes selecting candidate seeds that expose this impact through KASAN. This type of seed selection strategy can constrain the evolution direction of the seeds to always point towards the target site.

%It is noteworthy that while using only general code coverage (such as branch coverage and block coverage) as a guiding mechanism for seed selection contributes little to directed fuzzing, it is still useful for improving overall code coverage. Therefore, we still review this method. For example, Moonshine \cite{pailoor2018moonshine} prioritizes seed selection based on code coverage in descending order, ensuring that each selected seed is most beneficial for improving global coverage. Syzvegas \cite{wang2021syzvegas} proposed an novel reward mechanism and used the Multi-Armed Bandit (MAB) algorithm to dynamically adjust the selection probability of seeds, prioritizing those that bring higher coverage and lower time costs for mutation, thus ensuring the selected seeds contribute to overall coverage improvement. \todo{Similarly, MAB is also utilized by MOCK \cite{Xu2024MOCKOK} to dynamically schedule the selection of seeds with higher coverage and within the time overhead. In addition, MOCK combines the context-aware dependency relation constructed by the neural network model on the basis of these seeds that trigger high coverage to select more compact seeds from the corpus each time, resulting in the selection of seeds with both kernel state and the ability to improve the coverage metric.}

\subsubsection{Shortest Distance.}
Another seed selection strategy for directed fuzzing is the shortest distance principle. Specifically, this strategy requires researchers to first construct a call graph for kernel objects and then use the distance to the target site as the primary criterion for seed selection. Semfuzz \cite{you2017semfuzz} is the first fuzzer in the OSF to use the shortest distance principle for seed selection. It constructs the call graph by modifying GCC to collect call information during kernel compilation, and it uses the inverse of the distance from each candidate input's reachable functions to the vulnerable function as the priority. It selects the highest priority input for mutation each time. However, since Semfuzz's target site is limited to PoC-related vulnerable functions, it cannot fully execute OSF. SyzDirect \cite{tan2023syzdirect} employs static analysis to comprehensively identify interesting target sites within the kernel, constructs seed templates for reaching these sites, and combines the shortest distance principle to guide seed selection for directed fuzzing.

Seed selection based on the shortest distance principle is the most straightforward way to achieve directed fuzzing, but it also has the problem of not accurately determining which inputs can actually reach the target location. Consequently, it still wastes time on test cases that do not reach the target, leading to a waste of resources \cite{Huang2022BEACONDG, Zong2020FuzzGuardFO}. A good practice, Syzdirect \cite{tan2023syzdirect}, is to construct a template that describes the details of the seed composition for the target site, including function types, parameters, \etc This template can be used to verify the direction of seed evolution. Therefore, when the fuzzer gets stuck in ineffective local mutations, the template can guide the fuzzer to directly remove the seed from the corpus, helping it to escape the local mutation predicament. Hence, regardless of which of the above principles is adopted, it is best to consider a direction correction method when designing the seed selection strategy, continuously verifying whether the selected seeds are effectively moving towards the target site.

\subsubsection{Similarity Clustering.}
The similarity clustering approach groups or classifies seeds based on their shared features and assigns selection probabilities to each category according to fuzzing target. Methods such as minimum frequency, feedback-guided, and shortest distance inherently belong to metric feedback-based seed selection strategies, which prioritize early exploration of seeds that enhance specific metrics. However, these methods are prone to local optima and struggle to adapt to collaborative fuzzing scenarios requiring integrated multi-input interactions. To mitigate these issues, StateFuzz \cite{zhao2022statefuzz} clusters seeds with similar characteristics and ensures equal probability for selecting seeds across different clusters, thereby alleviating local optima. Furthermore, SATURN \cite{Xu2024Saturn} categorizes the corpus by device functionality (\eg printers, keyboards, storage devices) and dynamically selects seeds that enable host-device interaction based on the currently attached device type, preventing potential seed interaction conflicts during collaborative testing. Existing similarity clustering-based methods focus predominantly on clustering or classification, often employing random selection probabilities across categories. While they address challenges like local optima and collaborative testing, they still risk overlooking "valuable" seeds. 

% subsection 6
\subsection{Seed Trim}
\todo{Seed trim, also known as seed minimization, removes parts of the seed that do not contribute to the fuzzing objectives—such as researcher-defined feedback, vulnerability discovery, or proximity to the target site—while maintaining stable coverage \cite{Abdelnur2010SpectralFE,AFL,Peachtech}. For example, removing syscalls in a syscall sequence that do not contribute to defined targets or shortening the length of argument.} Seed trim is considered a critical step in ensuring fuzzing efficiency, as redundant seeds waste computational resources that could be used to thoroughly explore code regions. Since the problem of seed minimization has been proven to be NP-hard \cite{Rebert2014OptimizingSS}, existing OSF approaches typically use three types of heuristic principles to address the seed minimization problem: feedback-based, distance-based, and crash-based principles. Table \ref{tab1} shows fuzzers that optimize Seed trim, with `-' symbols indicating studies that do not explicitly mention optimization strategies.

%Seed Trim refers to removing redundant seeds and preserving them in the corpus \cite{Abdelnur2010SpectralFE,AFL,Peachtech}. Seed Trim is considered as a seed minimization problem because redundant seeds waste computational resources that could be used to thoroughly explore code areas. This problem has been proven to be NP-hard \cite{Rebert2014OptimizingSS}. Similar to seed selection, existing OSF approaches typically use three types of heuristic principles to address the seed minimization problem: feedback-based, distance-based, and crash-based principles. Table \ref{tab1} shows fuzzers that optimize Seed Trim, with `-' symbols indicating studies that do not explicitly mention optimization strategies.



%\textbf{The feedback-based principle} involves adding a seed to the corpus only after its coverage is stable and thoroughly minimized when a new coverage-triggering seed is discovered \cite{Syzkaller}. This principle is intuitive but often closely tied to the mutation phase, leading to significant computational resource waste \cite{wang2021syzvegas,Jang2023ReUSB}.

\textbf{The feedback-based principle} \todo{focuses on identifying seed sets that enhance feedback metrics, such as coverage, while simultaneously removing ineffective seeds. This approach requires consideration of two key aspects: 1) promptly eliminating seed sets that do not contribute to coverage improvement; and 2) simplifying the contributing seed sets by removing individual seeds that do not aid in coverage enhancement. Some works \cite{Syzkaller,Song2019PeriScopeAE,sun2021healer,Xu2024MOCKOK} evaluate the "value" of seeds by executing the seed set (a syscall sequence) in the corpus. If the syscall sequence does not contribute to coverage improvement, it is directly removed from the corpus; if it does improve coverage, the shortest contributing sequence is further extracted (\ie by removing individual non-contributing syscalls). While the principle behind this method is straightforward and intuitive, its efficiency is a significant concern due to the vast search space and the current lack of a method to quickly identify individual ineffective seeds \cite{wang2021syzvegas,Jang2023ReUSB}.}

\textbf{The distance-based principle} aims to address the challenges of directed fuzzing \cite{wu2018fuze,chen2019slake,hao2023syzdescribe}. It computes the reachable distance to the target site by constructing call graphs or creates seed templates that trigger the target site to filter out irrelevant seeds. This principle can reduce unnecessary exploration space due to the higher directional. However, it may not fully capture dynamic execution paths and runtime behaviors, affecting the accuracy of the filtering results. Additionally, the paths to the target site can be highly complex and dependent on multiple uncertain factors, causing some important seeds to be mistakenly filtered out \cite{Huang2022BEACONDG, Zong2020FuzzGuardFO}. Therefore, this method requires removing kernel objects outside the target site range to improve call graph construction efficiency and carefully extracting dependencies between seeds to ensure the accuracy of the minimization process.

\textbf{The crash-based principle} is applied after a crash is discovered, iteratively removing seeds that do not contribute to the crash by preserving the state of each seed generation and using seed replay. This method aims to increase the probability of crash reproduction but can also remove seeds with potential dependencies, leading to inconsistencies between the paths triggered by the minimized seeds and the original ones \cite{Jang2023ReUSB}.

% subsection 7
\subsection{Seed Update}
\label{Update}
Generation- and mutation-based are two common methods for seed updating \cite{Mans2018TheAS,Sutton2007FuzzingBF}. In OSF, seed update strategies focus more on mutation-based methods or a combination of both to enhance the depth of OS fuzzing. In this section, we will outline and review the application of these three strategies in OSF.

\subsubsection{Generation}
%The use of generation-based seed updating strategies in kernel fuzzing can be traced back to the seminal work of Koopman et al. \cite{Koopman1997ComparingOS}, who compared the robustness of operating systems with a limited set of manually selected syscall test cases. In OSF, generation-based OS fuzzers \cite{Trinity,KernelFuzzer2016,Weaver2015perf,schwarz2018automated} define input models through syscall grammar (\eg Gen.(1) in Table \ref{tab1}). These grammars define the parameter types and value ranges required for each syscall in a template form, thus providing the fundamental elements for seed updating.

\todo{The seed update strategy based on generation requires predefining seed usage rules to guide the generation of at least syntactically correct seeds. This method is particularly suitable for seeds that are structured, limited in number, or challenging to mutate accurately. Consequently, it is often applied in syscall-based (kernel) and I/O data-based (driver) fuzzing. In kernel fuzzing, generation-based operating system fuzzers \cite{Trinity,KernelFuzzer2016,schwarz2018automated} define a seed usage template based on the syntax of syscalls (\eg Gen.(1) in Table \ref{tab1}). This template specifies the name, type, argument types, and value ranges for each syscall, thereby providing the fundamental elements for seed updates.}

Another generation-based fuzzers ((\eg Gen.(2) in Table \ref{tab1})) extracts seed models that trigger target program sites to enhance the accuracy of directed fuzzing. For example, DIFUZE \cite{2017DIFUZE} uses static analysis to extract structural models of user space and driver interactions, enabling the construction of precise syscalls and parameter data structures for the target driver code. ACTOR \cite{fleischer2023actor} designed a flexible domain-specific language (DSL) to express and encode various vulnerability templates. These templates describe the triggering conditions for specific types of vulnerabilities, such as memory access errors and reference counting errors. Specifically, ACTOR records memory operations (referred to as ``actions'') during the fuzzing process based on vulnerability templates and attempts to recombine and rearrange these actions to generate new seeds that are more likely to trigger vulnerabilities.

% \begin{figure}[!t]
%         \includegraphics[width=0.99\linewidth]{img/mutation.pdf}
%         % \vspace{-5pt}
%         \caption{Mutation}
%         \label{img:mutation}
% \end{figure}

\subsubsection{Mutation}
Mutation-based strategies require designing multiple mutation algorithms (mutators) to update seeds. Unlike userland fuzzing, constructing complete syscall templates and accurate kernel seed models is often time-consuming and error-prone. Therefore, most operating system fuzzer tend to adopt mutation-based update strategies to explore deeper code paths. Mutation object can be classified into four categories: Syscall, Argument, Thread, and Other.

\textbf{Syscall.}
Syscall mutations are used in fuzzers that interact via syscalls, including adding, deleting, replacing, and reordering syscalls. Adding involves inserting an additional syscall into an existing syscall sequence, such as inserting a \texttt{read} between \texttt{ioctl} and \texttt{write}. Deleting involves removing a syscall from the sequence, for example, removing a \texttt{write} after a \texttt{read} instead of removing the \texttt{read} before the \texttt{write}. Replacing refers to substituting a commonly used resource, such as replacing the \texttt{ioctl} interface. Reordering involves randomly changing the order of one or more syscalls. Fuzzers (such as Razzer \cite{jeong2019razzer}, HEALER \cite{sun2021healer}, \etc) use Syzkaller as a mutation engine typically employ this method as a fundamental mutation operator. Early Syzkaller mutated syscalls in a randomized manner, which tended to ignore the dependencies between syscalls, resulting in the mutated syscall sequences becoming invalid. Therefore, some fuzzers \cite{pailoor2018moonshine,sun2021healer,Hao2022DemystifyingTD} focus on analyzing and extracting dependencies between syscalls to reduce the likelihood of syscall sequences becoming invalid after mutation.

\textbf{Argument.}
Argument mutation refers to performing mutation operations such as bit flip, byte reservation, byte replacement, and buffer fulfillment on syscall arguments and API arguments provided by the Hypervisor for testing (\eg the QTest framework used to support QEMU unit testing \cite{QTest}). Bit flip is a commonly used mutator for argument mutation, enabling quick argument changes by flipping specified or multiple random bits. Another mutator performs reservation and replacement on random bytes or variables \cite{JANUS2019fuzzing,Hydra2020finding,Liu2023LFuzz}. Despite the simplicity and ease of use of this method, its randomness limits the effectiveness of the fuzzer. Therefore, a more stable approach is to retain or completely replace the values of known mutable bytes or variables. For instance, GREBE \cite{lin2022grebe} reserve or replace the argument based on the original PoC in order to trigger more similar vulnerabilities. In addition, buffer fulfillment can be used for the variable-length argument in network syscall. For example, SemFuzz \cite{you2017semfuzz} caused an Use-After-Free vulnerability in kernel code that would otherwise handle skb.len properly by filling the \texttt{buf} argument of the \texttt{sendto} syscall to more than 512 bytes of data.

\textbf{Thread Interleaving.}
Data race is a common vulnerability in the kernel and kernel file system, and it is difficult to trigger concurrent access to shared data using only syscall- or argument-based mutators.  In order to identify data race behavior in the kernel or kernel file system, it is necessary to analyze the interleaving between two or more threads. Previous thread interleaving algorithms on userland testing use SKI \cite{Fonseca2014SKIEK} or PCT algorithms \cite{Burckhardt2010PCT} to schedule threads. The principle is to use hardware breakpoints to hang memory access threads, and subsequently randomly select a thread or schedule a high-priority thread to perform thread interleaving. This approach focuses only on user threads and has the disadvantages of missing race conditions and exploding search paths. To solve this problem, kernel fuzzer uses different techniques to improve kernel thread interleaving:

For random thread interleaving, Razzer \cite{jeong2019razzer} uses hardware breakpoints to interleave threads by adding two new hypercalls to the Hypervisor: \texttt{hcall\_set\_bp} and \texttt{hcall\_set\_order}, where \texttt{hcall\_set\_bp} instructs to set the breakpoint's virtual CPU and the breakpoint's address, and \texttt{hcall\_set\_order} sets the order in which threads are executed. Razzer uses these two hypercalls to control the order in which threads are executed, thus enabling random interleaving of threads. Krace \cite{xu2020krace} employs a low-invasion method for thread interleaving. First, \todo{syscall sequences} are generated for multiple different threads, and then these \todo{syscall sequences} are combined in an interleaved manner without disrupting the relative order of the \todo{syscall sequences} within individual threads to protect the original dependencies. Finally, delay injection is used to suspend the current thread at a memory access point for a period of time (picked at a random time from the designed ring buffer structure) to mutate the execution order of the multiple threads. CONZZER \cite{CONZZER2022context} takes a similar approach, exploring different interleaving possibilities by a random run of two functions specified to contain memory access instructions.

Random thread interleaving does not systematically search for interleaving possibilities and tends to perform redundant interleaving. To overcome this challenge, Segfuzz \cite{jeong2023segfuzz} disassembles a group of interleaved threads into multiple segments, subsequently performs syscall or argument mutators on the instructions within each segment, and finally merges them into new thread interleavings to fully explore the interleaving possibilities of each group of threads. It is worth noting that each segment consists of up to four memory instructions (\cite{Lu2008LearningFM} statistics that 92.4\% of concurrency bugs are due to the execution order of up to four memory accesses), and the relative order of the instructions remains fixed after decomposition. This approach improves the depth of thread interleaving exploration and but is limited to detecting data race vulnerabilities triggered by 4 memory access instructions \cite{Lu2008LearningFM}.

In addition, a different way of thread interleaving is adopted for directed fuzzing. As described in Section \ref{Section4.3}, directed fuzzing guides the testing path by constructing the distance between the current execution path and the target site. For example, DDRace \cite{Yuan2023DDRace} models control flow distance and data flow distance feedback metrics to guide the mutator in generating single-threaded syscall sequences accessing shared data and uses the proposed Race Pair Interleaving Path (RPIP) metrics as a priority to schedule multi-thread delays. In contrast to the above thread interleaving approaches, such approaches usually dedicate efforts to a specific vulnerability model, depending on program analysis techniques or by proposing feedback metrics related to the vulnerability to guide the thread interleaving.

\begin{figure*}[!t]
        \centering
        \subfigure[The definition of a task.]{
                \includegraphics[width=0.33\linewidth]{img/task_definition.pdf}\label{img:task_definition}}
        \hspace{20pt}\vline\hspace{20pt}
        \subfigure[An instantiated task.]{
                \includegraphics[width=0.51\textwidth]{img/task_instance.pdf}\label{img:task_instance}}
        \caption{A task for fuzzing RTOS}
\end{figure*}

\textbf{Other.}
The above mutation methods mainly update for syscall. However, syscall is unable to convey some detailed information, such as priority, execution state, and also unable to simulate the behavior of device drivers. For example, Rtkaller \cite{shen2021rtkaller} first generates a new syscall sequence using syscall- and argument-based mutator, and then constructs the basic execution unit-task of real time os (RTOS). As shown in Figure \ref{img:task_definition}, a task refers to execution units in rtos, comprising multiple syscall sequence accompanied with runtime priority (programs' execution order) and concurrency intensity (the number of the syscall sequences). According to the task definition in Fig.\ref{img:task_instance} first a new syscall sequence is generated using syscall and argument mutation and then Rtkaller replaces the priority of the four programs using random numbers to monitor the kernel functional modules related to real-time. \todo{Similarly}, Hydra \cite{Hydra2020finding} and janus \cite{JANUS2019fuzzing} employ argument-based mutators (\eg bit flip, \etc) to change meta data extracted from File system images and syscall-based mutators to generate manipulation of file system syscall sequence. VD-Guard \cite{Liu2023VDGuard}, Hypercube \cite{schumilo2020hyper}, V-shuttle \cite{pan2021V-shuttle}, VDF \cite{henderson2017vdf}, VIRTFUZZ \cite{Huster2024ToBoldly} and HYPERPILL \cite{Bulekov2024HYPERPILLFF} use argument-based mutators to alter I/O channel data to generate test cases for simulating the behavior of device drivers.

Seed update in OSF mainly focuses on mutation-based approaches. In addition, a strategy combining generation and mutaion expects to perform mutations directly on the basis of generated high-quality seeds to enhance the effectiveness of the seed renewal process.

% \begin{table} % 表格开始
%         \centering % 表格居中显示
%         \footnotesize
%         \caption{Feedback Categories in OSF.} % 表头标题
%         \vspace{-0.3cm}
%         \label{tab2} % 表格标签，便于引用

%         \begin{tabular}{ccl} % c表示单元格内容居中，l表示靠左，这里有两列，所以cc，如果是三列就是ccc或cll，根据自己

%                 \toprule % 顶部的线，这里可以定义粗细、toprule{1.5ptx}
%                 \multicolumn{1}{m{3cm}}{\centering Feedback} &                                                                                                                                                                                                                         % 中间的1.5cm表示第列宽度
%                 \multicolumn{1}{m{4cm}}{\centering Metric}   &
%                 \multicolumn{1}{m{4cm}}{\centering Fuzzers}                                                                                                                                                                                                                            \\

%                 \midrule % 中间的线
%                 \multirow{9}*{code coverage}                 & statement coverage                  & \cite{jeong2019razzer}, \cite{song2020agamotto}, \cite{zhao2022semantic}                                                                                                          \\

%                 \cline{2-3}

%                 ~                                            & \multirow{2}*{basic block coverage} & \cite{cesarano2023iris}, \cite{fleischer2023actor}, \cite{Syzkaller}, \cite{ma2022printfuzz}, \cite{maier2021bsod}, \cite{song2020agamotto}, \cite{Hung2024BRFFT},              \\
%                 ~                                            & ~                                   & \cite{shen2022drifuzz}, \cite{kim2020hfl}, \cite{you2017semfuzz}, \cite{schwarz2018automated}, \cite{Jang2023ReUSB}\\

%                 \cline{2-3}

%                 ~                                            & \multirow{2}*{edge coverage}        & \cite{zhao2022statefuzz}, \cite{shen2022tardis}, \cite{pan2021V-shuttle}, \cite{bulekov2023FUZZNG}, \cite{peng2020usbfuzz}, \cite{Syzkaller}, \cite{maier2021bsod},               \\
%                 ~                                            & ~                                   & \cite{wang2021syzvegas}, \cite{tan2023syzdirect}, \cite{pailoor2018moonshine}, \cite{Liu2023VDGuard}, \cite{Liu2023LFuzz}                                                         \\

%                 \cline{2-3}

%                 ~                                            & path coverage                       & \cite{chen2022sfuzz}, \cite{schumilo2017kafl}                                                                                                                                     \\

%                 \cline{2-3}

%                 ~                                            & \multirow{3}*{branch coverage}      & \cite{chen2020koobe}, \cite{sun2021healer}, \cite{shen2021rtkaller}, \cite{jeong2023segfuzz}, \cite{xu2020krace}, \cite{schumilo2021nyx}, \cite{henderson2017vdf},                \\
%                 ~                                            & ~                                   & \cite{myung2022mundofuzz}, \cite{bulekov2022morphuzz}, \cite{CONZZER2022context}, \cite{Hydra2020finding}, \cite{JANUS2019fuzzing}, \cite{shen2022drifuzz}, \cite{liang2020xafl}, \\
%                 ~                                            & ~                                   & \cite{wu2018fuze}, \cite{Xu2024MOCKOK}, \cite{Bulekov2024HYPERPILLFF}\\

%                 \midrule
%                 \multirow{4}*{thread coverage}               & alias coverage                      & \cite{xu2020krace}                                                                                                                                                                \\

%                 \cline{2-3}

%                 ~                                            & interleaving segment coverage       & \cite{jeong2023segfuzz}                                                                                                                                                           \\

%                 \cline{2-3}

%                 ~                                            & concurrent call pair coverage       & \cite{CONZZER2022context}                                                                                                                                                         \\

%                 \cline{2-3}

%                 ~                                            & race pair interleaving path         & \cite{Yuan2023DDRace}                                                                                                                                                             \\

%                 \midrule
%                 \multirow{6}*{custom}                        & critical object coverage            & \cite{lin2022grebe}                                                                                                                                                               \\

%                 \cline{2-3}

%                 ~                                            & state coverage                      & \cite{Hydra2020finding}, \cite{JANUS2019fuzzing}, \cite{zhao2022statefuzz}, \cite{zhao2022semantic}                                                                               \\

%                 \cline{2-3}

%                 ~                                            & action feedback                     & \cite{fleischer2023actor}                                                                                                                                                         \\

%                 \cline{2-3}

%                 ~                                            & probe model feedback                & \cite{wu2023devfuzz}                                                                                                                                                              \\

%                 \cline{2-3}

%                 ~                                            & capability feedback                 & \cite{chen2020koobe}                                                                                                                                                              \\ % &用来区分列，\\用来区分行

%                 \cline{2-3}

%                 ~                                            & DMA operation feedback              & \cite{Liu2023VDGuard}                                                                                                                                                             \\

%                 \bottomrule
%         \end{tabular}
% \end{table}

%The combination of generation and mutation aims to generate valid seeds with generation and then collaboratively update the seeds utilizing Mutation. For instance, Hydra \cite{Hydra2020finding} first uses the semantic assistance of argument types to generate syscalls (\eg \texttt{open}, \texttt{write}, \etc) and valid argument values (\eg integer values representing ranges, enumeration-type variables, \etc) specific to filesystem operations, which avoids being rejected by error-checking code at an early stage. Based on the generated syscall sequence, Hydra uses the argument-based mutator to update the arguments and add a random syscall at the end of the sequence, which ensures the state continuity of the updated syscall sequence as well as increasing the diversity of the seeds. Healer \cite{sun2021healer} utilizes static analysis to construct a relation table of syscalls from syzlang, which is used to guide the generation of new useful syscalls after a decrease in the gain of mutation. Another work that assists in syscall generation using static analysis is PrIntFuzz \cite{ma2022printfuzz}, which generates a syscall template with more information than syzlang. This template adds information for fault injection (data, fault codes, and interrupt signals) on top of syzlang, with the aim of generating syscall sequences specialized in handling faults for the mutation phase. Additionally, DriFuzz \cite{shen2022drifuzz} combines concolic and force execution to generate golden seeds for driver fuzzing in the first place, solving the problem that seeds based on mutation updates are difficult to pass through the full driver validation chain.
    

\subsubsection{Gen.+Mut.}
Recent advancements in fuzzing research have adopted a synergistic hybrid methodology integrating both generation-based and mutation-based strategies to address two critical challenges: (1) resolving efficiency bottlenecks caused by invalid initial seeds in domain-specific configurations, and (2) consistently producting variants of these effective seeds. This dual-mechanism framework demonstrates particular efficacy in directed fuzzing scenarios requiring targeted seed construction. The operational pipeline consists of two stages: the generation component synthesizes structurally valid seeds by leveraging domain-specific knowledge, while the mutation component systematically explores adjacent input spaces through combinatorial mutators.

For instance, Hydra \cite{Hydra2020finding} first uses the semantic assistance of argument types to generate syscalls (\eg \texttt{open}, \texttt{write}, \etc) and valid argument values (\eg integer values representing ranges, enumeration-type variables, \etc) specific to file system operations, which avoids being rejected by error-checking code at an early stage. Based on the generated syscall sequence, Hydra uses the argument-based mutator to update the arguments and add a random syscall at the end of the sequence, which ensures the state continuity of the updated syscall sequence as well as increasing the diversity of the seeds. \todo{HEALER \cite{sun2021healer} utilizes static analysis to construct a syscall relationship table from syzlang, which is used to directly generate syscalls that have dependencies on the current syscall sequence after mutation gains diminish, rather than continuing to execute low-yield mutation methods. Another work that employs static analysis to assist in generating syscalls is PrIntFuzz \cite{ma2022printfuzz}. It extends syzlang by adding fault injection information (such as data, fault codes, and interrupt signals) to generate syscall sequences related to fault handling. This allows the mutation algorithm to be directly applied to useful test cases, avoiding prolonged trial and error caused by relying solely on mutations. Additionally, DriFuzz \cite{shen2022drifuzz} combines concolic execution and forced execution to generate golden seeds that can pass the data validation phases in driver code. This approach addresses the issue of input rejection caused by seed update strategies based solely on mutation when faced with complex validation code logic. VideZZo \cite{Liu2023ViDeZZoDV} generates context-dependent I/O messages based on the proposed lightweight grammars, and applies the proposed 3 types of mutators with different granularities to extend the diversity of messages, \ie intra-message mutators, inter-message mutators, and group-level mutators. These 3 classes of mutators are similar to the syscall, argument-based mutation, which essentially wraps and applies its basic mutators (\eg delete, change order, bit flip) to a specific domain. BRF \cite{Hung2024BRFFT} extracts eBPF domain knowledge (\eg validator rules) and syscall dependencies to generate semantically correct eBPF programs, and then mutates the syscalls on top of the generated programs, solving the problem that seeds generated by previous kernel fuzzers are difficult to pass the eBPF validator efficiently. MOCK \cite{Xu2024MOCKOK} employs a neural network model to dynamically learn syscall sequences with context-aware dependencies to guide guide generation and mutation, which solves the problem of lack of context in the seeds updated by previous work. SATURN \cite{Xu2024Saturn} first dynamically extracts the file\_operations structure of device drivers using kallsyms and kcov, achieving precise mapping of syscall sequences (\eg \texttt{ioctl\$printer}) and their parameters (\eg valid file paths like \texttt{/dev/device\_name}). This approach addresses the inefficiency of initial seeds in USB driver fuzzing. During the mutation phase, SATURN products variants of these sequences through syscall-based and argument-based mutators, thereby exploring the input space for a class of usb driver fuzzing.}


The major overhead of the combined generation and mutation approach comes from preliminary seed analysis. This overhead is worth investing if the goal of fuzzing is to focus on specific issues in the OS, such as a single vulnerability type, a limited number of functional modules, and file operations or driver verification chains with continuous state features.


% subsection 9
\subsection{Feedback Mechanism}
Feedback is used to guide the direction of seed evolution. In our classification, feedback is categorized into code coverage, thread coverage, and custom coverage (as shown in Table \ref{tab2}). Since code coverage has been exhaustively reviewed and summarized in existing surveys \cite{Li2018FuzzingAS, Mans2018TheAS, Liang2018FuzzingSO}, we briefly discuss the acquisition of code coverage in OS and focus on kernel-related feedbacks.

\subsubsection{Code Coverage.}
Code coverage acquisition in OSF relies mainly on kcov (described in subsection \ref{subsection4.2}), as its task-level execution-based nature allows it to support more accurate collection of single syscall coverage \cite{vyukov2018kcov}. The use of kcov requires Linux version 4.6, gcc 6.1.0 and higher, or any version of Clang supported by the kernel. Therefore, the fuzzer must consider additional instrumentation methods for out-of-scope kernel versions or port kcov directly to the target version of the kernel \cite{shi2019industry}. It is worth noting that kcov is not capable of collecting all kernel coverage, and there are problems such as the kernel not being fully booted during the driver boot enumeration phase and the lack of support for soft/hard interrupt coverage acquisition.
To address this problem, \cite{schumilo2017kafl,wu2023devfuzz,ma2022printfuzz, zhao2022semantic,schumilo2021nyx} compute code coverage by using execution information such as branch instruction jumps, calls, and destination addresses recorded by the Intel PT, thus capturing instruction-level trace information during program execution.

% \begin{table} % 表格开始
% \centering % 表格居中显示
% \caption{Feedback in OSF.} % 表头标题
% \label{tab2} % 表格标签，便于引用

% \begin{tabular}{ccl} % c表示单元格内容居中，l表示靠左，这里有两列，所以cc，如果是三列就是ccc或cll，根据自己

% \toprule % 顶部的线，这里可以定义粗细、toprule{1.5ptx}
% \multicolumn{1}{m{3cm}}{\centering Feedback} &  % 中间的1.5cm表示第列宽度
% \multicolumn{1}{m{4cm}}{\centering Metric} &
% \multicolumn{1}{m{4cm}}{\centering Fuzzers}\\

% \midrule % 中间的线
% \multirow{11}*{code coverage} & statement coverage & Razzer, Agomotto, Dr.Fuzz. \\
% ~ & \multirow{3}*{basic block coverage} & Chizpurfle, IRIS, ACTOR, usb-fuzzer, \\
% ~ & ~ & PrintFuzz, BSOD, Agomotto, DriFuzz, HFL, \\
% ~ & ~ & Semfuzz, Automated Detection, KernelGPT. \\

% ~ & \multirow{3}*{edge coverage} & StateFuzz, Tardis, V-Shuttle, FUZZNG, USBFuzz, \\
% ~ & ~ & usb-fuzzer, BSOD, SyzVegas, Syzdirect, \\
% ~ & ~ & Moonshine. \\

% ~ & path coverage & Sfuzz, KAFL \\
% ~ & \multirow{3}*{branch coverage} & Koobe, HEALER, Rtkaller, Segfuzz, Krace, NYX, \\
% ~ & ~ & VDF, MundoFuzz, Morphuzz, CONZZER, Hydra, \\
% ~ & ~ & JANUS, DriFuzz, X-AFL, FUZE. \\

% \midrule
% \multirow{3}*{thread coverage} & alias coverage & Krace \\
% ~ & interleaving segment coverage & Segfuzz \\
% ~ & concurrent call pair coverage & CONZZER \\
% \midrule
% \multirow{5}*{custom coverage} & critical object coverage & GREBE \\
% ~ & state coverage & Hydra, JANUS, StateFuzz, Dr.Fuzz \\
% ~ & action feedback & ACTOR \\
% ~ & probe model feedback & DEVFUZZ \\
% ~ & capability feedback & KOOBE \\ % &用来区分列，\\用来区分行

% \bottomrule
% \end{tabular}
% \end{table}

% \begin{table}[!h] % 表格开始，添加[!h]使表格更紧凑地贴近上下文
%         \centering
%         \scriptsize
%         \caption{Feedback Categories in OSF.}
%         \vspace{-0.3cm} % 减少caption和表格之间的空隙
%         \label{tab2}
    
%         \begin{tabular}{ccl}
%             \toprule
%             \centering Feedback & Metric & Fuzzers \\
    
%             \midrule
%             \multirow{9}{*}{code coverage} 
%             & statement coverage & \cite{jeong2019razzer}, \cite{song2020agamotto}, \cite{zhao2022semantic} \\ 
%             \cline{2-3}
    
%             & \multirow{2}{*}{basic block coverage} 
%             & \cite{cesarano2023iris}, \cite{fleischer2023actor}, \cite{Syzkaller}, \cite{ma2022printfuzz}, \cite{maier2021bsod}, \cite{song2020agamotto}, \cite{Hung2024BRFFT} \\ 
%             & ~ & \cite{shen2022drifuzz}, \cite{kim2020hfl}, \cite{you2017semfuzz}, \cite{schwarz2018automated}, \cite{Jang2023ReUSB} \\ 
%             \cline{2-3}
    
%             & \multirow{2}{*}{edge coverage} 
%             & \cite{zhao2022statefuzz}, \cite{shen2022tardis}, \cite{pan2021V-shuttle}, \cite{bulekov2023FUZZNG}, \cite{peng2020usbfuzz}, \cite{Syzkaller}, \cite{maier2021bsod} \\ 
%             & ~ & \cite{wang2021syzvegas}, \cite{tan2023syzdirect}, \cite{pailoor2018moonshine}, \cite{Liu2023VDGuard}, \cite{Liu2023LFuzz} \\ 
%             \cline{2-3}
    
%             & path coverage & \cite{chen2022sfuzz}, \cite{schumilo2017kafl} \\ 
%             \cline{2-3}
    
%             & \multirow{3}{*}{branch coverage} 
%             & \cite{chen2020koobe}, \cite{sun2021healer}, \cite{shen2021rtkaller}, \cite{jeong2023segfuzz}, \cite{xu2020krace}, \cite{schumilo2021nyx}, \cite{henderson2017vdf} \\ 
%             & ~ & \cite{myung2022mundofuzz}, \cite{bulekov2022morphuzz}, \cite{CONZZER2022context}, \cite{Hydra2020finding}, \cite{JANUS2019fuzzing}, \cite{shen2022drifuzz}, \cite{liang2020xafl} \\ 
%             & ~ & \cite{wu2018fuze}, \cite{Xu2024MOCKOK}, \cite{Bulekov2024HYPERPILLFF} \\ 
%             \midrule
    
%             \multirow{4}{*}{thread coverage} 
%             & alias coverage & \cite{xu2020krace} \\ 
%             \cline{2-3}
    
%             & interleaving segment coverage & \cite{jeong2023segfuzz} \\ 
%             \cline{2-3}
    
%             & concurrent call pair coverage & \cite{CONZZER2022context} \\ 
%             \cline{2-3}
    
%             & race pair interleaving path & \cite{Yuan2023DDRace} \\ 
%             \midrule
    
%             \multirow{6}{*}{custom} 
%             & critical object coverage & \cite{lin2022grebe} \\ 
%             \cline{2-3}
    
%             & state coverage & \cite{Hydra2020finding}, \cite{JANUS2019fuzzing}, \cite{zhao2022statefuzz}, \cite{zhao2022semantic} \\ 
%             \cline{2-3}
    
%             & action feedback & \cite{fleischer2023actor} \\ 
%             \cline{2-3}
    
%             & probe model feedback & \cite{wu2023devfuzz} \\ 
%             \cline{2-3}
    
%             & capability feedback & \cite{chen2020koobe} \\ 
%             \cline{2-3}
    
%             & DMA operation feedback & \cite{Liu2023VDGuard} \\ 
%             \bottomrule
%         \end{tabular}
%     \end{table}

\begin{table}
    \centering
    \scriptsize % 减小字体大小
    \caption{Feedback Categories in OSF.}
    \label{tab2}
    \vspace{-0.3cm}
    \begin{tabular}{lll}
    \toprule
    \multicolumn{1}{m{1.5cm}}{\raggedright Feedback} &  % 中间的1.5cm表示第列宽度
    \multicolumn{1}{m{2.5cm}}{\raggedright Metric} &
    \multicolumn{1}{m{6.5cm}}{\raggedright Fuzzers}\\
    %Fuzzers & File System & Input Type & Status \\
    \midrule
    \multirow{4}*{Code Cov.}
    & Statement Cov. & \cite{jeong2019razzer,song2020agamotto,song2020agamotto} \\

    ~ & Basic Block Cov. & \cite{cesarano2023iris,fleischer2023actor,Syzkaller,ma2022printfuzz,maier2021bsod,song2020agamotto,Hung2024BRFFT,shen2022drifuzz,kim2020hfl,you2017semfuzz,schwarz2018automated,Pustogarov2020ExvivoDA,yang2023kernelgpt,Jang2023ReUSB, Huster2024ToBoldly} \\

    ~ & Edge Cov. & \cite{zhao2022statefuzz,shen2022tardis,Song2019PeriScopeAE,pan2021V-shuttle,bulekov2023FUZZNG,peng2020usbfuzz,Syzkaller,maier2021bsod,wang2021syzvegas,Pustogarov2020ExvivoDA,tan2023syzdirect,pailoor2018moonshine,Liu2023VDGuard,Liu2023LFuzz}\\ 

    ~ & Path Cov. &  \cite{schumilo2017kafl} \\ 

    ~ & Branch Cov. & \cite{chen2020koobe,sun2021healer,shen2021rtkaller,jeong2023segfuzz,xu2020krace,schumilo2021nyx,henderson2017vdf,myung2022mundofuzz,bulekov2022morphuzz,CONZZER2022context,Hydra2020finding,JANUS2019fuzzing,shen2022drifuzz,liang2020xafl,wu2018fuze,Xu2024MOCKOK,Xu2024Saturn,Bulekov2024HYPERPILLFF} \\ 
    \hline

    \multirow{4}*{Thread Cov.}
    & Alias Cov. & \cite{xu2020krace} \\

    ~ & Interleaving Segment Cov. & \cite{jeong2023segfuzz} \\ 

    ~ & Concurrent Call Pair Cov. & \cite{CONZZER2022context} \\

    ~ & Race Pair Interleaving Path & \cite{Yuan2023DDRace} \\
    \hline
    
    \multirow{6}*{Custom}
    & Critical Object Cov. & \cite{lin2022grebe} \\

    ~ & State Cov. &  \cite{Hydra2020finding,JANUS2019fuzzing,zhao2022statefuzz,zhao2022semantic} \\

    ~ & Action Feedback & \cite{fleischer2023actor} \\

    ~ & Probe Model Feedback & \cite{wu2023devfuzz} \\

    ~ & Capability Feedback & \cite{chen2020koobe} \\

    ~ & DMA Operation Feedback & \cite{Liu2023VDGuard} \\

    \bottomrule
    \end{tabular}
\end{table}


\begin{figure*}[!t]
        \centering
        \subfigure[No AIP exists in this thread interleaving context.]{
                \includegraphics[width=0.45\linewidth]{img/AIP_1.pdf}\label{img:AIP_1}}
        \hspace{10pt}\vline\hspace{10pt}
        \subfigure[An AIP ($wi\_3 \rightarrow ri\_2$) exists in this thread interleaving context.]{
                \includegraphics[width=0.45\textwidth]{img/AIP_2.pdf}\label{img:AIP_2}}
        \caption{An example of alias instruction pair coverage.}
\end{figure*}

\subsubsection{Thread Coverage}
Similar to thread mutation discussed in Subsection \ref{Update}, the discovery of concurrency vulnerabilities using solely code coverage as the only feedback mechanism is also limited. Therefore, it is necessary to dedicate a feedback mechanism related to thread Interleaving to guide the fuzzer in generating the seed that triggers the data race vulnerability. Existing works \cite{xu2020krace,CONZZER2022context,jeong2023segfuzz,Yuan2023DDRace} present distinct thread-related coverage metrics:

\cite{xu2020krace} proposes alias instruction pair coverage, or called AIP coverage (the first feedback mechanism related to thread coverage in OSF), as a metric of the degree of thread interleaving. An alias instruction pair is defined as a pair of instructions to read or write the same memory address in two concurrent threads, which is formalized using $A\leftarrow(wi\_x,t\_1)$ to indicate that there exists a $wi\_x$ instruction to write memory $A$ in thread $t\_1$, and that if there exists a $ri\_x$ instruction to read memory $A$ in another thread, \ie $A\leftarrow(ri\_y,t\_2)$, then ($wi\_x \rightarrow ri\_y$) denotes an alias instruction pair. For example, Figure \ref{img:AIP_1} and \ref{img:AIP_2} illustrates a group of memory access instructions and 2 threads, where the data race vulnerability to the shared data \texttt{V[length]} is triggered if and only if \texttt{A=C}. Figure \ref{img:AIP_1} and \ref{img:AIP_2} represent 2 different thread interleaving contexts, where (a) indicates that no alias instruction pair is covered due to the thread interleaving process does not read or write to the same memory address sequentially, and (b) indicates that the instruction pair ($wi\_3 \rightarrow ri\_2$) is covered due to the $ri\_3$ and \texttt{B=A+2} ($ri\_2$) read or write to the memory pointed to by \texttt{B} at the same time. A new syscall sequence is generated when the AIP coverage is no longer growing, allowing the fuzzer to focus on exploring the thread concurrency of the new syscall sequence at each time instead of focusing only on the sequential execution of the syscall.

However, although \cite{xu2020krace} is possible to fully interleave AIPs, it is possible that race condition misses due to ignoring the runtime context (\eg call stack, state of variables and data structures, \etc) of the instruction. For instance, the value of \texttt{A} could be dynamically determined by the context, \ie the instruction $wi\_1$ in Figure \ref{img:AIP_1} has the possibility of writing 2 to the memory address of \texttt{A}. Therefore, the opportunity to discover the data race vulnerability is missed by using AIP coverage. To solve this problem, \cite{CONZZER2022context} measures the thread interleaving using concurrency call pair coverage (CCP coverage) that records the call contexts of two function. Specifically, a CCP contains \texttt{func a} and \texttt{func b} call contexts $(CallCtx\_a1, CallCtx\_b1)$. For example, in thread 1 of Figure \ref{img:AIP_1}, $CallCtx\_a1 = (main \rightarrow ModuleX \rightarrow FuncA)$ determines $A =1$. If there is also another $CCP=(CallCtx\_a2, CallCtx\_b2)$ where $CallCtx\_a2 = (main \rightarrow ModuleZ \rightarrow FuncA)$, it could be explored for a different value of \texttt{A}, \eg $A=2$. In this case, CPP coverage explores more interleaved combinations of instructions through the call context, thus reducing the probability of a data race vulnerability.


\begin{figure*}[!t]
        \centering
        \subfigure[A pair of concurrent threads.]{
                \includegraphics[width=0.30\linewidth]{img/IS_1.pdf}\label{img:IS_1}}
        \hspace{10pt}\vline\hspace{10pt}
        \subfigure[An instance of the interleaving segment of (a).]{
                \includegraphics[width=0.23\textwidth]{img/IS_2.pdf}\label{img:IS_2}}
        \hspace{10pt}\vline\hspace{10pt}
        \subfigure[The possible thread interleaving using IS.]{
                \includegraphics[width=0.23\linewidth]{img/IS_3.pdf}\label{img:IS_3}}
        \caption{An example of interleaving segment coverage.}
\end{figure*}

Interleaving segment coverage (IS coverage) \cite{jeong2023segfuzz} reduces the exponential search space of thread interleaving and concentrates on exploring interleaved accesses to a memory address by narrowing the instruction set of interleaving to segments. Figure \ref{img:IS_1} and \ref{img:IS_2} demonstrate an uninitialized access bug of \texttt{\&v} through the interleaving segment. In contrast to \cite{xu2020krace} and \cite{CONZZER2022context}, IS focuses on a minimum instruction tuple each time, \ie performs \texttt{(read,read,write)} operations on the same address. As shown in Figure \ref{img:IS_3}, in this minimum instruction tuple, the uninitialized access bug is missed (failing to cover \texttt{\#S2}) because AIP incorrectly infers that $(wi\_3 \rightarrow ri\_1)$ and $(wi\_3 \rightarrow ri\_2)$ are identical in \texttt{\#S1}. Likewise, function-level based CCP could also miss \texttt{\#S2}, this is because CCP keeps track of simultaneously executing function pairs and is not aware of fine-grained interleaving at the instruction level. Overall, IS coverage reveals a systematic and efficient thread coverage. In the discussion of Subsection \ref{Update}, however, IS coverage could miss more complex concurrency scenarios due to its limitation of interleaving up to 4 instructions.

In addition, in the study of fuzzing special concurrency vulnerabilities (\eg concurrency UAF vulnerability), \cite{Yuan2023DDRace} proposes a new metric based on AIP, Race Pair Interleaving Path (RPIP), to trace the target side (\ie the potential UAF code areas) in multiple race pairs and value changes. Specifically, RPIP complements AIP by adding detail information, \ie an instruction tuple \texttt{(instr. type, thread no., shared var. value)}, to trace the accesses of multiple shared variables simultaneously. Meanwhile, all traced AIPs are categorized by shared variables and merged into the interleaving path of shared variables, which is used to measure the interleaving situation of shared variables in the target side. Although RPIP is used to guide fuzzing to uncover concurrency UAF vulnerability, the metric is still applicable to other concurrency vulnerabilities such as concurrency null pointer deference vulnerability. It is important to note that RPIP could have path explosion problem in the huge kernel code base, so this type of vulnerability usually relies on program analysis to extract the potential vulnerability side in advance.


%Since traditional code-coverage-driven fuzzing suffers from inefficiency and ineffectiveness in directed fuzzing (especially kernel bug exploitation), OSF at this stage aims to customize a new feedback metric to address these challenges. Prior to designing feedback mechanism, it is necessary to extract its structural information, which can be implemented using existing tools \cite{Bai2019EffectiveSA, Caballero2012UndangleED, Chipounov2011S2EAP, Shoshitaishvili2016SOKO}. As shown in Table \ref{tab2}, the existing custom feedback in the OSF includes both custom coverage and model-driven feedback.
\subsubsection{Custom Coverage.}
\todo{Traditional code coverage-driven fuzzing faces inefficiency and ineffectiveness in directed fuzzing (\eg kernel vulnerability exploitation fuzzing). To address these issues, existing OSF approaches have introduced various custom feedback mechanisms. Generally, custom feedback is highly correlated with the characteristics of the fuzzing task, which can be enhanced by incorporating other techniques, such as program analysis \cite{Bai2019EffectiveSA, Caballero2012UndangleED, Chipounov2011S2EAP, Shoshitaishvili2016SOKO}, into the fuzzing process. As shown in Table \ref{tab2}, the custom feedback mechanisms in OSF include custom coverage and domain-aware feedback.}

Custom coverage is a quantifiable feedback metric involving critical object (CO) coverage and State coverage, where CO coverage refers to the rate of hitting critical kernel objects in the crash report that can trigger a vulnerability (CO can be identified by backward taint analysis), which addresses the problem that code-coverage-driven feedback is limited to discovering the multiple error behaviors of a bug. State coverage instantiates the context in which the PUT is running, \eg Monitor's feedback \cite{Hydra2020finding}, file system metadata properties \cite{JANUS2019fuzzing}, state space of variables \cite{zhao2022statefuzz}, and function error codes \cite{zhao2022semantic}. These works enable directed fuzzing by quantifying the context related to the target under test as state coverage.

\todo{In contrast to coverage mechanisms, there is a category of feedback mechanisms called domain-aware feedback. Domain-aware refers to a domain knowledge built specifically to tackle a type of challenge, and is used to enhance the depth of fuzzing on such challenges.} For example, Action \cite{fleischer2023actor} refers to a 3-tuples \texttt{(Action type, addr., size)} dedicated to recording memory operations, revealing the specific syscall sequence that triggers a memory-related vulnerability by focusing on higher semantic memory operations. Probe model \cite{wu2023devfuzz} automatically generates seeds that can guide a fuzzer to properly initialize a device driver under test (DUT) through symbolic execution, which in turn effectively reach and test the functional code of the driver. Capability \cite{chen2020koobe} refers to the attributes of a specific vulnerability (\eg memory violation vulnerability), including: write address, size, and value. Specifically, Capability-driven fuzzing takes a PoC as input and analyzes the path and trigger conditions leading to an Out-Of-Bound (OOB) vulnerability via binary symbolic execution \cite{Chipounov2011S2EAP} to guide the seed mutation and generation. DMA operation feedback \cite{Liu2023VDGuard} indicates whether a DMA-related function is hit to guide a seed mutation, which is because vulnerabilities in hypervisor are mainly distributed in DMA-related operations. Therefore, DMA operation feedback is also typically an important feedback indicator for hypervisor fuzzing.

In summary, while code-coverage-driven fuzzing has achieved significant success, relying solely on code coverage as feedback is insufficient for OSF to effectively reach the expected testing code areas. Therefore, designing feedback relevant to the research question is an essential step. Last but not least, it does not mean that code coverage loses its significance, but instead remaining it as an infrastructure for OSF and fine-tuning it in combination with the use of new coverage metrics is the dominant research trend at this stage.

\subsection{Vulnerability Analysis}
\label{Vulnerability}

\subsubsection{Types}

Vulnerabilities found in OSFs are categorized into four types, as shown in Table \ref{tab1}, including memory violation, concurrency bug, logic bug, and \todo{other}.

Memory violation involves illegal access and operation of memory, including spatial and temporal vulnerabilities. Spatial memory errors refer to memory accesses that are outside the scope of their allocation, such as OOB and buffer overflow, \etc These errors occur when a program attempts to access a memory address that is outside the legal memory zone, which can cause the program to crash or incur undefined behavior. Temporal memory errors occur when memory is used at an incorrect moment, \eg UAF. Memory violation vulnerabilities are the most common type of error in OSFs, primarily because the C/C++ language provides direct control over the underlying memory management but lacks automated security checking mechanisms \cite{Unicorefuzz2019,chen2020koobe}. Thus, memory violation is also a major target of the current OSF and exploitation research.

Concurrency bug refers to the lack of proper synchronization mechanisms in multi-threaded or multi-process environments, which can lead to data inconsistency, deadlock, data race, double-fetch, and other race conditions, \etc Unlike userland fuzzing, the efficiency of exploring concurrency bugs in OS is limited by the large code base and complexity of the kernel, which makes it difficult to sufficiently detect various types of concurrency bugs, which could lead to memory violation errors (\eg traditional buffer overflows, use-after-free, \etc), resulting in serious kernel security attacks \cite{jeong2019razzer}.

Another category of vulnerabilities are kernel logic errors, which refer to bugs caused by incorrect coding logic that can stem from programmer error, incorrect algorithms, or incomplete, and may lead to problems such as outputting incorrect results, entering infinite loops, or skipping critical operations. For example, virtual devices entering infinite loops when receiving invalid data (Invalid Data Transfer) \cite{henderson2017vdf,pan2021V-shuttle,Liu2023VDGuard}, functions being called multiple times when not designed to be reentrant resulting in data inconsistencies (Reentrant Problems) \cite{myung2022mundofuzz}, multiple releases or incorrect formatting in interrupt request handling (Double IRQ Free and request irq format error) \cite{wu2023devfuzz}, attempts to disable already disabled devices \cite{wu2023devfuzz}, divide-by-zero operations \cite{pan2021V-shuttle}, and assertion errors in the \texttt{BUG\_ON} macro \cite{wu2023devfuzz,2017DIFUZE,pailoor2018moonshine,schumilo2020hyper}.

\todo{In addition to the aforementioned three categories of vulnerabilities, there are other relatively rare but equally critical OS vulnerabilities.}

\todo{\textbf{Privilege Protection Vulnerabilities} involve unauthorized operations or illegal access to protected resources, potentially leading to sensitive data leakage or compromising system integrity. Typical examples include vulnerabilities where user space attempts to access high-privilege memory regions within the kernel (User Memory Access \cite{wu2023devfuzz,2017DIFUZE}), denial of service vulnerabilities that prevent the kernel from providing its normal services (Kernel DoS \cite{schumilo2020hyper}), and vulnerabilities related to illegal writes to non-volatile memory (Writing to Non-Volatile Memory \cite{2017DIFUZE}).}

\todo{\textbf{Processor Exceptions} occur when the processor attempts to execute undefined instructions or when the instruction encoding or structure does not conform to processor specifications, leading to abnormal system termination. Common examples of such vulnerabilities include Invalid Opcode \cite{wu2023devfuzz} and General Protection Faults (GPFs) \cite{sun2021healer,lin2022grebe,maier2021bsod,zhao2022semantic}.}

\todo{\textbf{Data Integrity Vulnerabilities} refer to instances where data in the system becomes corrupted or inconsistent. This typically occurs when data is inadvertently modified during storage or transmission, resulting in unusable or incorrect data states, as seen in cases of Data Corruption \cite{pailoor2018moonshine}.}

\subsubsection{Monitor}
In terms of vulnerability monitoring, Muench et al. \cite{Muench2018Avatar2AM} track and categorize observable crashes and hangs into different classes, but this approach makes it difficult to detect vulnerabilities that do not immediately trigger a crash, such as buffer overflows. Another solution typically uses existing sanitizer\cite{Song2018SoKSF}tools for monitoring, such as KASAN\cite{KernelAddressSanitizer2019}, UBSAN \cite{UBsan}, ASan \cite{ASAN}, MSan \cite{MemorySanitizer2020}, \etc It is worth noting that KASAN may miss out-of-bounds accesses between neighboring legal memory regions or memory objects. For the situation where the sanitizer is not available (\eg Hypervisor \cite{henderson2017vdf,schumilo2020hyper,schumilo2021nyx}, Android OS \cite{2017DIFUZE}), it is generally required to record a sequence of crash-causing test cases entered into the target OS, and later on analysts debug to identify and categorize the bugs of the type.

For concurrency bug monitoring, the strategy of prior works \cite{Chen2020MUZZTG,Johansson2018RandomTW,Vinesh2019ConFuzzACF} is to integrate third-party checkers (\eg TSan \cite{TSan} and KCSAN \cite{KCSAN}) in fuzzing. However, such third-party checkers have been reported with many false positives \cite{CONZZER2022context} due to the omission of special synchronization primitives such as message queues and conditional variables \cite{ThreadSanitizerDR}. To improve the precision of monitor for concurrency-related vulnerabilities, customization of monitor using dynamic lockset analysis \cite{Savage1997EraserAD,jeong2019razzer,xu2020krace,jeong2023segfuzz}, happens-before analysis \cite{happensbefore}, and lockdep \cite{lockdep} to customize the monitor is the current mainstream solution.

%For the detection of such errors, Muench et al. \cite{Muench2018Avatar2AM} track and categorize observable crashes and hangs into different classes, but this approach makes it difficult to detect vulnerabilities that do not immediately trigger a crash, such as buffer overflows. Another solutions typically utilizes sanitizers \cite{Song2018SoKSF} to enable monitoring of memory violation vulnerabilities, but sanitizers such as ASAN \cite{ASAN}, MSAN \cite{MemorySanitizer2020}, \etc require special modifications for use in the kernel. Therefore, the dominant approach is to use KASAN \cite{KernelAddressSanitizer2019} embedded in the kernel. It is worth noting that KASAN may miss out-of-bounds accesses between neighboring legal memory regions or memory objects. For situations where KASAN is not available (\eg Hypervisor \cite{henderson2017vdf,schumilo2020hyper,schumilo2021nyx}, Android OS \cite{2017DIFUZE,Chizpurfle2019}), it is generally required to record a sequence of crash-causing test cases entered into the target OS, and later on analysts debug to identify and categorize the bugs of the type.

