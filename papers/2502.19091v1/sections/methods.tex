The Nexus architecture is a modular design that integrates a single root {\em Supervisor} agent alongside multiple {\em Task Supervisors} and {\em Worker} agents. These components are arranged within a hierarchical execution graph to ensure efficient task delegation, flexibility, and scalability. The remainder of this section details the architecture's core components, overall operational workflow, and distinguishing features.

\subsection{Core Components and Structure}
Nexus architectures rely on a single root {\em Supervisor} that mediates interactions between the user and the network of agents. Its primary responsibilities include: ($i$) {\bf task decomposition}, which involves breaking high-level prompts into actionable subtasks; ($ii$) {\bf agent selection}, where subtasks are delegated to the most appropriate {\em Worker} agent (or {\em Task Supervisor}, when instantiated) based on each agent's specialization; and ($iii$) {\bf result aggregation}, i.e., collecting outputs from delegated subtasks and synthesizing them into a cohesive final response.

{\em Worker} agents are specialized problem solvers tasked with executing the subtasks assigned by their supervisor. Each {\em Worker} operates in an isolated environment and possesses a unique {\em specialization} defined by its system message and the associated tools, environment variables, and {\em ad hoc} functions. Their key capabilities include: ($i$) utilizing dedicated tools (e.g., web search, shell commands, file manipulation) or knowledge bases to perform domain-specific operations; ($ii$) iteratively refining intermediate results through interactions with these tools or external data sources; and ($iii$) returning structured, task-specific outputs to the appropriate supervisor upon completion.

In addition to these agents, Nexus incorporates a global {\em Memory} mechanism along with a set of external {\em Tools}. The {\em Memory} works as a centralized repository that stores partial results, metadata, and relevant instructions, ensuring that all agents maintain an up-to-date view of task progress. Although the {\em Memory} serves as a shared repository, Nexus enforces role-based access control: while the {\em Supervisor} has global access, a {\em Worker} agent is confined to its own event history, and a {\em Task Supervisor} can access all memory locations associated with its assigned agents. On the other hand, the external {\em Tools} provide agents with specialized functionalities, such as data processing pipelines or access to external computational resources, thereby fostering a uniform and transparent environment for managing complex workflows.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.6\linewidth]{images/supervisor}
    \caption{Overview of the Nexus architecture. A root {\em Supervisor} receives user prompts and decides whether to finalize the solution or delegate its execution. Tasks of moderate complexity can be handled by specialized {\em Worker} agents, while particularly intricate tasks can be coordinated by intermediate {\em Task Supervisors}. \emph{Memory} maintains a synchronized record of partial outputs and relevant context. Circled markers denote the three main loops that are entailed in the proposed workflow.}
    \label{fig:nexus}
\end{figure}

Figure~\ref{fig:nexus} depicts the overall architecture and workflow of the proposed Nexus framework. More formally, the architecture is modeled as a rooted directed graph, denoted by 

\begin{equation}
\Gamma = (V, E),
\end{equation}

which captures the relationships between various agents and components within Nexus. The vertex set $V$ is partitioned into the following three disjoint subsets:

\begin{equation}
V = S \cup T \cup W,
\end{equation}

where $S$ represents the set of {\em Supervisor} agents\textemdash with the unique root node $s \in S$\textemdash, $T$ denotes the set of {\em Task Supervisor} agents, and $W$ corresponds to the set of {\em Worker} agents. Based on these assumptions, the edge set

\begin{equation}
E \subseteq V \times V
\end{equation}

captures all relationships among agents defined within any given $\Gamma$. A critical element of this structure is the hierarchical relationship between two or more elements, which can be formalized by introducing a parent function defined as 

\begin{equation}
\varphi \colon V \setminus \{s\} \to V.
\end{equation}

For every node $v \in V \setminus \{p\}$, the directed edge 

\begin{equation}
(\varphi(v), v) \in E
\end{equation}

identifies the immediate supervisor-to-agent relationship between node $v$ and its parent node $\varphi(v)$. This relationship adheres to the following constraints: first, if $v \in T$, i.e., a {\em Task Supervisor}, then its parent $\varphi(v)$ must belong to $S$; second, if $v \in W$, then $\varphi(v)$ is either in $T$ or $S$. Consequently, this design guarantees that every agent, other than the root, has a unique predecessor, thus ensuring that there exists a unique directed path from the root $s$ to any node $v \in V$. In addition to these hierarchical relationships, the architecture also allows the inclusion of extra edges that capture non-hierarchical interactions between components. Although these communication edges do not necessarily conform to the strict parentâ€“child relationship, they are incorporated in such a way as to maintain the overall hierarchical integrity of $\Gamma$. To further clarify the hierarchical structure, let us define a level function as 
\begin{equation}
\ell \colon V \to \mathbb{N},
\end{equation}
which is determined recursively by setting \(\ell(s) = 0\) for the root and, for any other node \(v \in V \setminus \{s\}\), defining 
\begin{equation}
\ell(v) = \ell(\varphi(v)) + 1.
\end{equation}
Such a function assigns each agent a level based on its distance from the root, with the root at level 0, its immediate subordinates at level 1, and so on.

\subsection{Multi-Loop Workflow}
Nexus introduces an iterative process for task decomposition and execution, organized into three primary interaction loops, as depicted in Figure~\ref{fig:nexus} (numbered circled arrow markers).

\underline{\smash{\bf First Loop: User-Supervisor Interaction.}}
In the first loop, the user provides a high-level prompt to the {\em Supervisor}. The {\em Supervisor} interprets the request and outlines an initial task execution plan while soliciting user feedback to ensure that the evolving plan remains aligned with the user's objectives. This iterative exchange continues until the {\em Supervisor} is ready either to delegate subtasks to other agents or to finalize a solution.

\underline{\smash{\bf Second Loop: Supervisor-Agent Coordination.}}
In the second loop, the {\em Supervisor} (or a {\em Task Supervisor}, when applicable) assigns well-defined subtasks to {\em Worker} agents based on their specific characteristics and specialization. The {\em Worker} agents then generate intermediate outputs by interacting with the tools and resources available within their designated working environments. If a {\em Worker} fails to produce satisfactory results or encounters a bottleneck, the {\em Supervisor} revises the subtask instructions or reallocates the task to another agent. This iterative reassessment continues until the subtasks collectively meet the established quality criteria.

\underline{\smash{\bf Third Loop: Intra-Agent Operations.}}
The third loop operates within each {\em Worker} agent's internal environment. Upon receiving its assigned subtask, a {\em Worker} iteratively leverages relevant tools, local data structures, or external knowledge bases to refine its intermediate output. Once a sufficiently polished solution is achieved, the {\em Worker} relays the result back to its supervisor for integration or final synthesis.

In summary, Nexus combines a robust hierarchical framework with the flexibility to support diverse interaction patterns among agents and their operating environments. This design endows the framework with three fundamental properties:

\begin{itemize}
\item \textbf{Scalability\textemdash}The framework can seamlessly incorporate new agents or supervisory nodes as task complexity escalates.
\item \textbf{Modularity\textemdash}{\em Worker} agents operate independently, enabling the straightforward integration or replacement of domain-specific capabilities.
\item \textbf{Robustness\textemdash}Hierarchical delegation and iterative feedback loops minimize the impact of individual agent failures, as tasks can be reassigned or refined with minimal disruption.
\end{itemize}

\subsection{Framework Installation and Basic Usage}

To ensure reproducibility and encourage widespread adoption, Nexus is distributed as an installable Python package. Most users can install Nexus directly from PyPI by executing the following command to retrieve the latest stable release:

\begin{verbatim}
    pip install primisai
\end{verbatim}

Alternatively, developers interested in modifying the framework's core functionalities can clone the GitHub repository and install the package in {\em editable} mode as follows:

\begin{verbatim}
    git clone git@github.com:PrimisAI/nexus.git
    cd nexus
    pip install -e .
\end{verbatim}

Listing~\ref{lst:example_arch} provides an example of how to instantiate a simple three-agent architecture for code refactoring, comprising a {\em Supervisor} and two specialized \emph{Worker} agents.

\begin{lstlisting}[
    language=Python,
    basicstyle=\small\ttfamily,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{gray!5},
    xleftmargin=18pt,
    framexleftmargin=15pt,
    xrightmargin=5pt,
    frame=single,
    rulecolor=\color{gray},
    breaklines=true,
    breakatwhitespace=true,
    showstringspaces=false,
    tabsize=2,
    caption={A Python implementation demonstrating a three-agent Nexus MAS architecture for automated code refactoring.},
    label={lst:example_arch},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!50!black}\itshape,
    stringstyle=\color{orange}]
from primisai.nexus.core import Agent, Supervisor

# Configure large language model parameters.
llm_config = {
    "api_key": "your-api-key-here",
    "model": "model-name-here",
    "base_url": "model-url-here",
}

# Create the root supervisor named "ProgrammingTaskCoordinator".
coordinator = Supervisor("ProgrammingTaskCoordinator", llm_config)

# Instantiate specialized Worker agents with programming-specific system prompts.
code_analyzer = Agent(
    "CodeAnalyzer",
    llm_config,
    system_message="You are a coding expert specialized in static code analysis. Your task is to evaluate code quality, identify potential bugs, and suggest improvements."
)

code_refactorer = Agent(
    "CodeRefactorer",
    llm_config,
    system_message="You are a programming assistant skilled in code refactoring and optimization. Your goal is to enhance code efficiency, readability, and maintainability while preserving functionality."
)

# Register agents with the ProgrammingTaskCoordinator.
coordinator.register_agent(code_analyzer)
coordinator.register_agent(code_refactorer)

# Display the agent hierarchy.
coordinator.display_agent_graph()

# Initiate an interactive session for collaborative programming support.
coordinator.start_interactive_session()
\end{lstlisting}

In order o further highlight Nexus' flexibility, Listing~\ref{lst:example_arch_yaml} presents the same architecture defined via our dedicated YAML file support. This approach not only reduces development complexity and effort, but it also allows users to separate configuration from code, thereby enhancing readability and maintainability.

\begin{lstlisting}[
    language=my-yaml,
    basicstyle=\small\ttfamily,
    numbers=left,
    numberstyle=\tiny\color{gray},
    stepnumber=1,
    numbersep=10pt,
    backgroundcolor=\color{gray!5},
    xleftmargin=18pt,
    framexleftmargin=15pt,
    xrightmargin=5pt,
    frame=single,
    rulecolor=\color{gray},
    breaklines=true,
    breakatwhitespace=true,
    showstringspaces=false,
    tabsize=2,
    caption={A YAML configuration defining a three-agent Nexus MAS architecture for automated code refactoring..},
    label={lst:example_arch_yaml},
    keywordstyle=\color{blue}\bfseries,
    commentstyle=\color{green!50!black}\itshape,
    stringstyle=\color{orange}]
supervisor:
    name: ProgrammingTaskCoordinator
    type: supervisor
    llm_config:
      model: ${LLM_MODEL}
      api_key: ${LLM_API_KEY}
      base_url: ${LLM_BASE_URL}
    system_message: "You are the supervisor for programming tasks. Oversee code analysis and refactoring operations."
    children:
      - name: CodeAnalyzer
        type: agent
        llm_config:
          model: ${LLM_MODEL}
          api_key: ${LLM_API_KEY}
          base_url: ${LLM_BASE_URL}
        system_message: "You are a coding expert specialized in static code analysis. Evaluate code quality, identify bugs, and suggest improvements."
      - name: CodeRefactorer
        type: agent
        llm_config:
          model: ${LLM_MODEL}
          api_key: ${LLM_API_KEY}
          base_url: ${LLM_BASE_URL}
        system_message: "You are a programming assistant skilled in code refactoring and optimization. Enhance code efficiency, readability, and maintainability."
\end{lstlisting}

Interested readers can refer to the GitHub repository, available at \url{https://github.com/PrimisAI/nexus}, for advanced usage, additional instructions, and further examples.