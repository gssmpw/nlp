% Model-Based Environment Configuration (MBEC) aims to formalize and automate the process of configuring computing environments through a series of definitions and state transition functions. This section specifies the core concepts and functions of MBEC, ensuring both theoretical rigor and practical applicability.
% \textbf{M}odel-\textbf{B}ased \textbf{E}nvironment \textbf{C}onfiguration (MBEC) aims to formalize and automate the process of configuring computing environments. This is achieved through a series of definitions and state transition functions that ensure both theoretical rigor and practical applicability. This section specifies the core concepts and functions of MBEC.
% In modern software engineering, configuring environments efficiently and reliably presents great challenges due to the complexity and variety of software configurations. 
\vspace{-0.5em}

In this part, we formulate the task of the environment configuration.
% In this section, we provide a detailed definition and formalization of MBEC.
It involves identifying an appropriate \textbf{base image} ($B$) and a \textbf{configuration process} ($\Gamma$). The objective is to ensure that the final system state ($S_f$) successfully runs all the unit tests in the repository.
% MBEC consists of several key components, and we formalize each through well-defined concepts and state transition functions.
% This section introduces these core components and their formal definitions, ensuring theoretical rigor and practical applicability.
% MBEC aims to formalize the configuration process of computing environments through a series of well-defined concepts and state transition functions. This section outlines the core components and functions of MBEC, ensuring both theoretical rigor and practical applicability.
\vspace{-0.5em}

\subsection{State Transition}
\vspace{-0.5em}

\textbf{Environment State ($S$):}
% The environmental state ($S_i$) represents the current state of the computer system, including all variables, files, cache, etc. Any state ($S_i \in \mathcal{S}$).
The environmental state ($S$) represents the current state of the computer system, which encompasses all variables, files, cache, etc. Any state $S \in \mathcal{S}$, where ($\mathcal{S}$) denotes the set of all possible environment states.

% \textbf{Action Set ($A$):}
% Each action set ($A$) represents a series of commands ($C$) to be executed in the current state. Formally, an action set can be written as:
% \begin{equation}
% A = {C_1, C_2, \ldots, C_n}
% \label{eq:action_set}
% \end{equation}
\vspace{-0.5em}

\textbf{Command ($C$):} The command $C$ represents an individual instruction or action that can be executed in the environment through interfaces such as \texttt{bash}, thus directly changing the system state.
% A command may consist of multiple lower-level instructions that collectively modify the system state.
\vspace{-0.5em}

\textbf{State Transition Function ($\delta$):}
The state transition function ($\delta$) defines the process through which the system transitions from one state to another state upon execution of a given command, i.e., 
\begin{equation}
    \delta: \mathcal{S} \times \mathcal{C} \rightarrow \mathcal{S},\quad \delta(S, C) = S'
\end{equation}
Here, $S'$ is the new state after execution of command $C$.
% \begin{equation}
% \delta: \mathcal{S} \times \mathcal{A} \rightarrow \mathcal{S}
% \end{equation}
% \begin{equation}
% \delta(S, A) = S'
% \end{equation}
% Where $S$ is the current state, $A$ is the action set, and $S'$ is the new state after executing $A$.
\vspace{-0.5em}

\subsection{Base image}
\vspace{-0.5em}

% We can consider the base image ($B$) as being constructed from an initial empty state ($S_\emptyset$) through a series of actions:
\textbf{Empty initial state ($S_\emptyset$):}
The empty initial state ($S_{\emptyset}$) represents a completely unconfigured, bare operating system or a purely hypothetical state without applications and configurations.
This state is used for theoretical purposes to define the starting point of a system's configuration.
% The empty initial state ($S_\emptyset$) represents a fully unconfigured bare operating system or a pure state with no applications. Regarding the definition of this empty state, it can be considered a "hypothetical" state used for theoretical purposes. It can be expressed as:
$S_\emptyset \in \mathcal{S}$.
% Here, $\mathcal{S}$ denotes the set of all possible environment states.
\vspace{-0.5em}

\textbf{Base image ($B$):}
% The empty initial state ($S_{\emptyset}$) represents a fully unconfigured, bare operating system or a purely hypothetical state with no applications and configurations.
From the empty initial state ($S_\emptyset$), we can construct the base image $B$ by applying a series of actions. The base image $B$ is essentially the final state achieved by applying a sequence of instructions starting from $S_\emptyset$:
% The base image ($B$) can be redefined as the final state formed by applying a series of instructions ($C^{B}_1, C^{B}_2, \ldots, C^{B}_m$) starting from the empty state.
\begin{equation}
B = \delta^m(S_{\emptyset}, {C^{B}_1, C^{B}_2, \ldots, C^{B}_m})
\label{eq:base_image}
\end{equation}

% Here, $\delta$ is the state transition function, and ${C_1^B, C_2^B, \ldots, C_m^B}$ are the individual instructions that constitute the base image.
Here, ${C^{B}_1, C^{B}_2, \ldots, C^{B}_m}$ are the individual commands that constitute the base image.
\vspace{-0.5em}

\subsection{Configuration process and target state}
\vspace{-0.5em}

\textbf{Configuration Process ($\Gamma$):}
% The target state $S_f$ signifies the desired final configuration of the system after applying a sequence of action sets starting from the base image:
% Starting from the base image $B$, a series of actions are applied to transform the environment. After performing these actions, we obtain the resulting state $S_f$, which we name the resultant state.
The configuration process, denoted as $\Gamma$, involves transforming the environment starting from the base image $B$ by applying a series of actions. The result of this process is a state $S_f$, which we refer to as the resultant state. Formally, the configuration process can be represented as:
\begin{equation}
S_f = \delta^n\left(B, {C_1, C_2, \ldots, C_n}\right)
\end{equation}
% \begin{equation}
% \Gamma(B, \{A_1, A_2, \ldots, A_n\}) = S_f = \delta^n\left(B, \{A_1, A_2, \ldots, A_n\}\right)
% \end{equation}
Following this transformation, it is crucial to verify whether $S_f$ meets all the required conditions to be considered the target state. This verification is performed using the state verification function.

% \textbf{Dynamic Adjustment ($\alpha$):}
% The dynamic adjustment function modifies the instruction sequence based on real-time feedback to optimize the configuration process. 
% \begin{equation}
%     \alpha: \mathcal{S} \times \mathcal{F} \rightarrow \mathcal{A} 
% \end{equation}
% \begin{equation}
%     A' = \alpha(S, \mathcal{F})
% \end{equation}

\textbf{State verification ($\epsilon$):}
The state verification function ($\epsilon$) determines whether the resultant state ($S_f$) successfully runs all tests within the repository after executing the configuration process ($\Gamma$). It maps a given state ($S$) to a binary value indicating whether all tests could be run in the resultant configuration: $\epsilon(S)$ returns 0 if all tests are successfully run, and 1 otherwise.
If $\epsilon(S_f) = 0$, it indicates that the configuration process has finished and the resultant state $S_f$ is considered the \textbf{target state}. Otherwise, it means that $S_f$ does not meet the necessary conditions.
% \rdhu{[need cut?]}
% The state verification function ($\epsilon$) determines that the resultant state $S_f$ successfully runs all tests within the repository after executing the configuration process $\Gamma$. It maps a given state $S$ to a binary value indicating whether the resultant configuration meets the required conditions: $\epsilon: \mathcal{S} \rightarrow \{{0, 1}\}$, such that:
% \begin{equation}
% \epsilon(S_f) = \begin{cases}
% 1 & \text{if } S_f \text{ runs all the tests successfully}, \\
% 0 & \text{otherwise}.
% \end{cases}
% \end{equation}
% If $\epsilon = 1$, it indicates that the configuration process has succeeded and the resultant state $S_f$ is considered the \textbf{target state}. Otherwise, it means that $S_f$ does not meet the necessary conditions.

% \textbf{Rollback Mechanism ($\rho$):}
% In the event of a failure at any step, the rollback mechanism restores the environment to the last known valid state. 
% \begin{equation}
%     \rho: \mathcal{S} \times \mathcal{A} \rightarrow \mathcal{S}
% \end{equation}
% \begin{equation}
%     \rho(S, A_1, \ldots, A_k) = S_{k-1}
% \end{equation}
% In practice, each cmd command consists of a series of lower-level operations. If a command cannot execute atomically and fails midway, it results in uncertainty. Formally, let a command $A$ be composed of lower-level commands ${ C_1, C_2, \ldots, C_n }$.
