\begin{figure*}[ht!]
	\centering
	\includegraphics[width=1.0\textwidth]{figs/framework.pdf}
    
    \caption{An example process of \textbf{\tool}, which illustrates two main parts: \textbf{Event Stream} and \textbf{\tool}~\textbf{Workflow}. The Event Stream tracks the entire action-observation process, where green boxes represent system prompts, yellow boxes represent responses from the LLM agent including the actions, and blue boxes represent observations from the Runtime Environment. The shaded actions indicate configurations abandoned after \textbf{base image change}. In the Event Stream, the blue text indicates that the command starts running, the green text indicates that the command runs successfully, and the red text indicates that the command fails. The \textbf{\tool}~\textbf{Workflow} consists of the \textbf{internal environment} and the \textbf{external environment}. The internal environment serves as the actual configuration Docker-based sandbox, which builds an actual testing runtime environment. The external environment executes the action-observation process and assists in the configuration process within the internal environment.}
\label{figs:framework}
\end{figure*}


In this part, we introduce the design of \tool~and atomic configuration synthesis. As shown in \tool~Workflow in Figure \ref{figs:framework}, the dual-environment architecture consists of an external environment and an internal environment. The internal environment is a Docker container where the actual environment configuration is executed, while the external environment assists the internal environment in setting up the configuration. After successfully configuring the environment, the Dockerfile generator will create the Dockerfile.
% In this section, we will detail the design of each component separately.

\begin{figure*}[ht!]
	\centering
	\includegraphics[width=1.0\textwidth]{figs/sequence2dockerfile.pdf}
    
    \caption{An example of the Dockerfile generator to transfer the commands into a runnable Dockerfile.}
\label{figs:sequence2dockerfile}
\end{figure*}

\subsection{External environment}

$\bullet$ \textbf{Action-observation interaction}:
In each turn of the environment-agent interaction, the event history $E_t = {(a_1, o_1), (a_2, o_2), \ldots, (a_{t-1}, o_{t-1})}$ records the historical actions and observations up to time step $t$. Additionally, the sequence of successfully executed commands ${C_1, C_2, \ldots, C_n}$ helps remind the LLM agent of the current system state.

At time step $t$, given the event history $E_t$ and the sequence of successfully executed commands $C_1, C_2, \dots, C_n$, the LLM agent generates a response including an action $a_t$:
\begin{equation}
    a_t = \pi(E_t, {C_1, C_2, \ldots, C_n})
\end{equation}
where $\pi$ is the function of the LLM agent's decision.
The environment state then transitions based on the action $a_t$:
\begin{equation}
    S_{t+1} = \delta(S_t, a_t)
\end{equation}
This iterative process ensures that the LLM agent remains informed of the system's current state and makes decisions accordingly, facilitating effective multi-turn interaction within the environment. 

% $\bullet$ \textbf{Rollback mechanism}:
% When executing commands, the system may encounter scenarios where parts of a command succeed while others fail. We introduce the concept of the intermediate state and formalize the handling of such uncertainties.

% \textbf{Uncertain state ($S_u$):} Generally, a command ($C_k$) may consist of multiple parts.  We assume $C_k$ is composed of two parts, $C_{k,1}$ and $C_{k,2}$. If $C_{k,1}$ executes successfully, the system enters an intermediate state ($S_u$):
% \begin{equation}
%     \tilde{S}_k = \delta(S_{k-1}, C_{k,1})
% \end{equation}
% Here, $C_{k,1}$ is the part of the command already executed. This intermediate state is crucial because it represents a partially applied command. This state could lead to inconsistencies and further errors if not handled properly.

% % In practice, sometimes a special failure handling procedure ($A_{\text{fail}}$) may be triggered upon the failure of a command. Thus, the formal description is:
% If the remaining part $C_{k,2}$ fails, the system might transition to an \textbf{uncertain state} ($S_u$), especially if a special failure handling procedure ($C_{\text{fail}}$) is triggered. Thus, the formal description is:
% \begin{equation}
%     S_u = \delta(\tilde{S}_k, C_{\text{fail}}) \quad \text{if} \quad \delta(\tilde{S}_k, C_{k,2}) \ne S_k
% \end{equation}

$\bullet$ \textbf{Rollback ($\rho$)}:
As illustrated in Figure~\ref{figs:intro_framework}, commands $C_{fail}$ may lead to an \textbf{uncertain state} ($S_u$) if not successfully executed. When a command executes failed (i.e., the command returns a non-zero return code), the system transitions into an uncertain state as defined by:
\begin{equation}
    S_u = \delta(S_{k-1}, C_{fail})
\end{equation}
Here, $C_{fail}$ is the failed executed command.
If a command fails, the system will transition to the uncertain state $S_u$.
% \textbf{Rollback ($\rho$):} 
To avoid such uncertainty, we introduce \textbf{rollback} ($\rho$). In the event of a failure at any step, the rollback mechanism restores the environment to the last certain state:
\begin{equation}
\rho: \mathcal{S} \times \mathcal{C} \rightarrow \mathcal{S},\quad \rho(S_u, { C_1, C_2, \ldots, C_k }) = S_{k-1}   
\end{equation}
Specifically, each time an instruction ($C$) is executed, we utilize the ``\texttt{docker commit}'' command to take a snapshot of the current state. Once the instruction is completed, we check its return code. If the return code is not 0, it indicates a failure in executing the instruction, and we replace the image with the most recently committed one. Besides, some instructions, such as ``\texttt{cat}'', generally do not change the state of the environment, and thus, we do not apply the rollback mechanism to them. The complete list of these actions is shown in Appendix~\ref{safe_commands}.

$\bullet$ \textbf{Base image change}:
If the LLM agent identifies that the currently selected base image is incorrect or unsuitable during the environment configuration process, it can reselect the base image. Once a new image is chosen, all previous configurations become invalid, and the executed commands are cleared, necessitating a restart of the configuration process. For instance, as shown in Figure \ref{figs:framework}, when the LLM agent discovers that the ``\texttt{StrEnum}'' class cannot be imported through testing, which is only available in the Python standard library starting from version 3.11, it decides to reselect the base image to python:3.11.

$\bullet$ \textbf{Result processor}:
In each turn of the interaction, executing commands may generate extensive output (e.g., logs), which can greatly increase the burden of the LLM agent. Therefore, whenever such information is added to the event history, we truncate excessively long text, retaining only the initial and final sections up to a specific length.

$\bullet$ \textbf{Dockerfile generator}:
If the LLM agent successfully runs all tests in the repository in the internal environment, the configuration process needs to be recorded in a Dockerfile. Figure \ref{figs:sequence2dockerfile} illustrates the Dockerfile generator's operation. \ref{figs:sequence2dockerfile} (a) lists the internal commands actually executed in the internal environment, their return codes (e.g., \texttt{0} indicates success, otherwise failure), and the current directory (\texttt{dir}). \ref{figs:sequence2dockerfile} (b) shows the process of generating the Dockerfile.

The principles for the conversion process include the following steps, scanning all internal commands sequentially, and the line numbers mentioned below match the line number of Figure \ref{figs:sequence2dockerfile} (a):
\begin{enumerate}[nosep]
% \setlength{\itemsep}{0pt}
% \setlength{\parskip}{0pt}
% \setlength{\parsep}{0pt}
\item By default, use \texttt{python:3.10} as the base image.
\item For commands that run successfully (i.e., have a return code of \texttt{0}), prepend the command with ``\texttt{RUN}'' to form a Dockerfile statement (e.g., line 3). Commands that fail (i.e., have a return code other than \texttt{0}, such as line 4) are rolled back and not included in the Dockerfile. An exception is some commands typically do not change the current state (such as ``\texttt{cat}'' on line 2). These commands are not added to the Dockerfile. We show the details in Appendix \ref{safe_commands}.
\item If \texttt{dir} is not the root directory, use \texttt{cd} to change to that directory before running the command, as each Dockerfile statement runs in its own directory session.
\item If a base image change statement is encountered (e.g., line 5), discard all previous configurations and switch to the new base image.
\item If a code editing command is encountered (e.g., line 9), copy the patch and editing script into the Docker container before executing the editing command.
\item If an export statement for adding environment variables is encountered (e.g., line 13), convert it to a persistent \texttt{ENV} statement.
\item After all statements have been scanned, check for dependency installation commands and replace any unspecified versions (e.g., ``\texttt{B>=1.0,<2.0}'' in line 11) with the actual versions downloaded in the Docker container (e.g., ``\texttt{B==1.5.1}'' in the final Dockerfile of Figure~\ref{figs:sequence2dockerfile} (b)).
\end{enumerate}

\subsection{Internal environment}

As shown in the \tool~workflow of Figure \ref{figs:framework}, the internal environment consists of a Docker container with a base image $B$ and the code repository to be configured. According to the latest data\footnote{\url{https://w3techs.com/technologies/history_details/pl-python/3}}
 from 2025, we select Python 3.10 as our default Docker base image due to its increasing usage and wide application among all Python 3 versions. Additionally, we categorize the executable actions within the internal environment into five types: environment monitoring, dependency installation, bash commands, code editing, and test running.

$\bullet$ \textbf{Environment monitoring}:
It serves as the eyes of the LLM agent in the internal environment, allowing it to observe the current state of the environment. These commands usually do not change the state of the environment. For instance, commands like ``\texttt{ls}'' and ``\texttt{cat}'' are employed to inspect directories and files. Additionally, commands like ``\texttt{pip list}'' and ``\texttt{pipdeptree}''\footnote{\url{https://github.com/tox-dev/pipdeptree}} are utilized to get the installed version of third-party libraries in the current environment.
For example, in the fourth part of Event Stream in Figure \ref{figs:framework}, the LLM agent calls the ``\texttt{find}'' command to search for \texttt{requirements.txt} within the environment to determine which dependencies need to be installed.
% This non-intrusive monitoring ensures that the Agent maintains an up-to-date understanding of the environment's configuration without inadvertently modifying it.

$\bullet$ \textbf{Dependency installation}:
It is primarily used to install the third-party libraries necessary for running tests, including libraries managed by both ``\texttt{pip}'' and ``\texttt{apt-get}''. To avoid dependency conflicts that may arise when downloading multiple packages, we implement a dependency management system in the external environment. Initially, the third-party libraries to be downloaded are added to a waiting list. If there are different constraints for the same library (e.g., ``\texttt{A$>=$1.0}'' and ``\texttt{A$<$1.0}''), they will be moved to a conflict list, and the LLM agent will determine the appropriate version to download.

We design a set of tools for the LLM agent to manage the installations. For instance, as shown in Figure \ref{figs:framework}, the action ``\texttt{waitinglist addfile}" adds all elements from \texttt{requirements.txt} to the waiting list, while executing the ``\texttt{download}'' command, third-party libraries are taken one by one from the waiting list and installed in the internal environment. The installation commands (e.g., ``\texttt{pip install}" and ``\texttt{apt-get install}") are executed. If the installation succeeds, the state of the environment is updated; if it fails, a rollback is performed. We show all our designed tools in Appendix \ref{Repo2Run_tools}.

$\bullet$ \textbf{Test running}:
It detects whether the current environment is successfully configured by running ``\texttt{pytest}'' unit tests. If the state ($S_f$) of the current environment passes the tests, it indicates that the LLM agent has successfully configured the environment within the Docker container, and the internal environment's process concludes. Conversely, if some tests fail, the error information is communicated back to the LLM agent, allowing it to perform further configurations and adjustments based on the errors.

$\bullet$ \textbf{Code editing}:
It allows the LLM agent to modify the code within the internal environment, including codes inside and outside the repository. Besides, to prevent the LLM agent from spuriously running the tests by directly modifying or deleting the test files, we do not permit the LLM agent to modify or delete the original test files within the repository.
For instance, Figure~\ref{figs:framework} demonstrates code editing to correct a syntax error resulting from the improper use of double quotes in a Python f-string.

$\bullet$ \textbf{Bash commands}:
Aside from the commands above, we also enable the LLM agent to directly invoke bash commands to interact with the internal environment. As shown in Figure \ref{figs:framework}, the LLM agent uses the command ``\texttt{export PYTHONPATH=/repo/src}''.

