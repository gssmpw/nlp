\subsection{Implementation} \label{impl}
%
\TN is developed with 5249 lines of code in Rust, utilizing \textit{rustc} and fully integrating with \textit{Cargo}, Rust's official package manager. \TN focuses on target files that can be compiled into an executable or a library \cite{cargotarget54online}. Using \textit{Cargo}, we address dependency issues prior to compilation and identify all targets in the package suitable for analysis. Compilation of these target files is done through \textit{rustc}. Upon completion, \TN is activated within the \texttt{after\_analysis} callback function of the \textit{rustc} driver, which is triggered by \textit{rustc} following the generation of Rust compiler's MIR, allowing us to employ the resulting MIR data as input for \tyanalyzer to start the analysis.


The workflow of \TN{} can be divided into two phases: 1) detecting if the type conversion generates a problematic \texttt{dst\_ty}, and 2) checking if the problematic type is accessed. With pairs of type sets generated by \analysisone, we can find a problematic type conversion even when a generic type is involved. With the alias graph built by \analysistwo, we can track how the pointer can be accessed. The type conversion pairs and alias graph are stored in \pcg, which accelerates the interprocedural analysis to obtain the information of external functions. For interprocedural analysis, we introduced a depth limitation to avoid the path explosion problem. We set the path length to 1 (tracing only the immediate caller or callee function), aligning with that in Rupta~\cite{rupta}.
