\section{Introduction}

Rust~\cite{RustLang} is an emerging programming language known by its strict enforcement of type safety and memory safety through compile-time checking, without sacrificing runtime performance. Since memory safety issues in unsafe languages such as C and C++ have been known to lead to catastrophic consequences, Rust has become an appealing solution to replace C and C++, and it has been adopted in major open-sourced projects such as the Linux kernel~\cite{LinuxKernel} and the Firefox browser~\cite{MozillaFirefox}. Recently, the White House also calls for adoption of memory-safe programming languages such as Rust to secure the cyberspace~\cite{whitehouse}.

Rust is fundamentally divided into two separate sub-languages: safe Rust and unsafe Rust~\cite{safeunsafe}. Safe Rust enforces strict compile-time checks to maintain memory safety and type safety. However, these checks can be excessively restrictive, blocking some essential but risky operations like accessing raw pointers. To address this, Rust introduces the {\tt unsafe} keyword for such situations. When employing unsafe Rust, it falls upon the programmer to uphold memory safety since the typical compile-time checks are circumvented.

Similar to traditional programming languages such as C/C++, Rust also supports type conversions~\cite{TypeConv22online}, where a variable is initially converted from type $A$ to type $B$  and subsequently accessed as type $B$. Safe Rust guarantees the security of these conversions through robust static type checking and strict ownership guidelines. Rust automatically infers the types of variables and expressions from their context and use. Also, the ownership feature helps ensure memory and concurrency safety by tracking the lifetime and borrowing at compile time~\cite{Ownership}. Nevertheless, there are instances where programmers need to use unsafe Rust for certain type conversions, especially those that involve pointers. For instance, since direct reference conversions are not allowed, conversions must be first made at the raw pointer level and then converted back to references using unsafe Rust. Consequently, these conversions may cause severe memory corruption problems similar to those found in C/C++~\cite{cve-2023-3079, cve-2023-4762, cve-2024-1939}. In the last five years, RUSTSEC~\cite{rustsec} has reported 32 type confusion bugs that can lead to various memory-safety issues such as data leaks, uninitialized memory, and Out-Of-Bounds (OOB) memory access.


Despite extensive research on type confusion bugs in C and C++~\cite{jeon2017hextype, haller2016typesan, duck2018effectivesan, lee2015type}, studies on type confusion bugs in Rust are still lacking due to three significant challenges. First, the conversion of data types between functions complicates type analysis, and this complexity cannot be addressed using traditional interprocedural analysis. For instance, when a type constructor function creates an instance of a type that is then handed off to another function for an unsafe type conversion, traditional interprocedural analysis fails to track the constructor function as it is absent from the conventional call graph~\cite{rupta}. Therefore, a new call graph is needed to identify this type of interprocedural type conversion.

{Second, predicting all possible concrete types that can replace a generic type in Rust is inherently challenging. Unlike C and C++, Rust uses trait bounds~\cite{Traitand70:online} to constrain generic types, ensuring they conform to specific behaviors and capabilities. It adds complexity since trait bounds can have implicit and recursive dependencies on other traits. Moreover, concrete types may encompass composite types like \texttt{struct}. As a result, a method of generic type resolution that adheres to the trait bounds is needed.}

Third, identifying \bugs requires establishing whether the pointer alias remains valid after type conversion, which is essential for our bug verification process. However, the ownership and lifetime features in Rust increases the complexity when undertaking pointer analysis. In C++, existing techniques primarily address the issue of pointer access via alias analysis~\cite{10.1145/3503222.3507770, 10301168, fan2020accelerating}. Nevertheless, traditional alias analysis needs modification to accommodate the pointer variable ownership and lifetime in Rust. For example, when ownership is transferred to another pointer or the pointer is automatically deallocated, the original pointer variable becomes invalid,
which cannot be detected by existing techniques.

To tackle these challenges, we develop \TN, a static analysis tool to detect \bugs in Rust applications. It consists of two main components, namely, \Tyanalyzer and \Bugdetector. By examining each function within the crate, \tyanalyzer creates a new call graph that helps identify the type constructor functions, addressing the first challenge. Property graph constructor performs \analysisone and \analysistwo. Type conversion analysis is conducted to collect type pairs (i.e., $\text{<}$source type, destination type$\text{>}$) and trait bounds for generic types through dependency resolution. It is employed to address the second challenge. Pointer alias analysis will construct a new alias graph, representing the alias relationship of the pointers. When ownership is transferred or dropped, \tyanalyzer updates the alias graph to reflect the node connections, which can solve the third challenge. As the final output, each function in the \pcg is associated with type pairs, trait bounds, and the pointer alias graph. The \pcg will be utilized by \bugdetector to analyze and verify the type confusion bugs.

Next, \bugdetector utilizes {the \pcg} to perform type conversion checks and access checks. First, type conversion checks are used to identify if the type conversion creates an invalid type pointer. Second, access checks will be performed to analyze if the invalid type pointer can be accessed. Via analyzing the type pairs and trait bounds, we summarize three patterns of type confusion bugs, namely, \bone, \btwo, and \bthree, to help locate invalid type pointers. When performing access checks, \bugdetector will first traverse the alias graph to determine if the invalid type pointer is accessible, then verify the absence of {\tc}, which is manually implemented by developers to prevent the type confusion bugs. After verification, the bug report will be delivered with the unsafe type conversion and type access highlighted.


We implement a prototype of \TN with 5249 lines of Rust. To assess \TN's effectiveness in bug identification, we first execute it on the \bugs reported to RUSTSEC from 2019 to 2024. The findings show that \TN can successfully identify all reported \bugs. Next, we perform a large-scale study by running \TN on the top 3,000 popular packages ranked on \url{crates.io} and \url{GitHub}. We detect 71 new \bugs and report all of them to their package developers. We receive {32} confirmations on the reported bugs at the time of writing. The new bugs occur in many high-profile repositories. For example, we demonstrate that the \bug within the \texttt{pprof} package can cause the downstream applications to crash (e.g., GreptimeDB with 4.2k stars on GitHub).  \looseness=-1

\vspace{0.1in}
\noindent{\bf Contributions.}
This paper makes the following contributions: 
\begin{packeditemize}
    \item We analyze all \bugs in RUSTSEC in the last five years and identify the three most prevalent categories of \bugs, namely, misalignment, inconsistent layout, and mismatched scope.
    \item We design and implement the first static analysis tool (\TN) to detect \bugs in Rust, {addressing the challenges of interprocedural type conversion, generic type resolution, and alias analysis} due to the unique features of Rust.
    \item We evaluate \TN on the top 3,000 Rust packages and identify {71} new \bugs which we have manually confirmed, surpassing the total number of bugs reported in RUSTSEC in the last five years. We also run \TN on existing \bugs and it achieves 100\% accuracy, demonstrating the robustness of \TN. 
\end{packeditemize}