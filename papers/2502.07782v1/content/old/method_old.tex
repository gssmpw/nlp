
\section{Flag Decomposition (FD)}\label{sec:methods}
We will now introduce our novel Flag Decomposition (FD) that, given $\D$, outputs a hierarchy-preserving flag $[\![\Q]\!]$. 

From this point forward, we use $[\cdot,\cdot,\cdot]$ to denote column space and $[\cdot|\cdot|\cdot]$ to denote block matrices. Let $\cB_i = \cA_i \setminus \cA_{i-1}$ denote the difference of sets for $i=1,2,\dots, k$ and $\B_i = \D_{\cB_i}$ so that $[\D_{\cA_i}] = [\B_1,\B_2,\dots,\B_i]$. We define the permutation matrix $\bP$ so $\B = [\B_1|\B_2| \cdots | \B_k] = \D\bP$. Also, denote the projection matrix onto the null space of $[\Q_i]$ with $\Q_i \in St(m_i,n)$ as $\bP_{\Q_i^\perp} = \I - \Q_i\Q_i^\top$. Finally, we use $n_0 = 0$, $\cA_0 = \emptyset$, and $\bP_{\Q_0^\perp} = \I$. 



\begin{dfn}[Hierarchy-preserving flags]
     A flag $[\![\X]\!] \in \flag(n_1,n_2,\dots, n_k;n)$ is said to preserve the hierarchy of $\D$ if $[\D_{\cA_i}] = [\X_1,\X_2,\dots,\X_i]\,$ for each $i=1,2,\dots,k$. 
\end{dfn}

If $\mathcal{A}_1 \subset \mathcal{A}_2 \subset \cdots \subset \mathcal{A}_k$ is a column hierarchy for $\D$, then a hierarchy-preserving flag results in the three, equivalent, nested sequences of subspaces
\begin{equation*}
    \begin{matrix}
        [\D_{\cA_1}] & \subset & [\D_{\cA_2}] & \subset & \cdots & \subset & [\D_{\cA_k}]\\    
        [\B_1] & \subset & [\B_1,\B_2] & \subset & \cdots & \subset & [\B_1,\B_2, \dots,\B_k]\\
        [\X_1] & \subset & [\X_1,\X_2] & \subset & \cdots & \subset & [\X_1,\X_2,\dots,\X_k].
    \end{matrix}
\end{equation*}
Before presenting a general flag decomposition, consider two well-known matrix decompositions that output flags.
\begin{exmp}[QR decomposition]
    For a tall and skinny ($p \leq n$) $\D$ with the column hierarchy $\{1,\dots,p_1\}\subset \{1,\dots,p_2\} \subset \cdots \subset \{1,\dots,p\}$ and the flag type is $(p_1,p_2,\dots,p;n)$, the QR decomposition $\D = \Q \bR$ outputs the hierarchy-preserving flag $[\![\Q]\!] \in \flag(p_1,p_2,\dots,p;n)$ because $[\mathbf{q}_1 | \mathbf{q}_2|\cdots |\mathbf{q}_i] = [\mathbf{d}_1 | \mathbf{d}_2|\cdots |\mathbf{d}_i]=[\D_{\cA_i}]$ for $i=1,2\dots,k$.
\end{exmp}

\begin{exmp}[SVD]
    Suppose $\D$ has the column hierarchy $\{1,\dots,p\}$ and the rank $n_k$. The SVD of $\D$ is $\D =\U \bm{\Sigma} \V^\top$. Let $\Q$ be the $n_k$ left singular vectors (columns of $\U$) associated with non-zero singular values. Then $[\![\Q]\!] \in \flag(n_k;n)$ is a hierarchy-preserving flag because $[\Q] = [\D]$.
\end{exmp}

These examples motivate a generalized decomposition of $\D$ that outputs a hierarchy-preserving flag. In particular, unlike in QR decomposition, $\D$ can be rank-deficient (\eg, $\mathrm{rank}(\D) < p$); and unlike the SVD, we can decompose into flags of type $(n_1,n_2,\dots,n_k;n)$ with $n_k \leq p$. 

\begin{dfn}[\textbf{Flag Decomposition (FD)}]
    Let $\D \in \R^{n \times p}$ be data with the hierarchically nested sequence of column indices $\cA_1 \subset \cA_2 \subset \cdots \subset \cA_k$. A flag decomposition of type $(n_1,n_2, \cdots, n_k; n)$ is the matrix factorization
    \begin{equation}
        \D = \Q \bR \bP^\top
    \end{equation}
    where the block structures are
    \begin{align}
        \Q &= [\underbrace{\Q_1}_{n \times m_1} | \underbrace{\Q_2}_{n \times m_2} | \cdots | \underbrace{\Q_k}_{n \times m_k} ] \in \R^{n \times n_k},\\
        \bR &= \begin{bmatrix}
            \bR_{11} & \bR_{12} & \cdots & \bR_{1k}\\
            \mathbf{0} & \bR_{22} & \cdots & \bR_{2k}\\
            \vdots & \vdots & \ddots & \vdots\\
            \mathbf{0} & \mathbf{0} & \cdots & \bR_{kk} \end{bmatrix} \in \R^{n_k \times p}, \\
        \bP &= [\bP_1 \,|\, \bP_2 \,|\, \cdots \,|\, \bP_k] \in \R^{p \times p}.
    \end{align}
    Here, $\Q$ corresponds to the Stiefel coordinates for the hierarchy-preserving flag $[\![\Q]\!] \in \flag(n_1,n_2,\dots, n_k;n)$ with $m_i=n_i - n_{i-1}$ and $n_k \leq p$, $\bR$ is a block upper-triangular matrix, and $\bP$ is a permutation matrix so that $\B = \D \bP$.
\end{dfn}
 Let us further investigate the proposed FD. 
\begin{prop}
    A data matrix $\D$ admits a flag decomposition of type $(n_1,n_2, \cdots, n_k; n)$ if and only if $\cA_1 \subset \cA_2 \subset \cdots \subset \cA_k$ is a column hierarchy for $\D$.
\end{prop}
\begin{proof}[Proof sketch]
    We use~\cref{prop:stiefel_coords,prop:proj_prop_and_flags} and the definition of a column hierarchy for $\D$. Details in suppl. material.
\end{proof}


\begin{comment}
\begin{dfn}[Projection property]\label{def:projection_property}
     $[\![\Q]\!]$ satisfies the projection property relative to $\D$ when, for $i=1,2,\cdots,k$,
    \begin{equation}\label{eq:projection_property}
    \bP_{\Q_i^\perp}\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp} \B_i = 0.
    \end{equation}
\end{dfn}
\end{comment}


\begin{prop}\label{prop:stiefel_coords}
    Suppose $\cA_1 \subset \cA_2 \subset \cdots \subset \cA_k$ is a column hierarchy for $\D$. Then there exists $\Q= [\Q_1\,|\,\Q_2\,|\, \cdots\,|\,\Q_k]$ that are coordinates for the flag $[\![\Q]\!]\in\flag(n_1,n_2,\dots,n_k;n)$ where $n_i = \mathrm{rank}(\D_{\mathcal{A}_i})$ that satisfies $[\Q_i] = [\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp}\B_i]$ and the \textbf{projection property} (for $i=1,2\dots,k$): 
    \begin{equation}\label{eq:projection_property}
    \bP_{\Q_i^\perp}\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp} \B_i = 0.
    \end{equation}
\end{prop}
\begin{proof}
    Define (for $i=2,3,\dots,k$) the projector onto the null space of $[\Q_1,\Q_2,\dots,\Q_i]$, as $\bP_{\Q_{:i}^\perp} = \I - \Q_{:i}\Q_{:i}^\top$. We use this to define $\C_i = \bP_{\Q_{:i-1}^\perp}\B_i$ and $\Q_i \in St(m_i,n)$ so that $[\Q_i] = [\C_i]$. Then we use mathematical induction to show results ending in ~\cref{eq:projection_property} and $\Q_i \in St(m_i,n)$ with $m_i = n_i - n_{i-1}$ where $n_i = \mathrm{rank}(\D_{\cA_i})$.
\end{proof}
\begin{comment}
\begin{proof}
    Existence of $\Q$ follows from the recursion $\mathbf{P}_{\Q_i^\perp}^\prime = \Q_i \Q_i^\top + \bP_{\Q_i^\perp} \mathbf{P}^\prime_{\Q_{i-1}^\perp}$ (with $\mathbf{P}^\prime_{\Q_0^\perp} = \mathbf{0}$). The projection property is proved using
    \begin{equation*}
        (\bP_{\Q^\perp_{i-1}} \cdots \bP_{\Q^\perp_1} \B_i)^\top (\bP_{\Q^\perp_{j-1}} \cdots \bP_{\Q^\perp_1} \B_j) = \boldsymbol{0}
    \end{equation*}
    for all $j \neq i$ and $[\Q_i] = [\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp}\B_i]$.
\end{proof}
\end{comment}
The simplest methods for recovering $\Q$ so that $[\Q_i] = [\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp}\B_i]$ include the left singular vectors from the truncated SVD and $\Q$ matrix from the QR decomposition with pivoting. 

%for the QR decomposition with pivoting, we have $\bP_{\Q^\perp_{i-1}} \cdots \bP_{\Q^\perp_0} \B_i = \Q_i' \bR_i'{\bP_i'}^\top$, the columns of $\Q_i$ correspond to columns of $\Q_i'$ associated with non-zero rows of $\bR_i'$. For the case of SVD where $\bP_{\Q^\perp_{i-1}} \cdots \bP_{\Q^\perp_0} \B_i = \U_i \bm{\Sigma}_i \V_i^\top$, the columns of $\Q_i$ are the columns of $\U_i$ associated with the non-zero singular values.

We will now use $\Q$ and the projection property to construct an FD and develop an algorithm for finding it.
\begin{prop}\label{prop:proj_prop_and_flags}
 Suppose $\cA_1 \subset \cA_2 \subset \cdots \subset \cA_k$ is a column hierarchy for $\D$. Then there exists some hierarchy-preserving 
 $[\![\Q]\!] \in \flag(n_1,n_2,\dots, n_k;n)$ (with $n_i = \mathrm{rank}(\D_{\mathcal{A}_i})$) 
 that satisfies the projection property of $\D$ and can be used for a flag decomposition of $\D$ with
    \begin{align}
        \bR_{i,j} &= 
        \begin{cases}
            \Q_i^\top\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp} \B_i, &i=j\\
            \Q_i^\top\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp} \B_j, &i < j
        \end{cases},\label{eq:onlyR}\\
        \bP_i &= \left[ \,\mathbf{e}_{b_{i,1}}\,|\, \mathbf{e}_{b_{i,2}}\,|\, \cdots\,|\, \mathbf{e}_{b_{i,|\cB_i|}} \right]\label{eq:onlyP}
    \end{align}
    where $\{b_{i,j}\}_{j=1}^{|\cB_i|} = \cB_i$ and $\mathbf{e}_{b}$ is the $b_{i,j}$$^{\mathrm{th}}$ standard basis vector.
\end{prop}
\begin{proof}[Proof sketch]
    This is proved using the previous proposition.
\end{proof}
\emph{Therefore, any $\D$ with an associated column hierarchy admits a hierarchy-preserving FD.} Now we state a uniqueness result for the FD.

\begin{prop}[Block rotational ambiguity]
    Given the FD $\D = \Q \bR \bP^\top$, any other Stiefel coordinates for the flag $[\![\Q]\!]$ produce an FD of $\D$ (via~\cref{prop:proj_prop_and_flags}). Furthermore, different Stiefel coordinates for $[\![\Q]\!]$ produce the same objective function values in~\cref{eq:general_opt} and~\cref{eq:iterative_opt} (for $i=1,\cdots,k$).
\end{prop}
\begin{proof}[Proof sketch]
    Notice $\Q_i \Q_i^T = (\Q_i\mathbf{M}_i)  (\Q_i\mathbf{M}_i)^\top$ for any $\Q_i \in St(m_i,n)$ and $\mathbf{M}_i \in O(m_i)$. See our suppl. material for details.
\end{proof}



\subsection{Flag recovery}
In this section, we introduce an approach for recovering the FD $\D = \Q \bR \bP^\top$ from a given, corrupted version of the dataset, $\tilde{\D}$ and the column hierarchy $\cA_1 \subset \cA_2 \subset \cdots \subset \cA_k$ for $\D$. We call recovering $[\![ \Q ]\!]$ from $\tilde{\D}$ and $\cA_1 \subset \cA_2 \subset \cdots \subset \cA_k$ the \emph{flag recovery}.


Recall that any $[\![ \Q ]\!]$ satisfying the projection property of $\D$ can be used for a FD (see~\cref{prop:proj_prop_and_flags}). However, since we only have access to $\tilde{\D}$, we may not be able to satisfy this property. As a remedy, we try to get as close as possible to satisfying the projection property by optimizing for $[\![\Q]\!]$ such that $\bP_{\Q_i^\perp} \cdots \bP_{\Q_1^\perp}\tilde{\B}_i \approx \bm{0}$ for each $i=1,2,\dots,k$. We minimize this cost column-wise to solve the problem in maximum generality. Specifically, we propose the following minimization:
\begin{equation}\label{eq:general_opt}
    [\![\Q]\!] = \argmin_{[\![\X]\!] \in \flag(n_1,n_2, \dots, n_k;n)} \sum_{i=1}^k \sum_{j \in \cB_i}\| \bP_{\X_i^\perp} \cdots \bP_{\X_1^\perp} \tilde{\mathbf{d}}_j \|_r^q
\end{equation}
for $r\geq 0$, $q > 0$. Choosing small $r$ and $q$ (\eg, $r =0$ and $q=1$) would result in a robust flag recovery, optimal for recovering $\D$ in the presence of outlier columns in $\tilde{D}$. This problem is difficult, even after restricting $q$ and $r$, so we address the iterative optimization for each $\Q_i$ for $i=1$, then $i=2$, and so on until $i=k$.
\begin{equation}\label{eq:iterative_opt}
    \Q_i =  \argmin_{\X \in St(m_i,n)} \sum_{j \in \cB_j}\| \bP_{\X^\perp} \bP_{\Q^\perp_{i-1}} \cdots \bP_{\Q^\perp_1} \tilde{\mathbf{d}}_j \|_r^q.
\end{equation}
The solution to the case where $r=q=2$ is obtained by the first $m_i$ left singular vectors of $\bP_{\Q^\perp_{i-1}} \cdots \bP_{\Q^\perp_1} \tilde{\D}_{\mathcal{B}_j}$.
In general, solving~\cref{eq:iterative_opt} for some $i$ recovers $\Q_i$ whose columns form a basis for a $m_i$ dimensional subspace in $\R^n$.
Although outputting a truncated basis via QR with pivoting or rank-revealing QR decompositions would offer faster alternatives to SVD for solving~\cref{eq:iterative_opt}, SVD offers more reliable subspace recovery~\cite{demmel1997applied}. Thus, we use SVD-based algorithms and leave exploration of QR methods for future work.

For cases where $\tilde{\D}$ has outlier columns, we use an $L_1$ penalty, \ie, $q=1$, and introduce an \textbf{IRLS-SVD solver}\footnote{IRLS denotes iteratively reweighted least squares.}, a simple method that resembles IRLS algorithms for subspace recovery~\cite{zhang2014novel,lerman2015robust,vidal2018dpcp,lerman2018fast,lerman2018overview,garg2019subspace,mankovich2022flag}. In practice, we implement a vanilla IRLS-SVD algorithm which could further be made faster and provably convergent using tools from~\cite{aftab2014generalized,beck2015weiszfeld,kummerle2021iteratively,kummerle2021scalable,verdun2024fast}. We leave more advanced solvers, as well as working with other values of $r$ and $q$ (e.g., $r=0$~\cite{liu2012robust}), for future work.



\subsection{\algname}
We now propose an algorithm~\algname~for finding FD and its robust version, Robust FD (RFD). Our algorithm is inspired by the Block Modified Gram-Schmidt (BMGS) procedure~\cite{jalby1991stability,barlow2019block}. Modified Gram-Schmidt (MGS) is a more numerically stable implementation of the classical Gram-Schmidt orthogonalization. BMGS runs an MGS algorithm on block matrices, iteratively projecting and ortho-normalizing matrices rather than vectors, to output a QR decomposition. In contrast, we use~\algname~on a data matrix with a column hierarchy to produce a hierarchy-preserving FD. Even with this difference,~\algname~is essentially a BMGS algorithm. We leave stability results and the search for more optimal algorithms, such as those using block Householder transformations~\cite{griem2024block}, to future work. A brief discussion of a different low-rank block matrix decomposition~\cite{ong2016beyond} can be found in suppl. material.


\algname~operates by first generating a permutation matrix $\bP$ (see~\cref{eq:onlyP}) to extract the matrix $\B = \D\bP^\top$, using the column hierarchy. Then each iteration $i=1,2,\dots,k$ constructs $\bP_{\Q_{i-1}^\perp}\cdots \bP_{\Q_1^\perp} \B_i$, solves an optimization of the form~\cref{eq:iterative_opt}, and then constructs each $\bR_{i,j}$ for $j \leq i$ (see~\cref{eq:onlyR}). In experiments, we call FD the output of~\algname~using SVD with $r=q=2$ and Robust FD (RFD) the iterative variant using $r=2$ and $q=1$ to solve~\cref{eq:iterative_opt}. 



As stated before, we may have the column hierarchy for $\D$ but only have access to a corrupted version of $\D$, namely $\tilde{\D}$. In this case, we need a method for detecting the flag type from $\tilde{\D}$. 

\paragraph{On the flag type}
FD requires a flag type to be specified. \emph{Detecting} or selecting an adapted flag type from data rather than relying on a heuristic choice, is recently addressed by Szwagier~\etal in the context of principal subspace analysis~\cite{szwagier2024curseisotropyprincipalcomponents}. Yet, our FD model includes a block upper triangular matrix $\bR$ and does not involve a latent variable generative model. Hence, we require a new method to detect flag types.  

    If $\cA_1 \subset \cA_2 \subset \cdots \subset \cA_k$ is a column hierarchy for $\D$ then the flag type of $\D$ is $(n_1,n_2,\dots,n_k;n)$ with $n_i = \mathrm{rank}(\D_{\cA_i})$ (see~\cref{prop:stiefel_coords}). 
    Yet, when the input $\D$ is noisy, \ie, we observe $\tilde{\mathbf{D}} = \mathbf{D} + \bm{\epsilon}$ ($ \bm{\epsilon} $ denotes random noise) instead of the true $\D$. This leads to an estimation problem of the flag type, where the task is to determine the flag type of $[\![\Q]\!]$ in the flag decomposition $\D = \Q\bR \bP^\top$, assuming access to the true (known) column hierarchy for $\D$.     

    A naive approach to address the problem of flag type estimation for our FD is to run the FD along with a singular value truncation in each SVD. Methods for truncating the SVs include the \emph{elbow} and \emph{Gavish-Dohono}~\cite{gavish2014optimal,falini2022review}. In this work, given a column hierarchy for $\D$, and $\tilde{\D}$, we choose an input flag type where $n_k < p$ and input it to FD. In doing so, the output of FD forms a reduced-rank approximation of $\D$ denoted $\hat{\D} = \Q \bR \bP^\top$. 
    
    A promising future research direction involves exploring smarter truncation methods for extracting the flag type of $\D$ under specific contamination criteria. 

    









