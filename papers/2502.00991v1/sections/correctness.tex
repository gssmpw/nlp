\section{Serializability and recovery}\label{sec:correctness}
% In this section, we prove the serializability under low isolation levels and the cross-isolation levels within \sysname. 
% Previous sections have demonstrated that the validation-based concurrency control guarantees the commit order of two transactions involved in a dependency. 

% Before we prove the guarantee of serializability in a weak isolation level, we first specify the relationship between the conflict graph (CG), which is constructed on the execution history, and the static dependency graph (SDG), which is based on transaction templates.
% For better illustration, the proof atmosphere is two-step; first, we will show that concurrency control in middleware guarantees the commit order of two transactions with dependency; then, we will prove the serializable guarantee of the workload in \sysname. 

% CG 中的依赖和 SDG 中的依赖是有对应关系的。
% \noindent\begin{lemma}
%     If $T_i \rightarrow T_j$ in the $CG$ of the execution history $H$, then $\mathcal{T}_i \rightarrow \mathcal{T}_j$ in the $SDG$ of the transaction template $\mathcal{T}$. 
%     % As a partial converse, if $\mathcal{T}_i \rightarrow \mathcal{T}_j$, then either $T_i \rightarrow T_j$ or $T_j \rightarrow T_i$ in $H$.
%     \label{theorem-1}
% \end{lemma}

% \noindent\textbf{Proof.} Suppose $T_i \rightarrow T_j$ within the execution history $H$, if $T_i \xrightarrow{ww} T_j$, then $H$ contains two write operations $w_i[x]$ and $w_j[x]$, belonging to $T_i$ and $T_j$, respectively. $x$ belongs to the intersection of the write sets of $T_i$ and $T_j$, it implies that $\mathcal{T}_i$ has potential ww dependency with $\mathcal{T}_j$. Thus, there exists a ww dependency in the $SDG$. Similarly, if there is rw or wr dependency between $T_i$ and $T_j$. 

% In this section, we first prove the serializability of \sysname's scheduling; in other words, \sysname can prevent all non-serializable schedulings, which are divided into the single-isolation level and cross-isolation level categories, and we provide the proof in \S~\ref{sec:proof.isolation} and \S~\ref{sec:proof.switch}, respectively. Lastly, we present the failure recovery strategy in \S~\ref{sec:proof:failure}.
In this section, we first prove the serializability of \sysname's scheduling in the single-isolation level and cross-isolation level categories in \S~\ref{sec:proof.isolation} and \S~\ref{sec:proof.switch}, respectively. Finally, we present the failure recovery strategy in \S~\ref{sec:proof:failure}. 

\subsection{Serializability under Low Isolation Levels \label{sec:proof.isolation}}
% Before we prove the isolation correctness, we identify $T.B$ as the beginning time of transaction $T$ and $T.C$ as the commit time of transaction $T$, and the characteristics of transactions involved in dependency edges are summarised in Table~\ref{tbl:correctness}. If $T_i \xrightarrow{ww} T_j$, 
% in SI, the FCW rule avoids concurrent updates, in other words, $T_i$ commits before $T_j$ starts. 
% While in RC, the database avoids \textit{dirty write} and guarantees read-last-committed. Hence, $T_j$ can only commit after $T_i$ commits. If $T_i \xrightarrow{wr} T_j$, $T_j$ reads the record written by $T_i$, $T_j$ must commit after $T_i$ commits in both SI and RC. Moreover, in SI, a transaction gets the snapshot at the beginning, we can make the characteristic more concise that $T_i$ commits before $T_j$ starts. Lastly, $T_i \xrightarrow{rw} T_j$, in both SI and RC, $T_i$ begins before $T_j$ commits, otherwise, $T_i$ reads the record written by $T_j$. 
% Before demonstrating the serializability of weak isolation levels, w
% \todo{1. previous work in SI and RC; 2. the concurrency control can identify all potential transaction templates and keep the dependency order ...; 3. conclusion}
% \textcolor{red}{in SI the only possible anomaly is from two consecutive RW and Tk commit first}
% \begin{theorem}
%     At the SI level, $H$ is conflict serializable if for every two consecutive RW dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in $H$, $T_j$ commits before $T_k$.
%     \label{theorem-2}
% \end{theorem}
% \textcolor{red}{\sysname can guarantee serializability in SI as it forces Tj commit first}
% \textcolor{red}{in RC the only possible anomaly is from the RW and Tj commit first}
% \begin{theorem}
%     At the RC level, $H$ is conflict serializable if for every RW dependency edge $T_i\xrightarrow{rw} T_j$ in $H$, $T_i$ commits before $T_j$.
%     \label{theorem-3}
% \end{theorem}
% \textcolor{red}{\sysname can guarantee serializability in RC as it forces Ti commit first}
% Under standard low isolation levels, the execution order of transactions may violate SER, often manifested as dependency cycles. Luckily, these cycles have been proven to follow some specific vulnerable dependencies. 
% Serializability can be effectively guaranteed at weak isolation levels if these patterns are identified and appropriately addressed. 
% The non-serializable scheduling under each low isolation level serves some specific vulnerable dependencies.
% According to Theorem \ref{the:vulnerable}, a necessary condition for non-serializability is the inconsistent dependency and commit order of vulnerable dependencies. \sysname identifies the static vulnerable dependency from the transaction templates and ensures that in transactions involving vulnerable dependencies, the commit order is consistent with the dependency order as outlined in Algorithm \ref{alg.transaction}, thus maintaining SER with RDBMS configured to low isolation levels. 
Non-serializable scheduling under each low isolation level accommodates certain specific vulnerable dependencies. According to Theorem \ref{the:vulnerable}, a necessary condition for non-serializability is the presence of inconsistent dependencies and commit orders among these vulnerable dependencies. 
\maintext{The unified middle-tier concurrency control ensures the commit order respects dependency order for transactions with vulnerable dependencies, thereby preserving SER even when the RDBMS operates at lower isolation levels.}
\extended{\sysname identifies static vulnerable dependencies from the transaction templates and ensures that, in transactions involving these dependencies, the commit order aligns with the dependency order as specified in Algorithm \ref{alg.transaction}. This approach maintains SER even when the RDBMS is configured to low isolation levels.}

% Informally, at the SI level, a cycle is present if and only if it contains two consecutive RW conflicts $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, with $T_k$ being the first transaction to commit, as discussed in Theorem \ref{def:si}. \sysname, at the SI level, records all potential two consecutive RW conflicts in the middle tier and ensures $T_j$ commits before $T_k$ as outlined in Algorithm \ref{alg.transaction}. This mechanism effectively prevents the formation of any SI cycles, thereby guaranteeing serializability.
% Similarly, at the RC level, a cycle exists if and only if it contains an RW conflict $T_i \xrightarrow{rw} T_j$, with $T_j$ being the first to commit as described in Theorem \ref{def:rc}. In this context, \sysname records all possible RW conflicts in the middle tier and enforces that $T_i$ commits before $T_j$ as detailed in Algorithm \ref{alg.transaction}. This approach ensures no RC cycles can form, thus maintaining serializability at the RC level. 

% \textcolor{red}{One possible conclusion: Unlike most SER CC protocols (e.g., SSI) that directly abort potential RW edges, this method permits certain RW edges to coexist while disallowing others that violate serializable orders. This approach effectively enhances concurrency within the system.}

% Following Theorem \ref{def:si} and Theorem \ref{def:rc} in \sysname, validation is integrated into the middle-tier concurrency control as discussed in Session \ref{design-1}, which is designed to handle transactions generated from templates associated with data dangerous structures at low isolation levels. This integration allows \sysname to proactively identify transactions that may lead to non-serializable scheduling, detect runtime dependencies, and ensure their correct commit order. This proactive approach effectively guarantees the absence of dependency cycles, thereby ensuring the serializability under low isolation levels.

% We first explore the possible \textcolor{red}{partial order} in an execution history $H$. 
% We denote the begin time of transaction $T$ as $T.B$ and the commit time as $T.C$. The \textcolor{red}{partial order} characteristics of conflict dependencies are summarized in Table~\ref{tbl:correctness}. 
% Consider the scenario where $T_i \xrightarrow{ww} T_j$. The First-Committer-Wins (FCW) rule at the SI level prevents concurrent updates by ensuring that $T_i$ commits before $T_j$ begins. At the RC level, the database prevents \textit{dirty write} and enforces the Read-Last-Committed rule, thus $T_j$ can only commit after $T_i$ has committed. 
% For the case where $T_i \xrightarrow{wr} T_j$, since $T_j$ reads the record written by $T_i$, $T_j$ commits only after $T_i$ has committed at both SI and RC levels. Moreover, at the SI level, since a transaction captures a snapshot at its beginning, it simplifies the relationship such that $T_i$ commits only before $T_j$ begins. Lastly, in the scenario where $T_i \xrightarrow{rw} T_j$, both SI and RC require that $T_i$ begins before $T_j$ commits to avoid $T_i$ reading a record that could potentially be written by $T_j$. 

% \begin{table}[t]
% \caption{Transaction characteristics of dependencies}
% \vspace{-4mm}
% \begin{tabular}{ccc}
% \toprule
%                       & Snapshot Isolation & Read Committed \\ 
% % \multicolumn{1}{l|}{$T_i \xrightarrow{ww} T_j$} & $commit(T_i) < begin(T_j)$ & $commit(T_i) < commit(T_j)$ \\
% % \multicolumn{1}{l|}{$T_i \xrightarrow{wr} T_j$} & $commit(T_i) < begin(T_j)$ & $commit(T_i) < commit(T_j)$ \\
% % \multicolumn{1}{l|}{$T_i \xrightarrow{rw} T_j$} & $begin(T_i) < commit(T_j)$ & $begin(T_i) < commit(T_j)$
% \midrule
% \multicolumn{1}{l}{$T_i \xrightarrow{ww} T_j$} & $T_i.C < T_j.B$ & $T_i.C < T_j.C$ \\
% \multicolumn{1}{l}{$T_i \xrightarrow{wr} T_j$} & $T_i.C < T_j.B$ & $T_i.C < T_j.C$ \\
% \multicolumn{1}{l}{$T_i \xrightarrow{rw} T_j$} & $T_i.B < T_j.C$ & $T_i.B < T_j.C$ \\
% \midrule
% \multicolumn{3}{l}{$<$ is the partial order \todo{in the execution history.}} \\
% \bottomrule
% \end{tabular}
% \label{tbl:correctness}
% \end{table}

% \begin{theorem}
%     In SI, H is conflict serializable if $T_j$ commits before $T_k$ for all two consecutive vulnerable dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in H.
%     \label{theorem-2}
% \end{theorem}
% \noindent\textbf{Proof.} We adopt the contrapositive approach here, assuming that if $H$ is not conflict serializable, there must be a cycle in $CG$. We maintain the commit order of $T_j$ and $T_k$, assuming $T_{j^{'}}$ is the first transaction committed within this cycle. Let's denote $T_{s^{'}}$ and $T_{i^{'}}$ as immediate predecessors of $T_{j^{'}}$, e.g. $T_{s^{'}}\rightarrow T_{i^{'}} \rightarrow T_{j^{'}}$. Since $T_{j^{'}}.C < T_{i^{'}}.C$, as per Table~\ref{tbl:correctness}, only the rw dependency is possible between $T_{i^{'}}$ and $T_{j^{'}}$. We can further infer that $T_{i^{'}}.B < T_{j^{'}}.C$, and since T3 was submitted first, $T_{j^{'}}.C < T_{s^{'}}.C$. Based on these two conditions, we can deduce that $T_{i^{'}}.B < T_{s^{'}}.C$, making only the rw dependency is possible between $T_{s^{'}}$ and $T_{i^{'}}$ as well.
% However, we identify all transactions that match the structure and could keep the commit order of $T_{i^{'}}$ and $T_{j^{'}}$, which means $T_{j^{'}}$ can not be the first one in these three transactions to commit. This contradicts our derivation. Therefore, \sysname can ensure the conflict serializability when the RDBMS is configured to SI.

% \begin{theorem}
%     At the SI level, $H$ is conflict serializable if for every two consecutive RW dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in $H$, $T_j$ commits before $T_k$.
%     \label{theorem-2}
% \end{theorem}
% \noindent\textbf{Proof.} 
% We prove this by contradiction, assuming that $H$ is not conflict serializable when $T_j$ commits before $T_k$. Let $T_{s^{'}}$ and $T_{i^{'}}$ be the immediate predecessors of $T_{j^{'}}$, such that $T_{s^{'}}\rightarrow T_{i^{'}} \rightarrow T_{j^{'}}$. Given that $T_{j^{'}}.C < T_{i^{'}}.C$, as indicated in Table~\ref{tbl:correctness}, the only feasible dependency between $T_{i^{'}}$ and $T_{j^{'}}$ is a RW dependency. We can further infer that $T_{i^{'}}.B < T_{j^{'}}.C$, and since $T_{j^{'}}$, $T_{j^{'}}.C < T_{s^{'}}.C$. From these conditions, it follows that $T_{i^{'}}.B < T_{s^{'}}.C$, suggesting that the only possible dependency between $T_{s^{'}}$ and $T_{i^{'}}$ is also RW.
% However, upon identifying all transactions that conform to this structure and could maintain the commit order of $T_{i^{'}}$ and $T_{j^{'}}$, it becomes evident that $T_{j^{'}}$ cannot be the first among these three transactions to commit. This observation contradicts our initial assumption. Therefore, we conclude that the \sysname can ensure conflict serializability at the SI level.

% \begin{theorem}
%     In RC, H is conflict serializable if $T_i$ commits before $T_j$ for all vulnerable dependency edges $T_i\xrightarrow{rw} T_j$ in H.
%     \label{theorem-3}
% \end{theorem}
% \noindent\textbf{Proof.} Similar to the proof of SI, we assume the existence of a dependency cycle in $H$, with $T_{i^{'}}$ as the first committed transaction and $T_{s^{'}}$ as its closest ancestor of $T_{i^{'}}$ in the cycle. This implies  $T_{s^{'}}\rightarrow T_{i^{'}}$ and $T_{i^{'}}.C < T_{s^{'}}.C$. According to Table~\ref{tbl:correctness}, an rw dependency exists between $T_{s^{'}}$ and $T_{i^{'}}$, and the validation-based concurrency control in \sysname ensures that $T_{s^{'}}$ commits before $T_{s^{'}}$ can commit. This contradiction indicates that \sysname can guarantee the conflict serializability of $H$ under RC.

% % \subsection{Consistent commit order}

% In \sysname, we incorporate validation into the transactions produced by transaction templates associated with data anomalies at weak isolation levels. This allows \sysname, during execution, to identify transactions that could potentially result in data anomalies and guarantee the commit order, all without the database's awareness. This approach disrupts the necessary conditions for the CG to form a dependency cycle.

\subsection{Serializability under Cross-isolation Levels \label{sec:proof.switch}}
% During the transition process, \sysname employs a more stringent concurrency control policy to ensure conflict serializability. Consider, for example, the switch from SER to SI. During this transition, we split the $CG$ of $H$ into two subgraphs, $CG_{SER}$ and $CG_{SI}$. $CG_{SER}$ contains transactions running under the SER isolation level, and $CG_{SI}$ contains those running under SI. $CG_{SER}$ is obviously acyclic, and according to Theorem~\ref{theorem-2}, so is $CG_{SI}$. Subsequently, we consider the dependency edges that connect $CG_{SER}$ and $CG_{SI}$. When the database processes transactions under both SI and SER concurrently, no exceptions will occur apart from those that could occur under SI alone. In \sysname, the concurrency control for all transactions is conducted according to the policy corresponding to SI, meaning the dependency between $CG_{SER}$ and $CG_{SI}$ forms a cycle neither.

\begin{comment}
Achieving serializability becomes complex, as \sysname must handle non-serializable scheduling arising from different isolation levels when transitioning from one isolation level $I_{old}$ to the new isolation level $I_{new}$.     
\end{comment}

% As detailed in Section~\ref{design-3}, this transition process comprises three distinct stages. 
% The serializability of Phase I, which encompasses all transactions operating under the old isolation level, as well as Phase III, involving all transactions under the new isolation level, can be readily proven as demonstrated in Section~\ref{sec:proof.isolation}.
% We will discuss the serializability for Phase II; the core is to prove the correctness of Theorem \ref{the:cross-isolation} and Theorem \ref{the:cross-isolation-commit}.  
% The correctness during the transition is established by proving the validity of Theorem \ref{the:cross-isolation} and Theorem \ref{the:cross-isolation-commit}.
% The validation locking mechanism in CIV allows the concurrency control algorithm described in Section \ref{design-1} to detect all vulnerable dependencies, $T_i \xrightarrow{rw} T_j$, regardless of whether $T_i$ and $T_j$ are executing under different or the same isolation levels. Furthermore, it enables $T_i$ to maintain its commit order consistent with the dependency order. 
We prove the correctness of the cross-isolation level in three steps: If there is non-serializable scheduling during the transition, \blackding{1} there exists at least a cross-isolation vulnerable dependency as defined in Definition~\ref{def:transition_vul}; 
% \blackding{2} The cross-isolation validation mechanism in \S\ref{design-3} can detect and avoid at least one cross-isolation vulnerable dependency in the non-serializable scheduling.
\blackding{2} there exists at least a cross-isolation vulnerable dependency $T_j \xrightarrow{rw} T_k$, where $T_k$ commits before $T_j$ and $T_j$ commits after the transition. 
\blackding{3} The cross-isolation validation mechanism can detect the dependency if $T_j$ commits after the transition and enforce the consistent commit and dependency order. \maintext{Due to the space limitation, we provide more details in our technique report \cite{TxnSails}. }

% In this subsection, we first prove that if we can ensure the commit order of $T_j$ and $T_k$ in the cross-isolation vulnerable dependency $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ aligns with the dependency order, then transactions can achieve SER. Then, we prove that our cross-isolation validation can ensure that the transaction commit order is consistent with the data dependency order in all cross-isolation vulnerable dependencies, thus ensuring serializability.
% all cross-isolation vulnerable dependencies can be prevented according to our cross-isolation validation phase.
% We prove this in the following two steps.
% if it needs to.

% We first prove that if non-serializable scheduling exists, there is at least one cross-isolation vulnerable dependency $T_j \xrightarrow{rw} T_k$, where 1. $T_k$ commits before $T_j$; 2. $T_j$ operates under SER; and 3. $T_j$ commits after the transition starts.

% The lock manner in CIV enables the concurrency control algorithm in Section \ref{design-1} can detect all vulnerable dependencies, $T_i\xrightarrow{rw} T_j$, even $T_i$ and $T_j$ execute under different isolation levels. We need to prove that if non-serializable scheduling exists, at least one cross-isolation vulnerable dependency $T_j \xrightarrow{rw} T_k$, where $T_k$ commits before $T_j$; 2. $T_j$ operates under SER; 3. $T_j$ commits after the transition starts. 

\begin{figure}[t]
    \centering
    \includegraphics[width=0.47\textwidth]{figures/switch_correctness.pdf}
    \vspace{-4mm}
    \caption{Transition from SER to SI/RC}
    % \caption{Partial dependency between $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$}
    \label{fig:switch_correctness}
    \vspace{-4mm}
\end{figure}
% If there is non-serializable scheduling, there is a cross-isolation vulnerable $T_j \xrightarrow{rw} T_k$ in this scheduling, where $T_k$ commits before $T_j$.

{
% \color{blue}
\blackding{1} 
\maintext{
We first prove the existence of cross-isolation vulnerable dependency in non-serializable scheduling. 
}
\extended{
We first prove that if there is non-serializable scheduling during the transition, there must be two consecutive RW dependencies, $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits before $T_j$.
}
If non-serializable scheduling occurs, consider three transactions: $T_2 \xrightarrow{D_1} T_1 \xrightarrow{D_2} T_0$. 
Without loss of generality, we assume $T_0$ is the first transaction committed.
Since $T_0$ commits first, $D_2$ must be an RW dependency; otherwise, $T_1$ should commit before $T_0$. 
Additionally, $T_1$ can not operate under RC because the concurrency control in \S\ref{design-1} would avoid the inconsistent dependency and commit order between $T_1$ and $T_0$. 
Moreover, $D_1$ can only be an RW edge; otherwise, $T_2$ commits before $T_0$ commits, as depicted in Figure~\ref{fig:switch_correctness}a, which contradicts the initial assumption that $T_0$ is the first to commit. 
\extended{Moreover, the data dependency from $T_2$ to $T_1$ can only be an RW edge. We prove this by reductio. If the dependency from $T_2$ to $T_1$ is either a WW or WR dependency, implying that $T_2$ commits before $T_1$ starts. Since $T_1$ is concurrent with $T_0$ due to an RW dependency, deriving $T_0$ commits after $T_1$ starts. Thus, $T_2$ must commit before $T_0$ commits, contradicting the assumption that $T_0$ is the first transaction to commit. Therefore, the data dependency from $T_2$ to $T_1$ must be an RW dependency, leading to two consecutive RW dependencies $T_2 \xrightarrow{rw} T_1 \xrightarrow{rw} T_0$, where $T_0$ commits first. 
}

Moreover, if $T_1$ operates under SI, the concurrency control in \S\ref{design-1} can detect the dependency from $T_1$ to $T_0$ and
enforce the consistent commit and dependency order. 
Hence, if non-serializable scheduling exists, \textbf{$T_1$ must operate under SER}. 

In other words, \textbf{the transition between RC and SI is serializable if they perform the concurrency control in \S\ref{design-1}}. 

% Furthermore, we can find at least a vulnerable dependency, where $T_j$ commits after the transition. 


% After employing the cross-isolation validation mechanism, $T_j$'s read set would be checked, and then the commit order would be enforced to be consistent with its dependency order.  

\blackding{2} We then prove that the existence of cross-isolation vulnerable dependency $T_j \xrightarrow{rw} T_k$, where $T_k$ commits before $T_j$ and $T_j$ commits after the transition. 
We demonstrate the proof under two cases as follows. 

% (1) Transaction $T_i$ in the cross-isolation vulnerable dependency $T_i \xrightarrow{rw} T_j$ operates under SER. If $T_i$ operates under SI or RC, then the concurrency control proposed in \S~\ref{design-1} can ensure that the commit order of $T_i$ and $T_j$ is consistent with the dependency order. Therefore, $T_i$ must operate under SER. 

% \noindent\textbf{Transition between SI and RC.} Consider the cross-isolation vulnerable dependency $T_i \xrightarrow{rw} T_j$. 

% (2) There must be at least one cross-isolation vulnerable dependency, $T_i \xrightarrow{rw} T_j$, where $T_i$ commits after the transition starts. Given that $T_i$ must operate under SER, we demonstrate the proof under two scenarios of the transition from SI/RC to SER and SER to SI/RC, respectively. 

\noindent\textbf{Transition from SI/RC to SER.} According to proof \blackding{1}, if there is non-serializable scheduling during the transition, there must be two consecutive RW dependencies, $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits before $T_j$ and $T_j$ operates under SER. During the transition from SI/RC to SER, $T_j$ operates under the new isolation level, making it commit after the transition starts. 
% \textit{As a result, the cross-isolation validation mechanism can detect the dependency and schedule the commit order to achieve serializable scheduling. }

\noindent\textbf{Transition from SER to SI/RC.} For clarity, we categorize the transactions during the transition into three discrete sets:
\maintext{
\begin{itemize}[leftmargin=*]
\item $S_{old}^{(1)}$: Transactions under $I_{old}$ committed before the transition.
\item $S_{old}^{(2)}$: Transactions under $I_{old}$ committed after the transition.
\item $S_{new}$: Transactions under $I_{new}$ starting after the transition.
\end{itemize}
}

\extended{
\begin{itemize}[leftmargin=*]
    \item $S_{old}^{(1)}$: The set of transactions under $I_{old}$ and have been committed when the transition occurs. 
    \item $S_{old}^{(2)}$: The set of transactions that operate under $I_{old}$ and commit after the transition occurs. 
    \item $S_{new}$: The set of transactions that start after the transition occurs and operate under $I_{new}$.
\end{itemize} 
}

Figure \ref{fig:switch_correctness}b shows the partial orders between transaction sets. 
Non-serializable scheduling implies a dependency cycle, 
\maintext{
either (a) between $S_{old}^{(2)}$ and $S_{new}$ or (b) spanning $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$.
}
\extended{
which can be classified into two kinds: (a) scheduling involves only transactions in $S_{old}^{(2)}$ and $S_{new}$; (b) scheduling involves transactions in $S_{old}^{(1)}$, $S_{old}^{(2)}$ and $S_{new}$. 
}

In the first case, all transactions involving vulnerable dependencies are committed after the transition. According to proof \blackding{1}, if there is non-serializable scheduling during the transition, there must be two consecutive RW dependencies, $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, and $T_j$ commits after the transition. 
In the second case, 
\maintext{
% as depicted in Figure \ref{fig:switch_correctness}b, 
there exists a transaction $T_j\in S_{old}^{(2)}$, its successor transaction is $T_k\in S_{old}^{(1)}$ and its predecessor transaction is either $T_i^{\prime}$ or $T_i$. Hence, there also exists a cross-isolation vulnerable dependency, where $T_k$ commits before $T_j$ and $T_j$ commits after the transition.
} 
\extended{we prove that there is at least one cross-isolation vulnerable dependency, $T_j\xrightarrow{rw} T_k$, where $T_j\in S_{old}^{(2)}$, in the non-serializable scheduling. We conclude that if there is a WR/WW data dependency from $T_i$ to $T_j$, $T_i$ must be committed before $T_i$ starts. Given that, we analyze the possible data dependencies between transaction sets.
The red arrow at the bottom shows that data dependencies from $S_{new}$ to $S_{old}^{(2)}$ can only be RW dependencies due to those transactions in $S_{new}$ commit after those in $S_{old}^{(2)}$.
The red dashed arrow within $S_{old}^{2}$ represents that dependencies between transactions within $S_{old}^{(2)}$ can only be RW dependencies because they are concurrent transactions. 
The red arrow in the top part shows that dependencies from transactions in $S_{old}^{(2)}$ to those in $S_{old}^{(1)}$ must be RW dependencies due to those transactions in $S_{old}^{(2)}$ commit after those in $S_{old}^{(1)}$ start. 
}
\extended{
Next, we use the reductio to prove that transaction $T_j$ in at least one vulnerable dependency, $T_j \xrightarrow{rw} T_k$, is not in the $S_{old}^{(1)}$ set.
If $T_j$ in all cross-isolation vulnerable dependencies, $T_j \xrightarrow{rw} T_k$, is in $S_{old}^{(1)}$, then any transaction $T_j$ in $S_{old}^{(2)}$ which is contained in a RW dependency pointing to $S_{old}^{(1)}$ must not have a precede RW dependency. However, due to that dependencies from transactions in $S_{new}$ (i.e., $T_i$) to $S_{old}^{(2)}$ (i.e., $T_i^\prime$) or dependencies from transactions in $S_{old}^{(2)}$ (i.e., $T_i^\prime$) to $S_{old}^{(2)}$ (i.e., $T_j$) must be RW dependencies, leading to contradiction. Therefore, at least one $T_j$ in cross-isolation vulnerable dependencies, $T_j \xrightarrow{rw} T_k$, is in $S_{old}^{(2)}$ or $S_{new}$. In other words, at least one $T_j$ commits after the transition starts.
}

% In conclusion, if there is a cross-isolation vulnerable dependency from $T_i$ to $T_j$ during the transition, the cross-isolation validation can ensure that their commit order is consistent with their dependency order, thus ensuring serializability. 
\blackding{3}
The cross-isolation validation mechanism can detect the vulnerable dependency $T_j \xrightarrow{rw} T_k$ if $T_j$ commits after the transition. It then enforces a consistent commit and dependency order. According to the contrapositive of proof \blackding{2}, if there does not exist cross-isolation vulnerable dependency $T_j \xrightarrow{rw} T_k$, where $T_k$ commits before $T_j$ and $T_j$ commits after the transition, then there is no non-serializable scheduling during the transition. As a result, the scheduling during the transition is serializable. 
% The approaches proposed in \S\ref{design-1} and \S\ref{design-3} can prevent all non-serializable scheduling. 
% if there is a cross-isolation vulnerable dependency from $T_i$ to $T_j$ during the transition, the cross-isolation validation can ensure that their commit order is consistent with their dependency order, thus ensuring serializability. 

% then any dependency $T_y \xrightarrow{rw} T_z$, where $T_y\in S_{old}^{(2)}$ and $T_z\in S_{old}^{(1)}$, the precede dependency can not be RW, which means $T_x \xrightarrow{ww/wr} T_y$, thus $T_x \in S_{old}^{(1)}$. In this case, a dependency cycle cannot contain transactions in all three transaction sets. Therefore, the counter-example does not exist; at least a precede RW dependency of $T_y$ must exist. Then, there is a structure with two consecutive RW dependencies, $T_x \xrightarrow{rw} T_y \xrightarrow{rw} T_z$, where $T_z \in S_{old}^{(1)}$ commits before $T_y \in S_{old}^{(2)}$ and $T_y$ commits after the transition starts. Thus, $T_y$ and $T_z$ constitute a cross-isolation level vulnerable dependency.

% Therefore, we conclude that for transitions from SER to SI/RC or from SI/RC to SER, if there is non-serializable scheduling, there is at least one cross-isolation vulnerable dependency, $T_j \xrightarrow{rw} T_k$, in two consecutive RW dependencies, transaction $T_j$ operates under the SER and commits after the transition starts. 
}


\subsection{Failure Recovery \label{sec:proof:failure}}
%{\color{blue}
% Failure recovery aims to recover the database to a consistent state, ensuring that no partial or corrupted data is present.
The system incorporates a robust failure recovery mechanism to ensure data consistency and service availability. When \sysname encounters a failure, the system automatically restarts \sysname to re-connect the RDBMS and rolls back all uncommitted transactions. When the RDBMS encounters failures, the system restarts the RDBMS and leverages the ARIES recovery algorithm~\cite{DBLP:journals/tods/MohanHLPS92:ARIES} to recover the database in a consistent state. 
% its recovery can rely on its own recovery techniques. 
% Moreover, applications can verify whether their modifications have been applied after recovery if they do not receive a response to the commit request.
% does not either modify the database kernel or keep any runtime transaction meta. As a result, there is no requirement to recover it to any consistent point. \sysname guarantees that any transaction passing the validation maintains the SER. Hence, it relies on the underlying RDBMS for failure recovery in the event of a failure. Moreover, applications can verify whether their modifications have been applied after recovery if they do not receive a response to the commit request. 
%}
% Due to the space limitation, we provide more details in our technique report \cite{TxnSails}. 

% \sysname identifies the static vulnerable dependency from the transaction templates. 

% To guarantee SS during the transition when involving SER, our CIV records all transactions $T_j$ that involve RW at the SER isolation level. CIV prevents $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ by enforcing a commit order that aligns with its dependency order. This approach ensures that $T_k$ does not commit before $T_j$, thereby avoiding the formation of cycles.

% \textbf{Transaction $T_j$ operates under SER.} Otherwise, the middle-tier concurrency control approach would ensure that the commit order of $T_j$ and $T_k$ is consistent with their dependency order. 

% \textbf{Transaction $T_j$ commits after the transition point.} In scenarios where the transition is from SI or RC to SER, since $T_j$ operates under SER, it starts and commits after the transition point.
% For the other two scenarios, we illustrate the partial orders between transaction sets, according to the categories outlined in Section \ref{design-3}, at the transition point in Figure \ref{fig:switch_correctness}b. The features of some dependencies are listed following: 
% % Dependencies arise from , between transactions in $S_{new}$ and those in $S_{old}^{(1)}$ and $S_{old}^{(2)}$. 
% \blackding{1} Dependencies from transactions in $S_{old}^{(1)}$ to those in $S_{new}$ can only be RW dependencies and no reverse dependencies because transactions in $S_{old}^{(1)}$ commit before any transactions in $S_{new}$ start. 
% \blackding{2} Transactions in $S_{new}$ are concurrent with those in $S_{old}^{(2)}$, because transactions in $S_{old}^{(2)}$ operate under SER, the dependencies from transactions in $S_{new}$ to those in $S_{old}^{(2)}$ are RW dependencies. The reverse dependencies can be any type.
% \blackding{3} Similarly, the dependencies between transactions within $S_{old}^{(2)}$ can only be RW dependencies because they are concurrent transactions.
% \blackding{4} Transactions in $S_{old}^{(1)}$ commits before those in $S_{old}^{(2)}$, thus dependencies from transactions in $S_{old}^{(1)}$ .

% There can be two kinds of dependency cycles: dependency cycles contain transactions in $S_{old}^{(1)}$ and $S_{new}$, and dependency cycles contain transactions in all three sets. In the first type, $T_j$ must commit after the transition according to the classification criteria of $S_{old}^{(2)}$. In another type, although $T_j$ may commit before the transition point, we prove that every dependency cycle contains two consecutive RW dependencies, $T_i^{'} \xrightarrow{rw} T_j^{'} \xrightarrow{rw} T_k^{'}$, and $T_j^{'}$ commits after the transition point. 

% As shown in Figure \ref{fig:switch_correctness}, the dependency cycle contains the dependency from transaction in $S_{new}$ to $S_{old}^{(2)}$ and the dependency from transaction in $S_{old}^{(2)}$ to $S_{old}^{(1)}$. Without losing generality, we denote them as $T_1\xrightarrow{rw} T_2$ and $T_3\xrightarrow{rw} T_4$, where $T_2$ and $T_3$ can be the same transaction. The dependency chain from $T_2$ to $T_4$ can be formalize as:

% \todo{}
% Thus far, we have proved the correctness of Theroem \ref{the:cross-isolation} and Theroem \ref{the:cross-isolation-commit}. The cross-isolation level validation mechanism ensures the commit order of xxx is consistent with their dependency order, thus ensuring SS during the transition.
% If the dependency cycle does not involve the transactions in $S_{old}^{(1)}$, $T_j$ must commit after the transition according the  $S_{old}^{(2)}$. In another case, 

% Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and may be bidirectional. 
% In phase~II, \sysname is required to track these dependencies and ensure that there are no dependencies from the transactions in $S_{new}$ to those in $S_{old}^{(2)}$.

% which involves transactions that run across isolation levels and can be divided into two distinct parts: (1) the isolation transitions involving SER isolation and (2) the transitions occurring solely between SI and RC levels. 
% \newpage
% \textbf{Transaction involves SER isolation level.} Additional validation is necessary during the transition when SER isolation is involved. As outlined in Section~\ref{design-3}, we categorize transactions into three sets: $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$. The concurrency control in Section~\ref{sec:design:cc:validation} ensures that there is no dependency cycle within $S_{old}^{(1)} \cup S_{old}^{(2)}$ and $S_{new}$, respectively.
% As depicted in Figure~\ref{fig:switch_correctness}, dependencies arise across isolation levels, between transactions in $S_{new}$ and those in $S_{old}^{(1)}$ and $S_{old}^{(2)}$. 
% \blackding{1} Transactions in $S_{old}^{(1)}$ commit before any transactions in $S_{new}$ start. Therefore, dependencies can only occur when a transaction in $S_{new}$ reads or writes the data written by $S_{old}^{(1)}$. 
% \blackding{2} Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and may be bidirectional. 
% In phase~II, \sysname is required to track these dependencies and ensure that there are no dependencies from the transactions in $S_{new}$ to those in $S_{old}^{(2)}$. 
% % Thus, the dependencies can be only flow from $S_{old}^{(2)}$ to $S_{new}$.
% Therefore, the dependency graph is acyclic during the transition, thus achieving SS.
% cross-isolation transactions during the transition are serializable.

% \textbf{Transition between SI and RC isolation levels.} Unlike involving SER, the transition of \sysname between SI and RC isolation levels does not require additional validation. To illustrate this, we consider the counter-example in Figure~\ref{fig:cross-isolation} and briefly demonstrate that no cycle can be formed during the transition. By contradiction, we assume a cycle exists, with $T_j$ being the first transaction to commit. This implies the existence of an RW edge from $T_i$ to $T_j$, as $T_j$ commits first. However, by identifying the static vulnerable dependency at RC, the middle-tier concurrency control approach ensures $T_i$ commits before $T_j$ for any RW dependency, meaning that $T_i$ operates under SI. 
% By identifying the static vulnerable dependency in SI, it is not permissible for two consecutive RW dependencies to have the last transaction committed first. So, the dependency from $T_k$ to $T_i$ must be either WW or WR. 
% In this case, the commit time of $T_k$ is before $T_i$ starts. Since $T_i$ is concurrent with $T_j$ by a RW dependency, $T_j$ commits after $T_i$ starts. Thus, $T_k$ must commit before $T_j$ commits, which contradicts the assumption that $T_k$ is the first transaction to commit in the cycle. Therefore, we conclude that no cycles exist during the transition.

% The transition process ensures serializability when transactions follow the middle-tier concurrency control designed for each individual isolation level in \sysname. As we all know, non-serializable scheduling can be identified by a dependency cycle. Consider the counter-example in Figure~\ref{fig:cross-isolation}. Denote the first committed transaction in the cycle as $T_j$, with its predecessor transactions as $T_i$ and $T_j$. The inconsistent dependency order and commit order between them indicate the dependency from $T_i$ to $T_j$ must be an RW dependency. This implies $T_i$ operates under SI and is concurrent with $T_j$, meaning \textit{$T_i$ begins before $T_j$ commits}. Then, the dependency from $T_k$ to $T_i$ could be either WW or WR dependency. If it is an RW dependency, two consecutive RW dependencies occur, consisting of the dangerous structure in SI; then, the middle-tier concurrency control could schedule the commit order of $T_i$ and $T_j$ to make it consistent with the dependency order. Since $T_i$ operates under SI, $T_k$ must commit before $T_j$ begins, which contradicts our assumption that $T_j$ is the first transaction to commit in this cycle. Therefore, no such dependency cycles exist, ensuring that transaction scheduling is serializable under \sysname.

% \sysname employs a stringent concurrency control mechanism during isolation level transitions. 
% The correctness of this mechanism can be divided into two parts: the transition involving SER and the transition between SI and RC. We demonstrate the correctness of both scenarios separately.

% \subsubsection{Transaction involving SER isolation level.}
% As detailed in Section~\ref{design-3}, this transition process comprises three distinct stages, for which we provide proof of serializability. 
% The serializability of Phase I, which encompasses all transactions operating under the previous isolation level, as well as Phase III, involving all transactions under the new isolation level, can be readily proven as demonstrated in Section~\ref{sec:proof.isolation}.
% We will provide proof of serializability for Phase II, which involves transactions that run across both isolation levels.

% According to Section~\ref{design-3}, we categorize the transactions into three sets: $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$. As depicted in Figure~\ref{fig:switch_correctness}, we will demonstrate that these transactions' schedules are serializable, without conflict cycles. Within the same isolation level, consider the proof in Section \ref{sec:proof.isolation}, we can establish that both $S_{old}^{(1)} \cup S_{old}^{(2)}$ and $S_{new}$ are serializable. 
% When dependencies are across isolation levels and transactions are from between $S_{new}$ and $S_{old}^{(1)}$, as well as between $S_{new}$ and $S_{old}^{(2)}$.
% \blackding{1} Transactions in $S_{old}^{(1)}$ commit before transactions in $S_{new}$ start. Therefore, dependencies can only occur when a transaction in $S_{new}$ reads or writes the data written by $S_{old}^{(1)}$.
% \blackding{2} Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and bidirected. In phase~II, \sysname could track these dependencies and ensure that transactions in $S_{new}$ either commit after $S_{old}^{(1)}$ or abort. 
% % no operation in $S_{old}^{(1)}$ depends on an operation in $S_{new}$.
% Thus, the dependencies can be only from $S_{old}^{(2)}$ to $S_{new}$. Consequently, cross-isolation transactions during the switching phase are serializable.
% For example, for the switch from SER to SI, the $CG$ of $H$ is divided into two subgraphs: $CG_{SER}$ and $CG_{SI}$. $CG_{SER}$ contains transactions operating under the SER level, and $CG_{SI}$ contains those operating under the SI level. It is evident that $CG_{SER}$ is acyclic due to the stringent nature of SER. Furthermore, according to Theorem~\ref{theorem-2}, $CG_{SI}$ is also acyclic.
% We then examine the dependency edges that bridge $CG_{SER}$ and $CG_{SI}$.

% In \sysname, \textcolor{red}{Describe more information when the database concurrently processes transactions under both SI and SER, how to deal with transaction conflict to guarantee serializability.} the concurrency control for all transactions adheres to SER protocol or Theorem \ref{theorem-2}. This approach ensures that no cycles form between $CG_{SER}$ and $CG_{SI}$, maintaining the acyclic nature of the overall system's conflict graph and thereby preserving conflict serializability throughout the transition.

% \subsubsection{Transition between SI and RC isolation level.} The transition process ensures serializability when transactions follow the middle-tier concurrency control designed for each individual isolation level in \sysname. As we all know, non-serializable scheduling can be identified by a dependency cycle. Consider the counter-example in Figure~\ref{fig:cross-isolation}. Denote the first committed transaction in the cycle as $T_j$, with its predecessor transactions as $T_i$ and $T_j$. The inconsistent dependency order and commit order between them indicate the dependency from $T_i$ to $T_j$ must be an RW dependency. This implies $T_i$ operates under SI and is concurrent with $T_j$, meaning \textit{$T_i$ begins before $T_j$ commits}. Then, the dependency from $T_k$ to $T_i$ could be either WW or WR dependency. If it is an RW dependency, two consecutive RW dependencies occur, consisting of the dangerous structure in SI; then, the middle-tier concurrency control could schedule the commit order of $T_i$ and $T_j$ to make it consistent with the dependency order. Since $T_i$ operates under SI, $T_k$ must commit before $T_j$ begins, which contradicts our assumption that $T_j$ is the first transaction to commit in this cycle. Therefore, no such dependency cycles exist, ensuring that transaction scheduling is serializable under \sysname.
