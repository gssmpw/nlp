\section{preliminaries}
% In this section, we first describe transaction and transaction Templates. Next, we present three isolation levels utilized in \sysname. Finally, we define the ``dangerous structures" that may arise under low isolation levels.
% RDBMS typically provides several isolation levels; in this paper, we focus on the three most commonly used: serializable (SER), snapshot isolation (SI), and read committed (RC). 
RDBMSs typically offer several isolation levels; in this paper, we focus on the three most commonly used: serializable (SER), snapshot isolation (SI), and read committed (RC).
In this section, we first discuss transaction templates.
We then present the dangerous structures under SI and RC, respectively.
We finally define the vulnerable dependencies that build the foundation of our approach.

% \subsection{Transaction and Transaction Template}
\subsection{Transaction Templates}
% {\color{blue}
% In \sysname, we assume that applications generate the transactions from transaction templates. 
% }

% A transaction is a sequence of read/write operations on data items that execute atomically. This means that either all operations are successful, resulting in a commit of the transaction, or none of the operations succeed, leading to an abort. 
% For clarity, we denote 
% the begin time as $B$ and the commit time as $C$. Additionally,
% $W(x_k)$ ($R(x_k)$) as the transaction generates (reads) a version $x_k$ of data item $x$.%, while $R(x_k)$ denotes as the transaction reads the version $x_k$ of $x$. 
% Two transactions are concurrent if neither terminates (commit/abort) before the other starts. 

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.47\textwidth]{figures/template_transaction.pdf}
%     \vspace{-4mm}
%     \caption{Transaction template and transaction}
%     \label{fig:template_transaction}
%     \vspace{-4mm}
% \end{figure}

A transaction template is an abstraction of application logic that consists of predefined SQL statements with parameter placeholders. 
Take the Amalgamate template in Example \ref{exa:oaofsb} as an example, 
% ConsiAmader the Amalgamate (Amg) template in Figure~\ref{fig:template_transaction}, 
which facilitates the transfer of funds from one customer to another. It first reads the balances of the checking and savings accounts of customer $N_1$, then sets them to zero. Finally, it increases the checking balance for $N_2$ by the sum of $ N_1$'s previous balances. In this context, $N_1$ and $N_2$ serve as parameter placeholders. This modular structure ensures readability and flexibility, allowing the transaction template to be reused across various contexts.
When a customer initiates a transaction at runtime, the application fills the placeholders with actual data. The complete transaction is then executed in the RDBMS, finalizing the business logic.

For better clarity, we use $\mathcal{T}_i$ to denote a transaction template and $T_i$ to denote a transaction generated by $\mathcal{T}_i$.

% \subsection{Isolation Levels}
% RDBMS typically provides several isolation levels; in this paper, we focus on the three most commonly used: serializable (SER), snapshot isolation (SI), and read committed (RC). While higher isolation levels offer stronger guarantees against data anomalies, they often come at the cost of reduced concurrency and performance.
% % The serializable isolation level provided by RDBMSs prevents all data anomalies at the expense of concurrency and performance. Therefore, 

% \textbf{\textit{Read Committed.}} 
% RC is the default isolation level in many database systems, including Oracle~\cite{} and PostgreSQL~\cite{}.
% % RC is provided in many database systems, such as PostgreSQL and Oracle.
% RC prevents anomalies such as \textit{dirty reads} and \textit{dirty writes}~\cite{}, ensuring that transactions do not access uncommitted data. At the RC level, write operations are executed with an exclusive lock that is maintained for the duration of the commit In contrast, read operations retrieve the most recently committed version.

% \textbf{\textit{Snapshot Isolation.}} 
% SI is the default isolation level in systems like YugabyteDB~\cite{} and MySQL~\cite{}. 
% SI addresses anomalies such as \textit{lost updates} and \textit{inconsistent reads}, which cannot be managed by RC. At the SI level, each transaction reads the most recent committed version of data as of the time the transaction begins. %, unless a new version has already been written, in which case that version is read. 
% Write operations are executed under an exclusive lock that is held for the duration of the commit, adhering to the \textit{First-Committer-Wins (FCW)} rule~\cite{}. %, i.e., when a transaction attempts to write, the system ensures that the write is allowed only if no other transaction has committed a newer version with a timestamp greater than the start time of the writing transaction. 

% \textbf{\textit{Serializable.}} SER is the strictest isolation level and prevents any anomalies. This means that the interleaved execution of transactions must be equivalent to a serial execution of the same transactions. In this case, the middle-tier concurrency control provided by \sysname is unnecessary. 

\subsection{Dangerous Structures\label{sec:back.vd}}
The dependencies between two concurrent transactions, $T_i$ and $T_j$, operating on the same item $x$, are classified as follows.

\begin{itemize}[leftmargin=*]
    \item $T_i \xrightarrow{ww} T_j$: $T_i$ writes a version of data item $x$, and $T_j$ writes a later version of $x$.
    \item $T_i \xrightarrow{wr} T_j$: $T_i$ writes a version of data item $x$, and $T_j$ reads either the version written by $T_i$ or a later version of $x$.
    \item $T_i \xrightarrow{rw} T_j$: $T_i$ reads a version of data item $x$, and $T_j$ writes a later version of $x$.
\end{itemize}

\begin{definition}[SI dangerous structure~\cite{DBLP:journals/pvldb/PortsG12}]
    \label{def:si}
    Under SI, two consecutive RW dependencies: $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ are considered as an SI dangerous structure, where $T_i$ and $T_j, T_j$ and $T_k$ are concurrent transactions, respectively. %Furthermore, $T_k$ must be the first transaction to commit in the cycle. 
    % Additionally, in the context of transaction templates, the static dangerous structure is characterized by two consecutive RW dependencies in the static dependency graph: $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$. 
    \qed
\end{definition}

\begin{definition}[RC dangerous structure~\cite{DBLP:journals/pvldb/GanRRB020, DBLP:conf/aiccsa/AlomariF15}]
    \label{def:rc}
    Under RC, an RW dependency: $T_i \xrightarrow{rw} T_j$ is considered as an RC dangerous structure, where $T_i$ and $T_j$ are concurrent transactions. %Furthermore, $T_j$ is the first transaction to commit in the cycle. 
    % In the context of transaction templates, the static dangerous structure is characterized as an RW dependency in the static dependency graph: $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j$. 
    \qed
\end{definition}

% \subsection{Template Dangerous Structure}

When it comes to transaction templates, the dependencies between two transaction templates, $\mathcal{T}_i$ and $\mathcal{T}_j$, are defined as follows: (1) $\mathcal{T}_i \xrightarrow{ww} \mathcal{T}_j$ if $\mathcal{T}_i$ and $\mathcal{T}_j$ write the same data set (e.g., relation) in sequence; (2) $\mathcal{T}_i \xrightarrow{wr} \mathcal{T}_j$ if $\mathcal{T}_i$ writes and $\mathcal{T}_j$ reads the same data set in sequence; (3) $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j$ if $\mathcal{T}_i$ reads and $\mathcal{T}_j$ writes the same data set in sequence.

% Furthermore, we can build the static dependency graph based on transaction templates and above three rules. 

\begin{definition}[Static SI dangerous structure~\cite{DBLP:conf/sigmod/CahillRF08, alomari2008serializable}]
    \label{def:sta_si}
    In a static dependency graph, two consecutive edges $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j$, $\mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$ are deemed to constitute a static SI dangerous structure.
    \qed
\end{definition}

\begin{definition}[Static RC dangerous structure~\cite{DBLP:conf/aiccsa/AlomariF15, DBLP:conf/icdt/VandevoortK0N22}]
    \label{def:sta_rc}
    In a static dependency graph, an edge $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j$ is deemed to constitute a static RC dangerous structure.
    \qed
\end{definition}

\begin{theorem}[\cite{alomari2009ensuring}]
\label{the:RC}
If a static dependency graph contains no SI (resp. RC) static dangerous structures, then scheduling the transactions generated by the corresponding transaction templates achieves SER when the RDBMS is configured to SI (resp. RC).
\qed
\end{theorem}

% Theorem \ref{the:vulnerable} forms the basis of our dynamic, fine-grained approach to achieving SER. Our method detects runtime dependencies and schedules commits to align with these dependencies. It does not require any additional write conflicts and minimally impacts transaction concurrency. 

% static and coarse-grained approach
% Based on Theorem \ref{the:RC}, eliminating all static dangerous structures in the static dependency graph before transaction execution ensures the SS. This forms the basis for the existing static and coarse-grained approach of introducing additional WW conflicts.
Theorem \ref{the:RC} serves as the foundation for existing approaches to achieving SER while the RDBMS is configured to SI/RC. However, these approaches are static and coarse-grained, leading to the incorrect identification of many non-cyclic schedules. This, in turn, causes a significant number of unnecessary transaction rollbacks.

% According to Definition \ref{def:sta_si}-\ref{def:rc}, we observe that not all static dangerous structures lead to non-serializable scheduling. Therefore, the static and coarse-grained approach of introducing additional WW conflict is over-conservative and may not yield optimal results. 

\subsection{Vulnerable Dependency}
% For non-serializable scheduling, a necessary condition is the presence of an RW dependency within a dangerous structure, where its dependency order is inconsistent with the commit order. We denote this RW dependency as a vulnerable dependency. Formally, the vulnerable dependency under SI and RC can be defined as follows: 
\begin{definition}[Static vulnerable dependency]
    \label{def:static_vul}
    The static vulnerable dependency is defined as $\mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$ in chain $\mathcal{T}_i \xrightarrow{rw} \boxed{\mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k}$ under SI, and $\boxed{\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j}$ under RC, respectively.  
    % For SI, the static vulnerable dependency is $\mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$ in the chain $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$. For RC, the static vulnerable dependency is $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j$.
    \qed
\end{definition}

\begin{definition}[Vulnerable dependency]
    \label{def:vul}
    The vulnerable dependency is defined as $T_j \xrightarrow{rw} T_k$ in chain $T_i \xrightarrow{rw} \boxed{T_j \xrightarrow{rw} T_k}$ under SI, and $\boxed{T_i \xrightarrow{rw} T_j}$ under RC, respectively.
    \qed
\end{definition}

\begin{theorem}[\cite{DBLP:conf/aiccsa/AlomariF15}] 
%\cite{DBLP:journals/pvldb/PortsG12, DBLP:conf/aiccsa/AlomariF15} 
\label{the:vulnerable}
% Every vulnerable dependency, if its dependency order, $T_i $
For any vulnerable dependency $T_i\xrightarrow{rw} T_j$, if $T_i$ commits before $T_j$, then the scheduling achieves SER.
% If the commit order of all vulnerable dependencies is consistent with their dependency order, then the execution over these transactions can achieve SS when they are configured to low isolation levels. 
% If a static dependency graph contains no SI (resp. RC) static dangerous structures, then the execution over the transactions derived from these transaction templates can achieve SS when they are configured to SI (resp. RC) level.
\qed
\end{theorem}

% 
Theorem \ref{the:vulnerable} forms the basis of our dynamic, fine-grained approach to achieving serializable scheduling. 
Compared to existing approaches, our approach neither introduces unnecessary writes nor misjudges cyclic schedules, thus preventing unwarranted transaction rollbacks.

% Our method detects runtime dependencies and schedules commits to align with these dependencies, avoiding additional write conflicts and minimally impacting transaction concurrency.



% Our method detects runtime dependencies and schedules commits to align with these dependencies. It does not require any additional write conflicts and minimally impacts transaction concurrency. 

% Theorem \ref{the:vulnerable} serves as the foundation for our dynamic and fine-grained approach to achieving SER. Our approach detects the runtime dependency and schedules the commit order to be consistent with the dependency order, which does not introduce the additional write. Thus, has little impact on the transaction concurrency. 

% This paper proposes a dynamic and fine-grained approach to avoid vulnerable dependencies. We schedule the commit order of transactions consistent with the dependency order, ensuring the SS under low isolation levels. 

% Furthermore, we denote a dependency in the static dependency graph as a static vulnerable dependency if it can produce a vulnerable dependency, potentially resulting in non-serializable scheduling. The definition is as follows:


% This definition helps us more accurately identify the transactions that need to be scheduled in \sysname.
% \newpage
% % low isolation data anomalies -> cycle -> feature, we denote these feature as the "dangerous structures" under low isolation levels.  

% First, we outline the conflict dependencies between transactions. The dependencies between two concurrent transactions, $T_i$ and $T_j$, operating on the same item $x$, can be classified into three types:
% \begin{itemize}[leftmargin=*]
%     \item $T_i \xrightarrow{ww} T_j$ occurs when $T_i$ writes a version of data item $x$, and $T_j$ writes a subsequent version of $x$.
%     \item $T_i \xrightarrow{wr} T_j$ occurs when $T_i$ writes a version of data item $x$, and $T_j$ reads either the version written by $T_i$ or a later version of $x$.
%     \item $T_i \xrightarrow{rw} T_j$ occurs when $T_i$ reads a version of $x$, and $T_j$ writes a later version of $x$.
% \end{itemize}

% % Given a set of committed transactions, the scheduling is serializable if and only if its dependency graph is acyclic.
% A schedule of committed transactions is considered SER if and only if its dependency graph is acyclic. In other words, non-serializable scheduling is invariably linked to the presence of dependency cycles. Extensive research has shown that dependency cycles arising under the low isolation level often follow some specific patterns, referred to as ``dangerous structures." Next, we describe the dangerous structures from the perspective of transactions and transaction templates.

% \begin{theorem}[SI Dangerous Structure~\cite{DBLP:conf/sigmod/CahillRF08, DBLP:journals/pvldb/PortsG12}]
%     \label{def:si}
%     The dependency cycle under SI contains two consecutive RW dependencies: $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_i$ and $T_j, T_j$ and $T_k$ are concurrent transactions. Furthermore, $T_k$ must be the first transaction to commit in the cycle. 
%     Additionally, in the context of transaction templates, the static dangerous structure is characterized by two consecutive RW dependencies in the static dependency graph: $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$. 
%     \qed
% \end{theorem}

% \begin{theorem}[RC Dangerous Structure~\cite{DBLP:conf/aiccsa/AlomariF15, DBLP:conf/icdt/VandevoortK0N22}]
%     \label{def:rc}
%     The dependency cycle under RC contains an RW dependency: $T_i \xrightarrow{rw} T_j$, where $T_i$ is concurrent with $T_j$. Furthermore, $T_j$ is the first transaction to commit in the cycle. 
%     In the context of transaction templates, the static dangerous structure is characterized as an RW dependency in the static dependency graph: $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j$. 
%     \qed
% \end{theorem}

% \subsection{Vulnerable dependency \label{sec:back.vd}}
% According to Theorem~\ref{def:si} and \ref{def:rc}, we observe that not all static dangerous structures lead to non-serializable scheduling. Therefore, the static and coarse-grained approach of introducing additional WW conflict is over-conservative and may not yield optimal results. 
% We also observe that a necessary condition for the non-serializable scheduling is the presence of an RW dependency within a dangerous structure, where its dependency order is inconsistent with the commit order. 
% We denote this RW dependency as a vulnerable dependency. The vulnerable dependency under SI and RC can be defined as follows:
% \begin{definition}
%     \label{def:vul}
%     For SI, the vulnerable dependency is $T_j \xrightarrow{rw} T_k$ in the chain $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$. For RC, a vulnerable dependency is any $T_i \xrightarrow{rw} T_j$ in the non-serializable scheduling. 
%     \qed
% \end{definition}
% In this paper, we propose a dynamic and fine-grained approach to avoid vulnerable dependencies by scheduling their commit order of transactions consistent with their dependency order, ensuring serializability under low isolation levels. 

% Furthermore, we denote a dependency in the static dependency graph as a static vulnerable dependency if it can produce a vulnerable dependency, potentially resulting in non-serializable scheduling. The definition is as follows:
% \begin{definition}
%     \label{def:static_vul}
%     For SI, the static vulnerable dependency is $\mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$ in the chain $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j \xrightarrow{rw} \mathcal{T}_k$. For RC, the static vulnerable dependency is $\mathcal{T}_i \xrightarrow{rw} \mathcal{T}_j$.
%     \qed
% \end{definition}
% This definition helps us more accurately identify the transactions that need to be scheduled in \sysname.

% Specifically, a vulnerable dependency under SI is represented as $T_j \xrightarrow{rw} T_k$ in the chain $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$. For RC, a vulnerable dependency is any $T_i \xrightarrow{rw} T_j$ in the non-serializable scheduling. 

% \subsection{Motivation}
% Existing approaches statically eliminate all dangerous structures in the static dependency graph to guarantee serializability under low isolation levels. 
% The presence of dangerous structures is a necessary condition for anomalies. Therefore, eliminating all dangerous structures from the static dependency graph guarantees serializability under low isolation levels. This strategy serves as the foundation of many existing methods. 
% However, according to Theorem~\ref{def:si} and \ref{def:rc}, not all dangerous structures result in non-serializable scheduling. 
% A static and coarse-grained approach of introducing additional write-write conflict is over-conservative and may not yield optimal results.

% According to the observation in the above section, serializability can also be guaranteed if we can ensure the commit order of transactions involved in the vulnerable dependencies aligns with their dependency order under low isolation levels.

% \subsection{Symbol Definition}
% We consider that transactions are generated by a fixed set $\Sigma$ of templates.
% Each template $\mathcal{T}^i \in \Sigma$ produces transaction instances denoted as $T^i_j$.
% For simplicity, when the context is clear, $T^i_j$ is abbreviated as $T_j$.
% Dependencies between two transaction templates, $\mathcal{T}^i$ and $\mathcal{T}^j$, are defined as follows:
% (1) $\mathcal{T}^i \xrightarrow{ww} \mathcal{T}^j$: if $\mathcal{T}^i$ and $\mathcal{T}^j$ write the same relation in sequence;
% (2) $\mathcal{T}^i \xrightarrow{rw} \mathcal{T}^j$: if $\mathcal{T}^i$ reads and $\mathcal{T}^j$ writes the same relation in sequence;
% (3) $\mathcal{T}^i \xrightarrow{wr} \mathcal{T}^j$: if $\mathcal{T}^i$ writes and $\mathcal{T}^j$ reads the same relation in sequence.

% Given two transaction templates $\mathcal{T}^i$ and $\mathcal{T}^j$, the dependency is represented as (1) $\mathcal{T}^i \xrightarrow{ww} \mathcal{T}^j$ if $\mathcal{T}^i$ and $\mathcal{T}^j$ write the same relation in sequence; (2) $\mathcal{T}^i \xrightarrow{rw} \mathcal{T}^j$ if $\mathcal{T}^i$ reads and $\mathcal{T}^j$ writes the same relation in sequence; (3) $\mathcal{T}^i \xrightarrow{wr} \mathcal{T}^j$ if $\mathcal{T}^i$ writes and  $\mathcal{T}^j$ reads the same relation in sequence, respectively.



% Let $T[rs]$ and $T[ws]$ be the read set and write set of $T$ during its execution.

% \begin{definition}[Static Dependency Graph]
%     A static dependency graph for the template set $\Sigma$ is represented as $SDG(\mathcal{V}, \mathcal{E})$, where:
%     \begin{itemize}%[leftmargin=*,itemsep=2pt,topsep=0pt,parsep=0pt]
%     \item $\mathcal{V}$ is a set of vertices, with each vertex $v_i$ corresponding to one and only one transaction template $T_i$ of $\Sigma$;
%     \item $\mathcal{E}$ is a set of edges, each represented as a triple $\langle v_i, d, v_j\rangle$, where $v_i$ and $v_j$ are vertices in $\mathcal{V}$, and $d$ denotes the dependency from $\mathcal{T}_i$ to $\mathcal{T}_j$, if any. 
%     \qed
%     \end{itemize}
    % A static dependency graph （DSG）comprises a 
    % In the static dependency graph, nodes represent transaction templates $\mathcal{T}$, and edges represent dependencies between these templates, indicating possible dependencies between transaction instances $T$.
    % If the intersection of the write set of $\mathcal{T}_i$ and $\mathcal{T}_j$ is not empty, there exists $\mathcal{T}_i \xrightarrow{ww} \mathcal{T}_j$. Similarly, if the intersection of the write set of $\mathcal{T}_i$ and the read set of $\mathcal{T}_j$ is not empty, there exist both $\mathcal{T}_i \xrightarrow{wr} \mathcal{T}_j$ and $\mathcal{T}_j \xrightarrow{rw} \mathcal{T}_i$. 
    % for an edge $\mathcal{T}_i \xrightarrow{wr} \mathcal{T}_j$, a non-empty intersection of the write set of $\mathcal{T}_i$ and the read set of $\mathcal{T}_j$. Conversely, if there exists an edge $\mathcal{T}_i \xrightarrow{wr} \mathcal{T}_j$, a non-empty intersection of the read set of $\mathcal{T}_i$ and the write set of $\mathcal{T}_j$ indicates a potential RW dependency. 
%     \label{def:sdg}
% \end{definition}

 %Next, we define the dynamic conflict graph below.
% Note, in $DSG.\mathcal{E}$, for any $e_1 = \langle v_i, rw, v_j, \mathcal R \rangle$ or $\langle v_i, wr, v_j, \mathcal R \rangle$, if $e_2 =\exists \langle v_i, ww, v_j, \mathcal R \rangle$, we omit the maintanence of $e_1$ and $e_2$.
% Notably, when both RW (WR) and WW dependency exists between $\mathcal{T}_i$ and $\mathcal{T}_j$, the RW (WR) dependency does not need to be explicitly labelled in the $SDG$ if it occurs during the presence of the WW dependency, according to transaction semantics. 
% $T_i$ and $T_j$ are guaranteed to have a WW dependency when an RW or WR dependency occurs, then these RW or WR dependencies need not be explicitly labelled.
% Figure 1(a) provides an example of the static dependency graph for SmallBank. Given two transactions, $T_i$ and $T_j$, the dependency from $T_i$ to $T_j$ can be categorized into three types. (1) $T_i \xrightarrow{ww} T_j$, if $T_i$ writes a version of data item $x$, and $T_j$ writes a subsequent version of $x$. (2) $T_i \xrightarrow{wr} T_j$, if $T_i$ writes a version of data item $x$, and $T_j$ reads either the version written by $T_i$ or a later version of $x$. (3) $T_i \xrightarrow{rw} T_j$, if $T_i$ reads $x$, and $T_j$ writes a later version of $x$. 
% Given two transactions $T^i$ and $T^j$, the dependency from $T^i$ to $T^j$ can be categorized into the following three types: (1) $T_i \xrightarrow{ww} T_j$, if $T_i$ writes a version of data item $x$, and $T_j$, writes a later version of $x$; (2) $T_i \xrightarrow{wr} T_j$, if $T_i$ writes a version of data item $x$, and $T_j$ reads the version written by $T_i$ or a later version of $x$; (3) $T_i \xrightarrow{rw} T_j$, if $T_i$ reads $x$, and $T_j$ subsequently writes a later version of $x$. 

% The dynamic conflict graph $CG$ is based on the execution history $H$ \cite{DBLP:conf/icde/AdyaLO00}. In this graph, each node represents a committed transaction $T$. An edge from $T_i$ to $T_j$ indicates that there is a dependency from $T_i$ to $T_j$. 

% \begin{definition}[Dynamic Conflict Graph]
%     \label{def:ddg}
%     Given a set of transactions generated from templates $\Sigma$ and a time point of the execution history $H$~\cite{DBLP:conf/icde/AdyaLO00} of these transactions, the dynamic conflict graph for $H$ is represented as $DCG(\mathcal{V}, \mathcal{E})$, where:
%     % In this graph, each node represents a committed transaction $T$. An edge from $T_i$ to $T_j$ indicates that there is a dependency from $T_i$ to $T_j$.
%     \begin{itemize}
%         \item $\mathcal{V}$ is a set of vertices, each $v_i$ corresponding to one and only one committed transaction $T_i$ in $H$. %For illustration purposes, let transaction $T^i$ be mapped to vertex $v_i$.
%         \item $\mathcal{E}$ is a set of edges, each of which is represented as a triple $\langle v_i, d, v_j\rangle$, where $v_i, v_j \in \mathcal{V}$, and $d$ denotes the dependency from $T_i$ to $T_j$ in $H$, if any.  \qed
%     \end{itemize}
% \end{definition}

% First, we define the conflict graph $CG$ based on the execution history $H$ \cite{DBLP:conf/icde/AdyaLO00}. In this graph, each node represents a committed transaction $T$. An edge from $T_i$ to $T_j$ indicates that there is a dependency from $T_i$ to $T_j$. The dependencies can be categorized into the following three types:
% \begin{itemize}[left=1em]
%     \item $T_i \xrightarrow{ww} T_j$ (write-write (WW) dependency) if $T_i$ writes a version of data item $x$, and $T_j$ %subsequently 
%     writes a later version of $x$;
%     \item $T_i \xrightarrow{wr} T_j$ (write-read (WR) dependency) if 
% $T_i$ writes a version of data item $x$, and $T_j$ reads $x$ or a later version of $x$;
%     \item $T_i \xrightarrow{rw} T_j$ (read-write (RW) dependency) if 
% $T_i$ reads $x$, and $T_j$ subsequently writes a later version of $x$.
% \end{itemize}


% {\color{blue}
% For database backend applications, the workload typically comprises some transaction templates $\mathcal{T}_i$. A transaction template is a predefined structure composed of queries and placeholders. During the generation of real-time transactions, these placeholders are filled with specific values, known as keys, to operate the RDBMS.}

% Previous studies have utilized the static dependency graph ($SDG$) to analyze potential dependencies between these templates~\cite{DBLP:journals/sigmod/KetsmanKNV22} statistically. Like $CG$, each node in $SDG$ represents a transaction template $\mathcal{T}$, giving rise to transaction instance $T$. An edge from $\mathcal{T}_a$ to $\mathcal{T}_b$ implies a potential execution where a dependency between the instance $T_i$ and $T_j$ can occur. In other words, the dependency edges in $CG$ can be mapped to the edges in $SDG$. 

% \begin{definition}[Vulnerable Edge~\cite{DBLP:conf/pods/Fekete05}]
%     % We denote a static dependency as a vulnerable edge if it can generate a run-time dependency that proceeds in the opposite direction from the commit order of transactions. 
%     A dependency is a vulnerable edge if it has the potential to generate a run-time dependency that proceeds in the reverse direction of the commit order of transactions. 
%     \label{def:vulnerable_edge}
%     \qed
% \end{definition}


% Specifically, 
% This paper focuses on SI and RC isolation levels, where transactions apply modifications only after committing. This implies that if there are WR or WW dependencies between $T_i$ and $T_j$, $T_i$ must commit before $T_j$ does.
% Consequently, if $T_j$ depends on $T_i$ but $T_i$ commits after $T_j$, the only possible dependency is a \textit{rw} dependency, e.g., vulnerable edges can only be rw dependencies.

% \subsection{Dangerous Structure Modeling}
% It is generally understood that if there's no cycle in the $SG$, the execution $H$ is serializable. Weak isolation levels, however, can give rise to various data anomalies, which are depicted by cycles in the MVSG. For decades, numerous studies have investigated the characteristics of these cycles at each isolation level~\cite{}. We will now discuss the traits of cycles in SI and RC, respectively. 

% It is generally understood that if no cycles exist in the $CG$, the execution $H$ is conflict serializable. However, low isolation levels permit certain data anomalies, manifesting as cycles in the $CG$. For decades, numerous studies have investigated the characteristics of these cycles under various isolation levels. We will now discuss the traits of cycles in SI and RC levels, respectively.

% We now define the term ``dangerous structure'', acceptable at lower isolation levels but may form dependency cycles that violate SER isolation.

% \begin{definition}[SI Dangerous Structure~\cite{DBLP:conf/sigmod/CahillRF08}]
%     \label{def:SI}
%     In the dynamic conflict graph $DCG$, two consecutive edges $\langle v_i, rw, v_j\rangle$ and $\langle v_j, rw, v_k\rangle $ are deemed to constitute an SI dangerous structure only if $T_i$ and $T_j, T_j$ and $T_k$ are concurrent transactions separately.
    % an SI dangerous structure is defined as a pattern with two edges $\langle T_i, rw, T_j\rangle$, and $\langle T_j, rw, T_k\rangle$.
    % Every dependency cycle in $CG$ contains two triple $\langle T_i, rw, T_j\rangle$ and $\langle T_j, rw, T_k\rangle$, 
    % % consecutive vulnerable edges $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, 
    % where each of these edges is between a pair of transactions that are concurrent with each other. Furthermore, $T_k$ is the first transaction to commit in the cycle.
    % \textcolor{red}{defincition of Dangerous Structure}
%     \qed
% \end{definition}

% \begin{definition}
% \label{def:RC}
% If a static dependency graph $SDG$ contains no SI (resp. RC) dangerous structures, then there will be no cycles in the dynamic conflict graph ($DCG$) of $SDG$ when the database is configured with RC (resp. RC) isolation. \qed
% \end{definition}

% \begin{theorem}
% \label{the:SI}
% If a static dependency graph $SDG$ contains no SI dangerous structures, then there will be no cycles in the dynamic conflict graph ($DCG$) of $SDG$ when the database is configured with SI isolation. \qed
% \end{theorem}

% In SI, the anomaly cycle must have two consecutive vulnerable dependency edges~\cite{}, e.g. $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, which is known as \textit{dangerous structure}. Each edge in this structure is between a pair of transactions concurrently executed, with the last transaction, $T_k$, being the first to commit. 

% \begin{definition}[RC Dangerous Structure~\cite{DBLP:conf/aiccsa/AlomariF15, DBLP:conf/icdt/VandevoortK0N22}]
%     \label{def:rc}
%         In the dynamic conflict graph $DCG$, an edge $\langle v_i, rw, v_j\rangle \in DCG.\mathcal{E}$ is deemed to constitute an RC dangerous structure only if $T_i$ and $T_j$ are concurrent transactions.
%     \qed
% \end{definition}

% If $T_i \rightarrow T_j$ in the $CG$ of the execution history $H$, then $\mathcal{T}_i \rightarrow \mathcal{T}_j$ in the $SDG$ of the transaction template $\mathcal{T}$. 
% It is trivial to deduce from Theorem~\ref{theorem-1} since every dependency edge in CG can be mapped into SDG.
% If a dependency cycle exists in CG, there is always a corresponding dependency cycle in SDG.
% Dynamic conflict graphs are the instances at a certain time point of the static dependency graph.
% This means, if there is a cycle in the dynamic conflict graph, then this cycle must exist in the static dependency graph; additionally, if there is no dangerous structures in the static dependency graph, then 

% (Adya, 1999) showed that any cycle produced by SI has two rw- dependency edges. This was extended in (Fekete et al., 2005), which showed that any cycle must have two rw-dependency edges that occur consecutively, and further, each of these edges is between a pair of transactions that are concurrent with each other.

% \subsection{{\color{blue} Motivation}}
% Rethinking the previously mentioned techniques, they introduce ww dependencies to avoid data anomalies at weak isolation levels. This usually curtails the concurrency, subsequently erasing some of the performance advantages derived from weaker isolation levels. Additionally, these methods often solely adjust the workload to fit the weak isolation level, neglecting the significance of identifying the most appropriate isolation approach for the workload, especially in scenarios where the workload is dynamic. In other words, we need to trade-off between modifying the workload and the weak isolation levels of the database. 
% As a result, we design a validation-based approach to minimize the overhead associated with preventing data anomalies and an adaptive model to tailor isolation levels for various workloads.
