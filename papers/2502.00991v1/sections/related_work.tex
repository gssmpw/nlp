\section{Related Work}
% \noindent\textbf{Concurrency control to guarantee SER.}  
% SER is regarded as the gold standard for transaction processing as its execution aligns with a serial execution. Much of the existing literature on serializability has explored a variety of algorithms, including 2PL and its variants~\cite{DBLP:journals/pvldb/BarthelsMTAH19, DBLP:journals/csur/BernsteinG81}, OCC and its variants~\cite{DBLP:conf/sosp/TuZKLM13,DBLP:conf/sigmod/YuPSD16,DBLP:conf/sigmod/KimWJP16,DBLP:conf/sigmod/LimKA17,DBLP:journals/pvldb/YuXPSRD18}
% % , and MVCC~\cite{DBLP:journals/pvldb/FaleiroA15, DBLP:conf/sigmod/0001MK15,durner2019no}. 
% Meanwhile, these are some works based on timestamp ordering~\cite{DBLP:journals/vldb/WangJFP17, DBLP:journals/vldb/WangJFP18, DBLP:journals/tkde/ZhaoZZLLZPD23, DBLP:journals/csur/BernsteinG81}, which intend to keep the commit order consistent with dependency order by checking the timestamp. 
% These algorithms effectively eliminate all forms of anomalies associated with concurrent transaction execution. Still, they can not fit in all workloads~\cite{DBLP:journals/pvldb/YuBPDS14,DBLP:journals/pvldb/HardingAPS17,DBLP:journals/pvldb/WuALXP17,DBLP:journals/pvldb/BarthelsMTAH19,DBLP:journals/pvldb/TanabeHKT20,DBLP:journals/pvldb/HuangQKLS20} and are designed for database kernel, which increase the development overhead. 
%The scheduling required to ensure serializability can be quite expensive, leading to potential bottlenecks in system performance. 
% SER is regarded as the gold standard for transaction processing. Existing literature on serializability has explored a variety of algorithms, including 2PL and its variants~\cite{DBLP:journals/pvldb/BarthelsMTAH19, DBLP:journals/csur/BernsteinG81}, as well as OCC and its variants~\cite{DBLP:conf/sosp/TuZKLM13,DBLP:conf/sigmod/YuPSD16,DBLP:conf/sigmod/KimWJP16,DBLP:conf/sigmod/LimKA17,DBLP:journals/pvldb/YuXPSRD18}. Additionally, there are studies based on timestamp ordering~\cite{DBLP:journals/vldb/WangJFP17, DBLP:journals/vldb/WangJFP18, DBLP:journals/tkde/ZhaoZZLLZPD23, DBLP:journals/csur/BernsteinG81}, which aim to maintain consistency between commit order and dependency order by checking timestamps. These algorithms effectively eliminate all forms of anomalies associated with concurrent transaction execution. However, they are not suitable for dynamic workloads~\cite{DBLP:journals/pvldb/YuBPDS14,DBLP:journals/pvldb/HardingAPS17,DBLP:journals/pvldb/WuALXP17,DBLP:journals/pvldb/BarthelsMTAH19,DBLP:journals/pvldb/TanabeHKT20,DBLP:journals/pvldb/HuangQKLS20} and are designed specifically for database kernels at SER level, which increases development overhead. In contrast, \sysname can guarantee SER across various isolation levels without requiring modifications to the database kernel.

% \noindent\textbf{Adaptive transaction processing.} 
% These studies adaptively select concurrency control protocols for dynamic workloads. SMF~\cite{DBLP:journals/pvldb/ChengKCSBCS24:SMF} greedy selects the next transaction to run based on the one that would lead to the smallest increase in execution time. Wagner et al.\textcolor{red}{~\cite{}} split each query into morsels and used a self-tuning stride scheduler to allocate resources to optimize tail latency adaptively. 
% Tebaldi~\cite{DBLP:conf/sigmod/SuCDAX17:Tebaldi} constructs hierarchical concurrency control by analyzing the stored procedures. Polyjuice~\cite{DBLP:conf/osdi/WangDWCW0021:Polyjuice} introduces reinforcement learning to design specific concurrency control for each stored procedure. 
% % However, the decision-making cost cannot be ignored, especially in transactional workloads, and these approaches are hard to implement because implementing a single concurrency control mechanism is very complex in industrial databases. In this paper, \sysname considers a broader range of isolation levels and employs middle-tier concurrency control algorithms without modifying the database kernel to ensure SER under low isolation levels, thereby enhancing efficiency. 
% Compared to \sysname, a common issue in these approaches is that they need to modify the database kernel, which introduces incalculable implementation overhead. The middle-tier concurrency control and self-adaptive mechanism make \sysname both efficient and correct without modification of the database kernel. 
% These studies adaptively select concurrency control protocols for dynamic workloads. For instance, SMF~\cite{DBLP:journals/pvldb/ChengKCSBCS24:SMF} greedy selects the next transaction to run based on the one that would lead to the smallest increase in execution time. Wagner et al.\textcolor{red}{~\cite{}} split each query into morsels and used a self-tuning stride scheduler to allocate resources to optimize tail latency adaptively. 
% Tebaldi~\cite{DBLP:conf/sigmod/SuCDAX17:Tebaldi} constructs hierarchical concurrency control by analyzing the stored procedures. Polyjuice~\cite{DBLP:conf/osdi/WangDWCW0021:Polyjuice} introduces reinforcement learning to design specific concurrency control for each stored procedure. 
% Our research is orthogonal to these algorithms; while they dynamically select the optimal concurrency control protocol for dynamic workloads, \sysname dynamically selects the best isolation level.
    

% \noindent\textbf{Serializable scheduling under low isolation levels.}  
% Recent studies have revealed that scheduling entire transaction workloads under low isolation levels can still achieve serializability by adjusting specific query patterns. For example, Fekete provides necessary and sufficient conditions for SI to achieve serializable scheduling~\cite{DBLP:conf/pods/Fekete05, alomari2008serializable}. A notable example is the TPC-C benchmark, which remains serializable even when executed at the SI level. Ketsman \cite{DBLP:journals/tods/KetsmanKNV22} investigated the characteristics of non-serializable scheduling under RC and Read Uncommitted isolation levels. This theoretical framework has been further refined with functional constraints by Vandevoort et al.~\cite{DBLP:conf/icdt/VandevoortK0N22}.
% Building on these theoretical foundations, it has been shown that workload can achieve serializable scheduling through modifications to the application logic via transaction templates, thereby enhancing performance \cite{DBLP:journals/pvldb/VandevoortK0N21}. %In this context, \sysname leverages these theoretical insights to implement serializable scheduling accurately and efficiently across various isolation levels, all without modification to application logic. 
% In light of these theoretical insights, \sysname is capable of accurately implementing serializable scheduling across various isolation levels, taking into account both static and dynamic workload characteristics.


% \noindent\textbf{Concurrency control at the application level}. Some application developers emphasize application-level concurrency control using mechanisms such as Java's ReentrantLock or \textit{key-value} stores like Redis \cite{Redis}. Tang et al. \cite{DBLP:journals/tods/WangTZYZGC24, DBLP:conf/sigmod/TangWZYZG022, DBLP:journals/sigmod/TangWZYZG023} provide insights into ad-hoc transactions, which employ flexible and efficient concurrency control on the application side. Bailis et al. \cite{DBLP:journals/pvldb/BailisFFGHS14} introduce the application-dependent correctness criterion known as \textit{I-confluence}, which assesses whether coordination-free transaction execution preserves application invariants. Conway et al. \cite{DBLP:conf/cloud/ConwayMAHM12} employ monotonicity analysis to eliminate the need for coordination in distributed applications. 
% %These techniques require developers to be sophisticated in concurrency control, which increases the likelihood of errors to some extent. In contrast, \sysname leverages the isolation levels of RDBMS and ensures serializability (SER) through automatic workload analysis. Furthermore, \sysname can adaptively select appropriate isolation levels to maintain high efficiency.
% These techniques require that developers possess a high level of expertise in concurrency control and often require significant modifications at the application level, which can increase the likelihood of errors to some extent. In contrast, \sysname leverages the isolation levels of RDBMS and ensures serializability through automatic workload analysis, requiring only lightweight modifications to the application.



% is efficient ensures serializability by adaptively selecting appropriate isolation levels.

% \noindent\textbf{Isolation guarantees in RDBMSs.} 
% The definition of isolation levels in ACID databases has evolved over decades. The ANSI/ISO SQL-92 standard defines four isolation levels \cite{DBLP:books/daglib/0067148}. However, due to the lack of mathematical formalization and potential ambiguities in SQL-92, several works have redefined data anomalies more formally \cite{DBLP:conf/sigmod/BerensonBGMOO95,adya1999weak,DBLP:conf/podc/CrooksPAC17,DBLP:conf/ds/GrayLPT76,DBLP:conf/eurosys/SzekeresZ18, DBLP:journals/pacmmod/LiuMWB24, DBLP:conf/concur/Cerone0G15, DBLP:journals/tkde/ZhaoZZLLZPD23}. The definition proposed by Adya~\cite{adya1999weak, DBLP:conf/icde/AdyaLO00} supports a wide range of concurrency control implementations. 
% Typical concurrency control encompasses various algorithms, including 2PL~\cite{DBLP:journals/pvldb/BarthelsMTAH19, DBLP:journals/csur/BernsteinG81}, OCC~\cite{DBLP:conf/sosp/TuZKLM13,DBLP:conf/sigmod/YuPSD16,DBLP:conf/sigmod/KimWJP16,DBLP:conf/sigmod/LimKA17,DBLP:journals/pvldb/YuXPSRD18}, timestamp ordering~\cite{DBLP:journals/csur/BernsteinG81}, and MVCC~\cite{DBLP:journals/pvldb/FaleiroA15, DBLP:conf/sigmod/0001MK15,durner2019no}. These techniques are orthogonal to \sysname, which considers the RDBMS a black box providing different isolation levels. 

% Recent works include TCM~\cite{DBLP:conf/icde/LometFWW12}, Silo~\cite{DBLP:conf/sosp/TuZKLM13}, TicToc \cite{DBLP:conf/sigmod/YuPSD16}, Sundial~\cite{DBLP:journals/pvldb/YuXPSRD18}, and RedT \cite{DBLP:journals/pvldb/ZhangLZXLXHYD23}.
% \noindent\textbf{Serializable techniques for applications.} 

% \noindent\textbf{Serializability techniques based on transaction templates.}
% Research has also investigated whether weak isolation levels can guarantee serializable scheduling under specific workloads. Fekete provides necessary and sufficient conditions against Snapshot Isolation~\cite{DBLP:conf/pods/Fekete05, alomari2008serializable}. Ketsman \cite{DBLP:journals/tods/KetsmanKNV22} characterized robustness against Read Committed and Read Uncommitted levels. This has been further refined with functional constraints by Vandevoort et al. ~\cite{DBLP:conf/icdt/VandevoortK0N22}. 
% % atomic visibility..., mixed isolations can not work for some platforms.
% \sysname leverages these theoretical foundations to accurately and efficiently implement serializable scheduling across different isolation levels. 
% In addition to the approaches we compared in the evaluation, IsoDiff~\cite{DBLP:journals/pvldb/GanRRB020} represents a tool to detect and resolve potential anomalies caused by executing transactions under RC or SI.  ConsAD~\cite{DBLP:conf/sigmod/ZellagK12} traces all dependencies in the middle tier and reports the inconsistent dependency cycle to database administrators (DBA), who choose an appropriate isolation level. It is worth noticing that \sysname achieves self-adaptive isolation level selection without the involvement of DBA. 

% \noindent\textbf{Concurrency control techniques in applications.} Applications rely on RDBMS to manage data with ACID guarantees, typically using ORM frameworks like Hibernate \cite{Hibernate}, and Mybatis \cite{Mybatis} to generate SQL statements transparently. Some developers emphasize application-level concurrency control, using mechanisms like Java's ReentrantLock or \textit{key-value} stores such as Redis \cite{Redis}. Bailis et al. \cite{DBLP:journals/pvldb/BailisFFGHS14} introduced the application-dependent correctness criterion \textit{I-confluence}, which determines if coordination-free transaction execution preserves application invariants. Conway et al. \cite{DBLP:conf/cloud/ConwayMAHM12} proposed using monotonicity analysis to eliminate coordination in distributed applications.
% Tang et al. \cite{DBLP:journals/tods/WangTZYZGC24, DBLP:conf/sigmod/TangWZYZG022, DBLP:journals/sigmod/TangWZYZG023} provided insights into ad-hoc transactions, which employ flexible and efficient concurrency control on the application side, although they identified bugs in 53 out of 71 cases.
% The paradigm of \sysname aims to avoid application-side concurrency control and efficiently ensures serializability by self-adaptive isolation level selection. 

% Future work will focus on further optimizing \sysname and exploring advanced application transaction techniques, such as column-based concurrency control and transaction-semantic-aware scheduling mechanisms.
Our study is related to the previous work on concurrency control algorithms that ensure serializable scheduling within and outside the database kernel.


\noindent\textbf{Within the database kernel.} 
Existing works have explored a variety of algorithms to guarantee SER, including 2PL, OCC, timestamp ordering (TO) and their variants \cite{DBLP:journals/pvldb/BarthelsMTAH19, DBLP:journals/csur/BernsteinG81, DBLP:conf/sosp/TuZKLM13,DBLP:conf/sigmod/YuPSD16,DBLP:conf/sigmod/KimWJP16,DBLP:conf/sigmod/LimKA17,DBLP:journals/pvldb/YuXPSRD18, DBLP:journals/tkde/ZhaoZZLLZPD23, DBLP:journals/vldb/WangJFP17, DBLP:journals/vldb/WangJFP18}. 
% Moreover, Wang \cite{DBLP:journals/vldb/WangJFP17, DBLP:journals/vldb/WangJFP18} design a concurrency control mechanism that makes low isolation level concurrency control algorithms serializable.
% Wang et al.~\cite{DBLP:journals/vldb/WangJFP17, DBLP:journals/vldb/WangJFP18} proposed a mechanism to make low isolation level concurrency control algorithms serializable. 
While these algorithms effectively eliminate anomalies in concurrent transaction execution, they offer varying performance benefits depending on the workload. To address this, some studies propose adaptive concurrency control algorithms for dynamic workloads.
For instance, SMF~\cite{DBLP:journals/pvldb/ChengKCSBCS24:SMF} greedily selects the next transaction based on the one that would result in the least increase in execution time. Tebaldi~\cite{DBLP:conf/sigmod/SuCDAX17:Tebaldi} constructs a hierarchical concurrency control model by analyzing stored procedures.  Polyjuice~\cite{DBLP:conf/osdi/WangDWCW0021:Polyjuice} employs reinforcement learning to design tailored concurrency control mechanisms for each stored procedure, while Snapper~\cite{DBLP:conf/sigmod/Liu00ZS22:Snapper} mixes deterministic and non-deterministic (i.e., 2PL) algorithms.
However, all these algorithms are explicitly tailored for database kernels, which limits their broader applicability and generalizability. In contrast, \sysname requires no kernel modifications and integrates seamlessly with various database systems. More importantly, \sysname boosts performance by adaptively assigning the optimal isolation level based on workload characteristics while preserving SER.

% However, all these algorithms are designed specifically for database kernels, limiting their broader applicability and generalizability. In contrast, \sysname requires no kernel modifications and integrates seamlessly with various databases.
% More importantly, \sysname enhances performance by adaptively allocating the optimal isolation level based on workload characteristics while maintaining SER.
%, even those using the advanced concurrency control algorithms mentioned above. 
% Additionally, certain workloads can safely operate at lower isolation levels. By adaptively allocating the optimal isolation level based on workload characteristics, \sysname enhances performance while maintaining SER.

% However, all these algorithms are designed for database kernels, which limits their broader applicability and generalizability. In contrast, \sysname requires no kernel modifications and integrates seamlessly with various databases, even if those databases employ the aforementioned advanced concurrency control algorithms. Moreover, certain workloads can safely execute at lower isolation levels. By self-adaptively allocating the optimal isolation level based on workload characteristics, \sysname enhances performance while maintaining serializability. 
% Therefore, these techniques are orthogonal to our approach. 

% Existing literature on serializability has explored a variety of algorithms, including 2PL and its variants~\cite{DBLP:journals/pvldb/BarthelsMTAH19, DBLP:journals/csur/BernsteinG81}, as well as OCC and its variants~\cite{DBLP:conf/sosp/TuZKLM13,DBLP:conf/sigmod/YuPSD16,DBLP:conf/sigmod/KimWJP16,DBLP:conf/sigmod/LimKA17,DBLP:journals/pvldb/YuXPSRD18}. Additionally, there are studies based on timestamp ordering~\cite{DBLP:journals/tkde/ZhaoZZLLZPD23, DBLP:journals/csur/BernsteinG81}, which aim to maintain consistency between commit order and dependency order by checking timestamps. These algorithms effectively eliminate all forms of anomalies associated with concurrent transaction execution. However, they are not suitable for dynamic workloads~\cite{DBLP:journals/pvldb/YuBPDS14,DBLP:journals/pvldb/HardingAPS17,DBLP:journals/pvldb/WuALXP17,DBLP:journals/pvldb/BarthelsMTAH19,DBLP:journals/pvldb/TanabeHKT20,DBLP:journals/pvldb/HuangQKLS20}.



% \noindent\textbf{Concurrency control techniques inside applications.} 
\noindent\textbf{Outside the database kernel.} 
Some application developers prioritize application-level concurrency control using mechanisms such as Java's ReentrantLock or memory stores like Redis \cite{Redis}. Tang et al. \cite{DBLP:journals/tods/WangTZYZGC24, DBLP:conf/sigmod/TangWZYZG022, DBLP:journals/sigmod/TangWZYZG023} provide valuable insights into ad-hoc transactions, which offer flexible and efficient concurrency control on the application side. Bailis et al. \cite{DBLP:journals/pvldb/BailisFFGHS14} introduce the application-dependent correctness criterion known as \textit{I-confluence}, which evaluates whether coordination-free execution preserves application invariants. Conway et al. \cite{DBLP:conf/cloud/ConwayMAHM12} use monotonicity analysis to eliminate the need for coordination in distributed applications.
% Some application developers emphasize application-level concurrency control using mechanisms such as Java's ReentrantLock or memory stores such as Redis \cite{Redis}. Tang et al. \cite{DBLP:journals/tods/WangTZYZGC24, DBLP:conf/sigmod/TangWZYZG022, DBLP:journals/sigmod/TangWZYZG023} provide insights into ad-hoc transactions, which employ flexible and efficient concurrency control on the application side. Bailis et al. \cite{DBLP:journals/pvldb/BailisFFGHS14} introduce the application-dependent correctness criterion known as \textit{I-confluence}, which assesses whether coordination-free execution preserves application invariants. Conway et al. \cite{DBLP:conf/cloud/ConwayMAHM12} employ monotonicity analysis to eliminate the need for coordination in distributed applications. 
% %These techniques require developers to be sophisticated in concurrency control, which increases the likelihood of errors to some extent. In contrast, \sysname leverages the isolation levels of RDBMS and ensures serializability (SER) through automatic workload analysis. Furthermore, \sysname can adaptively select appropriate isolation levels to maintain high efficiency.
These techniques demand that developers have a high level of expertise in concurrency control, which can increase the risk of errors. In contrast, \sysname relieves programmers from the complexities of concurrency control, ensuring efficiency through self-adaptive isolation level selection with minimal application modifications.
% These techniques require that developers possess a high level of expertise in concurrency control, which can increase the likelihood of errors. In contrast, \sysname frees programmers from concurrency control and ensures efficiency through self-adaptive isolation level selection with lightweight modifications to applications.

% \noindent\textbf{Serializability in low isolation levels. }
The most relevant work to ours demonstrates that scheduling entire workloads under low isolation levels can still achieve SER by adjusting specific query patterns. Fekete et al. provide the necessary and sufficient conditions for SI to achieve serializable scheduling~\cite{DBLP:conf/pods/Fekete05, alomari2008serializable}. 
% A notable example is the TPC-C benchmark, which remains serializable even when executed at the SI level. 
Ketsman et al. \cite{DBLP:journals/tods/KetsmanKNV22, DBLP:journals/pvldb/VandevoortK0N21} investigate the characteristics of non-serializable scheduling under RC and Read Uncommitted isolation levels. This theoretical framework has been further refined with functional constraints by Vandevoort et al.~\cite{DBLP:conf/icdt/VandevoortK0N22}. 
% Building on these theoretical foundations, it has been shown that workload can achieve serializable scheduling through modifications to the application logic via transaction templates, thereby enhancing performance \cite{}. 
%In this context, \sysname leverages these theoretical insights to implement serializable scheduling accurately and efficiently across various isolation levels, all without modification to application logic. 
Based on these insights, \sysname can accurately and efficiently achieve serializable scheduling across various isolation levels. To the best of our knowledge, \sysname is the first work to model the trade-off between the performance benefits and the serializability overhead under low isolation levels, achieving the self-adaptive isolation level selection. 