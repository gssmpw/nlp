\section{Implementation\label{implementation}}
We implement \sysname from scratch using Java and Python, comprising approximately 6,000 lines of Java code and 500 lines of Python code. \sysname is publicly available via \url{https://github.com/dbiir/TxnSailsServer}. Implemented outside the database kernel, \sysname can seamlessly integrate with any RDBMS that offers the isolation levels defined in~\cite{DBLP:conf/icde/AdyaLO00, DBLP:journals/pvldb/PortsG12}, enhancing performance and ensuring SER.

% We implement \sysname from scratch using Java and Python, involving about 6k lines of Java code and 0.5k lines of Python code. \sysname is publicly available via~\cite{TxnSails}. 
% \extended{
% Our implementation introduces three components: {\it Analyzer}, {\it Executor}, and {\it Adapter}.
% }
% % Our implementation introduces three components: {\it Analyzer}, {\it Executor}, and {\it Adapter}. % to support SER with self-adaptive isolation level selection. 
% \sysname is implemented outside the database kernel, and all RDBMSs, offering the isolation levels defined in theorem~\cite{DBLP:conf/icde/AdyaLO00, DBLP:journals/pvldb/PortsG12} 
% can seamlessly use \sysname to enhance the performance to achieve SER.

% adhere to the isolation level definition specified in previous theorem~\cite{DBLP:conf/icde/AdyaLO00, DBLP:journals/pvldb/PortsG12} can seamlessly use \sysname 

% does not modify the database kernel. {\em As a result, databases that adhere to the isolation level definition specified in previous theorem~\cite{DBLP:conf/icde/AdyaLO00, DBLP:journals/pvldb/PortsG12} can seamlessly use \sysname as a serializable scheduling provider.}
% libraries implementation
% \sysname also implements a connection pool to manage application connections.

% \textit{Template interfaces} are exposed for transaction template registration and analyzation, and \textit{execution interfaces} manages runtime transaction execution.
% Specifically, \textit{template interfaces} are used to register and analyze transaction templates, while \textit{execution interfaces} handle the execution of runtime transactions. 
\begin{table}[t]
    \caption{Interfaces of \sysname}
    \vspace{-4mm}
    \small
    \centering
    \resizebox{\linewidth}{!}{
    \begin{tabular}{ll}
        \Xhline{1.2pt}
        \multicolumn{2}{c}{\textit{Transaction template interfaces}} \\ 
        \Xhline{1.2pt}
        \textit{\makecell[l]{register(template\_name, sql)\\ $\qquad$ $\rightarrow$ SQL ID}}  & \makecell[l]{Register each sql with the template names \\ and receive the sql index in \sysname.} \\ \hline
        \textit{analysis()} & \makecell[l]{Analyze and identify static vulnerable \\ dependencies in low isolation levels.}  \\
        \Xhline{1.2pt}
        \multicolumn{2}{c}{\textit{Transaction execution interfaces}} \\ 
        \Xhline{1.2pt}
        \textit{begin()/commit()/rollback() }   & Begin/Commit/Rollback a transaction. \\ \hline
        \textit{\makecell[l]{execute(template\_name, SQL ID,\\ List[args]) $\qquad$ $\rightarrow$ result}}  & \makecell[l]{Execute the statement with its arguments \\ and receive the execution result.}  \\
        \Xhline{1.2pt}
        \label{tab:api}
    \end{tabular}
    }
    \vspace{-8mm}
\end{table}

% \begin{table}[t]
%     \caption{The \sysname client library}
%     \vspace{-4mm}
%     \small
%     \centering
%     \resizebox{\linewidth}{!}{
%     \begin{tabular}{llll}
%         \Xhline{1.2pt}
%         % \multicolumn{3}{l}{\textit{Transaction template interfaces}} \\ 
%         Interface name & Inputs & Outputs & Description\\
%         \Xhline{1.2pt}
%         \textit{register} & Template name, SQL & SQL ID & register transaction templates\\ \hline
%         \textit{analysis} &  & & Analyze and identify static vulnerable dependencies \\ 
%         \Xhline{1.2pt}
%         \Xhline{1.2pt}
%         \textit{begin/commit/abort} & & & Begin/Commit/Abort a transaction \\ \hline
%         \textit{execute} & Template name, SQL ID, List[args] & result & execute the SQL statement \\
%         \Xhline{1.2pt}
%         \label{tab:api}
%     \end{tabular}
%     }
%     \vspace{-8mm}
% \end{table}

\noindent\textbf{Interfaces.} Applications interact with \sysname via predefined interfaces, as detailed in Table~\ref{tab:api}.
To start, applications register transaction templates by \textit{register} interface, which parses SQL templates, extracts operation types and potential data sets, and outputs a unique SQL ID. Then, \textit{analysis} interface is used to identify static vulnerable dependencies under low isolation levels.
During execution, transactions are initiated through \textit{begin} interface, which assigns a unique ID for middle-tier concurrency control. Transactions are executed via \textit{execute} interface, passing the template name, SQL ID, and runtime arguments. \sysname transparently manages concurrency control and isolation levels. Finally, transactions are completed using \textit{commit/rollback} interface.


% During execution, transactions are started by \textit{begin} interface, which assigns a unique ID for middle-tier concurrency control. Transactions are run via the \textit{execute} interface, passing the template name, SQL ID, and runtime arguments. \sysname transparently manages concurrency control and isolation levels.
% Finally, transactions are completed by \textit{commit/rollback} interface. 
% . If the transaction executes without exceptions, \sysname commits it; otherwise, \sysname aborts it.

% Applications first connect to \sysname and invoke the library functions list in Table~\ref{tab:api} to complete their transactions. \sysname implements a thread pool to manage these connections.

\noindent\textbf{Analyzer.} We implement \textit{SDGBuilder} class that takes transaction templates as input and constructs a static dependency graph. The graph is then passed to \textit{CycleFinder} class to detect cycles based on the characteristics defined in Theorem~\ref{the:RC}. Finally, it identifies transaction templates with static vulnerable dependencies and stores the results in a \textit{MetaWorker} instance.

\noindent\textbf{Executor.} 
\textit{Executor} invokes \textit{SQLRewrite()} function to rewrite queries, selecting the appropriate record version if its template is involved in static vulnerable dependencies. It then sends the rewritten query to the database and records the \textit{vid} column.
Additionally, we implement a critical data structure, \textit{ValidationMetaTable}, which is initialized before any transactions are received to perform middle-tier validation in both single- and cross-isolation scenarios. Organized as a hash table, each bucket in the table represents a list of \textit{ValidationMeta} entries, including \textit{validation lock}, \textit{latest version}, and \textit{lease} information.
% {\it Executor} invokes {\it SQLRewrite()} function to rewrite queries, selecting the version of the record if its template is involved in static vulnerable dependencies. It then sends the rewritten query to the database and records the \textit{vid} column. 
% Additionally, we implement a crucial data structure, \textit{ValidationMetaTable}, which is initialized before any transactions are received to perform middle-tier validation in single- or cross-isolation scenarios. It is organized as a hash table, with each bucket representing a list of {\it ValidationMeta}, including {\it validation lock}, {\it latest version}, and {\it lease} information. 
A dedicated thread handles garbage collection of expired meta entries by comparing the \textit{lease} with the system's real-time clock. Moreover, we implement the \textit{WAIT-DIE} strategy within the \textit{ValidationMetaTable} to prevent deadlocks.
% A dedicated thread is responsible for garbage collection of expired meta entries by comparing the \textit{lease} and real-time system clock. Furthermore, we implement a {\it WAIT-DIE} strategy within {\it ValidationMetaTable} to prevent deadlocks.

\noindent\textbf{Adapter.} 
We first implement \textit{TransactionCollector} class that collects the read and write sets for transactions. Then, we implement a {\it RDGBuilder} class to build the runtime dependency graph. Finally, {\it Adapter} is implemented with the aid of \textit{torch\_geometric}, taking the runtime dependency graph as input and outputting the optimal isolation level.
% . It inputs the runtime dependency group and outputs the optimal isolation level. 
To ensure cross-platform compatibility and efficiency, the Python and Java components communicate via \textit{sockets}. 