\section{correctness}\label{sec:correctness}
% In this section, we prove the serializability under low isolation levels and the cross-isolation levels within \sysname. 
% Previous sections have demonstrated that the validation-based concurrency control guarantees the commit order of two transactions involved in a dependency. 

% Before we prove the guarantee of serializability in a weak isolation level, we first specify the relationship between the conflict graph (CG), which is constructed on the execution history, and the static dependency graph (SDG), which is based on transaction templates.
% For better illustration, the proof atmosphere is two-step; first, we will show that concurrency control in middleware guarantees the commit order of two transactions with dependency; then, we will prove the serializable guarantee of the workload in \sysname. 

% CG 中的依赖和 SDG 中的依赖是有对应关系的。
% \noindent\begin{lemma}
%     If $T_i \rightarrow T_j$ in the $CG$ of the execution history $H$, then $\mathcal{T}_i \rightarrow \mathcal{T}_j$ in the $SDG$ of the transaction template $\mathcal{T}$. 
%     % As a partial converse, if $\mathcal{T}_i \rightarrow \mathcal{T}_j$, then either $T_i \rightarrow T_j$ or $T_j \rightarrow T_i$ in $H$.
%     \label{theorem-1}
% \end{lemma}

% \noindent\textbf{Proof.} Suppose $T_i \rightarrow T_j$ within the execution history $H$, if $T_i \xrightarrow{ww} T_j$, then $H$ contains two write operations $w_i[x]$ and $w_j[x]$, belonging to $T_i$ and $T_j$, respectively. $x$ belongs to the intersection of the write sets of $T_i$ and $T_j$, it implies that $\mathcal{T}_i$ has potential ww dependency with $\mathcal{T}_j$. Thus, there exists a ww dependency in the $SDG$. Similarly, if there is rw or wr dependency between $T_i$ and $T_j$. 
% % For the partial converse, suppose $\mathcal{T}_i \rightarrow \mathcal{T}_j$ in the $SDG$. 
% \textcolor{red}{where do we need this result?}
% \noindent\textbf{Proof.} Suppose $T_i \rightarrow T_j$ within the execution history $H$, and condiser the case where $T_i \xrightarrow{ww} T_j$. In this scenario, $H$ contains two write operations, $w_i[x]$ and $w_j[x]$, executed by $T_i$ and $T_j$, respectively. Since $x$ is an element common to the write sets of both $T_i$ and $T_j$, it implies a potential \textit{ww} dependency between $\mathcal{T}_i$ and $\mathcal{T}_j$. Consequently, a \textit{ww} dependency is established in the SDG. The argument extends similarly for \textit{rw} and \textit{wr} dependencies between $T_i$ and $T_j$. 
% Since every dependency edge in $CG$ can be mapped into $SDG$, we can also conclude that \textit{if a dependency cycle exists in $CG$, there is always a corresponding dependency cycle in $SDG$.} 

% 如果CG中出现了异常环，那么这个异常环也出现在 SDG 中。
% \begin{lemma}
%     If a dependency cycle exists in CG, there is always a corresponding dependency cycle in SDG.
%     \label{lemma-1}
% \end{lemma}
% \noindent\textbf{Proof.} It is trivial to deduce from Theorem~\ref{theorem-1} since every dependency edge in CG can be mapped into SDG.

\subsection{Serilizability under Low Isolation Levels \label{sec:proof.isolation}}
% Before we prove the isolation correctness, we identify $T.B$ as the beginning time of transaction $T$ and $T.C$ as the commit time of transaction $T$, and the characteristics of transactions involved in dependency edges are summarised in Table~\ref{tbl:correctness}. If $T_i \xrightarrow{ww} T_j$, 
% in SI, the FCW rule avoids concurrent updates, in other words, $T_i$ commits before $T_j$ starts. 
% While in RC, the database avoids \textit{dirty write} and guarantees read-last-committed. Hence, $T_j$ can only commit after $T_i$ commits. If $T_i \xrightarrow{wr} T_j$, $T_j$ reads the record written by $T_i$, $T_j$ must commit after $T_i$ commits in both SI and RC. Moreover, in SI, a transaction gets the snapshot at the beginning, we can make the characteristic more concise that $T_i$ commits before $T_j$ starts. Lastly, $T_i \xrightarrow{rw} T_j$, in both SI and RC, $T_i$ begins before $T_j$ commits, otherwise, $T_i$ reads the record written by $T_j$. 
% Before demonstrating the serializability of weak isolation levels, w
% \todo{1. previous work in SI and RC; 2. the concurrency control can identify all potential transaction templates and keep the dependency order ...; 3. conclusion}
% \textcolor{red}{in SI the only possible anomaly is from two consecutive RW and Tk commit first}
% \begin{theorem}
%     At the SI level, $H$ is conflict serializable if for every two consecutive RW dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in $H$, $T_j$ commits before $T_k$.
%     \label{theorem-2}
% \end{theorem}
% \textcolor{red}{\sysname can guarantee serializability in SI as it forces Tj commit first}
% \textcolor{red}{in RC the only possible anomaly is from the RW and Tj commit first}
% \begin{theorem}
%     At the RC level, $H$ is conflict serializable if for every RW dependency edge $T_i\xrightarrow{rw} T_j$ in $H$, $T_i$ commits before $T_j$.
%     \label{theorem-3}
% \end{theorem}
% \textcolor{red}{\sysname can guarantee serializability in RC as it forces Ti commit first}
% Under standard low isolation levels, the execution order of transactions may violate SER, often manifested as dependency cycles. Luckily, these cycles have been proven to follow some specific vulnerable dependencies. 
% Serializability can be effectively guaranteed at weak isolation levels if these patterns are identified and appropriately addressed. 
% The non-serializable scheduling under each low isolation level serves some specific vulnerable dependencies.
% According to Theorem \ref{the:vulnerable}, a necessary condition for non-serializability is the inconsistent dependency and commit order of vulnerable dependencies. \sysname identifies the static vulnerable dependency from the transaction templates and ensures that in transactions involving vulnerable dependencies, the commit order is consistent with the dependency order as outlined in Algorithm \ref{alg.transaction}, thus maintaining SER with RDBMS configured to low isolation levels. 
Non-serializable scheduling under each low isolation level accommodates certain specific vulnerable dependencies. According to Theorem \ref{the:vulnerable}, a necessary condition for non-serializability is the presence of inconsistent dependencies and commit orders among these vulnerable dependencies. \sysname identifies static vulnerable dependencies from the transaction templates and ensures that, in transactions involving these dependencies, the commit order aligns with the dependency order as specified in Algorithm \ref{alg.transaction}. This approach maintains SER even when the RDBMS is configured to low isolation levels.

% Informally, at the SI level, a cycle is present if and only if it contains two consecutive RW conflicts $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, with $T_k$ being the first transaction to commit, as discussed in Theorem \ref{def:si}. \sysname, at the SI level, records all potential two consecutive RW conflicts in the middle tier and ensures $T_j$ commits before $T_k$ as outlined in Algorithm \ref{alg.transaction}. This mechanism effectively prevents the formation of any SI cycles, thereby guaranteeing serializability.
% Similarly, at the RC level, a cycle exists if and only if it contains an RW conflict $T_i \xrightarrow{rw} T_j$, with $T_j$ being the first to commit as described in Theorem \ref{def:rc}. In this context, \sysname records all possible RW conflicts in the middle tier and enforces that $T_i$ commits before $T_j$ as detailed in Algorithm \ref{alg.transaction}. This approach ensures no RC cycles can form, thus maintaining serializability at the RC level. 

% \textcolor{red}{One possible conclusion: Unlike most SER CC protocols (e.g., SSI) that directly abort potential RW edges, this method permits certain RW edges to coexist while disallowing others that violate serializable orders. This approach effectively enhances concurrency within the system.}

% Following Theorem \ref{def:si} and Theorem \ref{def:rc} in \sysname, validation is integrated into the middle-tier concurrency control as discussed in Session \ref{design-1}, which is designed to handle transactions generated from templates associated with data dangerous structures at low isolation levels. This integration allows \sysname to proactively identify transactions that may lead to non-serializable scheduling, detect runtime dependencies, and ensure their correct commit order. This proactive approach effectively guarantees the absence of dependency cycles, thereby ensuring the serializability under low isolation levels.

% We first explore the possible \textcolor{red}{partial order} in an execution history $H$. 
% We denote the begin time of transaction $T$ as $T.B$ and the commit time as $T.C$. The \textcolor{red}{partial order} characteristics of conflict dependencies are summarized in Table~\ref{tbl:correctness}. 
% Consider the scenario where $T_i \xrightarrow{ww} T_j$. The First-Committer-Wins (FCW) rule at the SI level prevents concurrent updates by ensuring that $T_i$ commits before $T_j$ begins. At the RC level, the database prevents \textit{dirty write} and enforces the Read-Last-Committed rule, thus $T_j$ can only commit after $T_i$ has committed. 
% For the case where $T_i \xrightarrow{wr} T_j$, since $T_j$ reads the record written by $T_i$, $T_j$ commits only after $T_i$ has committed at both SI and RC levels. Moreover, at the SI level, since a transaction captures a snapshot at its beginning, it simplifies the relationship such that $T_i$ commits only before $T_j$ begins. Lastly, in the scenario where $T_i \xrightarrow{rw} T_j$, both SI and RC require that $T_i$ begins before $T_j$ commits to avoid $T_i$ reading a record that could potentially be written by $T_j$. 

% \begin{table}[t]
% \caption{Transaction characteristics of dependencies}
% \vspace{-4mm}
% \begin{tabular}{ccc}
% \toprule
%                       & Snapshot Isolation & Read Committed \\ 
% % \multicolumn{1}{l|}{$T_i \xrightarrow{ww} T_j$} & $commit(T_i) < begin(T_j)$ & $commit(T_i) < commit(T_j)$ \\
% % \multicolumn{1}{l|}{$T_i \xrightarrow{wr} T_j$} & $commit(T_i) < begin(T_j)$ & $commit(T_i) < commit(T_j)$ \\
% % \multicolumn{1}{l|}{$T_i \xrightarrow{rw} T_j$} & $begin(T_i) < commit(T_j)$ & $begin(T_i) < commit(T_j)$
% \midrule
% \multicolumn{1}{l}{$T_i \xrightarrow{ww} T_j$} & $T_i.C < T_j.B$ & $T_i.C < T_j.C$ \\
% \multicolumn{1}{l}{$T_i \xrightarrow{wr} T_j$} & $T_i.C < T_j.B$ & $T_i.C < T_j.C$ \\
% \multicolumn{1}{l}{$T_i \xrightarrow{rw} T_j$} & $T_i.B < T_j.C$ & $T_i.B < T_j.C$ \\
% \midrule
% \multicolumn{3}{l}{$<$ is the partial order \todo{in the execution history.}} \\
% \bottomrule
% \end{tabular}
% \label{tbl:correctness}
% \end{table}

% \begin{theorem}
%     In SI, H is conflict serializable if $T_j$ commits before $T_k$ for all two consecutive vulnerable dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in H.
%     \label{theorem-2}
% \end{theorem}
% \noindent\textbf{Proof.} We adopt the contrapositive approach here, assuming that if $H$ is not conflict serializable, there must be a cycle in $CG$. We maintain the commit order of $T_j$ and $T_k$, assuming $T_{j^{'}}$ is the first transaction committed within this cycle. Let's denote $T_{s^{'}}$ and $T_{i^{'}}$ as immediate predecessors of $T_{j^{'}}$, e.g. $T_{s^{'}}\rightarrow T_{i^{'}} \rightarrow T_{j^{'}}$. Since $T_{j^{'}}.C < T_{i^{'}}.C$, as per Table~\ref{tbl:correctness}, only the rw dependency is possible between $T_{i^{'}}$ and $T_{j^{'}}$. We can further infer that $T_{i^{'}}.B < T_{j^{'}}.C$, and since T3 was submitted first, $T_{j^{'}}.C < T_{s^{'}}.C$. Based on these two conditions, we can deduce that $T_{i^{'}}.B < T_{s^{'}}.C$, making only the rw dependency is possible between $T_{s^{'}}$ and $T_{i^{'}}$ as well.
% However, we identify all transactions that match the structure and could keep the commit order of $T_{i^{'}}$ and $T_{j^{'}}$, which means $T_{j^{'}}$ can not be the first one in these three transactions to commit. This contradicts our derivation. Therefore, \sysname can ensure the conflict serializability when the RDBMS is configured to SI.

% \begin{theorem}
%     At the SI level, $H$ is conflict serializable if for every two consecutive RW dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in $H$, $T_j$ commits before $T_k$.
%     \label{theorem-2}
% \end{theorem}
% \noindent\textbf{Proof.} 
% We prove this by contradiction, assuming that $H$ is not conflict serializable when $T_j$ commits before $T_k$. Let $T_{s^{'}}$ and $T_{i^{'}}$ be the immediate predecessors of $T_{j^{'}}$, such that $T_{s^{'}}\rightarrow T_{i^{'}} \rightarrow T_{j^{'}}$. Given that $T_{j^{'}}.C < T_{i^{'}}.C$, as indicated in Table~\ref{tbl:correctness}, the only feasible dependency between $T_{i^{'}}$ and $T_{j^{'}}$ is a RW dependency. We can further infer that $T_{i^{'}}.B < T_{j^{'}}.C$, and since $T_{j^{'}}$, $T_{j^{'}}.C < T_{s^{'}}.C$. From these conditions, it follows that $T_{i^{'}}.B < T_{s^{'}}.C$, suggesting that the only possible dependency between $T_{s^{'}}$ and $T_{i^{'}}$ is also RW.
% However, upon identifying all transactions that conform to this structure and could maintain the commit order of $T_{i^{'}}$ and $T_{j^{'}}$, it becomes evident that $T_{j^{'}}$ cannot be the first among these three transactions to commit. This observation contradicts our initial assumption. Therefore, we conclude that the \sysname can ensure conflict serializability at the SI level.

% \begin{theorem}
%     In RC, H is conflict serializable if $T_i$ commits before $T_j$ for all vulnerable dependency edges $T_i\xrightarrow{rw} T_j$ in H.
%     \label{theorem-3}
% \end{theorem}
% \noindent\textbf{Proof.} Similar to the proof of SI, we assume the existence of a dependency cycle in $H$, with $T_{i^{'}}$ as the first committed transaction and $T_{s^{'}}$ as its closest ancestor of $T_{i^{'}}$ in the cycle. This implies  $T_{s^{'}}\rightarrow T_{i^{'}}$ and $T_{i^{'}}.C < T_{s^{'}}.C$. According to Table~\ref{tbl:correctness}, an rw dependency exists between $T_{s^{'}}$ and $T_{i^{'}}$, and the validation-based concurrency control in \sysname ensures that $T_{s^{'}}$ commits before $T_{s^{'}}$ can commit. This contradiction indicates that \sysname can guarantee the conflict serializability of $H$ under RC.

% % \subsection{Consistent commit order}

% In \sysname, we incorporate validation into the transactions produced by transaction templates associated with data anomalies at weak isolation levels. This allows \sysname, during execution, to identify transactions that could potentially result in data anomalies and guarantee the commit order, all without the database's awareness. This approach disrupts the necessary conditions for the CG to form a dependency cycle.

\subsection{Serializability under Cross-isolation Levels \label{sec:proof.switch}}
% During the transition process, \sysname employs a more stringent concurrency control policy to ensure conflict serializability. Consider, for example, the switch from SER to SI. During this transition, we split the $CG$ of $H$ into two subgraphs, $CG_{SER}$ and $CG_{SI}$. $CG_{SER}$ contains transactions running under the SER isolation level, and $CG_{SI}$ contains those running under SI. $CG_{SER}$ is obviously acyclic, and according to Theorem~\ref{theorem-2}, so is $CG_{SI}$. Subsequently, we consider the dependency edges that connect $CG_{SER}$ and $CG_{SI}$. When the database processes transactions under both SI and SER concurrently, no exceptions will occur apart from those that could occur under SI alone. In \sysname, the concurrency control for all transactions is conducted according to the policy corresponding to SI, meaning the dependency between $CG_{SER}$ and $CG_{SI}$ forms a cycle neither.

\begin{comment}
Achieving serializability becomes complex, as \sysname must handle non-serializable scheduling arising from different isolation levels when transitioning from one isolation level $I_{old}$ to the new isolation level $I_{new}$.     
\end{comment}

% As detailed in Section~\ref{design-3}, this transition process comprises three distinct stages. 
% The serializability of Phase I, which encompasses all transactions operating under the old isolation level, as well as Phase III, involving all transactions under the new isolation level, can be readily proven as demonstrated in Section~\ref{sec:proof.isolation}.
% We will discuss the serializability for Phase II; the core is to prove the correctness of Theorem \ref{the:cross-isolation} and Theorem \ref{the:cross-isolation-commit}.  
% The correctness during the transition is established by proving the validity of Theorem \ref{the:cross-isolation} and Theorem \ref{the:cross-isolation-commit}.
% The validation locking mechanism in CIV allows the concurrency control algorithm described in Section \ref{design-1} to detect all vulnerable dependencies, $T_i \xrightarrow{rw} T_j$, regardless of whether $T_i$ and $T_j$ are executing under different or the same isolation levels. Furthermore, it enables $T_i$ to maintain its commit order consistent with the dependency order. 
In this subsection, we first prove that if we can ensure the commit order of $T_j$ and $T_k$ in the cross-isolation vulnerable dependency $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ aligns with the dependency order, then transactions can achieve SER. Then we prove that all cross-isolation vulnerable dependencies can be prevented according to our cross-isolation validation phase.
% We prove this in the following two steps.
% if it needs to.

% We first prove that if non-serializable scheduling exists, there is at least one cross-isolation vulnerable dependency $T_j \xrightarrow{rw} T_k$, where 1. $T_k$ commits before $T_j$; 2. $T_j$ operates under SER; and 3. $T_j$ commits after the transition starts.

% The lock manner in CIV enables the concurrency control algorithm in Section \ref{design-1} can detect all vulnerable dependencies, $T_i\xrightarrow{rw} T_j$, even $T_i$ and $T_j$ execute under different isolation levels. We need to prove that if non-serializable scheduling exists, at least one cross-isolation vulnerable dependency $T_j \xrightarrow{rw} T_k$, where $T_k$ commits before $T_j$; 2. $T_j$ operates under SER; 3. $T_j$ commits after the transition starts. 

\begin{figure}[t]
    \centering
    \includegraphics[width=0.4\textwidth]{figures/switch_correctness3.pdf}
    \vspace{-4mm}
    \caption{Transition from SER to SI or RC}
    % \caption{Partial dependency between $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$}
    \label{fig:switch_correctness}
    \vspace{-4mm}
\end{figure}

{
\color{blue}
First, we prove that \textit{if there is a non-serializable scheduling during the transition, there must be a structure containing two consecutive RW dependencies, $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits first in this cycle and three transactions can execute under whether the same isolation level or different isolation levels.} Due to that $T_k$ commits first, leading to as RW edge from $T_j$ to $T_k$. Moreover, the data dependency from $T_i$ to $T_j$ can only be an RW edge. We prove this by reductio. If the dependency from $T_i$ to $T_j$ is either a WW or WR dependency, implying that $T_i$ commits before $T_j$ starts. Since $T_j$ is concurrent with $T_k$ due to an RW dependency, deriving $T_k$ commits after $T_j$ starts. Thus $T_i$ must commit before $T_k$ commits, contradicting the assumption that $T_k$ is the first transaction to commit. Therefore, the data dependency from $T_i$ to $T_j$ must be an RW dependency, leading to two consecutive RW dependencies $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits first.

Then, we prove that all cross-isolation vulnerable dependencies can be tracked using our cross-isolation validation. We prove this in the following two steps.

(1) Transaction $T_i$ in the cross-isolation vulnerable dependency $T_i \xrightarrow{rw} T_j$ operates under SER. If $T_i$ operates under SI or RC, then the middle tier can ensure that the commit order of $T_i$ and $T_j$ is consistent with the dependency order. Therefore, $T_i$ must operate under SER.


(2) There must be at least one cross-isolation vulnerable dependency, $T_i \xrightarrow{rw} T_j$, where $T_i$ commits after the transition starts. Given that $T_i$ must operate under SER, we demonstrate the proof under two scenarios of the transition from SI/RC to SER and from SER to SI/RC respectively. 

\textit{Transition from SI/RC to SER.} According to the above proofs, if there is non-serializable scheduling during the transition, there must be a structure containing two consecutive RW dependencies, $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits first and $T_j$ operates under SER. During the transition from SI/RC to SER, $T_j$ operates under the new isolation level, making it commit after the transition starts. 

\textit{Transition from SER to SI/RC.} For clarity, we categorize the transactions during the transition into three discrete sets:
\begin{itemize}[leftmargin=*]
    \item $S_{old}^{(1)}$: The set of transactions that operate under $I_{old}$ and have been committed when the transition occurs. 
    \item $S_{old}^{(2)}$: The set of transactions that operate under $I_{old}$ and commit after the transition occurs. 
    \item $S_{new}$: The set of transactions that start after the transition occurs and operate under $I_{new}$.
\end{itemize} 

The partial orders between transaction sets are depicted in Figure \ref{fig:switch_correctness}. 
Non-serializable scheduling implies dependency cycle in the dependency graph, which can be classified into two kinds: (a) scheduling involves only transactions in $S_{old}^{(2)}$ and $S_{new}$; (b) scheduling involves transactions in $S_{old}^{(1)}$, $S_{old}^{(2)}$ and $S_{new}$. 

In the first case, transaction $T_i$ in any vulnerable dependency $T_j \xrightarrow{rw} T_k$ commits after the transition starts.
In the second case, we need to prove that there is at least a cross-isolation vulnerable dependency, $T_j\xrightarrow{rw} T_k$, where $T_j\in S_{old}^{(2)}$. As highlighted by red arrows in Figure \ref{fig:switch_correctness}, (a) transactions in $S_{old}^{(2)}$ operate under SER and start before those in $S_{new}$ start, thus the dependency from transactions in $S_{new}$ to those in $S_{old}^{(2)}$ are RW dependencies.
(b) the dependencies between transactions within $S_{old}^{(2)}$ can only be RW dependencies because they are concurrent transactions. 
(c) transactions in $S_{old}^{(1)}$ commits before those in $S_{old}^{(2)}$, thus dependencies from transactions in $S_{old}^{(2)}$ to those in $S_{old}^{(1)}$ must be RW dependencies. 

Consider a counter-example: all $T_j$ in cross-isolation vulnerable dependencies, $T_j \xrightarrow{rw} T_k$, has committed before the transition starts, i.e., $T_j \in S_{old}^{(1)}$. In this case, for any dependency $T_y \xrightarrow{rw} T_z$, where $T_y\in S_{old}^{(2)}$ and $T_z\in S_{old}^{(1)}$, the precede dependency can not be RW, which means $T_x \xrightarrow{ww/wr} T_y$, thus $T_x \in S_{old}^{(1)}$. In this case, a dependency cycle cannot contain transactions in all three transaction sets. Therefore, the counter-example does not exist; at least a precede RW dependency of $T_y$ must exist. Then, there is a structure with two consecutive RW dependencies, $T_x \xrightarrow{rw} T_y \xrightarrow{rw} T_z$, where $T_z \in S_{old}^{(1)}$ commits before $T_y \in S_{old}^{(2)}$ and $T_y$ commits after the transition starts. Thus, $T_y$ and $T_z$ constitute a cross-isolation level vulnerable dependency.

Therefore, we conclude that for transitions from SER to SI/RC or from SI/RC to SER, if there is non-serializable scheduling, there is at least one cross-isolation vulnerable dependency, $T_j \xrightarrow{rw} T_k$, in two consecutive RW dependencies, transaction $T_j$ operates under the SER and commits after the transition starts. 
}

% \vspace{1mm}
First, we prove that \textit{\blackding{1} if there is a non-serializable scheduling during the transition, there must be a structure containing two consecutive RW dependencies, $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits first in this cycle and $T_j$ operates under SER.} 
% Consider the counter-example in Figure~\ref{fig:switch_correctness}a and briefly demonstrate that the dependency from $T_j$ to $T_k$ can not be either WR or WW. 
Consider $T_k$ as the first transaction to commit in the cycle. This implies the existence of an RW edge from $T_j$ to $T_k$, as $T_k$ commits first. However, by identifying the static vulnerable dependency at RC, the middle-tier concurrency control algorithm in Section \ref{design-1} ensures $T_j$ commits before $T_k$ for any RW dependency, meaning that $T_j$ operates under SI or SER. If the dependency from $T_i$ to $T_j$ is either a WW or WR dependency, implying that $T_i$ commits before $T_j$ starts. Since $T_j$ is concurrent with $T_k$ by an RW dependency, $T_k$ commits after $T_j$ starts. Thus, $T_k$ must commit before $T_j$ commits, which contradicts the assumption that $T_k$ is the first transaction to commit in the cycle. Therefore, we conclude that if there is a cross-isolation level dependency cycle, there must contain two consecutive RW dependencies $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits first. Furthermore, if $T_i$ operates under SI, the middle-tier concurrency control algorithm in Section \ref{design-1} can also maintain the commit order between $T_j$ and $T_k$ consistent with their dependency order. Therefore, $T_j$ operates under SER. 

We then prove that \textit{\blackding{2} if there is non-serializable scheduling during the transition, there must be at least one cross-isolation vulnerable dependency, $T_i \xrightarrow{rw} T_j$, where 1. $T_j$ commits before $T_i$ commits; 2. $T_i$ operates under SER; 3. $T_i$ commits after the transition starts.} We only consider the transitions involving SER because the transitions between SI and RC are safe. 

\textit{(1) Transitions from SI/RC to SER. }
According to the proof in \blackding{1}, if there is non-serializable scheduling during the transition, there must be a structure containing two consecutive RW dependencies, $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, where $T_k$ commits first in this cycle and $T_j$ operates under SER. In this structure, $T_j$ operates under the new isolation level; thus, $T_j$ commits after the transition starts. Thus, $T_j$ and $T_k$ constitute a cross-isolation level vulnerable dependency.
% the cross-isolation level vulnerable dependency required by \blackding{2} exists in this scenario. 

% By Theorem \ref{the:cross-isolation}, there exists a cycle involving $T_i$, $T_j$, and $T_k$, such that $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, and $T_k$ operates under SER. 
% We next prove $T_j$ must be in $S^{new}$ under SER, as shown in Figure \textcolor{red}{7b}. By contradiction, we first assume $T_j$ can be in $S^{(1)}_{old}$. $T_i$ and $T_k$ can either be in $S^{(1)_{old}}$ or $S^{(2)_{old}}$, In both scenarios, the dependency  $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ is contained within the process of the SI/RC isolation level. In this case, this dependency will be avoided by SI/RC itself proven by Section 5.1. Then, we assume $T_j$ can be in $S^{(2)}_{old}$, If this dependecy is present within $S^{(2)}_{old}$, it will be avoided as demonstrated in Section 5.1. Otherwise, $T_i$ or $T_k$ or both can be $S^{new}$, the dependency will be detected and subsequently avoided by the \textcolor{red}{static detection??}.
% We conclude that $T_j$ must be in $S^{new}$ under SER level.

\textit{(2) Transitions from SER to SI/RC. } 
For clarity, we categorize the transactions during the transition into three discrete sets:
\begin{itemize}[leftmargin=*]
    \item $S_{old}^{(1)}$: The set of transactions that operate under $I_{old}$ and have been committed when the transition occurs. 
    \item $S_{old}^{(2)}$: The set of transactions that operate under $I_{old}$ and remain unfinished when the transition occurs. 
    \item $S_{new}$: The set of transactions that starts after the transition occurs and operate under $I_{new}$.
\end{itemize} 

The partial orders between transaction sets are depicted in Figure \ref{fig:switch_correctness}. 
% Note that the dependencies from transactions in $S_{old}^{(1)}$ to those in $S_{new}$ can only be RW dependencies and no reverse dependencies because transactions in $S_{old}^{(1)}$ commit before any transactions in $S_{new}$ start. 
Non-serializable scheduling implies dependency cycle in the dependency graph, which can be classified into two kinds: (a) scheduling involves only transactions in $S_{old}^{(2)}$ and $S_{new}$; (b) scheduling involves transactions in $S_{old}^{(1)}$, $S_{old}^{(2)}$ and $S_{new}$. In the first case, it is similar to the proof of the transition from SI/RC to SER because all transactions are committed after the transition starts. 

In the second case, we need to prove that there is at least a cross-isolation vulnerable dependency, $T_j\xrightarrow{rw} T_k$, where $T_j\in S_{old}^{(2)}$. As highlighted by red arrows in Figure \ref{fig:switch_correctness}, (a) transactions in $S_{old}^{(2)}$ operate under SER and start before those in $S_{new}$ start, thus the dependency from transactions in $S_{new}$ to those in $S_{old}^{(2)}$ are RW dependencies.
% transactions in $S_{new}$ are concurrent with those in $S_{old}^{(2)}$ because transactions in $S_{old}^{(2)}$ operate under SER, the dependencies from  
(b) the dependencies between transactions within $S_{old}^{(2)}$ can only be RW dependencies because they are concurrent transactions. 
(c) transactions in $S_{old}^{(1)}$ commits before those in $S_{old}^{(2)}$, thus dependencies from transactions in $S_{old}^{(2)}$ to those in $S_{old}^{(1)}$ must be RW dependencies. 

Consider a counter-example: all $T_j$ in cross-isolation vulnerable dependencies, $T_j \xrightarrow{rw} T_k$, has committed before the transition starts, i.e., $T_j \in S_{old}^{(1)}$. In this case, for any dependency $T_y \xrightarrow{rw} T_z$, where $T_y\in S_{old}^{(2)}$ and $T_z\in S_{old}^{(1)}$, the precede dependency can not be RW, which means $T_x \xrightarrow{ww/wr} T_y$, thus $T_x \in S_{old}^{(1)}$. In this case, a dependency cycle cannot contain transactions in all three transaction sets. Therefore, the counter-example does not exist; at least a precede RW dependency of $T_y$ must exist. Then, there is a structure with two consecutive RW dependencies, $T_x \xrightarrow{rw} T_y \xrightarrow{rw} T_z$, where $T_z \in S_{old}^{(1)}$ commits before $T_y \in S_{old}^{(2)}$ and $T_y$ commits after the transition starts. Thus, $T_y$ and $T_z$ constitute a cross-isolation level vulnerable dependency.

% By Theorem \ref{the:cross-isolation}, there exists a cycle involving $T_i$, $T_j$, and $T_k$, such that  $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$. We next prove $T_j$ is in $S^{(2)}_{old}$ under SER, as shown in Figure \textcolor{red}{7a}. By contradiction, we first assume $T_j$ can be in $S^{(1)}_{old}$. $T_i$ and $T_k$ can either be in $S^{(1)_{old}}$ or $S^{(2)_{old}}$, In both scenarios, the dependency $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ is contained within the process of the SER isolation level. In this case, this dependency will be avoided by SER itself. Then, we assume $T_j$ can be in $S_{new}$. If this dependency is present within $S_{new}$, it will be avoided as demonstrated in Section 5.1. Otherwise, $T_i$ or $T_k$ or both can be $S^{(2)}_{old}$, the dependency will be detected and subsequently avoided by the \textcolor{red}{static detection??}.
% We conclude that $T_j$ must be in $S^{(2)}_{old}$ under SER level. 


% (2) \textit{Transition from SI/RC to SER. }
% By Theorem \ref{the:cross-isolation}, there exists a cycle involving $T_i$, $T_j$, and $T_k$, such that $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, and $T_k$ operates under SER. 
% We next prove $T_j$ must be in $S^{new}$ under SER, as shown in Figure \textcolor{red}{7b}. By contradiction, we first assume $T_j$ can be in $S^{(1)}_{old}$. $T_i$ and $T_k$ can either be in $S^{(1)_{old}}$ or $S^{(2)_{old}}$, In both scenarios, the dependency  $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ is contained within the process of the SI/RC isolation level. In this case, this dependency will be avoided by SI/RC itself proven by Section 5.1. Then, we assume $T_j$ can be in $S^{(2)}_{old}$, If this dependecy is present within $S^{(2)}_{old}$, it will be avoided as demonstrated in Section 5.1. Otherwise, $T_i$ or $T_k$ or both can be $S^{new}$, the dependency will be detected and subsequently avoided by the \textcolor{red}{static detection??}.
% We conclude that $T_j$ must be in $S^{new}$ under SER level.

Therefore, we conclude that for transitions from SER to SI/RC or from SI/RC to SER, if there is non-serializable scheduling, there is at least one cross-isolation vulnerable dependency, $T_j \xrightarrow{rw} T_k$, in two consecutive RW dependencies, transaction $T_j$ operates under the SER and commits after the transition starts. 

\noindent \textbf{Serializability.} CIV ensures that the transaction $T_j$ involving the cross-isolation vulnerable dependency, $T_j \xrightarrow{rw} T_k$, commits before $T_k$ commits. Thus, the transaction scheduling during the isolation level transition achieves SER.
% \sysname identifies the static vulnerable dependency from the transaction templates. 

% To guarantee SS during the transition when involving SER, our CIV records all transactions $T_j$ that involve RW at the SER isolation level. CIV prevents $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$ by enforcing a commit order that aligns with its dependency order. This approach ensures that $T_k$ does not commit before $T_j$, thereby avoiding the formation of cycles.

% \textbf{Transaction $T_j$ operates under SER.} Otherwise, the middle-tier concurrency control approach would ensure that the commit order of $T_j$ and $T_k$ is consistent with their dependency order. 

% \textbf{Transaction $T_j$ commits after the transition point.} In scenarios where the transition is from SI or RC to SER, since $T_j$ operates under SER, it starts and commits after the transition point.
% For the other two scenarios, we illustrate the partial orders between transaction sets, according to the categories outlined in Section \ref{design-3}, at the transition point in Figure \ref{fig:switch_correctness}b. The features of some dependencies are listed following: 
% % Dependencies arise from , between transactions in $S_{new}$ and those in $S_{old}^{(1)}$ and $S_{old}^{(2)}$. 
% \blackding{1} Dependencies from transactions in $S_{old}^{(1)}$ to those in $S_{new}$ can only be RW dependencies and no reverse dependencies because transactions in $S_{old}^{(1)}$ commit before any transactions in $S_{new}$ start. 
% \blackding{2} Transactions in $S_{new}$ are concurrent with those in $S_{old}^{(2)}$, because transactions in $S_{old}^{(2)}$ operate under SER, the dependencies from transactions in $S_{new}$ to those in $S_{old}^{(2)}$ are RW dependencies. The reverse dependencies can be any type.
% \blackding{3} Similarly, the dependencies between transactions within $S_{old}^{(2)}$ can only be RW dependencies because they are concurrent transactions.
% \blackding{4} Transactions in $S_{old}^{(1)}$ commits before those in $S_{old}^{(2)}$, thus dependencies from transactions in $S_{old}^{(1)}$ .

% There can be two kinds of dependency cycles: dependency cycles contain transactions in $S_{old}^{(1)}$ and $S_{new}$, and dependency cycles contain transactions in all three sets. In the first type, $T_j$ must commit after the transition according to the classification criteria of $S_{old}^{(2)}$. In another type, although $T_j$ may commit before the transition point, we prove that every dependency cycle contains two consecutive RW dependencies, $T_i^{'} \xrightarrow{rw} T_j^{'} \xrightarrow{rw} T_k^{'}$, and $T_j^{'}$ commits after the transition point. 

% As shown in Figure \ref{fig:switch_correctness}, the dependency cycle contains the dependency from transaction in $S_{new}$ to $S_{old}^{(2)}$ and the dependency from transaction in $S_{old}^{(2)}$ to $S_{old}^{(1)}$. Without losing generality, we denote them as $T_1\xrightarrow{rw} T_2$ and $T_3\xrightarrow{rw} T_4$, where $T_2$ and $T_3$ can be the same transaction. The dependency chain from $T_2$ to $T_4$ can be formalize as:

% \todo{}
% Thus far, we have proved the correctness of Theroem \ref{the:cross-isolation} and Theroem \ref{the:cross-isolation-commit}. The cross-isolation level validation mechanism ensures the commit order of xxx is consistent with their dependency order, thus ensuring SS during the transition.
% If the dependency cycle does not involve the transactions in $S_{old}^{(1)}$, $T_j$ must commit after the transition according the  $S_{old}^{(2)}$. In another case, 

% Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and may be bidirectional. 
% In phase~II, \sysname is required to track these dependencies and ensure that there are no dependencies from the transactions in $S_{new}$ to those in $S_{old}^{(2)}$.

% which involves transactions that run across isolation levels and can be divided into two distinct parts: (1) the isolation transitions involving SER isolation and (2) the transitions occurring solely between SI and RC levels. 
% \newpage
% \textbf{Transaction involves SER isolation level.} Additional validation is necessary during the transition when SER isolation is involved. As outlined in Section~\ref{design-3}, we categorize transactions into three sets: $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$. The concurrency control in Section~\ref{sec:design:cc:validation} ensures that there is no dependency cycle within $S_{old}^{(1)} \cup S_{old}^{(2)}$ and $S_{new}$, respectively.
% As depicted in Figure~\ref{fig:switch_correctness}, dependencies arise across isolation levels, between transactions in $S_{new}$ and those in $S_{old}^{(1)}$ and $S_{old}^{(2)}$. 
% \blackding{1} Transactions in $S_{old}^{(1)}$ commit before any transactions in $S_{new}$ start. Therefore, dependencies can only occur when a transaction in $S_{new}$ reads or writes the data written by $S_{old}^{(1)}$. 
% \blackding{2} Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and may be bidirectional. 
% In phase~II, \sysname is required to track these dependencies and ensure that there are no dependencies from the transactions in $S_{new}$ to those in $S_{old}^{(2)}$. 
% % Thus, the dependencies can be only flow from $S_{old}^{(2)}$ to $S_{new}$.
% Therefore, the dependency graph is acyclic during the transition, thus achieving SS.
% cross-isolation transactions during the transition are serializable.

% \textbf{Transition between SI and RC isolation levels.} Unlike involving SER, the transition of \sysname between SI and RC isolation levels does not require additional validation. To illustrate this, we consider the counter-example in Figure~\ref{fig:cross-isolation} and briefly demonstrate that no cycle can be formed during the transition. By contradiction, we assume a cycle exists, with $T_j$ being the first transaction to commit. This implies the existence of an RW edge from $T_i$ to $T_j$, as $T_j$ commits first. However, by identifying the static vulnerable dependency at RC, the middle-tier concurrency control approach ensures $T_i$ commits before $T_j$ for any RW dependency, meaning that $T_i$ operates under SI. 
% By identifying the static vulnerable dependency in SI, it is not permissible for two consecutive RW dependencies to have the last transaction committed first. So, the dependency from $T_k$ to $T_i$ must be either WW or WR. 
% In this case, the commit time of $T_k$ is before $T_i$ starts. Since $T_i$ is concurrent with $T_j$ by a RW dependency, $T_j$ commits after $T_i$ starts. Thus, $T_k$ must commit before $T_j$ commits, which contradicts the assumption that $T_k$ is the first transaction to commit in the cycle. Therefore, we conclude that no cycles exist during the transition.

% The transition process ensures serializability when transactions follow the middle-tier concurrency control designed for each individual isolation level in \sysname. As we all know, non-serializable scheduling can be identified by a dependency cycle. Consider the counter-example in Figure~\ref{fig:cross-isolation}. Denote the first committed transaction in the cycle as $T_j$, with its predecessor transactions as $T_i$ and $T_j$. The inconsistent dependency order and commit order between them indicate the dependency from $T_i$ to $T_j$ must be an RW dependency. This implies $T_i$ operates under SI and is concurrent with $T_j$, meaning \textit{$T_i$ begins before $T_j$ commits}. Then, the dependency from $T_k$ to $T_i$ could be either WW or WR dependency. If it is an RW dependency, two consecutive RW dependencies occur, consisting of the dangerous structure in SI; then, the middle-tier concurrency control could schedule the commit order of $T_i$ and $T_j$ to make it consistent with the dependency order. Since $T_i$ operates under SI, $T_k$ must commit before $T_j$ begins, which contradicts our assumption that $T_j$ is the first transaction to commit in this cycle. Therefore, no such dependency cycles exist, ensuring that transaction scheduling is serializable under \sysname.

% \sysname employs a stringent concurrency control mechanism during isolation level transitions. 
% The correctness of this mechanism can be divided into two parts: the transition involving SER and the transition between SI and RC. We demonstrate the correctness of both scenarios separately.

% \subsubsection{Transaction involving SER isolation level.}
% As detailed in Section~\ref{design-3}, this transition process comprises three distinct stages, for which we provide proof of serializability. 
% The serializability of Phase I, which encompasses all transactions operating under the previous isolation level, as well as Phase III, involving all transactions under the new isolation level, can be readily proven as demonstrated in Section~\ref{sec:proof.isolation}.
% We will provide proof of serializability for Phase II, which involves transactions that run across both isolation levels.

% According to Section~\ref{design-3}, we categorize the transactions into three sets: $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$. As depicted in Figure~\ref{fig:switch_correctness}, we will demonstrate that these transactions' schedules are serializable, without conflict cycles. Within the same isolation level, consider the proof in Section \ref{sec:proof.isolation}, we can establish that both $S_{old}^{(1)} \cup S_{old}^{(2)}$ and $S_{new}$ are serializable. 
% When dependencies are across isolation levels and transactions are from between $S_{new}$ and $S_{old}^{(1)}$, as well as between $S_{new}$ and $S_{old}^{(2)}$.
% \blackding{1} Transactions in $S_{old}^{(1)}$ commit before transactions in $S_{new}$ start. Therefore, dependencies can only occur when a transaction in $S_{new}$ reads or writes the data written by $S_{old}^{(1)}$.
% \blackding{2} Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and bidirected. In phase~II, \sysname could track these dependencies and ensure that transactions in $S_{new}$ either commit after $S_{old}^{(1)}$ or abort. 
% % no operation in $S_{old}^{(1)}$ depends on an operation in $S_{new}$.
% Thus, the dependencies can be only from $S_{old}^{(2)}$ to $S_{new}$. Consequently, cross-isolation transactions during the switching phase are serializable.
% For example, for the switch from SER to SI, the $CG$ of $H$ is divided into two subgraphs: $CG_{SER}$ and $CG_{SI}$. $CG_{SER}$ contains transactions operating under the SER level, and $CG_{SI}$ contains those operating under the SI level. It is evident that $CG_{SER}$ is acyclic due to the stringent nature of SER. Furthermore, according to Theorem~\ref{theorem-2}, $CG_{SI}$ is also acyclic.
% We then examine the dependency edges that bridge $CG_{SER}$ and $CG_{SI}$.

% In \sysname, \textcolor{red}{Describe more information when the database concurrently processes transactions under both SI and SER, how to deal with transaction conflict to guarantee serializability.} the concurrency control for all transactions adheres to SER protocol or Theorem \ref{theorem-2}. This approach ensures that no cycles form between $CG_{SER}$ and $CG_{SI}$, maintaining the acyclic nature of the overall system's conflict graph and thereby preserving conflict serializability throughout the transition.

% \subsubsection{Transition between SI and RC isolation level.} The transition process ensures serializability when transactions follow the middle-tier concurrency control designed for each individual isolation level in \sysname. As we all know, non-serializable scheduling can be identified by a dependency cycle. Consider the counter-example in Figure~\ref{fig:cross-isolation}. Denote the first committed transaction in the cycle as $T_j$, with its predecessor transactions as $T_i$ and $T_j$. The inconsistent dependency order and commit order between them indicate the dependency from $T_i$ to $T_j$ must be an RW dependency. This implies $T_i$ operates under SI and is concurrent with $T_j$, meaning \textit{$T_i$ begins before $T_j$ commits}. Then, the dependency from $T_k$ to $T_i$ could be either WW or WR dependency. If it is an RW dependency, two consecutive RW dependencies occur, consisting of the dangerous structure in SI; then, the middle-tier concurrency control could schedule the commit order of $T_i$ and $T_j$ to make it consistent with the dependency order. Since $T_i$ operates under SI, $T_k$ must commit before $T_j$ begins, which contradicts our assumption that $T_j$ is the first transaction to commit in this cycle. Therefore, no such dependency cycles exist, ensuring that transaction scheduling is serializable under \sysname.
