\section{correctness}\label{sec:correctness}
In this section, we prove the serializability in weak isolation levels and the cross-isolation levels within \sysname. 
% Previous sections have demonstrated that the validation-based concurrency control guarantees the commit order of two transactions involved in a dependency. 

% Before we prove the guarantee of serializability in a weak isolation level, we first specify the relationship between the conflict graph (CG), which is constructed on the execution history, and the static dependency graph (SDG), which is based on transaction templates.
% For better illustration, the proof atmosphere is two-step; first, we will show that concurrency control in middleware guarantees the commit order of two transactions with dependency; then, we will prove the serializable guarantee of the workload in \sysname. 

% CG 中的依赖和 SDG 中的依赖是有对应关系的。
% \noindent\begin{lemma}
%     If $T_i \rightarrow T_j$ in the $CG$ of the execution history $H$, then $\mathcal{T}_i \rightarrow \mathcal{T}_j$ in the $SDG$ of the transaction template $\mathcal{T}$. 
%     % As a partial converse, if $\mathcal{T}_i \rightarrow \mathcal{T}_j$, then either $T_i \rightarrow T_j$ or $T_j \rightarrow T_i$ in $H$.
%     \label{theorem-1}
% \end{lemma}

% \noindent\textbf{Proof.} Suppose $T_i \rightarrow T_j$ within the execution history $H$, if $T_i \xrightarrow{ww} T_j$, then $H$ contains two write operations $w_i[x]$ and $w_j[x]$, belonging to $T_i$ and $T_j$, respectively. $x$ belongs to the intersection of the write sets of $T_i$ and $T_j$, it implies that $\mathcal{T}_i$ has potential ww dependency with $\mathcal{T}_j$. Thus, there exists a ww dependency in the $SDG$. Similarly, if there is rw or wr dependency between $T_i$ and $T_j$. 
% % For the partial converse, suppose $\mathcal{T}_i \rightarrow \mathcal{T}_j$ in the $SDG$. 
% \textcolor{red}{where do we need this result?}
% \noindent\textbf{Proof.} Suppose $T_i \rightarrow T_j$ within the execution history $H$, and condiser the case where $T_i \xrightarrow{ww} T_j$. In this scenario, $H$ contains two write operations, $w_i[x]$ and $w_j[x]$, executed by $T_i$ and $T_j$, respectively. Since $x$ is an element common to the write sets of both $T_i$ and $T_j$, it implies a potential \textit{ww} dependency between $\mathcal{T}_i$ and $\mathcal{T}_j$. Consequently, a \textit{ww} dependency is established in the SDG. The argument extends similarly for \textit{rw} and \textit{wr} dependencies between $T_i$ and $T_j$. 
% Since every dependency edge in $CG$ can be mapped into $SDG$, we can also conclude that \textit{if a dependency cycle exists in $CG$, there is always a corresponding dependency cycle in $SDG$.} 

% 如果CG中出现了异常环，那么这个异常环也出现在 SDG 中。
% \begin{lemma}
%     If a dependency cycle exists in CG, there is always a corresponding dependency cycle in SDG.
%     \label{lemma-1}
% \end{lemma}
% \noindent\textbf{Proof.} It is trivial to deduce from Theorem~\ref{theorem-1} since every dependency edge in CG can be mapped into SDG.

\subsection{Serilizability in low isolation levels \label{sec:proof.isolation}}

% Before we prove the isolation correctness, we identify $T.B$ as the beginning time of transaction $T$ and $T.C$ as the commit time of transaction $T$, and the characteristics of transactions involved in dependency edges are summarised in Table~\ref{tbl:correctness}. If $T_i \xrightarrow{ww} T_j$, 
% in SI, the FCW rule avoids concurrent updates, in other words, $T_i$ commits before $T_j$ starts. 
% While in RC, the database avoids \textit{dirty write} and guarantees read-last-committed. Hence, $T_j$ can only commit after $T_i$ commits. If $T_i \xrightarrow{wr} T_j$, $T_j$ reads the record written by $T_i$, $T_j$ must commit after $T_i$ commits in both SI and RC. Moreover, in SI, a transaction gets the snapshot at the beginning, we can make the characteristic more concise that $T_i$ commits before $T_j$ starts. Lastly, $T_i \xrightarrow{rw} T_j$, in both SI and RC, $T_i$ begins before $T_j$ commits, otherwise, $T_i$ reads the record written by $T_j$. 
% Before demonstrating the serializability of weak isolation levels, w
% \todo{1. previous work in SI and RC; 2. the concurrency control can identify all potential transaction templates and keep the dependency order ...; 3. conclusion}
% \textcolor{red}{in SI the only possible anomaly is from two consecutive RW and Tk commit first}
% \begin{theorem}
%     At the SI level, $H$ is conflict serializable if for every two consecutive RW dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in $H$, $T_j$ commits before $T_k$.
%     \label{theorem-2}
% \end{theorem}
% \textcolor{red}{\sysname can guarantee serializability in SI as it forces Tj commit first}
% \textcolor{red}{in RC the only possible anomaly is from the RW and Tj commit first}
% \begin{theorem}
%     At the RC level, $H$ is conflict serializable if for every RW dependency edge $T_i\xrightarrow{rw} T_j$ in $H$, $T_i$ commits before $T_j$.
%     \label{theorem-3}
% \end{theorem}
% \textcolor{red}{\sysname can guarantee serializability in RC as it forces Ti commit first}
At vanilla weak isolation levels, the execution order of transactions may violate serializability, often manifested as dependency cycles. Luckily, these cycles have proved to follow some specific patterns. Serializability can be effectively guaranteed at weak isolation levels if these patterns are identified and appropriately addressed. As discussed in Section \ref{sec:back.vd}, a necessary condition for non-serializability is the inconsistent dependency and commit order of vulnerable dependencies. \sysname identifies the static vulnerable dependency from the transaction templates and ensures that in the transactions involving the vulnerable dependencies, the commit order is consistent with the dependency order as outlined in Algorithm \ref{alg.transaction}, thus maintaining serializability at low isolation levels. 


% Informally, at the SI level, a cycle is present if and only if it contains two consecutive RW conflicts $T_i \xrightarrow{rw} T_j \xrightarrow{rw} T_k$, with $T_k$ being the first transaction to commit, as discussed in Theorem \ref{def:si}. \sysname, at the SI level, records all potential two consecutive RW conflicts in the middle tier and ensures $T_j$ commits before $T_k$ as outlined in Algorithm \ref{alg.transaction}. This mechanism effectively prevents the formation of any SI cycles, thereby guaranteeing serializability.
% Similarly, at the RC level, a cycle exists if and only if it contains an RW conflict $T_i \xrightarrow{rw} T_j$, with $T_j$ being the first to commit as described in Theorem \ref{def:rc}. In this context, \sysname records all possible RW conflicts in the middle tier and enforces that $T_i$ commits before $T_j$ as detailed in Algorithm \ref{alg.transaction}. This approach ensures no RC cycles can form, thus maintaining serializability at the RC level. 

% \textcolor{red}{One possible conclusion: Unlike most SER CC protocols (e.g., SSI) that directly abort potential RW edges, this method permits certain RW edges to coexist while disallowing others that violate serializable orders. This approach effectively enhances concurrency within the system.}

% Following Theorem \ref{def:si} and Theorem \ref{def:rc} in \sysname, validation is integrated into the middle-tier concurrency control as discussed in Session \ref{design-1}, which is designed to handle transactions generated from templates associated with data dangerous structures at low isolation levels. This integration allows \sysname to proactively identify transactions that may lead to non-serializable scheduling, detect runtime dependencies, and ensure their correct commit order. This proactive approach effectively guarantees the absence of dependency cycles, thereby ensuring the serializability under low isolation levels.

% We first explore the possible \textcolor{red}{partial order} in an execution history $H$. 
% We denote the begin time of transaction $T$ as $T.B$ and the commit time as $T.C$. The \textcolor{red}{partial order} characteristics of conflict dependencies are summarized in Table~\ref{tbl:correctness}. 
% Consider the scenario where $T_i \xrightarrow{ww} T_j$. The First-Committer-Wins (FCW) rule at the SI level prevents concurrent updates by ensuring that $T_i$ commits before $T_j$ begins. At the RC level, the database prevents \textit{dirty write} and enforces the Read-Last-Committed rule, thus $T_j$ can only commit after $T_i$ has committed. 
% For the case where $T_i \xrightarrow{wr} T_j$, since $T_j$ reads the record written by $T_i$, $T_j$ commits only after $T_i$ has committed at both SI and RC levels. Moreover, at the SI level, since a transaction captures a snapshot at its beginning, it simplifies the relationship such that $T_i$ commits only before $T_j$ begins. Lastly, in the scenario where $T_i \xrightarrow{rw} T_j$, both SI and RC require that $T_i$ begins before $T_j$ commits to avoid $T_i$ reading a record that could potentially be written by $T_j$. 

% \begin{table}[t]
% \caption{Transaction characteristics of dependencies}
% \vspace{-4mm}
% \begin{tabular}{ccc}
% \toprule
%                       & Snapshot Isolation & Read Committed \\ 
% % \multicolumn{1}{l|}{$T_i \xrightarrow{ww} T_j$} & $commit(T_i) < begin(T_j)$ & $commit(T_i) < commit(T_j)$ \\
% % \multicolumn{1}{l|}{$T_i \xrightarrow{wr} T_j$} & $commit(T_i) < begin(T_j)$ & $commit(T_i) < commit(T_j)$ \\
% % \multicolumn{1}{l|}{$T_i \xrightarrow{rw} T_j$} & $begin(T_i) < commit(T_j)$ & $begin(T_i) < commit(T_j)$
% \midrule
% \multicolumn{1}{l}{$T_i \xrightarrow{ww} T_j$} & $T_i.C < T_j.B$ & $T_i.C < T_j.C$ \\
% \multicolumn{1}{l}{$T_i \xrightarrow{wr} T_j$} & $T_i.C < T_j.B$ & $T_i.C < T_j.C$ \\
% \multicolumn{1}{l}{$T_i \xrightarrow{rw} T_j$} & $T_i.B < T_j.C$ & $T_i.B < T_j.C$ \\
% \midrule
% \multicolumn{3}{l}{$<$ is the partial order \todo{in the execution history.}} \\
% \bottomrule
% \end{tabular}
% \label{tbl:correctness}
% \end{table}

% \begin{theorem}
%     In SI, H is conflict serializable if $T_j$ commits before $T_k$ for all two consecutive vulnerable dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in H.
%     \label{theorem-2}
% \end{theorem}
% \noindent\textbf{Proof.} We adopt the contrapositive approach here, assuming that if $H$ is not conflict serializable, there must be a cycle in $CG$. We maintain the commit order of $T_j$ and $T_k$, assuming $T_{j^{'}}$ is the first transaction committed within this cycle. Let's denote $T_{s^{'}}$ and $T_{i^{'}}$ as immediate predecessors of $T_{j^{'}}$, e.g. $T_{s^{'}}\rightarrow T_{i^{'}} \rightarrow T_{j^{'}}$. Since $T_{j^{'}}.C < T_{i^{'}}.C$, as per Table~\ref{tbl:correctness}, only the rw dependency is possible between $T_{i^{'}}$ and $T_{j^{'}}$. We can further infer that $T_{i^{'}}.B < T_{j^{'}}.C$, and since T3 was submitted first, $T_{j^{'}}.C < T_{s^{'}}.C$. Based on these two conditions, we can deduce that $T_{i^{'}}.B < T_{s^{'}}.C$, making only the rw dependency is possible between $T_{s^{'}}$ and $T_{i^{'}}$ as well.
% However, we identify all transactions that match the structure and could keep the commit order of $T_{i^{'}}$ and $T_{j^{'}}$, which means $T_{j^{'}}$ can not be the first one in these three transactions to commit. This contradicts our derivation. Therefore, \sysname can ensure the conflict serializability when the RDBMS is configured to SI.

% \begin{theorem}
%     At the SI level, $H$ is conflict serializable if for every two consecutive RW dependency edges $T_i\xrightarrow{rw} T_j \xrightarrow{rw} T_k$ in $H$, $T_j$ commits before $T_k$.
%     \label{theorem-2}
% \end{theorem}
% \noindent\textbf{Proof.} 
% We prove this by contradiction, assuming that $H$ is not conflict serializable when $T_j$ commits before $T_k$. Let $T_{s^{'}}$ and $T_{i^{'}}$ be the immediate predecessors of $T_{j^{'}}$, such that $T_{s^{'}}\rightarrow T_{i^{'}} \rightarrow T_{j^{'}}$. Given that $T_{j^{'}}.C < T_{i^{'}}.C$, as indicated in Table~\ref{tbl:correctness}, the only feasible dependency between $T_{i^{'}}$ and $T_{j^{'}}$ is a RW dependency. We can further infer that $T_{i^{'}}.B < T_{j^{'}}.C$, and since $T_{j^{'}}$, $T_{j^{'}}.C < T_{s^{'}}.C$. From these conditions, it follows that $T_{i^{'}}.B < T_{s^{'}}.C$, suggesting that the only possible dependency between $T_{s^{'}}$ and $T_{i^{'}}$ is also RW.
% However, upon identifying all transactions that conform to this structure and could maintain the commit order of $T_{i^{'}}$ and $T_{j^{'}}$, it becomes evident that $T_{j^{'}}$ cannot be the first among these three transactions to commit. This observation contradicts our initial assumption. Therefore, we conclude that the \sysname can ensure conflict serializability at the SI level.

% \begin{theorem}
%     In RC, H is conflict serializable if $T_i$ commits before $T_j$ for all vulnerable dependency edges $T_i\xrightarrow{rw} T_j$ in H.
%     \label{theorem-3}
% \end{theorem}
% \noindent\textbf{Proof.} Similar to the proof of SI, we assume the existence of a dependency cycle in $H$, with $T_{i^{'}}$ as the first committed transaction and $T_{s^{'}}$ as its closest ancestor of $T_{i^{'}}$ in the cycle. This implies  $T_{s^{'}}\rightarrow T_{i^{'}}$ and $T_{i^{'}}.C < T_{s^{'}}.C$. According to Table~\ref{tbl:correctness}, an rw dependency exists between $T_{s^{'}}$ and $T_{i^{'}}$, and the validation-based concurrency control in \sysname ensures that $T_{s^{'}}$ commits before $T_{s^{'}}$ can commit. This contradiction indicates that \sysname can guarantee the conflict serializability of $H$ under RC.

% % \subsection{Consistent commit order}

% In \sysname, we incorporate validation into the transactions produced by transaction templates associated with data anomalies at weak isolation levels. This allows \sysname, during execution, to identify transactions that could potentially result in data anomalies and guarantee the commit order, all without the database's awareness. This approach disrupts the necessary conditions for the CG to form a dependency cycle.

\subsection{Serializability in cross-isolation levels \label{sec:proof.switch}}
% During the transition process, \sysname employs a more stringent concurrency control policy to ensure conflict serializability. Consider, for example, the switch from SER to SI. During this transition, we split the $CG$ of $H$ into two subgraphs, $CG_{SER}$ and $CG_{SI}$. $CG_{SER}$ contains transactions running under the SER isolation level, and $CG_{SI}$ contains those running under SI. $CG_{SER}$ is obviously acyclic, and according to Theorem~\ref{theorem-2}, so is $CG_{SI}$. Subsequently, we consider the dependency edges that connect $CG_{SER}$ and $CG_{SI}$. When the database processes transactions under both SI and SER concurrently, no exceptions will occur apart from those that could occur under SI alone. In \sysname, the concurrency control for all transactions is conducted according to the policy corresponding to SI, meaning the dependency between $CG_{SER}$ and $CG_{SI}$ forms a cycle neither.

Achieving serializability becomes complex in the context of cross-isolation levels, as concurrency control must address dependencies arising from different isolation levels when transitioning from one isolation to another. 
As detailed in Section~\ref{design-3}, this transition process comprises three distinct stages. 
The serializability of Phase I, which encompasses all transactions operating under the old isolation level, as well as Phase III, involving all transactions under the new isolation level, can be readily proven as demonstrated in Section~\ref{sec:proof.isolation}.
We will discuss the serializability for Phase II, which involves transactions that run across isolation levels and can be divided into two distinct parts: (1) the isolation transitions involving SER isolation and (2) the transitions occurring solely between SI and RC levels. 

\textbf{Transaction involves SER isolation level.} Additional validation is necessary during the transition when SER isolation is involved. As outlined in Section~\ref{design-3}, we categorize transactions into three sets: $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$. The concurrency control in Section~\ref{sec:design:cc:validation} ensures that there is no dependency cycle within $S_{old}^{(1)} \cup S_{old}^{(2)}$ and $S_{new}$, respectively.
As depicted in Figure~\ref{fig:switch_correctness}, dependencies arise across isolation levels, between transactions in $S_{new}$ and those in $S_{old}^{(1)}$ and $S_{old}^{(2)}$. 
\blackding{1} Transactions in $S_{old}^{(1)}$ commit before any transactions in $S_{new}$ start. Therefore, dependencies can only occur when a transaction in $S_{new}$ reads or writes the data written by $S_{old}^{(1)}$. 
\blackding{2} Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and may be bidirectional. 
In phase~II, \sysname is required to track these dependencies and ensure that there are no dependencies from the transactions in $S_{new}$ to those in $S_{old}^{(2)}$. 
% Thus, the dependencies can be only flow from $S_{old}^{(2)}$ to $S_{new}$.
Therefore, the dependency graph is acyclic during the transition, thus achieving SS.
% cross-isolation transactions during the transition are serializable.

\textbf{Transition between SI and RC isolation levels.} Unlike involving SER, the transition of \sysname between SI and RC isolation levels does not require additional validation. To illustrate this, we consider the counter-example in Figure~\ref{fig:cross-isolation} and briefly demonstrate that no cycle can be formed during the transition. By contradiction, we assume a cycle exists, with $T_j$ being the first transaction to commit. This implies the existence of an RW edge from $T_i$ to $T_j$, as $T_j$ commits first. However, by identifying the static vulnerable dependency at RC, the middle-tier concurrency control approach ensures $T_i$ commits before $T_j$ for any RW dependency, meaning that $T_i$ operates under SI. 
By identifying the static vulnerable dependency in SI, it is not permissible for two consecutive RW dependencies to have the last transaction committed first. So, the dependency from $T_k$ to $T_i$ must be either WW or WR. 
In this case, the commit time of $T_k$ is before $T_i$ starts. Since $T_i$ is concurrent with $T_j$ by a RW dependency, $T_j$ commits after $T_i$ starts. Thus, $T_k$ must commit before $T_j$ commits, which contradicts the assumption that $T_k$ is the first transaction to commit in the cycle. Therefore, we conclude that no cycles exist during the transition.

% The transition process ensures serializability when transactions follow the middle-tier concurrency control designed for each individual isolation level in \sysname. As we all know, non-serializable scheduling can be identified by a dependency cycle. Consider the counter-example in Figure~\ref{fig:cross-isolation}. Denote the first committed transaction in the cycle as $T_j$, with its predecessor transactions as $T_i$ and $T_j$. The inconsistent dependency order and commit order between them indicate the dependency from $T_i$ to $T_j$ must be an RW dependency. This implies $T_i$ operates under SI and is concurrent with $T_j$, meaning \textit{$T_i$ begins before $T_j$ commits}. Then, the dependency from $T_k$ to $T_i$ could be either WW or WR dependency. If it is an RW dependency, two consecutive RW dependencies occur, consisting of the dangerous structure in SI; then, the middle-tier concurrency control could schedule the commit order of $T_i$ and $T_j$ to make it consistent with the dependency order. Since $T_i$ operates under SI, $T_k$ must commit before $T_j$ begins, which contradicts our assumption that $T_j$ is the first transaction to commit in this cycle. Therefore, no such dependency cycles exist, ensuring that transaction scheduling is serializable under \sysname.

% \sysname employs a stringent concurrency control mechanism during isolation level transitions. 
% The correctness of this mechanism can be divided into two parts: the transition involving SER and the transition between SI and RC. We demonstrate the correctness of both scenarios separately.

% \subsubsection{Transaction involving SER isolation level.}
% As detailed in Section~\ref{design-3}, this transition process comprises three distinct stages, for which we provide proof of serializability. 
% The serializability of Phase I, which encompasses all transactions operating under the previous isolation level, as well as Phase III, involving all transactions under the new isolation level, can be readily proven as demonstrated in Section~\ref{sec:proof.isolation}.
% We will provide proof of serializability for Phase II, which involves transactions that run across both isolation levels.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.47\textwidth]{figures/switch_correctness3.pdf}
    \vspace{-4mm}
    \caption{Cross-isolation level dependencies}
    % \caption{Partial dependency between $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$}
    \label{fig:switch_correctness}
    \vspace{-4mm}
\end{figure}

% According to Section~\ref{design-3}, we categorize the transactions into three sets: $S_{old}^{(1)}$, $S_{old}^{(2)}$, and $S_{new}$. As depicted in Figure~\ref{fig:switch_correctness}, we will demonstrate that these transactions' schedules are serializable, without conflict cycles. Within the same isolation level, consider the proof in Section \ref{sec:proof.isolation}, we can establish that both $S_{old}^{(1)} \cup S_{old}^{(2)}$ and $S_{new}$ are serializable. 
% When dependencies are across isolation levels and transactions are from between $S_{new}$ and $S_{old}^{(1)}$, as well as between $S_{new}$ and $S_{old}^{(2)}$.
% \blackding{1} Transactions in $S_{old}^{(1)}$ commit before transactions in $S_{new}$ start. Therefore, dependencies can only occur when a transaction in $S_{new}$ reads or writes the data written by $S_{old}^{(1)}$.
% \blackding{2} Initially, the dependencies between $S_{old}^{(2)}$ and $S_{new}$ can be any types and bidirected. In phase~II, \sysname could track these dependencies and ensure that transactions in $S_{new}$ either commit after $S_{old}^{(1)}$ or abort. 
% % no operation in $S_{old}^{(1)}$ depends on an operation in $S_{new}$.
% Thus, the dependencies can be only from $S_{old}^{(2)}$ to $S_{new}$. Consequently, cross-isolation transactions during the switching phase are serializable.
% For example, for the switch from SER to SI, the $CG$ of $H$ is divided into two subgraphs: $CG_{SER}$ and $CG_{SI}$. $CG_{SER}$ contains transactions operating under the SER level, and $CG_{SI}$ contains those operating under the SI level. It is evident that $CG_{SER}$ is acyclic due to the stringent nature of SER. Furthermore, according to Theorem~\ref{theorem-2}, $CG_{SI}$ is also acyclic.
% We then examine the dependency edges that bridge $CG_{SER}$ and $CG_{SI}$.

% In \sysname, \textcolor{red}{Describe more information when the database concurrently processes transactions under both SI and SER, how to deal with transaction conflict to guarantee serializability.} the concurrency control for all transactions adheres to SER protocol or Theorem \ref{theorem-2}. This approach ensures that no cycles form between $CG_{SER}$ and $CG_{SI}$, maintaining the acyclic nature of the overall system's conflict graph and thereby preserving conflict serializability throughout the transition.

% \subsubsection{Transition between SI and RC isolation level.} The transition process ensures serializability when transactions follow the middle-tier concurrency control designed for each individual isolation level in \sysname. As we all know, non-serializable scheduling can be identified by a dependency cycle. Consider the counter-example in Figure~\ref{fig:cross-isolation}. Denote the first committed transaction in the cycle as $T_j$, with its predecessor transactions as $T_i$ and $T_j$. The inconsistent dependency order and commit order between them indicate the dependency from $T_i$ to $T_j$ must be an RW dependency. This implies $T_i$ operates under SI and is concurrent with $T_j$, meaning \textit{$T_i$ begins before $T_j$ commits}. Then, the dependency from $T_k$ to $T_i$ could be either WW or WR dependency. If it is an RW dependency, two consecutive RW dependencies occur, consisting of the dangerous structure in SI; then, the middle-tier concurrency control could schedule the commit order of $T_i$ and $T_j$ to make it consistent with the dependency order. Since $T_i$ operates under SI, $T_k$ must commit before $T_j$ begins, which contradicts our assumption that $T_j$ is the first transaction to commit in this cycle. Therefore, no such dependency cycles exist, ensuring that transaction scheduling is serializable under \sysname.
