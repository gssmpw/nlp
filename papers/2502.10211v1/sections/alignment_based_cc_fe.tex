\section{The proposed process mining-based feature extraction}
\label{sec:abccfe}
This section first presents the preliminaries of \revision{process mining} to establish the notation used throughout the paper. In particular, we report the standard definitions from the \revision{process mining} literature of the event log, sublog, trace, Petri net, fitness, and alignment and moves. After the necessary notation is established, the proposed \revision{process mining}-based feature extraction with alignment-based \revision{conformance checking} is developed, including the definitions of alignment-based fitness and per-activity cost. These two are used to extract alignment-based \revision{conformance checking} diagnoses, i.e., the novel \revision{process mining}-based feature extraction approach.
\subsection{Preliminaries}
Firstly, we report the definition of the event log and sublog, since they are the main inputs to \revision{process mining} algorithms.
\begin{definition}[Event log, sublog and trace]
\label{def:el}
Let us denote $\mathcal{A}$ as the universe of activities and $\mathcal{A}^*$ the universe of possible sequences of activities in $\mathcal{A}$. Hereafter, we refer to a sequence of activities as a \emph{trace} $\sigma\in\mathcal{A}^*$. An \emph{event log} $L$ is a multi-set of $k$ traces, where a multi-set is a set such that there may be two equal yet distinct elements. Given $\mathcal{B}(\mathcal{A}^*)$ the set of multi-sets over $\mathcal{A}^*$, $L\in\mathcal{B}(\mathcal{A}^*)$. A \emph{sublog} is a subset of $L$. Furthermore, we denote an \emph{$n$-tuple of event logs} $\mathcal{L}=(\mathcal{L}(1),\mathcal{L}(2),\dots, \mathcal{L}(n))$ as $\mathcal{L}\in(\mathcal{B}(\mathcal{A^*}))^n$. 
\end{definition}
An event log can be processed by process discovery algorithms to build a process model. This process model captures a set of possible control flows based on the relationships among activities within the traces of the event log. There is a plethora of formalisms to capture these relationships. As mentioned in Section \ref{sec:introduction}, in this work, we focus on the labeled Petri net (hereafter, Petri net).
\begin{definition}[Petri net]
Let $P$ and $Tr$ be two sets of nodes of a bipartite graph such that $P\,\cap\,Tr=\emptyset$, and $F\subseteq (P\times Tr)\,\cup\,(Tr\times P)$ a set of directed arcs. Furthermore, let $A\subseteq\mathcal{A}$ be a set of activities and $l:Tr\rightarrow A\cup\{\tau\}$ a function that associates to elements of $Tr$ either an activity of $A$ or the ``silent" label $\tau$. A Petri net $N$ is the tuple $(P,Tr,F,A,l)$, where $P$ are the places, $Tr$ the transitions, $F$ the arcs, $A$ the activities, and $l$ the labeling function. Finally, $M\in \mathcal{B}(P)$ is the (current) \emph{marking} of the Petri net, i.e., a multi-set of tokens that determine which transition is allowed to \emph{fire}. In the following, we denote $\mathcal{N}$ the universe of Petri nets. 
\end{definition}
Similar to process discovery, \revision{conformance checking} algorithms also process event logs, but they use a reference Petri net and check the traces of event logs against it to verify if the execution fits the model \cite{aalst2022pmhandbook}. The main output of \revision{conformance checking} is the fitness, which quantifies how much the process model fits the event log.

\begin{definition}[Fitness]
Let $L\in\mathcal{B}(\mathcal{A^*})$ be an event log, $\sigma\in L$ a trace, and $N\in\mathcal{N}$ a Petri net. We denote the \emph{fitness} computed by \revision{conformance checking} when replaying $\sigma$ on $N$ as $F_{\sigma, N}\in[0,1]$, whereas when replaying all traces of $L$ we denote the \emph{fitness} as $F_{L,N}\in[0,1]$.
\end{definition}

Although there are many \revision{conformance checking} variants in the literature, the state-of-the-art is alignment-based \revision{conformance checking}. This variant attempts to find the best path across the reference Petri net that most accurately approximates the traces in the event log that deviate from normal control flow. This is done by taking into account the \textit{log moves} in an event log and their \textit{alignment} to the reference Petri net by evaluating the corresponding \textit{model moves}.
\begin{definition}[Alignment and moves]
Let us denote $\nomove$ as the ``skipped" activity. Let $N\in\mathcal{N}$ be a Petri net and $\sigma\in \mathcal{A}^*$ a trace. $\sigma_L=\langle a_1,\dots,a_o\rangle\in (\mathcal{A}\cup\{\nomove\})^*$ is a (finite) sequence of log moves related to $\sigma$ if and only if $\sigma_L\setminus \{\nomove\}=\sigma$. Then, $\sigma_{N}=\langle b_1,\dots, b_o\rangle\in (\mathcal{A} \cup \{\tau\} \cup \{\nomove\})^*$ is a (finite) sequence of model moves if and only if $\sigma_{N}\setminus\{\nomove\}$ is a firing sequence of $N$, i.e. an allowed control flow. An \emph{alignment} $\gamma_{\sigma, N}$ is the two-row matrix
\begin{equation}
\gamma_{\sigma, N}=
\begin{array}{c|c|c|c}
a_1 & a_2 & \cdots & a_o \\
\hline
b_1 & b_2 & \cdots & b_o
\end{array},
\end{equation}
if for all $1 \leq i \leq o$, $(a_i, b_i) \neq (\nomove, \nomove)$, where $(a_i,b_i)$ is a \emph{move}. 
\end{definition}
\subsection{Alignment-based \revision{conformance checking} diagnoses}
\begin{table}[!t]
\centering
\caption{Alignment-based \revision{conformance checking} diagnoses obtained from replaying the $n$-tuple of event logs $\mathcal{L}$ against a Petri net $N$.}
\label{tab:CC_DIAGNOSES}
\begin{tabular}{llllll}
\hline
\textbf{Event log}            & $\boldsymbol{c_1}$       & $\boldsymbol{c_2}$       & $\cdots$ & $\boldsymbol{c_o}$       & $\boldsymbol{F_{\mathcal{L}(i),N}}$ \\ \hline
$\boldsymbol{\mathcal{L}(1)}$ & $u_{c_1,\mathcal{L}(1)}$ & $u_{c_2,\mathcal{L}(1)}$ & $\cdots$ & $u_{c_o,\mathcal{L}(1)}$ & $F_{\mathcal{L}(1),N}$              \\
$\boldsymbol{\mathcal{L}(2)}$ & $u_{c_1,\mathcal{L}(2)}$ & $u_{c_2,\mathcal{L}(2)}$ & $\cdots$ & $u_{c_o,\mathcal{L}(2)}$ & $F_{\mathcal{L}(2),N}$              \\
$\cdots$                      & $\cdots$                 & $\cdots$                 & $\cdots$ & $\cdots$                 & $\cdots$                            \\
$\boldsymbol{\mathcal{L}(n)}$ & $u_{c_1,\mathcal{L}(n)}$ & $u_{c_2,\mathcal{L}(n)}$ & $\cdots$ & $u_{c_o,\mathcal{L}(n)}$ & $F_{\mathcal{L}(n),N}$              \\ \hline
\end{tabular}
\end{table}

Our proposal aims to collect information recorded throughout alignment-based \revision{conformance checking} when replaying event logs on a reference Petri net; we term such information as \emph{alignment-based \revision{conformance checking} diagnoses}. These diagnoses involve computing the alignment-based fitness and the per-activity cost.
\begin{definition}[Alignment-based fitness]
\label{def:ab_fitness}
Let us denote $\Gamma_{\sigma, N}$ as the set of all alignments between a trace $\sigma\in\mathcal{A}^*$ and a Petri net $N\in\mathcal{N}$. Let $\delta$ be the unitary cost function for a pair of moves or an alignment. Finally, let $\gamma^w_{\sigma,N}\in\Gamma_{\sigma, N}$ be the worst-case alignment and $\gamma^*_{\sigma,N}\in\Gamma_{\sigma, N}$ the best-case alignment, i.e., the alignments with the least and most costs according to $\delta$, respectively.  The \emph{alignment-based fitness} for $\sigma$ is defined as
\begin{equation}
F_{\sigma,N}=1-\frac{\delta(\gamma^*_{\sigma,N})}{\delta(\gamma^w_{\sigma,N})}.
\end{equation}
Let $L\in\mathcal{B}(\mathcal{A^*})$ be an event log. The \emph{alignment-based fitness} for $L$ is defined as
\begin{equation}
F_{L,N}=\frac{\sum_{\sigma\in L}F_{\sigma,N}}{|L|}.
\end{equation}
\end{definition}
\begin{definition}[Per-activity cost]
\label{def:act_cost}
Let $N\in\mathcal{N}$ be a Petri net, $\sigma\in\mathcal{A}^*$ a trace, $\mathcal{C}_{\sigma,N}\subseteq\mathcal{A}$ the set of activities found either in $\sigma$ or in labeled transitions of $N$, $\delta$ the cost function for a pair of moves or an alignment, $\gamma^*_{\sigma,N}\in\Gamma_{\sigma, N}$ the best-case alignment, and $\gamma^*_{c,\sigma,N}$ the set of moves of $\gamma^*_{\sigma,N}$ such that $\forall(a,b)\in\gamma^*_{c,\sigma,N}, c=a\lor c=b$. The \emph{per-activity cost} for $\sigma$ is defined as
\begin{equation}
    u_{c,\sigma}=\sum_{(a,b)\in \gamma^*_{c,\sigma,N}}\delta((a,b)),\quad c\in \mathcal{C}_{\sigma,N}.
\end{equation}
Let $L\in\mathcal{B}(\mathcal{A}^*)$ be an event log and $\mathcal{C}_{L,N}\subseteq\mathcal{A}$ the set of activities found either in traces of $L$ or in labeled transitions of $N$. The per-activity cost for $L$ is:
\begin{equation}
    u_{c,L}=\sum_{\sigma\in L}u_{c,\sigma},\quad c\in \mathcal{C}_{L,N}.
\end{equation}
\end{definition}
\begin{definition}[Alignment-based \revision{conformance checking} diagnoses]
\label{def:ab_cc}
Let $\mathcal{L}\in(\mathcal{B}(\mathcal{A}^*))^n$ be an $n$-tuple of event logs, $N\in\mathcal{N}$ a Petri net, $\mathcal{C}_{\mathcal{L},N}=\{c_1,\dots,c_o\}\subseteq\mathcal{A}$ the set of activities found either in traces of event logs of $\mathcal{L}$ or in labeled transitions of $N$. \emph{Alignment-based \revision{conformance checking} diagnoses} for $\mathcal{L}$ is tabular data arranged as in Table \ref{tab:CC_DIAGNOSES}.
\end{definition}
\begin{figure}[!t]
\centering
\includegraphics[width=0.95\columnwidth]{images/AB_CC_VISUALIZATION.png}
\caption{Generation of alignment-based \revision{conformance checking} diagnoses by replaying the $n$-tuple of event logs $\mathcal{L}$ against a Petri net $N$.}
\label{AB_CC_VISUALIZATION}
\end{figure}

Figure \ref{AB_CC_VISUALIZATION} visualizes the generation of alignment-based \revision{conformance checking} diagnoses. A starting set of event logs $\mathcal{L}$ is aligned to a Petri net $N$, generating a set of alignments per event log $\mathcal{L}(1)\dots\mathcal{L}(n)$. Subsequently, alignment-based fitness $F_{\mathcal{L}(x),N}$ and per-activity costs $u_{c_1,\mathcal{L}(1)}\dots u_{c_n,\mathcal{L}(1)}$ per event log $\mathcal{L}(1)\dots\mathcal{L}(n)$ are calculated. The results are joined together to form alignment-based \revision{conformance checking} diagnoses. Finally, machine learning can handle the resulting tabular data.

\paragraph{Illustrative example}Figure \ref{PETRI_NET_TRACES} shows the connection between alignment-based \revision{conformance checking} diagnoses of three traces and the reference Petri net of one of the datasets we use in Section \ref{sec:evaluation}. Specifically, the reference Petri net provides control-flow relations that alignment-based \revision{conformance checking} uses to check whether traces $\sigma_1$, $\sigma_2$ and $\sigma_3$ deviate from such relations. For example, $\sigma_1$ exhibits duplicated (\texttt{t35}), wrongly-ordered (\texttt{t51}$\rightarrow$\texttt{t62}), skipped (\texttt{t21}$\rightarrow$\texttt{t32}, \texttt{t44}$\rightarrow$\texttt{t54}, \texttt{t76}$\rightarrow$\texttt{t82}), and unknown (\texttt{t75}) control-flow anomalies. As a result, this reflects in some mismatches in the corresponding alignment, highlighted by the moves (\texttt{t35},$\nomove$), ($\nomove$,\texttt{t32}), (\texttt{t62},$\nomove$), ($\nomove$,\texttt{t76}) and (\texttt{t75},$\nomove$). These mismatches can be projected onto the process model. For example, by summing all per-activity costs related to \texttt{t44}, this results in $\sum_{\sigma}u_{t44,\sigma}=3$.
\begin{figure*}[!t]
\centering
\includegraphics[width=\textwidth]{images/PETRI_NET_TRACES.png}
\caption{The connection between alignment-based \revision{conformance checking} diagnoses of three traces and the reference Petri net of one of the datasets we use in Section \ref{sec:evaluation}.}
\label{PETRI_NET_TRACES}
\end{figure*}

