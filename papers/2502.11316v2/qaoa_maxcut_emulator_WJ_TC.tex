\documentclass[10pt]{IEEEtran}
\nonstopmode
\IEEEoverridecommandlockouts
% The preceding line is only needed to identify funding in the first footnote. If that is unneeded, please comment it out.
%Template version as of 6/27/2024

\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}

\usepackage{comment}


\usepackage{colortbl}
\usepackage{dhucs} % support Korean


\usepackage{booktabs} % For formal tablesa
\usepackage{multirow}


\usepackage{makecell}
\usepackage{tabularx}
\usepackage{subcaption}
\usepackage{bm}


\usepackage{color} %added by jina
\usepackage{setspace} %added by jina (for subsubsection)
\usepackage{graphicx} %added by jina (for table)
\usepackage{makecell}%added by jina (for table), thick line
\usepackage{enumitem} %added by jina (for table)
\usepackage{nicematrix} %added by jina (for table)
\usepackage{threeparttable} %added by jina (for table)
\usepackage{dblfloatfix}    % To enable figures at the bottom of page

\newcommand{\editorialcomment}[1]{\textcolor{blue}}
\newcommand{\delete}[1]{
%\textcolor{blue}{#1}
}
\newcommand{\black}[1]{\textcolor{black}{#1}}


\newcommand\plotlabel[1]{#1\vphantom{abcdefghijklmnopqrstuvwxyz}}

\newcommand\refFigure[1]{Fig.~\ref{#1}}
\newcommand\refTable[1]{Table~\ref{#1}}
\newcommand\refSection[1]{Section~\ref{#1}}
\newcommand\refAlgo[1]{Algorithm~\ref{#1}}
\newcommand\refEqn[1]{(\ref{#1})}
\newcommand\TODAY{19 11. 2024}

\newcommand\korean[1]{}
\newcommand\blind[1]{XXXX}
\newcommand\touchcare{YYYYYY}

\newcommand\ms{$ms$}
\newcommand\us{$\mu s$}
\usepackage{relsize}

\newcommand\LWJ[1]{\textcolor{red}{#1}}
\newcommand\CEJ[1]{\textcolor{brown}{#1}}
\newcommand\JN[1]{\textcolor{cyan}{#1}}
\newcommand{\CSH}[1]{\textcolor{red}{#1}}

\def\useshortref{0}
\def\usemiddleref{0}


\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}
\begin{document}

%A CMOS-Based Quantum Processing Unit for QAOA: Demonstration on Weighted-MaxCut in a Standalone FPGA
\title{Standalone FPGA-Based QAOA Emulator for Weighted-MaxCut on Embedded Devices
%\vspace {-20pt}
%\thanks{This work was supported in part by Institute of Information \& communications Technology Planning \& Evaluation (IITP) grant funded by the Korea government (MSIT) (No. RS-2023-00277060, Development of open edge AI SoC hardware and software platform), in part by the National Research Foundation of Korea (NRF) grant funded by the Korea government (MSIT) (No. RS-2024-00345668). (\textit{Corresponding author: Woojoo Lee})}
%\thanks{S. Choi, K. Lee, and W. Lee are with the Department of Intelligent Semiconductor Engineering, Chung-Ang University, South Korea. (e-mail: chltmdgus272@cau.ac.kr; since69se@cau.ac.kr; space@cau.ac.kr).}
%\thanks{J.-J. Lee is with the  AI SoC Research Division, Electronics and Telecommunications Research Institute (ETRI), Korea. (e-mail: ceicarus@etri.re.kr).}
%\thanks{$^{*}$Seonghyun Choi and Kyeongwon Lee contributed equally to this work as the first authors.}
%\thanks{This manuscript is intended for submission to \textit{IEEE Transactions on Computers.}}
}




\author{\large
Seonghyun Choi, Kyeongwon Lee, Jae-Jin Lee, and Woojoo Lee 
}



\begin{comment}
\author{\IEEEauthorblockN{1\textsuperscript{st} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{2\textsuperscript{nd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{3\textsuperscript{rd} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{4\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{5\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
\and
\IEEEauthorblockN{6\textsuperscript{th} Given Name Surname}
\IEEEauthorblockA{\textit{dept. name of organization (of Aff.)} \\
\textit{name of organization (of Aff.)}\\
City, Country \\
email address or ORCID}
}
\end{comment}

%\author{}

\maketitle

\begin{abstract}
Quantum computing (QC) emulation is crucial for advancing QC applications, especially given the scalability constraints of current devices. 
FPGA-based designs offer an efficient and scalable alternative to traditional large-scale platforms, but most are tightly integrated with high-performance systems, limiting their use in mobile and edge environments. 
This study introduces a compact, standalone FPGA-based QC emulator designed for embedded systems, leveraging the Quantum Approximate Optimization Algorithm (QAOA) to solve the Weighted-MaxCut problem. 
By restructuring QAOA operations for hardware compatibility, the proposed design reduces time complexity from $\bm{O(N^2)}$ to $\bm{O(N)}$, where $\bm{N = 2^n}$ for $\bm{n}$ qubits. 
This reduction, coupled with a pipeline architecture, significantly minimizes resource consumption, enabling support for up to 9-qubits on mid-tier FPGAs—three times more than comparable designs. 
Additionally, the emulator achieved energy savings ranging from 1.53$\bm{\times}$ for 2-qubits to up to 852$\bm{\times}$ for 9-qubits compared to software-based QAOA implementations on embedded processors.
These results highlight the practical scalability and resource efficiency of the proposed design, providing a robust foundation for QC emulation in resource-constrained edge devices.

%Quantum computing (QC) emulation is crucial for advancing QC applications amid current devices' scalability constraints. Although traditional QC emulators rely on large-scale platforms, FPGA-based designs enable more efficient, scalable alternatives. Yet, most FPGA-based emulators integrate with high-performance systems, limiting their use in mobile and edge environments.
%To overcome these challenges, this study presents a standalone FPGA emulator tailored for embedded systems, leveraging the Quantum Approximate Optimization Algorithm (QAOA) to solve the Weighted-MaxCut problem. To achieve this, we restructured QAOA operations for HW compatibility, \CSH{thereby reducing time complexity from $O(N^{2})$ to $O(N)$, where $N=2^{n}$ for number of qubit $n$,} and developed a pipeline architecture that minimizes resource consumption. Applying our HW$\cdot$SW co-design method, the proposed emulator with a dedicated accelerator achieved \delete{up to 863$\mathbf{\times}$ speedup over an SW-driven QAOA for a 5-qubit, 12-layer configuration.}\CSH{up to 854$\mathbf{\times}$ energy efficiency over an SW-driven QAOA for a 9-qubit configuration.} It also achieved superior resource efficiency by supporting \CSH{3$\mathbf{\times}$} more qubits on mid-tier FPGAs compared to a QC accelerator-equipped emulator. 
%\CSH{This highlights the significant energy efficiency of our proposed design compared to previous software-based and baseline emulators. Furthermore, the resource-efficient and scalable design establishes a practical foundation for QC emulation on resource-limited devices.}

\end{abstract}

\begin{comment}
\begin{IEEEkeywords}
component, formatting, style, styling, insert.
\end{IEEEkeywords}	
\end{comment}

\section{Introduction}

Over recent decades, quantum computing (QC) has made remarkable strides, leveraging principles of superposition, entanglement, and parallelism to surpass classical computing in specific domains. 
These advancements have garnered significant attention from both academia~\cite{Wang:ACM22,Kim:Nature23, Kikuchi:npjQI23,Almudever:DATE24} and industry~\cite{Microsoft:Qubit, Google:Science20}, firmly establishing QC as a central focus of modern research. 
However, current QC devices face substantial scalability and error correction challenges, preventing them from reaching the large-scale capacities required for fully practical quantum computers and networks. 
As a result, there has been considerable research into emulating quantum algorithms on classical computing resources to bridge the gap until fully operational QC systems emerge. 
QC emulators play a critical role in enabling rapid experimentation and prototyping of quantum circuits, traditionally relying on large, resource-intensive platforms~\cite{Arrazola:Nature21}. In contrast, recent QC emulators increasingly leverage FPGAs, providing more efficient, scalable, and cost-effective solutions for hardware-accelerated quantum algorithm emulation~\cite{Shang:npjQI23, ElAraby:IEEE23,Choi:AIMS24}. 
The inherent cost-efficiency, high performance, and reconfigurability of FPGAs make them an appealing choice for QC emulation.

%Over the past few decades, quantum computing (QC) has made remarkable strides, leveraging principles of superposition, entanglement, and parallelism to outperform classical computing in specific problem domains. 
%These advancements in QC have attracted substantial attention from both academia~\cite{Kim:Nature23, Kikuchi:npjQI23} and industry~\cite{Microsoft:Qubit,Google:Science20}, firmly establishing it as a focal area of modern research and development. 
%Despite this progress, current QC devices face significant challenges, particularly in scalability and error correction, which prevent them from reaching the practical, large-scale capacities required for quantum computers and networks. 
%Addressing these obstacles has spurred considerable research into emulating quantum algorithms using classical computing resources.
%
%QC emulators play a vital role in bridging the gap until fully operational QC systems become available. 
%Specifically, QC emulators facilitate rapid experimentation and prototyping of quantum circuits, algorithms, and applications. 
%Traditionally, classical QC emulators have relied on large, resource-intensive, and expensive emulation platforms~\cite{Arrazola:Nature21}. 
%In contrast, modern QC emulators increasingly leverage FPGAs for more efficient, scalable, and cost-effective hardware-accelerated quantum algorithm emulation~\cite{Shang:npjQI23, ElAraby:IEEE23}. 



%The inherent cost-efficiency, high performance, and reconfigurability of FPGAs make them an attractive option for QC emulation.

Nevertheless, most FPGA-based QC emulators to date are designed as QC accelerators integrated into high-performance computing systems \cite{Pilch:Springer19, Li:IEEE21, Shang:npjQI23, ElAraby:IEEE23} . 
While such integration is valuable, it falls short of supporting the eventual deployment of QC applications in mobile and edge device environments. 
Mobile and edge devices typically operate under stringent resource constraints and require applications that can closely interact with diverse surrounding environments and situations. 
Consequently, a QC emulator that operates within these constraints on embedded devices, rather than relying on server-level computing power, is essential.

In response to this need, we aim to develop a QC emulator tailored for embedded devices, designed to maximize efficiency within limited resources. 
Our research focuses on designing an optimized QC accelerator and implementing a complete standalone system on an FPGA. 
We have selected the Quantum Approximate Optimization Algorithm (\textit{QAOA}) as our target algorithm, given its high potential for applications in mobile and edge device environments. 
QAOA is an effective QC method for finding approximate solutions to combinatorial optimization problems~\cite{Streif:PRA21, Borle:SciPost21, Moussa:Springer22, Awasthi:Springer23} and is particularly relevant for the MaxCut problem in graph partitioning~\cite{Blekos:Elsevier24, Zhao:Elsevier24, Esposito:IEEE24}. 
Graph partitioning optimization is essential in numerous embedded system applications, especially in resource-constrained environments where efficient partitioning algorithms are critical~\cite{Jungum:Elsevier16, Faraj:ACM22, Chhabra:arXiv24}. 
Our study on an FPGA standalone QAOA emulator is expected to serve as a pivotal benchmark, providing critical insights and establishing a foundational framework for the practical deployment and advancement of QC within embedded systems.

The primary challenge in developing a QAOA emulator lies in creating an accelerator that supports the maximum number of qubits within constrained resources. 
Increasing the number of qubits in QC enhances the emulator's computational power and capacity, emphasizing the need for optimized design techniques. 
Like other QC algorithms, QAOA represents quantum states and operations as vectors and matrices, which grow exponentially with the number of qubits $n$. This exponential growth demands substantial resources for storage and processing, posing significant challenges for QC emulation on resource-constrained platforms. 
To address these challenges, we adopt a hardware-software co-design approach. 
First, we optimize the computational expressions of QAOA for the Weighted-MaxCut problem, tailoring them for hardware implementation and reducing the emulator's time complexity from $O(N^2)$ to $O(N)$ ($N=2^n$). 
We then deploy these optimized expressions in a pipelined structure, minimizing hardware resource requirements by reducing the number of parallelized multiplications, which are particularly resource-intensive in hardware computations.

%The primary challenge in developing a QAOA emulator lies in creating an accelerator capable of supporting the maximum possible number of qubits within limited resources. 
%Increasing the number of qubits in QC enhances the emulator's computational power and representation capabilities, driving the need for optimized design techniques. 
%Like other QC algorithms, QAOA also represents quantum states and operations as vectors and matrices, which grow exponentially with the number of qubits $n$. This exponential growth demands substantial resources for storage and processing, creating practical limitations for QC emulation on low-resource platforms. 
%To address these limitations, we adopt a hardware-software co-design approach, initially optimizing the computation expressions of QAOA for the Weighted-MaxCut problem specifically for hardware implementation, thereby reducing the emulator's time complexity from $O(N^{2})$ to $O(N)$ ($N=2^n$).
%We then deploy the optimized expressions in a pipelined structure, reducing the hardware resources required for emulation by minimizing the parallelization of multiplication operations, a significant burden in hardware computations.

Finally, the proposed accelerator was implemented as an IP core and integrated into an edge-device-oriented RISC-V processor architecture, completing the standalone QC emulator. 
Performance evaluations reveal that the energy efficiency of the emulator, enhanced by the QAOA accelerator, increases exponentially with the number of qubits, achieving up to a 1.5$\times$ reduction for 2-qubit QAOA and reaching a maximum of 854$\times$ reduction for 9-qubit QAOA.
Resource utilization analyses conducted on FPGA prototypes demonstrate that, while previous approaches support accelerators for up to 3-qubits on mid-tier FPGAs (e.g., Kintex-7) and 2-qubits on entry-level boards (e.g., Artix-7), our resource-optimized design enables the implementation of QC accelerators supporting up to 9-qubits and 8-qubits, respectively. 
These results highlight substantial improvements in both resource and energy efficiency, establishing the proposed emulator as a practical and scalable QC solution for solving complex Weighted-MaxCut problems on resource-constrained embedded devices.

%최근 양자 컴퓨터를 활용하여 고전 컴퓨터로 해결하기 어려운 문제에 도전하려는 시도가 늘어나고 있다. 이 가운데, 양자 근사 최적화 알고리즘(QAOA)\cite{Farhi:arXiv14}은 다양한 조합 최적화 문제에 대해 근사해를 찾는 효과적인 방법으로 떠오르고 있다 \cite{Choi:IEEE19, Zhou:PRX20, Streif:PRA21, Borle:SciPost21, Awasthi:Springer23, Moussa:Springer22}. 이러한 최적화 문제 중, MaxCut 문제\cite{Korte:Book11}는 그래프 분할을 최적화\cite{Ding:IEEE01, Beaulieu:arXiv21, Bhaskara:arXiv18}하는 데에 활용되고 있다. QAOA가 이러한 문제에 적합함이 알려져 있으며, 이에 따라 MaxCut 등의 그래프 분할 문제를 해결하기 위한 다양한 QAOA 알고리즘이 연구되고 있다. \cite{Blekos:Elsevier24, Zhao:Elsevier24, Villalba:MDPI21, Esposito:IEEE24}. 

%특히 자원이 제약된 환경에서 그래프 분할 문제를 해결하고자 하는 수요가 발생하고 있으며, 이를 위해 자원 효율적인 분할 알고리즘에 대한 연구가 현재 진행중이다\cite{Faraj:ACM22, Chhabra:arXiv24, Jungum:Elsevier16}. 따라서 QAOA와 같은 양자 알고리즘을 MaxCut과 같은 그래프 분할 문제에 적용하여 자원 제약적인 모바일 및 엣지 디바이스에 활용할 여지가 있다. 양자 컴퓨터 기술의 발전에 따라, MaxCut 문제를 위해 QAOA를 실행하는 양자 컴퓨팅 유닛을 SoC 디바이스에 집적하여 그래프 분할 성능을 극대화하는 방안이 효과적일 것으로 기대된다. 그러나 현재의 양자 컴퓨터 기술로는 이러한 하드웨어 구조 설계에 여전히 어려움이 있으며, 해당 하드웨어 위에서 어플리케이션을 개발하고 성능을 평가하는 데도 제약이 따른다.
%
%이를 해결하기 위한 대안으로, 양자 컴퓨터의 동작을 모방하는 에뮬레이터의 사용이 고려될 수 있다. 하지만 양자 컴퓨터의 중첩(superposition)과 얽힘(entanglement) 특성을 고전 컴퓨터에서 구현하려면, 큐비트 수가 증가함에 따라 연산량과 실행 시간이 기하급수적으로 늘어난다. 이는 특히 연산 성능이 제한적인 임베디드 장치에서 큰 문제로 작용한다. 또한 기존의 에뮬레이터는 SoC 환경에서의 동작을 고려하지 않고 설계되어, 양자 컴퓨팅 유닛이 집적된 SoC 구조를 에뮬레이팅하여 어플리케이션을 개발하고 성능을 평가하는 데에 어려움이 따른다.
%
%최근에는 FPGA와 같은 하드웨어 자원을 병렬적으로 구성하여 양자 컴퓨팅을 가속하려는 시도도 있다.\cite{ElAraby:IEEE23, Li:IEEE21, Pilch:Springer19} 그러나 이러한 방식 또한 큐비트 수가 증가할수록 필요한 하드웨어 자원량이 급증하여 MaxCut과 같은 최적화 문제의 에뮬레이팅 가능한 규모가 제한된다. 따라서 기존의 하드웨어 가속 방식은 자원이 희소한 임베디드 장치에서의 양자 컴퓨팅 유닛 에뮬레이션에는 적합하지 않다.
%
%따라서 임베디드 디바이스 상에서 QAOA를 효과적으로 에뮬레이션하려면 하드웨어 자원을 절약할 수 있는 새로운 접근이 필요하다. 본 연구에서는 QAOA의 대표적인 적용 사례인 Weighted-MaxCut 문제를 대상으로, 해당 연산식을 하드웨어에 최적화된 형태로 수정하였다. 재구성된 연산식을 기반으로 하드웨어 연산 유닛을 파이프라인 상에 배치해 하드웨어의 부담이 큰 곱연산의 병렬화를 억제함으로써 에뮬레이터의 연산에 필요한 하드웨어 자원을 절감하였다. 이 구조를 바탕으로 하드웨어 가속기 및 이를 집적한 시스템 온 칩(SoC) 아키텍처를 설계하고, QAOA 에뮬레이터의 실행 시간과 자원 점유량 측면에서의 개선 효과를 확인하였다. 




%\begin{comment}
%QAOA는 combinatorial optimization problem에 대한 근사해를 구하는 하이브리드 양자-고전 알고리즘이다.
%
%combinatorial optimization problem에 대해 QAOA가 고전 알고리즘에 대해 우위를 점할 수 있다는 기대로, 이에 대한 관심이 높아지고 있다.
%
%이에 따라 QAOA를 효과적으로 수행하기 위한 알고리즘에 대한 연구가 활발히 진행 중이다.
%
%QAOA를 실행하고 평가하기 위해서는 실제 양자 컴퓨터의 출력을 필요로 한다.
%
%그런데 현재 양자 컴퓨터는 매우 비싸고 접근하기 어려운 자원이다.
%
%따라서 실제 양자 컴퓨터를 이용하여 QAOA 알고리즘을 평가하는 것은 현실적이지 못하다.
%
%행렬-벡터 곱을 기반으로 동작하는 기존의 소프트웨어 기반 양자 컴퓨터 시뮬레이터는 양자역학을 지배하는 중첩이라는 특성에 의해 큐비트의 수에 따라 지수적으로 
%증가하는 컴퓨팅 파워를 감당할 수 없다.
%
%이를 극복하기 위해 FPGA 등의 하드웨어 연산 자원을 병렬적으로 구성해 양자 컴퓨터의 natural parallelism을 범용적으로 모방하려는 시도가 있었지만, 하드웨어 자원의 
%한계 때문에 제한된 큐비트 수의 양자 컴퓨팅 시스템만을 에뮬레이팅할 수 있다.
%
%따라서 QAOA를 효과적으로 에뮬레이팅하기 위해서는 QAOA를 구성하는 단위 연산의 특성을 이용해 지수적으로 증가하는 연산 요구량을 알고리즘적으로 절감하고, 
%이를 병렬화된 연산 모듈을 이용해 처리하는 등, 소프트웨어와 하드웨어 양 측면에서 연산을 최적화하는 것이 필요하다.
%
%본 연구에서는 QAOA를 이용하는 주요 문제인 MaxCut 문제에 대해 이의 연산식을 하드웨어에 최적화된 형태로 수정하고, 이에 대한 하드웨어 가속기 및 이를 포함하는 
%SoC architecture를 설계하였다.
%
%파라미터 최적화 알고리즘을 사용자가 정의할 수 있게끔 프레임워크를 구성해 보다 효과적인 알고리즘 연구 및 평가에 활용할 수 있다.
%
%
%최근 양자 컴퓨터를 이용해 고전 컴퓨터로 해결이 어려운 문제를 해결하고자 하는 시도가 증가하고 있다. 
%그중 QAOA는 양자 컴퓨터를 활용하여 조합 최적화 문제에 대해 근사해를 찾는 효과적인 방법이다.
%QAOA의 대표적인 문제인 maxcut은 많은 문제에 널리 쓰이는 방식이다. \delete{레퍼런스}
%특히 엣지 디바이스에서 maxcut 문제를 해결하려는 수요가 있다. \delete{레퍼런스}
%양자 컴퓨터 분야가 발전함에 따라, 이러한 용도에서 QAOA를 담당하는 양자 컴퓨팅 유닛을 집적하여 성능을 높이는 방식이 효과적일 것으로 보인다.
%하지만 현재 양자 컴퓨터 기술 수준에서 이러한 하드웨어 구조를 설계하는 데에 어려움이 있으며, 따라서 이 위에서 작동하는 어플리케이션을 개발하고 성능을 평가하는 데에는 제약이 있다.
%이러한 문제를 해결하기 위해 양자 컴퓨터의 동작을 모방하는 에뮬레이터의 사용을 고려할 수 있다. 하지만 양자 컴퓨터의 중첩, 얽힘 특성을 고전 컴퓨터에서 모방하는 일은, 큐비트 수가 증가함에 따라 기하급수적으로 증가하는 연산량 및 실행시간을 요구한다. 이는 특히 연산 성능이 제약적인 embedded device에서 큰 문제이다.
%FPGA의 하드웨어 자원을 병렬적으로 구성하여 설계한 가속기를 utilize하여 이러한 문제를 극복하고자 하는 시도가 있다. \delete{레퍼런스} 하지만 이것들 또한 증가하는 큐비트 수에 따라 하드웨어 자원량도 급격히 증가한다. 이는 에뮬레이터가 QAOA를 실행하여 해결할 수 있는 MaxCut 문제의 규모에 제약을 가하며, 특히 embedded device를 위한 양자 컴퓨팅 유닛의 에뮬레이팅에 적합하지 않다.
%따라서 embedded device 상에서 효과적으로 QAOA를 에뮬레이팅하기 위해서는 하드웨어 자원을 절감하는 방법이 필요하다. 본 연구에서는 QAOA의 대표적인 적용 사례인 MaxCut 문제를 대상으로, 이 문제의 연산식을 하드웨어에 최적화된 형태로 수정하여 제시한다. 더불어, 이를 기반으로 한 하드웨어 가속기 및 SoC(System on Chip) 아키텍처를 설계하였고 실행 시간 및 자원 점유량 측면에서 개선을 확인하였다. 
%
%
%
%최근 양자 컴퓨팅을 활용하여 성능을 극대화하려는 시도가 증가하고 있다. 그 중에서도 양자-고전 하이브리드 알고리즘인 QAOA(Quantum Approximate Optimization Algorithm)는 조합 최적화 문제에 대한 근사해를 찾는 데 유망한 방법으로 주목받고 있다.
%
%QAOA의 가장 큰 장점은 특정 조합 최적화 문제에 대해 고전 알고리즘보다 우수한 성능을 보일 가능성이 있다는 점에서 기인한다. 이는 많은 연구자들로 하여금 QAOA의 활용 가능성을 탐구하게 만들었으며, QAOA를 효과적으로 수행하기 위한 다양한 알고리즘적 접근들이 활발히 연구되고 있다. QAOA의 효과적인 평가를 위해서는 실제 양자 컴퓨터에서의 출력이 필수적이다. 그러나 현재 양자 컴퓨터는 매우 고가이며, 접근이 어려운 자원으로 제한되어 있다. 이에 따라 실제 양자 컴퓨터를 이용한 QAOA 알고리즘의 평가가 현실적으로 어려운 실정이다.
%
%이러한 제한을 해결하기 위해, 소프트웨어 기반의 양자 컴퓨터 시뮬레이터가 사용되었으나, 이들 시뮬레이터는 양자역학의 중첩 원리에 따라 큐비트 수가 증가할수록 지수적으로 증가하는 컴퓨팅 파워를 요구한다. 결과적으로, 기존의 행렬-벡터 곱을 기반으로 하는 시뮬레이터는 큐비트 수가 증가함에 따라 급격히 성능 저하를 겪게 된다. 이를 극복하기 위해 FPGA 등의 하드웨어 연산 자원을 병렬적으로 구성하여 양자 컴퓨터의 자연스러운 병렬성을 모방하려는 시도들이 있었다. 하지만 이러한 하드웨어 기반 접근 역시 자원 제약으로 인해 제한된 수의 큐비트만을 에뮬레이션할 수 있었다.
%
%따라서 QAOA를 효과적으로 에뮬레이팅하기 위해서는 QAOA를 구성하는 단위 연산의 특성을 최대한 활용하여 지수적으로 증가하는 연산 요구량을 알고리즘적으로 절감하는 것이 중요하다. 또한, 병렬화된 연산 모듈을 통해 연산을 최적화하고, 하드웨어 자원을 효율적으로 사용할 수 있는 접근이 요구된다. 이를 통해 소프트웨어와 하드웨어 양 측면에서 QAOA 수행의 효율성을 높이는 것이 가능하다.
%
%본 연구에서는 QAOA의 대표적인 적용 사례인 MaxCut 문제를 대상으로, 이 문제의 연산식을 하드웨어에 최적화된 형태로 수정하여 제시한다. 더불어, 이를 기반으로 한 하드웨어 가속기 및 SoC(System on Chip) 아키텍처를 설계하였다. 이러한 접근을 통해 기존의 한계를 극복하고, 보다 많은 수의 큐비트와 복잡한 문제를 효과적으로 처리할 수 있는 환경을 제공하고자 한다. 또한, 본 연구에서는 사용자가 파라미터 최적화 알고리즘을 정의할 수 있는 프레임워크를 설계하여, QAOA의 연구 및 평가에 있어 보다 유연한 실험 환경을 제공한다. 이를 통해 연구자들이 다양한 최적화 기법을 보다 쉽게 적용하고, QAOA의 성능을 정밀하게 분석할 수 있는 기반을 마련하였다.
%
%\end{comment}

\begin{figure}
%%\vskip -2pt
	\centering
	\includegraphics[width=0.49\textwidth]{./figure/qaoa/qaoa_overall1.pdf}
	\caption{Overall schematic of the QAOA process.}
	\label{fig:qaoa}
%%\vskip -6pt
\end{figure}

\section{QAOA for Weighted-MaxCut: Preliminaries}
%This section provides preliminaries on QAOA and its application to the Weighted-MaxCut problem.

\subsection{Quantum Approximate Optimization Algorithm} 
%QAOA의 연산은 그림 \ref{fig:qaoa}에서 보인 바와 같이 비용 ansatz 연산 $U_{C}(\gamma{}_{k})$과 믹스 ansatz 연산 $U_{M}(\beta{}_{k})$의 쌍으로 구성된다. 깊이 $p$의 QAOA 회로에서 $k (k\leq{}p)$번째 layer의 두 ansatz 연산은 QAOA 회로의 파라미터 $\gamma{}_{k}$, $\beta{}_{k}$에 의해 각각 조정되며 다음과 같이 나타난다:
%
%이때 $\hat{H}_{C}$는 주어진 최적화 문제 비용 함수를 나타내는 비용 해밀토니안이고, $\hat{H}_{M}$은 양자 상태의 중첩을 유도하여 탐색 공간을 넓히는 믹스 해밀토니안이다.
%
%QAOA 회로는 \ref{eq:ansatz_op_pair}에서 정의된 ansatz 연산 쌍을 가지고, 초기 양자 상태 $\vert{}s\rangle{} = H^{\otimes n} \vert{}0\rangle{}^{\otimes n}$에 대해  $k$를 순차적으로 증가시키며 총 $p$번의 ansatz 연산을 수행한다. 이때 $2p$개의 variational parameter $\boldsymbol{\gamma{}} = (\gamma{}_{1}, \ldots, \gamma{}_{p})$, $\boldsymbol{\beta{}} = (\beta{}_{1}, \ldots, \beta{}_{p})$가 정의되어 각 ansatz의 연산을 조정한다. ansatz 연산이 완료된 이후의 ansatz state $\vert{}\psi{}_{p}(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}})\rangle{}$는 다음 식과 같이 나타낼 수 있다.

As shown in \refFigure{fig:qaoa}, the operations in QAOA consist of a pair of \textit{ansatz} operators: the cost ansatz operator $U_{C}(\gamma_{k})$ and the mixer ansatz operator $U_{M}(\beta_{k})$. 
In a QAOA circuit of depth $p$, the two ansatz operators in the $k^{\text{th}}$ layer $(k \leq p)$ are adjusted by the parameters $\gamma_{k}$ and $\beta_{k}$ of the QAOA circuit, as represented by the following equations~\cite{Farhi:arXiv14}:
\begin{equation}\label{eq:ansatz_op_pair}
%\footnotesize
    U_{C}(\gamma{}_{k}) = e^{-i \gamma{}_{k} \hat{H}_{C}}, \quad{} U_{M}(\beta{}_{k}) = e^{-i \beta{}_{k} \hat{H}_{M}},
\end{equation}
\normalsize
where $\hat{H}_{C}$ denotes the cost Hamiltonian representing the cost function of the optimization problem, and $\hat{H}_{M}$ is the mixer Hamiltonian that induces superposition in quantum states, thereby expanding the search space.

The QAOA circuit sequentially applies the ansatz operator pairs defined in (\ref{eq:ansatz_op_pair}) for each $k$ from $1$ to $p$, on an initial quantum state $\vert s \rangle = H^{\otimes n} \vert 0 \rangle^{\otimes n}$. 
A total of $2p$ variational parameters, $\boldsymbol{\gamma} = (\gamma_{1}, \ldots, \gamma_{p})$ and $\boldsymbol{\beta} = (\beta_{1}, \ldots, \beta_{p})$, are used to tune the operations of each ansatz.




After completing the $p$ layers of ansatz operations, the resulting ansatz state $\vert \psi_{p}(\boldsymbol{\gamma}, \boldsymbol{\beta}) \rangle$ is expressed as follows:
\begin{equation}
%\footnotesize
    \vert{}\psi{}_{p}(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}})\rangle{} = e^{-i \beta{}_{p} \hat{H}_{M}} e^{-i \gamma{}_{p} \hat{H}_{C}} \ldots e^{-i \beta{}_{1} \hat{H}_{M}} e^{-i \gamma{}_{1} \hat{H}_{C}} \vert{}s\rangle{}.
\end{equation}
\normalsize
To ensure that the ansatz state obtained through this operation yields a solution close to the optimal, it is essential to find the optimal set of parameters $(\boldsymbol{\gamma}, \boldsymbol{\beta})$. 
For this purpose, on the classical computing side, the ansatz state output by the quantum computer is repeatedly measured, and the expectation value $F_{p}(\boldsymbol{\gamma}, \boldsymbol{\beta})$ of the cost Hamiltonian $\hat{H}_{C}$ is computed. 
This expectation value, corresponding to the cost function of the given problem, can be expressed in both quantum mechanical and probabilistic representations as follows:
%위 식의 연산을 통해 얻은 ansatz state가 최적에 가까운 해를 갖도록 하기 위해서는 파라미터 셋 $(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}})$의 최적값을 찾아야 한다. 이를 위해서 고전 컴퓨터 측면에서는 양자 컴퓨터에서 출력하는 ansatz state를 반복적으로 측정하면서 이에 대한 비용 해밀토니안 $\hat{H}_{C}$의 기댓값 $F_{p}(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}})$을 계산한다.  주어진 문제의 비용 함수에 대응되는 이 기댓값은 다음과 같이 양자역학적 표현과 확률적 표현으로 구할 수 있다:
\begin{equation}\label{eq:expect_prob}
    F_{p}(\boldsymbol{\gamma}, \boldsymbol{\beta}) = \langle \psi_{p}(\boldsymbol{\gamma}, \boldsymbol{\beta}) \vert \hat{H}_{C} \vert \psi_{p}(\boldsymbol{\gamma}, \boldsymbol{\beta}) \rangle = \sum\nolimits_{x} p(x) C(x)
\end{equation}
%\begin{equation}\label{eq:expect_theoretical}
%%\footnotesize
%    F_{p}(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}}) = \langle{}\psi{}_{p}(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}})\vert{} \hat{H}_{C} \vert{}\psi{}_{p}(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}})\rangle{},
%\end{equation}
%\begin{equation}\label{eq:expect_prob}
%%\footnotesize
%    F_{p}(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}}) = \sum\nolimits_{x} p(x) C(x), 
%\normalsize
%\end{equation}
where $p(x)$ denotes the probability of observing solution $x$ in measurement samples of the ansatz state. 
On the classical computer, an optimization algorithm is employed to maximize the expectation value obtained from (\ref{eq:expect_prob}), thereby finding the parameter set $(\boldsymbol{\gamma}, \boldsymbol{\beta})$ that maximizes this expectation value. On the quantum computer, the QAOA algorithm is re-executed based on the updated parameter set, iteratively optimizing the ansatz state to gradually converge towards the optimal solution.
%이때 $p(x)$는 ansatz state에 대한 측정 샘플에서 해 $x$를 나타내는 양자 상태의 비율을 나타낸다. 고전 컴서는 기댓값을 최대화하는 파라미터 셋 $(\boldsymbol{\gamma{}}, \boldsymbol{\beta{}})$을 찾아내기 위해, 식 \ref{eq:expect_prob}를 통해 얻은 기댓값을 최대화하는 최적화 알고리즘을 실행한다. 양자 컴퓨터에서는 이와 같이 수정된 파라미터 셋을 기반으로 QAOA 알고리즘을 다시 실행하여 최적화하는 과정이 반복된다. 이로써 ansatz state는 점진적으로 최적해에 수렴한다.

\subsection{Weighted-MaxCut Problem}

\begin{figure}
%%\vskip -2pt
	\centering
	\includegraphics[width=0.45\textwidth]{./figure/qaoa/maxcut1.pdf}
	\caption{Example of a Weighted-MaxCut problem with 6 vertices and 11 edges (weights omitted for simplicity).}
	\label{fig:maxcut}
%\vskip -6pt
\end{figure}

%The Weighted-MaxCut problem involves finding a partition of a graph with given vertices, edges, and weights assigned to each edge, such that the weighted sum of the edges in the cut is maximized. 
%Figure 2 illustrates a graphical representation of a Weighted-MaxCut problem, where the partition shown on the right maximizes the number of cut edges or their total weight, as defined by the problem on the left.
%In the two complementary subsets formed by the partition, each vertex $x_{i}$ in the $i$-th position can be labeled as 0 or 1 depending on the subset it belongs to. 
%Thus, for a vertex set of size $\vert V \vert$, any partition can be represented as a bit string $\mathbf{x} = x_{1} x_{2} \ldots x_{\vert V \vert}$. 
%By defining a cost function $C(\mathbf{x})$ that takes $\mathbf{x}$ as input and represents the weight sum of the cut defined by $\mathbf{x}$, the Weighted-MaxCut problem can be formulated as the task of finding the bit string $\mathbf{x}$ that maximizes the cost function $C(\mathbf{x})$. 
%The cost function $C(\mathbf{x})$ for the Weighted-MaxCut problem is given by:
The Weighted-MaxCut problem involves partitioning a graph with given vertices, edges, and edge weights in a way that maximizes the total weight of the edges crossing the partition.
\refFigure{fig:maxcut} presents a graphical representation of a Weighted-MaxCut problem, where the partition shown on the right maximizes the number of cut edges or their total weight, as defined by the problem on the left.
More specifically, each vertex $x_i$ in the $i$-th position belongs to one of the two subsets formed by the partition and can be labeled as 0 or 1 accordingly.
Thus, for a vertex set of size $\vert V \vert$, any partition can be represented as a bit string $\mathbf{x} = x_{1} x_{2} \ldots x_{\vert V \vert}$.
By defining a cost function $C(\mathbf{x})$ that takes $\mathbf{x}$ as input and represents the total weight of the cut, the Weighted-MaxCut problem can be formulated as the task of finding the bit string $\mathbf{x}$ that maximizes $C(\mathbf{x})$.
The cost function $C(\mathbf{x})$ for the Weighted-MaxCut problem is given by:
%Weighted-MaxCut 문제는 주어진 정점(vertices)과 간선(edges), 그리고 각 간선에 대한 가중치(weight)로 이루어진 그래프에 대해, 간선에 대한 cut의 가중치 합이 최대가 되는 분할(partition)을 구하는 문제이다. 분할에 의해 형성된 두 complementary subset에서 $i$번째 정점 $x{}_{i}$가 속한 subset에 따라 이를 0 또는 1로 라벨링할 수 있다. 따라서 정점 집합의 크기 $\vert{}V\vert{}$에 대해 임의의 분할은 비트열 $\mathbf{x} = x{}_{1} x{}_{2} \ldots x{}_{\vert{}V\vert{}}$로 나타낼 수 있으며, $\mathbf{x}$를 입력으로 받는 비용 함수 $C(\mathbf{x})$를 $\mathbf{x}$에 의해 정의된 분할의 cut의 weight 합으로 정의하면, Weighted-MaxCut 문제는 위에서 정의한 비용 함수 $C(\mathbf{x})$를 최대화하는 $\mathbf{x}$를 찾는 문제로 정의된다.Weighted-MaxCut 문제의 비용 함수 $C(\mathbf{x})$는 다음과 같다:
\begin{equation}
%\footnotesize
    C(\mathbf{x}) = \sum_{i, j = 1}^{\vert{}V\vert{}} \omega{}_{ij} x{}_{i} (1 - x{}_{j}).
\end{equation}
If the $i$-th and $j$-th vertices belong to the same subset, then $(x_{i}, x_{j}) = (0,0)$ or $(1,1)$, resulting in $x_{i} (1 - x_{j}) = 0$. 
Consequently, the edge connecting these two vertices does not affect the value of the cost function. 
In contrast, if the two vertices are in different subsets ($(x_{i}, x_{j}) = (0,1)$ or $(1,0)$), then $x_{i} (1 - x_{j})$ is nonzero, and this edge contributes to the cost function.
%$i$, $j$번째 정점이 같은 subset에 있다면 $(x{}_{i}, x{}_{j}) = (0,0)$ 또는 $(1,1)$이므로 $x{}_{i} (1 - x{}_{j}) = 0$이다. 따라서 두 정점을 잇는 간선은 비용 함수의 값에 영향을 주지 못한다. 반면, 두 정점이 다른 subset에 있다면 ($(x{}_{i}로, x{}_{j}) = (0,1)$ 또는 $(1,0)$) $(x{}_{i}, x{}_{j}) = (1,0)$이므로 $x{}_{i} (1 - x{}_{j})$가 nonzero 값을 가지고, 이 간선은 비용 함수에 기여하게 된다.

To solve the Weighted-MaxCut problem using QAOA, the cost Hamiltonian and mixer Hamiltonian must be defined. 
For the set of edges $E$ contributing to the cost function, the two Hamiltonians for the Weighted-MaxCut problem are defined as follows:
%Weighted-MaxCut 문제를 QAOA를 이용해 해결하기 위해서는 비용 해밀토니안과 믹스 해밀토니안을 각각 정의해야 한다. 비용 함수에 기여하는 간선의 집합 $E$에 대해 Weighted-MaxCut 문제의 두 해밀토니안은 다음 식과 같다:

\begin{equation}\label{eq:cost_hamiltonian}
%\footnotesize
    \hat{H}_{C} = \frac{1}{2} \sum_{(i,j) \in E} \omega{}_{ij} (I - Z_{i} Z_{j}),~~\hat{H}_{M} = \sum_{j \in V} X_{j},
\end{equation}
%\begin{equation}\label{eq:mix_hamiltonian}
%%\footnotesize
%    H{}_{M} = \sum_{j \in V} X{}_{j}
%\end{equation}
%이때 $Z{}_{i}$는 $i$번째 큐빗에 대한 파울리-Z 게이트 연산이다. 식 \ref{eq:cost_hamiltonian}의 부분합 요소 $Z{}_{i}Z{}_{j}$의 $l$번째 대각 성분 $Z{}_{i}Z{}_{j}(l,l)$은 다음과 같이 나타낼 수 있다:
where $Z_{i}$ is the Pauli-Z gate operation on the $i$-th qubit, and the $l$-th diagonal element $Z_{i}Z_{j}(l,l)$ of the term $Z_{i} Z_{j}$ can be expressed as:
\begin{equation}\label{eq:ZiZj_diag}
%\footnotesize
    Z_{i}Z_{j}(l,l) = \begin{cases}
    1 & \text{if the $l$-th bits of $i$ and $j$ are different} \\
    -1 & \text{if the $l$-th bits of $i$ and $j$ are the same}
    \end{cases}
\end{equation}

To utilize the Hamiltonians constructed for the Weighted-MaxCut problem within the QAOA circuit, they must be transformed into unitary quantum gates. For a circuit depth of $p$, the cost unitary and mixer unitary operations in the $k$-th layer $(k \leq p)$ for the Weighted-MaxCut problem can be derived as follows:
%위에서 Weighted-MaxCut 문제에 대해 구성한 해밀토니안을 QAOA 회로에서 활용하기 위해서는 유니터리 양자 게이트로 변환해야 한다. 회로의 깊이를 $p$라 할 때, weighted-MaxCut 문제에 대한 $k (\leq p)$번째 레이어의 비용 유니터리와 믹스 유니터리 연산은 다음과 같이 정의된다:
\begin{equation}\label{eq:cost_unitary}
%\footnotesize
    U_{C}(\gamma_{k}) = e^{-i \gamma_{k} \hat{H}_{C}} = \prod_{i=1,j<i}^{n} R_{Z_{i} Z_{j}}(-2 \omega_{ij} \gamma_{k}).
\end{equation}
\begin{equation}\label{eq:mix_unitary}
%\footnotesize
    U_{M}(\beta_{k}) = e^{-i \beta_{k} \hat{H}_{M}} = \prod_{i=1}^{n} R_{X_{i}}(2 \beta_{k}).
\end{equation}





\section{Optimization Strategies for the QAOA Emulator}

To emulate QAOA, it is necessary to repeatedly multiply the unitary matrices representing the ansatz operations, $U_{C}(\gamma_{k})$ and $U_{M}(\beta_{k})$, with the vector representing the initial state. 
However, for emulating $n$-qubit QAOA, the multiplication of the $N \times N$ matrix and $N \times 1$ vector (where $N=2^n$, the state space dimension) requires registers and computing power that scale with $O(N^2)$ ($=O(2^{2n})$) as $n$ increases, leading to an exponential growth in resource demands. 
Therefore, to efficiently emulate QAOA within the limited hardware resources of an SoC, it is essential to modify the matrix representation of QAOA in a hardware-friendly manner and accelerate the modified matrix operations by leveraging hardware characteristics. 
In this study, we decompose the matrix representation of the mixer ansatz operation $U_{M}(\beta_{k})$ for the Weighted-MaxCut problem, structuring the entire ansatz operation into hardware-optimized elemental operations. 
Furthermore, a pipelined structure is employed for these elemental operations to reduce the hardware resource demands associated with parallelizing multiplication operations.

%QAOA를 에뮬레이션하려면 초기 상태를 나타내는 벡터에 대해 ansatz 연산을 나타내는 유니터리 행렬 $ U{}_{C}(\gamma{}_{k})$, $U{}_{M}(\beta{}_{k})$을 반복적으로 곱하는 연산이 필요하다. 하지만 $n$ 큐빗 QAOA를 에뮬레이팅하기 위해 필요한 $N \times N$ 행렬과 $N \times 1$ 벡터($N=2^n$)의 곱 연산은 일반적인 경우 $n$이 증가함에 따라 소모하는 레지스터와 컴퓨팅 파워가 $O(N^2)$ ($=O(2^{2n})$)으로 급격하게 증가한다. 따라서 SoC의 제한된 하드웨어 자원으로 QAOA를 효율적으로 에뮬레이션하기 위해서는 QAOA의 행렬식을 하드웨어 친화적인 방식으로 수정하고, 수정된 행렬 연산을 하드웨어의 특성을 이용하여 가속하는 것이 필요하다. 본 연구에서는 Weighted-MaxCut 문제에 대한 QAOA의 믹스 ansatz 연산  $U{}_{M}(\beta{}_{k})$의 행렬식을 분해하여 전체 ansatz 연산을 하드웨어에 최적화된 단위 연산으로 구성하고, 이 단위 연산에 대해 파이프라인 구조를 적용하여 하드웨어에 부담이 큰 곱 연산의 병렬화를 최소화하였다.


\subsection{Decomposing the Mixer Unitary}\label{sec:decomp_mix_unitary}

The matrix representation of the Pauli-X rotation gate $R_{X}(2\beta_{k})$, which defines the mixer ansatz in (\ref{eq:mix_unitary}), is given by
%(\ref{eq:mix_unitary})에서 믹스 ansatz를 정의하는 파울리-X 회전 게이트 $R_{X}(2\beta{}_{k})$의 행렬식은 다음과 같이 표현된다.

\begin{equation}
\begin{aligned}
    R_{X}(2\beta_{k}) &= e^{-i\beta_{k} X} = \cos(\beta_{k}) I - i \sin(\beta_{k}) X \\
    &= \begin{bmatrix}
    \cos(\beta_{k}) & -i\sin(\beta_{k}) \\
    -i\sin(\beta_{k}) & \cos(\beta_{k})
    \end{bmatrix}.
\end{aligned}
\end{equation}
In this equation, both the identity matrix $I$ and the Pauli matrix $X$ have the vectors $\mathbf{v_{1}} = \begin{bmatrix} 1 & 1 \end{bmatrix}^{T}$ and $\mathbf{v_{2}} = \begin{bmatrix} 1 & -1 \end{bmatrix}^{T}$ as eigenvectors. 
Therefore, $R_{X}(2\beta_{k})$ also has $\mathbf{v_{1}}$ and $\mathbf{v_{2}}$ as eigenvectors, with eigenvalues determined as follows:
%이 식에서 항등 행렬 $I$와 파울리 행렬 $X$는 모두 $ \mathbf{v_{1}} = \begin{bmatrix} 1 & 1 \end{bmatrix}^{T}$, $ \mathbf{v_{2}} = \begin{bmatrix} 1 & -1 \end{bmatrix}^{T}$를 고유벡터로 가지므로 $R_{X}(2\beta{}_{k})$ 또한 $ \mathbf{v_{1}}$, $ \mathbf{v_{2}}$를 고유벡터로 가지며, 고유값은 다음과 같이 구해진다.
\begin{equation}\notag{}
%\footnotesize
    R_{X}(2\beta{}_{k})  \mathbf{v_{1}} = \begin{bmatrix}
    \cos(\beta{}_{k}) & -i\sin(\beta{}_{k}) \\
    -i\sin(\beta{}_{k}) & \cos(\beta{}_{k})
    \end{bmatrix}
     \begin{bmatrix} 1 \\ 1 \end{bmatrix} \qquad{} \qquad{}\qquad{}
\end{equation}
\begin{equation}
%\footnotesize
    \qquad{}= (\cos(\beta{}_{k}) - i \sin(\beta{}_{k})) \begin{bmatrix} 1 \\ 1 \end{bmatrix}
    = e^{-i\beta{}_{k}}  \mathbf{v_{1}} = \lambda{}_{1}  \mathbf{v_{1}},
\end{equation}
\begin{equation}\notag{}
%\footnotesize
    R_{X}(2\beta{}_{k})  \mathbf{v_{2}} = \begin{bmatrix}
    \cos(\beta{}_{k}) & -i\sin(\beta{}_{k}) \\
    -i\sin(\beta{}_{k}) & \cos(\beta{}_{k})
    \end{bmatrix}
    \begin{bmatrix} 1 \\ -1 \end{bmatrix} \qquad{}\qquad{}\qquad{}
\end{equation}
\begin{equation}
%\footnotesize
   \qquad{} = (\cos(\beta{}_{k}) + i \sin(\beta{}_{k})) \begin{bmatrix} 1 \\ -1 \end{bmatrix}
    = e^{i\beta{}_{k}} \mathbf{v_{2}} = \lambda{}_{2} \mathbf{v_{2}},
\end{equation}
where $\lambda_{1} = e^{-i\beta_{k}}$ and $\lambda_{2} = e^{i\beta_{k}}$. 
Thus, the eigenvalue decomposition of $R_{X}(2\beta_{k})$ is as follows:
%where, $\lambda{}_{1} = e^{-i\beta{}_{k}}$, $\lambda{}_{2} = e^{i\beta{}_{k}}$. 따라서 $R_{X}(2\beta{}_{k})$에 대한 고유값 분해는 다음과 같다:
\begin{equation}\label{eq:hadamard_rx_diag}
    R_{X}(2\beta{}_{k}) = \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}
    \begin{bmatrix} e^{-i\beta{}_{k}} & 0 \\ 0 & e^{i\beta{}_{k}} \end{bmatrix}
    \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}^{-1}
    = H \Lambda{}_{M} H,
\end{equation}
%\begin{equation}\label{eq:hadamard_rx_diag}
%%\footnotesize
%    \text{where} \quad{} H = \frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}, ~\text{and} ~~\Lambda{}_{M} = \begin{bmatrix} e^{-i\beta{}_{k}} & 0 \\ 0 & e^{i\beta{}_{k}} \end{bmatrix}.
%\end{equation}
where $H$ is the Hadamard matrix, and $\Lambda_{M}$ is the diagonal matrix containing the eigenvalues of $R_{X}(2\beta_{k})$ as its diagonal elements.
%여기서 $H$는 하다마드 행렬로 $\frac{1}{\sqrt{2}} \begin{bmatrix} 1 & 1 \\ 1 & -1 \end{bmatrix}$이고, $\Lambda{}_{M}$는 $R_{X}(2\beta{}_{k})$의 고유값을 대각 성분으로 가지는 대각 행렬로 $\begin{bmatrix} e^{-i\beta{}_{k}} & 0 \\ 0 & e^{i\beta{}_{k}} \end{bmatrix}$이다.

It can be seen that $U_{M}(\beta_{k})$ in (\ref{eq:mix_unitary}) represents an operation that applies the $R_{X}(2\beta_{k})$ operation simultaneously to $n$ qubits. 
Therefore, $U_{M}(\beta_{k})$ can be expressed as the tensor product of the $R_{X}(2\beta_{k})$ matrices as follows:
%(\ref{eq:mix_unitary})의 $U_{M}(\beta{}_{k})$는 $R_{X}(2\beta{}_{k})$ 연산을 $n$ 큐빗에 동시에 진행하는 연산임을 알 수 있다. 따라서 $U_{M}(\beta{}_{k})$는 다음과 같이 $R_{X}(2\beta{}_{k})$의 행렬의 텐서 곱으로 나타낼 수 있다.
\begin{equation}\label{eq:mix_eigen_diag}
%\footnotesize
    U_{M}(\beta{}_{k}) = R_{X}(2\beta{}_{k})^{\otimes n} = (H \Lambda{}_{M} H)^{\otimes n} = H^{\otimes n} D_{M} H^{\otimes n},
\end{equation}
where $D_{M}$ is the diagonal matrix representing the mixer ansatz and is given by $\Lambda_{M}^{\otimes n}$.
%where $D_{M}$ 은 믹스 ansatz를 나타내는 대각 행렬로 \Lambda{}_{M}^{\otimes{n}$와 같다.

In addition, in (\ref{eq:cost_hamiltonian}), the cost Hamiltonian $\hat{H}_{C}$ for the Weighted-MaxCut problem is a diagonal matrix, as it is the partial sum of diagonal matrices $I$ and $Z_{i} Z_{j}$. 
Consequently, the matrix exponential $U_{C}(\gamma_{k})$ in (\ref{eq:cost_unitary}), which has $\hat{H}_{C}$ as its exponent, is also a diagonal matrix. 
Defining the diagonal matrix representing the cost ansatz as $D_{C}$, i.e., $D_{C} = U_{C}(\gamma_{k})$, the ansatz operation performed in the $k$-th layer can be expressed as follows:
%또한 (\ref{eq:cost_hamiltonian})에서 Weighted-MaxCut 문제의 비용 해밀토니안 $\hat{H}_{C}$는 대각 행렬 $Z{}_{i} Z{}_{j}$의 부분합이므로 $\hat{H}_{C}$ 역시 대각 행렬이다. 따라서 이를 지수로 갖는 행렬 지수 함수로서 (\ref{eq:cost_unitary})의 $U_{C}(\gamma{}_{k})$ 또한 대각 행렬이다. 
%비용 ansatz를 나타내는 대각 행렬을 $D_{C}$로 정의하면, i.e., $D_{C}=U_{C}(\gamma{}_{k})$, $k$번째 레이어에서 수행하는 ansatz 연산은 다음과 같이 나타낼 수 있다.
\begin{equation}\label{eq:unit_ansatz_op}
%\footnotesize
    U_{M}(\beta{}_{k}) U_{C}(\gamma{}_{k}) = (H^{\otimes n} D_{M})(H^{\otimes n} D_{C}).
\end{equation}
In this equation, the ansatz operation for a single layer consists of an elemental ansatz operation ($U_{A} = H^{\otimes n} D$), which is the product of a diagonal matrix and the Hadamard matrix, applied separately for the cost and mixer operations. 
Therefore, by computing the values of the diagonal matrices $D_{M}$ and $D_{C}$ for all layers, the ansatz state can be obtained by iteratively applying these operations to the initial quantum state $\vert s \rangle$. 
Importantly, note that the computational cost for the diagonal matrix operations in this decomposed form is $O(N)$, which is significantly lower than the $O(N^{2})$ required for the original matrix-vector multiplication.
%이 식에서 단일 레이어의 ansatz 연산은 대각 행렬과 하다마드 행렬의 곱으로 이루어진 단위 연산 (Unit Ansatz Operation, $U_{A} = H^{\otimes n} D$)을 비용 및 믹스 연산에 대해 각각 가짐을 알 수 있다. 그러므로 모든 레이어에 대해 대각 행렬 $D_{M}$, $D_{C}$의 값을 각각 구하면, 초기 양자 상태 $\vert{}s\rangle{}$에 대해 이를 반복하여 ansatz state를 구할 수 있다. Importatly note that 이와 같이 분해된 행렬식의 대각 행렬 연산에서 요구하는 연산량은 기존의 matrix-vector 곱 연산의 $O(N^{2})$보다 적은 $O(N)$ 수준이다.

Meanwhile, in (\ref{eq:unit_ansatz_op}), the Hadamard matrix $H^{\otimes n}$ has all elements with an absolute value of $1/\sqrt{2^{n}}$. 
Therefore, by scaling the original Hadamard matrix to construct a modified Hadamard matrix $H_{1}$, in which all elements have an absolute value of 1, the multiplication operations required for the Hadamard transform in the elemental ansatz operation can be reduced. 
The relationship between the two matrices is given as follows:
%한편 식 \ref{eq:unit_ansatz_op}에서 사용하는 하다마드 행렬 $H^{\otimes n}$은 모든 행 요소의 절댓값이 $1/\sqrt{2^{n}}$이다. 따라서 기존의 하다마드 행렬을 스케일링하여 모든 요소의 절댓값이 1인 수정된 하다마드 행렬 $H_{1}$을 구성하면, 단위 연산의 하다마드 변환에 필요한 곱 연산을 절감할 수 있다. 두 행렬의 관계식은 다음과 같다.
\begin{equation}
%\footnotesize
    H_{1} = \frac{1}{\sqrt{2^{n}}} H^{\otimes n}, \quad \text{or} \quad H^{\otimes n} = \sqrt{2^{n}} H_{1}.
\end{equation}
\normalsize
Substituting this into (\ref{eq:unit_ansatz_op}) and simplifying yields the following:
\begin{equation}\label{eq:unit_ansatz_op_scaled}
%    U_{M}(\beta{}_{k}) U_{C}(\gamma{}_{k}) = \left(\frac{1}{\sqrt{2^{n}}} H_{1} D_{M}\right)\left(\frac{1}{\sqrt{2^{n}}} H_{1} D_{C}\right) \qquad{}
    U_{M}(\beta{}_{k}) U_{C}(\gamma{}_{k}) = \frac{1}{2^{n}} (H_{1} D_{M})(H_{1} D_{C}).
\end{equation}
%\begin{equation}\label{eq:unit_ansatz_op_scaled}
%    \qquad{}\qquad{}\qquad{}\qquad{}\qquad{} = \frac{1}{2^{n}} (H_{1} D_{M})(H_{1} D_{C})
%\end{equation}

The modified Hadamard transform can be implemented resource-efficiently by using only parallel addition/subtraction operations on vector components, instead of multiplication and accumulation operations. 
The scaling factor in powers of $2$ in (\ref{eq:unit_ansatz_op_scaled}) can be applied in hardware with simple bit-shift operations.
%이러한 스케일링을 통해 수정된 하다마드 변환은 곱하기 및 누적 연산 대신, 벡터 성분에 대한 병렬 더하기/빼기 연산만을 이용해 자원 효율적으로 구현될 수 있다. 식 \ref{eq:unit_ansatz_op_scaled}에서 $2$의 승수로 나타난 스케일링 연산에는 하드웨어에서 간단하게 구현되는 비트 시프트를 적용할 수 있다.

\subsection{Constructing the Cost and Mixer Ansatz Diagonal Matrices}
As derived in the previous section, the cost Hamiltonian matrix for the MaxCut problem is a diagonal matrix. 
Thus, by leveraging this diagonal property, the diagonal elements of the cost ansatz matrix $D_{C}$ can be derived from the cost Hamiltonian. 
First, using the definition of the matrix exponential and (\ref{eq:cost_unitary}), $D_{C}$ can be expressed as follows:
%이전 section에서 유도한 바와 같이, MaxCut 문제에 대한 비용 해밀토니안 행렬은 대각 행렬이다. 그러므로 이 대각 성질을 이용해서 비용 ansatz를 나타내는 대각 행렬 $D_{C}$의 대각 성분을 비용 해밀토니안으로부터 derive할 수 있다. 
%먼저, 행렬 지수함수의 정의와 (\ref{eq:cost_unitary})를 이용해 $D_{C}$를 다음과 같이 표현할 수 있다:
\begin{equation}\label{eq:diag_cost}
%\footnotesize
%    D_{C} = U_{C}(\gamma{}_{k}) = e^{-i \gamma{}_{k} \hat{H}_{C}} = \sum_{m=0}^{\infty} \frac{(-i \gamma{}_{k} \hat{H}_{C})^{m}}{m!} = \sum_{k=0}^{\infty} \frac{(-i \gamma{}_{k})^{m}}{m!} \hat{H}_{C}^{m}
    D_{C} = U_{C}(\gamma{}_{k}) = e^{-i \gamma{}_{k} \hat{H}_{C}} = \sum_{k=0}^{\infty} \frac{(-i \gamma{}_{k})^{m}}{m!} \hat{H}_{C}^{m}
\end{equation}
%\begin{comment}
%\begin{equation}
%    where \quad{} \hat{H}_{C} = \text{diag}\{\lambda{}_{C,1}, \lambda{}_{C,2}, \ldots, \lambda{}_{C,N}\}
%\end{equation}
%\end{comment}
Since $\hat{H}_{C}$ is a diagonal matrix, the $l$-th diagonal element of its power $\hat{H}_{C}^{m}$, denoted as $\hat{H}_{C}^{m}(l,l)$ for $l = 1, 2, \ldots, n$, can be obtained as follows:
%이때 $\hat{H}_{C}$는 대각 행렬이므로 이 행렬의 거듭제곱 $\hat{H}_{C}^{m}$의 $l$번째 대각 성분 $\hat{H}_{C}^{m}(l,l)$ $(l = 1, 2, \ldots, n)$은 다음과 같이 구해진다.
\begin{equation}
%\footnotesize
    \hat{H}_{C}^{m}(l,l) = (\hat{H}_{C}(l,l))^{m}
\end{equation}
Thus, by generalizing the $l$-th diagonal element $D_{C}(l,l)$, $D_{C}$ can be constructed for a given cost Hamiltonian as follows:
%따라서 $D_{C}$의 $l$번째 대각 성분 $D_{C}(l,l)$을 다음과 같이 일반화하여, 주어진 비용 해밀토니안에 대해 $D_{C}$를 다음과 같이 construct할 수 있다.
%\begin{equation}\notag{}
%    D_{C}(l,l) = \sum_{m=0}^{\infty} \frac{(-i \gamma{}_{k})^{m}}{m!} \hat{H}_{C}^{m}(l,l) = \qquad{}\qquad{}\qquad{}\qquad{}
%\end{equation}
%\begin{equation}
%   \qquad{}\qquad{}\qquad{}\qquad{} \sum_{m=0}^{\infty} \frac{(-i \gamma{}_{k} \hat{H}_{C}(l,l))^{m}}{m!} = e^{-i \gamma{}_{k} \hat{H}_{C}(l,l)}
%\end{equation}
\begin{equation}
  D_{C}(l,l) = \sum_{m=0}^{\infty} \frac{(-i \gamma{}_{k} \hat{H}_{C}(l,l))^{m}}{m!} = e^{-i \gamma{}_{k} \hat{H}_{C}(l,l)}
\end{equation}

Next, we derive a general expression for the $l$-th diagonal element $D_{M}(l,l)$ of the diagonal matrix $D_{M}$ representing the mixer ansatz, for $l = 1, 2, \ldots, n$. 
Using (\ref{eq:hadamard_rx_diag}) and (\ref{eq:mix_eigen_diag}), we know that $D_{M}$ can be represented as the tensor product of the $2 \times 2$ diagonal matrix $\Lambda_{M}$. 
Therefore, each diagonal element of $D_{M}$ is expressed as the successive product of the two diagonal elements of $\Lambda_{M}$, namely $\lambda_{1} = e^{-i\beta_{k}}$ and $\lambda_{2} = e^{i\beta_{k}}$. 
To compute the $l$-th diagonal element of the matrix $D_{M}$, each of the two diagonal elements of $\Lambda_{M}$ is multiplied $n - HW(l-1)$ times and $HW(l-1)$ times, respectively, where $HW(l-1)$ denotes the Hamming weight of $l-1$, which is the number of 1’s in the binary representation of $l-1$. 
Based on this, $D_{M}(l,l)$ can be expressed as follows:
%다음으로, 우리는 믹스 ansatz를 나타내는 대각 행렬 $D_{M}$의 $l$번째 대각 요소 $D_{M}(l,l)$ $(l = 1, 2, \ldots, n)$의 $l$에 대한 일반식을 유도한다. 
%우리는 (\ref{eq:hadamard_rx_diag}), (\ref{eq:mix_eigen_diag})을 통해 $D_{M}$은 $2\times{}2$ 크기의 대각 행렬 $\Lambda{}_{M}$의 텐서곱으로 나타남을 알고 있다. 따라서 $D_{M}$의 각 대각 성분은  $\Lambda{}_{M}$의 두 대각 성분 $\lambda{}_{1} = e^{-i\beta{}_{k}}$, $\lambda{}_{2} = e^{i\beta{}_{k}}$의 연속 곱으로 나타난다. 이때 대각 행렬 $D_{M}$의 $l$번째 대각 요소를 구하기 위해 \Lambda{}_{M}$의 두 대각 성분은, $l-1$의 이진 표현에서 비트 1의 개수 (which is Hamming weight of $l-1$) $HW(l-1)$에 대해 각각 $n-HW(l-1)$번, $HW(l-1)$번 곱해진다. 이를 기반으로 $D_{M}(l,l)$을 다음 식과 같이 표현할 수 있다.
\begin{equation}\label{eq:diag_mix}
    D_{M}(l, l) = \lambda{}_{1}^{n-HW(l-1)} \times{} \lambda{}_{2}^{HW(l-1)} = e^{iu(n,l)\beta{}_{k}},
\end{equation}
%\begin{equation}\label{eq:u}
where $u(n,l) = 2 \cdot HW(l-1) - n$. 
%\end{equation}
%이때 $HW(l-1)$는 $l-1$의 이진 표현에서 비트 1의 개수, 즉 $l-1$의 Hamming weight를 나타내는 함수이다.


\subsection{Pipelining Elemental Ansatz Operations}\label{sec:pipeline_unit_ansatz_op}

\begin{figure}
%\vskip -12pt
	\centering
	\includegraphics[width=0.42\textwidth]{./figure/qaoa/qaoa_pipeline_final.pdf}
	\caption{Operations in the pipeline structure for a single elemental ansatz on a 2-qubit system.}
	\label{fig:pipeline}
%\vskip -10pt
\end{figure}

Through the proposed matrix decomposition and scaling methods, we structured the computations required for the QAOA algorithm emulation for the MaxCut problem into hardware-friendly elemental ansatz operations, and derived general expressions for the diagonal elements of the diagonal matrices $D_{C}$ and $D_{M}$ required for these operations. 
However, to perform the multiplication of the diagonal matrix and vector in parallel within these elemental operations, an exponentially increasing number of multiplications would still be required. 
As is well known, multiplication operations demand significantly more hardware resources and computational power compared to addition operations, so parallelizing these exponentially increasing multiplications places a substantial burden on hardware.
%우리는 앞서 제안한 행렬 분해와 스케일링 방법을 통해 MaxCut 문제를 위한 QAOA 알고리즘 에뮬레이션에 필요한 연산을 하드웨어 친화적인 elemental ansatz 연산으로 구성하였고, 이 연산에 필요한 대각 행렬 $D_{C}, D_{M}$의 대각 성분에 대한 일반식을 유도하였다.
% 그러나, 이 단위 연산 내에서 대각 행렬과 벡터의 곱을 병렬적으로 수행하려면 여전히 지수적으로 증가하는 수준의 곱셈 연산이 필요하게 된다. 일반적으로 잘알려진 바와 같이 곱셈 연산은 덧셈 연산에 비해 더 많은 하드웨어 자원과 연산 능력을 요구하기 때문에, 지수적으로 증가하는 곱셈 연산을 병렬화하는 것은 하드웨어 부담을 크게 증가시킨다. 이에, 우리는 이러한 대각 행렬 연산을 하다마드 행렬 연산과 같은 파이프라인에서 처리함으로써 곱셈 연산의 병렬화를 최소화하고, 하드웨어에 친화적인 에뮬레이션 알고리즘을 구현하였다.

To address this issue, we process these diagonal matrix operations in a pipeline in conjunction with the Hadamard matrix operations, thereby minimizing the parallelization of multiplication operations and implementing a hardware-efficient emulation algorithm. 
\refFigure{fig:pipeline} illustrates the proposed pipeline design.
In the first operation (denoted as \textit{1\textsuperscript{st}.op} in the figure), instead of performing parallel multiplications for all diagonal elements of the matrix $D$ with the quantum state vector $\vert x \rangle$, we perform a single multiplication per clock cycle, focusing on one element at a time. 
This is represented by \textit{\textit{1\_MULT}} in the figure.

The result of the first multiplication operation, $\lambda_{1} x_{1}$, corresponds to the first column element of the modified Hadamard matrix $H_{1}$. 
In the subsequent clock cycle, the \textit{2\textsuperscript{nd}.op} operation adds or subtracts this result to the output vector $\vert \psi \rangle$ based on the column element's sign (either $1$ or $-1$), which is denoted as \textit{N add.} in the figure.
Simultaneously, in \textit{2\textsuperscript{nd}.op} of the same clock cycle, the next multiplication (\textit{1\_MULT}) is performed between the second element of $D$ and $\vert x \rangle$. 
In this pipeline design, each clock cycle within a single elemental ansatz operation executes one multiplication and $N$ additions in parallel. 
This sequence of parallel operations iterates across all $N$ elements of the diagonal matrix and the quantum state vector over a total of $N+1$ clock cycles to compute the ansatz state.

This pipeline architecture significantly reduces the computation time of the QAOA emulator’s matrix operations, decreasing the complexity from $O(N^{2})$ to $O(N)$ through efficient hardware parallelization. 
Additionally, by minimizing the need for parallel multiplications—which demand far more hardware resources than additions—our design mitigates the exponential increase in hardware requirements that typically accompanies larger qubit counts. 
By controlling the number of multiplication operations, we balance the reduction in execution time with manageable hardware resource usage. 
As a result, this optimized pipeline design effectively limits the growth in hardware resource demand, enabling scalable and resource-efficient QAOA emulation for the Weighted-MaxCut problem.

%To address this issue, we process these diagonal matrix operations in a pipeline in conjunction with the Hadamard matrix operations, thereby minimizing the parallelization of multiplication operations and implementing a hardware-efficient emulation algorithm.
%\refFigure{fig:pipeline}는 제안하는 파이프라인의 설계를 보여준다. 
%첫번째 operation(그림에서 \textit{1\textsuperscript{st}.op}로 표기)에서는 양자 상태를 나타내는 벡터 $\vert{}x\rangle{}$의 첫번째 성분에 대해, 주어진 대각 행렬 $D$의 모든 대각 성분을 병렬적으로 곱하는 대신 각 클락 사이클에서 하나의 요소에 대해서만 곱셈을 수행한다. 그림 내 이는  \textit{\textit{1\_MULT}}로 표시되어있다. 
%
%\textit{1\textsuperscript{st}.op} 에서 곱해진 첫 번째 요소 ($\lambda{}_{1}x_{1}$)는 수정된 하다마드 행렬 $H_{1}$의 첫 번째 열의 값에 대응되며, 이후 다음 클락 사이클에서 수행되는 \textit{2\textsuperscript{nd}.op}에서 열의 요소 값(1 또는 -1)에 따라, 연산 결과를 저장하는 벡터 $\vert{}\psi{}\rangle{}$에 더해지거나 빼진다. \refFigure{fig:pipeline}에서 이는 \textit{N add.}로 표시되어있다. 한편 동일한 클락 사이클의 \textit{2\textsuperscript{nd}.op}에서, 앞선 \textit{1\textsuperscript{st}.op}에서의 \textit{\textit{1\_MULT}} 연산이 주어진 양자 상태 벡터 $\vert{}x\rangle{}$와 대각 행렬 $D$의 두 번째 요소에 대해 수행된다. 따라서 본 연구에서 설계한 pipeline에서는 elemental ansatz 연산을 위해 단일 클락 사이클에서는 총 1개의 곱셈 연산과 $N$개의 덧셈 연산이 병렬적으로 수행된다. 이러한 병렬 연산이 단일 elemental ansatz operation을 구성하는 대각 행렬 및 양자 상태 벡터의 $N$개 요소에 대해 총 $N+1$개의 클락 사이클동안 반복적으로 수행되면서 ansatz state의 값을 계산한다. 
%
%위와 같은 설계를 통해  $O(N^{2})$의 시간 복잡도를 가지는 QAOA 에뮬레이터의 행렬 연산을 하드웨어 병렬화를 통해 $O(N)$의 수준으로 연산 시간을 절감하였다. 또한 본 연구에서 설계한 파이프라인을 적용함으로써, 덧셈 연산에 비해 하드웨어 자원의 부담이 큰 곱셈 연산이 큐비트 수에 따라 지수적으로 스케일링되지 않도록 하였다. 이로써 하드웨어 병렬처리화에 따른 실행 시간 감소의 tradeoff로서 발생하는 하드웨어 자원 요구량의 증가를 막았다. 따라서 본 연구에서는 위 설계를 차용함으로써 Weighted-MaxCut 문제를 위한 QAOA의 규모의 증가에 따른 에뮬레이터의 하드웨어 자원 요구량의 증가폭을 줄일 수 있다.

\section{Design and Implementation of the QAOA Emulator}

\subsection{QAOA Emulator Architecture and Design Automation}

To implement the QAOA emulator for the Weighted-MaxCut problem on standalone FPGAs, we designed a RISC-V processor platform based on the architecture shown in \refFigure{fig:architecture}. 
This platform leverages the RISC-V Rocket core~\cite{Berkeley:Rocket}, which includes floating-point arithmetic units, making it well-suited for QAOA emulation in embedded systems. 
Key components of the architecture include: a 512KB SRAM as the main memory, Flash memory for non-volatile storage, 
a lightweight Network-on-Chip ($\mu NoC$), a control module for boot and reset functions, and standard I/O interface modules (UART, SPI, and I$^{2}$C).
For the RTL design, we utilized the RISC-V eXpress (\textit{RVX})\cite{Han:IEEE21}, an EDA tool widely adopted for lightweight RISC-V processor development~\cite{Park:TCASI24, Lee:IoTJ24, Han:ISLPED24, Choi:JETECH2024}. 
The system was configured to operate at a 100MHz clock frequency. 
Central to this design is the Quantum MaxCut Accelerator (\textit{QMA}), a dedicated hardware module that integrates our proposed resource optimization techniques for efficient QAOA processing on the Weighted-MaxCut problem.
The QMA employs fixed-point arithmetic, which is well-suited for hardware-level operations~\cite{Zhang:FPGA15}, and is developed as an IP core with AXI interface support. 
This design enables seamless integration into any processor platform. 
As shown in \refFigure{fig:architecture}, we embedded this IP core into the baseline RISC-V processor, resulting in an emulator capable of efficiently executing QAOA operations with minimal additional resource usage.
%To implement the QAOA emulator for the Weighted-MaxCut problem on standalone FPGAs, we designed a RISC-V processor platform based on the architecture shown in \refFigure{fig:architecture}. 
%This platform leverages the RISC-V Rocket core\cite{Berkeley:Rocket}, which has floating-point arithmetic units, making it well-suited for emulating QAOA in embedded system.
%Key components of the architecture include: a 512KB SRAM as main memory, Flash memory for non-volatile storage, a lightweight Network-on-Chip (\(\mu\)NoC~\cite{Han:ISLPED19}) for interconnect, a control module for boot and reset functions, and standard I/O interface modules (UART, SPI, and I$^{2}$C).
%For RTL design, we utilized the RISC-V eXpress (\textit{RVX})~\cite{Han:IEEE21}, an EDA tool widely adopted for lightweight RISC-V processor development~\cite{Park:TCASI24, Lee:IoTJ24, Han:ISLPED24}, and configured the system to operate at a 100MHz clock frequency. 
%Central to this design is the Quantum MaxCut Accelerator (\textit{QMA}), a dedicated hardware module integrating our proposed resource optimization techniques for efficient QAOA processing on the Weighted-MaxCut problem.
%In designing the QMA, we adopted fixed-point arithmetic, which is well-suited for general hardware-level operations~\cite{Zhang:FPGA15}. 
%Additionally, the QMA was developed as an IP core with AXI interface support, enabling seamless embedding into any processor platform. 
%As shown in \refFigure{fig}, we integrated this IP into the baseline RISC-V processor, creating an emulator capable of efficiently supporting QAOA operations while minimizing resource usage.


To automate the emulator’s RTL code generation for varying qubit counts, we extended RVX to develop QC Emulator eXpress (\textit{QEX}). 
QEX accepts user-defined parameters, 
\textit{NUM\_QUBIT}, representing the target number of qubits. 
Given \textit{NUM\_QUBIT}, QEX determines the required register blocks for storing coefficients of basis states and elements of diagonal matrices, defining this count as a local parameter, \textit{NUM\_STATE}. 
QEX then configures the registers and computation units of the MaxCut Accelerator accordingly, generating the complete RTL code of the SoC platform depicted in \refFigure{fig:architecture}.

\begin{figure}
%\vskip -4pt
	\centering
	\includegraphics[width=0.5\textwidth]{./figure/qaoa/qaoa_soc_final1.pdf}
	\caption{Architecture diagram of the developed emulator with the Quantum MaxCut Accelerator (QMA).}
	\label{fig:architecture}
%\vskip -8pt
\end{figure}

We further developed a C-language API to interface with the QMA, providing four primary commands: 
i) \texttt{set\_parameter}, 
ii) \texttt{set\_cost\_hamiltonian}, 
iii) \texttt{activate\_maxcut}, and 
iv) \texttt{get\_expectation}. 
The emulator operates by storing application instructions, implemented with these API commands, in the SRAM for execution by the Rocket core. Upon completing the emulation, the MaxCut Accelerator returns the ansatz state’s expectation value to the Rocket core, enabling the user to optimize variational parameters based on the outcome.

%\begin{figure*}[t]
%%\vskip -8pt		\centering
%		\begin{subfigure}{0.30\textwidth}
%			\includegraphics[width=\textwidth]{./figure/qaoa/9-1.png}
%			 \caption{\centering \textit{CALCULATE\_RAD} stage}
%			\label{fig:stage1}
%		\end{subfigure}
%		\hfill
%		\begin{subfigure}{0.30\textwidth}
%			\includegraphics[width=\textwidth]{./figure/qaoa/10-1.png}
%			\caption{\centering \textit{NORMALIZE\_RAD} stage}
%			\label{fig:stage2}
%		\end{subfigure}
%		\hfill
%		\vspace{0.2cm}
%		\begin{subfigure}{0.30\textwidth}
%			\includegraphics[width=\textwidth]{./figure/qaoa/11-1.png}
%			\caption{\centering \textit{CORDIC} stage }
%			\label{fig:stage3}
%		\end{subfigure}
%		
%		
%		\hspace{0.12\textwidth}
%		\begin{subfigure}{0.30\textwidth}
%			\includegraphics[width=\textwidth]{./figure/qaoa/12-1.png}
%			\caption{\centering \textit{1\_MULT} stage}
%			\label{fig:stage4}
%		\end{subfigure}
%		\hfill
%		\begin{subfigure}{0.30\textwidth}
%			\includegraphics[width=\textwidth]{./figure/qaoa/13-1.png}
%			\caption{\centering \textit{N\_ADD} stage}
%			\label{fig:stage5}
%		\end{subfigure}
%		\hspace{0.12\textwidth}
%%		\vspace{-0.5cm}
%		\caption{Register-level schematics of the pipeline in the proposed MaxCut Accelerator.}
%			\label{fig:fsm_states}
%%\vskip -8pt
%\end{figure*}


\begin{figure*}
%\vskip -8pt
	\centering
	\includegraphics[width=1\textwidth]{./figure/qaoa/qaoa_schematics_pipeline_final4.pdf}
	\caption{Register-level schematic of the pipeline stages in the developed QMA.}
	\label{fig:reg_pipeline}
%\vskip -10pt
\end{figure*}


\subsection{Setup for Emulating QAOA}
Before running QAOA, it is necessary to define the cost Hamiltonian for the Weighted-MaxCut problem. 
To do this, the two vertices $i$ and $j$ connected by each edge in the graph, along with the fixed-point representation of the edge weight $weight$, are input into the QMA using the \texttt{set\_cost\_hamiltonian} command. 
The Hamiltonian is then constructed based on (\ref{eq:cost_hamiltonian}) and (\ref{eq:ZiZj_diag}), representing it as a partial sum of $Z_{i}Z_{j}$ matrices. 
Its diagonal elements, \texttt{cost\_hamil\_diag}, are calculated according to the following algorithm:
%Before running QAOA, the cost Hamiltonian for the Weighted-MaxCut problem must be defined. 
%For this, the two vertices $i$ and $j$ connected by each edge in the graph, along with fixed-point expression of the edge weight $weight$, are input into the QMA using the \texttt{set\_cost\_hamiltonian} command. 
%The cost Hamiltonian is then constructed using (\ref{eq:cost_hamiltonian}) and (\ref{eq:ZiZj_diag}), which represent it as a partial sum over $Z_{i}Z_{j}$ matrices. The diagonal elements of the cost Hamiltonian, \texttt{cost\_hamil\_diag}, are set based on the following algorithm:

\fontsize{7}{7}\selectfont{}
\begin{verbatim}
 for (k = 0; k < NUM_STATE; k++) {
   bit_i = (k >> (i-1)) & 1;   bit_j = (k >> (j-1)) & 1;
   if (bit_i != bit_j) cost_hamil_diag[k] += 2.0 * weight;}
\end{verbatim}
\normalsize

Additionally, the \texttt{set\_parameter} command configures the QAOA layer number (\textit{layer}) and sets the cost and mixer ansatz parameters in fixed-point format. 
These parameters are stored in the \textit{gamma[layer]} and \textit{beta[layer]} registers, respectively. 
The \textit{NUM\_QUBIT} parameter adjusts the number of qubits available for QAOA, defining the size of the Weighted-MaxCut problem that the emulator can handle when synthesized on the FPGA. 
This setup ensures that the QMA scales efficiently with the problem size specified by the user.
%Additionally, the \texttt{set\_parameter} command is used to input the QAOA layer number (\textit{layer}) and the values for the cost and mixer ansatz parameters \CSH{in fixed-point format} for that layer, which are then stored  in the \textit{gamma[layer]} and \textit{beta[layer]} registers, respectively. 
%The available number of qubits for QAOA is adjusted by setting the \textit{NUM\_QUBIT} parameter, which determines the size of the Weighted-MaxCut problem that the emulator can handle when synthesized on the FPGA. 
%This setup allows the QMA to scale according to the problem size defined by the user's configuration.

%\subsection{Setup for Emulating QAOA}
%
%QAOA를 실행하기 전에, Weighted-MaxCut 문제를 정의하는 비용 해밀토니안의 값을 구해야 한다.
%Weighted-MaxCut 문제를 정의하는 그래프에서 간선을 잇는 두 정점 $i$, $j$과 가중치 $weight$를, \texttt{set\_cost\_hamiltonian} 커맨드를 통해 MaxCut Accelerator에서 입력받는다. 이후 행렬 $Z_{i}Z_{j}$의 부분합으로 비용 해밀토니안을 구성하는 식 \ref{eq:cost_hamiltonian} 및 \ref{eq:ZiZj_diag}을 사용하여 다음의 알고리즘을 통해 비용 해밀토니안 \texttt{cost\_hamil\_diag}을 설정한다: 
%
%\scriptsize
%\begin{verbatim}
%    for (k = 0; k < NUM_STATE; k++) {
%        bit_i = (k >> (i-1)) & 1;
%        bit_j = (k >> (j-1)) & 1;
%        if (bit_i != bit_j) {
%            cost_hamil_diag[k] += 2.0 * weight;
%        }  
%    }
%\end{verbatim}
%\normalsize
%
%또한 \texttt{set\_parameter} 커맨드를 통해 QAOA의 layer 번호(\textit{layer})와 해당 layer의 cost 및 mix ansatz 연산 파라미터의 값을 전달받아, 레지스터 \texttt{gamma[layer]}, \texttt{beta[layer]}에 각각 저장한다. 또한 파라미터 \texttt{NUM\_QUBIT}의 값을 설정하여 QAOA의 가용 큐비트 수를 조정할 수 있으며, 이를 통해 에뮬레이터가 FPGA에 합성될 때, 이 가속기가 에뮬레이팅하는 Weighted-MaxCut 문제의 규모를 조정하도록 했다.




\subsection{Register-Level Pipeline}

In the pipeline structure described in Section~\ref{sec:pipeline_unit_ansatz_op}, the diagonal elements of $D_{c}$ and $D_{m}$ are required. 
These elements are computed as the polar form exponents (i.e., angle values) of each Hamiltonian, determined based on the parameters using (\ref{eq:diag_cost}) and (\ref{eq:diag_mix}). 
To perform computations on these elements in hardware, the angle values must be converted to their Cartesian form through trigonometric function evaluation. 
In this study, we extended the pipeline described in Section~\ref{sec:pipeline_unit_ansatz_op} by concatenating a CORDIC module~\cite{Volder:IEEE59} as an additional stage for trigonometric calculations, thereby constructing a complete pipeline for computing elemental ansatz operations based on the specified cost Hamiltonian and parameters.
\refFigure{fig:reg_pipeline} illustrates the register-level schematic for each stage of the pipeline.

This pipeline is executed $2p$ times across $p$ layers, where input values change based on the layer index and the sequence of $D_{c}$ and $D_{m}$ to ensure correct computation of each elemental ansatz operation. To control this, we defined a register \textit{order} to indicate whether each ansatz operation corresponds to the cost or mixer unitary, as well as a register \textit{layer} to specify the current layer index.

%\subsection{Register-Level Pipeline}
%section \ref{sec:pipeline_unit_ansatz_op} 에서 설명한 pipeline 구조에서는 $D_{c}$, $D_{m}$의 diagonal elements의 값이 필요하다. 이 값들은 각 해밀토니안과 파라미터 값에 따라 식 \ref{eq:diag_cost}, \ref{eq:diag_mix}의 polar form의 exponent, 즉 각도값으로 계산이 된다. 하드웨어에서 이 원소값들에 대해 연산하려면, 계산된 각도값에 대각함수 값을 구해 이를 cartesian form으로 변환해야 한다. 본 연구에서는 section \ref{sec:pipeline_unit_ansatz_op}에서 구성한 pipeline 구조에, 삼각함수의 계산을 위한 CORDIC module \cite{Volder:IEEE59} 을 하나의 stage로 추가하여 concatenate함으로써 주어진 비용 해밀토니안과 파라미터에 대해 elemental ansatz operation의 계산을 수행하는 전체 pipeline을 구성하였다. 실수 값은 23비트 정확도의 fixed-point expression를 이용해 나타내었으며, \refFigure{fig:fsm_states}은 전체적인 pipeline의 각 stage에 대한 register-level schematic을 보여준다.
%
%이 pipeline은 $p$개의 layer에 대해 총 $2p$번 수행된다. 각 수행마다 layer 차수와 $D_{c}$, $D_{m}$의 순서에 따라 입력값을 달리하여 해당 pipeline이 각 elemental ansatz operation이 올바르게 계산되도록 한다. 이를 위해, pipeline 내의 각 elemental ansatz 연산이 cost unitary인지 mix unitary인지 여부를 결정하는 레지스터 \textit{order}와, 연산이 수행되는 layer 번호를 나타내는 레지스터 \textit{layer}를 정의하였다.


\subsubsection{\textbf{CALCULATE\_RAD} stage}\noindent
This stage corresponds to the first stage depicted in \refFigure{fig:reg_pipeline}.
In this stage, the radian angle values of each diagonal element in $D_{c}$ and $D_{m}$ are computed based on (\ref{eq:diag_cost}) and (\ref{eq:diag_mix}).
When the \texttt{activate\_maxcut} command is executed, the pipeline stages operate over \textit{NUM\_STATE} clock cycles. 
The counter register \textit{count\_1st} ensures that each input corresponds to the (\textit{count\_1st})-th diagonal element of the Hamiltonian.

During this stage, the inputs are defined as the product of \textit{cost\_hamil\_diag[count\_1st]} and \textit{gamma[layer]} for $D_{c}$, or, for $D_{m}$, the product of $\textit{u[count\_1st, NUM\_QUBIT]}$ (cf. (\ref{eq:diag_mix})) and \textit{beta[layer]}. These inputs are selected based on the values of \textit{order} and \textit{layer}. The resulting angle values are stored in the \textit{rad} register and forwarded through the pipeline. The assignment of the \textit{rad} follows the algorithm:

\fontsize{7}{7}\selectfont
\begin{verbatim}
if(!order) {rad = cost_hamil_diag[count_1st] * gamma[layer];}
else {rad = u(count_1st, NUM_QUBIT) * beta[layer];}
\end{verbatim}
\normalsize

%In this stage, the radian angle values of each diagonal element in $D_{c}$ and $D_{m}$ are computed based on (\ref{eq:diag_cost}) and (\ref{eq:diag_mix}). As depicted in \textit{CALCULATE\_RAD stage in \refFigure{fig:reg_pipeline}}.
%When the \texttt{activate\_maxcut} command is called, the pipeline stages are activated over \textit{NUM\_STATE} clock cycles.
%The value of a counter register, \textit{count\_1st}, ensures that each input corresponds to the (\textit{count\_1st})-th diagonal element of the Hamiltonian.
%
%The inputs in this stage consist of the product of \textit{cost\_hamil\_diag[count\_1st]} and \textit{gamma[layer]} for $D_{c}$, or, for $D_{m}$, the product of $\textit{u[count\_1st,NUM\_QUBIT]}$ (cf. (\ref{eq:diag_mix})) and \textit{beta[layer]}. 
%These inputs are selected based on the values of \textit{order} and \textit{layer}, and the resulting angle values from these multiplications are stored in the \textit{rad} register and pipelined forward. 
%The \textit{rad} register is assigned according to the following algorithm:
%
%\fontsize{7}{7}\selectfont{}
%\begin{verbatim}
%if(!order) {rad = cost_hamil_diag[count_1st] * gamma[layer];}
%else {rad = u(count_1st, NUM_QUBIT) * beta[layer];} 
%\end{verbatim}
%\normalsize




%\subsubsection{\textit{CALCULATE\_RAD} stage}\noindent
%이 stage에서는 $D_{c}$ 및 $D_{m}$에 대한 식 \ref{eq:diag_cost}, \ref{eq:diag_mix}에서  polar form으로 나타내는 각 대각 성분의 지수, 즉 radian 단위의 각도값을 계산한다. 커맨드 \texttt{activate\_maxcut}가 호출되면서 입력값 \textit{en\_active\_maxcut}이 HIGH가 되면 이 stage의 enable 신호 (\textit{en\_pipeline})가 \texttt{NUM\_STATE} 개의 클락 사이클동안 활성화된다. 이때 연산 횟수를 카운트하는 레지스터 \texttt{count\_1st}의 값을 이용해 이 enable 신호를 컨트롤하고, 해밀토니안에 해당하는 본 stage의 입력값이 (\textit{count\_1st})-th diagonal element에 대응하도록 하였다. 
%
%그림 \ref{fig:stage1}의 stage에서, 입력값들은 $D_{c}$에 대해 비용 해밀토니안의 성분(\textit{cost\_hamil\_diag[count\_1st]})과 cost unitary에 대한 파라미터 \textit{gamma[layer]}의 곱으로 나타나며, $D_{m}$에 대해서는 식 \ref{eq:diag_mix}에서 정의된 $\textit{u(count\_1st,NUM\_QUBIT)}$의 값과 mix unitary에 대한 파라미터 \textit{beta[layer]}의 곱으로 나타난다. 이 입력값들은 \textit{order}과 \textit{layer}에 의해 선택되고 이들의 곱연산의 결과로써 출력된 각도값은 레지스터 \textit{rad}에 저장되어 파이프라이닝된다. 이와 같은 곱 연산은 아래의 알고리즘을 따라 구현하였다:
%
%\scriptsize
%\begin{verbatim}
%    if(!order) 
%        rad = cost_hamil_diag[count_1st] * gamma[layer];
%    else 
%        rad = u(count_1st, NUM_QUBIT) * beta[layer]; 
%\end{verbatim}
%
%\normalsize

%%또한 레지스터 \texttt{order}를 정의하여, $D_{c}$에 대한  elemental ansatz operation 연산을 할 때에는 0의 값을, $D_{m}$에 대한 연산을 할 때는 1의 값을 가지도록 하였고, \texttt{order} 및 \texttt{layer}의 값에 따라 해당 stage의 입력을 각각 다른 종류의 연산에 맞게 구성하도록 설계했다. 


\subsubsection{\textbf{NORMALIZE\_RAD} stage}\noindent
To ensure accurate trigonometric calculations in the CORDIC module, the angle values computed in the \textit{CALCULATE\_RAD} stage are normalized to the first quadrant as illustrated in \refFigure{fig:reg_pipeline}. 
First, the given angle value is reduced modulo $2\pi$, and then the normalized angle is calculated based on the quadrant in which the angle lies. 
This normalized angle is stored in the $rad_{Q1}$ register. Additionally, the signs of the trigonometric values, which may change due to quadrant normalization, are stored in the \textit{sign adjustment} registers based on the original quadrant of \textit{rad}. 
The angle values and trigonometric signs are determined according to the following algorithm:

\fontsize{7}{7}\selectfont{}
\begin{verbatim}
 neg_cos = 0; neg_sin = 0; norm_rad = rad % (2 * PI);
 if(en_pipeline) {
   if(norm_rad < 0.5 * PI) norm_rad_first_quad = norm_rad;
   else if(norm_rad < PI) 
     norm_rad_first_quad = PI - norm_rad; neg_cos = 1;
   else if(norm_rad < 1.5 * PI) {
     norm_rad_first_quad = norm_rad - PI;
     neg_sin = 1; neg_cos = 1;}
   else {
     norm_rad_first_quad = 2 * PI - norm_rad; neg_sin = 1;}}  
\end{verbatim}

\normalsize

%\textit{CALCULATE\_RAD} stage 에서 계산한 각도 값에 대해 CORDIC module에서 삼각함수 값을 정확히 수행하게끔 하기 위해 이 각도값을 제1사분면에 normalizing하는 과정을 \refFigure{fig:stage2}와 같이 수행한다. 이를 위해서 우선 주어진 각도값을 $2\pi{}$로 나눈 나머지를 구한 다음, 이 값이 어떤 사분면에 위치하는 지에 따라 normalized된 각도값을 계산하여 레지스터 \texttt{norm\_rad\_first\_quad}에 저장 한다. 또한 제1사분면에 normalize하면서 발생한 삼각함수 값의 부호 반전 여부는 \texttt{rad}의 사분면 위치에 따라 \texttt{neg\_sin}, \texttt{neg\_cos} 레지스터에 별도로 저장한다. 각도값 및 삼각함수의 부호는 다음과 같은 알고리즘으로 결정된다:
%
%\scriptsize
%\begin{verbatim}
%    neg_cos = 0; neg_sin = 0;
%    norm_rad = rad % (2 * PI)
%    if(en_pipeline) {
%        if(std_rad < 0.5 * PI) {
%            norm_rad_first_quad = norm_rad;
%        }
%        else if(std_rad < PI) {
%            norm_rad_first_quad = PI - nrom_rad;
%            neg_cos = 1;
%        }
%        else if(std_rad < 1.5 * PI) {
%            norm_rad_first_quad = norm_rad - PI;
%            neg_sin = 1; neg_cos = 1;
%        }
%        else {
%            nrom_rad_first_quad = 2 * PI - norm_rad;
%            neg_sin = 1;
%        }        
%    }  
%\end{verbatim}

\normalsize

\subsubsection{\textbf{CORDIC} stage} \noindent
% \CSH{\refFigure{fig:reg_pipeline}} illustrates the operation of this stage, which takes the normalized angle values produced in the previous \textit{NORMALIZE\_RAD} stage as inputs to calculate the mantissa and exponent parts of the diagonal elements in $D_{c}$ and $D_{m}$.
% To achieve this, the stage utilizes a CORDIC module that computes the trigonometric values for the given angle inputs.

This stage employs a CORDIC module to compute both cosine and sine values of $rad_{Q1}$.
The CORDIC module is implemented as a 16-stage pipeline, allowing the input angle $rad_{Q1}$ to propagate through the pipeline over 16 clock cycles.
After these cycles, the CORDIC module outputs the trigonometric values ${cos}_{Q1}$ and ${sin}_{Q1}$, along with a corresponding valid signal indicating completion.
To align the sign adjustments \delete{(\textit{neg_sin} and \textit{neg_cos})} with the trigonometric outputs generated in the same clock cycle, these sign values are pipelined in parallel with the CORDIC module across all 16 stages.


%This stage employs a CORDIC module to generate both real and imaginary sinusoidal values of $\textit{rad}_{\textit{Q1}}$.
%The CORDIC module in our design is structured as a 16-stage pipeline. 
%Consequently, the angle input $\textit{rad}_{\textit{Q1}}$ propagates through 16 clock cycles in the pipeline. 
%At the end of these cycles, the CORDIC module produces the trigonometric values $\textit{cos}_{\textit{Q1}}$ and $\textit{sin}_{\textit{Q1}}$ along with an output valid signal.
%To ensure that the sign adjustments \delete{(\textit{neg\_sin} and \textit{neg\_cos})} correspond to the trigonometric outputs generated at the same clock cycle, these sign values are also pipelined in parallel with the CORDIC module across 16 stages.


%그림 \ref{fig:stage3}는 앞선 \textit{NORMALIZE\_RAD} stage에서 normalized된 각도값을 입력으로 받아 $D_{c}$ 및 $D_{m}$의 대각 성분을 이루는 진수 및 가수 부분을 계산하는 본 stage의 동작을 그린다. 이를 위해 이 stage에서는 CORDIC module을 이용하여, 입력된 각도값에 대해 삼각함수 값을 계산하는 과정을 수행한다. 본 설계에서 사용한 CORDIC module은 그 자체로 총 16단계의 pipeline 구조를 가지고 있다. 따라서 CORDIC module의 input valid 신호로서의 \textit{en\_pipeline}과 함께 입력된 각도 값 \texttt{norm\_rad\_first\_quad}은 총 16개의 클락 사이클을 지나 CORDIC module의 output valid 신호와 함께, 삼각함수의 값 \texttt{cos\_theta}, \texttt{sin\_theta}의 출력을 만들어낸다. 또한 특정 클락 사이클의 각도값 입력에 대응하는 \texttt{neg\_sin}, \texttt{neg\_cos}의 값 또한 이들 출력과 대응하게끔 16단계 pipeline 구조를 CORDIC module과 병렬적으로 구성하였다.

\subsubsection{\textbf{1\_MULT} stage}\noindent
In this stage, the diagonal matrix element obtained from the \textit{CORDIC} stage is multiplied by the corresponding component of the state vector, performing the multiplication operation represented as \textit{1\_MULT} in \refFigure{fig:pipeline}. 
As shown in the \textit{1\_MULT} stage of \refFigure{fig:reg_pipeline}, a register, \textit{count\_4th}, is defined in this stage to count the number of operations. 
This counter selects the \textit{state[count\_4th]} from the \textit{state} vector, which represents the quantum states, and proceeds with the multiplication together with the diagonal element computed in the previous stage. 
Since both the diagonal matrix element and the \textit{state} vector component are complex numbers, the real and imaginary parts of the operation are calculated separately, as shown in the following algorithm:

%In this stage, the diagonal matrix element obtained from the \textit{CORDIC} stage is multiplied by the corresponding component of the state vector, performing the multiplication operation represented as \textit{\textit{1\_MULT}} in \refFigure{fig:pipeline}. 
%As shown in \textit{1\_MULT} stage in \refFigure{fig:reg_pipeline}, a register \textit{count\_4th} is defined in this stage to count the number of operations.
%This counter selects the \textit{state[count\_4th]} from the \textit{state} vector, which represents the quantum states, and proceeds with the multiplication together with the diagonal element computed in the previous stage.
%Since both the diagonal matrix element and the \textit{state} vector component are complex numbers, the real and imaginary parts of the operation are calculated separately, as shown in the following algorithm:

\fontsize{7}{7}\selectfont{}
\begin{verbatim}
    Re(mult) = Re(state[count_4th]) * cos_theta
        - Im(state[count_4th]) * sin_theta;
    Im(mult) = Re(state[count_4th]) * sin_theta
        + Im(state[count_4th]) * cos_theta;
\end{verbatim}
\normalsize
%이 스테이지에서는 \textit{CORDIC} stage에서 구한 대각 행렬의 성분과, 이와 짝을 이루는 상태 벡터의 성분을 입력으로 하여 그림 \ref{fig:pipeline}의 \textit{\textit{1\_MULT}} 연산에 해당하는 곱연산을 수행한다. \refFigure{fig:stage4}에서 보이는 바와 같이, 해당 stage에서 \textit{en\_pipeline}이 활성화되어있을 때 이 stage에서의 연산 횟수를 카운트하는 레지스터 \textit{count\_4th}가 정의되어있다. 이때 이 레지스터의 값이 양자 상태를 나타내는 레지스터 \textit{state}에서 \textit{count\_4th}번째 벡터 성분 \textit{state[count\_4th]}를 선택하여  \textit{CORDIC} stage에서 계산된 대각 성분의 값과 함께 곱 연산이 진행된다. 대각 행렬의 성분과 상태 벡터의 성분은 각각 복소수로서, 진수 부분과 가수 부분의 연산을 따로 수행해야 하며 이는 다음 알고리즘과 같이 이루어진다:
%
%\scriptsize
%\begin{verbatim}
%    Re(mult) = Re(state[count_4th]) * cos_theta
%        - Im(state[count_4th]) * sin_theta;
%
%    Im(mult) = Re(state[count_4th]) * sin_theta
%        + Im(state[count_4th]) * cos_theta;
%\end{verbatim}
%\normalsize

As a result, the real and imaginary parts of the complex product of the two complex numbers are output, and these values are stored in the \textit{mult} register to be passed to the next stage.
%이에 따른 결과로 두 복소수의 곱으로서의 복소수에 대한 진수 및 가수 부분의 값이 출력되며, 이 값들은 레지스터 \textit{mult}에 저장되어 다음 stage로 이동한다.

\subsubsection{\textbf{N\_ADD} stage}\noindent
As shown in \refFigure{fig:reg_pipeline}, this stage takes the complex product obtained in the \textit{1\_MULT} stage and multiplies it by each element in the corresponding column of the Hadamard matrix ($H_1$), performing the accumulation operation on the \textit{result} register, corresponding to \textit{N\_add.} in \refFigure{fig:pipeline}. 
As discussed in Section~\ref{sec:decomp_mix_unitary}, since the elements of matrix $H_1$ are either $1$ or $-1$, the multiplication with $H_1$’s column elements is implemented in hardware using simple sign inversion logic combined with parallel addition. After completing one elemental ansatz operation in the entire pipeline, the value in \textit{state} is re-initialized with the accumulated value in \textit{result}. The algorithm for this accumulation operation is as follows:

\scriptsize
\begin{verbatim}
   for(i=0; i<NUM_STATE; i++) {
     if(H_1[i][count_5th] == 1) result[i] += mult;
     else if(H_1[i][count_5th] == -1) result[i] -= mult;
     else printf("Error: Unexpected value in H_1");}
\end{verbatim}
\normalsize


%이 스테이지는 \refFigure{fig:stage4}에 묘사되어있는 것과 같이, \textit{1\_MULT} stage에서 구한 두 성분의 곱으로써의 복소수 값을, 짝을 이루는 hadamard matrix(H\_1)의 column의 성분들과 각각 곱하여, \refFigure{fig:pipeline}의 \textit{N\_add.} 에 해당하는 누적 연산을 레지스터 \textit{result}에 대해 수행한다. 이때 section \ref{sec:decomp_mix_unitary}에서 논의한 바와 같이, 행렬 $H_{1}$의 성분은 1 또는 -1로, $H_{1}$의 column의 성분을 곱하는 연산은 하드웨어상에서 간단한 sign inversion 논리와 병렬 더하기 연산으로 구현된다. 전체 pipeline에서 하나의 elemental ansatz operation이 끝난 후 \textit{state}의 값은 \textit{result}에 누적된 값으로 초기화된다. 이 누적 연산에 대한 알고리즘은 아래와 같다:
%
%\scriptsize
%\begin{verbatim}
%    for(i=0; i<NUM_STATE; i++) {
%        if(H_1[i][count_5th] == 1) {
%            result[i] += mult;
%        }
%        if(H_1[i][count_5th] == -1) {
%            result[i] -= mult;
%        }
%    }
%\end{verbatim}
%\normalsize


\section{Evaluation}

\begin{figure}[t]
%\vskip -6pt
	\centering
	\includegraphics[width=0.5\textwidth]{./figure/qaoa/demo1.pdf}
	\caption{Execution of the prototyped QAOA emulator on the Kintex-7 FPGA board (left), and on Artix-7 FPGA board (right).}
	\label{fig:result_on_fpga}
	%\vskip -6pt
\end{figure}

\begin{table}
\begin{center}
\caption{Comparison of execution time and energy consumption for 8-layer QAOA emulation with varying numbers of qubits between emulators with and without the QMA.}
%\vskip -2pt
		\centering
		\resizebox{\columnwidth}{!}{
		\begin{tabular}{ccccc}
			\toprule
			\multirow{2}{*}{\makecell{\\$n$}} & \multicolumn{2}{c}{w/o QMA} & \multicolumn{2}{c}{Proposed} \\
			\cmidrule(lr){2-3} \cmidrule(lr){4-5}
			& \multicolumn{1}{c}{Exec. time\hspace{0.15em}(\textit{ms})} & \multicolumn{1}{c}{Energy\hspace{0.15em}(\textit{mJ/exec.})}& \multicolumn{1}{c}{Exec. time\hspace{0.15em}(\textit{ms})} & \multicolumn{1}{c}{Energy\hspace{0.15em}(\textit{mJ/exec.})} \\
			\midrule
			2 &  0.41  	&0.23	& 0.26  	&0.15\\
			3 &  0.98  		&0.54	 & 0.26  	&0.15\\
			4 &  2.1 		&1.2	& 0.26 &0.15\\
			6 &  16  			&8.6	 & 0.27 & 0.17\\
			8 &  196  		&108	 & 0.30 & 0.30\\
			9 &  742 	&409	 & 0.34 &0.48\\
			\bottomrule
		\end{tabular}
		}
%	\vspace{0.2cm}
	\label{table:exec_time}	
\end{center}
%\vskip -10pt
\end{table}
\normalsize

Using the developed QEX, we implemented QAOA emulators with varying numbers of qubits, each incorporating the QMA shown in \refFigure{fig:architecture}.
These emulators were synthesized using the Xilinx Vivado tool~\cite{Vivado} and prototyped on a Xilinx Kintex-7 XC7K325T FPGA~\cite{Kintex7} board, as illustrated in \refFigure{fig:result_on_fpga}. 
After verifying stable operation, we evaluated the acceleration performance of the QMA by measuring the execution time of the QAOA with 8-layers on the emulator prototype. 
Energy consumption was calculated based on the measured execution time and power consumption data reported by Vivado. 
For comparison, a baseline processor with the same architecture as the emulator, but without the QMA, was also developed and prototyped on the same FPGA board. 
A C-based software implementation of the QAOA program was executed on the baseline processor to measure software-based emulation times. 
The results, summarized in \refTable{table:exec_time}, demonstrate substantial performance gains as the number of qubits increases. 
For 2-qubit QAOA emulation, the QMA achieved about 1.56$\times$ reduction in execution time and 1.53$\times$ improvement in energy efficiency. However, as the number of qubits increases, the benefits grow exponentially, culminating in a speedup of up to 2,182$\times$ and an energy efficiency improvement of 852$\times$ for 9-qubit emulation.

\begin{table}
%\vskip -8pt
\setlength{\tabcolsep}{5pt} % Adjust column padding
\begin{center}
	\caption{Resource usage and utilization on Kintex-7 FPGA for conventional and proposed emulators with Rocket core across varying qubit counts.}
	%\vskip 2pt
	\centering
	\begin{minipage}{0.5\textwidth}
		\centering
		\resizebox{1\columnwidth}{!}{
		\begin{tabular}{cccc}
			\toprule
			\multirow{3}{*}{\makecell{\\ $n$}} & \multicolumn{3}{c}{Emulators with a conventional HW accelerator}  \\
			\cmidrule(lr){2-4}
			& \multicolumn{1}{c}{LUT (Res. Util.)} & \multicolumn{1}{c}{\makecell{FF (Res. Util.)}} & \multicolumn{1}{c}{\makecell{DSP (Res. Util.)}} \\
			& \multicolumn{1}{c}{(Max : 203,800)} & \multicolumn{1}{c}{\makecell{(Max : 407,600)}} & \multicolumn{1}{c}{\makecell{(Max : 840)}} \\
			\midrule

			2 & \hspace{0.5em}43,086 (21.1\%)&  26,814 \hspace{0.5em}(6.6\%) & 103 (12.3\%)   \\
			3 & 136,437 (66.9\%) & 30,412 \hspace{0.5em}(7.5\%) & 315 (37.5\%) \\
			4\hspace{0.5em}(\textit{falied})& 1,275,722 (626\%)\hspace{1em}& 41,146 (10.1\%)& 834 (99.3\%)\\
			\bottomrule
		\end{tabular}
		}
	\end{minipage}
	
	%\vskip 5pt
	
	\begin{minipage}{0.5\textwidth}
		\centering
		\resizebox{1\columnwidth}{!}{
			\begin{tabular}{cccc}
			\toprule
			\multirow{3}{*}{\makecell{\\ $n$}} & \multicolumn{3}{c}{Emulators with the proposed QMA}  \\
			\cmidrule(lr){2-4}
			& \multicolumn{1}{c}{LUT (Res. Util.)} & \multicolumn{1}{c}{\makecell{FF (Res. Util.)}} & \multicolumn{1}{c}{\makecell{DSP (Res. Util.)}} \\
& \multicolumn{1}{c}{(Max : 203,800)} & \multicolumn{1}{c}{\makecell{(Max : 407,600)}} & \multicolumn{1}{c}{\makecell{(Max : 840)}} \\
			\midrule

			2 & \hspace{0.5em}28,999 \hspace{0.5em}(14.2\%) 	& \hspace{0.5em}27,011 \hspace{0.5em}(6.6\%) 	& 31 (3.7\%) \\
			3 & \hspace{0.5em}29,486 \hspace{0.5em}(14.5\%) 	& \hspace{0.5em}27,524 \hspace{0.5em}(6.8\%) 	& 31 (3.7\%) \\
			4 & \hspace{0.5em}30,510 \hspace{0.5em}(15.0\%) 	& \hspace{0.5em}28,597 \hspace{0.5em}(7.0\%) 	& 31 (3.7\%) \\
			6 & \hspace{0.5em}36,369 \hspace{0.5em}(17.8\%) 	& \hspace{0.5em}34,813 \hspace{0.5em}(8.5\%) 	& 32 (3.8\%) \\
			8 & \hspace{0.5em}79,252 \hspace{0.5em}(38.9\%) 	& \hspace{0.5em}60,724 (14.9\%) 				& 32 (3.8\%) \\
			9 & 130,134 \hspace{0.5em}(63.9\%) 				& \hspace{0.5em}94,978 (23.3\%) 				& 32 (3.8\%) \\
			10\hspace{0.5em}(\textit{falied}) & 230,183 (113.0\%) 							& 163,157 (40.0\%) 							& 32 (3.8\%) \\
			% 10 & \multicolumn{3}{c}{\textit{(failed)}} \\
			\bottomrule
		\end{tabular}
		}
	\end{minipage}
	\label{table:fpga_resource_genesys2}
\end{center}
\scriptsize \centering * Ref., LUT/FF/DSP of the emulator w/o the QC accelerator : 24853 / 24445 / 4
%\vskip -4pt
\end{table}
\normalsize

\begin{table}
	% \setlength{\tabcolsep}{7pt} % Adjust column padding
\begin{center}
	\caption{Resource usage and utilization on Artix-7 FPGA for proposed emulators with ORCA core across varying qubit counts.}
	%\vskip 2pt
	\centering
		\centering
		\resizebox{1\columnwidth}{!}{
		\begin{tabular}{cccc}
			\toprule
			\multirow{3}{*}{\makecell{\\ $n$}} & \multicolumn{3}{c}{ORCA-based emulator employing the proposed QMA}  \\
			\cmidrule(lr){2-4}
			& \multicolumn{1}{c}{LUT (Res. Util.)} & \multicolumn{1}{c}{\makecell{FF (Res. Util.)}} & \multicolumn{1}{c}{\makecell{DSP (Res. Util.)}} \\
& \multicolumn{1}{c}{(Max : 63,400)} & \multicolumn{1}{c}{\makecell{(Max : 126,800)}} & \multicolumn{1}{c}{\makecell{(Max : 240)}} \\
			\midrule

			2 & 17,053 \hspace{0.5em}(26.9\%) & 19,785 (15.6\%) & 31 (12.9\%)   \\
			3 & 17,625 \hspace{0.5em}(27.8\%) & 20,402 (16.1\%) & 31 (12.9\%) \\
			4 & 18.748 \hspace{0.5em}(29.6\%) & 21,395 (16.9\%) & 31 (12.9\%) \\
			6 & 25,554 \hspace{0.5em}(40.3\%) & 27,806 (27.8\%) & 32 (13.3\%)\\
			8 & 51,168 \hspace{0.5em}(80.7\%) & 53,545 (42.2\%) & 32 (13.3\%)\\
			9\hspace{0.5em}(\textit{falied}) & 84,739 (133.7\%) & 87,692 (69.2\%) & 32 (13.3\%)\\
			\bottomrule
		\end{tabular}
		}
	\label{table:fpga_resource_arty}
\end{center}
\scriptsize \centering * Ref., LUT/FF of the emulator w/o the QC accelerator : 12555 / 17154 / 4
%\vskip -10pt
\end{table}
\normalsize


%우리는 QEX를 이용해 \refFigure{fig:architecture}의 QMA를 포함하는 QAOA emulators with different number of qubits를 개발하고 이를 \refFigure{fig:result_on_fpga}와 같이 FPGA prototyping 하였다.  
%개발한 에뮬레이터 프로토타입의 정상 동작을 확인한 후, 이것의 evaluation를 위해 우리는 먼저 QMA의 가속 성능 평가를 수행하였다.
%우리는 4, 8, 12 layers의 QAOA 프로그램 개발한 에뮬레이터 프로토타입 상에서 동작시키면서 수행 시간을 측정하였다.  이어서 우리는 QMA만 없고 나머지 구성은 동일한 아키텍처의 프로세서를 개발하고 이것의 FPGA 프로토타입과 해당 프로세서의 코어에서 동작하는 C 언어로 짠 4, 8, 12 layers의 QAOA 소프트웨어 프로그램을 개발하여 프로세서 코어 상에서 소프트웨어로 동작하는 에뮬레이션의 수행 시간을 측정하였다.  
%\refTable{table:exec_time}은 그 비교 결과를 보여주는데, 큐비트 및 레이어 수가 증가함에 따라 OMA로 인한 가속 성능 증가 정도가 두드러짐을 확인할 수 있는데, 특히 5큐빗 12레이어 QAOA 에뮬레이션에서는 최대 863배의 속도 향상을 보여주었다. 

The reduction in execution time achieved through hardware parallelization inevitably increases hardware resource utilization. To address this, we proposed methods to mitigate the resource overhead effectively.  
To evaluate the effectiveness of these methods, we conducted experiments comparing hardware accelerators for matrix-vector multiplication in universal QC (\textit{Conventional}), designed without our optimizations, to the proposed QMA.  
These conventional accelerators, tailored to varying numbers of qubits, were integrated into the baseline platform shown in \refFigure{fig:architecture}, replacing the QMA. 
The RTL designs were adjusted for each qubit configuration.  
Both conventional and proposed emulators were prototyped on a Kintex-7 FPGA, incrementally increasing the number of qubits to compare resource utilization. The results are summarized in \refTable{table:fpga_resource_genesys2}.  
As shown, the conventional emulator became unsynthesizable beyond 3 qubits due to excessive resource usage. 
In contrast, the proposed emulator demonstrated efficient resource management, achieving a 78\% reduction in LUT utilization for the 3-qubit configuration and enabling seamless synthesis of the 3-qubit emulator, while supporting successful prototyping for configurations up to 9 qubits.

%하드웨어 병렬화로 인한 실행 시간 단축은 하드웨어 리소스 점유의 증가를 필연적으로 수반하는데, 우리는 본 study에서 이러한 리소스 사용의 증가를 효과적으로 억제하는 방안을 제안하였다. 따라서 우리는 next evaluation으로 제안한 resource-efficient methods의 효용성을 위한 실험을 수행하였다. 
%우리는 비교를 위해 제안기술이 적용되지 않은 에뮬레이팅을 위한 행렬-벡터 곱 연산을 가속하는 하드웨어 가속기를 설계하고, \refFigure{fig:architecture}의 아키텍처에서 the QMA 대신 이를 포함하는 baseline 에뮬레이터들 with various number of qubits의 RTL 설계를 하였다. 
%이어 우리는 qubit수를 증가시켜가며 baseline emulator와 proposed emulator를 Xilinx Vivado \cite{Vivado} 툴을 이용해 Kintex-7 FPGA에서 합성하여 리소스 사용량을 측정하고 비교하였다. 그 results는 표 \ref{table:fpga_resource_genesys2}에 요약되어 있다.
%이 표에서 확인할 수 있듯, baseline 구조의 경우 3큐빗 이상에서 자원 사용량의 급격한 증가로 인해 합성이 불가능했다. 반면, 제안한 구조에서는 리소스 사용이 효율적으로 관리되어 (baseline의 합성 가능한 최대 큐빗 수(3 큐빗)에서 LUT 자원 점유량이 약 85.3\%까지 절감된다), 최대 8큐빗 에뮬레이터 합성이 가능함을 확인할 수 있다.  




















%\CSH{본 디자인의 개선을 수치화하기 위해 다음과 같은 figure of merit의 값 $G$의 계산식을 제안한다. lower is better.}
%\begin{equation}
%	\CSH{G = \sqrt{\frac{RU_{LUT}^{2} + RU_{FF}^{2} + RU_{DSP}^{2}}{3}} \cdot{} T}
%\end{equation}
%\CSH{where $RU_{LUT}$, $RU_{FF}$, $RU_{DSP}$ are resource utilization ratio of LUT, FF, and DSP, respectively, and $T$ is execution time in miliseconds. We evaluated $G$ for the cases: i) without QMA, ii) baseline, and iii) proposed emulator, and organized in Table~\ref{table:fom}}


%\CSH{To quantify the improvements of our design, we propose the following figure of merit, \( G \), where a higher value indicates better performance:}
%\begin{equation}
%	\CSH{G = \left[\sqrt{\frac{RU_{LUT}^{2} + RU_{FF}^{2} + RU_{DSP}^{2}}{3}} \cdot T\right]^{-1}}
%\end{equation}
%\CSH{Here, \( RU_{LUT} \), \( RU_{FF} \), and \( RU_{DSP} \) represent the resource utilization ratios of LUT, FF, and DSP, respectively, and \( T \) denotes the execution time in seconds. We evaluated \( G \) for three configurations: i) without QMA, ii) baseline, and iii) proposed emulator, considering cases where the number of layer is 4, 8, and 12, and the parameter \( n \) takes values of 2, 3, 4, 6, 8, and 9. The results are organized in Table~\ref{table:fom}. Notably, our proposed design achieves a $G$ value that is 460 times higher than the w/o QMA in configuration for a 9-qubit, 12-layer system.} 

%\CSH{우리 연구에서 제시하는 에뮬레이터와 위의 비교군들 간의 에너지 효율성(energy efficiency)을 테이블 \ref{table{}}에서 비교하였다. 여기서 에너지 효율성은 실행당 에너지 소비의 역수로 정의되며, \CSH{\textit{w/o QMA}} 설정을 기준으로 정규화되었다. 테이블에서 확인할 수 있듯이, 제안된 에뮬레이터는 \CSH{\textit{w/o QMA}}와 비교했을 때 큰 폭의 에너지 절감을 보여주었으며, \CSH{\textit{Baseline}} 설정과 비슷한 에너지 소비로 더 많은 큐비트를 에뮬레이팅할 수 있었다. 특히 높은 큐비트 수와 레이어 수를 가진 경우에 제안된 에뮬레이터는 더욱 효율적인 에너지 사용을 나타내어, 복잡한 양자 연산을 처리하는 데 있어 우수한 성능을 보였다.}

%\CSH{To demonstrate the improvement of our design, we compare the energy efficiency of the proposed emulator with that of the reference configurations in Table \ref{table:energy}. 
%Energy efficiency is defined as the inverse of energy consumption per execution and is normalized relative to the \CSH{\textit{w/o QMA}} configuration. 
%%As shown in the table, the proposed emulator demonstrates significant energy savings compared to the \CSH{\textit{w/o QMA}} configuration and is able to emulate a larger number of qubits with similar energy consumption as the \CSH{\textit{Baseline}} configuration. 
%As shown in the table, the proposed emulator achieves substantial energy savings, with efficiency improvements up to  907 times for 9 qubit, 12 layers configurations, compared to the \CSH{\textit{w/o QMA}} configuration, highlighting its superior performance in handling QAOA emulations for complex Weighted-MaxCut problem.}


In addition, to evaluate the effectiveness of our proposed techniques on entry-level FPGA boards alongside mid-tier options, we conducted FPGA prototyping and resource usage comparisons for the proposed emulators integrated with the ORCA core~\cite{Vectorblox:ORCA} on the Xilinx Artix-7 XC7A100T board~\cite{Artix7} (cf. \refFigure{fig:result_on_fpga}). 
As shown in TABLE \ref{table:fpga_resource_arty}, the proposed emulator successfully scaled up to 8-qubits, whereas the conventional design was limited to a maximum of 2-qubits on the same board. 
These results demonstrate that the proposed emulator can efficiently support the emulation of more complex Weighted-MaxCut problems even in environments with severely constrained hardware resources.

%끝으로, 우리는 mid-tier가 아닌 entry 급의 FPGA board에서도 여전히 우리가 제안한 기술이 유용함을 증명하기 위해서 Digilent Arty-A7 보드를 이용한 FPGA 프로토타이핑 및 리소스 사용 비교를 수행하였다. 그 결과, baseline 구조는 2큐빗이 최대였던 것에 반해 TABLE \ref{table:fpga_resource_arty}에서 확인할 수 있는 것과 같이 제안한 emulator는 4큐빗까지 프로토타이핑이 가능하였다. 즉, 우리는 임베디드 장치와 같이 하드웨어 리소스가 제한된 환경에서 제안한 에뮬레이터가 보다 복잡한 Weighted-MaxCut 문제를 효과적으로 에뮬레이팅할 수 있음을 다시 한번 더 확인할 수 있었다. 


\section{Conclusion}
We proposed an efficient approach to emulating QAOA in resource-constrained environments. 
Focusing on the Weighted-MaxCut problem, we optimized the conventional QAOA by restructuring its operations for hardware efficiency and designing a pipeline-based architecture for embedded systems. 
These efforts culminated in the development of the Quantum MaxCut Accelerator (QMA), which was integrated into custom emulators. 
To facilitate the rapid creation of QAOA emulators, we introduced QEX, a tool for efficient design and deployment. 
For evaluation, we implemented FPGA prototypes of both the proposed and baseline emulators, enabling comprehensive comparisons of performance, energy efficiency, and resource utilization.
Experimental results demonstrated the significant acceleration, energy savings, and resource efficiency achieved with the QMA and our approach.
These achievements provide a groundwork for advancing QAOA emulation in resource-constrained environments and enhancing QC capabilities.

%우리는 자원 제약적인 환경에서 QAOA를 효과적으로 에뮬레이션하기 위한 새로운 접근법을 제안하였다. 
%QAOA의 대표적인 적용 사례인 Weighted-MaxCut 문제를 대상으로, 기존의 연산식을 하드웨어 효율성을 고려하여 재구성하고, 임베디드 환경에 적합한 파이프라인 기반 하드웨어 연산 구조를 설계하였다. 
%우리는 제안한 methods를 적용하여 QMA를 설계하였고, 이를 탑재한 에뮬레이터를 개발하였다. 그 과정에서 쉽고 빠르게 QAOA 에뮬레이터를 개발할 수 있는 QEX도 함께 개발하였다. 최종적으로 우리는 설계한 에뮬레이터들의 FPGA 프로토타입들을 포함해 성능 비교를 위한 baseline 에뮬레이터 프로토타입들을 만들었고, 이들을 활용한 실험을 통해 QMA의 가속 성능 우수성 증명과 함께 제안한 방법의 특출난 자원 소비 효율성을 입증하였다. 
%우리는 임베디드 시스템 환경에서도 QAOA의 잠재력을 효과적으로 활용할 수 있는 기반을 마련하였으며, 이를 통해 QC의 발전과 확장에 기여할 수 있기를 기대한다. 



\bibliographystyle{IEEEtran}
\bibliography{references_real}








\end{document}
