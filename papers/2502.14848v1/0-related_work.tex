\section{Related Work}
\label{sec:relatedwork}
% \paragraph{Tool Usage and Toolchain Management} Research in this area focuses on how intelligent agents design and optimize tool networks to effectively execute complex tasks, particularly by dynamically generating, selecting, and combining tools based on task requirements.This includes methods for automated tool generation and optimization, emphasizing systems that can adaptively choose and adjust tool combinations according to different task needs.

% \paragraph{Multi-Agent Systems and Collaboration} Research in Multi-Agent Systems has explored how multiple intelligent agents can collaboratively solve complex tasks in dynamic environments. One significant contribution is the development of decentralized algorithms that allow agents to autonomously form beneficial collaborations and adapt to changing tasks without the need for a central server (DeLAMA) ~\citep{tang2024decentralizedlifelongadaptivemultiagentcollaborative}. Another key area of study focuses on collaboration among heterogeneous agents, where different agents with varied capabilities work together on complex tasks, such as cleaning large spaces, using hierarchical decision models to allocate sub-tasks effectively~\citep{liu2023heterogeneousembodiedmultiagentcollaboration}. Additionally, collaborative learning approaches like Collaborative Q-learning (CollaQ) enhance agent teamwork by decomposing the Q-function and introducing reward attribution techniques to improve performance in multi-agent environments, such as the StarCraft challenge ~\citep{zhang2020multiagentcollaborationrewardattribution}. Finally, research has also examined how multi-agent collaboration can enhance the performance of large language models (LLMs) in tasks like simulations and software development, highlighting the potential of intelligent agent collaboration to improve task outcomes~\citep{talebirad2023multiagentcollaborationharnessingpower}.

\paragraph{Code Generation and Task Solving with LLMs} Large Language Models (LLMs) have demonstrated remarkable potential in generating code to solve complex tasks. Prior studies highlight their effectiveness in mathematical computation ~\citep{zhou2023solving, wang2023mathcoder, gou2023tora}, tabular reasoning ~\citep{chen2022program, lyu2023faithful, lu2024chameleon}, and visual understanding ~\citep{suris2023vipergpt, choudhury2023zero, gupta2023visual}. Frameworks such as AutoGen ~\citep{wu2023autogen} and CodeActAgent~\citep{wang2024executable} extend this capability to agent-based tasks by interpreting executable code as actions. These models dynamically invoke basic tools based on environmental feedback, significantly expanding their utility. Despite their successes, these approaches often treat program generation processes independently, failing to model shared task features and limiting the reusability of functional modules across tasks.

\paragraph{Reusable Tool Creation and Abstraction} To address the limitations of single-use program generation, recent efforts have focused on creating reusable tools. CREATOR ~\citep{qian2023creator} separates the processes of planning (tool creation) and execution, while LATM ~\citep{cai2023large} and CRAFT ~\citep{yuan2023craft} pre-build tools using training and validation sets for task solving. However, these methods often generate a large number of tools, presenting challenges for their efficient reuse. Furthermore, while abstraction-based approaches like REGAL ~\citep{stengel2024regal} focus on extracting reusable tools from primitive programs, they primarily construct simple tools with limited functional complexity. Similarly, Trove ~\citep{wang2024trove} adopts a training-free approach by dynamically composing high-level tools during testing, but its reliance on self-consistency can lead to hallucinated knowledge, reducing accuracy in complex tasks.

\paragraph{Tool Selection for Complex Task Solving} Currently, research on tool selection and retrieval methods primarily focuses on selecting appropriate tools through retrieval mechanisms and LLM-based approaches. ToolRerank ~\citep{zheng2024toolrerank} uses adaptive truncation and hierarchy-aware reranking to improve retrieval results, while Re-Invoke ~\citep{chen2024reinvoketool} introduces an unsupervised framework with synthetic queries and multi-view ranking, enhancing both single-tool and multi-tool retrieval. COLT ~\citep{Qu_2024COLT} combines semantic matching with graph-based collaborative learning to capture relationships among tools, outperforming larger models in some cases. AvaTaR~\citep{wu2024avataroptimizingllmagents} automates the optimization of LLM prompts for better tool utilization, and DRAFT~\citep{qu2024DAFT} refines tool documentation through iterative feedback and exploration, helping LLMs better understand external tools. Despite progress, existing methods generally overlook cost-effectiveness and scalability in tool selection, and often struggle to efficiently adapt to new tools and task requirements in dynamic environments, leading to performance and efficiency bottlenecks. In contrast, our approach dynamically prioritizes tools by combining their relevance and structural importance, ensuring computational efficiency and scalability, thus enabling more effective solutions for complex tasks.