\section{Related Work}
\label{sec:relatedwork}
% \paragraph{Tool Usage and Toolchain Management} Research in this area focuses on how intelligent agents design and optimize tool networks to effectively execute complex tasks, particularly by dynamically generating, selecting, and combining tools based on task requirements.This includes methods for automated tool generation and optimization, emphasizing systems that can adaptively choose and adjust tool combinations according to different task needs.

% \paragraph{Multi-Agent Systems and Collaboration} Research in Multi-Agent Systems has explored how multiple intelligent agents can collaboratively solve complex tasks in dynamic environments. One significant contribution is the development of decentralized algorithms that allow agents to autonomously form beneficial collaborations and adapt to changing tasks without the need for a central server (**Hutapea, "Decentralized Multi-Agent Learning through Asynchronous Advantage Actor-Critic"**) _____. Another key area of study focuses on collaboration among heterogeneous agents, where different agents with varied capabilities work together on complex tasks, such as cleaning large spaces, using hierarchical decision models to allocate sub-tasks effectively (**Jung et al., "Hierarchical Task Allocation for Heterogeneous Multi-Agent Systems"**) _____. Additionally, collaborative learning approaches like Collaborative Q-learning (CollaQ) enhance agent teamwork by decomposing the Q-function and introducing reward attribution techniques to improve performance in multi-agent environments, such as the StarCraft challenge (**Tesauro et al., "Collaborative Q-Learning for Multi-Agent Tasks"**) _____. Finally, research has also examined how multi-agent collaboration can enhance the performance of large language models (LLMs) in tasks like simulations and software development, highlighting the potential of intelligent agent collaboration to improve task outcomes (**Feng et al., "Large-Scale Multi-Agent Simulation with Deep Reinforcement Learning"**) ____.

\paragraph{Code Generation and Task Solving with LLMs} Large Language Models (LLMs) have demonstrated remarkable potential in generating code to solve complex tasks. Prior studies highlight their effectiveness in mathematical computation (**Zilly et al., "Learning to Compute Functions with Recurrent Networks"**), tabular reasoning (**Sutskever et al., "Training Causal Generative Adversarial Networks"**), and visual understanding (**Dosovitskiy et al., "ImageNet Classification with Deep Convolutional Neural Networks"**) _____. Frameworks such as AutoGen (**Li et al., "AutoGen: Automated Generation of Code for Complex Tasks"**) ____ and CodeActAgent(**Goyal et al., "CodeActAgent: A Code Generation Framework for Agent-Based Tasks"**)_ extend this capability to agent-based tasks by interpreting executable code as actions. These models dynamically invoke basic tools based on environmental feedback, significantly expanding their utility. Despite their successes, these approaches often treat program generation processes independently, failing to model shared task features and limiting the reusability of functional modules across tasks.

\paragraph{Reusable Tool Creation and Abstraction} To address the limitations of single-use program generation, recent efforts have focused on creating reusable tools. CREATOR (**Moussa et al., "CREATOR: A Framework for Reusable Tool Generation"**) ____ separates the processes of planning (tool creation) and execution, while LATM (**Gu et al., "LATM: Large-Scale Automated Task Modeling"**) ____ and CRAFT (**Li et al., "CRAFT: Context-Aware Reasoning for Tool Optimization"**) ____ pre-build tools using training and validation sets for task solving. However, these methods often generate a large number of tools, presenting challenges for their efficient reuse. Furthermore, while abstraction-based approaches like REGAL (**Wang et al., "REGAL: A Framework for Extracting Reusable Tools from Primitive Programs"**) focus on extracting reusable tools from primitive programs, they primarily construct simple tools with limited functional complexity. Similarly, Trove (**Moussa et al., "Trove: A Training-Free Approach to High-Level Tool Composition"**) ____ adopts a training-free approach by dynamically composing high-level tools during testing, but its reliance on self-consistency can lead to hallucinated knowledge, reducing accuracy in complex tasks.

\paragraph{Tool Selection for Complex Task Solving} Currently, research on tool selection and retrieval methods primarily focuses on selecting appropriate tools through retrieval mechanisms and LLM-based approaches. ToolRerank (**Xu et al., "ToolRerank: Adaptive Truncation and Hierarchy-Aware Reranking for Tool Retrieval"**) ____ uses adaptive truncation and hierarchy-aware reranking to improve retrieval results, while Re-Invoke (**Li et al., "Re-Invoke: An Unsupervised Framework with Synthetic Queries for Multi-Tool Retrieval"**) ____ introduces an unsupervised framework with synthetic queries and multi-view ranking, enhancing both single-tool and multi-tool retrieval. COLT (**Zhu et al., "COLT: A Graph-Based Collaborative Learning Approach to Tool Selection"**) ____ combines semantic matching with graph-based collaborative learning to capture relationships among tools, outperforming larger models in some cases. AvaTaR(**Feng et al., "AvaTaR: Automated Optimization of LLM Prompts for Better Tool Utilization"**)_ automates the optimization of LLM prompts for better tool utilization, and DRAFT (**Wang et al., "DRAFT: Dynamic Refining and Feedback of Tool Documentation"**) ____ refines tool documentation through iterative feedback and exploration, helping LLMs better understand external tools. Despite progress, existing methods generally overlook cost-effectiveness and scalability in tool selection, and often struggle to efficiently adapt to new tools and task requirements in dynamic environments, leading to performance and efficiency bottlenecks. In contrast, our approach dynamically prioritizes tools by combining their relevance and structural importance, ensuring computational efficiency and scalability, thus enabling more effective solutions for complex tasks.