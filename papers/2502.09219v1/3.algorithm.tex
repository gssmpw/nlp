\begin{algorithm}[t]
    % \LinesNumbered
    % \SetAlgoLined
    \DontPrintSemicolon
    
    \SetKwInOut{Input}{Input}
    \SetKwInOut{Output}{Output}
    
    \SetKwFunction{Prune}{PRUNE}
    
    
    \Input{A set of programs $\mathbf{EX}=\{\langle \Pi^{I}_1,\Pi^Q_1\rangle,\ldots,\langle\Pi^{I}_n,\Pi^Q_n\rangle \}$ where $\Pi^{I}_i$, and $\Pi^{Q}_i$ correspond to scene and question representation;
    Common Rule Set $\Pi^{R}$ with Fallback rules; \\
    Set of ground truths $\mathbf{GT} = \{\Pi^{GT}_1,\ldots,\Pi^{GT}_n\}$.}
    \Output{A hypothesis $\Pi^{D}$}
    
    
    
    $\Pi^{D} \leftarrow \emptyset$ \;
    \ForEach{$\langle \Pi^{I}_i,\Pi^Q_i\rangle \in \mathbf{EX}$}{
        \If(\tcp*[h]{$w$ is the query type, $x, y$ are possible answers}){$choose(w,x,y) \in \Pi^{Q}_i$}{ \label{a:choosestart}
            \If{$w \in \mathcal{C}_{sinChoice}$}{
                \lIf{$result(x) \in \Pi^{GT}_i$}{$\Pi^{D} \leftarrow \Pi^{D} \cup \{assign(x,w).\}$}
                \lElse{$\Pi^{D} \leftarrow \Pi^{D} \cup \{assign(y,w).\}$}
            }
            \Else{
                $\Pi^{D} \leftarrow \Pi^{D} \cup \{assign(x,w).\ assign(y,w).\}$
            }
        } \label{a:chooseend}
        \If{$\Pi^{I}_i\cup\Pi^Q_i\cup\Pi^{R} \nvDash \Pi^{GT}_i$}{ \label{a:gtsbeg}
            Pick the fact $select(i,c,j) \in \Pi^{Q}_i$ such that $\Pi^{I}_i\cup\Pi^Q_i\cup\Pi^{R} \models empty(i)$ and $i$ is minimal \;
            \If(\tcp*[h]{$c$ is then a general concept}){there does not exist $name(\_,c) \in \Pi^{I}_i$}{
                Pick $c' \neq c$ such that $name(\_,c') \in \Pi^{I}_i$ and $\Pi^{I}_i\cup\Pi^Q_i\cup\Pi^{R} \cup \{assign(c',c).\} \models \Pi^{GT}_i$ \;
                $\Pi^{D} \leftarrow \Pi^{D} \cup \{assign(c',c).\}$ \;
                $support_{c',c}$ += $1$ \;
            }
        }
    }  \label{a:gtsend}
    \Return $\{assign(c',c). \in \Pi^{D}$ with $support_{c',c} > threshold$\} \;
    \caption{FAST-DAP}
    \label{algo:train}
\end{algorithm}

In this section, we present a practical, heuristic algorithm for finding a DAP, that while is not guaranteed to maximize the accuracy of question answering, we show to perform very well in practice.  There are several reasons as to why we adopt this more practical approach.  First, in the general case, a brute-force approach is intractable.  Second, even if it is possible to exactly optimize an accuracy metric as described in the previous section, it may still perform poorly when confronted with unseen data due to overfitting.  Third, in some cases, the query itself can reveal portions of the ground truth.  To address all of these issues, we introduce our practical heuristic algorithm FAST DAP (Algorithm~\ref{algo:train}).
Regarding the first point, the algorithm is highly performant, requiring only one pass over all examples in $\textbf{EX}$ -- this also allows for trivial parallelization.  Second, we only add facts to $\Pi^D$ that support a certain number of examples, which acts as a form of regularization; we then tune this threshold to maximize accuracy.  
To address the third point, in lines~\ref{a:choosestart}--\ref{a:chooseend} we utilize examples that provide domain information in the query itself (with two answers as in $choose(color, red, blue, 0)$ and with single answer as in $choose(healthy, apple, cake, 0$)), while we leverage the step-by-step nature of the ASP formulation of queries (following~\cite{eiter2022neuro}, see Example~\ref{ex:techprelim}) to identify domain assignments that can satisfy the ground truth (lines \ref{a:gtsbeg}-\ref{a:gtsend}).



