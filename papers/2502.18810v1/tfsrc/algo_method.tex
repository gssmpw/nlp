% \begin{algorithm}[t]
%     \caption{Knowledge Graph-based Test Generation Framework}
%     \label{alg:framework}
%     \begin{algorithmic}[1]
%     \Require
%         \State Text corpus for forgetting $D_{\text{fgt}}$
%         \State Text corpus for retention $D_{\text{ret}}$
%     \Ensure
%         \State Generated test questions $Q$ with reference answers
    
%     \vspace{1mm}
%     \State \textbf{Stage 1: Knowledge Graph Construction}
%     \State Perform coreference resolution on $D_{\text{fgt}}$ and $D_{\text{ret}}$
%     \State Extract entities and relations using REBEL-large model
%     \State Construct knowledge graph $G_{\text{fgt}} = \langle \mathcal{E}_{\text{fgt}}, \mathcal{R}_{\text{fgt}}, \mathcal{F}_{\text{fgt}} \rangle$
%     \State Construct knowledge graph $G_{\text{ret}} = \langle \mathcal{E}_{\text{ret}}, \mathcal{R}_{\text{ret}}, \mathcal{F}_{\text{ret}} \rangle$
    
%     \vspace{1mm}
%     \State \textbf{Stage 2: Conflict Removal}
%     \State Identify conflicting edges: $E_{\text{conf}} \gets E(G_{\text{fgt}}) \cap E(G_{\text{ret}})$
%     \State Remove conflicts: $G_{\text{test}} \gets G_{\text{fgt}} \setminus E_{\text{conf}}$
    
%     \vspace{1mm}
%     \State \textbf{Stage 3: Question Synthesis}
%     \State Initialize empty question set $Q \gets \emptyset$
%     \For{each triple $(h, r, t) \in G_{\text{test}}$}
%         \State Retrieve source text context for triple $(h, r, t)$
%         \State Generate question $q$ and reference answer $a$ using LLM
%         \State Add to question set: $Q \gets Q \cup \{(q, a)\}$
%     \EndFor
    
%     \State \Return Test question set $Q$
%     \end{algorithmic}
%     \end{algorithm}


\begin{algorithm}[tb]
    \small
    \caption{\sys}
    \label{alg:selective_forgetting}
    \textbf{Input:} Forget dataset $D_{\text{fgt}}$, Retain dataset $D_{\text{ret}}$ \\
    \textbf{Output:} Audit suite $S$
    \begin{algorithmic}[1]
        \Function{GENERATION}{$D_{\text{fgt}}, D_{\text{ret}}$}
            \State $\triangleright$ Knowledge Graph Construction
            % \State Preprocess($D_{\text{fgt}}$) \Comment{Segmentation and coreference resolution}
            % \State Preprocess($D_{\text{ret}}$)
            \State $G_{\text{fgt}} \gets \text{KGExtraction}(D_{\text{fgt}})$ 
            % \Comment{Extract KG from $D_{\text{fgt}}$}
            \State $G_{\text{ret}} \gets \text{KGExtraction}(D_{\text{ret}})$ 
            % \Comment{Extract KG from $D_{\text{ret}}$}
            
            \State $\triangleright$ Redundancy Removal
            \State $G_{\text{test}} \gets \emptyset$
            \ForAll{$e \in G_{\text{fgt}}$}
                \If{$e \notin G_{\text{ret}}$}
                    \State $G_{\text{test}} \gets G_{\text{test}} \cup \{e\}$
                \EndIf
            \EndFor
            
            \State $\triangleright$ Question Synthesis
            \State $S \gets \emptyset$
            \ForAll{$e \in G_{\text{test}}$}
                \State $ctx \gets \text{RetrieveContext}(e)$ 
                % \Comment{Retrieve associated context for edge $e$}
                \State $prompt \gets \text{ComposePrompt}(e, ctx)$ 
                % \Comment{Compose prompt using $e$ and its context}
                \State $qa \gets \text{LLM}(prompt)$
                %  \Comment{Generate QA pair via LLM}
                \State $S \gets S \cup \{qa\}$
            \EndFor
            
            \State \Return $S$
        \EndFunction
    \end{algorithmic}
    \end{algorithm}
    
    