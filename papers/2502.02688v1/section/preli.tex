\section{Preliminaries}
\label{sec:Preliminaries}
The following definitions, theorems and algorithms are based on the following papers and books:~\cite{Regin:CostbasedArcConsistencyforGlobalCardinalityConstraints,Berge:GrapheetHypergraphes,Lawler:CombinatorialOptimization,Tarjan:DataStructuresandNetworkAlgorithms,Ahuja:NetworkFlows}.


\paragraph*{Constraint Programming:}
A finite constraint network ${\cal N}$ is defined as a set of $n \in N$ variables $X=\{x_1, \ldots, x_n\}$, a set of current domains ${\cal D} = \{D(x_1),\ldots, D(x_n)\}$ where $D(x_i)$ is the finite set of possible values for variable $x_i$, and a set ${\cal C}$ of constraints between variables. 
We introduce the particular notation ${\cal D}_0 = \{D_0(x_1),\ldots, 
D_0(x_n)\}$ to represent the set of initial domains of ${\cal N}$ 
on which constraint definitions were stated. 
A constraint $C$ on the ordered set of variables 
$X(C)=(x_{i_1},\ldots,x_{i_r})$ is a subset $T(C)$ of the Cartesian 
product $D_0(x_{i_1}) \times \cdots \times D_0(x_{i_r})$ 
that specifies the allowed combinations of values for 
the variables $x_{i_1}, \ldots, x_{i_r}$. 
An element of $D_0(x_{i_1}) \times \cdots \times D_0(x_{i_r})$ 
is called a tuple on $X(C)$ and is denoted by $\tau$. In a tuple $\tau$, the assignment of the $i^{\text{th}}$ variable is denoted by $\tau_i$. \var$(C,i)$ represents the $i^{\text{th}}$ 
variable of $X(C)$.
A value $a$ for a variable $x$ is often denoted by $(x,a)$. 
Let $C$ be a constraint. A tuple $\tau$ on $X(C)$ is valid if $\forall (x, a) \in \tau, a \in D(x)$. $C$ is consistent iff there exists a tuple $\tau$ of $T(C)$ which is valid. A value $a \in D(x)$ is consistent with $C$ iff $x \not \in X(C)$ or there exists a valid tuple $\tau$ of $T(C)$ with $(x,a) \in \tau$. 

The costgcc constraint is formally defined as follows.

\begin{definition}[\cite{Regin:CostbasedArcConsistencyforGlobalCardinalityConstraints}]
A {\bf global cardinality constraint with costs} is a constraint
$C$ associated with a cost function on $X(C)$ \texttt{cost}, an integer $H$
and in which each value $a_i \in D(X(C))$ is associated with two
positive integers $l_i$ and $u_i$\\
\begin{tabular}{@{\hspace{0.1cm}}l@{\hspace{0.1cm}}l}
$T(C)=\{$&$\tau$ such that $\tau$ is a tuple on $X(C)$\\ 
& and $\forall a_{i} \in D(X(C)) : l_{i} \leq \#(a_{i},\tau) \leq u_{i}$\\
& and $\Sigma_{i=1}^{|X(C)|} cost($\var$(C,i),\tau[i]) \leq H$ $\}$\\
\end{tabular}\\
It is denoted by $costgcc(X,l,u,cost,H)$.
\end{definition}

    To understand how arc consistency on a costgcc is established, some concepts from graph theory and flow theory are required.

\paragraph*{Graph theory:}

A \mev{directed graph} or \mev{digraph} $G=(X,U)$ consists of a
\mev{node set} $X$ and an \mev{arc set} $U$, where every arc $(x, y)$ 
is an ordered pair of distinct nodes. We will denote by $X(G)$ the
node set of $G$ and by $U(G)$ the arc set of $G$. The \mev{cost} of an arc is a value associated with the arc. When costs are associated with arcs, one should talk about weighted directed graphs.

A \mev{path} from node $x_1$ to node $x_k$ in $G$ is a list of nodes $[x_1, \dots, x_k]$ such that $(x_i, x_{i+1})$ is an arc for $i \in [1,k-1]$. 
The path is called \mev{simple} if all its nodes are distinct. 
The \mev{cost} of a path $P$, denoted by $cost(P)$, is the sum of the costs of the arcs contained in $P$. A \mev{shortest path} from a node $s$ to a node $t$ is a path from $s$ to $t$ whose cost is minimum.

\paragraph*{Flow theory:}

Let $G$ be a digraph where each arc $(x, y)$ 
is associated with three information: $l_{xy}$ the lower bound capacity, $u_{xy}$ the upper bound capacity and $c_{xy}$ the cost of the arc.

A \mev{flow} in $G$ is a function $f$ satisfying the following two
conditions: 
\point For any arc $(x, y)$, $f_{xy}$ represents the amount
of some commodity that can ``flow'' through the arc. Such a flow is
permitted only in the indicated direction of the arc, i.e., from $x$ to
$y$. For convenience, we assume $f_{xy}=0$ if $(x, y) \not\in
U(G)$.
\point A \mev{conservation law} is fulfilled at each
node: $\forall y \in X(G) : \sum_{x}f_{xy} = \sum_{z}f_{yz}$.

The \mev{cost} of a flow $f$ is $cost(f)=\sum_{(x, y) \in U(G)}f_{xy}c_{xy}$.

The feasible flow problem consists in computing a flow in $G$ that satisfies the \mev{capacity constraint}. That is finding $f$ such that $\forall (x, y) \in U(G)$ $l_{xy} \leq f_{xy} \leq u_{xy}$. The minimum cost flow problem consists in finding a feasible flow $f$ such that $cost(f)$ is minimum.

A min cost flow can be computed thanks to the augmenting shortest path algorithm. 
The main idea of the basic algorithms of flow theory is to proceed by
successive improvement of flows that are computed in a graph in which all
the lower bounds are zero and the
current flow is the zero flow (i.e., the flow value is zero on all arcs). 

First, assume that there is no lower capacity.
So, consider that all the lower bounds are equal to zero
and suppose that you want to increase the flow value for an arc $(x, y)$.
In this case, the zero flow is a feasible flow. 
Let $P$ be a shortest path from $y$ to
$x$ different from $(y, x)$, and $val=min(\{u_{xy}\} \cup \{u_{ab}$ s.t. $(a, b) \in P \})$. Then we can define the function $f$ on the arcs
of $G$ such that
$f_{ab}=val$ if $(a, b) \in P$ or $(a, b)=(x, y)$, and $f_{ab}=0$ otherwise. This
function is a flow in $G$ and $f_{xy} >0$. Now, from this flow we can define a particular graph without any flow value and all lower bounds equal to zero, the residual graph.

\begin{definition}
The \textbf{residual graph} for a given flow $f$, denoted by
$R(f)$, is the digraph with the same node set as in $G$ and with the arc set defined as follows:\\ $\forall (x, y) \in U(G)$:
\point $f_{xy} < u_{xy} \Leftrightarrow (x, y) \in U(R(f))$ and has cost
$rc_{xy}=c_{xy}$ and upper bound capacity
$r_{xy}=u_{xy} - f_{xy}$. 
\point $f_{xy} > l_{xy} \Leftrightarrow (y, x) \in U(R(f))$ and has cost
$rc_{yx}=-c_{xy}$ and upper bound capacity
$r_{yx}=f_{xy}-l_{xy}$. \\
All the lower bound capacities are equal to $0$.
\end{definition}

Then, we can select an arc and apply the previous algorithm on this arc in order to increase its flow value.
By dealing only with shortest path we can guarantee that the computed flow will have a minimum cost. 

Now consider the lower capacities. In this case, we can use the algorithm mentioned by RÃ©gin:

Start with the zero flow $f^o$. This flow satisfies the upper bounds.
Set $f=f^o$, and apply the following process while the flow is not feasible:\\
$1)$ pick an arc $(x, y)$ such that $f_{xy}$ violates the lower bound capacity in
$G$ (i.e., $f_{xy} < l_{xy}$).\\
$2)$ Find $P$ a shortest path from
$y$ to $x$ in $R(f)-\{(y, x)\}$.\\ 
$3)$ Obtain $f'$ from  $f$ by sending flow along $P$; set
$f=f'$ and goto $1)$\\
If, at some point, there is no
path for the current flow, then a feasible flow does not
exist. Otherwise, the obtained flow is feasible and is a minimum cost flow.

\section{Filtering Algorithm}
\label{sec:FilteringAlgorithm}
Our work builds on top of the original costgcc filtering (i.e., ~\cite{Regin:CostbasedArcConsistencyforGlobalCardinalityConstraints}). Before presenting how we speed up the algorithm for costgcc, let us briefly review the original algorithm.

There is a relation between a costgcc and the search for min-cost flow in a particular graph.

    \begin{definition}[\cite{Regin:CostbasedArcConsistencyforGlobalCardinalityConstraints}]
        Given $C = costgcc(X, l, u, cost, H)$. The value graph of $C$ is the bipartite graph $GV(C) = (X(C), D(X(C)), U)$ where $(x, a) \in U
        $ if $a \in D_x$. 
        The {\bf value network} of $C$ is the directed graph $N(C)$ with $l_{xy}$ the lower bound capacity, $u_{xy}$ the upper bound capacity and $c_{xy}$ the cost on arc from the node $x$ to the node $y$. $N(C)$ is obtained from the value graph $GV(C)$ by:
        \begin{itemize}
            \item Orienting each edge of $GV(C)$ from values to variables. $\forall x \in X(C) : \forall a \in D(x): l_{ax} =0$, $u_{ax} =1$ and $c_{ax} =cost(x,a)$.
            \item Adding a node $s$ and an arc from $s$ to each value. $\forall a \in D(X(C))$: $l_{sa} = l_a$, $u_{sa} = u_a$ and $c_{sa} =0$.
            \item Adding a node $t$ and an arc from each variable to $t$. $\forall x \in X(C): l_{xt} =1$, $u_{xt} =1$ and $c_{xt} =0$.
            \item Adding an arc $(t, s)$ with $l_{ts} \!\! = u_{ts} \!\! = \!\! |X(C)|$ and $c_{ts} \!\! = \!\! 0$.
        \end{itemize}
    \end{definition}

 

\begin{property}[\cite{Regin:CostbasedArcConsistencyforGlobalCardinalityConstraints}]
A costgcc $C$ is consistent iff there is a minimum cost flow in the value network of $C$ whose cost is less than or equal to H.
\end{property}

Figure~\ref{fig:exempleArcConsistance} represents the residual graph of the value network of the costgcc constraint defined in Figure~\ref{fig:intro}. 
This is the graph computed from a flow resulting of the min cost flow algorithm applied on the value network.
In the residual graph, the optimal solution corresponds to the arcs oriented from the variables to the values.
The optimal cost value is $7$.

For clarity, in the remainder, we consider that $C=costgcc(X, l, u, cost, H)$ is a costgcc constraint and that $f$ is min cost flow in $N(C)$. We also assume that the arc consistency of the underlined gcc of $C$ has been established.

The consistency of a value relates to the existence of a particular path in the residual graph of the min cost flow.
\begin{property}[\cite{Regin:CostbasedArcConsistencyforGlobalCardinalityConstraints}]\label{acxpte}
    A value $a$ of a variable $x$ is not consistent with $C$ iff the two following properties hold:
    \begin{itemize}
        \item $f_{ax} = 0$
        \item $d_{R(f)}(x, a) > H - cost(f) - rc_{ax}$
    \end{itemize}
    where $d_{R(f)}(x, a)$ is the shortest path between $x$ and $a$ in the residual graph of $f$, and $rc_{ax}$ is the residual cost of the arc $(a, x)$.
    \label{property:Regin}
\end{property}

To establish arc consistency, the previous property could be checked for each value of each variable. However it is possible to reduce the number of computed shortest paths.
    \begin{corollary}[\cite{Regin:CostbasedArcConsistencyforGlobalCardinalityConstraints}]\label{acpte}
        Given any variable $x$ and $b$ the value of $x$ such that $f_{bx} = 1$. Then, the value $a$ of $x$ is not consistent with $C$ iff the two following properties hold:
        \begin{itemize}
            \item $f_{ax} = 0$
            \item $d_{R(f)} (b, a) > H - cost(f) - rc_{ax} - rc_{xb}$
        \end{itemize}
    \end{corollary}

    An example of the application of Property~\ref{property:Regin} is given in Figure~\ref{fig:exempleArcConsistance}.
    The length of the shortest path from $Julia$ to $E$ has a cost of $-1$ (see blue arcs) and the cost of the arc ($E$, $Julia$) is $rc_{EJulia}=1$. Thus we have $d_{R(f)}(Julia, E)=-1$ and $H - cost(f) - rc_{EJulia}=11 - 7 -1=3$, so we have $-1 \leq 3$. From Property~\ref{property:Regin} it means that $(E, Julia)$ is consistent.
    The shortest path from $Peter$ to $B$ is $d_{R(f)}(Peter, B)=1$ and the cost of the arc ($B$, $Peter$) is $rc_{BPeter}=4$ (see red arcs). Hence, we have $H - cost(f) - rc_{BPeter} = 11 - 7 - 4 = 0$, so $1 > 0$. ($B$, $Peter$) is inconsistent, the arc is then removed.

    \begin{figure}
    \centering
    \begin{tikzpicture}[
    round/.style={regular polygon, regular polygon sides=6, draw=black},
    square/.style={rectangle, draw=black},
    oval/.style={rounded rectangle, draw=black, minimum width=1.5cm, minimum height=0.7cm},
    flecheG/.style={{Stealth[scale=1.3]}-},
    flecheD/.style={-{Stealth[scale=1.3]}},
    align=center
    every node/.style={transform shape}
    ]
    %Nodes
    \node[round] (xt)      {t};
    
    \node[oval] (x1) [draw=red, right of=xt, yshift=3cm, xshift= 1.5cm, thick] {Peter};
    \node[oval] (x2) [below of=x1] {Paul};
    \node[oval] (x3) [below of=x2] {Mary};
    \node[oval] (x4) [below of=x3] {John};
    \node[oval] (x5) [below of=x4] {Bob};
    \node[oval] (x6) [below of=x5] {Mike};
    \node[oval] (x7) [below of=x6, draw=blue, thick] {Julia};

    \node (w1) [right of=x1, yshift=0.1cm, xshift= -0.1cm] {\textcolor{red}{-1}};
    \node (w2) [right of=x1, yshift=-0.8cm, xshift= -0.2cm] {\textcolor{red}{4}};
    \node (w3) [right of=x2, yshift=-0.2cm, xshift= 0.15cm] {-1};
    \node (w4) [right of=x2, yshift=-0.5cm, xshift= -0.2cm] {4};
    \node (w5) [right of=x3, yshift=0.17cm, xshift= 0.1cm] {\textcolor{red}{3}};
    \node (w6) [right of=x3, yshift=-0.2cm, xshift= -0.2cm] {\textcolor{red}{-1}};
    \node (w7) [right of=x4, yshift=0.54cm, xshift= 0.1cm] {3};
    \node (w8) [right of=x4, yshift=-0cm, xshift= -0.2cm] {-1};
    \node (w9) [right of=x5, yshift=0.5cm, xshift= -0.2cm] {-1};
    \node (w10) [right of=x6, yshift=0.5cm, xshift= -0.2cm] {-1};
    \node (w11) [right of=x7, yshift=0.8cm, xshift= -0.2cm] {\textcolor{blue}{-1}};
    \node (w12) [right of=x7, yshift=-0cm, xshift= -0.2cm] {\textcolor{blue}{1}};      

    \node[square] (x8) [right of=x1, yshift=-1cm, xshift= 2cm] {A};
    \node[square] (x9) [draw=red, below of=x8, thick] {B};
    \node[square] (x10) [below of=x9] {C};
    \node[square] (x11) [below of=x10] {D};
    \node[square] (x12) [below of=x11, draw=blue, thick] {E};

    \node (c1) [right of=x8, yshift=0.1cm, xshift= -0.2cm] {[1, 2]};
    \node (c2) [right of=x9, yshift=0.1cm, xshift= -0.2cm] {[1, 2]};
    \node (c3) [right of=x10, yshift=0.2cm, xshift= -0.2cm] {[1, 1]};
    \node (c4) [right of=x11, yshift=-0.1cm, xshift= -0.2cm] {[0, 2]};
    \node (c5) [right of=x12, yshift=-0.1cm,xshift= -0.2cm] {[0, 2]};

    \node[round] (xs) [right of=x8, yshift=-2cm, xshift= 1.5cm]      {s};
    
    %%%

    \draw[flecheG] (x1.west) -- (xt);
    \draw[flecheG] (x2.west) -- (xt);
    \draw[flecheG] (x3.west) -- (xt);
    \draw[flecheG] (x4.west) -- (xt);
    \draw[flecheG] (x5.west) -- (xt);
    \draw[flecheG] (x6.west) -- (xt);
    \draw[flecheG] (x7.west) -- (xt);

    \draw[flecheG] (xs) -- (x8.east);
    \draw[flecheG] (xs) -- (x9.east);
    \draw[flecheG] (xs) -- (x10.east);
    \draw[flecheG, blue, thick] (xs) -- (x11.east);
    \draw[flecheD, blue, thick] (xs) -- (x12.east);

    \draw[flecheG, red, thick] (x8) -- (x1);
    \draw[flecheG] (x8) -- (x2);
    \draw[flecheD, red, thick] (x8) -- (x3);
    \draw[flecheD] (x8) -- (x4);

    \draw[flecheD, red, dashed, thick] (x9) -- (x1);
    \draw[flecheD] (x9) -- (x2);
    \draw[flecheG, red, thick] (x9) -- (x3);
    \draw[flecheG] (x9) -- (x4);

    \draw[flecheG] (x10) -- (x5);

    \draw[flecheG] (x11) -- (x6);
    \draw[flecheG, blue, thick] (x11) -- (x7);
    \draw[flecheD, blue, thick] (x12) -- (x7);

    \end{tikzpicture} 
    \caption{Example of computation of the consistency for the arcs ($E$, $Julia$) and ($B$, $Peter$). The value $B$ is not consistent with $Peter$. Thus, the dotted arc can be removed from the graph.}
    \label{fig:exempleArcConsistance}
\end{figure}