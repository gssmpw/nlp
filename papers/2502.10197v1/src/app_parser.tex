\section{Parser Details}\label{app:parser}
The parser is designed to parse as many outputs as possible while still enabling specific feedback to the model in case of errors. We give a high-level overview of the implementation here, and refer to the code repository for the full implementation.

The model solution always appears in a boxed environment, which is the only part of the model output that is parsed. If no boxed environment is found in the model solution, the parser throws the following error:
\begin{verbatim}
No \boxed content found in solution. Final solution needs to be encased in \boxed{}.
\end{verbatim}
The input is then sanitized by removing any extraneous characters, common sequences for formatting brackets (like \textbackslash left and \textbackslash right), and other common formatting characters.  

The parser differentiates between five primitive types (Integers, Floats, Fractions, Strings, and LaTeX Expressions), and two composite types (Lists and Matrices). The correct primitive type is automatically extracted from the model solution. By verifying any primitive type that gets extracted from the model solution matches this primitive type, we can ensure that the model has correctly formatted its solution. For instance, one of the most common errors is the use of "$\dots$" in a model solution. If a parser encounters this string anywhere in the solution for a primitive type that is different than Strings, it will return the following error:
\begin{verbatim}
Expected a primitive int/float/parseable LaTeX expression, but got '\dots'
\end{verbatim}
Note that the same error will occur even if the dots appears anywhere in a matrix or list.

For composite types, the parser recursively parses the contents of the boxed environment. Lists are parsed by splitting the contents of the boxed environment by commas, newlines or \& characters. We recursively extract the first element of the list. To prevent splitting on the wrong character, we check if the extracted first element is a valid primitive, list, or matrix. If not, the first element expands to the next comma, newline, or \& character and we repeat the process. 

Matrices are parsed by checking for any \LaTeX{}  environment that contains an array or matrix. Results are then extracted by splitting the matrix by '\textbackslash\textbackslash' and parsing each row as a List.

Finally, we found that a lot of the models add unnecessary brackets in their solutions (\eg writing '((1,2,3))' to represent '1,2,3'). To prevent this from causing errors in the verifier, we automatically extract the expected list depth from the verifier's solution and match this depth with the model's solution. If the model's solution has an unexpected depth that can not be easily converted, the parser will return the following error:
\begin{verbatim}
Failed to match correct depth {depth} for '{parsed_answer}'
\end{verbatim}
This entire procedure was then tested using a variety of model outputs in unit tests to ensure that the parser can handle a wide range of model outputs. Furthermore, in a lot of our model runs, we manually verified the parser's output to ensure that it was working correctly. This gives us high confidence that model performance does not depend on the parser's behavior.
