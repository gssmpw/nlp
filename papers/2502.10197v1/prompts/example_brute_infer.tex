\begin{system}{System}
You are an expert mathematician that solves problems using a brute-force approach and logical inference. You approach mathematical problems by first solving them in a brute-force manner for 
smaller cases if necessary and then generalizing your findings to solve the problem itself. In order to solve the problem, you need to progress in a series of steps. In each step, you can execute a Python code block to test your current idea.

Make sure to abide by the following rules:

    1. You should write the code in a Python code block starting with '```python' and ending with
    the '```' sequence followed by the end of your response. 
    2. Try to solve the problem in a brute-force manner for smaller cases (or for the case itself if possible) and then generalize your findings to solve the problem itself. Try to find patterns, relationships, or properties that can help you solve the problem.
    3. After you have written your code, you can stop your output. The user will execute your code and give you the results. If the result was successful, you can then format the response accurately.
    4. In your Python code, you can use 'print()' to save whatever important information you will then need to format your final reply. The user will then execute your code in a Python environment.
\end{system}

\begin{prompt}{User}
A divisor $d$ of a positive integer $n$ is said to be a close divisor of $n$ if $\sqrt{{60}} < d < 2\sqrt{{60}}$\Find a positive integer with exactly 60 close divisors.

Format your reply as follows:
Output the answer as an integer inside of $\boxed{...}$. For example $\boxed{123}$.\Your answer can contain mathematical operations using valid LaTeX notation.
\end{prompt}

\begingroup\raggedleft
\begin{gpt}{\gptheader}
    To solve this problem, we need to find a positive integer $n$ such that the number of its divisors $ d $ satisfying $ \sqrt{n} < d < 2\sqrt{n} $ is exactly 60. \\Let's break down the problem:
    
    1. **Range of Divisors**: We need to consider divisors within the range $ \sqrt{n} < d < 2\sqrt{n} $.
    2. **Counting Divisors**: We will have to ensure that there are exactly 60 divisors in this range
    3. **Choosing $ n $**: We must select $ n $ such that this condition is satisfied.\end{itemize}

    To find such an $ n $, we can explore integers for small values and see if they satisfy the condition. Let's attempt to brute-force this for a smaller test case first, by examining possible candidates for $ n $.
    
    ```
    import math # Function to calculate the number of close divisors
    
    def count_close_divisors(n):
        sqrt_n = math.sqrt(n)
        close_divisors = [d for d in range(1, n + 1) if n \% d == 0 and sqrt_n < d < 2 * sqrt_n]
        return len(close_divisors) # Brute-force search for the integer n 
        target_close_divisors = 60
        for n in range(1, 10**6):    
            if count_close_divisors(n) == target_close_divisors:
                print(n)\\        
                break\\
    ```
    
    This code attempts to find the smallest $ n $ with exactly 60 close divisors by iterating over possible $ n $ values, counting their close divisors, and stopping when the target number of close divisors is reached. 
    You can run the code to see the result.
\end{gpt}
\endgroup

\begin{prompt}{User}
    Code Output:\\```TimeOutError: exceeded 120.0 seconds timeout.```\\
\end{prompt}

\begingroup\raggedleft
\begin{gpt}{\gptheader}
    To address the timeout issue, we should focus on optimizing our approach instead of brute-forcing through all integers. Let's use the properties of divisors to narrow down our search.

    ### Understanding the Divisors
    
    For a number $ n $, the total number of divisors is determined by its prime factorization. If $ n = p_1^{a_1} p_2^{a_2} \cdots p_k^{a_k} $, then the number of divisors $ d(n) $ is given by:
    $$ d(n) = (a_1 + 1)(a_2 + 1) \cdots (a_k + 1) $$
    
    ### Range for Close Divisors
    
    We want to find numbers whose divisors satisfy $ \sqrt{n} < d < 2\sqrt{n} $. If $ n $ has $ d(n) $ total divisors, the close divisors lie around the middle of its divisor list. If we need exactly 60 close divisors, it is reasonable to consider numbers with larger total divisors count and check their properties.
    
    ### Revised Approach
    
    We will:
        1. Consider numbers with high total divisors.
        2. Use combinations of small primes to achieve a high number of total divisors.
        3. Calculate close divisors for these numbers efficiently.
        
    Let's try an approach using a more structured exploration of numbers with significant numbers of divisors:
    ```python
    import math
    from sympy import primefactors 
    
    # Function to calculate all divisors of n
    def divisors(n):\
       divs = []
       for i in range(1, int(math.sqrt(n)) + 1):
            if n \% i == 0:
                divs.append(i)
                if i != n // i:
                    divs.append(n // i)
        return sorted(divs)
        
    # Optimized search for n
    def find_integer_with_60_close_divisors():
        primes = [2, 3, 5, 7, 11, 13]
        max_divisors = 0    
        best_n = 0    
        # Iterate over some product of primes raised to powers    
        for a1 in range(1, 5):        
            for a2 in range(1, 5):
                for a3 in range(1, 5):
                    for a4 in range(1, 5):                    
                        for a5 in range(1, 5):                        
                            for a6 in range(1, 5):                            
                                n = (primes[0]**a1) * (primes[1]**a2) * (primes[2]**a3) * (primes[3]**a4) * (primes[4]**a5) * (primes[5]**a6)                            
                                divs = divisors(n)                            
                                sqrt_n = math.sqrt(n)                            
                                close_divs = [d for d in divs if sqrt_n < d < 2 * sqrt_n]                           
                                if len(close_divs) == 60:                               
                                    return n
    result = find_integer_with_60_close_divisors()
    print(result)
    ```
    
    In this approach, we use combinations of the first few small primes raised to small powers to efficiently search for $ n $. Each configuration of powers is evaluated to see if it results in exactly 60 close divisors. You can run this code to find $ n $.
\end{gpt}
\endgroup

\begin{prompt}{User}
    Code Output: 6985199471250
\end{prompt}

\begingroup\raggedleft
\begin{gpt}{\gptheader}
    The code has successfully found a positive integer with exactly 60 close divisors. 
    Therefore, the positive integer we are looking for is $\boxed{6985199471250}$
\end{gpt}


\endgroup
