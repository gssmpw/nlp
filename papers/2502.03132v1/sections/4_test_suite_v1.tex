\section{\spark Suite Options}
\label{sec: suite_options}


\begin{figure}[htbp]
    \centering
    \vspace{2.5cm}  % Optional vertical space
    \begin{tikzpicture}[transform canvas={xshift=0cm}] 
        % Define image size and spacing
        \def\imgwidth{8cm}  % Image width

        % Single figure for system framework
        \node at (0, 0) {\includegraphics[width=\imgwidth]{figure/system/spark_suite.pdf}};
    \end{tikzpicture}
    \vspace{2.3cm}
    \caption{\spark Suite Options.}
    \label{fig:Suite}
\end{figure}
In addition to the safe control library, \spark offers users a comprehensive testing option suite to evaluate the performance of various safe controllers, which is shown in \Cref{fig:Suite}. In this use case, we leverage \spark's composability to extract two types of Unitree G1 configurations from the Configuration Module and retrieve the simulation agent from the Agent Module. In the Task Module, we combine different goals and constraints to generate benchmarks. The Policy Module is then used for control, followed by an analysis of the performance of different algorithms within the Safety Module.
\subsection{Configuration Options} 

As the humanoid robot represents a highly nonlinear and complex system, \spark provides users with predefined robot configurations based on the Unitree G1 humanoid robot. 
The simulations define the robots using MuJoCo XML files.  

The testing suite includes \textbf{2} types of robot configurations in the benchmark environments:  


\textbf{G1FixedBase:} As shown in \Cref{fig:Suite} (4), this robot configuration consists of \textbf{17} Degrees of Freedom (DoFs), including 7 DoFs for each arm and 3 DoFs for the waist. The pelvis of the robot is fixed relative to the world frame. The setup is designed to help users analyze the performance of safe controllers specifically for the robot manipulators.  



\textbf{G1WholeBody:} \Cref{fig:Suite} (5) illustrate the robot configuration which includes \textbf{20} Degrees of Freedom (DoFs), comprising 17 DoFs for the upper body and an additional 3 DoFs for base motion. The base motion is modeled as a floating base in the world frame, with the 3 DoFs representing x-axis velocity, y-axis velocity, and yaw rotational velocity relative to the robot's base frame. This setup is designed to help users evaluate the capabilities of safe controllers for a humanoid robot with both locomotion and manipulation DoFs. The floating base configuration decouples the upper body’s movement from lower body locomotion, enabling the analysis of whole-body safety without interference from locomotion perturbations.

The definitions of the robot configurations are listed in \Cref{appendix: robot_config}


\begin{figure}[htbp]
    \centering
    \vspace{2cm}  % Optional vertical space
    \begin{tikzpicture}[transform canvas={xshift=0cm}] 
        % Define image size and spacing
        \def\imgwidth{4.5cm}  % Image width

        % Single figure for whole body
        \node at (0, 0) {\includegraphics[width=\imgwidth]{figure/simulation/whole_body_v1.png}};
    \end{tikzpicture}
    \vspace{2.2cm}
    \caption{\spark whole body task environment.}
    \label{fig: whole_body}
\end{figure}

\subsection{Agent Options}
Our testing suite includes two types of agents: a simulation agent and a real robot agent, both of which support the configurations specified in the configuration options. We used a Unitree G1 humanoid robot, for which \spark provides an interface in the agent module. G1 humanoid physically features 29 DOFs, but we modeled it as a 20 DOF mobile dual-manipulator system by simplifying the locomotion.
For the upper body dynamics, each arm was treated as a general manipulator with seven DOFs, while the waist was equipped with three rotational joints (roll, pitch, yaw).
Regarding locomotion, three DOFs were considered: longitudinal, lateral, and rotational in the humanoid's body frame. 
Table~\ref{tb: tasks} in the Appendix shows the detailed configuration for the G1 humanoid.

\subsubsection{\textbf{Simulation Agent}}
As shown in \Cref{fig:Suite} (7). The simulation agent is implemented based on MuJoCo and serves as a benchmark tool for evaluating algorithm performance. Within the simulation environment, users can access the agent's position, joint positions, and other relevant states, facilitating the implementation of various control algorithms.
\subsubsection{\textbf{Real Robot Agent}}
As shown in \Cref{fig:Suite} (6). In the real robot agent, users can access low-level interfaces to read the robot's joint position data. Within the testing suite, we utilize Unitree's high-level control API to achieve raw pitch and yaw movements on a 2D plane.

\subsection{Task Options}  
The testing suite of \spark provides predesigned tasks to generate reference controls, enabling the evaluation of safe controllers under various scenarios.  
\subsubsection{Task Objectives Options}
To simulate manipulation and navigation tasks, \spark provides test suites with \textbf{two} types of goal configurations:


% \textbf{Static Goal:} 
% This task requires the robot to reach static 3D goal positions with each hand. If the robot has DoFs for movement within the 2D plane, it must also navigate to a 2D goal position. Once a goal is reached, its location is randomly reset.  

\textbf{Arm Goal:} 
As shown in \Cref{fig:Suite} (8). This goal is used to simulate the manipulation scenario in simulation. The task requires the robot to reach designated static 3D target positions with each hand while ensuring precise and safe movement.

\textbf{Base Goal:}
As shown in \Cref{fig:Suite} (9). This goal is used to simulate the navigation scenario in simulation. The task requires the robot to autonomously navigate to a specified 2D goal position while ensuring safe movement and avoiding obstacles in the environment.


% \textbf{Dynamic Goal:}  
% This task involves a similar goal-reaching setup, but with dynamic goal positions for both the arms and the base. It is designed to simulate scenarios where the robot must perform collision avoidance while actively tracking moving target goals.  

In addition to the above two types of goals, users can also configure \textbf{Goal Motion}, which includes static and dynamic options. The goals for the arms and the robot base are marked in green spheres in \Cref{fig: whole_body}. 
\subsubsection{Task Constrains Options}
To represent collision volumes and evaluate safety performance, \spark provides test suites with \textbf{three} simple yet general constraint configurations:  

% \textbf{Static Obstacle:}  
% Static obstacles are dangerous 3D areas that the robot must avoid. These obstacles are represented as floating spheres that are trespassable, with penalties applied when the robot enters them.  

% \textbf{Dynamic Obstacle:}  
% Dynamic obstacles are moving 3D areas that the robot must avoid. These obstacles are also represented as floating spheres that are trespassable and can be configured to move randomly according to specific patterns (e.g., Brownian motion).  

\textbf{Obstacle Shape:}
Various obstacle shapes are provided, including circles and rectangles. Circular obstacles can be used to represent key points of certain objects, while rectangular obstacles are suitable for depicting tables or other square-shaped objects.

\textbf{Obstacle Motion:}
Obstacles can be either static or dynamic. Both types are represented as floating spheres that the robot must avoid. Trespassing incurs penalties. Static obstacles remain fixed, while dynamic obstacles move based on predefined patterns, such as Brownian motion.

\textbf{Obstacle Number:}
Users have the flexibility to control the number of obstacles within a task. For example, in our experiments, configuration v1 represents a scenario with 10 obstacles, whereas v0 corresponds to a denser environment with 50 obstacles. 


The collision volumes of the robot and the environment obstacles are marked in \Cref{fig: whole_body}. \Cref{appendix: collision_config} reports the configuration of the robot collision volumes.

\subsubsection{Task Interface Options}
Different agents can utilize distinct interfaces. For the Simulation Agent, users can control the position of obstacles using a keyboard, allowing for flexible and interactive environment adjustments within the simulation. In contrast, the Real Robot Agent leverages Apple Vision Pro to track human hand positions in real time, treating them as dynamic obstacles. This enables the real robot to perceive and react to obstacles in its environment, enhancing its ability to perform collision avoidance in real-world scenarios.

\subsection{Policy Options:}
We achieve humanoid locomotion tasks using PID control and implement manipulation tasks through a combination of PID control and inverse kinematics (IK). However, the choice of policy is not limited, as \spark supports user-defined policies, including data-driven approaches. Additionally, users can replace the standalone safety module with an end-to-end safe reinforcement learning policy, further demonstrating the extensibility of \spark. Since the model based safe controllers are the primary focus of \spark, we leave the integration of more complex control policies for future work.

\subsection{Safety Options:}

The safe controller of \spark is aimed at achieving both efficient and safe interaction with the environment by solving the following safe control problem:
\begin{align}\label{eq:safe_control_problem}
\minimizewrt{\mathbf{u}}~~ & \|\mathbf{u} - \mathbf{u}_{\text{ref}} \|^2_{\mathbf{Q}_\mathbf{u}}   \\ \nonumber
\st~~ & \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}) + \mathbf{g}(\mathbf{x})\mathbf{u} \\ \nonumber
& \mathbf{x} \in \Xb_\mathrm{s}
\end{align}
where $\mathbf{x} \in \cX \subseteq \mathbb{R}^{N_\xb}$ represents the system state, and $\mathbf{u} \in \cU \subseteq \mathbb{R}^{N_\ub}$ is the control variable corresponding to the $N_\ub$ degrees of freedom. $\mathbf{Q}_\mathbf{u}$ represents the cost matrix corresponding to $\mathbf{u}$. $\dot{\mathbf{x}} =\mathbf{f}(\mathbf{x}) + \mathbf{g}(\mathbf{x})\mathbf{u}$ denotes the system dynamics, and $\Xb_\mathrm{s}$ is the set of safe system states. At each timestep, the objective of the control problem is to track the reference control $\mathbf{u}_{\text{ref}}$ given by a nominal controller while satisfying both the system dynamic constraints and the safety constraints.  

The safe control of humanoid robots faces two major challenges: complex dynamics and dexterous safety. Humanoids integrate mobile robotics and dual-arm manipulation, resulting in a high-dimensional, nonlinear system where the coupling of uncertain legged locomotion and high-DOF arm movements significantly increases control complexity. While some degrees of freedom (DOFs) operate independently, others—such as those affecting localization—impact the entire system, making precise tracking and safe motion in Cartesian space difficult. Beyond dynamic constraints, safety considerations further complicate control. Humanoids must navigate confined spaces, carefully adjusting their poses to avoid collisions with obstacles and themselves. Modeling at a limb level rather than a whole-body level is essential, but this introduces combinatorial safety constraints, creating a highly nonconvex safe state space that challenges real-time safety assurance.


To address these challenges, \spark provides five different safety algorithms to ensure safe control.

\subsubsection{Safe Set Algorithm}
Proposed by \cite{liu2014control}, Safe Set Algorithm (SSA) introduces a continuous, piecewise smooth energy function $\phi \defeq \cX \mapsto \RR$, or safety index, to quantify safety while considering the system dynamics.
An $n^\mathrm{th}$ ($n\geq 0$) order safety index $\phi_n$ has the following general form:
\begin{equation}\label{def:phi_recursive}
    \begin{aligned}
        \phi_n &= (1+a_1 s)(1+a_2 s)\dots(1+a_n s)\phi_0,
    \end{aligned}
\end{equation}
where $s$ is the differentiation operator.
\eqref{def:phi_recursive} can also be expanded as
\begin{equation}\label{def:phi_root}
    \phi_n \defeq \phi_0 + \textstyle\sum_{i=1}^{n}k_i \phi^{(i)}_0.
\end{equation}
where $\phi_0^{(i)}$ is the $i^\mathrm{th}$ time derivative of $\phi_0$.
$\phi_n$ should satisfy that (a) the characteristic equation $\prod_{i=1}^n(1+a_i s) = 0$ only has negative real roots to prevent overshooting of $\phi_0$ and (b) $\phi_0^{(n)}$ has relative degree one to the control input $\ub$.

Ensuring humanoid safety involves solving optimal control problems with multiple safety constraints due to the limb-level modeling of the robot. To address this challenge, \spark extends the single-constraint safe control problem described in \cite{liu2014control} to handle multi-constraint cases by allowing the safe set of system states, $\Xb_\mathrm{s}$, to be defined by $M \geq 1$ energy functions $\phi$.  
Formally, the safe set is defined as:  
\begin{equation}
    \Xb_\mathrm{s} \coloneqq \{\xb \in \cX \mid \phi[i](\xb) \leq 0,~\forall i \in [M]\}.
\end{equation}  

Replacing the original safety constraint $\xb \in \Xb_\mathrm{s}$ in \eqref{eq:safe_control_problem}, the generalized safe control problem solved by \spark is written as:  
\begin{align}\label{eq:safe_control_problem_spark}
    \minimize_{\mathbf{u}}~~ & \|\mathbf{u} - \mathbf{u}_{\text{ref}} \|^2_{\mathbf{Q}_\mathbf{u}} \\ \nonumber
    \st~~ & \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}) + \mathbf{g}(\mathbf{x})\mathbf{u}, \\ \nonumber
    & \forall i \in [M],~ \dot{\phi}[i](\xb, \ub) \leq -\eta \quad \text{if} \quad \phi[i](\xb) \geq 0.
\end{align}  

Where $\eta$ is a positive constant. It can be shown that under the control constraints in \eqref{eq:safe_control_problem_spark}, a safe set $\Xb_\mathrm{safe} \subseteq \Xb_\mathrm{s}$ can still be identified. Within this set, both the forward invariance and the finite-time convergence properties are satisfied, ensuring theoretical safety guarantees \cite{chen2023safetyindexsynthesisstatedependent}.


\subsubsection{Control Barrier Function}

The Control Barrier Function (CBF) method \cite{ames2019control} enforces safety constraints continuously by ensuring that  $\dot{\phi} < -\alpha(\phi)$,
where $\alpha: \mathbb{R} \to \mathbb{R}$ is a strictly increasing function with $\alpha(0) = 0$.  

In its simplest form, $\alpha$ can be chosen as a positive constant $\lambda$, leading to a straightforward implementation. When considering multiple safety constraints, the safe control problem solved using CBF can be formulated as:

\begin{align}\label{eq:safe_control_problem_cbf}
    \minimize_{\mathbf{u}}~~ & \|\mathbf{u} - \mathbf{u}_{\text{ref}} \|^2_{\mathbf{Q}_\mathbf{u}} \\ \nonumber
    \st~~ & \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}) + \mathbf{g}(\mathbf{x})\mathbf{u}, \\ \nonumber
    & \forall i \in [M],~ \dot{\phi}[i](\xb, \ub) \leq -\lambda \phi[i](\xb).
\end{align}  

As a result, CBF may always deviate from the reference control input $\mathbf{u}_{\text{ref}}$, even when it is safe, i.e., $\phi[i] < 0$. In such cases, the control input may lead to an increase in the safety index $\phi[i]$, potentially reducing efficiency.  

\subsubsection{Sublevel Safe Set Algorithm}

The Sublevel Safe Set (SSS) algorithm \cite{wei2019safe} combines the strengths of SSA and CBF to address their respective limitations. It solves the following safe control problem:  
\begin{align}\label{eq:safe_control_problem_sss}
    \minimize_{\mathbf{u}}~~ & \|\mathbf{u} - \mathbf{u}_{\text{ref}} \|^2_{\mathbf{Q}_\mathbf{u}} \\ \nonumber
    \st~~ & \dot{\mathbf{x}} = \mathbf{f}(\mathbf{x}) + \mathbf{g}(\mathbf{x})\mathbf{u}, \\ \nonumber
    & \forall i \in [M],~ \dot{\phi}[i](\xb, \ub) \leq -\lambda \phi[i](\xb) \quad \text{if} \quad \phi[i](\xb) \geq 0.
\end{align}  

In the SSS algorithm, the control correction is only applied when $\phi[i](\xb) \geq 0$, allowing for a more efficient correction compared to CBF. Since the constraint is inactive when $\phi[i](\xb) < 0$, the robot achieves better performance while tracking the reference control input $\mathbf{u}_{\text{ref}}$.  

\subsubsection{Potential Field Method}

PFM \cite{khatib1986real} computes the control input $\mathbf{u}$ indirectly by first deriving a Cartesian-space control input $\mathbf{u}_{\text{c}}$. By defining the function $\mathbf{c}_r = \mathbf{h}(\mathbf{x})$, which calculates the closest point on the robot to the obstacles, the Cartesian-space dynamics can be written as:
\begin{equation}
    \dot{\mathbf{c}}_r = \mathbf{u}_{\text{c}} := \mathbf{u}_{\text{c-ref}} + \mathbf{u}_c^*,
\end{equation}
where $\mathbf{u}_{\text{c-ref}}$ is the reference control in the Cartesian space transformed from $\mathbf{u}_{\text{ref}}$ via:
\begin{equation}
    \mathbf{u}_{\text{c-ref}} = \nabla{\mathbf{h}}(\mathbf{x}) \mathbf{f}(\mathbf{x}) + \nabla{\mathbf{h}}(\mathbf{x}) \mathbf{g}(\mathbf{x}) \mathbf{u}_{\text{ref}}.
\end{equation}
The term $\mathbf{u}_c^*$ represents a repulsive "force" added to the reference $\mathbf{u}_{\text{c-ref}}$ to push the robot away from the obstacles whenever the safety constraint is violated. Specifically:
\begin{equation}
    \mathbf{u}_c =
    \begin{cases} 
        \mathbf{u}_{\text{c-ref}} - c_1 \nabla \tilde{\phi} & \text{if } \tilde{\phi}(\mathbf{c}_r) \geq 0, \\
        \mathbf{u}_{\text{c-ref}} & \text{otherwise},
    \end{cases}
\end{equation}
where $c_1 > 0$ is a tunable constant and $\tilde{\phi}(\mathbf{c}_r)$ is the energy function with respect to the Cartesian point $\mathbf{c}_r$. Finally, the equivalent control input $\mathbf{u}$ in the configuration space is derived from $\mathbf{u}_c$.

\subsubsection{Sliding Mode Algorithm}

SMA \cite{gracia2013reactive} ensures safety by maintaining the system state around a sliding layer defined by $\phi = 0$ whenever the safety constraint is violated. 

For a single safety index $\phi$, its gradient can be decomposed as:
\begin{align}
    \dot{\phi}(\mathbf{x}) &= \nabla \phi^\top(\mathbf{x}) \dot{\mathbf{x}} \\ \nonumber
    &= \nabla \phi^\top(\mathbf{x}) \big( \mathbf{f}(\mathbf{x}) + \mathbf{g}(\mathbf{x}) \mathbf{u} \big) \\ \nonumber
    &= \underbrace{\nabla \phi^\top(\mathbf{x}) \mathbf{f}(\mathbf{x})}_{L_\mathbf{f} \phi} + \underbrace{\nabla \phi^\top(\mathbf{x}) \mathbf{g}(\mathbf{x})}_{\mathbf{L}_\mathbf{g} \phi} \mathbf{u},
\end{align}
where the term $\mathbf{L}_\mathbf{g} \phi$ represents the sensitivity of the safety index $\phi$ to the control input $\mathbf{u}$.

To handle multiple constraints, \spark considers only the most unsafe safety index, denoted as $\phi_{\max}$, and corrects the reference control input as follows:
\begin{align}
    \mathbf{u} = 
    \begin{cases} 
        \mathbf{u}_{\text{ref}} - c_2 \mathbf{L}_\mathbf{g} \phi_{\max}^\top & \text{if } \phi_{\max} \geq 0, \\
        \mathbf{u}_{\text{ref}} & \text{otherwise},
    \end{cases}
\end{align}
where the constant $c_2 > 0$ is set sufficiently large to ensure that:
\begin{equation}
    \dot{\phi}_{\max} = L_\mathbf{f} \phi_{\max} + \mathbf{L}_\mathbf{g} \phi_{\max} \mathbf{u} - c_2 \|\mathbf{L}_\mathbf{g} \phi_{\max}\|^2 < 0.
\end{equation}

By doing so, SMA ensures that the system remains in a safe state while effectively handling multiple constraints.

\subsection{Evaluation metrics}\label{subsec:evaluation_metrics}

\spark provides four metrics to assess the performance of various safe control methods across different benchmark scenarios, evaluating both their safety and efficiency:
\begin{itemize}
    \item Step-wise average arm goal tracking score $J_{arm}$.
    \item Step-wise average base goal tracking score $J_{base}$.
    \item Step-wise average self safety score $M_{self}$.
    \item Step-wise average environment safety score $M_{env}$.
\end{itemize}

Formally,

\begin{align}
    &J_{arm} =\frac{1}{T}\sum_{t=0}^T \mathcal{G}(\Delta d_{arm}, \sigma_{arm}), \Delta d_{arm} \geq 0\label{eq: arm goal score}\\ 
    &J_{base} =\frac{1}{T}\sum_{t=0}^T \mathcal{G}(\Delta d_{base}, \sigma_{base}), \Delta d_{base} \geq 0\label{eq: base goal score}\\
    &M_{self} =\frac{1}{T}\sum_{t=0}^T \mathcal{G}(\Delta d_{self},\sigma_{self}), \Delta d_{self} \leq 0\label{eq: self safety score}\\
    &M_{env} =\frac{1}{T}\sum_{t=0}^T \mathcal{G}(\Delta d_{env} ,\sigma_{env}), \Delta d_{env} \leq 0\label{eq: environment safety score}\\ \nonumber
\end{align}
% \input{sections/param_tuning}


where $\Delta d_{arm}$ is the distance from the robot's hands to the corresponding goals, $\Delta d_{base}$ is the distance from the robot's pelvis to the corresponding base goal, $\Delta d_{env}$ is the violated distance between the robot and obstacles, and $d_{self}$ is the violated distance between the robot's collision volumes. 

$\mathcal{G}$ is the goal tracking score function, which converts the distance into a score within the range $[0, 1]$. The closer the distance to $0$, the higher the score. 

The score function is defined as follows:
\begin{align}
    &\mathcal{G}(\Delta d, \delta) = 
    \exp\bigg[-\frac{\Delta d^2}{\sigma}\bigg]
\end{align}


To demonstrate the versatility of the \spark framework, we deploy its safe control pipelines across various use cases. 
The agents range from a simulated humanoid robot to the real Unitree G1 humanoid robot, while the task inputs vary from autonomous target trajectories to teleoperation commands. Additionally, the environments span from static confined spaces to dynamic human-robot interaction scenarios. 
The various use cases are designed to serve multiple purposes, including benchmarking safe control algorithms \ref{sec: usecase_benchmark}, deploying them on real robots \ref{sec: usecase_safe_auto_real}, enabling safe teleoperation for human-robot interaction (HRI) scenarios \ref{sec: usecase_safe_teleop_real}, and allowing users to teleoperate a simulated robot with visual feedback \ref{sec: usecase_safe_teleop_sim}. The details of each use case, along with their corresponding sections, are outlined in \Cref{appendix:agent_task}



\input{table_template/tables/eva_full_table}
