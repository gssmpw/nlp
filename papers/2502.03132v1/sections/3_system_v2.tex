\section{\spark's Framework for Testing, Benchmarking, Development and Deployment}

In this section, we begin by outlining the various components that form safety-critical robotic scenarios. Next, we introduce \spark's modular framework. Finally, we show how the framework of \spark aligns with the principles outlined in Section~\ref{sec: introduction}.

\subsection{Components of a Safety-Critical Robotic Scenario}
\label{sec: syetem_component}

To fully appreciate the design of the \spark framework, we must first define the system-level components that constitute a safety-critical robotic scenario. 
The intricate interdependencies among these components directly influenced the design choices for the \spark framework, discussed in Section~\ref{sec: spark_framework}. 
By understanding how these components interact, we crafted a solution that streamlines the synthesis of safe controllers, ensuring that the framework is both composable and extensible. 
This approach not only simplifies the process of safe controller synthesis for users but also guarantees that the framework can be seamlessly deployed across a variety of safety-critical robot scenarios.
Below, we introduce our definitions for \textit{system state}, \textit{system dynamics}, \textit{system objectives}, \textit{system measurements}, and \textit{system controller}. 
While some of these definitions echo conventional control theory, others have been adapted to more precisely capture the nuances of safe controller synthesis procedure.

\paragraph{\textbf{System State}} includes the robot's internal state, such as a humanoid's joint positions and locomotion velocity, as well as the external state, which encompasses information about obstacles and human participants. 
The \textit{system state} can be obtained from either a simulated environment or the real physical world.

\paragraph{\textbf{System Dynamics}} encompass both the robot's internal dynamics and the external dynamics that influence its operation. 
It is important to note that the \textit{system dynamics} defined here are user-defined models rather than the true dynamics of the real world. 
In practice, capturing the complete complexity of real-world dynamics is infeasible.
These models, whether formulated analytically or derived from data, approximate the real world and are tailored for use by the \textit{system controller}, though they may differ from the actual dynamics.\footnote{This distinction is crucial to avoid confusion with the traditional control theory interpretation, where ``system dynamics'' typically refer to the system's true behavior.}

\paragraph{\textbf{System Objectives}} encompass both task-specific targets, such as following a trajectory or reaching a designated point, and safety constraints, such as ensuring obstacle avoidance. 
These \textit{system objectives} can be derived from pre-coded autonomy programs and user-defined safety criteria. 
Additionally, they may originate from user inputs, such as teleoperator gestures, or be generated by a Large Language Model (LLM)-based task planner.

\paragraph{\textbf{System Measurements}} provide the information about the system state to the controller.
By interfacing with external sensors, \textit{system measurements} capture details such as obstacle shape, number, and location, along with the goal positions.

\paragraph{\textbf{System Controller}} encompasses robot algorithms that optimize the control inputs for the robot based on the \textit{system dynamics}, \textit{system objectives}, and the \textit{system measurements}. 
It ensures that the robot operates efficiently while maintaining safety and achieving task-specific goals.

\begin{figure}[htbp]
    \centering
    \vspace{2cm}  % Optional vertical space
    \begin{tikzpicture}[transform canvas={xshift=0cm}] 
        % Define image size and spacing
        \def\imgwidth{8cm}  % Image width

        % Single figure for system framework
        \node at (0, 0) {\includegraphics[width=\imgwidth]{figure/system/system_components.png}};
    \end{tikzpicture}
    \vspace{2cm}
    \caption{System components of a safety-critical robotic scenario and their interdependencies. $A\rightarrow B$ translates to ``$B$ depends on $A$''.}
    \label{fig: system_components}
\end{figure}

Designing safe controllers for specific robot scenarios can be challenging due to the complex interdependencies among the system components as described above and shown in Figure~\ref{fig: system_components}. 
\textit{System controller} heavily depends on the \textit{system measurements} to estimate the \textit{system state}, \textit{system objectives} to inform its optimization process, and \textit{system dynamics} to model the effect of its control actions.
\textit{System measurements} are intrinsically dependent on the \textit{system state}, aiming to approximate it through sensor data.
By contrast, \textit{system state}, \textit{system objectives}, and \textit{system dynamics} are relatively self-contained and do not depend on other components. 

Recognizing these differences suggests a structured approach to reduce complexity. 
Considering these interdependencies, we designed the \spark framework to be easily composable and extensible, thereby facilitating uniform, modular safe controller synthesis across different robotic scenarios.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Framework of \spark}\label{sec: spark_framework} 

To facilitate the decomposition and integration of the components discussed in \Cref{sec: syetem_component}, we present the \spark framework, as shown in Figure~\ref{fig:system_framework}, offering users a collection of modular Python class templates designed to streamline the synthesis, testing, benchmarking, development, and deployment of safe controllers for robotic systems. 

\begin{figure}[htbp]
    \centering
    \vspace{2.5cm}  % Optional vertical space
    \begin{tikzpicture}[transform canvas={xshift=0cm}] 
        % Define image size and spacing
        \def\imgwidth{\linewidth}  % Image width

        % Single figure for system framework
        \node at (0, 0) {\includegraphics[width=\imgwidth]{figure/system/spark_sys_framework.pdf}};
    \end{tikzpicture}
    \vspace{2cm}
    \caption{\spark system framework.}
    \label{fig:system_framework}
\end{figure}


%[NEED TO INCLUDE THE KEYWORDS ON COMPOSABLE, EXTENSIBLE, DEPLOYABLE.]

The \spark framework is structured around the decomposition of system components into distinct modules that allow efficient handling of system states, measurements, objectives, dynamics, and controllers. 
This modularity, inspired by the relationships established in Section~\ref{sec: syetem_component}, enables composable, extensible, and deployable safe controller design. 

We first introduce the \textbf{Configuration} module which supports all other modules.

\paragraph{\textbf{Configuration Module}} houses \textit{system dynamics}, encapsulating robot-specific configurations such as degrees of freedom, motor interfaces, and system models. 
It provides essential context for other modules and enables the incorporation of robot-specific details, making it essential for defining and customizing dynamics within \spark. 

\textbf{Environment}, composed of \textbf{Agent} and \textbf{Task} modules, is the ``front-end'' of \spark, responsible for obtaining the \textit{system measurements} and modifying the \textit{system state}, in the context of \textit{system objectives}. 

\paragraph{\textbf{Agent Module}} interacts with the physical robot or its simulation. 
It receives control commands from the system controller and manipulates the robot’s state by applying these commands to the robot’s actuators or simulated system. 
Consequently, the \textbf{Agent} module’s primary role is to influence and modify the robot’s \textit{system state}, reflecting its position in the overall framework as an executor of system control. 
\textbf{Agent} module houses the interfaces for both simulated and real robots, allowing \spark to be deployable for various tasks.

\paragraph{\textbf{Task Module}} represents a key link in the \spark framework, responsible for providing system measurements and objectives to downstream modules. 
\textit{System objectives} are naturally incorporated into this module, where they serve as task-specific goals, e.g., goal points, obstacle avoidance. 
Additionally, the \textit{system measurements} module is integrated here, bridging the robot’s current state (via the \textbf{Agent} module) and information about the surrounding environment (e.g., obstacles, goal points). 
By providing system measurements along with the objectives, the \textbf{Task} module ensures that both system status and intended mission goals are captured and made available for policy decision-making in the subsequent module. 
This approach of combining measurements with objectives allows \spark to construct a comprehensive picture of the robot’s state in context with its task, ensuring efficient task execution and safe control under evolving conditions. 

We now turn to the ``back-end'' of the framework, encompassed by \textbf{Algorithm}, which unifies the \textbf{Policy} and \textbf{Safety} modules. The \textit{system controller} is incorporated here, divided into these two modules.

% \paragraph{\textbf{Policy and Safety Modules (Algorithm)}} The system controller operates within the \textbf{Algorithm} module, decomposed into two submodules: \textbf{Policy} and \textbf{Safety}. 
% The \textbf{Policy} module makes decisions based on system measurements (e.g., obstacles, current state) and system objectives (e.g., traverse a path or avoid collision), determining the reference control commands that guide the robot to achieve its task-specific goals. 
% The \textbf{Safety} module subsequently refines these actions by applying safety constraints to ensure that the robot’s operation remains both feasible and safe within predefined safety boundaries. 

\paragraph{\textbf{Policy Module}} processes the \textbf{Task} information to generate reference control actions that aim to achieve performance-oriented objectives, such as reaching a goal location, without considering safety constraints. 

\paragraph{\textbf{Safety Module}} refines the control actions given by the \textbf{Policy} module to ensure compliance with the safety constraints while attempting to follow the original reference control actions as closely as possible. 

Both \textbf{Policy} and \textbf{Safety} modules allow users to incorporate either model-based or data-driven controllers, preserving \spark's core principles of composability and extensibility.

% \subsection{Why decomposing the system components into \spark framework is valuable} 
% By organizing the system components into distinct, modular units, \spark maximizes flexibility and efficiency when working across diverse robotic platforms and task scenarios. 
% The overall modular structure is structured to: 
% \begin{itemize} 
% 	\item Allow users to customize or replace individual modules, optimizing and validating components such as system dynamics, measurements, or objectives independently of each other. 
% 	\item Facilitate rapid experimentation, allowing safe controller methods to be safely tested and benchmarked across different configurations without needing to redesign the entire system. 
% 	\item Ensure smooth integration with real robots, enabling research on safe control algorithms in both simulation and real-world environments with minimized friction between experimentation and deployment. 
% \end{itemize} 
% This fluid modularity—coupled with the clear separation of responsibilities for each module enables a streamlined approach to testing, benchmarking, development, and deployment. 
% The architecture of \spark is optimized to address real-world robotic challenges by helping users quickly evaluate performance, iterate development, and seamlessly deploy safe control strategies across various use cases.


\subsection{Why decomposing system components into the \spark framework is valuable}

As described in Section~\ref{sec: introduction}, the \spark framework is grounded in three core principles: \textit{composability}, \textit{extensibility}, and \textit{deployability}. By decomposing the system components into distinct, modular units, \spark maximizes flexibility and scalability for various robotic platforms and tasks. This design fosters the following advantages.

\begin{itemize}
    \item \textit{Composability:} Users can rapidly mix and match built-in or custom modules to create safe robotic control scenarios. 
    Predefined module options enable large-scale benchmarking, while module swapping allows easy scenario variation without re-engineering the entire synthesis process.
    \item \textit{Extensibility:} Each module can be independently customized or replaced, such as implementing novel safe control algorithms in the \textbf{Safety} module, integrating additional sensors in the \textbf{Task} module, testing new reinforcement learning algorithms in the \textbf{Policy} module, and incorporating latest humanoid robot in the \textbf{Configuration} module.
    This flexibility supports rapid development, wide-ranging experimental setups, and seamless adoption of new research innovations.
    \item \textit{Deployability:} The unified interface within the \textbf{Agent} module bridges simulation and physical hardware, simplifying the transition from prototyping to real-world experiments. 
    By supporting middleware like ROS and DDS in the \textbf{Agent} module, \spark ensures robust real-time performance, whether in controlled lab settings or complex human-robot interactions.
\end{itemize}

This clear separation of responsibilities across \spark's modules not only accelerates testing and benchmarking of safe control methods but also streamlines development and real-world deployment. Researchers can quickly iterate on scenarios and algorithms, and then confidently transfer their solutions to hardware platforms with minimal friction, all within one coherent framework.


% \subsection{Framework of \spark}\label{sec: spark_framework}
% To facilitate the decomposition and integration of the components discussed in \Cref{sec: syetem_component}, we present the \spark framework, offering users a collection of modular Python class templates. 

% \begin{figure}[htbp]
%     \centering
%     \vspace{2cm}  % Optional vertical space
%     \begin{tikzpicture}[transform canvas={xshift=0cm}] 
%         % Define image size and spacing
%         \def\imgwidth{8cm}  % Image width

%         % Single figure for system framework
%         \node at (0, 0) {\includegraphics[width=\imgwidth]{figure/system/spark_system_framwork.pdf}};
%     \end{tikzpicture}
%     \vspace{2cm}
%     \caption{\spark system framework.}
%     \label{fig:system_framework}
% \end{figure}



% To begin with, we first introduce the \textbf{Configuration Module} which supports all other modules.

% \paragraph{\textbf{Configuration Module}} provides \spark framework with a unified representation of the robot-dependent configuration. Specifically, it defines the robot’s degrees of freedom and motor interfaces, enabling the conversion of controller commands into both hardware and simulation actions. Additionally, it specifies control variables, robot states, and system dynamics, which can be referenced by controller modules. Finally, it includes robot collision volumes and CAD models to support the design of task objectives and safety constraints.

% Then, we introduce two modules, \textbf{Agent} and \textbf{Task}, which directly interact with the physical world and are collectively wrapped as the \textbf{Environment} in \spark.

% \paragraph{\textbf{Agent Module}} serves as the executor of control commands. It receives control commands from the control algorithms and, by referencing the robot configuration and the current system state, sends these commands to specific actuators on the real robot or steps the simulated robot using the selected dynamics model. This process is facilitated through a standardized interface within the module.

% \paragraph{\textbf{Task Module}} receives feedback from the \textbf{Agent} module while also observing external sensors and user inputs to determine the environment state. These system states are then processed into system measurements before being passed to downstream controller modules, along with system objectives that include user-defined task logic and safety requirements.

% At this stage, we have introduced the ``front-end" modules responsible for obtaining the system state, applying system dynamics, generating system objectives and measurements. Next, we examine the ``back-end" system controller modules: the \textbf{Policy} and \textbf{Safety} modules, collectively wrapped as \textbf{Algorithm} in \spark.

% \paragraph{\textbf{Policy Module}} processes task-related information, consisting of system measurements and objectives, to generate reference control actions that aim to achieve task-oriented goals without explicitly enforcing safety constraints. The policy can be either model-based or data-driven, providing users with flexibility and extensibility within \spark.

% \paragraph{\textbf{Safety Module}} refines the reference actions generated by the \textbf{Policy} module to ensure compliance with safety requirements while attempting to follow the original reference actions as closely as possible. By incorporating safety-related configurations from the \textbf{Configuration} module, this module generalizes the safe control problem, making it adaptable to different safe control methods.

% With this framework, \spark uses the \textbf{Environment} modules to manage the system state and measurements from both the robot and the external physical world, while integrating all system objective logic within the \textbf{Task} module. This separation also allows \spark to decompose the system controller into \textbf{Algorithm} modules, with the \textbf{Safety} module specifically handling safety-oriented task goals. This modular formulation empowers \spark with flexible usage, enabling a range of capabilities that will be introduced in the following section.

% \subsection{Capabilities of \spark}

% \paragraph{\textbf{Testing}} With the Python API provided by \spark, users can easily construct a safe control scenario by selecting from built-in or custom-designed module options. For example, to develop a humanoid safe teleoperation pipeline, one can set the human hand positions as the task-oriented goal and define objects as obstacles in the \textbf{Task} module. By integrating inverse kinematics (IK) in the \textbf{Policy} module and selecting a safe control algorithm from the \textbf{Safety} module, users can verify the control performance through the simulation provided by the \textbf{Agent} module in \spark.

% \paragraph{\textbf{Benchmarking}} In addition to designing and testing individual scenarios, \spark also provides users with a set of built-in options for the \textbf{Task} and \textbf{Agent} modules. These options allow users to easily scale up testing environments and benchmark the performance of control algorithms.

% \paragraph{\textbf{Development}} Safety being a core motivation behind \spark's design, the standalone \textbf{Safety} module enables users to easily develop new safe control methods and test them across different tasks without the need to modify other modules.

% \paragraph{\textbf{Deployment}} Beyond simulation testing and benchmarking, \spark also supports deploying safe control algorithms directly onto real robot hardware. This is made possible by the uniform design of the \textbf{Agent} module, which provides a general interface for both real robots and simulated robot systems.