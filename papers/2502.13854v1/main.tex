\newif\ifanon
%\anontrue
\anonfalse

\documentclass[11pt]{article}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{multicol}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{complexity} % complexity classes
\usepackage{hyphenat} % hyphens for compound words

\usepackage[letterpaper,margin=1in]{geometry}

% ---------- Bibliography ----------

\usepackage{ambib}
\addbibresource{main.bib}

% ---------- Theorems ----------

\usepackage{amthm}

% ---------- Maths commands, operators ----------

\let\H\relax
\let\R\relax
\usepackage{ammacros}

\DeclareMathOperator{\colors}{colors}
\DeclareMathOperator{\compat}{compat}
\DeclareMathOperator{\content}{content}
\DeclareMathOperator{\diam}{diam}
\DeclareMathOperator{\dist}{dist}
\DeclareMathOperator{\id}{id}
\DeclareMathOperator{\type}{type}

\makeatletter
\newlang{\@col}{col}
\newcommand*{\kcol}{k{\mhyph}\@col}
\newcommand*{\twocol}{2{\mhyph}\@col}
\makeatother

\newcommand*{\acc}{\mathbf{accept}}
\newcommand*{\alvgd}{\mathcal{V}(\mathcal{D},n)}
\newcommand*{\aviewsd}{\mathsf{AViews}(\mathcal{D},n)}
\newcommand*{\bad}{\mathrm{bad}}
\newcommand*{\base}{\mathrm{base}}
\newcommand*{\cO}{\mathcal{O}}
\newcommand*{\ids}{\mathsf{Id}}
\newcommand*{\kcolg}{\mathcal{G}(\kcol)}
\newcommand*{\maxid}{\mathsf{MaxId}}
\newcommand*{\ports}{\mathsf{prt}}
\newcommand*{\rej}{\mathbf{reject}}
\newcommand*{\rmc}{\mathrm{c}}
\newcommand*{\twocolg}{\mathcal{G}(\twocol)}
\newcommand*{\view}{\mathsf{view}}

% ---------- Figures ----------

\usepackage{tikz}
\usetikzlibrary{calc,fit,shapes.geometric,positioning}

\usepackage{standalone}

\usepackage{xcolor}
\definecolor{stgoblue}{RGB}{74,144,226}
\definecolor{stgogreen}{RGB}{80,227,194}
\definecolor{stgored}{RGB}{255,69,0}
\definecolor{stgoorange}{RGB}{255,165,0}

% ---------- Text goodies ----------

\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=black,
  citecolor=black,
  filecolor=black,
  urlcolor=black,
}
\newcommand{\email}[1]{\href{mailto:#1}{\texttt{#1}}}

\usepackage{microtype}
\usepackage{csquotes}
\usepackage[capitalize]{cleveref}

% ---------- todonotes--------
\usepackage[draft]{fixme}
\fxusetheme{color}
\FXRegisterAuthor{am}{anam}{\footnotesize\color{blue}Augusto}
\FXRegisterAuthor{pm}{apm}{\footnotesize\color{orange}Pedro}
\FXRegisterAuthor{mrw}{amrw}{\footnotesize\color{red}Martin}
\newcommand*{\augusto}[1]{\amnote{#1}}
\newcommand*{\pedro}[1]{\pmnote{#1}}
\newcommand*{\martin}[1]{\mrwnote{#1}}
\newcommand*{\augustoinline}[1]{\amnote[inline,nomargin]{#1}}
\newcommand*{\pedroinline}[1]{\pmnote[inline,nomargin]{#1}}
\newcommand*{\martininline}[1]{\mrwnote[inline,nomargin]{#1}}
\newenvironment{augustolong}{\begin{anamnote}[nomargin]{}}{\end{anamnote}}
\newenvironment{pedrolong}{\begin{apmnote}[nomargin]{}}{\end{apmnote}}
\newenvironment{martinlong}{\begin{amrwnote}[nomargin]{}}{\end{amrwnote}}
% AM: fixme is superior (faster, does not use TikZ)
%\usepackage{todonotes}
%\newcommand{\pedro}[1]{\todo[color=yellow!30]{\footnotesize Pedro: #1}}
%\newcommand{\pedroinline}[1]{\todo[inline,color=yellow!30]{Pedro: #1}}
%\newcommand{\martin}[1]{\todo[color=green!30]{\footnotesize Martin: #1}}
%\newcommand{\martininline}[1]{\todo[inline,color=green!30]{Martin: #1}}
%\newcommand{\augusto}[1]{\todo[color=blue!30]{\footnotesize Augusto: #1}}
%\newcommand{\augustoinline}[1]{\todo[inline,color=blue!30]{Augusto: #1}}

% ---------- Title ----------

\title{Strong and Hiding Distributed Certification of $k$-Coloring}
\date{}
\ifanon
\author{Anonymous Authors}
\else
\author{Augusto Modanese\thanks{Aalto University, Finland.
    Email: \email{augusto.modanese@aalto.fi}}
  \and Pedro Montealegre\thanks{Universidad Adolfo Ibáñez, Chile.
    Email: \email{p.montealegre@uai.cl}}
  \and Martín Ríos-Wilson\thanks{Universidad Adolfo Ibáñez, Chile.
    Email: \email{martin.rios@uai.cl}}}
\fi % end ifanon

\begin{document}

\maketitle
\thispagestyle{empty}

\begin{abstract}
Distributed certification is a framework in distributed computing where nodes in a network collaboratively verify whether the entire graph satisfies a given property. Within this framework, a \emph{locally checkable proof (LCP)} is a non-deterministic distributed algorithm designed to verify global properties of a graph $G$. It involves two key components: a \emph{prover} and a \emph{distributed verifier}. The prover is an all-powerful computational entity capable of performing any Turing-computable operation instantaneously. Its role is to convince the distributed verifier—composed of the graph's nodes—that $G$ satisfies a particular property $\Pi$.  

An LCP is correct if it satisfies \emph{completeness} and \emph{soundness}. Completeness ensures that, for every graph $G$ satisfying $\Pi$, there exists a certificate assignment that is accepted by all nodes. Soundness guarantees that for every graph $G$ that does not satisfy $\Pi$, at least one node rejects the assignment for any given certificate assignment.  

In this paper, we study the problem of certifying whether a graph is
\emph{$k$-colorable} with an LCP that is able to \emph{hide} the $k$-coloring
from the verifier.
More precisely, we say an LCP for $k$-coloring is \emph{hiding} if, in a
yes-instance, it is possible to assign certificates to nodes \emph{without
revealing an explicit $k$-coloring}. 
Motivated by the search for promise-free separations of extensions of the LOCAL
model in the context of locally checkable labeling (LCL) problems, we also
require the LCPs to satisfy what we refer to as the \emph{strong soundness}
property.
This is a strengthening of soundness that requires that, in a no-instance (i.e.,
a non-$k$-colorable graph) and for every certificate assignment, the subset of
accepting nodes must induce a $k$-colorable subgraph.
An LCP satisfying completeness, soundness, hiding, and strong soundness is
called a \emph{strong and hiding LCP}. 

We focus on the case of $2$-coloring.
We show that strong and hiding LCPs for $2$-coloring exist in specific graph
classes and requiring only $O(\log n)$-sized certificates.  
Furthermore, when the input is promised to be a cycle or contains a node of
degree $1$, we show the existence of strong and hiding LCPs even in an 
\emph{anonymous} network and with \emph{constant-size} certificates. 

Despite these upper bounds, we prove that there are no strong and hiding LCPs
for $2$-coloring in general, \emph{regardless of certificate size}. 
The proof relies on a Ramsey-type result as well as an intricate argument about
the realizability of subgraphs of the neighborhood graph consisting of the
accepting views of an LCP.
Along the way, we also give a characterization of the hiding property for the
general $k$-coloring problem that appears to be a key component for future
investigations in this context.

\end{abstract}

\clearpage % end titlepage
\pagenumbering{arabic} % reset page count
\thispagestyle{plain}

\section{Introduction}


Distributed certification is a framework in distributed computing where nodes in a network collaboratively verify that the entire network (graph) satisfies a given property. Within this framework, a \emph{locally checkable proof (LCP)} is a non-deterministic distributed algorithm designed to verify global properties of a graph \( G \). It involves two components: a \emph{prover} and a \emph{distributed verifier}. The prover is an omnipotent computational entity, capable of performing any Turing-computable operation instantaneously. Its role is to convince the distributed verifier, which consists of a collection of nodes within the graph, that \( G \) satisfies a particular property \( \mathcal{P} \).
The LCP must satisfy the properties of \emph{completeness} and \emph{soundness},
which are defined in a manner akin to the classical proof systems from
computational complexity theory.
(See \cref{sec:defs} for precise definitions.)

In this paper, we focus on \emph{$k$-coloring}, which consists of determining whether the input graph is $k$-colorable. This problem admits a simple one-round LCP with certificates consisting of $\cO(\log k)$ bits, representing the color of the node in a proper $k$-coloring. Our goal is to find a way to certify $k$-coloring \emph{without revealing} a proper $k$-coloring to the nodes. To achieve this, we introduce the notion of \emph{hiding} locally checkable proofs.
Informally, an LCP for $k$-coloring is said to be hiding if there exist
certificates that convince the verifier on every $k$-colorable graph, but there
is no local algorithm that can extract a $k$-coloring (of all nodes) from these
certificates.
(We postpone a more in-depth discussion of this new notion to
\cref{sec:intro-model}.)

In addition to the hiding property, we will also require our LCPs to satisfy a
stronger but still very natural variant of soundness, which we accordingly dub
\emph{strong soundness}.
The main reason for using this version instead of the usual one is a connection
to \emph{promise-free separations of extensions of the LOCAL model}, which we
discuss next.

\paragraph{Main motivation: application to promise-free separations.}
\emph{Locally checkable labeling} (LCL) problems are central to the study of
the LOCAL model of computation
\cite{naor95_what_siamjc,linial92_locality_siamjc}.
These are problems in which one must label the nodes of a graph according to
a set of constraints that can be locally verified.
By far, the most studied variant of LOCAL is randomized LOCAL
\cite{ghaffari18_derandomizing_focs,balliu21_lower_jacm,balliu20_much_podc,%
brandt16_lower_stoc,chang19_exponential_siamjc,chang19_time_siamjc,%
fischer17_sublogarithmic_disc,rozhon20_polylogarithmic_stoc}, but recently
interest has extended to several other augmentations of the LOCAL model,
including access to shared randomness \cite{balliu24_shared_arxiv}, quantum
computing
\cite{legall19_quantum_stacs,coiteux-roy24_no_stoc,balliu25_distributed_stoc},
and global symmetry breaking
\cite{akbari23_locality_icalp,chang24_tight_podc,ghaffari17_complexity_stoc,%
ghaffari18_derandomizing_focs}.
(See also \cite{akbari25_online_stoc} for a broader discussion of this
landscape.)

As is the case when confronted with a landscape of several different models, it
is imperative to ascertain that their capabilities are indeed distinct, namely
by proving separation results.
Here it cannot be stressed enough that we are looking for separations that hold
in a \emph{promise-free} setting, that is, without additional assumptions on the
input graph.
The reason for this is that the bulk of the theory on LCL problems is
promise-free, and arbitrary assumptions on the input graph can potentially
annihilate the landmark gap results in the field.
Nevertheless, proving promise-free separations is usually quite an ordeal and
only \emph{ad hoc} constructions are known.
See, for instance, the work of \textcite{balliu24_shared_arxiv} for such an
example.

For concreteness, let us focus on the case of separating the SLOCAL and online
LOCAL models.
(For this high-level discussion, it is not necessary to be familiar with these
models and their definitions.
The interested reader is referred to, e.g., \textcite{akbari23_locality_icalp}.)
There we have an exponential separation for the problem of $3$-coloring, but
only when restricted to bipartite graphs.
More precisely, there is an $\cO(\log n)$ algorithm for $3$-coloring bipartite
graphs in online LOCAL, whereas in SLOCAL we have a polynomial lower bound for
$3$-coloring that holds even in grids \cite{akbari23_locality_icalp}.

One incredibly simple approach to lift this separation between SLOCAL and online
LOCAL to a promise-free one would be to encode in the LCL input a certificate of
$2$-colorability while asking for a $3$-coloring (i.e., the nodes must label
themselves with a proper $3$-coloring).
Since we must allow arbitrary input graphs, the certificate cannot be valid in
all of them, so we require the nodes to output a correct $3$-coloring \emph{only
on the parts of the graph where the $2$-coloring certificate is valid}.
(This is very similar to the approach taken in the aforementioned paper by
\textcite{balliu24_shared_arxiv}.)
In addition, for it to be useful, the certificate of $2$-colorability must be
\emph{hiding} in the sense that every SLOCAL algorithm with $\cO(\log n)$
locality fails to extract a $3$-coloring from it.

Let us refer to this LCL problem, that is, $3$-coloring under the presence of a
certificate of $2$-colorability as $\Pi$.
Assuming such a hiding certificate exists, we immediately get a
\emph{promise-free separation} between SLOCAL and online LOCAL:
SLOCAL fails to solve $\Pi$ (with $\cO(\log n)$ locality) since it cannot
extract a $3$-coloring from the certificate, while online LOCAL can simply
execute the existing $\cO(\log n)$ coloring algorithm on the parts of the graph
where the certificate is valid (and labels the rest of the nodes arbitrarily).

Alas, the only way of certifying bipartiteness that is known is to reveal a
$2$-coloring, which renders the $3$-coloring problem trivial.
Hence it would be amazing to have a certificate for bipartiteness that
\emph{hides} a $3$-coloring.
In addition, this certificate must be resilient against being used to label
graphs that are not bipartite.
That is, for any graph $G$ where someone tries to place the certificate labels
on, the parts of $G$ where the certificate is valid is indeed $2$-colorable (so
that the online LOCAL algorithm succeeds in $3$-coloring these parts of $G$).
This motivates the stronger variant of soundness that we introduce.
We discuss these two notions in more detail next.

\subsection{The model}
\label{sec:intro-model}

Before we continue, we introduce our model in more detail but still in the form
of an informal discussion.
The reader is invited to consult \cref{sec:defs} for the formal definitions when
needed.

As mentioned above, the goal of the prover in the LCP model is to convince the
distributed verifier that the underlying graph $G$ satisfies a certain property
$\mathcal{P}$.
To achieve this, the prover assigns a \emph{certificate} \( \ell(v) \) to each
node \( v \). Once these certificates are distributed, each node \( v \)
receives the certificates of its vicinity. Using this local information---its
own certificate, the certificates of its neighbors, and the graph structure
visible to it---each node independently decides whether to accept or reject the
assertion that \( G \) satisfies \( \mathcal{P} \). 

We say that an LCP is \emph{correct} if it satisfies \emph{completeness} and \emph{soundness}. Roughly, soundness guarantees that if all nodes accept the assigned certificates (i.e., the proof is locally verified as correct at each node), then the underlying structure genuinely satisfies the intended property. In other words, no incorrect configurations are falsely accepted. Completeness, on the other hand, ensures that whenever the structure does satisfy the intended property, there is indeed a way to assign certificates such that local verification at every node passes. Thus, if the structure is valid, it will not be mistakenly rejected. 

In the standard version of soundness, we require that, if $G$ does not satisfy
$\mathcal{P}$, then, for any assignment of certificates that a malicious prover
attempts to distribute, there will be at least one node in $G$ that rejects.
We are interested in strengthening this to the following:
If $G$ does not satisfy $\mathcal{P}$, then, for any assignment of certificates,
\emph{the subgraph induced by accepting nodes of $G$} must satisfy the property
$\mathcal{P}$.
This is an equally natural requirement, besides being the correct notion for the
aforementioned connection to LCL problems.
It is also interesting to note that this distinction between these two versions
of soundness is intrinsical to distributed proof systems; that is, there is no
equivalent of this in the realm of the classical proof systems of computational
complexity theory.

We consider LCPs where the verifier is allowed to run for $r$ rounds, for a
fixed positive integer $r$, which we refer to as $r$-round LCPs.
Hence every node \enquote{sees} the graph structure and all certificates up to
$r$ hops away from it.
Every node is also given a unique identifier that is smaller than $N$, where $N$
scales polynomially with the number of nodes and is known by the nodes of the
graph.
If the LCP operates independently of the values of the identifiers (which is
desirable but may limit its power), then we refer to it as an anonymous LCP.

\paragraph{Hiding LCPs.}
Recall the central novel notion of our interest is that of a \emph{hiding} LCP.
Focusing on the case of coloring, an $r$-round LCP for $k$-coloring is hiding if
no $r$-round local algorithm can extract a $k$-coloring from a correct
certificate (i.e., a certificate that is accepted unanimously by the verifier).

Note that failing to extract in particular means it is acceptable if a
\emph{single} node fails to output its color.
Hence this is a purely algorithmic notion and is far (at least in its current
form) from having cryptographical applications or similar.
We believe it is also interesting to consider a quantified version where we
require, say, that at least a constant fraction of nodes fail to output a
correct color.
This could have connections to questions in distributed property testing, for
instance.
(See, e.g., the work of \textcite{censor-hillel19_fast_dc}.)
We postpone this investigation to future work.

It is important to notice that not every graph property admits a hiding LCP on every graph. 
For instance, consider the language of $2$-colored star graphs (i.e., we want to
certify that the input graph is a star without revealing a $2$-coloring). 
Since the nodes know that the input graph is a star, they can always output a color: 
If they have degree 1, they choose color 1; otherwise, they choose color 0.
This contrasts with classical LCPs, where it is known that 
every Turing-computable graph property $\mathcal{P}$ admits an LCP with
certificates of size $\cO(n^2)$: 
Simply provide the entire adjacency matrix of the input graph to every vertex, 
along with their corresponding node identifiers.

\subsection{Similar concepts and related work}

The notion of hiding LCPs is reminiscent of zero-knowledge proof systems, which
have also been studied in the distributed setting
\cite{bick22_distributed_soda,grilo25_distributed_arxiv}.
Note zero knowledge is a stronger notion usually with applications of a
cryptographical nature and requires the verifier to essentially learn nothing
about the prover's solution.
The hiding property is more lenient in that it is sufficient for the solution to
not be revealed everywhere.
In the case of coloring, for instance, it is enough if a single node fails to
output a correct color.
This connects better to possible applications to LCL problems, as previously
discussed.

Still in a complexity-theoretical vein, the question of whether there is a
hiding LCP for a problem $\Pi$ relates to whether the \emph{decision} and
\emph{search} versions of $\Pi$ are equal in complexity or not in the context of
distributed proof systems.
More specifically, a (non-adaptive, locally computable) reduction from the
search to the decision version of $\Pi$ contradicts the existence of a hiding
LCP for $\Pi$.
This is because what such a reduction is doing is, indeed, extracting the
solution for $\Pi$ from a correct certificate assignment.



Another related model is the \emph{resilient labeling scheme}, a type of
distributed proof system (specifically, a proof-labeling scheme) that considers
the scenario where the certificates of up to \( f \) nodes are erased. This
model was introduced by \textcite{fischer2022explicit} in the context of
studying trade-offs between certificate sizes and verification rounds. 
(See also the recent paper by \textcite{censor2025near}.) 
The key idea is to design a distributed algorithm in which nodes can reconstruct
their original labels from the remaining ones, even after some certificates have
been erased. 
This can be achieved using error-correcting codes and  techniques based in graph
partitions.
Unlike our model, resilient labeling schemes impose a requirement on
\emph{completeness} rather than \emph{soundness}. Specifically, in
\emph{yes-instances}, all nodes must accept the verification, even when a subset
of nodes has lost their certificates. However, no constraints are imposed on 
\emph{soundness} as we propose in this article. 

There are several articles that deal with lower bounds related to $k$-coloring, beyond the trivial upper bound of $\lceil \log k \rceil$ bits (i.e. give each node its color in a proper $k$-coloring). \Textcite{goos2016locally} show that any LCP deciding whether the chromatic number of a graph is strictly greater than $3$ requires certificates of size $\tilde{\Omega}(n^2)$. On the other hand, \textcite{bousquet24_local_stacs} demonstrated that, in the $d$-round LCP model, certificates of size $\Omega((\log k)/d)$ are necessary. Furthermore,  restricted to the anonymous model with a one-round verification, the authors show that $\lceil \log k \rceil$ bits are necessary, which exactly matches the lower bound. 
In this work, we ask whether any distributed proof that a graph is $k$-colorable \emph{necessarily leaks} a proper $k$-coloring of the graph. This question may be related to the minimum certificate size required to prove that a graph is $k$-colorable, but it is not the same. Indeed, it is possible that in order to achieve strong and hiding LCPs for $k$-coloring, we need certificates that are strictly larger than those required to certify the property without any additional conditions.




\subsection{Main results}

Our main results are focused on the $2$-coloring problem.
Nevertheless, our framework for lower bounds is also applicable to $k$-coloring
for arbitrary values of $k$.
Some of our upper bound techniques are also useful in the general case, but we
do not address those since the $2$-coloring case is the most fundamental. 

\paragraph{Upper bound with constant-size certificates.}
Our first result is the cornerstone case where the LCP is anonymous and we wish
to certify a $2$-coloring using only constant-size certificates.
We prove it is possible to certify the $2$-coloring without revealing it
provided that we are in graphs with minimum degree one or even cycles (or a
union of both).
In the statement below, $\twocol_\mathcal{H}$ refers to the promise version of
the $2$-coloring problem where we allow only input graphs from the class
$\mathcal{H}$.

\begin{restatable}{theorem}{restateThmDegOneOrEvenCycle}
  \label{thm:deg-one-or-even-cycle}
  Let $\mathcal{H} = \mathcal{H}_1 \cup \mathcal{H}_2$, where $\mathcal{H}_1$ is
  the class of graphs $G$ for which $\delta(G) = 1$ and $\mathcal{H}_2$ is the
  class of even cycles.
  Then there is a strong and hiding one-round anonymous LCP for
  $\twocol_\mathcal{H}$ using constant-size certificates.
\end{restatable}

We use two distinct strategies for the classes $\mathcal{H}_1$ and
$\mathcal{H}_2$.
If the input graph has minimum degree one, we can reveal the coloring everywhere
except for a node with degree one of our choosing.
Meanwhile, if we are in a cycle, we can use a $2$-\emph{edge}-coloring, which
hides the $2$-coloring \emph{from all nodes}.

\paragraph{Lower bound.}
For the case of $r = 1$, we have a matching lower bound for the $2$-coloring
problem.
For the case of larger $r$, our lower bound holds for graphs that satisfy a
certain connectivity property, which we define next.

Let $r$ be a positive integer.
A graph $G$ is said to be \emph{$r$-forgetful} if, for every node $v \in V(G)$
and every neighbor $u$ of $v$, there is a path $P = (v_0 = v, v_1, \dots, v_r)$
of length $r$ such that, for every $w \in N^r(u)$, $\dist(v_i,w)$ is
monotonically increasing with $i$.
The intuition is that, if we are visiting nodes in $G$ and arrive at $v$ from
$u$, then we can always find a way of \enquote{escaping} $v$ without having to
backtrack and go through the $r$-neighborhood of $u$.
See \cref{fig:forgetful} for an example.
This property applies to a broad class of graphs, including (regular) grids and
trees.
A necessary condition is that the graph has diameter at least $2r+1$ (see
\cref{lem:forgetful-diam}).

\begin{figure}
  \centering
  \includestandalone{figs/forgetful}
  \caption{Example of the $r$-forgetful property.
    The node $w$ is inside the neighborhood $N^r(u)$.
    The distance from $w$ is monotonically increasing along the path $P = (v_0 =
    v, v_1, v_2, \dots, v_r)$.}
  \label{fig:forgetful}
\end{figure}

Our main result is that it is impossible for $r$-round LCPs to hide a
$2$-coloring in $r$-forgetful graphs except for the two cases of
\cref{thm:deg-one-or-even-cycle}.
In particular, this holds even if the LCP is allowed to use the values of the
identifiers it sees arbitrarily (i.e., even if it is not anonymous).

\begin{restatable}{theorem}{restateThmFullBipImpossibility}
  \label{thm:full-bip-impossibility}
  Let $r$ be a positive integer, and let $\mathcal{H}$ be a class of graphs that
  contains at least one $r$-forgetful connected graph that is neither an even
  cycle nor has minimum degree equal to one. 
  Then there is no strong and hiding $r$-round LCP for $\twocol_\mathcal{H}$ (no
  matter the certificate size).
\end{restatable}

We postpone the overview of the proof of \cref{thm:full-bip-impossibility} to
\cref{sec:intro-techniques}.
For now, it is sufficient to mention it uses our main technical contribution,
which is the characterization of a hiding LCP for $k$-coloring based on the
\emph{neighborhood graph of accepting local views}.
Namely, an LCP for $k$-coloring is hiding if and only if the neighborhood graph
on accepting views is itself \emph{not} $k$-colorable (\cref{lem:hiding-char}).
Besides the lower bound proof, this technical result is useful for proving the
hiding property of our upper bound LCPs as well.

Incidentally, note this lemma also explains why we touched the point of hiding a
$3$-coloring while certifying a $2$-coloring when discussing the main
motivation, but did not define the notion of an LCP for \enquote{hiding a
$K$-coloring while certifying a $k$-coloring}, where $K > k$.
This is because an LCP that hides a $K$-coloring (i.e., from which we cannot
extract a $K$-coloring) must have a neighborhood graph that is not $K$-colorable
and thus in particular is not $k$-colorable; hence the LCP also hides a
$k$-coloring.
Taken in the contrapositive, the non-existence of a hiding LCP for $k$-coloring
(in the sense that we define, i.e., hiding a $k$-coloring) implies the
non-existence of an LCP for $k$-coloring that hides a $K$-coloring, for
\emph{every} value of $K \ge k$.

\paragraph{Upper bounds with variable-size certificates.}
Finally, we provide evidence showing that our impossibility result cannot be
(fully) extended to the non-anonymous case with super-constant certificate size. 
More precisely, we define two graph classes, namely graphs that admit a
\emph{shatter point} and \emph{watermelon graphs}, both of which admit strong
and hiding LCPs for 2-coloring. 

We say that a graph \( G \) \emph{admits a shatter point} if there exists a node \( v \in V(G) \) such that \( G - N[v] \) is disconnected (i.e., it has at least two distinct connected components). For this class, we obtain the following theorem.


\begin{restatable}{theorem}{restateThmShatterPoint}
  \label{thm:shatter-point}
  Let $\mathcal{H}$ be the class of graphs $G$ admitting a shatter point.
  Then, there is a strong and hiding one-round LCP for $\twocol_\mathcal{H}$
  using certificates of size \( \mathcal{O}(\min\{\Delta^2, n\} + \log n) \), where \( \Delta = \Delta(G) \) is the maximum degree of \( G \).
\end{restatable}

Meanwhile, a \emph{watermelon graph} is a graph $G$ defined by two nodes $v_1,v_2\in V(G)$ and a collection of disjoint paths $\mathcal{P} = P_1, \dots, P_k$ of length at least $2$ with endpoints in $v_1$ and $v_2$. Nodes $v_1$ and $v_2$ are called the \emph{endpoints} of $G$. In this case, we show a strong and hiding LCP for 2-coloring using certificates of size $\cO(\log n)$.

\begin{restatable}{theorem}{restateThmWatermelons}
  \label{thm:watermelons}
  Let $\mathcal{H}$ be the class of  watermelon graphs.
  Then, there is a strong and hiding one-round LCP for $\twocol_\mathcal{H}$
  using certificates of size $\cO(\log n)$. 
\end{restatable}

\subsection{Lower bound techniques}
\label{sec:intro-techniques}

Before concluding this introduction, we discuss our proof of
\cref{thm:full-bip-impossibility}.
The first step is to reduce the general non-anonymous case to that of
\emph{order-invariant} LCPs.
As the name suggests, these are LCPs where the verifier's behavior is only
sensitive to the \emph{order} and not the actual value of the identifiers in the
neighborhood of a node.
That is, we can replace the identifiers around a node without altering the
node's output as long as we preserve the relative order of identifiers.

The argument for reducing to the order-invariant case bases on Ramsey theory and
is similar to a construction by \textcite{balliu24_local_podc} in a different
context.
This reduction is shown in \cref{sec:ramsey}.
Hence, the \enquote{true form} of \cref{thm:full-bip-impossibility} that we
prove in \cref{sec:oi-lb} is the following:

\begin{restatable}{theorem}{restateThmOIBipImpossibility}
  \label{thm:oi-bip-impossibility}
  Let $r$ be a positive integer, and let $\mathcal{H}$ be a class of graphs that
  contains at least one $r$-forgetful connected graph that is neither an even
  cycle nor has minimum degree equal to one. 
  Then there is no strong and hiding $r$-round \emph{order-invariant} LCP for
  $\twocol_\mathcal{H}$ (no matter the certificate size).
\end{restatable}

Let us address the main technical aspects behind the proof of
\cref{thm:oi-bip-impossibility}.
As already mentioned above, the key realization is that the hiding property can
be fully characterized in terms of the \emph{neighborhood graph} of
yes-instances of an LCP.
For an $r$-round LCP $\mathcal{D}$, we denote the respective neighborhood graph
for instances with at most $n$ nodes by $\alvgd$.
The characterization we prove (\cref{lem:hiding-char}) is that, for any positive
integer $k$, $\mathcal{D}$ hides a $k$-coloring if and only if $\alvgd$ is
\emph{not} $k$-colorable.

The proof of the lemma is by showing how we can use a $k$-colorable $\alvgd$ to
extract a coloring for $\mathcal{D}$.
For this idea to go through, it is imperative that the nodes have an upper bound
on the number of nodes in the input graph.
The case where such a bound is not given remains an interesting open question.
See \cref{sec:alvg} for details.

The characterization of \cref{lem:hiding-char} suggests using non-$k$-colorable
subgraphs of $\alvgd$ in order to prove \cref{thm:oi-bip-impossibility}.
That is, assuming that $\mathcal{D}$ hides $2$-colorings, we would like to take
a non-bipartite subgraph $H$ in $\alvgd$ and turn it into a real instance.
Since we are in the special case of $2$-colorability, it suffices if $H$ is an
odd cycle---or, more generally, an odd closed walk---in $\alvgd$.

The main challenge is that, although $\alvgd$ consists of views that can be
found in instances accepted by $\mathcal{D}$, there is no guarantee that such an
arbitrary $H$ corresponds to views of a real instance.
This problem is evident if $H$ is a closed walk but not a cycle, but even then
$H$ may contain views that are inherently incompatible.
For instance, we may have distinct views of $H$ in which a node with the same
identifier has a different number of neighbors.
Indeed, if $H$ can be realized directly, then it is \emph{immediately obvious}
that $\mathcal{D}$ violates strong soundness.

We introduce and develop a notion of \emph{realizability} of subgraphs of
$\alvgd$ with which we are able to gradually manipulate an odd cycle of $\alvgd$
into a real instance.
To this end it is imperative to assume some properties of valid yes-instances
(e.g., the existence of more than one cycle as well as the property of
$r$-forgetfulness we defined previously) for the proof to go through.
The manipulations needed are fairly technical, which may be attributed to the
fact that we must ensure the resulting views all agree with each other.
Nevertheless, we are able to present them in a series of steps that makes the
construction more digestible as well as more evident where each property we
assume in the theorem statement finds its use.

In retrospect, the question of realizability of subgraphs of the neighborhood
graph is an interesting blend of graph theory and distributed computing that may
be of independent interest.
In its most general form, what we are asking in this context is the following:
\emph{Given a neighborhood graph $\alvgd$ and assuming certain properties of the
original class of graphs, when can we realize a subgraph $H$ of $\alvgd$ as a
real instance accepted by $\mathcal{D}$?}
From this angle, our proof of \cref{thm:oi-bip-impossibility} may also be seen
as an attempt to answer to this question in the case where $H$ is an odd cycle.
Our proof shows that, although not every odd cycle $H$ can be realized, (under
the assumptions of the theorem) it is possible to manipulate $H$ and obtain a
realizable subgraph of $\alvgd$ with the property that we want (i.e.,
non-bipartiteness).

\subsection{Organization}

The rest of the paper is organized as follows:
We start in \cref{sec:defs} by introducing basic definitions and the concept of
hiding LCPs.
\Cref{sec:alvg} introduces our main technical tool, the neighborhood graph, and
proves the characterization described above in \cref{sec:intro-techniques}.
In \cref{sec:anonymous-ub} we prove \cref{thm:deg-one-or-even-cycle}, which is
our upper bound in the anonymous case.
Then in \cref{sec:oi-lb,sec:ramsey} we prove our lower bound results
\cref{thm:oi-bip-impossibility,thm:full-bip-impossibility}.
Finally, in \cref{sec:non-anon-ubs} we prove
\cref{thm:shatter-point,thm:watermelons}, which are our upper bounds in the
non-anonymous case.

\section{Definitions}
\label{sec:defs}

Given two integers $s$ and $t$, $[s, t]$ denotes the set $\{k \in \mathbb{Z} : s
\leq k \leq t\}$. 
We also let $[1, t] = [t]$. 
For a function $f\colon A \to B$, we write $f|_{A'}$ for the restriction of $f$
to $A' \subseteq A$.

We only consider undirected graphs.
Loops are allowed.
Given a graph $G$, we denote $V(G)$ and $E(G)$, respectively, as the set of
nodes and edges of $G$. 
We occasionally write $uv$ for an edge $\{ u, v \}$ (where $u$ and $v$ are
distinct).
For a set of nodes $U\subseteq V(G)$, we denote $G[U]$ the subgraph of $G$
induced by $U$.
Given $v \in V(G)$, the \emph{set of neighbors} of $v$ is $N(v) = \big\{u \in
V(G) : \{u,v\} \in E\big\}$, and $N[v] = N(v) \cup \{v\}$ is the \emph{closed
neighborhood of $v$}. Furthermore, we denote $N^k(v)$ the nodes at distance at
most $k$ from $v$. The \emph{degree of $v$}, denoted $d(v)$, is defined as the
cardinality of $N(v)$, and the minimum and maximum degree of $G$ are denoted
$\delta(G)$ and $\Delta(G)$, respectively.
We denote the diameter of $G$ by $\diam(G)$.

We will also need the following simple fact about $r$-forgetful graphs:
\begin{lemma}
  \label{lem:forgetful-diam}
  If $G$ is $r$-forgetful, then $\diam(G) \ge 2r+1$.
\end{lemma}

\begin{proof}
  We prove there are two nodes that are at distance $2r+1$ from each other.
  Let $v \in V(G)$, and let $u$ be a neighbor of $v$.
  By the $r$-forgetful property, there is a vertex $w$ for which $\dist(w,v) =
  r$ and $\dist(w,u) = r+1$ (since the distance to $u$ increases monotonically
  along the path from $v$ to $w$).
  Let $w'$ be the before-to-last vertex in the path from $v$ to $w$.
  Note $\dist(w',u) = r$.
  Applying the $r$-forgetful property, there is another vertex $z$ at distance
  $r$ from $w$ such that the distance from $u \in N^r(w')$ is $2r+1$.
\end{proof}

\subsection{Distributed languages and problems}


We consider \emph{distributed languages} \(\mathcal{L}\) as sets of pairs \((G,
x)\), where \(G = (V, E)\) is a simple, finite, undirected graph, and \(x\colon
V \rightarrow \{0, 1\}^*\) is an \emph{input} function, sometimes called
\emph{witness}. 
For instance, in this article, we primarily focus on the language 
\[
\textsf{k-col} = \{ (G, x) : x\colon V(G) \rightarrow \{0, \dots, k\}, \forall
\{u, v\} \in E(G), x(u) \neq x(v)\},
\]
which is the language that contains all pairs \((G, x)\) such that \(x\) is a proper \(k\)-coloring of \(G\).

Associated with a distributed language \(\mathcal{L}\), we define the set of graphs 
\[
\mathcal{G}(\mathcal{L}) = \{G : \exists x\colon V(G) \rightarrow \{0,1\}^*, (G,
x) \in \mathcal{L}\}.
\]
containing all graph that admit a witness. For instance, \(\mathcal{G}(\textsf{2-col})\) is the set of bipartite graphs. 

\subsection{Distributed certification of distributed problems}

\paragraph{Ports, identifiers and labelings.} Given an $n$-node graph $G$, a
\emph{port assignment} is a function 
\[\ports_G\colon V(G) \times E(G) \to [\Delta(G)]\] 
that satisfies the following conditions for each $v \in V(G)$: (1)
For every edge $e$ incident to $v$, $\ports_G(v, e) \leq d(v)$. (2) For every pair
of edges $e_1, e_2$ incident to $v$, $\ports_G(v, e_1) \neq \ports(v, e_2)$. 
We omit the subscript when $G$ is clear from the context.
We slightly abuse notation and call $\ports(v)$ the function $\ports(v,\cdot)$.


Given an $n$-node graph $G$, and $N = \poly(n)$, an \emph{identifier assignment}
is an injective function 
\[
  \ids_G: V(G) \rightarrow [N].
\]
(Again, we drop the subscript when $G$ is clear from the context.)
Observe that for each $v \in V(G)$, $\ids(v)$ can be encoded in $\lceil \log(N)
\rceil = \cO(\log n)$ bits. 
We assume that all identifiers are encoded using the same number of bits
(possibly padded with zeros), so it is possible to compute a polynomial upper
bound of $n$ from the number of bits used to encode $\id(v)$, for each $v \in
V(G)$. 

For a given graph $G$ and a positive integer $c$, a \emph{labeling of $G$ of
size $c$} is a function 
\[
  \ell_G: V(G) \rightarrow \{0, 1\}^c.
\]
(Once more, the subscript is dropped when it is clear which $G$ we are referring
to.)
A labeling plays the role of a certificate in a non-deterministic distributed
algorithm.

\paragraph{Views.}
Fix an $n$-node graph $G$, a port assignment $\ports$, an identifier assignment
$\ids$, an \emph{input function} $I\colon V(G) \rightarrow \{0,1\}^*$, and a
positive integer $r$.
Each node $v$ in $G$ has a \emph{view} of radius $r$, which we denote by
$\view_r(G,\ports,\ids,I)(v)$.
If $r$, $\ports$, $\ids$, and $I$ are clear from the context, then we simply
write $\view(G)(v)$ instead; if the same can be said for $G$, then we shorten
this further to $\view(v)$.
Concretely, $\view(v)$ is the tuple 
\[
  \left(G_v^r, \ports|_{N^r(v)}, \ids|_{N^r(v)}, I|_{N^r}(v)\right)
\] 
where $G_v^r$ is the subgraph of $G$ induced by the union of all paths of length
at most $r$ starting from $v$ and $\ports|_{N^r(v)}$, $\ids|_{N^r(v)}$, and
$I|_{N^r}(v)$ are the maps induced by restricting $\ports$, $\ids$, and $I$ to
$N^r(v)$, respectively. 
(Notice that $G_v^r$ has $N^r(v)$ as its node set and contains the full
structure of $G$ up to $r-1$ hops away from $v$ but not any connections between
nodes that are at $r$ hops away from $v$).
Given a view $\mu = \view(v)$, we refer to $v$ as the \emph{center node} of
$\mu$.

When convenient, we may also refer to $\view(v)$ as the graph $G_v^r$ itself
labeled with the values of respective restrictions of $\ports$, $\ids$, and $I$.
We let $\mathcal{V}_r$ denote the set of all views of radius $r$ (in every
possible graph).

\paragraph{Local algorithms and decoders.} 
An $r$-round \emph{local algorithm} $\mathcal{A}$ is a computable map
$\mathcal{V}_r \to O$, where $O$ is some set of outputs.
We can imagine that $\mathcal{A}$ is the result of the nodes broadcasting to
their neighbors everything they know for $r$ rounds in succession, followed by
the execution of an internal unbounded (but computable) procedure at every node.
When running $\mathcal{A}$ on fixed $G$, $\ports$, $\ids$, and $I$, we write
$\mathcal{A}(G,\ports,\ids,I)(v)$ for $\mathcal{A}(\view(v))$; again, if $G$,
$\ports$, $\ids$, and $I$ are clear from the context, then we simply write
$\mathcal{A}(v)$.

A local algorithm $\mathcal{A}$ is \emph{anonymous} if its output is independent
of the identifier assignment; that is, for any two identifier assignments $\ids$
and $\ids'$, we have $\mathcal{A}(G,\ports,\ids,I)(v) =
\mathcal{A}(G,\ports,\ids',I)(v)$ for every $G$, $\ports$, $I$, and $v \in
V(G)$. 
Furthermore, the algorithm $\mathcal{A}$ is \emph{order-invariant} if its output
stays unchanged as long as the ordering of the identifiers is preserved; that
is, for any two identifier assignments $\ids$ and $\ids'$ such that $\ids(u) <
\ids(v)$ if and only if $\ids'(u) < \ids(v')$ for any $u,v \in V(G)$, we have
$\mathcal{A}(G,\ports,\ids,I)(v) = \mathcal{A}(G,\ports,\ids',I)(v)$ for every
$G$, $\ports$, $I$, and $v \in V(G)$. 
Notice that an anonymous algorithm is necessarily order-invariant, but the
converse may not be true.

A \emph{decoder} $\mathcal{D}$ is a $r$-round local algorithm that runs on
graphs where the input function $I$ of every node $v$ is a pair $I(v) = (N,
\ell(v))$ where $N = \poly(n)$ is a positive integer and $\ell$ is a label
assignment of $G$. 
A \emph{binary} decoder is a decoder whose outputs are $0$ or $1$.

\paragraph{Locally checkable proofs.} We are now ready to define the
\emph{locally checkable proofs} (LCP) model. 
We say that a distributed language $\mathcal{L}$ admits an $r$-round locally
checkable proof with certificates of size $f(n)$ if there exists an $r$-round
binary decoder $\mathcal{D}$ that satisfies the following two conditions:
\begin{description}
  \item[Completeness:] For every $n$-node $G \in \mathcal{G}(\mathcal{L})$, every port assignment $\ports$, and every identifier assignment $\ids$, there exists a labeling $\ell$ of $G$ of size $f(n)$ such that, for every $v \in V(G)$,~$\mathcal{D}(v) =~1$.
  \item[Soundness:] For every $n$-node $G \notin \mathcal{G}(\mathcal{L})$, every port assignment $\ports$, every identifier assignment $\ids$, and every labeling $\ell$ of $G$ of size $f(n)$, there exists a node $v \in V(G)$ such that~$\mathcal{D}(v) = 0$.
\end{description}
An LCP is called \emph{anonymous} if the binary decoder that defines it is
anonymous.

\subsection{Strong locally checkable proofs}

We introduce our first variant of the LCP model. We say that a language $\mathcal{L}$ admits a \emph{strong LCP} if, in addition to the completeness and soundness properties, the decoder $\mathcal{D}$ satisfies the \emph{strong soundness} property:
\begin{description}
  \item[Strong soundness:] For every $n$-node graph $G$, every port assignment
  $\ports$, every identifier assignment $\ids$, and every labeling $\ell$ of $G$
  of size $f(n)$, the subgraph induced by the set of nodes $\{v \in V(G) :
  \mathcal{D}(v) = 1\}$ is in $\mathcal{G}(\mathcal{L})$.
\end{description}
Observe that \emph{strong soundness implies soundness}. 
Indeed, in a no-instance \( G \), the set \( V(G) \) does not induce a
yes-instance; hence, \( \mathcal{D}(v) = 0 \) for at least one node \( v \in
V(G) \).

\subsection{Hiding locally checkable proofs}
\label{sec:hiding-def}

Remember that we defined distributed languages $\mathcal{L}$ as a set of pairs
$(G, x)$, where $x: V(G) \rightarrow \{0,1\}^*$. 
A \emph{hiding LCP} for $\mathcal{L}$ is one whose $r$-round decoder
$\mathcal{D}$ satisfies the following additional condition:
\begin{description}
  \item[Hiding:] For every $r$-round decoder $\mathcal{D}'$, there is an $n$-node $G \in
  \mathcal{P}$, a labeling $\ell$ of $G$ of size $f(n)$, a port assignment
  $\ports$, and an identifier assignment $\ids$ for which the following holds:
  \begin{itemize}
    \item For every $v \in V$, $\mathcal{D}(v) = 1$.
    \item $\mathcal{D}'$ fails to extract a valid witness for $G$, that is,
    $(G,(\mathcal{D}'(v))_{v\in V(G)})\notin \mathcal{L}$.
  \end{itemize}
\end{description}

Intuitively, a hiding LCP is a distributed certification algorithm that
certifies $G \in \mathcal{G}(\mathcal{L})$ \emph{without (fully) revealing} a
witness $x$ such that $(G, x) \in \mathcal{L}$. 
Note that in our definition, we allow the witness $x$ to be hidden in a single
node. 
In other words, we do not assume any condition on the number of nodes where the
witness is hidden.

An LCP can satisfy any of the previously defined properties simultaneously. For
instance, an anonymous, strong, and hiding LCP is an LCP that satisfies the
anonymous, hiding, and strong properties simultaneously. 
In particular, a hiding LCP is said to be \emph{anonymous} when all the decoders
involved in its definition (i.e., $\mathcal{D}$ and $\mathcal{D}'$) are
anonymous. 

\subsection{Strong locally checkable proofs for promise problems} 

In some of our results, we consider strong and hiding LCPs that should only work
on a subset of graphs having a certain property.
For that reason, it is convenient to work with \emph{promise problems}, where we
assume that yes-instances belong to a certain class of graphs $\mathcal{H}$.
Membership in $\mathcal{H}$ may not be easy to certify; nevertheless, we assume
(without having to verify it) that the input instance belongs to it.

Formally, let $\mathcal{L}$ be a distributed language, and let $\mathcal{H}
\subseteq \mathcal{G}(\mathcal{L})$ be a class of graphs. 
We define the \emph{$\mathcal{H}$-restricted problem} $\mathcal{L}_\mathcal{H}$
as the pair $(\mathcal{L}_\mathcal{H}^Y, \mathcal{L}_\mathcal{H}^N)$ where:
\begin{itemize}
  \item $\mathcal{L}_\mathcal{H}^Y$ is the set of yes-instances, that is,
  $\mathcal{L}_\mathcal{H}^Y = \mathcal{H}$.
  \item $\mathcal{L}_\mathcal{H}^N$ is the set of no-instances, namely the set
  of graphs $G$ such that $G \notin \mathcal{G}(\mathcal{L})$.
\end{itemize}
For graphs that are neither yes- nor no-instances, one may exhibit arbitrary
behavior.

The definitions of completeness, soundness, anonymity, and hiding are directly adapted when considering LCPs for promise problems. However, we need to be more precise in the case of the strong property. For $\mathcal{L}_\mathcal{H}$, we say that a LCP is strong if it satisfies the following condition:
\begin{description}
  \item[Strong promise soundness:] For every $n$-node $G \in \mathcal{L}_\mathcal{H}^N$, every port assignment $\ports$, every identifier assignment $\ids$, and every labeling $\ell$ of $G$ of size $f(n)$, the subgraph induced by the set of nodes $\{v \in V : \mathcal{D}(v) = 1\}$ belongs to $\mathcal{G}(\mathcal{L})$.
\end{description}

In full words, when considering strong LCP for a promise problem, we require that the subset of nodes that accept induces a graph in $\mathcal{G}(\mathcal{L})$, but not necessarily to $\mathcal{H}$.  
For instance, consider the problem of deciding whether a graph is bipartite,
with the promise that the input graph is a grid. 
For this problem, the goal is to define a certification algorithm that accepts
when the input graph is a grid and rejects when the input graph is not
bipartite. 
The above condition requires that, in no-instances, the subset of nodes that
accept induces \emph{some bipartite graph but not necessarily a grid}.

\section{The Accepting Neighborhood Graph}
\label{sec:alvg}

In this section we introduce a couple of technical tools that will be used
throughout the paper.
These are the accepting neighborhood graph and the characterization of hiding
based on it (\cref{lem:hiding-char}).

Let $\mathcal{L}$ be a distributed language, and let a graph $G \in
\mathcal{G}(\mathcal{L})$ be given along with port, identifier, and label
assignments $\ports$, $\ids$, and $\ell$.
We refer to the tuple $(G,\ports, \ids, \ell)$ as a \emph{labeled yes-instance}.

Let $\mathcal{D}$ be an $r$-round binary decoder for $\mathcal{L}$, and let $n$
be a positive integer. 
We define the set $\aviewsd$ as the set of all possible \emph{accepting views} of
$\mathcal{D}$ on graphs of at most $n$ nodes. 
Formally, a view $\mu \in \mathcal{V}_r$ belongs to $\aviewsd$ if there exists a
labeled yes-instance $(G,\ports, \ids, \ell)$ and a node $v \in V$ with
$\view(v) = \mu$ and such that $\mathcal{D}(v) = 1$.
Two views $\mu_1, \mu_2 \in \aviewsd$ are said to be
\emph{yes-instance-compatible} if there exists a labeled yes-instance $(G,
\ports, \ids, \ell)$ and an edge $\{u,v\}\in E(G)$ such that $\mu_1 = \view(u)$
and $\mu_2 = \view(v)$.
See \cref{fig:compatible-view-ex} for an example.

\begin{figure}
  \centering
  \includestandalone{figs/compatible_views}
  \caption{Example for compatible views $\mu_1 = \view(u)$ and $\mu_2 =
    \view(v)$ in a yes-instance $G$.
    Here we have $r = 2$.
    The numbers are the nodes' identifiers.
    Port numbers and labels are omitted for simplicity.
    Note how the edge between nodes $1$ and $4$ is not visible to $u$.
    This is admissible since the nodes are at distance strictly less than $2$
    from it.}
  \label{fig:compatible-view-ex}
\end{figure}

The \emph{accepting neighborhood graph} of $\mathcal{D}$, denoted $\alvgd$, is
the graph obtained from taking $\aviewsd$ as the node set and drawing edges
between every pair of yes-instance-compatible views. 
The reason for restricting the neighborhood graph to graphs of size bounded by
$n$ is its finiteness (and hence computability):

\begin{lemma}
  \label{lem:alg-construct-alvg}
  Let $\mathcal{L}$ be a distributed language and $r$ and $n$ be positive
  integers. 
  Consider an LCP of size $f(n)$ for $\mathcal{L}$ with decoder $\mathcal{D}$.
  There exists a sequential algorithm that computes $\alvgd$.
\end{lemma}

\begin{proof}
 The algorithm iterates over all possible labeled yes-instances $(G,\ports,
 \ids, \ell)$ such that $G$ is of size at most $n$. 
 On each iteration, the algorithm adds to the vertex set of \(\alvgd\) the set
 $\{\view(v): v\in V(G)\}$ and to the edge set all pairs
 \[
  \{\{\view(u), \view(v)\}: \{u, v\} \in E(G)\}.
 \]
  Since all sets are finite, the algorithm halts in a finite number of steps. 
\end{proof}

The following lemma gives us a characterization of hiding in terms of the local
view graph $\alvgd$:

\begin{lemma}
  \label{lem:hiding-char}
  Let $\mathcal{D}$ be an $r$-LCP for $\kcol_\mathcal{H}$. 
  Then $\mathcal{D}$ is hiding if and only if there is $n$ such that $\alvgd
  \notin \kcolg$.
\end{lemma}

\begin{proof}
  We prove the claim by showing that $\mathcal{D}$ is not hiding if and only if
  $\alvgd \in \kcolg$ for every $n$.

  First we prove the forward implication.
  If $\mathcal{D}$ is not hiding, then we have a decoder $\mathcal{D}'$ such
  that, for every labeled yes-instance $(G,\ports,\ids,\ell)$,
  $(\mathcal{D}'(v))_{v \in V(G)}$ is a witness for $G$ being in $\kcolg$.
  Then, for any $n$, (the restriction of) $\mathcal{D}'$ is a proper
  $2$-coloring of $\alvgd$ as a map from $\aviewsd$ to $[k]$:
  By definition of $\alvgd$, for any two neighboring views $\mu_1$ and $\mu_2$
  in $\alvgd$, there is a $k$-colorable graph $G$ (on less than $n$ nodes) with
  nodes $u$ and $v$ connected by an edge in $G$ and such that $\mu_1 = \view(u)$
  and $\mu_2 = \view(v)$.
  Since $\mathcal{D}'$ outputs a correct witness to $G \in \kcolg$, we have
  $\mathcal{D}'(\mu_1) \neq \mathcal{D}'(\mu_2)$.

  To prove the converse, we assume $\alvgd \in \kcolg$ for every $n$ and show
  how to construct a decoder $\mathcal{D}'$ that extracts a $k$-coloring from
  the certificate for $\mathcal{D}$.
  Let $n$ be given.
  Using \cref{lem:alg-construct-alvg}, we have an algorithm $\mathcal{A}$ that
  constructs $\alvgd$.
  We fix an arbitrary proper $k$-coloring $c$ of $\alvgd$ that can be computed
  deterministically from $\alvgd$ (e.g., $c$ is the lexicographically first
  coloring of $\alvgd$ where nodes are ordered as they appear in the output of
  $\mathcal{A}$).

  Now let $G$ be an input graph on $n$ nodes, and let $\ell$ be a labeling of
  $G$ that is accepted by $\mathcal{D}$.
  The decoder $\mathcal{D}'$ has every node $u \in V(G)$ execute the following
  procedure:
  \begin{enumerate}
    \item Execute $\mathcal{A}$ to construct $\alvgd$.
    \item Compute $c$.
    \item Determine own view $\mu_u = \view(u)$ in $\alvgd$.
    \item Output $c(\mu_u)$.
  \end{enumerate}
  This procedure is essentially correct by construction:
  For any two neighboring nodes $u,v \in V(G)$, since $u$ and $v$ are connected
  by an edge, their respective views $\mu_u$ and $\mu_v$ are connected in
  $\alvgd$.
  Thus, since $c$ is proper, $\mathcal{D'}(u) \neq \mathcal{D}'(v)$.
\end{proof}

\section{Upper bounds in the anonymous case}
\label{sec:anonymous-ub}

Our goal in this section is to prove:

\restateThmDegOneOrEvenCycle*

\subsection{Graphs with minimum degree 1}
We show first the following result:
\begin{lemma}
  Let $\mathcal{H}_1$ be the class of graphs $G$ for which $\delta(G) = 1$.
  There is an anonymous, strong and hiding one round LCP for $\twocol_{\mathcal{H}_1}$ using certificates of constant size.
\end{lemma} \label{lemm:degree1hiding}

Recall that, as discussed in \cref{sec:hiding-def}, it is sufficient to hide the
$2$-coloring at a single node.
The strategy is to hide the $2$-coloring at nodes with degree one.
This works for the strong soundness requirement because these nodes can never be
part of a cycle, let alone an odd one.

\begin{proof}
First, we start by describing the certificates assigned by the prover. Let $G=(V,E)$ be an instance of $2$-coloring. The prover assigns to each node a certificate $\ell:V \mapsto \{0,1,\bot, \top\}$. Intuitively, in a yes-instance, the prover will assign $\bot$ to a degree $1$ node, $\top$ to its unique neighbor and $\{0,1\}$ to the rest of the nodes in the graph, representing a $2$-coloring of that part. 



In a yes-instance $G$, since we are assuming $G \in \mathcal{H}$ then, there exists at least one node $u$ such that the degree of $u$ is $1$. In addition, nodes receiving $\{0,1\}$ are actually learning its coloring from their certificate.

We define the decoder $\mathcal{D}$ as follows for a node $v \in V$, a labeling $\ell$ and a port assignment $\ports$:
\begin{enumerate}
    \item If node $v$ receives a certificate $\ell(v) = \bot$,   $\mathcal{D}(v,\ell,\ports) = \textbf{accept}$ if
    \begin{enumerate}
        \item $\delta(v) = 1$ 
        \item Its only neighbor $u$ is labeled by $\ell(u) = \top$.
    \end{enumerate} Otherwise, $\mathcal{D}(v,\ell,\ports)= \textbf{reject.}$
    \item If node $v$ receives a certificate $\ell(v) = \top$, $\mathcal{D}(v,\ell,\ports) = \textbf{accept}$ if:
    \begin{enumerate}
        \item there exists a unique $u \in N(v)$ such that $\ell(u) = \bot$.
        \item For all $w \in N(v) \setminus \{u\}, \ell(w) = \beta \in \{0,1\}$. 
    \end{enumerate}  Otherwise, $\mathcal{D}(v,\ell,\ports)= \textbf{reject.}$
    \item If node $v$  receives certificate $\ell(v) \in \{0,1\}$,  $\mathcal{D}(v,\ell,\ports) = \textbf{accept}$ if:
    \begin{enumerate}
        \item There exists at most one neighbor $u \in N(v)$ such that $\ell(u) = \top$.
        \item For every $w \in N(v) \setminus \{u\}$, we have that $\ell(w) \in \{0,1\}$ and $\ell(v) = \ell(w) +1 \mod 2$. 
    \end{enumerate}
Otherwise, $\mathcal{D}(v)= \textbf{reject.}$
\end{enumerate}

We claim that the decoder $\mathcal{D}$ is a hiding and strong LCP. First we show that $\mathcal{D}$ is an LCP, i.e. it satisfies soundness and completeness.

If $G$ is a yes-instance for $2$-coloring equipped with some port assignment $\ports$  then, there exists a certificate $\ell$ assigned by the prover to each node in $G$ such that:

\begin{enumerate}
    \item $\bot$ is assigned to some node $u$ such that $\delta(u) =1$, i.e. $\ell(u) = \bot$.
    \item $\top$ is assigned to the unique node $v$ such that $v \in N(u)$, i.e. $\ell(v)= \top$.
    \item Some color $\beta \in \{0,1\}$ is assigned to each node $w \in N(v)$ i.e. $\ell(w) = \beta \in \{0,1\}$. 
    \item For the nodes $x \in V\setminus\{u,v\}$, the prover assigns a proper coloring, i.e. $\forall x \in V\setminus\{u,v\} , \forall y \in N(x)\setminus \{v\}$ the labeling $\ell$ satisfies  $\ell(x) = \ell(y)+1\mod 2$.
\end{enumerate}
The existence of this latter labeling follows from the fact that $G$ is a yes-instance and by construction we have that $\forall v \in V, \mathcal{D}(v,\ell,\ports) = \textbf{accept}$. Thus, completeness holds.
\end{proof}
Let us show that the decoder is strong (soundness then holds from the fact that strong soundness implies soundness). By contradiction, let us assume that there exists some instance $G=(V,E)$ some port assignment $\ports$ and a labeling $\ell$ such that $G' = G [\{v\in V: \mathcal{D}(v)=1\}]$ contains some odd cycle $C$. Since nodes in $C$ accept, we must have that there must exists some node $x \in V(C)$ such that its certificate does not contain a color, i.e. $\ell(x) \in \{\top,\bot\}$. This node $x$ must also accept, i.e. $\mathcal{D}(x,\ell,\ports) = \textbf{accept.}$ Thus, this node cannot have a $\bot$ labeling since it must have degree $1$ to accept and since $x\in V(C)$ we have that $\delta(x)\geq 2$. The only choice then is that $\ell(x) = \top$. But in that case, since $x$ accepts, then it has exactly one neighbor $u$ such that $\ell(u)=\bot$ and all the rest of its neighbors are labeled by some color $\beta \in \{0,1\}$. Since $C$ is odd, then $u \in V(C)$ which is a contradiction since $u$ must have degree $1$. Strong promise soundness holds.

%Let us show now that the decoder $\mathcal{D}$ is hiding. We proceed by applying \cref{lem:hiding-char}. More precisely, we are going to exhibit a cycle with $7$ nodes in $\alvgd$.  Let us consider two labeled anonymous yes-instances $I_1 = (G_1, \ell_1,\ports_1)$ and $I_2 = (G_2, \ell_2,\ports_2)$. Remember that since $I_1$ and $I_2$ are yes-instances then, there exists $u_1 \in V(G_1), u_2 \in V(G_2)$ such that $\delta(u_1)=\delta(u_2)=1$. Let us call $v_1$ (resp. $v_2$) to the unique neighbor of $u_1$ (resp. $u_2$). Observe that, by construction, for all $w \in N(v_1)$ we have that $\ell(w) = \beta_1 \in \{0,1\}$. Analogously, we have that the neighbors of $v_2$ in $G_2$ are labeled with some unique color $\beta_2$. We take $I_1$ and $I_2$ such that $\beta_1 \not = \beta_2$.  Without loss of generality, we assume $\beta_1=0$ and $\beta_2=1$. See \cref{fig:instancesdeg1}. 

%The cycle then is composed by the view of $u$ in $G_1$ (observe that this view
%is the same than in $G_2$), then the view of $v$ in $G_1$, the view of some
%neighbor $w_1$ of $v$ in $G_1$ the view of some neighbor $x$ in $G_1$ (observe
%that this view can also be in $G_2$), the view of a neighbor $y$ of $x$ in $G_1$
%(which can also be in $G_2$), the view of some neighbor $w_1$ of $v_2$ in $G_2$,
%the view of $v_2$ in $G_2$ and finally the view of $u_2$. The complete cycle is
%given in \cref{fig:oddcycledegree1}. By \cref{lem:hiding-char} the
%hiding property for $\mathcal{D}$ holds and so the main result follows.

Finally, to argue that $\mathcal{D}$ is hiding, consider the two instances on
\cref{fig:instancesdeg1}. 
Then $\mathcal{V}(\mathcal{D},4)$ contains the odd cycle depicted on
\cref{fig:oddcycledegree1}. 
We apply \cref{lem:hiding-char}.

\begin{figure}
  \centering
  \includestandalone{figs/instances_deg1}
  \caption{Anonymous labeled instances $I_1$ and $I_2$ for the proof of
  \cref{lemm:degree1hiding}.
  The numbers inside the nodes are the identifiers.
  The labels are written above the nodes in red.
  The neighborhood of the node $1$, which is marked in orange, is identical in
  the two instances.}
  \label{fig:instancesdeg1}
\end{figure}

\begin{figure}
  \centering
  \resizebox{\textwidth}{!}{%
    \includestandalone{figs/oddcycle_deg1}
  }
  \caption{Odd cycle in $\mathcal{V}(\mathcal{D},4)$ for graphs with minimum
  degree $1$. 
  The center node of a view is marked in orange.
  The blue, green, and yellow shades correspond to the areas of the instances
  from \cref{fig:instancesdeg1}.}
  \label{fig:oddcycledegree1}
\end{figure}

\subsection{Cycle}
\label{sec:ub-cycle}

\begin{lemma} \label{lemm:cyclehiding}
  Let $\mathcal{H}_2$ be the class of even cycles.
  There is an anonymous, strong and hiding one-round LCP for $\twocol|_{\mathcal{H}_2}$ using certificates of constant size.
\end{lemma}

The strategy in this case is to reveal a $2$-edge-coloring of the cycle.
Unlike the case of $\delta(G) = 1$, this hides the $2$-coloring
\emph{everywhere}.

\begin{proof}

We describe a Hiding LCP $\mathcal{D}(v,\ell, \ports)$ for $2$-coloring restricted to $\mathcal{H}_2$. 

We consider labeling maps of the form $\ell:V\mapsto (S  \times \{0,1\})^2$, where $S \subseteq \binom{\{1,2\}}{2} \cup \binom{\{1,2\}}{1}. $ Intuitively a valid labeling will encode a $2$-edge coloring. In fact, observe that given an instance $G=(V,E) \in \mathcal{H}_2$ and a port assignment $\ports$ for $G$, for each $e=uv \in E$ there exists a unique pair of ports $\ports(u,e)\ports(v,e)$ which represents the edge $e$.  Then, if $\varphi:E\mapsto\{0,1\}$ is an edge coloring, there exists a labeling $\ell_{\varphi}:V\mapsto (S \times \{0,1\})^2$, such that for each node $v$ and its two neighbors $v_1,v_2$ we have that 
\[\ell(v) = \left(
  \left(\ports(v,v_1v)\ports(v_1,v_1v),\varphi(v_1v)\right),
  \left(\ports(v,v_2v)\ports(v_2,v_2v),\varphi(v_2v)\right)
  \right).\]
Observe that if $G \in \mathcal{H}_2$ then $G$ is $2$-colorable if and only if $G$ is $2$-edge-colorable. The idea is that, the nodes can verify a proper $2$-edge-coloring but they are not able to extract the $2$-coloring from this information.

We call a labeling of the form $\ell:V\mapsto (\S \times \{0,1\})^2$, where $S \subseteq \binom{\{1,2\}}{2} \cup \binom{\{1,2\}}{1}, $ a \emph{valid labeling.} Otherwise we call it \emph{non valid.}

We define the decoder $\mathcal{D}$ as follows for node $v \in V$, a labeling $\ell$ and a port assignment $\ports:$

\begin{enumerate}
    \item if node $v$ receives a non valid labeling then $\mathcal{D}(v,\ell,\ports)=\textbf{reject}$.
    \item If $\ell$ is valid, then node $v$ with neighbors $v_1,v_2$ receives the certificate: \[\ell(v) = ((p_1(v)p_2(v),c_1(v)), (p_3(v)p_4(v),c_2(v)) ).\]
Also observe that view of $v$ has the form:
    \[\view(v) = \{(\ports(v,v_1v),\ell(v_1)),(\ports(v,v_2v),\ell(v_2))\}.\]
    If \[\ell(v) \not =(\ports(v,v_1v)\ports(v_1,v_1v),c_1(v)), (\ports(v,v_2v)\ports(v_2,v_2v),c_2(v)),\]
   then, $\mathcal{D}(v,\ell,\ports)=\textbf{reject.}$ 
    \item If $\ell$ is valid and if \[\ell(v) =(\ports(v,v_1v)\ports(v_1,v_1v),c_1(v)), (\ports(v,v_2v)\ports(v_2,v_2v),c_2(v))\]
    then, $\mathcal{D}(v,\ell,\ports)=\textbf{accept}$  if:
    \begin{itemize}
       \item $c_1(v) \not = c_2(v)$
        \item $\ell(v_1)$ contains edge $p_1(v)p_2(v)$ and color $c_1(v)$
        \item  $\ell(v_2)$ contains edge $p_3(v)p_4(v)$ and color $c_2(v)$
    \end{itemize} 
    Otherwise $\mathcal{D}(v,\ell,\ports)=\textbf{reject.}$
\end{enumerate}

Now we show that $\mathcal{D}$ is a hiding and strong LCP. First, $\mathcal{D}$ satisfies completeness because for any $G=(V,E) \in \mathcal{H}$, we have that $G \in \mathcal{G}(\twocol)$ if and only if there exists a proper $2$-edge-coloring $\varphi:E\mapsto\{0,1\}$. By the previous observations, we have that, for any assignation of ports $\ports$, there exists some (valid) labeling $\ell_{\varphi}$ such that (by construction) for every $v \in V$, $\mathcal{D}(v,\ell,\ports) = \textbf{accept}$. Thus, $\mathcal{D}$ satisfies completeness.

To see that $\mathcal{D}$ is hiding, consider the instances on
\cref{fig:instancescycles} as well as the odd cycle on \cref{fig:oddcyclecycles}
and apply \cref{lem:hiding-char}.

\begin{figure}
    \centering
    \includestandalone{figs/instances_cycle}
    \caption{Instances $I_1$ and $I_2$ for the proof of
    \cref{lemm:cyclehiding}.}
    \label{fig:instancescycles}
\end{figure}

\begin{figure}
    \centering
    \resizebox{\textwidth}{!}{%
      \includestandalone{figs/oddcycle_cycle}
    }
  \caption{Odd cycle in $\mathcal{V}(\mathcal{D},6)$.
    Views in green shade originate from $I_1$ while views are from instance
    $I_2$ of \cref{fig:instancescycles}.}
    \label{fig:oddcyclecycles}
\end{figure}


Now, let us show that $\mathcal{D}$ is strong. Let us consider a graph $G$ and some port assignment $\ports$. Let us call $G'=G [\{v\in V: \mathcal{D}(v)=1\}]$ and let us assume that $G'$ has an odd cycle $C$. By construction, we have that this cannot be possible since we must have that some node $v \in V(C)$ is such that $\mathcal{D}(v) = \textbf{reject}$ otherwise it will contradict the parity of $C$. In fact, since all the nodes in $C$ accept, any node $v \in V(C)$ is such that $\ell(v)$ contains a proper $2$-edge coloring. Since $G'$ cannot contain an odd cycle then, $G'$ is bipartite and thus $\mathcal{D}$ is strong. The lemma holds.

\end{proof}

\section{Impossibility in the order-invariant case}
\label{sec:oi-lb}

In this section, our goal is to show our impossibility result in the
order-invariant case (\cref{thm:oi-bip-impossibility}).
Before we can state the proof, we first need to set up some technical lemmas
concerning the accepting neighborhood graph (\cref{sec:stgo-postulate}).  
Using these new tools, we then prove our theorem in
\cref{sec:proof-oi-lb}.

\subsection{Realizing subgraphs of the accepting neighborhood graph}
\label{sec:stgo-postulate}

Fix an $r$-round LCP $\mathcal{D}$.
We will look at results of the following nature:
Given a subgraph $H$ of $\alvgd$ (possibly satisfying some requirements),
construct a graph $G_\bad$ that contains a subgraph $H'$ isomorphic to $H$ and
such that $V(H')$ is a subset of the nodes accepted by $\mathcal{D}$ in
$G_\bad$.

Let $\mu_1, \mu_2 \in \mathcal{V}_r$ be two views (not necessarily accepting)
with center nodes $v_1$ and $v_2$, respectively, and let $u$ be a node in
$\mu_1$.
We say $u$ is \emph{compatible} with $\mu_2$ if the following holds:
\begin{enumerate}
  \item $u$ has the same identifier as the center node of $\mu_2$, that is,
  $\ids_{\mu_1}(u) = \ids_{\mu_2}(v_2)$.
  \item For every node $w_1$ in $\mu_1$ that is at distance \emph{strictly less}
  than $r$ from $v_1$, if there is a node $w_2$ in $\mu_2$ with
  $\ids_{\mu_1}(w_1) = \ids_{\mu_2}(w_2)$ and $\dist(v_1,w_2) < r$, then $w_1$
  and $w_2$ have identical views of radius one (including ports, identifiers,
  and labels), that is, $\view_1(\mu_1)(w_1) = \view_1(\mu_2)(w_2)$.
\end{enumerate}
In addition, we say that $\mu_1$ is \emph{compatible} with $\mu_2$ \emph{with
respect to $u$} if $u$ is compatible with $\mu_2$.
Note this is a different concept than the yes-instance-compatibility we defined
in \cref{sec:alvg}.
In particular, here we are considering also non-neighboring nodes and we do not
require them to coexist in the same yes-instance.
For an example, see \cref{fig:compatible-node-ex}.

\begin{figure}
  \centering
  \includestandalone{figs/compatible_node}
  \caption{Example of views $\mu_1 = \view(v_1)$ and $\mu_2 = \view(v_2)$ where
    $\mu_1$ is compatible with $\mu_2$ with respect to the node $u$.
    As in \cref{fig:compatible-view-ex}, here we have $r = 2$ and have omitted
    ports and labels for simplicity.
    Note how the nodes $2$ and $4$ are allowed to have very different views than
    in $\mu_1$; in this case, the only node in $\mu_1$ required to have an
    identical radius-one view in $\mu_2$ is the node $9$.
  }
  \label{fig:compatible-node-ex}
\end{figure}

Let $H$ be a subgraph of $\alvgd$, and let $\mathcal{I} \subseteq [N]$ be the
set of identifiers that appear in at least some view of $H$.
For $i \in \mathcal{I}$, let $S(i) = S_H(i)$ denote the subgraph of $H$ induced
by the views of $H$ that contain a node with identifier $i$.
We say that $H$ is \emph{realizable} if it satisfies the following:
\begin{quote}
  For every $i \in \mathcal{I}$, there is a (not necessarily accepting) view
  $\mu_i \in \mathcal{V}_r$ such that, for every view $\mu \in S(i)$ where a
  node $u_i$ with $\ids_\mu(u_i) = i$ appears, $u_i$ is compatible with $\mu_i$.
\end{quote}
This definition comes with the following lemma, which motivates its name:

\begin{lemma}
  \label{lem:realizable}
  Let $\mathcal{D}$ be an $r$-round LCP.
  If $H$ is a realizable subgraph of $\alvgd$, then there is an instance
  $G_\bad$ with at most $N$ nodes that contains a subgraph isomorphic to $H$
  whose nodes are all accepted by $\mathcal{D}$.
\end{lemma}

The conceptual reason for using the subscript \enquote{bad} is that, if $H$ is
some forbidden structure that $\mathcal{D}$ should not accept, then $G_\bad$ is
a counter-example to the strong soundness of $\mathcal{D}$.
We will not be needing this fact later, but it is interesting to note that we do
not need the order-invariance of $\mathcal{D}$ for this particular result.

\begin{proof}
  First we make an quick observation regarding the property required in the
  statement.
  Let $\mathcal{C} \subseteq \mathcal{I}$ be the set of identifiers of center
  nodes in the views of $H$.
  Note that, for $i \in \mathcal{C}$, there is a unique view $\mu_i$ that
  satisfies the requirement for realizability.
  In particular, we have that there is a single view in $H$ with a center node
  having $i$ as its identifier and also that $\mathcal{D}(\mu_i) = 1$.

  Let us now describe the construction of $G_\bad$.
  Take a copy of each $\mu_i$ for $i \in \mathcal{I}$ and consider the graph
  $G_\base$ obtained from their (disjoint) union.
  (The identifiers in $G_\base$ may not be unique, but this is immaterial since
  $G_\base$ is simply an intermediate step in the construction.)
  We let $G_\bad$ be the graph obtained from $G_\base$ by identifying nodes
  possessing the same identifier; that is, for each $i \in \mathcal{I}$, the
  vertex with identifier $i$ in $G_\bad$ is the subset of $V(G_\base)$
  containing every $v \in V(G_\base)$ that has identifier $i$.
  To simplify matters, we let nodes in $G_\bad$ be synonymous with their
  identifiers (i.e., the node set of $G_\bad$ becomes simply $\mathcal{I}$).
  For $i,j \in \mathcal{I}$, we draw an edge between $i$ and $j$ in $G_\bad$ if
  and only if there is some view $\mu_k$ (where $k \in \mathcal{I}$) that
  contains nodes $v_i$ and $v_j$ having identifiers $i$ and $j$, respectively,
  that have an edge between them.
  Note that this is well-defined only because $H$ is realizable, that is,
  identified nodes in distinct views have suitable neighbors due to the
  compatibility between views.

  We extend $G_\bad$ with port and label assignments as specified by the
  $\mu_i$.
  For the label assignment $\ell_{G_\bad}$, we simply let $\ell_{G_\bad}(i) =
  \ell_{\mu_i}(i)$ for every $i$.
  Meanwhile, for the port assignments, we do the following: 
  For every $i \in \mathcal{I}$ and every edge $e = ij \in E(G_\bad)$, we let
  $\ports_{G_\bad}(i, e) = \ports_{\mu_i}(v_i, v_iv_j)$, where $v_i$ and $v_j$
  are the vertices with identifiers $i$ and $j$ in $\mu_i$, respectively.

  The identifier, port, and label assignments are well-defined by definition of
  $\mu_i$.
  What is left to argue is that $G_\bad[\mathcal{C}]$ is isomorphic to $H$:
  Let $i,j \in \mathcal{C}$ and consider $\mu_i$ and $\mu_j$ in $\alvgd$.
  If there is an edge between $\mu_i$ and $\mu_j$, then in $\mu_i$ we have a
  node $v_j$ with $\ids_{\mu_i}(v_j)$ and such that $v_iv_j \in E(\mu_i)$, where
  $v_i$ is the center node of $\mu_i$; hence there is an edge between $i$ and
  $j$ in $G_\bad$.
  Conversely, if there is no edge between $\mu_i$ and $\mu_j$ in $\alvgd$, then
  there is no such node $v_j$ in $\mu_i$, implying there is also no edge between
  $i$ and $j$ in $G_\bad$.
\end{proof}

Next we now show how to use the anonymity or order-invariance of $\mathcal{D}$
to obtain the conclusion of \cref{lem:realizable} based on a weaker assumption
on $H$.
To that end, consider the following weakening of realizability, which we shall
refer to as \emph{component-wise realizability}:
\begin{quote}
  For every $i \in \mathcal{I}$ \emph{and for every connected component $C$ in
  $S(i)$,} there is a (not necessarily accepting) view $\mu_i(C) \in
  \mathcal{V}_r$ such that, for every view $\mu \in V(C)$ where a node $u_i$
  with $\ids_\mu(u_i) = i$ appears, $u_i$ is compatible with $\mu_i$.
\end{quote}

\begin{lemma}
  \label{lem:realizable-oi}
  Let $\mathcal{D}$ be order-invariant, and let $H$ be a component-wise
  realizable subgraph of $\alvgd$.
  In addition, suppose that $\abs{V(H)} \le \sqrt{N / \Delta^r}$.
  Then the conclusion of \cref{lem:realizable} holds; that is, there is an
  instance $G_\bad$ with at most $N$ nodes that contains a subgraph isomorphic
  to $H$ and whose nodes are all accepted by $\mathcal{D}$.
\end{lemma}

We stress that here (unlike the case of \cref{lem:realizable}) the assumption
that $\mathcal{D}$ is order-invariant is essential for the proof to go through.
Albeit the statement is rather technical, the idea for the proof is simple:
If $S(i)$ has more than one component, we simply replace $i$ in one of the
components with a fresh identifier that does not appear yet in $H$.
To do so, we must take care that we are not exceeding our budget of $N$
identifiers and also that we are respecting the local ordering of identifiers.

\begin{proof}
  First note that, if $S(i)$ has a single component for every $i$, then we may
  apply \cref{lem:realizable} directly.
  Hence it is sufficient to show a reduction to that case.
  Without restriction, we assume that $\mathcal{I} = [t]$ for some positive
  integer $t$ (i.e., there are no \enquote{gaps} in the set of identifiers
  appearing in $H$).

  Let thus $i \in \mathcal{I}$ be given such that $S(i)$ has two or more
  components, and pick some component $C$ of $S(i)$.
  For the sake of simplicity, consider first the case where $\mathcal{D}$ is
  anonymous.
  Then, for any view $\mu \in \aviewsd$ that contains some node $u_i$ with
  $\ids_\mu(u_i) = i$, the view $\mu'$ obtained by replacing the identifier of
  $u_i$ with some $i' \neq i$ is also in $\aviewsd$ (as long as $i' \le N$).
  If we perform this modification consistently for all views in the component
  $C$, then the subgraph $H'$ of $\alvgd$ that we obtain is isomorphic to $H$.
  Since there are at most $\Delta^r \abs{V(H)} \le N$ nodes that are visible
  across all the views in $H$, we can guarantee that the replacement $i'$ is
  smaller than $N$.

  For the general case where $\mathcal{D}$ is order-invariant we use the same
  strategy but take care to pick $i'$ adequately.
  More specifically, we associate every $i \in \mathcal{I}$ with the set $I_i =
  [(i-1) \abs{V(H)} + 1, i \abs{V(H)}]$.
  Since every $S(i)$ does not have more than $\abs{V(H)}$ components, this
  allows us to pick a different replacement $I_i$ (as described above) for every
  component of $S(i)$.
  Moreover, we note that, for any $i,j \in \mathcal{I}$, we have $i < j$ if and
  only if $i' < j'$ for every $i' \in I_i$ and $j' \in I_j$.
  Hence this replacement of identifiers preserves the local order of
  identifiers, and hence the behavior of $\mathcal{D}$ in the respective view is
  the same.
  Finally, for the bound on the number of nodes, as before, the largest
  identifier that appears in $H$ is $\Delta^r \abs{V(H)}$, and hence the largest
  identifier that we replace it with is $\Delta^r \abs{V(H)}^2 \le N$.
\end{proof}

Notice that, although we assumed $H$ to be a subgraph of $\alvgd$, it was not
necessary to use that we realize every view at most once.
In particular, we may use the same arguments to obtain the following statement:

\begin{lemma}
  \label{lem:realizable-oi-walk}
  Let $\mathcal{D}$ be order-invariant, and let $W$ be a component-wise
  realizable closed walk in $\alvgd$.
  In addition, suppose that $\abs{V(W)} \le \sqrt{N / \Delta^r}$.
  Then the conclusion of \cref{lem:realizable} holds; that is, there is an
  instance $G_\bad$ with at most $N$ nodes that contains a closed walk
  isomorphic to $W$ over nodes accepted by $\mathcal{D}$.
\end{lemma}

\subsection{Proving \texorpdfstring{\cref{thm:oi-bip-impossibility}}{Theorem
\ref{thm:oi-bip-impossibility}}}
\label{sec:proof-oi-lb}

We now turn to the proof of our main lower bound result:

\restateThmOIBipImpossibility*

Let us discuss the proof strategy in more detail (see also
\cref{sec:intro-techniques}).
Suppose we have a hiding LCP $\mathcal{D}$ for $\twocol_\mathcal{H}$.
Without restriction we may assume that $\mathcal{H}$ \emph{only} consists of
$r$-forgetful connected graphs $G$ with $\delta(G) \ge 2$, and containing at
least two cycles.
This is the case because, if we have a strong and hiding LCP $\mathcal{D}$ for
$\mathcal{H}$, then we have a strong and hiding LCP for any subclass of
$\mathcal{H}$.

The main idea is to apply \cref{lem:hiding-char} and then construct a
counter-example to $\mathcal{D}$ being a strong LCP:
Fix $n$ such that $\mathcal{H}$ restricted to graphs on $n$ nodes is not empty.
Using \cref{lem:hiding-char}, we have that $\alvgd$ contains an odd cycle $C$.
Nevertheless, $C$ may arrange views in $\alvgd$ in a way that is not realizable
(see \cref{sec:stgo-postulate}).
We show how to construct an odd \emph{closed walk} in $\alvgd$ that always
avoids this problem.

Before we delve into the technicalities, let us introduce a new notion for
closed walks in $\alvgd$:
We say a walk $W$ in $\alvgd$ is \emph{non-backtracking} if, for every view
$\mu$ in $W$, the successor $\mu_>$ and predecessor $\mu_<$ of $\mu$ in $W$ are
such that $\ids_{\mu_>}(v_>) \neq \ids_{\mu_<}(v_<)$, where $v_>$ and $v_<$ are
the center nodes of $\mu_>$ and $\mu_<$, respectively.
Notice that it is always possible to construct a non-backtracking walk in graphs
with minimum degree at least two simply by repeatedly choosing a successor that
differs from the predecessor of the currently visited node.

It is evident from the material in \cref{sec:stgo-postulate} that being
non-backtracking is a necessary condition for the realizability of closed walks.
As we show next, this condition turns out to also be \emph{sufficient} if we are
in the class of graphs $\mathcal{H}$.

\begin{lemma}
  \label{lem:odd-walk-realizability}
  Let $\mathcal{D}$ be an $r$-round LCP for $\twocol_\mathcal{H}$.
  In addition, let $\alvgd$ contain a non-backtracking odd walk $W$.
  Then there is an odd closed walk $W'$ in $\alvgd$ that is component-wise
  realizable.
  Moreover, we have $\abs{V(W')} = \cO(n) \cdot \abs{V(W)}$.
\end{lemma}

The idea for the proof is to replace every edge of $W$ with a path long enough
so that the view we started with is entirely \enquote{forgotten}.

\begin{proof}
  For every edge $e = \mu_1\mu_2 \in E(W)$, fix a yes-instance $G_e \in
  \mathcal{H}$ on $n$ nodes that verifies that $\mu_1$ and $\mu_2$ are
  yes-instance-compatible.
  Notice that, since $G_e$ has diameter at least $2r+1$ (by
  \cref{lem:forgetful-diam}), it must have some node $v_{\mu'}$ whose view $\mu'
  = \view(v_{\mu'})$ has no single node in common with $\mu_1$ nor $\mu_2$.
  Let $v$ and $u$ denote the center nodes of $\mu_1$ and $\mu_2$, respectively.
  Construct a closed walk $W_e$ in $G_e$ by executing the following procedure:
  \begin{enumerate}
    \item Start at $u$.
    \item Take the edge to $v$.
    \item Pick a path $P = (v_0 = v, \dots, v_r)$ such that, for every $w \in
    V(\mu_2)$, $\dist(v_i,w)$ is monotonically increasing.
    (This is guaranteed by the $r$-forgetfulness of $G$.)
    Follow $P$ in order up to $v_r$.
    \item Since $\delta(G) \ge 2$, there is a path from $v_r$ to $v_{\mu'}$ that
    does not go through $v_{r-1}$.
    Follow this path until $v_{\mu'}$ is reached.
    \item Again, using $\delta(G) \ge 2$, continue the walk in a
    non-backtracking manner all the way back to $u$, thus closing the walk.
  \end{enumerate}
  See \cref{fig:odd-walk-realizability} for an illustration.
  \begin{figure}
    \centering
    \includestandalone{figs/non-backtracking_walk}
    \caption{Construction of the closed walk $W_e$.
      The edge between $u$ and $v$ is marked in orange.
      The green nodes are in the path $P$ leading away from $v$.
      The light orange area is the neighborhood $N^r(v_{\mu'})$ of $v_{\mu'}$,
      which is completely disjoint from $N^r(u)$ and $N^r(v)$.}
    \label{fig:odd-walk-realizability}
  \end{figure}
  Notice that $W_e$ is a closed walk in the yes-instance $G_e$, which means it
  must be even.
  We lift $W_e$ to a closed walk $L_e$ in $\alvgd$ by associating every node
  visited by $W_e$ with its view in $\alvgd$.

  Now consider the walk $W'$ in $\alvgd$ obtained from $W$ by inserting $L_e$
  before every $e$ in $W$.
  Since the $L_e$ are non-backtracking even closed walks and $W$ itself was
  non-backtracking, $W'$ is an odd non-backtracking closed walk by construction.
  In addition, $\abs{L_e} = \cO(n)$ since every node in $G_e$ is visited by
  $W_e$ at most a constantly many times.

  It remains to show that $W'$ is component-wise realizable.
  To that end, let $\mathcal{I}$ be the set of identifiers that appear in the
  views of $W'$, and let $i \in \mathcal{I}$ be some identifier.
  Take a component $K$ in $S(i)$.
  If there is $e \in E(W)$ such that $K$ is fully contained within the subwalk
  $L_e e$ of $W'$, then the views in $K$ all appear in the same graph $G_e$ and
  hence realizability is evident.

  Consider thus the case where $K$ spans views that originate from different
  graphs.
  Since in each $L_e$ we visit the view $\mu'$ that has no node in common with
  the views $\mu_1$ and $\mu_2$ of $e = \mu_1 \mu_2$, $K$ necessarily contains
  views from at most two distinct graphs $G_{e_1}$ and $G_{e_2}$, where $e_2$
  appears later in $W'$ than $e_1$.
  In particular, $K$ must be a subwalk of $L_{e_1} e_1 L_{e_2} e_2$ in $W'$.
  We let $\mu'$ be the view of the node $u_i$ in $G_{e_1}$ with
  $\ids_{G_{e_1}}(u_i) = i$.
  Naturally, every view in $K$ that appears in $L_{e_1} e_1$ is compatible with
  $\mu'$ with respect to its node with identifier $i$ (since it comes from the
  same graph $G_{e_1}$).
  Meanwhile, for any view $\mu \in V(K)$, the $r$-forgetfulness property ensures
  that the view of the node with identifier $i$ in $\mu$ can be obtained from
  $\mu'$ by removing nodes from $\mu'$ (in a way that does not disconnect the
  view).
  Hence $\mu$ is also compatible with $\mu'$ with respect to this node.
\end{proof}

The final ingredient is showing how to find a non-backtracking odd cycle in
$\alvgd$.
Here it will be necessary to use that $\mathcal{H}$ contains graphs with at
least two cycles, which is the one assumption that we have not used thus far.

\begin{lemma}
  \label{lem:non-backtracking-odd-cycle}
  Let $\mathcal{D}$ be an $r$-round LCP for $\twocol_\mathcal{H}$.
  If $\alvgd$ contains an odd cycle $C$, then it also contains a
  non-backtracking odd walk of length $\cO(n) \cdot \abs{C}$.
\end{lemma}

\begin{proof}
  Suppose there is a view $\mu \in V(C)$ that prevents $C$ from being
  non-backtracking; that is, $\mu$ has a successor $\mu_>$ and predecessor
  $\mu_<$ in $C$ such that $\ids_{\mu_>}(v_>) = \ids_{\mu_<}(v_<)$, where $v_>$
  and $v_<$ are the center nodes of $\mu_>$ and $\mu_<$, respectively.
  We show it is possible to replace the edge $e = \mu_< \mu$ with a
  non-backtracking odd walk $W = (\mu_0 = \mu_<, \dots, \mu_k = \mu)$ from
  $\mu_<$ to $\mu$ such that $\ids_{\mu_1}(v_1) = \ids_{\mu}(v)$ and
  $\ids_{\mu_{k-1}}(v_{k-1}) \neq \ids_{\mu_>}(v_>)$, where $v$, $v_1$, and
  $v_{k-1}$ are the center nodes of $\mu$, $\mu_1$, and $\mu_{k-1}$,
  respectively.

  By construction of $\alvgd$, there is a graph $G$ where the center nodes $v_>$
  and $v$ of the views $\mu_>$ and $\mu$ are adjacent.
  Let $G'$ denote the graph obtained from $G$ by deleting the edge between $v_>$
  and $v$.
  If $G'$ consists of a single connected component, then the removal of this
  edge decreases the number of cycles in $G'$ by at most one compared to $G$.
  If the removal of the edge disconnects $G'$ into two components, then there is
  still at least one cycle in either component.
  In either case, there is a cycle $C$ in the same component as $v$ in $G'$.
  Let $u$ be a node in $C$ that is at minimal distance from $v$.
  Since $G'$ is obtained from $G$ by deleting a single edge, $C$ is also a cycle
  in $G$ and it avoids $v_<$.
  Moreover, since $G$ is bipartite, it is an even cycle.

  Let $P_{vu}$ denote a path from $v$ to $u$ of minimal length in $G'$.
  Note $P_{vu}$ avoids edges of $C$.
  Consider the walk $W_G = (v_>v) P_{vu} C_u P_{uv}$ where $P_{uv}$ denotes
  $P_{vu}$ in reverse and $C_u$ the closed walk around $C$ starting and ending
  at $u$.
  Since $C$ is even, $W_G$ is an odd walk.
  We lift $W_G$ to a walk $W$ in $\alvgd$.
  Since $W$ originates from $W_G$, $W$ is non-backtracking.
  In addition, we have $\ids_{\mu_1}(v_1) = \ids_{\mu}(v)$ since $(v_>v)$ is the
  first edge of $W_G$ and $\ids_{\mu_{k-1}}(v_{k-1}) \neq \ids_{\mu_>}(v_>)$
  because $P_{vu}$ avoids $v_<$.
\end{proof}

We now combine all of the above to obtain the proof of
\cref{thm:oi-bip-impossibility}.

\begin{proof}[Proof of \cref{thm:oi-bip-impossibility}]
  Let $\mathcal{D}$ be a hiding order-invariant $r$-round LCP for
  $\twocol_\mathcal{H}$.
  Due to \cref{lem:hiding-char}, $\alvgd$ contains an odd cycle $C$.
  By \cref{lem:non-backtracking-odd-cycle}, we may as well assume that $C$ is
  non-backtracking.
  \Cref{lem:odd-walk-realizability} then gives us an odd closed walk $W$ that is
  component-wise realizable.
  Finally, by \cref{lem:realizable-oi-walk}, we have an instance $G_\bad \notin
  \twocolg$ containing $W$ as a subgraph and, moreover, this entire subgraph is
  accepted by $\mathcal{D}$.
  It follows that $\mathcal{D}$ is not strongly sound.
\end{proof}

\section{Impossibility of constant-size certificates in the non-anonymous case}
\label{sec:ramsey}

In this section, we show that, in general, there is no strong and hiding LCP for
the non-anonymous case. 
More precisely, we show that it is not possible to have a hiding and strong LCP for
$\twocol$ restricted a specific class of bounded-degree graphs and using
constant-size certificates.  The argument is based on the fact that the existence of a hiding and strong LCP under these assumptions implies the existence of an equivalent LCP that satisfies the same properties but is also order-invariant. The core of the proof for this result is
inspired in a argument presented by \textcite{balliu24_local_podc} which relies on a Ramsey-type theorem (see for example \cite{cholak01_strength_jsl,naor95_what_siamjc} for similar applications). We introduce Ramsey's theorem first and then we state and prove the first result of the section. 

In the next lines, we use the following notation: for fixed $n \in \N$ and some set $S$ we define the set of all subsets of $S$ of cardinality $n$,  $S^{(n)} = \{\{s_1,\hdots,s_n\}: s_1,\hdots s_n \in S.\}$ 

%In addition, a $k$-component partition of some set $X$ is a collection of sets $\mathcal{P}= \{C_1,\hdots,C_k\}$ such that $X = \bigcup \limits_{s \in [k]} C_s$ and for all $s,t \in [k]$ $C_s\cap C_t = \emptyset$. 

\begin{lemma}[Ramsey's Theorem] \label{lem:ramsey}
    Let $k,n \in \mathbb{N}$ and let $\mathcal{P}$ be a $k$-coloring of $\N^{(n)}$. There exists $s \in [k]$ and some infinite subset $Y \subseteq \N$ such that for all $I \in Y^{(n)}$ we have that $\mathcal{P}(I)=s$. 
\end{lemma}

We present now the first lemma of the section: Let $\Delta,r>0$ and let us call $\mathcal{B}(\Delta,r)$
the class of graphs such that:
\begin{enumerate}
    \item  For all $G \in \mathcal{B}(\Delta,r)$ we have that $\Delta(G) \leq \Delta$ 
\item There exists some $G \in \mathcal{B}(\Delta,r) $ such that:
\begin{enumerate}
    \item $G$ is  a connected $r$-forgetful graph.
    \item $G$ is not a cycle
    \item  $\delta(G)\geq2.$
\end{enumerate}
\end{enumerate}
\begin{lemma} \label{lem:ordinvconstdeg}
        Let $\Delta,r>0.$  If there exists an $r$-round hiding and strong LCP $\mathcal{D}$ for $\twocol_{\mathcal{B}(\Delta,r)}$ using constant-size certificates then, there exists an $r$-round hiding, strong and order-invariant LCP $\mathcal{D}'$ for $\twocol_{\mathcal{B}(\Delta,r)}$ using constant-size certificates.
\end{lemma}

\begin{proof}
        Let $\mathcal{D}$ be a hiding and strong decoder for $\twocol$ restricted to class $\mathcal{B}(\Delta,r)$.  We proceed following the same construction shown in \cite{balliu24_local_podc} to show that there exists some hiding and strong decoder $\mathcal{D}'$ for $\twocol$ restricted to class $\mathcal{B}(\Delta,r)$ which is order-invariant.
    
    Indeed, observe that, for some instance $G$, an id assignation $\ids$, some port assignation $\ports$ and some labeling $\ell$, the decoder $\mathcal{D}$ is a function which maps values in \[\view(v) = 
  \left(G_v^r, \ports|_{N^r(v)}, \ids|_{N^r(v)}, I|_{N^r}(v)\right)\] to $\{0,1\}$. Thus, this information can be seen as two separated elements: 
  \begin{enumerate}
      \item The identifier assignment $X = \ids|_{N^r(v)}$.
      \item The structure $S=(G_v^r,\ports|_{N^r},I|_{N^r}(v))$ which contains the information about the graph structure $G_v^r$ and the labels of the view contained in $I|_{N^r}(v)$.
  \end{enumerate}
  Thus, $\mathcal{D} = \mathcal{D}(X,S)$. We can see $\mathcal{D}$ as a function that assigns $X$ to some function $F(S)$ depending only on $S$. Formally, $\mathcal{D}(X,S) = \mathcal{D}(X)(S) = F(S)$. We use the same notation as in \cite{balliu24_local_podc} and we call $F(S)$ a \emph{type.} Observe that since the size of the certificates $c$ is constant and $\Delta(G) \leq \Delta$ there is a constant bound on the number of nodes in $\view(v)$ and a constant bound in the number of possible labelings.  More precisely, there are at most $s \leq \Delta^{r+1} $ nodes in $N^r(v)$ and since $\ell:V \mapsto \{0,1\}^c$ there are at most $2^{cs}$ possible labelings for $\view(v)$. Thus, there exists some constant $m$ such there are $m$ different types. We assume that types are numbered from $1$ to $m$. Observe that we can assume that all the identifier assignations have size $s$ (otherwise we can pack extra identifiers). Let $\mathcal{X} = \N^{s}$ be the set of all possible id assignations for nodes in $N^r(v)$. 
 
  Observe that $\mathcal{D}$ induces an $m$-coloring $\mathcal{P}$ in $\mathcal{X}$ by assigning to $X \in \mathcal{X}$ some particular type $\mathcal{D}(X)$ between the $m$ possible choices. Observe that we can associate to each color $C \in [m]$ a particular canonical type $F$ such that for all id assignation $X$ satisfying $\mathcal{P}(X)=C$ we have that $\mathcal{D}(X)(S) = F(S)$. Thus, there are $m$ different of these canonical types $\{F_1,\hdots,F_m\}$. By \cref{lem:ramsey} there exists some infinite set of identifier assignations $I^*\subseteq \mathcal{X}^{(s)}$ and some canonical type $F^*$ such that for all $X \in I^{*(s)}$ we have $\mathcal{D}(X)(S)=F^*(S)$.

  It follows that for $\mathcal{D}$ there exists some infinite set of id assignations $B$ such that for any $X \in B$, $\mathcal{D}$ does not depend on the actual numerical value of the identifiers but only on the structure $S$.

  We would like to define a hiding decoder $\mathcal{D}'$ for $\twocol$ restricted to $\mathcal{B}(\Delta,r)$ that is also order-invariant. Given some instance $G \in \mathcal{B}(\Delta,r)$ together with an identifier assignation $\ids$, a port assignation $\ports$, and a labeling $\ell$, for all $v\in V$ decoder $\mathcal{D}'$ will consider the local order induced by $\ids$ in $N^r(v)$ and will assign identifiers to nodes in $N^r(v)$ according to some id assignment $\ids'$ in set $B$ 
  given by the previous application of \cref{lem:ramsey}. This id assignment $\ids'$ is such that the original order in $N^r(v)$ is preserved, i.e. for all $u,w \in N^r(v)$ we have that $\ids(w)<\ids(v) \iff \ids'(w) < \ids'(v).$ Observe that new assignment $\ids'$ exists since $B$ is infinite. Additionally, $\ids'$, depends only on the original (local) order induced by $\ids$, and thus $\mathcal{D}'$ depends solely on this order as well. Furthermore, note that any assignment in $B$ is mapped by $\mathcal{D}$ to some type $F^*(S)$; that is, we have $\mathcal{D}(X)(S) = F^*(S) $ for all $ X \in B $.
  Now, we would like to say that $\mathcal{D'}$ can simulate $\mathcal{D}$ in $G$ with this new id assignation. However, the problem we face now (as same as in \cite{balliu24_local_podc}) is $\mathcal{D}$ works with $\ids$ which maps each node to some value in $\{1,\hdots, \poly(n)\}$ but $B$ may contain assignations with very large numerical values.

We fix this by considering first some new instance $G'$ defined as $G$ together with some independent set of nodes $W$. Formally, we define $G' = G\cup W$ (and its corresponding id assignations and port assignations) where $W$ is a graph composed by  isolated nodes that are not connected to nodes in $V$. We also consider that size of $W$ is large enough so the identifiers for $G'$ are assigned from some set $\{1,\hdots, N^{'} \}$.  This $N^{'}$ is a large number that allow us to choose some $X \in B$ such that $X$ takes values in $\{1,\hdots, N^{'}\}$.  Observe also that $G' \in \mathcal{B}(\Delta,r)$. Now, we can correctly define $\mathcal{D}'$ as a decoder that first re-writes the original id assignation $\ids$ in $G$ and then, assigns ids according to some assignation $X \in B$ and then runs decoder $\mathcal{D}$ in $G'$. More precisely, we have that $\mathcal{D}'(v) = \mathcal{D}(v)$ for all $v \in V(G')$. Observe that $\mathcal{D}'(v)$ is order-invariant in the component $G$ of $G'$ by construction. We claim that $\mathcal{D}'$ is hiding. Indeed, observe that $\mathcal{D}'$ cannot be hiding in $W$ since any map $c:W\mapsto \{0,1\}$ is a proper coloring for $W$ and thus it is always possible to extract a valid witness for $W$. Since $\mathcal{D}$ is hiding then, $\mathcal{D'}$ must be hiding in $G$. For the strong part, we observe that since nodes in $W$ are always $2$-colorable and $\mathcal{D}$ is strong, then $\mathcal{D}'$ is strong too. We conclude that $\mathcal{D'}$ is hiding, strong and order invariant. The lemma holds.


\end{proof}

%Additionally, in \cite{}, the authors use a construction based on copies of the same instance in order to However, instead of considering copies of one instance in order to extract an infinite order-invariant set of identifiers, we modify the original instance by considering isolated nodes.

Finally, we get the desired result by using \cref{thm:oi-bip-impossibility}.
 We state the main result of the section:

\begin{theorem}[\cref{thm:full-bip-impossibility}, restated]
    Let $\Delta,r>0$ and $\mathcal{D}$ an $r$-round LCP for $\twocol_{\mathcal{B}(\Delta,r)}$ using certificates of constant size. If $\mathcal{D}$ is hiding, then $\mathcal{D}$ is not strong. 
\end{theorem}
\begin{proof}
Let $\mathcal{D}$ an $r$-round LCP for $\twocol$ restricted to the class $\mathcal{B}(\Delta,r)$ using certificates of constant size. Let us assume that $\mathcal{D}$ is hiding and strong. By \cref{lem:ordinvconstdeg} there exists an $r$-round hiding, strong and order-invariant LCP for $\twocol$ restricted to the class $\mathcal{B}(\Delta,r)$ using certificates of constant size which contradicts \cref{thm:oi-bip-impossibility}. 
\end{proof}


%In this section we study the existence of strong and hiding LCPs in the case in which the networks is equipped with identifiers. We start with some definitions and technical lemmas. Inspired in \cite{}, we show that LCPs using constant size certificates and restricted to the class of graphs with bounded degree are order-invariant.

\section{Upper bounds in the non-anonymous case}
\label{sec:non-anon-ubs}

In this section, we give evidence showing that our impossibility results cannot be extended to the non-anonymous case with non-constant certificate size. More precisely, we show that graphs that admit a shatter point, and watermelon graphs admit strong and hiding LCPs for 2-coloring. 


\subsection{Graphs with a shatter point}



Remember  that a graph \( G \) \emph{admits a shatter point} if there is a node \( v \in V(G) \) such that \( G - N[v] \) is disconnected (i.e., it has at least two different connected components). Let us consider the following characterization of bipartite graphs that admit a shatter point.

\begin{lemma}\label{lem:bipshatter}
Let \( G \) be a graph, let \( v\in V(G) \), and let \( C_1, \dots, C_k \) denote the connected components of \( G - N[v] \). Then \( G \) is bipartite if and only if, for each \( i \in [k] \), the following conditions hold:
\begin{enumerate}
    \item \( N(v) \) is independent.
    \item \( G[C_i] \) is bipartite.
    \item The nodes in \( N^2(v) \) intersect only one of the two parts of \( G[C_i] \).
\end{enumerate}
\end{lemma}

\begin{proof}
If \( G \) is bipartite, conditions (1) and (2) are directly satisfied. Condition (3) follows from the fact that, if for some \( i \in [k] \), there were two nodes \( u_1, u_2 \in N(v) \) having neighbors in different components of \( G[C_i] \), then there would exist an odd path \( P \) between \( u_1 \) and \( u_2 \) in \( G \), implying that \( P + v \) forms an odd cycle in \( G \), which is a contradiction.

Conversely, suppose that \( G \) satisfies (1)-(3), and let \( C \) be a cycle in \( G \). If for some $i\in[k]$ \( C \) is fully contained in \( C_i \cup N(v)\), then condition (1) and (2) implies that \( C \) must be even. In the other case \( v \) must belong to \( C \). Let \( u_0, \dots, u_t \), with \( t \geq 1 \), be the sequence of nodes in \( N(v) \) contained in \( C \), in the order they are visited when we traverse \( C \) starting from \( v \) in an arbitrary direction. Specifically, \( u_0 \) and \( u_t \) are the neighbors of \( v \) in \( C \), and thus their distance in \( C \) is even. Furthermore, for each \( j \in [t] \), the path between \( u_{j-1} \) and \( u_j \) must consist of nodes in the same component of \( G - N[v] \). By condition (3), the distance between \( u_{j-1} \) and \( u_j \) is even as well. Therefore, \( C \) has even length. Consequently, all cycles in \( G \) have even length, meaning \( G \) is bipartite.
\end{proof}

\restateThmShatterPoint*




\begin{proof}
We define a one-round decoder \( \mathcal{D} \) that expects labelings formatted as follows. For each node \( u \), a labeling \( \ell(u) = (\type(u), \content(u)) \), where \( \type(u) \in \{0, 1, 2\} \) and $\content(u)$ is formatted as:

\begin{itemize}
\item If \( \type(u) = 0 \), it is interpreted as \( u \) being a shatter point of \( G \). In this case, \( \content(u) \) is interpreted as \( \id^u \), where \( \id^u \) represents the node identifier of \( u \).  

\item If \( \type(u) = 1 \), it is interpreted as \( u \) being a neighbor of a shatter point \( v \). In this case, \( \content(u) \) is interpreted as a pair \( (\id^u, \colors^u) \), where \( \id^u \) represents the node identifier of \( v \), and \( \colors^u \) is a vector in \( \{0,1\}^k \), where \( \colors^u_i \) represents the color (or partition) seen by the nodes in \( N(v) \) in the \( i \)-th component of \( G - N[v] \).
\item If \( \type(u) = 2 \), it is interpreted as \( u \) belonging to a component of \( G - N[v] \), where \( v \) is a shatter point. In this case, \( \content(u) \) is interpreted as a tuple \( (\id^u, \#^u, x^u) \), where \( \id^u \) represents the identifier of the shatter point \( v \), \( \#^u \in [k] \) is the number of the component \( C \) containing \( u \) (in an arbitrary enumeration of the components), and \( x^u \in \{0,1\} \) represents the color assigned to \( u \) in a 2-coloring of \( G[C] \). 

\end{itemize}

These certificates can be encoded in $\cO(k + \log n)$ bits. Note that there are \( k \leq \min\{\Delta^2, n\} \) distinct connected components. Hence, we have defined a labeling of size $\cO(\min\{\Delta^2,n\} + \log n)$.

The decoder \( \mathcal{D} \) specifies that each node first verifies that the format is as described above. Additionally, each node checks the following:

\begin{enumerate}
\item If \( \type(u) = 0 \), \( u \) checks that \( \id^u = \id(u) \). Furthermore, for all \( w_1, w_2 \in N(u) \), it verifies that \( \type(w_1) = \type(w_2) = 1 \), \( \content(w_1) = \content(w_2) \), and \( \id^{w_1} = \id^{w_2} = \id(u) \).
\item If \( \type(u) = 1 \), \( u \) verifies the following:
\begin{enumerate}
\item For all \( w \in N(u) \), \( \type(w) \neq 1 \).
\item There exists a unique \( w \in N(u) \) such that \( \type(w) = 0 \). For such \( w \), it must hold that \( \id^u = \id^w \).
\item If \( w \in N(u) \) satisfies \( \type(w) = 2 \), then \( \id^w = \id^u \) and \( \colors^u_{\#^w} = x^w \).
\end{enumerate}
\item If \( \type(u) = 2 \), \( u \) verifies the following:
\begin{enumerate}
\item For all \( w \in N(u) \), \( \type(w) \neq 0 \).
\item For each \( w \in N(u) \) such that \( \type(w) = 1 \), it holds that \( \id^w = \id^u \) and \( \colors^w_{\#^u} = x^u \).
\item For each \( w \in N(u) \) such that \( \type(w) = 2 \), it holds that \( \id^w = \id^u \), \( \#^w = \#^u \), and \( x^w \neq x^u \).
\end{enumerate}
\end{enumerate}

Let us now analyze the properties of our decoder.

\paragraph{Completeness.} Let \( G \) be a bipartite graph that admits a shatter point \( v \). We define a labeling $\ell^*$ that assigns the pair \( (\type(u), \content(u)) \) to each node \( u \in V \) as follows. First, set \( \type(v) = 0 \), set \( \type(u) = 1 \) for each node in \( N(v) \), and assign \( \type(u) = 2 \) to all other nodes \( u \).

Next, enumerate the components of \( G - N[v] \) from 1 to \( k \). For each \( i \in [k] \), compute a 2-coloring \( x_i: C_i \to \{0,1\} \) of component \( C_i \). this 2-coloring exists by the condition (2) of \cref{lem:bipshatter}. By condition (3) of \cref{lem:bipshatter}, the nodes \( u \in N(v) \) are adjacent to nodes of only one partition \( U \) of \( G[C_i] \). Let \( x_i^U \in \{0,1\} \) denote the color assigned to partition \( U \) in \( x_i \). For each \( i \in [k] \), assign \( \content(u) = (\id(v), i, x_i(u)) \) to each node \( u \in C_i \), and assign \( \content(u) = (\id(v), \colors^u )\) to each node \( u \in N(v) \), where $\colors^u = (x_i^U)_{i \in [k]}$. By construction we have that $\ell^*$ satisfies condition 1, 2(b,c), 3(a,b,c). Finally, from the condition (1) of \cref{lem:bipshatter}  we have that we have that $\ell^*$ satisfies~2(a).


\paragraph{Strong Soundness.} Let \( G \) be an arbitrary graph, and let \( \ports \), \( \id \), and \( \ell \) be, respectively, the port, identifier, and label assignments of \( G \). Let $H$ be a subgraph induced by a connected component nodes that accept for $\mathcal{D}$.

Since all the nodes of \( H \) accept, the format of the certificates is correct. In particular, each node \( u \) receives a \( \type(u) \) and a \( \content(u) \). From now on, we say that a node \( u \in V(H) \) such that \( \type(u) = i \) is a \emph{node of type \( i \)}.

First, suppose that \( H \) contains only nodes of type 1 or 2. Note that by condition 1(a), nodes of type 1 have only neighbors of type 2. By condition 2(c), all neighbors of nodes with \( \type(u) = 1 \) share the same color \( c^u \). Therefore, we can define the coloring function \( y: V(C) \rightarrow \{0,1\} \) such that \( y(u) = x^u \) if \( \type(u) = 2 \), and \( y(u) = 1 - c^u \) if \( \type(u) = 1 \). We obtain that every node has neighbors of different colors, and hence \( y \) defines a 2-coloring of \( H \).

Now suppose that \( H \) contains at least one node \( v \) of type 0. In this case, we will check the conditions of \cref{lem:bipshatter}. By conditions 1, 2(b,c), and 3(b,c), for all \( u \in V(H) \), \( \id^u = \id(v) \). In particular, \( v \) is unique. By condition 1, all neighbors of \( v \) are of type 1, and by condition 2(a), \( N_H(v) \) is independent. Thus, condition 1 of \cref{lem:bipshatter} is satisfied. Since \( v \) is unique, there are no nodes of type 1 outside \( N_H(v) \). Therefore, all nodes in \( G - N[v] \) are of type 2. By condition 3(c), each component of \( G - N[v] \) is 2-colored. Thus, condition 2 of \cref{lem:bipshatter} is satisfied. Finally, by condition 3(c), all nodes in the same component of \( G - N[v] \) receive the same number \( \# \). By condition 1, all nodes of type 1 receive the same \( \content \); in particular, they share the same vector \( \colors \). By condition 2(c), for every node \( u \) of type 1, and for every neighbor \( w \in N_H(u) \) of type 2 in a component with number \( \# \), it holds that \( \colors_{\#} = x^w \). Therefore, condition 3 of \cref{lem:bipshatter} is satisfied. We conclude that \( H \) must be bipartite.


\paragraph{Hiding.} \Cref{lem:hiding-char} establishes that to show \( \mathcal{D} \) is hiding, it is sufficient to exhibit an odd cycle in \( \alvgd \), for \( N = 8 \). 

Let \( P_1 \) be a path of nodes $(w_3, w_2, w_1, u_1, v, u_2, z_1, z_2)$. We look $P_1$ as a bipartite graphs admitting a shatter point $v$. Then $N(v) = \{u_1, u_2\}$ and there are two connected components in $P_1 - N[v]$, namely $ \{w_1, w_2, w_3\}$ and $\{z_1, z_2\}$. We then define \(P_2\) as the path $(w_3, w_2, u_1, v, u_2, z_1, z_2)$. This looks the same as $P_1$, except that one of the components is just $ \{w_2, w_3\}$.  Consider an arbitrary port  assignment $\ports$ and an arbitrary identifier assignment $\id$ of $P_1$. 
Then, consider the restriction of $\ports$ and $\id$ to the nodes in $P_2$ (we abuse notation and call them both $\ports$ and $\id$).

%Now in $P_1$ fix an arbitrary 2-coloring $x_1$ of $C_1$ and an arbitrary 2-coloring $x_2$ of $C_2$. For $P_2$, we consider the same coloring $x_2$ for $C_2$, and the restriction of $x_1$ to $\{w_2, w_3\}$. Now let $\ell_1$, $\ell_2$ be the labeling for $P_1$ and $P_2$ constructed as described for the completeness of $\mathcal{D}$, considering the 2-colorings described above.  

Then let $\ell_1$ be the labeling of $P_1$ described as follows (remember that $\ell(u)$ has the format $(\type(u), \content(u))$:

\begin{multicols}{2}
\begin{itemize}
    \item $\ell(v_1) = (0,\id(v))$,
    \item $\ell(u_1) = \ell(u_2) = (1, (\id(v),(0,0)))$,
    \item $\ell(w_1) = \ell(w_3) = (2,(\id(v), 1, 0))$,
    \item $\ell(w_2) = (2, (\id(v), 1, 1))$,
    \item $\ell(z_1) = (2, (\id(v), 2, 0))$, 
    \item $\ell(z_2) = (2,(\id(v), 2, 1))$.
\end{itemize}
\end{multicols}

and let $\ell_2$ be the labeling of $P_2$  defined as:
\begin{multicols}{2}
\begin{itemize}
    \item $\ell(v_1) = (0,\id(v))$
    \item $\ell(u_1) = \ell(u_2) = (1, (\id(v), (1,0)))$
    \item $\ell(w_3) = (2, (\id(v), 1, 0))$,
    \item $\ell(w_2) = (2, (\id(v), 1, 1))$.
    \item $\ell(z_1) = (2, (\id(v), 2, 0))$
    \item $\ell(z_2) = (2, (\id(v), 2, 1))$. 
\end{itemize}
\end{multicols}
Notice that every node accepts this certificates for decoder $\mathcal{D}$. Observe that $w_3$ and $z_2$ have the same view on $(P_1, \ports, \id, \ell_1)$ and $(P_2, \ports, \id, \ell_2)$. However, they are at odd distance in $P_1$ and at even distance in $P_2$. Then $\alvgd$ contains an odd cycle. We deduce that $\mathcal{D}$ is hiding. 
\end{proof}


\subsection{Watermelons}

We now give a one-round strong and hiding LCP for $2$-coloring, restricted to watermelon graphs. Remember that a \emph{watermelon graph} is a graph $G$ defined by two nodes $v_1,v_2\in V(G)$ and a collection of disjoint paths $\mathcal{P} = P_1, \dots, P_k$ of length at least $2$ with endpoints in $v_1$ and $v_2$. Nodes $v_1$ and $v_2$ are called the \emph{endpoints} of $G$.
\restateThmWatermelons*


%\begin{lemma}\label{lem:bipwatermelon}
 %   A watermelon graph is bipartite if and only if the length of every path of \( \mathcal{P} \) has the same parity.
%\end{lemma}

%\begin{proof}

%\end{proof}


\begin{proof}
Let $G$ be a watermelon graph with endpoints $v_1$ and $v_2$ and set of paths $\mathcal{P}$.
Observe that every cycle \( C \) in a watermelon graph is formed by exactly two paths \( P, P' \in \mathcal{P} \). Thus, \( G \) is bipartite if and only if \( C \) has even length, which holds if and only if \( P \) and~\( P' \) have the same parity. Therefore, all paths in $G$ is bipartite if and only the length of all the paths in $\mathcal{P}$ have the same parity. 

We define a one-round decoder $\mathcal{D}$ that expects a labeling $\ell$ of $G$ formatted as follows. For each node $u$, a the label of $\ell(u) = (\type(u),\content(u))$, where $\type(u) \in \{1,2\}$ and $\content(u)$ is formatted as:



\begin{itemize}
    \item If $\type(u) = 1$ is interpreted as the fact that $u$ is one of the endpoints $v_1$ or $v_2$ of the watermelon. In that case $\content(u) = (\id_1^u, \id_2^u)$, where $\id_1^u$ and $\id_2^u$ represent the identifiers of $v_1$ and $v_2$ in increasing order (i.e. $\id_1^u < \id_2^u$)
    \item If $\type(u) = 2$ is interpreted as the fact that $u$ belongs to a path $P\in \mathcal{P}$. In that case \[\content(u) = (\id^u_1, \id^u_2, \#^u, p^u_{1}, c^u_1, p^u_{2},c^u_2),\] where
    \begin{itemize}
        \item $\id_1^u$ and $\id_2^u$ represent the identifiers of $v_1$ and $v_2$ in increasing order (i.e. $\id_1^u < \id_2^u$).
        \item $\#_u$ represents a unique number assigned to the path $P$.
        \item The values of $c^u_1 \neq c^u_2\in \{0,1\}$ are interpreted as colors of the edges incident to $u$ in a $2$-coloring of $P$. 
        For each $i\in \{1,2\}$,  let $w$ be the neighbor of $u$ such that $i=\ports(u,\{u,w\})$. Then $p^u_{i}$,  represents $\ports(w, \{u,w\})$ and $c^u_i$ represents the color of edge~$\{u,w\}$. 

    
        
    \end{itemize}
\end{itemize}
Intuitively, we assign every node of \( G \) the identifiers of the endpoints \( v_1 \) and \( v_2 \). Additionally, we 2-color the edges of each path and identify each path with a distinct number. Thus, \( \mathcal{D} \) consists of verifying the following conditions:

\begin{enumerate}
    \item Every pair of neighbors \( w_1, w_2 \in V(G) \) verifies that \( \id^{w_1}_1 = \id^{w_2}_1 \) and \( \id^{w_1}_2 = \id^{w_2}_2 \). 
    \item If \( \type(u) = 1 \), the node \( u \) verifies:
    \begin{enumerate}
        \item \( \id^u_1 = \id(u) \) or \( \id^u_2 = \id(u)\).
        \item For each \( w \in N(u) \), \( \type(w) = 2 \) and that $p^w_{i2} = \ports(u,\{u,w\})$ for some $i\in \{1,2\}$.
        \item For every pair of neighbors \( w_1, w_2 \in N(u) \), \( \#^{w_1} \neq \#^{w_2} \).
        \item The set $\{c_i^w: w\in N(v) \text{ and } i\in \{1,2\} \text{ is such that }\ports(u,\{u,w\}) = p^w_{i} \}$ is a singleton. 
    \end{enumerate}
    \item If \( \type(u) = 2 \), the node \( u \) verifies:
    \begin{enumerate}

    
        \item It has exactly two neighbors $w_1$, $w_2$, where $w_i$ is the neighbor sending information to $u$ through port $i \in \{1,2\}$. 
      
            \item For each $i \in \{1,2\}$, if $\type(w_i) = 1$ then $\id_1^u = \id(w_i)$ or $\id^2_u = \id(w_i)$. 
            \item For each $i \in \{1,2\}$, if $\type(w_i) = 2$ then $\#^{w_i} = \#^u$. Furthermore, if  we call $j = p^u_{i}$ then $p_j^{w_i} = i$ and $c_j^{w_i} = c_i^u$.
    \end{enumerate}
\end{enumerate}

In the following we say that a node $u$ such that \( \type(u) = i \) is a \emph{type \( i \) node}. Roughly, condition~1 checks that all nodes agree in the (potential) endpoints of the watermelon. Conditions~2 are for the type 1 nodes. 2(a) checks that type 1 nodes $v$ are one of the endpoints of the watermelon; 2(b) that all neighbors of $v$ are type 2 nodes and the information of the ports is correct; 2(c) that the paths are correctly numbered; and 2(d) that the edges incident to $v$ are monochromatic. Condition 3 are for type 2 nodes. 3(a) checks that the nodes are in paths; 3(b) checks that the path stops in a endpoint of the watermelon; and 3(c) checks that the information about the ports is correct and that the edges of the path are $2$-colored. 

We now analyze the properties of the decoder.

\paragraph{Completeness.} Let \( G \) be a bipartite watermelon graph, and let \( v_1, v_2 \) be the endpoints of \( G \). For each path \( P \in \mathcal{P} \), color the edges of \( P \) with \( \{0,1\} \), assigning \( 0 \) to the edge incident to \( v_1 \) and alternating the colors until reaching \( v_2 \). Let \( c: E(G) \rightarrow \{0,1\} \) be the resulting coloring. Next, enumerate the \( k \) paths in \( \mathcal{P} \) arbitrarily with distinct numbers in \( [k] \).

Let \( \ports \) and \( \ids \) be arbitrary port and identifier assignments for \( G \). Without loss of generality \( \id(v_1) < \id(v_2) \). The labeling \( \ell(u) = (\type(u), \content(u)) \) of \( G \) is defined as follows:
\begin{itemize}
    \item \( \type(v_1) = \type(v_2) = 1 \). For all other nodes \( u \), we set \( \type(u) = 2 \).
    \item \( \content(v_1) = \content(v_2) = (\id(v_1), \id(v_2)) \).
    \item For each \( j \in [k] \), and every node \( u \) of \( P_j \), we denote \( w_i \) as the neighbor of \( u \) such that \( i = \ports(u, \{u, w_i\}) \). Then    
    \[
    \content(u) = (\id(v_1), \id(v_2), j, \ports(w_1, \{u, w_1\}), c(\{u, w_1\}), \ports(w_2, \{u, w_2\}), c(\{u, w_2\})).
    \]
\end{itemize}

By construction, conditions 1, 2(a,b,c), and 3(a-c) are satisfied. Finally, property 2(d) holds because all paths must have the same parity for \( G \) to be bipartite.


\paragraph{Strong Soundness.}
Let \( G \) be an arbitrary graph, and let \( \ports \) and \( \id \) denote arbitrary port and identifier assignments for \( G \). Let \( \ell \) be an arbitrary labeling of \( G \) with size \( \cO(\log n) \). Define \( H \) as the subgraph induced by a connected component of nodes that accept for \( \mathcal{D} \).

Since all nodes in \( H \) accept, the certificate format must be correct. Specifically, each node~\( u \) receives a label \( \type(u) \) and content \( \content(u) \). By condition 1, \( H \) can contain at most two nodes of type 1. Let \( C \) be a cycle of \( H \). 

If all nodes in \( C \) are of type 2, then condition 3(a) implies that \( H = C \). Condition 3(c) ensures that for each edge \( e = \{u,w\} \in E(G) \), \( u \) and \( w \) agree on the same color \( c(e) \in \{0,1\} \) of \( e \), and the format of \( \ell \) indicates that the two incident edges of each node have different colors. Consequently, \( c: E(H) \rightarrow \{0,1\} \) is a two-edge coloring of \( C \), implying that \( C \) is even. 

We now show that \( C \) cannot contain only one node of type 1. Indeed, if \( v \) were such a node, then the nodes of \( C - v \), which are connected by a path, are all of type 2. By condition 3(c), all nodes \( u, w \) in \( C - v \) satisfy that \( \#^u = \#^w \). Hence, \( v \) violates condition 2(c), which is a contradiction. 

Now, let us suppose that \( C \) contains two nodes \( v_1, v_2 \) of type 1. Then condition 2(b) states that \( C - \{v_1, v_2\} \) is defined by two paths \( P_1 \) and \( P_2 \). As we mentioned in the case where there are no nodes of type 1 in \( C \), conditions 3(a) and 3(c) ensure that \( P_1 \) and \( P_2 \) are two-edge colored. Conditions 2(b) and 2(d) ensure that all edges incident to \( v_1 \) and \( v_2 \) are monochromatic, and therefore the lengths of \( P_1 \) and \( P_2 \) have the same parity. We conclude that \( C \) is an even cycle. 

Thus, all cycles in \( H \) are even, and we deduce that \( H \) is bipartite.

\paragraph{Hiding.} \Cref{lem:hiding-char} establishes that to show \( \mathcal{D} \) is hiding, it is sufficient to exhibit an odd cycle in \( \alvgd \), for  \( N= 8 \). Let us consider a path of length $8$, namely $P = u_1, u_2, \dots, u_8$. Fix the port assignment  $\ports$ of $P$  that to each node $u_i$ ($i \in [2,7]$) assigns port $1$ to $u_{i-1}$ and port $2$ to $u_{i+1}$. We now define two identifier assignments of $P$. The first identifier assignment $\id_1$ is simply defined by
$\id_1(u_i) = i$ for each $i \in [8]$. The second identifier assignment $\id_2$ is defined as follows:

\[\id_2(u_i) = \begin{cases} 
i & \text{if } i \in \{1,2,7,8\} \\
9-i & \text{if } i \in \{3,4,5,6\}.\\
\end{cases}\]
For  $j\in \{1,2\}$, we denote $\ell_j$  the labeling assignments given to the nodes on instance $(P, \ports, \id_j)$. We denote $\mu^j_i$ the view of $u_i$ in $\mathcal{I}_j  = (P, \ports, \id_j, \ell_j)$. 

Observe that $P^*_2 = \mu_1^1, \mu_2^1, \mu_3^1, \mu_4^1$ and $P^*_1 = \mu_1^2, \mu_2^2, \mu_3^2, \mu_4^2,\mu_5^2$ are paths in $\alvgd$. Now notice that the views of $u_1$ in $\mathcal{I}_1$ and $\mathcal{I}_2$ are the same. Furthermore, the view of $u_4$ in $\mathcal{I}_1$ equals the view of $u_5$ in $\mathcal{I}_2$. Therefore $\mu_1^1 = \mu_1^2$ and $\mu_4^1 = \mu_5^2$. Then $P^*_2$ and $P^*_1$ define an odd cycle in $\alvgd$.  We deduce that $\mathcal{D}$ is hiding. 



\end{proof}

\ifanon\else
\section*{Acknowledgments}

We thank Jukka Suomela, Massimo Equi, and Sebastian Brandt for very fruitful
discussions.
We would also like to thank the remaining participants of the RW-DIST 2024
workshop that were involved in coming up with the upper bound construction for
the case of a single cycle (\cref{sec:ub-cycle}), which formed the cornerstone
case for this project.

Parts of this work were done while Pedro Montealegre and Martín Ríos-Wilson were
visiting Aalto University.
We acknowledge the support of the Research Council of Finland, Grant 363558.

Augusto Modanese was partly supported by the Helsinki Institute for Information
Technology (HIIT) and the Research Council of Finland, Grant 359104.
\fi % end ifanon

\printbibliography

\end{document}
