\section{Introduction} \label{intro}
The last two decades have witnessed a tremendous growth both in the collection and usage of data to power use cases such as business analytics, recommender systems and personalization. A significant amount of data that businesses collect from end users to power these applications is sensitive or personally identifiable. Understandably, there have been concerns from regulators, privacy advocates and various other citizen groups alike around the lack of transparency in the data collection and data handling practices adopted by businesses. Regulations such as GDPR \cite{GDPR16}, CCPA \cite{CCPA18}, HIPAA \cite{HIPAA03}, DMA \cite{DMA24} and EU AI Act~\cite{AIAct24} have been enacted into law in response to these privacy concerns and to drive transparency into the data collection and data usage practices of businesses. Specifically, these regulations require businesses to limit the usage of user data only for the purposes for which it is collected. As an example, the GDPR regulation requires businesses to seek consent from their end users (or formally, data subjects) in order to use sensitive attributes such as age and gender for advertising purposes.  At the same time, the use of this data is often permitted in anonymized form to enable business use cases intended for demographic analysis. 

To address these privacy concerns and ensure compliance with regulations, several solutions have been proposed~\cite{Byun05, Colombo17, Xue23} to enforce access control policies based on the purpose of data access. The systems are commonly referred to as \emph{Purpose-based Access Control} (PBAC) systems. Depending on the granularity of enforcement, these systems can either authorize/deny access to an entire dataset (\emph{coarse-grained} access control), or they can apply dynamic masking to hide contents of individual rows, columns or cells within the dataset (\emph{fine-grained} access control).  Enforcing policies dictated by these regulations across a large organization can be a challenging endeavor for the following reasons: 
\begin{enumerate}
\item A typical modern data stack involves multiple data processing systems such as Apache Spark~\cite{Spark}, Trino~\cite{Trino} and Apache Flink~\cite{Flink}. Thus, any access control solution is required to apply data access policies consistently across a diversity of data processing systems used in an organization. 
\item Many data-centric organizations commonly support 10-100s of thousands of datasets, 10-100s of use cases (or {\em purposes}) and 100s-1000s of data pipelines accessing exabyte-scale data every day. A practical solution for access control must therefore be sufficiently scalable to meet these demands.
\item The data models underlying these datasets can be varied and complex. For instance, it is common to model data using non-atomic data types like arrays, maps, and structs. Furthermore, it is also common for AI/ML workloads to employ application-specific descriptions of data overlaid on basic data structures such as arrays and structs. A practical solution for access control must support granular data-masking capabilities within such complex data structures to maximize data utility while ensuring compliance. 
\end{enumerate} 
Existing solutions have limited fine-grained access control capabilities and fall short in addressing one or more of the aforementioned challenges. Furthermore, we are not aware of any prior literature describing the myriad practical challenges encountered when deploying an access-control solution across a large data warehouse.

There are additional challenges for data-centric applications (such as LinkedIn among others) that employ a consent framework that controls how end-user data is used for different use cases. For instance, LinkedIn provides granular consent settings to its over one billion users (or {\em data subjects}) giving them control on how their data is used by LinkedIn for different use cases. 
Thus, data present in warehouse tables need to be dynamically masked based on data subject preferences in addition to the purpose of access. 
In Figure~\ref{fig:Data Filtering}, we illustrate how access control based on data subject preferences differs from the more common row and column-level access control used in practice. 
In this example, the {\em member\_profiles} table storing data subject information is queried for two different use cases, viz. “Ads” and “Jobs”. 
Data subject preferences controlling usage of different attributes of their data are stored in the \emph{member\_settings} table. 
Usage of data subject information for the Ads use case is controlled by two settings, \emph{allowEducationForAds} and \emph{allowEmployerForAds}, 
while that for Jobs use case is controlled by the settings \emph{allowEducationForJobs} and \emph{allowEmployerForJobs}. 
Based on the setting values for \emph{allowAgeEducationForAds} and \emph{allowEmployerForAds}, 
the education attribute associated with $memberId=123$ and employer attribute corresponding to $memberId=234$ in the {\em member\_profiles} table need to be masked for the Ads use case. 
Similarly, the education attribute of member $234$ and the employer attribute of members $123$ need to be masked for Jobs use case based on the corresponding values for jobs-related settings.

\input{figure-1.tikz}

To address these challenges, we designed and implemented Data Guard, a fine-grained purpose-based access control system for large data warehouses. The system translates policies specified in a domain-specific language (DSL) into purpose-specific views that mask data at access time. This translation is facilitated by maintaining a taxonomy of data classification labels (henceforth, referred to as \emph{policy labels}), which are used to provide semantic description of the data elements (e.g. rows, columns, and cells in a table) present in the warehouse. The policies use purpose and policy labels to define the conditions under which access to a data element described using an annotation is allowed or denied.  A \emph{policy compiler} translates these rules into a purpose-specific view SQL and registered with the warehouse. At access time, a view routing layer transparently routes accesses to the appropriate data-masking view based on the purpose attached to the access.  

The key contributions of this paper are as follows:
\begin{itemize}
    \item To the best of our knowledge, Data Guard is the first practical implementation of a fine-grained, purpose-based access control system that has been successfully deployed across a large enterprise warehouse. Data Guard has been rolled out at scale across LinkedIn's warehouse ensuring all data accesses using Spark and Trino -- 
    the data processing engines used to query the warehouse data at LinkedIn -- are compliant with our data usage policies. 
    \item Data Guard introduces a number of innovations that ensure both compliance and ease of use for warehouse users and application developers such as: 
    (i) High-level abstractions that allow policies to be defined using purposes and semantic data labels. These policies are translated by Data Guard into data-masking views that serve as the data access API. 
    (ii) A routing layer referred to as {\em ViewShift} which transparently routes accesses to warehouse tables from user queries to the appropriate data-masking views provisioned by Data Guard. 
    (iii) View optimizations to minimize performance overhead in existing data processing jobs, such as the use of memory-efficient bitmaps in lieu of expensive table joins.  
    (iv) Use of engine-agnostic views which allow data-masking views to be executable across different data processing engines (Spark and Trino at LinkedIn).
    \item To the best of our knowledge, Data Guard is the first practical implementation of an access control system that allows data-masking at the sub-cell level. 
    Data Guard achieves this via an expressive grammar that allows it to locate and mask deeply nested data elements inside composite attributes. 
    These granular masking capabilities of Data Guard allows data consumers to maximize value from the underlying data while still ensuring compliance. 
\end{itemize}  

In the rest of the paper, we provide a detailed description of the design of Data Guard, the key architectural choices in our system along with the reasons that motivated these choices, and the system implementation details. 
We also present data that quantifies the performance overhead of enforcement during data access and conclude with interesting areas of future work.