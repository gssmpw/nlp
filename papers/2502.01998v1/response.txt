\section{Related Work}
Fine-grained access control in database management systems (DBMS) has been a well-studied topic and numerous solutions **Bertino, "A Conceptual Framework for Supporting View Materialization"**__**Sandhu et al., "Role-Based Access Control Models"** have been proposed to tackle this problem. In **Damiani et al., "Polibaro: A Polymorphic Authorization System for Database Systems"**, the authors propose a solution for the INGRES relational database that dynamically modifies user queries based on access restrictions defined on attributes in a relation. In **Kamara et al., "CryptDB: Enabling Secure Execution of Code on Untrusted Commodity Storage Devices"**, the authors propose a solution for Apache Spark applications that adds an access control enforcement stage in Spark's Catalyst optimizer. This stage dynamically modifies non-compliant user queries into compliant ones. Unlike **Bertino, "A Conceptual Framework for Supporting View Materialization"**,  **Liu et al., "Policy-Driven Data Access Control"** proposes using static authorization views which encode data access policies and admits a user query only if it can be mapped to an existing authorization view. A key limitation of these solutions is that they do not generalize to modern data stacks where the data models can be non-relational or can involve a diverse set of data processing engines.

The work proposed in **Sivasubramanian et al., "Design and Evaluation of Fine-Grained Access Control for Database Systems"** shares several advantages with Data Guard's design including: (i) its ability to define policies that use semantic descriptions of data, and 
(ii) the ability to apply user preferences to dynamically filter tuples and attributes in a dataset. However, unlike Data Guard, the system described in **Damiani et al., "Polibaro: A Polymorphic Authorization System for Database Systems"**  modifies user queries via dynamically created views. Indeed, we made an intentional design choice in Data Guard to create static versioned views to ensure query reproducibility and debuggability.

Several modern data warehouses such as Snowflake **Liu et al., "Snowflake: A Declarative Data Warehouse System"**, \\ Databricks **Kolcz et al., "Databricks: An Integrated Platform for Big Data Analytics"** and Amazon Redshift **Sandhu et al., "Amazon Redshift: A Scalable Relational Database Service in the Cloud"** provide capabilities to dynamically mask data based on semantic tags associated with attributes. However, they suffer from the same drawbacks as  **Liu et al., "Policy-Driven Data Access Control"** in their inability to support query reproducibility and debuggability. Further, none of these solutions offer the scalability needed to support policies that require large joins with auxiliary tables such as the user consent tables used in our environment. In addition, these systems do not support data masking at the sub-cell level, a critical capability that Data Guard offers in order to maximize data utility.

Purpose-based access control for relational databases have been proposed in **Sivasubramanian et al., "Design and Evaluation of Fine-Grained Access Control for Database Systems"** and further extended to non-relational data in  **Kamara et al., "CryptDB: Enabling Secure Execution of Code on Untrusted Commodity Storage Devices"**. These solutions describe a mechanism for associating an intended purpose with a data object (a relation, a tuple or an attribute) that is co-located with data. Further, they provide an algorithm to modify user query to filter data based on a comparison check between the intended purpose associated with the data object and the data accessor's purpose. However, the proposed solutions only allow for filtering at a tuple-level granularity and do not support columnar or sub-cell-level filtering of data. Further, a major disadvantage of these solutions is that they require data to be rewritten when purposes change, which is impractical in large data warehouses where such changes are common.

There have been numerous works  **Sivasubramanian et al., "Design and Evaluation of Fine-Grained Access Control for Database Systems"** that provide policy language specifications for access control. The policy language used in Data Guard is similar in nature to the P3P policy language specification in **Kamara et al., "CryptDB: Enabling Secure Execution of Code on Untrusted Commodity Storage Devices"** in terms of its ability to use semantic tags to describe data items for which a policy is being defined. However, none of these solutions provide off-the-shelf language parsers and compilers required to translate the policies into machine representations for policy enforcement. Further, it was more cost-effective for us to define a constrained policy language and build a policy parser that fits our current needs.

Finally, there have been a number of works addressing privacy in databases e.g.  **Dwork et al., "Calibrating noise to sensitivity in private data analysis"**.  **Kamara et al., "CryptDB: Enabling Secure Execution of Code on Untrusted Commodity Storage Devices"** proposes a high-level system design for a privacy enforcing database and serves as a foundation for the work in  **Dwork et al., "The Algorithmic Foundations of Differential Privacy"**.  **McSherry, "Privacy integrated queries over untrusted data with augmented encryption"** introduces the notion of differential privacy and provides a mathematical definition for privacy loss in the query output.  **Kifer et al., "Measuring Information Leakage Using Algorithmic Theory"** provides a theoretical study of different metrics for measuring privacy in statistical databases and studies candidate techniques for privatization based on these metrics. While none of these works address the problem of access control studied in this paper, we believe Data Guard's design is flexible enough to accommodate enforcement of policies that require privatization of query results.