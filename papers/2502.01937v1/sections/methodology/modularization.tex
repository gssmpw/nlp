\subsection{Hierarchy of \yuntianyihl{ADS \BFP Study by Modularization Granularity}}

In this study, we aim to analyze the nature of ADS \bfps by examining them through seven distinct perspectives: (i) the root causes indicative of developer errors in the codebase; (ii) the symptoms of these bugs, as evidenced by aberrant behaviors, system failures, or runtime errors; (iii) the specific ADS module and sub-module where the bug is localized; (iv) the algorithm or function that the bug is related to; (v) the syntactic \bfp; (vi) the semantic \bfp \yuntianyihl{; and (vii) the \bfa related to the specific \bfp, root cause, sub-module, or algorithm}.

We introduce the concept of \textit{Modularization Granularity} as a means to dissect and understand the architecture of ADS, offering a clear depiction of the structural layers of software development into a hierarchy of granularity that spans from broad architectural modules to the minute intricacies of code statements.
Modularization granularity is essential to decompose complex systems into manageable segments. We identify this granularity through various levels of labels, each serving its unique role in the modular architecture.
\autoref{fig:hierarchy} shows the hierarchy along with two examples presenting how we label the bug fixes in the Planning module.

\begin{figure}[ht]
\centering
\includegraphics[width=\linewidth]{images/bfp_hierarchy.pdf}
\caption{Hierarchy of ADS \yuntianyihl{\BFP by Modularization Granularity}}
\label{fig:hierarchy}
\end{figure}

On the semantic level, we have \textit{Module} and \textit{Sub-module} labels which indicate the major components and their subdivisions respectively, facilitating a high-level understanding and management of the system. We also have \textit{Algorithm/Function} labels that reveal the intricate details of the system's functionality and operational logic. Finally, at the most granular level, we have the \textit{Statement/Code} labels, which are indicative of the syntactic construction of the software.
\textit{Syntactic BFPs} are categorized according to \yuntianyihl{code and} statement changes, while \textit{Semantic BFPs} \yuntianyihl{are analyzed from a high-level comprehensive understanding of ADS misbehaviors}.
\yuntianyihl{\textit{\Bfas} are determined through an in-depth examination of other labels, which describe the actionable strategies made to bugs, providing detailed steps and modifications necessary to correct errors, adjust code behavior, and improve system functionality.
For each pull request, we also label the \textit{Symptom} to identify the observable effects of bugs and the \textit{Root cause} that delves into their underlying reasons to help understand the relations between \bfps and bug types. This hierarchical framework allows us to trace symptoms back to their root causes and categorize them into our taxonomy of \bfps. This structured analysis informs our findings by providing a nuanced view of how different types of bugs arise, propagate through, and influence the system.}


While distinguishing the severity of individual bug-fix patterns may be challenging, the design of our modularization granularity hierarchy allows us to use the symptoms to assess severity. For instance, the bugs that have Crashes symptoms are clearly more severe than those with DGUI or no symptoms. We could use symptoms and corresponding violations to assess the severity of bugs. 

\yuntianc{The hierarchy has practical applications for both researchers and practitioners. For researchers, it provides a robust framework for studying bug-fix patterns in other domains. Its top three semantic levels and semantic bug-fix patterns can be customized to suit specific application domains, making it broadly applicable. For example, adapting the hierarchy more broadly to cyber-physical systems or robotics could provide valuable insights into their unique bug-fix challenges. This flexibility underscores the hierarchy's potential to standardize bug-fix analysis across diverse systems, aiding researchers in labeling and analyzing bug-fix data systematically. For practitioners, the hierarchy serves as a diagnostic tool to guide debugging and repair processes. By mapping the symptom and root cause of a bug to specific semantic or syntactic bug-fix patterns, the hierarchy helps practitioners identify actionable bug-fix actions.
Furthermore, it connects these patterns to affected modules, sub-modules, algorithms, and code statements, providing targeted guidance for debugging and repair. The hierarchy's adaptability also ensures its applicability to other modular architectures. 
}