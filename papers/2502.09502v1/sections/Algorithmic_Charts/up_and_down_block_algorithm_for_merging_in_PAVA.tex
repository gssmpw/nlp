\begin{algorithm}[hb]
    \caption{Up and Down Block Algorithm for Merging in PAVA}
    \label{alg:up_and_down_block_algorithm_for_merging_in_PAVA}
    \begin{flushleft}
    \textbf{Input:} vector $\bmu \in \mathbb{R}^p$, nonnegative weights $\brho \in \mathbb{R}_{+}^p$ ($\rho_{[1:k]}=\rho, \rho_{k+1:p}=0$), vector $\hat{\bnu}$ ($\hat{\nu}_j = \text{prox}_{\rho_j H_M}(\vert{\mu_j})$), integer $k \in \mathbb{N}$ (first $k$ elements subject to Huber penalty), and threshold $M > 0$ for the Huber loss function. %\\
    %\textbf{Output:} vector $\hat{\bnu} \in \mathbb{R}^p$, which is the optimal solution to Problem~\eqref{obj:KyFan_Huber_isotonic_regression}.\\
    \end{flushleft}
    \begin{algorithmic}[1]
        \STATE \COMMENT{Initialization for the first block}
        \STATE Initialize $b=1$, $P_1 = \rho_1$, $S_1 = \vert{\mu_1}$, $N_b=1$, $\nu_1$, $r_1 = 1$.
        \STATE $\nu_{\text{prev}} = \hat{\nu}_1$, $j=2$
        \WHILE{$j \leq n$}
            \STATE $b = b + 1$
            \STATE $P_b = \rho_j$, $S_b = \vert{\mu_j}$, $N_b=1$, $\nu = \hat{\nu}_j$
            \STATE \COMMENT{If the value for the current singleton block is greater that of the previous block (isotonic violation), merge the current block with the previous block}
            \IF{$\nu > v_{\text{prev}}$}
                \STATE $b = b - 1$
                \STATE $P_b = P_b + \rho_j$, \, $S_b = S_b + \vert{\mu_j}$, \, $N_b = N_b + 1$, \, $\nu = \text{prox}_{\frac{P_b}{N_b} H_{M}}(\frac{S_b}{N_b})$
                \STATE \COMMENT{Look forward: keep merging the current block with the next block if the isotonic violation persists}
                \WHILE{$j < n$ \AND $\nu \leq \hat{\nu}_j$}
                    \STATE $j = j + 1$
                    \STATE $P_b = P_b + \rho_j$, \, $S_b = S_b + \vert{\mu_j}$, \, $N_b = N_b + 1$, \, $\nu = \text{prox}_{\frac{P_b}{N_b} H_{M}}(\frac{S_b}{N_b})$
                \ENDWHILE
                \STATE \COMMENT{Look backward: keep merging the current block with the previous block if the isotonic violation persists}
                \WHILE{$b > 1$ \AND $\nu_{b-1} < \nu$}
                    \STATE $b = b - 1$
                    \STATE $P_b = P_b + P_{b+1}$, \, $S_b = S_b + S_{b+1}$, \, $N_b = N_b + N_{b+1}$, \, $\nu = \text{prox}_{\frac{P_b}{N_b} H_{M}}(\frac{S_b}{N_b})$
                \ENDWHILE
            \ENDIF
            \STATE \COMMENT{Save the current block's value and the index of the last element in the block}
            \STATE $\nu_b = \nu$, $r_b = j$
            \STATE \COMMENT{Start fresh on the next element}
            \STATE $\nu_{\text{prev}} = \nu$, $j = j + 1$
        \ENDWHILE
        \STATE \COMMENT{Modify the output vector to have the same new value for all elements in each block}
        \FOR{$l = 1, ..., b$}
            \STATE $\hat{\nu}_{[r_{l-1}+1:r_l]} = \nu_l$
        \ENDFOR
        \STATE \textbf{return} $\hat{\bnu}$
    \end{algorithmic}
\end{algorithm}

% \begin{algorithm}[H]
%     \caption{Modified PAVA with Huber Penalty for Nonincreasing Isotonic Regression}
%     \label{alg:up_and_down_block_algorithm_for_merging_in_PAVA}
%     \begin{flushleft}
%     \textbf{Input:} vector $\bmu \in \mathbb{R}^n$ (observations), nonnegative weights $w \in \mathbb{R}_{\ge 0}^n$, integer $k \in \mathbb{N}$ (first $k$ elements subject to Huber penalty), scalar $\rho > 0$ (Huber penalty coefficient), and threshold $M > 0$.\\
%     \textbf{Output:} vector $x \in \mathbb{R}^n$ (monotone, nonincreasing sequence approximating $y$).\\
%     \end{flushleft}
%     \begin{algorithmic}[1]
%         \STATE $M, P$
%         \STATE $y_1 \gets y,\; y_2 \gets y,\; w_1 \gets w,\; w_2 \gets w$
%         \FOR{$j = 0$ to $k-1$}
%             \STATE $w_1[j] \gets w[j] + \frac{\rho}{2}$
%             \STATE $y_1[j] \gets y[j] \cdot \frac{w[j]}{w_1[j]}$
%             \STATE $y_2[j] \gets y[j] - \frac{\rho M}{2w_2[j]}$
%         \ENDFOR
%         \STATE Initialize boolean array $\text{use\_y1}$ of length $n$:
%         \FOR{$j = 0$ to $n-1$}
%             \STATE $\text{use\_y1}[j] \gets (y_1[j] \leq M)$
%         \ENDFOR
    
%         \STATE Allocate arrays $x_1^{\text{block}}, w_1^{\text{block}}, x_2^{\text{block}}, w_2^{\text{block}}$, and $\text{use\_x1\_block}$ of length $n$
%         \STATE Allocate array $r$ of length $n+1$
%         \STATE $r[0] \gets -1,\; r[1] \gets 0$
%         \STATE $b \gets 1$ \COMMENT{Number of blocks}
    
%         \STATE $x_1^{\text{block}}[0] \gets y_1[0],\; w_1^{\text{block}}[0] \gets w_1[0]$
%         \STATE $x_2^{\text{block}}[0] \gets y_2[0],\; w_2^{\text{block}}[0] \gets w_2[0]$
%         \STATE $\text{use\_x1\_block}[0] \gets \text{use\_y1}[0]$
    
%         \STATE $j \gets 1$
%         \WHILE{$j < n$}
%             \STATE $b \gets b + 1$
    
%             \STATE \textbf{Compute current values:}
%             \IF{$\text{use\_y1}[j] = \text{True}$}
%                 \STATE $x_{\text{curr}} \gets y_1[j],\; w_{\text{curr}} \gets w_1[j]$
%             \ELSE
%                 \STATE $x_{\text{curr}} \gets \max(y_2[j], M),\; w_{\text{curr}} \gets w_2[j]$
%             \ENDIF
    
%             \STATE \textbf{Compute previous block values:}
%             \STATE $\ell \gets b - 2$ \COMMENT{Index of previous block}
%             \IF{$\text{use\_x1\_block}[\ell] = \text{True}$}
%                 \STATE $x_{\text{prev}} \gets x_1^{\text{block}}[\ell],\; w_{\text{prev}} \gets w_1^{\text{block}}[\ell]$
%             \ELSE
%                 \STATE $x_{\text{prev}} \gets \max(x_2^{\text{block}}[\ell], M),\; w_{\text{prev}} \gets w_2^{\text{block}}[\ell]$
%             \ENDIF
    
%             \STATE \textbf{Check for nonincreasing violation:} 
%             \IF{$x_{\text{prev}} < x_{\text{curr}}$}
%                 \STATE $b \gets b - 1$
%                 \STATE Merge current element with previous block:
    
%                 \STATE $S_1 \gets (w_1^{\text{block}}[b-1] \cdot x_1^{\text{block}}[b-1]) + (w_1[j] \cdot y_1[j])$
%                 \STATE $W_1 \gets w_1^{\text{block}}[b-1] + w_1[j]$
%                 \STATE $x_{1,\text{merged}} \gets S_1 / W_1$
    
%                 \STATE $S_2 \gets (w_2^{\text{block}}[b-1] \cdot x_2^{\text{block}}[b-1]) + (w_2[j] \cdot y_2[j])$
%                 \STATE $W_2 \gets w_2^{\text{block}}[b-1] + w_2[j]$
%                 \STATE $x_{2,\text{merged}} \gets S_2 / W_2$
    
%                 \STATE $\text{use\_x1\_merged} \gets (x_{1,\text{merged}} \leq M)$
    
%                 \COMMENT{k-up step: merge forward if violation persists}
%                 \WHILE{$j < n-1$ \AND $\bigl(x_{1,\text{merged}} \cdot \text{use\_x1\_merged} + (1-\text{use\_x1\_merged}) \cdot \max(x_{2,\text{merged}}, M)\bigr) \leq \bigl(y_1[j+1] \cdot \text{use\_y1}[j+1] + (1-\text{use\_y1}[j+1]) \cdot \max(y_2[j+1], M)\bigr)$}
%                     \STATE $j \gets j + 1$
%                     \STATE $S_1 \gets S_1 + w_1[j] \cdot y_1[j],\; W_1 \gets W_1 + w_1[j],\; x_{1,\text{merged}} \gets S_1 / W_1$
%                     \STATE $S_2 \gets S_2 + w_2[j] \cdot y_2[j],\; W_2 \gets W_2 + w_2[j],\; x_{2,\text{merged}} \gets S_2 / W_2$
%                     \STATE $\text{use\_x1\_merged} \gets (x_{1,\text{merged}} \leq M)$
%                 \ENDWHILE
    
%                 \COMMENT{k-down step: merge backward if violation persists}
%                 \WHILE{$b > 1$ \AND $\bigl(x_1^{\text{block}}[b-2] \cdot \text{use\_x1\_block}[b-2] + (1-\text{use\_x1\_block}[b-2]) \cdot \max(x_2^{\text{block}}[b-2], M)\bigr) < \bigl(x_{1,\text{merged}} \cdot \text{use\_x1\_merged} + (1-\text{use\_x1\_merged}) \cdot \max(x_{2,\text{merged}}, M)\bigr)$}
%                     \STATE $b \gets b - 1$
%                     \STATE $S_1 \gets S_1 + w_1^{\text{block}}[b-1] \cdot x_1^{\text{block}}[b-1],\; W_1 \gets W_1 + w_1^{\text{block}}[b-1],\; x_{1,\text{merged}} \gets S_1 / W_1$
%                     \STATE $S_2 \gets S_2 + w_2^{\text{block}}[b-1] \cdot x_2^{\text{block}}[b-1],\; W_2 \gets W_2 + w_2^{\text{block}}[b-1],\; x_{2,\text{merged}} \gets S_2 / W_2$
%                     \STATE $\text{use\_x1\_merged} \gets (x_{1,\text{merged}} \leq M)$
%                 \ENDWHILE
    
%                 \STATE $x_1^{\text{block}}[b-1] \gets x_{1,\text{merged}},\; w_1^{\text{block}}[b-1] \gets W_1$
%                 \STATE $x_2^{\text{block}}[b-1] \gets x_{2,\text{merged}},\; w_2^{\text{block}}[b-1] \gets W_2$
%                 \STATE $\text{use\_x1\_block}[b-1] \gets \text{use\_x1\_merged}$
%                 \STATE \textit{No violation}
%             \ELSE
%                 \STATE \COMMENT{No violation}
%                 \STATE $x_1^{\text{block}}[b-1] \gets y_1[j],\; w_1^{\text{block}}[b-1] \gets w_1[j]$
%                 \STATE $x_2^{\text{block}}[b-1] \gets y_2[j],\; w_2^{\text{block}}[b-1] \gets w_2[j]$
%                 \STATE $\text{use\_x1\_block}[b-1] \gets \text{use\_y1}[j]$
%             \ENDIF
    
%             \STATE $r[b] \gets j$
%             \STATE $j \gets j + 1$
%         \ENDWHILE
    
%         \COMMENT{Expand blocks to form final $x$}
%         \STATE $x \gets$ empty array of length $n$
%         \STATE $f \gets n-1$
    
%         \FOR{$\ell = b$ down to $1$}
%             \STATE $start\_idx \gets r[\ell-1] + 1$
%             \STATE $end\_idx \gets r[\ell]$
%             \IF{$\text{use\_x1\_block}[\ell-1] = \text{True}$}
%                 \STATE $block\_value \gets x_1^{\text{block}}[\ell-1]$
%             \ELSE
%                 \STATE $block\_value \gets \max(x_2^{\text{block}}[\ell-1], M)$
%             \ENDIF
%             \FOR{$idx = end\_idx$ down to $start\_idx$}
%                 \STATE $x[idx] \gets block\_value$
%             \ENDFOR
%             \STATE $f \gets start\_idx - 1$
%         \ENDFOR
    
%         \STATE \textbf{return} $x$
%     \end{algorithmic}
% \end{algorithm}
