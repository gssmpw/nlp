\subsection{Proof of Lemma~\ref{lemma:PAVA_merging_linear_time_complexity}}

\begin{namedlemma}[~\ref{lemma:PAVA_merging_linear_time_complexity}]
    \label{appendix_lemma:PAVA_merging_linear_time_complexity}
    The merging part (lines 11-14) in the PAVA algorithm can be executed in linear time complexity, $O(n)$, where $n$ is the number of elements in the input vector $\bmu$.
\end{namedlemma}

\begin{proof}
% Add proof content here
The actual implementation to achieve the linear time complexity is called the up and down block algorithm, which is provided in Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA} in this appendix.
In order to prove this lemma, we only need to show that 
1) Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA} accomplishes the objective in lines 11-14 of Algorithm~\ref{alg:PAVA_algorithm} in the main paper, and
2) Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA} runs in linear time complexity.

\paragraph{Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA} accomplishes the objective in lines 11-14 of Algorithm~\ref{alg:PAVA_algorithm}}
In this up and down block algorithm, we use a special data structure called $\{P_b, S_b, v_b\}$ to store the values of $\sum_{j \in \calB(b)} \rho_j$ (sum of Huber penalty coefficients), $\sum_{j \in \calB(b)} \vert{\mu_j}$ (sum of absolute values of the input vector elements), and $\text{prox}_{P_b H_{M}}(S_b)$ (proximal operator of the Huber penalty function), respectively, for each block index $b$.

The output of this proximal operator, $\text{prox}_{P_b H_{M}}(S_b)$, is the minimizer of the the univariate function in this block.
To see this, let us write out the minimizer of the univariate function in the $b$-th block explicitly, with $\calB(b)$ denoting the set of indices in the $b$-th block:
\allowdisplaybreaks
\begin{align}
    & \argmin_{v} \sum_{j \in \calB(b)} \left( \frac{1}{2} (v - \vert{\mu_j})^2 + \rho_j H_M(v) \right) \\
    = & \argmin_{v} \sum_{j \in \calB(b)} \left( \frac{1}{2} (v^2 - 2v\vert{\mu_j} + \mu_j^2) + \rho_j H_M(v) \right) \eqcomment{expand the square terms} \\
    = & \argmin_{v} \sum_{j \in \calB(b)} \left( \frac{1}{2} v^2 - v\vert{\mu_j} + \rho_j H_M(v) \right) \eqcomment{get rid of the constant terms} \\
    = & \argmin_{v} \left( \sum_{j \in \calB(b)} \frac{1}{2} v^2 - \sum_{j \in \calB(b)} v\vert{\mu_j} + \sum_{j \in \calB(b)} \rho_j H_M(v) \right) \eqcomment{apply summation to each term} \\
    = & \argmin_{v} \left( N_b \frac{1}{2} v^2 - S_b \vert{\mu_j} + P_b H_M(v) \right) \eqcomment{substitute $N_b = \sum\limits_{j \in \calB(b)} 1$, $S_b = \sum\limits_{j \in \calB(b)} \vert{\mu_j}$, and $P_b = \sum\limits_{j \in \calB(b)} \rho_j$} \\
    = & \argmin_{v} \left( \frac{1}{2} v^2 - \frac{S_b}{N_b} \vert{\mu_j} + \frac{P_b}{N_b} H_M(v) \right) \eqcomment{divide all terms by $N_b$}\\
    = & \argmin_{v} \left( \frac{1}{2} \left( v - \frac{S_b}{N_b} \right)^2 + \frac{P_b}{N_b} H_M(v) \right) \eqcomment{complete the square} \\
    =& \text{prox}_{\frac{P_b}{N_b} H_{M}}(\frac{S_b}{N_b}). \eqcomment{proximal operator of the Huber penalty function}
\end{align}

Thus, Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA} merges two adjacent blocks if the isotonic violation persists, and the output of the proximal operator is the minimizer of the univariate function in the merged block.
This is exactly the same as the objective in lines 11-14 of Algorithm~\ref{alg:PAVA_algorithm}.

\paragraph{Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA} runs in linear time complexity}
For the while loop $j \leq n$ in Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA}, the variable $j$ is incremented by 1 in each iteration, and the loop terminates when $j = n$.
Although there are two while loops inside the main while loop, the total number of iterations in the two inner while loops is at most $n$.
This is because we start with $n$ blocks, and each iteration of the inner while loops either merges two blocks forward or merges two blocks backward.
The total number of merging operations is at most $n-1$.
Thus, the total number of iterations in the while loop $j \leq n$ is at most $n$.
Lastly, since we can evaluate the proximal operator of the Huber loss function, $H_M(\cdot)$, in constant time complexity, the total time complexity of Algorithm~\ref{alg:up_and_down_block_algorithm_for_merging_in_PAVA} is $O(n)$.


\end{proof}

