\subsection{Payment Channels: Basic Principles}\label{sec:payment_channels}

% \paragraph{Layer-Two Solutions for Blockchain Scalability} The Nakamoto consensus protocol suffers from a fundamental shortcoming: its low transaction throughput. This limitation hinders the widespread adoption of blockchain-based systems for payments. In recent years, the blockchain community has proposed a variety of methods to address these scalability challenges. The proposed improvements can be broadly classified into two distinct categories: \textit{layer-one solutions} and \textit{layer-two solutions}. Layer-one solutions propose a new consensus mechanism that does not suffer the aforementioned drawbacks of the Nakamoto consensus protocol. In contrast, layer-two solutions use the existing framework of a Nakamoto consensus-based blockchain to provide users a tool to transact without recording all of the transactions on the blockchain itself. Hence, they are also termed as \textit{off-chain mechanisms}. By reducing the transaction load on the underlying blockchain, layer-two solutions address the issue of low throughput. Further, some mechanisms have the following property: when both nodes act honestly, the mechanism provides a faster transaction confirmation guarantee than the consensus layer. Only when there are disputes, the transactions are broadcast to the whole network, and the history as recorded by the blockchain is treated as final. The recent survey paper \cite{gudgeon2020sok} gives an overview of popular layer-two scalability solutions.
The idea of a payment channel was born at least as early as 2013 and has since undergone considerable evolution. We refer the interested reader to Section 3 of the survey \cite{gudgeon2020sok} and Chapter 5 of the thesis \cite{tikhomirov2020security} for a historical survey of payment channels. Here, we describe the construction and operation of a payment channel at a level of generality that encompasses several designs. 
\paragraph{Construction and Basic Operation} A payment channel is created by means of a special \textit{funding transaction}, with two nodes depositing some money into a new two-node account (the channel). This funding transaction is recorded on the blockchain. %Money can be spent from this special account only when both nodes agree to do so.
At the time of creation, both nodes also create and privately hold a \textit{commitment transaction} which disburses the money held in the channel back to their personal accounts. %This serves as a guarantee for each node that they can get their money back whenever they wish to. 
Once a channel is created between two nodes, they can transact by exchanging messages between themselves. Each message is simply a new commitment transaction, \textit{i.e.}, an agreement between the two nodes to split the escrowed fund in a certain portion between the two nodes. Thus, each transaction results in a reassignment of the total value between the two nodes. None of these transactions need to be broadcast to the blockchain network. A channel is closed by recording a commitment transaction on the blockchain that effectively returns the appropriate balances to the two nodes' individual accounts. A payment channel also includes some inbuilt safety mechanisms by which an honest node can withdraw its funds even if the other node goes missing or acts maliciously.

% \paragraph{One-directional Payment Channels} The first payment channels invented were one-directional by nature; payments could only be made by one node to the other, but not the other way around. Such payment channels are analogous to gift-cards, as illustrated by the following example. Suppose a customer buys a gift-card for a certain coffee chain for a hundred dollars, paying for it with their credit card. This transaction gets recorded on the credit card's server. Subsequently, when the customer buys a coffee for five dollars each time using the gift-card, these transactions are solely between the store and the customer; in particular, they are not recorded by the credit card company or the customer's bank. 

% In the blockchain world, a customer may create a unidirectional payment channel by depositing some money into it and subsequently use this deposited money to make multiple small payments. Each payment consumes some of the escrowed amount, eventually depleting the entire fund, just as in a gift-card. At this stage, the payment channel must be closed and a new one opened if further transactions are to be made. The channel may also be closed before exhausting the entire amount, if either of the two nodes decide they do not wish to transact further.

% \paragraph{Bidirectional Payment Channels} The pioneering work of Decker and Wattenhofer \cite{decker2015fast} as well as Poon and Dryja \cite{poon2016bitcoin} introduced bidirectional payment channels, i.e., channels that can support payments from either node to the other one. To visualize these payment channels, it is useful to think of a beaded wire, with the beads split among the two ends of the wire, similar to an abacus. Each bead represents a unit of money. Thus, the total number of beads is proportional to the total amount deposited, while the number of beads at each end denote the amounts owned by each node. A payment across a channel can be visualized as a movement of beads from the payer to the payee. From this point onward, the term payment channel is used to refer to a bidirectional payment channel.

\paragraph{Channel Capacity and Balances} The total amount of money escrowed in a channel is called the \textit{capacity} of the channel. The amount of money each node owns within the channel are the \textit{balances} of the two nodes. While the capacity remains constant over time, the balances change with every transaction. The sum of the balances always equals the capacity. 
At any given point in time, a channel's balances impose a bound on the maximum value of a single transaction that can be made in either direction. To elaborate, consider a channel between two nodes $A$ and $B$, and let their balances be $x_A$ and $x_B$ respectively. Then $A$ cannot pay $B$ more than $x_A$ amount of money and $B$ cannot pay $A$ more than $x_B$ amount of money in a single transaction. Usually, the transaction values through a payment channel are much smaller than the channel's capacity. Therefore, if a channel is \textit{balanced}, \textit{i.e.}, the balances are each close to half the capacity, it will be able to execute any transaction request that might arise from either of its ends.

\paragraph{Flows} Consider a scenario where node $A$ pays node $B$ ten dollars each day over the channel $A-B$ (\textit{e.g.}, a customer buying coffee from a cafe every day). This long-term transaction pattern can be represented as a \textit{flow} of money across the channel. More generally, a flow through a channel represents a long-term transfer of money from one node to another. We can use the notion of a flow to represent a series of transactions whose values fluctuate randomly or periodically around some average value.

The notion of flows sheds some light on the choice of the term \textit{channel capacity}, defined above. In the context of communication networks, this term denotes the maximum rate of communication that a channel can support, \textit{i.e.}, the maximum number of bits (or information) that the channel can carry per unit time. For a payment channel, there is a similar interpretation; its capacity, \textit{i.e.,} the total escrowed fund, is proportional to the maximum possible flow rate through the channel (sum of the flows in each of the two directions). Indeed, the flow through a channel is maximized if each node sends its complete balance to the counter-node immediately after the previous transaction is completed and the resulting flow rate is equal to the total escrowed fund per time slot. 

\paragraph{The Balance Condition for Flows} In addition to a bound on the total flow rate, a payment channel also imposes a \textit{balanced flow constraint}, which can be stated as follows. Without persistent on-chain rebalancing (described below), a payment channel cannot sustain a nonzero, constant net flow indefinitely. 
Suppose, for instance, that on average, $A$ pays $B$ ten dollars per day and $B$ pays $A$ five dollars per day. Over time, $A$'s balance in the channel decreases continuously. Whatever be the channel's capacity, eventually $A$'s balance gets completely exhausted. 
If $A$'s transactions to $B$ are \textit{elastic} (\textit{i.e.}, $A$ is willing to tolerate a smaller flow rate than its original demand), $A$ could wait for $B$ to make some payments to $A$. Effectively, the flow rate from $A$ to $B$ drops by half to five dollars per day. Thus, the channel settles to a state where it has zero net flow through it. This example illustrates how a channel naturally enforces the balance constraint on flows through it.

\paragraph{On-Chain Rebalancing} If flows are \textit{inelastic}, \textit{i.e.}, the entire demand must be served through the channel, then the channel can reset its balances via an on-chain transaction. One option is that $A$ pays $B$ some amount via an on-chain transaction, with $B$ paying $A$ back the same amount on the channel. If this amount is half the channel capacity, the entire operation would rebalance the channel. Alternatively, the nodes may open a new, perfectly balanced channel between themselves. In summary, with persistent on-chain rebalancing, a channel can support a nonzero net flow. However, on-chain rebalancing is an expensive operation and should be avoided to the extent possible. Moreover, supporting a nonzero net flow through a channel with persistent on-chain rebalancing is equivalent to serving balanced flows on the payment channel and serving the rest of the demand on the blockchain.