\subsection{From a Dual Algorithm to the DEBT Control Protocol}\label{sec:algorithm_to_protocol}

We now describe how algorithm \eqref{eq:algorithm} can be implemented in a decentralized fashion in a payment channel network whose model we presented in Section \ref{sec:PCN_model}. This decentralized implementation is the DEBT control protocol for PCNs. {At every slot $t$:
\begin{enumerate}
    \item The channel prices, $\lambda[t]$, are made publicly available. Using these prices and the knowledge of the graph topology, transacting node pairs calculate the prices along their prospective paths according to \eqref{eq:path_price}. 
    \item The demand arrives to the network. Each transacting node pair $(i,j)$ knows its demand $a_{i,j}$ and its path prices $\mu_{i,j,k}[t]$ (from the previous step). Using these, each node pair calculates the flow $f_{i,j,k}[t]$ to be requested along each path, using the waterfilling scheme \eqref{eq:waterfilling}. In Section \ref{sec:flow_control_routing}, we noted that each node-pair can perform this calculation independently.
    \item The flow requests are conveyed to the respective channels. Each channel checks whether the flow requested through it is feasible or not (whether it has sufficient balance to execute the flow). If it does, it immediately executes the flow; if not, it rebalances itself and then executes the flow. In either case, the flow requests made at slot $t$ are executed within the same slot. Following this, the balances of the channels change according to \eqref{eq:rebalancing}-\eqref{eq:balance_update}.
    \item Finally, each channel updates its price proportional to the net flow through it:
    $$ \lambda_{u,v}[t+1] = \lambda_{u,v}[t] + \gamma (Rf)_{u,v}[t] \quad \forall \ (u,v) \in E $$
    The price updates are based on local information alone; thus, each channel updates its price independently. In fact, channels need not know the source or the destination of the flows that they are serving to calculate prices.
\end{enumerate}}

The term $\lambda_{u,v}$ tends to increase if the net flow through the channel $(u,v)$ is in the direction from $u \rightarrow v$, and tends to decrease if the net flow is in the opposite direction. This change is consistent with the interpretation of $\lambda_{u,v}$ as a price that penalizes or encourages flows in order to maintain detailed balance. Indeed, a sustained net flow in either direction is bound to increase the price for any future flow in that direction. It also decreases the price for any flow in the opposite direction, thereby encouraging such flows. Note that when a channel rebalances itself, it does not reset its prices. Thus, the price of a channel may not exactly reflect its balances; rather, it is proportional to the net amount of money that a channel has carried through itself. The prices keep adjusting in a manner such that eventually, the net flow through each channel converges to zero. In the following section, we show that the flows not only converge to a detailed balance flow, but in fact, they converge to a solution of \eqref{eq:primal_problem}.

% \textcolor{red}{We conclude this section with a note on channel rebalancing. As mentioned in Section \ref{sec:flow_feasibility}, the main purpose of channels rebalancing themselves in our protocol is to ensure that all transactions requested by the nodes are executed by the network. This smooth execution of transactions is important in order to let the prices evolve as per the demand and converge to an optimal point. Next, observe that the price of a channel at any time is proportional to the cumulative net flow through it up until that point in time (because prices are initialized to be zero). In the following section, we show that the prices $\lambda[t]$ converge to some finite point $\lambda^*$, which suggests that the prices remain bounded throughout.}

% We now show how algorithm \eqref{eq:algorithm} can be implemented in a decentralized fashion in a payment channel network whose model we presented in Section \ref{sec:PCN_model}. This decentralized implementation is the DEBT control protocol for PCNs. Each iteration of algorithm $\eqref{eq:algorithm}$ corresponds to a single time step of the payment channel network. We make the following assumptions regarding the information available to the parties in the protocol. Firstly, we assume that each channel declares its price publicly whenever it is updated, \textit{i.e.}, $\lambda[t]$ is known to all nodes at the beginning of slot $t$. Secondly, we assume that each transacting node pair knows a set of paths between them along which they would like to execute transactions. Thus, they can calculate the corresponding path prices, $\mu[t]$.

% As the transaction requests arrive, nodes know the amount they would like to send to each recipient. Based on the path prices, they calculate the exact amount to send and the path(s) to send it along, \textit{i.e.}, $f[t]$ is calculated in response to $\mu[t]$. A transaction amount of zero corresponds to dropping the transaction. In Section \ref{sec:flow_control_routing}, we noted that each node-pair solves its own optimization problem to decide its flow, without interacting with the other node-pairs. Having made their decisions, nodes pass on the request for executing each flow to the channels in the corresponding path.

% If the flow vector $f[t]$ is feasible (\textit{i.e.}, satisfies \eqref{eq:feasibility}), all flow requests are executed immediately. Otherwise, if some channels have insufficient balances and are therefore unable to route the flows that have been requested, they rebalance themselves and then execute the flow. In either case, the flow requests made at slot $t$ are executed within the same slot. After executing the flow $f[t]$, the channels' balances are updated according to \eqref{eq:balance_update}. The channels update their prices at the end of the time slot, after the flows have been routed, as follows:
% \begin{align} \label{eq:lambda_updates}
%     \lambda_{u,v}[t+1] &= \lambda_{u,v}[t] + \gamma (Rf)_{u,v}[t] \quad \quad \forall \ (u,v) \in E
% \end{align}

% Note that the increment in a channel's price is proportional to the net flow through that channel in that time slot. Thus, the price updates are based on local information alone. Further, because all channel prices are initialized to zero, \textit{the price of a channel at any time is proportional to the cumulative net flow through it up until that point in time.} In fact, channels need not know the source or the destination of the flows that they are serving to calculate prices. Also note that the price updates do not depend on whether a channel rebalances itself or not. Each channel simply updates its own price and makes the price publicly known at the end of each slot.


% The term $\lambda_{u,v}$ tends to increase if the net flow through the channel $(u,v)$ is in the direction from $u \rightarrow v$, and tends to decrease if the net flow is in the opposite direction. This change is consistent with the interpretation of $\lambda_{u,v}$ as a price that penalizes or encourages flows in order to maintain detailed balance. Indeed, a sustained net flow in either direction is bound to increase the price for any future flow in that direction. It also decreases the price for any flow in the opposite direction, thereby encouraging such flows. The prices keep adjusting in a manner such that in the long run, the net flow through each channel converges to zero. This is a stable operating point for the protocol. %We discuss this further in the following section.

%In Section \ref{sec:dual_algorithm}, we presented algorithm $\eqref{eq:algorithm}$ (see $\eqref{eq:flow_updates_concise} - \eqref{eq:lambda_updates_concise}$) in which channels quote prices for routing flows based on which transacting node-pairs make flow-control and routing decisions.  This gives rise to a network protocol that can be implemented by the nodes and channels of a payment channel network.

% Assuming that the protocol converges to a detailed balance flow, the frequency with which a channel needs to rebalance reduces, eventually approaching zero. If the protocol converges fast enough, the number of times a channel would need to rebalance is finite. In fact, if the channel capacities are large enough, the channels would not need to rebalance at all. Moreover, the protocol never runs into deadlocks. This is because, in the transient phase, the channels rebalance themselves if they get imbalanced, while in steady-state, the protocol stifles out deadlock-causing flows.
