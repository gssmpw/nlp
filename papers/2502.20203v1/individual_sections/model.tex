\section{A Discrete-Time Model of a Payment Channel Network}\label{sec:PCN_model}
In this section, we present a mathematical model of a payment channel network.
We follow the notation used by \cite{sivaraman2021effect}.
The network consists of a set of nodes $V$ and a set of channels $E$ between pairs of nodes. 
The nodes are numbered $1, 2, \ldots, |V|$. A channel connecting nodes $u$ and $v$ is denoted $(u,v)$. 
We use the convention that the lower index vertex is written first; e.g., in the channel $(u,v)$, $u < v$. 
Each channel has a certain capacity, which refers to the total amount of money escrowed in the channel. 
Let $c_{u,v}$ denote the capacity of channel $(u,v)$ and let $c \in \mathbb{R}_+^{E}$ be a vector denoting the capacities of all the channels in the network. 
Thus, the tuple ($V, E, c$) specifies a weighted, undirected graph. 
This graph remains unchanged throughout the period of operation.

A PCN is a dynamical system. In this work, we assume the system evolves in discrete time steps. The state of the PCN at any given time is described by the balances in each of the channels. 
At any given time $t$, let the balance of node $u$ in channel $(u,v)$ be $x_{u,v}[t]$. 
It follows that the balance of $v$ in the same channel is $c_{u,v} - x_{u,v}[t]$. 
Let $x[t] \in \mathbb{R}_+^E$ denote the vector of balances, also called the state vector. 
By convention, $x$ contains the balance of the smaller-indexed node of each channel; the balance at the opposite end of the channel is inferred from its capacity. 
The state vector always satisfies $0 \leq x[t] \leq c$ (the inequalities hold component-wise).

\subsection{The Nature of Transaction Requests}\label{sec:transaction_requests}
\newcommand{\demand}{a}
\newcommand{\totalflow}{q}
We assume that in each slot, between every source-destination node-pair, a single transaction request arrives. Let $\demand_{i,j}[t]$ denote the monetary value of the transaction request from source $i$ to destination $j$ in slot $t$. This assumption does not sacrifice any generality. Indeed, the case where no transaction is requested is easily modeled by setting $\demand_{i,j}[t] = 0$. Moreover, multiple transaction requests in a time slot can be viewed as a single transaction request whose amount equals the sum of all the individual components. In general, the requested transaction amounts could vary arbitrarily over time. For the sake of simplicity, in this work, we focus on the regime of \textit{constant demands}, \textit{i.e.,} we assume that $\demand_{i,j}[t] = \demand_{i,j}$ for all time $t$ and all transacting node-pairs $(i,j)$. The vector $\demand = (\demand_{i,j})_{(i,j) \in V \times V}$ is called the \textit{demand vector}. We do not make any further assumption about $a$.

A second assumption we make is that the transaction demand arriving to the payment channel network is elastic. In other words, node-pairs prefer to have the entire transaction be served by the PCN, but it is acceptable that the request is dropped or partially served. This is a realistic assumption because users have alternate means of transacting, \textit{e.g.}, on the main blockchain. The choice of the transaction amount, $\totalflow_{i,j}[t]$, in response to the network state, is termed as \textit{flow-control}.

We model elastic transaction requests by means of a utility function. We assume that the node-pair $(i,j)$ gains a utility of $U_{i,j}(\totalflow_{i,j}[t])$ upon being served a transaction of amount $\totalflow_{i,j}[t] \in [0, a_{i,j}]$ by the network. We assume that $U_{i,j}(\cdot)$ is a concave, differentiable, and nondecreasing function over $[0, a_{i,j}]$. We also assume that $U_{i,j}(0) = 0$ and $U'_{i,j}(0) < \infty$. 
We assume transaction requests are \textit{infinitely divisible}, which means that any fraction of the value $\demand_{i,j}[t]$ can be served in slot $t$ with the rest being dropped. We also assume that transactions are not queued. 

\subsection{The Order of Events}
We model the PCN as a discrete-time system. 
To be definite, we assume that events take place in a fixed order in each time slot, as described below.
\begin{enumerate}
    \item Transaction requests arrive to the payment channel network. 
    Each transaction request is composed of a source-destination node-pair and a monetary value. 
    These transaction requests depend on exogenous factors, such as demand for certain goods and services, and are independent of the state in the network. 
    \item The nodes make flow-control and routing decisions. 
    That is, for every transaction request, the corresponding source-destination pair decides what fraction of the transaction value should be served; this includes the possibilities of serving the transaction entirely or dropping the transaction entirely. The node pair also decides which paths of the network should carry the transaction--we allow for multi-path routing. These decisions are made on the basis of some information reflecting the network's state; the precise details are given in Section \ref{sec:debt_control_protocol}.
    \item The payment channel network executes the transaction requests made by the nodes by moving the requisite money through the payment channels. After the transactions are served, channel balances are updated. We assume that the channels themselves never drop any transactions, \textit{i.e.}, all transaction requests that are passed on from the nodes to the network are actually served. The details of how this may be achieved in practice is described in Section \ref{sec:flow_feasibility}. 
\end{enumerate}

\subsection{Paths and Flows} A path in the PCN is a sequence of channels, with each one adjacent to the previous one, endowed with a sense of direction. A path may have cycles, but we assume that it traverses each channel at most once. Any such path can be represented by a vector $r \in \{-1, 0, 1\}^{E}$ using the convention described below:
\begin{itemize}
    \item let $r_{u,v} = 1$ if the path traverses the channel $(u,v)$ in the direction $u \rightarrow v$,
    \item let $r_{u,v} = -1$ if the path traverses the channel $(u,v)$ in the direction $v \rightarrow u$, and
     \item let $r_{u,v} = 0$ if the path does not traverse the channel $(u,v)$ in either direction.
\end{itemize}

A source-destination pair $(i,j)$ may use any number of paths in the network for carrying transactions. Denote the $k\textsuperscript{th}$ path by $p_{i, j, k}$ and the set of such paths by $P_{i,j}$. Note that a path from $i$ to $j$ is different from a path from $j$ to $i$. Let $P$ denote the set of all paths ($P = \cup_{i,j} P_{i,j}$). Let $R$ denote the $E \times P$ routing matrix with entries in $\{-1, 0, 1\}$ constructed using the convention given above. In $R$, each column corresponds to a particular path and each row corresponds to a particular channel.

With every path in the network, we associate a flow, which represents the amount of money sent along that path over a period of time. Let $f_{i,j,k}[t]$ denote the amount of money being sent on path $p_{i,j,k}$ in slot $t$. The amounts of money sent from node $i$ to node $j$ along all possible paths in slot $t$ is denoted by $f_{i,j}[t]$, \textit{i.e.}, \(f_{i,j}[t] \triangleq (f_{i,j,1}[t], \ldots, f_{i,j,k}[t])\).
The total amount of money sent from $i$ to $j$ in slot $t$ is denoted by $\totalflow_{i,j}[t]$. Thus \(\totalflow_{i,j}[t] \triangleq \Sigma_k f_{i,j,k}[t].\) Finally, let $f[t] \in \mathbb{R}^P$ denote the set of all the flows in the network in slot $t$.

\subsection{Feasibility of Flows and State-Change Equations}\label{sec:flow_feasibility} 
If the channel balances are arbitrary, it is possible that some channels are unable to execute the requested flows through them due to insufficient balance. A set of flows can be served entirely if and only if there is sufficient balance on each side of each edge to route all the flows through in that direction simultaneously. Given a balance vector $x[t]$, a flow vector $f[t]$ is \textit{feasible} if:
\begin{equation}\label{eq:feasibility}
    R^+f[t] \leq x[t]; \quad R^-f[t] \leq c - x[t].
\end{equation}
Here, $R^+$ is the matrix obtained by turning all $-1$s to $0$s in $R$ and $R^-$ is the matrix obtained by turning all $1$s to $0$s and $-1$s to $1$s in $R$. Thus, $R = R^+ - R^-$.

In this work, we make the following two assumptions that ensure that the flow vector at each time step is always feasible. Firstly, the channel capacities must be large enough so that if the channels are evenly balanced, they will be able to serve the entire demand on any routing scheme. We make this notion precise as follows. Given any demand vector $a$, let $A$ denote the set of (non-negative) flows satisfying the demand constraints:
\begin{align}
    A \triangleq \{f: f \geq 0, \ f_{i,j} \leq a_{i,j} \ \forall \ (i,j) \in \mathcal{N}\}.
\end{align}
We assume that the capacities of the channel are large enough such that:
\begin{align}\label{eq:large_capacity_assumption}
    \sup_{f \in A} R^+f \leq c/2, \quad \sup_{f \in A} R^-f \leq c/2
\end{align}


Secondly, whenever a channel observes that the requested flow through it is infeasible, it rebalances itself and then executes the flow. (By the first assumption, the flow becomes feasible after this rebalancing operation.) To keep things simple, we assume that the rebalancing operation takes place instantaneously. In practice, a rebalancing operation can take time; however, a channel can preemptively rebalance itself if it observes that its balances are getting skewed beyond a certain extent.

With this notation in place, we can write the state-update equations as follows. First, the channels undergo rebalancing if necessary. Thus, the intermediate balances are:
\begin{equation}\label{eq:rebalancing}
    \Tilde{x}_{u,v}[t] = \begin{cases}
        c_{u,v}/2 & \text{if  channel $(u,v)$ rebalances} \\
        x_{u,v}[t] & \text{otherwise}
    \end{cases}
\end{equation}
Next, they execute the requested flow. At the end of the slot, the new balances are:
\begin{equation}\label{eq:balance_update}
    x[t+1] = \Tilde{x}[t] - Rf[t].
\end{equation}

\subsection{Detailed Balance Flows}\label{sec:detailed_balance_flows}
The notion of flows as described above is a quantity that is dynamically evolving in time. In contrast, the notion of a \textit{stationary flow} refers to a steady, long-term, exchange of transactions between a pair of nodes in the PCN. 
(This is similar to the usage in Section \ref{sec:payment_channels}.)  
When referring to stationary flows, we use the notation $f$ (without $t$) to denote the vector of flow rates over each path. We also use the same convention to define $f_{i,j}$ and $\totalflow_{i,j}$.

In Section \ref{sec:payment_channels}, we discussed the balanced flow constraint on a payment channel. This constraint applies to every channel in a payment channel network. A stationary flow vector $f$ is said to satisfy the \textit{detailed balance condition} (equivalently, said to be a detailed balance flow) if \(Rf = 0.\)
For any flow vector $f$, the term $(Rf)_{u,v}$ represents the net flow in the direction $u \rightarrow v$ along the channel $(u,v)$; a negative value means that the net flow is in the direction $v \rightarrow u$. A detailed balance flow is such that the amount of money flowing through each channel is equal in the two opposite directions. Thus, after a detailed balance flow has been served, the balances on all the edges remain the same as before (see \eqref{eq:balance_update}). Any detailed balance flow can be sustained in steady-state without any on-chain rebalancing. Conversely, any flow vector that does not satisfy the detailed balance condition can only be sustained in steady-state with persistent on-chain rebalancing. 