%% This template can be used to write a paper for
%% Computer Physics Communications using LaTeX.
%% For authors who want to write a computer program description,
%% an example Program Summary is included that only has to be
%% completed and which will give the correct layout in the
%% preprint and the journal.
%% The `elsarticle' style is used and more information on this style
%% can be found at 
%% http://www.elsevier.com/wps/find/authorsview.authors/elsarticle.
%%
%%
% \documentclass[preprint,12pt]{elsarticle} % PREPRINT
\documentclass[final,3p,times,twocolumn]{elsarticle}

%% Use the option review to obtain double line spacing
%% \documentclass[preprint,review,12pt]{elsarticle}

%% Use the options 1p,twocolumn; 3p; 3p,twocolumn; 5p; or 5p,twocolumn
%% for a journal layout:https://www.overleaf.com/project/60b60ffab2ac5e96adda65ea
%% \documentclass[final,1p,times]{elsarticle}
%% \documentclass[final,1p,times,twocolumn]{elsarticle}
%% \documentclass[final,3p,times]{elsarticle}
%% \documentclass[final,3p,times,twocolumn]{elsarticle}
%% \documentclass[final,5p,times]{elsarticle}
%% \documentclass[final,5p,times,twocolumn]{elsarticle}

%% if you use PostScript figures in your article
%% use the graphics package for simple commands
%% \usepackage{graphics}
%% or use the graphicx package for more complicated commands
%% \usepackage{graphicx}
%% or use the epsfig package if you prefer to use the old commands
%% \usepackage{epsfig}

\usepackage{graphicx}% Include figure files
\usepackage{xcolor}
\usepackage[caption=false,justification=justified]{subfig}  

%% The amssymb package provides various useful mathematical symbols
\usepackage{amssymb}
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
\usepackage{listings}
\usepackage{amsmath}
\usepackage[autoload=false]{jlcode}
\usepackage{xcolor}
\usepackage[normalem]{ulem}
\usepackage{hyperref}

%New colors defined below
\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}
\definecolor{darkGreen}{RGB}{0,110,0}

%Code listing style named "mystyle"
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{backcolour}, commentstyle=\color{codegreen},
  keywordstyle=\color{magenta},
  numberstyle=\tiny\color{codegray},
  stringstyle=\color{codepurple},
  basicstyle=\ttfamily\scriptsize,%\ttfamily\footnotesize,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  numbers=none,                    
  numbersep=5pt,                  
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2,
% move frame wrt window
  frame=single,
  framexleftmargin=-5mm,
  framexrightmargin=+0mm,
  framextopmargin=1mm,
  framexbottommargin=-3mm,
  % move the whole window
  xleftmargin=-.4cm,
  xrightmargin=+0.08cm,
}

%"mystyle" code listing set
\lstset{style=mystyle}



%% The amsthm package provides extended theorem environments
%% \usepackage{amsthm}

\usepackage{float}


%% This list environment is used for the references in the
%% Program Summary
%%
\newcounter{bla}
\newenvironment{refnummer}{%
\list{[\arabic{bla}]}%
{\usecounter{bla}%
 \setlength{\itemindent}{0pt}%
 \setlength{\topsep}{0pt}%
 \setlength{\itemsep}{0pt}%
 \setlength{\labelsep}{2pt}%
 \setlength{\listparindent}{0pt}%
 \settowidth{\labelwidth}{[9]}%
 \setlength{\leftmargin}{\labelwidth}%
 \addtolength{\leftmargin}{\labelsep}%
 \setlength{\rightmargin}{0pt}}}
 {\endlist}


%%%%%% UNCOMMENT FOR SUBMISSION ###### BEGIN
\journal{X}
% \journal{XXX, published article available \href{https://doi.org/10.1016/j.patter.2022.100589}{here}}
%%%%%% UNCOMMENT FOR SUBMISSION ###### END


\newcommand{\red}[1]{\textcolor{red}{#1}}
\newcommand{\new}[1]{\textcolor{blue}{#1}}
\newcommand{\del}[1]{\new{\sout{#1}}}
\newcommand{\q}[1]{``#1''}

\newcommand{\beforeit}[0]{{\fontfamily{cmss}\selectfont
BeforeIT}}

\newcommand{\modelname}[0]{{\fontfamily{cmss}\selectfont{base model}}}

% font specific for "DADApy" string
\newcommand{\dfont}[1]{{\fontfamily{lmss}\selectfont
#1}}

% \newcommand{\code}[1]{\colorbox{light-gray}{\texttt{#1}}}

\newcommand{\code}[1]{\texttt{#1}}

% alternative families: cmss, qhv, phv, lmss

\usepackage{balance}
\newcommand{\para}[1]{\noindent[\textbf{ #1 }]}

\newcommand{\ald}[1]{\textcolor{blue}{\textbf{AG: #1}}}
\newcommand{\mitj}[1]{\textcolor{purple}{\textbf{MD: #1}}}
\newcommand{\seb}[1]{\textcolor{orange}{\textbf{SP: #1}}}
\newcommand{\other}[1]{\textcolor{green}{\textbf{OTHER: #1}}}

\usepackage{lipsum}



\newcommand{\faketext}{\textcolor{green}{\lipsum[1]}}

\begin{document}

\begin{frontmatter}

%% Title, authors and addresses

%% use the tnoteref command within \title for footnotes;
%% use the tnotetext command for the associated footnote;
%% use the fnref command within \author or \address for footnotes;
%% use the fntext command for the associated footnote;
%% use the corref command within \author for corresponding author footnotes;
%% use the cortext command for the associated footnote;
%% use the ead command for the email address,
%% and the form \ead[url] for the home page:
%%
%% \title{Title\tnoteref{label1}}
%% \tnotetext[label1]{}
%% \author{Name\corref{cor1}\fnref{label2}}
%% \ead{email address}
%% \ead[url]{home page}
%% \fntext[label2]{}
%% \cortext[cor1]{}
%% \address{Address\fnref{label3}}
%% \fntext[label3]{}

% \title{\texorpdfstring{\vspace{-2cm}}{} \dfont{BeforeIT.jl}: Agent-based macroeconomic modelling fast to learn and to run}

% \title{\texorpdfstring{\vspace{-2cm}}{} \dfont{BeforeIT.jl}: A High-Performance and Extensible Software for Macroeconomic Simulations}

\title{\texorpdfstring{\vspace{-2cm}}{} \dfont{BeforeIT.jl}: High-Performance Agent-Based Macroeconomics Made Easy}

%% use optional labels to link authors explicitly to addresses:

\author[a]{Aldo Glielmo\corref{author}}
\author[b,c,d]{Mitja Devetak}
\author[e]{Adriano Meligrana}
\author[f]{Sebastian Poledna}

\address[a]{Applied Research Team, Directorate General for Information Technology, Banca d’Italia, Rome, Italy$^{\text{**}}$\corref{disclaimer}}
\address[b]{Paris 1 Panthéon-Sorbonne University, Paris, France}
\address[c]{Complexity Science Hub, Vienna, Austria}
\address[d]{Supply Chain Intelligence Institute Austria, Vienna, Austria}
\address[e]{University of Turin, Turin, Italy}
\address[f]{International Institute for Applied Systems Analysis (IIASA),
Vienna,
% Schlossplatz 1, 2361 Laxenburg, 
Austria}
\cortext[author] {Corresponding author, aldo.glielmo@bancaditalia.it}

\cortext[disclaimer] {The views and opinions expressed in this paper are those of the authors and do not necessarily reflect the official policy or position of Banca d’Italia.}

\begin{abstract}

\beforeit{} is an open-source software for building and simulating state-of-the-art macroeconomic agent-based models (macro ABMs) based on the recently introduced macro ABM developed in \cite{poledna2023economic} and here referred to as the \emph{\modelname{}}.
%
Written in Julia, it combines extraordinary computational efficiency with user-friendliness and extensibility.
%
We present the main structure of the software, demonstrate its ease of use with illustrative examples, and benchmark its performance.
%
Our benchmarks show that the \modelname{} built with \beforeit{} is orders of magnitude faster than a Matlab version, and significantly faster than Matlab-generated C code.
%
\beforeit{} is designed to facilitate reproducibility, extensibility, and experimentation.
%
As the first open-source, industry-grade software to build macro ABMs of the type of the \modelname{}, \beforeit{} can significantly foster collaboration and innovation in the field of agent-based macroeconomic modelling. 
%
The package, along with its documentation, is freely available at \url{https://github.com/bancaditalia/BeforeIT.jl} under the AGPL-3.0.


\end{abstract}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
software package, agent-based model, simulation, macroeconomics
\end{keyword}
\end{frontmatter}

\newpage

%% main text
\section{Introduction}

% IMPORTANCE OF MACRO ABMS
%
Macroeconomic agent-based models (macro ABMs) are computational models in which the micro-level behaviour of heterogeneous interacting agents—such as households and firms— is simulated to produce a macro-level understanding of aggregate economic outcomes \cite{hamill2015agent,dawid2018agent,axtell2022agent}.
%
This modelling approach is in contrast with traditional macroeconomic frameworks based on dynamic stochastic general equilibrium (DSGE) models, which typically employ representative-agent assumptions and solve for equilibrium conditions under well-defined optimisation problems \cite{christiano2010dsge,del2013dsge,christiano2018dsge}.
%
In comparison to DSGE models, macro ABMs use computational simulations of heterogeneous agents interacting, often requiring greater computational resources and more extensive calibration \cite{pangallo2024data}.
%
On the other hand, ABMs can naturally treat heterogeneity and nonlinear interactions among agents, as well as nonequilibrium dynamics.

%
Since their emergence in the early 2000s, macro ABMs have become an important tool for analysing economic dynamics, and particularly for reproducing stylized facts and capturing emergent phenomena such as asset bubbles, market crashes, economic divergence and convergence, and technological innovation \cite{turrell2016agent,dawid2018agent,dosi2019more,dawid2024implications}. 
%
ABMs can also provide a strong foundation for policy analysis in areas such as systemic risk, housing market dynamics or inflation, and they have been increasingly employed by policy institutions \cite{turrell2016agent,baptista2016macroprudential,catapano2021macroprudential,axtell2022agent}.



\begin{figure}[t]
\centering
\includegraphics[width=0.99\linewidth]{figures/logo_black_text.png}
\caption{{\bf Logo of the package.}
\beforeit{} stands for \textbf{B}ehavioural \textbf{e}conomic \textbf{fore}casting by the \textbf{IT} research unit of the Bank of \textbf{It}aly. The agents in the `it' monogram exemplify the agent-based nature of the simulation method.
%
The name of the package also refers to the forecasting possibilities offered by the package, as in predicting a phenomenon \emph{before it happens}.
}
\label{fig:logo}
\end{figure}

%
% IMPORTANCE OF THE \modelname{}
%
The macro ABM developed in \cite{poledna2023economic} represents an important step forward for the field as it demonstrated that ABMs can achieve short-term forecasting performances competitive with vector autoregressive (VAR) and DSGE models, alongside their capacity for reproducing emergent phenomena and stylized facts. 
%
The model’s flexibility and detailed representation of economic sectors has enabled it to address a variety of issues, ranging from the COVID-19 pandemic \citep{poledna2020recovery} and the 2021–2023 inflation surge \citep{grazzini2023understanding} to financial crises \citep{hommes2023analyzing}, migration \citep{poledna2024economic}, natural disasters \citep{bachner2024revealing,hochrainer2024risk}, and labour productivity losses due to heat stress \citep{kimmich2024economic}. 
%
The model was extended to work in distributed memory parallel environments in \cite{gill2021high}, and was taken as the basis for the multi-country macro ABM developed in \cite{wiese2024forecasting}.
%
Interest in this model has grown among several institutions, including the Bank of Canada, which incorporated it into monetary policy analysis \citep{canvas2024,coletti2023blueprint,gosselin2023making}.

Over the years, this broad adoption has given rise to multiple implementations of such a model. 
%
The original implementation, available in open-source is written in Matlab \cite{poledna2023economic,iiasa-model-github},
% and follows an approach similar to Dynare that closely mirrors the formal description of the model in the original manuscript . 
and it has served as the foundation for other variants. 
%
For instance, the Bank of Canada created CANVAS—a production-oriented modification of the reference Matlab code—which is currently closed-source. 
%
While Matlab is a closed-source language, the original open-source Matlab code can also be run using the open-source Octave language, although this typically implies a significant slowdown in execution time.
%
\cite{gill2021high} introduced a Distributed Memory Parallel (DMP-HPC) implementation in C++ using MPI for supercomputers, which is likewise closed-source. 
%
Meanwhile, the University of Oxford \cite{wiese2024forecasting} and Deloitte \cite{simudyne} have each developed their own closed-source extensions in Python and Java, respectively, underscoring the model’s adaptability across a range of environments.

Despite this array of implementations, until now, there was no user- and developer-friendly package that could be freely accessed, installed, and extended for diverse applications. 
%
To address this gap, we developed and released \beforeit{}, an open-source, thoroughly documented software package that is both user- and developer-friendly, providing computational efficiency and a structure suitable for extensions. 
%
\beforeit{} takes the model developed in \cite{poledna2023economic} as its core reference, but it also offers a general platform that allows researchers to construct, modify, and extend macro ABMs tailored to their specific applications, thus fostering methodological experimentation and custom analysis. 
%
Since the model in \cite{poledna2023economic} forms the foundation of \beforeit{}, we refer to it as the \modelname{} in the rest of this work.

%
To ensure quality, reliability, and long-term usability, we made \beforeit{} adhere to modern open-source package development standards and best practices.
%
\beforeit{} is publicly available on the GitHub page of the Bank of Italy\footnote{\url{https://github.com/bancaditalia/BeforeIT.jl}}, expanding the organization’s library of open-source ABM software packages, which includes other models \cite{brusatin2024simulating} and a calibration engine \cite{benedetti2022black,glielmo2023reinforcement}.
%
Its name and logo, illustrated in Fig.~\ref{fig:logo}, highlight its focus on behavioural agent-based economic forecasting.

Developed in the Julia language, \beforeit{} achieves computational efficiency comparable to C-compiled code while preserving readability and maintainability, characteristics typically associated with scripting languages such as Python or Matlab. 
%
Julia's balance between ease of use and computational performance has contributed to Julia's growing popularity in economics for numerical computations \cite{Dynarejl,kockerols2023macromodelling}, with notable adoptions by institutions such as the Federal Reserve \cite{del2015frbny,del2017forecasting} and the Bank of Canada \cite{StateSpaceEconjl,araujo2024open}. 

By providing a platform to build, run and extend a model of proven impact, \beforeit{} fills an important gap in the open-source software community with the aim to foster innovation, collaboration, and the wider adoption of macro ABMs.
%

The rest of this work is structured as follows.
%
In Sec.~\ref{sec:model-summary} we briefly review the \modelname{} as this forms the foundation of \beforeit{}, in Sec.~\ref{sec:software-structure} we describe the structure of the software and its main features, in Sec.~\ref{sec:usage-illustration} we provide practical examples of software usage, starting from an essential script and moving to more advanced scenarios, finally in Sec.~\ref{sec:conclusions} we conclude.

\section{An essential model summary}
\label{sec:model-summary}
%
The \modelname, the macro ABM developed in \cite{poledna2023economic}, simulates macroeconomic dynamics in a small open economy by modelling the interactions of millions of heterogeneous agents. 
%
%These agents represent key macroeconomic entities in the economy such as: households, non-financial corporations, financial institutions, the central bank, the government, and the rest of the world. 
%
The model is calibrated using data from national accounts, sectoral data, input-output tables, and business demographics, ensuring that the model reproduces exactly the state of the economy in that quarter in terms of aggregate GDP, GDP components, and industry sizes.

The model adheres to the European System of Accounts (ESA) framework \cite{ESA2010} and organizes the economy into the following six classes of macroeconomic agents:
%
\begin{itemize}
    \setlength\itemsep{-0.15em}
    %
    \item \textbf{Households} make consumption, savings, and labour supply decisions.
    %    
    \item \textbf{Non-financial corporations} produce goods using labour, capital, and intermediate inputs, with firm-level heterogeneity captured in terms of size, production processes, and market conditions. 
    %
    \item \textbf{Financial institutions} mediate credit markets.
    %
    \item \textbf{The central bank} implements monetary policies.
    %
    \item \textbf{The government} is responsible for taxation, public goods provision, and income redistribution
    %
    \item \textbf{The rest of the world} accounts for external trade and international capital flows.
    %
\end{itemize}

A distinguishing feature of this model in the literature of macro ABMs is its ability to provide aggregate macroeconomic forecasts—such as for GDP, inflation, and employment—and sector-specific forecasts. 
%
The rich micro-structure of the model, combined with adaptive learning, allows agents to form expectations based on past behaviours and observed outcomes. 
%
For example, households and firms rely on simple autoregressive (AR(1)) forecasting rules. Meanwhile, decentralised market interactions are characterized by search and matching mechanisms, which introduce trade frictions and market dynamics.

% \begin{figure}[!h]
% \caption{
% {\bf Model illustration.}
% %
% \ald{Sebastian: Do we have a figure here?}
% %
% }
% \label{fig:model-illustration}
% \end{figure}

\begin{figure*}[!h]
\centering
\includegraphics[width=0.9\textwidth,trim={1cm 3cm 1cm 3cm},clip]{figures/BeforeIT_software_structure.pdf}
\caption{
{\bf Illustration of the workflow and main objects of the software}. 
%
The left-hand side illustrates the typical workflow of a simulation run.
%
The function \code{init\_model} takes as input the two dictionaries \code{parameters} and \code{initial\_conditions} and the number of simulation steps \code{T}, returning an object named \code{model}.
%
This \code{model} object is composed of distinct objects representing the different agents of the economy, such as \code{gov} and \code{firms} and two other objects that do \emph{not} represent agents but store properties and aggregate variables, i.e., \code{prop} and \code{agg}.
%
The \code{model} object serves as input for \code{run!} or  \code{ensemblerun}, where the second function performs multiple independent Monte Carlo runs.
%
Simulation results are stored in a \code{data} object for a single run or in a \code{data\_vector} object for multiple runs, both of which allow easy inspection and visualization of attributes for any agent type.
%
Similarly, we can inspect any attribute of any of the agent classes.
%
The right-hand side illustrates the fact that a simulation run is essentially a for loop over the function \code{step!} and that a run over one step consists of a series of well-defined function calls taking the different agent types as input and updating specific attributes of the same agent type, making up modular and transparent simulation process.
}
\label{fig:software-structure}
\end{figure*}

% Results and Discussion can be combined.
\section{Software structure and main features}
\label{sec:software-structure}




\noindent
\textbf{Initialisation.}
%
To instantiate a model, it is sufficient to call the function \code{init\_model}.
%
This function takes three inputs: the two dictionaries \code{parameters} and \code{initial\_conditions}, and the simulation length in quarters \code{T}. 
%
The two dictionaries must be defined using specific keyword strings, such as \code{"tau\_INC"} for the taxation rate on income or \code{"mu"} for the risk premium over the policy rate charged by commercial banks to issue loans.
%
We use the same keywords used in the original parametrisation, available from the supplementary material of \cite{poledna2023economic}.
%
This ensures full compatibility with the Matlab parametrisations provided by the original paper, allowing users to easily load the Matlab file using \code{matread(mat\_file.mat)} and use the resulting variables for initialization.
%
For quick experimentation, we include in the package the original parametrisation for Austria in the first quarter of 2010.
%
We also provide an experimental parametrisation for Italy.
%
However, we believe that the generation of parameters and initial conditions should ultimately be handled in a dedicated package specifically tailored to this purpose.

\noindent \textbf{Structure.}
%
The different classes of macroeconomic agents described in the previous section are implemented in \beforeit{} as separate objects, which in Julia are defined via ``mutable structs''.
%
% (i.e., active and inactive workers, firms, the financial sector, the central bank, the government and the rest of the world)
%
Specifically the package defines the following objects: \code{w\_act} (for households consisting of active workers), \code{w\_inact} (for households consisting of inactive workers), \code{firms} (for non financial corporations), \code{bank} (for the financial sector), \code{cb} (for the central bank), \code{gov} (for the government)
, \code{rotw} (for the rest of the world).
%
Each object contains specific and thoroughly documented attributes corresponding to the key features of the respective agent type.
%
For instance, the \code{w\_act} struct includes an attribute \code{Y\_h}, which stores the income of all active workers at any given simulation time-step.
%
The attribute names across all agent types are chosen to align closely with the equations and notation used in the original publication \cite{poledna2023economic} to facilitate a clear connection between the code and the theoretical model.
% %
% The names used for the agents' features are chosen to reflect the equations of the original publication \cite{poledna2023economic}.
%

Finally, the entire model is encapsulated within a struct named \code{model}, which includes the seven agent groups as its attributes, along with two additional objects: the \code{prop} struct, which stores the properties of the simulation run, and the \code{agg} struct, which holds the aggregate variables representing the overall state of the national economy being simulated.
%
The left side of Figure \ref{fig:software-structure} visually illustrates this hierarchical structure. 
%
The \code{model} struct is represented as a large rectangle containing nine smaller rectangles, corresponding to the seven agent classes and the two supplementary objects, \code{prop} and \code{agg}.

\noindent \textbf{Inspection.}
%
After a model is created as described above, its attributes can be inspected at any time using the common `dot' notation. 
%
For example, the latest value of the policy rate can be printed using \code{println(model.cb.rate)}, as illustrated in Figure~\ref{fig:software-structure}.
%
This feature can be especially convenient in interactive scripts or Jupyter notebooks to quickly verify the effects of specific code changes or interventions in the model.

\noindent \textbf{Simulation.}
%
Once a model is created using the appropriate function, a simulation can be executed with a single line of code by calling the function \code{run!}.
%
This function takes the model object as input and returns the data collected during the simulation run in a \code{data} object.
%
Note that, in Julia, the exclamation mark at the end of a function denotes a function that changes its arguments in-place.
%
In this case, \code{run!} changes the model in-place, and hence the \code{model} object after the call stores the final state of the model.
%
The \code{data} object has well-documented, intuitively named attributes, such as \code{nominal\_gdp} or \code{real\_household\_consumption}.
%
By default, 25 variables are tracked, but the set can be expanded by customising the data tracker.
%
All variables in the \code{data} object can be inspected using dot notation, for example, by calling \code{plot(data.real\_gdp)}.
%
It is also worth noting that the function for running a single simulation includes a keyword argument, \code{multi\_threading}, which defaults to \code{false}.
%
This option allows the consumption goods market for different industrial sectors to run on separate threads.
%
The code will utilise as many threads as are available to the Julia session.
%
It is also straightforward to run a large number of Monte Carlo repetitions of the same simulation using the function \code{ensemblerun}.
%
This function takes the model and the number of runs as input and returns a vector of data objects that can also be inspected using dot notation.
%
A keyword parameter, \code{multi\_threading}, is available also for this function and defaults to \code{true}.
%
The multi-threading option here is more efficient than the intra-model multi-threading across industrial sectors, as the threads operate on independent runs.

\noindent \textbf{Modularity.}
%
The right-hand side of Figure~\ref{fig:software-structure} illustrates the inner workings of the model runs.
%
Specifically, the figure shows that the \code{run!} function is essentially a simple for loop over a desired number of quarters, \code{T}, of the function \code{step!}, combined with a function to update the data tracker with the latest model data.
%
The figure also presents an excerpt from \code{step!}, highlighting how the main simulation loop consists of a sequence of very readable functions.
%
Each function takes as input the agent type performing the corresponding action, as well as the entire model, allowing the agent type to interact with it, and returns the updated value of specific attributes.
%
For example, by this convention, we have that \code{bank\_profits} takes \code{bank} and \code{model} as input and returns the updated bank profits, which are then assigned to the attribute \code{bank.Pi\_k}.
%
This clear modular structure allows for precise changes and extensions to the model by simply redefining specific functions.


\begin{figure*}[ht]
\centering
\includegraphics[width=0.9\linewidth]{figures/benchmark_w_Matlab.png}
\caption{{\bf A benchmark of the computational efficiency of different implementations.} 
%
The figure shows the mean time to run one step of the model calibrated on the Austrian economy with around 8 thousand agents and 8 million agents using the original Matlab code, the C code generated by the Matlab Coder toolkit, the HPC implementation and \beforeit{}. The benchmarks were executed on Linux x86\_64 with an AMD Ryzen 5 5600H CPU and 16 GB of RAM, except for the HPC results, which were only estimated by using the timings in \cite{gill2021high}.
%
}
\label{fig:speed}
\end{figure*}

\begin{figure*}[ht]
\begin{minipage}[b]{0.4\linewidth}
\centering
    \begin{jllisting}[language=julia, style=mystyle]
    import BeforeIT as Bit
    import Plots

    # load parameters
    p = Bit.AUSTRIA2010Q1.parameters
    ic = Bit.AUSTRIA2010Q1.initial_conditions

    # define a simulation length
    T = 20

    # initialise a model object
    model = Bit.init_model(p, ic, T)

    # run a number of simulations in parallel
    data_vector = Bit.ensemblerun(model, 8)

    # plot the results
    plots = Bit.plot_data_vector(data_vector)
    Plots.plot(plots...)
    \end{jllisting}
\end{minipage}
\hspace{0.2cm}
\begin{minipage}[b]{0.6\linewidth}
\centering
\includegraphics[width=\textwidth]{figures/output_2.png}
\end{minipage}
\caption{{\bf A simple script and its resulting graphs.}
\label{fig:simple_script}
%
The left panel shows how to run the model with just a few lines of code.
%
We import the package, load the original parametrisation for Austria in the first quarter of 2010, and specify a given number of quarters to simulate.
%
Then we call the \code{init\_model} function and then the  \code{ensemblerun} function, specifying 8 Monte Carlo runs.
%
Some of the results contained in the resulting \code{data\_vector} are provided on the right panel.
}
\end{figure*}

\noindent \textbf{Speed.}
%
In addition to being easy to use and extend, \beforeit{} is highly computationally efficient. 
%
In Figure~\ref{fig:speed} we show the efficiency of the software by benchmarking the mean time required to run the model of Austria in scale 1:1000, hence simulating around 8000 agents, and the model in scale 1:1, with around 8 million agents, for one step against the Matlab implementation, the C implementation generated with the Matlab-Coder toolbox and the HPC model developed in \cite{gill2021high}.
%
Our tests show that \beforeit{} is approximately 17 times faster than the Matlab implementation and 4 times faster than the Matlab-generated C code for the small version in the single-threaded case and, respectively, 35 times and 10 times faster when 8 million agents are simulated. 
%
Our single-threaded simulation appears to have a better runtime performance in respect to the HPC implementation of the model by looking at the running times reported in the original article \cite{gill2021high}. 
%
However, given the unavailability of the source code and the different execution environments, we cannot measure the exact speed-up.
%
The efficiency of \beforeit{} is largely due to Julia's just-in-time compilation, which enables a performance comparable to C while making the code significantly easier to develop, maintain and understand \cite{sells2020julia,hunold2020benchmarking,lin2021comparing}.
%
Additional performance gains are achieved by employing more optimized algorithms than those used in the original Matlab version. 
%
The greatest part of the performance improvement was made possible by employing a state-of-the-art dynamic weighted sampling method \cite{slepoy2008,d2022dynamic}, which allows to simulate the market exchange process for goods much more efficiently.
%
Notably, even without the use of such advanced algorithms, our software proved to be approximately on par with the C implementation.
%
The figure also illustrates that applying multi-threading across different industrial sectors can further accelerate the simulation, albeit the speed-up is sub-linear relative to the number of cores employed; even if we believe this aspect could be improved in the future, the scalability of the HPC implementation is still better than what BeforeIT.jl currently achieves.
%
However, when parallelizing over different independent Monte Carlo runs, BeforeIT.jl offers the best performance, without sacrificing ease of use.

\noindent \textbf{Testing.}
%
\beforeit{} includes a large and expanding suite of \emph{unit tests} to ensure its quality and reliability.
%
The current set of unit tests can be divided into three classes.
%
At the lowest level, we test specific functions representing individual agent actions against the expected behaviour.
%
As an example, we test that the function \code{taylor\_rule} with specific values of input arguments returns the same number that one can compute with pen and paper.
%
At the aggregate level, we test that the code respects several accounting identities. 
%
For instance, we check that the national income identity holds after every step, i.e., that the GDP equals the sum of all expenditures.
%
Finally, at the model level, we test that a deterministic version of the model exactly matches the detailed behaviour of a deterministic version of the original Matlab code.
%
Additionally, stochastic versions of the two models are rigorously tested for coherence through statistical analysis.

These layers of tests are run automatically through GitHub's continuous integration workflows every time the code is modified to collectively ensure both the accuracy and robustness of the software.


\noindent \textbf{Documentation.}
%
\beforeit{} is thoroughly documented.
%
The documentation for the main functions governing the inner workings of the package and of the agents in the model is embedded in the source code and it also forms an API reference available at \url{https://bancaditalia.github.io/BeforeIT.jl}.
%
The webpage provided also includes several tutorials to quickly learn how to use the package with a hands-on approach.
%
The source code reported in the online tutorials is available in the ``examples'' folder of the GitHub repository along with other example usages.



\section{Usage illustration}
\label{sec:usage-illustration}

Here, we present some illustrative examples of how to use the package.

\noindent \textbf{Essential usage.}
%
Figure~\ref{fig:simple_script} provides a step-by-step example of typical usage of the package.
%
The left-hand side outlines the exact commands required to load the package, initialise a model, run different Monte Carlo runs of the model, and then inspect the results. 
%
The right-hand side presents a few plots of the simulation runs, with the shaded area indicating the standard error on the mean of the Monte Carlo repetitions.

\begin{figure*}[!h]
    \begin{minipage}[t]{0.4\linewidth}
    \begin{jllisting}[language=julia, style=mystyle]
    # define custom attributes for the shock
    struct ConsumptionShock <: Bit.AbstractShock
        multiplier::Float64
        final_time::Int
    end

    # define an action to shock on the model
    function (s::ConsumptionShock)(model)
        if model.agg.t == 1
            model.prop.psi *= s.multiplier
        elseif model.agg.t == s.final_time
            model.prop.psi /= s.multiplier
        end
    end
    
    # define a specific shock
    my_shock = ConsumptionShock(1.02, 4) 

    # initialise and run the shocked model
    model = Bit.init_model(p, ic, T)
    data_vec = Bit.ensemblerun(model, 512; shock = my_shock)
    \end{jllisting}
    \centering
    \includegraphics[width=0.65\textwidth]{figures/gdp_shock.png}
    \end{minipage}
    \hspace{0.15cm}
    \begin{minipage}[t]{0.58\linewidth}
    \begin{jllisting}[language=julia, style=mystyle]
    # define a central bank object with extra attributes
    mutable struct NewCentralBank <: Bit.AbstractCentralBank
        Bit.@centralBank
        fixed_rate::Float64
    end
    # change the default central bank behaviour
    function central_bank_rate(cb::NewCentralBank, model)
        return fixed_rate
    end
    
    # initialise all agent types 
    properties = Bit.init_properties(p, T)
    firms, _ = Bit.init_firms(p, ic)
    w_act, w_inact, V_i_new, _, _ = Bit.init_workers(p, ic, firms)
    firms.V_i = V_i_new
    bank, _ = Bit.init_bank(p, ic, firms)
    government, _ = Bit.init_government(p, ic)
    rotw, _ = Bit.init_rotw(p, ic)
    agg, _ = Bit.init_aggregates(p, ic, T)
    
    # define the custom central bank
    _, args = Bit.init_central_bank(p, ic)
    central_bank = NewCentralBank(args..., 0.02)
    
    # define model
    model = Bit.Model(w_act, w_inact, firms, bank, central_bank, government, rotw, agg, properties)
    # adjust accounting
    Bit.update_variables_with_totals!(model)
    
    # run a simulation
    data_vec = Bit.ensemblerun(model, 8)
    \end{jllisting}
    \end{minipage}
\caption{{\bf Scripts for shocks and for extensions.}
%
The left-hand side script illustrates the usage of the interface to run simulations with shocks.
%
In essence, one simply needs to define a callable struct and pass it to the function \code{ensemblerun} as the \code{shock} keyword argument.
%
The effect of the simulated consumption shock on the GDP (ratio of shocked over baseline) is presented in the graph at the bottom.
%
The right-hand side script illustrates the usage of macros to extend the model without needing to copy-paste code.
%
In essence, one can create a new \code{mutable struct} for a custom central bank as a subtype of \code{AbstractCentralBank} and inherit all standard attributes using the \code{@centralBank} macro.
%
Then, one can modify specific behaviours by re-defining some functions for \code{cb::NewCentralBank}, the other functions will remain unchanged.
}
\label{fig:shock}
\end{figure*}

\noindent \textbf{Shocked simulations.}
%
We also provide a high-level interface for simulating arbitrary economic shocks to the model. 
%
This functionality is achieved through a ``shock'' object, implemented as a callable struct.

At the beginning of every step, and before agents' actions, the shock object is invoked.
%
The shock object receives the entire model as input, enabling it to modify any model attribute in-place in a highly flexible manner. 
%
The left panel of Figure~\ref{fig:shock} illustrates this process with an example of a consumption shock.
%
In the figure, we first create a struct with two attributes.
%
Then we make the struct ``callable'' by defining a function on top of the struct. 
%
The function increases the propensity to consume \code{psi} by the factor \code{multiplier} until the simulation time \code{model.agg.t} reaches \code{final\_time}, when it is set back to the original level.
%
Finally, a specific shock (\code{my\_shock}) is instantiated with a 2\% increase in the propensity to consume for 4 quarters.
%
This shock is then passed as a keyword argument to the function \code{ensemblerun}.
%
By default, the keyword argument is set to a dummy ``NoShock'' struct that performs no actions.
%
This abstraction allows for arbitrary complex shocks to be implemented straightforwardly since both the state of the model and any of its parameters are accessible as attributes of the \code{model} object and can be easily manipulated. 
%


\noindent \textbf{Extensions.}
%
We include in \beforeit{} specific macros that allow for easily extending the original agent classes without copying and pasting the entire codebase.
%
In the right panel of Figure~\ref{fig:shock} we provide an example of how to leverage these macros.
%
Suppose we want to extend the model by introducing a new type of central bank with custom behaviour.
%
We do this by creating a custom struct called \code{NewCentralBank}.
%
Crucially, we define this to be a subtype of \code{AbstractCentralBank}.
%
This allows the new struct to seamlessly inherit all existing functions defined in \beforeit{} for central banks.
%

In our new struct we want to inherit all existing attributes of the standard central banks in the package and add additional attributes.
%
We do this using the macro \code{@centralBank}, which essentially copy-pastes all the standard attributes within the newly created object.
%
Additional attributes can then be defined as needed.
%
Finally, we customise the behaviour of the central bank by defining a new \code{central\_bank\_rate} function.
%
In this function, we specify that \code{cb} is of type \code{NewCentralBank}.
%
In this way, through Julia's powerful multiple-dispatch mechanism, the compiled code will use this function instead of the default one, and will instead use the default functions for any other behaviours of the central bank as provided in the package implementation.

% This is to simplify the creation of new agents that will work seamlessly with existing functions. 
% %
% One is then expected to use multiple-dispatch in order to change only the behaviour they are interest in. 
%
% To showcase this on a simplified example consider again the central bank that has a fixed interest rate for the first 5 periods. 
% %
% In this case one can also do what shown in ...

Now what is left is to change the initialisation of the model by allowing our new object to appear.
%
To do so, we explicitly initialise each agent type and overwrite the default central bank with our extended object.

% - Advanced data collection ?  (i.e. extend the data collection with custom data?)

\section{Conclusions}
\label{sec:conclusions}

This paper introduces \beforeit{}, a software package to build state-of-the-art macoeconomic agent-based models (macro ABMs) that are based on the recently introduced \modelname{} \cite{poledna2023economic}, in a fast, user-friendly, and extensible framework. 
%
By leveraging the computational efficiency and flexibility of the Julia programming language, \beforeit{} delivers high-performance code that is greatly superior, e.g., to existing implementations of the \modelname{}, such as Matlab or Matlab-generated C code, while maintaining simplicity for users and developers.
%
Its modular structure, thorough documentation, and extensive testing ensure that the package can be easily picked up and used for applications ranging from policy analysis and economic forecasting to any model extension.
%
As the first open-source package to build models like \cite{poledna2023economic}, \beforeit{} fills an important gap in making the latest macro ABMs more accessible.
%
We believe the package can greatly facilitate experimentation, e.g., involving calibration using large volumes of data, or extensive sensitivity analyses and forecasting. 
%
The existing open-source Julia ecosystem for data science and numerical simulation can be of great help for these projects.
%
The Python open-source ecosystem could be equally leveraged as it is possible to bridge the two languages seamlessly using libraries such as PythonCall and JuliaCall \cite{pycall_juliacall}.
%
Most generally, \beforeit{} can contribute to the foundation of the next-generation tools for macro ABM research.

We foresee several lines of development that could further enhance \beforeit{}. 
%
One important enhancement is the modularisation and standardisation of the calibration scripts.
%
Differently from the rest of the package, these are not modularly written and currently come in the form of an unpolished research prototype. 
%
However, they could be easily improved and, potentially, even be adapted to make them work for any European nation. 
%
The resulting code could be integrated within \beforeit{} or be released as a dedicated companion package.
%
A second line of development would involve the inclusion in the package of other models that were built on top of the \modelname{}.
%
For example, it should be straightforward to include the so-called `CANVAS' model, built by the Bank of Canada, by appropriately adjusting the behaviour of specific agents as described in the corresponding publication.
%
Finally, it would be interesting to endow the package with automatic differentiation.
%
Automatic differentiation is available in Julia through several libraries and the inclusion in \beforeit{} is certainly possible by appropriately extending functions in the code that are non-smooth.
%
This, in turn, would enable the possibility to perform sensitivity analysis just by looking at the gradient of the model output, and it could help in calibrating the model to aggregate output data if deemed necessary or useful.

For any of the mentioned extensions or any other improvement to the package, we greatly encourage open-source contributions to the project in the form of issues, pull requests or feedback.


\section*{Acknowledgments}
%
AG would like to thank the following colleagues from Banca d'Italia: Marco Benedetti, Claudia Biancotti and Marco Favorito for their continuous help, support and feedback on the project, Andrea Gentili and Sara Corbo respectively for their help on the design of the package's name and logo.
%
The authors thank Claudia Biancotti (Banca d'Italia), Pietro Terna (University of Turin) and Marco Pangallo (CENTAI institute) for early feedback on the manuscript.
%
SP acknowledges funding from the Vienna Science and Technology Fund (WWTF) (grant number ESS22-040).
%
The views and opinions expressed in this paper are those of the authors and do not necessarily reflect the official policy or position of Banca d’Italia.


\balance

\bibliographystyle{elsarticle-num}

\bibliography{refs}



\end{document}

%%
%% End of file 