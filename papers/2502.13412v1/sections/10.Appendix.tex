\clearpage

\section*{APPENDIX}\label{sec: appendix}

This section provides supplementary materials, including detailed prompt designs, parameter settings for our method, and the KG schemas generated by different methods.

\subsection{Prompt Design for Our Method}
All prompts in this paper use a structured design~\cite{xing2025when}. 
Taking Fig.~\ref{fig: ee} as an example, it has three top-level parts: @Persona (which defines the identity and function of LLM), @ContextControl (which sets behavior constraints for LLM), and @Instruction (which provides operation instructions for LLM).

\begin{figure}[h]  % 使用 [H] 强制图片放置在当前位置
    \centering
    \includegraphics[width=1.0\linewidth]{materials/prompts/prompt_entity_extraction.pdf}
    \caption{Prompt for Entity Extraction Unit.}
    \label{fig: ee}
\end{figure}

Among them, Persona contains two sub-parts: 
\begin{itemize}
\item @Description: describes the task objective: (such as ``You are an intelligent API entity extractor...'');
\item @Terminology: describes technical terms: (such as ``Terms API entity...'').
\end{itemize}

@ContextControl contains several @Rules that limit the behavior in the context, e.g., ``Ensure your output is concise...''; 

@Instruction contains five sub-parts:
\begin{itemize}
\item @InputVariable: describes the input of prompt (such as ``text'' here);
\item @Commands: clarifies the execution steps of the LLM, such as ``Based on the definition of API entity terminology, extract the API entities...'';
\item @OutputVariable describes the input of prompt (such as `entities'' here);
\item @Rules: emphasizes the notices when LLM executes the command, such as ``The part of speech for API entities...'', this rule can effectively avoid the common word ambiguity of API entities~\cite{yanbang1}, for example, print'' may be a verb or refer to java.io.printwriter.print();
\item @Example: It is used to help understand the requirements of the task and clarify the output specifications.
\end{itemize}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\linewidth]{materials/prompts/prompt_relation_extraction.pdf}
    \caption{Prompt for Relation Extraction Unit.}
    \label{fig: re}
\end{figure}

\begin{figure}[h]
    \centering
    \includegraphics[width=1.0\linewidth]{materials/prompts/prompt_entity_type_labeling.pdf}
    \caption{Prompt for Entity Type Labeling Unit.}
    \label{fig: etl}
\end{figure}

\clearpage

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\linewidth]{materials/prompts/prompt_entity_type_fusion.pdf}
    \caption{Prompt for Entity Type Fusion Unit.}
    \label{fig: etf}
\end{figure}

\begin{figure}[htbp]
    \centering
    \includegraphics[width=0.95\linewidth]{materials/prompts/prompt_relation_type_fusion.pdf}
    \caption{Prompt for Relation Type Fusion Unit.}
    \label{fig: rtf}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\linewidth]{materials/prompts/prompt_guided_entity_extraction.pdf}
    \caption{Prompt for Schema-guided Entity Extraction Unit.}
    \label{fig: see}
\end{figure}

\begin{figure}[H]
    \centering
    \includegraphics[width=0.9\linewidth]{materials/prompts/prompt_guided_relation_extraction.pdf}
    \caption{Prompt for Schema-guided Relation Extraction Unit.}
    \label{fig: sre}
\end{figure}

\clearpage
\subsection{Parameter Setting}\label{sec: paramterset}
In this paper, we implement our method and baselines by calling GPT-4o.
It is the latest model of OpenAI, which has outstanding text understanding capabilities and can perform relatively complex inference tasks~\cite{GPT4oAnalysis-1}.
When calling the LLM, some parameters usually need to be set, including temperature, max\_tokens, n, frequency\_penalty, and presence\_penalty.
Among them, temperature is used to control the randomness of the generated text.
To ensure the stability of our method, we set it to 0 so that the LLM can generate more deterministic results. 
Max\_tokens is used to specify the maximum length of the generated result. 
Since the result lengths output by different units are different, max\_tokens has no fixed value. 
For example, the max\_tokens of the entity extraction unit is set to 128; 
while for the entity type fusion unit and the relation type fusion unit, the max\_token is set to 4096. 
The parameter n represents the number of generated results and is set to 1. 
In addition, frequency\_penalty and presence\_penalty are used to control the coherence of the generated text, and they are kept as the default values (0).

\subsection{The KG Schema Generated by Each Method}\label{section: newrel}
In this section, we will introduce the KG schema generated by each method.
First, Table~\ref{tab: reldetail} presents the 13 relation types generated by our method, 8 of which overlap with the relation types in the existing MKC method~\cite{Manual}.
For example, equivalence and function similarity both indicate that entities are similar or equal in functionality.
Since the occurrence frequency of the relation type``function opposite'' in MKC is low, our method filters it out.
However, we also discover five unique relation types, including: 
\begin{itemize}
\item Containment: It indicates that one entity contains another entity within it.
For example, \textit{SortedMap} contains \textit{headMap()}.
\item Modification: It means that One entity alters or modifies another entity.
For instance, \textit{remove()} can modify the elements in a \textit{SortedSet}.
\item Execution: It represents that one entity initiates or carries out the operation of another entity.
For example, execute \textit{lock()} to close the \textit{Lock} instance.
\item Access: It implies that one entity retrieves or acquires data from another entity.
For example, \textit{readInt()} reads data from a \textit{DataInputStream}.
\item Limitation: It signifies that one entity imposes constraints on another entity’s behavior or
functionality.
For example, the output of \textit{add()} is limited by the state of the \textit{BlockingQueue}.
\end{itemize}
These new relations types form the foundation for constructing a comprehensive API KG.

Table~\ref{tab: existing schemas} compares the differences in type information between existing methods and our method.
GraphRAG~\cite{GraphRAG} and EDC~\cite{EDC} are schema-free methods, with the former lacking relations types (e.g., the type triple (class, null, class)) and the latter lacking entity types (e.g., the type triple (null, check, null)).
In contrast, MKC defines 3 entity types (package, class, method) and 9 relations types, while our method defines 4 entity types (package, class, method, interface) and 13 relation types, resulting in 34 type triples (including 26 correct type triples).
This ensures the comprehensiveness and richness of the KG.
Although the EDC method can refine relation types, there is still redundancy in the final relation types, which can be further optimized.
For example, the relation types such as ``checks'', ``precedes'', and ``test'' have similar semantics and can be further merged.
In contrast, our method can abstract low-dimensional relation types into high-dimensional ones, avoiding such semantic redundancy.

Table~\ref{tab: schema2} shows the KG schemas designed by different variant methods.
Due to Our$_{\text{w/oKE}}$ adopts the schema of MKC, which only contains 3 entity types and 9 relation types, resulting in 9 type triples.
Our$_{\text{w/oKF}}$'s entity and relations types align with ours, but due to the lack of the KG filtering module, it includes 208 type triples, only 31 of which are valid, making the constructed KG unreliable.
Our$_{\text{w/oFC}}$, although consistent with our entity and relation types, lacks a full-connectivity strategy, resulting in only 20 type triples (including 18 correct type triples), making it impossible to construct a comprehensive and rich KG.

Table~\ref{tab: schema3} demonstrates the comparison of the KG schemas designed based on different models.
The results show that while all methods discover the same number of entity and relation types, the knowledge extraction differences lead to discrepancies.
Our$_{\text{Llama}}$ retains 30 type triples, but only 20 of them are correct.
Our$_{\text{Claude}}$ retains 32 type triples, with 23 being correct.
As a result, the KGs constructed by these methods are slightly less rich and reliable compared to the KG constructed by our method.

\clearpage

\begin{table*}[h]
\centering
\caption{The Details of the Relation Types in Our KG Schema.}
\begin{tabularx}{\textwidth}{@{}c|>{\centering\arraybackslash}X|>{\centering\arraybackslash}X@{}}
\hline
Type & Definition & Example \\ \hline
\begin{tabular}[c]{@{}c@{}}Equivalence (function similarity)\end{tabular} & One entity is equal or very similar to another entity in functionality. & The offerLast() method adds an element to the end of the Deque, just like offer(). \\ \hline
\begin{tabular}[c]{@{}c@{}}Difference (behavior difference)\end{tabular} & One entity is different from another, typically in behavior or characteristics. & The add() and offer() methods behave differently when the queue is full. \\ \hline
\begin{tabular}[c]{@{}c@{}}Replacement (function replace)\end{tabular} & One entity can substitute another in certain contexts without changing the expected result. & In many cases, you can replace the File class with the Path interface. \\ \hline
\begin{tabular}[c]{@{}c@{}}Preference (efficiency comparison)\end{tabular} & One entity is favored over another due to efficiency or ease of use in a specific context. & BufferedInputStream is faster than reading single bytes from an InputStream... \\ \hline
\begin{tabular}[c]{@{}c@{}}Dependency (logic constraint)\end{tabular} & One entity depends on another for its functionality or operation. & Collections.sort() relies on Arrays.asList() to sort array elements when more complex sorting is required. \\ \hline
\begin{tabular}[c]{@{}c@{}}Implementation (implement constraint)\end{tabular} & One entity provides a concrete realization or behavior for another entity. & The PoolThreadRunnable class implements the Runnable interface, allowing it to be executed by a thread. \\ \hline
\begin{tabular}[c]{@{}c@{}}Collaboration (function collaboration)\end{tabular} & One entity communicates or works with another entity to complete a specific task. & To set a date on a PreparedStatement or get a date from a ResultSet, you interact with java.sql.Date. \\ \hline
\begin{tabular}[c]{@{}c@{}}Conversion (type conversion)\end{tabular} & One entity is transformed into another entity or format. & You can convert a Set to a List by passing the Set to the addAll() method of a new List. \\ \hline
Containment & One entity contains another entity within it. & The headMap() method of SortedMap returns a new map containing the first elements of the original map. \\ \hline
Modification & One entity alters or modifies another entity. & To remove an element from a SortedSet, you call its remove() method, passing the element to be removed. \\ \hline
Execution & One entity initiates or carries out the operation of another entity. & To lock the Lock instance, you must call its lock() method. \\ \hline
Access & One entity retrieves or acquires data from another entity. & You can read data from a DataInputStream using its readInt() method. \\ \hline
Limitation & One entity imposes constraints on another entity's behavior or functionality. & If the BlockingQueue does not have space for a new element, the add() method throws an IllegalStateException. \\ \hline
\end{tabularx}
\label{tab: reldetail}
\end{table*}

\clearpage


\begin{table*}[t]
\centering
\rotatebox{270}{% 旋转整个表格和标题
\begin{minipage}{\textheight}
  \caption{Comparison of Type Information between the Existing Method and Our Method}
  \label{tab: existing schemas}
  \resizebox{1.0\textheight}{!}{%
    \begin{tabular}{c|cc|cc|cc|cc}
    \hline
    \multirow{2}{*}{Category} &
      \multicolumn{2}{c|}{MKC} &
      \multicolumn{2}{c|}{GraphRAG} &
      \multicolumn{2}{c|}{EDC} &
      \multicolumn{2}{c}{Our} \\ \cline{2-9} 
     &
      \multicolumn{1}{c|}{Number} &
      Content &
      \multicolumn{1}{c|}{Number} &
      Content &
      \multicolumn{1}{c|}{Number} &
      Content &
      \multicolumn{1}{c|}{Number} &
      Content \\ \hline
    Entity Type &
      \multicolumn{1}{c|}{3} &
      package, class, method &
      \multicolumn{1}{c|}{3} &
      package, class, method &
      \multicolumn{1}{c|}{0} &
      - &
      \multicolumn{1}{c|}{4} &
      package, class, method, interface \\ \hline
    Relation Type &
      \multicolumn{1}{c|}{9} &
      \begin{tabular}[c]{@{}c@{}}efficiency comparison,\\ function collaboration,\\ behavior difference,\\ implement constraint,\\ type conversion,\\ logic constraint,\\ function similarity,\\ function opposite, \\ function replace\end{tabular} &
      \multicolumn{1}{c|}{0} &
      - &
      \multicolumn{1}{c|}{53} &
      \begin{tabular}[c]{@{}c@{}}checks,\\ precedes,\\ test,\\ inspects,\\ is called before,\\ created inside,\\ provides,\\ located in package,\\ uses,\\ operates on\\ ...\end{tabular} &
      \multicolumn{1}{c|}{13} &
      \begin{tabular}[c]{@{}c@{}}preference, \\ collaboration,\\ replacement,\\ difference, \\ implementation, \\ conversion, \\ dependency,\\ equivalence,\\ execution, \\ limitation,\\ containment, \\ access,\\ modification\end{tabular} \\ \hline
    Type Triple &
      \multicolumn{1}{c|}{9} &
      \begin{tabular}[c]{@{}c@{}}(class, efficiency comparison, class),\\ (class, function collaboration, class),\\ (package, contain, class),\\ (method, behavior difference, method),\\ (method, implement constraint, method),\\ (class, type conversion, class),\\ (method, logic constraint, method),\\ (method, function similarity, method),\\ (class, has method, method),\\ (method, function opposite, method),\\ (method, function replace, method)\end{tabular} &
      \multicolumn{1}{c|}{9} &
      \begin{tabular}[c]{@{}c@{}}(class, null, class),\\ (class, null, method),\\ (class, null, package),\\ (method, null, method),\\ (method, null, class),\\ (method, null, package),\\ (package, null, package),\\ (package, null, class),\\ (package, null, method)\end{tabular} &
      \multicolumn{1}{c|}{53} &
      \begin{tabular}[c]{@{}c@{}}(null, check, null),\\ (null, precedes, null),\\ (null, test, null),\\ (null, inspects, null),\\ (null, is called before, null),\\ (null, created inside, null),\\ (null, provides, null),\\ (null, located in package, null),\\ (null, uses, null),\\ ...\end{tabular} &
      \multicolumn{1}{c|}{34} &
      \begin{tabular}[c]{@{}c@{}}(class, preference, class),\\ (class, collaboration, class),\\ (package, containment, class),\\ (method, difference, method),\\ (class, implementation, class),\\ (class, conversion, class),\\ (method, dependency, interface),\\ (class, equivalence, class),\\ (method, execution, method),\\ (method, limitation, method),\\ (method, replacement, method),\\ (class, access, method),\\ (method, modification, class), \\ (class, difference, class),\\ (method, preference, method), \\ ...\end{tabular} \\ \hline
    \end{tabular}
  }
\end{minipage}
}
\end{table*}


\begin{table*}[t]
\centering
\rotatebox{270}{% 旋转整个表格和标题
\begin{minipage}{\textheight}
  \caption{Comparison of KG Schemas between Variant Methods}
  \label{tab: schema2}
  \resizebox{1.0\textheight}{!}{%
    \begin{tabular}{ccccccccc}
    \hline
    \multirow{2}{*}{Category} &
      \multicolumn{2}{c}{Our$_{\text{w/oKE}}$} &
      \multicolumn{2}{c}{Our$_{\text{w/oKF}}$} &
      \multicolumn{2}{c}{Our$_{\text{w/oFC}}$} &
      \multicolumn{2}{c}{Our} \\ \cline{2-9} 
     &
      \multicolumn{1}{c|}{Number} &
      \multicolumn{1}{c|}{Content} &
      \multicolumn{1}{c|}{Number} &
      \multicolumn{1}{c|}{Content} &
      \multicolumn{1}{c|}{Number} &
      \multicolumn{1}{c|}{Content} &
      \multicolumn{1}{c|}{Number} &
      Content \\ \hline
    \multicolumn{1}{c|}{Entity Type} &
      \multicolumn{1}{c|}{3} &
      \multicolumn{1}{c|}{package, class, method} &
      \multicolumn{1}{c|}{4} &
      \multicolumn{1}{c|}{package, class, method, interface} &
      \multicolumn{1}{c|}{4} &
      \multicolumn{1}{c|}{package, class, method, interface} &
      \multicolumn{1}{c|}{4} &
      package, class, method, interface \\ \hline
    \multicolumn{1}{c|}{Relation Type} &
      \multicolumn{1}{c|}{8} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}efficiency comparison,\\ function collaboration,\\ behavior difference,\\ implement constraint,\\ type conversion,\\ logic constraint,\\ function similarity,\\ function replace, \end{tabular}} &
      \multicolumn{1}{c|}{13} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}preference, \\ collaboration,\\ replacement,\\ difference, \\ implementation, \\ conversion, \\ dependency,\\ equivalence,\\ execution, \\ limitation,\\ containment, \\ access,\\ modification\end{tabular}} &
      \multicolumn{1}{c|}{13} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}preference, \\ collaboration,\\ containment,\\ difference, \\ implementation, \\ conversion, \\ dependency,\\ equivalence,\\ execution, \\ limitation,\\ replacement,\\  access,\\ modification\end{tabular}} &
      \multicolumn{1}{c|}{13} &
      \begin{tabular}[c]{@{}c@{}}preference, \\ collaboration,\\ containment,\\ difference, \\ implementation, \\ conversion, \\ dependency,\\ equivalence,\\ execution, \\ limitation,\\ replacement, \\ modification,\\ access\end{tabular} \\ \hline
    \multicolumn{1}{c|}{Type Triple} &
      \multicolumn{1}{c|}{8} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}(class, efficiency comparison, class),\\ (class, function collaboration, class),\\ (package, contain, class),\\ (method, behavior difference, method),\\ (method, implement constraint, method),\\ (class, type conversion, class),\\ (method, logic constraint, method),\\ (method, function similarity, method),\\ (method, function replace, method)\end{tabular}} &
      \multicolumn{1}{c|}{208} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}(class, preference, class),\\ (class, collaboration, class),\\ (package, containment, class),\\ (method, difference, method),\\ (class, implementation, class),\\ (class, conversion, class),\\ (method, dependency, interface),\\ (class, equivalence, class),\\ (method, execution, method),\\ (method, limitation, method),\\ (method, replacement, method),\\ (class, access, method),\\ (method, modification, class), \\ (class, difference, class),\\ (method, preference, method), \\ ...\end{tabular}} &
      \multicolumn{1}{c|}{20} &
      \multicolumn{1}{c|}{\begin{tabular}[c]{@{}c@{}}(class, preference, class),\\ (method, collaboration, method),\\ (package, containment, method),\\ (method, difference, method),\\ (class, implementation, class),\\ (class, conversion, class),\\ (method, dependency, method),\\ (method, equivalence, method),\\ (method, execution, method),\\ (method, limitation, method),\\ (method, replacement, method),\\ (method, modification, class), \\ ...\end{tabular}} &
      \multicolumn{1}{c|}{34} &
      \begin{tabular}[c]{@{}c@{}}(class, preference, class),\\ (class, collaboration, class),\\ (package, containment, class),\\ (method, difference, method),\\ (class, implementation, class),\\ (class, conversion, class),\\ (method, dependency, interface),\\ (class, equivalence, class),\\ (method, execution, method),\\ (method, limitation, method),\\ (method, replacement, method),\\ (class, access, method),\\ (method, modification, class), \\ (class, difference, class),\\ (method, preference, method), \\ ...\end{tabular} \\ \hline
\end{tabular}
  }
\end{minipage}
}
\end{table*}

% Required package: \usepackage{multirow}
\begin{table*}[t]
\centering
\rotatebox{270}{% 旋转整个表格和标题
\begin{minipage}{\textheight}
  \caption{Comparison of KG Schemas across Different Models}
  \label{tab: schema3}
  \resizebox{1.0\textheight}{!}{%
    \begin{tabular}{c|cc|cc|cc}
    \hline
    \multirow{2}{*}{Category} &
      \multicolumn{2}{c|}{Our$_{\text{Llama}}$} &
      \multicolumn{2}{c|}{Our$_{\text{Claude}}$} &
      \multicolumn{2}{c}{Our} \\ \cline{2-7} 
     &
      \multicolumn{1}{c|}{Number} &
      Content &
      \multicolumn{1}{c|}{Number} &
      Content &
      \multicolumn{1}{c|}{Number} &
      Content \\ \hline
    Entity Type &
      \multicolumn{1}{c|}{4} &
      package, class, method, interface &
      \multicolumn{1}{c|}{4} &
      package, class, method, interface &
      \multicolumn{1}{c|}{4} &
      package, class, method, interface \\ \hline
    Relation Type &
      \multicolumn{1}{c|}{13} &
      \begin{tabular}[c]{@{}c@{}}preference, \\ collaboration,\\ containment,\\ difference, \\ implementation, \\ conversion, \\ dependency,\\ equivalence,\\ execution, \\ limitation,\\ replacement, \\ access,\\ modification\end{tabular} &
      \multicolumn{1}{c|}{13} &
      \begin{tabular}[c]{@{}c@{}}preference, \\ collaboration,\\ containment,\\ difference, \\ implementation, \\ conversion, \\ dependency,\\ equivalence,\\ execution, \\ limitation,\\ replacement, \\ access,\\ modification\end{tabular} &
      \multicolumn{1}{c|}{13} &
      \begin{tabular}[c]{@{}c@{}}preference, \\ collaboration,\\ containment,\\ difference, \\ implementation, \\ conversion, \\ dependency,\\ equivalence,\\ execution, \\ limitation,\\ replacement, \\ modification,\\ access\end{tabular} \\ \hline
    Type Triple &
      \multicolumn{1}{c|}{30} &
      \begin{tabular}[c]{@{}c@{}}(class, preference, class),\\ (class, collaboration, class),\\ (package, containment, class),\\ (method, difference, method),\\ (class, implementation, class),\\ (class, conversion, class),\\ (method, dependency, interface),\\ (class, equivalence, class),\\ (method, execution, method),\\ (method, limitation, method),\\ (method, replacement, method),\\ (class, access, method),\\ (method, modification, class), \\ (class, difference, class),\\ (method, preference, method), \\ ...\end{tabular} &
      \multicolumn{1}{c|}{32} &
      \begin{tabular}[c]{@{}c@{}}(class, preference, class),\\ (class, collaboration, class),\\ (package, containment, class),\\ (method, difference, method),\\ (class, implementation, class),\\ (class, conversion, class),\\ (method, dependency, interface),\\ (class, equivalence, class),\\ (method, execution, method),\\ (method, limitation, method),\\ (method, replacement, method),\\ (class, access, method),\\ (method, modification, class), \\ (class, difference, class),\\ (method, preference, method), \\ ...\end{tabular} &
      \multicolumn{1}{c|}{34} &
      \begin{tabular}[c]{@{}c@{}}(class, preference, class),\\ (class, collaboration, class),\\ (package, containment, class),\\ (method, difference, method),\\ (class, implementation, class),\\ (class, conversion, class),\\ (method, dependency, interface),\\ (class, equivalence, class),\\ (method, execution, method),\\ (method, limitation, method),\\ (method, replacement, method),\\ (class, access, method),\\ (method, modification, class), \\ (class, difference, class),\\ (method, preference, method), \\ ...\end{tabular} \\ \hline
\end{tabular}
  }
\end{minipage}
}
\end{table*}