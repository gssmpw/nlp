\section{INTRODUCTION}
Application Programming Interfaces (APIs) are essential in modern software development, enabling seamless interactions between system components \cite{raatikainen2021state, wu2024future, lercher2024microservice}.
Even simple programs, such as ``Hello World,'' rely on at least one API.
However, the vast number of available APIs and their complex interconnections pose significant challenges for developers.
For example, the Java standard library contains over 30,000 APIs, and any two APIs may exhibit as many as 11 distinct types of semantic relations \cite{javaapi, huang2022se}.
In such a complex ecosystem, developers often struggle to choose and use the right APIs.
Take \textit{HashMap} and \textit{Hashtable} as an example:
both store key-value pairs, but \textit{HashMap} is non-thread-safe, while \textit{Hashtable} is thread-safe.
Ignoring these subtle differences can lead developers to choose the wrong API, resulting in inefficient or incorrect implementations.
Therefore, organizing the interconnections between APIs (such as similar usage and different behaviors) into structured API knowledge will enhance developers' ability to make informed API choices.

Previous studies \cite{Manual, Huang2018APIMR, Liu2020GeneratingCB} introduce the concept of an API Knowledge Graph (KG), which organizes and represents the rich semantic information among APIs.
API KGs offer a valuable approach for understanding and leveraging API knowledge in various scenarios. 
For example, in API recommendation tasks~\cite{Liu2023RecommendingAA, Peng2021RevisitingBA, Huang2018APIMR}, when the order of set elements is not required, an API KG can recommend the more efficient \textit{java.util.HashSet} over \textit{java.util.TreeSet}.
This is because the KG not only captures the usage of APIs but also reveals subtle differences between them, enabling more informed and context-aware recommendations.
However, despite their great potential, constructing a knowledge-rich and reliable API KG still faces many challenges

Existing methods for constructing API KGs are predominantly schema-based~\cite{huang2022se, yanbang1, Ren2020APIMisuseDD}.
These methods rely on predefined schemas, including entity types, relation types, and type triples (combinations of entity types and relation types), to guide the extraction of API entities and relations.
For example, Huang et al.~\cite{yanbang1} design a schema that includes 3 entity types, 9 relation types, and 9 type triples by annotating and summarizing the entity types and relation types in API and tutorial documentation, and construct an API KG based on this schema.
However, developing such schemas requires annotators to invest significant time, resulting in high labor costs.
In particular, the more relation types are needed for constructing a rich KG, the more annotated documentation there will be, which further exacerbates the labor costs~\cite{yanbang2}.

In the field of natural language processing, schema-free methods \cite{GraphRAG, EDC, free3, free4} are another mainstream approach for constructing KGs.
Unlike schema-based methods, schema-free methods extract instance triples directly from text, thereby reducing labor costs.
For example, Zhang et al.~\cite{EDC} propose EDC, which utilizes large language models (LLMs) through few-shot prompting to identify and extract instance triples ([subject, relation, object]) from input texts, independent of any specific schema.
However, when these methods are applied to the construction of API KGs, they often introduce noise and reduce the reliability of the KG.
Due to the lack of schema guidance, these methods may extract inaccurate instance triples.
For example, the instance triple (\textit{SortedSet, is a type of, Set}) extracted from the text ``You can add elements to a SortedSet just like you would to a regular Set...'' fails to accurately express the original semantic meaning.
Furthermore, the constructed KG lacks type information, which limits its practicality.
For example, it is impossible to retrieve classes that are similar in usage to the class \textit{SortedSet}.

In summary, both schema-based and schema-free methods face significant challenges in constructing API KGs.
These challenges primarily stem from two aspects: schema-based methods suffer from the high labor costs associated with designing schemas, while schema-free methods struggle due to the absence of schemas during the extraction of API entities and relations.
To address these issues, it is crucial to automate the schema design and construct the API KG based on the generated schema.
Therefore, we propose using large language models (LLMs) to automate the construction of API KGs.
First, LLMs simulate the annotator's workflow in a bottom-up manner, starting by labeling specific types and then abstracting them into high-level types, thus constructing the schema.
Then, based on this schema, the LLM can extract API entities and relations to construct the API KG.
Through pre-training, LLMs store extensive API knowledge and demonstrate excellent capabilities in information extraction~\cite{yanbang1, yanbang2}, making them a promising solution for overcoming these challenges.

Despite the powerful potential of LLMs, they still face challenges when handling multi-step complex reasoning tasks, such as API KG construction.
Especially for KG schema design, which involves several interrelated tasks like entity identification, entity type labeling, and entity type fusion, LLMs struggle to complete these tasks all at once.
To address this, we adopt a Chain-of-Thought (CoT~\cite{cot1, cot2, cot3, yanbang2}) strategy, breaking the KG construction task into simple tasks and sequentially calling the LLM to complete them.
This step-by-step reasoning strategy enhances the LLM's reasoning accuracy, ensuring the construction of a more reliable KG.

However, due to the ``hallucination'' issue of LLMs~\cite{huang2024survey, dhuliawala2023chain}, their performance may not be reliable for data processing tasks that require high precision, such as collecting all identified relations.
To address this, we introduce a hybrid execution strategy.
Specifically, we implement non-AI units through coding to handle tasks that require high precision, while the AI units, driven by LLMs, focus on reasoning tasks.
These units are logically organized into an AI chain, ensuring that each task in the KG construction is effectively performed.
% To further improve the accuracy of LLM reasoning, we apply structured prompts within each AI unit~\cite{xing2025when}.
% Through these strategies, we fully leverage the potential of LLMs to construct API KGs.

To ensure the comprehensiveness of the KG, we adopt a fully connected strategy to construct a KG schema with diverse type triples.
Specifically, all entity types and relation types are combined to generate as many potential type triples as possible.
For example, entity types $ET_1$, $ET_2$, and relation type $RT_1$ can be combined into two type triples: ($ET_1$, $RT_1$, $ET_2$) and ($ET_2$, $RT_1$, $ET_1$).
However, due to the absence of manual verification, the KG schema generated by LLMs may not fully align with expert judgment, potentially introducing invalid type triples that result in suspicious instance triples.
For example, the type triple (\textit{class}, \textit{dependency}, \textit{method}) is invalid because, class dependencies typically point to other classes or interfaces, not specific methods~\cite{martin2000design}.
This leads to suspicious instance triples like (\textit{FileWriter}, \textit{relies on}, \textit{flush()}).
Therefore, we apply association rules to the construction of the KG.
By calculating the association strength (using \textit{Support}, \textit{Confidence}, and \textit{Lift} as measurement metrics) between entity types and relation types within the type triples, we can remove invalid triples that fall below the predefined thresholds for each metric, thereby filtering out suspicious instance triples to ensure the reliability of the API KG.

In conclusion, our framework consists of three key modules: KG exploration, KG construction, and KG filtering.
Specifically, the KG exploration module generates potential KG schemas, containing comprehensive entity types, relation types, and type triples.
The KG construction module extracts API entities and relations based on the schema, constructing a rich but unreliable KG.
Finally, the KG filtering module removes invalid type triples and suspicious instance triples, resulting in a rich and reliable  KG.
Among these, both the KG exploration and KG construction modules contain both AI and non-AI units.
For example, the KG exploration module includes the AI unit for entity type labeling and the non-AI unit for fully connected KG schema generation.
To ensure the reliability of the filtered KG, the KG filtering module is composed entirely of non-AI units, including the KG schema update unit and the KG update unit.

We systematically conduct experiments to evaluate our methodâ€™s performance.
First, we determine the most balanced thresholds for the KG filtering module, with \textit{Support}, \textit{Confidence}, and \textit{Lift} set to 0.005, 0.02, and 1.0, respectively. 
This configuration achieves a type triple accuracy of 0.76 and retains 26 valid type triples.
Second, our method significantly outperforms the state-of-the-art EDC~\cite{EDC}, achieving an F1 improvement of 25.2\% for API KG construction.
Moreover, the explore-construct-filter framework proves effective: the KG exploration module enhances the richness of KG by 133.6\%, the KG filtering module improves the reliability of the KG by 26.6\%, and the fully connected strategy increases the comprehensiveness of the KG by 33.5\%.
Finally, experiments across different LLMs (GPT-4, Llama, and Claude) demonstrate that our method exhibits strong generalizability.

In this paper, we make the following contributions:
\begin{itemize}[leftmargin=*]
    \item 
    Conceptually, we propose a method for automatically constructing an API KG.
    This method simulates the workflow of manual annotators using LLMs, automatically designs the KG schema, and then constructs the API KG. This method reduces the manual effort required to design the schema and enhances the efficiency of KG construction.
    \item
    Methodologically, we design the ``Explore-Construct-Filter'' framework to achieve this automation goal.
    The framework leverages LLMs to discover diverse entity types, relation types, and type triples, then extracts instance triples to construct a comprehensive KG.
    Through a filtering mechanism, the framework removes suspicious instance triples, ensuring that the constructed KG is both comprehensive and reliable.
    \item
    Technologically, we introduce a CoT strategy, which improves LLM's accuracy through step-by-step reasoning.
    Moreover, we adopt a hybrid execution strategy to ensure that each task is performed efficiently.
\end{itemize}


    % \item 
    % Experimentally, experimental results demonstrate that the proposed method significantly outperforms existing methods.
    % The designed strategies effectively enhance the overall performance, and the method exhibits strong cross-model generalizability.
    % Our code and data can be found here~\cite{data}.