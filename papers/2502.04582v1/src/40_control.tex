
\begin{figure}[tb]
    \centering
    \input{figures/block_diagram/block_diagram.tex}
    \caption{Control system overview and generalized coordinates.}
    \label{fig:controlsystem}
\end{figure}

This section details the control methods on the Mini Wheelbot, as visualized in~Fig.~\ref{fig:controlsystem}, that we later use in illustrative learning tasks in Sec.~\ref{sec:lbcexperiments}.
To this end, we first describe the system model (Sec.~\ref{sec:systemmodel}) and optimization-based identification of parameters from trajectory data (Sec.~\ref{sec:parameteridentification}), before introducing 
the state-feedback controller used for balancing (Sec.~\ref{sec:statefeedback}), and a nonlinear model-predictive controller for the orientation of the robot that is required for meaningful driving (Sec.~\ref{sec:nonlinearmpc}).
Finally, the stand-up in the roll and pitch direction and a half-flip are described (Sec.~\ref{sec:standup} and \ref{sec:flip}).
All implementations are available online\footnotemark[1].

We omit a detailed description on the estimation of the robots state, as we implement the existing method from~\cite{geist2022wheelbot} to fuse four gyroscope\footnote{Using corrected gyroscope measurement equations from the errata of~\cite{geist2022wheelbot}.}~$\omega_\text{B,i}$, four accelerometer~$a_\text{B,i}$, and two wheel encoder~$q_\text{D,R}$ measurements~(cf.~\cite{trimpe2010accelerometer,trimpe2012balancing,gajamohan2012cubli,muehlebach2016nonlinear} for details). Notably, the presented controllers are robust to alignment errors of the IMUs thus no calibration is needed.

\subsection{System Model}
\label{sec:systemmodel}
The Mini Wheelbot's state can be described as~$x~=~[\psi,\phi,\theta,\dot{\psi},\dot{\phi},\dot{\theta},q_\text{D}, q_\text{R}, \dot{q}_\text{D}, \dot{q}_\text{R}]^\top$.
The body orientation is expressed in Euler-like angles in yaw-roll-pitch order (see Fig.~\ref{fig:controlsystem}) with yaw~$\psi$ and roll~$\phi$ around the contact point coordinate system's~$\mathcal{C}_\text{z}$ axis and resulting~$\mathcal{C}^\prime_\text{x}$ axis, and pitch~$\theta$ around the drive motors axis of rotation that is aligned with~$\mathcal{D}_\text{y}$.
The angles of the wheels are~$q_\text{D,R}$ and the actions~$u~=~[\tau_\text{D}, \tau_\text{R}]^\top$ are the torques applied to driving~(bottom) and the reaction~(top) wheel.
The Mini Wheelbot's nonlinear, continuous-time dynamics of implicit form~$f_\text{ct}(x,\dot{x}, u, p)=0$ with parameters~$p$ can be derived using standard, multi-body methods~(e.g.,  Euler-Lagrange equations).
A detailed symbolic derivation using a computer algebra system is given in the supplementary code\footnotemark[1] and described in detail in~\cite{daud2017dynamic}.
The resulting differential equations have the form:
\begin{align}\label{eqn:eqnofmotion}
    \begin{split}M(\phi,\theta,p)&[\ddot{\phi},\ddot{\theta},\ddot{\psi}, \ddot{q}_\text{D}, \ddot{q}_\text{R}]^\top + b(\phi, \theta, \dot{\psi}, \dot{\phi}, \dot{\theta}, \dot{q}_\text{D}, \dot{q}_\text{R},p) \\ &+ g(\phi, \theta, \tau_\text{D}, \tau_\text{R},p)+\tau_{\psi}(\dot{\psi},p)= 0.
    \end{split}
\end{align}
The implicit dynamics~(\ref{eqn:eqnofmotion}) are parameterized by $p~=~[m_\text{D,R}, m_{B}, I_{\text{D}_\text{x,z}\text{,R}_\text{y,z}}, I_{\text{D}_\text{y}\text{,R}_\text{x}},
I_\text{B},
r_\text{D,R},
l_\text{D,R},
C_1, C_2]\in\mathbb{R}^{11}$, which consists of the masses and mass moments of inertia of the robot's body~$m_\text{B}$ and $I_\text{B}$ and reaction wheels~$m_\text{D,R}$ and ~$I_\text{D,R}$.
The mass moments of inertia are assumed to be diagonal and share values for multiple axis due to~(quasi-)symmetries.
Further, the radius of the wheels~$r_\text{D,R}$ and distance between rotation axis~$l_\text{D,R}$ enter as geometric parameters.
The rotational friction in the contact point is modeled as~$\tau_{\psi}=C_1\tanh(C_2\dot{\psi})$, where the constant~$C_1$ models the magnitude and~$C_2$ the slope of the friction.
The mass matrix~$M(\phi,\theta)$ is difficult to invert symbolically (i.e., symbolically computing~$\dot{x}=f_\text{expl}(x,u,p)$) and (\ref{eqn:eqnofmotion}) is stiff on a timescale relevant for controlling the yaw orientation.
Both issues motivate the use of implicit integrators~\cite{frey2023fast} for an accurate discrete-time model with time~$t\in\mathbb{N}$, that is:
\begin{align} \label{eqn:systemdynamics}
        x(t+1) = f_\text{dt}(x(t), u(t), p).
\end{align}


\subsection{Optimization-based Parameter Identification}
\label{sec:parameteridentification}
In this section, the optimization-based identification of the parameters~$p$ from data is described, which is similar to the methods presented in~\cite{bock1983recent,valluru2017development,simpson2023efficient,bodmer2024optimization}.
To this end, an optimization problem
\begin{align}
\begin{split}\label{eqn:sysid}
\min_{p\in\mathcal{P}, \hat{x},\hat{u}} & \sum_{i=0}^{N_\text{id}} \sum_{t=0}^{T_\text{id}}\|\hat{x}_i(t)-\bar{x}_i(t)\|^2_{Q_\text{id}}+\|\hat{u}_i(t)-\bar{u}_i(t)\|^2_{R_\text{id}}\\
\text{s.t.}\quad 
&\hat{u}_i(t)-\bar{u}_i(t)\in\mathcal{W},\;\forall t\in\mathbb{I}_{T_\text{id}},\forall i\in\mathbb{I}_{N_\text{id}}\\
&\hat{x}_i(t+1) = f_\text{dt}(\hat{x}(t), \hat{u}_i(t),p)
\;\forall t\in\mathbb{I}_{T_\text{id}},\forall i\in\mathbb{I}_{N_\text{id}}\\
\end{split}
\end{align}
is solved, where the parameters are constrained to reasonable box constraints~$\mathcal{P}$, the optimization objective consists of quadratic cost on the error between predicted~$\hat{x}$ and measured state~$\bar{x}$ and predicted~$\hat{u}$ and measured action~$\bar{u}$ over a finite horizon~$T_\text{id}$ and a set of trajectories~$N_\text{id}$.
The input disturbance constraint set~$\mathcal{W}$ can be conservatively approximated from direct measurements of the actuator torque ripple.
Quadratic cost matrices are chosen empirically as diagonal matrices~$Q_\text{id}=\text{diag}([100,1,1,10,10,10,0.1,0.1,0.1,0.1]^\top)$ and~$R_\text{id}=\text{diag}([100,100]^\top)$.

The optimization problem (\ref{eqn:sysid}) is implemented in CasADi~\cite{andersson2019casadi} and solved with IPOPT~\cite{wachter2006implementation}, which yields the optimal parameters~$p^*$.
A selection of trajectories from the dataset and the achieved prediction for the critical yaw state is plotted in Fig.~\ref{fig:sysid}.
In the following, the discrete-time dynamics~(\ref{eqn:systemdynamics}) with~$p^*$ substituted in will be referred to as~$f_\text{dt}(x(t), u(t))$, dropping the explicit dependency on~$p$ for ease of notation.

\begin{figure}[thpb]
    \centering
    \input{figures/sysid/sysid.tex}
    \caption{Five of the trajectories used for parameter identification: measurements (dotted) of yaw angle (top) and yaw rotational velocity (bottom) and predictions with optimal parameters~$p^*$ (solid).}
    \label{fig:sysid}
\end{figure}


\subsection{Balancing State-Feedback Controller}
\label{sec:statefeedback}
The Mini Wheelbot can balance in the roll and pitch direction using a simple state-feedback controller as proposed in~\cite{geist2022wheelbot}.
While we use the same structure, that is, state-feedback for the roll and the pitch states separately, we choose a data-driven approach to tune the gains of the controllers directly from closed-loop experiments instead of LQR (see Sec.~\ref{sec:bo}).

The state feedback controller~$u(t) = Kx(t)$ has the feedback gains matrix
\begin{align}
    \setlength\arraycolsep{3pt}
    K = \begin{bmatrix}
        0 &  0  & K_\text{D1} & 0 & 0   & K_\text{D2}   & K_\text{D3} & 0   & K_\text{D4} & 0 \\
        0 & K_\text{R1} & 0   & 0 & K_\text{R2} & 0   & 0 & K_\text{R3} & 0   & K_\text{R4}
    \end{bmatrix},
    \label{eqn:feedbackgain}
\end{align}
where the gains~$K_\text{D}\in\mathbb{R}^4$ control pitch and~$K_\text{R}\in\mathbb{R}^4$ roll.

\textit{Remark}: The yaw orientation of the robot is non-controllable for the Mini Wheelbot's dynamics linearized about the equilibrium balancing position, which are~$A=\tfrac{\partial f_\text{expl}}{\partial x} |_{x=0,u=0}$ and $B=\tfrac{\partial f_\text{expl}}{\partial u}|_{x=0,u=0}$.
The controllability matrix~$C=[B, AB, A^2B,\dots]$ has~$\text{rank}(C)=9 < 10$ where the non-controllable state is $\psi$.
Yet, friction in the wheel-to-ground contact lets~$\dot{\psi}$ converge to standstill.




\subsection{Nonlinear MPC for Driving Control}
\label{sec:nonlinearmpc}
Controlling the Mini Wheelbot's yaw orientation is required for driving the robot along meaningful paths, but can not be achieved by simple, linear control methods.
We propose using a nonlinear MPC~\cite{rawlings2017model} for controlling the yaw orientation.
In MPC, an optimization problem is repeatedly solved to compute a sequence of optimal actions that minimize a cost function for predicted future states.
From the sequence of optimal actions, only the first is applied in closed loop before solving the optimization problem again.
For the Mini Wheelbot, we formulate the nonlinear MPC
\begin{subequations}\label{eqn:mpc}
\begin{align}
\min_{v, x} & \sum_{k=0}^{N_\text{MPC}} \|x(t|k)\|^2_{Q_\text{MPC}} + \|u(t|k)\|^2_{R_\text{MPC}} \label{eqn:mpc:cost}\\
\text{s.t.}\quad & x(t|k+1) = f_\text{dt}(x(t|k), u(t|k)), \label{eqn:mpc:dyn}\\
& u(t|k) = K x(t|k) + v(t|k), \label{eqn:mpc:prestab}\\ %
& x(t|k)\in\mathcal{X}, u(t|k)\in\mathcal{U} \; \forall k\in\mathbb{I}_{N_\text{MPC}-1}\label{eqn:mpc:constr}\\
& x(t|0) = x(t),\quad x(t|N_\text{MPC}) \in \mathcal{X}_f \label{eqn:mpc:initterm}
\end{align}
\end{subequations}
that includes pre-stabilizing feedback (\ref{eqn:mpc:prestab}) with the controller from Sec.~\ref{sec:statefeedback} and a terminal constraint (\ref{eqn:mpc:initterm}).
The terminal constraint is~$\mathcal{X}_f=0$ to guarantee convergence of the solver to a solution that drives the yaw angle to the desired setpoint.
After solving the optimization problem~(\ref{eqn:mpc}), the first action is applied to the system,~$u(t)=u^*(t|0)$.
Cost terms are empirically chosen as diagonal matrices~$R_\text{MPC} = \text{diag}([10, 0.01]^\top)$ and~$Q_\text{MPC} = \text{diag}([100,1,1,0.001, 0.01, 1, 1, 0.0001, 0.25, 0.001]^\top)$.
Details on the constraints are available in the supplementary code\footnotemark[1].
We implement the nonlinear MPC optimization problem~(\ref{eqn:mpc}) in CasADi~\cite{andersson2019casadi} and solve it with IPOPT~\cite{wachter2006implementation}.

\subsection{Stand-Up Maneuver}

\begin{figure}[tb]
    \begin{subfigure}{1.6in}
        \includegraphics[height=0.5in,trim={3cm  3cm 37cm 6cm},clip]{figures/wheelbot_standup/video-frames/pitch_standup_4-029.jpg}%
        \includegraphics[height=0.5in,trim={23cm 3cm 15cm 6cm},clip]{figures/wheelbot_standup/video-frames/pitch_standup_4-037.jpg}%
        \includegraphics[height=0.5in,trim={35cm 3cm  0cm 6cm},clip]{figures/wheelbot_standup/video-frames/pitch_standup_4-100.jpg}%
    \end{subfigure}
    \begin{subfigure}{1.6in}
        \includegraphics[height=0.5in,trim={0cm  7cm 35cm 0cm},clip]{figures/wheelbot_standup/video-frames/roll_standup_1-033.jpg}%
        \includegraphics[height=0.5in,trim={5cm  7cm 33cm 0cm},clip]{figures/wheelbot_standup/video-frames/roll_standup_1-038.jpg}%
        \includegraphics[height=0.5in,trim={15cm 7cm 25cm 0cm},clip]{figures/wheelbot_standup/video-frames/roll_standup_1-055.jpg}%
    \end{subfigure}
    \begin{subfigure}{1.8in}%
        \input{figures/wheelbot_standup/pitch/pitch.tex}%
        \subcaption{Pitch stand-up.}\label{fig:standup:pitch}
    \end{subfigure}%
    \begin{subfigure}{1.2in}%
        \input{figures/wheelbot_standup/roll/roll.tex}%
        \subcaption{Roll stand-up.}\label{fig:standup:roll}
    \end{subfigure}%
    \vspace{1em}
    \begin{subfigure}{3.2in}
        \includegraphics[height=0.533in,trim={5cm  3cm 35cm 8cm},clip]{figures/wheelbot_standup/video-frames/flip-125.jpg}%
        \includegraphics[height=0.533in,trim={8cm  3cm 32cm 8cm},clip]{figures/wheelbot_standup/video-frames/flip-140.jpg}%
        \includegraphics[height=0.533in,trim={15cm 3cm 25cm 8cm},clip]{figures/wheelbot_standup/video-frames/flip-155.jpg}%
        \includegraphics[height=0.533in,trim={18cm 3cm 22cm 8cm},clip]{figures/wheelbot_standup/video-frames/flip-162.jpg}%
        \includegraphics[height=0.533in,trim={20cm 3cm 20cm 8cm},clip]{figures/wheelbot_standup/video-frames/flip-166.jpg}%
        \includegraphics[height=0.533in,trim={22cm 3cm 14cm 8cm},clip]{figures/wheelbot_standup/video-frames/flip-310.jpg}%
    \end{subfigure}
    \begin{subfigure}{3.2in}
        \input{figures/wheelbot_standup/flip/flip.tex}%
        \subcaption{Half flip.}\label{fig:standup:flip}
    \end{subfigure}
    \caption{Environment reset and half flip: The Wheelbot can stand up from any side by using its driving wheel (top left), its reaction wheel (top right), and even perform a flip stand-up (bottom). The maneuvers can be chained to reliably perform environment resets in episodic tasks.}
    \label{fig:standup}
\end{figure}

\label{sec:standup}
Similar to~\cite{geist2022wheelbot}, the new Mini Wheelbot can stand up in the pitch and roll direction (see Fig.~\ref{fig:standup:pitch} and ~\ref{fig:standup:roll}).
Standing up in the pitch direction involves one wheel quickly driving under the robot.
For the roll stand-up, the robot first spins up the reaction wheel before rapidly decelerating it thus excerting a counter torque that makes the robot stand up.
Both maneuvers are achieved via precomputed, open-loop command sequences before switching on the state-feedback controller (see Sec.~\ref{sec:statefeedback}) when entering~$\pm$\SI{30}{\degree} roll and pitch.

\subsection{Half Flip}
\label{sec:flip}
We implement a novel half-flip stand-up maneuver, visualized in Fig.~\ref{fig:standup:flip}.
This acrobatic maneuver pushes the Mini Wheelbot to its limits, illustrating the power of the hardware and hinting at future complex high-speed learning tasks.
The half flip is executed from an open loop action sequence taking about~\SI{160}{\milli\second} before switching on the balancing state-feedback controller for landing.
Similar to the pitch stand-up maneuver, the drive wheel quickly drives under the robot, however, with much higher torque, thus accelerating the Mini Wheelbot beyond the upright position.
After a~\SI{180}{\degree} rotation, the balancing position on the other wheel is reached, where the state-feedback controller starts balancing.
