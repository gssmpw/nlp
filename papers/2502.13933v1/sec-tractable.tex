%!TEX root = main.tex


\paragraph*{Efficiently solvable classes}
\label{sec:tractable}

We get back to finding efficiently solvable classes of imperfect recall games, this time using a parameter called \emph{shuffle-depth SD}, that is naturally derived from our algorithm for computing a minimal $\alr$-span. 

%Recall that $S_{\bar{I}} := \{ s    \in S \mid s \text{ contains no       action from } \act(I)\}$.

When $S$ is disconnected with $S = \uplus S_i$ and each $S_i$ connected : define
SD(S) = $\max_i SD(S_i)$. 
When $S$ is connected and $S$ has $\salr$, define SD(S) = 0.
Otherwise define
\[
SD(S) = 1 + \min_{I}\max_{a \in I}\text{SD}(S_a \cup S_{\bar{I}})
\]
For a $\Tt$ with SD $k$, our minimal $\alr$-span algorithm would encounter sets with $\salr$ after recursively
running upto depth $k$. This takes $\Oo(|\Tt|^{k+1})$ time. %\red{compress}



\begin{proposition}
The minimal $\alr$-span of game structure $\Tt$ with SD = $k$ can be computed in time $\Oo(|\Tt|^{k+1})$.
\end{proposition}

\begin{restatable}{corollary}{efficSolvClass}\label{cor:effic-solv-class}
The maxmin value in a one-player game can be computed in $\mathsf{PTIME}$ for games having structures with constant SD.
\end{restatable}


The game \textbf{III} for any $n$ has SD $2$, and using our algorithm one can find equivalent $\alr$-game with just a quadratic blowup in size. 