

\section{Phase 1 - Design of the Game Master for Version 1} \label{sec:GMV1}

Similarly to previous work exploring LLMs as GMs with prompt engineering~\cite{hua2020playing, You_et_al_2024,Triyason2023} our goal was to explore the use of LLMs and their ability to support engaging and interactive narratives. Our primary motivation was to enable single-player engagement in role-playing games while maintaining the essence of the game master role and the storytelling dynamics, all while ensuring replayability~\cite{krall2012aspects}---a critical factor in player acceptance~\cite{frattesi2011replayability}. We now describe the fundamental components of the ChatRPG v1 game system, the integration of LLMs through prompt engineering, and a user evaluation to gain initial insights from players.

\begin{figure*}[ht!]
  \centering
  \includegraphics[width=\linewidth]{0_pictures/chatRGP.png}
  \caption{Screenshots of the ChatRPG game: a) Landing page of the game. b) Example of a campaign and the text-based conversational user interface of the game.}
  \Description{A two-part image showing the interface of the ChatRPG game (a) shows the landing page with the game title and background image. (b) shows a gameplay example demonstrating the conversational user interface.}
  \label{fig:gameUI}
\end{figure*}

\subsection{The ChatRPG Game}

The term \emph{campaign} denotes a ChatRPG game instance initiated by a player with its own story, characters, and environments. Figure~\ref{fig:gameUI}a shows the landing page for users, also setting the atmosphere for a game, and Figure~\ref{fig:gameUI}b shows a screenshot of the text-based CUI of an example campaign being played. At the beginning of a campaign, the player defines the setting in which the story should unfold. Examples of settings are fantasy, mystery, or post-apocalyptic. The story's theme, characters, and environments must match the setting. The player can write an initial storyline, which they want their campaign to revolve around, or select a pre-generated story prompt, which we provide. For example, an initial storyline for a fantasy setting could be that bandits have kidnapped a child from a nearby village. Once played, existing campaigns can also be selected to be replayed. 

A player will play the game by manipulating a \emph{player character (PC)} in a particular setting, e.g., in a fantasy setting, the player takes on the role of a snobby elf or a furious orc or in a post-apocalyptic setting the character might be a crazy doctor or a shrewd police officer. The people that PCs meet during their campaign will be referred to as \emph{Non-Player Characters (NPCs)} e.g. a burly bearded dwarf who works as a blacksmith in the village or an ogre that the PC must kill. Associated with each character is a description that may define how that character looks and acts, in addition to any backstory they may have. Additionally, a character will have a type associated with it that determines which type of creature they are. The possible values for this type are humanoid, small monster, medium monster, large monster, or boss monster. Lastly, a character will have an associated attribute called \emph{Health Points (HP)}. Players are free to \emph{explore} the world of the campaign by stating what they want their character to do. The time in the world stops moving while the game is waiting for the player’s response. Possible actions that a character could perform are, for example, entering into a dialogue with an NPC, inspecting a peculiar object, or walking to the nearest tavern. In essence, exploration covers the actions that expand the world and the story---this happens based on player actions and features that facilitate such actions available within the game.

A \emph{combat} system is integrated into the exploration mode. A player can at any time choose to attack a target; whereafter the target retaliates with an attack of their own. The player can provide a description of how exactly they attack, allowing the player to express their character traits at all stages of the game. An important functionality of the application is the ability to save a campaign and resume it later. To achieve this, we implemented a sophisticated data model to save and update relations of all entities, e.g., campaigns, characters, environments, and messages. 


\subsection{LLM Integration for V1} \label{sec:GMV1_limits}
The first version employs prompt engineering, whereas all of the game details are consolidated as a long text string, which is then passed to the LLM for updating input from the player and advancing the game. The high-level overview is shown in Figure~\ref{fig:chatrpgv1flow}, while the exact prompts can be found in Appendix~\ref{app_chatgpt_v1_prompts} and publically available repository\footnote{\href{https://github.com/KarmaKamikaze/ChatRPG}{\texttt{https://github.com/KarmaKamikaze/ChatRPG}}}.


%IA I changed the width to make it readable, otherwise the font is too small 
\begin{figure*}[htb!]
  \centering
  \includegraphics[width=.7\linewidth]{0_pictures/ChatRPGv1flow.png}
  \caption{Game interaction flow diagram showing how in v1 user input is handled by the system to make calls to the LLM and present updates to the UI.}
  \Description{A figure showing a flow diagram depicting how user input is handled in the ChatRPG v1 system. It illustrates the process where user input leads to calls to the LLM, which generates a narrative response that is returned to the user interface in addition to game state updates.}
  \label{fig:chatrpgv1flow}
\end{figure*}

We utilized OpenAI's ChatGPT-4 model; however, other LLMs could be utilized by pointing the system via a stateless API, with each query isolated from all others. Content queries are passed to the LLM while the API does not track game state, and consequently, queries have to convey the relevant information and grow longer as the game processes. Maintaining context is, therefore, the responsibility of the API caller. In our initial approach, to maintain context, we stored the entire conversation history and appended it to all queries to the LLM. This simple approach ensures that the player’s adventure remains coherent within the world in which it takes place since all possible context is included in the conversation history. To best enable the LLM to respond fittingly to the player’s input, we have developed three different types of prompts to be prepended for each query. These will be called the \emph{Do}, \emph{Say}, and \emph{Attack} prompts, and this collection will be referred to as system prompts. The \emph{Do} prompt is used when the player wants to perform an action, while the \emph{Say} prompt is used when the player wants to say something without performing any physical actions. Lastly, the \emph{Attack} prompt is used when the player wants to attack someone. These prompts contain a paragraph of instructions that defines the overall role of the LLM, what its response should contain, and the format of its response. JavaScript Object Notation (JSON) format is used for language-independent data communication. 
%The exact contents of our queries will have to be determined through trial and error during the implementation.

The core gameplay of ChatRPG v1 is handled by two components, which we will call \emph{GameInputHandler} and \emph{GameStateManager}. The GameInputHandler will take input from the user, send it to the LLM, and ensure that responses are sent both to the UI to be displayed as well as to the GameStateManager to update the game state. The GameStateManager is responsible for parsing responses from the LLM and using this to update the game state. For example, if the player encounters a new character, it should be created and added to the campaign.


The back-end system was developed as a Blazor Server application, harnessing the capabilities of C\# and .NET 7.0 to construct a full-stack web solution without relying heavily on JavaScript. The advantage of the Blazor Server application framework is that all calculations are handled on the back-end while the client-side remains accessible to the user through a WebSocket. This allows us to create an interactive web page that responds directly to the user’s actions. Moreover, both the front- and back-end components run on the same language, enabling the use of inline C\# code for dynamic elements within the static HTML structures of the pages.


\subsection{Pilot Study with Game Master v1} 

We recruited eight participants with experience in TTPRG and CYOA games, especially Dungeon and Dragons, for the study. The participants were seven males and one female between the ages of 20 and 40 (M=27), and they claimed to play video games for 12+ hours per week. Participants were asked to complete a list of prepared concrete game tasks and then answer questions about their experience.
Game tasks included creating a new campaign, moving to a new location, having a conversation with an NPC, and fighting an enemy. Aside from these tasks, players were free to explore the game as they chose.  When they chose to stop playing the game, participants were asked to fill out a post-game survey and take part in a semi-structured interview to provide feedback on their gaming experience.


All participants completed the tasks successfully and unanimously expressed a willingness to play again, claiming that it was fun and seemed to adapt the story well to their input. The interviews helped to uncover the limitations and potential of the system. The main concern related to the narrative's coherence with many participants finding that some story elements deviated from their intent or that the specific details seemed to change, such as the number of enemies or items. Furthermore, participants asked for a more robust way to check what items their character was holding---some tried to ask the system, and this worked in some cases, yet the GM often provided incoherent responses or forgot that the player had just picked up an item. Another concern raised was that the system would begin to do worse as the game continued in terms of keeping track of the story---this was likely due to the zero-shot prompting of the system in which the entire game state is sent to the LLM each time. As the context window began to reach the limit, only the last part of the prompt was utilized, and the first part seemed forgotten. 

While the system seemed to support an overall enjoyable experience, these early insights led us to consider how the system could be redesigned to support scalability and address the concerns about narrative coherence. In the next section, we describe the redesigned version, which explores how the flexibility and capabilities of agentic AI can be utilized to design a robust RPG GM that leverages advanced reasoning and tool-calling mechanisms to improve coherence and user experience.