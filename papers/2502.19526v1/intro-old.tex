\ur{BIG TODO: introduced two notions of optimality, absolute and relative.  propogate.}

\ur{Intro + Abst: base --> oracle}
\ur{Feynman: what it its complexity, at least quad it seems?  What guarantee does it have?  Heuristic?  }
\ur{Meta: would be worth re-org'in section.  Make Omega optimality its own section and then describe SOAM.}
\ur{IMPORTANT: one sticking point for me was what kind of properties can SOAM optimize (in this paper).  We optimize gate count and T-count.  These are different enough, the question arises.  Can we formulate in terms of some algebra?  Associative property of splits or something? }
\ur{Meta: in the previous submission, we focused on ``scaling'' existing optimizers.  We now have changed our motivation to be more broader (local opt).  But the paper still has some sections using the prev motivation (like intro to soam section).}
\ur{Implementation: do not talk about ``integrating'' an existing optimizer but using it as an oracle for SOAM.  Ideally, we do not want to ``integrate'' and want this to be simple. }
Quantum computing shows significant potential in compute-intensive
domains that remain challenging for classical computers, including,
for example, the simulation of chemical and physical
processes~\cite{y+variational-quantum-2019}, combinatorial
optimization~\cite{hk-inspired-2002}, and machine
learning~\cite{b+quantum-learning-2017}.
%
This promise, coupled with advances in understanding and exploiting
the physics of subatomic particles, has advanced the field of quantum computing
rapidly over the past decade.
%
On the algorithms front, important quantum algorithms, which are
typically expressed as quantum circuits consisting of logical gates,
have been developed for key problems~\cite{deutsch1992rapid,shor1994algorithms,grover1996fast,bernstein1997quantum}.
%
On the architectures front, a variety of technologies have been
proposed for developing quantum computers, some capable of running
circuits with hundreds of qubits or depth-100 gate operations,
have become operational~\cite{k+evidence-2023, moses2023race, wurtz2023aquila}.
%
For example, IBM's Osprey quantum processor has 433 superconducting
qubits, and Atom computing has recently announced a quantum
computer with 1,180 neutral-atom qubits.

% Because modern quantum hardware supports a limited number of gates or operations,
Running a quantum algorithm on modern quantum hardware requires
``compiling'' the logical circuit representation of the algorithm to
the gate set for the target hardware~\cite{chong2017programming, tket-2020}.
%
A key step in this compilation process is the optimization of the
logical quantum circuit to reduce, for example, the number of all and
possibly certain kinds of gates such as T-gates, which are expensive.
%
Optimizing quantum circuits, however, is a formidable challenge.
%
It is known that finding the optimal circuit that is equivalent to a
given circuits is QMA hard~\cite{janzing2003identity} and thus it is
unlikely (unless the polynomial hierarchy collapses) that we will be
able to achieve fully optimal circuits efficiently.
%

%% Many state-of-the art circuit optimization tools optimize the circuit
%% by incrementally applying a basis set of (optimizing) transformations
%% to the circuit~\cite{n+large-2018,qiskit-2019,tket-2020,quartz-2022,queso-2023}.
%% %
%% Because this approach can take a  optimizations

%% Given enough time, such algorithms could find a globally optimal
%% circuit.
%% %
%% But in reality, they can take a long time (hours or days) even for
%% circuits with a few hundred gates.
%% %

%
%% These optimizers therefore are typically used under a time-out
%% (usually of hours) that terminates the optimization process when the
%% time-out occurs.
%
%% Earlier quantum optimizers relied on human beings to manually
%% construct this basis set of optimizing
%% transformations~\cite{n+large-2018}.
%% %
%% More recent research showed that it is possible to automate this process,
%% by developing algorithms that construct this basis set~\cite{quartz-2022, queso-2023} and
%% then using the basis set to optimize the circuit.
%% %
%% To optimize,
%% these approaches search for matching subcircuits in the basis set and replace them
%% with their optimized counterparts.
%%
%% These advances have led to important improvements in optimization quality
%% but they all have a key limitation: they do not scale beyond small
%% circuits, typically consisting of hundreds of gates.
%% %
Given that today's NISQ-era quantum computers have hundreds of qubits
and given the advances in improving coherence
times~\cite{preskill2018quantum}, it is currently feasible to execute
large quantum circuit with thousands of gates~\cite{k+evidence-2023}.
%
It is expected that further engineering improvements will lead to
successful execution of even larger circuits, even before the
fault-tolerant era.
%
These advances and the proven QMA-hardness of the quantum optimization
problem thus raise an important question: how can we improve the
efficiency, effectiveness, and scale of quantum circuit optimization?

In this paper, we propose two notions of local optimality
and develop efficient and effective optimization techniques that
produce locally optimal quantum circuits.
%
%
Given an integer $\Omega$, our first notion of local optimality,
called $\Omega$-optimality, requires each $\Omega$-deep subcircuit of
a circuit to be fully optimal.
%
Our second notion of local optimality, called relative local
optimality, relaxes local optimality by requiring the subcircuits to be
optimal only \defn{relative} to a given optimizer---i.e.,
the subcircuits may not be further optimized by the given optimizer
(though they may not be fully optimal).
%
Relative local optimality is a more practical notion
because achieving full optimality even for small subcircuits can be expensive.
%
Furthermore, the notion allows us to use our optimization techniques for existing optimizers
that do not guarantee full optimality.

To ensure local optimality, we present an algorithm that uses a given
``small circuit'' optimizer, which we call the ``oracle'' (optimizer),
to optimize small circuits.
%
For large input circuits, the algorithm partitions the circuit into
smaller subcircuits and recursively optimizes each subcircuit,
%
using the oracle only for the small circuits.
%
The algorithm then ``melds'' the optimized subcircuits to construct an
optimized circuit.
%
Since each subcircuit is optimized in isolation, the meld operation
cannot simply join the optimized results, because doing so would offer
no optimality guarantee: the seam conjoining two optimized subcircuits
may give rise to further optimizations that simple joining would miss.
%
Our algorithm therefore melds the optimized subcircuits together by
propagating optimizations from one subcircuit into the other until it achieves
convergence over the whole circuit.
%
Crucially, it only uses the oracle optimizer on small, $\Omega$-deep
subcircuits.
%


Under some reasonable assumptions for the cost function being
optimized---that the cost functions are non-negative and are integer
valued, and that they are additive under circuit concatenation
operation---we show that our \coam{} algorithm ensures local
optimality or relative local optimality (depending on the oracle
optimizer being used).
%
Furthermore, we prove that even though the
algorithm melds circuits at many levels of the recursive partitions,
and each meld operation may require many oracle calls to join circuits optimally,
the \coam{} algorithm makes linear number of calls (in the
size of the circuit) to the oracle optimizer.

\ur{The bound is  a  bit sloppy here. Improve }

We show that our algorithm is practical by implementing it and
applying it to three different state of the art optimizers:
%
Feynman~\cite{amy2019formal},
%
Quartz~\cite{quartz-2022}, and
%
Queso~\cite{queso-2023}.
%
We evaluate the resulting optimizers by considering a variety of
quantum circuits, ranging from moderate to large circuits.
%
The experiments confirm that our optimizers runs efficiently in
practice and can optimize circuits with many thousands gates
reasonably quickly.


The contributions of the paper are the following:
\begin{itemize}

\item A local optimality criterion, called $\Omega$-optimality for quantum circuit optimization.

\item An efficient algorithm for quantum circuit optimization that ensures local optimality.

\item The proofs that the algorithm guarantees local optimality and is efficient.

\item A practical implementation of the algorithm.

\item Applications of \coam{} algorithm to three existing optimizers.

\item An empirical evaluation that confirms the theoretical runtime and the quality guarantees and shows the scalability benefits of local optimality.

\end{itemize}


%% Guaranteed linear worst-case optimization time by itself is not
%% interesting for quantum circuit optimization---after all, a simple
%% algorithm that simply applies up to a linear number of optimizations
%% achieves the same bound.
%% %
%% What is also important is to ensure some degree of quality for the
%% optimized circuit.
%% %
%% For our algorithm, we show that the optimized circuits (output)
%% are \defn{locally optimal} with respect to the oracle being used in
%% the sense that applying the oracle to any (contiguous) subcircuit of
%% the optimized circuit yields no improvements.



%% Quantum circuit optimization problem requires optimizing a quantum
%% circuit by for example improving the the number of all or some
%% selected gates, .e.g., ``CNOT'' gates and ``T'' gates.
%% %
%% Existing quantum circuit optimizers either take as input a number of
%% ``optimizing transformations'', each of which transfor a small circuit
%% to another equivalent, and more optimized circuit, or discover such
%% optimizing transformations automatically.
%% %
%% Given a set of such (optimizing) transformations, circuit optimizers
%% apply the transformations to subcircuits of a circuit, replacing each
%% subcircuit with an equivalent but more optimized one.
%% %
%% Because there are a very large, typically exponentially many, number
%% of subcircuits to consider, quantum circuit optimizers do not scale
%% beyond relatively small circuits, consisting for example of a few
%% thousand gates (even less perhaps), without of course sacrificing on
%% the quality of the overall optimization.
%% %
%% It has been not known how quantum circuit optimization may be scaled
%% to larger circuits.


%% In this paper, we propose a optimization algorithm for quantum
%% circuits that scales to large circuits.
%% %
%% Our algorithm takes an optimizer that works on ``small'' circuits
%% (e.g., tens or hundreds of gates) and a circuit to be optimized.
%% %
%% It then recursively partition the circuit into small subcircuits,
%% optimizes the small circuits with the given optimizer, and melds the
%% optimized subcircuits.
%% %
%% To ensure optimality of the resulting circuit, our meld operation
%% considers the interactions along the seam of the optimized circuits
%% being meld.
%% %
%% We prove two key properties for our algorithm:
%% %
%% 1) it guarantees \emph{local optimality}---the output circuit cannot be
%% furether optimized by applying the given optimizer to any subcircuit,
%% %
%% 2) it scalables---it works within a worst-case time bound of $O(n)$
%% where $n$ is the size of the input circuit.
%% %

%% We implement our algorithm and apply it to a number of large circuits.
%% %
%% Our experiments show that the techniques do indeed scale linearly in
%% the size of the circuit and can successfully optimize circuits with
%% many thousands of gates.
%% %
%% Compared to existing art, our techniques can result in significant
%% improvements in circuit quality by using reasonable time and compute
%% resources.
