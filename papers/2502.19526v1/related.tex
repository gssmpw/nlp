We discussed most closely related work in the body of the paper.  In
this section, we present a broader overview of the work on quantum
circuit optimization.

\paragraph{Cost Functions.}
Gate count is a widely used metric for optimizing quantum circuits.
In the NISQ era, reducing gate count improves circuit performance
by minimizing noise from operations and decoherence.
It also reduces resources in fault-tolerant architectures
like the Clifford+T gate set.
Researchers have developed techniques to reduce gate count by
either directly optimizing circuits or
resynthesizing parts using efficient synthesis algorithms.
We cover optimization techniques later in the section.


%\paragraph{Other Gate Sets and Metrics.}

In addition to reducing gate counts,
compilers like Qiskit and t$\ket{\textnormal{ket}}$,
implement circuit transformations that optimize cost specific to NISQ architectures.
%
Examples include maximizing circuit fidelity in the presence of noise~\cite{murali2019noise, tannu2019not},
and
reducing qubit mapping and routing overhead (SWAP gates)
for specific device topologies~\cite{molavi2022qubit, lye2015determining, itoko2020optimization, li2019tackling},
or hardware-native gates and pulses \cite{nottingham2023decomposing, wu2021tilt, shi2019optimized, gokhale2020optimized}.
%
Techniques also exist to optimize/synthesis
circuits for specific unitary types, such as classical
reversible gates~\cite{prasad2006data, ding2020square, bandyopadhyay2020post, wille2019towards},
\clifft{}~\cite{amy2020number, kliuchnikov2014asymptotically, ross2014optimal, kissinger2020reducing},
Clifford-cyclotomic~\cite{forest2015exact}, V-basis~\cite{bocharov2013efficient, ross2015optimal},
and Clifford-CS~\cite{glaudell2020optimal} circuits.
%
While algorithms for small unitaries produce
Clifford+T circuits with an asymptotically optimal number of $\mathsf{T}$ gates~\cite{giles2013remarks},
efficiently generating optimal large Clifford+T circuits remains a challenge.
%
The \feyntool{} optimizer is used for optimizing the $\mathsf{T}$ count of quantum circuits.
%
It uses an efficient (polynomial-time) algorithm called phase folding~\cite{amy2014polynomial},
to reduce phase gates, such as the $\mathsf{T}$ gate, by merging them.
%
More generally, the Feynman toolkit combines phase folding
with synthesis techniques to optimize other metrics like the CNOT count~\cite{amy2019formal}.
%
We demonstrate that our \algname{} algorithm,
which guarantees local optimality,
can use \feyntool{} as an oracle for optimizing
$\mathsf{T}$ count in Clifford+T circuits
\iffull
in \appref{clifft}.
\else
in the Appendix.
\fi
%Our experiments demonstrate that our \algname{} algorithm,
%which guarantees local optimality,
%effectively uses \feyntool{} as an oracle for optimizing
%$\mathsf{T}$ count in Clifford+T circuits.
%
These experiments show that our \algname{} algorithm scales
to large circuits without reducing optimization quality.

\paragraph{Resynthesis methods.}
Resynthesis methods focus on decomposing unitaries into sequences of
smaller unitaries using algebraic structures of matrices.
%
Examples include
the Cartan decomposition \cite{tucci2005introduction},
the Cosine-Sine Decomposition (CSD),
the Khaneja Glaser Decomposition (KGD) \cite{khaneja2001cartan},
and the Quantum Shannon Decomposition (QSD).
%
Some synthesis methods demonstrate optimality for arbitrary unitaries of small size
(typically for fewer than five qubits),
particularly in terms of gate counts like CNOT gates \cite{rakyta2022approaching}.
%
However, their efficiency degrades significantly when dealing with larger unitaries;
furthermore, they require the time-consuming step of turning the circuit into a unitary.
%
QGo \cite{wu2020qgo} addresses this limitation with a hierarchical approach that
partitions and resynthesizes circuits block-by-block.
%
However, due to the lack of optimization across blocks,
the performance of QGo depends heavily on how circuits are partitioned.
%
Our local optimality technique, and specifically melding,
could be used to address this limitation of QGo.

\paragraph{Rule-based and peephole optimization methods.}
%Optimization methods often employ heuristic-based optimization
%to iteratively minimize the overall gate count.
%
%Their performance is often limited by the small set of rules used.
%Recent developments in optimization methods can be coarsely classified
%as rule-based, search-based, and learning-based techniques.
Rule-based methods find and substitute rules in quantum circuits to
optimize the circuit~\cite{iten2022exact, bandyopadhyay2020post,hietala2021verified, quartz-2022}.
%
VOQC~\cite{hietala2021verified} is
a formally verified optimizer that uses rules to optimize circuits.
%
VOQC implements several optimization passes inspired by state-of-the-art
unverified optimizer proposed by Nam et al.~\cite{Nam_2018}.
%
These passes include rules that perform $\mathsf{NOT}$ gate propagation, Hadamard gate reduction,
single- and two-qubit gate cancellation, and rotation merging.
%
Most of these passes take quadratic time in circuit size,
while some can take as much as cubic time~\cite{Nam_2018}.
%
Our experiments show that our local optimization algorithm \algname{}
effectively uses \voqc{} as an oracle for gate count optimization.
%

%
% UMUT: WE DO NOT IMPROVE RUNNING TIME OF VOQC
%Our results show that by focussing on local optimality,
%we can improve the running time of \voqc{} without any loss in circuit quality.

The notion of local optimality proposed in this paper is related
peephole optimization techniques from the classical compilers
literature~\cite{ct-compiler-2022,h+stratified-2016,sa-peephole-2006}.
%
Peephole optimizers typically optimize a small number of instructions,
e.g., rewriting a sequence of three addition operations into a single
multiplication operation.
%
Our notion of local optimality applies to segments of quantum
circuits, without making any assumption about segment sizes (in our
experiments, our segments typically contained over a thousand gates).
%
Because peephole optimizers typically operate on small instructions at
a time and because they traditionally consider the non-quantum
programs,  efficiency concerns are less important.
%
In our case, efficiency is crucial, because our segments can be large,
and optimizing quantum programs is expensive.
%
To ensure efficiency and quality, we devise a circuit
cutting-and-melding technique.

Prior work use peephole optimizers~\cite{prasad2006data,
liu2021relaxed} to improve the circuit one group of gates at a time,
and repeat the process from the start until they reach a fixed point.
%
The Quartz optimizer also uses a peephole optimization technique but
cannot make any quality guarantees~\cite{quartz-2022}.
%
Our algorithm differs from this prior work, in several aspects.
%
First,
it ensures efficiency, while also providing a quality guarantee based
on local optimality.
%
Key to attaining efficiency and quality is its use of circuit
cutting and melding techniques.
%
Second, our algorithm is generic: it can work on large segments (far
larger than a peephole) and optimizes each segment with an oracle,
which can optimize the circuit in any way it desires, e.g., it can use
any of the techniques described above.
%



\if0
%% UMUT: OUT OF PLACE
Although we focus on the Nam gate set for this evaluation, we note that
\quartz{} and \queso{} have shown competitive performance
for other gate sets (including IBM, Rigetti, and Ion)~\cite{quartz-2022, queso-2023}, and
we expect that this performance would translate to our setting.
\fi

\pyzx{}~\cite{kissinger2020Pyzx} is another rule-based optimizer
%However, it only minimizes $\mathsf{T}$ count and does not explicitly optimize gate count. We observe that \pyzx{} achieves worse performance on gate count, and can spend over 98\% of the time on circuit extraction for ZX-diagrams as opposed to optimization on ZX-diagrams for the sqrt circuit with 42 qubits.
that optimizes $\mathsf{T}$ count. It uses ZX-diagrams to optimize circuits and then extracts the circuit. Circuit extraction for ZX-diagrams is \#{}P-hard~\cite{de2022circuit}, and can take up much more time than optimization itself.
Because \algname{} invokes the optimizer many times, circuit extraction for ZX-diagrams can become a bottleneck. In addition, \pyzx{} only minimizes $\mathsf{T}$ count and does not explicitly optimize gate count. We therefore did not use \pyzx{} in our evaluation.
%Due to the uncertainty of the heuristics in the circuit extraction algorithm, it might not be efficient to pair \algname{} with \pyzx{} as an oracle for $\mathsf{T}$ count optimization.


\paragraph{Search-based methods.}
Rule-based optimizers may be limited by a small set of rules and are not exhaustive.
%
To address this,
researchers have developed search-based optimizers~\cite{queso-2023, quartz-2022, qfast,qsearch}
including \quartz{}~\cite{quartz-2022} and \queso{}~\cite{queso-2023}
that automatically synthesize exhaustive circuit equivalence rules.
%
Although their rule-synthesis approach differs,
both use similar algorithms for circuit optimization.
%
They iteratively operate on a search queue of candidate circuits.
%
In each iteration,
they pop a circuit from the queue,
rewrite parts of the circuit using equivalence rules,
and insert the new circuits back into the queue.
%
To manage the exponential growth of candidate circuits,
both tools use a ``beam search'' approach that limits the search queue size by
dropping circuits appropriately.
%
By limiting the size of the search queue,
\quartz{} and \queso{} ensure that
the space usage is linear relative to the size of the circuit.
%
Their running time remains exponential,
and they offer a timeout functionality,
allowing users to halt optimization after a set time.
%
This approach has delivered excellent reductions in gate count
for relatively small benchmarks~\cite{queso-2023, quartz-2022}.
%
However, for large circuits,
the optimizers do not scale well because they attempt to search an exponentially large search space.

QFast and QSearch apply numerical optimizations to
search for circuit decompositions that are close to the desired unitary~\cite{qfast, qsearch}.
%
Although faster than search-based methods \cite{davis2020towards},
these numerical methods tend to produce longer circuits, and their running time
is difficult to analyze.


%\paragraph{\feyntool{}.}





\if0
%% UMUT: REDUNDANT
The optimizers \quartz{} \cite{quartz-2022} and \queso{} \cite{queso-2023}
construct equivalent classes of quantum circuits and
use them to run a beam-search algorithm for reducing gate count (\secref{impl}).
%
These state-of-the-art optimizers are excellent for optimizing circuits
whose sizes are hundreds of gates.
\fi

\paragraph{Learning-based methods.}
Researchers have also developed machine learning models~\cite{fosel2021quantum}
for optimizing quantum circuits with variational/continuous parameters,
which reduce gate count by tuning parameters of
shallow circuit ansatze~\cite{mitarai2018quantum, ostaszewski2021reinforcement},
or by iteratively pruning gates \cite{sim2021adaptive, wang2022quantumnas}.
%
These approaches, however, are associated with substantial training costs~\cite{wang2022quantumnas}.
%




%

% %
% In this paper,
% we integrate our \coam{} algorithm with \quartz{}
% and demonstrate that it scales \quartz{} for larger circuits,
% with sizes going upto hundreds of thousands of gates.
% %
% Because the runtime behavior of \queso{} is similar to \quartz{},
% we tried to integrate our implementation with
% the \queso{} optimizer.
% %
% However, we faced two problems.
% %
% First,
% even though \queso{} implements a timeout facility,
% it does not adhere to it.
% %
% We observed that the tool takes an unpredictable amount of time
% taking as much as $200$x the given timeout.
% \footnote{We note that the tool is designed to operate for hours of optimization
% and may not have been designed to account for the range of timeouts we are interested in,
% i.e., in the range of hundreds of seconds.}
% %
% Second,
% the optimizer is in Java,
% which does not integrate with our code, because our
% implementation language does not cross-operate with Java.
%


% Global optimization of quantum circuits is QMA-hard ~\cite{janzing2003identity}.
% %
% As such, our algorithm targets a more modest but practically significant goal: to compose local optimizations of subcircuits while maintaining a strong $\Omega$-optimality guarantee (Theorem~\ref{thm:opt}), allowing us to scale an oracle optimizer (such as Quartz) to the large/deep circuit regimes in linear time (Theorem~\ref{thm:time}).
% %
% As a result, we achieve faster and higher-quality optimizations,
% surpassing the straightforward application of the oracle optimizer to the entire quantum circuit.




% \feyntool{} is an optimizer from the ``Feynman''\footnote{https://github.com/meamy/feynman} toolkit
% for quantum circuits that
% %
% This path integral model encodes the state transition performed by a quantum circuit with a
% sum over all possible paths between two given states.
% %
% The model is used by the \feyntool{} optimizer to generate a \emph{phase polynomial}
% of a circuit on which the optimizer performs a \emph{phase folding} optimization.
% The optimization merges phase gates
% acting on the same set of computational paths.
% %
% Phase folding is a powerful technique for optimizing phase gates such as the $\mathsf{S}$ gate,
% the $\mathsf{Z}$ gate, and the most expensive $\mathsf{T}$ gate~\cite{t-depth}.
%
% Furthermore, the algorithm terminates in polynomial time,
% making it a practical choice for optimizing large circuits.
%



%\yr{More explanations?}




%\input{implementation}
