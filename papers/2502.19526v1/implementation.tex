

\myparagraph{\quartz{} and \queso{}.}
\quartz{} and \queso{} are state of the art tools for synthesizing
circuit equivalence rules and using them to optimize circuits ~\cite{queso-2023, quartz-2022}.
%
The tools differ in their approach to rule synthesis,
but their algorithms for applying the rules for circuit optimization are similar.
%
To optimize circuits,
they execute a search algorithm by maintaining a search queue of candidate circuits.
%
At each step,
they pop a circuit from the queue and rewrite parts of the circuit using
their respective equivalence rules.
%
Then, they insert the new circuits back to the queue and repeat the process
until the queue becomes empty.
%
Since the number of circuits to consider grows exponentially with the size of the circuit,
both tools use ``beam search'',
 a search algorithm that limits the size of the search
queue and appropriately drops circuits after the limit is reached.
%
By limiting the size of the search queue,
\quartz{} and \queso{} ensure that
the space usage is linear in the size of circuit
(they only store a fixed number of circuits).
%
Their running time is exponential
and they provide a timeout functionality,
allowing their users to halt optimization after a certain amount of time.
%
Using this graph search approach with timeouts,
the tools have delivered excellent reductions in gate count
across a range of benchmarks and different gate sets~\cite{queso-2023, quartz-2022}.
%

\myparagraph{\feyntool{}.}
\feyntool{} is an optimizer from the ``Feynman''\footnote{https://github.com/meamy/feynman} toolkit
for quantum circuits that uses the path integral model of quantum computation to analyze and optimize circuits~\cite{amy2019formal}.
%
This path integral model encodes the state transition performed by a quantum circuit with a
sum over all possible paths between two given states.
%
The model is used by the \feyntool{} optimizer to generate a \emph{phase polynomial}
of a circuit on which the optimizer performs a \emph{phase folding} optimization.
The optimization merges phase gates
acting on the same set of computational paths.
%
Phase folding is a powerful technique for optimizing phase gates such as the $\mathsf{S}$ gate,
the $\mathsf{Z}$ gate, and the most expensive $\mathsf{T}$ gate~\cite{t-depth}.
%
Furthermore, the algorithm terminates in polynomial time,
making it a practical choice for optimizing large circuits.


% However, both optimizers deliver poor time scalability,
% because the number of the circuits that need to be considered
% increases exponentially with the size
% of the circuits and so does the running time.
% %
% For instance,
% \quartz{} takes more than $24$ hours on a circuit of size $48$.
% %
% \queso{} takes eighteen seconds to terminate on this circuit,
% and its running time jumps to an hour on a circuit of size 96 (a $20$x increase),
% which further jumps to around six hours for a circuit of size 326 (a $6$x increase).
% %
% For this reason,
% both tools implement a timeout facility,
% allowing the users to stop optimization at will.
% %
% Using this graph search approach with timeouts,
% the tools have delivered excellent reductions in gate count
% across a range of benchmarks and different gate sets.
%

% Because of the exponential time complexity,
% we run both tools with a timeout and
% take the best circuit it finds within the given time.


\myparagraph{\voqc{}.}
VOQC~\cite{hietala2021verified} is
a formally verified optimizer for quantum circuits,
implemented using Coq.

It takes as input quantum programs written in SQIR,
a quantum intermediate representation also developed by the authors.
VOQC implements several optimization passes inspired by state-of-the-art unverified optimizers~\cite{Nam_2018},
including not propagation, Hadamard gate reduction,
single- and two-qubit gate cancellation, and rotation merging. 
The optimizations are proved correct with respect to SQIR's denotational semantics.


% \myparagraph{Using optimizers with \coam{}.}
% We implement the \coam{} algorithm in SML and allow using existing optimizers as oracles.
% %
% Because the language allows for cross-language calls to C++,
% we only require a C++ wrapper to use an optimizer.
% %
% The wrapper implements the function $\mathsf{optimize}$,
% which takes a circuit in QASM format as input
% and returns an optimized circuit in as output.
% %

% %
% Because \quartz{} is written in C++,
% it was straightforward to use it in our implementation.
% %
% As an optimization,
% we pre-load the circuit equivalence rules of the \quartz{} optimizer
% and use them across different calls to it.
% %
% This removes the overhead of repeated file I/O.
% %

% The optimizer \queso{} is written in Java and we implement
% a C++ wrapper that manages the Java runtime and interfaces with our \coam{} implementation.
% %
% Our \coam{} implementation makes cross-language function calls the C++ wrapper,
% which, in turn, calls into the Java runtime,
% which executes \queso{} on the circuit.
% %
% The other implementation details are similar to \quartz{}.

% The \feyntool{} optimizer is written in Haskell
% and we write a C++ wrapper that invokes it via the operating system.
% %
% Specifically, to invoke \feyntool{} on a subcircuit, the wrapper
% writes the QASM representation to a file,
% calls \feyntool{} by using a system call,
% and reads the output.
%
%
% With more engineering efforts,
% it is possible to make the integration more efficient by
% by writing a C wrapper around Haskell and directly calling it from our implementation.
% %
% We leave this to future work.
%




% and does not naturally work with our implementation,
% because our
% implementation language does not cross-operate with Haskell.
% %
% We integrate \feyntool{} via the operating system.
%
%

% Because the overhead is large and difficult amortize by increasing
% subcircuit sizes, our integration with \feyntool{} incurs significant
% overhead.
% %
% Nevertheless, this integration demonstrates the feasibility of
% integrating with existing optimizers either through cross-language
% interoperability features (when feasible) or through systems calls.
%


% \myparagraph{Granularity optimization.}
