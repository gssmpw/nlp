%\label{sec:lang}
%\ur{TODO: rename ``shiftleft''  ``compaction''?}
%\ur{TODO: rename ``LOPT''  ``OPTIMIZATION''?}

In this section, we introduce \defn{local optimality} for quantum circuits
using a circuit language called \lang{}, which represents circuits as sequences of layers.
%
% \lang{} represents circuits as a sequence of layers.
%
We define local optimality based on three components:
(1) a base optimizer called the \defn{oracle},
(2) a \defn{cost} function that evaluates the circuit quality, and
(3) a \defn{segment size} $\Omega$,
which determines the scope of \emph{local optimizations}.
%
A segment refers to a contiguous sequence of layers.
%
Roughly speaking,
a circuit is locally optimal when it satisfies the following conditions:
\begin{enumerate}
    \item No local optimizations are possible, i.e., the oracle
    cannot optimize any segments of size $\Omega$.
    \item All circuit segments are as compact as possible with no unnecessary gaps.
\end{enumerate}
%

For a locally optimal circuit, the oracle cannot find more
optimizations unless it operates on segments larger than $\Omega$.
%
Because our definition is parametric in terms of the oracle,
we can define local optimality for any quantum gate set
by instantiating appropriate oracles.

We then develop a circuit rewriting semantics that produces
locally optimal circuits.
%
The semantics only uses the oracle on small circuit segments,
each containing at most $\Omega$ contiguous layers.
%
Using this semantics,
we prove that for a general class of cost functions,
\emph{any} circuit can be transformed into a locally optimal circuit.
%
This makes local optimality applicable to various cost functions
such as gate count, $\mathsf{T}$ count, and many others.


% %
% Our approach is also independent of the gate set, and can be instantiated for different
% gate sets by selecting an appropriate oracle.



% Local optimality is a practical goal of optimization
% because many optimizers struggle to optimize
% large circuits.
% This is useful becauseand are only effective when the circuits are small.
% %
% Because optimizing the whole circuit in one call to the optimizer can be
% infeasible, we use local optimality as the goal of optimization.



%
% This parameter, $\Omega$, controls how ``local'' the local optimality
%


%

% specifically by upper-bounding the number of circuit layers that
% are given to the oracle.
% %
% This bound, denoted $\Omega$, is another parameter of the system.
% %
% Altogether, our approach therefore has three parameters:
% an oracle $\oracle{}$, a \costof{} function, and a

% and our optimality results are taken relative
% to the oracle.
% %
% That is,
% approach can be applied to optimize across a variety
% %
% Local optimizations must adhere to a cost function
% %
% The rewrite system is quite general because it is parameterized by
% takes as parameters a base optimizer, a cost function, and a \omparam{} $\Omega$,
% and define rules for local optimization.
% %
% Because its parametric, the rewrite system can be used with a variety of optimizers,
% gate sets, and cost functions.



\subsection{Circuit Syntax and Semantics}

We present our circuit language called \lang{} (Layered Quantum Representation)
which represents a quantum circuit as a sequence of layers.
%
Figure~\ref{fig:lang:syn} shows the abstract syntax of the language.
%
We let the variable $q$ denote a qubit, and $G$ denote a gate.
%
For simplicity, we consider only unary gates $g(q)$ and binary gates
$g(q_1, q_2)$, where $g$ is a gate name in the desired gate set.
%
These definitions can be easily extended to support gates of any arity.

A \lang{} circuit $C$ consists of a sequence of
layers $\langle L_0, \dots, L_{n - 1} \rangle $,
where each layer $L_i$ is a set of gates
that are applied to qubits in parallel.
%
The circuit is \defn{well formed} if
the gates of every layer act on disjoint qubits, i.e.,
no layer can apply multiple gates to the same qubit.
%
As a shorthand, we write $\compat{G_1}{G_2}$ to denote that gates
$G_1$ and $G_2$ act on disjoint qubits,
i.e., $\qubits{G_1} \cap \qubits{G_2} = \emptyset{}$.
%
We similarly write $\compat{L_1}{L_2}$ for the same condition on layers.
%
Note that we implicitly assume well-formedness throughout the section
because it is preserved by all our rewriting rules.

We define the \defn{length} of a \lang{} circuit as the number of layers,
and the \defn{size} of a circuit $C$, denoted $|C|$, as the total number of gates.
%
A \defn{segment} is a contiguous subsequence of layers of the circuit, and
a \defn{k-segment} is a segment of length $k$.
%
% The size and length of a segment are defined similarly to circuits.
We use the Python-style notation $C[i : j]$ to represent a segment containing
layers $\langle L_i, \dots, L_{j - 1} \rangle $ from circuit $C$.
%
In the case of overflow (where either $i < 0$ or $j > \mathsf{length}(C)$),
we define $C[i : j] = C[\max(0, i) : \min(j, \mathsf{length}(C))]$.

Two circuits $C$ and $C'$ can be concatenated together as $C; C'$,
creating a circuit containing the layers of $C$ followed by layers of $C'$.
%
Formally,
if $C = \langle L_0 \dots L_{n-1} \rangle$ and $C' = \langle L'_0 \dots L'_{m-1} \rangle$,
then $C;C' = \langle  L_0 \dots L_{n-1},L'_0 \dots L'_{m-1} \rangle$.




%
% Gate names can come from any standard Quantum gate set, and must
% be supported by the chosen oracle optimizer.
% (e.g., Hadamard gate, NOT gate, controlled-NOT gate, T gate, etc.)

% %
% The figure uses variable $q$ (and variants) to range over a set of
% qubits, indexed by natural numbers $1 \ldots n$,
% %
% and variable $G$ (and variants) to range over a set of gates.
% %
% For simplicity we only consider unary and binary gates operating on one
% and two qubits respectively.
% %

\input{fig/fig-circ-lang-syntax}


% %
% Modern quantum optimizers work by taking typically small subcircuits of the input circuit and rewriting them to improve quality.
% %
% For this approach to work well, it is important for a layered circuit to be as compact as possible so as to maximize each subcircuit, which can be optimized.
%
%

% \sr{Paragraph above seems out of place here. Where should we motivate compactness?}


% \subsection{Well Typed Programs}

% We say that a program $P$ is well-typed if it consists of well-typed
% layers.
% %
% We say that a layer is well typed if each qubit is used (applied to a
% gate) at most once.
% %
% Well typedness enforces the no-cloning theorem of quantum mechanics,
% which prevents copying of an arbitrary quantum state.





\subsection{Local Optimality}

\input{fig/fig-lopt-defn}

% \todo{introduction to the subsection}
We introduce two optimality properties on circuits
written in our language \lang{}.
%
These properties are defined on the following parameters.
%
First, we assume an abstract \cost{} function over circuits,
where a smaller cost means a better quality circuit.
%
Second, we introduce a parameter $\Omega$,
which represents the maximum segment length that can be considered for optimization.
%
In this context,
the optimizations are \emph{local}
because each optimization can only optimize a circuit segment of length $\Omega$.
%
Third,
we assume an $\oracle$ optimizer that takes a circuit of length $\Omega$ and
produces an equivalent circuit, optimized w.r.t. the cost function.
%
We assume that the oracle and the cost function are compatible,
meaning that the oracle can only decrease the cost:
\[ \forall C.~\costof{\oracle{}(C)} \leq \costof{C}. \]
%

\myparagraph{Segment optimal circuits.}
%
A circuit is segment-optimal
if each and every $\Omega$-segment of the circuit is optimal
for the given \oracle{} and \cost{} function.
%
\figref{lopt-defn} defines \wopttext{} circuits
as the judgment $\windowopt\Omega C$.
%
The judgment checks that any segment $C[i:j]$ whose length
is smaller than $\Omega$ (i.e., $i \leq j \leq i+\Omega$)
can not be further optimized by the oracle.
Thus,
calling the oracle on any such
segment does not improve the cost function.
%
% The optimality guarantee is slightly weaker because it does not require
% the circuit to be \emph{compact}, which we define next.

\myparagraph{Compact circuits.}
A circuit is \emph{compact} if every gate is in the left-most possible
position, i.e., in the earliest layer possible.
% \footnote{It would also be possible to define compactness with right-most}
%
\figref{lopt-defn} formalizes this with the judgement $\compressed C$.
%
The judgment checks every gate $G$ and ensures that
at least one qubit used by $G$ is also used by the previous layer
(i.e., $G \in L_i$ and $\notcompat{L_{i-1}}{\{G\}}$).
%
% Therefore, $G$ cannot be moved left.
%
If every gate satisfies this condition, the circuit is compact.

Ensuring that a layered circuit is as compact as possible
is important because compact circuits are more amenable to local optimizations.
%
For example, consider two $H$ gates on the same qubit, one of them in layer $0$
and the other in layer $3$, with no gates in between.
% For example, consider a circuit with an $H$ gate on layer $0$ at qubit $0$ and
% another $H$ gate on layer $5$ at qubit $0$, with no gates in between.
%
Suppose we have an optimization that cancels two $H$ gates on the same qubit,
when they are on adjacent layers.
%
This optimization would not apply to
our circuit because the two $H$ gates are not adjacent.
%
However, if the circuit did not have such unnecessary ``gaps'',
we could apply the optimization and eliminate the two $H$ gates from our circuit.
%
Compaction ensures that such optimizations are not missed.

\myparagraph{Locally Optimal Circuits.}
A circuit is {locally optimal} if it is both
compact and \wopttext.
%
This means that each and
every $\Omega$-segment of the circuit is optimal
for the given \oracle{} and \cost{} function
and the circuit as a whole is compact,
ensuring that no more local optimizations are possible.
%
\figref{lopt-defn} defines locally optimal circuits,
as the judgment $\locallyopt\Omega C$,
%


% ====================================================================================================
% ====================================================================================================
% ====================================================================================================


\subsection{Circuit Rewriting for Local Optimality}

In this section,
we present a rewriting semantics for producing locally optimal circuits.
%
The rewriting semantics performs local optimizations,
each of which rewrites an $\Omega$-segment,
and compacts the circuit as needed.
%
% The key result of this section is a
% theorem that states that under some assumptions
% a circuit is either locally optimal or can be optimized to improve along the cost function.
Given a $\cost{}$ function, a \oracle{}, and a segment length $\Omega$,
we define the rewriting semantics as a relation $\localstep\Omega C {C'}$
which rewrites the circuit $C$ to circuit $C'$.
%
% For improved readability, we treat the cost, $\Omega$, and the oracle parameters as implicit and write $\localstep\Omega{C}{C'}$.
%
\figref{circ-rewrite} shows the rewriting rules
$\rulename{Lopt}$ and $\rulename{ShiftLeft}$
for local optimization and compaction, respectively.


\input{fig/fig-rewrite}
% \input{fig/fig-rewrite-converge}



% At a high level,
% the rule \rulename{Lopt} defines one local optimization using the oracle optimizer $\oracle$
% on some circuit segment $C$ of length upto $\Omega$.
% %
% The second rule \rulename{ShiftLeft} \emph{compresses} the circuit to enable more optimizations.
% %
% We discuss these rules in detail below.


% %
% We represent this formally with the local optimization relation ${C}\longmapsto_{\cost{}, \Omega, \oracle}{C'}$,
% which holds if
% 1) $C'$ is a better quality circuit than $C$, i.e., $\costof{C'} < \costof{C}$,
% 2) $C$ and $C'$ are syntactically equivalent except for a segment of length $\Omega$
% which is rewritten according to the oracle $\mathcal{O}$,
% and
% 3) $C$ and $C'$ are semantically equivalent.
% %
% For ease of denoting the optimization relation,
% we leave the cost function $\cost{}$ and the oracle $\oracle$ implicit,
% and instead denote it as $\localstep\Omega{C}{C'}$.
% \input{fig/fig-rewrite}
% We specify the oracle and the cost function explicitly when needed.




\myparagraph{Local Optimization Rule.}
The rule $\rulename{Lopt}$ (\figref{circ-rewrite})
performs one local optimization on a circuit.
%
It takes a segment $C$ of length $\Omega$,
feeds it to the \oracle{},
and retrieves the output segment $C'$.
%
If the cost of $C'$ is lower than the cost of $C$,
then the rule replaces the segment $C$ with $C'$.
%
The rule does not modify the
remaining parts $P$ (prefix) and $S$ (suffix) of the circuit.
%

% The rule \rulename{Lopt} improves the circuit by
% performing local optimizations.
% %
% As the rule optimizes different segments of the circuit,
% it can add and remove gates and layers, which can create gaps in
% the layers of the circuit.
% %
% These gaps can stretch the circuit segments to be longer than necessary,
% making them ineligible for further optimization.

% For example,
% consider a circuit segment that can be represented in $\Omega$ layers when
% there are no gaps.
% %
% Without gaps,
% since its length is $\Omega$,
% we could apply the rule \rulename{Lopt} and optimize it using the oracle.
% %
% However, if there are gaps between the gates of the circuit segment,
% it would instead use more than $\Omega$ layers,
% making it ineligible for further optimization.
% %
% Thus, local optimizations may be missed
% if the circuit segments have gaps and are longer than necessary.

\myparagraph{Compaction Rule.}
To compact the circuit, we have the rule \rulename{ShiftLeft} (\figref{circ-rewrite}).
%
In one step,
the rule shifts a gate to the ``left''
by removing it from its current layer and adding it to the preceding layer.
%
A circuit is compact whenever all gates have been fully shifted left.
%
Formally, the \rulename{ShiftLeft} rule
considers consecutive layers $L_1$ and $L_2$ and moves a gate
$G$ from layer $L_2$ into $L_1$,
creating new layers $L_1' = L_1 \cup \{G\}$ and $L_2' = L_2 \setminus \{G\}.$
%
To maintain well-formedness,
the rule checks that no gate in the previous layer operates on the same qubits
($\compat{L_1}{\{G\}}$).
% $\forall q \in \qubits{G}.~q \not\in \qubits{L_1}$.
% $\qubits{G} \cap \qubits{L_1} = \emptyset{}$.
% This requires that none of the qubits from gate $G$ are modified by layer $L_1$,
% i.e., $\forall q' \in \mathsf{qubits}(G), q' \not\in \dom{L_1}$.
%
% The rule then moves the gate $G$ to layer $L_1$ and removes it from the layer $L_2$,
% creating the resulting circuit with layers $L'_1$ and $L'_2$.
%m

% A circuit is \defn{compact}
% if none of its gates can be shifted to the left as defined by the rule \rulename{ShiftLeft}.
% %
% In a compact circuit,
% each gate is placed as early as possible
% representing all circuit segments in the smallest possible length.
% %
% This ensures that local optimization considers as many circuit segments
% as possible, missing no segments of length $\Omega$.
% %
% While it is also possible to achieve compaction using a ``shift right'' rule,
% we arbitrarily co
% \todo{justify?, say arbitrarily?}

\if0
alternative to the rule \rulename{ShiftLeft} would be a rule \rulename{MoveRight},
which would move the gates to the right when possible
and would guarantee that each gate is placed as late as possible.
%
For our purposes of local optimization,
both rules are theoretically identical as they guarantee
smallest possible length for each segment.
%
We also observed that it makes no difference to our practical results.

\fi

% To ensure that all eligible circuit segments are considered for optimization,
% we add a \emph{compression} rule to our rewriting semantics.
% %
% This rule ensures that the circuit is \emph{tightly layered} and does not have unnecessary gaps.
% %
% A circuit is \defn{tightly layered} if all its gates circuit are \emph{left aligned}.
% %
% A gate is \defn{left aligned} if it is either in the first layer of the circuit,
% or at least one of its qubits has a gate in the layer preceding it.
% %
% We add a \defn{compression step}, denoted $\globstep{C}{C'}$, to our rewrite rules,
% and it takes a loosely layered circuit $C$ to a tightly layered circuit $C'$,
% where $C$ and $C'$ apply the same gates in the same order.
% %
% %
% The compression step considers all gates which are not left aligned and moves them to
% their preceding layer,
% until there are no such gates and the circuit is tightly layered.
% %
% When a circuit is tightly layered,
% it has no gaps and all its circuit segments have the smallest possible length,
% ensuring that local optimization considers as many of them as possible.

\myparagraph{Example.}
\input{fig/fig_compression_unlocks_optimizations}
\figref{compression_unlocks_optimizations} illustrates how
our rewriting rules can optimize a circuit with $\Omega = 2$.
%
The dotted lines in the circuit separate the four layers.
%
The optimizations in the figure implicitly use an oracle that
performs the following actions:
it removes two consecutive $H$ gates on the same qubit because they cancel each other;
similarly, it removes two consecutive $X$ gates on the same qubit.
%

In the figure,
moving from (a) to (b),
the rule \rulename{Lopt} optimizes the $2-$segment enclosed in the green box and
removes two consecutive X gates on qubit $q_0$.
%
Then,
going from (b) to (c),
we apply the rule \rulename{ShiftLeft} twice,
moving the gate $H$ gates together,
and compacting the circuit.
%
Because of this compaction,
the rule \rulename{Lopt} can step from (c) to (d),
canceling the two consecutive $H$ gates.
%

\subsection{Correspondence between local optimality and local rewrites}

It is easy to show that our definition of local optimality is consistent with the
rewriting semantics, in the sense that (1) locally optimal circuits cannot be further
rewritten (\lemref{converged}), and (2) if a circuit is not locally optimal, then it
always can be rewritten (\lemref{can-step}).
%
% \begin{lemma}
% \label{lem:well-formed}
% For every well-formed circuit $C$, if $\localstep\Omega C {C'}$ then $C'$ is well-formed.
% \end{lemma}

\begin{lemma}
\label{lem:converged}
For every circuit $C$ where $\locallyopt\Omega{C}$, there is no $C'$ such that $\localstep\Omega C {C'}$.
\end{lemma}

\begin{lemma}
\label{lem:can-step}
For every circuit $C$, either $\locallyopt\Omega C$ or $\localstep\Omega C {C'}$.
\end{lemma}



% TODO: GIVE AN EXAMPLE CIRCUIT WHERE WE OPTIMIZE A CIRCUIT WITH OPTIMIZATION RUULS

%
% We represent this formally with the local optimization relation ${C}\longmapsto_{\cost{}, \Omega, \oracle}{C'}$,
% which holds if
% 1) $C'$ is a better quality circuit than $C$, i.e., $\costof{C'} < \costof{C}$,
% 2) $C$ and $C'$ are syntactically equivalent except for a segment of length $\Omega$
% which is rewritten according to the oracle $\mathcal{O}$,
% and
% 3) $C$ and $C'$ are semantically equivalent.
% %
% For ease of denoting the optimization relation,
% we leave the cost function $\cost{}$ and the oracle $\oracle$ implicit,
% and instead denote it as $\localstep\Omega{C}{C'}$.
%
% We specify the oracle and the cost function explicitly when needed.


% \figref{circ-rewrite} defines the relation with rules.
% %
% The rule \rulename{Seg} considers a circuit $C$ (segment) of length upto $\Omega$
% and rewrites $C$ to the output $C'$ of the oracle,
% but only if the oracle improves the cost of the circuit.
% %
% The rule assumes implicitly that the oracle does not change the circuit semantically.
% %
% The rule \rulename{Circ} considers a circuit consisting of three segments $P; C; S$,
% where the middle segment $C$ has length upto $\Omega$.
% %
% It rewrites the middle segment $C$ to segment $C'$ such that $\localstep\Omega{C}{C'}$,
% leaving the segments $P$ and $S$ unchanged.
% %
% Note that in one step, the relation only ever rewrites one segment whose length is bounded by $\Omega$ .


%
% Thus, if $\localstep\Omega{C}{C'}$ then $\costof{C'} < \costof{C}$ (by definition).
%
%
% The relation encodes the space of local optimizations that can be performed by a given oracle.
%


% ====================================================================================================
% ====================================================================================================
% ====================================================================================================


\subsection{Termination}
%
Given any circuit, we intend to use the rewriting semantics to produce an equivalent
locally optimal circuit.
%
However, this approach only succeeds if the rewriting semantics terminates, i.e., if
eventually no further rewrites are possible.
%
(Note that when our semantics terminates, \lemref{can-step} guarantees that the
circuit is locally optimal.)
%
Below are two examples where termination is not guaranteed.
\begin{enumerate}[leftmargin = *]
\item \textbf{Infinite Decrease in Cost}:
The cost function could be such that it decreases infinitely.
For instance,
consider the (contrived) cost function $\costof{C} = \prod_{\textsf{Rz}(\theta) \in C} \theta$,
which takes the product of the angles of gates $\textsf{Rz}(\theta)$ performing Z-axis rotations.
%
Suppose we have a circuit containing a single gate $\textsf{Rz}(1)$, setting $\theta = 1$
and its cost is $1$.
%
We can replace the $\textsf{Rz}(1)$ gate by  two consecutive $\textsf{Rz}(1/2)$ gates,
which achieve the same rotation,
but their combined cost is $1/4$.
%
This process can repeat infinitely,
halving the angle at each step, and the cost function would keep decreasing.
%
For this circuit and cost function, our rewriting semantics does not terminate.

\item \textbf{Cycles Due to Cost Function}:
A local optimization on one segment can increase the cost of a nearby segment,
creating an infinite loop of local optimizations.
%
To demonstrate this, consider the badly behaved cost function:
$\costof{C} = 0$ if $|C|$ is even, and
otherwise $\costof{C} = 1$.
%
Now, ``optimizing'' one segment (to toggle its number of gates from odd to even)
can cause a nearby overlapping segment
to toggle from even to odd, potentially repeating forever.
%
\end{enumerate}


% %
% We first discuss those cost functions for which the rewriting semantics can
% not terminate, because a locally optimal circuit does not even exist.
% %
% Then we discuss a class of cost functions for which our semantics terminates,
% producing locally optimal circuits.
% %
% % From \lemref{can-step}, we could attempt to obtain a locally optimal circuit by applying rewrite
% % rules until no more rewrites are possible.
% % %
% % However, for arbitrary cost functions, it is not guaranteed that these rewrites will ``terminate'' (i.e.,
% % converge upon a locally optimal circuit).




% We next consider whether or not local rewrites can be used to produce locally optimal
% circuits.
% %
% Our goal is to iteratively apply the rules \rulename{Lopt} and \rulename{ShiftLeft}
% until no more rules can be applied, at which point the circuit will be locally
% optimal.
% %
% In this section, we show that this approach is viable, but only if we place reasonable
% restrictions on the $\cost{}$ function.



\myparagraph{Ensuring termination.}
We can prove that our semantics terminates under certain conditions on the cost function.
%
First, we require $\costof{C} \in \mathbb{N}$; this guarantees that the cost cannot decrease infinitely.
%
Second, we require that the cost function is \defn{additive} according to the following definition.
\begin{definition}
A function $\cost{}: \textit{Circuit} \to \mathbb{N}$ is \defn{additive} iff both of the following conditions hold:
\begin{enumerate}
    \item $\costof{C_1 ; C_2} = \costof{C_1} + \costof{C_2}$ for all circuits $C_1$ and $C_2$.
    \item $\costof{\langle L_1 \cup L_2 \rangle} = \costof{\langle L_1 \rangle} + \costof{\langle L_2 \rangle}$ for all layers $L_1$ and $L_2$ such that $\compat{L_1}{L_2}$.
    % $\qubits{L_1} \cap \qubits{L_2} = \emptyset{}$.
\end{enumerate}
\end{definition}

Note that all cost functions that take a linear combination of counts
of each gate in the circuit are additive.
%
These include metrics
such as gate count (number of gates), $\mathsf{T}$ count (number of $\mathsf{T}$ gates), $\mathsf{CNOT}$ count (number of $\mathsf{CNOT}$ gates),
and two-qubit count (number of two-qubit gates).

For additive cost functions, we prove (\thmref{convergence}) that the rewriting semantics always
terminates.

\begin{theorem}[Termination]
\label{thm:convergence}
Let $\cost{}: \textit{Circuit} \to \mathbb{N}$ be an additive cost function.
%
For any initial circuit $C_0$,
there does not exist an infinite sequence of circuits such that
$$C_0 \overset{\Omega}\optstep C_1 \overset{\Omega}\optstep C_2 \overset{\Omega}\optstep \cdots$$
where each $\localstep{\Omega}{C_i}{C_{i+ 1}}$ represents a step of our rewriting semantics.
\end{theorem}

To prove \thmref{convergence}, we define a ``potential'' function
$\Phi: \textit{Circuit} \to \mathbb{N} \times \mathbb{N}$
and show that each step of our rewriting semantics decreases the potential function,
with the ordering $\Phi(C') < \Phi(C)$ defined lexicographically over $\mathbb{N} \times \mathbb{N}$.
%
A suitable definition for $\Phi$ is as follows.
\[
\begin{array}{c}
  \Phi(C) \defeq \left(\costof{C}, \mathsf{IndexSum}(C)\right)
\end{array}
\quad\text{where}\quad
\begin{array}{c}
  \mathsf{IndexSum}(C) \defeq \sum_{i} i |L_i| \\[1ex]
  C = \langle L_0, L_1, \ldots \rangle
\end{array}\]
This potential function has two components:
(1) the cost of the circuit, which decreases as optimizations are performed, and
(2) an ``index sum'', which decreases as gates are shifted left.
%
Together these components guarantee that the potential function decreases at each step, 
ensuring termination.
%
We provide the full proof in
\iffull
\appref{lem-pot-dec}.
\else
the Appendix.
\fi

%
% Note that $\Phi(-)$ ranges over tuples $\mathbb{N} \times \mathbb{N}$,
% and we define .
%



\if0
\subsection{I don't think we need this}

there exists $C^\text{OPT}$ such that $C \Downarrow C^\text{OPT}$.
%
Specifically, we show that:
\begin{theorem}[Termination]
\label{thm:convergence}
For any additive function $\cost{}: \textit{Circuit} \to \mathbb{N}$ and any well-formed circuit $C$,
there exists $C^\text{OPT}$ such that $C \Downarrow C^\text{OPT}$.
\end{theorem}

\begin{proof}
We proceed by induction over circuits ordered by $\Phi$.
%
First, if $\locallyopt{\Omega}{C}$ then $C \Downarrow^\Omega C$, i.e., $C = C^\text{OPT}$, and we are done.
%
Otherwise, by \lemref{can-step}, we have $\localstep\Omega C {C'}$, and therefore by \lemref{pot-dec1} we
have $\Phi(C') < \Phi(C)$.
%
Inductively we have $C' \Downarrow^\Omega C^\text{OPT}$ which (together with $\localstep\Omega C {C'}$)
yields $C \Downarrow C^\text{OPT}$.
\end{proof}


%
We prove this using an approach based on a potential function.
%
The idea is to define a suitable function $\Phi(C)$ which decreases after each step $\localstep\Omega C {C'}$,
making a termination proof possible via induction.
%
We specifically use the following potential function.
\[
\begin{array}{c}
  \Phi(C) \defeq \left(\costof{C}, \mathsf{IndexSum}(C)\right)
\end{array}
\quad\text{where}\quad
\begin{array}{c}
  \mathsf{IndexSum}(C) \defeq \sum_{i} i |L_i| \\[1ex]
  C = \langle L_0, L_1, \ldots \rangle
\end{array}\]
This potential function has two components:
(1) the cost of the circuit, which decreases as optimizations are performed, and
(2) an ``index sum'', which decreases as gates are shifted left.
%
Note that $\Phi(-)$ ranges over tuples $\mathbb{N} \times \mathbb{N}$, and therefore we define
$\Phi(C') < \Phi(C)$ lexicographically.
%
We can then prove that the potential decreases on every step, as presented in \lemref{pot-dec1}.

% TODO: Given $C$.  Any finitely many application of the rewrite rules lead to a locally optimal circuit. We can rewrite $C$ to a locally optimal circuit $C^{OPT}$ with finitely many applications of the rewrite rules; there exists  $C ->^* C'$, where $C'$ is locally optimal.

\begin{lemma}
\label{lem:pot-dec1}
For any additive function $\cost{}: \textit{Circuit} \to \mathbb{N}$,
% and any well-formed circuit $C$,
if $\localstep\Omega{C}{C'}$ then $\Phi(C') < \Phi(C)$.
\end{lemma}
\begin{proof}
% If $\locallyopt\Omega{C}$, then $C = C^\text{OPT}$ and we are done; otherwise,
% by \lemref{can-step} we have $\localstep\Omega{C}{C'}$.
%
There are two cases
for $\localstep\Omega{C}{C'}$:
either \rulename{Lopt} or
\rulename{ShiftLeft}.
%
In each case we show $\Phi(C') < \Phi(C)$.

In the case of \rulename{Lopt}, we have $\localstep\Omega C {C'}$ where
$C = (P ; C'' ; S)$ and $C' = (P ; \oracle{}(C'') ; S)$.
%
In $C'$, the segment $C''$ has been improved by one call to the \oracle{},
i.e., $\costof{\oracle{}(C'')} < \costof{C''}$.
%
Because the \cost{} function is additive, we have that
$\costof{C'} = \costof{P ; \oracle{}(C'') ; S} < \costof{P ; C'' ; S} = \costof{C}$.
%
This in turn implies $\Phi(C') < \Phi(C)$ due to lexicographic ordering on the
potential function.

% a segment of $C$ is improved by one
% call to the \oracle{}.
% %
% Because the \cost{} function is additively monotonic, we therefore have
% that $\costof{C'} < \costof{C}$, which in turn implies that
% $\Phi(C') < \Phi(C)$ due to lexicographic ordering.

% To show that the rewrite system terminates on any given circuit $C$,
% we define a well-founded order $\prec$ on the set of circuits
% and show that each rewrite descends down the order,
% i.e., for each $\localstep\Omega{C}{C'}$, $C' \prec C$.
% %
% Because a well-founded order can not have infinitely descending chains,
% the number of possible rewrites starting from the circuit $C$ are finite,
% showing that the circuit $C$ can be made locally optimal in a finite number of steps.
% %

In the case of \rulename{ShiftLeft}, we have $\localstep\Omega C {C'}$ where
$C = (P ; \langle L_1, L_2 \rangle ; S)$ and $C' = (P ; \langle L_1', L_2' \rangle ; S)$
and $L_1' = L_1 \cup \{G\}$ and $L_2' = L_2 \setminus \{G\}$.
%
Because the cost function is additive, we have $\costof{\langle L_1, L_2 \rangle} = \costof{\langle L_1', L_2' \rangle}$
and therefore $\costof C = \costof {C'}$.
%
To show $\Phi(C') < \Phi(C)$, due to the lexicographic ordering, it remains to show
$\mathsf{IndexSum}(C') < \mathsf{IndexSum}(C)$.
%
This in turn follows from the definition of $\mathsf{IndexSum}$; in particular, plugging
in $|L_1'| = |L_1| + 1$ and $|L_2'| = |L_2| - 1$ we get
$\mathsf{IndexSum}(C') = \mathsf{IndexSum}(C) - 1$.
%
Thus we have $\Phi(C') < \Phi(C)$.



% To define the order $C \prec C'$,
% we consider the two rewrite rules \rulename{Lopt} and \rulename{ShiftLeft}.
% %
% The rule \rulename{Lopt} improves the cost of some circuit segment of the circuit $C$.
% %
% Because our cost function $\costof{}$ is nice and assigns,
% improving the cost of a circuit segment also improves the cost of the whole circuit.
% %
% %

% The rule \rulename{ShiftLeft} reduces the layer index of some gate in the circuit.
% %
% For circuit $C = \langle{L_0, \dots L_n}\rangle$,
% we define \todo{a potential function...} $\mathsf{IndexSum} (C)$ as the sum of layer indices of each gate in the circuit.
% %
% The rule \rulename{ShiftLeft} reduces the $\mathsf{IndexSum}$ of the circuit by $1$,
% because it moves a gate in some layer $i$ to layer $i - 1$,
% reducing its layer index without changing any other gate.
% %

% We define $C \prec C'$ as $(\costof{C}, \mathsf{IndexSum}(C)) < (\costof{C'}, \mathsf{IndexSum}(C'))$,
% where $<$ is the lexicographic ordering on the tuple of natural numbers.
% %
% The order $\prec$ is well-founded because the relation compares
% elements in the cartesian product of natural numbers.
% %

% Both rewrite rules make progress along the descending chains w.r.t. the ordering $\prec$.
% %
% The rule \rulename{ShiftLeft} reduces the $\mathsf{IndexSum}$ of the circuit
% and keeps the cost unchanged.
% %
% The rule \rulename{Lopt} reduces the cost of the circuit.
% %
% Even though rule \rulename{Lopt} may arbitrarily affect the index sum,
% the rule always descends down a chain because it reduces the cost
% and cost comes first in the lexicographic ordering.
\end{proof}


As a result of \lemref{pot-dec1}, we know that every rewrite step makes progress along a
descending chain of the ordering given by $\Phi$.
%

% This guarantees that the optimizer has been considered on all nearby gates,
% i.e., gates that are at a distance of less than $\Omega$.
% %
% In practice,
% most optimizations can be found by considering relatively small values of $\Omega$,
% thus considering larger segments is unnecessary and takes too much time.


\sr{TODO: weave: these are helpful sentences, they should go somewhere.

\begin{quote}
Local optimality is a practical and flexible notion of optimality
as it can be used as a quality guarantee for any optimizer,
and thus can be used for different gate sets and cost functions.
%
In our evaluation, we demonstrate this with
four different oracle optimizers and three different gate sets.
%

In theory,
it is not immediately clear how we can use the rewriting
rules to create a locally optimal circuit from a given circuit.
%
A priori,
a locally optimal circuit may not even exist because
it is possible that the rewrite rules can lead to a cycle.
%


it is not immediately clear if every
circuit can be rewritten to a locally optimal circuit
and if so, how can we find it efficiently.
%
Consider for example
\todo{show why it may not exist}
\end{quote}
}


% \myparagraph{Additive Cost Functions.}
% Our definitions of local optimality and relative local optimality make
% no assumptions on the cost function.
% %
% In the rest of the paper, we focus our attention on cost functions
% that map circuits to natural numbers.
% %
% Most interesting cost functions satisfy this constraint, e.g., the
% total number of gates in a circuit, total weight of the gates where
% weight could denote some property such as the time units needed for
% that gate, or the depth of the circuit, etc.
% %
% If costs are not natural numbers, we can scale them (by additing and
% multiplying with appropriately chosen constants) to obtain natural
% numbers.

% In our algorithm for computing local optimality, we assume that cost
% functions are additive under circuit concatenation.
% %
% \begin{definition}[Additive Cost Functions]
% \label{def:additive-cost}

% We say that a cost function $\kwcost{\cdot}$ from circuits to costs is
% additive if the function maps circuits to positive natural numbers
% such that the cost of the concatenation of any two circuits $C_1$ and
% $C_2$ is equal to the cost of individual circuits, i.e.,
% \[
% \kwcost{\circuitcon{C_1}{C_2}} = \kwcost{C_1} +  \kwcost{C_2}.
% \]
% \end{definition}



\sr{ TODO: this is older brainstorm text. Still to weave, perhaps into algorithm section.
\begin{quote}
The reader might ask why we would want to delay the compression until after the optimization.  Why not interleave?

Here is an example that demonstrates why this is a bad idea

Suppose we split the circuit into A and B ``halves''
We then split B into B1 and B2 and optimize
When melding B1 and B2, we realize that we can compress by moving some gate from B2 to all the way into B1.
This triggers a full reoptimization of B, because many segments have changed.
Good, so we re-optimize B.
Now we meld with A and we realize that all those gates can again be moved to the beginning of A.  So now, we have to reopt A and B, effectively throwing away the intermediate optimization work.

The point is that the optimized prematurally without knowing the
global opportunity for compression.

TECHNICAL REASON: we are checking segments multiple times, in fact once at every recursion level.
\end{quote}
}

% \subsection{Past section}
\fi
