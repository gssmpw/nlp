\if0
\paragraph{TODO: WEAVE: THREE QUESTIONS}
\begin{itemize}
    \item Does a locally optimal circuit exist?
    \item How does the quality of a locally optimal circuit compare with a global
    optimality?
    \item Is it possible to find a locally optimal circuit efficiently?
    \item Does our local optimization technique work well with different optimizers?
\end{itemize}

... our results are:
\begin{itemize}
    \item Definition of local optimality (semantics)
    \item Evidence that local optimality is, in practice, ``just as good
    as global optimality'' in terms of quality
    \item Algorithm for local optimality and proof of (nearly) linear time
    \item Empirical evaluation showing that our algorithm scales linearly
    with circuit size.
\end{itemize}
\fi

% quantum importance
Quantum computing holds the potential to solve problems in fields such
as chemistry simulation~\cite{Feynman82,Benioff80},
optimization~\cite{childs2017quantum, peruzzo2014variational},
cryptography~\cite{shor1994algorithms}, and machine
learning~\cite{biamonte2017quantum, schuld2015introduction}
%
that can be very challenging for classical computing techniques.
%
Key to realizing the advantage of quantum computing in these and
similar fields is achieving the scale of thousands of qubits and
millions of quantum operations (a.k.a., gates), often with high
fidelity (minimal error).
%
%high-fidelity quantum operations
~\cite{hoefler2023disentangling, gidney2021factor, alexeev2021quantum}.
%
Over the past decade, the potential of quantum computing and the
challenges of scaling it have motivated much work on both hardware and
software.
%
On the hardware front, quantum computers based on
%
superconducting circuits~\cite{kjaergaard2020superconducting},
%
trapped ions~\cite{monroe2021programmable, moses2023race}, and
%
Rydberg atom arrays~\cite{ebadi2021quantum, scholl2021quantum} have
advanced rapidly, scaling to hundreds of qubits and achieving
entanglement fidelity over $99\%$.
%
On the software front, a plethora of programming
languages,
%
optimizing compilers, and run-time environments have been proposed,
both in industry and in academia
(e.g.,~\cite{selinger-towards-2004,quipper-2013,prz-qwire-2017,Nam_2018,tket-2020,silq-2020,hietala2021verified,yc-tower-2022,twist-2022,quartz-2022,qiskit-2023,v+qunity-2023}).




%% % quantum importance
%% Quantum computers hold the potential to solve problems that are intractable for classical computers in fields such as chemistry simulation~\cite{Feynman82,Benioff80}, optimization~\cite{childs2017quantum, peruzzo2014variational}, cryptography~\cite{shor1994algorithms}, and machine learning~\cite{biamonte2017quantum, schuld2015introduction}.
%% %
%% However, these applications often require thousands of qubits and
%% millions of gates, often with high fidelity
%% %
%% %high-fidelity quantum operations
%% ~\cite{hoefler2023disentangling, gidney2021factor, alexeev2021quantum}.
%% % the next sentence seems to contradict
%% %, which are still beyond the capabilities of today's quantum computer systems.
%% %
%% Quantum devices based on superconducting circuits~\cite{kjaergaard2020superconducting}, trapped ions~\cite{monroe2021programmable, moses2023race}, and Rydberg atom arrays~\cite{ebadi2021quantum, scholl2021quantum} have advanced rapidly in recent years, scaling to hundreds of qubits and achieving entanglement fidelity over $99\%$.
%

%
Due to the limitations of modern quantum hardware and the need for
scaling the hardware to a larger number of gates, optimization of
quantum programs or circuits remain key to realizing the potential of
quantum computing.
%
The problem, therefore, has attracted significant research.
%
Starting with the fact that global optimization of circuits is QMA
hard and therefore unlikely to succeed, Nam et al
developed a set of heuristics for optimizing quantum programs or
circuits~\cite{Nam_2018}.
%
Their approach takes at least quadratic time in the number of gates
in the circuit, making it difficult to scale to larger circuits,
consisting for example hundreds of thousands of gates.
%
In followup work Hietala et al.~\cite{hietala2021verified} presented a
verified implementation of Nam et al.'s approach.
%
In more recent work Xu et al.~\cite{quartz-2022} presented techniques for
automatically discovering peephole optimizations (instead of human-generated heuristics) and applying them to optimize a circuit.
%
Xu et al.'s optimization algorithm, however, requires exponential time
in the number of the optimization rules and make no quality guarantees
due to pruning techniques used for controlling space and time
consumption.
%
In follow-up work Xu et al.~\cite{queso-2023} and Li et
al~\cite{li2024quarl} improve on Quartz's run-time.
%
All of these optimizers can take hours to optimize moderately large
circuits (\secref{eval})
%
and cannot make any quality guarantees.
%


%% Classical quantum software~\cite{chong2017programming} plays a pivotal
%% role in enabling meaningful computation on these emerging hardware
%% platforms by deeply optimizing the quantum circuits for performance
%% and fault tolerance.
%% %
%% Compilers that can optimize quantum circuits are one of the crucial components in the software toolchain,
%% because the kinds and counts of gates in a quantum circuit are
%% a key predictor of the running time and fidelity of that circuit.
%% %
%% However, quantum circuit optimization is a hard classical problem and can require significant computational resources,
%% especially for large circuits,
%% of the kind that are expected to yield improvements over classical computers.
%% %
%% Thus, the development of a large-scale, reliable quantum computer capable of solving practical problems
%% is expected to be coupled with high-performance  optimizing compilers.
%% %
%which optimizes, controls, and calibrates operations on the quantum processor~\cite{ding2022quantum}. Advances in this classical compilers and other co-processing system
%, both in software and hardware,
%are needed to enable large-scale fault-tolerant computation~\cite{alexeev2024quantum}.

%This co-design effort encompasses the development of improved quantum computer hardware, which currently involves platforms with hundreds of qubits, including leading platforms such as superconducting circuits, trapped ions, and neutral atoms.
% compiling importance
%On the other hand, we need better algorithms that are both efficient and robust to errors. While researchers are developing more efficient quantum algorithms, there is also a trend to shift some of the computational burden from quantum computers to more reliable classical computers due to current hardware limitations. This trend includes techniques such as circuit cutting, algorithms with adaptive measurements, and variational quantum algorithms. Among these techniques, one promising direction—akin to developments in classical computing—is to create more powerful classical middleware to interface between quantum algorithms and quantum hardware. This is precisely what we aim to contribute in this paper. We present a compiler optimization algorithm designed for practically useful quantum circuits, which are often very large-scale.

% compiling hardness
%% A quantum compiler takes a representation of a logical quantum circuit and outputs a sequence of instructions compatible with the quantum hardware's instruction set. Circuit optimization techniques can be integrated into the compiler to reduce the quantum resources needed to perform the same computing task.
%% %
%% These optimizations, however, require a significant amount of computation using classical computers.
%% %
%% In fact, global optimization of arbitrary quantum circuits is QMA-hard, implying that efficient optimizers capable of delivering globally optimal circuits are unlikely to exist.
%% % existing compilers and inefficiency in searching
%% State-of-the-art quantum circuit optimizers suffer from poor efficiency and struggle to optimize large-scale circuits within a reasonable amount of time.
%% %
%% Among them, rule-based optimizers are the most popular
%% due to their relative efficiency~\cite{Nam_2018, hietala2021verified, quartz-2022, queso-2023}.
%% %
%% These optimizers repeatedly substitute subcircuits of a circuit with optimized versions according to a predefined set of rules.
%% %
%% Other optimizers, such as \feyntool{},
%% combine rule applications with techniques like phase-folding,
%% which exploit the inherent properties of quantum gates to analyze and optimize circuits~\cite{amy2019formal}.
%% %
%% However, these optimizers require at least quadratic time in the size of the circuit~\cite{Nam_2018, hietala2021verified,amy2019formal}, and some, such as search-based optimizers, attempt to explore exponentially large search spaces~\cite{quartz-2022, queso-2023}.
%% %



% 1. introduce algo 2. local opt 3. efficient linear cost 4. numerical expeiments 3 local optimizers
% now we do our stuff:
%

Given this state of the art and the fact that global optimality is unlikely
to be efficiently attainable due to its QMA hardness~\cite{Nam_2018},
we ask:
\emph{\textbf{is it possible to offer a formal quality guarantee while also ensuring 
efficiency?}}


In this work, we answer this question affirmatively and thus bridge quality
and efficiency guarantees.
%
We first present a form of ``local optimality'' and its slightly
weaker form called ``segment optimality'', and present a rewriting
semantics for achieving local optimality.
%
For the rewriting semantics, we consider a reasonably broad set of
cost functions (as optimization goals) and
%
prove that saturating applications of local rewriting rules yield
local optimality.
%
To ensure generality, we formulate local optimality in an
``unopinionated'' fashion in the sense that we do not make any
assumptions about which optimizations may be performed by the local
rewrites.
%
Instead, we defer all optimization decisions to an
abstract \defn{oracle} optimizer that can be instantiated with an
available optimizer as desired.
%
Local optimality differs from global optimality in the sense that it
requires that each segment of the circuit, rather than the global
circuit, is optimal with respect to the chosen oracle.
%%
We believe that this is a strong optimality guarantee, because it
requires optimality of each and every segment of the circuit.


Our rewriting semantics formalizes the notion of local optimality, but
it does not yield an efficient algorithm.
%
We present a local-optimization algorithm, called \algname{}
(Optimize-and-Compact) that takes a circuit and optimizes it in
rounds, each of which consists of an optimization and compaction
phase.
%
The optimization phase takes the circuit and outputs a segment-optimal
version of it, and the compaction phase compacts the circuit by
eliminating ``gaps'' left by the optimization, potentially enabling new
optimizations.
%
The \algname{} algorithm repeats the optimization and compaction
phases until convergence, where no more optimizations may be found.
%

To ensure efficiency, the optimization phase of \algname{} employs a
variant of the circuit cutting technique that was initially developed
for simulation of quantum circuits on classical
hardware~\cite{circuit-cutting-2020,tang-cutqc-2021,bravyi-future-qc-2022,k+cutting-2024}.
%
Specifically, our algorithm cuts the circuit hierarchically into
smaller subcircuits, optimizes each subcircuit independently, and
combines the optimized subcircuits into a locally optimal circuit.
%
To optimize small segments, the algorithm uses any chosen oracle and
does not make any restrictions on the optimizations that may be
performed by the oracle.
%%
The approach can therefore be used in conjunction with many existing
optimizers that support different gate sets and cost functions.
%
By cutting the circuit into smaller circuits, the algorithm ensures
that most of the optimizations take place in the context of small
circuits, which then helps reduce the total optimization cost.
%
But optimizing subcircuits independently can miss crucial
optimizations.
%
We therefore propose a \defn{melding} technique to ``meld'' the
optimized subcircuits by optimizing over the cuts.
%
To ensure efficiency, our melding technique starts at the cut,
optimizes over the cut, and proceeds deeper into the circuit only as
needed.
%

The correctness and efficiency properties of our cut-and-meld
algorithm are far from obvious.
%
In particular, it may appear possible that 1) the algorithm misses
optimizations and 2) the cost of meld operations grows large.
%
We show that none of these are possible and establish that the
optimization algorithm guarantees segment optimality and accepts a
linear time cost bound in terms of the call to oracle.
%
For the efficiency bound, we use an ``output-sensitive'' analysis
technique that charges costs not only to input size but also to the
cost improvement, i.e., reduction in the cost (e.g., number of gates)
between the input and the output.
%
%% Taken together we are able to bound the time for the optimization
%% phase of the algorithm in terms of the size of the circuit and the
%% improvement in the cost function being targeted, which is linear in
%% many casse of interest (e.g., when optimizing count of all or some
%% gates).
%% %
Even though the algorithm can in principle take a linear number of
rounds, this appears unlikely, and we observe in practice that it
requires very few rounds (e.g., less than four on average).


%\ur{Update needed based on experiments.}

To evaluate the effectiveness of local optimality, we implement
the \algname{} algorithm
%, and
%instantiate it with two state-of-the-art
%optimizers as oracles: \voqc{} ~\cite{hietala2021verified}
%and~\feyntool{}~\cite{amy2019formal}.
%
and evaluate it by considering a variety of quantum circuits.
%
%in two different, broadly accepted gate sets.
%
Our experiments show that our \algname{} implementation improves
efficiency, by more than one order of magnitude (on average), and
closely matches or improves optimization quality.
%
These results show that local optimality is a reasonably strong
optimization criterion and our cut-and-meld algorithm can be a
efficient approach to optimizing circuits.
%
Because our approach is generic, and can be tooled to use existing
optimizers, it can be used to amplify the effectiveness of existing
optimizers to optimize large circuits.
%

Specific contributions of the paper include the following.
\begin{itemize}
    \item The formulation  of local optimality and its formal definition.

\item A rewriting semantics for local optimality and proofs that saturating rewrites yield locally optimal circuits.

    \item An algorithm \algname{} for optimizing quantum circuits locally.

\item Proof of correctness of \algname{}.
    
  \item Run-time complexity bounds and their proofs for  the \algname{} algorithm.
    
    \item Implementation and a comprehensive empirical evaluation of \algname{}, demonstrating
    the benefits of local optimality and giving experimental evidence for the practicality of the approach.
\end{itemize}


We note that due to space restrictions, we have omitted proofs of
 correctness and efficiency;
\iffull
we provide these proofs and additional 
experiments in the Appendix.
\else
we provide these proofs and additional 
experiments in the Appendix submitted as supplementary material.
\fi
