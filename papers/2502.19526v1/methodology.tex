
\label{sec:methodology}

%
% The optimizer \coamwith{\feyntool{}} optimizes for the T count of circuits
% and the optimizers \coamwith{\quartz{}}, and \coamwith{\queso{}} optimize the gate count.


% The optimizer \coamwith{\feyntool{}} runs with a default segment size $\Omega = 120$.
% This segment size delivers the best running times and circuit quality.
%
For \coamwith{\feyntool}, we choose a default segment size of $\Omega = 120$,
which we found delivers the best running times and circuit quality.
%
% In \secref{vary-segment},
% we present an experiment that considers different values of $\Omega$,
% which shows that a variety of segment sizes deliver similar output quality in comparable running times.
%
We study the impact of $\Omega$ in more detail in \secref{var-segment}, and,
in particular, observe that a variety of segment sizes deliver similar output
quality in comparable running times.
%
In \secref{comp-feyn},
we evaluate the optimizer \coamwith{\feyntool{}}
and show that it guarantees $\Omega-$optimality in short running times,
especially because \feyntool{}, being a polynomial-time optimizer,
finishes quickly for small circuits~\cite{amy2019formal}.

Unlike \feyntool{},
the \quartz{} and \queso{} optimizers require exponential time
and do not terminate quickly for small circuits.
%
For instance,
\quartz{} takes more than $24$ hours on a circuit of size $48$.
%
\queso{} takes 18 seconds to terminate on the same circuit,
and its running time increases to an hour on a circuit of size 96 (a $20\times$ increase),
which further increases to around six hours for a circuit of size 326.
%
Expecting long termination times,
both optimizers provide a timeout functionality,
enabling users to halt optimization within a timeout.

Using \quartz{} and \queso{} with \coam{},
our goal is to guarantee $\Omega-$optimality relative to a timeout,
where we can show that the optimizers cannot improve any $\Omega-$segment
of the circuit within a given amount of time.
%
To achieve this,
we run the algorithm with a timeout policy.
%
The timeout policy, parameterized by  a ``per-gate'' timeout $t$,
allows \quartz{}/\queso{} to optimize a segment $W$,
until they do not find further optimizations for $\sizeof{W}*t$ seconds.
%
When this time has elapsed,
the output segment is optimal w.r.t. \quartz{}/\queso{}, at least for $\sizeof{W}*t$ seconds.
%
The timeout policy works because once a segment is optimized under the policy,
it cannot be further optimized with the same policy,
because running the optimizers again for $\sizeof{W}*t$ seconds will not find any optimizations.
%
We use \quartzt{t} and \quesot{t} to represent the optimizers \quartz{} and \queso{}
with the timeout policy.
%
We use them to get the following guarantees.
%

We develop the optimizer \coamwith{\quartzt{t}},
which returns $\Omega-$optimal circuits relative to the optimizer $\quartzt{t}$.
%
$\Omega-$optimality relative to \quartzt{t} guarantees that running \quartz{} on
a segment $W$ of depth $\Omega$ does not discover any optimizations in time $\sizeof{W} * t$.
%
For this optimizer,
we choose the segment depth $\Omega = 6$
because (by default) \quartz{} uses
equivalence rules for circuits up to size $6$~\cite{quartz-2022}.
%
By setting the segment depth to $6$,
our optimizer feeds all segments of size $6$ to \quartz{},
giving it enough scope to discover optimizations.
%
To analyze the performance of \coamwith{\quartzt{t}},
we run it to completion on all benchmarks
and record the output quality and running time.
%
We then run vanilla \quartz{} for the same amount of time and examine
the difference in the number of optimizations.
%
\secref{comp-quartz} shows the result of this experiment with $t = 0.01s$.

% When studying the optimizers \coamwith{\quartz{}} and \coamwith{\queso{}},
% we found that they have huge running times,
% even when $\Omega$ is small
% (for $\Omega = 4$,
% we tested that \coamwith{\queso{}} runs for at least ten hours on a benchmark with $5000$ gates).
% %
% This is because both $\quartz{}$ and $\queso{}$ are exponential time algorithms
% and do not terminate quickly for small circuits.
% %
% However, both tools deliver excellent optimizations
% even when stopped early with a timeout.
% %
% To utilize their optimizations in a scalable fashion,
% we define the optimizers \quartzt{t} and \quesot{t} that implement a timeout policy.
%

The optimizer \coamwith{\quesot{t}} runs similarly
and guarantees that on any $\Omega-$segment $W$ of the output circuit,
running \queso{} for time $\sizeof{W} * t$ does not yield any optimizations.
%
We choose the segment depth to $6$, because the rules in \queso{} (for the Nam gate set),
are of size $6$ and segments of depth $6$ give \queso{} enough scope to apply its optimizations.
%
To evaluate \coamwith{\quesot{t}},
we run it to completion on all benchmarks,
recording the output quality and running time.
%
Then, we run standard \queso{} for the same amount of time on each benchmark
and study the difference in the number of optimizations.
%
\secref{comp-queso} shows the result of this experiment with $t = 0.005s$.


% \paragraph{\coam{} configurations.}
% %
% For all our experiments, we set the segment depth of \coam{} to $6$,
% i.e., $\Omega = 6$.
% %
% We choose this value because
% it aligns with the default optimization behavior of \quartz{},
% as it only focuses on sub circuits of size $6$ at any optimization step.
% %
% As described in the \quartz{} paper,
% the size $6$ is a sweet spot for it,
% since increasing this size hinders time performance,
% and decreasing it harms circuit optimizations~\cite{quartz-2022, queso-2023}.
% %
% By setting the segment depth to $6$,
% our algorithm feeds all subcircuits of size $6$ to \quartz{}
% giving it enough scope to apply its optimizations.
% %
% \footnote{We note that this size $6$ is for the Nam gate set that we use in this paper.}

% Using this segment depth, we consider three configurations
% of \coam{}, each with a different timeout for the oracle.
% %
% We choose these timeouts to cover multiple orders of magnitude for oracle
% timeouts, specifically by giving the oracle $0.01$s, $0.1$s, and
% $1$s (respectively) per unit of $\Omega$.
% %
% \begin{itemize}

% \item \coamwith{\quartzt{0.06}}
% refers to our implementation of \coam{} with \quartz{} running as oracle
% where each call to \quartz{} is capped to complete in 0.06 seconds.

% \item \coamwith{\quartzt{0.6}}: \coam{} with \quartz{} oracle,
% with upto 0.6 seconds per call.

% \item \coamwith{\quartzt{6}}: \coam{} with \quartz{} oracle,
% with upto 6 seconds per call.

% % \item \coamwith{\quesot{1}} refers to our implementation of \coam{} with \queso{} running
% % as oracle where each call to \queso{} is capped to complete in 1 second.
% % \footnote{1 second is the minimum timeout \queso{} supports.}
% \end{itemize}

% We note that our integration with \quartz{}
% introduces overhead to the running time
% of our algorithm
% because each call to \quartz{} changes the circuit representation
% and also pays for the initialization cost of \quartz{}.
% %
% To mitigate this overhead,
% we send subcircuits of size $10*\Omega*n$ to \quartz{},
% instead of the size $2*\Omega*n$ described in the algorithm,
% where $\Omega$ represents \coam{}'s parameter and $n$ is the
% number of qubits.
% %
% By sending larger circuits to \quartz{},
% we ensure that the overhead does not dominate
% the time to execute one function call to \quartz{}.
% %
% %This reduces the number of calls and thus reduces the cross-language
% %overhead.
% %
% When the per call timeout is larger (i.e, 0.6 seconds, or 6 seconds),
% we send subcircuits of
% size $2*\Omega*n$.

% We also cache the rules used by quartz to reduce this overhead.
% \ur{I did not understand the last sentence with 2Omega.}

% \jr{revisit}



% The \queso{} optimizer~\cite{queso-2023}, which is written in Java, does
% not naturally
% %
% We therefore integrate \queso{} via the operating system.
% %
% Specifically, to invoke \queso{} on a subcircuit, our \coam{}
% implementation writes the QASM representation to a file and
% calls \queso{} by using a system call.
% %
% This system call, in turn, writes its output to another file, which
% our \coam{} implementation reads.
% %
% Because the overhead is large and difficult amortize by increasing
% subcircuit sizes, our integration with \queso{} incurs significant
% overhead.
% %
% Nevertheless, this integration demonstrates the feasibility of
% integrating with existing optimizers either through cross-language
% interoperability features (when feasible) or through systems calls.
% %

% For this reasons, we compare with \queso{} only on a few benchmarks.
%
% \ur{This last sentence does not sound right.  It can be interpreted as ``the results were not good, so we are not showing you everything'' }

%% We then run vanilla \quartz{} on the whole circuit
%% for the same end-to-end time as our algorithm
%% and compare the circuit quality.
%% %
%% We perform this experiment with three different timeouts ($t = 0.06$s, $0.6$s, $6$s),
%% each of which increases the end-to-end running time ten fold.
%




