\documentclass[acmsmall,screen, review, anonymous]{acmart}\settopmatter{printfolios=false,printccs=false,printacmref=false}

%replace XXX with the submission number you are given from the ASPLOS submission site.
\newcommand{\asplossubmissionnumber}{442}

\usepackage[normalem]{ulem}
\usepackage{latexsym,amsthm,amsmath,amsfonts,stmaryrd}
\usepackage{listings}
\usepackage{caption}
\usepackage{multirow}

\usepackage{newtxmath}
\usepackage{subfig}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{libertine}
\usepackage{braket}
\input{mac}
\begin{document}

\title{Scaling Quantum Circuit Optimizers}
\title{Supplementary Material for the Submission \\ Local Optimization of Large Quantum Circuits}

\date{}
\maketitle

\thispagestyle{empty}
\input{local}

\clearpage
\section{Additional proofs}

\paragraph{Proof of Theorem: Efficiency of segment optimization.}
The statement of the theorem is as follows:
\begin{quote}
  The function $\mathsf{segopt}(C)$ calls the oracle at most
  $\mathsf{length}(C) + 2\Delta$ times on segments of length at most $2\Omega$,
  where $\Delta$ is the improvement in the cost of the output.
  % Given a segment depth $\Omega$ and an oracle that optimizes for the cost function $\mathbf{cost}$,
  % the \coam{} algorithm optimizes a circuit $C$ of depth $D$
  % by calling the oracle at most $D + 2\Delta$ times on segments of depth at most $2\Omega$,
  % where $\Delta$ is the improvement in the cost of the output, assuming $\Omega \geq 2$.
\end{quote}
\begin{proof}
We prove the theorem for a tighter number of calls equal to $\mathsf{length}(C) + 2\Delta - 1$,
assuming $\Omega \geq 2$ and $\mathsf{length}(C) \geq 2$.
%
We proceed by induction on $\mathsf{length}(C)$.

In the base case, where $\mathsf{length}(C) \leq 2\Omega$, there is 1 call to the oracle.
%
This satisfies the desired bound due to $\mathsf{length}(C) \geq 2$.

For the inductive step, where $\mathsf{length}(C) > 2\Omega$, the algorithm splits into two halves $C_1$ and $C_2$,
such that $\mathsf{length}(C_1) < \mathsf{length}(C)$ and $\mathsf{length}(C_2) < \mathsf{length}(C)$.
%
% where $\sizeof{C_1} + \sizeof{C_2} = \sizeof C$,
% and $\costof{C_1} + \costof{C_2} = \costof C$.
%
The algorithm proceeds with two recursive calls
$C_1' = \mathsf{segopt}(C_1)$ and
$C_2' = \mathsf{segopt}(C_2)$, and finally computes the
output $C' = \mathsf{meld}(C_1', C_2')$.
%
The total number of calls to the oracle can be decomposed as:
\begin{itemize}
  \item Inductively,%
% \footnote{A technicality: note that, for the induction here to go through, we need
% $\sizeof{C_1},\sizeof{C_2} \geq 2$. These hold because we split in half:
% we have $\mathsf{length}(C) > 2\Omega \Rightarrow \mathsf{length}(C_1) \geq \Omega \Rightarrow \sizeof{C_1} \geq \Omega$
% (similarly for $C_2$), and finally note $\Omega \geq 2$.}
  in the first recursive call, at most $\mathsf{length}(C_1) + 2 * (\costof{C_1} - \costof{C_1'}) - 1$ calls to the oracle.
  \item Inductively, in the second recursive call, at most $\mathsf{length}(C_2)  + 2 * (\costof{C_2} - \costof{C_2'}) - 1$ calls to the oracle.
  \item In the meld, by Lemma 10 (``Bounded calls to oracle in meld''), at most $1 + 2 * (\costof{C_1'} + \costof{C_2'} - \costof{C'})$ calls to the oracle.
\end{itemize}
Adding these up yields exactly $\mathsf{length}(C) + 2 * (\costof{C} - \costof{C'}) - 1$, as desired.
\end{proof}

\clearpage

\section{Evaluation results with convergence ratio $\epsilon = 0$}
\input{fig/tab-main-result}
\input{fig/tab-main-result-time}
\input{fig/fig-app-compression-factor}
\begin{figure}
  \centering\small
  \input{fig/feyn.app.tex}
  \caption{
  The figure shows the optimization results of optimizers
  $\algname{}$ and \feyntool{}, with $\mathsf{T}$ count as the cost function.
  %
  It shows the running time in seconds for both optimizers (lower is better)
  and calculates the speedup of our \algname{} by taking the ratio of the
  two timings.
  %
  The figure also shows the $\mathsf{T}$ count reductions of both tools.
  %
  The results show that our $\algname{}$ delivers excellent time performance
  and runs almost an order of magnitude ($10\times$) faster than \feyntool{} on average.
  %
  Our \algname{} optimizer achieves this speedup without any sacrifice in circuit quality,
  and in fact sometimes produces better quality of circuits than \feyntool{}.
%
}
\end{figure}
\clearpage

% \section{Evaluation of configuration $\coamwith{\quartzt{0.1}}$}
% \figref{comp-med} shows the result of evaluation.
% \begin{figure}
%   \centering
%   \input{fig/prelim.0.1.tex}
%   \caption{
%     The figure compares the performance of $\coamwith{\quartzt{0.1}}$ against standard \quartz{}.
%     %
%     The label ``S'' represents $\coamwith{\quartzt{0.1}}$ and the label ``Q'' represents \quartz{}.
%     %
%     The figure compares the number of optimizations found by both appraoches in the same end-to-end time.
%     %
%     We impose a timeout of three hours.
%     }
%     \label{fig:comp-med}
%   \end{figure}


% \section{Evaluation of configuration $\coamwith{\quartzt{1}}$}
% \begin{figure}
%   \centering
%   \input{fig/prelim.1}
%   \caption{
%     The figure compares the performance of $\coamwith{\quartzt{1}}$ against standard \quartz{}.
%     %
%     The label ``S'' represents $\coamwith{\quartzt{1}}$ and the label ``Q'' represents \quartz{}.
%     %
%     The figure compares the circuit sizes (lower is better) and the optimization rates (higher is better) of both approaches
%     after running them for the same end-to-end time.
%     %
%     }
%     \label{fig:comp-high}
%   \end{figure}

%   \figref{comp-high} shows the result of evaluation.
% \clearpage
\section{Data for experiment varying $\Omega$}
\begin{table}[h]
  \centering
  \caption{Results for the \coamwith{\feyntool} optimizer on the \texttt{hhl} circuit with $7$ qubits.}
  \begin{tabular}{ccc}
      \toprule
      Omega & Output T count & Time \\
      \midrule
      2 & 42224 & 577 \\
      5 & 42224 & 240.16 \\
      15 & 42214 & 81.10 \\
      30 & 42174 & 52.47 \\
      60 & 42146 & 34.58 \\
      120 & 42128 & 28.16 \\
      240 & 42128 & 32.08 \\
      480 & 42118 & 47.22 \\
      960 & 42116 & 77.85 \\
      1920 & 42116 & 138.16 \\
      3840 & 42116 & 286.31 \\
      7680 & 42116 & 685.69 \\
      \bottomrule
  \end{tabular}
\end{table}

% \input{stretch-eval}
% \begin{abstract}

% \end{abstract}

\bibliographystyle{plain}
% \bibliography{references}

\bibliography{Ref_QCS_Ding,local}
\end{document}


