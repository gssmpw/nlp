
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\lstset{
  basicstyle=\footnotesize\fontfamily{ttfamily}\selectfont, % set the font
  keywordstyle={\color{mPurple}}, % set the keyword style
  morecomment=[l]{//},
  commentstyle=\rmfamily\slshape,
  % commentstyle=\itshape, % set the comment style
  showstringspaces=false, % don't show spaces in strings
  columns=fullflexible, % use proportional spacing
  morekeywords={fun,func,let,val,in,end,case,of,SOME, NONE, and, structure, if, else, then, return, def}, % define additional keywords
  mathescape=true, % enable math mode
  escapechar={@},
  keepspaces=true,
  breaklines=true,
  numbers=left,
  numbersep=4pt,
  xleftmargin=2em}

\begin{minipage}[t]{0.32\textwidth}
\begin{lstlisting}
$\Omega$: int
$\oracle{}$: circuit $\rightarrow$ circuit
$\cost{}$: circuit $\rightarrow$ int
compact: circuit $\rightarrow$ circuit

def $\mathsf{\algname{}}(C)$:
  $C'$ = segopt(compact($C$))
  if $C' = C$:
    return $C$
  else:
    return $\mathsf{\algname{}}(C')$
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.32\textwidth}
\begin{lstlisting}[firstnumber=12]
def segopt($C$):
  $d$ = length$(C)$
  if $d \leq 2\Omega$:
    $C'$ = $\oracle{}(C)$
    if $\costof{C'} < \costof{C}$:@\label{line:guard1start}@
      return $C'$
    else:
      return $C$@\label{line:guard1stop}@
  else:
    $m$ = $\lfloor d/2 \rfloor$
    $C_1$ = $C[0 : m]$
    $C_2$ = $C[m : d]$
    $C_1'$ = segopt($C_1$)
    $C_2'$ = segopt($C_2$)
    return meld$(C_1', C_2')$
\end{lstlisting}
\end{minipage}
\begin{minipage}[t]{0.345\textwidth}
\begin{lstlisting}[firstnumber=27]
def meld$(C_1, C_2)$:
  $d_1$ = length($C_1$)
  $d_2$ = length($C_2$)
  $W$ = $C_1 [d_1 - \Omega : d_1] + C_2 [0 : \Omega]$@\label{line:combine}@
  $W'$ = $\oracle{}(W)$@\label{line:guard2start}@
  if $\costof{W'} = \costof{W}$:
    return $(C_1 ; C_2)$@\label{line:guard2stop}@  // concatenate
  else:
    $M$ = meld$(C_1[0 : d_1 - \Omega], W')$@\label{line:mrec}@
    return meld($M, C_2[\Omega : d_2]$)
\end{lstlisting}
\end{minipage}

% $\Omega$: int
% Oracle: circuit $\rightarrow$ circuit
% cost: circuit $\rightarrow$ int

% def meld$(C_1, C_2)$:
%   $P$, $W_1$ = splitLastLayers$(C_1, \Omega)$
%   $W_2$, $S$ = splitFirstLayers$(C_2, \Omega)$
%   $W = W_1 + W_2$
%   $W'$ = Oracle$(W)$
%   if $\costof{W'} = \costof{W}$:
%     return concat$(P, W, S)$
%   else:
%     // assert ($\costof{W'} < \costof{W}$)
%     return meld(meld$(P, W')$, $S$)

% $c_1 + c_2$ = c $\mathit{where}\ \sizeof{c_1} = \sizeof{c}/2$
% $p_1 + s_1$ = $c_1$  $\mathit{where}\ \sizeof{s_1} = \Omega$
% $p_2 + s_2$ = $c_2$  $\mathit{where}\ \sizeof{p_2} = \Omega$
% $\textit{wd} \gets s_1 + p_2$
% $\textit{wd}' \gets \mathcal{O}(\textit{wd})$



% \begin{lstlisting}
% fun meld (c1, c2) =
%   let
%     val (c1s, c1p) = C.splitEnd (c1, $\Omega$)
%     val c2' = C.merge (c1p, c2)
%   in
%     case opt_prefix (2*$\Omega$, c2') of
%       SOME c2'' => meld (c1s, c2'')
%     | NONE => C.merge (c1, c2')
%   end

% and fun opt_prefix (prefix_size, c) =
%   let
%     val (cp, cs) = C.split (c, prefix_size)
%   in
%     case $\mathcal{O}$(cp) of
%       SOME cp' => SOME (meld (cp', cs))
%     | NONE => NONE
%   end
% \end{lstlisting}
