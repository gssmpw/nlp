
\definecolor{mPurple}{rgb}{0.58,0,0.82}
\lstset{
  language=SML, % set the programming language
  basicstyle=\footnotesize\fontfamily{ttfamily}\selectfont, % set the font
  keywordstyle={\color{mPurple}}, % set the keyword style
  commentstyle=\itshape, % set the comment style
  showstringspaces=false, % don't show spaces in strings
  columns=fullflexible, % use proportional spacing
  morekeywords={fun,let,val,in,end,case,of,SOME, NONE, and, structure, if, else, then, return}, % define additional keywords
  mathescape, % enable math mode
  breaklines=true,
  numbers=left,
  xleftmargin=15pt
}

\begin{lstlisting}[escapechar=@]
val $\Omega$ : int
val $\mathrm{opt}$ : circuit $\rightarrow$ circuit
val allSubckts : (circuit * int) $\rightarrow$ circuit list

fun optimize ($c$) =
  subckts = allSubckts($c$, $\Omega$)
  for (sbckt : subckts) {
    subckt' = $\mathsf{opt}$(subckt)
    if ($\mathsf{cost}$ (subckt') < $\mathsf{cost}$(subckt)) {
      c' = c[subckt'/subckt]
      return optimize ($c'$)
    }
  }

fun absorb (copt, crem) =
  $p_1 + s_1$ = copt
  $p_2 + s_2$ = crem
  wd = $(s_1 + p_2)$
  wd' = $\mathsf{opt} (s_1 + p_2)$
  if wd = wd' then
    return absorb ($p_1 +$  wd, $s_2$)
  else
  // this wastes work, because it dissects wd' piece by piece.
  return absorb (absorb($p_1$, wd'), $s_2$)
  // this is ok.
  return absorb (meld($p_1$, wd'), $s_2$)

\end{lstlisting}

% \begin{lstlisting}
% fun meld (c1, c2) =
%   let
%     val (c1s, c1p) = C.splitEnd (c1, $\Omega$)
%     val c2' = C.merge (c1p, c2)
%   in
%     case opt_prefix (2*$\Omega$, c2') of
%       SOME c2'' => meld (c1s, c2'')
%     | NONE => C.merge (c1, c2')
%   end

% and fun opt_prefix (prefix_size, c) =
%   let
%     val (cp, cs) = C.split (c, prefix_size)
%   in
%     case $\mathcal{O}$(cp) of
%       SOME cp' => SOME (meld (cp', cs))
%     | NONE => NONE
%   end
% \end{lstlisting}
