%!TEX root = ../main.tex

\section{Experiments}
\label{sec:exp}

\input{figures/experiments/exp-illustration.tex}


% \textbf{General setup.} We consider five contact-rich planning problems: 
% \begin{enumerate}
%     \item Push Bot: cart-pole between two soft walls, shown in Fig.~\ref{fig:exp:illustration} (a). The goal is to stabilize the cart-pole to $(a,\theta) = (0, \pi)$. For polynomial dynamics and other detailed settings, please refer to Appendix~\ref{app:pd:push-bot}.
    
%     \item Push Box: a simple pusher-slider system illustrated in Fig.~\ref{fig:exp:illustration} (b). Our goal is to push the box from one configuration ($(\sx, \sy, \theta)$) to another. Refer to Appendix~\ref{app:pd:push-box} for detailed settings. 
    
%     \item Push T-Block: same as Push Box, except that the box is replaced by a T-block. Thus, there are $8$ possible contact modes in each time step, as shown in Fig.~\ref{fig:exp:illustration} (c). Refer to Appendix~\ref{app:pd:push-T-block} for detailed settings. 
    
%     \item Push Box with a Tunnel: same as Push Box, expect that there are two circular obstacles forming a tunnel on box's way to its final goal, shown in Fig.~\ref{fig:exp:illustration} (d). Refer to Appendix~\ref{app:pd:push-box-tunnel} for detailed settings.
    
%     \item Planar Hand: two fingers rotating a 2D disk in a horizontal plane, shown in Fig.~\ref{fig:exp:illustration} (e). The goal is to rotate the circle disk $360^\circ$ with planar hand's two finger tips, while minimize the translation of the disk's center of mass. Refer to Appendix~\ref{app:pd:planar-hand} for detailed settings.
% \end{enumerate}
% Moreover, extensive real-world validations are exerted for the push T-block task. All experiments were conducted on a high-performance workstation equipped with a 2.7 GHz AMD 64-Core sWRX8 Processor, and 1 TB of RAM, to enable \MOSEK~\cite{aps2019ugrm-mosek-sdpsolver} to solve large-scale problems (with 64 CPU threads).

\textbf{General setup.} We consider five contact-rich problems.  
\begin{enumerate}
    \item \textbf{Push Bot:} A cart-pole system between two soft walls, shown in Fig.~\ref{fig:exp:illustration}(a). The objective is to stabilize the cart-pole at $(a, \theta) = (0, \pi)$. For polynomial dynamics and other detailed settings, please refer to Appendix~\ref{app:pd:push-bot}.  

    \item \textbf{Push Box:} A simple pusher-slider system, illustrated in Fig.~\ref{fig:exp:illustration}(b). The goal is to push the box from an initial configuration $(\sx, \sy, \theta)$ to a target configuration. There are 4 possible contact modes at each time step. Detailed settings can be found in Appendix~\ref{app:pd:push-box}.  

    \item \textbf{Push T-Block:} Similar to Push Box, but the box is replaced with a T-block, resulting in 8 possible contact modes at each time step, as shown in Fig.~\ref{fig:exp:illustration}(c). Please refer to Appendix~\ref{app:pd:push-T-block} for detailed settings.  

    \item \textbf{Push Box with a Tunnel:} Similar to Push Box, except that two circular obstacles form a tunnel along the box's path to its goal, as shown in Fig.~\ref{fig:exp:illustration}(d). Detailed settings are provided in Appendix~\ref{app:pd:push-box-tunnel}.  

    \item \textbf{Planar Hand:} A two-fingered system rotating a 2D disk in a horizontal plane, as shown in Fig.~\ref{fig:exp:illustration}(e). The goal is to rotate the disk by $360^\circ$ using two fingertip contacts while minimizing the translation of the disk's center of mass. See Appendix~\ref{app:pd:planar-hand} for further details.  
\end{enumerate}  

Additionally, extensive real-world validations are conducted for the Push T task. Experiments were performed on a high-performance workstation equipped with a 2.7 GHz AMD 64-Core sWRX8 Processor and 1 TB of RAM, enabling \MOSEK~\cite{aps2019ugrm-mosek-sdpsolver} to solve large-scale problems utilizing 64 threads.  



% \input{figures/goodplot/PushBot-goodplot.tex}
% \input{figures/goodplot/PushBox-goodplot.tex}
% \input{figures/goodplot/PushT-goodplot.tex}
% \input{figures/goodplot/PushBoxTunnel2-goodplot.tex}
% \input{figures/goodplot/PlanarHand-goodplot.tex}

\textbf{Conversion speed.} 
We compare \spot and \tssos in terms of conversion time across the five planning problems, considering different CS and TS options. In all cases, the planning horizon is set to $N = 30$. For the Push Box with a Tunnel problem, the CS relaxation order is set to $d = 3$ to obtain a tighter lower bound, while for the other examples, $d$ is set to $2$.
The results are summarized in Table~\ref{tab:performance_comparison}. \spot consistently outperforms \tssos, achieving at least a $2\times$ speedup. For large-scale problems such as Push Box with a Tunnel, \spot achieves approximately a $5\times$ speedup.
For the Planar Hand problem, the automatic CS pattern generation produces clique sizes exceeding 20 through both MF and MD methods, resulting in a large-scale SDP with over $1$ million constraints. Since \tssos tightly integrates its conversion and SDP solving processes, it is difficult to isolate the conversion time. Therefore, we only report \spot's conversion time for this case, which remains under 100 seconds despite the problem's scale.
\input{tables/table1.tex}

\textbf{Self-defined variable cliques.} 
Since the automatic sparsity exploitation mechanism may fail to detect robotics-specific sparsity, we adopt the following clique generation procedure:
\begin{enumerate}
    \item Generate a general sparsity pattern using \spot.
    \item Manually inspect the variable cliques to determine whether certain robotics-specific variable-level sparsity patterns can be incorporated.
    \item Modify the generated cliques and resend them to \spot using the ``SELF'' option.
\end{enumerate}
    
    For example, in the Planar Hand task, leveraging the kinematic chain pattern discussed in \S\ref{sec:robotics-specific}, we manually partition the variables at each time step into 14 smaller cliques, with sizes ranging from 6 to 14. Due to space constraints, these cliques are detailed in Appendix~\ref{app:sec:self-cliques}. These manually defined cliques precisely correspond to the red circles in Fig.~\ref{fig:demos}(a), illustrating the specific sparsity pattern.

\textbf{Robust minimizer extraction.} Due to the inherent complexity of contact-rich planning problems, it is not uncommon to encounter two types of relaxation ``failure cases'':  
\begin{enumerate}
    \item The sparse Moment-SOS Hierarchy is not tight.  
    \item The sparse Moment-SOS Hierarchy is tight but admits multiple solutions.  
\end{enumerate}  
In both cases, the moment matrices fail to attain rank 1 (or other general tightness certificates).  
To extract minimizers, \tssos and~\cite{kang2024wafr-strom} both employ the same ``naive'' approach: obtain the degree-1 submatrix of each moment matrix, then average the normalized eigenvectors across different variable cliques. While straightforward to implement, this method is not robust in practice, often leading to infeasible local rounding and large suboptimality gaps.  
On the other hand,~\cite{klep2018siopt-minimizer-extraction-robust} demonstrates that the Gelfand-Naimark-Segal (GNS) construction provides a robust approach for minimizer extraction from a single moment matrix. Inspired by this, we propose the following heuristic algorithm for minimizer extraction in the presence of multiple moment matrices:  
\begin{enumerate}
    \item For each moment matrix, extract minimizers along with their associated weights using the GNS construction.  
    \item Select the minimizer with the highest weight and average it across different variable cliques.  
\end{enumerate}  
This seemingly minor modification significantly improves robustness compared to the ``naive'' extraction method. We implemented the new minimizer extraction scheme in our \spot package. A detailed discussion of GNS is beyond the scope of this paper; we refer interested readers to~\cite{klep2018siopt-minimizer-extraction-robust}. 

\input{tables/table2.tex}
\input{tables/table3.tex}
\input{figures/experiments/more-simulation.tex}

\textbf{Numerical results.} The results are presented in Table~\ref{tab:results}. The planning horizon $N$ is set to $30$. For the Push Bot, Push Box, and Push T Block tasks, we evaluate 10 random initial states. For the Push Box with a Tunnel and Planar Hand tasks, we consider 5 random initial states. All reported statistics represent mean values.  
From semidefinite relaxation, we can get a lower bound $f_{\text{lower}}$ of original nonconvex POP. After extracting solution, we use an in-house local solver to round a feasible solution with an upper bound $f_{\text{upper}}$. The suboptimality gap is defined as:
\begin{align}
    \label{eq:exp:suuboptimality-gap}
    \eta_g := \frac{
        \abs{f_{\text{lower}} - f_{\text{upper}}}
    }{
        1 + \abs{f_{\text{lower}}} + \abs{f_{\text{upper}}}
    }
\end{align}
We also report max KKT residual $\eta_\kkt$ and \MOSEK solving time.   
Since SOS relaxation tends to generate much less constraint numbers compared to moment relaxation, and \MOSEK is sensitive to constraint numbers, we only test SOS relaxations. 

The numerical results reveal a clear trade-off between computational efficiency and relaxation tightness. When TS is not enabled, all average suboptimality gaps remain below $10\%$, except for the Planar Hand task. However, solving large-scale problems can take up to 5 minutes.  
Enabling TS with MF significantly improves computational efficiency. For the Push Bot, Push Box, and Push T Block tasks, we achieve near real-time solving speeds. However, this comes at the cost of significantly larger suboptimality gaps.  
Notably, there are two instances where \MOSEK fails to solve the SDP to high accuracy: (a) Push Bot, SELF + MAX; (b) Planar Hand, SELF + MF. The underlying causes of these failures remain unknown. We also report the corresponding SDP constraint number, PSD cone number, and max PSD cone size in Table~\ref{tab:sdp-config}. The demonstration of global optimal trajectories can be found in Fig.~\ref{fig:exp:more-simulation}.

\input{figures/experiments/more-realworld.tex}

\textbf{Real-world Push T-Block validations.} We extensively validate our global optimal policy in the real world Push T-Block setting, as illustrated in Fig.~\ref{fig:demos}(c). We use AprilTag~\cite{olson2011icra-apriltag} to get accurate pose estimation of the T-block. Due to the global optimality of our approach, a planning horizon of $N = 5$ is sufficient to generate high-quality planned trajectories. At each time step, we execute the pusher's first action and then re-plan. The average re-planning time is $3.7$ seconds, with CS set to MF and TS set to NON.
We evaluate our framework in 20 random trials, evenly split between two categories: clean push-T tasks, which involve standard push-T scenarios without disturbances, and ``dirty'' push-T tasks, where severe model mismatches and external disturbances are introduced to assess the planner's robustness. These disturbances include cases where the T-block is wrapped in a cable, put on some irregular surface, or contained within a small box. These three scenarios correspond to lines 2-4 in Fig.~\ref{fig:demos}(c).
Note that all these ``dirty'' push-T cases make our modeling (which is very simple) effectively ``wrong''.
However, our planner demonstrates remarkable efficiency and robustness across all test cases, achieving a $100\%$ success rate while naturally accommodating a wide range of initial states and challenging environments. 
For more demonstrations, please see Fig.~\ref{fig:exp:more-realworld} and project website.

\begin{quote}
    \textit{All models are wrong, but some are ``powerful'', with ``global optimization''.}
\end{quote}

