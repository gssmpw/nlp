\section{Background}\label{sec:bakground}

The Internet of Things (\iot) represents the interconnectedness of everyday physical objects or `things' via the internet. These objects are equipped with sensors, gateways, software, hubs, and other technologies, enabling them to collect and exchange data not only among themselves but also with other systems and applications via the Internet. In our study, we outline our research questions concerning the landscape of the most common \iot platforms, practices, and practitioners' perspectives. This section offers an overview of \iot platforms, including their layers, components, and common tests.




\begin{figure}[ht]
  \centering
  \includegraphics[width=0.45\textwidth]{figures/ecosystem-test2.1.pdf}
  \caption{IoT platform layers and common tests per layer \cite{makhshari2021}}
  \label{fig:iot}
\end{figure}

\textbf{\iot platforms.} An \iot platform is a software suite that provides the framework and tools to facilitate the development, and management of applications and connected devices. Those platforms and devices constitute an ecosystem that automates places like homes. In general, any \iot platform follows the architecture and layers described in Fig. \ref{fig:iot}~\cite{makhshari2021}. \figref{fig:iot} depicts four layers (\ie \iot devices, edge, cloud, and applications). The \textit{\iot devices} layer involves smart programmable devices interacting with the physical world through embedded sensors and actuators. The \textit{edge} layer consists of gateway devices with fewer resource constraints, capable of locally handling telemetry data collection, processing, and routing. These gateways interpret diverse communication protocols like MQTT, CoAP, and HTTP, managing device-device and device-cloud interoperability. The \textit{cloud} layer comprises remote \iot cloud servers that accumulate and process telemetry data, communicating with heterogeneous \iot devices for remote control and monitoring. \iot cloud servers utilize a rule engine to enable users to write automation logic, defining interoperability behaviors within the \iot system. Finally, a user can utilize \textit{applications (apps)} to interact and control the \iot devices.

In our research, we evaluated open-source \iot platforms, ultimately choosing  \openhab~\cite{openhab} and \homeassistant because of their widespread adoption. %
Both platforms are vendor-agnostic supporting a large range of devices and network protocols and allowing to connect and interact with products from different manufacturers (\ie Amazon, Alexa, Nest, Hue, Homekit, etc). Both platforms allow users to create complex interaction rules (\ie turn off the lights at a given hour if the motion sensor is not activated) using a user interface. Both platforms are also actively supported by community and diverse developers offering a wide range of add-ons, integrations, and custom components.

\textbf{\iot testing.} Each layer within the \iot platform is susceptible to failure, and the impact can cascade to subsequent layers. Moreover, \iot devices, often deployed in unpredictable and challenging environments, may encounter extreme conditions. Potential tests are outlined in Fig.~\ref{fig:iot} are listed based on the most common test for software components \cite{linares-vasquez_enabling_2017}.

\textit{T1: Application Tests} - This layer focuses on user experience and interface testing to facilitate coordination and access to IoT devices. Common tests include UI/UX assessments, notification functionalities, and smartphone integration \cite{linares-vasquez_enabling_2017}.

\textit{T2: Cloud Tests} - IoT device data is transmitted to cloud-based platforms for storage, analysis, and accessibility. Tests in this layer typically cover storage integrity, database access, and web service functionalities.

\textit{T3: Communication Protocols} - Various communication protocols such as Wi-Fi, Bluetooth, and cellular networks enable IoT devices to connect to the internet and other devices. Tests here include router firmware evaluations, network authentication, and protocol compliance checks.

\textit{T4: Network Connectivity} - IoT devices require stable connections to broader networks through standard protocols. Tests focus on input/output data validation, socket connections, and data delivery reliability.

\textit{T5: Intermediate Hubs} - Intermediate hubs facilitate device control with specific requirements. Tests involve event validation, connectivity checks, and rules configuration, where rules define configurable routines for device actions.

\textit{T6: Firmware and Resource Optimization} - IoT devices utilize firmware to monitor, control, and optimize processes. Tests concentrate on optimizing limited resources such as battery and memory, alongside fundamental configuration and trigger event validations.

A common functional software artifact deployed on each device is the \addon. For instance, devices such as cameras, sensors, and speakers can be seamlessly integrated into the platform as \addons. Each \addon comprises multiple software \textit{components}, including but not limited to battery management, sensor control, event handling, data collection, and network connectivity. These \textit{components} serve as the fundamental \textit{building blocks across all \iot layers}. Consequently, components are omnipresent throughout the \iot platforms. Each platform can have collaborations with private companies such as Hue, Amazon Alexa, or Apple HomeKit.

\textbf{Focal Methods.} Our goal is to identify testing practices across widely-used open-source \iot platforms. One common approach for assessing test coverage involves running tests and determining which functional blocks and lines of code are executed. However, applying this method across diverse programming languages, add-ons, and core components— in \iot platforms like \openhab and \homeassistant — poses significant challenges. Executing test coverage in these environments requires configuring various files, setting up specific environments, and integrating multiple devices for testing purposes \cite{8919324,bosmans_testing_2019}.


Our investigation adopts an agnostic approach to identify tests within \iot add-ons and component code. To achieve this, we utilize the concept of focal methods to pinpoint functional and test methods. According to Tufano et al. \cite{tufano_methods2test_2022}, a focal method \textit{(fm)} refers to a method within a functional block that has defined parameters. Each \textit{fm} can be tested by zero or $n$ focal test methods. A focal test method \textit{(ftm)} is a functional code block specifically designed to test either a portion or the entirety of an \textit{fm}. The primary purpose of \textit{ftms} is to capture the intent and structure of human-written tests, ensuring traceability between tests and code under test.

Focal methods provide a mechanism for identifying both functional methods and their corresponding tests within a component. The concept of a \textit{fm} (\figref{fig:focalmethods}) is based on the principle that all code is organized into files, and these files follow a structured format dictated by the syntax of the programming language (PL) \cite{tufano_methods2test_2022}. In object-oriented PLs (e.g., Java), this structure is particularly clear, and five levels of context can be identified:


\textit{Focal Method (fm)}: this first level represents a set of public methods with bodies that contain the most critical information for generating test cases. These are the functional code blocks that can be executed and tested.

\textit{Class Context (fm + c)}: the second level adds the class name to the focal method, providing the necessary context about the class to which the method belongs.

\textit{Class Constructor}: includes the class constructor, which offers details on how to instantiate the class to enable testing.

\textit{Auxiliary Methods}:  comprise supporting methods (\eg getters and setters) that are required to invoke the focal method.

\textit{Class Attributes}: encompass the set of attributes at the class level, which contribute to the functionality of the class.



\begin{figure}[t]
  \centering
  \includegraphics[width=0.48\textwidth]{figures/focal_method4.pdf}
  
  \caption{Focal method (fm) and focal test method (ftm) example.}
  \label{fig:focalmethods}
\end{figure}

\section{Research Questions}
\label{sec:rq}

In this research, we seek to learn more about \iot developers' perspectives regarding their test objective, common practices and techniques, test case design decisions, and challenges they face. By understanding what components are commonly tested, and the techniques used, we can not only gain insights into what areas might benefit from the development of new tools or techniques but also identify which parts of the system developers view as most critical or complex. This will guide the efficient allocation of testing resources and better focus future testing strategies, ultimately improving the reliability and performance of IoT applications. To evaluate how developers are currently testing \iot platforms, the practices they follow, and the challenges they face, we pose the following RQs:

\begin{enumerate}[label=\textbf{RQ$_{\arabic*}$}, ref=\textbf{RQ$_{\arabic*}$}, wide, labelindent=5pt]\setlength{\itemsep}{0.2em}
	
\item{\label{rq:common} \textit{What are the proportion of focal test methods for \addons and commonly components in open-source \iot platforms?}} 
\item{\label{rq:purpose}\textit{What is the purpose of current testing-related code and processes in open-source \iot platforms?}}
\item{\label{rq:design} \textit{How do developers design tests for \iot platforms?}}
\item{\label{rq:techniques}\textit{What tools, techniques, and processes do developers currently employ for testing \iot platforms?}}
\item{\label{rq:challenges}\textit{What challenges do developers face when testing \iot platforms?}}
\end{enumerate}







