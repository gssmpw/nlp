\section{\textit{PLC-BEAD} Dataset}
\label{sec:plcbead}


\subsection{Dataset Overview and Design Goals}
\label{subsec:overview}
\textbf{PLC-BEAD} is a comprehensive dataset encompassing over 700 unique PLC programs and 2,431 binaries, meticulously compiled using four different compilers. 
Each program in the dataset is accompanied by its source code written in Structured Text (ST) programming language, following the IEC 61131-3 standard~\cite{international3international}. These programs range from basic control mechanisms like timers and flip-flops to sophisticated algorithms for data processing and network communication.
The dataset is designed to capture the diversity of PLC program development in industrial settings, with binaries generated using four distinct compilers:

\begin{itemize}
    \item \textbf{CoDeSys} \cite{codesys}: A popular platform that many industrial vendors adopt~\cite{keliris2019icsref}. It produces a distinctive binary layout with dedicated sections for variable initialization and runtime system data.
    \item \textbf{GEB} \cite{geb}: A closed-source compiler often used in certain industrial sectors for building robust automation logic.
    \item \textbf{OpenPLC-V2} \cite{openplc}: An open-source solution that follows the IEC 61131-3 standard and is valued for its simplicity.
    \item \textbf{OpenPLC-V3} \cite{openplc}: A more modern iteration of OpenPLC with additional optimizations. 
\end{itemize}

These represent a mix of proprietary and open-source solutions that are widely used in industry and research~\cite{keliris2019icsref,7006408}.
Including these four compilers helps illustrate how the same ST source can produce substantially different binary layouts, enabling the study of unique compiler-specific patterns in binaries and facilitating the development of universal binary analysis tools.
To our knowledge, \textit{no other open dataset} offers such a combination of breadth (multi-compiler coverage) and depth (source-binary pairs, extensive functionalities) for PLCs.

\paragraph{Why an Integrated Source-Binary Dataset.}
% In PLC security and reverse engineering, many projects are forced to operate without source code, especially when analyzing legacy systems.
% However, having access to the original ST files can greatly benefit tasks such as debugging analysis pipelines, verifying functionality predictions, and identifying compiler-induced transformations in the binary.
% Therefore, we have structured PLC-BEAD to serve both binary-only analysis (for researchers focusing on digital forensics or vulnerability detection) and source-level correlation (for those who want to trace findings back to specific parts of the high-level logic).
Providing both source and binary artifacts in PLC-BEAD enables two complementary research directions. Researchers aiming to develop \textit{binary-focused} approaches (e.g., for ICS digital forensics or vulnerability scans) can rely solely on the compiled executables to evaluate how well automated methods perform without high-level code. Conversely, others may want to align their binary analyses with known ground-truth logic at the source level in order to map discovered vulnerabilities back to specific function blocks or instructions. This integrated approach offers flexibility in exploring questions such as:
\begin{itemize}
\item How do different compilers implement the same control algorithm, and what patterns or “fingerprints” are visible in the final binaries? 
\item Can a trained model reliably infer functionality (e.g., “timer logic” vs. “PID control loop”) solely from raw bytes? 
\item Does the same snippet of ST code produce semantically similar but structurally different binaries under different optimization settings or hardware targets? \end{itemize}


\paragraph{Potential Impact.}
Openly available datasets in computer vision and natural language processing have accelerated progress by enabling reproducibility and fostering collaborative benchmarking.
We believe a similar approach can empower ICS binary analysis research, where industrial secrecy and regulatory requirements often constrain reproducibility.
Our hope is that PLC-BEAD will:
\begin{itemize}
    \item Illuminate compiler-specific differences that may introduce security weaknesses or vulnerabilities in PLC binaries.
    \item Provide a standard platform for comparing machine learning models aimed at tasks such as toolchain provenance identification, functionality classification, or anomaly detection in PLC firmware.
    \item Spur follow-up work in ICS digital forensics, where effective classification of suspicious PLC binaries and rapid understanding of their purpose could significantly reduce response times after an incident.
\end{itemize}


\begin{figure}[!ht]
    \centering
    \includegraphics[width=0.88\linewidth]{figures/compilation_process.png}
    \caption{PLC-BEAD Dataset Construction Pipeline}
    \vspace{-8pt}
    \label{fig:compile}
    % \vspace{-pt}
\end{figure}


\subsection{Dataset Construction}
\label{subsec:construction}

The primary data source for PLC-BEAD is the \textit{OSCAT (Open Source Community for Automation Technology)} library~\cite{oscat}, a significant resource in PLC programming and automation~\cite{langmann2016aplc,
canedo2021arducode}. The library includes function blocks that range from arithmetic and signal processing to advanced building automation routines. 
OSCAT covers a broad spectrum of functions, from basic arithmetic to building automation modules, making it a practical starting point for reflecting real-world industrial requirements. 
% We supplemented these materials with additional ST samples that illustrate typical control logic (for example, simple timers, flip-flops, and PID controllers) and basic networking procedures.
Our aim was to capture a broad set of use cases that an engineer might encounter in industrial environments, while still keeping the dataset manageable.

\paragraph{Compilation Procedure.} Fig.~\ref{fig:compile} depicts the compilation process. After developing the PLC programs, we proceeded to compile them using the selected toolchains to obtain their corresponding binary files. However, due to variations in built-in libraries and primitive functions, some programs did not compile across all four compilers. 
For example, a string-handling snippet called \texttt{CAPITALIZE.ST} could be compiled in \textit{CoDeSys} but failed under \textit{OpenPLC-V3}. This is because the \textit{OpenPLC-V3} compiler does not support the primitive function, \texttt{\text{GET}\_\text{CHAR}()}. 
Similar compiler-specific constraints emerged across different functionality domains. 
In cases where only minor tweaks were required (for instance, replacing a function call with an equivalent), we performed these adjustments. 
For example, given that the language parsers for CoDeSys and GEB differ substantially from those used by OpenPLC, modifications to the ST programs were necessary to prevent syntax errors during the compilation process.
If a program demanded extensive rewrites to work on a particular compiler, we excluded it from that compiler’s compilation list to avoid changing its core logic. 

% \todo{\textbf{Automation Scripts.}
% We developed Python scripts to automate the compilation of all ST programs for each toolchain. 
% These scripts parsed a simple input manifest listing each ST file and the supported compilers for that file. 
% The build process varied across compilers, since each compiler had different command-line arguments and output directory structures. 
% Our scripts documented the toolchain, the compilation options, and the resulting binary files, creating a transparent audit trail for reproducibility.}

\begin{table}[!t]
    \centering \renewcommand{\arraystretch}{1.5}
    \caption{The data statistics of the \textit{PLC-BEAD} dataset.}
    \begin{tabular}{|l|l|l|l|l|}
    \hline
        \multirow{2}{*}{\# of Programs} & \multicolumn{4}{|c|}{\# of Binaries } \\ \cline{2-5}
        ~ & \textit{CoDeSys} & \textit{GEB} & \textit{OpenPLC-V2} & \textit{OpenPLC-V3} \\ \hline
        729 & 555 & 617 & 619 & 640 \\ \hline
    \end{tabular}
\vspace{-10pt}
    \label{tab:datastat}
\end{table}
\vspace{3pt}

\paragraph{Compilation Result.} Table~\ref{tab:datastat} summarizes how many of the 729 ST programs were successfully compiled by each toolchain. 
Specifically, \textit{OpenPLC-V2} compiled 619 programs, and \textit{OpenPLC-V3} compiled 640, while \textit{CoDeSys} and \textit{GEB} successfully handled 555 and 617 programs, respectively. 
These differences stem from language parsers and built-in library support that vary among the toolchains.
By the end of this process, we accumulated \textbf{2431 valid binaries} overall.


\subsubsection{Functionality Labeling}
\label{subsubsec:labeling}
One of the central goals of PLC-BEAD is to facilitate functionality-based analysis. 
For instance, security analysts might want to detect whether a suspicious binary is a timer routine or an actuator controller. 
Similarly, machine learning researchers might try to classify binaries based on high-level tasks. 
We therefore assigned each ST snippet to one of \textbf{22 functional categories}, derived from the OSCAT documentation~\cite{oscat} and common industrial practice (for example, “Timing,” “Math,” “Network,” “Building Control,” and others).




\paragraph{Annotation Procedure.}
The labeling was done manually by parsing the program’s file name and function block references. 
Some programs implemented multiple functions and did not fit neatly into a single label. 
In those cases, we used the most dominant function block or subroutine. 
For example, a snippet that primarily handled string manipulation but also included a small timer was labeled “String processing.” 
At least two team members confirmed all labels, who cross-checked the ST source to ensure consistency.

Fig.~\ref{fig:func_labels} illustrates the distribution of these functionality labels, with “\texttt{Time\_and\_Date}” and “\texttt{Mathematical Operations}” blocks being among the most common. 
We note that some functional categories have fewer samples, indicating mild class imbalance that researchers should account for during training or evaluation.

% \begin{table}[t]
% \centering
% \caption{Summary of PLC-BEAD dataset contents.}
% \label{tab:dataset_stats}
% \begin{tabular}{lcc}
% \toprule
% \textbf{Item} & \textbf{Quantity} & \textbf{Notes} \\
% \midrule
% ST programs & 729 & OSCAT \& custom snippets \\
% Compiled binaries & 2{,}431 & Across 4 compilers \\
% Func. labels & 22 & Timing, Math, Network, etc. \\
% Avg. binary size & \todo{} KB & Compiler-dependent \\
% \bottomrule
% \end{tabular}
% \end{table}


\subsection{Dataset Organization}
\label{subsec:organization}

To facilitate navigation and reuse, the PLC-BEAD dataset is organized into a hierarchy that separates source files, compiled binaries, and supporting metadata. The top-level directory contains:


\begin{itemize}
    \item \textit{Source/}: All ST programs. Files are grouped by compiler compatibility. For instance, \texttt{Source/codesys/} includes ST files that successfully compile with CoDeSys.
    \item \textit{Binary/}:  The resulting binaries, arranged similarly by compiler.
    \item \textit{Metadata/}: CSV files describing success or failure status for each ST program file. This directory also contains the master index file mapping each ST code to its compiled binaries and assigned functionality labels.
    \item \textit{README.md}: Documentation to ensure it is accessible to researchers. This offers in-depth insights into the dataset's structure, clarifies the significance of each metadata field, and provides guidelines for leveraging the dataset effectively in various research contexts.
\end{itemize}

This organization ensures that researchers can easily navigate across multiple compilers and functionality categories, with clear visibility into which files and binaries belong to each class. We also have a data card for the dataset attached as supplementary material.


% \textbf{Licensing and Distribution.}
% The dataset is released under an open license that permits research usage and redistribution, subject to any third-party terms from the original ST libraries (for example, OSCAT). }


\begin{figure}[!t]
    \centering
    \includegraphics[width=0.9999\linewidth]{figures/Func_distribution_2.png}
    \caption{Distribution Of Functional Labels (Top 12 Categories + Others)}
    \vspace{-8pt}
    \label{fig:func_labels}
    % \vspace{-pt}
\end{figure}

\subsection{Significance of Dataset Diversity}
Understanding binary data and its intricacies is fundamental in the context of PLC systems. 
Dataset diversity serves multiple critical purposes. First, it enhances static binary analysis, which focuses on examining binary code structure, control flow, and data flow. PLC-BEAD ensures analytical tools can interpret different vendor-specific binary formats and programming methodologies. Furthermore, diverse PLC binaries allow researchers to evaluate the limitations and accuracy of existing static analysis tools. By benchmarking these tools against a diverse dataset, researchers can identify areas for improvement and develop enhanced techniques that address the challenges presented by different PLC binaries.

The dataset's diversity is particularly crucial for ML applications. While ML techniques have shown promise in classifying and analyzing general-purpose software binaries~\cite{kim2018multimodal,shabtai2010automated,su2016deep,yu2023cfg2vec,xu2017spain}, the proprietary nature of PLC binaries, coupled with the lack of large, labeled datasets, has limited ML applications in the PLC domain. A diverse dataset that includes PLC binaries from multiple compilers facilitates training ML models that can generalize well across different PLC systems.

PLC-BEAD's structure and diversity aim to stimulate and support further research in PLC binary analysis. Its organization, metadata, and source code offer a robust platform for exploring PLC binaries, refining analysis techniques, and developing strong ML models for PLC system security and reliability. The dataset's comprehensive nature makes it particularly valuable for developing and evaluating cross-compiler binary analysis techniques, which are essential for handling the heterogeneous nature of industrial control systems.