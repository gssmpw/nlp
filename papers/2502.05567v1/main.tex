\documentclass{article}


\usepackage{arxiv}
\usepackage[utf8]{inputenc} % allow utf-8 input
\usepackage[T1]{fontenc}    % use 8-bit T1 fonts
\usepackage[colorlinks=true, allcolors=blue]{hyperref}
\usepackage{url}            % simple URL typesetting
\usepackage{booktabs}       % professional-quality tables
\usepackage{amsfonts}       % blackboard math symbols
\usepackage{nicefrac}       % compact symbols for 1/2, etc.
\usepackage{microtype}      % microtypography
\usepackage{lipsum}
\usepackage{graphicx}


\usepackage{microtype}
\usepackage{graphicx}
\usepackage{subfigure}
\usepackage{booktabs}
\usepackage{hyperref}
\newcommand{\theHalgorithm}{\arabic{algorithm}}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage[capitalize,noabbrev]{cleveref}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{assumption}[theorem]{Assumption}
\theoremstyle{remark}
\newtheorem{remark}[theorem]{Remark}
\usepackage[textsize=tiny]{todonotes}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{booktabs}   
\usepackage{makecell}   
\usepackage{array}
\usepackage{listings}
\newcommand{\smallsec}[1]{\paragraph{#1.}}
\lstset{
    escapeinside={(*@}{@*)},
}
\colorlet{punct}{red!60!black}
\definecolor{background}{HTML}{EEEEEE}
\definecolor{delim}{RGB}{20,105,176}
\colorlet{keyword}{magenta!60!black}
\lstdefinelanguage{lean}{
    basicstyle=\footnotesize\ttfamily,
    numbers=left,
    numberstyle=\scriptsize,
    stepnumber=1,
    numbersep=8pt,
    showstringspaces=false,
    breaklines=true,
    frame=lines,
    backgroundcolor=\color{background},
    literate=
     *{axiom}{{{\color{keyword}axiom}}}{5}
      {theorem}{{{\color{keyword}theorem}}}{7}
      {lemma}{{{\color{keyword}lemma}}}{5}
      {by}{{{\color{keyword}by}}}{2}
      {Lemma}{{{\color{keyword}Lemma}}}{5}
      {Proof}{{{\color{keyword}Proof}}}{5}
      {Qed}{{{\color{keyword}Qed}}}{3}
      {:}{{{\color{punct}{:}}}}{1}
      {,}{{{\color{punct}{,}}}}{1}
      {\{}{{{\color{delim}{\{}}}}{1}
      {\}}{{{\color{delim}{\}}}}}{1}
      {[}{{{\color{delim}{[}}}}{1}
      {]}{{{\color{delim}{]}}}}{1}
      {ℕ}{{\ensuremath{\mathbb{N}}}}{1}
      {ℤ}{{\ensuremath{\mathbb{Z}}}}1
      {ℝ}{{\ensuremath{\mathbb{R}}}}{1}
      {ℚ}{{\ensuremath{\mathbb{Q}}}}1
      {ℂ}{{\ensuremath{\mathbb{C}}}}1
      {∩}{{\ensuremath{\cap}}}1
    {∪}{{\ensuremath{\cup}}}1
    {⊂}{{\ensuremath{\subseteq}}}1
    {⊆}{{\ensuremath{\subseteq}}}1
    {⊄}{{\ensuremath{\nsubseteq}}}1
    {⊈}{{\ensuremath{\nsubseteq}}}1
    {⊃}{{\ensuremath{\supseteq}}}1
    {⊇}{{\ensuremath{\supseteq}}}1
    {⊅}{{\ensuremath{\nsupseteq}}}1
    {⊉}{{\ensuremath{\nsupseteq}}}1
    {∈}{{\ensuremath{\in}}}1
    {∉}{{\ensuremath{\notin}}}1
    {∋}{{\ensuremath{\ni}}}1
    {∌}{{\ensuremath{\notni}}}1
    {∅}{{\ensuremath{\emptyset}}}1
    {∫}{{\ensuremath{\int}}}1
    {∑}{{\ensuremath{\mathrm{\Sigma}}}}1
    {Π}{{\ensuremath{\mathrm{\Pi}}}}1
    {≤}{{\ensuremath{\leq}}}1
    {≥}{{\ensuremath{\geq}}}1
    {≠}{{\ensuremath{\neq}}}1
    {≈}{{\ensuremath{\approx}}}1
    {≡}{{\ensuremath{\equiv}}}1
    {≃}{{\ensuremath{\simeq}}}1
    {α}{{\ensuremath{\mathrm{\alpha}}}}1
    {β}{{\ensuremath{\mathrm{\beta}}}}1
    {γ}{{\ensuremath{\mathrm{\gamma}}}}1
    {δ}{{\ensuremath{\mathrm{\delta}}}}1
    {ε}{{\ensuremath{\mathrm{\varepsilon}}}}1
    {ζ}{{\ensuremath{\mathrm{\zeta}}}}1
    {η}{{\ensuremath{\mathrm{\eta}}}}1
    {θ}{{\ensuremath{\mathrm{\theta}}}}1
    {ι}{{\ensuremath{\mathrm{\iota}}}}1
    {κ}{{\ensuremath{\mathrm{\kappa}}}}1
    {μ}{{\ensuremath{\mathrm{\mu}}}}1
    {ν}{{\ensuremath{\mathrm{\nu}}}}1
    {ξ}{{\ensuremath{\mathrm{\xi}}}}1
    {π}{{\ensuremath{\mathrm{\mathnormal{\pi}}}}}1
    {ρ}{{\ensuremath{\mathrm{\rho}}}}1
    {σ}{{\ensuremath{\mathrm{\sigma}}}}1
    {τ}{{\ensuremath{\mathrm{\tau}}}}1
    {φ}{{\ensuremath{\mathrm{\varphi}}}}1
    {χ}{{\ensuremath{\mathrm{\chi}}}}1
    {ψ}{{\ensuremath{\mathrm{\psi}}}}1
    {ω}{{\ensuremath{\mathrm{\omega}}}}1
    {Γ}{{\ensuremath{\mathrm{\Gamma}}}}1
    {Δ}{{\ensuremath{\mathrm{\Delta}}}}1
    {Θ}{{\ensuremath{\mathrm{\Theta}}}}1
    {Λ}{{\ensuremath{\mathrm{\Lambda}}}}1
    {Σ}{{\ensuremath{\mathrm{\Sigma}}}}1
    {Φ}{{\ensuremath{\mathrm{\Phi}}}}1
    {Ξ}{{\ensuremath{\mathrm{\Xi}}}}1
    {Ψ}{{\ensuremath{\mathrm{\Psi}}}}1
    {Ω}{{\ensuremath{\mathrm{\Omega}}}}1
    {↦}{{\ensuremath{\mapsto}}}1
    {←}{{\ensuremath{\leftarrow}}}1
    {<-}{{\ensuremath{\leftarrow}}}1
    {→}{{\ensuremath{\rightarrow}}}1
    {↔}{{\ensuremath{\leftrightarrow}}}1
    {⇒}{{\ensuremath{\Rightarrow}}}1
    {⟹}{{\ensuremath{\Longrightarrow}}}1
    {⇐}{{\ensuremath{\Leftarrow}}}1
    {⟸}{{\ensuremath{\Longleftarrow}}}1
    {Σ}{{\ensuremath{\Sigma}}}1
    {Π}{{\ensuremath{\Pi}}}1
    {∀}{{\ensuremath{\forall}}}1
    {∃}{{\ensuremath{\exists}}}1
    {λ}{{\ensuremath{\mathrm{\lambda}}}}1
    {∧}{{\ensuremath{\wedge}}}1
    {∨}{{\ensuremath{\vee}}}1
    {¬}{{\ensuremath{\neg}}}1
    {⊢}{{\ensuremath{\vdash}}}1
    {‖}{{\ensuremath{\|}}}1
    {₁}{{\ensuremath{_1}}}1
    {₂}{{\ensuremath{_2}}}1
    {₃}{{\ensuremath{_3}}}1
    {₄}{{\ensuremath{_4}}}1
    {₅}{{\ensuremath{_5}}}1
    {₆}{{\ensuremath{_6}}}1
    {₇}{{\ensuremath{_7}}}1
    {₈}{{\ensuremath{_8}}}1
    {₉}{{\ensuremath{_9}}}1
    {₀}{{\ensuremath{_0}}}1
    {ᵢ}{{\ensuremath{_i}}}1
    {ⱼ}{{\ensuremath{_j}}}1
    {ₐ}{{\ensuremath{_a}}}1
    {⁻¹}{{\ensuremath{^{-1}}}}1
    {¹}{{\ensuremath{^1}}}1
    {ₙ}{{\ensuremath{_n}}}1
    {ₘ}{{\ensuremath{_m}}}1
    {ₚ}{{\ensuremath{_p}}}1
    {↑}{{\ensuremath{\uparrow}}}1
    {↓}{{\ensuremath{\downarrow}}}1
    {⊥}{{\ensuremath{\perp}}}1
    {∞}{{\ensuremath{\infty}}}1
    {∂}{{\ensuremath{\partial}}}1
    {√}{{\ensuremath{\sqrt}}}1
    {∘}{{\ensuremath{\circ}}}1
    {×}{{\ensuremath{\times}}}1
    {∆}{{\ensuremath{\triangle}}}1
    {⟨}{{\ensuremath{\langle}}}1
    {⟩}{{\ensuremath{\rangle}}}1
    {ℒ}{{\ensuremath{\mathcal{L}}}}1,
}
\lstdefinestyle{appendixstyle}{
    language=lean,
    numbers=none, 
    frame=none,
    backgroundcolor=\color{white}, 
}
\usepackage{enumitem}
\usepackage{arydshln} 
\usepackage{tcolorbox}
\usepackage{pifont}
\usepackage{framed}
\usepackage{authblk}
\usepackage{natbib}


\title{ATLAS: Autoformalizing Theorems through Lifting, Augmentation, and Synthesis of Data}


\author[1]{Xiaoyang Liu}
\author[1]{Kangjie Bao}
\author[1]{Jiashuo Zhang}
\author[1]{Yunqi Liu}
\author[1]{Yu Chen}
\author[1]{Yuntian Liu}
\author[3,4,*]{Yang Jiao}
\author[1,2,5,*]{Tao Luo}
\affil[1]{School of Mathematical Sciences, Shanghai Jiao Tong University}
\affil[2]{Institute of Natural Sciences, MOE-LSC, Shanghai Jiao Tong University}
\affil[3]{SPEIT, Shanghai Jiao Tong University}
\affil[4]{JoinTech Co., Ltd}
\affil[5]{CMA-Shanghai, Shanghai Artificial Intelligence Laboratory}
\affil[*]{Corresponding author: jiaoyang2002@sjtu.edu.cn, luotao41@sjtu.edu.cn}


\begin{document}
\maketitle


\begin{abstract}
Autoformalization, the process of automatically translating natural language mathematics into machine-verifiable formal language, has demonstrated advancements with the progress of large language models (LLMs). 
However, a key obstacle to further advancements is the scarcity of paired datasets that align natural language with formal language. 
To address this challenge, we introduce ATLAS (\textbf{A}utoformalizing \textbf{T}heorems through \textbf{L}ifting, \textbf{A}ugmentation, and \textbf{S}ynthesis of Data), an iterative data generation framework designed to produce large-scale, high-quality parallel theorem statements.
With the proposed ATLAS running for $10$ iterations, we construct an undergraduate-level dataset comprising $300$k theorem statements and develop the ATLAS translator, achieving accuracies of $80.59\%$ (pass@$8$) and $92.99\%$ (pass@$128$) on ProofNet, significantly outperforming the base model ($23.99\%$ and $47.17\%$) and InternLM2-Math-Plus-7B ($50.94\%$ and $80.32\%$).
Furthermore, the ATLAS translator also achieves state-of-the-art performance on both the high-school-level miniF2F dataset and the graduate-level MathQual dataset introduced in this work.
The datasets, model, and code will be released to the public soon.
\end{abstract}


\section{Introduction} \label{sec:introduction}
In modern mathematics, the growing complexity of proofs and use of computer-assisted proofs have raised concerns. Errors in traditional proofs may go unnoticed for long periods, while computer-assisted proofs often lack manual verifiability, leading to trust issues. For instance, the Four Color Theorem, proposed by Francis Guthrie in 1852, saw Alfred Kempe’s 1879 proof accepted for 11 years until Percy Heawood identified its flaw in 1890. In 1976, Kenneth Appel and Wolfgang Haken provided the first computer-assisted proof, but its reliance on unverifiable computations sparked debate. It was not until 2005 that Georges Gonthier used the Coq \citep{coq} to formally verify the proof. To address such issues, formal languages like Isabelle \citep{isabelle}, HOL Light \citep{hol_light}, Coq, and Lean \citep{lean4_2015, lean4_2021} have undergone significant advancements, leveraging automated verification to rigorously ensure the correctness of proofs.

However, writing mathematical content in formal languages demands a substantial investment of time and requires a deep familiarity with these languages, making the process labor-intensive. This highlights the critical importance of the task of autoformalization, which seeks to translate theorem statements and proofs described in natural language into their formal language counterparts. Given that the accurate formalization of statements is a critical prerequisite for the formalization of proofs, the focus of current research predominantly lies in the autoformalization of theorem statements. Recent advancements in this area have demonstrated promising results, primarily achieved by fine-tuning large language models (LLMs) through the construction of paired datasets. For clarity, we will hereafter refer to theorem statements expressed in natural language as NL statements, and those expressed in formal language as FL statements. The paired data, consisting of NL-FL statements, will be referred to as parallel statements.

To construct parallel statements, previous studies such as MMA \citep{mma} and HERALD \citep{herald} extract FL statements from Mathlib \citep{mathlib} and generate their NL counterparts using LLMs. However, the limited scope and size of Mathlib impose restrictions on the scale of the resulting datasets. Alternative methods, including Lean Workbook \citep{lean_workbook} and DeepSeek-Prover \citep{deepseek_prover}, attempt to generate FL statements from NL sources obtained via large-scale web scraping. Yet, this brute-force strategy often leads to inconsistent quality and necessitates extensive data filtering, introducing inefficiencies. Consequently, it is essential to design a more effective method for generating large-scale, high-quality parallel statements.

In this work, we propose ATLAS (Autoformalizing Theorems through Lifting, Augmentation, and Synthesis of Data), a framework designed to generate large-scale, high-quality parallel theorem statements. And we use Lean4 as our formal language, which will hereafter be abbreviated as Lean. The core of ATLAS is built upon three key components: Data Lifting, Data Synthesis, and Data Augmentation. In Data Lifting, mathematical concepts are lifted and extracted from Mathlib to construct a comprehensive concept repository. In Data Synthesis, the framework relies on teacher models, a student model, and the Lean compiler as its foundational elements. The teacher models, built on a larger and more powerful foundation model, utilize differentiated prompt engineering to perform three key roles: NL Statements Generation (NL-Gen), FL Statements Revision (FL-Rev), and FL Statements Alignment (FL-Align). ATLAS first randomly samples mathematical concepts, uses NL-Gen teacher model to generate NL statements, and has the student model translate these into FL statements. The Lean compiler checks the syntactic validity, routing invalid FL statements to FL-Rev teacher model for modification. FL-Align teacher model then verifies the semantic accuracy of valid FL statements. In Data Augmentation, parallel statements meeting both syntactic and semantic criteria are augmented through proof and contraposition. Finally, the synthetic data, combined with the augmented data, is used to fine-tune the student model for the next iteration.

After $10$ iterations of ATLAS, the synthetic and augmented data collectively form the ATLAS dataset, which consists of $300$k parallel theorem statements. Based on this dataset, we fine-tune a model, referred to as the ATLAS translator, which achieves accuracies of $91.60\%$, $80.59\%$, and $65.47\%$ on miniF2F \citep{minif2f}, ProofNet \citep{proofnet}, and the newly introduced MathQual, respectively, under the pass@$8$ metric. Notably, these results are comparable to or surpass the performance of both the base model and InternLM2-Math-Plus-7B under the pass@$128$ metric. When evaluated with the pass@$128$ metric, the ATLAS translator achieves accuracies of $96.93\%$, $92.99\%$, and $84.72\%$ on these datasets, respectively, establishing state-of-the-art performance.

Our main contributions can be summarized as follows.
\begin{itemize}[topsep=0pt, itemsep=0pt, parsep=0pt]
\item[1.] We propose an iterative data generation framework, ATLAS. Unlike previous approaches that begin by collecting NL or FL statements, our method starts with a concept repository constructed through Data Lifting. In Data Synthesis, we combine the Lean compiler with teacher models to produce high-quality parallel statements. In Data Augmentation, we propose two innovative augmentation methods to further expand the scale of parallel statements.
\item[2.] We introduce two datasets: the ATLAS dataset and the MathQual dataset. The ATLAS dataset, generated by our framework, consists of $300$k undergraduate-level parallel statements, making it one of the largest datasets currently available. In contrast, the MathQual dataset contains $2.5$k graduate-level natural language statements and is designed to evaluate the model's autoformalization capability on more challenging data.
\item[3.] We release the ATLAS translator, fine-tuned on the ATLAS dataset, achieving accuracies of $80.59\%$ (pass@$8$) and $92.99\%$ (pass@$128$) on ProofNet, significantly outperforming the base model ($23.99\%$ and $47.17\%$) and InternLM2-Math-Plus-7B ($50.94\%$ and $80.32\%$). Furthermore, despite being trained exclusively on undergraduate-level data, the ATLAS translator achieves state-of-the-art performance on both the high-school-level miniF2F dataset and the graduate-level MathQual dataset.
\end{itemize}


\section{Related Work}
\smallsec{Autoformalization}
The task of autoformalization can be seen as a machine translation problem \citep{autoformalization_as_translation}, which fundamentally adheres to the principle of mapping content from the source language into expressions that are consistent with the established syntax and lexical system of the target language. Early approaches \citep{nmt_1, nmt_2} have utilized neural machine translation techniques to address the task of autoformalizing theorem statements. With the rapid advancements in LLMs, recent research on LLM-based autoformalization can be broadly categorized into three main paradigms. Specifically, researchers \citep{llm_icl_1, llm_icl_2, llm_icl_3} have developed the application of few-shot prompting to enable LLMs to perform autoformalization effectively, while works such as ProofNet \citep{proofnet} and MMA \citep{mma} have further refined autoformalization performance by fine-tuning LLMs using parallel statements. Furthermore, \citet{rag} integrate retrieval-augmented generation techniques with LLMs to achieve additional improvements. 

\begin{figure*}[!htbp]
\centering
\includegraphics[width=\columnwidth]{figures/atlas_framework.pdf}
\caption{Overview of ATLAS. (a) Data Lifting: Collect mathematical topics from Mathlib to construct the concept repository, thereby preparing for subsequent data synthesis. (b) Data Synthesis: Randomly sample a pair of concepts from the concept repository, then generate an NL statement using NL-Gen teacher model. Subsequently, utilize the student model to translate this NL statement into a FL statement, which is then parsed and passed to the Lean compiler. Any FL statement that fails compilation is forwarded to FL-Rev teacher model for revision, while the modified and successfully compiled FL statement, along with the previously validated FL statement, are sent to FL-Align teacher model for semantic accuracy test. FL statement that passes the semantic accuracy check together with its corresponding NL statement constitutes a high-quality parallel statement, whereas those that fail is discarded, retaining only the NL statement for use in the next iteration. (c) Data Augmentation: Augment the FL statement obtained in the previous step using both proof and contraposition methods, and then use LLMs to construct NL statements. These parallel statements, along with the previously generated parallel statements, collectively form the ATLAS dataset.}
\label{fig:framework}
\end{figure*}

Meanwhile, another research direction focuses on the autoformalization of proofs \citep{proof_1, proof_2, proof_3, internlm_math_plus}, which is more challenging and resembles a simplified automated theorem-proving task. For example, DSP \citep{proof_1} uses LLMs to generate informal proofs, which are then mapped to formal proof sketches. These sketches are used to guide automated  theorem provers in filling these proof gaps.

\smallsec{Dataset Generation}
Obtaining large-scale, high-quality datasets of parallel statements remains a significant challenge. Previous efforts, such as MMA \citep{mma} and HERALD \citep{herald}, have approached this problem by leveraging Mathlib to extract FL statements and employing LLMs to generate their NL counterparts. While effective, the limited scope and size of Mathlib constrains the scalability of these datasets. On the other hand, approaches like Lean Workbook \citep{lean_workbook} and DeepSeek-Prover \citep{deepseek_prover} take the opposite direction, collecting NL statements from large-scale web sources and translating them into FL representations. While this strategy enables the generation of large-scale datasets, these web-based pipelines are susceptible to noise from low-quality sources and depend heavily on extensive post-processing for filtering and validation, which diminishes overall efficiency and compromises dataset quality. In contrast, our proposed method synthesizes NL statements within the controlled concept repository, leveraging a teacher-student paradigm and the Lean compiler to iteratively refine the quality of FL statements, which construct a significantly larger and higher-quality dataset of parallel statements, addressing the scalability and reliability issues of prior work.


\section{Methodology} \label{sec:methodology}
Our framework ATLAS, as illustrated in Figure \ref{fig:framework}, comprises three components: Data Lifting, Data Synthesis, and Data Augmentation. Section \ref{sec:concept_repository} introduces the construction of the concept repository through data lifting, laying the groundwork for subsequent processes. Section \ref{sec:data_synthesis} describes the specific workflow for data synthesis, while Section \ref{sec:data_augmentation} elaborates on the approach to data augmentation, with both together forming the complete steps of a single iteration.

\subsection{Data Lifting} \label{sec:concept_repository}
Mathlib \citep{mathlib}, the most extensive mathematical library within the Lean community, provides a rich repository of formalized mathematical definitions, theorems, and lemmas. This wealth of resources forms the cornerstone of autoformalization, enabling accurate and consistent translation of mathematical content. However, the reliance on Mathlib also exposes a critical limitation: when NL statements involve mathematical definitions that are absent in Mathlib\footnote{https://github.com/leanprover-community/mathlib4, commit \texttt{d942826fbe921454e3ae9942d00b06526e310812}}, such as ``subgradients" or ``subdifferentiation", the autoformalization process becomes highly prone to failure. The underlying reason is that the autoformalization of such NL statements necessitates first constructing the FL representation of the mathematical definition itself before attempting the translation, which is an extremely challenging task for LLMs.

To address the aforementioned limitation, we propose a shift in focus from collecting pre-existing NL statements to constructing a repository of mathematical concepts derived from Mathlib, followed by sampling concepts from this repository to synthesize NL statements. The setup of the repository serves two key purposes. On one hand, it avoids inefficiencies and resource waste caused by unimplemented mathematical definitions in Mathlib. On the other hand, it allows precise control over the mathematical topics involved in the NL statements, enabling greater flexibility and specificity. We refer to the process of abstracting concepts from a larger database to construct this repository as data lifting.

Specifically, we commence by collecting undergraduate-level mathematical topics\footnote{https://github.com/leanprover-community/mathlib4/blob/master/docs/undergrad.yaml} that have already been formalized in Mathlib to construct the concept repository. The repository consists of $13$ domains, $55$ topics, and $350$ concepts. Detailed information about the concept repository can be found in Appendix \ref{app:concept_repository}.

\subsection{Data Synthesis} \label{sec:data_synthesis}
This module is the most critical component of ATLAS, generating a large number of high-quality parallel statements through a teacher-student paradigm. Specifically, the entire process can be likened to an exam where NL statements are translated into FL statements. However, the goal is not only to assess the student’s translation abilities but, more importantly, to construct datasets that encompass both the knowledge the student has mastered and the unmastered knowledge imparted by teachers. The following subsections provide a detailed description of each phase, with the specific prompts provided in Appendix \ref{app:prompt_templates}.

\smallsec{NL Statements Generation}
Inspired by MUSTARD \citep{mustard} and AI-Assisted Math Generation \citep{synthetic_nl}, we similarly sample two mathematical concepts randomly from the repository and utilize the NL-Gen teacher model to generate an NL statement that incorporates these two concepts. This strategy leverages the linguistic capabilities of LLMs, enabling the generation of NL statement that are both reasonable and suitably challenging. In each iteration, a total of 10,000 samples are drawn, resulting in the generation of 10,000 NL statements. 

\smallsec{NL Statements Translation}
After generating the synthetic NL statements, we leverage the student model to translate them into the corresponding FL statements, thereby obtaining the parallel statements. During the initial iteration, the student model is fine-tuned on the MathlibExtract dataset and the Lean Workbook dataset. In subsequent iterations, the fine-tuning process incorporates additional synthetic data in previous iterations, along with augmented data, to iteratively improve and enhance autoformalization performance of the student model.

For MathlibExtract, we leverage LeanDojo \citep{leandojo} to extract FL statements from Mathlib and use LLMs to generate corresponding NL statements, instead of relying on the Mathlib dataset from the MMA dataset \citep{mma}. This choice is motivated by two factors: changes in Lean's syntax rules and continuous updates to Mathlib’s content, which have rendered the MMA dataset outdated.

\smallsec{FL Statements Parsing}
Before conducting syntactic validity test on FL statements, we develop a script using the stack and the \texttt{\#check} tactic to divide each FL Statement into the following four components: \texttt{theorem\_name}, \texttt{theorem\_variables}, \texttt{theorem\_hypotheses}, and \texttt{theorem\_conclusion}. Subsequently, the content is systematically organized line by line, both within and between these components. To provide a detailed explanation, we present a synthetic example obtained through the first two phases and additional synthetic examples with analyses can be found in the Appendix \ref{app:case_study}. The NL statement, along with its associated concepts and domains, is presented as follows.\\
\newpage
\vspace{-15pt}
\begin{table}[!htbp]
\footnotesize
\begin{tabular}{p{\textwidth}}
\texttt{\textbf{Concept1}: Cauchy sequences}\\
\texttt{\textbf{Domain1}: ~Single Variable Real Analysis}\\
\texttt{\textbf{Concept2}: Continuity of integrals with respect to parameters}\\
\texttt{\textbf{Domain2}: ~Measures and integral calculus}\\
\texttt{\textbf{NL statement}: If $\mathtt{f_n}$ is a sequence of continuous functions on $[\mathtt{a, b}]$ that converges uniformly to $\mathtt{f}$, and $\mathtt{g}$ is a continuous function on $\mathtt{R}$, then $\mathtt{\int_a^b f_n(x) g(x)\, dx}$ converges to $\mathtt{\int_a^b f(x) g(x) \, dx}$.}
\end{tabular}
\end{table}
\vspace{-5pt}

And the corresponding FL statement is presented as below.
\begin{lstlisting}[language=lean, numbers=none, numberstyle=\tiny]
theorem tm_name (f : (*@$\mathbb{N} \to \mathbb{R} \to \mathbb{R}$@*)) (f0 : (*@$\mathbb{R} \to \mathbb{R}$@*)) (a b : (*@$\mathbb{R}$@*)) (hab : a (*@$\leq$@*) b) (g : (*@$\mathbb{R} \to \mathbb{R}$@*)) (hg : Continuous g) (hf : (*@$\forall$@*) n, ContinuousOn (f n) (Set.Icc a b)) (h : (*@$\forall$@*) (*@$\varepsilon$@*) : (*@$\mathbb{R}$@*), (*@$\varepsilon$@*) > 0 (*@$\to$@*) (*@$\exists$@*) N : (*@$\mathbb{N}$@*), (*@$\forall$@*) n : (*@$\mathbb{N}$@*), n (*@$\geq$@*) N (*@$\to$@*) (*@$\forall$@*) x (*@$\in$@*) Set.Icc a b, |f n x - f0 x| < (*@$\varepsilon$@*)) : (*@$\forall$@*) (*@$\varepsilon$@*) : (*@$\mathbb{R}$@*), (*@$\varepsilon$@*) > 0 (*@$\to$@*) (ss*@$\exists$@*) N : (*@$\mathbb{N}$@*), (*@$\forall$@*) n : (*@$\mathbb{N}$@*), n (*@$\geq$@*) N (*@$\to$@*) |((*@$\int$@*) x in a..b, f n x * g x) - ((*@$\int$@*) x in a..b, f0 x * g x)| < (*@$\varepsilon$@*) := by sorry
\end{lstlisting}

Through the parsing of the given FL statement and the subsequent organization line by line, the resulting FL statement is presented below. Specifically, Line $1$ corresponds to \texttt{theorem\_name}, Lines $2\sim5$ correspond to \texttt{theorem\_variables}, Lines $6\sim9$ correspond to section \texttt{theorem\_hypotheses}, and Line $10$ corresponds to \texttt{theorem\_conclusion}. Compared to placing the entire content of the FL statement on a single line, especially when the FL statement contains a large amount of content, this configuration enhances the clarity of the feedback obtained after compilation, particularly by making error locations more explicit, which enables LLMs to more effectively identify and correct errors in FL statements that fail to compile.
\begin{lstlisting}[language=lean, numbers=left, numberstyle=\tiny]
theorem tm_name
(f : (*@$\mathbb{N} \to \mathbb{R} \to \mathbb{R}$@*))
(f0 : (*@$\mathbb{R} \to \mathbb{R}$@*))
(a b : (*@$\mathbb{R}$@*))
(g : (*@$\mathbb{R} \to \mathbb{R}$@*))
(hab : a (*@$\leq$@*) b)
(hg : Continuous g)
(hf : (*@$\forall$@*) n, ContinuousOn (f n) (Set.Icc a b))
(h : (*@$\forall$@*) (*@$\varepsilon$@*) : (*@$\mathbb{R}$@*), (*@$\varepsilon$@*) > 0 (*@$\to$@*) (*@$\exists$@*) N : (*@$\mathbb{N}$@*), (*@$\forall$@*) n : (*@$\mathbb{N}$@*), n (*@$\geq$@*) N (*@$\to$@*) (*@$\forall$@*) x (*@$\in$@*) Set.Icc a b, |f n x - f0 x| < (*@$\varepsilon$@*)) 
: (*@$\forall$@*) (*@$\varepsilon$@*) : (*@$\mathbb{R}$@*), (*@$\varepsilon$@*) > 0 (*@$\to$@*) (*@$\exists$@*) N : (*@$\mathbb{N}$@*), (*@$\forall$@*) n : (*@$\mathbb{N}$@*), n (*@$\geq$@*) N (*@$\to$@*) |((*@$\int$@*) x in a..b, f n x * g x) - ((*@$\int$@*) x in a..b, f0 x * g x)| < (*@$\varepsilon$@*) := by sorry
\end{lstlisting}

\smallsec{FL Statements Compilation}
In this phase, the Lean compiler's REPL (Read-Eval-Print Loop) is used to verify the syntactic validity of FL statements by checking if they compile successfully. Specifically, the implementation of REPL is primarily derived from the framework provided by the Lean community\footnote{https://github.com/leanprover-community/repl}, with additional reference to the codebase of Automatic Lean4 Compilation\footnote{https://github.com/rookie-joe/automatic-lean4-compilation}. Notably, since the student model lacks the capability to generate headers, a standard header, \texttt{import Mathlib}, is appended during the compilation process.

\smallsec{FL Statements Revision}
For FL statements that fail to compile, we utilize the corresponding NL statements and compilation error messages as context, providing this information to FL-Rev teacher model for modifications. The modified FL statements are then subjected to a second round of compilation. Ultimately, only the FL statements that successfully pass either the first or second compilation are retained. The underlying concept of this design is to enable a stronger model to guide a weaker model, thereby facilitating the transfer of knowledge from the former to the latter. This process allows the weaker model to progressively improve its performance and the subsequent experimental results validate the effectiveness of this design approach.

\smallsec{FL Statements Alignment}
For FL statements that pass the first or second compilation, FL-Align teacher model evaluates their semantic accuracy in translating the corresponding NL statement, ensuring no information is omitted or mistranslated. Specifically, the model is required to assess each pair of parallel statements and assign a rating from three categories: good, average, and poor. Pairs rated as good or average are retained, while pairs rated as poor, along with FL statements failing both compilations, have only their NL statements preserved for the next iteration's NL Statements Translation phase.

Note that we do not employ back-translation of FL statements into NL statements to compare their semantic accuracy with the original NL statements in this phase. Typically, back-translation is introduced to mitigate the influence of Lean on the model's performance. However, in our approach, we select teacher models that exhibit exceptional proficiency in Lean, facilitating an efficient transfer of knowledge from teacher models to the student model. This strategy enables a direct evaluation of semantic accuracy between NL and FL statements.

\subsection{Data Augmentation} \label{sec:data_augmentation}
This module augments the synthetic parallel statements in Section \ref{sec:data_synthesis} to further expand the
scale of data, leveraging the Lean compiler and employing two innovative methods: proving these FL statements and converting them into the contrapositive propositions.

\smallsec{Augmentation via Proof}
For each FL statement in the synthetic data, we use DeepSeek-Prover-V1.5 \citep{deepseek_prover_v1.5} to provide a proof. Then, the proof steps are executed interactively in Lean compiler step by step. Each time a tactic is successfully applied and the proof process has not yet concluded, Lean compiler's Infoview generates feedback containing the current variables, hypotheses, and conclusions. Leveraging the stack and regular expressions, we develop a script capable of constructing new FL statements directly from the content of the Infoview. Continuing with the example from Section \ref{sec:data_synthesis} FL Statements Parsing, after applying tactic \texttt{intro $\varepsilon$ $\varepsilon$pos}, the FL statement constructed from the Infoview is as follows.
\begin{lstlisting}[language=lean, numbers=none, numberstyle=\tiny]
theorem tm_name
(f : (*@$\mathbb{N} \to \mathbb{R} \to \mathbb{R}$@*))
(f0 : (*@$\mathbb{R} \to \mathbb{R}$@*))
(a b : (*@$\mathbb{R}$@*))
(g : (*@$\mathbb{R} \to \mathbb{R}$@*))
((*@$\varepsilon$@*) : (*@$\mathbb{R}$@*))
(hab : a (*@$\leq$@*) b)
(hg : Continuous g)
((*@$\varepsilon$@*)pos : (*@$\varepsilon > 0$@*))
(hf : (*@$\forall$@*) (n : (*@$\mathbb{N}$@*)), ContinuousOn (f n) (Set.Icc a b))
(h : (*@$\forall$@*) (*@$\varepsilon$@*) > 0 (*@$\to$@*) (*@$\exists$@*) N, (*@$\forall$@*) n (*@$\geq$@*) N, (*@$\forall$@*) x (*@$\in$@*) Set.Icc a b, |f n x - f0 x| < (*@$\varepsilon$@*)) 
: (*@$\exists$@*) N, (*@$\forall$@*) n (*@$\geq$@*) N, |((*@$\int$@*) (x : (*@$\mathbb{R}$@*))  in a..b, f n x * g x) - (*@$\int$@*) (x : (*@$\mathbb{R}$@*)) in a..b, f0 x * g x| < (*@$\varepsilon$@*) := by sorry
\end{lstlisting}

\smallsec{Augmentation via Contraposition}
In Section \ref{sec:data_synthesis} FL Statement Parsing, we obtain the \texttt{theorem\_hypotheses} for each FL statement. From this, we can extract the names of all the hypotheses and form a set, denoted as $hypotheses$, with its elements represented as $h$. Utilizing the \texttt{contrapose!} tactic, we can apply \texttt{contrapose! h} sequentially to each element $h$ in $hypotheses$, transforming the original proposition into an equivalent contrapositive statement for each hypothesis. After applying this transformation, new FL statements are constructed based on the updated information provided in Lean's Infoview. Continuing with the example from Section \ref{sec:data_synthesis} FL Statements Parsing, after applying tactic \texttt{contrapose!~hab}, we derive an equivalent contrapositive FL statement: the negation of the original conclusion becomes the new hypothesis, referred to as \texttt{hab}, while the negation of the original hypothesis hab becomes the new conclusion.
\begin{lstlisting}[language=lean, numbers=none, numberstyle=\tiny]
theorem tm_name
(f : (*@$\mathbb{N} \to \mathbb{R} \to \mathbb{R}$@*))
(f0 : (*@$\mathbb{R} \to \mathbb{R}$@*))
(a b : (*@$\mathbb{R}$@*))
(g : (*@$\mathbb{R} \to \mathbb{R}$@*))
(hg : Continuous g) 
(hf : (*@$\forall$@*) (n : (*@$\mathbb{N}$@*)), ContinuousOn (f n) (Set.Icc a b))
(h : (*@$\forall$@*) (*@$\varepsilon$@*) > 0, (*@$\exists$@*) N, (*@$\forall$@*) n (*@$\geq$@*) (*@$\mathbb{N}$@*), n (*@$\geq$@*) N, (*@$\forall$@*) x (*@$\in$@*) Set.Icc a b, |f n x - f0 x| < (*@$\varepsilon$@*)) 
(hab : (*@$\exists$@*) (*@$\varepsilon$@*) > 0, (*@$\forall$@*) (N : (*@$\mathbb{N}$@*)), (*@$\exists$@*) n (*@$\geq$@*) N, (*@$\varepsilon$@*) (*@$\leq$@*) |((*@$\int$@*) (x : (*@$\mathbb{R}$@*)) in a..b, f n x * g x) - (*@$\int$@*) (x : (*@$\mathbb{R}$@*)) in a..b, f0 x * g x|) 
: b < a := by sorry
\end{lstlisting}

\smallsec{Augmentation Dataset Construction}
The aforementioned augmentation operations both rely on Lean compiler’s Infoview. However, Infoview occasionally results in information loss. For instance, in the case of augmentation via contraposition, the types associated with $N$ and $\varepsilon$ are lost (i.e., $N : \mathbb{N}, \varepsilon : \mathbb{R}$). While these types can be internally inferred by the Lean compiler without causing compilation errors, some instances of information loss can lead to critical errors. For example, consider the following FL statement derived from the PutnamBench \citep{putnambench}.
\begin{lstlisting}[language=lean, numbers=none, numberstyle=\tiny]
theorem putnam_1965_b5
{K : Type*}
[Fintype K]
(V E : (*@$\mathbb{N}$@*))
(hV : V = Nat.card K)
(hE : 4*E (*@$\leq$@*) V^2)
: (*@$\exists$@*) G : SimpleGraph K, G.edgeSet.ncard = E (*@$\wedge$@*) (*@$\forall$@*) a : K, (*@$\forall$@*) w : G.Walk a a, w.length (*@$\neq$@*) 3 := by sorry
\end{lstlisting}

When this FL statement is entered into the Lean compiler, the information provided by Infoview, however, loses the type information for $G$ (i.e., $G : SimpleGraph~K$). Consequently, the constructed FL statement will lack this critical type detail, which is necessary for compilation and leading to a compilation error. Thus, we conduct the FL Statements Compilation on the aforementioned FL statements generated through augmentation. Only FL statements that pass the compilation are retained and paired with corresponding NL statements using LLMs.
\begin{lstlisting}[language=lean, numbers=none, numberstyle=\tiny]
theorem putnam_1965_b5
{K : Type*}
[Fintype K]
(V E : (*@$\mathbb{N}$@*))
(hV : V = Nat.card K)
(hE : 4*E (*@$\leq$@*) V^2)
: (*@$\exists$@*) G : G.edgeSet.ncard = E (*@$\wedge$@*) (*@$\forall$@*) (a : K), (w : G.Walk a a), w.length (*@$\neq$@*) 3 := by sorry
\end{lstlisting}


\section{Experiments} \label{sec:experiments}
\subsection{ATLAS Dataset Construction} \label{sec:atlas_dataset_construction}

\begin{figure}[htbp]
\begin{minipage}{0.48\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/atlas_dataset_1.pdf}
\caption{Syntactic validity rates and semantic correctness counts of student and FL-Rev teacher models. The line plot corresponds to the left y-axis, while the bar chart corresponds to the right y-axis.}
\label{fig:atlas_dataset_1}
\end{minipage}
\hfill 
\begin{minipage}{0.48\textwidth}
\centering
\includegraphics[width=\linewidth]{figures/atlas_dataset_2.pdf}
\caption{The amount of data generated by ATLAS in each iteration: synthetic data, proof-augmented data, and contraposition-augmented data.}
\label{fig:atlas_dataset_2}
\end{minipage}
\end{figure}

\smallsec{Experimental Setup}
In this work, we utilize DeepSeek-V2.5 as the foundation model for these teacher models, which is consistently accessed via API calls with the temperature parameter set to $0.7$. The student model is Llama3.1-8B-Instruct \citep{llama3.1}, aiming to transform general-purpose LLMs into Lean4 experts \citep{theoremllama}. And we utilize nucleus sampling \citep{top_p} with top $p = 0.9$ at a temperature of $0.6$ for sampling generation. After each iteration, we fine-tune the student model using a learning rate of $1 \times 10^{-5}$ with a cosine decay schedule over $3$ training epochs.

\smallsec{Results}
We conduct 10 iterations using ATLAS and carry out a comprehensive analysis of the data generated throughout the iterative process. As shown in Figure \ref{fig:atlas_dataset_1}, during the FL Statements Compilation phase, the syntactic validity rate of the student model gradually improves, while the validity rate of the FL-Rev teacher model initially increases but later declines. This phenomenon occurs because the student model performs poorly in the early iterations, resulting in many incorrect translations that necessitate corrections by the teacher model. Over several iterations, the student model learns from the teacher's corrections, improving its performance and reducing the need for further revisions by the teacher model. On the other hand, during the FL Statements Alignment stage, the number of semantically accurate translations by the student model gradually increases. These two metrics together indicate that the student model's ability for autoformalization is steadily improving under the continuous guidance of the teacher model.

Figure \ref{fig:atlas_dataset_2} presents the amount of synthetic data, proof-augmented data, and contraposition-augmented data generated in each iteration. Both the synthetic data volume and augmented data volume show a steady increase as the iterations progress. Among the augmented data, proof-augmented data accounts for a larger proportion, which is intuitive since the number of proof steps for a problem typically exceeds the number of assumptions by a significant margin. It is also worth noting that from the $7$th to the $10$th iteration, the total generated data volume in each round exceeds $45$k, demonstrating the high efficiency of ATLAS.

\subsection{ATLAS Translator Evaluation} \label{atlas_translator_evaluation}


\begin{table*}[!htbp]
\setlength{\tabcolsep}{1.5mm}
\centering
\caption{Performance comparison of different models across various datasets. 12-shot prompting involves enhancing the prompt with 12 parallel theorem statements randomly sampled from the ATLAS dataset as examples, with the same set of 12 examples used across all models performing 12-shot prompting. The version of GPT-4o used is \texttt{gpt-4o-2024-11-20} and the pass@$128$ results are excluded due to its relatively unremarkable performance under 12-shot prompting. SFT denotes models fine-tuned on the MathlibExtract and the Lean Workbook. The results of HERALD \citep{herald} are computed as the average performance across both the validation and test datasets. The last four rows represent ablation studies, indicating which datasets are used to fine-tune the base model. In addition, except for HERALD, the prompts used during inference for all models are consistent with those shown in Table \ref{tab:nl_statements_translation}.\\}
\label{tab:model_performance_comparison}
\scalebox{0.83}{
\begin{tabular}{lccccccccc}
\toprule
\multirow{2}{*}{Model} & \multicolumn{3}{c}{miniF2F} & \multicolumn{3}{c}{ProofNet} & \multicolumn{3}{c}{MathQual}\\
\cline{2-10}
& pass@$1$ & pass@$8$ & pass@$128$ & pass@$1$ & pass@$8$ &pass@$128$ &pass@$1$ & pass@$8$ & pass@$128$ \\
\hline
Llama3.1-8B-Instruct (12-shot) & 22.75\% & 62.91\% & 85.66\% & 8.09\% & 23.99\% & 47.17\% & 2.64\% & 5.66\% & 20.57\%\\
GPT-4o (12-shot) & 57.79\% & 84.63\% & - & 32.35\% & 57.95\% & - & 12.83\% & 28.68\% & -\\
DeepSeek-V2.5 (12-shot) & 74.80\% & 85.04\% & 89.96\% & 38.54\% & 52.83\% & 62.53\% & 16.23\% & 25.09\% & 34.15\%\\
Llama3.1-8B-Instruct (SFT) & \textbf{79.10\%} & \textbf{93.65\%} & 96.72\% & 30.73\% & 51.21\% & 66.31\% & 14.34\% & 27.36\% & 46.60\% \\
InternLM2-Math-Plus-7B & 18.24\% & 59.63\% & 92.01\% & 15.90\% & 50.94\% & 80.32\% & 3.77\% & 17.74\% & 50.75\%\\
HERALD & - & -  & 96.50\% & -  & - & 85.15\% & -  & -  & - \\
\textbf{ATLAS Translator} & 70.08\% & 91.60\% & \textbf{96.93\%} & \textbf{56.87\%} & \textbf{80.59\%} & \textbf{92.99\%} & \textbf{38.87\%} & \textbf{65.47\%} & \textbf{84.72}\%\\
\hdashline
w/ Synthetic Data & 67.21\% & 89.96\% & 95.29\% & 52.83\% & 77.90\% & 91.91\% & 36.23\% & 60.38\% & 82.08\%\\
w/ Augmented Data (Total) & 58.61\% & 86.68\% & 95.08\% & 38.01\% & 66.31\% & 83.02\% & 20.94\% & 43.58\% & 68.68\%\\
w/ Augmented Data (Proof) & 57.38\% & 81.76\% & 94.06\% & 31.00\% & 60.38\% & 78.71\% & 18.68\% & 35.66\% & 60.19\%\\
w/ Augmented Data (Contraposition) & 61.27\% & 87.70\% & 95.90\% & 29.65\% & 60.92\% & 81.67\% & 19.62\% & 44.91\% & 64.53\%\\
\bottomrule
\end{tabular}
}
\label{tb:alphafact}
\end{table*}

\smallsec{Experimental Setup}
In this section, we fine-tune Llama3.1-8B-Instruct exclusively on the ATLAS dataset to develop the ATLAS translator, then compare its autoformalization ability with other models on three datasets: miniF2F \citep{minif2f}, ProofNet \citep{proofnet}, and MathQual. The versions of miniF2F and ProofNet used in this evaluation are derived from DeepSeek\footnote{https://github.com/deepseek-ai/DeepSeek-Prover-V1.5/tree/main/datasets}. MathQual is a graduate-level dataset proposed in our work, consisting of $2.5$k NL statements, designed to evaluate the model's generalization ability on more challenging datasets.

We use the pass@$k$ metric \citep{pass_k} for evaluation, with $k=1, 8, 128$. Pass@$k$ represents the proportion passing both syntactic validity and semantic accuracy tests. For semantic accuracy test, we follow the methodology described in the Lean Workbook \citep{lean_workbook} and HERALD \citep{herald}: FL statements are back-translated into NL statements using InternLM2-Math-Plus-7B \citep{internlm_math_plus}, and DeepSeek-V2.5 is used to compare the back-translated NL statements with the original FL statements to ensure consistency. Here, $k$ represents the number of candidates generated per NL statement. And we consider the translation successful if any of these candidates pass both the syntactic validity and semantic accuracy tests.

Notably, given the large number of samples in MathQual, we use a subset for evaluation. This subset is constructed by sampling from each domain, with the sample size determined as $\lfloor \frac{\text{number of samples in the domain}}{5} \rfloor + 1$. Detailed information about the construction process and specifics of Mathqual can be found in Appendix \ref{app:mathqual}. The fine-tuning and sampling parameters are configured identically to those outlined in the Experimental Setup in Section \ref{sec:atlas_dataset_construction}.

\smallsec{Results}
Comparing the performance of different models, ATLAS translator consistently outperforms its counterparts across nearly all datasets and evaluation metrics. On the one hand, ATLAS translator achieves $56.87\%$, $80.59\%$, and $92.99\%$ accuracy under pass@$1$, pass@$8$, and pass@$128$ on ProofNet, respectively, significantly outperforming both the base model Llama3.1-8B-Instruct and teacher model DeepSeek-V2.5 with 12-shot prompting, demonstrating that our approach effectively enables knowledge transfer from a stronger model to a weaker one, allowing the latter to progressively improve and eventually surpass its teacher. In addition, the ATLAS translator also outperforms the currently strong-performing model InternLM2-Math-Plus-7B, particularly as the accuracy of ATLAS translator under pass@$8$ is comparable to that of model InternLM2-Math-Plus-7B under pass@$128$. These results underscore the remarkable quality of the ATLAS dataset and demonstrate the effectiveness of the proposed framework.

On the other hand, despite being trained exclusively on undergraduate-level data, the ATLAS translator also achieves state-of-the-art performance on both the high-school-level miniF2F dataset and the graduate-level MathQual dataset, showcasing the model's strong generalization capabilities. The slightly lower pass@$1$ and pass@$8$ performance on miniF2F compared to Llama3.1-8B-Instruct (SFT) can be attributed to the high similarity between the Lean Workbook and miniF2F, as both are predominantly composed of computational problems. 

Comparing the results of the ablation experiments, the model fine-tuned using only synthetic data performs similarly to ATLAS translator, demonstrating the high quality of synthetic data and the effectiveness of the synthesis strategy. Upon observing the performance of models fine-tuned with proof-augmented data and contraposition-augmented data, the latter proves to be more effective. This can be attributed to the fact that the quality of proof-augmented data heavily depends on the correctness of the proofs, yet generating correct and high-quality proofs for FL statements remains an immensely challenging task. However, the model fine-tuned on either augmented dataset individually, as well as on the combination of both, achieves performance on par with InternLM2-Math-Plus-7B, demonstrating the effectiveness of both augmentation strategies.


\section{Conclusion}
In this work, we propose a novel framework to advancing autoformalization by synthesizing and augmenting large-scale, high-quality datasets of natural language (NL) and formal language (FL) theorem statements, starting with data lifting. Our method addresses key limitations of existing approaches, such as the finite amount of data that can be extracted from repositories like Mathlib or the inconsistent data quality obtained from large-scale web scraping. By leveraging synthetic NL statements and iteratively fine-tuning the student model, we demonstrated a scalable and efficient framework for generating parallel NL-FL statements, significantly enhancing the autoformalization process.

Our proposed ATLAS translator, fine-tuned on the ATLAS dataset, achieves state-of-the-art performance across multiple benchmarks, including miniF2F, ProofNet, and the newly introduced MathQual dataset. Notably, the ATLAS translator achieves an accuracy of $92.99\%$ (pass@$128$) on ProofNet and demonstrates strong generalization capabilities, achieving an accuracy of $96.93\%$ on miniF2F and an accuracy of $84.72\%$ on MathQual under pass@$128$. These results underscore the efficacy of our dataset and framework, as well as the robustness of our model when applied to diverse and challenging mathematical statements.

In addition, our proposed framework is highly generalizable. For data lifting, it allows the creation of concept repositories across various formal languages, mathematical domains, and levels of difficulty, which can then be combined with data synthesis techniques to generate corresponding datasets. While our data augmentation approach relies on feedback from the Lean compiler, it is inherently applicable to any mathematical problem, as altering the problem's state through proof steps or reformulating it as a contraposition are fundamental operations in mathematics. 
These flexibilities highlight the broader applicability of our framework beyond Lean, making it a valuable tool for advancing formalization. By improving the scalability and accessibility of autoformalization, our work also paves the way for wider adoption of formal verification in mathematics and future advancements in automated theorem proving.


\section*{Acknowledgements}
This work is sponsored by the National Key R\&D Program of China Grant No. 2022YFA1008200 (T. L.),  Shanghai Municipal Science and Technology Key Project No. 22JC1401500 (T. L.), Shanghai Municipal of Science and Technology Major Project No. 2021SHZDZX0102 (T. L.). We appreciate the insightful discussions with Wei Zhao, Xinpu Tu, and Shuyu Yin during the early stages of the project.


\bibliography{main}
\bibliographystyle{arxiv}
\newpage
\appendix
\onecolumn
\section{Concept Repository} \label{app:concept_repository}
The complete concept repository is composed of $13$ domains, $55$ topics, and $350$ concepts. For the sake of clarity and brevity, Table~\ref{tab:concept_repository} only presents a subset of topics from $3$ domains, along with their corresponding concepts. And the full repository can be accessed in the open-source material.
\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{Partial list of mathematical concepts in the concept repository}
\label{tab:concept_repository}
\begin{tabular}{lll}
\toprule
\textbf{Domain} & \textbf{Topic} & \textbf{Concept}\\
\midrule
\multirow{16}{2.5cm}{Linear Algebra} % Linear Algebra
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Fundamentals} 
    & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{vector space, product of vector spaces, vector subspace, quotient space, sum of subspaces, direct sum, complementary subspaces, linear independence, generating sets, bases, existence of bases, linear map, range of a linear map, kernel of a linear map, algebra of endomorphisms of a vector space, general linear group}\\
    \cmidrule{3-3}
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Duality} 
    & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{dual vector space, dual basis, transpose of a linear map}\\
    \cmidrule{3-3}
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Finite-dimensional vector spaces} 
    & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{finite-dimensionality, isomorphism with $K^n$, rank of a linear map, rank of a set of vectors, isomorphism with bidual}\\
    \cmidrule{3-3}
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Multilinearity} 
    & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{multilinear map, determinant of vectors, determinant of endomorphisms, orientation of a $\mathbb{R}$-vector space}\\
    \cmidrule{3-3}
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Matrices} & 
    \makecell[{{>{\raggedright}p{.6\textwidth}}}]{commutative-ring-valued matrices, field-valued matrices, matrix representation of a linear map, change of basis, rank of a matrix, determinant, invertibility}\\
    \cmidrule{3-3}
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Endomorphism polynomials} & 
    \makecell[{{>{\raggedright}p{.6\textwidth}}}]{annihilating polynomials, minimal polynomial, characteristic polynomial, Cayley-Hamilton theorem}\\
    \cmidrule{3-3}
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Structure theory of endomorphisms} 
    & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{eigenvalue, eigenvector, generalized eigenspaces, Jordan-Chevalley-Dunford decomposition}\\
        \cmidrule{2-3}

\multirow{4}{2.5cm}{Single Variable Complex Analysis} % Single Variable Complex Analysis
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Complex Valued series}
    & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{radius of convergence, continuity, differentiability with respect to the complex variable, complex exponential, extension of trigonometric functions(cos) to the complex plane, extension of trigonometric functions(sin) to the complex plane, power series expansion of elementary functions(cos), power series expansion of elementary functions(sin)}\\
    \cmidrule{3-3}
 & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Functions on one complex variable}
    & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{holomorphic functions, Cauchy formulas, analyticity of a holomorphic function, principle of isolated zeros, principle of analytic continuation, maximum principle, holomorphic stability under uniform convergence}\\
        \cmidrule{2-3}

\multirow{14}{2.5cm}{Topology} % Topology
    & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Topology and Metric Spaces}
        & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{topology of a metric space, induced topology, finite product of metric spaces, limits of sequences, cluster points, continuous functions, homeomorphisms, compactness in terms of open covers (Borel-Lebesgue), sequential compactness is equivalent to compactness (Bolzano-Weierstrass), connectedness, connected components, path connectedness, Lipschitz functions, uniformly continuous functions, Heine-Cantor theorem, complete metric spaces, contraction mapping theorem}\\
        \cmidrule{3-3}
    & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Normed vector spaces on $\mathbb{R}$ and $\mathbb{C}$} 
        & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{topology on a normed vector space, Banach open mapping theorem, equivalence of norms in finite dimension, norms $\lVert \cdot \rVert_p$ on $\mathbb{R}^n$ and $\mathbb{C}^n$, absolutely convergent series in Banach spaces, continuous linear maps, norm of a continuous linear map, uniform convergence norm (sup-norm), normed space of bounded continuous functions, completeness of the space of bounded continuous functions, Heine-Borel theorem (closed bounded subsets are compact in finite dimension), Riesz' lemma (unit-ball characterization of finite dimension), Arzela-Ascoli theorem}\\
        \cmidrule{3-3}
    & \makecell[{{>{\raggedright}p{.15\textwidth}}}]{Hilbert spaces} 
        & \makecell[{{>{\raggedright}p{.6\textwidth}}}]{Hilbert projection theorem, orthogonal projection onto closed vector subspaces, dual space, Riesz representation theorem, inner product space $l^2$, completeness of $l^2$, inner product space $L^2$, completeness of $L^2$, Hilbert bases, example, the Hilbert basis of trigonometric polynomials, Lax-Milgram theorem}\\
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}


\section{Prompt Templates} \label{app:prompt_templates}
This section presents all the prompts utilized in this paper to facilitate the reproducibility of our work. Specifically, the contents presented in each table are as follows.
\begin{itemize}
\item Table \ref{tab:nl_statements_generation} demonstrates the prompt template used in the NL Statements Generation phase, where \texttt{domain1}, \texttt{concept1}, \texttt{domain2}, and \texttt{concept2} are randomly sampled from the concept repository;
\item Table \ref{tab:nl_statements_translation} demonstrates the prompt template used in the NL Statements Translation phase, which is also utilized during model fine-tuning and inference;
\item Table \ref{tab:fl_statements_revision} demonstrates the prompt template used in the FL Statements Revision phase, where \texttt{query} contains the FL statement, the corresponding NL statement, and compilation error messages;
\item Table \ref{tab:fl_statements_alignment} demonstrates the prompt template used in the FL Statements Alignment phase, where \texttt{query} contains the FL statement and the corresponding NL statement;
\item Table \ref{tab:back_translation} demonstrates the prompt template used in the Back Translation phase  of the experiment section;
\item Table \ref{tab:semantic_contrast} demonstrates the prompt template used in the Semantic Contrast phase of the experiment section.
\end{itemize}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{Prompt Template for NL Statements Generation}
\label{tab:nl_statements_generation}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\makecell[l]{\textbf{Prompt Template for NL Statements Generation}} \\
\midrule
\texttt{You are an expert mathematics professor tasked with creating proof problems for undergraduate mathematics majors. Your assignment is to construct a proof problem that integrates \{concept1\} from \{domain1\} and \{concept2\} from \{domain2\}.}\\
\\
\texttt{Follow these guidelines:}\\ 
\texttt{1. Create a concise theorem appropriate for undergraduate mathematics majors.}\\
\texttt{2. The theorem should be brief, not exceeding 50 words.}\\
\texttt{3. Incorporate both specified concepts into the theorem naturally.}\\ 
\texttt{4. State the theorem clearly and concisely.}\\ 
\texttt{5. Ensure the theorem is simple enough to be easily translated into Lean4.}\\ \\
\texttt{Present your problem using exactly this format:}\\
\texttt{\# Theorem (Natural language):}\\
\texttt{Theorem: Insert the theorem in natural language here.}\\
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{Prompt Template for NL Statements Translation}
\label{tab:nl_statements_translation}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\makecell[l]{\textbf{Prompt Template for NL Statements Translation}} \\
\midrule
\texttt{You are an expert in the Lean4 theorem prover. Your task is to translate theorems from natural language into formal Lean4 statements.}\\
\\
\texttt{Please follow these guidelines:}\\ 
\texttt{1. Carefully analyze the given theorem in natural language.}\\
\texttt{2. Translate it into a correct and precise Lean4 formal statement.}\\
\texttt{3. Use the following format for your response:}\\
\texttt{theorem tm\_name : The theorem's Lean4 formal statement := by sorry}\\
\texttt{4. Focus solely on the translation. Do not attempt to prove the theorem or provide additional explanations.}\\
\texttt{5. Ensure that your translation accurately captures all the mathematical concepts and relationships expressed in the natural language version.}\\
\texttt{6. Use appropriate Lean4 syntax, including correct use of quantifiers, implications, and mathematical symbols.}\\
\texttt{7. If the theorem involves specific mathematical structures (e.g., groups, rings, topological spaces), use the corresponding Lean4 definitions and notations.}\\
\\
\texttt{Remember, the goal is to create a syntactically correct and semantically accurate formalization in Lean4. Your translation should be faithful to the meaning of the original theorem while adhering to Lean4 conventions and best practices.}\\
\\
\texttt{Now please begin by carefully reading the natural language statement provided, and then proceed with your translation into Lean4.}\\
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{Prompt Template for FL Statements Revision}
\label{tab:fl_statements_revision}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\makecell[l]{\textbf{Prompt Template for FL Statements Revision}} \\
\midrule
\texttt{You are a math expert and an expert in Lean4. Your task is to modify the Lean4 code based on the given natural language description of a theorem, the corresponding Lean4 code, and the error message from the Lean compiler.}\\
\\
\texttt{Follow these guidelines:}\\ 
\texttt{1. Correct the Lean4 code to make it compile successfully.}\\
\texttt{2. Lean4 code may lack or have additional declarations of certain content. You can add or remove them as much as possible to keep it consistent with the natural language description.}\\
\texttt{3. No need to import any packages, because Mathlib will be imported by default as import Mathlib.}\\ 
\texttt{4. Carefully read the content and provide your modified answer: \{query\}}\\
\\
\texttt{Present your corrected Lean4 code using exactly this format:}\\
\texttt{\# Analysis:}\\
\texttt{Insert your analysis here}\\
\texttt{\# Corrected Lean4 code:}\\
\texttt{Insert the corrected Lean4 code here.}\\
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{Prompt Template for FL Statements Alignment}
\label{tab:fl_statements_alignment}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\makecell[l]{\textbf{Prompt Template for FL Statements Alignment}} \\
\midrule
\texttt{You are a math expert and an expert in Lean4. Your task is to check the alignment between the given natural language description of a theorem and the corresponding Lean4 code.}\\ 
\\
\texttt{Follow these guidelines:}\\ 
\texttt{1. Determine whether the Lean4 code is missing declarations of certain entities.}\\
\texttt{2. Assess whether the Lean4 code accurately represents the theorem described in the natural language.}\\
\texttt{3. Carefully read the content and provide your answer: \{query\}}\\ 
\\
\texttt{Present your answer using exactly this format:}\\
\texttt{\# Analysis:}\\
\texttt{Insert your analysis here}\\
\texttt{\# Alignment check result:}\\
\texttt{good, average or poor}\\
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{Prompt Template for Back Translation}
\label{tab:back_translation}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\makecell[l]{\textbf{Prompt Template for Back Translation}} \\
\midrule
\texttt{Convert the theorem described in lean below into a theorem described in natural language and do not try to solve the problem or output any additional content.}\\ 
\\
\texttt{```}\\
\texttt{lean}\\ 
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\newpage
\onecolumn
\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{Prompt Template for Semantic Contrast}
\label{tab:semantic_contrast}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\makecell[l]{\textbf{Prompt Template for Semantic Contrast}} \\
\midrule
\texttt{You are an experienced mathematics expert and educator with extensive experience in mathematical problem analysis. I need you to analyze the fundamental nature of the following two mathematical problems.}\\ 
\\
\texttt{Focus on:}\\ 
\texttt{1. Core mathematical concepts and principles}\\
\texttt{2. Problem-solving approaches and methodologies}\\
\texttt{3. Ultimate objectives of the problems}\\ 
\\
\texttt{Ignore:}\\
\texttt{1. Variations in wording}\\
\texttt{2. Changes in contextual scenarios}\\
\\
\texttt{Present your answer using exactly this format:}\\
\texttt{\# Analysis:}\\
\texttt{Insert your analysis here}\\
\texttt{\# Conclusion: }\\
\texttt{same or different}\\
\\
\texttt{Please approach this analysis with professional rigor.}\\
\texttt{\# Math Problem 1: \{data{[i]}{["nl"]}\}}\\
\texttt{\# Math Problem 2: \{data{[i]}{["back\_translation"]}\}}\\
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}


\section{Case Study} \label{app:case_study}
This section presents both successful and unsuccessful cases of synthetic data during the ATLAS iterative process. Tables \ref{tab:successful_example_1} to \ref{tab:successful_example_6} display successful cases generated by ATLAS, while Tables \ref{tab:failed_example_1} and \ref{tab:failed_example_2} illustrate the failed cases, each accompanied by corresponding analyses. The FL statements consist of multiple rounds, with content highlighted in red boxes indicating syntactic errors or inconsistencies with the relevant NL statements. Iteration for each data point ceases when there are no syntactic or semantic errors in the FL statement. The cases below demonstrate that, as the model iterates, it is able to formalize mathematical concepts in Lean with increasing accuracy.

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A successful case generated by ATLAS}
\label{tab:successful_example_1}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
In the first round, the model incorrectly formalized the matrix notation in Lean. However, in the second round, the formalization was correct.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} commutative-ring-valued matrices}\\
\texttt{\textbf{Domain1:} ~Linear algebra}\\
\texttt{\textbf{Concept2:} determinant}\\
\texttt{\textbf{Domain2:} ~Linear algebra}\\
\texttt{\textbf{NL statement:} For any commutative ring $R$ and any two $n\times n$ matrices $A$ and $B$ over $R$, the determinant of their product  $AB$  is equal to the product of their determinants, i.e.,  $ \det(AB) = \det(A) \det(B)$ .}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 1}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {R : Type*} [CommRing R] (n : (*@$\mathbb{N}$@*)) (*@\fcolorbox{red}{white}{(A B : Matrix (Fin n) R))}@*) : (A * B).det = A.det * B.det := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 2}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {R : Type*} [CommRing R] (n : (*@$\mathbb{N}$@*)) (A B : Matrix (Fin n) (Fin n) R) : (A * B).det = A.det * B.det := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A successful case generated by ATLAS}
\label{tab:successful_example_2}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
In the first two rounds, the model was unable to correctly formalize the concept of ``derivative." However, in the third round, it successfully formalizes this concept, demonstrating that the model effectively masters it after the learning experiences of the first two rounds.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} Leibniz formula}\\
\texttt{\textbf{Domain1:} ~Single Variable Real Analysis}\\
\texttt{\textbf{Concept2:} hyperbolic trigonometric functions}\\
\texttt{\textbf{Domain2:} ~Single Variable Real Analysis}\\
\texttt{\textbf{NL statement:} The derivative of the hyperbolic sine function, $\sinh(x)$, can be expressed using the Leibniz formula as ${\sinh}'(x) = \cosh(x)$.}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 1}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (x : (*@$\mathbb{R}$@*)) : (*@\fcolorbox{red}{white}{deriv sinh x = cosh x}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 2}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name : (*@\fcolorbox{red}{white}{deriv sinh = cosh}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 3}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name : HasDerivAt (fun x : (*@$\mathbb{R}$@*) => Real.sinh x) (Real.cosh x) x := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A successful case generated by ATLAS}
\label{tab:successful_example_3}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
In the first round, the model failed to correctly formalize the concepts of ``domain" and ``being an injection on a certain set." In the second and third rounds, it learned how to formalize ``domain," but struggled to accurately formalize ``being an injection on a certain set." In the fourth round, it successfully formalized these concepts.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} metric structure}\\
\texttt{\textbf{Domain1:} ~Single Variable Real Analysis}\\
\texttt{\textbf{Concept2:} derivative at a point}\\
\texttt{\textbf{Domain2:} ~Single Variable Real Analysis}\\
\texttt{\textbf{NL statement:} If a function  $f$ is differentiable at $c$  and $ {f}'(c) \neq 0 $, then there exists a neighborhood  $U$ of $c$ such that $ f $ is injective on $U$.}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 1}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : (*@$\mathbb{R} \to \mathbb{R}$@*)) (c : (*@$\mathbb{R}$@*)) (hf : DifferentiableAt (*@$\mathbb{R}$@*) f c (*@$ \wedge$@*) deriv f c (*@$\neq $@*) 0) : (*@$ \exists$@*) (U : Set (*@$\mathbb{R}$@*)), (*@\fcolorbox{red}{white}{(c $ \in $ U)}@*) (*@$ \wedge$@*) (*@\fcolorbox{red}{white}{(InjectiveOn f U)}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 2}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : (*@$\mathbb{R} \to \mathbb{R}$@*)) (c : (*@$\mathbb{R}$@*)) (hf : DifferentiableAt (*@$\mathbb{R}$@*) f c) (hc : deriv f c (*@$\neq $@*) 0) : (*@$ \exists$@*) U (*@$ \in$@*) nhds c, (*@\fcolorbox{red}{white}{Function.InjectiveOn f U}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 3}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : (*@$\mathbb{R} \to \mathbb{R}$@*)) (c : (*@$\mathbb{R}$@*)) (hf : DifferentiableAt (*@$\mathbb{R}$@*) f c) (hc : deriv f c (*@$\neq $@*) 0) : (*@$ \exists$@*) U (*@$ \in$@*) nhds c, (*@\fcolorbox{red}{white}{Function.Injective (f $\circ $ ($ \lambda$ x => x) $\circ $ (U := U) $\circ $ ($ \lambda$ x => x) $\circ $ (U := U))}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 4}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : (*@$\mathbb{R} \to \mathbb{R}$@*)) (c : (*@$\mathbb{R}$@*)) (hf : DifferentiableAt (*@$\mathbb{R}$@*) f c) (h'f : deriv f c (*@$\neq $@*) 0) :  (*@$ \exists$@*) U (*@$ \in$@*) nhds c, Set.InjOn f U := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A successful case generated by ATLAS}
\label{tab:successful_example_4}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
In the previous rounds, the model was unable to correctly formalize ``the order of a finite group" and the concept of ``two coprime positive integers", and there was unnecessary formalization. However, in the eighth round, the formalization was done correctly.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} direct product of groups}\\
\texttt{\textbf{Domain1:} ~Group Theory}\\
\texttt{\textbf{Concept2:} $\mathbb{Z}$ is a euclidean ring}\\
\texttt{\textbf{Domain2:} ~Ring Theory}\\
\texttt{\textbf{NL statement:} Let $G$  and $H$ be groups. If $G \times H $ is cyclic, then $G$ and $H$ are cyclic and their orders are coprime.}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 3}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G H : Type*} [Group G] [Group H] (h : IsCyclic (G × H)) : IsCyclic G ∧ IsCyclic H ∧ (*@\fcolorbox{red}{white}{Nat.coPrime (orderOfOf G) (orderOfOf H)}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 4}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G H : Type*} [Group G] [Group H] (hG : IsCyclic (G × H)) (hH : (*@\fcolorbox{red}{white}{IsCyclic (H × G)}@*)) : IsCyclic G ∧ IsCyclic H ∧ (*@\fcolorbox{red}{white}{Nat.coPrime (orderOfOf G) (orderOfOf H)}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 5}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G H : Type*} [Group G] [Group H] (hG : IsCyclic (G × H)) : IsCyclic G ∧ IsCyclic H ∧ (*@\fcolorbox{red}{white}{Nat.coPrime (Nat.card G) (Nat.card H)}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 6}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H] (hG : IsCyclic (G × H)) (hH : (*@\fcolorbox{red}{white}{IsCyclic (H × G)}@*)) : IsCyclic G ∧ IsCyclic H ∧ (*@\fcolorbox{red}{white}{Nat.coPrime (Fintype.card G) (Fintype.card H)}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 7}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H] (hG : IsCyclic (G × H)) (hH : (*@\fcolorbox{red}{white}{IsCyclic (H × G)}@*)) : IsCyclic G ∧ IsCyclic H ∧ (Fintype.card G).gcd (Fintype.card H) = 1 := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 8}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G H : Type*} [Group G] [Group H] [Fintype G] [Fintype H] (h : IsCyclic (G × H)) : IsCyclic G ∧ IsCyclic H ∧ (Fintype.card G).gcd (Fintype.card H) = 1 := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A successful case generated by ATLAS}
\label{tab:successful_example_5}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
In rounds five to seven, the incorrect formalization "Finset" was used. In round eight, the model revised it to "toFinSet," but it remained incorrect. Finally, in round nine, the formalization was done correctly. Note: The translation results for rounds 1 to 4 were subpar and lacked any significant insights, so they are not displayed.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} Cauchy-Schwarz inequality}\\
\texttt{\textbf{Domain1:} ~Bilinear and Quadratic Forms Over a Vector Spac}\\
\texttt{\textbf{Concept2:} counting measure}\\
\texttt{\textbf{Domain2:} ~Measures and integral calculus}\\
\texttt{\textbf{NL statement:} For any finite set $S$ and functions  $f$, $g$ : $S \to \mathbb{R}$, the Cauchy-Schwarz inequality holds:  $\left( \sum_{x \in S} f(x) g(x) \right)^2 \leq \left( \sum_{x \in S} f(x)^2 \right) \left( \sum_{x \in S} g(x)^2 \right)$.}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 5 $\sim$ 7}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (S : (*@\fcolorbox{red}{white}{FinSet $\mathbb{R}$}@*)) (f g : ℝ → ℝ) : (∑ x in S, f x * g x) ^ 2 ≤ (∑ x in S, f x ^ 2) * (∑ x in S, g x ^ 2) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 8}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (S : Set ℝ) (hS : S.Finite) (f g : S → ℝ) : (∑ x in (*@\fcolorbox{red}{white}{S.toFinSet}@*), f x * g x) ^ 2 ≤ (∑ x in (*@\fcolorbox{red}{white}{S.toFinSet}@*), f x ^ 2) * (∑ x in (*@\fcolorbox{red}{white}{S.toFinSet}@*), g x ^ 2) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 9}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {S : Type*} [Fintype S] (f g : S → ℝ) : (∑ x : S, f x * g x) ^ 2 ≤ (∑ x : S, f x ^ 2) * (∑ x : S, g x ^ 2) := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A successful case generated by ATLAS}
\label{tab:successful_example_6}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
In the first two rounds, there were formalization errors in Lean syntax, while in rounds three and four, the formalization expressed overly strong semantics. However, in round five, the formalization was done correctly.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} $K[X]$ is a euclidean ring when $K$ is a field}\\
\texttt{\textbf{Domain1:} ~Ring Theory}\\
\texttt{\textbf{Concept2:} inverse trigonometric functions}\\
\texttt{\textbf{Domain2:} ~Single Variable Real Analysis}\\
\texttt{\textbf{NL statement:} Let $K$ be a field. For any polynomial $ f(X) \in K[X] $, there exists a polynomial $ g(X) \in K[X] $ such that $f(X) \cdot g(X) = 1 $ if and only if $f(X)$ is a constant polynomial. This property is analogous to the invertibility of non-zero constants in the context of inverse trigonometric functions.}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 1}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {K : Type*} [Field K] (f : Polynomial K) : (∃ (g : Polynomial K), (*@\fcolorbox{red}{white}{Polynomial.mul f g = 1}@*)) ↔ (*@\fcolorbox{red}{white}{f.coeffs.all ((*@$\lambda$*@) n => n = 0)}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 2}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {K : Type*} [Field K] (f : K[X]) : (∃ g : K[X], f * g = 1) ↔ (*@\fcolorbox{red}{white}{f = C (1 : K)}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 3}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {K : Type*} [Field K] (f : Polynomial K) : (∃ g : Polynomial K, f * g = 1) ↔ (*@\fcolorbox{red}{white}{f = 1 $\vee$ f = -1}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 4}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {K : Type*} [Field K] (f : Polynomial K) : (∃ g : Polynomial K, f * g = 1) ↔ (*@\fcolorbox{red}{white}{f = 1}@*) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 5}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {K : Type*} [Field K] (f : Polynomial K) : (∃ g : Polynomial K, f * g = 1) ↔ (∃ c : K, f = Polynomial.C c) := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A failed case generated by ATLAS}
\label{tab:failed_example_1}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
The model was unable to correctly formalize the concept of a Gaussian integer ring.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} field $\mathbb{C}$ of complex numbers}\\
\texttt{\textbf{Domain1:} ~Ring Theory}\\
\texttt{\textbf{Concept2:} greatest common divisor}\\
\texttt{\textbf{Domain2:} ~Ring Theory}\\
\texttt{\textbf{NL statement:} Let $\alpha$ and $\beta$ be non-zero elements in the ring of Gaussian integers $\mathbb{Z}[i]$. Then the greatest common divisor $ \gcd(\alpha, \beta) $ in  $\mathbb{Z}[i]$ is a Gaussian integer of the form $ \gamma = x + yi$, where $x$ and $ y$ are integers.}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 1}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {α : ℂ} (hα : IsAlgebraic ℤ α) (h : IsMonic (Polynomial.map (algebraMap ℤ ℂ) (X - C α))) : IsEuclideanDomain (ℤ(*@$\left\langle \alpha \right\rangle$@*)) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 2}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ x y : ℤ, ∃ γ : ℤ[i], γ = x + y * I ∧ γ = gcd α β := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 3}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ γ : ℤ[i], γ = gcd α β ∧ ∃ x y : ℤ, γ = x + y * I := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 4}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ (γ : ℤ[i]) (x y : ℤ), γ = x + y * I ∧ γ = gcd α β := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 5}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ (γ : ℤ[i]) (x y : ℤ), γ = x + y * I ∧ γ = gcd α β := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 6}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ γ : ℤ[i], ∃ x y : ℤ, γ = ⟨x, y⟩ ∧ γ = gcd α β := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 7}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ γ : ℤ[i], γ = gcd α β := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 8}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ γ : ℤ[i], γ = gcd α β ∧ ∃ x y : ℤ, γ = x + y * i := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 9}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ γ : ℤ[i], γ = gcd α β := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 10}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (α β : ℤ[i]) (hα : α ≠ 0) (hβ : β ≠ 0) : ∃ γ : ℤ[i], γ = gcd α β := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\small
\caption{A failed case generated by ATLAS}
\label{tab:failed_example_2}
\begin{tabular}{p{0.93\textwidth}}
\toprule
\textbf{Analysis:} 
\begin{minipage}[t]{0.85\textwidth}
The model was unable to formalize such a relatively complex problem, and there were also certain issues with the natural language itself.
\end{minipage}\\
\midrule
\texttt{\textbf{Concept1:} Taylor's theorem with Lagrange form for remainder}\\
\texttt{\textbf{Domain1:} ~Single Variable Real Analysis}\\
\texttt{\textbf{Concept2:} affine function}\\
\texttt{\textbf{Domain2:} ~Affine and Euclidean Geometry}\\
\texttt{\textbf{NL statement:} For a function $ f $ that is  $n+1$  times differentiable on an interval containing $a$ and $ x$, the Taylor polynomial of degree $n$ at $a$ approximates  $f(x)$ with an error term that can be expressed as an affine function of $ (x-a)^{n+1} $.}\\
\texttt{\textbf{FL statements:}}\\
\texttt{\textbf{Round 1}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (f : ℝ → ℝ) (hf : ∀ x, (x ∈ Set.Icc a x) → HasFDerivAt (f' x) f x) (x : ℝ) (hx : x ∈ Set.Icc a x) : ∃ c : ℝ, f x - taylorPolynomial n a f = c * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 2}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (a x : ℝ) (n : ℕ) (f : ℝ → ℝ) (hf : ∀ x, f x = ∑ i in range (n + 1), (f^[i] a * (x - a) ^ i / i!)) : ∃ k : ℝ, f x - ∑ i in range (n + 1), (f^[i] a * (x - a) ^ i / i!) = k * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 3}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (a x : ℝ) (f : ℝ → ℝ) (hf : ∀ k : ℕ, k ≤ n → DifferentiableOn ℝ (fun x => iteratedDeriv n f x) (Set.Icc a x)) : ∃ c : ℝ, f x - iteratedDeriv n f a = c * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 4}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (a x : ℝ) (f : ℝ → ℝ) (hf : ContDiff ℝ (n + 1) f) : ∃ k : ℝ, f x - (f a + ∑ i in FinSet.range (n + 1), (f^[i + 1] a * (x - a) ^ i / (i + 1)!)) = k * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 5}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (n : ℕ) (a x : ℝ) (hf : ContDiff ℝ (n + 1) f) : ∃ f' g : ℝ, f x = f a + f' * (x - a) + g * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 6}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (a x : ℝ) (n : ℕ) (hf : ContDiff ℝ (n + 1) f) : ∃ k : ℝ, f x = f a + (f' a) * (x - a) + (1 / (Nat.factorial (n + 1))) * (f (n + 1) a) * (x - a) ^ (n + 1) + k * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 7}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (a : ℝ) (n : ℕ) (hf : ContDiff ℝ (n + 1) f) (x : ℝ) : ∃ A B : ℝ, f x - ∑ i in FinSet.range (n + 1), (f^[i] a * (x - a) ^ i / i!) = A * (x - a) ^ (n + 1) + B := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 8}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (a : ℝ) (f : ℝ → ℝ) (hf : ContDiff ℝ (n + 1) f) (x : ℝ) : ∃ c : ℝ, f x - ∑ i in FinSet.range (n + 1), (f^[i] a * (x - a) ^ i / i!) = c * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 9}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (a : ℝ) (f : ℝ → ℝ) (hf : ∀ k : ℕ, k ≤ n → DifferentiableOn ℝ (fun x => iteratedDeriv k f x) (Set.Ioo a a)) (x : ℝ) (hx : x ∈ Set.Ioo a a) : ∃ c : ℝ, f x - ∑ i in FinSet.range (n + 1), iteratedDeriv i f a * (x - a) ^ i / i! = c * (x - a) ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\texttt{\textbf{Round 10}}
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (a : ℝ) (f : ℝ → ℝ) (hf : ∀ k : ℕ, k ≤ n → DifferentiableOn ℝ (fun x => deriv^[k] f x) (Set.Icc a a)) : ∃ p : ℝ → ℝ, ∀ x : ℝ, |f x - p x| ≤ C * |x - a| ^ (n + 1) := by sorry
\end{lstlisting}
\vspace{-3pt}
\\[-13pt]
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}


\newpage
\onecolumn
\section{Human Evaluation} \label{app:human_evaluation}
In this section, $15$ samples are randomly selected from the pass@$1$ samples of miniF2F, ProofNet, and MathQual, which are evaluated for syntactic validity and semantic accuracy by mathematicians proficient in Lean. This approach aims to provide a better assessment of the model's performance and these samples help readers gain a clearer understanding of the model's autoformalization capability. The results presented further underscore the model's remarkable capacity for autoformalization. Even in instances where the model produces erroneous translations, it demonstrates a high level of completeness, enabling human experts to swiftly correct mistakes.

\subsection{miniF2F}
\begin{oframed}
\textbf{\# Example 1} \\
Integers $x$ and $y$ with $x>y>0$ satisfy $x+y+xy=80$. What is $x$$ ?\\
\textbf{(A)}\ 8 \qquad\textbf{(B)}\ 10 \qquad\textbf{(C)}\ 15 \qquad\textbf{(D)}\ 18 \qquad\textbf{(E)}\ 26$\\
Show that it is \textbf{(E)}\ 26.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (x y : Z) (h0 : 0 < y) (h1 : y < x) (h2 : x + y + x * y = 80) : x = 26 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 2} \\
What is the reciprocal of $\frac{1}{2}+\frac{2}{3}$ ? \\
$\mathrm{(A)}\ \frac{6}{7}\qquad\mathrm{(B)}\ \frac{7}{6}\qquad\mathrm{(C)}\ \frac{5}{3}\qquad\mathrm{(D)}\ 3\qquad\mathrm{(E)}\ \frac{7}{2}$\\ 
Show that it is $\frac{6}{7}$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name : 1 / (1 / 2 + 2 / 3) = 6 / 7 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 3}\\
Show that for any positive real numbers $a$ and $b$, $(a+b)^4 \leq 8(a^4 + b^4)$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (a b : (*@$\mathbb{R}$@*)) (ha : 0 < a) (hb : 0 < b) : (a + b) ^ 4 (*@$\leq$@*) 8 * (a ^ 4 + b ^ 4) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 4} \\
Show that for any natural number $n \in \mathbb{N}$, $3 \mid n^3 + 2n$ .
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : (*@$\mathbb{N}$@*)) : 3 (*@$|$@*) n ^ 3 + 2 * n := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 5} \\
Show that for any real-valued function $a$ on the natural numbers such that $\forall i \in \mathbb{N}, a_i \geq 0$, if $\prod_{i=0}^{n-1} a_i = 1$, then $\sum_{i=0}^{n-1} a_i \geq n$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : (*@$\mathbb{N}$@*)) (a : (*@$ \mathbb{N} \to \mathbb{R}$@*)) (ha : (*@$\forall$@*) i, 0 (*@$\leq$@*) a i) (hab : (*@$\prod$@*) i : Fin n, a (*@$\uparrow$@*)i = 1) : (*@$\Sigma$@*) i : Fin n, a (*@$\uparrow$@*)i (*@$\geq$@*) n := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 6} \\
If $|x - 2| = p$, where $x < 2$, then $x - p = $ \\
$ \textbf{(A)} \ -2 \qquad \textbf{(B)} \ 2 \qquad \textbf{(C)} \ 2-2p \qquad \textbf{(D)} \ 2p-2 \qquad \textbf{(E)} \ |2p-2|  $ \\
Show that it is \textbf{(C)} 2-2p.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (p : (*@$\mathbb{R}$@*)) (x : (*@$\mathbb{R}$@*)) (hx : x < 2) (h : |x - 2| = p) : x - p = 2 - 2 * p := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 7} \\ 
For any integer $a$, show that $a^2 \equiv 0 \pmod{4}$ or $a^2 \equiv 1 \pmod{4}$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (a : (*@$\mathbb{Z}$@*)) : a ^ 2 % 4 = 0 (*@$\vee$@*) a ^ 2 % 4 = 1 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 8} \\
When Rachel divides her favorite number by 7, she gets a remainder of 5. What will the remainder be if she multiplies her favorite number by 5 and then divides by 7? Show that it is 4.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : (*@$\mathbb{N}$@*)) (h : n % 7 = 5) : (5 * n) % 7 = 4 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 9} \\
Given that $x$ and $y$ are distinct nonzero real numbers such that $x+ \tfrac{2}{x} = y +  \tfrac{2}{y}$, what is $xy$?\\
$ \textbf{(A)}\ \frac{1}{4}\qquad\textbf{(B)}\ \frac{1}{2}\qquad\textbf{(C)}\ 1\qquad\textbf{(D)}\ 2\qquad\textbf{(E)}\ 4\qquad $\\
Show that it is \textbf{(D)} 2.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (x y : ℝ) (hx : x ≠ 0) (hy : y ≠ 0) (hxy : x ≠ y) (h : x + (2 / x) = y + (2 / y)) : x * y = 2 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 10} \\
Let $n$ be the number of integers $m$ in the range $1 \le m \le 8$ such that $\text{gcd}(m,8)=1$. What is the remainder when $3^n$ is divided by $8$? Show that it is $1$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name : (3 ^ (Nat.card { m : ℕ | 1 ≤ m ∧ m ≤ 8 ∧ Nat.gcd m 8 = 1 })) % 8 = 1 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 11} \\
Theorem: Let $f$ be a linear function for which $f(6) - f(2) = 12.$ What is $f(12) - f(2)?$\\
$\text {(A) } 12 \qquad \text {(B) } 18 \qquad \text {(C) } 24 \qquad \text {(D) } 30 \qquad \text {(E) } 36$ \\
Show that it is \text {(D)} 30.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (hf : ∃ a b, ∀ x, f x = a * x + b) (h : f 6 - f 2 = 12) : f 12 - f 2 = 30 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 12} \\
If $j$ is a positive integer and the expression $(7j+3)$ is multiplied by 3 and then divided by 7, what is the remainder? Show that it is 2.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (j : ℕ) (h : 0 < j) : (7 * j + 3) * 3 % 7 = 2 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 13} \\
Show that for positive integers $n$ and $k$ with $k \leq n$, we have $\binom{n}{k} = \binom{n-1}{k} + \binom{n-1}{k-1}$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n k : ℕ) (h(*@$_1$@*) : 0 < n) (h(*@$_2$@*) : 0 < k) (h(*@$_3$@*) : k ≤ n) : n.choose k = (n - 1).choose k + (n - 1).choose (k - 1) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark} 
\vspace{5pt}

\textbf{\# Example 14} \\ 
An audience of $450$ people is seated in an auditorium. Each row contains the same number of seats and each seat in the auditorium is occupied. With three fewer seats per row, and five extra rows, the same audience could still be seated, occupying all seats. How many rows does the auditorium have? Show that it is 25.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : (*@$\mathbb{N}$@*)) ((*@\fcolorbox{red}{white}{ hn : 450 = n * (n - 3) + 5 }@*) ) : n = 25 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{red}{\ding{55}}  The failure to correctly understand the problem statement led to errors in the formalization of the conditions.
\vspace{5pt}

\textbf{\# Example 15} \\
Find the greatest common factor of 180 and 168. Show that it is 12.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name : gcd 180 168 = 12 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}

\end{oframed}


\subsection{ProofNet}
\begin{oframed}
\textbf{\# Example 1} \\
Suppose $X$ is a nonempty complete metric space, and $\left\{G_{n}\right\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\bigcap_{1}^{\infty} G_{n}$ is not empty.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {X : Type*} [MetricSpace X] [CompleteSpace X] [Nonempty X] (G : ℕ → Set X) (hG : ∀ n, IsOpen (G n)) (hG' : ∀ n, Dense (G n)) : ((*@$\cap$@*) n, G n).Nonempty := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 2} \\
If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\overline{E}) \subset \overline{f(E)}$ for every set $E \subset X$. ($\overline{E}$ denotes the closure of $E$).
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X → Y) (hf : Continuous f) (E : Set X) : f '' closure E ⊆ closure (f '' E) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 3} \\ 
A uniformly continuous function of a uniformly continuous function is uniformly continuous.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name ((*@\fcolorbox{red}{white}{f : $\mathbb{R} \to \mathbb{R}$}@*)) (hf : UniformContinuous f) ((*@\fcolorbox{red}{white}{g : $\mathbb{R} \to \mathbb{R}$}@*)) (hg : UniformContinuous g) : UniformContinuous (f ∘ g) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{red}{\ding{55}} The formalization here directly assumes that $f$ and $g$ are functions on the real number domain, leading to a semantic inconsistency.
\vspace{5pt}

\textbf{\# Example 4} \\
Let $R$ be a ring in which $x^3 = x$ for every $x \in R$. Prove that $R$ is commutative.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {R : Type*} [Ring R] (h : ∀ (x : R), x ^ 3 = x) : ∀ (x y : R), x * y = y * x := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 5} \\
Prove that $\sqrt{n+1}-\sqrt{n} \rightarrow 0$ as $n \rightarrow \infty$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (hn : n > 0) : ∀ ε : ℝ, ε > 0 → ∃ N : ℕ, ∀ n : ℕ, n ≥ N → |( (*@$\sqrt{}$@*)(n + 1) - (*@$\sqrt{}$@*)(n)| < ε := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 6} \\
Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (p : ℕ) (hp : Nat.Prime p) (h : ∃ r, p = 2 ^ r + 1) : ∃ k, p = 2 ^ (2 ^ k) + 1 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 7} \\
Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℤ) (hn : ∃ a b : ℚ, a * a + b * b = n) : ∃ a b : ℤ, a * a + b * b = n := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 8} \\
Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \in A$ there is an open set $U$ containing $x$ such that $U \subset A$. Show that $A$ is open in $X$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {X : Type*} [TopologicalSpace X] (A : Set X) (hA : ∀ x ∈ A, ∃ U, IsOpen U ∧ x ∈ U ∧ U ⊆ A) : IsOpen A := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 9} \\
Let $p: X \rightarrow Y$ be a continuous map. Show that if there is a continuous map $f: Y \rightarrow X$ such that $p \circ f$ equals the identity map of $Y$, then $p$ is a quotient map.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] {p : X → Y} (hp : Continuous p) {f : Y → X} (hf : Continuous f) (h : p ∘ f = id) : QuotientMap p := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 10} \\
Show that $\int_0^1 \log(\sin \pi x) dx = - \log 2$. Show that $\int_0^1 \log(\sin \pi x) dx = - \log 2$. Show that $\int_0^1 \log(\sin \pi x) dx = - \log 2$. Show that $\int_0^1 \log(\sin \pi x) dx = - \log 2$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {X Y : Type*} [MetricSpace X] [MetricSpace Y] (f : X → Y) (hf : UniformContinuous f) {x : ℕ → X} (hx : CauchySeq x) : CauchySeq (f ∘ x) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 11} \\
Theorem: If $G$ is a finite group of even order, show that there must be an element $a \neq e$ such that $a=a^{-1}$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G : Type*} [Group G] [Fintype G] (hG : Fintype.card G % 2 = 0) : ∃ a : G, a ≠ 1 ∧ a = a⁻¹ := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 12} \\
Assume that $f \colon \mathbb{R} \rightarrow \mathbb{R}$ satisfies $|f(t)-f(x)| \leq|t-x|^{2}$ for all $t, x$. Prove that $f$ is constant.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (hf : ∀ (t x : ℝ), |f t - f x| ≤ |t - x| ^ 2) (x y : ℝ) : f x = f y := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 13} \\
If $f$ is a real continuous function defined on a closed set $E \subset \mathbb{R}$, prove that there exist continuous real functions $g$ on $\mathbb{R}$ such that $g(x)=f(x)$ for all $x \in E$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (E : Set ℝ) (hE : IsClosed E) (hf : ContinuousOn f E) : ∃ g : ℝ → ℝ, Continuous g ∧ ∀ x ∈ E, g x = f x := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 14} \\ 
Suppose $f$ is a real, three times differentiable function on $[-1,1]$, such that $f(-1)=0, \quad f(0)=0, \quad f(1)=1, \quad f^{\prime}(0)=0 .$ Prove that $f^{(3)}(x) \geq 3$ for some $x \in(-1,1)$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (hf : DifferentiableOn ℝ f (Set.Icc (-1) 1)) (h'f : DifferentiableOn ℝ (deriv f) (Set.Icc (-1) 1)) (h''f : DifferentiableOn ℝ (deriv (deriv f)) (Set.Icc (-1) 1)) (h'''f : DifferentiableOn ℝ (deriv (deriv (deriv f)))) (Set.Icc (-1) 1)) (h0 : f (-1) = 0) (h1 : f 0 = 0) (h2 : f 1 = 1) (h3 : deriv f 0 = 0) : ∃ x ∈ Set.Ioo (-1) 1, deriv (deriv (deriv f)) x ≥ 3 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 15} \\
If $a > 1$ is an integer, show that $n \mid \varphi(a^n - 1)$, where $\phi$ is the Euler $\varphi$-function.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (a n : ℕ) (ha : 1 < a) (hn : 0 < n) : n (*@$\mid$@*) Nat.totient (a ^ n - 1) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}

\end{oframed}

\subsection{MathQual}
\begin{oframed}
\textbf{\# Example 1} \\
Let $G$ be a group of order 132. Prove that $G$ is not a simple group.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {G : Type*} [Group G] [Fintype G] (hG : Fintype.card G = 132) : ¬IsSimpleGroup G := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 2} \\
Show that for any $J\in\mathbb{N}$, there is a function $f_{J}:[0,1]\rightarrow\mathbb{R}$ so that (i) $f_{J}(x_{i})=y_{i}$ for each $1\leq i\leq J$, and (ii) $|f_{J}(x)-f_{J}(x^{\prime})|\leq10|x-x^{\prime}|$ for every $x,x^{\prime}\in[0,1]$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (J : ℕ) (x y : Fin J → ℝ) (hx : ∀ i, x i ∈ Set.Icc 0 1) (hy : ∀ i, y i ∈ Set.Icc 0 1) : ∃ f : ℝ → ℝ, (∀ i, f (x i) = y i) ∧ ∀ x x' : ℝ, x ∈ Set.Icc 0 1 ∧ x' ∈ Set.Icc 0 1 → |f x - f x'| ≤ 10 * |x - x'| := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 3} \\
Let $X$ be an open convex subset of $\mathbb{R}^{n}$, Show that for any $x,y\in X$, there is a point $z$, lying on the line segment from $x$ to $y$, for which $f(y)-f(x)=\nabla f(z)\cdot(y-x)$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (n : ℕ) (hn : 0 < n) (X : Set (Fin n → ℝ)) (hX : IsOpen X) (hX' : Convex ℝ X) (f : (Fin n → ℝ) → ℝ) (hf : DifferentiableOn ℝ f X) (x y : Fin n → ℝ) (hx : x ∈ X) (hy : y ∈ X) : ∃ z ∈ segment ℝ x y, (f y - f x) = (fderiv ℝ f z) (y - x) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 4} \\
Let $f\colon(0,\infty)\to\mathbb{R}$ be continuous such that $f(4x)=f(x)$ for all $x$. Prove that there exists $x > 0$ such that $f(x)=f(2x)$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (hf : Continuous f) (h : ∀ x > 0, f (4 * x) = f x) : ∃ x > 0, f x = f (2 * x) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 5} \\
Let $(X,\mathcal{A},\mu)$ be a probability space and let $T:X\to X$ be a measurable and measure preserving map, i.e., for $A\in\mathcal{A}$, we have $\mu(T^{-1}(A))=\mu(A)$. For $A,B\in\mathcal{A}$, if $\mu(A-B)=\mu(B-A)=0$, we say that $A=B$ a.e. Prove that there exists a set $B\in\mathcal{A}$ such that $T^{-1}(B)=B$ and $A=B$ a.e.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {X : Type*} [MeasurableSpace X] (μ : MeasureTheory.Measure X) [MeasureTheory.IsProbabilityMeasure μ] (T : X → X) (hT : ∀ A : Set X, MeasurableSet A → μ (T ⁻¹' A) = μ A) (A : Set X) (hA : MeasurableSet A) (hA' : μ (A \ A) = 0) : ∃ B : Set X, MeasurableSet B ∧ T ⁻¹' B = B ∧ μ (A \ B) = 0 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 6} \\
Let $f(x)$ be a polynomial with real coefficients. Prove that if $f(x)$ has a root $r$ with $r \in \mathbb{C} \setminus \mathbb{R}$, then $\overline{r}$, the complex conjugate of $r$, is also a root of $f(x)$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : Polynomial ℂ) (r : ℂ) (hr : f.eval r = 0) (h : r ∉ Set.range ((↑) : ℝ → ℂ)) : f.eval (star r) = 0 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 7} \\
Let $f\in L^{1}(\mathbb{R})$ and for each $h>0$, let $\mathcal{A}_{h}f(x):={\frac{1}{2h}}\int_{|y|\leq h}f(x-y)d y$, Prove that $\|\mathcal{A}_{h}f\|_{1}\leq\|f\|_{1}$ for all $h>0$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℝ → ℝ) (hf : MeasureTheory.Integrable f MeasureTheory.volume) (h : ℝ) (hh : 0 < h) : ∫ x, (1 / (2 * h)) * ∫ y in {y | |y| ≤ h}, f (x - y) ∂MeasureTheory.volume ∂MeasureTheory.volume ≤ ∫ x, f x ∂MeasureTheory.volume := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 8} \\
Let $\Omega$ be a bounded simply connected domain. If $f:\Omega\to\Omega$ is analytic and there exists a point $z_{0}\in\Omega$ such that$$f(z_{0})=z_{0},\quad\mathrm{and}\quad f^{\prime}(z_{0})=1$$ then $f(z)=z$ for all $z\in\Omega$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (Ω : Set ℂ) (hΩ : IsConnected Ω) (hΩ' : IsOpen Ω) (hΩ'' : Ω ⊆ {z | ‖z‖ ≤ 1}) (f : ℂ → ℂ) (hf : AnalyticOn ℂ f Ω) (z₀ : ℂ) (hz₀ : z₀ ∈ Ω) (h₁ : f z₀ = z₀) (h₂ : deriv f z₀ = 1) : ∀ z ∈ Ω, f z = z := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 9} \\
Let $f:\mathbb{D}\to\mathbb{D}$ be holomorphic with $f(0)=0$, show that $|f(z)|\leq|z|$ for all $z\in\mathbb{D}$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : ℂ → ℂ) (hf : DifferentiableOn ℂ f (Metric.ball 0 1)) (h0 : f 0 = 0) : ∀ z ∈ Metric.ball 0 1, ‖f z‖ ≤ ‖z‖ := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 10} \\
Let $X$ , $Y$ be topological spaces with $Y$ Hausdorff, and let $f:X\to Y$ be a function. Show that if $f$ is continuous, the graph $\Gamma_{f}$ defined as $$\Gamma_{f}=\{(x,y)|y=f(x)\}\subset X\times Y$$ is closed.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {X Y : Type*} [TopologicalSpace X] [TopologicalSpace Y] [T2Space Y] (f : X → Y) (hf : Continuous f) : IsClosed (Set.range (fun x => (x, f x))) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 11} \\
Let $A$ be a nilpotent matrix and let $f$ be a polynomial in one variable, both over a field. Prove that $f(A)$ is invertible if and only if $f(0) \neq 0$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (A : Matrix (Fin 2) (Fin 2) ℝ) (f : Polynomial ℝ) (hf : IsNilpotent A) : (Polynomial.eval₂ (algebraMap ℝ (Matrix (Fin 2) (Fin 2) ℝ)) A f).det ≠ 0 ↔ f.coeff 0 ≠ 0 := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 12} \\
Let $V$ and $W$ be two vector spaces over a field $k,$ and let $f:V\to W$ be a linear map. Prove that $f$ is surjective if and only if its dual map $f^{*}$ is injective.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name {V W : Type*} [Field k] [AddCommGroup V] [Module k V] [AddCommGroup W] [Module k W] (f : V →(*@$_l$@*)[k] W) : Function.Surjective f ↔ Function.Injective (LinearMap.dualMap f) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
\vspace{5pt}

\textbf{\# Example 13} \\
Suppose that $f:A\rightarrow\mathbb{R}$, $A\subset\mathbb{R}^{m}$ is an $L$-Lipschitz map. Prove that $f$ can be extended to an $L$-Lipschitz map on $\mathbb{R}^{m}$, that is, there exists an $L$-Lipschitz map $g:\mathbb{R}^{m}\rightarrow\mathbb{R}$, such that $g\vert_{A}=f$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (m : ℕ) (L : NNReal) (f : (Fin m → ℝ) → ℝ) (hf : (*@\fcolorbox{red}{white}{LipschitzWith L f}@*)) (A : Set (Fin m → ℝ)) (hA : A.Nonempty) (hA' : (*@\fcolorbox{red}{white}{IsOpen A}@*)) : ∃ g : (Fin m → ℝ) → ℝ, LipschitzWith L g ∧ ∀ x ∈ A, g x = f x := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{red}{\ding{55}} ~The Lipschitz continuity of the f is not properly restricted to the domain A, and the condition that A is an open set is added.
\vspace{5pt}

\textbf{\# Example 14} \\
Fix $1 \leq p < \infty$ and let $\{f_{n}\}_{n=1}^{\infty}$ be a sequence of Lebesgue measurable functions $f_{n}:[0,1]\to\mathbb{C}$. Suppose there exists $f\in L^{p}([0,1])$ such that $f_{n}\rightarrow f$ in $L^{p}$, that is, $$\int_{[0,1]}|f_{n}(x)-f(x)|^{p}\,d x\to0.$$ Show that there is a subsequence $f_{n_{k}}$ such that $f_{n_{k}}(x)\rightarrow f(x)$ almost everywhere.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (p : ℝ) (hp : 1 ≤ p) (f : ℝ → ℂ) (f_n : ℕ → ℝ → ℂ) (hf : ∀ n, MeasureTheory.Memℒp (f_n n) (ENNReal.ofReal p) MeasureTheory.volume) (h : ∀ ε : ℝ, ε > 0 → ∃ N : ℕ, ∀ n : ℕ, n ≥ N → ∫ x in Set.Icc 0 1, Complex.abs (f_n n x - f x) ^ p ∂MeasureTheory.volume < ε) : ∃ f_n_k : ℕ → ℝ → ℂ, (∀ k : ℕ, MeasureTheory.Memℒp (f_n_k k) (ENNReal.ofReal p) MeasureTheory.volume) ∧ (∀ ε : ℝ, ε > 0 → ∃ N : ℕ, ∀ k : ℕ, k ≥ N → (*@\fcolorbox{red}{white}{$\forall x \in $ Set.Icc 0 1, Complex.abs (f\_n\_k\ k\ x\ -\ f\ x) <  $\varepsilon$}@*)) := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{red}{\ding{55}} The model exhibits formalization errors concerning the term ``almost everywhere."
\vspace{5pt}

\textbf{\# Example 15} \\
Show that the polynomial $x^{5}-5x^{4}-6x-2$ is irreducible in $\mathbb{Q}[x]$.
\vspace{-5pt}
\begin{lstlisting}[style=appendixstyle]
theorem tm_name (f : Polynomial ℚ) (hf : f = Polynomial.X ^ 5 - 5 * Polynomial.X ^ 4 - 6 * Polynomial.X - 2) : Irreducible f := by sorry
\end{lstlisting}
\vspace{-10pt}
\textcolor{green}{\large\checkmark}
 
\end{oframed}


\section{MathQual} \label{app:mathqual}
The MathQual dataset is derived from previous examinations of the Yau Mathematical Competition for college students, as well as graduate qualification examinations from multiple universities, including Boston University, Johns Hopkins University, University of Texas at Dallas, University of California, Los Angeles, University of California Riverside, and University of Georgia. Table \ref{tab:mathqual} presents the domains included in the MathQual dataset, along with the corresponding number of problem statements, as well as the sampling quantities from each domain during experiments. The process of creating the dataset is elaborated as follows.
\begin{itemize}[topsep=0pt, itemsep=0pt, parsep=0pt]
\item[1.] Relevant PDF documents are retrieved from official websites.
\item[2.] Optical Character Recognition (OCR)\footnote{https://github.com/opendatalab/MinerU} technology is employed to convert these documents into Markdown format.
\item[3.] High-quality, formalizable problem statements are meticulously selected through a manual filtration process. Notably, for proof problems consisting of multiple sub-questions, we amalgamate the overarching contextual conditions of the main problem with the specific conditions of each sub-question, thereby constructing several distinct problem statements.
\item[4.] The problem statements are categorized according to Mathematics Subject Classification (MSC)\footnote{https://zbmath.org/classification}.
\end{itemize}

\vspace{-5pt}
\begin{table*}[!htbp]
\centering
\caption{Domain Classification and Problem Counts in MathQual}
\label{tab:mathqual}
\begin{tabular}{lcc}
\toprule
\textbf{Domain} & \textbf{Total Count} & \textbf{Sampled Count}\\ 
\midrule
Algebraic geometry & 7 & 2 \\
Algebraic topology & 73 & 15 \\
Approximations and expansions & 18 & 4 \\
Associative rings and algebras & 33 & 7 \\
Calculus of variations and optimal control; optimization & 17 & 4 \\
Category theory; homological algebra & 24 & 5 \\
Combinatorics & 11 & 3 \\
Commutative algebra & 136 & 28 \\
Convex and discrete geometry & 2 & 1 \\
Difference and functional equations & 8 & 2 \\
Differential geometry & 91 & 19 \\
Dynamical systems and ergodic theory & 8 & 2 \\
Field theory and polynomials & 184 & 37 \\
Functional analysis & 160 & 33 \\
Functions of a complex variable & 308 & 62 \\
General topology & 71 & 15 \\
Geometry & 12 & 3 \\
Global analysis, analysis on manifolds & 53 & 11 \\
Group theory and generalizations & 221 & 45 \\
Harmonic analysis on Euclidean spaces & 37 & 8 \\
Integral equations & 4 & 1 \\
Integral transforms, operational calculus & 1 & 1 \\
Linear and multilinear algebra; matrix theory & 266 & 54 \\
Manifolds and cell complexes & 48 & 10 \\
Mathematical logic and foundations & 80 & 17 \\
Measure and integration & 113 & 23 \\
Number theory & 78 & 16 \\
Numerical analysis & 11 & 3 \\
Operations research, mathematical programming & 1 & 1 \\
Operator theory & 14 & 3 \\
Order, lattices, ordered algebraic structures & 3 & 1 \\
Ordinary differential equations & 49 & 10 \\
Partial differential equations & 48 & 10 \\
Potential theory & 19 & 4 \\
Probability theory and stochastic processes & 147 & 30 \\
Real functions & 99 & 20 \\
Sequences, series, summability & 33 & 7 \\
Several complex variables and analytic spaces & 8 & 2 \\
Special functions & 10 & 3 \\
Statistics & 20 & 5 \\
Topological groups, Lie groups & 11 & 3 \\
\addlinespace[0.1em]
\hdashline
\addlinespace[0.2em]
Total & 2537 & 530 \\
\bottomrule
\end{tabular}
\end{table*}
\vspace{-5pt}


\end{document}