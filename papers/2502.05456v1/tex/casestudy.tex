%\noindent\begin{minipage}{\columnwidth}
%\begin{lstlisting}[ style=Cpp,caption=An Out-of-Scope Input on Vulnerability Detection Task,label={a}] 
%    static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref)
%    {   
%        return 0;
%    }
%\end{lstlisting}
%\end{minipage}
%
%\noindent\begin{minipage}{\columnwidth}
%\begin{lstlisting}[ style=Cpp,caption=Adapted Input by CodeImprove on the Vulnerability Detection Task,label={b}] 
%    static int lywO3B (OIG1zCac *link, VZImhSctJ *uSILRM6oY) 
%    {    
%    return (130 - 130);
%    }
%\end{lstlisting}
%\end{minipage}



%Listing~\ref{a} shows an example of code snippet that is incorectly predicted in the vulnerability detection task. CodeImprove was able to detect this input as an out-of-scope input with a validity score of 0.2325 which is lesser than the threshold (i.e., 0.43). The expected label for the above code snippet is 1, however, the CodeBERT model classified the label as 0. Next, we adapt the code snippet into CodeImprove's input adaptation phase. The adapted input is shown in the Listing~\ref{b}, and the model was able to correctly predict the input label to 1 with a higher validity score.  After investigating the two code snippets, we find that the code snippet in listing two has changed method (i.e., null\_filter\_samples to lyw03B) and  variable names (e.g: samplesref to uSILRM6oY) to random names. Also, the \textit{return 0} is  replaced by \textit{return 130-130} by modifying the constant value 0. Although the method and variable names in the adapted code are not human readable, we belive that the models still can understand the logic, hence, predicting the correct label. 

%Listing~\ref{a} shows an example of a code snippet where the vulnerability detection task faced an incorrect prediction. In this case, CodeImprove identified this input as out-of-scope with a validity score of 0.2325, which falls below the threshold of 0.43. The expected label for this code snippet is 1, but the CodeBERT model assigned it a label of 0. Subsequently, we initiated the code snippet's adaptation process within CodeImprove. The adapted version is presented in Listing~\ref{b}, and notably, the model correctly predicted a label of 1 with an improved validity score. After a close examination of the two code snippets, it's evident that the one in Listing~\ref{b} underwent changes in method names (e.g., from "null\_filter\_samples" to "lyw03B") and variable names (e.g., from "samplesref" to "uSILRM6oY"). Furthermore, the \textit{return 0} statement was replaced with \textit{return 130-130} (line 3 in both listings) by altering the constant value. Although the method and variable names in the adapted code may not be easily readable to humans, we maintain the confidence that the models can still recognize the underlying logic, resulting in accurate label prediction.
%\textcolor{red}{example, intuition}
%\vspace{-1em}
\subsection{RQ5: Semantic Preservation in CodeImprove's Program Transformation}
%\input{tex/tables/RQ4}
\vspace{-1em}
\textit{Process: } The objective of this RQ is to examine whether the adapted programs maintain the semantics of the original inputs. We investigate the effectiveness of applying semantic preserving program transformations to adapt out-of-scope inputs. Based on our investigation we provide an example in Figure~\ref{fig-mc}. \textcolor{blue}{Additional examples are on our project website due to space restrictions\cite{CodeImprove}}.

%we will add more examples to our project website\textcolor{blue}{\cite{CodeImprove}}. 

Figure~\ref{fig-mc} provides an example of how CodeImprove helps to revise a misprediction. As illustrated in Figure~\ref{fig-mc-ori}, the CodeBERT model incorrectly predicts the input to \textit{no defect}, although the ground truth label is actually \textit{wrong output}. During the validation phase, CodeImprove identifies this out-of-scope input with a validity score of 0.0221, significantly lower than our threshold of 0.2. To adapt this input, CodeImprove applies semantic preserving transformations. \textcolor{blue}{These transformations include splitting lines, changing code order,  splitting declarations, and separating variable assignments at line 6. Additionally, the relational and incremental operators were altered in lines 9 and 12. These changes create a syntax shift that affects the model's interpretation, resulting in different embeddings. The transformed version is shown in Figure~\ref{fig-mc-transed}. After these transformations, the model correctly predicts the label as \textit{wrong output} with an improved validity score of 0.7377. }

%including splitting the single-line variable definition into the multiple-line definition at line 6, reversing both the operators and operands at lines 9 and 12, and replacing the self-increment operator into a variable assignment with an algebraic expression at lines 9 and 12, resulting in the transformed version shown in Figure~\ref{fig-mc-transed}. After applying these transformations, the model correctly predicted the label to \textit{wrong output} with an improved validity score of 0.7377. 

\begin{figure}[t]
  \centering
  \subcaptionbox{Before Transformation  \label{fig-mc-ori}}{
\includegraphics[width=0.2\textwidth]{tex/images/oriex.pdf}
  }
  \subcaptionbox{After Transformation\label{fig-mc-transed}}{
    \includegraphics[width=0.22\textwidth]{tex/images/transed.pdf}
    }
  \caption{An example of a M$\rightarrow$C transformation}
  \label{fig-mc}
\end{figure}


%that there are no defects in the given input, whose ground-truth label is actually the \textit{wrong output}. Through the input validation phase, CodeImprove identifies this out-of-scope input with a validity score of 0.0221, which is significantly lower than our threshold of 0.2, indicating a high level of uncertainty in the model's prediction.  To improve the prediction, CodeImprove applied semantic preserving transformations to lines 6, 9, and 12 of the input, resulting in the transformed version shown in Figure~\ref{fig-mc-transed}. After applying these transformations, the model correctly predicted the label of \textit{Wrong Output} with an improved validity score of 0.7377. 

%\noindent\begin{minipage}{\linewidth}
%\begin{lstlisting}[ style=Cpp,caption=An Out-of-Scope Input on Defect Prediction Task,label={c}] 
%    int arrcost (int [], int) ; 
%    int main (){ 
%        int n, i, j, a[10], cost=0, temp; 
%        printf("Enter the size"); 
%        scanf("%d", &n); 
%        for (i = 0; i < n; i ++) { 
%            printf("ele %d", i+1);
%            scanf("%d", &a[i]); 
%        } 
%        while (n != 1) { 
%            for (i = 0; i < n; i++) { 
%                if (a [i] < a[i+1]) { 
%                    cost += a[i]; 
%                    temp = a[i+1];
%                    a[i+1] = a[n-1]; 
%                    a[n-1] = temp; 
%                } else {
%                    cost += a[i+1]; 
%                    temp = a[i];
%                    a[i] = a[n-1]; 
%                    a[n-1] = temp; 
%                } 
%            n = n - 1; 
%            } 
%        } 
%        temp = a[0]; 
%        printf("array %d" , temp) ;
%    }
%\end{lstlisting}
%%\end{minipage}

%\noindent\begin{minipage}{\columnwidth}
%\begin{lstlisting}[ style=Cpp,caption=Adapted input by CodeImprove on the Defect Prediction Task,label={d}] 
%    int arrtemp (int [], int);
%    int main () { 
%        int i, i, Lnp9vei0, qrLDkOzUInu [(604 - 594)], temp = (764 - 764), temp;    
%        scanf ("%d", &i);   
%        for (i = (111 - 111); i < i; i++) {        
%            printf ("ele %d", i + (632 - 631));        
%            scanf (" %d", &qrLDkOzUInu[i]);    
%        }
%        while (i != (812 - 811)) {        
%            for (i = (196 - 196); i < i; i++) {             
%                if (qrLDkOzUInu[i] < qrLDkOzUInu[i + (78 - 77)]) {                
%                    temp += qrLDkOzUInu[i];            
%                    temp = qrLDkOzUInu[i + (774 - 773)];               
%                    qrLDkOzUInu[i + (547 - 546)] = qrLDkOzUInu[i - (837 - 836)];       
%                    qrLDkOzUInu[i - 1] = temp;        
%                }else{
%                    temp += qrLDkOzUInu[i + 1];
%                    temp = qrLDkOzUInu[i];
%                    qrLDkOzUInu[i] = qrLDkOzUInu[i - 1];
%                    qrLDkOzUInu[i - 1] = temp;        
%                }
%                i = i - 1;
%            }
%        }
%        temp = qrLDkOzUInu[(886 - 886)];
%        printf ("array %d", temp);
%    }
%\end{lstlisting}
%\end{minipage}


%Listing~\ref{c} shows an example of a code snippet where the defect prediction task faced an incorrect prediction. In this case, CodeImprove identified this input as out-of-scope with a validity score of 0.1007, which falls below the threshold of 0.27. The expected label for this code snippet is 1, but the CodeBERT model assigned it a label of 3. Subsequently, we initiated the code snippet's adaptation process within CodeImprove. The adapted version is presented in Listing~\ref{d}, and notably, the model correctly predicted a label of 1 with an improved validity score. After investigating the two code snippets, we find that the adapted input primarily involves variable renaming, and modification of variables while preserving the values. These changes occur in multiple lines across both code listings, including lines 3, 5, 6, 9, 10, 11, 13, 14, and 25. The adapted code retains its underlying logic, in particular having a significant influence on the model's decision-making process, allowing it to correctly predict the label. Hence, it can be inferred that variable name changes and the adjustment of constants, even without altering their values, play a substantial role in enhancing the model's performance for the aforementioned code input. 