\section{Molecule Generation}
\label{app:mol_gen}

\subsection{Other Baselines}
\label{app:subsec:baselines}
\cite{vignac2023midi} proposes to generate 2D molecular graphs in tandem with 3D positions to allow better molecule generation. Our numbers cannot be directly compared with this work since they use a different list of allowed bonds, as well as use formal charge information. We also note that our framework can also be used to generate 2D molecular graphs along with 3D positions; we can also make use of the rEGNNs and uniform adaptive schedule proposed in \cite{vignac2023midi}. Hence, our framework can be thought of as complementary to \cite{vignac2023midi}. Similarly, \cite{peng2023moldiff} proposes to use the guidance of a bond predictor to improve molecule generation. Again, we cannot directly compare the numbers since they use a dedicated bond predictor to make bond predictions instead of a look-up table. The idea of bond predictor can also be incorporated in our framework seamlessly; hence our framework is again complementary to this work.

\subsection{Training Details}
\label{app:mol_train_details}

We train a Dis-Co DiT model with the following configuration:

\begin{table}[h]
    \centering
    \begin{tabular}{c c}
    \toprule
    % \multicolumn{2}{c}{} \\
    % \midrule
   Number of Generalized DiT Blocks  & 8  \\
   Number of Heads  & 8 \\
   Model Dimension & 512 \\
   MLP Dimension & 2048 \\
   Time Embedding Input Dimension & 256 \\
   Time Embedding Output Dimension & 128 \\
   \bottomrule
\end{tabular}
    \caption{Model configuration for QM9}
    \label{tab:qm9_arch}
\end{table}


We use the AdamW optimizer (with $\beta_1 = 0.9$, $\beta_2 = 0.999$ and $\epsilon = 10^{-8}$) with no weight decay and with no dropout.  We use EMA with decay $0.9999$.  We set the initial learning rate to 0 and warm it up linearly for 8000 iterations to a peak learning rate of $10^{-4}$; a cosine decay schedule is then applied to decay it to $10^{-6}$ over the training steps. For QM9, we train for $2.5$ Million iterations with a batch size of 2048. We use pad tokens to pad the number of atoms to 29 if a molecule has fewer atoms.

\paragraph{Distance-based embedding for atom positions:}
We adapt the distance embedding part from the EGCL layer proposed in \cite{hoogeboom2022equivariant}. Consider a molecule with $N$ atoms; let us denote the atom position of the $i^\text{th}$ atom as $x_i$. Then, we begin by computing the pairwise distance between the $i^\text{th}$ atom and all the other atoms (including the $i^\text{th}$ atom itself) to get an $N-$ dimensional vector $d_i$. $d_i$ is fed into the Generalized DiT block and embedded to a vector of size $D$, where $D$ is the model dimension, using a linear projection. This $D$ dimensional array is processed as usual by the block and at the end of the block, it is projected back into an $N$ dimensional vector, which we call $m_i$, using another linear layer. Then, we modify $x_i$ as follows:
$$ x_i  \leftarrow x_i + \sum_{j \neq i} \frac{x_i - x_j}{d_{ij} + 1} m_{ij} $$
where $d_{ij}$ denotes the $j^\text{th}$ element of $d_i$ and $m_{ij}$ denotes the $j^\text{th}$ element of $m_i$. The distance $d_i$ is now recomputed using the modified $x_i$ and the process is repeated for each block. After the final block, we subtract out the initial value of $x_i$ from the output. 

\subsection{Ablations}

Unless specified otherwise, all the results reported in ablations use top-$p$ sampling with $p = 0.99$ and do not use the ReDeNoise algorithm at inference. For all molecule generation experiments, we noise the sequence in a round-robin fashion, and in each round, $\Pi(\phi)$ is constant for discrete tokens across all positions. Similarly, $K_{i_t}^{t}$ which is the number of continuous noising steps per round, is constant across all positions per round. By default, we choose $\Pi(\phi)$ to be $[0.5, 0.5, 0.5, 0.5]$, where the $4$ element sequence, which we refer to as the discrete noise schedule, denotes noising for 4 rounds with $\Pi(\phi)$ for the round chosen from the sequence. Similarly, the default value of $K_{i_t}^{t}$ is chosen to be $[200, 200, 200, 200]$, and we refer to this sequence as the continuous noising steps. Let us denote $\sum_{t}K_{i_t}^{t} $ as $K$. Note that $K$ is same across positions since we assume same number of continuous noising steps across positions per round. Given $K$, we use the following noise schedule for $\beta$:
$$ \beta(j) = 0.03 + 0.5(0.0001 - 0.03)(1 + \cos(\left(\frac{j}{K} \right)\pi)) $$
where $j$ is the total number of continuous noising steps at sequence time $t$ and element time $k$. We denote this noise schedule as $\text{cosine}(0.0001, 0.03)$.

\paragraph{Interleaving pattern:}
We broadly considered two interleaving patterns. In the first pattern, the atom positions of each atom was treated as a separate vector to form the interleaving pattern $[z_1, p_1, z_2, p_2, \dots, z_n, p_n ]$, where $z_i \in \mathbb{N}$ is the discrete atomic number and $p_i \in \mathbb{R}^{3}$ is its corresponding atom position. This interleaving pattern results in 29 discrete tokens and 29 continuous vectors. In the second pattern, the atom positions of all the $n$ atoms were bunched together as a single vector to form the interleaving pattern $[z_1, z_2, \dots, z_n, p^c ]$, where $p^c \in \mathbb{R}^{3n}$ is a single vector which is formed by concatenating the atom positions of all $n$ atoms.This interleaving pattern results in 29 discrete tokens and 1 continuous vector. The atom and molecule stability for these two configurations are given in Table \ref{tab:abl_qm9_interleaving}.
\begin{table}[h]
    \centering
    \begin{tabular}{c c c}
    \toprule
   Interleaving Pattern & Atom. Stability & Mol. Stability \\
   \midrule
   Positions separate  &  88.99 & 28.9 \\
   Positions together  & 98.07 & 83.83 \\
   \bottomrule
\end{tabular}
    \caption{Ablation on Interleaving Pattern}
    \label{tab:abl_qm9_interleaving}
\end{table}

As we can see, having the atom positions together helps improve performance by a large margin; we hypothesize that this could be due to the fact that having the positions together allows the model to capture the symmetries of the molecules better. We choose the interleaving pattern with the positions together for all further experiments.

\paragraph{DDPM v/s DDIM:}
\label{app:par:ddpm_ddim}
We evaluate both DDPM and DDIM using the positions together interleaving pattern. The results are given in Table \ref{tab:abl_qm9_sampling}. DDPM outperforms DDIM by a large margin and hence we use DDPM for all experiments.

\begin{table}[h]
    \centering
    \begin{tabular}{c c c}
    \toprule
   Saampling Strategy& Atom. Stability & Mol. Stability \\
   \midrule
   DDIM  &  94.84 & 61.29 \\
   DDPM  & 98.07 & 83.83 \\
   \bottomrule
\end{tabular}
    \caption{Ablation on Sampling Strategy}
    \label{tab:abl_qm9_sampling}
\end{table}

\paragraph{Distance-based atom position embedding:} 
As we discussed in $\ref{app:mol_train_details}$, we use a distance-based embedding for the atom positions. We tried directly using the positions, as well as using both by concatenating distance along with the positions.  The atom and molecule stability for these two configurations are given in Table \ref{tab:abl_qm9_embedding}.
\begin{table}[h]
    \centering
    \begin{tabular}{c c c}
    \toprule
   Embedding & Atom. Stability & Mol. Stability \\
   \midrule
   Position  &  91.87 & 55.93 \\
   Distance  & 98.07 & 83.83 \\
   Position + Distance & 95.54 & 68.15 \\
   \bottomrule
\end{tabular}
    \caption{Ablation on embedding}
    \label{tab:abl_qm9_embedding}
\end{table}

As we can see, using the distance embedding leads to the best results. This could be due to the fact that molecules inherently have rotation symmetry, which distance-based embeddings capture more naturally. This could also be due to the fact that both atom and molecule stability are metrics which rely on the distance between atoms and allowing the model to focus on the distance allows it to perform better. Hence, we choose the distance-based atom position embedding for all further experiments.

\paragraph{Sequence time sampling:}

While the sequence time $t$ is typically sampled uniformly between $0$ and $T-1$, note that for the interleaving pattern with the positions together, only one sequence timestep per round corresponds to noising continuous vectors since we have $n$ discrete tokens and $1$ continuous vector. This may make it slower for the model to learn the reverse process for the continuous vector. Hence, we also try a \textit{balanced} sequence time sampling strategy, where we sample $t$ such that the time steps where continuous vector is noised is sampled with probability $0.5$. For the same number of training steps, performance of both strategies are detailed in Table \ref{tab:abl_qm9_seq_time}.
\begin{table}[h]
    \centering
    \begin{tabular}{c c c}
    \toprule
  Sequence Time Sampling & Atom. Stability & Mol. Stability \\
  \midrule
  Uniform sampling  &  97.92 & 79.78 \\
  Balanced sampling  & 98.24 & 84.47 \\
  \bottomrule
\end{tabular}
    \caption{Ablation on Sequence Time Sampling}
    \label{tab:abl_qm9_seq_time}
\end{table}

Since the balanced sampling strategy leads to better performance, we choose this strategy for all further experiments.

\paragraph{Discrete noise schedule and continuous noising steps:}
We fix the total number of noising rounds in the forward process as $4$, the total number of continuous noising steps as $800$ and the $\beta$ schedule as $\text{cosine}(0.0001, 0.03)$ based on initial experiments. The discrete noise schedule and continuous noising steps are then varied.
\begin{table}[h]
    \centering
    \begin{tabular}{c c c c}
    \toprule
  Discrete Noise Schedule & Continuous Noising Steps &  Atom. Stability & Mol. Stability \\
  \midrule
  $[0.5, 0.5, 0.5, 0.5]$  & $[200, 200, 200, 200]$ & 98.07 & 83.83 \\
  $[0.5, 0.5, 0.5, 0.5]$  & $[100, 100, 300, 300]$ & 97.63 & 79.40 \\
  $[0.5, 0.5, 0.5, 0.5]$  & $[300, 300, 100, 100]$ & 97.93 & 81.37 \\
  $[0.5, 0.5, 0.5, 0.5]$  & $[100, 300, 100, 300]$ & 98.08 & 83.08 \\
  $[0.75, 0.5, 0.5, 0.25]$ & $[100, 200, 200, 300]$ & 98.13 & 83.00 \\
  $[0.85, 0.5, 0.5, 0.25]$ & $[50, 250, 200, 300]$ & 98.14 & 81.99 \\
  \bottomrule
\end{tabular}
    \caption{Ablation on Noise Schedules}
    \label{tab:abl_qm9_noise}
\end{table}
Despite trying out multiple schedules, the default schedule of $[200, 200, 200, 200]$ and $[0.5, 0.5, 0.5, 0.5]$ give the best results; we use these noise schedules for further experiments. Results are given in Table \ref{tab:abl_qm9_noise}.

\paragraph{Effect of ReDeNoise:}
We examine the effect of ReDeNoise algorithm at inference. Preliminary results indicated that noising and denoising for more than one round does not improve performance. Hence, we apply ReDeNoise for one round, but do multiple iterations of the noising and denoising. We observe the following:
\begin{table}[h]
    \centering
    \begin{tabular}{c c c}
    \toprule
  No. of times ReDeNoise is applied & Atom. Stability & Mol. Stability \\
  \midrule
  No ReDeNoise  &  97.94 & 80.24 \\
  1x & 98.23  & 83.42 \\
  2x & 98.37  & 85.17 \\
  3x & 98.46 & 85.78 \\
  4x  & 98.48 & 86.20 \\
  5x & 98.52 & 86.49 \\
  6x & 98.60 & 87.11 \\
  7x & 98.48 & 86.30 \\
  \bottomrule
\end{tabular}
    \caption{Ablation on ReDeNoise (unbalanced sequence time sampling)}
    \label{tab:abl_qm9_redenoise_unbalanced}
\end{table}
\begin{table}[!h]
    \centering
    \begin{tabular}{c c c}
    \toprule
  No. of times ReDeNoise is applied & Atom. Stability & Mol. Stability \\
  \midrule
  No ReDeNoise  &  98.24 & 84.47 \\
  6x  & 98.74 & 89.46 \\
  \bottomrule
\end{tabular}
    \caption{Ablation on ReDeNoise (balanced sequence time sampling)}
    \label{tab:abl_qm9_redenoise}
\end{table}
ReDeNoise improves performance upto 6 iterations, after which the metrics saturate. However, we see that there is a substantial improvement in the moelcular stability metric on using ReDeNoise. Table \ref{tab:abl_qm9_redenoise_unbalanced} gives the results of ReDeNoise in the unbalanced sequence time sampling setting. Since we observed performance improvement till $6$ rounds, we used this for further experiments. The results for balanced sequence time sampling is given in Table \ref{tab:abl_qm9_redenoise}.

\newpage
\paragraph{Effect of Top-p sampling:}
We vary top-p sampling value at inference and examine the effects in Table \ref{tab:abl_qm9_topp}.
\begin{table}[!h]
    \centering
    \begin{tabular}{c c c}
    \toprule
 Top-p & Atom. Stability & Mol. Stability \\
  \midrule
  0.8  &  98.60 &  88.5 \\
  0.9  & 98.90 & 90.74 \\
  0.99  & 98.74 & 89.46\\
  \bottomrule
\end{tabular}
    \caption{Ablation on Top-p}
    \label{tab:abl_qm9_topp}
\end{table}


\paragraph{Best configuration:} After all the above ablations, we obtain the best results with the following configuration:

\begin{table}[!h]
    \centering
    \begin{tabular}{c c}
    \toprule
    % \multicolumn{2}{c}{} \\
    % \midrule
   Interleaving Pattern  & Positions together  \\
   Atom Position Embedding  & Distance-based \\
   Sequence Time Sampling & Balanced \\
   Discrete Noise Schedule & $[0.5, 0.5, 0.5, 0.5]$ \\
   Continuous Noising Steps & $[200, 200, 200, 200]$ \\
   Continuous Noise Schedule &$\text{cosine}(0.0001, 0.03)$  \\
   ReDeNoise & 6x  \\
   Top-p & 0.9\\
   \bottomrule
\end{tabular}
    \caption{Best configuration for QM9}
    \label{app:tab:mol_config_best}
\end{table}
