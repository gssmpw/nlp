\section{Approach}

\subsection{Dynamics Model}

We extend the planar post-stall aircraft model presented in \cite{moore2014robust} into a three-dimensional model of a fixed-wing UAV. The extension of this model is first described in \cite{basescu2020icra} and an abbreviated version is revisited here.
We define our state as $\vect{x} = \begin{bmatrix} \vect{r}, \vectg{\theta}, \vectg{\delta}, \delta_t, \vect{v}, \vectg{\omega}\end{bmatrix}^T$. Here $\vect{r} =\begin{bmatrix} x_r,y_r,z_r\end{bmatrix}^T$ represents the position of the center of mass in the world frame $O_{x_r y_r z_r}$, $\vectg{\theta}= \begin{bmatrix} \phi, \theta, \psi\end{bmatrix}^T$ represents the set of $x-y-z$ Euler angles applied in a $ZYX$ intrinsic rotation sequence, and $\vectg{\delta} = \begin{bmatrix} \delta_{ar}, \delta_e, \delta_r \end{bmatrix}^T$ are control surface deflections for the right aileron, elevator, and rudder respectively. The left aileron deflection is treated as a dependent parameter, with $\delta_{al} = -\delta_{ar}$. $\delta_t$ is the magnitude of thrust from the propeller, $\vect{v} = \begin{bmatrix} v_x, v_y, v_z\end{bmatrix}^T$ is the velocity of the center of mass in the world frame, and $\vectg{\omega} = \begin{bmatrix}\omega_x, \omega_y, \omega_z\end{bmatrix}^T$ is the angular velocity of the body in the body-fixed frame $O_{xyz}$., and  $\vect{u}_{cs} = \begin{bmatrix} \omega_{ar}, \omega_{e}, \omega_{r}\end{bmatrix}^T$, where $\vect{u}_{cs}$ are the angular velocities of the control surfaces.
The equations of motion then become
\begin{align}
\dot{\vect{r}} &= \bR_b^r \vect{v},\quad \dot{\vectg{\theta}} = {\bT}_{\omega}^{-1}{\boldsymbol \omega}\nonumber\\
\dot{\vectg{\delta}} &= \vect{u}_{cs}, \quad \dot{\delta}_t = a_t \delta_t + b_t u_t\nonumber\\
\dot{\vect{v}} &= \vect{f}/m - \vectg{\omega}\times \vect{v},\quad \dot{\vectg{\omega}} = \matr{J}^{-1}(\vect{m}-\vectg{\omega}\times\matr{J}\vectg{\omega})
\label{eq:eom}
\end{align}

where 
\begin{align}
\vect{f}&= \sum_i\vect{f}_{s_i} - mg{\bR_b^r}^T \bez + {\bR_{t}^b}\vect{f}_{t} + \vect{f}_a\nonumber\\
\vect{m}&= \sum_{i}(\vect{l}_{s_i} \times \vect{f}_{s_i}) + \vect{m}_a .
\end{align}

Here $m$ is vehicle mass, $\matr{J}$ is the vehicle's inertia, $\bR_b^r$ denotes the rotation of the body-fixed frame with respect to the world frame, ${\bT}_{\omega}$ is the transformation which maps the Euler angle rates to an angular velocity in the body-fixed frame, $\bR_{t}^b$ is the rotation matrix that defines the orientation of the thrust source with respect to the body-fixed frame, and $g$ is the acceleration due to gravity. $\vect{f}_{s_i}$ represents the force due to each aerodynamic surface in the body frame calculated using flat plate theory and $\vect{f}_{t}$ represents the force due to the propeller and is given as $\vect{f}_{t}=\begin{bmatrix}\delta_{t} & 0 & 0\end{bmatrix}^T$. $\vect{l}_{s_i}$ is the vector from the vehicle center of mass to the surface center of pressure in the body-fixed frame. $a_t$ and $b_t$ are constants used to model the thrust dynamics and $u_t$ is the normalized control signal for the motor, $u_t\in{[0,1]} $. $\vect{f}_a$ and $\vect{m}_a$ represent learned residual aerodynamic forces and moments respectively.


\subsection{Trajectory Generation}

Direct trajectory optimization is characterized by the inclusion of both the inputs and states as decision variables in the optimization problem \cite{pardo2016evaluating} and often exhibits superior numerical conditioning and greater robustness to local minima than indirect methods \cite{tedrake2009underactuated}. Here, we use a direct transcription formulation of Simpson's integration rule as described in \cite{pardo2016evaluating} and formulate a trajectory optimization problem to solve the post-stall landing problem. We employ the Sparse Nonlinear Optimizer (SNOPT) \cite{Gill:2005:Snopt} to solve our nonlinear optimization problem. For the landing problem, even over fairly large ($\approx$ 4s) time horizons we have found that these implicit integration constraints offer good numerical stability and reduce the required number of knot points, which reduces the overall computational burden. Our trajectory optimization problem can be written as
\begin{equation}
\begin{aligned}
& \underset{\vect{x}_k, \vect{u}_k, h }{\text{min}}
& & \vect{\bar{x}}_N^T \vect{Q_f} \vect{\bar{x}}_N + \sum_k^{N-1}{ \vect{x}_k^T \vect{Q}  \vect{x}_k + \vect{u}_k^T \vect{R}  \vect{u}_k}\\
& \text{s.t.}
& & \vect{x}_{k} - \vect{x}_{k+1} + \frac{h}{6.0}(\vect{\dot{x}}_{k} + 4 \vect{\dot{x}}_{c,k} + \vect{\dot{x}}_{k+1})= 0\\
&
& & -\vectg{\delta}_f \le \vect{x}_{N}-\vect{x}_f \le \vectg{\delta}_f,~ -\vectg{\delta}_i \le \vect{x}_{0}-\vect{x}_i \le \vectg{\delta}_i\\
&
& & \vect{x}_{min}  \le \vect{x}_{k} \le \vect{x}_{max},~ \vect{u}_{min}  \le \vect{u}_{k} \le \vect{u}_{max}\\
&
&  & h_{min}  \le h \le h_{max},~ \forall k \in [0,\ldots,N]
\end{aligned}
\end{equation}
where 
\begin{align}
\vect{\dot{x}}_{k} &= \vect{f}(t, \vect{x}_{k}, \vect{u}_{k}),~~
\vect{\dot{x}}_{k+1} = \vect{f}(t, \vect{x}_{k+1}, \vect{u}_{k+1})\nonumber\\
\vect{u}_{c,k} &= (\vect{u}_{k} + \vect{u}_{k+1}) / 2\nonumber\\
\vect{x}_{c,k} &= (\vect{x}_{k} + \vect{x}_{k+1}) / 2 + h (\vect{\dot{x}}_{k} - \vect{\dot{x}}_{k+1}) / 8\nonumber\\
\vect{\dot{x}}_{c,k} &= \vect{f}(t, \vect{x}_{c,k}, \vect{u}_{c,k}).
\end{align}
Here, $\vect{x}$ is the system state and $\vect{u}$ is the control input. $h$ is the time step where $h_{min}=0.001s$ and $h_{max}=0.2s$. $\vectg{\delta}_f$ and $\vectg{\delta}_i$ represent the bounds on the desired final and initial states ($\vect{x}_f$,$\vect{x}_i$), respectively. $N$ is the number of knot points and $\bar{\vect{x}}_N = \vect{x}_N-\vect{x}_f$. $\matr{Q}$, $\matr{R}$, and $\matr{Q_f}$ are cost weighting matrices. In hardware, we achieved real-time planning at 5 Hz.
\subsubsection{Trajectory Tracking}
To control the aircraft to a trajectory between re-plans, we use time-varying LQR (TVLQR).
\begin{align}
\bu(t,\bx) &= \matr{K}(\bx-\bx_0(t))+\bu_{0}(t).
\end{align}
where the time-dependent feedback gain matrix $\matr{K}(t) = \matr{R_c}^{-1}\matr{B}(t)^T\matr{S}(t)$
and $\matr{S}(t)$ is computed by integrating
\begin{align}
-\dot{\matr{S}} = \matr{A}(t)^T\matr{S}+\matr{S}\matr{A}(t)-\matr{S}\matr{B}(t)\matr{R_c}^{-1}\matr{B}(t)^T\matr{S}+\matr{Q_c}
\end{align}
backwards in time from $t=T$ to $t=0$. Here $\matr{A}(t)=\frac{\partial \bff(\bx_0,\bu_0(t))}{\partial \bx}$ and $\matr{B}(t)=\frac{\partial \bff(\bx_0(t),\bu_0(t))}{\partial \bx}$. $\bx_{0}(t)$ and $\bu_{0}(t)$ are the nominal trajectories. $\matr{Q_c}$ and $\matr{R_c}$ are the weighting matrices on state and action respectively, and $\matr{S}(T)=\matr{Q_{fc}}$. Trajectory tracking occurred at a rate of 50 Hz. 

\subsection{Multi-Agent Architecture/Trajectory Passing}
\subsection{Statistical Verification}