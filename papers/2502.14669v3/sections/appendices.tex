\appendix

\section{Algorithm}
This appendix details the algorithm used to generate the maze reasoning dataset with reset demonstrations. The algorithm processes a base dataset of maze navigation problems and augments it with demonstration of incorrect attempts followed by resets and correct solutions.

% \begin{algorithm}
% \caption{Maze Reasoning Reset Data Generation}
% \label{alg:maze_reset}
% \begin{algorithmic}[1]
% \Require Base dataset $D$ containing maze problems with:
% \State - Adjacency list representation of $5\times5$ maze grid
% \State - Origin and target coordinates
% \State - Correct solution path
% \Ensure Augmented dataset with reset demonstrations

% \State Initialize empty datasets $D_1$ and $D_2$

% \ForAll{example $e \in D$}
%     \State Extract adjacency list $A$, origin $O$, target $T$, and path $P$
%     \State Count walls $W$ around origin $O$
%     \If{$W = 1$}
%         \State Add $e$ to $D_1$
%     \ElsIf{$W = 2$}
%         \State Add $e$ to $D_2$
%     \EndIf
% \EndFor

% \Procedure{ProcessOrder1}{$D_1$} \Comment{1 wall at origin}
%     \ForAll{example $\in D_1$}
%         \State $WP \gets \emptyset$ \Comment{Initialize wrong paths set}
%         \ForAll{adjacent node $N$ to origin $O$}
%             \If{$N \notin$ correct path}
%                 \For{$n\_steps$ from $max\_n\_steps$ down to $1$}
%                     \State Attempt to extend path until dead end or $n\_steps$
%                     \If{path length = $n\_steps$ or dead end reached}
%                         \State $WP \gets WP \cup \{path\}$
%                         \State \textbf{break}
%                     \EndIf
%                 \EndFor
%             \EndIf
%         \EndFor
%         \ForAll{path $\in WP$}
%             \State Generate chain-of-thought steps
%             \State Add ``Heading in wrong direction'' message
%             \State Add RESET marker
%         \EndFor
%         \State Append original correct solution
%         \State Format as conversation pairs
%     \EndFor
% \EndProcedure

% \Procedure{ProcessOrder2}{$D_2$} \Comment{2 walls at origin}
%     \ForAll{example $\in D_2$}
%         \For{$n\_steps$ from $max\_n\_steps$ down to $1$}
%             \State Generate wrong path $WP$ of length $n\_steps$
%             \If{valid path found}
%                 \State Generate chain-of-thought for $WP$
%                 \If{ending has 3 walls}
%                     \State Add ``Hit a dead end'' message
%                 \Else
%                     \State Add ``Heading in wrong direction'' message
%                 \EndIf
%                 \State Add RESET marker
%                 \State \textbf{break}
%             \EndIf
%         \EndFor
%         \State Append original correct solution
%         \State Format as conversation pairs
%     \EndFor
% \EndProcedure

% \State Combine processed $D_1$ and $D_2$ examples into final dataset

% \end{algorithmic}
% \end{algorithm}
% Algorithm 1: Main process
\begin{algorithm}
\caption{Maze Reasoning Reset Data Generation - Main Process}
\label{alg:main}
\begin{algorithmic}[1]
\REQUIRE Base dataset $D$ containing maze problems with:
    \STATE \quad - Adjacency list representation of $5 \times 5$ maze grid
    \STATE \quad - Origin and target coordinates
    \STATE \quad - Correct solution path
\ENSURE Augmented dataset with reset demonstrations

\STATE Initialize empty datasets $D_1$ and $D_2$

\FORALL{example $e \in D$}
    \STATE Extract adjacency list $A$, origin $O$, target $T$, and path $P$ from $e$
    \STATE Count walls $W$ around origin $O$
    \IF{$W = 1$}
        \STATE Add $e$ to $D_1$
        \STATE Call ProcessOrder1($e$) \COMMENT{See Algorithm \ref{alg:order1}}
    \ELSIF{$W = 2$}
        \STATE Add $e$ to $D_2$
        \STATE Call ProcessOrder2($e$) \COMMENT{See Algorithm \ref{alg:order2}}
    \ENDIF
\ENDFOR

\STATE Combine processed examples from $D_1$ and $D_2$ into the final dataset
\end{algorithmic}
\end{algorithm}

% Algorithm 2: Order-1 processing
\begin{algorithm}
\caption{Order-1 Processing (1 wall at origin)}
\label{alg:order1}
\begin{algorithmic}[1]
\STATE \textbf{Procedure} ProcessOrder1(example)
    \STATE $WP \leftarrow \emptyset$ \COMMENT{Initialize wrong paths set}
    \FORALL{adjacent node $N$ to origin $O$}
        \IF{$N \notin$ correct path $P$}
            \FOR{$n\_steps$ from $\text{max\_n\_steps}$ down to $1$}
                \STATE Attempt to extend path from $N$ until a dead end or $n\_steps$ are reached.
                \IF{path length = $n\_steps$ or a dead end is reached}
                    \STATE $WP \leftarrow WP \cup \{\text{path}\}$
                    \STATE \textbf{break}
                \ENDIF
            \ENDFOR
        \ENDIF
    \ENDFOR
    \FORALL{path $p \in WP$}
        \STATE Generate chain-of-thought steps for path $p$.
        \STATE Add ``Heading in wrong direction'' message.
        \STATE Add RESET marker.
    \ENDFOR
    \STATE Append original correct solution (path $P$).
    \STATE Format as conversation pairs.
\STATE \textbf{End Procedure}
\end{algorithmic}
\end{algorithm}

% Algorithm 3: Order-2 processing
\begin{algorithm}
\caption{Order-2 Processing (2 walls at origin)}
\label{alg:order2}
\begin{algorithmic}[1]
\STATE \textbf{Procedure} ProcessOrder2(example)
    \FOR{$n\_steps$ from $\text{max\_n\_steps}$ down to $1$}
        \STATE Generate wrong path $WP$ of length $n\_steps$ starting from $O$.
        \IF{a valid path $WP$ is found}
            \STATE Generate chain-of-thought for $WP$.
            \IF{$WP$ ends at a dead end (3 walls)}
                \STATE Add ``Hit a dead end'' message.
            \ELSE
                \STATE Add ``Heading in wrong direction'' message.
            \ENDIF
            \STATE Add RESET marker.
            \STATE \textbf{break}
        \ENDIF
    \ENDFOR
    \STATE Append original correct solution (path $P$).
    \STATE Format as conversation pairs.
\STATE \textbf{End Procedure}
\end{algorithmic}
\end{algorithm}

