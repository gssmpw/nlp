@inproceedings{toga,
author = {Dinella, Elizabeth and Ryan, Gabriel and Mytkowicz, Todd and Lahiri, Shuvendu K.},
title = {TOGA: a neural method for test oracle generation},
year = {2022},
isbn = {9781450392211},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3510003.3510141},
doi = {10.1145/3510003.3510141},
abstract = {Testing is widely recognized as an important stage of the software development lifecycle. Effective software testing can provide benefits such as bug finding, preventing regressions, and documentation. In terms of documentation, unit tests express a unit's intended functionality, as conceived by the developer. A test oracle, typically expressed as an condition, documents the intended behavior of a unit under a given test prefix. Synthesizing a functional test oracle is a challenging problem, as it must capture the intended functionality rather than the implemented functionality.In this paper, we propose TOGA (a neural method for <u>T</u>est <u>O</u>racle <u>G</u>ener<u>A</u>tion), a unified transformer-based neural approach to infer both exceptional and assertion test oracles based on the context of the focal method. Our approach can handle units with ambiguous or missing documentation, and even units with a missing implementation. We evaluate our approach on both oracle inference accuracy and functional bug-finding. Our technique improves accuracy by 33\% over existing oracle inference approaches, achieving 96\% overall accuracy on a held out test dataset. Furthermore, we show that when integrated with a automated test generation tool (EvoSuite), our approach finds 57 real world bugs in large-scale Java programs, including 30 bugs that are not found by any other automated testing method in our evaluation.},
booktitle = {Proceedings of the 44th International Conference on Software Engineering},
pages = {2130–2141},
numpages = {12},
location = {Pittsburgh, Pennsylvania},
series = {ICSE '22}
}

@inproceedings{evosuite,
  title={Evosuite: automatic test suite generation for object-oriented software},
  author={Fraser, Gordon and Arcuri, Andrea},
  booktitle={Proceedings of the 19th ACM SIGSOFT symposium and the 13th European conference on Foundations of software engineering},
  pages={416--419},
  year={2011}
}

@inproceedings{xia2024fuzz4all,
  title={Fuzz4all: Universal fuzzing with large language models},
  author={Xia, Chunqiu Steven and Paltenghi, Matteo and Le Tian, Jia and Pradel, Michael and Zhang, Lingming},
  booktitle={Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
  pages={1--13},
  year={2024}
}

@article{gulwani2016programming,
  title={Programming by examples},
  author={Gulwani, Sumit},
  journal={Dependable Software Systems Engineering},
  volume={45},
  number={137},
  pages={3--15},
  year={2016},
  publisher={IOS Press}
}

@inproceedings{deng2023large,
  title={Large language models are zero-shot fuzzers: Fuzzing deep-learning libraries via large language models},
  author={Deng, Yinlin and Xia, Chunqiu Steven and Peng, Haoran and Yang, Chenyuan and Zhang, Lingming},
  booktitle={Proceedings of the 32nd ACM SIGSOFT international symposium on software testing and analysis},
  pages={423--435},
  year={2023}
}

@inproceedings{jain2022jigsaw,
  title={Jigsaw: Large language models meet program synthesis},
  author={Jain, Naman and Vaidyanath, Skanda and Iyer, Arun and Natarajan, Nagarajan and Parthasarathy, Suresh and Rajamani, Sriram and Sharma, Rahul},
  booktitle={Proceedings of the 44th International Conference on Software Engineering},
  pages={1219--1231},
  year={2022}
}

@inproceedings{pfeiffer2020constitutes,
  title={What constitutes software? An empirical, descriptive study of artifacts},
  author={Pfeiffer, Rolf-Helge},
  booktitle={Proceedings of the 17th International Conference on Mining Software Repositories},
  pages={481--491},
  year={2020}
}

@inproceedings{su2023hotgpt,
  title={Hotgpt: How to make software documentation more useful with a large language model?},
  author={Su, Yiming and Wan, Chengcheng and Sethi, Utsav and Lu, Shan and Musuvathi, Madan and Nath, Suman},
  booktitle={Proceedings of the 19th Workshop on Hot Topics in Operating Systems},
  pages={87--93},
  year={2023}
}

@article{shin2020autoprompt,
  title={Autoprompt: Eliciting knowledge from language models with automatically generated prompts},
  author={Shin, Taylor and Razeghi, Yasaman and Logan IV, Robert L and Wallace, Eric and Singh, Sameer},
  journal={arXiv preprint arXiv:2010.15980},
  year={2020}
}

@article{planning2002economic,
  title={The economic impacts of inadequate infrastructure for software testing},
  author={Planning, Strategic},
  journal={National Institute of Standards and Technology},
  volume={1},
  year={2002}
}

@inproceedings{daka2014survey,
  title={A survey on unit testing practices and problems},
  author={Daka, Ermira and Fraser, Gordon},
  booktitle={2014 IEEE 25th International Symposium on Software Reliability Engineering},
  pages={201--211},
  year={2014},
  organization={IEEE}
}

@article{porrello2012death,
  title={Death and denial: The failure of the therac-25, a medical linear accelerator},
  author={Porrello, Anne M},
  journal={Death and Denial: The Failure of the THERAC-25, AMedical Linear Accelerator},
  year={2012}
}

@inproceedings{hossain2023neural,
  title={Neural-based test oracle generation: A large-scale evaluation and lessons learned},
  author={Hossain, Soneya Binta and Filieri, Antonio and Dwyer, Matthew B and Elbaum, Sebastian and Visser, Willem},
  booktitle={Proceedings of the 31st ACM Joint European Software Engineering Conference and Symposium on the Foundations of Software Engineering},
  pages={120--132},
  year={2023}
}

@inproceedings{li2023cctest,
  title={Cctest: Testing and repairing code completion systems},
  author={Li, Zongjie and Wang, Chaozheng and Liu, Zhibo and Wang, Haoxuan and Chen, Dong and Wang, Shuai and Gao, Cuiyun},
  booktitle={2023 IEEE/ACM 45th International Conference on Software Engineering (ICSE)},
  pages={1238--1250},
  year={2023},
  organization={IEEE}
}

@inproceedings{nam2024using,
  title={Using an llm to help with code understanding},
  author={Nam, Daye and Macvean, Andrew and Hellendoorn, Vincent and Vasilescu, Bogdan and Myers, Brad},
  booktitle={Proceedings of the IEEE/ACM 46th International Conference on Software Engineering},
  pages={1--13},
  year={2024}
}

@inproceedings{afshan2013evolving,
  title={Evolving readable string test inputs using a natural language model to reduce human oracle cost},
  author={Afshan, Sheeva and McMinn, Phil and Stevenson, Mark},
  booktitle={2013 IEEE Sixth International Conference on Software Testing, Verification and Validation},
  pages={352--361},
  year={2013},
  organization={IEEE}
}

@inproceedings{harman2010optimizing,
  title={Optimizing for the number of tests generated in search based test data generation with an application to the oracle cost problem},
  author={Harman, Mark and Kim, Sung Gon and Lakhotia, Kiran and McMinn, Phil and Yoo, Shin},
  booktitle={2010 Third International Conference on Software Testing, Verification, and Validation Workshops},
  pages={182--191},
  year={2010},
  organization={IEEE}
}

@article{endres2024can,
  title={Can Large Language Models Transform Natural Language Intent into Formal Method Postconditions?},
  author={Endres, Madeline and Fakhoury, Sarah and Chakraborty, Saikat and Lahiri, Shuvendu K},
  journal={Proceedings of the ACM on Software Engineering},
  volume={1},
  number={FSE},
  pages={1889--1912},
  year={2024},
  publisher={ACM New York, NY, USA}
}

@inproceedings{pacheco2007randoop,
  title={Randoop: feedback-directed random testing for Java},
  author={Pacheco, Carlos and Ernst, Michael D},
  booktitle={Companion to the 22nd ACM SIGPLAN conference on Object-oriented programming systems and applications companion},
  pages={815--816},
  year={2007}
}

@inproceedings{tillmann2008pex,
  title={Pex--white box test generation for. net},
  author={Tillmann, Nikolai and De Halleux, Jonathan},
  booktitle={International conference on tests and proofs},
  pages={134--153},
  year={2008},
  organization={Springer}
}

@inproceedings{tan2012tcomment,
  title={@ tcomment: Testing javadoc comments to detect comment-code inconsistencies},
  author={Tan, Shin Hwei and Marinov, Darko and Tan, Lin and Leavens, Gary T},
  booktitle={2012 IEEE Fifth International Conference on Software Testing, Verification and Validation},
  pages={260--269},
  year={2012},
  organization={IEEE}
}

@article{blasi2021memo,
  title={MeMo: Automatically identifying metamorphic relations in Javadoc comments for test automation},
  author={Blasi, Arianna and Gorla, Alessandra and Ernst, Michael D and Pezz{\`e}, Mauro and Carzaniga, Antonio},
  journal={Journal of Systems and Software},
  volume={181},
  pages={111041},
  year={2021},
  publisher={Elsevier}
}

@inproceedings{watson2020learning,
  title={On learning meaningful assert statements for unit test cases},
  author={Watson, Cody and Tufano, Michele and Moran, Kevin and Bavota, Gabriele and Poshyvanyk, Denys},
  booktitle={Proceedings of the ACM/IEEE 42nd International Conference on Software Engineering},
  pages={1398--1409},
  year={2020}
}

@article{tufano2020unit,
  title={Unit test case generation with transformers and focal context},
  author={Tufano, Michele and Drain, Dawn and Svyatkovskiy, Alexey and Deng, Shao Kun and Sundaresan, Neel},
  journal={arXiv preprint arXiv:2009.05617},
  year={2020}
}

@article{lahiri2022interactive,
  title={Interactive code generation via test-driven user-intent formalization},
  author={Lahiri, Shuvendu K and Fakhoury, Sarah and Naik, Aaditya and Sakkas, Georgios and Chakraborty, Saikat and Musuvathi, Madanlal and Choudhury, Piali and von Veh, Curtis and Inala, Jeevana Priya and Wang, Chenglong and others},
  journal={arXiv preprint arXiv:2208.05950},
  year={2022}
}

@article{hossain2024togll,
  title={TOGLL: Correct and Strong Test Oracle Generation with LLMs},
  author={Hossain, Soneya Binta and Dwyer, Matthew},
  journal={arXiv preprint arXiv:2405.03786},
  year={2024}
}

@article{spiess2024quality,
  title={Quality and Trust in LLM-generated Code},
  author={Spiess, Claudio and Gros, David and Pai, Kunal Suresh and Pradel, Michael and Rabin, Md Rafiqul Islam and Jha, Susmit and Devanbu, Prem and Ahmed, Toufique},
  journal={arXiv preprint arXiv:2402.02047},
  year={2024}
}

@article{ugare2024improving,
  title={Improving llm code generation with grammar augmentation},
  author={Ugare, Shubham and Suresh, Tarun and Kang, Hangoo and Misailovic, Sasa and Singh, Gagandeep},
  journal={arXiv preprint arXiv:2403.01632},
  year={2024}
}

@article{zhu2022fuzzing,
  title={Fuzzing: a survey for roadmap},
  author={Zhu, Xiaogang and Wen, Sheng and Camtepe, Seyit and Xiang, Yang},
  journal={ACM Computing Surveys (CSUR)},
  volume={54},
  number={11s},
  pages={1--36},
  year={2022},
  publisher={ACM New York, NY}
}

@article{baldoni2018survey,
  title={A survey of symbolic execution techniques},
  author={Baldoni, Roberto and Coppa, Emilio and D’elia, Daniele Cono and Demetrescu, Camil and Finocchi, Irene},
  journal={ACM Computing Surveys (CSUR)},
  volume={51},
  number={3},
  pages={1--39},
  year={2018},
  publisher={ACM New York, NY, USA}
}

@article{wang2024software,
  title={Software testing with large language models: Survey, landscape, and vision},
  author={Wang, Junjie and Huang, Yuchao and Chen, Chunyang and Liu, Zhe and Wang, Song and Wang, Qing},
  journal={IEEE Transactions on Software Engineering},
  year={2024},
  publisher={IEEE}
}

@article{liu2020automatic,
  title={Automatic test case and test oracle generation based on functional scenarios in formal specifications for conformance testing},
  author={Liu, Shaoying and Nakajima, Shin},
  journal={IEEE Transactions on Software Engineering},
  volume={48},
  number={2},
  pages={691--712},
  year={2020},
  publisher={IEEE}
}

@inproceedings{fontes2021using,
  title={Using machine learning to generate test oracles: A systematic literature review},
  author={Fontes, Afonso and Gay, Gregory},
  booktitle={Proceedings of the 1st International Workshop on Test Oracles},
  pages={1--10},
  year={2021}
}

@article{wang2023large,
  title={Large language models are implicitly topic models: Explaining and finding good demonstrations for in-context learning},
  author={Wang, Xinyi and Zhu, Wanrong and Wang, William Yang},
  journal={arXiv preprint arXiv:2301.11916},
  pages={3},
  year={2023}
}

@article{liu2024llm,
  title={LLM-Powered Test Case Generation for Detecting Tricky Bugs},
  author={Liu, Kaibo and Liu, Yiyang and Chen, Zhenpeng and Zhang, Jie M and Han, Yudong and Ma, Yun and Li, Ge and Huang, Gang},
  journal={arXiv preprint arXiv:2404.10304},
  year={2024}
}

@article{schaeffer2024emergent,
  title={Are emergent abilities of large language models a mirage?},
  author={Schaeffer, Rylan and Miranda, Brando and Koyejo, Sanmi},
  journal={Advances in Neural Information Processing Systems},
  volume={36},
  year={2024}
}

@article{xia2023universal,
  title={Universal fuzzing via large language models},
  author={Xia, Chunqiu Steven and Paltenghi, Matteo and Tian, Jia Le and Pradel, Michael and Zhang, Lingming},
  journal={arXiv preprint arXiv:2308.04748},
  year={2023}
}

@article{ouyang2023llm,
  title={LLM is Like a Box of Chocolates: the Non-determinism of ChatGPT in Code Generation},
  author={Ouyang, Shuyin and Zhang, Jie M and Harman, Mark and Wang, Meng},
  journal={arXiv preprint arXiv:2308.02828},
  year={2023}
}

@inproceedings{zhai2020c2s,
  title={C2S: translating natural language comments to formal program specifications},
  author={Zhai, Juan and Shi, Yu and Pan, Minxue and Zhou, Guian and Liu, Yongxiang and Fang, Chunrong and Ma, Shiqing and Tan, Lin and Zhang, Xiangyu},
  booktitle={Proceedings of the 28th ACM joint meeting on European software engineering conference and symposium on the foundations of software engineering},
  pages={25--37},
  year={2020}
}

@inproceedings{leitner2007contract,
  title={Contract driven development= test driven development-writing test cases},
  author={Leitner, Andreas and Ciupa, Ilinca and Oriol, Manuel and Meyer, Bertrand and Fiva, Arno},
  booktitle={Proceedings of the the 6th joint meeting of the European software engineering conference and the ACM SIGSOFT symposium on The foundations of software engineering},
  pages={425--434},
  year={2007}
}

@article{wei2022chain,
  title={Chain-of-thought prompting elicits reasoning in large language models},
  author={Wei, Jason and Wang, Xuezhi and Schuurmans, Dale and Bosma, Maarten and Xia, Fei and Chi, Ed and Le, Quoc V and Zhou, Denny and others},
  journal={Advances in neural information processing systems},
  volume={35},
  pages={24824--24837},
  year={2022}
}

@article{chen2023you,
  title={When do you need chain-of-thought prompting for chatgpt?},
  author={Chen, Jiuhai and Chen, Lichang and Huang, Heng and Zhou, Tianyi},
  journal={arXiv preprint arXiv:2304.03262},
  year={2023}
}

@article{li2023structured,
  title={Structured chain-of-thought prompting for code generation},
  author={Li, Jia and Li, Ge and Li, Yongmin and Jin, Zhi},
  journal={ACM Transactions on Software Engineering and Methodology},
  year={2023},
  publisher={ACM New York, NY}
}

@article{diao2023active,
  title={Active prompting with chain-of-thought for large language models},
  author={Diao, Shizhe and Wang, Pengcheng and Lin, Yong and Pan, Rui and Liu, Xiang and Zhang, Tong},
  journal={arXiv preprint arXiv:2302.12246},
  year={2023}
}

@article{ma2023fairness,
  title={Fairness-guided few-shot prompting for large language models},
  author={Ma, Huan and Zhang, Changqing and Bian, Yatao and Liu, Lemao and Zhang, Zhirui and Zhao, Peilin and Zhang, Shu and Fu, Huazhu and Hu, Qinghua and Wu, Bingzhe},
  journal={Advances in Neural Information Processing Systems},
  volume={36},
  pages={43136--43155},
  year={2023}
}

@inproceedings{xu2022prompting,
  title={Prompting decision transformer for few-shot policy generalization},
  author={Xu, Mengdi and Shen, Yikang and Zhang, Shun and Lu, Yuchen and Zhao, Ding and Tenenbaum, Joshua and Gan, Chuang},
  booktitle={international conference on machine learning},
  pages={24631--24645},
  year={2022},
  organization={PMLR}
}

@inproceedings{tan2008empirical,
  title={An Empirical Security Study of the Native Code in the JDK.},
  author={Tan, Gang and Croft, Jason},
  booktitle={Usenix Security Symposium},
  pages={365--378},
  year={2008}
}

@article{lee2012towards,
  title={Towards categorizing and formalizing the JDK API},
  author={Lee, Choonghwan and Jin, Dongyun and Meredith, Patrick O'Neil and Rosu, Grigore},
  year={2012}
}

@article{king1976symbolic,
  title={Symbolic execution and program testing},
  author={King, James C},
  journal={Communications of the ACM},
  volume={19},
  number={7},
  pages={385--394},
  year={1976},
  publisher={ACM New York, NY, USA}
}

@inproceedings{khurshid2003generalized,
  title={Generalized symbolic execution for model checking and testing},
  author={Khurshid, Sarfraz and P{\u{a}}s{\u{a}}reanu, Corina S and Visser, Willem},
  booktitle={International Conference on Tools and Algorithms for the Construction and Analysis of Systems},
  pages={553--568},
  year={2003},
  organization={Springer}
}

@inproceedings{meng2022batmapper,
  title={BatMapper-Plus: Smartphone-Based Multi-level Indoor Floor Plan Construction via Acoustic Ranging and Inertial Sensing},
  author={Meng, Chuize and Jiang, Shan and Wu, Mengning and Xiao, Xuan and Tao, Dan and Gao, Ruipeng},
  booktitle={International Conference on Wireless Algorithms, Systems, and Applications},
  pages={155--167},
  year={2022},
  organization={Springer}
}

@inproceedings{ren2022petrack,
  title={PeTrack: Smartphone-based pedestrian tracking in underground parking lot},
  author={Ren, Xiaotong and Zhu, Shuli and Meng, Chuize and Jiang, Shan and Xiao, Xuan and Tao, Dan and Gao, Ruipeng},
  booktitle={2022 18th International Conference on Mobility, Sensing and Networking (MSN)},
  pages={752--756},
  year={2022},
  organization={IEEE}
}

@article{meng2023smartphone,
  title={Smartphone-Based Indoor Floor Plan Construction via Acoustic Ranging and Inertial Tracking},
  author={Meng, Chuize and Jiang, Shan and Wu, Mengning and Xiao, Xuan and Tao, Dan and Gao, Ruipeng},
  journal={Machines},
  volume={11},
  number={2},
  pages={205},
  year={2023},
  publisher={MDPI}
}

@article{zhang2023ecoassistant,
  title={Ecoassistant: Using llm assistant more affordably and accurately},
  author={Zhang, Jieyu and Krishna, Ranjay and Awadallah, Ahmed H and Wang, Chi},
  journal={arXiv preprint arXiv:2310.03046},
  year={2023}
}

@inproceedings{dong2023towards,
  title={Towards next-generation intelligent assistants leveraging llm techniques},
  author={Dong, Xin Luna and Moon, Seungwhan and Xu, Yifan Ethan and Malik, Kshitiz and Yu, Zhou},
  booktitle={Proceedings of the 29th ACM SIGKDD Conference on Knowledge Discovery and Data Mining},
  pages={5792--5793},
  year={2023}
}

@article{gao2024aligning,
  title={Aligning llm agents by learning latent preference from user edits},
  author={Gao, Ge and Taymanov, Alexey and Salinas, Eduardo and Mineiro, Paul and Misra, Dipendra},
  journal={arXiv preprint arXiv:2404.15269},
  year={2024}
}

@article{jeon2002embedding,
  title={Embedding built-in tests in hot spots of an object-oriented framework},
  author={Jeon, Taewoong and Seung, Hyon Woo and Lee, Sungyoung},
  journal={ACM Sigplan Notices},
  volume={37},
  number={8},
  pages={25--34},
  year={2002},
  publisher={ACM New York, NY, USA}
}

@article{an2024make,
  title={Make Your LLM Fully Utilize the Context},
  author={An, Shengnan and Ma, Zexiong and Lin, Zeqi and Zheng, Nanning and Lou, Jian-Guang},
  journal={arXiv preprint arXiv:2404.16811},
  year={2024}
}

@article{schwarzschild2024rethinking,
  title={Rethinking llm memorization through the lens of adversarial compression},
  author={Schwarzschild, Avi and Feng, Zhili and Maini, Pratyush and Lipton, Zachary C and Kolter, J Zico},
  journal={arXiv preprint arXiv:2404.15146},
  year={2024}
}

@article{lewis2023formal,
  title={Formal verification of quantum programs: Theory, tools, and challenges},
  author={Lewis, Marco and Soudjani, Sadegh and Zuliani, Paolo},
  journal={ACM Transactions on Quantum Computing},
  volume={5},
  number={1},
  pages={1--35},
  year={2023},
  publisher={ACM New York, NY}
}

@inproceedings{kim2024exploring,
  title={Exploring the Impact of Inheritance on Test Code Maintainability},
  author={Kim, Dong Jae and Chen, Tse-Hsun},
  booktitle={Proceedings of the 2024 IEEE/ACM 46th International Conference on Software Engineering: Companion Proceedings},
  pages={382--383},
  year={2024}
}

@article{shin2024assessing,
  title={Assessing evaluation metrics for neural test oracle generation},
  author={Shin, Jiho and Hemmati, Hadi and Wei, Moshi and Wang, Song},
  journal={IEEE Transactions on Software Engineering},
  year={2024},
  publisher={IEEE}
}

@article{kamaraj2023hybridized,
  title={A Hybridized Artificial Neural Network for Automated Software Test Oracle.},
  author={Kamaraj, K and Lanitha, B and Karthic, S and Prakash, PN and Mahaveerakannan, R},
  journal={Computer Systems Science \& Engineering},
  volume={45},
  number={2},
  year={2023}
}

@INPROCEEDINGS{6185286,
  author={Blanc, Gregory and Miyamoto, Daisuke and Akiyama, Mitsuaki and Kadobayashi, Youki},
  booktitle={2012 26th International Conference on Advanced Information Networking and Applications Workshops}, 
  title={Characterizing Obfuscated JavaScript Using Abstract Syntax Trees: Experimenting with Malicious Scripts}, 
  year={2012},
  volume={},
  number={},
  pages={344-351},
  keywords={Syntactics;Personal digital assistants;Proposals;Automata;Malware;Feature extraction;Electronic mail;abstract syntax tree;JavaScript;obfuscation},
  doi={10.1109/WAINA.2012.140}}

@article{jiang2024generating,
  title={Generating executable oracles to check conformance of client code to requirements of JDK Javadocs using LLMs},
  author={Jiang, Shan and Zhu, Chenguang and Khurshid, Sarfraz},
  journal={arXiv preprint arXiv:2411.01789},
  year={2024}
}

@article{frangel,
author = {Shi, Kensen and Steinhardt, Jacob and Liang, Percy},
title = {FrAngel: component-based synthesis with control structures},
year = {2019},
issue_date = {January 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {POPL},
doi = {10.1145/3290386},
abstract = {In component-based program synthesis, the synthesizer generates a program given a library of components (functions). Existing component-based synthesizers have difficulty synthesizing loops and other control structures, and they often require formal specifications of the components, which can be expensive to generate. We present FrAngel, a new approach to component-based synthesis that can synthesize short Java functions with control structures when given a desired signature, a set of input-output examples, and a collection of libraries (without formal specifications). FrAngel aims to discover programs with many distinct behaviors by combining two main ideas. First, it mines code fragments from partially-successful programs that only pass some of the examples. These extracted fragments are often useful for synthesis due to a property that we call special-case similarity. Second, FrAngel uses angelic conditions as placeholders for control structure conditions and optimistically evaluates the resulting program sketches. Angelic conditions decompose the synthesis process: FrAngel first finds promising partial programs and later fills in their missing conditions. We demonstrate that FrAngel can synthesize a variety of interesting programs with combinations of control structures within seconds, significantly outperforming prior state-of-the-art.},
journal = {Proc. ACM Program. Lang.},
month = jan,
articleno = {73},
numpages = {29},
keywords = {program synthesis, control structures, component-based synthesis, angelic execution}
}

@article{10.1145/1064978.1065018,
author = {Mandelin, David and Xu, Lin and Bod\'{\i}k, Rastislav and Kimelman, Doug},
title = {Jungloid mining: helping to navigate the API jungle},
year = {2005},
issue_date = {June 2005},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {40},
number = {6},
issn = {0362-1340},
doi = {10.1145/1064978.1065018},
abstract = {Reuse of existing code from class libraries and frameworks is often difficult because APIs are complex and the client code required to use the APIs can be hard to write. We observed that a common scenario is that the programmer knows what type of object he needs, but does not know how to write the code to get the object.In order to help programmers write API client code more easily, we developed techniques for synthesizing jungloid code fragments automatically given a simple query that describes that desired code in terms of input and output types. A jungloid is simply a unary expression; jungloids are simple, enabling synthesis, but are also versatile, covering many coding problems, and composable, combining to form more complex code fragments. We synthesize jungloids using both API method signatures and jungloids mined from a corpus of sample client programs.We implemented a tool, prospector, based on these techniques. prospector is integrated with the Eclipse IDE code assistance feature, and it infers queries from context so there is no need for the programmer to write queries. We tested prospector on a set of real programming problems involving APIs; prospector found the desired solution for 18 of 20 problems. We also evaluated prospector in a user study, finding that programmers solved programming problems more quickly and with more reuse when using prospector than without prospector.},
journal = {SIGPLAN Not.},
month = jun,
pages = {48–61},
numpages = {14},
keywords = {reuse, program synthesis, mining}
}

@inproceedings{jungloid,
author = {Mandelin, David and Xu, Lin and Bod\'{\i}k, Rastislav and Kimelman, Doug},
title = {Jungloid mining: helping to navigate the API jungle},
year = {2005},
isbn = {1595930566},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/1065010.1065018},
abstract = {Reuse of existing code from class libraries and frameworks is often difficult because APIs are complex and the client code required to use the APIs can be hard to write. We observed that a common scenario is that the programmer knows what type of object he needs, but does not know how to write the code to get the object.In order to help programmers write API client code more easily, we developed techniques for synthesizing jungloid code fragments automatically given a simple query that describes that desired code in terms of input and output types. A jungloid is simply a unary expression; jungloids are simple, enabling synthesis, but are also versatile, covering many coding problems, and composable, combining to form more complex code fragments. We synthesize jungloids using both API method signatures and jungloids mined from a corpus of sample client programs.We implemented a tool, prospector, based on these techniques. prospector is integrated with the Eclipse IDE code assistance feature, and it infers queries from context so there is no need for the programmer to write queries. We tested prospector on a set of real programming problems involving APIs; prospector found the desired solution for 18 of 20 problems. We also evaluated prospector in a user study, finding that programmers solved programming problems more quickly and with more reuse when using prospector than without prospector.},
booktitle = {Proceedings of the 2005 ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {48–61},
numpages = {14},
keywords = {reuse, program synthesis, mining},
location = {Chicago, IL, USA},
series = {PLDI '05}
}

@article{10.1145/1993316.1993506,
author = {Gulwani, Sumit and Jha, Susmit and Tiwari, Ashish and Venkatesan, Ramarathnam},
title = {Synthesis of loop-free programs},
year = {2011},
issue_date = {June 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {6},
issn = {0362-1340},
doi = {10.1145/1993316.1993506},
abstract = {We consider the problem of synthesizing loop-free programs that implement a desired functionality using components from a given library. Specifications of the desired functionality and the library components are provided as logical relations between their respective input and output variables. The library components can be used at most once, and hence the library is required to contain a reasonable overapproximation of the multiset of the components required.We solve the above component-based synthesis problem using a constraint-based approach that involves first generating a synthesis constraint, and then solving the constraint. The synthesis constraint is a first-order ∃∀ logic formula whose size is quadratic in the number of components. We present a novel algorithm for solving such constraints. Our algorithm is based on counterexample guided iterative synthesis paradigm and uses off-the-shelf SMT solvers.We present experimental results that show that our tool Brahma can efficiently synthesize highly nontrivial 10-20 line loop-free bitvector programs. These programs represent a state space of approximately 2010 programs, and are beyond the reach of the other tools based on sketching and superoptimization.},
journal = {SIGPLAN Not.},
month = jun,
pages = {62–73},
numpages = {12},
keywords = {component-based synthesis, program synthesis, smt}
}

@inproceedings{10.1145/1993498.1993506,
author = {Gulwani, Sumit and Jha, Susmit and Tiwari, Ashish and Venkatesan, Ramarathnam},
title = {Synthesis of loop-free programs},
year = {2011},
isbn = {9781450306638},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/1993498.1993506},
abstract = {We consider the problem of synthesizing loop-free programs that implement a desired functionality using components from a given library. Specifications of the desired functionality and the library components are provided as logical relations between their respective input and output variables. The library components can be used at most once, and hence the library is required to contain a reasonable overapproximation of the multiset of the components required.We solve the above component-based synthesis problem using a constraint-based approach that involves first generating a synthesis constraint, and then solving the constraint. The synthesis constraint is a first-order ∃∀ logic formula whose size is quadratic in the number of components. We present a novel algorithm for solving such constraints. Our algorithm is based on counterexample guided iterative synthesis paradigm and uses off-the-shelf SMT solvers.We present experimental results that show that our tool Brahma can efficiently synthesize highly nontrivial 10-20 line loop-free bitvector programs. These programs represent a state space of approximately 2010 programs, and are beyond the reach of the other tools based on sketching and superoptimization.},
booktitle = {Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {62–73},
numpages = {12},
keywords = {component-based synthesis, program synthesis, smt},
location = {San Jose, California, USA},
series = {PLDI '11}
}

@inproceedings{10.1145/1706299.1706337,
author = {Srivastava, Saurabh and Gulwani, Sumit and Foster, Jeffrey S.},
title = {From program verification to program synthesis},
year = {2010},
isbn = {9781605584799},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/1706299.1706337},
abstract = {This paper describes a novel technique for the synthesis of imperative programs. Automated program synthesis has the potential to make programming and the design of systems easier by allowing programs to be specified at a higher-level than executable code. In our approach, which we call proof-theoretic synthesis, the user provides an input-output functional specification, a description of the atomic operations in the programming language, and a specification of the synthesized program's looping structure, allowed stack space, and bound on usage of certain operations. Our technique synthesizes a program, if there exists one, that meets the input-output specification and uses only the given resources.The insight behind our approach is to interpret program synthesis as generalized program verification, which allows us to bring verification tools and techniques to program synthesis. Our synthesis algorithm works by creating a program with unknown statements, guards, inductive invariants, and ranking functions. It then generates constraints that relate the unknowns and enforces three kinds of requirements: partial correctness, loop termination, and well-formedness conditions on program guards. We formalize the requirements that program verification tools must meet to solve these constraint and use tools from prior work as our synthesizers.We demonstrate the feasibility of the proposed approach by synthesizing programs in three different domains: arithmetic, sorting, and dynamic programming. Using verification tools that we previously built in the VS3 project we are able to synthesize programs for complicated arithmetic algorithms including Strassen's matrix multiplication and Bresenham's line drawing; several sorting algorithms; and several dynamic programming algorithms. For these programs, the median time for synthesis is 14 seconds, and the ratio of synthesis to verification time ranges between 1x to 92x (with an median of 7x), illustrating the potential of the approach.},
booktitle = {Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {313–326},
numpages = {14},
keywords = {verification, proof-theoretic program synthesis},
location = {Madrid, Spain},
series = {POPL '10}
}

@article{proveri,
author = {Srivastava, Saurabh and Gulwani, Sumit and Foster, Jeffrey S.},
title = {From program verification to program synthesis},
year = {2010},
issue_date = {January 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {1},
issn = {0362-1340},
doi = {10.1145/1707801.1706337},
abstract = {This paper describes a novel technique for the synthesis of imperative programs. Automated program synthesis has the potential to make programming and the design of systems easier by allowing programs to be specified at a higher-level than executable code. In our approach, which we call proof-theoretic synthesis, the user provides an input-output functional specification, a description of the atomic operations in the programming language, and a specification of the synthesized program's looping structure, allowed stack space, and bound on usage of certain operations. Our technique synthesizes a program, if there exists one, that meets the input-output specification and uses only the given resources.The insight behind our approach is to interpret program synthesis as generalized program verification, which allows us to bring verification tools and techniques to program synthesis. Our synthesis algorithm works by creating a program with unknown statements, guards, inductive invariants, and ranking functions. It then generates constraints that relate the unknowns and enforces three kinds of requirements: partial correctness, loop termination, and well-formedness conditions on program guards. We formalize the requirements that program verification tools must meet to solve these constraint and use tools from prior work as our synthesizers.We demonstrate the feasibility of the proposed approach by synthesizing programs in three different domains: arithmetic, sorting, and dynamic programming. Using verification tools that we previously built in the VS3 project we are able to synthesize programs for complicated arithmetic algorithms including Strassen's matrix multiplication and Bresenham's line drawing; several sorting algorithms; and several dynamic programming algorithms. For these programs, the median time for synthesis is 14 seconds, and the ratio of synthesis to verification time ranges between 1x to 92x (with an median of 7x), illustrating the potential of the approach.},
journal = {SIGPLAN Not.},
month = jan,
pages = {313–326},
numpages = {14},
keywords = {verification, proof-theoretic program synthesis}
}

@inproceedings{mimic,
author = {Heule, Stefan and Sridharan, Manu and Chandra, Satish},
title = {Mimic: computing models for opaque code},
year = {2015},
isbn = {9781450336758},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/2786805.2786875},
abstract = {Opaque code, which is executable but whose source is unavailable or hard to process, can be problematic in a number of scenarios, such as program analysis. Manual construction of models is often used to handle opaque code, but this process is tedious and error-prone. (In this paper, we use model to mean a representation of a piece of code suitable for program analysis.) We present a novel technique for automatic generation of models for opaque code, based on program synthesis. The technique intercepts memory accesses from the opaque code to client objects, and uses this information to construct partial execution traces. Then, it performs a heuristic search inspired by Markov Chain Monte Carlo techniques to discover an executable code model whose behavior matches the opaque code. Native execution, parallelization, and a carefully-designed fitness function are leveraged to increase the effectiveness of the search. We have implemented our technique in a tool Mimic for discovering models of opaque JavaScript functions, and used Mimic to synthesize correct models for a variety of array-manipulating routines.},
booktitle = {Proceedings of the 2015 10th Joint Meeting on Foundations of Software Engineering},
pages = {710–720},
numpages = {11},
keywords = {JavaScript, MCMC, Opaque code, model generation, program synthesis},
location = {Bergamo, Italy},
series = {ESEC/FSE 2015}
}


@inproceedings{oguide,
author = {Jha, Susmit and Gulwani, Sumit and Seshia, Sanjit A. and Tiwari, Ashish},
title = {Oracle-guided component-based program synthesis},
year = {2010},
isbn = {9781605587196},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/1806799.1806833},
abstract = {We present a novel approach to automatic synthesis of loop-free programs. The approach is based on a combination of oracle-guided learning from examples, and constraint-based synthesis from components using satisfiability modulo theories (SMT) solvers. Our approach is suitable for many applications, including as an aid to program understanding tasks such as deobfuscating malware. We demonstrate the efficiency and effectiveness of our approach by synthesizing bit-manipulating programs and by deobfuscating programs.},
booktitle = {Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1},
pages = {215–224},
numpages = {10},
keywords = {program synthesis, oracle-based learning, SMT, SAT},
location = {Cape Town, South Africa},
series = {ICSE '10}
}

@inproceedings{10.1145/1926385.1926423,
author = {Gulwani, Sumit},
title = {Automating string processing in spreadsheets using input-output examples},
year = {2011},
isbn = {9781450304900},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/1926385.1926423},
abstract = {We describe the design of a string programming/expression language that supports restricted forms of regular expressions, conditionals and loops. The language is expressive enough to represent a wide variety of string manipulation tasks that end-users struggle with. We describe an algorithm based on several novel concepts for synthesizing a desired program in this language from input-output examples. The synthesis algorithm is very efficient taking a fraction of a second for various benchmark examples. The synthesis algorithm is interactive and has several desirable features: it can rank multiple solutions and has fast convergence, it can detect noise in the user input, and it supports an active interaction model wherein the user is prompted to provide outputs on inputs that may have multiple computational interpretations.The algorithm has been implemented as an interactive add-in for Microsoft Excel spreadsheet system. The prototype tool has met the golden test - it has synthesized part of itself, and has been used to solve problems beyond author's imagination.},
booktitle = {Proceedings of the 38th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {317–330},
numpages = {14},
keywords = {program synthesis, programming by example (pbe), spreadsheet programming, string manipulation, user intent, version space algebra},
location = {Austin, Texas, USA},
series = {POPL '11}
}

@article{stringio,
author = {Gulwani, Sumit},
title = {Automating string processing in spreadsheets using input-output examples},
year = {2011},
issue_date = {January 2011},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {46},
number = {1},
issn = {0362-1340},
doi = {10.1145/1925844.1926423},
abstract = {We describe the design of a string programming/expression language that supports restricted forms of regular expressions, conditionals and loops. The language is expressive enough to represent a wide variety of string manipulation tasks that end-users struggle with. We describe an algorithm based on several novel concepts for synthesizing a desired program in this language from input-output examples. The synthesis algorithm is very efficient taking a fraction of a second for various benchmark examples. The synthesis algorithm is interactive and has several desirable features: it can rank multiple solutions and has fast convergence, it can detect noise in the user input, and it supports an active interaction model wherein the user is prompted to provide outputs on inputs that may have multiple computational interpretations.The algorithm has been implemented as an interactive add-in for Microsoft Excel spreadsheet system. The prototype tool has met the golden test - it has synthesized part of itself, and has been used to solve problems beyond author's imagination.},
journal = {SIGPLAN Not.},
month = jan,
pages = {317–330},
numpages = {14},
keywords = {program synthesis, programming by example (pbe), spreadsheet programming, string manipulation, user intent, version space algebra}
}

@inproceedings{icmlpbe,
author = {Menon, Aditya Krishna and Tamuz, Omer and Gulwani, Sumit and Lampson, Butler and Kalai, Adam Tauman},
title = {A machine learning framework for programming by example},
year = {2013},
publisher = {JMLR.org},
abstract = {Learning programs is a timely and interesting challenge. In Programming by Example (PBE), a system attempts to infer a program from input and output examples alone, by searching for a composition of some set of base functions. We show how machine learning can be used to speed up this seemingly hopeless search problem, by learning weights that relate textual features describing the provided input-output examples to plausible sub-components of a program. This generic learning framework lets us address problems beyond the scope of earlier PBE systems. Experiments on a prototype implementation show that learning improves search and ranking on a variety of text processing tasks found on help forums.},
booktitle = {Proceedings of the 30th International Conference on International Conference on Machine Learning - Volume 28},
pages = {I–187–I–195},
location = {Atlanta, GA, USA},
series = {ICML'13}
}

@inproceedings{syngeo,
author = {Gulwani, Sumit and Korthikanti, Vijay Anand and Tiwari, Ashish},
title = {Synthesizing geometry constructions},
year = {2011},
isbn = {9781450306638},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/1993498.1993505},
abstract = {In this paper, we study the problem of automatically solving ruler/compass based geometry construction problems. We first introduce a logic and a programming language for describing such constructions and then phrase the automation problem as a program synthesis problem. We then describe a new program synthesis technique based on three key insights: (i) reduction of symbolic reasoning to concrete reasoning (based on a deep theoretical result that reduces verification to random testing), (ii) extending the instruction set of the programming language with higher level primitives (representing basic constructions found in textbook chapters, inspired by how humans use their experience and knowledge gained from chapters to perform complicated constructions), and (iii) pruning the forward exhaustive search using a goal-directed heuristic (simulating backward reasoning performed by humans). Our tool can successfully synthesize constructions for various geometry problems picked up from high-school textbooks and examination papers in a reasonable amount of time. This opens up an amazing set of possibilities in the context of making classroom teaching interactive.},
booktitle = {Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {50–61},
numpages = {12},
keywords = {abstraction, forward and backward analysis, program synthesis, ruler-compass geometry constructions},
location = {San Jose, California, USA},
series = {PLDI '11}
}

@article{10.1145/3140587.3062351,
author = {Feng, Yu and Martins, Ruben and Van Geffen, Jacob and Dillig, Isil and Chaudhuri, Swarat},
title = {Component-based synthesis of table consolidation and transformation tasks from examples},
year = {2017},
issue_date = {June 2017},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {52},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/3140587.3062351},
doi = {10.1145/3140587.3062351},
abstract = {This paper presents a novel component-based synthesis algorithm that marries the power of type-directed search with lightweight SMT-based deduction and partial evaluation. Given a set of components together with their over-approximate first-order specifications, our method first generates a program sketch over a subset of the components and checks its feasibility using an SMT solver. Since a program sketch typically represents many concrete programs, the use of SMT-based deduction greatly increases the scalability of the algorithm. Once a feasible program sketch is found, our algorithm completes the sketch in a bottom-up fashion, using partial evaluation to further increase the power of deduction for rejecting partially-filled program sketches. We apply the proposed synthesis methodology for automating a large class of data preparation tasks that commonly arise in data science. We have evaluated our synthesis algorithm on dozens of data wrangling and consolidation tasks obtained from on-line forums, and we show that our approach can automatically solve a large class of problems encountered by R users.},
journal = {SIGPLAN Not.},
month = jun,
pages = {422–436},
numpages = {15},
keywords = {SMT-based deduction, Programming by example, Program synthesis, Data preparation, Component-based synthesis}
}

@inproceedings{syntable,
author = {Feng, Yu and Martins, Ruben and Van Geffen, Jacob and Dillig, Isil and Chaudhuri, Swarat},
title = {Component-based synthesis of table consolidation and transformation tasks from examples},
year = {2017},
isbn = {9781450349888},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3062341.3062351},
doi = {10.1145/3062341.3062351},
abstract = {This paper presents a novel component-based synthesis algorithm that marries the power of type-directed search with lightweight SMT-based deduction and partial evaluation. Given a set of components together with their over-approximate first-order specifications, our method first generates a program sketch over a subset of the components and checks its feasibility using an SMT solver. Since a program sketch typically represents many concrete programs, the use of SMT-based deduction greatly increases the scalability of the algorithm. Once a feasible program sketch is found, our algorithm completes the sketch in a bottom-up fashion, using partial evaluation to further increase the power of deduction for rejecting partially-filled program sketches. We apply the proposed synthesis methodology for automating a large class of data preparation tasks that commonly arise in data science. We have evaluated our synthesis algorithm on dozens of data wrangling and consolidation tasks obtained from on-line forums, and we show that our approach can automatically solve a large class of problems encountered by R users.},
booktitle = {Proceedings of the 38th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {422–436},
numpages = {15},
keywords = {SMT-based deduction, Programming by example, Program synthesis, Data preparation, Component-based synthesis},
location = {Barcelona, Spain},
series = {PLDI 2017}
}


@article{syndstrans,
author = {Feser, John K. and Chaudhuri, Swarat and Dillig, Isil},
title = {Synthesizing data structure transformations from input-output examples},
year = {2015},
issue_date = {June 2015},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {50},
number = {6},
issn = {0362-1340},
doi = {10.1145/2813885.2737977},
abstract = {We present a method for example-guided synthesis of functional programs over recursive data structures. Given a set of input-output examples, our method synthesizes a program in a functional language with higher-order combinators like map and fold. The synthesized program is guaranteed to be the simplest program in the language to fit the examples. Our approach combines three technical ideas: inductive generalization, deduction, and enumerative search. First, we generalize the input-output examples into hypotheses about the structure of the target program. For each hypothesis, we use deduction to infer new input/output examples for the missing subexpressions. This leads to a new subproblem where the goal is to synthesize expressions within each hypothesis. Since not every hypothesis can be realized into a program that fits the examples, we use a combination of best-first enumeration and deduction to search for a hypothesis that meets our needs. We have implemented our method in a tool called λ2, and we evaluate this tool on a large set of synthesis problems involving lists, trees, and nested data structures. The experiments demonstrate the scalability and broad scope of λ2. A highlight is the synthesis of a program believed to be the world's earliest functional pearl.},
journal = {SIGPLAN Not.},
month = jun,
pages = {229–239},
numpages = {11},
keywords = {Program synthesis, automated deduction, data transformations, programming by example, search-based synthesis}
}

@inproceedings{10.1145/1706299.1706339,
author = {Bodik, Rastislav and Chandra, Satish and Galenson, Joel and Kimelman, Doug and Tung, Nicholas and Barman, Shaon and Rodarmor, Casey},
title = {Programming with angelic nondeterminism},
year = {2010},
isbn = {9781605584799},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1706299.1706339},
doi = {10.1145/1706299.1706339},
abstract = {Angelic nondeterminism can play an important role in program development. It simplifies specifications, for example in deriving programs with a refinement calculus; it is the formal basis of regular expressions; and Floyd relied on it to concisely express backtracking algorithms such as N-queens.We show that angelic nondeterminism is also useful during the development of deterministic programs. The semantics of our angelic operator are the same as Floyd's but we use it as a substitute for yet-to-be-written deterministic code; the final program is fully deterministic. The angelic operator divines a value that makes the program meet its specification, if possible. Because the operator is executable, it allows the programmer to test incomplete programs: if a program has no safe execution, it is already incorrect; if a program does have a safe execution, the execution may reveal an implementation strategy to the programmer.We introduce refinement-based angelic programming, describe our embedding of angelic operators into Scala, report on our implementation with bounded model checking, and describe our experience with two case studies. In one of the studies, we use angelic operators to modularize the Deutsch-Schorr-Waite (DSW) algorithm. The modularization is performed with the notion of a parasitic stack, whose incomplete specification was instantiated for DSW with angelic nondeterminism.},
booktitle = {Proceedings of the 37th Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
pages = {339–352},
numpages = {14},
keywords = {traces, refinement, constraints, bounded model-checking, angelic non-determinism},
location = {Madrid, Spain},
series = {POPL '10}
}

@article{pnondet,
author = {Bodik, Rastislav and Chandra, Satish and Galenson, Joel and Kimelman, Doug and Tung, Nicholas and Barman, Shaon and Rodarmor, Casey},
title = {Programming with angelic nondeterminism},
year = {2010},
issue_date = {January 2010},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {45},
number = {1},
issn = {0362-1340},
url = {https://doi.org/10.1145/1707801.1706339},
doi = {10.1145/1707801.1706339},
abstract = {Angelic nondeterminism can play an important role in program development. It simplifies specifications, for example in deriving programs with a refinement calculus; it is the formal basis of regular expressions; and Floyd relied on it to concisely express backtracking algorithms such as N-queens.We show that angelic nondeterminism is also useful during the development of deterministic programs. The semantics of our angelic operator are the same as Floyd's but we use it as a substitute for yet-to-be-written deterministic code; the final program is fully deterministic. The angelic operator divines a value that makes the program meet its specification, if possible. Because the operator is executable, it allows the programmer to test incomplete programs: if a program has no safe execution, it is already incorrect; if a program does have a safe execution, the execution may reveal an implementation strategy to the programmer.We introduce refinement-based angelic programming, describe our embedding of angelic operators into Scala, report on our implementation with bounded model checking, and describe our experience with two case studies. In one of the studies, we use angelic operators to modularize the Deutsch-Schorr-Waite (DSW) algorithm. The modularization is performed with the notion of a parasitic stack, whose incomplete specification was instantiated for DSW with angelic nondeterminism.},
journal = {SIGPLAN Not.},
month = jan,
pages = {339–352},
numpages = {14},
keywords = {traces, refinement, constraints, bounded model-checking, angelic non-determinism}
}


@inproceedings{loopfree,
author = {Gulwani, Sumit and Jha, Susmit and Tiwari, Ashish and Venkatesan, Ramarathnam},
title = {Synthesis of loop-free programs},
year = {2011},
isbn = {9781450306638},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/1993498.1993506},
doi = {10.1145/1993498.1993506},
abstract = {We consider the problem of synthesizing loop-free programs that implement a desired functionality using components from a given library. Specifications of the desired functionality and the library components are provided as logical relations between their respective input and output variables. The library components can be used at most once, and hence the library is required to contain a reasonable overapproximation of the multiset of the components required.We solve the above component-based synthesis problem using a constraint-based approach that involves first generating a synthesis constraint, and then solving the constraint. The synthesis constraint is a first-order ∃∀ logic formula whose size is quadratic in the number of components. We present a novel algorithm for solving such constraints. Our algorithm is based on counterexample guided iterative synthesis paradigm and uses off-the-shelf SMT solvers.We present experimental results that show that our tool Brahma can efficiently synthesize highly nontrivial 10-20 line loop-free bitvector programs. These programs represent a state space of approximately 2010 programs, and are beyond the reach of the other tools based on sketching and superoptimization.},
booktitle = {Proceedings of the 32nd ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {62–73},
numpages = {12},
keywords = {component-based synthesis, program synthesis, smt},
location = {San Jose, California, USA},
series = {PLDI '11}
}

@INPROCEEDINGS{Edsynth,
  author={Yang, Zijiang and Hua, Jinru and Wang, Kaiyuan and Khurshid, Sarfraz},
  booktitle={2018 IEEE 11th International Conference on Software Testing, Verification and Validation (ICST)}, 
  title={EdSynth: Synthesizing API Sequences with Conditionals and Loops}, 
  year={2018},
  volume={},
  number={},
  pages={161-171},
  keywords={Task analysis;Tools;Space exploration;Eigenvalues and eigenfunctions;Libraries;Runtime;Java;Test Execution Driven;API Synthesis with Conditionals and Loops;Lazy Candidate Exploration},
  doi={10.1109/ICST.2018.00025}}

@article{loopy,
author = {Ferdowsifard, Kasra and Barke, Shraddha and Peleg, Hila and Lerner, Sorin and Polikarpova, Nadia},
title = {LooPy: interactive program synthesis with control structures},
year = {2021},
issue_date = {October 2021},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {5},
number = {OOPSLA},
doi = {10.1145/3485530},
abstract = {One vision for program synthesis, and specifically for programming by example (PBE), is an interactive programmer's assistant, integrated into the development environment. To make program synthesis practical for interactive use, prior work on Small-Step Live PBE has proposed to limit the scope of synthesis to small code snippets, and enable the users to provide local specifications for those snippets. This paradigm, however, does not work well in the presence of loops. We present LooPy, a synthesizer integrated into a live programming environment, which extends Small-Step Live PBE to work inside loops and scales it up to synthesize larger code snippets, while remaining fast enough for interactive use. To allow users to effectively provide examples at various loop iterations, even when the loop body is incomplete, LooPy makes use of live execution, a technique that leverages the programmer as an oracle to step over incomplete parts of the loop. To enable synthesis of loop bodies at interactive speeds, LooPy introduces Intermediate State Graph, a new data structure, which compactly represents a large space of code snippets composed of multiple assignment statements and conditionals. We evaluate LooPy empirically using benchmarks from competitive programming and previous synthesizers, and show that it can solve a wide variety of synthesis tasks at interactive speeds. We also perform a small qualitative user study which shows that LooPy's block-level specifications are easy for programmers to provide.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {153},
numpages = {29},
keywords = {Program synthesis, live programming}
}

@inproceedings{sypet,
author = {Feng, Yu and Martins, Ruben and Wang, Yuepeng and Dillig, Isil and Reps, Thomas W.},
title = {Component-based synthesis for complex APIs},
year = {2017},
isbn = {9781450346603},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3009837.3009851},
abstract = {Component-based approaches to program synthesis assemble programs from a database of existing components, such as methods provided by an API. In this paper, we present a novel type-directed algorithm for component-based synthesis. The key novelty of our approach is the use of a compact Petri-net representation to model relationships between methods in an API. Given a target method signature S, our approach performs reachability analysis on the underlying Petri-net model to identify sequences of method calls that could be used to synthesize an implementation of S. The programs synthesized by our algorithm are guaranteed to type check and pass all test cases provided by the user.   We have implemented this approach in a tool called SyPet, and used it to successfully synthesize real-world programming tasks extracted from on-line forums and existing code repositories. We also compare SyPet with two state-of-the-art synthesis tools, namely InSynth and CodeHint, and demonstrate that SyPet can synthesize more programs in less time. Finally, we compare our approach with an alternative solution based on hypergraphs and demonstrate its advantages.},
booktitle = {Proceedings of the 44th ACM SIGPLAN Symposium on Principles of Programming Languages},
pages = {599–612},
numpages = {14},
keywords = {Component-based, Petri-net, Program Synthesis, Type-directed},
location = {Paris, France},
series = {POPL '17}
}


@article{reuseableAPI,
author = {Mai, Yubo and Gao, Zhipeng and Hu, Xing and Bao, Lingfeng and Liu, Yu and Sun, JianLing},
title = {Are Human Rules Necessary? Generating Reusable APIs with CoT Reasoning and In-Context Learning},
year = {2024},
issue_date = {July 2024},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {1},
number = {FSE},
url = {https://doi.org/10.1145/3660811},
abstract = {Inspired by the great potential of Large Language Models (LLMs) for solving complex coding tasks, in this paper, we propose a novel approach, named Code2API, to automatically perform APIzation for Stack Overflow code snippets. Code2API does not require additional model training or any manual crafting rules and can be easily deployed on personal computers without relying on other external tools. Specifically, Code2API guides the LLMs through well-designed prompts to generate well-formed APIs for given code snippets. To elicit knowledge and logical reasoning from LLMs, we used chain-of-thought (CoT) reasoning and few-shot in-context learning, which can help the LLMs fully understand the APIzation task and solve it step by step in a manner similar to a developer. Our evaluations show that Code2API achieves a remarkable accuracy in identifying method parameters (65\%) and return statements (66\%) equivalent to human-generated ones, surpassing the current state-of-the-art approach, APIzator, by 15.0\% and 16.5\% respectively. Moreover, compared with APIzator, our user study demonstrates that Code2API exhibits superior performance in generating meaningful method names, even surpassing the human-level performance, and developers are more willing to use APIs generated by our approach, highlighting the applicability of our tool in practice. Finally, we successfully extend our framework to the Python dataset, achieving a comparable performance with Java, which verifies the generalizability of our tool.},
journal = {Proc. ACM Softw. Eng.},
month = jul,
articleno = {104},
numpages = {23},
keywords = {APIs, Chain-of-thought, In-context learning, Large language models, Stack Overflow}
}


@inproceedings{transit,
author = {Udupa, Abhishek and Raghavan, Arun and Deshmukh, Jyotirmoy V. and Mador-Haim, Sela and Martin, Milo M.K. and Alur, Rajeev},
title = {TRANSIT: specifying protocols with concolic snippets},
year = {2013},
isbn = {9781450320146},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2491956.2462174},
doi = {10.1145/2491956.2462174},
abstract = {With the maturing of technology for model checking and constraint solving, there is an emerging opportunity to develop programming tools that can transform the way systems are specified. In this paper, we propose a new way to program distributed protocols using concolic snippets. Concolic snippets are sample execution fragments that contain both concrete and symbolic values. The proposed approach allows the programmer to describe the desired system partially using the traditional model of communicating extended finite-state-machines (EFSM), along with high-level invariants and concrete execution fragments. Our synthesis engine completes an EFSM skeleton by inferring guards and updates from the given fragments which is then automatically analyzed using a model checker with respect to the desired invariants. The counterexamples produced by the model checker can then be used by the programmer to add new concrete execution fragments that describe the correct behavior in the specific scenario corresponding to the counterexample.We describe TRANSIT, a language and prototype implementation of the proposed specification methodology for distributed protocols. Experimental evaluations of TRANSIT to specify cache coherence protocols show that (1) the algorithm for expression inference from concolic snippets can synthesize expressions of size 15 involving typical operators over commonly occurring types, (2) for a classical directory-based protocol, TRANSIT automatically generates, in a few seconds, a complete implementation from a specification consisting of the EFSM structure and a few concrete examples for every transition, and (3) a published partial description of the SGI Origin cache coherence protocol maps directly to symbolic examples and leads to a complete implementation in a few iterations, with the programmer correcting counterexamples resulting from underspecified transitions by adding concrete examples in each iteration.},
booktitle = {Proceedings of the 34th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {287–296},
numpages = {10},
keywords = {cache coherence, program synthesis, programming by example},
location = {Seattle, Washington, USA},
series = {PLDI '13}
}

@inproceedings{escher,
  title={Recursive program synthesis},
  author={Albarghouthi, Aws and Gulwani, Sumit and Kincaid, Zachary},
  booktitle={Computer Aided Verification: 25th International Conference, CAV 2013, Saint Petersburg, Russia, July 13-19, 2013. Proceedings 25},
  pages={934--950},
  year={2013},
  organization={Springer}
}


@inproceedings{snippy,
author = {Ferdowsifard, Kasra and Ordookhanians, Allen and Peleg, Hila and Lerner, Sorin and Polikarpova, Nadia},
title = {Small-Step Live Programming by Example},
year = {2020},
isbn = {9781450375146},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3379337.3415869},
abstract = {Live programming is a paradigm in which the programming environment continually displays runtime values. Program synthesis is a technique that can generate programs or program snippets from examples. deltextThis paper presents a new programming paradigm called Synthesis-Aided Live Programming that combines these two prior ideas in a synergistic way. When using Synthesis-Aided Live Programming, programmers can change the runtime values displayed by the live addtextPrevious works that combine the two have taken a holistic approach to the way examples describe the behavior of functions and programs. This paper presents a new programming paradigm called Small-Step Live Programming by Example that lets the user apply Programming by Example locally. When using Small-Step Live Programming by Example, programmers can change the runtime values displayed by the live visualization to generate local program snippets. \% Live programming and program \% synthesis work perfectly together because the live programming environment \% reifies values, which makes it easy for programmers to provide the examples \% needed by the synthesizer. We implemented this new paradigm in a tool called toolname, and performed a user study on $13$ programmers. Our study finds that Small-Step Live Programming by Example with toolname helps users solve harder problems faster, and that for certain types of queries, users prefer it to searching the web. Additionally, we identify the usersynthgap, in which users' mental models of the tool do not match its ability, and needs to be taken into account in the design of future synthesis tools.},
booktitle = {Proceedings of the 33rd Annual ACM Symposium on User Interface Software and Technology},
pages = {614–626},
numpages = {13},
keywords = {live programming, program synthesis},
location = {Virtual Event, USA},
series = {UIST '20}
}

@inproceedings{codehint,
author = {Galenson, Joel and Reames, Philip and Bodik, Rastislav and Hartmann, Bj\"{o}rn and Sen, Koushik},
title = {CodeHint: dynamic and interactive synthesis of code snippets},
year = {2014},
isbn = {9781450327565},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2568225.2568250},
abstract = {There are many tools that help programmers find code fragments, but most are inexpressive and rely on static information. We present a new technique for synthesizing code that is dynamic (giving accurate results and allowing programmers to reason about concrete executions), easy-to-use (supporting a wide range of correctness specifications), and interactive (allowing users to refine the candidate code snippets). Our implementation, which we call CodeHint, generates and evaluates code at runtime and hence can synthesize real-world Java code that involves I/O, reflection, native calls, and other advanced language features. We have evaluated CodeHint in two user studies and show that its algorithms are efficient and that it improves programmer productivity by more than a factor of two.},
booktitle = {Proceedings of the 36th International Conference on Software Engineering},
pages = {653–663},
numpages = {11},
keywords = {program synthesis, IDE},
location = {Hyderabad, India},
series = {ICSE 2014}
}


@article{tfcoder,
author = {Shi, Kensen and Bieber, David and Singh, Rishabh},
title = {TF-Coder: Program Synthesis for Tensor Manipulations},
year = {2022},
issue_date = {June 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {44},
number = {2},
issn = {0164-0925},
url = {https://doi.org/10.1145/3517034},
abstract = {The success and popularity of deep learning is on the rise, partially due to powerful deep learning frameworks such as TensorFlow and PyTorch, which make it easier to develop deep learning models. However, these libraries also come with steep learning curves, since programming in these frameworks is quite different from traditional imperative programming with explicit loops and conditionals. In this work, we present a tool called TF-Coder for programming by example in TensorFlow. TF-Coder uses a bottom-up weighted enumerative search, with value-based pruning of equivalent expressions and flexible type- and value-based filtering to ensure that expressions adhere to various requirements imposed by the TensorFlow library. We train models to predict TensorFlow operations from features of the input and output tensors and natural language descriptions of tasks to prioritize relevant operations during search. TF-Coder solves 63 of 70 real-world tasks within 5 minutes, sometimes finding simpler solutions in less time compared to experienced human programmers.},
journal = {ACM Trans. Program. Lang. Syst.},
month = may,
articleno = {10},
numpages = {36},
keywords = {tensor transformation, tensor manipulation, TensorFlow, PBE, programming by example, Program synthesis}
}

@article{autopandas,
author = {Bavishi, Rohan and Lemieux, Caroline and Fox, Roy and Sen, Koushik and Stoica, Ion},
title = {AutoPandas: neural-backed generators for program synthesis},
year = {2019},
issue_date = {October 2019},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {OOPSLA},
url = {https://doi.org/10.1145/3360594},
abstract = {Developers nowadays have to contend with a growing number of APIs. While in the long-term they are very useful to developers, many modern APIs have an incredibly steep learning curve, due to their hundreds of functions handling many arguments, obscure documentation, and frequently changing semantics. For APIs that perform data transformations, novices can often provide an I/O example demonstrating the desired transformation, but may be stuck on how to translate it to the API. A programming-by-example synthesis engine that takes such I/O examples and directly produces programs in the target API could help such novices. Such an engine presents unique challenges due to the breadth of real-world APIs, and the often-complex constraints over function arguments. We present a generator-based synthesis approach to contend with these problems. This approach uses a program candidate generator, which encodes basic constraints on the space of programs. We introduce neural-backed operators which can be seamlessly integrated into the program generator. To improve the efficiency of the search, we simply use these operators at non-deterministic decision points, instead of relying on domain-specific heuristics. We implement this technique for the Python pandas library in AutoPandas. AutoPandas supports 119 pandas dataframe transformation functions. We evaluate AutoPandas on 26 real-world benchmarks and find it solves 17 of them.},
journal = {Proc. ACM Program. Lang.},
month = oct,
articleno = {168},
numpages = {27},
keywords = {generators, graph neural network, pandas, program synthesis, programming-by-example, python}
}

@inproceedings{wrex,
author = {Drosos, Ian and Barik, Titus and Guo, Philip J. and DeLine, Robert and Gulwani, Sumit},
title = {Wrex: A Unified Programming-by-Example Interaction for Synthesizing Readable Code for Data Scientists},
year = {2020},
isbn = {9781450367080},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
doi = {10.1145/3313831.3376442},
abstract = {Data wrangling is a difficult and time-consuming activity in computational notebooks, and existing wrangling tools do not fit the exploratory workflow for data scientists in these environments. We propose a unified interaction model based on programming-by-example that generates readable code for a variety of useful data transformations, implemented as a Jupyter notebook extension called Wrex. User study results demonstrate that data scientists are significantly more effective and efficient at data wrangling with Wrex over manual programming. Qualitative participant feedback indicates that Wrex was useful and reduced barriers in having to recall or look up the usage of various data transform functions. The synthesized code allowed data scientists to verify the intended data transformation, increased their trust and confidence in Wrex, and fit seamlessly within their cell-based notebook workflows. This work suggests that presenting readable code to professional data scientists is an indispensable component of offering data wrangling tools in notebooks.},
booktitle = {Proceedings of the 2020 CHI Conference on Human Factors in Computing Systems},
pages = {1–12},
numpages = {12},
keywords = {computational notebooks, data science, program synthesis},
location = {Honolulu, HI, USA},
series = {CHI '20}
}
@inproceedings{fewshotahmed2023,
author = {Ahmed, Toufique and Devanbu, Premkumar},
title = {Few-shot training LLMs for project-specific code-summarization},
year = {2023},
isbn = {9781450394758},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3551349.3559555},
doi = {10.1145/3551349.3559555},
abstract = {Very large language models (LLMs), such as GPT-3 and Codex have achieved state-of-the-art performance on several natural-language tasks, and show great promise also for code. A particularly exciting aspect of LLMs is their knack for few-shot and zero-shot learning: they can learn to perform a task with very few examples. Few-shotting has particular synergies in software engineering, where there are a lot of phenomena (identifier names, APIs, terminology, coding patterns) that are known to be highly project-specific. However, project-specific data can be quite limited, especially early in the history of a project; thus the few-shot learning capacity of LLMs might be very relevant. In this paper, we investigate the use few-shot training with the very large GPT (Generative Pre-trained Transformer) Codex model, and find evidence suggesting that one can significantly surpass state-of-the-art models for code-summarization, leveraging project-specific training.},
booktitle = {Proceedings of the 37th IEEE/ACM International Conference on Automated Software Engineering},
articleno = {177},
numpages = {5},
keywords = {code summarization, deep learning, large language model},
location = {Rochester, MI, USA},
series = {ASE '22}
}

@article{10.1145/2666356.2594297,
author = {Perelman, Daniel and Gulwani, Sumit and Grossman, Dan and Provost, Peter},
title = {Test-driven synthesis},
year = {2014},
issue_date = {June 2014},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {49},
number = {6},
issn = {0362-1340},
url = {https://doi.org/10.1145/2666356.2594297},
doi = {10.1145/2666356.2594297},
abstract = {Programming-by-example technologies empower end-users to create simple programs merely by providing input/output examples. Existing systems are designed around solvers specialized for a specific set of data types or domain-specific language (DSL). We present a program synthesizer which can be parameterized by an arbitrary DSL that may contain conditionals and loops and therefore is able to synthesize programs in any domain. In order to use our synthesizer, the user provides a sequence of increasingly sophisticated input/output examples along with an expert-written DSL definition. These two inputs correspond to the two key ideas that allow our synthesizer to work in arbitrary domains. First, we developed a novel iterative synthesis technique inspired by test-driven development---which also gives our technique the name of test-driven synthesis---where the input/output examples are consumed one at a time as the program is refined. Second, the DSL allows our system to take an efficient component-based approach to enumerating possible programs. We present applications of our synthesis methodology to end-user programming for transformations over strings, XML, and table layouts. We compare our synthesizer on these applications to state-of-the-art DSL-specific synthesizers as well to the general purpose synthesizer Sketch.},
journal = {SIGPLAN Not.},
month = jun,
pages = {408–418},
numpages = {11},
keywords = {test driven development, program synthesis, end-user programming}
}

@inproceedings{testdriven,
author = {Perelman, Daniel and Gulwani, Sumit and Grossman, Dan and Provost, Peter},
title = {Test-driven synthesis},
year = {2014},
isbn = {9781450327848},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/2594291.2594297},
doi = {10.1145/2594291.2594297},
abstract = {Programming-by-example technologies empower end-users to create simple programs merely by providing input/output examples. Existing systems are designed around solvers specialized for a specific set of data types or domain-specific language (DSL). We present a program synthesizer which can be parameterized by an arbitrary DSL that may contain conditionals and loops and therefore is able to synthesize programs in any domain. In order to use our synthesizer, the user provides a sequence of increasingly sophisticated input/output examples along with an expert-written DSL definition. These two inputs correspond to the two key ideas that allow our synthesizer to work in arbitrary domains. First, we developed a novel iterative synthesis technique inspired by test-driven development---which also gives our technique the name of test-driven synthesis---where the input/output examples are consumed one at a time as the program is refined. Second, the DSL allows our system to take an efficient component-based approach to enumerating possible programs. We present applications of our synthesis methodology to end-user programming for transformations over strings, XML, and table layouts. We compare our synthesizer on these applications to state-of-the-art DSL-specific synthesizers as well to the general purpose synthesizer Sketch.},
booktitle = {Proceedings of the 35th ACM SIGPLAN Conference on Programming Language Design and Implementation},
pages = {408–418},
numpages = {11},
keywords = {test driven development, program synthesis, end-user programming},
location = {Edinburgh, United Kingdom},
series = {PLDI '14}
}

@article{lamothe2021systematic,
author = {Lamothe, Maxime and Gu\'{e}h\'{e}neuc, Yann-Ga\"{e}l and Shang, Weiyi},
title = {A Systematic Review of API Evolution Literature},
year = {2021},
issue_date = {November 2022},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {54},
number = {8},
issn = {0360-0300},
url = {https://doi.org/10.1145/3470133},
doi = {10.1145/3470133},
abstract = {Recent software advances have led to an expansion of the development and usage of application programming interfaces (APIs). From millions of Android packages (APKs) available on Google Store to millions of open-source packages available in Maven, PyPI, and npm, APIs have become an integral part of software development.Like any software artifact, software APIs evolve and suffer from this evolution. Prior research has uncovered many challenges to the development, usage, and evolution of APIs. While some challenges have been studied and solved, many remain. These challenges are scattered in the literature, which hides advances and cloaks the remaining challenges.In this systematic literature review on APIs and API evolution, we uncover and describe publication trends and trending topics. We compile common research goals, evaluation methods, metrics, and subjects. We summarize the current state-of-the-art and outline known existing challenges as well as new challenges uncovered during this review.We conclude that the main remaining challenges related to APIs and API evolution are (1) automatically identifying and leveraging factors that drive API changes, (2) creating and using uniform benchmarks for research evaluation, and (3) understanding the impact of API evolution on API developers and users with respect to various programming languages.},
journal = {ACM Comput. Surv.},
month = oct,
articleno = {171},
numpages = {36},
keywords = {API evolution, APIs, SLR}
}
