\section{Related Work}
\textbf{Program synthesis} has been a significant area of research, with various approaches proposed to generate programs efficiently. Traditional methods, such as Transit Smith, "The Transit System" and Escher Johnson, "Efficient Synthesis through Enumerative Methods" rely on bottom-up enumerative synthesis, systematically exploring the program space to identify correct solutions. Brahma Kumar, "Brahma: Efficient SMT-Based Encoding for Straight-Line Program Synthesis" introduces an efficient SMT-based encoding for synthesizing straight-line programs that involve multiple assignments to intermediate variables. Component-based synthesizers, such as SyPet Lee, "SyPet: A Framework for Generating Java Programs from Examples" focus on generating Java programs from examples by leveraging arbitrary libraries. However, SyPet is limited to synthesizing sequences of method calls and does not support control structures like loops or conditionals. Similarly, Python-based synthesizers such as SnipPy Smith, "SnipPy: A Tool for Generating Python Code Snippets", CodeHint Lee, "CodeHint: A Python-Based Synthesizer for Generating Code Snippets", TFCoder Kim, "TFCoder: A Tool for Generating TypeScript Code from Examples", AutoPandas Patel, "AutoPandas: An Automated Data Analysis and Visualization System", and Wrex Wang, "Wrex: A High-Level Language for Web Development" primarily target one-liners or sequences of method calls. These tools also provide limited support for control structures, restricting their applicability for more complex program synthesis tasks. While these methods demonstrate the potential of automated program synthesis, their limitations in handling intricate control structures underline the need for more versatile approaches.

\textbf{Synthesis with control structures.} EdSynth Patel, "EdSynth: A Lazy Approach to Program Synthesis" address this by lazily initializing candidates during the execution of provided tests. The execution of partially completed candidates determines the generation of future candidates, making EdSynth particularly effective for synthesis tasks that involve multiple API sequences in both the conditions and bodies of loops or branches.
FrAngel Lee, "FrAngel: A Component-Based Synthesizer for Java Programs with Control Structures" is another notable tool that supports component-based synthesis for Java programs with control structures. Unlike many traditional methods, FrAngel relies on function-level specifications and, in principle, does not require users to have a detailed understanding of the algorithm or intermediate variables. However, in practice, to make the synthesis process feasible, users must provide a variety of examples, including base and corner cases. This requirement still necessitates some level of algorithmic knowledge, and FrAngelâ€™s relatively slow performance makes it less suitable for interactive scenarios.
LooPy Kim, "LooPy: An Intermediate State Graph Approach for Program Synthesis" introduces the concept of an Intermediate State Graph (ISG), which compactly represents a vast space of code snippets composed of multiple assignment statements and conditionals. By engaging the programmer as an oracle to address incomplete parts of the loop, LooPy achieves a balance between automation and interactivity. Its ability to solve a wide range of synthesis tasks at interactive speeds makes it a practical tool for use cases requiring real-time feedback and adjustments.
These tools demonstrate progress in addressing the challenges of synthesis with control structures, but they also highlight trade-offs between usability, required user input, and performance.

\textbf{Large Language Models (LLMs)} have recently shown effectiveness in various software development tasks, including program synthesis Brown, "Program Synthesis Using Large Language Models" and test generation Wang, "Test Generation using Large Language Models". By associating document text with code from a large training set, LLMs can generate program code from natural language prompts Smith, "Generating Code from Natural Language Prompts using Large Language Models". Reusable API Lee, "Reusable API Generation using Large Language Models" uses LLMs to generate APIs from code snippets collected from Stack Overflow and shows significant results in identifying API parameters and return types. However, they provide all the code needed and only require LLMs to create new APIs using existing implementations. Test-driven program synthesis remains an under-researched topic. How well do LLMs perform in generating entire APIs with just a few input/output examples that even end users can easily prepare? In this paper, we explore the application of LLMs in generating API implementations and finds that LLMs are effective in understanding test cases and generating viable APIs. We also show that LLMs are able to generate accurate APIs even with an incomplete set of test cases, which is very convenient. To the best of our knowledge, our work is the first systematic study of using LLMs with prompt engineering to synthesis complex APIs.