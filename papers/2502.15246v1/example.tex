\definecolor{javapurple}{rgb}{0.5,0,0.35} % strings
\definecolor{linenumbergray}{rgb}{0.5,0.5,0.5}
\lstdefinestyle{Java-github}{
        basicstyle=\ttfamily\tiny,
        language=Java,
        commentstyle=\color{linenumbergray},
        stringstyle=\color{javapurple},
        keywordstyle=\color{red},
        morekeywords={@Test},
        morecomment=[s][\color{linenumbergray}]{/**}{*/},
        numbers=left,
        numberstyle=\tiny\color{linenumbergray},
        numbersep=2.5pt,
        xleftmargin=1em,
        moredelim=**[is][\color{javapurple}]{@h@}{@h@},
        morecomment=[f][{\btHL[fill=gitdel]}]-,
        morecomment=[f][{\btHL[fill=gitadd]}]+,
        breaklines = true,
        %escapeinside={(*@}{@*)}
}

\section{Motivating Examples}
\label{sec:example}
This section walks through two example APIs, illustrates the limitations of existing Component-based API Synthesis techniques, and presents a novel API Synthesis technique that requires fewer user inputs and can generates more human readable implementations.

To illustrate the limitations inherent in current component-based API synthesis techniques, we walk through two examples from FrAngel's\cite{frangel} benchmark results. FrAngel is a state-of-the-art component-based API synthesis technique. In the first example, the task is to synthesize an API \texttt{getOffsetForLine} that takes a html document(Document) and a line(Integer) as the input arguments, and outputs the start offset(Integer) at index line of the document. This example was first studied in Sypet\cite{sypet}, another state-of-the-art component-based API synthesis technique, and FrAngel re-evaluated the Sypet dataset in its paper. The second example originates from the geometry benchmark of FrAngel's evaluation set. The target API, \texttt{ellipseArea}, calculates the area of an input ellipse. Fig.~\ref{fig:figure1} shows FrAngel's implementation of the two example APIs.

\begin{figure}
    \centering
    \begin{minipage}[t]{0.47\linewidth}
	\begin{lstlisting}[style = Java-github]
static int getOffsetForLine(Document doc, int line) {
    int var1 = 0;
    line = doc.getDefaultRootElement().getElement(var1).getEndOffset();
    return line;
}
        \end{lstlisting}
        \vspace{.5in}
        \begin{lstlisting}[style = Java-github]
static double ellipseArea(Ellipse2D ellipse) {
    return Math.PI * ellipse.getWidth() * ellipse.getHeight() / 4;
}
        \end{lstlisting}
    \vspace{.75in}
    \caption{\texttt{getOffsetForLine}(above) \& \texttt{ellipseArea}(below) APIs produced by FrAngel}
    \label{fig:figure1}
    \end{minipage}
\hspace{.2in}
    \begin{minipage}[t]{0.47\linewidth}
        \begin{lstlisting}[style = Java-github]
public int getOffsetForLine(Document doc, int line) throws BadLocationException {
    // Implement the logic to find the offset for the given line number
    Element root = doc.getDefaultRootElement();
    if (line < 0 || line >= root.getElementCount()) {
        throw new BadLocationException("Invalid line number", line);
    }
    Element lineElement = root.getElement(line);
    return lineElement.getStartOffset();
}
        \end{lstlisting}
	\begin{lstlisting}[style = Java-github]
public static double ellipseArea(Ellipse2D ellipse) {
    // The width and height of the Ellipse2D object represent the full lengths of the axes
    double semiMajorAxis = ellipse.getWidth() / 2;
    double semiMinorAxis = ellipse.getHeight() / 2;
        
    // The area of an ellipse is pi * semiMajorAxis * semiMinorAxis
    return Math.PI * semiMajorAxis * semiMinorAxis;
}
        \end{lstlisting}
        \vspace{.16in}
    \caption{\texttt{getOffsetForLine} (above) \& \texttt{ellipseArea} (below) APIs produced by the proposed methodology}
    \label{fig:figure2}
    \end{minipage}
\end{figure}

\noindent\textbf{User Input Test Cases.}
FrAngel is unable to produce an accurate solution in the first example because the original Sypet task provides an inadequate number of test cases. Most component-based synthesis methodologies employ constraint-based search approaches to generate code and they often rely on a set of comprehensive test cases to eliminate ambiguities in the task. However, comprehensive test case generation is non-trivial and challenging for complex APIs that encompass a substantial number of edge cases. Thus, existing techniques often require multiple input test cases to generate a solution.

\noindent\textbf{Code Readability.}
In the second example, the implementation generated by FrAngel presents challenges for human users to comprehend effectively. Existing techniques frequently employ non-descriptive variable names and omit intermediate steps during code generation. Additionally, they lack the ability to incorporate comments that would aid human programmers in understanding the resulting implementations.

These limitations underscore the necessity of developing a more advanced solution for complex API synthesis tasks. Our proposed approach, which leverages Large Language Models to generate the implementations, effectively mitigates these challenges and demonstrates promising results in our benchmark studies. As shown in Fig.~\ref{fig:figure2}, our approach successfully generates correct and human-comprehensible solutions for the two APIs, while requiring fewer user inputs.