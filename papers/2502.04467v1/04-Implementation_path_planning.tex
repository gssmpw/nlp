% %---------------------------------------------------------------------------------------
%\section{Decision problem applying  to path and trajectory planning of thetered UAV-UGV}

In the previous section, we defined a procedure that allows us to efficiently identify the status of a collision-free catenary using a decision problem. In this section, we use this procedure \rev{to enhance the path planning method for a tethered UAV-UGV robotic configuration proposed in \cite{smartinezr2023}. } We summarize the method here for the sake of completeness.

%------------------------------------
%\subsection{RRT* algorithm using decision problems}

The goal of the path planning algorithm is to devise a safe path for the marsupial system that connects a starting position of the whole system to a goal configuration in which the UAV system has a goal position, while the rest of the system has an arbitrary, but feasible and collision-free, configuration. To this end, we use the RRT* algorithm \cite{karaman_rrt_star}.

To reduce the complexity of the approach, we only consider as decision variables the position of both platforms, omitting the variables related to the state of the tether. %, which are specified in Section \ref{sec:overview}. 
These tether parameters are then obtained by solving the corresponding PDP or CDP associated with the positions of both platforms.

The path planner in this Section does not consider any kinematic or dynamic constraints to obtain the path, leaving them for the optimization stage of the algorithm described in Section \ref{sec:optimization_process}.

% \begin{figure}[t!]
% \centering
% \includegraphics[width=0.4\textwidth]{Figures/rrt_diagram_v2.png}
% %  \includegraphics[width=0.48\textwidth]{Figures/results_rrt_2.png}
%   \caption{Basic flow diagram of our implemented RRT* algorithm. }
%   \label{fig:rrt_diagram}
% \end{figure}

The main steps of the RRT* algorithm are as follows. % in Fig. \ref{fig:rrt_diagram}. 
It creates a tree starting from the initial configuration of the marsupial system which will be expanded in a loop for a given number of iterations. In the loop, it generates a new collision-free sample in the \textit{Sampling} step, generating a random collision-free node ($x_{random}$) containing the positions of the UAV and the UGV. Then, RRT* tries to extend the tree towards the random sample, obtaining a new candidate node to be added to the tree ($x_{new}$). The new node should be \textit{validated} by solving the Decision Problem  of section \ref{sec:approach} connecting the new UAV and UGV poses. If extended, RRT* optimizes the graph by searching for the best parent node and rewiring the tree in the neighborhood of $x_{new}$. These steps lead to an asymptotically optimal solution for the path \cite{karaman_rrt_star}. We explain the main particularities of our implementation in each step below.

\subsection{Sampling}

In this step, we search for valid UGV and UAV positions. To this end, the position of the UGV is sampled at the traversable points of the 3D map with a minimum clearance \cite{driving_pc}. Similarly, the position of the UAV is sampled in the obstacle-free space of the environment, which is composed of points having a minimum clearance. We use Euclidean Distance Fields (EDF) to speed up the sampling process, storing it in a preprocessed grid, which contains the distance from each grid point to its closest obstacle in the environment \cite{edf_survey}. In this way, we can check if a point is collision-free just by checking its EDF.

%Obtaining the projection of the 3D point cloud of obstacles in the environment to a plane $\pi$ can be computationally demanding. Hence, in this paper we propose to sample the planes on the environment in a preprocessing step. This is done by slicing the 3D environment in a given number of headings (see Fig. \ref{fig:slices}). Then, whenever a PDP is to be solved, we use the closest pre-processed plane of the required heading.


%\begin{figure}[!t]
%\includegraphics[width=0.48\textwidth]{Figures/slices_1.png}
%  \includegraphics[width=0.48\textwidth]{Figures/results_rrt_2.png}
%  \caption{Slices of a 3D scenario in a given heading. The obstacles of each plane are represented in small spheres with different colors for different planes. }
%  \label{fig:slices}
%\end{figure}

%The performance of both approaches (PDP and CDP) is tested and compared in Section \ref{sec:experiments}. 


\subsection{Steer}

\label{sec:steering}

%We use the \texttt{Steering} procedure used in \cite{smartinezr2023} 
This step tries to generate a new valid node ($x_{new}$) by extending the tree from the nearest node ($x_{near}$) of the previously generated  configuration ($x_{random}$). We follow the steering function proposed in \cite{smartinezr2023}, which sequentially tries three different steering modes, keeping the new node of the first successful mode. Note that in contrast to the Sampling step, the new node should be validated before adding it to the tree. In each mode, the steering method considers movement in a subset of the agents:

\begin{enumerate}
    \item The first mode steers only the UAV position component, and the UGV position is fixed. 
    \item In the event that the first mode does not succeed, the second mode is executed. The second mode steers both the UGV and the UAV
    \item The last mode just steers the UGV and considers the UAV fixed.  
\end{enumerate}

\subsection{Validating the new node}

Whenever a candidate $x_{new}$ configuration is generated with one of the steering alternatives, we make sure that there exists a collision-free tether connecting the positions of each vehicle. To this end, a decision problem, either CDP or PDP, should be solved. 

%\textcolor{red}{The algorithm in \cite{smartinezr2023}, used the catenary model of the shape of the tether. Therefore, it solved a CDP with the numerical approach described in Section \ref{sec:approach}. }

%In this paper, we check for collisions in the catenary by sampling it and ensuring that the EDF values on the samples exceed a minimum clearance. 

In this paper, we propose to use a parabolic model of the tether to speed up the RRT* algorithm. Therefore, we solve a PDP using our iterative algorithm of Section \ref{solvingPDP}. Note that the proposed iterative algorithm uses a 2D description of the environment and obstacle clustering to accelerate the processing, while the RRT* is working in 3D. In the rest of the section, we detail our proposed procedure that conveniently projects and clusters the obstacles in the environment to a 2D plane, making use of the input EDF.

%As in the catenary formulation
%As stated before, we use the EDF to accelerate the 2D projection and clustering process. 
Once the positions of the UGV and UAV have been defined, we compute the 2D vertical plane that passes through both positions. Then, we uniformly sample the 3D EDF in the T region 
(see Fig. \ref{fig:PDP}). If the EDF at a sample point does not meet a minimum clearance, we assume that the point is an obstacle. Otherwise, it is considered as free space. We use the same resolution in this sampling procedure as the resolution of the provided EDF.

While we are generating the grid containing the obstacles in the 2D plane, we try to group them by connecting the  currently generated point with the previous obstacles in its already computed neighborhood, if any. This method is fast, can be performed just by analyzing the direct neighbors of each sample, but might divide concave obstacles into several clusters depending on their shapes. As an example, Figure \ref{fig:clustering} represents a projection that has been properly clustered into three main obstacles (red, green, and blue). However, the clustering algorithm fails to merge the remaining obstacles in pink, purple, and yellow, to name a few. Therefore, the computation of the PDP will increase slightly due to a larger number of clusters. In spite of it, results of Section \ref{sec:experiments} show that this increase is marginal and that PDP remains the fastest method to solve the problem. 

\rev{Once we have obtained the different clusters as point clouds, we get the convex hull of each cluster, resulting in the input polygons of Algorithm \ref{alg:decision_problem}.}




 %Finally, if no $x_{new}$ node is found, we go back to the sampling procedure. In contrast, $x_{new}$ is first connected to the best possible neighbor, and then the tree is rewired to ensure asymptotical optimality.



\begin{figure}[!t]
  \includegraphics[width=0.48\textwidth]{Figures/2d_projection.png}
  \caption{Example of a 2D projection, in which each cluster is represented with a set of big dots in a different color. The projection is obtained from a 3D Point Cloud, represented in fine-grained dots with colors from red to green depending on its $z$ coordinate. Figure obtained with RViz \cite{rviz}. }
  \label{fig:clustering}
\end{figure}
