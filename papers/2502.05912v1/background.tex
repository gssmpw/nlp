\section{Background}
\label{sec:background}

\paragraph{Relations}
We write $\attrs(R)$ for the set of attributes of a relation $R$.  The domain of attributes $U \subseteq \attrs(R)$  is $\dom(R.U) \defeq \Pi_U(R)$.

\paragraph{Queries}
\system supports single-block SQL queries:
%
\begin{align*}
  & \texttt{SELECT } \text{[groupby-attrs]}\\
  & \texttt{FROM } R_1, R_2, \ldots, R_m \\
  & \texttt{WHERE } \text{[join-and-selection-predicates]}\\
  & \texttt{GROUP BY }\text{[groupby-attrs]}
\end{align*}
%
We ignore aggregates in \texttt{SELECT} because they do not affect the output cardinality.
We do not support sub-queries.  The predicates can be equality, range, and their conjunction and disjunction; 
\texttt{IN} and \texttt{LIKE} predicates can be supported with trivial
effort (see Sec.~\ref{sec:histograms}).
\nop{
For example:
%
\newline $\texttt{City IN ('Pittsburg','Edinburg') OR City LIKE '\%burgh\%'}$
}
%
\revone{Queries with bag semantics are also supported, by replacing
  them with a full query.  For
  example, the output of $\texttt{SELECT A FROM }\ldots$
  (without \texttt{GROUP BY}) is a bag that has the same size as
  the output of $\texttt{SELECT * FROM }\ldots$, which is a set.
  Throughout the paper we will assume that queries have set semantics.}
%
We will use the conjunctive query notation instead of SQL:
%
\begin{align}
  Q(V_0) = & R_1(V_1) \wedge R_2(V_2) \wedge \cdots \wedge R_m(V_m)\wedge\text{[predicates]} \label{eq:cq}
\end{align}
%
where each $V_j\defeq \attrs(R_j)$ is a set of variables, and
$V_0 \subseteq V_1 \cup \cdots \cup V_m$ represents the \groupby
variables.  We denote by
$\vars(Q) \defeq V_1 \cup \cdots \cup V_m = \set{X_1, \ldots, X_n}$
the set of all variables in the query.  When $V_0=\set{X_1, \ldots, X_n}$, 
then we say that $Q$ is a \emph{full} conjunctive
query.  $Q$ is \emph{acyclic} if its relations $R_1, \ldots, R_m$ can
be placed on the nodes of a tree, such that, for every individual
variable $X_i$, the set of tree nodes that contain $X_i$ forms a
connected component.  $Q$ is called \emph{Berge-acyclic} if it is
acyclic and any two relations share at most one variable.  For
example, the 3-way join query $J_3$ is Berge-acyclic, while the
3-clique query $C_3$ is cyclic:
%
\begin{align}
  J_3(X,Y,Z,U) = & R(X,Y) \wedge S(Y,Z) \wedge T(Z, U) \label{eq:j3}\\
  C_3(X,Y,Z)   = & R(X,Y) \wedge S(Y,Z) \wedge T(Z,X) \label{eq:c3}
\end{align}
%

\paragraph{Degree Sequences}
Fix a relation instance $R$, and two
sets of variables $X, Y \subseteq \attrs(R)$.  The \emph{degree
  sequence} from $X$ to $Y$ in $R$ is the sequence
$\degree_R(Y|X) \defeq (d_1, d_2, \ldots, d_N)$ obtained as follows.
Compute the domain of $X$, $\dom(R.X)=\set{x_1, \ldots, x_N}$, denote
by $d_i = |\sigma_{X=x_i}(\Pi_{XY}(R))|$ the degree (or frequency) of
$x_i$, and sort the values in the domain $\dom(R.X)$ such that their
degrees are decreasing $d_1 \geq d_2 \geq \cdots \geq d_N$.  We call
$i$ the \emph{rank} of the element $x_i$.  Notice that
$\degree_R(Y|X)$ and $\degree_R(XY|X)$ are the same, where $XY$
denotes the union $X \cup Y$.  When $X=\emptyset$, then the degree
sequence has length 1, $\degree_R(Y|\emptyset)=(|\dom(R.Y)|)$.  When
the functional dependency $X \rightarrow Y$ holds (for example, if $X$
is a key), then $\degree_R(Y|X)=(1,1,\ldots,1)$.  When $|X|\leq 1$, then
we say that the degree sequence is \emph{simple}, and when
$XY =\attrs(R)$, then we say that the degree sequence is \emph{full}
and denote it by $\degree_R(*|X)$, or just $\degree_R(X)$ (we used
this notation in Fig.~\ref{fig:ds}).  In this paper we will consider
only simple degree sequences.
%
\revone{The degree sequence also
  applies to the case when $R$ is a bag, not necessarily a set.}
%
% : see the brief discussion in Sec.~\ref{sec:conclusions}.
%
The $\ell_p$-norm of a sequence $\bm d = (d_1, d_2, \ldots)$ is
$\lp{\bm d}_p \defeq \left(\sum_i d_i^p\right)^{1/p}$, where
$p \in \openclosed{0,\infty}$.  When $p$ increases towards $\infty$,
$\lp{\bm d}_p$ decreases and converges to
$\lp{\bm d}_\infty \defeq \max_i d_i$, see Fig.~\ref{fig:lp}.

Fig.~\ref{fig:degree} illustrates some simple examples of degree
sequences: $\degree_R(YZ|X)$ is both simple and full, and we can write
it as $\degree_R(*|X)$ or just $\degree_R(X)$. The degree sequence
$\degree_R(Z|XY)$ is not simple.

\begin{figure}
  \centering
    \begin{align*}
      R=&\begin{array}[c]{|c|c|c|} \hline X&Y&Z \\ \hline
         1&a&\ldots \\
         1&b&\ldots \\
         1&b&\ldots \\
         2&a&\ldots \\
         2&b&\ldots \\
         3&b&\ldots \\
         3&c&\ldots \\
         4&d&\ldots \\ \hline
    \end{array}
&&
   \begin{array}[c]{ll}
     \degree_R(YZ|X)&=(3,2,2,1)\\
     \degree_R(Y|X) &= (2,2,2,1)\\
     \degree_R(Z|XY)&=(2,1,1,1,1,1,1)\\
     \degree_R(XYZ|\emptyset)&=(8)=(|R|)
   \end{array}
    \end{align*}
    \caption{Examples of Degree Sequences.}
  \label{fig:degree}
\end{figure}


\paragraph{Density-based \ce}
The traditional, density-based cardinality estimator~\cite{DBLP:books/daglib/0020812} is
limited to selections and joins.  It makes the assumptions mentioned
in the introduction and computes the estimate bottom-up on the query
plan, for example:
%
\begin{align*}
  \est(\sigma_{X=\text{value}}(R)) = & \frac{|R|}{|\dom(R.X)|} \\
  \est(R \Join_{X=Y} S) = & \frac{|R|\cdot|S|}{\max(|\dom(R.X)|,|\dom(S.Y)|)}
\end{align*}
%
The ratio $\frac{|R|}{|\dom(R.X)|}$ is the average degree,
$\texttt{Avg}(\degree_R(*|X))$.

Queries with \groupby are treated differently by different systems.
We describe briefly how they are handled by two open-source systems,
illustrating on the following \groupby query:
%
\begin{align}
    JG_3(X,U) = & R(X,Y) \wedge S(Y,Z) \wedge T(Z, U) \label{eq:jg3}
\end{align}
%
\duckdb ignores the \groupby clause, and estimates the size of $JG_3$
to be the same as that of the full join $J_3$ (Eq.~\eqref{eq:j3}).
\psql estimates it as the minimum between the full join, and the
product of the domains of the \groupby variables,
$|\dom(R.X)|\cdot |\dom(T.U)|$.


\paragraph{Theoretical Upper Bounds}
An \emph{upper bound} for a
conjunctive query $Q$ is a numerical value, which is computed in terms
of statistics on the input database,  such as the output size of the query is
is guaranteed to be below that bound.  The upper bound is \emph{tight}
if there exists a database instance, satisfying the statistics, such
that the query's output is as large as the bound.\footnote{Up to some
  small, query-dependent constant.}  The AGM
bound~\cite{DBLP:journals/siamcomp/AtseriasGM13} is a tight upper that
uses only the cardinalities $|R_1|, \ldots, |R_m|$; in other words, it
uses only the $\ell_1$-norms of full degree sequences.  A non-negative
sequence $w_1, \ldots, w_m$ is called a \emph{fractional edge cover}
of the query $Q$ in Eq.~\eqref{eq:cq} if every variable $X_i$ is
``covered'', meaning that $\sum_{j\in[m]: X_i \in V_j}w_j \geq 1$.  The AGM
bound states that
$|Q| \leq |R_1|^{w_1}\cdot|R_2|^{w_2}\cdots|R_m|^{w_m}$ for any
fractional edge cover.  It is useful for cyclic
queries like $C_3$ above (see Sec.~\ref{subsec:lpbound:full}), but for
acyclic queries it degenerates to a product of cardinalities, because
the optimal edge cover is integral.  For example, the AGM bound of the
3-way join in Eq.~\eqref{eq:j3} is $|J_3| \leq |R|\cdot |T|$, because
the optimal fractional edge cover is\footnote{Every fractional edge
  cover must satisfy $w_R\geq 1$ in order to cover $X$, and
  $w_T \geq 1$ to cover $U$; then $w_S$ can be arbitrary.  Therefore,
  $|R|^{w_R}|S|^{w_S}|T|^{w_T}\geq |R|\cdot|T|$.}
$w_R=1, w_S=0, w_T=1$.

The \maxdegree bound introduced in~\cite{DBLP:conf/pods/Khamis0S17}
generalizes the AGM bound by using both cardinalities and maximum
degrees; in other words, it uses both $\ell_1$ and $\ell_\infty$ norms
of degree sequences.  When restricted to acyclic queries, the
\maxdegree bound represents an improvement over the AGM, but it is
still less accurate than a density-based estimate.
%
%In particular,
%it can take into account functional dependencies, because they
%correspond to a maximum degree $=1$.  When applied to an acyclic
%query, the degree bound can be described as
%follows~\cite{DBLP:journals/pvldb/ChenHWSS22}.  Define the following
%cardinality estimation graph, $CEG$.  Its nodes are all subsets of
%variables, $U \subseteq \set{X_1, \ldots, X_n}$.  For every set $U$
%and every relation $R_j(V_j)$, there is an edge from $U$ to $U_j$
%labeled with the cardinality $|R|$; and for every known maximum degree
%sequence $d = \lp{\degree_{R_j}(W|V)}_\infty$ and every set
%$U \supseteq V$ there is an edge from $U$ to $U \cup W$ labeled $d$.
%Then the degree bound is the shortest path in the graph from
%$\emptyset$ to $\set{X_1, \ldots, X_n}$, where the ``length'' of the
%path is defined as the product of it labels.
%
For example, the bound for $J_3$ is the minimum of the following four
quantities (see also~\cite{DBLP:journals/pvldb/ChenHWSS22}):
%
\begin{align}
  |J_3|\leq & |R|\cdot |T| \nonumber \\
  |J_3|\leq & |R| \cdot \lp{\degree_S(Z|Y)}_\infty \cdot\lp{\degree_T(U|Z)}_\infty\label{eq:degree:bound:j3}\\
  |J_3|\leq & |S|\cdot \lp{\degree_R(X|Y)}_\infty \cdot  \lp{\degree_T(U|Z)}_\infty \nonumber \\
  |J_3| \leq &|T|\cdot \lp{\degree_S(Y|Z)}_\infty \cdot \lp{\degree_R(X|Y)}_\infty \nonumber 
\end{align}
%
For comparison, the traditional, density-based estimator for $J_3$ is:
%
{
\begin{align*}
  \est(J_3)=&\frac{|R|\cdot|S|\cdot|T|}{\max(|\dom(R.Y)|,|\dom(S.Y)|)\cdot\max(|\dom(S.Z)|,|\dom(T.Z)|)}
\end{align*}
}

When $|\dom(R.Y)|\leq |\dom(S.Y)|$ and $|\dom(S.Z)|\leq |\dom(T.Z)|$
then the estimator becomes
$|R|\cdot
\texttt{Avg}(\degree_S(Z|Y))\cdot\texttt{Avg}(\degree_T(U|Z))$, which
is the same as the \maxdegree bound in Eq.~\eqref{eq:degree:bound:j3}
with the maximum degree replaced by the average degree.

\safebound~\cite{DBLP:conf/icdt/DeedsSBC23,SafeBound:SIGMOD23}
uses simple, full degree sequences and computes a tight upper bound of
a Berge-acyclic, full conjunctive query.  For example, if
$\degree_R(*|X)=(a_1\geq a_2 \geq \cdots)$ and
$\degree_S(*|Y)=(b_1\geq b_2 \geq \cdots)$, then \safebound will infer
the following bound on a 2-way join:
$|R \Join_{X=Y} S| \leq \sum_i a_ib_i$.  When applied to the 3-way
join $J_3$ \safebound returns a much better bound than the degree
bound~\eqref{eq:degree:bound:j3}, but that bound is not described by a
closed-form formula; it is only given by an algorithm.  The
limitations of \safebound are its lack of explainability, its
restriction to Berge-acyclic queries, and its reliance on 
compression heuristics for the degree sequences.

\paragraph{Information Theory} Let $X$ be a finite random
variable, with outcomes $x_1, \ldots, x_N$, and probability function
$\pr$.  Its \emph{entropy} is:
%
\begin{align*}
  h(X) \defeq & - \sum_{i=1,N} \pr(x_i) \log \pr(x_i)
\end{align*}
%
where $\log$ is in base 2.  It holds that $0 \leq h(X) \leq \log N$,
and $h(X)=\log N$ iff $\pr$ is uniform, i.e.,
$\pr(x_1)=\cdots=\pr(x_N)=1/N$.

Let $X_1,\ldots, X_n$ be $n$ finite, jointly distributed random
variables.  They can be described by a finite relation
$R(X_1, \ldots, X_n)$, representing their support, and a probability
function s.t. for each tuple $t \in R$, $\pr(t)\geq 0$ and
$\sum_{t \in R}\pr(t)=1$.  For every subset $U$ of variables, $h(U)$
denotes the entropy of the marginal distribution of the random variables
in $U$.  For example, we have $h(X_1X_3)$, $h(X_2X_4X_5)$, etc.  This
defines a vector $h$ with $2^n$ dimensions, which is called an
\emph{entropic vector}.  The \emph{conditional entropy} is defined as
%
\begin{align}
  h(V|U) \defeq & h(UV) - h(U) \label{eq:chain}
\end{align}
%
The following hold for all subsets of variables
$U, V \subseteq \attrs(R)$:
%
\begin{align}
  h(V) \leq & \log|\dom(R.V)| & h(V|U) \leq & \log\lp{\degree_R(V|U)}_\infty \label{eq:h:log}
\end{align}
%
Every entropic vector $\bm h$ satisfies the \emph{basic Shannon
  inequalities}:
%
\begin{align}
&&  h(\emptyset) =&\ 0\nonumber\\
&\text{Monotonicity:}&  h(U\cup V) \geq &\  h(U)\label{eq:shannon:monotonicity}\\
&\text{Submodularity:}&  h(U)+h(V)\geq &\  h(U\cup V)+h(U\cap V)\label{eq:shannon:submodularity}
\end{align}
%
Every vector $\bm h$ that satisfies the basic Shannon inequalities is
called a \emph{polymatroid}.  Every entropic vector is a polymatroid,
but the converse is not
true~\cite{zhang1998characterization,Yeung:2008:ITN:1457455}.
%
%\begin{align*}
%  h(U\cup V) \geq &\  h(U) &&\text{Monotonicity}\\
%  h(U)+h(V)\geq &\  h(U\cup V)+h(U\cap V) && \text{Submodularity}
%\end{align*}
