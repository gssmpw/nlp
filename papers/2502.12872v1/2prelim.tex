\subsection{Automata}
We use $\mathbb{N}$ to denote the set of natural numbers $\{0,1,2,\dots\}$. For two natural numbers $i,j$ with $i<j$, we shall use $[i,j]$ to denote the set $\{i,i+1,\dots,j\}$, consisting of natural numbers that are at least $i$ and at most $j$. For a natural number $i$,  we use $[i]$ to denote the set $[0,i]$. 
We use $\unitinterval$ to denote the unit interval, i.e., $\unitinterval = \{x \mid 0 \leq x \leq 1\}.$
For a finite set $X$, a probability distribution on $X$ is a function $f:X\xrightarrow{}\unitinterval$ that maps each element in $X$ to a number in $\unitinterval$, such that $\sum_{a\in X} f(X) = 1$. We denote the set of probability distributions on $X$ by $\Distribution(X)$. 

\paragraph*{Parity automata}
An $[i,j]$-\emph{nondeterministic parity automaton} $\Ac = (Q,\Sigma,\Delta,q_0)$, $[i,j]$-parity automaton for short, consists of a finite directed graph with edges labelled by letters in $\Sigma$ and \emph{priorities} in $[i,j]$ for some $i,j \in \mathbb{N}$ with $i\leq j$. 
The set of \emph{states} $Q$ constitutes the vertices of this graph, and the set of \emph{transitions} $\Delta \subseteq Q \times \Sigma \times [i,j] \times Q$ represents the labelled edges of the graph. 
%These edges are called \emph{transitions}, which are represented by elements of the set $\Delta \subseteq Q \times \Sigma \times [i,j] \times Q$, and the vertices of this graph are called \emph{states},  which are elements of the set $Q$. 
Each automaton has a designated \emph{initial state} $q_0 \in Q$. 
For states $p,q \in Q$ and a letter $a \in \Sigma$, we use $p\xrightarrow{a:c}q$ to denote a transition from $p$ to $q$ on the letter $a$ that has the priority $c$. We assume our automata to be \emph{complete}, i.e., for each state and letter, there is a transition from that state on that letter.

A \emph{run} on an infinite word $w$ in $\Sigma^{\omega}$ is an infinite path in the automaton, starting at the initial state and following transitions that correspond to the letters of $w$ in sequence.  We say that such a run is \emph{accepting} if the highest priority occurring infinitely often amongst the transitions of that run is even, and a word $w$ in $\Sigma^{\omega}$ is accepting if the automaton has an accepting run on $w$. The \emph{language} of an automaton $\Ac$, denoted by $\Lc(\Ac)$, is the set of words that it accepts. We say that the automaton $\Ac$ \emph{recognises} a language $L$ if $\Lc(\Ac)=L$. A parity automaton $\Ac$ is said to be \emph{deterministic} if for any given state in $\Ac$ and any given letter in $\Sigma$, there is exactly one transition from the given state on the given letter. 



We will say that $[i,j]$ with $i=0$ or $1$ is the parity index of $\Ac$. A \emph{B\"uchi} (resp. co-B\"uchi) automaton is a $[1,2]$ (resp. $[0,1]$) parity automaton. A \emph{safety automaton} is a B\"uchi automaton where all  transitions with parity $1$ occur as self-loops on a sink state. Dually, a \emph{reachability automaton} is a B\"uchi automaton $\Ac$ such that all transitions with parity $2$ in $\Ac$ occur as self-loops on a sink state. A \emph{weak automaton} is a B\"uchi automaton, in which there is no cycle that contains both an accepting and a rejecting transition.

We write $(\Ac,q)$ to denote the automaton $\Ac$ with $q$ instead as its initial state, and $\Lc(\Ac,q)$ to denote the language it recognises. We say two states $p$ and $q$ in $\Ac$ are language-equivalent if $\Lc(\Ac,p) = \Lc(\Ac,q)$.

\paragraph*{Probabilistic automata}
A probabilistic parity automaton $\Pc = (Q,\Sigma,\Delta,\rho,q_0)$---a natural extension of probabilistic B\"uchi automata defined by Baier, Gr\"o\ss er, and Bertrand~\cite{BGB12}---has the semantics of a parity automaton. Additionally, we assign a probability to each transition in $\Delta$ using the function $\rho: \Delta \xrightarrow{} \unitinterval$, such that for each state and each letter, the sum of $\rho(\delta)$s for outgoing transitions $\delta$ from that state on that letter add up to 1. We write $\Delta_{q,a}$ to denote the set of outgoing transitions from  the state $q$ on the letter~$a$.

Given a probabilistic automaton $\Pc$ as above, the behaviour of $\Pc$ on an input word $w$ is as follows: each transition $\delta$ from a given state on a given letter can be taken with probability $\mu(\delta)$. We formalise this by an infinite Markov chain that captures all the possible runs of $\Pc$ on $w$. For the word $w=a_0 a_1 a_2 \dots$, consider the Markov chain $M_w$ defined over the vertices $Q \times \mathbb{N}$. After `processing' the finite word $a_0 a_1 \dots a_{i-1}$, the Markov chain will be at some state $(q,i)$, where $q$ is a state that can be reached from $q_0$ on the word $a_0 a_1 \dots a_{i-1}$, and a run of the Markov chain moves from $(q,i)$ to the state $(p,i+1)$ with probability $\rho(\delta)$, where $\delta=q\xrightarrow{a_i:c_i}p$ is a transition in $\Ac$. The initial state of $M_w$ is $(q_0,a_0)$, and  we say that a run in $M_w$ is accepting if the corresponding run for $\rho$ in $\Ac$ is accepting.

For an input word $w$ and a probabilistic automaton $\Pc$, we define the probability $\prob_\Pc(w)$ to be the probability measure of accepting runs in $M_w$.  We mostly deal with almost-sure semantics of probabilistic automata, and therefore, we refer to language of a probabilistic automaton $\Pc$ as $\Lc(\Pc) = \{w\in \Sigma^\omega\mid \prob_\Pc(w) = 1\}$.

If the priorities occurring in a probabilistic parity automaton are from the set $[1,2]$ (resp.\ $[0,1]$), we call it a probabilistic B\"uchi (resp. coB\"uchi) automaton. 

%A probabilistic finite automaton $\Pc= (Q,\Sigma,q_0,\Delta,\rho, F)$, introduced by Rabin~\cite{Rab63} on the other hand contains a finite set of states, and a finite alphabet, a start state $q_0$, however, its transition relation $\Delta\subseteq Q\times \Sigma\times Q$. Further, the probability function $\rho$ is also defined similarly a  function from $\Delta$ to real values in $[0,1]$ such that for each state $q$ and letter $a$, $\sum_{(q,a,q')\in \Delta}\rho(q,a,q') = 1$. The set $F$ represent the set of final states.

%A probabilistic finite automaton, unlike a probabilistic parity automaton, deals with finite words, i.e., words in $\Sigma^*$. For a word $w\in \Sigma^*$, a run of the probabilistic automaton $\Pc$ is accepting if the last state of the run ends at a state in $F$. 
%We also define for a given word $w$, we define $\prob_\Pc(w)$ to be the probability that a run of $\Pc$ on $w$ is accepting.
% \apbutlong{To appendix.}


\subsection{Resolution of nondeterminism}
We will deal with nondeterministic automata where the nondeterminism can be resolved using a combination of memory and randomness. Let us start by recalling the classical definition of history-determinism, which is characterised by the following history-determinism game.

\begin{definition}[History-determinism game]\label{defn:hd-game}
Given a nondeterministic parity automaton $\Ac = (Q,\Sigma, \Delta, q_0)$, the \emph{history-determinism (HD) game} on $\Ac$ is a two-player game between Eve and Adam that starts with Eve's token at $q_0$ and proceeds for infinitely many rounds. 
For each $i \in \mathbb{N}$, round $i$ starts with Eve's token at a state $q_i$ in $Q$, and proceeds as follows.
\begin{enumerate}
    \item Adam selects a letter $a_i \in \Sigma$;
    \item Eve selects a transition $q_i \xrightarrow{a_i:c_i} q_{i+1} \in \Delta$ along which she moves her token. Eve's token then is at $q_{i+1}$ from where the round $(i+1)$ is played. 
\end{enumerate} 
Thus, in the limit of a play of the HD game, Adam constructs a word letter-by-letter, and Eve constructs a run on her token transition-by-transition on that word. Eve wins such a play if the following condition holds: if Adam's word  is in $\Lc(\Ac)$, then the run on Eve's token is accepting.
\end{definition}
We say that an automaton is history deterministic (HD) if Eve has a winning strategy in the HD game on $\Ac$. History-determinism games are finite-memory determined~\cite[Theorem 3.12]{Pra25} and therefore, if an automaton $\Ac$ is HD then Eve has a finite memory winning strategy, that is, a mapping from the set of finite plays of the HD game to the next transition that Eve chooses, where the mapping is only based on the current position and a finite memory structure. We will formalise this concept by \emph{pure resolvers}. We first define the concept of resolvers where we allow for randomness as well.     

\paragraph*{Resolver}
For a nondeterministic parity automaton $\Ac=(Q,\Sigma,\Delta,q_0)$, a \emph{stochastic resolver}, or just \emph{resolver}, for $\Ac$ is given by $\Mc=(M,m_0,\mu,\nextmove)$, where $M$ is a finite set of \emph{memory states}, $m_0$ is the initial memory state. The function $\nextmove$ assigns to every three-tuple of memory state $m$, state $q$ of $\Ac$, and letter $a$ in $\Sigma$, a probability distribution $\nextmove(m,q,a)$ in $\Distribution(\Delta_{q,a})$, where $\Delta_{q,a}$ is the set of outgoing transitions from state $q$ on letter $a$. The function $\mu$ is the transition function and is given by $\mu:M\times \Delta \to M$.

Eve using a resolver $\Mc$, plays in the HD game on $\Ac$ as follows. At state $q$, when the memory state is $m$, suppose Adam chooses the letter $a$. Eve then selects an outgoing transition $\delta$ from $q$ on $a$ with the probability $(\nextmove(m,q,a)) \circ (\delta)$, and updates  to be $m'=\mu(m,\delta)$. 

We say that a resolver $\Mc$ for Eve constitutes a winning strategy in the HD game on $\Ac$ if she wins almost-surely when she plays using $\Mc$ as described above. We say that a resolver $\Mc$ is \emph{pure}, if for each memory state $m$, each state $q$, and letter $a$, the probability distribution $\nextmove(m,q,a)$ assigns probability $1$ to some outgoing transition in $\Delta_{q,a}$ and probability 0 to every other transition in $\Delta_{q,a}$. 

In $\omega$-regular games, which HD games are a subclass of, Eve has a winning strategy if and only if she has a pure winning strategy. Thus, if Eve has a stochastic resolver that is a winning strategy in the HD game on $\Ac$, then she also has a pure resolver. 
We say that a resolver is \emph{memoryless} if that resolver has one state. 
%\begin{mydef*}{Memoryless adversarially resolvable automata}
%    An automaton $\Ac$ is \emph{memoryless-adversarial resolvable} (MA)  if there is a memoryless resolver for $\Ac$ using which Eve wins the HD game on~$\Ac$.
%\end{mydef*}

\begin{tcolorbox}
    An automaton $\Ac$ is \emph{memoryless-adversarial resolvable} (MA)  if there is a memoryless resolver for $\Ac$ using which Eve wins the HD game on~$\Ac$ almost-surely, i.e., with probability $1$.
\end{tcolorbox}


If there is a memoryless resolver $\Mc$ for Eve using which she wins the HD game with probability $1$, then any memoryless resolver $\Mc'$ that assigns nonzero probabilities to the same transitions as $\Mc$ can also be used by Eve to win the HD game on~$\Ac$ (\cref{lemma:indifferent2probabilities} in the appendix).

\paragraph*{Nonadversarial resolvability}
So far, we have discussed resolution of nondeterminism in automata where the letters are chosen adversarially. We next introduce the notions of nondeterminism where this is relaxed. For a parity automaton $\Ac$ and a resolver $\Mc$ for $\Ac$, we say that $\Mc$ is a \emph{almost-sure resolver} 
for $\Ac$ if for each word $w$, the run constructed on $w$ using $\Mc$ in the HD game on $\Ac$ is almost-surely accepting. 

More concretely, consider the probabilistic automaton $\Pc=\Mc\circ\Ac$ that is obtained by \emph{composing} the resolver $\Mc$ with~$\Ac$. That is, the states of $\Pc$ are $Q \times M$, the initial state of $\Pc$ is~$p_0=(q_0,m_0)$. The automaton $\Pc$ has the transition $(q,m)\xrightarrow{a:c}(q',m')$ of probability $p$ if $\delta=q\xrightarrow{a:c}q'$ is a transition in $\Ac$, $(\nextmove(m,q,a))\circ \delta = p$ and $m'=\mu(m,\delta)$. Then, we say that $\Mc$ is an \emph{almost-sure resolver} for $\Ac$  if $\Lc(\Ac)=\Lc(\Pc)$. For $\Mc$, $\Ac$, and $\Pc$ as above, we call $\Pc$ the \emph{resolver-product} of $\Mc$ and $\Ac$.   

\begin{tcolorbox}
   An automaton $\Ac$ is \emph{stochastically resolvable} (SR) if there is an almost-sure resolver for~$\Ac$.
\end{tcolorbox}
%\paragraph*{Stochastically resolvable automata} We say that $\Ac$ is stochastically resolvable, SR for short, if there is an almost-sure resolver for~$\Ac$.
\begin{tcolorbox}
   An automaton $\Ac$ is \emph{memoryless stochastically resolvable} (MR) if there is an almost-sure resolver for~$\Ac$ that is memoryless.  
\end{tcolorbox}

%\paragraph*{Memoryless stochastically resolvable automata} We say that 




\begin{example}\label{example:reachSRbutnotHD}
Consider the example of the reachability automaton $\Ac$ in \cref{fig:ReachSRbutnotHD}, where the accepting transitions are double-arrowed. We will show that $\Ac$ is MR but not HD. This automaton accepts all infinite words over the alphabet $\{a,b\}$. The only nondeterminism is at the initial state $q_0$.  At the state $q_0$ on reading $a$ or $b$,  if the resolver correctly guesses the next letter, then it will reach the accepting state. Consider a resolver that chooses the transitions to $q_a$ and $q_b$ with $\frac{1}{2}$ probability. Then for any fixed infinite word, this resolver produces an accepting run that will eventually, almost surely,  correctly guess the letter one step ahead.

However, in the HD game on $\Ac$, Adam can always adversarially choose the letter based on the resolution of the run. That is, whenever Eve in the HD game is at $q_b$, Adam chooses the letter $a$ and chooses the letter $b$ whenever Eve is at $q_a$. This adversarial choice of letters ensures that Eve's run is rejecting, and thus Adam wins the HD game on $\Ac$.
\end{example}
We give an equivalent definition for SR and MR automata based on the \emph{stochastic-resolvability} game, or the SR game for brevity. 
\paragraph*{Stochastic resolvability game} The SR game on an automaton $\Ac$ proceeds similarly to the HD game. In each round, Adam selects a letter and then Eve responds with a transition of $\Ac$ on that letter; thus, in the limit, Adam constructs an infinite word and Eve constructs a run on that word. 
Eve wins if her transitions form an accepting run whenever Adam's word is in the language. However, unlike the HD game, Adam does not observe Eve's run, and therefore his strategy must not depend on the position of Eve's token in the automaton. We define this game more formally and prove the following related result in the appendix.

\begin{restatable}{lemma}{randomispure}\label{lemma:random-is-pure}
For every parity automaton $\Ac$, a resolver $\Mc$ is an almost-sure resolver for $\Ac$ if and only if $\Mc$ is a finite-memory strategy that is almost-surely winning for Eve against all strategies of Adam in the SR game on $\Ac$.
\end{restatable}

