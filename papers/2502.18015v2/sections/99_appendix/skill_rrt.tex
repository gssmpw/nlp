\newcommand{\gpuskillrrt}{\texttt{Skill-RRT-Batch}}

This section provides the \texttt{UnifSmplSkillAndSubgoal}, \texttt{GetApplicableNearestNode}, and \texttt{Failed} algorithms used in \texttt{Skill-RRT} algorithm. Then, we describe \gpuskillrrt, an extended \texttt{Skill-RRT} algorithm that extends nodes in parallel to accelerate planning and data collection times using GPU-based simulation, specifically Isaac Gym \cite{makoviychuk2021isaac}. Note that we use \gpuskillrrt~instead of the vanilla \texttt{Skill-RRT} throughout our experiments.

Across the algorithms, the distance function \( d_{SE(3)} \), which is used to determine the success of NP and P skills, is used in the same way.
% the distance function between two object poses $q^1_\text{obj}, q^2_\text{obj}$ is defined as $d_{SE(3)}(q^1_\text{obj}, q^2_\text{obj})=\Delta T(q^1_\text{obj}, q^2_\text{obj})+\alpha \Delta\theta(q^1_\text{obj}, q^2_\text{obj})$, where $\Delta T$ is the positional difference, $\Delta\theta$ is the orientational difference, and $\alpha$ is a weight term for the orientation difference. The weight term $\alpha$ is set to 0.1.

\input{algos/skill-RRT/sampleskillandsubgoal}

Algorithm \ref{algo:UnifSmplSkillAndSubgoal} provides the pseudocode for the \texttt{UnifSmplSkillAndSubgoal} function. This function takes as input the set of skills $\mathcal{K}$, and the object regions $Q_\text{obj}$. It outputs a uniformly sampled skill $K$ and the desired object pose for the skill, $q_\text{obj}$. The algorithm begins by uniformly sampling a skill $K$ from the set of skills $\mathcal{K}$ (L1). Then, the desired object pose $q_\text{obj}$ is set to the goal object pose $q^g_\text{obj}$ with a goal sampling probability $p_g$ (L2–4), or it is uniformly sampled from the object regions $Q_\text{obj}$ otherwise (L5–6). Finally, the algorithm returns the sampled skill $K$ and the desired object pose for the skill $q_\text{obj}$.

\input{algos/skill-RRT/nearest}

Algorithm \ref{algo:GetFeasibleNearestNode} provides the pseudocode for the \texttt{GetApplicableNearestNode} function. It takes in the tree $T$, the skill $K$ for which feasibility is to be checked, and the desired object pose for the skill, $q_{\text{obj}}$. If the skill $K$ is a non-prehensile skill, we compute all feasible nodes for the given skill and desired object pose in the tree using the feasibility checker $K.\phi(s, q_{\text{obj}})$. We then find the nearest node, $v_{\text{near}}$, to the desired object pose $q_{\text{obj}}$ among the feasible nodes using the distance function $d_{SE(3)}$, and return $v_{\text{near}}$ (L1-3). If the skill $K$ is a prehensile skill, we first compute the closest node, $v_{\text{close}}$, to the desired object pose $q_{\text{obj}}$ in the tree (L5). If the closest node $v_{\text{close}}$ passes the feasibility check using the feasibility checker for the prehensile skill, $v_{\text{near}}$ is set to $v_{\text{close}}$ (L6-7). Otherwise, $v_{\text{near}}$ is set to the empty set (L8-9). The different order of finding the nearest node and performing the feasibility check for prehensile skills is due to the computational expense of the feasibility checker of the prehensile skill, as it involves collision checking.

\input{algos/skill-RRT/failed}

Algorithm \ref{algo:Failed} checks whether a skill fails given the state $s$ and the desired object pose $q_{\text{obj}}$. If the distance between the object pose in the state $s.q_{\text{obj}}$ and the desired object pose $q_{\text{obj}}$ is less than the predefined threshold $\delta_{\text{obj}}$, the algorithm returns false. Otherwise, it returns true.

\input{algos/skill-RRT/GPU_skill_rrt}

We now describe \gpuskillrrt~in Algorithm \ref{algo:gpuskillrrtbackbone}, a parallelized version of the original \texttt{Skill-RRT}. The inputs and outputs are the same as those of the original \texttt{Skill-RRT}. The main differences in \gpuskillrrt~are: 1) uniformly sampling skills and desired object poses in batches using the \texttt{UnifSmplSkillAndSubgoalBatch} function (L5); 2) finding the feasible and nearest node $\mathbf{v}_\text{near}$ using the \texttt{GetApplicableNearestNodeBatch} function (L6); and 3) extending nodes in parallel with GPU-based simulation via the \texttt{ExtendBatch} function. Bold letters indicate a batch of components. We do not rewrite the batched versions of the functions because single components (normal letters) are simply replaced by batches of components (bold letters).

% Batch extend
% Get connector

% \input{algos/skill-RRT/extend_abstract}

% \input{algos/skill-RRT/extend}
