\begin{algorithm}[H]
\caption{\texttt{Skill-RRT}}\label{algo:skill-rrt}
\begin{algorithmic}[1]
\State \textbf{Input:} initial config $(q^{\text{obj}}_0$, $q^{\text{robot}}_0)$, goal config $q^{\text{obj}}_{\text{goal}}$, \\
skill library $\mathcal{O}=\{o_\alpha \mid \alpha \in \{\text{NP}_1, ..., \text{NP}_n, \text{Place}\}\}$, \\
\colorbox{gray!20}{\makebox[\dimexpr\linewidth-1em\relax][l]{connector library $C=\{c_\alpha \mid \alpha \in \{\text{NP}_1, ..., \text{NP}_n, \text{Place}\}\}$}}, \\
set of regions $\mathcal{M}=\{(\mu^i_{\mathcal{I}}, \mu^i_{\beta}) \mid i \in \{1, ..., n\}\}$, \\
Metric function $d$ to calculate distance between $(q^{\text{obj}}, q^{\text{obj}}_{sg})$, \\ Goal sample probability $p_g$
\State \textbf{Output:} skill plan $\tau_{\text{skill}}$ \\

\State $T=\emptyset$    \Comment{Initialize empty tree}
\State $v_{0} \gets \{ q^{\text{obj}}_{0} \}$ \Comment{Create a start node}
\State $T$.AddNode($v_{0}$)

\While{True}
    \State ${o_\alpha}, {q}^{\text{obj}}_{sg} \gets $\hyperref[algo:SampleSkillAndPose]{\texttt{SampleSkillAndSubgoal}}($\mathcal{O}, p_g$)
    \State ${v}_{\text{near}} \gets$ \hyperref[algo:NearestNode]{\texttt{CheckPreAndNearestNode}}($T, o_\alpha, q^{\text{obj}}_{sg}, d$)
\State \colorbox{gray!20}{\makebox[\dimexpr\linewidth-2em\relax][l]{$T \leftarrow $ \hyperref[algo:Extend]{\texttt{Extend}}$(T, v_{\text{near}}, o_\alpha, c_\alpha, {q}^{\text{obj}}_{sg})$}}
    \If{$q^{\text{obj}}_{\text{goal}} \in \bigcup_{v \in T.V} \{ v.q^{\text{obj}}_{\text{sg}} \}$}
        \State $v_{\text{goal}} \gets v \in T.V \ \text{s.t.} \ v.q^{\text{obj}}_{\text{sg}} = q^{\text{obj}}_{\text{goal}}$
        \State \textbf{break}
    \EndIf
\EndWhile

\State $\tau^\text{full}_{\text{skill}} \gets []$ \Comment{Initialize an empty list}
\While{$v_{\text{goal}} \neq v_0$}
    % \If{$v_{\text{goal}}.\text{type} == \text{skill}$}
    %     \State \colorbox{gray!20}{\makebox[\dimexpr\linewidth-3.5em\relax][l]{$\tau_{\text{skill}}.\text{append}((v_{\text{goal}}.o, v_{\text{goal}}.q^\text{obj}_\text{sg}))$}}
    % \Else
    %     \State \colorbox{gray!20}{\makebox[\dimexpr\linewidth-3.5em\relax][l]{$\tau_{\text{skill}}.\text{append}((v_{\text{goal}}.c, v_{\text{goal}}.q^\text{robot}_\text{pre}))$}}
    % \EndIf
    \State $\tau^\text{full}_{\text{skill}}.\text{append}(v_{\text{goal}})$
    \State $v_{\text{goal}} \gets v_{\text{goal}}.\text{parent}$
\EndWhile

\State $\tau^\text{full}_{\text{skill}} \gets \tau^\text{full}_{\text{skill}}[::-1]$ \Comment{Reverse the list}
\State \Return $\tau^\text{full}_{\text{skill}}$

\end{algorithmic}
\end{algorithm}

