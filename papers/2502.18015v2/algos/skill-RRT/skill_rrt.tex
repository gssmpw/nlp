\begin{algorithm}[H]
\caption{\texttt{Skill-RRT}}\label{algo:Universal-skill-rrt}
\begin{algorithmic}[1]

\Procedure{\texttt{Skill-RRT}}{
  $q^{\text{obj}}_0, q^{\text{robot}}_{0}, q^{\text{obj}}_{\text{goal}}, \mathcal{O},\{\mu^i\}_{i=1, \dots, n}$, 
  \hspace{1cm} $p_g$, $d^\text{robot}(\cdot, \cdot)$, $d^\text{obj}(\cdot, \cdot)$, 
  $\epsilon^\text{robot}$, $\epsilon^\text{obj}$, \texttt{Extend}$(\cdot, \cdot, \cdot, \cdot, \cdot, \cdot, \cdot, \cdot)$
}

\State $T=\emptyset$   \Comment{Initialize an empty tree}
\State $v_{0} \gets \{\emptyset, \emptyset,  q^{\text{obj}}_{0},  \textbf{0},q^\text{robot}_0,  \textbf{0}\}$ \Comment{Root: no skill, subgoal}
\State $v_\text{goal} \gets $ None
\State $T$.AddNode($v_{0}$)

\For{$i = 1$ \textbf{to} $N$}
    \State ${o}, {q}^{\text{obj}}_{sg} \gets $\hyperref[algo:SampleSkillAndPose]{\texttt{SampleSkillSubgoal}}($\mathcal{O}, p_g, \ \ \ \ \ \ $
    \hspace*{18em}$ \{\mu^i\}_{i=1, \dots, n}$)
    \State ${v}_{\text{near}} \gets$ \hyperref[algo:NearestNode]{\texttt{GetFeasibleNearestNode}}($T, o, q^{\text{obj}}_{sg},$
    \hspace*{21.5em}$ d^\text{obj}$)
    \If{$v_\text{near}$ is $\emptyset$} 
        \State \textbf{continue}
    \EndIf
    \State $T \leftarrow $ \texttt{Extend}$\big(T, v_{\text{near}}, o, q^{\text{obj}}_{sg}, d^\text{robot}(\cdot, \cdot), d^\text{obj}(\cdot, \cdot),$ \\
    \hspace*{19em} $ \epsilon^\text{robot}, \epsilon^\text{obj}\big)$
    \If{$q^{\text{obj}}_{\text{goal}} \in \bigcup_{v \in T.V} \{ v.q^{\text{obj}}_{\text{sg}} \}$}
        \State $v_{\text{goal}} \gets v \in T.V \ \text{s.t.} \ v.q^{\text{obj}}_{\text{sg}} = q^{\text{obj}}_{\text{goal}}$
        \State \textbf{break}
    \EndIf
\EndFor

\If{$v_\text{goal}$ is None}
    \State \textbf{Return} None
\Else
    \State $\texttt{Path}_{\text{skill}} \gets \texttt{Retrace}(v_\text{goal}) $
    \State \textbf{Return} $\texttt{Path}_{\text{skill}}$
\EndIf
\EndProcedure

\Statex
\hrulefill


\end{algorithmic}
\end{algorithm}