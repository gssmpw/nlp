\begin{algorithm}[H]
\caption{\texttt{LazyExtend}}\label{algo:AbstractExtend}
\begin{algorithmic}[1]

\Procedure{\texttt{LazyExtend}}{$T$, $v_{\text{near}}$, $o$, ${q}^{\text{obj}}_{sg}, d^\text{obj}, \epsilon^\text{obj}$}
    \State ${q}^{\text{robot}}_{\text{pre}} \gets o.\pi^\text{pre}(v_{\text{near}}.q^{\text{obj}}_\text{pose}, {q}^{\text{obj}}_{sg})$
    \State $v^c_\text{new} \gets \{\emptyset, q^\text{robot}_\text{pre},v_\text{near}.q^\text{obj}_\text{pose},v_\text{near}.q^\text{obj}_\text{vel},q^\text{robot}_\text{pre}, \textbf{0} \}$ % \Comment{Teleport $q^\text{robot}$}
    \State \Comment{Teleport $q^\text{robot}_\text{pos}$ to $q^\text{robot}_\text{pre}$}
    \State $q^{\text{obj}}_\text{pose},q^{\text{obj}}_\text{vel}, q^{\text{robot}}_\text{pos}, q^{\text{robot}}_\text{vel} \gets \texttt{simulate}(o.\pi, v^c_\text{new}, {q}^{\text{obj}}_{sg})$
    \If{\textbf{not} $d^\text{obj}({q}^{\text{obj}}_\text{pose}, {q}^{\text{obj}}_{sg}) < \epsilon^\text{obj} $}
        \State \Return $T$
    \EndIf

    \State ${v_{\text{new}}} \gets \{o, q^\text{obj}_{sg}, {q}^{\text{obj}}_\text{pose},{q}^{\text{obj}}_\text{vel}, {q}^{\text{robot}}_\text{pose},  {q}^{\text{robot}}_\text{vel}\}$
    \State $T$.AddNodes$({v}_{\text{new}})$
    \State $T$.AddNodes$({v}^c_{\text{new}})$
    \State $v_{\text{new}}.\text{parent} = v^c_{\text{new}}$
    \State $v^c_{\text{new}}.\text{parent} = v_{\text{near}}$
    \State \Return $T$
\EndProcedure

\end{algorithmic}
\end{algorithm}
