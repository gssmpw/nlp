%%% macros for continuous wp project

%% very rough guideline for macros:
% use a macro for everything unless there is a good reason not to do so
% a possible exception are integer indices, we often do not use macros for them
% avoid macros with many parameters (e.g. more than 3)
% only write macros for things that we actually need
% camelCase should be the default for macro names
% do not worry too much about the definition of the macro - one can easily change it!
% the macro's name should be enough the clarify its meaning, append a documenting comment if not
% it is OK to define alternative shorthands for lengthy macro names
% append the suffixes "b", "c", etc. for alternative names (example: \ex = f, \exb = g, \exc = h)
% apppend suffix "Gen" for macro with "generic" arguments (example: \lowerIntGen = \lowerInt{\ivalL}{\ivalR})

%% cumstom environments
\newtheorem*{remark}{Remark}
\newtheorem*{counterexample}{Counter-example}
\newenvironment{myhighlight}{%
    %\medskip%
    \begin{center}%
        \begin{minipage}{0.85\textwidth}%
        }{%
        \end{minipage}%
    \end{center}%
    %\medskip%
}\newenvironment{mychallenge}[1]{\begin{myhighlight}\textbf{Challenge #1:}}{\end{myhighlight}}


%% special non-math formatting
\newcommand{\inductionCase}[1]{\subsubsection*{The case #1}} % used in proofs by structural induction
% copy-paste for induction proof:
%\inductionCase{$\prog = \SKIP$}
%\inductionCase{$\prog = \DIVERGE$}
%\inductionCase{$\prog = \OBSERVE{\guard}$}
%\inductionCase{$\prog = \ASSIGN{\pVar}{\aExp}$}
%\inductionCase{$\prog = \UNIFASSIGN{\pVar}$}
%\inductionCase{$\prog = \ITE{\guard}{\prog_1}{\prog_2}$}
%\inductionCase{$\prog = \PCHOICE{\prog_1}{\prob}{\prog_2}$}
%\inductionCase{$\prog = \SEQ{\prog_1}{\prog_2}$}
%\inductionCase{$\prog = \WHILE{\guard}{\progBody}$}


%% stuff involving colors
\newcommand{\gray}[1]{\textcolor{black!60}{#1}}

\newcommand{\toolfont}[1]{\textnormal{\textsc{#1}}}
\newcommand{\toolcaesar}{\toolfont{Caesar}\xspace}
\newcommand{\toolboogie}{\toolfont{Boogie}\xspace}
\newcommand{\toolzt}{\toolfont{Z3}\xspace}


%% hacky latex stuff
\newcommand{\xqed}[1]{%
    \leavevmode\unskip\penalty9999 \hbox{}\nobreak\hfill
    \quad\hbox{#1}}
\newcommand{\qedDef}{\xqed{$\triangle$}}


%% sets of numbers
\newcommand{\reals}{\mathbb{R}}
\newcommand{\extendedReals}{{\overline{\reals}}}
\newcommand{\exReals}{\extendedReals}
\newcommand{\realConst}{c}

\newcommand{\nonNegReals}{\reals_{\geq 0}}
\newcommand{\nnReals}{\nonNegReals}
\newcommand{\exNonNegReals}{\exReals_{\geq 0}}
\newcommand{\ennReals}{\exNonNegReals}
\newcommand{\monus}{\mathbin{\dot-}}

\newcommand{\integers}{\mathbb{Z}}
\newcommand{\ints}{\integers}
\newcommand{\nats}{\mathbb{N}}
\newcommand{\nonNegInts}{\nats}
\newcommand{\nnInts}{\nats}

\newcommand{\rats}{\mathbb{Q}}
\newcommand{\nonNegRats}{{\rats_{\geq 0}}}
\newcommand{\nnRats}{{\nonNegRats}}
\newcommand{\ratConst}{q}

\newcommand{\bools}{\mathbb{B}}
\newcommand{\boolConstTrue}{\mathsf{true}}
\newcommand{\boolConstFalse}{\mathsf{false}}


%% complexity classes and related things
\newcommand{\PSPACE}{\mathsf{PSPACE}}
\newcommand{\QFNRA}{\mathsf{QF\_NRA}}
\newcommand{\coRE}{\mathsf{coRE}}
\newcommand{\RE}{\mathsf{RE}}

%% intervals
\newcommand{\intervalLeft}{a} % left boundary point of generic interval
\newcommand{\intervalLeftb}{c}
\newcommand{\ivalL}{\intervalLeft}
\newcommand{\ivalLb}{\intervalLeftb}
\newcommand{\intervalRight}{b} % left boundary point of generic interval
\newcommand{\intervalRightb}{d}
\newcommand{\ivalR}{\intervalRight}
\newcommand{\ivalRb}{\intervalRightb}
\newcommand{\closedInterval}[2]{{[#1,#2]}} % [TW] in retrospect I think this should not be a macro because it is clearer to simply type [a,b] and the probability that we ever want to replace the boundary brackets is very low. So I will not define macros for (a,b), (a,b], etc.
\newcommand{\clIval}{\closedInterval}
\newcommand{\clIvalGen}{\closedInterval{\intervalLeft}{\intervalRight}}
\newcommand{\unitInterval}{\closedInterval{0}{1}}
\newcommand{\uIval}{{\unitInterval}}


%% iverson
\newcommand{\iv}[1]{{\left[#1\right]}} % iverson brackets of Boolean expression #1


%% lambda expression
\newcommand{\lam}[2]{\lambda #1 . #2} % lambda expression


%% domain and fixed point theory
\newcommand{\poleq}{\preceq}
\newcommand{\poleqb}{\preceqq}
\newcommand{\pogeq}{\succeq}
\newcommand{\pogeqb}{\succeqq}
\newcommand{\partialOrderDomain}{L}
\newcommand{\partialOrderDomainb}{M}
\newcommand{\poDom}{\partialOrderDomain}
\newcommand{\poDomb}{\partialOrderDomainb}
\newcommand{\partialOrder}[2]{(#1,\,#2)}
\newcommand{\po}[2]{\partialOrder{#1}{#2}}
\newcommand{\partialOrderGen}{(\partialOrderDomain,\,\poleq)}
\newcommand{\partialOrderGenb}{(\partialOrderDomainb,\,\poleqb)}
\newcommand{\poGen}{\partialOrderGen}
\newcommand{\poGenb}{\partialOrderGenb}
\newcommand{\partialOrderElement}{a}
\newcommand{\partialOrderElementb}{b}
\newcommand{\poElem}{\partialOrderElement}
\newcommand{\poElemb}{\partialOrderElementb}
\newcommand{\partialOrderSubset}{A}
\newcommand{\poSubset}{\partialOrderSubset}
\newcommand{\poBot}{\bot}
\newcommand{\poTop}{\top}


%% measure theory
\newcommand{\sigmaAlgebra}{\mathcal{F}}
\newcommand{\sAlg}{\sigmaAlgebra}
\newcommand{\proseSigmaAlgebra}{$\sigma$-algebra\xspace} % the word sigma algebra when it appears in prose
\newcommand{\proseSigmaAlgebras}{$\sigma$-algebras\xspace} % plural
\newcommand{\measureSpaceUniverse}{\Omega}
\newcommand{\mUniv}{\measureSpaceUniverse}
\newcommand{\measurableSet}{A}
\newcommand{\measurableSetb}{B}
\newcommand{\countableCollectionOfMeasurableSets}{\mathcal{A}}
\newcommand{\sigmaAlgebraGenerators}{\mathcal{C}}
\newcommand{\sigmaAlgebraGeneratedBy}[1]{\sigma(#1)}
\newcommand{\sigmaAlgebraGeneratedByIn}[2]{\sigma_{#2}(#1)}
\newcommand{\borelSets}[1]{{\mathcal{B}(#1)}}
\newcommand{\lebesgueSets}[1]{{\overline{\mathcal{B}}(#1)}}
\newcommand{\simpleFun}{s}
\newcommand{\measure}{\boldsymbol\mu}
\newcommand{\lebesgueMeasure}{\boldsymbol\lambda}
\newcommand{\lebmes}{\lebesgueMeasure}


%% fixed point operators
\newcommand{\slfp}[1]{\mathsf{lfp}\,{#1}}
\newcommand{\sgfp}[1]{\mathsf{gfp}\,{#1}}
\newcommand{\lfpOp}[2]{\Phi_{#1}^{#2}} % lfp operator for wp
\newcommand{\gfpOp}[2]{\Psi_{#1}^{#2}} % gfp operator for wlp
\newcommand{\lfpOpN}[3]{\underline{\Phi}_{#1}^{#2,#3}} % lfp operator for lwp
%\newcommand{\lfp}[3]{\lfpOp{#1}{#2}(#3)} 
%\newcommand{\gfp}[3]{\gfpOp{#1}{#2}(#3)}
\newcommand{\exlfp}[3]{\iv{\neg #3} \cdot #2 + \iv{#3} \cdot \wpTrans{#1}} % explictly write the fixed point operator for program (#1), expectation (#2) and guard (#3)
\newcommand{\lfp}{\operatorname{lfp}}
\newcommand{\gfp}{\operatorname{gfp}}
\newcommand{\lfpIn}[2]{\lfp#1.\,#2}
\newcommand{\gfpIn}[2]{\gfp#1.\,#2}
\newcommand{\fpVar}{Y}


%% real functions
\newcommand{\realDomain}{D}
\newcommand{\fun}{f}
\newcommand{\funb}{g}
\newcommand{\func}{h}
\newcommand{\boundedFunBound}{B}
\newcommand{\funRestr}[2]{#1\,\big|_{#2}}


%% riemann integral
\newcommand{\partition}{P}
\newcommand{\partitionb}{Q}
\newcommand{\setOfPartitions}{\mathcal{P}}
\newcommand{\partitions}[1]{\mathfrak{P}#1} % set of partitions of interval #1
\newcommand{\partitionSize}{N}
\newcommand{\partitionSizeb}{M}
\newcommand{\partitionNorm}[1]{\|#1\|} % fineness of partition #1
\newcommand{\partitionRefines}{\preceq}

\newcommand{\upperSum}[2]{{U_{#1,#2}}} % upper Riemann sum of function #1 w.r.t. partition #2
\newcommand{\lowerSum}[2]{{L_{#1,#2}}} % upper Riemann sum of function #1 w.r.t. partition #2
\newcommand{\upperInt}[2]{\overline{\int_{#1}^{#2}}} % upper Riemann integral over interval [#1,#2]
\newcommand{\lowerInt}[2]{\underline{\int_{#1}^{#2}}} % lower Riemann-Darboux integral over interval [#1,#2]
\newcommand{\upperIntGen}{\upperInt{\ivalL}{\ivalR}}
\newcommand{\lowerIntGen}{\lowerInt{\ivalL}{\ivalR}}


%% programs
\newcommand{\prog}{C} % program
\newcommand{\progBody}{B} % loop body 
\newcommand{\pWhile}{\mathsf{pWhile}} % set of pWhile programs
\newcommand{\heyVL}{\mathsf{HeyVL}} % set of pWhile programs
\newcommand{\pWhileWith}[2]{\pWhile(#1,#2)} % set of pWhile programs with expressions #1 and guards #2
\newcommand{\numVars}{n} % number of variables in a program
\newcommand{\pVars}{V} % set of program variables
\newcommand{\pVar}{\mathtt{x}} % program variable
\newcommand{\pVarb}{\mathtt{y}}
\newcommand{\pVarc}{\mathtt{z}}
\newcommand{\pVarm}{\mathtt{M}}
\newcommand{\pVari}{\mathtt{i}}
\newcommand{\pVarj}{\mathtt{j}}
\newcommand{\pVaraa}{\mathtt{a}}
\newcommand{\pVarbb}{\mathtt{b}}
\newcommand{\pVarcount}{\mathtt{count}}
\newcommand{\pVart}{\mathtt{t}}
\newcommand{\pVarh}{\mathtt{h}}
\newcommand{\pVarTmp}{\mathtt{tmp}} % tmp program variable
\newcommand{\pState}{\sigma} % program state
\newcommand{\pStates}{\nnReals^\pVars} % set of program states
\newcommand{\pSt}{\pState}
\renewcommand{\st}{\pState} % \st defined by soul package
\newcommand{\states}{\pStates}
\newcommand{\pStUpdate}[3]{#1[#2 \mapsto #3]}
\newcommand{\arithmeticExpression}{E}
\newcommand{\aExp}{\arithmeticExpression}
\newcommand{\aExps}{\mathcal{E}} % set of arithmetic expressions
\newcommand{\guard}{\varphi} % boolean expression in program (i.e., while guard, if guard, observe condition)
\newcommand{\guards}{\mathcal{G}} % set of boolean expressions
\newcommand{\prob}{p} % probability in PCHOICE
\newcommand{\unfold}[2]{#1^{#2}} % #2-fold unfolding of program #1
\newcommand{\depth}{\ell} % unfolding depth


%% program syntax
\newcommand{\SKIP}{\mathtt{skip}}
\newcommand{\DIVERGE}{\mathtt{diverge}}
\newcommand{\INVARIANT}{\mathtt{@invariant}}
\newcommand{\ASSIGN}[2]{#1\coloneq#2}
\newcommand{\NONDETASSIGN}[3]{#1\coloneq [ #2, #3 ]}
\newcommand{\UNIF}{\mathtt{unif}} % uniform distribution over [0,1]
\newcommand{\DISCRETEUNIF}{\mathtt{discrete\_unif}} % discrete uniform distribution 
\newcommand{\UNIFOVER}[2]{\UNIF\closedInterval{#1}{#2}} % uniform distribution over [#1,#2]
\newcommand{\RNDASSIGN}[2]{#1:\approx#2} % sample from distribution #2 and assign result to program variable #1
\newcommand{\UNIFASSIGN}[1]{\RNDASSIGN{#1}{\UNIF_{\uIval}}} % sample from unif[0,1] and
\newcommand{\DISCRETEUNIFASSIGN}[2]{\RNDASSIGN{#1}{\DISCRETEUNIF \left( #2 \right) }} % sample from unif[0,1] and

\newcommand{\KWOBSERVE}{\mathtt{observe}} 
\newcommand{\OBSERVE}[1]{\KWOBSERVE(#1)}
\newcommand{\SEMICOLON}{;}
\newcommand{\SEQ}[2]{#1\,\SEMICOLON\,#2}
\newcommand{\KWIF}{\mathtt{if}} % keyword "if"
\newcommand{\KWELSE}{\mathtt{else}}
\newcommand{\ITE}[3]{\KWIF(#1)~\{#2\}~\KWELSE~\{#3\}}
\newcommand{\PCHOICE}[3]{\{#1\}~[#2]~\{#3\}}
\newcommand{\KWWHILE}{\mathtt{while}}
\newcommand{\WHILE}[2]{\KWWHILE~(#1)~\{#2\}}
\newcommand{\WHILENOBODY}[1]{\KWWHILE~(#1)~\{}
\newcommand{\INVARIANTANNOTATE}[1]{\INVARIANT \left( #1 \right)}

\newcommand{\pNEQ}{\neq}
\newcommand{\pAND}{\land}


%% wp
\newcommand{\transSymb}{\mathcal{T}}
\newcommand{\wpSymb}{\mathsf{wp}}
\newcommand{\vcSymb}{\mathsf{vc}}
\newcommand{\wlpSymb}{\mathsf{wlp}}
\newcommand{\cwpSymb}{\mathsf{cwp}}
\newcommand{\lwpSymb}[1]{\underline{\mathsf{w}}\mathsf{p}^{#1}} % lower wp^N symbol
\newcommand{\uwpSymb}[1]{\overline{\mathsf{wp}}^{#1}} % upper wp^N symbol
\newcommand{\lwlpSymb}[1]{\underline{\mathsf{wl}}\mathsf{p}^{#1}} % lower wlp^N symbol
\newcommand{\uwlpSymb}[1]{\overline{\mathsf{w}}\mathsf{l}\overline{\mathsf{p}}^{#1}} % upper wlp^N symbol
\newcommand{\lcwpSymb}[1]{\underline{\mathsf{cw}}\mathsf{p}^N} % lower cwp^N symbol
\newcommand{\ucwpSymb}[1]{\overline{\mathsf{cwp}}^N} % upper cwp^N symbol
\newcommand{\wpwlpSymb}{\mathsf{w}(\mathsf{l})\mathsf{p}}

\newcommand{\someTrans}[1]{\transSymb\llbracket#1\rrbracket}
\newcommand{\wpTrans}[1]{\wpSymb\llbracket#1\rrbracket} % wp[[#1]]
\newcommand{\wpwlpTrans}[1]{\wpwlpSymb\llbracket#1\rrbracket}
\newcommand{\vcTrans}[1]{\vcSymb\llbracket#1\rrbracket} % wp[[#1]]
\newcommand{\wlpTrans}[1]{\wlpSymb\llbracket#1\rrbracket}
\newcommand{\cwpTrans}[1]{\cwpSymb\llbracket#1\rrbracket}
\newcommand{\lwpTrans}[2]{\lwpSymb{#1}\llbracket#2\rrbracket}
\newcommand{\uwpTrans}[2]{\uwpSymb{#1}\llbracket#2\rrbracket}
\newcommand{\lwlpTrans}[2]{\lwlpSymb{#1}\llbracket#2\rrbracket}
\newcommand{\uwlpTrans}[2]{\uwlpSymb{#1}\llbracket#2\rrbracket}
\newcommand{\lcwpTrans}[2]{\lcwpSymb{#1}\llbracket#2\rrbracket}
\newcommand{\ucwpTrans}[2]{\ucwpSymb{#1}\llbracket#2\rrbracket}

\newcommand{\somewp}[2]{\someTrans{#1}\left(#2\right)} 
\renewcommand{\wp}[2]{\wpTrans{#1}\left(#2\right)} % wp[[#1]](#2)
\newcommand{\vc}[2]{\vcTrans{#1}\left(#2\right)} 
\newcommand{\wlp}[2]{\wlpTrans{#1}\left(#2\right)}
\newcommand{\cwp}[2]{\cwpTrans{#1}\left(#2\right)}
\newcommand{\lwp}[3]{\lwpTrans{#1}{#2}\left(#3\right)} % lwp^#1[[#2]](#3)
\newcommand{\uwp}[3]{\uwpTrans{#1}{#2}\left(#3\right)}
\newcommand{\lwlp}[3]{\lwlpTrans{#1}{#2}\left(#3\right)} % lwlp^#1[[#2]](#3)
\newcommand{\uwlp}[3]{\uwlpTrans{#1}{#2}\left(#3\right)}
\newcommand{\lcwp}[3]{\lcwpTrans{#1}{#2}\left(#3\right)}
\newcommand{\ucwp}[3]{\ucwpTrans{#1}{#2}\left(#3\right)}

%Characteristic Functions
\newcommand{\charfun}[3]{\tensor*[^{#1}_{#2}]{\Phi}{_{{#3}}}}
\newcommand{\charfuniter}[4]{\tensor*[^{#1}_{#2}]{\Phi}{_{{#3}}^{#4}}}

\newcommand{\charfuntrans}[2]{\charfun{\transSymb}{#1}{#2}}
\newcommand{\charfunwp}[2]{\charfun{\wpSymb}{#1}{#2}}
\newcommand{\charfunwlp}[2]{\charfun{\wlpSymb}{#1}{#2}}
\newcommand{\charfunuwp}[3]{\charfun{\uwpSymb{#1}}{#2}{#3}}
\newcommand{\charfunlwp}[3]{\charfun{\lwpSymb{#1}}{#2}{#3}}
\newcommand{\charfunlwlp}[3]{\charfun{\lwlpSymb{#1}}{#2}{#3}}

\newcommand{\charfunwpiter}[3]{\charfuniter{\wpSymb}{#1}{#2}{#3}}
\newcommand{\charfunlwpiter}[4]{\charfuniter{\lwpSymb{#1}}{#2}{#3}{#4}}
\newcommand{\charfunuwlpiter}[4]{\charfuniter{\uwlpSymb{#1}}{#2}{#3}{#4}}


\newcommand{\N}{N} % the ^N from wp^N
\newcommand{\Nb}{M} % alternative to \N

\newcommand{\ex}{f} % expectation
\newcommand{\exb}{g}
\newcommand{\exc}{h}
\newcommand{\exI}{I}
\newcommand{\exJ}{J}
\newcommand{\eleq}{\sqsubseteq} % order between expectations
\newcommand{\egeq}{\sqsupseteq} % order between expectations
\newcommand{\expectations}{\mathbb{E}}
\newcommand{\exps}{\expectations}
\newcommand{\boundedExpectations}{{\expectations^{\leq 1}}}
\newcommand{\bexps}{\boundedExpectations}
\newcommand{\measurableExpectations}{{\expectations_{meas}}}
\newcommand{\expsmeas}{\measurableExpectations}
\newcommand{\boundedMeasurableExpectations}{{\expectations^{\leq 1}_{meas}}}
\newcommand{\bexpsmeas}{\boundedMeasurableExpectations}
\newcommand{\measurableLocallyBoundedExpectations}{{\expectations_{meas}^{\lesssim}}}
\newcommand{\expsmeaslb}{\measurableLocallyBoundedExpectations}
\newcommand{\compactSet}{K}
\newcommand{\expsClass}{\mathcal{F}} % subset of expectations
\newcommand{\exSubs}[3]{#1[#2 / #3]} % substitution of variable #2 in expectation #1 by term #3
\newcommand{\exSubsGen}{\exSubs{\ex}{\pVar}{\aExp}}


%% logic and syntactic expressions
\newcommand{\synEx}{\mathsf{f}}
\newcommand{\synExb}{\mathsf{g}}
\newcommand{\synExc}{\mathsf{h}}
\newcommand{\synExI}{\mathsf{I}}
\newcommand{\synExJ}{\mathsf{J}}
\newcommand{\synExps}{\mathsf{Expr}}
\newcommand{\synSubs}[3]{#1[#2/#3]}
\newcommand{\supQuantifierSymbol}{\reflectbox{\textnormal{\textsf{\fontfamily{phv}\selectfont S}}}\hspace{.2ex}}
\newcommand{\infQuantifierSymbol}{\raisebox{.6\depth}{\rotatebox{-30}{\textnormal{\textsf{\fontfamily{phv}\selectfont \reflectbox{J}}}}\hspace{-.1ex}}}
\newcommand{\quantitativeQuantifierSymbol}{\reflectbox{\textnormal{\textsf{\fontfamily{phv}\selectfont Q}}}\hspace{.2ex}}
\newcommand{\synSupBd}[3]{{\supQuantifierSymbol\!_\clIval{#2}{#3}\,#1\colon}}
\newcommand{\synInfBd}[3]{{\infQuantifierSymbol\!_\clIval{#2}{#3} \,#1\colon}}
\newcommand{\synVarQuantBd}[4]{{#4\!_\clIval{#2}{#3} \,#1\colon}}


\newcommand{\limplies}{{}\rightarrow{}}
\newcommand{\liff}{{}\leftrightarrow{}}
\newcommand{\sem}[1]{\llbracket#1\rrbracket}
\newcommand{\free}[1]{{\mathsf{free}(#1)}}
\newcommand{\varsIn}[1]{{\mathsf{free}(#1)}}

\newcommand{\logicVariables}{\mathit{LV}}
\newcommand{\lvars}{\logicVariables}
\newcommand{\logicVariablesSubset}{{\logicVariables'}}
\newcommand{\lvarsSubset}{\logicVariablesSubset}
\newcommand{\logicVariable}{x}
\newcommand{\lvar}{\logicVariable}
\newcommand{\logicVariableb}{y}
\newcommand{\lvarb}{\logicVariableb}
\newcommand{\logicVariablec}{z}
\newcommand{\lvarc}{\logicVariablec}
\newcommand{\logicVariabled}{w}
\newcommand{\lvard}{\logicVariabled}

\newcommand{\syntacticTerm}{\mathsf{t}}
\newcommand{\syntacticTermb}{\mathsf{u}}
\newcommand{\syntacticTermc}{\mathsf{v}}
\newcommand{\synTerm}{\syntacticTerm}
\newcommand{\synTermb}{\syntacticTermb}
\newcommand{\synTermc}{\syntacticTermc}
\newcommand{\syntacticTerms}{\mathsf{Terms}}
\newcommand{\synTerms}{\syntacticTerms}
\newcommand{\synMonus}{\mathbin{\dot{-}}} % monus symbol used in syntactic expressions

\newcommand{\syntacticGuard}{\upvarphi}
\newcommand{\synGuard}{\syntacticGuard}
\newcommand{\syntacticGuards}{\mathsf{Guards}}
\newcommand{\synGuards}{\syntacticGuards}

\newcommand{\firstOrderFormula}{\uppsi}
\newcommand{\foForm}{\firstOrderFormula}
\newcommand{\firstOrderFormulab}{\uptheta}
\newcommand{\foFormb}{\firstOrderFormulab}
\newcommand{\firstOrderFormulas}{\mathsf{FO}}
\newcommand{\foForms}{\firstOrderFormulas}
\newcommand{\firstOrderExistsQuantifier}{\exists}
\newcommand{\foExists}{\firstOrderExistsQuantifier}
\newcommand{\firstOrderForallQuantifier}{\forall}
\newcommand{\foForall}{\firstOrderForallQuantifier}
\newcommand{\foQuantifierSymbol}{\reflectbox{$\mathsf{Q}$}\hspace{.2ex}}

\newcommand{\resVal}{r}

\newcommand{\semiAlgebraicSet}{A}
\newcommand{\saSet}{\semiAlgebraicSet}

\newcommand{\expsClassExp}{\exps_{\synExps}}
\newcommand{\bexpsClassExp}{\expsClassExp^{\leq 1}}

\newcommand{\representableExpectations}{\exps_{\synExps}}
\newcommand{\repExps}{\representableExpectations}
\newcommand{\boundedRepresentableExpectations}{\exps^{\leq 1}_{\synExps}}
\newcommand{\brepExps}{\boundedRepresentableExpectations}

\newcommand{\syntacticExpectations}{\synExps}
\newcommand{\bsyntacticExpectations}{\syntacticExpectations^{\leq 1}}


%% misc
\newcommand{\eps}{\varepsilon}
\newcommand{\suitableClass}{\mathfrak{C}}
\newcommand{\zerofun}{0}
\newcommand{\onefun}{1}
\newcommand{\grammarSymb}{\Coloneqq}


%% m o r e  s p a c e
\newcommand{\eeq}{~{}={}~}
\newcommand{\nneq}{~{}\neq{}~}
\newcommand{\iin}{~{}\in{}~}
\newcommand{\nnotin}{~{}\not\in{}~}
\newcommand{\lleq}{~{}\leq{}~}
\newcommand{\ggeq}{~{}\geq{}~}
\newcommand{\llt}{~{}<{}~}
\newcommand{\ggt}{~{}>{}~}
\newcommand{\ppoleq}{~{}\poleq{}~}
\newcommand{\ppogeq}{~{}\pogeq{}~}
\newcommand{\eeleq}{~{}\eleq{}~}
\newcommand{\eegeq}{~{}\egeq{}~}
\newcommand{\aand}{~{}\text{and}{}~}
\newcommand{\mminus}{~{}-{}~}
\newcommand{\pplus}{~{}+{}~}
\newcommand{\mmid}{~{}\mid{}~}

\newcommand{\qand}{\quad\text{and}\quad}
\newcommand{\qqand}{\qquad\text{and}\qquad}

\newcommand{\colprog}{\textbf{Program}}
\newcommand{\coln}{$\mathbf{\N}$}
\newcommand{\colt}{\textbf{Time}}
\newcommand{\colformsize}{\textbf{|AST|}}
\newcommand{\colpost}{\textbf{Post}}
\newcommand{\colbound}{\textbf{Bound}}

\newcommand{\progdiverging}{\texttt{diverging}}
\newcommand{\progirwin}{\texttt{IrwinHall}}
\newcommand{\progmontecarlo}{\texttt{MonteCarlo}}
\newcommand{\progtortoise}{\texttt{TortoiseHare}}
