% file: extend-refine.tex
%		(copied from shrink.tex)

\sect{ \Extend\ and \Refine\ Subroutines}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	We present algorithms for
	\Extend\ and \Refine\
	(see \refeqs{extend}{refine} for the input-output
	specifications of these subroutines).

	For efficiency, we will augment the concept of a scaffold
	to keep track of global parameters such as $\bff$, as well as
	computed values from each stage.
	For the $i$th stage with admissible triple
	$(E_i,\Delta t_i, F_i)$, we have computed values such as
	the transformation parameters ($\pi$ and $\bfg$)
	and the \lognorm\ bounds ($\olmu_1$ and $\olmu_2$) for
	$(\bff,F_i)$ and $(\bfg,\pi(F_i))$.
	%%
	More precisely, we define an \dt{augmented scaffold}
	$\calD$ by adding an extra component $\bfG$ to the
	usual $m$-stage scaffold:
			$\calD = (\bft, \bfE, \bfF, \bfG)$
	where $\bfG=(G_1\dd G_m)$. 
	%To motivate the components of $\bfG$,
	As usual, $G_i = G_i(\calD)$ where
		$$G_i(\calD) =(\pi_i,\bfg_i,\olmu^1_i,\olmu^2_i;
					\cored{\delta_i, h_i, \ell_i, \bfE_i, \bfF_i})$$
	where the parameters in red are
	extra data needed by the \Refine\ subroutine below.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ssect{\Extend\ Subroutine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	Basically, 
	$\Extend(\calD, \veps,\delta,H)$
		calls $\stepA$ to add a new stage to $\calD$.
		Note that we view $\calD$ is an object in the sense
		of OOPL, and write $\calD.\Extend(\cdots)$ to call
		$\Extend$ to modify itself: 

	{\scriptsize
	\Ldent\progb{
		\lline[0] $\calD.\Extend(\veps,\delta,H)$ 
		\lline[5] INPUT: $m$-stage augmented scaffold $\calD$, 		
							$\veps>0$, $\delta>0, H>0$.
		\lline[5] OUTPUT:  	$\calD'$ 
							is a $m+1$-stage refinement of $\calD$
							such that 
		\lline[25]		 $(t_{m+1}(\calD')-t_m(\calD),E_{m+1}(\calD))$
							is an $\veps$-admissible pair. 
						
		\lline
		\lline[10]  $(h,B_1)\ass \stepA(E_m(\calD),\veps,H)$.
		\lline[10] $\olmu_1\ass \mu_2(J_{\bff}(B_1))$.  
		\lline[10]  $(\olmu_2,\pi,\bfg)\ass \Transform(\bff,B_1,\olmu_1)$.
		\lline[10]  $\delta'_1\ass \TransformBound(\delta,
		\pi, B_1)$
			\lline[10]  $h_1\ass 
		h(h,\|\bfg^{[2]}(\pi(B_1))\|,
		\olmu_2,\delta'_1)$.
		\Commentx{ See \refeq{h1}.}
		\lline[10] 	return $\calD';(t_m+h,B_1,B_1)$,
		$(\pi,\bfg,\olmu_1,\olmu_2,\delta, 
		h_1,(E_m(\calD),B_1),(B_1))$.
	}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ssect{\Refine\ Subroutine}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	The goal of $\calD.\Refine(\veps)$ is to ensure that
	the end-enclosure of $\calD$ has max-width $\le \veps$.
	This is achieved by making the admissible quad
			$(E_{i-1},\Delta t_i, F_i, E_i)$
	$\delta_i$-bounded (see \refeq{deltabound})
	for each stage $i$ where $\delta_i$ is halved
	iteratively. We can achieve this bound using
	\refLem{eulerStep} and \refCor{cor-1}.  But this is very inefficient.
	Instead, we introduce a\footnote{
		Viewing the $i$th stage as a \bigStep,
		the mini-scaffold represent \smallStep s of 
		the $i$th stage. 
	} 
	``mini-scaffold'' $\bfG_i=(\ell_i, \bfF_i,\bfE_i)$
	into stage $i$ where the time grid is uniform
	with step size $(\Delta t_i)\cdot 2^{-\ell_i}$.
	%
	% where $\bfE_i$ and $\bfF_i$ are $2^{\ell_i}$-vectors,
	See Figure \ref{fig:d-q} for illustration.
	Now, we can adaptively increment $\ell_i$ to refine the
	$i$th stage.
		%
	% This is done using the \Bisect\ subroutine below.
		%
	But when $(\Delta t_i)2^{-\ell_i}$ reaches the bound
	of \refeq{h1}, we can update the global data
	$E_i, F_i, \olmu^1, \olmu^2, \pi_i, \bfg_i$, etc.
	Moreover, the $i$th quad is $\delta_i$-bounded
	(by design).
	

	
	% TODO: \usepackage{graphicx} required
	\begin{figure}[h]
		\centering
		\includegraphics[width=0.7\linewidth]{figs/D-Q}
		\caption{$3$-stage scaffold $\calD$ with $\ell_1=2$,
		$\ell_2=1$ and $\ell_3=0$ in $G$.}
		\label{fig:d-q}
	\end{figure}



	\savespace{

	{\small
	\Ldent\progb{
		\lline[0] Bisect$(\calD[i])$  
		\lline[5] INPUT: Some $i$th stage of $\calD$.
		\lline[5] OUTPUT:  A refinement of each small step of the
					$i$th stage. 
		\lline[10] 	(This is a self-modification of $\calD$.)
		\lline[10]  Let $(\pi_i,\bfg_i,\olmu^1_i,\olmu^2_i,
			\delta_i, h_i, \ell_i, \bfE_i, \bfF_i)$ be $G_i(\calD)$
		\lline[10]  Initialize two new vectors $\bfE'$ and $\bfF'$.
		\lline[10]  $h \ass (\Delta t_i)2^{-\ell_i-1}$
		\lline[10]  For $j=1\dd 2^{\ell_i}$,
		\lline[15]  	$E \ass \stepB(\bfE_i[j-1], h, \bfF_i[j])$
		\lline[15]  	$\bfE'.\text{push\_back}(E)$
		\lline[15]  	$\bfE'.\text{push\_back}(\stepB(E, h,
							\bfF_i[j]))$
		\lline[15]  	$\bfF'.\text{push\_back}(\bfF_i[j])$;
						  	$\bfF'.\text{push\_back}(\bfF_i[j])$;
		\lline[10]  $(\ell_i, \bfE_i, \bfF_i)\ass (\ell_i+1, \bfE', \bfF')$
	}}
	We view $\bfE_i$ and $\bfF_i$ as a vector in the sense
	of C++.  Denote the operation of
	appending $E$ to the end of the vector by
	$\bfE_i.\text{push\_back}(E)$.

	}% savespace

	We are ready to describe the \Refine\ subroutine:
	
	{\scriptsize
	\Ldent\progb{
		\lline[0] $\calD.\Refine(\veps)$
		\lline[5] INPUT:  $m$-stage augmented
				scaffold $\calD$ and $\veps>0$.
		\lline[5] OUTPUT: $\calD$ remains an
					$m$-stage augmented scaffold 
         \lline[25]           but 
					the length satisfies $\wmax(E_{m})\le \veps$.
		\lline
		\lline[10] $r_0\ass \wmax(E_m(\calD))$. 
		\lline[10] While ($r_0> \veps$)
		\lline[15]   For ($i=1\dd m$)
		\lline[20]  	Let $(\pi,\bfg,\olmu^1,\olmu^2,
						\delta, h, \ell,
						\bfE, \bfF)$ be $G_i(\calD)$
		\lline[20] 	 	$H\ass (\Delta t_i)2^{-\ell}$
		\llline[1:]{15}{ 	 	If $(H>h)$}
		\lline[25] 	 		$\Bisect(\calD[i])$
		\lline[20] 	 	Else
		\llline[2:]{20}   		$E_0\ass \half E_0$.
		\llline[3:]{20}   		$\delta'\ass \delta$,
								\quad $\delta\ass\delta/2$.
		\lline[25] 			Let $Ball_\bfp(r_0)$ denote the
								circumscribing ball of $\bfE[0]$
		\lline[30]          and $Ball_{\bfp'}(r'_0)$ be the
								circumscribing ball of $\pi(\bfE[0])$.
		\lline[30]			$\bfq\ass \pi(\bfp)$, $d\ass 
		\|\bfq-m(Box(\pi(\bfE[0])))\| $.
		\lline[25]			For ($j=1\dd 2^{\ell}$)
		\lline[30]  			If ($\pi=Id$) 
		\lline[35]					$\bfq\ass \bfm(\bfE[j])$,
									
		\lline[30]				Else 
		\lline[35]				
									$\bfq\ass \bfq+\bfg(\bfq)H$,
									
		\lline[30]				$\delta_1\ass \TransformBound(\delta',
									\pi, \bfF[j])$.
		\llline[4:]{25}{ 		$r_1\ass r_0e^{j\olmu^1 H}+\delta'$,
								$r'_1\ass (r'_0+d)e^{j\olmu^2 H}+\delta_1$}
		\lline[30] 				$B\ass Box(	r_1)$,
								$B'\ass  Box(r'_1)$.
		\lline[30]  			$\bfF[j]\ass \bfF[j] \cap
				\pi\inv(Box(\pi(\bfE[j-1])+B',\bfp'+B')$
		\llline[5:]{25} 				$\bfE[j]\ass \bfE[j]\cap    
		        \pi\inv(\bfq+B')	\cap (\pi\inv(\bfq)+B)$.
		\lline[30] 				$\delta'_1\ass \TransformBound(\delta,
										\pi, \bfF[j])$.
		\lline[30] 				$h\ass 	
					h(h,\|\bfg^{[2]}(\pi(\bfF[j]))\|,\olmu^2,\delta'_1).$
		\lline[25]	\Commentx{End of For ($j=1\dd 2^{\ell}$)}
		\lline[20]  $E_i(\calD)\ass \bfE[2^{\ell}]$, 
					%	\quad $F_i(\calD)\ass Box\Big(
							%\bigcup_{j=1}^{2^\ell}\bfF_j(\calD)\Big)$
		%\lline[20]  Update $\olmu_2$ of $G_i(\calD)$
				%		to $\mu_2(J_\bfg\Big(\bigcup_{j=1}^{2^\ell}
									%\bfF_j(\calD))\Big)$ 
				%\qquad\Commentx{(Experimentally see if this helps)}
		\lline[15]	\Commentx{End of For ($i=1\dd m$)}
		\llline[6:]{10}	{ $r_0\ass\wmax(E_m(\calD))$}
		\lline[10] Return $\calD$.
	}}

	\bleml[refine]
		The subroutine $\calD.\Refine(\veps)$ is correct.
	\eleml

	\savespace{
	\dt{Correctness of \Refine:}
	The proof of correctness of \Refine\ is similar to
	that of \Refine: first, its partial correctness is exactly the same
	as before.  As for termination, we see that
	in each iteration of the while-loop, and for
	each stage ($i=1\dd m$), we either
	call the bisection subroutine or both $\delta$ and
	$E_0$ are halved (Lines 2: and 3:).  We can only bisect at most
	$\ceil{\log_2(\Delta t_i/h_i)}$ times in stage $i$.
	On the other hand, using the same argument as
	for \Refine, as $\delta$ and length of $E_0$ goes to $0)$,
	we know that the value of $r_0$ (Line 6:).  Thus termination 
	must happen.
	}% savespace
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
