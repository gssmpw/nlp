%file: overview-new.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sect{Overview of our Algorithm}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	We will develop an algorithm for the End-Enclosure
	Problem \refeq{endEncProb}, by elaborating
	on the classic Euler method or corrector-predictor
	framework for homotopy path 
	%	\cite[Algorithm 8.2.3, page XX]{sommese+2:intro-nag:1}
	(e.g., \cite{sommese+2:intro-nag:10,xu-burr-yap:homotopy:18}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%Step A and B	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	The basic motif is to 
	repeatedly call two subroutines\footnote{
		Nediakov et al.~\cite{nedialkov+2:validated-ode:99}
		call them Algorithms I and II.
	}
	which we call \stepA\ and \stepB, respectively:
	\savespace{They correspond roughly
	to predictor/corrector steps of homotopy path methods.
	}
	
	% use image to get equation number!!!
	\beql{stepAB}
			\includegraphics[width=0.75\columnwidth]{figs/stepAB}
	\eeql
	
	% Note: these definitions has moved to myMac.sty
	%	but not to myMac-issac.sty:
\DeclareRobustCommand{\loongrightarrow}{%
  	\DOTSB \relbar\joinrel \relbar\joinrel
  		\relbar\joinrel \relbar\joinrel
		\rightarrow }
\DeclareRobustCommand{\looongrightarrow}{%
  \DOTSB \relbar\joinrel \relbar\joinrel
  		 \relbar\joinrel \relbar\joinrel
  		 \relbar\joinrel \relbar\joinrel \rightarrow }
	
	Thus we see this progression
		\beql{stepAstepB}
			E_0 \overset{\stepA}{\looongrightarrow}
			(E_0,h_0,F_1) \overset{\stepB}{\looongrightarrow}
			(E_0,h_0,F_1,E_1) 
		\eeql
	where $\stepA$ and $\stepB$ successively
	transforms $E_0$ to an admissible triple and quad.
	By iterating \refeq{stepAstepB} with $E_1$ we can get to
	the next quad $(E_1, h_1, F_2,E_2)$, and so on.  {\em This is
	the basis of most validated IVP algorithms.}
	We encode this as:
		\beql{simpleivp}
			\includegraphics[width=0.8\columnwidth]{figs/simpleivp}
		\eeql
	
	Note that the iteration of \refeq{stepAstepB}
	above is not guaranteed to halt (i.e.,
	to reach $t=1$).  Moreover, we have no control over the length of
	the end-enclosure.
	% \end{Example}
	To address this, define an \dt{$\veps$-admissible triple}
	to be an admissible $(E_0,h,F_1)$ with 	
	\beql{eps-admiss}
	h^k\bff^{[k]}(F_1) \ib[-\veps,\veps]^n
	\eeql
	and extend $\stepA$ to:

	\beql{stepA}
		\includegraphics[width=0.75\columnwidth]{figs/stepA+}
	\eeql
	See \refLem{admiss} for the context of this definition.
	\ignore{
	\Ldent\progb{	
		\lline[-2] $\stepA(E_0,\veps,H)\ssa (h,F_1)$:
		\lline[0] INPUT: $E_0\in\intbox\RR^n$, $0<H\le 1$ and $\veps>0$
		\lline[0] OUTPUT:  an $\veps$-admissible pair $(h,F_1)$
							for $E_0$
		\lline[10]		such that $h\le H$.
	}
	}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Scaffold
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	We introduce a data structure called a ``scaffold'' to encode the
	intermediate information needed for this computation.
	\refFig{explain-D} shows such a scaffold.
	% However, our algorithm will need to repeatedly
	% refine a partial trace of a computation
	% path. 

		\FigEPSissac{explain-D}{0.6}{
			A 7-step scaffold. The horizontal
			axis represents time, and the vertical axis represents
			$\RR^n$. The red curve corresponds to $\bfx(t)$, the blue
			line segments represent end-enclosures, and the green boxes,
			% projected onto the vertical axis,
			represent full-enclosures.
		}

	By a \dt{scaffold} we mean a triple
		$\calD =(\bft,\bfE,\bfF)$
	where
		$\bft= (0\le t_0 < t_1 < \cdots < t_m\le 1)$,
		$\bfE = (E_0 \dd E_m)$,
		and $\bfF = (F_0 \dd F_m)$ such that
		the following holds for all $i=0,1\dd m$:
	\benum
	\item $E_i$ is an end enclosure of
		$\ivp(E_{i-1},t_i-t_{i-1})$  for $i\ge 1$.
	\item $(E_{i-1}, \Delta t_i, F_i,E_i)$ is an admissible quadruple.
		% Call this quadruple the \dt{$i$th-stage} of the scaffold.
	%\item  $Box(E_{i-1}\cup E_i)\ib F_i$.
	\eenum
	
	For $i=1\dd m$, let
			$\Delta t_i\as  t_i-t_{i-1}$
	denote the $i$th \dt{step size}.  Call $\calD$
	an \dt{$m$-stage} scaffold where the $i$th \dt{stage}
	of $\calD$ is the admissible quadruple
			\beql{stage}
				(E_{i-1}, \Delta t_i, F_i, E_i).\eeql
	% The $i$th admissible triple is similarly defined.

	For $i=0\dd m$, the $i$th \dt{state} of $\calD$
	is $\calD[i]=(t_i, E_i, F_i)$.
	Thus, the initial and final states are $\calD[0]$ and $\calD[m]$,
	respectively.
	The \dt{end-} and \dt{full-enclosure} of $\calD$ is $E_m$ and $F_m$
	(respectively).  The \dt{time-span} of $\calD$ is the interval
	$[t_0,t_m]$, and $t_m$ is the \dt{end-time} of $\calD$.

\savespace{
	\bobs
	For any $m$-stage scaffold $\calD$, its end-enclosure
	$E_m$ is the end-enclosure for the $IVP(E_0,t_m-t_0)$.
	\eobs
	}%

	%%%
	In general, a state $(t',E',F')$ is called a \dt{refinement} of
	$(t,E,F)$ if $t=t'$ and $E'\ib E$ and $F'\ib F$.
	A $m'$-stage scaffold $\calD'$
	is called a \dt{refinement} of $\calD$ if 
	for any $i=0\dd m$, 
	there exists $j=0\dd m'$ such that
	$\calD'[j]$ is a refinement of $\calD[i]$.
	A $m'$-stage scaffold $\calD'$
	is called a \dt{extension} of an $m$-stage $\calD$ if $\calD$ is a
	prefix of $\calD'$ and $m'>m$.
	%%%
	An $m$-stage scaffold $\calD$
	is \dt{$\delta$-bounded} if for all $i=1\dd m$ we have:

	\beql{deltabound}
		\wmax(E_i)\le \wmax(E_{i-1})
			\cdot e^{\mu_2(J_{\bff}(F_i))(t_i-t_{i-1})}+2\delta.
	\eeql

	Next, we introduce the algorithm \Extend.
	
	% use image to get equation number!!!
		\beql{extend}
			\includegraphics[width=0.75\columnwidth]{figs/extend}
		\eeql


	\ignore{%
	\Ldent\progb{
		\lline[-2] 
			\Extend$(\calD, \veps,\delta, H)$ 
				$\ssa(\veps',\delta', \calD')$
		\lline[3] INPUT: A $\delta$-bounded $m$-stage scaffold $\calD$,
			$\veps>0$
		\lline[3] OUTPUT:  $\calD'$ is a $m+1$-stage 
		refinement of $\calD$,
		\lline[8]	 such that $\calD'$ is $\delta'$-bounded and
		\lline[8]	 $\wmax(E_{m+1})\le \veps'$
				and $t_{m+1}(\calD')\le t_{m}(\calD)+H$.
		}
	}%

	To bound the length of the end enclosure, we refine \(\calD\)
	whenever \(\wmax(E_m) > \veps\). 
		The interface for this \Refine\ algorithm is as follows:
	
	% use image to get equation number!!!
		\beql{refine}
			\includegraphics[width=0.75\columnwidth]{figs/refine}
		\eeql

	\ignore{%
	\Ldent\progb{
		\lline[0] $\Refine(\calD, \delta, \veps) \ssa(\delta',\calD')$  
		\lline[5] INPUT: A $\delta$-bounded  $m-$step scaffold $\calD$,
				$\delta>0,\veps>0$.
		\lline[5] OUTPUT:   
			$\delta'\le \delta$ and $\calD '$ is a $\delta'$-bounded
			$m'$-stage
		\lline[25] scaffold satisfies $\wmax(E_{m'})\le \veps.$}
	}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\ssect{The Radical Transform: Key Lemma}
\input{inc/radical-xform}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	

















%%%%%%%%%%%%%%%%%%%%%% THE END -- EXTRA STUFF %%%%%%%%%%%%%%%%%%%%%%%%%%
	%	
	%	In addition, we provide an additional algorithm, referred to as Step
	%	A+: it iteratively reduces the parameters $\veps_1$ and $\delta$,
	%	repeating Step A until the resulting admissible pair passes
	%	\texttt{Verifyfull}$F_0$ and satisfies $h > \delta$, where 
	%	\texttt{Verifyfull}($F_0$) is macro used to verify some conditions
	%	for $F_0$. 
	%	
	%	\Ldent\progb{
	%		\lline[0] StepA+$(\delta,\veps,\calD )$  
	%		\lline[5] INPUT: $\bff$,  $\delta>0$, $\veps>0$,  $\calD $, $k>0$. 
	%		\lline[5] OUTPUT: $(\delta_0,\calD ',h>0,B)$,
	%				where $\delta_0\le \delta$, $\calD '$
	%		is $\delta_0-$ controlled, $(h,B) $ is the admissible pair.
	%		\lline[5] $\veps_1\ass \veps$.
	%		\lline[5] 	$(h,F_1 ) \ass$ \texttt{StepA}($\veps_1,\calD $) 
	%		\lline[15] While $Verifyfull(F_0)= 'false'$
	%		\lline[20]	$\delta\ass \frac{\delta}{2}$,
	%					$\veps_1\ass \frac{\veps_1}{2}$. 
	%		\lline[20] $\calD \ass$ Update$(\delta,\calD )$
	%		\lline[20] $(h,F_1)\ass$ \texttt{StepA}($\veps_1,\calD $).
	%		\lline[15] 	 While $h<\delta$  
	%		\lline[20] 	$\delta\ass \frac{\delta}{2}$. 
	%		\lline[20] $\calD \ass$ Update$(\delta,\calD )$
	%		\lline[20]  $(h,F_1)\ass$ \texttt{StepA}($\veps_1,\calD $).
	%		
	%		\lline[15] Return 
	%		$(\delta,\calD ,h,F_1 )$.
	%	}
	%	
	%	Next we consider our \texttt{Step B} algorithm.
	%	
	%
	%	
	%	In addition, we provide an additional algorithm, referred to as \texttt{StepB+} to ensure that the length of each end enclosure in $\calD '$ is less that $\veps$.
	%	
	%	
	%	\Ldent\progb{
	%		\lline[0] StepB+$( F_0,h,\delta,\calD )$  
	%		\lline[5] INPUT: $\bff$, $(h,F_1)$, $\delta>0$, $\veps$,  $\calD $,    
	%		\lline[5] OUTPUT: A value $\delta_0 \le \delta$ and $\calD '$
	%		\lline[5]	such that $\calD '$ is $\delta_0-$ controlled. 
	%		\lline[5] The length of each end enclosure in $\calD '$ is less that $\veps$.
	%		\lline[15] $c\ass \mu_2(J_{\bff}(F_0))$, $\delta_0\ass \delta$.
	%		\lline[15] $E_0, T$ are the last item of $G_{end},\bft$,respectively. 
	%		$r_0\ass \frac{length(E_0)}{2}$.
	%		\lline[15] While $r_0 e^{ch} +\delta_0 > \frac{\veps}{2}$
	%		\lline[20]  $ \delta_0\as \frac{\delta_0}{2}$,
	%		$\calD \ass$ Update$(\delta_0,\calD )$, 
	%		$E_0$ be the last item of $G_{end}$, $r_0\ass \frac{length(E_0)}{2}$.
	%		\lline[15] ($\calD ',\delta_0)\ass StepB(E_0,\delta_0,F_0,h)$
	%		\lline[15] $\calD \ass \calD;\calD '$.
	%		\lline[10] Return ($\delta_0,\calD $).
	%		
	%	}

%%%%%%%%%%%%%%%%%%%%%%%%%%%% REMOVED
	%The sub-algorithm \texttt{Shrink} in \texttt{Step B} as:
	
	
	
	%\Ldent\progb{
	%	\lline[0] Approximatepoints($E_0,\delta,F_0,h$)
	%	\lline[5] INPUT: $\bff$, $(h,F_1)$, $\delta>0, E_0$, where $(h,F_1)$ is an admissible pair for $E_0$.   
	%	\lline[5] OUTPUT: A step size $h_1<h$ and a point list $L=(\bfq_0\dd\bfq_{\lceil h/h_1 \rceil})$ satisfy:
	%
	%	\lline[5] $\bfq_{\lceil h/h_1 \rceil}$ is a $\delta$-distance point at time $h$. 
	%	\lline[5] For each $i=1\dd \lceil h/h_1 \rceil-1$, $\bfq_i$ is a $\delta$-distance point at time $ih_1$. 
	%
	%	
	%}
	
	%
	%\textbf{Step A:} 
	%Let $E_0$ and $T$ represent the last elements of $G_{end}$ and $\bft$, respectively. We then call \texttt{AdmissiblePair}($E_0,1 - T,\veps_1$) to obtain an $\veps$-admissible pair $(h,\ol{F_0})$, where $h$ is the step size  and $\ol{F_0}$ a full enclosure for $\bfx\in\ivp(\bfp_0,1)$ restrict to $[T,T+h]$.
	%
	%\textbf{Step A+:}
	%If $h \leq \delta$, we update $\delta \leftarrow \frac{\delta}{2}$, call \texttt{Update()} to compute new $\delta$-controlled $\calD $ and repeat the step.
	%
	%\textbf{Step A++:}
	%We call \texttt{Verifyfull}($\ol{F_0}$) to check whether the 
	%full enclosure $\ol{F_0}$ satisfies some conditions, which we will
	%introduce later.
	%If these conditions are not satisfied, we reduce $\delta \leftarrow \frac{\delta}{2}$ and $\veps_1 \leftarrow \frac{\veps_1}{2}$, call \texttt{Update}( $\calD ,\delta$), and repeat step A.
	%
	%
	%
	%\textbf{Step B:} 
	%In this step, we first compute a step size to $h_1 \leq h$. Then the time interval $[t_0, t_0 + h]$ is then subdivided into $\lceil \frac{h}{h_1} \rceil$ smaller segments:
	%
	%\[
	%[t_0, t_0 + h_1], \ldots, [t_0 + h - \lfloor \tfrac{h}{h_1} \rfloor h_1, t_0 + h].
	%\]
	%
	%For each subinterval, we compute both an end enclosure and a full enclosure. 
	%
	%\textbf{Step B+}
	%We  check whether the length of each end enclosure  less than $\veps$.
	%If this condition is not met, we update $\delta \leftarrow \frac{\delta}{2}$, call \texttt{Update}( $\calD ,\delta$), and repeat step B.
	%
	
	
	%\textbf{Step A: (Admissible Pair Computation)}
	%
	%\textbf{1. Inputs}:
	%\begin{itemize}
	%	\item $ E_0 $: The current enclosure, representing the last element of the set $ G_{end} $.
	%	\item $ T $: The final time value in the vector $ \bft $,
	% representing the current time step.
	%	\item $ \veps_1 $: The initial precision parameter.
	%	\item $\delta$: The initial step size parameter.
	%\end{itemize}
	%
	%\textbf{2. Outputs}:
	%\begin{itemize}
	%	\item $\delta$: A step size parameter.
	%	\item $\delta$-controlled $\calD $.
	%	\item $h$: The step size satisfies $h> \delta$.
	%	\item $\ol{F_0}$: A full enclosure for $ \bfx \in \ivp(\bfp_0, 1) $
	% restricted to the interval $ [T, T + h] $ and satisfies 
	%	some conditions (to be defined later).
	%\end{itemize}
	%
	%\textbf{3. Procedure}:
	%\begin{itemize}
	%	\item Call \texttt{AdmissiblePair}$(E_0, 1 - T, \veps_1)$ to
	% compute an $ \veps_1 $-admissible pair $ (h, \ol{F_0}) $, where:
	%	\begin{itemize}
	%		\item $ h $: The computed step size for the interval.
	%		\item $ \ol{F_0} $: The full enclosure for $ \bfx \in \ivp(\bfp_0, 1) $ restricted to the interval $ [T, T + h] $.
	%	\end{itemize}
	%\end{itemize}
	%
	%\textbf{ (Full Enclosure Verification)}:
	%\begin{itemize}
	%	\item Call \texttt{Verifyfull}$(\ol{F_0})$ to check if the full enclosure $ \ol{F_0} $ satisfies certain conditions (to be defined later).  If these conditions are not met, update both $ \delta \leftarrow \frac{\delta}{2} $ and $ \veps_1 \leftarrow \frac{\veps_1}{2} $, call \texttt{Update}($\calD , \delta$), and repeat Step A.
	%\end{itemize}
	%
	%\textbf{ (Step size Control)}:
	%\begin{itemize}
	%	\item If $h\le \delta$ then update $ \delta \leftarrow \frac{\delta}{2} $, and call \texttt{Update($\calD , \delta$)} and repeat Step A.
	%\end{itemize}
	%
	%
	%
	%
	%\textbf{Step B: Subdivision of the Time Interval}
	%
	%\textbf{1. Inputs}:
	%\begin{itemize}
	%	\item $ (h, \ol{F_0}, \delta, \calD ) $: The output of Step A.
	%	\item $ \veps > 0 $: The desired precision.
	%\end{itemize}
	%
	%\textbf{2. Outputs}:
	%\begin{itemize}
	%	\item $ \delta_1, \calD  $: $ \delta_1\le \delta $ and a $ \delta_1 $-controlled $ \calD  $ such that the length of each end enclosure in $ \calD  $ is less than $ \veps $.
	%\end{itemize}
	%
	%\textbf{3. Procedure}:
	%\begin{itemize}
	%	\item Compute a smaller step size $ h_1 $ such that $ h_1 \leq h $.
	%	\item Subdivide the time interval $ [t_0, t_0 + h] $ into $ \left\lceil \frac{h}{h_1} \right\rceil $ subintervals:
	%	\[
	%	[t_0, t_0 + h_1], \ldots, [t_0 + h - \left\lfloor \frac{h}{h_1} \right\rfloor h_1, t_0 + h].
	%	\]
	%	\item For each subinterval, compute both an end enclosure and a full enclosure for the solution.
	%\end{itemize}
	%
	%\textbf{(End Enclosure Check)}:
	%\begin{itemize}
	%	\item Verify whether the length of each end enclosure is less than the predefined precision $ \veps $. 
	%	\item If this condition is not satisfied, update $ \delta \leftarrow \frac{\delta}{2} $, call \texttt{Update}($\calD , \delta$), and repeat Step B.
	%\end{itemize}
	%
	%
%%%%%%%%%%%%%%%%%%%%%% THE END OF EXTRA STUFF %%%%%%%%%%%%%%%%%%%%%%%%%%
