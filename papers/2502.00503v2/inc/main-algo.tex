% file: main-algo.tex
%    Taken from shrink3.tex

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\sect{The End-Enclosure algorithm and Experiments}
	The following is our algorithm to
	solve the \endEncIVP\ problem of \refeq{endEncProb}:
	
	{\small
	\Ldent\progb{\label{alg:endEnc}
		\lline[0]  \endEncAlgo($B_0, \veps) \ssa(\ulB_0, \olB_1)$:
		\lline[5] INPUT: $\veps>0, B_0\in \intbox\RR^n$
		\lline[10] such that $IVP(B_0,1)$ is well-defined.
		\lline[5] OUTPUT:	$\ulB_0,\olB_1 \in \intbox\RR^n$,
							$\ulB_0\ib B_0$, $\wmax(\olB_1)<\eps$
		\lline[10] 			and $\olB_1$ is an end-enclosure of
							$\IVP(\ulB_0,1)$.
		\lline
		\lline[15] $\calD\ass 	
					((0),(B_0),(B_0),(Id,\bff,0,0,\veps,0,
					(B_0,B_0),(B_0)))$.
		\lline[15]  $(t,\delta,i)\ass (0,\veps,0)$, $h\ass0, 
						H\ass 1$.
		\lline[15] while $h<H$ 
		\lline[20] $h\ass \stepA(B_0,\veps,H), H\ass \half H$.
		\lline[15] While $t<1$ 
		\lline[20] $\calD.\Extend(\veps,\delta,H)$.
		\lline[20] $\calD.\Refine(\veps)$.
		\lline[20] $t\ass t_{i+1}(\calD)$. $i\ass i+1$.
		\lline[15] return $( E_0(\calD),  E_i(\calD))$.
		
		 
		
	}}
	
	
	\bthml[correct-main]
	Algorithm $\endEncAlgo(B_0, \veps)$ is correct.
	\ethml

	\savespace{
	\bpf
	
	If the algorithm terminates, its correctness is ensured by the
	conclusions in \refSec{stepAB}.
	
	We now proceed to prove the termination of the algorithm. Specifically,
	we need to show that the loop in the algorithm can terminate, which
	means that the time variable $ t $ can reach $ 1 $. 
	
	To establish this, it suffices to demonstrate that for given inputs $
	B_0 $ and $ \veps > 0 $, there exists a positive lower bound for the
	step size, denoted by $ \ul h > 0 $, such that for any $ i > 0 $ in the
	loop, the step size $ h_i = t_{i+1} - t_i $ satisfies $ h_i \geq \ul h
	$.
	
	Consider the state of the scaffold $ \calD $ after the $ i $-th
	iteration of the loop. At this stage, $ \calD $ is an $ i $-step
	scaffold. By the design of the $\Extend$ algorithm, we have 
	\[
	(h_i, F_i) \ass \stepA(E_{i-1}, \veps, 1 - t_{i-1}).
	\]
	 
	
	Since $ \wmax(E_{m-1}) \leq \veps $, let $ \bfx_c \in \ivp(m(B_0), 1)
	$. Then, it holds that 
	\[
	E_{m-1} \ib \bfx_c(T_i) + [-2\veps, 2\veps]^n.
	\]
	
	By \reflem{veps-admisspair}, if 
	\[
	(h(t), F(t)) \ass \stepA\big(\bfx_c(t) + [-2\veps, 2\veps]^n, \veps, 1
	- t\big),
	\] 
	then $ h(t_i) \leq h_i $.
	
	Define 
	\[
	\ul h \ass \min_{t \in [0, 1]} h(t).
	\]
	Since $ h(t) > 0 $ for all $ t \in [0, 1] $,  we conclude that $ \ul h
	> 0 $. 
	
	Thus, for any $ i > 0 $ in the loop, the step size satisfies $ h_i =
	t_{i+1} - t_i \geq \ul h $. This ensures that the loop will terminate
	in a finite number of iterations.
	\epf
	}% savespace
    
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\ssect{Experiments}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		We implemented \ourAlgo\ in \Cpp.
	Our implementation follows the explicitly described
	subroutines in this paper.  There are no hidden hyperparameters
	(e.g., our step sizes are automatically adjusted).
	The only caveat is that we use machine precision:
	this is necessary to have fair comparisons to existing software.
	In principle, we can implement
	our algorithm using arbitrary precision number type
	(which will automatically get a hit in performance
	regardless of precision).
	%%
	Our timings are based on a laptop with a 
	13th Gen Intel Core i7-13700HX 2.10 GHz processor and 16.0 GB RAM.
	Our eventual code will be open-sourced in \cite{core:home}.
	
	
	The example are taken from \refTab{problems} with
	given $(\bff, B_0)$.
	The time span is $t\in [0,1]$ in all the experiments
	except for Eg1-b, where $t\in [0,5.48]$.  This is
	an example that AWA cannot solve \cite[p.~13]{bunger:taylorODE:20}.
	
	
	For each example, we use our algorithm to compute a scaffold
	$\calD(\veps_0)$ for an initial value of $\veps_0$.
	We subsequently
	refine this scaffold using smaller $\veps_i$ ($i=1,2,\ldots$)
	to obtain $\calD(\veps_1)$, $\calD(\veps_2), \ldots$.
	The total number of mini-steps in all the stages of
	$\calD(\veps_i)$ is shown in column
	$\#(\calD)$; the timing for
	each refinement is incremental time.
	% However, when $\#(\calD)$ is relatively small,
	% our \Refine\ algorithm runs efficiently.
	This nice refinement feature gives
	us to better precision control with
	low additional cost after the initial $\calD$.  
	
	
	
	\begin{table*}[h!]
		{\tiny
			\centering
			\begin{tabular}{c|c|c|c|c|c|c|c}
				\hline
				\textbf{Case} & \textbf{Method} & $\veps$ 
				& \textbf{Order} & $\ulB_0$ & $\olB_1$
				& $\#(\mathcal{D})$ & \textbf{Time (s)} \\
				\hline
				Eg1-a & Ours & $0.3$
				& 3 & $Box_{(1.0,3.0)}(0.1)$ & $[0.03,0.12]\times[1.31,1.59]$
				& 27 & 3.297 \\
				& \Refine & $0.1$
				&  & $Box_{(1.0,3.0)}(5.0\times 10^{-5})$
				& $[0.03,0.12]\times[1.41,1.50]$ & 6273 & 4.453 \\
				& \Refine & $0.007$
				&  & $Box_{(1.0,3.0)}(2.0\times 10^{-5})$
				& $[0.07,0.08]\times[1.45,1.46]$ & 6289 & 0.495 \\
				& 	\simpleIVPdirect\  & N/A
				& 3 & N/A & $[-1.00,1.18]\times[0.66,2.25]$
				& N/A & 0.343 \\
				& 	\simpleIVPlohner\ & N/A
				& 3 & N/A & $[0.008,0.093]\times[1.30,1.56]$
				& N/A & 0.015 \\
				& \capdCr\ & N/A
				& 3 & N/A & $[0.05,0.09]\times[1.38,1.54]$
				& N/A & 8.930 \\
				& \capdCr\ & N/A
				& 20 & N/A & $[0.05,0.10]\times[1.37,1.55]$
				& N/A & 0.049 \\
				%& Lohner & / &  & / & $[0.02,0.10]\times[1.35,1.50]$ & -- & 0.182s \\
				\hline
				Eg1-b & Ours & $3.3$
				& 3 & $Box_{(1.0,3.0)}(0.00156)$
				& $[-0.39,2.29]\times[1.37,4.62]$ & 115 & 42.712\\
				& \Refine\ & $1.6$
				&  & $Box_{(1.0,3.0)}(2.3\times 10^{-11})$
				& $[0.16,1.72]\times[2.25,3.81]$ & 231553 & 372.617 \\
				& \Refine\ & $0.6$
				&  & $Box_{(1.0,3.0)}(1.1\times 10^{-11})$
				& $[0.69,1.21]\times[2.77,3.28]$ & 231681 & 15.479 \\
				& \simpleIVPdirect\ & N/A
				& 3 & N/A & \cored{Timeout}
				& N/A & \cored{Timeout} \\
				& \simpleIVPlohner\ & N/A
				& 3 & N/A & \cored{Timeout}
				& N/A & \cored{Timeout} \\
				& \capdCr\ & N/A
				& 3 & N/A & \cored{No Output}
				& N/A & \cored{No Output} \\
				& \capdCr\ & N/A & 20 & N/A & \cored{No Output}
				& N/A & \cored{No Output} \\
				\hline
				Eg2 & Ours & $0.51$ & 3 & $Box_{(-3.0,3.0)}(0.1)$
				& $[-2.38,-1.88]\times[0.37,0.75]$ & 19 & 1.781 \\
				& \Refine\ & $0.26$ &  & $Box_{(-3.0,3.0)}(2\times 10^{-5})$
				& $[-2.15,-2.12]\times[0.54,0.58]$ & 12353 & 10.287 \\
				& \Refine\ & $0.01$ &  & $Box_{(-3.0,3.0)}(1\times 10^{-5})$
				& $[-2.14,-2.13]\times[0.56,0.57]$ & 12353 & 0.868 \\
				& \simpleIVPdirect\ & N/A & 3 & N/A
				& $[-2.74,-1.53]\times[-2.11,3.12]$ & N/A & 1.844 \\
				& \simpleIVPlohner\ & N/A & 3 & N/A
				& $[-2.42,-1.62]\times[0.40,0.72]$ & N/A & 1.566 \\
				& \capdCr\ & N/A & 3 & N/A 
				& $[-2.37,-1.89]\times[0.40,0.72]$ & N/A & 6.097 \\
				& \capdCr\ & N/A & 20 & N/A
				& $[-2.39,-1.87]\times[0.36,0.76]$ & N/A & 0.050 \\
				\hline
				Eg3 & Ours & $0.6$ & 3 
				& $Box_{(-1.5,8.5)}(1.9\times 10^{-6})$
				& $[-0.60,-0.59]\times[-7.08,-6.53]$ & 9237 & 9.511 \\
				& \Refine\ & $0.3$ &
				& $Box_{(-1.5,8.5)}(4.7\times 10^{-7})$
				& $[-0.60,-0.59]\times[-6.80,-6.63]$ & 11729 & 2.641 \\
				& \Refine\ & $0.1$ &
				& $Box_{(-1.5,8.5)}(1.1\times 10^{-7})$
				& $[-0.60,-0.59]\times[-6.72,-6.67]$ & 14785 & 3.259 \\	
				& \simpleIVPdirect\ & N/A & 3 & N/A & \cored{Timeout}
				& N/A & \cored{Timeout} \\
				& \simpleIVPlohner\ & N/A & 3 & N/A & \cored{Timeout}
				& N/A & \cored{Timeout} \\
				& \capdCr\ & N/A & 3 & N/A & \cored{No Output}
				& N/A & \cored{No Output} \\
				& \capdCr\ & N/A & 20 & N/A & \cored{No Output}
				& N/A & \cored{No Output} \\
				
				\hline
				Eg4 & Ours & $9.0$ & 3 & $Box_{(15,15,36)}(8\times 10^{-4})$
				& $[-8.85,-5.04]\times[-1.36,7.35]\times[31.26,39.02]$
				& 32 & 61.673 \\
				& \Refine\ & $3.0$ & & $Box_{(15,15,36)}(8\times 10^{-7})$
				& $[-8.40,-5.48]\times[1.53,4.45]\times[33.68,36.60]$
				& 44033 & 126.665 \\
				& \Refine\ & $1.0$ & & $Box_{(15,15,36)}(5.9\times 10^{-9})$
				& $[-7.42,-6.46]\times[2.51,3.47]\times[34.66,35.62]$
				& 44033 & 27.824 \\
				& \simpleIVPdirect\	& N/A & 3 & N/A & \cored{Timeout}
				& N/A & \cored{Timeout} \\
				& \simpleIVPlohner\	& N/A& 3 & N/A & \cored{Timeout}
				& N/A & \cored{Timeout} \\
				& \capdCr\ & N/A & 3 & N/A & \cored{No Output} & N/A
				& \cored{No Output} \\
				& \capdCr\ & N/A & 20 & N/A & \cored{No Output} & N/A
				& \cored{No Output} \\
				\hline
			\end{tabular}
		}
		\caption{Experiments on \ourAlgo\ and \Refine.}
		\label{tab:main}
	\end{table*}
	
	We compared our algorithm with 3 other algorithms:
	
	1. First, algorithm is from
	the CAPD library \cite{capd-homepage} with source code in github.
	% https://github.com/CAPDGroup/CAPD
	In \refTab{main}, the method \capdCr\ refers to their method
	\ttt{ICnOdeSolver} with order $r=3$ or $20$,
	based on the $C^r$-Lohner algorithm
	\cite{zgliczynski:lohner:02,capd:rigorousDynSys:21}.
	The method accepts an interval input such our $B_0$.
	%%
	%It is not clear that the CAPD algorithm (whose
	%algorithmic details are not described) is validated since it seems
	%difficult to introduce a suitable StepA for the entire cascade of
	%stages in Lohner-style algorithms. 
	% Attempts to provide an adaptive
	% StepA may not halt \cite[p.38, Algorithm
	% 5.3.1]{nedialkov+2:validated-ode:99}. 
	% We use the default CAPD Taylor order of $20$.
	% but it fails to produce any output for
	% Eg1-b, Eg3, and Eg4.
	% In contrast, our method reliably produces results in all cases.  
	
	2 \& 3. We also implemented the \simpleIVP\ algorithm 
	in \refeq{simpleivp}, where \stepB\ is either the 
	Direct method \refeq{stepBdirect} and
	well as our own implementation of the
	the Lohner method. In \refTab{main}, they are called 
	\simpleIVPdirect\ and \simpleIVPlohner, respectively.  
	
	Our table indicates two kinds of error conditions:
	\cored{Timeout} (\simpleIVPdirect, \simpleIVPlohner)
	and \cored{No Output} (\capdCr).
	The former means the code took more than 1 hour to run.
	the latter means the code stopped with no output.
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



