%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{What is Achieved in This Paper}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	We present an algorithm
		$\ourAlgo(B_0,\veps)\ssa(\ulB_0,\olB_1)$
	that solves the above $\endEncIVP(B_0,\veps)$ problem.  It is
	\dt{complete} in that sense that if the input is valid,
	then \dt{(C1)} the algorithm halts, and
	\dt{(C2)} the output $(\ulB_0,\olB_1)$ specifications of \\
	$\endEncIVP(B_0,\veps)$.  Our algorithm do not
	need any extra ``hyperparameters'': we literally
	implement what is described in this paper.
	Algorithms that only satisfy \dt{(C2)}
	are said\footnote{
		Completeness and partial completeness are standard
		terms in theoretical computer science.
	} to be \dt{partially correct}.
	To our knowledge, all current validated IVP algorithms 
	are only partially correct.

	Our preliminary implementation shows the
	viability of \\ \ourAlgo, and
	its ability to do certain computations where
	current validated IVP software fails.

	% Validity of
	% input should ideally be only a syntactic requirement.
	Our $\endEncIVP$ Problem requires the validity 
	of the input $(B_0,\veps)$.  This makes it a 
	\dt{promise problem}
	\cite{goldreich:promise-problems:06}).
	It raises a separate computational issue to check validity.
	To our knowledge, this is an open problem although 
	Some version of such questions are
	undecidable in the analytic complexity framework
	\cite{graca+2:max-intvl-ivp:09, ko:real:bk}.
	%In addition, our IVP algorithm is the first algorithm 
	%to support user-specified error bound.
	%	In this age of AI, the word ``algorithm''  
	%	often refers to heuristics or techniques,
	%	with no pre-determined concept of correctness.
	%The computational complexity literature sometimes
	%appear to claim complete IVP algorithms, but
	%we shall review these claims below.
	Hans Stetter \cite{stetter:validatedODE:90}
	summarized the state-of-the-art over 30 years ago as follows:
	{\em To date, no programs that could be truly called `scientific
	software' have been produced. 
	AWA is state-of-art, and can be used by a sufficiently expert user --
	it requires selection of step-size, order and suitable choice of
	inclusion set represention.}  
	Corliss \cite[Section 10]{corliss:survey-ode-intvl:89}
	made similar remarks.
	% there is no validated IVP software that
	% {\em is ready to be placed
	% in the hands of scientists and engineers for routine use}.
	Unfortunately, the situation has not changed in 30 years.
	The gold standard for Validated IVP software is based on
	Lohner's algorithm
	% remove lohner:thesis to save space
	%\cite{lohner:thesis,moore:diffEqn:09,corliss:survey-ode-intvl:89}.
	\cite{moore:diffEqn:09,corliss:survey-ode-intvl:89}.
	called AWA\footnote{
		AWA is the German term for IVP.
	}. 
	%
	Bunger's recent implementation \cite{bunger:taylorODE:20}
	of AWA in INTLAB/MATLAB \cite{intlab-ref} has greatly  
	improved its usability.  Besides the requisite IVP
	inputs, this software allow input options
	% like Taylor order (which
	% do not affect correctness) but it also has
	such as min-step size \ttt{hmin},
	the absolute and relative error tolerances \ttt{AbsTol}
	and \ttt{RelTol}, and it automatically generates
	a time grid $t_1<\cdots<t_N$
	\cite[p.~8]{bunger:taylorODE:20}.
	These are well-known \dt{hyperparameters} of
	numerical algorithms which
	experienced users may set to
	coax a recalcitrant instance to converge, but no
	guarantees.
	% (e.g., Bunger's AWA provide options such as
	% such as min-step size, max-error tolerance, etc.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% END
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

