\twocolumn
\newpage
\appendix
\section*{Appendix}

\section{Schema-constrained Reasoning}
\label{apdx:schema_constrained_reasoning}

GSM8K:
\begin{minted}
[
fontsize=\footnotesize,
style=autumn,
breaklines
]
{json}
{
  "type": "object",
  "properties":{
    "thought": {
      "type": "string",
      "description": "put your thought here"
    },
    "answer": {
      "type": "number",
      "description": "put your answer here, integer only"
    }
  },
  "required": ["thought", "answer"],
}
\end{minted}

\noindent
MATH500:
\begin{minted}
[
fontsize=\footnotesize,
style=autumn,
breaklines
]
{json}
{
  "type": "object",
  "properties":{
    "thought": {
      "type": "string",
      "description": "put your thought here"
    },
    "answer": {
      "type": "number",
      "description": "put your answer here"
    }
  },
  "required": ["thought", "answer"],
}
\end{minted}

\noindent
MMLU:
\begin{minted}
[
fontsize=\footnotesize,
style=autumn,
breaklines
]
{json}
{
  "type": "object",
  "properties": {
    "thought": {
      "type": "string",
      "description": "put your thought here"
    },
    "answer": {
      "type": "string",
      "enum": ["A", "B", "C", "D"],
      "description": "put your choice here"
    }
  },
  "required": ["thought", "answer"],
}
\end{minted}

\noindent
ARC-Challenge:
\begin{minted}
[
fontsize=\footnotesize,
style=autumn,
breaklines
]
{json}
{
  "type": "object",
  "properties": {
    "thought": {
      "type": "string",
      "description": "put your thought here"
    },
    "answer": {
      "type": "string",
      "description": "put your answer here, Options only, e.g. A",
      "enum": ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"]
    }
  },
  "required": ["thought", "answer"],
}
\end{minted}

\section{Benchmark Prompts}
\label{apdx:schema_bench_prompts}
System prompt template:
\begin{minted}
[
fontsize=\footnotesize,
breaklines
]
{python}
"""You should generate answer with given JSON format.
<Schema> Here are the json-schema of the content format:
{schema}
</Schema>"""
\end{minted}

\noindent
For Complex Schema and Custom Formats, the user prompt is as follow:
\begin{minted}
[
fontsize=\footnotesize,
breaklines
]
{python}
"Please generate a valid JSON object according to the JSON schema. Give your JSON object directly, without ```."
\end{minted}

\noindent
User prompt in Escape Translation:
\begin{minted}
[
fontsize=\footnotesize,
breaklines
]
{python}
"Please generate a valid JSON object according to the JSON schema, remember your special token here: {special_token} Give your JSON object directly, without ```."
\end{minted}

\noindent
As for tasks in Schema-constrained Reasoning, we simply use the query in dataset as the user prompt.


\section{Tool Callings Conversion}
\label{apdx:tool_conversion}
% \noindent\makebox[\linewidth]{\rule{\linewidth}{0.4pt}}
We use the following code to convert tools to a formal JSON schema.
\begin{minted}
[
fontsize=\footnotesize,
breaklines,
linenos
]
{python}
def convert_function_to_schema(functions):
  schema = {
    "$defs": {
      "tools": {
        "description": "Available tools you could use.",
        "oneOf": []
      }
    },
  }
  for func in functions:
    # aligning informal types to standard JSON schema basic data types
    # e.g. 'dict' -> 'object', 'list' -> 'array'
    new_func = recurrsive_convert_type(func)
  schema["$defs"][func["name"]] = {
    "type": "object",
    "description": func.get("description", ""),
    "properties": {
      func["name"]: new_func["parameters"]
    },
    "required": [func["name"]],
    "additionalProperties": False
  }
  schema["$defs"]["tools"]["oneOf"].append({ "$ref": "#/$defs/{}".format(func['name'].replace('~', '~0').replace('/', '~1')) })
  schema["oneOf"] = [
    {
      "type": "array",
      "description": "Calling multiple tools in a array.",
      "items": {
        "$ref": "#/$defs/tools"
      },
      "minItems": 2
    },
    {
      "$ref": "#/$defs/tools"
    },
    {
      "type": "string",
      "description": "If none of the function can be used, point it out here. If the given question lacks the parameters required by the function, also point it out here."
    }
  ]
  jsonschema.Validator.check_schema(schema)
return schema
\end{minted}

\onecolumn