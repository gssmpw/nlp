% \begin{table*}[t!]
% \begin{wraptable}{r}{0.44\textwidth}
\begin{wraptable}{r}{0.42\textwidth}
%     \caption{Feedback categorization in conversational code generation. %Given a state $s$ that an LLM generates a code snippet, $r(s)$ is a reward from a reward function $r(\cdot)$ and $\pi(a|s)$ is an action from a policy $\pi(\cdot): S \rightarrow A$ that maps a state space $S$ to an action space $A$. 
% Our contribution introduces a control knob for execution feedback and natural language feedback, enabling a broader range of realistic scenarios. $\triangle^1$ signifies that only syntax errors can be specified by $f_c$. $\triangle^2$ signifies that only the errors that are located where the provided test cases cover ($f_e$) or by novice-expertise ($f_v$) can be specified. $\triangle^3$ signifies that the guidance for refinement by novice-expertise user might be incorrect. } 
\caption{By providing diverse feedback types, with different coverage levels in  
execution and natural language feedback, ours encompasses a broader range of realistic scenarios. 
$\triangle$ indicates partial coverage (\S\ref{convcodeworld:categorization}) with specific limitations: $^1$Syntax errors only, $^2$Limited by test coverage or feedback provider, and $^3$Potential misguidance due to limited expertise.}
    \centering
    \scriptsize
    % \small
    \begin{tabular}{c|ccc}
        \thickhline
        \multirow{2}{*}{\textbf{Feedback}} &  \textbf{Fault}  & \textbf{Guidance for}  \\
         &  \textbf{Localization}  & \textbf{Refinement}  \\\hline
        $f_c$ & \phantom{0}$\triangle^1$  & \xmark \\
        $f_e$ &  \phantom{0}$\triangle^2$  & \xmark \\ 
        $f_e^*$ & \cmark & \xmark \\
        $f_v$ & \phantom{0}$\triangle^2$ & \phantom{0}$\triangle^3$  \\
        $f_v^*$ & \cmark & \cmark \\
        \thickhline
    \end{tabular}
    \normalsize
    \label{tab:categorization}
% \end{table*}
\end{wraptable}


% \begin{table*}[t!]
%     \caption{Combination of feedback and possible scenarios.} 
%     \centering
%     \small
%     \begin{tabular}{lccc}
%         \thickhline
%         \textbf{Notations} \\\hline
%         $o_t^m = \{x, a_{t-1}^m, c_{t-1}, e_{t-1}, a_{t-1}^u\}$ \\
%         % $b_t^m(s_t) = Pr(s_t|b_0,a_0^m,o_1^m,a_1^m, ..., a_{t-1}^m,o_{t-1}^m) \approx Pr(s_t|a_{t-1}^m,o_{t-1}^m)$ \\
%         $\pi^m: o_t^m \rightarrow \Delta(A^m)$\\
%         \hdashline
%         $o_t^u = \{x, a_t^m, c_t, e_t\}$ \\
%         % $b_t^u(s_t) = Pr(s_t|b_0,a_0^u,o_1^u,a_1^u, ..., a_{t-1}^u,o_{t-1}^u) \approx Pr(s_t|a_{t-1}^u,o_{t-1}^u)$ \\
%         $\pi^u: o_t^u \rightarrow \Delta(A^u)$\\\hline
%         Execution feedback w/ full TC or expert user feedback: $b_t^m(s_t) = 1$ (now it's a Dec-MDP) \\
%         Expert users: $\pi^u(o_t^u) = a_t^{u*}$, reduces the action space of the model $A^m$ into $\hat{A}^{m} \subseteq A^m$\\
        

%         % $o_t^m = \{x, y_{t-1}, f_{t-1}^c, f_{t-1}^e, f_{t-1}^u\}$ \\
%         % $a_t^m = y_{t}$ \\ %\hdashline
%         % $b_t^m(s_t) = Pr(s_t|b_0,a_0^m,o_1^m,a_1^m, ..., a_{t-1}^m,o_{t-1}^m) \approx Pr(s_t|a_{t-1}^m,o_{t-1}^m)$ \\
%         % $\pi^m: o_t^m \rightarrow \Delta(A^m)$\\
%         % \hdashline
%         % $o_t^u = \{x, c_t, f_t^c, f_t^e\}$ \\
%         % $a_t^u = f_t^u$ \\
%         % % $b_t^u(s_t) = Pr(s_t|b_0,a_0^u,o_1^u,a_1^u, ..., a_{t-1}^u,o_{t-1}^u) \approx Pr(s_t|a_{t-1}^u,o_{t-1}^u)$ \\
%         % $\pi^u: o_t^u \rightarrow \Delta(A^u)$\\\hline
%         % Execution feedback w/ full TC or expert user feedback: $b_t^m(s_t) = b_t^*(s_t)$ (an optimal belief state) \\
%         % Expert users: $\pi^u(o_t^u) = \pi^{u*}(o_t^u) = f_t^{u*}$\\        
        
        
%         \thickhline
%     \end{tabular}
%     \normalsize
%     \label{tab:thinking}
% \end{table*}