\section{Introduction}
\label{sec:intro}

\boldunderpara{Ethereum and ERC.}
%\songlh{The background of Ethereum and Solidity.}
Since the creation of Bitcoin, blockchain technology has evolved significantly.
One of the most important developments is Ethereum~\cite{eth-1,eth-2}, a decentralized, open-source blockchain platform. Ethereum enables the creation and execution of decentralized applications (DApps) like financial services and smart contracts, which are self-executing agreements with the terms of the contracts directly written into code~\cite{dapps, sc-anatomy}. 

%\songlh{Briefly discuss what are ERCs and why there are rules. }
To govern smart contracts running on Ethereum, a set of formal standards called Request for Comments (\textit{ERCs}) have been developed~\cite{token-standard}. For example, the ERC20 standard defines a common set of rules for fungible tokens---tokens (digital assets) that are interchangeable with one another~\cite{erc20}. 
ERCs play a crucial role in the Ethereum ecosystem by providing a 
common set of rules and specifications that developers can follow when implementing smart contracts. ERCs ensure interoperability 
and compatibility between different Ethereum-based projects, 
wallets, and DApps~\cite{dapps}. 

\input{figures/fig-erc20-high}

\boldunderpara{ERC violations.}
%\songlh{Issues when ERC rules are violated}
The violation of an ERC rule could result in interoperability issues where a violating contract may not work properly with wallets or DApps. ERC violations could also lead to security vulnerabilities and financial loss. Additionally, ERC violations could result in de-listing of tokens from exchanges, as many exchanges have listing requirements of following ERC standards~\cite{erc-standard}.
%

Figure~\ref{fig:20-high} shows a violation of an ERC20 rule in a real smart contract. 
The \texttt{\_balances} field in line 2 monitors the number of tokens held by each 
address. Function \texttt{transferFrom()} in lines 6--10 transfers
\texttt{amount} tokens from one address to another. 
%, as evidenced by the reduction \texttt{from}’s value in \texttt{\_balances} in line 14 and the increase of \texttt{to}’s value of in \texttt{\_balances} in line 15. 
%After the contract is deployed to 
%Ethereum, \texttt{transferFrom()} can be invoked by anyone through a message call.
ERC20 imposes multiple rules on \texttt{transferFrom()}, such as the necessity to fire an \texttt{Transfer} event for logging purposes and to
treat the transfer of zero tokens the same as transferring other amounts, both of which the contract follows. % to ensure consistent contract behavior. 
%Apparently, the contract adheres to both rules. 
However, \texttt{transferFrom()} violates a crucial ERC20 rule that mandates \texttt{transferFrom()} to verify whether its caller has the privilege to transfer \texttt{amount} tokens, which ensures financial security. 
Due to this violation, anyone can steal tokens from any address by invoking \texttt{transferFrom()} to transfer tokens to his address. 
The patch in line 7 illustrates how to fix the violation. 
The patch uses a two-dimensional map, \texttt{\_allowances}, to track
how many tokens ``\texttt{from}'' allows ``\texttt{msg.sender}'' to manipulate. 
The subtraction operation in this line triggers an exception 
and the termination of the transaction in case of underflow, thus preventing a caller 
of the function from transferring tokens if they do not have enough privilege.





\boldunderpara{State of the art.}
Following ERC rules is crucial, but developers often struggle due to the need for a thorough understanding of all the requirements and corresponding contract code. 
ERC standards encompass numerous rules; for the three ERCs we examine,
there are 132 rules in total. 
A single operation can involve multiple rules. 
For example, ERC20 requires that 
the public \texttt{transferFrom()} function of all ERC20 contracts 
comply with six rules, covering the function’s API, 
return value generation, caller privilege validation, 
logging, and input handling. The failure to check caller privileges 
leads to the issue above. 
Additionally, ERC rules are often described in different formats, 
with some being code declarations and others being natural languages, 
further complicating compliance.



Meanwhile, contract implementations are often complex as well. 
One contract and its dependent code
usually contain hundreds to thousands of lines of source code in multiple files.
Some code details may be obscured within intricate 
caller-callee relationships, while others may involve numerous 
objects and functionalities possibly written by different 
programmers. All these complexities in ERC rules and smart 
contracts make it extremely hard for programmers to manually 
check for ERC violations. As a result,
ERC rule violations widely exist in real-world smart contracts~\cite{humanaudited}.


Today's practices to avoid ERC violations are on three fronts. 
First, program-analysis tools have been developed to 
automatically verify certain criteria of smart contracts~\cite{slither-erc,erc20-verifier,ZepScope,VerX,ERCx}. 
These tools are limited by the types of verifications they can perform, 
and often fail to validate many complex ERC requirements like the rule 
violated in Figure~\ref{fig:20-high}.
A fundamental reason 
is that many 
ERC rules involve semantic information (\eg, caller privileges) 
and require customization for individual contracts (\eg, configuring where
caller privileges are stored)---a process that is time-consuming if 
not unfeasible. 
Second, there are several auditing services 
provided by security 
experts~\cite{certik,revoluzion,pixelplex,blockhunters, immunebytes, antier,humanaudited}.
Although auditing services are more thorough and 
comprehensive than program-analysis tools, 
they are often costly and involve lengthy processing time, likely involving manual efforts behind the scenes.
Third, there have been some primitive proposals to rely exclusively on large language models (LLMs) to check 
smart contracts for ERC compliance~\cite{GPT-RyanHarvey,GPT-MichaelDNorman}.
Unfortunately, these techniques suffer from LLMs’ hallucinations and have high false positives and false negatives, as shown in our
experiments.





%\vspace{0.05in}
%\noindent \textit{Are there any cheaper, automated, thorough, and accurate
%ERC rule verification methods?}
%\vspace{0.05in}

%\commentty{rearranged and rephrased some text. Please double check.}

\boldunderpara{Our proposal.}
%
The goal of this research is to develop a cheaper, automated, thorough, and accurate ERC rule verification approach. 
%
We believe that a well-structured method is grounded in a deep understanding of ERC rules. To this end, 
we commence our work with an empirical study of ERC standards. Specifically, we analyze three 
widely-used ERC standards and their 132 rules, 
focusing on the nature of these rules, the 
security implications of their non-compliance, and their articulation in natural language. 
Our study reveals four key insights that are valuable for Solidity developers, security analysts, and 
ERC protocol designers. Notably, we find that approximately one-sixth of ERC rules are dedicated to 
verifying whether an operator, token owner, or token recipient has the necessary privileges to perform 
specific operations. Violations of these rules can create clear attack paths, potentially leading to 
significant financial losses (\eg, Figure~\ref{fig:20-high}). 
In addition, we discover that most 
ERC rules can be validated within a single function, 
and we identify recurring linguistic patterns used 
to describe these rules.







\if 0
%
This paper addresses the above research question by introducing \emph{\Tool}, 
a tool that integrates an LLM with symbolic execution to verify ERC rule compliance. 
The core idea is to harness LLMs’ natural language understanding 
to automatically configure symbolic execution for inspecting smart contracts 
against ERC rules with formal guarantees. 
Although the concept is straightforward, 
three key challenges must be overcome for it to be effective.
\textbf{\textit{Challenge I}}: How can we design \Tool{} to ensure comprehensive audit coverage of ERC rules that encompass many different aspects of smart contracts?
\textbf{\textit{Challenge II}}: 
How can we mitigate the LLM's hallucinations when 
it translates ERC rules written in natural languages to a form that symbolic execution can then apply?
\textbf{\textit{Challenge III}}: How can we generalize \Tool{} to support the diverse implementations of smart contracts? 




This paper answers this research question by developing \emph{\Tool}, 
a tool that leverages large language models (LLMs) to interpret ERC rules 
expressed in natural language and perform symbolic execution to detect 
rule violations with formal guarantees. 
\commentty{Insights of LLMs+SE? How does it relate to a cheaper, automated, thorough, and accurate
design? How are LLMs hallucinations addressed?}
\shihao{
   LLM's cost and accuracy is heavily influenced by the lines of code of the smart contracts. In order to have a cheaper and accurate solution, reducing the proportion of leveraging LLM is necessary. Run LLM once on the target ERC, the generated constraints can be shared with the symbolic engine to audit all smart contracts from the same ERC without LLM involving anymore, no matter lines of code, which dramatically lower the cost and improve the accuracy.
}
%
%
It is not straightforward to build \Tool{}, 
we have to overcome three primary obstacles.
%
\textbf{\textit{Challenge I}}: 
Since ERC rules cover various aspects of smart contracts, 
how can we design \Tool{} to ensure comprehensive auditing coverage?
\textbf{\textit{Challenge II}}: 
Given that most ERC rules are written in natural language, 
how can we translate them into a format that guides symbolic execution 
for auditing purposes?
\textbf{\textit{Challenge III}}: Considering the diversity of smart contracts, how can we avoid customization while enabling \Tool{} to analyze all contracts 
in the same ERC standard?
\fi


\if 0
This paper answers this research question in the affirmative by building \emph{\Tool}, 
a tool that leverages large language models (LLMs) \shihao{and symbolic execution} to automatically audit smart contracts for ERC compliance. 
% LLMs like ChatGPT have seen tremendous success in recent years and have 
%demonstrated their capabilities in many areas including natural language understanding, language translation, questions-and-answers, content generation, etc. LLMs have also 
%been used in programming-language-related tasks like bug finding~\cite{sun2023gpt}, malware detection~\cite{csahin2021malware}, 
% and program repairing~\cite{xia2023keep, ibbaleveraging}. %\yiying{fill these references and probably more PL-related use of LLM.}
% However, as far as we know, there has been no exploration of LLMs in rule auditing, such as ERC compliance auditing.
%\commentty{or general rule auditing?} \shihao{Yes, I cannot find other paper for using LLM to do general rule auditing} 
% The use of LLMs in ERC auditing introduces several new challenges.
% First, there are many ERC rules with different natures and specified in different natural languages. 
% It is unclear how to represent them effectively to an LLM.
% Second, most ERC rules are specific to program semantics. Thus, we need a good representation of smart-contract code to an LLM.
% Third, LLMs largely work as black boxes during the auditing process, and their
% effectiveness largely depends on the prompts employed.
%How can we devise appropriate prompts to enhance the effectiveness of LLMs?

%\yiying{above correct? any other challenges?} \shihao{Another challenge is automating the auditing process?}
%\commentty{are there any existing LLM-based approaches for rule auditing other than ERC? Why is ERC so unique, or can our approach be generalized to handle other kinds of rules?} \shihao{NO? ERC is so unique because Ethereum is the most popular platform for smart contracts and ERCs are the standards for them. Other kinds of rules may include protocols or standards, like TCP, UDP, JVM, etc? or even simply the rules in the function(other programming languages) comment.}

\commentty{It would be clearer if we numbered these challenges and matched them with their corresponding solutions.} 
\shihao {
  To thoroughly, automatically, and cost-efficiently verify whether a smart contract is compliant with the ERC, there are several chanllenges need to be addressed. 
  
  First, how to automatically identify rules from the ERC written by the natural language? An ERC contains not only the rules, but also many other supplemental information like introduction, motivations, background, etc.. Furthermore, there are no limitation on language pattern for ERC submitter to demonstrate the rules.
  
  Second, how to automatically translate the rules into program-understandable constraints is challenging due to the inherent ambiguity and variability of natural language. Extracting precise logical conditions from natural language descriptions often requires advanced natural language processing techniques and domain-specific knowledge.

Lastly, how to leverage the constraints to thoroughly find violations is complicated by the exponential growth of possible execution paths in a smart contract. Efficiently exploring all relevant paths while ensuring coverage of potential violations requires sophisticated strategies to balance completeness with computational feasibility.
}

\fi



Leveraging the insights gained from our empirical study, 
we introduce \Tool{}, 
%a novel tool that harnesses the combined strengths of large language models (LLMs) and symbolic execution to automate the entire ERC rule verification process. 
a novel tool that combines the strength of 
large language models (LLMs) for natural language understanding 
with the formal guarantees of symbolic execution for code analysis, 
to automate the entire ERC rule verification process.
This endeavor involves addressing three critical technical challenges:
\textbf{\textit{Challenge I}}: How can \Tool{} be designed to handle the diverse program semantics (\eg, 
permission checking, logging, input handling) 
involved in ERC rules?
\textbf{\textit{Challenge II}}: How can we better utilize the LLM to reduce hallucinations while maintaining full automation?
\textbf{\textit{Challenge III}}: 
Given that different contracts may implement 
the same ERC rules in various ways, how can we generalize \Tool{} to support these diverse implementations?

To tackle these challenges, we develop an Extended Backus-Naur Form (EBNF) grammar to 
formalize ERC rules using code constructs (\eg, contract fields) and contract execution events (\eg, burning tokens). This grammar empowers \Tool{} to carry out 
program analysis tasks for verifying ERC compliance in a comprehensive manner
and effectively addresses \textit{Challenge I}.
For \textit{Challenge II}, we instruct the LLM to extract rules from descriptions pertaining to 
individual functions or events rather than from the entire ERC document. 
Once the rules are extracted, we direct the LLM to convert them into the EBNF grammar,
which we subsequently transform into constraints for the symbolic execution engine. 
This two-step process significantly narrows the LLM's output space, as it is bounded by the more limited grammar rather than by the broader constraints, consequently reducing the statistical variability and uncertainty associated with the LLM’s output.
To resolve \textit{Challenge III}, we define multiple constraint-variable types 
that represent generic contract execution states and 
implement corresponding update mechanisms in the symbolic execution engine. 
These innovations effectively mitigate implementation variations 
across different contracts, eliminating the necessity 
for contract-specific customization and distinguishing \Tool{} from 
existing symbolic execution techniques~\cite{klee,S2E,SymCC}.
To the best of our knowledge, no prior work addresses ERC requirements 
as comprehensively as ours.




\if 0


%and notice a correlation between the natural language specification of a rule and its implementation.

We then develop \Tool{} guided by the insights from our empirical study. 
Specifically, we designed an EBNF grammar to formalize ERC rules using code constructs (\eg, function parameters) that are either explicitly required by the ERCs 
or commonly used by smart-contract developers. 
This grammar enables downstream program analysis tasks to 
accommodate most ERC rules, effectively addressing \textit{Challenge-I}.
%
We design prompts to guide an LLM in automatically extracting 
rules from ERC documents and translating them into the EBNF grammar. 
Instead of using the LLM to analyze the vast number of smart contracts 
or to generate constraints that can be directly used as configurations 
for symbolic execution, we focus on using the LLM to formalize the rules 
embedded in ERC documents using the EBNF grammar. 
By positioning the grammar between natural language 
and smart contract code, this approach reduces \Tool{}’s statistical variability 
and uncertainty, effectively addressing \textit{Challenge II} and setting it apart from techniques that rely solely on LLMs~\cite{GPT-RyanHarvey,GPT-MichaelDNorman}.
%
To address \textit{Challenge-III}, we define multiple constraint-variable 
types to represent generic contract execution states, 
and use these variable types to synthesize 
constraints that indicate when rule violations occur (violation constraints) from the formalized ERC rules. 
We further specify how these variables should be updated during symbolic execution. 
Identifying ERC rule violations 
is then reduced to finding values for constraint variables 
that satisfy the 
violation constraints. 
These mechanisms 
effectively eliminate implementation differences across contracts and the need for customization.

\fi






\if 0

Second, we design and implement \Tool{} based on three principles.
\textit{Divide and conquer}: We split the auditing process into a startup 
phase for automatically extracting rules from ERCs and a working phase for inspecting individual contracts. 
Additionally, we divide large contracts into small code segments 
and instruct LLMs to inspect each segment individually against a 
specific rule to focus their attention.
\textit{Guided by our study}: We separate each individual contract based 
on its public functions. We leverage identified linguistic 
patterns as one-shot examples during ERC rule extraction.
\textit{Specialization}: We create specialized questions for each type of 
rules and automate the process from ERC rule extraction to 
generating specialized prompts using our designed informative 
YAML format. Furthermore, we craft one-shot Solidity code 
examples for specific rules to enhance LLMs' auditing effectiveness.
The mechanisms employed in \Tool{} can serve as inspiration for 
future researchers exploring the application of LLMs in other 
programming-language-related tasks.

\fi


We evaluate \Tool{} using three datasets: 
a large dataset of 4,000 contracts randomly selected from etherscan.io~\cite{etherscan} and polygonscan.com~\cite{polygonscan}, 
a ground-truth dataset of 40 contracts with violation 
labels (created by us), and a third containing ten contracts of 
an ERC not studied previously.
%
\Tool{} detects 5,783 ERC rule violations in the large dataset, 
with 1,375 exhibiting a clear attack path 
leading to potential financial losses (one is shown in Figure~\ref{fig:20-high}). 
The true-positive-to-false-positive rate is approximately 3.8. 
Overall, \Tool{} is effective and accurate in identifying ERC violations.
%
We compare \Tool{} against two automated static analysis techniques~\cite{slither-erc,ZepScope}, 
one dynamic testing technique~\cite{ERCx}, 
three ChatGPT-based auditing approaches, 
and one human auditing service~\cite{humanaudited} using the ground-truth dataset. 
\Tool{} detects at least 70\% more violations than all the baselines, 
while reporting fewer or comparable false positives, 
demonstrating its superiority
over the state of the art and 
the benefits of combining LLMs with symbolic execution 
for smart-contract auditing. Additionally, \Tool{} reduces both time and monetary 
costs by a factor of a thousand compared to the human auditing service, 
highlighting its cost efficiency.
%
Finally, \Tool{} identifies all violations in the third dataset, proving its ability to generalize beyond the ERCs studied during its design.

In sum, we make the following contributions. 




%We have made \Tool{} and all our study results publicly available ~\cite{XXX}. 


\begin{itemize}[leftmargin=3em]
    \item We conduct the first empirical study on Ethereum ERC rules made for smart-contract implementations.
    
    \item We design and implement \Tool to audit smart contracts and pinpoint ERC rule violations. 
    
    %\item We conduct thorough experiments to assess \Tool{} and confirm its effectiveness, accuracy, and advancement. 
    \item We confirm \Tool{}'s effectiveness, advancement, cost efficiency, and generality through thorough experiments.

\end{itemize}


%DApps running on Ethereum are most commonly written in Solidity~\cite{soliditylang}, a high-level programming language specifically designed for writing smart contracts on the Ethereum blockchain. \yiying{I feel that Solidity is not core to this work. no need to talk about it here.}
