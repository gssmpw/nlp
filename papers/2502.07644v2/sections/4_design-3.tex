\subsection{Static Analysis and Symbolic Execution}
\label{sec:se}

We develop static analysis routines to verify API compliance and compute 
auxiliary information, along with a symbolic execution engine
to check against the formalized ERC rules.


\bolditalicparagraph{Static Analysis.}
We implement static analysis routines for three purposes:
1)	verifying contracts include the necessary functions 
and events specified by the corresponding ERC, 
and their declarations meet the required parameters,
2)	implementing utility functions, 
such as \texttt{getFieldName()} and \texttt{getOrder()},
and 
3)	identifying contract fields with constant values and constraints enforced 
by the implementations (\eg, keys of a mapping field being all non-zeros).


\bolditalicparagraph{Symbolic Execution.}
As discussed in Section~\ref{sec:what}, most rules apply to a public function. 
For these, we perform symbolic execution on the function. 
For the remaining rules, which apply to the entire contract, 
we analyze each public function individually.


Given a public function, we initialize all state variables to \texttt{false} 
and set contract fields to the identified constants, if applicable. 
All other constraint variables are treated as symbolic. 
At the end of each execution path, 
we use static analysis to determine $O$ variable values 
and employ a solver (\ie, Z3~\cite{z3-repo}) to compute the values 
of all other variables. Additionally, we initialize the constraint set to 
reflect common Ethereum requirements (\eg, \texttt{msg.sender > 0}) 
and type-enforced constraints. %(\eg, ensuring a \texttt{uint256} variable is non-negative).

The symbolic execution process is similar to existing techniques~\cite{klee,S2E,SymCC}, 
with the key difference being how we update state variables. 
We change the values of these variables to \texttt{true}, 
if the corresponding actions are performed. 
For example, when an event is emitted, we set the corresponding $EM$ variable to \texttt{true}. 
To manage path explosion, we limit each loop to a maximum of two iterations. 
When a path reaches the end of the public function (\ie, the function's return) 
or throw an exception, 
we compute the conjunction of the initial constraints, those enforced by the
implementation of the entire contract,
those collected during symbolic execution along the path, 
and the violation constraints synthesized for the rule being checked. 
If Z3 finds a solution for the conjunction, 
we find a violation of the rule.


For example, when checking path 8-9-12-13-14-15-16-9 in Figure~\ref{fig:20-high}
against the formalized rule in Figure~\ref{fig:20-high-grammar},
the initial constraints include ``$from_{first} \geq 0$'', ``$to_{first} \geq 0$'', ``$amount_{first} \geq 0$'', and ``$TH=false$''. 
After executing lines 12 and 13, ``$from_{first} \neq 0$'' and ``$to_{first} \neq 0$''
are added to the constraint set due to the path conditions. 
Similarly, besides constraints about how the final values of \texttt{\_balance[from]} and \texttt{\_balance[to]} are computed from their initial values,
we set $BI_{\_balance}$, $BD_{\_balance}$, and $BC_{\_balance}$ to \texttt{true} after analyzing lines 14 and 15. 
$EM_{Transfer}$ is set to \texttt{true} after line 16. 
We request Z3 to compute a solution for the 
conjunction of those constraints and the violation
constraints discussed in Section~\ref{sec:synthesizing} after 
line 9. 
Z3 finds a solution for $from_{first}$, 
$to_{first}$, $amount_{first}$, $\_balance[from_{first}]_{first}$,
and $\_balance[to_{first}]_{first}$,
representing when given those values, a violation of the rule occurs.  

%and 
%the constraints collected along the path include ``$from_{first} \neq 0$'' (line 12),
%``$to_{first} \neq 0$'' (line 13), ``$\_balances[from_{first}]_{last} %=\_balances[from_{first}]_{first} â€“ amount_{first}$'' (line 14), ``$\_balances[to_{first}]_{last} = \_balances[to_{first}]_{first} + amount_{first}$''(line 15)

\if 0

\shihao{
There are three paths after the symbolic execution. Two of them are throwed due to two require statements in line 12-13. Last one path normally returns at line 9. We ignore those paths ending in throwing and check whether normally-returned path is satisfied with the violating constraint $\neg (allowances[from][msg.sender]_{first} \geq 
amount_{first}) \land \neg (TH_{last} = true)$. $\neg (allowances[from][msg.sender]_{first} \geq 
amount_{first})$ is possible to be true since $allowances$ does not been added any constraints before the execution, $allowances[from][msg.sender]_{first}$ can be anything, including the value smaller than $amount_{first}$. $\neg (TH_{last} = true)$ is true because the path normally returns without throwing. The \Tool{} reports violation here due to that violating constraint is possible to be true.

We do not check violating constraints on path ending with throwing(except 2 throw rules in ERC20 that expect not to throw under certain conditions) because one intrinsic fact: throwing in solidity will eliminate all changes made in the execution. No change means no violation. 

To demonstrate how flipping $\Phi_{if}$ can eliminate the false positives, another throw rule from same function but expect no to throw will be used: "transfer value is 0 is allowed". Its violating constraint is $(p2 = 0) \And \neg (TH_{last} = false)$. Now, we need to check the violating constraints on those paths ending with throwing but ignore the normally-returned path(since we know it is impossible to satisfy with the violating constraint). For the path throwed due to the line 12, the constraints of that path are $p0 = 0 \And TH_{last} = true$, which will satisfy with the violating constraints since $p2$ can be any value. If we report the violation here, it is an false positive since the throwing is not caused by p2 at all. Flipping the $\Phi_{if}$, which is $p2 = 0$ elegantly solves this issue. If a path ending with throwing satisfy both $\Phi_{if}$ and $\neg \Phi_{if}$, then we say the the cause of throwing is not related to $\Phi_{if}$, which elimiates the false positives.
}

\fi