\subsection{Effectiveness of \Tool{}}
\label{sec:large}

\input{tables/tbl-large}

%\bolditalicparagraph{Methodology.}


\subsubsection{Methodology}
We create a \emph{large} dataset with 4,000 contracts for this evaluation, 
consisting of 
3,400 ERC20 contracts, 500 ERC721 contracts, and 100 ERC1155 contracts.
These contracts are randomly sampled from 
etherscan.io~\cite{etherscan} and polygonscan.com~\cite{polygonscan}.
We choose the former platform because of its prominence and the latter 
due to its higher contract deployment compared to other platforms (\eg, Arbitrum~\cite{arbitrum}, BscScan~\cite{bsc}). 
All contracts are relatively new, deployed between September 2023 
and July 2024. On average, each contract contains 469.3 lines of Solidity source code.



We run \Tool{} on the dataset and count the violations and 
false positives \Tool{} reports to assess its effectiveness. 
For each flagged violation, we manually review the result of symbolic execution, 
the rule description, and the relevant smart contract code to determine 
whether it is a true violation or a false positive. 
Each reported violation is reviewed by at least two paper authors, 
with any disagreements resolved through multiple rounds of discussion. 
Since the number of the contracts in the dataset is large, 
we do not manually analyze the contracts to identify all their ERC rule violations, 
so false negatives are not evaluated in this experiment. 



%\songlh{XXX}

%\bolditalicparagraph{Experimental Results.}

\subsubsection{Experimental Results}
As shown in Table~\ref{tab:large}, 
\Tool{} identifies 5,783 ERC rule violations, 
including 1,375 with a high-security impact, 3,720 
with a medium impact, and 688 with a low impact. 
The substantial number 
of violations detected highlights \textit{\Tool{}’s effectiveness in validating ERC rule compliance.} 
Across the three ERCs, \Tool{} detects violations for all of them, 
including 5,211 violations from ERC20 contracts, 542 from ERC721 contracts, and 30 from 
ERC1155 contracts. This demonstrates that 
\textit{\Tool{}’s violation detection capability extends 
across multiple ERCs.}


\italicparagraph{High-Security Impact.}
Among the 1,353 high-security impact violations detected in ERC20 contracts, 
14 are due to failing to validate that the message caller of \texttt{transferFrom(address \_from, address \_to, uint256 \_value)}
has sufficient privileges to transfer the \texttt{\_value} tokens.  
An example of this violation is shown in Figure~\ref{fig:20-high}, 
with similar code patterns found in the other 13 cases.
Another 1,266 cases violate the same rule, but stem from a different issue: 
instead of comparing the allowed amount with \texttt{\_value}, 
these implementations check whether the allowed amount equals \texttt{type(uint256).max}.
Furthermore, they fail to update the allowed amount after the transfer, which we believe 
creates a backdoor in the contract. This loophole potentially enables one address to drain any 
amount of tokens from another account.
Another 73 violations breach the rule that \texttt{transfer()} should revert if the message caller 
does not have enough tokens to transfer. 
Exploiting these violations could allow an address to spend 
more tokens than it actually possesses. 
The flawed implementations either use
\texttt{unchecked} to 
bypass the underflow check when reducing the caller's balance 
or include a path 
that does not decrease the caller's balance at all.

\Tool{} identifies 18 high-security violations that do not comply with ERC721 requirements. 
These violations are related to functions 
%like 
%\texttt{transferFrom()} and \texttt{safeTransferFrom()}, 
%which are 
responsible for transferring NFT ownership. The 
flawed implementations fail to check whether the sender is the rightful owner of the NFT or whether the recipient 
address is not the zero address. Exploiting these 
vulnerabilities could lead to NFTs being stolen or 
permanently lost at the zero address.

\input{figures/fig-erc1155-high}
\if 0
% Shihao
\input{figures/fig-erc721-high}
\shihao{
\Tool{} found 18 violations with a high-security impact in ERC721 contracts. An example of the violations shown in Figure~\ref{fig:721-high}, with similiar code patterns found in the other 16 cases. ERC721 mandates that  \_from should be the the current owner and \_to should not be the zero address during the transfer. Neither \texttt{transferFrom} not its callee \texttt{\_transfer} performs these important checks. The patch in lines 7--8 shows the necessary checks.
}
\fi



\Tool{} pinpoints four violations with a high-security impact in an ERC1155 contract.
The simplified contract is shown in Figure~\ref{fig:1155-high}.
Function \texttt{safeTransferFrom()} in lines 5--12 is designed to 
transfer \texttt{value} tokens of type 
\texttt{id} from one address to another.
Similar to ERC20, ERC1155 mandates that the message caller 
must be approved to manage the tokens 
for the token owner. 
Unfortunately, neither \texttt{safeTransferFrom()} 
nor its callee \texttt{\_update()} performs this crucial 
check (via \texttt{\_approvals}), allowing anyone to transfer 
tokens from any address to their own.
The patch in line 7 introduces a verification step to ensure that 
the token owner has approved the message 
caller to handle his tokens, thus aligning with the ERC1155 requirement.
Moreover, ERC1155 mandates that \texttt{safeTransferFrom()} checks whether 
the recipient is a contract and if so, whether the contract is capable of handling
ERC1155 tokens by calling \texttt{onERC1155Received()} on the contract.
Unfortunately, the implementation in Figure~\ref{fig:1155-high} neglects these
requirements. Transferring tokens to a recipient contract without the required capability 
results in the tokens being indefinitely trapped within the contract.
Lines 9--11 show the necessary checks to fulfill the requirements.
%Another \songlh{XXX} violations %with a high-security impact from ERC1155 contracts
%are similar to the one patched by line 6 in Figure~\ref{fig:1155-high}.
The remaining violation arises from the failure to check 
whether the recipient is address zero. 
Transferring tokens to address zero leads to the irreversible loss of the 
tokens.
The violation is patched by line 6 in Figure~\ref{fig:1155-high}.

%In summary, \emph{\Tool{} is capable of detecting violations of ERC rules that can result in the loss of digital assets.}

\italicparagraph{Medium-Security Impact.}
The 3,720 violations with a medium impact stem from several reasons. 
Of these, 3,611 violations involve ERC20 rules, 
where the \texttt{transfer()} and \texttt{transferFrom()} functions incorrectly 
throw an exception when transferring zero tokens,
instead of treating it as a normal transfer. Additionally, 55 violations result from the absence of a required function specified by the relevant ERC. 
Another 32 violations occur due to missing or incorrect return-value types in functions, contrary to ERC specifications. Finally, 22 violations stem from failing to throw an exception for invalid input parameters in ERC721 contracts.




%\input{figures/fig-erc-emit}


\italicparagraph{Low-Security Impact.}
Of the 688 event-related violations, 672 are due to the omission of an event declaration, 16 fail to emit an event, 
and one emits an event but with a wrong parameter. 
%One example is shown in Figure~\ref{fig:emit}. 
%ERCXXX mandates that a TransferSingle event be emitted when minting tokens, 
%with the second argument set to zero. 
%However, when the contract mints tokens by calling  \texttt{airdrop()}, 
%the second parameter of the emitted event in line 11 incorrectly set to the input parameter of \texttt{airdrop()}, which is provided by the message caller. 


\italicparagraph{False Positives.}
In general, \emph{\Tool{} demonstrates high accuracy}, reporting 1,510 false positives when analyzing 4,000 contracts. The true-violation-to-false-positive ratio is approximately 3.8. These false positives arise from two main sources.

First, all 1,388 false positives from ERC721 and ERC1155 contracts 
result from errors when the LLM performs rule extraction. 
Specifically, the LLM makes seven mistakes: it misses one rule (for ERC1155), 
reports four unnecessary rules (two for ERC721 and two for ERC1155), 
and misrepresents two rules (for ERC1155). 
Each of the last six errors leads to a false positive in every contract of the ERC 
unless the 
contract lacks the relevant function. For instance, 
the LLM incorrectly identifies a rule in ERC721 that 
prohibits function \texttt{safeTransferFrom()} from throwing an exception when the destination is a contract, a requirement not specified by ERC721. 
This error causes a false positive in all 500 ERC721 contracts 
in the dataset. We argue that it is highly unlikely for all contracts to not adhere to 
a specific ERC rule. Therefore, a simple strategy of ignoring 
rules violated by all contracts can effectively eliminate false positives 
caused by rule extraction errors made by the LLM.

Second, all 122 false positives from ERC20 contracts arise 
during symbolic execution. Of these, 116 occur when a contract 
retrieves the token balance of an account from another contract, 
whose code is unavailable during our experiment. 
As a result, \Tool{} incorrectly assumes that the \texttt{transfer()} implementation 
does not verify the caller's balance. 
Another five false positives are due to \Tool{}'s inability to handle assembly code.
%, preventing it from detecting token-balance-reading operations within such code. 
The remaining false positive arises from an implementation of \texttt{transferFrom()}, 
where the source address is compared with the message caller and an authorization check is only performed if they differ. 
We consider this a false positive, as the check is skipped only when 
the caller is transferring her own tokens, making exploitation impossible.

\begin{tcolorbox}[size=title]
{\textbf{Answer to effectiveness:} 
\Tool{} accurately detects a wide range of ERC rule violations across multiple ERCs, with many violations clearly linked to potential financial loss.}
\end{tcolorbox}


\if 0

Overall, \textit{\emph{\Tool{}} exhibits high accuracy.}
It reports only 122 false positives, 
with a precision exceeding 97.9\%. %($5738/(122+5738)$).
%\commentty{122 seems like a large number; it might be better to use a percentage, e.g., 122/3738}
These false positives arise from three reasons.
First, in 116 cases, a contract retrieves the token balance 
of an account from another contract whose code is not 
available during our experiment. As a result, \Tool{} 
mistakenly assumes that the implementation of \texttt{transfer()} does not verify the message caller's 
balance.
Second, \Tool{} does not support assembly code, leading to 
the inability to identify the operation of reading token balance, 
which causes five false positives.
Third, in one instance, the implementation of 
\texttt{transferFrom(address \_from, address \_to, uint256 \_value)} compares \texttt{\_from} with the message caller 
and only performs an authorization check if they are 
different. We consider this a false positive since the
authorization is only skipped when the message caller is transferring her own tokens, making exploitation 
impossible in this scenario.

\fi
