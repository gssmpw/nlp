\subsection{ERC Rule Translation}
\label{sec:translation}
Generating constraints directly from natural language rules is challenging 
for the LLM due to the vast space of possible constraints, 
which increases uncertainty and the likelihood of hallucinations. 
To mitigate this, we define an EBNF grammar to formalize ERC rules 
and instruct the LLM to translate the extracted rules into this IR. 
The EBNF grammar effectively limits the LLM's output space, improving accuracy. 
Additionally, formalizing the rules with the EBNF simplifies processing for subsequent tasks. The EBNF essentially acts as a bridge between natural languages 
and constraint inputs for symbolic execution, addressing \textit{Challenge-II} 
in Section~\ref{sec:intro}.

We design the EBNF grammar based on the empirical study 
in Section~\ref{sec:study}. This grammar covers a wide range of ERC 
requirements and represents a key technical contribution of this paper, 
effectively addressing \textit{Challenge-I} in Section~\ref{sec:intro}. 
Additionally, it is a one-time effort with long-term benefits, 
as it can accommodate future ERCs not yet studied (see Section~\ref{sec:3525}).


\if 0

Synthesizing buggy constraints directly from natural language rules is challenging. 
\commentty{something is missing here. Why can't we use LLMs
to directly synthesize constraints taken by symbolic execution?
Why is EBNF best suitable for IR?} 
\shihao{LLM can generate IR constrained by EBNF pretty well~\cite{wang2024guidinglargelanguagemodels,NEURIPS2023_cd40d0d6}}
To address this, we define an \shihao{IR in Extended Backus–Naur Form (EBNF)} grammar~\cite{ebnf} and a corresponding JSON format to formally outline 
how to inspect smart contracts for rule violations. 
We then guide the LLM to translate the extracted rules into this intermediate representation (IR). 
The grammar acts as a bridge between natural language and the constraint configurations for symbolic execution, effectively mitigating the LLM’s hallucinations (\emph{Challenge-II} in Section~\ref{sec:intro}). In addition, 
the grammar covers the majority of requirements specified by the ERCs, ensuring \Tool{}’s comprehensiveness in analyzing ERC rules 
(\emph{Challenge-I} in Section~\ref{sec:intro}).

\fi


\input{figures/fig-grammar}



%\input{tables/tbl-utility-function}

\bolditalicparagraph{EBNF Grammar.}
As shown by line 1 in Figure~\ref{fig:ebnf}, 
the EBNF grammar contains five top-level non-terminals (symbols enclosed by ``<>’’)
corresponding to five linguistic 
pattern groups in Table~\ref{tab:linguistic}. 
The grammar encompasses all groups except the one related to return value generation.
This omission stems from the difficulty of using contract elements explicitly required by ERCs to define the required return values. For instance, 
ERC20 specifies that the \texttt{name()} function of every ERC20 contract must return the name of the token the contract manages, 
but does not mandate where the name should be stored, making it challenging to formalize this rule across diverse ERC20 implementations.

The grammar expands all non-terminal symbols into terminal 
ones (those not enclosed by ``<>''). 
The grammar's terminals include contract elements 
(\eg, public functions and their parameters) defined by ERCs, 
utility functions (shown in violet in Figure~\ref{fig:ebnf}), 
control-flow constructs (e.g., \texttt{if}, \texttt{then}, \texttt{with}), 
and Boolean operators. Utility functions are analysis routines we define, 
and their names are carefully chosen to reflect their exact functionalities. 
This naming approach aids the LLM in understanding these functions 
and performing the formalization. For example, \texttt{checkThrow(<fun>, <flag>)} 
returns a Boolean value, indicating whether the contract function \texttt{<fun>} throws an exception or not as expected by \texttt{<flag>}. 
Table~\ref{tab:utility} lists all utility functions and their respective purposes.



\italicparagraph{Non-terminal <throw>.}
\texttt{<throw>} in line 3 formalizes 
how to check rules requiring a function to throw or not throw an exception under a specific condition. 
For one such rule, 
%we need to specify 
both non-terminal \texttt{<b\_exp>}, representing the condition, 
and the parameter of utility function \texttt{checkThrow(<fun>, <flag>)} need to be specified.


How to extend non-terminal \texttt{<b\_exp>} is shown in lines 9--17. 
A \texttt{<b\_exp>} in line 9 could be a compound Boolean expression, 
a Boolean expression that compares two \texttt{<value>}s, 
or the returns of three utility functions. 
A \texttt{<value>} in line 10 could be
\texttt{msg.sender}, a field value of the contract, a parameter, or similar elements. 
Utility function \texttt{getFieldValue()} in line 11 returns the value of a contract field, taking 
the field name as input. 
Since a field could be a multi-dimensional array or mapping, 
\texttt{getFieldValue()} takes optional \texttt{<key>} parameters. 
ERCs do not impose any requirements on field names 
but do require the names of certain public functions that return the values of contract fields. 
We consider these functions as anchor functions to identify field names. For example,
function \texttt{allowance()} in lines 18--20 of Figure~\ref{fig:20-high} is explicitly required by ERC20, and it is the anchor function
to identify the contract field that records how many tokens
one address allows another to manipulate (\eg, \texttt{\_allowances}). 
Utility function \texttt{getFieldName()} in line 12 takes an anchor function as 
input and outputs the name of the field accessed by the anchor function. 
%Utility Function \texttt{getPara()} in line 13 retrieves the parameter of the input function or event at a specified \texttt{<index>}.


\input{figures/fig-erc20-high-grammar}

As an example, Figure~\ref{fig:20-high-grammar} shows 
the formalization of the rule violated in Figure~\ref{fig:20-high}. 
This rule is about the \texttt{transferFrom()} contract function, 
whose declaration is in line 2. 
In line 4, contract function \texttt{allowance()} required by ERC20, is identified by the LLM 
as the anchor function for the field tracking how many tokens one address allows another to manage (\eg, \texttt{\_allowances} in Figure~\ref{fig:20-high}). 
Utility function \texttt{getFieldName()} analyzes 
contract function \texttt{allowance()} 
to extract the field name. Since the contract field is a two-dimensional mapping, 
utility function \texttt{getFieldValue()} requires two additional parameters as keys. 
If the mapping element is greater than or equal to the 
transfer amount (the third parameter of contract function \texttt{transferFrom()}), 
it indicates that the token owner has granted sufficient privileges to 
\texttt{msg.sender}. Otherwise, contract function \texttt{transferFrom()} should throw an exception, verified by utility function \texttt{checkThrow()} in line 6.

\italicparagraph{Non-terminals <call> \& <emit>.}
These two check whether a contract function 
calls another function or emits an event under specific conditions. 
They also ensure that the parameters of the called function 
or emitted event meet the required criteria. 
For example, ERC1155 requires a function to emit
a \texttt{TransferSingle} event with the event's second 
parameter set to zero when minting tokens. 
To enforce this rule, we use the utility function \texttt{checkMint(<func>)} 
as the first \texttt{<b\_exp>} of \texttt{<emit>} to verify that the analyzed 
contract function only increases token balances without decreasing them, 
indicating a token minting action. Once confirmed, we then check if the 
contract function emits the required event using \texttt{checkEmit()}. 
If this is also confirmed, we proceed to verify that the second parameter 
of the emitted event is zero, specified by the second \texttt{<b\_exp>}.




\italicparagraph{Non-terminal <assign>.}
\texttt{<assign>} performs an unconditional check 
using utility function \texttt{checkEndValue(<fun>, <value>, <value>)} 
in line 6 of Figure~\ref{fig:ebnf}.
The utility function checks whether the first \texttt{<value>} matches 
the second at the end of contract function \texttt{<fun>}.


\italicparagraph{Non-terminal <follow>.}
\texttt{<follow>} checks whether the two input operations follow the specified order. An order can be represented by another pair of operations, as demonstrated by 
utility function \texttt{getOrder(<op>, <op>)} in line 14 of Figure~\ref{fig:ebnf}.


\bolditalicparagraph{Prompting the LLM.}
Some ERC rules apply directly to function and event declarations 
and can be inspected without translation. For the other rules extracted by the LLM, 
we use the LLM to translate each one individually. 
Figure~\ref{fig:prompt2} shows the prompt template. 
It begins with a function or event's source code declaration, 
followed by an extracted natural language rule for the function or event 
and any possible arguments. 
The template then specifies the JSON schema for the top-level non-terminal of 
the rule to help the LLM understand the EBNF grammar. 
For example, the JSON schema of \texttt{<throw>}
is used for the rule violated in Figure~\ref{fig:20-high}. 
%The JSON schema helps the LLM understand the EBNF grammar. 
Next, the template introduces all anchor functions of the ERC, and finally instructs the LLM to translate the rule into the EBNF and output the result according to the JSON schema.





\if 0

The LLM successfully translates \shihao{60} out of the \shihao{90} rules. 
The remaining \shihao{30} rules are not translated for three reasons.
First, \shihao{24} rules pertain to generating return values, 
for which we do not design the grammar, as previously discussed.
\commentty{better elaborate why 38 rules are missing as this is a significant number. What would be the potential solutions?} \shihao{Return value descriptions, dependent on specific environments (\eg, 'Returns the name of the token'), resist standardization due to their contextual variability.}
Second, the text descriptions of three rules lack sufficient details, leading to translation failures. 
For example, ERC1155 requires \texttt{safeTransferFrom()} to throw for any error \shihao{we can filter this by simple check, should we remove it?}, 
but it does not formally define all possible errors.
%causing the LLM to miss translating two rules.
Third, the LLM makes mistakes with the final \shihao{three} rules. For example, the LLM fails to identify
the correct anchor function, thus missing one rule. 
%
%including
%one due to that the LLM fails to generate the three 
%primitive Boolean expressions described in a complex %text description, 
%one due to the generation of an extra requirement 
%for a parameter when calling a function, one
%incorrectly translating a requirement for a %parameter, 
%and one resulting from failing to identify the %correct anchor function.
We correct these last four rules, enabling \Tool{} to validate more rules. \shihao{should remove this sentence?}

\fi





