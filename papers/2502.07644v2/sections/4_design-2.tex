\subsection{Constraint Synthesizing}
\label{sec:synthesizing}

Since smart contracts have diverse implementations for the same ERC, 
to eliminate the need for customizing symbolic execution for each contract, 
we define a set of constraint variables to represent generic contract execution states shared across contracts, along with their update mechanisms during symbolic execution. 
These designs are essential for expressing ERC requirements 
and generating constraints equivalent to the EBNF grammar. They differentiate \Tool{} from existing symbolic execution techniques~\cite{klee,S2E,SymCC} 
and serve as the second major technical contribution of this paper.



\bolditalicparagraph{Constraint Variables.}
%
For each public function $fun$, 
we define six types of \emph{state variables} to track whether $fun$ or its callees perform specific actions, thereby entering corresponding states. 
Specifically, we define a $TH$ variable to indicate whether $fun$ throws an exception, possibly triggered by \texttt{require}, \texttt{revert}, \texttt{assert}, or \texttt{throw}. 
Solidity programmers often use modifiers to enforce checks, 
and exceptions may be thrown if these checks fail. 
Those modifiers are naturally supported 
through inter-procedural analysis. Additionally, we define an $EM$ 
variable for each event declared in the contract to track whether $fun$ emits that event, 
and a $CA$ variable for each contract function to track whether $fun$ calls it. For each contract field, we define $BI$, $BD$, and $BC$ variables to indicate 
whether $fun$ increases, decreases, or modifies the field, respectively. These variables are initialized to \texttt{false} before analyzing $fun$ and are set to \texttt{true} when the corresponding actions are performed by $fun$ or its callees.


For example, if the condition in line 12 of Figure~\ref{fig:20-high} evaluates to \texttt{false}, function \texttt{transferFrom()} throws an exception, and thus, the $TH$ variable 
is set to \texttt{true}. 
After executing line 15, $BI_{\_balances}$ 
is set to \texttt{true}, representing the sum of all mapping elements 
has ever been increased. %\shihao{line 15? line 14 is -=.}

In addition to the state variables, we define an $O$ variable for each executed instruction, representing the instruction sequence along a concrete execution path. 
We also define value variables for contract fields, formal and actual function parameters, event parameters, local variables, and values defined by Ethereum (\eg, \texttt{msg.sender}). These value variables are updated during symbolic execution 
or constrained by path conditions.


\input{tables/tbl-constraint}


\bolditalicparagraph{Generating Violation Constraints.}
For the five top-level non-terminals, we generate constraints for \texttt{if}’s condition ($\Phi_{if}$), 
the check part ($\Phi_{check}$), 
and \texttt{with}’s condition 
($\Phi_{with}$). 
We then combine these to form violation constraints based on the 
rules in Table~\ref{tab:constraint}.
Specifically, if a rule requires an action (\eg, \texttt{assign}), 
its violation occurs when the action is not performed. 
If a rule requires an action under a condition, its violation happens when
the condition is met but the action is not performed (\eg, \texttt{<throw>}), or when
the action is performed, but the action’s parameters do not meet the 
requirements (\eg, \texttt{<emit>}). 
For rules that require no exceptions under certain conditions, we design validation constraints as ``$\neg \Phi_{if} \land \neg \Phi_{check}$.’’ 
A violation is 
reported only when the violation constraints are met, 
but the validation constraints are not met, 
ensuring that the exception is indeed due to the specified conditions.
Additionally, for \texttt{call} and \texttt{emit}, we inspect whether analyzed 
contacts contain the called functions or emitted events before synthesizing constraints. 





When synthesizing $\Phi_{if}$, $\Phi_{check}$, and $\Phi_{with}$, 
we use defined value variables to replace relevant contract elements 
(\eg, formal and real parameters, 
contract fields) and utility functions with the ``get'' prefix. 
We use the checks of state variables to replace utility functions 
with the ``check'' prefix. 
Additionally, for each constraint variable, we consider two key values when synthesizing constraints: 
its initial value before executing a public function 
and its final value afterward. 
Except for formal parameters and 
contract fields accessed through formal parameters, 
we use the final values of all other variables 
to generate constraints.



Consider the rule violated in Figure~\ref{fig:20-high}. 
The generated constraints are 
``$\neg (allowances[from_{first}][msg.sender_{last}]_{first} \geq 
amount_{first}) \land \neg (TH_{last} = true)$.'' 
Subscripts $first$ and $last$ 
indicate whether the initial or final value is used. Variable $allowances[from][msg.sender]$ %\shihao {letter s is incorrectly formatted with underscore. Last place is using msg.sender} 
is accessed via a formal parameter, and both $from$ and $amount$ are formal parameters as well. Therefore, their initial values are used. 
On the other hand, $TH$'s final value is used, representing whether 
the function throws an example after a concrete execution. 

