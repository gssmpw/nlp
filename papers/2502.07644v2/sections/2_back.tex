\section{Background}
This section gives the background of the project, including 
Solidity smart contracts, 
ERCs, 
and techniques related to ours. 



\subsection{Ethereum and Solidity Smart Contracts}

Ethereum is a blockchain system that enables programmers to 
write smart contracts for the building 
of decentralized applications~\cite{eth-1,eth-2}. 
Both Ethereum users and smart contracts are represented by 
distinct addresses, which can be used to send and receive Ethers 
(the native Ethereum cryptocurrency) and interact with smart contracts, 
thereby leveraging their functionalities to perform complex transactions. 
Ethereum cultivates a thriving digital economy ecosystem. 
At the time of writing, the price of one Ether is over \$3K, 
with the total market value of all Ethers exceeding \$300B~\cite{eth-price}. 
%ranking second only to Bitcoin among all cryptocurrencies~\cite{eth-price}. 
Daily transactions on Ethereum surpass one million, 
with a volume exceeding \$4B~\cite{eth-daily}. 
Smart contracts play a pivotal role in Ethereum's success, as they guide 
most transactions and enable crucial 
functionalities~\cite{erc20,erc721,eth-defi}.


%such as cryptocurrencies~\cite{erc20}, NFTs~\cite{erc721}, and decentralized finance~\cite{eth-defi}.

 
Solidity is the most widely used programming language
for writing smart contracts~\cite{solidity-popular-1,solidity-popular-2}. 
With a syntax resembling ECMAScript~\cite{ecmascript}, Solidity effectively conceals 
the intricacies of the Ethereum blockchain system. 
Implementing a contract in Solidity is similar to implementing 
a class in Java. A contract contains 
contract fields (state variables) to store the contract's states 
and functions to realize its functionalities. 
%Analogous to object-oriented programming languages, 
A function in Solidity can be public, internal, or private. 
Public functions serve as the contract's interface, providing external access 
to its functionalities. These functions can be invoked by a different contract 
or an Ethereum user through a message call, 
while private or internal functions cannot. 
Additionally, contracts can define events emitted during execution, 
serving as logs on-chain 
that can be analyzed by off-chain applications. 

Figure~\ref{fig:20-high} shows a contract example, with two contract fields in lines 2 and 3, 
%\texttt{\_balances} (line 2) and \texttt{\_allowances} (line 3), 
%tracking the number of tokens owned by each address and 
%the tokens approved by the first dimension for manipulation 
%by the second dimension, respectively. 
and an event %\texttt{Transfer()} 
in line 4. It emits the event in line 16. The public function \texttt{transferFrom()} 
(lines 6--10) can be called by any Ethereum user or contract after the contract is deployed, while the internal function \texttt{\_transfer()} (lines 11--17) is restricted to calls from the same address.



\subsection{Ethereum Request for Comment (ERC)}
\label{sec:erc}

ERCs are technical documents that outline the requirements 
for implementing smart contracts, ensuring interoperability and 
compatibility across various contracts, applications, and platforms 
and helping foster the 
Ethereum ecosystem~\cite{erc-eip1, erc-standard, stefanovic2023proposal}. 
Typically, an ERC begins with a concise motivation. For example, ERC20 emphasizes its
role in defining a standard token interface for 
applications like wallets and decentralized exchanges~\cite{erc20}.
Subsequently, an ERC provides a detailed specification section, which
outlines all necessary public functions and events, including their parameters,
return values, and any optional attributes. Additionally, 
an ERC usually specifies requirements through plain text or code comments for each function or event, just before their declaration.
For example, 
beyond the requirements for the function API and return value generation, 
ERC20 incorporates four additional rules for \texttt{transferFrom()} 
(\eg, Figure~\ref{fig:20-high}): 
mandating the emission of a \texttt{Transfer} event, 
verifying whether the message caller is approved to manipulate 
the tokens and throwing an exception if not, 
treating the transfer of zero tokens similarly to other amounts, 
and emitting an event 
when transferring zero tokens.





%\mengting{The purpose of ERCs is to establish standards and guidelines for the Ethereum blockchain, specifically in the context of smart contracts and tokens. ERCs are proposals for improvements to the Ethereum ecosystem, and they define a set of rules and specifications that developers can follow when creating smart contracts or tokens on the Ethereum blockchain. These standards help ensure interoperability and compatibility among different applications and platforms within the Ethereum ecosystem. The template of ERCs includes abstract, motivation which could be omitted if evident, specification, rationale, reference implementation (optional), security considerations and copyright ~\cite{erc-eip1}. For example, in ERC-20, the abstract part indicates the following standard allows for the implementation of a standard API for tokens within smart contracts and the standard provides basic functionality to transfer tokens. The motivation part indicates ERC-20 is for wallets and decentralized exchanges to re-use tokens. In the specification part, the interface and implementation requirements are described. The implementation part provides two examples, i.e. OpenZeppelin implementation and ConsenSys implementation ~\cite{erc20}. There are 379 ERCs ~\cite{erc-standard} in the Ethereum GitHub repository including contract standards such as token standards (ERC-20), name registries (ERC-137), URI schemes, library/package formats, and wallet formats ~\cite{erc-eip1}. The most popular token standards are ERC-20 which is a standard interface for fungible tokens, ERC-721 which is a non-fungible tokens specification, ERC-777 for extra functionality and ERC-1155 for utility tokens and non-fungible tokens ~\cite{token-standard}.}

Violating ERC rules can result in substantial financial losses and unexpected contract behaviors. For instance, ERC721 mandates \texttt{onERC721Received()} to be called for each token transfer, when the recipient is a contract. Additionally, it further requires that 
the caller must verify that the return is a specific magic number. 
These two rules ensure that the recipient contract has 
the capability to handle the transferred tokens. 
Transferring tokens to a contract lacking this capability can result 
in the tokens being permanently trapped in the recipient contract. 
This issue was initially reported in 2017 on Ethereum Reddit, 
leading to a loss of \$10,000 worth of tokens at that time, and has since caused millions of dollars in losses~\cite{erc20-problem-history}.
As another example, the rule violation in Figure~\ref{fig:20-high} 
%fails to adhere to the rule of verifying the privilege of its message caller, and thus 
opens the door for a hacker to
pilfer tokens from any account. 
In summary, it is crucial to ensure that contracts adhere to ERC rules to safeguard financial assets and 
ensure the proper functionalities of the contracts.



%\songlh{An example of a code implement ERC-20}

%\mengting{The ERC20 Token is the minimum standard template for fungible tokens. It defines 6 mandatory functions and 2 events. 3 of these functions are getter function of state variables which represent account balance (line 2 in Figure~\ref{fig:20-high}), total token supply (line 3) and the amount one address can spend on behalf of another address (line 4). Except for the interface, the standard also includes rules about implementing functions and rules about emitting the events. For example, for the function transferFrom which transfers '\_value' amount of token from address '\_from" to address '\_to', the Transfer event must be fired as shown in line 19 in Figure~\ref{fig:20-high}. This function should throw unless the \_from account has deliberately authorized the sender of the message via some mechanism. For example, as shown in line 10 in Figure~\ref{fig:20-high}, if amount is larger than \_allowances[from][msg.sender] which means the amount it wants to transfer exceeds the amount the address 'from' allows the message sender to transfer, this line will throw an exception because of underflow. Moreover, transfers of 0 values must be treated as normal transfers. As shown in line 10-19 in Figure~\ref{fig:20-high}, the function transferFrom does not have special handling for zero value of amount. In addition, it also defines 3 optional functions which return the name, symbol and number of decimal places of the token. }

\subsection{Related work}
\label{sec:related}

There are tools designed to automatically detect ERC rule violations. 
For example, Slither includes specific checkers (\ie, slither-check-erc~\cite{slither-erc}) 
that assess whether a contract meets the requirements of 11 ERCs. 
However, these checkers have limited functionality, focusing mainly on 
verifying the presence of required functions and events, 
ensuring proper declarations, and confirming that functions emit 
the necessary events. Unfortunately, they cannot address 
more advanced requirements, such as the one violated in Figure~\ref{fig:20-high}.
%
The ERC20 verifier is a tool dedicated to ERC20 contracts~\cite{erc20-verifier}, 
performing checks similar to those done by Slither. 
ZepScope~\cite{ZepScope} extracts necessary checks from OpenZeppelin's code 
and verifies whether contracts using OpenZeppelin's code implement these checks.
VerX~\cite{VerX} is an automated tool that verifies whether smart contracts meet specific properties identified from project documentation. 
While both ZepScope and VerX address some ERC rules (\eg, access control checks), 
they overlook many others (\eg, required event emissions). 
ERCx verifies ERC rule compliance with unit tests~\cite{ERCx}, but its tests are 
incomplete and often fail to trigger violations in smart contracts. 
Several customized ChatGPT services are available for auditing smart contracts on 
OpenAI's GPTs 
platform~\cite{GPT-RyanHarvey,GPT-MichaelDNorman}. 
In Section~\ref{sec:compare}, we evaluate one of these services 
and find it significantly underperforms in detecting ERC violations.



%\mengting{Ryan Harvey published a custom GPT~\cite{tao2023opening,bestgpts,allgpts,introgpts} called Smart Contract Auditor that can audit smart contracts, but it focuses on best practices in smart contract security. Thus it also misses complex violations.}


Researchers have also developed automated tools to identify other types of Solidity bugs, including reentrancy bugs~\cite{liu2018reguard, qian2020towards, xue2020cross, Oyente, Zeus}, nondeterministic payment bugs~\cite{wang2019detecting, li20safepay}, consensus bugs~\cite{yang2021finding, chen2023tyr}, eclipse attacks~\cite{wust2016ethereum, xu2020eclipsed, marcus2018low}, out-of-gas attacks~\cite{grech2018madmax,ghaleb2022etainter}, errors in DApps~\cite{VetSC}, accounting errors~\cite{zhang2024towards},
and code snippets consuming unnecessary gas~\cite{kong.pattern,brandstatter2020characterizing, brand.efficiency,nelaturu2021smart,chen2018towards,gaschecker,chen2017under,slither}. 
However, these techniques focus on bugs unrelated to the 
semantics defined by ERCs and cannot detect ERC rule 
violations. %like \Tool{} can.

Security experts provide auditing services to identify 
vulnerabilities or logic flaws 
in smart 
contracts~\cite{certik,revoluzion,pixelplex,blockhunters,immunebytes,antier,humanaudited}, with some also assessing ERC compliance. 
However, these services incur significantly higher financial and time 
costs compared to automated tools, which may make Solidity 
developers reluctant to use them.

Researchers have also leveraged
LLMs to analyze Solidity code for 
detecting vulnerabilities~\cite{sun2023gpt, ma2024combiningfinetuningllmbasedagents}, 
patching bugs~\cite{ibbaleveraging}, generating exploits~\cite{wu2024advscanner}, 
and testing Solidity programs~\cite{alici2023openai}. However, the problem we address differs from these techniques. Since ERCs define numerous implementation rules that are tied to program semantics, 
we address a broader range of bugs than these techniques.

In summary, existing program-analysis-based 
techniques either have limited ERC compliance 
verification capabilities 
or focus on bug types unrelated to ERCs. 
While manual audits are thorough, they are costly and 
time-consuming. LLM-based approaches show promise for 
general error detection but struggle to identify 
specific ERC rule violations. Our research overcomes 
these limitations by developing a fully automated, end-to-end solution for verifying smart contracts against a
comprehensive set of ERC rules.




%Researchers have already utilized LLMs provided by ChatGPT for analyzing Solidity code. 
%Sun \etal{} define features for ten vulnerability types and instruct ChatGPT to inspect Solidity contracts to detect vulnerabilities of those types~\cite{sun2023gpt}. 
%Ibba \etal{} explore leveraging ChatGPT for patching bugs in Solidity programs~\cite{ibbaleveraging}. 
%Alıcı \etal{} seek guidance from ChatGPT on testing a Solidity program, then follow the instructions provided by ChatGPT to execute the testing process with ChatGPT and identify bugs~\cite{alici2023openai}. 
%The problem we address differs from existing techniques. 
%Given that ERCs specify a multitude of implementation rules and most of them are related to program semantics, 
%we essentially resolve bugs in a much wider array of types than existing techniques.


%\mengting{
%CertiK~\cite{certik}, Revoluzion~\cite{revoluzion}, PixelPlex~\cite{pixelplex} and BLOCKHUNTERS~\cite{blockhunters} provides manual auditing service to assess smart contracts. ImmuneBytes~\cite{immunebytes} also provides smart contract auditing service to check the compliance, evaluate models and identify vulnerabilities. Antiersolutions~\cite{antier} audits the security of smart contracts, updates threat model and provides enterprise security counseling.}
