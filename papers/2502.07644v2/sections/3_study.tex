\section{Empirical Study on ERC Rules}
\label{sec:study}

This section presents our empirical study on ERC rules, including the methodology employed for the study and the categories established for the rules. 
%and the findings associated with the study. 


\subsection{Methodology}


From the 102 ERCs in the final status, 
we choose ERC20, ERC721, and ERC1155 
as our study targets. 
We base our selection on their popularity,  
%with numerous corresponding contracts, 
%We select them, because of their popularity,
their complexity, 
and their significance in the Ethereum ecosystem.

\emph{ERC20} is a technical standard for fungible tokens (\eg, cryptocurrencies) 
and is the most famous ERC standard.
It outlines operational requirements for minting, burning, and transferring 
tokens~\cite{erc20}. 
Presently, there are over 450,000 ERC20 tokens on Ethereum~\cite{erc20-popular}, 
with many boasting a market capitalization surpassing \$1 billion~\cite{USDT,SHIB,Binance}.

%(\eg, USDT~\cite{USDT}, SHIB~\cite{SHIB}, Binance USD~\cite{Binance}).

\emph{ERC721} is designed for non-fungible tokens (NFTs), where each token is 
distinct and indivisible~\cite{erc721}. ERC721 specifies how ownership of NFTs 
is managed. 
As the most popular NFT standard, 
it is adhered to by major NFT marketplaces~\cite{opensea,rarible}.

\emph{ERC1155} aims to enable a single contract to oversee both fungible and 
non-fungible tokens~\cite{erc1155}. Additionally, it facilitates batch 
operations. 
%For example, multiple types of tokens can be transferred in one single transaction. %from one 
%address to another together. 
ERC1155 has found adoption in various gaming and 
charity donation projects~\cite{Horizon,9Lives,Reewardio}.

%\emph{ERC3525} is tailored for semi-fungible tokens, where each token is distinct like NFTs but incorporates an additional qualitative nature like fungible tokens~\cite{erc3525}.
%ERC3525 has already been leveraged for financial instruments~\cite{fujidao,bufferfinance}.

We carefully review the official documents (including text descriptions and associated code)
and manually identify rules by evaluating their relevance to contract implementations, 
whether they have clear restricting targets, and whether they offer actionable checking criteria. 
Certain rules explicitly use terms like ``must'' or ``should'' to convey obligations.
%Certain rules are extracted from the textual descriptions, 
%with some explicitly using terms like ``must'' or ``should'' to convey obligations. 
%The remaining rules are gained from code sections pertaining to function and event declarations.
%indicating the requirements for contract interfaces.
%In total, we identified 192 rules from the four ERCs,
%including 34 rules from ERC20, 60 from ERC721, 40 from ERC1155, and 58 from ERC3525, respectively. 
%Table~\ref{tab:rules} illustrates the distribution of these rules across the ERCs.
%
We identify a total of 132 rules across the three ERCs: 32 
from ERC20, 60 from ERC721, and 40 from ERC1155. %and 58 from 
%ERC3525.
Our study primarily answers three key questions regarding the identified rules: 
1) what rules are specified? 2) why are they specified? and 
3) how are they specified in natural languages? 
The objective is to garner insights 
for building techniques to automatically detect rule violations. 
%Similar to the process of rule identification, 
%All study results are carefully reviewed by at least two paper authors.
To maintain objectivity, all study results are examined by at 
least two paper authors.

%\subsection{Study Results}



\subsection{Rule Content (What)}
\label{sec:what}
%We first inspect the rules' content to understand what
%checks we need to detect their violations. As shown by the rows in Table~\ref{tab:study},
%we separate the rules into four categories. 
An ERC rule generally requires that a public function includes a specific piece of code. 
Based on the semantic nature of the code, we classify the rules into four categories.


\italicparagraph{Privilege Checks.} 
24 rules delineate the necessary privileges for executing specific token operations. 
%
Regarding the pattern of required code, 
20 rules involve 
performing a condition check and throwing an exception if the check fails, 
while others require calling a function for a subsequent check.
We further analyze the object being checked in each rule. Among the 24 rules,
10 pertain to verifying if the operator (\eg, a message caller) possesses
the required privilege. For example, the implementation in Figure~\ref{fig:20-high}
violates an ERC20 rule about \texttt{transferFrom()}, 
which requires the implementation
to verify the message caller is authorized to
transfer the tokens.
Additionally, three rules address whether the token owner holds sufficient privilege.
For example, function \texttt{safeTransferFrom()} 
in ERC1155 
sends tokens of a particular type from one address to another, 
and ERC1155 mandates the source has enough tokens. 
The remaining 11 rules focus on the recipients of token transfer operations. 
For instance, ERC721 specifies the recipient cannot be address zero for \texttt{safeTransferFrom()}. 
Moreover,
it also mandates calling \texttt{onERC721Received()} on the recipient when the receipt is
a contract. 
It further requires the caller to check whether the return value 
is a magic number and mandates the caller
to 
throw an exception if not. 
%Both ERC1155 and ERC3525 have similar rules.



%and the \texttt{require} in line 11 ensures adherence to this rule.



% \shihao{The remaining 7 rules focus on the error handling of the transfer process. Different ERC has different way to handle the error during the transferring. For instance, \texttt{transferFrom()} in Figure~\ref{fig:20-high}, the boolean return indicates the success of the transfer. However, ERC1155 requires transfer-related functions must revert on any other error instead of returning false.}

%\songlh{XXX}

\italicparagraph{Functionality Requirements.} 
Five types of code are required by rules in this category.
First, 24 rules specify how to generate the return value of a function. 
For example, ERC1155 mandates that \texttt{balanceOf(address \_owner, uint256 \_id)} should return the amount of tokens of type \texttt{\_id} 
owned by \texttt{\_owner}. 
In particular, when a
function returns a Boolean value, 
it implicitly requires returning \texttt{true} upon successful 
execution and \texttt{false} otherwise.
Second, 12 rules address the validation of input parameters 
and whether an exception should be 
thrown under certain conditions. 
For instance, ERC20 dictates that \texttt{transferFrom()} treats 
the transfer of zero tokens the same as the transfer of a non-zero amount. 
Figure~\ref{fig:20-high} adheres to this rule. 
Third, two rules explicitly mandate the associated function to 
throw an exception when any error occurs. 
Fourth, three rules specify how to update particular variables. 
For instance, one ERC20 rule requires \texttt{approve(address \_spender, uint256 \_value)} to overwrite the 
allowance value that the message caller allows \texttt{\_spender} to
manipulate with \texttt{\_value}. The remaining rule is from 
ERC1155 which allows transferring multiple types of tokens together  
and requires the balance update for each input token type to 
follow their order in the input array.


\input{tables/tbl-study}

\italicparagraph{API Requirements.}
The three ERCs require the declaration of 33 public functions 
that allow contract users to interact with contracts following the ERCs. 
Therefore, programmers must implement these APIs as specified to ensure compatibility.
 

%ERC721 mandates calling \texttt{onERC721Received()} on the recipient when conducting a token transfer. 
%It further requires the caller to check whether the return value of \texttt{onERC721Received()} is a magic number and mandates the caller to 
%throw an exception if not. Both ERC1155 and ERC3525 have similar rules.


\italicparagraph{Logging.}
ERCs impose logging requirements by emitting events. 
For example, ERC20 mandates the emission of a \texttt{Transfer} event 
when a transfer operation occurs (\eg, line 14 in Figure~\ref{fig:20-high}). 
In total, there are 33 rules related to logging. 
Out of these, 24 specify when an event should be emitted, 
with 8 further requiring the parameters of the event, 
while the remaining 9 pertain to event declarations.




\stepcounter{insight}
\boldunderparagraph{Insight \arabic{insight}:}
{\it{
Given that ERC rules involve various contract semantics, building 
program analysis techniques to cover those semantics and identify rule violations 
%across diverse 
%contracts 
poses a significant challenge.
}}

We further study the valid scope for each rule. 
Among the 132 rules, 
the valid scopes of 106 rules are confined to a single function. 
For instance, ERC20 mandates \texttt{transferFrom()} 
in Figure~\ref{fig:20-high} scrutinizes whether the message caller 
has the privilege to handle the token owner's tokens. 
%As another example, 43 rules concern how a function generates its return value. 
Moreover, 9 rules pertain to event declarations. 
In the remaining 17 cases, 
their valid scopes encompass the entire contract. 
For instance, ERC20 necessitates emitting a \texttt{Transfer} event 
whenever a token transfer occurs. Similarly, ERC721 requires calling \texttt{onERC721Received()} on the recipient contract for each token transfer, 
along with checking the return value. %of \texttt{onERC721Received()}.



\stepcounter{insight}
\boldunderparagraph{Insight \arabic{insight}:}
%\noindent{\textbf{Insight \arabic{insight}:}}
{\it{
Most ERC rules can be checked within a function or at an event declaration site, and there is no need to analyze the entire contract for compliance with these rules. 
}}

\input{tables/tbl-linguistic}

\subsection{Violation Impact (Why)}

We analyze the security implications of rule violations to understand why the rules are specified, and categorize the rules' 
impacts into three levels in Table~\ref{tab:study}.
%we categorize the rules' impacts into three levels.



\italicparagraph{High.}
A rule is deemed to have a high-security impact if there exists a clear 
attack path exploiting its violation, 
resulting in financial loss. 
As shown in Table~\ref{tab:study}, 36 rules fall into this category, 
encompassing all rules related to privilege checks. 
For instance, the failure to verify an operator's privilege can enable a hacker to pilfer tokens (\eg, Figure~\ref{fig:20-high}) and neglect to inspect whether a recipient address
is non-zero can lead to tokens being lost permanently. 

Regarding the rules governing the functionalities, 
non-compliance with 12 of them can also result in financial loss. 
Of these, 9 rules outline how to generate return values 
representing token ownership or privileges to operate tokens, 
such as \texttt{balanceOf()} returning 
the number of tokens of an address.
Errors that provide incorrect returns for 
these functions can lead to valid tokens being trapped in an address
or allow an address to manipulate tokens without necessary privilege. 
The remaining three rules pertain to the correct updating of token ownership. 
For instance, ERC20 requires function \texttt{approve(address \_spender, uint256 \_value)} 
to use \texttt{\_value} to overwrite the amount of tokens 
the message caller authorizes \texttt{\_spender} to manage.


%
%updating privilege-related variables. ERC20 mentioned in \texttt{approve(spender, value)} that value should overwrite the current allowance. Breaking this rule, for example, by increasing the allowance, might accidentally grant the spender more funds than intended, potentially leading to a loss of balance.
%
%}
%
% mandated by ERC3525, 
\if 0
For example, ERC3525 mandates that the receiver's slot 
of transferred tokens must match the sender's. 
As each slot in ERC3525 represents a type of tokens, 
violating this rule can cause tokens with a high value to 
transform into tokens with a low value after a transfer. 
ERC721, ERC1155, and ERC3525 all require inspection 
of whether an address has the capability to handle received tokens 
during a token transfer to prevent tokens from becoming 
trapped in the recipient address. These rules pertain to code usage and also have a high impact.
\fi



\italicparagraph{Medium.}
A rule has a medium impact if its violation can lead 
to unexpected contract or transaction behavior, while not having a clear attack path 
to causing financial loss. For example, if a public function's API fails 
to adhere to its ERC declaration requirement, 
invoking the function with a message call following the requirement 
would trigger an exception. Another example is ERC20's requirement 
that the function \texttt{transferFrom()} (\eg, Figure~\ref{fig:20-high}) treats the 
transfer of zero tokens the same way as transferring non-zero values. 
If a contract does not adhere to this rule, its behavior would be 
unexpected for the message caller.


\italicparagraph{Low.}
All event-related rules are about logging. We consider their security impact as low. 



\stepcounter{insight}
\boldunderparagraph{Insight \arabic{insight}:}
%\noindent{\textbf{Insight \arabic{insight}:}}
{\it{
For numerous rules, their violations present a clear attack path 
for potential financial loss, emphasizing the urgency of detecting and 
addressing these violations.
}}







\subsection{Linguistic Patterns (How)}
\label{sec:patterns}

Among the 132 rules, 42 specifically address function or event declarations, 
which are clearly defined using the Solidity code in the ERCs. 
The remaining 90 rules are described in natural language. 
As shown in Table~\ref{tab:linguistic}, we have identified 11 linguistic patterns 
to classify how these rules are presented. 
These 11 patterns correspond to six types of code implementations, 
as indicated by their ID prefixes (column ID in Table~\ref{tab:linguistic}): 
TP indicates throwing or not throwing an exception under certain conditions; 
CP involves calling a function, possibly with specific argument requirements; 
EP denotes emitting an event under certain conditions, 
potentially with argument requirements; 
RP involves returning a required value under certain conditions; 
AP refers to updating a variable with a new value; 
and OP indicates performing an action in a specific order.

As shown in Table~\ref{tab:linguistic}, 
four patterns (TP1, EP1, EP2, and RP1) account for over 80\% of the rules. 
TP1 is primarily used for privilege checks. For example, the ERC20 rule violated 
in Figure~\ref{fig:20-high} states, ``the function SHOULD throw unless the \_from account 
has deliberately authorized the sender of the message via some mechanism,''
which falls under TP1. 
EP1 and EP2, indicated by their prefixes, are used to emit events, 
while RP1 specifies return values. In contrast, the remaining patterns 
cover much fewer rules. For instance, 
AP2 and OP1 each associate with only one rule.



\stepcounter{insight}
\boldunderparagraph{Insight \arabic{insight}:}
%\noindent{\textbf{Insight \arabic{insight}:}}
{\it{
The majority of rules can be specified using common linguistic patterns, while 
there are a few rules that are specifically outlined in a distinct manner.
}}

\input{figures/fig-structure}


\if 0

We further categorize the 12 patterns into six groups based on how these rules are implemented in Solidity. 
Patterns with IDs sharing the same prefix are grouped together in Table~\ref{tab:linguistic}. 
Group CP encompasses seven linguistic patterns where rule implementations involve a condition check 
followed by the execution (or non-execution) of an action 
if the check passes. 
This condition check may be explicitly implemented using an \texttt{if} or a \texttt{require} statement, or it could be implemented implicitly. 
For instance, the check required by the violated rule in Figure~\ref{fig:20-high} can be performed using a subtraction operation, as illustrated by line 7. 
Group EP pertains to rules related to emitting or not emitting events, with implementations or violations involving the keyword \texttt{emit}. Similarly, group RP involves rules where implementations revolve around \texttt{return}, and group AP deals with rules where implementations involve updating field values.

\stepcounter{insight}
\boldunderparagraph{Insight \arabic{insight}:}
%\noindent{\textbf{Insight \arabic{insight}:}}
{\it{
How a rule should be implemented usually correlates with how the rule is specified in the ERC. 
}}
\fi
