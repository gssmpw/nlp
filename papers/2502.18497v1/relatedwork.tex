\section{Related works}
\label{S:2}
Classical static community detection algorithms recalculate all changes in the global network structure at each step, while dynamic approaches focus on identifying and tracking local changes within specific substructures. To improve efficiency, several approaches have been developed to solve the community detection problem in large dynamic networks.

One of the most common approaches for community detection in dynamic networks is to use a static algorithm based on the community membership of nodes from a previous snapshot of the network~\cite{AG10}. In this approach, nodes are assigned to communities based on the previous snapshot of the network and are processed regardless of the edge deletions and insertions in the batch update. The widely used implementation of the Leiden algorithm based on this approach is Leidenalg\footnote{https://github.com/vtraag/libleidenalg}. In addition to the relative flexibility, this implementation also scales well and can be used on networks with millions of nodes, as long as they can be stored in memory. The Leiden algorithm also supports multiplex partition optimization, enabling community detection on both positive and negative links~\cite{TB09}, as well as across multiple time slices~\cite{MRM10}. Furthermore, it allows partial partition optimization, where some community assignments can be fixed~\cite{ZBJ19}, providing greater flexibility in the analysis of complex networks.

In order to compare the accuracy of the modularity of dynamic algorithms, we also considered two static algorithms in the following scenario: after each batch update, a static algorithm runs on the entire network starting from a singleton partition. The first is Grappolo\footnote{https://github.com/ECP-ExaGraph/grappolo}. It is a parallel implementation of the Louvain algorithm that uses several heuristics to speed up the computation~\cite{LHK14}. It has a larger memory requirement and a slight loss in accuracy due to the random order in which the nodes are processed and the use of a different heuristic method. Additionally, the Grappolo algorithm allows the processing of large networks and has a distributed memory version available for extremely large datasets~\cite{GHT18}. The other is NetworKit\footnote{https://github.com/networkit/networkit}, a tool for high-performance network analysis. It supports large networks in the size range from thousands to billions of edges. It implements efficient graph algorithms that are parallelized to make use of parallel architectures. NetworKit includes the development of a parallel variant of the Louvain and Leiden algorithm~\cite{SM13}.

%Another approach is the Grappolo algorithm~\cite{HKT17}, which is a parallel implementation\footnote{https://github.com/ECP-ExaGraph/grappolo} of the Louvain algorithm that uses several heuristics to speed up computation~\cite{LHK14}. It may have a larger memory requirement and a slight loss in accuracy due to the random order in which the nodes are processed and the use of a different heuristic method. Additionally, the Grappolo algorithm allows the processing of large networks and has a distributed memory version available for extremely large datasets~\cite{GHT18}.

%Also, we mention the open-source tool\footnote{https://github.com/networkit/networkit} NetworKit~\cite{AGH23,SSM16} for high-performance network analysis that supports large networks in the size range from thousands to billions of edges. It implements efficient graph algorithms that are parallelized to make use of multicore architectures. NetworKit includes the development of a parallel variant of the Louvain and Leiden algorithm~\cite{SM13}.

A more efficient approach to identifying communities in dynamic graphs involves incremental expansion of the affected nodes of the network after receiving a batch of updates that include edge deletions and insertions. The newly developed Dynamic Frontier algorithm~\cite{SLe24} is a parallel implementation\footnote{https://github.com/puzzlef/leiden-communities-openmp-dynamic} of the Leiden algorithm (called DF-Leiden) that incrementally identifies and processes an approximate set of affected nodes. It follows a graph traversal-like process until the nodes' community assignments converge.

%There are various algorithms that optimize modularity. One such algorithm presented in \cite{ZB15} incrementally updates the local community of a seed set as the underlying network changes. This algorithm performs best when low-latency updates are required. The speedup achieved varies depending on the size of the local community, with larger communities performing relatively better. \cite{ZCL21} proposes DynaMo, an adaptive algorithm designed to maximize modularity gain incrementally while updating the community structure in dynamic networks. A comprehensive comparison of DynaMo with Louvain (a static algorithm) and 5 other dynamic algorithms was conducted in the experimental evaluation. Extensive experiments were conducted on 6 real-world and 10,000 synthetic networks.. It has been demonstrated that DynaMo surpasses all other five dynamic algorithms in terms of efficiency and is two to five times (on average) faster than the Louvain algorithm.

There are a variety of algorithms that use alternative methods to optimize modularity, such as stabilized label propagation~\cite{XCS13}, game theory~\cite{JX15}, local community detection~\cite{ZB15}, online iterative procedure~\cite{RPP17}, adaptive strategies~\cite{ZCL19} or node disassembly techniques~\cite{RKN24}. However, all of these methods have a number of significant drawbacks that prevent them from competing with faster and more precise algorithms for large dynamic networks.

Furthermore, there are often challenges with the efficient parallelization of dynamic algorithms. For example, load imbalance can lead to uneven workload distribution, which can cause certain processors to become idle, resulting in decreased efficiency. Another challenge is shared memory, as accessing shared memory by multiple threads requires coordination, which increases complexity and overhead. Additionally, scalability limitations can arise when adding more processors, as synchronization delays may not always improve performance. To address these challenges, some heuristics have been proposed to solve them in the Louvain algorithm using OpenMP multithreading~\cite{LHK14}. In addition, ideas have been suggested to parallelize and accelerate the Leiden algorithm without sacrificing the quality of the solution~\cite{US21,VTT19}. Specifically, the authors of~\cite{US21} describe a technique for parallelizing the local moving phase. This involves integrating a queue of active nodes into the Leiden algorithm and analyzing how the refinement phase can be carried out efficiently.

%----------------------------------------------------------------------------------------