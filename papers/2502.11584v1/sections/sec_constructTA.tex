\section{Constructing Timed Transducer from STL}
\label{sec: Transform STL into TA}

    \begin{figure*}[t]
        \begin{minipage}{.48\textwidth}
            \centering
            \begin{tikzpicture}[->,shorten >=1pt,auto,node distance=3.5cm,el/.style = {inner sep=2pt, align=left, sloped},every label/.append style = {font=\scriptsize},semithick,initial where=above]
			
			\tikzstyle{every node}=[font=\small]
			\tikzstyle{good state}=[circle,thick,draw=NavyBlue!75,fill=NavyBlue!20,minimum size=5mm,accepting]
			\tikzstyle{bad state}=[circle,thick,draw=Maroon!75,fill=Maroon!20,minimum size=3mm]
			\tikzstyle{dead state}=[rectangle,thick,draw=Maroon!75,fill=Maroon!20,minimum size=5mm]

                \node[initial, bad state]  at (0,-0.3) (S0) {$l_0$};
                \node[bad state] at (0,-2) (S2) {$l_1$};
			\node[good state] at (-2.5,-5.5)  (S3) {$l_2$};
			\node[bad state] at (2.5,-5.5)  (S4)  {$l_3$};
			
			\path (S0) edge node {$\begin{array}{c}
                                    p_1, c:=0, \mid \green{\top}\\ 
                                    \neg p_1, c:=0, \mid \green{\bot_{p_1}}  
                                    \end{array}$}(S2)
            
                      (S2) edge [loop right] node  {$\begin{array}{c} 
                                    p_1, c<t_1 \mid \green{\top} \\
                                    \neg p_1, c<t_1 \mid \green{\bot_{p_1}} \end{array}$} 
                      (S2) edge node [el,above] {$\begin{array}{c}
                                    p_1 \land p_2, c = t_1 \mid \green{\top}\\
                                    \neg p_1 \land p_2, c = t_1 \mid \green{\bot_{p_1}}\end{array}$} 
                      (S3) edge node [el,above] {$\begin{array}{c}
                                    p_1 \land \neg p_2, c=t_1 \mid \green{\top}\\
                                    \neg p_1 \land \neg p_2, c=t_1 \mid \green{\bot_{p_1}} \end{array}$} 
                      (S4)
			         (S3) edge [loop below] node {$\Sigma \mid  \green{\top}$} (S3)
            
                      (S4) edge [loop right] node [el,above] {$\begin{array}{c}
                                    p_1 \land \neg p_2, t_1 \le c < t_2 \mid \green{\top}\\ 
                                    \neg p_1 \land \neg p_2, t_1 \le c < t_2 \mid \green{\bot_{p_1}}  \end{array}$} 
                      (S4) edge node [el,above]{$\begin{array}{c} 
                                    p_1 \land p_2, t_1 \le c \leq t_2 \mid \green{\top}\\
                                    \neg p_1 \land p_2, t_1 \leq c \leq t_2 \mid \green{\bot_{p_1}}\end{array}$} (S3)
                      (S4) edge node {$\begin{array}{c}
                                    p_1 \land \neg p_2, c = t_2 \mid \green{\bot_{p_2}}\\
                                    \neg p_1 \land \neg p_2, c=t_2 \mid \green{\bot_{p_1}\land\bot_{p_2}}\end{array} $} (S3);
		\end{tikzpicture}
            \vspace{-.6cm}
            \caption{Timed Transducer $\automaton_{\until}$}
            \label{fig: until}
        \end{minipage}
        \hfill
        \begin{minipage}{.48\textwidth}
            \centering
            \begin{tikzpicture}[->,shorten >=1pt,auto,node distance=3.5cm,el/.style = {inner sep=2pt, align=left, sloped},every label/.append style = {font=\scriptsize},semithick,initial where=above]
			
			\tikzstyle{every node}=[font=\small]
			\tikzstyle{good state}=[circle,thick,draw=NavyBlue!75,fill=NavyBlue!20,minimum size=5mm,accepting]
			\tikzstyle{bad state}=[circle,thick,draw=Maroon!75,fill=Maroon!20,minimum size=3mm]
			\tikzstyle{dead state}=[rectangle,thick,draw=Maroon!75,fill=Maroon!20,minimum size=5mm]

                \node[initial, bad state]  at (0,-0.3) (S0) {$l_0$};
                \node[bad state] at (0,-2) (S1) {$l_1$};
                \node[good state] at (-2.5,-5.5) (S2) {$l_2$};
			\node[bad state] at (2.5,-5.5)  (S3) {$l_3$};

			\path (S0) edge node {$\neg p_1, c:=0 \mid \green{\top}$}
                      (S1) edge [bend right=40] node [el,above] {$ p_1 \mid \green{\top}$} (S2)
            
                      (S1) edge [loop right] node {$\neg p_1, c<t_1 \mid \green{\top}$} 
                      (S1) edge node [el,above] {$\begin{array}{c}
                                    \neg p_1 \land \neg p_2, c = t_1 \mid \green{\bot_{p_2}}\\ 
                                    \neg p_1 \land p_2, c = t_1 \mid \green{\top} \end{array}$} 
                      (S3) edge node [el,above] {$\begin{array}{c} 
                                    p_1, c < t_1 \mid \green{\top}\\
                                    p_1 \land p_2, c = t_1 \mid \green{\top}\\
                                    p_1 \land \neg p_2, c = t_1 \mid \green{\bot_{p_2}}\\ \end{array}$} (S2)
            
                      (S2) edge [loop below] node {$\Sigma \mid \green{\top}$} (S2)
            
                      (S3) edge [loop right] node [el,above]  {$\begin{array}{c}
                                    \neg p_1 \land \neg p_2, t_1 \le c < t_2 \mid \green{\bot_{p_2}}\\
                                    \neg p_1 \land p_2, t_1 \le c < t_2 \mid \green{\top}\end{array}$} 
                      (S3) edge node [el, above] {$\begin{array}{c}
                                    p_1 \land  p_2, t_1 \le c \leq t_2 \mid \green{\top}\\
                                    p_1 \land \neg p_2, t_1 \le c \leq t_2 \mid \green{\bot_{p_2}}\end{array}$} (S2)
                      (S3) edge node {$\begin{array}{c}
                                    \neg p_1 \land \neg p_2, c = t_2 \mid \green{\bot_{p_2}}\\
                                    \neg p_1 \land p_2, c = t_2 \mid \green{\top} \end{array}$} (S2);
		\end{tikzpicture}
            \vspace{-.6cm}
            \caption{Timed Transducer $\automaton_{\release}$}
            \label{fig: release}
        \end{minipage}
        
%        \vskip\baselineskip

        % \begin{minipage}{.48\textwidth}
        %     \centering
        %     \scalebox{0.9}{
        %     \begin{tabular}{@{}cccl@{}}
        %         \hline
        %         i & $\delta_i$                   & \qquad & $\lambda(\delta_i)$ \\ 
        %         \hline
        %         1 & $(l_0, p_1, \epsilon, c:=0, l_1)$ & &$\top$ \\ %$\signal'=\signal$  \\ 
        %         2 & $(l_0, \neg p_1, \epsilon, c:=0, l_1)$ & &$\bot_{p_1}$\\  %$p_1(\signal')=true$ \\ 
        %         3 & $(l_1, p_1, c<t_1, \epsilon, l_1)$ & &$\top$ \\ %$\signal'=\signal$  \\ 
        %         4 & $(l_1, \neg p_1, c < t_1, \epsilon, l_1)$ & &$\bot_{p_1}$\\ %$p_1(\signal')=true$  \\ 
        %         5 & $(l_1, p_1 \land p_2, c=t_1, \epsilon, l_2)$ & &$\top$\\ %$\signal'=\signal$  \\ 
        %         6 & $(l_1, \neg p_1 \land p_2, c=t_1, \epsilon, l_2)$ & &$\bot_{p_1}$\\ % $p_1(\signal')=true$  \\
        %         7 & $(l_1, p_1 \land \neg p_2, c = t_1, \epsilon, l_3)$ & &$\top$ \\% $\signal'=\signal$ \\
        %         8 & $(l_1, \neg p_1 \land \neg p_2, c=t_1, \epsilon, l_3)$ & &$\bot_{p_1}$ \\ % $p_1(\signal')=true$ \\
        %         9 & $(l_2, \Sigma, \epsilon, l_2)$ & & $\top$ \\ %$\signal'=\signal$  \\ 
        %         10 & $(l_3, p_1 \land \neg p_2, t_1 \le c < t_2 , \epsilon, l_3)$ & &$\top$\\ %$\signal'=\signal$  \\ 
        %         11 & $(l_3, \neg p_1 \land \neg p_2, t_1 \le c < t_2, \epsilon, l_3)$ & & $\bot_{p_1}$ \\ % $p_1(\signal')=true$  \\ 
        %         12 & $(l_3, p_1 \land p_2, t_1 \le c \leq t_2, \epsilon, l_2)$ & & $\top$ \\ % $\signal'=\signal$  \\
        %         13 & $(l_3, \neg p_1 \land p_2, t_1 \le c \leq t_2, \epsilon, l_2)$ & & $\bot_{p_1}$ \\ % $p_1(\signal')=true$  \\
        %         14 & $(l_3, \neg p_1 \land \neg p_2, c = t_2, \epsilon, l_2)$ & & $\bot_{p_1},\bot_{p_2}$ \\ % $p_1(\signal')=true\land p_2(\signal')=true$\\
        %         15 & $(l_3, p_1 \land \neg p_2, c = t_2, \epsilon, l_2)$ & & $\bot_{p_2}$ \\ % $p_2(\signal')=true$  \\
        %         \bottomrule
        %     \end{tabular}}
        %     \caption{Edges of Timed Transducer for $p_1\until_{[t_1,t_2]}p_2$ and their output labels.}
        % \label{table:until}
        % \end{minipage}
        % \hfill
        % \begin{minipage}{.48\textwidth}
        %     \centering
        %     \scalebox{0.9}{
        %     \begin{tabular}{@{}cccl@{}}
        %         \hline
        %         i & $\delta_i$                   & \qquad & $\lambda(\delta_i)_i$ \\ 
        %         \hline
        %         1 & $(l_0, \neg p_1, \epsilon, c:=0, l_1)$ & & $\top$\\ % $\signal'= \signal$ \\ 
        %         2 & $(l_0, p_1, \epsilon, \epsilon, l_2)$ & & $\top$ \\ %$\signal'=\signal$  \\ 
        %         3 & $(l_1, \neg p_1, c<t_1, \epsilon, l_1)$ & & $\top$ \\ % $\signal'=\signal$  \\ 
        %         4 & $(l_1,  p_1 , c < t_1 , \epsilon, l_2)$ & & $\top$ \\ % $\signal'=\signal$ \\ 
        %         5 & $(l_1, p_1 \land p_2, c = t_1 , \epsilon, l_2)$ & & $\top$ \\ % $\signal'=\signal$   \\
        %         6 & $(l_1, p_1 \land \neg p_2, c = t_1 , \epsilon, l_2)$ & & $\bot_{p_2}$ \\ % $p_2(\signal')=true$ \\
        %         7 & $(l_1, \neg p_1 \land \neg p_2 , c = t_1 , \epsilon, l_3)$ & & $\bot_{p_2}$ \\ % $p_2(\signal')=true$  \\
        %         8 & $(l_1, \neg p_1 \land p_2, c = t_1 , \epsilon, l_3)$ & & $\top$ \\ % $\signal'=\signal$  \\
        %         9 & $(l_2, \Sigma, \epsilon , l_2)$ & & $\top$ \\ % $\signal'=\signal$  \\
        %         10 & $(l_3, \neg p_1 \land \neg p_2, t_1 \le c < t_2 , \epsilon, l_3)$ & & $\bot_{p_2}$ \\ % $p_2(\signal')=true$  \\
        %         11 & $(l_3, \neg p_1 \land p_2, t_1 \le c < t_2 , \epsilon, l_3)$ & & $\top$ \\ % $\signal'=\signal$  \\
        
        %         12 & $(l_3, p_1 \land p_2,  t_1 \le c \leq t_2, \epsilon, l_2)$ & & $\top$ \\ % $\signal'=\signal$ \\
        %         13 & $(l_3, p_1 \land \neg p_2,  t_1 \le c \leq t_2, \epsilon, l_2)$ & & $\bot_{p_2}$ \\ % $p_2(\signal')=true$  \\
        %         14 & $(l_3,  \neg p_1 \land  \neg p_2,  c =t_2, \epsilon, l_2)$ & & $\bot_{p_2}$ \\ % $p_2(\signal')=true$\\
        %         15 & $(l_3, \neg p_1 \land p_2,  c=t_2, \epsilon, l_2)$ & & $\top$ \\ % $\signal' = \signal$  \\     
        %         \bottomrule
        %     \end{tabular}}
        %     \caption{Edges of Timed Transducer for $p_1\release_{[t_1,t_2]}p_2$ and their output labels.}
        % \label{table:release}
        % \end{minipage}
        \end{figure*}

    In this section, we outline a methodology for constructing a TT based on an STL. This TT processes the encoded timed word discussed in \cref{sec: Signal Encoding} and generates output for the corresponding enforcement strategy. 
    
    % \nzcomment{We can consider the full set of STL. I've discussed with Han how to extend this part to the full set, and given a solution to deal with the nested temporal operators. Essentially, this corresponds to the sequential composition of two timed automata.}
    % \hscomment{@Prof. Naijun. I’ve carefully considered the idea of sequential composition and have concerns that it may not be suitable for handling nested STL formulas. Could we discuss this further when you are avaiAmir Pnueli
    % }
    
    The construction process is inspired by the compositional hierarchy utilized in \cite{ferrere2019real} for building a TT for metric interval temporal logic (MITL). We have adopted this methodology and enhanced its applicability:
    \begin{enumerate*}[label=(\roman*)]
        \item It is suitable for STL, accommodating temporal operators with punctual intervals (e.g., \(\until_{[t_1,t_1]}\)),
        \item It is appropriate for runtime enforcement. The output of the TT serves as an enforcement strategy, which pinpoints the specific predicate causing the STL formula violation. This identification allows us to precisely modify only the signals involved in the failure, rather than altering all signals indiscriminately.
    \end{enumerate*}
    
    Initially, we will describe the construction of the TT for the temporal operators $\until_I$ and $\release_I$ used in the normal form of \cref{sec:Signal Temporal Logic}. Subsequently, we will present the method for composing these operators according to the structure of the STL formula.
    
 %    Our procedure consists of three steps:
 %    \begin{enumerate*}
	% \item Rewriting and extracting the structure of STL.
	% \item Constructing the \emph{timed transducer} for the atomic components of the STL formula.
	% \item Compositionally constructing the entire timed transducer.
 %    \end{enumerate*}
 %    We will now explain the procedure in detail.    
    % \subsection{Rewriting and extracting the structure of STL}
    % %\saucomment{shall we remove 3.1? or maybe we can say that:  we rewrite a STL formula using operators defined in Definition \ref{def:stl}. After rewrite the STL formula, we need to split the formula into a tree structure, each root corresponding to a boolean operator or a temporal operator. Splitting has to be done from left to right.}
    % Essentially, the first step is rewriting the given STL formula in NNF form. After rewriting the STL formula, we need to split the formula into a tree structure, each root corresponding to a boolean operator or a temporal operator (as shown in Figure \ref{fig:tree_structure}). %Splitting has to be done from left to right if brackets not specified.
    % \begin{figure}[H]
    %     \centering
    %     \includegraphics[width=0.9\linewidth]{figures/tree_structure(1).png}
    %     %\caption{$\phi_1 \until_{[a,b]} (\phi_2 \until_{[c,d]}\phi_3)$}
    %     \caption{$(\phi_1 \until_{[a,b]} \phi_2) \land (\phi_3 \until_{[c,d]}\phi_4)$}
    %     \label{fig:tree_structure}
    % \end{figure}
    
    \subsection{Timed Transducer for $\until_I$ and $\release_I$}\label{subsec:transducer}
    
    % We use timed transducers- a variant of timed automata \cite{alur1994theory}. Our transducers are signal transducers that input and output dense-time real-valued signals: the environment generates input that are transmitted instantaneously to the timed transducer; and the timed transducer generates output autonomously that are transmitted instantaneously to its environment. \saucomment{change}
        % The distinction between input and output is: \textit{output is a way of eliminating undesirable inputs.} Meaning, suppose the environment generates any (arbitrary bad) input signal; however, we wish to guarantee that the transducer exhibits some behaviour. Then instead of blocking that bad input from the environment to be transmitted to the timed transducer, we permit these inputs to occur but permit the transducer to correct the input signal by producing a (behaviour-preserving) correct output.
        %Our correctness conditions are often of the form "if the environment behaves incorrectly, then the automaton behaves correctly. Alternatively, our correctness condition may require the automaton to detect bad inputs and respond to them by outputting the correct signal. So, In our case, 
        %Thus, we have simple ways of dealing with input restrictions without including input-blocking in the model.
        
        % \begin{definition}[Timed transducer]\label{def:ta}
        %     A timed transducer is a tuple $\automaton=(\loca,\linit,\clock,\allowbreak\alphbt,\trans, \lambda, \lacpt)$, where
        %     \begin{itemize}
        %         \item $\loca$ is a finite set of locations; %\sout{categorized into three types: \emph{observing}, \emph{modifying}, and \emph{violation}}.
        %         \item $\linit\in\loca$ is the initial location;
        %         \item $\clock$ is the set of clocks;
        %         \item $\alphbt$ is the alphabet: finite sets of input variables;
        %         \item $\trans\subseteq \loca\times\alphbt\times\mathcal{G}(\clock)\times \power{\clock}\times \loca$ is the transition relation;
        %         %\item $Inv: L \rightarrow \mathcal{G}(C)$ is a mapping from locations in $L$ to clock constraints over $\clock$ also called invariants;
        %         \item \sout{The labelling $\lambda: \trans \rightarrow \Sigma$ which associates each transition with an output variables;}
        %         \sout{The labelling $\lambda: \trans \rightarrow \mu(x) \cup \{vio\} $ which associates each transition with an output variables; signal x is not defined.\\}
                
        %         The labeling $\lambda: \trans \rightarrow \Realn$, \textcolor{red}{where $n$ is the number of output alphabet};

        %         The 
        %         \item $\lacpt\subseteq\loca$ is a set of accepting locations.
        %     \end{itemize}
        % \end{definition}
        % The Timed transducer is formally defined as following:
        % \begin{definition}[Timed transducer]\label{def:ta}
        %     A timed transducer is a tuple $\automaton=(\loca,\linit,\clock,\allowbreak\alphbt,\trans, \lambda, \lacpt)$, where
        %     \begin{itemize}
        %         \item $\loca$ is a finite set of locations; %\sout{categorized into three types: \emph{observing}, \emph{modifying}, and \emph{violation}}.
        %         \item $\linit\in\loca$ is the initial location;
        %         \item $\clock$ is the set of clocks;
        %         \item $\alphbt$ is finite set of input variables;
        %         \item $\Lambda$ is finite set of output variables;
        %         \item $\trans\subseteq \loca\times\alphbt\times\mathcal{G}(\clock)\times \power{\clock}\times \loca$ is the transition relation;
        %         \item $\lambda: \trans \mapsto \Lambda$ associates each transition with an output variables;
        %         \item $\lacpt\subseteq\loca$ is a set of accepting locations.
        %     \end{itemize}
        % \end{definition}

        % Given the instantaneous and rapid nature of reactive systems, it is impractical to enforce a signal by delaying or suppressing it as suggested by \cite{10.1016/j.scico.2016.02.008,hublet2024proactive}. Instead, we construct a transducer whose output actively enforces the input word by \emph{editing it when necessary}, ensuring both \emph{soundness} and \emph{transparency}. 
        %We will now introduce the construction of the timed transducer for the $\until_I$ operator.
        
        % Consider an atomic STL formula $f$ defined over propositional variables $\varphi_1, . . . , \varphi_n$. $\automaton_{f}$ for $f$ is a timed transducer whose input alphabet is $\Sigma$ (set of n Boolean values 0 or 1), representing valuations of the propositional variables appearing in $f$ at time $t$. Given the set of signals (e.g. $\{\signal_1,\cdots, \signal_k\}$), for every input, $\automaton_{f}$ makes a transition and gives as output the values of the signals (e.g. $\mu(\signal_1), \cdots, \mu(\signal_k)$) such that propositions $\varphi_1, . . . , \varphi_n$  are satisfied by the signal values: in case a signal needs to be corrected, $\automaton_{f}$ gives as output the minimal value ($\rho(\signal_1), \cdots, \rho(\signal_k)$) such that the signal satisfies the propositions \sout{and in case a signal cannot be corrected, it gives $vio$ as output.} % (for example, $\mu(x)=0.7$). 

        %For example, consider a formula $f$ as follows $\eventually_{[0,a]}\varphi$ where $x$ is the given signal and $\varphi$ is a propositional variable such that $\varphi: \mu(x)\geq0.7$. Input alphabet $\Sigma=\{\varphi, \neg \varphi\}$ where $\varphi$ represents  $\mu(x) \geq 0.7$ (the property is satisfied) and $\neg \varphi$ represents $\mu(x)< 0.7$ (the property is not satisfied). The input word to $\automaton_{f}$ will be $(\sigma,t)$ where $\sigma \in \Sigma$. The output will be the original signal value i.e., $\mu(x)$ in case the signal is not modified and $\mu(x)=0.7$ incase the property is not satisfied and signal is modified. 

        %\textcolor{red}{For example, consider a formula $f$ as follows: $\varphi_1\until_{[a,b]}\varphi_2$ and consider $\signal$ be the given signal. $\varphi_1$ and $\varphi_2$ are the propositional variables. Let us consider $\varphi_1: \mu(\signal)\geq0.7$ and $\varphi_2: \mu(\signal)\geq0.9$. Input alphabet $\Sigma=\{\varphi_1, \neg \varphi_1, \varphi_2, \neg \varphi_2\}$ where $\varphi_1$ represents  $\mu(\signal) \geq 0.7$ (the property is satisfied), $\neg \varphi_1$ represents $\mu(\signal)< 0.7$ (the property is not satisfied), $\varphi_2$ represents  $\mu(\signal) \geq 0.9$ (the property is satisfied), $\neg \varphi_2$ represents $\mu(\signal)< 0.9$ (the property is not satisfied). The input word to $\automaton_{f}$ will be $(\sigma,t)$ where $\sigma \in \Sigma$. The output will be (1) the original signal value i.e., $\mu(\signal)$ in case the signal is not modified (2) $\mu(\signal)=0.7$ or $\mu(\signal)=0.9$ in case the property is not satisfied and signal is modified and \sout{(2) $vio$ in case the signal cannot be corrected to satisfy the property.} }
        
        
        
        
        %\sout{In our framework, the locations of the TA are categorized into three disjoint sets: \emph{observing}, \emph{modifying} and \emph{violation}. These sets will utilize distinct enforcement methods. The properties of \emph{observing} locations are (1) these locations are without location invariants (2) the output of all the incoming and outgoing transitions of this location will be the original value of the signal i.e., $\mu(x)$, meaning no enforcement done on the incoming signal.         The properties of \emph{modifying} locations are (1)  these locations are with location invariants (2) the output of some of the incoming or outgoing transitions of this location can be the modified value of the signal such that the signal satisfies all the propositional variables $\varphi_1, . . . , \varphi_n$, meaning the incoming signal can be modified.         The properties of \emph{violation} locations are (1) these locations are without location invariants (2) these are violating locations where the violations to the specified property cannot be stopped, meaning a signal cannot be corrected (3) the output of all of the incoming or outgoing transitions of this location is $vio$, a flag indicating that the signal cannot be corrected to satisfy the property.}

        %We are now ready to construct the timed transducers associated with the formula %$\eventually_{[0,a]}\varphi$ 
        %$\varphi_1\until_{[a,b]}\varphi_2$ and $\varphi_1\release_{[a,b]}\varphi_2$.
 
 
        \paragraph{TT for $p_1\until_{[t_1,t_2]}p_2$} We firstly present the construction of the TT \( \automaton_{\until} \), which is designed to enforce a signal according to the STL formula \( p_1 \until_{[t_1, t_2]} p_2 \). The structure of the transducer \( \automaton_{\until} \) is defined as follows:
        \begin{itemize}
            \item $\loca=\{l_0, l_1, l_2, l_3\}$; 
            \item $\linit=l_0$;
            \item $\clock=\{c\}$;
            \item $\alphbt= \{p_1,p_2\}$;
            \item $\Lambda = \{\top, \bot_{p_1}, \bot_{p_2} \}$;
            %\item $\trans$%=\{ \delta_1,\delta_2, \cdots,\delta_{15} \}$;
            %\item $\lambda$%=\{\lambda_1,\cdots \lambda_{15}\}$;
            \item $\lacpt=\{l_2\}$.
        \end{itemize}
        %\hscomment{Do we really need the table?}
        %\saucomment{ @ Dr Srinivas yes. In the current model, both good and bad cases are moving to the same state with True/False output labels.  however as u suggested, if we can just model all the bad cases to move to a violation trap state then following issues: in figure 4 of  until transducer, at location $l_1$, suppose input $\neg p_1 \land p_2$ comes at time t1. This is not an acceptable behaviour. Thus one acceptable  behaviour out of following must be chosen: $ p_1 \land p_2$, $p_1 \land \neg  p_2$.       Choosing $p_1 \land \neg  p_2$ is not appropriate because it alters signals to satisfy both the predicates: not a minimal modification. Thus we have just a single acceptable behaviour : $ p_1 \land p_2$. we tried to capture this whole information in the TA, thus we have output variables too}
        
        The set of transitions $\Delta$ and the corresponding outputs $\lambda$ of \(\automaton_{\until}\) is depicted in \cref{fig: until}. 
        
        In the output alphabet, \(\top\) represents the strategy of making no change to the signal value, while \(\bot_{p_i}\) indicates that the signal value should be modified to satisfy the predicate \(p_i\). Essentially, an output of \(\bot_{p_i}\) suggests how the input action should be modified to achieve a \(\top\) output. For instance, if the transition from \(l_1\) to \(l_2\) in \cref{fig: until} has an input action of \(\neg p_1 \land p_2\) and outputs \(\bot_{p_1}\), it implies that the input should be changed to \(p_1 \land p_2\) to ensure a \(\top\) output in this transition.
        
        % \begin{remark}
        %     The output labels  $\lambda_i$  associated with each transition  $\delta_i$  in Table \ref{table:until} specify the modifications made to the signal by the timed transducer to ensure that the predicates are satisfied. For the signals $\signal$ and predicates  $p_1$  and  $p_2$ :
        %     \begin{enumerate*}[label=(\roman*)]
        %         \item $\signal{\prime} = \signal$ indicates that the values of the signal should remain unaltered by the enforcer / enforcement algorithm.
        %         \item $p_i(\signal{\prime}) = \text{true}$ indicates that the value of the signal should be minimally modified by the enforcer / enforcement  to satisfy the predicate $p_i$.
        %     \end{enumerate*}
        %     This framework ensures that the enforcement strategy either retains the original signal values or adjusts them minimally to meet the STL requirements.
        % \end{remark}

        

        We propose below the equivalence of \emph{Until} operator of STL and its transducer. 
        \begin{restatable}{proposition}{restateUntil}
        %[Equivalence of \emph{Until} operator of STL and its transducer]    
            \label{propo1}
            Let $\signal$ be a signal and $\tword$ denote its encoded timed word against the STL formula $p_1\until_{[t_1,t_2]}p_2$. Define $\bm{\omega}_{\top}$ as the timed word where all event actions are $\top$. The following equivalence is then established:
            %Let $\signal$ be a signal. Let $\tword$ be its encoded timed word against the given STL formula $p_1\until_{[t_1,t_2]}p_2$. %Let $\rho$ be the run of $\automaton_{p_1\until_{[t_1,t_2]}p_2}$ over $\sigma$ from its initial state. 
            %Let $\bm{\omega}_{\top}$ be the timed word with actions of all its events being $\top$. 
            %for the accepting run over $\tword$, where the output of all transition being $\top$. 
            %Then, the following equivalence holds:
            \[
            \llangle\automaton_{\until}\rrangle(\tword) = \bm{\omega}_{\top} \iff \signal \models p_1 \until_{[t_1, t_2]} p_2
        \]
        \end{restatable}

        %Proof (of Proposition \ref{propo1} - sketch only).
        The proof relies on the case analysis based on the events received in time intervals $[0, t_1]$ and $(t_1,t_2]$. The detailed proof is provided in \cref{sec:appendix}.


        \paragraph{TT for $p_1\release_{[t_1,t_2]}p_2$}  Here, we detail the construction of the TT \( \automaton_{\release} \). The structure of the TT \( \automaton_{\release} \) is defined as follows:

        
        % We let $\automaton=(\loca,\linit,\clock,\allowbreak\alphbt,\trans, \lambda, \lacpt)$, where
        \begin{itemize}
            \item $\loca=\{l_0, l_1, l_2, l_3\}$; 
            \item $\linit=l_0$;
            \item $\clock=\{c\}$;
            \item $\alphbt=\{p_1,p_2\}$;
            \item $\Lambda = \{\top, \bot_{p_1}, \bot_{p_2} \}$;
            %\item $\trans$%=\{ \delta_1 \cdots \delta_{15} \}$;
            %\item $\lambda$%=\{\lambda_1 \cdots \lambda_{15}\}$;
            \item $\lacpt=\{l_2\}$.
        \end{itemize}
        where $\trans$ and the corresponding $\lambda$ are given in \cref{fig: release}.
        %\hscomment{@saumya Pls refer to the preliminary, the output is a function map transition to the output alphabet, therefore no need the subscripts. I suggest we eliminate the transition and output defined in item environment, and refer to the figure for these two components.}
        % The timed transducer $\automaton_{\until}$ is depicted in \cref{fig: release}. We denote $\signal'=\signal$ by simply $\top$ (meaning no change in signals value) and $p(\signal)=true$ by $\bot_p$ (meaning signals value changed to satisfy predicate $p$).

         We propose below the equivalence of \emph{Release} operator of STL and its transducer. 

         \begin{restatable}{proposition}{restateRelease}
         %[Equivalence of \emph{Release} operator of STL and its transducer]   
            \label{propo2}
            Let $\signal$ be a signal and $\tword$ denote its encoded timed word against the given STL formula $p_1\release_{[t_1,t_2]}p_2$. 
            Let $\bm{\omega}_{\top}$ be defined as before.
            %the output timed word for the accepting run over $\tword$, where the output of all transitions being $\top$. 
            The following equivalence is then established:
            \begin{align*}
            \llangle\automaton_{\release}\rrangle(\tword) = \bm{\omega}_{\top} \iff \signal \models p_1 \release_{[t_1, t_2]} p_2
            \end{align*}
        \end{restatable}
        
        The proof shares a similar idea with \cref{propo1} and is therefore omitted here.

        \begin{remark}
            Essentially, the TT we constructed is \emph{self-correcting}; that is, any transition within the TT has the potential to result in an acceptable run. This allows us to use such a TT to enforce a signal without worrying about the TT entering a violation state where no acceptable run exists.
        \end{remark}
%Proof (of Proposition \ref{propo2} - sketch only). 
%The proof relies on case analysis based on the events received in time intervals: $[0, t_1], (t_1,t_2]$. The detailed proof is provided in Appendix \ref{sec:appendix}.


    \subsection{Compositionally Constructing the Entire Timed Transducer}
    %\hscomment{Formally define the composition}
        % Composition method: parallel Composition and Sequential Composition.
        % \saucomment{pending}
        In this paper, because we consider non-nested STL, the possible connections between two sub-formulas containing temporal operators (i.e., \(p_1 \until_I p_2\) or \(p_1 \release_I p_2\)) are limited to either conjunction or disjunction. Consequently, it is sufficient to define the product of TTs we constructed in \cref{subsec:transducer} according to $\land$ or $\lor$.
        
        \paragraph{$\land$-Product} We will first explain how to construct TT of property in the form of $\varphi_1\land\varphi_2$ by taking product between TTs, where the TTs for $\varphi_1$ and $\varphi_2$ have been constructed as $\automaton_{1}$ and $\automaton_{2}$, respectively.
        
        \begin{definition}[$\land$-Product]
            Given two TTs $\automaton_1=(\loca_1,\linit^1,\clock_1,\alphbt_1,\Lambda_1,\trans_1,\allowbreak\lambda_1,\lacpt_1)$ and $\automaton_2=(\loca_2,\linit^2,\clock_2,\alphbt_2,\Lambda_2,\trans_2,\lambda_2,\lacpt_2)$\footnote{To avoid multiple subscripts, the indices of automata for the initial condition $l_0$ have been moved from superscript to subscript for both $\automaton_1$ and $\automaton_2$}, the $\land$-product automaton $\automaton_1\times_{\land}\automaton_2\Def (\loca,\linit,\clock,\alphbt,\Lambda,\trans,\lambda,\lacpt)$, where
            \begin{itemize}
                \item $\loca = \loca_1 \times \loca_2$,
                \item $\linit = (\linit^1,\linit^2)$,
                \item $\clock = \clock_1 \cup \clock_2$,
                \item $\alphbt = \alphbt_1 \cup \alphbt_2$,
                \item $\Lambda = \Lambda_1 \cup \Lambda_2$,
                \item $\delta = \left((l_1,l_2),(a_1,a_2),g_1 \land g_2,\clock_1'\cup\clock_2',(l_1',l_2')\right) \in \trans$ iff \\ 
                $\delta_1 = (l_1,a_1,g_1,\clock_1',l_1')\in \trans_1$ and $\delta_2 =(l_2,a_2,g_2,\clock_2',l_2')\in \trans_2$,
                \item $\lambda(\delta) = \lambda_1(\delta_1)\land\lambda_2(\delta_2) $,
                \item $\lacpt = \lacpt_1\times\lacpt_2$.
            \end{itemize}
        \end{definition}
        %\hscommentinline{define how $\lambda_1(\delta_1)\land\lambda_2(\delta_2)$ work}        

        \paragraph{$\lor$-Product} We now explain how to construct TT of property in the form of $\varphi_1\lor\varphi_2$ by taking product between TTs, where the TTs for $\varphi_1$ and $\varphi_2$ have been constructed as $\automaton_1$ and $\automaton_2$, respectively.

        \begin{definition}[$\lor$-product]
            Given two TTs $\automaton_1=(\loca_1,\linit^1,\clock_1,\alphbt_1,\Lambda_1,\trans_1,\allowbreak\lambda_1,\lacpt_1)$ and $\automaton_2=(\loca_2,\linit^2,\clock_2,\alphbt_2,\Lambda_2,\trans_2,\lambda_2,\lacpt_2)$, the $\lor$-product automaton $\automaton_1\times_{\lor}\automaton_2\Def (\loca,\linit,\clock,\alphbt,\Lambda,\trans,\lambda,\lacpt)$, where
            \begin{itemize}
                \item $\loca = \loca_1 \times \loca_2$,
                \item $\linit = (\linit^1,\linit^2)$,
                \item $\clock = \clock_1 \cup \clock_2$,
                \item $\alphbt = \alphbt_1 \cup \alphbt_2$,
                \item $\Lambda = \Lambda_1 \cup \Lambda_2$,
                \item $\delta = \left((l_1,l_2),(a_1,a_2),g_1 \land g_2,\clock_1'\cup\clock_2',(l_1',l_2')\right) \in \trans$ iff \\ 
                $\delta_1 = (l_1,a_1,g_1,\clock_1',l_1')\in \trans_1$ and $\delta_2 =(l_2,a_2,g_2,\clock_2',l_2')\in \trans_2$,
                \item $\lambda(\delta) = \lambda_1(\delta_1)\lor\lambda_2(\delta_2) $,
                \item $\lacpt = (\lacpt_1\times\loca_2)\cup(\loca_1\times\lacpt_2)$.
            \end{itemize}
        \end{definition}
        % \saucomment{need to define $\omega_{\top}$: The output timed word, where all transition outputs are $\top$, is denoted by $\omega_{\top}$.}
        % \hscomment{As we plan to move the main result to section 4.1, and $\omega_{\top}$ has been defined in the proposition, we may not need to defined it here.}
        
        Essentially, the primary distinction between the $\land$-product and the $\lor$-product lies in the output function $\lambda$ and the acceptance condition $F$. For a formula of the form $\varphi_1 \land \varphi_2$, the signal must satisfy both $\varphi_1$ and $\varphi_2$. Therefore, a transition in the product TT is considered `good' (i.e., the output action is $\top$) iff the transitions in both $\automaton_{\varphi_1}$ and $\automaton_{\varphi_2}$ are `good'. Additionally, the acceptance condition must ensure that the acceptance locations of both TTs are reached. Conversely, for a formula of the form $\varphi_1 \lor \varphi_2$, it is sufficient for the signal to satisfy either $\varphi_1$ or $\varphi_2$.
        
        By induction on the structure of a given STL formula, the following proposition holds:
        \begin{restatable}{proposition}{restateComposition}\label{prop:composition}
            Let $\signal$ be a signal and $\tword$ denote its encoded timed word against the given STL formula $\varphi_1\,op\,\varphi$, where $op\in\{\land,\lor\}$. Let $\bm{\omega}_{\top}$ be defined as in \cref{propo1}. The following equivalence is then established: 
            \[
                \llangle\automaton_{\varphi_1}\times_{op}\automaton_{\varphi_2}\rrangle(\tword) = \bm{\omega}_{\top} \iff \signal \models \varphi_1\,op\,\varphi_2.
            \]            
        \end{restatable}

    %     Because we considered non-nested STL in this paper, the possible connections between two sub-formulas contain temporal operators (i.e., $p_1\until_I p_2$ or $p_1\release_I p_2$) are either \emph{conjunction} or \emph{disjunction}. Therefore, we only need to define how to make composition between two TTs we constructed in \cref{subsec:transducer}.

        
    %     In this paper, we support composition using the conjunction ($\land$) and disjunction ($\lor$) operators, meaning we allow the forms $\varphi \land \varphi$ and  $\varphi \lor \varphi$, where $\varphi$ can represent any of the following: \sloppy $\top , p(\signal), \neg p(\signal), \varphi, (\varphi_1 \mathcal{U}_I \ \varphi_2),  (\varphi_1  \mathcal{R}_I \ \varphi_2)$.

    % To obtain a composite timed transducer for $\varphi_1 \land \varphi_2$, we take the timed transducers $\mathcal{A}_{\varphi_1}$ and $\mathcal{A}_{\varphi_2}$  corresponding to $\varphi_1$ and $\varphi_2$, respectively, and compute their product to form a transducer representing $\varphi_1 \land \varphi_2$. The final state in this composite transducer is the final state of both the transducers. %denoted by (q_1, q_2) \in F, is achieved if and only if \( q_1 \in F_1 \) and \( q_2 \in F_2 \), where \( F_1 \) and \( F_2 \) are the final states of \( A_{\varphi_1} \) and \( A_{\varphi_2} \), respectively.

    % Similarly, to obtain a composite timed transducer for $\varphi_1 \lor \varphi_2$, we take the timed transducers $\mathcal{A}_{\varphi_1}$ and $\mathcal{A}_{\varphi_2}$  corresponding to $\varphi_1$ and $\varphi_2$, respectively, and compute their product to form a transducer representing $\varphi_1 \lor \varphi_2$. The final state in this composite transducer is the final state of any of the transducer.

    % %The procedure is conceptually simpler than \cite{ferrere2019real}. 
    

    


    
