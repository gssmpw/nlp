\section{Related Works}
\label{sec:RL}
% \hscommentinline{this section need to be rewrite.}
\paragraph{Runtime enforcement for reactive systems.}
A framework to synthesize enforcers for reactive systems, called shields, from a set of safety properties was introduced in \cite{10.1007/978-3-662-46681-0_51}. The uni-directional shield observes inputs from the environment and outputs from the system (program) and transforms erroneous outputs. It considered untimed properties expressed as automata. 

Authors in \cite{10.1145/3126500,10.1145/3092282.3092291,10.1109/TII.2019.2945520} extendes \cite{10.1007/978-3-662-46681-0_51} and considered bi-directional runtime enforcement for reactive systems. The enforcer presented a monitoring framework which monitors both the inputs and the outputs of a synchronous program and (minimally) edits erroneous inputs/outputs in order to guarantee a given property.  In \cite{10.1145/3092282.3092291,10.1109/TII.2019.2945520}, the properties are discrete properties, expressed using a variant of timed automata  %(dense time properties can be expressed as Timed Automata) 
called Discrete Timed Automata (DTA) and Valued Discrete Timed Automata (VDTA). These are TAs with integer-valued clocks (i.e., FSMs extended with a set of integer variables that are used as discrete clocks, for instance, to count the number of ticks before a certain event occurs).  The use of DTA/VDTA over TA is primarily motivated by the fact that the approach can directly use a formulation similar to synchronous languages, where time is discretized. This makes the overall algorithm simple and does not require region or zone graph construction. All transitions take one tick relative to the ticks of a synchronous global clock inspired by synchronous languages. The environmental inputs are captured %\sout{by an additional piece of hardware called the Reactive Functional Unit (RFU)} 
and are made available. % on the next tick boundary (at the onset of the next tick). 
During a tick, all three components â€“ the environment, the program, and the enforcer- are executed once. 


The monitoring frameworks in \cite{10.1145/3092282.3092291,10.1109/TII.2019.2945520} are for discrete systems where they sampled the execution (i.e. the inputs signal occurring in the environment) to contain a number of observable state changes. For continuous timed systems, however, variables can change arbitrarily fast. For monitoring signals of time-continuous systems for dense-time properties using \cite{10.1145/3092282.3092291,10.1109/TII.2019.2945520}, the observations can be made only at discrete moments, each observation contains only partial information. This is not effective. Because only the whole set of possible observations of a particular execution can restore all information on that execution, thus, this work contributes an enforcement mechanism for dense-time real-valued signals for continuous timed systems. 

\paragraph{STL for specifying properties of CPS} STL \cite{10.1007/978-3-540-30206-3_12} is used for specifying linear-time properties of continuous real-valued signals. 
The logic of STL is based on a bounded subset of the real-time logic MITL \cite{10.1145/227595.227602} i.e. MITL$_{[a,b]}$. 
In MITL$_{[a,b]}$ all temporal modalities are restricted to intervals of the form $[a, b]$
with $0 \leq a < b$ and $a, b \in \mathbb{Q}_{\geq 0}$, where the behavior of a system is observed for a finite time interval. 

There exist frameworks for monitoring STL properties. For example, the framework in \cite{10.1007/978-3-540-30206-3_12} automatically creates property monitors that can check whether a given signal of bounded length and finite variability satisfies the property. However, this was for offline monitoring and not for correcting the signal if not according to the property. Authors in \cite{sun2024redriver} attempt enforcement (correcting a signal) specifically for the self-driving realm. %They essentially handle an offline runtime enforcement problem: 
It is based on the predictive environment constructed by the sensors of the car. If the AV is predicted to potentially violate them in the near future (based on the quantitative semantics of STL), the REDriver framework repairs the trajectories using a gradient-driven algorithm. However, in some situations, the enforcer may not have access to the prediction of future signals.


Our work presents a more general approach to enforcing STL properties. Unlike existing literature, it adopts a more formal enforcement method, where the enforcer corrects the signal while adhering to some critical constraints.

