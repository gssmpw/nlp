\section{Introduction}

% Runtime enforcement is a light-weight method to formally ensure some specified properties of systems.
% It has attracted more and more interests.

% Modern systems have more and more real-time requirement --- reactive system. 
% Traditional mechanisms of RE may not usable for such system (i.e., suppressing, buffering input actions)
% Existing method only considered safety property, there is a lack of an uniform hierarchy for runtime enforcement of reactive system

% In this paper, we considered RE of properties expressed in signal temporal logic for reative system. 
% STL is a temporal language with rich expressive, can be used to specified the property of signals in dense time.

% contribution

% outline 

Modern Cyber-Physical Systems (CPSs), especially those with emerging AI-enabled modules, are becoming increasingly difficult to verify formally, and sometimes even impossible, due to the chaotic behavior of the AI modules. Runtime Enforcement (RE) \cite{schneider2000enforceable}, serving as a lightweight formal method, has attracted increasing research interest in recent years for the verification of CPSs.
%RE utilises a set of formal properties along with the black-box system, and enforces these properties over the system
%at run-time. 
In RE, an \emph{enforcer} is synthesized to monitor the executions of a black-box system at runtime, ensuring compliance with a set of desired properties. In the event of a violation, the enforcer employs evasive actions to output property complaint words.  %the enforcer modifies the input execution to ensure that the output adheres to the specified properties. 
There are various evasive actions, such as:
\begin{enumerate*}[label=(\roman*)]
    \item blocking the execution \cite{10.1145/353323.353382},
    \item modifying the input sequence by suppressing and/or inserting actions \cite{10.1007/s10207-004-0046-8,10.1145/1455526.1455532}, and
    \item buffering input actions until they can be safely forwarded \cite{DBLP:journals/fmsd/FalconeMFR11,10.1007/978-3-030-32079-9_4,10.1007/978-3-642-35632-2_23,10.1007/s10703-014-0215-y,10.1016/j.scico.2016.02.008}.
\end{enumerate*}
However, these evasive actions may not be suitable for CPSs since delaying reactions or terminating the system may be impractical \cite{10.1145/3092282.3092291}. 

One key aspect of CPS is the need for active interaction between the controller (the Cyber part) and the plant (the Physical part) \cite{10.1145/3126500}. This interaction involves responding immediately to various events or signals emitted by the plant. Consequently, the enforcer must address erroneous executions in CPS without delay and ensure continuous operation. 
%A typical example of how the RE works for CPS is shown in \cref{fig:pacemaker}. A pacemaker is enforced against the requirement that ``\textit{an Atrial Pacing (\textsf{AP}) should be followed by a Ventricular Pacing (\textsf{VP}) within the Atrioventricular Interval (\textsf{AVI})}''. As shown in \cref{fig:pacemaker}, an enforcer the \textsf{AP} emitted by the pacemaker at time $t_1$ until it can confirm that the requirement is met—that is, a \textsf{VP} is emitted by the pacemaker at time $t_2$ satisfying $t_2-t_1 \le \textsf{AVI}$. However, such a strategy could have a catastrophic impact on the life of the patient.

% \begin{figure}[h]
%     \centering
%     \begin{adjustbox}{max width = 1\linewidth}
%         \scalebox{1}{
%             \begin{tikzpicture}
%                 \draw[rounded corners] (-5,2.5) -| (-3,3.5) -- (-5,3.5) -- cycle; 
%                 \node at(-4,3) {Heart};
                
%                 \draw[rounded corners] (3,2.5) -| (5,3.5) -- (3,3.5) -- cycle;
%                 \node at(4,3) {Pacemaker};
                
%                 \draw[rounded corners, dashed] (2,-1.5) -| (6,1.5) -- (2,1.5) -- cycle;
%                 \node at(4,0){
%                     \begin{tikzpicture}
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=-0.5:0] plot(\x,0.8) node[below]{\black{$t_1$}};
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=0:0.52] plot(\x,{0.8*sin(6*\x r)+0.8});
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=0.52:3, -stealth] plot(\x,0.8) node[above]{\black{\textsf{AP}}};

%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=-0.5:0.785] plot(\x,-0.5) node[below]{\black{$t_2$}};
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=0.785:1.31] plot(\x,{0.8*cos(6*\x r)-0.5});
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=1.31:3, -stealth] plot(\x,-0.5) node[above]{\black{\textsf{VP}}};
%                     \end{tikzpicture}};
%                 \node at(4.6,1.2) {$t_2-t_1 \le \textsf{AVI}$};
%                 \node at(4,-1.8) {original control signal};

%                 \draw[rounded corners, dashed] (-6,-1.5) -| (-2,1.5) -- (-6,1.5) -- cycle;
%                 \node at(-4,0){
%                     \begin{tikzpicture}
%                         \draw[color=Violet, thick] (0,0.9) -- (0,0.8) node[below]{\black{$t_1$}};
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=-0.5:0.785] plot(\x,0.8) node[below]{\black{$t_2$}};
%                         \draw[color=Maroon, samples=20, line width=1.5pt, domain=0.785:1.31] plot(\x,{0.8*cos(6*\x r)+0.8});
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=1.31:3, -stealth] plot(\x,0.8) node[above]{\black{\textsf{AP}}};

%                         \draw[color=Violet, thick] (0,-0.4) -- (0,-0.5) node[below]{\black{$t_1$}};
%                         \draw[color=Violet, thick] (0.785,-0.4) -- (0.785,-0.5) node[below]{\black{$t_2$}};
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=-0.5:2.09] plot(\x,-0.5) node[below]{\black{$t_2+\textsf{AVI}$}};
%                         \draw[color=Maroon, samples=20, line width=1.5pt, domain=2.09:2.62] plot(\x,{0.8*sin(6*\x r)-0.5});
%                         \draw[color=Violet, samples=20, line width=1.5pt, domain=2.62:3, -stealth] plot(\x,-0.5) node[above] {\black{\textsf{VP}}};
%                     \end{tikzpicture}};
%                 \node at(-4,-1.8) {enforced control signal};
                
%                 \draw[rounded corners] (-0.5,-0.5) -| (1.1,0.5) -- (-0.5,0.5) -- cycle;
%                 \node at (0.3,0) {Enforcer};

%                 \draw[-Stealth, thick] (-3,3) -- node[above]{electrode signal} (3,3);
%                 \draw[-Stealth, thick] (4,2.5) -- (4,1.5);
%                 \draw[-Stealth, thick] (-4,1.5) -- (-4,2.5);
%                 \draw[-Stealth, thick] (2,0) -- (1.1,0);
%                 \draw[-Stealth, thick] (-0.5,0) -- node[above] {Delay} (-2,0);
%             \end{tikzpicture}
%         }
%     \end{adjustbox}
%     \caption{RE for Pacemaker}
%     \label{fig:pacemaker}
% \end{figure}

Different methods have been proposed to synthesize enforcers for CPSs. Authors in \cite{10.1007/978-3-662-46681-0_51} first introduced a framework to synthesize enforcers for reactive systems, focusing solely on safety properties and considering untimed properties expressed as automata. Subsequent studies, including \cite{10.1145/3126500,10.1145/3092282.3092291,10.1109/TII.2019.2945520}, extended this framework to include bi-directional runtime enforcement for CPSs. However, all these methods assume a system model in discrete time, meaning they presuppose that signals or events occur only at discrete `ticks'. Although this assumption simplifies the modeling, it is devoid of the expressive power of continuous time specifications. %As depicted in \cref{fig:pacemaker}, the system interacts directly with a physical entity—the heart—and such simplifications 
%and can sometimes result in incorrect system behaviors. 
%Furthermore, existing methods consistently focus on properties directly presented using automata, without addressing the complexities involved in constructing such automata from more intricate properties.


% \begin{figure}[H]
%             \centering
%             \includegraphics[width=1\linewidth]{figures/overview.png}
%             \caption{Overview}
%             \label{fig:overview}
% \end{figure}

\begin{figure}[h]
    \centering
    \begin{adjustbox}{max width = 1\linewidth}
        \scalebox{1}{
            \begin{tikzpicture}[font=\footnotesize]
                \node (stl) at(3.8,1.3) {STL Formula $\varphi$};
                \node[sine wave icon, scale=0.4] (s) at (-2.5,0) {};
                \node[bubble=Goldenrod] (signal) at (0,0) {Signal\\Encoding\\\cref{sec: Signal Encoding}};
                \node[bubble=DarkOrchid] (trans) at (3.8,0) {Construct\\Timed\\Transducer\\\cref{sec: Transform STL into TA}};
                \node[bubble=NavyBlue] (modified) at (3.8,-1.9) {Enforcer\\\cref{sec:Runtime Enforcement against STL}};

                \draw[rounded corners, dashed] (-1, -0.85) -| (5,1.6) -- (-1,1.6) -- cycle;
                \node at(0,-0.7) {\scriptsize{Transform STL to TT}};
                
                \draw[-stealth] (s) -- node[above, xshift = -5pt]{\scriptsize{Signal $\signal$}} (signal);
                \draw[-stealth] (signal) -- node[below] {\scriptsize{$(t_0,a_0),\cdots,(t_k,a_k)$}} node[above]{\scriptsize{Timed Word $\tword$}} (trans);
                % \draw[-stealth] (trans) -- node[left] {\scriptsize{$\begin{array}{r}\text{Enforce}\\\text{Strategy}\end{array}$}} (modified);
                \draw[-stealth] (trans) -- node[left, yshift=-5pt]{\scriptsize{Timed Transducer $\automaton_\varphi$}} (modified);
                \draw[-stealth] (stl) -| (signal);
                \draw[-stealth] (stl) -- (trans);
                \draw[-stealth] (-1.5,0) |- (modified);
                \draw[-stealth] (modified) -- (3.8,-2.6) node[below] {\scriptsize{Output Signal $\resltsig\models\varphi$}};
            \end{tikzpicture}
        }
    \end{adjustbox}
    \vspace{-0.4cm}
    \caption{Overview}
    \label{fig:overview}
\end{figure}

In this paper, we take a step further by proposing a uniform hierarchy to synthesize enforcers for CPSs operating in dense time, with properties expressed using \emph{Signal Temporal Logic} (STL). The enforcer processes an input signal $\signal$ observed up to the current time $t$ and generates an output signal $\resltsig$ that satisfies the specified STL formula $\varphi$. As illustrated in \cref{fig:overview}, the enforcer encompasses three steps:
\begin{enumerate*}[label=(\roman*)]
\item Encoding a signal $\signal$ as a timed word in accordance with the STL formula. The timed word can be recognized by a timed automaton. This procedure is depicted as the yellow block in \cref{fig:overview}.
\item Constructing a variant of Timed Automaton (TA) from the given STL formula. The TA, with both input and output, is represented as \emph{Timed Transducer} (TT). The output of the TT indicates the enforcement strategy to be applied to the current input event (illustrated as the purple block in \cref{fig:overview}).
\item Enforcing a signal $\signal$ using the TT $\automaton_\varphi$ constructed from STL formula $\varphi$ (represented as the blue block in \cref{fig:overview}).
\end{enumerate*}
A significant advantage of our enforcer is that it \emph{does not} require reachability analysis because the enforcement strategies used are encoded explicitly within the timed transducer. Our experimental results demonstrate the effectiveness of our approach and provides empirical evidence of its suitability for CPS.

Our enforcer is characterized by \emph{soundness} (the output signal $\resltsig$ satisfy $\varphi$), \emph{transparency} (the input signal $\signal$ are only modified when necessary), and \emph{minimal modification} (the difference between the output and input signal values is minimal). Our work makes the following contributions:
\begin{enumerate}
    \item We propose a method to encode dense time signals into time words while preserving the information required to adjust the compliance of a given signal with a specified STL formula (\cref{sec: Signal Encoding}),
    \item we introduce a uniform approach to construct timed transducers against STL formulae, enabling these transducers to enforce the compliance of the STL formula on the input timed word (\cref{sec: Transform STL into TA}),
    \item we develop a method to minimally modify the signal to ensure its satisfaction with respect to the given STL formula (\cref{sec:Runtime Enforcement against STL}), and
    \item we provide experimental evidence to demonstrate the effectiveness of our approach (\cref{Case Study}).
\end{enumerate}

\paragraph{Organization} \cref{sec:Preliminaries and notations} provides a recap of important preliminaries and formally defines the problem. The process of encoding a signal into a timed word is detailed in \cref{sec: Signal Encoding}. The transformation of STL into TTs is discussed in \cref{sec: Transform STL into TA}. \cref{sec:Runtime Enforcement against STL} describes the method for signal modification and the comprehensive runtime enforcement algorithm for STL formulas. A relevant case study is presented in \cref{Case Study}. Related works are reviewed in \cref{sec:RL}. Finally, the conclusions and future work are outlined in \cref{sec:Conclusions and Future Works}. 

% The problem can be formalized as follows: Given an STL formula $\varphi$, construct an enforcement function $E_{\varphi}:(X\times\NonNegReals)\mapsto X$, such that for all input signals $\signal$, the resulting signals $\resltsig=E_{\varphi}(\signal,t)$ satisfy (i) the given STL formula $\varphi$ (soundness) %i.e., $\resltsig \vDash\varphi$,
% and (ii) transparency.




%An motivate example - pacemaker, to show why can delay, why consider dense time is important, and how to enforce.
%
%Existing method: 1. system react in discrete time, 2. only considered safety property
%
%We proposed a method to enforce reactive systems against a dense-time specification - STL.



% \saucomment{remove}
% \noindent \textit{Reactive systems and Synchronous programming.} The traditional view of a computer system is that of a black box, with input following processing, and processing following output, after which the program terminates. This is known as a transformational system because the relation of the input to the output is sufficient to completely characterise the program's behaviour. 

% In contrast, for reactive systems \cite{10.1007/978-3-642-82453-1_17} the relation of the input to the output is not sufficient to completely characterise the program's behaviour, i.e. they are not adequately described by a relational or functional view. Reactive systems are interactive by nature: they interact continuously with their environment at a speed imposed by the environment. Typically they will receive some initial input, but then continue to interact with their environment during their execution, by both sending output to and receiving new input from the environment. At a more abstract level, the role of a reactive system is to provide and maintain an interaction with its environment, not just by manipulating data but by reacting to many different kinds of events, signals and conditions. Real-time systems such as avionics systems are examples of reactive systems.

% Synchronous programming \cite{BENVENISTE199835} is a useful approach to designing reactive systems. The synchronous programming defines some aspects of how these programs deal with reactive systems: the programs are considered to be (1) non-terminating (2) interact continuously with the adjoining environment / external events (3) react instantaneously (in no time) to it (4) all parts of the system have the same knowledge of events at a given instant; this is achieved by instantly broadcasting events between sub-processes, etc.\\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \noindent \textit{Runtime enforcement in the context of synchronous programs.} Runtime enforcement (RE) is a technique to monitor the execution of a (black-box) system at runtime and ensure its compliance with a set of formal requirements. In the event of a violation, using an enforcement monitor (EM) / enforcer, an (untrustworthy) input execution (in the form of a sequence of events that does not comply with the property) is modified into an output sequence that complies with a property. % (e.g., a safety requirement). 

% For that, the enforcer performs certain evasive actions so as to prevent the violation. The evasive actions might include blocking the execution \cite{10.1145/353323.353382}, modifying input sequence by suppressing and/or inserting actions \cite{10.1007/s10207-004-0046-8,10.1145/1455526.1455532}, and buffering input actions until a future time when it could be forwarded \cite{DBLP:journals/fmsd/FalconeMFR11,10.1007/978-3-030-32079-9_4,10.1007/978-3-642-35632-2_23,10.1007/s10703-014-0215-y,10.1016/j.scico.2016.02.008}.

% None of the evasive actions described above is appropriate for synchronous reactive systems since delaying the reaction, terminating the system, or not reacting instantaneously when an error is observed is infeasible. The enforcer for a synchronous reactive system must act upon erroneous outputs on the fly and continue operating (cannot halt). Considering this, there is recent interest in runtime enforcement of synchronous reactive systems.

% \cite{10.1007/978-3-662-46681-0_51} introduced a framework to synthesize enforcers for reactive systems, called shields, from a set of safety properties. The uni-directional shield observes inputs from the environment and outputs from the system (program) and transforms erroneous outputs. \cite{10.1007/978-3-662-46681-0_51} considered untimed properties expressed as automata. 

% \cite{10.1145/3126500,10.1145/3092282.3092291,10.1109/TII.2019.2945520} extendes \cite{10.1007/978-3-662-46681-0_51} and considered bi-directional runtime enforcement for reactive systems. The enforcer presented in the framework monitors both the inputs and the outputs of a synchronous program and (minimally) edits erroneous inputs/outputs in order to guarantee that a given property holds.  In \cite{10.1145/3092282.3092291,10.1109/TII.2019.2945520}, the properties are discrete properties, expressed using a variant of TA (dense time properties can be expressed as Timed Automata) called Discrete Timed Automata (DTA) and Valued Discrete Timed Automata (VDTA). These are TAs with integer-valued clocks (i.e., TAs extended with a set of integer variables that are used as discrete clocks, for instance, to count the number of ticks before a certain event occurs).  The use of DTA/VDTA over TA is primarily motivated by the fact that the approach can directly use a formulation similar to synchronous languages, where time is discretized. This makes the overall algorithm simple and does not require region or zone graph construction. All transitions take one tick relative to the ticks of a synchronous global clock inspired by synchronous languages. The environmental inputs are captured \sout{by an additional piece of hardware called the Reactive Functional Unit (RFU)} and are made available on the next tick boundary (at the onset of the next tick). During a tick, all three components – the environment, the program, and the enforcer- are executed once. \\

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \noindent \textit{Motivation: Need of enforcement mechanism for dense-time real-valued signals and STL for real-valued, temporal properties.} %For the discrete systems in [2,3], the execution (i.e. the inputs events / signal occurring in the environment asynchronously)  consists of a number of observable state changes. \sout{or transitions leading to a state-transition sequence} In the case of time-continuous systems, however, variables can change arbitrarily fast. So, a particular execution can only be described by recording at each moment the state of the system. If one would maintain that, observations can be made only at discrete moments, each observation contains only partial information. Only the whole set of possible observations of a particular execution can restore all information on that execution. 
% The monitoring frameworks in \cite{10.1145/3092282.3092291,10.1109/TII.2019.2945520} are for discrete systems where they sampled the execution (i.e. the inputs signal occurring in the environment) to contain a number of observable state changes. For time-continuous systems, however, variables can change arbitrarily fast. For monitoring signals of time-continuous systems for dense-time properties using \cite{10.1145/3092282.3092291,10.1109/TII.2019.2945520}, the observations can be made only at discrete moments, each observation contains only partial information. Thus, is not effective. Because only the whole set of possible observations of a particular execution can restore all information on that execution. Thus, there is a need for an enforcement mechanism for dense-time real-valued signals from time-continuous systems. 
% \saucomment{Question: Does not make this an Asynchronous Reactive System where the reactions may happen at unpredictable times, depending on when the events are received and how the system schedules its tasks?}

% Summarising above, in the domain of continuous and hybrid reactive systems, the input events/signal to a synchronous program that we want to monitor / correct (or even the outputs of a synchronous program) are dense-time real-valued signals and thus the properties we need to specify are dense-time properties. 

% Now, Signal Temporal Logic (STL) \cite{10.1007/978-3-540-30206-3_12} is a temporal logic formalism for specifying linear-time properties of continuous real-valued signals. 
% The logic of STL is based on a bounded subset of the real-time logic MITL \cite{10.1145/227595.227602} i.e. MITL$_{[a,b]}$. 
% In MITL$_{[a,b]}$ all temporal modalities are restricted to intervals of the form $[a, b]$
% with $0 \leq a < b$ and $a, b \in \mathbb{Q}_{\geq 0}$, where the behaviour of a system is observed for a finite time interval. There exist frameworks for monitoring of STL properties. For example, the framework in \cite{10.1007/978-3-540-30206-3_12} automatically create property monitors that can check whether a given signal of bounded length and finite variability satisfies the property. However, this was for offline monitoring and not for correcting the signal if not according to the property. \cite{sun2024redriver} attempts enforcement (correcting a signal). They essentially handle an offline runtime enforcement problem: it is based on the predictive environment constructed by the sensors of the car. If the AV is predicted to potentially violate them in the near future (based on the quantitative semantics of STL), the REDriver framework repairs the trajectories using a gradient-driven algorithm. 
% However, in some situations, the enforcer may not have access to the prediction of future signals.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \noindent \textit{Contribution.} In this work, we aim to construct a runtime enforcer for a given STL formula $\varphi$. The enforcer takes as input signals $\signal$ observed up to the current time $t$ and outputs (minimally modified) signals $\resltsig$. % that satisfies $\varphi$. 
% The enforcer should always comply with some constraints such as \textit{soundness} (the output signal $\resltsig$ satisfies the given STL formula $\varphi$), \textit{transparency} (the input signal $\signal$ is modified only when necessary and in a minimal way), etc while modifying an input. Transparency ensures that the enforcer modifies the signal minimally such that the quantitative semantics, or robustness, of STL formulas \cite{10.1007/978-3-642-14295-6_17} %\hscomment{cite "Breach A Toolbox for Veriﬁcation and Parameter Synthesis of Hybrid Systems Alexandre Donzé"} 
% is strictly positive meaning that the formula is satisfied and the magnitude is minimum which indicates how "robustly" the formula is satisfied. %\sout{Also, the enforcer will only modify the signal at the last time instants that the STL property is to be violated.} 
% Also, the enforcer will modify the signal at the moment of the property violation, just before the point at which it can no longer be corrected. 
% %The problem can be formalized as follows: Given an STL formula $\varphi$, construct an enforcement function $E_{\varphi}:(X\times\NonNegReals)\mapsto X$, such that for all input signal $\signal$, the resulting signals $\resltsig=E_{\varphi}(\signal,t)$ satisfy  $\varphi$, i.e. $\resltsig \vDash\varphi$.
% The problem can be formalized as follows: Given an STL formula $\varphi$, construct an enforcement function $E_{\varphi}:(X\times\NonNegReals)\mapsto X$, such that for all input signals $\signal$, the resulting signals $\resltsig=E_{\varphi}(\signal,t)$ satisfy (i) the given STL formula $\varphi$ (soundness) %i.e., $\resltsig \vDash\varphi$,
% and (ii) transparency.




% The approach that we follow is: We will first translate the given STL formula into a timed transducer suitable for enforcement such that if a signal is accepted by the timed transducer, then it satisfies the corresponding STL formula. We then %specify constraints on an enforcer and 
% devise an enforcer or enforcement algorithm. % which is a solution to the specified constraints. 
% A signal to be corrected is encoded as a timed word that is capable of being accepted by the timed transducer. Then property expressed as timed transducer is enforced onto the signal by the enforcement algorithm (meaning upon input timed word, the timed transducer is traversed and the timed word / signal is corrected using an enforcement algorithm).

% The steps can be summarized as follows (and is illustrated in the Figure \ref{fig:overview}):
% \begin{enumerate}
%     \item Signal Encoding: A signal should be encoded as a timed word that is capable of being accepted by the timed transducer.
%     \item Transforming STL formula (to be enforced onto the given input signal) into a timed transducer.
%     \item Enforcing the property expressed as a timed transducer onto the signal.
% \end{enumerate}


% \begin{figure}[H]
%             \centering
%             \includegraphics[width=1\linewidth]{figures/overview.png}
%             \caption{Overview}
%             \label{fig:overview}
% \end{figure}

   %          \scalebox{.8}{
			% \begin{tikzpicture}
			% 	\tikzstyle{terminator} = [rectangle, draw, text centered, rounded corners, minimum height=2em]
			% 	\tikzstyle{process} = [rectangle, draw, text centered, minimum height=2em]
			% 	\tikzstyle{decision} = [diamond, draw, text centered, minimum height=2em]
			% 	\tikzstyle{data}=[trapezium, draw, text centered, trapezium left angle=60, trapezium right angle=120, minimum height=2em]
			% 	\tikzstyle{connector} = [draw, -latex']
			% 	\tikzstyle{cloud} = [draw, ellipse,text width= 8em, fill=blue!20, node distance=2cm, minimum height=2em]  
				
			% 	\node [terminator, fill=blue!20] at (0,0) (Transform) {Transform};
			% 	\node [terminator, fill=blue!20] at (5,0) (Transducer) {Transducer};
			% 	\node [data, fill=red!20] at (3,3) (STL specification)  {STL specification};  
				
			% 	\path [connector] (-2,0) -- node[above] {signal} (Transform);
   %              \path [connector] (Transform) -- node[above] {Timed word} (Transducer);
   %              \path [connector] (STL specification) -- (Transducer);
   %              \path [connector] (STL specification) -- (Transform);
   %              \path [connector] (Transducer) -- node[left] {signal} (5,-2);
			% 	\path [connector] (Transducer) -- node[right] {transformed signal} (8,-2);
			% \end{tikzpicture}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% \noindent \textit{Outline.} The paper is organized as follows: preliminary concepts and notations for timed automata/transducers and signal temporal logic are covered in Section \ref{sec:Preliminaries and notations} along with the problem formulation. Encoding the signals into a timed word is explained in Section \ref{sec: Signal Encoding}. The transformation of  STL into timed transducers is explained in Section \ref{sec: Transform STL into TA}. 
% Runtime Enforcement of STL formulas is provided at Section
% \ref{sec:Runtime Enforcement against STL}. A relevant case study is given in Section \ref{Case Study}. Main results (soundness of the translation of the STL formulas into the transducers) are provided in Section \ref{sec:results}. Finally, conclusions and future works are presented in Section \ref{sec:Conclusions and Future Works}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






% Advantage:
% \begin{itemize}
%     \item Give a more formal guarantee of the enforcer, in compared with \cite{sun2024redriver}
%     \item \cite{sun2024redriver} is designed only for self-driving realm, we considered a more general mechanism in this paper. 
%     \item \cite{sun2024redriver} essentially handled an off-line runtime enforcement problem: it based on the predicate environment constructed by the sensors of the car. However, in some institution, the enforcer may not have access to the prediction of future signal.
% \end{itemize}








% My paper:
% given dynamics in each modes, and an STL formula, we can synthesize the guard conditions for each discrete transitions.

% if we want to use the existing method, we need to model the dynamics of signal using ODE first

% This is conflict with the aim of runtime enforcement (monitoring and correcting, without modeling the system)









