\section{Signal Encoding}
\label{sec: Signal Encoding}

    % \begin{figure*}[htbp]
    %         \centering
    %         \begin{adjustbox}{max width=1\linewidth}
    %             \begin{tikzpicture}[font=\small]
    %                 \centering
    %                 \begin{scope}
    %                     \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
    %                     \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$x_1$};
    %                     \draw[dashed, color = gray] (0,1.05) node[left] {\black{$0.7$}} -- (6,1.05);
                        
    %                     \draw[color=NavyBlue, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
    %                         (0, 0.6)
    %                         (0.6, 1.05)
    %                         (1.2, 1.3)
    %                         (1.9, 1.2)
    %                         (2.7, 1.05)
    %                         (3.3, 0.94)
    %                         (3.8, 1.05)
    %                         (4.5, 1.3)
    %                         (5.4, 1.05)
    %                         (6.0, 0.8)
    %                     };
                        
    %                     \node at (0,0) [below] {\green{$0$}};
    %                     \draw[dashed, color = gray] (0.6, 0) node[below] {\orange{$0.5$}} -- (0.6,1.5);
    %                     \draw[dashed, color = gray] (2.7, 0) node[below] {\orange{$2.2$}} -- (2.7,1.5);
    %                     \draw[dashed, color = gray] (3.8, 0) node[below] {\orange{$3.2$}} -- (3.8,1.5);
    %                     \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
    %                     \draw[dashed, color = gray] (5.4, 0) node[below] {\orange{$4.5$}} -- (5.4,1.5);
    %                     \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
    %                 \end{scope}

    %                 \begin{scope}[shift = {(8,0)}]
    %                     \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
    %                     \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$x_2$};
    %                     \draw[dashed, color = gray] (0,0.75) node[left] {\black{$0.5$}} -- (6,0.75);

    %                     \draw[color=Maroon, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
    %                         (0, 1.2)
    %                         (1.4, 0.75)
    %                         (2.3, 0.15)
    %                         (3.5, 0.3)
    %                         (4.5, 0.6)
    %                         (5.6, 0.75)
    %                         (6.0, 1)
    %                     };

    %                     \node at (0,0) [below] {\green{$0$}};
    %                     \draw[dashed, color = gray] (1.4, 0) node[below] {\orange{$1.2$}} -- (1.4,1.5);
    %                     \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
    %                     \draw[dashed, color = gray] (5.6, 0) node[below] {\orange{$4.7$}} -- (5.6,1.5);
    %                     \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
    %                 \end{scope}
                    
    %                 \node at(6,-1.3) {
    %                        $\begin{array}{c}
    %                             \textsf{timestamps}  \\
    %                             \textsf{actions}
    %                        \end{array}
    %                        \left(\!\!\!\begin{array}{c}
    %                            \green{0}  \\
    %                            \nblue{\neg p_1}\land \maroon{p_2} 
    %                       \end{array}\!\!\!\right) 
    %                       \left(\!\!\!\begin{array}{c}
    %                            \orange{0.5}  \\
    %                            \nblue{p_1}\land \maroon{p_2} 
    %                       \end{array}\!\!\!\right)
    %                       \left(\!\!\!\begin{array}{c}
    %                            \orange{1.2}  \\
    %                            \nblue{p_1}\land \maroon{\neg p_2} 
    %                       \end{array}\!\!\!\right)
    %                       \left(\!\!\!\begin{array}{c}
    %                            \orange{2.2}  \\
    %                            \nblue{\neg p_1}\land \maroon{\neg p_2} 
    %                       \end{array}\!\!\!\right)
    %                       \left(\!\!\!\begin{array}{c}
    %                            \orange{3.2}  \\
    %                            \nblue{p_1}\land \maroon{\neg p_2} 
    %                       \end{array}\!\!\!\right)
    %                       \left(\!\!\!\begin{array}{c}
    %                            \green{4}  \\
    %                            \nblue{p_1}\land \maroon{\neg p_2} 
    %                       \end{array}\!\!\!\right)
    %                       \left(\!\!\!\begin{array}{c}
    %                            \orange{4.5}  \\
    %                            \nblue{\neg p_1}\land \maroon{\neg p_2} 
    %                       \end{array}\!\!\!\right)
    %                       \left(\!\!\!\begin{array}{c}
    %                            \orange{4.7}  \\
    %                            \nblue{\neg p_1}\land \maroon{p_2} 
    %                       \end{array}\!\!\!\right)
    %                       \left(\!\!\!\begin{array}{c}
    %                            \green{5}  \\
    %                            \nblue{\neg p_1}\land \maroon{p_2} 
    %                       \end{array}\!\!\!\right)$
    %                 };
    %             \end{tikzpicture}
    %         \end{adjustbox}
    %         \caption{Signal Encoding against Formula $p_1\until_{[4,5]}p_2$}
    %         \label{fig:signal-encoding}
            % \vskip\baselineskip
            
            % \begin{minipage}{.48\textwidth}
            %         \centering
            %         \begin{tabular}{c c c c}
            %             \toprule
            %             \textsf{clock} & \textsf{input} & \textsf{location after transition} & \textsf{output}  \\
            %             \midrule
            %              0   & $\neg p_1\land p_2$ & $l_1$ & $\bot_1$ \\
            %              0.5 & $ p_1\land p_2 $     & $l_1$ & $\top$   \\
            %              1.2 & $ p_1\land\neg p_2 $ & $l_1$ & $\top$   \\
            %              2.2 & $\neg p_1\land \neg p_2 $ & $l_1$ & $\bot_1$ \\
            %              3.2 & $p_1\land \neg p_2 $     & $l_1$ & $\top$   \\
            %              4   & $p_1\land \neg p_2 $     & \red{$l_3$} & $\top$   \\
            %              4.5 & $\neg p_1\land \neg p_2 $  & $l_3$ & $\bot_1$   \\
            %              4.7 & $\neg p_1\land p_2 $     & \red{$l_2$} & $\bot_1$\\  
            %              \bottomrule
            %         \end{tabular}
            %         \captionof{table}{Enforcement of timed word  obtained from Figure \ref{fig:signal-encoding} using Until Transducer}
            %         \label{tab:table_enf}
            % \end{minipage}
            % \hfill
            % \begin{minipage}{.48\textwidth}
            %     \centering
            %     \begin{tikzpicture}
            %         \centering
            %         \begin{scope}
            %             \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
            %             \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$\signal_1$};
            %             \draw[dashed, color = gray] (0,1.05) node[left] {\black{$0.7$}} -- (6,1.05);
                        
            %             \draw[color=NavyBlue, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
            %                 %(0, 0.75)
            %                 (0.6, 1.05)
            %                 (1.2, 1.3)
            %                 (1.9, 1.2)
            %                 (2.7, 1.05)};
            %                 %(3.3, 0.94)
            %             \draw[color=NavyBlue, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
            %                 (3.8, 1.05)
            %                 (4.5, 1.3)
            %                 (5.4, 1.05)
            %                 %(6.0, 0.8)
            %             };
            %             \draw[color=red, line width = 1.6pt] plot coordinates{(0,1.05) (0.6,1.05)};
            %             \draw[color=red, line width = 1.6pt] plot coordinates{(2.7,1.05) (3.8,1.05)};
            %             \draw[color=red, line width = 1.6pt] plot coordinates{(5.4,1.05) (5.6,1.05)};
                        
            %             \node at (0,0) [below] {\green{$0$}};
            %             \draw[dashed, color = gray] (0.6, 0) node[below] {\orange{$0.5$}} -- (0.6,1.5);
            %             \draw[dashed, color = gray] (2.7, 0) node[below] {\orange{$2.2$}} -- (2.7,1.5);
            %             \draw[dashed, color = gray] (3.8, 0) node[below] {\orange{$3.2$}} -- (3.8,1.5);
            %             \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
            %             \draw[dashed, color = gray] (5.4, 0) node[below] {\orange{$4.5$}} -- (5.4,1.5);
            %             \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
            %         \end{scope}

            %         \begin{scope}[shift = {(0,-2.3)}]
            %             \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
            %             \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$\signal_2$};
            %             \draw[dashed, color = gray] (0,0.75) node[left] {\black{$0.5$}} -- (6,0.75);

            %             \draw[color=Maroon, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
            %                 (0, 1.2)
            %                 (1.4, 0.75)
            %                 (2.3, 0.15)
            %                 (3.5, 0.3)
            %                 (4.5, 0.6)
            %                 (5.6, 0.75)
            %                 (6.0, 1)
            %             };

            %             \node at (0,0) [below] {\green{$0$}};
            %             \draw[dashed, color = gray] (1.4, 0) node[below] {\orange{$1.2$}} -- (1.4,1.5);
            %             \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
            %             \draw[dashed, color = gray] (5.6, 0) node[below] {\orange{$4.7$}} -- (5.6,3.8);
            %             \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
            %         \end{scope}
                     
            %     \end{tikzpicture}
            %     \caption{Signal After Enforcement}
            %     \label{fig:after-enforce}
            % \end{minipage}
        % \end{figure*}
    In this section, we will introduce the procedure for encoding a signal into a timed word. This step is essential because we aim to enforce a signal using a TT, but a signal, defined as a real-valued function over dense time, is not directly compatible with TT. 
    %A signal, defined as a real-valued function over dense time, is not directly compatible with transducers. To bridge this gap, we introduce a procedure to encode the signal into a timed word, which is accepted by a transducer. 
    
    The encoding process, applied to a given signal $\signal$ with respect to an STL formula $\varphi$, involves recording the truth value of predicates of $\varphi$ at both \emph{variable points} and \emph{relevant points} within the signal. We will now provide a detailed explanation of this encoding procedure.

    \paragraph{Variable Points}
    Intuitively, a variable point is where the truth value of a predicate regarding the signal changes.
        The concept of variable points is as below.
        \begin{definition}[Variable Point \customcite{bae2019bounded}{Def.~2.8}]
            Given a signal $\signal:\NonNegReals \mapsto \Realn$, a time point $\tau\in \NonNegReals$ is a variable point of $\signal$ with respect to a predicate $p(\signal)$ if for some neighborhood $B$ containing $\tau$, there are different truth values $u$ and $v$ such that $p(\signal)=u$ for every $t\in B\cap [0,\tau)$ and $p(\signal)=v$ for every $t\in B\cap (\tau,+\infty)$.
        \end{definition} 

        
        
        In this paper, we limit our focus to \emph{non-Zeno} signals constrained within a \emph{bounded} time frame. Consequently, such signals possess a finite number of variable points. There is a notable characteristic of variable points, formalized in the following proposition:
        \begin{proposition}
            Given a signal $\signal$ and a predicate $p(\signal)$, assume $t_0 < t_1 < \cdots < t_k$ denote all the variable points of $\signal$ with respect to $p(\signal)$. It is then established that the truth value of $p(\signal)$ remains constant within each open interval $(t_i, t_{i+1})$ for all indices $i = 0, 1, \ldots, k$\footnote{Here, $t_{k+1}$ is defined to be the endpoint of the signal $\signal$.}.
        \end{proposition}

        Consequently, the signal $\signal$ can be effectively encoded as a timed word:
        \[
            \tword = (t_0, a_0), (t_1, a_1), \cdots, (t_k, a_k),
        \]
        where each $t_i$ denotes a variable point with respect to $p(\signal)$, and each $a_i$ represents the truth value of $p(\signal)$ within the interval $(t_i, t_{i+1})$ for indices $i = 0, 1, \ldots, k$. This encoding method ensures that $\tword$ comprehensively captures all information about $\signal$ with respect to the predicate $p(\signal)$. 

        The set of variable points of a signal with respect to an STL formula $\varphi$ is defined as the union of the sets of variable points for all predicates $p\in pd(\varphi)$\footnote{Recall that $pd(\varphi)$ is defined as the set of predicates in an STL formula $\varphi$ in \cref{sec:Preliminaries and notations}}. Accordingly, the timed word can be constructed based on these combined variable points. 
    %
        The following example provides a comprehensive illustration of this process:

        \begin{example}\label{exp:variable-point}
            Consider the signal $\signal=(x_1, x_2)$ illustrated in \cref{fig:signal-encoding}, and the STL formula $\varphi = p_1 \until_{[4,5]} p_2$, with $p_1 \equiv x_1 - 0.7 \ge 0$, and $p_2 \equiv x_2 - 0.5\ge 0$. The time word for $\signal$ with respect to $\varphi$ is given by:
            \begin{align*}
            &(0.5,p_1\land p_2),(1.2, p_1 \land \neg p_2),(2.2, \neg p_1\land \neg p_2),(3.2, p_1\land \neg p_2),&&\\
            &(4.5,\neg p_1\land \neg p_2), (4.7, \neg p_1 \land p_2)%\qquad\qquad\qquad\qquad\qquad
            &&\lhd
            \end{align*}
            %\qedT
        \end{example}
        %\hscomment{The procedure of computing the variable point is given here.}
        
        The values of a signal \(\signal\) that may lead to variable points against the predicate \(p(\signal)\) can be determined by solving the equation \(\mu_p(x)=0\). Depending on the structure of $\mu_p(x)$, different methods can be used to find or approximate the root of $\mu_p(x)$:
        \begin{enumerate*}[label=(\roman*)]
            \item Gaussian elimination is suitable for linear forms of $\mu_p(x)$,
            \item Newton-Raphsom method can be used for polynomial forms of $\mu_p(x)$,
            \item For more complex forms, such as transcendental equations, the Real roots isolation method \cite{gan2017reachability} can be used to approximate the intervals of the roots.
        \end{enumerate*}
        Using $vv(p)$ to denote the set of such valuations against predicate $p$, then $vv(\varphi) = \cup_{p\in pd(\varphi)}vv(p)$ for a given STL formula $\varphi$.  
        
        Variable points are effective for documenting changes in a signal in accordance with a specific STL formula. However, they may not provide sufficient information for \emph{enforcing} compliance with an STL property.
        Consider, for example, the scenario depicted in \cref{exp:variable-point}, where the proposition $p_1$ is false within the time interval $[0,0.5)$. This condition leads to the STL formula $\varphi$ not being satisfied by the signal $\signal$. However, in the absence of an input event before $t=0.5$ — specifically, an input at $t=0$ — no transducer can confirm that $\varphi$ is unsatisfied by the signal, nor can it enforce the signal accordingly.
        To address this, it becomes necessary to incorporate \emph{relevant points} tailored to an STL formula, ensuring all relevant events are recorded. %\nzcomment{We may need to discuss how to compute the set of variable points for a given STL formula and a set of signals, which depends on the structure of the formulas and the signals.}

        
        \paragraph{Relevant Points} Intuitively, relevant points include the time points that correspond to the interval boundaries of the given formula and the initial instant of the given signal. These points mark where the satisfaction requirements for predicates may change. For example, in the formula \( p_1 \until_{[t_1,t_2]} p_2 \), before \(t_1\), ensuring that \(p_1\) is satisfied suffices. However, after \(t_1\), it is also necessary to verify the satisfaction of \(p_2\).
        
        We proceed to inductively define relevant points of an STL formula as follows:
            \begin{definition}[Relevant Point]
                Given an STL formula $\varphi$, the set of relevant points $rp(\varphi)$ is inductively defined by:
                \begin{gather*}
                rp(\top) = \emptyset,\quad rp(\varphi_1\land\varphi_2) = rp(\varphi_1)\cup rp(\varphi_2),\\ %assuming \varphi_1 is until, etc.
                rp(p(x)) = \{ 0 \},\quad rp(\varphi_1\lor\varphi_2) = rp(\varphi_1)\cup rp(\varphi_2),\\
                rp(\varphi_1\until_{[t_1,t_2]}\varphi_2) = \{t_1,t_2\}\cup rp(\varphi_1) \cup rp(\varphi_2),\\
                rp(\varphi_1\release_{[t_1,t_2]}\varphi_2) = \{t_1,t_2\}\cup rp(\varphi_1)\cup rp(\varphi_2).
                \end{gather*}
            \end{definition}

            % Intuitively, relevant points include the time points that correspond to the interval boundaries of the given formula and the initial instant of the given signal. These points mark where the satisfaction requirements for predicates may change. For example, in the formula \( p_1 \until_{[t_1,t_2]} p_2 \), before \(t_1\), ensuring that \(p_1\) is satisfied suffices. However, after \(t_1\), it is also necessary to verify the satisfaction of \(p_2\).
            
            % Intuitively, relevant points contain the time points that correspond to the interval boundary of the given formula and the initial instant of the given signal. 
            % These are the points where satisfaction requirements of the predicates may change. Such as for $p_1\until_{[t_1,t_2]}p_2$, before $t_1$, only $p_1$ show be ensure to be satisfied, but after $t_1$, we also need to check about the satisfaction of $p_2$.
            
            % These are the points where we need to make sure that the signal, if not satisfying the respective predicates in the formula, then definitely satisfy the predicates during enforcement. 
            
            The actions of events at time points $t \in rp(\varphi)$ reflect the truth values of all predicates in $\varphi$ at time $t$, which can be directly sampled in real-time from the signal. Consider the following example for further illustration:
            
            \begin{example}\label{exp:relavant-point}
                Continuing \cref{exp:variable-point}, recall that $\varphi=p_1\until_{[4,5]}p_2$. The set of relevant point $rp(\varphi)=\{0,4,5\}$, and the events at relevant points with respect to signal $\signal=(x_1,x_2)$ is:
                \begin{align*}
                    (0,\neg p_1\land p_2),(4, p_1\land \neg p_2),(5,\neg p_1\land p_2).
                \end{align*}
                Consequently, the complete time word encoded from $\signal$ with respect to the STL formula $\varphi$ is depicted in \cref{fig:signal-encoding}. The events at variable points are highlighted in orange, while the events at relevant points are marked in green.
                \qedT
            \end{example}

        \paragraph{Signal encoding} We now give the process of signal encoding. 
        The signal encoding process, as outlined in \cref{alg:signal-encoding}, operates in real-time by monitoring changes in the truth values of predicates within the given STL formula. In an infinite loop, the algorithm waits for the input signal (\cref{line:await}) at current time $t$ (the function \textsf{current\_time()} can be used to get the current time as shown in \cref{line:time}). It updates the truth values \texttt{CurrPred} of all predicates (\cref{line:update value}) with respect to the current signal values. An event is emitted (\cref{line: emit}) whenever a variable point or relevant point is met (\cref{line:if condition}). 
        %The identification of variable points is achieved by comparing the truth value \texttt{PrevPred} in the previous loop with the current truth value \texttt{CurrPred} (the condition $\texttt{CurrPred}\neq \texttt{PrevPred}$ in the line \ref{line:if condition}).

    %     \hscomment{how to update the time $t$ in \cref{alg:signal-encoding} should be clarify}
    %     \begin{algorithm}[H]
    %     \caption{$\textsf{SignEncode}(\signal,\varphi)$}
    %     \label{alg:signal-encoding} %\scriptsize
    %     \begin{algorithmic}[1]
    %         \Require $\signal$: signal, $\varphi$: STL formula
    %         \Ensure $\sigma$: time word encoded from $\signal$
    %         \State $\texttt{Rele} \gets rp(\varphi)$, $\texttt{Pred} \gets pd(\varphi)$ 
    %         \State $\texttt{CurrPred} \gets [False,\cdots,False]$ 
    %         \State $\texttt{PrevPred} \gets [False,\cdots,False]$
    %         \While {await\_signal} 
    %             \State Update current time $t$  \label{line:update time}
    %             \State $\texttt{CurrPred}\gets$ Truth values of predicates $p\in \texttt{Pred}$ with respect to $\signal$ at $t$\label{line:update value}
    %             \If{$\texttt{CurrPred}\neq \texttt{PrevPred}$ or $t\in \texttt{Rele}$} \label{line:if condition}
    %                 \State Emit $(t,\texttt{CurrPred})$ \label{line: emit}
    %             \EndIf
    %             \State $\texttt{PrevPred}\gets \texttt{CurrPred}$
    %         \EndWhile
    %     \end{algorithmic}
    % \end{algorithm}
    \begin{algorithm}[H]
        \caption{$\textsf{SignEncode}(\varphi)$}
        \label{alg:signal-encoding} %\scriptsize
        \begin{algorithmic}[1]
            \Require $\varphi$: STL formula
            \Ensure $\sigma$: time word encoded from $\signal$
            \State $\texttt{Rele} \gets rp(\varphi)$, $\texttt{Vari} \gets vv(\varphi)$,  $\texttt{Pred} \gets pd(\varphi)$ 
            %\State $\texttt{CurrPred} \gets [False,\cdots,False]$ 
            %\State $\texttt{PrevPred} \gets [False,\cdots,False]$
            \While {true}
                \State $\signal$ $\gets$ \textsf{await\_signal}() \label{line:await}
                \State $t$ $\gets$ \textsf{current\_time}() \label{line:time} \Comment{Get the current time $t$}
                \State $\texttt{CurrPred}\gets$ Truth values of predicates $p\in \texttt{Pred}$ with respect to $\signal$ at $t$\label{line:update value}
                %\If{$\texttt{CurrPred}\neq \texttt{PrevPred}$ or $t\in \texttt{Rele}$} \label{line:if condition}
                \If{$\signal(t)\in\texttt{Vari}$ or $t\in\texttt{Rele}$}\label{line:if condition}
                    \State Emit $(t,\texttt{CurrPred})$ \label{line: emit}
                    %\State Emit $(t,)$
                \EndIf
                %\State $\texttt{PrevPred}\gets \texttt{CurrPred}$
            \EndWhile
        \end{algorithmic}
    \end{algorithm}

    \begin{remark}
        During the signal encoding process, we can proactively identify variable points and relevant points, allowing for the enforcement of the signal before any actual violations occur. This proactive enforcement can be achieved by:
        \begin{enumerate*}[label=(\roman*)]
            \item expanding the values at a variable point into its surrounding neighborhood, and
            \item slightly adjusting the timing of relevant points in $rp(\varphi)$ to check these points in advance.
        \end{enumerate*}
    \end{remark}

    
    %In \cref{alg:signal-encoding}, $Rele$ is the set of relevant points. $Pred$ is set of  predicates included in the STL formula $\varphi$. Initially, the current and previous truth values of all the predicates with respect to $\signal$ is set to $False$, i.e., $CurrPred \gets [False,\cdots,False]$ and $Prevpred \gets [False,\cdots,False]$. Upon receiving a signal, the (current) truth values of all the predicates is found out. If those changed, then the truth values of the predicates are emitted (as a timed event) along with the current time. Also, if the current time point is a relevant point, then the truth values of the predicates at the current relevant point are emitted (as a timed event) along with the current time.
    % In order to enforce the signal using TA, we need first encode the continuous signal into timed word, which can be accepted by a TA.
    
    % The given signals, to be corrected, $\signal_1, \cdots, \signal_k$ should be encoded as a time word that is capable of being accepted by a timed transducer.
    % The first step is: for each given signal, we extract the variable points. 
    %for the given signal we extract the variable points. For a signal $\signal: D \mapsto \Realn$, a time point $\tau\in D$ is called a \emph{variable point} if the truth value of a proposition changes at time $\tau$ on the signal $\signal$. we take all the variable points with the truth value of the preposition and constitute the primary timed word. however this is not the final encoding of a signal to be relayed to the transducer. we need to carefully observer (and modify/enforce) the signal at the interval boundaries if the signals do not satisy the given STL formula. why at boundaries, because we want to modify the signals  just before the point after which it can no longer be corrected. thus we account those boundary time points into our timed word. and this gives our final timed word representing a signal. we take an example  where given signals and STL specifications, we explain how  we get the final timed word below.
    
    
    
    % \paragraph*{Variable point.} For a signal $\signal: D \mapsto \Realn$, a time point $\tau\in D$ is called a \emph{variable point} if the truth value of a proposition changes at time $\tau$ on the signal $\signal$.
    
    % \begin{definition}[Variable Point\cite{bae2019bounded}]
    %     Given a signal $\signal:D\mapsto \Realn$, a time point $\tau\in D$ is a variable point of $\signal$ with respect to a proposition $\mu(\signal)$ if for some neighborhood $B\ni \tau$, there are different truth values $u$ and $v$ such that $\mu(\signal)=u$ for every $t\in B\cap [0,\tau)$ and $\mu(\signal)=v$ for every $t\in B\cap (\tau,+\infty)$.
    % \end{definition} 

    % \begin{remark}
    %     In this work, we consider bounded signals: the domain and the number of variable points are bounded. 
    % \end{remark}
    
    % We gather all the variable points along with the truth value of the proposition at those points to form the primary timed word. However, this is not the final encoding of the signal to be relayed to the transducer.  We need to carefully observe (and potentially modify or enforce) the signal at the interval boundaries if the signals do not satisfy the given STL formula. Why at boundaries? Because we want to correct the signal just before the point after which correction is no longer possible. Thus, we account for these boundary time points in our timed words.
    % And doing this provides the final timed word representing a signal and suitable to be relayed to the transducer. 

    % So, for the given signals $\signal_1, \cdots, \signal_k$, the corresponding timed word $\tword$ follows these:
    % \begin{itemize}
    %     \item Each time point in $\tword$ is a variable point of at least one signal from $\signal_1, \cdots, \signal_k$;
    %     \item The alphabet in each event $(\tau_i,\mu)$ is similar to the satisfaction of the proposition in $B\cap(\tau_i,+\infty)$, where $B$ is a small enough neighbourhood where the truth value of all the signals change. 
    % \end{itemize}

    
    % Below, given signals and STL specification, we explain how we obtain the final timed word via an example.

    % \begin{example}[Extracting Variable points from the signal]
    % Given an STL formula $(\signal_1\ge 0.7)\until_{[4,5]}(\signal_2\ge 0.5)$, with $p_1\equiv \signal_1\ge 0.7$, $p_2\equiv \signal_2 \ge 0.5$ and signals $\signal_1$ and $\signal_2$  given in Figure \ref{fig:signal-encoding}, we extract the variable points $(\neg p_1 \land p_2, 0), (p_1 \land p_2, 0.5), (p_1 \land \neg p_2, 1.2), (\neg p_1 \land \neg p_2, 2.2), (p_1 \land \neg p_2, 3.2), (\neg p_1 \land \neg p_2, 4.5) \text{ and } (\neg p_1 \land p_2, 4.7)$ as marked (in colour red) in the plots of the Figure \ref{fig:signal-encoding}. This constitutes our primary timed word. Now, the points at the interval boundaries should also be considered. So, the final timed word is \sloppy $(\neg p_1 \land p_2, 0), (p_1 \land p_2, 0.5), (p_1 \land \neg p_2, 1.2), (\neg p_1 \land \neg p_2, 2.2), (p_1 \land \neg p_2, 3.2), (p_1 \land \neg p_2, 4),(\neg p_1 \land \neg p_2, 4.5), (\neg p_1 \land p_2, 4.7) \text{ and } (\neg p_1 \land p_2, 5)$ where the interval boundary points are $(p_1 \land \neg p_2, 4), (\neg p_1 \land p_2, 5)$ marked (in colour green) in the plots of the Figure \ref{fig:signal-encoding}. This constitutes our final timed word.
    %For a given signal of humidity in the top plot in Figure \ref{} and for the given proposition $\varphi \geq 55$, the variable points (humidity crossing 55\%) are shown (marked by red dots) in the bottom plot in Figure \ref{}. 
    %     \begin{figure*}[p]
    %         \centering
    %         \includegraphics[width=1\linewidth]{figures/variable_points.png}
    %         \caption{Extracting Variable points from the signal)}
    %         \label{fig:enter-label}
    %     \end{figure*}        
    % \end{example}

