\section{Runtime Enforcement using transducer}
\label{sec:Runtime Enforcement against STL}
 %2 kinds of states in automata: causing/observing, modifying state: can modify automata according to reaching the above states.As seen in Section \ref{}, the locations of the automaton, of the STL formula to be enforced on a signal, are categorized into three types: \emph{observing}, \emph{modifying}, and \emph{violation}.

 %\saucomment{talk about minimal change function}
 %\hscomment{Minimally modified the signal using QP}

    With all the preparatory work, we will present our runtime enforcement mechanism in this section. We will first describe an optimization-based method to \emph{minimally modify} the signal according to the output of the TT as detailed in \cref{sec: Transform STL into TA}. Then, we will introduce the enforcer against an STL formula, which will be outlined through a designated algorithm.

    \paragraph{Minimally modifying the signal}
    For a given STL formula $\varphi$, let \(x = \signal(t)\)\footnote{Note that the bold \(\signal\) represents a signal, while the non-bold $x$ is an $n$-dimensional real vector. We introduce the non-bold $x$ here to ease the symbolic burden in \cref{eq:opt}} be the value of the signal at the timestamp $t$. Assume the output action of TT \(\automaton_{\varphi}\) induced by the input $(t, a)$ is $\bot_{p_k}$. The signal can then be modified by solving the following optimization problem:
    %\saucomment{same index can be taken, j not required}
    \begin{align}\label{eq:opt}
        \begin{aligned}
        \text{Minimize:}  \quad & || y - x^{p_k} ||\\
        \text{Subject to:}\quad & \mu_i(x[x^{p_k}/y]) \ge 0, \quad \forall p_i\in a,\\
                                & \mu_j(x[x^{p_k}/y]) < 0, \quad \forall \neg p_j \in a,\\
                                & \mu_k(y) \Join 0,
        \end{aligned}
    \end{align}
    where \(\Join\) is $\ge$ if $\neg p_k \in a$ and \(\Join\) is $<$ otherwise. Here, $x^{p_k}$ denotes the components of $x$ related to the predicate $p_k$, $y$ is the decision variable of the optimization problem, representing the modified value of the signal at $t$. Notation $x[x^{p_k}/y]$ denotes the vector obtained by replacing the occurrences of $x^{p_k}$ in $x$ with $y$. For an intuitive illustration, see \cref{fig:illus}, where $y=(y_1,y_2,y_3)$.

    \begin{figure}[h]
        \centering
            \begin{align*}
                  & \quad x^{p_1} \Def \{x_1,x_2,x_m\}\,,\quad\ \,\cdots~ ,\quad \maroon{x^{p_k} \Def \{x_m,x_{m+1},x_n\}}\\
                  & p_1\equiv \mu_1(\tikzmarknode{x1}{x_1},\tikzmarknode{x2}{x_2},\tikzmarknode{xm}{x_m})\ge 0\,, ~\cdots ~,\, \maroon{p_k\equiv\mu_k(\tikzmarknode{xm1}{x_m},\tikzmarknode{xm11}{x_{m+1}},\tikzmarknode{xn}{x_n})\ge 0}\\
                  & \\
                x\quad\ =~& ~\left(~\tikzmarknode{p11}{x_1}\,,~\tikzmarknode{pk1}{x_2}\,,~x_3\,,~\cdots\,,~\tikzmarknode{p12}{\highlight{Maroon}{$x_m$}}\,,~\tikzmarknode{pk2}{\highlight{Maroon}{$x_{m+1}$}}\,,~\cdots\,, ~x_{n-1}\,,~\tikzmarknode{pk3}{\highlight{Maroon}{$x_n$}}~\right)\\
                x[x^{p_k}/y] = &~\left(~ x_1\,,~x_2\,,~ x_3\,,~\cdots\,,~\highlight{NavyBlue}{$y_1$\ }\,,~\highlight{NavyBlue}{\ \ $y_2$\ \ \,}\,,~\cdots\,,~x_{n-1}\,,~\highlight{NavyBlue}{$y_3$}~\right)
            \end{align*}
            \begin{tikzpicture}[overlay,remember picture,>=stealth,nodes={align=left,inner ysep=1pt}]
                \draw (p11.north)++(0,0.05) -- ++(0,0.6) -| (x1);
                \draw (pk1.north)++(0,0.05) -- ++(0,0.4) -| (x2);
                \draw (p12.north)++(-0.1,0) -- ++(0,0.37) -| (xm);

                \draw[Maroon] (p12.north)++(0.1,0) -- ++(0,0.57) -| (xm1.south);
                \draw[Maroon] (pk2.north) -- ++(0,0.37) -| (xm11.south);
                \draw[Maroon] (pk3.north) -- ++(0,0.37) -| (xn.south);
            \end{tikzpicture}
        \vspace{-5mm}
        \caption{Illustration of $x^{p_k}$ and $x[x^{p_k}/y]$.} %Note that $x\in\Realn$ is an $n$-dimensional real vector, while $y=(y_1,y_2,y_3)$ serves as the decision variable of the QP problem.}
        \label{fig:illus}
    \end{figure}

    %\noindent \textit{Note}: In  \cref{fig:illus}, we see that values of signal $x_m$ is modified to satisfy some predicate $p_1$ and similarly, values of signals $x_{m+1}$ and $x_n$ are modified to satisfy some predicate $p_k$.\\

    
    We refer to this procedure as $\textsf{Modify}\left(x,a,b,\varphi\right)$, where $x$ represents the value of the signal, $a$ is the input action of the TT, $b$ is the corresponding output action, and $\varphi$ is the STL formula. The following proposition confirms the robustness of our minimal modification method:
    \begin{proposition}\label{prop:modify}
        If the optimization problem in \cref{eq:opt} is solvable, then this procedure maintains the minimal modification requirement as per \cref{def:enforcer}.
    \end{proposition}
    
    \begin{remark}
        \cref{eq:opt} can be solved using different methods, depending on the constraints provided in the predicate functions $\mu_p$ in the STL formula. If all of the $\mu_p$ are linear, then \cref{eq:opt} can be solved using Quadratic Programming (QP). If the $\mu_p$ are polynomial, \cref{eq:opt} can be transformed into Semidefinite Programming (SDP) by using Putinar's Positivstellensatz \cite{putinar1993positive}.  
    \end{remark}
    %\hscommentinline{what below is for RE algorithm, pls use $\textsf{Modify}(x,b,\varphi)$ to denote the minimal modification procedure.}
   \paragraph{Enforcer} We are now ready to present our runtime enforcement algorithm, as shown in \cref{algorithm}. Assume we have a signal $\signal$ to be enforced against an STL formula $\varphi$. The algorithm begins by computing its TT $\automaton_{\varphi}$ following the method described in \cref{sec: Transform STL into TA} (\cref{al2line:0} in \cref{algorithm}). Subsequently, as the signal $\signal$ is received, it is encoded into input events. The enforcer $E_{\varphi}$ in \cref{algorithm} then traverses the TT $\automaton_{\varphi}$ and generates the output events. Depending on this output, the signal is modified (if required) and released.
   
    The algorithm proceeds as follows:
    \texttt{currState} monitors the current state of the TT, which includes the current location and clock valuation in the timed transducer. \texttt{currState} is initially set to the starting state of $\automaton_{\varphi}$ (\cref{al2line:1}). It then enters an infinite loop (\cref{al2line:2}) until an event is detected from \cref{alg:signal-encoding} (\cref{al2line:3}).

    Upon receiving an event, the transducer $\automaton_{\varphi}$ transitions, updates the \texttt{currState}, and gives the output $b$ according to the transition (\cref{al2line:4}). If the output is anything other than $\top$, the transducer minimally modifies the signal before it is released (\cref{al2line:6}).
    % This is done for all the events in the buffer accumulated in the current tick $T$, after which the algorithm proceeds with the next iteration.
    The following example illustrates how our enforcer operates. 

    \begin{figure*}[t]
            \begin{minipage}{.48\textwidth}
                    \centering
                    \begin{tabular}{c c c c c}
                        \toprule
                        \thead{state before\\transition} &\thead{timestamp} &  \thead{input\\action} & \thead{state after\\ transition} & \thead{output\\action}  \\
                        \midrule
                         $(l_0,0)$ & 0 & $\neg p_1\land p_2$ & $(l_1,0)$ & $\bot_1$ \\
                         $(l_1,0)$ & 0.5 & $ p_1\land p_2 $  & $(l_1,0.5)$ & $\top$   \\
                         $(l_1,0.5)$ & 1.2 & $ p_1\land\neg p_2 $ & $(l_1,1.2)$ & $\top$   \\
                         $(l_1,1.2)$ & 2.2 & $\neg p_1\land \neg p_2 $ & $(l_1,2.2)$ & $\bot_1$ \\
                         $(l_1,2.2)$ & 3.2 & $p_1\land \neg p_2 $     & $(l_1,3.2)$ & $\top$   \\
                         $(l_1,3.2)$ & 4   & $p_1\land \neg p_2 $     & $(l_3,4)$ & $\top$   \\
                         $(l_3,4)$ & 4.5 & $\neg p_1\land \neg p_2 $  & $(l_3,4.5)$ & $\bot_1$   \\
                         $(l_3,4.5)$ & 4.7 & $\neg p_1\land p_2 $     & $(l_2,4.7)$ & $\bot_1$\\  
                         \bottomrule
                    \end{tabular}
                    \captionof{table}{Transitions in TT of $p_1\until_{[4,5]} p_2$}
                    \label{tab:table_enf}
            \end{minipage}
            \hfill
            \begin{minipage}{.48\textwidth}
                \centering
                \vspace{-3mm}
                \begin{adjustbox}{max width = .95\linewidth}
                \begin{tikzpicture}[font=\small]
                    \centering
                    \begin{scope}
                        \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
                        \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$x_1$};
                        \draw[dashed, color = gray] (0,1.05) node[left] {\black{$0.7$}} -- (6,1.05);
                        
                        \draw[color=NavyBlue, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
                            %(0, 0.75)
                            (0.6, 1.05)
                            (1.2, 1.3)
                            (1.9, 1.2)
                            (2.7, 1.05)};
                            %(3.3, 0.94)
                        \draw[color=NavyBlue, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
                            (3.8, 1.05)
                            (4.5, 1.3)
                            (5.4, 1.05)
                            %(6.0, 0.8)
                        };
                        \draw[color=red, line width = 1.6pt] plot coordinates{(0,1.05) (0.6,1.05)};
                        \draw[color=red, line width = 1.6pt] plot coordinates{(2.7,1.05) (3.8,1.05)};
                        \draw[color=red, line width = 1.6pt] plot coordinates{(5.4,1.05) (5.6,1.05)};
                        
                        \node at (0,0) [below] {\green{$0$}};
                        \draw[dashed, color = gray] (0.6, 0) node[below] {\orange{$0.5$}} -- (0.6,1.5);
                        \draw[dashed, color = gray] (2.7, 0) node[below] {\orange{$2.2$}} -- (2.7,1.5);
                        \draw[dashed, color = gray] (3.8, 0) node[below] {\orange{$3.2$}} -- (3.8,1.5);
                        \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
                        \draw[dashed, color = gray] (5.4, 0) node[below] {\orange{$4.5$}} -- (5.4,1.5);
                        \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
                    \end{scope}

                    \begin{scope}[shift = {(0,-2.3)}]
                        \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
                        \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$x_2$};
                        \draw[dashed, color = gray] (0,0.75) node[left] {\black{$0.5$}} -- (6,0.75);

                        \draw[color=Maroon, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
                            (0, 1.2)
                            (1.4, 0.75)
                            (2.3, 0.15)
                            (3.5, 0.3)
                            (4.5, 0.6)
                            (5.6, 0.75)
                            (6.0, 1)
                        };

                        \node at (0,0) [below] {\green{$0$}};
                        \draw[dashed, color = gray] (1.4, 0) node[below] {\orange{$1.2$}} -- (1.4,1.5);
                        \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
                        \draw[dashed, color = gray] (5.6, 0) node[below] {\orange{$4.7$}} -- (5.6,3.8);
                        \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
                    \end{scope}
                     
                \end{tikzpicture}
                \end{adjustbox}
                \vspace{-4mm}
                \caption{Enforced Signal in \cref{exp:alg2}}
                \label{fig:after-enforce}
            \end{minipage}
        \end{figure*}
        
    %\hscomment{What about we change line \ref{al2line:3} to $(t,a)\gets$ event emitted by \cref{alg:signal-encoding}}
% \hscomment{Modified this to online one}
    \begin{algorithm}[H]
        %\caption{Algorithm Enforcer $E_\varphi(\automaton_\varphi,\tword,\signal$) }
        \caption{Algorithm Enforcer $E_\varphi(\signal$) }
        \label{algorithm} %\scriptsize
        \begin{algorithmic}[1]
            % \State $T \leftarrow 0$
            % \State $ currState \leftarrow  [l_0 , c:=0]$
            % \While {true}
            %     \For{$(\delta, a) \in \tword$ in buffer}
            %         \State $currState[1] = currState[1]+\delta$
            %         \State \footnotesize $currState[0], \signal'=\delta_{\automaton_{f}}(currState[0],  G(C), a, reset(C))$
            %         \State $release(\signal')$
            %     \EndFor		
            % \EndWhile
            % \State $T \leftarrow T +1$
            \State $\automaton_\varphi \gets $ TT constructed from $\varphi$ \label{al2line:0}
            \State $ \texttt{currState} \leftarrow  [l_0 , c:=0]$\label{al2line:1}
            \While {$true$}\label{al2line:2}
                %\State $(t, a)\gets \textsf{await\_event()}$ 
                \State $(t, a)\gets$ event emitted by \cref{alg:signal-encoding}\label{al2line:3}
                %\State $currState[0], output=\delta_{\automaton_{f}}(currState[0],  G(C), a, reset(C))$
                \State $\texttt{currState}, ~b =\textsf{make\_transition}_{\automaton_{\varphi}}(\texttt{currState}, t, a)$\label{al2line:4}
                \If{$b \neq\top$}
                    \State $\signal(t)=\textsf{Modify}(\signal(t),a,b, \varphi)$\label{al2line:6}
                \EndIf
                \State release $\signal$
            \EndWhile
        \end{algorithmic}
    \end{algorithm}


    % \begin{algorithm}[H]
    %     \caption{Algorithm Enforcer $E_f(\automaton_{f}, \tword, \signal$) }
    %     \begin{algorithmic}[1]
    %     \State $ currState \leftarrow  [l_0 , c:=0]$
    %         \While {true}
    %             \State (t, a) $\gets$ await event()
    %             \State $currState[0], output=\delta_{\automaton_{f}}(currState[0],  G(C), a, reset(C))$
    %             \If{output $\neq $$ \top$}
    %                 %\State $\signal'(t)=reconstruct(\signal(t), output, f)$
    %                 \State Pred=$pd(f)$	%\comment{Pred is the set of predicates in the STL formula f.}
    %     	        \State p=Pred[output]	%\comment{predicate at the specified index output within Pred.}
    %     	        \State $\signal(t)=minimize \mid \mid \signal(t)-y \mid \mid \text{ subject to }p(y)=True$
    %             \EndIf
    %             \State release($\signal$)
    %         \EndWhile
    %     \end{algorithmic}
    % \end{algorithm}




  \begin{example}[Enforcement of STL formula on a timed word]\label{exp:alg2}
      %We consider the STL formula $(\signal_1\ge 0.7)\until_{[4,5]}(\signal_2\ge 0.5)$, with $p_1\equiv \signal_1\ge 0.7$, $p_2\equiv \signal_2 \ge 0.5$ and signals $\signal_1$ and $\signal_2$ from Figure \ref{fig:signal-encoding}. 
      Continuing to \cref{exp:relavant-point}, recall that the STL property is defined as $p_1\until_{[4,5]} p_2$, where $p_1\equiv x_1\ge 0.7$, $p_2\equiv x_2 \ge 0.5$. %The TT of formula $\varphi = p_1\until_$ The time word is shown in \cref{fig:signal-encoding}.
      %The final timed word encoded from the signals (and the STL specification) is: $(\neg p_1 \land p_2, 0), (p_1 \land p_2, 0.5), (p_1 \land \neg p_2, 1.2), (\neg p_1 \land \neg p_2, 2.2), (p_1 \land \neg p_2, 3.2), (p_1 \land \neg p_2, 4),(\neg p_1 \land \neg p_2, 4.5), (\neg p_1 \land p_2, 4.7) \text{ and } (\neg p_1 \land p_2, 5)$. 
      \cref{tab:table_enf} gives the steps of enforcement of the timed word using Until Transducer. The signal at time points \{0, 2.2, 4.5, 4.7\} are modified to satisfy the STL formula. The modified signal is shown in \cref{fig:after-enforce}.
    \qedT
    \end{example}
%\spcomment{Reg Algo 2, how do you argue that the final output signal is sound with respect to the given STL formula? State changes are made upon the input. And after the state change Modify is called. Is it guaranteed that your Modify approach preserves the state?}

    The following theorem states the correctness of the enforcer described in \cref{algorithm}
    \begin{theorem}
        Given an STL formula $\varphi$ and a signal $\signal$, the enforcer $E_\varphi$ in \cref{algorithm} can enforce $\signal$ to satisfy $\varphi$, while ensuring that the \emph{soundness}, \emph{transparency}, and \emph{minimal modification} conditions in \cref{def:enforcer} are met. 
    \end{theorem}
    \begin{proof}
    The transparency of the enforcer is a direct result of \cref{propo1}, \cref{propo2}, and \cref{prop:composition}, as \cref{algorithm} will not modify the signal under the $\top$ output of the TT. The soundness of the enforcer is ensured by observing the truth that, the $\bot_p$ outputs of TT essentially indicate how to modify the input action to those inputs that can lead to a $\top$ output. The minimal modification condition is ensured by \cref{prop:modify}.
    \end{proof}
 % \hscommentinline{Here we may need a theorem to show our enforcer truly solve the problem in \cref{sec:Preliminaries and notations}}

  %\nzcomment{Yes, I agree. In addition, we also need to have a complexity analysis of our approach.}

    \paragraph{Complexity Analysis} The time complexity of \cref{algorithm} is multifaceted. The time complexity of the function $\textsf{make\_transition}_{\automaton{\varphi}}$ is $\mathcal{O}(m \times n)$, where $m$ is the number of states in the TT and $n$ is the size of the input alphabet. The time complexity of the function $\textsf{Modify}$ depends on the structure of the predicate function in the STL formula; it will be polynomial in the number of decision variables when the predicate functions are linear \cite{nesterov1994interior}.

    Other procedures, such as constructing the TT from the STL formula in \cref{sec: Transform STL into TA} (polynomial in the size of the TT, primarily influenced by the composition operator), and computing the values of the signal leading to the variable points in \cref{sec: Signal Encoding} (achieving quadratic convergence with the Newton-Raphson method), may be time-consuming. However, both procedures can be performed \emph{offline}, thus they do not impact the efficiency of our runtime enforcement algorithm.