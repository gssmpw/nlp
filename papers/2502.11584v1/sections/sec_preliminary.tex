%\section{Preliminaries and notations}
%\section{Preliminary and Problem Formulation}
\section{Background and Problem Formulation}
\label{sec:Preliminaries and notations}
Let $\Nats$, $\Reals$, $\NonNegReals$, and $\NonNegRat$ denote the set of natural numbers, real numbers, non-negative real numbers and non-negative rational numbers, respectively. 
%Let $\Nats$, $\Reals$ and $\NonNegReals$ denote the set of natural numbers, real numbers and  non-negative real numbers respectively. True and false are represented by $\top$ and $\bot$, respectively, with $\mathbb{B} = \{\top, \bot\}$ denoting the set of Boolean values.
For a set $A \subseteq \mathbb{R}$ and a real number $a \in \mathbb{R}$, the expression $a \oplus A$ is used to denote the set obtained by adding $a$ to each element in $A$. %For a signal \(\signal: \NonNegReals \to \Realn\), %(where all the signal are observed over a common duration), 
% let \(|\signal|\) denote its length.
%\saucomment{For a signal \(\signal: \NonNegReals \to \Realn\), length of the signal from $t_1$ to $t_2$ will be $t_2-t_1$. We denote this length as $\mid x \mid$.}

%In Section \ref{sec:Timed Automata}, we discuss preliminaries and notations of a timed automaton, semantics of a timed automaton and deterministic and complete timed automaton. In Section \ref{sec:Signal Temporal Logic}, we discuss the syntax of signal temporal logic. In Section \ref{sec:Problem Formulation}, we present the problem statement.

    \subsection{Timed Transducer}\label{sec:Timed Transducer}
        %\hscomment{I directly give the preliminary about timed transducer, and define a notion $\llangle\automaton\rrangle(\signal)$, is this form more suitable? yes}
        A Timed Transducer (TT) is a specialized version of a timed automaton \cite{alur1994theory} that is capable of both taking input and producing output. We provide the essential preliminaries of timed transducers below.

        \paragraph{Timed Language}
        Let $\alphbt$ denote a finite alphabet. A pair $(t, a)\in\NonNegReals\times\alphbt$ is called an \emph{event}. A \emph{timed word} over $\alphbt$ is a finite sequence $\tword=(t_0,a_0)(t_1,a_1)\cdots(t_n,a_n)\allowbreak\in(\NonNegReals\times\alphbt)^*$, where $t_i$ is the \emph{time-stamp} indicating the global time at which the \emph{action} $a_i$ occurs, for all $0\le i \le n$. A \emph{timed language} $\mathcal{L}$ is a set of timed word, i.e., $\mathcal{L}\subseteq(\NonNegReals \times \alphbt)^*$. %Let $\emptyword$ denote the empty word.

        % \saucomment{An RTA (rational timed automata) is time-bisimilar to ITA  (integral timed automata) . For rechability etc, an RTA is converted to ITA by multiplying all rational constants by a factor that make them integral. And thus they directly show guards with non-negative integers.        
        % in this work, We don't require rechability etc, so no need to have such constraints.
        % and we think, its even ok to  consider non-neagtive real nos.}
        
         \paragraph{Timed Transducer}
         Let $\clock$ be the set of clock variables. A \emph{clock constraint} $g$ is a Boolean combination of atomic constraints of the form $c\!\Join\! r$, with $c\in\clock$, $r\in \NonNegRat$, and $\Join\in\{\le,<,\ge,>,=\}$. We use $\mathcal{G}(\clock)$ to denote the set of clock constraints. A \emph{clock valuation} $v:\clock\mapsto\NonNegReals$ is a function assigning a non-negative real value to each clock $c\in\clock$. We write $v\models g$ if the clock valuation $v$ satisfies the clock constraints $g$. For $d\in\NonNegReals$, let $v+d$ denote the clock valuation which maps every clock $c\in\clock$ to the value $v(c)+d$, and for a set $\mathcal{C}'\subseteq\clock$, let $\clockreset{\mathcal{C}'}$ denote the clock valuation which resets all clock variables in $\mathcal{C}'$ to $0$ and agrees with $v$ for other clocks in $\clock\setminus\mathcal{C}'$. A timed transducer is defined as below:

        \begin{definition}[Timed transducer]
            A timed transducer is a tuple $\automaton=(\loca,\linit,\clock,\alphbt,\Lambda,\trans,\lambda,\lacpt)$, where
            \begin{itemize}
                \item $\loca$ is a finite set of locations;
                \item $\linit$ is the initial location;
                \item $\clock$ is the set of clocks;
                \item $\alphbt$ is the input alphabet;
                \item $\Lambda$ is the output alphabet;
                \item $\trans\subseteq \loca\times\alphbt\times\mathcal{G}(\clock)\times \power{\clock}\times\loca$ is a finite set of transitions;
                \item $\lambda: \trans \mapsto \Lambda$ is the output function that associates each transition with an output;
                \item $\lacpt\in\loca$ is a set of accepting locations;
            \end{itemize}  
        \end{definition}
        % \hscomment{A remark is added here to reply Prof. Srinivas's doubt.}
        % \begin{remark}
        %     Unlike the traditional definition of TA as per \cite{alur1994theory}, where the clock constraints involve natural numbers (i.e., \(r \in \Nats\) for clock constraint \(c \Join r\)), we employ real number version clock constraints in TT. This approach is due to:
        %     \begin{enumerate*}[label=(\roman*)]
        %         \item Alignment with the syntax of STL, which involves timing constraints in real numbers (please refer to \cref{sec:Signal Temporal Logic}),
        %         \item Our method does not rely on reachability analysis of TA as described in \cite{pinisetty2017runtime}, thereby eliminating the need to restrict clock constraints to natural numbers to facilitate the reachability analysis methods of TA, such as the region graph \cite{alur1994theory}.
        %     \end{enumerate*}
        % \end{remark}

        A transition \(\delta = (l, a, g, \clock', l')\) in \(\Delta\) represents a jump from location $l$ to $l'$ by performing an action \(a \in \alphbt\) when the constraint \(g \in \mathcal{G}(\clock)\) is satisfied by the current clock valuation. The set \(\clock'\) indicates which clocks should be reset upon reaching $l'$.

        A \emph{state} $q$ of \(\automaton\) is a pair $(l, v)$, where \(l \in \loca\) denotes the location, and $v$ is a clock valuation. A \emph{run} $\rho$ of \(\automaton\) over an input timed word \(\tword = (t_0, a_0)(t_1, a_1) \cdots (t_n, a_n)\) is a sequence \((l_0, v_0) \xrightarrow[b_0]{\tau_0, a_0} (l_1, v_1) \xrightarrow[b_1]{\tau_1, a_1} \cdots \xrightarrow[b_n]{\tau_n, a_n} (l_{n+1}, v_{n+1})\), where $\tau_i = t_i - t_{i-1}$ for $i = 1, 2, \ldots, n$ and $\tau_0 = t_0$, satisfying the following conditions:
        \begin{enumerate}
            \item $l_0$ is the initial location and $v_0(c) = 0$ for all $c\in\clock$,
            \item For each $i=0,1,\cdots,n$, there is a transition $\delta_i=(l_i,a_i,g_i,\clock_i,\allowbreak l_{i+1})\in\trans$ such that $v_i+\tau_i\models g_i$ and $v_{i+1} = \clockreset[(v_i+\tau_i)]{\clock_i}$,
            \item $\lambda(\delta_i) = b_i\in\Lambda$ for all $i=0,1,\cdots,n$.
        \end{enumerate}
        The run $\rho$ is \emph{accepted} by $\automaton$ if $l_{n+1}\in \lacpt$. The output timed word induced by $\automaton$ is $\bm{\omega}=(t_0,b_0)(t_1,b_1)\cdots(t_n,b_n)$, sharing the same timestamp $t_i$ ($i=0,1,\cdots,n$) as the input timed word. We use the notation \(\llangle\automaton\rrangle(\tword) = \bm{\omega}\) to denote that \(\automaton\) executes an accepted run over input timed word \(\tword\) that induces output timed word $\bm{\omega}$.

        \begin{example}\label{example:TA}
            % \color{red}
            The $\automaton_P$ illustrated in \cref{fig:TA} represents a TT for the property $P$: ``\textit{There should be a delay of at least $5$ time units between any two read file requests}''. This TT consists of locations $\loca=\{l_0,l_1,l_2\}$, with $l_0$ as the initial location and $\{l_0, l_1\}$ as the accepting locations, indicated by double circles. The input alphabet is $\alphbt=\{r, w\}$  with $r$ for read requests and $w$ for write requests. The output alphabet is $\{\top,\bot\}$ (denoted by green in \cref{fig:TA}), where $\top$ indicates a proper input that may lead to an accepted run, and $\bot$ indicates an improper input that leads to an unacceptable run. The transducer operates with one clock $c$.

            Given the input timed word $\tword=(1,r)(4,w)(6,r)$, the run $\rho$ of $\automaton$ progresses as follows:
            \[
                \rho = (l_0,0) \xrightarrow[\green{\top}]{1,r} (l_1,0) \xrightarrow[\green{\top}]{3,w} (l_1,3) \xrightarrow[\green{\top}]{2,r} (l_1,0).
            \]
            The output timed word of $\automaton_p$ over input timed word $\tword$ is \(\llangle\automaton_P\rrangle(\tword)=(1,\green{\top})(4,\green{\top})(6,\green{\top})\), which indicates whether the transition at current timestamp results in an acceptable run.
            % \color{blue}
            % The $\automaton_P$ illustrated in \cref{fig:TA} represents a TT for the property $P$: ``\textit{There should be a delay of at least $5$ time units between any two read file requests}''. This TT consists of locations $\loca=\{l_0,l_1\}$, with $l_0$ as the initial location and $\{l_0, l_1\}$ as the accepting locations, indicated by double circles
            % %\footnote{This TT is self-correcting: It adjusts its behavior to go to safe states, meaning the TT alters the actions of the transitions to go to safe states. That is why no violation states are needed here.}. 
            % The input alphabet is $\alphbt=\{r, w\}$  with `$r$' for read requests and `$w$' for write requests. The output alphabet is $\{\top,\bot_r, \bot_w\}$ (denoted by green in \cref{fig:TA}), where `$\top$' is the output that indicates a proper input that may lead to an accepted run\hscomment{We can not say this, as all the run in this automaton is acceptable...}, and `$\bot_r, \bot_w$' are the outputs that indicate improper inputs that lead to an unacceptable run and hence should be corrected. The transducer operates with one clock $c$.

            % Given the input timed word $\tword=(1,r)(3,w)(4,r)$, the run $\rho$ of $\automaton$ progresses as follows:
            % \[
            %     \rho = (l_0,0) \xrightarrow[\green{\top}]{1,r} (l_1,0) \xrightarrow[\green{\top}]{2,w} (l_1,2) \xrightarrow[\green{\bot_r}]{1,r} (l_1,3).
            % \]
            % The output timed word of $\automaton_p$ over input timed word $\tword$ is \(\llangle\automaton_P\rrangle(\tword)=(1,\green{\top})(3,\green{\top})(4,\green{\bot_r})\), which here indicates input $(4,r)$ needs to be corrected for an acceptable run.
            % \color{black}
            \qedT
        \end{example}
        \begin{figure}[h]
		\centering
		%\scalebox{0.9}{
		\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2cm, el/.style = {inner sep=2pt, align=left, sloped},
		every label/.append style = {font=\small},
		semithick,initial where=below]
		
		\tikzstyle{every node}=[font=\small]
		\tikzstyle{good state}=[circle,thick,draw=NavyBlue!75,fill=NavyBlue!20,minimum size=5mm,accepting]
		\tikzstyle{bad state}=[circle,thick,draw=Maroon!75,fill=Maroon!20,minimum size=3mm]
		\node[initial,good state] (l0) {$l_0$};
		\node[good state]         (l1) [right of=l0, xshift = 15pt] {$l_1$};
		\node[bad state]       (l2) [right of=l1, xshift = 15pt] {$l_2$};
  
		\path (l0) edge [loop above] node {$w \mid \green{\top}$} (l0)
		edge node { $r,c:=0 \mid \green{\top}$ } (l1)             
		(l1) edge [loop above] node {$ w \mid \green{\top}$} (l1)
		edge [loop below] node {$r, c \geq 5, c:=0 \mid \green{\top}$} (l1)
        edge node {$r,c<5 \mid \green{\bot}$} (l2)
		(l2) edge [loop above] node {$ w \mid \green{\bot}$} (l2)
             edge [loop below] node {$r\mid \green{\bot}$} (l2);
		\end{tikzpicture}%}
		\caption{Timed Transducer $\mathcal{A}_P$}
		\label{fig:TA}
	\end{figure}

 %    \begin{figure}[h]
	% 	\centering
 %        \begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2cm, el/.style = {inner sep=2pt, align=left, sloped},
	% 	every label/.append style = {font=\small},
	% 	semithick,initial where=below]
		
	% 	\tikzstyle{every node}=[font=\small]
	% 	\tikzstyle{good state}=[circle,thick,draw=NavyBlue!75,fill=NavyBlue!20,minimum size=5mm,accepting]
	% 	\tikzstyle{bad state}=[circle,thick,draw=Maroon!75,fill=Maroon!20,minimum size=3mm]
	% 	\node[initial,good state] (l0) {$l_0$};
	% 	\node[good state]         (l1) [right of=l0, xshift = 15pt] {$l_1$};
	% 	% \node[bad state]       (l2) [right of=l1, xshift = 15pt] {$l_2$};
  
	% 	\path (l0) edge [loop above] node {$w \mid \green{\top}$} (l0)
	% 	edge node { $r,c:=0 \mid \green{\top}$ } (l1)             
	% 	(l1) edge [loop above] node {$ w \mid \green{\top}$} (l1)
	% 	edge [loop below] node {$r, c \geq 5, c:=0 \mid \green{\top}$} (l1)
 %        edge [loop right] node {$r,c<5 \mid \green{\bot_r}$} (l1);
	% 	% (l2) edge [loop above] node {$ w \mid \green{\bot}$} (l2)
 %  %            edge [loop below] node {$r\mid \green{\bot}$} (l2);
	% 	\end{tikzpicture}%}
	% 	\caption{Timed Transducer $\mathcal{A}_P$}
	% 	\label{fig:TA}
	% \end{figure}
    
% \saucomment{shall we change the output to 1 for all violating transitions and 0 for all accepting transitions?}
% \hscomment{yes}
        
 %    \subsection{Timed Automata}\label{sec:Timed Automata}
 %        As the STL formula under consideration will ultimately be transformed into a timed automaton in this paper, we provide the following preliminary details about timed automata.
        
 %        \paragraph{Timed Language}
 %        Let $\alphbt$ denote a finite alphabet. A pair $(t, a)\in\NonNegReals\times\alphbt$ is call an \emph{event}. A \emph{timed word} over $\alphbt$ is a finite sequence $\tword=(t_0,a_0)\cdots(t_n,a_n)\allowbreak\in(\NonNegReals\times\alphbt)^*$, where $t_i$ represents the global time when taking action $a_i$ for all $0\le i \le n$. A \emph{timed language} $\mathcal{L}$ is a set of timed word, i.e., $\mathcal{L}\subseteq(\alphbt\times\NonNegReals)^*$. Let $\emptyword$ denote the empty word.
        
 %        \paragraph{Timed automata}
	%     A Timed Automaton (TA) \cite{alur1994theory} is a kind of finite automaton equipped with a finite set of real-valued clocks. Let $\clock$ be the set of clock variables. A \emph{clock constraint} $g$ is a Boolean combinations of atomic constrains of the form $c\!\Join\!n$, with $c\in\clock$, $n\in\Nats$, \hscomment{can we replace this by $n\in\NonNegReals$?}and $\Join\in\{\le,<,\ge,>,=\}$. We use $\mathcal{G}(\clock)$ to denote the set of clock constraints. A \emph{clock valuation} $v:\clock\mapsto\NonNegReals$ is a function assigning a non-negative real value to each clock $c\in\clock$. We write $v\in g$ if the clock valuation $v$ satisfies the clock constraints $g$. For $d\in\NonNegReals$, let $v+d$ denote the clock valuation which maps every clock $c\in\clock$ to the value $v(c)+d$, and for a set $\mathcal{C}'\subseteq\clock$, let $\clockreset{\mathcal{C}'}$ denote the clock valuation which resets all clock variables in $\mathcal{C}'$ to $0$ and agrees with $v$ for other clocks in $\clock\setminus\{\mathcal{C}'\}$. Formally, a timed automaton is defined as below:

 %        \begin{definition}[Timed Automata]
 %            A timed automaton is a tuple $\automaton=(\alphbt,\loca,\linit,\lacpt,\clock,\trans)$, where
 %            \begin{itemize}
 %                \item $\alphbt$ is the alphabet;
 %                \item $\loca$ is a finite set of locations;
 %                \item $\linit$ is the initial location;
 %                \item $\lacpt\in\loca$ is a set of accepting locations;
 %                \item $\clock$ is the set of clocks;
 %                \item $\trans\subseteq \loca\times\alphbt\times\mathcal{G}(\clock)\times \power{\clock}\times \loca$ is a finite set of transitions. 
 %            \end{itemize}  
 %        \end{definition}

 %        \begin{example} (Timed automata).
 %    		\label{example:TA}
 %            The automaton $ \mathcal{A}_P $ in \cref{fig:TA} denotes a timed automaton of a prototype property $ P $ which says: "\textit{There should be a delay of at least 5 time units between any two user requests (r)}", with $ \loca=\{l_0,l_1,l_2\} $ as the set of locations, $ l_0 $ the initial location, and $\{l_0, l_1\}$ as the accepting locations (denoted by double circles). The alphabet of events is $ \Sigma=\{r,  \ldots\}$.  The automaton has one clock $c$. 
 %    	\end{example}
	% %\begin{wrapfigure}{r}{0.3\textwidth} 
 %    \begin{figure}[H]
	% 	\centering
	% 	%\scalebox{0.9}{
	% 	\begin{tikzpicture}[->,shorten >=1pt,auto,node distance=2cm, el/.style = {inner sep=2pt, align=left, sloped},
	% 	every label/.append style = {font=\small},
	% 	semithick,initial where=below]
		
	% 	\tikzstyle{every node}=[font=\small]
	% 	\tikzstyle{good state}=[circle,thick,draw=blue!75,fill=blue!20,minimum size=5mm,accepting]
	% 	\tikzstyle{bad state}=[circle,thick,draw=red!75,fill=red!20,minimum size=3mm]
	% 	\tikzstyle{dead state}=[rectangle,thick,draw=red!75,fill=red!20,minimum size=5mm]
	% 	\node[initial,good state] (l0) {$l_0$};
	% 	\node[good state]         (l1) [right of=l0] {$l_1$};
	% 	\node[dead state]       (l2) [right of=l1] {$l_2$};
  
	% 	\path (l0) edge [loop above] node {$\Sigma \setminus \{r\}$}( l0)
	% 	edge node { $r,c:=0$ } (l1)             
	% 	(l1) edge [loop above] node {$\Sigma \setminus \{r\}$} (l1)
	% 	edge [loop below] node {$r, c \geq 5, c:=0$} (l1)
 %        edge node {$r,c< 5$} (l2)
	% 	(l2) edge [loop above] node {$\Sigma$} (l2);		
	% 	\end{tikzpicture}%}
	% 	\caption{$ \mathcal{A}_P $}
	% 	\label{fig:TA}
	% %\end{wrapfigure}
	% \end{figure}


 %    The transitions can be understood as follows: from initial location $ l_0 $ and on the reception of input action $r$, $ \mathcal{A}_P$ makes a transition to location $ l_1 $ with the clock $ c $ being reset (to keep an eye on the reception of next $r$ action). From location $ l_1 $, if another action $r$ is received after 5 time unit, then $ \mathcal{A}_P  $ remains at the accepting location $l_1$ and resets its clock, otherwise goes to violating (non-accepting) location $l_2$.  From locations $l_0$ and $l_1$,  on input actions $\Sigma \setminus \{r\}$, $ \mathcal{A}_P $ remains at the same respective locations.
 
 % \begin{definition}[Semantics of TA]
	% 	\label{semTA}
	% 	The semantics of a TA is a timed transition system
	% 	 $\llangle \automaton \rrangle =( Q, q_0, \Gamma, \to, Q_F )$ 
 %        where the (infinite) set of states is given by $Q= L \times {\Bbb R}_{\geq0}^{|\clock|}$.
	% 	State $q_0=(l_0,v_0)$ is the initial state where $v_0$ is the	valuation that maps each clock in $\clock$ to $0$. The set of accepting states is given by $Q_F= F \times {\Bbb R}_{\geq0}^{|\clock|}$. The set of transition labels is given by
	% 	$\Gamma =  {\Bbb R}_{\geq0}\times \Sigma$. A label is a pair consisting of a delay (since the previous action) and an action.
	% 	The transition relation $\to\subseteq Q\times \Gamma\times Q$ is a set of transitions of the form $(l,v )\overset{{(\delta,a)}}{\longrightarrow} (l',v')$ with $\delta=t_n - t_{n-1}$ i.e., the difference between the absolute time of occurrence of action $a$ and the previous action and $v'=(v +\delta)[Y \leftarrow 0]$ whenever there exists $(l, g,a,Y, l') \in \Delta$  s.t. $v+\delta \models g$  for  $\delta\in {\Bbb R}_{\geq0}$.	
	% \end{definition}
        
        % \saucomment{we should add it somewhere else}\textcolor{red}{Our enforcer have the following properties:}
        % \begin{itemize}
        %     \item It will only modify the signal at the last time instants that the STL property is to be violated.
        % \end{itemize}
	%\noindent \textit{Deterministic and complete TA}. $\mathcal{A}$ is $deterministic$ whenever for any two distinct transitions $(l, g_1,a,Y_1, l_1')$ and $(l, g_2,a,Y_2, l_2')$ $\in \Delta$, $g_1\land g_2$ is unsatisfiable. ${\mathcal{A}}$ is $complete$ whenever for any location $l\in L$ and an action $a\in\Sigma$, the disjunction of the guards of the transitions leaving $l$ and labelled by $a$ evaluates to $true$. 

	%In this work, we only consider deterministic and complete TA \cite{alur1994theory,10.1016/j.scico.2016.02.008}. So, wherever we say a TA, it refers to a deterministic and complete TA.
     
        %\paragraph{Timed automata.} 
        
        
        
%
%
%        A clock valuation for $X$, where $X=\{x_1,\cdots,x_k\}$ is a finite set of clocks, is an element of ${\Bbb R}_{\geq0}^X$ , i.e., a function from $ X $ to ${\Bbb R}_{\geq0}^X$. $v+ \delta$ is the valuation assigning	$v(x) + \delta$ to each clock $ x $ of $ X $, where $ v \in  {\Bbb R}_{\geq0}^X$	and	$ \delta \in {\Bbb R}_{\geq0}$ (delay since previous action). Given a set of clocks $X'\subseteq X$, $v[X' \leftarrow 0]$ is the clock valuation $ v $ where all clocks in $ X' $ are assigned to 0. $ \mathcal{G}(X) $ denotes the set of guards. These are clock constraints defined as Boolean combinations of simple constraints of the form $ x \Join c $ with $ x \in X $, $ c \in {\Bbb N} $ and $\Join\in \{<,\leq,=,\geq,>\}$.	Given $g \in \mathcal{G}(X)$ and $v\in {\Bbb R}_{\geq0}^X$, we denote $v\models g$ when $ g $ holds according to $ v $. %\blue{A (semantic) state is a pair composed of a location and the clock valuations.}



    	% \begin{definition}[Timed automata]
    	% 	\label{def:ta}
    	% 	TA is a tuple ${\mathcal{A}}=(L, l_0, X, \Sigma,$ $\Delta, F)$, s.t. $L$ is a finite set of locations. $l_0 \in L$ is initial location. $X$ is a finite set of clocks. $\Sigma$ is a finite set of actions. $\Delta\subseteq L \times \mathcal{G}(X)\times \Sigma \times 2^X \times L$ is the transition relation. $F\subseteq L$ is the set of accepting locations.
    	% \end{definition}
	
    	


    %A run $ \rho $ from $ q \in Q $ is a sequence of moves in \sloppy{$ [\![ \calA ]\!]: \rho = q \xrightarrow{(\delta_1, a_1)} q_1 \cdots q_{n-1} \xrightarrow{(\delta_n, a_n)} q_n  $},	for some $ n \in N $, where the trace of a run $ \rho $ is the timed word $ (t_1, a_1) \cdot (t_2, a_2) \cdots (t_n, a_n) $, (where the date $t_n$ of action $ a_n $ is the sum of all the delays i.e., $ \Sigma_{i=1}^{n} \delta_i $). The set of runs from $ q_0 \in Q $ is denoted by $ Run(\calA) $. The subset of runs accepted by $ \calA $, i.e., when $ q_n \in F_G $ is denoted by $ Run_{F_G}(\calA) $. $\calL(\calA)$ denotes the language accepted by $\calA$ from its initial state $q_0$, whereas $\calL(\calA,q)$ denotes the language accepted by $\calA$ from state $q$.

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \subsection{Signal Temporal Logic}
    \label{sec:Signal Temporal Logic}
    %\paragraph*{Signal Temporal Logic} 
    Signal Temporal Logic (STL) \cite{maler2004monitoring} is a predicate logic used to describe and analyze continuous real-valued signals. Consider a signal $\signal:\NonNegReals\mapsto \Realn$. For each predicate $p(\signal)$, there is a corresponding function %\emph{linear function}
    $\mu_p:\Realn\mapsto \Reals$. The truth value of $p(\signal)$ at time $t$ is defined as follows:
    \begin{align*}
        p(\signal(t)) \Def\left\{
            \begin{aligned}
                \top,\quad \text{if}\quad \mu_p(\signal(t)) \ge 0,\\
                \bot,\quad \text{if}\quad \mu_p(\signal(t)) < 0.
            \end{aligned}\right.
    \end{align*}
    We will use the notion $p(\signal(t))\equiv\mu_p(\signal(t))\ge 0$ to define a predicate $p(x)$ in this paper. And we use \(|\signal|\) to denote the length of a signal.
    
    As demonstrated in \cite{fainekos2009robustness}, any STL formula can be equivalently converted into Negation Normal Form (NNF), in which negations appear only adjacent to predicates. In this paper, we considered \emph{non-nested} STL formula in NNF, which can be defined recursively as below:
    %this paper considers only the NNF representation of STL. The syntax of STL when expressed in NNF is outlined in the following definition:
    %\begin{definition}[STL in NNF Syntax]
    %\label{def:stl}
        %The syntax of Signal Temporal Logic (STL) is defined by
        %\saucomment{can we discuss this? Sure}
        \begin{align*}
            &\phi \Def ~ \top ~\mid~ p(\signal) ~\mid~ \neg p(\signal) ~\mid~ \phi_1 \land \phi_2 ~\mid~ \phi_1 \lor \phi_2,\\ %predicates
            &\varphi \Def ~ \phi_1 \until[I] \phi_2 ~\mid~ \phi_1 \release[I] \phi_2 ~\mid~ \varphi_1 \land \varphi_2 ~\mid~ \varphi_1 \lor \varphi_2~, %propositions
        \end{align*}
        where $\until_I$ and $\release_I$ are the \emph{until} and \emph{release} operators, respectively. $I=[t_1,t_2]$ is a \emph{bounded} interval with \emph{rational} endpoints (i.e., $t_1,t_2\in\NonNegRat$)\footnote{The endpoints of $I$ are restricted to $\NonNegRat$ to facilitate encoding this into the clock constraints of the TT defined in \cref{sec:Timed Transducer}}. Note that $\release_I$ are the dual of $\until_I$, in a way that $\phi_1\release_I\phi_2\equiv\neg(\neg\phi_1\until_I\neg\phi_2)$. We use $pd(\varphi)$ to denote the set of \emph{predicates} in an STL formula $\varphi$. The NNF replaces the negation of a formula by including all operators and their duals in the grammar. Other temporal operators can be defined as syntactic sugars, e.g., 
        %\[ 
            $\eventually_I\phi \equiv \top \until_I \phi,
            \always_I \phi \equiv \bot \release_I \phi$.
        %\]
    \begin{remark}
        We employ NNF because it facilitates the subsequent transformation of an STL formula into a timed transducer. This choice is strategically important since timed transducer, acting as a special form of timed automata, are not closed under complementation. Thus, negating an STL formula would necessitate taking the complement of its corresponding timed automaton, which is problematic due to this lack of closure. 
    \end{remark}

    The semantics of STL is defined as the satisfaction of a formula $\varphi$ with respect to a signal $\signal$ and time $t \in \NonNegReals$. 
        
        \begin{definition}[STL Semantics]
        \label{def:STL Semantics}
        The satisfaction of an STL formula $\varphi$ at a given time $t$ over a signal $\signal$, denoted by $(\signal, t) \models \varphi$, is inductively defined as follows:
            \begin{align*}
                &(\signal, t) \models \top & & \\
                &(\signal, t) \models p(x) & &\tiff\quad \mu_p(\signal(t)) \ge 0\\
                &(\signal, t) \models \neg p(x) & &\tiff\quad \mu_p(\signal(t)) < 0\\
                &(\signal, t) \models \varphi_1 \land \varphi_2& & \tiff\quad  (\signal, t) \models \varphi_1 \aand (\signal, t) \models \varphi_2\\
                &(\signal, t) \models \varphi_1 \lor \varphi_2& & \tiff\quad  (\signal, t) \models \varphi_1 \text{ or } (\signal, t) \models \varphi_2\\
                &(\signal , t) \models \varphi_1 \until_I \varphi_2& & \tiff\quad \exists t' \in t \oplus I,~ (\signal, t') \models \varphi_2\\ 
                & && \qquad\quad\aand\forall t'' \in [t, t'], (\signal, t'') \models \varphi_1\\
                & (\signal, t) \models \varphi_1 \release_I \varphi_2& & \tiff\quad \forall t'\in t \oplus I,~ (\signal, t') \models \varphi_2\\
                & && \qquad\quad\oor \exists t''\in[t,t'], (\signal,t'')\models \varphi_1
                %&\textcolor{red}{(\signal, t) \models \varphi_1 \release_I \varphi_2} && \tiff\quad (\exists t' \geq t, \suchthat (x,t') \models \varphi_1  \text{ and }\\ 
                %& && \qquad \qquad \forall t'' \geq t, \text{ such that } (x,t'') \models \varphi_2) \\
                %&&& \qquad \qquad \text{ or }  \forall t''' \geq t, (x, t''') \models \varphi_2
            \end{align*} 
            %φ R ψ is equivalent to ¬(¬φ U ¬ψ).
            % \hscomment{Release is dual to until, therefore it should be defined as above}
            % \saucomment{pl check above semantics of Release}
        \end{definition}
        %\hscomment{I feel there is no need to put is as remark}
        %\saucomment{yes, m putting this as a remark with a heading}
        %\begin{remark}[Relating Intervals in STL Formulas to Guards in Timed Transducer]    
            Intuitively, the subscript $I$ in the until operator $\until_I$ defines the timing constraints under which a signal must \emph{eventually} satisfy $\varphi_2$, while ensuring that $\varphi_1$ is satisfied beforehand. Similarly, the subscript $I$ in the release operator $\release_I$ specifies the timing constraints in which a signal must \emph{always} satisfy $\varphi_2$, unless $\varphi_1$ has been satisfied earlier. We say  $\signal\models\varphi$ if $(\signal,0)\models \varphi$.
        %\end{remark}
        
                \begin{example}
    		      \label{example:Properties in STL}
                The following examples illustrate some properties defined by STL.
                %For a signal $\signal$, we can think of various STL properties. For example:
    		    \begin{enumerate}
                    % \item $(\signal + 30 > 0 \land \signal - 30 < 0) \until_{[0,10]} (\signal = 100)$: The value of the signal will be 100 within 10 seconds; until then the value of the signal is within the range (-30,30).
                    \item $(\signal  \leq 30) \until_{[5,10]} (\signal = 0)$: The value of the signal will be $0$ at a time instant between $5$ to $10$ seconds; until then the value of the signal is less than $30$.
    		        \item $\always_{[0,\infty)} (\signal < 3.5)$: The signal is always below $3.5$.
                    \item $\eventually_{[0,30]} (\signal > 100)$: At some time in the first $30$ seconds, the value of the signal will exceed $100$. \qedT
    		    \end{enumerate}
    	    \end{example} 


    \subsection{Runtime Enforcement}
    \label{Preliminaries to Runtime Enforcement}
    The purpose of RE is to monitor input sequences produced by a running system and transform them into output sequences that adhere to a specified property $\varphi$. This is achieved using an enforcer.
 %This paper discusses RE of dense time signals. We can formally define an enforcer for a given property $\varphi$ as follows:
    % \hscomment{$\signal$ is a signal from $\NonNegReals$ to $\Realn$, and $X$ is the set of all such signal}
    
    \paragraph{Constraints on an Enforcer.} Let $X$ denote the set of signals \(\signal : \NonNegReals \mapsto \Realn\). Some constraints are required on how enforcer $E_{\varphi}$ for $\varphi$ transforms a signal $\signal$ at time $t$, to ensure that it performs correctly and minimally disruptively. %For example, the soundness constraint ensures that the enforcer’s output adheres to the specified property soundness. Without soundness, there would be no guarantee that the enforcer's output meets the desired specifications, undermining the purpose of runtime enforcement. 
    
    %Moreover, the transparency constraint ensures that the enforcer only intervenes when absolutely necessary. This is critical to maintaining system fidelity, as unnecessary modifications could disrupt expected behaviour, reduce efficiency, or introduce unintended side effects. By enforcing transparency, the enforcer maintains the integrity of the original signal as much as possible, preserving system performance and expected behaviour when no property violations occur. 
    
    %Lastly, the minimal/optimal modification constraint ensures that the enforcer modifies the output when the original input signal would violate the specified property such that it now satisfy the specified property and the modification should be minimal. By only making minimal changes, the enforcer keeps the output as close as possible to the original input signal. Overall, this constraint ensures that the enforcer is effective yet minimally invasive, thereby supporting system stability and efficiency. 
    % The formal definitions of the constraints are:
    

%   \hscommentinline{@Prof. Naijun, @Prof. Partha, @Prof. Srinivas: Please justified which version is more suitable}
    % \begin{definition}[Constraints on an Enforcer]\label{def:enforcer}
    %     Given an STL formula $\varphi$, an enforcer is a function $E_{\varphi}:X \times \NonNegReals \mapsto X$ that satisfies the following conditions:
    %     \begin{itemize}
    %         \item \emph{Soundness}:
    %         \[
    %         \forall \signal \in X,\forall t\in\NonNegReals,~ E_\varphi(\signal,t)=\resltsig \implies \resltsig\models \varphi,
    %         \]
    %         \item \emph{Transparency}:
    %         \[
    %         \forall \signal \in X,\forall t\in\NonNegReals, ~ \signal\models\varphi \implies  E_\varphi(\signal,t) = \signal,
    %         \]
    %         \item \emph{Minimal / optimal Modification}:
    %         \[
    %         \forall \signal \in X, \forall t\in\NonNegReals,~ \signal\not\models\varphi \implies E_\varphi(\signal,t) = \argmin_{\resltsig\in O}||\signal(t)-\resltsig(t)||,
    %         \]
    %         where $O = \{\resltsig\mid\resltsig\models \varphi\land |\signal|=|\resltsig|\}$, and $||\cdot||$ is the Euclidean norm in $\Realn$.
    %     \end{itemize}
    % \end{definition}

    % \saucomment{shall we have Def 5 with t or Def 6 without t?}
    % \nzcomment{I think this definition is correct, and the previous one is incorrect mathematically, at least not rigid enough.}
    \begin{definition}[Constraints on an Enforcer]\label{def:enforcer}
        Given an STL formula $\varphi$, an enforcer is a function $E_{\varphi}:X \mapsto X$ that satisfies the following conditions:
        \begin{itemize}
            \item \emph{Soundness}:
            \[
            \forall \signal \in X,~ E_\varphi(\signal)\models \varphi,
            \]
            \item \emph{Transparency}:
            \[
            \forall \signal \in X, ~ \signal\models\varphi \implies  E_\varphi(\signal) = \signal,
            \]
            \item \emph{Minimal Modification}:
            \[
            \forall \signal \in X,~ \signal\not\models\varphi \implies E_\varphi(\signal) = \argmin_{\resltsig\in O}||\signal-\resltsig||_s,
            \]
            where \(O = \{\resltsig \mid \resltsig \models \varphi \land |\signal| = |\resltsig|\}\), and $||\cdot||_s$ is the norm for signals defined as \(||\signal - \resltsig||_s \Def \max_t ||\signal(t) - \resltsig(t)||\), with $||\cdot||$ being the Euclidean norm in \(\Realn\).
        \end{itemize}
    \end{definition}
    
    %\saucomment{Note that: The "Minimal Modification" definition also includes instantaneity/ length preserving.}
    % Intuitively,  soundness.. transparency.. minimal modification..
    
    
    % Some constraints, namely soundness and transparency, are required on how enforcer $E_{\varphi}$ transforms signals $\signal$ at time $t$.
    
    % \begin{equation}
    %     Soundness: ~\forall \signal, \forall t \in \Reals_{\geq 0}, ~ E_{\varphi}(\signal,t)= \resltsig \implies \resltsig \models \varphi 
    % \end{equation}
    % Transparency
    % \begin{equation}
    %         Original ~signal:  \forall \signal, \forall t \in \Reals_{\geq 0}, \signal \models \varphi \implies E_{\varphi}(\signal,t)=\signal\\
    % \end{equation}
    % \begin{equation} 
    % \begin{split}
    %         Modified~ signal: \forall \signal, \forall t \in \Reals_{\geq 0}, \signal \not \models \varphi \implies\\ E_{\varphi}(\signal,t)=\resltsig: min(\mid\signal,\resltsig \mid) ~\land ~ \resltsig \models \varphi
    %         \end{split}
    % \end{equation}

    \begin{figure*}[htbp]
            \centering
            \begin{adjustbox}{max width=1\linewidth}
                \begin{tikzpicture}[font=\small]
                    \centering
                    \begin{scope}
                        \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
                        \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$x_1$};
                        \draw[dashed, color = gray] (0,1.05) node[left] {\black{$0.7$}} -- (6,1.05);
                        
                        \draw[color=NavyBlue, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
                            (0, 0.6)
                            (0.6, 1.05)
                            (1.2, 1.3)
                            (1.9, 1.2)
                            (2.7, 1.05)
                            (3.3, 0.94)
                            (3.8, 1.05)
                            (4.5, 1.3)
                            (5.4, 1.05)
                            (6.0, 0.8)
                        };
                        
                        \node at (0,0) [below] {\green{$0$}};
                        \draw[dashed, color = gray] (0.6, 0) node[below] {\orange{$0.5$}} -- (0.6,1.5);
                        \draw[dashed, color = gray] (2.7, 0) node[below] {\orange{$2.2$}} -- (2.7,1.5);
                        \draw[dashed, color = gray] (3.8, 0) node[below] {\orange{$3.2$}} -- (3.8,1.5);
                        \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
                        \draw[dashed, color = gray] (5.4, 0) node[below] {\orange{$4.5$}} -- (5.4,1.5);
                        \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
                    \end{scope}

                    \begin{scope}[shift = {(8,0)}]
                        \draw[-Stealth, thick] (0,0) -- (6.3,0) node[right] {$t$};     
                        \draw[-Stealth, thick] (0,0) -- (0,1.7) node[above,left] {$x_2$};
                        \draw[dashed, color = gray] (0,0.75) node[left] {\black{$0.5$}} -- (6,0.75);

                        \draw[color=Maroon, line width = 1.4pt, smooth, tension = 0.5] plot coordinates {
                            (0, 1.2)
                            (1.4, 0.75)
                            (2.3, 0.15)
                            (3.5, 0.3)
                            (4.5, 0.6)
                            (5.6, 0.75)
                            (6.0, 1)
                        };

                        \node at (0,0) [below] {\green{$0$}};
                        \draw[dashed, color = gray] (1.4, 0) node[below] {\orange{$1.2$}} -- (1.4,1.5);
                        \draw[dashed, color = gray] (4.8, 0) node[below] {\green{$4$}} -- (4.8,1.5);
                        \draw[dashed, color = gray] (5.6, 0) node[below] {\orange{$4.7$}} -- (5.6,1.5);
                        \draw[dashed, color = gray] (6,0) node[below] {\green{$5$}} -- (6,1.5);
                    \end{scope}
                    
                    \node at(6,-1.3) {
                           $\begin{array}{c}
                                \textsf{timestamps}  \\
                                \textsf{actions}
                           \end{array}
                           \left(\!\!\!\begin{array}{c}
                               \green{0}  \\
                               \nblue{\neg p_1}\land \maroon{p_2} 
                          \end{array}\!\!\!\right) 
                          \left(\!\!\!\begin{array}{c}
                               \orange{0.5}  \\
                               \nblue{p_1}\land \maroon{p_2} 
                          \end{array}\!\!\!\right)
                          \left(\!\!\!\begin{array}{c}
                               \orange{1.2}  \\
                               \nblue{p_1}\land \maroon{\neg p_2} 
                          \end{array}\!\!\!\right)
                          \left(\!\!\!\begin{array}{c}
                               \orange{2.2}  \\
                               \nblue{\neg p_1}\land \maroon{\neg p_2} 
                          \end{array}\!\!\!\right)
                          \left(\!\!\!\begin{array}{c}
                               \orange{3.2}  \\
                               \nblue{p_1}\land \maroon{\neg p_2} 
                          \end{array}\!\!\!\right)
                          \left(\!\!\!\begin{array}{c}
                               \green{4}  \\
                               \nblue{p_1}\land \maroon{\neg p_2} 
                          \end{array}\!\!\!\right)
                          \left(\!\!\!\begin{array}{c}
                               \orange{4.5}  \\
                               \nblue{\neg p_1}\land \maroon{\neg p_2} 
                          \end{array}\!\!\!\right)
                          \left(\!\!\!\begin{array}{c}
                               \orange{4.7}  \\
                               \nblue{\neg p_1}\land \maroon{p_2} 
                          \end{array}\!\!\!\right)
                          \left(\!\!\!\begin{array}{c}
                               \green{5}  \\
                               \nblue{\neg p_1}\land \maroon{p_2} 
                          \end{array}\!\!\!\right)$
                    };
                \end{tikzpicture}
            \end{adjustbox}
            \caption{Signal Encoding against Formula $p_1\until_{[4,5]}p_2$}
            \label{fig:signal-encoding}
            \end{figure*}
            
    Intuitively, \emph{soundness} ensures that the output signal complies with the specified STL formula $\varphi$. \emph{Transparency} stipulates that if the input signal $\signal$ already meets $\varphi$, the enforcer should not alter it, but rather transmit the original signal $\signal$ as the output. \emph{Minimal modification} requires that if the input signal $\signal$ does not satisfy $\varphi$, the enforcer should adjust it to ensure compliance with $\varphi$, while keeping the modifications as minimal as possible relative to the original signal $\signal$.
    
    % Intuitively, \emph{soundness} means that the output signal satisfies the given STL formula $\varphi$. \emph{Transparency} means that if the input signal $\signal$ satisfies the given STL formula $\varphi$, then the enforcer should not modify it and simply relay the original signal $\signal$ as output. \emph{Minimal modification} means that if the input signal $\signal$ does not satisfy the given STL formula $\varphi$, then the enforcer should modify it such that it now satisfies the given STL formula $\varphi$ and the modification should be minimal with respect to the original signal $\signal$.


    %\hscommentinline{Transparency, Soundness, Enforcement Function, minimal modified function}


    
\paragraph{Problem Formulation}
\label{sec:Problem Formulation}
    %In this paper, we aim to construct a runtime enforcer for a given STL formula $\varphi$. Let $X$ denote the set of signals.  This enforcer takes as input signals $\signal \in X$ observed up to the current time $t$ and outputs modified signals $\resltsig$ that satisfy $\varphi$. 
    With all the preliminary details established, we now formally define the problem under consideration in this paper as follows:
    \begin{tcolorbox}[boxrule=.5pt,colback=white,colframe=black!75]
        \textbf{Synthesis of Enforcer.} Given an STL formula $\varphi$, construct an enforcer $E_{\varphi} : X \mapsto X$ for $\varphi$ that satisfies the \emph{soundness}, \emph{transparency}, and \emph{minimal modification} conditions as per \cref{def:enforcer}.
    \end{tcolorbox}

    % \begin{problem}
    %     Given an STL formula $\varphi$, construct an enforcer $E_{\varphi} : X \mapsto X$ of $\varphi$ that satisfies the soundness, transparency, and minimal modification conditions as per \cref{def:enforcer}.
    % \end{problem}

    % With all the priliminary be introduced, we now formally defined he problem under consideration in this paper as follows:
    % \begin{problem}
    %     % Given an STL formula $\varphi$, construct an enforcement function $E_{\varphi}:(X\times\NonNegReals)\mapsto X$, such that for all input signals $\signal$, the resulting signals $\resltsig=E_{\varphi}(\signal,t)$ satisfy: $\resltsig\vDash\varphi$.
    %     Given an STL formula $\varphi$, construct an enforcer $E_{\varphi}:X\mapsto X$ of $\varphi$ that satisfying the \emph{soundness}, \emph{transparency}, and \emph{minimal modification} conditions as per \cref{def:enforcer}.
    %     %such that for all input signals $\signal$, the resulting signals $\resltsig=E_{\varphi}(\signal,t)$ satisfy the constraints given in subsection \ref{Preliminaries to Runtime Enforcement} i.e., soundness and  transparency.
    % \end{problem} 

    % In order to solve this problem the approach that we employ is as follows: we will translate the given STL formula into timed transducer suitable for enforcement such that if a signal is accepted by the timed transducer, then it also satisfies the corresponding STL formula. We devise an enforcement algorithm (enforcer) that will yield the corrected signal (w.r.t. the given STL formula). This enforcer is \textit{Sound} (the output signal satisfies the given formula) and \textit{Transparent} (the input signal is modified when necessary and in a minimal way) with respect to the formula.
    % Having done this, at runtime, the given signal to be corrected is encoded as a timed word that is capable of being accepted by timed transducer.  %We then specify constraints on an enforcer and devise an enforcer or enforcement algorithm which is a solution to the specified constraints. 
    % That timed word is given as input to the algorithm, which enforces the formula (expressed as timed transducer) onto the signal. %encoded as a time word. 

    %  The steps can be recapitulated as follows:
    % \begin{enumerate}
    %     \item Signal Encoding: A signal should be encoded as a time word that is capable of being accepted by the timed transducer.
    %     \item Transform STL formula (to be enforced onto the given input signal) into the timed transducer.
    %     \item Enforcing the property expressed as a timed transducer onto the signal.
    % \end{enumerate}
    
    % The below sections explain these steps in detail.
    