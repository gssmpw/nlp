\section{Background and Problem Statement}
An \textit{answer set program} $P$ consists of a set of rules, each rule is structured as follows:
\begin{align}
\label{eq:generalrule}
\text{Rule $r$:~~}a_1 \vee \ldots a_k \leftarrow b_1, \ldots, b_m, \textsf{not } c_1, \ldots, \textsf{not } c_n
\end{align}
where, $a_1, \ldots, a_k, b_1, \ldots, b_m, c_1, \ldots, c_n$ are propositional variables or atoms, and $k,m,n$ are non-negative integers. 
The notations $\rules{P}$ and $\at{P}$ denote the rules and atoms within the program $P$. 
In rule $r$, the operator ``\textsf{not}'' denotes \textit{default negation}~\cite{clark1978}. For each 
rule $r$ (\cref{eq:generalrule}), we adopt the following notations: the atom set $\{a_1, \ldots, a_k\}$ constitutes the {\em head} of $r$, denoted by $\head{r}$, the set $\{b_1, \ldots, b_m\}$ is referred to as the {\em positive body atoms} of $r$, denoted by $\body{r}^+$, and the set $\{c_1, \ldots, c_n\}$ is referred to as the \textit{negative body atoms} of $r$, denoted by $\body{r}^-$.
A rule $r$ is called a {\em constraint} when $\head{r}$ contains no atom.
A program $P$ is called a {\em disjunctive logic program} if there is a rule $r \in \rules{P}$ such that $\Card{\head{r}} \geq 2$~\cite{BD1994}.
% While the body of a rule is a set of atoms, we use $\body{r}$ to denote the conjunction $b_1 \wedge \ldots b_m \wedge \neg{c_1} \wedge \ldots \neg{c_n}$ in the following discussion, and we use the notation $\rulesyntax{.}$ to express a rule.

In ASP, an interpretation $M$ over $\at{P}$ specifies which atoms are assigned \true; that is, an atom $a$ is \true under $M$ if and only if $a \in M$ (or \false when $a \not\in M$ resp.). 
%
An interpretation $M$ satisfies a rule $r$, denoted by $M \models r$, if and only if $(\head{r} \cup \body{r}^{-}) \cap M \neq \emptyset$ or $\body{r}^{+} \setminus M \neq \emptyset$. An interpretation $M$ is a {\em model} of $P$, denoted by $M \models P$, when $\forall_{r \in \rules{P}} M \models r$. 
%
The \textit{Gelfond-Lifschitz (GL) reduct} of a program $P$, with respect to an interpretation $M$, is defined as $P^M = \{\head{r} \leftarrow \body{r}^+| r \in \rules{P}, \body{r}^- \cap M = \emptyset\}$~\cite{GL1991}.
%
An interpretation $M$ is an {\em answer set} of $P$ if $M \models P$ and no $M\textprime \subset M$ exists such that $M\textprime \models P^M$.
%
We denote the answer sets of program $P$ using the notation $\answer{P}$.

\paragraph{Exact Answer Set Counting~\cite{KCM2024}}
Given an ASP program $P$, the exact answer set counting seeks to count the number of answer sets of $P$; more formally, the problem seeks to find $\Card{\answer{P}}$.

\paragraph{Approximate Answer Set Counting~\cite{KESHFM2022}}
Given an ASP program $P$, tolerance parameter $\epsilon$, and confidence parameter $\delta$, the approximate answer set counting seeks to estimate the number of answer sets of $P$ with a probabilistic guarantee; more formally, the approximate answer set counters returns a count $c$ such that 
$\pr{\sfrac{\Card{\answer{P}}}{1 + \epsilon} \leq c \leq (1 + \epsilon) \times \Card{\answer{P}}} \geq 1 - \delta$. Our approximate answer set counter invokes a polynomial number of calls to an ASP solver. 

\paragraph{Clark's completion} \cite{clark1978} or \emph{program
completion} is a technique to translate a normal program $P$ into a propositional formula $\completion{P}$ that is related but not semantically equivalent. Specifically, for each atom $a$ in $\at{P}$, we perform the following steps:
\begin{enumerate}
    \item Let $r_1, \ldots, r_k \in \rules{P}$ such
      that $\head{r_1} =\ldots= \head{r_k} = a$, then we add the
      propositional formula $(a \leftrightarrow (\body{r_1} \vee
      \ldots \vee \body{r_k}))$ to $\completion{P}$.
    \item Otherwise, we add the literal $\neg{a}$ to $\completion{P}$.
\end{enumerate}
Finally, $\completion{P}$ is derived by logically conjoining all the previously added constraints. Literature indicates that while every answer set of $P$ satisfies $\completion{P}$, the converse is not true~\cite{LZ2004}.