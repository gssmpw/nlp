In this section, we provide the general definition and discussion of our newly proposed scheme, the Efficient 2-layer Identity-Based Signature Scheme (\scheme{}).

In PKI-based schemes, the security of cryptographic primitives (e.g., digital signatures) hinges on the authenticity of public keys. In conventional systems, this is achieved by digital certificates or certificate chains. 
For instance, to verify a digital signature, the verifier must confirm the authenticity of the signer's public key by ensuring the validity of the associated certificates. However, the communication and computation overhead introduced by certificates might not be tolerable in some applications (mobile devices operating in low-bandwidth environments). To address this, in identity-based cryptography, the user's public key is derived from their publicly available information (e.g., IP address).  
Existing efficient identity-based signature schemes (e.g., \cite{singla2021look}) are primarily based on the Schnorr signature \cite{Schnorr91}. 
Despite their elegant design, their inherent design and the key generation process (which derives keys from the Schnorr signature) can result in less efficient verification algorithms. 

With the efficiency and security requirements of 5G networks in mind, we present a new Efficient 2-layer Identity-Based Signature (\scheme{}).  \scheme{}, presented in  Algorithm \ref{alg:IBS}, offers highly efficient signing and verification, ensures high resiliency by avoiding a single point of failure, and supports fine-grained lawful interception.  
This is achieved by deriving a new identity-based signature from the highly efficient certificate-based scheme, ARIS \cite{ARIS}. The efficiency of ARIS is due to the ability to convert costly exponentiation operations to a few point additions by utilizing the homomorphic property of the underlying one-way function. This results in computation efficiency in both signing and verification algorithms. 

As depicted in Algorithm \ref{alg:IBS}, after the parameter selection (similar to \cite{ARIS,Tachyon}), the Setup algorithm computes the $t$ public key elements $mpk=\{Z_i\}_{i=1}^t$ and publishes the public parameters. We note that parameters $t$ and $k$ are related to the k-combinatorial problem \cite{Tachyon,ARIS}, i.e., ${t \choose k}\geq 2^\kappa $ (for security parameter $\kappa$)  and play an important role in providing storage and computation overhead trade-off.  For instance, a larger $t$ results in larger keys but more efficient signing and verification, as it allows for a smaller $k$.   During the extract algorithm, by harnessing the scheme in \cite{ARIS}, the PKG computes the user's key pair ($sk_U,{C}_U$) based on the provided identity $U$.   
After computing the user keys and considering their structure, the signing and verification processes can be carried out in a manner similar to that in \cite{Schnorr91}.
 
\newcommand{\algrule}[1][.2pt]{\par\vskip.3\baselineskip\hrule height #1\par\vskip.3\baselineskip}

\begin{algorithm}\caption{$\scheme{}$}\label{alg:IBS}
\small
$(msk,params)\gets\setup(1^\kappa)$
\algrule[0.5pt]
\begin{algorithmic}[1]
 
\item Given $\kappa$, select $p,q$, $msk \Ra \mathbb{Z}_p$ and  $t,k\Ra \mathbb{N}$ where   ${t \choose k}\geq 2^\kappa $
\item  Compute $z_i \gets \PRF_{msk}(i)$  and $Z_i \gets z_iP \mod q$ $\mathbf{for}$  $i= \{1,\dots,t\}$ and set $\mathbf{Z}\gets \{Z_i\}_{i=1}^t$
\item  Output $msk$ and $params=(mpk,p,q,t,k)$, where $mpk=\mathbf{Z}$
 
\end{algorithmic}
\algrule[0.5pt]

 $(\sk_U,{C}_U)\gets\sgnextract(msk,U)$
\algrule[0.5pt]

\begin{algorithmic}[1]

\item Compute $u \gets \PRF_{msk}(U)$ and ${C}_{U}\gets u P \mod q$ 
\item Compute $\{j_1\dots, j_k\}\gets \h_1(U,C_{U})$ where each $|j_i| = |t|$

 \item Compute $x_{U}\gets   \sum_{i=1}^{k} z_{j_i} + u \mod p$  
  \item Output $(\sk_U  = x_{U}$, ${C}_U$) 
\end{algorithmic}
\algrule[0.5pt]

$\sigma_{m,U}\gets\sign(m,\sk_U)$
\algrule[0.5pt]
\begin{algorithmic}[1]
\item Select $r \Ra \mathbb{Z}_p$ and compute $  h\gets \h_2(m,rP \mod q) $
\item Compute $s\gets r - h \times \sk_U$
\item Outputs $\sigma_{m,U} = (s, h)$

\end{algorithmic}

\algrule[0.5pt]
$\{\text{valid},\text{invalid}\}\gets\verify(m,\sigma_{m,U},U,{C}_U,mpk)$
\algrule[0.5pt]
\begin{algorithmic}[1]

\item Compute $\{j_1,\dots,j_{k}\} \gets \h_1(U,C_U)$ 
\item $R'\gets sP+h(\sum_{i=1}^k \mathbf{Z}[j_i] \mod q +C_U)$
\item Output `valid' \textbf{if} $h=\h_2(m,R')$, \textbf{else} output `invalid'

\end{algorithmic}

\end{algorithm}

\subsection{Robust Security and fine-grained lawful interception} \label{sec:lawful}
Identity-based systems solely rely on the PKG to generate the keys for all users, creating a single point of failure. Thus, if the PKG is compromised, the entire system's security is at risk. To address this vulnerability, we leverage the additive property of the key generation algorithms of \scheme{} to propose new key generation methods (Algorithm \ref{alg:IBS_lawful}). This is achieved by dividing the signer's key into two components, $u_1$ and $z_U$. During the new key generation process, the signer selects $u_1$ and computes its commitment $Q_u$.
The PKG then computes the other secret component, i.e., $z_U$, by deriving an ARIS signature (see $\sgnextract(\cdot)$ in Algorithm \ref{alg:IBS_lawful}) on user identity $U$ and $Q_u$ (implicit certification).  After receiving $z_U$, by leveraging the additive property of \scheme{}, the signer computes the \emph{final} secret key as $x_U\gets u_1+z_U \mod p$. In this case, even if the PKG is compromised, the user secret key remains secure since the adversary needs knowledge of $ u_1$ to compute it. 

With this improvement, the new key generation algorithm can also enable a fine-grained lawful interception by allowing the signer to reissue its key by running $(u_1,Q_U)\gets \userkg(params)$  and requesting a new $x_U$ from the PKG. This requires including a sequence number $t$, supplied by the user $U$, in the input of the hash function $\h_1(\cdot)$ during the $\sgnextract(\cdot)$ algorithm. Using the sequence number in key generation prevents the misuse of the old keys and provides an efficient approach for fine-grained control of the key lifespan. 

\begin{algorithm}\caption{Key Generation for robust security and fine-grained lawful interception}\label{alg:IBS_lawful}
\small
$(u_1,Q_U)\gets\userkg(params)$
\algrule[0.5pt]

\begin{algorithmic}[1]
 
\item Compute $u_1 \gets  \ZZ_p$
\item Compute $Q_U \gets u_1 P \mod q $
\item Output $(u_1,Q_U)$
 
\end{algorithmic}
\algrule[0.5pt]

 $(x_U,{C}_U)\gets\sgnextract(msk,Q_U)$
\algrule[0.5pt]

\begin{algorithmic}[1]

\item Compute $u_2 \gets \PRF_{msk}(U)$ and ${B}_{U}\gets u_2 P \mod q$ 
\item Compute $C_U \gets Q_U+B_U \mod q$
\item Compute  $\{j_1\dots, j_k\}\gets \h_1(U,C_{U})$ where each $|j_i| = |t|$

 \item Compute $z_{U}\gets   \sum_{i=1}^{k} z_{j_i} + u_2 \mod p$  
  \item Output $( z_{U}, B_U,{C}_U$) 
\end{algorithmic}
\algrule[0.5pt]

$\sk\gets\cmpkey(u_1,z_U)$
\algrule[0.5pt]

\begin{algorithmic}[1]
 
\item Compute $x_U\gets u_1+z_U \mod p$
\item Output ($x_U,Q_U$)
 
\end{algorithmic}

\end{algorithm}

\subsection{Security Analysis}
\begin{theorem}
    In the random oracle model, if an adversary \A~can break the scheme proposed in Algorithm \ref{alg:IBS}, in the sense of Definition \ref{def:eucma}, then one can construct another algorithm \C~that runs the adversary and \A~as a subroutine and can solve an instance of the ECDL problem in Definition \ref{def:ecdl}.
\end{theorem}
 
\begin{proof}

    Given  $X\gets \EC$ as an instance of the ECDL problem, \C~works as follows to find a solution $z^*\gets \ZZ_p$, such that $z^*P=Z^* \mod q$. 
    
    \noindent\emph{Setup:} \C~keeps two lists ($L_1, L_2$) to keep track of the output of the random oracles $\h_1(\cdot)$ and $\h_2(\cdot)$  and lists $L_\sigma$ and $L_U$ to keep track of the messages submitted to the sign and corrupt oracles, respectively. \C~sets up the following random oracles to handle queries to hash functions. 
    \begin{itemize}
        \item $\alpha_1\gets \h_1$-$\mathtt{sim}(U,C_{U},L_1)$: If the input (i.e., $U,C_{U}$) already exists, it returns the corresponding $\alpha_1$, else, it returns  $\alpha_1 \Ra \{0,1\}^{k|t|}$ and stores $(U,C_{U},\alpha_1)$   in $L_1$. 
        
        \item $\alpha_2\gets \h_2$-$\mathtt{sim}(m, R, L_2)$: If the input $(m,R)$ already exists, it returns the corresponding $\alpha_2$, else, it returns  $\alpha_2 \Ra  \ZZ_p$ and stores $(m, R,\alpha_2)$   in $L_2$. 
            
            \end{itemize}
     Next, \C~selects a target index $j^*\gets \{1,\dots,t\} $ and sets the target $mpk$ element $ Z_{j^*} =  Z^*$. Then it selects $z_i \Ra \ZZ_p$ and compute  $Z_i\gets z_i P \mod q $ where $i\in\{1,\dots,t\}$ and $i\neq j^*$ and output $mpk=(Z_i, \dots, Z_t)$.

    \noindent \emph{Queries:} 
    
    \begin{itemize}
    \item \emph{Hash queries:} Hash queries on $\h_1$, $\h_2$ and $\h_3$ will be handled by   $\h_1$-$\mathtt{sim}(\cdot)$, $\h_2$-$\mathtt{sim}(\cdot)$ and $\h_3$-$\mathtt{sim}(\cdot)$ functions defined above, respectively. 
    \item \emph{$\mathcal{O}_{Corrupt}({U})$ Queries:} Given a user $U$, if $U$ exists in $L_U$, it returns $(x_{U})$. Next, it checks $L_1$; if such $U$ exits with an index corresponding to $j^*$, it aborts. Else, it selects $u\Ra \ZZ_p$, computes $U\gets uP \mod q$. Next, it selects $j_i\Ra\{1,\dots,t\}$ for $i=\{1,\dots,k\}$ and $j_i \neq j^*$, for each $j_i$, recovers the corresponding $z_{j_i}$ and computes and returns the secret key $x_{U}\gets \sum_{i=1}^k z_{j_i}+u \mod p$. To respond to future queries, the output is stored in $L_U$. 
    \item \emph{$\mathcal{O}_{Sign}(m,U)$ Queries:} For signature queries for users $U$ where $\alpha_1 $ does not contain $j^*$, \C~can work similar to the $\sign(\cdot)$ to generate the signature. Otherwise, when $\alpha_1$ contains $j^*$, \C~uses its access to the random oracle and works similarly to Schnorr Signature to generate a valid signature for \A.
    
    \end{itemize}
    \noindent \emph{$\A$'s Forgery:}  Finally, $\A$ will output a forgery message-signature pair $(m^*,\sigma_{U^*})$. $\A$ wins the game if $\text{`valid'}\gets\scheme.\verify(m^*,\sigma_{U^*},U^*,{C}_{U^*},mpk)$ and  $m^*$ was not submitted to $\mathcal{O}_{Sign}(\cdot)$.   

\noindent \emph{Solving the hard problem:} After outputting a valid forgery by $\A$, $\C$ checks if for $U^*$  the target public key element $Z^*$ is embedded $\alpha_1$. Else, it fails. If   $\alpha_1$ indeed contains $j^*$, similar to \cite{Tachyon,ARIS}, \C~utilizes the forking lemma \cite{Bellare-Neven:2006}, to obtain a second forgery $m^*,\sigma'_{U^*}$, where with a very high probability $s^*\neq s'$ and $h^*= h' $. Then, given the results of Lemma 1 in \cite{Bellare-Neven:2006}, to solve the ECDL problem.
    
\end{proof}

\begin{cor}
 The key generation algorithm provided in Algorithm \ref{alg:IBS_lawful} offers robust security by  preventing a single point of failure inherent in identity-based schemes. 
\end{cor}
\begin{proof}
      In the original scheme (i.e., Algorithm \ref{alg:IBS}), the secret component of the user key is computed as $x_U\sum_{i=1}^{k} z_{j_i} + u \mod p$, where both $z_j$'s and $u$ are known and selected by the PKG.  
      Consequently, a compromised PKG can issue private keys on behalf of the user. In the key generation algorithm with robust security in Algorithm \ref{alg:IBS_lawful}, the secret component of user key is computed as $x_U = \sum_{i=1}^{k} z_{j_i} + u_2+u_1$ where $u_1$ is not known to the PKG. This offers the binding property by incorporating the commitment of $u_1$ as the input of the hash function $\h_1(\cdot)$. We note that the correctness of the key supplied by the PKG can be simply  verified by the user by running the verification algorithm in ARIS \cite{ARIS} on $z_U$.
\end{proof}