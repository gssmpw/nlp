%This section describes how to specify target motifs and putative scaffolds, and how a collection of generated scaffolds is evaluated.
%The motif and scaffold specifications are made precise through a formatting convention introduced in Appendix XXX.
%Considerations and subjective choices made in the evaluation criteria are discussed in Appendix XXX.
%The evaluation metrics are made precise through pseudo-code in Appendix XXX.



A motif-scaffolding method
takes a motif as input and returns a set of putatively compatible scaffolds as output.
%The present benchmark proposes metrics to evaluate the quality of these solutions.
This section details how motifs and scaffolds in MotifBench are specified,
proposes metrics by which a scaffold set is evaluated,
and describes how these metrics are computed.
\Cref{sec:considerations} describes considerations upon which these specifications and metrics were chosen.



\paragraph{Motif specification (inputs):}
A \emph{motif} is specified by the coordinates of the backbone atoms of several residues and (in some cases) the amino acid types of a subset of those residues.
\begin{itemize}
    \item {Motif atom coordinates are extracted from experimental structures deposited in the Protein Data Bank (PDB) \citep{berman2002protein}.}
    \item {Each problem comprises the N, C$\alpha$, and C backbone coordinates of several residues.}
    \item {The residues may be part of a single sequence-contiguous segment, or they may be divided across multiple segments.}
    \item {When the amino acid types at particular positions are thought to be important to the biochemical function of the motif, these types and positions are specified and may not be modified in designed scaffolds.  Side-chain heavy atom coordinates for these positions are also provided as optional inputs.}
\end{itemize}

\paragraph{Scaffold set specification (outputs):}
For each motif, the motif-scaffolding method outputs a collection of 100 \emph{scaffolds}, each specified through the coordinates of backbone atoms (including those in the motif) of a single protein chain.
\begin{itemize}
\item{Coordinates for C$\alpha$ atoms must be given, and additional backbone atoms (N, C and O) may be specified as well.}
\item{All scaffolds must contain the same number of residues.  This fixed overall length of scaffolds is part of the problem specification.}
\item{Each scaffold is accompanied by metadata specifying the placement of the motif segment(s) in the scaffold sequence.
These placements may be chosen in any way (e.g.\ to match the order and spacing in the experimental structures, algorithmically, or manually).}
\end{itemize}


\paragraph{Evaluation:}
\input{main/schematic_figure}
Three metrics comprise the evaluation of each scaffold set: the \emph{number of unique solutions}, the \emph{novelty} of solutions, and overall \emph{success rate}.

The ``number of unique solutions'' counts the number of substantively distinct scaffolds in the set that are predicted to maintain the geometry of the motif within an experimentally realizable backbone.
This metric emphasizes that a method for the motif-scaffolding problem should ideally provide a variety of solutions;
protein design problems often have additional difficult-to-specify constraints and so benefit from further computational filtering and experimental screening.
This metric is computed as follows:

\begin{enumerate}
    \item{For each scaffold, eight amino acid sequences are generated using a fixed backbone sequence design method. MotifBench uses \texttt{ProteinMPNN} \citep{dauparas2022robust} as default. 
    If not all backbone atoms (N, C$\alpha$, C and O) are specified, then C$\alpha$-only \texttt{ProteinMPNN} is used.
    }
    \item{For each generated sequence, a backbone structure is predicted using \texttt{ESMFold} \citep{lin2022language}.}
    \item{A scaffold backbone is a ``success'' if at least one of the eight sequences satisfies both of the following creteria:
    \begin{itemize}
        \item {\textbf{Motif maintenance:} The root mean squared distance (RMSD) between the backbone atoms (N, C$\alpha$, and C) of the input motif and corresponding atoms of the predicted structure (the \emph{motifRMSD}) is at most 1.0 Angstrom (\AA);}
        \item{\textbf{Scaffold validity:} The RMSD between corresponding backbone atoms (C$\alpha$ only) of the generated and predicted structures (the \emph{self-consistency RMSD}, or \emph{scRMSD} \citep{trippe2022diffusion}) is at most 2.0 \AA.}
    \end{itemize}
    For each of the above steps, the Kabsch algorithm \citep{kabsch1976solution} is first used to align structures so that the minimum RMSD across all possible alignments is returned.
    }
    \item{The ``number of unique solutions'' is the number of clusters into which ``successful'' backbones are assigned by \texttt{Foldseek-Cluster} \citep{barrio2023clustering}.}
\end{enumerate}

Secondarily, a scaffold set is evaluated by two additional metrics:
\begin{itemize}
\item{``Novelty'' quantifies the typical distance of solutions to any structure in the PDB \citep{berman2002protein}. 
 To compute the novelty, for each success we use \texttt{FoldSeek-Search} \citep{van2024fast} to approximate the highest TM-score \citep{zhang2005tm} to any structure in the PDB.
 Then for each cluster of successes we compute the mean of one minus this TMscore within the cluster.
 The  ``Novelty'' is the mean of this score across clusters, or $0$ if there are no successful scaffolds.}
\item{The ``Success rate'' is the fraction of scaffolds in the set that are successes, independent of their diversity and novelty.}
\end{itemize}

\paragraph{The MotifBench score for ranking performance across a set of problems.}
To enable ranking the relative ability of a motif-scaffolding method to provide unique solutions across a collection of test cases we introduce the ``MotifBench score''.  The MotifBench score has the form

$$
\textrm{MotifBench score} = \frac{1}{\# \mathrm{\ test\ cases}} \sum_{i=1}^{\# \mathrm{\ test\ cases}} (100 + \alpha) \frac{\#\mathrm{\ unique \ solutions\ for\ case\ } i}{\alpha + \# \mathrm{\ unique \ solutions \ for \ case\ } i}\ , \quad \mathrm{with}\  \alpha=5.
$$

We choose the form of this score to capture that the marginal value of an additional solution for a given problem is much larger when the number of unique solutions is low.  If there were just one motif, one could rank on the number of unique solutions.
However, simply averaging this across misses that the marginal value of an additional solution is much larger when the number of solutions is low.

We note two properties of this metric:
\begin{itemize}
    \item It ranges from 0 to 100; the score is 0 if no solutions are found and 100 every backbone is a unique solution for every problem.
    \item The choice of $\alpha =5$ gives high weight to first solutions and increases much more slowly as the number of solutions grows larger.
\end{itemize}
As examples, with 1, 5, or 50 solutions the MotifBench score is 17.5, 52.5 or 95.5, respectively.

As a consequence of the second property, the MotifBench score reflects that it is preferable for a method to provide few solutions to more motifs rather than to provide more solutions to few motifs.
So a method (``method A'') that gives one unique solution for every test case would achieve a much higher score (17.5/100) than another method (``method B'') that returns one hundred solutions for one of the thirty total test cases and zero solutions to the twenty-nine every other problem (3.33/100).  By contrast, the simpler score that is just the average number of unique solutions would be lower for method A (1./100) than method B (3.33/100).


The MotifBench score is not, however, intended to capture every aspect of a motif-scaffolding method and cannot be taken to indicate that one method is superior than another in every setting.  Indeed a method that tends to provide a smaller number of unique solutions than another may still be preferable in some applications if the solutions it identifies are more novel or have different secondary structure content on average.



\paragraph{Pseudo-code algorithms detailing the evaluation procedure.}
\Cref{alg:test_backbone_set,alg:test_scaffold} detail the evaluation procedure and metrics. 
They use the following notation:
\begin{itemize}
\item{$\vec x_{n,l,a}^{\mathrm{design}}:$ 3D coordinate of atom $a$ in residue $l$ of designed scaffold $n$.}
\item{$I_{n, m}^{\mathrm{design}}:$ Index of the first residue of motif segment $m$ in scaffold $n$.  }
\item{$\vec x_{m,l, a}^{\mathrm{motif}}:$ 3D coordinate of atom $a$ in residue $l$ of motif segment $m.$} % motif coordinates
\item{$s_{m,l}^{\mathrm{motif}}:$ Amino acid type of residue $l$ of motif segment $m.$} % motif sequence
\item{$r_{m,l}^{\mathrm{motif}}:$ Indicator of whether the amino acid type of residue $l$ of motif segment $m$ may be redesigned.}
%L_{\mathrm{design}}, % fixed length of each design
\end{itemize}

\begin{algorithm}[t]
\caption{Compute metrics for a scaffold set for a given motif }\label{alg:test_backbone_set}
\begin{algorithmic}
\Procedure{backbone\_metrics}{$
\{\vec x_{n,l,a}^{\mathrm{design}} \},  % designed backbones
\{I_{n, m}^{\mathrm{design}}\}, % motif placements
\{\vec x_{m,l, a}^{\mathrm{motif}}\}, % motif coordinates
\{s_{m,l}^{\mathrm{motif}}\}, % motif sequence
\{r_{m,l}^{\mathrm{motif}}\} % restricted positions {0,1}^{m, l_m}
%L_{\mathrm{design}}, % fixed length of each design
%, N_{\mathrm{design}}=100 % number of designs
$}
\LeftCommentOne{Identify successful scaffolds}
%\State{$\textrm{valid}_n \leftarrow \texttt{check\_valid}(\{\vec x_{n,l,a}^{\mathrm{design}}\}, \{I_{n,m}^{\mathrm{design}}\}, \{s^{\mathrm{motif}}_m\},\{r_{m,l_m}^{\mathrm{motif}}\})$}
%\Comment{$n\in \{1, \dots, N_{\mathrm{design}}\}$}
\State {$\textrm{success}_n%, \{ \vec x_{n, l, a}^{\mathrm{pred}}\} 
{\leftarrow} \texttt{testScaffold}(\{\vec x_{n,l,a}^{\mathrm{design} }\}, \{I_{n,m}^{\mathrm{design}}\}, \{x^{\mathrm{motif}}_{m,l, a}\}, \{s^{\mathrm{motif}}_{m,l}\}, \{r_{m,l}^{\mathrm{motif}}\})$}\Comment{$n\in \{1,\dots, 100\}$}
%n{\in} \{1, \dots, N_{\mathrm{design}}\}$}
%\If{valid \textbf{and} success}
%\State $\{\vec x_{n,l,a}^{\mathrm{success}}\} \gets \{ \{\vec x_{n, l, a}^{\mathrm{pred}}\} \textrm{\ for\ } n\in \{1,\dots, N_{\mathrm{design}}\} \textrm{\ if valid}_n=\mathbf{True} \textrm{\ and success}_n=\mathbf{True} \}$  
\State $\{\vec x_{n,l,a}^{\mathrm{success}}\} \gets \{ \{\vec x_{n, l, a}^{\mathrm{design}}\} \textrm{\ for\ } n\in \{1,\dots, 100\} \ \textrm{if success}_n=\mathbf{True} \}$  
\State $N_{\mathrm{success}} \gets | \{\vec x_{n,l,a}^{\mathrm{success}}\}|$
\State 
\LeftCommentOne{Cluster for the number of unique solutions.}
\State clusters $\gets \texttt{Foldseek-cluster}( \{\vec x_{n,l,a}^{\mathrm{success}}\}$)
\State num\_solutions = $|\textrm{clusters}|$
\State 
\LeftCommentOne{Compute novelty}
%\For{c in clusters}
    \State $\{\mathrm{pdb\_tm}_{c,n}\} \gets \texttt{Foldseek-search}(\{x_{n,l,a}^{\mathrm{success}}\})$ 
    \Comment{$c\in \textrm{clusters}, n \in \textrm{c}$}
    \State {$\textrm{novelty}_c$} $\gets 1\ - \ \mathrm{mean}(\{\mathrm{pdb\_tm}_{c,n}\  \textrm{for}\  n \in c\}$) 
    \Comment{$c\in \textrm{clusters}$}
%\EndFor
    \State {novelty} $\gets \mathrm{mean}(\{\mathrm{novelty}_c \ \textrm{for} \ c \in \textrm{clusters}\}$) 
\State 
\LeftCommentOne{Compute success rate}
\State $\textrm{success\_rate} = N_{\mathrm{success}} / 100$
\State \Return num\_solutions, novelty, success\_rate
\EndProcedure
\end{algorithmic}
\end{algorithm}


\begin{algorithm}
\caption{Test backbone for motif maintenance and scaffold validity}\label{alg:test_scaffold}
\begin{algorithmic}
%\Require {Scaffold specs: Generated pdb $\textrm{designed\_scaffold}$, motif placements $\{I_{m}\}$}
%\Require {Motif specification: bb coordinates for each segment $\{\vec x^\mathrm{motif}_{m,L_m, a}\}$,  chosen length $L$, restricted sequence $\{s^\mathrm{motif}_{m, l_m}\}$, restricted sequence positions $\{z_{m,l_m}\}$}
%\Require {Defaults: $N_\textrm{seqs}=8, \textrm{motif\_threshold}=1$\AA
%, $\textrm{sc\_threshold}=2$\AA, M=num motif segments}
\Procedure{testBackbone}{$\{\vec x_{l,a}^{\mathrm{design} }\},  \{I_{m}^{\mathrm{design}}\}, \{x^{\mathrm{motif}}_{m,l,a}\}, \{s^{\mathrm{motif}}_{m,l}\}, \{r_{m,l}^{\mathrm{motif}}\}$
%,
%N_{\mathrm{seq}}{=}8, 
%{\mathrm{motif\_threshold}=1\mathrm{\AA}},$
%\mathrm{sc\_threshold}=2\mathrm{\AA}$
}
%\Ensure{$y = x^n$}
%\Comment{the comment goes right-aligned to end of the previous line}
\LeftCommentOne{Fixed-backbone sequence design with motif sequence restricted}
    \If{designed\_scaffold has N-Ca-C-O atoms}
        \Comment{Use full-backbone \texttt{ProteinMPNN}}
        \State{$\{s_{n,l}\} \leftarrow$ \texttt{ProteinMPNN}(
        $\{\vec x_{l,a}^{\mathrm{design} }\}, 
        \{I_{m}^{\mathrm{design}}\}, \{s^\mathrm{motif}_{m,l}\}, \{r_{m,l}^{\mathrm{motif}}\})$}
        \Comment {$n \in \{1, \dots, 8\}$}
        \Else
        \Comment{Use C$\alpha$ only \texttt{ProteinMPNN}}
        \State{$\{s_{n, l}\} \leftarrow \texttt{CA-ProteinMPNN}(
        \{\vec x_{l,C\alpha}^{\mathrm{design} }\}, 
        \{I_{m}^{\mathrm{design}}\},\{s^\mathrm{motif}_{m,l}\}, \{r_{m,l}^{\mathrm{motif}}\}$)}
        \Comment {$n \{1,\dots, 8\}$}
    \EndIf
    \LeftCommentOne{Structure prediction}
    \State $\{\vec x_{n,l,a}^{\mathrm{pred}}  \} \leftarrow $ \texttt{ESMFold}$(\{s_{n,l}\})$ \Comment {$n \in \{1,\dots, 8\}$}

    \State
    \LeftCommentOne{Motif maintenance: compute motif RMSD across segments (C, C$\alpha,$ and N atoms)}
    \State $\{\vec x_{n, m, l, a}^{\mathrm{motif}, \mathrm{pred}} \} \leftarrow 
    \{\vec x_{n,I_m+l, a}^{\mathrm{pred}}\}$
    \Comment{$n\in\{1,\dots, 8\}, m\in\{1, \dots\}, a\in \{N, C\alpha, C\}$}
    \State $\textrm{motifRMSD}_n$ $\leftarrow$ \texttt{ComputeAlignedRMSD}$(
    \{\vec x_{n, m, l, a}^{\mathrm{motif}, \mathrm{pred}}\},
    \{\vec x^{\mathrm{motif},\mathrm{true}}_{m,l, a}\}
    )$
        \Comment {$n \in \{1, \dots, 8\}$}
    \State
    
    \LeftCommentOne{Scaffold validity: compute self-consistency RMSD (C$\alpha$ only)}
    \State $\textrm{scRMSD}_n$ $\leftarrow$ \texttt{ComputeAlignedRMSD}$(
    \{\vec x_{n, l, C\alpha}^{ \mathrm{pred}}\},
    \{\vec x^{\mathrm{design}}_{n,l, C\alpha}\})$
        \Comment {$n \in \{1, \dots, 8\}$}
    %\State $\textrm{success}_n$ =(scRMSD $<$ scRMSD\_threshold) \textbf{and} (motifRMSD $<$ motifRMSD\_threshold)
%\textrm{success}_n=\mathbf{True}$ for 
    \State
    \State successes $\leftarrow \{ n\  | \ \mathrm{motifRMSD}_n < 1$ \AA\  
    $ \mathbf{and}\ \mathrm{scRMSD}_n < 2$ \AA  \}
\If{successes =\{ \}}
    \Return  False%, None
\EndIf
%\State $n^* = \underset{n\in \textrm{successes}}{\textrm{argmin}} \{\textrm{motifRMSD}_n\}$
\State \Return  \textbf{True}%, $\{\vec x^{\mathrm{pred}}_{n^*, l, a} \}$
\EndProcedure
\end{algorithmic}
\end{algorithm}

\Cref{alg:test_scaffold} 
 relies on the Kabsch algorithm in two calls to \texttt{ComputedAlignedRMSD}.
 This algorithm is provided in \Cref{alg:compute_aligned_rmsd} of \Cref{sec:kabsch_alg}.
