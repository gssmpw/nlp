\begin{itemize}
    \item Quantum-readyというために、ソフトウェアレベルではQutntum algorithmと古典アルゴリズムの切り替えが容易にできると書いておく
    \item 実際に量子アルゴリズムを使った結果を載せるかどうかはちょっと今後の頑張り次第かな、、、
\end{itemize}

\section{Example usage of our software with quantum circuits}
\label{appendix:software}
QAQSインスタンスの初期化時に、solver引数として"qiskit"を与えればゲートで動くし、qiskitのバックエンドをibm\_quantumに変更すればQPUが使えます、という説明を例とともに書く。

\section{Experiments including soft-scoring}
\label{appendix:exp_original_impl}
元のQSQSの実装通りに実験したらどうなるかを記載する。

\section{Results of Discussion 5.2}
\label{appendix:discussion}
変更部分の数式的な説明と、実験結果を記載する。
Generalized IoU (GIoU) is defined as follows.
\begin{equation}
    GIoU(A, B) = IoU(A, B) - \frac{|C(A, B)\setminus A\cup B|}{|C(A, B)|},
\end{equation}
where $C(A, B)$ is the minimum convex hull that covers $A\cup B$.
従って、$GIoU(A, B)\leq 0$ならば$0$でクリップする、という処理は、IoU閾値を$\dfrac{|C\setminus A\cup B|}{|C|}$としてボックスの重なり判定を行うことと等価。
まとめると、$P_1$と$P_2$はそれぞれ以下のように定義される。
\begin{align}
    (P_1)_{ij} &= \left\{
        \begin{array}{cl}
            IoU(b_i, b_j) & \mathrm{if}~IoU(b_i, b_j) \geq \dfrac{|C(b_i, b_j)\setminus b_i\cup b_j|}{|C(b_i, b_j)|}\\
            0 & \mathrm{otherwise}
        \end{array}\right.\\
    (P_2)_{ij} &= \left\{
        \begin{array}{cl}
            \dfrac{|b_i\cap b_j|}{\sqrt{|b_i||b_j|}} & \mathrm{if}~IoU(b_i, b_j) \geq \dfrac{|C(b_i, b_j)\setminus b_i\cup b_j|}{|C(b_i, b_j)|}\\
            0 & \mathrm{otherwise}
        \end{array}\right.
\end{align}
$C\neqA\cup B$なら必ず$IoU(A, B)\leq GIoU(A, B)$なので、この修正によって得られる係数行列の方が元の係数行列よりも非ゼロ成分の数が等しいか少ない。従って、この修正によって係数行列の疎性が向上する。

% \clearpage
% 以下は載せないかもしれない。
% \section{予測ボックスサイズの統計について}

% \section{Implementation details of SSIM computation}
% C++のソースコードベースで、SSIMの実装に関する詳細を記述する。
% 基本的にConv2D関数を用いてSSIMを計算するsub-routineと、最初にboxごとの画素値の平均と標準偏差を計算しておく呼び出し元関数で構成されている。

% \begin{algorithm}
%     \caption{Divide-and-Conquer}
%     \label{algo:subroutine}
%     \begin{algorithmic}
%         \Require
%         \Ensure{$A:~n\times n$ matrix whose elements are SSIM} 
%         \If{The block is sufficiently small}
%             \State Compute SSIM for the current block using \cref{algo:ssim_gpu}.
%         \Else
%             \State{Divide current block into four small blocks}
%             \State{Execute \cref{algo:subroutine} for each block.}
%             \State{Merge computation results into a single matrix.}
%         \EndIf
%     \end{algorithmic}
% \end{algorithm}

% \begin{algorithm}
%     \caption{GPU-parallelized SSIM}
%     \label{algo:ssim_gpu}
%     \begin{algorithmic}
%         \Require{$X:~n\times C\times W\times H$ tensor of images}
%         \Ensure{$A:~n\times n$ matrix whose elements are SSIM} 
%         \State{$G\gets$ 2D gaussian filter}
%         \State{$\bm{\mu}\gets\mathrm{Conv2D}(X, G)$}\Comment{Compute the mean for each image patch defined by $G$.}
%         \State{$\bm{\sigma}\gets\mathrm{Conv2D}(X^2, G) - \bm{\mu}^2$}\Comment{Compute the standard deviation for each image patch defined by $G$.}
%         \State{$M_\mu\gets (\bm{\mu}.\mathrm{unsqueeze}(1) * \bm{\mu}.\mathrm{unsqueeze}(0)).\mathrm{view}(-1, C, W, H)$}\Comment{Compute product of mean for all pairs of images.}
%         \State{$M_X\gets (X.\mathrm{unsqueeze}(1) * X.\mathrm{unsqueeze}(0)).\mathrm{view}(-1, C, W, H)$}
%         \State{$Cov\gets\left(\mathrm{Conv2D}(M_X, G) - M_\mu\right).\mathrm{view}(n, n, C, W, H)$}\Comment{Compute covariance of all pairs of images.}
%         \State{$M_\mu\gets M_\mu.\mathrm{view}(n, n, C, W, H)$}
%         \State{$S_\mu\gets\bm{\mu}^2.\mathrm{unsqueeze}(1)+\bm{\mu}^2.\mathrm{unsqueeze}(0)$}
%         \State{$S_\mu\gets\bm{\sigma}^2.\mathrm{unsqueeze}(1)+\bm{\sigma}^2.\mathrm{unsqueeze}(0)$}
%         \State{$A\gets\left(\dfrac{2M_\mu+C_1}{S_\mu+C_1}\times\dfrac{2Cov+C_2}
%         {S_\sigma+C_2}\right).\mathrm{mean}(-1).\mathrm{mean}(-1).\mathrm{mean}(-1)$}\Comment{Compute SSIM averaged over channels, width, and height.}
%     \end{algorithmic}
% \end{algorithm}