\section{Appendix}

% \subsection{License}
% For the datasets in our experiments, HumanEval and LeetCode uses the MIT License,  All of these licenses allow their data for academic use.

\input{tables/compare_mathvista}
\subsection{Detail Results}
\label{sec:detail_results}
Table \ref{tab: mathvista} shows detailed experimental results for MLLMs on \benchmark and MathVista.



\subsection{Prompts}
\label{sec:prompt}
The prompts used are listed in Table \ref{tab:prompt_construction1}-\ref{tab:evaluation}.
\begin{table*}[htbp]
\centering
\captionsetup{justification=centering}
\begin{tabular}{p{\textwidth}}
\toprule
\underline{\textbf{\textsc{Prompt for Flowchart Construction and Test Cases Generation.}}} \\
\begin{minipage}{\textwidth}
\vspace{2mm}
\begin{minted}[fontsize=\small,breaklines=true]{markdown}

You are a helpful assistant. You need to complete the following tasks:
1.Given a problem and a code solution, use mermaid to draw a general flowchart with explicit inputs and outputs (the inputs and outputs need to be consistent with the code solution). The flowchart should depict the problem's requirements and code logic. The conditions for each path of the flowchart need to be written clearly. Note the syntax correctness of mermaid, such as the correct use of (), etc. For example, if there are special symbols in mermaid, you need to use "" to include, for example B[Input: x (integer)] is wrong, you need to use B["Input: x (integer)"]. The flowchart is enclosed with ```mermaid and ```.
    -The logic of the flowchart needs to be exactly the same as the code
    -If there is function nesting, display the nested functions as a subgraph
2.Design test cases to test the code. Test cases are presented in the form of assert statements. Test cases cover basic test cases, boundary test cases, and large number test cases. You must design at least three test cases for each category. The test cases are contained with ```python and ```.

<problem>
Palindrome Number
Given an integer x, return true if x is a palindrome, and false otherwise.


Example 1:

Input: x = 121
Output: true
Explanation: 121 reads as 121 from left to right and from right to left.
Example 2:

Input: x = -121
Output: false
Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
Example 3:

Input: x = 10
Output: false
Explanation: Reads 01 from right to left. Therefore it is not a palindrome.


Constraints:

-231 <= x <= 231 - 1
</problem>


<solution>
def isPalindrome(self, x: int) -> bool:
    if x < 0:
        return False

    reversed_num = 0
    temp = x

    while temp != 0:
        digit = temp % 10
        reversed_num = reversed_num * 10 + digit
        temp //= 10

    return reversed_num == x
</solution>

\end{minted}
\end{minipage} \\
\bottomrule
\end{tabular}

\caption{Prompt for Flowchart Construction and Test Cases Generation.}
\label{tab:prompt_construction1}
\end{table*}

\begin{table*}[htbp]
\centering
\captionsetup{justification=centering}
\begin{tabular}{p{\textwidth}}
\toprule
\underline{\textbf{\textsc{Prompt for Flowchart Construction and Test Cases Generation.}}} \\
\begin{minipage}{\textwidth}
\vspace{2mm}
\begin{minted}[fontsize=\small,breaklines=true]{markdown}
```mermaid
flowchart TD
    A[Start] --> B["Input: x (integer)"]
    B --> C{Is x < 0?}
    C -- Yes --> D["Output: False (negative numbers are not palindromes)"]
    C -- No --> E[Initialize reversed_num = 0, temp = x]
    E --> F{Is temp != 0?}
    F -- Yes --> G[Extract last digit: digit = temp % 10]
    G --> H[Update reversed_num: reversed_num = reversed_num * 10 + digit]
    H --> I[Update temp: temp = temp // 10]
    I --> F
    F -- No --> J{Is reversed_num == x?}
    J -- Yes --> K["Output: True (x is a palindrome)"]
    J -- No --> L["Output: False (x is not a palindrome)"]
```

```python
# Basic test cases
assert isPalindrome(121) == True  # palindrome
assert isPalindrome(-121) == False  # negative number, not a palindrome
assert isPalindrome(10) == False  # not a palindrome

# Boundary test cases
assert isPalindrome(0) == True  # smallest non-negative integer, palindrome
assert isPalindrome(9) == True  # single-digit number, palindrome
assert isPalindrome(-1) == False  # smallest negative number, not a palindrome

# Large number test cases
assert isPalindrome(123454321) == True  # large palindrome
assert isPalindrome(1000000001) == True  # large palindrome with zeros in the middle
assert isPalindrome(123456789) == False  # large non-palindrome
```

<problem>
%%%problem%%%
</problem>


<solution>
%%%solution%%%
</solution>

\end{minted}
\end{minipage} \\
\bottomrule
\end{tabular}

\caption{Prompt for Flowchart Construction and Test Cases Generation.}
\label{tab:prompt_construction2}
\end{table*}

\begin{table*}[htbp]
\centering
\captionsetup{justification=centering}
\begin{tabular}{p{\textwidth}}
\toprule
\underline{\textbf{\textsc{Prompt for Evaluation.}}} \\
\begin{minipage}{\textwidth}
\vspace{2mm}
\begin{minted}[fontsize=\small,breaklines=true]{markdown}
Generate code according to flowchart.
Note: If you're using a specific python package, you'll need to import it yourself. You don't need to use functions like input() to get input, just complete the python function.
Starter Code:
```python
%%%starter_code%%%
```
Present the code between ```python and ```.


\end{minted}
\end{minipage} \\
\bottomrule
\end{tabular}

\caption{Prompt for Evaluation.}
\label{tab:evaluation}
\end{table*}


\subsection{Cases}
\label{sec:cases}
Finally, as shown in Figure \ref{fig:case}, we select the problem from the Math subset and present the responses from four MLLMs. This problem has two flowcharts and puts higher demands on the capabilities of MLLMs.

Overall, GPT-4o and Llama-3.2-90B-Vision-Instruct provide correct answers, while MiniCPM-V-2\_6 and Claude-3-Haiku-20240307 gave incorrect ones. Upon careful analysis of the generated code, we can observe that GPT-4o correctly follows the logic depicted in the flowchart to generate the correct code. However, Llama-3.2-90B-Vision-Instruct did not follow the recursive logic as shown in the flowchart, instead using the dynamic programming algorithm. This is an interesting phenomenon, suggesting that Llama-3.2-90B-Vision-Instruct, after processing the flowchart, comprehends the problem that the algorithm in the chart is solving and provides a dynamic programming solution. This demonstrates that the model not only interprets the flowchart's surface meaning but also, to some extent, ``understands" the logical intent behind it.

As clearly shown in the bottom of Figure \ref{fig:case}, MiniCPM-V-2\_6 fails to generate fully correct code because the model omits two steps from the subgraph, although the other steps are correct, ultimately leading to an \texttt{AssertionError}. On the other hand, Claude-3-Haiku-20240307 fails to correctly identify the function variables in both the main and sub-functions and does not properly understand the execution flow of the code in the subgraph, ultimately leading to a \texttt{RecursionError}. This indicates that both models have poor image understanding and reasoning capabilities.
\input{figures/case}