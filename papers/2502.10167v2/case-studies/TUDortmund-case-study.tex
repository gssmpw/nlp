\subsection{Access Tracing and Data Processing Using Trace Writers}
\label{subsec:tudo}

\subsubsection{Overview}
\label{tudo:overview}
Emerging NVM technologies have the potential to complement or partially replace DRAM as main memory, but they face the challenge of wear-out over time.
If memory cell updates are unevenly distributed, heavily updated memory bits can wear out prematurely, reducing the overall capacity and lifespan of the memory. In the worst case, the memory will fail when the first cell is fully worn out. To mitigate this issue, wear-leveling techniques are essential.
There exists a wide variety of various wear-leveling approaches on hard- and software-level~\cite{yang:2007, PageWL, CacheWL, Loop2RecWL, hoelscher:2022, HeapStackWL, Stack, HeapWL}.
The data-comparison write scheme~\cite{yang:2007} is a hardware-based technique that reduces unnecessary write operations. The memory cell is only updated when the target value differs from the one currently stored. For most NVMs, wear is only induced by writing but for some technologies, such as FeRAM~\cite{philofsky:1996}, it can also be inflicted when reading.
Software-based wear-leveling solutions can be better tailored to the application's needs by focusing on important memory regions or reacting to specific access patterns. Usually, such solutions involve more spatial and computational overhead compared to hardware-based solutions but they might be applied when a suitable hardware-solution does not exist.



While many wear-leveling solutions have gained popularity, their evaluations often lack depth. In our previous work \cite{hoelscher:2023}, we built on the toolchain presented in this paper to develop a new wear-analysis method that provides a detailed assessment of NVM wear-out at a single-bit granularity.
This approach tracks the number of bit flips per memory cell during an application’s simulation, as bit flips are directly proportional to wear. The collected data is then recorded in a trace for further analysis, applying metrics that provide insights into how applications induce different degree of wear on NVM. 
This detailed wear analysis helps refine and optimize wear-leveling strategies while making previously in-house evaluation methods more comparable.

Besides  wear-out analyses, the simulation toolchain described in this study can provide insights into many aspects of memory behavior. For example, it may monitor library usage patterns \cite{hakert:2020:split} and examine read access patterns \cite{hakert:2022}.  This may be used to assess cache replacement policies, debug and profile workloads, and discover abnormal memory access patterns or security risks such as side-channel attacks.
In summary, the cycle-accurate full-system simulation provides information beyond wear-out patterns, making the trace writer a very useful tool for broader system research.


\subsubsection{Objective}
\label{tudo:objective}
In this case study, we want to familiarize the reader with NVMain2.0's trace writing capabilities, enabling them to utilize these to their full extent for various use cases. To this end, we provide step-by-step instructions that guide the reader through the creation of a new trace writer. We cover a) the creation of a basic trace writer skeleton and its integration into the toolchain's build process, b) basic logging functionality and available simulation information, and c) processing during tracing for additional information and further analysis.











\subsubsection{Step-By-Step Instructions}
\label{subsubsec:tud-instructions}
In this section, we guide the reader iteratively through the creation of a new trace writer in NVMain2.0, such that they can set up a suitable instance for their respective use case. Given the root directory \texttt{NVM\_Simulation} of the toolchain's repository, all paths mentioned in this section are relative to \texttt{NVM\_Simulation/simulator/nvmain/traceWriter/}.


~\noindent \textbf{Skeleton and Build Integration:}\\
For any use case, a trace writer's general setup remains the same. First, we show how to create a basic trace writer skeleton and integrate it into the toolchain's build process. Start by creating a class for the \emph{TutorialTraceWriter} (\texttt{*.h/*.cpp)} that inherits from the base class \texttt{NVM::GenericTraceWriter}. The base class is provided by NVMain2.0 for custom trace writers to ensure an interaction with the simulation is possible, i.e., known hook-functions that can be called regularly by the simulation are present. Declare the functions shown in \cref{lst:skeleton} in the \emph{TutorialTraceWriter}'s header file.
\begin{lstlisting}[caption={Trace Writer Skeleton},label=lst:skeleton,language=c++,basicstyle=\ttfamily\scriptsize]
class TutorialTraceWriter : public NVM::GenericTraceWriter {
    public:
        virtual ~TutorialTraceWriter() = default;
        virtual bool SetNextAccess(NVM::TraceLine *nextAccess) override;
        virtual std::string GetTraceFile() override;
        virtual void SetTraceFile(std::string file) override;

    private:
        std::ofstream traceFile;
        std::string traceFileAddress;
    };
\end{lstlisting}
Additionally, include the variables shown in \cref{lst:skeleton}. They will store the resulting trace file's address as well as provide an output-file-stream required for the actual logging. The inherited function \texttt{GetTraceFile()} and \texttt{SetTraceFile()} are mandatory for NVMain2.0 to create the trace file in the first place. Define them in the trace writer's source file as shown in \cref{lst:getset}.
\begin{lstlisting}[caption={Getter/Setter Definition},label=lst:getset,language=c++,basicstyle=\ttfamily\scriptsize]
std::string TutorialTraceWriter::GetTraceFile() {
    return traceFileAddress;
}

void TutorialTraceWriter::SetTraceFile(std::string file) {
    traceFileAddress = file;
    traceFile.open(traceFileAddress.c_str());

    if (!traceFile.is_open()) {
        std::cout << "File could not be opened!" << std::endl;
    }
}
\end{lstlisting}

With the fundamental functions in place, the trace writer needs to be integrated into NVMain2.0's build process. For this, add all source files to the \texttt{SConscript}. It is part of SCons~\cite{scons}, the build system at hand, which lists all source files to consider when building. Furthermore, since NVMain2.0 uses the factory pattern~\cite{ellis:2007} to handle client code, the \emph{TutorialTraceWriter} needs to be added to the \texttt{TraceWriterFactory}'s source file. For both, stick to the practice of the current implementation in place. Finally, the system's configuration needs to be adapted. Open the NVM's configuration file that is to be used for your simulation, i.e., any \texttt{.../Config/*.config}. It contains the key parameters that specify the NVM's behavior. However, it is also used to configure the trace writer that will be used during the application's simulation, where three entries need to be modified. These are \texttt{PrintPreTrace}, allowing to toggle the trace writer's usage, \texttt{PreTraceFile}, specifying the resulting trace file's name, and \texttt{PreTraceWriter}, which indicates the trace writer that is to be used. Toggle the usage to \texttt{true}, set a trace file name and select the \emph{TutorialTraceWriter}. This concludes the skeleton's setup, which now can be built upon with meaningful logging behavior.


~\noindent \textbf{Logging Functionality:}\\
To enable logging, the trace writer provides an output-file-stream through which content can be put to the resulting trace. In context of these step-by-step instructions, the variable that stores the stream is \texttt{traceFile}, which you have added when setting up the trace writer skeleton. When the simulation is started, the output-file-stream will be opened and it can be written to with standard C++ I/O-stream operations. To get started with logging, go ahead and use the trace writer's destructor to put "Hello World" to the resulting trace. See \cref{lst:helloworld} for comparison. Build the toolchain, which is required because the modified trace writer needs to be compiled, and run the simulation as described in appendix~\cref{app:setup} using the \emph{helloworld}-benchmark. Check if you got the desired results.
\begin{lstlisting}[caption={Hello World},label=lst:helloworld,language=c++,basicstyle=\ttfamily\scriptsize]
TutorialTraceWriter::~TutorialTraceWriter() {
    traceFile << "Hello World" << std::endl;
}
\end{lstlisting}

Knowing how to add to the resulting trace, we move to modify the \emph{TutorialTraceWriter} such that it logs meaningful information on the simulated application. When simulating, the function \texttt{SetNextAccesss()} is called with every access to the NVM. All information on the access are passed to the function in form of \texttt{TraceLine} objects. By default, these objects contain information on:
\begin{itemize}
    \item The targeted physical address of memory the memory access (\texttt{GetAddress().GetPhysicalAddress()})
    \item The type of memory access, e.g., read or write (\texttt{GetOperation()})
    \item The data that will be put to / read from the memory address (\texttt{GetData()})
    \item The current cycle (\texttt{GetCycle()})
    \item The thread identification (\texttt{GetThreadId()})
\end{itemize}
In our previous work~\cite{hakert:2020:split}, we have modified the toolchain to additionally provide information on the current program counter. Knowing the application's memory layout, i.e., where the individual libraries are placed in the \texttt{.text}-section (see \cite{hakert:2020:split} for details), it allows to identify which part of the application has caused the respective memory access. You can access this information with \texttt{get\_program\_counter()}\footnote{
Requires to enable the bit flips simulation extension. See appendix~\cref{app:setup} for details.
}.

To complete this step of the instructions, go ahead and put some information available on the memory access to the resulting trace. We propose to log the access' targeted physical memory address, its operation and the last byte of the data that is to be read or written. Stick with the format \texttt{"Address | Operation | Data"}. Doing so should modify the function \texttt{SetNextAccess()} to look similar to \cref{lst:basiclog}~\footnote{
The function needs to return \texttt{true} to indicate that the memory access was handled correctly.
}

\begin{lstlisting}[caption={Basic TraceLine Logging},label=lst:basiclog,language=c++,basicstyle=\ttfamily\scriptsize]
bool TutorialTraceWriter::SetNextAccess(NVM::TraceLine *nextAccess) {
    const OpType operation = nextAccess->GetOperation();
    std::string opString;

    if(operation == NVM::READ) {
        opString = "READ";
    } else if(operation == NVM::WRITE) {
        opString = "WRITE";
    } else {
        opString = "OTHER";
    }

    traceFile << std::hex << nextAccess->GetAddress().GetPhysicalAddress() << std::dec << " | ";
    traceFile << opString << " | ";
    traceFile << static_cast<uint64_t>(nextAccess()->GetData().GetByte(0));

    return true;
}
\end{lstlisting}

~\noindent \textbf{Processing During Tracing:}\\
Simply logging available information, as shown previously, can be useful, but for some use cases, it may not be sufficient. In addition to storing data placement in the resulting trace, the trace writer can process memory access information to prepare the trace for further analysis or generate additional insights.
For example, in our previous work \cite{hoelscher:2023}, we compared the old content of accessed memory addresses to their new values and recorded the number of bit flips per memory cell. At the end of the simulation, the recorded data was stored in the trace as a histogram.

Specifically for NVM simulation, processing simulation data can be particularly useful for wear-leveling development and optimization. This approach allows evaluating wear-leveling techniques by simulating their impact on memory accesses without requiring modifications to complex structures, such as an operating system service. Additionally, hardware-based solutions can be assessed using a trace writer before investing in prototype development, enabling early-stage validation and refinement.

To provide a concrete example of what’s possible, we create an example trace writer that tracks NVM  per block.
Let's start by creating a fresh trace writer skeleton. Then, define a map that associates each block index with an integer value. For the sake of this example, use blocks of size 4KB. Next, within the function \texttt{SetNextAccess()}, check whether each memory access is a write operation. If it is, determine the affected block and increment its recorded access count by one.
Finally, to store the recorded data in the trace file at the end of the simulation, write the map to the trace writer’s destructor using the format \texttt{“Index | Accesses”}. Refer to \cref{lst:blockAccesses} for comparison.


\begin{lstlisting}[caption={Trace Block Accesses},label=lst:blockAccesses,language=c++,basicstyle=\ttfamily\scriptsize]
/*
 * Variables accessMap and blockSize are defined in the header file.
 * The blockSize in the example is 4KB.
 */

TutorialTraceWriter::~TutorialTraceWriter() {
    for(auto entry : accessMap) {
        traceFile << entry.first << " | " << entry.second << std::endl;
    }
}

bool TutorialTraceWriter::SetNextAccess(TraceLine *nextAccess) {
    if(nextAccess->GetOperation() == NVM::WRITE) {
        accessMap[nextAccess->GetAddress().GetPhysicalAddress() / blockSize]++;
    }

    return true
}
\end{lstlisting}


The toolchain’s repository includes two additional exercises on creating a new trace writer. For more details, please refer to Appendix~\cref{app:tudo:exercises}.



\begin{insightbox}
In this case study, we guide the reader on integrating a basic trace writer into NVMain2.0, enabling them to perform basic logging operations on the application's behavior. In addition, we show how the trace writer can be used to process simulation data for additional insight, promoting its versatility for development and analysis.
\end{insightbox}