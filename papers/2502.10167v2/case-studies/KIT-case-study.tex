\subsection{Compute-in-Memory (CiM)} \label{sec:nvm-cim}


\subsubsection{Overview}

Modern computing systems predominantly rely on the von Neumann architecture \cite{kit1}, where the CPU handles data processing and memory components are dedicated to storage \cite{kit2}. This design results in frequent data transfers between the CPU and memory, causing significant energy consumption and performance bottlenecks, collectively known as the ``memory wall.'' These transfers account for up to 60\% of system energy use, with memory access consuming far more energy than computational operations \cite{kit3,kit4,kit5}. Additionally, DRAM faces scaling limitations, with its capacity growth lagging behind increases in processing power, partly due to the shrinking reliability of DRAM cells \cite{kit/dramScale1,kit/dramScale2,kit/dramScale3}.

The Compute-in-Memory (CiM) architecture has emerged as a viable solution to reduce the energy cost of data movement. By bringing processing capabilities closer to the data, CiM reduces reliance on the CPU \cite{kit/ext1,kit/ext2,kit/ext3}. These architectures range from minimal hardware changes for simple operations, such as bulk data manipulation, to more complex designs integrating processing cores near memory arrays. While the latter supports a wide range of applications, challenges such as design complexity, frequent CPU interactions, and task-offloading inefficiencies limit their practicality \cite{kit/ext2}. Simplified CiM designs, focusing on specific applications, reduce information exchange with the CPU and ease programming challenges, making them ideal for parallelizable tasks like DNA sequencing \cite{kit/dna1,kit/dna2, hameed_tetc21}, image processing \cite{kit/img1,kit/img2}, and database operations \cite{kit/db1,kit/db2}.
As advanced memory technologies that tightly couple memory with logic units have entered mass production (e.g., HBM \cite{kit/hbm} and HMC \cite{kit/hmc}), CiM is the industry's next frontier~\cite{khan_cimlandscape_2024}.

However, current research has mostly focused on SRAM-based and DRAM-based CiM architectures, leaving a gap in tools for NVM-based CiM design and evaluation. NVMs, as discussed in \cref{sec:Introduction}, offer significant advantages such as reduced static power leakage, no need for data refreshing, and improved scalability. These properties make NVMs particularly promising for CiM, where energy efficiency and scalability are critical \cite{kit/ext1,kit/ext4}. NVM like ReRAM has resistive properties that enable efficient analog-based MAC and Boolean computations with minimal hardware modifications.


Recent advancements in NVM-based CiM modules demonstrate their potential for practical implementations. Leading foundries, including TSMC, Samsung, and IBM, have fabricated CiM modules using ReRAM, STT-MRAM, and PCM. For instance, TSMC has integrated ReRAM and STT-MRAM into CiM designs for neural network acceleration \cite{kit/stt-tsmc1,kit/reram-tsmc4}, while Samsung and IBM have demonstrated CiM modules using STT-MRAM and PCM \cite{kit/pcm-ibm3,kit/stt-samsung2}, respectively. These developments showcase the ability of NVM-based CiM architectures to address the performance and energy limitations of traditional computing systems, highlighting their potential to enable more efficient and scalable designs.



\subsubsection{Objective}

Existing CiM simulators, such as CIM-SIM \cite{CIM-SIM}, MNSIM \cite{MNSIM}, NeuroSiM \cite{NEUROSIM}, PiMulator \cite{PiMulator}, MultiPIM \cite{MultiPIM}, Sim2PIM \cite{Sim2PIM}, and PIMSim \cite{PIMSim}, offer capabilities like full-system simulation, reconfigurable technology and architecture, and cycle-accurate modeling.
However, our CiM extension is the first to integrate all these features specifically for NVM.
Designed with detailed modeling, modularity, and extensibility,
our extension prioritizes realistic design choices to ensure practical applicability in real-world scenarios.
The following subsections provide an in-depth exploration of these features.


\subsubsection{Methodology}

To gain a deeper understanding of the proposed CiM extension, we begin by discussing the general design choices, the available alternatives, and the reasoning behind these decisions. This approach helps readers comprehend the requirements for practical architectural design while enabling them to identify potential improvements and trade-offs. Subsequently, we provide a detailed implementation guide for the gem5 framework in the following subsections.

\textbf{CiM vs. PIM:}
A central distinction in this design is between CiM and PIM (Processing-in-Memory). PIM integrates processing cores near memory to support diverse applications but faces challenges such as complex design, frequent CPU data exchanges, and system support issues (e.g., coherency mechanisms and task-offloading granularity)  \cite{kit/ext1,kit/ext4,kit/ext5,kit/ext7}.
CiM, by contrast, focuses on minimal modifications to the memory periphery for specific tasks like bulk bitwise operations or data copying \cite{kit/rowclone}. This narrower scope simplifies programming, reduces CPU interaction, and enables a streamlined design. Additionally, CiM leverages the unique resistive properties of NVM for efficient analog computations, such as MAC and Boolean operations \cite{kit/ext4,kit/ext5,kit/ext8}, using simple crossbar circuitry modifications. This design resembles SIMD cores with much larger register sizes (equivalent to a memory bank’s row), making CiM highly efficient for parallelized, data-intensive applications.

\textbf{CPU-CiM Communication:}
This can be implemented in two ways:
\CRicon{1} Custom Instructions and \CRicon{2} Memory-Mapped I/O. While the The first approach is well-suited for accelerators closely connected to the CPU core. However, it requires significant CPU modifications (e.g., pipeline and control logic changes) and is tied to specific ISAs, which limits compatibility.
The second approach maps the CiM module’s physical address space into the virtual address space of applications. While it introduces communication delays due to OS involvement, it avoids the design challenges of custom instructions and is more flexible, making it the preferred choice in this case.

\textbf{Physical Placement of CiM Components:}
A critical design decision for CiM components is their physical placement within the main memory module, which consists of multiple memory chips. While integrating CiM circuitry directly into each chip allows for parallel processing of simple operations like logical AND, it faces challenges with operations like logical shifts that require contiguous data. Modeling CiM as a separate chip adjacent to memory chips addresses some issues but introduces power, latency, and communication protocol challenges due to the DDR interface’s lack of dedicated signal lines. Despite these trade-offs, using LRDIMM (Load-Reduced Dual In-Line Memory Module) modules, commonly found in server applications, offers a practical solution. LRDIMMs enhance signal integrity, reduce system modifications, and provide added benefits like error correction and improved simulation flexibility, making them ideal for CiM integration.

Finally, memory controllers, which are highly complex and integrated into modern CPUs, present a unique challenge for CiM implementation. Modifying these controllers requires careful consideration to avoid performance bottlenecks or compatibility issues. Proposals involving such changes must carefully balance hardware and software implications.
As with other extensions discussed in this article, we utilize the gem5 framework \cite{kit/gem5-1,kit/gem5-2} for modeling and simulation purposes.
\cref{kit:fig1a} shows a simplified X86 system where minimal changes are required for CiM integration. Only a few components within the LRDIMM module are modified, while the CPU-integrated memory controller and memory chips remain unchanged.

\begin{figure}[ht]
	\centering
	\begin{minipage}[c]{0.4\textwidth}
		\centering
		\includegraphics[width=\textwidth, page=1]{KIT-figures/mainSys.pdf} 
		\caption{x86 with CiM-capable memory}
		\label{kit:fig1a}
	\end{minipage}
	\hfill
	\begin{minipage}[c]{0.49\textwidth}
		\centering
		\includegraphics[width=\textwidth, page=2]{KIT-figures/mainSys.pdf} 
		\caption{Structure of the CiM chip}
		\label{kit:fig1b}
	\end{minipage}
\end{figure}


\subsubsection{Step-by-Step Instructions}\label{kit/label1}

This subsection discusses the programming model for the CiM extension, provides examples and supported operations, and concludes with a brief discussion on how it is enabled in gem5. The CiM extension operates similarly to a SIMD core, with CiM rows acting as registers and supporting only simple operations on column-aligned data. A CiM-capable chip resembles a conventional memory chip with modifications to row decoders (`\texttt{Dec.}', for multi-row activation) and sense amplifiers (`\texttt{SA}', for multi-reference voltages), as illustrated in \cref{kit:fig1b}. Simple operations, like bitwise AND, are performed by simultaneously activating rows and applying the appropriate reference voltage across the sense amplifiers.
To support more complex operations, CMOS-based CiM Logic is added after the column selector multiplexer, enabling tasks like bitwise NOT. Input signals for these units are managed by a state machine in the CiM controller, which processes commands from user applications. As illustrated in \cref{kit/fig2}, a NAND operation involves activating operand rows for a parallel AND (step \CRicon{1}), loading results into the CiM Logic for a NOT operation (steps \CRicon{2} to \CRicon{3}), and storing the final results back into memory (step \CRicon{4}). \cref{kit/lst1} shows the implementation of the NAND operation in a user application with the help of CiM API.
To provide a practical example that includes both a loop and a conditional statement, \cref{kit/lst2} presents a sequential \texttt{for} loop in regular C++ code that uses the ternary operator (`\texttt{?:}'), and \cref{kit/lst3} shows the conversion of this code into the CiM version, with the loop unrolled.

\begin{figure}[h]
	\centering
	\includegraphics[width=0.195\linewidth, page=1]{KIT-figures/steps.pdf}
	\includegraphics[width=0.195\linewidth, page=2]{KIT-figures/steps.pdf}
	\includegraphics[width=0.195\linewidth, page=3]{KIT-figures/steps.pdf}
	\includegraphics[width=0.195\linewidth, page=4]{KIT-figures/steps.pdf}
	\includegraphics[width=0.195\linewidth, page=5]{KIT-figures/steps.pdf}
	\caption{Steps required to perform a NAND operation.}
	\label{kit/fig2}
\end{figure}


\cref{kit-tb1} lists the essential operations implemented in the CiM extension. We have applied these operations to several real-world applications, including the following:
\CRicon{1} BitIndexing (BIT)\cite{kit/app1}: Bitmap-formatted database queries are ORed together, and the results are ANDed with another query.
\CRicon{2} BLASTN algorithm (BLS)\cite{kit/app2}: Used for searching short DNA sequences within large DNA or protein sequences.
\CRicon{3} Morphological Image Processing (MIP)\cite{kit/app3}: Implementation of Dilation and Erosion algorithms with binary-coded input images of various filter sizes.
\CRicon{4} Marching Squares (MSQ)\cite{kit/app4}: An algorithm designed to extract contour lines from 2D images.
\CRicon{5} Shifted Hamming Distance (SHD)\cite{kit/app5}: A well-known algorithm for calculating edit distances in short DNA sequences.
\CRicon{6} BitWeaving (BWV)\cite{kit/app6}: A technique developed for efficiently scanning database queries in memory.
These applications are categorized as \textit{Embarrassingly Parallel} \cite{kit/emb}, making them well-suited for CiM implementation.
Other operations, such as MAC for binarized vector-to-matrix multiplication, are also included in the source files to support the implementation of simple neural network applications.
Users can refer to the provided application examples, CiM API code and documentation, as well as other modules, such as OS drivers offered by the CiM API, to gain a better understanding of CiM implementation.


\begin{table}[h]
	\caption{Essential operations supported by the CiM extension.}
	\label{kit-tb1}
	\begin{tabular}{@{}ccccc@{}}
		\toprule
		Operation Type                                                                                     &
		Operation                                                                                          &
		Source                                                                                             &
		Destination                                                                                        &
		Description                                                                                                                               \\ \midrule
		In Memory Array                                                                                    &
		\texttt{AND, OR, XOR}                                                                              &
		A List of Rows                                                                                     &
		\begin{tabular}[c]{@{}c@{}}A Single Row\\ (Default: \texttt{SA} output)\end{tabular}                        &
		Perform bitwise operation                                                                                                             \\ \midrule
		\multirow{2}{*}[-6pt]{In CMOS Periphery}                                                           &
		\texttt{COPY}                                                                                      &
		\multirow{2}{*}[-6pt]{\begin{tabular}[c]{@{}c@{}}A Single Row\\ (Default: \texttt{SA} output)\end{tabular}} &
		\multirow{2}{*}[-6pt]{A Single Row}                                                                &
		\begin{tabular}[c]{@{}c@{}}Copies row content\\ Optional: bitwise rotation\end{tabular}                                               \\ \cmidrule(lr){2-2} \cmidrule(l){5-5}
		                                                                                                   &
		\texttt{NOT\_COND}                                                                                 &
		                                                                                                   &
		                                                                                                   &
		\begin{tabular}[c]{@{}c@{}}Performs bitwise NOT\\ Or vector mask operation.\end{tabular}                                              \\ \midrule
		\multirow{2}{*}[-3pt]{\begin{tabular}[c]{@{}c@{}}In CiM Controller\\ Or DMA-Related\end{tabular}}        &
		\texttt{copy\_to\_cim}                                                                             &
		A pointer to a vector                                                                              &
		CiM row number                                                                                     &
		\multirow{2}{*}[-3pt]{\begin{tabular}[c]{@{}c@{}}Copies vector to/from a CiM row\\ If DMA:  Main Memory $\leftrightarrow$ CiM\end{tabular}} \\ \cmidrule(lr){3-4}
		                                                                                                   &
		\texttt{copy\_to\_cpu}                                                                             &
		CiM row number                                                                                     &
		A pointer to a vector                                                                              &
		\\ \bottomrule
	\end{tabular}
\end{table}

To summarize, \cref{kit/fig3} illustrates the modifications made to the gem5 framework to enable the CiM extension. The only alterations to the gem5 codebase involve the \texttt{AbstractMemory} class, which has been adapted to monitor interactions with the CiM address space, and the \texttt{MemInterface} class, which has been updated to adjust the access time for any request associated with the CiM address space. The \texttt{CiMHandler} class serves as the primary component responsible for managing CiM commands. It accomplishes this by interpreting opcodes, configuring the state machine, assigning appropriate timing, and ultimately invoking the relevant operation function via the \texttt{CiMOperationInterface}.
The \texttt{CiMOperationInterface} acts as the base class for all CiM operations, providing a pure functional implementation. This class can be extended to incorporate detailed modeling or fault injection capabilities (e.g., the \texttt{CiMFaultInjection} class, as shown). Most parameters can be configured through the gem5 simulation configuration file, allowing users to select among different technologies or specify various timing values. Additionally, users can extend the source code by overriding the provided functions.
Finally, as with the previous extensions discussed in this article, either the `\texttt{CDNCcim=1}' or `\texttt{CDNCcimFS=1}' flag must be specified during the gem5 compilation process, depending on the desired simulation mode (system emulation/full-system simulation mode), to enable the CiM extension.
Detailed steps for setting up and running the CiM extension are provided in the Appendices section.


\begin{figure}[h]
	\centering
	\includegraphics[width=0.8\linewidth, page=3]{KIT-figures/mainSys.pdf}
	\caption{Summary of modifications, contributions, and communications regarding the CiM extension in gem5.}
	\label{kit/fig3}
\end{figure}

\begin{insightbox}
	This case study provides a comprehensive guide to the practical realization of CiM, highlighting key challenges and offering researchers clear directions for getting started.
	Our CiM extension stands out by combining full-system simulation, flexible technology and architecture, and detailed circuit modeling, specifically targeting NVM technologies.
	It focuses on accuracy, reconfigurability, and expandability, enabling realistic design decisions and facilitating hardware/software design-space exploration for CiM applications.
\end{insightbox}
