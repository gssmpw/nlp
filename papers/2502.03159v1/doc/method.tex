\section{PICBench}
\label{sec:method}
In this section, we will first present an overview of our PICBench framework and then introduce the details.

\subsection{Framework}
\Cref{fig:flow} illustrates PICBench's flow: user provides a natural language description of their PIC design task to the LLM. 
The LLM’s output, a simulation-ready netlist, is then directly fed into SAX for simulation.
If the simulation tool reports errors, the tool’s outputs are returned to the LLM as a new prompt with a request to rectify the errors. Simultaneously, the error information is reviewed and summarized into restrictions by human inspection, which are then incorporated into the initial system prompt. 
If the simulation tool successfully generates a frequency response, PICBench tests the functionality of the generated design by comparing it with the golden results. 
The process terminates when both syntax and functionality tests are passed.
Otherwise, the process iterates up to a user-specified number of trials.

% \begin{figure*}[!tb]
%     \centering
%     \subfloat{%
%       \includegraphics[width=0.95\textwidth]{fig/framwork.pdf}
%       }
%       \caption{PICBench framework that automated design generation and evaluation. Users only need to provide their problem descriptions.}
%       \label{fig:flow}
% \end{figure*}

\subsection{Detail Description of Our Benchmark}
PICBench collects 24 meticulously crafted, commonly encountered PIC design problems, spanning a wide range of design complexities and scales. 
\Cref{tab:tb_des} shows the detailed description of all 24 problems provided in our benchmark, including 6 optical computing circuits, 7 optical interconnects circuits, 9 optical switches, and 2 fundamental devices.
These problems exhibit significant variation in their target functionalities, including examples such as optical switches, optical modulators, and more.
In addition to the diverse functionalities, our benchmark also exhibits rich variation in the implementation. 
For instance, optical switches in our benchmark share the common functionality of switching signal connections. 
However, we include all widely used architectures of optical switches, such as crossbar, Spanke, Benes, and Spanke-Benes, with configurations ranging from $4 \times 4$ to $8 \times 8$.
Notably, we do not include any purely device-level design problems in our collection, as these lack connections, and the components section in each netlist inherently addresses device-level designs.
The foundational devices we include are not simple device components. 
They involve connections among more than two components and can serve as the basis for constructing more complex circuits.

\begin{table*}[htb!]
    \centering
    \renewcommand{\arraystretch}{1.2}
    \caption{Benchmark Description}
    \label{tab:tb_des}
    \resizebox{\textwidth}{!}{ 
    \begin{tabular}{llcc}
        \toprule
        \multicolumn{2}{c}{\textbf{Design}}& \textbf{Description} \\
        \midrule
        \multirow{7}{*}{\textbf{Optical Computing}} 
         & Clements\_$4 \times 4$ & A $4 \times 4$ MZI mesh arranged using the Clements method \\
         & Clements\_$8 \times 8$ & An $8 \times 8$ MZI mesh arranged using the Clements method \\
         & Reck\_$4 \times 4$ & A $4 \times 4$ MZI mesh arranged using the Reck method \\
         & Reck\_$8 \times 8$ & An $8 \times 8$ MZI mesh arranged using the Reck method \\
         & NLS & A Non-Linear Sign gate with a signal channel and two additional ancilla channels \\
         & U-matrix block & A fundamental block representing a $2 \times 2$ unitary matrix of arbitrary values \\
         \midrule
         \multirow{7}{*}{\textbf{Optical Interconnects}} \
         & Direct modulator& An optical direct modulator  \\
         & QPSK modulator & An optical QPSK modulator  \\
         & 8-QAM modulator& An optical 8-QAM modulator \\
         & 64-QAM modulator& An optical 64-QAM modulator  \\
         & WDM\_mux & A WDM multiplexer \\
         & WDM\_demux & A WDM demultiplexer \\
         & Optical hybrid & A 90$^{\circ}$ optical hybrid\\
         \midrule
         \multirow{9}{*}{\textbf{Optical Switch}} 
         & OS\_$2 \times 2$ & A fundamental $2 \times 2$ optical switch\\
         & Crossbar\_$4 \times 4$ & A $4 \times 4$ optical switching network based on Crossbar architecture \\
         & Crossbar\_$8 \times 8$ &  An $8 \times 8$ optical switching network based on Crossbar architecture  \\
         & Spanke\_$4 \times 4$ &  A $4 \times 4$ optical switching network based on Spanke architecture \\
         & Spanke\_$8 \times 8$ & An $8 \times 8$ optical switching network based on Spanke architecture \\
         & Benes\_$4 \times 4$ & A $4 \times 4$ optical switching network based on Benes architecture \\
         & Benes\_$8 \times 8$  & An $8 \times 8$ optical switching network based on Benes architecture  \\
         & Spanke–Benes\_$4 \times 4$  & A $4 \times 4$ optical switching network based on Spanke–Benes architecture  \\
         & Spanke–Benes\_$8 \times 8$ &  An $8 \times 8$ optical switching network based on Spanke–Benes architecture \\
         \midrule
         \multirow{2}{*}{\textbf{Fundamental Devices}} 
         & MZM & A Mach-Zehnder modulator\\
         & MZI\_ps & A Mach-Zehnder interferometer with a phase shifter \\
        \bottomrule
    \end{tabular}
    }
\end{table*}

For each design, we provide three key components: a detailed problem description, the correct design, and its corresponding frequency response.
The problem description is a natural language description of the desired circuit functionality, including the required configurations and the number of input and output ports, as illustrated in \Cref{fig:problem_des}, which provides an example of the MZI\_ps problem.
\begin{figure}[!tb]
    \centering
    \subfloat{%
      \includegraphics[width=0.48\textwidth]{fig/Problem_Description.pdf}
      }
      \caption{Example of problem description.}
      \label{fig:problem_des}
\end{figure}
% To ensure the correctness and reliability of the problem description, human designer is tasked with generating corresponding designs based on these descriptions. 
% If the description is unambiguous and allows for the correct design to be accurately created, it is considered valid and the manually created correct design is regarded as the golden solution for evaluation.
Human designers then manually craft the correct design based on the description, producing golden solution for evaluation.
To streamline the evaluation process, the correct design is subsequently fed into the simulator, and its frequency response is directly saved. 
This frequency response serves as a reference for verifying the correctness of the design’s functionality.

\subsection{Code Generation and Evaluation}
\label{sec:code_gen_eval}
Since the netlist required by SAX does not follow a general format, we designed a system prompt template to maximize the efficiency of instructing LLMs to generate high-quality, error-free designs. 
As shown in \Cref{fig:sys_prompt}, the template consists of three components: 
\begin{enumerate}
    \item {\textbf{Required format}:} This part provides the schema for the required format. It defines the structure of the netlist to ensure compliance with SAX's requirements.
    \item {\textbf{API document}:} This part includes detailed documentation of the built-in components provided by SAX or defined by us. It specifies port definitions and configurable parameters, offering a comprehensive reference for implementing various components within the netlist.
    \item {\textbf{Restrictions}:} This part establishes a set of clear restrictions designed to standardize and streamline the generation of netlist JSON content.
\end{enumerate}

% By adhering to these guidelines, the generation process ensures consistent and logical outputs, maintaining high levels of professionalism and clarity. 
This structured approach promotes uniformity across all generated netlists, minimizes errors and ambiguity, and ensures that the outputs are both precise and efficient.

\begin{figure}[!tb]
    \centering
    \subfloat{%
      \includegraphics[width=0.48\textwidth]{fig/System_Prompt.pdf}
      }
      \caption{System prompt template for code generation.}
      \label{fig:sys_prompt}
\end{figure}

Once the design is successfully generated, its evaluation is automatically conducted, focusing primarily on two aspects: syntax and functionality.

Syntax correctness is the most fundamental requirement for ensuring logical functionality and executable code, as functionality cannot be assessed without first confirming syntactic validity. 
To verify syntax, the design is tested using the SAX simulator. 
If no errors are detected and a frequency response is successfully generated, the syntax is considered valid.

Functionality correctness is also evaluated through simulation to determine whether the generated design performs as expected.
However, unlike traditional testbenches used in RTL design \cite{lu2024rtllm}, where specific input signals are crafted to verify the correctness of outputs, our simulations are conducted in the frequency domain.
In this context, the input corresponds to a range of frequencies rather than discrete signals, and the response at any single wavelength alone does not provide a conclusive indication of success or failure, nor does it enable precise and efficient feedback.
% and the response at individual frequencies lacks standalone significance.
Therefore, we simply compare the simulation results between generated code completions and golden reference solutions.
Since the built-in components are limited, we manually construct all required components based on the descriptions provided in the API document, ensuring that all problems in our benchmark are successfully evaluated.

\subsection{Error Classification Loop}
\label{sec:Error_class}
The PIC netlist design generation problem involves a specialized language and task that is rarely encountered during the pre-training of existing LLMs, leading to inherent limitations in their performance on such tasks. 
Despite employing in-context learning and providing several examples, LLMs often confuse the PIC netlist format with other netlist formats. 
For instance, in a PIC netlist, each port can only be connected once, and duplicate connections to the same port are prohibited. 
However, LLMs frequently generate connections containing multi-pin nets, as seen in traditional VLSI netlists, which is incorrect.

To effectively employ LLMs in PIC design generation, we employ an automatic error classification feedback method. 
Since the specific aspects causing LLM failures are uncertain, errors are iteratively inspected and summarized during the generation process. 
For each conversation, if a syntax error is detected, a human expert inspects the error information, identifies common errors, and summarizes them into general restrictions to prevent the recurrence of similar errors.
\Cref{tab:class_restrictions} summarize all the common error types we collected during our trials and the corresponding restrictions that we collect as prompt.
These domain-specified restrictions are then integrated into system prompt to improve understanding of PIC modules and coding styles, and provide valuable insights into the primary reasons for failures.
This prompt-tuning approach effectively addresses poor code generation, significantly enhancing LLM performance for PIC design tasks.

\begin{table}[!t]
\centering
\caption{Restrictions for the PIC design task, listing the main failure types and corresponding constraints to maintain valid syntax.}
\label{tab:class_restrictions}
\begin{tabular}{|p{3cm}|p{5.5cm}|}
\hline
\textbf{Failure Types} & \textbf{Restrictions}\\
\hline
Use undefined models &
Only built-in devices are permitted
unless otherwise specified; never
use undefined models. \\
\hline
Bind the I/O ports &
Input or output ports in the
\texttt{ports} section represent only the
system’s start or end points; they must
not appear in any internal connections. \\
\hline
Mess up ‘Instances’
and ‘models’ part &
When specifying built-in components,
the model reference must appear in
the \texttt{models} section like
\texttt{``...\,: "<ref>"''} rather
than \texttt{``"<ref>" : ...''}.
The \texttt{instances} section
only instantiates these components. \\
\hline
Extra contents found
in JSON &
Only the required JSON netlist elements
should appear in the output.
Do not include comments, advice,
or code block markings. \\
\hline
Duplicate connections
to the same port &
Each port can only be connected once;
duplicate connections to the same port
are prohibited. \\
\hline
Wrong connections for
dangling ports &
If a specific port mapping is not
explicitly required, omit it rather
than introducing arbitrary or unused
port names. \\
\hline
Wrong ports number &
The total number of input and output ports
must align with the design specification.
Each input port typically starts with \texttt{I},
and each output port with \texttt{O}. \\
\hline
Wrong ports &
Ensure all \texttt{connections} and
\texttt{ports} are valid and consistent
with the defined \texttt{instances} and
\texttt{models}. Do not generate invalid
or undefined mappings. \\
\hline
Wrong component name &
Underscores are prohibited
in component names. \\
\hline
Other syntax error & $\backslash$
 \\
\hline
\end{tabular}
\end{table}


\subsection{Error Feedback Loop}
Due to the inherent hallucination tendencies of LLMs, even when comprehensive restrictions are provided to mitigate trivial errors, the same issues may persist. 
Inspired by real-world coding practices—where code is rarely correct on the first attempt, and iterative feedback from simulation and synthesis tools is critical for meeting design specifications—we adopt a feedback-based method that efficiently leverages error information from each query and the simulator.

For each problem, the initial query follows the standard process introduced in \Cref{sec:code_gen_eval}.
However, if the simulator detects a syntax error, our correction feedback loop is triggered. 
The error is first classified into specific categories, as outlined in \Cref{sec:Error_class}, enabling the precise identification of its cause without requiring the LLM to interpret abstract error messages which can directly inform code refinement. 
Next, the error category, along with detailed error reports and a crafted feedback prompt, is fed back to the LLM to refine the previously generated code in a manner similar to human debugging.
If the evaluation instead identifies a functional error, the feedback loop provides a concise prompt 
``The syntax is correct, but a functional error has occurred. Please review the problem description carefully". 
The feedback loop will continue iteratively until the code passes or the maximum number of iterations is reached.

\Cref{fig:feedback} gives an example of MZI\_ps to illustrate this process,
Initially, the LLM generates a result that incorrectly connects to non-existent port I2. 
This error is automatically classified as a ``Wrong Ports Error." The classification, combined with detailed error information and a crafted feedback prompt, is then fed back to the LLM. 
After one iteration of the correction feedback loop, the error is resolved, and the code passes the test.

    \begin{figure}[!tb]
    \centering
    \subfloat{%
          \includegraphics[width=0.45\textwidth]{fig/Correction_feedback.pdf}
      }
      \caption{An example of solving MZI\_ps by GPT o1-mini with feedback}
      \label{fig:feedback}
    \end{figure}
