\section{Appendix}



\begin{figure*}[!hbp]
\centerline{\includegraphics[width=\linewidth]{figs/motivating_example.pdf}}
\caption{Motivating example}
\label{fig:motivating}
\end{figure*}

\subsection{Engineering Upgrades}
\label{sec:engineering}
\bedrockfuzz adds a collection of engineering upgrades to improve the effectiveness and ease of usage, as follows:

\begin{itemize}[leftmargin=*]
    \item \textit{Limit search to unbroken questions}. To avoid the same set of questions being jailbroken across multiple fuzzing iterations, \bedrockfuzz removes a question $q_i$ from $Q$ as soon as $q_i$ is jailbroken in a fuzzing iteration $k$ (i.e., $Q \gets Q \setminus \{q_i\}$). This ensures that future fuzzing iterations focuses the search to questions that are still unbroken. Note that due to this upgrade, the total number of jailbreaks equals the number of questions jailbroken.

    \item \textit{Checking template-mutation compatibility.} Given a template $t$, only a subset $M_t$ of all mutations $M$ might make sense as candidates to be applied to $t$. For example, if $t$ already ends with ``Sure, here is'', there isn't much of a point of applying \textit{Inject Prefix} or \textit{Expand After} mutations. Similarly, if $t$ already includes instructions for \textit{Refusal Suppression}, there is no need to repeat these instructions again.
    Through simple regular expression checks, \bedrockfuzz derives a subset of mutations $M_t \subseteq M$ that are compatible with $t$ and limits mutation selection to only a compatible mutation $m \in M_t$ when generating the mutant $m(t)$.
    
    \item \textit{Improved prompts for LLM-based mutations.} As shown in figures~\ref{fig:transfer_mutation} \&~\ref{fig:few_shots}, \bedrockfuzz utilizes formatting tags (e.g., ``[ANSWER BEGINS]'' and ``[ANSWER ENDS]'') to improve LLM-based mutant generation and decrease invalid mutants.

    \item \textit{Multi-threading support.} Given a mutant $m(t)$, \bedrockfuzz utilizes multi-threading to parallelize discharging attack prompts $A_{m(t)}$ to the target model as well as evaluating corresponding responses $R_{m(t)}$ to speed up the most time-critical steps in each fuzzing iteration.
    
    \item \textit{Usability upgrades.} \bedrockfuzz provides improved command-line interface, logging support, statistics summary, and results reporting to enhance usage experience and results analysis.
\end{itemize}


\subsection{Pseudo code for mutation selection using Q-learning}
\label{app:mutation_selection}

\begin{algorithm}
\caption{Q-learning based mutation selection}
\label{alg:mutation_selection_ql}
\begin{algorithmic}[1]
\algrenewcommand\alglinenumber[1]{\scriptsize \selectfont #1}
   \Statex {\bfseries Globals:} Q-table $\mathcal{Q}$, learning rate $\alpha$, discount factor $\gamma$, exploration probability $\epsilon$   
   \Statex
   \Statex {\bfseries Input:} template $t$
   \Statex {\bfseries Output:} mutation $m$
   \Procedure{SelectMutation}{$t$}
   \State $M_t \gets$ \Call{GetCompatibleMutations}{$t$}
   \State $random \gets$ \Call{GetRandomNumber}{ }
   \If{$random < \epsilon$}
        \State $m \gets$ \Call{UniformlyRandom}{$M_t$} 
    \Else
       \State $s_t \gets root(t)$
        \State $m \gets$ \Call{WeightedRandom}{$M_t$, $\mathcal{Q}[s_t]$}
   \EndIf
   \State \Return $m$
   \EndProcedure
   \Statex
   \Statex {\bfseries Input:} template $t$, mutation $m$
   \Procedure{Reward}{$t$, $m$}
   \State $r \gets ASR(m(t))$ 
   \State $s_t \gets root(t)$
   \State $\mathcal{Q}[s_t][m] \gets (1-\alpha)~ \mathcal{Q}[s_t][m]$ 
   \Statex $\quad\quad\quad\quad\quad\quad\quad  +~ \alpha~ (r + \gamma~ \max_{a} \mathcal{Q}[s_t][a])$ 
   \EndProcedure
\end{algorithmic}
\end{algorithm}
Algorithm~\ref{alg:mutation_selection_ql} presents the Q-learning based mutation selection algorithm. Given a template $t$, \Call{SelectMutation}{} selects a compatible mutation $m \in M_t$ using an epsilon-greedy exploration-exploitation strategy (lines 1-9). If the generated random number $random \in [0, 1]$ is less than exploration probability $\epsilon$, then a uniformly-random selection is made from $M_t$ (lines 3-5). Otherwise, a weighted random selection is done using the Q-table values $\mathcal{Q}[s_t]$ as weights, with the state $s_t$ as the root parent of $t$ (lines 6-8).
Using the attack success rate of the generated mutant $m(t)$ as reward $r$, the \Call{Reward}{ } function is used to update the Q-table value $\mathcal{Q}[s_t][m]$ for the selected mutation $m$ (lines 10-13).


\subsection{Pseudo code for template selection using multi-arm bandits}
\label{app:template_selection}

\begin{algorithm}
\caption{Template selection using multi-arm bandits}
\label{alg:template_selection_ql}
\begin{algorithmic}[1]
\algrenewcommand\alglinenumber[1]{\scriptsize \selectfont #1}
   \Statex {\bfseries Globals:} Q-table $\mathcal{Q}$, learning rate $\alpha$, discount factor $\gamma$, exploration probability $\epsilon$   
   \Statex
   \Statex {\bfseries Output:} template $t$
   \Procedure{SelectTemplate}{ }
   \State $random \gets$ \Call{GetRandomNumber}{ }
   \If{$random < \epsilon$}
        \State $t \gets$ \Call{UniformlyRandom}{$O \cup G$} 
    \Else
        \State $t \gets$ \Call{WeightedRandom}{$O \cup G$, $\mathcal{Q}$}
   \EndIf
   \State \Return $t$
   \EndProcedure
   \Statex
   \Statex {\bfseries Input:} template $t$, mutation $m$
   \Procedure{Reward}{$t$, $m$}
   \State $r \gets ASR(m(t))$ 
   \State $\mathcal{Q}[t] \gets (1-\alpha)~ \mathcal{Q}[t]$
   \Statex $\quad\quad\quad\quad\quad  +~ \alpha~ (r + \gamma~ \max_{a} \mathcal{Q}[a])$ 
   \EndProcedure
\end{algorithmic}
\end{algorithm}
Algorithm~\ref{alg:template_selection_ql} presents the pseudo code for template selection using multi-arm bandits. In a given fuzzing iteration, \Call{SelectTemplate}{} selects a template $t$ from the current population $O \cup G$ using an epsilon-greedy exploration-exploitation strategy (lines 1-7). If the generated random number $random \in [0, 1]$ is less than exploration probability $\epsilon$, then a uniformly-random selection is made from $O \cup G$ (lines 2-4). Otherwise, a weighted random selection is done using the Q-table values $\mathcal{Q}$ as weights (lines 5-6).
Using the attack success rate of the generated mutant $m(t)$ as reward $r$, the \Call{Reward}{ } function is used to update the Q-table value $\mathcal{Q}[t]$ for the selected template $t$ (lines 8-10).



\subsection{Additional Implementation Details}
\label{app:implement}
\bedrockfuzz provides command-line options to easily change key hyper parameters, including the mutator model used for performing LLM-based mutations as well as the judge model used for evaluating whether or not a target response represents a successful jailbreak.

Here is a summary of hyper parameter values we used:
\begin{itemize}[leftmargin=*,noitemsep, topsep=0pt]
    \item \textit{Models}
    \begin{itemize}
        \item Mutator model: Mistral Large 2 (24.07)
        \item Judge model: Fine-tuned Llama 2 13B model from~\cite{mazeika2024harmbench}
        \item Temperature: 1.0        
    \end{itemize}
    \item \textit{Mutation selection using Q-learning}
    \begin{itemize}
        \item Learning rate: 0.4
        \item Discount factor: 0.1
        \item Initial epsilon: 1.0
        \item Epsilon decay factor: 0.9
        \item Minimum epsilon: 0.2
    \end{itemize}
    \item \textit{Template selection using multi-arm bandits}
    \begin{itemize}
        \item Learning rate: 0.3
        \item Discount factor: 0.02
        \item Initial epsilon: 1.0
        \item Epsilon decay factor: 0.97
        \item Minimum epsilon: 0.2
    \end{itemize}
    \item \textit{Early-exit fruitless templates}
    \begin{itemize}
        \item Threshold: 10\% questions
        \item Threshold minimum: 4 questions
        \item Threshold maximum: 20 questions
    \end{itemize}
    \item \textit{Warmup}
    \begin{itemize}
        \item Percentage of questions used for warmup: 100\% (all questions)
    \end{itemize}
\end{itemize}



\subsection{Additional Details on New Mutations}
\label{app:mutations}

\begin{figure*}[!hp]
\centerline{\includegraphics[width=0.8\linewidth]{figs/refusal.pdf}}
\caption{Mutant template on applying refusal suppression mutation to {\tt \{TEMPLATE\}}}
\label{fig:refusal}
\end{figure*}

\begin{figure*}[!hp]
\centerline{\includegraphics[width=0.8\linewidth]{figs/transfer.pdf}}
\caption{Prompt used for Transfer Mutation}
\label{fig:transfer_mutation}
\end{figure*}

\begin{figure*}[!hp]
\centerline{\includegraphics[width=0.8\linewidth]{figs/few_shots.pdf}}
\caption{Prompt used for Few Shots mutation}
\label{fig:few_shots}
\end{figure*}



\vspace*{\fill} \pagebreak
