\section{Design}
In this section, we will discuss the system model of {\ourAlgName} and the detail of the decentralized virtual network embedding algorithm.


% The physical network is represented as an un-directed graph $G_{p}=(V_{p}, E_{p})$. The set of $N$ physical nodes $V_{p}=\{v^{1}_{p},\dots,v^{N}_{p} \}$ and the set of $L$ physical links $E^{p}=\{ e^{1}_{p}, \dots, e^{L}_{p} \}$. Each node $v^{i}_{p}$ has a limited amount of computing resources, denoted as $\pmb{CPU}(v^{i}_{p})$ while the bandwidth of link $e^{i}_{p}$ is $\pmb{BW}(e^{i}_{p})$. 

% We assume that a virtual embedding request (VNR) is also in the form of an un-directed graph $G_{v}=(V_{v}, E_{v})$. Similar to the physical network, for each VNR, there are $n$ virtual nodes 
% % $V_{v}=\{ v^{1}_{v},\dots,v^{n}_{v} \}$ 
% and $l$ virtual links.
% % $E_{v}=\{ e^{1}_{v}, \dots, e^{V}_{v} \}$.
% Each virtual node $v^{i}_{v}$ requires $\pmb{CPU}(v^{i}_{v})$ units of resource for its operation, and each virtual link $e^{i}_{v}$ consumes $\pmb{BW}(e^{i}_{v})$ units of bandwidth to handle the communication of its endpoints.

\subsection{System Model}
The physical network is represented as an undirected graph \(G_p = (V_p, E_p)\). The set of physical nodes is denoted as \(V_p\), and the set of physical links is denoted as \(E_p\). Each physical node has limited computing resources denoted as \(\text{CPU}(v)\), where \(v \in V_p\), and the bandwidth of each physical link is denoted as \(\text{BW}(e)\), where \(e \in E_p\).

We assume that a virtual embedding request (VNR) is also in the form of an undirected graph \(G_v = (V_v, E_v)\). Similar to the physical network, there are virtual nodes denoted as \(V_v\) and virtual links denoted as \(E_v\) for each VNR. Each virtual node requires resources denoted as \(\text{CPU}(v')\), where \(v' \in V_v\), and each virtual link consumes bandwidth denoted as \(\text{BW}(e')\), where \(e' \in E_v\).


As a decentralized VNE algorithm, there is no centralized controller in the system. Every physical node can serve the VNR, and clients can send their VNRs to any one of the physical nodes. It ensures that a single node failure will not halt the system since clients can resend the request to other physical nodes if they receive no response from the primary node. 

\subsection{Performance Metrics}
The primary objective of this study is to minimize the blocking probability of virtual networks, which plays a critical role in optimizing resource utilization, ensuring high service availability, and enhancing customer satisfaction. The acceptance ratio can be mathematically represented as:

\fontsize{8}{8}\selectfont
\begin{equation}
    \text{Acceptance Ratio} = 
    \lim_{\vert\text{VNRs}\vert\rightarrow \infty} \frac{\sum_{t\in\text{VNRs}} e_{t}}{\vert\text{VNRs}\vert}
\end{equation}
\normalsize

In this context, $e_t$ represents a binary variable that indicates whether a single VNR is embedded within the physical network or not.
%
Furthermore, the \emph{Revenue} and \emph{Cost} of the algorithm's embedding can be computed as follows:

\fontsize{8}{8}\selectfont
\begin{gather}
    \text{Revenue} 
    =
    \sum_{t\in\text{VNRs}}
    e_{t} \Big\{
    \sum_{v' \in V_v}
    \text{CPU}(v')
    +
    \sum_{e' \in E_v}
    \text{BW}(e')\Big\}, \label{eq_rev} \\
    \begin{split}
        \text{Cost} =
        \sum_{t\in\text{VNRs}} &
        e_{t} \Big\{
        \sum_{v' \in V_v}
        \text{CPU}(v') \\
        & + 
        \sum_{i, j \in V_p}
        \sum_{p_{i,j} \in \mc{P}_{i,j}}
        \sum_{e' \in E_v}
        y_{i,j}
        \text{BW}(e')\vert p_{i,j}\vert\Big\},
    \end{split}
    \label{eq_cost} 
\end{gather}
\normalsize

Here, the binary decision variable $y_{i,j}$ is defined to denote if the virtual link $e'$ is mapped onto the physical path $p_{i, j}$ between the physical nodes $i$ and $j$ or not. The symbol $\vert p_{i,j}\vert$ represents the length of the path $p_{i,j}$.

% In {\ourAlg}, we introduce a specific metric with the primary aim of minimizing this metric as much as possible. The optimization equation representing this metric is depicted as follows:

% \fontsize{8}{8}\selectfont
% \begin{gather}
%     \max_{X,Y} \: \text{metric} = \max_{X,Y} \: X \cdot \text{Revenue} - Y \cdot \text{Cost}
% \end{gather}
% \normalsize


\subsection{Algorithm}
When a physical node receives a Virtual Network Request (VNR), it acts as the primary node for that request and starts the decentralized Virtual Network Embedding (VNE) algorithm. We select a random list of physical nodes to act as leaders. These leaders are tasked with performing local embedding. This process generates embedding candidates, each with its own cost and revenue.
%
Then, we run a modified version of the ring-based election algorithm (explained in detail in Algorithm \ref{alg}) among the leader nodes. This helps us to collectively agree on the optimal embedding candidate with the highest metric score. Finally, the physical resources are allocated to the client in accordance with the selected proposal.

\begin{algorithm}[t]
  \fontsize{8}{8}\selectfont
  \caption{\ourAlg\ -- \ourAlgFull}
  \label{alg}
  \DontPrintSemicolon\SetNoFillComment
  \SetKwFunction{procedureName}{\textbf{\ourAlgName}} 
  \SetKwProg{myalg}{procedure}{}{}
  \nonl \myalg{\procedureName{%
    $G_{p}$, $G_{v}$, $X$, $Y$, $L$%
  }}{
    $P \leftarrow$ a random circular linked list of $L$ selected leaders in the physical network\;

    \tcc{Embedding Initiation: }
    cost, revenue, sol $\gets$ embed($n, G_{p}, G_{v}$)  \\

    $metric$ $\gets$ X $\times$ revenue $-$ Y $\times$ cost \\
    $p_n$ creates an EMBEDDING message with $id = (n, metric, P, G_p, G_v)$\;
    $p_n$ passes the EMBEDDING message to next node\;

    \tcc{Message Handling: }
    \For{$p_i \in P$}{
        \If{$p_i$ receives EMBEDDING message}{
            cost, revenue, sol $\gets$ embed($i, G_{p}, G_{v}$)  \\
            $metric_{pi}$ $\gets$ X $\times$ revenue $-$ Y $\times$ cost \\
            \If{message metric $>$ $metric_{pi}$}{
                $p_i$ forwards the EMBEDDING message to $p_{i+1}$
            }
            \Else{
                $p_i$ changes the EMBEDDING message id to $(i, metric_{pi}, P, G_p, G_v)$ and forwards the message to $p_{i+1}$\;
            }
        }
        
        \If{$p_i$ receives EMBEDDING message with its own id}{
            $p_i$ sends EMBEDDED message with $id = (i, sol, P, G_p, G_v)$ to $p_{i+1}$\;
        }
        
        \If{$p_i$ receives EMBEDDED message with its own id}{
            \tcc{No more messages, terminated}
            allocate($G_{p}$, $G_{v}$, sol) \label{alg_line_allocate} \\
        }

        \If{$p_i$ receives EMBEDDED message}{
            sol $\gets$ EMBEDDED message \\
            $p_i$ forwards the EMBEDDED message to $p_{i+1}$\;
        }

    }

}{}
\end{algorithm}

\cat{Decentralized Embedding} 
As shown in algorithm \ref{alg}, the primary node launches {\ourAlgName} using a virtual network request, $G_v$, along with the physical network, $G_{p}$. There are three adjustable parameters configured to align with the network provider's requirements: $(X,Y)$, which are used to balance revenue and cost in the embedding performance metrics, and $L$, which determines the number of leaders to be chosen.

In the embedding initialization phase, a list of $L$ leaders (including the primary node itself) $P$ is chosen randomly in the physical network by the primary node. We chose leaders randomly for each request because it can improve the utilization of physical nodes compared to having a fixed set of leaders. The primary node then performs a low-cost local embedding algorithm to find out an embedding candidate that can fit the VNR and calculates the metric score using the cost/revenue of the candidate. It generates an \textit{EMBEDDING} message to start the ring-based algorithm by sending the message to the next node in the leaders list $P$. Note that the list $P$ is constructed as a circular linked list.

In the first phase of the ring-based algorithm, the EMBEDDING message must go through all leaders in the list $P$ at least once to find the best embedding candidate. When a node $n_i$ receives an EMBEDDING message with an id $(j, metric_j, P, G_p, G_v)$ where $i \neq j$, it performs the local embedding algorithm and calculates the metric score $metric_i$. If $metric_i > metric_j$ in the message id, node $n_i$ has a better embedding solution, so it changes the message id to $(i, metric_i, P, G_p, G_v)$ and sends it to the next node. Otherwise, it simply forwards the original message indicating that it agrees with the current solution.

When a node $n_i$ receives an EMBEDDING message with its own solution, it knows that all leaders have agreed on its proposal. It then sent an EMBEDDED message with the solution to the next leader, which will again go through every leader to notify the final decision. The algorithm terminates when $n_i$ receives the EMBEDDED message created by itself. $n_i$ will allocate the resources for the VNR and reply to the client.

\cat{Local Embedding} We adopted the local embedding algorithm from previous work GraphViNE~\cite{habibi2020graphvine}. This algorithm uses a breadth-first search algorithm to find a possible embedding solution.
% , as shown in algorithm \ref{alg_embed}.
When a leader $n_i$ calls the algorithm, it starts searching with $n_i$ itself as the root node. Firstly, the virtual nodes $V_{v}$ are sorted as higher resource demand first queue. Then a breadth-first search algorithm is performed on the physical network $G_{P}$. Each traversed node will greedily embed as many virtual nodes as possible while meeting the CPU and bandwidth requirements. When all virtual nodes have been embedded in physical nodes, the embedding solution is found, and we compute the cost and revenue. To reduce the search space, two thresholds, $\alpha\times|V_v|$ and $\beta$ are defined to limit the total number of inspected servers and the maximum search depth, respectively. 

% \begin{algorithm}[t]
%   \fontsize{8}{8}\selectfont
%   \caption{Embedding Subroutine}
%   \label{alg_embed}
%   \DontPrintSemicolon\SetNoFillComment
%   \SetKwFunction{procedureName}{\textbf{embed}} 
%   \SetKwProg{myalg}{procedure}{}{}    
%   \nonl \myalg{\procedureName{%
%     $n$, $G_{p}(V_p, E_p)$, $G_{v}(V_v, E_v), \alpha, \beta$%
%   }}{
%     $q_{p} \gets$ queue($n$) \\
%     $q_{v} \gets$ prio\_queue($V_v$) 
%     \hfill \text{\fontsize{6}{6}\selectfont/* Prioritizes virtual nodes with higher CPU demand */} \\
%     \While{{\upshape \textbf{not}} $q_v$.empty()}{
%         $n_{p}$ $\gets q_{p}$.pop() \\
%         \If{dist($n_{p}$, $n$) = $\beta$ \textbf{or} $n_{p}$ = $NULL$}{
%             Break \hfill \text{/* Reach max search depth */}
%         }
%         Mark $n_{p}$ visited \\
%         \While{True}{
%             $n_{v} \gets q_{v}$.pop() \\
%             % \For{$m' \in$ neighbor($n_{t}$)}{
%             %     \If{$m'$ is not embedded}{
%             %         $q_{t}$.push($m'$)
%             %     }            
%             % }
%             \If{$\text{CPU}(n_v) > \text{CPU}(n_p)$}{
%                 Break \hfill \text{/* Not enough resource */}
%             }
%             \If{$\nexists$ path to connect $n_{v}$ to its neighbors}{
%                 Break \hfill \text{/* Not enough bandwidth */}
%             }
%             Embed $n_{v}$ in $n_{p}$ and store the decision in sol
%         }
        
%         counter $\gets 0$ \\
%         \For{$n' \in$ neighbor($n_{p}$) \textbf{and} \text{counter} $\leq (\alpha \times |V_v|)^{\frac{1}{\beta}}$}{
%             \If{$n'$ is not visited}{
%                 $q_{p}$.push($n'$) \\
%                 counter $\gets$ counter $+ 1$
%             }
%         }
%     }
%     cost $\gets$ Calculate the cost with Eq.~\eqref{eq_cost} \\
%     revenue $\gets$ Calculate the revenue with Eq.~\eqref{eq_rev} \\
%     \textbf{Return} cost, revenue, sol
% }{}
% \end{algorithm}




% The embed subroutine uses the physical input server as the starting point of its embedding procedure based on a breadth-first search mechanism. 
% We defined two thresholds, $\alpha\times|\mc{N}^{t}|$ and $\beta$, to limit the total number of inspected servers and the maximum search depth, respectively. We omit the detailed description of embed subroutine for the sake of space and brevity.