\section{Security of $\PSecAgg$}
\label{app:proofs}

We prove our framework secure in the real-world/ideal-world simulation paradigm~\cite{EPRINT:Lindell16}. Security is argued by showing that whatever an adversary can do in the real world, it can do in the ideal world, where it interacts with an ideal functionality (trusted third party). In the ideal world, parties send their inputs to the ideal functionality, which then computes the desired function, and returns the output. In the real world, parties run the steps of the protocol.

The adversary is modeled as a probabilistic polynomial time (PPT) algorithm, that corrupts $t$, an honest minority of parties, among the parties involved in the protocol ($\PartySet{})$ in the real world.

We define an ideal functionality, $\FSecAgg$, as follows. It receives the models and the test data from the parties at the start of each round, computes the accuracy of the models on the test data, applies and the predicate $\valid()$ on them. It then filters out the bad predicates, aggregates the rest, and returns the output to the parties. The formal description appears in \figref{fsecagg}.

\begin{protofig}{Functionality $\FSecAgg$}{Functionality for Robust Secure Aggregation}{fsecagg}

    \textbf{Parameters:} Parties $\PartySet{} = \{P_1, \ldots, P_m\}$, number of corrupt parties $\cor$. Description of a check function, represented by $\msf{Chk}$. \\

    \textbf{Run:} On receiving $(\arith{\vec m}, \arith{\vec m'}, \arith{\vec D})$ from each party, where $\vec m$ is the updated local model, and $\vec m'$ is the model before the update, do the following:

    \begin{enumerate}
        \item Reconstruct the models $\vec m = \Sigma \arith{\vec m}$, $\vec m' = \Sigma \arith{\vec m'}$, and the test data $\vec D = \Sigma \arith{\vec D}$.
        \item Compute the inference of each of the models, $\msf{Acc}_i = \msf{Chk}(\vec m_i, \vec D)$, and $\msf{Acc'}_{i - 1} = \msf{Chk}(\vec m'_i, \vec D)$ for $i \in [1, m]$. Compute $\scr_i = \msf{Acc}_i - \msf{Acc}'_i$, for $i \in [1, m]$.
        \item Sort the vector of $\scr$ values, and apply a trimmed mean on them by deleting the top $\cor/2$ and bottom $\cor/2$ scores. Denote the final score for $\vec m_i$ is denoted as $\msf{scr}_i$.
        \item Select the models corresponding to the top $k$ scores across the $m$ parties.
        \item Compute the norms of these models, $\msf{norm}_i$, for $i \in [1, m - k]$. Set the value $\msf{bound}$ to be 1.5 times the median of the norms.
        \item Aggregate all models such that $\msf{norm}_i \leq \msf{bound}$ as $m_{\msf{agg}}$.
        \item Send $m_{\msf{agg}}$ to $\Adv$. If $\Adv$ sends $\msf{abort}$, send $\msf{abort}$ to all the parties. Else, send $m_{\msf{agg}}$.
    \end{enumerate}

    \textbf{Output to the adversary:} Send $\arith{m_{\msf{agg}}}$ to $\Adv$, and wait for it to respond. If $\Adv$ sends $\msf{abort}$, send $\msf{abort}$ to all the parties. Otherwise, send $\arith{m_{\msf{agg}}}$ to all the parties.

\end{protofig}

\begin{protofig}{Functionality $\FSort$}{Functionality for Oblivious Sort}{fsort}

\textbf{Parameters:} Parties $\PartySet{} = \{P_1, \ldots, P_m\}$.

\begin{enumerate}
    \item On receiving a sharing of a vector of elements, $\arith{\vec u}_i$, from all the parties reconstruct $\vec u = \Sigma_{i = 1}^m \arith{\vec u}_i$.
    \item Define the sorted array as $\vec u'$. Send $\arith{\vec u'}$ to all the parties.
\end{enumerate}
    
\end{protofig}

\begin{protofig}{Functionality $\FRand$}{Functionality to Sample Common Random Values}{frand}

\textbf{Parameters:} Parties $\PartySet{} = \{P_1, \ldots, P_m\}$. A pseudorandom function (PRF) $F$.

\begin{enumerate}
    \item Sample pairwise PRF keys, $\kappa_{ij}$ for each pair of parties $(P_i, P_j)$, for $i, j \in [1, m]$. Sample a common key $\kappa$ for all the parties.
    \item Send all $\kappa, \kappa_{ij}$, where $P_i$ is controlled by $\Adv$, to $\Adv$. If $\Adv$ sends $\msf{abort}$, send $\msf{abort}$ to all the parties. Else, send $\kappa$ and the respective keys to all the parties.
\end{enumerate}
    
\end{protofig}

\begin{protofig}{Functionality $\FSecInf$}{Functionality for Secure Inference}{fsecinf}

\textbf{Parameters:} Parties $\PartySet{} = \{P_1, \ldots, P_m\}$, a neural network architecture $N$.

\begin{enumerate}
    \item On receiving $(\arith{\vec w}, \arith{\vec D})$ from all the parties, reconstruct $\vec w = \Sigma_{i = 1}^m \arith{\vec w}$ and $\vec D = \Sigma_{i = 1}^m \arith{\vec D}$.
    \item Compute inference using the weights $\vec w$, on the dataset $D$, for a neural network $N$, to get $\msf{Acc}$.
    \item Send $\arith{\msf{Acc}}$ to $\Adv$ and wait for it to respond. If $\Adv$ sends $\msf{abort}$, send $\msf{abort}$ to all the parties. Else, send $\arith{\msf{Acc}}$.
\end{enumerate} 
    
\end{protofig}

\begin{protofig}{Functionality $\FMult$}{Functionality for Multiplication}{fmult}

\textbf{Parameters:} Parties $\PartySet{} = \{P_1, \ldots, P_m\}$.

\begin{enumerate}
    \item Receives secret-shared values $\arith{x}, \arith{y}$ from $\PartySet{}$, and reconstructs $x, y$.
    \item Computes $z = x \cdot y$, and sends it to $\Adv$.
    \item Depending on what $\Adv$ replies with, sends either $\arith{z}$ to the parties, or $\msf{abort}$.
\end{enumerate}

    
\end{protofig}



\begin{protofig}{Functionality $\FMaxSoft$}{Functionality for Maximum Softmax}{fmaxsoft}

\textbf{Parameters:} Parties $\PartySet{} = \{P_1, \ldots, P_m\}$, a classifier $f$, with $L$ classes.

\begin{enumerate}
    \item On receiving $(\arith{\vec w}, \arith{\vec D})$ from all the parties, reconstruct $\vec w = \Sigma_{i = 1}^m \arith{\vec w}$ and $\vec D = \Sigma_{i = 1}^m \arith{\vec D}$.
    \item Compute $\msf{MSft} = \frac{1}{|\bfD|} \sum_{(\bfx_k, y_k) \in \bfD} \max f(\bfx_k; \bfw)$, where $f(\bfx_k; \bfw) \in \R^L$ is the predicted softmax probability over $L$ classes, which is an output by the classifier $f$ parameterized with $\bfw$. 
    \item Send $\arith{\msf{MSft}}$ to $\Adv$ and wait for it to respond. If $\Adv$ sends $\msf{abort}$, send $\msf{abort}$ to all the parties. Else, send $\arith{\msf{MSft}}$.
\end{enumerate} 
    
\end{protofig}

\begin{theorem}\label{thm:secagg}
    Protocol $\PSecAgg$ securely realises the functionality $\FSecAgg$ in the presence of a malicious adversary that can statically corrupt up to $\cor < m/2$ parties in $\mpcnodes$, in the $(\FSecInf, \FSort, \FRand)$-hybrid model.
\end{theorem}

\begin{proof}
    Since the parties in the protocol only interact with $\FSecInf$, $\FMult$, $\FSort$, $\FZeroOne$, and $\FRand$ for the key setup, the proof is quite straightforward. Let $A$ denote the set of corrupt parties. We construct a simulator, $\Sim$ that interacts with the adversary controlled parties in the real world, and ideal functionality, $\FSecAgg$, in the ideal world. $\Sim$ initializes a boolean flag, $\msf{flag} = 0$, which indicates whether an honest party aborts during the protocol.

    Note that $\mpcnodes$ does not have any inputs, and only acts as output-receiving parties. The inputs, namely the models $\vec w_i$, and the validation datasets, $\vec D_i$, for $i \in [1, m]$, come from the clients. Thus, we can distinguish between two cases. The honest clients communicate their data directly to the functionality, $\FSecAgg$, and $\Sim$ does not need to simulate anything. If $\Adv$ sends an $\msf{abort}$ to it, it forwards that to $\FSecAgg$. Else, it receives $m_{\msf{agg}}$ from the functionality, and sends it to $\Adv$.

    The Setup phase is simulated by $\Sim$ by invoking the simulator for $\FRand$. In order for a corrupt client to secret-share its input, $\mpcnodes$ reconstruct a fresh random value $u$ to it, using their pairwise PRF keys.
    Since we assume that we are using a linear secret-sharing scheme, such as an instantiation of a replicated secret-sharing scheme~\cite{CCS:MohRin18,USENIX:DalEscKel21,tetrad,EPRINT:FLNW16}, the simulator knows $\Adv$'s keys, and can extract the corrupt client's input, $\vec w', \vec D'$. $\Sim$ runs the simulator for $\FSecInf$, by using random data for the cases when the $\vec w'$ is supposed to be checked with honest client's validation data. $\Sim$ emulates $\FSort$ internally.

    If the adversary cheated at any point in the protocol, set $\msf{flag} = 1$, and send $\msf{abort}$ to $\FSecAgg$. Else, send $\vec w', \vec D'$ to $\FSecAgg$, to receive $m_{\msf{agg}}$. If $\msf{flag} = 1$, or if $\Adv$ sends an $\msf{abort}$, send $\msf{abort}$ to $\FSecAgg$. Else, send $m_{\msf{agg}}$ to $\Adv$.

    
\end{proof}
