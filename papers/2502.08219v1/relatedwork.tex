\section{Related Work}
% BEGIN ORIGINAL
% The identified related work can be structured into three different categories.
% For each of these categories a literature research was conducted representing the theoretical background of the presented analysis in this paper.
% END ORIGINAL

% BEGIN AI-IMPROVED
The identified related work can be organized into three distinct categories.
For each category, a literature review was conducted to represent the theoretical background of the analysis presented in this paper.
% END AI-IMPROVED

% \begin{itemize}
% \item \textbf{Centrality in Graphs}: Covers the theoretical background of the chosen graph-based methods. The applicability of established evaluation methods known from social networks is researched.
% \item \textbf{Package Dependency Analysis}: Previous studies according to the structure of software ecosystems, such as the npm Registry, RubyGems.org, or the Debian project, are examined.
% \item \textbf{Project Status Analysis}: Techniques for quantifying the maintenance status of software projects are researched.
% \end{itemize}

% BEGIN AI-IMPROVED
\begin{itemize}
	\item \textbf{Centrality in Graphs}: This section covers the theoretical background of the selected graph-based methods. The research focuses on the applicability of established evaluation methods known from social networks.
	\item \textbf{Package Dependency Analysis}: This section examines previous studies related to the structure of software ecosystems like the npm Registry, RubyGems.org, or the Debian project.
	\item \textbf{Project Status Analysis}: Research is conducted on techniques for quantifying the maintenance status of software projects.
\end{itemize}
% END AI-IMPROVED

\subsection{Centrality in Graphs}

% BEGIN ORIGINAL
% In the context of network analysis, centrality measures offer several advantages over naive methods, such as only counting incoming edges.
% In contrast to those naive methods, Centrality provides a nuanced understanding of a node's importance based on its position in the network.
% By using centrality, insights into the overall network structure, such as identifying key influencers, potential bottlenecks, or vulnerable nodes can be gained.
% Overall, centrality provides a more comprehensive view of node importance within a network compared to just counting incoming edges.
% END ORIGINAL

% BEGIN AI-IMPROVED
In the context of network analysis, centrality measures offer several advantages over naive methods, such as merely counting incoming edges.
Unlike these naive approaches, centrality provides a nuanced understanding of a node's importance based on its position within the network.
By employing centrality, one can gain insights into the overall network structure, including identifying key influencers, potential bottlenecks, or vulnerable nodes.
Overall, centrality offers a more comprehensive view of node importance within a network compared to simply counting incoming edges.
% END AI-IMPROVED

% BEGIN ORIGINAL
% Centrality algorithms assign numbers or rankings to nodes within a graph corresponding to their network position.
% Applications include identifying the most influential persons in a social network, key infrastructure nodes in the internet, or analyzing urban networks.
% In general, centrality algorithms answer the question “What characterizes an important node?”.
% Since the word “importance” has a wide number of meanings, the available definitions of centrality are versatile \cite{Freeman1978}.
% END ORIGINAL

% BEGIN AI-IMPROVED
Centrality algorithms assign numbers or rankings to nodes within a graph based on their network position.
Applications include identifying the most influential people in a social network, key infrastructure nodes on the internet, or analyzing urban networks.
In general, centrality algorithms answer the question, “What characterizes an important node?”
The word “importance” can have many meanings, making the available definitions of centrality versatile \cite{Freeman1978}.
% END AI-IMPROVED

% BEGIN ORIGINAL
% Among the various centrality algorithms, the eigenvector centrality emerged as the most promising algorithm for this study, as demonstrated in 2019 by Gómez \cite{Gomez2019}.
% While eigenvector centrality focuses on the importance of connections to influential nodes, betweenness centrality highlights nodes that facilitate communication between others, and closeness centrality emphasizes nodes with efficient access to the entire network.
% Other centrality algorithms were deemed unsuitable for this study
% END ORIGINAL

% BEGIN AI-IMPROVED
Among the various centrality algorithms, eigenvector centrality emerged as the most promising algorithm for this study, as demonstrated in 2019 by Gómez \cite{Gomez2019}.
While eigenvector centrality focuses on the importance of connections to influential nodes, betweenness centrality highlights nodes that facilitate communication between others, and closeness centrality emphasizes nodes with efficient access to the entire network.
Other centrality algorithms were deemed unsuitable for this study.
% END AI-IMPROVED

% BEGIN ORIGINAL
% Historically, eigenvector centrality was introduced by Landau \cite{landau1895relativen} for chess tournaments.
% Half a century later, it was rediscovered by Wei \cite{wei1952algebraic} and popularized by Kendall \cite{760e07d1-fd0d-3ce0-afae-f7ab9cd57766} in the context of sport ranking.
% Claude introduced a general definition for graphs based on social connections \cite{claude1966theorie}.
% Eventually, Bonacich \cite{35397813-90c1-3806-8d5d-a07b3340ac3d} reintroduced eigenvector centrality again and made it popular in link analysis.
% END ORIGINAL

% BEGIN AI-IMPROVED
Historically, eigenvector centrality was introduced by Landau \cite{landau1895relativen} for chess tournaments.
Half a century later, it was rediscovered by Wei \cite{wei1952algebraic} and popularized by Kendall \cite{760e07d1-fd0d-3ce0-afae-f7ab9cd57766} in the context of sports ranking.
Claude introduced a general definition for graphs based on social connections \cite{claude1966theorie}.
Eventually, Bonacich \cite{35397813-90c1-3806-8d5d-a07b3340ac3d} reintroduced eigenvector centrality and made it popular in link analysis.
% END AI-IMPROVED

% BEGIN ORIGINAL
% Eigenvector centrality gives a measure of the influence of the node based on the connections of the nodes to which it is connected.
% Similar to degree centrality, eigenvector centrality favors nodes that have a high number of links.
% In contrast to degree centrality, eigenvector centrality also factors in the centrality of the adjacent node.
% END ORIGINAL

% BEGIN AI-IMPROVED
Eigenvector centrality measures the influence of a node based on the connections of the nodes to which it is connected.
Similar to degree centrality, eigenvector centrality favors nodes with a high number of links.
Unlike degree centrality, eigenvector centrality also considers the centrality of the adjacent nodes.
% END AI-IMPROVED

% BEGIN ORIGINAL
% Due to its mathematical foundation, eigenvector centrality requires strongly connected graphs\footnote{\url{https://ocw.mit.edu/courses/14-15-networks-spring-2022/mit14_15s22_lec3.pdf}}.
% In the context of a software repository's dependency graph for a Linux distribution, strong connectivity cannot always be assumed.
% However, a more general variant exists: the Katz centrality algorithm, introduced by Leo Katz in 1953 \cite{Katz1953}.
% Unlike eigenvector centrality, Katz centrality also applies to graphs that are not strongly connected.
% END ORIGINAL

% BEGIN AI-IMPROVED
Due to its mathematical foundation, eigenvector centrality requires strongly connected graphs\footnote{\url{https://ocw.mit.edu/courses/14-15-networks-spring-2022/mit14_15s22_lec3.pdf}}.
In the context of a software repository's dependency graph for a Linux distribution, strong connectivity cannot always be assumed.
However, a more general variant exists: the Katz centrality algorithm, introduced by Leo Katz in 1953 \cite{Katz1953}.
Unlike eigenvector centrality, Katz centrality also applies to graphs that are not strongly connected.
% END AI-IMPROVED

% BEGIN ORIGINAL
% Katz centrality is capable of assigning scores to nodes outside the largest connected component.
% It incorporates an attenuation factor to account for paths of varying lengths, ensuring non-zero scores for a broader range of nodes.
% By emphasizing immediate neighbors through a constant additive term, Katz centrality considers both direct and indirect connections.
% This robustness benefits nodes with fewer connections that remain influential due to their network positions.
% The attenuation factor provides flexibility, allowing for adjustments based on the network's unique characteristics.
% Overall, Katz centrality offers a versatile approach for evaluating disconnected networks, delivering meaningful scores across the graph.
% END ORIGINAL

% BEGIN AI-IMPROVED
Katz centrality is capable of assigning scores to nodes outside the largest connected component.
It incorporates an attenuation factor to account for paths of varying lengths, ensuring non-zero scores for a broader range of nodes.
By emphasizing immediate neighbors through a constant additive term, Katz centrality considers both direct and indirect connections.
This robustness benefits nodes with fewer connections that remain influential due to their network positions.
The attenuation factor provides flexibility, allowing for adjustments based on the network's unique characteristics.
Overall, Katz centrality offers a versatile approach for evaluating disconnected networks, delivering meaningful scores across the graph.
% END AI-IMPROVED

\subsection{Package Dependency Analysis}

% BEGIN ORIGINAL
% In 2015, Wang et al. published a study using a graph-based method to create a distribution wide dependency analysis for Ubuntu~14.04 \cite{7490780}.
% The authors present the challenges with creating a dependency graph by parsing package metadata from package manager such as Debian's \gls{apt}.
% This work illustrates that a graph-based approach is efficient for understanding the software structure of a whole distribution and it can assist in further more detailed investigations.
% END ORIGINAL

% BEGIN AI-IMPROVED
In 2015, Wang et al. published a study using a graph-based method to create a distribution-wide dependency analysis for Ubuntu~14.04 \cite{7490780}.
The authors present the challenges of creating a dependency graph by parsing package metadata from package managers such as Debian's \gls{apt}.
This work illustrates that a graph-based approach is efficient for understanding the software structure of an entire distribution and can assist in further, more detailed investigations.
% END AI-IMPROVED

% BEGIN ORIGINAL
% In 2017, Decan, Mens, and Claes published a comparison of dependency issues in \gls{foss} packaging ecosystems \cite{7884604}.
% The authors presented an empirical analysis of the evolution of dependency graphs of three large package ecosystems.
% The paper highlights solutions each package ecosystem has put into place for dependency update issues, such as dependency constraints.
% The authors conclude that package dependency updates have a non-negligible maintenance cost and that better packaging and dependency analysis tools are required.
% END ORIGINAL

% BEGIN AI-IMPROVED
In 2017, Decan, Mens, and Claes published a comparison of dependency issues in \gls{foss} packaging ecosystems \cite{7884604}.
The authors presented an empirical analysis of the evolution of dependency graphs of three large package ecosystems.
The paper highlights solutions each package ecosystem has implemented for dependency update issues, such as dependency constraints.
The authors conclude that package dependency updates entail a non-negligible maintenance cost and that better packaging and dependency analysis tools are needed.
% END AI-IMPROVED

% BEGIN ORIGINAL
% In 2018, Decan, Mens, and Grosjoen published a more detailed study about the evolution in software packaging ecosystems \cite{Decan2019}.
% The authors state that the majority of packages depend on other packages, but only a small proportion of packages account for most reverse dependencies.
% According to the study, there is a high proportion of so called “fragile” packages, due to a high and increasing number of transitive dependencies over time.
% The study concludes that these findings are instrumental for assessing the quality of a package dependency networks and that it can be improved through more comprehensive dependency management tools and imposed policies.
% END ORIGINAL

% BEGIN AI-IMPROVED
In 2018, Decan, Mens, and Grosjoen published a more detailed study on the evolution of software packaging ecosystems \cite{Decan2019}.
The authors state that most packages depend on other packages, but only a small proportion of packages account for most reverse dependencies.
According to the study, there is a high proportion of so-called “fragile” packages due to a high and increasing number of transitive dependencies over time.
The study concludes that these findings are instrumental for assessing the quality of package dependency networks and that improvements can be made through more comprehensive dependency management tools and imposed policies.
% END AI-IMPROVED

% BEGIN ORIGINAL
% In 2021, Suhaib Mujahid et al. published a study evaluating a centrality-based approach which could detect packages in the npm Registry that are in decline~\cite{9631870}.
% The authors conclude that it is possible to predict that packages in the npm ecosystem will soon become deprecated.
% The article's key point is an analysis of the popular npm package Moment.js. The authors published a chart that shows a declining centrality value since September 2018.
% Two years later the package was considered deprecated by its developers.
% Not until that point in time, the number of packages that depended on Moment.js started to drop.
% END ORIGINAL

% BEGIN AI-IMPROVED
In 2021, Suhaib Mujahid et al. published a study evaluating a centrality-based approach that could detect packages in the npm Registry that are in decline~\cite{9631870}.
The authors conclude that it is possible to predict when packages in the npm ecosystem will soon become deprecated.
The article's key point is an analysis of the popular npm package Moment.js. The authors published a chart showing a declining centrality value since September 2018.
Two years later, the package was considered deprecated by its developers.
It was not until that point in time that the number of packages depending on Moment.js began to drop.
% END AI-IMPROVED

% BEGIN ORIGINAL
% In 2025, Alhamdan and Staicu published a study analyzing the Deno ecosystem \cite{Alhamdan:Staicu:2025}.
% The authors state that even Deno has a smaller attack surface than Node.js, several attacks are not or only partially addressed.
% The paper also highlights that classical URL-related issues such as expired domains or the reliance on insecure transport protocols are still relevant.
% The authors propose the following to improve the security model of the Deno ecosystem: add import permissions, additional access control at file system level, support for compartmentalization, and a manifest file that persists fine-grained permissions.
% END ORIGINAL

% BEGIN AI-IMPROVED
In 2025, Alhamdan and Staicu published a study analyzing the Deno ecosystem \cite{Alhamdan:Staicu:2025}.
The authors state that although Deno has a smaller attack surface than Node.js, several attacks are not addressed or only partially addressed.
The paper also highlights that classical URL-related issues, such as expired domains or reliance on insecure transport protocols, remain relevant.
The authors propose the following improvements to the security model of the Deno ecosystem: add import permissions, additional access control at the file system level, support for compartmentalization, and a manifest file that persists fine-grained permissions.
% END AI-IMPROVED

\subsection{Project Status Analysis}

% BEGIN ORIGINAL
% Unmaintained projects are still a serious problem as also shown by \cite{236368}.
% In 2020, Jailton Coelho et al. published a study \cite{COELHO2020106274} proposing an approach to identify GitHub projects that are not actively maintained.
% The authors introduced the so-called \gls{lma} value as a metric describing the maintenance status of Github projects.
% The authors trained a machine learning model to identify unmaintained or sparsely maintained projects, based on a set of features, for instance the number of commits, forks, or issues.
% The approach was published as an extension for Google Chrome.
% Ironically, this extension is not actively maintained anymore.
% Further, the published extension does not contain the trained model but instead is intended to communicate with a server provided by the authors.
% This server is currently offline and therefore the developed approach cannot be used for this paper.
% However, the authors conducted several correlation analyses.
% The authors state that, e.g., the number of contributors or lines of code can be used to assess the maintenance status of a software project, since those are correlated with their \gls{lma} value.
% END ORIGINAL

% BEGIN AI-IMPROVED
Unmaintained projects continue to pose a serious problem, as also shown by \cite{236368}.
In 2020, Jailton Coelho et al. published a study \cite{COELHO2020106274} proposing a method to identify GitHub projects that are not actively maintained.
The authors introduced the so-called \gls{lma} value as a metric for describing the maintenance status of GitHub projects.
They trained a machine learning model to identify unmaintained or sparsely maintained projects based on a set of features, such as the number of commits, forks, or issues.
The approach was released as an extension for Google Chrome.
Ironically, this extension is no longer actively maintained.
Furthermore, the published extension does not contain the trained model but instead is intended to communicate with a server provided by the authors.
This server is currently offline, and therefore the developed approach cannot be used for this paper.
However, the authors conducted several correlation analyses.
They state that factors such as the number of contributors or lines of code can be used to assess the maintenance status of a software project, as these are correlated with their \gls{lma} value.
% END AI-IMPROVED

% BEGIN ORIGINAL
% In 2020, Rob Pike published a technical article \cite{pike2020} describing the criticality score which is a technique for quantifying criticality.
% In 2021, this technique was further examined by Pfeiffer \cite{pfeiffer}.
% The goal of this score is to find a single value that represents all signals of criticality for a package in a meaningful way.
% The \gls{ossf} group, operated by the Linux Foundation, maintains multiple software projects on Github\footnote{\url{https://github.com/ossf}} which can be used to, e.g., calculate the criticality score of Github projects or surveys about the state of software ecosystems.
% However, their tools are only applicable for a limited scope.
% For instance, the official criticality score tool\footnote{\url{https://github.com/ossf/criticality_score}} is only applicable to Github projects and a Google Cloud account is required to use the tool.
% END ORIGINAL

% BEGIN AI-IMPROVED
In 2020, Rob Pike published a technical article \cite{pike2020} describing the criticality score, a technique for quantifying criticality.
In 2021, this technique was further examined by Pfeiffer \cite{pfeiffer}.
The goal of this score is to find a single value that meaningfully represents all signals of criticality for a package.
The \gls{ossf} group, operated by the Linux Foundation, maintains multiple software projects on GitHub\footnote{\url{https://github.com/ossf}} that can be used to calculate the criticality score of GitHub projects or conduct surveys about the state of software ecosystems.
However, their tools are only applicable within a limited scope.
For instance, the official criticality score tool\footnote{\url{https://github.com/ossf/criticality_score}} is only applicable to GitHub projects, and a Google Cloud account is required to use the tool.
% END AI-IMPROVED