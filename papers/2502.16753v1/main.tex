%Version 3 October 2023
% See section 11 of the User Manual for version history
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                 %%
%% Please do not use \input{...} to include other tex files.       %%
%% Submit your LaTeX manuscript as one .tex document.              %%
%%                                                                 %%
%% All additional figures and files should be attached             %%
%% separately and not embedded in the \TeX\ document itself.       %%
%%                                                                 %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%\documentclass[referee,sn-basic]{sn-jnl}% referee option is meant for double line spacing

%%=======================================================%%
%% to print line numbers in the margin use lineno option %%
%%=======================================================%%

%%\documentclass[lineno,sn-basic]{sn-jnl}% Basic Springer Nature Reference Style/Chemistry Reference Style

%%======================================================%%
%% to compile with pdflatex/xelatex use pdflatex option %%
%%======================================================%%

%%\documentclass[pdflatex,sn-basic]{sn-jnl}% Basic Springer Nature Reference Style/Chemistry Reference Style


%%Note: the following reference styles support Namedate and Numbered referencing. By default the style follows the most common style. To switch between the options you can add or remove Numbered in the optional parenthesis. 
%%The option is available for: sn-basic.bst, sn-vancouver.bst, sn-chicago.bst%  
 
%%\documentclass[sn-nature]{sn-jnl}% Style for submissions to Nature Portfolio journals
%%\documentclass[sn-basic]{sn-jnl}% Basic Springer Nature Reference Style/Chemistry Reference Style
% \documentclass[sn-mathphys-num]{sn-jnl}% Math and Physical Sciences Numbered Reference Style 
\documentclass[sn-mathphys-ay]{sn-jnl}% Math and Physical Sciences Author Year Reference Style
%%\documentclass[sn-aps]{sn-jnl}% American Physical Society (APS) Reference Style
%%\documentclass[sn-vancouver,Numbered]{sn-jnl}% Vancouver Reference Style
%%\documentclass[sn-apa]{sn-jnl}% APA Reference Style 
%%\documentclass[sn-chicago]{sn-jnl}% Chicago-based Humanities Reference Style

%%%% Standard Packages
%%<additional latex packages if required can be included here>
\usepackage[dvipsnames]{xcolor}
\usepackage{graphicx}%
\usepackage{multirow}%
\usepackage{amsmath,amssymb,amsfonts}%
\usepackage{amsthm}%
\usepackage{mathrsfs}%
\usepackage[title]{appendix}%
\usepackage{xcolor}%
\usepackage{textcomp}%
\usepackage{manyfoot}%
\usepackage{booktabs}%
\usepackage{algorithm}%
\usepackage{algorithmicx}%
\usepackage{algpseudocode}%
\usepackage{listings}%
\usepackage{subcaption}

%%%%

%%%%%=============================================================================%%%%
%%%%  Remarks: This template is provided to aid authors with the preparation
%%%%  of original research articles intended for submission to journals published 
%%%%  by Springer Nature. The guidance has been prepared in partnership with 
%%%%  production teams to conform to Springer Nature technical requirements. 
%%%%  Editorial and presentation requirements differ among journal portfolios and 
%%%%  research disciplines. You may find sections in this template are irrelevant 
%%%%  to your work and are empowered to omit any such section if allowed by the 
%%%%  journal you intend to submit to. The submission guidelines and policies 
%%%%  of the journal take precedence. A detailed User Manual is available in the 
%%%%  template package for technical guidance.
%%%%%=============================================================================%%%%

%% as per the requirement new theorem styles can be included as shown below
\theoremstyle{thmstyleone}%
\newtheorem{theorem}{Theorem}%  meant for continuous numbers
% \newtheorem{theorem}{Theorem}[section]% meant for sectionwise numbers
%% optional argument [theorem] produces theorem numbering sequence instead of independent numbers for Proposition
% \newtheorem{proposition}[theorem]{Proposition}% 
\newtheorem{proposition}{Proposition}% to get separate numbers for theorem and proposition etc.

\theoremstyle{thmstyletwo}%
\newtheorem{example}{Example}%
\newtheorem{remark}{Remark}%

\theoremstyle{thmstylethree}%
\newtheorem{definition}{Definition}%
\newtheorem{problem}{Problem}%

\raggedbottom
%%\unnumbered% uncomment this for unnumbered level heads
%%%%%% ADDITIONAL PACKAGES AND COMMANDS%%%%%%%%%%%%%%%
%\usepackage[pagewise]{lineno}
%\linenumbers

\newcommand{\arena}{$\mathcal{A}$}
\newcommand{\attackset}{\mathcal{A}}
\newcommand{\Act}{\mathcal{A}}
\newcommand{\Prob}{\mathcal{P}}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\graph}{\mathcal{G}}
\newcommand{\mask}{\mathcal{M}}
\newcommand{\expval}{\mathbb{E}}
\usepackage{caption}
\usepackage{subcaption} 

\newcommand{\rmg}[1]{ {\color{blue}RMG: #1}}

%\usepackage{epsfig} % for postscript graphics files
%\usepackage{epstopdf}


\begin{document}

\title[]{Enhancing sensor attack detection in supervisory control systems modeled by probabilistic automata}

% Enhancing detection of sensor attacks in supervisory control systems modeled by probabilistic automata

%Detecting sensor attack strategies in supervisory control systems modeled by probabilistic automata
%On detecting sensor 
%Detection of classes of sensor attacks using probabilistic supervisory control framework
%%=============================================================%%
%% GivenName	-> \fnm{Joergen W.}
%% Particle	-> \spfx{van der} -> surname prefix
%% FamilyName	-> \sur{Ploeg}
%% Suffix	-> \sfx{IV}
%% \author*[1,2]{\fnm{Joergen W.} \spfx{van der} \sur{Ploeg} 
%%  \sfx{IV}}\email{iauthor@gmail.com}
%%=============================================================%%

\author*[1]{\fnm{Parastou} \sur{Fahim}}\email{pbf5107@psu.edu}

\author[2,3]{\fnm{Samuel} \sur{Oliveira}}\email{samuel.oliveira@unifap.br}

\author[1]{\fnm{R\^omulo} \sur{Meira-G\'oes}}\email{romulo@psu.edu}
% \equalcont{These authors contributed equally to this work.}

% \author[1,2]{\fnm{Third} \sur{Author}}\email{iiiauthor@gmail.com}
% \equalcont{These authors contributed equally to this work.}

\affil[1]{\orgdiv{School of Electrical Engineering and Computer Science}, \orgname{The Pennsylvania State University}, \orgaddress{\city{University Park}, \state{PA}, \country{USA}}}

\affil[2]{\orgdiv{Graduate Program in Electrical Engineering}, \orgname{Santa Catarina State University (UDESC)}, \orgaddress{\city{Joinville}, \state{SC}, \country{Brazil}}}

\affil[3]{\orgdiv{Department of Exact and Technological Sciences}, \orgname{Federal University of Amapá (UNIFAP)}, \orgaddress{\city{Macapá}, \state{AP}, \country{Brazil}}}
% \affil[2]{\orgdiv{Department}, \orgname{Organization}, \orgaddress{\street{Street}, \city{City}, \postcode{10587}, \state{State}, \country{Country}}}

% \affil[3]{\orgdiv{Department}, \orgname{Organization}, \orgaddress{\street{Street}, \city{City}, \postcode{610101}, \state{State}, \country{Country}}}

%%==================================%%
%% Sample for unstructured abstract %%
%%==================================%%

\abstract{
Sensor attacks compromise the reliability of cyber-physical systems (CPSs) by altering sensor outputs with the objective of leading the system to unsafe system states. 
This paper studies a probabilistic intrusion detection framework based on $\lambda$-sensor-attack detectability ($\lambda$-sa), a formal measure that evaluates the likelihood of a system being under attack based on observed behaviors.
Our framework enhances detection by extending its capabilities to identify multiple sensor attack strategies using probabilistic information, which enables the detection of sensor attacks that were undetected by current detection methodologies. 
We develop a polynomial-time algorithm that verifies $\lambda$-sa detectability by constructing a weighted verifier automaton and solving the shortest path problem. 
Additionally, we propose a method to determine the maximum detection confidence level ($\lambda$*) achievable by the system, ensuring the highest probability of identifying attack-induced behaviors.  
%Sensor deception is a class of attacks in control systems where an attacker manipulates sensor readings to cause damage to the system.
%In this work, we investigate the problem of designing better and faster intrusion detection systems against sensor deception attacks.
%We study this problem in the context of stochastic supervisory control theory using the notion of $\epsilon$-safety detection.
%The $\epsilon$-safety notion ensures that a sensor deception attack can be detected due to changes in the probabilistic behavior in the control system, i.e., it leaves a probability footprint. 
% The intrusion detection mechanism uses the probabilistic information of the system to identify if the system is under attack.
% Our work investigates quantitative measurements to detect this class of attacks in the context of stochastic supervisory control.
% We introduce the notion of $\epsilon$-safe systems, which is a first step to generalize qualitative intrusion detection conditions to quantitative intrusion detection conditions.
%We provide necessary and sufficient conditions to verify if a system is $\epsilon$-safe in polynomial-time complexity improving the current state-of-the-art exponential-time complexity. 
% This algorithm improves the state-of-the-art verification algorithm for $\epsilon$-safety that ran in exponential-time complexity.
}

%%================================%%
%% Sample for structured abstract %%
%%================================%%

% \abstract{\textbf{Purpose:} The abstract serves both as a general introduction to the topic and as a brief, non-technical summary of the main results and their implications. The abstract must not include subheadings (unless expressly permitted in the journal's Instructions to Authors), equations or citations. As a guide the abstract should not exceed 200 words. Most journals do not set a hard limit however authors are advised to check the author instructions for the journal they are submitting to.
% 
% \textbf{Methods:} The abstract serves both as a general introduction to the topic and as a brief, non-technical summary of the main results and their implications. The abstract must not include subheadings (unless expressly permitted in the journal's Instructions to Authors), equations or citations. As a guide the abstract should not exceed 200 words. Most journals do not set a hard limit however authors are advised to check the author instructions for the journal they are submitting to.
% 
% \textbf{Results:} The abstract serves both as a general introduction to the topic and as a brief, non-technical summary of the main results and their implications. The abstract must not include subheadings (unless expressly permitted in the journal's Instructions to Authors), equations or citations. As a guide the abstract should not exceed 200 words. Most journals do not set a hard limit however authors are advised to check the author instructions for the journal they are submitting to.
% 
% \textbf{Conclusion:} The abstract serves both as a general introduction to the topic and as a brief, non-technical summary of the main results and their implications. The abstract must not include subheadings (unless expressly permitted in the journal's Instructions to Authors), equations or citations. As a guide the abstract should not exceed 200 words. Most journals do not set a hard limit however authors are advised to check the author instructions for the journal they are submitting to.}

\keywords{Discrete Event Systems; Supervisory Control; Cybersecurity; Intrusion Detection}

%%\pacs[JEL Classification]{D8, H51}

%%\pacs[MSC Classification]{35A01, 65L10, 65L12, 65L20, 65L70}

\maketitle
\graphicspath{{Figs/}}

\section{Introduction}
\vspace{-0.5em}
\input{1-intro.tex}
% Cyber-physical systems (CPSs) bridge computational and communication technologies, enabling the monitoring and control of physical processes.
% However, their increase in use, complexity, and dependence on communication networks introduces new vulnerabilities that may be exploited by cyber-attacks.
% For this reason, it is crucial to identify and understand vulnerabilities in CPSs for their secure operation.

% In this paper, we study the problem of designing better and faster \emph{intrusion detection (ID) systems} for CPSs modeled as \emph{probabilistic discrete event systems (PDES)} \citep{Lawford:1993,Garg:1999,Lafortune:2021}. 
% An ID system monitors the presence of attacks by analyzing the behavior of the control system.
% Herein, we investigate detectors for \emph{sensor deception attacks}; an attacker that hijacks a subset of sensors to damage the CPS. 

% % In the context of DES, several works focused on detecting and preventing deception attacks. 
% % We separate these works in three categories: \textbf{[1]} \emph{attack synthesis} \citep{Su:2018,meira-goes:2020synthesis,tong:2022,YAO2024deception}, \textbf{[2]}~\emph{robust supervisor design} \citep{meira-goes:2023dealing,Wang:2020,Zheng2023deception}, and \textbf{[3]} \emph{intrusion detection design} \citep{Thorsley:2006,Carvalho:2018,Lima:2019,meira-goes:2020towards,wang:2022,fritz2023detection,zhang2023robust,lin2023diagnosability}.
% % Our work differs intrinsically from attack synthesis and robust supervisor design since we study intrusion detection design.
% % Within intrusion detection design, most works only consider logical, without probabilities, DES models except for \citep{Thorsley:2006,meira-goes:2020towards}.
% In DES, several works focused on detecting and preventing deception attacks, e.g., see \citep{Rashidinejad:2019,hadjicostis2022cybersecurity}. 
% We separate these works in three categories: \textbf{[1]} \emph{attack synthesis} \citep{Su:2018,meira-goes:2020synthesis,tong:2022,YAO2024deception}, \textbf{[2]}~\emph{robust supervisor design} \citep{Su:2018,wakaiki2019supervisory,meira-goes:2023dealing,Zheng2023deception}, and \textbf{[3]} \emph{intrusion detection design} \citep{Thorsley:2006,Carvalho:2018,Lima:2019,meira-goes:2020towards,wang:2022,fritz2023detection,zhang2023robust,lin2023diagnosability}.
% Our work differs intrinsically from attack synthesis and robust supervisor design since we focus on ID.
% Within ID design, most works only consider logical, without probabilities, DES models except for \citep{Thorsley:2006,meira-goes:2020towards}.

% \cite{Thorsley:2006} investigated ID systems for actuator deception attacks. 
% This attacker was modeled using a probabilistic model, leading to a probabilistic model for the controlled system.
% However, the ID system \emph{does not use} this probabilistic information to detect the attacker, i.e., the detector only uses logical models similar to those in \citep{Carvalho:2018,Lima:2019}.
% In other words, these detectors can only detect logical footprints left by the attacker.


% Of particular relevance to this paper is the work in \citep{meira-goes:2020towards} where the notion of \emph{$\epsilon$-safety} is introduced.
% $\epsilon$-safety defines a \emph{quantitative measure} for detecting sensor deception attacks that are undetectable by logical intrusion detectors in \citep{Carvalho:2018,Lima:2019}.
% The $\epsilon$ value represents the certainty a behavior originates from an attacked system.
% This new detection definition identifies attackers that significantly change the probability of the controlled system when modifying the behavior of the system but that remain undetectable by their logical behavior.
% In other words, it evaluates if the attacker leaves a \emph{probability footprint} while stealthily modifying the controlled behavior.
% % i.e., the likelihood of the attacked behavior.

% In this paper, we introduce a computationally more efficient algorithm to verify $\epsilon$-safety, i.e., to verify if the attacker leaves a probability footprint.
% \cite{meira-goes:2020towards} presented an algorithm with \emph{exponential-time complexity} to solve the $\epsilon$-safety verification problem.
% We present a \emph{polynomial-time} complexity algorithm to this verification problem.
% The complexity reduction comes from transforming the $\epsilon$-safety verification problem to the \emph{shortest path problem} \citep{cormen2022introduction}.

% Our solution methodology comprises two steps and uses methods from DES and graph theory.
% In the first step, we build a structure, denoted \emph{weighted verifier}, that includes information on the attacked and unattacked controlled systems.
% This structure was inspired by the verifier automaton used for faulty diagnosis, which has information about the faulty and nonfaulty systems \citep{yoo2002polynomial}.
% Using the weights in the verifier, we find the string with the least $\epsilon$-safety value by finding the shortest path from initial to marked states in the weighted verifier.
% % This string is obtained by finding the shortest path to \emph{detection states}, i.e.,
% The solution of the shortest path problem over the verifier provides the correct value to verify $\epsilon$-safety.

% The contributions of this paper are as follows: (i) a correction in the original problem definition of finding the largest $\epsilon$ such that $\epsilon$-safety holds; and (ii) the first, to the best of our knowledge, polynomial-time complexity algorithm to verify $\epsilon$-safety.

% The rest of the paper is structured as follows: Section~\ref{sect:preliminaries} reviews the necessary definitions of PDES and supervisory control under sensor deception attacks. 
% The concept of $\epsilon$-safety and two verification problems are formulated in Section~\ref{sect:problem}. In Section~\ref{sect:solution}, we describe our polynomial-time complexity solution for the two verification problems. 
% We conclude the paper in Section~\ref{sect:conclusion}. 
% % \begin{figure}[h]
% %     \centering
% %     \includegraphics[width=0.4\textwidth]{6.1.png} 
% %     \caption{CPS} 
% %     \label{CPS} 
% % \end{figure}



\section{Motivation Example} \label{sect:motivation}
\input{2-motivating-example.tex}


\section{Modeling of Controlled Systems}\label{sect:sup} 
\input{3-sct.tex}


\section{Modeling of Control Systems under Sensor Attacks}\label{sect:preliminaries}
\input{4-sct-attack.tex}

\section{Probabilistic Intrusion Detection of Sensor Deception Attacks}\label{sect:problem}
\input{5-prob-det}

\section{Solution Verification of $\lambda$-sa detectability}\label{sect:solution}
\input{6-solution.tex}

\section{Conclusion}\label{sect:conclusion}
This paper investigated a new sensor attack detection notion using probabilistic information. 
We proposed the notion of $\lambda$-sa detectability that ensures probabilistic detection for all complete, consistent, and successful sensor attack strategies.
This notion generalizes the previously defined $\epsilon$-safety, introduced in \citep{meira-goes:2020towards,Fahim2024-wodes}, by considering general classes of sensor attack strategies instead of a single strategy as in $\epsilon$-safety.
We show that $\lambda$-sa detectability can be verified in polynomial time by reducing our verification problem to a shortest path problem in a graph.
We leave for future work considering the detection of both sensor and actuator attacks. 
%\nolinenumbers
\bibliography{romulo}% common bib file

\appendix
\section{Appendix}
\subsection{Probabilistic Parallel Composition $||_p$} \label{app:parallel_prob}
%%MOVE TO APENDIX
\begin{definition}
The probabilistic composition, $||_p$ between PDES $G$ and DFA $R$ is defined by $R||_p G = (X_R\times X_G, \Sigma, \delta_{R,G},P_{R,G}, (x_{0,R},x_{0,G}), X_{R}\times X_{m,G})$ where:
\begin{equation}
P_{R,G}((x_R,x_G),e,(y_R,y_G)) = \left\lbrace
\begin{array}{ll}
\frac{P_G(x_G,e)}{\sum_{\sigma\in\Gamma_G(x_R)\cap\Gamma_R(y_R)}P_G(x_G,\sigma)} &
\ e\in \Gamma_R(x_R)\cap\Gamma_G(x_G) \\
0 & \text{otherwise}
\end{array}
\right.
\end{equation}
\end{definition}

\subsection{Construction of attack strategy using automaton $A$}\label{app:A_aut}

An automaton $A= (X_A, \Sigma_m, \delta_{A},x_{0,A})$ encodes an attack strategy if the following condition holds:
\begin{enumerate}
    \item[(1)] $\forall x\in X_A$, $e\in \Sigma_i$. $\delta_A(x,e)! \Rightarrow \forall e\in \Sigma_m\setminus\{e\}.\  \delta_A(x,e)\hspace{-0.1cm}\not{!}$ 
    \item[(2)] $\forall x\in X_A$, $e\in \Sigma_a$. $\delta_A(x,e)! \Leftrightarrow \delta_A(x,del(e))\hspace{-0.1cm}\not{!}$ 
\end{enumerate}
Condition (1) ensures that states with an insertion event do not have any other transitions. 
Since the attacker is deterministic, it can only insert one event when it has ``decided" to insert.
Condition (2) ensures that the attacker can only delete a compromised event or not attack this event, i.e., it cannot have both options since it is deterministic.

Next, we show how to extract an attack strategy from an automaton $A$.
First, for state $q\in X_A$, the function $Ins(q)$ returns a string of insertion events that can be executed from $q$ until it reaches a state in $A$ where it cannot insert events.
The function $Ins(q)$ is defined recursively as follows:
\begin{equation}
Ins(q) = \left\{ 
\begin{array}{cc}
  eIns(\delta_A(q,e))   & \text{if } \Gamma_A(q) = \{e\} \wedge e\in \Sigma_i\\
  \epsilon  &  \text{if } \Gamma_A(q)\cap \Sigma_i = \empty
\end{array}
\right.
\end{equation}

Now, we are ready to extract a strategy from $A$.
\begin{definition}
Given DFA $A = (X_A, \Sigma_m, \delta_{A},x_{0,A})$ satisfying the conditions above.
First, the strategy for $\epsilon$ is $A(\epsilon,\epsilon) = Ins(x_{0,A})$, i.e., a string of insertions from the initial state if they are present in A.
Next, the attack strategy generated by $A$ is constructed as follows for any state $q\in X_A$ and event $e\in \Sigma$:

\begin{equation}\label{eq:}
A(q,e) = \left\lbrace
\begin{array}{ll}
del(e) Ins(\delta_A(q,del(e)) & \text{if } del(e) \in \Gamma_A(q)\\
e Ins(\delta_A(q,e)) & \text{if } e\in \Gamma_A(q)\\
\text{undefined} & \text{otherwise}
\end{array}
\right.
\end{equation}
\end{definition}
The strategy is defined for state $q$ after observing event $e\in \Gamma_A(q)\cap \Sigma$ is: (1) maintain observation of event $e$ followed by a possible string of insertion event, or (2) replace $e$ with $del(e)$ followed by a possible string of insertion event.
Lastly, we can extend the function $A(q,e)$ for strings as in Def.~\ref{def:attack_str} for any  $s\in \lang(A)$ as $A(s,e) = A(\delta_A(x_{0,A},s),e)$.
The attack strategy is also undefined for any string $s\notin \lang(A)$.

\end{document}
