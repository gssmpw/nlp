.pdf% An overview of this reduction is shown in Figure~\ref{fig:overview_solution}.
Figure~\ref{fig:overview_solution} provides an overview of our solution approach. 
First, we construct an attack system that encompasses all possible sensor attacks using the plant model $G$, supervisor $R$, and compromised event set $\Sigma_a$.
Intuitively, we construct PDES $M_n$ containing the nominal controlled behavior and $M_a$ containing all possible attacked behavior.
Next, we constructed a weighted verifier consisting of a DFA $V$ and weight function $w$.
The DFA $V$ marks the language in $L^A_{det}$ for all attacks in $\Psi_A$.
At the same time, $V$ combines the information of string executions in nominal and attack systems.
The function $w$ captures the probability ratio between executing transitions in the nominal controlled system and an attacked system.

\begin{figure}[h]
    \centering
    \includegraphics[width=1\textwidth]{Figs/overview-alg.pdf} 
    \caption{Overview on solution algorithm} 
    \label{fig:overview_solution}
\end{figure}
% The first step in this reduction is to construct an automaton that exactly marks the language in $L_{det}$.
% Inspired by the verifier automaton \citep{yoo2002polynomial}, the construction of this automaton has been first described in \citep{meira-goes:2020towards}.
% Intuitively, a verifier automaton $T$ is defined based on the nominal system $M_n$ and the attacked system $M_a$.
% The next step is to compute the ratio between an event being executed in $M_a$ versus the event in $M_n$ for every transition in $T$.
% Instead of directly computing the probability of executing a string in $L_{det}$, we compute the ratio of executing this string in $M_a$ over its projected string in $M_n$.
% Due to limited space, proofs are not omitted.
% refer to the corresponding references for more information.

Based on the weighted verifier, we pose a shortest path problem to identify the shortest path to reach a marked state in $V$, i.e., executing a string in a detection language $L^A_{det}$.
The shortest path problem outputs either: (1) a message that $V$ has ``negative cycles" or (2) a vector $\mathbf{sp}$ with the shortest path values from the initial state to each marked state in $V$.
Based on this output, we calculate the detection value $dtc$.
To make our approach concrete, we describe each step in detail using our running example.
Our goal is to verify if our running example is $0.9$-safe.



% \subsection{Overview}

\subsection{Construction of nominal system}
The nominal controlled system is built as described in Section~\ref{sect:preliminaries} using the probabilistic parallel composition $||_p$.
Formally, the nominal system is defined by $M_n = R||_pG$.
Figure~\ref{fig:M_n} depicts the nominal system for our running example.

\subsection{Construction of attacked system}\label{sub:controlled-system}
The sensor attacker disrupts the \emph{nominal} controlled system $R/G$.
Based on the attack actions, we construct the attacked plant $G_a$ and the attacked supervisor $R_a$ to include \emph{every possible attack action} with respect to $\Sigma_a$ as in \citep{meira-goes:2021synthesis}. 
In this manner, we can obtain a structure that contains all possible controlled systems under sensor attacks by composing $R_a$ and $G_a$.
% Considering these attacker actions, we model the controlled system under sensor attacks by modifying the plant $G$ and supervisor $R$ .

The attacked plant $G_a$ is a copy of $G$ with more transitions based on compromised sensors $\Sigma_a$.
Insertion events are introduced to $G_a$ as self-loops with probability $1$ since fictitious insertions do not alter the state of the plant with probability $1$.
On the other hand, deletion events are defined in $G_a$ with the same probability as their legitimate events because the attacker can only delete an event if this event has been executed in the plant $G$.
The following insertion and deletion transitions are added to $G_a$ for any $e\in \Sigma_a$.
\begin{align}
\delta_{G_a}(x,ins(e)) = x, \quad & P_{G_a}(x,ins(e),x) = 1\label{eq:ins_plant}\\
\delta_{G_a}(x,del(e)) = y, \quad & P_{G_a}(x,del(e),y) = P_{G}(x,e,y), \text{ if } \delta_G(x,e)!\label{eq:del_plant}
\end{align}
Figure~\ref{fig:Ga} shows the $G_a$ for our running example, the new transitions are highlighted in red.
Insertions in deadlock states are omitted for illustration purposes.

\begin{figure}[thpb]
\begin{subfigure}[t]{0.45\columnwidth}
\centering
\includegraphics[width=1\columnwidth]{Figs/Ga.png}
\caption{$G_a$}
\label{fig:Ga}
\end{subfigure}
\ 
\begin{subfigure}[t]{0.45\columnwidth}
\centering
\includegraphics[width=0.71\columnwidth]{Figs/Ra.png}
\caption{$R_a$}
\label{fig:Ra}
\end{subfigure}
\\
\begin{subfigure}[t]{1\columnwidth}
\centering
\includegraphics[width=0.55\columnwidth]{Figs/Ma.png}
\caption{$M_a$}
\label{fig:Ma}
\end{subfigure}
\caption{Attacked plant, supervisor, and system}
\label{fig:attacked-models}
\vspace{-2em}
\end{figure}

% For each transition $y = \delta_G(x,e)$ in $G$, the following deletion transitions are added to $G_a$.
% \begin{align}
% \end{align}
% Equation~\ref{eq:del_plant} models attacker deletions with the same probability as their legitimate events.

% Figure~\ref{fig:attacked-plant} shows the attacked plant for our running example where new events are highlighted in red.
% For illustration purposes, we omit the transitions in states $0$ and $3$ since they are deadlock states.
Similar to the construction of $G_a$, we define the attacked supervisor $R_a$ as a DFA.
For the supervisor, insertions are observed as legitimate events while deletions do not change the state of the supervisor.
For any event $e\in \Sigma_a$, the following transitions are added to $R_a$ on top of those already in $R$.
\begin{align}
\delta_{R_a}(x,ins(e)) &= \delta_R(x,e) \text{ if } \delta_R(x,e)! \label{eq:ins_sup}\\
\delta_{R_a}(x,del(e)) &= x \text{ if } \delta_R(x,e)! \label{eq:del_sup}
\end{align}
Figure~\ref{fig:Ra} shows the attacked supervisor for our running example.
% Again for illustration purposes, we omit transitions from state~$3$.

All possible controlled systems under attack are represented by $M_a = R_a||_p G_a$.
Figure~\ref{fig:Ma} shows the system $M_a$ for our running example.
Recall that states in $M_a$ are of the format $(x_{R},x_{G})$ for $x_R\in X_{R_a}$ and $x_G\in X_{G_a}$.
Note that the attacker can cause a mismatch between these states which was not possible in the nominal $M_n$ as in Fig.~\ref{fig:M_n}.
% Note that, the system $R_a/G_a$ includes every possible sensor attack action since the model considers the worst-case attack scenario in which the attacker can attack whenever it is possible.
Although this model is simple, it is well-suited to the problem we are investigating since we want to detect every possible attack strategy. 
Next, we have two propositions that link the language of $M_a$ with languages generated by attacked systems $\lang(S_A/G)$ for a given $A$.
The first proposition shows that a complete and consistent attack strategy generates a behavior in $M_a$.
\begin{proposition}\label{prop:Sa-Ma}
Let attack strategy $A$ be complete and consistent.
For every $s\in \lang(S_A/G)$, then $A(s) \in \lang(M_a)$.
\end{proposition}
\begin{proof}
It follows by the construction of $G_a$, $R_a$, and by $A$ being a complete and consistent attack strategy.
\end{proof}

Next, every string in $M_a$ can be generated by a complete and consistent attack strategy.
\begin{proposition}\label{prop:Ma-Sa}
For every $s\in \lang(M_a)$, there exists $A$ complete and consistent such that $\Pi^G(s)\in \lang(S_A/G)$.
\end{proposition}
\begin{proof}
We start by showing $\Rightarrow$ by constructing an attack strategy $A$ that generates $s\in \lang(M_a)$.
First, we can break $s$ into $0\leq k\leq|s|$ substrings such that $s = t_1\dots t_k$.
Moreover, each substring satisfies: $t_1\in \Sigma_i^*$ and $t_i\in (\Sigma\cup\Sigma_d)\Sigma_i^*$ for $1<i\leq k$.

Intuitively, we are breaking $s$ into $k$ substrings to be generated by the attack strategy $A$.
Recall that $A$ needs to satisfy the conditions in Def.~\ref{def:attack_str}.
Attack $A$ will output each of these $t_i$, e.g., $A(\epsilon,\epsilon) = t_1$, and $A(t_1,\mask(t_2[1])) = t_2$.
We construct $A$ for $s$ as follows:
\begin{align*}
A(\epsilon,\epsilon) &= t_1\\
A(t_1\dots t_j,\mask(t_{j+1}[1])) &= t_{j+1} \forall\ 1<j\leq k-1
\end{align*}
For other strings $t\in\Sigma_m^*\setminus\{\epsilon\}$ and event $e\in\Sigma$, the attack strategy is $A(t,e)=e$.
Attack strategy $A$ is complete and consistent by construction.

Now, we show that $\Pi^G(s)\in \lang(S_A/G)$ by showing that $\Pi^G(t_1\dots t_j)\in \lang(S_A/G)$.
We show this by recursively showing that $te\in \lang(G)$, $t\in \lang(S_A/G)$ and $e\in S_A(t)$ which implies that $te\in \lang(S_A/G)$.  
By definition of $\lang(S_A/G)$, $\epsilon = \Pi^G(t_1)\in \lang(S_A/G)$.

By construction of $t_1$ and $t_2$, we have $\Pi^G(t_1t_2) = \mask(t_2[1])$.
Now by construction of $R_a$, it follows that $x_R = \delta_{R_a}(x_{0,R_a},t_1) = \delta_R(x_{0,R},\Pi^S(t_1))$. 
Since $t_1t_2 \in \lang(M_a)$ and the definition of $R_a||_pG_a$, we have that $t_2[1]\in \Gamma_{R_a}(x_R)$ and $\mask(t_2[1])\in \Gamma_{R}(x_R)$.
Thus, the event $\mask(t_2[1])$ is allowed by $S(A(\epsilon,t_1)) = S_A(\epsilon)$.
As $t_1t_2[1]\in \lang(G_a)$, then $\Pi^G(t_1t_2) = \mask(t_2[1])\in \lang(G)$ by construction of $G_a$.
In summary, we have $\epsilon\in \lang(S_A/G)$, $\Pi^G(t_1t_2) = t_2[1]\in \lang(G)$, and $t_2[1]\in S_A(t_1)$, which implies that $\Pi^G(t_1t_2)\in \lang(S_A/G)$.
By similar recursive arguments, we can show that $\Pi^G(t_1\dots t_j) = t_2[1]\dots t_j[1]\in \lang(S_A/G)$ for any $1<j\leq k$.
\end{proof}


\subsection{Constructing the Weighted Verifier}
Once $M_a = R_a||_p G_a$ is constructed, we identify all possible languages $L_{det}^A$ for any $A\in \Pi_A$.
Recall that $L_{det}^A$ is defined by the shortest strings that are one controllable event away from a critical state.
Based on $M_a$, we define the detection states as follows:
\begin{equation}
X_{det} = \{(x_R,x_G)\in X_{M_a}\mid \exists e\in (\Sigma_d\cap\Sigma)\text{ s.t. } (e \in \Gamma_{R_a}(x_R))\wedge (\delta_{G_a}(x_{G},e)=x_{crit}\}
\end{equation}
In the $M_a$ in Fig.~\ref{fig:Ma}, the detection state is $(2,1)$ since the critical state $(1,0)$ is reached via controllable event $a$. 
The detection states $X_{det}$ are related to $L_{det}^A$ since they are states one controllable event away from a critical state.

% This relationship is captured by the following proposition.




Next, we need a structure where we can directly compare string executions in $S_A/G$ versus $S/G$.
Inspired by the verifier automaton in \citep{yoo2002polynomial}, we define the weighted verifier, DFA $V$, and weight function $w$.
The verifier automaton $V$ marks the strings in $L^A_{det}$ for any $A\in \Psi_A$.
Moreover, weights $w$ contain the probability information of executing transitions in attacked systems $S_A/G$ and nominal system $S/G$.
We start by constructing the verifier $V$ similarly to the steps described in \citep{meira-goes:2020towards}. 
% Let $M_n = R||_p G$ denote the nominal system and $M_a = R_a||_p G_a$ denote the attacked systems.
% in $\lang(M_n)\cap\Pi^S(\lang(M_a))$.
% This language captures strings in the nominal system that can be also generated by the attacked system, i.e., ambiguous strings.
% Moreover, in verifier $V$, we mark detection strings $L_{det}$.

\begin{definition}\label{def:verifier}
Given $M_n$, $M_a$, and the detection states $X_{det}$, we define verifier $V$ as: 
(1) $X_{V}\subseteq X_{R}\times X_G \times X_{R_a}\times X_{G_a}$; (2) $x_{0,V} = (x_{0,R},x_{0,G},x_{0,R_a},x_{0,G_a})$; (3) $\delta_{V}((x_1,x_2,x_3,x_4),e) = (y_1,y_2,y_3,y_4)$ if $\delta_{R,G}((x_1,x_2),\Pi^S(e)) = (y_1,y_2)$ and $\delta_{R_a,G_a}((x_3,x_4),e) = (y_3,y_4)$  for $e\in \Sigma_m$, $x_1,y_1\in X_R$, $x_2,y_2\in X_G$, $x_3,y_3\in X_{R_a}$, and $x_4,y_4\in X_{G_a}$ with $(x_3,x_4)\not\in X_{det}$, otherwise is undefined; and (4) $X_{m,V} = \{(x_1,x_2,x_3,x_4) \mid \ (x_3,x_4)\in X_{det}\}$.
% \begin{enumerate}
%     \item $X_{V}\subseteq X_{M_n}\times X_{M_a}$
%     \item $x_{0,V} = (x_{0,M_n},x_{0,M_a})$
%     \item $\delta_{V}((x_1,x_2),e) = (y_1,y_2)$ if $\delta_{M_n}(x_1,\Pi^S(e)) = y_1$ and $\delta_{M_a}(x_2,e) = y_2$ for $e\in \Sigma_m$ and $(x_1,x_2),(y_1,y_2)\in X_{M_n}\times X_{M_a}$ with $x_2\not\in X_{det}$;
%     \item $X_{m,V} = \{(x_1,x_2) \mid \ x_2\in X_{det}\}$.
% \end{enumerate}
\end{definition}

% In \citep{meira-goes:2020towards}, it was shown that $V$ marks  $L_{det}$.
With abuse of notation, we only describe $V$ by its accessible and co-accessible parts, i.e., the $Trim(V)$ operator as in \citep{Lafortune:2021} is applied after Def.~\ref{def:verifier}.
Figure~\ref{fig:verifier} depicts the verifier $V$ constructed based on Def.~\ref{fig:verifier}.
To construct this automaton, we start from the initial state $x_{0,V}$ and perform a reachability analysis to obtain the next states via $\delta_V$.
For example from state $(2,2,2,2)$ and event $a$, state $(1,1,1,1)$ is reached.
In this scenario, $ego$ moves one cell closer to $adv$ in both systems.
From state $(1,1,1,1)$ and event $ins(b)$, state $(2,2,2,1)$ is reached.
In this case, the nominal system moves to state $(2,2)$ since the insertion $ins(b)$ is observed as event of $b$.
However, the attacked system moves to state $(2,1)$ where the relative distance remains $1$.
State $(2,2,2,1)$ is a marked state since state $(2,1)$ is a detection state.
Next, we discuss the weights in the verifier.

\begin{figure}[thpb]
\centering
\includegraphics[width=0.65\columnwidth]{verifier.png}
\caption{Weighted verifier $V$}
\label{fig:verifier}
\end{figure}

% The automaton $T$ in Fig.~\ref{fig:DFA_t} has deadlock states, i.e., $Uns$ states.
% For this reason, we define the verifier $V$ using the coaccessible automaton of $T$, $CoAc(T)$ where the operator $CoAc$ is defined as in \citep{Lafortune:2021}.
We define weights for verifier $V$ based on the transition probabilities in $M_n$ and $M_a$.
For example, the transition in $V$ from state $(1,1,1,1)$ to state $(2,2,2,1)$ via event $ins(b)$ captures the information of the execution in $M_n$ and in $M_a$.
In the case of $M_n$, the nominal system observes event $b$, which has a probability of $0.111\dots$, Fig.~\ref{fig:M_n}.
In the attacked system, the probability of executing $ins(b)$ is equal to $1$, Fig.~\ref{fig:Ma}.
Thus, the ratio of executing this transition in the attacked system is $9$ times more likely than executing in the nominal system, i.e., $1/0.111\dots = 9$.
We use the logarithm of this ratio as a weight for this transition as shown in Fig.~\ref{fig:verifier}.
The use of the logarithm will become clear when we pose the shortest path problem.
% Figure~\ref{fig:verifier} shows the weighted verifier where weights are shown in blue.

Formally, we define the weight function $w:X_V\times \Sigma_m\times X_V\rightarrow \mathbb{R}$ for each transition $\delta_V((x_1,x_2,x_3,x_4),e) = (y_1,y_2,y_3,y_4)$ as:

\begin{equation}\label{eq:ratio}
w((x_1,x_2,x_3,x_4),e,(y_1,y_2,y_3,y_4)) = \log \frac{P_{M_a}((x_3,x_4),e,(y_3,y_4)}{P_{M_n}((x_1,x_2),\Pi^S(e),(y_1,y_2))}
\end{equation}
In Eq.~\ref{eq:ratio}, we have that $P_{M_n}((x_1,x_2),\epsilon,(y_1,y_2)) = 1$, i.e., the probability of executing the empty string is always one.


Based on the verifier $V$, we calculate the weights as shown in Fig.~\ref{fig:verifier} using Eq.~\ref{eq:ratio}.
For example, the weight for transition $\delta_V((2,2,2,2),b) = (1,1,1,1)$ is equal to $\log{(1)}=0$ since $P_{M_a}((2,2),b,(1,1)) = P_{M_n}((2,2),b,(1,1)) = 0.1$.

Propositions~\ref{prop:Sa-Ma} and~\ref{prop:Ma-Sa} have linked the strings in $M_a$ to strings in $S_A/G$ for an attack strategy.
Next, we show that the strings in $\lang_m(V)$ are related to strings in a detection language $L_A^{det}$.

\begin{proposition}\label{prop:det_lang}
A string $s\in \lang_m(V)$ if and only if $\exists A\in \Psi_A$ such that $\Pi^G(s)\in L_{det}^A$.
\end{proposition}
\begin{proof}
This proposition follows from Propositions~\ref{prop:Sa-Ma} and~\ref{prop:Ma-Sa} and the construction of $V$ and its detection states $X_{det}$    
\end{proof}

\subsection{Finding the Shortest Path}
The verifier automaton $V$ has the information to find the attack strategy $A$ and the string in $L^A_{det}$ with the smallest intrusion detection value, $dtc$, as in Def.~\ref{def:lambda-sa-det}.
This string is related to the shortest path from the initial state to any detection state, i.e., the string executed by the path.
To show this relationship, we present the relationship between the weight of a path in $V$ and the probabilities of executing this path in $M_n$ and $M_a$

Let us select the path $p = (2,2,2,2)a(1,1,1,1)ins(b)\allowbreak(2,2,2,1)$ from the verifier $V$ in Fig.~\ref{fig:verifier}.
This path is generated using attack strategy $A_1$ in Fig.~\ref{fig:A1}.
The weight of this path is the sum of each transition weight: $$\log(\frac{0.1}{0.1})+\log(\frac{1}{0.11\dots})=\log(1)+\log(9) = \log(1\times 9) = \log(9)$$
In Eq.~\ref{eq:ratio}, we define transition weights as the ratio of transition probabilities in $M_a$ over  $M_n$.
We rewrite the weight of path $p$:
\begin{align*}
\log(\frac{0.1}{0.1})+\log(\frac{1}{0.11\dots}) &= \log(\frac{0.1}{0.011\dots})\\&=\log(\frac{L_p(S_{A_1}/G)(a)}{L_p(S/G)(ab)})\\& =\log(9)
\end{align*}
Executing $p$ in $M_a$ is $9$ times more likely than executing in $M_n$.
% When the detection observes the string $ab$, it has high confidence that it was executed by an attacked system in $M_a$.

By finding the shortest path in $V$, we find the smallest ratio of executing a path in $M_a$ over executing in $M_n$.
The shortest path is defined as:
\begin{definition}[Shortest path]\label{def:shortest-path}
Given verifier $V$ with weight function $w$, the shortest marked path is defined as the path with the shortest sum of weights from the initial state to a marked state in $V$:
$$\inf_{\rho:=x_0e_0\dots x_{|\rho|}\in Paths_m(V)}\sum_{i=0}^{i<|\rho|}w(x_i,e_i,x_{i+1})$$
where $Path_m(G)$ is a path starting in $x_{0,G}$ and ending in $X_{m,G}$, $Path_m(G) = \{x_0e_0\dots x_n\in (X_G\times \Sigma)^*X_G \mid  x_0 = x_{0,G}\wedge x_{i+1} = \delta_G(x_i,e_i), i<n \wedge x_n\in X_{m,G}\}$.
\end{definition}

% We also define a \emph{marked path} in $G$.
% Intuitively, a marked path in $G$ is a finite sequence of (state, event) pairs starting in $x_{0,G}$, satisfying $\delta_G$, and ending in a marked state.
% \begin{definition}(Marked path)
% A \emph{marked path} in $G$ is a sequence $\rho = x_0e_0\dots x_{n-1}e_{n-1}x_n\in (X_G\times \Sigma)^*X_G$ such that $x_0 = x_{0,G}$, $x_{i+1} = \delta_G(x_i,e_i)$ for $i<n$, and $x_n\in X_{m,G}$.
% The length of $\rho$ is defined by $|\rho| = n+1$. 
% The set of all marked paths in $G$ is denoted as $Paths_m(G)$.
% \end{definition}
The following proposition formally ties the weight of a path in $V$ with the probability ration of executing a string in $M_a$ and $M_n$.
\begin{proposition}\label{prop:weight-Ma}
Given verifier $V$ and weight function $w$, for any $s\in \lang_m(V)$ with path $x_0s[1]x_1\dots s[|s|]x_{|s|}$ then
$$\sum_{i=0}^{|s|-1} w(x_i,s[i+1],x_{i+1}) = \log \left(\frac{L_p(S_A/G)(\Pi^G(s))}{L_p(S/G)(\Pi^S(s))} \right)$$
where attack strategy $A$ is constructed as in the proof of Prop.~\ref{prop:Ma-Sa}.
\end{proposition}
\begin{proof}
This result follows by the definition of the verifier, the weight function, and the logarithm property of multiplication, i.e., $log(ab) = log(a) +log(b)$.
Recall that each verifier state $x_i$ is defined by $(x_{i,1},x_{i,2},x_{i,3},x_{i,4})$ (Def.~\ref{def:verifier}).
It follows that:
\begin{align*}
\sum_{i=0}^{|s|-1}w(x_i,s[i+1],x_{i+1}) &= \sum_{i=0}^{|s|-1} \log\left(\frac{P_{M_a}((x_{i,3},x_{i,4}),s[i+1],(x_{i+1,3},x_{i+1,4})}{P_{M_n}((x_{i,1},x_{i,2}),\Pi^S(s[i+1]),(x_{i+1,1},x_{i+1,2}))}\right)\\
&= \log\left(\Pi_{i=0}^{|s|-1} \frac{P_{M_a}((x_{i,3},x_{i,4}),s[i+1],(x_{i+1,3},x_{i+1,4})}{P_{M_n}((x_{i,1},x_{i,2}),\Pi^S(s[i+1]),(x_{i+1,1},x_{i+1,2}))}\right)
\end{align*}
By Prop.~\ref{prop:Ma-Sa}, we can construct an attack strategy $A$ such that $\Pi^G(s)\in \lang(S_A/G)$.
Moreover, by construction of $M_a$, we have that $\Pi_{i=0}^{|s|-1} P_{M_a}((x_{i,3},x_{i,4}),s[i+1],(x_{i+1,3},x_{i+1,4}) = L_p(S_A/G)(\Pi^G(s))$.
And by construction of $M_n$, we have $\Pi_{i=0}^{|s|-1} P_{M_n}((x_{i,1},x_{i,2}),\Pi^S(s[i+1]),(x_{i+1,1},x_{i+1,2}) = L_p(S/G)(\Pi^S(s))$.
Therefore, we have:
\begin{align*}
\sum_{i=0}^{|s|-1}w(x_i,s[i+1],x_{i+1})  = \log\left(\frac{L_p(S_A/G)(\Pi^G(s))}{L_p(S/G)(\Pi^S(s))}\right)
\end{align*}
\end{proof}
% Although Dijkstra's algorithm has better time complexity than Bellman-Ford, it disallows negative cycles in the graph.
% In the weighted verifier $V$, it is possible to have negative transition weights when the probability of executing the transition in $M_n$ is larger than executing in $M_a$, i.e., $log(r)<1$ when $r<1$ in Eq.~\ref{eq:ratio}.
% Therefore, it is possible to have negative cycles in the verifier $V$.
% For this reason, we use the Bellman-Ford algorithm to compute the shortest path in $V$.

The shortest path problem is a well-known problem in graph theory with polynomial-time algorithm solutions, e.g., Bellman-Ford, and Dijkstra's algorithms \citep{cormen2022introduction}.
Since $V$ can have negative and positive weights, we use the Bellman-Ford algorithm to compute the shortest path in $V$.
The Bellman-Ford algorithm outputs either: (1) a vector, $\mathbf{sp} \in \mathbb{R}^{|X_{m,V}|}$, storing the smallest real values for paths from the initial state to marked states, or (2) an output saying that the graph has a ``negative cycle."

Back to our running example, we run the Bellman-Ford algorithm using the weighted verifier $V$ depicted in Fig.~\ref{fig:verifier}.
The verifier does not have negative cycles since all cycles have $0$ weight, i.e., $\log(1) = 0$.
The shortest path returns the vector $\mathbf{sp} = [\log(9)]$.

\subsection{Extracting the Intrusion Detection Value}
Solving the shortest path problem for the weighted verifier $V$ gives us the information to solve Problems~\ref{prob:ver-lsa} and~\ref{prob:optimal-lsa}.
Herein, we describe the solution for Problem~\ref{prob:ver-lsa}.
The solution for Problem~\ref{prob:optimal-lsa} follows the same steps.

The shortest path problem can return two possible outputs: (1) a vector, $\mathbf{sp}\in \mathbb{R}^{|X_{m,V}|}$, or (2) ``negative cycle."
In the case of output (2), Problem~\ref{prob:ver-lsa} returns that $M_n$ is not $\lambda$-sa detectable.
The shortest path can be arbitrarily small when $V$ has a negative cycle.
We can select a string in $M_a$ that reaches a marked state that its probability of execution is much smaller than in $M_n$, i.e., $L_p(M_a)(s)<< L_p(M_n)(\Pi^S(s))$.
In other words, we can construct an attacker $A$ as in Prop.~\ref{prop:Ma-Sa} that generates this string with an arbitrarily small detection value. 
% , i.e., it goes to $-\infty$ which means that the execution ratio goes to $0$.
% In consequence, the execution ratio of a string goes to $0$.
% The probability of executing this string in $M_a$ is much smaller than the probability of executing the projected string in $M_n$.
% Consequently, the $int$ value in Eq.~\ref{eq:likelihood} goes to $0$.
In this scenario, there exists an attacker that hides its probabilistic trace to be negligible.
% This result is described by the following theorem.

\begin{theorem}\label{theo:negative-cycle}
Let $M_n$, $M_a$, $\lambda \in (0.5,1]$ be given.
If the Bellman-Ford algorithm returns that the weighted verifier $V$ has a negative cycle, then $M_n$ is not $\lambda$-sa detectable.
\end{theorem}

\proof
When $V$ has a negative cycle, the shortest path has a limit as $-\infty$.
Thus, we can find a path $s\in \lang_m(V)$ with path $\rho = x_0s[1]x_1\dots s[|s|]x_{|s|+1}$ with weight smaller than $\log(\frac{\lambda}{1-\lambda})$.
$$\sum_{i=0}^{i<|s|}w(x_i,s[i],x_{i+1})< \log\left(\frac{\lambda}{1-\lambda}\right)$$
% It follows that:
% \begin{align*}
% \sum_{i=0}^{i<|s|}w(x_i,s[i],x_{i+1}) = \sum_{i=0}^{i<|s|} \log\left(\frac{P_{M_a}((x_{i,3},x_{i,4}),s[i],(x_{i+1,3},x_{i+1,4})}{P_{M_n}((x_{i,1},x_{i,2}),\Pi^S(s[i]),(x_{i+1,1},x_{i+1,2}))}\right)< \log\left(\frac{\lambda}{1-\lambda}\right)
% \end{align*}
% By Prop.~\ref{prop:Ma-Sa}, we can construct an attack strategy $A$ such that $s\in \lang(S_A/G)$.
% Moreover, by construction of $M_a$, we have that $\Pi_{i=0}^{|s|} P_{M_a}((x_{i,3},x_{i,4}),s[i],(x_{i+1,3},x_{i+1,4}) = L_p(S_A/G)(\Pi^G(s))$.
% And by construction of $M_n$, we have $\Pi_{i=0}^{|s|} P_{M_n}((x_{i,1},x_{i,2}),\Pi^S(s[i]),(x_{i+1,1},x_{i+1,2}) = L_p(S/G)(\Pi^S(s))$.
Using Prop.~\ref{prop:weight-Ma}, we have:
\begin{align*}
\log\left(\frac{L_p(S_A/G)(s)}{L_p(S/G)(\Pi^S(s))}\right)< \log\left(\frac{\lambda}{1-\lambda}\right)\\
\frac{L_p(S_A/G)(\Pi^G(s))}{L_p(S/G)(\Pi^S(s))}<\left(\frac{\lambda}{1-\lambda}\right)
\end{align*}
Manipulating the equation above, we get:
\begin{align*}
\frac{L_p(S_A/G)(\Pi^G(s))}{L_p(S_A/G)(\Pi^G(s))+L_p(S/G)(\Pi^S(s))}< \lambda 
\end{align*}
Since $s\in \lang_m(V)$ and by Prop.~\ref{prop:det_lang}, the system $M_n$ is not $\lambda$-sa detectable.
\endproof

In the case the Bellman-Ford algorithm returns the vector $\mathbf{sp}\in \mathbb{R}^{|X_{m,V}|}$, we can find the value $dtc$ in Eq.~\ref{eq:likelihood}.
Depending on this calculated value, we return (i) $M_n$ is $\lambda$-sa detectable, or (ii) $M_n$ is \textbf{not} $\lambda$-sa detectable.
We calculate the value $dtc$ with the lowest value $val$ in the vector $\mathbf{sp}$, i.e., $val = \min \textbf{sp}$.
\begin{align}
\frac{L_p(S_A/G)(\Pi^G(s))}{L_p(S/G)(\Pi^S(s))} = \exp(val)\nonumber\\
L_p(S_A/G)(\Pi^G(s)) = \exp(val)L_p(S/G)(\Pi^S(s))\label{eq:relation-ratio}
\end{align}
Where $s$ is the string in $V$ generated by the shortest path value obtained by the Bellman-Ford algorithm.
Using the relation in Eq.~\ref{eq:relation-ratio}, Eq.~\ref{eq:likelihood} gives us the value of $dtc$.
\begin{align}
dtc &= \frac{\exp(val)L_p(S/G)(\Pi^S(s))}{L_p(S/G)(\Pi^S(s))(1+\exp(val))}\nonumber \\
& =\frac{exp(val)}{1+exp(val)} \label{eq:final-int}
\end{align}

Therefore, the shortest path value $val$ to a marked state in $V$ provides us the $dtc$ as in Def.~\ref{def:lambda-sa-det}.
Formally, we have the following theorem.

\begin{theorem}\label{theo:vector-shortest}
Let $M_n$, $M_a$, $\lambda\in (0.5,1]$ be given.
Also, let the Bellman-Ford algorithm for the weighted verifier $V$ return vector $\mathbf{sp}\in \mathbb{R}^{|X_{m,V}|}$ with $val$ being the lowest value in $\mathbf{sp}$.
The system $M_n$ is $\lambda$-sa detectable if and only if 
\begin{equation}\label{eq:thm}
\frac{exp(val)}{1+exp(val)}\geq \lambda
\end{equation}
\end{theorem}

\proof \quad 
We start by proving $\Rightarrow$: If $M_n$ is $\lambda$-sa detectable, then Eq.~\ref{eq:thm} holds.
First, we assume that $M_n$ is  $\lambda$-sa detectable, which implies that $dtc = \inf_{A\in\Psi_A}\inf_{s\in L^A_{det}} det(s) \geq \lambda$.
Therefore, there exists an attack strategy $A\in \Psi_A$ and string $s\in L_{det}^A$ such that for all other $A'\in \Psi_A$ and $t\in L_{det}^{A'}$: $det(s)\leq det(t)$.
Let $A$ and $s$ be the attack strategy and string that satisfy the proposition above.
Using Prop.~\ref{prop:Sa-Ma}, we can find a string $u = A(s)\in \lang_m(V)$ such that $\Pi^G(u) = s$.
By Prop.~\ref{prop:weight-Ma}, we have: 
\begin{equation}\label{eq:w_u}
w_u = \exp\left(\sum_{i=0}^{|u|-1} w(x_i,u[i+1],x_{i+1})\right)  = \frac{L_p(S_A/G)(s)}{L_p(S/G)(\Pi^S(s))}
\end{equation}
where $u$ generates path $x_0u[1]\dots u[|u|]x_{|u|}$ in $V$.
Similar to Eq.~\ref{eq:final-int}, we can write the detection value of $s$ as $det(s) = \frac{w_u}{1+w_u}$.
Since we assumed that $M_n$ is $\lambda$-sa detectable $\frac{w_u}{1+w_u}\geq \lambda$.
It remains to be proved that $w_u = \exp(val)$.

We show that $w_u = \exp(val)$ by contradiction.
By the solution of the Bellman-Ford algorithm, we can construct a string $v\in \lang_m(V)$ such that $w_v = \exp(val)$, where $w_v$ is the weight of string $v$ calculated as in Eq.~\ref{eq:w_u}
Assume that $w_u\neq \exp(val)$.
If $w_u<\exp(val)$, we found a new path in $V$ with a weight smaller than the shortest path $val$, i.e., a contradiction.
If $w_u>\exp(val)$, we found a string $v\in \lang_m(V)$ with weight smaller than $w_u$.
Using Prop.~\ref{prop:weight-Ma}, we can calculate $det(\Pi^G(v)) = \frac{w_v}{w_v+1}$.
Since $w_u>w_v$, $w_u>0$, and $w_v>0$, it follows: 
\begin{equation}\label{eq:ineq-cont}
det(s) = det(\Pi^G(u)) = \frac{w_u}{w_u+1}> \frac{w_v}{w_v+1}>det(\Pi^G(v))
\end{equation}
However, Eq.~\ref{eq:ineq-cont} contradicts that $det(s)$ is the smallest detection value as we assumed above.
Therefore, it must be that $w_u = w_v = \exp(val)$ which concludes our $\Rightarrow$ proof.

Next, we need to prove $\Leftarrow$: If Eq.~\ref{eq:thm} holds, then $M_n$ is $\lambda$-sa detectable.
We can prove this statement by contradiction.
Let us assume that Eq.~\ref{eq:thm} holds and that $M_n$ \emph{is not} $M_n$ $\lambda$-sa detectable.
Since $M_n$ is not $\lambda$-sa detectable, then there exist an attack strategy $A$ and string $s\in L_{det}^A$ such that $det(s)<\lambda$.
Using Prop.~\ref{prop:Sa-Ma}, we can find an string $t\in \lang_m(V)$ such that $A(s) = t$ and $det(s) = \frac{w_t}{1+w_t}$ where $w_t$ is calculated as in Eq.~\ref{eq:w_u}.
We show that $w_t$ will be smaller than $exp(val)$, which contradicts the assumption that $val$ is the smallest weight in $V$.

Let $v\in \lang_m(V)$ such that $w_v = exp(val)$, where $w_v$ is the weight of string $v$ similar to Eq.\ref{eq:w_u}.
With $w_t$, it follows that $det(\Pi^G(v)) = \frac{w_v}{w_v+1}>\lambda$ by our assumption that Eq.~\ref{eq:thm} holds.
Using $det(s)<\lambda$ and $det(\Pi^G(v))>\lambda$, it follows that  $\frac{w_t}{1+w_t}<\frac{w_v}{w_v+1}$.
The last inequality implies that $w_t<w_v = \exp(val)$ since $w_v>0$ and $w_t>0$, i.e., string $t$ has weight less than $val$.
However, $val$ is the smallest weight in $V$, i.e., a contradiction.
Therefore, if Eq.~\ref{eq:thm} holds, then $M_n$ is $\lambda$-sa detectable.
This concludes our proof.
\endproof

Back to our running example, the shortest path from the Bellman-Ford algorithm for verifier in Fig.~\ref{fig:verifier} is $\mathbf{sp} = \log(9)$.
% In this scenario, the algorithm returned $\mathbf{sp} = [\log(9)]$.
Since there is a single marked state, $val = \log(9)$.
Following Thm.~\ref{theo:vector-shortest}, we have:
\begin{equation}
\frac{\exp(val)}{1+\exp(val)}=0.9\geq 0.9
\end{equation}
Thus, the system $M_n$ is $0.9$-safe.

\subsection{Complexity of $\lambda$-sa detectability}
Our last result is related to the complexity of solving Problems~\ref{prob:ver-lsa} and~\ref{prob:optimal-lsa} due to the Bellman-Ford algorithm.
\begin{theorem}\label{theo:complexity}
Solving Problem~\ref{prob:ver-lsa} has worst-case time-complexity of $O(|X_V|^2) = O(|X_G\times X_R|^4)$.
\end{theorem}
\begin{proof}
This result follows by the complexity of the Bellman-Ford algorithm and the construction of $V$.
\end{proof}
