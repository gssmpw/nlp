\begin{algorithm*}[h]
\caption{Generate Mask from Keypoints}
 \label{algo:blocking}
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\Input{$KP$: array of shape $(F \times J, 2)$ containing coordinate of keypoints in $[x, y]$  \\
       $H$: Height of the original heatmap \\
       $W$: Width of the original heatmap \\
       $D_S$: Size of spatial resolution \\
       $min\_masked\_number$: Minimum number of points to be randomly selected for masking \\
       $max\_masked\_number$: Maximum number of points to be randomly selected for masking}
\Output{$final\_mask$: A single mask of shape $(total\_rows\_squares, total\_cols\_squares)$ with 1s where squares are masked}

$total\_rows\_squares \gets \left\lfloor \frac{H}{S} \right\rfloor + \text{(1 if } H \% D_S \text{ else 0)}$\;

$total\_cols\_squares \gets \left\lfloor \frac{W}{S} \right\rfloor + \text{(1 if } W \% D_S \text{ else 0)}$\;

$final\_mask \gets \text{zeros}((total\_rows\_squares, total\_cols\_squares))$\;

$total\_points \gets F \times J$

$\alpha \gets \text{max}(1, \text{min}(min\_masked\_number, total\_points))$\;

$\beta \gets \text{min}(max\_masked\_number, total\_points)$\;

$num\_block\_to\_mask \gets \text{RandomSample}(\{\alpha, \alpha+1, \ldots, \beta, \beta + 1\}, 1)$\;

%$selected\_indices \gets \text{random.choice}(\text{range}(total\_points), size=num\_to\_mask)$\;

$selected\_indices \gets \text{RandomSample}\left(\{0, 1, 2, \ldots, total\_points - 1\}, num\_block\_to\_mask\right)$

$selected\_points \gets KP[selected\_indices]$\;

\ForEach{$(x, y) \in selected\_points$}{
    $col \gets \left\lfloor \frac{x}{D_S} \right\rfloor$\;
    
    $row \gets \left\lfloor \frac{y}{D_S} \right\rfloor$\;
    
    \If{$0 \leq row < total\_rows\_squares$ \textbf{and} $0 \leq col < total\_cols\_squares$}{
        $final\_mask[row, col] \gets 1$\;
    }
}

\Return $final\_mask$\;
\end{algorithm*}