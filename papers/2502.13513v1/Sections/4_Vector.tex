\section{Attack Taxonomy and Analysis}\label{sec:vector}

In this section, we present our taxonomy of attacks caused by phantom events and provide detailed
explanations as well as detection rules for each attack.

\begin{table*}[ht]
\centering
\caption{Mapping relationship between attack vectors and related modules.}
\label{tab:attack-classification}
\begin{tabular}{l|l|p{8.5cm}|p{3cm}}
\toprule
\textbf{Level} & \textbf{Attacks} & \textbf{Descriptions} & \textbf{Related Modules} \\
\midrule
\multirow{2}{*}{\textbf{On-chain}}
& event counterfeiting & Use existing contracts to emit Phantom events & \(\bm{\mathcal{M}}_{TS}\), \(\bm{\mathcal{M}}_{O}\) \\
\cmidrule{2-4}
& inconsistent logging & Inconsistencies between database and blockchain event emissions & \(\bm{\mathcal{M}}_{SC}\), \(\bm{\mathcal{M}}_{TS}\), \(\bm{\mathcal{M}}_{D}\) \\
\midrule
\multirow{3}{*}{\textbf{Off-chain}}
&contract imitation & Deploy a malicious contract to emit Phantom events & \(\bm{\mathcal{M}}_{SC}\), \(\bm{\mathcal{M}}_{TS}\), \(\bm{\mathcal{M}}_{O}\) \\
\cmidrule{2-4}
& transfer event spoofing & Emit Phantom events with social engineering attack & \(\bm{\mathcal{M}}_{SC}\), \(\bm{\mathcal{M}}_{TS}\), \(\bm{\mathcal{M}}_{O}\) \\
\cmidrule{2-4}
& event handling error & Incorrect display/ insertion/storage due to faulty event processing & \(\bm{\mathcal{M}}_{D}\), \(\bm{\mathcal{M}}_{O}\) \\
\bottomrule
\end{tabular}
\end{table*}

We relied on industry reports, academic literature, and real-world smart contract audits to construct a taxonomy of relatively new and understudied phantom event attacks. We model five distinct attack
scenarios, which are classified into two categories based on their origins:
(1) \emph{on-chain (smart contract) vulnerabilities} and (2) \emph{off-chain weaknesses}.
These attacks are summarized in our attack classification table (\cref{tab:attack-classification}).

Detailed demonstrations of these attacks are available in the supplementary materials.\footnote{\url{https://github.com/PhantomEvent/Event-attack-demo}}


\subsection{Attack Vectors and Detection Rules}
This section introduces five attacks related to phantom events and proposes corresponding detection rules. Examples of these attacks can be found in~\cref{appendix:examples}.

\subsubsection{Event Counterfeiting}\label{vec:attack1}

\begin{figure}
\small
\footnotesize
\begin{lstlisting}[language=Solidity]
function depositETH(uint destinationChainId) external payable {
  require(msg.value > 0, "Deposit amount must be greater than 0");
  ethBalances[msg.sender] += msg.value;
  emit Deposit(msg.sender, msg.value, address(0), destinationChainId);
}

function deposit(address token, uint amount, uint destinationChainId) external {
  require(amount > 0, "Deposit amount must be greater than 0");
  safeTransfer(token, address(this), amount);
  tokenBalances[msg.sender][token] += amount;
  emit Deposit(msg.sender, amount, token, destinationChainId);
}

function safeTransfer(address token, address to, uint value) internal {
  (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));
  require(success && (data.length == 0 || abi.decode(data, (bool))), "!safeTransfer");
}
\end{lstlisting}
\caption{Proof of concept for the event counterfeiting attack, where \texttt{deposit} and
\texttt{depositETH} could emit the same event.}\label{code:1}
\end{figure}

This attack takes advantage of legitimate contracts that emit the same event from multiple functions or execution paths (\(\bm{\mathcal{M}}_{TS}\)). In the provided code example~\cref{code:1}, both the \texttt{depositETH} and \texttt{deposit} functions emit a \texttt{Deposit} event, where the third parameter signifies the token type. While \texttt{depositETH} uses \texttt{address(0)} to represent ETH, the \texttt{deposit} function uses the token address for ERC-20 tokens. However, the \texttt{deposit} function can also emit an event with \texttt{address(0)}, mimicking an ETH deposit.

An attacker could exploit this by calling the \texttt{deposit} function and forging the third parameter as \texttt{address(0)}, without actually transferring any ETH. This creates a \emph{phantom} \texttt{Deposit} event that resembles a real ETH deposit. Off-chain validation systems, which rely on event logs for transaction verification, may mistakenly treat this event as a legitimate ETH deposit, allowing the attacker to fraudulently claim large sums on the destination chain due to the flawed event validation process.


\paragraph{Detection Method}
This vulnerability occurs when different functions or execution paths emit the same event with identical parameters, even though each function imposes different constraints. Off-chain systems often treat these events as authentic without verifying the parameter constraints. If a function emits a value that is expected to be constrained or validated by another function, it is considered a potential vulnerability. The detection rule checks for cases where identical parameter values are emitted along different execution paths, even when those paths should enforce distinct constraints, and flags such events as potential vulnerabilities.


The formalized detection rule is expressed as follows.

\begin{equation}
\small
\text{EC} = \left\{
e \in E \mid
\begin{aligned}
  & V(f, e) \cap V(g, e) \neq \emptyset \text{ and } \\
  & \exists \; f, g \in F(e)
\end{aligned}
\right\}
\end{equation}


\begin{itemize}
    \item \( E \) is the set of emitted events, and \( e \in E \) represents an individual event.
    \item \( F \) is the set of all function paths in the contract that can emit events, and \( f, g \in F \) are specific function paths that emit the same event \( e \).
    \item \( V(f, e) \) and \( V(g, e) \) represent the range of values that the parameters of event \( e \) can take along function paths \( f \) and \( g \).
\end{itemize}


\subsubsection{Inconsistent Logging}\label{vec:attack2}

\begin{figure}
\footnotesize
\small
\begin{lstlisting}[language=Solidity]
function requestWithdraw(uint256 _type, uint256 _amount) external {
  require(WITHDRAW_ALLOWED, "TroyEmpire: Withdrawal is disabled for now");
  emit WithdrawalRequested(_msgSender(), _type, _amount);
}
\end{lstlisting}
\caption{Proof of concept for the inconsistent logging attack.}\label{code:2}
\end{figure}

Many DApps adopt a hybrid logging model that uses both blockchain and traditional databases to record critical operations. For example, DeFi platforms record financial transactions, such as deposits and withdrawals, while GameFi platforms track user operations. Our analysis revealed that numerous projects not only rely on database records, but also emit logs on the blockchain.

Specifically, poorly designed smart contracts may allow attackers to emit forged events, leading to inconsistencies between the blockchain and the database logs. For example, a financial platform might use both blockchain and off-chain databases to log withdrawal requests. If the smart contract lacks proper access controls, attackers could arbitrarily generate withdrawal events on the blockchain, creating a mismatch with the database records, as shown in \cref{code:2}.


\paragraph{Detection Method}
This vulnerability occurs when smart contracts emit events without proper access control or validation against stored data. Specifically, some contracts lack necessary constraints, allowing any user to trigger critical events such as withdrawals without validating the event parameters against the contract's state. To detect this, we analyze the contract's functions for two key aspects: (1) the presence of access control mechanisms or event parameter validation (e.g., \texttt{require} statements) that restrict who can emit events, and (2) whether the function interacts with storage (i.e., reads from or writes to storage variables) when emitting events to ensure that parameters are validated against previously stored values. If a function emits an event without adequate access control or does not interact with storage, it is flagged as a potential vulnerability.

The formalized detection rule is expressed as follows.

\begin{equation}
\small
\text{IL} = \left\{
f \in F \mid
\begin{aligned}
  & Constraint(f) = \emptyset \text{ or } \\
  & (S_{\texttt{read}}(f) = \emptyset \text{ and } S_{\texttt{write}}(f) = \emptyset)
\end{aligned}
\right\}
\end{equation}


\begin{itemize}
    \item \( Constraint(f) \): The access control mechanism for function \( f \) or constraint for event parameters. If \( Constraint(f) = \emptyset \), there are no access controls or constraints.
    \item \( S_{\texttt{read}}(f) \) and \( S_{\texttt{write}}(f) \): The storage variables read and written by the function \( f \).
\end{itemize}

\subsubsection{Contract Imitation}\label{vec:attack3}

This attack involves the deployment of a malicious contract to exploit or imitate an existing contract (\(\bm{\mathcal{M}}_{SC}\)). We classify this attack into two subtypes based on its characteristics. The first subtype, called Blended Event Attack, occurs when a malicious contract interacts with a legitimate contract, causing events from both contracts to be logged within the same transaction. This blending of events makes it difficult to distinguish between legitimate and fraudulent activity. The second subtype, named Mimicry Contract Attack, involves an attacker deploying a forged contract that imitates the behavior of a legitimate contract, allowing the attacker to manipulate event logs and transaction details.


An \emph{authentic} contract typically records logs from its own functions. However, most contracts permit external calls, allowing malicious contracts to invoke their functions, leading to logs from both contracts being recorded in a single transaction (\(\bm{\mathcal{M}}_{TS}\)). This scenario, termed the \emph{Blended Event} attack, introduces a security risk when the log emitter is not verified.

The \emph{Mimicry Contract} attack exploits transparency practices, as many DApp teams publish their contract source code to promote trust. This allows attackers to modify and redeploy code, creating malicious contracts that mimic legitimate ones and emit event logs that can be freely manipulated (\(\bm{\mathcal{M}}_{TS}\)). For ERC-20 tokens or NFTs, this manipulation enables attackers to forge transaction records, such as minting or transferring tokens or NFTs, which can include falsifying the sender to make an NFT appear as though it was issued by a well-known artist.

\paragraph{Detection Method}
%This vulnerability arises when an attacker deploys a forged contract to mimic an authentic contract, emitting phantom events that resemble legitimate ones. The attacker can further blend these phantom events with authentic events within the same transaction log, making it difficult for off-chain systems to distinguish between legitimate and forged events.
To detect this, we analyze the \emph{transaction logs}. Specifically, we check whether the same event signature (\( Topics_0 \)) appears multiple times in the same transaction, but is emitted by different contracts. If the event signature is emitted by both the authentic contract and a forged contract within the same transaction, it is flagged as a potential attack transaction. This detection rule helps identify cases where the event signatures match but are emitted by different emitters, indicating a \emph{Blended Event Attack}.


\begin{equation}
\small
\text{BE} = \left\{
L_{\textit{hash}} \mid
\begin{aligned}
  & Topics_0^i = Topics_0^j \text{ and } \\
  & S_{\texttt{address}}^i = S_{\texttt{auth}} \text{ and } \\
  & S_{\texttt{address}}^j = S_{\texttt{forge}}
\end{aligned}
\right\}
\end{equation}



\subsubsection{Transfer Event Spoofing}\label{vec:attack4}

This attack is a form of social engineering attack~\cite{social_engineer}. One common example is the Zero Transfer Scam, where the attacker creates a phantom event that mimics a legitimate token transfer. After the user sends tokens, the attacker generates a fake event that makes it appear as though the user has sent tokens to a similarly named recipient address, which belongs to the attacker. This counterfeit event is recorded by wallets and blockchain explorers, misleading the victim into transferring additional funds to the attacker's account. This scam has reportedly caused losses of at least \$27.36 million USD, affecting 28,414 victims~\cite{wallet_visual}.

The second variation, called the Airdrop Scam~\cite{spoof}, exploits the common Web3 marketing tactic of token airdrops. Attackers forge phantom events by spoofing the senderâ€™s address using real ERC-20 or ERC-721 contracts, often selecting addresses designed to catch attention (e.g., 0x8888...8888). These phantom airdrops trick victims into interacting with the tokens. Attackers may set up honeypot contracts where users can buy tokens but are unable to sell them, or use phantom event logs to promote malicious links (e.g., using ENS names to deceive victims). In more severe cases, attackers may perform rug pulls, withdrawing liquidity and leaving victims with worthless tokens~\cite{rugpull}.


\paragraph{Detection Method}
Attackers exploit the fact that many third-party services, such as wallets and blockchain explorers, blindly trust events emitted by smart contracts without verifying their authenticity. By taking advantage of this lack of verification, attackers can generate phantom events that mimic legitimate transfers, misleading users into transferring funds to the attacker's address. To detect this, we can analyze the transaction logs to ensure that the transfer event was genuinely initiated by the correct sender, or verify if the sender had approved the address that initiated the transaction.


\begin{equation}
\small
\text{TS} = \left\{
L_{\textit{hash}} \mid
\begin{aligned}
  & TX_{\textit{sender}} \neq \textit{TokenSender} \text{ and } \\
  & Approve(\textit{TokenSender}, TX_{\textit{sender}}) = \text{false}
\end{aligned}
\right\}
\end{equation}


\begin{itemize}
    \item \( \textit{TokenSender} \) represents the sender of the tokens in event.
    \item \( Approve(\textit{TokenSender}, TX_{\textit{sender}}) \) indicates whether the token sender has authorized the transaction initiator to transfer their tokens.
\end{itemize}

\subsubsection{Event Handling Error}\label{vec:attack5}
This attack exploits vulnerabilities in how blockchain explorers, wallets, and monitoring tools process and interpret transaction data. These applications rely on on-chain data to provide real-time information to users. When phantom events are mistakenly treated as legitimate, this can result in inaccurate wallet balances, false transaction histories, or incorrect asset ownership records, which misleads users and potentially impacts their decision-making.

For example, in the context of \emph{Contract Imitation} attacks, even if phantom events are not specifically targeting blockchain explorers, they may still cause explorers to log these events as valid ERC-20 or NFT transfers, despite no actual transfer occurring. This misinterpretation allows attackers to create the appearance of transfers without underlying transactions.

Attackers can further exploit this by embedding malicious payloads within event data to launch attacks such as cross-site scripting (XSS) or SQL injection (SQLi). Without proper sanitization, such payloads can lead to unauthorized actions on the DApp interface, data theft, or database compromise.

\paragraph{Detection Method}
This attack leverages the implicit trust that blockchain explorers, wallets, and monitoring tools place in on-chain data. Effective detection requires adaptable methods tailored to the needs of each off-chain application. Explorers should validate events against actual token transfers, while wallets need to confirm that transfers are permitted for the sender. By customizing detection rules based on these unique validation standards, applications can mitigate the risks posed by phantom events and embedded malicious payloads.
