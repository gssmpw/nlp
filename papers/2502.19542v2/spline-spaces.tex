\section{Spline spaces}\label{sec:spline-spaces}

In this section, all required notation and definitions will be introduced for the univariate
B-splines, and later extend into tensor product B-splines and, finally, the hierarchical
B-spline de Rham complex. We will simplify the notation used in \cite{Evans2018} and
\cite{Shepherd2024} to the two-dimensional case.

\subsection{Univariate B-splines}\label{subsec:univariate-splines}

In order to define univariate B-splines of polynomial degree \(\degree\geq 1\), we need to
define a knot vector. Namely, for \(m \geq 1\), a knot vector \(\knotvec =
(\knot_1,\dots,\knot_{m+\degree+1})\) is a sequence of non-decreasing real numbers, or
knots, satisfying \[
	\knot_1=\dots=\knot_{\degree}<\knot_{p+1}\leq \dots \leq
	\knot_{m+1}<\knot_{m+2}=\dots=\knot_{m+\degree+1}.
\]
We note that the first and last knots are repeated \(p\) times, which differs from the usual
choice of \(p+1\) repetitions, and enforces homogeneous boundary conditions for splines of
degree \(p\);
we also assume that no knot is repeated more than \(p\) times.
To simplify the notation, we will consider that \(\knot_1=0\) and \(\knot_{m+\degree+1}=1\) from now on.

The knot vector \(\knotvec\) induces a partition of the interval \([0,1]\), which we will
denote by \(Z\) and call the breakpoints of \(\knotvec\). In other words,
\(Z=\{\zeta_1, \dots, \zeta_{z+1}\}\) is the largest subset of \(\knotvec\)
such that \[
    \zeta_i<\zeta_{i+1},\ i\in\{1,\dots,z\}.
\]
Also, it will be useful to define the intervals given by \(Z\), namely 
\begin{equation}\label{eq:breakpoint-indices}
	\mathcal{I} \coloneqq  \left\{(\zeta_i,\zeta_{i+1}): i\in\{1,\dots,z\}\right\}.
\end{equation}

Using the knot vector \(\knotvec\) we can define two spaces that will be used to establish
discrete complexes.
Let \(\bspspace^{0}(\knotvec)\) be the space of piecewise-polynomial functions of degree
\(\degree\) and regularity \(C^{p-r}\) at knots with multiplicity \(r\) that
vanish at \(\knot \in \{0,1\}\).
Similarly, we set \(\bspspace^{1}(\knotvec)\) as the space of piecewise-polynomial functions
of degree \(\degree-1\) with \(C^{p-r-1}\) regularity at knots with multiplicity \(r\) ― no
conditions imposed at the boundaries. 

It is easy to see that, with the chosen boundary conditions, the dimension of the space
\(\bspspace^{j}(\knotvec)\) is \(m+j, j\in \{0,1\}\), and we can define a set of \(m+j\)
basis functions that span it.
As mentioned in the introduction, we will choose to work with the B-splines \(\bsp^j_{i}, i
\in \{1,\dots,m+j\},\) as the basis for \(\bspspace^{j}(\knotvec)\), and denoting the
set as \(\bspbasis^{j}(\knotvec)\). We refer the reader to \cite{Piegl1997, Schumaker2007}
for more details on the construction of B-splines. Nonetheless, we highlight a fact about
the support of B-splines that will be used extensively throughout the paper: \[
	\supp(\bsp^j_{i}) = (\knot_{i}, \knot_{i+p+1-j}),\; j\in \{1, 2\}\;.
\]

\subsection{Tensor Product B-splines}\label{subsec:tensor-product-splines}

Now that we have fully characterized univariate B-spline spaces, we can use them to
construct a two-dimensional tensor-product B-spline space. Note that we will restrict the
definitions and notation to these conditions, but the construction is altogether identical
for higher-dimensional spaces.

Moreover, keeping in line with our desire to work with hierarchical spline spaces, we will
also introduce the relevant notation for the levels of a hierarchy. We will use \(L\) to
refer to the highest non-trivial refinement level and \(0\leq \level \leq L\) for a general
level.

Let \(\bspbasis^{j_1}_{\level}(\knotvec_{\level, 1})\) and
\(\bspbasis^{j_2}_{\level}(\knotvec_{\level, 2})\) be two univariate spline spaces under the
assumptions of \Cref{subsec:univariate-splines}. We denote their associated polynomial
degrees and dimensions as \(p_{(\level, k)}\) and \(m_{(\level, k)}+j_k\), respectively,
where \(j_k \in \{0, 1\}\) and \(k\in\{1,2\}\). We can then define the tensor product space
\[
	\bspspace_{\level}^{\boldvec{j}} \coloneqq \bspspace^{j_1}(\knotvec_{(\level, 1)})
	\otimes \bspspace^{j_2}(\knotvec_{(\level, 2)}).
\]
A basis for this space is given by \[
	\bspbasis^{\boldvec{j}}_\level \coloneqq \left\{
		\bsp^{\boldvec{j}}_{\boldvec{i}, \level}(\xi_1, \xi_2) \coloneqq 
		\bsp^{j_1}_{i_1}(\xi_1) \bsp^{j_2}_{i_2}(\xi_2):
		\bsp^{j_k}_{i_k} \in \bspbasis^{j_k}_\level(\knotvec_{(\level, k)})
	\right\}\;.
\]
We have used a bold and upright notation for the two-dimensional multi-indexes \(\boldvec{j}\)
and \(\boldvec{i}\), and will do so throughout the paper. To access their \(k\)-th entry we respectively 
write, as above, \(j_k\) and \(i_k\), and we will denote the \(i_k\)-th knot
of the level \(\level\) univariate knot vector \(\knotvec_{(\level, k)}\) as \(\knot_{i_k,
\level, k}\). 

From this point forward, we will mainly refer to multi-variate basis functions either using
the three indices \(\boldvec{j}, \boldvec{i}, \text{ and } \level\) or omitting all of them
whenever they are not necessary ― unless otherwise specified. We are now capable of defining
a set of finite element spaces such that the discrete complex they give is cohomologically
equivalent to the continuous complex. The relevant spaces are \[
	\bspspace^0_{\level} \coloneqq \bspspace_{\level}^{(0,0)}\;, \qquad \bspspace^1_{\level}
	\coloneqq \bspspace_{\level}^{(1,0)} \times \bspspace_{\level}^{(0,1)}\;, \qquad
	\bspspace^2_{\level} \coloneqq \bspspace_{\level}^{(1,1)}\;,
\]
and the discrete complex is naturally \cite{Buffa2010, Buffa2011}  \[
    \begin{tikzcd}
		\complex{\bsp}_h~:~ \bspspace^0_{\level} \arrow{r}{\grad} & \bspspace^1_{\level}
		\arrow{r}{\curl} & \bspspace^2_{\level}\;.
    \end{tikzcd}
\]
To help ease notation, we will use \(\boldvec{0}=(0,0)\) throughout the paper.
Taking into account the way in which the \(\grad\) and \(\curl\) operators change the
polynomial degree and regularity of functions it becomes clear that \[
    \grad(\bspspace^0_{\level}) \subseteq \bspspace^1_{\level}\;,\qquad
    \curl(\bspspace^1_{\level}) \subseteq \bspspace^2_{\level}\;.
\]

Finally, we also define the tensor-product mesh \(\mesh_{\level}\) induced by the two sets of intervals \(\mathcal{I}_{(\level, 1)}\) and
\(\mathcal{I}_{(\level, 2)}\), corresponding to  \(\knotvec_{(\level, 1)}\) and
\(\knotvec_{(\level, 2)}\), respectively. We define the mesh of level $\level$ as \[
	\mesh_{\level} = \left\{I_{1}\times I_{2}: I_{1} \in \mathcal{I}_{(\level, 1)}, I_{2}
	\in \mathcal{I}_{(\level, 2)}\right\}.
\]

\subsection{Hierarchical B-splines}\label{subsec:hierarchical-splines}

With all the single-level tensor-product spline spaces from
\Cref{subsec:tensor-product-splines} in hand, we will construct a hierarchical B-spline
space. We start by defining a set of nested domains and function spaces defined on them,
assigning each domain and corresponding space to a specific refinement level. For the
spaces, we require that \(\bspspace^{\boldvec{j}}_0\subseteq
\bspspace^{\boldvec{j}}_1\subseteq\dots\subseteq \bspspace^{\boldvec{j}}_L\) for all
valid \(\boldvec{j}\). Lastly, our nested set of closed domains  
\(\domain_\level\subset \mathbb{R}^2\) need to satisfy \[
	\domain \eqqcolon \domain_0\supseteq \domain_1 \supseteq\dots \supseteq \domain_{L}
	\supseteq \domain_{L+1}\coloneqq \emptyset \;.
\]
Furthermore, we also introduce the following assumption on how the subdomains that determine
the mesh can be chosen.
\begin{assum}\label{assum:refinement-domains}
	We assume that \(\domain_{\level+1}\) is given as the union of
	supports of B-splines in \(\bspbasis_\level^{\boldvec{0}}\), that is \[
		\domain_{\level+1} \coloneqq \bigcup_{\bsp \in
		\tilde{\bspbasis}^{\boldvec{0}}_\level}\overline{\supp(\bsp)},\ \level = \{0,\dots,L-1\},
    \]
	where \(\tilde{\bspbasis}^{\boldvec{0}}_\level\subseteq \bspbasis^{\boldvec{0}}_\level\)
	is some set of level \(\level\) B-splines.
\end{assum}

This leads us to defining a hierarchical mesh, \(\mesh\), as\[
	\mesh \coloneqq \bigcup_{\level \in \{0,\dots,L\}} \left\{ \meshel \in \mesh_\level:
	\meshel \subseteq \domain_\level \wedge \meshel \not \subseteq \domain_{\level+1}
	\right\}.
\]
As a consequence of \Cref{assum:refinement-domains}, all elements of \(\mesh\) are
pairwise disjoint and \(\bigcup_{\meshel \in \mesh} \overline{\meshel} = \domain \).
Then, a standard way of selecting a basis \(\hbbasis_L^{\boldvec{j}}\) for hierarchical
B-spline spaces uses the following algorithm \cite{Giannelli2012, Buffa2022}: 
\begin{enumerate}
	\item \(\hbbasis_0^{\boldvec{j}} \coloneqq \bspbasis^{\boldvec{j}}_0\).
    \item For \(\level = 0,\dots,L-1\), let \(
		\hbbasis_{\level+1}^{\boldvec{j}} \coloneqq
		\hbbasis^{\boldvec{j}}_{\level+1, A} \cup \hbbasis^{\boldvec{j}}_{\level+1, B}
	\), where 
	\begin{align*}
	% A
	\hbbasis^{\boldvec{j}}_{\level+1, A} &\coloneqq \left\{
		\bsp \in \hbbasis_{\level}^{\boldvec{j}}: \supp(\bsp) \not \subseteq
		\domain_{\level+1} 
	\right\},\\
	% B
	\hbbasis^{\boldvec{j}}_{\level+1, B} &\coloneqq \left\{
		\bsp \in \bspbasis^{\boldvec{j}}_{\level+1} : \supp(\bsp) \subseteq
		\domain_{\level+1}
	\right\}\;.
	\end{align*}
\end{enumerate}
We then set \(\hbspace^{\boldvec{j}}_{\level} \coloneqq \bspan{
\hbbasis^{\boldvec{j}}_{\level}}\), for any level \(0\leq \level \leq L\). The corresponding
hierarchical spaces are, then, \[
	\hbspace^0_{\level} \coloneqq \hbspace_{\level}^{(0,0)}\;, \qquad \hbspace^1_{\level}
	\coloneqq \hbspace_{\level}^{(1,0)} \times \hbspace_{\level}^{(0,1)}\;, \qquad
	\hbspace^2_{\level} \coloneqq \hbspace_{\level}^{(1,1)}\;,
\]
and, for each \(\level=0,\dots, L\), the hierarchical complex is
\begin{equation}\label{eq:hierarchical-complex}
	\begin{tikzcd}
		\complex{\hb}_h~:~ \hbspace^0_{\level} \arrow{r}{\grad} & \hbspace^1_{\level}
		\arrow{r}{\curl} & \hbspace^2_{\level}.
	\end{tikzcd}
\end{equation}

\begin{rem}
	Under \Cref{assum:refinement-domains}, the three spaces in the complex
	\eqref{eq:hierarchical-complex} are associated to the same hierarchical mesh.
\end{rem}

The basis just defined above for hierarchical spaces can be slightly altered to preserve
partition of unity and to reduce the support of the basis functions, through a procedure called truncation. For this, we introduce the higher-level representation of
B-splines. Namely, given \(\bsp^{\boldvec{j}}_{\boldvec{i}, \level} \in
\bspbasis^{\boldvec{j}}_{\level}\), it is possible to write the basis function as 
\begin{equation}\label{eq:finer-rep}
	\bsp^{\boldvec{j}}_{\boldvec{i}, \level} \equiv \sum_{\bsp \in
	\bspbasis^{\boldvec{j}}_{\level+1}} c^{\level,
	\level+1}_{\bsp}(\bsp^{\boldvec{j}}_{\boldvec{i}, \level}) \bsp,\quad c^{\level,
	\level+1}_{\bsp}(\bsp^{\boldvec{j}}_{\boldvec{i}, \level}) \in \mathbb{R}.
\end{equation}
Using this property, we can then define the truncation operator at level $\ell+1$ as in \cite{Giannelli2012}
\begin{equation}\label{eq:truncated-rep}
	\trunc^{\level+1}(\bsp^{\boldvec{j}}_{\boldvec{i}, \level}) \coloneqq 
	\sum_{\substack{\bsp \in \bspbasis^{\boldvec{j}}_{\level+1}:
	\\ \supp(\bsp)\not \subseteq \domain_{\level+1}}}
	c^{\level, \level+1}_{\bsp}(\bsp^{\boldvec{j}}_{\boldvec{i}, \level})\bsp.
\end{equation}
The truncation operation described above is linear and, in particular, can be written as a
matrix multiplication; see \cite{D'Angella2020} for more details.

Using this, the new truncated hierarchical basis is given by
\begin{enumerate}
    \item \(\thbbasis_0^{\boldvec{j}} \coloneqq \bspbasis^{\boldvec{j}}_0\).
    \item For \(\level = 0,\dots,L-1\), let \(
		\thbbasis_{\level+1}^{\boldvec{j}} \coloneqq
		\thbbasis^{\boldvec{j}}_{\level+1, A} \cup \hbbasis^{\boldvec{j}}_{\level+1, B}
	\), where
    \[
		\thbbasis^{\boldvec{j}}_{\level+1, A} \coloneqq \left\{
			\trunc^{\level+1}(\bsp): \bsp\in \thbbasis_{\level}^{\boldvec{j}} ~\wedge~ \supp(\bsp) \not \subseteq \domain_{\level+1}
		\right\}\;.
    \]
\end{enumerate}
It is possible to show that \(\bspan{\thbbasis^{\boldvec{j}}_{\level}} =
\bspan{\hbbasis^{\boldvec{j}}_{\level}} = \hbspace^{\boldvec{j}}_{\level}\) for all levels
\(\level = 0,\dots, L\). While the two bases span the same space \cite{Giannelli2012}, the
truncated basis is preferable in some instances due to the better matrix conditioning
achieved with this basis and the recovery of the convex partition of unity property of
tensor-product B-splines.

We will also define the notion of mother of a truncated B-spline \cite{Giannelli2013}. Given
a truncated basis function \(\thb^{\boldvec{j}}_{\boldvec{i}, \level} \in
\thbbasis^{\boldvec{j}}_{\level}\), we say that
\(\bsp^{\boldvec{j}}_{\boldvec{i}, \level}\) is the mother of
\(\thb^{\boldvec{j}}_{\boldvec{i}, \level}\) if \[
	\thb^{\boldvec{j}}_{\boldvec{i}, \level} = 
	\trunc^{L}\left(\cdots\left(\trunc^{\level+1}\left(\bsp^{\boldvec{j}}_{\boldvec{i},
	\level}\right)\right)\right)\;,
\]
and we denote this relationship as \(\mot(\thb^{\boldvec{j}}_{\boldvec{i}, \level})
\coloneqq \bsp^{\boldvec{j}}_{\boldvec{i}, \level}\).

We mentioned before how spurious harmonic forms can be introduced for arbitrary refinement
domains. The reason for this can be understood by carefully considering the
construction of the hierarchical spaces. The way in which the selection mechanism of
active and inactive basis functions in each level works can, in principle, lead to a discrete
complex with different cohomology spaces than the original one. This can happen because the
coarse basis functions we remove from one level and the finer basis functions we replace
them with in the next level can span spaces with different topological properties. See
\cite[Fig. 7]{Shepherd2024} and \cite[Fig. 13]{Evans2018}, and the surrounding discussions,
for some illuminating examples of this phenomenon.
