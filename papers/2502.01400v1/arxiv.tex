\documentclass[a4paper,USenglish,cleveref, autoref, thm-restate]{lipics-v2021}

\usepackage{xspace}
\usepackage{dsfont}
\usepackage{thmtools}
\usepackage{mismath}
\usepackage{bbm}
\usepackage{mathtools}
\usepackage{ifthen}
\usepackage{comment}
\usepackage{parskip}
\graphicspath{{img/}}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb}
\usepackage{mathrsfs}
\usepackage{thm-restate}
\usepackage{wrapfig}
\usepackage{cases}
\usepackage{xspace}
\usepackage{csquotes}
\usepackage{multirow}
\usepackage{multicol}
\usepackage{mathtools}

\usepackage{footmisc}
\newtheorem{case}{Case}
\hideLIPIcs  %


\newcommand{\sv}[1]{#1}%
\newcommand{\lv}[1]{}%
 %
\usepackage{etoolbox}
\newcommand{\appendixText}{}

 %
\newcommand{\toappendix}[1]{\gappto{\appendixText}{{#1}}}%

\newcommand{\subs}{\ensuremath\mathrm{subs}\xspace}

\newcommand{\Graph}{\ensuremath{G}}
\newcommand{\GraphO}{\ensuremath{H}}
\newcommand{\VS}{\ensuremath{X}}
\newcommand{\VSx}{\ensuremath{X}}
\newcommand{\MS}{\ensuremath{D}}
\newcommand{\Vertices}{\ensuremath{V}}
\newcommand{\Edges}{\ensuremath{E}}
\newcommand{\GraphInd}[1]{\ensuremath{\Graph[{#1}]}}
\newcommand{\nb}[1]{\ensuremath{N(#1)}}
\newcommand{\nbd}[2]{\ensuremath{N_{#1}(#2)}}

\newcommand{\cw}{\ensuremath{\mathop{\mathrm{cw}}}}
\newcommand{\sd}{\ensuremath{\mathop{\mathrm{sd}}}}
\newcommand{\pw}{\ensuremath{\mathop{\mathrm{pw}}}}
\newcommand{\nd}{\ensuremath{\mathop{\mathrm{nd}}}}
\newcommand{\vc}{\ensuremath{\mathop{\mathrm{vc}}}}
\newcommand{\tc}{\ensuremath{\mathop{\mathrm{tc}}}}

\newcommand{\tw}{\ensuremath{\mathop{\mathrm{tw}}}}
\newcommand{\cvd}{\ensuremath{\mathop{\mathrm{cvd}}}}
\newcommand{\td}{\ensuremath{\mathop{\mathrm{td}}}}
\newcommand{\fvs}{\ensuremath{\mathop{\mathrm{fvs}}}}
\newcommand{\mw}{\ensuremath{\mathop{\mathrm{mw}}}}
\newcommand{\Tab}{\mathrm{Tab}}
\newcommand{\FPT}{\ensuremath{\mathsf{FPT}}\xspace}
\newcommand{\XP}{\ensuremath{\mathsf{XP}}\xspace}
\newcommand{\W}[1]{\ensuremath{\mathsf{W[#1]}}}
\newcommand{\Ww}{\ensuremath{\mathsf{W}}}
\newcommand{\NP}{{\ensuremath{\mathsf{NP}}}\xspace}
\newcommand{\Pee}{{\ensuremath{\mathsf{P}}}\xspace}
\newcommand{\Ll}{{\ensuremath{\mathsf{L}}}\xspace}
\newcommand{\NE}{{\mathsf{NE}}}
\newcommand{\yes}{\ensuremath{{\mathsf{yes}}}}
\newcommand{\Ee}{{\mathsf{E}}}
\newcommand{\cliFC}{\ensuremath{\mathsf{CliqueFC}}\xspace}
\newcommand{\MSs}{D_G}

\newcommand{\onbh}[2]{\ensuremath{\mathsf{N}_{#1}(#2)}}
\newcommand{\cnbh}[2]{\ensuremath{\mathsf{N}_{#1}[#2]}}
\newcommand{\ctypes}{\ensuremath{\mathsf{CT}}}
\newcommand{\ntypes}{\ensuremath{\mathsf{NT}}}
\newcommand{\spatterns}{\ensuremath{\mathsf{SP}}}
\newcommand{\shapes}{\ensuremath{\mathsf{Shapes}}}
\newcommand{\shapesag}[1]{\ensuremath{\mathsf{Shapes}^{(\alpha,\gamma, #1)}}}
\newcommand{\ctypef}[3]{\ensuremath{\mathsf{ctype}_{#2}^{#3}(#1)}}
\newcommand{\dtypef}[1]{\ensuremath{\mathsf{ntype}(#1)}}
\newcommand{\coloring}{\ensuremath{\mathsf{coloring}}}
\newcommand{\fc}[1]{\ensuremath{\mathsf{fc}(#1)}}
\newcommand{\fcnobrackets}[1]{\ensuremath{\mathsf{fc}}}
\newcommand{\fcd}[2]{\ensuremath{\mathsf{fc}_{#2}(#1)}}
\newcommand{\Cc}{\mathcal{C}}
\newcommand{\Qq}{\mathcal{Q}}
\newcommand{\Xx}{\mathcal{X}}
\newcommand{\setupto}[1]{\ensuremath{[#1]}}
\newcommand{\labtype}{\textbf{labeled type}}
\newcommand{\labcliqtype}{\textbf{labeled clique type}}

\newcommand{\signat}[2]{\ensuremath{\mathsf{sgn}^{#1}_{#2}}}
\newcommand{\cT}{\ensuremath{\mathsf{cT}}\xspace}
\newcommand{\ctype}{\ensuremath{\mathsf{cT}}\xspace}
\newcommand{\nT}{\ensuremath{\mathsf{nT}}\xspace}
\newcommand{\sP}{\ensuremath{\mathsf{sP}}\xspace}
\newcommand{\nsP}{\ensuremath{\mathsf{nsP}}\xspace}
\newcommand{\mtx}{\ensuremath{\mathsf{M}}\xspace}
\newcommand{\shape}{\ensuremath{\mathsf{shp}}\xspace}
\newcommand{\limshape}{\ensuremath{\mathsf{BOUNDEDshpT}}\xspace}
\newcommand{\vershape}{\ensuremath{\mathsf{VerifyShape}}\xspace}
\newcommand{\nodd}{\ensuremath{\mathbb{N}_\text{odd}}\xspace}


\newcommand{\red}{\ensuremath{\mathsf{red}}}
\newcommand{\maximal}{\ensuremath{\mathsf{maximal}}\xspace}
\newcommand{\bounded}{\ensuremath{\mathsf{bounded}}\xspace}
\newcommand{\blue}{\ensuremath{\mathsf{blue}}}
\newcommand{\FO}{{$\mathsf{FO}$}\xspace}
\newcommand{\MSO}{{\ensuremath{\mathsf{MSO}}}\xspace}
\newcommand{\MSOt}{{\ensuremath{\mathsf{MSO}_2}}\xspace}
\newcommand{\MSOo}{\ensuremath{\mathsf{MSO}_1}\xspace}
\newcommand{\smallo}[1]{\ensuremath{o(#1)}}
\newcommand{\MSOLCC}{\MSO\unskip\mbox{-}\nobreak\hspace{0pt}{\sf LCC}\xspace}
\newcommand{\fvdp}[1]{{\sc Fair Vertex } {#1} {\sc Deletion}}

\newcommand{\dbinpacking}{\textsc{Unary $\ell$-Bin Packing}\xspace}
\newcommand{\dtuple}{\textsc{Unary $d$-Tuple} Problem\xspace}
\newcommand{\FairVD}{\textsc{Fair Vertex $\mathsf{FO}$ Deletion}\xspace}
\newcommand{\FairVE}{\textsc{FairVE}\xspace}
\newcommand{\ClusterVD}{\textsc{ClusterVD}\xspace}
\newcommand{\df}{\coloneqq}
\newcommand{\NOT}[1]{\overline{#1}}
\def\phi{\varphi}
\def\tilde{\widetilde}

\usepackage{xcolor}
\newcommand{\magenta}[1]{{\color{magenta}\bf #1}}
\newcommand{\comm}[1]{
  \textsf{\magenta{*** (Comment) #1 ***}}
}

\newcommand{\TM}[1]{\textcolor{orange}{TM: #1}}
\newcommand{\AZ}[1]{\textcolor{magenta}{AZP: #1}}
\newcommand{\JO}[1]{\textcolor{cyan}{JO: #1}}



\newcommand{\prob}[3]{
\begin{center}
\renewcommand{\arraystretch}{0.85}%
\begin{tabularx}{\textwidth}{|lX|}
	\hline
	\multicolumn{2}{|l|}{\hspace{0pt}\rule{0pt}{13pt} #1}\\
	{\bf Input:\enspace}&{#2}\\
	{\bf Question:\enspace}&{#3 \rule[-6pt]{0pt}{6pt}} \\
	\hline
\end{tabularx}
\end{center}
}



\bibliographystyle{plainurl}%


\title{Fair Vertex Problems Parameterized by Cluster Vertex Deletion}



\author{Tom\'a\v{s} Masa\v{r}\'ik}{Institute of Informatics, Faculty of Mathematics, Informatics and Mechanics, University of Warsaw}{masarik@mimuw.edu.pl}{0000-0001-8524-4036}{Supported by the Polish National Science Centre SONATA-17 grant number
2021/43/D/ST6/03312.}
\author{Jędrzej Olkowski}{Institute of Informatics, Faculty of Mathematics, Informatics and Mechanics, University of Warsaw}{TODO}{TODO ORCID}{Supported by the Polish National Science Centre SONATA-17 grant number 2021/43/D/ST6/03312.}
\author{Anna Zych-Pawlewicz}{Institute of Informatics, Faculty of Mathematics, Informatics and Mechanics, University of Warsaw}{anka@mimuw.edu.pl}
{https://orcid.org/0000-0002-5361-8969}{This work is supported by National Science Centre grant agrement }




\authorrunning{T. Masa\v{r}\'ik, J. Olkowski, A. Zych-Pawlewicz}

\Copyright{T. Masa\v{r}\'ik, J. Olkowski, A. Zych-Pawlewicz}


\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003752.10003809.10003635</concept_id>
       <concept_desc>Theory of computation~Graph algorithms analysis</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10002950.10003624.10003633.10010917</concept_id>
       <concept_desc>Mathematics of computing~Graph algorithms</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10002950.10003624.10003633.10010918</concept_id>
       <concept_desc>Mathematics of computing~Approximation algorithms</concept_desc>
       <concept_significance>300</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Graph algorithms analysis}
\ccsdesc[500]{Mathematics of computing~Graph algorithms}
\ccsdesc[300]{Mathematics of computing~Approximation algorithms}


\keywords{Fair problems, Cluster vertex deletion, metatheorem, parameterized complexity}

\category{} %




\nolinenumbers %

\EventEditors{John Q. Open and Joan R. Access}
\EventNoEds{2}
\EventLongTitle{42nd Conference on Very Important Topics (CVIT 2016)}
\EventShortTitle{CVIT 2016}
\EventAcronym{CVIT}
\EventYear{2016}
\EventDate{December 24--27, 2016}
\EventLocation{Little Whinging, United Kingdom}
\EventLogo{}
\SeriesVolume{42}
\ArticleNo{23}




\begin{document}

\maketitle

\begin{abstract}

  %
  %
We study fair vertex problem metatheorems on graphs within the scope of structural parameterization in parameterized complexity.
 Unlike typical graph problems that seek the smallest set of vertices satisfying certain properties, the goal here is to find such a set that does not contain too many vertices in any neighborhood of any vertex.
Formally, the task is to find a set $X\subseteq V(G)$ of fair cost $k$, i.e., such that for all $v\in V(G)$ $|X\cap N(v)|\le k$.
Recently, Knop, Masařík, and Toufar [MFCS 2019] showed that all fair \MSOo definable problems can be solved in \FPT time parameterized by the twin cover of a graph.
They asked whether such a statement would be achievable for a more general parameterization of cluster vertex deletion, i.e., the smallest number of vertices required to be removed from the graph such that what remains is a collection of cliques.

In this paper, we prove that in full generality this is not possible by demonstrating a \W{1}-hardness.
On the other hand, we give a sufficient property under which a fair \MSOo definable problem admits an \FPT algorithm parameterized by the cluster vertex deletion number.
Our algorithmic formulation is very general as it captures the fair variant of many natural vertex problems such as the Fair Feedback Vertex Set, the Fair Vertex Cover, the Fair Dominating Set, the Fair Odd Cycle Transversal, as well as a connected variant of thereof. %
Moreover, we solve %
the Fair $[\sigma,\rho]$-Domination problem for $\sigma$ finite, or $\sigma=\mathbb{N}$ and $\rho$ cofinite.
Specifically, given finite or cofinite $\rho\subseteq \mathbb{N}$ and finite $\sigma$, or $\rho\subseteq \mathbb{N}$ cofinite and $\sigma=\mathbb{N}$, the task is to find set of vertices $X\subseteq V(G)$ of fair cost at most $k$ such that for all $v\in X$, $|N(v)\cap X|\in\sigma$ and for all $v\in V(G)\setminus X$, $|N(v)\cap X|\in\rho$.
\end{abstract}


\section{Introduction}\label{sec:intro}

We investigate the parameterized complexity of a large class of vertex graph problems under a structural parameterization.
In particular, we study fair problems that are becoming more popular in recent years while their history can be traced back to the 80's~\cite{LinSahni}.
The paradigm of the \emph{fair problems} is that we seek a solution, usually represented as a subset of some universe, which is well-distributed within the given underlying structure but does not necessarily have the smallest possible size.
The standard formal formulation of the idea above which is tailored to graph problems uses the fair cost function as a measure of well-distributedness.
Given a graph $G$, we define the \emph{fair cost} (\fcnobrackets{}) of set $\VS \subseteq \Vertices(\Graph)$ as $\fc{\VS}\df \max_{v \in \Vertices(\Graph)} |\nb{v} \cap \VS|$, where $\nb{v}$ is an open neighborhood of vertex $v$ in $\Graph$. 
Then the \emph{fair vertex problems} on graphs are graph problems defined as set $\VS\subseteq V(G)$ of the smallest fair cost among all vertex subsets satisfying some property.
As we wish to solve a large collection of problems, we need to formally characterize what properties we care about.
For that, we use a concept of graph logic which is a standard tool that allows us to specify a collection of problems stateable using common tools.
For example, in the \MSOo logic, for which we design our main \FPT algorithm, we can define many standard graph properties such as $k$-colorability, acyclicity, and even the connectivity of a set. %
See \Cref{sec:logic} for more details.
Before stating a formal definition, we wish to bring up one detail which we would like to discuss:
We separate the class of problems into two categories.
First, where the logic does not have access to set $X\subseteq V(G)$ which is only used to compute the fair cost.
Second, on the other hand, provides access to $X$ which plays the role of a free variable in the formula.
Therefore, we provide two distinct problem formulations below.
We follow the notation established in~\cite{KMT19}, where $\textsf{L}$ represent an abstract logic.


\prob{\sc Fair Vertex $\mathsf{L}$ Deletion}
{An undirected graph $\Graph$, $k\in\mathbb{N}$, and a sentence $\varphi$ in logic \textsf{L}.}
{Is there a set $\VS \subseteq \Vertices(G)$ of fair vertex cost at most $k$ such that $\GraphInd{\Vertices(G) \setminus \VS} \models \varphi$?}

In the above definition, $\GraphInd{Y}$ denotes $\Graph$ induced by $Y \subseteq \Vertices(G)$.
We can observe that this definition is rather general but it does not capture, for example, the Fair Dominating set problem, i.e., a problem asking for a set $X\subseteq V(G)$ such that for all $v\in V(G)$ $N[v]\cap X\neq \emptyset$.
Hence, we present the more powerful variant where we allow free variables. 

\prob{\sc $\ell$-Fair Vertex $\mathsf{L}$ Evaluation}
{An undirected graph $\Graph$, $k\in\mathbb{N}$, and a formula $\varphi(X_1,\ldots,X_\ell)$ with $\ell$ free variables in logic \textsf{L}.}
{Are there sets $W_1,\ldots,W_\ell$ of vertices each of fair vertex cost at most $k$ such that $\Graph \models \varphi(W_1,\ldots,W_\ell)$?}{}

In the special case of $\ell=1$, we say only {\sc $\mathsf{L}$-FairVE}.
So far, we defined the fair vertex problems when provided with logic $\mathsf{L}$ and graph $G$, where the aim is to find a set $X\subseteq V(G)$ of the smallest fair cost that satisfies some formula of $\mathsf{L}$.
To speak about particular problems, we often use a template where we say \emph{fair -something-} problem if the -something- problem can be described in some $\mathsf{L}$ and, therefore, its fair variant belongs to the {\sc $\mathsf{L}$-FairVE} problems.
An important first such example is the Fair Vertex Cover problem, which can be described in \FO logic by a simple formula stating that 
for all vertices $x,y\not\in X$, we have $xy\not\in E(G)$. 
Note an important detail that we do not count the access to set $X$ representing the free variable as using a set variable.
In fact, we can even express the above in the deletion variant and so, the Fair Vertex Cover belongs to the {\sc Fair Vertex \FO Deletion} problems.

We can easily modify the fair vertex problem definitions to edge problems where we seek $F\subseteq E(G)$ subject to \emph{edge fair cost} function defined as $\fc{F}\df \max_{v \in \Vertices(\Graph)} \text{deg}_F(v)$, where $\text{deg}_F(v)$ measures the number of edges incident to vertex $v$ that are in $F$.
The edge variant was the original studied variant in early works~\cite{LinSahni,KLS10Kam,Kolman09onfair} until the vertex variant was formally defined in 2017~\cite{MT20}. %
Edge variant is important for the context, but in the current paper we only explore the fair vertex problems and, therefore, we refrain from formal definitions.
For more details on the topic see~\cite{KMT19}. %


In this paper, we study the fair vertex problems under structural parameterization.
Very recently, in 2023, Gima and Otachi~\cite{GimaOtachi} showed that {\sc $\ell$-Fair Vertex \MSOt Evaluation} is \FPT parameterized by the vertex integrity and the size of the formula. 
This is complemented with \W{1}-hardness of the Fair Vertex Cover problem even when parameterized by treedepth and feedback vertex set combined~\cite{KMT19}.
Notice that there is very little gap between those parameters, so the situation on the sparse side of the spectrum seems to be relatively understood.
On the other hand, we know much less about dense graph parameters.
Knop, Koutecký, Masařík, and Toufar~\cite{KKMT} showed that {\sc $\ell$-Fair Vertex \MSOo Evaluation} is \FPT parameterized by the neighborhood diversity and the size of the formula. 
Note that \MSOo cannot be extended to \MSOt on dense graph parameters because \MSOt model-checking on cliques is not even in \XP unless $\mathsf{E} = \mathsf{NE}$ \cite{CMR,Lampis14}.
Parameterization by the twin cover is explored in \cite{KMT19} and the {\sc \MSOo-FairVE} is \FPT parameterized by the twin cover and the size of the formula while {\sc $\ell$-Fair Vertex \MSOo Evaluation} is already \W{1}-hard under the same parameterization.
The question raised in \cite{KMT19} was whether the {\sc \MSOo-FairVE} remains \FPT even when parameterized by the stronger parameter of the cluster vertex deletion. %
The \emph{cluster vertex deletion} number is the size of the smallest set $D\subseteq V(G)$ such that $G-D$ (i.e., $G[V(G)\setminus D]$) is a collection of disjoint cliques.
We denote a set $D\subseteq V(G)$ such that $G-D$ is a collection of disjoint cliques a \emph{modulator} of graph $G$.
The cluster vertex deletion number is a well-known optimization problem; see e.g., \cite{IKP23} for a very recent overview of results.
Nevertheless, it has already been successfully used as a structural graph parameter to provide \FPT algorithms for various graph problems in past two years~\cite{BKR23,GKKMV23,KS23}.
In this paper, we resolve the general question negatively, while providing a very extensive collection of problems that do admit still an \FPT algorithm under our parameterization.
We refer to \cref{fig:classes} for a visual overview of the results and graph class relations.


\begin{figure}
\centering
\begin{subfigure}{0.32\textwidth}
    \includegraphics[width=\textwidth]{classes.pdf}
    \caption{Parameterized complexity of the Fair Vertex Cover problem.}
    \label{fig:classes:VC}
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
    \includegraphics[width=\textwidth]{classes2.pdf}
  \caption{Parameterized complexity of the {\sc \MSOo-FairVE} problem.}
    \label{fig:classes:FairVE}
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
    \includegraphics[width=\textwidth]{classes3.pdf}
    \caption{Parameterized complexity of the {\sc $\ell$-Fair Vertex \MSOo Evaluation} problem.}
    \label{fig:classes:FairlVE}
\end{subfigure}
        
\caption{Parameterized complexity the fair vertex problems. The green color means there is an \FPT algorithm parameterized by the structural parameter (and the size of the formula if it applies). The red color highlights parameters for which there is \W{1}-hardness result and the blue color marks yet unknown.
  Results bounded in rectangle are new in this paper.
}
\label{fig:classes}
\end{figure}




\paragraph*{Related Results.}
The concept of Fair Problems has been extended to include \emph{local cardinality constraints}, as introduced by Szeider~\cite{Szeider:11}. 
For a graph $G$ with cardinality constraints $\alpha(v)\subseteq [n]$ for all $v\in V(G)$. 
  The solution is a subset $W\subseteq V(G)$ such that $|W\cap N(v)|\in \alpha(v)$ for all $v\in V(G)$. A notable special case, introduced in \cite{KKMT}, is called  \emph{linear local cardinality constraints}, where all $\alpha(v)$ forms an interval.
  Local linear problems were further studied in~\cite{Knop2021}.
Observe that the fair vertex problems with fair cost $f$ represent the simplest local cardinality constraints, where $\alpha(v)=[f]$ for all $v\in V(G)$.

There was also some interest in exploring particular fair problems parameterized by their solution size, see e.g., \cite{JRS,KMMS21}.
Papers \cite{IKKPS25,JRS,FairHighwayDimension} studied an extension of the fair concept into set, specifically introducing and tackling the fair hitting set problem.
Moreover, \cite{FairHighwayDimension} shows that the Fair Vertex Cover problem is \NP-complete for any $k\ge 4$ even on planar graphs, where $k$ is the fair cost of the solution.
  %



\subsection{Our Results}

Here, we closely describe our results.
First, we state our hardness theorem which is answering a general case of a question posted in~\cite{KMT19}. %
Notice that the hardness is for the most restricted (deletion) version of metatheorems where only a sentence in \FO logic is used after the deletion of a set.
  \begin{restatable}[Hardness]{theorem}{WhThm}\label{thm:hardness} 
    The Fair Vertex \FO Deletion problem is \W{1}-hard parameterized by the cluster vertex deletion number and the size of the formula. 
\end{restatable}

To state the positive result precisely and formally we need to introduce much more model-checking background and tools which we do in \Cref{sec:mc}.
It would be too technical to state it at this point in the introduction.
We would rather give an overview, intuition, and a less formal statement here.
We also explain the methods of our proof and we conclude with the list of fair problems which we show to be solvable in \FPT time parameterized by the cluster vertex deletion. 


A big-picture strategy of our proof can be summarized as follows. 
First, we characterize all the objects, called shapes, that can be viewed as classes of equivalence from the perspective of the formula.
That means we can check the truthfulness of the formula on the shape.
At the same time, each graph $G$ and a solution $X\subseteq V(G)$ can be reduced to some shape.
See \cref{sec:shape} for the formal definition.
A desired outcome of this part of the proof is that the number of shapes is bounded in parameters; the formula size and the size of a modulator.
Therefore, all the shapes can be enumerated in \FPT time.
A drawback of this strategy is that the fair cost of the input graph $G$ cannot be easily mapped to the shapes and has to be computed. 
That is what we are going to do.
Given a shape we are able to formulate an integer linear program (ILP) to recover the solution of minimal fair cost, which belongs to the equivalence class of this shape.
Moreover, such an ILP has the number of variables bounded by our parameters, therefore we utilize the following algorithm originally proposed by Lenstra~\cite{Lenstra83}.
\begin{theorem}[{\cite{Lenstra83} with an improved running time by Reis and Rothvoss~\cite{RR23}}]\label{thm:ILPinBoundedDimension}
  There is an algorithm that, given an ILP (Integer Linear Program) with $p$ variables and $m$ constraints, finds an optimal solution in time ${\log p}^{\mathcal{O}(p)} \cdot (m\log L)^{\mathcal{O}(1)}$, where $L$ is the maximum absolute value of the coefficients.
\end{theorem}
Hence, the approach above leads to a solution in \FPT time.
Such a general approach was used in both \cite{KMT19, MT20}.


However, we faced a few differences which complicated the approach sketched above.
After all, under current parameterization, the general problem is \W{1}-hard.
The first difference is that the objects are more complicated compared with the previous parameterizations \cite{KMT19, MT20}, and so the whole model-checking machinery has to be verified to still hold in this case.
Certainly, compared to the twin cover, each clique can have many different neighborhoods in the modulator.
To prove this part, we used tools developed by Lampis~\cite{Lampis12} and by Knop, Masařík, and Toufar~\cite{KMT19}.
After a meticulous verification we, indeed, know that there are only parametrically many shapes that are relevant with respect to the formula.
It is interesting to note that once we have the above, it actually provides an alternative proof of the model-checking (without measuring the fair cost; see \cref{cor:mc}) in \FPT, time reproving older results, (e.g., implied by \cite{CMR}). %

For the second difference, we need to take a closer look at what the shape looks like.
It describes the solution on the modulator $D$ exactly, so from now on we focus only on cliques in $G-D$. 
We partition all the cliques into groups, where each group contains cliques that are either small and have the same number of vertices of identical neighborhoods in the modulator or are large an have all large number of such vertices of identical neighborhoods in the modulator.

For such cliques, shape tells us \textbf{either} how many vertices need to be used in the free variable \textbf{or} how many vertices need to be left out from the free variable.
We have such information for all groups of cliques.
Although, for groups containing large cliques (which can possibly consist of different sizes of cliques), we only know the shape of a group as a whole and not about the individual cliques in the group.
Therefore, we do not know how to assign the cliques of the original graph $G$ to the information described in shape so that we minimize the fair cost.
The crucial point in our proof is that as long as the shape states that for all cliques in one group that \textbf{either} all of them are described by how many vertices need to be used in the free variable \textbf{or} all of them are described by how many vertices need to be left out from the free variable, we are able to formulate an integer linear program in bounded dimension that computes the minimum fair cost (\cref{thm:ILPinBoundedDimension}).
We call shapes that satisfy the above property \emph{coherent}; see \cref{def:coherent} for a formal definition.
Let us summarize this statement as an informal main theorem.
The formal equivalent is presented in \cref{sec:FPT statement} as \cref{thm:main-fpt}.

\begin{theorem}[Main informal algorithmic \FPT statement; see \cref{thm:main-fpt} for a formal version]\label{thm:main-informal}
    %
    Let $\phi(\aleph)$ be a fixed \MSOo formula with one free variable and $G$ be a graph. 
    %
    %
    If there exists a solution of the minimal fair cost whose shape is coherent then we can solve the respective \textsc{\MSOo-FairVE} problem in \FPT time parameterized by $|\phi|$ and $|D_G|$.
\end{theorem}



Surprisingly, observe that the assumptions of the theorem are properties of the problem, and more importantly, we can decide about individual problems whether they satisfy this assumption.
We do such a verification in \cref{sec:problems}.
Let us demonstrate an example of such a reasoning for the Fair Vertex Cover problem.
Notice that from each clique we need to take either all or all but one vertices to the vertex cover set.
Therefore, each such solution leads to a coherent shape, as even the solution on all cliques is described by how many vertices need to be left out from the free variable.
It is for each clique either zero or one as reasoned above.


We define several fundamental graph vertex problems that are covered by \cref{thm:main-informal}. 
We provide only very concise formulation here, for more details see \cref{sec:problems}.
Given a graph and integer $d$ at the input.
We describe the problems by expressing how $G-X$ is constrained.
Note that in addition to that we are looking for $X$ with fair cost at most $d$.
The \emph{Fair Feedback Vertex Set} problem requires $G-X$ to be a forest.
The \emph{Fair Odd Cycle Transversal} problem requires $G-X$ to be a bipartite graph.
Of course, we can impose additional \MSOo expressible constraints on $X$ in all the problems above.
In particular, the connectivity constraint on $X$ leads to variants of the problems above that has been well studied in non-fair setting; see e.g., a recent study of those problems parameterize by clique-width~\cite{FK23}.
We also define the Fair $[\sigma,\rho]$-Domination problem for $\sigma$ finite, or $\sigma=\mathbb{N}$ and $\rho$ cofinite.
Such class of problems has been coined by Telle in~\cite{T94}.
There, the task is to find set of vertices $X\subseteq V(G)$ such that for all $v\in X$, $|N(v)\cap X|\in\sigma$ and for all $v\in V(G)\setminus X$, $|N(v)\cap X|\in\rho$.
An important and classical member of the family of problems above is the \emph{Fair Dominating Set} problem, where $\sigma=\mathbb{N}, \rho = \mathbb{N}\setminus \{0\}$.


We conclude with a list of problems that are implied by \cref{thm:main-informal}.



\begin{corollary}\label{cor:problmesFPT}
  We can solve the following problems in \FPT time parameterized by the cluster vertex deletion.
    \begin{multicols}{2} %
\begin{itemize}
  \item Fair Vertex Cover,
  \item Fair Feedback Vertex Set,
  %
\item Fair Odd Cycle Transversal, %
    \columnbreak
  \item Fair Dominating Set,
  \item A connected variant of the preceding problems,
  %
  %
  %
  \item Fair $[\sigma,\rho]$-Domination problem for $\sigma$ finite, or $\sigma=\mathbb{N}$ and $\rho$ cofinite.
\end{itemize}
\end{multicols}
\end{corollary}



 %
 %
 %
 %
 %
 %
 %
 %




\paragraph*{Organization of the paper.}
After a short preliminaries (\Cref{sec:prelims}) we describe the model-checking toolbox and give proofs related to structural understanding of the problem in \cref{sec:mc}.
Notably, we state the main theorem formally in \Cref{sec:FPT statement}.
In \cref{sec:FPT} we provide the algorithmic side of the proof including an ILP formulation of the problem.
Then we include \cref{sec:problems} which provides problem statements of natural problems that are solved by our main theorem together with proofs that they are covered by it.
\cref{sec:hardness} contains the proof of our hardness result.
We conclude with short conclusions (\cref{sec:conc}).





\section{Preliminaries}\label{sec:prelims}
We denote $\setupto{n}\df \{ 0,1,2,\ldots n \}$ and $\nodd \df \{2n+1 : n \in \mathbb{N} \}$.
For a graph $\Graph$ and a set $\VSx \subseteq \Vertices(G)$, we denote its complement by $\NOT{X}\df\Vertices(G) \setminus \VSx$.
A \emph{modulator} $\MS \subseteq \Vertices(G)$ of $\Graph$ is a set such that $\GraphInd{\Vertices(G) \setminus \MS}$ is a collection of vertex disjoint cliques. For every graph $G$, we denote by $\MSs$ any fixed modulator of the smallest size. We also assume that a set $\MSs$ has fixed ordering. For a graph $\Graph$ and its modulator $\MSs$, we let $\Cc_\Graph$ denote the collection of cliques in $\GraphInd{\Vertices(G) \setminus \MSs}$. For a set $\VSx \subseteq \Vertices(G)$ and a vertex $v \in \Vertices(G)$, we have $\nbd{\VSx}{v}\df\nb{v} \cap \VSx$, i.e., the neighbors of $v$ in~$\VSx$. 
As we will be analyzing the neighborhoods of vertices in modulator $\MSs$ of $\Graph$, that is $\nbd{\MSs}{v}$, we will use a slightly different notation. %
We denote all binary vectors of length $d$ by $\ntypes_{d}$. 
Recall that we also assumed that vertices in $\MSs$ are ordered, so that there is a natural bijection between all subsets of $\MSs$ and vectors in $\ntypes_{|\MSs|}$. 
For each $C\in\Cc_\Graph$ and for each $\nT\in\ntypes_{|\MSs|}$, we define $C_\nT\df \{ v \in \Vertices(C) : \nbd{\MSs}{v}=\nT \}$ as the set of vertices in $C$ whose neighborhood type is $\nT$.
Since we will mostly be using $\ntypes_{|\MSs|}$, we will use just $\ntypes$ when it is clear from the context.

A \emph{signature} of a clique $C \in \Cc_\Graph$ is a vector $\signat{}{C}$ indexed with neighborhood types. For each $\nT \in \ntypes$, we set $\signat{}{C}[\nT] \df |C_\nT|$. 
For $C \in \Cc_\Graph$, we also define \emph{$\alpha$-truncated signature} ${\signat{\alpha}{C}[\nT] \df \min(|C_\nT|, \alpha)}$.
For $\alpha\in\nodd$\footnote{For technical ease of notation that will be apparent later, we insist on $\alpha$ being odd. At this point, this assumption is not necessary, but we prefer to make it consistent and prepare the reader from the start that $\alpha$ takes only odd values.}, we define an \emph{$\alpha$-clique type} that is a vector \cT indexed with neighborhood types $\nT \in \ntypes$ and values from $[\alpha]$ such that for $C \in \Cc_\Graph$, $\cT[\nT] \df \min ( \alpha, |C_\nT| )$. 
We denote $\ctypes^{(\alpha, |\MSs|)} \df [\alpha]^{\ntypes_{|\MSs|}}$ set of all $\alpha$-clique types. 
Clearly, $|\ctypes^{(\alpha, |\MSs|)}| = \alpha^{|\ntypes_{|\MSs|}|} = \alpha^{2^{|\MSs|}}$. 

\subsection{Logic}\label{sec:logic}

The formulas of \MSOo logic are those which can be constructed using vertex variables, denoted usually by $x_i, y_i, \dots$, set variables denoted usually by $X_i, Y_i, \dots$, \emph{label classes} denoted by $L_i$, the predicates $E(x_i,x_j), x_i \in L_j, x_i = x_j$ operating on vertex variables, standard propositional connectives and the quantifiers $\exists, \forall$ operating on vertex and set variables. The semantics are defined in the usual way, with the $E(x_i, x_j)$ predicate being true if and only if $(x_i,x_j) \in E$ and labels being interpreted as sets of vertices. 

We will also consider two more standard logics in graph theory. An \FO logic only allows quantifications over elements (vertices or edges).
A more powerful, \MSOt, where in addition to \MSOo, even quantification over the set of edges is allowed.
It is well known that \FO $\subsetneq$ \MSOo $\subsetneq$ \MSOt, where the connectivity, and the Hamiltonian cycle are properties demonstrating strict inclusions, respectively.
For more details consult e.g., \cite{CE-book}.

Let $\phi(\aleph)$ be a formula with one free variable. 
The \emph{size} of the formula (denoted as $|\phi|$) is measured in the number of vertex and set quantifiers. 

\section{Shapes and Model-Checking}\label{sec:mc}

In this section, we introduce the terminology needed to prove the correctness of our \FPT algorithm (\cref{thm:main-informal}). Firstly, we define compliant solutions (\cref{sec:compliant}), which provide canonical representations of solutions without any loss in either the fair cost or the formula. 
After that, we give a formal definition of a shape which is the main object used for the model-checking (\cref{sec:shape}). %
With these foundations, we formally state our main theorem (\cref{thm:main-fpt}) in \cref{sec:FPT statement}.
Then we introduce additional model-checking tools in \cref{sec:mcTools}. 
\cref{sec:mc:mainProofs} proves two main statements of this section.
First, that restricting attention to compliant solutions is sufficient from both model-checking as well as the fair cost perspectives (\cref{lem:compliant}).
Second, provides an equivalence of model-checking of a graph $G$ with compliant $X\subseteq V(G)$ on one side and the respective shape on the other side (\cref{lem:shape_equivalence_one}). 
As mentioned, the conclusion of this section is that \MSOo model-checking can be done in \FPT time parameterized by the cluster vertex deletion and the size of the formula (\cref{cor:mc}).


\subsection{Compliant Set}\label{sec:compliant}
In this short subsection, we define how well-structured sets of vertices look like.
Those sets will play the role of canonical solutions with respect to both the formula and the fair cost.
This property is captured by \cref{lem:compliant}.


\begin{definition}[$\alpha$-compliant sets]
Let $\alpha$ be a positive integer and $G$ be a graph. Recall that  $\Cc_G$ is the collection of cliques in $G-D_G$.

We say that $X\subseteq V(G)$ is \emph{$\alpha$-compliant} if for each $C \in \Cc_G$ and for each $\nT\in\ntypes$
\[\text{either } |X\cap V(C_\nT)|\le \frac{\alpha}{2} \text{ or } |\NOT{X}\cap V(C_\nT)|\le \frac{\alpha}{2}.\]
\end{definition}

\begin{lemma}[Compliant solution of capped fair cost]\label{lem:compliant}
    There is a computable function ${f:\mathbb{N}^2\rightarrow \mathbb{N}}$ such that for any \MSOo formula $\phi(\aleph)$ with one free variable, for any graph $G$, and for any $\alpha \in \nodd, \alpha > f(|D_G|, |\phi|)$, the following is true. For each $X\subseteq V(G)$ such that $G\models \phi(X)$, there exist $X'\subseteq V(G)$ such that:
    \nopagebreak
    \begin{multicols}{3}
\begin{itemize}
  \item $X'$ is $\alpha$-compliant, 
  \item $G\models \phi(X')$, and
  \item $\fc{X'}\le\fc{X}$.
\end{itemize}
\end{multicols}
\end{lemma}

We postpone the proof to \cref{sec:mc:mainProofs} as we first need to introduce more model-checking tools before we can prove it.
However, the statement gives us a good intuition that we will need to care only of solutions $X$ that are $\alpha$-compliant as the other solutions do not have a better fair cost while having the same expressive power.

\subsection{Shapes}\label{sec:shape}
Throughout this section, we assume that every solution $X$ is $\alpha$-compliant, for some fixed $\alpha$ that depends only on the formula and the size of the modulator. %
Recall that, in \cref{lem:compliant}, we prove that it is sufficient to consider only such solutions.

Now we describe how a solution $X$ satisfying formula $\phi(\aleph)$ on a graph $G$ can be represented.
To do so, we introduce the concept of shapes and solution patterns. 
We define a \emph{solution pattern} as a vector indexed with neighborhood types $\nT \in \ntypes_{d}$ and with values from $\setupto{\alpha}$. We denote all \emph{solution patterns} as $\spatterns^{(\alpha, d)}\df[\alpha]^{\ntypes_d}$. 
Intuitively, every $\sP \in \spatterns^{(\alpha, |\MSs|)}$ describes how solution $X$ is distributed over vertices with a specific neighborhood type in a particular clique $C \in \Cc_G$. For a graph $G$ and  $\sP \in \spatterns^{(\alpha, |D_G|)}$ and for every $\nT \in \ntypes_{|D_G|}$, whenever $\sP[\nT] < \alpha / 2$ then there is exactly $\sP[\nT]$ nodes of type $\nT$ from $C$ in solution $X$. On the other hand if $\sP[\nT] > \alpha / 2$, then there are all but $\alpha - \sP[\nT]$ nodes of type $\nT$ from $C$ in solution $X$. We will use shorthand notation $\spatterns$ for $\spatterns^{(\alpha, |D_G|)}$ , when its clear from the context.

\medskip

\begin{definition}[Shapes]\label{def:shape}
  Let $\alpha \in \nodd$ and $\gamma, d \in \mathbb{N}$. 
  We define $\shapes^{(\alpha,\gamma, d)}$ as a set of all tuples $(\nT^*,\mtx)$, where:
  \begin{enumerate}
    \item[1)] $\nT^* \in \ntypes_d$, %
    \item[2)] $\mtx$ is a $|\spatterns^{(\alpha, d)}| \times |\ctypes^{(\alpha+1, d)}|$ matrix 
  whose entries are from $\setupto{\gamma}$, and %
\item[3)] \phantomsection\label{c:3} for each $\nT\in\ntypes$, $\cT\in\ctypes^{(\alpha+1, d)}$, and $\sP\in\spatterns^{(\alpha, d)}$ such that $\mtx[\sP, \cT]>0, \cT[\nT] \leq \alpha$, we have $\sP[\nT]\le\cT[\nT]$.
\end{enumerate}
We refer to an element $\shape\in\shapes^{(\alpha,\gamma,d)}$ as a \emph{shape}.
\end{definition}

\medskip
  Observe that each entry in \mtx can be classified as one of 3 types, described below. 
  We say that particular $(\nT, \ctype)$, where $\nT\in\ntypes$ and $\ctype\in\ctypes^{(\alpha+1, d)}$, is \emph{bounded} if $\ctype[\nT] \leq \alpha$.
  Otherwise (i.e., $\ctype[\nT]=\alpha+1$), $(\nT, \ctype)$ is \emph{unbounded}.
  If $(\nT, \ctype)$ is unbounded we further say that for some $\sP\in\spatterns^{(\alpha, d)}$: 
  \begin{itemize}
    \item either $(\nT, \ctype, \sP)$ is \emph{fat} whenever $\alpha/2 < \sP[\nT] $,
    \item or $(\nT, \ctype, \sP)$ is \emph{thin} whenever $\sP[\nT]<\alpha/2$.
  \end{itemize}
  If $(\nT, \ctype)$ is bounded then we say $(\nT, \ctype, \sP)$ is \emph{bounded} for any $\sP \in \spatterns^{(\alpha, d)}$.
  Note that as $\alpha$ is odd $(\nT, \ctype, \sP)$ is either thin, fat, or bounded.
Also note that Condition~\hyperref[c:3]{3)} in \cref{def:shape} is necessary, as it ensures that whenever clique $C$ is bounded, a solution pattern $\sP$ does not describe a solution containing more vertices than there is in respective $\nT$ in $C$.


Now, we can provide intuition about shapes. First, we briefly describe the meaning of the parameters $\alpha, \gamma$. Roughly speaking, $\alpha$ corresponds to the maximum number of vertices of the same neighborhood within a single clique that the formula can distinguish. In other words, once there are more than $\alpha$ such vertices, increasing their number further makes no difference to the formula. On the other hand, $\gamma$ corresponds to the maximum number of cliques of the same clique type the formula can distinguish. We will formalize this intuition in \cref{prop:lam} and \cref{cor:induction}.
Given $G$ and $\phi(\aleph)$, we define $\shapes^{(\alpha, \gamma, |\MSs|)}$ as a set of all possible shapes the solution sets can take as $\alpha$ and $\gamma$ are computed from $\phi(\aleph)$ and $\MSs$.
Each such shape, denoted as \shape, consists of two parts.
First, we describe the portion of the solution set $X$ in the modulator $\MSs$. More precisely, $X \cap \MSs$ forms the first part of $\shape$, denoted $\nT^*$. The second part is a matrix, that describes how the solution $X$ is distributed over the cliques and their respective neighborhood parts.
Notice that the number of all possible shapes is bounded in terms of $\alpha, \gamma, |\MSs|$, so we can enumerate all of them, and maintain an \FPT complexity.


We proceed with the definition of a well-behaved class of shapes that we call coherent shapes.
Those will capture a solution of problems that we will be able to solve in \FPT time.

\begin{definition}[Coherent shape]\label{def:coherent}
  Let $\alpha \in \nodd$ and $\gamma, d \in \mathbb{N}$.
  We say that $(\nT^*,\mtx)=\shape\in\shapes^{(\alpha,\gamma, d)}$ is \emph{coherent} if for each $\nT\in\ntypes$ and $\cT\in\ctypes^{(\alpha+1, d)}$ such that $(\nT,\cT)$ is unbounded we have that elements of set $\{(\nT,\cT,\sP)\mid {\sP\in\spatterns^{(\alpha, d)}} \text{ and } \mtx[\sP,\cT] > 0 \}$ are either all thin or all fat.
  \end{definition}
  
  We define a relationship between a set of vertices representing a potential solution in the graph and a shape.


\begin{definition}
  For a graph $G$, clique $C \in \Cc_G$ and $\alpha \in \nodd$, we say that a set $X$ \emph{matches} a solution pattern $\sP \in \spatterns^{(\alpha, |\MSs|)}$ on clique $C$ if for each $\nT \in \ntypes_{|\MSs|}$ it holds that \\ $|X \cap C_\nT| = 
        \begin{cases*}
            \sP[\nT] & if $\cT[\nT] \leq \alpha$ \\
            \sP[\nT] & if $\cT[\nT] = \alpha+1$ and $\sP[\nT] < \alpha / 2$ \\
            |C_\nT| - (\alpha - \sP[\nT]) & if $\cT[\nT] = \alpha+1$ and $\sP[\nT] > \alpha/2$ 
          \end{cases*}$
\end{definition}

\medskip

\begin{definition}[Graph and a set associated with a shape]\label{def:associatedGraph}
  Given $(\nT^*, \mtx)=\shape \in \shapes^{(\alpha,\gamma, d)}$ we construct a graph $G'$ and describe $X'\subseteq V(G')$ \emph{associated} with $\shape$:
  \begin{itemize}
    \item[1)]  $G'$ has $d$ vertices in modulator and exactly those represented by vector $\nT^*$ are in $X'$,
    \item[2)]  $G'$ contains exactly  $\sum_{\sP \in \spatterns^{(\alpha, d)}} \mtx[\sP,\cT]$ cliques of clique type $\ctype$ described by $\cT$-th column $($each clique contains exactly $\ctype[\nT]$ vertices of neighbourhood type $\nT$ for each $\nT\in\ntypes)$.
      Moreover, set $X'$ matches solution pattern $\sP\in\spatterns^{(\alpha, d)}$ on exactly $\mtx[\sP,\cT]$ cliques out of those with clique type \cT.
\end{itemize}
\end{definition}


\medskip 

  We established that a shape can be interpreted as an instance of a solution. In particular, in \cref{def:associatedGraph}, we described how to associate a graph $G$ and set $X\subseteq V(G)$ with a specific shape. This allows us to evaluate a formula on $G$ where $X$ is substituted for the free variable. We can view this process as evaluating the formula on the shape directly. This is formalized in the following definition.

\begin{definition}[Evaluation of shape]\label{def:shapeEvaluation}
  Let $\phi(\aleph)$ be a fixed formula with one free variable.
  For each $\shape\in\shapes^{(\alpha,\gamma, d)}$ we define whether $\shape$ is \emph{true} or \emph{false} in the given formula $\phi(\aleph)$ $($denoted as $\models \phi(\shape))$.
  Let $G',X'$ be a graph and a set associated with $\shape$.
  Then $\models\phi(\shape)$ if and only if $G'\models\phi(X')$.
\end{definition}



Now, we describe the formal procedure for reducing the size of a clique $C$.
As $X$ is $\alpha$-compliant set we need to preserve at most $\alpha$ vertices in any $C_\nT$. Consequently, we can express any $\alpha$-compliant solution as a shape, which we will formally establish in \cref{shape:compliant_set}. 

\begin{definition}[Trimming]\label{def:trim}
Let $G$ be a graph,  $\alpha \in \nodd$, and $X$ is any $\alpha$-compliant set.
Then for each $\nT\in\ntypes$, $C_\nT$ such that $C\in\Cc_G$, and for each $X_{C_\nT}\df V(C_\nT)\cap X$ we define \emph{$\alpha$-trimmed} $C'_{\nT}\subseteq C_{\nT}$ and $X_{C'_{\nT}}\subseteq V(C'_{\nT})$: 
\begin{itemize}
  \item If $|C_{\nT}|\le \alpha$ then  $C'_{\nT}\df C_{\nT}$ and $X_{C'_\nT}\df X_{C_\nT}$.
  \item Otherwise, $|C'_{\nT}|\df \alpha+1$ and:
  \begin{itemize}
    \item If $|X_{C_\nT}| > |C_\nT|-\alpha/2$ then $|X_{C'_\nT}|\df \alpha +1 -  |V(C_{\nT})\setminus X_C|$.
    \item If $|X_{C_\nT}| \le |C_\nT|-\alpha/2$ then $|X_{C'_\nT}|\df \min\left(|X_{C_\nT}|,\lfloor\frac{\alpha}{2}\rfloor\right)$.
  \end{itemize}
\end{itemize}
\end{definition}
Note that we only work with $\alpha$-compliant $X$. 
Therefore, if $|X_{C_\nT}| > |C_\nT| - \alpha/2$ it follows $|V(C_{\nT})\setminus X_C| \leq \alpha / 2$ which means $|X_{C'_\nT}|$ is always non-negative.
Observe that according to this definition, $X_{C'_{\nT}}$ is a subset of $X_{C_\nT}$.
Given $G$ and $\alpha$-compliant $X\subseteq V(G)$ we create \emph{$\alpha$-trimmed} $G'$ and $X'\subseteq V(G')$ where for every clique $C$ and \nT, each $C'_\nT$ and $X_{C_\nT'}$ are $\alpha$-trimmed, and the modulator of $G$ is left unchanged. Then it holds that $D_G \subseteq V(G')$.


Now, we are ready to encode all $\alpha$-compliant solutions (the number of which depends on the size of $G$) into shapes (which are bounded in terms of $|\phi|$ and $|\MSs|$) and evaluate only the latter.  


\begin{definition}[Shape agreeing with compliant set]\label{shape:compliant_set}
  Let $\alpha \in \nodd$ and $\gamma, d \in \mathbb{N}$. Let $G$ be a graph, where $D\subseteq V(G)$ is the modulator and $\Cc$ is the collection of cliques in $G-D$.
  Let $X\subseteq V(G)$ be $\alpha$-compliant.
  Let $\tilde{G}$, $\tilde{X}$ be $\alpha$-trimmed $G$, $X$ and also $\tilde{\Cc}$ be cliques of $\tilde{G}-D$.
  We say that $\shape\in\shapes^{(\alpha,\gamma, |\MSs|)}$ \emph{agrees} with $X$ on $G$ if $G',X'$ associated with $\shape$ are isomorphic to $\tilde{G}$, $\tilde{X}$ with the following exception.
  If there are exactly $\gamma$ cliques of the same clique type $\cT$ and the same value $|C_\nT\cap X|$ for all $\nT\in\ntypes$ in $\Cc'$ there are at least $\gamma$ of them in $\tilde{\Cc}$.
  \end{definition}
  
  We also say that $\alpha$-compliant set $X$ is an \emph{extension} of $\shape \in\shapes^{(\alpha,\gamma, |\MSs|)}$  whenever \shape agrees with $X$ on $G$.
  We denote the set of all shapes in $\shapes^{(\alpha, \gamma, |\MSs|)}$ that agrees with $X$ by $\shapes^{(\alpha, \gamma, |\MSs|)}(X)$.

  \begin{observation}\label{obs:oneShape}
    Let $G$ be a graph, and $X\subseteq V(G)$ be $\alpha$-compliant set for some $\alpha \in \nodd$. Then for each $\gamma \in \mathbb{N}$, there exists only one shape that agrees with $X$, i.e., $|\shapes^{(\alpha,\gamma, |\MSs|)}(X)|=1$. 
  \end{observation}
    Therefore, for the sake of convenience, we treat $\shapes^{(\alpha,\gamma, |\MSs|)}(X)$ as a single shape not as a set of shapes.
  To prove \cref{obs:oneShape} notice that for each clique $C \in \mathcal{C}_G$ there is exactly one $\sP \in \shapes^{(\alpha,\gamma, |\MSs|)}$, which agrees with the $\alpha$-compliant set $X$ on this clique.
  
  \subsection{\FPT algorithm statement}\label{sec:FPT statement}
  
  Now, we have enough ingredients to formally state our main theorem. 

  \begin{restatable}[FPT algorithm]{theorem}{fptThm}\label{thm:main-fpt}
    There is a computable function ${f:\mathbb{N}^2\rightarrow \mathbb{N}}$ such that for any \MSOo formula $\phi(\aleph)$ with one free variable, for any graph $G$, 
    $\alpha \in \nodd$ and $\gamma \in \mathbb{N}$, such that $\alpha, \gamma > f(|D_G|, |\phi|)$, the following is true:
    
    Let $\Xx$ be a collection of all sets $X\subseteq V(G)$ such that $G\models \phi(X)$.
    If there exists $\alpha$-compliant $X\in\Xx$ such that $\fc{X}\le \min_{X'\in\Xx} \fc{X'}$ and such that the shape in $\shapesag{|D_G|}(X)$ is coherent then we can solve the \textsc{\MSOo-FairVE} problem in \FPT time parameterized by $|\phi|$, $\alpha$,~$\gamma$, and $|D_G|$.
  \end{restatable}

  We point out that both $\alpha$ and $\gamma$ will subsequently be bounded by $|\phi|$ as will be specified in \Cref{prop:lam} and \cref{cor:induction} inside the next subsection.
  %


\subsection{Main Tools and Model-checking Machinery}\label{sec:mcTools}

Now we will build tools that allows us to capture our intuition that two $\alpha$-compliant sets, which have identical shapes that agree with both of them, are indistinguishable from the formula's perspective.
We now formulate the main lemma of this part.

\begin{lemma}\label{lem:shape_equivalence_one}
  There is a computable function ${f:\mathbb{N}^2\rightarrow \mathbb{N}}$ such that for any \MSOo formula $\phi(\aleph)$ with one free variable, for any graph $G$, and for any $\alpha \in \nodd$ and $\gamma \in \mathbb{N}$ such that $\alpha,\gamma > f(|D_G|, |\phi|)$, the following is true.
  If $X\subseteq V(G)$ is $\alpha$-compliant and  $\shape$ is the shape in  $\shapesag{\MSs}(X)$ we have that: $\models \phi(\shape)$ if and only if $G \models \phi(X)$.
\end{lemma}

Before we prove \cref{lem:shape_equivalence_one} in \cref{sec:mc:mainProofs} we need to introduce model-checking tools and notation. 
We will consider labeled graphs as discussed in \cref{sec:logic}, which are more convenient for proving some properties of the formula on a graph. Recall that a label is simply a subset of vertices. 

\begin{definition}
  For a labeled graph $G$ we say that vertices $u$ and $v$ have the same label type if they have the same labels and neighborhood type.
\end{definition}


We will follow the approach of an irrelevant vertex and an irrelevant clique as it was done in \cite{KMT19} and \cite{Lampis12}.

\begin{definition}\label{def:formula_to_sentene}
    For a given labeled graph $G$, a set $X \subseteq V(G)$, and a formula $\phi(\aleph)$, we define sentence $\phi_X$ in the following way.
    We introduce a new label $l_X$ and assign $l_X$ to all nodes in $X$, thus obtaining labeled graph $G_X$. We create sentence $\phi_X$ from $\phi(\aleph)$ by replacing every occurrence of $X$ with $l_X$. 
\end{definition}
    We observe that $\phi_X$ is a valid expression since $l_X$ represents a set of nodes as $X$ does. 

\begin{observation}\label{upd}
  Let $G$ be a labeled graph, $X \subseteq V(G)$, and $\phi(\aleph)$ be a formula. Then \[G \models \phi(X) \iff G_X \models \phi_X.\]
\end{observation}

Now we will state the theorem, which will be a useful tool in proving \cref{prop:lam}. Intuitively we want any $C_\nT$ to be able to shrink to a size that depends on the $\phi$ while maintaining the truthfulness of the formula.

\begin{theorem}[Reformulation of {\cite[Lemma 5]{Lampis12}}]\label{ref:lam}
   Let $G$ be a labeled graph and $\phi$ be an \MSOo sentence with $q_S$ set quantifiers and $q_v$ vertex quantifiers. Let $T \subseteq V(G)$ consist of vertices of the same label type. Also let $Q$ be any subset of $T$ such that $|T \setminus Q| \geq 2^{q_S}q_v$. Then $G \models \phi$ if and only if $G - Q \models \phi$.
\end{theorem}

\begin{corollary}[Corollary of {\cite[Lemma 5]{Lampis12}}]\label{prop:lam}
    Let $\phi(\aleph)$ be a fixed \MSOo formula with one free variable, $q_v$ vertex quantifiers, and $q_S$ set quantifiers.
    Let us denote $\tau \df 2 \cdot 2^{q_S}q_v$.
    Let $G$ be a graph and $T \subseteq V(G)$ be a set of vertices of the same label type, such that $|T| \geq \tau$.
    %
    Then for every $X \subseteq V(G)$, there exists $Q \subseteq T$ with $|T \setminus Q| = \tau$, such that the following is true. 
    \begin{align}
      G \models \phi(X)  &\iff %
        G - Q \models \phi(X \setminus Q) 
            \label{eq:TwinsReduction-case1}\\
              G - Q \models \phi(X \setminus Q) &\implies 
            \begin{cases}   
              G \models \phi( X \setminus Q)  & \text{if } |X\cap T| \leq |T| - \frac{\tau}{2}, \\
              G \models \phi( X \cup Q)   & \text{if } |X \cap T| \geq \frac{\tau}{2}.
               %
            \end{cases} \label{eq:TwinsReduction-case2} 
    \end{align}   
    Moreover, 
    \begin{align}
      \begin{cases}   \label{eq:XcapQ}
              |(T \setminus Q)\cap X|= |X\cap T| &  \text{if } |X\cap T| \leq \frac{\tau}{2}, \\
              |(T \setminus Q)\cap X|=\lfloor\frac{\tau}{2}\rfloor &  \text{if } \frac{\tau}{2}< |X\cap T| \leq |T| - \frac{\tau}{2}, \\
               |(T \setminus Q)\cap X|=\tau-|T\setminus X|  & \text{otherwise.}
            \end{cases}
          \end{align}
\end{corollary}


\begin{proof}
  We define $Q$ based on $|X\cap T|$.
  \newline \textbf{Case 1:} ${\frac{\tau}{2} < |X\cap T| \leq |T| - \frac{\tau}{2}}$.  
    %
    Let $Q_1$ be a subset of $X\cap T$ of size $|X \cap T|-\frac{\tau}{2}$ and let $Q_2$ be a subset of $T \setminus X$ of size $|T \setminus X|-\frac{\tau}{2}$. 
    Let $Q \coloneqq Q_1 \dot\cup Q_2$. 
 \newline    \textbf{Case 2:} $|T| - \frac{\tau}{2} < |X\cap T|$ 
    %
    Let $Q$ be any subset of $X\cap T$ of size $|T| - \tau$. 
 \newline    \textbf{Case 3:}  $|X\cap T| < \frac{\tau}{2}$ 
    %
  We set $Q$ to be a subset of $T \setminus X$ of size $|T| - \tau$.


  Observe that $Q$ is defined so that $|T\setminus Q|=\tau$.
    Also, we can now easily check that $Q$ satisfies \cref{eq:XcapQ} in all three cases.

  We now prove \Cref{eq:TwinsReduction-case1}. 
  Given $X$ we can use \Cref{upd}. 
  In \textbf {Case 2  and 3}, after labeling $X$, the whole set $Q$ as well as at least $\frac{\tau}{2}$ vertices of $T\setminus Q$ are defined to have the same labeled type. Therefore, we can directly apply \cref{ref:lam}.
  In \textbf{Case 1}, we apply \cref{ref:lam} twice. First on $Q_1$ and then on $Q_2$.
  Still, after labeling $X$, in each such a step $Q_1$ ($Q_2$) have the same labeled type as at least $\frac{\tau}{2}$ vertices of $T\setminus Q$.
  Therefore, in all cases, we have
    \[G \models \phi(X)  \iff  G_X - Q \models \phi_X. \]
   Observe that $G_X - Q \models \phi_X$ is equivalent to  $G_{X \setminus Q} - Q \models \phi_{X \setminus Q}$.
   Hence, we conclude the proof of \Cref{eq:TwinsReduction-case1} by applying \Cref{upd}.

   We conclude the proof by proving \Cref{eq:TwinsReduction-case2}. 
We consider two cases depending on the size of set $X\cap T$.
Suppose $|X\cap T| \leq |T| - \frac{\tau}{2}$.
By construction of $Q$, we know that $T\setminus Q$ contains at least $\frac{\tau}{2}$ vertices \textbf{not} in $X$.
Assume $G-Q \models \phi(X\setminus Q)$.
Using \Cref{upd}, we get it is equivalent to $G_{X\setminus Q}-Q \models \phi_{X\setminus Q}$.
In turn, there is at least $\frac{\tau}{2}$ vertices of the same labeled type \textbf{not} labeled by $X$ and we use this labeling on additional $|Q|$ vertices which we add to $G-Q$ and we apply \Cref{ref:lam} to it.
Hence, we obtain $G_{X\setminus Q}-Q \models \phi_{X\setminus Q} \iff  G_{X\setminus Q} \models \phi_{X\setminus Q} 
$ as we know that newly added vertices are not labeled by $X$.
We conclude by \cref{upd}.
Now, suppose $|X \cap T| \geq \frac{\tau}{2}$.
By construction of $Q$, we know that $T\setminus Q$ contains at least $\frac{\tau}{2}$ vertices in $X$.
Following the same steps as before, there are at least $\frac{\tau}{2}$ vertices of the same labeled type labeled by $X$ and we use this labeling on additional $|Q|$ vertices which we add to $G-Q$ before we apply \Cref{ref:lam} to it.
Hence, we obtain 
$G-Q \models \phi(X\setminus Q) \iff  G_{X\cup Q} \models \phi_{X\cup Q}$ as we know that newly added vertices are labeled by $X$.
We conclude by \cref{upd}.
\end{proof}

    %

    %



\begin{definition}
    We say that two cliques have the same labeled clique type if they have the same size, the
same clique type and there is isomorphism between their vertices that preserve labels.
\end{definition}


We now state an analog of the irrelevant clique lemma for bounded twin-cover \cite[Lemma 7\footnote{Lemma 8 in the full version of the paper \cite{KMT19-arxiv}}]{KMT19}. 
We decided to omit the proof as literally the same proof without any changes would work in our case as well.

\begin{lemma}[Corollary of the proof of {\cite[Lemma 8]{KMT19-arxiv}}]\label{lem:induction}
Let $G$ be a labeled graph with cluster vertex deletion $D$. Let $\phi$ be an \MSOo sentence with
$q_v$ vertex quantifiers and $q_S$ set quantifiers. Suppose the size of a maximum clique in $G \setminus D$ is bounded by $\ell$. If there are strictly more than
$\gamma(q_S, q_v, \ell) \coloneqq   2^{\ell \cdot q_S}(q_v + 1)$
cliques of the same labeled clique type $T$ then there exists a clique $C$ of the labeled clique type $T$ such
that $G \models \phi$ if and only if $G - C \models \phi$.
\end{lemma}




The above lemma, which holds for sentences, effectively allows us to shrink the graph so that it does not contain too many similar cliques. 
Now, we want to prove a similar statement for \MSOo formulas with one free variable.


\begin{corollary}\label{cor:induction}
  Let $G$ be a labeled graph with the size of maximum clique in $\Cc_G$ bounded by $\ell$ and assume that $\cvd(G)$ is at most $d$. Let $X\subseteq V(G)$, and let $\phi(\aleph)$ be a fixed \MSOo formula with $q_v$ vertex quantifiers and $q_S$ set quantifiers. If there are strictly more than 
\sv{$\gamma(q_S,q_v, \ell) \coloneqq 2\cdot 2^{\ell \cdot q_S}(q_v+1)$} cliques of the same labeled clique type $T$, then there exists a clique $C$ of a labeled clique type $T$ such that $G\models \varphi(X)$ if and only if $G - C \models \varphi(X \setminus C)$.
\end{corollary}

\begin{proof} %
  Let $G_X$ and $\phi_X$ be a graph and logic sentence according to \cref{def:formula_to_sentene}. Now it is enough to prove that $G_X \models \phi_X \iff G_X - C \models \phi_{X - C}$. Observe that in graph $G_X$ there exists at least $2^{\ell^{q_S}}(q_v+1)$ cliques of the same labeled clique type, as there is twice as many in the assumption of the corollary before we account for the label $l_X$.
  Now the corollary holds because of \cref{lem:induction}.
\end{proof}


\subsection{Proofs of Main Model-checking Statements}\label{sec:mc:mainProofs}


Before we prove \cref{lem:compliant} and \cref{lem:shape_equivalence_one}, we formulate the model-checking corollary.

\begin{corollary}\label{cor:mc}
  \MSOo model-checking can be done in \FPT time parameterize by the cluster vertex deletion and size of the formula.
\end{corollary}

\begin{proof}[Proof sketch]
     Let $q_S, q_v$ be a number of set quantifiers and vertex quantifiers in $\phi$, respectively.
     We specify $\alpha \coloneqq 2\cdot 2^{q_S}q_v$, $\gamma \coloneqq 2\cdot 2^{2^d\alpha \cdot q_S}(q_v+1)$ (recall $\alpha,\gamma$ are given by \cref{prop:lam} and \cref{cor:induction}).
     \Cref{lem:compliant} states that we can find the optimal solution even when restricted to $\alpha$-compliant sets.
     Therefore, we iterate over all  $\shape\in\shapes^{\alpha,\gamma,\MSs}$ whose number is bounded by parameters.
     On each $\shape$ we model-check formula on $\shape$ which leads to model-checking of the associated graph and the set (consult \cref{def:associatedGraph}) whose size are bounded by parameters.
     We conclude by \cref{lem:shape_equivalence_one} which provides a correctness of the approach above, as $\phi(\shape)$ is true if and only if there is $\alpha$-compliant set $X$ such that $G\models \phi(X)$.
\end{proof}

We can notice that the approach above is not the most simplified possible.
However, it illustrates the overall approach to model-checking using the shapes and other tools we build in order to be able to work towards the fair problems.
We continue by proving \Cref{lem:compliant}.









\begin{proof}[Proof of \cref{lem:compliant}]

Let $f(|\MSs|, |\phi|) \coloneqq 4 \cdot 2^{q_S}q_v$ and let us fix any odd $\alpha \geq f(|\MSs|, |\phi|)$. The statement is trivial if $X$ is $\alpha$-compliant on all $C_\nT$ where $C\in \Cc$ and $\nT \in \ntypes$. 
   Assume there is $C_\nT$ on which $X$ is not $\alpha$-compliant. Observe that $\frac{\alpha}{2} < |X_{C_\nT}| < |C_\nT| - \frac{\alpha}{2}$. Let $Q$ be a subset of size $|C_\nT| - \frac{\alpha}{2}$ from \cref{prop:lam}. 
    
    Thanks to \cref{eq:TwinsReduction-case1} we know that $G - Q \models \phi(X \setminus Q)$. Then we can apply the first case of \cref{eq:TwinsReduction-case2} to obtain $G \models \phi(X \setminus Q)$. According to \cref{eq:XcapQ} we get that $|(C_\nT \setminus Q) \cap X| = \lfloor\frac{ \alpha }{2}\rfloor$, but trivally $|(C_\nT \setminus Q) \cap X|  = |(X \setminus Q) \cap C_\nT| = \lfloor\frac{ \alpha }{2}\rfloor$. Let $X' = X \setminus Q$ and observe that $X' \subseteq X$ and $G \models \phi(X')$. We can apply the previous procedure to every $C_\nT$, at each time reducing set $X'$. Obviously, after the last reduction set $X'$ is $\alpha$-compliant. The other two properties are also satisfied because $X' \subseteq X$ and we maintain that $G \models \phi(X')$.
  %
  %
  %
  %
\end{proof}

The following lemma translate \cref{prop:lam} so it can be used in the situation when an $\tau$-compliant solution is trimmed (\cref{def:trim}).
\begin{lemma}\label{equi:trimmed}
Let $\tau \coloneqq 2\cdot 2^{q_S}q_v$.
  Let $G$ be a graph, $X\subseteq V(G)$ be $\tau$-compliant, and $\phi(\aleph)$ be and \MSOo formula with one free variable.  Let us fix any $C_\nT$ in $G$ and let $\tilde{C}_\nT, X_{\tilde{C}_\nT}$ be $\tau$-trimmed. Then it holds that \[ G \models \phi(X) \iff G - (C_\nT \setminus \tilde{C}_\nT ) \models \phi\big((X \setminus (C_\nT \setminus \tilde{C}_\nT)\big). \]
\end{lemma}

\begin{proof}
    %
    
    In the case $|C_\nT| \leq \tau+1$, $C_\nT$ is equal to $\tilde{C}_\nT$ so equivalence is obvious. Let $Q \subseteq V( C_\nT)$ be a set from \cref{prop:lam} and let us consider two remaining cases, how trimming $C_\nT$ might look like. From \cref{eq:TwinsReduction-case1} we get that $G \models \phi(X) \iff G - Q \models \phi(X \setminus Q)$. Thus, we only need to prove that $Q$ is isomorphic to $C_\nT \setminus \tilde{C}_\nT$.
    
    \item[ \textbf{Case 1:} $|C_\nT \cap X| > |C_\nT| - \frac{\tau}{2}$.] $\newline$
    Notice that $C_\nT \setminus \tilde{C}_\nT$ is a subset of X. According to \cref{eq:XcapQ} we get that $|Q \cap X| = |C_\nT | - \tau$, which means $Q \subseteq X$, which proves that $Q$ is isomorphic to $C_\nT \setminus \tilde{C}_\nT$.

    \item[ \textbf{Case 2:} $|C_\nT \cap X| \leq |C_\nT| - \frac{\tau}{2}$.] $\newline$
      According to \cref{def:trim} we get that $X_{\tilde{C}_\nT} = \min\left(\lfloor \frac{\tau}{2} \rfloor, |C_\nT \cap X| \right)$.
    From \cref{eq:XcapQ} we get that $|(T \setminus Q) \cap X| = \min\left(\lfloor \frac{\tau}{2} \rfloor, |C_\nT \cap X|\right)$. Thus, $Q$ is isomorphic to $C_\nT \setminus \tilde{C}_\nT$.
\end{proof}

\begin{proof}[Proof of \cref{lem:shape_equivalence_one}]
     Let $q_S, q_v$ be a number of set quantifiers and vertex quantifiers in $\phi$, respectively.
     Let $\alpha_0 \coloneqq 2\cdot 2^{q_S}q_v$, $\gamma_0 \coloneqq 2\cdot 2^{2^d\alpha_0 \cdot q_S}(q_v+1)$ (recall $\alpha_0,\gamma_0$ are given by \cref{prop:lam} and \cref{cor:induction}).
     We define $f(|\MSs|, |\phi|) \coloneqq \max(\alpha_0, \gamma_0)$. Now let us fix any $\alpha \in \nodd, \gamma \in \mathbb{N}$ larger than $f(|\MSs|, |\phi|)$.
    %
     %
    Recall, that due to \cref{obs:oneShape} we know there is exactly one \shape $\in \shapes^{(\alpha, \gamma, d)}(X)$ as promised in the assumptions.
     We need to prove \[\models \phi(\shape) \text{ if and only if } G \models \phi(X). \]
     

     Assume that $\models \phi(\shape)$. Let $G', X'$ be a graph and a set associated with the shape \shape. From the \cref{def:shapeEvaluation} we get that $G' \models \phi(X')$. Let $\tilde{G}, \tilde{X}$ be $\alpha$-trimmed $G,X$ and $\tilde{\mathcal{C}}$ be a collection of cliques in $\tilde{G}-D$ as in \cref{shape:compliant_set}.
     Observe that both $G', \tilde{G}$ have bounded size of cliques by $\alpha \cdot 2^d$ and that $G', X'$ and $\tilde{G}, \tilde{X}$ are isomorphic after removing all but $\gamma$ cliques of the same clique type from $\tilde{G}$. Because of that, we can iteratively apply \cref{cor:induction} for all solution patterns and obtain $G' \models \phi(X') \iff \tilde{G} \models \phi( \tilde{X} )$.
     Now, iteratively using \cref{equi:trimmed} we obtain $\tilde{G} \models \phi( \tilde{X} ) \iff G \models \phi(X)$.
\end{proof}
    






\section{\FPT Algorithm}\label{sec:FPT}
The main result of this section is an \FPT algorithm for some \FairVE problems parameterized by $\MSs$ and $|\phi|$ which proves \cref{thm:main-fpt}. 
Recall that we cannot give an \FPT algorithm for the most general version of the problem, as we show in \cref{sec:hardness} that the problem is \W{1}-hard. 
Hence, here, with the conditions we impose on the problem instance, we are close to a fine line where the \FairVE problem becomes hard. 

\fptThm*


Now we will provide some intuition on how to prove \cref{thm:main-fpt}.
Let us fix $G, \phi(\aleph)$ and observe that due to \cref{lem:compliant} we can restrict ourselves to solutions which are $\alpha$-compliant for some $\alpha < f(|D_G|, |\phi|)$. 
Let us fix \shape from $\shapes^{(\alpha, \gamma, |D_G|)} $ and let $X$ be any $\alpha$-compliant set agreeing with \shape. Then due to \cref{lem:shape_equivalence_one} the logical value of $G \models \phi(X)$ is known.
Recall that an $\alpha$-compliant set $X$ is an extension of $\shape\in\shapes^{(\alpha, \gamma, |D_G|)}$ whenever $\shape$ agrees with $X$ on $G$.
To conclude, observe that to prove \cref{thm:main-fpt}, it is enough to find a minimal, in terms of \fcnobrackets{}, extension for every coherent shape \shape from $\shapes^{(\alpha, \gamma, |\MSs|)}$.

\begin{definition}\label{def:cfc}
  For every graph $G$, clique $C \in \mathcal{C}_G$, any $\nT^* \subseteq \MSs$, and every solution pattern $\sP \in \spatterns^{(\alpha, |\MSs|)}$ we define the fair cost of a clique as follows: 
\begin{align*}
  \cliFC(C, \sP, \nT^*) &= \sum_{\nT \in \ntypes : \sP[\nT] < \alpha / 2 } \sP[\nT]  +\sum_{\nT \in \ntypes :\sP[\nT] > \alpha / 2} \left( C_\nT - \alpha + \sP[\nT]\right)  \\
&+\max_{N_D(v) : v \in C}\Delta(N_D(v)),
\end{align*}
where $$\Delta(\nT)= 
\begin{cases}
  |\nT \cap \nT^*|-1 \text{ if } \sP[\nT]=\alpha \text{ or } \sP[\nT]=\cT[\nT], \\
|\nT \cap \nT^*| \text{ otherwise.}
\end{cases}$$
\end{definition}

Notice, that the value of $\cliFC(C, \sP, \nT^*)$ is equal to the maximum \fc{v} over $v \in C$, assuming that solution $X$ is distributed on a clique $C$ and modulator $\MSs$ according to \sP and $\nT^*$, respectively.



\begin{lemma}\label{lem:coherent_shapeILP}
  Let $G$ be a graph with and $\phi(\aleph)$ be a formula with one free variable. 
  Let $f$ be a function given by \cref{lem:shape_equivalence_one} and $\alpha, \gamma>f(|\MSs|,|\phi|)$ be integers.
  Then there is an \FPT algorithm parameterized by $|\phi|, |\MSs|,\alpha,\gamma$ which for every coherent shape \shape = $(\nT^*, \mtx) \in \shapes^{(\alpha, \gamma, |\MSs|)}$ and any $k\in\mathbb{N}$, decides if there exist an $\alpha$-compliant set $X \subseteq V(G)$ such that $G \models \phi(X)$, $X$ agrees with \shape, and $\fc{X} \leq k$.
\end{lemma}

\begin{proof}
We start by a description of the algorithm and later we prove its correctness and time complexity.
Firstly, we need to check if $\shape$ satisfies a formula. If not we can already return that such a set $X$ does not exist, since $X$ that agrees with \shape does not satisfy $G \models \phi(X)$ due to \Cref{lem:shape_equivalence_one}.
Assume now that $\shape$ satisfies formula $\phi(\aleph)$.

Let $\cT \in\ctypes^{(\alpha+1,|\MSs|)}$.
Recall that for $C \in \Cc_\Graph$, $\alpha$-truncated signature  $\signat{\alpha}{C}$ is defined as a vector consisting of entries $\min(|C_\nT|, \alpha)$.
By $S_{\cT}$ we denote set $\{C \in \mathcal{C}_G : \signat{\alpha+1}{C} = \cT \}$. 
We have $\spatterns^{(\alpha, |\MSs|)}$ given by $M$.
For coinciseness, in this proof, we omit the superscript $(\alpha, |\MSs|)$ as it is clear form the context.
For each $\mathbf{S} \subseteq \spatterns$, let
\[ N_{\cT}^{\mathbf{S}} = \left\{C \in S_{\cT} : \{\sP :  \cliFC(C, \sP, \nT^*) \leq k \}  = \mathbf{S}  \right\}.\] 
Observe that definition $N_{\cT}^{\mathbf{S}}$ is a partition of $C\in S_\cT$ based on $\mathbf{S}$.
Introducing sets $\mathbf{S}$ allows us to stop worrying about the fair cost of vertices within the cliques.
From now on, for every clique, we know the set of possible solution patterns, which does not violate the \fcnobrackets{}.
Therefore, we are need to express that the fair cost of vertices in the modulator is at most $d$.


Let $X_{\cT}^{\mathbf{S}, \sP}$ be a variable representing the number of cliques from $N_{\cT}^{\mathbf{S}}$, which take $\sP$ as a solution pattern. We formluate \cref{il_faircost} for all subsets $\mathbf{S}$ of $\spatterns$.
We also need to ensure that variables $X_{\cT}^{\mathbf{S}, \sP}$ are compatible with $\shape$, which is ensured by \cref{ilp_compile1} and \cref{ilp_compile2}.

\noindent
\begin{align}
    \sum_{\sP \in \mathbf{S}}  X^{\mathbf{S}, \sP}_{\cT} = |N_{\cT}^{\mathbf{S}}| && \forall_{\cT \in \ctypes} \forall_{\mathbf{S} \subseteq \spatterns } \label{il_faircost} \\
    \sum\limits_{\mathbf{S}:\sP\in\mathbf{S} }  X^{\mathbf{S}, \sP}_{\cT} = \mtx[\cT, \sP] && \forall_{\cT \in \ctypes} \forall_{\sP \in \spatterns } : M[\cT, \sP] < \gamma \label{ilp_compile1} \\ 
    \sum\limits_{\mathbf{S}:\sP\in\mathbf{S} }  X^{\mathbf{S}, \sP}_{\cT} \geq \gamma  && \forall_{\cT \in \ctypes} \forall_{\sP \in \spatterns } : M[\cT, \sP] = \gamma \label{ilp_compile2}
\end{align}


We already ensured that the solution will comply with $\shape$ and the fair cost of any node inside any clique is at most $k$. 
It remains to calculate the fair cost for every $v \in \MSs$. To do so, we need to distinguish two cases as we only consider coherent shapes. 
For all cliques of a specific \cT, and for every \nT, we know whether we take almost all or almost none vertices of \nT as describe in matrix \mtx in \shape.  That allows us to count fair cost of the vertices in the modulator.

So let us define $thick\_nodes$ as a sum $ \sum_{\cT \in \ctypes} \sum_{C \in S_\cT } \sum_{\nT \in \ntypes} \sum_{\sP \in \spatterns: \sP[\nT] > \alpha / 2} |C_\nT| $. 
\[ thick(v) = thick\_nodes - \sum_{\cT \in \ctypes} \sum_{ \sP \in \spatterns } \sum_{\substack{\nT \in \ntypes \\ \sP[\nT] > \alpha / 2} }  \sum_{\mathbf{S} \subseteq \spatterns} X^{\mathbf{S}, \sP}_{\cT}\cdot(\alpha - \sP[\nT]).  \]
\[ thin(v) = \sum_{\cT \in \ctypes} \sum_{ \sP \in \spatterns } \sum_{\substack{\nT \in \ntypes ;;\\ \sP[\nT] < \alpha / 2} } \sum_{\mathbf{S} \subseteq \spatterns}  X^{\mathbf{S}, \sP}_{\cT}\cdot\sP[\nT].  \]

\noindent
From that, we can easily calculate \fc{v} of any $ v \in \MSs $. That is:
\[ \text{FC}(v) = thick(v)+thin(v) + |\nT^* \cap N(v)|. \]
Hence, we arrive into final set of constraints:
\begin{align}
  \text{FC}(v) \leq k && \forall_{v \in \MSs} \label{il_modulator}
\end{align}
To summarize, the whole ILP consists of Constraints 
(\ref{il_faircost}),
(\ref{ilp_compile1}),
(\ref{ilp_compile2}), 
and (\ref{il_modulator}).

Let us prove the time complexity. 
The only variables in the ILP are $X_{\cT}^{\mathbf{S}, \sP}$. 
Observe that values $|\mathbf{S}|, |\ctypes|, |\spatterns|$ are bounded by functions of $\alpha$, $\gamma$, $|D_G|$ and $|\phi|$.
Hence, we have bounded number of variables and we conclude by \cref{thm:ILPinBoundedDimension}.

Let us prove the correctness of the proposed algorithm. Let $I_{G, \phi}^\shape$ be the outcome of the ILP instance for a graph $G$, formula $\phi$ and shape $\shape$. We need to prove that $I_{G, \phi}^\shape$ is a YES-instance $\iff \big( \exists_{X \subseteq V(G)|} : \fc{X} \leq k \text{, } G \models \phi(X) \text{, } X \text{ is } \alpha$-compliant set and $X$ agrees with $\shape \big)$.

We start with the right-side implication. 
We construct set $X$ in a following way. That is for exactly $ X^{\mathbf{S}, \sP}_{\cT}$ cliques in $N_\cT^\mathbf{S}$ we chose solution pattern \sP, which gives us a solution set $X$. Now, $\fc{X} \leq k$ comes from the fact that $I_{G, \phi}^\shape$ is YES-instance and from the construction of set $\mathbf{S}$, which ensures us that both for vertices in $D_G$ and in $\Cc_G$ the fair cost is at most $k$. 
Observe that $X$ agrees with \shape is explicit ensured by \cref{il_faircost}, \cref{ilp_compile1} and \cref{ilp_compile2}.
We know that $G \models \phi(X)$ because if there is a solution to ILP instance it means that $\models \phi(\shape)$ and from \cref{lem:shape_equivalence_one} we deduce that $G \models \phi(X)$. The fact that $X$ is $\alpha$-compliant follows directly from the construction.

Let us prove the left-side implication. 
Let $X \subseteq V(G)$ be an $\alpha$-compliant set that satisfies all constraints from assumptions and let \shape be a shape agreeing with $X$. Because every $N_\cT^\mathbf{S}$ is a partition of cliques, we are able assign to variable  $X^{\mathbf{S}, \sP}_{\cT}$ as many cliques from $N_\cT^\mathbf{S}$, as many have solution pattern \sP.
Checking that $I_{G, \phi}^\shape$ is a YES-instance is analogous as in the previous case. %
\end{proof}

We prove the main theorem of this section (\cref{thm:main-fpt}) by an iterative applicatin of \cref{lem:coherent_shapeILP}.
We can compare the following approach to the proof of model-checking corollary (\cref{cor:mc}).


\begin{proof}[Proof of \cref{thm:main-fpt}]
    Let $f$ be a function from \cref{lem:shape_equivalence_one}.
    We iterate over each $\shape\in\shapes^{(\alpha, \gamma, |\MSs|)}$.
      We model-check the formula on $\shape$ which leads to model-checking of the associated graph and the set (consult \cref{def:associatedGraph}) whose size are bounded by parameters.
    If $\models\shape$ then we use \cref{lem:coherent_shapeILP} to provide us with $X$ of the fair cost at most $k$ if it exists in \FPT time.
    That proves we are able to solve \textsc{\MSOo-FairVE} problem in \FPT time.
\end{proof}

\section{Problems Covered by {\Cref{thm:main-fpt}}}\label{sec:problems}


In this short section, we provide a list of particular problems that are covered by a rather technical statement of \Cref{thm:main-fpt}.
Alongside definitions we also give justifications of why their shape is coherent.
Therefore, we prove \cref{cor:problmesFPT}.

\prob{\sc Fair Vertex Cover}
{An undirected graph $G$ and an integer $k$.}
{Is there a set $X \subseteq V(G)$ of fair cost at most $k$ such that every edge has at least one endpoint in $X$?}

\prob{\sc Fair Feedback Vertex Set}
{An undirected graph $G$ and an integer $k$.}
{Is there a set $X \subseteq V(G)$ of fair cost at most $k$ such that $G-X$ is a forest?}

\prob{\sc Fair Odd Cycle Transversal}
{An undirected graph $G$ and integer $k$.}
{Is there a set $X \subseteq V(G)$ of fair cost at most $k$ such that $G - X$ is a bipartite graph?}



The crucial observation is that solving all the aforementioned problems on cliques is relatively straightforward.
Any valid solution force set $X$ to contain all but at most a constant number of vertices in each clique (or in each $C_\nT$).
We formulate this idea as the following observation.
\begin{observation}[Solution structure on a clique]\label{obs:solutionStructure}
    Let $G$ be any graph. For any problem $\pi$ defined above, there is a constant $c_\pi$ such that following hold.
    Whenever we have $X \subseteq V(G)$ that satisfies $\pi$ (except for the fair cost condition) and for any $C \in \Cc$, it holds that $|X \cap C| \geq |C|-c_\pi$. In particular, for every $\nT$, it holds that $|X \cap C_\nT| \geq |C_\nT|-c_\pi$.
\end{observation}
\Cref{obs:solutionStructure} immediately leads to coherent shapes as all non-zero entries of the shape matrix are fat or bounded.
It is a rutine and standard check that the above problems can be expressed in \MSOo formula of constant size.
Therefore, we conclude by \Cref{thm:main-fpt}.
Observe that $c_\pi\le2$ for all the problems mentioned above.
Hence, we prove \cref{cor:problmesFPT} for them.


We now move to problems where the coherence originates in the matrix entries being thin.
We can formulate an analogous observation where we replace the last condition with $|X \cap C_\nT| \leq c_\pi$.

\prob{\sc Fair [$\sigma,\rho$]-Domination}
{An undirected graph $G=(V,E)$, finite or cofinite $\rho\subseteq \mathbb{N}$ and finite $\sigma$, or cofinite $\rho\subseteq \mathbb{N}$ and $\sigma=\mathbb{N}$, and an integer $k$.}
{Is there a set of vertices $X\subseteq V(G)$ of fair cost at most $k$ such that for all $v\in X$, $|N(v)\cap X|\in\sigma$ and for all $v\in V(G)\setminus X$, $|N(v)\cap X|\in\rho$.}
Observe that the \textsc{Fair Dominating Set} is a special case of [$\sigma,\rho$]-Domination where $\sigma=\mathbb{N}$ and $\rho=\mathbb{N}\setminus\{0\}$.
Again, it is a routine check to describe [$\sigma,\rho$]-Domination using an \MSOo formula, now its size depend on $\sigma,\rho$.

We assume that $\sigma$ is finite. 
We define $\max_\sigma\df \max_{x\in \sigma} (x+1)$.
Observe that each clique contain at most $\max_\sigma$ vertices of the solution.
Therefore, we conclude that any such shape is coherent with all non-zero entries of the associated matrix thin or bounded.

We assume that $\sigma=\mathbb{N}$ and $\rho$ is cofinite. 
We define $\max_\rho\df \max_{x\in\mathbb{N} \wedge x\not\in \rho} (x+1)$.
Observe that it is never profitable to put to $X$ more than $\max_\rho$ vertices of any $C_\nT$.
To satisfy $\rho$, if there is more than $\max_\rho$ vertices of certain $|C_\nT\cap X|$, %
we make $|C_\nT\cap X|=\max_\rho$.
Indeed, this operation does not violate $\rho$ condition (and there is no condition on $\sigma$) and does not increase the fair cost.
Hence, we conclude that such shapes are coherent with all non-zero entries of the associated matrix thin or bounded.



By this analisis we conclude the proof of \cref{cor:problmesFPT}.








\section{Hardness}\label{sec:hardness}


In this section, we present the reduction proving \W{1}-hardness of \FairVD stated as the following theorem.
\WhThm*



We use the \textsc{Unary $\ell$-Bin Packing} problem as the starting point of our hardness reduction.
The \textsc{Unary $\ell$-Bin Packing} is \W{1}-hard for parameter $\ell$, the number of bins~\cite{JansenKMS13}.
There, the item sizes are encoded in unary and the task is to assign $n$ items to $\ell$ bins such that the sum of sizes of items assigned to any bin does not exceed its capacity $B$.
Formally, \textsc{Unary $\ell$-Bin Packing} is defined as follows.

\prob{\textsc{Unary $\ell$-Bin Packing}\hspace{20em} {\em Parameter:} $\ell$}
{Positive integers $\ell, B$ and multiset $\mathcal{S}$ of item of non-zero sizes 

$s_1, \ldots, s_n$ encoded in unary.}
{Is there a packing of all items into at most $\ell$ bins of size $B$? 

More formally is there a function $f: [n] \rightarrow [\ell]$, such that \[\underset{k \in [\ell]}{\forall} \underset{i \in f^{-1}(k)}{\sum} s_i \leq B\]}

Now we introduce the first problem, which we reduce from \dbinpacking.

\prob{\textsc{Unary $d$-Tuple Problem}\hspace{18em} {\em Parameter:} $d$}
{Positive integers $b, d$ and multiset $\mathcal{A}$ of $n$ non-zero integer tuples $(a^{(i)}_1, \ldots, a^{(i)}_d)$, $i \in \{ 1, \ldots ,n \}$, where entries of every tuple are encoded unary.}
{Is there a function $f : [n] \rightarrow [d]$, such that \[\underset{k \in [d]}{\forall} \sum_{i \in f^{-1}(k)} a^{(i)}_k \leq b\]}

\noindent
The main result of this section is based on the two lemmas that follow next. In the first lemma (\cref{lem:tuple-W1}) we show a reduction from \dbinpacking problem to \dtuple problem, which implies  W[1]-hardness of the latter.

\begin{lemma}\label{lem:tuple-W1}
  \dtuple problem is \W{1}-hard parameterized by $d$.
\end{lemma}


\begin{proof}
  To show \W{1}-hardness of \dtuple we reduce from \dbinpacking. Let us take any instance ($\mathcal{S}, \ell, B$) of a \dbinpacking. Let $(\mathcal{A}, d, b)$ be an instance of \dtuple, such that $b = B$, $d = \ell$ and 
    $\forall_{i \in [n]} \forall_{k \in [d]} a^{(i)}_k = s_i$.
    
    Assume that $(\mathcal{A}, d, b)$ is a YES-instance. Then there is a function $f$, a witness of YES-instance. Since $d = \ell$, $b=B$ and $\forall_{k \in [d]} a^{(i)}_k = s_i$, we can rewrite property $\forall_{k \in [d]} \sum_{i \in f^{-1}(k)} a^{(i)}_k \leq b$ of function $f$ as $\forall_{k \in [\ell]} \sum_{i \in f^{-1}(k)} s_i \leq B$. From that, it is easy to observe that every witness of YES-instance of the \dtuple problem is also a witness of YES-instance of \dbinpacking and vice versa.    
\end{proof}

Now, we show the main reduction, reducing from \dtuple and proving \cref{thm:hardness}.


\begin{proof}[Proof of \cref{thm:hardness}]
  We reduce from \dtuple which was shown \W{1}-hard in \cref{lem:tuple-W1}.


  %
We describe the construction from \dtuple problem to \FairVD. Let us take any instance ($\mathcal{A}, d, b)$ of a \dtuple. Firstly we remove all tuples with at least one zero entry since we pick that position in the final assignment. 
We construct graph $G$ in the following way. At the beginning, we construct nodes $v_1, v_2, \dots, v_d$. For the $i$-th tuple $(a^{(i)}_1, \ldots, a^{(i)}_d) \in \mathcal{A}$, we construct clique $C^i$ of size $\sum_{k=1}^d a_k^{(i)}$ and we connect $a_k^{(i)}$ nodes from this clique with node $v_k$ for every $k \in [d]$. Such set of $a_k^{(i)}$ nodes from clique $C^i$ we denote $C^i_{k}$.

Observe that $\cvd(G) = \{v_1, v_2, \dots, v_d \}$, since removing it leave us with a set of disjoint cliques.
There are exactly $d$ different neighborhood types. 
Now we propose the formula for instance of \FairVD problem. Firstly we  define 
$\text{modul}(v)$, which checks if the vertex $v$ belongs to $\cvd(G)$.
Observe that due to our reduction each vertex outside the modulator has only at most two non-adjacent neighbors while all vertices in the modulator have as many non-adjacent neighbors as is the number of tuples in \dtuple.
We can easily encode the above property in \FO formula describing whether a given vertex is in the modulator.
\[ \text{modul}(v)\models \exists_{a, b, c \in N(v)} a \neq b \wedge a \neq c \wedge b \neq c \wedge \neg e(a, b) \wedge \neg e(b, c) \wedge \neg e(c, a).\]

Then we show the final formula which is satisfied if and only if in every clique $C^i$ we removed at least one set $C^i_k$ for $k \in [d]$.
Observe that the above is true if and only if there are \textbf{no} $d$ vertices outside the modulator that are in one clique and each of them is a neighbor od a different vertex in the modulator.
We encode it in the following \FO formula.

\[\phi \models \neg \left( \exists_{v_1, \dots v_d}
    \bigwedge_{ \substack{ i,j \in[d] \\ i \neq j}} v_i \neq v_j  
    \bigwedge_{i \in [d]} \neg\text{modul}(v_i) 
    \bigwedge_{\substack{ i,j \in[d] \\ i \neq j}} e(v_i, v_j) 
    \bigwedge_{\substack{ i,j \in[d] \\ i \neq j}} \left(\exists_u \, e(u, v_i) \wedge \neg e(u, v_j)\right) \right).\]

Finally, we set value $k$ in \FairVD to be equal to value $b$ in \dtuple. 
   We need to analyze the correctness of the reduction. 
    First, we observe that since entries of \dtuple are encoded unary, $|G|$ is linear in terms of the sum of all values in tuples, therefore linear in the size of \dtuple input size. 
    Size of $\phi$ is a function of $|\MSs|$.   
    
    Now we show the soundness of the reduction rule.
    Assume that \dtuple is a YES-instance, and let function $f$ be a witness of that. Then set $X$, such that $\forall_{i \in [n]} X \cap C^i = C^i_{f(i)}$ is a witness of YES-instance of \FairVD. Now let us assume that \FairVD is a YES-instance and let $X \subseteq V(G)$ be a witness of that. 
    Let $X'$ be a subset of $X$ such that $ X' \cap \cvd(G) = \emptyset$ and for any $i \in [n], X' \cap C^i = C^i_k$ for some $k \in [d]$. 
    At least one such $k$ must exist since $X$ satisfies $\phi$. Observe that $X'$ still satisfies $\phi$ and $\fc{X'} \leq \fc{X} \leq k$. Let $f$ be such that for every $i \in [n], f(i)$ is equal to $k \in [d]$ if $X' \cap C_i = C^i_k$. Then $f$ is a witness of being YES-instance of \dtuple.
\end{proof}




\section{Conclusions}\label{sec:conc}
In this paper we resolved a question in \cite{KMT19}.
we showed that despite the general problem is \W{1}-hard we are able to solve many graph vertex problems in \FPT time.
It would be interesting to see if we can extend (some of) the \FPT results for more dense graph parameters.
In particular, \cite{KMT19} shows that the Fair Vertex Cover problem is solvable in \FPT time parameterized by the modular-width.
We would like to reiterate a question whether $\MSOo$-FairVE is \FPT parameterized by the modular-width and the size of the formula.

While \cref{thm:main-fpt} cover quite a lot of natural graph vertex problems it would be interesting to know whether all cases of Fair $[\sigma,\rho]$-Domination problems are \FPT parameterized by the cluster vertex deletion.

We propose one a bit overlooked question of whether \MSOo-FairVE problems are in \XP parameterized by the clique-width and the size of the formula.
For \MSOt-FairVE problem, \cite{Kolman09onfair} showed an \XP algorithm parameterized by the treewidth and the size of the formula as observed by \cite{MT20}. 
This result was later implied by a more general result of \cite{KKMT}.
However, to our best knowledge, an \XP algorithm on clique-width is missing.


\bibliography{main}

  %

\end{document}

