\section{Introduction}

Modern processors achieve enhanced performance through complex microarchitectures, incorporating features like sophisticated optimizations, more comprehensive pipelines, and advanced cache mechanisms. While these innovations boost efficiency, they also expose new vulnerabilities, evidenced by numerous attacks on shared microarchitectural components: cache~\cite{irazoqui2014wait,gruss2016flush+,zhang2012cross}, branch prediction unit~\cite{evtyushkin2018branchscope}, and translation look-aside buffer~\cite{gras2018translation}. These vulnerabilities have been exploited to bypass security measures and siphon sensitive data. Moreover, transient execution attacks leverage speculative and out-of-order execution to access transiently available data, exacerbating security risks~\cite{kocher2020spectre,lipp2020meltdown}. 

Several optimizations are present in the front-end of x86 processors, in which instructions are fetched and decoded into micro-operations ($\mu$ops) and transferred to the execution ports. Notably, the prefetching mechanism in the front-end unit fetches instructions even further in the pipeline speculatively to keep up with the speed of execution ports, assuming these instructions remain unaltered. However, if an application has write access to its instruction memory, any instruction can be overwritten dynamically during the code execution~\cite{ansel2011language}. This modification is detected by processors to maintain the correct flow of the instruction stream. x86 systems detect these changes through special hardware units and check mechanisms in the front-end, and all instructions after the modifying instructions are invalidated, causing a pipeline flush~\cite{kyker2003method,self_amd}, which is frequently referred to as self-modifying code (SMC) detection mechanism.

Resource sharing has been promoted on modern CPUs via optimizations such as Simultaneous Multithreading (SMT)~\cite{tullsen1995simultaneous}.
SMT technologies, i.e., Intel hyper-threading, enable multiple virtual processors that run disjoint tasks to share resources on the same core with up to 30\% performance gain with the same CPU die size~\cite{intelHTPerf}.
On the other hand, SMT introduces new attack vectors and security challenges.
Attacks such as PortSmash~\cite{aldaya2019port} are only feasible due to the real-time sharing of core-private resources, which otherwise were impractical. 
In May 2019, a class of Meltdown-style attacks collectively referred to as microarchitectural data sampling (MDS)~\cite{schwarz2019zombieload,van2019ridl}, 
also highlighted the negative impact of Intel hyperthreading on the security of modern CPUs.
However, the performance gained by SMT proved indispensable, outweighing any data leakage across logical processors.
%While hardware patches have been deployed for data-spilling attacks like MDS, side channels across logical processors remain a valid concern without foreseeable hardware mitigation. 
These attacks can be even more applicable in Function-as-a-service (FaaS) cloud platforms with core multi-tenancy, such as Cloudflare Workers and Amazon Lambda instances.

When the processor encounters a self-modifying code snippet, the detection and correction mechanism slows down all threads running on the same physical core. Even though self-modifying code mechanism has been exploited to either degrade the performance of a processor through frequent pipeline 
flushes~\cite{aldaya2022hyperdegrade} or increase the speculative window size~\cite{ragab2021rage}, there is no extensive investigation on how self-modifying code as a standalone attack vector can directly leak private information such as cryptographic keys, unauthorized secrets in memory, and keystrokes while creating a high bandwidth covert communication. 
This paper delves into how attackers can exploit the SMC mechanism on x86 systems and leverage it to create high-resolution, less noisy microarchitecture side-channel attacks. 
Our study identifies a diverse set of x86 instructions, triggering the SMC-detection mechanism and extending the well-known Prime+Probe and Flush+Reload attacks to create covert channels on the L1 instruction (L1i) cache across SMT threads in the same physical core. SMaCk offers a more efficient cache attack tool for adversaries as cache hits and misses can be distinguished more robustly compared to traditional Prime+Probe attacks on the L1i cache~\cite{aciiccmez2007yet,aciiccmez2010new}. 

In summary, this paper:

\begin{itemize}
    \item explores which x86 instructions trigger the SMC detection mechanism on Intel and AMD processors. 
    \item systematically analyzes how the SMC detection mechanism affects front-end and back-end units in x86 processors by utilizing performance counters.    
    \item crafts new Prime+iProbe and Flush+iReload attacks on the L1 instruction cache to create covert channels between two SMT threads with a low error rate.
    \item shows that attackers can identify vulnerable cryptographic libraries by monitoring L1 instruction cache sets and leak a 2048-bit RSA key from a vulnerable cryptographic implementation.
    \item demonstrates an SMC-based single-trace side-channel attack on the Secure Remote Password (SRP) protocol in the most recent OpenSSL implementation by leveraging the L1 instruction cache, successfully extracting the server's private key exponent bits. 
    \item leverages the L1 instruction cache side-channel to demonstrate Spectre-type attacks, showing the inefficiency of shared data cache-based Spectre detection mechanisms.
    \item designs a performance counter-based defense technique to detect newly introduced SMC-based attacks on modern processors.
\end{itemize}
