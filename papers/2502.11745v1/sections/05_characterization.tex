% \section{RowHammer and Data Retention Time}
% \label{sec:rh_ret}
% \yctcomment{1}{chop chop chop}
% \agycomment{1}{I agree. This section does not help to the story of this paper. It can make a good appendix.}
% As the first step of our characterization study, we investigate the effect of data retention time on RowHammer characterization results, following the algorithm in \algref{alg:test_alg}. Our hypothesis is that exacerbated charge leakage (as an artifact of RowHammer) can lead a DRAM cell to experience a bitflip \emph{not} only because it is hammered but as a cumulative impact of the cell's inherent leakage characteristics and RowHammer's impact. Although this relation between data retention and RowHammer seems natural, \emph{no} prior work investigates this aspect. {We first measure baseline \gls{nrh} using \emph{naïve} \iql{IQB2}method where the aggressor rows are hammered immediately after the victim rows are initialized and the victim rows are read immediately after the aggressor rows are hammered (i.e., the victim rows remain unaccessed only during the RowHammer attack.).}
% Then, we conduct two types of experiments and compare them to the baseline, where the row is hammered immediately after it is refreshed and \yct{0}{checked for bitflips} immediately after hammering. 
% \agy{1}{Our tests} keep the victim row unaccessed for \agy{1}{exactly} a \gls{trefw} \agy{1}{}{\milli\second}) and performs hammering either in the beginning (i.e., Hammer-First) or at the end (i.e., Sleep-First)}. We calculate \gls{thammer} and \gls{tsleep} \agy{1}{based on the desired hammer count}.
% % The first set of experiments hammer the aggressor rows and wait for \gls{tsleep} until the end of \gls{trefw} while the second set of experiments wait for \gls{tsleep} and hammer the aggressor rows.

% % We analyze a row's RowHammer vulnerability by measuring \gls{nrh} using these two experiments and compare these \gls{nrh} to the baseline \gls{nrh} where \gls{nrh} is measured without the effect of data retention time. 
% \figref{fig:nrh_reduction} demonstrates the \agy{1}{variation in} \gls{nrh} values of the tested rows \agy{1}{from {three representative modules from each manufacturer} (columns of subplots) for two different methods of conducting RowHammer tests (rows of subplots).}
% \agy{1}{The x-axis shows the \gls{nrh} value found by using the \emph{naïve} method and the y-axis shows the \gls{nrh} values found by taking either Hammer-First or Sleep-First approaches.} The dashed line shows the $x=y$ line, \agy{1}{where both methods suggest the same \gls{nrh} value.} 
% % for \gls{nrh} $=$ baseline \gls{nrh}. 
% % The rows on the red line show the rows that have the same \gls{nrh} and baseline \gls{nrh} 
% \agy{1}{A marker below the dashed line shows a row where the naïve method causes bitflips at higher hammer counts than the other method specified on the y-axis, which can be misleading for RowHammer mitigations.}
% % have lower \gls{nrh} than baseline \gls{nrh}. We make \param{N} observations from \figref{fig:nrh_reduction_h1}.
% % \yctcomment{0}{The observations from fig 6 and fig 7 will be the same, should we get rid of fig 6?}
% \agy{1}{For each subplot, we fit the data to a linear regression model that is specified on the top-left corner of each subplot along with the model's $R^2$ score.}

% \begin{figure}[ht]
% \centering
% \includegraphics[width=1\linewidth]{figures/RH_RET.pdf}
% \caption{{Variation in \gls{nrh} across different testing methods}}
% \label{fig:nrh_reduction}
% \end{figure}

% We make \param{three} observations from \figref{fig:nrh_reduction}. First, 
% {the \gls{nrh} values found by using Hammer First and Sleep First \iql{IQB5}methods are never higher than the \gls{nrh} values found by using the naïve method. \param{57.93\%} and \param{44.05\%} of the tested rows exhibit lower \gls{nrh} values when tested by using Hammer First and Sleep First methods compared to the naïve method. Therefore, both Hammer First and Sleep First methods are more accurate than the naïve method in finding the worst-case \gls{nrh}.}
% Second, the \gls{nrh} values found using different methods are similar to each other as most of the data points are accumulated around $y=x$ line and the linear regression models approximate to $y=x$ ($0.96 \leq m \leq 1.00, where\ y=mx+b$) with high confidence ($R^2 \geq 0.98$).
% Third, while Hammer First and Sleep First methods result in the same \gls{nrh} value for most of the rows, Hammer First's \gls{nrh} is smaller (worse) than Sleep First's for \param{45.74\%} rows. Based on these observations, we derive \takeref{take:rh_ret}.
% \agycomment{0}{Fix the Takeaway cross references}\yctcomment{0}{fixed it.}

% \takeaway{Hammer First is a more accurate method to find the worst-case \gls{nrh} among the tested methods.\label{take:rh_ret}}

% \begin{figure}[ht]
% \centering
% \includegraphics[width=1\linewidth]{figures/nRH_reduction_all.pdf}
% \caption{nRH reduction}
% \label{fig:nrh_reduction_all}
% \end{figure}
% \yctcomment{0}{Fix the x label. add hue}

% \begin{itemize}
%     \item All 
% \end{itemize}


\section{\om{3}{Effect of Charge Restoration Latency\\on RowHammer}}
\label{sec:rh_cr}
% This section presents
\agy{3}{We present} the first rigorous characterization of the effect of charge restoration latency on RowHammer vulnerability in real DDR4 DRAM chips.
% Although many characterization studies~\understandingRowHammerAllCitations{} analyze RowHammer under various conditions, \emph{no} prior work studies the effect of charge restoration latency and the potential benefits of reducing charge restoration latency on real DDR4 DRAM chips.
% To design efficient and low-cost RowHammer mitigation mechanisms, it is crucial to understand the relation between charge restoration latency and the RowHammer vulnerability, as many RowHammer mitigation mechanisms suffer from high performance overheads due to charge restoration latency. 
%\agycomment{1}{Removed a redundant part of the motivation}
% This section \agy{1}{studies} the relation between charge restoration latency and RowHammer vulnerability of real DRR4 DRAM chips, 
% following the methodology described in \secref{sec:methodology}.\agycomment{3}{This ``following the methodology described in \secref{sec:methodology}'' part is not necessary. Remove or convince me that it is necessary.} 
% \subsection{Relation Between Charge Restoration Latency and RowHammer}
% To understand the relation between charge restoration latency and RowHammer vulnerability, 
\subsection{Effect on RowHammer Threshold}
\label{sec:effect_nrh}

We 
% \agycomment{3}{Is this really Onur's addition or yours? I think it is unnecessary and a bit odd.}
measure \gls{nrh} of a DRAM row \agy{1}{while sweeping the charge restoration latency used for restoring the charge of \om{6}{each} victim row.}
\figref{fig:nRH_single_pcr} demonstrates \gls{nrh} \om{3}{as} charge restoration \agy{1}{latency \om{3}{reduces} in a box-and-whiskers plot.}\footnote{\label{fn:boxplot}{\agy{1}{The box is lower-bounded by the first quartile (i.e., the median of the first half of the ordered set of data points) and upper-bounded by the third quartile (i.e., the median of the second half of the ordered set of data points).
The \gls{iqr} is the distance between the first and third quartiles (i.e., box size).
Whiskers show the minimum and maximum values.}}}
% are used to refresh victim rows for one time. 
The x-axis shows the normalized charge restoration latency used \agy{1}{for restoring} victim rows \agy{1}{before hammering} and the y-axis shows the \gls{nrh} value \yct{3}{for each tested victim row, normalized to \agy{1}{the} \gls{nrh}} \agy{1}{value when the victim row is refreshed before hammering using the nominal charge restoration latency \om{3}{(i.e., $t_{RAS}=33ns$}). \agy{3}{Each subplot shows data from a different manufacturer, \om{6}{depicting \gls{nrh} values of all tested rows} across all tested chips from that manufacturer.}}
\yct{7}{Dashed red lines represent the lowest charge restoration latency that does \emph{not} significantly \yct{9}{($<3\%$)} decrease \gls{nrh} for each manufacturer.}

\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{figures/fig6_NRH_vs_PCR.pdf}
\caption{\yct{3}{$\bm{N}_{\bm{RH}}$ versus charge restoration latency in all tested DRAM rows}}
\label{fig:nRH_single_pcr}
\end{figure}
% \yctcomment{3}{I can change the xlabel to "normalized" for this figure but not for others, so I keep it consistent.}\agycomment{3}{why not for others? You should explain it in your discussion with Onur.}
% \agycomment{3}{Did you discuss this ``normalized'' comment with Onur?}\yctcomment{3}{no, I slightly increased the fig sizes and fixed all figures.}

We make \param{three} observations from \figref{fig:nRH_single_pcr}. First, \gls{nrh} of the tested rows \agy{1}{significantly} decreases \agy{1}{as} charge restoration latency \agy{1}{reduces for Mfrs.~H and~S.} 
\agy{1}{Second, at very low \gls{tras} values (e.g., $x=0.18t_{RAS}$), charge restoration is \emph{not} strong enough for a subset of DRAM cells to retain data for $64ms$, and thus they exhibit an \gls{nrh} value of 0, meaning that they experience \om{3}{data retention} bitflips \om{3}{(without being hammered)}.} 
% When \param{0.18} latency is used to refresh the victim rows, some of the victim rows have 0 \gls{nrh} meaning that they cannot retain their data for \gls{trefw} even if no hammering is performed. 
\agy{1}{Third}, reducing charge restoration latency \agy{1}{by \param{64\%}, \param{82\%}}\om{6}{, and 36\%} \yct{6}{(shown with dashed red lines)} \om{3}{negligibly affects} \yct{7}{($<3\%$)} the \gls{nrh} of the \agy{1}{tested} rows \agy{1}{from} Mfrs.~H, M\om{6}{, and~S}, respectively. 
\agy{1}{We hypothesize that Mfrs.~H and~M implement} large \om{7}{safety margins (i.e., guardbands)} \agy{1}{in their respective nominal} charge restoration latencies\agy{1}{, such that \om{6}{these latencies}} can be \agy{1}{significantly} reduced without \agy{1}{exacerbating} \om{3}{the RowHammer vulnerability}. 
\om{3}{Based on these observations, we derive:}


% \takeaway{Charge restoration latency (\gls{tras}) can be reduced i)~with no effect on \om{3}{RowHammer threshold} or ii)~at the cost of reducing the RowHammer threshold of real DRAM chips, while reducing charge restoration latency beyond a safe minimum value can cause data retention bitflips and compromise reliability.\label{take:nrh_cr}}
\takeaway{Charge restoration latency can be reduced \agy{3}{down to a safe minimum value without affecting} the \om{3}{RowHammer threshold} of real DRAM chips.\label{take:nrh_cr}}
% \agycomment{3}{Let's discuss this simplification.}\yctcomment{3}{makes sense, we already explain it in the text.}

\noindent
\iqrev{\textbf{\om{3}{Lowest} $\bm{N}_{\bm{RH}}$ across rows \yct{6}{with} reduced $\bm{t}_{\bm{RAS}}$.} \figref{fig:nrh_changemodule} demonstrates how the \om{3}{\om{6}{lowest} observed} \gls{nrh} across tested DRAM rows \om{6}{changes with} reduced \gls{tras} in a line plot, where the DRAM row that exhibits the \om{3}{lowest} \gls{nrh} may or may \emph{not} be the same row \om{7}{across different} \gls{tras} values. The x-axis shows \om{3}{normalized} charge restoration \om{6}{latency} and the y-axis shows the \om{3}{lowest} \gls{nrh} value in a DRAM module under reduced \gls{tras}, normalized to the \om{3}{lowest} \gls{nrh} under nominal \gls{tras}.
% Each curve represents a different manufacturer and the shade around the curve shows the minimum and maximum values across all tested modules from a manufacturer.
\yct{10}{Each subplot represents modules from a different manufacturer and each curve represents a different module.}
% of tested DRAM modules to understand the impact of reduced restoration latency on the worst-case \gls{nrh} of the DRAM modules. \figref{fig:nrh_changemodule} demonstrates the lowest \gls{nrh} values of each DRAM module normalized to the lowest \gls{nrh} when nominal latency is used on the y-axis, for different restoration latencies (x-axis). Each curve represents a different manufacturer.
}

\yctcomment{6}{absolute nrh values changes significantly between modules, but we can figure out something for the extended version}
\yctcomment{7}{fixed colors}
\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{figures/figae_NRH_change_per_module.pdf}
\caption{\om{3}{Lowest observed $\bm{N}_{\bm{RH}}$ versus charge restoration latency in all tested DRAM modules}}
\label{fig:nrh_changemodule}
\end{figure}

\yctcomment{10}{updated the figure}
\iqrev{From \figref{fig:nrh_changemodule}, we make two observations. 
\om{3}{First, for all tested modules from Mfr.~M, the lowest \gls{nrh} value does \emph{not} \yct{3}{significantly} change
% \agycomment{3}{This is incorrect. I see some variation and values below 1.0. You can say that the variation is below some number or does not reduce more than X\%}\yctcomment{3}{added a "significantly"} 
even at $x=0.27t_{RAS}$ \om{7}{(73\% reduction in \gls{tras})}.}
\om{3}{Second, the modules from Mfrs.~H and~S are resilient to reduced charge restoration latency. Their lowest \gls{nrh} values decrease by less than 3\%, on average across tested modules, even when the charge restoration latency is reduced by 36\% and 19\% for Mfrs.~H and~S, respectively.}\yctcomment{6}{We used the average nRH of the modules.}
% \agycomment{3}{can we not be more specific? 90\% is also more than 36\%}
\om{3}{Based on these observations, we conclude that reducing \om{6}{the} charge restoration latency \om{6}{can have} a \om{6}{small ($<3\%$) impact on the} lowest observed \gls{nrh} values in the tested DRAM modules.}}
\omcomment{7}{36 and 19 are small reductions 3 percent seems high? Is the data in This figure consistent with the data in figure 6?}
\yctcomment{7}{I checked the numbers and they are correct, we use 5 iterations for each test. Therefore, I think 3\% is logical due to VRD. Regarding figure 6, they represent each row's nrh change while this plot represents the nrh of the module.}
% This indicates that lower charge restoration latencies can be explored without compromising module-level reliability in many cases.

To analyze \yct{3}{how \gls{nrh} values of individual rows change, we compare the normalized \gls{nrh} values to their \gls{nrh} values under nominal \gls{tras}}.
% \footnote{We analyze DRAM chips from Mfrs.~H and~S because only those chips experience an exacerbated RowHammer vulnerability with reduced \gls{tras}.\label{fn:onlyHS}} 
\agy{3}{\yct{3}{\figref{fig:nrh_single_pcr_per} shows} a scatter plot where each data point represents a DRAM row from \yct{10}{three} representative modules: \yct{10}{H8, M5, and S1}. The x-\yct{3}{axis shows} the row's \yct{3}{\gls{nrh}} under nominal charge restoration latency, \yct{3}{and the y-axis shows the row's \gls{nrh} under reduced charge restoration latency (\om{6}{to} $0.45t_{RAS}$) normalized to the \gls{nrh} under nominal charge restoration latency}.
% \agycomment{3}{Is this correct?}\yctcomment{3}{not exactly, y axis is normalized to default nrh}\agycomment{3}{So did you correct it?yesgut} 
\yct{10}{Each subplot indicates \om{11}{DRAM} rows from different manufacturers.}}
\yct{6}{The dashed red line represents $y=0.75$ where the \gls{nrh} value decreases by 25\% with $0.45t_{RAS}$.}
% \yct{3}{\figref{fig:nrh_single_pcr_per} shows how normalized \gls{nrh} values change for two representative modules from Mfrs.~H and~S. The x-axis represents the \gls{nrh} values under nominal charge restoration latency. The y-axis shows the normalized \gls{nrh} values when the victim row is refreshed using $0.45t_{RAS}$ for each tested row, normalized to their \gls{nrh} values under nominal \gls{tras}. Different markers indicate the rows from different modules.}}
\yctcomment{10}{Added Micron}
\begin{figure}[ht]
\centering
\includegraphics[width=0.9\linewidth]{figures/fig8_NRH_dist.pdf}
\caption{\yct{3}{$\bm{N}_{\bm{RH}}$ at $\bm{0.45t}_{\bm{RAS}}$ versus $\bm{N}_{\bm{RH}}$ at nominal $\bm{t}_{\bm{RAS}}$ for \agy{3}{tested rows from \yct{10}{three} representative modules \yct{10}{H8, M5, and S1}}}}
\label{fig:nrh_single_pcr_per}
\end{figure}

{We make two observations from~\figref{fig:nrh_single_pcr_per}.
First, a small fraction of rows are significantly more sensitive to partial charge restoration than the vast majority of the rows. 
\yct{3}{For example, fewer than 0.45\%\yct{10}{, 0.66\%,} and 10.34\% of the rows from Mfrs.~H\yct{10}{, M,} and~S experience an \gls{nrh} reduction of more than 25\% \yct{3}{(i.e., below the red dashed line)} when they are refreshed using $0.45t_{RAS}$.}
\yct{3}{Second, rows with the lowest \gls{nrh} values under nominal charge restoration latency do \emph{not} exhibit the largest reductions in \gls{nrh} under reduced \gls{tras}. To illustrate, the rows with low \gls{nrh} values under nominal \gls{tras} (e.g., $x=10K$ at the left subplot) \agy{3}{exhibit values close to $1.0$ on the y-axis,}
% do \emph{not} experience a high \gls{nrh} reduction (i.e., their normalized \gls{nrh} values are close to $y=1.0$), 
while the rows with high \gls{nrh} values (e.g., $x=20K$ at the left subplot) can experience \om{6}{larger} \gls{nrh} reductions.}
\yct{3}{Based on these observations, we derive:}
% \om{3}{Based on these observations, we conclude that rows that are already vulnerable to Rowhammer under nominal \gls{tras} are relatively less affected by reduced charge restoration latency.}

\takeaway{\yct{7}{Charge restoration latency can be reduced down to a safe minimum value without significantly affecting the lowest observed \gls{nrh} of the tested DRAM modules.\label{take:nrh_dist}}}



\subsection{Effect on RowHammer Bit-Error-Rate}
\label{sec:effect_ber}

{\om{3}{We next} study the impact \om{3}{of} reduced charge restoration latency on the RowHammer \gls{ber}\yctcomment{6}{defined in sec 4.3}.} \figref{fig:ber_single_pcr} demonstrates \om{3}{how} RowHammer \gls{ber} \om{3}{changes as} charge restoration \agy{1}{latency \om{3}{reduces}} \yct{9}{(using a similar style as \figref{fig:nRH_single_pcr}).}
% a box-and-whiskers plot.\fnref{fn:boxplot}
% are used to refresh victim rows for one time. 
% The x-axis shows the normalized charge restoration latency used \agy{1}{for refreshing} victim rows \agy{1}{before hammering} and the y-axis shows the \gls{ber} \agy{1}{value \yct{3}{for each tested victim row from each manufacturer (different subplots)},} normalized to \agy{1}{the} \gls{ber} \agy{1}{value when the victim row is refreshed using the nominal charge restoration latency.}
% \yct{7}{Dashed red lines represent the lowest charge restoration latency that does \emph{not} significantly \om{8}{(i.e., by more than 3\% on average)} increase RowHammer \gls{ber} for each manufacturer.}
% where full charge restoration latency is used. 
\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{figures/fig9_BER_vs_PCR.pdf}
\caption{\yct{3}{$\bm{BER}$ versus charge restoration latency in all tested DRAM rows}}
\label{fig:ber_single_pcr}
\end{figure}
We make \param{two} observations from \figref{fig:ber_single_pcr}.
First, \gls{ber} of the tested rows \agy{1}{increases} \om{3}{superlinearly} \agy{1}{as} charge restoration latency \agy{1}{reduces for Mfrs.~H and~S.} 
% \agy{1}{Second, at very low \gls{tras} values (e.g., 18\% of the nominal \gls{tras}), charge restoration is \emph{not} strong enough for a subset of DRAM cells to retain data for \{\milli\second}, and thus they exhibit an \gls{nrh} value of 0, meaning that they experience bitflips without being hammered.} 
% When \param{0.18} latency is used to refresh the victim rows, some of the victim rows have 0 \gls{nrh} meaning that they cannot retain their data for \gls{trefw} even if no hammering is performed. 
\agy{1}{Second}, reducing charge restoration latency \agy{1}{by \param{36\%}, \param{82\%}}\om{6}{, and 19\%} \yct{6}{(shown with dashed red lines)} does \emph{not} significantly increase \yct{6}{($<3\%$)} the \gls{ber} of the \agy{1}{tested} rows \agy{1}{from} Mfrs.~H, M, and~S, respectively. \yct{3}{From these observation, we derive:}

\takeaway{\yct{3}{Charge restoration latency can be reduced down to a safe minimum value without \yct{7}{significantly} increasing the RowHammer \gls{ber}.}\label{take:ber_cr}}
% \takeaway{\yct{3}{Charge restoration latency can be reduced i)~with no effect on RowHammer \gls{ber} or ii)~at the cost of a superlinear increase in the RowHammer \gls{ber}.\label{take:ber_cr}}}

% These observations support our \om{3}{ (see~\secref{sec:effect_nrh}, \figref{fig:nRH_single_pcr}) that charge restoration latency can be \agy{1}{significantly} reduced~i)~with no effect on RowHammer vulnerability or~ii)~at the cost of an increase in the RowHammer vulnerability.}
% \agy{1}{Second}, reducing charge restoration latency \agy{1}{by \param{36\%} and by \param{82\%}} does \emph{not} significantly increase the \gls{ber} of the \agy{1}{tested} rows \agy{1}{from} Mfrs.~H and~M, respectively. \agy{1}{This observations supports our hypothesis \om{3}{(see~\secref{sec:effect_nrh},~\figref{fig:nRH_single_pcr})} that Mfrs.~H and~M implement} a large guardband \agy{1}{in their nominal} charge restoration latency, \agy{1}{such that it} can be \agy{1}{significantly} reduced without \agy{1}{exacerbating} \om{3}{the} RowHammer vulnerability. 



% \agycomment{3}{Onur's comment to Sec 5 title applies here too. Change this and revisit all section and subsection titles.}
\subsection{\om{6}{Combined} Effect of Temperature\\and Charge Restoration Latency on RowHammer}
\label{sec:effect_temp}

\srev{\yct{3}{We} study the \om{7}{combined} impact of temperature and charge restoration latency on RowHammer vulnerability in terms of \gls{nrh} and \gls{ber}.
\figref{fig:nrh_single_pcr_temp} demonstrates \yct{3}{how \om{6}{\gls{nrh} and} \gls{ber} change as charge restoration latency reduces using} a box-and-whiskers plot.\fnref{fn:boxplot}
The x-axis shows the normalized restoration latency used \agy{1}{for refreshing} victim rows \agy{1}{before hammering} and the y-axis shows the \gls{nrh} (top \yct{3}{subplots}) and \gls{ber} (bottom \yct{3}{subplots}) \agy{1}{values \yct{3}{for each tested victim row},} normalized to \agy{1}{the} \gls{nrh} and \gls{ber} \agy{1}{values when the victim row is refreshed using the nominal charge restoration latency. Different colors represent different temperature values.} 
}

\yctcomment{10}{Added Micron}
\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{figures/fig10_TEMP.pdf}
\caption{\yct{3}{RowHammer vulnerability in terms of $\bm{N}_{\bm{RH}}$ (top subplots) and $\bm{BER}$ (bottom subplots) versus charge restoration latency for each tested DRAM row at \om{6}{three different temperatures}}}
\label{fig:nrh_single_pcr_temp}
\end{figure}

% \agycomment{3}{Please double check this}\yctcomment{3}{correct}
% We make one key observation from~\figref{fig:nrh_single_pcr_temp}.
% \yct{3}{Temperature does \emph{not} have a significant effect on how RowHammer vulnerability changes with reduced charge restoration latency.}
\agy{3}{From \figref{fig:nrh_single_pcr_temp}, we observe that temperature does \emph{not} significantly \om{6}{impact} the effect of reducing charge restoration latency on RowHammer vulnerability.}
\yct{10}{For example, when the temperature is raised from \SI{50}{\celsius} to \SI{80}{\celsius}, the normalized \gls{nrh} (\gls{ber}) changes by only \param{0.31\% (1\%), 0.20\% (0.02\%), and 0.08\% (9\%)} for the chips from Mfrs.~H, M, and S, respectively.}}
\yct{3}{Based on this observation, we derive:}
% \om{3}{Based on these observations, we conclude that rows that are already vulnerable to Rowhammer under nominal \gls{tras} are relatively less affected by reduced charge restoration latency.}

\takeaway{\yct{3}{Our experimental results show no significant impact of temperature on the effect of charge restoration latency on RowHammer vulnerability.\label{take:nrh_temp}}}
% \agycomment{3}{This takeaway is way stronger and conclusive than what the data can substantiate. I would move it to the end of the characterization and make the takeaway softer. It is better to say \emph{Our experimental results show no significant impact of temperature on...} instead of \emph{Temperature does not affect}}\yctcomment{3}{I see, i am not sure about moving this but making it softer makes sense.}
% We make \param{N} observations from \figref{fig:ber_single_pcr}. First, \gls{ber} of the tested rows increases significantly as we reduce the charge restoration latency for Mfr. S and Mfr. H. Second, reducing charge restoration latency up to some point does not significantly affect the \gls{ber} of the rows in Mfr. H. This observation supports that Mfr. H uses a large guardband for charge restoration latency. Third, the rows of Mfr. M does not show an increase in the RowHammer vulnerability similar to their observed \gls{nrh}.

% \agy{1}{Fourth}, the RowHammer vulnerability of Mfr. M does not get affected by the change in the charge restoration latency. We hypothesize that the chips of Mfr. M ignores the timing of the commands as we use non-manufacturer-recommended timing parameters.

% , we analyze the effect of charge restoration latency on the \gls{ber}, following the algorithm in \algref{alg:test_alg}.

% \figref{fig:ber_single_pcr} demonstrates the \agy{1}{impact of reduced charge restoration latency on RowHammer} \gls{ber}. 
% % change when different charge restoration latencies are used to refresh victim rows for one time. 
% The x-axis shows the normalized charge restoration latency used to refresh the victim rows and the y-axis shows the \gls{ber} normalized to \gls{ber} where full charge restoration latency is used. 


% \agy{1}{Fourth}, the RowHammer vulnerability of Mfr. M does not get affected by the change in the charge restoration latency. We hypothesize that the chips of Mfr. M ignores the timing of the commands as we use non-manufacturer-recommended timing parameters.

\subsection{Effect of Repeated Partial Charge Restoration\\on RowHammer}
\label{sec:rh_rep}

\agy{1}{Reducing charge restoration latency can lead to partially restoring \agy{20}{DRAM cell} charge. Repeating partial charge restoration can eventually degrade the stored charge to a level that is \emph{not} strong enough \om{6}{to maintain data integrity \om{7}{in} the presence of charge leakage}. \yct{3}{Therefore, we} investigate the effect of repeated partial charge restoration on the RowHammer vulnerability.}
\yct{3}{To do so, we perform different numbers of consecutive preventive refreshes on the victim row with reduced charge restoration \om{6}{latency} before hammering the aggressor rows.}
% \agycomment{3}{We need to explain when and how this repeated partial charge restoration is done either here or in Sec 4. If in Sec 4, here we should provide a cross reference probably.}    


\figref{fig:nrh_multiple_pcr} demonstrates \yct{3}{how \gls{nrh} changes} when the victim row is repeatedly \om{6}{preventively} refreshed with reduced charge restoration latency 
% before the hammering with reduced charge restoration \agy{1}{latency using 
using a box-and-whiskers plot.\fnref{fn:boxplot}
The x-axis shows the normalized charge restoration latency used \agy{1}{for refreshing} victim rows \agy{1}{\yct{3}{before hammering (see \secref{subsec:testing_methodology})}} and the y-axis shows the \gls{nrh} \agy{1}{value \yct{3}{of each tested row},} normalized to \agy{1}{the} \gls{nrh} \agy{1}{value when the victim row is refreshed using the nominal charge restoration latency.} \agy{1}{Different colors denote the number of restorations performed on the victim row with reduced charge restoration latency.} \yct{3}{Each subplot shows data from a different manufacturer, aggregated across all tested chips from that manufacturer.}
% \agycomment{3}{Talk about the population of data points in these plots, similar to the fixes to other earlier plots.}\yctcomment{3}{added}

\yctcomment{10}{Added Micron}
\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{figures/fig11_NRH_vs_RPCR.pdf}
\caption{\yct{3}{$\bm{N}_{\bm{RH}}$ versus repeated partial charge restoration in all tested DRAM rows}}
\label{fig:nrh_multiple_pcr}
\end{figure}

\agy{1}{We make \param{three} observations from \figref{fig:nrh_multiple_pcr}. 
First, \gls{nrh} of tested rows from \yct{10}{Mfrs.~H and M} is \emph{not} significantly affected by the number of restorations as the \gls{nrh} values are similar across different numbers of restorations. 
Second, \gls{nrh} of the tested rows from Mfr. S decreases as the number of restorations increases. For example, under $0.36t_{RAS}$, a clear downward trend is observed in the \om{6}{\gls{nrh}} values. 
Third, performing partial charge restoration multiple times can lead to data retention bitflips at very low \gls{tras} values. For example, a single partial charge restoration using $0.27t_{RAS}$ does \emph{not} lead to data retention bitflips for tested rows from Mfr. S, while repeating \om{6}{such partial} restoration twice \om{6}{across two preventive refreshes} can lead to data retention bitflips (i.e., \om{6}{some cells} experience bitflips with \emph{no} hammering\om{6}{, as induced by $N_{RH}=0$)}.}
\yct{3}{Based on these observations, we conclude that \agy{3}{using reduced charge restoration latency \om{7}{repeatedly for} many consecutive preventive refreshes} might lead to data retention bitflips at very low \gls{tras} values.}
% \agycomment{3}{We need to conclude something from this plot. Each plot should have a conclusion. Takeaway is a conclusion for some of them, but not all plots have their own private takeaways. Revisit all plots and draft conclusions.}\yctcomment{3}{added}

% \begin{itemize}
%     \item \gls{nrh} of the tested rows from Mfr. H does not significantly change with the number of restorations.
%     \item \gls{nrh} of the tested rows from Mfr. S decreases with the number of restorations.
%     \item Performing partial charge restoration with \param{0.27\%} latency twice reduces the \gls{nrh} up to 0 for some rows from Mfr. S, meaning that those rows cannot retain their data for \gls{trefw}. 
% \end{itemize}
% \yctcomment{0}{Some bridge sentence to extreme number of restorations.}

\agy{1}{To investigate the effect of repeated \om{7}{partial} charge restoration more rigorously, we scale up the number of \agy{3}{repeated partial charge} restorations up to 15K \agy{3}{at the beginning of each test for \yct{10}{three} representative modules: \yct{10}{H7, M2, and S6}}.
\figref{fig:nrh_ext_pcr} demonstrates how \gls{nrh} \agy{1}{changes when the victim row is repeatedly refreshed before hammering with} \yct{6}{charge restoration latency of $0.36t_{RAS}$} \agy{1}{\agy{3}{using} a box-and-whiskers plot.}\fnref{fn:boxplot}
% are used to refresh victim rows for one time. 
The x-axis shows the number of \yct{6}{partial charge restorations} performed on the victim row with $0.36t_{RAS}$. The y-axis shows the \gls{nrh} \agy{1}{values} \agy{3}{when the victim rows are repeatedly refreshed with reduced charge restoration latency\yct{6}{,} normalized \yct{6}{to their \gls{nrh} values with the nominal \gls{tras}}}.
% to the row's \gls{nrh} when refreshed using nominal charge restoration latency.\yctcomment{7}{hard to read simplify}
% normalized to \agy{1}{the} \gls{nrh} \agy{1}{value when the victim row is refreshed before hammering using the nominal restoration latency for two representative modules.} 
\agy{1}{Different colors denote different modules.}}

% To study the impact of repeated charge restoration, we test two representative modules, H7 and S6, with up to 15,000 repeated partial charge restorations. Figure 12 shows how NRH changes when the victim row is refreshed multiple times with a reduced charge restoration latency of 
%  . The x-axis represents the number of refreshes performed before hammering, while the y-axis shows the NRH values normalized to those under nominal charge restoration latency. Different colors indicate different DRAM modules.
% \figref{fig:nrh_ext_pcr} shows the \gls{nrh} change for \param{0.36} charge restoration latency and different numbers of restorations for two representative modules from Mfr. S and Mfr. H. The x-axis shows the number of restorations performed and the y-axis shows the normalized \gls{nrh} distribution. 

\yctcomment{10}{Added Micron}
\begin{figure}[ht]
\centering
\includegraphics[width=0.9\linewidth]{figures/fig12_NRH_extreme.pdf}
\caption{\yct{3}{$\bm{N}_{\bm{RH}}$ versus \om{7}{number of} repeated partial \om{6}{charge} restorations in all tested rows from \yct{10}{three} modules}}
\label{fig:nrh_ext_pcr}
\end{figure}
% \yctcomment{1}{Missing ylabel and wrong xlabel}

We make \param{\agy{3}{three}} observations from \figref{fig:nrh_ext_pcr}.
First, \gls{nrh} \om{6}{values} of the rows from \yct{10}{Mfrs.~H and M} are \emph{not} significantly affected by the number of partial charge restorations. For example\yct{1}{, \gls{nrh} values \yct{10}{of the tested rows from Mfr.~H} \yct{3}{change only by $1.24\%$} \om{6}{if rows} are refreshed 15K times using $0.36t_{RAS}$ \om{6}{versus only one time}.}
% \agycomment{3}{Give numbers. The word similar is not scientific enough.}\yctcomment{3}{added}
Second, performing restorations using reduced charge restoration latency many times can lead to data retention bitflips in the rows from Mfr.~S. 
% For example, some rows exhibit data retention bitflips (i.e., performing 2.5K partial charge restorations causes some cells to lose their charge \emph{without} hammering) when they are refreshed more than 2.5K times.
\yctcomment{7}{We checked the data and they are correct, for high latencies, it does not matter the number of refreshes since after each refresh the voltage level will be the same.}
For example, \agy{3}{using reduced charge restoration latency for} 2.5K \agy{3}{consecutive \om{7}{preventive} refreshes}
% partial charge restorations 
causes some cells to lose their charge \emph{without} hammering (\om{6}{as seen by} $N_{RH}=0$).
% Therefore, to 
% \agycomment{3}{This was ``Therefore,'' but the previous sentence does not directly result in the claim in this sentence. I think this is a new observation.}
\yct{6}{Third, to prevent bitflips due to repeated partial charge restorations, there should be a limit on the number of consecutive refreshes with reduced charge restoration latency.}
% \agy{3}{Third, to} avoid bitflips caused by repeatedly refreshing a row using reduced charge restoration latency, an upper limit should be enforced to the number of such consecutive refreshes. 
For example, rows from \yct{10}{Mfrs.~H, M, and S} experience \emph{no} bitflips when their rows are
refreshed \yct{10}{15K, 15K, and 1K} times with \yct{6}{$0.36t_{RAS}$}, respectively. 
After the rows from \yct{10}{Mfrs.~H, M, and S} are refreshed \yct{10}{15K, 15K, and 1K} times, respectively, we need to perform a charge restoration using nominal \gls{tras} to fully restore the charges of the cells.
\agy{3}{Based on our analysis of the repeated partial charge restoration, we derive:}

\takeaway{\yct{6}{Reduced charge restoration latency can be used safely for many consecutive refreshes without causing any failures.}\label{take:rh_rep}}
% \takeaway{It is not safe to reduce charge restoration latency (\gls{tras}) for \emph{all} refreshes. A DRAM row from Mfrs.~H and~S should be refreshed using the nominal charge restoration latency once after every {15K and 1K} refreshes with reduced \gls{tras}, respectively.\label{take:rh_rep}}










\section{\yct{3}{Effect of Charge Restoration Latency on \om{7}{the} Half-Double \om{7}{Access Pattern}}}
\label{sec:halfdobule_chargerestoration}
\iey{7}{An aggressor row can cause bitflips in victim rows that are not physically adjacent~\cite{kim2014flipping,kim2020revisiting}. The impact of RowHammer on a victim row decreases and eventually disappears as the physical distance between the victim and the aggressor rows increases. To account for this characteristic, prior works define \emph{blast radius} as the distance between an aggressor row and its furthest victim row~\cite{kim2014flipping,kim2020revisiting, frigo2020trrespass,orosa2021deeper,cojocar2020rowhammer,deridder2021smash,hassan2021utrr,jattke2022blacksmith,kogler2022half,park2020graphene, yaglikci2021security, yaglikci2021blockhammer, hassan2024selfmanaging, devaux2021method, patel2022case, patel2024rethinking}. A recent RowHammer attack, Half-Double~\cite{kogler2022half}, introduces an access pattern (i.e., Half-Double access pattern) that exploits blast
radius to induce bitflips with a significantly lower activation count. Half-Double demonstrates that}
\yct{7}{hammering a \emph{far} aggressor row (i.e., physically two rows away from the victim row) many times and then hammering the \emph{near} aggressor row (i.e., physically \om{8}{adjacent to} the victim row) a much smaller number of times lead\iey{7}{s} to bitflips in some DDR4 DRAM chips.}
%\yct{7}{Prior work~\cite{kogler2022half} demonstrates Half-Double access pattern where hammering a \emph{far} aggressor row (i.e., physically two row away from the victim row) many times and then hammering the \emph{near} aggressor row (i.e., physically one row away from the victim row) a much smaller number of times lead to bitflips in some DDR4 DRAM chips.}
% Although double-sided RowHammer is more effective  (i.e., leads to more bitflips and bitflips at smaller hammer counts) than the Half-Double attack at the circuit level, prior works~\cite{kogler2022half} demonstrate 
Half-Double \yct{7}{access pattern is} based on exploiting two weaknesses of a poorly designed RowHammer mitigation mechanism i)~underestimation of blast radius (i.e., the \agy{7}{maximum distance between an aggressor and a victim} row) and ii)~ignoring the hammering effect of the victim row preventive refreshes. To mitigate Half-Double bitflips, existing RowHammer mitigation mechanisms perform preventive refreshes on \agy{7}{all four rows in} $\pm2$\agy{7}{-row distance} of the aggressor row~\cite{olgun2024abacus, canpolat2024prac, qureshi2024mint, qureshi2024impress, hassan2021utrr, yaglikci2021blockhammer}. For completeness, we analyze the impact of reducing charge restoration latency on \iey{7}{the} Half-Double \om{7}{access pattern}. To do so, we modify \algref{alg:test_alg} such that the hammering function performs \iey{7}{the} Half-Double access pattern instead of double-sided RowHammer on randomly selected \param{\agy{7}{two}} modules from \agy{7}{each of Mfrs.~H and~S (four modules in total).}

\srev{
\figref{fig:half_cr} demonstrates the impact of reduced \gls{tras} on the Half-Double access pattern in terms of the percentage of rows with Half-Double bitflips for the modules from Mfr.~H \yct{7}{\om{7}{(}we do \emph{not} observe any Half-Double bitflips in the modules from Mfr.~S\om{7}{)}}.\yctcomment{7}{Yes, we should test Mfr. M as well, added to TODO.}
% \agycomment{4}{What about Mfr. S? We should generate the same plot for Mfr. S too.}\yctcomment{7}{thanks} 
The x-axis shows the normalized charge restoration latency used for refreshing victim rows before Half-Double and the y-axis shows the percentage of rows with Half-Double bitflips. Different colors represent different number\om{7}{s} of partial charge restorations.
}\yct{7}{Error bars represent the minimum and maximum values across each tested module from Mfr.~H.}


\begin{figure}[!h]
\centering
\includegraphics[width=1\linewidth]{figures/fig13_HalfDouble.pdf}
\caption{\srev{Percentage of rows with Half-Double bitflips \om{8}{versus} reduced charge restoration latency \om{8}{for preventive refreshes}}}
\label{fig:half_cr}
\end{figure}


\srev{
We make four observations.
First, the \om{7}{tested} modules from Mfr.~S do \emph{not} exhibit Half-Double bitflips within a \gls{trefw} (i.e., 64ms) interval\om{7}{, even though they do exhibit double-sided RowHammer bitflips (\secref{sec:effect_nrh})}. 
Second, the total number of Half-Double bitflips is significantly lower than the total number of double-sided RowHammer bitflips (not shown in the figure).
Third, \yct{7}{when charge restoration latency is reduced by 64\%,} the \om{8}{percentage} of rows with bitflips decreases \yct{7}{(by 39.31\%)}\yctcomment{8}{checked the precision for all numbers}.
% to a minimum value \yct{7}{(by 64\%)} 
\yct{7}{As charge restoration latency is reduced from $0.36t_{RAS}$ to $0.18t_{RAS}$, the \yct{8}{percentage} of rows with bitflips significantly increases.}
%while reducing latency further increases the number of rows with bitflips.
\yctcomment{7}{we do not have a hypothesis for now and we are trying.}
% \ieycomment{7}{There are two interesting parts: 1) there is a decrease and 2) this trend changes after some point. Do you test same set of rows from Figure 10 for example? Can we try to hypothesize something from other results? For example, some rows exhibit higher rowhammer threshold (or lower ber) when you reduce the latency. maybe we can recycle what we write there (if we have written any hypothesis.}
%Third, the number of rows with bitflips slightly decreases as the charge restoration latency is reduced to a minimum value \yct{7}{(by 64\%)} while reducing latency further increases the number of rows with bitflips.\yctcomment{7}{we do not have a hypothesis and the decrease is not that strong.}
Fourth, the number of charge restorations does \emph{not} significantly affect the \yct{8}{percentage} of rows with bitlips. \yct{7}{For example, the \yct{8}{percentage} of rows with bitflips varies by 1.50\% when \yct{8}{each tested row is} refreshed one time using $0.36t_{RAS}$ versus refreshed five times.}
% \agycomment{4}{These observations need some quantification.}
We conclude that i)~the double-sided RowHammer pattern is significantly more effective than \om{7}{the} Half-Double access pattern and ii)~charge restoration latency can be reduced to a safe minimum value without affecting the Half-Double \yct{8}{access pattern} vulnerability of a DRAM chip.
}
















% \setcounter{ismail}{\value{version}}
% \setcounter{version}{7}

\section{\yct{3}{Effect of Charge Restoration Latency\\on Data Retention Failures}}
\label{sec:retention_chargerestoration}


\srev{We analyze \yct{7}{how the data retention time of a DRAM row changes as charge restoration latency reduces}\om{7}{.}\yctcomment{7}{We will test more modules and data pattern. added to TODO.}
% the impact of reducing charge \sql{R1.1}restoration latency during periodic refreshes which are performed to prevent data retention failures. 
To do so, we select \yct{10}{2, 1, and 4} modules from \yct{10}{Mfrs.~H, M, and~S}, respectively, and test all rows in a \yct{7}{randomly selected} bank from each module at \SI{80}{\celsius} using \param{two} data patterns \yct{7}{(all 1s and 0s)}. \yct{7}{To analyze the effect of reduced charge restoration latency on data retention time,} we \yct{7}{perform charge restoration on} the \yct{7}{tested} row \yct{7}{using} reduced charge restoration latency \param{once or ten} times. \yct{7}{Then,} we wait for the data retention time we want to test and check for bitflips. To analyze the change in the data retention time of DRAM cells, we test the rows with \yct{7}{different} data retention times ($64ms,\ 96ms,\ 128ms,\ 256ms,\ 512ms,\ 1024ms$).}

% \agycomment{4}{Specify the module name here}
% \yctcomment{7}{I checked the figure and the text. The they are saying we do not observe bitflips at 0.36tras, 10 restoration and 256ms, which is the pink line (behind the yellow line), and they point shows 0 rows with bitflips. I also updated the lines' saturation to make it visible the lines that are behind at each other.}
\srev{~\figref{fig:ret_cr} demonstrates the \yct{7}{effect} of reduced \yct{7}{charge} restoration latency on data retention failures \yct{10}{for different manufacturers (\om{11}{each represented in different} columns of subplots)}.
% for a representative module (S4)\yctcomment{7}{we will add data for all modules in the extended version. Added to TODO}
The x-axis shows the normalized charge restoration latency used \agy{1}{for refreshing} rows. The y-axis shows the fraction of rows with data retention failures \yct{10}{when the tested row is refreshed using reduced latency one time (top subplots) or ten times (bottom subplots)}.
\yct{10}{Each curve represents a different data retention time \yct{7}{and overlapping lines use the color corresponding to the higher data retention time.}}}
\yct{10}{Each data point presents the average values across all tested modules from a manufacturer.}
\yctcomment{7}{Replotted the figure with distinct colors and added this explanation.}
% \yctcomment{10}{updated the figure}
\vspace{10pt}
\begin{figure}[ht]
\centering
\includegraphics[width=1\linewidth]{figures/fig14_Retention.pdf}
\caption{\srev{Fraction of rows with data retention failures under repeated partial charge restoration}}
\label{fig:ret_cr}
\end{figure}

\srev{We make \yct{10}{seven} observations from \figref{fig:ret_cr}.
% First, the tested rows from Mfr.~H and~M do \emph{not} experience any bitflips even when they are refreshed five times using $0.18t_{RAS$.
\yct{10}{First, the tested rows from Mfrs.~H and M do \emph{not} experience data retention bitflips at $256ms$ and $512ms$ even when the rows are refreshed ten times using $0.27t_{RAS}$, respectively.}
\yct{10}{Second, for Mfr.~H, the fraction of rows with bitflips slightly increases when $t_{RAS}$ is reduced from  $0.36t_{RAS}$ to $0.27t_{RAS}$, while the number of \agy{7}{consecutive} partial charge restorations does \emph{not} affect the data retention failures.}
\yct{10}{Third, for Mfr.~M, reducing charge restoration latency does \emph{not} affect the data retention failures.}
\yct{10}{Fourth}, the tested rows \yct{10}{from Mfr.~S} do \emph{not} experience data retention bitflips for $256ms$ even when they are refreshed ten times using $0.36t_{RAS}$.\yctcomment{7}{the data was correct but plot was hard to separate, fixed it.}
\yct{10}{Fifth}, the data retention time of some rows \yct{10}{from Mfr.~S} decreases as charge restoration latency reduces. For example, while \emph{no} data retention failures occur when the rows are refreshed using $0.36t_{RAS}$ even with a data retention time of $256ms$, some rows experience data retention bitflips when they are refreshed using $0.27t_{RAS}$.
{\yct{10}{Sixth}, \yct{10}{for Mfr.~S}, the number of \agy{7}{consecutive} partial charge restorations significantly affects the number of rows with data retention bitflips. \yct{8}{For example, \param{472$\times$} more rows experience data retention bitflips at $256ms$ when they are refreshed ten times instead of one time using $0.27t_{RAS}$.}}}
% \ieycomment{7}{This is not easy to see as Onur said. Here give an example (e.g., for 512ms of data retention time XXX more rows experience bitflips...(the rest of your sentence)}\yctcomment[7]{I think with the new figure, this is clear.}
\yct{7}{\yct{10}{Seventh}, our observations are aligned with \agy{7}{a} prior work~\cite{das2018vrldram} that develop\om{7}{s} a detailed circuit-level analytical model and analyze\om{7}{s} the effect of reduced charge restoration latency on the data retention times (not shown in the figure).}
% \ssrev{Based on these observations, we conclude that charge restoration latency can be reduced to a safe minimum value without causing data retention failures while reducing beyond this point causes data retention failures.}
\yct{7}{From these observations, we derive:}

\takeaway{Charge restoration latency can be reduced to a safe minimum value without causing data retention failures.\label{take:retention}}

% \yctcomment{7}{is this too out of space?}
% \agycomment{4}{yes, a bit. It says something new after we wrap up the analysis.}


%=====================================================
%=====================================================
%=====================================================
%=====================================================
%=====================================================
%=====================================================
%=====================================================
%=====================================================
%=====================================================
%=====================================================
% HALF DOUBLE

% \section{\yct{3}{Effect of Charge Restoration Latency on Half-Double Attack}}
% \label{sec:halfdobule_chargerestoration}

% \yctcomment{3}{We can chop this part if we need space.}
% \srev{
% Although double-sided RowHammer is more effective  (i.e., leads to more bitflips and bitflips at smaller hammer counts) than the Half-Double attack at the circuit level, prior works~\cite{, qazi2021halfdoublereport} demonstrate Half-Double attack, based on exploiting two weaknesses of a poorly designed RowHammer mitigation mechanism i)~underestimation of blast radius (i.e., the impact radius of an aggressor row) and ii)~ignoring the hammering effect of the victim row refreshes. To mitigate Half-Double bitflips, existing RowHammer mitigation mechanisms perform preventive refreshes on $\pm2$ of the aggressor row~\cite{olgun2024abacus, canpolat2024prac, qureshi2024mint, qureshi2024impress, hassan2021utrr, yaglikci2021blockhammer}. For completeness, we analyze the impact of reducing \gls{tras} on the Half-Double attacks. To do so, we modify \algref{alg:test_alg} such that the hammering function performs Half-Double pattern instead of a double-sided RowHammer on the randomly selected \param{2} modules from Mfr.~H and 2 modules from Mfr.~S.
% }

% \srev{
% \figref{fig:half_cr} demonstrates the impact of reduced restoration latency on the Half-Double access pattern in terms of the percentage of rows with bitflips for the modules from Mfr.~H. The x-axis shows the normalized charge restoration latency used for refreshing victim rows before Half-Double attack and the y-axis shows the ratio of rows with bitflips. Different colors represent the different number of partial charge restorations.
% }


% \begin{figure}[ht]
% \centering
% \includegraphics[width=\linewidth]{figures/fig13_HalfDouble.pdf}
% \caption{\srev{Percentage of rows with Half-Double bitflips under partial charge restoration}}
% \label{fig:half_cr}
% \end{figure}


% \srev{
% We make four observations from \figref{fig:half_cr}.
% First, the modules from Mfr.~S do \emph{not} exhibit Half-Double bitflips under a \gls{trefw} (i.e., 64ms) interval. 
% Second, the total number of Half-Double bitflips is significantly lower than the total number of Half-Double bitflips.
% Third, the number of rows with bitflips slightly decreases as the restoration latency is reduced to a safe minimum value while reducing latency further causes retention failures and increases the number of rows with bitflips. 
% Fourth, the number of restorations does \emph{not} significantly affect the number of rows with bitlips.
% We conclude that i)~the double-sided RowHammer pattern is significantly more effective than Half-Double access pattern and ii)~the charge restoration latency can be reduced to a safe minimum value without affecting the Half-Double attack vulnerability of a DRAM chip.
% }

% \setcounter{version}{\value{ismail}}