\section{Characterization Methodology}
\label{sec:methodology}
\om{3}{We} describe our DRAM testing infrastructure, the real DDR4 DRAM chips tested, and our testing methodology.

\subsection{DRAM Testing Infrastructure}
\label{subsec:methodology_infra}

We test {commodity} DDR4 DRAM chips using an FPGA-based DRAM testing infrastructure that consists of four main components {(as Fig.~\ref{fig:infrastructure} illustrates)}: i)~a host machine that generates the test {program} and {collects experiment results}, ii)~an FPGA development board (Xilinx Alveo U200~\cite{alveo_u200}), programmed with DRAM Bender~\cite{olgun2023drambender, safari-drambender} {(based on SoftMC~\cite{hassan2017softmc, softmcgithub})}, {to execute our test programs}, iii)~a thermocouple temperature sensor and a pair of heater pads pressed against the DRAM chips {to maintain a {target temperature level}}, and iv)~a PID temperature controller (MaxWell FT200~\cite{maxwellFT200}) that controls the heaters and keeps the temperature at the desired level \agy{0}{with a precision of $\pm$\SI{0.5}{\celsius}}.\footnote{\yct{3}{To test the reliability of our temperature controller during RowHammer tests, we repeat RowHammer tests on all rows in round-robin fashion at nine different hammer counts \yct{3}{for 24 hours}. We sample the temperature of three modules (one from each manufacturer) every 5 seconds and observe that the variation in temperature is less than \SI{0.5}{\celsius}.
% \agycomment{3}{A similar text should be in Svard. Why don't you just copy it? This last sentence is still meaningless because it doesnt tell you for how long you kept the test running.YCT:copied it properly}
}}
% To evaluate temperature stability during RowHammer tests, we perform a
% double-sided RowHammer test with a hammer count of 1M and traverse across
% all rows in round-robin fashion for 24 hours at three different temperature levels.
% We sample the temperature of three modules (one from each manufacturer)
% every 5 seconds and observe a variation within the error margin of 0.2
% ◦C,
% 0.3
% ◦C, and 0.5
% ◦C at 35 ◦C, 50 ◦C, and 80 ◦C, respectively.


\begin{figure}[ht]
\centering
\includegraphics[width=0.9\linewidth]{figures/fig5_test_infra.png}
\caption{\srev{\om{3}{Photograph of our} DRAM \sql{R4}Bender infrastructure}}
\label{fig:infrastructure}
\end{figure}




\head{Eliminating interference sources} 
To observe \agy{0}{RowHammer bitflips} \yct{0}{without any circuit-/system-level interference},
we \yct{0}{take \param{three} measures }\agy{0}{ to eliminate} potential sources of interference, \yct{0}{as \om{3}{done} in} prior works~\cite{kim2020revisiting, orosa2021deeper, yaglikci2022understanding, hassan2021utrr, luo2023rowpress}.
First, we disable periodic refresh during the execution of our test programs to \agy{0}{prevent \yct{0}{any unintended charge restoration by periodic refreshes or }potential on-DRAM-die \gf{0}{TRR} mechanisms~\cite{frigo2020trrespass, hassan2021utrr}}.
% \agycomment{4}{I removed some redundant text here}\yctcomment{7}{thanks}
% so that we can} observe the DRAM chip's behavior at the circuit-level.
Second, we \yct{0}{make sure the runtime of any program does \emph{not} exceed the refresh window such that \agy{6}{\emph{no}} data retention failures are observed.}
%\agy{0}{strictly bound the execution time of} our test programs within \agy{0}{the} refresh window \agy{0}{of the tested DRAM chips at the tested temperature} to avoid data retention failures interfering with read disturbance failures. 
Third, we \yct{0}{confirm} that the tested DRAM modules and chips have neither rank-level nor on-die ECC.
\agy{0}{{\agy{6}{By doing so,}} we directly observe {and analyze} all {circuit-level} bitflips {without interference} {from architecture-level correction and mitigation mechanisms}\om{3}{~\cite{patel2020beer, patel2019understanding}}.}
% \agy{0}{With these \param{three} measures,} we directly observe and analyze all bitflips without interference.}

\subsection{Tested DDR4 DRAM Chips}
\label{sec:methodology_dramchips}

% \agycomment{3}{This is a bit oddly specific. We usually do not specify the DIMM type. However, it is good to have. Now, the missing thing is which module is which type in the table below.} 
% \agycomment{3}{Onur wrote belonging, you changed it to belongs without a which or that preceding belongs. Now you have an extra grammar mistake :D} 
{Table~\ref{tab:dram_chip_list} \om{3}{lists} the \agy{0}{\nCHIPS{} real DDR4 DRAM chips (\om{3}{\agy{3}{belonging} to 10 U-DIMM, 10 R-DIMM, and 10 SO-DIMM modules})} that we test from all three major DRAM manufacturers, which cumulatively hold a \SI{97}{\percent} share of the DRAM market~\cite{statista2024marketshare}.}
{\agy{0}{To investigate whether our analysis applies to different DRAM technologies, designs, and manufacturing processes,
we test various} DRAM chips with different die densities and die revisions from each DRAM chip manufacturer.}\footnote{\agy{0}{A DRAM chip's} technology node is \agy{0}{\emph{not} always} publicly available. 
A die revision code of X indicates that there is \emph{no} public information available about the die revision. We provide more detail on all tested DRAM modules, their RowHammer characteristics under partial charge restoration, and their \X{} configuration parameters in Appendix \ref{sec:ext_tables}.
% ~\iey{6}{We provide much more detail on all tested DRAM chips and a summary of their read disturbance and reduced latency characteristics in the extended version of this paper~\cite{}.}
}
%(e.g., the DRAM module vendor has removed the original DRAM chip manufacturer's markings, and the DRAM stepping field in the SPD is $0x00$.)
{To maintain a reasonable experiment time, we perform our characterization using a total of 3K rows \om{3}{in a randomly selected} bank from each module we tested; 1K from the beginning, 1K from the middle, and 1K from the end of the DRAM bank\om{3}{, similarly} to prior \om{3}{works}~\cite{luo2023rowpress, yaglikci2022hira, kim2014flipping, orosa2021deeper, yaglikci2022understanding, olgun2023hbm, gao2022frac, gao2019computedram}}.
% {All of the results report the data across \om{3}{total} 3K rows from \nCHIPS{} chips unless otherwise specified.}
\yctcomment{6}{I will prepare the extended table for appendix}
\input{tables/tested_modules}

\subsection{Testing Methodology}
\label{subsec:testing_methodology}

\head{Metrics}
{To characterize \agy{20}{a DRAM row's RowHammer} vulnerability, we examine \agy{0}{two metrics:  {i)~\gls{nrh}, the minimum number of activations per\yctcomment{3}{Yes, we always use double-sided.} aggressor \om{3}{row} to \om{3}{observe} at least one RowHammer bitflip and ii)~\gls{ber}, the fraction of DRAM cells in a row that experience a RowHammer bitflip}.
% {We define \gls{nrh} as the minimum number of activations per aggressor to get at least one RowHammer bitflip, and \gls{ber} as the ratio of cells exhibiting RowHammer bitflip in a row.}
A higher \gls{nrh} (\gls{ber}) indicates lower (higher)} vulnerability.}

\SetAlFnt{\scriptsize}
\RestyleAlgo{ruled}
\begin{algorithm}
{\setstretch{0.8}
\caption{Test for profiling the effect of reduced \gls{tras} on RowHammer vulnerability}\label{alg:test_alg}
    \DontPrintSemicolon
    \SetAlgoLined
    \SetKwFunction{FMain}{main\_test\_loop}
    \SetKwFunction{FHammer}{perform\_RH}
    \SetKwFunction{initialize}{init\_rows}
    \SetKwFunction{measureber}{perform\_RH}
    \SetKwFunction{check}{check\_for\_bitflips}
    \SetKwFunction{Hammer}{hammer\_doublesided}
    \SetKwFunction{InitAggr}{initialize\_aggressor\_rows}
    \SetKwFunction{InitVictim}{initialize\_victim\_row}
    \SetKwFunction{PartRestoration}{partial\_restoration}
    \SetKwFunction{Sleep}{sleep\_until\_tREFW}
    \SetKwProg{Fn}{Function}{:}{}
    
    \tcp{$t_{RAS(Nom)}$: nominal charge restoration latency}
    \tcp{$t_{RAS(Red)}$: reduced charge restoration latency}
    \tcp{$RA_{vic}$: victim row address}
    % \tcp{$TestedRows$: The list of tested rows (\secref{subsec:methodology_dramchips})}
    \tcp{$N_{PR}$: number of consecutive partial restorations}
    \tcp{$HC$: hammer count per aggressor row}
    \tcp{$DP$: data Pattern}
    % \tcp{$TestedN_{PR}$: The list of tested $N_{PR}$(\secref{sec:rh_rep})}
    \Fn{\PartRestoration{$RA_{vic}$, $t_{RAS(Red)}$, $N_{PR}$}}{
        \tcp{perform $N_{PR}$ partial charge restorations with $t_{RAS(Red)}$}
        \For{$i = 0; \ i < N_{PR}; \ i\text{++}$}{
            ACT({$RA_{vic}$}, wait=$t_{RAS(Red)}$)\;
            PRE({wait=$t_{RP}$})\;
        }
    }
    \Fn{\FHammer{$RA_{vic}$, $DP$, $HC$, $t_{RAS(Red)}$, $N_{PR}$}}{
        \tcp{perform double-sided RH and return the bitflip count}
        \initialize($RA_{vic}$, $DP$) \tcp{initialize aggressor and victim rows}
        \PartRestoration{$RA_{vic}$, $t_{RAS(Red)}$, $N_{PR}$}\;
        \Hammer({$RA_{vic}$}, $HC$) \tcp{hammer aggressor rows}
        \Sleep{} \tcp{wait until the end of $t_{REFW}$}
        \KwRet \check($RA_{vic}$) \tcp{count the bitflips}
    }
    
    \Fn{\FMain{}}{
        \tcp{measure $N_{RH}$ for each $t_{RAS(Red)}$, $N_{PR}$, and $RA_{vic}$}
        \ForEach{$t_{RAS(Red)}$ in from $t_{RAS(Nom)}$ to $6ns$ at steps of $3ns$}{
            \ForEach{$N_{PR}$ in from $TestedN_{PR}$}{
                \ForEach{$RA_{vic}$ in $TestedRows$}{
                    \tcp{{find the worst-case data pattern (WCDP)}}
                    
                    \ForEach{$DP$ in [RS, RSI, CS, CSI, CB, CBI]}{
                        \FHammer{$RA_{vic}$, $DP$, 100K, $t_{RAS(Red)}$, $N_{PR}$}\;
                        $WCDP$ = $DP$ that causes the most bitflip\;
                    }
                    \tcp{measure $BER$ with 100K hammers}
                    $BER$ = \FHammer{$RA_{vic}$,\ $WCDP$,\ $100K$,\ $t_{RAS(Red)}$,\ $N_{PR}$}\;
                    \tcp{check for retention bitflips without hammering, return $N_{RH}=0$ if there are retention bitflips}
                    $ret\_bfs$ = \FHammer{$RA_{vic}$,\ $WCDP$,\ $0$,\ $t_{RAS(Red)}$,\ $N_{PR}$}\;
                    \If{$ret\_bfs\ >\ 0$}{
                        \Return $0$, $BER$\;
                    }
                    \tcp{measure final $N_{RH}$ using bi-section search}
                    $HC_{high} = 100K$;
                    $HC_{low} = 0$;
                    $HC_{step} = 1K$;
                    $N_{RH} = 100K$;\;
                    \While{$HC_{high} - HC_{low} > HC_{step}$}{
                        $HC_{cur} = (HC_{high} + HC_{low})/2$\;
                        $rh\_bfs$ = \FHammer{$RA_{vic}$,\ $WCDP$,\ $HC_{cur}$,\ $t_{RAS(Red)}$,\ $N_{PR}$}\;
                        $HC_{low} = (rh\_bfs\ ==\ 0)\ ?\ HC_{cur}\ :\ HC_{low}$\;
                        $HC_{high} = (rh\_bfs\ !=\ 0)\ ?\ HC_{cur}\ :\ HC_{high}$\;
                        $N_{RH} = (rh\_bfs\ ==\ 0)\ ?\ N_{RH}\ :\ HC_{cur}$\;
                    }
                    \Return $N_{RH}$, $BER$\;
                }
            }
        }
    }
}
\end{algorithm}

% \agycomment{3}{Algorithm 1 comes too late. Better to have it on the same page as this text.}
\yctcomment{8}{Double-checked the line numbers.}
\head{Tests}
\yct{3}{Alg.~\ref{alg:test_alg} describes our main test loop and helper functions.}
\yct{3}{Our main test loop (lines 12-36\agy{3}{)}
%\agy{3}{)} 
measures \gls{nrh} and \gls{ber} of each tested row for different charge restoration latencies and different numbers of restorations.}
Our RowHammer testing function (lines 6-11\agy{3}{)} uses \om{6}{the} double-sided hammering pattern~\cite{kim2014flipping, kim2020revisiting, seaborn2015exploiting, orosa2021deeper, luo2023rowpress}, where we hammer two physically adjacent (aggressor) rows to a victim row in an alternating manner. We perform double-sided {hammering} with the maximum activation rate possible within DDR4 command timing {specifications}~\cite{jedec2017ddr4} as this access pattern is \om{3}{demonstrated to be} the most effective RowHammer access pattern on DRAM chips when RowHammer mitigation mechanisms are disabled~\cite{kim2014flipping, kim2020revisiting, frigo2020trrespass, cojocar2020rowhammer, seaborn2015exploiting, orosa2021deeper, olgun2023hbm}.
% \footnote{\yct{6}{We also analyze the effect on charge restoration latency on \yct{7}{Half-Double} pattern~\cite{kogler2022half} and observe similar results\iey{6}{, as shown in the extended version of this paper~\cite{}.}}}%. Due to space limitations, we omit our Half-double pattern analysis.}}
% \agycomment{3}{Finish talking about what happens within a test before explaining which parameters you sweep}\yctcomment{3}{moved to the end of paragraph}
\yct{3}{After initializing the aggressor and victim rows \om{6}{(line 7)}, we perform \om{3}{partial charge} restoration on \yct{3}{the sandwiched victim row (i.e., the row between two aggressor rows) (line~8\agy{3}{)} \yct{6}{using \gls{trasred}} \emph{before}} we perform double-sided hammering (line~9\agy{3}{)}.
% \agycomment{3}{we do not have a motivation for number of restorations and we even did not define what it means. Does it mean the number of building restorations in the world since the big bang?}
% \agycomment{3}{I don't see how you addressed this}\yctcomment{3}{we extended the last head of motivation section.}
% The partial charge restoration function (lines 1-5\agy{3}{)} performs partial charge restoration on the sandwiched victim row for different restoration latencies and different number of restorations.\agycomment{3}{This sentence does not say much and boring to read. Quite redundant as well.}
{\yct{6}{To guarantee that reducing charge restoration latency does \emph{not} cause any failures}, we keep the victim rows unaccessed for \agy{3}{a time window as large as} \gls{trefw} (i.e.\agy{3}{,} until \agy{3}{the partially restored row would be} refreshed by periodic refresh)
(line~10\agy{3}{)}}. \yct{6}{By doing so, we} ensure that we can detect if reduced charge restoration latency causes a data retention failure. An \gls{nrh} value of 0 indicates that the victim row experiences a bitflip \emph{without} \om{6}{hammering} due to data retention failure (lines~21-24\agy{3}{)}.}
\yct{3}{To analyze the effect of partial charge restoration, we sweep the charge restoration latency and the number of consecutive charge restorations (lines 1-5).}
\yct{2}{We run all our experiments for five iterations and record the lowest (highest) observed \gls{nrh} (\gls{ber}) in our analyses similar to prior works~\cite{luo2023rowpress, olgun2023hbm, yaglikci2022hira, yaglikci2022understanding, orosa2021deeper, kim2020revisiting, lee2017design, kim2014flipping}.}
% \agycomment{3}{We should explain here separately why we care about repeated partial charge restoration and how we test it.}
% \yctcomment{3}{Do we still need to discuss it after adding it to the motivation?}

\head{{Data patterns}}
{We use six commonly used data patterns~\cite{chang2016understanding,chang2017understanding,khan2014efficacy,khan2016parbor,khan2016case,kim2020revisiting,lee2017design,mukhanov2020dstress,orosa2021deeper, kim2014flipping, liu2013experimental}: row stripe (0xFF/0x00),
checkerboard (0xAA/0x55), column stripe (0xAA/0xAA) and their inverses. Before measuring a row's \gls{nrh} \om{3}{and \gls{ber}}, we identify the worst-case data pattern (WCDP) (lines 16-19\agy{3}{)} for each row among six data patterns. We use the data pattern that causes the most bitflips to measure \gls{nrh} \om{3}{and \gls{ber}} of that row.
}


% \agycomment{3}{There is a way of making math expressions bold as well. That would be nice to have here.}
\head{Finding $\bm{N}_{\bm{RH}}$ and $\bm{BER}$}
\yct{1}{We perform a bi-section search\om{3}{~\cite{bisectionsearch}} to measure a row's \gls{nrh} (lines \param{25-32}\agy{3}{)}. The search algorithm has three parameters: $HC_{high}$, $HC_{low}$, and $HC_{step}$. \om{3}{$HC_{high}$ ($HC_{low}$) specify the upper (lower)} bound for \gls{nrh} and $HC_{step}$ determines the resolution of the \gls{nrh} measurement. In our tests,
$HC_{high}$, $HC_{low}$, and $HC_{step}$ are 100K, 0, and 1K, respectively. \yct{3}{To measure a row's \gls{ber}, we perform double-sided hammering with a hammer count of 100K and check for the bitflip \om{6}{count} (line~20\agy{3}{)}.}}
% We test all our DDR4 DRAM chips with 100K/0 hammers for $HC_{high}$/$HC_{low}$ and 1K for $HC_{step}$.}

\head{Finding physically adjacent rows}
DRAM manufacturers use internal address mapping schemes~\cite{cojocar2020rowhammer, salp} to translate \emph{logical} DRAM addresses (e.g., row, bank, column) into physical DRAM addresses (e.g., the physical location of a row). These schemes enable post-manufacturing row repair by remapping faulty rows~\cite{hassan2019crow} and organize internal DRAM structures cost-efficiently~\cite{khan2016parbor, vandegoor2002address}. Mapping schemes vary significantly across DRAM chips~\cite{barenghi2018software, cojocar2020rowhammer, horiguchi1997redundancy, itoh2013vlsi, khan2016parbor, kim2014flipping, patel2020beer, orosa2021deeper}, requiring reverse-engineering to analyze physical row organization. For each victim row, we carefully identify the two neighboring aggressor rows for double-sided RowHammer using reverse-engineering techniques described in prior works~\cite{kim2020revisiting, orosa2021deeper, luo2023rowpress}.
% DRAM manufacturers use internal address mapping schemes~\cite{cojocar2020rowhammer, salp} to translate \emph{logical} DRAM addresses (e.g., row, bank, and column) that are exposed to the memory controller into physical DRAM addresses (e.g., the physical location of a row). 
% These mapping schemes serve two main purposes: i)~enabling post-manufacturing row repair by remapping faulty rows to spare rows~\cite{hassan2019crow}, and~ii)~organizing internal DRAM structures in a cost-optimized and hierarchical manner~\cite{khan2016parbor, vandegoor2002address}. 
% The specific mapping schemes vary significantly across different DRAM chips~\cite{barenghi2018software, cojocar2020rowhammer, horiguchi1997redundancy,itoh2013vlsi,keeth2001dram,khan2016parbor, khan2017detecting,kim2014flipping,lee2017design,liu2013experimental, patel2020beer,orosa2021deeper,saroiu2022price,patel2022case}, making it necessary to reverse-engineer the physical row organization for accurate analysis.
% For every victim DRAM row that we test, we identify the two neighboring physically adjacent DRAM row addresses that the memory controller can use to access the aggressor rows in double-sided RowHammer. To do so, we carefully reverse-engineer the physical row organization using techniques described in prior works~\cite{kim2020revisiting, orosa2021deeper, luo2023rowpress}.



\head{{Temperature}}
{
We conduct all our tests at three temperature levels \SI{50}{\celsius}, \SI{65}{\celsius}, and \SI{80}{\celsius}, which is the highest possible temperature in our infrastructure that leaves a safe margin of \SI{5}{\celsius} to \SI{85}{\celsius}, where the refresh rate is doubled~\cite{jedec2017ddr4}. We report our results for \SI{80}{\celsius} unless stated otherwise.}



