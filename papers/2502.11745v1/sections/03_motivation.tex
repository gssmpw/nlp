\section{Motivation}
\label{sec:motivation}

% \yctcomment{3}{The reason we give the time spent for prev ref is that this graph shows our headroom as we only care about the time of prev ref (not the communication overhead of Hydra). Therefore, I suggest we change this section head to "Preventive refresh overhead of RowHammer....".}\agycomment{3}{This discussion should be over an email with Onur. It should not wait until the next iteration.}
\head{\yct{3}{Preventive refresh} overheads of RowHammer mitigation \om{1}{mechanisms}}
\srev{Prior works~\rowHammerDefenseScalingProblemsCitations{} already show that existing RowHammer mitigations \sql{R2.1}incur prohibitively high performance or area overheads as \gls{nrh} reduces \om{3}{with DRAM technology scaling}.} \agy{3}{This is because blocking a DRAM bank for performing a preventive refresh
% \agycomment{3}{Double-check whether preventive refresh is properly defined in Sec 2. If not, please define.}\yctcomment{3}{I defined and remove "RowHammer-preventive", we did not use anywhere that.}
might delay memory accesses and thus degrade system performance. We analyze} 
% We repeat this performance analysis with \param{five} state-of-the-art RowHammer mitigation \om{1}{mechanisms} by analyzing 
\yct{3}{the fraction of execution time \agy{3}{during which} a DRAM bank is \agy{3}{busy performing} preventive refreshes,}
% \agycomment{3}{the parenthesis did not say anything extra. I removed it}
% (i.e., the execution time spent on preventive refreshes)
% , including the more recent ones than the prior analyses. 
% We conduct these simulations 
following the methodology described in \secref{sec:eval_methodology} for \agy{3}{\param{five} state-of-the-art RowHammer mitigation \om{1}{mechanisms} and} \om{3}{six} different \gls{nrh} values \om{3}{on} \param{60} multi-programmed 4-core workload mixes.
% \agycomment{3}{I removed the randomly chosen explanation as it is already in the methodology in \secref{sec:eval_methodology}} 
% randomly chosen across benchmarks specified in \secref{sec:eval_methodology}.  
\figref{fig:performance_motivation} shows a line plot where each curve represents a different RowHammer mitigation \om{1}{mechanism}. The x-axis shows \om{7}{the} tested \gls{nrh} values and the y-axis shows
% the RowHammer mitigation \om{1}{mechanism}'s overhead in terms of 
% \agycomment{3}{I removed a part here. Does that look good?}
the fraction
% \agycomment{3}{this is fraction, figure says percentage. Why inconsistent? Make the figure fraction as well.}
of \om{3}{execution} time spent on preventive refreshes.
% \agycomment{3}{why does this have the \\om tag? isn't it your modification? Also, the fraction of execution time is repeated. It is not good.}
The shaded areas mark the minimum and maximum values across all workload mixes.
% \agycomment{3}{Onur has a comment here that is not addressed. Is this additional execution time due to preventive refreshes? Be clear}\yctcomment{3}{Thanks, added an explanation.} 
\yctcomment{7}{fixed colors}
\vspace{10pt}
\begin{figure}[ht]
\centering
\includegraphics[width=0.85\linewidth]{figures/fig3_RH_overhead.pdf}
\caption{\om{3}{Preventive refresh overhead of five RowHammer mitigation mechanisms as RowHammer vulnerability worsens}}
\label{fig:performance_motivation}
\end{figure}
% \agycomment{3}{mitigations, mitigation mechanisms, or mitigation techniques? Make your mind and be consistent}

% Graphene 64 100 ['0.78', '0.88', '0.97']
% Graphene 128 100 ['0.88', '0.95', '1.0']
% Graphene 256 100 ['0.94', '0.98', '1.0']
% Graphene 512 100 ['0.97', '0.99', '1.0']
% Graphene 1024 100 ['0.99', '1.0', '1.0']
% Graphene 2048 100 ['0.99', '1.0', '1.0']
% Hydra 64 100 ['0.13', '0.78', '0.97']
% Hydra 128 100 ['0.16', '0.84', '0.99']
% Hydra 256 100 ['0.24', '0.89', '1.0']
% Hydra 512 100 ['0.37', '0.94', '1.0']
% Hydra 1024 100 ['0.67', '0.97', '1.01']
% Hydra 2048 100 ['0.89', '0.99', '1.01']
% PARA 64 100 ['0.22', '0.49', '0.77']
% PARA 128 100 ['0.35', '0.62', '0.85']
% PARA 256 100 ['0.52', '0.75', '0.91']
% PARA 512 100 ['0.68', '0.85', '0.94']
% PARA 1024 100 ['0.8', '0.91', '0.98']
% PARA 2048 100 ['0.89', '0.95', '1.0']

\cqrev{
We make \param{four} observations from \figref{fig:performance_motivation}.
% \agycomment{3}{Onur has comments on the y-axis: Why do we focus on this metric and not overall performance overhead?
% Does it not also make sense to show overall performance overhead numbers here?
% Writing introduces overall performance overhead late.
% And the y axis metric of this figure is not precisely defined.} \yctcomment{3}{The reason why we use preventive refresh overhead rather than overall performance overhead is that we only reduce the time spent on prev refs (not Hydra's communication overhead). Basically this figure shows our headroom. I suggest we change the head of the section as "Preventive refresh overhead of RowHammer..."}
First, all tested RowHammer mitigation \om{1}{mechanisms} spend a larger fraction of their time performing preventive refreshes 
% the time spent for preventive refreshes issued by RowHammer mitigations significantly increases 
as \om{3}{\gls{nrh} reduces (i.e., DRAM chips become more vulnerable to read disturbance)}. 
% for all tested RowHammer mitigations. 
Second, RFM's, PRAC's, and PARA's \om{3}{overheads} reach up to 43.05\%, 19.19\%, and 10.95\%, respectively, in the worst-case across our tests.
\agy{3}{Third, \param{RFM} and \param{PARA} exhibit the highest time spent on preventive refreshes for all tested \gls{nrh} values larger than 32 (e.g., 19.30\% and 6.12\% of total execution time, on average across tested workload mixes at an \gls{nrh} of 64, respectively), while they introduce almost zero area overhead~\cite{kim2014flipping, jedec2020ddr5} (not shown in the figure).}
% \agycomment{3}{you dropped Onur's comment here. Be careful. I drafted and alternative. Please see the source code below for your version and see the diff.}
% \srev{Third, \param{RFM} and \param{PARA} introduce almost zero area \sql{R2.1}overhead~\cite{kim2014flipping, jedec2020ddr5} while exhibiting the highest time spent on preventive refreshes for all tested \gls{nrh} values larger than 32, reaching 19.30\% and 6.12\% of total execution time, on average across tested workload mixes at an \gls{nrh} of 64, respectively.}
%
Fourth, among the tested RowHammer mitigations, Graphene and Hydra \om{3}{spend the least} time \om{3}{on} preventive refreshes, \om{3}{e.g., only}
% \agycomment{3}{dont forget to check how it looks on the pdf}
\param{2.68\%} and \param{1.54\%} \om{3}{of total execution time} for an \gls{nrh} value of \param{32} on average across all tested workload mixes. Hydra \om{6}{wastes} the least \agy{3}{fraction of execution time} \om{6}{on} preventive refreshes\om{7}{,} but incurs significant \om{6}{system-level} slowdowns \om{7}{(not shown here; see~\secref{sec:eval_perf})} because it maintains its \om{3}{counter} metadata in DRAM and occupies \om{3}{the} memory channel to retrieve and update \om{3}{its metadata}~\cite{canpolat2024breakhammer, bostanci2024comet, olgun2024abacus}. 
%\param{Graphene} \agy{3}{spends} \om{7}{1.54\% of its execution} \agy{3}{time on performing preventive refreshes \yct{7}{at an \gls{nrh} value of \param{32}}\ieycomment{7}{at which threshold?}. Graphene achieves this}
\param{Graphene} \agy{3}{spends} \iey{6}{\agy{6}{a} higher fraction of execution time on preventive refreshes than Hydra, but incurs the lowest system-level slowdowns across all tested RowHammer mitigations (not shown here; see~\secref{sec:eval_perf}). Graphene achieves the lowest overall performance overhead}
% \om{3}{overall performance} overhead 
at the expense of increasingly large chip area overhead that reaches \iey{0}{\param{$10.38mm^2$} (\param{$4.45\%$} of the chip area of an Intel Xeon processor~\cite{wikichipcascade})
when configured with an \gls{nrh} of 32 for a \om{6}{dual-rank} system with 16 banks \om{6}{per} rank.}
With these \param{four} observations, we \yct{1}{demonstrate} that existing RowHammer mitigations incur significant \yct{3}{preventive refresh overheads} or area overheads as \gls{nrh} decreases. Therefore, we conclude that reducing the overheads of such mechanisms at low cost is critical.
}

% \agycomment{3}{we did not talk about energy in the previous part. It sort of comes out of no where}
% \yctcomment{3}{We do not use "RowHammer-preventive" anywhere, so I removed it.}
\head{Reducing the time \agy{0}{and energy} spent for preventive refreshes}\yctcomment{3}{Fig 3 provides the time cost with the nominal tRAS, here we will provide the cost of preventive refs with reduced tRAS.}
Prior works already show that DRAM timing constraints include large guardbands\om{6}{~\cite{lee2015adaptive, liu2013experimental, chang2016understanding, chang2017understanding, chang2017understandingphd, kim2018solar, yaglikci2022understanding, mathew2017using, lee2017design, chandrasekar2014exploiting, das2018vrldram}}\yctcomment{6}{added DATE2014, SIGMETRICS2017, VRL-DRAM}\yctcomment{7}{fixed refs}. To reduce the performance overhead of RowHammer mitigation \om{1}{mechanisms}, we explore the idea of reducing the time spent on \om{3}{each} preventive refresh.
To this end, we 
experimentally evaluate the effect of reducing \gls{tras}
\agy{3}{on the} i)~reliability of real DDR4 DRAM chips using the methodology described in \agy{3}{\secref{sec:methodology_dramchips}}, and ii)~\agy{3}{time and energy costs} of preventive refreshes.
% \agycomment{3}{was time cost not in Fig3? Onur asked this. Why do you not answer?} 
% \agycomment{3}{Why refer to Sec 4 while you can refer to 4.2?}
% reduce the timing constraint of the charge restoration process (\gls{tras}\om{3}{; see \secref{sec:methodology}}), the most time-consuming operation during a row refresh. We 
% \agycomment{3}{I chopped a redundant sentence here. Please check the source and we can discuss.} \yctcomment{3}{makes sense}
% \agycomment{3}{tRAS was supposed to be defined in the background. Why do we have a gls definition here? Check the pdf.} \yctcomment{fixed it}

% \yctcomment{3}{I will try to improve here further.}
% \agycomment{3}{Onur asked: why estimated? Where is the answer? We shouldn't say that this is estimated maybe or explain to Onur why it is estimated but not measured} 
\figref{fig:m_plot} shows the results of our motivational analysis for two representative DDR4 DRAM modules \om{1}{one from \agy{3}{Mfrs.~H and~S} \om{3}{(see \secref{sec:methodology_dramchips})}}. We reduce the charge restoration latency from right to left on the x-axis. $x=1.0$ marks the nominal \gls{tras} value \om{3}{(i.e., $33ns$)}. The y-axis shows the values of five different curves normalized to their respective values at the nominal \gls{tras} value, three of which are \om{3}{in} the top two subplots\iey{7}{,} and the remaining two are in the bottom two subplots. The enumerated five curves show \yct{3}{the following\om{6}{:}} 
1)~\om{3}{\emph{Prev\om{6}{entive} Refresh Latency}:} the time spent to perform a single preventive refresh \yct{3}{(solid \om{6}{black} line in top subplots)}. \yct{3}{DRAM standards~\dramStandardCitations{} do \emph{not} report how the preventive refresh latency is calculated. \om{6}{We} compute it as the sum of \gls{tras} and $t_{RP}$ timing parameters\om{6}{, since} a preventive refresh is functionally equivalent to opening and closing a DRAM row.}
% 1)~\om{3}{\emph{Prev. Refresh Latency}:} estimated time spent to perform a single preventive refresh, \om{3}{computed \agy{3}{as} the sum of \gls{tras} and $t_{RP}$ timing parameters}, 
2)~\om{3}{\emph{RowHammer Threshold}:} the minimum activation count needed to induce the first RowHammer bitflip, i.e., \gls{nrh}, observed on real DRAM chips~\yct{0}{when reduced charge restoration latency is used} \yct{3}{(dashed \om{6}{red} line in top subplots)}.
3)~\om{3}{\emph{Prev\om{6}{entive} Refresh Count}:} the number of preventive refreshes, \agy{3}{computed as 1/\gls{nrh} based on the insight that a preventive refresh is performed every \gls{nrh} activations \yct{3}{(dotted \om{6}{green} line in top subplots)}.}
4)~\om{3}{\emph{Total Time Cost}:} the time spent for all preventive refreshes as \agy{3}{the} product of \yct{7}{Preventive Refresh Count} and \yct{7}{Preventive Refresh Latency} \yct{3}{(solid purple line in bottom subplots)}.
% \agycomment{3}{There are two different dashed orange lines in the bottom-left subplot}\yctcomment{3}{fixed it}
5)~\om{3}{\emph{Total Energy Cost}:} energy consumption \om{6}{of} all preventive \agy{20}{refreshes} as the product of \yct{7}{Preventive Refresh Count} and the total time spent doing so \yct{3}{(dotted \om{6}{yellow} line in bottom subplots)}.
% \agycomment{3}{Onur asked: why estimated? How do you address it?}\yctcomment{3}{I think how it is computed explains why it is estimated.}
% \agycomment{3}{I did not check everything in this paragraph but found some silently dropped comments. Please double check and make sure we address all comments.}     
% \agycomment{3}{Let's make some of these curves dashed and dotted. Otherwise, it is very hard to match.} \yctcomment{3}{I changed it but tbh the previous figure was more beautiful.}\agycomment{3}{We cannot optimize for beauty only, though :(}\yctcomment{3}{art is dead}\agycomment{3}{science survives}

\begin{figure}[ht]
\centering
\includegraphics[width=0.92\linewidth]{figures/fig4_mot_analysis.pdf}
\caption{\srev{Effect of reducing charge restoration latency on \sql{R4}the time \om{3}{and energy spent on} preventive refreshes}}
\label{fig:m_plot}
\end{figure}

% \agycomment{3}{These curves }
% \agycomment{3}{should this not be reduces?} 
% \agycomment{3}{why it? you put the subject before i) already}
From \figref{fig:m_plot}, we make \param{four} observations. 
\yct{3}{First, \om{7}{Preventive Refresh Latency} reduces proportionally as charge restoration latency decreases.}
\yct{3}{Second, \om{6}{reducing the} charge restoration latency i)~\om{7}{reduces RowHammer Threshold} (\gls{nrh}) by less than \om{6}{only} $5\%$ \yct{6}{when} \gls{tras} is reduced by $64\%$ and $36\%$} for \om{1}{the \om{6}{two} \agy{3}{modules} from \agy{3}{Mfrs.~H and~S}}, respectively (marked with dashed blue lines), and ii)~\om{6}{reduces} \gls{nrh} \om{6}{much} more significantly if \gls{tras} is reduced \om{7}{more} than these values. 
% \agycomment{3}{is this while phrase really necessary?}
\yct{3}{Third, \om{6}{Total Time Cost} \om{6}{of preventive refreshes}
% time spent for all preventive refreshes (i.e., total time cost)
\agy{3}{i)~reduces} with reducing \gls{tras} until an inflection point (marked with a dark purple circle \om{6}{in \figref{fig:m_plot} (bottom)} at 36\% and 45\% of the nominal \gls{tras} value for modules from \agy{3}{Mfrs.~H and~S}, respectively)\om{6}{,} \agy{3}{and}
% ii)~reducing \gls{tras} beyond these inflection points the total time costs.
\agy{3}{ii)~increases beyond the respective inflection points.} 
% The reasoning behind this is that 
\agy{3}{This is because} the \om{7}{higher Preventive Refresh Count} \om{6}{at lower \gls{tras}} overwhelms the reduction in \om{7}{Preventive Refresh Latency}. Hence, the lowest \om{7}{Total Time Costs} are observed at these inflection points with a \om{7}{Total Time Cost} reduction of $43\%$ and $28\%$ for the \om{6}{two} \agy{3}{modules} from \agy{3}{Mfrs.~H and~S}, respectively.} 
\yct{3}{Fourth, \om{6}{Total Energy Cost \om{6}{of preventive refreshes} also has \om{6}{similar} inflection points}
% the energy consumption of preventive refreshes (i.e., total energy cost) 
% follows a similar curve to the curve of their total time costs, where the inflection points 
(marked with a dark \om{6}{yellow} circle \om{6}{in \figref{fig:m_plot} (bottom)})
% appear
at $36\%$ and $64\%$ of the nominal \gls{tras} value where the total energy cost can be reduced by $40\%$ and $19\%$ for the \agy{3}{modules} from \agy{3}{Mfrs.~H and~S}, respectively.}\yctcomment{7}{yes they are consistent with the figure}
Based on this motivational analysis, we conclude that reducing \agy{3}{charge} restoration latency is a promising approach to reduce the performance and energy overheads of RowHammer mitigations. 
% {However, to reliably reduce restoration latency, it is crucial to understand the effects of restoration latency on RowHammer vulnerability.}


\head{{Characterizing the Impact of {Charge} Restoration Latency}}
{To reliably reduce the {charge} restoration latency of preventive refreshes, it is critical to understand the limits of a DRAM chip. % and operate the DRAM chip accordingly.
\yct{3}{Therefore, it is \om{6}{important} to investigate i)~how RowHammer \om{6}{T}hreshold and the number of RowHammer bitflips
% \yctcomment{3}{we did not explain ber until here, should we explain it here? Actually the explanation is just Bit-Error-Rate} 
change with reduced charge restoration latency, ii)~whether \agy{3}{using reduced charge restoration latency for many consecutive \yct{3}{preventive} refreshes further worsens RowHammer threshold or number of RowHammer bitflips},
% it is safe to use the reduced charge restoration latency multiple times as multiple partial restorations might lead bitflips
and iii)~how the data retention time of a DRAM row changes with the reduced charge restoration latency.}
Although many prior works~\understandingRowHammerAllCitations{} study \om{7}{various aspects of} the \om{3}{read disturbance} characteristics of DRAM (e.g., \om{3}{access and data patterns}, voltage, temperature), \emph{no} prior work characterizes the effect of \agy{3}{charge} restoration latency on RowHammer.
}


\yct{7}{In this paper, we conduct a rigorous experimental characterization study to understand how reducing charge restoration latency affects RowHammer vulnerability in real DDR4 DRAM chips, along with its effects on system performance and energy efficiency.}
