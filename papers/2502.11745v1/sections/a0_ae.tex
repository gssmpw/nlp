% LaTeX template for Artifact Evaluation V20240722
%
% Prepared by Grigori Fursin with contributions from Bruce Childers,
%   Michael Heroux, Michela Taufer and other colleagues.
%
% See examples of this Artifact Appendix in
%  * ASPLOS'24 "PyTorch 2: Faster Machine Learning Through Dynamic Python Bytecode Transformation and Graph Compilation": 
%      https://dl.acm.org/doi/10.1145/3620665.3640366
%  * SC'17 paper: https://dl.acm.org/citation.cfm?id=3126948
%  * CGO'17 paper: https://www.cl.cam.ac.uk/~sa614/papers/Software-Prefetching-CGO2017.pdf
%  * ACM ReQuEST-ASPLOS'18 paper: https://dl.acm.org/citation.cfm?doid=3229762.3229763
%
% (C)opyright 2014-2024 cTuning.org
%
% CC BY 4.0 license
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% When adding this appendix to your paper, 
% please remove above part
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\appendix
\section{Artifact Appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Abstract}

Our artifact contains the data, source code, and scripts needed to reproduce our results.
We provide: 
1)~the scripts to parse and plot our DRAM Bender results, 
2)~the source code of our simulation infrastructure based on Ramulator 2.0, 
3)~all evaluated memory access traces and all major evaluation results, and
4)~the data and scripts to reproduce all key figures in the paper.
We identify the following as key results:
\begin{itemize}
    \item Effect of partial charge restoration on RowHammer vulnerability in terms of RowHammer \gls{nrh} and \gls{ber}
    \item Effect of repeated partial charge restoration on RowHammer vulnerability in terms of RowHammer \gls{nrh}
    \item \X's impact on system performance
    \item \X's impact on DRAM energy consumption
    % \item \X's impact on the total time spent on preventive refresh operations
\end{itemize}


\subsection{Artifact Check-list (meta-information)}
\begin{table}[ht]
\centering
\footnotesize
\label{table:ae_metainfo}
\begin{tabular}{lm{4.8cm}}
\textbf{Parameter} & \textbf{Value} \\ \hline
Program & C++ programs\newline 
            Python3 scripts\newline
            Shell scripts \\ \hline
Compilation & C++ compiler with c++20 features \\ \hline
Run-time environment & Ubuntu 20.04 (or similar) Linux\newline
                        C++20 build toolchain (tested with GCC 10)\newline
                        Python 3.10+\newline
                        Git \\ \hline
Metrics & RowHammer \gls{nrh} and \gls{ber}\newline
            Instruction-per-cycles (IPC)\newline
            Weighted speedup\newline
            DRAM energy \\ \hline
Experiment customization & Possible. See \secref{sec:exp_custom} \\ \hline
Disk space requirement & $\approx$ 30 GiB \\ \hline
Experiment completion time & $\approx$ 2 days (on a compute cluster with 250 cores) \\ \hline
Publicly available? & DRAM Bender results (\url{https://zenodo.org/records/14343791})\newline
                        Benchmarks (\url{https://zenodo.org/records/14345886})\newline
                        Zenodo (\url{https://zenodo.org/records/14878588})\newline
                        GitHub (\url{https://github.com/CMU-SAFARI/PaCRAM}) \\ \hline
Code licences & MIT \\ \hline
\end{tabular}
\end{table}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Description}
 
\noindent\emph{We highly recommend using Slurm with a cluster that can run experiments in bulk.}

\subsubsection{How to access}

~Source code and scripts are available at \url{https://github.com/CMU-SAFARI/PaCRAM}.

\subsubsection{Hardware dependencies}

~We recommend using a PC with 32 GiB of main memory.
Approximately 30 GiB of disk space is needed to store intermediate and final evaluation results.

\subsubsection{Software dependencies}

\begin{itemize}
    \item GNU Make, CMake 3.20+
    \item C++20 build toolchain (tested with GCC 10)
    \item Python 3.9+ (tested with Python 3.10.6)
    \item pip packages: matplotlib, seaborn, pandas, pyyaml
    \item Ubuntu 22.04
    \item (Optional) Slurm 20+
\end{itemize}

\subsubsection{Benchmarks}

~We use workload memory traces collected from SPEC2006, SPEC2017, TPC, MediaBench, and YCSB benchmark suites.
These traces are available at \url{https://zenodo.org/records/14345886}.
Install scripts will download and extract the traces.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Installation}

\lstset{
    backgroundcolor=\color{gray!20}, % Set the background color
    basicstyle=\ttfamily\bfseries\footnotesize,
    columns=fullflexible,
    frame=single,
    breaklines=true,
    postbreak=\mbox{\textcolor{red}{$\hookrightarrow$}\space},
    showstringspaces=false,
    numbersep=5pt,
    xleftmargin=0pt,
    numbers=none,
    keywordstyle=\color{black},  % Set keyword color to black
    identifierstyle=\color{black},  % Set identifier color to black
    commentstyle=\color{black},  % Set comment color to black
    stringstyle=\color{black}  % Set string color to black
}

The following steps will download and prepare the repository for the main experiments:
\begin{enumerate}
    \item Clone the git repository.
    \begin{lstlisting}[language=bash]
$ git clone https://github.com/CMU-SAFARI/PaCRAM
    \end{lstlisting}
    \item Install Python dependencies, compile Ramulator 2.0, download DRAM Bender experiment results, and download workload traces.
    \begin{lstlisting}[language=bash]
$ ./setup_all.sh
    \end{lstlisting}
\end{enumerate}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Evaluation and Expected Results}
We categorize our evaluation into two parts: i) Off-the-shelf DDR4 DRAM characterization and ii) System evaluation of \X{}.

\subsubsection{Off-the-shelf DDR4 DRAM characterization}
~We used DRAM Bender~\cite{safari-drambender} to characterize real DDR4 DRAM chips.
The data we gather from \nCHIPS{} DDR4 DRAM chips are publicly available at \url{https://zenodo.org/records/14343791}. We make the following claims.

\head{Claim 1.1 (C1.1)} Charge restoration latency (\gls{tras}) can be reduced 1) with no effect on or 2) at the cost of increasing the RowHammer vulnerability (i.e., lower RowHammer \gls{nrh} and higher RowHammer \gls{ber}), while reducing charge restoration latency beyond a safe minimum value can cause data retention failures. This property is proven by measuring the RowHammer vulnerability of real DDR4 DRAM chips with reduced charge restoration latency as described in \secref{subsec:testing_methodology} whose results are illustrated in Figs.~\ref{fig:nRH_single_pcr} and~\ref{fig:ber_single_pcr}. 

\head{Claim 1.2 (C1.2)} It is not safe to reduce charge restoration latency (\gls{tras}) for all refresh operations as performing partial charge restoration many times can cause data retention failures. This property is proven by measuring the RowHammer vulnerability of real DDR4 DRAM chips with repeated reduced charge restoration latency as described in \secref{subsec:testing_methodology} whose results are illustrated in \figref{fig:nrh_multiple_pcr}. 

To parse the results and plot the key figures of our experimental results:
\begin{enumerate}
    \item Parse and plot the results for RowHammer \gls{nrh} and \gls{ber}.
    \begin{lstlisting}[language=bash]
$ ./plot_db_figures.sh
(or ./plot_db_figures_slurm.sh if Slurm is available)
\end{lstlisting}
\end{enumerate}

\subsubsection{System evaluation of \X{}}
~We used Ramulator 2.0~\cite{ramulator2github} to demonstrate the potential benefits of \X{} on system performance and energy efficiency. We make the following claims.

\head{Claim 2.1 (C2.1)} \X{} significantly improves system performance for both single-core and multi-programmed workloads. This property is proven by evaluating system performance of \X{} when used with five state-of-the-art RowHammer mitigation mechanisms as described in \secref{sec:eval_methodology} whose results are illustrated in Figs.~\ref{fig:lrr_analysis} and~\ref{fig:perf_imp}.

% \head{Claim 2.2 (C2.2)} \X{} reduces the total time spent on preventive refresh operation. This property is proven by measuring the total time spent on preventive refresh operations of \X{} with five state-of-the-art RowHammer mitigations as described in \secref{sec:evaluation} whose results are illustrated in \figref{fig:ref_time}.

\head{Claim 2.2 (C2.2)} \X{} significantly improves energy efficiency of the system. This property is proven by evaluating DRAM energy consumption of \X{} when used with five state-of-the-art RowHammer mitigation mechanisms as described in \secref{sec:eval_methodology} whose results are illustrated in \figref{fig:edp}.


To run simulations, parse the results, and plot the key figures of \X's evaluation:
\begin{enumerate}
    \item Prepare Ramulator 2.0 simulation warmup checkpoints.
    \begin{lstlisting}[language=bash]
$ ./prepare_warmups.sh
(or ./prepare_warmups_slurm.sh if Slurm is available)
    \end{lstlisting}
    \item Wait for the warmup runs to end. The following displays the status of the warmup runs. You can restart failed runs simply by rerunning step 1.
    \begin{lstlisting}[language=bash]
$ python3 check_warmup_status.py
    \end{lstlisting}
    \item Launch Ramulator 2.0 simulation runs.
    \begin{lstlisting}[language=bash]
$ ./run_ramulator_all.sh
(or ./run_ramulator_all_slurm.sh if Slurm is available)
    \end{lstlisting}
    \item Wait for the simulations to end. The following displays the status of the runs. You can restart failed runs simply by rerunning step 3.
    \begin{lstlisting}[language=bash]
$ python3 check_run_status.py
    \end{lstlisting}
    \item Parse simulation results and collect statistics.
    \begin{lstlisting}[language=bash]
$ ./parse_ram_results.sh
    \end{lstlisting}
    \item Generate all figures that support C2.1 and C2.2.
    \begin{lstlisting}[language=bash]
$ ./plot_ram_figures.sh
    \end{lstlisting}
\end{enumerate}

\subsection{Experiment Customization}
\label{sec:exp_custom}
Our scripts provide easy configuration of the 1)~evaluated RowHammer mitigation mechanisms, 2)~tested RowHammer thresholds, 3)~preventive refresh latency, 4)~periodic refresh latency, and 5)~simulated workload combinations. The run parameters are configurable in \mbox{\texttt{Ram\_scripts/utils\_runs.py}} with 1)~\mbox{\textit{MITIGATION\_LIST}} and 2)~\mbox{\textit{NRH\_VALUES}}. 3)~The preventive refresh latency and 4)~periodic refresh latency can be configured using \mbox{\texttt{latency\_factor\_vrr}} and \mbox{\texttt{latency\_factor\_rfc}} parameters in a configuration file, respectively. 5)~Simulated workload combinations can be updated in \mbox{\texttt{{Ram\_scripts/mixes\_multicore.txt}}}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Methodology}

Submission, reviewing, and badging methodology:\yctcomment{8}{I will fix this margin issue.}

\begin{itemize}
  \item \url{https://www.acm.org/publications/policies/artifact-review-and-badging-current}
  \item \url{https://cTuning.org/ae}
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% When adding this appendix to your paper, 
% please remove below part
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%





% \section{Execution Time Spent on Preventive Refreshes}
% \agycomment{4}{This is also a candidate to move to the appendix. Especially because, it only provides details but nothing new AND consumes lots of space due to 2-col figure.}
% % \head{The execution time spent on preventive refreshes}
% \yct{1}{To understand the reasoning behind \X's performance improvement, we analyze the \yct{10}{execution time spent on preventive refreshes (i.e., where a DRAM bank is unavailable due to preventive refreshes)}. \figref{fig:ref_time} demonstrates the \yct{10}{total time spent on preventive refreshes for singlecore (top subplots) and multi-programmed workloads (bottom subplots)}. The x-axis shows six different \gls{nrh} values and the y-axis shows the \yct{10}{execution time spent on} preventive refreshes normalized to \yct{4}{their values}
% % execution time spent on preventive refreshes 
% when mitigation mechanisms without \X{} are configured \yct{20}{with an \gls{nrh} of 1K}.}\agycomment{4}{these texts turn to tongue twisters. Instead you can say something like: execution time spent on preventive refreshes normalized to that when ...}\yctcomment{4}{yeah, you are right}

% \begin{figure}[ht]
% \centering
% \includegraphics[width=1\linewidth]{figures/fig17_pref_time.pdf}
% \caption{\srev{Total time spent on preventive \sql{R4}refreshes}}
% \label{fig:ref_time}
% \end{figure}

% \yct{1}{We make \param{three} observations from \figref{fig:ref_time}. 
% \yct{10}{First, the execution time spent on preventive refreshes significantly increases as \gls{nrh} decreases. For example, the execution time spent on preventive refreshes for Hydra increases by \yct{20}{$144\times$} when \gls{nrh} is decreased from \yct{20}{$1K$ to $32$}.
% Second, both \Xh{} and \Xs{} significantly reduce the time spent on preventive refresh for RFM and PARA in all configurations. {For example, \Xh{} (\Xs{} reduces the execution time spent on preventive refreshes of PARA by \yct{20}{$34.12\%$ ($10.70\%$)} on average across all \gls{nrh} values}.
% Third, \Xs{} spends more time on refreshes than \Xh{}.}
% First, the majority of preventive refreshes use reduced restoration latency. For example, for \gls{nrh} of 64, \param{95.7\%} of all preventive refreshes use reduced restoration latency\{, on average}.
% \agycomment{1}{quantify} 
% Second, \emph{no}
% \agycomment{1}{emph all negations: e.g., no, none, not...}
% mitigation mechanism uses nominal charge restoration latency for higher \gls{nrh} as \gls{tfr} is larger than \gls{trefw} for higher \gls{nrh} values\agy{1}{. This is because} \X{} does \emph{not} need to use \agy{1}{the} nominal \agy{1}{ restoration} latency \agy{1}{for preventive refreshes as}
% to restore the charge level of the rows since 
% periodic refresh\agy{1}{s already fully} restore \agy{1}{victim rows' charges} before the \agy{1}{victim rows' partial charge restoration count reaches \gls{thpcr}.}
% y can receive \gls{thpcr} preventive refreshes with reduced latency). 
% Third, the number of preventive refreshes using reduced latency decreases with decreasing \gls{nrh} since \X{} sets the bits in \gls{fr} more frequently for low \gls{nrh} values, causing more preventive refreshes using nominal latency. 
% Based on these observations, we derive \takeref{take:time_ref}.
% %\agycomment{1}{We need to tie this back to the energy-related motivation in Sec 3. Assume that the energy spent for a refresh  is proportional to the latency of the refresh . So, as most of these  perform partial charge restoration instead of full, they save energy. Report the number.}

% \takeaway{\X{} significantly reduces the execution time spent on preventive refreshes.\label{take:time_ref}}


















