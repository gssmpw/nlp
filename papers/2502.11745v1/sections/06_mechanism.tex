\section{\yct{4}{\X{}}}
\label{sec:mechanism}
\yct{20}{To demonstrate the potential benefits of our experimental observations, \om{1}{we propose a new memory controller-based mechanism, \emph{\Xlong{} (\X{})}}. \X{} \yct{4}{works with an existing RowHammer mitigation mechanism and} leverages our experimental observations to safely reduce the \agy{4}{latency of preventive refreshes} that the existing mitigation \agy{4}{mechanism} perform\om{7}{s}. \srev{By doing so, \X{} 
% reduces the performance and energy overheads of RowHammer mitigation mechanisms with negligible additional area overhead and 
introduces a novel perspective \om{1}{into} addressing RowHammer vulnerability at low cost.}}


\subsection{Overview of \X{}}
\label{sec:mech_overview}
% \agycomment{4}{This subsection title can be something more general than the implementation. You actually explain how it works rather than how it is implemented.}\yctcomment{4}{can we remove the subsection title?}
\yct{4}{\figref{fig:pacram} illustrates \om{5}{a} high-level overview of \X{}.}
\yct{4}{When a DRAM row is activated~\circled{1}, \X{} and the existing RowHammer mitigation mechanism
\om{5}{are} provided with the activated row address.}
The \om{5}{mitigation} mechanism decides whether to perform a preventive refresh
% . The trigger algorithm of the \om{5}{mitigation} mechanism uses the reduced \gls{nrh} configured by \X{} 
and issues a preventive refresh if it detects a potential aggressor \om{5}{row}~\circled{2}.
% If the trigger algorithm of the mechanism detects a potential RowHammer attack on the activated row, it does \emph{not} issue a preventive refresh and sends the row address of the potential aggressor to \X{}~\circled{2}. 
\yct{7}{Simultaneously, \X{} determines whether preventive refresh latency can be reduced and provides \agy{7}{the memory controller with reduced or nominal preventive refresh latency~\circled{3}.}
% \agycomment{7}{provide X with Y is a standard expression.}\yctcomment{7}{thanks}
% the preventive refresh latency (i.e., reduced or nominal latency) to the memory request scheduler~\circled{3}.
\agy{7}{The memory request scheduler schedules a preventive refresh (generated by the existing mitigation mechanism) using the preventive refresh latency (determined by \X{})~\circled{4}.}
% \agycomment{7}{Is this what you meant?}\yctcomment{7}{exactly}
}
% \yct{7}{When the memory controller\agy{7}{controller or request scheduler?} receives both \agy{7}{1)}~a preventive refresh from the existing mitigation mechanism and \agy{7}{2)~the latency that needs to be used with the} preventive refresh from \X{}, it performs a preventive refresh with the provided latency on the potential victim rows~\circled{4}.}}
% \yctcomment{7}{I am thinking to fix here.} 
% If the corresponding bit in \gls{fr} is \emph{logic-1} (i.e., the victim rows of the corresponding row are \emph{not} fully restored), \X{} provides the nominal refresh latency and writes \emph{logic-0} to the corresponding bit in \gls{fr}. If the corresponding bit in \gls{fr} is \emph{logic-0} (i.e., the victim rows of the corresponding row are fully restored), \X{} provides reduced latency and the memory controller performs a preventive refresh using the reduced refresh latency to perform partial charge restoration on the victim rows.}

\begin{figure}[ht]
\centering
\includegraphics[width=0.9\linewidth]{figures/fig15_pacram.pdf}
\caption{\yct{4}{Overview of \X{}}}
\label{fig:pacram}
\end{figure}




% by exploiting partial charge restoration.
% \agycomment{4}{Previous version was suggesting that the mitigation mechanisms frequently perform the latency, which does not make sense.}
% We propose a new memory controller-based mechanism, \agy{1}{\Xlong{} (\X{})}. The goal of \X{} is to reduce the performance overhead of the existing preventive refresh-based RowHammer mitigation mechanisms. 
% \X{} achieves this goal by exploiting partial charge restoration\agy{1}{.}\agycomment{1}{I removed i.e. because it was confusing more than explaining.} 
% (i.e., \X{} utilizes the sweet spot discussed in \secref{sec:motivation}).
% \subsection{Overview}
% \label{sec:mech_overview}
% \agycomment{4}{Given that you have an overview below, this part should be very brief and high level. Avoid redundancies with the overview. Maybe we should merge this paragraph with the overview and get rid of the subsection title: Overview. You can save some space and it can flow better by doing so}\yctcomment{4}{makes sense, drafted}
\subsection{Reducing Preventive Refresh Latency}
\label{sec:mech_reducing}

% \yct{7}{\X{} leverages our experimental observations to safely reduce the preventive refresh latency of an existing mitigation mechanism.}
% \agycomment{7}{The first sentence was just redundant. I removed it.}\yctcomment{7}{I just added to enter to the section but okay.}
% \agy{7}{To safely reduce pr}
\yct{7}{\X{} uses two preventive refresh latencies: i)~\emph{nominal latency} \agy{7}{for full charge restoration}
% to fully restore the cells' charge\agycomment{7}{VRL-DRAM should have a better way of saying this. Maybe just: \emph{nominal latency} for full charge restoration} 
and ii)~\emph{reduced latency} \agy{7}{for partial charge restoration}.\footnote{\om{8}{\X{} does \emph{not} affect the latency of periodic refreshes.\label{fn:onlyprev}}}}\yctcomment{8}{added the footnote here and refer it on the evaluation}
% to perform partial charge restoration on the victim rows.}
% \X{} \yct{20}{reduces} the latency of \agy{1}{preventive} refreshes \om{1}{\agy{4}{(i.e., performs} partial charge restoration on victim rows)} \agy{4}{to reduce the performance \yct{4}{and energy} overheads of existing RowHammer mitigation mechanisms}. 
\agy{7}{To safely perform partial charge restoration, \X{} overcomes two challenges.}
\agy{4}{First, reducing preventive refresh latency can reduce the row's \gls{nrh} (}\takeref{take:nrh_cr}\agy{4}{).} 
% \iql{IQE2}shows that the RowHammer vulnerability of a DRAM module can get worse (i.e., a decrease in \gls{nrh}) \om{1}{as the restoration latency is reduced}.
% To compensate for the \gls{nrh} reduction, 
\agy{7}{To address this challenge,}
\X{} configures the existing RowHammer mitigation mechanism with \om{8}{a} reduced \gls{nrh}, \om{5}{based on experimental characterization of the DRAM chips that are being controlled.}
\yct{7}{Second, repeated consecutive partial charge \agy{7}{restoration} might cause failures (\takeref{take:rh_rep}). \agy{7}{To address this challenge,}}
\yct{7}{\X{} limits the number of consecutive partial charge restorations.}
\agy{7}{To this end, \X{} assigns each DRAM row \om{8}{into one} of two states: i)~$F$: the row has to be refreshed using \emph{full} charge restoration and ii)~$P$:~the row can be refreshed using \emph{partial} charge restoration. Initially, all rows are in the $F$-state 
% (e.g., they need to be refreshed using full charge restoration latency)
and \X{} periodically pulls each row's state to $F$.
% ; so that each row is periodically forced to be refreshed using \emph{full} charge restoration.
When a row is refreshed using \emph{full} charge restoration, \X{} switches the row's state to $P$, so that future \yct{7}{preventive} refreshes can be performed using \emph{partial} charge restoration.
% \X{} maintains the state of each row using 1 bit in a bit vector called \gls{fr}. 
The \om{8}{time} interval \om{8}{for} resetting rows to $F$-state is the smallest time window in which the maximum number of refreshes with partial charge restoration can be safely performed (\secref{sec:mech_implementation}).}
\yct{8}{By doing so, \X{} performs full charge restoration for the first preventive refresh targeting a DRAM row and partial charge restoration for the rest of the preventive refreshes until the row's state is periodically reset into $F$.}

\head{\agy{7}{Security}}
\yct{8}{\X{} safely reduces charge restoration latency of preventive refreshes by applying two modifications to the existing RowHammer mitigation mechanism, based on experimental characterization data}: i)~reducing \gls{nrh} and ii)~limiting the maximum number of consecutive refreshes using partial charge restoration. Therefore, \X{} guarantees that the existing RowHammer mitigation mechanism is correctly configured based on the DRAM chip's vulnerability level. An existing RowHammer mitigation mechanism's security against DRAM read disturbance-based exploits is identical to that of the mechanism integrated with \X{}.

% \agycomment{7}{We can draw a state machine around here to make it easier to understand}\yctcomment{7}{make sense if we have space}

% \agy{7}{To ensure this limit, \X{} uses two parameters: 1)~\gls{thpcr} and 2)~\gls{tfr}, where a maximum consecutive partial charge restoration count of \gls{thpcr} times within a \gls{tfr} time window.}
% % \yct{7}{To do so, \X{} uses a threshold value, defined as \gls{thpcr}, and a time period, defined as \gls{tfr}. 
% \gls{tfr} represents the minimum time interval for a row to receive \gls{thpcr} consecutive partial charge restorations. 
% \X{} uses the nominal latency for the first preventive refresh for each row within a \gls{tfr} to perform full charge restoration and reduced latency for the rest of the preventive refreshes to perform partial charge restoration.
% By doing so, \X{} guarantees to perform one full charge restoration before a row can receive \gls{thpcr} partial charge restorations.


\subsection{\agy{7}{Detailed} Implementation \agy{7}{and Configuration}}
\label{sec:mech_implementation}


\head{\agy{7}{Full charge restoration interval ($\bm{\tfr{}}$)}}
\agy{7}{To ensure robust execution, we calculate the smallest time interval at which a DRAM row should be refreshed using full charge restoration. We assume the worst case, where a DRAM row is hammered as frequently as possible (i.e., activated every $t_{RC}$).
% the RowHammer mitigation mechanism performs a preventive refresh after every \gls{nrh} row activations.\yctcomment{7}{not all mechs do that} 
\yct{8}{The latency of a preventive refresh that performs partial charge restoration is computed as the sum of the reduced charge restoration latency and \iey{8}{the nominal} precharge latency (\gls{trasred} + \gls{trp}).} \agy{7}{The RowHammer mitigation mechanism performs a preventive refresh \yct{7}{after \gls{nrh} row activations}.} Therefore, 
\agy{7}{the smallest interval of such refreshes is the cumulative latency of performing i)~\gls{nrh} activations ($N_{RH} \times t_{RC}$) and ii)~the preventive refresh (\gls{trasred} + \gls{trp}), resulting in (\gls{nrh}$t_{RC}$ + \gls{trasred} + \gls{trp}).} 
From experimental characterization data (\om{8}{\figref{fig:nrh_ext_pcr}}), we obtain \gls{thpcr}.
% \agycomment{7}{fill in}
% a row can be safely refreshed using partial charge restoration for  times consecutively. 
The smallest time window that can contain \gls{thpcr} of such preventive refreshes is $\thpcr{} (\nrh{}\trc{} + \trasred{} + \trp{})$, which we denote as the \gls{tfr}.}\footnote{\yct{0}{If \gls{tfr} is larger than \gls{trefw}, \X{} uses the reduced charge restoration latency for \emph{all} preventive refreshes \om{5}{since} periodic refresh performs full charge restoration before a row can \om{5}{receive} \gls{thpcr} partial charge restorations.}}
\agy{7}{For example, the tested module S6 exhibits the \gls{nrh} and \gls{thpcr} values of 3.9K and 2K, respectively, \yct{7}{at $t_{RAS(Red)} = 0.36t_{RAS}$} and thus it requires rows to be refreshed with full charge restoration at an interval of \param{$374ms$}}.
% \agycomment{7}{fill in}
% \agycomment{7}{put all these three parameter values for each row in the large table in the appendix.}
% By doing so, \X{} guarantees that a row does \emph{not} receive more than \gls{thpcr} consecutive partial charge restorations and the \gls{nrh} of the DRAM chip does \emph{not} go beyond the configured value \yct{7}{provided by \X{}.}
% \agycomment{7}{please fix and beautify this part all glossaries should be defined earlier (if possible, in the background)}
% \agy{7}{Based on our experimental characterization data, }\yct{7}{}
% \agycomment{7}{give some example numbers}\yctcomment{7}{I will give the example to the configuring \X{} part in eval.}
% \yct{7}{To address these challenges at low cost,
% \agy{7}{To maintain each row's state at low cost, \X{} implements a bit vector, called \gls{fr}, that stores a single bit for each row in the DRAM module. Each bit in \gls{fr} indicates whether a row is refreshed using nominal latency (i.e., fully restored) within a \gls{tfr}.
% \emph{logic-1} indicates the corresponding row is refreshed using nominal latency within a \gls{tfr}, vice versa.}
% \yct{7}{\X{} only performs a full charge restoration if a row is not fully restored within a \gls{tfr} (i.e., the corresponding bit is \emph{logic-0}). After performing full charge restoration on the row, \X{} writes \emph{logic-1} to the corresponding bit and uses reduced latency for that row to perform partial charge restorations until the corresponding bit is reset to \emph{logic-0}. 
% \X{} periodically resets all bits in \gls{fr} to \emph{logic-0} every \gls{tfr}. Hence, after \X{} resets \gls{fr}, \X{} uses nominal latency for the first preventive refresh and reduced latency for the rest of the preventive refreshes of a row. 
% We calculate \gls{tfr} as the minimum time required for a row to receive \gls{thpcr} partial charge restorations.
% For example, if a RowHammer mitigation mechanism issues a preventive refresh when a row is hammered \gls{nrh} times, \gls{tfr} is set to $th_{PCR} \times (N_{RH} \times t_{RC} + t_{RFC(Red)})$.
% \agycomment{7}{explain how it addresses in high level first. Then explain the details of the mechanism. Using a threshold value is not high level explanation. Limiting the number of consecutive partial charge restorations and adjusting \gls{nrh} accordingly for the worst case is a better intuitive high level explanation.}
% \gls{thpcr} represents the maximum number of consecutive preventive refreshes using the reduced latency a row 
% \agycomment{7}{can receives is grammatically wrong. Use grammarly.}
% can receive. 
% \X{} guarantees that
% any victim row does \emph{not} receive
% \agy{7}{\emph{no} victim row receives}
% more than \gls{thpcr} preventive refreshes using reduced latency \emph{without} being refreshed using nominal latency \agy{7}{(i.e., fully restored)}.
% \agycomment{7}{This sentence is tooooo long and impossible to parse for me. I get lost when a row receives the reduced latency.}\yctcomment{7}{what about now}
% \X{} implements a bit vector, called \gls{fr}, that stores a single bit for each row in the DRAM module. Each bit in \gls{fr} indicates whether the victim rows of an aggressor row are refreshed using nominal latency (i.e., fully restored).
% % \agycomment{7}{why not a bit per victim? we refresh victim rows. What if two different aggressor hammers the same victim? how can we track them together to limit the partial refresh count of the victim?}
% If the victim rows are fully restored, the corresponding bit in \gls{fr} is set to \emph{logic-1} and set to \emph{logic-0}, otherwise.  
% % \yctcomment{7}{I changed logic-0 and 1, this way it is more intuitive.}
% \X{} uses the reduced latency only if the victim rows of an aggressor row are previously refreshed using nominal latency (i.e., the corresponding bit is \emph{logic-1}).
% \agycomment{7}{I still understand that a victim row's refreshes alternate between nominal and reduced latencies after every refresh. So, independent from thpcr a row is refreshed using nominal after refreshed using partial latency}
% If the corresponding bit is \emph{logic-0}, \X{} uses the nominal latency and sets the corresponding bit to \emph{logic-1}.}
% To ensure that a victim row is fully restored before receiving \gls{thpcr} partial charge restorations, \X{} periodically writes \emph{logic-0} to all bits in \gls{fr}. 
% \X{} configures \gls{tfr} as the minimum time interval for a row to receive \gls{thpcr} consecutive preventive refreshes. 
% For example, if a RowHammer mitigation mechanism issues a preventive refresh when a row is hammered \gls{nrh} times, \X{} sets \gls{tfr} as $th_{PCR} \times (N_{RH} \times t_{RC} + t_{RFC(Red)})$.\footnote{\yct{0}{If calculated \gls{tfr} is larger than \gls{trefw}, \X{} uses the reduced charge restoration latency for all preventive refreshes \om{5}{since} periodic refresh performs full charge restoration before a row can \om{5}{receive} \gls{thpcr} partial charge restorations.}} 
% \yct{4}{By doing so, \X{} guarantees that a row is refreshed at least once with the nominal latency (i.e., fully restores the cells' charge) before a row performs \gls{thpcr} consecutive partial charge restorations and }
% guarantees that the \gls{nrh} of the DRAM chip does \emph{not} go beyond the configured value \yct{7}{provided by \X{}.}
% \agycomment{7}{This 8.2 needs a new structure. You should start with high level, then explain low level. The structure should be clear and simple. The flow should not have loops. Explanations need more intuition. I cannot help without completely understanding how it works, and even I cannot understand after reading several times.}
% As \X{} exploits the manufacturer-recommended timing parameters, it is \emph{not} secure to use \yct{4}{reduced} \yct{4}{\gls{tras}} for \emph{all} preventive refreshes (\takeref{take:rh_rep}). Thus, \X{} uses a threshold \yct{4}{value} for \gls{thpcr} and makes sure no row performs more than \gls{thpcr} consecutive partial charge restorations \agy{1}{without performing a full charge restoration \yct{4}{using nominal \gls{tras}}}. After performing a maximum number of \gls{thpcr}, \X{} uses the \agy{1}{nominal} \yct{4}{\gls{tras}} for \agy{1}{the next} preventive refresh to \agy{1}{fully} restore the charge level of DRAM cells. After restoring the charge level to the nominal level, \X{} continues to reduce the latency of \yct{4}{preventive} refreshes. By doing so, \X{} guarantees that the \gls{nrh} of the DRAM chip does \emph{not} go beyond the configured value.



% As \X{} exploits the manufacturer-recommended timing parameters, it is \emph{not} safe to use reduced refresh latency for \emph{all} preventive refreshes (\takeref{take:rh_rep}). 
% Thus, \X{} uses a threshold value for \gls{thpcr}.
% and makes sure no row performs more than \gls{thpcr} consecutive partial charge restorations \agy{1}{without performing a full charge restoration using nominal refresh latency}. 
% After performing a maximum number of \gls{thpcr}, \X{} uses the \agy{1}{nominal} refresh latency for \agy{1}{the next} preventive refresh to \agy{1}{fully} restore the charge level of DRAM cells. After restoring the charge level to the nominal level, \X{} continues to reduce the latency of \yct{4}{preventive} refreshes. 

% \yct{20}{To safely reduce the preventive refresh latency at low cost, \X{} stores \gls{fr}.} 
% At initialization, \X{} writes \emph{logic-1} to all bits in \gls{fr}. 
% When the RowHammer mitigation \yct{4}{mechanism triggers} a preventive refresh, it first checks \gls{fr}. If the corresponding bit in \gls{fr} is \emph{logic-1} (i.e., the victim rows of the corresponding row are \emph{not} fully restored), the mitigation uses the nominal refresh latency to perform preventive refresh and writes \emph{logic-0} to the corresponding bit in \gls{fr}. If the corresponding bit in \gls{fr} is \emph{logic-0} (i.e., the victim rows of the corresponding row are fully restored), the mitigation safely uses the reduced preventive refresh latency to perform partial charge restoration. 
% \agycomment{0}{You can explain this simpler}


\head{\agy{7}{Maintaining row states}}
\agy{7}{To maintain each row's state at low cost, \X{} implements a bit vector, called \gls{fr}. \gls{fr} stores a single bit for each row in the DRAM module. Each bit in \gls{fr} indicates whether a row \om{8}{should be} refreshed using nominal latency within a \gls{tfr}. \gls{fr} can be implemented as an SRAM array in the memory controller.}
% or as a DRAM array inside the DRAM chip.}


\subsection{Hardware Complexity}
\label{sec:eval_area}
% \omcomment{8}{Double check all calculations here}\yctcomment{7}{we improved the mechanism and I think currently it is clear that we only need FR for storage. What do you think?}
{\X{}'s metadata storage \yct{7}{(i.e., \gls{fr})} can be implemented \om{5}{using} SRAM in the memory controller. \om{5}{The} metadata size is independent of \gls{nrh}, making \X{} scalable with the increasing RowHammer vulnerability.}
\X{} stores one bit of information per DRAM row \om{5}{on the fully restored bit vector (\gls{fr})}. We evaluate \X{}'s chip area and access latency \agy{4}{overheads} using CACTI~\cite{cacti}. Our results show that \X{} has an area cost of $0.0069mm^2$ per DRAM bank \yct{4}{where a DRAM bank consists of} 64K DRAM rows.
% \agycomment{4}{confusing: do we store metadata in SRAM or DRAM?}\yctcomment{4}{i guess this works} 
When configured for a dual rank system with 16 banks at each rank, \X{} requires storage of $8KB$ per bank,
\agy{4}{corresponding to a $0.09\%$ overhead on} a high-end Intel Xeon processor~\cite{wikichipcascade} \agy{4}{($1.35\%$ \om{7}{of} the memory controller area~\cite{skylakedieshot})}.
% and the scratchpad implementation has an overall area overhead of $0.106\%$ / $1.590\%$ of the chip/memory controller area of a high-end Intel Xeon processor~\cite{wikichipcascade, skylakedieshot}.} 
The metadata access latency \om{7}{in SRAM} \agy{4}{is} $0.27ns$, which is \agy{4}{significantly smaller than the latency of a DRAM row activation (e.g., $14ns$~\cite{datasheetM393A1K43BB1}), and can be} hidden by the row activation latency.
% , e.g., $14ns$~\cite{datasheetM393A1K43BB1}.

% \subsection{Security}
% \label{sec:mech_security}
% % \agycomment{4}{Please cross check with Svard and copy-merge as much as possible.}\yctcomment{4}{copied the structure}
% \X{} does \emph{not} compromise the security guarantees of existing RowHammer mitigation mechanisms. 
% \yct{4}{Existing mechanisms provide their security guarantees for each DRAM row when they are configured carefully with the profiled \gls{nrh} value of the DRAM chip.}
% \yct{4}{With \X{}, existing mechanisms are configured with the reduced \gls{nrh} value provided by \X{}.\yctcomment{7}{fixed the mech explanation}
% % and as explained in \secref{sec:mech_implementation}, \X{} does \emph{not} allow \gls{nrh} of any row to be lower than the configured \gls{nrh}.}
% \yct{4}{Hence, existing mechanisms still provide their security guarantees for each DRAM row.}}
% % \X{} carefully exploits the manufacturer-recommended refresh latencies and configures the mechanisms accordingly. As explained in \secref{sec:mech_implementation}, \X{} does \emph{not} allow any row to be partially refreshed more than \gls{thpcr} times without fully restoring the cells' charge level using nominal refresh latency. By this way, \X{} does \emph{not} allow \gls{nrh} of any row to be lower than the configured \gls{nrh}, thereby does \emph{not} compromise the security guarantees of existing RowHammer mitigation mechanisms.

\subsection{{\X{} with \agy{4}{on-DRAM-die RowHammer\\Mitigation Mechanisms}}}
% in-DRAM Activation Counting}}
% \iqrev{
\label{sec:ondiemitigations}
\agy{4}{\om{8}{Various} prior works propose on-DRAM-die RowHammer mitigation mechanisms~\cite{bennett2021panopticon, canpolat2024prac, marazzi2022protrr, marazzi2023rega, hassan2024selfmanaging, qureshi2024mint, son2017making, jedec2024ddr5, canpolat2025chronus}, including the PRAC mechanism (\secref{sec:background_dram_read_disturbance}) in \om{7}{the recent} DDR5 standard~\cite{jedec2024ddr5, canpolat2025chronus}}.
\iqrev{\agy{4}{To support these mechanisms, \X{} can also} be \yct{4}{implemented in \om{5}{a} DRAM chip} \agy{4}{with an on-DRAM-die RowHammer mitigation mechanism.}
\agy{7}{When a preventive refresh is scheduled,}
\yct{7}{\X{} determines whether the refresh latency can be safely reduced \yct{8}{by checking \gls{fr}} and stores the preventive refresh latency information in the mode registers (MR)~\cite{jedec2020ddr5}.}
\om{5}{When} \agy{7}{the} memory controller
\agy{4}{performs a preventive refresh (e.g., by issuing an RFM command~\cite{canpolat2024prac}), it uses the latency specified in the MR.}}
% \yct{7}{While \X{} stores the preventive refresh latency information in the mode registers (MR), To alleviate bandwidth and latency limitations of MRs, we encourage research and development of
\yct{7}{\agy{7}{\om{8}{We believe} better memory interfaces}
% MRs might be limited in efficiently communicating such decisions to the memory controller. Better interfaces between the memory controller and DRAM are essential 
\om{8}{can facilitate} easier \agy{7}{and more efficient integration of} on-DRAM-die RowHammer mitigation mechanisms and \agy{7}{\om{8}{\X-like} mechanisms that make RowHammer mitigation more efficient and scalable}. 
\agy{7}{For example,} Self-Managing DRAM~\cite{hassan2024selfmanaging} \agy{7}{enables} DRAM chips to autonomously \agy{7}{perform maintenance operations. In a memory system that implements Self-Managing DRAM, \X{} can easily be implemented in the DRAM chip with \emph{no} modifications to the memory controller or the memory interface.}}
% \agycomment{7}{This discussion does not seem to be complete.}
% \yct{7}{Such designs could enable future DRAM systems to become more autonomous, scalable, and capable of addressing emerging challenges like RowHammer.}

