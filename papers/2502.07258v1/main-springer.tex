% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%
\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%
\usepackage{graphicx}
% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage[hidelinks]{hyperref}
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
%\urlstyle{rm}
%

\usepackage{listings}
\usepackage{tikz}
\usepackage{pgfplots}
\usepackage{pgfplotstable}
\usepackage{xcolor}
\pgfplotsset{compat=1.18} 
\usepackage{xfrac}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{array, makecell}
\usepackage{amsmath}

\lstnewenvironment{cpptable}{\lstset{language=C++}}{}

\newcommand{\orc}[1]{\href{https://orcid.org/#1}{\includegraphics[height=10pt]{orcid}}}

%\usepackage[caption=false]{subfig}

\usepackage{wrapfig}

\begin{document}
%
\title{Closing a Source Complexity Gap between Chapel and HPX}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Shreyas Atre\inst{1} \and
Chris Taylor\inst{2} \orc{0000-0001-7119-818X} \and
Patrick Diehl\inst{3}\orc{0000-0003-3922-8419} \and Hartmut Kaiser\inst{1}\orc{0000-0002-8712-2806}}
%
\authorrunning{S. Atre et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{Louisiana State University, Baton Rouge, LA, 70803 \and
Tactical Computing Labs, LLC, 
\and
Los Alamos National Laboratory, Los Alamos, NM, 87544\\
\email{\{satre1,hkaiser\}@lsu.edu,ctaylor@tactcomplabs.com,diehlpk@lanl.gov}}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
A previous case study measured performance vs source-code complexity across multiple languages. The case study identified Chapel and HPX provide similar performance and code complexity. This paper is the result of initial steps toward closing the source-code complexity gap between Chapel and HPX by using a source-to-source compiler. The investigation assesses the single-machine performance of both Chapel and Chplx applications across Arm and x86. 

%A previous case study benchmarking a 1D heat equation kernel measured performance vs source-code complexity ratios across multiple languages. The case study measured source-code complexity using lines of code (LoC) and the  COnstructive COst MOdel (COCOMO) model. The case study's results indicated Chapel and HPX were nearest neighbors in the same COCOMO quadrant. The COCOMO quadrant represented languages sharing dual high performance and low source-code complexity. The case study showed an existing gap between Chapel and HPX with respect to source-code complexity. This paper is the result of initial steps toward closing the source-code complexity gap between Chapel and HPX. This paper investigates the performance implications associated with closing the source-code complexity gap using a source-to-source compiler. The investigation assesses the single-machine performance of both Chapel and Chplx applications across Arm and x86. This paper explores the performance implications and considerations associated with migrating the Chapel language from it's existing synchronous runtime system to the HPX asynchronous many task runtime system.

\keywords{Compilers \and Programming Languages \and HPC \and Runtime Systems \and HPX \and AGAS \and Chapel \and PGAS}
\end{abstract}


\section{Introduction}

HPX is an asynchronous many-task runtime (AMT) system implementing the ISO C\texttt{++} language's standard template library (STL) for data parallelism.HPX is built on the ParalleX execution model~\cite{parallex} placing emphasis onscalability, performance, and responsiveness of parallel applications using futures. HPX hosts a user-land thread library and an active global address space~\cite{hpx_agas}. %HPX offers capabilities to handle fine-grained parallelism and lightweight synchronization using futures and task-based algorithm decomposition. HPX demonstrates best performance when tasks are small and applications are structured as task graphs.

% Developers can use familiar data structures and algorithms from the STL in their HPX applications to enhance productivity, performance, and code reuse. 

%HPX's user-land thread library is compatible with traditional program trace visualization tools (TAU, Ravel, HPCToolkit, etc). Capturing aggregate performance numbers is possible with existing trace visualization tools and techniques. Capturing information at the granularity of HPX user-land threads is infeasible. Traveler is a modern web-based performance visualization tool created specifically for HPX applications. This case study uses Traveler for performance analysis as it provides tooling that can collect HPX runtime information necessary to investigate the performance implications of migrating Chapel programs to HPX using a source-to-source compiler. 

%HPX implements an Active Global Address Space (AGAS)~\cite{hpx_agas} and provides user-space implementations of data parallelism and concurrency as defined in the ISO C++ standard. 

Chapel~\cite{cascade} is a general purpose, productivity focused, procedural language designed with features supporting Partitioned Global Address Space (PGAS) programming~\cite{pgas}. Chapel gives users the ability to write applications under both a single-host shared memory system and a multi-host, distributed memory system. Chapel's language syntax shares similarities with C\texttt{++} and Python. Cray's Chapel compiler offers performance on par with C and C\texttt{++}.

The Cray Chapel compiler originally generated C programs. Chapel offers programming language features that were not organic to C. Support for the Chapel language specific features is provided by a custom C-based runtime system which this paper will refer to as Cray's Chapel runtime system. The current Cray Chapel compiler has shifted from source-to-source compilation to the LLVM compiler infrastructure. The Cray Chapel compiler continues to provide legacy support for C program generation.

The previous study~\cite{diehl2023benchmarking} indicated Chapel and HPX provided comparable performance. The study showed a gap between Chapel and HPX with respect to source code complexity. Source code complexity is measured using lines-of-code and the \textbf{Co}nstructive \textbf{Co}st \textbf{Mo}del (COCOMO)~\cite{Boehm1981} model. Closing the source-code complexity gap between Chapel and HPX requires implementation of a source to source compiler. The source-to-source compiler needs to translate Chapel software applications into ISO C\texttt{++} applications that exercise runtime system functionality provided by HPX.

 The ChplX compiler is the result of a 6 month software development effort. ChplX does not currently support the entire Chapel language. The ChplX compiler closes the code complexity gap between Chapel and HPX by achieving line-for-line translation of Chapel to C\texttt{++}. The ChplX compiler generates C\texttt{++} code that exercises functionality implemented in the ChplX library.

The ChplX library implements language functionality, using HPX, that was previously  exclusive to Chapel and the Chapel runtime system. The ChplX library implements facilities corresponding to Chapel data types like Chapel ranges, domains, arrays, but also Chapel language features like \textit{cobegin}, \textit{coforall}, and \textit{forall}, etc. The ChplX library provides ChplX compiler developers an ability to experiment with different code generation options. ISO C\texttt{++} developers have an opportunity to experiment with the ChplX library's implementation of the Chapel language's features outside of the Chapel programming language.

Our contributions in this work include the following:
\begin{itemize}
    \item A demonstration of Chapel's suitability as a frontend language for ISO C\texttt{++}.
    \item The first cross comparison of Chapel's performance across A64FX and x86.
    \item The ChplX\footnote{\url{https://github.com/ct-clmsn/chplx}} source-to-source proof of concept compiler and the ChplX C\texttt{++} library implemented using the AMT HPX~\cite{Kaiser2020}.
    \item A review of the Cray Chapel compiler's abstract syntax tree representation of conditional expressions and its impact on syntax driven management of variable scope.
    \item Prototyping a new C\texttt{++}-specific inlining feature for Chapel, `inlinecxx`.
    \item Evaluation of the strong scaling properties of 
    the Cray Chapel compiler compared to ChplX.
    \item An evaluation of the ChplX compiler's 6 month development effort to close the COCOMO gap while maintaining high performance.
\end{itemize}

This work demonstrates parity between the Chapel and HPX programming models. This work describes the ChplX compiler's implementation. The ChplX library and the functionality it provides is introduced. This work finishes with a performance evaluation of the 1D heat equation code, STREAM, GUPS, and code complexity using COCOMO scoring.

% needs more HPX introduction sauce
%HPX implements an Active Global Address Space (AGAS)~\cite{hpx_agas} and provides user-space implementations of data parallelism and concurrency as defined in the ISO C++ standard. HPX is built on the ParalleX execution model~\cite{parallex}, which focuses on improving the scalability, performance, and responsiveness of parallel applications. Developers can use familiar data structures and algorithms from the STL in their HPX applications to enhance productivity, performance, and code reuse.

% needs more APEX introduction sauce
%HPX integrates with the Autonomic Performance Environment for eXascale (APEX)~\cite{10.5555/3026759.3026764}. APEX provides HPX performance observation, measurement, analysis and runtime decision making capabilities in order to optimize performance. APEX collects system information HPX consumes during application execution providing HPX the ability to autotune performance.

%APEX generates trace information. APEX program traces provide the ability to study runtime performance of applications implemented using HPX. Traveler~\cite{9904447} is a performance visualization tool that consumes APEX trace information. Traveler shows users performance information associated with each line of an application. Users are able to observe APEX measurements associated with internode communication, hardware and software performance counters, and a tree view of syntactic relationships that exist between the collected counter information.

%ChplX is an environment that ties together the Chapel language, HPX, APEX, and Traveler into a single solution called the ChplX Toolchain.

\section{The Chapel and HPX Programming Models}

Chapel provides a Single Program, Many Data (SPMD) distributed programming experience. Chapel offers a productivity oriented syntax emphasized in modern scripting languages. Chapel's syntax reflects its origins as an array programming language descended from Orca C and ZPL. Chapel extends its foundation as an array programming language by implementing a Partitioned Global Address Space (PGAS) communication model. PGAS has roots in UPC, Split-C, and OpenSHMEM~\cite{10.1145/2020373.2020375}.

HPX implements an ISO C\texttt{++} standard conforming data parallelism and asynchronous execution library. HPX introduces an Active Global Address Space (AGAS) built around its data parallelism foundation. Users can implement distributed object types that can expose methods and functions for remote invocation and execution. ISO C\texttt{++} futures become the foundation for managing the completion of remote method and function invocations. Users can chain multiple asynchronous invocations into a tree or dataflow graph.

HPX provides an implementation of C\texttt{++}20 coroutines along with the standard's new \textit{co\_await} functionality. HPX's coroutine support means C\texttt{++} is capable of performing Python and Chapel style yield and generator expressions. HPX's support for \textit{await} functionality makes the implementation of data parallel and recursive algorithms as straightforward as implementing a slightly modified version of the sequential version of the algorithm. Listing 5, in the Appendix, demonstrates the slight modifications required to parallelize a sequential implementation of the quick sort algorithm. HPX's coroutine support for C\texttt{++}20 coroutines creates the means to implement Chapel-style iterator functions. Chapel iterator functions are similar in form and function to Python's generator functions and expressions.

HPX and Chapel focus on shared-memory and distributed-memory parallelism and concurrency. Both provide abstractions for distributed data types and data structures. Both provide mechanisms for handling task dependencies and synchronization. Chapel and HPX share a common set of functionality and are different in a handful of ways.

%Chapel's implementation of PGAS means memory allocations are fixed over integral types (short, int, float, double, etc).
HPX's AGAS implementation registers objects with the runtime using a string identifier. AGAS registered objects are capable of changing locality based on resource and compute constraints that may occur during an application's runtime. In contrast, Chapel fixes addresses within the partitioned global address space.

HPX provides first-class support for futures at the runtime system level. Chapel provides futures but, they are not an integral part of the underlying runtime system. Chapel's parallel model is fork-join in nature. HPX's model offers support for fork-join parallelism. HPX makes a concerted and deliberate effort to place futures and asynchrony at the forefront of its user story. The intent is to promote those tools over the classical fork-join model.

\section {The ChplX Toolchain and Environment}


%\begin{wrapfigure}{r}{0.5\textwidth}
%  \begin{center}
%\includegraphics[width=0.5\textwidth]{figures/chplxtools.png}
%  \end{center}
%  \caption{The ChplX Toolchain}
%  \label{fig:chplx_toolchain}
%\end{wrapfigure}

The ChplX compiler part of the ChplX toolchain. The ChplX toolchain has three components. The first component is the ChplX compiler. The second component is the ChplX library. The third component is the Traveler visualization tools. The ChplX compiler creates C\texttt{++} application software. The compiler-generated application software uses the ChplX library. Users can opt to use the ChplX library without the ChplX compiler to craft C\texttt{++} applications. ChplX compiler and ChplX library users can both use and benefit from the Traveler visualization tools. The Traveler visualization tools exist to provide performance analytics for data collected from the HPX user-land thread library. Existing other performance tools are not compatible with HPX due the HPX user-land thread support.

%compiler. The ChplX library is modular as well. It's 
%implementation provides the main interface between the 
%Chapel source program and the generated C++ program. It can 
%be modified or integrated as a standalone library as well. 
%This design does not place mandatory constraints into the 
%User's computational environment. All the pieces are 
%integrated by default and can be replaced or modified as per %will at the endpoints with a few lines of code change.

\subsection{The ChplX Compiler}

The ChplX compiler performs the source-to-source translation of Chapel programs to C\texttt{++} programs. The ChplX compiler is implemented using C\texttt{++} and a frontend library provided by Cray's Chapel compiler. Cray's Chapel frontend library provides a lexer, parser, and abstract syntax tree framework implemented in C\texttt{++}.

%The ChplX compiler relies heavily on `std::variant` to both build a revised version of the Chapel compiler's syntax tree and in the symbol table. The use of `std::variant` 

The ChplX compiler adds directives in the generated C\texttt{++} program which point back to the original Chapel program. This feature helps debugging and visualization tools map the generated C\texttt{++} application software back to the original Chapel program. Users can quickly assess if a performance regressions or bottlenecks is the side effect of an implementation decision in the original Chapel program or an issue in the ChplX compiler generated C\texttt{++} program.

The ChplX compiler generates an appropriate CMake build file for the application. This feature offers a convenient mechanism to compile applications without having to bother with learning a build system or implementing build system scripts.

ChplX prototypes a Chapel function providing direct integration with C\texttt{++}. The function originally expedited the ChplX compiler's bootstrapping. The special function is called \textit{inlinecxx}.
The \textit{inlinecxx} function operates in a fashion similar to an \textit{asm} intrinsic found in C and C\texttt{++}. Users are able to write a string of C\texttt{++} code which is forwarded into the final generated program. The \textit{inlinecxx} function is implemented, in the ChplX compiler, using C\texttt{++}'s \textit{fmt} library. Listing 1 is an example of the feature.

\begin{lstlisting}[language=c++,caption=ChplX `inlinecxx` input and compiled C++ output,label=lst:rdtime,escapechar=|,float=tbp,showstringspaces=false]
// `inlinecxx` function signature
proc inlinecxx(string, n?...)

// Chapel code that uses `inlinecxx`
var i = 0;
inlinecxx("std::cout << i << std::endl");
inlinecxx("std::cout << {} << std::endl", i);

// ChplX generated C++ output from lines 5-6
int i = 0;
std::cout << i << std::endl;
\end{lstlisting}

Programs implemented using the ChplX \textit{inlinecxx} functionality will not be compatible with the Cray Chapel compiler. Users can correct this incompatibility by implementing the Chapel function in Listing 2 or by placing comments around their \textit{inline} expressions from their Chapel program. The function implemented in Listing 2 turns the \textit{inlinecxx} invocation into a "null" operation. The code provided to \textit{inlinecxx} passes through the Cray Chapel compiler with no effect on the output program. Depending on the complexity of the \textit{inlinecxx} workaround may not be sufficient for portability.

%\begin{lstlisting}[language=c++,caption=ChplX `inlinecxx` A Chapel function for Cray Chapel programs creating compatiblity with ChplX,label=lst:rdtime,escapechar=|,float=tbp]
%// `inlinecxx` function signature
%proc inlinecxx(str : string, n?...) {
%}
%\end{lstlisting}
The ChplX compiler is oraganized into a frontend and backend. The frontend contains the parser and abstract syntax tree (AST) construction tooling provided by the Cray Chapel compiler. The backend accepts the AST created by the frontend and begins a multipass compilation process.

The first pass creates a \textit{program symbol table} using the visitor pattern\cite{gamma1994design}. The program symbol table is composed of smaller \textit{scope symbol tables} targeting each \textit{scope} (modules, functions, classes, loops, etc) structured using a heap.

The compiler populates scope symbol tables using Chapel's variable scoping rules. Each scope symbol table has parents and children. Scope symbol tables are organized as a heap and can be queried from the program symbol table using the line of code where the lexical scope is initialized. Program symbol table queries operate both up and down the tree.

Implementation of the symbol table pass is complicated by the lexical scoping structure of conditional expressions constructed by the Cray Chapel compiler's parser. The Chapel AST has a Block AST node representing a sequence of statements. Chained series of conditional expressions (\textit{if}, \textit{else-if}, \textit{else-if}) are nested inside each other in the AST as opposed to being constructed as a sequence of statements. Nested conditional expressions instantiate an excessive number of Block AST nodes increasing the complexity of the AST. Table 1 shows how a Chapel conditional expression is stored by the Cray Chapel compiler in the AST.

Variable declarations made within the scope of earlier conditional blocks can be naively propagated down into conditional block scopes. Syntactically this specific propagated variable declaration should be considered out of scope.

In situations where the final part of the conditional expression has no condition, an \textit{else} block, the nesting pattern is terminated. The \textit{else} block is added at the end of the conditional chain as a new, \textit{untyped block}. This particular structuring of chained conditional expressions and \textit{else} blocks complicates syntactic analysis for functions, classes, records, loops, conditional expressions, use of the AST for program symbol table construction, and enforcing variable scope. It is difficult to discern if the tail scope is an \textit{else block} or an extraneous conditional expression.

ChplX uses back pointers to manage these issues. There are some instances where back pointers causes unsatisfactory results. A better solution involves implementation of an initial compiler pass that transforms the Cray Chapel compiler's AST into a more manageable structure.

The initial transformation pass would create a new lexical type for conditional expressions. The new lexical type would store conditional expressions as variable length list of conditional clauses. The approach would more closely reflect the syntax reflected in the user's code and make managing scoping rules, symbol table creation, and symbol addition a straight forward process. This solution will be visited in future work.

\begin{table}[b]
\caption{Chapel language Conditional Expressions in the AST, `\{\}` represents a scope, `cond\(\)` represents the conditional\label{chplx_condexpr}}
\centering
\begin{tabular}{ l | l } %|| l | l }
Chapel Conditional & Chapel AST \\
\hline
\begin{cpptable}
if() {}
else if() {}
\end{cpptable}
&
\makecell[l]{
cond() \{ \\
\quad \{ \\
\quad\quad cond() \{ \\
\quad\quad \} \\
\quad \} \\
\}
}
\\
\end{tabular}
\end{table}

%The ChplX compiler implementation uses \textit{std::variant}, an ISO C\texttt{++} data type that provides a strongly typed form of a standard C and C\texttt{++} union. The ChplX compiler uses \textit{std::variant} to represent type information. Chplx includes a data type for both user defined types, \textit{classes}, \textit{records}, and functions. Functions types are represented using variable length arrays of argument type information. User defined types are an extension of functions. ChplX makes a concerted effort to represent all type information as a derivative of function types composed from a set of integral types. This decision has drastically simplified the development process.

The ChplX symbol table is initialized with the following integral types \textit{nil, bool, string, int, real, complex, tuple, range, domain, and function}. The symbol table is additionally loaded with the template symbol (\texttt{?}), binary operators, ternary operator, and the \texttt{inlinecxx} function. Loops and conditionals are treated by the symbol table compiler pass as a special class of functions. Each instance of a loop or function is entered into the symbol table. Each loop or function is given a function name using the type of loop (\texttt{for}, \texttt{forall}, \texttt{coforall}, etc) or conditional expression (\texttt{if}, \texttt{else\_if}, \texttt{else}) along with the Chapel program's file name and the line number associated with the loop or conditional expression.

The second pass constructs data structures describing the output C\texttt{++} program using the program symbol table. Each AST node is visited and an output program syntax tree is constructed. The output program syntax tree uses \textit{std::variant} simplifying the traversal logic. Use of \textit{std::variant} reduces tree traversal to a \textit{std::visit} invocation. Output from the second pass creates a output program syntax tree. The output program syntax tree embeds symbol table information. This decision removes symbol table look ups from the code generation pass.

The final pass performs program code generation using the visitor pattern to print ISO C\texttt{++} to the output files. A CMake build script is generated. %The program code generation pass uses the visitor pattern to traverse the output program syntax tree. 
%The visitor pattern prints ISO C\texttt{++} code to output files.
%The final step in the code generation pass is creation of a CMake build script. Listings 3 and 4 provide a simplified sample of the ChplX compiler's output for a given Chapel input.


\begin{minipage}{0.45\textwidth}
\begin{lstlisting}[language=c++,caption=ChplX compiler input,label=lst:rdtime,escapechar=|]
var a : int = 1 + 1;
a = a + 1;
\end{lstlisting}
\end{minipage}
\hfill
\begin{minipage}{0.45\textwidth}
\begin{lstlisting}[language=c++,caption=ChplX compiler output,escapechar=|]
#line 8 "expr.chpl"
        auto a = 1 + 1;
#line 9 "expr.chpl"
        a = a + 1;
\end{lstlisting}
\end{minipage}


%The second extension implemented in ChplX provides native 
%compiler support for cmake. During the compilation 
%process, the ChplX compiler collects information about a 
%Chapel application creating a well formed cmake build 
%script. This feature eases a users compilation experience.

\subsection{ChplX Library}

Programs created by the ChplX compiler are composed by mapping Chapel's language syntax onto the ChplX library. The ChplX library is an abstraction layer above the HPX runtime system. ChplX implements Chapel's language functionality. The ChplX library is designed to simplify the source to source compilation process. The ChplX compiler's goal of achieving line-by-line translation is made possible by the implementation of the ChplX library.

The ChplX library currently provides support for: data parallelism, process level parallelism, range support, array support, tuples, domains, associative domains, atomics, locales, synchronization variables, and zippered iteration. The ChplX library can be extended further to provide generator function support, distributed classes and records, distributed containers, channels, and first class support for futures.

There are two benefits provided by the ChplX library. The first and more obvious benefit is that C\texttt{++} developers gain access to Chapel's language functionality. A secondary benefit is that the library provides C\texttt{++} developers an ability to further tune and optimize ChplX compiler generated Chapel programs.

The main design goal for the ChplX library is to reduce the complexity of transformations required to create ISO C\texttt{++} from Chapel. The library implements the main Chapel language semantics as C\texttt{++} template types such that there is almost a one-on-one relationship between a particular Chapel language feature and the corresponding ChplX library feature. Table~\ref{chplx_facilities} lists the most important facilities implemented by the ChplX library.

\begin{table}[tb]
\caption{Exemplar Chapel language features and corresponding ChplX library facilities\label{chplx_facilities}}
\centering
\begin{tabular}{ll|ll}
Chapel Language & ChplX Library & Chapel Language & ChplX Library  \\ 
\hline
Range           & \texttt{chplx::Range<>} & forall          & \texttt{chplx::forall}   \\
Tuple           & \texttt{chplx::Tuple<>} & coforall        & \texttt{chplx::coforall}    \\
Domain          & \texttt{chplx::Domain<>} & begin           & \texttt{chplx::begin}   \\
Array           & \texttt{chplx::Array<>} & cobegin         & \texttt{chplx::cobegin}  \\
Locale          & \texttt{chplx::Locale<>} & zip             & \texttt{chplx::zip}     \\
Dmap            & \texttt{chplx::dmap<>} &  Sync            & \texttt{chplx::Sync<>}  \\
Atomic          & \texttt{chplx::Atomic<>} & Single          & \texttt{chplx::Single<>}   \\
\end{tabular}
    \vspace{-5mm}
\end{table}

The APIs and semantics for the listed facilities enumerated in Table~\ref{chplx_facilities} are modeled after their corresponding Chapel language semantics. Using Chapel ranges as an example, the C\texttt{++} template type \texttt{chplx::Range<>} exposes all of the functionality defined for Chapel Ranges. ChplX Ranges support bounded and unbounded ranges, slicing, striding, arithmetic range operators, and the Range operators (\texttt{\#}, \texttt{by}, and \texttt{align}). All of the support is implemented as API functions operating on \texttt{chplx::Range<>} instances (\texttt{chplx::count()}, \texttt{chplx::by()}, and \texttt{chplx::align()}). \texttt{chplx::Range<>} additionally supports all of the member functions corresponding to the Chapel language specification. %Table~\ref{range_functions} is an exemplar (incomplete) list of those.

%\begin{table}
%\caption{Exemplar list of Chapel Range functions implemented by the ChplX library \texttt{chplx::Range<>} type\label{range_functions}}
%\centering
%\begin{tabular}{l|l}
%Chapel Range & ChplX Range  \\ 
%\hline
%\texttt{proc range.stride} & \texttt{Range<>::stride()}       \\
%\texttt{proc range.low} & \texttt{Range<>::low()}       \\
%\texttt{proc range.lowBound} & \texttt{Range<>::lowBound()}       \\
%\texttt{proc range.alignedLow} & \texttt{Range<>::alignedLow()}       \\
%\hline
%\texttt{proc range.isAmbigous} & \texttt{Range<>::isAmbigous()}       \\
%\texttt{proc range.isEmpty} & \texttt{Range<>::isEmpty()}       \\
%\texttt{proc range.isBounded} & \texttt{Range<>::isBounded()}       \\
%\hline
%\texttt{proc range.indexOrder(ind)} & \texttt{Range<>::indexOrder(ind)}       \\
%\end{tabular}
%\end{table}

The parallel tasking and looping constructs are well integrated with the \texttt{chplx::Range<>}, \texttt{chplx::Domain<>}, and \texttt{chplx::Array<>} C\texttt{++} template types, such that iteration can be directly performed on instances of those.

Chapel iterators are directly mapped onto equivalent features exposed by the ChplX library. The implementation of iterators relies on native C\texttt{++} co-routines introduced in C\texttt{++}20, in particular on the C\texttt{++} language keywords \texttt{co\_return}, \texttt{co\_yield}, and \texttt{co\_await}. All iterable C\texttt{++} template types in the ChplX library expose specific iterators that enable seamless integration for the ChplX library looping and tasking constructs.

%\subsection{APEX}
%
%APEX~\cite{10.5555/3026759.3026764} is a product of the DoE's XPRESS effort that aimed to develop %new performance observation, measurement, analysis, and runtime decision making to optimize %performance. APEX is a runtime introspection, adaptation, and autotuning library for asynchronous %many-task runtime systems.
%
%APEX provides support for software and hardware counters. The software and hardware counter %support enables both the collection of performance data from the underlying hardware but also the %ability to collect performance data about specific routines or operations preformed in software.
%
%APEX offers a runtime policy engine which can perform adaptive runtime execution for hard coded %rules. Users can define specific performance targets for some aspect of the runtime system's %performance along with software-based mechanisms to handle situations where the performance %targets are achieved. APEX integrates with ActiveHarmony in order to provide dynamic search for %runtime autotuning.
%
%APEX enjoys first class integration into HPX.  The integration means ChplX compiled applications %gain access to features and capabilities provided by APEX.
%
%APEX provides ChplX compiled applications the ability to be autotuned or runtime adapted. ChplX %applications benefit from APEX's observation, measurement, and analytic capabilities. APEX %collected data can be exported into OTF2 and be trivially consumed by other products.
%
%\subsection{Traveler}
%
%\begin{figure*}
%\includegraphics[width=\textwidth,height=6cm]{figures/temporal_view.png}
%\caption{Traveler's visualization of an execution trace, using data collected by APEX, from %Chapel code executed using HPX}
%\label{fig:traveler_exploded_view}
%\end{figure*}
%
%Traveler\cite{9904447} is a modern performance visualization tool that processes trace %information collected and organized by APEX. 
%
%Traveler originally supported the Phylanx\cite{8638482} toolkit. Phylanx performed runtime %conversion of Numpy application code into a Scheme-derivative language called PhySL. Phylanx %distributed memory interpreter would subsequently load and execute PhySL.
%
%Within the context of Phylanx, Traveler is used to identify performance bottlenecks in a user's %Numpy application, HPX, and the Phylanx interpreter. Traveler visualisations directed %implementation of C++ plugins the Phylanx interpreter used to perform Numpy operations. Numpy %operations that were performed frequently were rolled into a single plugin that further %accelerated overall application performance.
%
%Traveler has been generalized to support C++ applications implemented with HPX. Traveler's %generalization allows C++ developers a novel mechanism to find runtime visualization in %application software.
%
%The ChplX toolchain provides first-class support for Traveler visualizations through the %underlying ChplX library. The ChplX compiler inserts source location information into a specific %suite of ChplX library calls that exercise the HPX and APEX runtime integration.
%
%The output of a ChplX application running with HPX and APEX runtime integration is a file system %directory containing multiple OTF2 and metadata files. These OTF2 and metadata artifacts can %subsequently be rendered and analyzed using Traveler.

\section{Performance \& Complexity Evaluation}

Performance benchmark experiments were conducted on the following single node machines: Intel(R) Xeon(R) Platinum 8358 CPU clocked at 2.60GHz, with 64 cores, and 240 GiB DDR4 Memory and an A64FX machine with 32GB of HBM. All experiments were performed with Clang+LLVM 15, HPX v1.9.1 (APEX v2.6.3), Chapel 2.3, on an Ubuntu focal environment.

The following benchmarks are used to assess performance: STREAM, Heat equation, and GUPS. Each benchmark is compiled using different options. The first option exercises the Cray Chapel compiler's gcc and clang backends with the \textit{--fast} optimizations. The Cray Chapel compiler's llvm backend is not used in order to maintain a level of comparability between results. The second pair of options compile the Chplx compiler's generated code with gcc and clang using \textit{-O3} optimizations.

%Sections 4.1, 4.2, \& 4.3 describe each benchmark, experiment conditions, present performance plots, and provide analysis of the performance plots. Section 4.4 provides a summary analysis of all the benchmarks. All benchmark performance numbers are averages over 10 independent runs.

%  using Traveler master branch commit 4b34a32 if required

\subsection{Heat Equation Kernel}
% provide information on the heat equation code
% found here -> https://arxiv.org/pdf/2307.01117.pdf
%
The heat equation kernel evaluated in this study is one-dimension with length L for all times $t > 0$. Equation 1 defines the kernel. Equation 2
defines Euler's method which is used for time discretization. The $\boldsymbol{\alpha}$ term is a material's diffusivity.

While this problem is small and extremely simple, it has much in common with many high performance codes that simulate black holes, coastal waves, atmospheres, etc. Block-structured meshes that use finite differences are common and essential for modeling a wide variety of physical systems.

\begin{equation}
\frac{\delta u}{\delta t} = \alpha \frac{\delta ^ 2 u}{\delta \ u^2}, 0 <= x < L, t > 0
\end{equation}

\begin{equation}
u(t + \delta t, x_i) = u(t, x_i) + \delta t \cdot \alpha \frac{u(t, x_{i-1}) - 2 \cdot u (t, x_i) + u (t, x_{i+1}) }{2h}
\end{equation}

This specific kernel's performance has been studied across 10 programming languages and runtime systems in the previous study~\cite{diehl2023benchmarking}. The heat equation kernel was selected for this paper based based on the previous study's rationale. The problem is small, simple, and has commonality with high performance scientific codes in astrophysics~\cite{Diehl2023EvaluatingHA}, hydrodynamics~\cite{10.1007/s10915-019-00960-z}, and n-body simulations~\cite{Dekate_2012}.

%and classical benchmarks such as the STREAM\cite{McCalpin1995,McCalpin2007} and GUPS\cite{osti_860347}.

%A Chapel implementation of the heat equation kernel is compiled using the Cray Chapel compiler with the \textit{--fast} flag is applied. The Cray Chapel compiler's \textit{--fast} flag enables the LLVM \textit{-O3} optimizer.

%The Chapel implementation of the heat equation kernel is compiled using the ChplX compiler. The ChplX compiler's output is a C++ program. The C++ program is compiled using clang++ with \textit{-O3} optimization by virtue of CMake's Release mode. The ChplX output is compiled as an ISO C++20 application.

%The ChplX output C++ program is also compiled using both the \textit{-Ofast --fast-math} flags by virtue of CMake's Release mode.

%Performance measurements are taken for each program compiled with the Cray Chapel compiler and ChplX with different runtime configurations of thread counts. The Sifive rv64g machine has only 4 cores. Core counts place a hard upper bound on the performance measurements taken on each system. There are noticeable performance differences depending upon which compiler flags are applied and the number of software threads created and managed to support the underlying hardware's core count.

%\begin{figure}[tb]
%\begin{tikzpicture}

%\begin{axis}[grid,xlabel={\# threads},ylabel={Seconds},xmax=64, legend pos=north east]

%    \addplot[black,thick,mark=*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel2-stream-add-x86.csv};

%    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-stream-add.csv};

%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel2-stream-copy-x86.csv};

%    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-stream-copy.csv};

%    \addplot[black,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel2-stream-scale-x86.csv};

%    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-stream-scale.csv};

%    \addplot[purple,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel2-stream-triad-x86.csv};

%    \addplot[purple,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-stream-triad.csv};

%    \addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel2-heat-x86.csv};

%    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel-fast.csv};

%    \addplot[yellow,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-deux-heat-eqn-x86.csv};

%    \addplot[green,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-release.csv};
    
%    \addplot[purple,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel2-gups-x86.csv};

%    \addplot[purple,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-gups.csv};
    
    %\legend{add, copy, scale, triad, heat, gups};
    
%\end{axis}
%\end{tikzpicture}

%    \caption{Heat Equation: Cray Chapel Strong Scaling, Average Time}
%    \label{fig:performance:scalingA}
%\end{figure}

%\begin{figure}[tb]
%\begin{tikzpicture}
%
%\begin{axis}[grid,xlabel={\# threads},ylabel={Seconds},xmax=64, legend pos=north east]
%
%    \addplot[black,thick,mark=*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel-noflags.csv};
%
%    \addplot[blue,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel-baseline.csv};
%
%    \addplot[orange,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel-fast-vs-ChplX-reldebinf.csv};
%
%    \addplot[purple,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel-fast.csv};
%
%    \legend{chapel-noflags,chapel-baseline,chapel-rdi,chapel--fast};
%    
%\end{axis}
%\end{tikzpicture}
%
%    \caption{Heat Equation: Cray Chapel Strong Scaling, Average Time}
%    \label{fig:performance:scalingA}
%\end{figure}

%\begin{figure}[tb]
%\begin{tikzpicture}

%\begin{axis}[grid,xlabel={\# threads},ylabel={Seconds},xmax=64, legend pos=north east]

%    \addplot[black,thick,mark=*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {ChplX-noflags.csv};

%    \addplot[blue,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {ChplX-debug.csv};

%    \addplot[orange,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {ChplX-reldebginf.csv};

%    \addplot[purple,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {ChplX-release.csv};    

%    \legend{ChplX-noflags,ChplX-debug,ChplX-rdi,ChplX-release};
    
%\end{axis}
%\end{tikzpicture}

 %   \caption{Heat Equation: ChplX Strong Scaling, Average Time}
 %   \label{fig:performance:scalingB}
%\end{figure}

%\begin{figure}[tb]
%\begin{tikzpicture}

%\begin{axis}[grid,xlabel={\# threads},ylabel={Seconds},xmax=64, legend pos=north east]

%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel-fast.csv};

%    \addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-release.csv};

%    \addplot[magenta,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel2-heat-ookami.csv};

    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chapel-fast.csv};

    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {chplx-heat-rv.csv};

%    \legend{chapel-x86,chplx-x86,chapel-ookami};
    
%\end{axis}
%\end{tikzpicture}
%    \caption{Heat Equation: Strong Scaling, Average Time}
%    \label{fig:performance:scalingC}
%\end{figure}

\begin{figure}[tbp]
\begin{subfigure}[t]{0.45\textwidth}
\begin{tikzpicture}[scale=0.75, transform shape]

\begin{axis}[grid,ymode=log,xlabel={\# threads},ylabel={Seconds, log scale},xmin=2,xmax=64, legend pos=north east]
    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/heat-chapel-gcc.csv};
    
    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/heat-chapel-llvm.csv};
    
    \addplot[blue,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/heat-chplx-gcc.csv};

    \addplot[teal,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/heat-chplx-llvm.csv};

    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-heat-chapel-gcc.csv};

    \addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-heat-chplx-gcc.csv};

    \legend{chapel-gcc-x86,chapel-clang-x86,chplx-gcc-x86,chplx-clang-x86,chapel-gcc-a64fx,chplx-clang-a64fx};
\end{axis}
\end{tikzpicture}
\caption{}
\label{}
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.45\textwidth}
\begin{tikzpicture}[scale=0.75, transform shape]

\begin{axis}[grid,xlabel={\# threads},ylabel={Giga-Updates/second (GUPS)},xmin=1,xmax=64,legend pos=north west]
    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{2}, col sep=comma] {2025_jan/gups-chapel-gcc.csv};
    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{2}, col sep=comma] {2025_jan/gups-chplx-gcc.csv};
    %\addplot[blue,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{2}, col sep=comma] {2025_jan/gups-chapel-llvm.csv};
    %\addplot[blue,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{2}, col sep=comma] {2025_jan/gups-chplx-llvm.csv};
    %\addplot[teal,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-gups-chapel-gcc.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-gups-chplx-gcc.csv};    
    \legend{chapel-gcc-x86,chplx-gcc-x86}; %,chapel-gcc-a64fx,chplx-gcc-a64fx};  
\end{axis}
\end{tikzpicture}
\caption{}
\label{fig:performance:gupsStrongScaling}
\end{subfigure}
\caption{Heat Equation: Strong Scaling, Average Time and (\subref{fig:performance:gupsStrongScaling}) GUPS \(n\_threads*bytes \div seconds \div 1e9\), Giga-Updates Per Second, 1GB Strong Scaling}
\label{fig:performance:heatEqn}
%\end{subfigure}
%\hfill
%\begin{subfigure}[t]{0.45\textwidth}
%\begin{tikzpicture}[scale=0.75, transform shape]
%\begin{axis}[grid,ymode=log,xlabel={\# threads},ylabel={Seconds}, legend pos=north east]
%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-gcc-10000.csv};
%    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-llvm-10000.csv};    
%    \addplot[blue,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-gcc-10000.csv};
%    \addplot[teal,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-llvm-10000.csv};
%    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-gcc-10000.csv};
%    \addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-gcc-10000.csv};
    %\addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-llvm-10000.csv};
    %\addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-llvm-10000.csv};
%\legend{chapel-gcc-x86,chapel-clang-x86,chplx-gcc-x86,chplx-clang-x86,chapel-gcc-a64fx,chplx-gcc-a64fx}%,chapel-clang-a64fx,chplx-clang-a64fx} 
%\end{axis}
%\end{tikzpicture}
%\caption{10 thousand elements}
%\label{fig:performance:stream_a}
%\end{subfigure}
%
%\begin{subfigure}[t]{0.45\textwidth}
%
%\caption{1 million elements}
%\label{fig:performance:stream_c}
%\end{subfigure}
%\hfill
%\begin{subfigure}[t]{0.45\textwidth}
%\end{subfigure}
%\caption{ (\subref{fig:performance:heatEqn}) Heat Equation: Strong Scaling, Average Time and (\subref{fig:performance:heatEqn})   }
\end{figure}

%\begin{axis}[grid,ymode=log,xlabel={\# threads},ylabel={Seconds, log scale}, legend columns=2, legend style={at={(0.5,-0.2)},anchor=north east}]



%\begin{figure}[tb]
%\begin{tikzpicture}
%
%\begin{axis}[grid,xlabel={\# threads},ylabel=
%{Data Rate (bytes/time)},legend style={at={(0.5,-0.2)},anchor=north},legend columns=4]
%{Rate},xmin=1,xmax=32, legend pos=north east]
%
%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_copy_rate.csv};
%    \addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_add_rate.csv};
%    \addplot[black,thick,mark=*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_scale_rate.csv};
%    \addplot[black,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_triad_rate.csv};
%
%   \addplot[gray,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_copy_rate.csv};
%    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_add_rate.csv};
%   \addplot[gray,thick,mark=*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_scale_rate.csv};
%    \addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_triad_rate.csv};
%
%    \legend{chpl-copy,chpl-add,chpl-scale,chpl-triad,chplx-copy,chplx-add,chplx-scale,chplx-triad};
%
%\end{axis}
%\end{tikzpicture}
%    \caption{STREAM Copy, Add, Scale, Triad Data Rate Scaling}
%    \label{fig:performance:streamDataRateScaling}
%\end{figure}

%\begin{figure}[tb]
%\begin{tikzpicture}

%\begin{axis}[grid,xlabel={Gigabytes},ylabel=
%{Seconds},legend style={at={(0.5,-0.2)},anchor=north},legend columns=4]
%{Rate},xmin=1,xmax=32, legend pos=north east]

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_copy.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_copy.csv};

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_add.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_add.csv};

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_scale.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_scale.csv};

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_triad.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_triad.csv};

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_copy_rate.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_copy_rate.csv};

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_add_rate.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_add_rate.csv};

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_scale_rate.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_scale_rate.csv};

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chapel_stream_triad_rate.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_triad_rate.csv};
    
    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{4},y expr=\thisrowno{6}, col sep=comma] {summer/chpl_gups_final_data_scaling.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{4},y expr=\thisrowno{6}, col sep=comma] {summer/chplx_gups_final_data_scaling.csv};
    

    %\addplot[black,thick,mark=square*] table [x expr=\thisrowno{5},y expr=\thisrowno{2}, col sep=comma] {summer/chpl_gups_final_data_scaling.csv};
    %\addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{5},y expr=\thisrowno{2}, col sep=comma] {summer/chplx_gups_final_data_scaling.csv};

%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chpl_stream_copy_data_scaling.csv};
%    \addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chpl_stream_add_data_scaling.csv};
%    \addplot[black,thick,mark=*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chpl_stream_scale_data_scaling.csv};
%    \addplot[black,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chpl_stream_triad_data_scaling.csv};

%    \addplot[gray,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_copy_data_scaling.csv};
%    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_add_data_scaling.csv};
%    \addplot[gray,thick,mark=*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_scale_data_scaling.csv};
%    \addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {summer/chplx_stream_triad_data_scaling.csv};

%    \legend{chpl-copy,chpl-add,chpl-scale,chpl-triad,chplx-copy,chplx-add,chplx-scale,chplx-triad};
%
%\end{axis}
%\end{tikzpicture}
%    \caption{STREAM Copy, Add, Scale, Triad Data Scaling w/32 threads}
%    \label{fig:performance:streamDataScaling}
%\end{figure}


%Figures~\ref{fig:performance:scalingA} and ~\ref{fig:performance:scalingB} presents an aggregated view of our results applying different compilation and optimization flags with the Cray Chapel compiler and the ChplX compiler.

Figure~\ref{fig:performance:heatEqn} is shows strong scaling performance for the 1D heat equation code using a log scale due to the magnitude of the values. The input data set size consists of 1 million double precision floating point numbers. %The Cray Chapel compiler demonstrates best performance when compared to the Chplx compiled versions of the applications. The Chplx compiled version of the application equally achieves peak performance at 32 threads. Both compilers appear to experience performance gains under gcc with Chplx appearing to experience the most substantial performance gains as thread counts increase. The Cray Chapel compiler appears to experience an adverse performance behavior on x86 with the Clang backend.

\subsection{GUPS}

The Giga Updates Per Second (GUPS) benchmark~\cite{osti_860347} shown in Figure~\ref{fig:performance:gupsStrongScaling} measures how frequently a machine can update randomly generated memory locations. GUPS inundates the memory system with read and write requests. GUPS measures the machine's ability to perform updates while managing the parallelism implementations present in both the Cray Chapel runtime system and the ChplX/HPX runtime system. This GUPS benchmark is performed over approximately 1 gigabyte of memory. GUPS accesses memory locations that are within the space of half the total systems memory. Memory locations need be within a specific range and have little correlation. Updates are performed after a memory access. The GUPS implementation performs an `xor` on a 64-bit integer with a literal value. The result is stored back into memory. The GUPS benchmark metrics are computed by taking the number of threads, multiplied by the number of bytes processed, and dividing by the time.


%Two versions of GUPS have been implemented with line-for-line equivalency due to the prototype nature of ChplX. The GUPS benchmark metrics are computed by taking the number of threads, multiplied by the number of bytes processed, and dividing by the time.

%Figure ~\ref{fig:performance:gupsStrongScaling} shows Chplx demonstrates best performance after scaling beyond 8 threads. The Chplx-clang compiled application has the steepest performance improvement of the set of experimental results. Performance steadily increases as the thread count increases.
%Figure ~\ref{fig:performance:gupsDataScaling} application performance by time relative to the amount of data processed by the benchmark. Chplx demonstrates advantageous data scaling performance. Figure ~\ref{fig:performance:gups_cmp} is the GUPS benchmark. 

\subsection{STREAM}

The STREAM\cite{McCalpin1995,McCalpin2007} benchmark is designed to measure the amount of sustained memory bandwidth and computational performance of vector kernels. STREAM reflects operations performed by simple computational kernels. The STREAM implementation is performed over an array of a million double precision floating point numbers. This data set size was selected to maintain consistency with the Heat Equation kernel. The STREAM benchmark performs three operations: addition, scale, and copy operation in parallel over varying data set sizes and thread counts. The implementation used for the STREAM performance study is a derivative of what is currently provided with the Cray Chapel compiler. Slight modifications have been made from the original Cray Chapel compiler's source due to current limitations in the ChplX compiler.

% The modified versions of the programs are line for line equivalent in at the Chapel program level.The ChplX version differences apply \textit{inlinecxx} in order to work around lingering compiler bugs related to the previously identified scoping issues.


% analysis - differentials between chapel and ChplX code

\begin{figure}[tb]
   % \begin{subfigure}[t]{0.45\textwidth}
%\begin{tikzpicture}[scale=0.75, transform shape]
%\begin{axis}[grid,xlabel={\# threads},ylabel={Seconds}, legend pos=north east]
%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-gcc-100000.csv};
%    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-llvm-100000.csv};  %  \addplot[blue,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-gcc-100000.csv};
%\addplot[teal,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-llvm-100000.csv};
%    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-gcc-100000.csv};
%    \addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-gcc-100000.csv};    
    %\addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-llvm-100000.csv};
    %\addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-llvm-100000.csv}; 
%\legend{chapel-gcc-x86,chapel-clang-x86,chplx-gcc-x86,chplx-clang-x86,chapel-gcc-a64fx,chplx-gcc-a64fx} %,chapel-clang-a64fx,chplx-clang-a64fx}
%\end{axis}
%\end{tikzpicture}
%\caption{100 thousand elements}
%\label{fig:performance:stream_b}
%    \end{subfigure}
    \begin{subfigure}[t]{0.45\textwidth}
\begin{tikzpicture}[scale=0.75, transform shape]
\begin{axis}[grid,xlabel={\# threads},ylabel={Seconds},legend pos=north east]
    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-gcc-1000000.csv};
    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-llvm-1000000.csv};    
    \addplot[blue,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-gcc-1000000.csv};
    \addplot[teal,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-llvm-1000000.csv};
    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-gcc-1000000.csv};  
    \addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-gcc-1000000.csv};
    %\addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-llvm-1000000.csv};      
    %\addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-llvm-1000000.csv};  
\legend{chapel-gcc-x86,chapel-clang-x86,chplx-gcc-x86,chplx-clang-x86,chapel-gcc-a64fx,chplx-gcc-a64fx} %,chapel-clang-a64fx,chplx-clang-a64fx}    
\end{axis}
\end{tikzpicture}
    \caption{10 million elements}
\label{fig:performance:stream_c}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \begin{tikzpicture}[scale=0.75, transform shape]
    \begin{axis}[grid,xlabel={\# threads},ylabel={Seconds}, legend pos=north east]
    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-gcc-100000000.csv};
    \addplot[gray,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chapel-llvm-100000000.csv};    
    \addplot[blue,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-gcc-100000000.csv};
    \addplot[teal,thick,mark=square*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/stream-triad-chplx-llvm-100000000.csv};
    \addplot[blue,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-gcc-100000000.csv};
    \addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-gcc-100000000.csv};
    %arm-triad-chplx-gcc-100000000.csv};    
    %\addplot[gray,thick,mark=triangle*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chapel-llvm-100000000.csv};
    %\addplot[black,thick,mark=diamond*] table [x expr=\thisrowno{0},y expr=\thisrowno{1}, col sep=comma] {2025_jan/arm-triad-chplx-llvm-100000000.csv};       
\legend{chapel-gcc-x86,chapel-clang-x86,chplx-gcc-x86,chplx-clang-x86,chapel-gcc-a64fx,chplx-gcc-a64fx} %,chapel-clang-a64fx,chplx-clang-a64fx}
\end{axis}
    \end{tikzpicture}

    \caption{100 million elements}
\label{fig:performance:stream_d}
    \end{subfigure}

    \caption{STREAM Benchmark}
    \label{fig:stream_bench}
\end{figure}


%\begin{figure}[tb]
%\begin{tikzpicture}
%
%\begin{axis}[grid,xlabel={Gigabytes},ylabel={Seconds},legend style={at={(0.03,0.85)},anchor=west}]
%
%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{5},y expr=\thisrowno{2}, col sep=comma] {summer/chpl_gups_final_data_scaling.csv};
%    \addplot[gray,thick,mark=square*] table [x expr=\thisrowno{5},y expr=\thisrowno{2}, col sep=comma] {summer/chplx_gups_final_data_scaling.csv};
%    
%    \legend{chapel,chplx};
%   
%\end{axis}
%\end{tikzpicture}
%    \caption{GUPS, 1GB Data Scaling Average}
%    \label{fig:performance:gupsDataScaling}
%\end{figure}
%
%\begin{figure}[tb]
%\begin{tikzpicture}
%
%\begin{axis}[grid,xlabel={\# threads},ylabel={Giga-Updates/second  (GUPS)},xmin=1,xmax=32,legend style={at={(0.03,0.85)},anchor=west}]
%
%    \addplot[black,thick,mark=square*] table [x expr=\thisrowno{1},y expr=\thisrowno{3}, col sep=comma] {summer/chpl_gups_final_time_total_data.csv};
%    \addplot[gray,thick,mark=square*] table [x expr=\thisrowno{1},y expr=\thisrowno{3}, col sep=comma] {summer/chplx_gups_final_time_total_data.csv};
%    \legend{chapel,chplx};
%    
%\end{axis}
%\end{tikzpicture}
%    \caption{GUPS \(n\_threads*bytes \div seconds \div 1e9\), Giga-Updates Per Second, 1GB Strong Scaling}
%    \label{fig:performance:gups_cmp}
%\end{figure}


%Figures~\ref{fig:performance:streamStrongScaling}, ~\ref{fig:performance:streamDataRateScaling}, ~\ref{fig:performance:streamDataScaling}
%The performance figures for STREAM~\ref{fig:performance:stream_e} show the Cray Chapel compiler continues to demonstrate better performance for both compilation options. Chplx performance improves substantially as the data set sizes increase over a 100 thousand elements. Figures ~\ref{fig:performance:stream_c} ~\ref{fig:performance:stream_d} show Chplx begins to close the performance gap with the Cray Chapel compiler. Generally speaking, as data set sizes increase, Chplx performance increases.

\subsection{Performance Summary}

%Cray's Chapel runtime system manages parallelism using Sandia's Qthreads library~\cite{qthreads}. Qthreads multi-threading emphasizes Multi-Threaded Apartment (MTA) and Processing-In-Memory (PIM). Qthreads offers Full-Empty Bit (FEB) support on any word of memory in a program. Qthreads are assigned to \textit{shepards} which control the ability for Qthreads to move or migrate during execution.

% The HPX runtime system implements a work-stealing thread scheduler managing a user-land thread implementation. HPX user-land threads operate over a queue of operating system threads. HPX's multithreading implementation is designed to achieve support for millions of concurrent thread instances. The implication of the HPX design choice is the scaling profile achieved in Figure ~\ref{fig:performance:stream_e}.

ChplX demonstrates good performance and performance scaling based on the benchmarks presented in this study. Generally speaking, as data set sizes increase, Chplx performance increases. The ChplX C\texttt{++} library mirrors Chapel's features while maintaining high performance scalability. The ChplX compiler's emphasis on line-for-line source-to-source translation creates C\texttt{++} programs capable of maintaining competitive performance targets with respect to software compiled with the Cray Chapel compiler.

%The performance studies all use equivalent compilation settings and compilers. The performance studies result in a comparison between implementations of two different versions of the Chapel runtime system. The Cray Chapel compiler's runtime system implements data parallel language functionality using Qthreads. ChplX implements Chapel-equivalent data parallel language functionality using HPX. We believe the performance differentials shown in Figure~\ref{fig:performance:heatEqn}, \ref{fig:performance:stream_e}, and \ref{fig:performance:gupsStrongScaling} are artifacts from each language implementation's runtime system.

%ChplX provides a different scaling profile that surpasses the Cray Chapel compiler's performance at 34 software threads on a 64 core machine. This difference is consistent with findings from the previous study~\cite{diehl2023benchmarking}. The Cray Chapel compiler, with \textit{--fast} optimization, offers better performance for scenarios where the software thread count is scaled to around 20-24 software threads. After ~24 threads the compiled application begins to experience a performance decline.

The heat equation kernel yielded Figure~\ref{fig:performance:heatEqn}. The kernels performance demonstrates the Cray Chapel compiler and the ChplX compiler have similar strong scaling profiles. The performance differences are believed to be a function of the runtime systems. Chplx on other benchmarks achieves improved performance scaling when the data set size exceeds a million elements. We believe that since the data set amount is fixed to 1 million elements similar performance improvements would be apparent as the data set size increases.

The STREAM benchmark in Figure ~\ref{fig:stream_bench} shows the Chplx/HPXruntime system offers performance that is comparable to the Cray Chapel compiler's runtime system. It's also clear that for large problem sizes Chplx can achieve performance targets consistent with those achieved by the Cray Chapel compiler.

%% TODO

The GUPS benchmark in Figure~\ref{fig:performance:gupsStrongScaling} shows a performance gap between ChplX and the Cray Chapel compiler. Chplx manages to exceed the Cray Chapel compiler's performance in this particular study across x86 and A64FX. We attribute this performance differential as a by product of Chplx's support libraries' use of HPX and the memory system.

\subsection{Source Complexity}

The ChplX compiler closes the complexity gap between Chapel and ISO C\texttt{++} HPX applications. The metrics used to define the code complexity gap are the COCOMO Estimated Scheduled Effort and Lines of Code. Closing the gap means there is an approximate line-for-line equivalency between Chapel programs and ChplX generated C\texttt{++} programs.

Figure~\ref{fig:loc} and ~\ref{fig:cocomo} show 3 frequencies between Chapel, C\texttt{++}, and Boilerplate over each benchmark. Chapel frequency measures the Chapel implementation of each benchmark under both metrics. ChplX generates several support files (header files, program driver files) along with the application specific program file. The application specific program file contains all the lines of code that directly correspond to the input Chapel program. C\texttt{++} frequency measures the C\texttt{++} application specific program file generated by ChplX. Boilerplate frequency captures measurements made with the application specific program file and the support files generated by ChplX.

The first quantitative measurement presents LoC measurements in Figure~\ref{fig:loc} using the cloc Linux tool. cloc has been directed to exclude comments and empty lines in the program files. The figure shows ChplX achieves a 5 line of code difference between all benchmarks.

The second quantitative measurement presents the COCOMO Estimated Schedule Effort. The previous heat equation study~\cite{diehl2023benchmarking} uses Estimated Schedule Effort (ESE). This paper exercises the same COCOMO metric for consistency. The ESE difference between each benchmark is ~0.7 ESE on average with a 0.6 median.

The differences between the Chapel Benchmark applications and the ChplX generated C\texttt{++} application software are marginal. A review of the software's generated source program shows the differences in the C\texttt{++} application software relate to the creation of namespaces and include directives. The program driver itself consists of a header file and program file and approximately 5 lines of software that initializes the HPX runtime system.

\pgfplotsset{compat=1.11,
    /pgfplots/ybar legend/.style={
    /pgfplots/legend image code/.code={%
       \draw[##1,/tikz/.cd,yshift=-0.25em]
        (0cm,0cm) rectangle (3pt,0.8em);},
   },
}

\begin{figure}[tb]
    \centering
    \begin{subfigure}[t]{0.45\textwidth}
        \pgfplotstableread[col sep=comma,]{loc_histogram.csv}\datatable
\begin{tikzpicture}[scale=0.75, transform shape]
\begin{axis}[
    ybar,
    xlabel={Benchmark},
    xtick=data,
    xticklabels from table={\datatable}{Benchmark},
    ybar=2*\pgflinewidth,
    ymin=0,
    scaled y ticks = false,
    ytick distance=10,
    ylabel={LoC},
    legend style={at={(0.0,1.0)}, anchor=north west}
    ]
    \addplot table[x expr=\coordindex, y={Chapel}] {\datatable};
    \addplot table[x expr=\coordindex, y={Cpp}] {\datatable};    
    \addplot table[x expr=\coordindex, y={Boilerplate}] {\datatable}; 
\legend{Chapel, ChplX C++, ChplX Boilerplate};
\end{axis}
\end{tikzpicture}
    \caption{Lines of Code Measurements}
    \label{fig:loc}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.45\textwidth}
    \pgfplotstableread[col sep=comma,]{cocomo_data.csv}\datatable
\begin{tikzpicture}[scale=0.75, transform shape]
\begin{axis}[
    ybar,
    xlabel={Benchmark},
    xtick=data,
    xticklabels from table={\datatable}{Benchmark},
    ybar=2*\pgflinewidth,
    ymin=0,
    scaled y ticks = false,
    ylabel={Estimated Schedule Effort},
    legend style={at={(0.0,1.0)}, anchor=north west},
    axis y line=right
    ]
    \addplot table[x expr=\coordindex, y={Chapel}] {\datatable};
    \addplot table[x expr=\coordindex, y={Cpp}] {\datatable};    
    \addplot table[x expr=\coordindex, y={Boilerplate}] {\datatable}; 
\legend{Chapel, ChplX C\texttt{++}, ChplX Boilerplate};
\end{axis}
\end{tikzpicture}
    \caption{COCOMO: Estimated Schedule Effort}
    \label{fig:cocomo}
    \end{subfigure}
    \caption{Software estimates: (\subref{fig:loc}) Lines of code and (\subref{fig:cocomo}) estimated schedule effort using COCOMO.}
    \label{fig:enter-label}
        \vspace{-5mm}
\end{figure}







% \subsection{Visualization}

% %\begin{figure}[h!]
% %\centering
% %  \begin{subfigure}[b]{0.5\textwidth}
% %\centering
% %\includegraphics[width=\textwidth]{figures/gantt_view.png}
% %  \caption{Traveler's Gantt View}
% %\label{fig:civa_accuracy1}
% %\end{subfigure}
% %\hfill
% %  \begin{subfigure}[b]{0.5\textwidth}
% %\centering
% %\includegraphics[width=\textwidth]{figures/utilization_view.png}
% %  \caption{Traveler's Utilization View}
% %\label{fig:civa_accuracy2}
% %\end{subfigure}
% %\hfill
% %  \begin{subfigure}[b]{0.5\textwidth}
% %\centering
% %\includegraphics[width=\textwidth]{figures/histogram_interval_view.png}
% %  \caption{Traveler's Histogram Interval View}
% %\label{fig:civa_accuracy2}
% %\end{subfigure}
% %\caption{Traveler Visualizations from APEX trace data of the ChplX program}
% %\end{figure}
% %
% %\vfill

% \begin{figure*}
% \includegraphics[width=\textwidth,height=6cm]{figures/dependency_tree_aggregated_view.png}
%   \caption{Traveler's Dependency and Aggregated Gantt Chart View}
% \label{fig:civa_accuracy3}
% \end{figure*}


% \vfill

% Traveler represents performance using an interval based metric. Intervals are related to tasks. Intervals can represent tasks and intervals can be composed together into tasks. Intervals have a start and end time, a globally unique identifier (GUID), an optional parent GUID, a location to identify which compute resource executed the interval, and a primitive name which describes what the interval was part of executing. In programming terms, intervals are an event type. Figures 5.a, 5.b, and 5.c are different views represented in Traveler for performance information regarding the execution of intervals in a ChplX program. 

% Figure 5.a is a Gantt chart view provided by the Traveler performance analysis tool. The Gantt chart represents resource state over time. Rows represent a particular compute resource, a software thread or hardware thread. The rectangular bars over the row represent intervals in time where the specific resource is being utilized.

% Figure 5.b is a utilization view provided by Traveler. The utilization view presents total compute resource utilization over time. The height of the chart is the total amount of resource activity at a specific point in time over the total runtime of the application's intervals. The view allows users to select a range which creates highlights in the other views to show which portions of the other visualizations represent the range selected in the utilization view.

% Figure 5.c is a histogram interval view. The histogram interval view shows performance interval information binned by the entire program time. The x-axis in the view is a bin storing frequency information for intervals that co-occur in time. Users can select a range of intervals binned together and other parts of Traveler are dynamically updated with highlights to help users navigate the collection of performance data and computed analytics. Figure 5.c was exercised in this study to navigate and identify Figures 5.a and 5.b.

% The Figure 5.a and Figure 5.b indicates there are some performance gaps that can be addressed in the HPX runtime system to close the performance gap.

% %%%%%%%%%%%%% TODO
% %% add analysis, how the performance can be improved

% The Traveler views in Figure 5.a, 5.b, and 5.c provide convenient mechanisms to quickly identify bottlenecks in the C++ application software running HPX. The highlighted interval in Figure 5.a is the location where CPU utilization graph is at its lowest. The selection information in Figure 5.a is presented in a view that is adjacent to the interval visualisation. The selection information communicates the location in C++ source code where the performance regression occurs. Traveler creates a feedback loop for further performance tuning.

% The left side of Figure 6 is Traveler's dependency graph visualization. The dependency graph shown represents the interval selected in Figure 5.a. The right side of Figure 6  the corresponding aggregate Gantt chart for the dependency graph. Navigation of both the dependency graph and the Gantt chart can be driven by either chart. Selecting an interval on the Gantt chart selects the associated node in the dependency graph. Selecting a node in the dependency graph selects intervals in the Gantt chart.

% The selected region of the Gantt chart highlighted the dependency graph node for the \textit{chplx::forall(Target \&\&, F \&\&, Args \&\&...)} function in the application software. The function invocation is a ChplX library call the ChplX compiler used in the generated program. The specific call is implemented in the ChplX library in the file "forall\_loop.hpp" on line 198.

% Figure 6 allows the user to navigate the code and identify more granular task intervals. The nodes in the dependency graph can be changed with the User Interface. Traveler updates the right side of the visualization to show performance metrics corresponding to selected dependency tree node, providing better visual insights.

% The performance profile of the overall data parallel tasks in C++-based program is a known quantity~\cite{diehl2023benchmarking}. Given the benchmarks made in the previous study, the performance bottleneck in the ChplX generated C++ program is shared in the original Chapel program. As the ChplX compiler is a source-to-source tool specifically aimed at a line-to-line translation to C++ using the ChplX library, a developer can quickly navigate through the ChplX generated application software, find a ChplX compiler provided comment pointing back to the original Chapel program, and quickly assess if the performance bottleneck is in the Chapel program or in the ChplX compiler generated C++ source code.

% The performance bottleneck in Figure 6 is caused by the implementation of Chapel-style data parallel for loops in the ChplX library. As of this publication, and after our performance assessments, we believe the existing performance gap can be closed with additional effort applied in the ChplX library and HPX.

\section{Conclusions \& Future work}

The ChplX compiler demonstrates that source-to-source compilation to ISO C\texttt{++}20 combined with HPX, a standards conforming asynchronous many-task runtime system, can yield competitive high performance with the Cray Chapel compiler. The ChplX compiler is the end product of a 6 month collaboration yielding a solution that tightens the source code complexity gap between Chapel and ISO C\texttt{++}. The ChplX compiler prototyped and demonstrates the `inlinecxx` functionality works within the existing syntactic framework offered by Chapel. Development of the Chplx compiler identified a syntactic structural issue in the Chapel parsing infrastructure that complicates syntax driven compilation. The ChplX compiler shows Chapel's potential as a high performance frontend language for ISO C\texttt{++}. 

Future work will address ChplX compilation bugs that were discovered during implementation of the benchmarks. The performance gaps ChplX experiences will be studied and improved with experimentation with HPX's suite of executors. We intend to additionally investigate implementation of GPU support. Future studies can expand on this work by using additional benchmark codes to expand ChplX's language support. % as part of the effort to expand Chplx's existing language support: LULESH, HPCC RA, HPCC PTRANS, HPCC FFT, HPCC HPL, miniMD, LNLL CoMD, SSCA\#2 kernel 2, SSCA\#2 kernel 3, SSCA\#2 kernel 4, and SSCA\#2 graph construction.

\section*{Acknowledgments}
\footnotesize
The authors would like to thank Stony Brook Research Computing and Cyberinfrastructure and the Institute for Advanced Computational Science at Stony Brook University for access to the innovative high-performance Ookami computing system, which was made possible by a \$5M National Science Foundation grant (\#1927880). This work was supported by the U.S. Department of Energy through the Los Alamos National Laboratory. Los Alamos National Laboratory is operated by Triad National Security, LLC, for the National Nuclear Security Administration of U.S. Department of Energy (Contract No. 89233218CNA000001). LA-UR-25-21252
%HPE/Cray for providing the Cray Chapel compiler and 
%respective codes to the general public under the Apache 2 
%license. LSU Center for Computation and Technology and 
%Tactical Computing Labs for their respective support with 
%this effort. Special thanks to Kate Isaacs, Kevin Huck, and 
%Steve Brandt for their respective assistance and support 
%with APEX and Traveler.

%
%
%

%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
% \bibliographystyle{splncs04}
% \bibliography{mybibliography}
%
\footnotesize
\bibliographystyle{plain}
\bibliography{chapel}

\end{document}