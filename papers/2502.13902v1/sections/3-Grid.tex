
%\yao{it comes a bit out of the blue to have the user study directly after the RW. Is there sufficient meat to have a method section? There you could theoretically talk about the grid-based approach, such as motivation, pipeline (which should be different from study procedure), and maybe implementation details}

\section{Grid Labeling}
\begin{figure}[t]
    \centering
    \includegraphics[width=0.95\linewidth]{figures/grids.pdf}
    \caption{Comparison of Static and Adaptive Grid segmentations applied to a histogram from CharXiv~\cite{charxiv}. Static Grid splits the visualization into equal-sized rectangles, while Adaptive Grid dynamically produces patches that fit the visualization layout.}
    \label{fig:grids}
    \vspace{-5mm}
\end{figure}
% \yao{Another argument for using grids: the circle of BubbleView and Gaussian kernel of saliency maps cannot preserve the shapes of visualization elements, which are usually rectangular. \cite{scanpath}} 
Existing saliency and importance annotation methods use circular~\cite{bubbleView} or freeform~\cite{importAnnot} shapes, which do not preserve the structure of visual elements, particularly when creating saliency maps by Gaussian kernels~\cite{scanpath}.
Inspired by Google's reCaptcha~\cite{recaptcha}, we propose \textbf{Grid Labeling}, a patch-based annotation approach that addresses this limitation. With Grid Labeling, users annotate specific areas by clicking on image patches (\autoref{fig:grids}). This binary interaction\,---\,clicking or not clicking\,---\,enforces discrete annotations, facilitating faster response aggregation by promoting higher consensus. 
% \will{``dichotomous annotations'' sounds a bit obscure}

\subsection{Static Grid} \label{grids:static}
As a baseline, we first designed the Static Grid by dividing the visualization’s height and width into N equal sections, resulting in $N^2$ patches. We leave N as a hyperparameter, which was set to 8 in our experiment. This made the patch size approximately equivalent to the recommended circle size in BubbleView~\cite{bubbleView}. 

\subsection{Adaptive Grid} \label{grids:adaptive}
To further reduce annotation time and effort, we introduce an Adaptive Grid that groups smaller \textit{tiles} into larger \textit{blocks} aligned with the visualization’s layout.

\noindent\textbf{Step 1: Split Regions.}
We divide the visualization into three regions: text, edge, and background. We filter out the text area with PaddlePaddle OCR~\cite{paddlepaddle}, followed by the Canny edge detection algorithm~\cite{canny} to extract graphical elements. The remaining tiles not identified as text or edges are labeled as background.

\noindent\textbf{Step 2: Defining the Tile Space.}
Let's assume we are filling in the visualization with small tiles with the size of $t$ (e.g., 32px), which is the minimum patch size. 
Then the image would be covered with a grid of tiles with dimensions $M \times N$ ($M=\left\lfloor \text{Height} / t \right\rfloor, N=\left\lfloor \text{Width} / t \right\rfloor$), forming $G \in \{0,1\}^{M \times N}$. 
We individually build the binary grid for each region (text, edge, or background), which will be covered with larger blocks in Step 3. 
Each entry $G_{i,j}$ is set to 1 if tile $(i,j)$ belongs to the selected region and 0 otherwise. 
% \will{could be helpful to explain what t and G means. Now it's just mathematical definitions. we know how G is defined, but what does it \textit{mean}? this could help build intuition for your readers}

\noindent\textbf{Step 3: Optimizing Block Arrangement.}
We then assign larger rectangular blocks that can minimally cover the entire grid. Define binary decision variables $B_{i,j}^{w,h} \in \{0,1\}$, where $B_{i,j}^{w,h} = 1$ indicates that a rectangular block of size $w \times h$ tiles is placed with its top-left corner at tile $(i,j)$. Our objective is to minimize the total number of blocks:
$\min \sum_{i,j,w,h} B_{i,j}^{w,h}$
, while the entire region must be covered once without overlap between the blocks. This merges coverage and non-overlap requirements into a single constraint:
% \will{maybe helpful to clarify what you mean by coverage and non-overlap requirements here? if your objective is to minimize the total number of blocks, what is stopping you from merging all tiles into one? To me, the objective is clear, but the constraints are not.} 
\[
\sum_{\substack{(i',j',w,h) \\ i' \leq i < i'+h,\; j' \leq j < j'+w}} B_{i',j'}^{w,h} \;=\; G_{i,j}, 
\quad \forall (i,j).
\]
We solve this optimization problem using Integer Linear Programming (ILP) with OR-Tools’ constraint programming solver~\cite{ortools}. By enforcing the exact coverage of each tile, we get patches that cover the visualization while respecting the background contents