% This is samplepaper.tex, a sample chapter demonstrating the
% LLNCS macro package for Springer Computer Science proceedings;
% Version 2.21 of 2022/01/12
%

\documentclass[runningheads]{llncs}
%
\usepackage[T1]{fontenc}
% T1 fonts will be used to generate the final print and online PDFs,
% so please use T1 fonts in your manuscript whenever possible.
% Other font encondings may result in incorrect characters.
%

%%%%% pre-existing commands %%%%%

\usepackage{graphicx}

%%%%% new commands %%%%%

\usepackage{cite}
\usepackage{amssymb,amsfonts}
\usepackage{esvect}

\usepackage{macros}
\usepackage{float}
\usepackage{tcolorbox}
\usepackage{stmaryrd}
\usepackage{centernot} % puts a negation dash at the center of the symbol
\usepackage{soul} % to define the highlight command properly
\usepackage{mathpartir,bussproofs}
\usepackage{mathtools}
\usepackage{mathrsfs}
\usepackage{arydshln}
\usepackage{anyfontsize}
\usepackage{thm-restate}
\usepackage{hyperref}
\usepackage{cleveref}
\usepackage{mdframed}
\usepackage{algorithm,algpseudocode}
\usepackage{graphicx}%

% Used for displaying a sample figure. If possible, figure files should
% be included in EPS format.
%
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
\usepackage{color}
\renewcommand\UrlFont{\color{blue}\rmfamily}
%\urlstyle{rm}
%
%\newcommand{\MF}[1]{{\color{magenta}{\noindent #1}}}


\SetSymbolFont{stmry}{bold}{U}{stmry}{m}{n}
%\newcommand{\daniele}[1]{\textcolor{magenta}{DN:#1}}


\begin{document}
%
\title{Equational Reasoning Modulo Commutativity in Languages with Binders}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Ali K. Caires-Santos\inst{1} \orcidID{0009-0004-3183-3686} \and
Maribel Fern\'andez\inst{2} \orcidID{0000-0001-8325-5815}\and
Daniele Nantes-Sobrinho\inst{1,3} \orcidID{0000-0002-1959-8730}}
%
\authorrunning{A.K Caires-Santos et al.}
% First names are abbreviated in the running head.
% If there are more than two authors, 'et al.' is used.
%
\institute{University of Bras\'ilia, Brazil \and
King's College London, UK\\
%\email{lncs@springer.com}
\and
Imperial College London, UK\\
%\email{\{abc,lncs\}@uni-heidelberg.de}}
}
%
\maketitle              % typeset the header of the contribution
%
\begin{abstract}
Many formal languages include binders as well as operators that satisfy equational axioms, such as commutativity. Here we consider the nominal language, a general formal framework which provides support for the representation of binders, freshness conditions and $\alpha$-renaming. 
Rather than relying on the usual freshness constraints, we introduce a nominal algebra which employs  permutation fixed-point constraints in $\alpha$-equivalence judgements, seamlessly integrating commutativity into the reasoning process.
We establish its proof-theoretical properties and provide a sound and complete semantics in the setting of nominal sets.
Additionally, we propose a novel algorithm for nominal unification modulo commutativity, which we prove terminating and correct.  By leveraging fixed-point constraints, our approach ensures a finitary unification theory, unlike standard methods relying on freshness constraints.
%Moreover, thanks to the use of fixed-point constraints, the resulting unification theory is finitary, unlike the standard nominal unification modulo commutativity using freshness constraints.
%This extension provides a robust foundation for structural induction and recursion over syntax with binding constructs and commutative operators, such as first-order logic and the $\pi$-calculus, enabling reasoning modulo both  $\alpha$-equivalence and commutativity.
This framework offers a robust foundation for structural induction and recursion over syntax with binders and commutative operators, enabling reasoning in settings such as first-order logic and the $\pi$-calculus.

\keywords{Languages with binders \and Unification \and Equational theories.}
\end{abstract}
%
%
\section{Introduction}

In computer science and logic, formal languages abstract away concrete syntax details, focusing on abstract syntax to capture structural properties. However, conventional abstract syntax falls short for languages with variable-binding constructs.
%
%\alert{Introduction from CSL -- needs updating}
%
The formalisation  of languages with binding is challenging and requires specialised tools: one of the aims of the POPLMark challenge~\cite{DBLP:conf/tphol/AydemirBFFPSVWWZ05} was to explore and compare methods for the formalisation of binding operators. Many different techniques were proposed to address the challenge, for example, the approach based on  higher-order abstract syntax (HOAS) is described  in the survey~\cite{DBLP:journals/jar/FeltyMP15} by Felty et al.
%has an interesting survey~\cite{DBLP:journals/jar/FeltyMP15}. 
Here we follow the nominal approach, introduced by Gabbay and Pitts~\cite{DBLP:journals/fac/GabbayP02}: Binders are specified using an abstraction construct of the form $[a]t$, where $a$ is a name and $t$ an arbitrary expression (read ``abstract $a$ in $t$'').

Nominal syntax~\cite{DBLP:journals/fac/GabbayP02} makes a distinction between \emph{names} $a,b,...$ (also called atoms), which can be abstracted but cannot be substituted, and \emph{(meta-)variables} $X,Y,...$ (also called \emph{unkowns}), which can be substituted but not abstracted.
%Nominal sets provide a semantics for nominal syntax. Given an infinite countable set $\mathbb{A}$ of atoms, \alert{a nominal set is a set $X$ equipped with an action of the group of all finite permutations on $\A$, 
%denoted $\Perm{\A}$, 
%such that every element has a finite support.} Intuitively, the support of a term $t$ is the set of unabstracted atoms occurring in $t$. %Recall that a \emph{support} of an element $x$ is a set $S$ of atoms such that for all $\pi$ with $\dom{\pi} \cap S = \emptyset$  we have $\pi\cdot x = x$.
The $\alpha$-equivalence relation $\approx$ is defined using the notion of support, or equivalently, the notion of freshness, a concept that generalises the idea of an atom not being free in a term: $a$ is \emph{fresh} for  $t$, written $a \fresh t$, if $a$ is not in the support of $t$.
%\alert{Nominal unification (i.e., solving   $\alpha$-equivalence constraints)  
%Two nominal terms $s, t$ are unifiable if there exists a substitution $\sigma$ for the variables in $s,t$ such that $s\sigma \approx t\sigma$.
% Hence, nominal unification refers to the satisfiability of a constraint of the form $s \approx t$ in the quotient by $\alpha$-equality of the ground term algebra. 
%is decidable and unitary~\cite{DBLP:journals/tcs/UrbanPG04}: any satisfiable constraint has a most general unifier  $(\Delta,\sigma)$ where $\Delta$ is a set of freshness constraints of the form $a \fresh X$ and $\sigma $ a substitution.}

More generally, in languages where operators are subject to equational axioms $E$, such as associativity ($\tf{A}$) and commutativity ($\C$), the equivalence relation of interest is generated by $\alpha$ and  $E$.
A well-known example is first-order logic with $\forall$ and $\exists$ quantifiers and conjunction and disjunction connectives; similarly, in Milner's $\pi$-calculus expressions are considered modulo a structural congruence. 
Effective reasoning techniques for such languages are essential, particularly when proving properties about them in a proof assistant. A common subproblem in this context is solving unification problems—finding the appropriate {\em substitution} that equates two expressions—when applying lemmas in automated proofs.

%includes commutativity and associativity axioms for sums and parallel process composition.

Although unification of first-order terms modulo commutativity is decidable and finitary,   and nominal unification is unitary (every solvable problem has a unique most general unifier), unification modulo $\alpha$ and $\C$ is not finitary if solutions are expressed using substitutions and freshness contexts~\cite{DBLP:journals/mscs/Ayala-RinconSFS21}. This motivated the study of a version of nominal syntax where the $\alpha$-equivalence relation is specified using permutation fixed-point constraints $\pi \fix{} t$ (read ``$\pi$ fixes $t$)'' instead of freshness constraints~\cite{DBLP:journals/lmcs/Ayala-RinconFN19}.
However,  the derivation relation defined in~\cite{DBLP:journals/lmcs/Ayala-RinconFN19} is sound for strong nominal algebras~\cite{10.1561/2500000017,DBLP:journals/corr/abs-1006-3027} only (that is, the carriers should be strong\footnote{A nominal set is strong iff its elements are strongly supported by finite sets, i.e., whenever a permutation fixes an element $x$ of the set then it has to fix the atoms occurring in $x$ pointwise.} nominal sets). Soundness with respect to the standard nominal set models was proved only for a restricted calculus in~\cite{entics:14777}.

\paragraph*{Contributions.} The system presented in this paper is a generalisation of the latter in two ways: judgements here can include arbitrary fixed point constraints in contexts, and equational axioms are taken into account, making the system more expressive while maintaining soundness for standard nominal set models. Devising a proof system for general fixed point judgements that is sound and complete  is challenging; the difficulty lies in the variable rule, which needs to be sufficiently powerful to derive all the valid judgements, but only those that are valid in all nominal set models.  A key idea to obtain soundness and completeness with respect to standard nominal set semantics is to analyse the permutation cycles in fixed-point assumptions.
%This is achieved by a careful analysis of the fixed-point constraints in the context to identify the permutation subgroups associated with each variable in the judgement.  
%To recover soundness for nominal set models, a restricted class of permutation fixed-point contexts should be used~\cite{entics:14777}, where the assumptions are {\em primitive} fixed-point constraints of the form  $\new c.(a \ c) \fix{} X$  (here $\new$ is nominal logic's ``new'' quantifier~\cite{PittsA:noml})
%which quantifies over new names).



%In this paper we consider arbitrary fixed-point constraints and develop a novel notion of nominal algebra with an alternative proof system for $\alpha$-equality 
%and fixed-point constraint 
%judgements, which we prove sound and complete with respect to standard nominal set semantics. 


We also study  satisfiability of equality constraints: we  show that nominal unification is decidable and unitary if $E = \emptyset$, and it is finitary if $\C$ommutativity axioms are included. More precisely, we provide a unification algorithm specified as a set of simplification rules on unification problems, which we show terminating
and correct. 
The normal forms of the simplification system consist of a finite set ($\Upsilon$) of  fixed-point constraints and a substitution. The algorithm outputs a most general solution of the form $(\Upsilon,\sigma)$ if $E = \emptyset$ and  a finite complete set of solutions of the form $(\Upsilon_i,\sigma_i)$ if $E = \C$. Having a finitary theory is important in practice, for example to design  programming languages and theorem provers that support binders and equational axioms, to specify completion procedures for rewriting modulo $\alpha$ and $E$, etc.
A notable feature of our unification algorithm is its treatment of computed {\em substitutions}: it ensures that meta-variables are instantiated while maintaining stability under renaming of bound names—preserving consistency when fresh names are introduced during computation (see Remark~\ref{rmk:substitution}).

%where $\Phi$ is a set of fixed-point constraints of the form $\pi \fix{} X$.
%In contrast, nominal unification modulo commutativity is not finitary if solutions are expressed using freshness constraints instead of permutation fixed-point constraints. 

%\MF{Check if the next points are already covered above} Our results are summarised as follows:
%\begin{itemize}
 %   \item We propose a new notion of nominal algebra and a corresponding set of derivation rules for 
    %permutation 
  %  commutative ($\C$) %fixed-point constraints and 
   %$\alpha$-equality constraints (denoted $s~  \faeq{C} ~t$), which generalises  previous versions of nominal algebra.
   %, using the $\new$-quantifier.
    %\item We prove that this specification is correct (Theorem~\ref{thm:correctness}): a fixed-point constraint $\pi\fix{C}t$ corresponds to its intentional semantics, i.e.,  $\pi\cdot t\approx_{C} t$.
    %\item About validity: We give semantics to $\C$ fixed-point constraints and prove that our commutative nominal algebra is sound and complete w.r.t.\ nominal sets (Theorems~\ref{thm:soundness_fix} and ???).
    %\item  About satisfiability: We define a rule-based algorithm for nominal unification (with empty equational theory) using our fixed-point constraints, and prove it correct (Theorem~\ref{thm:correctness-simp-rules}). We extend this algorithm to take into account commutative operators, thus obtaining a rule-based algorithm for nominal $\C$-unification, which is also proven correct (Theorem~\ref{thm:c-correct}).
%\end{itemize}


%\paragraph*{Overview of the paper.}
%This paper is organised as follows.
%Section~\ref{sec:background} contains the necessary background on  nominal algebra. Section~\ref{sec:constraints} introduces fixed-point constraints and judgements with $\new$-quantified atoms as well as the derivation rules implementing $\C$-$\alpha$-equivalence. In Section~\ref{sec:soundness} we prove that commutative nominal algebra with fixed-point constraints is sound for nominal sets. In Sections~\ref{sec:unification} and \ref{sec:cunification} we investigate satisfiability problems for our nominal algebra via the study of nominal unification and nominal $\C$-unification.  Section~\ref{sec:conclusion} concludes the paper.
Proofs of selected results can be found in the Appendix. An extended version with all the proofs is available in~\cite{arxiv/cairessantos2025}.

\section{Preliminaries}\label{sec:preliminaries}

In this section, we introduce some basic notions and notations used throughout the paper; for more details we refer the reader to~\cite{book/Pitts, DBLP:journals/fac/GabbayP02, DBLP:journals/logcom/Gabbay09}.

\subsubsection*{Nominal Syntax.}
Fix disjoint countably infinite sets $\mathbb{A} = \{a,b,c,\ldots\}$ of {\em atoms} and $\V = \{X,Y,Z,\ldots\}$ of {\em variables}. A {\em signature} $\Sigma$ is a set of {\em term-formers} ($\tf{f},\tf{g},\ldots$) $-$ disjoint from $\A$ and $\V$ $-$ where each $\tf{f}\in \Sigma$ has a fixed \emph{arity} $n\geq 0$, denoted $\tf{f}:n$.
% We follow Gabbay’s \emph{permutative convention} \cite{DBLP:journals/fac/GabbayP02}: atoms $a, b$ range permutatively over $\A$, and therefore, saying two atoms $a$ and $b$ are distinct is unnecessary.
%
A {\em finite} permutation $\pi$ of atoms is a bijection $\A \to \A$ such that the set $\dom{\pi} := \{a \in\A \mid \pi(a) \neq a\}$ is finite. Write $\id$ for the {\em identity permutation}, $\pi\circ \pi'$ for the {\em composition} of  $\pi$ and $\pi'$, and $\pi^{-1}$ for the {\em inverse} of $\pi$.
We use {\em swappings} of atoms of the form $(a\ b)$ to implement the renaming of atoms, for the purpose of $\alpha$-conversion.   Given two permutations $\pi$ and $\rho$, the permutation $\pi^\rho = \rho\circ\pi\circ\rho^{-1}$ denotes the {\em conjugate} of $\pi$ with respect to $\rho$.

 \emph{Nominal terms} are defined inductively by the following grammar:
\[ s,t,u::= a \mid \pi\act X \mid \tf{f^E}(t_1,\ldots, t_n) \mid [a]t \]
where $a$ is an {\em atom}; $\pi\act X$ is a {\em suspension}, where $\pi$ is an atom permutation. Intuitively, $\pi\act X$ denotes that $X$ will get substituted for a term and then $\pi$ will permute the atoms in that term accordingly (i.e., the permutation $\pi$ is suspended). Suspensions of the form $\id\act X$ will be represented simply by $X$; {\em a function symbol} $\tf{f} : n$ of arity $n$ may be equipped with an equational theory $\tf{E}$, hence $\tf{f^E}(t_1,\ldots, t_n)$ denotes the \emph{application} of $\tf{f^E}$ to a tuple $(t_1,\ldots, t_n)$. We write $\tf{f^\emptyset}$, or simply $\tf{f}$, to emphasise that no equational theory is assumed for $\tf{f}$; $[a]t$ denotes the \emph{abstraction} of the atom $a$ over the term $t$. The set of all nominal terms formed from a signature $\Sigma$ will be denoted by $\F(\Sigma,\V)$.

Write $\var{-}$ and $\atm{-}$ to denote the sets of all variables and all atoms occurring in the argument, respectively. A nominal term $t$ is {\em ground} when it does not mention variables, i.e., when $\var{t} = \emptyset$. The set of all ground terms will be denoted by $\F(\Sigma)$. The set of \emph{free atoms} of a ground term $g$ is denoted as $\tf{fn}(t)$ and consists of the atoms, say $a$, that do not occur under the scope of an abstraction $[a]$, that is, $\tf{fn}(a) = \{a\}, \tf{fn}(\tf{f^E}(g_1,\ldots,g_n)) = \bigcup_{i=1}^n\tf{fn}(g_i),$ and $\tf{fn}([a]g) = \tf{fn}(g)\setminus\{a\}$. Write $t \equiv u$ for {\em syntactic identity} of terms.

The {\em object-level permutation action on terms}, denoted as $\pi\act t$, is defined  via the homomorphic application of a permutation on the structure of the term: $ \pi \act a \equiv  \pi(a) ,~\pi \act (\pi' \act X) \equiv (\pi \circ \pi') \act X, \pi \act ([a]t)\equiv [\pi(a)](\pi \act t)$ and $
\pi \act \tf{f^E}(t_1, \ldots, t_n) \equiv \tf{f^E}(\pi \act t_1, \ldots, \pi \act t_n)$.
\emph{Substitutions}, usually denoted by $\sigma,\delta,\ldots$, are finite mappings from variables to terms, which extend homomorphically over terms. We write $Id$ to denote the identity substitution, $\dom{\sigma}$ 
% and $ \ima{\sigma}$ 
to denote the domain
% and the image 
of $\sigma$. Substitutions and permutations commute: $\pi\act (s\sigma) \equiv (\pi \act s)\sigma$.


\begin{example}Abstractions will be used to represent binding operators (e.g. the lambda operator from the $\lambda$-calculus). Considering the signature $\Sigma = \{\tf{lam}: 1, \tf{app} : 2\}$ and treating $\lambda$-variables as atoms, $\lambda$-terms can be inductively generated by the grammar:
\(
    e::= a\mid \tf{app}(e,e)\mid \tf{lam}([a]e)
\).
Note that $(a \ b)\cdot \tf{lam}([a]a)\equiv \tf{lam}([b]b)$ implements the renaming of $a$ for $b$ using the swapping $\swap{a}{b}$. 
%As expected, $\tf{lam}([a]a)\approx_\alpha \tf{lam}([b]b)$.
%We will  write $\tf{app}(s, t)$ for the $\lambda$-application $(s\ t)$ and $\tf{lam}([a] s)$ for the $\lambda$-abstraction $\lambda a.s$.
\end{example}



\paragraph*{Groups and Permutations.}
For completeness, we present some elementary notions, notations and properties of groups and permutations that will be used throughout the paper. This subsection can be skipped on a first reading and consulted later as a reference.
%For e.g., for $x\in S$, we write $x^{-1}$ for the inverse of $x$, i.e. $x\circ x^{-1}=0$, where $0$ denotes the identity element of the group.
A {\em permutation group}
is a group\footnote{A {\em group} is a set $G$ equipped with an operation $\circ:G\times G\to G$ that satisfies four properties: closure, associativity, identity, and invertibility.} $G$ whose elements are permutations on a set and the group operation is the composition $\circ$ of permutations.
 If $S$ is a non-empty subset of a permutation group $G$, then we denote by $\pair{S}$  the subgroup of all elements of 
$G$ that can be expressed as the finite composition of elements in  $S$ and their inverses.
%, i.e.,the set $\{x_1\circ x_2 \circ \dots \circ x_n \mid n \in \mathbb{N}\text{ and } x_i \in S \text{ or } x_i\in S^{-1}\}$.
$\pair{S}$ is called the {\em subgroup generated by $S$}.
%When the set is finite, say $S = \{x_1, x_2, \dots, x_r\}$, we will use the notation $\pair{x_1,x_2, \dots, x_r}$ to denote $\pair{\{x_1, x_2, \dots, x_r\}}$.
We will work with the group of {\em finite} permutations of atoms $\A$, denoted by $\Perm{\A}$. Moreover, given $B\subseteq \A$ write $\Perm{B} = \{\pi\in\Perm{\A}{} \mid \dom{\pi}\subseteq B\}$.
Recall that finite permutations can be expressed in two equivalent ways: either as compositions of swapping (a.k.a. transpositions), or as compositions of {\em disjoint permutation cycles}. E.g., $(a \ d)(a \ c)(a \ b)(e \ f)$ and $(a \ b \ c \ d)(e \ f)$ represent the same permutation.
%
If $H$ and $K$ are subsets of a permutation group $G$ whose operation is $\alert{\circ}$ (in particular, if $H$ and $K$ are subgroups of $G$), the set $\{h\alert{\circ}k \mid h \in H, k \in K\}$ will be denoted by $H\alert{\circ} K$~\footnote{The usual notation is just by juxtaposition $HK$, we will distinguish the operator $H\alert{\circ}K$ to improve readability later on.}.
%by $H^{-1}$. 
%\ali{The notation $H^{-1}$ was used to defined the generated group, but since we don't use it anymore, there's no reason to put it in the paper.}
In general, $H\alert{\circ}K$ is not a subgroup of $G$, even when $H$ and $K$ are subgroups of $G$. However, $H\alert{\circ}K$ is a subgroup of $G$ iff $H\alert{\circ}K=K\alert{\circ}H$.

\subsubsection*{Nominal Sets.}
A {\em $\Perm{\A}$-set}, denoted by $\nom{X}$, is a pair $(|\nom{X}|,\act)$ consisting of an {\em underlying set} $|\nom{X}|$ and a {\em permutation action} $\cdot $, which is a group action on $|\nom{X}|$, i.e., an operation
$\act:\Perm{\A}\times |\nom{X}|\to |\nom{X}|$ such that $\id\act x = x$ and $\pi\act (\pi'\act x) = (\pi\circ\pi')\act x$, for every $x\in |\nom{X}|$ and $\pi,\pi'\in \Perm{\A}$.  We will write $\pi\act_{\nom{X}} x$, when we want to make $\nom{X}$ clear.
For $B \subseteq \A$, we denote $\Fix{B}$ as the set of permutations that fix pointwise the elements of $B$, i.e.
  $
  \Fix{B} = \{\pi\in\Perm{\A}\mid \forall a\in B.~\pi(a) = a\}.$
A set $B\subseteq \A$ {\em supports} an element $x \in |\nom{X}|$ when for all permutations $\pi\in\Perm{\A}$:
$\pi\in\Fix{B} \implies \pi\act x = x $.
Additionally,  $B$ {\em strongly supports} $x\in|\nom{X}|$ if the reverse implication holds.
A {\em nominal set} is a $\Perm{\A}$-set $\nom{X}$ all of whose elements are finitely supported.
%A nominal set is {\em strong} iff every element is strongly supported by a finite set. 
$\nom{X,Y,Z}$ will range over nominal sets.
%\MF{Do we use strong support??}

%\ali{No, we don't use strong nominal sets anywhere, except possibly in the introduction (?) (I haven't read it fully yet).}
The {\em  support} of an element $x\in|\nom{X}|$ of a nominal set $\nom{X}$ is defined as
$\supp{}{x} = \bigcap\{B\mid \text{$B$ is finite and supports $x$}\}.$
This implies that $\supp{}{x}$ is the {\em least} finite support of $x$.
The support provides a semantics for freshness constraints in the class of nominal sets~\cite{DBLP:journals/logcom/Gabbay09,DBLP:journals/logcom/GabbayM09}:  \text{When } $ a\notin\supp{}{x}$, \text{ we write } $a\fresh_{\tt sem} x$, and read this as ``$a$ is fresh for $x$''.
%This is the notion used to provide a semantics in the class of nominal sets for freshness constraints~\cite{DBLP:journals/logcom/Gabbay09,DBLP:journals/logcom/GabbayM09}.

One of the main properties of the relation $a\fresh_{\tt sem} x$ is the so-called \emph{Choose-a-Fresh-Name Principle}, which says that if $x \in|\nom{X}|$ has a finite support, then it is always possible to choose a new atom $a$ such that $a\fresh_{\tt sem} x$. Therefore, the notion of freshness provides a generative aspect of fresh atoms.


\begin{example}[Some simple nominal sets]\label{ex:nominal-and-strong-sets}
 The $\Perm{\A}$-set $(\A,\act)$ with the action $\pi\act_\A a = \pi(a)$ is a nominal set and $\supp{}{a} = \{a\}$. The group $\Perm{\A}$ equipped with the action by conjugation $\rho\act_{\Perm{\A}}\pi = \pi^{\rho}$ forms a nominal set and $\supp{}{\pi} = \dom{\pi}$. The set of ground terms $\F(\Sigma)$ with the usual permutation action on terms is a nominal set and $\supp{}{g} = \atm{g}$. 
 %
 %
 Another example is the set $\pow{\tt fin}{\A} = \{B\subset\A \mid B \text{ is finite}\}$. Then the $\Perm{\A}$-set $(\pow{\tt fin}{\A},\act)$ with the action $\pi\act_{\pow{\tt fin}{\A}} B = \{\pi\act_\A a\mid a \in B\}$ is a nominal set and $\supp{}{B} = B$. 
 %Observe that $\pow{\tt fin}{\A}$ is not strong: $B = \{a,b\}$ and $\pi = (a \ b)$, then $\pi\act B = B$ but $\pi\notin \Fix{B}$. Similarly, the set $\pow{\tf{cofin}}{\A}$ is a nominal set but not a strong one.
\end{example}

%\MF{The example below can be removed if we are not using strong nominal sets - and we can add the first sentence about cofinite subset after (1)} \daniele{agreed}

%\begin{example}
%\label{ex:pow-fin-set} 
%\end{example}

\subsubsection*{The new \texorpdfstring{$\new$}{new}-quantifier.} The $\new$-quantifier~\cite{DBLP:journals/fac/GabbayP02} models the quantification used when we informally write ``rename $x$ in $\lambda x.t$ to a new name''. Thus, if $\phi$ is the description of some
property of atomic names $a$, then $\new \atnew{a}.\phi(\atnew{a})$ holds when $\phi(\atnew{a})$ holds for all but finitely many atoms $\atnew{a}$. Usually, $\phi$ is a predicate in higher-order logic~\cite{book/Pitts} or in ZFA or FM set theory~\cite{DBLP:journals/fac/GabbayP02,DBLP:journals/bsl/Gabbay11}. The $\new$-quantifier is defined as
\begin{equation}\label{eq:new_cofin}
    \new \atnew{a}.\phi(\atnew{a}) \text{ holds iff } \{\atnew{a}\in\A \mid \phi(\atnew{a}) \text{ holds}\} \text{ is cofinite}\footnote{A {\em cofinite} subset of a set $M$ is a subset $B$ whose complement in $M$ is a finite set. }.
\end{equation}


Therefore, $\new \atnew{a}.(\ldots)$ means ``for a cofinite number of atoms $\atnew{a}, (\ldots)$'' . The quantifier $\new$ allows to quantify the \emph{generative} aspect of names/atoms. This aligns with the Choose-a-Fresh-Name Principle of the relation $\fresh_{\tt sem} $. The connection between these two notions is established by \emph{Pitts' equivalence}~\cite{DBLP:journals/fac/GabbayP02,book/Pitts}, which defines the freshness of an atom $a$ for an element $x$ in a nominal set using the new-quantifier $\new$ and a fixed-point identity as follows:
\begin{equation}\label{eq:pitts-eq-1}
    a \fresh_{\tt sem} x \iff \new \atnew{c}. (a \ \atnew{c})\cdot x=x.
\end{equation}

The following equivalences will be heavily used throughout the text:
\begin{equation}\label{eq:fresh_fix}
   \begin{aligned}
   a\notin \supp{}{x}&\iff  a \fresh_{\tt sem} x \\
   &\iff \new \atnew{c}. (a \ \atnew{c})\cdot x=x \text{ holds}\\
   & \iff \{\atnew{c}\in\A \mid \newswap{a}{c}\act x = x\} \text{ is cofinite.}
   \end{aligned}
\end{equation}

Let $\catnew{c} = \atnew{c_1}, \ldots, \atnew{c_n}$ be list of atoms. We will write $\newc{c}{}. \phi(\catnew{c})$ as shorthand for $\new \atnew{c_1}. \new \atnew{c_2}. \ldots \new \atnew{c_n}. \phi(\catnew{c})$. Since $\new \atnew{a_1}. \new \atnew{a_2}. \phi$ holds if and only if $\new \atnew{a_2}. \new \atnew{a_1}. \phi$ holds, then the set $\catnew{c}$ can be interchangeably treated as either an unordered list or a finite set of atoms. We will refer to this set as the set of {\em $\new$-quantified names}.
%Although the atoms in $\catnew{c}$ are not directly quantified, this set inherently carries the meaning that these atoms represent entities that will be $\new$-quantified.


\section{Generalised Permutation Fixed-Points in Nominal Sets}\label{sec:permutation-fix-nominal-sets}

In this section, we  consider {\em generalised fixed-point identities}: a version of fixed-point identities with general \new-quantified atom permutations $\pi$.
%, which may be \new-quantified.  
That is,
\begin{equation*}
    \newc{c}{}.\pi \act x = x,
\end{equation*}
 where $\pi$ is a finite composition of disjoint cycles, and not only swappings. For example, $\new\atnew{c_1},\atnew{c_2},\atnew{c_3}. \swap{a \ \atnew{c_1}}{\atnew{c_2}}\circ \swap{b}{d}\cdot x = x $ is a generalised fixed-point identity.

In addition, we will split the permutation $\pi$ into  $\pi_{\catnew{c}}$, consisting of the cycles that contain at least one  $\new$-quantified atom,  and  $\pi_{\neg \catnew{c}}$, consisting of cycles whose atoms are not quantified. 
%We will investigate the meaning of such generalisation  in the context of nominal sets.

% To motivate the next definition, let $\catnew{c}$ be a finite set of $\new$-quantified names, and $\pi$ a permutation (represented as  composition  of disjoint cycles). Some or all atoms in $\dom{\pi}$ may belong to $\catnew{c}$, or none of them may be in $\dom{\pi}$. We will reorganise the disjoint cycles in $\pi$ in a way that the cycles that contain atoms in $\catnew{c}$ are together in one side, and the side that does not contain atoms in $\catnew{c}$ are separated in another side. We will denote the former as $\pi_{\catnew{c}}$ and the latter as $\pi_{\neg \catnew{c}}$.

\begin{example}
    Consider the  generalised fixed-point identity $\new{\catnew{c}}.\pi\cdot x=x$ with $\catnew{c} = \atnew{c_1}, \atnew{c_2}, \atnew{c_3},\atnew{c_4}$ and 
    \(
    \pi = (a_1 \ \atnew{c_1} \ \atnew{c_2}) \circ (a_2 \ \atnew{c_3})\circ \highlight{(a_3 \ a_4 \ a_5)}\circ (a_6 \ \atnew{c_4})\circ \highlight{(a_7 \ a_8)}
\). Note that $\pi$
is equivalent to the permutation consisting of the composition of $\pi_{\catnew{c}}$ and  $\pi_{ \neg \catnew{c}}$:
 \(
    \pi = \underbrace{(a_1 \ \atnew{c_1} \ \atnew{c_2}) \circ (a_2 \ \atnew{c_3}) \circ (a_6 \ \atnew{c_4})}_{\pi_{\catnew{c}}}\circ  \underbrace{\highlight{(a_3 \ a_4 \ a_5)}\circ \highlight{(a_7 \ a_8)}}_{\pi_{\neg \catnew{c}}}.
\)
Interesting permutations with different behaviours are: (i) $\pi_1 = (a \ \atnew{c_1}) \circ (b \ \atnew{c_2} \ \atnew{c_3} \ d) \circ (f \ \atnew{c_4})$, with $(\pi_1)_{\catnew{c}}=\pi_1$ and $(\pi_1)_{\neg \catnew{c}}=\id$; and (ii) $\pi_2=(a_1 \ b_1\ d_1)\circ (a_2 \ b_2)$ with  $(\pi_2)_{\neg \catnew{c}}=\pi_2$ and $(\pi_2)_{\catnew{c}}=\id$.
\end{example}

We formalise this decomposition of permutations in the following definition.
\begin{definition}[Classifying Permutation Cycles]\label{def:splitting}
   Let $\pi$ be a permutation and $\catnew{c}$ a finite set of \new-quantified atoms. Define $\pi_{\catnew{c}}$ as the product of disjoint cycles of $\pi$ that mention atoms in $\catnew{c}$, and  $\pi_{\neg\catnew{c}}$ as the product of disjoint cycles of $\pi$ that do not mention atoms in $\catnew{c}$. Define $\pi_{\catnew{c}} := \id$ if $\catnew{c}\cap\dom{\pi} = \emptyset$.  Similarly, $\pi_{\neg\catnew{c}} := \id$ if every disjoint cycle of $\pi$ mentions at least one atom from $\catnew{c}$.
\end{definition}


\begin{example} The following illustrate some properties of splitting permutations:
    \begin{enumerate}
        \item In general, it is not true that $\pnew{\pi_1\circ\pi_2}{\catnew{c}} = \pnew{\pi_1}{\catnew{c}}\circ\pnew{\pi_2}{\catnew{c}}$ for all permutations $\pi_1,\pi_2$. Take $\catnew{c}=\atnew{c_1}$ and the permutations
  $ \pi_1 = (a \ \atnew{c_1})$ \text{ and }
        $\pi_2 = (a \ b \ d)$. Then
     \(
        \pi_1\circ\pi_2 = (a \ b \ d \ \atnew{c_1})
         \neq (a \ \atnew{c_1}) = (\pi_1)_{\atnew{c_1}} \circ (\pi_2)_{\atnew{c_1}}.
    \)

    \item In general, it is not true that $\pnew{\pi^\rho}{\catnew{c}} = (\pi_{\catnew{c}})^\rho$,  for all  permutations $\pi$ and $\rho$. Similarly,  $\pnew{\pi^\rho}{\neg \catnew{c}} = (\pnew{\pi}{\neg \catnew{c}})^\rho$ does not hold in general. Take $\catnew{c}=\atnew{c_1}$ and  consider  
    $    \pi = (a \ b \ \atnew{c_1})\circ (d \ e)$ and $
    \rho = (\atnew{c_1} \ d)$.
    After computing the conjugate and reorganising the cycles we obtain
 $\pnew{\pi^{\rho}}{\atnew{c_1}} = (\atnew{c_1} \ e)\neq (a \ b \ d) =  (\pi_{\atnew{c_1}})^{\rho}$. We can similarly check that $(\pi_{\neg\atnew{c_1}})^{\rho}\neq \npnew{\pi^{\rho}}{\atnew{c_1}}$.

%  $(\pi_{\neg\catnew{c}})^{\rho_1} = (\atnew{c_1} \ \atnew{c_2})\circ(\atnew{c_3} \ g)$
%              $\npnew{\pi^{\rho_1}}{\catnew{c}} = (a \ b \ m)\circ(d \ n)\circ(e \ f)$
\end{enumerate}
\end{example}

Assuming permutations are written as  compositions of disjoint cycles, the next lemma states that if $\pi\act x = x$ and  $\eta$ is a cycle in $\pi$, then if   one atom of $\eta$ is not in $\supp{}{x}$,  none of the atoms in $\eta$ are in $\supp{}{x}$. Moreover, it also states that all the permutations in the group generated by permutations that fix an element $x$ of a nominal set, also fix $x$.

\begin{restatable}{lemma}{generated}
\label{lemma:generated-group}
 Let $x$ be an element of a nominal set and $\pi, \eta_1,\ldots, \eta_n$ be permutations written as compositions of disjoint cycles.
    \begin{enumerate}
    \item If $\pi\act x=x$,  $\eta$ is a cycle of $\pi$ and $\dom{\eta} - \supp{}{x} \neq \emptyset$
    %there is $a\in \dom{\eta}$ such that $a\notin \supp{}{x}$,
    then $\dom{\eta}\cap\supp{}{x} = \emptyset$.
    \item If $\eta_i\act x = x$, for all $i=1,\ldots,n$, and  $\rho\in \pair{\eta_1,\ldots,\eta_n}$, then $\rho\act x = x$.
    \end{enumerate}
\end{restatable}
%
For e.g., if $\swap{a_1 \ a_2}{a_3}\circ \swap{a_4}{a_5}\cdot x = x $ and $a_2\notin \supp{}{x}$, then $a_3,a_1\notin \supp{}{x}$.

The following result generalises Pitts' equivalence (\ref{eq:pitts-eq-1}) to any permutation $\pi$.

\begin{restatable}[Generalised Pitts' equivalence]{lemma}{pitts}
\label{lemma:pitts-eq-generalized}\hfill
    \begin{enumerate}
        \item $\newc{c}{}.~\pi\act x =x$ iff $\newc{c}{}.\pi_{\catnew{c}}\act x = x$ and $\newc{c}{}.\pi_{\neg\catnew{c}}\act x = x$.

        \item $\newc{c}{}. ~\pi_{\catnew{c}}\act x = x$ iff  for all $\catnew{c}$, $\catnew{c}\cap\supp{}{x} = \emptyset$ implies $\dom{\pi_{\catnew{c}}}\cap \supp{}{x} = \emptyset$.
        %$\dom{\pi_{\catnew{c}}}\cap \supp{}{x} = \emptyset$, for all  $\catnew{c}$ such that $\catnew{c}\cap\supp{}{x} = \emptyset$.

        \item $\newc{c}{}.~\pi_{\neg\catnew{c}}\act x = x$ iff for all $\catnew{c}$,  $\catnew{c}\cap\supp{}{x} = \emptyset$ implies $\pi_{\neg\catnew{c}}\act x = x$.

    \end{enumerate}
\end{restatable}
% \alert{MF Question: I don't know how to parse items 2 and 3. Should it be:\\
% 2. $\newc{c}{}. ~\pi_{\catnew{c}}\act x = x$ iff ($\dom{\pi_{\catnew{c}}}\cap \supp{}{x} = \emptyset$ and  $\catnew{c}\cap\supp{}{x} = \emptyset$).
% }

% \ali{If by ``($\dom{\pi_{\catnew{c}}}\cap \supp{}{x} = \emptyset$ and  $\catnew{c}\cap\supp{}{x} = \emptyset$)'' we meant ``$\dom{\pi_{\catnew{c}}}\cap \supp{}{x} = \emptyset$ and  $\catnew{c}\cap\supp{}{x} = \emptyset$ for some $\catnew{c}$ such that $\catnew{c}\cap\supp{}{x} = \emptyset$''. Then yes, this can be stated this way. That's because of the some/any property of the $\new$. The reason why Ive chosen the 'any' part of the some/any property is because it fits better in some proofs.}
% \begin{proof}
%     Proof in Appendix~\ref{app:permutation-fix-nominal-sets}.
% \end{proof}

\section{A proof system}\label{sec:proof-system}

%\alert{We need to say what the C stands for.}
In this section, we introduce notions of fixed-point constraint, equality constraint and $\alpha,\C$-equivalence  judgement, together with derivation rules  (Figure~\ref{fig:fixed-rules_new}). Our judgements and rules are more general than the ones in~\cite{DBLP:journals/logcom/GabbayM09, entics:14777,DBLP:journals/lmcs/Ayala-RinconFN19} since we consider {\em general} $\new$-quantified permutations subsuming both freshness and algebraic (here, commutative) conditions (more discussion about expressivity can be found below); as a consequence, we need only one predicate (equality, denoted $\aeq{C}$) and only one set of rules to handle notions of term equality and name freshness. Before discussing the rules, we define generalised fixed-point contexts and judgements, as well as a normalisation process to refine permutations in contexts.

%\paragraph{Constraints and Judgements via Permutation Fixed-Points}
%\label{sec:constraints}
 
\begin{definition}[Generalised fixed-point constraint and context] \hfill 
\begin{enumerate}
\item An {\em $\alpha,\C$-equality constraint} (or simply an {\em equality constraint}) is an expression of the form $t \aeq{C} u$, where $t$ and $u$ are nominal terms. 

       \item A (generalised) {\em fixed-point constraint} is an $\alpha,\C$-equality constraint of the form $\pi \act t \aeq{C} t$, where $\pi$ is a permutation. A fixed-point constraint of the form $\pi \act X \aeq{C} X$ is called {\em primitive}.  
       \item    A (generalised) {\em fixed-point context} is an expression of the form $\newc{c}{}. \Upsilon$, where $\catnew{c} = \atnew{c_1}, \ldots, \atnew{c_n}$ and $\Upsilon$ is a finite set containing only primitive fixed-point constraints. For simplicity, we write $\Upsilon_{\catnew{c}}$ to denote  $\newc{c}{}. \Upsilon$. Symbols such as $\Upsilon,\Psi,\Upsilon',\Psi'$, are used to represent fixed-point contexts.
       \end{enumerate}
\end{definition}
We will adopt the existing notation for fixed-point constraints~\cite{DBLP:journals/lmcs/Ayala-RinconFN19} and abbreviate $\pi \act t \aeq{C} t$ as $\pi \fix{C} t$, writing primitive constraints as $\pi \fix{C} X$.

\begin{definition}[Judgement]
 An {\em $\alpha,\C$-equivalence judgment} is an expression of the form  $\new\catnew{c}.(\Upsilon \vdash t\aeq{C} u)$
  consisting of a fixed-point context $\Upsilon_{\atnew{\pvec{c}'}}$, with $\atnew{\pvec{c}'}\subseteq \catnew{c}$, and an equality constraint $t\aeq{C} u$, which may contain atoms from $\catnew{c}$. We simplify the notation to  $\Upsilon_{\catnew{c}} \vdash t\aeq{C} u$.
 %\alert{Should we say that the \new quantifier in the judgement ranges over the whole judgement, not just  $\Upsilon$ ???}
\end{definition}
%
%
% \ali{The $\new$ quantifier IS ranging over the entire judgment. The only reason it was initially placed solely on the context was to simplify notation and to focus on generalized contexts of the form $\newc{c}{}.\Psi$. In this approach, a context is the entire expression $\newc{c}{}.\Psi$. When using $\new$ to quantify over the whole judgment, contexts are reduced to just the set of constraints $\Psi$, which, without the quantification, does not capture all the necessary information. Both approaches—ranging $\new$ only over the context or over the entire judgment—are equivalent in expressiveness. See the equivalences below: 
%  \begin{align*}
%      \new c.(\phi(c) \implies \psi(c))&\iff (\new c.\phi(c)) \implies (\new c.\psi(c))\\
%      &\iff (\new c.\phi(c)) \implies \psi(c)\\
%  \end{align*}
%  where the last equivalence, we uses the property $(\new c.\psi(c)) \iff \psi(c)$.
%   My proposal is to maintain the generalized contexts the way they are and say that $\new$ is ranging over the whole judgment but still use the current notation.}
%OK
We  write $\Upsilon_{\catnew{c}}|_X$ to refer to the fixed-point constraints on the variable $X$, that is,  $\Upsilon_{\catnew{c}}|_X := \newc{c}{}. \{\pi\fix{C} X\mid \pi\fix{C} X\in \Upsilon\}$. We extend the notation $\atm{-}$ to contexts $\Upsilon_{\catnew{c}}$. For example, $\atm{\new \atnew{c}.\{(a \ b \ \atnew{c})\fix{C} X\}} = \{a, b, \atnew{c}\}$. The set also includes vacuous $\new$-quantified names, as in $\atm{\new \atnew{c,c_1}.\{(a \ \atnew{c})\fix{C} X\}} = \{a, b, \atnew{c,c_1}\}$. We may slightly abuse notation when convenient and write $\pi\fix{C} X \in \Upsilon_{\catnew{c}}$ instead of $\pi\fix{C} X \in \Upsilon$.


\subsubsection{Expressivity.}\label{sec:normalised}
In the standard nominal approach using freshness constraints, contexts store only information about the freshness of atoms in (meta-)variables — they impose conditions on which atoms cannot occur free in any interpretation of the variables. Generalised fixed-point contexts are more expressive. 
Consider the context $\new \atnew{c}.\Psi_1 = \new \atnew{c}.\{(a \ \atnew{c} \ b)\circ(d \ e)\fix{C} Z\}$. By the generalized Pitts' equivalence (see Lemma~\ref{lemma:pitts-eq-generalized}), this  context implies two things:

\begin{enumerate}
\item The atoms $a, b$ (and also $\atnew{c}$) cannot occur freely in an interpretation of $Z$.

\item $(d \ e)\fix{C} Z$ holds, which does not force the atoms $d$ and $e$ to be fresh in interpretations of $Z$, since neither $d$ nor $e$ are $\new$-quantified or occur in a cycle with a $\new$-quantified name. For example,  $Z$ could be mapped to the term $d+e$ where $+$ is a commutative operator. In this case, $a, b$, and $\atnew{c}$ do not occur freely in $d+e$, while $d$ and $e$ occur freely in $d+e$, but $(a \ \atnew{c} \ b)\act (d+e) \aeq{C} d+e$ and $(d \ e)\act(d+e) \aeq{C} d+e$.
\end{enumerate}

The example above shows that generalised fixed-point contexts are a form of ``hybrid context'': they store more than just freshness information; they also encode relevant fixed-point constraints that cannot be reduced to freshness.

\subsection{Normalisation}\label{sec:normalization}
We can explore the properties of permutations to improve our fixed-point contexts. The idea is to use the properties in  Lemma~\ref{lemma:generated-group} to transform contexts into equivalent, simpler ones,  using first the rule  {\bf (R1)} exhaustively and then  {\bf (R2)}: % as below:
{\small 
\[
\begin{array}{rl}
     \textbf{(R1)}& \new\catnew{c}. (\{\pi_{\catnew{c}}\circ\pi_{\neg \catnew{c}} \fix{C} X\}\cup \Upsilon') \implies     \new\catnew{c}. (\{\pi_{\catnew{c}}\fix{C} X, \pi_{\neg \catnew{c}} \fix{C} X\}\cup \Upsilon') \\[1mm]
     %
     \textbf{(R2)}& \new\catnew{c}. (\{\pi_{\catnew{c}}\fix{C} X, (\rho_{\neg \catnew{c}} \circ \rho'_{\neg \catnew{c}})\fix{C}X \}\cup \Upsilon') \implies     \new\catnew{c}. (\{(\pi_{\catnew{c}}\circ \rho_{\neg \catnew{c}})\fix{C} X,   \rho'_{\neg \catnew{c}} \fix{C} X\}\cup \Upsilon') \\
     & \text{if } \dom{\pi_{\catnew{c}}}\cap \dom{\rho_{\neg\catnew{c}}}\neq \emptyset \text{, where $\rho$ is a cycle disjoint from $\rho'$.}
\end{array}
\]
}
We justify our rules as follows: For rule {\bf (R1)}: From Definition~\ref{def:splitting}, it follows that given $\catnew{c}$, every permutation $\pi$ that is written as a product of disjoint cycles can be rewritten such that $\pi= \pi_{\catnew{c}}\circ \pi_{\neg \catnew{c}}$.  By Lemma~\ref{lemma:pitts-eq-generalized}, the constraint $\pi_{\catnew{c}}\circ \pi_{\neg \catnew{c}} \fix{C} X$ is equivalent to  $\pi_{\catnew{c}} \fix{C} X \wedge \pi_{\neg \catnew{c}} \fix{C} X$. For rule {\bf (R2)} the constraints on the lhs are normal forms w.r.t. ({\bf R1}): From the constraint $\pi_{\catnew{c}}\fix{C} X$ it follows that the atoms in $\pi_{\catnew{c}}$ cannot occur free in the instances of $X$ (they are not in the support of the instances of $X$). Since $\rho$ is a cycle that contains atoms in $\pi_{\catnew{c}}$, by  Lemma~\ref{lemma:generated-group}, all the atoms in the cycle must not be in the support of $X$. From the equivalences in (\ref{eq:fresh_fix}), not being in the support
is equivalent to being the fixed-point with atoms in $\catnew{c}$. The composition $\pi_{\catnew{c}}\circ \rho_{\neg \catnew{c}} $ generates a new permutation $\pnew{\pi'}{\catnew{c}}$ with the atoms of $\pi_{\catnew{c}}$ and $\rho_{\neg \catnew{c}}$ organised as a composition of disjoint cycles.

\begin{example}\label{exa:normalisation}
To illustrate ({\bf R1}), consider  the  context $\Psi_{\atnew{c}}=\new \atnew{c}.\{(\newswap{a}{c}\circ \swap{d}{e}\fix{C} Z\}$ which is equivalent to the context   $\new \atnew{c}.\{\newswap{a}{c}\fix{C} Z, \swap{d}{e}\fix{C} Z\}$ with simpler constraints. The left constraint gives information about freshness whereas the  right constraint is about terms that are fixed by permutation $\swap{d}{e}$. To illustrate ({\bf R2}), consider the context $\new \atnew{c}.\Psi_2 = \new \atnew{c}.\{\newswap{a}{c}\fix{C} X, (a \ b)\circ(d \ e)\fix{C} X\}$. By generalised Pitts' equivalence (Lemma~\ref{lemma:pitts-eq-generalized}), $\newswap{a}{c}\fix{C} X$ alone implies that $a$ cannot occur freely in any interpretation of $X$, as $\atnew{c}$ is $\new$-quantified. In contrast, when considering the constraint $(a \ b)\circ (d \ e)\fix{C} X$ on its own, the names $a,b,d,e$ may occur freely in an interpretation of $X$. However, when the two constraints are considered together, as in $\new \atnew{c}.\Psi_2$, the scenario for the name $b$ changes: it follows from Lemma~\ref{lemma:generated-group} that $b$ also cannot be free in any interpretation of $X$.
Rule ({\bf R2}) composes both permutations as in $\newswap{a}{c}\circ \swap{a}{b}$ obtaining the equivalent context $\new \atnew{c}.\{\newswap{a \ b}{c}\fix{C} X, (d \ e)\fix{C} X\}$ where it is explicit that $a$ and $b$ must be fresh in all the instances of $X$.
\end{example}



\paragraph{\bf Important Assumption.} From now on, unless explicitly stated otherwise, we will assume that {\em every fixed-point context, say $\Upsilon_{\catnew{c}}$, is in normal form with respect to the exhaustive application of rules ({\bf R1}) and ({\bf R2})}. 

Thus, just as we can split a permutation $\pi$ into its disjoint parts $\pi_{\catnew{c}}$ and $\pi_{\neg\catnew{c}}$, we will split a generalised fixed-point context $\Upsilon_{\catnew{c}}$ into its ``freshness''  part (denoted $(\Upsilon_{\catnew{c}})_{\fresh}$) and ``pure fixed-point'' (but non-freshness) part (denoted $(\Upsilon_{\catnew{c}})_{\fix{C}}$). That is, $(\Upsilon_{\catnew{c}})$ will be divided into the following disjoint sets:
$(\Upsilon_{\catnew{c}})_{\fresh} := \newc{c}{}.\{\pi_{\catnew{c}}\fix{C} X \mid \pi\fix{C} X\in \Upsilon\}$ and $(\Upsilon_{\catnew{c}})_{\fix{C}} := \newc{c}{}.\{\pi_{\neg\catnew{c}}\fix{C} X \mid \pi\fix{C} X\in \Upsilon\}$. 
For example, the context $\new\catnew{c}.\Psi_2$ from Example~\ref{exa:normalisation} will be split into $(\new \atnew{c}.\Psi_2)_{\fresh} = \new \atnew{c}.\{(a \ b \ \atnew{c})\fix{C} X\}$ and $(\new \atnew{c}.\Psi_2)_{\fix{C}} = \new \atnew{c}.\{(d \ e)\fix{C} X\}$.


In the following  we use the notation
%consider the permutations occurring in the fixed-point constraints in $\Upsilon_{\catnew{c}}$ that contains atoms of $\catnew{c}$ or not. They will be denoted as  
% $\perm{}{(\Upsilon_{\catnew{c}})_{\fresh}} := \{\pi_{\catnew{c}} \mid \pi\fix{C} X\in \Upsilon\}$ and 
$\perm{}{(\Upsilon_{\catnew{c}})_{\fix{C}}} := \{\pi_{\neg\catnew{c}} \mid \pi\fix{C} X\in \Upsilon\}$
% , respectively.





\subsection{Derivation rules for \texorpdfstring{$\aeq{C}$}{falphaeqC}}\label{sec:derivation-rules}



%Derivation rules for $\C$-fixed-point and $\C$-$\alpha$-equality judgements are given in Figure~\ref{fig:fixed-rules_new}.


\begin{figure}[!t]
% ensure that we have normalsize text
\small
% Store the current equation number.
%\setcounter{MYtempeqncnt}{\value{equation}}
% Set the equation number to one less than the one
% desired for the first equation here.
% The value here will have to changed if equations
% are added or removed prior to the place these
% equations are referenced in the main text.
%\setcounter{equation}{5}
\begin{mdframed}
\begin{mathpar}
   \inferrule*[right=$(\frule{\faeq{C}}{a})$]
    {\qquad }{\Upsilon_{\catnew{c}} \vdash a\aeq{C} a}
   %
   \and
   %
    \inferrule*[right=$(\frule{\faeq{C}}{var})$]
    {\pi'^{-1}\circ\pi\in\PN{}{\Upsilon_{\catnew{c}}|_X}}
        {\Upsilon_{\catnew{c}} \vdash \pi\act X \aeq{C} \pi'\act X}
   %
   \and
   %
   \inferrule*[right=$\tf{f}\neq \tf{f^C} \ (\frule{\faeq{C}}{\tf{f}})$]
   {\Upsilon_{\catnew{c}} \vdash t_1 \aeq{C} t_1'\\ \ldots \\
        \Upsilon_{\catnew{c}} \vdash t_n\aeq{C} t_n'}
        {\Upsilon_{\catnew{c}} \vdash {\tt f}(t_1,\ldots,t_n) \aeq{C} {\tt f}(t_1',\ldots,t_n')}
    %
    \and
    %
    \inferrule*[right=$(\frule{\faeq{C}}{\tf{f^C}})$]
    {\Upsilon_{\catnew{c}} \vdash s_0\aeq{C}t_i\\
       \Upsilon_{\catnew{c}} \vdash s_1\aeq{C}t_{1-i} \quad  i=0,1}
    {\Upsilon_{\catnew{c}} \vdash \tf{f^C}(s_0,s_1)\aeq{C} \tf{f^C}(t_0,t_1)}
    %
    \and
    %
    \inferrule*[right=$(\frule{\faeq{C}}{[a]})$]
    {\Upsilon_{\catnew{c}} \vdash  t \aeq{C} t'}
    {\Upsilon_{\catnew{c}} \vdash [a]t \aeq{C} [a]t'}
    %
    \and
    %
    \inferrule*[right=$(\frule{\faeq{C}}{ab})$]
    {\Upsilon_{\catnew{c},\atnew{c_1}} \vdash \newswap{a}{c_1}\act t \aeq{C} \newswap{b}{c_1}\act s}
    {\Upsilon_{\catnew{c}} \vdash [a]t \aeq{C} [b]s}
    %where $c_1\notin \atm{\Upsilon},\catnew{c},a,b,t,s$
\end{mathpar}
\end{mdframed}
% Restore the current equation number.
%\setcounter{equation}{\value{MYtempeqncnt}}
% The IEEE uses as a separator
%\hrulefill
\caption{Derivation rules for $\aeq{C}$.}
\label{fig:fixed-rules_new}
% The spacer can be tweaked to stop underfull vboxes.
\vspace*{4pt}
\end{figure}


% \UnaryInfC{where $c_1\notin \atm{\Upsilon},\catnew{c},a,b,t,s$}

%Rules $(\frule{\fix{C}}{var})$ and $(\frule{\faeq{C}}{var})$ are
We are now ready to present our derivation rules (Figure~\ref{fig:fixed-rules_new}). The rule  $(\frule{\faeq{C}}{ab})$ for abstraction relies on Pitts' definition of $\alpha$-equivalence on nominal sets ($=_\alpha$) using the $\new$-quantifier~\cite{book/Pitts}:
\begin{equation}\label{eq:pitts-eq-2}
 (a_1,x_1) =_\alpha (a_2,x_2) \iff \new \atnew{c_1}.~\newswap{a_1}{ c_1}\act x_1 = \newswap{a_2}{c_1}\act x_2.
\end{equation}
This means that two abstractions $[a_1]t$ and $[a_2]s$ are equal if  $\new \atnew{c_1}. \newswap{a_1}{c_1}\act t = \newswap{a_2}{c_1}\act s$. As expected, the rule for commutativity $(\frule{\faeq{C}}{\tf{f^C}})$  ensures  that to prove $\Upsilon_{\catnew{c}}\vdash {\tf f}^{\C}(s_0,s_1)\aeq{C} {\tf f}^{\C}(t_0,t_1)$ there must exist derivations of $\Upsilon_{\catnew{c}}\vdash s_0 \aeq{C} t_0 $ and $\Upsilon_{\catnew{c}} \vdash s_1\aeq{C} t_1$; or derivations of $\Upsilon_{\catnew{c}}\vdash s_0 \aeq{C} t_1 $ and $\Upsilon_{\catnew{c}} \vdash s_1\aeq{C} t_0$.

The rule $(\frule{\faeq{C}}{var})$ for handling variables is more involved. It is inspired by  Lemma~\ref{lemma:generated-group} and Lemma~\ref{lemma:pitts-eq-generalized}.
Applying $\pi'^{-1}$ to both sides of $\pi\act X \aeq{C} \pi'\act X$ yields $\pi'^{-1} \act (\pi \act X) \aeq{C} X$, which simplifies to $(\pi'^{-1}\circ\pi) \cdot X \aeq{C} X$. At this point, it is essential to verify whether $\pi'^{-1}\circ\pi$ belongs to the {\em group generated by permutations derived from the context $\Upsilon_{\catnew{c}}|_X$}, denoted as $\PN{}{\Upsilon_{\catnew{c}}|_X}$, whose permutations are known to fix $X$. Here
\begin{equation}\label{permutation-group-X}
    \PN{}{\Upsilon_{\catnew{c}}|_X} = \Perm{\atm{(\Upsilon_{\catnew{c}}|_X)_{\fresh}}}\alert{\circ}\pair{\perm{}{(\Upsilon_{\catnew{c}}|_X)_{\fix{C}}}},
\end{equation}
which is a subgroup of $\Perm{\A}$ because $\rho_1\circ\rho_2 = \rho_2\circ\rho_1$ holds for all $\rho_1 \in \Perm{\atm{(\Upsilon_{\catnew{c}}|_X)_{\fresh}}}$ and all $\rho_2\in\pair{\perm{}{(\Upsilon_{\catnew{c}}|_X)_{\fix{C}}}}$ since $\rho_1$ and $\rho_2$ are disjoint.
The remaining rules are standard and rely on the decomposition of the constraint over the structure of its terms.
\begin{example} \label{examples-judgements} 
The judgement $\new \atnew{c}.\{\newswap{d \ e}{c}\fix{C} X, (a \ b)\fix{C} Y\}\vdash \tf{f^C}([d]X,((a \ b)\act Y)\aeq{C} \tf{f^C}(Y,[e]X)$ is derivable. For $\Upsilon_{\atnew{c}}=\new \atnew{c}.\{\newswap{d \ e}{c}\fix{C} X, (a \ b)\fix{C} Y\}$, we have the following derivation:
\vspace{-4mm}
{\small 
          \begin{prooftree}
            \AxiomC{$(a \ b)\in \Perm{\{\atnew{c}\}}\alert{\circ}\pair{(a \ b)}$}
            \dashedLine

            \UnaryInfC{$(a \ b)\in \PN{}{\Upsilon_{\atnew{c}}|_Y}$}
            \RightLabel{$(\frule{\faeq{C}}{var})$}
            
            \UnaryInfC{$\Upsilon_{\atnew{c}} \vdash (a \ b)\act Y \aeq{C} Y$}
            
            \AxiomC{$(d \ e \ \atnew{c_1})\in \Perm{\{d,e, \atnew{c},\atnew{c_1}\}}\alert{\circ}\pair{\emptyset}$}
            \dashedLine
            \UnaryInfC{$(d \ e \ \atnew{c_1})\in \PN{}{\Upsilon_{\atnew{c},\atnew{c_1}}|_X}$}
            \RightLabel{$(\frule{\faeq{C}}{var})$}
        \UnaryInfC{$\Upsilon_{\atnew{c},\atnew{c_1}} \vdash \newswap{d}{c_1}\act X \aeq{C} \newswap{e}{c_1}\act X$}
        \RightLabel{$(\frule{\faeq{C}}{ab})$}
        \UnaryInfC{$\Upsilon_{\atnew{c},\atnew{c_1}} \vdash [d]X \aeq{C} [e]X$}
          \RightLabel{$(\frule{\faeq{C}}{\tf{f^C}})$}
             \BinaryInfC{$\Upsilon_{\atnew{c}} \vdash \tf{f^C}([d]X,(a \ b)\act Y)\aeq{C} \tf{f^C}(Y,[e]X)$}
         \end{prooftree}
         }
   While the freshness approach~\cite{DBLP:journals/tcs/UrbanPG04} requires $a \fresh Y$ and $b \fresh Y$ to derive $(a \ b)\act Y \aeq{C} Y$, the fixed-point calculus removes this limitation. Here, $(a \ b)\act Y \aeq{C} Y$ is derivable without relying on any freshness assumption. Yet, if desired, it could be derived using freshness; for instance, it could be derived using the context $\new\atnew{c}. \{(a \ b \ \atnew{c})\fix{C}Y \}$. This shows that the fixed-point calculus generalises and extends the freshness calculus, establishing it as proper subcalculus.
\end{example}

%Rule $(\frule{\fix{C}}{\tf{f^C}})$ transforms a $\C$-fixed-point constraint into a $\C$-$\alpha$-equality constraint; and  $(\frule{\faeq{C}}{\tf{f^C}})$ abbreviates two rules, by taking  $i=0$ and $i=1$, which is equivalent to consider the permutation of the arguments of a commutative function symbol, say ${\tf f}^{\C}$. 


%Thus, rule $(\frule{\faeq{C}}{ab})$ is obtained from (\ref{eq:pitts-eq-2}) as follows:
%\begin{align*}
 %   [\pi(a)]\pi\act t = [a]t &\iff \new \atnew{c_1}. \newswap{\pi(a)}{c_1}\act (\pi\act t) = \newswap{a}{c_1}\act t \\
  %  &\iff \new \atnew{c_1}. \pi\act(\newswap{a}{c_1}\act t) = \newswap{a}{c_1}\act t.
%\end{align*}
%Similarly, we obtain rule $(\frule{\faeq{C}}{ab})$.
%Observe that the rule $(\frule{\faeq{C}}{a})$ is independent of the context $\Upsilon_{\catnew{c}}$. 
%Thus, we can assume, w.l.o.g., a convenient context when applying this rule. The remaining rules are defined, inductively, as expected.

%For example, the judgement  $\emptyset \vdash (a \ b)\fix{C} d$ is derivable from rule  $(\frule{\faeq{C}}{a})$ as $\swap{a}{b}(d)\equiv d$; and  $\new\atnew{c}. \{\newswap{a}{c}\fix{C} X\} \vdash (a \ b)\fix{C} d$ as well.  We can also use quantified names as in  $(\new \atnew{c_1}, \atnew{c_2}.\{\newswap{d}{c_1}\fix{C} X\}) \vdash \newswap{a}{c_2}\fix{C} \atnew{c_1}$, which is derivable from $(\frule{\faeq{C}}{a})$.


\subsection{Properties}\label{sec:properties}
Our calculus satisfies essential structural properties, as summarised in Theorem~\ref{lemma:pitts-eq-generalized}. It upholds {\em equivariance}, ensuring that derivations remain invariant under the action of permutations, thereby preserving consistency across transformations. It also satisfies {\em inversion}, a useful property for inductive proofs on derivations, as it facilitates the bottom-up application of derivation rules. More significantly, and in contrast with previous fixed-point approaches~\cite{DBLP:journals/lmcs/Ayala-RinconFN19,entics:14777}, our framework enables the definition of a sound and complete semantics for commutative nominal algebra with $\new$-quantified fixed-point constraints in nominal sets, as established in Theorem~\ref{thm:soundness-completeness-fix} below. The key insight to achieve this result lies in the $(\frule{\faeq{C}}{var})$ rule, more precisely in the construction of the group  $\PN{}{\Upsilon_{\catnew{c}}|_X}$ (see~(\ref{permutation-group-X})), which carefully distinguishes freshness information from fixed-point behaviour.

\begin{restatable}[Miscellaneous]{theorem}{miscellaneous}\label{thm:miscellaneous}
The following hold:
\begin{enumerate}
  \item (Inversion) \label{thm:inversion} The derivation rules from Figure~\ref{fig:fixed-rules_new} are invertible.
  \item (Equivariance) \label{thm:object-equivariance} $\Upsilon_{\catnew{c}} \vdash  s \aeq{C} t$ iff $\Upsilon_{\catnew{c}} \vdash  \rho\act s\aeq{C} \rho\act t$,
where $\rho$ is an arbitrary permutation (it could have atoms of $\catnew{c}$ in its domain).
  \item (Equivalence) \label{thm:alpha-equivalence} $\Upsilon_{\catnew{c}}\vdash - \aeq{C} -$ is an equivalence relation.
  %\item \alert{(Preservation) \label{thm:preservation-fix}  If $\Upsilon_{\catnew{c}} \vdash \pi\fix{C} s$ and $\Upsilon_{\catnew{c}} \vdash s\aeq{C} t$ then  $\Upsilon_{\catnew{c}} \vdash  \pi\fix{C} t$.}
  \item (Strengthening) \label{thm:strengthening}  If $(\Upsilon\uplus\{\pi\fix{C} X\})_{\catnew{c}}\vdash s\aeq{C} t$ and $(\dom{\pi}\setminus\catnew{c})\cap\atm{s,t} = \emptyset$, then $\Upsilon_{\catnew{c}}\vdash s\aeq{C} t$.
 \end{enumerate}
\end{restatable}
 %Inversion is a particularly useful property in proofs by induction on the derivation of a judgment, as it enables a bottom-up application of the derivation rules. Equivariance ensures that our derivations remain closed under the action of permutations, maintaining consistency under such transformations. Equivalence establishes that the relation $\aeq{C}$ is an equivalence relation, which is crucial for reasoning about structural properties. 
 %Preservation ensures that a fixed point of$\alpha$-equivalent terms is maintained. 
%Strengthening is standard. 
%allows us to eliminate unnecessary constraints from the context.

\subsubsection{Soundness and Completeness.}\label{sec:soundness-completeness}
We first define the semantics of judgements. Below, we introduce the fundamental notions required to present our results, while the full construction of the semantic model is provided in the appendix.

%\begin{definition}[Commutative $\Sigma$-algebra]\label{def:sigma-algebra-with-nominal-set}
    Given a signature $\Sigma$, which may contain commutative function symbols, a {\em commutative nominal $\Sigma$-algebra} $\nalg{A}$ (or just $\Sigma$-algebra) consists of:
    \begin{enumerate}
        \item A nominal set $\nom{A} = (|\nom{A}|,\act)$ $-$ the domain.

        \item An injective equivariant\footnote{Given $\Perm{\A}$-sets $\nom{X,Y}$, call a map $f: |\nom{X}|\to |\nom{Y}|$ {\em equivariant} when $\pi\act f(x) = f(\pi\act x)$ for all $\pi\in\Perm{\A}$ and $x\in |\nom{X}|$.} map $\atom^{\nalg{A}}:\A\to |\nom{A}|$ to interpret atoms; we write the interpretation $\atom(a)$ as $a^{\nalg{A}}\in |\nom{A}|$.

        \item An equivariant map $\abs^{\nalg{A}}:\A\times |\nom{A}|\to |\nom{A}|$ such that $\new\atnew{c}. \newswap{a}{c}\act \abs^{\nalg{A}}(a,x) = \abs^{\nalg{A}}(a,x)$, for all $a\in \A$ and $x\in|\nom{A}|$; we use this to interpret abstraction.

        \item An equivariant map $f^{\nalg{A}}:|\nom{A}|^n \to |\nom{A}|$, for each $\tf{f}:n$ in $\Sigma$.

        \item For each $\tf{f^C}$ in $\Sigma$, the associated equivariant map $f^{\C,\nalg{A}}$ satisfies $f^{\C,\nalg{A}}(x_1, x_2) = f^{\C,\nalg{A}}(x_2, x_1)$ for all $x_1, x_2 \in |\nom{A}|$. Sometimes, $\nalg{A}$ will be called a {\em nominal model of $\C$ (over $\Sigma$)}.
    \end{enumerate}
    We use $\nalg{A,B,C}$ to denote $\Sigma$-algebras.
%\end{definition}

A {\em valuation} $\varsigma$ in a commutative $\Sigma$-algebra $\nalg{A}$ maps unknowns $X\in\V$ to elements
$\varsigma(X) \in |\nom{A}|$. Below we define an equivariant function $\Int{\act}{\nalg{A}}{\varsigma}: \F(\Sigma,\V)\to |\nom{A}|$ to interpret terms w.r.t. a valuation $\varsigma$.

\begin{definition}[Interpretation]\label{def:interpretation-of-terms}
    Let $\nalg{A}$ be a commutative $\Sigma$-algebra. Suppose that $t \in \F(\Sigma, \V)$ and consider a valuation $\varsigma$ in $\nalg{A}$. The {\em interpretation} $\Int{t}{\nalg{A}}{\varsigma}$ is defined inductively as:
    \[
    \begin{array}{l@{\hspace{1cm}}r}
    \begin{array}{rcl}
            \Int{a}{\nalg{A}}{\varsigma} &=&  a^{\nalg{A}}\\
            %
            \Int{[a]t}{\nalg{A}}{\varsigma} &=&\abs^{\nalg{A}}(a,\Int{t}{\nalg{A}}{\varsigma})\\
            %
            \Int{{\tt f^{\C}}(t_1,t_2)}{\nalg{A}}{\varsigma} &=& f^{\C,\nalg{A}}(\Int{t_1}{\nalg{A}}{\varsigma}, \Int{t_2}{\nalg{A}}{\varsigma})\\
        \end{array} &
        \begin{array}{rcl}
            \Int{ \pi\act X}{\nalg{A}}{\varsigma} & =& \pi\act \varsigma(X)\\
            %
            \Int{{\tt f}(t_1,\ldots,t_n)}{\nalg{A}}{\varsigma} & =& f^{\nalg{A}}(\Int{t_1}{\nalg{A}}{\varsigma},\ldots, \Int{t_n}{\nalg{A}}{\varsigma}) \\
        \end{array}
        \end{array}
\]
\end{definition}
 % In this case we write $f:\nom{X}\to\nom{Y}$. For instance, any constant map is easily an equivariant map. A relation $R \subseteq |\nom{X}|\times|\nom{Y}|$ is called {\em equivariant} iff, for any permutation $\pi\in\Perm{\A}$ and $(x, y) \in|\nom{X}|\times|\nom{Y}|$, $xRy \iff (\pi\act x)R(\pi\act y)$. For example, the relations $\in, =,\subseteq$ and their negations are equivariant. The usual relations of sets $\cup$ (union) and $\cap$ (intersection) are equivariant, as well as the complement relation $\setminus$.
%
The interpretation map $\Int{\cdot}{\nalg{A}}{\varsigma}$ is  equivariant. The next definition gives a semantics to our derivations within nominal sets.
%
%\begin{definition}[Validity]\label{def:validity}
    For any commutative $\Sigma$-algebra $\nalg{A}$:
        \begin{itemize}
           \item $\Int{\Upsilon_{\catnew{c}}}{\nalg{A}}{\varsigma}$ is {\it valid} if, and only if,  $\newc{c}{}.\pi\act\Int{X}{\nalg{A}}{\varsigma} = \Int{X}{\nalg{A}}{\varsigma}$, for each $\pi\fix{C} X\in\Upsilon$;
           %\item \alert{$\Int{\Upsilon_{\catnew{c}}\vdash \pi\fix{C} t}{\nalg{A}}{\varsigma}$  is {\it valid} if, and only if,  $\Int{\Upsilon_{\catnew{c}}}{\nalg{A}}{\varsigma}$ (valid) implies $\pi\act\Int{t}{\nalg{A}}{\varsigma} = \Int{t}{\nalg{A}}{\varsigma}$.}
          \item  $\Int{\Upsilon_{\catnew{c}}\vdash t \aeq{C} u}{\nalg{A}}{\varsigma}$  is {\it valid}  if, and only if, $\Int{\Upsilon_{\catnew{c}}}{\nalg{A}}{\varsigma}$ (valid) implies $\Int{t}{\nalg{A}}{\varsigma} = \Int{u}{\nalg{A}}{\varsigma}$.
        \end{itemize}
  %\alert{More generally, $\Int{\Upsilon_{\catnew{c}} \vdash\pi \fix{C} t}{\nalg{A}}{}$ is {\it valid} iff $\Int{\Upsilon_{\catnew{c}} \vdash \pi \fix{C} t}{\nalg{A}}{\varsigma}$ is valid for all valuations $\varsigma$.} Similarly for
  More generally, $\Int{\Upsilon_{\catnew{c}}\vdash t \aeq{C} u}{\nalg{A}}{}$ is {\em valid} iff  $\Int{\Upsilon_{\catnew{c}}\vdash t \aeq{C} u}{\nalg{A}}{\varsigma}$ is valid for all valuation $\varsigma$ .
%\end{definition}
 The semantics of equality constraints is defined for all commutative $\Sigma$-algebras: $\Upsilon_{\catnew{c}} \vDash s\aeq{C} t$ when $\Int{\Upsilon_{\catnew{c}} \vdash s\aeq{C} t}{\nalg{A}}{}$ is valid for all $\nalg{A}$ model of $\C$.
%\begin{definition}[Semantic  Judgements]\hfill
   % \begin{itemize}
    %    \item Write $\Upsilon_{\catnew{c}} \vDash s\aeq{C} t$ when $\Int{\Upsilon_{\catnew{c}} \vdash s\aeq{C} t}{\nalg{A}}{}$ is valid for all $\nalg{A}$ model of $\C$.

      %  \item \alert{Write $\Upsilon_{\catnew{c}} \vDash \pi\fix{C} t$ when $\Int{\Upsilon_{\catnew{c}_0}\vdash \pi\fix{C} t}{\nalg{A}}{}$ is valid for all $\nalg{A}$ model of $\C$.}
   % \end{itemize}
%\end{definition}

\begin{example}
    An example of an algebra involves the set $\pow{\tf{fin}}{\A}$. When equipped with the maps $\atm{a} = \{a\},\abs(S) = S\setminus\{a\}$, and $f(S_1,\ldots,S_n) = \bigcap_i S_i$ for every $\tf{f}:n$ in $\Sigma$, it forms a model of $\C$.
\end{example}

The proof system is sound and complete with respect to the nominal set semantics. 
In previous work, the $(\frule{\faeq{C}}{var})$ rule was simpler: it checked only the domains of the permutations involved, yielding a restricted notion of soundness. The construction of the  subgroup $\PN{}{\Upsilon_{\catnew{c}}|_X}$  in $(\frule{\faeq{C}}{var})$  is essential to obtain:

\begin{restatable}{theorem}{soundcomplete}\label{thm:soundness-completeness-fix}
     For any $\Upsilon_{\catnew{c}},t,u$, the following hold:
    \begin{enumerate}
        \item (Soundness) \label{thm:soundness-fix} If $\Upsilon_{\catnew{c}} \vdash t\aeq{C} u$ then $\Upsilon_{\catnew{c}} \vDash t\aeq{C} u$.

        \item (Completeness) \label{thm:completeness-fix} If $\Upsilon_{\catnew{c}} \vDash t\aeq{C} u$ then $\Upsilon_{\catnew{c}} \vdash t\aeq{C} u$.
    \end{enumerate}
\end{restatable}



\section{Nominal \texorpdfstring{$\C$}{C}-Unification}\label{sec:nominal-c-unification}

In this section, 
%we define nominal $\C$-unification problems and their solutions, introducing an ordering to compare solutions. We then
we present a rule-based algorithm for solving $\C$-unification problems using fixed-point constraints, proving its termination and correctness.

%set simplification of simplification rules which will be used to  calculus. 

%\begin{proof}
 %   Proof in Appendix~\ref{app:preservation-substitutiton}.
%\end{proof}

 \begin{definition}[Nominal $\C$-Unification Problem] A \emph{(nominal) $\C$-unification problem} $\probc$ has the form $\newc{c}{}.Pr$,  where $Pr$ consists of a finite set of (unification) constraints of the form $s\aeq{C}^?t$.
\end{definition}



Solutions for nominal $\C$-unification problems will be expressed using pairs  $\npair{\Psi, \sigma}{\atnew{\pvec{c}'}}$ consisting of a generalised fixed-point context $\Psi_{\atnew{\pvec{c}'}}$ and a substitution $\sigma$, where occurrences of the atoms $\atnew{\pvec{c}'}$ in the image of $\sigma$ are $\new$-quantified.
We call such $\sigma$ a $\new$-substitution, denoted as $\newc{c}{}.\sigma$ or $\sigma_{\atnew{\pvec{c}}}$.  We will omit the subscript and write only $\sigma$ to avoid clutter. 
%, as some of the atoms occurring in the image of $\sigma$ might be $\new$-quantified. 
We will come back to this later in \S\ref{ssec:unif-rules}. 


 \begin{definition}[$\C$-Solution/Unifier]
 A  $\C$-unifier ($\C$-{\em solution}) for a  nominal $\C$-unification problem $\probc = \newc{c}{}.Pr$ is a pair $\npair{\Psi, \sigma}{\atnew{\pvec{c}'}}$, such that  $\catnew{c} \subseteq \atnew{\pvec{c}'}$ and
 %$\Psi_{\atnew{\pvec{c}'}}$ is a context, and $\sigma$ is the $\new$-substitution, 
 $\Psi_{\atnew{\pvec{c}'}} \vdash s\sigma \aeq{C}t\sigma$, for each $s\aeq{C}^? t\in Pr$.
 % Furthermore, if $\Psi_{\atnew{\pvec{c}'}}\vdash X\sigma\aeq{C} X\sigma\sigma$, for all $X \in \V$, then the $\C$-unifier is called {\em idempotent}.
 If no $\C$-unifier $\npair{\Psi, \sigma}{\atnew{\pvec{c}'}}$ exists for $\probc$, the problem $\probc$ is {\em unsolvable}. We denote the set of all $\C$-unifiers of $\probc$ by $\mathcal{U}(\probc)$. 
\end{definition}
For simplicity, we will omit $\C$ and primarily refer to $\C$-unifiers and $\C$-solutions of $\C$-unification problems as unifiers and solutions, respectively.
The solutions to a problem $\probc$, elements of the set $\mathcal{U}(\probc)$, can be compared using the instantiation order $\ins{}$ (quasi-order) defined as follows:


\begin{definition}[Instantiation order]\label{def:ordering}
    Given  $\npair{\Psi_1,\sigma_1}{\atnew{\vec{c}_1}}$ and $\npair{\Psi_2,\sigma_2}{\atnew{\vec{c}_2}}$,
    we write $\npair{\Psi_1,\sigma_1}{\atnew{\vec{c}_1}} \ins{} \npair{\Psi_2,\sigma_2}{\atnew{\vec{c}_2}}$ when $\atnew{\vec{c}_1}\subseteq \atnew{\vec{c}_2}$ and there exist a substitution $\delta$ such that  $(\Psi_2)_{\atnew{\vec{c}_2}}\vdash \Psi_1\delta$ and $(\Psi_2)_{\atnew{\vec{c}_2}}\vdash X\sigma_2\aeq{C} X\sigma_1\delta$, for all $X\in \V$.
\end{definition}
%
%\begin{lemma}\label{lemma:quasiorder}
%    The relation $\ins{}$ defines a quasiorder (i.e. reflexive and transitive) in $\mathcal{U}(\probc)$.
%\end{lemma}
%
For example, for $\sigma = [Y\mapsto a, X\mapsto Z]$, $\sigma' = [Y\mapsto a, X\mapsto \tf{f}(Y,d), Z\mapsto \tf{f}(Y,d)]$,  we can verify that
\(
    \npair{\{\newswap{a}{c} \fix{C} Z\}, \sigma}{\atnew{c}}\ins{}\npair{\{\newswap{a}{c}\fix{C} Z, \newswap{a}{c_1}\fix{C} Y\}, \sigma'}{\atnew{c},\atnew{c_1}}
\).
In fact, for $\delta=[Z\mapsto \tf{f}(Y,d)]$:
%it is enough to  check that the items 1. and 2. of the Definition~\ref{def:ordering} hold 
    \begin{enumerate}
        \item $\new \atnew{c},\atnew{c_1}.\{\newswap{a}{c}\fix{C}Z, \newswap{a}{c_1}\fix{C} Y\}\vdash W\sigma' \aeq{c} W\sigma\delta$, for all $W\in \V$.
        \item $\new \atnew{c},\atnew{c_1}.\{\newswap{a}{c}\fix{C} Z, \newswap{a}{c_1}\fix{C} Y\}\vdash \newswap{a}{c}\fix{C} Z\delta$.
    \end{enumerate}
Unlike nominal unification\cite{DBLP:journals/tcs/UrbanPG04} (without equational theories), solvable nominal $\C$-unification problems need not have just one most general unifier. Thus, the role of the most general unifier  is taken on by a complete set of $\C$-unifiers:
\begin{definition}[Complete Set of $\C$-unifiers]
Let $\probc$ be a $\C$-unification problem. A {\em complete set of $\C$-unifiers of $\probc$} is a set of pairs $S$ that satisfies
\begin{enumerate}
    \item $S\subseteq \U{\probc}$;
     \item  For all $\npair{\Psi,\sigma}{\atnew{\pvec{c}'}} \in \U{\probc}$ there exists $\npair{\Phi,\sigma'}{\atnew{\pvec{c}''}}\in S$ s.t.\ $\npair{\Phi,\sigma'}{\atnew{\pvec{c}''}}\ins{} \npair{\Psi,\sigma}{\atnew{\pvec{c}'}}$.
\end{enumerate}
%$S$ is a  {\em minimal complete set of $\C$-unifiers} iff it is a complete set  that satisfies
%\begin{enumerate}
%\setcounter{enumi}{2}
%    \item Two distinct elements of $S$ are incomparable w.r.t. $\ins{}$, i.e., for all  pairs $\pair{\Psi_{\catnew{c}},\sigma}, \pair{\Psi_{\catnew{c}}',\sigma'} \in S$, $\pair{\Psi_{\catnew{c}},\sigma}\ins{} \pair{\Psi_{\catnew{c}}',\sigma'}$  implies $\pair{\Psi_{\catnew{c}},\sigma}= \pair{\Psi_{\catnew{c}}',\sigma'}$.
%\end{enumerate}
%A pair $\pair{\Psi_{\catnew{c}},\sigma}$ is a {\em most general $\C$-unifier} iff $\{\pair{\Psi_{\catnew{c}},\sigma}\}$ is a minimal complete set of $\C$-solutions. 
\end{definition}

%\begin{definition}
 %   A pair $\pair{\Psi_{\atnew{\pvec{c}'}},\sigma}$ is said to be a {\em most general solution} (mgs) of a problem $\probc$ when it is a minimal element of $\mathcal{U}(\probc)$ with respect to the relation $\ins{}$, that is, for all $\pair{\Psi'_{\atnew{\pvec{c}''}},\sigma'} \in \mathcal{U}(\probc)$, we have $\pair{\Upsilon_{\atnew{\pvec{c}'}},\sigma} \ins{} \pair{\Psi'_{\atnew{\pvec{c}''}},\sigma'}$.
%\end{definition}

%Unification problems are closed by instantiation, meaning that every instance of a solution is also a solution.

%\begin{lemma}[Closure by Instantiation]\label{lemma:closure-by-instantiation}
 %   Suppose $\pair{(\Psi_1)_{\atnew{\vec{c}_1}},\sigma_1}\in \mathcal{U}(\probc)$ and $\pair{(\Psi_1)_{\atnew{\vec{c}_1}},\sigma_1} \ins{} \pair{(\Psi_2)_{\atnew{\vec{c}_2}},\sigma_2}$. Then $ \pair{(\Psi_2)_{\atnew{\pvec{c}_2}},\sigma_2} \in \mathcal{U}(\probc)$.
%\end{lemma}



\subsection{$\texttt{Unify}_{\C}$: a rule-based algorithm for $\C$-unification}\label{ssec:unif-rules}

\begin{figure}[!t]
    \centering
    \begin{tabular}{@{}l@{ }l@{ \hspace{-0.4cm}}c@{ }l@{}}
        \hline
        &\\[-0.3cm]

        $(del)$ & $\newc{c}{}.Pr\uplus\{t\aeq{C}^? t\}$ & $\Longrightarrow$ & $\newc{c}{}.Pr$ \\

        $(\tf{f})$ & $\newc{c}{}.Pr\uplus\{\tf{f}(\tilde{t})_n \aeq{C}^{?} \tf{f}(\tilde{t'})_n\}$ & $\Longrightarrow$ & $\newc{c}{}.Pr\cup\{t_1\aeq{C}^{?} t_1',\ldots,t_n\aeq{C}^{?} t_n'\}$ \\

        $(\tf{f^C})$ & $\newc{c}{}.Pr\uplus\{\tf{f^C}(t_0,t_1) \aeq{C}^{?} \tf{f^C}(s_0,s_1)\}$ & $\Longrightarrow$ & $
        \left\{\begin{array}{@{}l@{}}
            \newc{c}{}.Pr\cup\{t_0\aeq{C}^{?} s_0,t_1\aeq{C}^{?} s_1\},\\[0.05cm]
            \newc{c}{}.Pr\cup\{t_0\aeq{C}^{?} s_1,t_1\aeq{C}^{?} s_0\}
        \end{array}
        \right.$\\[0.5cm]

        $([a])$ & $\newc{c}{}.Pr\uplus\{[a]t \aeq{C}^{?} [a]t'\}$ & $\Longrightarrow$ & $\newc{c}{}.Pr\cup\{t\aeq{C}^{?} t'\}$\\

        $(ab)$ & $\newc{c}{}.Pr\uplus\{[a]t \aeq{C}^{?} [b]t'\}$ & $\Longrightarrow$ & $\new\catnew{c},\atnew{c_1}.Pr\cup\{\newswap{a}{c_1}\act t\aeq{C}^{?} \newswap{b}{c_1}\act t'\}$ \\

        $(var)$ & $\newc{c}{}.Pr\uplus\{\pi\act X \aeq{C}^{?} \pi'\act X\}$ & $\Longrightarrow$ & $\newc{c}{}.Pr\cup\{(\pi'^{-1}\circ\pi)\act X\aeq{C}^? X\}$, \\

        & & & if $\pi'\neq \id$\\[0.1cm]

       $(inst_1)$ & $\newc{c}{}.Pr\uplus\{\pi\act X \aeq{C}^{?} t\}$ & $\overset{[X\mapsto \pi^{-1}\act t]}{\Longrightarrow}$ & $\newc{c}{}.Pr\{X\mapsto \pi^{-1}\act t\}$, if $X\notin\var{t}$\\[0.1cm]

       $(inst_2)$& $\newc{c}{}.Pr\uplus\{t\aeq{C}^{?} \pi\act X \}$ & $\overset{[X\mapsto \pi^{-1}\act t]}{\Longrightarrow}$ & $\newc{c}{}.Pr\{X\mapsto \pi^{-1}\act t\}$, if $X\notin\var{t}$\\
        &\\[-0.3cm]
        \hline
    \end{tabular}
    \caption{Simplification rules for $\aeq{C}$. The notation $(\tilde{t})_n$ abbreviates $(t_1,\ldots,t_n)$.}
    \label{fig:c-simp-rules}
\end{figure}

In this subsection, we introduce a set of \emph{simplification rules} (Figure~\ref{fig:c-simp-rules}) for ``solving'' nominal $\C$-unification problems. These rules simplify problems by transforming constraints into ``simpler'' ones, by running the derivation rules from Figure~\ref{fig:fixed-rules_new} in reverse. The rule $(\frule{\faeq{C}}{\tf{f^C}})$ splits a $\C$-unification problem into two, with the original problem solvable if at least one of the new problems is solvable. This requires working with finite sets of $\C$-unification problems, called \emph{extended $\C$-unification problems}, denoted as $\mathcal{M}$.
%The set of $\C$-solutions of $\mathcal{M}$ is $\U{\mathcal{M}} := \bigcup_{\probc\in\mathcal{M}}\U{\probc}$, meaning $\pair{\Phi_{\catnew{c}},\sigma}$ is a solution of $\mathcal{M}$ if it solves some $\probc \in \mathcal{M}$.

The algorithm ${\tt Unif}_{\C}$ starts with $\exprob=\{\probc\}$ and exhaustively applies simplification rules. 
%hat is, ${\tt Unif}_{\C}$ consists of selecting $\probc \in \exprob$, applying a rule, and then replacing $\probc$ with the resulting problem(s) that the application of the rule may generate. 
We denote by $\nf{\exprob}$ the normal forms of $\exprob$ by the  reduction relation $\Longrightarrow$ generated by the simplification rules. 
%with $\overset{*}{\Longrightarrow}$ as its reflexive-transitive closure. If $\exprob\overset{*}{\Longrightarrow} \exprob'$ and no further rules apply ($\exprob'\centernot\Longrightarrow$), $\exprob'$ is a \emph{normal form}, denoted $\nf{\exprob}$. 

\begin{restatable}[Termination]{theorem}{termination}\label{thm:termination}
The relation $\Longrightarrow$ is terminating.
\end{restatable}
%
Some constraints in $\probc$ cannot be simplified, we say that they are {\em reduced}. An equality constraint $s \aeq{C}^? t$ is \emph{reduced} if it satisfies one of the following:
\begin{itemize}
    \item $s$ is a suspension on a variable and $t$ is that variable (e.g., $\pi\act X \aeq{C}^? X$).
    \item $s$ and $t$ are distinct atoms (e.g. $a\aeq{C}^? b$).
    \item $s$ and $t$ have different head symbols (e.g., $\tf{f}(u) \aeq{C}^? \tf{g}(v)$).
    \item $s$ and $t$ have different root constructors (e.g., $[a]s' \aeq{C}^? \tf{f}(t)$).
    \item $s$ is a suspension on some variable, $t$ is not a suspension, but $t$ contains occurrences of that variable (e.g. $X \aeq{C}^? \tf{f}(X,a)$).
\end{itemize}

The first form, which is a fixed-point equation, is \emph{consistent}; the others are \emph{inconsistent}.  A problem $\probc = \newc{c}{}.Pr$ is \emph{reduced} if all constraints in $Pr$ are reduced.  
A problem $\probc$  is called {\em solvable} if its normal form $ \nf{\probc} $ contains a reduced problem where all the constraints are consistent.
In this case, we compute $\sol{\probc}$ as the set of pairs $\npair{\Upsilon, \sigma}{\atnew{\pvec{c}'}}$ 
where 
%that are $\C$-unifiers of solvable reduced problems $\probc'\in \exprob'$.
%For each $\pair{\Upsilon_{\atnew{\pvec{c}'}},\sigma}$,  
$\atnew{\pvec{c}'}$ includes the set of names generated in the simplification process (i.e. $\atnew{\pvec{c}}\subseteq \atnew{\pvec{c}'}$), 
$\Upsilon_{\atnew{\pvec{c}'}} = \new \atnew{\pvec{c}'}.\{\pi\fix{C} X \mid \pi\act X \aeq{C}^? X \in {\probc'} \text{~solvable~and~}  {\probc'}\in \nf{\probc} \}$, and $\sigma$ is either $Id$ (if no instantiation rules were used) or the composition of substitutions used throughout the simplification of a branch starting in $\probc$ and ending in $\probc'$.
% Consequently, a problem $\probc$ is reduced iff $\probc = \nf{\{\probc\}}$. 
% It  is \emph{successful} (or solvable) if $\nf{\{\probc\}} = \alert{\emptyset_{\atnew{\pvec{c}'}}}$ or contains only consistent constraints; otherwise, the problem \emph{fails} (is unsolvable).
% A problem $\probc$ (not necessarily reduced) is called {\em solvable} iff there exists a reduced $\probc'\in \exprob'$ such that $\exprob\overset{*}{\Longrightarrow}\exprob'$ and $\probc'$ is solvable.  Here, $\exprob:=\{\probc\}$ is the extended $\C$-unification problem associated to $\probc$t  .  
%The set of solutions of a solvable  problem $\probc$, denoted as $\sol{\probc}$,  consists of the set of pairs $\pair{\Upsilon_{\atnew{\pvec{c}'}}, \sigma}$ that are $\C$-unifiers of solvable reduced problems $\probc'\in \exprob'$.
%For each $\pair{\Upsilon_{\atnew{\pvec{c}'}},\sigma}$,  $\catnew{c}\subseteq \atnew{\pvec{c}'}$ is the set of names generated in the simplification process, $\Upsilon_{\atnew{\pvec{c}'}} = \new \atnew{\pvec{c}'}.\{\pi\fix{C} X \mid \pi\act X \aeq{C}^? X \in {\probc'}\}$, and $\sigma$ is either $Id$ (if no instantiation rules were used) or the composition of substitutions used throughout the simplification of a branch starting in $\probc$ and ending in $\probc'$.
%A failing $\probc$ is \emph{unsolvable}; otherwise, it is \emph{solvable}, with solution


%An extended $\C$-problem $\exprob$ is \emph{reduced} iff all $\probc' \in \nf{\exprob}$ are reduced, and \emph{successful} if some $\probc' \in \nf{\exprob}$ is successful. Otherwise, $\exprob$ \emph{fails} and is \emph{unsolvable}. If $\exprob$ is successful, its solutions are $\sol{\exprob} = \{\sol{\probc'} \mid \probc' \in \nf{\mathcal{M}} \text{ is successful}\}$.

%This process defines the algorithm $\texttt{unify}$ as follows:

%\begin{algorithm}
%\caption{A pseudocode for the $\texttt{unify}$ algorithm}\label{alg:unify}
%\begin{algorithmic}
%\State \textbf{Input:} a nominal $\C$-unification problem $\probc$;
%\State \textbf{Output:} a finite, complete set of $\C$-solutions $S$ solving the input, or the empty set, if the input has no solutions;
%\State $\sol{\exprob}:=\emptyset$;
%\State $\mathcal{M}:=\{\probc\};$
%\While{there is some $\mathcal{M}$ such that $\mathcal{M}\Longrightarrow \mathcal{M}'$}
%$\mathcal{M}:=\mathcal{M}'$;
%\For {each $\probc\in\mathcal{M}$}
%\If{$\probc = \nf{\probc}$ and $\nf{\probc}$ is successful} $\sol{\exprob}:=\sol{\exprob}\cup\{\sol{\probc}\}$;
%\Else{ $\sol{\exprob}:=\sol{\exprob}$};
%\EndIf
%\EndFor
%\EndWhile  { and \bf return} $\sol{\exprob}$;
%\end{algorithmic}
%\end{algorithm}

 \begin{example}
    Suppose $\Sigma = \{\wedge:2\}$. Let $\probc = \{[a](X\wedge Y) \aeq{C}^? [b](Y\wedge X)\}$. Then
    \[
        \probc \overset{*}{\Longrightarrow} \{ \new \atnew{c_1}.\{(a \ \atnew{c_1} \ b)\act X\aeq{C}^?  X\},\new \atnew{c_1}.\{(a \ b \ \atnew{c_1})\act X\aeq{C}^? X, (a \ b \ \atnew{c_1})\act Y \aeq{C}^? Y\}\}.
    \]
    %
    The algorithm computes two solutions:
  $\npair{\{(a \ \atnew{c_1} \ b)\fix{C}  X\},[Y\mapsto (a \ \atnew{c_1} \ b)\act X]}{\atnew{c_1}}$ and 
 $ \npair{\{(a \ b \ \atnew{c_1})\fix{C} X, (a \ b \ \atnew{c_1})\fix{C} Y\},Id}{\atnew{c_1}}$ (a complete set of $\C$-solutions of $\probc$). Note that, by taking $\delta = [Y\mapsto X]$, the first  is an instance of the second.
\end{example}

\begin{remark}\label{rmk:substitution}
Substitutions feature $\new$-quantified names, as in $\sigma = [Y \mapsto (a \ \atnew{c_1} \ b) \act X]$. This is a desirable property that shows that solutions are stable under the choice of new names for renaming that can be done throughout computation.  This is achieved using the concept of a $\new$-substitution,  
%or, more succinctly, $\sigma_{\catnew{c}}$,
which provides a systematic way to track freshness information.
\end{remark}

The next result shows that if a $\C$-unification problem $\probc$ is solvable, our algorithm ${\tt Unif}_{\C}$ will output  $\sol{\probc}$ which is a complete set of solutions of $\probc$. 
\begin{restatable}[Correctness]{theorem}{correctness}\label{thm:correctness-simp-rules}
    Let $\probc$ be a problem such that $\probc\overset{*}{\Longrightarrow} \nf{\probc}$. If $\probc$ is solvable, then the following hold: 
    \begin{enumerate}
        \item \textnormal{(Soundness)} $\sol{\probc}\subseteq \U{\probc}$.
       
        \item \textnormal{(Completeness)} If $\npair{\Phi,\tau}{\atnew{\pvec{c}''}}\in \U{\probc}$ then there exists $\npair{\Psi,\sigma}{\atnew{\pvec{c}'}}\in\sol{\probc}$ s.t. $\npair{\Psi,\sigma}{\atnew{\pvec{c}'}}\ins{} \npair{\Phi,\tau}{\atnew{\pvec{c}''}}$. The set $\sol{\probc}$ is a complete set of $\C$-unifiers of $\probc$.
    \end{enumerate}
\end{restatable}

A direct consequence of termination and correctness is that the complete set of $\C$-unifiers of a $\probc$ is always finite.
\begin{corollary}
   $\C$-unification using generalised fixed-point constraints is finitary.
\end{corollary}
\section{Related Work.}
Gabbay and Mathijssen~\cite{DBLP:journals/logcom/GabbayM09} define a sound and complete proof system for nominal algebra, where derivation rules are subject to freshness conditions,
%$a\#t$.  (read ``$a$ is fresh for $t$'' ).
and provide a semantics in the class of nominal sets. %(sets with a finitely supported permutation action), which have a rich structure to reason about names, the permutation of names, and name binding.
Nominal sets also give an absolute denotation for first-order logic~\cite{DBLP:journals/jacm/Gabbay16}, and more recently for predicate logic~\cite{dowek2023nominalsemanticspredicatelogic}.
%\alert{However, to our knowledge, none of these works explore the nominal algebra semantics induced by properties of function symbols, such as commutativity, in the language considered.}

 Applications of nominal techniques in languages where operators satisfy equational axioms were studied in various contexts, using freshness constraints in the definition of $\alpha$-equivalence: e.g., to specify syntactic reasoning algorithms to  show properties of program transformations on higher-order expressions in call-by-need functional languages, taking into account e.g. {\tt letrec} constructs~\cite{DBLP:journals/fuin/Schmidt-Schauss22};  in theorem-proving, due to nominal logic’s equivariance property,  a different form of unification,  called equivariant unification, was investigated in~\cite{DBLP:journals/jar/Cheney10};
 applications in theorem-proving and rewrite-based programming languages also require the use e.g. of {\tt A} and/or {\tt C} operators~\cite{AYALARINCON20193}.  Nominal unification algorithms modulo commutativity are available, which generate infinite complete sets of solutions expressed using freshness constraints and substitutions~\cite{DBLP:conf/frocos/Ayala-RinconSFN17,   DBLP:journals/mscs/Ayala-RinconSFS21}. 
The finitary  algorithm  developed here opens the path for  extensions of programming languages such as  $\alpha$-prolog~\cite{DBLP:conf/iclp/CheneyU04}, building commutativity into the unification algorithm. 


Alternative approaches to representing binders, beyond the already-mentioned HOAS, include the $\lambda\sigma$-calculus\cite{DBLP:journals/jfp/AbadiCCL91} and the locally nameless  representation~\cite{DBLP:journals/jar/Chargueraud12}. The $\lambda\sigma$-calculus is based on the definition of  explicit capture-avoiding substitutions. However, a significant drawback is that it does not support reasoning about open terms, as it lacks confluence when applied to terms with meta-variables.
Handling meta-variables effectively is essential for reasoning about binders in  in proof assistants, such as AutoSubst2~\cite{DBLP:conf/cpp/StarkSK19}, which provides support for formalising metatheory in Coq. It is based on the  $\lambda\sigma$-calculus and could benefit from an alternative approach to computing substitutions for meta-variables—one that systematically accounts for the required renamings.
%focusing in particular on the use of this technique in formal proofs.


%Locally nameless approach to the representation of syntax
% Fixed-point permutation constraints were introduced by Ayala-Rinc\'on et al~\cite{DBLP:journals/lmcs/Ayala-RinconFN19}, where a derivation system was provided together with a translation from  the standard presentation using freshness constraints,  as well as a nominal unification algorithm. Nominal algebra semantics for fixed-point constraints was first studied by Caires-Santos et al~\cite{entics:14777}, where it was shown that the derivation rules given in~\cite{DBLP:journals/lmcs/Ayala-RinconFN19} are sound only for strong nominal sets. A restricted proof system was shown to be sound for   nominal sets without  equational theories.
 %Also,  symmetric rules are used for the abstraction case (which facilitates the proof that the defined relation is indeed an equivalence relation). Here we prove correctness, and study satisfiability, which was not considered in~\cite{entics:14777}.



\section{Conclusion}

We introduced a novel framework for equational reasoning modulo commutativity in languages with binders, using nominal techniques with ($\new$-quantified) permutation fixed-point constraints. This approach integrates commutativity into $\alpha$-equivalence reasoning without relying on freshness constraints, ensuring soundness and completeness in nominal set semantics.
% By analysing permutation cycles in fixed-point assumptions, we developed a sound and complete proof system for nominal algebras, ensuring correctness with respect to standard nominal set semantics.
%
Additionally, we proposed a terminating and correct $\C$-unification algorithm that provides finite complete set of solutions, addressing a key limitation of previous methods that produced infinite solutions when using freshness constraints. Our results establish a solid foundation for reasoning about syntax with binding and equational properties, with potential applications in theorem proving, programming language semantics, and automated reasoning systems.

Future work includes extending our approach to broader equational theories, e.g. integrating associativity along commutativity, and exploring practical implementations in verification tools.


%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
 \bibliographystyle{splncs04}
 \bibliography{references}
%

%\clearpage
%\newgeometry{left=1.5cm, right=1.5cm}

\appendix

\input{extended-appendix}

\end{document}
