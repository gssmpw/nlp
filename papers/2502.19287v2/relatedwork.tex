\section{Related Work.}
Gabbay and Mathijssen~\cite{DBLP:journals/logcom/GabbayM09} define a sound and complete proof system for nominal algebra, where derivation rules are subject to freshness conditions,
%$a\#t$.  (read ``$a$ is fresh for $t$'' ).
and provide a semantics in the class of nominal sets. %(sets with a finitely supported permutation action), which have a rich structure to reason about names, the permutation of names, and name binding.
Nominal sets also give an absolute denotation for first-order logic~\cite{DBLP:journals/jacm/Gabbay16}, and more recently for predicate logic~\cite{dowek2023nominalsemanticspredicatelogic}.
%\alert{However, to our knowledge, none of these works explore the nominal algebra semantics induced by properties of function symbols, such as commutativity, in the language considered.}

 Applications of nominal techniques in languages where operators satisfy equational axioms were studied in various contexts, using freshness constraints in the definition of $\alpha$-equivalence: e.g., to specify syntactic reasoning algorithms to  show properties of program transformations on higher-order expressions in call-by-need functional languages, taking into account e.g. {\tt letrec} constructs~\cite{DBLP:journals/fuin/Schmidt-Schauss22};  in theorem-proving, due to nominal logic’s equivariance property,  a different form of unification,  called equivariant unification, was investigated in~\cite{DBLP:journals/jar/Cheney10};
 applications in theorem-proving and rewrite-based programming languages also require the use e.g. of {\tt A} and/or {\tt C} operators~\cite{AYALARINCON20193}.  Nominal unification algorithms modulo commutativity are available, which generate infinite complete sets of solutions expressed using freshness constraints and substitutions~\cite{DBLP:conf/frocos/Ayala-RinconSFN17,   DBLP:journals/mscs/Ayala-RinconSFS21}. 
The finitary  algorithm  developed here opens the path for  extensions of programming languages such as  $\alpha$-prolog~\cite{DBLP:conf/iclp/CheneyU04}, building commutativity into the unification algorithm. 


Alternative approaches to representing binders, beyond the already-mentioned HOAS, include the $\lambda\sigma$-calculus\cite{DBLP:journals/jfp/AbadiCCL91} and the locally nameless  representation~\cite{DBLP:journals/jar/Chargueraud12}. The $\lambda\sigma$-calculus is based on the definition of  explicit capture-avoiding substitutions. However, a significant drawback is that it does not support reasoning about open terms, as it lacks confluence when applied to terms with meta-variables.
Handling meta-variables effectively is essential for reasoning about binders in  in proof assistants, such as AutoSubst2~\cite{DBLP:conf/cpp/StarkSK19}, which provides support for formalising metatheory in Coq. It is based on the  $\lambda\sigma$-calculus and could benefit from an alternative approach to computing substitutions for meta-variables—one that systematically accounts for the required renamings.
%focusing in particular on the use of this technique in formal proofs.


%Locally nameless approach to the representation of syntax
% Fixed-point permutation constraints were introduced by Ayala-Rinc\'on et al~\cite{DBLP:journals/lmcs/Ayala-RinconFN19}, where a derivation system was provided together with a translation from  the standard presentation using freshness constraints,  as well as a nominal unification algorithm. Nominal algebra semantics for fixed-point constraints was first studied by Caires-Santos et al~\cite{entics:14777}, where it was shown that the derivation rules given in~\cite{DBLP:journals/lmcs/Ayala-RinconFN19} are sound only for strong nominal sets. A restricted proof system was shown to be sound for   nominal sets without  equational theories.
 %Also,  symmetric rules are used for the abstraction case (which facilitates the proof that the defined relation is indeed an equivalence relation). Here we prove correctness, and study satisfiability, which was not considered in~\cite{entics:14777}.