\section{Introduction}


Web applications are ubiquitous---so are their security problems.
In particular, the vulnerability class of Cross-Site Scripting (XSS) remains one of the major security issues on the Web.
Over the past decade, XSS has been studied extensively, with a focus on approaches to detect these flaws in existing applications.
This detection relies on the identification of insecure data flows from attacker-controlled inputs into security-sensitive sinks. 
The actual techniques to pursue this goal vary, but they all rely on the availability of observable evidence of such data flows.
This can be as simple as the re-identification of an input string in the application's HTML, in the case of manual bug hunting, and as sophisticated as fully automatic taint analysis.

This poses a problem for an often overlooked component of large web applications: \emph{the backend}. Similar to the use of web technologies in its public frontend, the same application often employs web interfaces for its internal backends.
These interfaces, inaccessible from the public internet behind a firewall, serve various internal application functions, including administration of the application, usage analysis, and back-office tasks such as supply chain management and accounting. 

Not different from public web applications, internal web tools are also susceptible to security problems in general and XSS in particular. 
As these backend systems process data generated by the application's public counterpart, there is a high likelihood of data from potentially malicious, attacker-supplied inputs flowing into the backend's web code. 
This situation opens the door for XSS attacks on internal application components.
However, current XSS detection techniques fall short in finding such flaws, as no evidence of problematic data flows can be obtained. All effects of the public-to-internal flows remain within the constraints of the internal systems.
Testing tools operating from the outside are literally ``blind'' to any side effects caused by injection attempts. 

In this paper, we present the first comprehensive study on \textit{Blind Cross-Site Scripting (BXSS)} vulnerabilities. As by definition \textit{no} direct channels from the affected system-under-test and the testing approach exist, the only option to verify the presence of a BXSS vulnerability is the injection and execution of JavaScript code. 
To this end, we present a method for synthesizing \emph{polyglots}: XSS payloads specifically designed for a multitude of injection contexts. More specifically, we use Monte Carlo tree search (MCTS) to synthesize a small set of seven polyglots, capable of executing code in all test cases of a state-of-the-art XSS testbed (see \Cref{sec:generation}). 

However, good performance on an artificial testbed does not necessarily result in similar properties in real-world settings. For this reason, we validate the generated polyglots on a set of recently uncovered client-side XSS vulnerabilities found in the Tranco Top \num{10000} websites. To do so, we compare the polyglots' capability to uncover vulnerabilities with the currently established state-of-the-art method of precise payload generation~\cite{StoPfiKaiLek+15,LekStoJoh13,MelDasShaBau+18,BenKleBarJoh21,KleBarBen+22,stock2017web}. In this experiment our blind polyglots prove to be highly competitive with precise exploit generation, through triggering 147 vulnerabilities compared to 145 found by the precise payload generation. Furthermore, the generated polyglots vastly outperform the well-known, manually crafted ``Ultimate Polyglot''~\cite{ultimate-polyglot} (see \Cref{sec:taint-validation} for details).

Finally, we present the---to the best of our knowledge---first study on BXSS in the wild. We conduct a large-scale analysis of the Tranco Top \num{100000} websites using our generated polyglots as testing payloads, uncovering~\num{20} instances of BXSS problems in internal systems. This study demonstrates that our testing approach is well suited to detect BXSS vulnerabilities in real-world websites, as well as, the existence of this vulnerability class (see \Cref{sec:bxss-study}) on popular websites. 


\paragraph{Contribution.} In summary, we make the following contributions in this paper:
\begin{itemize}
\setlength\itemsep{-0.2em} %

\item We propose a method for automatically synthesizing a small set of XSS polyglots using Monte Carlo tree search, covering all currently known injection contexts. %

\item We show that the polyglots synthesized by our method achieve comparable performance to state-of-the-art vulnerability detection for client-side \xss{}. %

\item We design a methodology to detect backend XSS automatically and use it to conduct a large-scale evaluation on the \num{100000} most popular websites, finding \num{20}~BXSS vulnerabilities in \num{18} backend systems. %
\end{itemize}

