% Note: (The following is out of date). To compute the solution for a subgame in the set $\{ G_{\theta} \}_{\theta \in \Theta_1}$, the subroutine $\textsc{findnash}$ converts the game into sequence-form, constructs a series of matrices and vectors to create the linear complementarity problem, and then solves it with the Lemke-Howson algorithm. %relevant citations: Koller '96 Efficient Computation of Equilibria for Extensive Two-Person Games
% also relevant: used the Lemke-Howson implementation at github.com/AndyLamperski/lemkelcp
% In order to avoid the pitfall of the algorithm failing to terminate because of degeneracy, we added the $\varepsilon$ perturbation suggested in the paper to the column vector $\mathbf{b}$. % see page 9
% The solution is then converted into a format compatible with the game tree.

% Most of these can just be dumped into the appendices provided we do a good enough job describing them with language

\subsection{Subroutines for Organizing Subgames}

\begin{algorithm}[H]
\renewcommand{\thealgorithm}{}
\small
\floatname{algorithm}{GetSubgameRoots}
\caption{Algorithm that constructs a subtree $\Psi$ containing all the roots of the subgames within a game $G$}
\label{alg:get_roots}
\begin{algorithmic}
\Require{Input game $G$}

\State{Initialize $\Psi$ to contain only the game root $h_0$}

\For{$h \in D$, beginning with those closest to the root node}
\If{$|I(h)| == 1$ and if for every node $h'$ that succeeds $h$, every node $h'' \in I(h')$ succeeds $h$ (see $\varphi(h')$, $\varphi(h'')$)}
\State{Add $h$ to $\Psi$ via an outgoing edge from the closest node $h'$ in $\Psi$ that precedes $h$ (i.e. $(h', h)$)}
\EndIf
\EndFor

\vspace{1em}
\Return $\Psi$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\renewcommand{\thealgorithm}{}
\small
\floatname{algorithm}{GetSubgameGroups}
\caption{Algorithm that groups the subgames of $G$ by their height in $\Psi$}
\label{alg:get_pruning_seq}
\begin{algorithmic}
\Require{Input game $G$, subtree of subgame roots $\Psi$, maximum height $\ell$}

\State{Initialize each set $\Theta_k$ of subgames whose roots are in $\Psi$ at a height $k$ to $\emptyset$, for all $1 \leq k \leq \ell$}
\For{$h_{\theta} \in \Psi$}
\State{Add the identifier $\theta$ of subgame $G_{\theta}$ with root $h_{\theta}$ at height $k$ in the subtree $\Psi$ to $\Theta_k$}
\EndFor

\vspace{1em}
\Return $\{ \Theta_k \}_{k = 1}^{\ell}$
\end{algorithmic}
\end{algorithm}

\newpage
\subsection{GBI}

\begin{algorithm}[H]
\renewcommand{\thealgorithm}{}
\small
\floatname{algorithm}{GBI}
\caption{Generalized backward induction \citep{kaminski19}}
\label{alg:brute_compute_spe}
\begin{algorithmic}
\Require{Input game $G$}

\State{$\Psi \gets \textsc{GetSubgameRoots}(G)$}
\State{$\ell \gets$ height of $h_0$ in $\Psi$}
\State{$\{ \Theta_k \}_{k = 1}^{\ell} \gets \textsc{GetSubgameGroups}(G, \Psi, \ell)$}
\State{$\Sigma^{SPE}_1 \gets \{ \textsc{GetInitialSPE}(G, \Theta_1) \}$}
\For{$1 \leq k < \ell$}
\If{$\Sigma^{SPE}_k = \emptyset$}
\Return $\emptyset$
\EndIf
\State{$S^{k + 1} \gets \bigcup\limits_{\theta \in \Theta_{k + 1}, j \in N} \left( \bigtimes_{I \in \left.\cI_j\right|_{G_{\theta}}} \left.A_j\right|_{G_{\theta}}(I) \right)$}
\For{$\bsigma^k \in \Sigma^{SPE}_k$}
\For{$\bsigma^{k + 1} \in S^{k + 1}$}
\For{$\theta \in \Theta_{k + 1}$}
\If{ $\neg \textsc{IsNash}(\left.\bsigma^{k + 1}\right|_{G_{\theta}}, G_{\theta})$}
\State{Discard $\bsigma^k \cup \bsigma^{k + 1}$}
\EndIf
% \State{Replace $G_{\theta}$ in $G$ with terminal node and payoff vector $U( \left.\bsigma^{k + 1}\right|_{G_{\theta}} \mid h_{\theta})$}
\State{Replace $G_{\theta}$ with terminal node and payoff $U\left( \left.\bsigma^{k + 1}\right|_{G_{\theta}} \right)$}
\EndFor
\State{Add $\bsigma^k \cup \bsigma^{k + 1}$ to $\Sigma^{SPE}_{k + 1}$}
\EndFor
\EndFor
\EndFor

\Return $\Sigma^{SPE}_{\ell}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\renewcommand{\thealgorithm}{}
\small
\floatname{algorithm}{IsNash}
\caption{Algorithm for checking whether a partial solution $\left.\bsigma\right|_{G_{\theta}}$ is a NE of a subgame $G_{\theta}$ where $\theta \in \Theta_k$}
\label{alg:is_nash}
\begin{algorithmic}
\Require{Partial solution profile $\left.\bsigma\right|_{G_{\theta}}$, subgame $G_{\theta}$, $\theta \in \Theta_k$}
\vspace{1em}
\For{$j \in N$}
\State{$\left.S_j\right|_{G_{\theta}} = \times_{I \in \left.\cI_j\right|_{G_{\theta}}} \left.A_j\right|_{G_{\theta}}(I)$}
\For{$\bm{s}_j \in \left.S_j\right|_{G_{\theta}}$}
\If{$\hat{U}_j \left( \bm{s}_j, \left.\bsigma_{-j}\right|_{G_{\theta}} \right) > \hat{U}_j \left( \left.\bsigma\right|_{G_{\theta}} \right)$}
\Return False
\EndIf

\EndFor
\EndFor

\vspace{1em}
\Return True
\end{algorithmic}
\end{algorithm}

\newpage
\subsection{Subroutines for \textsc{ComputeSPE}}

\begin{algorithm}[H]
\renewcommand{\thealgorithm}{}
\small
\floatname{algorithm}{GetInitialSPE}
\caption{Algorithm that finds the initial set of partial SPE for the subgames closest to the terminal nodes in $G$}
\label{alg:get_spe_theta1}
\begin{algorithmic}
\Require{Input game $G$, subgame identifier set $\Theta_1$}

%\State{Initialize $\sigma^{NE}_1 = \emptyset$}
\State{Initialize $\bsigma^{SPE}_1 = \emptyset$}
\For{$\theta \in \Theta_1$}
% USE BLACK-BOX FIND_NASH ALGORITHM LIKE DLP FOR SEQUENCE-FORM
\State{Find a NE for the subgame $\left.\bsigma^{NE}\right|_{G_{\theta}} = \textsc{SubgameCFR}(G_{\theta})$}
\State{$\bsigma^{SPE}_1 = \bsigma^{SPE}_1 \cup \left.\bsigma^{NE}\right|_{G_{\theta}}$}
\EndFor

\vspace{1em}
\Return{$\bsigma^{SPE}_1$}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\renewcommand{\thealgorithm}{}
\small
\floatname{algorithm}{\textsc{SubgameCFR}}
\caption{Adaptation of CFR for computing subgame SPE}
\label{alg:subgame_cfr}
\begin{algorithmic}
\Require{subgame $G_{\theta}$, partial SPE profile $\left.\bsigma^\mathit{SPE}\right|_{G_{\theta}}$, timesteps $T$}

\State{$\cI_{G_{\theta} \setminus \bsigma} \gets \{ I \in G_{\theta} \mid I \notin \left.\bsigma^\mathit{SPE}\right|_{G_{\theta}} \}$}
\If{$V(h_{\theta}) = 0$ and $\cI_{G_{\theta} \setminus \bsigma} = \emptyset$}
\Return $\left.\bsigma^\mathit{SPE}\right|_{G_{\theta}}$
\EndIf
\For{$I \in \cI_{G_{\theta} \setminus \bsigma}$}
\State $j \gets V(I)$
\State{$\bsigma^1(I)(a) \gets \frac{1}{\mid A_{j}(I) \mid}$ for all $a \in A_{j}(I)$}
\State{$R_I[a] \gets 0$ for for all $a \in A_{j}(I)$}
\State{$S_I[a] \gets 0$ for all $a \in A_{j}(I)$}
\EndFor

\For{$t \in \{1, \dotsc, T\}$}
\State{$u^{*} \gets \textsc{Traverse}\left( h_{G_{\theta}}, t, 1, 1, 1, G_{\theta}, \left.\bsigma^\mathit{SPE}\right|_{G_{\theta}} \right)$} % CFR Helper

\EndFor

\For{$I \in \cI_{G_{\theta} \setminus \bsigma}$}
\State{$\bsigma^{CFR}(I) \gets \textsc{Average}\left( \{ \bsigma^t(I) \}_{t = 1}^T \right)$}
\EndFor

\Return $\bsigma^{CFR} \cup \left.\bsigma^{SPE}\right|_{G_{\theta}}$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
\renewcommand{\thealgorithm}{}
\small
\floatname{algorithm}{\textsc{Traverse}}
\caption{Completes a full CFR-traversal of subgame $G_{\theta}$}
\label{alg:traverse}
\begin{algorithmic}
\Require{Node $h$, time $t$, reach probabilities $r_0$, $r_1, r_2$; subgame $G_{\theta}$, partial SPE $\left.\bsigma^{SPE}\right|_{G_{\theta}}$}

\State{$j \gets V(h)$}
\If{$j = 0$}
\State{$u^{*} = \vec{0}$}
\For{ $x \in X(h)$}
\State{$u^{*} \gets u^{*} + P(x \mid h) \cdot \textsc{Traverse}\left( hx, \hspace{0.05em} t, \hspace{0.05em} r_1, \hspace{0.05em} r_2, \hspace{0.05em} r_0 \cdot P(x \mid h), \hspace{0.05em} G_{\theta}, \hspace{0.05em} \left.\bsigma^{SPE}\right|_{G_{\theta}} \right)$}
%\Return$P(x \mid h) \cdot \textsc{Traverse}\left( hx, \hspace{0.05em} t, \hspace{0.05em} r_1, \hspace{0.05em} r_2, \hspace{0.05em} r_0 \cdot P(x \mid h), \hspace{0.05em} G_{\theta}, \hspace{0.05em} \left.\bsigma^{SPE}\right|_{G_{\theta}} \right)$
\EndFor
\Return $u^{*}$
\ElsIf{$h$ is terminal}
\Return $u(h)$
\ElsIf{$I(h) \in \left.\bsigma^{SPE}\right|_{G_{\theta}}$}
\Return $U(\left.\bsigma^{SPE}\right|_{G_{\theta}} \mid h)$
\EndIf

\State{$I \gets I(h)$}
\State{Initialize counterfactual utility $u^{*}_I \gets 0$}
\State{Initialize action utilities $u_I[a] \gets 0$ for $a \in A_{j}(I)$}
\For{$a \in A_{j}(I)$}
\If{$j = 1$}
\State{$u_I[a] \gets \textsc{Traverse}\left( ha, t, r_1 \cdot \bsigma^t(I)(a), r_2, r_0, G_{\theta}, \left.\bsigma^{SPE}\right|_{G_{\theta}} \right)$}
\Else
\State{$u_I[a] \gets \textsc{Traverse}\left( ha, t, r_1, r_2 \cdot \bsigma^t(I)(a), r_0, G_{\theta}, \left.\bsigma^{SPE}\right|_{G_{\theta}} \right)$}
\EndIf
\State{$u^{*}_I \gets u^{*}_I \mathrel{+} \bsigma^t(I)(a) \cdot u_I[a]$}
\EndFor

\State{$r_j, r_{-j} \gets \emptyset$}
\If{$j = 1$}
\State{$r_j \gets r_1$}
\State{$r_{-j} \gets r_2 r_0$}
\Else
\State{$r_j \gets r_2$}
\State{$r_{-j} \gets r_1 r_0$}
\EndIf
\For{$a \in A_{j}(I)$}
\State{$R_I(a) \gets R_I(a) \mathrel{+} r_{-j} \cdot \left(u_I[a][j] - u^{*}_I[j] \right)$}
\State{$S_I(a) \gets S_I(a) \mathrel{+} r_j \cdot \bsigma^t(I)(a)$}
\EndFor
\State{Update $\bsigma^{t + 1}(I)$ using $R_I(\cdot)$ values and regret-matching}

\Return $u^{*}_I$
\end{algorithmic}
\end{algorithm}





