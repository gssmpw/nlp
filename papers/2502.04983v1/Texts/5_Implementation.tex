\section{Implementation}
\sysName~is built using JavaScript for the front-end client, and our back-end uses OpenAIâ€™s ChatGPT \cite{openai_chatgpt} API, specifically using the GPT-4o Mini model.

\subsection{Prompt Design}

\textbf{Code Template Generation.} We first ask GPT to generate a template class code with a basic setting according to the JavaScript framework that users {will use}. %used. 
The framework is automatically {determined} 
% \hbc{according to the following descriptions, the system determines (rather suggest) the framework?} 
for users when {they input} %inputting 
general descriptions in {the} central module. For example, if the user inputs ``I want to make {a} %it a 
platform game'', {the} Phaser framework will be {selected;}
% selected
% \hbc{selected or suggested (mentioned earlier)?}; 
if he/she inputs ``make %it 
a creative coding project'', the p5.js framework is initialized. When a new element is created, an initial class template code will be added to the scene folder, and the central.js is also automatically initialized with the elements instantiated.

\textbf{Code Generation for Individual Elements and Multiple Elements.} {To guide GPT to generate output in a controlled manner, the text prompt has to follow a certain format. For individual element code,} we design the prompt {format} %\hbc{You mean the prompt has to follow a certain format? This should be clarified before introducing the details} 
mainly including \emph{Task}, \emph{Requirement}, \emph{Reference Code Template}, and \emph{Output Format}. The ``elementname'', ``effect'', and ``framework'' in the format will be replaced by the created element names, user's input texts (including the translated graphical information), and suggested framework name. Then they forms a text prompt to GPT{, which generates the} %and then generate 
code and context for {each} element. For interactions codes among multiple elements, we design the prompt in similar format with individuals, except for an extra context information and the output format. Please refer to the supplementary materials for the specific prompt designs. 
%\yhc{I merged two subsections.}


% \textbf{Code Generation for Multiple Elements.}
% We design the prompt for the central module mainly similar to the individual elements. One difference is it includes context information in the prompt for central module.
% \hbc{The description here is almost the same as that in the previous paragraph. Try to minimize the repeated info}


\subsection{Code Integration}
Once receiving the response, for individual module{s}, we extract the code, insert it to the element classes{, and insert} %and 
the context to the context information repository. When updating {an} element later, the newly generated code will replace the original one, and the newly updated context will be compared to the original ones and then {updated}. %updating. 
For the central module, we copy the code generated and replace the original {one}, %ones, 
and insert the newly defined variables and functions in the relevant individual element class code. The context information is also compared and updated correspondingly. The insert positions is determined by the pre-defined or guided-maintained flags (e.g., ``//variable start'', ``//variable end'', ``//function start'', ``//function end'') in the code.

