\section{Motivation}
\label{sec:background}

As mentioned in Section~\ref*{sec:intro}, a vulnerability-witnessing test is a test case that targets the security requirements of a certain code component (e.g., a class method) and whose failure indicates the likely presence of a vulnerability.
The concept has been mentioned in the work by Kang et al.~\cite{kang:issta2022:transfer} with an analogous meaning.
Namely, the study focused on vulnerabilities affecting third-party libraries and sought for test cases starting from the client application that could trigger the vulnerable behavior.
To do this search, Kang et al.~\cite{kang:issta2022:transfer} manually inspected 64 \Java open-source projects affected by 22 third-party vulnerabilities, finding 42 witnessing tests in total.
%In this work, we reuse the same concept but relax the focus on third-party vulnerabilities, extending the concept to any form of security flaw. 

\begin{listing}[t]
    \inputminted[
    frame=single,
    baselinestretch=1.2,
    fontsize=\tiny,
    escapeinside=||,
    linenos,
    xleftmargin=2em
    ]{java}{listings/motivating.java}
    \caption{Documented fix for CVE-2018-17202 and its related vulnerability-witnessing test in \textsc{Apache Commons Imaging}.}
    \label{lst:motivating}
\end{listing}

Listing~\ref{lst:motivating} shows the test witnessing an infinite loop vulnerability (CWE-835) affecting \textsc{Apache Commons Imaging}, disclosed via CVE-2018-17202\footnote{CVE-2018-17202: \url{https://www.cve.org/CVERecord?id=CVE-2018-17202}}.
If this test is run on the vulnerable version (i.e., the one including the \texttt{while} statement highlighted as red in Listing~\ref{lst:motivating}) it will fail due to taking more than two seconds, set by the test author as a cut-off to decree an infinite loop occured (i.e., the execution must terminate within two seconds).
%Such a test has been created in the same commit that patched the vulnerability.\footnote{CVE-2018-17202 fix: \url{https://github.com/apache/commons-imaging/commit/6a79d3}}
Consequently, when the test is run on the fixed version, it will pass, indicating the absence of the infinite loop vulnerability.

The example shown in Listing~\ref{lst:motivating} is part of \VulforJ; to have it be part of the dataset, the authors started from the vulnerabilities appearing in \projectKB~\cite{ponta:msr2019:projectkb}, a manually-curated dataset of publicly disclosed vulnerabilities linked to their corresponding fixing commits from hundreds open-source \Java projects.
From this, only those vulnerabilities with one and only one accessible fixing commit were selected.
Then, each fixing commit was manually inspected, and the vulnerabilities not directly related to \Java code, e.g., modifying an XML configuration file, were discarded.
%
With a single fixing commit, it was easy to identify the versions in which the project was \textit{vulnerable} (i.e., the revision before the fix), and when it was \textit{patched} (i.e., the revision resulting after applying the fix).
The patched version was built (via the project's build automation system, such as \textsc{Maven}) and, in case no build error was raised, its test suite was run, obtaining a record of passing and failing tests.
Then, the project is checked out to the vulnerable version while keeping the same test suite used for the patched version and built again.
If no build errors are raised, the test suite is run and a new record of passing and failing tests is stored.
% 
At this point, the two records of tests were compared: if a test passed on the patched version but failed on the vulnerable version, then the test was qualified as a witness of the vulnerability (a.k.a. Proof of Vulnerability in the original paper) believed to happened to the presence of the flawed code.

We observe that this process bears its fruits when two main conditions are met.
First, \textbf{the building must succeed for both the vulnerable and patched versions}, which happened only in 139 out of 417 ($\sim$33\%) candidate patches.
Then, the two test suite runs must result in tests failing on the vulnerable version and passing on the patched version.
This requirement can only happen if \textbf{the witnessing tests exist in the test suite exactly the patched version}, which happened only for 69 out of 139 ($\sim$50\%) buildable patches.
In summary, the whole process was successful only for 17\% of the candidate patches.\footnote{
For ten patches not exhibiting any witnessing tests and where the fixing commit had changed no more than three lines, the authors manually developed the missing test cases to enlarge the dataset further; such tests have been added into \VulforJ despite not existing in the ``official'' projects' test suites.
}
% Without the fixing commit, the approach used to build \VulforJ cannot have access to the right $\langle$vulnerable--patched$\rangle$ versions easily pairs.
% Indeed, the only option left is to build as many pairs of consecutive revisions $\langle v_1, v_2\rangle$ as possible and observe which test case failed on the $v_2$ version but failed on the $v_2$ one.
% Although theoretically possible, this does not assure the test is witnessing a vulnerability, as $v_2$ might not be fixing a vulnerability, so likely inducing into mistakenly flagging tests as witness.
% Therefore, a large manual inspection effort is needed, ending up to read and inspect thousands of test cases manually~\cite{lin:ist2014:test:reduction}.
% Furthermore, the prelevance of vulnerability-witnessing tests among tests suites is noticeably low.
% Indeed, \VulforJ found a total of 108 tests among 51 projects, each having test suites made of thousands of test cases on average.
%
%Even by managing to have access to the vulnerability fix commits, the vulnerability-witnessing test might not existing in the patched version (as we have seen for \VulforJ when the authors manually crafted missing test cases). In such a scenario, \VulforJ is unable to record information from the test execution to pinpoint to the right witnessing test.

We developed \vuteco to circumvent such requirements.
First, \vuteco is a fully static approach that can retrieve witnessing tests in any project, even if not buildable. This is meant to reduce the chances of missing interesting tests only because of errors unrelated to the test itself.
%
Then, it checks for the presence of a witnessing test at a selected version of the test suite (e.g., the latest revision) without requiring the witnessing test to exist when the vulnerability was fixed.
