\documentclass[../main.tex]{subfiles}
%\graphicspath{{\subfix{../images}}}
%\makeatletter
%\def\input@path{{../images}}
%\makeatother
\begin{document}
\section{Experiments}
\label{sec:exp}
In the following, we realise the PBRM with a neural SCDF. We use a single arm YuMi (SAY) \citep{say} in the experiments, where we only plan for its first three axes and keep the wrist fixed. The configuration space is defined as $\C = (-\pi, \pi)^3$.
\subsection{Neural signed configuration distance function}
\subsubsection{Obstacle parameterization and rotational equivariance}
In the following, we assume that the obstacles are spherical, meaning that the geometry vector is described as $\geom=\begin{bmatrix} \c^\top, \: r \end{bmatrix}^\top$, where $\c \in \R^3$ is the center position and $r \in \R_{+}$ the radius. Furthermore, since the first joint of our considered robot type has a rotation around the $z$-axis and our obstacles are rotation symmetrical, we end up with a rotation equivariance around the $z$-axis. This means that if we rotate both the robot and the obstacle by $\theta$ around the $z$-axis using the rotation matrix $\Rotz(\theta) \in \text{SO}(3)$, then the signed distance will be equivalent to the signed distance in the untransformed case. Thus, we have the following equivariance
\begin{equation}
\funcNSD(\q, \c, r) = \funcNSD([\theta_1 + \theta, \: \theta_2, \:  \theta_3 ]^\top, \: \Rotz(\theta)\c, \: r).
\end{equation}
The above symmetry allows us to generate the obstacles positioned only in the $xz$-plane, which reduces the input space and simplifies the learning.
\subsubsection{Data generation and learning}
We generate a mesh for $\NrSampledObstacles=4096$ randomly generated obstacles. The sampling of the center is done by first sampling a radial distance uniformly, $r_{c}~\sim~\uniform(0.30, 0.55)$, and an angle, $\psi_{c}~\sim~\uniform(0, \pi/2)$, from which the center is formed in the $xz$-plane by polar coordinates. The radius of the obstacle is sampled from $r~\sim~\uniform(0.05, 0.10)$. We use \cite{trimesh} for collision-detection and running the marching cubes algorithm. For each mesh, we sample $\NrSampledDataPoints=2048$ configurations and compute the smallest distances with \cite{pcu}. This results in 8 million data points. We split the data set into train and test data set by using the data generated from the 3686 randomly selected obstacles as training data and the remaining 410 as test data, resulting in a $90/10\%$ split.
\\\\
We use a multi-layered neural network with $3$ linear layers and $256$ hidden units for all layers. Each hidden layer is passed through a ReLU activation function, except for the last layer, where no activation function is used. We train the neural network by using \cite{pytorch}. The training is stopped after 30 consecutive epochs of unimproved test loss and we save the network weights with the lowest test loss. The best test loss was $3.34 \cdot 10^{-3}$.
\subsubsection{Collision detection}
To validate the learned distance function, we evaluated its capability to detect collisions from the obstacles in the test data. For each obstacle, we sampled 2048 configurations and computed their collision status. We then queried the network for the distances and classified the configurations with negative distance as being in collision. The overall accuracy was $98.0\%$. The recall (accuracy among the configurations in collision) was $99.7\%$. The precision (accuracy over the predicted collisions) was $71.0\%$. The number of configurations that were in-collision were roughly $5 \%$. The precision highlights that our SCDF is somewhat conservative, but it still performs good enough to be used.
\subsection{Path Planning}
In the following experiments we evaluate the PBRMs capabilities, in both static and dynamic settings. Since the PBRM returns a sequence of intersecting spheres, $((\q_1, r_1), \hdots, (\q_{\NrBz}, r_{\NrBz}))$, we have the possibility to use convex optimization in order to produce a path. In the following experiments, we optimize for shortest path length by solving the following convex program
\begin{subequations}
\label{eq:cvx}
\begin{alignat}{2}
&\!\underset{\x_1, \hdots, \x_{\NrBz+1}}{\min} &\qquad& \sum_{i=1}^{\NrBz-1} \norm{\x_{i} - \x_{i+1}} \label{eq:cvx:obj} \\
&\text{subject to} 	&& \x_1 = \q_1, \: \x_{\NrBz+1} = \q_{\NrBz}, \label{eq:cvx:query} \\
&&& \norm{\x_{i} - \q_j} \le r_j , \: i = 2, \hdots \NrBz, j=i-1, \: i. \label{eq:cvx:int}
\end{alignat}
\end{subequations}
Here, the path consists of $\NrBz+1$ points and our objective is to minimize the path length \eqref{eq:cvx:obj}. The path starts and ends in the query pair \eqref{eq:cvx:query} and we limit the points to lie within the intersection of each neighboring sphere \eqref{eq:cvx:int}. This has the effect of producing the shortest path that lies within the union of spheres given by the PBRM.
\subsubsection{Static world}
\begin{wraptable}{r}{10cm}
\centering
\caption{Statistics (mean/max) over cases where both planners were successful. Shortcutting is abbreviated as SC.}
\label{tab:static:results}
\begin{tabular}{l ccc}
     					& PBRM & PRM	& 	PRM+SC \\ 
    \midrule
    Length [rad] & 7.1 / 15.9 &  7.4 / 18.0 & 5.9 / 13.7 \\
	Time [ms]&  3 / 9  &	171 /	534	 & 431 / 951 \\
    \bottomrule
\end{tabular}
\end{wraptable}
We evaluate our proposed planner in a randomized world with $8$ static obstacles. The obstacles are first sampled according to the data distribution and then positioned in the $xyz$-space by sampling a rotation around the $z$-axis, $\phi_s \sim \uniform(-\pi, \pi)$. Since our proposed planner is a multi-query planner, we benchmark it with PRM, with and without shortcutting. We use the implementation from OMPL~\citep{ompl}.  The planners were evaluated on~100 different world instances. For each world instance, the planner was evaluated on 10 random queries which could not be connected by a collision-free straight line path. The performance is measured based on the path length and time to produce the path. For the offline-phase, we used $\NrVerts=100$. This produced roadmaps with an average of 214~vertices and 327~edges. The mean time to construct the roadmap was 2.6~s and the mean estimated coverage was 87~\%. The used PRM implementation grows the roadmap at each query, thus over all experiments it resulted in a mean number of vertices and edges of~540 and~2425. The mean time to construct the roadmap was 1.5~s. In the online phase, PBRM was able to find a path in 48.3~\% of the queries, while PRM found a path in 44.9~\% of the cases. The somewhat low rate of reported path suggests that the world generation produced disjoint free spaces or free spaces with very narrow corridors with high probability. For PBRM, 7.4~\% of the reported paths were in collision. Among them, the largest penetration was 9 mm, thus rather minor collisions were observed. From the queries where both planners were able to return a path, we present the mean and max of the path lengths and computation times in Table \ref{tab:static:results}. The results show that our planner produces paths that are shorter compared to the PRM, even though our planner is on average smaller in size. The reason for why the gap is not larger is probably due to the fact that the PRM expands the roadmap at each query, which we do not do in our implementation. Observing the computation time, we see a clear benefit of not relying on collision-detection since our implementation is the fastest by a wide margin.
\subsubsection{Dynamic world}
To test how well our planner can handle moving obstacles, we evaluate its rewiring capabilities on new unseen obstacles which have not been considered in the offline phase. We use the same setup for the static obstacles as in the previous section, but here we use 5 static obstacles in every world instance. Once a world instance has been created, we start by sampling a collision-free goal configuration, where we limit the first joint axis to be within $(-\pi, -\pi/2)$. Next, we sample 10 different start configurations, where we limit the first joint axis to be within $(\pi/2, \pi)$. This results in query points which are on the opposite side of the configuration space w.r.t the first joint axis, thus making the problem more difficult. For each query, we sample an obstacle from the data distribution with a $z$ rotation sampled from $\phi \sim \uniform(-\pi/6, \pi/6)$ and that is not in collision with any of the query points. This obstacle will be used at run time to test the planners capability to adapt to new unseen obstacles. We refer to this obstacle as a test obstacle. We repeat the process for 10 different world instances.
\\\\
For each world instance, we use $\NrVerts=100$ and $\NrVertsExtra=150$. After growing the roadmap, we attach the goal configuration to the graph. Next, we start the online phase, where we introduce the test obstacle and query for a path from the planner. The experiments resulted in the planner being able to find a path in 91~\% of the cases, with none of the found paths being in collision. The average time to produce a path or report no path could be found was 43 ms. The main bottlenecks in the process were the rewiring and connecting the start configuration to the graph steps, with average times of 23 and 13 ms. However, both steps are amenable for parallelization and more optimized implementations, which would reduce their computation times significantly. The overall mean shows that our planner can rapidly produce a path at a high frequency and therefore could manage moving obstacles.
\iffalse
\begin{table}
\centering
\caption{Computation times for producing a path online with test obstacles. Columns rewire, connect and shortest path refer to the steps described in Section \ref{sec:pbrm:dyn}. The optimization column refers to solving \eqref{eq:cvx}. Finally, complete gives the time for all steps. }
\label{tab:dynamic:results}
\begin{tabular}{l ccccc}
Â´		& Rewire [ms] & Connect [ms] &  Shortest path [ms] & Optimization [ms] & Complete [ms] \\
\midrule
mean / max    & 23 / 81    &    13 / 135 &   1 /4   &  4 / 8 &  43 / 138 \\
    \bottomrule
\end{tabular}
\end{table}
\end{document}
\subsubsection{Straight line collision detection}
With the spheres produced by the SCDF, we can innovate on a new approach to perform straight line collision detection, which is the problem of verifying if the straight line segment connecting a start, $\qStart$, and a goal point, $\qGoal$ is collision-free. The idea is to cover the segment with a minimal set of spheres in $\C$, which we do in a recursive fashion. We start by computing the signed distance by using the learned SCDF for each endpoint, $r_s$ and $r_e$, and the distance between the endpoints $d=\norm{\qGoal-\qStart}$. Next, we compute the gap distance between the spheres, $g=d - r_s - r_e$. If the gap distance is negative, i.e. the spheres intersect, then we stop and report that the segment is collision-free, otherwise we compute a midpoint at the middle of the gap, $d_m = g/2 + r_s$, and $\q=(1-d/d_m) \qStart + (d/d_m) \qGoal$. Then we continue the procedure recursively by doing the same for the gap to the left and right of the new point. If we detect a negative signed distance at any point, i.e. we are in collision, then we stop immediately. Once the segment has been covered by a set of spheres, then we stop and report that it is collision-free.
\\\\
We benchmark our approach with a naive straight line collision detection procedure where we iterate sequentially over an equally spaced discretized line and immediately stop if collision is detected. We test the capabilities on the test obstacles. For each obstacle we sample 64 configuration pairs uniformly in $\C$. For the naive approach, we discretize the line with a distance of $.1$ rad. In terms of mean computation time, our approach takes 1 ms compared to 100 ms for the naive approach, a 100 time speed up. We stress that this is a crude comparison and other collision detection methods might lower the gap or change the outcome, but it does highlight the usefulness with our approach.
%\begin{table}
\begin{wraptable}{r}{5.5cm}
\centering
\caption{Statistics over cases were both planners were successful.}
\label{tab:static:results}
\begin{tabular}{l cc c cc}
    & \multicolumn{2}{c}{Path length [rad]} & & \multicolumn{2}{c}{Planning time [ms]} \\
     					& mean & max 	& 	& mean & max  	\\ 
    \midrule
    PBRM 			& 7.08  & 15.91 & &	3 & 9 \\
    PRM 			& 7.37  & 18.00 & & 171 & 534 \\
	PRM+S.C 			& 5.86 & 13.73 	& & 433 & 951 \\
    \bottomrule
\end{tabular}
\end{wraptable}
%\end{table}

\fi



