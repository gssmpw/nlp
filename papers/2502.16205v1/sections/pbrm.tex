\documentclass[../main.tex]{subfiles}
%\graphicspath{{\subfix{../images}}}
\makeatletter
\def\input@path{{../images/}}
\makeatother
\begin{document}
\begin{figure}
\centering
\scalebox{.675}{\input{apa.tex}}
\vspace{-20pt}
\caption["Short" caption without tikz code]{\textbf{All}: \tikz\draw [yellow25525520,fill=yellow25525520] (0,0) rectangle (1.5ex,1.5ex); and \tikz\draw [darkmagenta12630156,fill=darkmagenta12630156] (0,0) rectangle (1.5ex,1.5ex); represents $\Cf$ and $\Co$, respectively. \textbf{Left:} Illustrates the offline construction of the roadmap in a static setting. We try to distribute $\NrVerts$ large spheres. Spheres already distributed (\tikz\draw[draw=dodgerblue,fill=dodgerblue,opacity=0.5] (0,0) circle (0.75ex);). We grow a sampled sphere by a line search and accept it if the resulting center is not covered (\tikz\draw[draw=green,fill=green,opacity=0.5] (0,0) circle (0.75ex);) else rejecte it (\tikz\draw[draw=red,fill=red,opacity=0.5] (0,0) circle (0.75ex);).  \textbf{Middle:} The online stage in a static setting, the green sequence of spheres make up a convex corridor which can be used in a convex program to produce a smooth trajectory connecting the query points (\tikz\draw [line width=1mm, red] (0,0) -- (1.5ex,0);). \textbf{Right}: Shows a dynamic scenario. At the offline stage, we  add $\NrVertsExtra$ extra spheres which are distributed freely (\tikz\draw[draw=green,fill=green,opacity=0.5] (0,0) circle (0.75ex);). Online when the obstacle region changes (\tikz\draw [darkmagenta12630156,fill=darkmagenta12630156, opacity=0.7, postaction={pattern=north east lines, fill opacity=0.7}] (0,0) rectangle (1.5ex,1.5ex);) then the graph is adapted by first recomputing radii and then rewiring. The extra spheres help to keep the graph connected.}
\label{fig:pbrm}
\end{figure}
\section{Probabilistic Bubble Roadmap (PBRM)}
The following section presents the Probabilistic Bubble Roadmap (PBRM), which is an improved PRM. Like PRM, it is based on a roadmap that is reused to answer multiple queries. The roadmap is represented by an undirected graph, $\Graph=(\V, \E)$, consisting of vertices, $\V \in \C \times \R_+$, and edges, $\E \in \V^2$. Compared to the PRM though, each vertex in our graph covers a collision-free region in the form of a sphere. Thus, a vertex, $\vert=(\q, r)$, is formed by a sphere center, $\q \in \Cf$, and a radius, $r \in \R_+$. The radius of the sphere is computed from an SCDF, which we assume to be given and that is once differentiable. Here, we stress that it can be any SCDF, not just the neural SCDF we presented in Section \ref{sec:NSCDF}. Like PRM, the PBRM consists of two stages, an offline stage where the roadmap is constructed and an online stage where we solve multiple queries. Since the roadmap is reused during the online stage, it has to be rewired if new obstacles are introduced. Usually, this can not be done in real-time for PRM, which therefore is restricted to static settings. Our choice of representation however allows us to rapidly rewire the graph in the presence of new obstacles, and can therefore also be used in dynamic settings. Let us now explain how to construct and use the roadmap for both scenarios, which is also illustrated in Figure \ref{fig:pbrm}.
\subsection{Static environments}
%\subsubsection{Offline phase}
The main goal of the roadmap construction is to distribute $\NrVerts$ spheres in $\Cf$ that are as large as possible and cover as much space as possible, which we illustrate in the left part of Figure \ref{fig:pbrm}. This is realised by sampling a batch of $\NrSamples$ collision-free spheres, and order them in a descending order w.r.t their radii. For each sample, we first grow the radius by running a line search, where we greedily step in the gradient direction until the radius does not grow anymore. Then, we check if the resulting sphere center is not yet covered by any sphere in the vertex set. If so, we add it to the vertices, otherwise we continue. Once we have distributed $\NrVerts$ spheres, we compute the edges by adding an edge between any pair of spheres that intersect. Before ending, we connect the components of the graph. The resulting graph is illustrated in the middle part of Figure \ref{fig:pbrm}. Once we have a graph, we can estimate the coverage of the free space by sampling a set of collision-free configurations, compute their corresponding spheres, and calculate the fraction of spheres which intersect with our graph. This gives an estimate of how well we have covered the free region and gives us feedback in the process of creating the roadmap.
\\\\
Once the graph is compiled, we can solve for arbitrary queries, i.e. start and goal pairs, $\qStart$ and $\qGoal$, which is shown in the middle part of Figure \ref{fig:pbrm}. For each query, the first step is to connect the points to the graph. We repeat the following procedure for both points. First, we compute the radius for the point and check which spheres in the graph they intersect with. If there is any intersection, then we add the edges to the graph, otherwise we find at most $\NrNeighConnect$ vertices which can be connected to the point by a collision-free straight line. For each line, we compute a sequence of overlapping spheres that cover it and add the vertices and edges to the graph. If no connection could be done, then we report back that no path could be produced. After connecting the query point to the graph, we solve for the shortest path in the graph by running A$^\star$ with the smallest distance to the goal as a heuristic function. If a path is found, we are given a sequence of $\NrBz$, intersecting spheres, $((\q_1, r_1), \hdots, (\q_{\NrBz}, r_{\NrBz}))$, that connects the query points with each other and can be used in a convex optimization program to compute a smooth trajectory, optimize for clearance etc. Before accepting new queries, we remove all added edges and vertices from the graph.
\subsection{Dynamic environments}
\label{sec:pbrm:dyn}
We only need to add some minor steps in order for the roadmap to support moving obstacles. The offline roadmap construction is the same as in the static scenario but we add an additional $\NrVertsExtra$ uniformly sampled collision-free vertices to the graph before the edges are created. These possibly redundant extra vertices are added to increase the chance of keeping the graph connected when we adapt it to any changes of the obstacle region, as shown in the right part of Figure \ref{fig:pbrm}. An additional step in the offline stage is that we attach the goal configuration, $\qGoal$, to the graph, which is done since in dynamic settings, we assume that the planning is repeated with the same goal configuration but with different start configurations each time step.
\\\\
Once the goal configuration is connected, the online stage can start. The first step is to observe the new obstacles and compute the new radii for all vertices. We disregard the vertices which are in collision, i.e. have negative radii. Then, we recompute the edges by simply checking which spheres intersect. Next, we connect the start point $\qStart$ to the rewired graph and compute a shortest path connecting the query points, which we  return in the form of a convex corridor if it exists. Otherwise, we return that none could be found.
\end{document}
\iffalse
Once the goal configuration is connected, the online stage can start, which is presented in Algorithm~\ref{alg:pbrm:dynamic}. The first step is to observe the new obstacles, then we rewire the graph by only considering vertices that are collision-free, line~\ref{alg:pbrm:dynamic:verts} and edges where the spheres still overlap, line~\ref{alg:pbrm:dynamic:edges}. Next, we add $\qStart$ to the rewired graph, line~\ref{alg:pbrm:dynamic:add}, and compute a path connecting the query points, line~\ref{alg:pbrm:dynamic:spp}, or report that a path does not exists if no path was found.
\begin{algorithm2e}
\KwIn{$\Graph$, $\funcSD$, $\qStart$, $\qGoal$}
\KwOut{$\centers$}
\DontPrintSemicolon
\SetAlgoLined
\SetArgSty{upshape}
$\Odyn \gets$ observe new obstacles \;
$\Vrw \gets \{(\q_i, r_i) \in \V \: | \: \funcSD(\q_i, \: \Odyn) > 0 \}$ \label{alg:pbrm:dynamic:verts} \;
$\Erw \gets \{((\q_i, r_i), (\q_j, r_j)) \in \tilde{\V}^2 \: | \: ||\q_i - \q_j||_2 < \min(\funcSD(\q_i, \: \Odyn), \: r_i)  +  \min(\funcSD(\q_j, \: \Odyn), \: r_j) \}$ \label{alg:pbrm:dynamic:edges} \;
$\GraphRw \gets (\Vrw, \Erw) $ \label{alg:pbrm:dynamic:graph} \;
$\GraphRw \gets$  connect $\qStart$ \label{alg:pbrm:dynamic:add}  \;
$\centers \gets $ find shortest path in $\Graph$ from $\qStart$ to $\qGoal$ by A$^{\star}$ \label{alg:pbrm:dynamic:spp} \;
\caption{Presents how to adapt the graph to changes in the free region}
\label{alg:pbrm:dynamic}
\end{algorithm2e}
\begin{algorithm2e}
\KwIn{$\funcSD$, $\NrVerts$, $\NrSamples$, $\O$}
\KwOut{$\Graph$}
\DontPrintSemicolon
\SetAlgoLined
\SetArgSty{upshape}
$\V, \:  \E \gets  \emptyset, \: \emptyset $ \;
\While{$|\V| \le \NrVerts $}{
	$\Q \gets $ sample $\NrSamples$ collision-free configurations \label{alg:pbrm:static:sample} \;
	$\r \gets \funcSD(\Q, \: \O)$ \label{alg:pbrm:static:radii_comp} \;
	$\Q, \textbf{r} \gets $ sort in descending order w.r.t radius \label{alg:pbrm:static:sort} \;
	\For{$i = 1, \hdots \NrSamples$}{ \label{alg:pbrm:static:loop_samples}
		$\q_i, r_i \gets \Q_i, \r_i$ \;
		$\text{accept} \gets \q_i \text{ is not within any sphere in } \V $ \label{alg:pbrm:static:check} \; 
		\If{$\text{accept}$}{
			\If{$r_i < r_{\text{thr}}$}{
				$\q_i, r_i \gets $ grow sphere by greedy line search, in direction of $\nabla_{\q_i} \funcSD(\q, \O) $ \label{alg:pbrm:static:gradient_acc} \;
				$\text{accept} \gets \q_i \text{ is not within any sphere in } \V $ \label{alg:pbrm:static:check2} \;
			}
			\If{$\text{accept}$}{
				$\V \gets \V \cup \{ (\q_i, r_i) \}$ \label{alg:pbrm:static:add} \;
			}
		}
		\If{$|\V| \ge \NrVerts $}{
			\textbf{break} \;
		}
	}
}
$\E \gets \{((\q_i, r_i), (\q_j, r_j)) \in \V^2 \: | \: ||\q_i - \q_j||_2 < r_i  +  r_j\}$ \label{alg:pbrm:static:edges} \;
$\Graph \gets (\V, \E) $ \;
connect components in $\Graph$ \label{alg:pbrm:static:components} \;
\caption{Offline construction of the roadmap. The idea is to distribute $\NrVerts$ spheres which are as large as possible and cover as much space of the free-region.}
\label{alg:pbrm:static}
\end{algorithm2e}
The idea is to distribute $\NrVerts$ spheres in $\Cf$ that are as large as possible and cover as much of the free space. We do this by sampling a batch of $\NrSamples$ collision-free configurations, line~\ref{alg:pbrm:static:sample}, and order them in a descending order w.r.t their radii, line~\ref{alg:pbrm:static:sort}. We iterate over all the samples, line~\ref{alg:pbrm:static:loop_samples}, and only accept the samples whose centers are not covered by any sphere in the vertex set. If a sample passes this requirement, then we check if its radius is smaller than some threshold, $r_{\text{thr}}$. If so, then we grow the radius by running a line search, where we greedily grow the radius along the gradient direction. Once the sphere has been grown, we re-check if it still is not covered by the spheres in the vertex set, line~\ref{alg:pbrm:static:check2}, and add it if that is the case, line \ref{alg:pbrm:static:add}. Once we have distributed $\NrVerts$ spheres, we compute the edges by adding an edge between any pair of spheres that intersect, line \ref{alg:pbrm:static:edges}. Before ending, we connect the components of the graph, line~\ref{alg:pbrm:static:components}.
\\\\
\fi