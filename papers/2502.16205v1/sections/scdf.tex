\documentclass[../main.tex]{subfiles}
%\graphicspath{{\subfix{../images}}}
%\makeatletter
%\def\input@path{{../images}}
%\makeatother
\begin{document}
\section{Neural signed configuration distance function}
\label{sec:NSCDF}
We define a configuration distance function, $\funcD: \C \times \W \mapsto \R_+ $, as
\begin{equation}
\funcD(\q, \O_i) = \min_{\qc \in \partial\C\O_i} \: ||\q - \qc||.
\end{equation}
It takes a configuration, $\q$, and a world space representation of the obstacle, $\O_i$, as input and returns the smallest distance to the boundary of the obstacle region in the configuration space, $\partial\C\O_i$. The distance function gives us no information whether we are in collision or not, which however the signed configuration distance function, $\funcSD: \C \times \W \mapsto: \R $, does. It is defined as 
\begin{equation}
\funcSD(\q, \: \O_i) = 
\begin{cases}
-\funcD(\q, \: \O_i) & \text{if } \q \in \C\O_i, \\
\hphantom{-} \funcD(\q, \: \O_i) & \text{otherwise.}
\end{cases}
\end{equation}
Thus, if $\q$ is in the interior of $\C\O_i$, i.e. in collision, then the distance is negative, otherwise it is positive, i.e. collision-free. Now, if the signed distance is positive then a sphere placed at the queried point with radius equal to the distance covers a collision-free region w.r.t $\O_i$. Furthermore, if the SCDF is a smooth function, then we can grow the sphere, i.e. collision-free region, by stepping along the gradient, $\nabla_{\q} \funcSD(\q, \O_i)$, since it points in the direction of increasing distance.
\\\\
From the problem description, we realise that our problem scenario involves multiple obstacles, $\O=\bigcup_{i=1}^{\NrObst} \O_i$, which in general can result in a more complicated geometry. A naive approach would be to form an SCDF for this resulting shape which seems to be a harder problem than forming a SCDF for the individual shapes. Fortunately, the SCDF allows us to combine multiple SCDF values by taking the smallest distance, that is 
\begin{equation}
\label{eq:scdf:min}
\funcSD(\q, \O) =  \text{min}(\funcSD(\q, \O_1), \: \funcSD(\q, \O_2), \: \hdots, \: \funcSD(\q, \O_{\NrObst})).
\end{equation}
Thus, the SCDF naturally supports multiple obstacles which makes it scalable. However, despite the attractive features of the SCDF, the non-linear mapping of a world-space obstacle to its corresponding obstacle boundary in the configuration space is far from clear how to form analytically. 
\\\\
Instead of trying to express the SCDF analytically, we approach this problem by approximating the SCDF with a deep neural network, $\funcSD \approx \funcNSD$, which we refer to as a neural SCDF. Since we are using a deep neural network to represent the SCDF, we need to be able to represent a general obstacle, $\O_i$, such that it can be processed through a neural network. We do this by restricting the neural SCDF to support geometrical shapes that come from the same family of geometrical shapes, e.g. family of spheres, and that can be parameterized by a vector $\geom \in \geomClass \subset \R^G $, where $\geomClass$ is the parameter space. Thus, our neural network is defined as the mapping $\funcNSD(\q, \: \geom) : \C \times \geomClass \mapsto \R $. An arbitrary obstacle shape can then be represented as a union of possibly simpler shapes, e.g. union of spheres \citep{hubbard_spheres}, and the resulting SCDF is then computed by \eqref{eq:scdf:min}. Furthermore, the flexibility which the min-property brings us, makes it possible for us to learn distinct different neural SCDFs for different geometrical shapes, e.g. spheres and axis aligned boxes, and then again simply combine them with \eqref{eq:scdf:min}.
\\\\
Next, we discuss how we generate a labeled data set to train the network. First, we assume that the configuration space effectively can be expressed by 3 DOF. At first sight this might seem too limiting to be practically useful. However, there are many robot types and applications for which this assumption is reasonable. One example of a robot type is the SCARA robot, which has 4 DOF \citep{rob_mod_plan_cont}. If no tool is used, then the planning reduces to 3 DOF. If however a tool is needed in the planning, then by approximating the tool by a sphere, the problem again reduces to 3 DOF. The same idea applies to anthropomorphic arms \citep{rob_mod_plan_cont}, where the wrist axis and the tool are approximated by a sphere. Furthermore, in some applications, e.g. palletizing, it is common to keep a fixed orientation of the wrist, e.g. top-down. By doing so, the path planning problem again reduces to 3 DOF. 
\\\\
Having addressed our assumptions, we continue with the details of our data generation process. We sample $\NrSampledObstacles$ parameter vectors, $\geom_i$, constrained to be positioned in the workspace of the robot. The configuration space is discretized into a coarse grid $\Th \in R^{\NrDisc \times \NrDisc \times \NrDisc}$, with $\NrDisc$ grid points in each dimension. We compute the collision status for each configuration. For each configuration which is in collision and has neighboring collision-free configurations, we find all boundary points between it and all its collision-free neighbors by bisection. All collision and boundary configurations are saved, from which we compute a mesh with the marching cubes algorithm \citep{marchingcubes}. To form a labeled data set, we sample $\NrSampledDataPoints$ configurations uniformly from $\C$, compute the smallest distance, $d_i$, to the mesh and multiply with its collision-status, $s_i \in \{-1, 1 \}$. The process results in a labeled data set $\DS=\{(\q_{i,j}, \geom_i), s_{i,j} d_{i,j})\}_{i=1, j=1}^{\NrSampledObstacles, \NrSampledDataPoints}$, which we use to train a neural network by minimizing the mean-squared error loss, $\text{MSE} = \sum_{i,j}^{N, M}(\funcNSD(\q_{i, j}, \geom_{i})-  s_{i,j} d_{i,j})^2 / N M$.
\end{document}
