\section{Algorithm}
\label{sec:algo}

This section describes the algorithm and its related concepts. Section~\ref{ssec:weightfunc} formally defines the weight function for edges and associated structural results. Section~\ref{ssec:oracle-algo} describes the algorithm assuming access to an idealized oracle that can decide an edge to be heavy or light (based on the the edge having many or less triangles incident on it). Section~\ref{ssec:oracle-implement} describes how to actually implement this oracle within the problem setup. Section~\ref{ssec:final-algo} puts everything together to develop the final algorithm.

\remove{This section describes the algorithm starting from the setting of an idealized oracle that can decide an edge to be heavy or light (based on the edge having many or less triangles incident on it) based on an idealized weight function over the edges. This weight function is developed in Section~\ref{ssec:weightfunc} starting from the notion of heavy and light edges. Section~\ref{ssec:oracle-algo} discusses about how the idealized oracle can develop an estimate of the weight function. The implementation of the idealized oracle is discussed in Section~\ref{ssec:oracle-implement}. Section~\ref{ssec:final-algo} puts everything together to develop the final algorithm.}






%Section 1 - Weight Function








%-----------------------------Weight Function-----------------------------








\subsection{Weight Function}
\label{ssec:weightfunc}
In this section, we formalize the ideas of heavy and light edges and weight function for the edges. 
\paragraph*{Heavy and light edges and triangles.} First, we define heavy and light edges and correspondingly, heavy and light triangles.
\begin{definition}[$\threshold$-heavy and $\threshold$-light edges]\label{Definition: Heavy and Light Edges}
    An edge $\edge \in \edgeset$ is defined to be a $\threshold$-heavy (resp. $\threshold$-light) edge if it participates in more than $\threshold$ (resp. $\leq \threshold$) triangles.
\end{definition}
% \begin{definition}[$\threshold$-Light Edges]\label{Definition: Light Edges}
%     An edge $\edge \in \edgeset$ is defined to be a heavy edge if it participates in $\leq \threshold$ triangles.
% \end{definition}
% \todo{The constant is to be fixed later.}
%We define heavy and light triangles associated with the idea of heavy and light edges. 
\begin{definition}[$\threshold$-heavy and $\threshold$-light triangles]\label{Definition: Heavy and Light Triangles}
    A triangle $\triangle \in \triangleset$ is called a $\threshold$-heavy triangle if all its three edges are $\threshold$-heavy edges. A triangle that is not $\threshold$-heavy is a $\threshold$-light triangle.
\end{definition}

% \begin{definition}[$\threshold$-Light Triangles]\label{Definition: Light Triangles}
%     A triangle $\triangle \in \triangleset$ is called a light triangles if it contains at least one $\threshold$-light edge.
% \end{definition}
% \gopi{May be we define all of the above four in just one definition?}

We denote by $\lighttriangles{\threshold}$ and $\heavytriangles{\threshold}$ 
% \gopi{Shall we include $\tau$ in these notations?} 
the number of $\threshold$-light and $\threshold$-heavy triangles in the graph $\graph$, respectively. 
The following lemma bounds the number of $\threshold$-heavy triangles in a graph.
\begin{lemma}[Upper Bound on $\heavytriangles{\threshold}$]\label{Lemma: Upper Bound on Heavy Triangles}
Given a graph $\graph = (\vertexset,\edgeset)$ with $\numtriangle$ triangles, the number of $\threshold$-heavy triangles is at most $\frac{3\numtriangle\arboricity}{\threshold}$  .
    \begin{proof}
        Note that the graph $\graph = (\vertexset,\edgeset)$ has $\numtriangle$ triangles containing at most $3\numtriangle$ edges. By Definition~\ref{Definition: Heavy and Light Triangles}, $\threshold$-heavy triangles have all three of their edges to be $\threshold$-heavy edges, each participating in greater than or equal to $\threshold$ triangles. Hence, the number of $\threshold$-heavy edges in $\graph$ is at most $\frac{3\numtriangle}{\threshold}$ .

        Now consider the subgraph $H = (V_H, E_H)$ of $\graph$ induced by the $\threshold$-heavy edges in $\graph$. We know, $\edgeset_H \leq \frac{3\numtriangle}{\threshold}$. Also, $\arboricitygraph{H} \leq \arboricitygraph{\graph} = \arboricity$ (see Section~\ref{ssec:arbor-prop}). Hence, by Lemma~\ref{lemma: arboricity triangle bound}, we know that $H$ contains at most $\frac{3\numtriangle\arboricity}{\threshold}$ triangles.
    \end{proof}
\end{lemma}
The following corollary follows from Lemma~\ref{Lemma: Upper Bound on Heavy Triangles} and the fact that $\numtriangle = \lighttriangles{\threshold} + \heavytriangles{\threshold}$. 
\begin{corollary}[Lower Bound on $\lighttriangles{\threshold}$]\label{Corollary: Lower Bound on Light Triangles}
    Given a graph $\graph = (\vertexset,\edgeset)$, there are at least $(1-\frac{3\arboricity}{\threshold}) \numtriangle$  $\threshold$-light triangles.
\end{corollary}

\paragraph*{Weight function for the edges.}
Now, we define a weight function for the edges. As a triangle is incident to multiple edges, the objective of a weight function is to charge each of the light triangles to exactly one of its participating light edges. To ensure this, we do not charge any triangle to the heavy edges. Each light edge $\edge$ can be charged by at most $\numtriangle_\edge$ triangles, i.e., all the triangles $\edge$ participates in. To avoid over-counting, we ensure that the sum of the weight functions over all edges is equal to the number of light triangles, $\lighttriangles{\threshold}$. $\fbrac{\triangle,\edge}$ denotes that the triangle $\triangle$ is charged through the edge $\edge$.

%qa\debarshi{ \st{Can we directly define the weight function through the charging definition and state the current definition as properties?}}

\begin{definition}[Triangle weight function $(\weightfunc)$]\label{Definition: Weight Function}
    We define a function $\func{\weightfunc}{\edgeset}{\Nat}$ to be a triangle weight function if it satisfies the following two conditions:
\[
\begin{array}{llll}
\mbox{Condition (1)}: & \weightfunc(\edge) & \leq & 
\left\{
\begin{array}{ll}
\numtriangle_\edge & \text{if $\edge$ is a light edge}\\
0 &\text{if $\edge$ is a heavy edge} 
\end{array} 
\right. 
\\
\mbox{Condition (2)}: & \sum\limits_{\edge \in \edgeset} \weightfunc(\edge) & = & \lighttriangles{\threshold} 
\end{array}
\]


\remove{   
    \begin{enumerate}
        % \item $\weightfunc(\edge) \leq \min{\{\numtriangle_\edge,\frac{3\arboricity}{\approxerror}\}}$
        \item $\weightfunc(\edge) \leq \begin{dcases}
            \numtriangle_\edge &\text{if $\edge$ is a light edge}\\
            0 &\text{if $\edge$ is a heavy edge}
        \end{dcases}$
        \complain{\item $\sum_{\edge \in \edgeset} \weightfunc(\edge) = \numtriangle_{light}$ (Debarshi: should it not be \lighttriangles{\threshold}?)}
    \end{enumerate}
}
\end{definition}
%\gopi{\st{May be we intuitively explain what is triangle weight function first? Then the first sentence will be in proper context.}}

Observe that there are multiple such weight functions (e.g., a triangle with 3 light edges can be assigned to any one of these 3 edges). Henceforth, we denote the set consisting of valid triangle weight functions by $\weightfamily$. We now state a property of valid weight functions. Note that this property is true for any $\weightfunc \in \weightfamily$.

%\gopi{May be we intuitively explain what is triangle weight function first}
\begin{lemma}\label{Lemma: Weight Function Expectation}
    % For all valid triangle weight function $\weightfunc \in \weightfamily$, an edge $\edge$ chosen uniformly at random from $\edgeset$ satisfies $\Exp_{e \sim \uniform(\edgeset)} \weightfunc(\edge) = \frac{\lighttriangles{\threshold}}{\edgecount}$.
    Consider any triangle weight function $\weightfunc \in \weightfamily$. If we select an edge $e \in E$ uniformly at random, then the expected value of $w(e)$ is $\frac{\lighttriangles{\threshold}}{\edgecount}$, i.e., $\Exp_{e \sim \uniform(\edgeset)} \weightfunc(\edge) = \frac{\lighttriangles{\threshold}}{\edgecount}$.
    % \gopi{Shall we write as follows?: Consider any triangle weight function $\weightfunc \in \weightfamily$. If we select an edge $e \in E$ uniformly at random, then the expected value of $w(e)$ is $\frac{\lighttriangles{\threshold}}{\edgecount}$, i.e., $\Exp_{e \sim \uniform(\edgeset)} \weightfunc(\edge) = \frac{\lighttriangles{\threshold}}{\edgecount}$.}

    \begin{proof}
        Given that the edges have been chosen uniformly at random and the condition of the triangle weight function, we have:
        $$\Exp_{\edge \sim \uniform(\edgeset)} \weightfunc(\edge) ~~~~~ = ~~~~~ \sum_{\edge \in \uniform(\edgeset)} \frac{1}{\edgecount} \weightfunc(\edge)  ~~~~~ = ~~~~~ \frac{1}{\edgecount} \sum_{\edge \in \edgeset} \weightfunc(\edge) ~~~~~ = ~~~~~ \frac{\lighttriangles{\threshold}}{\edgecount}$$
    \remove{
        \begin{align*}
            \Exp_{\edge \sim \uniform(\edgeset)} \weightfunc(\edge) &= \sum_{\edge \in \uniform(\edgeset)} \frac{1}{\edgecount} \weightfunc(\edge)\\
            &= \frac{1}{\edgecount} \sum_{\edge \in \edgeset} \weightfunc(\edge)\\
            &= \frac{\lighttriangles{\threshold}}{\edgecount} &\text{By Definition of Triangle Weight Function}
        \end{align*}
        }
    \end{proof}
\end{lemma}

% \begin{lemma}\label{Lemma: Weight Function Variance}
%     For all valid triangle weight function $\weightfunc \in \weightfamily$, an edge $\edge$ chosen uniformly at random from $\edgeset$ satisfies $\Var[\weightfunc(\edge)] \leq \frac{3\arboricity}{\approxerror} \Exp[\weightfunc(\edge)]$.

%     \begin{proof}
%         \begin{align*}
%             \Var[\weightfunc(\edge)] &\leq {\Exp}^2[\weightfunc(\edge)]\\
%                          &\leq \frac{3\arboricity}{\approxerror}\Exp[\weightfunc(\edge)] &\text{As $\weightfunc(\edge) \leq \frac{3\arboricity}{\approxerror}$, by definition~\ref{Definition: Weight Function}}
%         \end{align*}    
%     \end{proof}
% \end{lemma}








%-----------------------------Oracle Based Algorithm-----------------------------








\subsection{Oracle Based Algorithm}
\label{ssec:oracle-algo}
Our algorithm, due to its usage of the \emph{triangle weight function}, requires knowledge of whether an edge is \emph{heavy} or \emph{light}. The problem of deciding whether an edge is heavy is non-trivial as it directly relates to number of triangles the edge participates in. In this section, we assume black-box access to an oracle $\exactheavyoracle{}$ that helps us to determine whether an edge is heavy or not. 
\begin{align*}
    \exactheavyoracle(\edge,\arboricity,\approxerror) &=\begin{dcases}
        1 &\text{if edge $e$ is a $\frac{\upperthreshold\arboricity}{\approxerror}$-heavy edge, i.e., $\threshold = \frac{\upperthreshold\arboricity}{\approxerror}$}\\
        0 &\text{if edge $e$ is a $\frac{\lowerthreshold\arboricity}{\approxerror}$-light edge, i.e., $\threshold = \frac{\lowerthreshold\arboricity}{\approxerror}$}
    \end{dcases}
\end{align*}
% \gopi{Is there any significance of $\tau$ in $k_\tau$ or we can just say $k$?}
Here $h$ and $l$ $(h > l)$ are constants to be determined later. \remove{In this section, we develop our algorithm assuming black-box access to this oracle.} We will discuss an efficient 
implementation of this oracle later. 
\iffalse{
The algorithm that we propose in this section can be thought of as estimating a weight function $\weightfunc$ as $\empweightfunc$. If the estimate $\empweightfunc$ is an unbiased estimate of the true $\weightfunc$, 
}\fi

Let us first consider the case where we are given an oracle that given an edge $\edge$, returns the exact value of a weight function, $\weightfunc(\edge)$. Given, we can sample edges uniformly at random through the \randedgeq{} query, we can compute $\Exp_{\edge \sim \uniform(\edgeset)}\tbrac{\weightfunc(\edge)} = \lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}$ using this oracle on the sampled edges. However, no such oracle exist in our model. Hence, we try to simulate one through an empirical estimate of the weight function, $\empweightfunc(\edge)$. Recall the fact that there are many valid weight functions, each being characterized by every light triangle being charged to a unique edge. Our algorithm will work if the empirical weight function $\empweightfunc$ estimates any one of these weight functions. We achieve this by ensuring that a triangle is not sampled through more than one edge (see Line~\ref{Line: Remove Duplicate Triangles} of Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate}). Thus, the assignments that we consider can be extended to a valid weight function $\weightfunc$, and our algorithm can be thought of as estimating this weight function through $\empweightfunc$. We develop our initial algorithm ( Algorithm \ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate}) assuming access to an estimate of $\numtriangle$ as $\esttriangle$ satisfying the following assumption:
\begin{assumption}\label{Assumption: Triangle 2 Factor Estimate}
$\esttriangle \leq 2\numtriangle$.
\end{assumption}
In Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate}, we assume that we know $m$ exactly. In fact, our algorithm and analysis work even if we have a constant factor approximation of $m$. This can be achieved by using $O(1)$  queries \cite{assadi2018simple}.

\begin{algorithm}[ht!]
    \caption{Triangle Counting Algorithm - with Oracle Access, and $\esttriangle$}\label{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate}
    \begin{algorithmic}[1]
        \Require \degreeq{}, \neighbourq{}, \edgeexistsq{}, and \randedgeq{} query access to a graph $\graph$. Parameters $\esttriangle, \arboricity$, $\approxerror$, $\edgecount$ and oracle access to \exactheavyoracle{} with threshold constants $\lowerthreshold,\upperthreshold$
        \State $\edgesamplesize \gets 4\constant(1+\upperthreshold)\approxerror^{-3}(\edgecount\arboricity/\esttriangle)\log\vertexcount$ 
        \State $\samplededges \gets \emptyset$ \Comment{$\samplededges$ is the set of random edges sampled. $\size{\samplededges} \leq \edgesamplesize$ growing upto $\edgesamplesize$}
        \State $\sampledtriangles \gets \emptyset$ \Comment{$\sampledtriangles$ is the set of light triangles sampled through the edges in $\samplededges$}
        \For{$i \in [\edgesamplesize]$}
            \State $\edge_i \gets \randedgeq{}$
            \State $\samplededges \gets \samplededges \cup \edge_i$
            \State Let $\edge_i = (\vertex_i, x)$ where $\degree{\vertex_i} < \degree{x}$
            \remove{Let $\vertex_i$ be the endpoint of $\edge_i$ with smaller degree, and $x$ be the endpoint of $\edge_i$ that is not $\vertex_i$.} \Comment{Requires two \degreeq{} queries}
            \If{($\exactheavyoracle(\edge_i,\arboricity,\approxerror) = 0$)} \Comment{$\edge_i$ is a $\frac{\lowerthreshold\arboricity}{\approxerror}$-light edge} 
            \label{line: heavyoracle call}
                \State $\querycount_{\edge_i} \gets 0$ \Comment{$\querycount_\edge$ denotes the number of queries for each edge $\edge$}
                %\complain{
                \If{$\degree{\vertex_i} \leq \arboricity$}
                    \State set $\querycount_{\edge_i} \gets 1$ with probability $\frac{\degree{\vertex_i}}{\arboricity}$
                \Else 
                    \State set $\querycount_{\edge_i} \gets \ceil{\frac{\degree{\vertex_i}}{\arboricity}}$
                \EndIf
                %}
                %\State If $\degree{\vertex_i} \leq \arboricity$, set $\querycount_{\edge_i} \gets 1$ with probability $\frac{\degree{\vertex_i}}{\arboricity}$. Otherwise, set $\querycount_{\edge_i} \gets \ceil{\frac{\degree{\vertex_i}}{\arboricity}}$
            \For{$j \in [\querycount_{\edge_i}]$}
                \State Choose $k \gets \uniform\fbrac{\sbrac{1,2,...,\degree{\vertex_i}}}$
                \State $\altvertex \gets \neighbourq{\fbrac{\vertex_i,k}}$
                    % \State If $\edgeexistsq{\fbrac{\altvertex,x}} = 1$, $\sampledtriangles \gets \sampledtriangles \cup (\altvertex,\edge_i)$ 
                    %\State If($\edgeexistsq{\fbrac{\altvertex,x}} = 1$ and $\triangle = (\altvertex,\edge_i)$ is not in $\samplededges$ through another edge $\edge'$) $\sampledtriangles \gets \sampledtriangles \cup \triangle$ \label{Line: Remove Duplicate Triangles} \Comment{A triangle $\triangle$ may occur in $\sampledtriangles$ multiple times, but each time it will be through same edge $\edge$}
                \If{($\edgeexistsq{\fbrac{\altvertex,x}} = 1$ and $\triangle = (\altvertex,\edge_i)$ is not in $\samplededges$ through another edge $\edge'$)}
                \label{Line: Remove Duplicate Triangles} 
                    \State $\sampledtriangles \gets \sampledtriangles \cup \triangle$ \\
                    \Comment{A triangle $\triangle$ may occur in $\sampledtriangles$ multiple times, but each time it will be through same edge $\edge$}
                    %\iffalse{\gopi{May be we are allowing repetition of triangles encountered while processing a single (random) edge?}\debarshi{Fixed?}}
                    %\fi
                \EndIf
            \EndFor
            \Else
                \State $\querycount_{\edge_i} \gets 0$
            \EndIf
        \EndFor
        % \State If a triangle $\triangle$ is present in $\sampledtriangles$ through different edges, choose one edge arbitrarily, and remove the triangle through the other edges.
\iffalse{\For{$\edge \in \samplededges$}
            \If{$\querycount_\edge > 0$}
                \State $\empweightfunc(\edge) = \frac{1}{\querycount_{\edge}} \sum_{(\triangle,\edge) \in \sampledtriangles} \max\fbrac{\arboricity,\degree{\edge}}$
            \Else
                \State $\empweightfunc\fbrac{\edge} = 0$
            \EndIf
            % \State $Y_\edge = \frac{1}{\querycount_{\edge}} \empweightfunc(\edge)$
        \EndFor
        % \State Choose a consistent weight function $\weightfunc$. Compute the empirical weight function as $\empweightfunc(e) = \weightfunc_\samplededges(e)$
        \State \Return $\emptriangle = \frac{\edgecount}{\edgesamplesize}\sum_{\edge \in \samplededges} \empweightfunc(\edge)$}
\fi 
        \For{$i \in [\edgesamplesize]$}
            \If{$\querycount_{\edge_i} > 0$}
                \State $\empweightfunc(\edge_i) = \frac{1}{\querycount_{\edge_i}} \sum_{(\triangle,\edge_i) \in \sampledtriangles} \max\fbrac{\arboricity,\degree{\edge_i}}$
            \Else
                \State $\empweightfunc\fbrac{\edge_i} = 0$
            \EndIf
            % \State $Y_\edge = \frac{1}{\querycount_{\edge}} \empweightfunc(\edge)$
        \EndFor
        % \State Choose a consistent weight function $\weightfunc$. Compute the empirical weight function as $\empweightfunc(e) = \weightfunc_\samplededges(e)$
        \State \Return $\emptriangle = \frac{\edgecount}{\edgesamplesize}\sum_{i \in \edgesamplesize} \empweightfunc(\edge_i)$
    \end{algorithmic}
\end{algorithm}
\begin{lemma}\label{lemma: E[Y_I] Weight Func Algo}
    Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} ensures that $\Exp\tbrac{\empweightfunc(\edge_i)} = \lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}/\edgecount $, and $\Exp\tbrac{\emptriangle} = \lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}$.
    \begin{proof}
    Let $\sE_i$ be the event that the edge $\edge$ is chosen in the $i$-th round. We proceed with the proof by considering two different cases: $\degree{\edge} < \arboricity$ and $\degree{\edge} \geq \arboricity$. 
    
    % \medskip
    
    {\bf Case I }($\degree{\edge} < \arboricity$):
    When $\degree{\edge} < \arboricity$, $\querycount_\edge$ is set to $0$ with probability $1 - \degree{\edge}/\arboricity$ and \complain{1} with probability $\degree{\edge}/\arboricity$, and $\empweightfunc(\edge)$ is evaluated through a single query. Thus, \begin{align}
        \Exp[\empweightfunc(\edge_i)|\sE_i] &= \frac{\degree{\edge}}{\arboricity} \sum_{k \in [\weightfunc(\edge)]} \frac{1}{\degree{\edge}} \arboricity + \fbrac{1 - \frac{\degree{\edge}}{\arboricity}}\cdot0 = \weightfunc(\edge)\label{Eq: E[what(e)] low degree edge}
    \end{align}

    % \medskip
     
    {\bf Case II }($\degree{\edge} \geq \arboricity$):
    On the other hand, when $\degree{\edge} \geq \arboricity$, let $Z_j, j \in [\querycount]$ denote the contribution of each of the $\querycount$ queries made for the edge $\edge$ to the weight function estimate. Then, we have:
    \begin{align}
        \Exp[Z_j|\sE_i] &= \sum_{k \in [\weightfunc(\edge)]} \frac{1}{\degree{\edge}} \degree{\edge}= \weightfunc(\edge)\label{Eq: E[Z_j] random edge arboricity}
    \end{align}
    Correspondingly, we have by linearity of expectation and Equation~\ref{Eq: E[Z_j] random edge arboricity}:
    \begin{align}
        \Exp\tbrac{\empweightfunc(\edge_i)|\sE_i} = \frac{1}{\querycount_\edge}\sum_{j \in [\querycount_{\edge}]} \Exp\tbrac{Z_j|\sE_i} = \Exp\tbrac{Z_j|\sE_i} = \weightfunc(\edge)\label{Eq: E[what(e)] high degree edge}
    \end{align}

    Given that we draw each edge $\edge \in \samplededges$ uniformly at random, we now have by Equations~\ref{Eq: E[what(e)] low degree edge},~\ref{Eq: E[what(e)] high degree edge}, and Lemma~\ref{Lemma: Weight Function Expectation}:
    \begin{align*}
        \Exp\tbrac{\empweightfunc(\edge_i)} = \Exp_{\edge \sim \uniform\fbrac{\edgeset}} \weightfunc\fbrac{\edge} = \lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}/\edgecount 
    \end{align*}
    By linearity of expectations, we obtain
    \begin{align*}
        \Exp\tbrac{\emptriangle} = \Exp\tbrac{\frac{\edgecount}{\edgesamplesize}\sum_{i \in \edgesamplesize} \empweightfunc(\edge_i)} = \lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}} 
    \end{align*}

    \end{proof}
\end{lemma}

Note that Lemma~\ref{lemma: E[Y_I] Weight Func Algo} holds irrespective of whether Assumption~\ref{Assumption: Triangle 2 Factor Estimate} is satisfied or not. Next, we turn our attention to the variance of $\empweightfunc(\edge)$.

\begin{lemma}\label{lemma: Var[Y_i] Weight Func Algo}
    Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} ensures that $\Var[\empweightfunc(\edge_i)] \leq \frac{(1+\upperthreshold)\arboricity}{\approxerror} \cdot \Exp_{\edge \sim \uniform\fbrac{\edgeset}}[\weightfunc(\edge)]$.
    \begin{proof}
        Again, we consider two different cases as in the proof of Lemma \ref{lemma: E[Y_I] Weight Func Algo}.  \remove{$\degree{\edge} \geq \arboricity$ and $\degree{\edge} < \arboricity$.}
        
        % \medskip
      
      {\bf Case I }($\degree{\edge} < \arboricity$):
        When $\degree{\edge} < \arboricity$, Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} makes at most $1$ query as $\querycount \leq 1$. As $\empweightfunc(\edge) \leq \arboricity$, we have 
        \begin{align}
            \Var[\empweightfunc(\edge_i)|\sE_i] \leq \Exp[\empweightfunc(\edge_i)^2|\sE_i] \leq \arboricity\Exp\tbrac{\empweightfunc\fbrac{\edge_i}|\sE_i} \label{Eq: Var[Y_i,S, Small Degree Edge] random edge arboricity}
        \end{align}
        
        \remove{
        $$\leq \frac{\upperthreshold\arboricity}{\approxerror}\Exp[\empweightfunc\fbrac{\edge_i}|\sE_i] $$
        \begin{align*}
            \Var[\empweightfunc(\edge_i)] &\leq \Exp[\empweightfunc(\edge_i)^2]\\
                        &\leq \arboricity\Exp\tbrac{\empweightfunc\fbrac{\edge}}&\text{As $\empweightfunc(\edge) \leq \arboricity$}\\
                        &\leq \frac{\upperthreshold\arboricity}{\approxerror}\Exp[\empweightfunc]
                        % &\text{As $\empweightfunc \leq \frac{\upperthreshold\arboricity}{\approxerror}$}
        \end{align*}
        }
        
        {\bf Case II }($\degree{\edge} \geq \arboricity$):
        Now we consider the case $\degree{\edge} \geq \arboricity$ which is more involved as $\querycount \geq 1$. We first estimate the variance of each $Z_j$ individually as defined in Lemma~\ref{lemma: E[Y_I] Weight Func Algo}. We condition on the event that edge $\edge$ is chosen in the $i$-th stage, denoted by $\sE_i$. If $\exactheavyoracle(\edge,\arboricity,\approxerror) = 1$, then $Var[Z_j] = 0, \forall j \in [\querycount]$. Hence, we condition on the event that $\exactheavyoracle(\edge,\arboricity,\approxerror) = 0$ from now on. As $Z_j \leq \degree{\edge}$,
        \begin{align}
             Var[Z_j|\sE_i]  \leq \Exp[Z_j^2|\sE_i] 
                                \leq \degree{\edge_i}\Exp[Z_j|\sE_i] \label{Eq: Var[Z_j]}
        \end{align}
        \remove{
        \begin{align}
            \nonumber Var[Z_j|\sE_i]    &\leq \Exp[Z_j^2|\sE_i]&\\
                                &\leq \degree{\edge}\Exp[Z_j|\sE_i] &\text{$Z_j \leq \degree{\edge}$}\label{Eq: Var[Z_j]}
        \end{align}
        }
        After having bounded the variance of the contribution of each query, we now obtain the variance of the weight estimate of the edge.
        \begin{align}
          \nonumber  \Var[\empweightfunc(\edge_i)|\sE_i]   &=\Var\tbrac{\frac{1}{\querycount_{\edge_i}}\sum_{j \in \querycount_{\edge_i}} Z_j|\sE_i}&\\
          \nonumber                      &=\frac{1}{\querycount_{\edge_i}^2}\sum_{j \in \querycount_{\edge_i}}\Var\left[ Z_j|\sE_i \right]&\text{($Z_j$ are i.i.d. given $\sE_i$)}\\
          \nonumber                      &=\frac{\degree{\edge_i}}{\querycount_{\edge_i}}\sum_{j \in \querycount_{\edge_i}}\frac{1}{\querycount_{\edge_i}}\Exp[ Z_j|\sE_i ]&\text{(by Equation~\ref{Eq: Var[Z_j]} and linearity of expectation)}\\
          &\leq \arboricity \Exp[\empweightfunc(\edge_i)|\sE_i]&\text{ $\left(\mbox{as }  \querycount_{\edge_i} = \ceil{\frac{\degree{\edge}}{\arboricity}}\right)$}\label{Eq: Var[Y_i,S,High Degree Edge] random edge arboricity}
\end{align}

        Now, we remove the conditioning on $\sE_i$ using law of total variance:
        \begin{align*}
            \Var[\empweightfunc(\edge_i)] &= \Exp_{\edge_i}[\Var[\empweightfunc(\edge_i)|\sE_i]] + \Var_{\edge_i}[\Exp[\empweightfunc(\edge_i)|\sE_i]] &\text{(by law of total variance)}\\
            &\leq \Exp_{\edge_i}[\arboricity \Exp[\empweightfunc(\edge_i)|\sE_i]] + \Exp_{\edge_i} [\Exp[\empweightfunc(\edge_i)|\sE_i]^2]&\text{(by Equation~\ref{Eq: Var[Y_i,S, Small Degree Edge] random edge arboricity} and~\ref{Eq: Var[Y_i,S,High Degree Edge] random edge arboricity})}\\
            &\leq \arboricity \Exp_{\edge_i}[\Exp[\empweightfunc(\edge_i)|\sE_i]] + \frac{\upperthreshold\arboricity}{\approxerror} \cdot \Exp_{\edge_i} [\Exp[\empweightfunc(\edge_i)|\sE_i]]&\text{(as $\exactheavyoracle(\edge) = 0$, $\frac{\upperthreshold\arboricity}{\approxerror}\geq |T_e|$)}\\
            &\leq \frac{(1+\upperthreshold)\arboricity}{\approxerror} \cdot \Exp[\weightfunc(\edge)] 
        \end{align*}
    \end{proof}
\end{lemma}
\begin{theorem}\label{Theorem: Oracle Triangle Estimate ALgo Works}
    Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} makes $36\constant(1+\upperthreshold)\approxerror^{-3} (\edgecount\arboricity/\esttriangle)\log\vertexcount$ queries, and $4\constant(1+\upperthreshold)\approxerror^{-3} (\edgecount\arboricity/\esttriangle)$ $\log\vertexcount$ calls to \exactheavyoracle{}, and given $\esttriangle$ satisfying Assumption~\ref{Assumption: Triangle 2 Factor Estimate},  returns $\emptriangle$ such that $\Pr(|\emptriangle-\lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}|\geq \approxerror\lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}) \leq \frac{1}{\constant\log \vertexcount}$.
\end{theorem}

\begin{proof}
        The algorithm calls \exactheavyoracle{} for each of the $\edgesamplesize$ edges in $\samplededges$, resulting in a total of $4\constant(1+\upperthreshold)\approxerror^{-3}\log(\vertexcount)(\edgecount\arboricity/\esttriangle)$ calls. 

        The algorithm makes $\edgesamplesize$ \randedgeq{} queries, $2\edgesamplesize$ \degreeq{} queries, and $2\querycount_\edge$ \neighbourq{} query for each edge $\edge \in \samplededges$. All edges in $\samplededges$ are sampled uniformly at random from $\edgeset$. Hence, the expected number of \neighbourq{} queries made are: 
        
        $$\Exp_{\edge \sim \uniform\fbrac{\edgeset}} \left[ \ceil{\frac{\degree{\edge}}{\arboricity}} \right] = \sum_{e \in E} \frac{1}{m} \ceil{\frac{\degree{\edge}}{\arboricity}} \leq \frac{1}{m} \sum_{e \in E} 1 + \frac{\degree{\edge}}{\arboricity} = 1 + \frac{1}{m} \sum_{e \in E} \frac{\degree{\edge}}{\arboricity} \leq 1 + \frac{2m\arboricity}{m\arboricity} = 3$$
        The last inequality in the above step follows from Lemma~~\ref{Lemma: deg(e) sum is m * arboricity}.
        \remove{
        \begin{align*}
            &\Exp_{\edge \sim \uniform\fbrac{\edgeset}} \ceil{\frac{\degree{\edge_i}}{\arboricity}}\\
            =&\sum_{e \in E} \frac{1}{m} \ceil{\frac{\degree{\edge}}{\arboricity}}\\
            \leq&\frac{1}{m} \sum_{e \in E} 1 + \frac{\degree{\edge}}{\arboricity}\\
            =&1 + \frac{1}{m} \sum_{e \in E} \frac{\degree{\edge}}{\arboricity}\\
            \leq& 1 + \frac{2m\arboricity}{m\arboricity}&\text{By Lemma~\ref{lemma: arboricity triangle bound}}\\
            =& 3
        \end{align*}
        }
        Hence, the algorithm makes at most $9\constant\edgesamplesize = 36\constant(1+\upperthreshold)\approxerror^{-3}(\edgecount\arboricity/\esttriangle) \log \vertexcount$ queries in expectation. Here the inequality is due to the fact that for a heavy edge $\edge$ in $\samplededges$, $\querycount_\edge = 0$. Furthermore, we bound the variance of the estimate $\emptriangle$ as:
        
        % \red{By Lemma~\ref{lemma: E[Y_I] Weight Func Algo}, we have $\Exp\tbrac{\emptriangle} = \lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}$} \complain{(Debarshi, please check if it is $\lighttriangles{\lowerthreshold}$. I think there is something wrong with the superscript.)}\debarshi{Fixed it, but I think \red{this} line is unnecessary.}. 
        
        $$\Var[\emptriangle] = \Var[\frac{\edgecount}{\edgesamplesize} \sum_{i \in s} \empweightfunc(\edge_i)] \leq \frac{(1+\upperthreshold)\arboricity\edgecount^2\Exp[\weightfunc(\edge)]}{\approxerror \edgesamplesize} \leq \frac{(1+\upperthreshold)\edgecount\arboricity\Exp[\emptriangle]}{\approxerror \edgesamplesize}.$$
        The last two steps follow from Lemma~\ref{lemma: Var[Y_i] Weight Func Algo} and the fact that $\Exp\tbrac{\emptriangle} = \edgecount\Exp\tbrac{\weightfunc(\edge)}$.\remove{
        \begin{align*}
            \Var[\emptriangle] &= \Var[\frac{\edgecount}{\edgesamplesize} \sum_{i \in s} \empweightfunc(\edge)]\\
                    &\leq \frac{(1+\upperthreshold)\arboricity\edgecount^2\Exp[\empweightfunc(\edge)]}{\approxerror \edgesamplesize} &\text{Lemma \ref{lemma: Var[Y_i] Weight Func Algo}}\\
                    &\leq \frac{(1+\upperthreshold)\edgecount\arboricity\Exp[\emptriangle]}{\approxerror \edgesamplesize} &\Exp\tbrac{\emptriangle} = \edgecount\Exp\tbrac{\empweightfunc(\edge)}
        \end{align*}
        }
        We now use Chebyshev's inequality on $\emptriangle$:
        \begin{align*}
            \Pr(|\emptriangle - \Exp[\emptriangle]| \leq \approxerror \Exp[\emptriangle]) 
                    &\leq \frac{\Var[\emptriangle]}{\approxerror^2\Exp[\emptriangle]^2}   &\text{(Chebyshev's inequality)}\\
                    &\leq \frac{(1+\upperthreshold)\edgecount\arboricity}{\approxerror^3\edgesamplesize\Exp[\emptriangle]}&\text{(by Lemma \ref{lemma: Var[Y_i] Weight Func Algo})}\\
                    &\leq \frac{(1+\upperthreshold)\edgecount\arboricity}{\approxerror^3\cdot 4\constant\fbrac{1+\upperthreshold}\approxerror^{-3}(\edgecount\arboricity/\esttriangle)\log\vertexcount \cdot \lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}}} &\text{(by Lemma \ref{lemma: E[Y_I] Weight Func Algo})}\\
                    & \leq \frac{1}{\constant\log \vertexcount} &\text{(as $\lighttriangles{\frac{\lowerthreshold\arboricity}{\approxerror}} > \numtriangle/2 \geq \esttriangle/4$)}
        \end{align*}
    \end{proof}
%\gopi{\st{May be we summarize the conclusion from this section as a Lemma (so that we can use it later as a blackbox). Also, this section is good for building intuition. But this is not directly useful in the final algorithm later. If possible, may be we consider to rewrite it assuming access to an approximate Heavy-Oracle so that we can use the result as a blackbox later.}}\debarshi{Done.}
% \todo{$\approxerror^3$ is optimal?}








%-----------------------------New Subsection-----------------------------








%Section 3 - Implementing the Oracle

\subsection{Implementing the Oracle}
\label{ssec:oracle-implement}
Rather than the exact oracle (\exactheavyoracle) that we assumed in Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate}, we would design an oracle (called \heavyoracle) that given arboricity $\arboricity$, and parameters $\approxerror$ and $\confidence$, accepts edges participating in at most $\frac{\arboricity}{2\approxerror}$ triangles and rejects edges participating in at most $\frac{2\arboricity}{\approxerror}$ triangles with probability $1 - \confidence$. The algorithm works by estimating the number of triangles each edge participates in. However, in this case, each \neighbourq{} and \edgeexistsq{} generates i.i.d. random variables. Thus, our analysis uses multiplicative Chernoff bound to obtain high probability guarantees for each individual edge.

% \complain{Make $\querycount$ floor.}\debarshi{Done!}
\begin{algorithm}[ht!]
    \caption{\heavyoracle($\edge$,$\arboricity$,$\approxerror$,$\confidence$)}\label{Algorithm: Heavy Oracle}
    \begin{algorithmic}[1]
        \Require \degreeq{}, \neighbourq{}, \edgeexistsq{}, and \randedgeq{} query access to a graph $\graph$
        % \State $\degree{\edge} \gets degree(u)$, where $u$ is the endpoint of $e$ with smaller degree.
        \State $\querycount \gets \ceil{\frac{16\approxerror ~ \degree{\edge}}{\arboricity}\log\fbrac{\frac{1}{\confidence}}}$ \Comment{$\querycount$ denotes the number of queries for each edge $\edge$}
        % \State $\altvertex \gets$ Smaller degree vertex of $\edge$ 
        \State Let $\edge = (\altvertex, x)$ where $\degree{\altvertex} < \degree{x}$
        \Comment{Requires 2 \degreeq{} queries}
        \State $Y \gets 0$
        \For{$i \in [\querycount]$}
            \State Choose $k \gets \uniform\fbrac{\sbrac{1,2,...,\degree{\altvertex}}}$
            \State $\vertex_i \gets \neighbourq(\altvertex,k)$ 
            \Comment{Requires 1 \neighbourq{} query}
            % \State If $\vertex_i$ and $\edge$ form a triangle, $Y_i = 1$, else $Y_i = 0$ 
            \If{$\edgeexistsq{\fbrac{\vertex_i,x}} = 1$} \Comment{Requires 1 \edgeexistsq{} query}
                \State $Y_i \gets 1$ 
                \Comment{Found triangle $\fbrac{\vertex_i,\edge}$ }
            \Else
                \State $Y_i \gets 0$
            \EndIf
            \State $Y  \gets Y + Y_i$
        \EndFor
        \State $Y \gets \frac{1}{\querycount}Y$
        % \State $Y = \sum_{i \in \querycount} Y_i$
        \If{$Y \geq \frac{\arboricity}{\approxerror\degree{\edge}}$} 
            \State \Return 1
        \Else
            \State \Return 0
        \EndIf
    \end{algorithmic}
\end{algorithm}
% \vspace{-0.05in}
\begin{lemma}\label{Lemma: Heavy Oracle Algorithm Correctness}
    The algorithm $\heavyoracle{\fbrac{\edge,\arboricity,\approxerror,\confidence}}$ satisfies the following properties with probability at least $1-\confidence$: (i) rejects edge $\edge$ if it is $\frac{2\arboricity}{\approxerror}$-heavy; (ii) accepts edge $\edge$ if it is $\frac{\arboricity}{2\approxerror}$-light.
   \remove{
    \begin{itemize}
        \item rejects edge $\edge$ if it is $\frac{2\arboricity}{\approxerror}$-heavy.
        \item accepts edge $\edge$ if it is $\frac{\arboricity}{2\approxerror}$-light.
    \end{itemize}
    }
\end{lemma}

\begin{proof}
    For (i), we only consider edges that have at least $\frac{2\arboricity}{\approxerror}$ triangles. In this case, the random variables $Y_i$ ($Y_i$ as in Algorithm~\ref{Algorithm: Heavy Oracle}; $Y_i=1$ if $\vertex_i$ and $\edge$ form a triangle; $0$, otherwise) are i.i.d. Bernoulli random variables taking value $1$ with probability at least $\frac{2\arboricity}{\approxerror ~ \degree{\edge}}$. Hence, we have the following using linearity of expectation:  
    % $\Exp\tbrac{Y} = \Exp\tbrac{\frac{1}{\querycount}\sum_{i \in \tbrac{\querycount}} Y_i}$. 
    $\Exp\tbrac{Y} = \Exp\tbrac{\frac{1}{\querycount}\sum_{i \in \tbrac{\querycount}} Y_i} = \Exp\tbrac{Y_i} > \frac{2\arboricity}{\approxerror ~ \degree{\edge}} $
   \remove{
    \begin{align*}
        &\Exp\tbrac{Y}\\
        =&\Exp\tbrac{\frac{1}{\querycount}\sum_{i \in \tbrac{\querycount}} Y_i}\\
        =&\Exp\tbrac{Y_i} &\text{By linearity of expectations}\\
        >& \frac{2\arboricity}{\approxerror\degree{\edge}}
    \end{align*}
    }
    
    As $Y=\frac{1}{\querycount}\sum_i Y_i$, we can upper bound the probability of the algorithm returning $0$ for the edge $\edge$, by a multiplicative Chernoff bound (Lemma~\ref{Lemma: Multiplicative Chernoff Bound}) as follows:
    \begin{align*}
        \Pr\tbrac{Y \leq \frac{\arboricity}{\approxerror\degree{\edge}}} \remove{\complain{\mbox{(Debarshi: why is this } \frac{\arboricity}{\approxerror} \mbox{ and not } \frac{2 \arboricity}{\approxerror}?)}}
        \leq& \Pr\tbrac{Y \leq \fbrac{1-\frac{1}{2}}\Exp\tbrac{Y}} &\left( \Exp\tbrac{Y} > \frac{2\arboricity}{\approxerror\degree{\edge}} \right)\\
        \leq&\exp{\fbrac{-\frac{\querycount\Exp\tbrac{Y}}{12}}} &\text{(by multiplicative Chernoff bound)}\\
        \leq&\exp{\fbrac{-\frac{\querycount\arboricity}{6\degree{\edge}\approxerror}}} &\left( \Exp\tbrac{Y} > \frac{2\arboricity}{\approxerror\degree{\edge}}\right)\\
        \leq & ~ \confidence &\left( \querycount = \frac{16\approxerror \degree{\edge}}{\arboricity}\log\fbrac{\frac{1}{\confidence}}\right)\\
    \end{align*}
    For (ii), we do not have a lower bound on the probability of success $(Y_i = 1)$ in general and hence we cannot obtain a lower bound on $\Exp\tbrac{Y}$. Now, observe that for the edges that participate in very few triangles, the probability of finding triangles (i.e. getting $Y_i = 1$) is low. However, such light edges can still tolerate a high approximation error to be accepted (as a light edge). To account for the trade-off between the lower bound on the probability of $Y_i = 1$ and the upper bound on the approximation factor,
    \remove{However, observe that the edges that participate in very few triangles, and hence has a low probability of finding triangles (i.e. getting $Y_i = 1$) also can tolerate a high approximation error to still be accepted (as a light edge). To account for the trade-off between the lower bound on the probability of $Y_i = 1$ and the upper bound on the approximation factor, (Debarshi: too complicated! can you simplify?)}we divide the edges participating in at most $\frac{\arboricity}{2\approxerror}$ triangles into $\tbrac{\ceil{\log(\frac{\arboricity}{\approxerror})}}$ buckets with each bucket being defined as the set of edges $\bucket_k = \sbrac{\edge|\frac{\arboricity}{2^{k+1}\approxerror}\leq\numtriangle_\edge < \frac{\arboricity}{2^k\approxerror}}$. For each of these buckets, observe that when \heavyoracle{} is called for an edge belonging to the bucket, we have $\Pr\tbrac{Y_i = 1} = \frac{\triangle_\edge}{\degree{\edge}} \geq \frac{\arboricity}{2^{k+1}\approxerror\degree{\edge}}$, and hence $\Exp\tbrac{Y} = \Exp\tbrac{Y_i} \geq \frac{\arboricity}{2^{k+1}\approxerror\degree{\edge}}$.
    
   \remove{ \red{Similarly, from the other side, we have $\Exp\tbrac{Y} < \frac{\arboricity}{2^{k}\approxerror\degree{\edge}}$, and hence $\fbrac{1 + 2^k}\Exp\tbrac{Y} < \frac{\arboricity}{\approxerror\degree{\edge}}$. Using these observations, we complete the proof by considering any $\edge$ in these buckets:
    \todo{Approxerror can be at most $2^(k-1)$?}
    \begin{align*}
        \Pr\tbrac{Y \geq \frac{\arboricity}{\approxerror\degree{\edge}}} 
        \leq&\Pr\tbrac{Y \geq \fbrac{1+2^k}\Exp\tbrac{Y}} &\left( \fbrac{1 + 2^k}\Exp\tbrac{Y} < \frac{\arboricity}{\approxerror\degree{\edge}}\right)\\
        \leq& \exp{\fbrac{-\frac{2^{2k}\querycount\Exp\tbrac{Y}}{2+2^k}}} &\text{(by multiplicative Chernoff bound)}\\
        \leq& \exp{\fbrac{-\frac{2^{2k}\querycount\Exp\tbrac{Y}}{2^{k+1}}}} &(k \geq 1)\\
        \leq& \exp{\fbrac{-\frac{\querycount\arboricity}{4\approxerror\degree{\edge}}}}&\left( \Exp\tbrac{Y} > \frac{\arboricity}{2^{k+1}\approxerror\degree{\edge}} \right)\\
        \leq&~ \confidence & \left( \querycount \geq \frac{6\approxerror \degree{\edge}}{\arboricity}\log\fbrac{\frac{1}{\confidence}} \right)\\
    \end{align*}
    }}

    On the other hand, we have $\Exp\tbrac{Y} < \frac{\arboricity}{2^{k}\approxerror\degree{\edge}}$, and hence $\fbrac{1 + 2^{k-1}}\Exp\tbrac{Y} < \frac{\arboricity}{\approxerror\degree{\edge}}$. Using these observations, we complete the proof by considering any $\edge$ in these buckets:
    % \todo{Approxerror can be at most $2^(k-1)$?}
    \begin{align*}
        \Pr\tbrac{Y \geq \frac{\arboricity}{\approxerror\degree{\edge}}} 
        \leq&\Pr\tbrac{Y \geq \fbrac{1+2^{k-1}}\Exp\tbrac{Y}} &\left( \fbrac{1 + 2^{k-1}}\Exp\tbrac{Y} < \frac{\arboricity}{\approxerror\degree{\edge}}\right)\\
        \leq& \exp{\fbrac{-\frac{2^{2k-2}\querycount\Exp\tbrac{Y}}{2+2^{k-1}}}} &\text{(by multiplicative Chernoff bound)}\\
        \leq& \exp{\fbrac{-\frac{2^{2k}\querycount\Exp\tbrac{Y}}{2^{k+3}}}} &(k \geq 1)\\
        \leq& \exp{\fbrac{-\frac{\querycount\arboricity}{16\approxerror\degree{\edge}}}}&\left( \Exp\tbrac{Y} > \frac{\arboricity}{2^{k+1}\approxerror\degree{\edge}} \right)\\
        \leq&~ \confidence & \left( \querycount = \frac{16\approxerror \degree{\edge}}{\arboricity}\log\fbrac{\frac{1}{\confidence}} \right)
    \end{align*}
\end{proof}

Lemma~\ref{Lemma: Heavy Oracle Algorithm Correctness} shows that Algorithm~\ref{Algorithm: Heavy Oracle} can decide whether an edge is heavy or not with probability $1 - \confidence$ using $\frac{16\approxerror ~ \degree{\edge}}{\arboricity}\log\fbrac{\frac{1}{\confidence}}$ iterations; making 2 \degreeq{}, 1 \neighbourq{} and 1 \edgeexistsq{} queries in each iteration. For an individual edge, $\degree{\edge}$ can be at most $\vertexcount-1$, and hence the subroutine might contribute to additional queries for each edge. However, as part of Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate}, \heavyoracle{} is called on a set of edges drawn uniformly at random. Hence, in the following lemma, we bound the expected number of queries made by \heavyoracle{} when called on edges that were drawn uniformly at random.

\begin{lemma}\label{Lemma: Heavy Oracle Query Count}
    $\heavyoracle{\fbrac{\edge,\arboricity,\approxerror,\confidence}}$ makes $132\approxerror\log\fbrac{\frac{1}{\confidence}}$ queries in expectation on an edge $\edge \sim \uniform\fbrac{\edgeset}$. 
    
    % \complain{(Debarshi: the statement of the lemma is not making sense!)}
\end{lemma}

\begin{proof}
   For edge $\edge$, $\heavyoracle{\fbrac{\edge,\arboricity,\approxerror,\confidence}}$ makes $\ceil{\frac{16\approxerror \degree{\edge}}{\arboricity}\log\fbrac{\frac{1}{\confidence}}}$ iterations with each iteration making $4$ queries. Hence, the expected number of queries is:
   \begin{align*}
       \Exp_{\edge \sim \uniform\fbrac{\edgeset}}\tbrac{4\ceil{\frac{16\approxerror \degree{\edge}}{\arboricity}\log\fbrac{\frac{1}{\confidence}}}}
       \leq& \frac{64\approxerror}{\arboricity}\log\fbrac{\frac{1}{\confidence}}\Exp_{\edge \sim \uniform\fbrac{\edgeset}}\tbrac{\degree{\edge}}+ 4\\
       =& \frac{64\approxerror}{\arboricity}\log\fbrac{\frac{1}{\confidence}}\frac{1}{\edgecount}\sum_{\edge \in \edgeset} \degree{\edge}+4\\
       \leq& \frac{64\approxerror}{\arboricity}\log\fbrac{\frac{1}{\confidence}}\frac{1}{\edgecount}2\edgecount\arboricity + 4&\text{(by Lemma~\ref{Lemma: deg(e) sum is m * arboricity})}\\
       \leq& 132\approxerror\log\fbrac{\frac{1}{\confidence}} &\left( \approxerror\log\fbrac{\frac{1}{\confidence}} \geq 1 \right)
   \end{align*}
\end{proof}








%-----------------------------New Subsection-----------------------------








%Section 3 - Combining the algorithms

\subsection{The Final Algorithm}
\label{ssec:final-algo}
In this section, we put together everything. \remove{remove the assumption of access to \exactheavyoracle{} through using the \heavyoracle{} implementation developed in the previous section.} Our goal is to call \heavyoracle{} with appropriate parameters \remove{in an appropriate manner} instead of \exactheavyoracle{} so that the approximation error due to the heavy triangles not being counted remains sufficiently small. We also derive the query complexity of the algorithm including the queries made through \heavyoracle{}.

% \red{In this section, we develop the complete algorithm by removing the oracle and \complain{triangle estimate assumptions (Debarshi: do you remove it in this subsection?)} that we made for Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate}. We first note that the oracle to detect heavy edges \exactheavyoracle{} that we assumed for the algorithm cannot be implemented exactly. So, we replace it with the oracle call of \heavyoracle{} where we can detect heavy edges and light edges but with different thresholds. Hence, we implement the \heavyoracle{} subroutine in a manner so that the number of heavy triangles remain sufficiently small and we obtain the corresponding guarantees on heavy edges and query complexity of the algorithm.}


\begin{algorithm}[ht!]
    \caption{Triangle Counting Algorithm - with $\esttriangle$}\label{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate}
    \begin{algorithmic}[1]
        \Require \degreeq{}, \neighbourq{}, \edgeexistsq{}, and \randedgeq{} query access to a graph $\graph$. Parameters $\esttriangle, \arboricity$, $\approxerror$, $\edgecount$ 
        % \State Call Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} by replacing $\exactheavyoracle\fbrac{\edge,\arboricity,\approxerror}$ call with $\heavyoracle\fbrac{\edge,\arboricity,\approxerror/6,\frac{1}{\edgecount\vertexcount}}$, and parameters $\esttriangle, \arboricity$, $\approxerror/2$, and thresholds \complain{$\lowerthreshold = \frac{3}{2}$, and $\upperthreshold = 6$.}
        \State Call Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} with parameters $\esttriangle, \arboricity$, $\approxerror/2$, and thresholds $\lowerthreshold = 6$, and $\upperthreshold = 24$. We also implement $\exactheavyoracle\fbrac{\edge,\arboricity,\approxerror}$ oracle call through $\heavyoracle\fbrac{\edge,\arboricity,\approxerror/6,\frac{1}{\edgecount\vertexcount}}$. \Comment{Due to the Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} being called with parameter $\approxerror/2$ and the \heavyoracle{} implementation as stated, the threshold parameters are evaluated w.r.t. call to \heavyoracle{} with parameter $\lowerthreshold = 6$ and $\upperthreshold = 24$}
    \end{algorithmic}
\end{algorithm}

\begin{theorem}\label{Theorem: Triangle Estimate ALgo Works}
   Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} makes at most
$\fbrac{5050+13200\approxerror\log\vertexcount}\fbrac{\approxerror^{-3} (\edgecount\arboricity/\esttriangle) \constant\log \vertexcount}$ queries in expectation and returns $\emptriangle$ such that 
$\Pr\tbrac{\emptriangle \in \tbrac{\fbrac{1-\approxerror}\numtriangle,\fbrac{1+\approxerror}\numtriangle}} \geq 1 - \frac{1}{\constant\log \vertexcount}$.
\remove{
    \begin{align*}
        \Pr\tbrac{\emptriangle \in \tbrac{\fbrac{1-\approxerror}\numtriangle,\fbrac{1+\approxerror}\numtriangle}} \geq 1 - \frac{1}{\log \vertexcount}
    \end{align*}
}
\end{theorem}

\begin{proof}
    Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} will make the same number of calls to \heavyoracle{} as did Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Oracle Triangle Estimate} to \exactheavyoracle{}. So, by Theorem~\ref{Theorem: Oracle Triangle Estimate ALgo Works}, Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} makes $36\constant(1+\upperthreshold)\approxerror^{-3}(\edgecount\arboricity/\esttriangle)\log\vertexcount$ queries and $4\constant(1+\upperthreshold)\approxerror^{-3}\log(\vertexcount)$$(\edgecount\arboricity/\esttriangle)$ calls to $\heavyoracle{}$. By Lemma~\ref{Lemma: Heavy Oracle Query Count}, each call to $\heavyoracle{}$ requires $132\approxerror\log \vertexcount$ queries in expectation. Combining with the fact that we have $\upperthreshold = 24$, the algorithm requires $\fbrac{5050+13200\approxerror\log\vertexcount}\fbrac{\approxerror^{-3} (\edgecount\arboricity/\esttriangle) \constant\log \vertexcount}$ queries in expectation.

    By Lemma~\ref{Lemma: Heavy Oracle Algorithm Correctness}, the implementation of $\exactheavyoracle\fbrac{\edge,\arboricity,\approxerror} = \heavyoracle{\fbrac{\edge,\arboricity,\approxerror/6,\frac{1}{\edgecount\vertexcount}}}$  accepts a $\frac{6\arboricity}{\approxerror}$-light edge and rejects a $\frac{24\arboricity}{\approxerror}$-heavy edge with probability at least $1 - \frac{1}{\edgecount\vertexcount}$. By union bound, the algorithm accepts all $\frac{6\arboricity}{\approxerror}$-light edges and rejects all $\frac{24\arboricity}{\approxerror}$-heavy edges in $\samplededges$ with probability at least $1-\frac{1}{\vertexcount}$. Hence, by Corollary~\ref{Corollary: Lower Bound on Light Triangles} and Lemma~\ref{lemma: E[Y_I] Weight Func Algo}\remove{\complain{(Debarshi: it should need something more than Corollary~\ref{Corollary: Lower Bound on Light Triangles}?)}}, we have, 
    % \complain{(Debarshi: if you agree to the change in the constants of $\frac{\alpha}{\approxerror}$, then correct all occurrences of it.)}
    \begin{align}
    % \Pr\tbrac{\lighttriangles{\frac{6\arboricity}{\approxerror}} \in \tbrac{\fbrac{1-\approxerror/2}\numtriangle,\numtriangle}} \label{Eq:Final Light Triangle Bound}\\
    \Exp\tbrac{\emptriangle} = \lighttriangles{\frac{6\arboricity}{\approxerror}} \in \tbrac{\fbrac{1-\approxerror/2}\numtriangle,\numtriangle} \label{Eq:Final Light Triangle Bound}
    \end{align}

    By Theorem~\ref{Theorem: Oracle Triangle Estimate ALgo Works}, we have that:
    \begin{align}
        % \Pr\tbrac{\emptriangle \in \tbrac{\fbrac{1-\approxerror/2}\lighttriangles{\frac{6\arboricity}{\approxerror}},\fbrac{1+\approxerror/2}\lighttriangles{\frac{6\arboricity}{\approxerror}}}}\label{Eq: Final Estimate Bound not}\\
        \Pr\tbrac{\emptriangle \in \tbrac{\fbrac{1-\approxerror/2}\lighttriangles{\frac{6\arboricity}{\approxerror}},\fbrac{1+\approxerror/2}\lighttriangles{\frac{6\arboricity}{\approxerror}}}} \geq 1 - \frac{1}{\constant\log \vertexcount}\label{Eq: Final Estimate Bound}
    \end{align}

    Combining Equations~\ref{Eq:Final Light Triangle Bound} and~\ref{Eq: Final Estimate Bound}~and using union bound on the event that all oracle calls were executed correctly, for large enough $\vertexcount$:
    \begin{align*}
        \Pr\tbrac{\emptriangle \in \tbrac{\fbrac{1-\approxerror}\numtriangle,\fbrac{1+\approxerror}\numtriangle}} \geq 1 - \frac{1}{\constant\log \vertexcount}
    \end{align*}
\end{proof}

Using the usual techniques in property testing~\citep{Dana_Ron_Triangle_Counting,DBLP:conf/soda/EdenRS20,chakrabarti2015data,Goldreich_Ron_EdgeCounting}, we can obtain the following result. The details of the proof are deferred to the appendix.

\begin{theorem}\label{Theorem: Final Upper Bound}
    There exists an algorithm that makes $\bigot{\frac{\edgecount\arboricity\log\frac{1}{\confidence}}{\approxerror^3\numtriangle}}$ queries in expectation, and returns $X \in \tbrac{\fbrac{1-\approxerror}\numtriangle,\fbrac{1+\approxerror}\numtriangle}$ with probability at least $1 - \confidence$.
\end{theorem}


\subsection{Finalizing The Algorithm}

% \begin{algorithm}
%     \caption{Final Algorithm}
%     \begin{algorithmic}
%         \Require \randedgeq{}, \neighbourq{}, and \edgeexistsq{} query access to a graph $\graph$. Parameters $\arboricity$, $\approxerror$ 
%         \For{$\esttriangle$ in $\tbrac{\vertexcount^3,\vertexcount^3/2,...,1}$}
%             \For{$i \in \tbrac{\log\fbrac{\frac{6\log(\vertexcount)}{\confidence}}}$}
%                 \State $X_i \gets$ Solution to Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} with parameters $\esttriangle,\arboricity,\approxerror$
%                 \State $X \gets \min_i X_i$
%                 \If{$X \geq \esttriangle$}
%                     \State \Return $X$
%                 \EndIf
%             \EndFor
%         \EndFor
%     \end{algorithmic}
% \end{algorithm}

In this section, we describe the steps to obtain Theorem~\ref{Theorem: Final Upper Bound} from Theorem~\ref{Theorem: Triangle Estimate ALgo Works}. First, we remove the assumption on the knowledge of $\esttriangle$ for the Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate}. To achieve that, we search for an appropriate choice of $\esttriangle$ starting from $\searchesttriangle = \vertexcount^3$ and halving it each time we fail to find a $\esttriangle$ satisfying Assumption~\ref{Assumption: Triangle 2 Factor Estimate}.
We must also bound the probability of $\searchesttriangle$ deviating significantly below $\numtriangle$. To ensure that, for each value of $\searchesttriangle$, we run Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} using values of $\esttriangle$ as $\vertexcount^3,\vertexcount^3/2,...,\searchesttriangle$.

\begin{algorithm}
    \caption{Triangle Counting Algorithm}\label{Algorithm: Final Search}
    \begin{algorithmic}[1]
        \Require \degreeq{}, \neighbourq{}, \edgeexistsq{}, and \randedgeq{} query access to a graph $\graph$. Parameters $\arboricity$, $\approxerror$, $\edgecount$ 
        \For{$\searchesttriangle $ in $\tbrac{\vertexcount^3,\vertexcount^3/2,...,1}$}\label{Line: Bar T Range}
            \For{$\esttriangle$ in $\tbrac{\vertexcount^3,\vertexcount^3/2,...,\searchesttriangle }$} \label{Line: EstTriangle Range}
                \For{$i \in \tbrac{2\log\fbrac{\constant\log(\vertexcount)}}$}
                    \State $X_i \gets$ Solution to Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} with parameters $\esttriangle,\arboricity,\approxerror$
                    \State $X \gets \min_i X_i$
                    \If{$X \geq \esttriangle$}
                        \State \Return $X$
                    \EndIf
                \EndFor
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

First we bound the probability that the Algorithm~\ref{Algorithm: Final Search} terminates at a choice of $\esttriangle$ that does not satisfy the Assumption~\ref{Assumption: Triangle 2 Factor Estimate}.

\begin{lemma}\label{Lemma: Final Search Wrong Termination Bound}
    When $\esttriangle > 2\numtriangle$, the algorithm terminates with probability at most $\frac{1}{\constant\log^2 \vertexcount}$.
    % When $\searchesttriangle  > 2\numtriangle$, the algorithm terminates with probability at most $\frac{1}{\constant\log\fbrac{\vertexcount}}$.
    
    % \debarshi{Should we split this into two lemmas?}
\end{lemma}

\begin{proof}
    By Lemma~\ref{lemma: E[Y_I] Weight Func Algo}, we have from Markov's inequality:
    \begin{align*}
        \Pr\tbrac{\emptriangle > 2\numtriangle} \leq \frac{\Exp\tbrac{\emptriangle}}{2\numtriangle} \leq \frac{1}{2}
    \end{align*}
    Now, we have $\Pr\tbrac{X \geq \esttriangle} \leq \Pr\tbrac{\cap_{i}X_i \geq \esttriangle} \leq \frac{1}{\constant\log^2 \vertexcount}$
\remove{
    \begin{align*}
        &\Pr\tbrac{X \geq \esttriangle}\\
        \leq &\Pr\tbrac{\bigcap\limits_i ~ X_i \geq \esttriangle}\\
        \leq &\frac{1}{\constant\log^2 \vertexcount}
    \end{align*}
    }
    % A union bound over all possible values of $\esttriangle$ in Line~\ref{Line: EstTriangle Range} completes the proof.
\end{proof}

% \begin{lemma}
%     When $\searchesttriangle  < 2\numtriangle$, the algorithm terminates with probability at least $?$
% \end{lemma}

% \begin{proof}
    
% \end{proof}

\begin{lemma}\label{Lemma: Final Search Low Bar T Bound}
    The algorithm reaches a value of $\searchesttriangle  \leq \numtriangle/2^k$ $\fbrac{k \geq 1}$ with probability at most $\frac{1}{\fbrac{\constant\log \vertexcount}^k}$.
\end{lemma}

\begin{proof}
    For every such value of $\searchesttriangle $, we have a $\esttriangle$ in Line~\ref{Line: EstTriangle Range} of Algorithm~\ref{Algorithm: Final Search} such that $\esttriangle \leq \numtriangle/2$. By Theorem~\ref{Theorem: Triangle Estimate ALgo Works}, the algorithm returns an estimate $X_i \geq \numtriangle/2 \geq \esttriangle$ with probability at least $1 - \frac{1}{\constant\log \vertexcount}$. Taking a union bound over possible values of $i \in \tbrac{2\log \fbrac{\constant\log \vertexcount}}$, we have Algorithm~\ref{Algorithm: Final Search} returns an $X$ such that $X \geq \numtriangle/2 \geq \esttriangle$ with probability at least $1 - \frac{1}{\constant\log \vertexcount}$, and the algorithm terminates.

    % \debarshi{Here in the union bound, we use the fact that $\log\vertexcount \gg \log\log\vertexcount$, do we need to make this explicit?}
    
    Hence, to get to a $\searchesttriangle  \leq \frac{\numtriangle}{2^k}$, the Algorithm~\ref{Algorithm: Final Search} must have failed to terminate for all previous values of $\searchesttriangle $, which happens with probability at most $\frac{1}{\fbrac{\constant\log \vertexcount}^k}$.
\end{proof}

Finally we combine Lemmas~\ref{Lemma: Final Search Wrong Termination Bound} and~\ref{Lemma: Final Search Low Bar T Bound} to obtain the following theorem quantifying the estimation guarantees and query complexity of Algorithm~\ref{Algorithm: Final Search}.

\begin{theorem}
    Algorithm~\ref{Algorithm: Final Search} makes $\bigot{\edgecount\arboricity/\approxerror^3\numtriangle}$ queries in expectation, and returns $X \in [\fbrac{1-\approxerror}\numtriangle$ $,\fbrac{1+\approxerror}\numtriangle]$ with probability at least $5/6$.
\end{theorem}

\begin{proof}
    The algorithm runs through at most $\log^2 \vertexcount$ values of $\esttriangle$ such that $\esttriangle > 2\numtriangle$. By Lemma~\ref{Lemma: Final Search Wrong Termination Bound}, the algorithm terminates in each such case with probability at most $1/\constant\log^2\vertexcount$. For each value of $\searchesttriangle  \leq 2\numtriangle$, by Theorem~\ref{Theorem: Triangle Estimate ALgo Works}, the algorithm returns a wrong value with probability at most $1/\constant\log \vertexcount$. There are at most $3\log\vertexcount$ such values of $\searchesttriangle$. Taking an union bound and fixing the constant $\constant$ appropriately, the algorithm returns a correct output with probability at least $5/6$.

    For each  $\searchesttriangle $ in Line~\ref{Line: Bar T Range} of Algorithm~\ref{Algorithm: Final Search}, by Theorem~\ref{Theorem: Triangle Estimate ALgo Works} the algorithm makes $\bigot{(\edgecount\arboricity/\approxerror^3\searchesttriangle )}$ queries. Hence, till $\searchesttriangle  \leq \numtriangle/2$, the algorithm makes $\bigot{(\edgecount\arboricity/\approxerror^3\numtriangle)}$ queries. Additionally, by Lemma~\ref{Lemma: Final Search Low Bar T Bound}, the queries beyond $\searchesttriangle  \leq \numtriangle$ can be bounded as:
    \begin{align*}
        \sum_{i \in \log\fbrac{\vertexcount}}\frac{1}{\fbrac{\constant\log \vertexcount}^k}\cdot2^k \cdot\bigot{\frac{\edgecount\arboricity}{\approxerror^3\numtriangle}} &=\bigot{\frac{\edgecount\arboricity}{\approxerror^3\numtriangle}}
    \end{align*}
\end{proof}

\begin{theorem}
    There exists an algorithm that makes $\bigot{\frac{\edgecount\arboricity\log\frac{1}{\confidence}}{\approxerror^3\numtriangle}}$ queries in expectation, and returns $X \in \tbrac{\fbrac{1-\approxerror}\numtriangle,\fbrac{1+\approxerror}\numtriangle}$ with probability at least $1 - \confidence$.
\end{theorem}

\begin{proof}
    By the well-known median trick~\citep{chakrabarti2015data}, the median of $\bigo{\log\frac{1}{\confidence}}$ independent runs of Algorithm~\ref{Algorithm: Final Search} establishes the result.
\end{proof}











% \begin{algorithm}[ht!]
%     \caption{Triangle Counting - Final Algorithm}\label{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate}
%     \begin{algorithmic}[1]
%         \Require \randedgeq{}, \neighbourq{}, and \edgeexistsq{} query access to a graph $\graph$. Parameters $\esttriangle, \arboricity$, $\approxerror$ oracle access to \heavyoracle{} with threshold constant $\threshold$
%         \State $\edgesamplesize \gets 25\approxerror^{-3}\log(\vertexcount)(\edgecount\arboricity/\esttriangle)$
%         \State $\samplededges \gets \emptyset$
%         \State $\sampledtriangles \gets \emptyset$
%         \For{$i \in [\edgesamplesize]$}
%             \State $\edge_i \gets \randedgeq{}$
%             \State Let $\vertex_i$ be the endpoint of $\edge_i$ with smaller degree, and $x$ be the endpoint of $\edge_i$ that is not $\vertex_i$.
%             \If{$\heavyoracle(\edge_i,\arboricity,\frac{\approxerror}{12},\frac{1}{2\edgecount\log{\fbrac{n}}}) = 0$}
%                 \State $\samplededges \gets \samplededges \cup \edge_i$
%                 \State $\querycount_{\edge_i} \gets 0$
%                 \State If $\degree{\edge_i} \leq \arboricity$, set $\querycount_{\edge_i} \gets 1$ with probability $\frac{\degree{\edge_i}}{\arboricity}$. Otherwise, set $\querycount_{\edge_i} \gets \ceil{\frac{\degree{\edge_i}}{\arboricity}}$
%                 \For{$j \in [\querycount_{\edge_i}]$}
%                     \State $\altvertex \gets \neighbourq{\fbrac{\vertex_i}}$
%                     \State If $\edgeexistsq{\fbrac{\altvertex,x}} = 1$ and $(\altvertex,\edge_i)$ is not a triangle in $\sampledtriangles$, $\sampledtriangles \gets \sampledtriangles \cup (\altvertex,\edge_i)$ 
%                 \EndFor
%             \EndIf
%         \EndFor
%         % \State Remove duplicate triangles from $\sampledtriangles$ If a triangle is
%         \For{$\edge \in \samplededges$}
%             \State $\empweightfunc(\edge) = \frac{1}{\querycount_{\edge}} \sum_{(u,\edge) \in \sampledtriangles} \max\fbrac{\arboricity,\degree{\edge}}$
%             % \State $Y_\edge = \frac{1}{\querycount_{\edge}} \empweightfunc(\edge)$
%         \EndFor
%         % \State Choose a consistent weight function $\weightfunc$. Compute the empirical weight function as $\empweightfunc(e) = \weightfunc_\samplededges(e)$
%         \State \Return $\emptriangle = \frac{\edgecount}{\edgesamplesize}\sum_{\edge \in \samplededges} \empweightfunc(\edge)$
%     \end{algorithmic}
% \end{algorithm}

% \begin{theorem}\label{Theorem: Triangle Estimate Algo Works}
%     The algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} returns $\emptriangle$ such that
%     \begin{align*}
%         \Pr\tbrac{\emptriangle \in \tbrac{\fbrac{1-\approxerror}\numtriangle,\fbrac{1+\approxerror}\numtriangle}} \geq 1 - \frac{1}{\log\fbrac{\vertexcount}}
%     \end{align*}
% \end{theorem}

% \begin{proof}
%     The \heavyoracle{} implemented here rejects $\frac{24\arboricity}{\approxerror}$-heavy edges and accepts $\frac{24\arboricity}{\approxerror}$-light edges with probability at least $1 - \frac{1}{2\edgecount\log{\fbrac{n}}}$. By union bound, \heavyoracle{} rejects all $\frac{24\arboricity}{\approxerror}$-heavy edges and accepts all $\frac{6\arboricity}{\approxerror}$-light edges correctly with probability at least $1-\frac{1}{2\log{\fbrac{n}}}$. 
    
%     Hence, by Lemma~\ref{lemma: E[Y_I] Weight Func Algo} and Corollary~\ref{Corollary: Lower Bound on Light Triangles}, the algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} with probability at least $1-\frac{1}{2\log{\fbrac{n}}}$ outputs $\emptriangle$ such that:
%     \begin{align}
%         \Exp{\tbrac{\emptriangle}} = \lighttriangles{\threshold} \in \tbrac{\fbrac{1-\frac{\approxerror}{2}}\numtriangle,\numtriangle}\label{Equation: Expectation of Triangle Estimate Algorithm}
%     \end{align}
%     By Theorem~\ref{Theorem: Oracle Triangle Estimate ALgo Works}, we have that:
%     \begin{align}
%         \Pr\tbrac{\emptriangle \notin \tbrac{\fbrac{1-\frac{\approxerror}{2}}\lighttriangles{\threshold},\fbrac{1+\frac{\approxerror}{2}}\lighttriangles{\threshold}}} \leq \frac{1}{2\log\fbrac{\vertexcount}}\label{Equation: Confidence interval of Triangle Estimate Algorithm}
%     \end{align}
%     Combining Equation~\ref{Equation: Expectation of Triangle Estimate Algorithm} and \ref{Equation: Confidence interval of Triangle Estimate Algorithm} through union bound, we have:
%     \begin{align*}
%         \Pr\tbrac{\emptriangle \in \tbrac{\fbrac{1-\approxerror}\numtriangle,\fbrac{1+\approxerror}\numtriangle}} \geq 1 - \frac{1}{\log\fbrac{\vertexcount}}
%     \end{align*}
% \end{proof}

% \todo{Make the final search algorithm formal?}



% \begin{theorem}
%     The Algorithm~\ref{Algorithm: Random Edge Arboricity Triangle Counting Triangle Estimate} makes $25\approxerror^{-3}\log(\vertexcount)(\edgecount\arboricity/\esttriangle)(4+2\approxerror\log\fbrac{2\edgecount\log{\fbrac{n}}})$ queries in expectation.
% \end{theorem}
% \todo{Find a more comprehnsible expression.}
% \begin{idea}[There is a $\log^2(n)$ term!]
%     The original works of~\citep{Dana_Ron_Triangle_Counting,assadi2018simple} in terms of $poly\log(n)$ includes only a $\log(n)$ term. Here, it becomes $\log^2(n)$ due to the \heavyoracle{} adding an additive $\log(n)$ for the union bound. It can be reduced to $m\arboricity$ quite easily. Do we need to?
% \end{idea}
% \begin{proof}
%     The algorithm makes $3$ sets of queries, $\edgesamplesize$ \randedgeq{} queries, \heavyoracle{} call for each of these sampled edges, and finally $2\querycount$ queries for each of these edges.

%     For $\heavyoracle{}$, lemma~\ref{Lemma: Heavy Oracle Query Count} states that it makes $2\approxerror\log\fbrac{2\edgecount\log{\fbrac{n}}}$ queries in expectation. 

%     For the final $2\querycount$ queries, the expectation is taken over the edges sampled uniformly at random:
%     \begin{align*}
%         &\Exp_{\edge \sim \uniform\fbrac{\edgeset}} \ceil{\frac{\degree{\edge_i}}{\arboricity}}\\
%         =&\sum_{e \in E} \frac{1}{m} \ceil{\frac{d_e}{\arboricity}}\\
%         \leq&\frac{1}{m} \sum_{e \in E} 1 + \frac{d_e}{\arboricity}\\
%         =&1 + \frac{1}{m} \sum_{e \in E} \frac{d_e}{\arboricity}\\
%         \leq& 1 + \frac{2m\arboricity}{m\arboricity}&\text{By Lemma~\ref{lemma: arboricity triangle bound}}\\
%         =& 3
%     \end{align*}
%     Hence, the algorithm makes at most $\edgesamplesize(4+2\approxerror\log\fbrac{2\edgecount\log{\fbrac{n}}})$ in expectation. Plugging back the value of $\edgesamplesize$ completes the proof.
% \end{proof}