
\documentclass[acmsmall,screen,nonacm]{acmart}



\usepackage{tikz}
\usetikzlibrary{calc, decorations.markings, decorations.shapes, arrows.meta, chains, positioning, shapes.symbols, shapes.geometric}
\usepackage{listings}
\usepackage[normalem]{ulem}  %
\usepackage{lipsum}
\usepackage{wrapfig}
\usepackage{multicol}
\usepackage{subcaption}
\usepackage{adjustbox}
\usepackage[skins]{tcolorbox}

\input{macros/colors.tex}
\input{lib/lstlinebgrd_fixed.tex}
\input{lib/delphyne_listings.tex}
\input{lib/haskell_listings.tex}

\input{macros/shortcuts.tex}
\input{macros/notations.tex}


\setcopyright{acmlicensed}
\copyrightyear{2024}
\acmYear{2024}
\acmDOI{XXXXXXX.XXXXXXX}

\acmConference[PLDI '25]{Programming Language Design and Implementation}{2025}{Seoul}
\acmISBN{978-1-4503-XXXX-X/18/06}

\begin{document}


\title{Oracular Programming}
\subtitle{A Modular Foundation for Building LLM-Enabled Software}

\author{Jonathan Laurent}
\orcid{0000-0002-8477-1560}
\affiliation{%
  \institution{Carnegie Mellon University}
  \city{Pittsburgh}
  \state{Pennsylvania}
  \country{USA}}
  \affiliation{%
  \institution{Karlsruhe Institute of Technology}
  \city{Karlsruhe}
  \country{Germany}}
\email{jonathan.laurent@cs.cmu.edu}

\author{AndrÃ© Platzer}
\orcid{0000-0001-7238-5710}
\affiliation{%
  \institution{Karlsruhe Institute of Technology}
  \city{Karlsruhe}
  \country{Germany}}
\email{platzer@kit.edu}

\renewcommand{\shortauthors}{Laurent and Platzer}


\begin{abstract}
  Large Language Models have proved surprisingly effective at solving a wide range of tasks from just a handful of examples. However, their lack of reliability and modularity limits their capacity to tackle large problems that require many steps of reasoning. In response, researchers have proposed advanced pipelines that leverage domain-specific knowledge to chain smaller prompts, provide intermediate feedback and improve performance through search. However, the current complexity of writing, tuning, maintaining and improving such pipelines has limited their sophistication. We propose \emph{oracular programming}, a foundational paradigm for building LLM-enabled applications that lets domain experts express high-level problem-solving strategies as programs with unresolved choice points. These choice points are resolved at runtime by LLMs, which generalize from user-provided examples of correct and incorrect decisions. An \emph{oracular program} is composed of three orthogonal components: a \emph{strategy} that consists in a nondeterministic program with choice points that can be reified into a search tree, a \emph{policy} that specifies how to navigate this tree with the help of LLM oracles, and a set of \emph{demonstrations} that describe successful and unsuccessful search tree navigation scenarios across diverse problem instances. Each component is expressed in a dedicated programming language and can be independently improved or substituted. We address the key programming language design challenges of modularly composing oracular programs and enforcing consistency between their components as they evolve.
\end{abstract}







\maketitle



\section{Introduction}

Large Language Models (LLMs) trained on vast corpora of text, such as GPT-4~\cite{gpt4}, have demonstrated remarkable capability in learning new tasks from a handful of examples and generating complex, structured data~\cite{brown2020language}. These models have driven breakthroughs across a wide range of problem areas, including reasoning-intensive domains like program synthesis~\cite{li2022competition}, mathematical problem-solving~\cite{lewkowycz2022solving} and formal theorem proving~\cite{jiang2022draft,first2023baldur}. Still, their lack of reliability and their propensity to hallucinate have limited their practical impact and their ability to tackle large problems that require combining many steps of reasoning without error. In response, researchers have proposed {integrating} LLMs into software pipelines that leverage domain-specific knowledge to decompose complex tasks into smaller prompts~\cite{sahoo2024systematic}, provide intermediate feedback through external tools or separate LLM critics~\cite{yao2022react,yao2024tree}, and improve reliability through search and validation~\cite{yao2024tree,lewkowycz2022solving}.

At first glance, developing such pipelines may seem deceptively simple. After all, LLMs can be prompted through straightforward APIs, and developers have access to the full arsenal of existing programming languages and software-engineering tools to build sophisticated systems on top of them. However, developing LLM-enabled software raises unique challenges that we argue are not properly addressed by existing programming abstractions:

\begin{itemize}
  \item LLMs offer a powerful but inherently unreliable programming primitive, making the ubiquitous use of \emph{search} and \emph{validation} essential for ensuring dependability. At the same time, prompting an LLM is an expensive operation, making retrials and backtracking particularly costly. Resolving this tension requires the careful tuning of this search logic, which must also be adaptable to user-specific constraints (e.g. inference budget, latency tolerance...). Evolving this logic can require costly and frequent refactorings, especially when it is intertwined with the higher-level logic that specifies how large problems are decomposed into smaller problems and prompts. 
  \item Prompting language models often works best when providing examples of successfully solving other instances of the same task (i.e. \emph{few-shot prompting}~\cite{brown2020language}). Such examples are therefore crucial components of LLM-enabled programs but writing them can be time-consuming. More importantly, these examples need to be kept synchronized with the rest of the program: any change can render some examples irrelevant while introducing the need for new ones, whose identity may be unclear. While numerous techniques exist for maintaining correctness and consistency in traditional programs -- primarily through type systems, contracts and testing -- LLM-enabled programs present a unique and largely unaddressed challenge. Yet, these programs stand to gain disproportionately from \emph{fearless refactoring}, as the inherent opacity and unpredictability of LLMs demand frequent iteration and rapid development cycles.
\end{itemize}

Together, these challenges have limited the scale, complexity and robustness of existing LLM-enabled software. This paper proposes a new foundation for programming with LLMs, which we
\input{figures/triangle.tex}%
call \emph{oracular programming}. In this paradigm, a \emph{program} is defined by three orthogonal components: a \emph{strategy},
a \emph{policy}, and a set of \emph{demonstrations}. A \emph{strategy} is a nondeterministic program that denotes a high-level plan for solving a particular class of problems. It induces a search tree that can be navigated with LLM guidance, as specified by a \emph{policy}. A \emph{demonstration} bundles relevant examples of answering specific LLM requests with unit tests, in such a way to describe concrete scenarios of successfully or unsuccessfully navigating the search tree for a particular problem instance. By design, all three components are orthogonal and can be improved or substituted \emph{independently}. Each can be expressed in a dedicated language, whose design is guided by three core objectives: \emph{modularity}, \emph{evolvability} and \emph{extensibility}.

\begin{description}
\item[Modularity.] {Modularity} matters most~\cite{harper2016practical} and yet is remarkably subtle to achieve for oracular programs. Modularity ensures that large strategies can be composed from smaller ones, individual LLM queries {transparently} replaced by calls to dedicated strategies, and sub-strategies refined independently of their parents. Achieving this goal has profound implications on the design of the strategy and policy languages. In particular, a key challenge is to allow composing strategies while keeping their respective policies independent and oblivious to each other. We accomplish this by defining a novel data structure for \emph{modular search trees}, along with a \emph{search stream protocol} that allows composing heterogeneous search algorithms.

\item[Evolvability.] Oracular programs must be easy to evolve, keeping their three respective components consistent with each other. Consistency between \emph{strategies} and \emph{policies} is enforced through types. By design, \emph{policies} and \emph{demonstrations} are fully decoupled and so a change in one cannot affect the other. Finally, consistency between \emph{strategies} and \emph{demonstrations} is enforced by having demonstrations specify unit tests in the form of tree-navigation scenarios that can be  concisely described in a dedicated sub-language. Consistency is {guaranteed} to be preserved for a large class of strategy transformations. In addition, our demonstration language enables rich tooling support for writing and repairing demonstrations interactively.

\item[Extensibility.] To foster the discovery of new idioms, our proposed programming framework is designed for \emph{extensibility}. The strategy language can be extended with new \emph{effects} by defining new types of tree nodes. In addition, most policies are expressible by composing a number of standard building blocks but, should the need arise, new search algorithms can be easily added by implementing the search stream protocol.
\end{description}

This paper begins with a high-level overview of \emph{oracular programming} and of its key concepts, which we present via a minimal example (Section~\ref{sec:overview}). Then, it motivates and explores the design of the three languages that form the triad of oracular programming (Section~\ref{sec:triad}). After that, it introduces Delphyne, an oracular programming framework embedded in Python, which comes with proper tooling support via a dedicated language server (Section~\ref{sec:delphyne}).




\section{Overview}\label{sec:overview}

Let us illustrate the key concepts of oracular programming using a simple but relevant example.

\begin{figure}
  \centering
  \includegraphics{figures/img/strategy-overview.pdf}
  \caption{Strategies are nondeterministic programs that can be reified into search trees. They can issue \emph{queries} to be answered by external oracles. \emph{Branching}, \emph{value} and \emph{failure} nodes are labeled \code{B}, \code{F}, and \code{V} respectively. Horizontal lines denote \emph{nesting} while other lines denote parent-child relations. Grayed-out elements indicate information that is mostly relevant to the policy language and can be ignored on first reading.}\label{fig:strategy-overview}
\end{figure}

\paragraph{Strategies and Trees.} Figure~\ref{fig:strategy-overview} shows a simple strategy for the problem of \emph{program synthesis} named \code{generateProg}. Concretely, \code{generateProg} is a \emph{nondeterministic} program that takes a specification as an argument and returns a program that respects it. To do so, it proceeds in several steps. First, it conjectures a program. Then, it reflects on this program, determining a likelihood that the program indeed respects the specification. After that, it generates a machine-checkable proof establishing that the program is correct, and verifies this proof. If the proof is verified as correct, the program can be returned. In turn, the first conjecturing step is implemented via a separate strategy named \code{conjectureProg}. Given a specification, this strategy conjectures a correct program by generating executable unit tests, producing a program and then returning it if it passes every test.

Once its arguments are instantiated, a strategy such as \code{generateProg} can be reified into an infinitely-branching search tree. Calls to the \code{branch} operator induce \emph{branching nodes}. A strategy can branch over the result of another strategy (e.g. \code{conjectureProg}) or over the result of a \emph{query} (e.g. \code{ProveProg}, \code{ProposeTests}...). A \emph{query} is an object that denotes a question being asked to an external oracle. For each query type, one must define two prompting functions along with a parsing function for converting raw textual answers to values of suitable type. The \code{systemPrompt} function generates a textual description of the general class of questions associated with a query type (e.g. \textit{``Given a program and a specification, estimate the likelihood that the program matches the specification. Answer with a real number in the $[0, 1]$ interval.''}) while the \code{instancePrompt} function generates a textual description of a specific query instance (e.g. a labeled code block containing a program followed by a labeled code block containing a specification). This separation between \emph{system prompts} and \emph{instance prompts} is important for implementing \emph{few-shot prompting}, as we discuss shortly and illustrate in Figure~\ref{fig:policy-overview}. A call to the \code{ensure} operator induces a \emph{failure leaf} when its boolean argument is \emph{false} and does nothing otherwise. A strategy successfully returning a value induces a \emph{success leaf}. Finally, a call to the \code{value} operator induces a \emph{value node}, which is attached a query or another strategy tree and has a unique child associated with the strategy's continuation.

By \emph{modularity}, any query can be refined into a dedicated strategy call without affecting other parts of the oracular program. For example, \code{generateProg} currently uses a single \code{ProveProg} query to generate machine-checkable proofs but a dedicated strategy could be used instead, providing more opportunities for guiding LLMs in this task. This modularity appears in the structure of search trees, where any query attached to a node can be replaced by a nested strategy tree, both of them implementing the concept of a \emph{search space} (Section~\ref{sec:strategy-lang}). A strategy can invoke \emph{effects}, the list of which is called its \emph{signature} and is featured in its type. Each effect corresponds to the ability of spawning a particular node type. By \emph{extensibility}, new effects can be defined within our framework. Operators such as \code{branch}, \code{value} and \code{ensure} are not primitives but can be defined in the same way. A sub-strategy does not necessarily have to share the signature of its parent but it must be associated a \emph{search policy} that can handle all its effects, as we discuss next.

\begin{figure}
  \centering
  \includegraphics{figures/img/policy-overview.pdf}
  \caption{A policy describes how to navigate a strategy tree with the help of an oracle. It consists in a search policy and an inner policy, both of which can be assembled from atomic components.}\label{fig:policy-overview}
\end{figure}

\paragraph{Policies.} As illustrated in Figure~\ref{fig:policy-overview}, a \emph{policy} specifies \emph{how} the search tree induced by a strategy should be navigated, with the help of one or several LLMs. The structure of a policy reflects the modular structure of the associated strategy. More precisely, a {policy} is defined as a pair of a \emph{search policy} and of an \emph{inner policy}. The {search policy} describes an algorithm for navigating the top-level tree (e.g. {depth-first search}, {breadth-first search}, {best-first search}, MCTS...) while the {inner policy} recursively specifies a policy for every sub-strategy, along with a \emph{prompting policy} for each query.

A \emph{prompting policy} describes how a query should be answered: which LLM should be used, how the prompt should be formed, how many answer attempts should be made... One standard prompting policy is \emph{few-shot prompting}, where the prompt features a series of examples that answer queries of the same type. These examples are themselves extracted from \emph{demonstrations}, as we discuss shortly. The prompt is formed by concatenating the system prompt of the query, the instance prompt for each example along with the associated answer, and finally the instance prompt of the query to be answered. Given such a prompt, LLM answers can be repeatedly sampled and parsed, resulting in an infinite \emph{search stream}. Search streams provide an abstraction for representing the outcome of an arbitrary prompting policy or search policy, allowing heterogeneous search processes to be composed and transformed uniformly. A search stream consists of a lazy stream of messages, which can be of three types: a \code{Yield} message produces a new value, a \code{Spent} message indicates what search budget has been spent and a \code{Barrier} message indicates that an estimated amount of budget is \emph{about} to be spent. Search budgets can be expressed using different metrics: number of requests, token usage, dollar amount for a certain LLM API... 

A \emph{search policy} maps a search tree and an inner policy to a search stream. Its type reflects the list of effects (i.e. node types) that it is capable of handling. One standard search policy is \emph{depth-first} search, or \code{dfs}, which can handle the \code{Branch} and \code{Fail} effects. Every time \code{dfs} reaches a branching node, it uses the inner policy to convert the attached tree or query into a search stream and then consumes this stream until a branching candidate is generated, at which point the stream is paused until backtracking happens and a new candidate is needed. A \code{Yield} message is issued whenever a success node is reached. Importantly, \code{dfs} is oblivious to the nature of the query or strategy that induces a stream of candidates at each branching node, thereby enforcing modularity.

Prompting policies and search policies are typically not defined from scratch but assembled from smaller building blocks. In particular, two important kinds of building blocks are \emph{tree transformers} and \emph{stream transformers}. A \emph{tree transformer} maps a tree to another one, possibly with a different signature. Tree transformers can be \emph{right}-composed with search policies. For example, the \code{generateProg} strategy must be associated a search policy that handles branching, failure, and {value} nodes. This is the case of \code{bestFirstSearch} or \code{mcts}, which leverage the value information for prioritizing branches to explore. Alternatively, a tree transformer can be used to \emph{eliminate} value nodes, so that \code{dfs} can be used instead. This can be done it at least two different ways: by simply removing value nodes (\code{dropValues}) or converting value nodes into \code{ensure} statements that fail below a certain level (\code{binarizeValues}). A \emph{stream transformer} maps a search stream into another one. Stream transformers can be \emph{left}-composed with search policies or prompting policies. Standard examples of stream transformers are \code{take n}, which terminates a stream after \code{n} elements are generated and \code{withBudget b}, which terminates a stream after a certain amount of budget is spent.

Although strategies and policies ultimately work together to produce search streams, our framework allows to fully decouple them. Thus, a strategy such as \code{generateProg} can be combined with vastly different policies, which may themselves reflect different tradeoffs in terms of budget spending, parallelism and latency.

\begin{figure}
  \centering
  \includegraphics{figures/img/demo-overview.pdf}
  \caption{A demonstration bundles a set of query answers with a sequence of unit tests that describe concrete scenarios of navigating a specific strategy tree using these answers. Each test describes a path in the tree, highlighted with a matching color.}\label{fig:demo-overview}
\end{figure}

\paragraph{Demonstrations}
Few-shot prompting depends on the availability of examples. We propose a dedicated language for writing, organizing and maintaining such examples with minimal effort in the form of \emph{demonstrations}. A demonstration bundles a set of query answers with a sequence of unit tests that describe concrete scenarios of navigating a specific strategy tree using these answers, thereby ensuring their relevance and consistency with the associated strategy. An example of a demonstration is shown in Figure~\ref{fig:demo-overview} for the \code{generateProg} strategy. It ends with a \code{queries} section that contains one or more answers for a sequence of queries. Answers can be attached optional labels and tagged according to whether or not they are eligible to being used as examples for few-shot prompting.

Each test describes a path through the search tree and can either succeed or fail. Also, each test is composed of a sequence of instructions that are chained together using the \code{|} pipe operator. The first test (\code{run | success}) ensures that the provided examples are sufficient for solving the particular problem instance that the demonstration is about. The \code{run} instruction can be informally interpreted as ``walk through the tree, using the first listed answer as a response every time a listed query is encountered'' ; the \code{success} instruction checks that the node at the end of this path is a success leaf. The second test demonstrates how to recover from a suboptimal choice by assigning it a low value. The \code{at EvalProg `wrong`} instruction is similar to \code{run}, except that the answer labeled \code{wrong} must be selected when applicable and navigation must stop upon reaching a node associated with a query of type \code{EvalProg} ; the \code{answer} instruction ensures that this query is answered in the demonstration. Since the answer labeled with \code{wrong} is not optimal and only included for the purpose of demonstrating how to reflect on a bad choice, it is marked as unsuitable for use as an example. Finally, the third test aims for a full walk through the tree, selecting the \code{wrong}-labeled answer when appropriate. However, it hits a query that is not listed in the demonstration and thus fails as \emph{stuck}, providing the user with appropriate information on what query must be answered for navigation to proceed. With proper tooling, this mechanism allows writing and repairing demonstrations interactively.
Section~\ref{sec:demo-lang} motivates and discusses our proposed \emph{demonstration language} in detail, emphasizing the empirical observations that it is based on and the evolvability guarantees that it provides.


\section{The Oracular Programming Triad}\label{sec:triad}

This section justifies and describes the design of the three languages that, together, form the triad of \emph{oracular programming}. In particular,  we define a \emph{strategy} and a \emph{policy language} via shallow embeddings in Haskell. Haskell is a good candidate for a host language, because of its expressive type system and of its syntactic facilities for expressing monadic code. A Python embedding is also discussed in Section~\ref{sec:delphyne}, as we introduce our Delphyne framework. %


\subsection{The Strategy Language}\label{sec:strategy-lang}


Reifying nondeterministic programs as search trees is not a new idea, but it has arguably failed to meet its potential as a programming paradigm so far, in the absence of a systematic way of producing oracles to navigate the resulting search spaces at scale. Our suggestion of using large language models for this role is a key contribution of this paper. Beyond this, our proposed \emph{strategy language} innovates significantly on classical implementations of nondeterministic programming by addressing the key challenges of \emph{modularity} and \emph{extensibility}. To better convey this point, we first explore a \emph{naive} design based on well-known techniques and showcase its limitations.

\subsubsection{An initial design attempt}\label{sec:initial-design}

A \emph{strategy} is a nondeterministic program that can be reified into a (possibly infinite) search tree. Let us consider the following initial definition for such a tree:

\begin{ccodebox}
\begin{lstlisting}[style=haskell]
data Tree a = Success a | Failure | forall b. Branch (Query b) (b -> Tree a)
data Query b = Query { prompt :: String, parseAnswer :: String -> Maybe b }
\end{lstlisting}
\end{ccodebox}

\noindent In this definition, \code{Tree a} is the type of a tree producing values of type \code{a}. Such a tree can be either a \emph{success leaf} that contains a value of type \code{a}, a \emph{failure leaf} that represents a dead-end, or a \emph{branching node} that contains a \emph{query} and one \emph{sub-tree} for every possible answer to this query. A \emph{query} represents a question being asked to an external oracle and it is defined by a prompt along with an answer-parsing function. The type \code{Query b} denotes a query with answers of type \code{b}. Note that \code{b} is existentially\footnote{Perhaps surprisingly, existential types are introduced in Haskell using the \texttt{forall} keyword. This is because any constructor type $(\exists \alpha \, T(\alpha)) \rightarrow \tau$ is isomorphic to $\forall \alpha \, (T(\alpha) \rightarrow \tau)$.} quantified in the definition of a branching node.


Strategy trees can be equipped with a monadic structure, allowing us to define them as nondeterministic programs using Haskell's \emph{do}-notation, without an explicit reification step:

\begin{codebox}
\begin{ccol}
\begin{lstlisting}[style=haskell]
instance Monad Tree where
  return = Success
  Success a >>= f = f a
  Failure >>= f = Failure
  Branch q k >>= f =
    Branch q (\b -> k b >>= f)
\end{lstlisting}
\end{ccol}
\qquad
\begin{ccol}
\begin{lstlisting}[style=haskell]
type Strategy = Tree

branch :: Query b -> Strategy b
branch q = Branch q Success
ensure :: Bool -> Strategy ()
ensure b = if b then return () else Failure
\end{lstlisting}
\end{ccol}
\end{codebox}

\noindent For example, here is a minimal strategy for \emph{program synthesis} expressed in this language:

\begin{codebox}
\begin{ccol}
\begin{lstlisting}[style=haskell]
generateProg :: Spec -> Strategy Prog
generateProg spec = do
  prog <- branch (conjectureProg spec)
  proof <- branch (generateProof spec prog)
  ensure (checkProof spec prog proof)
  return prog
\end{lstlisting}
\end{ccol}
\qquad
\begin{ccol}
\begin{lstlisting}[style=haskell]
conjectureProg
  :: Spec -> Query Prog
generateProof
  :: Spec -> Prog -> Query Proof
checkProof
  :: Spec -> Prog -> Proof -> Bool
\end{lstlisting}
\end{ccol}
\end{codebox}

\noindent A strategy tree can be navigated using an arbitrary \emph{policy} that combines an oracle along with a search algorithm. For example, \emph{depth-first search} can be defined as follows\footnote{The \texttt{MaybeT} monad transformer adds failure capability to a monad. It implements the \texttt{MonadPlus} type class. In particular, \texttt{mzero} denotes a failure and \texttt{msum} returns the first successful value out of a list of alternatives.}:

\begin{ccodebox}
\begin{lstlisting}[style=haskell]
dfs :: (String -> IO [String]) -> Strategy a -> MaybeT IO a
dfs _ (Success x) = return x
dfs _ Failure = mzero
dfs oracle (Branch (Query prompt parse) k) = do
  answers <- lift (oracle prompt)
  msum (map (dfs oracle . k) (mapMaybe parse answers))
\end{lstlisting}
\end{ccodebox}

\noindent Here, the \code{dfs} function takes as its first argument an \emph{oracle} in the form of a function that maps a prompt to a list of possible answers. Such an oracle can be implemented by sampling multiple answers from a large language model. Other search policies such as \emph{breadth-first search} can be defined as easily. Importantly, \emph{nondeterministic programming} allows separating the definition of a search space from the definition of the algorithms and oracles used to explore it.


This initial account of a \emph{strategy language} has the advantage of simplicity. However, it is sorely limited in terms of \emph{extensibility} and \emph{modularity}.

\paragraph{Lack of extensibility} The \emph{strategy tree} abstraction defined above is not compatible with more advanced search algorithms that leverage additional information or structure in the search space. For example, \emph{Monte-Carlo Tree Search} requires information about \emph{action priors} and \emph{values} to improve search efficiency. Also, many {proof search} algorithms leverage the fact that a proof state can often be decomposed into a collection of \emph{subgoals}, which can be processed concurrently. In general, it is impossible to define a single, fixed tree abstraction that can accommodate all existing search algorithms. Thus, we aim for an \emph{extensible} design, where new types of nodes can be easily defined.


\paragraph{Lack of modularity} The \emph{strategy} abstraction defined above is \emph{not} \emph{modular}. Indeed, modularity requires every query to be \emph{transparently} replaceable by a call to a dedicated strategy. In general, a powerful workflow for designing strategies consists in starting with very broad queries and then
\input{figures/refinement-diff}%
iteratively \emph{refining} them {when} and {where} more control is needed. It might appear that our naive design proposal allows this. For example, in the \code{generateProg} example above, a candidate program is conjectured in one go by issuing a single query. We can update \code{conjectureProg} to use a dedicated strategy instead, as shown in Figure~\ref{fig:refine-write-program}.
Doing so is akin to {inlining} the tree associated with \code{conjectureProg} into the tree associated with \code{generateProg}. However, such inlining is hardly transparent and deeply alters the shape of the outer tree, typically mandating changes to every search policy. For example, assuming a version of \code{dfs} with an additional \code{maxDepth} parameter, performing such inlining would likely require altering the \code{maxDepth} setting. Moreover, a single search algorithm may not necessarily be best adapted to both \code{generateProg} and \code{conjectureProg}: these two strategies should be allowed to independently produce different types of trees and leverage different policies.

Our proposed strategy language allows composing heterogeneous strategies. We present it in two stages. First, we illustrate its usage by expanding on the example from Figures~\ref{fig:strategy-overview}~and~\ref{fig:policy-overview} (Section~\ref{sec:ext-comp-strategy-lang}). Then, we transition to a formal specification, providing a rigorous definition of the modular and extensible tree data structure that strategies reify into (Section~\ref{sec:ext-comp-trees}).


\subsubsection{A Modular and Extensible Strategy Language}\label{sec:ext-comp-strategy-lang}


The \code{generateProg} strategy shown in Figure~\ref{fig:strategy-overview} has type \haskellCode{Strategy '[Branch, Fail, Value] GPIP Prog}. The last type argument indicates its \emph{return type}, which is the type of values attached to the success leaves of the induced tree. The first argument indicates its \emph{signature}, which is the list of effects that it is allowed to invoke. Finally, the second argument indicates its \emph{associated inner policy type}. Every strategy must be associated an inner policy type, which reflects its modular structure and defines the shape of compatible \emph{inner policies}. Inner policies recursively specify prompting policies and search policies for all inner queries and strategies. The inner policy type for \code{generateProg} is named \code{GPIP} and is defined in Figure~\ref{fig:policy-overview}. It is a record type with field \code{cp} for the search policy and inner policy associated with inner strategy \code{conjectureProg}, \code{ep} for the prompting policy associated with inner query \code{EvalProg}, and \code{pp} for the prompting policy associated with inner query \code{ProveProg}. The \code{branch} and \code{value} operators take \emph{opaque search spaces} as arguments. An \emph{opaque search space} can be seen as a map from an inner policy to a search stream. It can be defined from either a query or a strategy, although this implementation detail is deliberately kept hidden from search strategies for the sake of modularity. Opaque search spaces can be created using the \code{query} and \code{search} functions, whose types are summarized and explained in Figure~\ref{fig:branch-query-search}.

\input{figures/branch-query-search.tex}
\input{figures/effect-examples-short.tex}


Our strategy language is extensible and new effects can be added easily, by defining new kinds of tree nodes along with functions that spawn them. The full definition for the \code{Branch} effect fits within a handful of lines and is shown in Appendix~\ref{ap:additional-defs} (Figure~\ref{fig:branch-def}). We show examples of other effects in Figure~\ref{fig:effect-examples-short}, which we reuse to illustrate our formal definition of a \emph{search tree} in Section~\ref{sec:ext-comp-trees}. In particular, Figure~\ref{fig:compare-and-branch-effect} introduces the \code{compareAndBranch} effect. This effect is similar to \code{branch}, except that it also expects as an additional argument a parametric query or strategy for deduplicating and ranking any list of branching candidates (by mapping it to a probability distribution). Such additional information can be leveraged by some search policies for reducing search redundancy and prioritizing promising branches. In our example from Figure~\ref{fig:strategy-overview}, this would avoid potentially branching on conjectured programs that are essentially equivalent, which cannot be achieved using the \code{value} effect alone. Finally, Figure~\ref{fig:join-effect} introduces the \code{join} effect, which takes as an argument a strategy generating a value of type \code{a} and a strategy generating a value of type \code{b} and returns a strategy returning a value of type \code{(a, b)}. This effect can be used to explicitly expose parallelism in a strategy (the trees associated with both arguments can be explored concurrently) or to model \emph{independent subgoals} in theorem proving applications. In contrast with other effects introduced so far that manipulate opaque spaces, \code{join} expects as arguments strategies with the same signature and associated inner policy type as the surrounding strategy. Indeed, \code{join} is non-modular by design. It is not meant to hide the nature of its arguments by exposing them to the surrounding policy as abstract search streams. Rather, it explicitly exposes them as nested strategy trees, allowing the policy to leverage this additional structure. Beyond implementing parallel policies, this allows in particular to implement MCTS variations that leverage the structure of the \emph{conjunction-disjunction} trees that are typical in automated theorem proving~\cite{lample2022hypertree,whalen2016holophrasm,renshaw2011distributed}.


\subsubsection{Strategy Trees}\label{sec:ext-comp-trees}


\input{figures/example-tree.tex}

A strategy induces a search space in the form of a \emph{strategy tree}. A tree consists of either a \emph{success leaf} that carries a value or in a \emph{node} associated with some \emph{effect}. The list of effects allowed inside a tree constitutes its \emph{signature}. Each node features an \emph{action type} along with a family of \emph{children trees} indexed over this type. Actions cannot be built directly but only \emph{assembled} by combining elements belonging to some \emph{nested spaces} attached to the node. A space is either associated a \emph{query} or another \emph{tree}, possibly with a different signature. For example, both \code{Branch} and \code{CompareAndBranch} nodes feature a space named \code{cands} for branching candidates. In addition, \code{CompareAndBranch} nodes feature a \emph{parametric} space named \code{compare}, that is, a family of spaces indexed over sequences of elements from \code{cands}. Figure~\ref{fig:tree-example} depicts an example of a strategy tree. Because actions must always be assembled from elements of nested spaces, any node in a tree can be referenced by an object that recursively records the sequence of query answers leading to it. For example, the unique success node shown for the top-level tree in Figure~\ref{fig:tree-example} ({not} considering nested trees) has reference $\refpath{\refpath{2, 5}, 9}$, which is a shortcut for $\refpath{\refcname{cands}\refspelt{\refcname{cands} \refspelt{2}, \refcname{cands} \refspelt{5}}, \refcname{cands} \refspelt{9}}$ and recursively encodes a sequence of two actions. In this expression, numbers are identifiers pointing to query answers, which for now can be seen as simple strings. This ability to easily reference any node or query in a tree is crucial for building proper tooling around oracular programs, as we discuss shortly. References also play a key role in the \emph{demonstration language} and are defined precisely in Section~\ref{sec:references}.


\input{figures/tree-def-listing.tex}


\paragraph{A Formal Definition for Trees} The formal type definition for a \emph{strategy tree} is provided in Figure~\ref{fig:tree-def}. In type \code{Tree s p n v}, parameter \code{s} corresponds to the tree's {signature}, parameter \code{p} corresponds to the associated inner policy type and parameter \code{v} corresponds to the type of value being produced at success leaves. Parameter \code{n} is a phantom type that uniquely identifies the node within which the tree is nested. In the example from Figure~\ref{fig:tree-example}, all six nodes within the nested tree on the right-hand side share the same value for \code{n}, which identifies the first branching node of the top-level tree. For nodes of the top-level tree, \code{n} refers to a virtual node that we call \emph{global origin}. A tree is either a success leaf (Line~\ref{line:success}) or another node (Line~\ref{line:some-node}). In both cases, a reference is provided, allowing the node to be recomputed from the global origin. Success leaves are attached a \emph{tracked value} of type \code{Tracked n v}, which packs a value with a reference. Phantom type \code{n} ensures that the resulting value can be used to form actions at node \code{n} but \emph{not} anywhere else. A non-success node carries an element of type \code{Node e p t n' k}, where \code{e} is an effect belonging to \code{s}, \code{n'} is a fresh, existentially-quantified type identifying this node, \haskellCode{k := Tree s p n v} ensures that children trees share their parent's type and \haskellCode{t := Tree s p} is relevant in defining nodes such as \code{Join} and explained later. A node introduces an existentially-quantified action type \code{a} and exposes an \emph{effect} of type \code{e p t n a}, along with a \code{child} function. The \code{child} function takes an argument of type \code{Tracked n' a}, ensuring that actions can only be assembled from elements of local nested spaces. Indeed, as can be seen in Figure~\ref{fig:refs-def}, values of this type cannot be constructed directly but only assembled from other tracked values using the \code{trackPair} and \code{trackList} functions. Strategies can be reified into trees via the \code{reify} function, whose type is shown on Line~\ref{line:make-tree}. We implement reification by defining  \code{Strategy s p} as a free monad and using standard techniques~\cite{swierstra2008data}.

\input{figures/eff-space-def-listing.tex}
\input{figures/refs-def-listing.tex}

\paragraph{Effects and Nested Spaces} As defined in Figure~\ref{fig:eff-space-def}, an \emph{effect} type \code{e} is a type constructor with parameters \code{p} (the {inner policy type} associated with the surrounding tree), \code{t} (the type of \emph{embedded trees}, to be explained later), \code{n} (the phantom type identifying the current node), and \code{a} (the action type for the current node), whose member functions are mostly relevant to the {demonstration language} (Section~\ref{sec:demo-lang}) and that we explain as the need for them arises. In particular, the \code{spaces} function returns a list of \emph{parametric nested spaces}. Nested spaces can be parametric in an assembly of local tracked values (e.g. \code{CompareAndBranch}). Nonparametric spaces are implicitly parametric in the unit type. Note that the \code{spaces} function is useful for manipulating \emph{generic} trees with \emph{unknown} or \emph{arbitrary} effects. Its output features runtime type annotations that can be used for performing safe casting and runtime type checks, hence the \code{Typeable} instances. These features are useful for implementing an interpreter for the demonstration language (Section~\ref{sec:demo-lang}), which is more dynamic in nature. However, specific policies such as \code{dfs} can access nested spaces directly via the fields of specific effects, thereby benefitting from strong static typing.


A \emph{space} (Lines~\ref{line:space:start}-\ref{line:space:end}) must specify a \emph{source}, which is either a \emph{tree} or a \emph{query} (Lines~\ref{line:space-source:start}-\ref{line:space-source:end}, Figure~\ref{fig:tree-example}). There are two kinds of spaces, corresponding to the two instances of the \code{Space} type class. The \code{Branch} and \code{CompareAndBranch} effects involve \emph{opaque spaces}. An opaque space with type \code{OpaqueSpace p n v} can be created by pairing a query or a strategy with a function that, given an inner policy of type \code{p} as an additional argument, returns a lazy stream of {tracked values} (see Section~\ref{sec:policy-lang} for details on the {search stream protocol}). We call such a space \emph{opaque} because the search algorithm navigating the surrounding tree is unaware of whether the space is induced by a query or a tree, and of the signature of this tree in the latter case. Instead, the search algorithm directly uses the resulting stream of tracked values, as in the \code{dfs} example from Figure~\ref{fig:strategy-overview}. \emph{Embedded trees} form another kind of space. An embedded tree is a nested tree that shares the same signature and policy type as its surrounding tree. In contrast with opaque spaces, these nested trees must be handled by the search policy of the surrounding tree. The \haskellCode{t} parameter of effect types refers to the partially instantiated type of the surrounding tree (\code{Tree s p}), allowing the definition of effects that involve embedded trees such as \code{Join} (Figure~\ref{fig:join-effect}).



\subsubsection{References and Tracked Values}\label{sec:references} We provide formal type definitions for \emph{references} and \emph{tracked values} in Figure~\ref{fig:refs-def}. References play a key role in defining the concept of a \emph{trace}, which is central to our proposed \emph{demonstration language} (Section~\ref{sec:demo-lang}). Any element of the search space defined by a tree can be recomputed from its reference, using the \code{successValue} function (Line~\ref{line:success-value}). A \emph{node reference} (Line~\ref{line:node-ref}) consists in a list of \emph{value references} that denotes a sequence of actions to follow from the root. A \emph{value reference} (Line~\ref{line:value-ref}) is an \emph{assembly} (Line~\ref{line:assembly}) of local \emph{space element references}. A \emph{space element reference} (Line~\ref{line:space:start}-\ref{line:space:end}) denotes an element to a local parametric space and is defined by a \emph{space name}, a \emph{value reference} for the space parameter, an \emph{answer} in the case of a query, and a reference to a success node in the case of a nested tree. A \emph{tracked value} (Line~\ref{line:tracked}) pairs a value with a reference whose accuracy is guaranteed by the type system. Thus, tracked values cannot be built directly but only obtained from evaluating query answers, decomposing success nodes, and combining existing tracked values using functions such as \code{trackPair} and \code{trackList} (Lines~\ref{line:tracked-combine:start}-\ref{line:tracked-combine:end}).





\subsubsection{Queries}\label{sec:queries}

\input{figures/query-def-listing-full-width.tex}

A \emph{query} is an object that represents a question being asked to an oracle. Queries can be classified according to their \emph{type}. A \emph{query type} is defined as an arbitrary Haskell datatype that implements the \code{Query} type class defined in Figure~\ref{fig:query-typeclass}. This definition differs slightly from the simpler version that is used implicitly in the Overview section (Figures~\ref{fig:strategy-overview}~and~\ref{fig:policy-overview}) for simplicity. Each query type is associated with two prompting functions: a \emph{system} prompting function and an \emph{instance}  prompting function. A \emph{system prompt} describes the general task associated with a query type, while an \emph{instance prompt} describes a specific instance of this task. A system prompt usually does \emph{not} depend on the content of a particular query but only on its type.\footnote{Still, customizing the system prompt for specific instances in order to emphasize or add specific information can sometimes be useful and so our framework allows such a dependency.} Both system and
instance prompts can be parameterized by a value of the associated \emph{parameter type} (\code{PromptParam q}), allowing them
\input{figures/full-prompt-example.tex}%
to be tuned offline via policy parameters or at runtime via search. Our Delphyne implementation allows using dedicated templating languages such as Jinja~\cite{jinja} to write prompting functions. Each query type must also define a sequence of \emph{answer modes}, each of which is described by a name along with a parser that converts a textual oracle answer into a value of the associated \emph{answer type} (\code{QResult q}). There are several reasons for allowing multiple answer modes. The first reason is the same as for allowing prompting functions to be parameterized: different LLM oracles may require subtly different answer formats and this choice should be amenable to tuning, both offline and at runtime. The second reason is that having several answer modes allows the use of \emph{heterogeneous examples}. Indeed, writing examples that demonstrate the full chain of reasoning expected from oracles can be time-consuming and it is sometimes useful to mix such detailed examples with shorter, more streamlined ones. Also, negative examples can be implemented via dedicated answer modes. Figure~\ref{fig:full-prompt} shows an example of a \emph{few-shot} prompt that supports both \emph{short} and \emph{negative} examples.





\subsection{The Policy Language}\label{sec:policy-lang}

An oracular program is defined by three components: a \emph{strategy}, a \emph{policy} and a set of \emph{demonstrations}. The previous section explored the first component, defining a language for expressing high-level problem-solving strategies as nondeterministic programs that can be reified into search trees. We now focus on the definition of \emph{policies} that navigate such trees with the assistance of LLM oracles.

\subsubsection{The Search Stream Protocol}\label{sec:search-stream}

Modularity requires a shared protocol that allows heterogeneous search algorithms to cooperate. For example, in our example from Figure~\ref{fig:strategy-overview}, the \code{generateProg} strategy leverages another strategy \code{conjectureProg} to produce program candidates. Both strategies can invoke different effects and be associated independent policies. For example, the former may use \emph{best-first search} while the latter may use \emph{depth-first search}.

\input{figures/search-streams-def-listing.tex}

As a first approximation, a \emph{search policy} (e.g. \code{dfs} from Figure~\ref{fig:policy-overview}) maps a search tree to a {lazy stream} of tracked values. Thus, an outer policy can generate elements of an opaque nested space \emph{on demand}. However, it is typically undesirable for an outer policy to yield full control to an inner one until the latter successfully generates an element, which may never happen. Thus, finer-grained control is required. Policies must be allowed to make interleaved calls to inner policies and allocate a specific search budget every time a new attempt is made to generate an element of a nested space.

Our proposed solution is described in Figure~\ref{fig:streams}. A \emph{search stream} is a lazy sequence of \emph{search stream elements}. Each element either \emph{yields} a value (\code{Yield}), declares that a given amount of search budget was spent (\code{Spent}) or announces a minimum budget that is required for continuing search (\code{Barrier}). A \emph{budget} is a vector of nonnegative numbers, possibly infinite, with components such as: number of LLM requests, number of input tokens, number of output tokens, price in dollars... A typical call to an LLM is preceded by a \code{barrier} message indicating a cost estimate and later followed by a \code{Spent} message indicating the real incurred cost. Only then is a \code{Yield} message issued in case a valid element can be parsed from the LLM output (Figure~\ref{fig:policy-overview}). Streams can be assembled using a series of standard combinators, the most important of which are listed in Figure~\ref{fig:stream-combinators}.

\input{figures/stream-combinators.tex}

\subsubsection{Search and Prompting Policies}\label{sec:search-prompting-policies} A \emph{search policy} can now be formally defined as a function that maps a \emph{tree} to a \emph{search stream} of tracked values, as we do in Figure~\ref{fig:streams} (Line~\ref{line:search-policy}). Similarly, a \emph{prompting policy} maps a \emph{query} to a search stream of tracked values. In both cases, the search stream can be defined within a monadic context (Line~\ref{line:exec-monad}) that allows calls to external LLM oracles (hence \code{IO}), supports \emph{tracing} (\code{WriterT Trace}, see Section~\ref{sec:tracing}), and provides access to the inner policy, along with a set of \emph{demonstrations} to be used as a source of examples (\code{ReaderT (p, [Demonstration])}).  %

We can now define the \code{dfs} search policy introduced in Figure~\ref{fig:policy-overview}. The \code{dfs} function is defined inductively on the structure of a strategy tree whose non-success nodes can have type
\code{Branch} and \code{Fail}. As defined in Figure~\ref{fig:tree-def}, the \code{S} and \code{Z} constructors are used to encode the position of different
\input{figures/dfs-def.tex}%
effects in the \code{[Branch, Fail]} list, allowing us to represent extensible sum types in Haskell. Our Python implementation uses \emph{union types} instead, allowing for a more ergonomic representation.
Encountering a success node yields an element, encountering a failure node yields no element, while encountering a branching node leads to lazily exploring the \code{cands} space while recursively calling \code{dfs} on each generated element, which we do via the \code{streamBind} combinator (Figure~\ref{fig:stream-combinators}).


\subsubsection{Assembling Policies}


Although our framework allows writing search and prompting policies from scratch, it is more convenient to assemble them by instantiating and combining standard building blocks: LLM querying, RAG-based example selection~\cite{gao2023retrieval}, depth-first search, breadth-first search,
\input{figures/elim-join-listing.tex}%
MCTS~\cite{browne2012survey}, budget limits, majority voting~\cite{sahoo2024systematic}...
Building blocks of particular interest are \emph{tree transformers}, which can alter a tree signature so that it can be used with a specific policy. For example, a strategy featuring the \code{Branch}, \code{Fail} and \code{Join} effects cannot directly be used in combination with \code{dfs}, which does not handle the \code{Join} effect. However, one can compose \code{dfs} with the standard \code{elimJoin} transformer that eliminates all \code{Join} nodes in a tree by inlining their arguments in sequence, and which can itself be defined concisely using the standard \code{bindTree} and \code{elimEffect} combinators\footnote{The \texttt{bindTree} function is the tree counterpart of the monadic bind operation defined on strategies. The \texttt{elimEffect} function creates a tree transformer that globally removes an effect type from a \emph{local} elimination rule for this effect.}.


\subsubsection{Tracing}\label{sec:tracing}
When debugging oracular programs, it is useful to remember every node and space that was encountered by the policy during search. We define a \emph{trace} as  a sequence of objects of type \code{GlobalNodeRef} or \code{GlobalSpaceRef} (Figure~\ref{fig:refs-def}). Traces can be manually created by search policies, or automatically by using tracing tree wrappers. Traces can be visualized as trees with proper tooling (Section~\ref{sec:delphyne}). In addition, future work will explore how to automatically extract demonstrations from traces so as to implement self improvement loops for oracular programs~\cite{laurent2022learning}.




\subsection{The Demonstration Language}\label{sec:demo-lang}

Although queries can sometimes be successfully answered via \emph{zero-shot} prompting, LLMs typically work better when examples of answering queries of the same type are provided (Figure~\ref{fig:full-prompt}). Therefore, such examples must be an integral part of an \emph{oracular program} and the question arises of {how} to best \emph{write} and \emph{maintain} them. A naive approach is to have a user-created database of raw query-answer pairs. However, such a collection would be hard to {read}, {write} and {maintain}. It would be hard to read because individual examples are accumulated with no context and are not grounded in concrete narratives of solving specific problems. It would be hard to write because determining {what} instances to answer for queries occurring in the middle of complex pipelines and then manually writing them down is error-prone and time-consuming. Most importantly, it would be hard to \emph{maintain} since any change to the associated strategy can break or deprecate some examples and require new ones to be written, without a clear way for users to know which ones.

This section proposes a novel language for writing and maintaining examples. In this language, related examples are bundled with unit tests in the context of coherent \emph{demonstrations}. Tests can themselves be described concisely in a dedicated sub-language. Our language is designed to support a rich editor experience, in the form of an  interactive, execution-guided writing workflow and of a linter that enforces consistency between strategies and demonstrations.

\input{figures/demo-def-listing.tex}

\subsubsection{Demonstrations} An example of a demonstration is shown in Figure~\ref{fig:demo-overview}, while a type definition is provided in Figure~\ref{fig:demo-def}. A demonstration consists in a \emph{strategy} (with all arguments instantiated), a sequence of \emph{answered queries}, and a sequence of \emph{tests}. An \emph{answered query} is a pair of a query and of a list of \emph{answers}. Each answer is tagged with an optional \emph{label}, the corresponding \emph{answer mode} (Section~\ref{sec:queries}), and a flag indicating whether or not the answer can be used as an example for few-shot prompting. Answered queries are assembled into coherent scenarios of navigating the search tree induced by the demonstration's strategy through \emph{tests}. Each test describes a path through the tree, starting at the root and ending at a particular node. In addition, tests can either succeed or fail. A demonstration can be \emph{evaluated} by running each of its tests. Doing so results in a \emph{trace} (Section~\ref{sec:tracing}), a destination node for each test, and a set of diagnostics (e.g. a test failed, an answer could not be parsed, a particular query answer is not used by any test...). This information can be displayed to users through appropriate editor support, allowing an interactive workflow for writing and repairing demonstrations (Section~\ref{sec:demo-maintenance}).




\subsubsection{A DSL for Navigation Tests}\label{sec:tests-dsl}

A test is composed of a sequence of \emph{instructions} (Figure~\ref{fig:demo-def}). Each instruction takes as an input a node in the tree (initially the root) and returns a new node. Instructions can also fail or emit warnings. Nodes can be identified by values of type \code{GlobalNodeRef} (Figure~\ref{fig:refs-def}). In the rest of this section, we describe and motivate the semantics of all instructions.

\paragraph{Walking through the tree} The most basic instruction is the \code{run} instruction. Starting at the current node, this instruction uses the demonstration's query answers to navigate the tree until a leaf node is reached or an answer is missing. Each effect type specifies how associated tree nodes must be navigated by implementing the \code{navigate} function from the \code{Effect} class (Figure~\ref{fig:eff-space-def}, Lines~\ref{line:navigate:start}-\ref{line:navigate:end}). The \code{navigate} function takes a node as an argument. For leaves, it returns \code{Nothing}. Otherwise, it returns a function that builds an answer (i.e. selects a child) given a \emph{choice function} for selecting elements from local spaces (Figure~\ref{fig:eff-space-def}, Line~\ref{line:choice-fun}). We provide examples for standard effects in Figure~\ref{fig:navigate-impl}. Navigating a \code{Branch} node consists in selecting an element from the \code{cands} space and using it as an answer. Failure nodes are leaf nodes and thus cannot be navigated. Value nodes have a unique child, which can be selected without further inspection (by picking as an answer the tracked value of unit type \code{nil}, defined in Figure~\ref{fig:refs-def}). Finally, \code{Join} nodes can be navigated by selecting elements from the \code{left} and \code{right} spaces and pairing them up to form an answer.

\input{figures/navigate-impl.tex}

Whenever \code{run} needs to select an element from a space that is defined by a query, it looks for this query in the demonstration's list of answered queries and picks the \emph{first} provided answer. When an answer cannot be found, it fails at the current node. Whenever \code{run} encounters a space defined by a tree, it recursively navigates this tree. The \code{run} command stops when a leaf is reached. It is often composed with the \code{success} command, which ensures that the current node is a success leaf. %


\paragraph{Exploring alternative paths with hints} The \code{run} function can be passed a sequence of answer labels as \emph{hints}, so as to specify alternate paths through the tree. Whenever a query is encountered, it is checked whether or not an answer is available whose label matches the first provided hint. If so, this answer is used and the hint is consumed. For example, instruction \haskellCode{run 'foo bar'} can be interpreted as: ``walk through the tree, using answer \code{foo} whenever applicable and then \code{bar}''. A warning is issued if the \code{run} command reaches a leaf node while unused hints remain. Our design allows describing paths concisely, by only specifying the few places in which they differ from a {default} path. This works very well for specifying demonstrations, which typically describe \emph{shallow} traces that are centered around a successful scenario, on top of which side-explorations are made (e.g. showing how a bad decision leads to a low value score, demonstrating how redundant candidates can be removed at a particular step...).

\paragraph{Stopping at particular nodes}
The \code{at} instruction works like \code{run}, except that it allows specifying an internal node at which the walk must stop. All nodes in a tree are associated a set of tags. The \code{at} instruction takes as an additional argument a node selector, the simplest form of which denotes a tag to match. For example, in Figure~\ref{fig:demo-overview}, instruction \haskellCode{at EvalProg 'wrong'} behaves similarly to \haskellCode{run 'wrong'}, except that it stops when encountering a node tagged with \code{EvalProg}. By default, all \emph{spaces} are tagged with the name of the associated query or strategy, and each node inherits the tags of its \emph{primary space} if it has one. Each effect is allowed to define at most one \emph{primary space}, which is the first element returned by the \code{spaces} function (Figure~\ref{fig:eff-space-def}, Line~\ref{line:spaces}) whenever \code{hasPrimarySpace} (Figure~\ref{fig:eff-space-def}, Line~\ref{line:has-primary-space}) is \emph{true}. Custom tags can be specified for spaces and nodes by implementing the \code{spaceTags} (Figure~\ref{fig:eff-space-def}, Line~\ref{line:space-tags}) and \code{nodeTags} (Figure~\ref{fig:eff-space-def}, Line~\ref{line:node-tags}) functions respectively.

Importantly, \code{at} can only stop {within} the same tree as it started in and \emph{not} inside a nested tree. In the example from Figure~\ref{fig:demo-overview}, \haskellCode{at ConjProg} will error instead of stopping at the unique node that is attached a \code{ConjProg} query (query 2). This design choice is mandated, once again, by \emph{modularity}. Indeed, individual strategies can be made responsible for setting unambiguous tags for nodes that they control but cannot be made responsible for ensuring the absence of clashing tags in \emph{other} strategies. In order to stop at the node mentioned earlier, one must use instruction \haskellCode{at conjectureProg/ConjProg} instead. The node selector that is used here refers to the first node with tag \code{ConjProg} \emph{within} the first space with tag \code{conjectureProg}. Finally, \code{at foo\#2/bar\#3} stops at the \emph{third} node with tag \code{bar}, within the \emph{second} space with tag \code{foo}.


\paragraph{Entering nested spaces} The \code{go} instruction allows entering a tree nested within the current node. For example, if the current node is a \code{CompareAndBranch} node (Figure~\ref{fig:compare-and-branch-effect}), \code{go cands} enters the tree that defines the \code{cands} space or errors if \code{cands} is defined by a query. This instruction can be shortened as \code{go}, since \code{cands} is the primary space of \code{CompareAndBranch} nodes. More interestingly, suppose that the demonstration already explores two paths within \code{cands} that reach different success leaves and thus correspond to two different branching candidates. As previously discussed, each of these paths can be described through a sequence of \emph{hints} so let us assume that the first candidate is identified by \haskellCode{''} (no hints, or default path) and the second candidate is identified by \haskellCode{'foo'} (use answer \haskellCode{'foo'} when appropriate). Then, instruction \haskellCode{go compare([cands\{''\}, cands\{'foo'\}])} can be used to enter the strategy tree comparing those two candidates. It can be shortened into \haskellCode{go compare(['', 'foo'])} since \code{cands} is a primary space. In general, any element of a local space can be referred to via a (possibly empty) sequence of hints. For spaces defined by queries, at most one hint is expected that indicates which answer to use. For spaces defined by trees, a sequence of hints is expected that leads to a success leaf by calling \code{run} recursively.

The \code{answer} instruction is similar to \code{go}. It takes a space selector as an argument but then expects to find a query instead of a tree when entering this space. It then succeeds if the corresponding query is answered in the demonstration and fails otherwise.


\subsubsection{Writing and Maintaining Demonstrations}\label{sec:demo-maintenance}
Demonstrations can be written interactively. A typical workflow is to start with an empty \code{queries} section and a single \code{run | success} test. Evaluating the demonstration results in the test getting \emph{stuck} at a given node. Proper editor support allows visualizing this node, along with the attached unanswered query, which can then be added to the demonstration body with a single click (Section~\ref{sec:delphyne}). An answer can then be written manually, or generated by an LLM and then edited, after which the demonstration can be evaluated again. In addition, running an oracular program results in a trace (Section~\ref{sec:tracing}). Any path within this trace can be automatically extracted as a new demonstration or merged into an existing one.

By design, many changes to an oracular program are guaranteed not to break demonstrations: changing a policy, modifying a prompt, adding a new demonstration, appending new answers at the end of an existing one... Even significant strategy changes are frequently guaranteed to preserve demonstrations. For example, adding a call to \code{value} in a strategy cannot cause a previously passing test to fail.\footnote{This is assuming that the new node does not introduce a tag that conflicts with another tag from the strategy.} %
The same is true when replacing an instance of \haskellCode{do \{x <- foo ; y <- bar ; cont \}} by \haskellCode{do \{ (x, y) <- join foo bar ; cont \}}. In the event that a strategy change \emph{does} break a demonstration, the breakage is clearly indicated by one or more failing tests. Moreover, for each failing test, the node at which the failure happened can be inspected, as well as the full demonstration trace. Finally, the conciseness of the test specification sub-language facilitates quick iteration.





\section{Delphyne: a Python-Based Oracular Programming Framework}\label{sec:delphyne}

We release \emph{Delphyne}, an open-source\footnote{Delphyne is available at: \url{https://github.com/jonathan-laurent/delphyne}.} framework for oracular programming based on Python.\footnote{In Greek mythology, Delphyne was the monstruous serpent, also known as \emph{Python}, that guarded the Delphi oracle.} Delphyne offers rich tooling support for writing demonstrations and inspecting traces in the form of a VSCode extension. Beyond being a popular and accessible programming language with a
\input{figures/delphyne-floating-logo.tex}%
rich ecosystem, Python has several technical properties that make it suitable for implementing an oracular programming framework. First, its \emph{reflection} capabilities allow defining new effects and enriching trees with debugging metadata with minimal boilerplate. Second, it has a low-latency interpreter that supports runtime module reloading, allowing demonstrations to be instantly re-evaluated after strategy changes are made. Third, its ecosystem integrates powerful libraries for serializing and parsing structured data (e.g. Pydantic), writing prompts as string templates (e.g. Jinja), and querying LLMs. Finally, its support for gradual typing enables a good compromise between simplicity and type-safety, both in the design of embedded strategy and policy languages and in the implementation of the demonstration interpreter.\footnote{Still, Haskell remains a superior choice for technical exposition, as its type system allows for a fully precise and rigorous definition of strategy trees (Section~\ref{sec:ext-comp-trees}).}

\input{figures/delphyne-strategy-example.tex}

\paragraph{Embedding a Strategy and Policy Language} As demonstrated in Section~\ref{sec:strategy-lang}, defining our extensible \emph{strategy tree} data structure in a statically typed language requires advanced type features such as GADTs, existential types and higher-kinded types.  Such features are not available in Python's gradual type system. However, we found that a limited and \emph{contained} use of \code{Any} allows Delphyne to offer its users most of the benefits of static typing while eschewing much complexity. Indeed, Delphyne offers fully precise typing to \emph{strategy writers}. Strategies and operators such as \code{branch} can be typed exactly, resulting in a comparable experience as in a statically typed language when using type checkers such as Pyright in strict mode. In addition, the availability of \emph{union types} in Python offers a simpler and more ergonomic way of expressing strategy signatures (Figure~\ref{fig:delphyne-strategy-example}). On the side of the policy language, atomic components (search policies, prompting policies, tree transformers, stream transformers...) can also be typed exactly, enforcing their correct use and composition. However, their \emph{implementation} typically requires gradual typing since search trees are not fully typed. For example, the \code{Branch} class (representing branching nodes) has no parameter constraining the type of value being branched on or the type of the surrounding inner policy. In addition, the constraint according to which an action can only be assembled from elements of \emph{local} spaces is only enforced at runtime. Writers of functions such as \code{dfs} must therefore be careful in ensuring that their implementation truly matches the advertised type. Overall, this is a good tradeoff since typical users are expected to spend much more effort writing strategies and assembling policy components than defining new effects and atomic policies.

Delphyne strategies are not expressed with monadic code (for which Python has poor syntactic support) but using coroutines instead (hence the use of the \code{yield from} keyword). An example is provided in Figure~\ref{fig:delphyne-strategy-example}. Since python coroutines cannot be cloned, reification is implemented via thermometer continuations~\cite{koppel2018capturing}: a tree node is identified by the sequence of actions leading to it and the strategy is replayed from scratch every time a child is computed. This can be optimized through two layers of caching, by avoiding to replay the strategy when accessing the \emph{first} child of a node and by storing all accessed nodes in a cache indexed by node references.


\input{figures/demo-screenshot.tex}

\paragraph{A Rich Editor Experience for Demonstrations.} Figure~\ref{fig:demo-screenshot} shows a screenshot of using the Delphyne VSCode extension for writing a demonstration. In addition, an integrated task manager allows running oracular programs concurrently and inspecting the associated traces \emph{as they grow}. %



\section{Related Work}\label{sec:related-work}

Many frameworks exist to simplify the development of LLM-enabled programs~\cite{liu2023prompting}. However, our framework is unique in harnessing the full power and generality of nondeterministic programming to robustly integrate prompting into modular, first-class programs. To the best of our knowledge, it is also the first to identify and address the challenge of treating few-shot examples as \emph{maintainable} program components. Finally, while existing frameworks offer a restricted set of search primitives, such as repeated trials and majority voting, our framework allows writing and composing arbitrary, \emph{modular} policies. While this level of power and generality may not be necessary for all applications, we expect Delphyne to be particularly useful in scenarios where reliable external feedback enables the full exploitation of search. This is notably the case in areas such as program synthesis, program verification and theorem proving, where high-quality feedback is available through interpreters, static analyzers, model-checkers and proof assistants.

The DSPy framework allows building LLM pipelines by combining declarative modules that carry natural-language typed signatures~\cite{khattab2024dspy}. Notably, it allows automatically optimizing prompts and examples based on an objective function, drawing similarity to backpropagation-based learning frameworks such as Pytorch~\cite{paszke2019pytorch}. Future work will explore integrating such functionality into oracular programming frameworks. The LMQL language~\cite{beurer2023prompting} enables guiding LLMs by enforcing precise answer templates, making it a natural complement to our framework, which orchestrates multiple requests. Future work will integrate an LMQL-based prompting policy into Delphyne.






\section{Conclusion}

Symbolic AI methods based on logic and rules naturally complement subsymbolic methods~\cite{platzer2024intersymbolic} based on deep learning. The former are reliable and interpretable, while the latter enable harnessing commonsense knowledge from vast amounts of data. Oracular programming provides a foundation for integrating those approaches. Delphyne provides a basis for fostering new idioms for building intersymbolic AI systems. Future work will focus on large-scale case studies and developing methods to automatically evolve oracular programs through self-improvement loops~\cite{laurent2022learning}.




\bibliographystyle{ACM-Reference-Format}
\bibliography{main}


\appendix


\section{Additional Definitions}\label{ap:additional-defs}

This appendix provides additional definitions that were omitted from the main text for concision. Figure~\ref{fig:branch-def} shows the full definition of the standard \code{Branch} effect.

\begin{figure}[h]
\begin{ccodebox}
\hspace{18pt}
\begin{lstlisting}[style=haskell, numbers=left, numbersep=15pt]
data Branch :: EffectKind where
  Branch :: (Typeable a) => { cands :: OpaqueSpace p n a } -> Branch p t n a

branch :: (Branch `In` s, Typeable a) => SpaceBuilder p a -> Strategy s p a
branch cands = makeNode (\spawner -> Branch (noparam "cands" spawner cands))

instance Effect Branch where
  spaces (Branch cands) = [constSpace "cands" cands]
  hasPrimarySpace _ = True
  nodeTags _ = []
  mapEmbedded _ (Branch cands) = Branch cands
  navigate (Branch cands) = Just (\choose -> choose cands)
\end{lstlisting}
\vspace{0.15cm}
\end{ccodebox}
\vspace{-0.3cm}
\caption{Defining the \code{Branch} Effect. For simplicity, we do not allow attaching custom {node tags}. Support for those can be added by adding an argument to \code{branch} and a field to \code{Branch}.}\label{fig:branch-def}
\vspace{-0.1cm}
\end{figure}


\end{document}
