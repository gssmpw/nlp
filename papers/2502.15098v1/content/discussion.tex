\section{Discussion and Limitations} \label{sec:discussion}


\subsection{\system{}'s Scope}
\parheading{Closing the Loop.} 
We acknowledge that \system{} does not quite ``close the loop" on malware detection. The missing component is the feedback from scheduled \ra to \ta. Ideally, whenever scheduled/periodic  (i.e., not triggered by \ta) \ra{} detects malware, \ta heuristics would be adjusted based on recent traffic logs that must contain infection-relevant traffic. Otherwise, the device must have been infected via direct/physical
means. This is part of future work.

\parheading{Malware without Network Traffic}
\system cannot detect malware that sits on a device silently without generating any network traffic. 
However, if such malware is transmitted to the device through the network, then \system catches it during transmission. 
Additionally, certain types of Mirai-variant malware have the capability to remain dormant for a specific duration before becoming active to initiate a DoS attack. 
In such scenarios, the \system can detect the malware when it becomes active and starts generating network traffic.
\subsection{Attestation TCB} \label{subsec:attestationtcb}
In \system Attester is implemented by extending the operating system (OS). This increases the TCB size by including the OS in the TCB and makes it vulnerable. 
To mitigate this, a TPM~\cite{tpm} can be integrated and a secure
boot process can be configured to verify the TCB binaryâ€™s
validity. This ensures that the OS always boots in the expected
state. However, advanced attacks such as privilege escalation
and runtime control-flow attacks can still compromise the
TCB, which is out of scope for this paper.

\subsection{Compatibility with Other Attestation Techniques}
There are more secure ways of implementing attestation in IoT devices besides the OS-based Attester module. 
Notably, two options would be: (1) using off-the-shelf ARM TrustZone, or (2) using theoretical Root-of-Trusts (RoTs) such as SMART~\cite{smart} and Sancus~\cite{sancus}.

ARM TrustZone-M~\cite{ARM-TrustZone-M} provides secure isolation between normal and secure regions of memory for devices with ARM Cortex-M23/33/55 microcontroller units (MCUs). Installing the attestation TCB in the secure region prevents illegal access or modification by programs in the normal region. Further, the TCB can verify if the device is running expected user binary by accessing and measuring the normal region when an attestation request is received. We implemented such a technique on NXP LPC55S69-EVK \cite{nxpboard} board with ARM Cortex-M33. However, we could not test and evaluate the prototype due to lack of real-world malware on low-end devices. Higher-end processors such as ARM Cortex-A32/72 are equipped with TrustZone-A  ~\cite{trustzone}, Trusted Execution Environment (TEE) extensions, which can access the physical memory of normal regions, but it is difficult to implement an attestation scheme that can measure user processes. This is because the normal region's separate Memory Management Unit (MMU) virtualizes user processes for the normal OS. Creating an attestation mechanism for TrustZone-A without trusting the normal OS is a non-trivial task. For ultra-low-power MCUs like TI MSP430~\cite{msp_memory_specs} and AVR ATMega8~\cite{atmel_specs}, several RoTs~\cite{smart,sancus,vrasedp,trustlite} propose attestation techniques based on custom hardware extensions. Since \system{} only relies on Attester as a black box, it can seamlessly integrate with these RoTs without modifications.

\subsection{Physical Attacks}
There are two types of physical attacks: non-invasive and invasive. Both are considered out of the scope of this paper.

Non-invasive attacks involve physical reprogramming of device software using direct/wired interfaces, such as USB/UART, SPI, or I2C. These attacks are challenging to detect, particularly when the attestation TCB becomes compromised or when the measurement values are maliciously updated to reflect the corrupted state of the applications being attested. 
However, well-known security mechanisms, such as secure boot, can mitigate these attacks.

Invasive attacks, on the other hand, involve attempting physical damage to the device, such as inducing hardware faults, tampering with hardware components, or exploiting physical side channels to extract secrets. Protection against invasive attacks can be achieved through standard tamper-resistant techniques~\cite{ravi2004tamper}.

\subsection{Mitigation of DoS attacks}
There are several ways an adversary can launch a DoS attack on an IoT device.
Recall from Section \ref{subsec:advesarymodel} that an adversary can overwhelm an IoT device by sending a large volume of packets, or it can utilize the infected devices to flood the network with excessive traffic, affecting other devices in the same network.
These attacks can be detected when the gateway observes abnormal traffic to/from an IoT device, triggering attestation.
Subsequently, since an IoT device is unresponsive during the attack, the attestation request will be disregarded, and after a timeout, \system will raise a failure.

Next, the adversary can also trick the gateway by sending abnormal packets to an IoT device and forcing the gateway to perform attestation repeatedly. 
Repeated attestation not only consumes power but can also potentially degrade the functionality of an IoT device.
Although such attacks are out of the scope of \system,  we note that they can be mitigated by implementing rate-limiting to perform attestation only a fixed number of times within a certain interval.

Furthermore, if the adversary has prior knowledge of the IoT device profile, it can launch a DoS attack by sending a burst of packets that conform to the profile.
For instance, the adversary can construct malicious packets with the same packet length and forged source address to match one of the profile entries.
In such cases, Monitor would allow the traffic to pass, resulting in a successful attack.  
Such attacks are also out-of-scope.
Note that detecting such traffic would require stateful profile monitoring to check the timing interval between consecutive packets. 
However, implementing such monitoring is computational and storage intensive.
Considering the general IoT traffic observed in our evaluation, we believe the benefits of deploying such resource-intensive measures are not substantial enough to justify their implementation.

\subsection{Software Updates} 
There can be two different types of software updates: (1) the server's software changes resulting in different external address and/or packet lengths. However, the software state of the IoT device remains unchanged; or (2) the IoT device's software state changes.
Similar to a new command that generates benign traffic (see Section~\ref{subsec:effectiveness-feedback-loop}), software updates of the first type can be handled by the feedback loop. 
When a software update for the IoT device occurs, it triggers Monitor with a new packet. Monitor then calls Attester on the IoT device to perform attestation, which does not detect any change in the software state. Finally, this new packet is included as part of the IoT device's profile. It can also be handled manually by providing the gateway with the updated profile information. 
However, software updates of the second type cannot be incorporated automatically by \system{}. This is because when called by Monitor, Attester sees that the software state does not match the reference value. As a result, the legitimate new packet is considered malicious. To solve this problem, the server must provide the updated reference value to the IoT device and gateway in this case.

\subsection{IoT Devices in Ad Hoc Network}
IoT devices in ad hoc mode can exchange packets without going through the gateway, making it impossible for Profiler or Monitor to capture and process them. Such devices are out of the scope of \system{}. However, we assume that the owner of the IoT device is trusted. Thus, in other words, the IoT device is configured to operate in infrastructure mode that allows all packets to go through the gateway.  