\section{Background \& Related Work} \label{sec:background}
This section provides some background on targeted devices, \ra, and \ta, and on their interaction.
\subsection{Targeted Devices} \label{subsec:targeted_devices}
%
This work focuses on resource-constrained IoT devices specifically designed for sensing and actuation tasks, some of which perform safety-critical functions (e.g., fire/smoke detectors, smart locks, glass vibration alarms, and surveillance/motion cameras). They are equipped with micro-controller units (MCUs) such as ARM Cortex-M series or mid-range MCUs like ARM Cortex-A series. To support security features, some MCUs provide extended hardware features like memory protection units (MPUs) or memory management units (MMUs).

This work is applicable to a wide range of IoT devices equipped with some form of root of trust. However, very simple devices  (so-called ``bare metal'') that lack security features are considered out-of-scope.

\noindent {\bf Network Connectivity.}
IoT devices are often connected to the Internet and other peer devices, either directly or via an intermediary, 
such as a controller hub or a router. This paper focuses on devices that use routers for connectivity.
Such devices are equipped with at least one network interface, such as WiFi, Bluetooth, cellular, wired Ethernet, or Zigbee.
We focus on WiFi traffic since WiFi is the most common network interface present on consumer IoT devices~\cite{blevswifi}. 
Albeit, any other network media (wired or wireless) can be easily supported by \system.

\subsection{Remote Attestation: \ra}
%
\ra{} is a security service that enables a trusted party (\vrf) to measure current software state of an untrusted remote 
device (\prv). \ra protocol is usually realized as follows:
\begin{itemize}
    \item \vrf sends an \ra request to \prv that contains a challenge.
    \item \prv receives the request, computes a secure measurement of its current software state and sends it to \vrf.
    \item \vrf verifies the result and decides whether \prv is in a valid/healthy state.
\end{itemize}
%
The measurement is obtained by: (1) hashing (using a suitable cryptographic hash function, such as SHA-256) the software, and 
then (2) computing either a Message Authentication Code (MAC) or a digital signature over the hash digest and the challenge. 
Computing a MAC requires \prv to share a key with \vrf, while computing a signature requires \prv to have a 
private key with the corresponding public key known to \vrf. Both approaches require \prv to have some form of secure storage 
for the (shared or private) key. The measurement is typically computed 
within a Trusted Computing Base (TCB) that relies on trusted hardware and/or software, depending on the type of \ra: software-based,
hardware-based, or hybrid. 
Hardware-based \ra~\cite{tpm,sancus,kil2009remote,MQY10} relies on dedicated secure
hardware components, e.g., TPM~\cite{tpm} or Intel SGX~\cite{sgx}). 
However, such hardware is normally too costly (in multiple aspects) for most IoT devices.
Software-based \ra~\cite{KeJa03,seshadri2004swatt,ammar2020simple,grisafi2022pistis,gligor} requires no secure 
hardware features. However, it assumes an ideal environment with reliable communication even in the presence of a remote attacker, which is difficult to achieve in real world scenarios.

Hybrid \ra~\cite{smart,vrasedp,tytan,trustlite} claims security equivalent to hardware-based \ra, at a lower cost. Such methods require minimal hardware support and shift the bulk of complexity to the (trusted) software component. However, hybrid \ra still requires hardware modification and, therefore, is not readily applicable to off-the-shelf IoT devices.

For our proof of concept implementation, we use a software-based \ra{} method suitable for off-the-shelf consumer IoT devices.  
However, we expect that \system{} could be used in tandem with many \ra{} methods. Section \ref{sec:discussion} discusses the compatibility of \system with other \ra{} techniques.

\subsection{Traffic Analysis: \ta}\label{subsec:network-monitoring}
% 
In \ta, a specific software/hardware combination (device $x$) is profiled in a controlled setting to identify its traffic characteristics under normal operating conditions. These characteristics (also referred to as $x$'s traffic fingerprint or profile) are then used to identify $x$ on any network by matching live traffic patterns to $x$'s fingerprint. Network fingerprints can include bandwidth, timing of TCP connections, port numbers, IP addresses, packet sizes, protocol identifiers, directions, etc. For example, 
\cite{trimananda2020packet} develops packet-level event signatures of IoT devices using only sequence numbers and the
size and direction of TCP packets.  

Some early \ta\ techniques relied on \dpidefinition{} (\dpi{})~\cite{moore2005,ma2006}.
Surprisingly, \dpi{} also initially proved effective for smartphones~\cite{miskovic2015} and \iot{}~\cite{feng2018}, 
perhaps due to lax security practices in the early days of these technologies.
However, gradually traffic encryption became more common~\cite{razaghpanah2017,alrawi2019,huang2020}. Consequently, new fingerprinting techniques were proposed that identify individual functionality on IoT devices even
if the application-layer payload is encrypted, \eg{}~\cite{oconnor2019,trimananda2020packet,acar2020,varmarken2022fingerprintv}. 
Network fingerprinting has various useful applications such as intrusion detection, traffic prioritization, and user activity profiling. However, attackers also use it to reconnoiter a network for an effective attack.

Although they vary greatly in terms of complexity and collected traffic features, these techniques focus only on a subset 
of \iot{} traffic that uniquely identifies a specific device or a certain event occurring on it. In contrast, \system{} monitor component
operates as a whitelist. Therefore, it needs to learn the complete (normal) traffic profile of an \iot{} device, which it achieves by
blending a simple passive \ta technique (to flag suspicious patterns) with \ra (to perform infection checking), 
as described in Section \ref{sec:design}).

Another body of prior work focused on detecting malicious activity via \ta\ based on Machine Learning (ML) 
techniques.~\cite{tekiner2022lightweight,marin2019deep,nguyen2019diot,alrashdi2019ad,wozniak2020recurrent}.
These techniques tend to use numerous traffic features, resulting in heavy-weight ML models.
Typically, packets to/from \iot{} devices are captured and relevant features are extracted in order to build data samples. 
During the training phase, ML models are trained with labeled benign and malicious data samples. 
During the monitoring phase, classifiers label each data sample as either benign or suspicious. 
A related approach involves ML models trained with only benign data~\cite{meidan2018n,rey2022federated}.
In contrast, \system{} uses very few traffic features which results in a very lightweight, heuristic-based detection model.

\subsection{\ra-\ta\ Synergy}
%
One important practical aspect of \ra{} mostly avoided by prior work is: {\em exactly when to perform it?} 
Two intuitive choices are to perform \ra{} at: (1) scheduled, e.g., at fixed and/or random intervals,  
and/or (2) on-demand, e.g., before using \prv. Both approaches have pros and cons. Though easy to configure, the former 
has two disadvantages: First, it leaves potentially
long time gaps between successive \ra\ instances which allows malware to come and go in the interim and remain undetected.
Second, it is generally quite wasteful due to \ra's resource consumption on \prv. If the device performs safety-critical tasks,
performing \ra can divert it from such tasks or at least slow it down.

Meanwhile, most \ta\ techniques do not go beyond detection of suspicious activity, \ie{} they do not inspect the device to confirm that it is actually infected, though some involve suspected device quarantine. This is clearly insufficient for comprehensive IoT malware mitigation. Even quarantine represents potential over-reaction since the suspected device might in fact not be infected. The only way to make sure is to inspect the suspected device, \eg{} via \ra. 
\system{} uses lightweight \ta to flag suspicious IoT traffic patterns and triggers \ra\ for all suspected devices. 
If an \ra\ result reflects malware presence, the user (\ie{} administrator/owner) is immediately notified.
Otherwise, in case of a false positive (no malware detected based on the \ra\ result), \system{} ``learns'' 
by whitelisting the observed traffic pattern.
