\section{Design \& Implementation} \label{sec:design}
This section discusses the main components of \system{}: Profiler, Monitor, and Attester (see Figure~\ref{fig: system overview}). 

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figures/Design_Overview.pdf}
    \caption{\system overview: blue arrows represent the feedback loop between Attester and Monitor.
    }
    \label{fig: system overview}
\end{figure}

\subsection{Profiler}\label{subsec:profiler}
The first step of \system{} is building a device profile for each IoT device during the training period when each device is newly deployed and assumed to be malware-free. This task is performed by Profiler running on the gateway. All normal events of an IoT device (\eg{} turning on/off as well as brightness and color control in case of a smart bulb) are triggered manually using the corresponding controller app in the user device. User manuals and options in controller apps are consulted to develop the list of all possible events for the IoT device. This list is easy to build since \system{} targets simple to moderately complex devices such as smart bulb, smart plug, robot vacuum cleaner, camera, \etc{} Profiler can build profiles for multiple IoT devices simultaneously, and the training is performed online.

Profiler refreshes its state after every 20,000 packets to avoid stalling caused by large PCAP files due to limited RAM and processing power. It stores IoT device profiles in a database shared with Monitor, using a hash map for fast access. The MAC addresses of devices to be trained are also stored in the database and read by Profiler at the beginning of each iteration, allowing for dynamic changes in the list in each iteration.

\parheading{Device Profile.}
A device profile refers to the profile of the expected network traffic to/from the IoT device. Figure \ref{fig: profile example} shows example profiles for two commodity IoT devices: Lumiman bulb \cite{lumimanbulb}, and Sensi thermostat \cite{sensithermostat}. Each profile can be viewed as a table, where each row represents a unique group of packets called profile entry. Thus, each profile consists of a list of profile entries. Each profile entry consists of the device MAC address, external address, packet direction and length. 

External address is the IP address belonging to the entity that exchanges packets with the IoT device. It refers to either its corresponding server or user device. This is the most important feature since malware-generated packets usually have different IP addresses. This holds as long as malware does not compromise DNS and/or the routing protocol. 

Legitimate packets sent to/received from a specific external address by an IoT device usually have slight length variations.  
It is worth mentioning that \system{} can effectively detect malware packets without this feature. However, we include it because packet length provides additional information while being very lightweight.  

Packet direction reflects whether the IoT device is the source or destination of the packet, \ie{}
\begin{itemize}
    \item \textit{Server-to-Device}: sent by the server to the IoT device.
    \item \textit{Device-to-Server}: sent by the IoT device to the server.
    \item \textit{Device-to-User}: sent from the IoT device to the user device in the same network.
    \item \textit{User-to-Device}: sent from the user device to the IoT device within the same network.
\end{itemize}
Note that we choose four different values for packet direction to make profile entry more intuitive and informative for human users. Just two directions (to/from the IoT device) would suffice for \system{} to work properly. Moreover, \system{} does not require users to be in the same LAN as the IoT device. A remote user device communicates with the IoT device through the server and is treated the same as communications between the IoT device and server.

Packet direction plays an important role since suspicious packets generated by the IoT device might cause more concern than those sent to the IoT device. For example, packets sent to the IoT device may indicate malware payload being downloaded or malicious command. In contrast, packets sent from the IoT device might indicate exfiltration of sensed data or malware being sent to another IoT device. Moreover, used together, packet direction and length make the packet matching criteria stricter. Oftentimes, packets of a specific length are exchanged only in one direction and not the other.  

Other features that could be taken into account include the packet sequence, frequency, protocol, or packet volume per unit of time. We do not include them in \system{} because, as we found out, the set of three aforementioned features suffices to detect malware with high accuracy (see Section \ref{sec: Evaluation}). Furthermore, this makes the packet matching algorithm in Monitor lightweight and efficient.

Packets with the same external address, direction, and length are grouped together. This grouping is independent of packet sequencing and packets in the same group can be captured at any time during the training phase. We assume that each profile contains entries for all possible groups of packets that can be transmitted to and from the IoT device. 

\parheading{Building Profile.}
Figure~\ref{fig: system overview} shows how Profiler builds a profile. 

PyShark~\cite{pyshark} library captures and processes packets from the IoT device via its LiveCapture interface. A BPF filter, configured with the MAC address of the IoT device, filters captured traffic. 

To construct a profile entry, five fields are extracted from each packet: source IP address, destination IP address, source MAC address, destination MAC address, and packet length. Further, \system{} assumes that the IoT device is connected to the LAN defined by the gateway. Thus, either the source or destination MAC address must be the actual MAC address of the IoT device, whereas the other MAC address is the MAC address of the gateway.  

\parheading{Configuration Packets.}
Configuration packets of standard protocols, such as NTP, DHCP, DNS, MDNS, BOOTP, ARP, EAPOL, are not included in the profile. Such packets are typically transient and do not provide meaningful insight into the recurrent nature of IoT device traffic. However, \system{} considers both TCP and UDP packets for the profile. Many prior network fingerprinting mechanisms \cite{trimananda2020packet,oconnor2019homesnitch} consider only TCP packets. The fact that many modern IoT devices use UDP makes \system{} more inclusive and robust.

\parheading{Determining Direction \& External Address.}
Packets are associated with a specific IoT device using its MAC address. This way, if the IoT device changes its IP address, its profile is not affected. MAC addresses are used to determine directions and IP addresses. If the list of MAC addresses in the database contains the source MAC address of the packet, then the destination IP address is considered the external address. In that case, the direction is \textit{Device-to-Server}. On the other hand, the source IP address becomes the external address if the destination MAC address is in the list of MAC addresses and the direction is \textit{Server-to-Device}. Finally, if both source and destination IP addresses are local addresses, the direction is either \textit{Device-to-User} or \textit{User-to-Device}. 

\parheading{Mapping IP Addresses to Hostnames.}
In our experiments with numerous devices, we observed that IP addresses of servers can change frequently, leading to unstable profiles. Hostnames, on the other hand, remain unchanged or change rarely. Therefore, using hostnames as external addresses is preferable. However, this requires an IP-to-hostname mapping in \system{}, as hostnames are resolved to IP addresses through DNS packets,
and the associated IP addresses are used in subsequent communication.

\system{} builds IP-address-to-hostname mappings using DNS response packets instead of creating profile entries for captured DNS packets. It extracts hostnames from the \textit{Query} field and resolved IP addresses from the \textit{Answer} field to create a mapping from each IP address to its corresponding hostname.

%
If source/destination IP address is not a local address, \system{} tries to find the corresponding hostname from the IP-address-to-hostname mapping. If this fails, \system{} performs reverse DNS lookup using the IP address. If a hostname is returned, \system{} uses it; otherwise, it uses the IP address. 

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{figures/Short_Profile_Example.pdf}
    \caption{Partial profiles of: \textbf{(a)} Lumiman Bulb, \textbf{(b)} Sensi Thermostat (S-D=\textit{Server-to-Device}, D-S=\textit{Device-to-Server}, D-U=\textit{Device-to-User}, U-D=\textit{User-to-Device}). 
    Note: See Appendix A for full profile of Sensi Thermostat. 
    For more examples, see \cite{MADEA_dataset}.} 
    \label{fig: profile example}
\end{figure}

\parheading{Example \newexample.} 
In this example, we use profiles of Lumiman Bulb and Sensi Thermostat from Figure~\ref{fig: profile example}.

\noindent \textit{Lumiman Bulb.}
In the first profile entry, the bulb is the destination of the packet. Thus, the direction is \textit{Server-to-Device} and the source address is the external address. The source IP address is resolved to a hostname (\ie{} \textit{m2.tuyaus.com}) using IP-address-to-hostname mapping and that hostname denotes the external address. 
During the development of \system{}, the hostname \textit{m2.tuyaus.com} resolves to 21 different IP addresses, \eg{} \textit{54.212.163.173}. Interestingly, apart from Lumiman Bulb, another IoT device (\ie{} HBN plug) also exchanges packets with the same external address. Thus, these two devices are likely to be associated with the same manufacturer and talk with the same servers. The second profile entry has the same external address and length as the first entry, but the opposite direction. 
In the third profile entry, both source and destination IP addresses are local and the bulb is the source. Thus, the direction is \textit{Device-to-User} and the IP address of the user device becomes the external address. In the fourth profile entry, the external address is a hostname resolved through reverse DNS lookup (\ie{} the source IP address cannot be resolved using IP-address-to-hostname mapping) and the direction is \textit{Server-to-Device}. The original source IP address is 35.164.195.39 and the hostname implies that the server is hosted on AWS cloud. 

\noindent\textit{Sensi Thermostat.}
In the Sensi Thermostat profile in Figure \ref{fig: profile example}(b), the external address of the last profile entry is an IP address and the direction is \textit{Device-to-Server}. It means that the destination IP address cannot be resolved even through reverse DNS lookup.

\subsection{Monitor}
Monitor attempts to match each packet to/from the IoT device to some profile entry. We assume that all normal events have been reflected in the profile during the training phase. Hence, if no match is found for a packet, \system{} assumes it to be suspicious (\ie{} potentially generated by malware). Appendix B provides more insight into the differences between observed malware-generated and normal packets. One concern about this approach is that updates in either the IoT device or server can change the benign traffic pattern. Please refer to Section \ref{sec:discussion} for details about how \system{} handles updates. Any device can be added to the list of IoT devices to be monitored as Monitor runs constantly. Similar to Profiler, it refreshes its state after every 20,000 packets. 

\parheading{Matching a Packet.} 
During the monitoring phase, Monitor constructs an entry for every packet following the same approach that Profiler performs ( see Section~\ref{subsec:profiler}). Then, Monitor checks for a matching profile entry based on MAC address, external address, packet direction and length. If no exact match is found, it performs partial string matching for external address with at least 80\% similarity while ensuring the top-level domain name is the same. 
 
For instance, \textit{ec2-35-164-195-39.us-west-2.compute.amazonaws.com} will match with \textit{ec2-13-235-158-83.ap-south-1.compute.amazonaws.com} since both partially match and the top-level domain is \textit{amazonaws.com}. 80\% similarity is chosen based on empirical observation. This percentage gives a negligible number of false positive packets for hostnames found through reverse DNS lookup while keeping the level of similarity significant. We define false positive as a benign packet being detected as suspicious by \system{}. With 85\% and 90\% similarity matching, we observe more false positives. Partial string matching is considered because the external address changes slightly periodically in some IoT devices, \eg{} Ring doorbell and Blink camera. MAC address, and packet direction and length are still matched exactly. 

\parheading{Example \newexample.}
In this example, let us consider a packet captured by Monitor. The following five properties are extracted from it: 
\begin{enumerate}
    \item source MAC address: \textit{64:16:66:49:3e:cb}.
    \item destination MAC address: \textit{dc:a6:32:ce:31:63}
    \item source IP address: \textit{192.168.4.230}
    \item destination IP address: \textit{35.186.98.64}
    \item packet length: \textit{284}
\end{enumerate}

\system{} maintains a list of MAC addresses of the monitored devices in the database. It also maintains a hash map of all profile entries. Monitor observes that the list contains source MAC address. Thus, Monitor determines that the device MAC address is \textit{64:16:66:49:3e:cb} and the packet direction is \textit{Device-to-Server}. Furthermore, the destination IP address is translated to the hostname \textit{oculus9353-us1.dropcam.com} that becomes the external address. 
Monitor forms an entry as a tuple (MAC address: \textit{64:16:66:49:3e:cb}, external address: \textit{oculus9353-us1.dropcam.com}, packet direction: \textit{Device-to-Server}, packet length: \textit{284}) and finds a matching profile entry from the hashmap. 
If a matching profile entry is found for Monitor's entry, it means that such a packet has been seen by Profiler during the training phase and, thus, the packet is considered legitimate. The Monitor's entry may fail to match any profile entry because of two reasons: (1) there is no profile entry that can be matched with Monitor's entry when Monitor inspects the MAC address, external address, and packet direction; or (2) there are profile entries that can be matched with Monitor's entry when Monitor inspects MAC address, external address, and packet direction; however, the packet length in profile entry does not match the packet length in Monitor's entry.
   
We have observed that mismatched packet lengths contribute the most to FPR. However, the security impact of mismatched packet lengths is relatively low, as long as external address is matched. Thus, \system{} offers relaxed matching, in which Monitor excludes packet length when matching Monitor's entry to a profile entry.

Finally, in the case that Monitor detects a suspicious packet, \ie{} a packet whose entry does not match with any profile entry, it then calls a program called Attester to verify the state of the IoT device.  


\subsection{Attester}
Attester runs locally on the IoT device and it is responsible for attesting the software state of the IoT device when requested. It works on the assumption that the software state of the IoT device is deterministic, measurable, and unchanged unless the IoT device is infected by malware. It is to be noted that the software state can also change due to legitimate software updates. Section~\ref{sec:discussion} discusses how this case is handled by \system{}.
 
During the training phase, the software state of a healthy IoT device is measured as the \textit{reference value} that indicates that the IoT device is not compromised. During the monitoring phase Attester measures the software state when called by Monitor. Monitor's call includes a new challenge every time. The measured value is compared with the reference value locally by Attester as sending the full measurement result to Monitor can be expensive in terms of network bandwidth. 
If the values match, Attester reports an acknowledgment indicating that the IoT device is healthy. Otherwise, it reports that the IoT device has been infected by malware. In this case Attester's report includes the divergent measurement result for further analysis.
The Attester's report is always signed using the IoT device's secret key, and the signature includes the challenge so that the gateway can authenticate that the report is fresh and indeed generated by the IoT device.

In \system{} proof of concept implementation, Attester is a Python program running on a Raspberry Pi emulated smart bulb. Traditional device attestation that involves measuring the full program memory is not suitable for RPi's virtual memory which is managed by OS. We can't determine the physical addresses of processes in memory, and, thus, cannot determine which memory region to attest. Additionally, measuring the large RAM (in the scale of gigabytes) of a RPi would be slow and impractical. Therefore, Attester attests the binaries of the currently running processes on the RPi instead. 

Attester works on the assumption (backed by observation 4, see \ref{subsec:effectiveness-feedback-loop}) that the processes running on the IoT device, at any given time, are deterministic and limited in number. Hence, it is possible to maintain a list of expected processes and hash values of their corresponding binaries. If any IoT device is infected by malware, a new malware process would be running on it or the malware would embed itself in an existing process which would change the hash value of the corresponding binary file. Attester inspects this hash value change to detect malware on the IoT device. This attestation is supported by extensive experiments conducted on the emulated bulb for evaluation. Section \ref{sec: Evaluation} provides more details on these experiments.

During the training period, Attester builds a list of expected processes and corresponding hash values for the IoT device. 
When called by Monitor, Attester obtains a list of all currently running processes by calling the Linux command \texttt{ps aux | less > [output file]} which directs the output to a text file. Next, the output file is parsed to extract the PID of each process. PID is used to obtain the location of the binary file for each process. This location is in the format of \texttt{/proc/[PID]/exe}. Finally, \system{} calculates the hash value of the binary file of each process using the command \texttt{sha256sum /proc/[PID]/exe}.  

This list is then compared against the list of expected processes. If there is any new process in the current process list or an expected process with a wrong hash value, the IoT device will be considered compromised (\ie{} infected by malware) and Attester reports this to Monitor: Attester will also send the list of the new processes and/or the processes with the wrong hash values. 
Otherwise, if there is no new process and all current processes have the same hash values as calculated during training, Attester will send the attestation report back to Monitor indicating that the IoT device is healthy.

\begin{figure}
    \centering
    \includegraphics[width=\columnwidth]{figures/Cases.pdf}
    \caption{\textbf{Case 1}---Malware not detected by Attester:
    (a) the RPi smart bulb's profile, (b) packets for a new command (\ie{} status message), (c) Monitor's log, and (d) the RPi smart bulb's profile updated by Monitor. \textbf{Case 2}---Malware detected by Attester: (a) the RPi smart bulb's profile, (b) packets generated by malware, and (c) Monitor's log.}
    \label{fig: positive feedback}
\end{figure}

\subsection{Feedback Loop}\label{subsec:feedback-loop}
Monitor and Attester complement each other and create a feedback loop, which is a key contribution of \system{}.
During monitoring, if no matching profile entry is found for Monitor's entry of a particular packet, Monitor calls Attester to attest the IoT device. If Attester finds no malware (Case 1), it reports to Monitor that the IoT device is healthy and Monitor considers the triggering packet as a false positive. Next, it updates the IoT device's profile by creating a corresponding profile entry and appending it to profile to avoid future false positives prompted by similar packets. If Attester finds malware on the IoT device (Case 2), it reports to Monitor that the IoT device has been infected.  

Section~\ref{sec: Evaluation} provides an example of the feedback loop operation; Figure~\ref{fig: positive feedback} illustrates the process. Currently, Monitor logs the report message for further analysis by device owner. Ideally, Monitor would send the report directly to the owner as an alert for Case 2.