\subsection{\archytas{}}
\label{sec:chat}

\input{code/tool_code.tex}

% \subsection{Archytas}
Archytas is a toolbox for enabling LLM agents to interact with various tools in order to solve tasks more effectively, following the ReAct (Reason \& Action) paradigm ~\cite{yao2022react}. 
It is similar in functionality to existing solutions like LangChain~\cite{langchain}, but focuses on providing a streamlined interface for tools. 
By implementing ReAct, an agent can decompose a user request into smaller steps, decide which tools to invoke for each step, provide corresponding input to those tools, and iterate until the task is complete. 
This flexible interface is well-suited for both purely textual tasks and more complex operations (e.g., looking up a dataset, calling AI-based filtering routines, etc.).

\subsection{\chat{}}
The \chat{} interface integrates with \system{} with \archytas{} by exposing a series of tools that the LLM-based agent can leverage. 
Essentially, these tools 
% (shown in Table \ref{tab:agent_tools_short}) 
correspond to templated code snippets that can 1. perform fundamental \sys\ operations (e.g., registering a dataset, generating schemas, filtering records) and 2. orchestrate entire pipelines of transformations.
% without requiring the user to manually write code.
Figure~\ref{fig:toolcode} provides an example of a tool implementation.

% \input{code/agent_tools}

\begin{figure}[t]
    \centering
    \includegraphics[width=\linewidth]{figures/demo-dataset.png}
    \caption{Setting an input dataset through \chat{}}
    \label{fig:dataset_ops}
\end{figure}

The Archytas agent will read tool code as natural language, and consider its doc-string and input/output parameters in order to decide whether to use it to satisfy the user requests.
All tools adhere to a similar pattern in terms of input and output. The general docstring of a tool summarizes what each tool accomplishes and when it is appropriate to use.
The \texttt{Args} section of the docstring can be used to describe the input and output arguments expected for each tool.
Providing a few examples of usage within the docstring proved to be the most efficient solution to improve the quality of the reasoning agent.

The code of each tool is a Python function with the \verb|@tool()| annotation, and a Jinja-based templated syntax can be used to inject run-time variables.
Within the tool code, if a variable is expressed in round brackets as \texttt{\{\{variable\}\}}, the Archytas agent will fill the variable with a variable available at run-time in the Python execution environment.
When parsing a single user request, the reasoning Archytas agent can decide to chain several tool invocations if it deems it necessary to fulfill the desired request (See Section~\ref{sec:demoscenario} for an example).

% \subsection{Beaker}
% Beaker is a custom Jupyter kernel framework designed to integrate seamlessly with web applications. Rather than restricting all interactions to a classic notebook UI, Beaker permits front-end components of an application to leverage long-lived Jupyter sessions in the background.

We host our \chat{} system within a hybrid notebook-chat environment, called Beaker. 
Beaker is an implementation of computational notebooks that integrates AI capabilities into the interactive coding environment. 
Building on Project Jupyter's foundation, Beaker incorporates an AI agent that facilitates code generation and execution while maintaining awareness of the complete notebook state.
This enables context-aware coding, automated debugging, and dependency management, along with comprehensive state management that allows users to restore previous notebook states.

The combination of notebook as well as chat-based features allows users to interact with code, data, and LLM features all from one seamless interface. 
% This powerful combination means a user can, for instance, register a dataset, set a schema, filter, then convert and extract information without ever leaving a single chat or environment.

% While maintaining full compatibility with Jupyter notebook formats, Beaker supports seamless transitions between notebook-style coding and conversational interfaces. 
% Advanced users can customize agents with specific toolsets using the ReAct paradigm, allowing for adaptation to diverse use cases while preserving the familiar notebook interface paradigm.
% \subsection{\sys\ Task Abstraction}
% 
% \chunwei{I think this is a good opportunity to mention something about language-independent abstraction of \sys\ workload. This abstraction could serve as unified representation across any \sys\ language interface.}

