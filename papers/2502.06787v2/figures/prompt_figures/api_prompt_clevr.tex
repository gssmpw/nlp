\begin{figure*}[t]
\begin{psmall}
Implement a method given a docstring and method signature, using the API specification as necessary.
Current API:
{pre_defined_signatures}
{generated_signatures}

Here are some examples of how to implement a method given its docstring and signature:
<docstring>
\"\"\"
Locates objects that are on the left of the reference object.
Args:
    image (IMAGE): Image to search.
    ref_x (int): X coordinate of reference object in pixel space.
    ref_y (int): Y coordinate of reference object in pixel space.
Returns:
    points (list): list of [x, y] coordinates for objects in pixel space matching description to the left.
\"\"\"
</docstring>
<signature>def objects_left(image, ref_x, ref_y):</signature>
<implementation>
objects_left = []
all_objects = loc(image, object_prompt='objects')
for object_point in all_objects:
    x, y = object_point
    if same_object(image, ref_x, ref_y, x, y):
        continue
    if x < ref_x:
        objects_left.append(object_point)
return objects_left
</implementation>
<docstring>
\"\"\"
Gets the material of the given object.
Args:
    image (IMAGE): Image that the object is contained in.
    ref_x (int): X coordinate of reference object in pixel space.
    ref_y (int): Y coordinate of reference object in pixel space.
Returns:
    str: Material of the object.
\"\"\"
</docstring>
<signature>def object_material(image, ref_x, ref_y):</signature>
<implementation>
material = vqa(image=image, question='What material is this object?', x=ref_x, y=ref_y)
return material
</implementation>
<docstring>
\"\"\"
Checks if an object 1 is in front of object 2.
Args:
    image (IMAGE): Image that the object is contained in.
    x_1 (int): X coordinate of object 1 in pixel space.
    y_1 (int): Y coordinate of object 1 in pixel space.
    x_2 (int): X coordinate of object 2 in pixel space.
    y_2 (int): Y coordinate of object 2 in pixel space.
Returns:
    bool: True if object 1 is in front of object 2, False otherwise
\"\"\"
</docstring>
<signature>def in_front_of(image, x_1, y_1, x_2, y_2):</signature>
<implementation>
depth_1 = depth(image, x_1, y_1)
depth_2 = depth(image, x_2, y_2)
return depth_1 < depth_2
</implementation>
<docstring>
\"\"\"
Checks if object1 has the same size as object2
Args:
    image (IMAGE): Image that the object is contained in.
    x_1 (int): X coordinate of object 1 in pixel space.
    y_1 (int): Y coordinate of object 1 in pixel space.
    x_2 (int): X coordinate of object 2 in pixel space.
    y_2 (int): Y coordinate of object 2 in pixel space.
Returns:
    bool: True if object 1 has the same size as object 2, False otherwise
\"\"\"
</docstring>
<signature>def same_size(image, x_1, y_1, x_2, y_2):</signature>
<implementation>
object_1_size = vqa(image=image, question='What size is this object?', x=x_1, y=y_1)
object_2_size = vqa(image=image, question='What size is this object?', x=x_2, y=y_2)
return object_1_size == object_2_size
</implementation>

Here are some helpful tips: 
1) When you need to search over objects satisfying a condition, remember to check all the objects that satisfy the condition and don't just return the first one. 
2) You already have an initialized variable named "image" - no need to initialize it yourself! 
3) When searching for objects to compare to a reference object, make sure to remove the reference object from the retrieved objects. You can check if two objects are the same with the same_object method.
Do not define new methods here, simply solve the problem using the existing methods.
Now, given the following docstring and signature, implement the method, using the API specification as necessary. Output the implementation inside <implementation></implementation>.
Again, Output the implementation inside <implementation></implementation>.
<docstring>{docstring}</docstring>
<signature>{signature}</signature>
\end{psmall}
\caption{\textbf{Implementation Agent Prompt for \clevr.} This prompt differs from the prompt used for \ourbench as we omit examples illustrating usage of the \texttt{get\_2D\_object\_size} method. The prompt features \emph{Weak ICL} examples illustrating correct usage of the pre-defined modules, as well as \emph{Pseudo ICL} in the form of natural language instructions.}
\label{fig:implementation_prompt_clevr}
\end{figure*}