




In this section, we describe our problem statement, review SVS~\cite{shared-val-seq-23}, and present a high-level overview of $\pname$.

\subsection{Problem Statement}~\label{sec:problem-statement}
We investigate protocols for the problem of executing cross-rollup transactions (CRTs) atomically. 
In this paper, we use ``rollups'' to refer to ``zk-rollups,'' systems that use SNARKs to prove the correctness of transaction execution.


\myparagraph{Assumptions, Threat Model, and Goals}
 In this work, we consider the case of $2$ rollups, which reside on distinct L1 chains. For ease of exposition, we assume the participating rollups are operated by the same (shared) Executor. Later (see~\cref{sec:discussion}), we explain how our protocol can serve for the case of rollups with \textbf{different Executors}. 
  We adopt the standard assumption that participating L1 chains are live and safe (informally, liveness means the blockchain keeps processing transactions, and safety means that the finalized blocks are consistent cross replicas; see, e.g.,~\cite{shiFoundations2020} for formal definitions.)
 We consider a computationally bounded adversary which can corrupt the Executor in order to break atomicity of users' cross-rollup transactions; he cannot, however, tamper with user-signed transactions. We assume the Executor maintains the rollup's liveness, i.e., he is always online, processing transactions on L2 and submitting state roots on L1.~\footnote{This is a standard assumption for existing rollups, which employ stake-based incentive mechanisms and replace misbehaving Executors.} 

 The goal is to allow a user to execute a sequence of transactions spanning multiple rollups in an atomic (i.e., all-or-nothing) manner while preserving the ordering of the transactions within each rollup.
 We aim to design a \textbf{C}ross-\textbf{R}ollup \textbf{A}tomic \textbf{T}ransactions (CRAT) protocol that \textbf{(a)} is as \textbf{secure} as existing zk-rollups, \textbf{(b)} is \textbf{efficient} in terms of layer 1 transactions, \textbf{(c)} places \textbf{minimal or zero trust} on any third-party, and \textbf{(d)} is \textbf{practical} in terms of on-chain (L1) gas usage.


\myparagraph{Defining Cross-Rollup Transaction (CRT)}
For the rest of this paper, we use the term ``action'' to mean a transaction executed on a single chain. Looking ahead, without formal definition and proof, promising ideas proposed in~\cite{shared-val-seq-23} are in fact insecure. 
Pinning down a formal model and proving security for $\pname$ is a non-trivial technical challenge. 
For the purposes of this overview only, we use the following simpler notations. An \emph{action} can be represented using the format specified by Ethereum Virtual Machine (EVM)~\cite{eth-evm}, i.e., 
$a = (\addr, \cdata)$, where $\addr$ is the smart contract address and $\cdata$ contains the function identifier and arguments.
Then a cross-rollup transaction (CRT) can be viewed as an ordered sequence of actions $ \crt = [a_i]_{i \in [n]}$.






\subsection{Building Block: Trigger-Action Paradigm}~\label{sec:overview-svs}
The state-of-the-art proposal is Shared Validity Sequencing (SVS)~\cite{shared-val-seq-23} and variants (e.g., \cite{espresso-circ-24}).
SVS aims to enable an action $a_1$ on $\rol{1}$ to ``trigger'' a call to action $a_2$ on another rollup $\rol{2}$ (and vice versa and potentially recursively) in an atomic fashion.
SVS assumes that both rollups reside on the same layer 1 and share the same Validator smart contract (which limits its practicality).
To achieve atomicity, the consistency between $a_1$'s input to $a_2$ (which is stored on $\rol{1}$) and $a_2$'s execution (which takes place on $\rol{2}$) must be verified by layer 1. SVS introduced a special layer 2 smart contract to facilitate efficient consistency checks using Merkle Trees.
Specifically, on all rollups $\rol{i}$, a ``general system contract'' $\gsc_i$ is deployed and trusted by all users. $\gsc_i$ exposes two main functions: $\trig(\cdot)$ and $\act(\cdot)$~\footnote{The $\gsc$ function $\act(\cdot)$ is not to be confused with the term ``action'' which represents a blockchain transaction.}. $\gsc$ stores two merkle trees, $\ttree_i$ and $\atree_i$, whose roots we denote by $\troot{i}$ and $\aroot{i}$, respectively.

\begin{figure}
    \centering
    \includegraphics[scale=0.5]{figures/svs-gsc-diagram-2-actions-crop.pdf}
    \caption{SVS~\cite{shared-val-seq-23} trigger-action paradigm. Here ``$\mathsf{CALL}(f)$'' denotes that the (smart contract) function $f$ will be executed.}
    \label{fig:orig-svs-trigger-action}
\end{figure}

\label{svs-crt-lifecycle} 
In~\cref{fig:orig-svs-trigger-action}, we illustrate the SVS workflow assuming a user who wishes to execute action $a_1 = (\addrr{1}, \cdataa{1})$ on $\rol{1}$ and $a_2 = (\addrr{2}, \cdataa{2})$ on $\rol{2}$ atomically \footnote{For instance, the pair $(a_1,a_2)$ could be a burn-mint token transfer.}.
She first ``bundles'' $(a_1,a_2)$ by creating an \emph{augmented} action $a_1'$ that executes $a_1$ and calls $\gsc_1.\trig(\addrr{2}, \cdataa{2})$ (step 1); then she sends $a_1'$ to the Executor, who in turn executes $a_1'$ on $\rol{1}$ (step 2), causing the tuple $(\addrr{2}, \cdataa{2})$ to be inserted into $\ttree_1$ (step 3). The Executor executes $\gsc_2.\act(\addrr{2}, \cdataa{2})$ on $\rol{2}$ (step 4), and as a result the same tuple $(\addrr{2}, \cdataa{2})$ is inserted into $\atree_2$ (step 5) and $a_2$ is executed.
Now atomicity boils down to a simple consistency check of whether $\troot{1} \overset{?}{=} \aroot{2}$ and $\troot{2} \overset{?}{=} \aroot{1}$, which the L1 $\vsm{}$ can efficiently check.

To see why atomicity holds, note that the execution of $a_1'$ implies (1) $a_1$ is executed, and (2) $(\addrr{2}, \cdataa{2})$ is inserted into $\ttree_1$. Either both (1) and (2) take effect or none does. Similarly, the execution of $\gsc_2.\act(\addrr{2}, \cdataa{2})$ implies (1') $a_2$ is executed on $\rol{2}$, and (2') the same triple $(\addrr{2}, \cdataa{2})$ is inserted into $\atree_2$. $\gsc_2$ ensures that both take place or none does.
Due to the collision resistance of Merkle Trees, the atomicity check above ensures that if (2) and (2') took place, so did (1) and (1').

\subsection{Technical Challenges and Our Solutions}~\label{sec:svs-challenges-and-solutions}



\begin{figure*}
    \centering
    \includegraphics[scale=0.5]{figures/svs-attack-diagram-new-crop.pdf}
    \caption{Serializability attack on SVS~\cite{shared-val-seq-23}. A malicious Executor (shown on the right in red) can execute $a_3$ before $a_1'$, flipping the order of steps (2,3) with steps (6,7). Since $a_1'$ only modifies $\ttree_1$ and $\gsc_1.\act(a_3)$ only modifies $\atree_1$, the two $\gsc$ contracts result in the same state as in the honest execution (shown in the middle), thus passing the consistency check.}
    \label{fig:svs-serializability-attack}
\end{figure*}

Although simple and elegant, SVS~\cite{shared-val-seq-23} has two major problems and fixing them requires careful modeling and protocol design. 
First, serializability -- and by extension, atomicity -- breaks down for CRTs of \emph{length greater than $2$}, as illustrated in \cref{fig:svs-serializability-attack}.
Consider $\crt := [a_1, a_2, a_3]$ of length $3$, where $a_1$ and $a_3$ are to be executed on rollup $1$ and $a_2$ on rollup $2$. A natural attempt to do this with SVS is to create augmented actions $(a_1', a_2')$ as above: $a_2'$ is the same as $a_2$ but also triggers $a_3$, and now $a_1'$ is the same as $a_1$ but also triggers $a_2'$ (step 1 in \cref{fig:svs-serializability-attack}).
The intention is that the atomic execution starts with $a_1'$ (steps 2,3), then $a_2'$ (steps 4,5) and $a_3$ (steps 6,7). 
However, a \textit{malicious} Executor can easily mount a re-ordering attack to break atomicity; in our example, he can execute $a_3$ before $a_1'$ on rollup $1$. 
Doing so still passes the consistency check as above and the validity proof verifications because each action was honestly executed. In practice, this can be a serious attack; for example, if $a_1$ and $a_3$ contain arbitrage logic, changing their execution order can cause the user to miss the arbitrage opportunity or end up worse off. 








Second, SVS requires all rollups to share the same Executor and reside on the same chain, while many rollups do not satisfy these requirements. Moreover, the Executor is required to submit each new pair of state roots \emph{together} in the same L1 transaction, along with the extended validity proofs described above. Instead, CRAT protocols should ideally be \textit{flexible} and allow rollups to reside on \textit{distinct L1 chains}, as well as be operated by distinct, possibly distrusting Executors.
To overcome this challenge, the Two-Phase Commit (2PC) paradigm is a natural choice and indeed the one we adopt; however, due to the distinct and heterogeneous nature of the entities involved -- two VSM contracts and an untrusted Executor -- applying the 2PC framework tuns out to be highly nontrivial. 

\subsubsection{Our Solutions}
We present $\pname$, along with the careful programming model and formalism needed to tackle the major flaws not addressed by the SVS~\cite{shared-val-seq-23} architecture. 

\myparagraph{Restoring serializability}
We present our new design in two steps. 
In the first step, we fix serializability in the simpler \emph{chain CRT} programming model, in which each action is limited to trigger at most one other action. However, the chain CRT model lacks the necessary expressiveness for certain applications, such as flash loans. We concretely motivate the necessity of such higher expressiveness in~\cref{subsec:application-xfl}. In the second step, we propose a more flexible programming model and modify our serializability solution to support this model.

In more detail, 
we introduce the notion of {\em sessions}. We carefully modify $\gsc$ to track CRT instances by assigning a unique session nonce and maintaining an entry nonce and an active flag.  The source action $(a_1)$ starts a new CRT session by calling a new entry point function in $\gsc$, which increments the session and entry nonces and sets the flag. Subsequent $\act(\cdot)$ calls verify that the session nonce matches the current or next expected value, ensuring consistent use of the same nonce across actions. The VSM contract checks that the sum of the two entry nonces equals the session nonce. 




\myparagraph{Supporting DAG CRTs}
We introduce the more expressive Directed Acyclic Graph (DAG) CRT programming model. In this model, each action can trigger multiple subsequent actions, which can in turn trigger additional actions, forming a directed acyclic graph (hence the name ``DAG'').  To integrate this intended functionality within our serializability solution, we represent a DAG CRT as a sequence of actions, similar to chain CRTs, but with the key distinction that each action includes multiple sub-actions to be executed, along with the ability to trigger additional sub-actions.
To support the more expressive DAG CRTs, we modify  $\gsc.\act(\cdot)$ to accept an \emph{array} of triggered actions, instead of a single action. Further, we ensure that all trigger calls and triggered actions within the same transaction share the same nonce value, we repurpose the entrypoint function to be the global entrypoint of $a_1$, all while preserving the previous session-tracking logic.


\myparagraph{Supporting distinct L1 chains}
While the above changes restore serializability, we draw on 2-Phase Commit (2PC) protocols from the distributed computing literature~\cite{bernstein-concurrency-databases-1986} to support rollups with $\vsm{}$s on distinct L1 chains.
The key is to ensure that two VSM contracts accept new state roots in an all-or-nothing fashion. Suppose the Executor is ready to submit a pair of state digests -- one to each VSM -- which were produced by at least one CRT. \done%
In the pre-commit round, one VSM is selected as the leader; it verifies and pre-commits to the submitted state digest and transitions to a paired status; the non-leader VSM then follows the same process and pre-commits only after the leader VSM. In the commit round, the two VSMs commit to the new state digest in the same order after verifying relevant evidence from the other side.

For ease of exposition, we present $\pname$ in the chain-CRT model in \cref{sec:xevm,sec:2pc-trustless}, and present modifications to support the DAG-CRT model in~\cref{sec:dag-crt-protocol}.





\subsection{Overview of \pname}






\begin{figure}
    \centering
    \includegraphics[scale=0.35]{figures/crat-diagrams-crop.pdf}
    \caption{$\pname$ Overview}
    \label{fig:protocol-diagram}
\end{figure}

We describe the end-to-end workflow of $\pname$, illustrated in~\cref{fig:protocol-diagram}, starting from the user CRT and all the way until the pair of new state digests are accepted by the VSM contracts. The user starts by creating a single transaction which encodes her intended CRT by making the appropriate calls to $\gsc.\trig(\cdot)$, and sends her transaction to the Executor (step $1$). The Executor keeps executing received transactions off-chain (phase 1 below) and, at regular intervals, he submits transaction batches -- along with the state digest they produce -- to the VSM on L1 (phase 2 below).

\parhead{Phase 1.} The Executor executes the transaction batch off-chain following the \emph{\textbf{C}ross-EVM (XEVM)} sub-protocol of $\pname$. The off-chain execution yields a new pair of state digests, and the Executor also produces validity proofs, one per rollup. This phase corresponds to step $2$ in~\cref{fig:protocol-diagram} and addresses the first challenge outlined in~\cref{sec:svs-challenges-and-solutions}. 

\parhead{Phase 2.} The Executor drives the two VSMs to perform the \emph{2PC component} of $\pname$ (steps $3-6$ in~\cref{fig:protocol-diagram}). Each VSM can be in either ``free'' or ``paired'' status, and initially both are in free status.
During the \textit{pre-commit} round, one of the two VSMs is deterministically chosen as the leader; suppose it is $\vsm{1}$. The Executor first drives $\vsm{1}$ to pre-commit (step $3$) by submitting the new state digest, validity proof, and evidence that $\vsm{2}$ is in free status; 
$\vsm{1}$ in turn verifies the proof and the evidence, accepts the digest as temporary, and switches to paired status.
Next, the Executor drives $\vsm{2}$ to pre-commit (step $4$), and $\vsm{2}$ also switches to paired status after verifying that $\vsm{1}$ is in paired status.

During the \textit{commit} round, the Executor first drives $\vsm{1}$ to commit
(step $5$) by submitting evidence that (a) $\vsm{2}$ is in paired status
and (b) the roots of the $\gsc$ contracts match. $\vsm{1}$ in turn verifies the evidence, accepts its temporary state digest as final, and stores its ``commit'' decision under a unique identifier of this 2PC instance. Next, the Executor drives $\vsm{2}$ to commit (step $6$), and $\vsm{2}$ also accepts its temporary state digest as final after verifying that that $\vsm{1}$ has issued a ``commit'' decision.

\myparagraph{Abort case} During the second round of 2PC, $\vsm{1}$ (the leader) can also be driven to abort. After verifying relevant evidence that $\vsm{2}$ has not switched to paired status, $\vsm{1}$ stores an ``abort'' decision (under the 2PC identifier), discards its temporary state digest, and ``rolls back'' to the original state digest. Similarly to the commit case, $\vsm{2}$ will also abort (if ever pre-committed) upon verifying $\vsm{1}$'s abort decision.

\myparagraph{Incorrect Evidence} The workflow above describes an honest execution. If the Executor submits incorrect evidence to the $\vsm{}$ during pre-commit or commit, verification checks will fail, causing the $\vsm{}$ to revert the transaction. In the pre-commit round, the $\vsm{}$ would remain in free status, while in the commit round, it would remain locked in paired status until proper commit/abort evidence is provided. Allowing a $\vsm{}$ to unilaterally abort is insecure, as a malicious Executor could drive one $\vsm{}$ to commit and force the other to abort. This highlights the importance of a leader-based approach, where one $\vsm{}$ decides and the other follows, as well as the non-trivial nature of applying 2PC in this setting.


\begin{remark}[VSM Communication via Bridges]~\label{rem:bridge-assumption}
    When we say a VSM ``verifies evidence'' about the other VSM's state, we mean that it verifies a state membership proof against L1 block headers relayed by a trustless blockchain bridge, such as \cite{xiew-zkbridge-22}. We further assume that a VSM only considers bridge-relayed state digests that are final (2 epochs in Ethereum~\cite{buterin-gasper-2020}), eliminating the possibility of any reorg~\cite{eth-org-reorg}.
\end{remark}

\begin{remark}[Setup]~\label{rem:vsm-setup}
    It is crucial that each VSM be aware of its rollup's GSC contract and of the other VSM. After deployment, we assume a secure, one-time setup phase at the end of which, each VSM has hardcoded the address of its rollup's GSC contract as well as the address of the other VSM. Such setups are common practice and outside this paper's scope.
\end{remark}



\parhead{Application: Cross-Rollup Flash Loan}~\label{subsec:application-xfl}
A cross-rollup flash loan involves the following seven steps:
\noindent\textbf{1. Borrow} the desired amount from a flash loan pool (on $\rol{1}$).
\noindent\textbf{2. Burn} the amount (on $\rol{1}$).
\noindent\textbf{3. Mint} the amount (on $\rol{2}$).
\noindent\textbf{4. Arbitrage} (on $\rol{2}$). 
\noindent\textbf{5. Burn} the post-arbitrage amount (on $\rol{2}$).
\noindent\textbf{5. Mint} the post-arbitrage amount (on $\rol{1}$).
\noindent\textbf{7. Repay} the borrowed amount and retain the profit (on $\rol{1}$). Typically, a Token contract supports burn-and-mint, and a User contract contains the logic for the user’s actions (e.g., arbitrage).

We now discuss why cross-rollup flash loans highlight the need for the more expressive DAG CRT model. In the execution of action $a_1$, which includes steps 1 and 2 on $\rol{1}$, both step 3 (mint) and step 4 (arbitrage) must be triggered for execution on $\rol{2}$. In theory, steps 3 and 4 could be combined into a single action $a_2$, and having $a_1$ trigger $a_2$ would eliminate the need for multiple trigger calls. However, this approach presents a challenge in determining which contract will perform the bundling and trigger $a_2$. Specifically, step 3 relates to the Token contract, while step 4 is handled by the User contract. Consequently, the Token contract should (internally) trigger the mint operation upon burning, and the User contract should trigger the arbitrage, resulting in two trigger calls at the end of $a_2$. The Executor should then pick up both trigger calls, bundle them together, and pass them as arguments to single $\gsc.\act(\cdot)$ invocation. These practical desiderata underscore the necessity for a more flexible and expressive programming model, such as our DAG CRT model.










