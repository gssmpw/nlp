In this section, we describe the Two-Phase Commit (2PC) protocol between the two $\vsm{}$s and driven by the Executor. We omit formally specifying the Executor's role in the 2PC protocol, since it follows directly from the $\vsm{}$ specification. As such, the entire section focuses on the $\vsm{}$ specification.


The $\vsm{}$ contract consists of three main functions ($\textproc{updateDigest}$, $\textproc{commit}$, and $\textproc{abort}$), shown in \cref{alg:vsm-generic}, which serves as a generic 2PC framework between VSMs. Concrete procedures -- such as leader determination and evidence verification -- are performed by functions $\textproc{IsLocal}, \textproc{VerPreComEvd}, \textproc{VerComEvd}$, and $\textproc{VerAbEvd}$, which we describe in this section and formally specify in \cref{alg:vsm-trustless-p1} in~\cref{apdx:vsm}.

\myparagraph{Bridge abstraction}
Recall from \cref{par:background-bridges} and \cref{rem:bridge-assumption} that we assume a trustless bridge between the underlying L1 chains. In the following, the $\ovsm$ structure contains state attributes of the other $\vsm{}$, which can be verified against the bridge using attribute proofs which we denote by $\attproofs$. 

\begin{algorithm}[ht]
    \small
    \caption{Validator Smart Contract: Generic 2PC}
    \label{alg:vsm-generic}
    \begin{algorithmic}[1] %

        \Function{UpdateDigest}{$\dstt{},  \valproof, \locevd, \pcevd$}
            \State \textbf{Require} $(\pstat = \free)$
            \State \Call{VerValProof}{$\dstt{}, \valproof$}
            \If{\Call{IsLocal}{$\dstt{}, \locevd$}} \; $\dst{} \gets \dstt{}$
            \Else
                \State \Call{VerPreComEvd}{$\dstt{}, \pcevd$}
                \State $\dstemp{} \gets \dstt{}$, \; $\pstat \gets \paired$
            \EndIf
        \EndFunction
        \Function{Commit}{$\cevd$}
            \State \require $(\pstat = \paired)$
            \State \Call{VerComEvd}{$\cevd$}
            \State $\dst{} \gets \dstemp{}$, \; $\pstat \gets \free$
        \EndFunction
        \Function{Abort}{$\abevd$}
            \State \require $(\pstat = \paired)$
            \State \Call{VerAbEvd}{$\abevd$}
            \State $\pstat \gets \free$
        \EndFunction
    \end{algorithmic}
\end{algorithm}


\myparagraph{State} The $\vsm{}$'s state consists of its ID ($\vsmid{}$) and the current rollup state digest ($\dst{}$). We also assume that it knows the address and ID of the VSM that it is connected to (see \cref{rem:vsm-setup}). The $\pstat \in \{\free, \paired \}$ variable is initialized to $\free$. All remaining state variables are specified in~\cref{alg:vsm-trustless-p1}.

\myparagraph{Entrypoint} The $\textproc{updateDigest}$ function takes as input a new state digest ($\dstt{}$), a validity proof ($\valproof$), local evidence ($\locevd$), and pre-commit evidence. First, the $\vsm{}$ verifies $\valproof$ using the (assumed) existing zk-proof verification mechanism (\textproc{VerValProof} function). Next, it parses the local evidence $(\roots, \attproofs) \gets \locevd$ which is used to determine whether $\dstt{}$ is a local or non-local state digest. It parses the claimed roots of the $\gsc$ contract  $(\troot{}, \aroot{},  \troot{}', \aroot{}') \gets \roots$ and verifies $\attproofs$ to check the membership of $(\troot{}, \aroot{})$ (resp. $(\troot{}', \aroot{}')$) against $\dst{}$ (resp. $\dstt{}$). If $\troot{}' = \troot{}$ and $\aroot{}' = \aroot{}$, then $\dstt{}$ is a $\emph{local}$ digest and thus accepted immediately $(\dst{} \gets \dstt{})$. Otherwise, $\dstt{}$ is a $\emph{non-local}$ digest and the $\vsm{}$ proceeds to pre-commit. Note that $\locevd$ additionally contains the $\snonce{}'$ and $\enonce{}'$ variables of the $\gsc$ contract, which are also verified under $\dstt{}$, and stored to be used in the commit round. 

\myparagraph{Pre-commit} If the $\vsm{}$ successfully verifies the supplied pre-commit evidence ($\pcevd$), then it stores $\dstt{}$ as the temporary digest and switches to $\paired$ status.
 In the $\textproc{VerPreComEvd}$ function, the $\vsm{}$ parses the pre-commit evidence $(\ovsm, \attproofs, \dstt{O}) \gets \pcevd$, where $(\ovsm, \attproofs)$ are verified against a bridge-relayed state digest of the other L1 chain. Next, it computes the 2PC instance identifier as $\idx \gets \textproc{GetIndex}(\dst{}, \dstt{}', \ovsm.\dst{}, \dstt{O})$, where $\textproc{GetIndex}(\cdot)$ deterministically orders and hashes the four state digests, so that both VSMs compute the same $\idx$ value. The $\idx$ identifier is stored and used to determine the leader of this 2PC instance. If the $\vsm{}$ is the \textit{leader}, it checks whether $\ovsm.\pstat = \free$. If the $\vsm{}$ is \textit{not the leader}, it checks that the computed index matches the leader VSM's index and that the leader VSM is in $\paired$ status.


\myparagraph{Commit/Abort} If the $\vsm{}$ successfully verifies the supplied commit evidence ($\cevd$), then it accepts the temporary state digest as final ($\dst{} \gets \dstemp{}$) and switches to $\free$ status.
 In the $\textproc{VerComEvd}$ function, the $\vsm{}$ parses the commit evidence $(\ovsm, \attproofs) \gets \cevd$, where $\ovsm$ and $\attproofs$ are first verified similarly to the pre-commit round. Next, it fetches the current 2PC instance identifier $\idx$ and determines the leader of this 2PC instance. If the $\vsm{}$ is the \textit{leader}, it checks whether $\ovsm.\pstat = \paired$ and $\ovsm.\idx = \idx$. It also verifies that the new pair of state digests ($\dstemp{}, \dst{}$) satisfy \emph{atomicity} by checking that (1) the Merkle roots of the $\gsc$ contracts match (i.e., $\troot{}' = \ovsm.\aroot{}'$ and $\aroot{}' = \ovsm.\troot{}'$) and (2) the sum of the two entry nonces is equal to both session nonces. If so, it stores a $\commit$ decision under $\idx$. If the $\vsm{}$ is \textit{not the leader}, it follows the leader VSM's decision under $\idx$. The $\textproc{abort}$ and $\textproc{verAbEvd}$ functions are similar to the commit case; see~\cref{alg:vsm-trustless-p1} for more details.



