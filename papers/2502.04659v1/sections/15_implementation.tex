We implement $\pname$ on Ethereum networks using the Foundry toolkit~\cite{foundry-book}. We abstract away the (existing) SNARK validity proofs of zk-rollups and implement the additional logic introduced by $\pname$. We also implement our motivating application, the cross-rollup flash loan, on top of $\pname$. %

\subsection{Implementation details}

Our $\pname$ implementation~\footnote{\url{https://github.com/ikaklamanis/crate}} consists of three main components: the Executor which performs both the XEVM off-chain execution on L2 and drives the 2PC on L1 (implemented in 1,200+ lines of Python), the L2-based General System ($\gsc$) contract (implemented in 100+ lines of Solidity), and the L1-based Validator ($\vsm{}$) contract (implemented in 500+ lines of Solidity). We conducted our evaluation on a machine with 80 cores powered by an Intel(R) Xeon(R) Platinum 8380 CPU @ 2.30GHz, 125 GB of memory, and 208 GB of swap space.

\myparagraph{Rollup architecture}
We use a simple rollup architecture with two rollups. Each rollup consists of an L2 chain instantiated as a Foundry~\cite{foundry-book} EVM chain, whose state is checkpointed on an L1 chain, also instantiated as a Foundry EVM chain. We deploy a copy of the $\gsc$ contract on the L2 chain, and a copy of the $\vsm{}$ contract on the L1 chain. 

\myparagraph{Executor}
We implement the Executor in Python as a standalone entity consisting of two modules. First, the XEVM module implements the Shared Executor \cref{alg:shared-executor-xevm-chain-crt}. 
Second, the 2PC module implements the Executor's role in the 2PC protocol; it fetches the state roots of both rollups, as well as membership proofs for the $\gsc$ state, using the Ethereum RPC API~\cite{eth-rpc-api}. 
We simulate the generation of the user transaction by including it as part of the Executor implementation. The Executor also simulates the bridge between the two L1s, by relaying block headers to the two VSM contracts. 

\myparagraph{$\vsm{}$ contract}
The $\vsm{}$ contract receives new state digests and follows the 2PC protocol to commit or abort. Our implementation executes the full 2PC protocol, which includes verifying MPT membership proofs that are part of the pre-commit and commit evidence. To optimize gas efficiency, we batch membership proofs where possible. We provide and evaluate two implementations for MPT verification. In the first implementation (``CRATE-MPT''), we use a smart contract~\cite{solidity-mpt} which directly verifies membership proofs on-chain; in the second one (``CRATE-SNARK''), we use Groth16~\cite{groth-16} SNARKs  and the Circom~\cite{circom-site} framework. %

\newcommand{\token}{\mathsf{xToken}}
\newcommand{\flpool}{\mathsf{xFlashLoan}}
\newcommand{\userfl}{\mathsf{xUserFL}}

\parhead{Flash Loan Application}
We implement a flexible cross-rollup flash loan infrastructure in less than 300 lines of Solidity, carefully leveraging the more expressive DAG-CRT model of $\pname$. The implementation consists of two ``service'' contracts: the $\token$ contract, which facilitates token transfers and the \emph{cross-rollup} burn-then-mint service, and the $\flpool$ contract, which supports the \emph{cross-rollup} flash loan service.
Third, we implement the $\userfl$ contract, which is executes the user-desired actions during the cross-rollup flash loan. We deploy a copy of each of the three contracts on each rollup L2 chain.
The reader can refer to \cref{apdx:xfl} for the Solidity implementation of these contracts.



\subsection{Evaluation}

\newcommand{\batchsize}{\mathsf{batchSize}}
\newcommand{\numbatches}{\mathsf{numBatches}}

\parhead{L1 Gas Usage}

Compared to existing zk-rollups, $\pname$ introduces an extra L1 transaction for finalizing the state digest and additional overhead for verifying pre-commit and commit evidence. We measure this extra L1 gas usage and compare it to Zksync Era~\cite{zksync-era}, which finalizes an L2 batch using three L1 transactions~\cite{quarkslab-zksync-workflow}. Based on data from Etherscan~\cite{etherscan} and Zksync Explorer~\cite{zksync-explorer}, the L1 gas usage of Zksync is in the range $0.9$M -- $2.1$M gas during the period June-December 2024. Since zk-rollups already incur batch submission costs, $\pname$â€™s evaluation excludes batch size considerations.


We define a simple workflow where the Executor receives transactions, which are grouped into batches, each containing at least one CRT. For each batch, (1) the XEVM module executes all transactions on L2, producing new state digests, and (2) the 2PC module drives the 2PC protocol between the two VSMs. We run this workflow for $100$ instances of 2PC and compute the average L1 gas usage of $\pname$. Using the MPT verifier contract, the average gas usage of $\pname$ over all 2PC instances is $1.35$M gas, with approximately $840$K gas for pre-commit and $510$K gas for commit. Thus the MPT-based $\pname$ incurs a $\mathbf{0.64-1.5}\times$ increase in gas usage compared to the referenced gas usage range of Zksync Era, which we illustrate in \cref{fig:2pc-gas-usage-increase}.



\begin{figure}
    \centering
    \includegraphics[scale=0.4]{figures/l1_gas_cost_increase_plot.pdf}
    \caption{L1 gas usage increase incurred by the MPT-based (red) and SNARK-based (green) implementation of the $\pname$ 2PC protocol, compared to the observed gas usage range of a vanilla zk-rollup (Zksync). }
    \label{fig:2pc-gas-usage-increase}
\end{figure}



\parhead{Using SNARKs instead of native MPT proofs} To further reduce L1 gas usage during 2PC, we replace Merkle membership proofs with SNARK proofs. This allows us to batch the unrelated $\locevd$ and $\pcevd$ membership proofs of the pre-commit round into a single SNARK. Under this implementation, the average gas usage of $\pname$ over all 2PC instances is $670$K gas, with approximately $340$K gas for pre-commit and $330$K gas for commit. Thus the SNARK-based $\pname$ incurs a $\mathbf{0.32-0.75}\times$ increase in gas usage compared to the observed gas usage range of Zksync Era, which we also illustrate in \cref{fig:2pc-gas-usage-increase}.
We note that in practice, a zk-rollup integrating $\pname$ can further reduce gas usage by combining the existing state transition validity SNARK with $\pname$'s pre-commit SNARK into a single SNARK. 


Since our experiments above are conducted on local Foundry chains, the depth of our MPT tries is $d = 4$, which is smaller than the depth observed on Ethereum Mainnet account MPT tries ($d=11$ at the time of writing). Larger MPT depths imply larger SNARK circuits, which in turn increase proof generation time. We use the term ``single'' MPT proof to mean a proof for a single MPT trie. To prove membership of a smart contract variable against the chain's state root, we need a ``full'' MPT proof consisting of \emph{two single} MPT proofs; one for the account trie and one for the storage trie. Under this terminology, the SNARK circuit of the pre-commit round contains \emph{two full} MPT proofs (one for $\locevd$ and one for $\pcevd$); the SNARK circuit of the commit round contains \emph{one full} MPT proof (for $\cevd$).

We separately measure the SNARK generation time of a \emph{single} MPT proof for different values of $d \in [2,16]$. For $d=16$, the proof generation time is $130$ seconds (with CPU) and $60$ seconds (with GPU). We use an AWS EC2 g4dn.xlarge instance for both CPU and GPU performance benchmarks. The instance has 4 Intel Xeon Platinum 8259CL CPUs @ 3.095 GHz, 16 GB memory, and 1 NVIDIA Tesla T4 GPU core. Since $\pname$ uses $4$ single MPT proofs for the pre-commit round, we estimate that the SNARK proof generation time of the pre-commit round (for $d=16$) is $4 \times 130 = 520$ seconds (i.e., $8.7$ minutes) with CPU, and $4 \times 60 = 240$ seconds (i.e., $4$ minutes) with GPU. Similarly, the SNARK proof generation time of the commit round is estimated to be $4.4$ minutes with CPU and $2$ minutes with GPU. Note that the \emph{proof size, verification time, and L1 gas usage remain the same} regardless of the MPT depth.





\parhead{Flash Loan application}
We measure the total gas usage of a flash loan CRT across both rollups to be $550$K gas. For reference, single-chain flash loans are reported~\cite{equalizer-fl-cost} to consume $200$K gas on average. This increase is due to the overhead of the six trigger-action calls made by our cross-rollup flash loan. Regardless, our flash loan is reasonably practical, especially considering the significantly lower L2 gas costs. 
