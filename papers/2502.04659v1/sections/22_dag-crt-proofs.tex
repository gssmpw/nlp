\noindent\textbf{Notation.} We use the following terminology and notation:
\begin{itemize}[leftmargin=*]
    \item For an action $a$ and sub-action $sa$, if $sa.\desc{} \in a.\desc{}$, we say that $a$ is the \emph{parent} action of $sa$.   
    \item We use $sa.\rol{}$ to denote the rollup on which a sub-action $sa$ is to be executed, which is the same as the rollup field of the parent action.
    \item We use $sa \in a$ to mean $sa.\desc{} \in a.\desc{}$, as well as $a[j] = sa$ to mean $a.\desc{j} = sa.\desc{}$.
    \item We write $a.\desc{} \subseteq \atree$ to mean that $a.\desc{} = [sa_j.\desc{}]_{j \in [|a.\desc{}|]}$ appears as a contiguous subsequence in the array maintained by $\atree$. We use similar notation for $\descnext{}$ and $\ttree$.  
\end{itemize} 

We also use the notation ``$a.\desc{} \subseteq^* \atree$'' to mean that $a.\desc{} \subseteq \atree$ and all $a.\desc{}[j]$ -- and only them --  are inserted with the same $\anonce{}$. The same goes for ``$a.\descnext{} \subseteq^* \ttree$''.

    


\cref{claim:a-exec-iff-desc-inserted-dag} conveys the same core idea as \cref{claim:a-exec-iff-desc-inserted-chain}, but the argument becomes more intricate due to the complexity of DAG-CRTs.


\begin{claim}~\label{claim:a-exec-iff-desc-inserted-dag}
    Let $\ttree$ and $\atree$ be the trigger and action trees of $\gsc$ after the transaction batch $\batch{}$ is accepted by the $\vsm{}$ of a rollup, and let $a$ be a \emph{non-local} action. Then $a \in \batch{}$ if and only if $a.\desc{} \subseteq^* \atree$ and $a.\descnext{} \subseteq^* \ttree$.~\footnote{This statement also captures the edge cases where either $a$ is not triggering or is not action-wrapped; e.g. if $|a.\desc{}| = 0$, then trivially $a.\desc{} = [] \subseteq \atree$.}
\end{claim}

\begin{proof}[Proof of \cref{claim:a-exec-iff-desc-inserted-dag}]
     The ``only if'' direction is simple and omitted. We show the contrapositive of the ``if'' direction, i.e., we begin by assuming $a \notin \batch{}$; also assume $a.\desc{} \subseteq \atree$ (if not, we are done). Since $a \notin \batch{}$ \emph{as is}, there are two cases under which the subactions of $a$ still appear as a contiguous subsequence under $\atree$. (1) The subactions of $a$ are partitioned and each partition is part of a distinct parent action in the batch; in this case, by construction of \cref{alg:gsc-mult-triggers}, there exist two subactions belonging to different parent actions, which are inserted in $\atree$ with different $\anonce{}$ values. Thus $a.\desc{} \not \subseteq^* \atree$. (2) All subactions of $a$ are part of the same parent action in the batch (and thus share the same $\anonce{}$), but that parent action additionally includes at least one other subaction (preceding or following the subactions of $a$); in this case, the subactions of $a$ are not the \emph{only} ones to use this $\anonce{}$ value, and we again have $a.\desc{} \not \subseteq^* \atree$.
\end{proof}



\begin{lemma}~\label{lem:dag-gsc-all-or-none-exec}
    Let $\dagcrt = [a_i]_{i \in [n]}$ and $\{\rol{b}, \dst{b}, \dstt{b}, \batch{b}\}_{b \in \{1,2\}}$ be as in \cref{def:forward-atom-chain-crt}, when using the DAG-CRT $\gsc$ contract for off-chain execution. For $b \in \{1,2\}$, let $\{\ttree_b, \atree_b \}$ be the $\gsc_b$ trees under $\dst{b}$.
    Also assume 
    
    \noindent(I) $\ttree_1 = \atree_2$ and $\ttree_2 = \atree_1$.

    Then (I) is preserved under $(\dstt{1}, \dstt{2})$ if and only if there exists $d \in \{\true, \false\}$ such that $\actexec{}(\dst{b}, \dstt{b}, \batch{b}, a_i) = d$ for $b \in \{1,2\}$ where $a_i.\rol{} = \rol{b}$.
\end{lemma}

\begin{proof}[Proof of \cref{lem:dag-gsc-all-or-none-exec}]
    The ``if'' direction corresponds to the honest execution; its proof is simple and thus omitted. We prove the contrapositive of the ``only if'' direction. Assume there exists $1 \leq i \leq n-1$ and such that (without loss of generality)  $a_{i}'.\rol{} = \rol{1}$ and $a_{i + 1}'.\rol{} = \rol{2}$, and $\actexec{}(\dst{1}, \dstt{1}, \batch{1}, a_{i}') = \true  $ while $\actexec{}(\dst{2}, \dstt{2}, \batch{2}, a_{i+1}') = \false$. Since $\dagcrt$ is a DAG CRT, we know $k_i^2 = |a_i'.\descnext{} | =|a_{i+1}'.\desc{}| = k_{i+1}^1 > 0$.
    Using \cref{claim:a-exec-iff-desc-inserted-dag}, the former implies $a_{i}'.\descnext{} \subseteq^* \ttree_{1}'$ ; the latter implies $a_{i+1}'.\desc{} \not \subseteq^* \atree_{2}'$, which we break down to one of these three disjoint cases:
    \begin{itemize}
        \item Case 1: $a_{i+1}'.\desc{} \not \subseteq \atree_{2}'$. This gives us directly that $\ttree_{1}' \neq \atree_{2}'$.
        
        \item Case 2: $a_{i+1}'.\desc{} \subseteq \atree_{2}'$ and  $\exists j$ such that $a_{i+1}.\desc{}[j] \in \atree_{2}'$ with $\anonce{1}$ and $a_{i+1}.\desc{}[j+1] \in \atree_{2}'$ with $\anonce{2} \neq \anonce{1}$. Since all $a_i'.\descnext{}[j] \in \ttree_{1}'$ are inserted in $\ttree_{1}'$ with the same $\tnonce{}$, then without loss of generality $\anonce{2} \neq \tnonce{}$ and thus $\ttree_{1}' \neq \atree_{2}'$.
        
        \item Case 3: $a_{i+1}'.\desc{} \subseteq \atree_{2}'$, all $a.\desc{}[j] \in \atree_{2}'$ with the same $\anonce{}$, and there exists another subaction $sa^*.\desc{} \notin a_{i+1}'.\desc{}$ such that $sa^*.\desc{} \in \atree_{2}'$ also with $\anonce{}$. Since $a_{i}'.\descnext{} \subseteq^* \ttree_{1}'$, there cannot be any $\descnext{}$ that matches $sa^*.\desc{}$ with the same $\tnonce{} = \anonce{}$ as the subactions in $a_{i}'.\descnext{}$. Thus $\ttree_{1}' \neq \atree_{2}'$.
    \end{itemize}
    
\end{proof}

We also repurpose \cref{lem:svs-gsc-honest-or-reverse-order} and \cref{lem:chain-gsc-honest-order} and their proofs to handle DAG CRTs, but omit stating them. The only difference is that the $\desc{}$ and $\descnext{}$ fields are arrays (instead of elements) and as such they can be empty (instead of null) and form contiguous subsequences of the trigger/action trees (instead of being a member thereof).



Finally, the proof of \cref{thm:dag-crate-forward-atomicity-two-rollups} is similar to the proof of \cref{thm:chain-crate-forward-atomicity-two-rollups}; the only difference is that we rely on DAG-CRT-repurposed versions of \cref{lem:svs-gsc-honest-or-reverse-order} and \cref{lem:chain-gsc-honest-order}.
