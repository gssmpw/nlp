\subsection{Safety}
The SVS trigger-action paradigm~\cite{shared-val-seq-23} serves as a \emph{programming model} for cross-rollup transactions, in addition to providing an elegant atomicity check mechanism. In the simple example where $a_1$ triggers $a_2$, causing the Executor to execute $\act{}(a_2)$, it is as if $a_1$ \emph{passes} control to $a_2$, which in turn is not expected to return to its caller. This programming model is akin -- in spirit -- to the \emph{continuation-passing style (cps)} model~\cite{sussman-scheme-1998, appel-continuations-2007}, as well as to the widely used asynchronous event driven architecture~\cite{jansen-ibm-event-driven-2020, rah-even-driven-microservices-2022, ghaemi-pubsub-blockchain-2021}. 
We first define the simpler chain-CRT model, which is similar to the CRT abstraction in~\cite{lu-atomic-cc-interactions-24}, and then present the more involved DAG-CRT model.


\parhead{Chain CRTs}~\label{sec:chain-crt-model}
We model an \emph{action} as a $3$-tuple $a = (\desc{}, \code{}, \descnext{})$. Here, $\desc{} = (\rol{}, \addr{}, \cdata{})$ is the action's \emph{description}; $\rol{}$ is the target rollup (L2)~\footnote{We assume the $\rol{}$ identifier also determines the underlying L1.}, $\addr$ is the smart contract address, and $\cdata$ contains the function identifier and arguments.
Next, $\code{}$ is the \emph{raw code trace} of the action, i.e., it represents the actual opcode sequence executed, \emph{without} the triggering logic. Finally, $\descnext{}$ is \emph{the description of another action} to be executed, and its format is identical to $\desc{}$. Although not explicit, we assume that $a.\desc{}$ uniquely determines both $a.\code{}$ and $a.\descnext{}$; this correspondence is enforced by EVM rules.~\footnote{Similarly, $(\addr{}, \cdata{})$ determines the EVM opcodes to be executed.} We will overload notation and use $a.\rol{}$ to mean $a.\desc{}.\rol{}$. The field $a.\descnext{}$ can be $\nul$, in which case it is ignored.

\done{This model assumes the original SVS~\cite{shared-val-seq-23} trigger-action paradigm, restricted to allow each transaction to trigger only a single other action.}

\begin{remark}
    Looking ahead, $\descnext{}$ is precisely the field inserted in $\ttree$, while $\desc{}$ is the field inserted in $\atree$.  
\end{remark}


We define a \emph{chain CRT} as a sequence $\ccrt := [a_i]_{i \in [n]}$ which satisfies $a_n.\descnext{} = \nul$ and for all $1 \leq i \leq n-1$, \; $a_i.\descnext{} = a_{i+1}.\desc{} \neq \nul$. Since each action in the sequence is modeled to trigger the next action, we notice that each $a_i$ fully determines the sub-CRT $\ccrt [i\colon \! ]$. This means that the entire CRT $\ccrt$ can be represented by the single source action $a_1$, which is exactly the action the user will submit to the Executor. Even though $a_1$ is a compact representation of $\ccrt$, we still represent CRTs by the full sequence of actions to facilitate analysis. 


A transaction \emph{batch} is an ordered list of actions that the Executor submits along with the new state digest on L1. An action can be either \emph{local}, i.e., confined within the rollup, or \emph{non-local}, i.e., part of a CRT. 
We say a \emph{state digest} is \emph{local} if it has been produced by a batch consisting of only local actions. Otherwise we say the state digest is \emph{non-local}. We write $a_1 \underset{\batch{}}{\prec} a_2$ to mean that $a_1$ appears before $a_2$ within $\batch{}$.
We define the following predicate:
\begin{itemize}[leftmargin=*]
    \item $\actexec{}(\dst{}, \dstt{}, \batch{}, a) = \true$ if $a \in \batch{}$ \textbf{and} executing $\batch{}$ causes the state digest to transition from $\dst{}$ to $\dstt{}$.
\end{itemize}

We can now define the atomic execution predicate $\atomexec(\ccrt, \{\rol{j}, \dst{j}, \dstt{j}, \batch{j}\}_j)$, which covers an entire CRT instance $\ccrt := [a_i]_{i \in [n]}$ and is defined with respect to the set of rollups $\rolset = \cup_{i \in [n]} \{ a_i.\rol{} \}$ and their state digest pairs and batches.
This predicate evaluates to $\mathsf{True}$ if and only if (1) occurs or both (2a) and (2b) occur:
\begin{enumerate}[leftmargin=*]
    \item For all $j \in [|\rolset|]$ and for all $i \in [n]$ s.t. $a_i.\rol{} = \rol{j}$, $\actexec{}(\dst{j}, \dstt{j}, \batch{j}, a_i) = \false$.
    \item (a) For all $j \in [|\rolset|]$ and for all $i \in [n]$ s.t. $a_i.\rol{} = \rol{j}$,
            $\actexec{}(\dst{j}, \dstt{j}, \batch{j}, a_i) = \true$.
            
        (b) For all $j \in [|\rolset|]$ and for all $i_1, i_2 \in [n]$ s.t. $a_{i_1}.\rol{} = a_{i_2}.\rol{} = \rol{j}$ and $i_1 < i_2 $, it holds that $a_{i_1} \underset{\batch{}}{\prec} a_{i_2}$.
\end{enumerate}

\noindent We now proceed to formally define atomicity for chain CRTs.

\begin{definition}[CRT Atomicity]~\label{def:forward-atom-chain-crt}   
    Let $\ccrt := [a_i]_{i \in [n]}$ be a CRT, 
    and let $\mathcal{R} = \cup_{i \in [n]} \{ a_i.\rol{} \}$ be the set of associated rollups, for some $n \geq 2$. For each $j \in [|\mathcal{R}|]$, let $\dst{j}$ be the \emph{current} state digest of $\vsm{j}$. Also let $(\dstt{j}, \batch{j})$ be the (state digest, transaction batch) pair which is \emph{immediate next accepted} after running CRAT protocol $\protocol$. We say $\protocol$ satisfies \emph{atomicity} if 
    \begin{align*}
        \atomexec(\ccrt, \{\rol{j}, \dst{j}, \dstt{j}, \batch{j}\}_j) = \mathsf{True}.
    \end{align*}
\end{definition}




\parhead{DAG CRTs}~\label{sec:dag-crt-model}
Similar to chain CRTs, a DAG-CRT action is a tuple $a_i := (\desc{}, \code{}, \descnext{})$. Unlike chain-CRTs, $a.\desc{} = [sa_j.\desc{}]_j$ now is an array of \textbf{s}ub-\textbf{a}ction descriptions (hence ``$sa$''), $a.\code{}$ represents the concatenation of the $[sa_j.\code{}]_j$ components, and $a'.\descnext{} = [\descnext{}[k]]_k $ is an array of descriptions of triggered sub-actions. Similar to chain CRTs, $a.\desc{}$ uniquely determines both $a.\code{}$ and $a.\descnext{}$. The array $\descnext{}$ can be empty, in which case it is ignored. We define a DAG-CRT as a sequence $\dagcrt := [a_i]_{i \in [n]}$ which satisfies $|a_n.\descnext{}| = 0$ and for all $1 \leq i \leq n-1$, $a_i.\descnext{} = a_{i+1}.\desc{}$. Note the equality is between \emph{arrays}.


    

We can now repurpose all predicates from~\cref{sec:chain-crt-model} for DAG CRTs. Under the repurposed predicate $\atomexec{}(\dagcrt, \cdot)$), we can also re-purpose~\cref{def:forward-atom-chain-crt} to work for DAG CRTs. We omit re-stating these repurposed versions since the only difference is the use of $\dagcrt$ instead of $\ccrt$.


\subsection{Liveness and Efficiency}

\myparagraph{Liveness} A CRAT protocol satisfies liveness if the participating rollups maintain liveness, as discussed in \cref{sec:problem-statement}.

\myparagraph{Efficiency}
The key efficiency metric for cross-rollup transactions (CRTs) is latency, which refers to the time delay between submitting a CRT instance and its successful commitment or abortion. Measuring time complexity in this setting is challenging due to the heterogeneous nature of participating rollups and their differing finality rules. However, L1 transactions are the bottleneck, and we define a "round" as the duration of the slowest layer 1 transaction, based on the blockchain that takes the longest to finalize a transaction. CRAT protocols should preserve the constant round finality of existing rollups, and we capture this requirement in~\cref{def:efficiency}. 





\begin{definition}[Efficiency]~\label{def:efficiency}
    Let $\protocol$ be a CRAT protocol and let $\ccrt = [a_i]_{i \in [n]}$ be a chain-CRT of length $n$. We say $\protocol$ is \emph{efficient} if it completes in $O(1)$ rounds.
\end{definition}

Similarly, we can repurpose \cref{def:efficiency} for DAG CRTs by requiring that the protocol completes in $O(1)$ rounds regardless of the CRT length (number of actions) as well as the total number of sub-actions.



\done%



