\subsection{Safety}~\label{sec:safety-chain-crt}


In this section, we prove that $\pname$ satisfies atomicity per~\cref{def:forward-atom-chain-crt}. First, we prove that if the off-chain execution of the CRT does not satisfy all-or-nothing or serializability, then certain predicates about the two $\gsc$ states will not hold. Second, we prove that if at least one of the $\gsc$ state predicates does not hold, then the two $\vsm{}$s on L1 will not be able to complete the 2PC and commit to the new pair of faulty state digests. We use three helper lemmas which collectively imply the first step of our proof sketch. Note that \cref{lem:svs-gsc-all-or-none-exec} and \cref{lem:svs-gsc-honest-or-reverse-order} assume the SVS~\cite{shared-val-seq-23} $\gsc$ contract. Our modifications to the $\gsc$ contract do not affect these lemmas, so their implications directly apply to the more robust chain-CRT $\gsc$. 






 An observation that will prove useful is that if a non-local action $a$ is part of an L1-accepted batch, then the fields $a.\desc{}$ and $a.\descnext{}$ are inserted into the trigger and action trees, respectively -- besides $a.\code{}$ being executed. We capture this intuitive obesrvation in \cref{claim:a-exec-iff-desc-inserted-chain}. 
 
\begin{claim}~\label{claim:a-exec-iff-desc-inserted-chain}
    Let $\ttree$ and $\atree$ be the trigger and action trees of $\gsc$ after $\batch{}$ is accepted by the $\vsm{}$ of a rollup, and let $a$ be a \emph{non-local} action. Then $a \in \batch{}$ if and only if $a.\desc{} \in \atree$ and $a.\descnext{} \in \ttree$.~\footnote{This also captures the edge cases when $a$ is the first or last CRT action; e.g. if $a.\desc{} = \nul$, then trivially $a.\desc{} \in \atree$.}
\end{claim}

\begin{proof}
     $(a.\desc{}, a.\code{}, a.\descnext{})$ comprise the same action $a$ and are inserted/executed atomically when $a \in \batch{}$.
\end{proof}


\cref{lem:svs-gsc-all-or-none-exec} states that the SVS $\gsc$ satisfies the all-or-nothing property of atomicity.

\begin{lemma}~\label{lem:svs-gsc-all-or-none-exec}
    Let $\ccrt = [a_i]_{i \in [n]}$ and $\{\rol{b}, \dst{b}, \dstt{b}, \batch{b}\}_{b \in \{1,2\}}$ be as in~\cref{def:forward-atom-chain-crt}, when using the \emph{original SVS} $\gsc$ contract for off-chain execution. For $b \in \{1,2\}$, let $\{\ttree_b, \atree_b \}$ be the $\gsc_b$ trees under $\dst{b}$.
    Also assume (I) $\ttree_1 = \atree_2$ and $\ttree_2 = \atree_1$.
    Then (I) is preserved under $(\dstt{1}, \dstt{2})$ if and only if there exists $d \in \{\true, \false\}$ such that, for all $i \in [n]$, $\actexec{}(\dst{b}, \dstt{b}, \batch{b}, a_i) = d$ for both $b \in \{1,2\}$ where $a_i.\rol{} = \rol{b}$.
\end{lemma}

\begin{proof}[Proof of \cref{lem:svs-gsc-all-or-none-exec}]
    The ``if'' direction corresponds to the honest execution; its proof is simple and thus omitted. We prove the contrapositive of the ``only if'' direction. Assume there exists $1 \leq i \leq n-1$ and such that (without loss of generality)  $a_{i}'.\rol{} = \rol{1}$ and $a_{i + 1}'.\rol{} = \rol{2}$, and $\actexec{}(\dst{1}, \dstt{1}, \batch{1}, a_{i}') = d_i \neq d_{i+1} = \actexec{}(\dst{2}, \dstt{2}, \batch{2}, a_{i+1}')$. Since $\ccrt$ is a chain CRT, we know $a_i'.\descnext{} = a_{i+1}'.\desc{} \neq \nul$.
    
    \noindent\textbf{Case 1:} $d_i = \true$ and $d_{i+1} = \false$. Using \cref{claim:a-exec-iff-desc-inserted-chain}, the former implies $a_{i}'.\descnext{} \in \ttree_{1}'$, and the latter implies $a_{i+1}'.\desc{} \notin \atree_{2}'$.
            
    \noindent\textbf{Case 2:} $d_i = \false$ and $d_{i+1} = \true$. The former implies $a_{i}'.\descnext{} \notin \ttree_{1}'$, and the latter implies $a_{i+1}'.\desc{} \in \atree_{2}' $.
    In either case we get $\ttree_{1}' \neq \atree_{2}'$.
\end{proof}

\cref{lem:svs-gsc-honest-or-reverse-order} states that under the SVS $\gsc$, an Executor can only \emph{fully reverse} the order of actions within a CRT -- and still pass the $\gsc$ root check. We defer its proof to \cref{apdx:chain-crt-proofs}. In the following, we say that $\batch{}$ \emph{preserves} (resp. \emph{fully reverses}) the relative order of actions in a CRT $\ccrt = [a_i]_{i \in [n]}$ if for all $0 \leq i_1 < i_2 \leq n$ such that $a_{i_1}, a_{i_2} \in \batch{}$, it holds that $a_{i_1} \underset{\batch{}}{\prec} a_{i_2}$  (resp. $a_{i_1} \underset{\batch{}}{\succ} a_{i_2}$).

\begin{lemma}~\label{lem:svs-gsc-honest-or-reverse-order}
    Consider the same setup as in \cref{lem:svs-gsc-all-or-none-exec} and assume $\ttree_1 = \atree_2$ and $\ttree_2 = \atree_1$. Also assume $\actexec{}(\dst{b}, \dstt{b}, \batch{b}, a_i) = \true$ for $b \in \{1,2\}$ where $a_i.\rol{} = \rol{b}$. Then both $\batch{1}$ and $\batch{2}$ either preserve or fully reverse the relative order of actions if and only if $\ttree_1' = \atree_2'$ and $\ttree_2' = \atree_1'$.
\end{lemma}


\cref{lem:chain-gsc-honest-order} states that our chain-CRT $\gsc$ is safe against the ``reversal'' attack introduced in \cref{lem:svs-gsc-honest-or-reverse-order}. We defer the proof of \cref{lem:chain-gsc-honest-order} to~\cref{apdx:chain-crt-proofs}. 

\begin{lemma}~\label{lem:chain-gsc-honest-order}
    Let $\ccrt = [a_i]_{i \in [n]}$ and $\{\rol{b}, \dst{b}, \dstt{b}, \batch{b}\}_{b \in \{1,2\}}$ be as in \cref{def:forward-atom-chain-crt}, when using our \emph{chain-CRT} $\gsc$ contract for off-chain execution. For $b \in \{1,2\}$, let $\{\ttree_b, \atree_b, \sactive{b}, \snonce{b},  \\ \enonce{b} \}$ be the $\gsc_b$ state under $\dst{b}$. Assume $\actexec{}(\dst{b}, \dstt{b}, \batch{b}, a_i) = \true$ for $b \in \{1,2\}$ where $a_i.\rol{} = \rol{b}$. Also assume 

    \noindent(I) $\ttree_1 = \atree_2$ and $\ttree_2 = \atree_1$,
    
    \noindent(II) $\snonce{1} = \snonce{2} = \enonce{1} + \enonce{2}$, and

    \noindent(III) $\sactive{b} = \false$ for at least one $b \in \{1,2\}$.

    \noindent Then $\batch{1}$ and $\batch{2}$ preserve the relative order of all actions if and only if (I,II,III) are preserved under $(\dstt{1}, \dstt{2})$.
\end{lemma}

We now state and prove our main theorem.


\begin{theorem}~\label{thm:chain-crate-forward-atomicity-two-rollups}
    $\pname$ satisfies atomicity for chain-CRTs and $|\mathcal{R}| = 2$ rollups.
\end{theorem}

\begin{proof}[Proof of \cref{thm:chain-crate-forward-atomicity-two-rollups}]
    Let $\ccrt = [a_i']_{i \in [n]}$ and $\{\vsm{b}, \rol{b}, \dst{b}, \dstt{b}, \batch{b}\}_{b \in \{1,2\}}$ be as in \cref{def:forward-atom-chain-crt}, where $\{\dstt{b}, \batch{b}\}_{b \in \{1,2\}}$ are the new state digests and batches after running $\pname$. For $b \in \{1,2\}$, let $\{\ttree_b, \atree_b, \sactive{b}, \snonce{b}, \\ \enonce{b} \}$ be the $\gsc_b$ state under $\dst{b}$.
    Assume properties (I,II,II) from \cref{lem:chain-gsc-honest-order} all hold under $(\dst{1}, \dst{2})$.
    Also let $\idx = \textproc{getIndex}(\dst{1}, \dstt{1}, \dst{2}, \dstt{2})$ be the 2PC instance index.
    For contradiction, assume $\pname$ does \emph{not} satisfy atomicity, i.e., assume
    \begin{align*}
        \atomexec(\ccrt, \{\rol{b}, \dst{b}, \dstt{b}, \batch{b}\}_{b \in \{1,2\}}) = \false.
    \end{align*}
    This means either (a) the $\actexec{}(\cdot)$ predicates do not all agree, or (b) all $\actexec{}(\cdot) = \true$ and at least one pair of actions are not in order in their batch. In case (a), \cref{lem:svs-gsc-all-or-none-exec} says that property (I) is not preserved. In case (b), \cref{lem:chain-gsc-honest-order} says that at least one of (I,II,III) is not preserved. 
    In either case, using an inductive argument across all CRTs present in $\batch{1}$ and $\batch{2}$, at least one of (I,II,III) is not preserved under $(\dstt{1}, \dstt{2})$.
    
    \smallskip
    We now consider the 2PC component of $\pname$ leading to the new state digests. First note that in either case (a) or (b), at least one of $(\dstt{1}, \dstt{2})$ is a non-local digest; without loss of generality, assume $\dstt{1}$ is non-local. Thus $\vsm{1}$ must have executed $\textproc{PreCommit}$ successfully, followed by $\textproc{Commit}$, in order to commit to the new state digest $\dstt{1}$. This is because $\vsm{1}$ will see that one of $\ttree_1', \atree_1'$ is updated and will never accept $\dstt{1}$ as a new local state digest. This relies on the soundness of merkle membership proofs of the $\gsc$ state against the rollup state digest. We consider two cases:
    
   \noindent\textbf{Case 1:} $\vsm{1}$ is the leader under $\idx$. Then $\vsm{2}$ must have successfully  executed $\textproc{PreCommit}$ and entered $\paired$ status under $\idx$ 
    (otherwise, $\vsm{1}$ will never see correct proof of $\vsm{2}$ being $\paired$, and will never decide to commit). Now consider the successful execution of $\textproc{Commit}$ on $\vsm{1}$, 
    leading to a $\commit$ decision. Since $\vsm{1}$ decides to commit, it must see that all three properties (I,II,III) are preserved under $(\dstt{1}, \dstt{2})$, a contradiction. 

    \noindent\textbf{Case 2:} $\vsm{1}$ is \emph{not} the leader under $\idx$, so $\vsm{2}$ is the leader. Since $\vsm{1}$ accepts new non-local state digest ($\dstt{1}$), it must accept it after successful completion of $\textproc{Commit}$. Since $\vsm{1}$ is not the leader, it must have seen correct proof that $\vsm{2}.\decisions[\idx] = \commit$. For $\vsm{2}$ to decide to commit, it must have also successfully executed $\textproc{Commit}$ and committed. Again, it must be that all properties (I,II,III) are preserved under $(\dstt{1}, \dstt{2})$, a contradiction.  

\end{proof}

Note that the proof of \cref{thm:chain-crate-forward-atomicity-two-rollups} relies on the soundness of bridge proofs for the correctness of the L1 state digest.


\subsection{Latency and Liveness}~\label{sec:liveness-chain-crt}
$\pname$ requires two L1 transactions per rollup in sequential order: $\vsm{1}.\textproc{updateDigest}$, $\vsm{2}.\textproc{updateDigest}$, $\vsm{1}.\textproc{Commit}$, and $\vsm{2}.\textproc{Commit}$, with a similar order for aborts. This ensures an end-to-end latency of $4$ rounds, satisfying efficiency with respect to \cref{def:efficiency}. $\pname$ satisfies \emph{liveness}, as the leader VSM can always exit $\paired$ status by committing or aborting, while the non-leader VSM depends on the leader’s decision. Since both rollups are assumed live, this dependency does not cause deadlocks.


































