Blockchains have revolutionized trust, democratization, and privacy for applications in finance and beyond. As of October 2024, blockchain systems and applications collectively control assets worth over 2.5 trillion dollars~\cite{forbes-crypto-cap-24}. A unique attribute that sets blockchain applications apart from conventional ones is {\em composability}, the ability to combine services from multiple smart contracts in a single atomic execution. Composability enables trustless, atomic interactions that lead to innovative applications, such as flash loans~\cite{qin-attacking-defi-flash-loans-21}. 

Blockchains like Ethereum~\cite{wood-ethereum-2014} have a ``layer 2''-centric~\cite{eth-org-layer-2} roadmap for scalability. Layer 2 (L2) chains are separate blockchains built on top of the layer 1 (L1) chain, inheriting some of its security features. A rollup, a specific type of L2 chain, handles transaction execution off-chain and then submits the transaction data back to the main Ethereum blockchain. Even though rollups are envisioned to host the execution of more and more transactions, the scalability provided by L2 chains is {\em at odds} with composability. 
L2 systems like rollups are isolated from each other and forgo the advantages~\cite{a16z-composability} of composability in a cross-rollup context.



The fragmentation barrier poses a distinct challenge: the necessity for various chains to interoperate (IO), i.e., securely communicate and coordinate. Several cross-chain interoperability (IO) protocols have surfaced to address this gap, primarily adopting the framework of atomic swaps and cross-chain bridges (see, e.g.,~\cite{augusto-sok-io-24} for a survey). These systems have found extensive use in practice. 
For instance, bridges~\cite{xiew-zkbridge-22, axelar, near-bridge} move more than $1$ billion USD worth of assets cross-chain per week within Decentralized Finance (DeFi) services alone, as of the time of writing~\cite{defillama-bridges}. 
Atomic swaps~\cite{bitcoin-wiki-htlc,herlihy-atomic-cc-swaps-18} are also widely deployed, with which two parties can exchange their assets on separate blockchains with an atomicity guarantee: either they both receive the other partyâ€™s assets, or neither does. 
However, while existing IO protocols enable services such as asset transfers, they cannot offer full cross-rollup {\em composability}, since they lack a coordination mechanism. 
Notably, they cannot support cross-rollup flash loans or other complex applications that involve executing multiple transactions across rollups atomically.


A few academic proposals~\cite{lu-atomic-cc-interactions-24, fal-tccsci-23, zakhary-ac3-20} achieve composability for transactions spanning multiple L1 chains. However, they tackle a fundamentally different problem, as they operate on L1; they further require complex state locking mechanisms and multiple rounds, thus prohibiting certain applications like cross-chain flash loans. 
Shared sequencer networks, such as Espresso, Astria, and Radius~\cite{espresso-docs, astria-docs, radius-docs}, enable certain types of cross-rollup transactions but crucially trust the sequencer for proper sequencing to guarantee atomicity. 



\myparagraph{The problem}
We investigate protocols for executing cross-rollup transactions (CRTs) atomically, enabling users to execute a sequence of transactions across multiple rollups in an all-or-nothing manner. 
Besides the all-or-nothing feature, we also require \emph{serializability} (in particular, \emph{weak serializability}), i.e., that the execution preserves the order of transactions within the CRT. In contrast, \emph{full serializability} additionally requires that no other transaction can interleave between CRT transactions (see \cref{sec:discussion} for details). \done Serializability is needed by most applications, such as arbitrage consisting of carefully ordered buy-and-sell transactions. 
Candidate solutions should also minimize trust in third parties and be flexible by supporting rollups that reside on different L1s.






\myparagraph{Building block: Shared Validity Sequencing}
Shared Validity Sequencing (SVS)~\cite{shared-val-seq-23} proposes a trigger-action paradigm for a smart contract on one rollup to remotely invoke a smart contract method on another rollup. A \textit{smart contract}~\cite{eth-org-smart-contracts} is a program stored on a blockchain that gets executed once all its predetermined conditions are satisfied. A rollup is operated by an \emph{Executor} and is controlled by a Validator smart contract ($\vsm{}$) on L1. SVS relies on a shared Executor between two rollups and a special system contract ($\gsc$) residing on both rollups. $\gsc$ has two main functions,
$\trig$ (called by users) and $\act$ (called by the Executor), and two Merkle trees, $\ttree$ and $\atree$. 
The atomicity of CRTs is ensured by comparing the roots of the two Merkle trees, enforced by the Validator smart contract, avoiding trust in any third party. A more detailed description of SVS can be found in \cref{sec:overview-svs}.


The SVS solution has two major problems. If the user CRT has a length greater than $2$, a malicious Executor could reorder transactions such that the all-or-nothing check passes, yet serializability breaks. Restoring serializability while preserving expressiveness is a nontrivial challenge we tackle in this paper.
Moreover, SVS also assumes that rollups share the same Executor and reside on the same L1 chain, which lacks flexibility. A more flexible protocol would allow rollups to reside on separate chains and be operated by distinct Executors. 




\myparagraph{Our approach}
We present our protocol, $\pname$: \textbf{C}ross-\textbf{R}ollup \textbf{A}tomic \textbf{T}ransaction \textbf{E}xecution, which extends the existing rollup architecture and addresses the two key problems found in~\cite{shared-val-seq-23}, thus enabling cross-rollup composability. 
$\pname$ begins with the user creating a single source transaction that encodes her CRT using the trigger-action framework and sends it to the Executor. In Phase 1, the Executor executes a transaction batch off-chain, and generates new state digests and validity proofs. $\pname$ supports serializability and more complex CRTs by modifying the GSC contract to handle multiple triggered actions and track CRT sessions with session nonces. In Phase 2, the Executor drives the two VSMs to complete a Two-Phase-Commit (2PC) protocol, in order to jointly agree on the new pair of state digests. First, one of the two VSMs is designated to be the \emph{leader} and pre-commits to the new state digest, followed by the non-leader VSM. Then the leader VSM commits to the digest only when presented with evidence that the other VSM has pre-committed; finally the non-leader VSM commits, too, after seeing evidence of the leader VSM's commit decision.

\parhead{Formal definition and proof}
The lack of formal definition and rigorous analysis in~\cite{shared-val-seq-23} leaves the flaws unnoticed.
Thus, we formally define cross-rollup transactions (CRTs) in two different programming models, and then define atomicity for CRT execution, providing -- to our knowledge -- the first formal treatment of cross-rollup composability. We use our formal framework to rigorously prove security for $\pname$.

\parhead{Implementation and evaluation.}
We implement $\pname$ on Ethereum networks using the Foundry~\cite{foundry-book} toolkit, focusing on the Executor, L2-based $\gsc$ contract, and L1-based Validator ($\vsm{}$) contract. For evaluation, our implementation using SNARK-based membership proofs incurs a $0.32-0.75\times$ increase in gas usage compared to Zksync Era~\cite{zksync-era}. We additionally implement and evaluate a modular cross-rollup flash loan application on top of $\pname$.
Regarding rollup finality, $\pname$ achieves finality in 4 rounds on L1 (i.e., $~52$ minutes on Ethereum). Existing zk-rollups submit new state roots to L1 at intervals in the order of \emph{hours}, since SNARK proof generation is the bottleneck. Thus, $\pname$'s latency does not affect existing rollups' finality and throughput, since the $\vsm{}$s were already not utilized during that time for any new state updates.




\subsection*{Our Contributions.}
\begin{itemize}[leftmargin=*]
    \item We analyze the state-of-the-art cross-rollup composability paradigm~\cite{shared-val-seq-23} and demonstrate a concrete attack that breaks its security for CRTs of length greater than $2$. 
    \item We provide two formal models for cross-rollup transactions (CRTs): the chain-CRT and DAG-CRT programming model. Within these models, we formally define atomicity for CRTs, providing the first such formal security treatment.
    \item We introduce $\pname$, a secure cross-rollup composability protocol that (1) only trusts the underlying L1s, the liveness of the L2s, and the liveness of a bridge between the L1s, and (2) achieves finality in 4 rounds on L1. We then formally prove the security of $\pname$.
    \item We implement $\pname$ along with an end-to-end cross-rollup flash loan. Our experiment shows that $\pname$ is practical in terms of L1 gas usage.
    \item We introduce extensions to $\pname$ which enable full serializability and support distinct Executors.
\end{itemize}

