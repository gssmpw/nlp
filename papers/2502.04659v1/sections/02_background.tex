



\myparagraph{Blockchains}
A blockchain is a distributed protocol where a group of nodes collectively maintains an ordered list of blocks. A block is a data structure that stores a header and a list of transactions, as well as important metadata, such as a pointer to the previous block. 

\myparagraph{Smart contracts}
Many blockchains support expressive programs called smart contracts; these are stateful programs whose state persists on the blockchain. Our solution relies heavily on smart contracts on both L1 and L2, so we introduce some commonly used notation. The keyword \textbf{require} is used to check whether a certain predicate is true; if not, then the EVM reverts execution of the transaction. A smart contract can emit \emph{events} using the \textbf{emit} keyword; events provide non-persistent logging functionality which can be used by upper-level applications.

\myparagraph{Merkle Tree} A Merkle tree~\cite{merkle-tree} is a dynamic data structure widely used to commit to an ordered sequence of values. Under the assumption of cryptographic hash functions, two Merkle trees are equal if and only if their roots are equal. Ethereum uses the more efficient variant of Merkle-Patricia Tries~\cite{mpt-trie} for storage. In this work we use Merkle trees to mean both regular Merkle trees and MPT tries.

\newcommand{\scstruct}[1]{\mathsf{SC}_{#1}}

\myparagraph{Rollups: Executor and VSM} We consider validity-proof-based rollups, widely known as zk-rollups~\cite{eth-org-zk-rollups}. Each rollup is operated by a single entity -- which we call Executor~\footnote{In practice, there are distinct entities (Sequencer, Executor, Prover, etc.) assuming different roles in the rollup operation.} -- and is controlled by a Validator smart contract ($\vsm{}$) on layer $1$. The Executor is responsible for receiving, ordering, and executing transactions submitted by rollup users. The Executor also creates a validity proof for the state transition, and submits both the new state digest and the proof to the $\vsm{}$ (at the same time). The $\vsm{}$ contract maintains a short digest $\dst{}$ of the current state $\mathsf{ST}$ of the rollup. The $\vsm{}$ contract exposes a function $\textproc{updateDigest}(\cdot)$, which advances the current state digest and can only be called by the Executor. This function verifies the validity proof before accepting the new state digest. Suppose $\dst{}$ is the current state digest stored by a rollup VSM, and let $\dstt{} \neq \dst{}$ be another state digest. We say that $\dstt{}$ is the \emph{immediate next accepted} digest after $\dst{}$ if $\dstt{}$ is the first digest submitted to and accepted by the VSM contract through the $\textproc{updateDigest}(\cdot)$ function. 

\myparagraph{Bridges}~\label{par:background-bridges}
$\pname$ relies on cross-chain bridges for communication between VSMs and can use any trustless bridge, such as zkBridge~\cite{xiew-zkbridge-22}. We abstract bridges as follows: a contract $\contract{1}$ on $\bc{1}$ can access state from $\contract{2}$ on $\bc{2}$ via a tuple $(\scstruct{2}, \attproofs)$, where $\scstruct{2}$ represents $\contract{2}$'s state, and $\attproofs$ provides membership proofs against a relayed $\bc{2}$ block header.



\myparagraph{Application: Flash Loan}
Flash loans~\cite{qin-attacking-defi-flash-loans-21} enable a user to borrow a loan and repay it in the same blockchain transaction; if the loan is not repaid in the same transaction, then the entire transaction will fail. They are a type of uncollateralized loans, available to all users regardless of the capital they own.




\myparagraph{Two-Phase Commit (2PC)}
Two-Phase Commit (2PC) is a protocol introduced in the setting of distributed databases~\cite{bernstein-concurrency-databases-1986} to ensure atomicity in transactions across multiple servers. It operates in two phases: the pre-commit phase, where the coordinator asks all participants if they can commit, and the commit phase, where the coordinator either commits or aborts the transaction based on responses. This protocol guarantees that either all participants commit the transaction or none do.

\myparagraph{Zero-Knowledge Arguments and SNARKs}
An argument system for an NP relation $R$ is a protocol between a computationally-bounded prover $\prover$ and a verifier $\verifier$. Through this protocol, $\verifier$ is convinced by $\prover$ that a witness $w$ exists such that $(x,w) \in R$ for some input $x$. There is also an algorithm $\gen$ which produces public parameters during the setup phase. A triple $(\gen, \prover, \verifier)$ is a zero-knowledge argument (ZKA) of knowledge for $R$ is it satisfies \emph{completeness}, \emph{knowledge soundness}, and \emph{zero knowledge}; we refer the reader to~\cite{groth-16, thaler-proofs-args-zk-22} for formal definitions of these properties. $(\gen, \prover, \verifier)$ is considered a \emph{succint} argument system if the total communication (proof size) between $\prover$ and $\verifier$ as well as the running time of $\verifier$ are bounded by $\mathsf{poly}(\lambda, |x|, \log|R|)$, where $\log|R|$ represents the size of the circuit computing $R$. For this paper, we require only a succinct non-interactive argument of knowledge (SNARK) that satisfies the first two properties and ensures succinctness.
