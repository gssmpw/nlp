\newcommand{\startsession}{\textproc{startSession}}
\newcommand{\checksessionid}{\textproc{checkSessionID}}
\newcommand{\trigger}{\textproc{trigger}}
\newcommand{\triggerinternal}{\textproc{triggerInternal}}
\newcommand{\action}{\textproc{action}}

In this section, we present XEVM, our modified execution engine for rollups. First, we extend the General System Contract ($\gsc$) introduced in~\cite{shared-val-seq-23} so that it securely supports chain CRTs of arbitrary length. Next, we present the full Executor algorithm specification for the XEVM component. 


\subsection{General System Contract}


\input{contracts/gsc-single-trigger}


 In this section, we present our modified General System Contract ($\gsc$) which handles chain CRTs. \cref{alg:gsc-single-trigger} fully specifies our $\gsc$ contract; we highlight our contributions with \textcolor{chain}{blue color} on top of SVS~\cite{shared-val-seq-23}. Besides the Merkle trees $(\ttree, \atree)$ and nonces ($\tnonce{}, \anonce{})$, the $\gsc$ contract maintains two additional nonces $(\snonce{}, \enonce{})$ and the $\sactive{}$ flag to keep track of CRT sessions. Nonces are initialized to zero and the $\sactive{}$ flag to $\false$.

The source action $(a_1)$ launches a new CRT session by calling the new entry point function $\startsession$, passing the $(\addr, \cdata)$ fields of the action it wishes to trigger. $\startsession$ increments both $\enonce{}$ and $\snonce{}$ by one, marks the session as active ($\sactive{} \gets \true$), and calls $\triggerinternal(\msgsender, \addr, \cdata)$. $\triggerinternal$ is an internal function only supposed to be called by $\startsession$. 
$\trigger$ is the function that application smart contracts are supposed to invoke.   


The $\trigger$ function increments $\tnonce{}$, hashes the tuple $(\msgsender, \addr{}, \cdata, \tnonce{}, \sid{})$, and inserts the hash into $\ttree$. Here $\msgsender$ is the address of the caller contract and $\sid{}$ is taken to be the current $\snonce{}$ value. It also emits a Trigger event intended to be listened to by the Executor.  

The $\action$ function takes as input the tuple $(\sender, \addr{}, \cdata, \sid{})$ and can only be called by the Executor. First, it checks that $\sid{}$ matches either $\snonce{}$, which requires that $\sactive{} = \true$ , or $\snonce{} + 1$, signaling a new CRT session. Then, it sets $\xsender{} \gets \sender$ and calls the smart contract method specified by $(\addr{}, \cdata)$. The callee contract can access the public variable $\xsender{}$ which specifies the cross-rollup sender. Next, it increments $\anonce{}$, hashes the tuple $(\sender, \addr{}, \cdata, \anonce{}, \sid{})$, and inserts the hash into $\atree$. If the $\tcalled{}$ flag is raised during the call to $(\addr{}, \cdata)$ (i.e., there is a nested call to $\trigger$), this means that the current CRT session is not finished. Otherwise, this is the end of the current CRT session and it marks $\sactive{} \gets \false$. 



We assume a unique copy of the $\gsc$ contract is deployed on each rollup. Our design guarantees that the $\trigger$ function can only be called either by $\startsession$ or in a nested manner during an $\action$ call, as well as that $\startsession$ can only be called by a source action ($a_1$), and never in a nested manner during an $\action$ call.


\subsection{Executor Specification}
 

In this section, we describe the XEVM component of the Executor, formally specified in~\cref{alg:shared-executor-xevm-chain-crt}. The Executor algorithm manages the execution of both local and non-local transactions across the two rollups. We assume a function $\textproc{evm}$ which takes as input a transaction and executes it on the specified rollup according to EVM rules. The Executor maintains the current state and a state checkpoint for each rollup. To execute a transaction $\tx$ received by a user, he calls $\textproc{entryPoint}(\tx)$, which creates state checkpoints for all rollups before proceeding to call \textproc{xevm}($\tx$). The $\textproc{xevm}(\tx)$ function uses the (assumed) $\textproc{evm}$ function to execute $\tx$ and listens for a trigger event. If there is a triggered transaction $\tx'$, the Executor constructs a wrapper transaction $\tx''$ which calls $\gsc.\action(\cdot)$ with the description of $\tx'$ as argument. It then recursively calls $\textproc{xevm}(\tx'')$, and so on, until all trigger calls have been handled. If any transaction or its triggered transaction fail, this failure propagates up to $\textproc{entryPoint} $, which restores the state of all rollups to their checkpoints.
























