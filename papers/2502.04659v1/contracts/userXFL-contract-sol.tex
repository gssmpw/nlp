\begin{lstlisting}[language=Solidity]

contract XUserFL {

    GeneralSystemContract public gsc;
    Token public token;
    FlashLoan public fl;
    address public othUserFLAddr;

    constructor(address gscAddr){ 
        gsc = GeneralSystemContract(gscAddr);
    }

    function setup(address tokenAddr, address flAddr, address _othUserFLAddr) public {
        token = Token(tokenAddr);
        fl = FlashLoan(flAddr);
        othUserFLAddr = _othUserFLAddr;
    }

    function simpleXFL(uint256 amount, address arbAddr, bytes memory cdArb) public {
        bytes memory cdStep1 = abi.encodeWithSignature(
            "step1(uint256,address,bytes)", 
            amount, arbAddr, cdArb
        );
        fl.init(amount, address(this), cdStep1);
    }

    // on rollup 1
    function step1(uint256 amount, address arbAddr, bytes memory cdArb) public {
        token.burn(othUserFLAddr, amount); 
        bytes memory cdStep2 = abi.encodeWithSignature(
            "step2(uint256,address,bytes)", 
                amount, arbAddr, cdArb
        );        
        gsc.trigger(othUserFLAddr, cdStep2);
    }

    // on rollup 2
    function step2(uint256 amount, address arbAddr, bytes memory cdArb) public {
        require(gsc.xSender() == othUserFLAddr);
        (bool status, bytes memory data) = arbAddr.call(cdArb);
        require(status == true);
        token.burn(othUserFLAddr, amount);
        bytes memory cdStep3 = abi.encodeWithSignature(
            "step3(uint256)", 
                amount
        );
        gsc.trigger(othUserFLAddr, cdStep3);
    }

    // on rollup 1
    function step3(uint256 amount) public {
        require(gsc.xSender() == othUserFLAddr);
        token.transfer(address(fl), amount);
    }

}

\end{lstlisting}
