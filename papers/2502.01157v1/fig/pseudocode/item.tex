\begin{figure}[ht]
  \centering
  \begin{algorithm}[H]
    \caption{Ray tracing algorithm}\label{alg:render}
    \begin{algorithmic}[1]
      \Procedure{$\textsc{Render}$}{$\mathbf{o},\mathbf{d}$} \Comment{ray parameters}
        \State \(t_0 \gets 0\)
        \State \(i \gets \mathrm{nn}(\mathbf{o})\) \Comment{initial cell (nearest neighbour)}
        \State \(T \gets 1\)
        \State \(\mathbf{C} \gets \mathbf{0}\)
        \While{\(T > \epsilon\)}
          \State \(x \gets v_i\) \Comment{\(v_i\): primal vertex of cell \(i\)}
          \State \(t_1 \gets \infty\)
          \State \(i' \gets \varnothing\)
          \ForAll{\(j \in \mathrm{N}(i)\)}  \Comment{$\mathrm{N}(i)$: neighbours of cell \(i\)}
            \State \(x' \gets v_j\) \Comment{\(v_i\): primal vertex of cell \(j\)}
            \State \((t_j, \textrm{front}) \gets \textsc{Intersect}(\mathbf{o},\mathbf{d},x,x')\)
            \If{\(\textrm{front}~\textbf{and}~(t_j < t_1)\)}
              \State \(t_1 \gets t_j\)
              \State \(i' \gets j\)
            \EndIf
          \EndFor
          \State \(c \gets \mathbf{c}_{i}\) \Comment{$\mathbf{c}_{i}$: color of cell $i$}
          \State \(\sigma \gets \sigma_{i}\) \Comment{$\sigma_{i}$: density of cell $i$}
          \State \(\alpha \gets 1 - e^{-\sigma(t_1-t_0)}\)
          \State \(\mathbf{C} \gets \mathbf{C} + T\,\alpha\, c\)
          \State \(T \gets T\,(1-\alpha)\)
          \State \(t_0 \gets t_1\)
          \State \(i \gets i'\)
        \EndWhile
        \State \Return \(\mathbf{C}\)
      \EndProcedure
    \end{algorithmic}
  \end{algorithm}
\vspace{-1.5em}
  \caption{\textbf{Ray tracing --}
  Our ray tracing algorithm is simple, and based on the method proposed by \citet{ray_plane}.
  Unlike common algorithms for tracing triangle meshes and other unstructured scene representations, we do not require a hierarchical acceleration structure, and thus avoid the associated $O(\log(n))$ query operation.}
  \label{fig:pseudocode}
\end{figure}