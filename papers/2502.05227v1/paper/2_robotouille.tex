\vspace{-1em}
\section{Robotouille}
\label{sec:formulation}
\vspace{-1em}

% We formalize \robotouille{} tasks as Markov Decision Processes (MDPs) $\mathcal{M} = <\mathcal{S}, \mathcal{A}, \mathcal{T}, \mathcal{R}>$. State $s \in \mathcal{S}$ is the set of all objects, predicates such as \texttt{iscut(lettuce1)}, or "\texttt{lettuce1} is cut", and \texttt{on(lettuce1,table2)}, or "\texttt{lettuce1} is on \texttt{table2}", and progress variables such as cooking time left or number of cuts remaining. Action $a \in \mathcal{A}$ is a grounded action such as \texttt{move(robot1, table1, table2)}, or "Move \texttt{robot1} from \texttt{table1} to \texttt{table2}". Actions have preconditions over state predicates which must be met to be valid. For a given state $s$ and action $a$, the transition function $\mathcal{T} \colon \mathcal{S} \times \mathcal{A} \rightarrow \mathcal{S}$ returns the next state $s'$ if $a$ is valid or the current state $s$ if $a$ is invalid. The reward function $\mathcal{R} \colon \mathcal{S} \rightarrow \{0, 1\}$ defines the goal of a given task where for goal state $s_g$, $r(s_g) = 1$.

We formalize \robotouille{} tasks as an MDP with time-delayed effects, $\mathcal{M} = <\mathcal{S}, \mathcal{A}, \mathcal{T}, \mathcal{R}>$. Each state $s \in \mathcal{S}$ is $s = (\hat s_t, H_t)$ where $\hat s_t$ represents observable state elements like objects or predicates such as \texttt{iscut(lettuce1)}, or "\texttt{lettuce1} is cut", and \texttt{on(lettuce1,table2)}, or "\texttt{lettuce1} is on \texttt{table2}", and $H_t$ is a set of timer variables $h \in H_t$ each created by actions with a countdown function $h(x) = d - (x - i)$ where $d$ is a delay constant and $i$ is the timer's activation step. Action $a \in \mathcal{A}$ is a grounded action such as \texttt{move(robot1, table1, table2)}, or "Move \texttt{robot1} from \texttt{table1} to \texttt{table2}" that may introduce new timers $h$. Actions have preconditions over state predicates which must be met to be valid. For a given state $s$ and action $a$, the transition function $\mathcal{T} \colon \mathcal{S} \times \mathcal{A} \rightarrow \mathcal{S}$ returns the next state $s' = (\hat s_{t+1}, H_{t+1})$ if $a$ is valid or the current state $s$ if $a$ is invalid. For a valid action step, $\hat s_{t+1} = \hat s_t \cup \{predicates(h)|h \in H_t, h(t) = 0 \}$ to removes expired timers and $H_{t+1} = (H_t - \{ h|h(t) = 0\}) \cup \{h|a \text{ adds delay}\}$ to update active timers. The reward function $\mathcal{R} \colon \mathcal{S} \rightarrow \{0, 1\}$ defines the goal of a given task where for goal state $s_g$, $r(s_g) = 1$. We provide a complexity analysis between synchronous and asynchronous settings in Appendix~\ref{app:async-harder-sync}.

\vspace{-0.5em}
\input{figures/table_3_related_works}
\vspace{-0.5em}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Domain and Problem JSONs %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{enumerate}
%     \item easy environment creation + language backend (predicates and actions in domain have language descriptions and goal description is used as language goal in instance json) (paragraph 1)
%     \item figure makes sense to reference in paragraph 1 with what the JSON actually looks like
%     \item Easy to add new items into domain with rendering
%     \item make reference to domain and instance JSON have an example in mind for which we can have a figure
% \end{enumerate}

% \textbf{Customizable JSON Backend} The Robotouille environment is built with an easily customisable JSON backend. Predicates can be defined in a domain JSON with a name, the object types for the predicate, and natural language descriptions, which allows for easy integration with the LLM .(Figure~\ref{fig:domain_json_pred}) 
% Similarly, new actions are implemented by specifying their name, their preconditions (a list of predicates that need to be true for the action to be valid), and immediate effects (a list of predicates that are applied to a state immediate after the action is performed), special effects (effects that are not easily defined by predicates, explained later), and a natural language description. (Figure~\ref{fig:domain_json_action})
% New items can also be added to the domain using the domain json, and images corresponding to the items can be easily specified in the rendering json. (Figure~\ref{fig:renderer_json})

\textbf{Domain and Problem JSONs} \robotouille{} uses JSONs to fully describe a task $\mathcal{M}$ using a domain $\mathcal{D} = <\mathcal{O}_\mathcal{D}, \mathcal{P}_\mathcal{D}, \mathcal{A}_\mathcal{D}>$ and problems $\mathcal{P} = <\mathcal{O}_\mathcal{P}, \mathcal{I}_\mathcal{P}, \mathcal{G}_\mathcal{P}>$, inspired by PDDL \citep{aeronautiques1998pddl} and described in Figure~\ref{fig:jsons} (a-b). Domain $\mathcal{D}$ defines the possible states and actions of an environment with object types $\mathcal{O}_\mathcal{D}$, predicate definition $\mathcal{P}_\mathcal{D}$ and action definitions $\mathcal{A}_\mathcal{D}$. Problem $\mathcal{P}$ grounds the domain definitions with objects $\mathcal{O}_\mathcal{P}$, initial state predicates $\mathcal{I}_\mathcal{P}$, and goal $\mathcal{G}_\mathcal{P}$. In addition, $\mathcal{P}_\mathcal{D}$, $\mathcal{A}_\mathcal{D}$ and $\mathcal{G}_\mathcal{P}$ have language representations for an LLM agent.

%%%%%%%%%%%%%%%%%%
% Action Effects %
%%%%%%%%%%%%%%%%%%

% \begin{enumerate}
%     \item Talk about PDDL influence (paragraph 2)
%     \item some may notice that this looks similar to PDDL which is correct because we are influenced by this
%     \item however it can be cumbersome or even impossible to add some functionality to PDDL hence why we have special effects
%     \item describe some special effects and point to Appendix for full list and specification of special effects
% \end{enumerate}

% \textbf{Augmented PDDL Backend} This structure bears resemblance to the Planning Domain Definition Language (PDDL), a widely-adopted standard for Artificial Intelligence planning languages. Indeed, this similarity is intentional, as the design of our custom backend was influenced by PDDLâ€™s framework. However, despite its strengths in domain and problem definition, it can be cumbersome and in some cases impossible to add intended functionality to PDDL. The most notable instance of this is the ability to add actions that have effects that are not immediate. For example, cooking a steak on a stove is not instantaneous. It takes some amount of time, allowing the agent to perform other actions while waiting for steak to finish cooking. This is cumbersome in the PDDL framework because actions only have immediate effects. With Robotouille's custom backend, we are able to implement different special effects, includind:
% \begin{enumerate}
%     \item Delayed Effects: Changes to a state that only take effect after a specified number of steps in the environment.
%     \item Repeated Effects: Changes to a state that only take effect after an action has been done a specified number of times.
%     \item Creation Effects: An effect of an action that creates a new item in the environment.
%     \item Deletion Effects: An effect of an action that deletes an item in the environment. 
%     \item Conditional Effects: Changes to a state that only take effect if some conditions (which are predicates) are true. 
% \end{enumerate}
% Using the example of cooking an item, there are two special effects that are important. Firstly, a steak needs to be on a stove to be cooking; it should not continue cooking if the player picks it up from the stove. Secondly, the cooking should be delayed; the item should only be cooked after some time has passed. We are able to specify this in the domain json when defining the cook action. (Figure~\ref{fig:domain_json_sfx}) As seen in the figure, we are also able to nest special effects. The delayed effect is also an effect that should only be applied if the item is still on the stove, and should pause when the item is removed from the stove. 

\textbf{Action Effects} We adopt immediate effects from PDDL, where $\mathcal{T}(s, a) = s'$ and $s'$ results from predicates being added or removed due to $a$. To extend actions beyond immediate effects, we introduce \textbf{special effects}, which are custom code blocks that allow for complex interactions, such as delayed effects in cooking where predicates are added after a delay. Figure~\ref{fig:jsons} (c) shows an example of a special effect for the cook action. A conditional effect applies the \texttt{iscooking} predicate if an item \texttt{i1} is on station \texttt{s1} and removes it otherwise. In addition, a delayed effect is nested that adds predicate \texttt{iscooked(i1)} after a delay specified in the problem JSON (see Appendix~\ref{app:additional-jsons}).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Language Goal Specification %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{enumerate}
%     \item flexible goal specification (paragraph 3)
%     \item language goals are vague (making a cheeseburger on a table can mean multiple tables, ingredients in specific orders, whatever)
%     \item our goal system is very flexible and allows for a combinatorial number of goals to capture various configurations that satisfy a vague language goal
% \end{enumerate}

% \textbf{Flexible Goal Specification} Inspired by PDDL, Robotouille's backend also allows for flexible goal specification. Language goals are vague and difficult to specify. Our goal system allows for a combinatorial number of goals to capture various configurations that satisfy a vague language goal. For example, making a cheeseburger on a table can vary significantly depending on the context - there may be multiple tables involved, ingredients may be stacked in different orders, etc. Our goal system is designed to accommodate this variability by allowing for a combinatorial number of  goals to capture various configurations that satisfy a vague, broadly defined language goal. With the example of a cheeseburger, we specify that:
% \begin{enumerate}
%     \item The bottom bun must be on a table
%     \item The top bun must be clear (meaning nothing should be stacked on top of it)
%     \item The cheese and patties should be at the table (they just need to be part of the stack at the same table)
%     \item The patty should be cooked
% \end{enumerate}
% This ensures that as long as the bottom bun is at the bottom of the stack and the top bun is at the top of the stack, the patty and the cheese can be in any order. Furthermore, with the use of ids in defining these goals, we are able to clearly specify which predicate applies to which item. (Figure~\ref{fig:goal_specification}) This is important when a goal refers to multiple items that may require separate predicates applied on them. 

\textbf{Language Goal} Language goals are inherently ambiguous and many states may satisfy them. For example, in Figure~\ref{fig:jsons} (d), the goal \texttt{Make lettuce cheese sandwich on table} lacks information about which ingredients or tables to use (in the case where there are multiple) and doesn't specify whether the lettuce is above or below the cheese. We created a flexible goal specification system that captures a combinatorial number of goal states that may satisfy a vague language goal. In this example, by specifying that (1) one bread slice must be directly on the table, (2) another is somewhere at the table while being clear on top and (3) lettuce and cheese must be somewhere at the table, we fully capture all possible outcomes that satisfy the language goal.

%%%%%%%%%%%%%%%%%%%%%%%%%
% Procedural Generation %
%%%%%%%%%%%%%%%%%%%%%%%%%

% \textbf{Procedural Generation} Robotouille also incorporates procedural generation, which enables the creation of diverse environments. It supports both noisy and full randomization, allwoing for a wide range of variability in tasks. With noisy randomization, certain elements are varied within predefined constraints, maintaining the general structure of the environment while introducing subtle changes. This ensures that a goal can still be reached despite randomization (e.g. all stations can be reached, all ingredients are accessible, etc.) Full randomization, on the other hand, allows for complete unpredictability. This procedural flexibility makes Robotouille an effective benchmark in testing the effectiveness of LLMs on different iterations of the same task.

\textbf{Procedural Generation} \robotouille{} provides procedural generation which works off an existing problem JSON. To ensure that goals can be satisfied, the problem JSON should contain the minimum number of objects that satisfy the goal. The procedural generator shuffles existing objects and adds new objects which allows for stress testing on diverse environments with varying language descriptions and optimal paths to the goal.

%%%%%%%%%%%%%%%
% Multi-agent %
%%%%%%%%%%%%%%%

% \textbf{Multi-agent} Furthermore, Robotouille supports multi-agent environments, allowing for multiple agents to interact within a shared environment. These environments can be turn-based, where a single LLM can control multiple players within an environment to achieve a common task. Multiple agents can also interact in the environment in real time using Robotouille's networking capabilities.

\textbf{Multi-agent} \robotouille{} supports multi-agent environments by simply adding more players into the problem JSON. These environments can be either turn-based, where an LLM agent controls a single agent at a time, or real-time, where an LLM agent controls all agents simultaneously. We additionally implement networked multi-agent to allow data-collection of human-human play and evaluating agents against humans.

\vspace{-0.5em}
\input{figures/JSONs/fig_json_final_screenshot}
\vspace{-0.5em}