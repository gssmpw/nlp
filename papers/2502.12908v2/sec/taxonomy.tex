\subsection{GNNs for Databases' Scenarios Taxonomy}
As illustrated in Figure~\ref{fig:taxonomy}, this survey establishes a new taxonomy that categorizes existing works into two main areas: traditional databases and graph databases. These categories are further organized based on different application scenarios. We provide a brief introduction to each category as follows:

\subsubsection{Relational Databases}  
Relational databases have long been considered the cornerstone of data processing in computer science, offering a structured approach to data storage and retrieval. As a result, relational databases remain the central focus of database research. Many studies leverage GNNs to enhance the efficiency of relational databases further.
GNN applications in relational databases can be categorized into three areas:

\textbf{Performance Prediction}: Accurate performance prediction is essential for effective scheduling and monitoring in DBMSs. GNNs are leveraged to model the complex dependencies in database workloads, enabling precise query runtime and resource utilization predictions. For instance, a query plan\footnote{A query plan is a tree-structured set of database operations, where each node represents a specific DBMS operation, such as Aggregate, Hash Scan, or Index Scan. The DBMS executes these operations in the order defined by the tree structure.} can be represented as a graph, allowing GNNs to predict the processing time for the query plan with high accuracy. 

\textbf{Query Optimization}: GNNs enhance traditional database efficiency by optimizing critical aspects of query planning, such as join order selection, cardinality estimation, and query plan representation. These advancements facilitate the selection of optimal query plans, significantly reducing execution times and improving overall DBMS performance. For instance, a join plan can be represented as a tree structure, and using models like Tree-LSTM, the execution time of the join plan can be predicted. The most suitable plan for a specific query can be identified by comparing different join plans.

\textbf{Text-to-SQL}: Text-to-SQL is a crucial field that bridges the gap between natural language and structured database queries, making database interaction more accessible~\cite{DBLP:journals/corr/abs-2406-07815,DBLP:journals/pvldb/LiLCLT24}. In this field, GNNs play a key role in transforming natural language into SQL queries~\cite{DBLP:journals/corr/abs-2408-05109}. For example, GNNs can capture the relationships among different schema components and generate corresponding embeddings. These embeddings can be utilized to construct input representations, constrain the generation space, and enhance the alignment between natural language and database structures.

Beyond these categories, GNNs have also been applied to other traditional database challenges, such as materialized view maintenance, data partitioning, and automatic scheduling. These emerging applications demonstrate the versatility of GNNs in addressing diverse database problems.  


\subsubsection{Graph Databases}  
Graph databases organize data in graphs and are increasingly adopted in real-world applications, with notable examples including Neo4j, TigerGraph, and NebulaGraph. Leveraging their ability to capture graph-structured information effectively, GNNs provide significant advantages for enhancing graph database functionalities. GNN applications in graph databases can be categorized into two primary tasks:  

\textbf{Graph Similarity Computation}: Graph similarity computation is a fundamental operation in graph databases, underpinning many downstream tasks such as graph clustering, anomaly detection, and recommendation systems. GNNs have been widely employed to improve the efficiency and accuracy of similarity computations, including graph edit distance (GED) and maximum common subgraph (MCS) problems. For instance, embedding-based approaches powered by GNNs enable the representation of graph structures in a latent space, facilitating fast and scalable similarity computations.  

\textbf{Graph Query Acceleration}: Query processing is a critical function in graph databases, and GNNs have significantly advanced performance optimization in this area. Key tasks such as subgraph matching, subgraph counting, and Approximate Nearest Neighbor (ANN) search have benefited from GNN-based techniques. For example, subgraph matching algorithms utilize GNN embeddings to prune the search space, while ANN search employs GNNs to generate efficient graph-level representations for rapid querying.  

In addition to these core tasks, GNNs have been applied to enhance other aspects of graph databases, including representation learning, graph partitioning, and cardinality estimation in knowledge graphs. These developments demonstrate the potential of GNNs to optimize graph database operations. 

In the following sections, we delve deeper into these two research directions, exploring how GNNs contribute to each area and highlighting the differences among the various methods.