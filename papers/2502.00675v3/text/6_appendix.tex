\appendix

\section{Algorithm for SQLs List Execution with Self-Correction during Column Exploration}
\label{appendix:algo}

\begin{algorithm}[ht]
\caption{SQL List Execution with Self-Correction during Column Exploration}
\label{alg:execute_sql}
\KwIn{List of SQL queries \texttt{sqls}}
\KwOut{Result dictionary \texttt{result\_dic}}
\BlankLine
Initialize an empty dictionary \texttt{result\_dic} and an error record list \texttt{error\_rec}\;
\While{\texttt{sqls} is not empty}{
    Extract the first query: \texttt{sql} = \texttt{sqls.pop()}\;
    Execute the query: \texttt{results} = \texttt{execute\_sql\_api(sql)}\;
    
    \If{\texttt{results} are invalid}{
        Append correct SQL and result into result dictionary.\;
    }
    \Else{
        Initialize \texttt{max\_iter} = \texttt{3}, \texttt{simplify} = \texttt{False}, and \texttt{corrected\_sql} = \texttt{None}\;
        \While{\texttt{max\_iter} $>$ \texttt{0} and correction is needed}{
            \If{\texttt{max\_iter} = \texttt{0}}{\Break\;}
            Generate a corrected query:\\
            \texttt{corrected\_sql} = \texttt{self\_correct(sql, results)}\;
            Re-execute the corrected query:\\
            \texttt{results} = \texttt{execute\_sql\_api(corrected\_sql)}\;
            \texttt{max\_iter} -= \texttt{1}\;
        }
        \If{correction succeeds and results are valid}{
            Add \texttt{corrected\_sql} and its \texttt{results} to \texttt{result\_dic}\;
            \If{\texttt{results} is a valid string and not empty}{
                Append \texttt{1} to \texttt{error\_rec}\;
                Request additional corrections for remaining queries with similar errors:\\
                \texttt{response} = \texttt{chat\_session.get\_model\_response()}\;
                Parse response into a list of SQL queries \texttt{response\_sqls}\;
                \If{\texttt{len(response\_sqls)} $\geq$ \texttt{len(sqls)/2}}{
                    Replace \texttt{sqls} with \texttt{response\_sqls}\;
                }
            }
        }
        \Else{
            Append \texttt{0} to \texttt{error\_rec}\;
            \If{Too many errors in \texttt{error\_rec}}{\Return \texttt{result\_dic}}
        }
    }
}
\Return \texttt{result\_dic}\;
\end{algorithm}

Algorithm \ref{alg:execute_sql} begins by initializing an empty dictionary to store query results and a list to record errors. It then processes a list of SQL queries sequentially by executing each query and immediately checking the validity of its results. If a query returns an invalid result, the algorithm stores a corrected version of the query along with its result. Otherwise, it enters a self-correction loop where, for a limited number of iterations, it attempts to refine the query by generating a corrected version using a self-correction function and re-executes it. Once a corrected query produces valid results, these are added to the result dictionary. Additionally, if the successful result meets certain conditions (being a non-empty valid string), the algorithm logs this event and, if the error frequency suggests a systemic issue, it replaces a significant portion of the remaining queries with a new set of SQL queries generated from a correction prompt. This iterative process continues until all queries are processed or an excessive number of errors prompts an early termination of the execution loop.

\section{Algorithm for Self-Refinement Workflow for SQL Query Execution}
\begin{algorithm}[ht]
\caption{Self-Refinement for SQL Query Execution}
\label{alg:self_refine}
\KwIn{Input prompts $\mathcal{P}$}
\KwOut{Refined SQL query and results}
\BlankLine
Initialize iteration counter \texttt{itercount} to 0, and empty list \texttt{results\_tables}\;
Construct $\mathcal{P}$ by table information, task description, column exploration, format restriction\;
\While{\texttt{itercount} $<$ \texttt{max\_iter}}{
    Generate the next SQL query from $\mathcal{P}$:\\
    \texttt{response} = \texttt{chat\_session.get\_model\_response()}\;
    Execute the query: \texttt{response} = \texttt{execute\_sql\_api(response, \texttt{api})}\;
    
    \If{\texttt{response} contains valid results}{
        Parse the results as follows:
        \begin{itemize}
            \item Round numeric columns to two decimal places.
            \item Check if nested values, null columns.
        \end{itemize}
        If the results are unique and conform to the expected format, append them to \texttt{results\_tables}\;
        Save the refined query and results to the designated paths\;
        \If{the results appears in \texttt{results\_tables} twice}{
            Satisfy self-consistency\;
            \Break
        }
    }
    \ElseIf{\texttt{response} indicates an error or invalid data}{
        Refine the SQL query by addressing issues such as:
        \begin{itemize}
            \item Missing or empty columns.
            \item Incorrect handling of nested data or sorting constraints.
            \item Syntax errors or invalid API-specific operations.
        \end{itemize}
        Update $\mathcal{P}$ with error feedback and retry the process\;
    }
    
    Increment \texttt{itercount}\;
    
    \If{three or more consecutive errors occur}{
        Terminate the process and discard any incomplete save files\;
    }
}
\If{\texttt{itercount} reaches \texttt{max\_iter}}{
    Discard all incomplete saved files\;
}
\end{algorithm}

Algorithm \ref{alg:self_refine} describes a self-refinement workflow for iteratively generating, executing, and refining SQL queries. It begins by constructing an initial query environment ($\mathcal{P}$) that incorporates input prompts, including table information, task descriptions, column exploration strategies, format restrictions, and API-specific query guidelines. During each iteration, a new SQL query is generated using the chat session model and executed via the specified API. If the query returns valid results, the results are processed by rounding numeric columns to two decimal places and handling nested values. The results are checked for uniqueness and format compliance, and if they satisfy these criteria, they are stored in a results table (\texttt{results\_tables}). Self-consistency is achieved by verifying if the same result appears in \texttt{results\_tables} twice, at which point the process terminates. If errors or invalid data are encountered, the algorithm refines the query by addressing issues such as missing or empty columns, improper handling of nested data, or syntax errors, and retries the process with the updated query. The workflow terminates either when valid results meet self-consistency, when the maximum number of iterations (\texttt{max\_iter}) is reached, or when three consecutive errors occur, ensuring incomplete or invalid outputs are discarded. This structured approach improves robustness and accuracy in SQL query execution.