\section{Background}\label{sec:background}
\begin{figure*}[t]
    \centering
    \includegraphics[width=1.0\textwidth]{Figures/Background.pdf}
    \caption{(a) Querying a Bucket-Brigade (BB) QRAM with capacity $N=8$ takes 25 circuit layers. A detailed step-by-step procedure can be found in Appendix~\ref{subsec:BBdetail}. The circuit layer number indicates the \emph{finishing} time of each stage. (b) Each quantum router in the BB QRAM involves \texttt{CSWAP} operations between the router qubit and the data qubits. (c) H-tree layout of a BB QRAM. Quantum routers are organized in a binary tree structure, where classical data are located at the leaves. Dashed lines indicate external address and bus qubits that are used to query the QRAM. Figure (c) represents the QRAM state after all address qubits have been loaded, corresponding to circuit layer 15 in (a).} 
    \label{fig:bg}
\end{figure*}

\subsection{Emerging Quantum Hardware and Software} 

Quantum algorithms have been shown to provide polynomial or super-polynomial speedups against their best-known classical counterparts on special computational tasks, ranging from quantum chemistry simulations~\cite{lee2021even, berry2019qubitization, van2020convex} to quantum cryptography~\cite{gidney2021factor, shor1994algorithms}. Many of these algorithms, however, rely on the existence of a quantum random access memory (QRAM) device to efficiently query classical or quantum data in superposition, coupled with a quantum processing unit (QPU) with sufficient system size to process the queried data efficiently and fault tolerantly. For example, a classically intractable problem of scientific or industry interests is expected to require hundreds of thousands of high-fidelity qubits \cite{gidney2021factor, beverland2022assessing}.

In recent years, many physical architecture platforms have demonstrated high-quality control over tens or hundreds of qubits. Due to various constraints including connectivity, power, and wiring, it is challenging to scale up these systems as a single monolithic quantum processor. These constraints can be mitigated by a \emph{modular} approach, where small units of special-purpose devices are linked together to form a single quantum processor~\cite{meter2008arithmetic, monroe2014large, nickerson2014freely, alexeev2021quantum}. This modular approach (both in hardware and software) can also simplify manufacturing, control, and maintenance. For example, in superconducting quantum computers, tunable couplers can be connected to bendable cryogenic microwave cables to mediate cross-chip interactions between remote qubits from separate modules. The flexibility of the microwave links allows the system's connectivity to extend beyond planar layouts. More compact on-chip designs have also been demonstrated, but typically have stricter topology constraints to avoid crossing inter-connecting wires. Multi-layer die stacks can alleviate this challenge but require vertical connection using Through-Silicon-Vias (TSVs) \cite{yost2020solid,gambino2015overview,rosenberg20173d,brecht2016multilayer}.

The rapid increment of available qubits and advances in scalable architectures also facilitate the development of quantum algorithms. For example, running multiple algorithms in shared hardware makes it possible for IBM's 1000+ qubit machine to increase hardware utilization~\cite{gambetta2020ibm}. Meanwhile, many quantum algorithms benefit from the novel distributed or multi-core quantum computing architectures, dramatically improving resource efficiency and overall performance~\cite{wu2023qucomm,caleffi2022distributed}.

\subsection{Quantum Queries}
A quantum random access memory implements a quantum query by accessing (classical) memory at multiple addresses in superposition. It realizes the following unitary operation: 
\begin{align}
\sum_{i=0}^{N-1}\alpha_i\ket{i}_{\text{A}}\ket{0}_{\text{B}} &\xrightarrow[]{\text{Query}} \sum_{i=0}^{N-1}\alpha_i\ket{i}_{\text{A}}\ket{x_i}_{\text{B}}\label{eq:qram}
\end{align}
where $\ket{\cdot}_{\text{A}}$ ($\ket{\cdot}_{\text{B}}$) is the address (bus) qubit register storing the input (output), $x_i$ is the data value stored at address $i$, and $\alpha_i$ is the superposition amplitude of address $i$. $N$ is the size of the memory (or QRAM capacity). The number of address and bus qubits, $|A|$ and $|B|$ respectively, are termed the \emph{address width} and \emph{bus width}. For the remainder of the paper, we will assume $|A|=\log(N)$ and $|B|=1$. 

\subsubsection{Overview of Bucket-Brigade QRAM}

We consider BB QRAM, one of the leading quantum query architectures, proposed by Giovannetti et al. in 2008 \cite{giovannetti2008quantum, giovannetti2008architectures}. BB QRAM implements a quantum query to a memory of size $N$ in $O(\log(N))$ time (i.e., circuit layer \cite{amico2023defining}, which is defined as one logical circuit step where all quantum gates inside the same
layer are executed in parallel). BB QRAM is also proven to exhibit superior noise resilience than other architectures, including Fanout QRAM \cite{nielsen2010quantum} and Select-Swap QRAM \cite{low2024trading}.  

The basic building block of a BB QRAM is a \emph{quantum router}. Shown in Fig.~\ref{fig:bg}(b), a quantum router consists of two \texttt{CSWAP} gates acting on four qubits. The two \texttt{CSWAP} gates route an input qubit to either the left or right output qubits in a superposition based on the quantum state of the router qubit which takes one of three states: $\ket{W}$ inactive ``wait'' state routes trivially, $\ket{0}$ routes left, and $\ket{1}$ routes right. BB QRAM recursively concatenates quantum routers initialized to $\ket{W}$ in a binary tree structure. Fig.~\ref{fig:bg}(c) shows BB QRAM in a 2D H-Tree layout \cite{giovannetti2008architectures, xu2023systems}.

\subsubsection{Query Procedure in BB QRAM}

We define four main operations for BB QRAM routers: \texttt{LOAD} (L) qubit through escape, \texttt{TRANSPORT} (T) to next router, \texttt{ROUTE} (R) in current router, and \texttt{STORE} (S) into router qubit. Detailed definitions for each can be found in Appendix~\ref{subsec:BBdetail}.

Using the four operations, BB QRAM realizes quantum queries in three stages: \emph{address loading}, \emph{data retrieval}, and \emph{address unloading}. In address loading, each $i^{\text{th}}$ address qubit is \texttt{LOAD}ed through the escape and then routed to the $i^{\text{th}}$ level of the tree by a series of alternating \texttt{ROUTE} and \texttt{TRANSPORT} operations. The specific path is controlled by the previously routed address qubits stored in higher levels of the tree. Once an address qubit is at the right level, it is \texttt{STORE}d into the routers. Note that each address qubit can be loaded and begin routing before the previous address qubit has been stored since the beginning of the path is independent of the last address qubit; this ``bit-level pipelining'' (to distinguish from ``query-level pipelining'' introduced by this paper in later sections) reduces the total latency through quantum parallelism. After address loading, the fully loaded QRAM stores a superposition of different addresses, where each address activates a distinct root-to-leaf path that is unentangled with the other routers in the $\ket{W}$ state (important for maintaining fidelity).

In the data retrieval stage, the bus qubit is routed to the leaves of the QRAM tree in a procedure similar to address loading (also as part of the ``bit-level pipeline'', i.e., loaded before the last address qubit is stored). All classical memory are copied in parallel to modify the ``delocalized bus qubit'' at the leaves of the QRAM tree. Finally, the bus qubit is routed out of the tree, and the routers are reverted to an all-$\ket{W}$ state through uncomputation, which follows the same steps as address loading but in reverse. A step-by-step description and instruction set can be found in Appendix~\ref{subsec:BBdetail}.

The inherent parallelism in executing both quantum gates and classical queries ensures the BB QRAM has an $O(\log(N))$ latency for address loading (4 circuit layers for storing each address qubit and routing the bus), an $O(1)$ latency for data retrieval (though also a single circuit layer, it is much faster than other gates in practice), and an overall $O(\log(N))$ query latency. We provide a visual description of the query procedure of BB QRAM in Fig.~\ref{fig:bg}(a) and a more detailed version in Appendix~\ref{subsec:BBdetail}.

It has been shown that BB QRAM has intrinsic noise resilience, due to limited entanglement among different paths and restricted propagation of errors. The infidelity of a query is proven to be upper bounded by $O(\epsilon\log^2(N))$, where $\epsilon$ is the error rate of each operation and $N$ is the size of the memory \cite{hann}. Such superior infidelity scaling makes BB QRAM a particularly attractive candidate for implementation before the era of fault tolerance.
