\section{Sketch Style Adjustment}
\label{sec:method_step3}
In Stage 1, we effectively complete the empty areas, but this does not guarantee that the strokes of $\intermediatesketch$ will exhibit global stylistic coherence.
The variety of sketch styles complicates the process of defining appropriate parameterizations that can capture all potential styles.
To address this, we utilize style descriptions extracted from the VLM to guide the style adjustment of $\intermediatesketch$.
Intuitively, we can represent $\intermediatesketch$ in SVG codes and request the VLM to edit the codes to achieve the desired style adjustment.
However, several challenges then arise, given the limitations of existing VLMs.
First, many such VLMs handle only limited numbers of tokens, restricting the number of curves that can be included in $\intermediatesketch$.
Second, such VLMs often hallucinate.
In other words, they may generate strokes absent in $\intermediatesketch$ or delete many genuine strokes in $\intermediatesketch$.

\input{fig_files/vlm_adjust_fig}
To address the abovementioned issues, we request the VLM to generate an executable style adjustment code $\mathcal{C}$ that can operate on $\intermediatesketch$, as illustrated in~\cref{fig:vlm_adjust}.
Specifically, we provide the VLM with the following information:
\begin{itemize}
    \item A preamble that contains the instructions for the task.
    \item A symbolic representation of the style-agnostic completed sketch $\intermediatesketch$ (\eg~SVG code).
    \item The stylized text prompt $\finalprompt$.
    \item A snippet of the skeleton style adjustment code that specifies how to read and write an SVG file, and defines a section for which the VLM should fill in the code for adjustment of $\intermediatesketch$. 
\end{itemize}
The VLM then completes the missing part of the skeleton code snippet, yielding a style adjustment code that specifies how to adjust the newly generated strokes (\eg~stroke width, curvature, or smoothness) to match the style of $\inputsketch$.
For example, the VLM can generate simple code to make the strokes thicker:
\begin{minted}[fontsize=\footnotesize]{python}
def adjust_stroke_style(path_data):
    parsed_path = parse_path(path_data)
    if "bold" in stylized_prompt_lower:
         width_scale_factor *= 1.2   
     for seg in parsed_path:
        seg = seg.width * width_scale_factor
\end{minted}
Meanwhile, the VLM generate the following complex code to simplify the path structures of $\intermediatesketch$:
\begin{minted}[fontsize=\footnotesize]{python}
def adjust_stroke_style(path_data):
    parsed_path = parse_path(path_data)
    enhanced_segments = []
    for seg in parsed_path:
        if isinstance(seg, CubicBezier):
            # Simplify curves by splitting them
            midpoint = seg.point(0.5)
            enhanced_segments.append(\\ 
            Line(start=seg.start, end=midpoint))
            enhanced_segments.append(\\
            Line(start=midpoint, end=seg.end))
    # Smooth paths by reducing unnecessary points
    smoothed_segs = []
    for i in range(len(enhanced_segments) - 1):
        start = enhanced_segments[i].start
        end = enhanced_segments[i + 1].end
        smoothed_segs.append(Line(start=start, end=end))
    # Combine segments into an SVG path string
    enhanced_path = " ".join(seg.d() for seg in \\
                             smoothed_segs)
    return enhanced_path
\end{minted}

Finally, we execute $\mathcal{C}$ on $\intermediatesketch$ to obtain $\completesketch$.
Please see supplement for the details of the preamble we provided to the VLM and other adjustment codes generated by the VLM.


        




