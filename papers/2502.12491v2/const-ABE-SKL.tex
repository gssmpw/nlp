% !TEX root = main.tex

\newcommand{\decryptable}{\mathsf{decryptable}}
\newcommand{\undecryptable}{\mathsf{undecryptable}}


\section{ABE-CR-SKL from LWE}\label{sec:ABE-SKL}
In this section, we show how to achieve ABE-CR-SKL from the LWE assumption.
To this end, we also introduce SKFE-CR-SKL with classical decryption and key-testability.
First, we recall the standard SKFE.

\begin{definition}[Secret-Key Functional Encryption]\label{def:SKFE}
An SKFE scheme $\SKFE$ for the functionality $F: \cX \times
\cY \ra \cZ$ is a tuple of four PPT algorithms $(\Setup, \KG, \Enc, \Dec)$. 
\begin{description}
\item[$\Setup(1^\secp)\ra\msk$:] The setup algorithm takes a security parameter $1^\lambda$, and outputs a master secret key $\msk$.
\item[$\KG(\msk,y)\ra\sk_y$:] The key generation algorithm takes a master secret key $\msk$ and a function $y \in \cY$, and outputs a functional decryption key $\sk_y$.


\item[$\Enc(\msk,x)\ra\ct$:] The encryption algorithm takes a master secret key $\msk$ and a plaintext $x \in \cX$, and outputs a ciphertext $\ct$.

\item[$\Dec(\sk_y,\ct)\ra z$:] The decryption algorithm takes a
functional decryption key $\sk_y$ and a ciphertext $\ct$, and
outputs  $z \in \{ \bot \} \cup \cZ$.

\item[Correctness:] We require that for every $x \in \cX$ and $y\in\cY$, we have that

\[
\Pr\left[
\Dec(\sk_y, \ct) = F(x,y)
 \ :
\begin{array}{rl}
 &\msk \la \Setup(1^\secp)\\
 & \sk_y \gets \KG(\msk,y) \\
 &\ct \gets \Enc(\msk,x)
\end{array}
\right] \ge 1 - \negl(\secp).
\]
\end{description}
\end{definition}




\begin{definition}[Selective Single-Ciphertext Security]\label{def:sel-1ct-SKFE}
We formalize the experiment
$\expb{\SKFE,\qA}{adp}{ind}(1^\secp,\coin)$ between an adversary
$\qA$ and a challenger for an SKFE scheme for the functionality $F:\cX\times\cY\ra\cZ$ as follows:
        \begin{enumerate}
            \item Initialized with $1^\secp$, $\qA$ outputs $(x_0^*,x_1^*)$. The challenger $\Ch$ runs $\msk\gets\Setup(1^\secp)$ and sends $\ct^*\gets\Enc(\msk,x_\coin^*)$ to $\qA$.
            \item $\qA$ can get access to the following oracle.
            \begin{description}
            \item[$\Oracle{\qKG}(y)$:] Given $y$, if $F(x_0^*,y)\ne F(x_1^*,y)$, returns $\bot$. Otherwise, it returns $\sk_y\gets\KG(\msk,y)$.
            \end{description}
            \item $\qA$ outputs a guess $\coin^\prime$ for $\coin$. 
            $\qCh$ outputs $\coin'$ as the final output of the experiment.
        \end{enumerate}
        
We say that $\SKFE$ satisfies selective single-ciphertext security if, for any QPT $\qA$, it holds that
\begin{align}
\advb{\SKFE,\qA}{sel}{1ct}(1^\secp) \seteq \abs{\Pr[\expb{\SKFE,\qA}{sel}{1ct} (1^\secp,0) \ra 1] - \Pr[\expb{\SKFE,\qA}{sel}{1ct} (1^\secp,1) \ra 1] }\le \negl(\secp).
\end{align}
\end{definition}

\begin{theorem}[\cite{C:GorVaiWee12}]\label{thm:1ct_adaptive_function_private_SKFE}
    Assuming the existence of OWFs, there exists selective single-ciphertext secure SKFE.
\end{theorem}


\subsection{Definitions of SKFE-CR-SKL}

We consider the classical decryption property and key-testability for
SKFE-CR-SKL as in the case of SKE-CR-SKL.
\begin{definition}[SKFE-CR-SKL]
An SKFE-CR-SKL scheme $\SKFESKL$ for the functionality $F: \cX \times
\cY \ra \cZ$ is a tuple
of five algorithms $(\Setup,\qKG, \Enc, \allowbreak\qDec,\qVrfy)$.
\begin{description}
%\item[$\Setup(1^\secp,1^{\numkey})\ra\msk$:] The setup algorithm takes a security parameter $1^\lambda$ and a collusion bound $1^{\numkey}$, and outputs a master secret key $\msk$.
\item[$\Setup(1^\secp)\ra\msk$:] The setup algorithm takes a security parameter $1^\lambda$ and a master secret key $\msk$.

\item[$\qKG(\msk,y)\ra(\qsk_y,\vk,\tk)$:] The key generation algorithm
takes a master secret key $\msk$ and a string $y \in \cY$, and
outputs a functional secret key $\qsk_y$, a certificate verification
key $\vk$, and a testing key $\tk$.

\item[$\Enc(\msk,x)\ra\ct$:] The encryption algorithm takes a master
secret key $\msk$ and a string $x \in \cX$, and outputs a ciphertext $\ct$.

\item[$\qDec(\qsk_y,\ct)\ra z$:] The decryption algorithm takes a
functional secret key $\qsk_y$ and a ciphertext $\ct$, and outputs a
value $z \in \cZ \cup \{\bot\}$.

%\item[$\qCert(\qfsk)\ra\cert$:] The certification algorithm takes a function decryption key $\qfsk$, and outputs a classical string $\cert$.

\item[$\qVrfy(\vk,\widetilde{\qsk}_y)\ra\top/\bot$:] The verification algorithm takes a verification key $\vk$ and a (possibly malformed) functional secret key $\widetilde{\qsk}_y$, and outputs $\top$ or $\bot$.

% \item[$\KeyTest(\tk,\sk)\ra\top/\bot$:] The key-testing algorithm takes a key-testing key $\tk$ and a classical secret key $\sk$, and outputs $\top$ or $\bot$.



\item[Decryption correctness:] For all $x\in\cX$ and
$y\in\cY$, we have
\begin{align}
\Pr\left[
\qDec(\qsk_y, \ct) \allowbreak = F(x,y)
\ :
\begin{array}{ll}
\msk\gets\Setup(1^\secp)\\
(\qsk_y,\vk,\tk)\gets\qKG(\msk,y)\\
\ct\gets\Enc(\msk,x)
\end{array}
\right] 
\ge 1-\negl(\secp).
\end{align}
% \begin{enumerate}
% \item Generate $\msk\gets\Setup(1^\secp)$ and $(\qsk,\vk,\tk)\gets\qKG(\msk,y)$, where $\qsk$ is a state over a register $\qreg{SK}$.
% \item Generate $\ct\gets\Enc(\msk,x)$.
% \item Prepare a register $\qreg{OUT}$ that is initialized to $\ket{0\cdots0}_{\qreg{OUT}}$.
% \item Apply the map $\ket{u}_{\qreg{SK}}\ket{w}_{\qreg{OUT}}\ra\ket{u}_{\qreg{SK}}\ket{w\oplus\CDec(u,\ct)}_{\qreg{OUT}}$ to the registers $\qreg{SK}$ and $\qreg{OUT}$.
% \item Measure $\qreg{OUT}$ in the computational basis to get the result $z$.
% \end{enumerate}
% For any strings $x$ and $y$, the probability of the above process resulting in $z=F(x,y)$ is $1-\negl(\secp)$.

%\item[Decryption Robustness:]For any strings $x$ and $y$, we have 
%\begin{align}
%\Exp_{
%\begin{scriptsize}
%\begin{array}{lll}
%\msk\gets\Setup(1^\secp)\\
%(\qsk,\vk,\tk)\gets\qKG(\msk,y)\\
%\ct\gets\Enc(\msk,x)
%\end{array}
%\end{scriptsize}
%}
%\left[
%\Pr\left[
%\exists \sk \textrm{~~such that~~}
%\begin{array}{ll}
%\KeyTest(\tk,\sk)=\top\\
%\CDec(\sk,\ct)\ne F(x,y)
%\end{array}
%\right]
%\right]
%=\negl(\secp).
%\end{align}

\item[Verification correctness:] We have 
\begin{align}
\Pr\left[
\qVrfy(\vk,\qsk_y)=\top
\ :
\begin{array}{ll}
\msk\gets\Setup(1^\secp)\\
(\qsk_y,\vk,\tk)\gets\qKG(\msk,y)
\end{array}
\right] 
\ge1-\negl(\secp).
\end{align}

\end{description}
\end{definition}

\begin{definition}[Classical Decryption Property]\label{def:classical-Dec-SKFE}
We say that $\SKFESKL=(\Setup,\qKG,\Enc,\qDec,\qVrfy)$ has
the classical decryption property if there exists a deterministic
polynomial time algorithm $\CDec$ such that given $\qsk_y$ in the
register $\qreg{SK}$ and ciphertext $\ct$, $\qDec$ applies the map
$\ket{u}_{\qreg{SK}}\ket{v}_{\qreg{OUT}}\ra\ket{u}_{\qreg{SK}}\ket{v\oplus\CDec(u,\ct)}_{\qreg{OUT}}$
and outputs the measurement result of the register $\qreg{OUT}$ in
the computational basis, where $\qreg{OUT}$ is initialized to
$\ket{0\cdots0}_{\qreg{OUT}}$.
\end{definition}
\begin{definition}[Key-Testability]\label{def:key-testability-SKFE}
We say that an SKFE-CR-SKL scheme $\SKFESKL$ with the classical
decryption property satisfies key testability, if there exists a
classical deterministic algorithm $\KeyTest$ that satisfies the
following conditions:

\begin{itemize}
\item \textbf{Syntax:} $\KeyTest$ takes as input a testing key $\tk$
and a classical string $\sk$ as input. It outputs $0$ or $1$.

\item \textbf{Correctness:} Let $\msk\gets\Setup(1^\secp)$ and
$(\qsk_y,\vk,\tk)\gets\qKG(\msk,y)$ where $y$ is a string. We denote the register holding
$\qsk_y$ as $\qreg{SK}$. Let $\qreg{KT}$ be a register that is
initialized to $\ket{0}_{\qreg{KT}}$. If we apply the map
$\ket{u}_{\qreg{SK}}\ket{\beta}_{\qreg{KT}}\ra\ket{u}_{\qreg{SK}}\ket{\beta\oplus\KeyTest(\tk,u)}_{\qreg{KT}}$
to the registers $\qreg{SK}$ and $\qreg{KT}$ and then measure
$\qreg{KT}$ in the computational basis, we obtain $1$ with
overwhelming probability.

\item \textbf{Security:} Consider the following experiment
$\expb{\SKFESKL,\qA}{key}{test}(1^\secp)$.

\begin{enumerate}
\item The challenger $\qCh$ runs $\msk\gets\Setup(1^\secp)$ and
initializes $\qA$ with input $\msk$. 

\item $\qA$ can get access to the following oracle, where the list $\List{\qKG}$ used by the oracles is initialized
to an empty list.
\begin{description}
\item[$\Oracle{\qKG}(y)$:] Given $y$, it finds an entry of the form
$(y,\tk)$ from $\List{\qKG}$. If there is such an entry, it
returns $\bot$.

Otherwise, it generates $(\qsk_y,\vk,\tk)\la\qKG(\msk,y)$, sends
$(\qsk_y,\vk,\tk)$ to $\qA$, and adds $(y,\tk)$ to $\List{\qKG}$.
\end{description}

\item $\qA$ sends a tuple of classical strings $(y, \sk, x)$ to $\qCh$.
$\qCh$ outputs $\bot$ if there is no entry of the form $(y,\tk)$ in $\List{\qKG}$ for some $\tk$.
Otherwise, $\qCh$ generates $\ct\gets\Enc(\msk,x)$, and outputs $\top$ if
$\KeyTest(\tk,\sk)=1$ and $\CDec(\sk,\ct)\ne F(x,y)$, and outputs $\bot$ otherwise.
\end{enumerate}

For all QPT $\qA$, the following must hold:

\begin{align}
\advb{\SKFESKL,\qA}{key}{test}(1^\secp) \seteq
\Pr[\expb{\SKFESKL,\qA}{key}{test}(1^\secp) \ra \top] \le
\negl(\secp).
\end{align} 
\end{itemize}
\end{definition}



\begin{definition}[Selective Single-Ciphertext KLA Security]\label{def:sel-1ct-security_SKFE-SKL}
%\takashi{Renamed from lessor security to IND-CPA security. (Alternatively, should we call it something like IND-KLA (Key Leasing Attack)?)}
We say that an SKFE-CR-SKL scheme $\SKFESKL$ is selective single-ciphertext secure, if
it satisfies the following requirement, formalized from the
experiment $\expc{\SKFESKL,\qA}{sel}{1ct}{kla}(1^\secp,\coin)$
between an adversary $\qA$ and a challenger:

\begin{enumerate}
\item Initialized with $1^\secp$, $\qA$ outputs $(x_0^*,x_1^*)$. The challenger $\qCh$ runs $\msk\gets\Setup(1^\secp)$. 

\item $\qA$ can get access to the following (stateful) oracles,
where the list $\List{\qKG}$ used by the oracles is initialized
to an empty list:

\begin{description}
\item[$\Oracle{\qKG}(y)$:] Given $y$, it finds an entry of the form
$(y,\vk,V)$ from $\List{\qKG}$. If there is such an entry, it
returns $\bot$.

Otherwise, it generates $(\qsk,\vk,\tk)\la\qKG(\msk,y)$, sends
$\qsk$ and $\tk$ to $\qA$, and adds $(y,\vk,\bot)$ to $\List{\qKG}$.

\item[$\Oracle{\qVrfy}(y,\widetilde{\qsk})$:] Given
$(y,\widetilde{\qsk})$, it finds an entry $(y,\vk,V)$ from
$\List{\qKG}$. (If there is no such entry, it returns $\bot$.) It
then runs $\decision \gets \qVrfy(\vk,\widetilde{\qsk})$ and returns
$\decision$ to $\qA$. If $V=\bot$, it updates the entry into
$(y,\vk,\decision)$. 
\end{description}

\item $\qA$ requests the challenge ciphertext. If there exists
an entry $(y,\vk,V)$ in $\List{\qKG}$ such that $F(x_0^*,y)\ne
F(x_1^*,y)$ and $V=\bot$, $\qCh$ outputs $0$ as the
final output of this experiment. Otherwise, $\qCh$ generates
$\ct^*\la\Enc(\msk,x_\coin^*)$ and sends $\ct^*$ to $\qA$.

\item $\qA$ continues to make queries to $\Oracle{\qKG}$. However, $\qA$ is not allowed to send $y$ such that $F(x_0^*,y)\ne F(x_1^*,y)$ to $\Oracle{\qKG}$.

\item $\qA$ outputs a guess $\coin^\prime$ for $\coin$. $\qCh$
outputs $\coin'$ as the final output of the experiment.
\end{enumerate}

For any QPT $\qA$, it holds that

\begin{align}
\advc{\SKFESKL,\qA}{sel}{1ct}{kla}(1^\secp) \seteq \abs{\Pr[\expc{\SKFESKL,\qA}{sel}{1ct}{kla} (1^\secp,0) \ra 1] - \Pr[\expc{\SKFESKL,\qA}{sel}{1ct}{kla} (1^\secp,1) \ra 1] }\leq \negl(\secp).
\end{align} 
\end{definition}

In Appendix \ref{sec:SKFESKL-KT}, we prove the following theorem:

\begin{theorem}
Assuming the existence of a BB84-based SKE-CD scheme and the existence
of OWFs, there exists a selective single-ciphertext KLA secure
SKFE-CR-SKL scheme satisfying the key-testability property.
\end{theorem}

\subsection{Definitions of ABE-CR-SKL}\label{sec:ABE_SKL_def}

In this section, we recall definitions of ABE-CR-SKL by Agrawal et al.~\cite{EC:AKNYY23}.

\begin{definition}[ABE-CR-SKL]
An ABE-CR-SKL scheme $\ABESKL$ is a tuple of five algorithms $(\Setup,
\qKG, \Enc, \qDec,\allowbreak\qVrfy)$.
Below, let $\cX = \{ \cX_\secp \}_\secp$, $\cY= \{ \cY_\secp
\}_\secp$, and $R= \{ R_\secp: \cX_\secp \times \cY_\secp \to \bit
\}_\secp$ be the ciphertext attribute space, the key attribute
space, and the associated relation of $\ABESKL$, respectively. Let
$\cM$ denote the message space.

\begin{description}
\item[$\Setup(1^\secp)\ra(\pk,\msk)$:] The setup algorithm takes a security parameter $1^\lambda$, and outputs a public key $\pk$ and master secret key $\msk$.
\item[$\qKG(\msk,y)\ra(\qsk_y,\vk)$:] The key generation algorithm
    takes a master secret key $\msk$ and a key attribute $y \in
    \calY$, and outputs a user secret key $\qsk_y$ and a verification key $\vk$.

%\footnote{\shota{I don't know whether user secret key is the right name for it.}\ryo{I think it's ok. Another option is simply ``decryption key''.} 
%\shota{OK, I continue to use "user secret key".}}


\item[$\Enc(\pk,x,\msg)\ra\ct$:] The encryption algorithm takes a public key $\pk$, a ciphertext attribute $x\in \cX$, and a plaintext $\msg\in\cM$, and outputs a ciphertext $\ct$.

\item[$\qDec(\qsk_y,\ct)\ra \msg^\prime$:] The decryption algorithm
takes a user secret key $\qsk_y$ and a ciphertext $\ct$. It outputs
a value $\msg^\prime\in \{\bot\}\cup \cM$.

% \item[$\qCert(\qfsk)\ra\cert$:] The certification algorithm takes a function decryption key $\qfsk$, and outputs a classical string $\cert$.

\item[$\qVrfy(\vk,\qsk^\prime)\ra\top/\bot$:] The verification algorithm takes a verification key $\vk$ and a quantum state $\qsk^\prime$, and outputs $\top$ or $\bot$.


\item[Decryption correctness:]For every $x \in \cX$ and $y \in \cY$
satisfying $R(x,y)=0$ and $\msg\in\cM$, we have
\begin{align}
\Pr\left[
\qDec(\qsk_y, \ct) \allowbreak = \msg
\ \middle |
\begin{array}{ll}
(\pk,\msk) \la \Setup(1^\secp)\\
(\qsk_y,\vk)\gets\qKG(\msk,y)\\
\ct\gets\Enc(\pk,x,\msg)
\end{array}
\right] 
\ge1-\negl(\secp).
\end{align}

\item[Verification correctness:] For every $y \in \cY$, we have 
\begin{align}
\Pr\left[
\qVrfy(\vk,\qsk_y)=\top
\ \middle |
\begin{array}{ll}
(\pk,\msk) \la \Setup(1^\secp)\\
(\qsk_y,\vk)\gets\qKG(\msk,y)\\
% \cert \lrun \qCert(\qfsk)
\end{array}
\right] 
\ge1-\negl(\secp).
\end{align}

\end{description}
\end{definition}

\begin{definition}[Adaptive IND-KLA Security]\label{def:ada_lessor_ABESKL}
We say that an ABE-CR-SKL scheme $\ABESKL$ for relation $R:\cX\times
\cY \to \bin$ is adaptively IND-KLA secure, if it satisfies the
following requirement, formalized from the experiment
$\expc{\ABESKL, \qA}{ada}{ind}{kla}(1^\secp,\coin)$ between an
adversary $\qA$ and a challenger $\qCh$:
        \begin{enumerate}
            \item At the beginning, $\qCh$ runs $(\pk,\msk)\gets\Setup(1^\secp)$
            and initializes the list $\List{\qKG}$ to be an empty set. 
            Throughout the experiment, $\qA$ can access the following oracles.
            \begin{description}
            \item[$\Oracle{\qKG}(y)$:] Given $y$, it finds an entry of the form $(y,\vk,V)$ from $\List{\qKG}$. If there is such an entry, it returns $\bot$.
            Otherwise, it generates $(\qsk_y,\vk)\la\qKG(\msk,y)$,
            sends $\qsk_y$ to $\qA$, and adds $(y,\vk,\bot)$ to $\List{\qKG}$.
            %\shota{Maybe we do not have to differentiate the difference between $\bot$ and $\unreturned$.}\ryo{I agree. The definition of PKFE-SKL does not differentiate them.}\shota{I now use the simpler version that does not differentiate them.}
            
            \item[$\Oracle{\qVrfy}(y,\widetilde{\qsk})$:] Given $(y,\widetilde{\qsk})$, it finds an entry $(y,\vk,V)$ from $\List{\qKG}$. (If there is no such entry, it returns $\bot$.) 
            It then runs $\decision \seteq \qVrfy(\vk,
            \widetilde{\qsk})$ and returns $\decision$ to $\qA$.
            If $V=\bot$, it updates the entry into $(y,\vk,\decision)$.
            % \item[$\Oracle{\qKG}(f)$:] Given $f$, the challenger checks if there is an entry $(f,\vk,M)$ in $\List{\qKG}$. If so, the challenger outputs $\bot$. Otherwise, it generates $(\qfsk,\vk)\la\qKG(\msk,f)$, sends $\qfsk$ to $\qA$, and adds $(f,\vk,\notyet)$ to $\List{\qKG}$.
            % \item[$\Oracle{\qVrfy}(f,\qfsk^\prime)$:] Given $(f,\qfsk^\prime)$, it finds an entry $(f,\vk,M)$ from $\List{\qKG}$. (If there is no such entry, it returns $\bot$.) If $M \ne \notyet$, it returns $\mathsf{Verified}$. If $M = \notyet$, it returns $M^\prime \seteq \qVrfy(\vk,\qfsk^\prime)$ and updates the entry into $(f,\vk,M^\prime)$.
            \end{description}
            %\ryo{This is still ambiguity since there are possibly two or more entries such that $(f,\vk_1,M_1) \in \List{\qKG}$ and $(f,\vk_2,M_2)\in \List{\qKG}$. Should we store indices for the same function $f$?}
            \item \label{ada_lessor_abe_challenge}
            When $\qA$ sends $(x^*,\msg_0,\msg_1)$ to $\qCh$, 
            it checks that for every entry $(y,\vk,V)$ in 
            $\List{\qKG}$ such that $R(x^*,y)=0$, it holds
            that $V=\top$. If so,
            $\qCh$ generates $\ct^*\la\Enc(\pk,x^*,\msg_\coin)$ and
            sends $\ct^*$ to $\qA$. Otherwise, it outputs $0$.
            \item 
            $\qA$ continues to make queries to $\Oracle{\qKG}(\cdot)$ and  $\Oracle{\qVrfy}(\cdot,\cdot )$.
            However, $\qA$ is not allowed to send a key attribute
            $y$ such that $R(x^*,y)=0$ to $\Oracle{\qKG}$.
            \item $\qA$ outputs a guess $\coin^\prime$ for $\coin$. 
            $\qCh$ outputs $\coin'$ as the final output of the experiment.
        \end{enumerate}
        For any QPT $\qA$, it holds that
\ifnum\llncs=0        
\begin{align}
\advc{\ABESKL,\qA}{ada}{ind}{kla}(1^\secp) \seteq \abs{\Pr[\expc{\ABESKL,\qA}{ada}{ind}{kla} (1^\secp,0) \ra 1] - \Pr[\expc{\ABESKL,\qA}{ada}{ind}{kla} (1^\secp,1) \ra 1] }\leq \negl(\secp).
\end{align}
\else
\begin{align}
\advb{\PKFESKL,\qA}{ada}{lessor}(\secp) 
&\seteq \abs{\Pr[\expb{\ABESKL,\qA}{ada}{lessor} (1^\secp,0) \ra 1] - \Pr[\expb{\ABESKL,\qA}{ada}{lessor} (1^\secp,1) \ra 1] }\\
&\leq \negl(\secp).
\end{align}
\fi
\end{definition}

\begin{remark}\label{remark:same_query_remark}
Although we can handle the situation where multiple keys for the same attribute $y$ are generated using an index management such as $(y,1,vk_1,V_1)$, $(y,2,vk_2,V_2)$, we use the simplified definition as Agrawal et al.~\cite{EC:AKNYY23} did.\ryo{I avoided copy-and-paste from AKNYY23.}
% In \Cref{def:ada_lessor_ABESKL}, the key generation oracle returns $\bot$ if the same $y$ is queried more than once. To handle the situation where multiple keys for the same attribute $y$ are generated,  we need to manage indices for $y$ such as $(y,1,vk_1,V_1), (y,2,vk_2,V_2)$.
% Although we can reflect the index management in the definition, it complicates the definition and prevents readers from understanding the essential idea.
% Thus, we use the simplified definition above.
\end{remark}

We also consider relaxed versions of the above security notion. 

\begin{definition}[Selective IND-KLA
Security]\label{def:sel_ind_ABE_SKL} We consider the same security
game as that for adaptive IND-KLA security except that the adversary
$\qA$ should declare its target $x^*$ at the beginning of the game
(even before it is given $\pk$).

We then define the advantage
$\advc{\ABESKL,\qA}{sel}{ind}{kla}(1^\secp)$ for the selective case
similarly. We say $\ABESKL$ is selectively IND-KLA secure if for any
QPT adversary $\qA$, $\advc{\ABESKL,\qA}{sel}{ind}{kla}(1^\secp)$ is
negligible.    
\end{definition}



\subsection{Construction}
We construct an ABE-CR-SKL scheme
$\ABESKL=\ABESKL.(\Setup,\qKG,\allowbreak\Enc,\qDec,\qVrfy)$ for the relation
$R$ with the message space $\cM \seteq \bit^{\msglen}$ using the following building blocks.
\begin{itemize}
\item ABE scheme $\ABE=\ABE.(\Setup,\KG,\Enc,\Dec)$ for the following relation $R^\prime$.
\begin{description}
\item[$R^\prime(x^\prime,y^\prime)$:]Interpret $x^\prime\seteq x\|C$ and
    $y^\prime\seteq y\|z$, where $C$ is a circuit. Then, output $0$ if
    $R(x,y)=0$ and $C(z)=\bot$, and otherwise output $1$.
\end{description}

\item Compute-and-Compare Obfuscation $\CCObf$ with the simulator $\CCSim$.
\item SKFE-CR-SKL scheme with key-testability
$\SKFESKL=\SKFESKL.\allowbreak(\Setup,\qKG,\Enc,\qDec,\qVrfy,\allowbreak\KeyTest)$ for
the following functionality $F$. It also has the classical
decryption algorithm $\SKFESKL.\CDec$.

\begin{description}
\item[$F(\widetilde{x},\widetilde{y})$:]Interpret
    $\widetilde{x}\seteq x\|z$ and $\widetilde{y}\seteq y$. Then, output $z$
    if $R(x,y)=0$, and otherwise output $\bot$.
\end{description}

\end{itemize} 

The construction is as follows.

\begin{description}
\item[$\ABESKL.\Setup(1^\secp)$:] $ $
\begin{itemize}
    \item Generate $(\abe.\pk,\abe.\msk)\gets\ABE.\Setup(1^\secp)$.
    \item Generate $\skfe.\msk\gets\SKFESKL.\Setup(1^\secp)$.
    \item Output $\pk\seteq\abe.\pk$ and $\msk\seteq(\abe.\msk,\skfe.\msk)$.
\end{itemize}



\item[$\ABESKL.\qKG(\msk,y)$:] $ $
\begin{itemize}
    \item Parse $\msk=(\abe.\msk,\skfe.\msk)$.
    \item Generate $(\skfe.\qsk,\skfe.\vk,\skfe.\tk)\gets\SKFESKL.\qKG(\skfe.\msk,y)$. We denote the register holding $\skfe.\qsk$ as $\qreg{SKFE.SK}$.
    \item Sample explicit randomness $\key \gets \bit^\secp$.
    \item Prepare a register $\qreg{ABE.SK}$ that is initialized to $\ket{0\cdots0}_{\qreg{ABE.SK}}$.
    \item Apply the map
        $\ket{u}_{\qreg{SKFE.SK}}\ket{v}_{\qreg{ABE.SK}}\ra\ket{u}_{\qreg{SKFE.SK}}\ket{v\oplus\ABE.\KG(\abe.\msk,y\|u,\key)}_{\qreg{ABE.SK}}$ to the registers $\qreg{SKFE.SK}$ and $\qreg{ABE.SK}$, and obtain $\qsk$ over the registers $\qreg{SKFE.SK}$ and $\qreg{ABE.SK}$.
    \item Output $\qsk$ and
        $\vk\seteq(y,\abe.\msk,\skfe.\vk,\skfe.\tk, \key)$.
\end{itemize}



\item[$\ABESKL.\Enc(\pk,x,\msg)$:] $ $
\begin{itemize}
    \item Parse $\pk=\abe.\pk$.
\item Generate $\tlC\gets\CCSim(1^\secp,\pp_D,1)$, where $\pp_D$ consists of circuit parameters of $D$ defined in the security proof.
    \item Generate $\abe.\ct\gets\ABE.\Enc(\abe.\pk,x\|\tlC,\msg)$.
    \item Output $\ct\seteq\abe.\ct$.
\end{itemize}
 
\item[$\ABESKL.\qDec(\qsk,\ct)$:] $ $
\begin{itemize}
   \item Parse $\ct=\abe.\ct$. We denote the register holding $\qsk$ as $\qreg{SKFE.SK}\tensor\qreg{ABE.SK}$.
   \item Prepare a register $\qreg{MSG}$ that is initialized to $\ket{0\cdots0}_{\qreg{MSG}}$
   \item Apply the map $\ket{v}_{\qreg{ABE.SK}}\ket{w}_{\qreg{MSG}}\ra\ket{v}_{\qreg{ABE.SK}}\ket{w\oplus\ABE.\Dec(v,\abe.\ct)}_{\qreg{MSG}}$ to the registers $\qreg{ABE.SK}$ and $\qreg{MSG}$.
   \item Measure the register $\qreg{MSG}$ in the computational basis and output the result $\msg^\prime$.
\end{itemize}


\item[$\ABESKL.\qVrfy(\vk,\qsk^\prime)$:] $ $
\begin{itemize}
    \item Parse $\vk=(y,\abe.\msk,\skfe.\vk,\skfe.\tk, \key)$. We denote the register holding $\qsk^\prime$ as $\qreg{SKFE.SK}\tensor\qreg{ABE.SK}$.
    \item Prepare a register $\qreg{SKFE.KT}$ that is initialized to $\ket{0}_{\qreg{SKFE.KT}}$.
    \item Apply the map $\ket{u}_{\qreg{SKFE.SK}}\ket{\beta}_{\qreg{SKFE.KT}}\ra\ket{u}_{\qreg{SKFE.SK}}\ket{\beta\oplus\SKFESKL.\KeyTest(\skfe.\tk,u)}_{\qreg{SKFE.KT}}$ to the registers $\qreg{SKFE.SK}$ and $\qreg{SKFE.KT}$.
    \item Measure $\qreg{SKFE.KT}$ in the computational basis and
        output $\bot$ if the result is $0$. Otherwise, go to the next step.
    \item Apply the map
        $\ket{u}_{\qreg{SKFE.SK}}\ket{v}_{\qreg{ABE.SK}}\ra\ket{u}_{\qreg{SKFE.SK}}\ket{v\oplus\ABE.\KG(\abe.\msk,y\|u,\key)}_{\qreg{ABE.SK}}$ to the registers $\qreg{SKFE.SK}$ and $\qreg{ABE.SK}$.
    \item Trace out the register $\qreg{ABE.SK}$ and obtain
        $\skfe.\qsk^\prime$ over register $\qreg{SKFE.SK}$.
    \item Output $\top$ if $\top=\SKFESKL.\qVrfy(\skfe.\vk,\skfe.\qsk^\prime)$ and $\bot$ otherwise.

\end{itemize}
\end{description}

\paragraph{Decryption correctness:}
\fuyuki{We require that simulated obfuscated program generated by $\CCSim$ outputs $\bot$ for every input.}
Let $x$ and $y$ be a ciphertext-attribute and a key-attribute,
respectively, such that $R(x,y)=0$. The secret-key
$\qsk$ output by $\ABESKL.\qKG$ is of the form $\sum_u \alpha_u
\ket{u}_{\qreg{SKFE.SK}}\ket{\abe.\sk_{y\|u}}_{\qreg{ABE.SK}}$,
where $\abe.\sk_{y\|u}\gets\ABE.\KG(\abe.\msk,y\|u,\key)$.
Let $\ct\gets\ABESKL.\Enc(\pk,x,\msg)$, where
$\ct=\abe.\ct\gets\ABE.\Enc(\abe.\pk,x\|\tlC,\msg)$ and
$\tlC\gets\CCSim(1^\secp, \pp_D, 1)$.
If we apply the map
\begin{align}
\ket{v}_{\qreg{ABE.SK}}\ket{w}_{\qreg{MSG}}\ra\ket{v}_{\qreg{ABE.SK}}\ket{w\oplus\ABE.\Dec(v,\abe.\ct)}_{\qreg{MSG}}
\end{align}
to $\sum_u \alpha_u \ket{u}_{\qreg{SKFE.SK}}\ket{\abe.\sk_{y\|u}}_{\qreg{ABE.SK}} \tensor \ket{0\cdots0}_{\qreg{MSG}}$, the result is
\begin{align}
\sum_u \alpha_u \ket{u}_{\qreg{SKFE.SK}}\ket{\abe.\sk_{y\|u}}_{\qreg{ABE.SK}} \tensor \ket{\msg}_{\qreg{MSG}}
\end{align}
since $\tlC(u)=\bot$ and thus $R^\prime(x\|\tlC,y\|u)=0$ for every string $u$.
Therefore, $\ABESKL$ satisfies decryption correctness.

\paragraph{Verification correctness.}
Let $y$ be a key attribute and $(\qsk,\vk)\gets\ABESKL.\qKG(\msk,y)$.
It is clear that the state $\skfe.\qsk^\prime$ obtained when computing $\ABESKL.\qVrfy(\vk,\qsk)$ is the same as $\skfe.\qsk$ generated when generating $\qsk$.
Therefore, the verification correctness of $\ABESKL$ follows from that of $\SKFESKL$.

\subsection{Proof of Selective IND-KLA Security}

Let $\qA$ be an adversary for the selective IND-KLA security of $\ABESKL$.
We consider the following sequence of experiments.
\begin{description}
\item[$\hybi{0}^\coin$:]This is $\expc{\ABESKL,\qA}{sel}{ind}{kla}(1^\secp,\coin)$.
\begin{enumerate}
\item $\qA$ declares the challenge ciphertext attribute $x^*$. The
    challenger $\qCh$ generates $(\abe.\pk,\abe.\msk)\gets\ABE.\Setup(1^\secp)$ and $\skfe.\msk\gets\SKFESKL.\Setup(1^\secp)$, and sends $\pk\seteq\abe.\pk$ to $\qA$.

\item $\qA$ can get access to the following (stateful) oracles, where the list $\List{\qKG}$ used by the oracles is initialized to an empty list:

\begin{description}
\item[$\Oracle{\qKG}(y)$:]Given $y$, it finds an entry of the form
$(y,\vk_y,V)$ from $\List{\qKG}$. If there is such an entry, it
returns $\bot$. Otherwise, it generates $\qsk_y, \vk_y$ as follows.

\begin{itemize}
\item Generate $(\skfe.\qsk_y,\skfe.\vk_y,\skfe.\tk_y)\gets\SKFESKL.\qKG(\skfe.\msk,y)$. We denote the register holding $\skfe.\qsk_y$ as $\qreg{SKFE.SK_y}$.

\item Prepare a register $\qreg{ABE.SK_y}$ that is initialized to $\ket{0\cdots0}_{\qreg{ABE.SK_y}}$.

\item Sample explicit randomness $\key_y \gets \bit^\secp$.

\item Apply the map
    $\ket{u}_{\qreg{SKFE.SK_y}}\ket{v}_{\qreg{ABE.SK_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{v\oplus\ABE.\KG(\abe.\msk,y\|u,\key_y)}_{\qreg{ABE.SK_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.SK_y}$, and obtain $\qsk_y$ over the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.SK_y}$.

\item Set $\vk_y\seteq(y,\abe.\msk,\skfe.\vk_y,\skfe.\tk_y, \key_y)$.
\end{itemize}
It returns $\qsk_y$ to $\qA$ and adds the entry $(y,\vk_y,\bot)$ to $\List{\qKG}$.
\item[
$\Oracle{\qVrfy}(y,\widetilde{\qsk})$:] It finds an entry
$(y,\vk_y,V)$ from $\List{\qKG}$. (If there is no such entry, it
returns $\bot$.) It parses
$\vk_y=(y,\abe.\msk,\skfe.\vk_y,\skfe.\tk_y,\key_y)$ and computes
$d$ as follows.  

\begin{itemize}
    \item Let the register holding $\widetilde{\qsk}$ be $\qreg{SKFE.SK_y}\tensor\qreg{ABE.SK_y}$.
    \item Prepare a register $\qreg{SKE.KT_y}$ that is initialized to $\ket{0}_{\qreg{SKE.KT_y}}$.
    \item Apply $\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta}_{\qreg{SKE.KT_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta\oplus\SKFESKL.\KeyTest(\skfe.\tk_y,u)}_{\qreg{SKE.KT_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{SKE.KT_y}$.
    \item Measure $\qreg{SKE.KT_y}$ in the computational basis and
        set $d\seteq\bot$ if the result is $0$. Otherwise, go to the next step.
    \item Apply the map
        $\ket{u}_{\qreg{SKFE.SK_y}}\ket{v}_{\qreg{ABE.SK_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{v\oplus\ABE.\KG(\abe.\msk,y\|u,\key_y)}_{\qreg{ABE.SK_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.SK_y}$.
    \item Trace out the register $\qreg{ABE.SK_y}$ and obtain $\skfe.\qsk^\prime$ over $\qreg{SKFE.SK_y}$.
    \item Set $d\seteq\top$ if $\top=\SKFESKL.\qVrfy(\skfe.\vk_y,\skfe.\qsk^\prime)$ and set $d\seteq\bot$ otherwise.
It returns $d$ to $\qA$. Finally, if $V=\bot$, it updates the entry
$(y,\vk_y,V)$ to $(y,\vk_y,d)$. 
\end{itemize}
\end{description}
\item $\qA$ sends $(\msg_0^*,\msg_1^*)\in \cM^2$ to
$\qCh$. $\qCh$ checks if for every entry $(y, \vk_y, V)$ in
$L_{\qKG}$ such that $R(x^*,y) = 0$, it holds that $V = \top$. If
so, it generates $\tlC^*\gets\CCSim(1^\secp, \pp_D, 1)$ and
$\abe.\ct^*\gets\ABE.\Enc(\abe.\pk,x^*\|\tlC^*,\allowbreak\msg_\coin^*)$, and
sends $\ct^*\seteq\abe.\ct^*$ to $\qA$. Otherwise, it outputs $0$.

\item $\qA$ outputs $\coin^\prime$. The challenger outputs $\coin'$
as the final output of the experiment.
\end{enumerate}
        
\item[$\hybi{1}^\coin$:]This is the same as $\hybi{0}^\coin$ except
that $\tlC^*$ is generated as
$\tlC^*\gets\CCObf(1^\secp,D[\skfe.\ct^*], \lock, 0)$, where $\skfe.\ct^*\gets\SKFESKL.\Enc(\skfe.\msk,\allowbreak x^*\|0^\secp)$, $\lock\gets\bit^\secp$, and $D[\skfe.\ct^*](x)$ is a circuit that has $\skfe.\ct^*$ hardwired and outputs $\SKFESKL.\CDec(x,\skfe.\ct^*)$.
\end{description}

We pick $\lock$ as a uniformly random string that is completely independent of other variables such as $\skfe.\ct^*$.
Thus, from the security of $\CCObf$, we have $\abs{\Pr[\hybi{0}^\coin=1]-\Pr[\hybi{1}^\coin=1]}=\negl(\secp)$.

\begin{description}
\item[$\hybi{2}^\coin$:]This is the same as $\hybi{1}^\coin$ except
that $\skfe.\ct^*$ hardwired into the circuit $D$ is generated
as $\skfe.\ct^*\gets\SKFESKL.\Enc(\skfe.\msk,x^*\|\lock)$.
\end{description}

\fuyuki{$\qA$ returns every key for a key attribute $y$ such that $R(x^*,y)=\decryptable$. On the other hand, for any key attirbute $y$ such that $R(x^*,y)=\undecryptable$, $F(x^*\|\lock,y)=F(x^*\|0^\secp,y)=\bot$. Then, we can invoke the OT-IND-KLA security of $\SKFESKL$.}

From the selective single-ciphertext security of $\SKFESKL$, we can show that
$\hybi{1}^\coin \approx \hybi{2}^\coin$. Suppose that $\Hyb_1^\coin
\not \approx \Hyb_2^\coin$ and $\qD$ is a corresponding
distinguisher. We consider the following reduction
$\qR$:

\begin{description}
\item Execution of $\qR^{\qD}$ in
$\expc{\SKFESKL,\qR}{sel}{1ct}{kla}(1^\secp, b)$:

\begin{enumerate}
\item $\qCh$ runs $\skfe.\msk \gets \SKFESKL.\Setup(1^\secp)$ and initializes $\qR$
with the security parameter $1^\secp$.

\item $\qD$ declares the challenge ciphertext-attribute $x^*$. $\qR$
generates $(\abe.\pk, \abe.\msk) \gets \ABE.\Setup(1^\secp)$ and
sends $\ek \seteq \abe.\pk$ to $\qD$.

\item $\qR$ chooses $\lock \chosen \zo{\secp}$ and sends $(\skfe.\msg_0^*,
\skfe.\msg_1^*) \seteq (x^* \| 0^\secp, x^* \| \lock)$ to $\qCh$.

\item $\qR$ simulates the access to $\Oracle{\qKG}(y)$ for $\qD$ as
    follows, where $L_{\qKG}$ is a list initialized to be empty:
\begin{description}
\item $\Oracle{\qKG}(y):$ Given $y$, it finds an entry of the
form $(y, \vk_y, V)$ from $L_{\qKG}$. If there is such an entry,
it returns $\bot$. Otherwise, it generates $(\qsk_y, \vk_y)$ 
similar to $\Hyb_0^\coin$ except that the values
$(\skfe.\qsk_y, \skfe.\vk_y, \skfe.\tk_y)$ are generated as
$(\skfe.\qsk_y,
\skfe.\vk_y, \skfe.\tk_y) \gets \SKFESKL.\Oracle{\qKG}(y)$ instead.
It adds $(y, \vk_y, \bot)$ to $L_{\qKG}$ and returns $\qsk_y$.
\end{description}

\item $\qR$ simulates the access to $\Oracle{\qVrfy}(y,
\widetilde{\qsk})$ as follows:
\begin{description}
\item $\Oracle{\qVrfy}(y, \widetilde{\qsk}):$ Given $(y,
\widetilde{\qsk})$, it finds an entry $(y, \vk_y, V)$ from
$L_{\qKG}$ (If there is no such entry, it returns $\perp$). It then
executes a procedure similar to that in $\Hyb_0^\coin$, except that $\SKFESKL.\Oracle{\qVrfy}(y,
\skfe.\qsk')$ is executed instead of $\SKFESKL.\qVrfy(\skfe.\vk_y,
\skfe.\qsk')$. The corresponding output $d$ is returned as the
output of the oracle.
\end{description}
\item $\qR$ requests the challenge ciphertext from $\qCh$ and receives
$\skfe.\ct^* \gets \SKFESKL.\Enc(\skfe.\msk, \skfe.\msg^*_b)$.
\item $\qD$ sends $(\msg_0^*, \msg_1^*) \in \cM^2$ to $\qR$. $\qR$
checks that for every entry $(y,\vk_y,V)$ such that $R(x^*,y)=0$, it
holds that $V = \top$. If so, it
generates $\tlC^* \gets \CCObf(1^\secp, D[\skfe.\ct^*], \lock, 0)$
and $\abe.\ct^* \gets \ABE.\Enc(\abe.\pk, x^* \| \tlC^*, \msg^*_\coin)$ and
sends $\ct^* \seteq \abe.\ct^*$ to $\qD$. Else, it outputs $0$.
\item $\qD$ outputs a bit $b'$. $\qR$ outputs $b'$ and $\qCh$
outputs $b'$ as the final output of the experiment.
\end{enumerate}
\end{description}

It is easy to see that the view of $\qD$ is the same as that in
$\Hyb^\coin_2$ when $\lock$ is encrypted in $\skfe.\ct^*$ and that
of $\Hyb^\coin_1$ when $0^\secp$ is encrypted. Moreover, for $\qD$
to distinguish between the two hybrids, it must be the case that
$V = \top$ for all entries $(y, \vk_y, V)$ such that $R(x^*, y) =
0$, which directly implies that the analogous values checked by
$\SKFESKL.\Oracle{\qVrfy}$ must also be $\top$. If $R(x^*,y)=1$, $F(x^*\concat 0^\secp,y)=F(x^*\concat \lock,y)=\bot$.  Consequently,
$\qR$ breaks the selective single-ciphertext security of $\SKFESKL$. Therefore, it
must be that $\Hyb_1^\coin \approx \Hyb_2^\coin$.

\begin{description}
\item[$\hybi{3}^\coin$:]This is the same as $\hybi{2}^\coin$ except that $\Oracle{\qKG}$ behaves as follows. (The difference is red colored.)

\begin{description}
\item[$\Oracle{\qKG}(y)$:]Given $y$, it finds an entry of the form
$(y,\vk_y,V)$ from $\List{\qKG}$. If there is such an entry, it
returns $\bot$. Otherwise, it generates $\qsk_y, \vk_y$ as follows.

\begin{itemize}
\item Generate $(\skfe.\qsk_y,\skfe.\vk_y,\skfe.\tk_y)\gets\SKFESKL.\qKG(\skfe.\msk,y)$. We denote the register holding $\skfe.\qsk_y$ as $\qreg{SKFE.SK_y}$.
    \textcolor{red}{
        \item Prepare a register $\qreg{ABE.R^\prime_y}$ that is initialized to $\ket{0}_{\qreg{ABE.R^\prime_y}}$.
    \item Apply the map $\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta}_{\qreg{ABE.R^\prime_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta\oplus R^\prime(x^*\|\tlC^*,y\|u)}_{\qreg{ABE.R^\prime_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.R^\prime_y}$.
    \item Measure $\qreg{ABE.R^\prime_y}$ in the computational basis
        and output $\bot$ if the result is $0$. Otherwise, go to the next step.
    }

\item Prepare a register $\qreg{ABE.SK_y}$ that is initialized to $\ket{0\cdots0}_{\qreg{ABE.SK_y}}$.

\item Sample explicit randomness $\key_y \gets \bit^\secp$.

\item Apply the map
    $\ket{u}_{\qreg{SKFE.SK_y}}\ket{v}_{\qreg{ABE.SK_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{v\oplus\ABE.\KG(\abe.\msk,y\|u,\key_y)}_{\qreg{ABE.SK_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.SK_y}$, and obtain $\qsk_y$ over the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.SK_y}$.

\item Set $\vk_y\seteq(y,\abe.\msk,\skfe.\vk_y,\skfe.\tk_y, \key_y)$.
\end{itemize}
It returns $\qsk_y$ to $\qA$ and adds the entry $(y,\vk_y,\bot)$ to $\List{\qKG}$.
\end{description}
\end{description}

With overwhelming probability, we observe that the added procedure that checks
$R^\prime(x^* \| \tlC^*,y \| u)$ in superposition affects the final state $\qsk_y$ at most negligibly.
We consider the following two cases.
\begin{itemize}
\item The first case is where $R(x^*,y)=1$. In this case, we have
    $R^\prime(x^*\|\tlC^*,y\|u)=1$ for any $u$.
Hence, we see that the added procedure does not affect the state $\skfe.\qsk_y$.
\item The second case is where $R(x^*,y)=0$. Let
$\skfe.\qsk_y=\sum_u \alpha_u \ket{u}_{\qreg{SKFE.SK_y}}$. From
the classical decryption property of $\SKFESKL$, we have that for
any $u$, it holds that
$\SKFESKL.\CDec(u,\skfe.\ct^*)=\lock$. Thus, $\tlC^*(u)\ne\bot$ and
$R^\prime(x^*\|\tlC^*,y\|u)=1$ with overwhelming probability from
the correctness of $\CCObf$. Hence, we see that the added procedure affects the state $\skfe.\sk_y$ at most negligibly.
\end{itemize}
Therefore, we have $\abs{\Pr[\hybi{2}^\coin=1]-\Pr[\hybi{3}^\coin=1]}=\negl(\secp)$.

\begin{description}
\item[$\hybi{4}^\coin$:]This is the same as $\hybi{3}^\coin$ except that the oracle $\Oracle{\qVrfy}$ behaves as follows. (The difference is red colored.)
\begin{description}
\item[ $\Oracle{\qVrfy}(y,\widetilde{\qsk})$:] It finds an entry
    $(y,\vk_y,V)$ from $\List{\qKG}$. (If there is no such entry, it
    returns $\bot$.) It parses
    $\vk_y=(y,\abe.\msk,\skfe.\vk_y,\skfe.\tk_y,\key_y)$. If
    $R(x^*, y) = 1$, then it behaves exactly as in $\Hyb^\coin_3$
    and otherwise, it computes $d$ as follows:
    \begin{enumerate}[(a)]
    \item Let the register holding $\widetilde{\qsk}$ be $\qreg{SKFE.SK_y}\tensor\qreg{ABE.SK_y}$.
    \item Prepare a register $\qreg{SKFE.KT_y}$ that is initialized to $\ket{0}_{\qreg{SKFE.KT_y}}$.
    \item Apply $\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta}_{\qreg{SKFE.KT_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta\oplus\SKFESKL.\KeyTest(\skfe.\tk_y,u)}_{\qreg{SKFE.KT_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{SKFE.KT_y}$.
    \item Measure $\qreg{SKFE.KT_y}$ in the computational basis and
        set $d\seteq\bot$ if the result is $0$. Otherwise, go to the next step.
    \textcolor{red}{
    \item Prepare a register $\qreg{ABE.R^\prime_y}$ that is initialized to $\ket{0}_{\qreg{ABE.R^\prime_y}}$.
    \item Apply the map $\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta}_{\qreg{ABE.R^\prime_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{\beta\oplus R^\prime(x^*\|\tlC^*,y\|u)}_{\qreg{ABE.R^\prime_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.R^\prime_y}$.
    \item Measure $\qreg{ABE.R^\prime_y}$ in the computational basis and set $d\seteq\bot$ if the result is $0$. Otherwise, go to the next step.
    }
    \item Apply the map
        $\ket{u}_{\qreg{SKFE.SK_y}}\ket{v}_{\qreg{ABE.SK_y}}\ra\ket{u}_{\qreg{SKFE.SK_y}}\ket{v\oplus\ABE.\KG(\abe.\msk,y\|u,\key)}_{\qreg{ABE.SK_y}}$ to the registers $\qreg{SKFE.SK_y}$ and $\qreg{ABE.SK_y}$.
    \item Trace out the register $\qreg{ABE.SK_y}$ and obtain $\skfe.\qsk^\prime$ over $\qreg{SKFE.SK_y}$.
    \item Set $d\seteq\top$ if $\top=\SKFESKL.\qVrfy(\skfe.\vk_y,\skfe.\qsk^\prime)$ and set $d\seteq\bot$ otherwise.
It returns $d$ to $\qA$. Finally, if $V=\bot$, it updates the entry $(y,\vk_y,V)$ into $(y,\vk_y,d)$. 
\end{enumerate}
            \end{description}
\end{description}

%The procedure add at $\hybi{4}^\coin$ that checks $R^\prime(x^*\|\tlC^*,y\|u)$ in superposition affects the %response at most negligibly.
%We can immediately see it if the query $(y,\widetilde{\qsk})$ satisfies $R(x^*,y)=\undecryptable$ similarly %to the analysis of the previous change.
%We consider the case where the query $(y,\widetilde{\qsk})$ satisfies $R(x^*,y)=\decryptable$.
%Suppose the measurement result of $\qreg{SKFE.KT_y}$ computed by $\Oracle{\qVrfy}$ is $\top$.
%From the decryption robustness of $\SKFESKL$, we can write the post measurement state as
%\begin{align}
%\sum_{u\textrm{~~s. t.~~}\SKFESKL.\KeyTest(\tk_y,u)=\top} \alpha_u %\ket{u}_{\qreg{SKFE.SK_y}}\ket{\phi_u}_{\qreg{ABE.SK_y}}
%&=\sum_{u\textrm{~~s. t.~~}\SKFESKL.\CDec(u,\ct^*)=\lock} \alpha_u %\ket{u}_{\qreg{SKFE.SK_y}}\ket{\phi_u}_{\qreg{ABE.SK_y}}.
%\end{align}
%From the correctness of $\CCObf$, this state is negligibly close to
%\begin{align}
%\sum_{u\textrm{~~s. t.~~}R^\prime(x^*\|\tlC^*,y\|u)=1} %\alpha_u\ket{u}_{\qreg{SKFE.SK_y}}\ket{\phi_u}_{\qreg{ABE.SK_y}}
%\end{align}
%with overwhelming probability.
%We see that the added process does not affect this state at all.
%Therefore, we have $\abs{\Pr[\hybi{3}^\coin=1]-\Pr[\hybi{4}^\coin=1]}=\negl(\secp)$.
%
%If $j = j^\star$,
%    measure $\qreg{SKE.SK_y}$ in the computational basis to get a
%    value $\sk$ and send $(\sk, y, \lock)$ to $\qCh$.

Suppose there exists a QPT distinguisher $\qD$ that has
non-negligible advantage in distinguishing $\Hyb_3^\coin$ and
$\Hyb_4^\coin$. Let $\qD$ make $q = \poly(\lambda)$ many queries to
the oracle $\Oracle{\qVrfy}(\cdot, \cdot)$. We will now consider the
following QPT algorithm $\qA_\oh$ with access to an oracle
$\widetilde{\Oracle{\qKG}}$ and an oracle $\cO$ that runs $\qD$ as follows:

\begin{description}
\item $\underline{\qA_\oh^{\widetilde{\Oracle{\qKG}}, \cO}(\abe.\pk,
\skfe.\msk)}:$
\begin{enumerate}
\item $\qA_\oh$ runs $\qD$ who sends the challenge ciphertext-attribute
$x^*$ to $\qA_\oh$.
\item $\qA_\oh$ sends $\ek = \abe.\pk$ to $\qD$ and initializes $L_{\qKG}$
to be an empty list.
\item When $\qD$ queries $\Oracle{\qKG}$ on input $y$, $\qA_\oh$ queries
the oracle $\widetilde{\Oracle{\qKG}}(y)$ in order to obtain its
response $\ket{\phi}$ and a list $\widetilde{L_{\qKG}}$. It updates
$L_{\qKG} = \widetilde{L_{\qKG}}$. It sends $\ket{\phi}$ to $\qD$.
\item $\qA_\oh$ simulates the access of $\Oracle{\qVrfy}$ for $\qD$ as
follows:
\begin{description}
\item $\underline{\Oracle{\qVrfy}(y, \widetilde{\qsk})}:$
\begin{enumerate}
\item Execute Steps (a)-(e) of $\Oracle{\qVrfy}$ as in
    $\Hyb_4^\coin$.
    \item Apply the map
        $\ket{u}_{\qreg{SKE.SK_y}}\ket{\beta}_{\qreg{ABE.R_y}}\ra\ket{u}_{\qreg{SKE.SK_y}}\ket{\beta\oplus
        \calO(u)}_{\qreg{ABE.R_y}}$ to the registers
        $\qreg{SKE.SK_y}$ and $\qreg{ABE.R_y}$. 
\item Execute Steps (g)-(j) of $\Oracle{\qVrfy}$ as in
$\Hyb_4^\coin$.
\end{enumerate}
\end{description}

\item $\qD$ sends $(\msg_0^*, \msg_1^*) \in \cM^2$ to $\qA_\oh$. $\qA_\oh$ checks if
for every entry $(y, \vk_y, V)$ in $L_{\qKG}$ such that $R(x^*, y) =0$, it holds that $V = \top$. If so, it generates
$\tlC^*\gets\CCObf(1^\secp,D[\skfe.\ct^*], \lock, 0)$
 and $\abe.\ct^* \gets \ABE.\Enc(\abe.\pk, x^* \|
\tlC^*, \msg^*_\coin)$, where $\skfe.\ct^* = \SKFESKL.\Enc(\skfe.\msk,
x^* \| 0^\secp) $and sends $\ct^* \seteq \abe.\ct^*$ to $\qD$.
Otherwise, it outputs $0$.
\item $\qD$ outputs a guess $b'$. $\qA_\oh$ outputs $b'$.
\end{enumerate}
\end{description}

Let $H$ be an oracle that for every input $u$, outputs $1$.
Consider now the extractor $\qB_\oh^{\widetilde{\Oracle{\qKG}}, H}$
as specified by the O2H Lemma (Lemma \ref{lem:O2H}). We will now
construct a reduction $\qR$ that runs $\qB_\oh$ by simulating the oracles
$\widetilde{\Oracle{\qKG}}$ and $H$ for $\qB_\oh$, and breaks
key-testability of the $\SKFESKL$ scheme.

\begin{description}
\item Execution of $\qR$ in
$\expb{\SKFESKL,\qR}{key}{test}(1^\secp)$:

\begin{enumerate}
\item The challenger $\qCh$ runs $\skfe.\msk \leftarrow
\SKFESKL.\Setup(1^\secp)$ and
initializes $\qR$ with input $\skfe.\msk$.
\item $\qR$ samples $(\abe.\pk, \abe.\msk) \gets
\ABE.\Setup(1^\secp)$ and initializes $\qB_\oh$ with the input
$(\abe.\pk, \skfe.\msk)$.
\item $\qR$ simulates the access to $\widetilde{\Oracle{\qKG}}(y)$ for $\qB$ as
follows, where $L_{\qKG}$ is a list initialized to be empty:
\begin{description}
\item $\widetilde{\Oracle{\qKG}}(y):$ Given $y$, it finds an entry of the
form $(y, \vk_y, V)$ from $L_{\qKG}$ (If there is such an entry,
it returns $(\bot, L_{\qKG})$). Otherwise, it generates $(\qsk_y, \vk_y)$ 
similar to $\Hyb_3^\coin$.
It adds $(y, \vk_y, \bot)$ to $L_{\qKG}$ and returns $(\qsk_y,
L_{\qKG})$.
\end{description}

\item When $\qB_\oh$ queries an input $u$ to $H$, $\qR$ responds with $1$.

\item $\qB_\oh$ outputs values $y$ and $\sk$. $\qR$ sends $(\sk, y,
\lock)$ to $\qCh$.

\end{enumerate}
\end{description}

We will now claim that with non-negligible probability, $\qR$ obtains
values $\sk$ and $y$ such that $R'(x^* \| \tlC^*,y \| \sk) = 0$.  Recall that
the hybrids differ only when $R(x^*, y) = 0$.  By the definition of
$R'$ and $\tlC^*$ and the decryption correctness of $\SKFESKL$, this
will imply that $\SKFESKL.\CDec(\sk, \skfe.\ct^\star) \neq
F(x^*\|\lock,y)$ since $F(x^* \| \lock, y) = \lock$, and $R'(x^* \| \tlC^*,y \| \sk) = 0$ requires $\tlC^*(\sk)=\bot$. Moreover,
$\KeyTest(\skfe.\tk_y, \sk)$ also holds. Consequently, this will imply
$\qR$ breaks the key-testability of $\SKFESKL$. To prove this, we will
rely on the One-Way to Hiding (O2H) Lemma (Lemma \ref{lem:O2H}).
Consider an oracle $G$ which takes as input $u$ and outputs $R'(x^* \|
\tlC^\star, y\|u)$ and an oracle $H$ which takes as input $u$ and
outputs $1$. Notice that if the oracle $\calO = G$, then the view of
$\qD$ as run by $\qA_\oh$ is the same as in $\Hyb_4^\coin$, while if $\calO = H$, the view
of $\qD$ is the same as in $\Hyb_3^\coin$. By the O2H Lemma, we
have the following, where $z = (\abe.\pk, \skfe.\msk)$.

\begin{align}
\abs{\Pr[\qA_\oh^{\widetilde{\Oracle{\qKG}},
H}(z)=1]-\Pr[\qA_\oh^{\widetilde{\Oracle{\qKG}}, G}(z)=1]} \leq
2q\cdot\sqrt{\Pr[\qB_\oh^{\widetilde{\Oracle{\qKG}}, H}(z)\in S]}
\enspace.
\end{align}
where $S$ is a set where
the oracles $H$ and $G$ differ, which happens only for inputs $u$ s.t.
$R'(x^*\|\tlC^\star, y\|u) = 0$. Since $\qR$ obtains $\sk$ and $y$ as the
output of $\qB_\oh^{\widetilde{\Oracle{\qKG}},H}(z)$, the argument
follows that $\Hyb_3^\coin \approx \Hyb_4^\coin$.

\begin{description}
\item[$\hybi{5}^\coin$:]This is the same as $\hybi{4}^\coin$ except that $\ct^*\seteq\abe.\ct^*$ is generated as $\abe.\ct^*\gets\ABE.\Enc(\abe.\pk,x^*\|\tlC^*,0^{\msglen})$.
\end{description}

The view of $\qA$ in $\hybi{4}^\coin$ and $\hybi{5}^\coin$ can be simulated with $\abe.\pk$ and the access to the quantum key generation oracle $\Oracle{qkg}$.
This is because before $\ABE.\KG$ is required to be applied in the
simulation of oracles $\Oracle{\qKG}$ and $\Oracle{\qVrfy}$, the
relation check $R'(x^* \| \tlC^\star, y\|u)$ is already applied in
superposition.
Thus, we have $\abs{\Pr[\hybi{4}^\coin=1]-\Pr[\hybi{5}^\coin=1]}=\negl(\secp)$.

Lastly, $\hybi{5}^{0}$ and $\hybi{5}^{1}$ are exactly the same experiment and thus we have $\abs{\Pr[\hybi{5}^0=1]-\Pr[\hybi{5}^1=1]}=\negl(\secp)$.
Then, from the above arguments, we obtain
\begin{align}
&\abs{\Pr[\expc{\ABESKL,\qA}{sel}{ind}{kla}(1^\secp,0)=1]-\expc{\ABESKL,\qA}{sel}{ind}{kla}(1^\secp,1)=1]}\\
=&\abs{\Pr[\hybi{0}^0=1]-\Pr[\hybi{0}^1=1]}\le\negl(\secp).
\end{align}
This completes the proof. \qed

Recall now that SKFE-CR-SKL with Key-Testability is implied by
BB84-based SKE-CD, OWFs and adaptively single-ciphertext
function-private SKFE. Since this notion of SKFE is implied by OWFs
(Theorem \ref{thm:1ct_adaptive_function_private_SKFE}), we have that
SKFE-CR-SKL with Key-Testability is implied by LWE. Since,
Compute-and-Compare Obfuscation and quantum-secure Ciphertext-Policy
ABE for Circuits are both implied by LWE, this gives us the 
following theorem:

\begin{theorem}
There exists an ABE-CR-SKL scheme satisfying Selective IND-KLA
security, assuming the polynomial hardness of the LWE assumption.
\end{theorem}


