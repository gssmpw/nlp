We applied Recurrency Sequence Processing to address the lack of consistency in the coarse dance representation of the~\cite{li2024lodge} model. We named this Recurrency Sequence Representation Learning as Dance Recalibration (DR). Dance recalibration uses \(n\) Dance Recalibration Blocks (DRB) corresponding to the length of the rough dance sequence to add sequential information to the rough dance representation to improve the consistency of the whole dance. The overall structure of our model is illustrated in Figure 1.

\begin{figure}[!t]
    \centering
    \includegraphics[width=\textwidth]{Figure1.eps}
    \caption{overall procedure of Pooling processing by our Pooling Block}
    \label{fig:enter-label4}
\end{figure}


\subsection{Dance Recalibration (DR)}
When the dance motion representation passes through the Dance Decoder Process using the~\cite{li2024lodge} model, it yields a coarse dance motion representation. During this process, the dance motion representations that pass through Global Diffusion follow a distribution but can output unstable values. This results in awkward dance motions when viewed from a sequential perspective. To address this issue, we added a Dance Recalibration Process.

DR fundamentally follows a structure similar to RNNs. Although RNNs are known to suffer from the gradient vanishing problem as they get deeper, the sequence length of the coarse dance representation in \cite{li2024lodge} is not long enough to cause this issue, making it suitable for use. Using LSTM or GRU, which solve the gradient vanishing problem, would make the model too complex and computationally expensive, making them unsuitable for use with the Denoising Diffusion Process \cite{ho2020denoising, song2020denoising}.

The coarse dance representation has 139 channels, consisting of 4-dim foot positions, 3-dim root translation, 6-dim rotaion information and 126-dim joint rotation channels. Of these, the 126-dim channels directly impact the dance motion, and all DR operations are performed using these 126 channels.

The values output from the Global Dance Decoder \(GD_{i}\), contain unstable dance motion information that follows a distribution. We construct Global Recalibrated Dance \(GRD_{i}\) by concatenating \(C\) the information from \(GRD_{i-1}\) with \(GD_{i}\) and applying pooling \(P\), thereby adding sequential information. However, using previous information as is may result in overly simple and smoothly connected dance motions. To prevent this, we add Gaussian noise \(G\) to the previous information \(GRD_{i-1}\) to produce more varied dance motions. This process is represented in Equations 1 below. The entire procedure is illustrated in Figure 2, 3.
\begin{equation}
    GRD_{i} = P(C(GD_{i} , GRD_{i-1} + G(Threshold))
\end{equation}



\begin{figure}[!t]
    \centering
    \includegraphics[width=\textwidth]{DanceRecalibration.eps}
    \caption{Overall of the Dance Recalibration Block Structure}
    \label{fig:enter-label1}
\end{figure}

\begin{figure}[!t]
    \centering
    \includegraphics[width=\textwidth]{DanceRecalibrationBlock.eps}
    \caption{The structure of the dance recalibration block}
    \label{fig:enter-label2}
\end{figure}

\subsection{Pooling Block}
Pooling \(P\) uses a simple pooling method. When \(GRD_{i}\) with added \(G\) and \(GD_{i+1}\) are input, they are concatenated into a \((Batch\times2\times126)\). First, we perform Layer Normalization to minimize differences between layers. Then, we pass through three simple 1D-Convolution Blocks, each followed by an activation function and batch normalization, to construct \(GRD_{i+1}\) that includes information from the previous dance motion. This procedure is illustrated in Figure 4.

\begin{figure}[!t]
    \centering
    \includegraphics[width=\textwidth]{Figure3.eps}
    \caption{overall procedure of Pooling processing by our Pooling Block}
    \label{fig:enter-label3}
\end{figure}

By following all these steps, each dance motion incorporates a bit of information from the previous dance motions, producing an overall coarse dance motion that follows the distribution of Global Diffusion while also retaining sequential information. This process is expressed in Equation 2:

\begin{equation}
    Total Coarse Dance Motion = C_{i=1}^{n}(P(C(GD_{i} , GRD_{i-1} + G(Threshold))), P(GD_{0}))
\end{equation}

We did not use bi-directional information because it complicates the calculations and can destabilize sequential information when using more than two \(GD_{i}\). Since there is a trade-off between generating complex dance motions and maintaining consistency, it is crucial to add appropriate noise. However, due to time constraints, we could not conduct various ablation studies.