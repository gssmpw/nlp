\section{Background}
\label{sec:background}

While SciML is becoming increasingly used in \CSE{}, it differs fundamentally from \CSE{} in predicting system behavior. Traditional \CSE{} follows a deductive approach, deriving mathematical equations from conservation laws and physical properties to describe system causality.
Moreover, \CSE{} is used to predict the behavior of complex systems that are difficult or impossible to study experimentally~\cite{ruede2018research}.
In contrast, ML is an inductive discipline that learns relationships, potentially non-causal, directly from data or existing numerical models~\cite{Ruden_et_alAIDA_2020}.
SciML is a subset of ML and is an interdisciplinary field aimed at accelerating scientific and engineering discoveries.
While ML was once used only to help identify patterns in data from scientific instruments and sensors, SciML has evolved beyond data analysis to accelerate diverse scientific tasks, as discussed in the next section.

\subsection{Scope}
\label{sec:scope}

This paper focuses on SciML that enhances computational modeling and simulation of physical systems. Specifically, we address SciML approaches that support computational workflows where a model must be evaluated repeatedly within larger algorithmic procedures. In scientific computing, these are known as ``outer-loop'' processes because they form an additional computational layer that wraps around the core model solution. Such processes include:
(1) \emph{explanatory modeling}, which searches for insights into complex system behaviors; (2) \emph{uncertainty quantification}, which infers model parameters from observations and propagates them to predictive distributions~\cite{Ghanem_HO_book_2016}; (3) \emph{sensitivity analysis}, which identifies factors with greatest influence on predictions~\cite{Saltelli_book_2004}; (4) \emph{experimental design}, which predicts which data collections maximize understanding or decision value~\cite{Ryan_DMP_ISR_2016}; and (5) \emph{optimal design and control}, which optimizes objective functions by adjusting decision variables under constraints~\cite[Ch.~1]{Martins_Ning_book_2021}.
To support these outer-loop processes, predictive SciML encompasses four main classes of methods, each presenting different computational challenges: surrogate modeling, model discovery, hybrid \CSE{}-SciML modeling, and outer-loop learning.

\emph{Surrogate modeling} builds low-cost approximations of computationally expensive models for outer-loop analyses. 
Surrogate models can map model inputs to specific quantities of interest~\cite{Doostan_VI_CMAME_2013, Tezaur_PPJR_JAMES_2022, bouhlel2020scalable}.
Surrogate models can also approximate complete solutions to governing equations via data-driven reduced-order modeling~\cite{Peherstorfer_W_CMAME_2016, Schmid_JFM_2010, Brunton_PK_PNAS_2016}, operator learning with Gaussian processes~\cite{mora2024operator} and neural networks~\cite{HesthavenUbbiali18,kovachki2023neural, Lu_JPZK_NMI_2021, bhattacharya2021model, Li_KBALBSA_icml_2021,o2024derivative,fresca2022pod}, and physics-informed neural networks (PINNs)~\cite{yu2018deep,Raissi_PK_JCP_2019,goswami2023physics}, which encode physical constraints directly into the neural network training.
Finally, surrogate models can provide solutions to differential equations without simulation data~\cite{Sirignano_S_JCP_2018, W_B_CMS_2018}.

\emph{Model discovery} learns equations approximating physical system principles~\cite{Schmid_JFM_2010,Brunton_PK_PNAS_2016,Ling_JT_JCP_2016,Cory_CDEL_NC_2024}. Like operator learning and reduced-order modeling, these approaches work with both experimental and simulation data. Model discovery is being increasingly used to develop constitutive closure models that can be used when a numerical model cannot practically resolve small scales such that the large-scale equations are unclosed.

\emph{Hybrid \CSE{}-SciML models} embed SciML components within \CSE{} models.
Examples include learning initial guesses for iterative PDE solvers~\cite{huang2020int}, predicting preconditioners for linear systems~\cite{sappl2019deep}, and developing constitutive models for applications ranging from radiation transport~\cite{Huang_YCRY_MMS_2023} to aerospace~\cite{Singh_MD_AIAA_2017}.

\emph{Outer-loop learning} leverages ML to predict solutions under varying conditions.
Applications include surrogate models for expensive forward simulations in PDE-constrained optimization~\cite{wang2021fast,luo2023efficient} and Bayesian inverse problems~\cite{cao2024lazy}.
Reinforcement learning solves PDE-constrained optimization across different conditions~\cite{sutton2018reinforcement}.
ML methods can also learn solutions to these problems directly.
For example, ML models learn Bayesian posterior distributions as marginals of joint distributions for fast online inference with arbitrary observational data~\cite{baptista2020conditional,baptista2023representation,weilbach2020structured}.


\subsection{Comparing \CSE{} and SciML model development and deployment}

Making scientific claims using SciML models involves two steps: model development and model deployment. 
While SciML models can complement \CSE{} models, their development processes differ, though deployment processes remain similar, as shown in Figure~\ref{fig:basic-sciml-workflow}.
To illustrate these steps, we use an example quantifying uncertainty in a hybrid SciML-\CSE{} ice-sheet model of the Humboldt Glacier in Greenland, with unknown glacier-landmass friction.
Our example is loosely based on the study by He et al.~\cite{He_PKS_JCP_2023}, which exemplifies thorough reporting of a SciML model's strengths and weaknesses.

\CSE{} model development begins with physics-based governing equations. In our example, while nonlinear Stokes equations accurately model shear-thinning behavior for ice sheets, simpler models like shallow-shelf approximation (SSA) are often used for computational tractability~\cite{He_PKS_JCP_2023}.
The second step implements numerical methods to solve  the governing equations while respecting properties like mass and energy conservation. This involves choosing a fixed ansatz (e.g., a finite element basis) and applying numerical procedures using linear algebra, Newton iteration, and time-stepping. For instance, He and coworkers~\cite{He_PKS_JCP_2023} used continuous piecewise linear elements for thickness and velocity fields with Newton iteration and semi-implicit time-stepping.

\begin{figure}[htb]
    \centering
    \includegraphics[width=\linewidth]{basic-sciml-workflow.pdf}
    \caption{Fundamental steps for developing and deploying \CSE{} and SciML models in outer-loop processes. Deployment phases are conceptually similar for both model types when making scientific claims. Simulation steps require multiple model runs based on outer-loop process demands.}
    \label{fig:basic-sciml-workflow}
\end{figure}

In contrast to \CSE{}, typical SciML development relies on training procedures that require observational data or the ability to query an existing numerical model. Consequently, as shown in Figure \ref{fig:basic-sciml-workflow}, the development begins with collecting input-output training data. For example, He et al.~\cite{He_PKS_JCP_2023} built a DeepONet~\cite{Lu_JPZK_NMI_2021} to map ice-sheet thickness and friction to glacier velocity, using data from an SSA-based \CSE{} model to accelerate glacier evolution and uncertainty quantification. 
The second step sets model hyperparameters (e.g., neural-network width and depth). The third optimizes model parameters (e.g., neural-network weights and biases) by minimizing the difference between model outputs and training data. He et al.~\cite{He_PKS_JCP_2023} used Adam optimization to minimize the mean-squared error between predicted and training velocities. Often, hyperparameters must be tuned through formal optimization or informal assessment of model accuracy across different settings.
Note that some SciML models~\cite{Sirignano_S_JCP_2018, W_B_CMS_2018} combine \CSE{} and SciML development steps shown in Figure~\ref{fig:basic-sciml-workflow}, training without data by minimizing objectives that enforce known governing equations.

The development and deployment of SciML models for specific scientific applications follows distinct phases. When using these models to make scientific claims—--like predicting the Humboldt glacier's impact on sea level in the future—--deployment involves three key steps beyond the initial model development. 
First, we collect calibration data representing the system's current state (distinct from training data, which spans multiple states). 
Second, we calibrate the model through optimization to match this system-specific data. In our ice-sheet example, this means solving an inverse problem for friction parameters to match recent velocity measurements~\cite{Jakeman_SHHHP_ESD_2024}, notably optimizing model inputs rather than SciML parameters like neural-network weights. 
Finally, we run the model under various future conditions or plausible friction fields, such as those obtained from Bayesian calibration.

\subsection{Leveraging an existing \CSE{} framework for trustworthy SciML}
\label{sec:framework}

As highlighted by Broderick et al.~\cite{Broderick_GMSZ_SA_2023}, trust in SciML and \CSE{} models can be gained or lost at any step of development and deployment (Figure~\ref{fig:basic-sciml-workflow}). Building trust requires demonstrating that the mathematical model adequately meets analysis goals despite being an approximation. The model must then be verified by comparing theoretical and empirical results to ensure it solves its mathematical formulation correctly. Additionally, rigorous code testing must be implemented to reduce software bugs, and data provenance must be documented to ensure relevance for future conclusions and decisions.

Over decades, the scientific computing community developed rigorous standards for building credibility in computational models. These standards crystallized into a systematic approach known as \emph{verification and validation} (V\&V), providing guidelines to enhance model trustworthiness by addressing potential failure points~\cite{AIAA_validation_report_1998,VV10-2006,Oberkampf_T_PAS_2002}. 
Verification ensures correct algorithm and code implementation (solving the equations correctly), while validation assesses model appropriateness for intended applications (solving the correct equations).

While V\&V practices are well-established in scientific computing, the emergence of SciML brings new concerns that existing guidelines don't fully address. SciML combines aspects of both scientific computing and ML, presenting unique verification and validation challenges beyond either field. We argue that adapting and extending proven V\&V principles from scientific computing can provide a foundation for building trustworthy SciML models. 
To this end, we make recommendations in four areas: problem definition, verification, validation, and continuous credibility building (see Figure~\ref{fig:model-development}). 
Problem definition and verification (Sections~\ref{sec:problem-def} and~\ref{sec:verification}) expand on the model development steps in Figure~\ref{fig:basic-sciml-workflow},  while validation and reporting (Sections~\ref{sec:validation} and~\ref{sec:ongoing}) detail the deployment steps. Validation is generally most pertinent only to papers that utilize SciML to support a scientific claim for a specific application. However, all other components illustrated in Figure~\ref{fig:basic-sciml-workflow} are applicable to all SciML papers, including those that present algorithmic advances, which are relevant to a broad spectrum of scientific applications.

 \begin{figure}[htb]
    \centering
    \includegraphics[width=\linewidth]{our-workflow.pdf}
    \caption{Four components of trustworthy model development. Blue boxes indicate areas common to \CSE{} and SciML models, while gray boxes show SciML-specific areas. Generative physics-informed SciML models may skip the gray data collection and processing boxes in code and solution verification.}
    \label{fig:model-development}
\end{figure}

Like Broderick et al.~\cite{Broderick_GMSZ_SA_2023}, we view trustworthiness as a spectrum rather than binary. Following Oberkampf's predictive capability maturity model~\cite{oberkampf2007predictive}, the four components in Figure~\ref{fig:model-development} build confidence through continuous testing and refinement as new data emerge. Each study should mature progressively in its development process through these four areas. The following sections identify opportunities for improving SciML practice, along with corresponding recommendations.
 
We do not claim that these four components or our recommendations are comprehensive or universally applicable. Instead, we aim to stimulate community efforts to develop SciML guidelines and standards. We hope to advance practice beyond the basic implementation of our recommendations toward more thorough, deliberate, and well-documented approaches to SciML development and deployment.
