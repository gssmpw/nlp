
\section{Contribution Identification}
\label{sec:contribution-indentify}


% \subsection{Problem Statement}
% We establish the definition for contributing summary generated from a function based on its contribution to $S(V_{\text{src}}, V_{\text{sink}})$.

% \begin{definition}[Contributing Summary] \label{def:contributing_summary}
% A summary $s \in S^f$ is considered a contributing summary for function $f$ if it satisfies at least one of the following criteria:
% (1) Path Contribution: The summary path $\pi$ is used to connect with at least one source-sink path, i.e., $\pi \in \Pi(V_{\text{src}}, V_{\text{sink}})$.
% (2) Condition Contribution: The summary path $\pi$ is used to instantiate at least one guard vertex labeled along the source-sink paths, i.e., $\phi_{\pi} \in \Phi(V_{\text{src}}, V_{\text{sink}}, V_{\text{g}})$.
% \end{definition}

% The bottom-up collection of $S(V_{\text{src}}, V_{\text{sink}})$ outlined in Algorithm~\ref{alg:ps-vf-analysis} can collect and maintain non-contributing summaries, leading to scalability bottlenecks. 
% Specifically, non-contributing summaries can arise in two scenarios.
% First, when collecting three types of summaries, over-summarization can occur.
% For instance, in the motivating example depicted in Fig.~\ref{fig:motivation_ex}, when analyzing the function $baz$, a non-contributing summary $\pi_2$ is collected. 
% When analyzing function $baz$, there is no prior knowledge of which the specific summary contributes to, resulting in the conservative collection of all summaries within it. 
% Consequently, the non-contributing summary $\pi_2$ is collected as a transfer summary.
% Second, non-contributing summaries can be induced through the cloning of callee summaries. 
% For example, the summary $\pi_6$ is a non-contributing summary generated by cloning and concatenating with the callee summary $\pi_2$. 
% Furthermore, since there are no other summaries in function $boo$ that use $\pi_2$, and $\pi_6$ is identified as a non-contributing summary, $\pi_2$ should not be cloned from function $baz$ when analyzing $foo$. 
% As summaries are maintained and cloned into higher-level functions, the size of $S^f$ can exponentially increase due to the explosion of paths. 
% To sum up, collecting and cloning only the contributing summaries can significantly improve scalability.


% To prevent non-contributing summaries, it is necessary to take a preliminary step during the collection of $S^{f}$ and the cloning of callee's summary $S^{c}$ in Algorithm~\ref{alg:ps-vf-analysis}. 
% Each summary is evaluated thoroughly to ensure that only the contributing summary is cloned and collected.
% However, this assessment introduces a contradiction, as it relies on the assumption that $S(V_{\text{src}}, V_{\text{sink}})$ is obtained as defined in Definition~\ref{def:contributing_summary}.

% \textbf{Problem Statement:} Our research goal is to identify non-contributing summaries without the need to collect $S(V_{\text{src}}, V_{\text{sink}})$. 
% It is crucial for the identification process to be efficient, ensuring that the cost of identification is lower than the potential redundancy it aims to prevent.


% Since computing both path and condition contributions needs to identify $V_h^{*}$ and $V_t^{*}$, we denote $V_h^{p*}$ and $V_t^{p*}$ as those collected for path contribution, and $V_h^{c*}$ and $V_t^{c*}$ as those collected for condition contribution.

In this section, we first present three technical designs of our contribution identification algorithm.
We then give the details of the identification algorithm that identifies the necessary vertices for path and condition contribution.
Finally, we establish the soundness of our approach, analyze the complexity of algorithms, and discuss the advanced graph reachability with consideration of the calling context.

% \textit{How to preserve the precision of the analysis?}
\textit{\textbf{Preserving the precision of the analysis.}} To ensure this, instead of directly utilizing the abstractions to identify non-contributing summaries,
    the identification algorithm uses the abstractions to soundly identify all necessary head vertices $V_{h}$ and tail vertices $V_{t}$ that are reached by source-sink pairs (path contribution) as well as guard vertices $V_{g}$ that are labeled on source-sink paths (condition contribution).
    This means that contributing summaries can only be collected within necessary vertices, which we denote as $V^{N}$.
    Therefore, summaries contributing to source-sink paths can be collected within $V^{N}$ as in the traditional methods.
    In contrast, summaries collected outside $V^{N}$ are considered as the non-contributing summaries.
    The soundness proof is given in Section~\ref{sec:sound}.


\textit{\textbf{Efficient and effective identification.}}
    The identification process relies on graph reachability. 
    More precise graph reachability results in fewer necessary vertices $V^{N}$ being identified, allowing for recognizing more non-contributing summaries starting outside of $V^{N}$. 
    However, using advanced reachability algorithms increases the identification overhead. 
    The complexity of more advanced reachability algorithms often outweighs the precision gains they can provide. 
    To strike a balance, i.e., spending minimal overhead while significantly boosting the efficiency of path-sensitive analysis, we select the classic breadth-first search (\texttt{bfs}) algorithm for implementing our abstractions. More discussion about this is in Section~\ref{sec:discussion}.


\textit{\textbf{Resolving implicit contribution.}}
    The source of the implicit contribution comes from the condition contribution of a summary.
    With the abstractions, resolving the implicit contribution is transferred to gather the necessary guard vertices that are labeled on source-sink paths.
    The key is that the necessary guard vertices could be obtained from edge sets that are reachable from the necessary heads and tails for path contribution.


The contribution identification algorithm is outlined in Algorithm~\ref{alg:main}.
At a high level, it identifies necessary vertices $V^{N}$ in two parts for path and condition contribution, respectively, through three stages.
First, it identifies the first part of necessary vertices $V^{N}$ for path contribution using the procedure \texttt{identifyPathContrib} in Algorithm~\ref{alg:main}.
Next, using these necessary heads and tails for path contribution, we collect the necessary guard vertices with the procedure \texttt{collectNecGuards} in Algorithm~\ref{alg:condition}.
Lastly, based on the necessary guard vertices and heads and tails that are not identified for path contribution, we further identify the second part of necessary vertices for condition contribution using the procedure \texttt{identifyCondContrib} in Algorithm~\ref{alg:condition}.
% Next, we detail each step.


% \vspace{-0.5em}
\subsection{Path Contribution Identification}


\begin{algorithm}[t]\small
  \caption{Contribution Identification}
  \label{alg:main}
  \SetKwData{Vn}{$V^{\texttt{N}}$}
\SetKwData{Vcand}{$V^{\texttt{cand}}$}
  \SetKwFunction{Q}{identifyContrib}
  \SetKwProg{Proc}{Procedure}{}{}
    \Proc{\Q{$G$}} {
    $\Vn \leftarrow \emptyset$; $\Vcand \leftarrow \emptyset$\;
    \texttt{identifyPathContrib}(G,\Vn,\Vcand)\;
    \texttt{identifyCondContrib}(G,\Vn,\Vcand)\;
    \Return $V^{\texttt{N}}$\;
  }

  \SetKwFunction{Q}{identifyPathContrib}
  \SetKwProg{Proc}{Procedure}{}{}
  \Proc{\Q{G,\Vn,\Vcand}} {
    srcVisited $\leftarrow \emptyset $; sinkVisited $\leftarrow \emptyset $\;
    \SetKwData{Vsrc}{$V_{\texttt{src}}$}
    \ForEach{$v \in \Vsrc $} {
        \texttt{bfs}(srcVisited, $v$, G, forward)\;
    }
    \SetKwData{Vsink}{$V_{\texttt{sink}}$}
    \ForEach{$v \in \Vsink $} {
        \texttt{bfs}(sinkVisited, $v$, G, backward)\;
    }

    \Vn $\leftarrow $ {srcVisited} $\cap$ {sinkVisited} $\cap\ (V_{t} \cup V_{h} - V_{g})$\;
    \Vcand $\leftarrow$ {srcVisited} $\cup$ {sinkVisited} $- V^{N}$\;
    
    % \ForEach{$v$ $\in$ \texttt{src\_visited} \texttt{and} $v \in$ \texttt{sink\_visited} } {
    %     \If{ $v$ $\in$ $V_{t} \cup V_{h} - V_{g}$} {
    %         \texttt{p}-\textit{pp} $\leftarrow$ \texttt{p}-\textit{pp} $\cup$ $v$ \;
    %     }
    % }
    % \Return \;
  }
\end{algorithm}

% Following the Lemma ~\ref{corol_path}, each vertex $v$ in $V_h^{p*} \cup V_t^{p*}$ satisfies the following condition: there exists a pair $(src, sink) \in V_{src} \times V_{sink}$ such that both $src$ and $v$, as well as $v$ and $sink$, are reachable on the PDG of $P$.



% With Lemma ~\ref{corol_path}, for each vertex $v$ in $V_h^{p*} \cup V_t^{p*}$, the following condition holds: there exists a pair $(src, sink) \in V_{\text{src}} \times V_{\text{sink}}$ such that both $src$ and $v$, as well as $v$ and $sink$, are reachable on the PDG of $P$.

Procedure \texttt{identifyPathContrib} in Algorithm~\ref{alg:main} utilizes \texttt{bfs} to explore the graph separately from both the source and sink vertices. 
Since a vertex $v$ only needs to be reachable by at least one source-sink pair, the \texttt{bfs} initiated from the source (sink) vertices maintain a shared visiting set called $\texttt{srcVisited}$ ($\texttt{sinkVisited}$). 
This ensures that each vertex is visited only once during the \texttt{bfs} from the sources (sinks). 
After completing all \texttt{bfs}, the necessary vertices for path contribution can be obtained by computing the intersection between the vertices visited both by $\texttt{srcVisited}$ and $\texttt{sinkVisited}$ and $V_{t} \cup V_{h} - V_{\text{g}}$ in Line 12.
As the guard vertices could not have the path contribution, the necessary vertices only come from $V_{t} \cup V_{h} - V_{\text{g}}$.
Vertices that are visited by sources and sinks but not identified as necessary vertices for path contribution are called candidates, denoted as $V^{\texttt{cand}}$. 
These vertices may have condition contribution, which are computed on Line 13 and passed to the procedure \texttt{identifyCondContrib} on Line 4.



\subsection{Condition Contribution Identification}
\label{sec:condition-identification}


The necessary guard vertices are labeled on the edges of the source-sink paths. 
Thus, necessary guard vertices can be collected using the necessary vertices for path contribution.

% The guard vertices $V_{g}^{*}$, which are instantiated to constrain source-sink paths, are also labeled on the edges of the source-sink paths simultaneously. 
% Therefore, any labeled edge of a source-sink path naturally stands within the reach of any vertex of that path. 
% According to the path abstraction, since $V_h^{p*}$ and $V_t^{p*}$ compose a set of vertices from source-sink paths, $V_{g}^{*}$ can be collected using $V_h^{p*}$ and $V_t^{p*}$.

% Hence, each vertex $g$ in $V_{g}^{*}$ satisfies the following condition: there exists a pair $(u, v) \in (V_h^{p*} \cup V_t^{p*}) \times (V_h^{p*} \cup V_t^{p*})$, such that the edge $e=(x, y)$ has the label $L_d(e)=g$, and both $u$ and $x$, as well as $v$ and $y$, are reachable on the PDG of $P$.
% The collection of $V_{g}^{*}$ can utilize BFS traversal to gather the visited edges. During this process, the two shared edge sets, $\texttt{fwd\_visited\_edges}$ and $\texttt{bwd\_visited\_edges}$, are used to record the visited edges for forward BFSs starting from the vertices from $V_h^{p*}$, and backward BFSs starting from $V_t^{p*}$, respectively.
% They ensure that each edge is visited only once during the forward BFSs and backward BFSs,
% as the edge $e=(x, y)$ only needs to be reached by at most one vertex from $V_h^{p*}$ in the forward direction and at most one vertex from  $V_t^{p*}$ in the backward direction.
% For each edge $(u, v)$ encountered in $\texttt{fwd\_visited\_edges}$, if the reverse edge $(v, u)$ is also found in \texttt{bwd\_visited\_edges}, the label $L_d(u, v)$ is added to the set $V_{g}^{*}$.

% Based on the above explanation, 
% each vertex $\text{g}$ in \texttt{necGuards} satisfies the following condition: there exists a pair $(u, v) \in V^{N} \times V^{N}$, where the edge $e=(x, y)$ has the label $L_d(e)=\text{g}$, and both $u$ and $x$, as well as $v$ and $y$, are reachable on the PDG of $P$.
The necessary guards are collected and maintained in $V_{g}^{\texttt{nec}}$ through procedure \texttt{gatherNecGuards}, using the \texttt{bfsEdge} traversal to gather the visited edges. 
Two shared edge sets, \texttt{fwdEdges} and \texttt{bwdEdges}, are utilized to keep track of the visited edges for forward and backward \texttt{bfsEdge} starting from the vertices in $V^{N}$, respectively. 
These two sets ensure that each edge is visited only once during the forward and backward \texttt{bfsEdge}.
For each edge $(u, v)$ encountered in \texttt{fwdEdges}, if the reverse edge $(v, u)$ is also found in \texttt{bwdEdges}, the label $L_d(u, v)$ is added to $V_{g}^{\texttt{nec}}$.

% As the edge $e=(x, y)$ only needs to be reached by at most one vertex from $V^{N}$ in the forward and backward direction, the sets guarantee this condition.


\begin{algorithm}[t]\small
  \caption{Condition Contribution Identification}
  \label{alg:condition}
    \SetKwData{Vn}{$V^{\texttt{N}}$}
    \SetKwData{Vcand}{$V^{\texttt{cand}}$}
    \SetKwData{necG}{$V^{\texttt{nec}}_{g}$}
  \SetKwFunction{Q}{identifyCondContrib}
  \SetKwProg{Proc}{Procedure}{}{}
  \Proc{\Q{G,\Vn,\Vcand}} {
    $\necG \leftarrow \emptyset$; {fwdVisited} $\leftarrow \emptyset$; {bwdVisited} $\leftarrow \emptyset $\;
    \texttt{gatherNecGuards}(\Vn, \necG)\;
    \ForEach{$v$ $\in$ \Vcand} {
        \texttt{bfs}({fwdVisited}, $v$, G, forward)\;
    }
    \ForEach{$v$ $\in$ \necG} {
        \texttt{bfs}({bwdVisited}, $v$, G, backward)\;
    }
    % \ForEach{$v$ $\in$ \texttt{fwd\_visited} \texttt{and} $v \in$ \texttt{bwd\_visited} } {
    %     \If{ $v$ $\in$ $ V_{t} \cup V_{h} - V_{g}$} {
    %         \texttt{c}-\textit{pp} $\leftarrow$ \texttt{c}-\textit{pp} $\cup$ $v$ \;
    %     }
    % }

    \Vn $\leftarrow$ \Vn $\cup$ ({fwdVisited} $\cap$ {bwdVisited}) $\cap\ (V_{t} \cup V_{h})$\;
    
    % \Return \texttt{c}-\textit{pp} \;
  }
  
  \SetKwFunction{Q}{gatherNecGuards}
  \SetKwProg{Proc}{Procedure}{}{}
  \Proc{\Q{\Vn, \necG}} {
        {fwdEdges} $\leftarrow \emptyset$; {bwdEdges} $\leftarrow \emptyset$\;
        \ForEach{$v$ $\in$ \Vn} {
            \texttt{bfsEdge}({fwdEdges}, $v$, G, forward)\;
        }
        \ForEach{$v$ $\in$ \Vn} {
            \texttt{bfsEdge}({bwdEdges}, $v$, G, backward)\;
        }
        
        \ForEach{$(u, v) \in \mathrm{bwdEdges}$ $\cap\ \mathrm{fwdEdges}$} {
            \necG $\leftarrow $ \necG $ \cup $ $ L_d(u, v)$\;
        }
        % \Return \necG\;
  }
\end{algorithm}

After collecting the necessary guard vertices, 
the algorithm then proceeds to collect another part of the necessary vertices for condition contribution.
If a vertex has already been identified for path contribution, separately identifying its condition contribution is unnecessary.
Thus, the procedure \texttt{identifyCondContrib} explores the vertices from the candidates in the forward direction and from each necessary guard vertex in the backward direction.
During the \texttt{bfs} iterations, the shared sets \texttt{fwdVisited} and \texttt{bwdVisited} are utilized to keep track of the visited vertices in each direction, respectively. 
By examining the head and tail vertices present in both \texttt{fwdVisited} and \texttt{bwdVisited} sets, another part of the necessary vertices can be identified.


\begin{example}
Procedure \texttt{identifyPathContrib}'s output is $\{ NULL_{19}, m_{20}, a_2, a_5, \text{printf}(*a_9), p_{11}, \text{printf}(*p_{13}) \}$, and the necessary guard vertice is $\{ \varphi_2 \}$.
The vertices that have condition contribution are $\{ p_{11}, a_2, a_5, m_{20}, NULL_{19}, \varphi_2 \}$ and some of them are included in the path contribution. 
Thus, the output of the procedure \texttt{identifyCondContrib} is $\{ \varphi_2 \}$.
Also, the set $V^{N}$ to assess the contributing summary is $\{ NULL_{19}, m_{20}, \text{printf}(*a_9), p_{11}, \text{printf}(*p_{13}), a_2, a_5, \varphi_2 \}$.
\end{example}

% \vspace{-0.5em}
\subsection{Soundness}
\label{sec:sound}

% Recall the definition in~\ref{def:contributing_summary}; we can derive the following two lemmas for the necessary vertices.
% \begin{lemma}[Necessity of criteria (1)] \label{corol_path}
%     % If the summary $s=(\pi, \phi_{\pi})$ satisfies the path contribution, then there exists a source-sink pair, $ (src, sink) \in V_{src} \times V_{sink}$, such that $src$ reaches both $\pi[0]$ and $\pi[-1]$, and meanwhile $sink$ is reached by both $\pi[0]$ and $\pi[-1]$. 
%     If the summary $s=(\pi, \phi_{\pi})$ meets the path contribution criteria, there exists a source-sink pair, denoted as $(src, sink) \in V_{\text{src}} \times V_{\text{sink}}$, where $src$ can reach both $\pi[0]$ and $\pi[-1]$, and $sink$ is reached by both $\pi[0]$ and $\pi[-1]$.
%     % (specifically, any vertex from $\pi$, with the head and tail vertices being considered here).
% \end{lemma}

% \begin{lemma}[Necessity of criteria (2)] \label{corol_condition}
%     % If the summary $s=(\pi, \phi_{\pi})$ satisfies the condition contribution, then there exists a guard vertex $g \in V_g$ of $\Phi(V_{src}, V_{sink}, V_{g})$, which can be reached by $\pi[0]$ and $\pi[-1]$.
%     If the summary $s=(\pi, \phi_{\pi})$ meets the condition contribution criteria, there exists a guard vertex $\text{g} \in V_{\text{g}}$ from $\Phi(V_{\text{src}}, V_{\text{sink}}, V_{\text{g}})$ that are reached by $\pi[0]$ and $\pi[-1]$.
% \end{lemma}

% Lemma~\ref{corol_path} can be proven using a proof-by-contradiction approach. 
% On the other hand, to establish Lemma~\ref{corol_condition}, we first need to use a key fact that $V_{\text{g}}$ is the set of guard vertices that necessitate instantiation during the construction of the path conditions. 
% Based on this premise, if a guard vertex is employed to constrain $\Pi(V_{\text{src}}, V_{\text{sink}})$, it must meet one of the following conditions: either it is reachable from the other guard vertices labeled on $\Pi(V_{\text{src}}, V_{\text{sink}})$, or it is labeled on $\Pi(V_{\text{src}}, V_{\text{sink}})$. Subsequently, we can proceed with a proof by contradiction to demonstrate Lemma~\ref{corol_condition}.



% The key observation is that Lemma~\ref{corol_path} and Lemma~\ref{corol_condition} provide a means to identify the path contribution and condition contribution by examining the reachability between specific vertices on $\pi$ with distinct reaching targets, without computing any summaries. Once the path contribution or condition contribution of a summary is identified, a contributing summary. Consequently, the abstraction for path and condition is formulated as follows.

% \textbf{Abstract path contribution.}
% Based on Lemma~\ref{corol_path}, the head or tail vertices on $\pi$ serve as the reaching targets, starting from the source-sink pairs $V_{\text{src}} \times V_{\text{sink}}$. 
% Since guard vertices at the end of a summary cannot contribute to the path, the head vertex of a summary with path contribution originates from $V_{h}$, while the tail vertex comes from $V_t - V_{\text{g}}$. We denote these subsets as $V_{h}^{*} \subseteq V_{h}$ and $V_{t}^{*} \subseteq V_{t} - V_{\text{g}}$.
% The identification of path contribution for the function summary $S^{f}(V_h, V_t)$ is then abstracted as a reachability problem between $V_{h}^{*}$ and $V_{t}^{*}$ with respect to at least one source-sink pair. In Algorithm~\ref{alg:ps-vf-analysis}, the three types of summaries to be collected between $V_{h}^{*}$ and $V_{t}^{*}$ are considered to possess path contribution and are subsequently recognized as contributing summaries.


% \textbf{Abstract condition contribution.}
% Based on Lemma~\ref{corol_condition}, the target vertices for condition contribution are the head or tail vertices of $\pi$ and some of the guard vertices that are instantiated to constrain $\Pi(V_{\text{src}}, V_{\text{sink}})$. These guard vertices are denoted as $V_{\text{g}}^{*}$.
% Thus, the identification of the condition contribution for the function summary $\Phi^f(V_h, V_t)$ can be abstracted as a reachability problem between $V_{h}^{*}$ and $V_{t}^{*}$ with respect to at least one guard vertex belonging to $V_{\text{g}}^{*}$. 

% In Algorithm~\ref{alg:ps-vf-analysis}, the summaries collected between $V_{h}^{*}$ and $V_{\text{g}}^{*}$, as well as between $V_{\text{g}}^{*}$ and $V_{t}^{*}$, are considered to have condition contributions.
% With the path abstraction, the identification of the path contribution can be achieved by collecting $V_h^{*}$ and $V_t^{*}$ without computing any summaries. However, for the condition contribution abstraction, $V_{\text{g}}^{*}$ is required, representing a set of guard vertices labeled on the source-sink paths. 
% Note that $V_{\text{g}}^{*}$ can still be collected without calculating any summaries.
% Given that we have used $V_h^{*}$ and $V_t^{*}$ to abstract source-sink paths in the path abstraction, $V_{\text{g}}^{*}$ can be determined as the set of edge labels that can be reached by both $V_h^{*}$ and $V_t^{*}$.
% Therefore, finding contributing summary involves identifying $V_h^{*}$, $V_t^{*}$, and $V_{\text{g}}^{*}$. We denote these vertices that need to be identified as $V^{I} = V_h^{*} \cup V_t^{*} \cup V_{\text{g}}^{*}$.
% In the following section, we present the efficient algorithm implemented by \tool~to identify $V^{I}$.

% \vspace{-1.5em}
% \subsection{Soundness.}

% The $V^{I}$ identified by ~\tool~ contains the necessary heads, tails, and guard vertices for source-sink paths.
% The summaries that are collected outside the vertices in $V^{I}$ are considered non-contributing summaries.
% Thus, we formulate the following theorem to establish the soundness of abstracting contributions in identifying non-contributing summaries for function $f$ based on the $V^{I}$:

% The \tool\ collect the necessary vertices $V^{N}$ that includes essential head vertices, tail vertices, and guard vertices required for source-sink paths. 
% The summaries collected outside the vertices in $V^{N}$ are considered non-contributing summaries. 
% Thus,
We propose the following theorem to establish the soundness of abstracting contributions in identifying non-contributing summaries for function $f$ based on $V^{N}$.

\begin{theorem}[Soundness]
\label{thm:sound}

Given the set $V^{N}$ identified, for any function $f \in P$, if a summary $s=(\pi, \phi)$ is collected and neither $\pi[0]$ nor $\pi[-1]$ appears in $V^{N}$, it must be a non-contributing summary for function $f$. Canceling the corresponding operations does not affect $S(V_{\text{src}}, V_{\text{sink}})$.

% See the proof in a longer version of this paper\cite{toappear}.
See the proof in Appendix Section~\ref{app:sound}.
% \begin{proof}
% In Algorithm~\ref{alg:ps-vf-analysis}, when collecting the summary $s$ between $V_{h}^{f}$ and $V_{t}^{f}$, if $\pi[0] \notin V_h^{p*} \cup V_t^{p*}$ or $\pi[-1] \notin V_h^{p*} \cup V_t^{p*}$, it indicates that $s$ cannot be reached by any source-sink pairs. Therefore, it does not contribute to any source-sink path. If $\pi[0] \notin V_h^{c*} \cup V_t^{c*}$ or $\pi[-1] \notin V_h^{c*} \cup V_t^{c*} \cup V_{\text{g}}^{*}$, it means that $s$ cannot be used to constrain any source-sink path. Hence, it does not contribute to any condition. In such cases, the collecting operation should be canceled.

% In Algorithm~\ref{alg:ps-vf-analysis}, when collecting the summary $s$ by concatenating it with the summaries $S^{c}$ cloned from callee functions, following the same judgment conditions as described in the previous case, if it is determined to be a non-contributing summary, the operation of cloning $s^{c}$ should be canceled.
% \end{proof}
\end{theorem}

\begin{example}
% Continuing with our example in Fig.~\ref{fig:motivation_ex}, the collection of summary $\pi_{7}$ is prevented. This is because the cloning of $\pi_{1}^{\prime}$ to concatenate with $b_3 \rightarrow b_7$ is determined to be non-contributing. The reason for this is that $b_3$ is not included in $V^{I}$.
% Similarly, the collection of summary $\pi_{2}$ and $\pi_7$ is removed. This is because $f_{15}$ and $d_4$, which are the starting vertex of $\pi_{2}$ and $\pi_7$, are not present in the $V^{I}$.
In Fig.~\ref{fig:motivation_ex}, collecting summary path $\pi_{6}$ and verifying its condition $\phi_{\pi_{6}}$ are prevented because it is determined that cloning $\pi_{1}^{\prime}$ to concatenate with $b_3 \rightarrow b_6$ would result in a non-contributing summary.
It is because $b_3$ is not included in $V^{N}$.
Similarly, the collection and verification of summaries $s_{2}$ and $s_7$ are removed because the head vertices $f_{15}$ and $c_1$ of these summaries are not present in $V^{N}$.
\end{example}

\begin{algorithm}[t]\small
  \caption{New Path-Sensitive Value Flow Analysis}
  \label{alg:boosted-ps-vf-analysis}
  \SetKwFunction{Q}{newPathSensitveAnalysis}
  \SetKwProg{Proc}{Procedure}{}{}
  \SetKwComment{Comment}{//}{}
  \SetKwInOut{Input}{Input}
  \SetKwInOut{Output}{Output}
  \Proc{ \Q{P} } {
        Build call graph CG and PDG of {P}\;
      $V^{N} \leftarrow $ \texttt{identifyContrib}(PDG)\;
        /* \textbf{\textit{The initialize part is the same as the Algorithm~\ref{alg:ps-vf-analysis}}}  */
        
      \ForEach{$f$ $\in CG$ in bottom-up order} {
            /*~\textit{Pruning the redundancies.} ~*/
            
            $V_{\text{fp}} \leftarrow V_{\text{fp}} \cap V^{N}$; $V_{\text{ap}} \leftarrow V_{\text{ap}} \cap V^{N}$\;
            $V_{\text{fr}} \leftarrow V_{\text{fr}} \cap V^{N}$; $V_{\text{ar}} \leftarrow V_{\text{ar}} \cap V^{N}$; $V_{\text{g}} \leftarrow V_{\text{g}} \cap V^{N}$\;
            /* \textbf{\textit{The summary collection part, which is the same as the Alogirhtm~\ref{alg:ps-vf-analysis}.} } ~*/
      }             
    $ \forall (\pi, \varphi) \in S(V_{\text{src}}, V_{\text{sink}}),\, \text{report}\, \pi\, \text{as}\, \text{a}\, \text{bug}\, \text{if}\, \varphi\, \text{is}\, \text{sat;} $
  }
  % \vspace{-0.2cm}
\end{algorithm}

% \vspace{-0.5em}
\subsection{Summary and Discussion}
\label{sec:discussion}

% With the $V^{I}$ identified, as described in Theorem~\ref{thm:sound}, Algorithm~\ref{alg:ps-vf-analysis} can be enhanced and revised as Algorithm~\ref{alg:boosted-ps-vf-analysis}.
% During the collection of three types of summaries, the algorithm filters the head, tail, and guard vertices using the $V^{I}$. 
% This filtering step ensures that summaries outside $V^{I}$ 
% are not collected and cloned, thereby eliminating the non-contributing summaries.


Based on the identification of $V^{N}$, as outlined in Theorem~\ref{thm:sound}, Algorithm~\ref{alg:ps-vf-analysis} can be improved and revised as Algorithm~\ref{alg:boosted-ps-vf-analysis}.
During the process of collecting the three types of summaries, the algorithm incorporates a filtering step for the head, tail, and guard vertices using $V^{N}$. 
The filtering step guarantees that summaries located outside of $V^{N}$ are not collected or cloned, effectively eliminating non-contributing summaries. Verification of these summaries by a constraint solver is thus avoided.
Next, we discuss the important points of the algorithm, including its complexity, precision, and efficiency.

% It is worth noting that the filtering process's overhead remains constant. 
% This is because it involves a table lookup performed before each collection of summaries. 


\textbf{Complexity.}
The procedure \texttt{identifyPathContrib} involves searching the PDG $G$ at most twice, as do each of the other procedures, since each edge is visited only once, either in the forward or backward traversal direction. As a result, the overall complexity is linear with respect to the size of PDG.
% The procedural \texttt{identify\_path\_contri} involves searching the PDG $G$ at most twice, so as other procedurals, as each edge is visited only once, either in the forward or backward traversal direction. 
% Similarly, the procedures \texttt{identify\_cond\_contri} and \texttt{collect\_nec\_guards} also require searching the PDG at most twice. 
% As a result, the overall complexity of collecting $V^{N}$ is $O(|V| + |E|)$. Here, $|V|$ represents the number of vertices in the PDG, and $|E|$ represents the number of edges.


% In the collection of $V^{p*}_{h}$ and $V^{p*}_{t}$, the PDG $G$ is searched at most twice, as each edge is visited at most once, either in the forward or backward traversal direction.
% Similarly, in the collection of  $V^{*}_{g}$, as well as $V^{c*}_{h}$ and $V^{c*}_{t}$, the PDG is also searched at most twice. 
% Therefore, the overall complexity of collecting $V^{I}$ is $O(|V| + |E|)$.

\textbf{Precision and Efficiency.}
The soundness of $V^{N}$ ensures the correct collection of contributing summaries. 
However, there may still be vertices within $V^{N}$ that lead to non-contributing summaries. 
The precision of $V^{N}$ can be increased by minimizing the number of such vertices, thereby identifying more non-contributing summaries.
The reason for the incorrect collection of some vertices in $V^{N}$ is that Algorithm~\ref{alg:main} utilizes a traditional reachability algorithm, specifically the \texttt{bfs}, to address the reachability problems without differentiating the calling context under which the summary could be used.
However, certain non-contributing summaries can only be identified under specific contexts, i.e., via context-free-language (CFL) reachability~\cite{reps1994speeding, reps1995shape, kodumal2004set, chaudhuri2008subcubic, yannakakis1990graph, melski2000interconvertibility}.
% Using more advanced reachability algorithms, such as context-free-language (CFL) reachability~\cite{reps1994speeding, reps1995shape, kodumal2004set, chaudhuri2008subcubic, yannakakis1990graph, melski2000interconvertibility}, which can model the context-sensitivity of the reachability problem. 
Consequently, non-contributing summaries that are reachable under traditional reachability algorithms but not under context-sensitive reachability algorithms could be further identified. 
The precision of $V^{N}$, therefore, depends on the approach used to solve reachability.
The CFL reachability algorithm takes calling context into consideration by respectively labeling function calls and returns with matched parentheses \([_k\) and \(]_k\) at line $k$.
Thus, a vertex \(i\) is context-sensitively reachable from a vertex \(j\) if the label string of the path does not contain any mismatched parentheses.

\begin{example}
In Fig.~\ref{fig:motivation_ex} (b), the following edges are labeled with parentheses to fulfill the requirements of the CFL reachability algorithm:
$m_{20} \xrightarrow{]_2} a_{2}$, $m_{20} \xrightarrow{]_3} b_{3}$,
$a_{5} \xrightarrow{[_5} p_{11}$, $b_{6} \xrightarrow{[_6} f_{15}$, and $f_{16} \xrightarrow{]_6} e_{6}$.
By replacing \texttt{bfs} with a CFL reachability algorithm in Algorithm~\ref{alg:main}, we would produce $V^{\texttt{N}} = \{NULL_{19}, m_{20}, \text{printf}(*a_9), p_{11}, \text{printf}(*p_{13}), a_2, a_5, \varphi_2 \}$, which is the same as when using \texttt{bfs}. 
In this case, using the CFL reachability algorithm does not improve the precision.
\end{example}

In practice, the precision of $V^{N}$ that can be improved by CFL reachability is limited. In our evaluation, approximately 80\% of non-contributing summaries were successfully identified using \texttt{bfs}.
However, in terms of efficiency, CFL reachability often encounters a cubic complexity barrier~\cite{kodumal2004set, chaudhuri2008subcubic, yannakakis1990graph, melski2000interconvertibility}. 
% It presents a challenge in efficient identification, as the computational cost may outweigh the potential performance improvements achieved. 
As demonstrated by our experiment in Fig.~\ref{fig:cfl-light-fusion}, using a CFL-based algorithm to collect $V^{N}$ significantly decreases overall performance. 
Thus, we use \texttt{bfs}.


