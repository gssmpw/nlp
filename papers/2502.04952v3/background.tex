\section{Background and Preliminary}
\label{sec:problem-formu}

This section introduces the background of path-sensitive value flow analysis and basic notations throughout the paper.
\vspace{-0.7em}
\subsection{Background}
We assume that the target program is in the static single assignment (SSA) form~\cite{cytron1991efficiently}, where each variable has only one definition and multiple definitions are merged using a $\phi$-assignment, following many existing works~\cite{babic2008calysto, cadar2008klee, shi2018pinpoint, sui2016svf, sui2014detecting, xie2005scalable}.
All elements within an array or a union structure are considered to be aliases.
In our implementation,  we have utilized the existing methods to resolve points-to relations~\cite{shi2018pinpoint}.

\textbf{Program Dependence Graph (PDG).}
Given the program $P$, PDG is constructed to characterize how a value flows from one program statement to another through edges labeled with path constraints.
We follow the previous works~\cite{sui2016svf, sui2014detecting, shi2018pinpoint} to construct the program dependence graph, where the definition, the use of all variables, and operators are modeled as vertices.
% The set of guard vertices is generated by the existing quasi-path-sensitive analysis~\cite{shi2018pinpoint}.

% Specifically, symbolic expressions within the program, such as "$a \leq b + c$", are efficiently represented in the PDG by using vertices for operators, 
% enabling efficient querying of symbolic expressions and construction of path conditions.



% \begin{figure}[t]
%     \begin{align*}
%         Program~P~   &:=~F+ \\
%         Function~F~  &:=~f(v_1, v_2, ...)~=~\{~S;~\} \\
%         Statement~S~ &:=~v~=~e
%                         ~|~v~=~f(v_1,v_2,...,v_n) 
%                         ~|~\textbf{return}~e \\
%                         &~|~\textbf{if}(e)~\{~S_1;~\} 
%                         ~|~S_1;S_2\\
%         Expression~e~&:=~\langle v \rangle
%                         ~|~u
%                         ~|~u_1~\oplus~u_2
%                         ~|~\otimes~u
%                         ~|~ite(u_1,u_2,u_3) \\
%         Operator~\oplus~&:=~+
%                         ~|~-
%                         ~|~=
%                         ~|~...
%                         \quad
%                         \otimes~:=~\neg
%                         ~|~-
%                         ~|~...
%     \end{align*}
%     \vspace{-0.2cm}
%     \caption{The syntax of the language.}
%     \label{fig:language}
%     \vspace{-0.4cm}
% \end{figure}


\begin{definition}[]
\label{def:pdg}
A program dependence graph for a function is a directed graph denoted as $G=(V, O, E_d, E_c)$:
% where each component is defined as follows:
\begin{itemize}
    \item $V$ is a set of vertices, each of which is denoted by $v@s_i$, meaning the variable $v$ is defined or used at a statement $s_i$.
    We write $v@s_i$ as $v_i$ for short as the program is in the SSA form.
    The guard vertices are denoted as $V_{\text{g}} \subseteq V$.
    % $V_{\text{g}} \subseteq V$ is the set of guard vertices in $V$, 
    \item $O$ is a set of operator vertices (binary $\oplus$ or unary $\otimes$), each of which represents a symbolic expression.
    \item $E_d \subseteq (V \cup O) \times (V \cup O)$ is a set of directed edges.
    $(v_i, v_j) \in E_d$ means that the value $v_i$ flows to value $v_j$.
    Edges are labeled with guards from $V_{\text{g}} \cup true $, which represent the constraints that qualify the value flow.
    % Edges are labeled with guards from $V_{\text{g}} \cup true $ by labeling function $L_d$. 
    % These labels represent the constraints that qualify data dependence relations.
    \item $E_c \subseteq V \times V_b$ is a set of control dependence edges.
    % each of which is labeled by $L_c: E_c \rightarrow \{true, false\}$.
    % For each edge $(v_i, u_j) \in E_c$, the $v_i$ is reachable at runtime if and only if the branch condition defined by the guard $u_j$ is $L_c((v_i, u_j))$.
\end{itemize}

\end{definition}

% Once a PDG (denoted as $G_f$) is constructed for each function $f$, the program dependence graph for the entire program (denoted as $P$) can be obtained by concatenating all the individual function PDGs.
% For every function invocation within the program, additional edges are introduced between the actual and formal parameters, as well as between the actual return values and formal return values.
% These additional edges represent the data dependencies that arise from passing arguments and returning values between functions.

\begin{example}
    In Fig.~\ref{fig:motivation_ex}(b), the two value flows from $c_1$ to $printf(*c_8)$ and from $p_{11}$ to $printf(*p_{13})$ are qualified by the branch expressions at Line 7 and Line 12. 
    Therefore, the two edges $(c_1, print(*c_8))$ and $(p_{11}, printf(*p_{13}))$ are labeled by guards $\varphi_1$ and $\varphi_2$. 
    The expression of these branches can be derived by searching the PDG from guard vertices $\varphi_1$ and $\varphi_2$, which are $e_7 \neq NULL_{7}$ and $p_{11} \neq NULL_{12}$, respectively.
    \label{example:pdg}
\end{example}


To check a given value-flow path $\pi$~\cite{shi2018pinpoint}, the path condition $\phi_{\pi}$ incorporates not only the value flows represented by the edges but also the value flows related to the instantiation of the guard vertices labeled on those edges. 
Note that these two categories of value flows are not identical. The value flows related to the instantiation of guard vertices can be interconnected with the value flows of other paths. Thus, the path condition $\phi_{\pi}$ often relates more paths beyond just $\pi$.

% In the example for the derived guard vertices $\varphi_1 \equiv e_7 \neq NULL_7$ and $ \varphi_2 \equiv p_{11} \neq NULL_{12}$, the path-sensitive value flow analysis additionally needs to track which values flow into $e_7$ and $p_{11}$ to assess the feasibility of the paths encompassing the value flows $(c_1, printf(*c_8))$ and $(p_{11}, printf(*p_{13}))$.
% The tracking of $e_7$ and $p_{11}$ is an instantiation of $\varphi_1$ and $\varphi_2$.

% The tracking of $e_7$ and $p_{11}$ is an instantiation of $\varphi_1$ and $\varphi_2$, 
% which contributes to the path condition that is included on a value flow path.

\begin{example}
\label{example:path_condition}
    Recall Fig.~\ref{fig:motivation_ex}(c),
    the summary $\pi_7: c_1 \xrightarrow{\varphi_1} printf(*c_8)$ summaries the value flow from $c_1$ to $c_8$ with the guard $\varphi_1$. 
    The value flow represented by the edge is encoded as $c_8 = c_1 \land \varphi_1$.
    When instantiating the constraint represented by the guard $\varphi_1$, which states that $e_7 \neq NULL_{7}$, the value flow of $e_7$ is tracked.
    This results in the identification of the summary path of $\pi_6$, represented as $NULL^{\prime}_{19} \rightarrow m^{\prime}_{20} \rightarrow \dots \rightarrow e_{6} \rightarrow e_7$. 
    Consequently, the path condition of $\pi_6$ is applied in this context. 
    Taking all of this into consideration, the path condition of $\pi_7$ can be expressed as $c_8 = c_1 \land e_7 \neq NULL_{7} \land \phi_{\pi_{6}}$.
    Summary condition $\phi_{\pi_{7}}$ involves more complex value flow than summary path $\pi_{7}$ due to instantiating the constraint represented by the guard $\varphi_1$.
\end{example}


Given a value-flow path $\pi$ on the program dependence graph $G$, $\pi[i]$ represents $i-$th vertex $v_i@s_i$ on the path. 
Specifically, we use $\pi[-1]$ to denote the tail element of $\pi$.
Given sets $V_1$ and $V_2$, which are subsets of the vertices $V$ in the PDG, we use $\Pi(V_1, V_2)$ to represent the set of value-flow paths from a vertex in $V_1$ to another vertex in $V_2$.

The path conditions of a set of value-flow paths $\Pi(V_1, V_2)$ are represented as $\Phi(V_1, V_2, V_{\text{g}})$, 
The additional $V_{\text{g}}$ denotes the set of guard vertices that necessitate instantiation during the construction of the path conditions. 
% In situations where the vertices $V_1$ and $V_2$ can be inferred from the context, they can be omitted, and the abbreviated notations $\Pi$ and $\Phi$ can be used.
% A value-flow path $\pi_1$ can concatenate to other $\pi_{2}$, denoted as $\pi_1 + \pi_2$, if and only if $(\pi_{1}[-1], \pi_{2}[0]) \in E_d$.
% Thus, the concatenation of two sets of value-flow paths $\Pi(V_1, V_2)$ and $\Pi(V_3, V_4)$ is defined as $\Pi(V_1, V_2)$ + $\Pi(V_3, V_4)$ = $\{
% \pi_1 + \pi_2 : \pi_{1} \in \Pi(V_1, V_2) \wedge \pi_2 \in \Pi(V_3, V_4) \wedge (\pi_{1}[-1], \pi_{2}[0]) \in E_d
% \}$

% \begin{figure}[t]
%     \centering
%     \includegraphics[width=\columnwidth]{figs/bottom_up.pdf}
%     \caption{Example of collecting a source-sink path in a bottom-up manner. $\bullet$ denotes entries of the function boundaries, i.e., actual parameters and actual returns at call sites.}
%     \label{fig:bottom_up}
%     \vspace{-0.4cm}
% \end{figure}

\textbf{Bottom Up Value Flow Analysis.}
Given the PDG and bug-specific sources $V_{\text{src}}$ and sinks $V_{\text{sink}}$, the path-sensitive value flow analysis is to collect $\Pi(V_{\text{src}}, V_{\text{sink}})$ and $\Phi(V_{\text{src}}, V_{\text{sink}}, V_{\text{g}})$.
To determine the presence of bugs, each path $\pi$ in $\Pi(V_{\text{src}}, V_{\text{sink}})$ is evaluated by checking its path condition $\phi_{\pi}$ using a constraint solver.
If the path condition $\phi_{\pi}$ is determined to be \textit{sat}, the path $\pi$ is reported as a detected bug.
To scale up the collection of $\Pi(V_{\text{src}}, V_{\text{sink}})$ and $\Phi(V_{\text{src}}, V_{\text{sink}}, V_{\text{g}})$, the existing path-sensitive approaches~\cite{cousot2002modular, xie2005scalable, shi2018pinpoint, shi2020conquering, shi2020pipelining, shi2021path} use a compositional manner that analyses each function on a call graph from the bottom.
Note that existing bottom-up analyses~\cite{cousot2002modular, xie2005scalable, shi2018pinpoint, shi2020conquering, shi2020pipelining} first compute the Strongly Connected Components (SCC) of the call graph to make it acyclic.
Then, the path-sensitive methods compute symbolic summaries for each function. 
These summaries are subsequently instantiated in the callers' different contexts, allowing them to be reused to merge various source-sink paths and their corresponding path conditions, thereby eliminating the redundant re-analysis of each function.

However, the alternative top-down approaches~\cite{reps1995precise, reps1994speeding, murphy1999program, sagiv1996precise} analyze functions in a call graph from top to bottom, producing summaries for specific program contexts that cannot be reused for all source-sink paths. Thus, they require analyzing the same function multiple times for different calling contexts, sacrificing path sensitivity. 
As a result, these approaches can only determine the reachability of a source-sink pair without providing the connecting paths and path conditions.

% Avoiding redundancy distinguishes the bottom-up method from the alternative top-down analysis in a call graph~\cite{reps1995precise, reps1994speeding, murphy1999program, sagiv1996precise}. 
% Specifically, top-down approaches analyze functions from the top layers to the bottom layers, producing summaries in specific program contexts that cannot be reused for all source-sink paths. 
% Top-down approaches require analyzing the same function multiple times for different calling contexts, sacrificing path sensitivity. 
% As a result, they can only determine the reachability of a source-sink pair without providing their connecting paths and path conditions.

% \begin{algorithm}[t]\small
%   \caption{Path-Sensitive Value Flow Analysis}
%   \label{alg:ps-vf-analysis}
%   \SetKwProg{Proc}{Procedure}{}{}
%   \SetKwComment{Comment}{//}{}
%   \SetKwInOut{Input}{Input}
%   \SetKwInOut{Output}{Output}
%   \Proc{$\texttt{path\_sensitve\_value\_flow(P)}$} {
%       Build call graph $CG$ and PDGs of the functions in \texttt{P} \;
%       /*~\textit{Initialize summary sets.}~*/\;
%       $S(V_{\text{src}}, V_{\text{sink}}) \leftarrow \emptyset$\;
%       \ForEach{$f \in CG$}{
%             $S^{f}(V_{\text{src}}, V_{\text{sink}}) \leftarrow \emptyset$;
%             $S^{f}(V_{\text{fp}}, V_{\text{fr}}) \leftarrow \emptyset$ \;
%             $S^{f}(V_{\text{fp}}, V_{\text{sink}}) \leftarrow \emptyset$;
%             $S^{f}(V_{\text{src}}, V_{\text{fr}})  \leftarrow \emptyset$\;
%       }

%       \ForEach{$f$ $\in$ $CG$ in bottom-up order} {

%             \ForEach{c $\in$ callees of $f$}{
%             \resizebox{0.8\columnwidth}{!} {
%             $
%             \begin{aligned}
%                 & /*~\textit{Collect and solve transfer summary.}~*/   & \\
%                 & S^{f}(V_{\text{fp}}, V_{\text{fr}}) = \left\{ 
%                 \begin{aligned}
%                 \, &\Pi^{f}(V_{\text{fp}}, V_{\text{ap}}) + \begingroup \color{red}\Pi^{c}(V_{\text{fp}}, V_{\text{fr}})\endgroup +\Pi^{f}(V_{\text{ar}}, V_{\text{fr}}) &\\
%                 \, &\Phi^{f}(V_{\text{fp}}, V_{\text{ap}}, V_{\text{g}}) + \begingroup \color{red}\Phi^{c}(V_{\text{fp}}, V_{\text{fr}}, V_{\text{g}})\endgroup +\Phi^{f}(V_{\text{ar}}, V_{\text{fr}}, V_{\text{g}}) &\\
%                 \, &S^{f}(V_{\text{fp}}, V_{\text{fr}}) &
%                 \end{aligned}\right.
%                 &\\
%                 & \forall (\pi, \varphi) \in S^{f}(V_{\text{fp}}, V_{\text{fr}}),\, \text{remove}\, (\pi, \varphi)\, \text{if}\, \varphi\, \text{is}\, \text{unsat;} &\\
%                 &\\
%             \end{aligned}
%             $
%             }
            
            
%             \resizebox{0.8\columnwidth}{!} {
%             $
%             \begin{aligned}
%                 & /*~\textit{Collect and solve input summary.}~*/ & \\
%                 & S^{f}(V_{\text{fp}}, V_{\text{sink}}) = \left\{  
%                 \begin{aligned}
%                 \, & S^{f}(V_{\text{fp}}, V_{\text{ap}}) + \begingroup \color{red}S^{c}(V_{\text{fp}}, V_{\text{fr}})\endgroup + S^{f}(V_{\text{ar}}, V_{\text{sink}}) & \\
%                 \, & S^{f}(V_{\text{fp}}, V_{\text{ap}}) + \begingroup \color{red}S^{c}(V_{\text{fp}}, V_{\text{sink}})\endgroup & \\
%                 \, & S^{f}(V_{\text{fp}}, V_{\text{sink}}) & 
%                 \end{aligned}\right.\\
%                 & \forall (\pi, \varphi) \in S^{f}(V_{\text{fp}}, V_{\text{sink}}),\, \text{remove}\, (\pi, \varphi)\, \text{if}\, \varphi\, \text{is}\, \text{unsat;} &\\
%                 & \\
%             \end{aligned}
%             $
%             }

%             % \ForEach{$(\pi, \varphi)$ $\in$ $S^{f}(V_{\text{fp}}, V_{\text{sink}})$} {
%             %     Solve $\varphi$ and remove the $(\pi, \varphi)$ if $\varphi$ is unsat\;
%             % }
            
            
%             \resizebox{0.8\columnwidth}{!} {
%                 $
%                 \begin{aligned}
%                     & /*~\textit{Collect and solve output summary.}~*/ & \\
%                     & S^{f}(V_{\text{src}}, V_{\text{fr}}) = \left\{  
%                     \begin{aligned}
%                     \, & S^{f}(V_{\text{src}}, V_{\text{ap}}) +\begingroup \color{red}S^{c}(V_{\text{fp}}, V_{\text{fr}})\endgroup +S^{f}(V_{\text{ar}}, V_{\text{fr}}) & \\
%                     \, & S^{f}(V_{\text{src}}, V_{\text{fr}}) & \\
%                     \, & \begingroup \color{red}S^{c}(V_{\text{src}}, V_{\text{fr}})\endgroup & \\
%                     \end{aligned}\right. & \\
%                 & \forall (\pi, \varphi) \in S^{f}(V_{\text{src}}, V_{\text{fr}}),\, \text{remove}\, (\pi, \varphi)\, \text{if}\, \varphi\, \text{is}\, \text{unsat;} &\\
%                 &\\
%                 \end{aligned}
%                 $
%             }
            
%             %  \ForEach{$(\pi, \varphi)$ $\in$ $S^{f}(V_{\text{src}}, V_{\text{fr}})$} {
%             %     Solve $\varphi$ and remove the $(\pi, \varphi)$ if $\varphi$ is unsat\;
%             % }
            
%              % \forall $(\pi, \varphi)$ $\in$ $S^{f}(V_{\text{src}}, V_{\text{fr}})$ remove $(\pi, \varphi)$ if $\varphi$ is unsat\;
             
            
            
%             \resizebox{0.8\columnwidth}{!} {
%             $
%             \begin{aligned}
%                 & /*~\textit{Collect and solve source-sink path.}~*/ & \\
%                 & S^{f}(V_{\text{src}}, V_{\text{sink}}) = \left\{  
%                 \begin{aligned}
%                 \, & S^{f}(V_{\text{src}}, V_{\text{ap}}) +\begingroup \color{red}S^{c}(V_{\text{fp}}, V_{\text{fr}})\endgroup +S^{f}(V_{\text{ar}}, V_{\text{sink}}) & \\
%                 \, & \begingroup \color{red}S^{c}(V_{\text{src}}, V_{\text{fr}})\endgroup +S^{f}(V_{\text{ar}}, V_{\text{sink}}) & \\
%                 \, & S^{f}(V_{\text{src}}, V_{\text{sink}}) & \\
%                 \end{aligned}\right.
%                  & \\
%                  & S(V_{\text{src}}, V_{\text{sink}}) \leftarrow S(V_{\text{src}}, V_{\text{sink}}) \vee S^{f}(V_{\text{src}}, V_{\text{sink}}) &\\
%             \end{aligned}
%             $
%             }
%             % \ForEach{$(\pi, \varphi)$ $\in$ $S^{f}(V_{\text{src}}, V_{\text{sink}})$} {
%             %     Solve $\varphi$ and report $\pi$ as a bug if $\varphi$ is sat. \;
%             % }
%       }}             
%     $ \forall (\pi, \varphi) \in S(V_{\text{src}}, V_{\text{sink}}),\, \text{report}\, \pi\, \text{as}\, \text{a}\, \text{bug}\, \text{if}\, \varphi\, \text{is}\, \text{sat;} $
%   }
%   \vspace{-0.2cm}
% \end{algorithm}

\begin{algorithm}[t]\small
  \caption{Path-Sensitive Value Flow Analysis}
  \label{alg:ps-vf-analysis}
  \SetKwFunction{Q}{pathSensitveAnalysis}
  \SetKwProg{Proc}{Procedure}{}{}
  \SetKwComment{Comment}{//}{}
  \Proc{\Q{P}} {
    Build call graph CG and PDG of {P}\;
      $S(V_{\text{src}}, V_{\text{sink}}) \leftarrow \emptyset$\;
      \ForEach{$f \in CG$}{
      \resizebox{0.8\columnwidth}{!} {
            $S^{f}(V_{\text{fp}}, V_{\text{fr}}) \leftarrow \emptyset$;
            $S^{f}(V_{\text{fp}}, V_{\text{sink}}) \leftarrow \emptyset$;
            $S^f(V_{\text{src}}, V_{\text{fr}})$\;}
      }

    \ForEach{$f$ $\in$ $CG$ in bottom-up order} {
        \ForEach{c $\in$ callees of $f$}{
        \texttt{collectCloneSolveSmry}($S^f(V_{\text{fp}}, V_{\text{fr}}),c$)\;
        \texttt{collectCloneSolveSmry}($S^f(V_{\text{fp}}, V_{\text{sink}}),c$)\;
        \texttt{collectCloneSolveSmry}($S^f(V_{\text{src}}, V_{\text{fr}}),c$)\;
        \texttt{collectSrcSinkPath}($S(V_{\text{src}}, V_{\text{sink}}), c$)\;
        }
    }
    $ \forall (\pi, \varphi) \in S(V_{\text{src}}, V_{\text{sink}}),\, \text{report}\, \pi\, \text{as}\, \text{a}\, \text{bug}\, \text{if}\, \varphi\, \text{is}\, \textit{sat;} $
  }
  % \vspace{-0.2cm}
\end{algorithm}

To construct complete source-sink paths, bottom-up approaches gather three types of summaries.
\begin{definition}[Function Summary]
A summary for the function $f$ is represented by a tuple $s = (\pi, \phi_{\pi})$, 
where summary path $\pi$ captures a value flow path after the callee functions' summaries are cloned.
The summary condition $\phi_{\pi}$ encodes value flows of $\pi$ and value flows instantiated from guard vertices that are labeled on $\pi$.
\begin{itemize}
    \item Transfer summary $S(V_{\text{fp}}, V_{\text{fr}})$ summarizes value flow paths from the function's formal parameters $V_{\text{fp}}$ to the function's formal return $V_{\text{fr}}$. 
    \item Input summary $S(V_{\text{fp}}, V_{\text{sink}})$ summarizes value flow paths from the function's formal parameters to a sink within the function or its callee functions.
    \item Output summary $S(V_{\text{src}}, V_{\text{fr}})$ summarizes value flow paths from sources to the function's formal return. The sources are found within the function or callee functions.
\end{itemize}
\end{definition}

Existing work~\cite{shi2020conquering,shi2018pinpoint} shows that collecting these different categories of value flow paths is sound for bug detection.
Corresponding to $V_{\text{fp}}$ and ${V}_{\text{fr}}$ that represent the sets of formal parameters and formal return,
${V}_{\text{ap}}$ and ${V}_{\text{ar}}$ represent the sets of actual parameters and actual return.
% \begin{example}
% Recall Fig.~\ref{fig:motivation_ex}(c): summary $\pi_{1}$ is the output summary collected from function \textit{qux}, summary $\pi_{2}$ is the transfer summary collected from function \textit{baz}, and summary $\pi_{3}$ is the input summary collected from function \textit{bar}.
% \end{example}
We denote total summaries that are collected from function $f$ as $S^{f}(V_{h}, V_{t})=(\Pi^{f}, \Phi^{f})$.
$V_{h}$ and $V_{t}$ are the head vertices and tail vertices of the summary path that could be collected in Algorithm~\ref{alg:ps-vf-analysis}.
Specifically, $V_{h}$ are the head vertices come from $V_{\text{fp}}$, $V_{\text{ar}}$ and $V_{\text{src}}$, and $V_{t}$ are the tail vertices come from $V_{\text{ap}}, V_{\text{fr}}, V_{\text{sink}}$, and $V_{\text{g}}$.

Algorithm~\ref{alg:ps-vf-analysis} presents the existing bottom-up summary collection~\cite{cousot2002modular, xie2005scalable, shi2018pinpoint, shi2020conquering, shi2020pipelining, shi2021path} of $ S(V_{\text{src}}, V_{\text{sink}})$ for the given program $P$. 
In general, it is accomplished by two helper functions: \texttt{collectCloneSolveSmry} and \texttt{collectSrcSinkPath}. 
The first function, \texttt{collectCloneSolveSmry}, is responsible for collecting summaries by cloning the callee's summaries and then solving the summary condition, filtering out the \textit{unsat} ones.
The second function, \texttt{collectSrcSinkPath}, collects the source-sink paths that can be discovered after collecting the summaries in the current function.
The overall Algorithm~\ref{alg:ps-vf-analysis} begins by constructing the CG and PDG for the program $P$. 
It then initializes a global set $S(V_{\text{src}}, V_{\text{sink}})$ to maintain all the source-sink paths, as well as three summary sets for each function to maintain the three types of summaries. 
The algorithm proceeds to process each function in a bottom-up fashion, collecting three types of function summaries (in Lines 8, 9, and 10) and source-sink paths (in Line 11), assisted by the two helper functions.
Finally, the algorithm reports bugs in Line 12 by solving the path condition after all functions have been analyzed.

The \texttt{collectCloneSolveSmry} helper collects summaries directly from the current function if the value flow path does not pass through a function call. Otherwise, it collects summaries by concatenating the inlined summaries from the called function $c$. 
For example, in Fig.~\ref{fig:motivation_ex}, the summaries $\pi_{1}$ $\pi_{2}$, and $\pi_{3}$ are collected directly from their respective functions, while others are collected by concatenating callee summaries.

A single summary is collected in two steps: collecting the summary path $\Pi$ and instantiating the summary condition $\Phi$. 
Instantiating the summary condition often requires additional summary paths. 
As demonstrated in Example~\ref{example:path_condition}, instantiating a summary condition often involves additional value flow starting from the guard vertex labeled on the summary path. 
Once a condition is instantiated, it is solved by a constraint solver. 
If a summary's condition is \textit{unsat}, the summary is discarded because an infeasible summary implies that the resulting source-sink path is also infeasible.
The helper function puts the feasible summaries into three types of summary sets, which would be used in the caller functions in the incoming analysis.
At that time, the summaries are inlined, which helps the caller form long summaries and possible source-sink paths.


\begin{example}
Recall Fig.~\ref{fig:motivation_ex}(c). 
Functions \textit{qux}, \textit{baz}, and \textit{bar} are called by the function \textit{foo}. 
Thus, \textit{qux}, \textit{baz}, and \textit{bar} are analyzed first, while \textit{foo} is analyzed later.
In function \textit{qux}, only the output summary $s_{1}$ is generated between the source $V_{\texttt{src}} = \{NULL_{19}\}$ and the formal return $V_{\texttt{fr}} = \{m_{20}\}$, and then $\phi_{\pi_{1}}$ is verified.
Thus, \textit{qux} has $S^{\texttt{qux}}(V_{\texttt{src}}, V_{\texttt{fr}}) = \{s_1=(\pi_{1},\phi_{\pi_{1}})\}$, with the other three sets being empty.
In function \textit{baz}, only the transfer summary $s_{2}$ is collected between the formal parameter $V_{\texttt{fp}} = \{f_{15}\}$ and the formal return $V_{\texttt{fr}} = \{f_{16}\}$, with the condition verified.
Thus, \textit{baz} has $S^{\texttt{baz}}(V_{\texttt{fp}}, V_{\texttt{fr}}) = \{s_2=(\pi_{2},\phi_{\pi_{2}})\}$, with the other three sets being empty.
In function \textit{bar}, the input summary $s_{3}$ is collected between the formal parameter $V_{\texttt{fp}} = \{p_{11}\}$ and the sink $V_{\texttt{sink}} = \{printf(*a_{9})\}$, with condition verified.
Thus, \textit{bar} owns $S^{\texttt{bar}}(V_{\texttt{fp}}, V_{\texttt{sink}}) = \{s_3=(\pi_{3}, \phi_{\pi_{3}})\}$, with the other three sets being empty.
Since there is a conditional edge in $\pi_{3}$, its summary condition $\phi_{\pi_{3}}$ involves the instantiation of the constraint represented by the guard $\varphi_2$, which is $p_{11} \neq NULL_{11}$. This involves the value flow path of $p_{11}$, which coincides with its summary path.

\end{example}

\begin{example}
    When analyzing the top layer function \textit{foo}, the summaries are cloned from the bottom layer functions accordingly.
    When collecting the transfer summaries starting from formal parameter $V_{\texttt{fp}} = \{ c_1 \}$, which reaches a sink $printf(*c_8)$ but cannot reach any actual input in $V_{ap} = \{ a_{5}, b_{6} \}$, no transfer summaries are gathered as a result.

    When collecting the input summaries, the summary $s_{7}$ is generated with a summary path collected from the formal parameter $V_{\texttt{fp}} = \{c_1\}$ to the sink $V_{\texttt{sink}} = \{printf(*c_8)\}$, without cloning callee summaries. 
    However, the summary condition $\phi_{\pi_7}$ necessitates instantiating the guard vertex $\varphi_{1}$, where $V_{g} = \{\varphi_{1}\}$.
    To this end, the value flow starting from $\varphi_{1}$ is tracked. 
    When reaching the actual output $e_6$ of the function call to \textit{bar} in line 6, the summary $s_{2}$ is cloned from the callee \textit{bar}. 
    Moving forward, when reaching the actual output $b_3$ of the function call to \textit{qux} in line 3, the summary $s_{1}$ is cloned, thus forming the summary $s_{6}$.
    Finanly $\phi_{\pi_7}$ is verified.

    When collecting the output summaries, because the $V_{\texttt{src}}$ in the current function is empty, the output summaries of the callee function are cloned, introducing additional sources. 
    Thus, in line 2, the summary $s_{1}$ is inlined again, which is the output summary of the function \textit{qux}.
    By combining the summary $s_{1}$, the value path from the output $a_2$ to $a_5$ is traced and involves the call to the function \textit{bar} in line 5. 
    Since $a_5$ is passed to \textit{bar}, the input summary or transfer summary that starts at the corresponding formal parameter is inlined. 
    In our case, the input summary $s_{3}$ of the function \textit{bar} is inlined. 
    After concatenating with the input summary, the path reaches a sink, forming a complete source-sink path, but does not reach any formal return. Thus, no output summary is collected.
    
\end{example}


The \texttt{collectSrcSinkPath} helper is similar to the \texttt{collectCloneSolveSmry} but tries to collect the source-sink paths in each iteration and does not solve the path conditions. 
In the example of Fig.~\ref{fig:motivation_ex}, the helper collects no source-sink paths from bottom-layer functions, as no such paths are formed, but it collects two source-sink paths, $s_4$ and $s_5$, from the upper-layer function \textit{foo}.
Eventually, $\phi_{\pi_4}$ and $\phi_{\pi_5}$ are solved when reporting bugs in Line 12 of Algorithm~\ref{alg:ps-vf-analysis}.


% We denote total summaries that are collected from function $f$ as $S^{f}(V_{h}, V_{t})=(\Pi^{f}, \Phi^{f})$.
% $V_{h}$ and $V_{t}$ are the head vertices and tail vertices of the summary path that could be collected in Algorithm~\ref{alg:ps-vf-analysis}.
% Specifically, $V_{h}$ are the head vertices come from $V_{\text{fp}}$, $V_{\text{ar}}$ and $V_{\text{src}}$, and $V_{t}$ are the tail vertices come from $V_{\text{ap}}, V_{\text{fr}}, V_{\text{sink}}$, and $V_{\text{g}}$.
% Upon reaching the root of the call graph, the algorithm terminates, and all source-sink summaries $S(V_{\text{src}}, V_{\text{sink}}) = (\Pi(V_{\text{src}}, V_{\text{sink}}), \Phi(V_{\text{src}}, V_{\text{sink}}, V_{\text{g}}))$ for the entire program are collected. 
% Here, $\Pi(V_{\text{src}}, V_{\text{sink}})$ represents the set of source-sink paths, and $\Phi(V_{\text{src}}, V_{\text{sink}}, V_{\text{g}})$ represents the set of instantiated path conditions. 
% Some of these summaries may not be used for concatenating source-sink paths but are utilized to instantiate the guard vertices labeled on the source-sink paths. 
% Finally, the collected summaries are verified to report any bugs.




% \vspace{0.2cm}
% \mybox{
% \textbf{Problem Statement:}
% Our research goal is to identify non-contributing summaries without the need to collect $S(V_{\text{src}}, V_{\text{sink}})$. 
% It is crucial for the identification process to be efficient, ensuring that the cost of identification is lower than the potential redundancy it aims to prevent.
% }