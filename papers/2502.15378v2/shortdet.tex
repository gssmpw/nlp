\section{Short-Detour Replacement Paths}
\label{sec:short}

%This section will deal with the case of short detour paths, specifically those of length at most $\zeta = n^{\frac{2}{3}}$. We will show that there exists an algorithm
%\yijun{Sometimes you mix ``replacement paths'' with ``detours'' - they are different}

In this section, we prove the following result. %\yijun{I am thinking about rewriting the proof using the notation $X[i,j]$ is the shortest replacement path length with a short detour from precisely $v_i$ to $v_j$. We define $X[\leq i,j]$ similarly, by allowing the detour to start at or before $v_i$. The notations $X[i, \geq j]$ and $X[\leq i, \geq j]$ are defined similarly. Notice that $dp_{i,d} = X[\leq i, \geq i+1]$ and $l_{i,d} = X[i,\geq i+d]$}\yijun{work in progress...}\yijun{I have back up  the old version... if the new approach does not work well, can revert}



%\yijun{Todo: unify the statement with the next section, check if we just want to let the first endpoint of an edge output the result.}

\begin{restatable}[Short detours]{proposition}{shortdetour}
\label{thm:shortdetour}
For unweighted directed graphs, there exists an $O(\zeta)$-round deterministic algorithm that lets the first endpoint $v_i$ of each edge $e=(v_i, v_{i+1})$ in $P$ compute the shortest replacement path length for $e$ with a short detour.
%runs for $O(\zeta)$ rounds in the $\CONGEST$ model such that for every edge $(u,v)$ in $P$, $u$ learns the length of the shortest possible replacement path after deleting the edge $(u,v)$ using a short detour.
\end{restatable}

Recall that $\zeta$ is the threshold between a short detour and a long detour. While we set  $\zeta=n^{2/3}$ in \Cref{sec:prelim}, we emphasize that \Cref{thm:shortdetour} works for any choice of $\zeta$. \Cref{thm:shortdetour} is proved by an algorithm consisting of two stages, as follows. 

\begin{description}
    \item[Stage 1: Hop-constrained BFS.] We run a BFS from every vertex $v$ in $P$ for $\zeta$ hops \emph{backward}, meaning that the direction of the edges are reversed. To deal with any potential congestion issue, in each step, each vertex propagates only the BFS tree originating from the furthest vertex in $P$, dropping all the remaining branches, so all BFS can be completed in $\zeta$ rounds. This still allows each vertex in $P$ to learn the furthest vertex in $P$ that can be reached by a detour path starting from $v$ of length $d$, for all $d \in [\zeta]$. 
    \item[Stage 2: Information pipelining.] Using the information from hop-constrained BFS, each vertex can locally compute the best detour to skip all of the next $x$ edges in front of it, for all $x \in [\zeta]$. With a $(\zeta-1)$-round dynamic programming algorithm, the two endpoints of each edge $e$ in $P$ can compute the shortest replacement path length for $e$ with a short detour.
\end{description}

In this section, whenever $S = \emptyset$, we use the convention that $\max S = -\infty$ and $\min S = \infty$.



\subsection{Hop-Constrained BFS}


Recall that $P = (v_1, \ldots, v_{h_{st}-1})$ is the given $s$-$t$ shortest path.
For each vertex $u$ in the graph $G$, we define $f_u^\ast(d)$ as the largest index $j$ satisfying the following conditions:
\begin{itemize}
    \item There exists a path from $u$ to $v_j$ of length exactly $d$ avoiding all edges in $P$.
    \item For any $\ell > j$, there is no path from $u$ to $v_\ell$  of length exactly $d$ avoiding all edges in $P$.
\end{itemize}
If such an index $j$ does not exist, we set $f_u^\ast(d) = -\infty$. 
%As mentioned above, the goal for this part is for each vertex $v$ along $P$ to find the farthest vertex along $P$ that can be reached by a detour path of length $d$ starting from $v$ for $d=1,2,\dots,\zeta$.

\begin{restatable}[Hop-constrained BFS]{lemma}{backwardsBFS}
\label{Thm: Backward BFS Works}
There exists an $O(\zeta)$-round deterministic algorithm that lets each vertex $u$ in the graph $G$ compute $f_u^\ast(d)$ for all $d \in [\zeta]$.
    %Consider an instance of the replacement path problem. Then there exists an algorithm that runs in $O(z)$ rounds such that at the end, every vertex $v$ along $P$ knows of $v_d$, the farthest possible vertex along $P$ that can be reached by a detour path of length $d$ starting from $v$ for all $d=1,2,\dots,z$.
\end{restatable}
\begin{proof}
Intuitively, it suffices to run a $\zeta$-hop  BFS from each vertex in $P$, where in each step, each vertex propagates only the BFS tree originating from the furthest vertex in $P$. We formalize this proof idea, as follows.


In the first round of the algorithm, each vertex $v_i$ in $P$ sends its index $i$ to all its incoming edges, excluding the edges in $P$. 
For each vertex $u$ in $G$, we write $S_d(u) \subseteq[h_{st}-1]$ to denote the set of messages received by $u$ in the $d$th round of the algorithm. For the base case of $d = 0$, we set $S_0(v_i) = \{i\}$ for each vertex $v_i$ in $P$ and set $S_0(u) = \emptyset$ if $u$ does not belong to $P$.

For $d = 2, \ldots, \zeta$, in the $d$th round of the algorithm, for each vertex $u$ in $G$, if $S_{d-1}(u) \neq \emptyset$, then $u$ sends $\max S_{d-1}(u)$ to all its incoming edges, excluding the edges in $P$. Intuitively, $S_{d-1}(u)$ is the collection of BFS that reaches $u$ at round $d-1$, and the algorithm lets $u$ propagate only the BFS originating from the furthest vertex in $P$ in round $d$. 

It can be proved by an induction on $d$ that the following claim holds, so the algorithm indeed lets each vertex $u$ correctly compute $f_u^\ast(d)$ for each $d \in [\zeta]$.
\[f_u^\ast(d) = \max S_{d}(u).\]

%\begin{cases}
%    \max S_{d}(u), & \text{if $S_{d}(u) \neq \emptyset$,}\\
%    -\infty, & \text{otherwise.}
%\end{cases}\]
%For the special case that $S_{d}(u) = \emptyset$, we let $f_u^\ast(d) = -\infty$.
The claim holds for $d=0$ by the definition of $S_0$. Assuming that the claim already holds for $d-1$, to see that the claim holds for $d$, observe that
\[f_u^\ast(d) = \max_{x \, : \, (u,x)\in E} f_{x}^\ast(d-1) = \max_{x \, : \, (u,x)\in E}\max S_{d-1}(x) = \max S_{d}(u),\]
as required.
\end{proof}

\subsection{Information Pipelining} 
Let us introduce some additional notations. For any $i < j$, we define $X[i, j]$ as the shortest length of a replacement path with a short detour that starts precisely at $v_i$ and ends precisely at $v_j$. If such a path does not exist, then $X[i, j] = \infty$. For example, we must have $X[i, j] = \infty$ whenever $j-i > \zeta$. %In other words, $X[i, j]$ is the sum of the following three terms: the distance from $s$ to $v_i$, the distance from $v_i$ to $v_j$ avoiding all edges between $v_i$ and $v_j$ in $P$, and the distance from $v_j$ to $t$. 
Moreover, we define
\begin{align*}
X[\leq i,\,j] &= \min_{i' \, : \, i' \leq i} X[i', j],\\
X[i,\,\geq j] &= \min_{j' \, : \, j' \geq j} X[i, j'],\\
X[\leq i,\,\geq j] &= \min_{i' \, : \, i' \leq i} \, \, \min_{i' \, : \, j' \geq j} X[i', j'].
\end{align*}
Observe that $X[\leq i, \, \geq i+1]$ is precisely the shortest replacement path length with a short detour for the edge $e=(v_i, v_{i+1})$ in $P$, so our objective is to let each $v_i$ learn $X[\leq i, \, \geq i+1]$. The following lemma shows that the information obtained from BFS already allows each $v_i$ to calculate the value of $X[i, \, \geq j]$ for all $j > i$.

\begin{lemma}[Base case]\label{lem:short_base}
The value of $X[i, \, \geq j]$ for all $j > i$ can be determined from the value of $f_{v_i}^\ast(d)$ for all $d \in [\zeta]$.
\end{lemma}
\begin{proof}
We consider the following function:
\[
h^\ast(i,j) = \min\{ d\in[\zeta] \, | \, f_{v_i}^\ast(d)=j\}.
\]
We claim that
\[
X[i, \, \geq j]=\min\{X[i, \, \geq j+1], h_{st}-(j-i)+h^\ast(i,j)\}.\]
Observe that we must have $X[i, \, \geq j] = \infty$ whenever $j-i > \zeta$, so the above claim allows us to determine the value of $X[i, \, \geq j]$ for all $j > i$. For the rest of the proof, we prove the claim. 

\paragraph{Upper bound.} We prove the upper bound $X[i, \, \geq j] \leq \min\{X[i, \, \geq j+1], h_{st}-(j-i)+h^\ast(i,j)\}$. The part $X[i, \, \geq j] \leq X[i, \, \geq j+1]$ follows immediately from the definition of $X[i, \, \geq j]$. The part $X[i, \, \geq j] \leq h_{st}-(j-i)+h^\ast(i,j)$ follows from the fact that $h_{st}-(j-i)+h^\ast(i,j)$ equals the length of some replacement path that has a short detour from $v_i$ to $v_j$ of detour length $h^\ast(i,j)$.

\paragraph{Lower bound.} To show that  $X[i, \, \geq j] \geq \min\{X[i, \, \geq j+1], h_{st}-(j-i)+h^\ast(i,j)\}$, it suffices to show that, if $X[i, \, \geq j] < X[i, \, \geq j+1]$, then $X[i, \, \geq j] = h_{st}-(j-i)+h^\ast(i,j)$. The condition $X[i, \, \geq j] < X[i, \, \geq j+1]$ implies that $X[i, \, \geq j] = X[i, \, j]$, which equals the shortest length of a replacement path with a short detour that starts precisely at $v_i$ and ends precisely at $v_j$. If $h^\ast(i,j)$ equals the length $d$ of a shortest path from $v_i$ to $v_j$ avoiding the edges in $P$, then we have $X[i, \, \geq j] = X[i, \, j] = h_{st}-(j-i)+h^\ast(i,j)$, as required. Otherwise, by the definition of $f^\ast_{v_i}(d)$, there must be a vertex $v_{\ell}$ with $\ell > j$ such that there is a path from $u$ to $v_\ell$  of length exactly $d$ avoiding all edges in $P$, so $X[i, \, \geq j] \leq X[i, \ell] < X[i, \, j]$, which is a contradiction.
\end{proof}


\begin{lemma}[Dynamic programming]\label{lem:short_recursive}
Suppose each vertex $v_i$ in $P$ initially knows the value of $X[i, \, \geq j]$ for all $j > i$. There exists an $O(\zeta)$-round deterministic algorithm that lets each vertex $v_i$ in $P$ compute $X[\leq i, \, \geq i+1]$.
\end{lemma}
\begin{proof}
For the base case, each vertex $v_i$ can locally compute 
\[X[\leq i, \, \geq i+\zeta]=X[i, \, \geq i+\zeta],\]
since any short detour path that starts at or before $v_{i}$ and ends at or after  $v_{i+\zeta}$ must starts precisely at $v_{i}$ and ends precisely at $v_{i+\zeta}$.

For $d = \zeta, \zeta-1, \ldots, 2$, assuming that each vertex $v_i$ in $P$ already knows $X[\leq i, \, \geq i+d]$, then we can let each vertex $v_i$ in $P$ compute $X[\leq i, \, \geq i+(d-1)]$ using one round of communication. Observe that
\begin{align*}
  X[\leq i, \, \geq i+(d-1)] &= \min\{X[\leq i-1, \, \geq i+(d-1)], X[i, \, \geq i+(d-1)]\}\\
  &= \min\{X[\leq i-1, \, \geq (i-1) + d], X[i, \, \geq i+(d-1)]\},
\end{align*}
so it suffices to let each $v_{i-1}$ send $X[\leq i-1, \, \geq (i-1) + d]$ to $v_i$. Therefore, $\zeta-1$ rounds of communication suffice to let each vertex $v_i$ in $P$ compute $X[\leq i, \, \geq i+1]$.
\end{proof}
 
Combining all the ingredients, we prove the main result of the section.

%\shortdetour*
\begin{proof}[Proof of \Cref{thm:shortdetour}]
 We first run the $O(\zeta)$-round algorithm of \Cref{Thm: Backward BFS Works} to let each vertex $u$ in the graph $G$ compute $f_u^\ast(d)$ for all $d \in [\zeta]$. By \Cref{lem:short_base}, the computed information allows each vertex $v_i$ in $P$ to infer the value of  $X[i, \, \geq j]$ any all $j > i$, enabling us to run the $O(\zeta)$-round algorithm of \Cref{lem:short_recursive}. By the end of the algorithm, each vertex $v_i$ in $P$ knows  $X[\leq i, \, \geq i+1]$, which is the shortest length of a replacement path for $e=(v_i, v_{i+1})$ with a short detour.
\end{proof}





%\newpage










% RECYCLING BIN ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

%Backward BFS ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

% \TODO{} Slightly restructure this to first mention the algorithm at the top, separating it from the motivation for dropping and proof of correctness of dropping\yijun{Yes, it will be better if you can cleanly separate (1) the intuition/motivation, (2) actual algorithm description, and (3) analysis/proof of corretness.}

% This following section can be summed up in the following lemma

% \begin{lemma}
%     The Backward BFS phase takes $O(\zeta)$ rounds, and at the end of it, every vertex $v$ along $P$ will know the length and end of all short detour paths that could be used in some optimal replacement path.\yijun{Can we make a bit more precise the information that each vertex learns?}
% \end{lemma}

% In this first stage, we concurrently run BFS backwards from each vertex on $P$ up to a depth of $\zeta$. This means that if an edge $(u,v)$ exists, then the BFS can explore from $v$ to $u$. The only information passed during this BFS is the vertex ID that the BFS exploration belongs to. When a BFS exploration reaches a vertex on $P$, that vertex makes a note of what vertex ID that BFS originated from as well as how many rounds it took since the start of this Backward BFS phase to reach.

% Running a single instance of this BFS clearly takes $\zeta$ rounds. However, an issue can arise where multiple instances of BFS reach a vertex at the same time. An example of this is shown below, where after the first round, the vertex $v$ now has to pass backwards multiple vertex IDs of $a,b,c$. This could cause us to violate the $\CONGEST$ model.\yijun{Use math mode in the figure to write $a,b,c,v,P$. Same for the figure below.}


% %https://tikz.net/contents/chapter-03-drawing-positioning-and-aligning-nodes/
% %https://tex.stackexchange.com/questions/13587/how-to-change-the-size-of-nodes
% %https://tex.stackexchange.com/questions/58878/tikz-set-node-label-position-more-precisely
% \vspace{7px}
% \begin{tikzpicture}
%     \draw (0,0) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=below:$a$] {};
%     \draw (1,0) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=below:b] {};
%     \draw (2,0) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=below:c] {};
%     \draw (0.5,1) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=v] {};
    
%     \draw (-1,0) -- (3,0) node[label=P]{};
%     \draw[-Latex] (0.5,1) .. controls (0.0,0.5) .. (0,0);
%     \draw[-Latex] (0.5,1) .. controls (1.0,0.5) .. (1,0);
%     \draw[-Latex] (0.5,1) .. controls (2.0,1.0) .. (2,0);

%     %Recycling Bin
%     % \fill (0,0) circle[radius=1.5pt];
%     % \fill (1,0) circle[radius=1.5pt];
%     % \fill (2,0) circle[radius=1.5pt];
%     % \fill (0.5,1) circle[radius=1.5pt];
%     % \draw (0,0) circle[radius=2.5pt] node[label=test] {};
%     % \node[outer sep=2pt,fill=white] {P};
%     % (1, 4) node[circle, black, draw](a){A};
% \end{tikzpicture}

% This issue can be overcome by having vertices only send backwards the furthest vertex along $P$ they received from the previous round. In the diagram above, vertex $v$ would only send $c$'s ID backwards out of the 3 vertices in the 2nd round. This ensures that each vertex will only have to send at most one ID backwards at every round, so the requirements of the $\CONGEST$ model are not violated. It remains to show that the BFS traversals that get this form of ``early termination'' does not cause us to lose any potentially optimal detour paths.

% Suppose that two different BFSes starting from $a,b$ where $a$ comes before $b$ on $P$ both reach a vertex $v$ at the same time. Suppose for the sake of contradiction that there exists an optimal replacement path $D$ that uses the path from $v$ to $a$ found by the BFS. This shortest path can have the portion starting from $a$ replaced by the part along $P$ from $a$ to $t$, creating a new replacement path $D'$. This is a shortest path from $a$ to $t$ since $P$ is the shortest path from $s$ to $t$. Now since both BFSes reach $v$ at the same time, then the length of the shortest path from $v$ to $a$ equals the length of the shortest path from $v$ to $b$. Therefore the length of the part from $v$ to $a$ to $b$ along $D'$ will be strictly longer than the length of the shortest path from $x$ to $b$, so this part of $D'$ can be replaced to get a new shorter path, contradicting the optimality of $D'$ and $D$.

% \vspace{7px}
% \begin{tikzpicture}
%     %Drawing vertices
%     \draw (-3,0) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=below:s] {};
%     \draw (0,0) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=below:a] {};
%     \draw (3,0) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=below:b] {};
%     \draw (5,0) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=below:t] {};
%     \draw (0.5,1) node[draw, circle, color=black, fill=black, inner sep=0pt, minimum size=5pt, label=v] {};
%     %Drawing edges along P and label P
%     \draw[-Latex] (-3,0) -- (0,0);
%     \draw[-Latex] ( 0,0) -- (1,0);
%     \fill (1.2,0) circle[radius=1.5pt];
%     \fill (1.5,0) circle[radius=1.5pt];
%     \fill (1.8,0) circle[radius=1.5pt];
%     \draw[-Latex] ( 2,0) -- (3,0);
%     \draw[-Latex] ( 3,0) -- (5,0) node[label=P]{};
%     %Drawing edges going in/out of v
%     \draw[-Latex] (0.5,1) .. controls (0.0,0.5) .. (0,0);
%     \draw[-Latex] (0.5,1) .. controls (2.0,1.0) .. (3,0);
% \end{tikzpicture}


    %     \item[Backward BFS.] Run a BFS backwards up to depth $\zeta$ from every vertex $v$ on $P$, dropping some unneeded branches of the BFS trees. This will allow each vertex along $P$ to learn of the farthest possible vertex along $P$ that can be reached by a detour path starting from $v$ of length exactly $d$ for all $1 \leq d \leq \zeta$. Then using this information, locally compute the length of the shortest replacement path that starts from $v$ and skips at least $d$ edges for all $1 \leq d \leq \zeta$.

    % \item[Information Pipelining.] The information from the Backward BFS is then appropriately pipelined forwards along $P$. This allows the vertices to distributedly fill up a dp table on the shortest possible detour path that 
    
    %Each vertex internally computes the best way to skip all of the next $i$ edges in front of it for $i=1,2,\dots,\zeta$. Then this information is dynamically pipelined along $P$, dropping unnecessary information, so that each edge $(u,v)$ will know the shortest possible replacement path using a short detour.%\yijun{if you want textbf, can use description instead of itemize. I prefer information over info.}
    
    % \TODO{} Update this part
    
    % The path $P$ is broken up into chunks of length $2\zeta$ (with the last chunk possibly being smaller), and this information of possibly optimal short detour paths is pipelined forwards along each chunk. This process is then repeated again, except with the first chunk being of length $\zeta$ and the rest still being of length $2\zeta$ (except possibly the last).



% \begin{theorem}
% \label{Thm: Short Detour Part Works}
%     There exists a deterministic algorithm that runs for $O(\zeta)$ rounds in the $\CONGEST$ model such that for every edge $(u,v)$ in $P$, $u$ learns the length of the shortest possible replacement path after deleting the edge $(u,v)$ using a short detour.
% \end{theorem}

% \begin{restatable}{theorem}{shortdetour}
% \label{thm:shortdetour}
% There exists a deterministic algorithm that runs for $O(\zeta)$ rounds in the $\CONGEST$ model such that for every edge $(u,v)$ in $P$, $u$ learns the length of the shortest possible replacement path after deleting the edge $(u,v)$ using a short detour.
% \end{restatable}

% I claim that the above algorithm will run in $O(\zeta)$ rounds.


    % \item Now each vertex $v$ along $P$ knows a superset of the detour paths starting from itself that is part of some optimal replacement path after an edge deletion.\yijun{Maybe make it a bit more precise the output format: I think $v$ knows a collection of pairs $(u,d)$ (for all $d \in [\zeta]$) such that $u$ is the ``farthest'' vertex in $P$ reachable from $v$ using exactly $d$ hops, avoiding the edges in $P$. In my opinion this will be a better (more precise) way to write the main lemma statement}

    %Then $d$ is not a part of any optimal replacement path for any deleted edge along $P$.
    %\yijun{$D$ is diameter, change to some other variable, maybe $d$?}



    % Let us proceed by contradiction. Let $d$ be some short detour path from $a$ to $b$ that was lost due to the BFS pruning. Suppose that for some edge $e$ on $P$, the optimal replacement path $st \diamond e$ after deleting $e$ uses $D$ as its detour path.

    % Because $D$ was not discovered by the algorithm, this must mean that for some edge $(u,v)$ on $D$, $v$ did not send the BFS from $b$ backwards to $u$. This in turn means that at that same round, $v$ sent the BFS from some vertex $c$ further along $P$ than $b$ to $u$ at the same round. Suppose that the round where the BFS was dropped was round $r$. This means that there exists a path of length $r$ from $v$ to $b$ and from $v$ to $c$.

    % Since $D$ goes from $a$ to $b$, then $e$ must lie somewhere in between $a$ and $b$. Therefore, a detour path that goes from $a$ to $c$ would also give a replacement path when $e$ is deleted from the graph.

    % But note that the detour path that copies $D$ from $a$ to $v$ then instead going to $c$ along the path of length $r$ results in a strictly shorter replacement path $st \diamond e$, where the distance is shortened by the number of edges from $b$ to $c$ along $P$. This contradicts the optimality of the replacement path obtained by taking $D$ as the detour path.

    % Therefore, no optimal replacement path after an edge deletion will use $D$ as a detour path. 

%From the above Lemma, we see that the best short detour path for a given starting vertex and length will never be dropped. Then each 

%Taking the contrapositive of the above Lemma, we see that any short detour path that is used part of some optimal replacement path after some edge is deleted will not be lost from the dropped messages. This means that all the vertices will be able to correctly learn the information claimed by the above algorithm.\yijun{It would be better if you have a lemma saying that for any optimal replacement path with short detour, the detour is found by the algorithm. This is more direct than the above lemma. Also, the above lemma only says that optimal detours are not pruned and does not say that the detours that are not pruned cover all optimal detours (this is only discussed informally before the lemma statement)}












%Info Pipelining ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    % \begin{align*}
    %     test & waow \\
    %     & asdf
    % \end{align*}

    % $$
    % l_i[k-r-1] 
    % = \min(l_{i-1}[k-r], \ l_i[k-r-1])
    % $$ $$
    % = \min \left( \min_{0 \leq z \leq r} l'_{i-1-z}[k-r+z], \ l'_i[k-r-1] \right)
    % $$ $$
    % = \min \left( \min_{1 \leq z \leq r+1} l'_{i-z}[k-r-1+z], \ l'_i[k-r-1] \right)
    % $$ $$
    % = \min_{0 \leq j \leq r+1} l'_{i-z}[k-j+z]
    % $$


% \begin{lemma}
%     At the end of round $r$, $l_i[k-j]$ is set as the least possible extra distance added by a short detour path that skips the $\zeta-j$ edges after $v_i \ \forall \ i \in \{1,2,\dots,L\}, j \in \{0,1,\dots,r\}$
% \end{lemma}
% \begin{proof}
%     We prove this by induction on the round number. Consider the end of round 0. Then $l_i[\zeta]$ would be set based on the best short detour path that starts from $v_i$ and skips at least $\zeta$ edges. However, since a short detour path has a length of at most $\zeta$, then a short detour path skipping the $\zeta$ edges after $v_i$ 
% \end{proof}


%We now show that this algorithm works as desired by proving the following Lemma. Note that the short detour paths in question no longer necessarily start from $v_i$. Also denote "the end of round 0" as the state right before round 1 starts for convenience.

% Note that because a short detour path is of length at most $\zeta$ and $P$ is the shortest path from $s$ to $t$, then a detour path connects between 2 vertices that are at most $\zeta$ distance away from each other along $P$ (otherwise, a section of $P$ could be replaced by the detour path, contradicting the optimality of $P$). Therefore, for a given edge $(u,v)$ to know the best short detour path, it only needs relevant information from the $\zeta$ vertices before it along $P$.

% For this part of the algorithm, we will first describe the algorithm to propagate relevant information along a section of length $L$ on $P$.

% \begin{itemize}
%     \item Suppose the vertices on this section of $P$ are $v_1,v_2,\dots,v_L$ from start to end.
%     \item Each vertex $v_i$ internally computes a list the least possible extra distance added by a detour path starting from itself that skips all the $x$ edges in front of it for $x=1,2,\dots,\zeta$. 
%     \item This list 
% \end{itemize}

% Now as described previously, we divide up $P$ into chunks of length $2\zeta$ and pipeline information forwards 

% In this part of the algorithm, the goal 

% P = s p0 p1 p2 ... t

% detour from p2 of len k vs detour from p1 of len k+1 vs detour from p0 of len k+2
% p0 forwards k+2 to p1, p1 compares to see which is better, better one gets forwarded to p2

% Each vertex keeps track of a list `l` where the ith element of l is 

% \begin{lemma}
%     Information known by a 
% \end{lemma}

    % $$\min(l_i[j], l_{i-1}[j+1], l_{i-2}[j+2], \dots, l_{i-(\zeta-j)}[\zeta]) 
    % \ \ \ \ \ \forall \ i \in \{1,2,\dots,N\}, j \in \{1,2,\dots,k\}$$


        % \item 
        % \item 
        % \item 

        % \item Each vertex $v_i$ on $P$ initialises the $\zeta$th cell of its own array to be the length of the shortest replacement path that uses a short detour path skipping at least $\zeta$ edges in 




    
        % \item Each vertex internally computes the length of the shortest possible detour path by using a detour path starting from itself and ending at least $i$ vertices down along $P$ for $i=1,2,\dots,\zeta$. Let $l_i$ denote the list maintained by $v_i$ and denote $l_i[x]$ to be the stored value for landing at least $x+1$ vertices down along $P$.
        % \begin{itemize}
        %     \item[*] Mark it as undefined if no such short detour path exists or if there are not at least $x+1$ vertices in front of $v_i$.\yijun{or set it to be $\infty$}
        % \end{itemize}
        % \item We then have $\zeta-1$ rounds where in each round, every vertex $v_i$ on $P$ sends some information to $v_{i+1}$ and updates it's current $l_i$ based on the received information.
        % \item For each vertex $v_i$ In round $r$
        % \begin{itemize}
        %     \item[-] Send the value of $l_i[k-r]$ to $v_{i+1}$
        %     \item[-] Let $x=l_{i-1}[k-r]$ be the value received from $v_{i-1}$. Set $l_i[k-r-1] = \min(x, l_i[k-r-1])$
        %     \begin{itemize}
        %         \item[*] Do not modify the value if $x$ is undefined.\yijun{no need this if you use $\infty$ for undefined.}
        %     \end{itemize}
        % \end{itemize}
        % \item Now each vertex $v_i$ knows the shortest possible replacement path length after deleting $(v_i,v_{i+1})$ which is stored in $l_i[0]$.
        % %that the best short detour path and the resulting replacement path length for deleting $(v_i,v_{i+1})$ by adding $l_i[0]$ to the length of $P$.



% The algorithm for this part resembles a pipelined dynamic programming as described below.
% \begin{itemize}
%     \item Each vertex internally computes the length of the shortest possible detour path by using a detour path starting from itself and ending at least $i$ vertices down along $P$ for $i=1,2,\dots,\zeta$. Let $l_i$ denote the list maintained by $v_i$ and denote $l_i[x]$ to be the stored value for landing at least $x+1$ vertices down along $P$.
%     \begin{itemize}
%         \item[*] Mark it as undefined if no such short detour path exists or if there are not at least $x+1$ vertices in front of $v_i$.\yijun{or set it to be $\infty$}
%     \end{itemize}
%     \item We then have $\zeta-1$ rounds where in each round, every vertex $v_i$ on $P$ sends some information to $v_{i+1}$ and updates it's current $l_i$ based on the received information.
%     \item For each vertex $v_i$ In round $r$
%     \begin{itemize}
%         \item[-] Send the value of $l_i[k-r]$ to $v_{i+1}$
%         \item[-] Let $x=l_{i-1}[k-r]$ be the value received from $v_{i-1}$. Set $l_i[k-r-1] = \min(x, l_i[k-r-1])$
%         \begin{itemize}
%             \item[*] Do not modify the value if $x$ is undefined.\yijun{no need this if you use $\infty$ for undefined.}
%         \end{itemize}
%     \end{itemize}
%     \item Now each vertex $v_i$ knows the shortest possible replacement path length after deleting $(v_i,v_{i+1})$ which is stored in $l_i[0]$.
%     %that the best short detour path and the resulting replacement path length for deleting $(v_i,v_{i+1})$ by adding $l_i[0]$ to the length of $P$.
% \end{itemize}





% This clearly takes $O(\zeta)$ rounds since we have $\zeta-1$ rounds and does not violate the $\CONGEST$ model since the only information passed along an edge in each round is a single distance value.\yijun{It will be clearer if you first define the dynamic programming table (formal definition of $l_i[x]$ + how you do the base case from the values obtained by BFS + how you set the values recursively in the inductive step), and then say how this table can be computed efficiently in the $\CONGEST$ model. Currently, they are mixed together, and the definition of $l_i[x]$ is not very formal}

% Let us now prove that this algorithm works. Let $l'_i$\yijun{I guess you mean the output from BFS? This notation should be introduced in the place where you define the dynamic programming table - I suggest separating $l_i$ and $l_i'$ for clarity} denote the original state of $l_i$ before round 1 starts for $i=1,2,\dots,L$. We prove the following 2 lemmas.

% \begin{lemma}
% \label{Lem: Only need past \zeta}
%     The length of the shortest possible replacement path using a short detour path that jumps over all $j$ edges from $v_i$ to $v_{i+j}$ along $P$ is
    
%     $$\min_{0 \leq z \leq k-j}l'_{i-z}[j+z]
%     \quad \forall \ 1 \leq i \leq N, 1 \leq j \leq \zeta$$
% \end{lemma}
% \begin{proof}
%     Consider some $1 \leq i \leq N, 1 \leq j \leq \zeta$. Note that a detour path of length $x$ must start and end on two vertices on $P$ that are at most $x$ distance away along $P$ because otherwise, $P$ could have this section replaced to get a shorter path, contradicting minimality. Therefore, any short detour path must start and end on two vertices that are at most $\zeta$ units apart along $P$.

%     Consider some short detour path that skips over the $j$ edges along $P$ from $v_i$ to $v_{i+j}$. Since it must end at $v_{i+j}$ or later. then it must start at $v_{i+j-\zeta}$ or later by the above paragraph. Therefore, it suffices to check short detour paths that start somewhere from $v_{i+j-\zeta}=v_{i-(\zeta-j)}$ to $v_i$ inclusive.

%     Note that a detour path that starts from $v_{i-z}$ for some $0 \leq z \leq k-j$ and skips all edges between $v_i$ and $v_{i+j}$ along $P$ iff it skips all edges between $v_{i-z}$ and $v_{i+j}$. Therefore, the length of the shortest replacement path starting from $v_{i-z}$ that skips the $j$ desired edges is $l'_{i-z}[j+z]$. Now the expression above takes the minimum of these values for $z \in \mathbb{Z}, 0 \leq z \leq k-j$, which is what we want.

%     Thus, the Lemma is proven
% \end{proof}




% \begin{lemma}
% \label{Lem: We compute past \zeta}
%     At the end of round $r$, we have
    
%     $$l_i[k-j] = \min_{0 \leq z \leq j}l'_{i-z}[k-j+z] 
%     \quad\forall \ 1 \leq i \leq L, 0 \leq j \leq r$$
    
%     for all rounds $r=0,1,\dots,k-1$, where the end of round 0 is taken to be right before the start of round 1.
% \end{lemma}
% \begin{proof}
%     We prove this by induction on the round number. At the end of round 0, the correct value is set in $l_i[\zeta]$ by definition. Suppose that the statement is true at the end of round $r$ for some $0 < r < k-1$.

%     Consider the end of round $r+1$. Note that only the $l_i[k-r-1]$ is edited in $l_i$ for any list $l_i$, so the statement remains true for $0 \leq j \leq r$. Meanwhile, the other entries have not been touched at all, so $l_i[d]=l'_i[d] \ \forall \ d \leq k-r-1$
    
%     Now the value of $l_i[k-r-1]$ is set to
%     \begin{align*}
%         l_i[k-r-1] 
%         &= \min(l_{i-1}[k-r], \ l_i[k-r-1]) \\
%         &= \min \left( \min_{0 \leq z \leq r} l'_{i-1-z}[k-r+z], \ l'_i[k-r-1] \right) \\
%         &= \min \left( \min_{1 \leq z \leq r+1} l'_{i-z}[k-r-1+z], \ l'_i[k-r-1] \right) \\
%         &= \min_{0 \leq j \leq r+1} l'_{i-z}[k-j+z]
%     \end{align*}
%     so the statement is true for $j=r+1$ too, so it is true for round $r+1$.

%     Therefore by induction, the lemma is true for all rounds $r=0,1,\dots,\zeta$.

%     Thus, the Lemma is proven
% \end{proof}
% \yijun{The above two lemmas should be easy observations if you define $l_i$ and $l_i'$ using graph terminology. Currently, they are complicated mainly due to their definitions being unclear.}




% \begin{proof}

% By \Cref{Lem: We compute past \zeta} we see that $l_i[1] = \min_{0 \leq z \leq k-1} l'_{i-z}[1+z]$, which by \Cref{Lem: Only need past \zeta} is the length of the shortest replacement path that uses a short detour path that skips the edge $(v_i,v_{i+1})$.

% Therefore the shortest replacement path using short detour paths that skip $(v_i,v_{i+1})$ are correctly computed at the end of Info Pipelining.

% Combining the two parts of the algorithm, we see that \Cref{thm:shortdetour} is true by construction.\yijun{Also refer to the lemma for BFS algo in the proof: you need this to get the $l_i'$ values (base cases for dynamic programming)}
% \end{proof}
