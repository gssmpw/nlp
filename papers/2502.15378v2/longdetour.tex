\section{Long-Detour Replacement Paths}
\label{sec:long}

In this section, we handle the replacement paths having long detours, i.e., the length of the detour is greater than the threshold $\zeta = n^{2/3}$. We break the detours into smaller pieces so that the required distance information can be computed efficiently. To break the detours, we use the concept of \emph{landmark vertices}, which was previously used in the literature~\cite{BernsteinK08, ullman1990high} and have been widely used in fault-tolerant algorithms and distance computation. Moreover, as now a detour can cross two distant vertices in $P$, to facilitate information pipelining, we also divide the shortest $st$ path, $P$ into \emph{segments} separated by \emph{checkpoints}. At this point, let us define some notations which we will use throughout this section: 
\begin{itemize}
    \item We use the notation $u \leq_{P'} v$ to denote that $u$ appears before $v$ in the path $P'$.
    \item For any two vertices $x \leq_{P'} y$,  we write $P'[x,y]$ to denote the subpath of $P'$ from $x$ to $y$.
    \item Let $G \setminus P'$ denote the graph after deleting the edges in $P'$. 
    \item We write $(uv)_G$ to denote the shortest path from $u$ to $v$ in the graph $G$. We also write $|uv|_G$ to denote the length of the shortest path from $u$ to $v$ in the graph $G$. When the underlying graph is clear from the context, we omit the subscripts.
\end{itemize}
%We emphasize\dipan{Should we in stead change$P$ to $\mathcal{P}$ here?}that the above notations regarding paths not only apply to the given $s$-$t$ shortest path $P$ but also an arbitrary path. 

Let us now formally state the main result that we prove in this section. %\yijun{note: restate and prove the first main theorem of the paper immediately after this result.}

\begin{proposition}[Long detours]
\label{Thm: Long Detour Part Works}
    For unweighted directed graphs, there exists an $\widetilde{O}(n^{2/3}+D)$-round randomized algorithm that lets the first endpoint $v_i$ of each edge $e=(v_i, v_{i+1})$ in $P$ compute a number $x$ such that
    \[|st \diamond e| \leq x \leq \text{the shortest replacement path length for $e$ with a long detour}\] with high probability.   
    %runs for $\widetilde{O}(n^{2/3}+D)$ rounds in the $\CONGEST$ model such that for every  edge $e=(u,v)$ in $P$, with high probability, $u$ learns the length of the shortest possible replacement path after deleting the edge $(u,v)$ using a long detour.
\end{proposition}


\Cref{Thm: Long Detour Part Works} guarantees the exact value of $|st \diamond e|$ only when some shortest replacement path for $e$ takes a long detour. Otherwise, \Cref{Thm: Long Detour Part Works} provides only an upper bound on $|st \diamond e|$. In this case, the exact value of $|st \diamond e|$ can be computed using the algorithm from \Cref{thm:shortdetour}. Combining \Cref{thm:shortdetour} and \Cref{Thm: Long Detour Part Works}, we prove our first main theorem.

\mainUB*

\begin{proof}
Run the algorithms of \Cref{thm:shortdetour} and \Cref{Thm: Long Detour Part Works} with the threshold $\zeta = n^{2/3}$, by taking the minimum of the two outputs, the first endpoint $v_i$ of each edge $e=(v_i, v_{i+1})$ in $P$ correctly computes the shortest replacement path length $|st \diamond e|$.
\end{proof}

%\yijun{Todo: define some notations at the beginning of this section: the use of $\diamond$ (which is more flexible than in prelim), $R[x,y]$ for subpath, and $G/P$,  $\leq_P$, and you wrote $uv$ (sometimes $(u, v)$??) to denote a shortest path from $u$ to $v$, and what else? Important: In many places, you confuse between shortest path and shortest path length... so I am not sure about the meaning of the notations.}

%\dipan{edited the paragraph below}
%\yijun{Todo: this algo actually might also accidentally report replacement paths that uses a short detour, so to be more precise, the guarantee of the main theorem of the section is that for every edge whose replacement path has a long detour, the algo reports the optimal one. For edges whose replacement path has a short detour, the algo will report some upper bound but not necessarily an optimal one. This also needs to be mentioned in the paragraphs below.}



%At first, observe that in \Cref{Thm: Long Detour Part Works} only guarantees a tight bound on $|st \diamond e|$ when the shortest replacement path uses a long detour. If the shortest replacement path uses a short detour, then the output of \Cref{Thm: Long Detour Part Works} will just be an upper bound of $|st \diamond e|$. In this case, $v$ can compute $|st \diamond e|$ using the algorithm \Cref{thm:shortdetour}. 

We start our discussion of the proof of \Cref{Thm: Long Detour Part Works} by defining the landmark vertices. % and a result about landmark vertices.

\begin{definition}[Landmark vertices]
For a given constant $c  > 0$, sample each vertex in $V$ with probability $\frac{c \log n}{n^{2/3}}$ independently.
 The set $L$ of landmark vertices is the set of all sampled vertices.
\end{definition}

By a Chernoff bound, the size of the landmark vertex set is $|L| 
 = \widetilde{O}(n^{1/3})$ with high probability. The following proof is folklore and can be found in the textbook~\cite{greene1990mathematics}. For the sake of presentation, we write $L=\{l_1,l_2, \ldots, l_{|L|}\}$.

\begin{lemma}[Property of landmark vertices]
\label{Lem : Landmark Vertex}
    Consider any $S$ of $n^{2/3}$ vertices. With a probability of at least $1- n^{-\Omega(c)}$, i.e., with high probability, at least one of the vertices in $S$ is a landmark vertex.
\end{lemma}

Let us fix an edge $e = (v_i, v_{i+1})$ in $P$ whose replacement path $R = st \diamond e$ uses a long detour. Suppose we want $v_i$ to determine the length of $R$. Also, let the detour of $R$ begins at vertex $a$ and ends at vertex $b$. Since we are dealing with long detours, the subpath $R[a,b]$ contains more than $\zeta = n^{2/3}$ vertices. By \Cref{Lem : Landmark Vertex}, there exists at least one landmark vertex $l^* \in L$ on $R[a,b]$. To enable $v_i$ to compute $|R|$, it suffices to determine the lengths of the two subpaths of $R$: one from $s$ to $l^*$ and another from $l^*$ to $t$, denoted as $R[s, l^*]$ and $R[l^*, t]$, respectively. Observe that they can be rewritten as $
R[s, l^*] = sl^* \diamond P[v_{i+1}, t]$ and $R[l^*, t] = l^*t \diamond P[s, v_i]$. However, since the specific landmark vertices on the detour of $R$ are unknown, we must provide $v_i$ with the values of $|s l \diamond P[v_{i+1}, t]|$ and $|l t \diamond P[s, v_i]|$ for all $l \in L$. After that, $v_i$ can locally compute the length of $R$ as follows:

$$|st \diamond e| =\min\limits_{l \in L} |s l \diamond P[v_i,t]| + |lt \diamond P[s,v_{i+1}]|.$$



% %Let us fix an edge $e=(u,v)$ in $P$ whose replacement path $R = st \diamond e$ uses a long detour. Suppose we want $u$ to learn the length of the path $R = st \diamond e$. Also, let the detour of $R$ starts at $a$ and ends at $b$. Since we are dealing with long detours, there are more than $\zeta = n^{2/3}$ vertices in $R[a,b]$. Now, using \Cref{Lem : Landmark Vertex}, we can claim that $\exists l^* \in L$ on $R[a,b]$. To let $u$ know $|R|$, it can be done by determining the length of the two subpaths of $R$, i.e., from $s$ to $l^*$ and $l^*$ to $t$, denoted by  $R[s,l^*]$ and $R[l^*,t]$, respectively. Observe that $R[s,l^*]$ and $R[l^*,t]$ can be written as  $sl^* \diamond P[u,t]$ and $l^*t \diamond P[s,v]$, respectively. However, we do not know which landmark vertices are on the detour of $R$. Hence, for all possible $l \in L $, we have to let $u$ know $|sl \diamond P[u,t]|$ and $|lt \diamond P[s,v]|$. After that, $u$ can locally calculate the length of the path $R$ as follows:

% $$|st \diamond e| =\min\limits_{l \in L} |s l \diamond P[v_i,t]| + |lt \diamond P[s,v_{i+1}]|.$$


% Let us now state an easy to prove observations which will help us in the analysis of our algorithm.

% \begin{observation}
% \label{obs_start}
%     If $l_1$ is the first vertex in the detour of $st \diamond e$, then $sl_1 \diamond e$ should have only start of the detour and not an end.
% \end{observation}

% \begin{observation}
% \label{obs_end}
%     If $l_k$ is the last vertex in the detour of $st \diamond e$, then $l_kt \diamond e$ should have only the of the detour and not a start.
% \end{observation}

% Let $L'$ and $L''$ be the subset of landmark vertices satisfying the conditions given by \Cref{obs_start} and \Cref{obs_end}, respectively.\yijun{Actually, I don't understand the two observations and the above sentence. Do you fixe $e$ or not? If you fix $e$, then I guess you also fix $l_1$ and $l_k$? If you do not fix $e$, then I think $L'$ and $L''$ can be the entire set $L$? }

To summarize, for each vertex $v_i$ in the path $P = (s=v_1, v_2, \ldots, v_{h_{st}-1}=t)$, we want to store the following information in $v_i$. %\yijun{the presentation needs to be somewhat updated here: just need two parts, the all-pair distances are needed as subroutines.} %\yijun{k is threshold} 
%\dipan{Changed. Should I change the $l_k$s used also? Or are those fine?} \yijun{todo: ideally, yes, or maybe it is easier to change the symbol $k$ for threshold... $\kappa$ or $\zeta$ or else, as $k$ is too common?}
\begin{description}
    \item[1. Distances from $s$ to the landmark vertices:] $|sl \diamond P[v_{i},t]|$ for all $l \in L$.
%    \item[2. Distances between the landmark vertices:] $|l_jl_k|_{G \setminus P}$ for all $(l_j,l_k) \in L \times L$.
    \item[2. Distances from the landmark vertices to $t$:] $|lt \diamond P[s,v_{i+1}]|$  for all $l \in L$.
\end{description}


In \Cref{s to land} we address the first part. In \Cref{land to t} we address the second part, which is symmetrical to the first part, and prove \Cref{Thm: Long Detour Part Works}. 

Observe that, for some $l \in L$, the distances $|sl \diamond P[v_{i},t]|$ and $|lt \diamond P[s,v_{i+1}]|$ may be more than $n^{2/3}$. So, a simple BFS-like algorithm may not work within $\widetilde{O}(n^{2/3}+D)$ rounds. To address that issue, we utilize a subroutine %(as in \Cref{lem : land to land}) 
that enables each vertex $v \in V$ (hence $v \in P$) to know the distances between all pairs of landmark vertices.

%\gopinath{Some intuition may be added.}
%The algorithm corresponding to both parts will require a subroutine (as in \Cref{lem : land to land}) that enables each vertex $v \in V$ (hence $v \in P$) to know the distances between all pairs of landmark vertices.



%\begin{definition}[Congestion and Dilation]
%During scheduling any distributed algorithm for any graph, the congestion is the highest message size at any round for a vertex and the dilation is the number of round a vertex has to send any message.
%\end{definition}

%The following result is due to Ghaffari \cite{Ghaffari}.\yijun{There are older and classical references for scheduling distributed algorithms, which we should also cite and discuss. I am not sure the lemma statement is an appropriate one? E.g., how do we get shared randomness?} 

%\begin{lemma}[\cite{Ghaffari}]
%    Given shared randomness, any distributed algorithm can be scheduled in $O(congestion +dilation \cdot \log n)$ rounds with high probability.
%\end{lemma}


\begin{lemma}[Distance between the landmark vertices]
\label{lem : land to land}
    There exists an $\widetilde{O}(n^{2/3}+D)$-round randomized algorithm that lets all vertices  $v \in V$ compute, for all pairs $(l_j,l_k) \in L \times L$, the length of the path $(l_jl_k)_{G \setminus P}$, with high probability.
    %, i.e., $|l_jl_K|_{G \setminus P}$.% is stored in all $v \in V$.
    %\yijun{Maybe just write $V$.}
\end{lemma}
Due to \Cref{Lem : Landmark Vertex}, the intuition is that BFS explorations up to depth $n^{2/3}$ starting from each vertex in $L$ should be sufficient to determine the distances between landmark vertices. We need the following lemma to formally prove \Cref{lem : land to land}.

\begin{lemma}[$k$-source $h$-hop BFS~\cite{LenzenPP19}]\label{kbfs}
    For directed graphs, there exists an $O(k+h)$-round deterministic algorithm that computes $k$-source $h$-hop BFS.
\end{lemma}

\begin{proof}[Proof of \Cref{lem : land to land}]
    We store $|l_jl_k|_{G \setminus P}$  in all $v \in V$, for any pair $(l_j,l_k) \in L \times L$, by finding the length of the whole path in parts. For that, observe that, using \Cref{Lem : Landmark Vertex}, in the path $(l_jl_k)_{G \setminus P}$, with high probability, there will be a landmark vertex in each length of $n^{2/3} $. That means, a longer $(l_jl_k)_{G \setminus P}$ path can be viewed as a concatenation of some paths between landmark vertices of at most $n^{2/3} $ hops. Therefore, if we can calculate the all-pair distances $L \times L$ in $G \setminus P$ under a constraint of $n^{2/3}$ hops, and broadcast the distances to all vertices $v \in V$, then $v$ can calculate $(l_jl_k)_{G \setminus P}$  for any pair of $|l_jl_k| \in L \times L$.

    In other words, we need a BFS tree of at most $h = n^{2/3}$ hops from all $l_i \in L$. We have in total $|L| = \widetilde{O}(n^{1/3})$ landmark vertices. Therefore, using \Cref{kbfs}, we can find the required BFS trees in $O(h+|L|) = O(n^{2/3})$ rounds. After that, each $l_i \in L$ knows the distances from all other landmark vertices under a hop constraint of $h = n^{2/3}$.
    
    
%    For this, we can run algorithm similar to Bellman-Ford Algorithm \cite{bellman1958routing, Ford} to find BFS up to level $n^{2/3} \log n$ rooted at each $l_i$. Here, any vertex can be at most at $n^{1/3}$ many vertices. Therefore, the congestion is at most $n^{1/3}$ and the dilation is at most $n^{2/3} \log n$. Hence, applying \Cref{kbfs}, each $l_i$ can find the distances to the landmark vertices that it can reach in $n^{2/3} \log n$ length.

    Now, we plan to send this information to all the vertices $v \in V$. The total number of messages to be broadcast is $O(|L|^2) = \widetilde{O}(n^{2/3})$.    
    %Here, as every landmark vertex sends $n^{1/3}$ many vertices and the number of landmark vertices in the graph is at most $n^{1/3}$, so the total number of messages will be $n^{2/3}$.  
    All the messages are of $O(\log n)$ bits. Therefore, by \Cref{LP}, the broadcast can be done in $\widetilde{O}(n^{2/3} + D)$ rounds.
    After that, each $v$ is able to locally calculate $|l_jl_k|_{G \setminus P}$  for all pairs $(l_j,l_k) \in L \times L$.

    While our algorithm is deterministic, the computed distances are only correct with high probability, as the guarantee of \Cref{Lem : Landmark Vertex} is probabilistic.
\end{proof}









%Next, we will discuss how we store the first and second parts in each $v_i$. The third part can be stored symmetrically to the first part. We start with the second part because it is less complicated.

% \subsection{Distances Between the Landmark Vertices}
% In this section, we show how we let all vertices in the graph compute  $|l_jl_k|_{G \setminus P}$ for all $(l_j,l_k) \in L \times L$. We need the following tool.


%Let us first state the following lemma which was previously in the literature and will be used in the following discussion.

%HoangPDGYPR19




%At first, let us try to find the length of $(l_il_j)_{G \setminus P}$ for any pair $(l_i,l_j) \in L \times L$ and broadcast those data to all the vertices in the shortest path $P$. For that, we use the BFS on the graph $G \setminus P$. Therefore, we run the BFS tree from all the landmark vertices $l \in L$ till $n^{2/3} \log n$ level in $G \setminus P$. After this, each $l_i$ will know the landmark vertices to which it can reach in length $\leq n^{2/3} \log n$ in $G \setminus P$. We also broadcast these data from each of $l_i$. This will have at most $n^{2/3}$ many information and hence, can be sent in $\widetilde{O}(n^{2/3}+D)$ rounds.\yijun{You cannot claim this without a proper proof/citation/reference. See e.g., Section 2.3 of https://arxiv.org/pdf/1708.03903} This will ensure that all the vertices can now calculate the distances between any possible pair of landmark vertices in $G \setminus P$.

\subsection{Distances From \texorpdfstring{$s$}{s} to the Landmark Vertices}
\label{s to land}

Let us recall that, the shortest path $P$ contains the vertices $(s=v_1, v_2, \dots, v_{h_{st}-1}=t)$. Also, in each $v_i$, we want to store $|sl_j \diamond P[v_{i},t]|$ for all $l_j \in L$. Let us use the notation $M[l_j, v_i]$ to denote $|sl_j \diamond P[v_{i},t]|$, so our goal become storing $M[l_j,v_i]$, for all $l_j \in L$, in each $v_i$. 

At first, we informally discuss an approach to store $M[l_j,v_i]$, for all $l_j \in L$, in each $v_i$ in $\widetilde{O}(h_{st}+n^{2/3})$ rounds, and then show how to remove the additive term $O(h_{st})$.
%\yijun{maybe do this at the place we define $L$. And also $|L|$ is not $n^{2/3}$.}
Observe that, if you fix some $l_j$, then $M[l_j,v_i]$ is decreasing in $i$, i.e., $M[l_j,v_i] \geq M[l_j,v_{i'}]$ whenever $v_i \leq_{P}v_{i'}$. This is true because the path $sl_j \diamond P[v_{i},t]$  avoids $v_{i'}$ for all $i' \geq i$. %, if $v_i \leq_P v_{i'}$.
Specifically, we have  \[M[l_j,v_i]= \min \left\{ M[l_j,v_{i-1}], |sv_i|+|v_il_j|_{G \setminus P} \right\}.\] Now, if we can store   $|v_il_j|_{G \setminus P}$, for all $l_j \in L$, in each $v_i$, then by doing $|L|$ sweeps in $P$ in a pieplining fashion, we can let each $v_i$ compute $M[l_j, v_i]$ for all $l_j \in L$ in $\widetilde{O}(h_{st}+|L|) = \widetilde{O}(h_{st}+n^{1/3})$ more rounds. We discuss how we can remove the $h_{st}$ additive term later. In view of the above, we want to let $v_i$ compute $|v_il_j|_{G \setminus P}$ for all $l_j \in L$. The next lemma achieves this goal in $\widetilde{O}(n^{2/3} + D)$ rounds.

%\yijun{TODO: A technical issue: the lemma below only computes the hop-constrained distances. Of course, this is ok for us, but the lemma statement asks for distances without a hop constraint. The easier fix is perhaps to also compute the all-pair hop-constraint distances $L \times L$ and use the property of landmark vertices. This adds an extra $O(D)$ term in the round complexity (everywhere in this subsection).} 


%in $\widetilde{O}(h_{st}+n^{2/3})$ rounds. However, the next lemma proves something stronger which we will need to prove the main result in this section.


%\yijun{can be a bit more precise: this is by doing $|L|$ sweeps in $P$ in a pipelining fashion, and say that later we will improve the algo to remove $h_{st}$} 

\begin{lemma}[Distances to the landmark vertices] \label{lemma: vilj path}
    There exists an $\widetilde{O}(n^{2/3}+D)$-round randomized algorithm that lets each $v_i$ in $P$ compute $|v_il_j|_{G \setminus P}$, for all $l_j \in L$, with high probability.
\end{lemma}

\begin{proof}
%\gopinath{Is the proof ok?}\yijun{looks ok, but might also need to check other places (proofs and also informal discussions)}
First, let all vertices $v \in V$ know the length of the path $(l_j l_k)_{G \setminus P}$ for all pairs $(l_j, l_k) \in L \times L$. By \Cref{lem : land to land}, this can be achieved in $\widetilde{O}(n^{2/3} + D)$ rounds. 

Now, consider a vertex $v \in P$ and a landmark $l_j \in L$. Using \Cref{Lem : Landmark Vertex}, if the path $(v l_j)_{G \setminus P}$ has length at least $n^{2/3}$, then with high probability, there will be a landmark vertex in every segment of length $n^{2/3}$. This means that such a path $(v l_j)_{G \setminus P}$ can be viewed as a concatenation of the path from $v$ to some landmark $l$ and the path from $l$ to $l_j$, where $l$ is the first landmark encountered in the path from $v$ to $l_j$. Since, with high probability, the length of the path from $v$ to $l$ is at most $n^{2/3}$, and each vertex in $P$ already knows the distances between landmark vertices, it suffices to determine the distance of each vertex $v \in P$ to all vertices in $L$ under a hop constraint of $h=n^{2/3}$. 

To achieve this, we perform BFS from all landmark vertices $l_j \in L$ up to a depth of $n^{2/3}$ in $(G \setminus P)^R$ (the reverse graph of $G \setminus P$). Since $|L| = \widetilde{O}(n^{1/3})$, this requires performing $\widetilde{O}(n^{1/3})$ BFS computations, each up to $n^{2/3}$ hops. By \Cref{kbfs}, this can be completed in $O(|L| + n^{2/3}) = {O}(n^{2/3})$ rounds. During these BFS computations, each vertex can record its level in the BFS rooted at each $l_j$. At the end of the these BFS procedures, each vertex $v$ in $P$, knows the distances to all landmark vertices that can be reachable within $n^{2/3}$ hops.
 %Hence, we can store $|v_il_j|_{G \setminus P}$ for all $v_i \in P, l_j \in L$ in $v_i$ by a distributive algorithm with $\widetilde{O}(n^{2/3})$ rounds.
\end{proof}

The length of pipelining $h_{st}$ is the bottleneck of the algorithm. Hence, to reduce the number of rounds, we want to reduce the required length of pipelining. For that, we break the path $P$ into segments of length $O(n^{2/3})$. We call the endpoints of the segments as checkpoints. Formally, %we want to have a sequence of vertices in path $P$, which will be known as checkpoints, $C$ and there should be at most $\lceil n^{2/3} \rceil$ vertices any two consecutive checkpoint vertex. We also do not want the number of checkpoints to be large. 
let the set of checkpoints be \[C=\{s=v_1,v_{1+\lceil n^{2/3} \rceil},v_{1+2\lceil n^{2/3} \rceil},,v_{1+3\lceil n^{2/3} \rceil} \ldots, t\}.\] 
Therefore, between two consecutive checkpoints, there are exactly $\lceil n^{2/3} \rceil$ edges, except for the last segment, where the number of edges can be smaller, as we put $t$ as the last checkpoint.
%Here, note that, there may also not be $\lceil n^{2/3} \rceil$ many vertices between the last checkpoint vertex $t$ and the second last checkpoint vertex. However, we put $t$ as the last checkpoint vertex.
We denote the checkpoint as $c_1, c_2 \ldots$. The segment $P[c_{i},c_{i+1}]$, which starts from the vertex $c_{i}$ and ends at the vertex $c_{i+1}$ in $P$, is the $i$th segment. The segments are edge-disjoint and overlap in the checkpoints. % which is dividing them. 

For our next lemma, let us define a ``localized'' version of $M[l_j,v_i]$ restricted to the $i$th segment. For each vertex $v$ in $P$ such that $c_{i} \leq_P v \leq_P c_{i+1}$, we define \[M^i[l_j,v]=\min_{u \, : \, c_{i} \leq_P u \leq_P  v} \left\{|su|+|ul_j|_{G \setminus P}\right\}.\] 


%\yijun{the above two sentences are slightly confusing. what is missing is that we need to mention that a checkpoint belongs to two segments, so we have two values.}\gopinath{Editted the text.}


%Observe that, fixing $l_j$, we may have two different values of $M^{i-1}[l_j,c_{i}]$ and $M^i[l_j,c_i]$. These two values will be required for two cases defined in \Cref{lem : s to land}.

%








%\yijun{Suggestion: replace \Cref{hst} with a paragraph of informal proof, and then include a formal proof for the lemma below.}

\begin{lemma}[Information pipelining within a segment] \label{mincheckpoint}
    There exists an $\widetilde{O}(n^{2/3}+D)$ randomized algorithm that lets each vertex $v$ in each segment $P[c_i, c_{i+1}]$  compute $M^i[l_j,v]$ with high probability. 
    %in $v \in P$:  $M^i[l_j,v]=\min_{c_{i-1} \leq_P u \leq_P  v} \{|su|+|ul_j|_{G \setminus P}\}$  for all $l_j \in L$, where $c_{i} \leq_P v \leq_P c_{i+1}$.   
    %\yijun{there are some typos in the lemma statement about the indices and strict/non-strict inequalities. I think you should be able to make $N[l_j, c_i]=M^i[l_j, c_i]$ to simplify the discussion (eliminate the $N[]$ notation).}       
        %$N[l_j,c_i] =\min_{c_{i-1} \leq_P u <_P c_{i}} \{(su)+(ul_j)_{G \setminus P}\}$ in $c_i$ for all $l_j \in L$.
        \end{lemma}

\begin{proof}
%Let us recall that, we defined $M[l_j,v_i]$ to denote $|sl_j \diamond P[v_{i},t]|$. This implies, $M[l_j,v_i]=\min_{ u \leq_P  v } \{|su|+|ul_j|_{G \setminus P}\}$. Therefore, $M^i[l_j,v]$ is basically similar to $M[l_j,v_i]$ restricted over the $i$th segment $P[c_{i-1},c_i]$. Hence, fixing $l_j$, $M^i[l_j,v]$ will also be a decreasing function for any $i$.
%\yijun{Actually the above discussion is not helpful, once you see in the def that this is $\min\{...\}$ it is immediate that you can compute it by a single sweep.} \gopinath{Yes!}
First, let all vertices $v \in P$ compute  $|vl_j|_{G \setminus P}$ for all $l_j \in L$. By \Cref{lemma: vilj path}, this can be achieved in $\widetilde{O}(n^{2/3}+D)$ rounds.

%\yijun{I think it will be cleaner if you first describe the algo for a fixed $l_j$, and observe that in the $x$th round we only send a message in the $x$th edge, so by pipelining (the algo for $l_j$ is delayed by $j$ rounds), we can finish in $O(|L| + n^{2/3})$ rounds. }

Let us focus on the $i$th segment, $P[c_{i},c_{i+1}]$.
Let us now fix $l_j$ and discuss how we let all the vertices $v$ in the $i$th segment $P[c_{i},c_{i+1}]$ compute the value of $M^i[l_j,v]$.  In the first round, the first vertex $c_{i}$ calculates $M^i[l_j,c_{i}] = |sc_i| + |c_i l_j|_{G \setminus P}$ locally and sends the value to the second vertex $v'$ of the segment. In the second round, the second vertex calculates $M^i[l_j,v']=\min\{M^i[l_j,c_{i}], |sv'| + |v' l_j|_{G \setminus P}\}$ and send the value to the third vertex of the segment, and so on. The number of rounds needed equals the number of edges in the segment, which is $O(n^{2/3})$.


Observe that, in the $x$th round, we only send a message in the $x$th edge of the segment. 
%Also, the segments are edge-disjoint. Hence, there will be no overlap in sending the messages. 
Therefore, by pipelining (i.e., the algorithm for $l_j$ is delayed by $j$ rounds), we can run the algorithms for all $l_j \in L$ in parallel using $O(n^{2/3}) + |L|-1 = O(n^{2/3})$ rounds.
%This gives us an algorithm with $O(|L| + n^{2/3})$ rounds. Now, $|L|=\widetilde{O}(n^{1/3})$. Therefore, the algorithm works with $\widetilde{O}(n^{1/3}+n^{2/3})=\widetilde{O}(n^{2/3})$ rounds.
%So, let us explicitly discuss how we store $M^i[l_j,v]$. To discuss this process, let us denote the $j$th vertex in the segment $[c_{i},c_{i+1}]$ as $v_{ij}$. We do the following process simultaneously for each segment:
   % \begin{itemize}
  %      \item In the first round, $v_{i0}$ calculates $M^i[l_j,v_{i0}]$ for all $l_j \in L$ and sends $M^i[l_1,v_{i0}]$ to $v_{i1}$.
 %       \item In the second round, $v_{i0}$ sends $M^i[l_2,v_{i0}]$ to $v_{i1}$, $v_{i1}$ calculates $M^i[l_1,v_{i1}]$ and sends it to $v_{i2}$.
%        \item In the third round, $v_{i0}$ sends $M^i[l_3,v_{i0}]$ to $v_{i1}$, $v_{i1}$ calculates $M^i[l_2,v_{i1}]$ and sends it to $v_{i2}$, $v_{i2}$ calculates and send $M^i[l_1,v_{i2}]$ to $v_{i3}$.
    %\end{itemize}
   % The algorithm continues till all $v \in [c_i,c_{i+1}]$ has calculated and stored $M^i[l_j,v_i]$ for all $l_j \in L$.
   % It can be observed that at the end of $n^{2/3}$ rounds, all $v\in [c_i,c_{i+1}]$ will have stored $M^i[l_1,v_i]$. Also, $v_{i1}$ will pass $M^i[l_{n^{2/3}},v_{i1}]$ to $v_{i2}$ after $n^{1/3}$ rounds. This will take $n^{2/3}$ more rounds to be calculated. Hence, we can store $M^i[l_j, v]$ in $O(n_{2/3}+n^{1/3})$ rounds.
\end{proof}
%\yijun{Suggestion: In the above lemma statement, change one inequality to strict inequality so that we really decompose the path into segments, without overlaps.}

%Let us now state our main lemma of this section and prove it formally.

Consider the vertex common to both the $(i-1)$th and $i$th segments, i.e., the checkpoint $c_i$. For a fixed landmark vertex $l_j$, both $M^{i-1}[l_j, c_i]$ and $M^{i}[l_j, c_i]$ are well-defined. However, these values may differ. Both $M^{i-1}[l_j, c_i]$ and $M^{i}[l_j, c_i]$ are necessary for our proof in the following lemma. % \Cref{lem : s to land}.


\begin{lemma}[Part 1]
\label{lem : s to land}
There exists an $\widetilde{O}(n^{2/3}+D)$-round randomized algorithm that lets each vertex $v_i$ in $P$ compute the length of the path $sl_j \diamond P[v_{i},t]$, for all $l_j \in L$, with high probability.
    %There exists a distributed algorithm with $\widetilde{O}(n^{2/3}+D)$ rounds such that, for any $l_j \in L $, length of the path $sl_j \diamond P[v_{i},t]$, i.e., $|sl_j \diamond P[v_{i},t]|$  is stored in $v_i \in P$.
\end{lemma}

\begin{proof}
We first run the algorithm of \Cref{mincheckpoint}. After that, using \Cref{LP}, we can broadcast all values of $M^{i}[l_j,c_{i+1}]$, for all $l_j \in L$ and all segments $P[c_i, c_{i+1}]$, to all the vertices in $\widetilde{O}(n^{2/3}+D)$ rounds. Now, we claim that we already have all the necessary ingredients to calculate \[|sl_j \diamond P[v_{i},t]|= \min_{u \, : \, s \leq_P u \leq_P v_i} \{|su|+|ul_j|_{G \setminus P}\}\] for each $l_j \in L$ at $v_i$. Assume that $(v_i,v_{i+1})$ lies in the segment between $c_k$ and $c_{k+1}$. There are two cases, depending on the vertex $u$ where the detour of $sl_j \diamond P[v_{i},t]$ starts.

\begin{enumerate}

    \item If the detour starts at the same segment, then the length of $sl_j \diamond P[v_{i},t]$ is 
    \[M^k[l_j,u] = \min_{u \, : \, c_k \leq u \leq v_i} \left\{|su|+|ul_j|_{G \setminus P}\right\}.\] The vertex $v_i$ has learned this value from the algorithm of \Cref{mincheckpoint}.

    \item If the detour starts at some other segment, then the length of $sl_j \diamond P[v_{i},t]$ is \[ \min_{c_x \in C \, : \, x < k} \, \,  \, \min_{u \, : \, c_k \leq u \leq v_{k+1}}  \left\{|su|+|ul_j|_{G \setminus P}\right\} = \min_{c_x \in C \, : \, x < k} M^{x}[l_j,c_{k+1}].\]  The vertex $v_i$ as learned  all the values of $M^{x}[l_j,c_i]$ from the broadcast.
\end{enumerate}
The length of $sl_j \diamond P[v_{i},t]$ is the minimum value of the above two cases.
%We do not know whether the detour we were trying to find falls in the first or the second case. However, we can calculate both 
%Thus, we can calculate the relevant information and store those in $v_i$.
\end{proof}

\subsection{Distances From the Landmark Vertices to \texorpdfstring{$t$}{t}}\label{land to t}

This third part is be symmetric to \Cref{s to land}. %Let us state and prove the main result of this section.

%\yijun{put the above proof sketch inside the proof environment for the lemma below}

\begin{lemma}[Part 2]
\label{lem : land to t}
    There exists an $\widetilde{O}(n^{2/3}+D)$-round randomized algorithm that lets each vertex $v_i$ in $P$ compute the length of the path $l_jt \diamond P[s,v_{i+1}]$, for all $l_j \in L$, with high probability.
\end{lemma}

\begin{proof}
    To prove this lemma, we consider the reverse graph $G^R$ of $G$ by reversing all the edges of $G$. The path $P$ will also be reversed to $P^R$, which is $(t=v'_1,v'_2, \dots , v'_{h_{st}-1}=s)$, where the vertex $v_i$ in the $P$ is represented as $v'_{h_{st}-i+1}$ in $P^R$. Our goal is to let $v_i$ compute the distances $|l_jt \diamond P[s,v_{i+1}]|$ for all $l_j \in L$ in the graph $G$. This is equivalent to letting each $v'_i$ compute the distances $|tl_j \diamond (v'_{i-1},s)|$  for all $l_j \in L$ in the graph $G^R$, which can be done using the algorithm of \Cref{lem : s to land} in  $\widetilde{O}(n^{2/3}+D)$ rounds. 
    
    A slight mismatch here is that the algorithm of \Cref{lem : s to land} will store the distance $|l_jt \diamond P[s,v_{i+1}]|$ in $v_{i+1}$ and not $v_i$. This can be resolved by transmitting the information from $v_{i+1}$ to $v_i$ along the edge $(v_i, v_{i+1})$, which costs additional $O(|L|)=\widetilde{O}(n^{1/3})$ rounds.
    %and can be proven symmetrically. Hence, we state the following lemma without proof.
\end{proof}

We are now ready to prove \Cref{Thm: Long Detour Part Works}.

\begin{proof}[Proof of \Cref{Thm: Long Detour Part Works}]

    % In this part, we are dealing with the long detours, i.e., the detours with lengths more than $n^{2/3}$. This algorithm gives an upper bound on the length of the replacement path.
    
    % For each edge $e=(u,v) \in P$, we want to store the length of the path $st \diamond e$ in $u$. From our discussions, it must be clear that, $|st \diamond e|= \min _{(l_j,l_k) \in L \times L} \{ |sl_j \diamond P[u,t]| + |(l_jl_k)_{G \setminus P}|+|l_kt \diamond P[s,v]|\}$. Using, \Cref{lem : land to land} \Cref{lem : s to land}, \Cref{lem : land to t}, we have already stored all the relevant information in $u$ in $\widetilde{O}(n^{2/3}+D)$ rounds.
    
    
    %\yijun{emphasize again that in case the detour is short, the algo reports an upper bound.}
The algorithm runs the procedures of \Cref{lem : s to land,lem : land to t} by spending  $\widetilde{O}(n^{2/3}+D)$ rounds. From the information stored in $v_i$, the vertex $v_i$ can locally compute 
     $$x=\min _{l \in L} \{ |sl \diamond P[v_i,t]| + |lt \diamond P[s,v_{i+1}]\}.$$
Observe that  $x$ is the minimum of the lengths of all paths from $s$ to $t$ that avoids $e$ and contains at least one landmark vertex in $L$.     
    
    We show that the output $x$ satisfies the requirement. Let the path that realizes value $x$ be $P_i$.
     As $P_i$ is a path from $s$ to $t$ avoiding $e$, we have $x \geq |st \diamond e|$.  Let $P_i^*$ be a shortest path from $s$ to $t$ avoiding $e$ with a long detour. By \Cref{Lem : Landmark Vertex}, $P_i^*$ contains a landmark vertex with high probability. Hence, by the definition of $x$, we have $x \leq |P_i^*|$, as required.
     %If $P_i$ contains a long detour, then observe that $x=|P_i|=|P_i^*|$. We have $x \leq |P_i^*|$ since $P_i$ may contain a short detour.
%      If $P_i$ contains long detour, say $R$,
% . Note that $\mathcal{P}_i$ may contain some paths with a short detour. For each path $P_i \in \mathcal{P}_i$
\end{proof}


    









%This way, we store the information about $sl_i \diamond e$ for each $l_i \in L$ and $e \in P$ in the endpoints of $e$. By similar approach on the reverse graph, we can store $l_it \diamond e$ for each $l_i \in L$ and $e \in P$ in the endpoints of $e$ and combine all data to calculate the length of $st \diamond e$ at the endpoints of $e$.\yijun{Could you break the 2-page proof into lemmas/paragraphs? This is a bit long.}
