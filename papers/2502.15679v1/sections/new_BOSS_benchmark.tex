\section{The \bm Benchmark}
\label{sec:bm_challenge}

\begin{figure*}[ht]
    \centering
    \includegraphics[width=1.0\textwidth]{imgs/bms.png} 
    % \caption{This figure illustrates the three challenges of \bm where \pb occurs, with progressively increasing difficulty.\gb{Captions needs to be significantly expanded. I also feel like this figure does not look good. It has a lot of text and basic figures. Can you illustrate each challenge using concrete visual examples and fewer text? It would be more intuitive and look a lot better than the current figure. I also feel like the current figure has a lot going on in terms of arrows. You need to simplify it. For instance, I looked at it for ~30s and I still have no idea what some of these illustrations mean. Make it simpler and reduce the amount of text, arrows, and other potentially uncessary/overwhelming details}}
    % \caption{\gb{Maybe start by saying that this is an illustration of 3 BOSS challenges to immediately indicate what this figure depicts instead of going right into specific examples without any overview.} This figure uses three concrete examples, \texttt{PlaceObject(plate, cabinet)}, \texttt{PlaceObject(potato, bowl)}, and \texttt{MoveContainer(bowl, cabinet)}, to illustrate the three challenges of \bm, each examining distinct aspects of \pb. Challenge 1, ``Single Predicate Modification'', shows a case where \pb occurs due to the modification of a single predicate (i.e., circles in the figure) caused by the effect of the previous skill (e.g., \texttt{IN(potato, bowl)})\gb{Will this not be considered unfair since the training and deployment scenarios are constructed specifically so that they wouldn't overlap or at least that's how it seems?}. Challenge 2, ``Accumulated Predicates Modification'', highlights the scenario where \pb arises from multiple predicate changes (i.e., circles in the figure) due to accumulated effects from preceding skills (e.g., \texttt{On(plate, cabinet)} and \texttt{IN(potato, bowl)})\gb{I feel like this example is a bit weird. In my view, the instruction is ambiguous, i.e., you are saying move the bowl on the cabinet but actually it needs to be moved on the plate. Even if I was a person trying to execute this, I don't know exactly that this is what you would want me to do. For instance, should the bowl be placed on the plate or on some other place on the cabinet? It's also unclear what's supposed to happen if there's not enough space on the cabinet. Generally, I find this example somewhat contrived and not very natural. Maybe it would be better to tell the robot to place the bowl on the plate instead of a cabinet to avoid ambiguity.}. Challenge 3, ``Real Long-Horizon Task'', showcases how \pb impacts a real long-horizon task, where both ``Single Predicate Modification'' and ``Accumulated Predicates Modification'' occur, significantly degrading the final task performance.\gb{What do the green and red colors depict in the figure? It's not explained. What does a red circle around the plate mean? Can you explicitly describe what these are?} \gb{Also, Is this the intended font? These figure captions are pretty small and thus difficult to read without zooming in significantly}}
    
    \caption{This figure illustrates the three challenges of \bm, each examining a distinct aspect of \pb, using concrete examples: \textcolor{mygreen}{\texttt{OpenDrawer(cabinet, bottom)} (green)}, \textcolor{myred}{\texttt{PlaceObject(potato, bowl)} (red)}, and \textcolor{myblue}{\texttt{MoveContainer(bowl, cabinet)} (blue)}. Challenge 1, Single Predicate Shift (\bma), shows a case where \pb occurs due to the modification of a single predicate (i.e., the circle in the figure) caused by the effect of the previous skill (e.g., \texttt{IN(potato, bowl)}). Challenge 2, Accumulated Predicate Shift (\bmb), highlights the scenario where \pb arises from multiple predicate changes (i.e., circles in the figure) due to accumulated effects from preceding skills (e.g., \texttt{IN(potato, bowl)} and \texttt{DrawerOpen(cabinet, top)}). Challenge 3, Real Long-Horizon Task (\bmc), showcases how \pb impacts a real long-horizon task with three skills, where ``Single Predicate Shift'' and ``Accumulated Predicate Shift'' occur in the second skill and the third skill respectively, significantly degrading the final task performance.}
    \vspace{-1.6em}
    \label{fig:bm_arch}
\end{figure*}



We introduce the \bm benchmark, designed to facilitate a comprehensive empirical study of the \pb problem across modern IL methods. To address this issue, we build the environment using the Libero simulation platform~\cite{liu2024libero} (Section~\ref{subsec:bm_env}) and form the task set by leveraging selected existing tasks from Libero and scalably generating their modified versions (Section~\ref{subsec:bm_task}). \bm includes three challenges (Section~\ref{subsec:bm_1}~$\sim$~\ref{subsec:bm_3}) designed not only to validate the existence of \pb but also to demonstrate its significant negative impact on the success of long-horizon tasks. These challenges evaluate IL methods on the curated tasks within the constructed environment and feature 44, 88, and 10 tasks respectively, providing a diverse and extensive evaluation.


% \gb{Do we need a figure to highlight the main properties of the benchmark? Since this is one of our main contributions, I think it would be great to showcase that as a figure, especially if we want to emphasize particular things about the benchmark, i.e., a large number of tasks, etc?}\yy{TODO - pie chart}


\subsection{Environment}
\label{subsec:bm_env}
We build the environment of \bm on the Libero platform~\cite{liu2024libero}, which, although originally designed for lifelong robot learning tasks, provides diverse manipulation scenes featuring a Franka Emika Panda robot arm and accommodates a wide variety of tasks. Libero is highly flexible for creating and customizing tasks because they are generated using Planning Domain Definition Language (PDDL) files, which specify the planning problem including operators, predicates, and their relationships. These features make Libero an excellent foundation for developing \bm, enabling us to adapt it specifically to study the \pb problem.

\subsection{Task Design}
\label{subsec:bm_task}

Building on the Libero environment, \bm focuses on studying the impact of \pb on long-horizon tasks. To achieve this, we require a set of atomic robotic tasks, where each task involves only a single skill. These tasks are used to simulate individual skills within a skill chain that are unaffected by \pb. Additionally, we generate modified counterparts to simulate scenarios where \pb occurs. This setup enables performance comparisons between the two sets when evaluating IL methods. All three challenges are based on these 2 sets of tasks. 

To build the set of tasks unaffected by \pb, we select all the skill-level tasks from Libero-100, the most comprehensive and diverse task suite in Libero, spanning 12 manipulation scenes and covering a wide range of object interactions and motor skills. Multi-skill tasks (e.g., “open the top drawer of the cabinet and put the bowl in it”) are excluded, while single-skill tasks (e.g., “open the bottom drawer of the cabinet”) are retained. As a result, the final set comprises 44 single-skill tasks. % \gb{Why? It seems that those would be even better suited to study the OSS problem} All three challenges are constructed from this refined set.

% \yy{TODO: use some notations mentioned in problem def here.} To build the set of counterparts, we propose the \textbf{Rule-based Automatic Modification Generator (RAMG)}, which can scalably generate modified tasks. RAMG is a systematic algorithm designed to enhance diversity in pre-defined environments through structured, rule-based modifications. Operating on PDDL files, RAMG iteratively alters object positions, introduces new objects, or modifies object states within the environment. It supports three types of modifications: (1) repositioning or adding external objects to specific regions, (2) changing the states of fixtures (e.g., opening or closing cabinets), and (3) placing small objects into designated containers. These modifications follow dynamic constraints (e.g., newly added objects do not create obstacles) and maintain logical consistency (e.g., a drawer cannot be simultaneously open and closed) to ensure that they do not hinder the agent from achieving the task goal. Using deterministic yet flexible rules, RAMG provides a scalable method for generating task variations. With a single modification per task, RAMG can produce up to 1,727 modified tasks from the 44 selected tasks, and adding multiple modifications significantly increases this number. The extensive set of generated modified tasks offers flexibility and a robust foundation for designing the three challenges.

To build the set of counterparts, we propose the \textbf{Rule-based Automatic Modification Generator (RAMG)}, which can scalably generate modified tasks. RAMG is an algorithm designed to enhance the visual diversity of skills in predefined environments through structured, rule-based modifications. Operating on PDDL files, RAMG iteratively modifies predicates, $\Psi$, by altering object positions, introducing new objects, or changing object states within the environment. It supports three types of modifications: (1) repositioning existing objects or adding external objects to specific regions, (2) changing the state of fixtures (e.g., toggling a predicate like \texttt{DrawerOpen(bottom\_drawer, cabinet)}), and (3) modifying containment relations by altering predicates like \texttt{In(potato, bowl)}. These modifications adhere to dynamic constraints (e.g., newly added objects do not interfere with existing \texttt{Pre} and \texttt{Eff} conditions) and maintain logical consistency (e.g., preventing contradictions where a predicate $\psi_i$ and its negation $\neg\psi_i$ hold simultaneously). Using deterministic yet flexible rules, RAMG provides a scalable method for generating task variations. With a single modification per task, RAMG can produce up to 1,727 modified tasks from the 44 selected tasks, and adding multiple modifications significantly increases this number. The extensive set of generated modified tasks offers flexibility and a robust foundation for designing the three challenges.

% \gb{How many of these will you use? The way this is written, you are leading the reader to believe that your experiments will involve all of these 1,727 modified tasks. If the number is much smaller than that, you will need to provide a good justification why you don't do it}






\subsection{Challenge 1: Single Predicate Shift (\bma)}
\label{subsec:bm_1}

% \gb{The section structure of this seems disjoint. You go from environment to Challenge 1 without any explanation or overview. Maybe instead you could have a separate section dedicated to all the challenges and then just list each challenge as a subsection? Also, before introducing each challenge maybe you could provide a brief overview of what each challenge entails? Right now the transition between the previous section and this section seems very abrupt and not very intuitive} \yy{I added some descriptions to connect environment and the 3 challenges, will this be better now?}

% As outlined in Section~\ref{sec:problem_definition}, \pb arises when skill-irrelevant predicates, $\Psi$, are altered in ways that do not affect the feasibility of the current skill but disrupt the execution of its visuomotor policy. For example, as shown in the left box of Figure~\ref{fig:bm_arch}, \texttt{In(potato, bowl)} does not impact the feasibility of the current skill, \texttt{MoveContainer(bowl, cabinet)}, but negatively affects the skill policy's performance. In the context of skill chaining, a foundational structure in long-horizon tasks, the preceding skill is the most likely to cause \pb for the subsequent skill. Therefore, we introduce a challenge, Single Predicate Modification (\bma), specifically designed to evaluate the impact of \pb caused by single-step transitions on the performance of baseline methods (see examples in Figure~\ref{fig:bm_arch}).

As outlined in Section~\ref{sec:problem_definition}, \pb arises when skill-irrelevant predicates, $\Psi$, are altered in ways that do not affect the feasibility of the current skill but disrupt the execution of its visuomotor policy. For example, as shown in the left box of Figure~\ref{fig:bm_arch}, the predicate \texttt{In(potato, bowl)} does not impact the feasibility of the current skill, \texttt{MoveContainer(bowl, cabinet)}, since it is absent from $\texttt{Pre}$ and $\texttt{Eff}$. However, changes to this predicate can still alter the visuomotor observation space, $\mathcal{O}$, negatively affecting the skill policy's performance. In the context of skill chaining, a foundational structure in long-horizon tasks, the preceding skill is the most likely to introduce modifications in $\mathcal{O}$ that induce \pb for the subsequent skill. Therefore, we introduce a challenge, Single Predicate Shift (\bma), specifically designed to evaluate the impact of \pb caused by single-step transitions on the performance of baseline methods (see examples in Figure~\ref{fig:bm_arch}).

To investigate the impact of single-step \pb on baseline methods, we compare their performance on skills unaffected by \pb (e.g., \texttt{On(potato, table)}) versus those affected by \pb (e.g., \texttt{In(potato, bowl)}). As detailed in Section~\ref{subsec:bm_task}, for the former, we evaluate baselines on the 44 selected tasks. For the latter, we use RAMG to generate 44 corresponding randomly modified tasks, each with a single modification applied to simulate the occurrence of \pb caused by the preceding skill. 

% Libero's customization flexibility plays a crucial role here, as its task environments are generated using Planning Domain Definition Language (PDDL) files\notezlf{you may mention PDDL when introducing task planning in formulation? you can mention it defines e.g., operators, and what you need to modify here}. This allows us to easily add new objects (e.g., placing a potato in a bowl or on a tabletop) or modify object states (e.g., closing an opened drawer). These modifications enable us to simulate single-step \pb efficiently and evaluate baseline performance on the altered tasks.








\subsection{Challenge 2: Accumulated Predicate Shift (\bmb)}
\label{subsec:bm_2}
% The effect of executing a skill persists until a future skill reverses it, meaning it impacts not only the immediate next skill but also multiple subsequent skills. Over the course of a skill chain, effects from numerous skills can accumulate, resulting in a more severe \pb for a future skill. As illustrated in the middle box of Figure~\ref{fig:bm_arch}, the accumulated effects, \texttt{On(plate, cabinet)} and \texttt{In(potato, bowl)}, collectively impact the current skill, \texttt{MoveContainer(bowl, cabinet)}. Thus, it is valuable to study the differences between accumulated \pb and single-step \pb. To address this, we introduce another challenge, Accumulated Predicates Modification (\bmb), specifically designed to analyze the impact of \pb accumulation across preceding skills (check examples in Figure~\ref{fig:bm_arch}).

The effect of executing a skill persists until a future skill reverses it, meaning it impacts not only the immediate next skill but also multiple subsequent skills. Over the course of a skill chain, effects from numerous skills can accumulate, resulting in a more severe \pb for a future skill. Formally, given a sequence of operators $\{\texttt{op}_1, \texttt{op}_2, \dots, \texttt{op}_t\}$, the accumulated effects at time step $t$ are given by $\bigcup_{i=1}^{t} \texttt{Eff}_i$. As illustrated in the middle box of Figure~\ref{fig:bm_arch}, the accumulated effects, \texttt{On(plate, cabinet)} and \texttt{In(potato, bowl)}, collectively impact the current skill, \texttt{MoveContainer(bowl, cabinet)}, by modifying predicates in the observation space $\mathcal{O}$. Thus, it is valuable to study the differences between accumulated \pb and single-step \pb. To address this, we introduce another challenge, Accumulated Predicate Shift (\bmb), specifically designed to analyze the impact of \pb accumulation across preceding skills (check examples in Figure~\ref{fig:bm_arch}).


Similar to \bma, we evaluate baseline performance on the next skill under two conditions: task unaffected by \pb and task modified by previous effects. Using PDDL description files, we create two sets of modified tasks, each simulating the cumulative effects of multiple preceding skills on the current skill, with one set incorporating two modifications and the other three. However, multiple modifications can sometimes conflict. For example, a modification such as ``place an apple inside the small bowl'' could conflict with another that specifies ``place a potato inside the small bowl,'' potentially causing the Libero environment to break due to overlapping space constraints. By iteratively invoking the proposed RAMG two or three times, we easily generate the two sets of modified tasks, leveraging RAMG's ability to ensure constraint-compliant task generation.



% \gb{It would be great to provide a detailed list of modifications that your system can implement. Similarly, for completenes/reporducibility, it would be great to provide a list of all the tasks included in your dataset along with the numbers for each task. This would emphasize the benchmark contribution and also make the paper more reproducible. Right now many details about your benchmark/dataset are missing.} \yy{I could provide stats in the pie chart, but it's hard for me to list all task names considering there're thousands of tasks generated by RAMG. For listing tasks I use in these 3 challenges, I could add the names later in the appendix after the paper is published (RA-L does not include appendix but I could include one in arxiv version).}






\subsection{Challenge 3: Skill Chaining (\bmc)}
\label{subsec:bm_3}
The ultimate goal of addressing the \pb problem is to improve the success of long-horizon robot tasks. To this end, we introduce a challenge, Skill Chaining (\bmc), consisting of 10 long-horizon tasks, each comprising a chain of three skills (check examples in Figure~\ref{fig:bm_arch}). This challenge serves as a straightforward way to demonstrate the impact of the \pb problem on long-horizon task performance.

To construct this challenge, we manually select and combine skills from the 44 selected skill-level tasks, ensuring that \pb occurs in each skill while avoiding conflicts between modifications. We reset the robot to a neutral position after each skill to eliminate dynamic transition feasibility issues~\cite{chen2023sequential}, ensuring the challenge focuses solely on the impact of \pb, which specifically addresses the negative effects of changes in visual observations.


