\section{An algorithm for deciding \texorpdfstring{$\exists\R(\ipow{\cn})$}{the existential theory}}
\label{sec:the-algorithm}

\emph{Fix a computable number $\cn > 0$ that is either transcendental or has a
polynomial root barrier}. In this section, we discuss our procedure for deciding
the satisfiability of formulae in~$\exists\R(\ipow{\cn})$. For simplicity, we
assume for now $\cn > 1$. The general case of $\cn > 0$ is handled
in~\Cref{subsection:small-bases}.

The pseudocode of the procedure is given in~\Cref{algo:main-procedure}. To keep
it as simple as possible, we use nondeterminism in line~\ref{algo:line8} instead
of implementing, e.g., a routine backtracking algorithm. The procedure assumes
the input formula~$\phi(x_1,\dots,x_n)$ to be quantifier-free (this is without
loss of generality, since~$\exists\R(\ipow{\cn})$ is an existential theory), 
and it is split into three steps, which we discuss in the forthcoming three
subsections.

\input{code-simple-procedure}
\input{algorithm-sign-evaluation}

\subsection{Step I (lines~\ref{algo:line1}--\ref{algo:line6}): reducing the
variables to integer powers of
\texorpdfstring{$\xi$}{the base}}\label{subsection:reduction-to-substructure}

The first step reduces the problem of finding a solution over $\R$ to the
problem of finding a solution over $\ipow{\cn}$. Below, we denote by
$\exists\ipow{\cn}$ the existential theory of the structure $(\ipow{\cn}; 0, 1,
\cn, +, \cdot, <,=)$. Formulae from this theory are built from the grammar of
$\exists\R(\ipow{\cn})$, except they do not feature predicates $\ipow{\cn}(x)$,
as they are now trivially true.

For reducing $\exists\R(\ipow{\cn})$ to $\exists\ipow{\cn}$, we observe that
every $x \in \R$ can be factored as $u \cdot v$ where $u$ belongs to
$\ipow{\cn}$ and $v$ is either $0$ (if $x = 0$) or it belongs, in absolute
value, to the interval~$[1,\cn)$. In the case of $x \neq 0$, this factorisation
is unique, and $u$ corresponds to the largest element of $\ipow{\cn}$ that is
less or equal to the absolute value of~$x$, i.e., $u \leq \abs{x} < \cn \cdot
u$. The procedure uses this fact to replace every occurrence of a variable $x_i$
in the input formula $\phi(x_1,\dots,x_n)$ with two fresh variables $u_i$ and
$v_i$ (see the \textbf{for} loop of line~\ref{algo:line1}), where $v_i$ is set
to satisfy either $v_i = 0$ or $1 \leq \abs{v_i} < \cn$ (the latter is short for
the formula $(1 \leq v_i < \cn) \lor (-\cn < v_i \leq -1)$), and $u_i$ is
(implicitly) assumed to belong to $\ipow{\cn}$. This allows to replace all
occurrences of the predicate $\ipow{\cn}(x_i)$ with $v_i = 1$
(line~\ref{algo:line3}). We obtain in this way an equivalent formula from the
existential theory of the reals, but where the variables $u_1,\dots,u_n$ are
assumed to range over~$\ipow{\cn}$.

After the updates performed by the \textbf{for} loop, the procedure eliminates
the variables $v_1,\dots,v_n$ by appealing to a quantifier elimination procedure
for the FO theory of the reals, named \textsc{RealQE} in the pseudocode. We
remind the reader that a quantifier elimination procedure is an algorithm that, 
from an input (quantified) formula, produces an \emph{equivalent} quantifier-free
formula. Since such a procedure preserves formula equivalence, we can use it to
eliminate $v_1,\dots,v_n$ even if $u_1,\dots,u_n$ are assumed to range over
$\ipow{\cn}$.
%, as the latter variables occur free in the formula in input of \textsc{RealQE}. 
The constant $\cn$ appearing in the formula is treated as an
additional free variable by \textsc{RealQE}. The output formula
$\psi(u_1,\dots,u_n)$ belongs to $\exists\ipow{\cn}$, as required. This
concludes the first step of the~algorithm.

To perform the quantifier elimination step, we rely on the
quantifier elimination procedure for the (full) FO theory of the reals developed
by Basu, Pollack and Roy~\cite{BasuPR96}. This procedure achieves the
theoretically best-known bounds for the output formula, not only for 
arbitrary
quantifier alternation but also for the existential
fragment (i.e., when taking~$\omega = 1$ below).

\begin{restatable}[{\cite[Theorem 1.3.1]{BasuPR96}}]{theorem}{TheoremBasu}
  \label{theorem:basu}
  There is an algorithm with the following specification:
  \begin{center}
    \begin{minipage}{0.95\linewidth}
      \begin{description}
        \item[\textup{Input:}]\tab A formula~$\phi(\vec y)$ from the first-order
          theory of $(\R; 0, 1, +, \cdot, <, =)$.
        \item[\textup{Output:}]\tab A quantifier-free formula $\gamma(\vec y) =
          \bigvee_{i = 1}^I \bigwedge_{j = 1}^J p_{i,j}(\vec y) \sim_{i,j} 0$
          equivalent to $\phi$,\\ 
          \tab\tab where every $\sim_{i,j}$ is from $\{<,=\}$.
      \end{description}
    \end{minipage}
  \end{center}
  Suppose the input formula~$\phi$ to be of the form $Q_1 \vec x_1 \in \R^{n_1}
  \dots Q_\omega \vec x_\omega \in \R^{n_\omega} : \psi(\vec y, \vec x_1, \dots,
  \vec x_\omega)$, where $\vec y = (y_1,\dots,y_k)$, every $Q_i$ is $\exists$ or
  $\forall$, and $\psi$ is a quantifier-free formula with $m$ atomic formulae
  $g_i \sim 0$ satisfying $\deg(g_i) \leq d$ and $\height(g_i) \leq h$. Then,
  the output formula~$\gamma$ satisfies
  \begin{center}
      $\begin{aligned} I &\leq (m \cdot d + 1 )^{(k+1) \Pi_{i=1}^\omega
        O(n_i)}\,, &\hspace{1cm} \deg(p_{i,j}) &\leq d^{\Pi_{i=1}^\omega
        O(n_i)}\,, \\
        J &\leq (m \cdot d + 1)^{\Pi_{i=1}^\omega O(n_i)}\,, & \height(p_{i,j})
        &\leq (h+1)^{d^{(k+1) \Pi_{i=1}^\omega O(n_i)}}\,, \end{aligned}$
        \vspace{-3pt}
  \end{center}
  and the algorithm runs in time $\size(\phi)^{O(1)}(m \cdot d
  +1)^{(k+1)\Pi_{i=1}^\omega O(n_i)}$.
\end{restatable}


\subsection{Step II (lines~\ref{algo:line7} and~\ref{algo:line8}):
solving \texorpdfstring{$\exists\ipow{\cn}$}{the existential theory over integer powers of the base}}\label{subsection:algorithm-step-two}

The second step of the procedure searches for a solution to the quantifier-free
formula $\psi$ in line~\ref{algo:line6}. For every variable $u_i$ in $\psi$, the
algorithm guesses an integer $g_i$, encoded in unary, from a finite set $P_{\psi}$.
Implicitly, this guess is setting $u_i = \cn^{g_i}$. The next proposition shows
that $P_{\psi}$ can be computed from $\psi$ and the base~$\cn$, i.e.,
$\exists\ipow{\cn}$ has a \emph{small witness property}.%

\begin{restatable}{proposition}{TheoremSmallModelProperty}
  \label{theorem:small-model-property}
  Fix $\cn > 1$. There is an algorithm with the following specification: 
  \begin{center}
    \begin{minipage}{0.95\linewidth}
      \begin{description}
        \item[\textup{Input:}]\tab A quantifier-free formula $\psi(u_1,\dots,u_n)$ from $\exists \ipow{\cn}$. 
        \item[\textup{Output:}]\tab A finite set $P_{\psi} \subseteq \Z$ such that $\psi$ is satisfiable if and only if\\ 
        \tab\tab $\psi$ has a solution in the set $\{(\cn^{j_1},\dots,\cn^{j_n}) : j_1, \dots, j_n \in P_{\psi} \}$.
      \end{description}
    \end{minipage}
  \end{center}
  To be effective, the algorithm requires knowing either that $\cn$ is a
  computable transcendental number, or two integers  $c,k \in \N_{\geq 1}$ for
  which~$\sigma(d,h) \coloneqq c \cdot (d+\ceil{\ln(h)})^k$ is a root barrier of
  $\cn$. In the latter case, the elements in $P_{\psi}$ are bounded in absolute
  value by $(2^{c}\ceil{\ln(H)})^{D^{2^5n^2} k^{D^{8n}}}$, where $H \coloneqq
  \max(8,\height(\psi))$ and $D \coloneqq \deg(\psi)+2$.
\end{restatable}

\noindent
We defer a sketch of the proof of~\Cref{theorem:small-model-property} (perhaps
the main technical contribution of the paper)
to~\Cref{sec:solving-substructure}. Note that the bound on~$P_{\psi}$ given in
the final statement of~\Cref{theorem:small-model-property} is in general triply
exponential in $\size(\psi)$, but it becomes doubly exponential if the root
barrier $\sigma$ is such that $k = 1$. The two statements
in~\Cref{theorem:general-result-root-barrier} stem from this distinction.

\subsection{Step III (line~\ref{algo:line9}): polynomial sign
evaluation}\label{subsection:polynomial-sign-evaluation} 
The last step of the procedure checks if the assignment $u_1 =
\cn^{g_1},\dots,u_n = \cn^{g_n}$ is a solution to $\psi(u_1,\dots,u_n)$. Observe
that $\psi(\cn^{g_1},\dots,\cn^{g_n})$ is a Boolean combination of polynomial
(in)equalities $p(\cn) \sim 0$, where $\cn$ may occur with negative powers (as
some $g_i$ may be negative). This is unproblematic, as one can make all powers
non-negative by rewriting each (in)equality $p(\cn) \sim 0$ as $\cn^{-d} \cdot p
\sim 0$, where $d$ is the smallest negative integer occurring as a power of
$\cn$ in~$p$ (or $0$ if such an integer does not exist).
%, thus obtaining a formula where all polynomials have non-negative degrees.  
After this small update, line~\ref{algo:line9} boils down to determining the
sign that each polynomial in the formula has when evaluated at $\cn$. This
enables us to simplify all inequalities to either $\top$ or $\bot$, to then
return $\top$ or $\bot$ depending on the Boolean structure of~$\psi$. Let us
thus focus on the required sign evaluation problem, which we denote
by~$\SIGN_{\cn}$. Its specification is the following:

\begin{center}
  \begin{minipage}{0.95\linewidth}
    \begin{description}
      \item[Input:]\tab A univariate integer polynomial $p(x)$.
      \item[Output:]\tab The symbol $\sim$ from $\{<,>,=\}$
      such that $p(\cn) \sim 0$.
    \end{description}
  \end{minipage}
\end{center}

\subparagraph*{Solving {\rm$\SIGN_{\cn}$} when $\cn \in \R$ is transcendental.}
It is a standard fact that~$\SIGN_{\cn}$ becomes solvable whenever~$\cn$ is any
computable transcendental number. Indeed, in this case $p(\cn)$ must be
different from~$0$, and one can rely on the fast-convergence sequence of
rational numbers~$T_0,T_1,\dots$ to find $n \in \N$ such that $|p(\cn) -
p(T_{n})|$ is guaranteed to be less than $|p(T_{n})|$. The sign of $p(\cn)$ then
agrees with the sign of~$p(T_{n})$, and the latter can be easily computed. In
general, the asymptotic running time of this algorithm cannot be bounded. 


\subparagraph*{Solving {\rm$\SIGN_{\cn}$} when $\cn \in \R$ has a (polynomial) root barrier.}
A similar algorithm as the one given for transcendental numbers can be defined
for numbers with a polynomial root barrier; and in this case its running time
can be properly analysed. The pseudocode of such a procedure is given
in~\Cref{algo:sign-evaluation}, and it should be self-explanatory. We stress
that running this algorithm requires access to the root barrier $\sigma$ and the
Turing machine $T$.

\begin{restatable}{lemma}{LemmaSignPolyRootBarrier}
  \label{lemma:sign-poly-root-barrier}
  \Cref{algo:sign-evaluation} respects its specification.
\end{restatable}

\begin{proof}[Proof sketch] 
  If $\abs{T_n} \geq h+2$, then $p(\cn)$ and $p(T_n)$ have the same sign,
  because $h+1$ is an upper bound to the absolute value of every root
  of~$p(x)$~\cite[Chapter 8]{Rahman02}. If~$\abs{T_n} < h+2$ instead, by
  studying the derivative of $p$ in the interval ${[-(h+3),h+3]}$
  containing~$\cn$, one finds $\abs{p(\cn)-p(T_n)} \leq 2^{-2\sigma(d,h)-1}$,
  with~$n$ defined as in line~\ref{algo:sign-evaluation:bound-on-n}. Then,
  either $\abs{p(T_n)} \leq 2^{-2 \cdot \sigma(d,h)-1}$ and $p(\cn) = 0$, or
  $\abs{p(T_n)} > 2^{-2 \cdot \sigma(d,h)-1}$ and $p(\cn)$ and $p(T_n)$ have the
  same sign.
\end{proof}

% \begin{proof}[Proof sketch] 
%   The proof of this lemma rests on the following two facts: \textbf{(i)} $h+1$
%   is an upper bound to the absolute value of every root of~$p$~\cite[Chapter
%   8]{Rahman02}, so if $\abs{T_n} \geq h+2$, then $p(\cn)$ and $p(T_n)$ have the
%   same sign. \textbf{(ii)} Assuming $\abs{T_n} < h+2$, the choice of~$n$ made in
%   line~\ref{algo:sign-evaluation:bound-on-n} entails $\abs{p(\cn)-p(T_n)} \leq
%   2^{-2\sigma(d,h)-1}$. (This is proven by first bounding
%   $\frac{\abs{p(\cn)-p(T_n)}}{\abs{\cn-T_n}}$ by the maximum, in absolute value,
%   that derivative of $p$ takes in the interval ${[-(h+3),h+3]}$
%   containing~$\cn$.) By definition of root barrier, $p(\cn) = 0$ or
%   $\abs{p(\cn)} \geq e^{-\sigma(d,h)} > 2^{-2\sigma(d,h)}$. Then, either
%   $\abs{p(T_n)} \leq 2^{-2 \cdot \sigma(d,h)-1}$ and $p(\cn) = 0$, or
%   $\abs{p(T_n)} > 2^{-2 \cdot \sigma(d,h)-1}$ and $p(\cn)$ and $p(T_n)$ have the
%   same sign. 
% \end{proof}

When $\sigma$ is a polynomial root barrier, the integer $n$ from
line~\ref{algo:sign-evaluation:bound-on-n} can be written in unary using
polynomially many digits with respect to~$\size(p)$. This yields the following
lemma.

\begin{restatable}{lemma}{LemmaRuntimeSignPolyRootBarrier}
  \label{lemma:runtime-sign-poly-root-barrier}
  Let $\cn \in \R$ be a number computed by a Turing machine $T$ and having a polynomial
  root barrier~$\sigma$. If $T$ runs in polynomial time, then so
  does~\Cref{algo:sign-evaluation}.
\end{restatable}

\subsection{Correctness and running time of Algorithm~\ref{algo:main-procedure}}
\label{subsection:correctness-algorithm}

Since~lines~\ref{algo:line1}--\ref{algo:line5} preserve the satisfiability the
input formula, by chaining~\Cref{theorem:basu},
\Cref{theorem:small-model-property}, and \Cref{lemma:sign-poly-root-barrier}, we
conclude that~\Cref{algo:main-procedure} is correct. 
\begin{restatable}{lemma}{LemmaCorrectnessAlgorithmOne}
  \label{lemma:correctness-algorithm-1}
  \Cref{algo:main-procedure} respects its specification.
\end{restatable}
This
establishes~\Cref{theorem:result-root-barrier}.\ref{theorem:result-root-barrier:point3}
restricted to bases $\cn > 1$. Analogously, when $\cn$ is a number with a
polynomial root barrier~$\sigma(d,h) \coloneqq {c \cdot (d + \ceil{\log_e
h})^k}$, by pairing~\Cref{lemma:correctness-algorithm-1} with a complexity
analysis of~\Cref{algo:main-procedure}, one
shows~\Cref{theorem:general-result-root-barrier} restricted to bases $\cn > 1$.
In performing this analysis, we observe that the bottleneck of the procedure is
given by the guesses of the integers~$g_i$ performed lines~\ref{algo:line7}
and~\ref{algo:line8}. The absolute value of these integers is either doubly or
triply exponential in the size of the input formula $\phi$, depending on
whether~$k=1$. A deterministic
implementation of the procedure can iterate through all their values in doubly
or triply exponential time.

% \begin{proof}[Proof sketch of~{\Cref{theorem:general-result-root-barrier}} for $\cn > 1$.]
% We discuss the runtime of~\Cref{algo:main-procedure} with respect to a base $\cn
% > 1$ computable by a polynomial-time Turing machine and having a root
% barrier~$\sigma(d,h) \coloneqq {c \cdot (d + \ceil{\log_e h})^k}$.
% By~\Cref{theorem:basu}, the formula $\psi$ defined in line~\ref{algo:line6} is
% computed in exponential time (and has exponential size) in the size of the input
% formula~$\phi$. Then, by~\Cref{theorem:small-model-property}, the integers~$g_i$
% guessed in line~\ref{algo:line7} are, when written in unary, either doubly or
% triply exponential in~$\size(\phi)$ (depending on whether $k = 1$). When
% implementing the procedure deterministically, we can iterate through all these
% unary numbers in doubly or triply exponential time. Accounting for the sizes of
% $\psi$ and of each $g_i$, we see that line~\ref{algo:line9} calls the algorithm
% for $\SIGN_{\cn}$ on polynomials whose height is singly exponential
% in~$\size(\phi)$, and whose degree is either doubly or triply exponential
% in~$\size(\phi)$. Following~\Cref{lemma:runtime-sign-poly-root-barrier}, we
% conclude that the whole procedure takes doubly or triply exponential time
% (depending~on~$k$). 
% \end{proof}

% \begin{restatable}{lemma}{LemmaRuntimeSignPolyRootBarrierPolyTM}
%   Let $\cn$ be an algebraic number, or $\pi$.
%   There is an instantiation of~\Cref{algo:sign-evaluation} 
%   that runs in time $\poly(\size(p))$.
%   That is, $\SIGN_{\cn}$ can be solved in polynomial time.
% \end{restatable}

% Of course, in the case of~$\cn$ being an algebraic number represented by $(q,\ell,u)$, one can
% also solve $\SIGN_{\cn}$ in a na\"ive way, by checking the validity of the Tarski arithmetic formulae ${\exists x : q(x) = 0 \land \ell \leq x \leq u \land p(x) \sim 0}$, where $\sim$ ranges over
% $\{=,\geq\}$ and $p$ is the input polynomial. By~\Cref{theorem:basu}, this method also requires polynomial time.
% \am{This lead to the following idea...}

% \am{Text below is work in progress / needs to be redone.}

% If $\cn$ is one of the remaining numbers in~\Cref{table:transcendence-degrees},
% then other instantiations of~\Cref{algo:sign-evaluation} yield good results.
% To the best of our knowledge, the fastest known Turing machines to compute irrational algebraic numbers may require polynomial space~\cite{?}.
% Nonetheless, we can obtain a polynomial time procedure by considering approximations and representations that are different from the ones given by $T$.

% In the case of $\cn$ being an (irrational) algebraic number given by~$(q,\ell,u)$.

% \begin{restatable}{lemma}{LemmaRuntimeSignPolyRootBarrierPolyTable1}
%   \label{lemma:runtime-sign-polynomial-root-barrier-poly-table1}
%   Let $\cn$ be algebraic or a number from~\Cref{table:transcendence-degrees}. There is an  instantiation of \Cref{algo:sign-evaluation} 
%   that runs in time $\poly(\size(p))$.
%   That is, $\SIGN_{\cn}$ can be solved in polynomial time.
% \end{restatable}

% \noindent
% We remark that~\Cref{lemma:runtime-sign-polynomial-root-barrier-poly-table1}
% provides an algorithm for deciding $\SIGN_{\cn}$ for $\cn = e$ that is
% exponentially faster than the (more known) procedure described by Macintyre and
% Wilkie in~\cite[pages 460--462]{MacWilkie96}, which is based on Baker's proof of
% the transcendence of $e$. Despite trying, we could not find a suitable reference
% for solving this problem in polynomial time.


\subsection{Handling small bases}\label{subsection:small-bases}

We now extend our algorithm so that it works assuming $\cn > 0$ instead of just
$\cn > 1$, hence completing the proofs of
\Cref{theorem:result-root-barrier}.\ref{theorem:result-root-barrier:point3} and
\Cref{theorem:general-result-root-barrier}. Let $\cn$ be computable and either
transcendental or with a polynomial root barrier. First, observe that we can
call the procedure for $\SIGN_\cn$ on input $x-1$ in order to check if $\cn \in
(0,1)$, $\cn = 1$ or $\cn > 1$. 

If $\cn = 1$, we
replace in the input formula $\phi$ every occurrence of $\ipow{\cn}(x)$ with $x
= 1$, obtaining a formula from the existential theory of the reals, which we can
solve by~\Cref{theorem:basu}. If~$\cn > 1$, we
call~\Cref{algo:main-procedure}. Suppose then $\cn \in (0,1)$. In this case, we
replace every occurrence of $\ipow{\cn}(x)$ with
$\ipow{\big(\frac{1}{\cn}\big)}(x)$, and opportunely multiply by integer powers of
$\frac{1}{\cn}$ both sides of polynomials inequalities in order to eliminate the
constant $\cn$. In this way, we obtain from $\phi$ an equivalent formula
in~$\exists\R(\ipow{\big(\frac{1}{\cn}\big)})$. Since $\frac{1}{\cn} > 1$, we
can now call~\Cref{algo:main-procedure}; provided we first establish the
properties of $\frac{1}{\cn}$ required to run this algorithm. These properties
indeed hold:
\begin{enumerate}
  \item\label{small-bases:i2} If $\cn$ is transcendental, then so is
  $\frac{1}{\cn}$. This is because the algebraic numbers form a field.
  \item\label{small-bases:i3} If $\cn$ has a polynomial root barrier~$\sigma$,
  then $\sigma$ is also a root barrier of $\frac{1}{\cn}$. Indeed, consider an
  integer polynomial $p(x) = \sum_{i=0}^d a_i \cdot x^i$ with height $h$, and
  assume $p(\frac{1}{\cn}) \neq 0$. Since $\sigma$ is a root barrier of $\cn$,
  we have $\cn^d \cdot |{p(\frac{1}{\cn})}| = |{\sum_{i=0}^d a_i \cdot
  \cn^{d-i}}| \geq e^{-\sigma(h,d)}$, which in turns implies that
  $|{p(\frac{1}{\cn})}| \geq e^{-\sigma(h,d)} \cdot \cn^{-d} \geq
  e^{-\sigma(h,d)}$, where the last inequality uses~$\frac{1}{\cn} \geq 1$.
  \item\label{small-bases:i1} From a Turing machine $T$ computing $\cn$, we can
  construct a Turing machine $T'$ computing~$\frac{1}{\cn}$.
  \Cref{lemma:turing-machine-reciprocal} gives this construction, and shows that
  $T'$ runs in polynomial time if so does $T$. 
  %(as required to apply the
  %already-established~\Cref{theorem:general-result-root-barrier} for $\cn >
  %1$).
\end{enumerate} 
