\section{Introduction}

In the current data-rich era, extracting meaningful information from the ever-growing volume of data presents a significant challenge \cite{ss13}.
To address this challenge, various data structures have been developed to facilitate the extraction of insights from vast datasets \cite{c06}, such as the Bloom filter \cite{b70}, count-min sketch \cite{c09}, hyperloglog \cite{ffgm07}, and so on. Among them, the Bloom filter mainly handles membership queries in big data \cite{b70}; count-min sketch handles the frequency of occurrence of a certain type of data in big data \cite{c09}; Hyperloglog is used to count the cardinality of a set of data, that is, the number of different elements in this set of data \cite{ffgm07}.


In this paper, we focus more on the Bloom filter \cite{b70}, which is a space-efficient probability data structure that deals with membership queries. Due to its efficient space utilization and low time complexity, it is widely used in various scenarios, especially industry scenarios requiring massive data processing and low-latency response capability. Classical scenarios include database systems and web-cache systems \cite{g82, ngp09, ml16, pnbs20}. 


In addition to the scenarios mentioned above, the Bloom filter is also used in various scenarios involving sensitive user data. 
One usage is the privacy-preserving dataset intersection: When two organizations want to find out what user data they have in common without revealing specific user information, Bloom filters can be used. By converting the respective user datasets into Bloom filters and then performing an intersection operation, common elements can be determined without exposing specific user records~\cite{b13, js11}. 
Another scenario is anonymous login: Bloom filters can store hash values of login credentials. When a user tries to log in, the system can check whether the hash of the credentials may exist in the filter instead of storing the actual password hash~\cite{lvd11, bcmp20}. 
Since the content inserted into the Bloom filter is user-sensitive, preventing attackers from reconstructing user-sensitive information from the released Bloom filter vector is an essential task.

In this work, we consider the differential privacy of the Bloom filter under the membership query scenario. 
The membership query problem involves storing information about a set of elements $S$ in a space-efficient manner to determine if an element $x$ is a member of $S$.
One example is the membership query application of the Bloom filter in streaming media recommendation~\cite{wzwl+14}, such as Tiktok. 
That is, the Bloom filter will be used for filtering to prevent users from being recommended duplicate content when using streaming media.
The Bloomfilter vector mentioned above will also be released to other businesses, such as advertising, e-commerce, etc. When the Bloomfilter vector is released, the user's privacy information, which videos the user has watched, needs to be well protected.

Thus, we introduce our DPBloomfilter (Algorithm~\ref{alg:init}) to protect the sensitive user information stored in the Bloomfilter vector, i.e. the $m$ index binary bits based on the hash values generated by $k$ different hash functions.
To implement a differential privacy budget, we used the classic random response technique \cite{w65} (Definition~\ref{def:random_response}
) in differential privacy, which randomly flips some bits to ensure that attackers cannot restore sensitive user data from neighboring datasets (Definition\ref{def:pre_neighbor_dataset}).
We theoretically show that our DPBloomfilter achieves $(\epsilon, \delta)$-DP guarantee, where the main technique is that we first ensure each bit holds a certain DP guarantee so that we achieve $(\epsilon, \delta)$-DP for the entire Bloom filter. 
Also, we have theoretically proved that our DPBloomfilter has high utility when  DP parameters are in a certain regime.
Furthermore, our empirical evidence verifies our utility analysis that our DPBloomfilter can procedure membership query services with high accuracy while protecting user data privacy.
While providing privacy guarantees, our algorithm preserves the same running complexity as the standard Bloom filter. 

Our contribution can be summarized as follows:
\begin{itemize}
    \item  To the best of our knowledge, this is the first work to provide DP for the Bloom filter for membership query problems.
    \item We have proved from a theoretical perspective that DPBloomfilter can achieve $(\epsilon, \delta)$-DP under the random response mechanism while preserving the same running time complexity compared with the standard Bloom filter.  
    \item We have proved from a theoretical perspective that when the DP parameters $\epsilon$ and $\delta$ are very small, DPBloomfilter can still maintain good utility. 
    \item Our simulation experiments also reflect the same effect as our theoretical results. The two confirm each other. 
\end{itemize}

{\bf Roadmap.} Our paper is organized as follows. In Section~\ref{sec:related_work}, we review related literature.
Section~\ref{sec:preliminary} presents the preliminary of Bloom Filter and  Differential Privacy. In Section~\ref{sec:main_result}, we outline the main results of our algorithm. 
In Section~\ref{sec:appendix_quantile_proof}, we elaborate the derivations for the closed-form distribution of the random variable $W$, where $N$ is the $1 - \delta$ quantile of $W$. 
Section~\ref{sec:appendix_privacy_guarantees} contains the proof of privacy guarantees for DPBloomfilter.
Section~\ref{sec:appendix_utility} presents a detailed analysis of utility guarantees for DPBloomfilter.
Section~\ref{sec:appendix_running_time} restates the analysis results of running time for DPBloomfilter.
Section~\ref{sec:discussion} elaborates on the underlying intuitions that informed the design of the DPBloomfilter.
In Section~\ref{sec:conclusion}, we conclude our paper.







