\section{Technical Overview}\label{sec:tech_overview}
In Section~\ref{sec:tec_privacy_sb}, we will provide the privacy guarantees of Single Bit in DPBloomfilter. Then, we will present the privacy guarantees of our entire algorithm in Section~\ref{sec:tec_privacy_dp}. In Section~\ref{sec:tec_utility_dp}, we will examine the utility guarantees of DPBloomfilter. Additionally, we include a remark that analyzes the trade-off between privacy and utility inherent in our approach. In Section~\ref{sec:tec_time_dp}, we discuss the running time of our algorithm.


\subsection{Privacy Guarantees of Single Bit}\label{sec:tec_privacy_sb}

To accomplish differential privacy, Algorithm~\ref{alg:init} applies a random response mechanism to each bit of the standard Bloom Filter. In this section, we aim to examine the privacy guarantees for a single bit of our algorithm.

Recall that in Definition~\ref{sec:pre_def_bf}, for dataset $A \subset [n]$, we use $g[j]$  to denote the $j$-th element of array output by standard Bloom Filter. Here, we use $\wh{g}[j]$ to denote the $j$-th element of array output by DPBloomfilter. Similarly, for any neighboring dataset $A' \subset [n]$, we use $g'[j]$ and $\wh{g}'[j]$ to denote the $j$-th element of array output by standard Bloom Filter and DPBloomfilter. 
To examine the privacy guarantees for the $i$-th bit, we must consider two distinct cases.

{\bf Case 1}. Suppose $g'[j] = g[j]$, then we can obtain (See also Lemma~\ref{lem:eps0_DP:formal}) that  for all $v \in \{0,1\}$, we have
\begin{align*}
    \frac{\Pr[\wt{g}[j]=v]}{\Pr[\wt{g}'[j]=v]} = 1.
\end{align*}

{\bf Case 2}. Suppose $g'[j] \neq g[j]$, then we can obtain (See also Lemma~\ref{lem:eps0_DP:formal}) that for all $v \in {0,1}$, we have
\begin{align*}
    e^{-\epsilon_{0}} \leq \frac{\Pr[\wt{g}[j]=v]}{\Pr[\wt{g}'[j]=v]} \leq e^{\epsilon_{0}}.
\end{align*}

By combining the above two cases, we can demonstrate the privacy guarantees of single bit for our algorithm.

\begin{lemma} [Differential Privacy for single Bit, informal version of Lemma~\ref{lem:eps0_DP:formal}] \label{lem:eps0_DP:informal}
Let $\epsilon_0 \geq 0$ and $\wt{g}[i] \in \{0,1\}$ be the $i$-th element of array output by DPBloomfilter. 
Then, we can show that, for all
$j \in [m]$, $\wt{g}[j]$ is $\epsilon_0$-DP. 
\end{lemma}



\subsection{Privacy Guarantees of DPBloomFilter}\label{sec:tec_privacy_dp}
Here, we comprehensively analyze the DP guarantees for our DPBloomFilter. Recall that in Definition~\ref{def:bloom_filter}, for dataset $A$, we use $g$ to denote the array output by standard Bloom Filter. Here, we use $\wt{g}$ to denote the array output by DPBloomfilter. Similarly, for any neighboring dataset $A'$, we use $g'$ and $\wh{g}'$ to denote the array output by standard Bloom Filter and DPBloomfilter, respectively.

Here, we consider the set of indices $j$ within the range $m$ where the value of $g[j]$ and $g'[j]$ differs.
\begin{align*}
    S := \{j \in [m] : g[j] \neq g'[j]\}.
\end{align*}
Thus, the set of indices $j$ where the value of $g[j]$ and $g'[j]$ are the same can be defined as
$
    \ov{S} := [m] \backslash S.
$
We can use the result of privacy guarantees of a single bit in Section~\ref{sec:tec_privacy_sb}, for any $j \in S$ and $v \in \{0,1\}$, we have
\begin{align*}
\frac{\Pr[\wt{g}[j]=v]}{\Pr[\wt{g}'[j]=v]}  = 1,
\end{align*}
and for any $j \in \ov{S}$ and $v \in \{0,1\}$, we have
\begin{align*}
e^{-\epsilon_{0}} \leq \frac{\Pr[\wt{g}[j]=v]}{\Pr[\wt{g}'[j]=v]} \leq e^{\epsilon_{0}}.
\end{align*}
By applying the composition lemma (refer to Lemma~\ref{lem:pre_com_lem}) , we obtain the following for any $Z \in \{0,1\}^m$,
\begin{align}\label{equ:epsilon_0_bound}
|\ln{\frac{\Pr[\wt{g} = Z]}{\Pr[\wt{g}' = Z]}}| \leq  |S|\epsilon_0.
\end{align}
Here, we define $W := |S|$ for convenience. To get a better bound for Equation~\ref{equ:epsilon_0_bound}, we need to calculate the probability distribution function of the random variable $W$. Before that, we need to define two random variables we will use. Firstly, we define $Y$ as the set of distinct values among the $k$ hash values generated by the standard Bloom filter considering one $x \in [n]$. Then we consider two data $x, x' \in [n]$. We define $Z$ as the set of distinct values in $Y_{x} \cup Y_{x'}$.

Then firstly we proceed to calculate the distribution of $|Y|$ (see details in Lemma~\ref{lem:distribution_of_Y}), we can show for any $y = 1,2,\dots,k$
\begin{align*}
    & ~ \Pr[|Y| = y] \\
    = & ~ 
    \begin{cases}
        1 / m^{k-1},  & y = 1 \\
        \binom{m}{y} \cdot y ^k / m^k
        - \sum_{i=1}^{k-1} \Pr[Y = i] \cdot \binom{m - i}{y -i}, & y = 2, \cdots , k
    \end{cases}
\end{align*}
Given the probability of $|Y|$, we can calculate the conditional probability of $|Z|$ conditioned on $|Y_{x}| = a$ and $|Y_{x'}| = b$, where $a,b \in [k]$ (see details in Lemma~\ref{lem:distribution_of_Z})
\begin{align*}
    \Pr[|Z| = z | |Y_x| = a, |Y_{x'}| = b] = \frac{A_m^a \cdot \binom{b}{t} \cdot A_{m - a}^t \cdot A_{a}^{b-t}}{A_m^a \cdot A_m^b}.
\end{align*}
Finally, we use the property of union probability. We can calculate the probability of $W$ (see details in Lemma~\ref{lem:distribution_of_W}). 
Fig.~\ref{fig:w_distribution} visualize the distribution of the random variable $W$ under the setting described in the experiments section (Section~\ref{sec:experiments}). It shows that the distribution of $W$ has a good concentration property, i.e., it concentrates on its mean.

Recall in Section~\ref{sec:pre_notations}, we use $F_{X}^{-1}$ to denote the $1-\delta$ quantile of the Cumulative Distribution Function $F_{X}(x)$ of random variable $X$. 

Here, we define
\begin{align*}
    N:= F_{W}^{-1}(1-\delta)
\end{align*}
Hence, by the properties of the quantile function, we have
\begin{align*}
    \Pr[N \leq W] = 1-\delta.
\end{align*}
By choosing the appropriate value of $\epsilon_0 = \epsilon/N$, we have
\begin{align*}
|\ln{\frac{\Pr[\wt{g} = Z]}{\Pr[\wt{g}' = Z]}}| \leq W\frac{\epsilon}{N}.
\end{align*}
Then we have, with probability $1-\delta$,
\begin{align*}
    |\ln{\frac{\Pr[\wt{g} = Z]}{\Pr[\wt{g}' = Z]}}| \leq \epsilon.
\end{align*}
Then, we can demonstrate the privacy guarantees for DPBloomfilter (see also Theorem~\ref{thm:query_privacy:informal}).



\subsection{Utility Guarantees of DPBloomfilter}\label{sec:tec_utility_dp}
This section will present a comprehensive analysis of the utility guarantees for DPBloomfilter.
We start by introducing the following conditions for the Utility guarantee of DPBloomFilter.
\begin{condition} \label{con:utility_condition}
We need the following conditions for Utility guarantees of DPBloomfilter:
\begin{itemize}
    \item \textbf{Condition 1.} Assume that a hash function selects each array position with equal probability.
    \item \textbf{Condition 2.} Let $z \in \{0,1\}$ denote the ground truth for whether an element $y \in A$.
    \item \textbf{Condition 3.} Let $\wh{z} \in \{0,1\}$ denote the answer output by standard Bloom Filter for whether an element $y \in A$.
    \item \textbf{Condition 4.} Let $\wt{z} \in \{0,1\}$ denote the answer output by DPBloomfilter for whether an element $y \in A$
    \item \textbf{Condition 5.} Let $\alpha:=\Pr[z=0] \in [0,1]$
    \item \textbf{Condition 6.} Let $t := e^{\epsilon_0} / (e^{\epsilon_0} + 1)$. 
\end{itemize}
    
\end{condition}

Firstly, we proceed to derive the utility of the standard Bloom Filter by calculating 
\begin{align*}
    \Pr[\wh{z} = z] = 1 - \Pr[\wh{z} = 1 | z = 0] \Pr[z=0].
\end{align*}
The above equation comes from the fact that Bloom Filter will not introduce a false negative. After the initialization process of Bloom Filter, the probability of one certain bit is not set to $1$ is (see also Lemma~\ref{lem:bloom_true_accuracy:formal})
\begin{align*}
    (1-\frac{1}{m})^{|A|k} \geq e^{-2|A|k/m}.
\end{align*}
A false positive occurs when, for all $i \in [k]$, the elements $g[h_i(y)]$ are all set to $1$ after initialization. In this case, we have:
\begin{align*}
    \Pr[\wh{z} = 1 | z = 0] = & ~( 1 - (1 - \frac{1}{m})^{|A|k})^k \leq  ~ (1 - e^{-2|A|k/m})^k.
\end{align*}
Therefore, we have
\begin{align*}
    \Pr[\wh{z} = z] \geq & ~ 1 - (1 - e^{-2|A|k/m})^{k} \alpha.
\end{align*}
Further if $m = \Omega(|A|k)$ and $k = \Theta(log(\alpha/\delta_{err}))$, we have
\begin{align*}
    \Pr[\wh{z} = z] = 1 - \delta_{\mathrm{err}} \cdot \alpha.
\end{align*}
\begin{lemma} [Accuracy for query of Standard Bloom filter, informal version of Lemma~\ref{lem:bloom_true_accuracy:formal}]\label{lem:bloom_true_accuracy:informal}
If Condition~\ref{con:utility_condition} holds, we have
\begin{align*}
    \Pr [ \wh{z} = z ] \geq 1 - (1 - e^{-2|A| k / m})^k \cdot \alpha.
\end{align*}
Further if $m = \Omega(|A| k)$ and $k = \Theta(\log(1/\delta_{err}))$, we have
\begin{align*}
     \Pr [ \wh{z} = z ] \geq 1 - \delta_{\mathrm{err}} \cdot \alpha.
\end{align*}
\end{lemma}

We then quantify the error introduced by applying the random response mechanism in the DPBloomfilter by calculating $\Pr[\wt{z} = \wh{z}]$. Using basic probability rules, we have
\begin{align*}
    \Pr[\wt{z} = \wh{z}] = & ~ \Pr[\wt{z}=1|\wh{z}=1]\Pr[\wh{z}=1] \\
    & ~ +\Pr[\wt{z}=0|\wh{z}=0]\Pr[\wh{z}=0].
\end{align*}

We can compute the following term by using the definition of DPBloomfilter in Algorithm~\ref{alg:init}  (see details in Lemma~\ref{lem:dpbloom_bloom_accuracy:formal})
\begin{align*}
    \Pr[\wt{z}=1|\wh{z}=1] = & ~ (\frac{e^{\epsilon_0}}{e^{\epsilon_0}+1})^k, \\
     \Pr[\wt{z}=0|\wh{z}=0] \geq & ~ \frac{e^{\epsilon_0}}{e^{\epsilon_0}+1}.
\end{align*}
Here we let $\Pr[\wh{z}=0] = \wh{\alpha}$, note that $\wh{\alpha} = \alpha (1 - \delta_{\mathrm{err}})$. Hence, $\Pr[\wh{z} = 1] = 1 - \Pr[\wh{z}=0] = 1 - \alpha + \alpha \cdot \delta_{err}$. Then we will have (see details in Lemma~\ref{lem:dpbloom_bloom_accuracy:formal})
\begin{align*}
    \Pr[\wh{z} = z] \geq t \cdot \alpha \cdot (1 - \delta_{err}).
\end{align*}

\begin{lemma}[Accuracy (compare DPBloomFilter with Bloom) for Query, informal version of Lemma~\ref{lem:dpbloom_bloom_accuracy:formal}]\label{lem:dpbloom_bloom_accuracy:informal}
If Condition~\ref{con:utility_condition} holds, we can show
Then, we can show
\begin{align*}
\Pr[ \wt{z} = \wh{z}] \geq t \cdot \alpha \cdot (1 - \delta_{err}).
\end{align*}
\end{lemma}
Now, we can proceed to examine the utility guarantees of DPBloomfilter by calculating $\Pr[\wt{z} = z]$, i.e., comparing the output of DPBloomfilter with the ground truth for the query. 
By combining the result of the analysis above, we will have (see more details in Theorem~\ref{thm:dpbloom_true_accuracy:formal})
\begin{align*}
    \Pr[ \wt{z} = z ] \geq \alpha \cdot (1-t-t^k)\cdot \delta_{\mathrm{err}}+\alpha\cdot t. 
\end{align*}
Then, we have demonstrated the utility guarantees of our algorithm while simultaneously ensuring privacy (see Theorem~\ref{thm:dpbloom_true_accuracy:informal}).


Similar to other differential privacy algorithms, our algorithm encounters a trade-off between privacy and utility, where increased privacy typically results in a reduction in utility, and conversely. An in-depth examination of this trade-off is provided as follows.

\begin{remark} [Trade-off between Privacy and Utility of DPBloomfilter]
An inherent trade-off exists between the privacy and utility guarantees of our algorithm. To ensure privacy, we must lower the value of $\epsilon_0$ in Theorem~\ref{thm:query_privacy:informal}. On the other hand, for utility considerations (in Theorem~\ref{thm:dpbloom_true_accuracy:informal}), we define the lower bound of $\Pr[\wt{z} = z]$ as $u = \alpha(1-t-t^k)\delta_{\mathrm{err}}+\alpha t$
, a reduction in $\epsilon_0$ will lead to a reduction in $t$ then finally result in a reduction in $u$. This, in turn, leads to diminished utility.
\end{remark}

\subsection{Running Time of DPBloomfilter}\label{sec:tec_time_dp}
In this section, we will analyze the running time of our DPBloomfilter. 
Recall in Definition~\ref{def:bloom_filter}, we let $\mathcal{T}_{h}$ denote the computation time per execution for all hash functions. To analyze the algorithm's running time, firstly, we consider the running time of initialization in Algorithm~\ref{alg:init}. It contains two steps as follows

\textbf{Step 1.} Let's consider the initialization of the standard Bloom Filter. For a single element $x \in A$, it needs $O(k\cdot \mathcal{T}_h)$ time to compute over $k$ hash functions. And $|A|$ elements need to be inserted. Combining these two facts, it needs $|A|\cdot k \cdot \mathcal{T}_h$ time to initialize the standard Bloom Filter.

\textbf{Step 2.} Let's consider the ``Flip each bit'' part in DPBloomfilter. Since there are $m$ bits in the Bloom Filter, it takes $O(m)$ time to flip each bit.

Hence, it takes $O(|A|\cdot k \cdot \mathcal{T}_{h}+m)$ time to run the initialization function in Algorithm~\ref{alg:init}. (see also in Lemma~\ref{lem:init_time})

Then we consider the running time of a single query in Algorithm~\ref{alg:init}. For each query $y$, the algorithm needs $O(k \cdot \mathcal{T}_{h})$ time to compute the hash values of $y$ over $k$ hash functions. Hence, it takes $O(k \cdot \mathcal{T}_{h})$ time to run each query $y$ in. (see also in Lemma~\ref{lem:query_time})

By combining the two running time together, we can obtain the running time of our entire algorithm is $O(|A|\cdot k \cdot \mathcal{T}_{h}+m)$. This highlights the advantage of our algorithm: it matches the time complexity of a standard Bloom Filter while providing a strong privacy guarantee.

