\section{Introduction}

Many emerging applications within important domains, such as healthcare and the Internet of Things (IoT), have extremely stringent energy requirements.
At the same time, it is typically not economically viable to create special-purpose ASICs for each type of application.
Developers are hence forced to use ultra-low-power (ULP) processors in these systems, but the active power consumption of most commercial ULP devices is still measured in milliwatts and hence falls short in many deployments. Biomedical applications~\cite{chen_injectable_2015}, for example, require power consumption at the level of microwatts or below.

It is well known that reducing the supply voltage into the subthreshold region yields energy-minimal operation for a given design~\cite{weak-inversion:JSSC1997, Tsiv}, but it is yet not clear how to design energy efficient microcontrollers for subthreshold operation.
% Non-conventional ISA
Zhai et al.~\cite{subVt-mcu:TVLSI2009} evaluate energy-efficient subthreshold processor designs, but a key part of their study is the design of the instruction set architecture (ISA) itself.
While designing a new ISA enables optimizations for the target application domain, e.g., specialized registers and a low-precision arithmetic unit (ALU), it also incurs two significant drawbacks.
First, special-purpose ISAs lack a software ecosystem, but Arm and RISC-V have demonstrated that a thriving software ecosystem is a key enabler of commercial success. 
Second, special-purpose ISAs are potentially over-constrained and therefore only efficient for a few applications. 
This significantly reduces the reuse benefits that make general-purpose microcontrollers cost-effective.

%Conventional ISA
In contrast, basing the processor design on a standard ISA, such as Arm or RISC-V, enables tapping into a software ecosystem of widely used and industry-proven compilers, libraries, and operating systems, and such ISAs are designed for flexibility, which makes them efficient for a wide range of applications.
Examples of prior work on subthreshold microcontrollers with a standard ISA, e.g., Zscale~\cite{zscale:ESSCIRC2018} (RISC-V), SleepRunner~\cite{sleeprunner:JSSC2021} (ARM) and Bottle Rocket~\cite{10409181} (RISC-V), focus on evaluating a single microcontroller and therefore do not shed light on the key trade-offs of subthreshold microcontroller design.
Furthermore, each implementation is evaluated in a different process technology, making it challenging to extract generic conclusions from the various works.
Conti et al.~\cite{schiavone:PATMOS2017} evaluates three RISC-V microcontroller designs, but use a standard cell library with a nominal supply voltage of 1.2\,V and only report results for supply voltages down to 0.8\,V (which is far above the subthreshold region).

% Goal
Our goal in this paper is to fill this knowledge gap in the design of subthreshold standard-ISA microcontrollers.
More specifically, we want to understand how to design the microarchitecture of standard-ISA microcontrollers to maximize energy efficiency when targeting subthreshold operation.
% Subthreshold library
Since commercial subthreshold standard cell libraries are not available\footnote{Commercial subthreshold microcontrollers exist, e.g., Ambiq's SPOT-enabled devices~\cite{ambiq-spot}, but, to the best of our knowledge, no commercial subthreshold cell library is available.}, we designed our own library for a commercially available 130\,nm process technology node (\autoref{sec:bowilib}); this is a commonly used technology node for microcontrollers.
We have characterized the cell library and verified functional correctness using simulations at supply voltages between 250 and 400\,mV.

% Cores
We use our subthreshold library to evaluate several open-source RISC-V cores that exhibit a wide range of microarchitectural features (\autoref{sec:cores}).
% Multi-cycle
SERV~\cite{serv:GITHUB}, QERV~\cite{serv:GITHUB}, and PicoRV32~\cite{picorv32:GITHUB} represent multi-cycle architectures, meaning that (1)~a single instruction is executed at a time, and (2)~each instruction takes multiple cycles to execute.
SERV implements a bit-serial ALU, which yields low area at the cost of increased instruction latency, while the QERV operates on four bits at a time, which increases area but significantly lowers latency compared to SERV.
PicoRV32 is a more conventional multi-cycle core with a standard bit-parallel ALU.
% Pipelined
Ibex~\cite{ibex:GITHUB}, Vex~\cite{vexriscv:GITHUB}, and Rocket~\cite{rocket} represent pipelined architectures, which means that multiple instructions overlap and are executed in parallel.
Ibex and Vex-2\footnote{The pipeline depth of the Vex core is configurable and Vex-2 represents a 2-stage pipeline while Vex-5 represents a 5-stage pipeline.} represent shallow pipelines with two stages while the Rocket and Vex-5 represent deeper pipelines with five stages.
% Generic RV32E configuration
All cores implement the RV32E ISA, which is the minimal RISC-V ISA with only 16 registers and no hardware support for multiplication, division, or floating-point.
% Experimental setup
Each core is taken through synthesis, place and route, and parasitic extraction using an industrial-grade tool flow, 
%(\autoref{sec:experimental-setup}), 
and evaluated in the subthreshold region at 300\,mV, which is close to the energy-optimal supply voltage for our cell library (\autoref{sec:experimental-setup}).

% Benchmarks
We use eight benchmarks from MachSuite~\cite{machsuite:IISWC2014} to evaluate performance and energy efficiency; our energy efficiency metric is energy per instruction (EPI).
% Results
We find that Vex-2 yields the lowest EPI due to two main reasons:
\textit{First}, multi-cycle SERV, QERV, and PicoRV32 use (many) more cycles per instruction (CPI) compared to Vex-2.
Therefore, their low power consumption does not compensate for their long runtime.
\textit{Second}, for the deeply pipelined Vex-5 and Rocket, the additional buffers inserted during synthesis to enable subthreshold operation means that the clock cycle time does not decrease enough compared to Vex-2 to compensate for the increase in CPI caused by the deeper pipeline.
They hence yield similar performance to Vex-2 but with increased power consumption.
We further study EPI in the context of runtime, power, and area constraints and find that other cores than Vex-2 can be Pareto optimal.
For example, Vex-5 yields (slightly) lower runtime than Vex-2, and the multi-cycle SERV and QERV are Pareto optimal when power or area is (significantly) constrained.
