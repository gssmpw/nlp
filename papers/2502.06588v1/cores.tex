\section{The RISC-V Cores}
\label{sec:cores}

\begin{figure}[t]
    \centering
    \begin{subfigure}[b]{\columnwidth}
         \centering
         \includegraphics[width=0.8\linewidth]{microarch-multi-cycle.pdf}
         \caption{Multi-cycle architecture.}
         \label{fig:microarch-multi-cycle}
     \end{subfigure}
     
     \begin{subfigure}[b]{0.70\columnwidth}
         \centering
         \includegraphics[width=\linewidth]{microarch-2stage.pdf}
         \caption{2-stage pipelined architecture.}
         \label{fig:microarch-two-stage}
     \end{subfigure}
     
     \begin{subfigure}[b]{0.8\columnwidth}
         \centering
         \includegraphics[width=\linewidth]{microarch-5stage.pdf}
         \caption{5-stage pipelined architecture.}
         \label{fig:microarch-five-stage}
     \end{subfigure}
    
    \caption{Ultra-low-power processor microarchitecture design options. {\it SERV, QERV, and PicoRV32 are multi-cycle architectures (a),  Ibex and Vex-2 are 2-stage pipelined architectures (b), and Vex-5 and Rocket are 5-stage pipelined architectures (c).}}
    \label{fig:microarch}
\end{figure}

We evaluate the SERV~\cite{serv:GITHUB}, QERV~\cite{serv:GITHUB}, PicoRV32~\cite{picorv32:GITHUB}, Ibex~\cite{ibex:GITHUB}, Vex~\cite{vexriscv:GITHUB}, and Rocket~\cite{rocket} 32-bit RISC-V cores, and we will now explain their microarchitectures in more detail. In all of these cores, instruction execution can be broken down into five key steps which the core must be able to perform to execute all RISC-V instructions. The core (1) fetches the instruction from memory, (2) decodes the instruction and retrieves its operands from the register file, and (3) performs the ALU-operation(s) the instruction requires. For load and store instructions, the ALU is used to compute the memory address, which in turn enables accessing memory (4).
In step (5), the core writes the output of the instruction to the register file (if the instruction produces output).
While all the cores we consider perform these five steps, \autoref{fig:microarch} illustrates that the manner in which they implement them varies widely. 

SERV, QERV, and PicoRV32 are all multi-cycle architectures, which means that an instruction is executed to completion over multiple clock cycles before the execution of the next instruction is initiated, i.e., there is only a single instruction in the datapath at any given time (see \autoref{fig:microarch-multi-cycle}).
This simplifies the control unit as the causes for hazards are significantly reduced and eliminates the need for forwarding logic, resulting in reduced area at the cost of lower performance.
SERV and QERV reduce area further by implementing an iterative ALU.
SERV takes this to the extreme by implementing a bit-serial ALU where a single bit of the final result is produced per cycle, resulting in a 32-cycle ALU latency. 
QERV trades latency against area by implementing a 4-bit wide (or quaternary) ALU, resulting in an 8-cycle ALU latency.
In comparison, the fully bit-parallel ALU of the PicoRV32 has a single-cycle latency.

The key alternative to a multi-cycle architecture is a pipelined architecture, which exploits instruction-level parallelism to execute parts of instructions in parallel. \autoref{fig:microarch-two-stage} and \ref{fig:microarch-five-stage} illustrate that this is enabled by separating (some of) the datapath units by pipeline registers.
Ibex and Vex-2 have a two-stage pipeline (see \autoref{fig:microarch-two-stage}), while Vex-5 and Rocket both have 5-stage pipelines (see \autoref{fig:microarch-five-stage}).
The pipeline registers enable Vex-2 and Ibex to fetch and decode one instruction in parallel with executing, accessing memory, and writing back the results of a different instruction. Vex-5 and Rocket on the other hand can work on up to five instructions in parallel.
At nominal supply voltage, deepening the pipeline makes it possible to increase the clock frequency and thereby performance --- because the amount of work that needs to be completed in a single clock cycle decreases when the number of stages increases --- but this comes at the cost of increased area and complexity --- because dependencies between instructions result in hazards that the core must handle such that the application executes correctly.
