\section{Results}

\begin{table}[tp]
  \centering
  \caption{Averages across all benchmarks.}
  %Runtime is normalized to Vex-2. }
  \begin{tabular}{l|r|r|r|r}
    Core           & CPI   & Runtime & Power             & EPI \\
    \hline
    \hline
    SERV           & 57.94 & 14.68   &  2.85\,\textmu W  & 78.74\,pJ \\
    QERV           & 18.16 & 4.93    &  3.46\,\textmu W  & 32.18\,pJ \\
    PicoRV32       &  5.36 & 1.95    &  5.37\,\textmu W  & 19.74\,pJ \\
    Vex-2          &  1.29 & 1.00    &  3.73\,\textmu W  & 7.04\,pJ \\
    Ibex           &  1.59 & 1.22    &  6.13\,\textmu W  & 14.10\,pJ \\
    Vex-5          &  1.72 & 0.91    &  9.17\,\textmu W  & 15.76\,pJ \\
    Rocket         &  1.71 & 1.30    & 10.08\,\textmu W  & 24.72\,pJ \\
    \hline
    Vex-2 (1.2\,V) &  1.29 & 0.0112  &  2 324\,\textmu W & 49.20\,pJ \\
    Vex-5 (1.2\,V) &  1.72 & 0.0037  & 17 671\,\textmu W & 124.78\,pJ \\
  \end{tabular}
  \label{tab:results_summary}
\end{table}

A summary of the results is found in \autoref{tab:results_summary}; runtime is normalized to Vex-2.  Vex-2 is clearly the most energy efficient core, having an EPI of only 7\,pJ.  SERV is the most power efficient core with an average power of 2.85\,\textmu W, while Vex-5 is the fastest among the subthreshold cores.

\begin{figure*}[t]
  \centering
\begin{subfigure}{0.32\textwidth}
  \centering
  \includegraphics[width=\textwidth]{power_subvth.pdf}
  \caption{Average power (subthreshold cores).}
  \label{fig:power_subvth}
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
  \centering
  \includegraphics[width=\textwidth]{runtime.pdf}
  \caption{Execution time (subthreshold cores).}
  \label{fig:runtime}
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
  \centering
  \includegraphics[width=\textwidth]{epi.pdf}
  \caption{EPI (all cores).}
  \label{fig:epi}
\end{subfigure}
  \caption{Power consumption, execution time, and Energy Per Instruction (EPI) across benchmarks and cores.}
  \label{fig:power_runtime_epi}
\end{figure*}

\begin{figure*}[t]
  \centering
\begin{subfigure}{0.32\textwidth}
  \centering
  \includegraphics[width=\textwidth]{runtime-vs-epi.pdf}
  \caption{Runtime versus energy efficiency.}
  \label{fig:runtim-vs-epi}
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
  \centering
  \includegraphics[width=\textwidth]{power-vs-epi.pdf}
  \caption{Power versus energy efficiency.}
  \label{fig:power-vs-epi}
\end{subfigure}
\hfill
\begin{subfigure}{0.32\textwidth}
  \centering
  \includegraphics[width=\textwidth]{area-vs-epi.pdf}
  \caption{Area versus energy efficiency.}
  \label{fig:area-vs-epi}
\end{subfigure}
  \caption{Pareto-optimal designs when optimizing for energy efficiency (EPI) and runtime (a), power (b), or area (c).}
  \label{fig:pareto}
\end{figure*}


\subsection{Power, Performance, and Energy Efficiency}
\label{subsec:power-perf-energy}

\noindent
\textbf{Power.}
\autoref{fig:power_subvth} shows power for the subthreshold cores.  The horizontal axis shows benchmark runs for each core, grouped by benchmark.  Cores are ordered by their size in number of transistors.  The vertical axis is average power.
As can be seen, power is quite constant across the different benchmarks.  Power is also correlated with area, so the smallest core, SERV, is also the most power efficient.
PicoRV32 has almost the same power consumption as the two-stage Ibex, while Vex-2 has a significantly lower power consumption than both PicoRV32 and Ibex.
Deeper pipelines clearly result in higher power consumption, as shown for the 5-stage Vex-5 and Rocket cores.

\autoref{tab:results_summary} reports average power consumption over all the benchmarks for both the subthreshold cores and the 1.2\,V cores; The 1.2\,V cores are three orders of magnitude more power hungry than the subthreshold cores (mW instead of $\mu$W).

\noindent
\textbf{Performance.}
Execution time is shown in \autoref{fig:runtime}.  The horizontal axis shows benchmark runs for each core and is ordered the same way as in \autoref{fig:power_subvth}.  The vertical axis is execution time, normalized to Vex-2.  
There are significant differences, with SERV being 15$\times$ slower than Vex-2.
QERV has a 4-bit wide ALU and achieves 3$\times$ better performance than the bit-serial SERV.
In general, all the multi-cycle cores are slow because of their low average CPI (cycles per instruction).
Average CPI is shown in \autoref{tab:results_summary}.

The pipelined cores have longer clock periods than the multi-cycle cores (see \autoref{tab:PRcores}).
Nevertheless, the pipelined cores are much faster than the multi-cycle cores because they all have a CPI close to one. At 300\,mV, Vex-2 improves performance by 15$\times$ and 5$\times$ compared to SERV and QERV, respectively, whereas Ibex yields performance improvements of 12$\times$ and 4$\times$.  Even though both Vex-2 and Ibex are 2-stage cores, they differ in their CPI.  This is due to Ibex stalling one cycle for every load and store instruction~\cite{ibex_pipeline}, resulting in a 23\% increase in average CPI compared to Vex-2. 
Vex-5 is the fastest core because of a relatively low CPI and the lowest clock period, and is on average 9\% faster than Vex-2.  Vex-2 is the second-fastest core and has the lowest CPI.

Table~\ref{tab:results_summary} shows that the 1.2\,V cores are two orders of magnitude faster than the subthreshold cores, resulting in Vex-5 (1.2\,V) being the overall fastest core. 

\begin{table*}[tp]
  \centering
  \caption{Instance count and timing for the critical path.}
  \resizebox{\textwidth}{!}{
  \begin{tabular}{l|r|r|r|r|r|r|r|r|r|r|r|r|r|r}
                     & \multicolumn{2}{c|}{Total} & \multicolumn{3}{c|}{Buffers} & \multicolumn{3}{c|}{Inverters} & \multicolumn{3}{c|}{Comb.} & \multicolumn{3}{c}{Flip-flops} \\
                     & Count & Delay & Count & \multicolumn{2}{c|}{Delay} & Count & \multicolumn{2}{c|}{Delay} & Count & \multicolumn{2}{c|}{Delay} & Count & \multicolumn{2}{c}{Delay} \\
    \hline
    \hline
    Vex-2	&91	&1398,75	&22	&447,36	&31,98\%	&21	&240,08	&17,16\%	&47	&668,64	&47,80\%	&1	&42,67	&3,05\%\\
    Vex-5	&47	&968,1	&31	&705,36	&72,86\%	&6	&95,1	&9,82\%	&9	&115,53	&11,93\%	&1	&52,11	&5,38\%\\
    Vex-2 (1.2\,V)	&90	&16,14	&1	&0,19	&1,18\%	&5	&0,72	&4,46\%	&83	&15,04	&93,18\%	&1	&0,19	&1,18\%\\
    Vex-5 (1.2\,V)	&33	&3,86	&0	&0	&0,00\%	&5	&0,61	&15,80\%	&27	&3,08	&79,79\%	&1	&0,17	&4,40\%\\
  \end{tabular}
  }
  \label{tab:critical_path}
\end{table*}

\begin{table}[tp]
  \centering
  \caption{Area breakdown.}
  \begin{tabular}{l|r|r|r|r}
    Core         & Buffers & Inverters & Comb.  & Flip-flops   \\
    \hline
    \hline
    Vex-2        & 31.5\%  & 11.5\%    & 33.8\% & 23.2\% \\
    Vex-5        & 34.5\%  & 10.0\%    & 29.5\% & 26.0\% \\
    \hline
    Vex-2 (1.2\,V) &  0.1\%  &  8.7\%    & 56.3\% & 34.4\% \\
    Vex-5 (1.2\,V) &  0.0\%  &  8.1\%    & 52.7\% & 38.7\% \\
  \end{tabular}
  \label{tab:area}
\end{table}

\noindent
\textbf{Energy per instruction.}
Our energy efficiency metric is energy per instruction (EPI), and \autoref{fig:epi} shows EPI for all benchmarks.  The horizontal axis shows benchmark runs for each core, ordered the same way as in Figures \ref{fig:power_subvth} and \ref{fig:runtime}.  The vertical axis is EPI, where a core with a lower number means a more energy efficient core.

Vex-2 is clearly the most energy efficient core for all benchmarks, with an average EPI of 7\,pJ.  This is both a result of its low power consumption, seen in \autoref{fig:power_subvth}, and its low execution time, seen in \autoref{fig:runtime}.  SERV is the least energy efficient core (excluding the 1.2\,V cores) with an EPI of 79\,pJ, which is 11$\times$ larger than the EPI of Vex-2.  Even though SERV is the core with the lowest power consumption (\autoref{fig:power_subvth}), its high execution time (\autoref{fig:runtime}) makes it more energy-hungry than all the other subthreshold cores. 
At 1.2\,V, Vex-2 and Vex-5 have 7--8$\times$ the EPI of their subthreshold equivalents, i.e., they are roughly one order of magnitude less energy efficient. This observation is in line with prior work~\cite{6359800,Beiu}. The massive difference in energy efficiency results in Vex-5 (1.2\,V) being the least energy efficient core in our evaluation (EPI of 125\,pJ).


\noindent
\textbf{Pareto-optimal design points.}
When designing for ultra-energy-efficient devices, multiple design constraints often have to be balanced against each other.
Such devices are commonly mass-produced, and low price (small area) is usually a competitive advantage.  They are also often powered by energy harvesting, which enforce power consumption limitations, while still requiring to be performant.
\autoref{fig:pareto} shows the evaluated cores when energy efficiency (EPI) is plotted against runtime~(a), power~(b), and area~(c).
The figures show that Vex-2 is a Pareto-optimal design for all three cases, with Vex-5 being Pareto optimal if a faster core is required (9\%), but at a 2.2$\times$ reduction in energy efficiency and 1.7$\times$ increase in area.
For power and area constrained devices, we find that SERV and QERV are Pareto optimal.
Their bit/quaternary-serial operation reduces their area by more than 2$\times$ compared to Vex-2, which also results in lower power consumption at 24\% and 6\%, respectively.
Their main drawback is the increased runtime at 15$\times$ and 5$\times$, which results in lower energy efficiency at 11$\times$ and 5$\times$ compared to Vex-2, respectively.
PicoRV32 is Pareto optimal in terms of area, with a 6\% decrease at a cost of 2.8$\times$ reduction in energy efficiency compared to Vex-2.
Ibex and Rocket are found to \emph{not} be Pareto optimal.


\subsection{Pipelining for Ultra-Low-Power Cores}

The Vex-2 and Vex-5 cores are constructed from the same source code, only with different configurations.
This makes them suitable for studying how the number of pipeline stages affect runtime, power, energy, and area.
Pipelining improves execution time by splitting the critical path with a pipeline register, thus increasing clock frequency. 
Extra registers and pipelining logic leads to an increase in area of approximately 1.7$\times$ when going from a 2 to 5 stages. 
As shown in \autoref{tab:PRcores}, at 1.2\,V we achieve a clock frequency that is almost 4$\times$ faster when going from a 2-stage to a 5-stage pipeline.
In subthreshold, the clock frequency is only 1.5$\times$ faster.
As the CPI also increases when going to five stages, there is only a 9\% improvement in execution time when using a 5-stage pipeline in subthreshold, which makes pipelining much less attractive in subthreshold compared to 1.2\,V. 

In order to understand why pipelining the subthreshold Vex does not experience the same benefits as the standard supply voltage Vex, we investigated the critical paths of the different Vex cores.  \autoref{tab:critical_path} shows which cells constitute the critical paths of the different cores. 
We see that for Vex-2 in subthreshold, buffers contribute to 32\% of the delay of the critical path.
Only 48\% of the delay is due to combinatorial cells, i.e., the cells that implement the logic functions.
For Vex-2 at 1.2\,V, the buffers only contribute to 1.2\% of the total delay, while combinatorial cells contribute 93\%.
This demonstrates the main difference between the subthreshold cores and the 1.2\,V cores: The subthreshold cores have much higher buffer requirements.  Due to its low current levels, subthreshold circuits are much more penalized by long wires that load the subthreshold gates and increase delays substantially.  This forces the EDA flow to insert buffers to meet timing requirements.  Relaxing the timing requirements would get rid of the buffers, but the clock frequency would then drop to such a degree that energy efficiency would decrease.  This changes the effect pipelining has in subthreshold. 
Comparing Vex-5 to Vex-2 in \autoref{tab:critical_path} shows that pipelining to a large degree reduces the number of combinatorial gates, but not the buffers.  The critical path of Vex-5 in subthreshold has 73\% of its total delay spent on buffers, while only 12\% is spent on combinatorial cells.  At 1.2\,V the situation is very different; there are no buffers in the critical path. 
Increased buffering is seen all over the core.  \autoref{tab:area} shows which cells are contributing to the area of the cores.  In subthreshold, buffers take up 31.5\% of the area of the Vex-2 core, while they are almost nonexistent in the 1.2\,V core.  When introducing pipelining to the subthreshold core, the proportion of buffers increases to 34.5\% because of the larger area requiring longer wires. 

When looking at energy efficiency, deeper pipelines are even less attractive.
Evident from \autoref{fig:epi} and \autoref{tab:results_summary}, the 5-stage Vex core is less energy efficient than the 2-stage Vex core.
Even though the clock period (and therefore also the execution time) decreases for the 5-stage core, the power increases to such a degree that the 5-stage core ends up being much less energy efficient.
This is the case for both subthreshold and nominal voltages.
The power increases 7.6$\times$ at 1.2\,V and 2.5$\times$ at subthreshold.
Some of this increase in power is due to larger area, and some of it is due to higher switching activity.
Leakage is a major component of the average power in subthreshold, but almost insignificant at nominal voltage.
This means that the power of the subthreshold 5-stage core is less affected by high switching activity than for nominal voltages, and the power and energy penalty is not as high.
However, as the improvement in execution time is so slight, there are seemingly no good reasons for using a 5-stage pipeline RISC-V core when designing for subthreshold operation.  
