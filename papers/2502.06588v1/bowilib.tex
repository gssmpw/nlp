\section{Custom Subthreshold Library}
\label{sec:bowilib}

This paper uses a commercially available 130\,nm process for which the nominal supply voltage is 1.2\,V and the absolute values of the threshold voltages are around 350\,mV.  A standard cell library in this 130 nm technology for a supply voltage of 1.2 V is available, but not optimized, nor characterized for supply voltages below 1.08\,V.
Lack of characterization means that the standard library can not be used by EDA tools below 1.08\,V.
Even if the library was characterized for other voltages, the lack of optimization for subthreshold operation likely makes the library perform suboptimally at ultra-low voltages~\cite{937856}.

We have developed a custom cell library to perform the experiments in this paper.
This section goes through the design of this library and explains design choices affecting subthreshold operation, in addition to details on verification of the library.
\subsection{Cell Selection}

\begin{table}[t]
  \centering
  \caption{Custom cell library.}
  \begin{tabular}[tp]{l|l}
    Type & Cell \\
    \hline
    \hline
    Basic gates & INV\_X\{1,2,5,10,20,40,80,160,320\}, \\
                & NAND\_X\{1,2,5,10\}, NOR\_X\{1,5,10\}, \\
                & XOR\_X5, XNOR\_X5, AOI\_X5, OAI\_X5 \\

    Buffers & BUF\_X\{2,5,10,20,40,80,160,320\}, DLY\_X\{4,8\} \\

    Latches & DLATCH\_X5 \\

    Flipflops & DFF\_X5, DFF\_SET\_X10, DFF\_RESET\_X10 \\

    Complex cells & FA\_X5, MUX\_X2 \\
  \end{tabular}
  \label{tab:bowilib}
\end{table}

\autoref{tab:bowilib} describes our custom cell library.
While more cells typically improve the efficiency of the synthesized circuit, subthreshold cell libraries with relatively few cells are not uncommon,
e.g., only four basic cells were used in~\cite{7062968}. A likely reason is that adding more cells incurs an engineering overhead.
We therefore include some additional commonly used cell types to improve efficiency, but keep the overall number of cells low to reduce engineering overhead.

The conventional 130\,nm standard cell library contains many logic gates with high fan-in.
Noise margins are worse in subthreshold~\cite{bol2011robust} because it gets more difficult to achieve logic gate outputs close to either $V_{DD}$ or $V_{SS}$.
The transistor can be viewed as a voltage-controlled resistor, and in subthreshold the difference in resistance between a (somewhat) conducting state and a (mostly) non-conducting state is lower than for conventional supply voltages.
Combined with high loads on logic gate outputs, the output voltages may get degraded or take long to settle.
This makes it important to keep a low number of transistors in series between a logic gate output and either $V_{DD}$ or $V_{SS}$~\cite{calhoun2005modeling}, dictating a low fan-in.  We limit the logic gates in our library to a maximum of two transistors separating cell output from either $V_{DD}$ or $V_{SS}$, resulting in mostly 2-input gates.
The FA cell is a conventional 28T full adder~\cite{full-adder:ISSCC1990} and has three transistors in series, but not on the output which is driven by an inverter that restores internal signals. 


\subsection{Transistor Sizing}

Logic gates, if designed such that all transistors have the same size, will likely exhibit an imbalance with respect to rise and fall times.  
This is unfortunate as it will negatively affect both switching speeds and power.  A key target when choosing the transistor sizes of a cell is, therefore, to aim for a balance between the nMOS and pMOS networks for the relevant supply voltages and operating temperatures.

We choose transistor sizes based on simulations of toggle times.  A simulation setup is created for each logic gate such that the gate inputs can be toggled independently.
The latency from an input toggles to the output passes $V_{dd}/2$ is then simulated.  This is done for all input transitions that lead to a rising ($0 \rightarrow 1$) or falling ($1 \rightarrow 0$) output transition, and the average rise latency $R$ and the average fall latency $F$ are calculated.
We then devised a metric, called \emph{imbalance}, to quantify the extent to which a logic gate exhibits imbalance in rise and fall latencies: %in \autoref{eq:imbalance}. 
$i = \frac{\lvert R - F \rvert}{R + F}$.
The imbalance $i$ is a number between 0 and 1 where a logic gate with perfectly balanced rise and fall times yields $i$ equal to 0 while a completely imbalanced logic gate yields $i$ equal to 1. Minimizing $i$ is hence the goal when sizing the transistor gates. 
Load affects the degree of imbalance, and we therefore let all simulated gates drive an inverter.

Minimum sized transistor gates should be avoided in subthreshold circuits.
Local random mismatch (LRM) causes transistors that should ideally have similar electrical properties to behave differently due to limitations in the fabrication processes.
Pelgroms law~\cite{pelgrom} states that the variance of the threshold voltage due to mismatch is inversely proportional to the transistor gate areas $width \times length$ ($WL$).
There are exponential dependencies governing the current levels in subthreshold operation, and the threshold voltages, therefore, have large effects on subthreshold operation.  This makes it important to minimize the effects of mismatch on the threshold voltage.  
The default nMOS gate area ($WL$) is, therefore, chosen to be five times the minimum size.  This reduces the threshold voltage variance to 20\% compared to the minimum sized transistor.  We sometimes deviate from this guideline to achieve the necessary drive strength and performance.  

The pMOS gate area is then determined based on a transient simulation sweeping the pMOS area.  This is done for all logic gates. The pMOS area minimizing the imbalance metric $i$ is chosen.  More complex cells are constructed from logic gates and do not need additional balancing. 
When choosing transistor gate area, the length is set to minimum size and only the width is customized for the cell. 

\subsection{Cell Library Layout and Verification}
\label{sec:cell_lib_verification}

\noindent
\textbf{Layout.}
The layouts of the cells are created in Cadence Virtuoso~\cite{virtuoso}.  
Post-layout simulations with parasitic extraction is performed to verify that the cells are functionally correct and perform as expected over the range of voltages and temperatures the library is expected to work with.
Simulations were performed with Cadence Spectre~\cite{spectre} and parasitic extraction with Siemens Calibre~\cite{calibre}.  After layout, the library was characterized with Cadence Liberate~\cite{liberate}.

 \begin{figure}[t]
   \centering
     \begin{subfigure}[b]{0.49\columnwidth}
       \centering
       \includegraphics[width=\columnwidth]{iv_balance.pdf}
       \caption{INV X5}
       \label{fig:balance_iv}
     \end{subfigure}
     \hfill
     \begin{subfigure}[b]{0.49\columnwidth}
       \centering
       \includegraphics[width=\columnwidth]{nand_balance.pdf}
       \caption{NAND X5}
       \label{fig:balance_nand}
     \end{subfigure}
     \caption{Imbalance $i$ versus voltage for across temperatures.}
     \label{fig:balance}
\end{figure}

\autoref{fig:balance} shows an example of a post layout simulation of the inverter (INV) and NAND cells of size X5.
Imbalance $i$ is depicted against supply voltage for three different temperatures (-40\textdegree C, 15\textdegree C, and 30\textdegree C).
These cells are reasonably balanced by staying below 3\% for all temperatures and voltages between 250\,mV and 400\,mV.  They should, therefore, be well suited for the temperature and voltage range the library is targeting.  

\noindent
\textbf{Verification.}
The library is designed to work with a supply voltage between 250\,mV and 400\,mV, and local random mismatch (LRM) should, therefore, not cause functional defects.
To verify this, several designs were implemented with a full physical layout and then simulated with a transistor-level analog simulation including extracted parasitics.
The analog simulations were performed at the lowest supply voltage of 250\,mV, and with Monte Carlo simulations investigating LRM.
The largest design was PicoRV32~\cite{picorv32:GITHUB}, which is one of the RISC-V cores evaluated later in this paper.  As the core does not contain memory, and also requires some control signals set externally, a Verilog testbench had to be implemented that contains the memory and controls the interface to the PicoRV32 core.
The instruction memory is filled with a small test program.  As these simulations are very time-consuming, only a very small test program containing 18 instructions could be simulated to completion within reasonable time.
Cadence Xcelium~\cite{xcelium} was used to co-simulate the digital Verilog testbench and the analog PicoRV32 core.
The core was simulated until successful completion of the 18-instruction test program. 
No failures were detected with any of the tested designs, including PicoRV32.  
