\subsection{RQ2. Techniques Used for AEG}

Table~\ref{tbl:rq2-results-aeg} summarizes the selected exploit generation studies in our survey and the main techniques employed by them.
Note that we report the studies with their IDs, which are labeled after we perform paper grouping in Section~\ref{sec:paper-organization}.
These techniques can be classified into four technique families as we mentioned in our taxonomy (Figure~\ref{fig:taxonomy}), including AEG, Security Testing, Fuzzing, and other kinds of techniques.

\input{tables/rq2-tab}

\subsubsection{AEG}
In our 63 selected studies, twelve are dedicated to the AEG. The main approaches can be divided into three groups, i.e., Control-flow hijacking AEG, Crash Analysis-based AEG, and Data-oriented AEG. Control-flow Hijacking is the dominant technique with 10/12 AEG studies in our survey while we found only one for each of Crash Analysis-based and Data-oriented AEG. The popular approaches implementing Control-flow Hijacking AEG often require the program binaries as the inputs and consist four steps: (i) identify the vulnerability, (ii) obtain runtime information, (iii) generate the exploits, and (iv) verify the exploits. Meanwhile, Crash Analysis-based AEG (S10~\cite{Liu202271}) requires the crash information as the extra inputs, then this technique extract the execution trace tries and reproduce the crash under symbolic mode. If an exploitable state is found, a solver is utilized to resolve the path contraints to find malicious inputs and synthesize the exploit. Data-oriented AEG (S11~\cite{Pewny2019111}), on the other hand, tries manipulate the data control path instead of the execution control flow of the targeted program. This technique generate the data-oriented programming (DOP) attacks in the form of a high-level language, then compile them into concrete exploits for each kind of compilers.

\subsubsection{Security Testing}
Security testing has the majority of studies in our survey with a very wide range of testing techniques. They expand in multiple classes of testing techniques: from model-based testing, logic programming-based testing, heuristic-based testing, grammar-based testing, search-based testing to hybrid testing, learning-based testing, and pentesting. Xu et al. contribute to the threat model based security testing with their four works (S08, S48-S50~\cite{marback2013threat, xu2011tool, xu2012automated, Xu2015247}). They first manually contruct the PetriNets as the threat models, from which they generate the attack paths, and lastly the security test cases. Their approach can be applied to generate security tests in cross-language projects such as PHP and C/C++.
In the work of Zech et al. (S35~\cite{Zech201488}), they generates negative security tests based on a answer set programming that they collect from the developers. Chaleshtari et al. (S31~\cite{Chaleshtari20233430}) employed heuristic-based testing, where they define of 120 Metamorphic relations with domain-specific language for specifying security properties in Java code and then use them for generate security test cases. In S27~\cite{Mohammadi201678}, Mohammadi et al. used unit testing to generate Cross-side scripting (XSS) tests for Java Jakarta Server Pages (JSP). The inputs for the tests are provided by a grammar-based generator, this techniques were used detect zero-day XSS vulnerabilities. Del Grosso et al. (S35~\cite{DelGrosso20083125}) tried to generate test input to detect buffer overflow in C/C++ programs by leveraging search-based testing. The genetic algorithm they used gives rewards to the test inputs reaching the vulnerable statements. In this way, they can find the inputs that can trigger the vulnerabilities. Del Grosso et al. (S34~\cite{Liu2020286}) applied recent advances in deep learning for natural language processing to learn the semantic knowledge from code snippets vulnerable to SQL Injection attacks to generate the malicious inputs and then translate these inputs into security test cases.

\subsubsection{Fuzzing}
We acknowledge that there are a plethora of fuzzing techniques in the literature. However, as mentioned in the Section~\ref{sec:intro} and Section~\ref{sec:background}, we set our scope to the techniques that are specific designed to find vulnerabilities at the first place. So many of the fuzzing techniques (do not focus on security vulnerabilities, yet can be used to discover security bugs) are of our scope except for the ones in Table~\ref{tbl:rq2-results-aeg}. Coverage-based greybox fuzzing are employed by the most fuzzing studies (S04, S13-16~\cite{Bohme2019489, Liu2018, Wuestholz20201398, Gong2022374}) in our survey. S13~\cite{Bohme2019489} is one of the well-known work which are built on American Fuzzy Lop (AFL) tool framework and leverages the Markov chain as modeling a systematic exploration of the state space for finding inputs. Other fuzzing techniques can be named for finding vulnerabilities such as Knowledge-based fuzzing, Directed fuzzing, Mutation-based fuzzing, Stateful fuzzing, and Whitebox fuzzing.

\subsubsection{Others}
Some other techniques utilized for generating vulnerability exploits that we found are also well-known such as Taint analysis, Symbolic execution, and String analysis. Note that these techniques are frequently employed as parts of the other exploit generation studies, however, we only report the primary techniques. In this family, we list the studies that are not eligible to be classified into the big three technique families AEG, Security testing, and Fuzzing.