\subsection{RQ4. Output of AEG techniques}

As shown in Table~\ref{tbl:rqs-g1}, we categorize the outputs of the tools into groups: (1) exploit, which is either a code snippet or a complete program that can be executed to exploit the vulnerabilities, (2) test cases, which are usually associated and can be executed with a testing framework such as \textsc{JUnit} or \textsc{Selenium} to find evidence of the vulnerability's presences in the project, and (3) input/payload which consists of crafted input values or objects to trigger the vulnerable states of the asset.

It can be foreseen that most AEG techniques (studies S01 -- S11) target generating working exploits that find not only the vulnerable states but also the exploitable states of the target programs.
\ifthenelse{\boolean{deliverable}}
{}
{\ema{We need to clarify (earlier) the difference between exploitable and vulnerable states because it's interesting.}}
However, Do et al.~\cite{Do2015401} proposed an AEG technique that generates an exploit in the form of a test case, which can be executed via the Java \textsc{JUnit} testing framework. In contrast to AEG, fuzzing techniques tend to generate the inputs or payloads that can aim to trigger the only vulnerable state without further exploitation actions.
This is true except for some fuzzing work where they also put more effort into reaching the exploitable state of the vulnerabilities~\cite{Bohme2019489}.
Most security testing techniques aim to generate security test cases to find vulnerabilities or security weaknesses in a more methodical way compared to AEG and Fuzzing approaches. Many testing techniques also aim to generate the malicious inputs~\cite{Bozic202020, Bozic2020115, Liu2020286, Appelt2014259} for triggering web-based vulnerabilities and exploits for memory-based vulnerabilities in program binaries~\cite{Nurmukhametov202137}.