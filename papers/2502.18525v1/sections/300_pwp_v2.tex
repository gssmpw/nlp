\section{\Ours (\ours)}
\label{sec:methodology}
Modern software engineering (SWE) requires using multiple programming languages, tools, and modalities.
Furthermore, it relies on a wealth of tools that required tremendous human effort to create—from linters, to visual code debuggers, to project management tools.
Motivated by these observations, we create \Ours{}, an IDE environment that satisfies two properties: (i) it is \textit{expressive}, meaning that an agent can perform any task that is achievable through a sequence of primitive operations (e.g., typing or clicking) within an IDE; (ii) an agent has access to any tool implemented within the IDE since using a tool amounts to performing a sequence of primitive actions.



\subsection{PwP environment}

We represent the \ours{} environment as a partially observable Markov decision process (POMDP).
We define the PwP POMDP  \(\langle S, A, O, T, R \rangle\) as:

\begin{itemize}[leftmargin=2em]
\item \(\mathbf{S}\) is the set of states describing the IDE and the operating system context, including open files, active editor panels, and cursor positions. 
\item \(\mathbf{A}\) is the action space, encompassing all possible keyboard and mouse events.
The atomic actions in PwP are provided by the  \texttt{xdotool} library~\cite{xdotool}, which allows specifying all possible keyboard and mouse events in a simple syntax.
The specific action space varies based on the agent setting, described in (\S\ref{sec:agent}).

\item \(\mathbf{O}\) is the observation space.
The observation space varies based on the agent setting, described in (\S\ref{sec:agent}).
\item \(\mathbf{T}\) is the transition function.
Actions like inserting a character typically lead to deterministic changes in the IDE state, whereas background processes 
can introduce stochasticity in timing and responses. 
\item \(\mathbf{R}\) is the reward function that measures performance on a given task. 
For instance, after the agent finishes editing code to fix a bug, the environment can run a test suite on the updated files to compute a reward. 
\end{itemize}

Trajectories in \ours{} can thus resemble real-world development work: an agent can fix a bug in a repository, use a suggestion tool to help with writing code, or create documentation.
The IDE and its operating system environment track changes, run tests and return reward signals.


\input{tables/env_comparison}

\subsection{Key Features of \Ours{}}



\paragraph{Expressive observation and action space.}
A typical approach to building agents is to engineer a set of high-level actions for operations like ``open file'' or ``list symbols in file'', and then engineer an environment that supports each action~\cite{xia2024agentlessdemystifyingllmbasedsoftware,yang2024swebenchmultimodalaisystems,wang2024openhandsopenplatformai}.
Furthermore, agents receive textual outputs that are manually reformatted for each action. The key difficulty is that such engineering does not scale to a large number of actions or to the full range of software engineering tasks, and the agent may be specialized to the observation and action space.
In contrast, \ours{} preserves standard screen-based user interaction.
The agent can navigate IDE menus visually, move the cursor, and press keys.
This makes the environment expressive: an agent can achieve any task that can be achieved through primitive actions in an IDE.

\paragraph{Full Spectrum of Developer Tools.}
A modern IDE offers debuggers, linters, version control, refactoring utilities,  integrated terminals, and many extensions.
In particular, PwP is developed on top of VSCode, which has a rich set of built-in functionalities and extensions.
Implementing each of these into an agent or environment would require significant human effort.
However, \ours{} provides these capabilities out-of-the-box within a single environment.
Agents can set breakpoints, execute code, use language-specific extensions, review error messages, or run tests in a consistent interface.

\paragraph{Multimodality and Language Agnosticism.}
Because the IDE supports numerous programming languages through extensions and built-in modules, \ours{} naturally covers tasks across Python, Java, JavaScript, Lean, and more without requiring separate integrations. 
For instance, agents can use the same debugger interface for all languages, or use pre-existing linters provided by IDE extensions.
Beyond screenshots, the environment provides video streams and  audio, though we leave exploring these for future work.





\paragraph{Rich Feedback and State Access.}
\ours{} can evaluate performance immediately using testing frameworks or compilation checks.
For instance, if the agent modifies a file, the IDE can automatically trigger a build, update diagnostics, or run tests, generating real-time feedback.
In cases requiring deeper inspection—such as verifying that a bug is truly fixed—the environment can reveal file-system changes, process states, or test results.

\input{listings/pwp_example}

\paragraph{Future Adaptability.}

As agents continue to evolve, \ours{} provides a unified environment for incorporating new benchmarks and training.
For example, \ours{} is amenable to reinforcement learning due to its use of the standard gymnasium~\cite{towers2024gymnasiumstandardinterfacereinforcement} interface and its checkpointing functionality. We show an example of how to interact with \ours{} in \autoref{lst:pwp_example}.
Checkpointing also allows for backtracking in search-based methods~\cite{Koh2024TreeSF,Putta2024AgentQA}. 
As software engineering practices progress and new IDE tools emerge, \ours{} incorporates them without additional engineering overhead. 
Further, as agents become more ubiquitous, it is imperative to evaluate their capabilities in pair-programming scenarios with human developers. 
\ours{} supports concurrent user-agent interaction, potentially enabling new kinds of pair programming or real-time collaboration studies. 
Finally, adding new tasks requires only minimal modification to configuration and evaluation files.


\subsection{Infrastructure and Implementation}

\ours{} is deployed in a secure sandboxed environment.
In particular, we run a modified version of Visual Studio Code (VSCode) and a minimal operating system inside a Docker container, ensuring a secure and isolated environment.
We chose VSCode for its extensive language support, rich ecosystem of extensions, widespread adoption in the developer community, and open-source nature that enables customization and modification of its core functionality.
Each container instance maintains its own file system and processes, preventing interference between experiments, facilitates reproducibility, and ensuring parallelization of evaluation.
We further provide the ability to checkpoint the environment state, which is especially useful for backtracking in search algorithms or while training RL agents.

The environment interfaces with VSCode through multiple channels: 1.) A controller that manages Docker container lifecycle and configuration, 2.) A port-forwarding system for real-time screen and video capture, 3.) A modified VSCode codebase that exposes DOM state information, and 4) The VSCode Extension API for accessing fine-grained IDE state.
This multi-channel approach enables both high-level environment control and detailed state observation.

Screen capture is handled via \texttt{ImageMagick} for static screenshots and \texttt{ffmpeg} for streaming video output.
These tools were selected for their low latency and ability to handle various screen resolutions and color depths.
For actions, a lightweight controller executes \texttt{xdotool} commands within the container, which in turn simulates keyboard and mouse events on the IDE.
Agents can thus insert code, open new files, or navigate menus using the same actions that a human developer would.

As shown in \ref{lst:pwp_example}, a Python API is provided for interaction, following a style similar to common reinforcement learning libraries such as gymnasium~\cite{towers2024gymnasiumstandardinterfacereinforcement}.
The API abstracts away the complexity of container management, benchmark management, and handling observations and actions, allowing researchers to focus on agent development.
Users can query the environment for the latest screenshot, issue an \texttt{xdotool} command, and receive updated states or rewards.
The environment's container configuration is flexible, allowing for software installations, customizable CPU/memory limits, and display settings (e.g., resolution).
This versatility is crucial for large-scale evaluation, especially when tasks vary in complexity and resource needs.
