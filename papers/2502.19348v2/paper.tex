\documentclass[acmsmall,screen]{acmart}

%%%% SHORT VERSION OR NOT %%%%%
\newif\ifarxiv
\arxivtrue

\settopmatter{printfolios=true}

\newcommand{\polish}[1]{{\color{red}#1}}

\usepackage{caption,subcaption}
\usepackage{wrapfig}
\usepackage{graphicx,fancyvrb,booktabs}
\usepackage{xspace}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{microtype}

\usepackage[frozencache=true,cachedir=minted-cache]{minted}
%\usepackage[finalizecache=true,cachedir=minted-cache]{minted}
%\usepackage[cachedir=minted-cache]{minted}

\newcommand{\iver}[1]{\mintinline{systemverilog}{#1}}
\newcommand{\iverhack}[1]{\mintinline{verilog}{#1}}

\newcommand{\gramsep}{\ensuremath{\ |\ }}

\newcommand{\IP}{\textsc{ip}\xspace}
\newcommand{\ALWAYSP}{\textsc{alwaysp}\xspace}
\newcommand{\VARP}{\textsc{varp}\xspace}
\newcommand{\NBAP}{\textsc{nbap}\xspace}

\newcommand{\CP}{\textsc{cp}\xspace}

\newcommand{\orderall}{NB\_ORDER\_ALL\xspace}
\newcommand{\ordersame}{NB\_ORDER\_SAME\xspace}

\newcommand{\nomixblocking}{NB\_MIX\_NO\_BLOCKING\xspace}
\newcommand{\nomix}{NB\_MIX\_NO\xspace}

\hyphenation{Veri-log}

\setcopyright{cc}
\setcctype{by}
\acmDOI{10.1145/3720484}
\acmYear{2025}
\acmJournal{PACMPL}
\acmVolume{9}
\acmNumber{OOPSLA1}
\acmArticle{126}
\acmMonth{4}

\ifarxiv
\else
\received{2024-10-16}
\received[accepted]{2025-02-18}
\fi

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
%\setcopyright{acmlicensed}
%\copyrightyear{2018}
%\acmYear{2018}
%\acmDOI{XXXXXXX.XXXXXXX}


%%
%% These commands are for a JOURNAL article.
%\acmJournal{JACM}
%\acmVolume{37}
%\acmNumber{4}
%\acmArticle{111}
%\acmMonth{8}

%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

\begin{document}

%\title{Visually Debugging the Semantics of Verilog
%\title{The Verilog Standard Is Too Broken to Be Formalised and What We Can Do About It}
%\title{Untangling Problems in the Simulation Semantics of Synthesisable Verilog}
\title{The Simulation Semantics of Synthesisable Verilog}

\author{Andreas Lööw}
\orcid{0000-0002-9564-4663}
\affiliation{%
  \institution{Imperial College London}
  \city{London}
  \country{United Kingdom}
}
\email{a.loow@imperial.ac.uk}

\begin{abstract}
%\polish{NEW: Highlighting problems in the simulation semantics of synthesisable Verilog that are problems for [using the semantics in verification], which we have found during our formalisation process... what started as a project to formalise the simulation standard ended up a project to hunt down problems with the Verilog standard.}

Despite numerous previous formalisation projects targeting Verilog, the semantics of Verilog defined by the Verilog standard -- Verilog's simulation semantics -- has thus far eluded definitive mathematical formalisation. Previous projects on formalising the semantics have made good progress but no previous project provides a formalisation that can be used to execute or formally reason about real-world hardware designs. In this paper, we show that the reason for this is that the Verilog standard is inconsistent both with Verilog practice and itself. We pinpoint a series of problems in the Verilog standard that we have identified in how the standard defines the semantics of the subset of Verilog used to describe hardware designs, that is, the synthesisable subset of Verilog. We show how the most complete Verilog formalisation to date inherits these problems and how, after we repair these problems in an executable implementation of the formalisation, the repaired implementation can be used to execute real-world hardware designs. The existing formalisation together with the repairs hence constitute the first formalisation of Verilog's simulation semantics compatible with real-world hardware designs. Additionally, to make the results of this paper accessible to a wider (nonmathematical) audience, we provide a visual formalisation of Verilog's simulation semantics.

% It follows that the analogous simple repairs applied to the formalisation would thus give the first formalisation of Verilog's simulation semantics compatible with real-world hardware designs. 

% have also highlighted and left open concurrency problems at the core of the semantics. In this paper, we address these last remaining concurrency problems of the semantics, specifically, we identify the root-cause problem of the standard that give raise to the concurrency problems. We also identify a problem of the standard that give raise to a concurrency problem that seems to have gone unnoticed in previous work. Given the severity of the problems of the standard that we have identified, we argue that the standard cannot be meaningfully formalised unless the identified problems are first resolved; or, put more plainly: we argue that the Verilog standard is too broken to be formalised. We are, nevertheless, optimistic: said problems appear to be relatively easy to resolve and we give suggestions on how to resolve them. Taken together, previous work on the semantics of Verilog patched with our suggestions on how to resolve the problems we identify in this paper provide a possible semantic formal foundation for formal reasoning about~Verilog~designs~and~tools.
%
%In this paper, to prepare the ground for such a formalisation, we employ an, what we believe to be, underappreciated form of semantics formalisation: namely, visual formalisation. We develop a visual formalisation of Verilog's simulation semantics and use this formalisation to visually debug, i.e., visually find problems in, the standard's description of the semantics. We identify two problems in the Verilog standard that the current state-of-the-art mathematical formalisation projects for Verilog have either missed or, we argue, misunderstood. We believe the two identified problems (1) constitute actionable findings for improving the Verilog standard and (2) demonstrate the complementary value of~visual~formulation.
%
%Because of the two identified problems, we believe definitive formalisation of Verilog cannot take place before the standard is revised.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10010583.10010682.10010689</concept_id>
       <concept_desc>Hardware~Hardware description languages and compilation</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003752.10010124.10010131</concept_id>
       <concept_desc>Theory of computation~Program semantics</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Hardware~Hardware description languages and compilation}
\ccsdesc[500]{Theory of computation~Program semantics}

%\ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
%\ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Verilog, semantics}

%\received{20 February 2007}
%\received[revised]{12 March 2009}
%\received[accepted]{5 June 2009}

\maketitle

% todo: maybe add
% Rust: https://twitter.com/wcrichton/status/1608632382256746498
% Updated Rust: https://twitter.com/wcrichton/status/1626725794751070208
% Also, Cerberus visualises provenance... say visualise difficult-to-understand features, such as ownership in Rust and provenance in C...

\section{Introduction}

% an instruction-set architecture,

To formally reason about a programming language or a hardware-description language (HDL), a mathematical formalisation of the language is required (e.g., an operational semantics or a denotational semantics). Examples of applications of formal reasoning include the \emph{verification of programs/hardware designs} implemented in the language in question and the \emph{verification of tools} for the language, such as compilers/synthesis tools and analysis tools (e.g.,~model~checkers).

Unfortunately, the most popular HDL~\cite{Flake2020}, Verilog, lacks a definitive mathematical formalisation. The semantics of Verilog, known as its \emph{simulation semantics} (formally, its \emph{scheduling semantics}), is defined by the (System)Verilog standard, IEEE 1800-2023~\cite{SystemVerilog-2023}. As an HDL, the semantics of Verilog is distinctly different from the semantics of traditional programming languages such as C++ or Haskell. In short, the semantics is \emph{reactive} and \emph{event driven}: it is driven by \emph{concurrent processes that create and react to events}, such as a clock tick or a change in a circuit input.

% The Verilog standard is infamous for being difficult to read and understand, nevertheless, the literature features a long line of attempts at formalising it.

Although no definitive mathematical formalisation of Verilog is available today, previous work on formalising Verilog have made good progress~\cite{Meredith10,Chen23,Gordon95,Schneider98a,Schneider98b,Pace98,Jifeng00a,Jifeng00b,Bowen00,Zhu01a,Zhu01b,Huibiao06,Stewart02}. The most comprehensive and detailed formalisation, that is, the state-of-the-art, is the formalisation by Chen~et~al.~\cite{Chen23}. Before Chen~et~al.'s work was published the state-of-the-art was the formalisation by Meredith~et~al.~\cite{Meredith10}. Despite the progress made, these previous formalisations are not definitive since they cannot be used to execute or formally reason about real-world Verilog hardware designs: in particular, the major problems remaining to be resolved are the concurrency problems at the core of Verilog's semantics that both Chen et al. and Meredith et al. run into and leave open.

%\polish{(We introduce the two state-of-the-art formalisations in more detail in the related work section (Sec.~\ref{sec:related-work}).)}

%Unfortunately, our ongoing work on formalising Verilog has come to a halt. In this paper, we claim, perhaps controversially, this is because \emph{the Verilog standard (in its current version) is too broken to be (meaningfully) formalised}. We have identified two main problems blocking formalisation, which we describe in detail in this paper.

In this paper, we address the concurrency problems left by previous work on formalising Verilog and, as a result, can for the first time present a formalisation of Verilog that is compatible with real-world hardware designs. We succeed in doing so by identifying problems in the Verilog standard that are the root causes of the problems left by previous work. Additionally, we also highlight problems in the Verilog standard that have gone unnoticed in previous work. Previous work have tried to formalise the standard as-is but the problems we have found in the standard suggest that this is to attack the \emph{wrong problem}: a formalisation of a broken standard is of little use. The \emph{right problem} to attack is to clearly describe the problems in the standard such that they can be resolved -- this is the problem we attack in this paper. %In other words, in our view, the Verilog standard in its current form is too broken to be formalised without first addressing \IP and \NBAP.

\paragraph{Contribution 1: Verilog standard problems (Sec.~\ref{sec:informal-simulation-semantics}, \ref{sec:simulation-semantics}, and \ref{sec:problems})} The first contribution of this paper is that we identify a series of problems in the Verilog standard. We have found these problems in a multitude of ways. Some problems we have found by (unstructured) close reading of the Verilog standard and previous work on formalising Verilog's simulation semantics. Some of the problems we have found by developing, what we call, a ``visual formalisation'' of Verilog's simulation semantics (see the third contribution below).

The problems we identify are of varying character -- the most severe problems are problems where the Verilog standard is inconsistent with Verilog practice. In more detail, these are problems arising from inconsistencies between the following two descriptions of Verilog's simulation semantics:
%
\begin{itemize}
\item Verilog's simulation semantics as \emph{described by the Verilog standard}; which we call, simply, Verilog's \emph{simulation semantics} (since it is \emph{the} simulation semantics).
\item Verilog's simulation semantics as \emph{assumed in practice}; which we call, Verilog's \emph{informal simulation semantics}. This is the semantics used by, e.g., practitioners when designing hardware using Verilog and in university course material for digital design courses. %The semantics can be seen as a (not fully faithful) simplification/high-level description of the standard's simulation semantics.
\end{itemize}
%
In the main text of the paper, we discuss both descriptions and we show, for example, that Verilog's \emph{simulation semantics} allows for more interleavings between concurrent processes than Verilog's \emph{informal simulation semantics}. Verilog code written assuming Verilog's informal simulation semantics, that is, Verilog code written by today's Verilog conventions, is therefore not compatible with the semantics specified by the standard; the semantics specified by the standard, if followed to the letter, renders almost all but the most trivial Verilog code~completely~broken.

%The interleaving semantics of concurrent processes specified by the standard is incompatible with Verilog practice: 

Another type of problem we highlight is where the standard is inconsistent with itself. For example, the semantics of a core concurrency construct of Verilog, called nonblocking assignments, used for race-free communication between concurrent processes, is specified in contradictory ways in different parts of the standard. The semantics of nonblocking assignments is described by both pseudocode and prose text in the standard and these two descriptions are inconsistent.

%As we show in the main text, the problem \IP is the underlying problem causing the above-mentioned concurrency problems for both Meredith et al.'s and Chen et al.'s Verilog formalisations. The problem \NBAP seems to have not been discussed in previous formalisation work.

%E.g., \IP shows that the Verilog standard is out of sync with current Verilog practice -- and what is the use for a formalisation of a standard out of sync with current practice?

%The two problems \IP and \NBAP are different kinds of inconsistency problems, as we now discuss in more detail.

%\paragraph{The Verilog standard problems: \NBAP} The problem \NBAP arise from an inconsistency, in contrast to \IP, within the standard itself.

%We show in this paper that Verilog's simulation semantics allow for more process interleavings than Verilog's informal simulation semantics, thereby breaking code designed using Verilog's informal simulation semantics.

\paragraph{Contribution 2: mathematical formalisation of Verilog (Sec.~\ref{sec:formalisations})} The second contribution of this paper is that we show that the problems we have identified in the Verilog standard (the first contribution of the paper) are sufficient to enable us to ``repair'' the current state-of-the-art mathematical formalisation of Verilog, i.e., the formalisation by Chen~et~al.~\cite{Chen23}, in the sense that after the repairs the formalisation is compatible with Verilog practice. Specifically, as we detail below, we show this \emph{indirectly} by repairing Chen~et~al.'s executable implementation of their formalisation.

To be able to evaluate their formalisation on Verilog code, Chen et al. have implemented an executable version of their formalisation in Java. In their paper, Chen et al. run this Java implementation on a selection of test cases from the test suite of the open-source Verilog simulator Icarus~\cite{Icarus} and real-world test cases (including tests for parts of a CPU implemented in Verilog). Since Chen et al.'s formalisation closely follows the Verilog standard and (as we show) therefore inherits the problem of the standard, many of these tests fail to execute correctly.

We repair the problems we have identified in the Verilog standard in the Java implementation of Chen et al.'s formalisation and show that this repaired implementation can successfully execute almost all test cases Chen et al. used to evaluate their formalisation. We make the repaired implementation available in the artefact of this paper.

\paragraph{Contribution 3: visual formalisation of Verilog (Sec.~\ref{sec:formalisations})} The third contribution of this paper is that we have developed a new web-browser-based visual Verilog simulation tool VV (short for ``Verilog visualiser''). VV is the first tool to visualise the structure and maintenance of the Verilog event queue (the heart of Verilog's simulation semantics), and we therefore think of VV as the first ``visual formalisation'' of Verilog. As we explain in the body of this paper, Verilog's simulation semantics is centred around this event queue which is used to keep track of and coordinate different events. By visualising this queue, VV therethrough shows how the constructs of Verilog are given semantics in terms of their interactions with this queue. VV is interactive and driven by the user of the tool clicking the next event to execute, which allows its users to visually explore different event schedules and other aspects of the semantics of Verilog.

% VV can be run in any web browser without any installation or setup: 

We believe the visual formalisation of Verilog that VV provides has complementary value to mathematical formalisation. Whereas mathematical formalisations require specialised knowledge of formal semantics to read, and hence are not accessible to a wide range of Verilog tool developers and Verilog hardware designers, our visual formalisation is readily accessible to anyone with a web browser. We believe the problems we identify here are of interest to communities outside communities where knowledge of formal semantics can be assumed and we therefore see making Verilog's simulation semantics more widely accessible through VV as an important means to disseminate our findings of this paper. Moreover, we ourselves have found VV to be helpful in debugging the Verilog standard; indeed, VV has helped us to find some of the problems of the standard we discuss~in~this~paper.

A live demo of VV and its source code are available at \url{https://github.com/AndreasLoow/vv} and also in the artefact of this paper.

%exploring the design space of the simulation semantics. We make VV available because we believe, like the tool has been useful for us, the tool might be useful for other researchers investigating the semantics of Verilog.

%\paragraph{Contributions} In summary, we make the following contributions:
%
%\polish{Having in mind the advantages of going through a round of testing/bug finding before attempting to formally verify a piece of software or hardware, we believe ``debugging'' language standards before attempting mathematical formalisation is well-invested energy. This is particularly true for language standards like the Verilog standard, which is known to be difficult to work with.}
%
%% \begin{itemize}
%% \item We explain the root-cause problem, which we call \IP, behind the last remaining major concurrency problems in the formal semantics of Verilog. We also report on a concurrency problem, which we call \NBAP, not highlighted in previous research.
%% \item We investigate how \IP and \NBAP are treated in current practice, i.e., by existing Verilog simulators.
%% \item We show that both Meredith et al.'s and Chen et al.'s Verilog formalisations, i.e., the two state-of-the-art Verilog formalisations, fail to fully address both \IP and \NBAP.
%% \item We make suggestions on how \IP and \NBAP can be resolved.
%% \item We make available our new visual simulation tool VV, which has helped us in debugging the Verilog standard and exploring the design space of the semantics.
%% \end{itemize}

%\paragraph{Overview of the paper} In Sec.~\ref{sec:scope} we define the scope of our investigations into Verilog. In Sec.~\ref{sec:verilog}, we give an introduction to the Verilog's informal simulation semantics.

%we give a crash course in Verilog, in particular, we introduce , . We give this crash course to (1) make the paper self-contained (in particular, accessible to readers with limited previous experience with Verilog) and (2) later contrast Verilog's informal simulation semantics with . In Sec.~\ref{sec:scope}, now having introduced Verilog, we discuss what subset of Verilog we consider most important for formalisation, that is, we define the scope of our work. In Sec.~\ref{sec:simulation-semantics}, we discuss the simulation semantics of Verilog as defined by the Verilog standard. This section is not only important to readers with limited previous experience of Verilog but also readers with previous experience with Verilog that have not delved into the details of the semantics of Verilog, such as readers with long experience with Verilog for hardware design.

%\polish{In Sec.~\ref{sec:two-problems}, we meet reaction (1), we discuss the two problems we have found. In Sec.~\ref{sec:nonproblems}, we meet reaction (2), we highlight some nonproblems some readers will have expected to be problems for formalisation. Lastly, In Sec.~\ref{sec:vv}, we describe VV. We finish with related work in Sec.~\ref{sec:related-work} and conclude in Sec.~\ref{sec:conclusion}.}

%% -------------------------- OLD --------------------------

%In this paper, we employ \emph{visual formalisation} to prepare the ground for a future definitive mathematical formalisation of Verilog: we visually debug the Verilog standard by visually formalising it and in the process we identify problems in the standard that provide actionable pathways to improve it. Previous work on mathematical formalisation of the standard have not found or have inadequately addressed the problems we have found, which we believe shows that \emph{visual formalisation is a (perhaps, underappreciated) useful complement to traditional mathematical formalisation}. Specifically, we have developed a \emph{visual formalisation of Verilog's simulation semantics} which has led us to identify \emph{two problems in the Verilog standard} concerning the semantics of process interleavings and a core construct of Verilog called nonblocking assignments. We show how the identified problems manifest in the two state-of-the-art mathematical formalisations of Verilog, namely, Meredith~et~al.~\cite{Meredith10} and Chen~et~al.~\cite{Chen23}.

%\paragraph{Approach: Visual formalisation.}

%We believe that the visual formalisation of Verilog we contribute in this paper has the potential to serve as a useful intermediate step towards a definitive mathematical formalisation of Verilog.

%This is because we hypothesise that the reason the literature has yet to see a definitive mathematical formalisation of Verilog is the result of a communal split between the hardware-design community and the programming-language-theory community: the hardware-design community has the know-how of Verilog but not the know-how of developing mathematical formalisations of languages whereas the programming-language-theory community has the opposite problem.

%Our visual formalisation of Verilog, we believe, has the potential to enable the two communities to combine their expertise. We believe this because, in contrast to a mathematical formalisation, no specialist mathematical knowledge is required to understand our visual formalisation, hence, our visual formalisation enables the hardware-design community to judge if our formalisation is consistent with their everyday intuitions about Verilog. Simultaneously, in contrast to the Verilog prose standard, extensive knowledge of Verilog is not required to understand our visual formalisation, hence, our visual formalisation provides a first starting point for a mathematical formalisation of Verilog for the programming-language-theory community.

\section{Scope: Target Subset of Verilog}%
\label{sec:scope}

In this section, we define the scope of our investigation into Verilog. Verilog is a large language: the Verilog standard weighs in at 1354~pages -- just the grammar alone occupies 46~pages (see App.~A of the standard). Because of the size of the standard, we have identified a \emph{target subset of Verilog} that we believe captures the subset of Verilog most important to formalise. We give the syntax of this subset in Fig.~\ref{fig:syntax}. We have identified this subset using the following three \emph{target subset selection criteria}, which we motivate and explain below:
%
\begin{enumerate}
\item focus on \emph{synthesisable Verilog} constructs;
\item focus on Verilog constructs that have interesting behaviour in terms of how they interact with the \emph{Verilog event queue};
\item include \emph{Verilog modules}.
\end{enumerate}

\begin{figure}[t]
\begin{minipage}[t]{0.30\textwidth}
\[
\small
\begin{array}{lcl}
  n &\in& \mathbb{N} \\
  \textit{str} &\in& \text{strings} \\
  \textit{id} &\in& \text{identifiers} \\
  b & ::= & \texttt{0} \gramsep \texttt{1} \gramsep \texttt{x} \gramsep \texttt{z} \\
%
  \textit{op}_\textit{1} & ::= & \texttt{!} \gramsep \texttt{\char`\~} \gramsep \cdots \\
  \textit{op}_\textit{2} & ::= & \texttt{\&} \gramsep \texttt{\&\&} \gramsep \texttt{+} \gramsep \cdots \\
%
%% e & ::= & n\texttt{\textquotesingle{}b}b & \text{(binary) literal constant} \\
%%   & |   & \texttt{\textquotesingle{}\{}\ (e\texttt{,})*\ \texttt{\}} & \text{unpacked array \polish{literal}} \\
%%   & |   & \textit{id} & \text{variable/net reference} \\
%%   & |   & \textit{op}_\textit{1}\ e & \text{unary operator} \\
%%   & |   & e\ \textit{op}_\textit{2}\ e & \text{binary operator} \\
%%   & |   & e\ \texttt{?}\ e\ \texttt{:}\ e & \text{ternary if} \\
%
  e & ::= & \texttt{\textquotesingle{}b}b \\
    & |   & \texttt{\textquotesingle{}\{}\ e{}*\ \texttt{\}} \\
    & |   & \textit{id} \\
    & |   & \textit{op}_\textit{1}\ e \\
    & |   & e\ \textit{op}_\textit{2}\ e \\
%
  \textit{eee} & ::= & \texttt{edge} \\
               & \gramsep & \texttt{posedge} \\
               & \gramsep & \texttt{negedge} \\
  \textit{ee} & ::= & [\textit{eee}]\ e \gramsep \textit{ee}\ \texttt{or}\ \textit{ee} \\
  \textit{st} & ::= & \texttt{\$display} \\
              & \gramsep & \texttt{\$monitor} \\
              & \gramsep & \texttt{\$finish} \\
  \textit{ste} & ::= & e \gramsep \textit{str} \gramsep \texttt{\$time} \\
\end{array}
\]
\end{minipage}
%
\begin{minipage}[t]{0.69\textwidth}
\[
\small
\begin{array}{lcll}
  s & ::= & s\ \texttt{;}\ s & \text{sequential sequencing} \\
    & |   & \texttt{if}\ \texttt{(} e \texttt{)}\ s\ [\texttt{else}\ s]\ & \text{if statement} \\
    & |   & \textit{id}\ \texttt{=}\ [\texttt{\#}n]\ e & \text{blocking assignment} \\
    & |   & \textit{id}\ \texttt{<=}\ [\texttt{\#}n]\ e & \text{nonblocking assignment} \\
    & |   & \texttt{@(} \textit{ee} \texttt{)}\ [s] & \text{event control} \\
    & |   & \texttt{@(*)}\ [s] & \text{comb. event control} \\
    & |   & \texttt{\#} n\ [s] & \text{delay control} \\
    & |   & \texttt{wait(} e \texttt{)}\ [s] & \text{wait statement} \\
    & |   & \textit{st}\texttt{(}\textit{ste}*\!\texttt{)} & \text{system task} \\
%
  m & ::= & \multicolumn{2}{l}{n \gramsep \texttt{(}n\texttt{,}\ n\texttt{)} \gramsep \texttt{(}n\texttt{,}\ n\texttt{,}\ n\texttt{)}} \\
  \textit{nt} & ::= & \multicolumn{2}{l}{\texttt{wire} \gramsep \texttt{wand} \gramsep \texttt{wor}} \\
  \textit{pt} & ::= & \multicolumn{2}{l}{\texttt{initial} \gramsep \texttt{final} \gramsep \texttt{always} \gramsep \texttt{always\_ff}} \\
              & | & \multicolumn{2}{l}{\texttt{always\_comb} \gramsep \texttt{always\_latch}} \\
%
  \textit{mi} & ::= & \texttt{logic}[\texttt{[}n\texttt{:}n\texttt{]}]\ \textit{id}[\texttt{[}n\texttt{:}n\texttt{]}]\ [\texttt{=}\ e] & \text{variable declaration} \\
              & |   & \textit{nt}[\texttt{[}n\texttt{:}n\texttt{]}]\ [\texttt{\#}m]\ \textit{id}[\texttt{[}n\texttt{:}n\texttt{]}]\ [\texttt{=}\ e] & \text{net declaration} \\
              & |   & \textit{pt}\ s & \text{procedure/block} \\
              & |   & \texttt{assign}\ \textit{id}\ \texttt{=}\ [\texttt{\#}m]\ e & \text{continuous assignment} \\
              & |   & \textit{id}\ \textit{id}\texttt{(}(\textit{id}.(e))*\texttt{)} & \text{module instantiation} \\
%
  \textit{md} & ::= & \multicolumn{2}{l}{\texttt{input} \gramsep \texttt{output} \gramsep \texttt{inout}} \\
%
  \textit{mk} & ::= & \texttt{logic} \gramsep \textit{nt} \\
%
  \textit{mp} & ::= & \multicolumn{2}{l}{\textit{md}\ \textit{mk}[\texttt{[}n\texttt{:}n\texttt{]}]\ \textit{id}[\texttt{[}n\texttt{:}n\texttt{]}]\ [\texttt{=}\ e]} \\
%
  m & ::= & \multicolumn{2}{l}{\texttt{module}\ \textit{id}\texttt{(}\textit{mp}*\!\texttt{)\!;}\ \textit{mi}*\ \texttt{endmodule}}
\end{array}
\]
\end{minipage}
\caption{Target syntax of expressions $e$, statements $s$, module items $\textit{mi}$, and modules~$m$. Square brackets ($[\ldots]$) denote optional elements and times ($\ldots*$) denotes repetition. Redundant syntax is omitted to avoid clutter, e.g., ``$\textit{ee} ,\,\textit{ee}$'' instead of ``$\textit{ee}\ \texttt{or}\ \textit{ee}$'' in event expressions (\textit{ee}) or \texttt{reg} instead of \texttt{logic}~in~variable~declarations~(\textit{mi}).}%
\label{fig:syntax}
\end{figure}

\paragraph{First selection criterion: synthesisable Verilog} The primary reason Verilog is a large language is because Verilog essentially consists of two languages (with shared syntax and semantics):
%
\begin{enumerate}
\item \emph{Synthesisable Verilog}: the subset of Verilog used to describe the structure and behaviour of hardware designs (this is the ``hardware description'' part of Verilog), deriving its name from the fact it is the kind of Verilog code that synthesis tools accept.
\item \emph{Nonsynthesisable Verilog}: the subset of Verilog used to implement ``test benches'' for hardware designs, which provide stimuli-and-probe infrastructure.
\end{enumerate}

We focus on synthesisable Verilog because our ultimate interest is formal reasoning support for Verilog: in such reasoning, test benches are replaced by other stimuli-and-probe infrastructure. E.g., in model checking the stimuli-and-probe infrastructure might be an LTL or CTL formula.\footnote{Even outside the domain of formal reasoning, some approaches to hardware development replace Verilog test benches with other infrastructure. E.g., cocotb~\cite{cocotb} enables implementing test benches in Python instead of~(nonsynthesisable)~Verilog.} With that said, we do also include a small select subset of simple nonsynthesisable Verilog in~our~target~subset. %, such that we can easily provide stimuli to hardware designs within VV.

Fortunately, synthesisable Verilog constitutes a relatively small subset of Verilog. This is so even though we interpret ``synthesisable'' broadly in this work to protect against the fact that what kind of Verilog code is synthesisable is not officially codified anywhere. The Verilog standard does not comment on, much less codify, what kind of Verilog code is synthesisable. The previous Verilog synthesis standard~\cite{Verilog-synthesis-2005} is ``withdrawn'' without any new standard to replace it. Nevertheless, what kind of Verilog is synthesisable is relatively well-understood folklore.\footnote{Strictly speaking, what part of Verilog is synthesisable or not depends on one's synthesis tool and target technology. E.g., some target technologies support specifying initial values of registers whereas others do not. Because we interpret ``synthesisable'' broadly/generously, this does not cause any problems for us.}

%However, for this paper, these various flavours of ``synthesisable Verilog'' are similar enough that it is sufficiently precise to talk about ``synthesisable Verilog'' without specifying what synthesis tool or target technology we have in mind.

\paragraph{Second selection criterion: the Verilog event queue} As we discuss further in the subsequent sections, the semantics of Verilog is oriented around an event queue, and we are especially interested in exploring a representative subset of \emph{core concurrency constructs} of Verilog that have \emph{interesting semantics in terms of how they interact with this event queue}. In particular, Verilog contains many constructs for supporting programming-in-the-large~\cite{DeRemer75} (in contrast to programming-in-the-small), such as metaprogramming constructs and modules, which are used to structure large hardware developments. Programming-in-the-large constructs are important in real-world code but not for exploring the core concurrency semantics of Verilog, this is because such constructs are typically defined by elaboration and therefore do not complicate the event queue further compared to just considering programming-in-the-small constructs.

\paragraph{Third selection criterion: modules} We make one exception from our general rule (from the second selection criterion) of not considering programming-in-the-large constructs: we consider Verilog modules. Large Verilog developments typically consist of multiple modules (representing, e.g., arithmetic logic units, memories, etc.) instantiated into large module hierarchies. Although, like other programming-in-the-large constructs, modules are given semantics by elaboration, their elaboration is interesting both from the perspective of concurrency and the Verilog event queue.

\section{Background: Informal Simulation Semantics}%
\label{sec:informal-simulation-semantics}

In this section, we introduce Verilog's \emph{informal} simulation semantics, i.e., the semantics used in everyday Verilog development. By definition, there is no authoritative source specifying the informal simulation semantics. The discussion in this section is partly based on the Verilog standard and partly based on our best understanding of the Verilog folklore.

This section serves two purposes. First, for the reader not familiar with Verilog, it serves as a crash course on the Verilog background necessary to understand the rest of the paper. Second, it makes explicit a concurrency principle, which we call CP, assumed in everyday Verilog development. When discussing problems in the Verilog standard in subsequent sections, we show that CP is not respected by the standard.

Our discussion in this section covers our target subset of Verilog (Fig.~\ref{fig:syntax}). First, we discuss the semantics of ``intermodule'' Verilog (Sec~\ref{sec:informal-intermodule-simulation-semantics}), that is, the semantics of an individual module. Second, we discuss the semantics of ``intramodule'' Verilog (Sec~\ref{sec:informal-intramodule-simulation-semantics}), that is, the semantics of a set of modules.

%concurrency principle, which we call \CP, assumed in Verilog practice which we further into the paper show is broken by Verilog's simulation semantics as described by the standard (this is the problem we call \IP).

\subsection{Informal Intermodule Simulation Semantics}\label{sec:informal-intermodule-simulation-semantics}

%\polish{In particular, we give an informal introduction to the \emph{Verilog event queue}, the central construct used in the Verilog standard to give semantics to the construct of Verilog. How the informal descriptions of this section are realised in terms of the event queue and event-driven processes.}

%\paragraph{Restriction 1: synthesisable Verilog.} Recall that our ultimate aim is a mathematical formalisation of Verilog. The main usage of such a formalisation is to reason formally about Verilog hardware designs and tools manipulating and analysing Verilog hardware designs, for which only the subset of Verilog used to describe the structure and behaviour of hardware is relevant, i.e., the synthesisable subset of Verilog, which constitutes a relatively small subset of Verilog.\footnote{Strictly speaking, what part of Verilog is considered synthesisable or not depends on one's synthesis tool and what technology is targeted. E.g., some target technologies support specifying the initial values of registers whereas others do not. However, for our purposes here, these various flavours of ``synthesisable Verilog'' are similar enough that it is sufficiently precise to talk about ``synthesisable Verilog'' without specifying what synthesis tool or target technology we have in mind.}

%For our project here, we are therefore foremost interested in synthesisable Verilog. We do, however, include some nonsynthesisable constructs in VV -- e.g., delay constructs -- such that we run simple test benches inside VV, which is useful for exploring the semantics.

%\paragraph{Restriction 2: core concurrency semantics.} Moreover, not all of synthesisable Verilog is of immediate interest to us. ... Here, we are interested in the semantics of core constructs of synthesisable Verilog so ubiquitous that they cannot be avoided, such as different types of assignments: blocking assignments, nonblocking assignments, continuous assignments, etc. 

%\footnote{On the topic of how much of Verilog is covered by VV, we have also tested VV against the CHIPS Alliance Verilog test suite~\cite{chips-sv-test-suite}. The results are available in the \texttt{sv-tests-runner} directory in the source code repository of VV. However, the results are not particularly enlightening because the test suite contains many programming-in-the-large modules and very few programming-in-the-small modules.}

%Fig.~\ref{fig:syntax} gives the syntax of our target subset of Verilog. At the level of detail we will discuss the event queue and semantics in this section, the Verilog standard, Verilog practice, VV's semantics, Meredith et al.'s semantics, and Chen et al.'s semantics. are, to our best knowledge, largely in agreement.

In this section, we discuss the informal simulation semantics of intermodule Verilog.

\paragraph{Values.} For our target subset, Verilog values consist of bits and arrays of bits. Bits can take on four different values~\cite[p.~88]{SystemVerilog-2023}. All four are included in our target subset, see $b$ (Fig.~\ref{fig:syntax}). The value \texttt{x} is used for a multitude of purposes, often representing something like ``unknown value'', ``invalid value'', ``error'', or similar.\footnote{It is difficult to succinctly characterise precisely what role X values play in Verilog. E.g., Flake et al.~\cite{Flake2020} count eight different situations in where X values can arise.} The value \texttt{z} represents a high-impedance state and is used to model tristate logic, as discussed below.

% \footnote{Verilog allows for implicitly declared nets; anecdotally, many consider implicit nets to be a misfeature that introduces more problems than it solves. To allow us to focus on the core concurrency semantics of Verilog rather than surface syntax problems, we require all nets to be explicitly declared. This can be understood as \texttt{default\_nettype} being is set to \texttt{none} by default instead of \texttt{wire}~\cite[p.~685--686]{SystemVerilog-2017}.}

\paragraph{Data objects.} A data object in Verilog is a ``named entity that has a data value and a data type associated with it''~\cite[p.~88]{SystemVerilog-2023}. There are two main groups of data objects in Verilog: variables and nets. Our target subset includes both groups, see $\mathit{mi}$ (Fig.~\ref{fig:syntax}). Variables have the same semantics as variables in software languages, i.e., the last write to a variable determines its value. Nets have no analogue in software languages: the value of a net is determined by its set of ``drivers'', in our target subset, a set of continuous assignments, by net resolution, as we discuss below when discussing continuous assignments.

\paragraph{Processes} Verilog is a process-based concurrent language. Our target subset includes two types of processes, discussed below: procedural processes and continuous assignments. See,~again,~$\mathit{mi}$~(Fig.~\ref{fig:syntax}).

% We discuss these potentially less familiar faces further in subsequent sections, when we discuss the Verilog event queue in more detail. Expressions $e$ and statements $s$ include the usual imperative-software-language suspects, such as sequential sequencing and if statements. Statements $s$ also include potentially less familiar faces to software audiences, such as the various timing- and  used to coordinate process execution. Here, see example in Fig.~\ref{fig:alwaysexample} (left).

\begin{figure}[t]
\begin{minipage}[t]{0.33\textwidth}
\inputminted[fontsize=\small]{verilog}{alwaysexample1.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\small]{verilog}{alwaysexample2.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.33\textwidth}
\inputminted[fontsize=\small]{verilog}{alwaysexample3.sv}
\end{minipage}
%
\caption{Three code fragments for discussing the semantics of procedural processes.}%
\label{fig:alwaysexample}
\end{figure}

\paragraph{Procedural processes and variables} We explain procedural processes through examples. In short, procedural processes are similar to processes in traditional software languages: they come with a program counter, internal state, etc. Also like in traditional software languages, procedural processes execute in nondeterministic order. Procedural processes can only write to variables, not nets (since they cannot participate in net resolution, as discussed below).

Consider the left code fragment in Fig.~\ref{fig:alwaysexample}. The first line declares the variables \texttt{a}, \texttt{b}, \texttt{c}, and \texttt{d}, where \texttt{a} and \texttt{b} are given initial values and \texttt{c} and \texttt{d} are not and are therefore initialised with the value \texttt{x}. There are in total three procedural processes, arising from the \iver{initial} and \iver{always} blocks. An \iver{initial} block executes once and then terminates. An \iver{always} block executes over and over again in an infinite loop. The construct \iver{@(a, b)} in the first \iver{always} block is an event-control construct, which blocks the process until the value of \texttt{a} or \texttt{b} changes. The event-control construct \iver{@(c)} in the second \iver{always} block, similarly, causes the process to block until the value of \texttt{c} changes. A block can have multiple event-control constructs and they can occur anywhere in the block body. 

Blocks of \iver{always} type with only one event-control at the beginning of the block follow a simple concurrency principle, which we here call CP: such blocks are scheduled for execution each time a data object mentioned in the event-control changes. For example, this principle is useful when modelling combinational logic, that is, stateless logic. Because of CP, an \iver{always} block with only one event-control at the beginning of the block that lists all data objects the block depends on, like the first \iver{always} block (but unlike the second \iver{always} block) in our example here, is a good fit to model combinational logic. The semantics of such blocks coincide with the semantics of combinational logic because such blocks will (eventually) run with the latest values of its dependencies because such blocks are scheduled for execution each time a dependency changes.

To exemplify further, returning back to the left code fragment in Fig.~\ref{fig:alwaysexample}, given the above discussion, we see that one possible execution of the code fragment is that the \iver{initial} block runs first, updating \texttt{a}, thereby causing the first \iver{always} block to run, which in turn updates \texttt{c}, which in turn causes the second \iver{always} block to run, which updates \texttt{d}.

Now, consider the middle code fragment in Fig.~\ref{fig:alwaysexample}. This code fragment models sequential logic, that is, stateful logic. The first \iver{always} block is a behavioural model of a clock. The block uses the time-control construct \texttt{\#}\iver{1} to delay the effect of the assignment for one ``time slot'', a concept we will make more precise when introducing Verilog's simulation semantics in the next section. The two other \iver{always} blocks abide by the concurrency principle CP: i.e., the two blocks run every positive edge of the clock (\iver{posedge clk}), i.e., at every clock tick. The assignments inside the two blocks are nonblocking assignments (\iver{<=}) rather than blocking assignments (\iver{=}) as used in the left code fragment. This is to accurately model the semantics of hardware registers. In the example here, note that one block writes to \texttt{a} and another block reads from \texttt{a}. Nonblocking assignments delay the effect of their assignment until all other blocks have read the previous value; again, we will explain nonblocking assignments more precisely when introducing Verilog's~simulation~semantics~in~the~next~section.

Lastly, consider the right code fragment in Fig.~\ref{fig:alwaysexample}. The first \iver{always} block illustrates a convenient shorthand for modelling combinational logic: the block is equivalent to the first \iver{always} of the left code fragment in Fig.~\ref{fig:alwaysexample}. There are also \iver{always_comb}, \iver{always_ff}, and \iver{always_latch}, which are variants of \iver{always} which allow hardware designers to declare modelling intent (stating if the block models combinational logic, sequential logic, or latched logic, respectively). The right code fragment shows some example usages of these blocks. For our purposes here, \iver{always_comb} is the same as \iver{always_comb @(*)} except that it is guaranteed to always run at least once during the first time slot. The blocks \iver{always_ff} and \iver{always_latch} have the same semantics as \iver{always}.

% \footnote{In real code, \iver{always_comb} should always be used instead of \iver{always} to model combinational logic because of well-known problems associated with the latter that we do not cover here and do not matter for our discussion in this paper.}

\begin{figure}[t]
\begin{minipage}[t]{0.13\textwidth}
\inputminted[fontsize=\small]{verilog}{assign_example.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.33\textwidth}
\inputminted[fontsize=\small]{verilog}{wire_resolution.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\small]{verilog}{wand_resolution.sv}
\end{minipage}
%
\caption{Three code fragments for discussing the semantics of continuous assignments.}%
\label{fig:resolution}
\end{figure}

\paragraph{Continuous assignments and nets} We now explain continuous assignments, the second type of process we consider, again through examples. Consider the left code fragment in Fig.~\ref{fig:resolution}. The code fragment declares a net of type \iver{wire} and a continuous assignment \iver{assign} for the net. A continuous assignment induces a driver process which drives the current value of the expression of the assignment into a net or a variable. In the example, the continuous assignment drives \iver{inp + 1} into the net \iver{w}. Processes induced by continuous assignments are not like software-language processes: the only function of the driver process associated with a continuous assignment is to keep its driver value up-to-date by reevaluating the assignment expression every time a data object the expression depends on is updated. In other words, continuous assignments follow the same concurrency principle CP as simple \iver{always} blocks, although being a much simpler type of process since driver processes do not need a program counter or other internal state.

There is, however, a major difference between continuous assignments and \iver{always} blocks: continuous assignments can participate in net resolution. While a variable can have at most one driver; a net, in contrast, can have multiple drivers. If a net has multiple drivers, the values from the different drivers are merged using the resolution function of the net. Our target subset contains three types of nets: \iver{wire}, \iver{wand}, and \iver{wor}. E.g., for a \iver{wire} net, all drivers with value \texttt{z} are ignored in resolution, and all other drivers must have the same value, otherwise the net resolves to \texttt{x} -- see the middle code fragment in Fig.~\ref{fig:resolution}. A \iver{wand} net will, in contrast, resolve to the conjunction of the values of its drivers -- see the right code fragment in Fig.~\ref{fig:resolution}.

\paragraph{Other constructs} We introduce the remaining important constructs, such as \iverhack{$display} and \iverhack{$monitor}, in the next section, again by example.

%The execution of such processes is controlled by timing and event-control constructs. Such processes behave much like processes in a software language in the sense that they have a program counter and process-local state and they are interleaved in a sequentially consistent manner.

\subsection{Informal Intramodule Simulation Semantics}\label{sec:informal-intramodule-simulation-semantics}

\begin{figure}[t]
\begin{minipage}[t]{0.49\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{circuit.sv} (a) Hardware module
\newline
\begin{Verbatim}[fontsize=\footnotesize]
> iverilog -g2012 circuit.sv circuit_tb.sv
> ./a.out
time = 0 --> inp1 = x, inp2 = x, out = x
time = 1 --> inp1 = 1, inp2 = 0, out = x
time = 3 --> inp1 = 1, inp2 = 1, out = 1
time = 5 --> inp1 = 1, inp2 = 1, out = 0
circuit_tb.sv:22: $finish called at 6 (1s)
\end{Verbatim}
(c) Output from running the test bench \\ (the \texttt{-g2012} flag enables SystemVerilog \\ support)
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.49\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{circuit_tb.sv} (b) Test-bench module
\end{minipage}
%
\caption{Example hardware design \texttt{circuit} (a), test bench \texttt{circuit\_tb} (b), and test-bench output (c).}%
\label{fig:tbexample}
\end{figure}

% we consider a full Verilog example consisting of a circuit (i.e., a hardware model) and a test bench. 

In this section, we discuss the informal simulation semantics of intramodule Verilog. We again proceed by example: see the two modules in Fig.~\ref{fig:tbexample}, which consist of a hardware-design module \iver{circuit}, which is synthesisable, and a test-bench module \iver{circuit_tb}, which is not nonsynthesisable. The test-bench module \iver{circuit_tb} stimulates and probes the hardware module \iver{circuit} much like a real physical test bench would do. As shown in the example, modules can be instantiated inside other modules and connected up using the inputs and outputs of the modules. %We do not elaborate further on modules here since for our work in this paper it is sufficient to consider only one module at a time (since the semantics of modules are defined by simple elaboration).

The contents of the two modules in Fig.~\ref{fig:tbexample} consist mostly of constructs already discussed. We mention two things of note. First, the first \iver{initial} block of the test bench installs a ``monitor'', which prints its argument at the end of each simulation time slot. In our target subset, there is also a \iverhack{$display} function that prints its argument when called instead of at the end of each time slot. Second, the second \iver{initial} block of the test bench shows that event-control constructs can occur at any location in a block.

Given a hardware design and a test bench for the design, we can simulate the design in its test bench using a Verilog simulator such as Icarus~\cite{Icarus}. Doing so using Icarus gives the output shown in Fig.~\ref{fig:tbexample}. The output shown is the output of the monitor installed by the \iverhack{$monitor} invocation in the test bench.

%The test bench module is not synthesisable because of how timing and event controls are used to define the module: the clock is modelled using a delayed assignment and the input stimuli process contains multiple event controls.

\section{Background: Simulation Semantics}\label{sec:simulation-semantics}

% To implement a Verilog simulator is to implement the Verilog reference algorithm for simulation.

We now discuss Verilog's simulation semantics as defined by the Verilog standard. We focus on the \emph{Verilog event queue} -- the heart of the standard's description of the simulation semantics. The discussion in this section is intentionally short and only meant to give a high-level idea of the simulation semantics and introduce key terms (such as time slots and regions). We emphasise \emph{how} the standard defines the simulation semantics, which is important to understand in order to understand the problems we have found in the standard we that discuss in~subsequent~sections.

First, we discuss the intramodule simulation semantics (Sec.~\ref{sec:intramodule-simulation-semantics}). For this semantics, the standard defines the event queue and the rest of the simulation semantics by two components:
%
\begin{enumerate}
\item pseudocode for a ``reference algorithm for simulation'' in Sec.~4.5 of the standard, and
\item prose text at varying levels of detail (literally) sprinkled throughout the standard.
\end{enumerate}
%
The two components depend on each other and the pseudocode is not a complete description without the prose text and vice versa.

Second, we discuss the intermodule simulation semantics (Sec.~\ref{sec:intermodule-simulation-semantics}). This semantics is defined only by prose text. The prose text defines the intermodule semantics by elaboration to the intramodule semantics.

%. Our aim here is not to introduce the full semantics, but to introduce enough of \emph{how} the standard defines the semantics to be able to we discuss the two problems we have found in the standard. In other words, the purpose of this section is not to teach the reader not previously familiar with Verilog the full Verilog language, but to enable such reader to follow the discussion in subsequent sections of the paper.

\subsection{Intramodule Simulation Semantics}\label{sec:intramodule-simulation-semantics}

We give a brief summary of Verilog's intramodule simulation semantics by summarising the standard's description of the reference algorithm for simulation. The reference algorithm is an interpreter for Verilog, i.e., an operational semantics. The standard describes the reference algorithm at a high level and leaves the details of the algorithm to the imagination of its readers. The entry point of the algorithm is the following pseudocode function (all pseudocode in this section is from Sec.~4.5~of~the~standard):
%
\begin{Verbatim}[fontsize=\small]
execute_simulation {
 T = 0;
 initialize the values of all nets and variables;
 schedule all initialization events into time zero slot;

 while (some time slot is nonempty) {
  move to the first nonempty time slot and set T;
  execute_time_slot (T);
 }
}
\end{Verbatim}
%
The algorithm is oriented around events and maintains an event queue. The event queue is divided into ``time slots''. The variable \texttt{T} keeps track of the current time slot, or ``simulation time''. Each time slot is split into ``regions''. The following regions are relevant for our target subset of Verilog: active, inactive, NBA (``nonblocking assignment''), and observed.\footnote{The standard includes 17 regions in total. The regions not included here are used to give semantics to constructs that are out of scope here, e.g., the Verilog APIs to interoperate with, e.g., C code.} Time slots are executed by the pseudocode function \texttt{execute\_time\_slot}. After restricting the function to the regions relevant here, the function is as follows:
%
\begin{Verbatim}[fontsize=\small]
execute_time_slot {
 while (any region in [Active ... Observed] is nonempty) {
  execute_region (Active);

  R = first nonempty region in [Active ... Observed];
  if (R is nonempty)
   move events in R to the Active region;
 }
}
\end{Verbatim}
%
That is, until all regions are empty, the events of the first nonempty region are moved to the active region and executed. The pseudocode function \texttt{execute\_region} for executing regions is as follows:
%
\begin{Verbatim}[fontsize=\small]
execute_region {
 while (region is nonempty) {
  E = any event from region;
  remove E from the region;

  if (E is an update event) {
   update the modified object;
   schedule evaluation event for any process sensitive to the object;
  } else { /* E is an evaluation event */
   evaluate the process associated with the event and possibly schedule
   further events for execution;
  }
 }
}
\end{Verbatim}
%
That is, the events of a region are executed in nondeterministic order and execution is driven by processes creating events -- update events -- and reacting to events -- evaluation events. The details of scheduling new events and executing events in the queue are described only by prose text. In short, most events are scheduled in the active region, exceptions include zero-delayed events which are scheduled in the inactive region, updates from nonblocking assignments which are scheduled in the NBA region, and \iverhack{$monitor} invocations which are scheduled in the observed region.

%\paragraph{Example execution (1)} Consider again the left Verilog fragment of Fig.~\ref{fig:alwaysexample}. There are in total three procedural processes, arising from the \iver{initial} block and the two \iver{always} blocks. At initialisation, all processes with be in state \texttt{ProcStateRunning} and all regions of the event queue are empty except the active region which will contain three events \texttt{EventEvaluation} (one per process). Say the two \texttt{EventEvaluation} events for the \iver{always} processes are picked for execution: the two processes execute their respective event-controls \iver{@(a, b)} and \iver{@(c)}, which put both processes into state \texttt{ProcStateWaiting}. Now, say that the \texttt{EventEvaluation} event for the \iver{initial} process is picked: the process updates \texttt{a} to \iver{1}, which will schedule a new \texttt{EventEvaluation} in the active region for the first \iver{always} block, because that process is waiting for \texttt{a} to change. After executing the \iver{initial} process, the process is now in state \iver{ProcStateFinished}. There is now only one event in the active region: the \texttt{EventEvaluation} event for the first \iver{always} block that was scheduled by the \iver{initial} process. Executing the first \iver{always} block again will update \texttt{c}, put the process back to waiting for \texttt{a} to change again (i.e., put the process into state \texttt{ProcStateWaiting}), and schedule a new \texttt{EventEvaluation} event in the active region for the second \iver{always} process since that process was waiting for \texttt{c} to change. After the execution of the second \iver{always} block, there are no more events to be processed and the~simulation~ends.

%\paragraph{Example execution} We now consider an example execution to aid understanding. Consider again the middle Verilog fragment of Fig.~\ref{fig:alwaysexample}. Say that the input \texttt{inp} is a constant \texttt{1}. In the first time slot of simulation, no change to any variable will occur: the first \iver{always} block will block because of the time-control \texttt{\#}\iver{1} and schedule an \texttt{EventDelayedEvaluation} event for the process in active region of the next time slot; the two other \iver{always} processes enter state \texttt{ProcStateWaiting} waiting for a positive clock edge. (If the delay would have been zero instead, i.e., \texttt{\#}\iver{0}, then the \texttt{EventDelayedEvaluation} event would have instead been scheduled in the inactive region of the same time slot.) Because all regions of the first time slot are now empty, simulation time progresses to the next time slot. Now, the only event available in the active region is the \texttt{EventDelayedEvaluation} of the first \iver{always} block, which is now executed, updating \texttt{clk} to 1, and the process blocks again and schedules a new \texttt{EventDelayedEvaluation} event in the next time slot. The update of \texttt{clk} wakes up the two other \iver{always} blocks, which are waiting for a positive clock edge. Since the assignments of the two blocks are nonblocking, the processes do not update the variables directly but instead schedule two events \texttt{EventNBA("a", 1)} and \texttt{EventNBA("b", 0)} in the NBA region of the current time slot and then goes back to waiting for the next positive clock edge. Importantly, note that \texttt{b} will be updated with the value \texttt{0} because the update to the variable \texttt{a} has not yet been committed. There are now no more events in the active region, so the NBA events are moved to the active region.\footnote{In the next section, we discuss a problem with this part of the semantics. Here we follow the pseudocode as described in the standard, not, e.g., the semantics implemented in VV.} Now, the two \texttt{EventNBA} events in the active region are ready to be executed: doing so sets \texttt{a} to \texttt{1} and \texttt{b} to \texttt{0}. There are now no more events in the current time slot, so simulation time is progressed to the next time slot, where an \texttt{EventDelayedEvaluation} is scheduled for the first \iver{always}. The simulation then continues like described forever since the clock continues forever.

\subsection{Intermodule Simulation Semantics}\label{sec:intermodule-simulation-semantics}

In the Verilog standard, Verilog's intramodule simulation semantics is specified through prose-text-described elaboration (primarily in Sec. 23 of the standard, called ``Modules and hierarchy''). In this paper, we are only interested in the part of elaboration relevant to concurrency. In short, the core of the concurrency-relevant part of the elaboration boils down to the following relatively simple rules: an \iver{input} port induces a continuous assignment from outside the module to inside the module; an \iver{output} port induces a continuous assignment in the opposite direction; and an \iver{inout} port induces a ``non-strength-reducing transistor'' between the outside of the module and the inside (we discuss \iver{inout} ports further in Sec.~\ref{sec:intermodule-problems}). For example, consider again Fig.~\ref{fig:tbexample}: when the module \iver{circuit} is instantiated in the module \iver{circuit_tb}, the \iver{input} port \iver{clk} induces a continuous assignment \iver{assign circuit.clk = clk}, where the left-hand side \iver{circuit.clk} refers to the variable \iver{clk} of the instantiated module \iver{circuit}.

Examples of intermodule constructs we are not interested in here (because they do not relate to concurrency) are convenience constructs to define modules, convenience constructs to instantiate modules, and meta-programming constructs (e.g., parameterised modules and the \iver{generate} construct). For example, consider again Fig.~\ref{fig:tbexample}: using module instantiation convenience constructs, the module instantiation in the module \iver{circuit_tb} can equivalently be written as \iver{circuit circuit(.clk, .inp1, .inp2, .out)} or (the even shorter) \iver{circuit circuit(.*)}.

%% \begin{verbatim}
%% - Similarly, convenience for instantiating modules... e.g. "ports by name", ".*", etc.
%% - ``non-ANSI header and the ANSI header'' + convenience for defining modules... (e.g.: ``If the direction is omitted, it shall default to \iver{inout}.'', borrow some examples 736, maybe mh14)
%% - ``Default port values'' = no interesting semantics, only constant expression
%% - simple meta-programming: 
%% \end{verbatim}

%% \begin{quote}
%% Ports can always be represented as declared objects connected as follows:
%% %
%% \begin{itemize}
%% \item If an input port, then a continuous assignment from an outside expression to a local (input) net or variable
%% \item If an output port, then a continuous assignment from a local output expression to an outside net or variable
%% \item If an inout port, then a  connecting the local net to an outside net
%% \end{itemize}
%% \end{quote}

%\begin{itemize}
%\item Most of process execution happens in the active region. E.g., executing a nondelayed blocking assignment, say \iver{y = 1}, updates the variable/net \iver{y} and notifies other processes waiting in the active region for updates, e.g., a process wanting at a statement \iver{@(posedge y)} if \iver{y} was, e.g., \texttt{0} before. Executing a (nonzero-)delayed blocking assignment, say \texttt{\#5}\iver{ y = 1} or \texttt{y = \#3}\iver{ 1}, schedules an event in a future time slot's active region relative to the current time.
%\item Zero-delayed statements, however, such as \texttt{\#0}\iver{ y = 1}, are scheduled in the inactive region of the current time slot.
%\item Nonblocking assignments also schedule events outside the active region: such assignments schedule update events in the NBA region (of the current time slot, or of a future time slot if the assignment is delayed). Scheduling events in the NBA region enables nonblocking assignments to be used for communication between processes since they do not race with events scheduled in the active region, such as most other aspects of process execution.
%\item Lastly, in our target subset of Verilog, the observed region is only used by the \iverhack{$monitor} system task, to print values at end of time slots.
%\end{itemize}

%In VV's subset of Verilog, processes are induced by continuous assignments (\iver{assign}) and initial and always blocks (\iver{initial} and \iver{always} and its variants, such as \iver{always_comb}).

%As the standard states, ``[a] SystemVerilog description consists of connected threads of execution or processes.''

%Verilog standard~\cite{SystemVerilog-2017} defines a ``scheduling semantics'' for Verilog, more commonly referred to as Verilog's ``simulation semantics''.\footnote{We are here only concerned with capturing the scheduling semantics as defined by the standard, not Verilog's so-called synthesis semantics -- see Lööw~\cite{Loow22} for a longer discussion on the relationship between Verilog's two semantics.} Verilog's semantics is concurrent and event driven, in the sense that

%Consider for example the line saying ``update the modified object'' -- to flesh out this line we need to clarify what kind of ``objects'' are available and what it means to ``modify'' them. Ultimately, it is important to have a fleshed out idea of the reference algorithm since a simulator tool is correct if and only if ``the user-visible effect [of the simulator tool] is consistent with the reference algorithm.''

%\subsection{Verilog's stratified event queue}

\section{Problems in the Verilog Standard}%
\label{sec:problems}

We now discuss the problems we have found in the Verilog standard (that previous work on formalising Verilog have not already addressed). Again, we discuss intramodule Verilog (Sec.~\ref{sec:intramodule-problems}) and intermodule Verilog~(Sec.~\ref{sec:intermodule-problems})~separately. In our discussion, we consider multiple \emph{sources of truth} and highlight discrepancies between them and the standard. Our discussion is based on the latest Verilog standard, i.e., SystemVerilog-2023~\cite{SystemVerilog-2023} (there is no separate active standard for Verilog only, Verilog has been merged into SystemVerilog).

\paragraph{First source of truth: Verilog practice} Our first source of truth is ``Verilog practice'', where we use Verilog's informal simulation semantics (outlined in Sec.~\ref{sec:informal-simulation-semantics}) and Verilog simulators as proxies for ``Verilog practice''. For our discussion on Verilog simulators, we consider both open-source and closed-source simulators. The two most popular open-source simulators are Icarus~\cite{Icarus} and Verilator~\cite{Verilator}. However, for our work here, only Icarus is relevant since Verilator does not (directly) implement Verilog's simulation semantics but instead prioritises performance over standard conformance (Verilog designs are simulated by compilation to C++/SystemC and the implemented semantics has more in common with Verilog's synthesis semantics, which is out of scope for this paper, than its simulation semantics). Our discussions are based on Icarus version 12.0. As for closed-source simulators, we consider Aldec Riviera Pro 2023.04, Cadence Xcelium 23.09, Mentor Questa 2023.3, and Synopsys VCS 2023.03.\footnote{Which are the simulators that were available at \url{https://edaplayground.com} at the time of writing.} Of course, for the internals and behaviour of closed-source simulators, we can only provide informed guesses.

\paragraph{Second source of truth: Verilog-2005} Our second source of truth is, perhaps surprisingly, the latest pre-SystemVerilog Verilog standard, i.e., Verilog-2005~\cite{Verilog-2005} (which we refer to by said name). Although the Verilog-2005 standard is officially superseded by the latest SystemVerilog standard, we believe it is meaningful to compare the two because the Verilog-2005 standard is still in use. For example, some recent work on Verilog, such as the main reference point of our work, Chen et al.~\cite{Chen23} (from 2023), published after the publication of the first SystemVerilog standard still uses the Verilog-2005 standard as its basis. The problems we highlight in this section show that even if one is only interested in a ``Verilog subset'' of SystemVerilog, one should use the latest SystemVerilog standard to avoid problems in the older versions of the standard that have been fixed in the latest version of the standard. For example, (as we show) some of the test cases that fail in Chen et al.'s evaluation of their semantics fails exactly for this reason.

\paragraph{Third source of truth: formalisations of Verilog} Our third source of truth is previous work on the formal semantics of Verilog. Although taking into consideration that they both formalise the old standard Verilog-2005~\cite{Verilog-2005}, our two main reference points are Chen et al.~\cite{Chen23} and Meredith et al.~\cite{Meredith10}, which are the two most comprehensive formalisations of Verilog.

\paragraph{Discarded sources of truth} Lastly, we want to clarify what Verilog problems we are \emph{not} interested in. Verilog, as it deserves, has a bad reputation. We believe this bad reputation is a result of, what we call, ``pragmatic shortcomings'' of Verilog; that is, commonly misunderstood aspects of Verilog (pitfalls/quirks/etc.) that arise from Verilog's, at times, antipedagogical design. Such shortcomings are relatively well understood and documented in a variety of formats, ranging from online rants (informed to varied degrees) to books such as \textit{Verilog and SystemVerilog Gotchas: 101 Common Coding Errors and How to~Avoid~Them} by Sutherland and Mills~\cite{Sutherland07}. In contrast, what we are interested in are, what we call, ``semantic shortcomings'' of Verilog; that is, inconsistencies and other types of problems that can be found in the standard that render the actual semantics of the language unclear. Whereas the pragmatic shortcomings of Verilog are relatively well understood and can be resolved by a careful reading of the standard, the semantic shortcomings we highlight in this work are novel to this work. With that said, to be clear, this is not to say that pragmatic shortcomings do not constitute a problem -- it is only to say that they are not of primary interest for our work because they are not blockers for formal reasoning.

%To clarify what we mean by pragmatic shortcomings, we now discuss some oft-cited grievances of Verilog that have \emph{not} been problems in our work with the Verilog standard.

%SUMMARY HERE -- maybe mention X semantics here? problem for synthesis... in general simulation-synthesis mismatches... 

%we show that the current two state-of-the-art formalisations of Verilog, i.e.,  and , do not address the problems adequately.

\subsection{Intramodule Problems}\label{sec:intramodule-problems}

We discuss five intramodule problems that we have found in the Verilog standard. We call these problems PREEMPT, ALWAYS\_START, VAR\_INIT, NB\_ORDER, and NB\_MIX. We summarise how our different sources of truth handle these problems in Tab.~\ref{tab:overview}.

\begin{table}[t]
\centering
\caption{A summary of the Verilog problems we have identified in this paper. In the leftmost column, ``SV standard'' refers to SystemVerilog-2023~\cite{SystemVerilog-2023} and ``V standard'' refers to Verilog-2005~\cite{Verilog-2005}. ``--'' in any column means not mentioned. In the PREEMPT column, ``NO*'' means ``NO'' with minor exceptions (discussed in the main text of the paper). In the ALWAYS\_START column, ``NO'' means no special treatment of combinational \iver{always} blocks. For the VAR\_INIT column, see the discussion on VAR\_INIT in the main text for the meaning of INITIAL and FIRST. In the NB\_ORDER and NB\_MIX columns, NONE means that no order is enforced. In the NB\_ORDER column, ``ALL/SAME''  means that, inconsistently, both SAME and ALL are specified.}
\small
\begin{tabular}{lccccc}
 \toprule
 \textbf{Source of truth} & \textbf{PREEMPT} & \textbf{ALWAYS\_START} & \textbf{VAR\_INIT} & \textbf{NB\_ORDER} & \textbf{NB\_MIX} \\
 \midrule
 Pseudocode in SV standard & -- & -- & FIRST & NONE & NONE \\
 Prose text in SV standard & YES & NO & FIRST & ALL/SAME & BLOCK \\
 Pseudocode in V standard & -- & -- & -- & NONE & NONE \\
 Prose text in V standard & YES & NO & INITIAL & ALL/SAME & BLOCK \\
 Icarus~\cite{Icarus} & NO* & CUSTOM & FIRST & ALL & ALL \\
 Closed-source simulators & NO* & CUSTOM & FIRST & ALL & ALL \\
 Chen et al.~\cite{Chen23} & YES & NO & INITIAL & ALL & NONE \\
 Meredith et al.~\cite{Meredith10} & YES & NO & INITIAL & ALL & NONE \\
% Our best guess & NO & ALL & VAR & ALL & ALL \\
 \bottomrule
\end{tabular}
\label{tab:overview}
\end{table}

The problems PREEMPT, ALWAYS\_START, and VAR\_INIT are concurrency problems and, importantly, the main problems causing test-case failures for Chen et al. in their evaluation (see Sec.~\ref{sec:chen}). The two problems NB\_ORDER and NB\_MIX are also concurrency problems, specifically relating to the semantics of nonblocking assignments. These two problems seem to not have caused problems in previous work, instead, we found the two problems by ``visually debugging'' executions using our new visual Verilog simulator VV (which we explain further in Sec.~\ref{sec:vv} after having introduced VV).

%by writing small Verilog test modules to try out corner cases of the semantics of Verilog and then interactively running them in VV until we saw something suspicious or unexpected occur, which caused us to investigate further. We now describe the two problems we have identified and moreover

%\polish{incompatible semantics of hardware and with current practice of Verilog...}

\subsubsection{PREEMPT}

%This, however, interacts badly with the event-control constructs of Verilog.

The most severe problem we have identified is that the interleaving semantics of concurrent processes specified by the standard breaks the concurrency principle CP of the informal simulation semantics (introduced in Sec.~\ref{sec:informal-simulation-semantics}), that is, is incompatible with Verilog practice. The problem, as we illustrate below, arises from the fact that the standard~\cite[p.~69]{SystemVerilog-2023} allows arbitrary interleavings by specifying that Verilog processes work by preemptive multitasking (in contrast to cooperative multitasking):\footnote{Essentially the same text has been in the standard since the very first version of the standard~\cite[p.~47]{Verilog-1995}.}
%
\begin{quote}
[...] statements without time-control constructs in procedural blocks do not have to be executed as one event. Time control statements are the \# expression and @ expression constructs (see 9.4). At any time while evaluating a procedural statement, the simulator may suspend execution and place the partially completed event as a pending event in the event region. The effect of this is to allow the interleaving of process execution [...].
\end{quote}

%(The two modules are essentially equivalent, except, recall, that an \iver{always_comb} block is guaranteed to run at least once in the first time slot whereas an \iver{always} does not enjoy this guarantee.

\paragraph{Minimal examples} We illustrate the problem with minimal examples. Consider the modules \iver{interleave1} and \iver{interleave2} in Fig.~\ref{fig:interleave}. The second module \iver{interleave2} is a variant of the first module \iver{interleave1} using \iver{always} instead of \iver{always_comb}, which we include here to illustrate that the problem we illustrate here happens regardless of what type of block is used. Per the discussion in Sec.~\ref{sec:informal-simulation-semantics}, the \iver{always_comb}/\iver{always} blocks of the two modules model combinational logic and should respect CP.\footnote{The \iver{initial} blocks for the purpose of this example can be seen as fragments of a combinational block (e.g., \iver{always_comb}).} In other words, according to CP, \iver{c} must equal \iver{a + b} in quiescent states. Because of the interleaving semantics specified by the standard (the text quoted above), \emph{the standard does not guarantee this}. Indeed, the following interleaving of \iver{interleave2} is allowed by the standard:
%
\begin{enumerate}
\item The \iver{always} process executes the \iver{@(a, b)} event control and starts waiting.
\item The \iver{initial} process executes \iver{a = 0}, which wakes up the \iver{always} process. The \iver{initial} process then preempts.
\item The \iver{always} process executes \iver{c = a + b}, which sets \iver{c} to \texttt{x} because \texttt{b} has not yet been assigned anything (and is therefore \texttt{x}), and then preempts.
\item The \iver{initial} process executes \iver{b = 1} and terminates. The \iver{always} process does not register the update event to \iver{b} since the process is not in a waiting state.
\item The \iver{always} process then continues execution by directly going into waiting since it again has reached its \iver{@(a, b)} event control.
\end{enumerate}
%
There are now no more events to execute, but $\mathtt{c} \neq \mathtt{a + b}$. Effectively, the \iver{always} process ``missed'' the update to the variable \iver{b}. Similar problematic interleavings can be constructed for \iver{interleave1}.

\begin{figure}[t]
\center
\begin{minipage}[t]{0.25\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{interleave1.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.25\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{interleave2.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.25\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{interleave3.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.23\textwidth}
\begin{minted}[fontsize=\footnotesize]{verilog}
// [...]

always_comb begin
 out1 = in1a;
 out2 = in2a;
 case (sel)
  cond2: out2 = in2b;
  cond3: out1 = in1c;
 endcase
end

// [...]
\end{minted}
\end{minipage}
\caption{Example Verilog code to illustrate the problem with the interleaving semantics specified~by~the~standard.}\label{fig:interleave}
\end{figure}

Another problematic example is given by the module \iver{interleave3} in Fig.~\ref{fig:interleave}. Clearly, an interleaving analogous to the problematic interleaving of \iver{interleave2} can be constructed for \iver{interleave3}. Therefore, the standard breaks \iver{interleave3} as well. Double assignments like in the \iver{initial} block happen in real Verilog code, e.g., they can arise from a common coding-style used to avoid inferring latches. E.g., the code in Fig.~\ref{fig:interleave} to the very right is example 4.5c ``case with defaults listed before case statement'' from Mills~\cite{Mills12} which illustrates this coding-style. In the code, note that both \texttt{out1} and \texttt{out2} can be assigned multiple times in the block.

\paragraph{Realistic examples}

\ifarxiv
In App.~\ref{app:interleavings},
\else
In the appendix of the extended version of this paper~\cite{extended},
\fi
 we provide problematic examples consisting of a synthesisable module and a test bench, to show that the problem not only occurs in artificial examples written to illustrate problems.

%Hence, contrary to what the standard suggests, not all interleaving can be allowed. At the same time, if we look at existing simulators, it is not the case that no interleavings ever occur. More precisely, we are not aware of any situations in where two procedural processes are preempted and interleaved in existing simulators, but we are aware of situations where procedural processes are interleaved with continuous assignments. One such situation is illustrated by the \iver{continterleave} module in Fig.~\ref{fig:interleave}. Some existing simulators print \iver{b = x} followed by \iver{b = x} whereas other existing simulators print \iver{b = x} followed by \iver{b = 1}. We are not aware of problems caused by interleaving procedural processes and continuous assignments.

%VV only interleaves processes when they block; see the cited paper for further details. In short, the standard seems contradictory and it appears that the semantics of Verilog breaks down if arbitrary interleavings are allowed. VV must therefore diverge from the standard for its interleaving semantics. Other interesting aspects of execution of concurrent processes in Verilog included in VV's example collection include, e.g., the semantics of self-triggering.

\paragraph{Possible fixes} The above examples show that allowing unconditional preemption breaks Verilog's informal simulation semantics. Some condition must therefore be put on when preemption is allowed. One alternative that is attractive because of its simplicity is to not allow any preemption at all, i.e., require cooperative multitasking. This change is not as disruptive as it might at first appear: as we survey below, today's simulators seem to, with minor exceptions, already implement cooperative multitasking.

\begin{figure}[t]
\center
\begin{minipage}[t]{0.35\textwidth}
\begin{minted}[fontsize=\footnotesize]{verilog}
module continterleave;

logic i, o1, o2;

// "Simple" continuous assignment
assign o1 = i;

// "Nonsimple" continuous assignment
assign o2 = i + 1;

initial begin
 $display("i = %b, o1 = %b, o2 = %b",
          i, o1, o2);
 i = 1;
 $display("i = %b, o1 = %b, o2 = %b",
          i, o1, o2);
end

endmodule
\end{minted}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.35\textwidth}
\begin{minted}[fontsize=\footnotesize]{verilog}
module bufinterleave;

logic i, o1, o2;

// Similar to "assign o1 = i;"
buf (o1, i);

// Similar to "assign o2 = !i;"
not (o2, i);

initial begin
 $display("i = %b, o1 = %b, o2 = %b",
          i, o1, o2);
 i = 1;
 $display("i = %b, o1 = %b, o2 = %b",
          i, o1, o2);
end

endmodule
\end{minted}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.2\textwidth}
\begin{minted}[fontsize=\footnotesize]{verilog}
module infiniteloop;

logic a;  
  
always
 if (a == 1) $finish;

initial
 a = 1; 
  
endmodule
\end{minted}
\end{minipage}
%
\caption{Two modules illustrating minor interleaving exceptions in existing simulators.}\label{fig:interleavings-simulators}
\end{figure}

% (We discuss further in App.~\ref{app:icarus}.)

\paragraph{Current simulators} First, by inspecting the source code of Icarus we see that processes are not interleaved (i.e., execute until they block),\footnote{See the comments and implementation of the main entrypoint for process execution, \texttt{vthread\_run}, at \url{https://github.com/steveicarus/iverilog/blob/v12_0/vvp/vthread.h\#L66} and \url{https://github.com/steveicarus/iverilog/blob/v12_0/vvp/vthread.cc\#L843}.} with one minor exception: simple continuous assignments may be interleaved. To illustrate that Icarus can interleave simple continuous assignments, consider \texttt{continterleave} in Fig.~\ref{fig:interleavings-simulators}. When the module is run in Icarus, we get the following output:
%
\begin{verbatim}
i = x, o1 = x, o2 = x
i = 1, o1 = 1, o2 = x
\end{verbatim}

Second, based on small-scale systematic testing that we have carried out (the tests and the results of the tests are included in the artefact of this paper), it appears that today's closed-source simulators do not interleave processes except for minor exceptions. To exemplify, we mention two of these minor exceptions. The first minor exception is given by Synopsys VCS: the simulator appears to interleave \iver{initial} blocks and continuous assignments. E.g., when running the module \texttt{continterleave} in Fig.~\ref{fig:interleavings-simulators} in Synopsys VCS we get the following output:
%
\begin{verbatim}
i = x, o1 = x, o2 = x
i = 1, o1 = 1, o2 = 0
\end{verbatim}
%
That is, different from the above Icarus execution of the same module, both continuous assignments are interleaved. This is a minor exception in the sense that if the \iver{initial} block is replaced with, e.g., an \iver{always_comb} block with the same body, then the continuous assignments are not interleaved. The second minor exception is given by Aldec Riviera Pro: the simulator appears to interleave \iver{buf} processes, a gate-level construct similar to continuous assignments. E.g., when the module \texttt{bufinterleave} in Fig.~\ref{fig:interleavings-simulators} is run in Aldec Riviera Pro we get the following output:
%
\begin{verbatim}
i = x, o1 = x, o2 = x
i = 1, o1 = 1, o2 = x
\end{verbatim}
%
This is a minor exception in the sense that other gate-level constructs appear to not be interleaved, e.g., as we see above, \iver{not} processes. Different from the Synopsys VCS minor exception, Aldec Riviera Pro interleaves the \iver{buf} process even if the \iver{initial} block is replaced by an \iver{always_comb} block. Lastly, if the \iver{buf} gate is replaced by an analogous continuous assignment, as specified in the comments in the module, then Aldec Riviera Pro does not interleave the block and the replacement continuous assignments.

Third, the module \texttt{infiniteloop} in Fig.~\ref{fig:interleavings-simulators} provides another way to test if today's closed-source simulators preempt processes. Aldec Riviera Pro, Cadence Xcelium, and Mentor Questa all loop forever when asked to simulate the module. Most likely, the blocks are scheduled in source code order and the first block never preempts, thereby not giving the second block a chance to execute and end the simulation. The three simulators do not loop forever when the order of the blocks is reversed in the source code. Synopsys VCS, on the other hand, never loops forever. It is unclear why: the simulation ends even if the \iver{initial} block is commented out.

\paragraph{Previous work} Both Chen et al.'s and Meredith et al.'s Verilog semantics follow the standard to the letter and allow for arbitrary interleavings. For example, both semantics allow for problematic interleaving sequences of \iver{interleave3} from Fig.~\ref{fig:interleave}. 
\ifarxiv
In App.~\ref{app:executions},
\else
In the appendix of the extended version of this paper~\cite{extended},
\fi
 we demonstrate this for both semantics.

%Both Meredith et al. and Chen et al. notice that there are concurrency issues in their semantics. Our above discussion on the problem \IP explains why the standard is to blame for these problems, as we now elaborate.

%Meredith et al. consider a module \iver{netassign} (see their Fig.~5) similar to our module \iver{interleave3} in Fig.~\ref{fig:interleave} where the block \iver{always_comb b = a} has been replaced by a continuous assignment \iver{assign b = a}. Because they have misunderstood the semantics of nets, thinking nets have the same semantics as variables, they initially treat continuous assignments as alternative syntax for \iver{always} blocks: ``[t]he best we can glean from the standard is that a [continuous] assignment should perform essentially as an \iver{always} block with one blocking assignment in it [...].'' They notice that this semantics gives problematic interleavings, but do not address the source of the problem (that is, \IP): instead, they implement a fix for continuous assignments and then forget to address the problem they have indirectly discovered for \iver{always} blocks. In result, modules like our \iver{interleave3} are left broken in their semantics.

%We do not see not changing the standard as realistic, given that, as we have shown above, even such simple code as the \iver{interleave} module requires additional synchronisation when arbitrary interleavings are allowed (in this case, just because of a combinational block depends on other combinational block in the module).

\begin{figure}[t]
\center
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{always_start.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{var_init1.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{var_init2.sv}
\end{minipage}
\caption{Three example modules illustrating problems relating to the start of simulation.}\label{fig:init}
\end{figure}

\subsubsection{ALWAYS\_START} Another problem that breaks CP is the problem we call ALWAYS\_START, which relates to the first-cycle semantics of combinational blocks. To exemplify, we consider the module \iver{always_start} in Fig.~\ref{fig:init}: according to the semantics specified by the standard, this module can print \texttt{00x}, i.e., \texttt{c} can still be uninitialised at the end of simulation. This obviously breaks CP and can happen because the \iver{initial} block can execute and terminate before the \iver{always} block executes the \iver{@(a)} event control. In contrast, \texttt{b} cannot be uninitialised at the end of simulation because an \iver{always_comb} block must run at least once during the first simulation cycle. Indeed, this is one of the reasons \iver{always_comb} was introduced in the language. Introducing a new block type does, however, not solve the original problem: since \iver{always} blocks cannot be used to soundly model combinational logic, the construct should have been deprecated for this usage when \iver{always_comb} was introduced.

To work around the ALWAYS\_START problem, Icarus implements a custom execution ordering that ensures that combinational \iver{always} blocks enter waiting before other blocks start executing.\footnote{See \url{https://github.com/steveicarus/iverilog/blob/v12_0/elaborate.cc\#L6064}.} The closed-source simulators we consider, except Cadence Xcelium, seem to implement a similar approach: they all print \texttt{000}. Cadence Xcelium prints \texttt{00x} and prints \texttt{000} when the \iver{initial} block is moved after the \iver{always} block. Both Chen et al.'s and Meredith et al.'s semantics allow the~output~\texttt{00x}.

\subsubsection{VAR\_INIT} Although not a problem of the most recent standard, the problem we call VAR\_INIT has caused problems in previous work on formalising Verilog (discussed below). To illustrate the problem, consider the module \iver{var_init1} in Fig.~\ref{fig:init}. According to the most recent standard, this module can only print \texttt{0}. This is because initialisation is defined to happen before any process begins (see the pseudocode in Sec.~\ref{sec:simulation-semantics}). In Tab.~\ref{tab:overview}, we call this semantics FIRST. In Verilog-2005 (see Sec.~6.2.1 of the standard), on the other hand, variable initialisation is defined by elaboration to an \iver{initial} block with an assignment: i.e., \iver{var_init1} would be elaborated to the module \iver{var_init2} in Fig.~\ref{fig:init}. In Tab.~\ref{tab:overview}, we call this semantics INITIAL. In this earlier semantics, the module \iver{var_init1} has a race: the module can print either \texttt{1} or \texttt{x} since the elaborated \iver{initial} block can execute either before or after the display block.

This change in the semantics appears to not be well-known: Chen et al. implement the (broken) Verilog-2005 semantics. Seemingly unaware of VAR\_INIT, they misattribute resulting failures in test cases to races in the test cases.

\subsubsection{NB\_ORDER}

The semantics of nonblocking assignments specified by the pseudocode of the reference algorithm for simulation (discussed in Sec.~\ref{sec:simulation-semantics}) and the semantics specified by the prose text in the standard are not consistent with each other: the reference algorithm does not offer the same order guarantees for nonblocking assignments as the prose text. Whereas the function \texttt{execute\_time\_slot} of the pseudocode suggests that executing NBA events is a simple matter of moving all NBA events from the NBA region to the active region, the prose text of the standard suggests that executing NBA events is more involved.

\begin{figure}[t]
\center
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{nbinterleave1.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{nbinterleave2.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{nbinterleave3.sv}
\end{minipage}
\caption{Three example modules illustrating problems relating to nonblocking assignments.}\label{fig:nbproblem}
\end{figure}

A defining characteristic of the active region is that its events are allowed to execute in any order, hence, doing what the pseudocode suggests and simply move all NBA events to the active region does not guarantee any order between the NBA events when executed. This is inconsistent with the prose text, which provides order guarantees. Which order guarantees should be provided is, however, unclear since the prose text is inconsistent with itself and specifies two different order guarantees. On page~69 of the standard, an order guarantee we call NB\_ORDER\_ALL is given: NBA events, \emph{unconditionally}, ``shall be performed in the order the [nonblocking assignments] were executed''. On page~254 of the standard, an order guarantee we call NB\_ORDER\_SAME is given: ``[t]he order of the execution of distinct nonblocking assignments to a given variable shall be preserved'', i.e., only the order of NBA events \emph{for the same variable} is required to be preserved. To exemplify, consider the module \iver{nbinterleave1} in Fig.~\ref{fig:nbproblem}. Enforcing either NB\_ORDER\_ALL or NB\_ORDER\_SAME, the module must print \texttt{1}. Enforcing neither, the module can print either \texttt{0} or \texttt{1}. Clearly, one of NB\_ORDER\_ALL or NB\_ORDER\_SAME must be enforced: much of today's Verilog code would break if \iver{nbinterleave1} would be allowed to print \texttt{0}.

We discuss how our different sources of truth handle this problem after having introduced the next problem, NB\_MIX, since the two problems are interrelated.

%The second major problem we have run into is that the pseudocode function \texttt{execute\_time\_slot} in the reference algorithm is misleading. Specifically, in what semantics the pseudocode function suggests for nonblocking assignments. 

%For illustration of the first reason, consider the two modules \iver{binterleave} and \iver{nbinterleave} in Fig.~\ref{fig:interleave}. If interleavings of procedural processes are disallowed, then \iver{binterleave} will only ever print nothing or \iver{a = 1}, never \iver{a = 0}. Now, consider what output should be allowed for the \iver{nbinterleave} module. In VV, executing the first block in \iver{nbinterleave} schedules two events in the NBA region of the current time slot, specifically, the \texttt{nba} field of the current time slot will be \texttt{[EventNBA("a", 0), EventNBA("a", 1)]} after execution. After the second block has entered its waiting state, according to \texttt{execute\_time\_slot}, since both the \texttt{active} and \texttt{inactive} fields are empty, the contents of the \texttt{nba} field should be moved to the \texttt{active} fields. 

%Therefore, additional structure is needed to keep track of NBA order dependencies in the queue. There are, of course, multiple ways to keep track of these order dependencies: for VV, we adapt the solution proposed by ... In VV, we call the group event type \texttt{Events}, see the definition of the \texttt{event} data type above. Executing an \texttt{Events} event removes the first (sub)event from the event but leaves the event itself, unless the list of events was a singleton list, in which case the event is removed after execution. All in all, continuing the example, in VV, after moving the NBA events to the active region, the NBA region is empty and the active region is \texttt{[Events([EventNBA("a", 0), EventNBA("a", 1)])]}.

\subsubsection{NB\_MIX} The prose text of the standard enforces another order guarantee of NBA events not enforced by the pseudocode. The following prose text can be found on page~253 of the standard, specifying an order guarantee we call \nomixblocking:\footnote{Another unrelated problem: note that the quoted text has not been updated for SystemVerilog, specifically, assignments in the reactive region set execute after assignments in the active region set. The same text occurs in the Verilog-2005 standard~\cite[p.~120]{Verilog-2005}. This is not of great importance here since the reactive region set is out of scope for our work.}
%
\begin{quote}
[...] nonblocking assignments are the last assignments executed in a time step---with one exception. Nonblocking assignment events can create blocking assignment events.~These blocking assignment events shall be processed after the scheduled~nonblocking~events.
\end{quote}
%
I.e., the execution of blocking and nonblocking assignments must not be mixed. As far as we can tell, the standard does not comment on other types of events mixing with NBA events. E.g., is the execution of the \iverhack{$display} statement in \iver{nbinterleave2} in Fig.~\ref{fig:nbproblem} allowed to mix with the execution of the nonblocking assignments? That is, should it be possible for the module to print twice or just once? For later discussion, we call the order guarantee that disallows all mixing \nomix.

\paragraph{Possible fixes} For NB\_ORDER, at least for the subset of Verilog we consider here, enforcing \nomix, which we believe should be enforced per the below discussion, resolves the dilemma of which of \orderall and \ordersame should be enforced: given \nomix, \orderall and \ordersame have no externally observable difference between them. To exemplify, consider \iver{nbinterleave3} in Fig.~\ref{fig:nbproblem} and assume that \nomix is enforced: now, we see that all possible executions under both \orderall and \ordersame give the same output.

For NB\_MIX, what order guarantee should be enforced is less clear: should no order guarantee, \nomixblocking, or \nomix be enforced? We believe there are advantages to enforcing \nomix: this is because enforcing \nomix makes the interleaving behaviour of nonblocking assignments consistent with the interleaving behaviour of procedural processes. We illustrate by example: consider again \iver{nbinterleave2} and \iver{nbinterleave3} from Fig.~\ref{fig:nbproblem}. With either no order guarantee or \nomixblocking, the modules \iver{nbinterleave2} and \iver{nbinterleave3} are able to invoke the \iverhack{$display} call multiple times. In contrast, if all the nonblocking assignments of \iver{nbinterleave2} and \iver{nbinterleave3} are replaced by blocking assignments, then the modules would only be able to invoke \iverhack{$display} at most once. That is, nonblocking assignments under no order guarantee or \nomixblocking have more interleavings than the corresponding blocking assignments would. Enforcing \nomix rules out such ``extra'' interleavings, making the interleaving behaviour of nonblocking assignments and procedural processes more consistent.

\paragraph{Current simulators} Icarus enforces both NB\_ORDER\_ALL and \nomix.\footnote{See \url{https://github.com/steveicarus/iverilog/blob/v12_0/vvp/schedule.cc\#L1119}.} Icarus moves all NBA events from the NBA region to the active region when the active region and inactive region are empty, exactly as specified by the pseudocode of the standard. Despite simply moving the NBA events to the active region, because Icarus executes all events in the active region in FIFO order, the simulator enforces both \orderall and \nomix.

All closed-source simulators we have tested give the same output for the three modules from Fig.~\ref{fig:nbproblem}, specifically, \texttt{1} for \iver{nbinterleave1}, \texttt{1} for \iver{nbinterleave2}, and \texttt{1, 1} for \iver{nbinterleave3}, indicating that no reordering or mixing has taken place. We have not managed to find an example of where an existing simulator reorders NBA events or mixes them with other events.

\paragraph{Previous work} Neither Meredith et al. nor Chen et al. highlight the two nonblocking-assignment inconsistencies we highlight here. Nevertheless, both Meredith et al.'s and Chen et al.'s semantics enforce \orderall. Meredith et al.'s semantics, when moving NBA events in the NBA region to the active region, maintain the order among the NBA events by grouping all NBA events into a group event containing all the NBA events and move this group event to the active region instead of each individual NBA event. In the active region, the events contained inside NBA group events are executed in order. Chen et al. take a bigger step away from the pseudocode and maintain the order of NBA events by spawning a new procedural process containing all writes of the NBA region instead of moving events between regions; we have found no support for this behaviour in the standard. None of \nomixblocking and \nomix are maintained by Meredith et al.'s or Chen et al.'s semantics. 
\ifarxiv
In App.~\ref{app:executions},
\else
In the appendix of the extended version of this paper~\cite{extended},
\fi
 we demonstrate using examples how Meredith et al.'s and Chen et al.'s semantics handle nonblocking assignments.

%We now continue our discussion on what output is allowed by the \iver{nbinterleave} module to illustrate the second reason for why \texttt{execute\_time\_slot} is misleading. The answer to our \iver{nbinterleave} question, it turns out, depends on whether NBA events and other events are allowed to mix; in other words, (similarly to the first major problem) how much interleaving between events is allowed. Specifically, executing the first event of the \texttt{Events} will schedule an evaluation event for the second block, more precisely, an \texttt{EventEvaluation} event. 

%Now, is the new \texttt{EventEvaluation} event allowed to execute before the remaining NBA event in the \texttt{Events} event? The function \texttt{execute\_time\_slot} suggests that this is allowed, since it simply moves all NBA events to the active region. 

%In VV, whether the execution of NBA events can be interleaved by other types of events is controlled by the checkbox ``Process NBA events first'' in the left-most column of the interface. It is checked by default, not allowing NBA events to be interleaved.

%\subsubsection{NET-INIT} MAYBE ADD NET-INIT AS WELL? delay as mentioned in Chen et al. -- probably diff from simulators?

\subsection{Intermodule Problems}\label{sec:intermodule-problems}

We discuss two intermodule problems we have found in the Verilog standard. These two problems are not as severe as the intramodule problems discussed in the previous section, but should nevertheless be addressed in the standard. Both problems relate to Chen et al.'s previous work on formalising Verilog. Although Chen et al., like all other previous work on Verilog, do not capture the intermodule semantics formally, they capture the intermodule semantics in their Java implementation of their semantics. The second problem we discuss here (relating to port coercion) shows up in their evaluation of their semantics.

%The intermodule simulation semantics of Verilog is defined by elaboration. The main idea in this elaboration: connect up different modules with continuous assignments.

%Again, foremost interested in the concurrency semantics and the Verilog event queue. I.e., we are interested in how multiple modules connect up. Various meta-programming constructs, not interesting.

%To provide the first steps towards a formalisation of the intermodule semantics, we present pseudocode that captures the intermodule semantics.

%We first highlight problems in the standard we have run into when developing our pseudocode and then present our pseudocode.

%Some examples here...

%\subsection{Standard problems}

%The problem we have found in the intermodule semantics is not as severe as the problem we have found in the intramodule semantics but should nevertheless be addressed.

%Worth commenting on Chen et al.'s problems since not caught by the large set of authors of the paper or during the review process of the paper.

\subsubsection{Semantics of \iver{inout} Ports}

One part of the intermodule semantics of Verilog that seems to have caused confusion in earlier work on formalisation is the semantics of \iver{inout} ports. Chen et al. claim they have ``discovered'' what they call the ``alias semantics'' of \iver{inout} ports: they handle ``inout port connections by replacing all occurrences of aliased nets with a fresh uniformed name''. This, however, is different from how the standard specifies the semantics of \iver{inout} ports -- which Chen et al. appear to have missed. This indicates that the standard should be clarified on this point. For our target subset of Verilog, a port for a module can be either an \iver{input} port, an \iver{output} port, or an \iver{inout} (bidirectional) port. Whereas the standard specifies that \iver{input} ports and \iver{output} ports are elaborated to continuous assignments, an \iver{inout} port is instead elaborated to a bidirectional connection ``analogous to an always-enabled \iver{tran} connection between the two nets, but without any strength reduction''. (We do not cover strength reduction in this paper, see the standard for more information.)

%Moreover, the elaboration of \iver{inout} ports is problematic for two reasons. First, the only discussion on the semantics of \texttt{tran} we could find in the standard is the following (p.~840): ``The \texttt{tran} [...] devices shall have terminal lists containing two bidirectional terminals. Both bidirectional terminals shall unconditionally conduct signals to and from the devices, allowing signals to pass in either direction through the devices.'' . Secondly, .

\begin{figure}[t]
\center
\begin{minipage}[t]{0.49\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{coercion_in.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.49\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{coercion_out.sv}
\end{minipage}
%
%\hfill
%
%\begin{minipage}[t]{0.32\textwidth}
%\inputminted[fontsize=\footnotesize]{verilog}{inoutex.sv}
%\end{minipage}
\caption{Intermodule simulation semantics problems.}\label{fig:intermodule}
\end{figure}

\subsubsection{Port Coercion} A second thorny issue is, what the standard calls, port coercion. The standard specifies that ``[a] port that is declared as input (output) but used as an output (input) or inout may be coerced to inout. If not coerced to inout, a warning shall be issued.'' What is meant by ``used as'' an input or output is not clear from this text. We illustrate by example: consider the left subfigure in Fig.~\ref{fig:intermodule}. In the subfigure, the \iver{input} port of \iver{coercion_in} must be coerced into an \iver{inout} port since the module writes to it. However, the \iver{output} port of the same module does \emph{not} need to be coerced even though the module is reading from it. This is because reading an output port is different from the port being ``used as'' an input port. To contrast, the right subfigure in Fig.~\ref{fig:intermodule} illustrates using an \iver{output} port as an \iver{input} port -- i.e., the write should come from outside the module. All the simulators we consider print \texttt{x} when running \iver{coercion_out_top}, indicating that the continuous assignment outside the module reaches inside the module despite the \iver{outp} port being declared an \iver{output} port. Unfortunately, Chen et al. get the distinction between ``used as'' an input port and reading a port inside a module wrong (see the discussion in Sec.~\ref{sec:chen}). The standard should therefore be clarified on this point.

%- Port connection rules, we highlight two interesting ones. rules largely similar to the rule of continuous assignments.

%``dissimilar net types (net and port collapsing)'' (e.g., connecting a \iver{wire} net and a \iver{wand} net). port coercion...

%\subsubsection{Port coercion vs. net type check}

\section{Verilog Formalisations}%
\label{sec:formalisations}

In this section, first, we discuss how we have repaired Chen et al.'s semantics based on the problems in the Verilog standard we have pinpointed in the previous section, second, we introduce our new visual Verilog simulation tool VV.

%\polish{Pseudocode formalisation -- repaired reference algorithm... say not included because of lack of space...}

\subsection{Mathematical Formalisation: Repaired Chen et al. Semantics}%
\label{sec:chen}

To test their semantics, Chen et al. run their Java implementation of their semantics on a selection of test cases from the Icarus test suite and a small collection of real-world test suites, including tests for parts of a RISC-V processor. Chen et al. run into problems with test cases from both types of test suites. For the Icarus tests, Chen et al. report 116 failing tests out of 824 tests~\cite[Fig.~1]{Chen23b}. For the real-world tests, some of the tests only work under their semantics in the sense the test cases \emph{can} pass, by running the test cases multiple times until an appropriate schedule happens to be selected, rather than passing every run (which is what happens when the tests are run in using a standard Verilog simulator).

Chen et al.'s evaluation results can be significantly improved with small changes to the Java implementation. Directed by the discussion in Sec.~\ref{sec:problems}, we have modified the Java implementation (as documented in the artefact of the paper) to disable process preemption, ensure that combinational \iver{always} blocks execute at least once in the first time slot (like \iver{always_comb}), and to implement SystemVerilog semantics for variable initialisation. Below, we discuss the results of re-running the test suites with this updated Java implementation.

\paragraph{Icarus test suite} Re-running the Icarus test suite, only 23\footnote{We have removed the test \texttt{sqrt32.v} identified as broken by Chen et al. and reverted changes to \texttt{pr1913918b.v} and \texttt{pr1777103.v} by Chen et al. relating to port coersion.} tests now fail (compared to 116 before). The failing tests are summarised in Tab.~\ref{tab:test-cases} and we explain in more detail below why the remaining failing tests do not indicate any major remaining problems in the repaired semantics for executing hardware designs (i.e., synthesisable Verilog). In the below discussion, the ``(five) simulators'' we refer to are the five simulators introduced in Sec.~\ref{sec:problems}.

\begin{wraptable}{r}{0.35\textwidth}
%\vspace{-0.4cm}
\caption{Classification of failing tests, see further discussion in main text.}
\begin{tabular}{lc}
 \toprule
 \textbf{Type of failure} & \textbf{Num.} \\
 \midrule
 Start race & 4 \\
 Order race & 2 \\
 Other race & 3 \\
 Port coersion & 5 \\
 Net delay initialisation & 1 \\
 PCA & 8 \\
 \bottomrule
\end{tabular}
\label{tab:test-cases}
%\vspace{-1cm}
\end{wraptable}

%\polish{We also extend Chen et al.'s evaluation by considering a larger set of simulators for failing tests... they primarily use Icarus as the proxy for Verilog practice -- we refer to these as ``the five simulators''}

\begin{figure}[t]
\center
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{almost_comb.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{fifo.sv}
\end{minipage}
%
\hfill
%
\begin{minipage}[t]{0.32\textwidth}
\inputminted[fontsize=\footnotesize]{verilog}{net_delay.sv}
\end{minipage}
\caption{Simplified failing test cases.}%
\label{fig:test-cases}
\end{figure}

% mention something about sqrt32.v here! has an overflow problem, we ignore that problem here.

%The remaining failing test cases consist of problems already explained by Chen et al. (e.g., \texttt{sqrt32.v}), relates to the misunderstanding about port coercion discussed earlier in the paper (e.g., \texttt{bufif.v}), relates to constructs we do not consider in this paper (e.g., \iver{force} in \texttt{pr1832097b.v}), or are genuine races (e.g., \texttt{br991a.v} fails in Icarus if the source-code order of the blocks in the file is changed).

\paragraph{Icarus test suite: race problems} Race problems have the potential to be interesting since our main focus is concurrency. However, none of the tests failing because of race problems are synthesisable (e.g., uses delays) and are, hence, out of immediate interest -- we nevertheless discuss them briefly below.

%% Start race

The five tests grouped under ``start race'' (\texttt{pr1570451b.v}, \texttt{pr1956211.v}, \texttt{pr2470181b.v}, and \texttt{pr2597278.v}) fail because of races at the start of simulation. Consider the module \texttt{almost\_comb} in Fig.~\ref{fig:test-cases}, which we have constructed to illustrate the common problem among the failing test cases. Should \texttt{b} in the last output from the monitor be allowed to be \texttt{x}? (Cadence Xcelium does allow this output, the other four simulators appear not to.) In other words, should there be a principle that ensures that the \iver{always} block in the example starts waiting before the first \iver{initial} block runs? We do not discuss further since our immediate interest here~is~synthesisable~code.

%% Order race

The two tests grouped under ``order race'' (\texttt{sdw\_dsbl.v} and \texttt{vardly.v}) succeed in all five simulators but fail in Chen et al.'s semantics. Consider the module \texttt{fifo} in Fig.~\ref{fig:test-cases}, again constructed to illustrate the common problem among the failing test cases. Must \texttt{a} in the last output from the monitor be \texttt{3}? (All five simulators' last output is \texttt{a = 3}.) This is only ensured if the events of the active region are executed in first-in-first-out order. This is a very strong order guarantee and indicates that the tests lack sufficient synchronisation.

%Most likely what happens in both the test cases and \texttt{fifo} is that the events in the active region are executed in first-in first-out order -- which results in a smaller set of schedules than considering all possible event orders. Without a first-in-first-out order guarantee, the tests fail and they therefore fail in Chen et al.'s semantics.

%Order guarantee: if added to the active region before, it is executed before. The standard does not specify such guarantee.

%All five simulators print a = 3 in the last time slot, indicating that the write \iver{a = 2} always happens before the write \iver{a = 3}

% \footnote{If first block is \polish{FIX}:\iver{initial begin #5; #5 a = 3; end} Synopsys seem to merge the waits and print ``2'' since the delayed 3 write is scheduled before if the blocks are scheduled in execution order.}

%% Other race

The three tests grouped under ``other race'' (\texttt{br991a.v}, \texttt{pr1662508.v}, and \texttt{undefined\_shift.v}) clearly lack sufficient synchronisation. E.g., both \texttt{br991a.v} and \texttt{pr1662508.v} fail even in Icarus if the source code order of the blocks of the tests are changed.

%-- nothing ensures that nets are updated before they are checked

\paragraph{Icarus test suite: port coersion problems} Five tests fail because of problems related to port coersion (grouped under ``port coersion''). Three of the tests (\texttt{bufif.v}, \texttt{pr1777103.v}, and \texttt{pr1913918b.v}) fail because \iver{output} ports are read, which Chen et al.'s semantics incorrectly disallows (recall the discussion in Sec.~\ref{sec:intermodule-problems}). The tests pass in all five simulators. All tests pass in Chen et al.'s semantics when refactored to not read from \iver{output} ports. The test \iver{br1001.v} fails because Chen et al. have chosen to not implement Sec.~23.3.3.7 of the standard. Lastly, the test \iver{gate_connect1.v} fails because array expressions are used as inputs to primitive gates. As the comment in the test file says, ``[t]he standard is quiet about [array expressions as inputs for primitive gates], but the consensus among other simulators is that the [least-significant bit] of the expression is used.'' Indeed, the test passes in all five simulators.

%, and, e.g., if the offending \iver{output} port in \texttt{bufif.v} is replaced by an \iver{inout} port the test passes in as well.

\paragraph{Icarus test suite: net delay initialisation problem} The single test of the group ``net delay initialisation'', \texttt{ldelay1.v}, passes in all five simulators but fails in Chen et al. semantics. We illustrate the problem using a simplified example, see \iver{net_delay} in Fig.~\ref{fig:test-cases}. As Chen et al. highlight, the standard should be more clear on what the value of the net \texttt{w} should have before time step 10, specifically, the value driven the \iver{assign} of the example. Whereas Chen et al. semantics prints ``\texttt{w = z}'' followed by ``\texttt{w = 0}'', there appears to be consensus in Verilog practice that the initial driven value should be \texttt{x}, indeed, all five simulators print ``\texttt{w = x}'' followed by ``\texttt{w = 0}''.

\paragraph{Icarus test suite: PCA problems} The tests grouped under ``PCA'' use procedural continuous assignments~\cite[Sec.~10.6]{SystemVerilog-2023}, which are outside our target scope and the tests are therefore not of immediate interest to us. See Chen et al.~\cite[Sec.~3.2.2]{Chen23b} for more discussion.

\paragraph{Real-world test suite} Re-running the real-world tests, all tests now appear to pass every run. Unfortunately, because Chen et al.'s state space exploration tool does not scale, it is only possible to run the real-world tests by running them multiple times with randomly selected schedules rather than exhaustively enumerating the entire reachable state space.

\paragraph{Conclusion} In conclusion, with only minor changes to Chen et al.'s Java implementation, the implementation is turned into an implementation compatible with Verilog practice and real-world hardware designs (as represented by the test suites included in the evaluation). Here, we have only worked with the Java implementation of Chen et al.'s semantics since that is the version of the semantics needed to run the evaluation. Applying the analogous simple fixes to Chen et al.'s mathematical formalisation (i.e., the inference rules presented in their paper) turns the formalisation into the first formalisation compatible with Verilog practice.

%% #Failed: 16
%% #Timeout: 0
%% #Unsupported: 0
%% #Exception caught: 4

%% bufif.v: stricter-type-checker
%% br1001.v: stricter-type-checker
%% gate_connect1.v: ambiguity unmatched-ports
%% sqrt32.v: err-case

%% ldelay1.v -- value before first net assignmen
%% (pr1777103.v -- port problem)
%% sdw_dsbl.v -- race
%% undefined_shift.v -- race

%Chen et al. also notice that their semantics give raise to problematic interleavings. Chen et al. evaluate their semantics by using it to run the test suite of Icarus and other real-world test suites (including a small RISC-V processor). Chen et al. notice that 99 of the Icarus tests fail under their semantics because of (according to their own diagnosis) too many interleavings. However, instead of blaming the standard for allowing too many interleavings, they blame the test cases for having insufficient synchronisation. Our discussion on the problem \IP above puts this blame into question: given that allowing arbitrary interleavings breaks even very simple modules like \iver{interleave1}, \iver{interleave2}, and \iver{interleave3} in Fig.~\ref{fig:interleave} -- it is no surprise that modules from the Icarus test suite and elsewhere break as well. That is, our discussion on the problem \IP puts the blame onto the standard and suggests that the test modules fail under Chen et al.'s semantics not because the modules are broken but because \emph{Chen et al.'s semantics accurately captures the interleaving semantics specified by the Verilog standard} which in turn does not capture Verilog practice (which leads to the test modules failing).

%In App.~\ref{app:interleavings}, to exemplify, we show and discuss one of the Icarus test modules that fail in Chen et al.'s evaluation. and the modifications Chen et al. did to the test modules to make them pass. %, confirming that \IP is to blame for these test failure.

\subsection{Visual Formalisation: VV}%
\label{sec:vv}

%\url{https://github.com/andreasloow/vv}.

%\polish{We have implemented VV in ReScript~\cite{rescript}, an OCaml dialect of JavaScript, }

We now discuss VV, the new visual Verilog simulation tool we have built. Below, we discuss the interface of VV, give some comments on the implementation of VV, and give an example of how VV has been useful to us to ``visually debug'' the Verilog standard. VV implements and visualises Verilog's simulation semantics, including the reference algorithm for simulation and the algorithm's associated event queue (discussed in Sec.~\ref{sec:simulation-semantics}). VV supports our target subset of Verilog (Fig.~\ref{fig:syntax}), except modules and arrays (which we found would not make VV's implementation of the event queue more interesting). 

%We have created a set of test modules (at the time of writing, 130 modules) we have created during the development of VV, they can be loaded using the drop-down menu in the top-left of the interface of VV. The modules illustrate different aspects and corner-cases of the semantics~of~Verilog.

%To implement the semantics of Verilog in VV is to flesh out and implement the three pseudocode functions \texttt{execute\_simulation}, \texttt{execute\_time\_slot}, and \texttt{execute\_region} from the standard introduced in the previous section. We now report on the two major problems we ran into in this process.

%VV is available at \url{https://github.com/anonymous/anonymous} and the \texttt{README.md} file contains a link to a website where the tool is live.

%VV is bundled with a small collection of test modules (at the time of writing, 130 modules), which can be loaded into VV using the drop-down menu to the top-left of the interface. We created the test modules in the process of implementing and experimenting with VV, and the modules illustrate different aspects and corner-cases of the semantics of Verilog. The test modules also include a short series of introductory modules forming a mini-tutorial on how to use VV and some of the basics~of~Verilog.

\begin{figure}[t]
\centering
\includegraphics[width=\textwidth]{screenshot.png}
\caption{A screenshot of VV.} %The third column (from left) visualises the current state of the Verilog event queue, as we explain in more detail, in Sec.~\ref{sec:vv}, after having introduced Verilog's simulation semantics in more detail, in Sec.~\ref{sec:simulation-semantics}~and~onwards.}
\label{fig:screenshot}
\end{figure}

\paragraph{The interface of VV} Fig.~\ref{fig:screenshot} contains a screenshot of VV. The interface of VV is as follows, from left-to-right:
%
\begin{enumerate}
\item The first column of the interface contains a drop-down menu with a small collection of test modules (at the time of writing, approximately 130 modules, which we have created during the development of VV) and the source code of the currently selected test module -- the source code can also be manually edited instead of loading a predefined test module.
\item The second column contains the normalised result of parsing the module in the first column.
\item The third column contains the current state of the simulation. In more detail, from top-to-bottom: the current simulation time (and simulation status), the current state of all variables and nets, the current state of all continuous assignments (i.e., net drivers), the current state of all procedural processes, the current event queue, and the currently~installed~monitor~(if~any).
\item The fourth column contains the module output of the run so far (from, e.g., \iverhack{$display} and \iverhack{$monitor} calls).
\end{enumerate}

Simulation in VV is driven by the user clicking the next simulation step to happen. Possible next steps for the simulation are marked in blue in the third column of the interface, e.g., an event in the event queue ready to execute or the simulation-time text when the current time slot is empty and the simulation is ready to progress to the next nonempty time slot. E.g., in the screenshot in Fig.~\ref{fig:screenshot}, there is one blue-marked active event. Clicking the blue event causes VV to execute the event and update the event queue and other simulation state accordingly. After executing the clicked event, the simulator goes back into waiting for the next user decision. If needed, e.g., when there are multiple events to choose from, execution can be restarted by re-parsing the module.

%In short, during the executing of a module, VV provides a visualisation of the Verilog event queue and the events currently scheduled in its various regions. All execution is driven by users clicking the next event to execute.

\paragraph{Implementation of VV} VV can be run in any web browser without any setup needed. We have implemented VV in ReScript~\cite{rescript}, an OCaml dialect of JavaScript. We have used React~\cite{react} for the front-end of VV and Ohm~\cite{ohm} for parsing Verilog source code. The most important part of VV is its implementation of its simulation-state representation, in particular, the Verilog event queue. We have tried to capture the description of the standard, taking into consideration both previous work on formalising Verilog and the problems we have pinpointed in this paper. We describe the simulation-state representation of VV in more detail in 
\ifarxiv
App.~\ref{app:vv}.
\else
the appendix of the extended version of this paper~\cite{extended}.
\fi
Regarding the problems we have highlighted in this paper: VV does not allow preemption and enforces both NB\_ORDER\_ALL (using the trick by Meredith et al. described earlier in the paper) and NB\_MIX\_NO. Other implementation details of VV are not particularly interesting; the rest of VV is a simple and straightforwardly implemented event-driven interpreter, which required no particular ingenuity to implement. 

% Developing VV and running small test modules inside the tool has helped us understanding Verilog better. 

\paragraph{How VV has been useful to us} One example of how VV has been useful to us is the problem NB\_MIX. The reason we discovered this problem is that we were executing different test modules in VV (essentially playing around with the tool), and two of them happened to be the module \texttt{nbinterleave2} from Fig.~\ref{fig:nbproblem} and the analogous module with blocking assignments. Using a version of the tool that did not enforce any order between nonblocking events and other active events, the tool's visualisation of the simulation state in combination with the tool's ability to interactively execute modules made it immediately clear that the nonblocking-assignment version of the module allowed for more interleavings than the blocking-assignment version of the module, which we thought was strange and led us to investigate what order guarantees the standard specifies, which in turn ultimately led us to discover the problem we now call NB\_MIX.

%Our main reason for going with ReScript is that we wanted a language that compiles to the web so that our tool would be easily available to everyone without the need for any setup or other obstacles. Traditionally, targeting the web meant JavaScript programming. Today, there are many options for targeting the web. We initially considered TypeScript, a variant of JavaScript with a Java-like static type system. However, TypeScript does not have good support for algebraic data types and pattern matching -- important features, in our opinion, for developing readable interpreters. We therefore went looking for web language with a more functional feel, and found ReScript. ReScript is a JavaScript variant instead inspired by (the functional language) OCaml, and has support for algebraic data types and pattern matching. Furthermore, ReScript has good integration with the JavaScript library React for building user interfaces (ReScript compiles to JavaScript, and can hence interoperate with JavaScript code), and we therefore went with React for the front-end of our tool. Other implementation languages and user interface libraries would have been viable choices as well, but ultimately we are happy with the choices we made.

%The implementation of the tool itself is not particularly exciting. Since our primary aim is conformance with the standard rather than e.g. performance, the implementation is expressed directly in the concepts introduced in the previous section. ReScript's standard library makes this doable since it includes the standard data structures one expects in a functional(-inspired) language and other high-level languages, such as list and maps.

%The interpreter code and the user interface code is fully separated from each other. The interpreter implementation is a traditional interpreter, with the exception that mutable state is fully avoided to allow for stepping back and forth in history. Avoiding mutation is sometimes awkward in ReScript, especially for deeply nested records, given the lack of e.g. something similar to Haskell's lens library. To record the history of executions, we follows the same implementation approach as illustrated by the game in the React tutorial available (at the time of writing) on the React web page: we simply keep an array of all states up until the current state, and React makes it simple show the various stored states. (That this kind of going back and forth in history is so simple to implement is part of the reason we went with React for our front-end.)

\section{Related Work}\label{sec:related-work}

%\polish{have not found an instance of when visualisation has been used to explore a semantics rather than as a tool build by people with a good understanding of the language to educate beginners.}

We discuss related work, including previous Verilog formalisations and visualisations.

% being a by-product of our visual investigation of the Verilog standard

% Their semantics does, however, not include support for X and Z values. Moreover, Meredith et al. have misunderstood the difference between variables and nets, and as a result do not include proper support for nets in their semantics. Thereby, they (unwittingly) do not take into consideration net-specific features such as multidriven nets. They do, on the other hand, consider arrays, which we do not include. 

\paragraph{Formalising language standards} Running into problems in language standards is not as uncommon as one might expect. In theory, a standard is the ultimate authority on the semantics of the language it standardises. In practice, less so -- as previous work exemplifies, formalising language standards is rarely as straightforward as theory suggests it should be. Memarian et al.~\cite{Memarian16,Memarian19}, in their work on formalising C, argue and give examples showing that the practice of C (what they call the ``de facto standards'' of C) and the ISO standard for C are out of sync with each other; or, in their own words: ``properties of C assumed by systems code and those implemented by compilers have diverged, both from the ISO standards and from each other, and none of these are clearly understood.'' To address this problem, they consult and balance an eclectic collection of sources of truth: the ISO standard, existing C code, experimental data from compilers, and survey and interview answers about C from systems programmers and compiler writers. These kinds of problems are not unique to C: Bodin et al.~\cite{Bodin14}, in their work on formalising JavaScript (arguably a much simpler language than C), to make sense of the semantics of JavaScript, had to consult not only the JavaScript standard but also browser implementations of JavaScript, discussion groups such as es-discuss, and the official ECMA test suite test262.

\paragraph{Verilog formalisations.} Chen et al.'s~\cite{Chen23} Verilog semantics is to date the most complete formalisation of the Verilog standard, specifically, the Verilog-2005 standard~\cite{Verilog-2005}. Chen et al. present their semantics by inference rules and also implement their semantics in Java, e.g., they have built a state-space explorer. Before Chen et al.'s semantics, the most complete formalisation was the formalisation by Meredith et al.~\cite{Meredith10}. Meredith et al.'s semantics is implemented in the K framework~\cite{Rosu10}, which allows for the generation of, among other tools, interpreters and model checkers. Gordon's~\cite{Gordon95} early work on Verilog semantics is another project of note. The project covers many important Verilog features, such as nonblocking assignments and delays. The presentation of Gordon's semantics is, however, informal (and, in places, nonstandard): the semantics is presented in prose form. Lastly, the work-in-progress paper by Lööw~\cite{Loow22b} reports on early work on the results presented in this paper.

 % (and furthermore, hence, is not executable).

% Nets are included as well, but restricted to a single driver.

%Meredith et al.'s target subset of Verilog is similar to our target subset of Verilog. 

%As we have discussed in this paper, there are issues in how they formalise the interleaving semantics of \iver{always} blocks and similar blocks. Chen et al. target a larger subset of Verilog than us since they are not, like us, foremost interested in the core concurrency semantics of synthesisable Verilog. As we have discussed in this paper, their semantics have problems with how to handle the interleaving semantics of \iver{always} blocks and similar blocks.

%Both Meredith et al.'s and Chen et al.'s semantics are executable. Meredith et al.'s semantics is executable because it is implemented in the K framework, . Chen et al. make their semantics executable by manually implementing it in Java.

%Another Verilog project that emphasises executability is Bowen et al.~\cite{Bowen00} (although instead referring to the same concept as their semantics being ``animatable''). They formalise Verilog in the logic programming language Prolog, enabling printing traces of Verilog executions. Their supported subset of Verilog is minimal: e.g., they do not discuss~features~such~as~nonblocking~assignments~or~nets.

Other previous projects on the semantics of Verilog we are aware of do not follow the standard as closely as Chen et al., Meredith et al., and Gordon. We consider those projects to be either suggestions for alternative semantics for Verilog (rather than formalisations of the standard semantics) or semantics derived from the standard semantics designed to aid formal reasoning. %\polish{Examples include e.g. Choi~\cite{Choi24}, AND ADD MORE HERE!!!}

%\paragraph{Verilog simulators.} Multiple Verilog simulators exist today, such as the simulators shipped with large commercial hardware development environments such as Xilinx Vivado~\cite{vivado} and the open-source simulator Icarus Verilog~\cite{Icarus} and Verilator~\cite{Verilator}.

\paragraph{Verilog visualisations.} Our new visual simulator VV visualises Verilog's simulation semantics, including the event queue of Verilog. To our best knowledge, no existing Verilog simulator allows for its event queue to be inspected, whereas in VV it is the main function of the tool.\footnote{Not even the Verilog APIs (PLI/VPI) defined by the standard that allow ``foreign language functions to access the internal data structures of a SystemVerilog simulation''~\cite[Ch.~36]{SystemVerilog-2023}, do, as far as we are aware, allow for such inspection.} Analysis/debugging facilities of existing simulators are designed with the aim to help its users to find and understand bugs in Verilog designs rather than visualising Verilog's simulation semantics. Common debugging facilities in existing simulators include ``printf debugging'' (e.g., \iverhack{$display} and \iverhack{$monitor}) and waveform visualisation.

Looking beyond simulators, we are not aware of any nonsimulator tool visualising Verilog's simulation semantics. For Verilog's synthesis semantics, Materzok~\cite{Materzok19} has developed DigitalJS, ``a visual Verilog simulator for teaching''. DigitalJS uses the synthesis tool Yosys~\cite{Yosys} for synthesising its Verilog input and visualises the synthesised output of Yosys. However, the visualisation does not explain the internals of the synthesis process -- the synthesis tool is still a black box for the user (i.e., it is only its final output that is visualised). Similar visualisations, although not interactive, come bundled with e.g. Yosys itself and other synthesis tools like Xilinx Vivado~\cite{vivado}. (On the topic on visualising synthesis algorithms, although not directly related to Verilog, Nestor~\cite{Nestor08} has implemented CADAPPLETS (later ported to CADApps) for visualising a selection of synthesis algorithms.)

%\polish{We do not include array values, which are important for real-world code but do not complicate the Verilog event queue compared to only supporting bit values. Not including arrays has allowed us to avoid a long series of minor nonconcurrency problems we are not directly interested in for the moment, such as the implicit resizing semantics of Verilog.}

%\footnote{See, e.g., the discussion on variables and nets in Sec.~4.1 of their paper, where they claim that ``[t]he distinction between nets and variables is an archaic part of the standard, no longer strictly necessary''. Moreover, in Sec.~4.3, they claim that ``[t]he best we can glean from the standard is that a net assignment should perform essentially as an \iver{always} block with one blocking assignment in it'', which is clearly not the case since variables and nets have completely different evaluation models.}

%They, moreover, do not address the two problems we raise in Sec.~\ref{sec:vv}; we illustrate the resulting problems exhibited by their semantics with test modules written for their semantics, see the \texttt{k-verilog} directory in the source code repository of VV. See also the modules under \texttt{xx\_more/Meredith/} in the drop-down menu with test modules in VV, which further discusses the questions for the Verilog community raised by Meredith et al. in their paper.

%The K framework is a toolbox potentially perfect for the experienced semanticist, but potentially less perfect for those uninitiated in the field of programming-language semantics; or, put in comparative language, we believe our Verilog visualisation to be more approachable than K and a useful complement for Verilog users less experienced in formal semantics.

%TODO: Now, consider Meredith et al.'s~\cite{Meredith10} Verilog formalisation, the most complete Verilog formalisation to date; they seem to have misunderstood the difference between variables and nets in Verilog (see Sec.~\ref{sec:related-work} for further comments on this). This highlights that a formal semantics and a correct semantics are separate concepts, and hence feedback is important.

%Lööw~\cite{Loow22b} discusses the problem we call the first major problem in Sec.~\ref{sec:vv}. The paper reports on work-in-progress, and the suggestions made in the paper are not incorporated into a semantics. Lööw does not take into account interleavings between procedural processes and continuous assignments.

% \polish{Fig.~\ref{fig:gtkwave} contains an example waveform output waveform.}

%Regardless, using or extending an existing simulator with support for visualising its event queue is not a sound approach to our work here. To force ourselves to scrutinise the various corner of the Verilog standard, we had no option but to build a new simulator from the ground up. Our work here is to debug the Verilog standard, and doing so is only possible by starting from zero and carefully and critically~reading~the~standard.

%\begin{figure}[t]
%\centering
%\includegraphics[width=\textwidth]{gtkwave.png}
%\caption{A screenshot of GTKWave with a run of \texttt{cirucit\_tb} from Fig.~\ref{fig:tbexample}. The waveform display shows the states of data objects over time.}%
%\label{fig:gtkwave}
%\end{figure}

%Whereas existing simulators need only to guarantee that the behaviour of the simulator is within the behaviour allowed by the Verilog standard, VV must allow its users to explore the all behaviour of Verilog.

%The design of VV is driven the aim to by provide accurate visualisations of all internals of executions of Verilog modules -- internals traditionally not exposed by Verilog simulators (in particular, the event queue).

%VV and traditional simulators have different design goals; specifically, the design goal of VV is to explain the semantics of Verilog whereas the design goal of traditional simulators is to allow testing and debugging of (real-world) hardware designs. The two goals are similar but not identical. As a result, the two types of simulators end up differing substantially. We highlight key differences along three dimensions: simulator internals, human-simulator interaction, and analysis~facilities.

%INTERACTION IS THE KEY DIFFERENCE!!!

%\paragraph{Simulator internals.} For traditional simulators, simulation speed is the main driving force behind the design of the simulator. In contrast, for VV, simulation speed is largely unimportant. Instead, the design of VV is driven the aim to by provide accurate visualisations of all internals of executions of Verilog modules -- internals traditionally not exposed by Verilog simulators (in particular, the event queue). The internals of VV must therefore be as conceptually/ontologically faithful to the standard as possible, even at the expense of efficiency.

%\paragraph{Human-simulator interaction.} Traditional simulators are batch tools, whereas VV is an interactive tool. To exemplify, recall that, due to concurrency, Verilog is a nondeterministic language. E.g., when there is a choice of multiple interleavings during execution, a traditional simulator will not explore all possible execution paths, but instead commit to one specific interleaving (which gives the best performance payoff) and ignore the remaining ones. In contrast, in VV it is up to the user to pick which particular interleaving to explore, enabling users to explore the full semantics of Verilog. (In this aspect, VV has more in common with explicit-state model checking than traditional simulators, except that  VV is driven by human rather than machine.)

%\begin{figure*}[t]
%\centering
%\includegraphics[angle=-90,width=0.9\textwidth]{examplegraph/graphfixed.pdf}
%\caption{Waveform of an Icarus Verilog simulation of example 12, a sequential pipeline register, from Cummings~\cite{Cummings00} rendered by GTKWave. A waveform allows for visualising both internal and external connections.}\label{fig:waveform}
%\end{figure*}

%\paragraph{Analysis facilities.} The analysis facilities offered by traditional simulators, in the form of debugging facilities, are designed to help its users to understand and find bugs in Verilog designs, whereas the analysis facilities offered by VV are designed for explaining the semantics of Verilog. Common debugging facilities in traditional simulators include ``printf debugging'' (e.g., \iverhack{$display} and \iverhack{$monitor}) and waveform visualisation -- see Fig.~\ref{fig:waveform} for an example waveform output from the simulator Icarus Verilog. Critically, in traditional simulators, the event queue cannot be inspected whereas in VV one of the main functions of the tool is to visualise the event queue.\footnote{Not even the Verilog APIs (PLI/VPI) defined by the standard that allow ``foreign language functions to access the internal data structures of a SystemVerilog simulation''~\cite[Ch.~36]{SystemVerilog-2017}, do, as far as we are aware, allow for such inspection.}

%In summary, because the different goals of visual simulation and traditional simulation, not much infrastructure between them can be shared, and we thus decided to do a small clean-slate implementation. WE NOW DISCUSS THESE DIFFERENCES.

%However, even if traditional simulators would provide a way to inspect their internal state, such access is not sufficient to explore the semantics of Verilog.

%EQV is required since our aim is completely different from conventional simulators, we aim to capture \emph{all} behaviours as allowed by the standard, simulator performance does not matter since, only readability/understandability of the code.

%However, the current range of simulators does not give a way to inspect the internal event queue during execution, the users are limited to execute the informally specified algorithm in their head. show how simulation trace looks like from some open source tool… ... say that you don’t see the internal queue…

%Like us, they omit support for multiple modules. 

%\paragraph{Other hardware languages} VHDL... Generator-based languages less of a problem? CIRCT... the LLVM thing. Supposedly cleaner languages, but they lack any written-down semantics at all!!!

%\paragraph{Other visualisations of programming languages and formal methods.} Although not a common form of formalisation, visualisation is not unheard of in previous programming-language-theory-related work; e.g., in previous work we find: visualisations of programming languages and paradigms with steep learning curves, e.g., Homer's~\cite{Homer22} work on visualising stack-based concatenative languages (which, as Homer remarks, has sometimes (humorously) been referred to as ``write-only'' languages), Greenberg and Blatt's~\cite{Greenberg19} Shtepper which visualises the execution of shell scripts, Eisenstadt and Brayshaw's~\cite{Eisenstadt88} Prolog visualisation work, and the lambda calculus visualisations collected by Pramod's~\cite{Pramod}; visualisations of difficult corners of mainstream languages, e.g., the visualisation tool Loupe~\cite{Philip14} which helps users ``understand how JavaScript's call stack/event loop/callback queue interact with each other'' and Cooper's~\cite{Cooper12} visualisations of coroutine event loops in JavaScript; and visualisations of distributed systems~\cite{Beschastnikh20}.

%In the formal-methods literature, one can find examples of visualisations of formal-method techniques (e.g., ribbon proofs for separation logic~\cite{Wickerson13} or graphical proof assistants, designed for education, such as Holbert~\cite{OConnor22}) and examples of providing understandable presentations of proof states in program-verification tools (e.g., the proof-state visualisations in KeY~\cite{Ahrendt16} and Iris'~proof~mode~\cite{Krebbers18,Krebbers17}).

%Concurrency adds another layer of complexity, and consequently more room for mistakes and mishaps in language standards. One example of work in this area is Boehm's argument that ``threads cannot be implemented as a library''~\cite{Boehm05}, a once common practice. A second example is given by Vafeiadis et al.~\cite{Vafeiadis15}, who show that common compiler optimisations are invalid under the C11 memory model, i.e., another case of the ISO standard of C being out of sync with practice. A third example is given by Alglave et al.~\cite{Alglave21}, who give a comprehensive review of the many twists and turns that have happened in the over decade long work on formal concurrency modelling of the Arm architecture. They review a great many numbers of papers with various and incompatible relationships to the standard by Arm, where suggestions put forward as reasonable options in one paper are judged not reasonable in the next paper, and so on. %Similarly, in another paper, this time on formal modelling of concurrency in Linux, Alglave et al.~\cite{Alglave18} highlights that concurrency in Linux is a contentious topic, whose documentation rather than being the pinnacle of clarity may be used to frighten small children (and also, they add, appears to be disconcerting to grown-ups).

\section{Conclusion}%
\label{sec:conclusion}

Our aim of the project presented in this paper has changed during the course of the project. Initially, our aim was to develop mechanised metatheory for Verilog's simulation semantics such that we would be able to formally connect up Verilog tools using Verilog's simulation semantics (e.g., Verilog simulators) and Verilog tools using Verilog's synthesis semantics (e.g., Verilog synthesis tools). However, we quickly realised that the simulation semantics was too broken to satisfy any of the metatheory we had in mind. At this point, our aim changed to the current aim of the paper: to pin down the problems in Verilog's simulation semantics that remain despite multiple previous projects having formalised the semantics.

Looking ahead, now having identified enough problems in the Verilog standard's description of Verilog's simulation semantics to turn previous work on Verilog formalisation into a formalisation compatible with Verilog practice, we hope that our future attempt at developing mechanised metatheory for the simulation semantics will end more positively than our first attempt. Ultimately, of course, the problems identified in this paper need to be addressed in the Verilog standard, such that the standard does not require patching to be usable.

%Co-develop standards along with mathematical formalisations, e.g., the work on WebAssembly~\cite{Haas17,Watt18,Watt21}.

%We believe the work presented in this paper straightens out the last remaining major question mark in the formalisation of Verilog's simulation semantics. Specifically, we have analysed the last major question left open by the Verilog formalisation work of Meredith et al.~\cite{Meredith10} and Chen et al.~\cite{Chen23} (the problem we call \IP), i.e., the two state-of-the-art Verilog formalisations. We have also raised a problem of the Verilog standard that seems to not have been raised in previous work on the formalisation of Verilog (the problem we call \NBAP). 

%We believe that combining either the semantics of Meredith et al. or Chen et al. with the fixes we suggest here provide a possible semantic formal foundation for formal reasoning about Verilog designs and tools. Working towards validating this belief, we are now looking into mechanising a version Verilog's simulation semantics that incorporates the fixes suggested in this paper, and prove meta-theoretical properties about this ``repaired'' simulation semantics (e.g., showing that the semantics enforces \CP for synthesisable modules). Ultimately, of course, the problems raised in this paper need to be addressed in the standard, such that the standard does not require fixes to be formalisable.

%With an eye towards a definitive mathematical formalisation of Verilog, we have developed a visual formalisation of Verilog's simulation semantics. We hope the two problems of the Verilog standard we have identified will help future mathematical work on Verilog by our discussions here ultimately feeding into an improved version of the Verilog standard. Moreover, we believe the two problems we have identified show the complementary value of visual formalisation compared~to~mathematical~formalisation.

%Although, one can never be sure -- maybe not even in the utopian/dystopian future where machines are designing our hardware will we be free of Verilog~\cite{Pearce20,Thakur22}~:-).

%We hope our visual formalisation will be useful as a steppingstone in future work on a developing a mathematical formalisation of Verilog based on the Verilog standard, in particular, the two problems of the Verilog standard we 

 %introduced VV, a visualisation tool for Verilog's simulation semantics. 

%VV makes inspectable not only the parts of Verilog execution inspectable in traditional Verilog tools but also Verilog's internal event queue. We understand VV as a visual formalisation of Verilog, and by visually formalising difficult-to-understand corners of Verilog in a form understandable by both hardware designers and programming-language-theory researchers, 

\section{Data-Availability Statement}

The artefact~\cite{artefact} of this paper contains: (1) the small-scale systematic test suite we have developed and used to test how closed-source simulators handle the PREEMPT problem; (2) the source code of our new tool VV; (3) our modified version of Chen et al.'s artefact.

\bibliographystyle{ACM-Reference-Format}
\bibliography{paper}

\ifarxiv
\appendix
\include{app/interleavings.tex}
\include{app/executions.tex}
\include{app/vv.tex}
\else
\fi

% OLD
%\include{app/icarus.tex}
%\include{app/formal.tex}

\end{document}
