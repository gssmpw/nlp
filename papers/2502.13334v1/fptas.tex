\subsection{An FPTAS for constant number of types} \label{fptas-section}

In this section we prove the following main result:

\begin{theorem} \label{fptas}
    Assuming that the number of buyer types $T$ is constant, for any $\eps > 0$ there is a fully polynomial time approximation scheme (FPTAS) that outputs a menu achieving at least $(1-\eps)$-fraction of the maximum seller profit in time polynomial in $\fr{1}{\eps}$, $\ab{A}$, and $\ab{Q}$.
\end{theorem}

This positive result complements the negative result in \cref{np-hardness-two-types} where we showed that computing the \emph{exact} maximum profit is \tbf{NP}-hard even for two types. Our proof of \cref{fptas} has the following outline. First, we introduce a general framework due to \citet{woeginger2000} for converting a certain class of dynamic programs to an FPTAS. Second, we show that the service provider problem can be cast into this framework using a suitable definition of dynamic program state. Third, we prove that the recast service provider problem meets the technical conditions required in \citet{woeginger2000} to admit an FPTAS. The overall proof turns out to be quite involved, so this section focuses on the conceptual ideas needed to formulate the service provider problem as a dynamic program as well as to prove that it can be converted into an FPTAS.

\para{Proof preliminaries.} We start by fixing the actions $a^t$ for each contract $\cC^t$ in the menu beforehand, noting that to find the profit-maximizing menu, we can iterate over all $\ab{A}^T$ possible choices of actions for buyer types in polynomial time because $T$ is constant. For each possible assignment of actions $a^{t}$ to contracts $\cC^{t}$, we design an algorithm below to compute an approximation to the maximum seller profit given this action assignment and then take the maximum across all such action assignments. Also recall that by \cref{two-usage-prices-suffice}, a profit-maximizing menu has usage prices $x^t_q\in \bc{0,\infty}$. 

Our overall plan is to search over all possible choices of usage prices $x^t_q\in \bc{0,\infty}$ using a dynamic program and for each such choice compute the maximum seller profit achievable conditioned on these usage prices. Unfortunately, there are exponentially many choices of usage prices, $2^{T\cd \ab{Q}}$ to be precise. Our key insight is to reduce the search space to polynomial size by combining similar choices of usage prices $x^t_q\in \bc{0,\infty}$ that result in similar seller profits. This is a two-step process: we need to first define what it means for two choices of usage prices to be \emph{similar} and then prove that for this definition, similar usage prices actually imply similar seller profits. The main challenge lies in constructing a concise \emph{state} vector as a function of the usage prices $x^t_q$ such that:

\begin{itemize}
    \item The maximum seller profit for a given choice of usage prices can be computed from just the state itself without knowing the original usage prices.
    \item Small changes in state implies small changes in maximum seller profit.
\end{itemize} 

We formalize when two state vectors are similar with the following definition:

\begin{definition*}
    For a constant $r>1$, two state vectors $s$ and $s'$ are \emph{$r$-close} if for all components $i$, $r^{-1} \cd s_i \le s'_i \le r\cd s_i$.
\end{definition*}

% Next, we concretize the above proof ideas by first introducing a general dynamic program (DP) framework due to   \citet{woeginger2000}, which  casts our problem \kicomment{this clause sounds odd}, then describing the construction of a suitable DP state for our problem, following by proving the seller's profit as a function of the constructed state does satisfy the two desired properties above.   

\paragraph{A general dynamic program framework.}

We begin by introducing a dynamic program framework by \citet{woeginger2000} that considers optimization problems of the following form:

% \hfcomment{Key question -- interpreting in our setting, is $x^t_q$ the input in the following description, or is it actually the buyer's values $v^t_q$? I thought  $v^t_q$ is the input which you need to update your state, whereas $x^t_q \in \{ 0, \infty\} $ is directly embedded in the transition function $f_0, f_{\infty}$. $f_\infty (s_{i-1}, v_i), f_0 (s_{i-1}, v_i)$ are two new states.   Also,  I am thinking whether this is the most audience-friendly way to describe this problem. Maybe we can use 2~3 sentence to quickly hint on how these terminologies   correspond to quantities in our setting.}
\begin{itemize}
    \item A sequence of inputs $z_1,\lds,z_n$ and a set $S_0$ of initial states, where each state is a vector of real numbers.
    \item A set $\cF$ of transition functions, where each function $f\in \cF$ maps a tuple $(\te{state}, \te{input})$ to a new state.
    \item An objective function $\pi$ mapping a state to a real-numbered value.
\end{itemize}

The dynamic program (Algorithm \ref{dp}) works in $n$ steps. At each step $i = 1, \lds, n$, it processes the input $z_i$ and constructs a set of states $S_i$ using the previous set of states $S_{i-1}$. Each state in $S_i$ encodes a partial solution to the problem using inputs $z_1,\lds,z_i$, and the final set $S_n$ consists of the full solution to the problem using the entire input. Note that in addition to outputting the optimal objective value, any dynamic program can also output a sequence of transition functions that leads to the optimal state by also storing for each state a sequence of transition functions that achieve it.

\begin{algorithm}
        \caption{General dynamic program}
	\label{dp}
        \SetAlgoNoLine
	\KwIn{A sequence $z_1,\lds,z_n$ of length $n$}
	Let $S_0 \coloneq $ the set of initial states
	
	\For{$i = 1,\lds,n$
		}{
			Let $S_i \coloneq \bc{f(s,z_i): f\in \cF, s\in S_{i-1}}$
		}

        \KwOut{$\max \bc{\pi(s):s\in S_n}$}
	
\end{algorithm}

Note that Algorithm \ref{dp} runs in exponential time since the number of states multiplies at every step by the number $\ab{\cF}$ of possible transitions functions. Interestingly, \citet{woeginger2000} proves that any dynamic program of the form in Algorithm \ref{dp} can be converted to an FPTAS so long as three conditions are satisfied:

% \footnote{The conditions described in \citet{woeginger2000} are slightly more general than those that we write down, but for clarity we describe a simpler version of the conditions that is sufficient for the service provider problem.} 

\begin{enumerate}
    \item \emph{Proximity between states is preserved by the transition functions.} For any transition function $f$, input $z_i$, and states $s, s'$, if $s$ and $s'$ are $r$-close then $f(s, z_i)$ and $f(s', z_i)$ are $r$-close.

    \item \emph{Proximity between states is preserved by the objective function.} There exists an integer $G\ge 0$ such that if $s$ and $s'$ are states that are $r$-close then $\pi_{\tt{indirect}}(s') \ge r^{-G} \cd \pi_{\tt{indirect}}(s)$.

    \item \emph{Computability.} All transition functions $f\in \cF$ and the objective function $\pi$ can be evaluated in polynomial-time.
    
\end{enumerate}

% \hfcomment{Delete Algo 2? Does not seem to convey much additional information, compared to Algo 1. The only idea is to trim, which is already described in text.  }
% \begin{algorithm}[t]
%         \caption{FPTAS (informal)}
% 	\label{dp-fptas}
%         \SetAlgoNoLine
% 	\KwIn{A sequence of  $n$ inputs $z_1,\lds,z_n$}
%         Partition state space into polynomially many buckets that consist of similar state vectors
        
% 	Let $T_0 \coloneq S_0 \coloneq $ the set of initial states
	
% 	\For{$i = 1,\lds,n$
% 		}{
% 			Let $S_i \coloneq \bc{f(s,z_i): f\in \cF, s\in T_{i-1}}$
            
%             Let $T_i \coloneq $ a trimmed copy of $S_i$: for each bucket that contains multiple states in $S_i$, keep exactly one
% 		}

%         \KwOut{$\max \bc{\pi(s):s\in T_n}$}
	
% \end{algorithm}

The simple FPTAS of \citet{woeginger2000} is based on the idea of \emph{trimming} the state space. Instead of exploring exponentially many states corresponding to exponentially many choices of transition functions, a dynamic program whose goal is to compute a $(1-\eps)$-approximation of the maximum objective value need only store a $\poly\bp{\fr{n}{\eps}}$-sized subset of states at every step by combining state vectors where the individual components of the states are within a $(1\pm \eps)$-multiplicative factor of each other. The objective function's proximity property guarantees that the dynamic program outputs a $(1-\eps)$-approximation of the maximum seller profit.

\paragraph{Defining the dynamic program state.} 

Our main challenge lies in showing that the service provider problem can be written in the form of Algorithm \ref{dp} as well as to prove that the dynamic program satisfies the three technical conditions above to yield an FPTAS. We first prove that the vector of usage prices can be concisely represented using a \emph{state} vector such that the maximum seller profit preserves proximity. To do this, we first introduce the following key definition:

\begin{definition*}[Value of a contract]
    The buyer \emph{value} of contract $\cC^{t'}$ for type $t$ is $$V(t;\cC^{t'}) \coloneq \sum_{q} p^{a^{t'}}_q v^t_q \cd \one\bb{x^{t'}_q = 0} = U(t;\cC^{t'}) + w^{t'}.$$
\end{definition*}

The value can be interpreted as the buyer's utility \emph{before} paying the upfront price. With the definition of value, the buyer IC constraints can be written as
\begin{align*}
    U(t; \cC^t) \ge U(t; \cC^{t'}) \iff  V(t; \cC^t) - w^t \ge V(t; \cC^{t'}) - w^{t'} \iff  w^t \le w^{t'} + V(t; \cC^t) - V(t; \cC^{t'}) 
\end{align*}
for all $t,t'$ and the IR constraints can be written as $w^t \le V(t;\cC^t)$ for all $t$. The reason why the buyer values are particularly suitable for concisely representing the usage price vector is that the profit-maximizing upfront prices $(w^t)_{t\in [T]}$ can be computed by a linear program with parameters being the values by \cref{binary-optimization-problem}:

\begin{tcolorbox}[title=Maximizing profit in direct menus fixing actions and values]
    \begin{align} 
        \pi_{\tt{direct}} = \max_{(w^t)_{t\in [T]}} &  \bE_{t\sim \mu} \bb{w^t - c(a^t)} \label{linear-program-given-usage-prices} \\
        & w^t \le w^{t'} + V(t; \cC^t) - V(t; \cC^{t'}), & \fl t,t' && \te{(IC)} \notag \\
            & w^t \le V(t;\cC^t),  & \fl t && \te{(IR)} \notag
\end{align}
\end{tcolorbox}


% Note that once the usage prices are set, the values $V(t;\cC^{t'})$ are fixed and do not depend on the upfront prices. The existence of a linear program to compute the profit-maximizing upfront prices given the usage prices by itself does not yield an efficient algorithm because the search space of usage prices $x^t_q$ is exponential in size.

% Given that there is a linear program, namely \cref{linear-program-given-usage-prices}, that computes the maximum profit given as input all values $V(t;\cC^{t'})$ of contracts for each type,

Since usage prices do not appear in \cref{linear-program-given-usage-prices} other than implicitly via the definition of $V(t;\cC^{t'})$, the vector of values $\bp{V(t;\cC^{t'})}_{t,t'}$ is a natural choice of state. However, the objective function $\pi_{\tt{direct}}$ in \cref{linear-program-given-usage-prices} is not continuous in the vector of values. This is because a small change in a value $V(t;\cC^{t'})$ could result in the menu of contracts no longer being feasible because of the violation of a IC constraint, so the maximum seller profit could suddenly jump from a large positive value to 0. Using $\pi_{\tt{direct}}$ as the dynamic program objective would violate the proximity condition of \citet{woeginger2000} and hence would fail to yield an FPTAS.

To address this issue, the key idea is to return to an indirect menu formulation of the service provider problem. Define $\pi_{\tt{indirect}}$ to be the maximum seller profit for a state $s$ over all upfront prices for \emph{indirect} menus, which by the revelation principle has the same maximum as $\pi_{\tt{direct}}$ over all states achievable by a menu. The idea of using indirect menus is unintuitive because direct menus are in general a conceptual simplification of indirect menus and usually make it easier to optimize seller mechanisms in the contract design literature. Nevertheless, relaxing the service provider problem to allow indirect menus turns out to be crucial in our setting.

We first review the definition of indirect menus. Rather than requiring that a buyer of type $t$ choose the contract $\cC^t$ as we do in a direct menu, in an indirect menu we specify a menu of $T$ contracts $\bp{\cC^t}_{t\in [T]}$ and then allow buyers to choose their utility-maximizing contract from the menu, or opt-out if no contract offers nonnegative utility for the buyer. The opt-out option is equivalent to always including in the menu a \emph{trivial} contract $\cC^0 = (a^0, w^0, \mbf{\infty})$ that deterministically maps a \emph{trivial} action $a^0$ with zero cost to a \emph{trivial} outcome that has zero value for all types and zero payments. It is straightforward to verify that \cref{two-usage-prices-suffice} is also valid for indirect menus, so we can write down the seller profit function for indirect menus as the following:

\begin{tcolorbox}[title=Maximizing profit in indirect menus fixing actions and values]
    \begin{align*}
             \pi_{\tt{indirect}} &= \max_{(w^t)_{t\in [T]}}\bE_{t \sim \mu} \left[ w^{u(t)} - c(a^{u(t)}) \right] \\
            u(t) &\coloneq \argmax_{t'\in \bc{0} \cup [T]} U(t;\cC^{t'}) =  \argmax_{t'\in \bc{0} \cup [T]} \bb{V(t;\cC^{t'}) - w^{t'}}
          \end{align*}   
\end{tcolorbox}

% \footnote{This assumption is needed in \cref{value-is-proximity} to prove that the seller profit is proximity in the state.}

%  Indeed, we can first convert the indirect menu to an equivalent direct menu and then apply the transformation in \cref{two-usage-prices-suffice} to the direct menu, noting that the result of the transformation can also be viewed as an indirect menu. Hence usage prices $x^t_q\in \bc{0,\infty}$ suffice for indirect menus as well,

% \begin{tcolorbox}[title=Maximizing profit in indirect menus with usage prices in $\bc{0,\infty}$]
%     \begin{align*}
%              \max_{ \substack{\{(a^{t'}, w^{t'}, \mathbf{x}^{t'}) \}_{{t'} \in [T]} \\ x^{t'}_q\in \bc{0,\infty}}} & \quad \bE_{t \sim \mu} \left[ w^{u(t)} - c(a^{u(t)}) \right] \\
%              & u(t) \in \argmax_{t'\in \bc{0} \cup [T]} U(t;\cC^{t'})
%           \end{align*}   
% \end{tcolorbox} 

The function $u(t):[T]\to \bc{0}\cup [T]$ represents type $t$ choosing the contract $\cC^{t'}$ that maximizes their utility. As before, we break ties in favor of the seller, which is a standard assumption in principal-agent problems. Indirect menus do not have the discontinuous IC conditions present in direct menus. Indirect menus do not have IR conditions either because of the existence of the trivial contract as a choice. That being said, it is not clear at all that $\pi_{\tt{indirect}}$ is continuous in the vector of values because buyer can jump between contracts: a small change in a value $V(t;\cC^{t'})$ could lead to a buyer choosing an entirely different contract with a significantly higher or lower upfront payment. \cref{value-is-proximity} is devoted to proving that $\pi_{\tt{indirect}}$ preserves proximity of the vector of values, which is needed to derive an FTPAS.

\para{Formulating the service provider problem as a dynamic program.}

% We begin with an indirect menu that has usage prices $x^t_q = \infty,\fl t, q$, which has revenue 0 since every buyer type is prevented from using every outcome. These two possible choices for each type and outcome tuple are the \emph{transition functions} that map between dynamic program states. Since there are two choices at every step, the number of dynamic program states blows up by a factor of two at every step, but because of our eventual trimming procedure we are able to reduce to only a polynomial number of states at every step. 

Having defined the dynamic program state as the vector of values of all contracts in an indirect menu for all buyer types, we now describe how we can cast the service provider problem into \citet{woeginger2000}'s dynamic program framework:

\begin{itemize}
    \item Let the input $z_1,\lds,z_n$ in Algorithm \ref{dp} be an arbitrary ordering of the $n = T\cd \ab{Q}$ type and outcome tuples $(t,q)$. The input $z_i = (t_i, q_i)$ is the type and outcome tuple that indexes the usage price $x^{t_i}_{q_i} \in \{ 0, \infty \}$ whose value will be decided at step $i$.

    \item A state $s$ is a $\bp{T^2}$-dimensional vector of the form $s = \bp{s_{t,t'}}_{t,t'}$. Given a choice of usage prices $x^t_q$, the state is computed as
    \begin{align*} \label{valid-s}
        s_{t,t'} &\coloneq V(t;\cC^{t'}) = \sum_{q} p^{a^{t'}}_q v^t_q \cd \one\bb{x^{t'}_q = 0}.
    \end{align*}

    \item Defining $$u_{s,w}(t) \coloneq \argmax_{t'\in \bc{0} \cup [T]} \bb{s_{t, t'} - w^{t'}}$$ as the index of the utility-maximizing contract for type $t$, the maximum seller profit given a state $s$ can be written as
    $$\pi_{\tt{indirect}}(s) \coloneq \max_{\bp{w^{t'}}_{t'\in [T]}} \bE_{t\sim \mu} \bb{w^{u_{s,w}(t)} - c\bp{a^{u_{s,w}(t)}}}.$$

    \item There are two transition functions. The first is $f_\infty$, which corresponds to setting $x^t_q = \infty$ and is defined by $f_\infty(s, (t,q)) = s$. The second is $f_0$, which corresponds to setting $x^t_q = 0$. To get from $s$ to $s' = f_0(s,(t,q))$ we set $$s'_{t',t} = s_{t',t} + p^{a^t}_q v^{t'}_q, \quad \fl t'$$ and leave the other components unchanged.

    % Note that the transition functions are defined so that at every step $i$, the state consists of values for all types for the first $i$ outcomes.\kicomment{the last sentence probably does not make sense.}

    % These are two \emph{transition functions} at every step: $f_0$ corresponds to $x^t_q = \infty$ and $f_1$ corresponds $x^t_q = 0$ for the next tuple $(t, q)$ in the sequence. 
\end{itemize}
% The global maximum seller profit is $\max_s \pi(s)$ over all states $s$ that are obtained from \cref{valid-s} for some choice of usage prices $x^t_q\in \bc{0,\infty}$.
    
% Having defined both the state and how to calculate the maximum seller profit from the state, we finally construct a dynamic program to approximate $\max_s \pi(s)$:

% \begin{itemize}
%     \item Each input vector is of the form $\bp{v^1_q, v^2_q, \lds, v^T_q} \in \bR_{\ge 0}^{[T]}$ for $q\in Q$ and $(a^1,a^2,\lds,a^T) \in A^{[T]}$.

%     \item Initially we set all usage prices payments as $x^t_q = \infty$, which corresponds to the state $s = \mathbf{0}$.

%     \item Arbitrarily order the $T\cd \ab{Q}$ type and outcome tuples $(t, q)$ in a sequence. For each type and outcome tuple in order, we decide whether to leave the usage price as $x^t_q = \infty$, which prevents type $t$ from using outcome $q$, or to change it to $x^t_q = 0$, which has type $t$ using outcome $q$. 
    
    % \item The transition functions at every step will correspond to, for every tuple $(t, q)$, For concreteness,  but the choice of sequence does not matter in the analysis. In summary, there are two transition functions for every tuple $(t,q)$:

%     \item The goal is to compute $\max_s \pi(s)$ over all states $s$ that are achievable by applying the transition functions for each tuple $(t,q)$.
% \end{itemize}

% We apply a standard result in the FPTAS literature, for example see \citet{woeginger2000}, that states that if a dynamic program formulation satisfies three technical conditions then it can be converted to a FTPAS by combining states with similar seller profits at every step of the dynamic program so that only a polynomial number of states are ever considered. 


\para{From dynamic program to FPTAS}

To finish the proof of \cref{fptas}, we show that the dynamic program for the service provider problem admits an FPTAS. By \citet{woeginger2000} this amounts to proving three conditions: 

\begin{claim*}[Proximity between states is preserved by the transition functions]
     For any transition function $f$, input $x_i$, and states $s, s'$, if $s$ and $s'$ are $r$-close then $f(s, z_i)$ and $f(s', z_i)$ are $r$-close.
\end{claim*}

\begin{proof}
    Both transition functions $f_\infty$ and $f_0$ increment the state by a vector with nonnegative entries that does not depend on the current state, and $r^{-1} \cd s_i \le s'_i \le r\cd s_i$ implies $r^{-1} \cd (s_i + c) \le s'_i + c \le r\cd (s_i + c)$ for any $c \ge 0$.
\end{proof}

\begin{lemma}[Proximity between states is preserved by the objective function] \label{value-proximity}
    The seller profit $\pi_{\tt{indirect}}(s)$ preserves proximity in $s$.
\end{lemma}

\begin{lemma}[Computability] \label{value-efficient}
    The seller profit $\pi_{\tt{indirect}}(s)$ is efficiently computable given $s$.
\end{lemma}

We reiterate that even the \emph{continuity} of the seller profit for indirect menus is not obvious, so the proof of \cref{value-proximity} is non-trivial. The proofs of \cref{value-proximity} and 
\cref{value-efficient} can be found in \cref{value-is-proximity} and \cref{value-is-efficient} respectively.

    % The remainder of the proof involves analyzing the value function to show that it satisfies \citet{woeginger2000}'s proximity condition.
    
    % We first characterize when \cref{w-conditions} admits a feasible solution. Note that if $V(t;\cC^t) < V(t; \cC^{t'})$ for some $t < t'$ then $w^t \le w^{t'} + V(t; \cC^t) - V(t; \cC^{t'})$ contradicts $w^t \ge w^{t'}$ and so the current state yield no feasible solution. We claim that in this case we can terminate the dynamic program search by use of \citet{woeginger2000}'s \emph{filter function}. To check whether this filter function is valid, we need to show that no future transition function will ever yield a feasible solution so that we did not miss a final state feasible solution. Because we ordered the type and quality transition tuples so that qualities purchased for lower-indexed types are decided before higher ones, note that if we are currently setting the performance payment for type $t'$ then $V(t;\cC^t)$ for $t < t'$ will remain constant for the rest of the dynamic program run since the qualities type $t$ purchased have already been set. On the other hand, $V(t;\cC^{t'})$ only weakly increases for the rest of the dynamic program run, hence if at any point $V(t;\cC^t) < V(t; \cC^{t'})$ by setting $x^{t'}_q = 0$ through transition function $f_1$, the same inequality will be satisfied at the end state and hence there will be no feasible menu of contracts.
    
    % This motivates defining the filter function $h_1$ associated to transition function $f_1$ as returning \tsf{True} if and only if all conditions of the form $V(t;\cC^t) \ge V(t; \cC^{t'})$ are still satisfied. The filter function $h_0$ associated to $f_0$ always returns \tsf{True} since $f_0$ leaves all the value functions and hence whether or not the inequalities $V(t;\cC^t) < V(t; \cC^{t'})$ are satisfied unchanged.
    
    % The filter function definition also motivates the definition of the following \emph{quasi-dominance} relation in \citet{woeginger2000}'s framework. Assuming we are currently deciding a quality for type $t'$, a state $s$ quasi-dominates another state $s'$ if all quantities of the form $$V(t;\cC^t) - V(t; \cC^{t'}),\quad \fl t < t'$$ for $s$ are greater than the corresponding quantities for $s'$. With this definition of quasi-dominance, it is easy to see that if $s$ quasi-dominates $s'$, then if we apply a transition function $f$ to both $s$ and $s'$, the filter function $h_1$ will return \tsf{True} for $s$ if it returns \tsf{True} for $s'$ since applying $f$ changes all of the quantities $$V(t;\cC^t) - V(t; \cC^{t'}),\quad \fl t < t'$$ by the same amount for $s$ and $s'$. If these quantities were all initially greater in $s$ than $s'$ and after applying $h_1$ these quantities are all nonnegative in $s'$, then they must all be nonnegative in $s$ as well. Also note that applying $f$ preserves quasi-dominance, again because $f$ changes the quantities $$V(t;\cC^t) - V(t; \cC^{t'}),\quad \fl t < t'$$ by the same amount.
    
   % \hfcomment{This is why we cannot extend to 3 types. } There is one subtlety we have to address however. \citet{woeginger2000}'s framework requires quasi-dominance to be a total preorder on states. This is so that given a collection of states that are all close to each other, we need only store a state that has quasi-dominates all other states in the collection, knowing that if any of the states in the collection eventually lead to a valid solution in the sense that all filter functions are satisfied, then the quasi-dominant state will also lead to a valid solution with approximately the same value function

   %  Unfortunately, quasi-dominance is not a total preorder but we can fix it by keeping at most $(T^2)!$ states.
    
    % On the other hand, if $V(t;\cC^t) \ge V(t; \cC^{t'}),\fl t < t'$, then there is a feasible solution to \cref{w-conditions}, in particular $w^t = 0,\fl t$. Knowing the existence of a feasible solution, the value function can be computed in polynomial time by solving the following linear program:
    % \begin{equation} \label{w-linear-program}
    %     \begin{split}
    %         \max & \sum_{t\in [T]} \mu^t \cd w^t \\
    %         w^t &\le w^{t'} + V(t; \cC^t) - V(t; \cC^{t'}), \quad \fl t < t' \\
    %         w^t &\ge w^{t'},\fl t < t' \\
    %         w^t &\le V(t;\cC^t),\quad \fl t.
    %     \end{split}
    % \end{equation}

%     Finally, we verify that each technical condition in \citet{woeginger2000} is satisfied:
%     \begin{itemize}
%         \item \emph{Proximity is preserved by the transition functions.} This follows from the fact that each component of the state $(V(t;\cC^{t'}))_{t,t'\in [T]}$ increases by the same amount when we decide whether or not a type and quality tuple is purchased.

%         \item \emph{Proximity is preserved by the value function.} This follows from a classic result, for example see \citet{mangasarian1987}, that the objective value of a feasible linear program is proximity in the parameters in \cref{w-conditions} and hence proximity in the state $(V(t;\cC^{t'}))_{t,t'\in [T]}$, which is sufficient for proximity with $G = 1$.

%         \item \emph{Conditions on the filter functions.} This follows by the definition of quasi-dominance. If all quantities of the form $$V(t;\cC^t) - V(t; \cC^{t'}),\quad \fl t < t'$$ for $s$ are greater than the corresponding quantities for $s'$, then if $f_1(s',x)$ yields a feasible solution then so will $f_1(s, x)$.

%         \item \emph{Runtime conditions.} Note that the transition functions, the value function, and the quasi-dominance relation can be decided in polynomial time.
%     \end{itemize}
% \end{proof}




% \begin{theorem} \label{two-type-fptas}
%     There exists a fully polynomial time approximation scheme (FPTAS) for maximizing service provider revenue for two types $t_1, t_2$ that is polynomial in the number of actions and number of quality levels.
% \end{theorem}

% \begin{proof}
%     Without loss of generality let $t_2$ be the highest revenue type, noting that we can also solve for the optimal menu with $t_1$ being the highest revenue type and output the best menu across the two cases. Recall from \cref{training-payment-formula-two-types} that there exists an optimal menu where \[w^1 = \sum_{j\in S} p_q v^1_q\] and \[w^2 = \min \bc{\sum_{j\notin S} p_q v^2_q + \sum_{j\in S} p_q v^1_q, \sum_{j\in Q} p_q v^2_q},\] so the maximizing service provider revenue reduces to the following combinatorial optimization problem:
%     \begin{equation} \label{fptas-combo}
%         \max_{S\subs Q} \quad \mu^1 \cd \sum_{j \in S} p_q v_q^1 + \mu^2 \cd \min \bc{\sum_{j\in S} p_q v^1_q + \sum_{j\notin S} p_q v^2_q, \sum_{j\in Q} p_q v^2_q}
%     \end{equation}
%     We show that this optimization problem has a dynamic program formulation that is \emph{extremely benevolent} in the language of \citet{woeginger2000}, which implies the existence of an FPTAS.

%     In the notation of \citet{woeginger2000}, define the following dynamic program formulation of \cref{fptas-combo}:
%     \begin{itemize}
%         \item Each input vector is of the form $(v^1_q, v^2_q)$ for $q\in Q$.
%         \item Each state is a vector $(s_1, s_2)$ where $$s_1 = \sum_{q\in S_k} p_q v^1_q,\quad s_2 = \sum_{q\in S_k} p_q v^1_q + \sum_{q\notin S_k} p_q v^2_q,$$ where $k$ is the number of quality levels we have seen so far and $S_k$ is the set of quality levels in $S$ among the first $k$ quality levels.
%         \item The initial state-set is $\bc{(0,0)}$.
%         \item There are two transition functions: $f_1$ corresponds to adding the next quality level $q$ to $S$, and $f_0$ corresponds to not adding it. If $q$ is added to $S$, then we increment $s_1$ by $p_q v^1_q$ and $s_2$ by $p_q v^1_q$, and if $q$ is not added to $S$ then we increment $s_2$ by $p_q v^2_q$.
%         \item The value function is $$g(s_1, s_2) = \mu^1 \cd s_1 + \mu^2 \cd \min\bc{s_2, \sum_{q} p_q v^2_q},$$ and we seek to maximize the value function.
%     \end{itemize}
%     To prove that our dynamic formulation is \emph{extremely benevolent}, we verify the following properties:

%     \begin{itemize}
%         \item \emph{Proximity is preserved by the transition functions.} Since $f_1$ and $f_0$ both consist of adding the same nonnegative vector that depends on the next input vector $x$ to the current state $s$, if states $s$ and $s'$ are $(d,r)$-close for $d=(1, 1)$ and any $r>1$, then $f(s,x)$ and $f(s', x)$ are $(d,r)$-close as well.

%         \item \emph{Proximity is preserved by the value function.} For $G=1$ and any $r>1$, if states $s$ and $s'$ are $(d,r)$-close for $d=(1, 1)$, then $g(s') \ge r^{-G} \cd g(s)$ for maximization problems.
%     \end{itemize}
%     We conclude that by \citet{woeginger2000}, there exists an FPTAS for the problem of maximizing service provider profit for two types and a single action.
    
% \end{proof}

% To compute the exact maximum seller profit, it seems that we would have to enumerate over all subsets of outcomes that each type uses, the number of which is exponential in the number of outcomes. We would then compute the profit-maximizing upfront prices for each such subset using for example a linear program, since given the usage prices the service provider problem reduces to a linear program in the $w^t$'s. To efficiently approximate the maximum seller profit, we show that the service provider problem has a dynamic program formulation that allows subsets with \emph{similar} valuations to be bucketed together into a single dynamic program state. It turns out that the right definition of \emph{similar} is when two such subsets of outcomes yield similar utilities $U(t;\cC^{u})$ for all type tuples $(t,u)$.



%%%%%%%%%%%%%%%%%
% \subsubsection{An FPTAS}

% We have shown that it is sufficient to consider payment schemes, where the usage prices for any outcome lies in $\{0, \infty\}$. Thus, fixing the actions, we can represent any contract, as $(w^t, S^t)$, where $S^t$ is the set of qualities for which $x_q^t = 0$.  Thus, a menu of contracts can be represented as $\{ (w^t, S^t) : t \in [T]\}$. Let $\sS = (S^1, S^2, \cdots, S^T)$ and let $\bS$ denote the set of all $\sS$. We have $|\bS| = 2^{T|Q|}$. 

% We also know that given any $\sS \in \bS$, the seller's maximum profit is given by 
% \begin{align*}
%     \pi(\sS) \coloneq \max_{ \bf{w}}  & \sum_{t \in [T]}  \sum_{u\in [T]} \mu^t \mathbb{I} \{ u(t) = u\} 
%     \left( w^{u} - c(a^{u}) \right)\\
%     &\text{s.t.  } u(t) \in \argmax_{ u \in \{0\} \cup [T]} \left\{V(t, u) - w^{u}\right\}
% \end{align*}
% Our goal is to identify a set $\sS \in \bS$ that maximizes $\pi(\sS)$.

% First, we observe that $\pi(\sS)$ depends on $\sS$ only through the value of $\mathcal{V}(\sS) \coloneq  ( V(t, u) : t, u \in [T]) \in \mathbb{R}^{T^2}$. Let $\mathbb{V} \coloneq \{ \mathcal{V}(\sS) : \sS \in \bS\} \subseteq \mathbb{R}^{T^2}$, and define $\Pi(s)$ for $s  = (s_{t,u} : t, u  \in [T]) \in \mathbb{R}^{T^2}$ as 
% \begin{align*}
%     \Pi(s) \coloneq \max_{ \bf{w}}  & \sum_{t \in [T]}  \sum_{u\in [T]} \mu^t \mathbb{I} \{ u(t) = u\} 
%     \left( w^{u} - c(a^{u}) \right)\\
%     &\text{s.t.  } u(t) \in \argmax_{ u \in \{0\} \cup [T]} \left\{s_{t, u} - w^{u}\right\}.
% \end{align*}
% We will first focus on the goal of approximately maximizing $\Pi(s)$ over all $s \in \mathbb{V}$. 

%  To do this, we consider the following scheme: First, order the set $[T] \times Q$ arbitrarily, and let the $n^{th}$ term in the order be denoted by $z_n = (u_n, q_n)$. We consider stages denoted by $n = 1, \cdots, N \coloneq T|Q|$. For any $(u, q) \in [T] \times Q$, let $E(u, q) = (S_1, \cdots, S_T) \in \bS$ where $S_t = \emptyset$ for $t \neq u$ and $S_u = \{q\}$. Define functions $\{ f_a(s; z_n) : a \in \{0, 1\} \}$ as follows:
% \begin{align*}
%     f_a(s; z_n) &= \begin{cases} s & \text{if $a = 0$;}\\
%      s + \mathcal{V}(E(z_n)) & \text{if $a = 1$;}.
%     \end{cases}
% \end{align*}
% Now consider the following algorithm:
% \begin{enumerate}
%     \item Initialize $\mathbb{V}_0 = \{ \zero \}$.
%     \item For $n = 1$ to $N$ do
%     \item \quad Let $\mathbb{V}_n = \emptyset$
%     \item \quad For every $s \in \mathbb{V}_{n-1}$ and for every $a \in \{0, 1\}$ do
%     \item \qquad Add $f_a(s; z_n)$ to $\mathbb{V}_n$
%     \item \quad EndFor
%     \item EndFor
%     \item Output $\max\{\pi(s) : s \in \mathbb{V}_N\}$.
% \end{enumerate}

% Observe that $\mathbb{V}_N = \mathbb{V}$, and hence the above algorithm does provide what we seek. The advantage with this formulation is that this fits right in the framework of Woeginger (2000), who provides an FPTAS for solving the above problem under some conditions on $f$ and $\pi$.  


% Initialize $\sS_0 = (\es, \cdots, \es)$. 
% The stages are denoted by $n=0, 1, \cdots, N = |TQ|-1$. At each stage $n$, we have two actions $a_n \in \{0, 1\}$. The transition functions are given by 
% \begin{align*}
%     f_n(\sS, a_n) = \begin{cases}  \sS & \text{if $a_n= 0$;} \\
%     (S_1, \cdots, S_{t_n} \cup \{q_n\} , \cdots, S_T)  & \text{ if $a_n = 1$,}
%     \end{cases}
% \end{align*}
% where $\sS = (S_1, \cdots, S_T)$. 
% The one-stage reward functions are given by 
% \begin{align*}
%     r_n(\sS, 0) &= 0  \\
%     r_n(\sS, 1) &= \pi(f_n(\sS, 1)) - \pi(\sS).
% \end{align*}
% Alternatively, we can consider the reward functions as $r_n(\sS, a) = 0$ for all $n < N$ and 
% \begin{align*}
%     r_N(\sS, a) = \pi(f(\sS, a)).  
% \end{align*}





% The DP equation is given by 
% \begin{align*}
%     \Pi_n(\sS) = \max\{ \Pi_{n+1}(\sS) , r_n(\sS, 1) + \Pi_{n+1}(f(\sS, 1)) \}.
% \end{align*}

% Our goal is to show that this DP can be solved approximately efficiently by coalescing the states. Essentially, we will define new states. 

% This DP has the structure where the state space can be split into (overlapping) sets:
% \begin{align*}
%     \bS_0 &= \{ (\emptyset, \cdots, \emptyset) \}\\
%     \bS_{n+1} &= \bS_n \cup \{ f_n(\sS, 1) : \sS \in \bS_n\}.
% \end{align*}


% We first observe that for any two $\sS_1, \sS_2 \in \bS$ resulting in the same values of $ \mathcal{V} = \{ V(t, u)\}$, we have $\pi(\sS_1) = \pi(\sS_2)$. Thus, rather than tracking the specific values of $\sS$, we will track the values $\mathcal{V} = \{ V(t, u) : t, u \in [T]\}$, and write $\pi(\sS)  = \pi(\mathcal{V})$.


%%%%%%%%%%%%%%%%%%%%




% Direct menus are by definition also indirect menus, and any indirect menu can be converted into a direct menu by the revelation principle by simply recording which contract in the menu each buyer type $t$ chooses and assigning that contract, with duplicates allowed, as $\cC^t$. Hence the service provider problem for indirect menus is equivalent to the problem for direct menus:

% \begin{tcolorbox}[title=Maximizing profit of an indirect menu]
%     \begin{align*}
%         \max_{ \{(a^{t'}, w^{t'}, \mathbf{x}^{t'}) \}_{{t'} \in [T]}} & \quad \bE_{t \sim \mu} \left[ w^{u(t)} + \sum_{q} p^{a^{u(t)}}_q x^{u(t)}_q \cdot \one \bb{v^{u(t)}_q \ge x^{u(t)}_q} - c(a^{u(t)}) \right]  \\
%              & u(t) \in \argmax_{t'\in \bc{0} \cup [T]} U(t;\cC^{t'})
%     \end{align*}
% \end{tcolorbox}