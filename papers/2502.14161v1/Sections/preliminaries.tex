%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% -------------------- PRELIMINARIES --------------------
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}\label{sec:preliminaries}
Throughout the paper we use standard graph notation~\cite{books/Diestel17},
and we assume familiarity with the basic notions of parameterized complexity~\cite{books/CyganFKLMPPS15}.
All graphs considered are undirected without loops.
Let $G = (V, E)$ be a graph.
Then, $\cc(G)$ denotes the set of its connected components.
Given a subset of its vertices $S \subseteq V$, $G[S]$ denotes the subgraph induced by $S$ while $G - S$ denotes $G[V \setminus S]$.
For a weight function $\wc$ on the vertices of $G$ and a subset $S \subseteq V$,
we denote by $\wc(S)$ the sum of the weights of all vertices of $S$.
Given a subset of its edges $M \subseteq E$, $V_M$ denotes the vertices incident to the edges in $M$ while $G[V_M]$ denotes the graph
induced by those vertices.
A \emph{matching} $M$ of $G$ is a subset of its edges such that every vertex of $G$ is incident to at most one edge in $M$.

For $x, y \in \mathbb{Z}$, let $[x, y] = \setdef{z \in \mathbb{Z}}{x \leq z \leq y}$ while $[x] = [1,x]$.
Given a function $f \colon A \to B$, for every $b \in B$ we denote by $f^{-1}(b)$ the set of preimages of $b$ under $f$,
that is, $f^{-1}(b) = \setdef{a \in A}{f(a) = b}$.
Notice that in the previous it is not necessary for $f$ to be defined over the whole set $A$.
For a function $f$ we denote by $f[v \mapsto \alpha]$ the function
$(f \setminus \{(v, f(v))\}) \cup \{(v, \alpha)\}$, viewing $f$ as a set.
Standard $\sO$ notation is used to suppress polynomial factors.
Proofs of statements marked with {\appsymbNote} are deferred to the appendix.

\subparagraph{Clique-width.}
A graph of clique-width $k$ can be constructed through a sequence of the following operations on vertices that are labeled with at most $k$ different labels.
We can use (1) introducing a single vertex~$v$ of an arbitrary label~$i$, denoted $i(v)$,
(2) disjoint union of two labeled graphs, denoted $H_1 \oplus H_2$,
(3) introducing edges between \emph{all} pairs of vertices of two distinct labels~$i$ and~$j$ in a labeled graph~$H$, denoted $\eta_{i,j}(H)$,
and (4) changing the label of \emph{all} vertices of a given label~$i$ in a labeled graph~$H$ to a different label~$j$,
denoted $\rho_{i \to j}(H)$.
An expression describes a graph~$G$ if $G$ is the final graph given by the expression (after we remove all the labels).
The \emph{width} of an expression is the number of different labels it uses.
The clique-width of a graph is the minimum width of an expression describing it~\cite{dam/CourcelleO00}.
For a labeled graph $H$ and $v \in V(H)$, let $\lab_H(v)$ denote the label of $v$ in $H$,
while $\lab^{-1}_H (i) = \setdef{v \in V(H)}{\lab_H(v) = i}$ denotes the set of vertices of $H$ of label $i$.
For $S \subseteq V(H)$, let $H[S]$ denote the labeled subgraph of $H$ induced by $S$.
A clique-width expression is \emph{irredundant} if whenever the operation $\eta_{i,j}$
is applied on a graph $G$, there is no edge between an $i$-vertex and a $j$-vertex in $G$,
and we will use such expressions to simplify our algorithms.
We remark that any clique-width expression can be transformed in linear time into an irredundant one of the same width~\cite{dam/CourcelleO00}.

\subparagraph{pw-SETH.} The \emph{primal pathwidth SETH} (pw-SETH) states that,
for all $\varepsilon>0$, 3-SAT requires time at least
$(2-\varepsilon)^{\pw}n^{\bO(1)}$, where $\pw$ is the pathwidth of the primal
graph of the input formula. In other words, the pw-SETH posits that the simple
DP algorithm which solves 3-SAT in time $\sO(2^{\pw})$ is best possible.
Beating this algorithm seems to encapsulate the difficulty of improving upon
simple DP algorithms in general and indeed the pw-SETH is \emph{equivalent} to
many tight lower bounds for problems parameterized by linear structure widths
(pathwidth or linear clique-width) \cite{soda/Lampis25}. The pw-SETH also has
the advantage of being implied by several other standard assumptions, such as the
Set Cover Conjecture and the SETH for circuits of depth $\varepsilon n$~\cite{arxiv/Lampis24},
making lower bound results based on the pw-SETH seem more believable.

In this paper we present two such lower bound results based on the pw-SETH, in
one case (for \textsc{Induced Matching} parameterized by pathwidth) showing
that breaking our bound is \emph{equivalent} to the pw-SETH. For this, we
recall some notions and results from~\cite{soda/Lampis25} which we will make
use of later in our reductions, and in particular in
\cref{lem:induced:lb:CSP->Induced,thm:acyclic:lb}. Informally, reductions in
this context start from a constraint satisfaction problem \textsc{CSP} with
alphabet size equal to the desired base of the lower bound, similarly to
SETH-based reductions \cite{siamdm/Lampis20}. However, rather than reducing
from a \textsc{CSP} instance parameterized by the number of variables we reduce
by an instance parameterized by the pathwidth of its primal graph, which
contains a vertex for each variable and an edge when two variables appear in a
common constraint. To facilitate the reduction, we use the fact that it is hard
(under pw-SETH) to distinguish between \textsc{CSP} instances which are
satisfiable and instances which are unsatisfiable even if for the majority of
variables we are allowed to select multiple assignments, albeit while only
modifying values in a monotone way along the given path decomposition.


\begin{definition}[{\cite[Definition~3.2]{soda/Lampis25}}]
    Suppose we have a \textsc{CSP} instance $\psi$ over an alphabet $[B]$ of size $B \ge 2$,
    with variable set $V$, a path decomposition of its primal graph $B_1,\ldots, B_t$,
    and an injective function $b$ mapping each constraint to the index of a bag that contains all its variables.
    A \emph{multi-assignment} is a function $\sigma$ that takes as input a variable
    $x \in V$ and an index $j \in [t]$ such that $v \in B_j$ and returns a value in $[B]$.
    We will say that:
    \begin{enumerate}
        \item A multi-assignment $\sigma$ is \emph{satisfying} for $\psi$ if for each constraint $c$,
        the assignment $\sigma_c(x) = \sigma(x,b(c))$, that is,
        the restriction of the multi-assignment to $b(c)$,
        satisfies the constraint.

        \item A multi-assignment $\sigma$ is \emph{monotone} if for all $x \in V$ and $j_1<j_2$
        with $x \in B_{j_1} \cap B_{j_2}$ we have $\sigma(x,j_1) \le \sigma(x,j_2)$.

        \item A multi-assignment $\sigma$ is \emph{consistent} for $x \in V$ if for all
        $j_1,j_2 \in [t]$ such that $x \in B_{j_1} \cap B_{j_2}$
        we have $\sigma(x,j_1)=\sigma(x,j_2)$.
    \end{enumerate}
\end{definition}



\begin{corollary}[{\cite[Corollary 3.1]{soda/Lampis25}}]\label{cor:weird}
    For all $\varepsilon>0, B \ge 2$ we have the following.
    Suppose there is an algorithm that takes as input a $4$-\textsc{CSP} instance $\psi$ over
    an alphabet of size $B$,
    a partition of its variables into two sets $V_1, V_2$,
    a path decomposition of its primal graph of width $p$ where each bag contains at most
    $\bO (B \log p)$ variables of $V_2$,
    and an injective function $b$ mapping each constraint to a bag that contains its variables.
    The algorithm decides if there exists a monotone satisfying multi-assignment $\sigma$,
    which is consistent for the variables of $V_2$.
    If the supposed algorithm runs in time $\bO ( (B-\varepsilon)^p |\psi|^{\bO(1)})$,
    then the pw-SETH is false.
\end{corollary}
