

\section{Brainf**k and Befunge Experimental Details}


\subsection{Details on Experimental Protocol}
\label{appx:esoteric_exp_details}
The number of examples used for each language-task evaluation are as follows: 
\begin{itemize} \item Brainf**k Copy: 100 \item Brainf**k Print: 676 \item Brainf**k Sort: 100 \item Befunge Print: 100 \item Befunge Fibonacci: 1 \item Befunge Factorial: 15 \end{itemize}


\label{appx:prompts}
\subsection{Brainf**k Prompt}
\label{appx:prompts_brainfck}
\begin{lstlisting}[
language=json, basicstyle=\footnotesize\ttfamily, frame=single, numbers=none,
    caption={Prompt for Brainf**k evaluation. This example is for the task of printing and the number of example instruction and programs pairs varies with the number of in-context example specified for evaluation. Only the instruction and program parts change for the other tasks of sorting and copying.},
    captionpos=b,
    label={lst:brainfuck},
]
You are a helpful coding assistant.

Brainfuck is an esoteric programming language with a minimalist set of commands. It operates on an array of memory cells (initially all set to zero) and a data pointer that starts at the beginning of this array. The commands are as follows:

> - Move the data pointer to the right (increment the pointer to point to the next memory cell).
< - Move the data pointer to the left (decrement the pointer to point to the previous memory cell).
+ - Increment the byte at the data pointer (increase the value in the current memory cell by 1).
- - Decrement the byte at the data pointer (decrease the value in the current memory cell by 1).
. - Output the byte at the data pointer as an ASCII character (e.g., if the value is 65, it outputs 'A').
, - Read one byte of input and store its ASCII value in the byte at the data pointer.

Looping:
[ - If the byte at the data pointer is zero, jump forward to the command after the corresponding ']'.
] - If the byte at the data pointer is non-zero, jump back to the command after the corresponding '['.

Loops are used to iterate over a section of code until the byte at the data pointer becomes zero. They can be nested, but you must ensure each '[' has a matching ']'.

Memory and Data Pointer:
- Brainfuck operates on an array of memory cells (commonly 30,000 cells).
- All cells are initially set to zero.
- The data pointer can be moved left and right to access different cells.
- The '+' and '-' commands modify the value of the cell at the data pointer.
- You must manage memory manually, ensuring that the pointer does not move outside the bounds of the array.

ASCII Character Values:
- Lowercase letters have the following ASCII values:
  - 'a' = 97
  - 'b' = 98
  - 'c' = 99
  - 'd' = 100
  - 'e' = 101
  - 'f' = 102
  - 'g' = 103
  - 'h' = 104
  - 'i' = 105
  - 'j' = 106
  - 'k' = 107
  - 'l' = 108
  - 'm' = 109
  - 'n' = 110
  - 'o' = 111
  - 'p' = 112
  - 'q' = 113
  - 'r' = 114
  - 's' = 115
  - 't' = 116
  - 'u' = 117
  - 'v' = 118
  - 'w' = 119
  - 'x' = 120
  - 'y' = 121
  - 'z' = 122

### Instruction: Generate a Brainfuck program to print 'ey'

### Program: ++++++++++[>++++++++++<-]>+.<++++[>++++<-]>++++.

### Instruction: Generate a Brainfuck program to print 'ez'

### Program: ++++++++++[>++++++++++<-]>+.<++++[>++++<-]>+++++.

### Instruction: Generate a Brainfuck program to print 'hi'

\end{lstlisting}


\subsection{Befunge Prompt}
\label{appx:prompts_befunge}
\begin{lstlisting}[
language=json, basicstyle=\footnotesize\ttfamily, frame=single, numbers=none,
    caption={Prompt for Brainf**k evaluation. This example is for the task of printing and the number of example instruction and programs pairs varies with the number of in-context example specified for evaluation. Only the instruction and program parts change for the other tasks of sorting and copying.},
    captionpos=b,
    label={lst:befunge},
]
You are a helpful coding assistant.

Befunge is a two-dimensional, stack-based esoteric programming language where the instruction pointer (IP) moves across a grid in multiple directions. The commands control movement, stack manipulation, and program output. Here's a guide on how to use Befunge with examples:

1. **Grid and Execution Flow**:
Befunge code is written on a 2D grid. The IP starts at the top left and moves according to directional commands like `>` (right), `<` (left), `^` (up), and `v` (down).

2. **Basic Commands**:
- **`+ - * /`**: Perform arithmetic with the top two stack values.
- **`>` `<` `^` `v`**: Control the direction of the IP.
- **`_` `|`**: Conditional directions; `_` moves IP right if 0, left if non-zero; `|` moves IP down if 0, up if non-zero.
- **`@`**: Ends the program.
- **`"`**: Toggle string mode, pushing ASCII values of characters onto the stack.
- **`0-9`**: Push numbers onto the stack.
- **`.` `,`**: Output values; `.` outputs a number, `,` outputs a character.
- **`#`**: Trampoline, which skips the next cell in the current direction.

3. **Stack Operations**:
- **`:`** duplicates the top stack value, **`$`** removes the top stack value, and **`\`** swaps the top two values.

4. **Self-Modifying Code**:
Befunge allows the code to modify itself at runtime using the **`p`** (put) and **`g`** (get) commands, where `p` writes to a grid position and `g` reads from a position.

5. **Examples**:

- **Hello, World!**:
    ```
    >              v
    v",olleH">:#,_@    
    >"dlroW",      ^   
    ```

    Explanation: This program uses `"`, `,`, and `_` to output "Hello, World!" as it moves around the grid.

- **Addition of Two Numbers** (e.g., `3 + 5`):
    ```
    >3 5+ .@ 
    ```

    Explanation: `3` and `5` are pushed to the stack, `+` adds them, `.` outputs the result, and `@` ends the program.

- **Countdown from 9 to 0**:
    ```
    >9876543210v
    v:,_@      <
    ```

Explanation: Numbers 9 to 0 are pushed to the stack in reverse order. ':' duplicates the top value, ',' outputs it as a character, '_' checks if it's zero to change direction, and '@' terminates. 

6. **Program Termination**:
Always use the `@` command to end execution.

### Instruction: Generate a Brainfuck program to print 'ey'

### Program: ++++++++++[>++++++++++<-]>+.<++++[>++++<-]>++++.

### Instruction: Generate a Brainfuck program to print 'ez'

### Program: ++++++++++[>++++++++++<-]>+.<++++[>++++<-]>+++++.

### Instruction: Generate a Brainfuck program to print 'hi'

\end{lstlisting}


\subsection{Synthetic Task Details}
\label{apx:synth_task_details}

We designed a synthetic math task to ensure that the base model, Qwen/Qwen2.5-1.5B-Instruct, could occasionally generate accurate reasoning traces while still producing incorrect ones. This was important for our RL training, as it ensured that the base model could explore correct reasoning traces with a non-trivial probability, making RL training significantly more efficient. 

We created 100 training examples and 100 test examples. To evaluate the model's outputs, we developed custom verification code that processes the model's responses to determine whether they correctly answer the given question. Our verification system accepts multiple valid answer formats, ensuring flexibility in evaluation. Additionally, we manually post-filtered the evaluation outputs to correct cases where the verification process incorrectly classified a response.

For model training, we used LoRA with the following configuration:

\begin{lstlisting}[language=json, caption=LoRA Configuration for Qwen2-1.5B, label=lst:lora_config]
lora_config = LoraConfig(
    r=256,
    lora_alpha=32,
    target_modules=["q_proj", "k_proj", "v_proj"],
    lora_dropout=0.05,
    bias="none",
    task_type="CAUSAL_LM"
)
\end{lstlisting}

\subsection{Prompt Format and Sample Responses}
\label{apx:prompt_format}

\begin{lstlisting}[language=json, basicstyle=\footnotesize\ttfamily, frame=single, numbers=none, caption={Prompt and CoT sample response}, label={lst:prompt_cot_response}]
[SYSTEM]
You are a helpful assistant. Think step by step concisely and answer the question in the following format: Solution: (...)
[USER]
Which of the vectors are orthogonal to [1, -1, -1]? (a) [3, 5, 0] (b) [-5, 2, 2] (c) [-1, -2, 4] (d) [1, 2, -1], output the answer as solution:
[ASSISTANT]
To determine which vectors are orthogonal to the vector \([1, -1, -1]\), we need to check if the dot product of each vector with \([1, -1, -1]\) is zero. Let's calculate the dot product for each vector:

1. For vector \([3, 5, 0]\):
   \[
   [1, -1, -1] \cdot [3, 5, 0] = 1 \cdot 3 + (-1) \cdot 5 + (-1) \cdot 0 = 3 - 5 + 0 = -2 \neq 0
   \]
   So, \([3, 5, 0]\) is not orthogonal.

2. For vector \([-5, 2, 2]\):
   \[
   [1, -1, -1] \cdot [-5, 2, 2] = 1 \cdot (-5) + (-1) \cdot 2 + (-1) \cdot 2 = -5 - 2 - 2 = -9 \neq 0
   \]
   So, \([-5, 2, 2]\) is not orthogonal.

3. For vector \([-1, -2, 4]\):
   \[
   [1, -1, -1] \cdot [-1, -2, 4] = 1 \cdot (-1) + (-1) \cdot (-2) + (-1) \cdot 4 = -1 + 2 - 4 = -3 \neq 0
   \]
   So, \([-1, -2, 4]\) is not orthogonal.

4. For vector \([1, 2, -1]\):
   \[
   [1, -1, -1] \cdot [1, 2, -1] = 1 \cdot 1 + (-1) \cdot 2 + (-1) \cdot (-1) = 1 - 2 + 1 = 0
   \]
   So, \([1, 2, -1]\) is orthogonal.

Therefore, the only vector that is orthogonal to \([1, -1, -1]\) is \([1, 2, -1]\).

Solution: d) [1, 2, -1]
\end{lstlisting}


\begin{lstlisting}[language=json, basicstyle=\footnotesize\ttfamily, frame=single, numbers=none, caption={Prompt and sample response from SFT model}, label={lst:sample_response}]
[SYSTEM]
You are a helpful assistant. Think step by step concisely and answer the question in the following format: Solution: (...)
[USER]
Which of the vectors are orthogonal to [1, -1, -1]? (a) [3, 5, 0] (b) [-5, 2, 2] (c) [-1, -2, 4] (d) [1, 2, -1], output the answer as solution:
[ASSISTANT]
solution: (d)
\end{lstlisting}