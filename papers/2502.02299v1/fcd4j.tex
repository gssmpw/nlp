\documentclass[10pt, conference]{IEEEtran}
\usepackage[T1]{fontenc}
\usepackage{graphicx} % Required for inserting images
\usepackage{hyperref}
\hypersetup{ hidelinks,}
\usepackage{paralist}
\usepackage{colortbl}
\usepackage{subcaption}
\captionsetup{compatibility=false}
\usepackage{formal-grammar}
\usepackage[capitalise, noabbrev]{cleveref}
\Crefname{lstlisting}{Listing}{Listings}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{xcolor}
\usepackage{soul}
\usepackage{tabularray}
\UseTblrLibrary{booktabs}
\usepackage{listings}

\lstdefinestyle{mystyle}{
  language=Java, 
  upquote=true,
  basicstyle=\scriptsize\ttfamily,
  breakatwhitespace=false,         
  breaklines=true,                 
  captionpos=b,                    
  keepspaces=true,                 
  showspaces=false,                
  showstringspaces=false,
  showtabs=false,                  
  tabsize=2,
  escapeinside={(*@}{@*)},
}

\lstset{style=mystyle}

\definecolor{lgreen}{RGB}{144, 238, 144}
\definecolor{lred}{RGB}{255, 114, 118}

\begin{document}
\title{Flow Graph-Based Classification of Defects4J Faults}
\author{\IEEEauthorblockN{Alexandra van der Spuy}
\IEEEauthorblockA{Stellenbosch University\\
Stellenbosch, South Africa\\
Email: 23552395@sun.ac.za} 
\and 
\IEEEauthorblockN{Bernd Fischer}
\IEEEauthorblockA{Stellenbosch University\\
Stellenbosch, South Africa\\
Email: bfischer@sun.ac.za}}
  
\maketitle

\begin{abstract}
Software fault datasets such as Defects4J provide for each individual fault its
location and repair, but do not characterize the faults. Current
classifications use the repairs as proxies, which does not capture the intrinsic nature of the fault.  
In this paper, we propose a new,
direct fault classification scheme based on the control- and data-flow graph
representations of the program.  Our scheme comprises six control-flow and two
data-flow fault classes.  We apply this to 488 faults from seven
projects in the Defects4J dataset.  We find that one of the data-flow fault
classes (definition fault) is the most common individual class but that the 
majority of faults are classified with at least one control-flow fault class.  
The majority of the faults are assigned between one and three classes.  Our proposed
classification can be applied to other fault datasets and can be used to
improve fault localization and automated program repair techniques for specific
fault classes.
\end{abstract}

%======================================================================
\section{Introduction}
%======================================================================
Software debugging is an expensive and time-consuming process~\cite{DiGiuseppe2015,Defects4JDissection}, requiring faults to be found (\emph{fault localization}) and fixed (\emph{fault repair}).
Its effectiveness depends on several factors, but one factor that is often overlooked is the nature of the fault itself~\cite{Nath_Merkel_Lau_2012}.
Typically, this fault nature is unknown, but an analysis of known real-world faults allows us to identify common fault types, which can in turn be used to improve fault localization and repair techniques.

However, investigating the \emph{intrinsic nature} of faults can be labor-intensive,
and classifications typically use the applied repairs as proxies
\cite{Pan_Kim_Whitehead_2009,Nath_Merkel_Lau_2012,Lucia_Lo_Jiang_Thung_Budi_2014,Defects4JDissection}.
This allows automating the classification process but it does not necessarily
capture the intrinsic nature of the faults themselves, since faults can
typically be repaired in different ways.

In this paper, we describe a new fault classification scheme based on
control- and data-flow graphs.  The main novelty of our scheme is its grounding
in the (abstract) structural properties of the faults themselves, rather than
the applied repairs. This not only eliminates any potential bias by
repair-based classifications, it also emphasizes the commonalities of different
faults under syntactic variations. Consider for example the faults (and
repairs) shown in \cref{listing:lang62,listing:chart18}. In both cases, the
underlying problem is that the control flow from the fault location to the next
location is wrong (i.e., whenever the program executes the faulty statement,
it executes the wrong statement next), despite the differences in the
faulty statements (i.e., return vs.\ missing statement) and
the repair (i.e., substitution of return by 
throw vs.\ insertion of break).
We thus classify both faults as (unconditional) control-flow target faults.

Our scheme comprises six control-flow and two data-flow fault classes.  We use
it to classify 488 faults from seven projects in the Defects4J dataset; the
classification results are available at
\url{https://github.com/alexvdspuy/fcd4j}.  The most common individual class is
one of the data-flow fault classes (definition fault); however, the
control-flow classes are overall more common.  Similar to repair
classes~\cite{Defects4JDissection}, our fault classes are not disjoint since
a single fault can have characteristics of multiple classes.
The majority of the faults are thus assigned one to three of the eight classes.

\section{Flow Graph-Based Classification}\label{sec:fgbc}
%======================================================================

\subsection{Flow graphs}\label{subsec:fg}
%----------------------------------------------------------------------
We base our classification on flow graph representations of programs.
Specifically, we consider the control-flow graph (CFG) and data-flow graph
(DFG) as a single structure $G=(V,E_C,E_D)$, where the vertices $V$
correspond to the program statements, the CFG edges $E_C$
correspond to changes in the program counter, and the DFG edges $E_D$
represent associations between variable writes or \emph{defs} and their
references or \emph{uses}.
%
The flow graph construction, with explicit def-use association edges, is fairly
standard \cite{Allen1970,Ribeiro2019}.  For the classification we assume that
($i$) jumps (i.e., break-, continue-, return-, and
throw-statements) are represented by CFG edges only, and not by
vertices, and ($ii$) method calls are represented by a vertex modeling the
parameter passing and a CFG edge modeling the jump.
We list our fault classes in \S\ref{subsec:cf}~to~\ref{subsec:df}.

%======================================================================

%----------------------------------------------------------------------
\subsection{Control-flow faults}\label{subsec:cf}
%----------------------------------------------------------------------

%......................................................................
\subsubsection{Unconditional control-flow target faults}\label{subsubsec:unconditionaltargetf}
%......................................................................

Such faults occur when at least one CFG edge has the wrong target
and the source of the faulty edge 
has no other outgoing edge, i.e., is not a predicate node. Any 
run that reaches the source will thus traverse the faulty edge and inevitably enter an error state, but not necessarily fail.
Faulty edges can correspond to wrong statement orders, or to missing,
extraneous, or wrong jumps and method calls. 
Furthermore, the flow graph must already have the correct set of vertices,
unless the fault occurs in combination with other faults.

%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Statement order faults}\label{par:order} 
%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
Such faults occur when a sequence of consecutive edges connect multiple
vertices in the wrong order, but the set of source and target vertices of these
edges is correct; a repair rearranges the edges' sources and targets, which
corresponds to reordering the statements. Closure-$13$ shows an example:
%
\begin{lstlisting}[caption={Statement order fault (Closure-$13$)},label={listing:closure13}]
(*@\sethlcolor{lred}\hl{+}@*) (*@\sethlcolor{lred}\hl{traverse(c);}@*)
  Node next = c.getNext();
(*@\sethlcolor{lgreen}\hl{+}@*) (*@\sethlcolor{lgreen}\hl{traverse(c);}@*)
  c = next; 
\end{lstlisting}

%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Jump faults}\label{par:jump} 
%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A jump fault occurs if the target of a single edge is wrong; this edge
can connect two adjacent statements, representing the normal control
flow, or span a larger gap, representing a jump statement.  In both cases the
repair effectively ``re-wires'' this edge.
%
For example, Chart-$18$ contains a \emph{wrong} jump, where the
return-statement induces a CFG edge with the wrong target; replacing it with
a throw-statement induces an edge with the correct target:
\begin{lstlisting}[caption={Jump fault---wrong jump target (Chart-$18$)},label={listing:chart18}]
  if (index < 0) {
(*@\sethlcolor{lred}\hl{-}@*)   (*@\sethlcolor{lred}\hl{\textbf{return};}@*)
(*@\sethlcolor{lgreen}\hl{+}@*)   (*@\sethlcolor{lgreen}\hl{\textbf{throw} new UnknownKeyException("The key (" + key}@*)
(*@\sethlcolor{lgreen}\hl{+}@*)       (*@\sethlcolor{lgreen}\hl{    + ") is not recognised.");}@*)
  }
\end{lstlisting}
In contrast, Lang-$62$ contains a \emph{missing}
jump fault where the control flow incorrectly connects the assignment
to the next case-label, and the insertion of the break-statement repairs this.
Similarly, removing a faulty \emph{extraneous} jump restores the
normal control flow.
\begin{lstlisting}[caption={Jump fault---missing jump (Lang-$62$)},label={listing:lang62}]
  case 'x' : {
    entityValue = Integer.parseInt(entityContent
        .substring(2), 16);
(*@\sethlcolor{lgreen}\hl{+}@*)   (*@\sethlcolor{lgreen}\hl{\textbf{break};}@*)
  }
\end{lstlisting}

%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Method call faults}\label{par:method}
%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
The similarity between jumps and method calls also extends to faults. The only
small difference is that the \emph{repair} of a missing
method call with arguments also requires inserting the vertex
that models the parameter passing; this implies that such faults are also
definition faults (\S\ref{subsubsec:def}).
Listings~\ref{listing:time22} and \ref{listing:math64} show a \emph{wrong} resp.\ \emph{missing} method call (cf.\ 
Listings~\ref{listing:chart18} and \ref{listing:lang62} for the corresponding jump faults).
\sethlcolor{lgreen}
\begin{lstlisting}[caption={Method call fault---wrong method (Time-$22$)},label={listing:time22}]
(*@\sethlcolor{lred}\hl{-}@*) (*@\sethlcolor{lred}\hl{\textbf{this}(duration, \textbf{null}, \textbf{null});}@*)
(*@\sethlcolor{lgreen}\hl{+}@*) (*@\sethlcolor{lgreen}\hl{\textbf{super}();}@*)
\end{lstlisting}
\vspace{-2ex}
\begin{lstlisting}[caption={Method call fault---missing call (Math-$64$)},label={listing:math64}]
  if (maxCosine <= orthoTolerance) {
    // convergence has been reached
(*@\hl{+}@*)   (*@\hl{updateResidualsAndCost();}@*)
\end{lstlisting}

%......................................................................
\subsubsection{Control-flow predicate faults}\label{subsubsec:guardaroundbodyf}
%......................................................................
Control-flow predicates (i.e., the conditions of conditionals and loops)
determine which CFG paths a program follows.  A control-flow predicate fault
occurs if at least one of these paths is incorrect.  This can be caused by a
fault in the condition itself, missing/extraneous predicate vertices
guarding otherwise correct existing vertices, or entire
predicate blocks that are missing.

In contrast to unconditional jump target faults, a program with a control-flow
predicate fault may reach the fault location without entering an erroneous state (e.g.,
a run of the fault entry of Lang-$55$ shown in \cref{listing:lang55}, in
which the inserted predicate would evaluate to true, does not cause an error).

%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Predicate vertex faults}\label{par:pred}
%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
This class captures faults where the CFG structure is correct, but
the label of a predicate vertex (i.e., the condition) is wrong.  
For example, Chart-$1$ contains a predicate vertex
fault, but if the faulty vertex is also the target of a faulty DFG edge (i.e., 
references a wrong variable), it is also classified as a data-flow fault.
\begin{lstlisting}[caption={Predicate vertex fault (Chart-$1$)},label={listing:chart1}]
(*@\sethlcolor{lred}\hl{-}@*) if (dataset (*@\sethlcolor{lred}\hl{!=}@*) null) {
(*@\sethlcolor{lgreen}\hl{-}@*) if (dataset (*@\sethlcolor{lgreen}\hl{==}@*) null) {
    return result;
  }
\end{lstlisting}

%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Predicate existence faults}\label{par:guard}
%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
This class captures faults where the CFG has an
extraneous (resp.\ missing) predicate node guarding existing vertices, leading to paths that execute the guarded vertices in too few (resp.\ many) paths.
For example, Lang-$55$ contains a \emph{missing} if-guard fault: 
\sethlcolor{lgreen}
\begin{lstlisting}[caption={Predicate existence fault---missing if (Lang-$55$)},label={listing:lang55}]
  }
(*@\hl{+}@*) (*@\hl{\textbf{if}(\textbf{this}.runningState == STATE\_RUNNING) \{}@*)
    stopTime = System.currentTimeMillis();
(*@\hl{+}@*) (*@\hl{\}}@*)
  this.runningState = STATE_STOPPED;
\end{lstlisting}

%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
\paragraph{Predicate block faults}\label{par:block}
%. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
In contrast to predicate existence faults, predicate \emph{block} faults
capture faults where the CFG is missing not only the predicate vertex but also
the entire guarded block.
Closure-$85$ contains such a fault:
\sethlcolor{lgreen}
\begin{lstlisting}[caption={Predicate block fault---missing while (Closure-$85$)},label={listing:closure85}]
  Node next = ControlFlowAnalysis.computeFollowNode(n);
(*@\hl{+}@*) (*@\hl{\textbf{while} (next != \textbf{null} \&\& next.getType() == Token.BLOCK)}@*)
(*@\hl{+}@*)   (*@\hl{\textbf{if} (next.hasChildren())}@*)
(*@\hl{+}@*)     (*@\hl{next = next.getFirstChild();}@*)
(*@\hl{+}@*)   (*@\hl{\textbf{else}}@*)
(*@\hl{+}@*)     (*@\hl{next = computeFollowing(next);}@*)
  return next; 
\end{lstlisting}

%----------------------------------------------------------------------
\subsection{Data-flow faults}\label{subsec:df}
%----------------------------------------------------------------------
Data-flow faults occur when the value written into a memory location does not
match the requirements of a subsequent read from that location. This can be
caused by faulty or missing definitions, or by faulty uses. 

%......................................................................
\subsubsection{Definition faults}\label{subsubsec:def}
%......................................................................
Such faults occur at the source of a DFG edge.
We distinguish between a wrong write value (i.e., the wrong value is written to the correct variable, see \cref{listing:closure97}), wrong write location (i.e., the correct value is written to the wrong variable), or a missing definition.

\begin{lstlisting}[caption={Definition fault---wrong write value (Closure-$97$)},label={listing:closure97}]
(*@\sethlcolor{lgreen}\hl{+}@*) (*@\sethlcolor{lgreen}\hl{\textbf{long} lvalLong = lvalInt \& 0xffffffffL;}@*)
(*@\sethlcolor{lred}\hl{-}@*) result = (*@\sethlcolor{lred}\hl{lvalInt}@*) >>> rvalInt;
(*@\sethlcolor{lgreen}\hl{+}@*) result = (*@\sethlcolor{lgreen}\hl{lvalLong}@*) >>> rvalInt;
\end{lstlisting}

%......................................................................
\subsubsection{Use faults}\label{subsubsec:use}
%......................................................................
Such faults occur at the target of a DFG edge, where the variable is read from the wrong location.
Jsoup-57 contains a faulty use of \texttt{attributes} instead of \texttt{it}:

\begin{lstlisting}[caption={Use fault (Jsoup-$57$)},label={listing:jsoup57}]
(*@\sethlcolor{lred}\hl{-}@*) (*@\sethlcolor{lred}\hl{attributes}@*).remove((*@\sethlcolor{lred}\hl{attrKey}@*));
(*@\sethlcolor{lgreen}\hl{+}@*) (*@\sethlcolor{lgreen}\hl{it}@*).remove();
\end{lstlisting}

%======================================================================
\section{Dataset Construction Methodology}
%======================================================================
We use Defects4J~\cite{Defects4Jinfo}, a repository of real-world Java projects, as our data source.
We classify the 488~faults from seven Defects4J projects (see \cref{tab:project}) with manual thematic analysis, similar to the process described by Sobreira \emph{et al.}~\cite{Defects4JDissection}.
Each fault is inspected in terms of the source and repaired program, as well as failing test cases.
The fault is then assigned the appropriate fault classes from our classification scheme.
The first author of this paper performed manual classification, which was then reviewed by the second author, and another round of classification was done.

\begin{table*}[t!]
  \centering
  \caption{Project characteristics~\cite{Ribeiro2019,Defects4Jinfo,Marcilio_2023} and fault class frequency (maximum per project bolded)}\label{tab:project}
  \scalebox{0.9}{\begin{tblr}{
    colspec = {|l|r||r|r|r|r|r|r|r|r||r||r|r|r|r|},
    cell{1}{12} = {c=4}{c},
    % cell{1}{11} = {c=4}{c},
    cell{1}{3} = {c=9}{c},
    % cell{2}{3} = {c=6}{c},
    % cell{2}{9} = {c=2}{c},
    % cell{2}{11} = {c=1}{c},
    % cell{2}{12} = {c=1}{c},
    % cell{2}{13} = {c=1}{c},
    % cell{3}{13} = {c=1}{c},
    }\toprule
    & & Fault classes & & & & & & & & & Faults\\
    \cline{3-15}
    Project & KLOC 
    & order & jump & call & pred & guard & block 
    & def & use
    & Avg per fault
    & CF & DF & CF/DF & All
    \\
    \midrule
    Chart & $96$ 
    & $1$ & $3$ & $5$ & $4$ & $11$ & $3$ 
    & $\mathbf{15}$ & $7$ 
    & $1.88\pm 1.15$
    & $11$ & $6$ & $9$ & $26$
    \\
    Closure & $90$ 
    & $6$ & $9$ & $37$ & ${42}$ & $53$ & $30$
    & $\mathbf{81}$ & $6$ 
    & $1.98\pm 1.03$
    & $52$ & $14$ & $67$ & $133$
    \\
    Lang & $22$ 
    & $2$ & $18$ & $11$ & $11$ & $31$ & $11$ 
    & $\mathbf{43}$ & $8$ 
    & $2.08\pm 0.86$
    & $20$ & $12$ & $33$ & $65$
    \\
    Math & $85$ 
    & $1$ & $17$ & $29$ & $24$ & $36$ & $18$ 
    & $\mathbf{83}$ & $20$ 
    & $2.15\pm 1.04$
    & $22$ & $27$ & $57$ & $106$
    \\
    Mockito & $11$ 
    & $0$ & $3$ & $15$ & $2$ & $16$ & $6$ 
    & $\mathbf{28}$ & $4$ 
    & $1.95\pm 0.86$
    & $10$ & $4$ & $24$ & $38$
    \\
    Time & $28$ 
    & $3$ & $9$ & $6$ & ${7}$ & $17$ & $3$ 
    & $\mathbf{21}$ & $5$ 
    & $2.63\pm 1.61$
    & $6$ & $4$ & $17$ & $27$\\
    \hline[dotted]
    Jsoup & $10$ 
    & $3$ & $4$ & $36$ & $14$ & $30$ & $23$ 
    & $\mathbf{59}$ & $6$ 
    & $1.88\pm 0.85$
    & $33$ & $14$ & $46$ & $93$
    \\
    \midrule
    All & $342$ 
    & $16$ & $63$ & $139$ & $104$ & $194$ & $94$ 
    & $\mathbf{330}$ & $56$ 
    & $2.04\pm 1.03$
    & $154$ & $81$ & $253$ & $488$
    \\
    \bottomrule
  \end{tblr}}
  \vspace{-1ex}
\end{table*}

We consider the difference in the flow graphs of the faulty and fixed code to manually assign fault classes according to the intrinsic fault nature.
We infer the nature of the fault from the program context, taking into account the repair semantics.
However, we investigate alternative repairs and compare all repair flow graphs to the faulty flow graph---the applied repair does not drive our classification.

We note that Sobreira \emph{et al.}~\cite{Defects4JDissection} were unable to classify 22~of the 395~faults in terms of their repair patterns; we are able to classify these faults in terms of our classification scheme.
We also consider the Jsoup project, which has not been classified before and as such is unbiased by other classifications.

\subsection{Limitations}
We consider, similarly to Sobreira \emph{et al.}~\cite{Defects4JDissection}, each Defects4J fault entry as a single fault that may display characteristics of multiple classes.
However, certain entries do contain multiple independent faults (e.g., Chart-$18$).
For comparability and compatibility with the repair-based classification~\cite{Defects4JDissection}, we do not distinguish between multi-faults within an entry.

Several of the Defects4J patches combine the repair with refactoring (see \cref{listing:math46}).
This biases a repair-based classification and may inhibit our fault classification.

%======================================================================
\section{Dataset Statistics}
%======================================================================
\cref{tab:project} shows the frequency of each fault class, in terms of the number of faults it is assigned to, over the 488~classified Defects4J faults.
We see that \emph{definition} fault (data-flow) is the most common fault class for each project.
On the other hand, \emph{unconditional statement order} fault (control-flow) is the least common class.
Overall, the total control-flow classifications clearly outweigh the total data-flow classifications, despite individual control-flow classes being less frequently assigned.

We also see the distribution of the number of fault classes by the average number assigned per fault.
All faults are assigned, on average, around two fault classes, with Time displaying the highest average ($2.63$).
Furthermore, standard deviations of around $1.0$ show that faults are generally assigned between one and three fault classes.
\cref{fig:confm_ff} shows the co-assignments between our fault classes.
Each cell $i,j$ shows the percentage of faults assigned fault class $i$ that are also assigned fault class $j$.
There is high agreement between several classes,
especially with \emph{definition} fault.
Due to the discussed distribution, faults are often assigned more than one class, and definition fault is the most frequent class.

Because the fault classes are not disjoint, we consider disjoint fault types, where a fault is assigned only control-flow classes (pure CF), only data-flow classes (pure DF), or both (CF/DF).
The majority of faults display a mixture of control- and data-flow characteristics.

Sobreira \emph{et al.}~\cite{Defects4JDissection} investigate 395~Defects4J faults;
however, they focus on the repair actions and patterns, rather than fault types.
The repair actions are very fine-grained, since they distinguish between addition, removal, and modification in nearly all syntactic categories.
This leads to 28~different classes.
The nine repair patterns are more abstract, and thus closer to our classification.
However, some repair pattern categories are not useful for our purposes.
For example, \emph{single line} does not give much information about the fault itself---the fault is fixed in one line, but this is not the only possible fix.
\cref{fig:confm_rr} shows the co-assignments of seven repair classes from~\cite{Defects4JDissection}, which show fewer agreements than our own.
%
However, we argue that certain of their repair classifications are biased by the fix, and do not accurately represent the underlying fault.
Consider \cref{listing:lang7,listing:math46}:
\sethlcolor{lred}
\begin{lstlisting}[caption={Conditional block repair---removal (Lang-$7$)~\cite{Defects4JDissection}},label={listing:lang7}]
(*@\hl{-}@*) (*@\hl{\textbf{if} (str.startsWith("--")) \{}@*)
(*@\hl{-}@*)   (*@\hl{return \textbf{null};}@*)
(*@\hl{-}@*) (*@\hl{\}}@*)
\end{lstlisting}
\vspace{-2ex}
\begin{lstlisting}[caption={Unwraps-from repair---if-else (Math-$46$)~\cite{Defects4JDissection}},label={listing:math46}]
(*@\sethlcolor{lred}\hl{-}@*) return (*@\sethlcolor{lred}\hl{isZero ? }@*)NaN(*@\sethlcolor{lred}\hl{ : INF}@*);
(*@\sethlcolor{lgreen}\hl{+}@*) return NaN;
\end{lstlisting}
The underlying fault in \cref{listing:lang7} is not the conditional, but the return-statement; removing only the return would also be a valid fix.
We instead classify this as an \emph{unconditional jump fault}.
The \emph{unwraps-from} classification in \cref{listing:math46} is biased by the fix, when the fault is a \emph{definition} and \emph{use} fault (referencing and returning \texttt{INF} instead of \texttt{NaN}).
\cref{fig:confm_f} shows the percentage correlation between our assigned fault classes with the repair-based classes~\cite{Defects4JDissection}, and \cref{fig:confm_r} shows the reverse.
We see several one-sided agreements between the classifications, with
(\emph{cond block, guard}) and (\emph{expr fix, pred}) the only pairs to show two-sided majority agreement.
This illustrates that the two classifications are distinct.
\cref{fig:confm_ff,fig:confm_r} show that both fault and repair class assignments often correlate with the definition fault class,
implying that these faults and fixes often focus on definitions.

\begin{figure}[!htb]
  \centering
  \begin{subfigure}[t]{0.49\columnwidth}
    \centering
    \includegraphics[width=4.25cm]{figures/heat_ff.pdf}
    \caption{Fault vs.\ fault}\label{fig:confm_ff}
  \end{subfigure}
  \begin{subfigure}[t]{0.49\columnwidth}
    \centering
    \includegraphics[width=3.9cm]{figures/heat_rr.pdf}
    \caption{Repair vs.\ repair}\label{fig:confm_rr}
  \end{subfigure}
  \begin{subfigure}[t]{0.49\columnwidth}
    \centering
    \includegraphics[width=4.4cm]{figures/heat_f.pdf}
    \caption{Repair vs.\ fault (by fault)}\label{fig:confm_f}
  \end{subfigure}
  \begin{subfigure}[t]{0.49\columnwidth}
    \centering
    \includegraphics[width=4.4cm]{figures/heat_r.pdf}
    \caption{Repair vs.\ fault (by repair)}\label{fig:confm_r}
  \end{subfigure}
  \caption{Agreement matrices between classes (our fault classes, described in \S\ref{sec:fgbc}; repair classes~\cite{Defects4JDissection})}\label{fig:confm}
  \vspace{-1ex}
\end{figure}

%======================================================================
\section{Dataset Usage and Future Research Questions}
%======================================================================

Our fault classification scheme is useful for its exploration of intrinsic \emph{fault} characteristics, instead of repairs.
We suggest the use of our scheme and classified faults to investigate datasets similar to Defects4J and to reduce debugging costs.

We have already considered the research question ``Are spectrum-based fault localization (SBFL) techniques more effective for certain fault types?''
Our preliminary results show that SBFL performs worse on pure control-flow faults, likely because such faults often involve missing code, which is difficult to localize.
SBFL techniques suitable to specific fault types may be developed, then tested on our classified faults and compared with existing techniques.
We can also investigate the research question, ``Can the classification of an unknown fault be predicted from SBFL performance?''

Other possible applications include automated program repair. 
For example, we can use the fault class frequency information to guide automated program repair to attempt fixes in order of fault class frequency; 
if we can classify individual faults on-the-fly, we could even tailor individual repair operations to the specific fault classes.

%======================================================================
\section{Related Datasets}
%======================================================================
Goodenough and Gerhart~\cite{Goodenough_Gerhart_1975} give phase-based error
classification (\emph{construction}, \emph{specification}, \emph{design},
\emph{requirements}), but this is too abstract for our purposes.  They also
classify program errors into \emph{missing control-flow paths},
\emph{inappropriate path selection}, and \emph{inappropriate or missing
action}.  These classes are similar to some of our fault classes, 
but the classification does not account for all faults found in practice.

Duncan and Robson~\cite{Duncan_Robson_1996} focus on faults in C programs.
Their main classes are \emph{problematic construct}, \emph{multiple file usage}, and \emph{portability issues}.
However, some of the faults are overly specific (e.g., \emph{confusion of \& and \&\&}) or not applicable to our dataset (e.g., \emph{scanf with wrong types}).

Pan \emph{et al.}~\cite{Pan_Kim_Whitehead_2009} describe a classification
scheme of 27 bug fix patterns.  The scheme is quite fine-grained, e.g.,
\emph{change of if condition expression} and \emph{change of loop predicate}
form different classes, despite both being predicate faults.  However, since
certain fault characteristics can be deduced from the fix patterns, the schema
has found use and adoption.
%
Nath \emph{et al.}~\cite{Nath_Merkel_Lau_2012} use these classes as a fault
classification scheme for Java, while Lucia \emph{et
al.}~\cite{Lucia_Lo_Jiang_Thung_Budi_2014} limit their scheme to eight
categories, six of which are taken from Pan \emph{et
al.}~\cite{Pan_Kim_Whitehead_2009}, with two categories added (incl.\ \emph{others}).  
However, predicate faults remain divided between conditionals and loops.

DiGiuseppe and Jones~\cite{DiGiuseppe2015} investigate fault localization
performance wrt.\ four fault taxonomies, of which three are quite coarse, with
only between four and five fault types.  The single fine-grained taxonomy,
taken from Hayes \emph{et al.}~\cite{Hayes_Chemannoor_Holbrook_2011}, is a
generic fault taxonomy and includes classes such as \emph{visual stimulation}
and \emph{documentation}, which are typically not useful in bug datasets.
DiGiuseppe and Jones find no correlation between their classes and
localization effectiveness; however, our preliminary results show that such a
correlation likely exists for our classification, indicating it is more
suitable for such applications.

%----------------------------------------------------------------------

%======================================================================
\section{Conclusion}
%======================================================================
In this paper, we introduce a novel fault classification scheme based on program flow graphs.
We classify 488 faults from seven real-world projects in the Defects4J repository.
The distribution of the number of fault classes assigned per fault is generally similar between different projects; the average is around two classes assigned per fault, but faults are generally assigned between one and three classes.
The fault class frequency over all faults shows that the definition fault (data-flow) is the most frequent fault class with 330~faults classified as such.
The unconditional statement order fault (control-flow) is the least frequent, with only 16~faults classified as such.
However, pure data-flow faults are the least common in the dataset ($16.6\%$), compared with pure control-flow ($31.6\%$) and mixed control- and data-flow ($51.8\%$) faults.

\bibliographystyle{IEEEtran}
\bibliography{refs}


\end{document}
