\section{Method}
To support interactive experiences, our actuator needs to dynamically adjust its output according to the desired haptic feedback at a given time and tool position.
We now describe our real-time approach to reconstruct the tool's 3D position given the readings observed by the Hall sensors and the control strategy to govern the electromagnet-tool interaction.

\subsection{3D position estimation}
At the core of creating dynamic interactive experiences lies the ability to react in real-time to the movement of the user. Thus, a method to acquire the tool position with sufficient accuracy and precision with low latency is required. This is challenging due to the dynamic superimposition of the various magnetic fields (see Eq. \ref{eq:b_sum}). More precisely, directly computing the tool's position from the sensor readings would require inversion of Eq.~\ref{eq:basic_B}, which is non-linear and hence non-invertible, rendering an analytical solution for the tool position infeasible.

To overcome this difficulty, we introduce a reconstruction algorithm that optimizes an estimate of the tool's position given the Hall sensor readings in real time. We propose an iterative model fitting approach for 3D position estimation. We minimize the residual between the \emph{expected} sensor reading $\BiBold$, as predicted by our model of the magnetic field (Eq.~\ref{eq:b_sum}) given the current actuation, and the \emph{actual} measurements acquired by the Hall sensors $\BiTildeBold$. In this setting, the optimization variables are the tool's 3D position and its orientation. With a good initialization, which we attain by careful construction of the hardware, and exploiting the redundancy in the measurements, this algorithm provides accurate estimates of the tool's position in 3D, with a mean accuracy of 6.9$\pm 3.2$ mm, as shown in our technical evaluation.

For each Hall sensor ($\siBold \in \SBold$) defined by its 3D coordinate, $\siBold = [s_{x},s_{y},s_{z}]^T$, we seek to find the tool position $\RpenBold = [p_x,p_y, p_z]^T$ and orientation $\oBold = [\theta, \varphi]^T$ that provides the best model fit to the current reading. We use the global coordinate system for the sensors position $\RsiBold$ and tool position $\RpenBold$ with an origin in the center of the electromagnet, \ie $\ReBold = [0,0,0]$. The optimization problem is then given by:
\begin{equation}\label{eq:energy}
\arg\underset{\RpenBold,\ \oBold}{\min} \bigg[ \sum_{\siBold \in \SBold} \ \sum_{x,y,z}
\mathbf{w_i} \Big( \BpBold(\RsiBold - \RpenBold, \mpBold) + \BeBold(\RsiBold, \meBold) + \BnBold - \BiTildeBold \Big)^2 \bigg] \ ,
\end{equation}
where $\mathbf{w_i}$ selectively weighs the sensor axes depending on the value it reads (\ie a completely saturated sensor receives a weight close to 0). We pre-compute $\BeBold$ for different actuation strengths and $\BnBold$ denotes the background noise measured at startup.
We empirically found that including the tool orientation $\theta$ and $\varphi$ as free variables improves the position estimates by roughly 2 mm in Euclidean distance. However, the orientation estimates were too noisy to use in interactive settings.

We minimize Eq.~\ref{eq:energy} via iterative optimization. Specifically, we use PyTorch's second-order L-BFGS optimizer, which typically works well for non-smooth optimization instances such as ours and requires no parameter tuning. Gradients are computed automatically via auto-grad.

Our method relies on known sensor locations obtained via one-shot calibration. We empirically found that an initial estimate of the sensors' locations in the range of $1$ mm accuracy is required to support robust convergence of the algorithm.

\subsection{Actuation} \label{sc:actuation control}
Given the 3D pen-position, we can now deliver dynamically adjustable attractive and repulsive forces via the electromagnet to create desired haptic experiences. It remains in the hand of an application designer to decide with which intensity and in what direction the tool is pulled or pushed according to the desired user experience. \omniUIST is able to control 3 of the 6 DoF available, summing up forces and torques. We derive the case in which the goal is to control the three components of the haptic force $\mathbf{F_h}$, while controlling torques would follow an analogous derivation.

Under the magnetic dipole-dipole approximation, the force applied to the permanent magnet in the tool can be computed from the previous magnetic moments for the tool, $\mpBold$, and the electromagnet magnetization $\meBold$ we seek to control. Using the formulation of Yung \etal\cite{yung1998analytic} and rewriting it in matrix form allows us to derive a simple control law for the parameters of the electromagnet $\meBold^{set}$, given the location of the tool $\rpBold$, its dipole orientation $\mpBold$, and the desired haptic force $\mathbf{F_h}$:
\begin{equation}
\meBold^{set} = a_1 \ \left[\mathbb{D} \ + a_2 \ \mathbb{I}\right]^{-1} * \mathbf{F_h} \label{eq:force_me}
\end{equation}
\noindent where $a_1 = \frac{4\pi \rpen^{5}}{3\mu {0}}$, $a_2 = \langle\mpBold,\rBold\rangle$ can be computed from the tool position information (as described in the previous section).
The matrix $\mathbb{D}$ has elements
\begin{equation}\label{eq:d_ij}
d{i,j} = m_{p_i} \ r_{p_j} + m_{p_j} \ r_{p_i} - 5 \ a_2 \ (r_{p_i} / r_p^2) \ ,
\end{equation}
\noindent where $m_{p_{i}}$ and $r_{p_{i}}$ denote the $i$-component of the dipole $\mpBold$ (Eq. \ref{eq:mpBold}) and position $\rpBold$, respectively.
$\mathbb{I}$ is a diagonal identity matrix.

Finally, we use the calibration matrix from Eq.~\ref{eq:me_from_c_i} to find the electrical current to be applied to the individual coils:
\begin{equation}\label{eq:I_from_me}
\mathbf{I}^{set} = \mathbb{C}^{-1} * \meBold^{set} \ .
\end{equation}

By combining Eq.~\ref{eq:I_from_me} and \ref{eq:force_me}, the vector of desired haptic force $\mathbf{F_h}$ can be mapped into three actuation currents $\mathbf{I}^{set}$. This 3D-forces-onto-3D-currents mapping can always be decomposed into tangential and radial forces, using the tool's local coordinate system.

To only consider attractive and repelling forces and ignore the tangential component, Eq.~\ref{eq:I_from_me} can be further simplified to:
\begin{equation}
\mathbf{I}^{set} = \alpha \frac{2\pi \rpen^{3}}{3\mu _{0}} \ \rpBold \ ,
\end{equation}
\noindent where $\alpha$ is the intensity of the force and its sign denotes attraction or repulsion relative to the sphere. In this particular case, the electrical current vector, the direction of the tool, and the tool dipole can be assumed to be always collinear.

\subsection{Control implementation}
The tracking algorithm, electromagnet control, and user-facing components (AR applications) run on a commodity gaming PC (Intel Core i7-8086K with 6 cores at 4 GHz, 32 GB RAM, NVIDIA GeForce GTX 1080 Ti) on Windows 10. The system is implemented in Python 3.7 and uses PyTorch's L-BFGS solver. The optimization-based tracking algorithm runs at 40Hz at the highest precision (6.9 mm). The AR applications were implemented in Unity 2019, SteamVR, and the Varjo Unity Plugin v2.4.
\begin{figure}[!t]
\centering
\includegraphics[width=\columnwidth]{\dir/sensing/figures/hardware_v4.pdf}
\caption{\omniUIST hardware overview. Annotated view of the most important components of the system. All components can be acquired commercially or are easy to produce in a standard FabLab.
A top-down view of the physical device can be seen in Figure~\figref{fig:teaser_sensing}.}
\label{fig:control_Scheme}
\end{figure}

\subsection{Hardware integration}
Our hardware design is driven by two main factors. First, through a finite element analysis (FEA), we determined the physical characteristics of our hardware, such as coil diameter, core size, as well as the parameters of the permanent magnet embedded in the hand-held tool. This reference design strikes a balance between compact form-factor and force-generation capabilities. Second, we use off-the-shelf components for sensors and the voltage controller, in-house wound coils and in-house milled printed circuit boards (PCBs) to precisely mount the sensor's boards.

Reproducing \omniUIST only requires readily available components and few specialized tools, if any. The main hardware components are illustrated in Figure~\ref{fig:control_Scheme}.

Figure \ref{fig:comsol} plots the results from an FEA of the tool's magnet to identify the best configuration given our current spherical electromagnet design. We use a magnet with 15 mm diameter and 7 mm height (volume of 5 cm$^3$), which corresponds to a point in the dark red region of the plot, where the output vertical force at 5 A is maximal. Please note that these characteristics hold for magnets with similar volume: either wider and shorter cylinders or narrow and tall, providing ample room for the design of the handheld prop. Importantly, a bigger magnet would not necessarily perform better and may decrease performance (top right region of the plot), since the weight of the magnet counteracts the vertical actuation in repel mode.
\begin{figure}[!t]
\centering
\includegraphics[width=\columnwidth]{\dir/sensing/figures/magnet-choice-force.pdf}
\caption{Finite element analysis of actuation force as a function of the permanent magnet's dimensions. Our current design is based on a $15\times7$ mm magnet, which provides maximal force generation capabilities. However, the plot illustrates that there is a Pareto front of similarly well-performing shapes that could allow for different tool designs.}
\label{fig:comsol}
\end{figure}
\add{The omnidirectional electromagnet is based on a 30 mm diameter soft iron core encapsulated in 3D printed guides, aimed to assist during the manual winding (see Fig. \ref{fig:hardware}).}
\add{In contrast to~\cite{zarate2020contact}, we construct our coils layer by layer in an interwoven fashion.}

We iteratively add layers of x-winding, y-winding, and z-winding, respectively, until we reach an outer diameter of 65 mm. We use round copper wire with an external diameter of 0.9 mm (19 AWG) to obtain roughly 150 turns per coil. We employed a total cable length of $L_x = 21.4$ m, $L_y = 22.7$ m and $L_z = 24$ m for the x-, y- and z-coil respectively.
Since the x-coil is wound first, it has a smaller radius per layer, \ie a shorter perimeter per turn. The measured resistance of the coils are $R_x = 0.643 \ \Omega$, $R_y = 0.676 \ \Omega$ and $R_z = 0.708 \ \Omega$. The system supports up to 15 A of actuation current, which translates to a power of 157 W. To help remove the Joule heating generated within the coils, we place a brushless DC fan under the sphere (\emph{CUI Devices, 0.524 $m^3$/min}), and include air intakes on the side of \textit{Omni}.

To enable accurate and reliable tracking, it is paramount that the electromagnet and the Hall sensors are mounted rigidly with respect to each other. To ensure this, we fabricated custom PCBs using a desktop PCB milling machine (\emph{Bantam Tools}). The ring-shaped sensor PCB is located below the electromagnet, with two circular arrays that mount 4 Hall Sensors each (LIS3MDL, \emph{Pololu}).

All sensors are precisely aligned with the coil planes, such that each sensor's local coordinate system aligns with the global frame. The Hall sensors sample at up to 1kHz and are read out by a microcontroller (\emph{Teensy 4.0}), that communicates with the host PC.

We implemented an open-loop strategy to control the generated force. The approach is based on an analytical relation between the force, the coil actuation, and the tool location (Eq.~\ref{eq:force_me}), and relies on a few-point calibration. For actuation, we use three H-bridges (\emph{Pololu G2 18v17}) to control the current of each coil with a pulse width modulation (PWM) of the voltage. Given Ohm's law, we can directly control the current via the voltage if the resistance of each coil is known. Since electromagnets suffer from drift due to self-heating (and thus resistance changes), our system includes a coil-resistance drift compensation implemented directly on the actuation microcontroller. Two current sensors (\emph{INA260, Adafruit}) provide an independent measure of the voltage and current of each coil. A sliding window average of the measured current $I_i$ and voltage $V_i$ are used to stabilize force-generation.