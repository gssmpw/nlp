%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
\label{sec:intro}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\noindent
We are interested in input-output
specifications of higher-order programs that handle infinite 
data, such as streams or non-wellfounded trees.
Consider e.g.
\[
\begin{array}{r c l}
  \filter
& :
& (\BT \to \Bool)
  ~\longto~
  \Stream \BT
  ~\longto~
  \Stream \BT
\\

  \filter\ p\ (a \Colon x)
& =
& \term{if}~ (p\ a)
  ~\term{then}~ a \Colon (\filter\ p\ x)
  ~\term{else}~ (\filter\ p\ x)
\end{array}
\]

\noindent
where $\Stream\BT$ stands for the type of streams on $\BT$.
Assume $p : \BT \to \Bool$ is a function that
tests for a property $\psi$.
If $x$ is a stream on $\BT$,
then $(\filter\ p\ x)$ retains those elements of $x$ which satisfy $\psi$.
The stream produced by $(\filter\ p\ x)$ is thus only partially defined,
unless $x$ has infinitely many elements satisfying $\psi$.

Logics like $\LTL$, $\CTL$ or the modal $\mu$-calculus are
widely used to formulate, on infinite objects,
safety and liveness properties (see e.g.~\cite{hr07chapter,bs07chapter}).
Safety properties state that
some ``bad'' event will not occur,
while liveness properties 
specify that ``something good'' will happen 
(see e.g.~\cite{bk08book}).
One typically uses
temporal modalities like $\Box$
(\emph{always})
or $\Diam$
(\emph{eventually})
to write properties of streams and specifications of programs over such data.


A possible specification for $\filter$
asserts that $(\filter\ p \ x)$ is a totally defined stream whenever
$x$ is a totally defined stream with infinitely many elements satisfying $\psi$.
We express this with the temporal modalities $\Box$ and $\Diam$.
Let $\BT$ be finite and assume given,
for each $a$ of type $\BT$,
a formula $\form a$ which holds on $b : \BT$
exactly when $b$ is $a$.
Then $\Box \bigvee_a \form a$
selects those streams on $\BT$
which are totally defined.
The formula $\Box\Diam \form\hd\psi$ expresses that a stream
has infinitely many elements satisfying $\psi$.
We can thus state that for all streams $x : \Stream\BT$,
\begin{equation}
\label{eq:intro:spec}
\begin{array}{c}
  \text{$x$ satisfies $\Box\bigvee_a \form a$ and $\Box\Diam \form\hd\psi$}
  \quad\longimp\quad
  \text{$(\filter\ p\ x)$ satisfies $\Box\bigvee_a \form a$}
\end{array}
\end{equation}

It is undecidable whether a given higher-order program satisfies
such an input-output temporal property written with formulae
of the modal $\mu$-calculus \cite{ktu10popl}.
A previous work~\cite{jr21esop}
provided a refinement type system for proving such properties.
This type system handles the (negation-free) alternation-free modal $\mu$-calculus
on infinite types such as streams or trees.
But it is based on guarded recursion
and does not allow for non-productive functions such as $\filter$.


In this paper, we consider a fragment of $\FPC$ equipped with general
recursion ($\FPC$ extends $\PCF$~\cite{plotkin77tcs} with
recursive types, see e.g.\ \cite{pierce02book}).
%
We are interested in specifications as in \eqref{eq:intro:spec},
but interpreted at the level of denotational semantics:
In our view, since a stream (as opposed to e.g.\ an integer)
is an inherently infinite object, the above specification for $\filter$
should hold for any stream whatsoever, and not only
for those definable in a given programming language.

This leads us to consider temporal properties
on infinite datatypes in Scott domains.
We noted in \cite{rs24jfla} that the usual rule of Scott induction
(see e.g. \cite[\S 6.2]{ac98book}) does not prove liveness
properties like \eqref{eq:intro:spec} above.
We instead resort to Abramsky's paradigm of
``Domain Theory in Logical Form'' (DTLF) \cite{abramsky91apal}.
%
We build on~\cite{bk03ic}, in which Bonsangue and Kok extend DTLF
to an infinitary type system which is sound and complete for
a large family of infinitary properties, known as the \emph{saturated} ones.%
\footnote{A subset of a domain is \emph{saturated} when it is upward-closed.}
%
This includes
the \emph{negation-free} formulae of
(suitable adaptations of) the modal $\mu$-calculus \cite{rs24jfla},
and thus the specification in \eqref{eq:intro:spec}.


We present an infinitary refinement type system for saturated properties.
Our system is a reformulation of DTLF which,
in contrast with \cite{abramsky91apal,bk03ic}
(see also \cite[\S 10.5]{ac98book}),
has no specific syntactic entity for compact open sets.
We do isolate a finitary logical fragment,
but it only consists of finite conjunctions and falsity,
without non-empty disjunctions.
As consequence, our version of Abramsky's \emph{coprimeness predicate}
is a \emph{consistency} predicate,
which selects those finite formulae with a non-empty interpretation.
We think this is logically clearer.
Besides, our consistency predicate has a \emph{positive} (inductive) definition
(cf.\ \cite{bk03ic,ac98book}).


Also, similarly as in~\cite{bk03ic}, the completeness of
our system relies on a topological property of Scott domains
known as \emph{well-filteredness},
and reflected in an infinitary rule ($\ax{WF}$ in \S\ref{sec:wf}).
We show that this rule is actually not needed for an
interesting range of specifications,
including \eqref{eq:intro:spec} for $\filter$,
as well as
various specifications for functions on streams and trees
(see Example~\ref{ex:reft:fun} and Theorem~\ref{thm:main}).

Having some control on the rule $\ax{WF}$
is relevant in the context of this work.
We ultimately target a finitary system in which,
similarly as in~\cite{jr21esop},
infinitary behaviours of fixpoint formulae are simulated
by explicit quantifications over the number of unfoldings
of these fixpoints.
To this end, it is important to know that the rule $\ax{WF}$
can be avoided in many interesting cases.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\paragraph{Organization of the paper.}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We devise our refinement type system in \S\ref{sec:system}.
Its (Scott) semantics is presented in \S\ref{sec:sem},
and completeness is handled in \S\ref{sec:compl}.
Finally, \S\ref{sec:conc} discusses our results in the perspective of further works.

\opt{full}{Proofs are available in the Appendices.}






