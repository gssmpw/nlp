%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{A Refinement Type System}
\label{sec:system}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\noindent
We assume given a collection of sets $\Base$,
which will play the role of \emph{base types}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{The Pure System}
\label{sec:pure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

The \emph{pure types}
(notation $\PT,\PTbis,\dots$) are
the closed types over the grammar
\begin{equation*}
\begin{array}{r @{\ \ }c@{\ \ } l}
     \PT
&    \bnf
&    \BT
\gss \PT \times \PT
\gss \PT \arrow \PT
\gss \TV
\gss \rec \TV.\PT 
\end{array}
\end{equation*}

\noindent
where $\BT \in \Base$,
where $\TV$ ranges over an infinite supply of \emph{type variables},
and where $\rec\TV.\PT$ binds $\TV$ in $\PT$.
%
We consider terms from the grammar
\[
\begin{array}{r !{~}r!{~} l}
    M,N 
&   \bnf
&   x
\gs \lambda x.M
\gs M N
\gs \fix x.M
\gs \fold(M)
\gs \unfold(M)
\\

&   \mid
&   \pair{M,N}
\gs \pi_1(M)
\gs \pi_2(M)
\gs a
\gs \cse\ M\ \copair{a \mapsto N_a \mid a \in \BT}
\end{array}
\]

\noindent
where $\BT \in \Base$ and $a \in \BT$.
The term constructors $\fold, \unfold, \pi_1, \pi_2$
are often written in curried form,
so that e.g.\ $(\fold M)$ stands for $\fold(M)$.


Terms are typed as usual, with judgments of the form
$\Env \thesis M : \PT$, where $\Env$ is a list
$x_1:\PTbis_1,\dots,x_n:\PTbis_n$ with $x_i \neq x_j$
if $i \neq j$.
Some typing rules are presented in Figure~\ref{fig:reft:puretyping}.%
\footnote{The set of all typing rules of the pure system is in
Figure~\ref{fig:app:puretyping}, \S\ref{sec:app}.}
Of course, each type $\PT$ is inhabited
by the term $\Omega_\PT \deq \fix x.x : \PT$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t!]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{c}
\dfrac{\Env,x:\PT \thesis M : \PT}
  {\Env \thesis \fix x.M : \PT}
\qquad\quad

\dfrac{\Env \thesis M : \PT[\rec\TV.\PT/\TV]}
  {\Env \thesis \fold(M) : \rec\TV.\PT}

\qquad\quad

\dfrac{\Env \thesis M : \rec\TV.\PT}
  {\Env \thesis \unfold(M) : \PT[\rec\TV.\PT/\TV]}

\\\\

\dfrac{}
  {\Env \thesis a : \BT}

\qquad\quad

\dfrac{ \Env \thesis M : \BT
  \qquad\text{for each $a \in \BT$,\quad} \Env \thesis N_a : \PT}
  {\Env \thesis \cse\ M\ \copair{a \mapsto N_a \mid a \in \BT} : \PT}

\end{array}
\]
\caption{Typing rules of the pure calculus (excerpt).%
\label{fig:reft:puretyping}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% BEGIN FULL
\begin{full}
\begin{remark*} %[Operational Semantics]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
This paper concerns the denotational semantics
of the above fragment of $\FPC$ in %usual
Scott domains.
This denotational semantics, to be discussed in~\S\ref{sec:sem},
is compatible with the contextual closure of the %following
usual evaluation rules.
\[
\begin{array}{r c l !{\qquad} r c l}
  (\lambda x.M)N
& \rhd
& M[N/x]

& \unfold(\fold M)
& \rhd
& M
\\

  \pi_i \pair{M_1,M_2}
& \rhd
& M_i

& \fix x.M
& \rhd
& M[\fix x.M/x]
\\

  \cse\ a\ \copair{a \mapsto N_a \mid a \in \BT}
& \rhd
&  N_a
\end{array}
\]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{remark*}
\end{full}
% END FULL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example} %[Streams and Trees]
\label{ex:pure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The type of \emph{streams over $\PTbis$} is
$\Stream\PTbis \deq \rec\TV.\, \PTbis \times \TV$.
It is equipped with the constructor
\(
  \Cons
  \deq
  \lambda h .\lambda t.\fold \pair{h,t}
  :
  \PTbis \arrow \Stream\PTbis \arrow \Stream \PTbis
\).
We use the infix notation $(M \Colon N)$ for $(\Cons M\, N)$.
The usual \emph{head} and \emph{tail} functions
are $\hd \deq \lambda s.\, \pi_1 (\unfold s) : \Stream\PTbis \arrow \PTbis$
and $\tl \deq \lambda s.\, \pi_2 (\unfold s) : \Stream\PTbis \arrow \Stream\PTbis$.

The type of \emph{binary trees over $\PTbis$} is
$\Tree\PTbis \deq \rec\TV.\, \PTbis \times (\TV \times \TV)$.
The constructor
$\Node : \PTbis \arrow \Tree\PTbis \arrow \Tree\PTbis \arrow \Tree\PTbis$
and the destructors
$\lbl : \Tree\PTbis \arrow \PTbis$
and
$\lft, \rght : \Tree\PTbis \arrow \Tree\PTbis$
are defined similarly as resp.\ $\Cons, \hd, \tl$ on streams.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[t!]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{c}
\toprule

\begin{array}{r !{~}c!{~} l !{~}c!{~} l}
  \bm{\map}
& \deq
& \lambda f. \fix g. \lambda x.~
  (f\ (\hd x)) \Colon (g\ (\tl x))

& :
& (\PT \arrow \PTbis)
  \longarrow
  \Stream\PT
  \longarrow
  \Stream\PTbis

\end{array}


\\\midrule

\begin{array}{r !{~}l!{~} l}
  \bm{\filter}
& :
& (\PTbis \arrow \Bool)
  \longarrow
  \Stream\PTbis
  \longarrow
  \Stream\PTbis
\\


& \deq
& \lambda p. \fix g.\lambda x.~
  \term{if}~ (p\ (\hd x))
  ~\term{then}~ (\hd x) \Colon (g\ (\tl x))
  ~\term{else}~ (g\ (\tl x))
\end{array}


\\\midrule

\begin{array}{r !{~}l!{~} l !{~}c!{~} l}
  \bm{\diag}
& \deq
& \diagaux (\lambda x.x)
& :
& \Stream(\Stream \PTbis) \longarrow \Stream \PTbis
\\[0.5em]

  \bm{\diagaux}
& :
& \multicolumn{3}{l}{
  (\Stream\PTbis \arrow \Stream\PTbis)
  \longarrow
  \Stream (\Stream \PTbis)
  \longarrow
  \Stream \PTbis
  }
\\

& \deq
& \multicolumn{3}{l}{
  \fix g. \lambda k. \lambda x.~
  \big( (\hd \comp\, k) (\hd x) \big)
  \Colon
  \big( g\ (k \comp \tl)\ (\tl x) \big)
  }
\end{array}

\\\midrule

\begin{array}{c !{\qquad} c}

\begin{array}[t]{l !{~}l!{~} l}

  \bm{\extract}
& :
& \Rou \PTbis \longarrow \PTbis
\\
& \deq 
& \fix e.\lambda c. \unfold\, c\ e
\end{array}

&

\begin{array}[t]{l !{~}l!{~} l}
  \bm{\Over}
& :
& \Rou \PTbis
\\
& \deq
& \fix c. \fold(\lambda k. k\ c)
\end{array}

\end{array}

\\\\

\begin{array}{r !{~}l!{~} l}
  \bm{\bft}
& \deq
& \begin{array}{l !{~}c!{~} l}
    \lambda t.~ \extract (\bftaux\ t\ \Over)
  & :
  & \Tree \PTbis
    \longarrow
    \Stream \PTbis
  \end{array}
\\[0.5em]

  \bm{\bftaux}
& :
& \Tree\PTbis
  \longarrow
  \Rou (\Stream\PTbis)
  \longarrow
  \Rou (\Stream\PTbis)
\\

& \deq
& \fix g.\lambda t.\lambda c.
  \fold \left(
    \lambda k.~
    (\lbl t) \Colon
    \left( \unfold\, c \ \big( k \comp (g (\lft t)) \comp (g (\rght t)) \big) \right)
  \right)

\end{array}

\\\bottomrule

\end{array}
\]
\caption{Functions on Streams and Trees.\label{tab:ex}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:pure:fun}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Table~\ref{tab:ex} defines some functions on streams and trees.

On streams, besides the usual $\map$ function,
we consider the $\filter$ function from \S\ref{sec:intro}.
This assumes that $\Base$ contains a set $\Bool = \{\term{tt},\term{ff} \}$
of \emph{Booleans}.
The notation
$\term{if}~ M ~\term{then}~ N_{\term{tt}} ~\term{else}~ N_{\term{ff}}$
stands for the term
$\cse\ M\ \copair{a \mapsto N_a \mid a \in \Bool}$.
Finally, the function $\diag$ computes the diagonal of a stream of streams.
We refer to~\cite[Example 8.3]{jr21esop} for explanations.
Just note that
$\comp$ denotes composition of functions,
so that $M \comp N$ stands for $\lambda x. M(N\, x)$.

On trees, the function $\bft$ implements Martin Hofmann's breadth-first traversal
(see e.g.~\cite{bms19types,jr21esop}).
It uses the recursive type
$\Rou\PTbis \deq \rec\TV.\, (\TV \arrow \PTbis) \arrow \PTbis$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FULL
\begin{full}
\begin{remark*} %[Fixpoints]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
We assumed a term former $\fix x.M$ for term-level fixpoints,
but it is well known that $\fix$ is definable in presence of recursive types
(cf.\ e.g.\ \cite[\S 20.1]{pierce02book}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{remark*}
\end{full}
% FULL
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Negation-Free Infinitary Modal Logics}
\label{sec:log}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t!]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{c}

\dfrac{\varphi \in \Lang(\PT_1)}
  {\form{\pi_1} \in \Lang(\PT_1 \times \PT_2)}

\qquad\qquad

\dfrac{\varphi \in \Lang(\PT_2)}
  {\form{\pi_2} \in \Lang(\PT_1 \times \PT_2)}

\qquad\qquad

\dfrac{\psi \in \Lang(\PTbis)
  \qquad
  \varphi \in \Lang(\PT)}
  {\psi \realto \varphi \in \Lang(\PTbis \arrow \PT)}

\\\\

\dfrac{\varphi \in \Lang(\PT[\rec \TV.\PT/\TV])}
  {\form\fold \varphi \in \Lang(\rec \TV.\PT)}

\qquad\qquad

\dfrac
  {\text{$\BT \in \Base$ and $a \in \BT$}}
  {\form a \in \Lang(\BT)}

\end{array}
\]
\caption{Modalities.%
\label{fig:modal}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\noindent
We consider negation-free infinitary formulae with modalities
as in~\cite{abramsky91apal,bk03ic,jr21esop}.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[Formulae]
\label{def:form}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\PT$ be a pure type.

The formulae $\varphi \in \Lang(\PT)$
are formed using the modalities in Figure~\ref{fig:modal}
together with arbitrary set-indexed %(resp.\ finite)
conjunctions $\bigwedge_{i \in I} \varphi_i$ and
disjunctions $\bigvee_{i \in I} \varphi_i$.
We write $\True$ (resp.\ $\False$) for the empty conjunction (resp.\ disjunction).

We let $\Lang_\land(\PT)$
consist of those $\varphi \in \Lang(\PT)$
in which all conjunctions are finite and all disjunctions are empty
($\False$ is the only disjunction allowed in $\Lang_\land(\PT)$).

The formulae $\varphi \in \Lang_\Open(\PT)$
are formed from formulae in $\Lang_\land(\PT)$
using arbitrary disjunctions and finite conjunctions.

The \emph{normal forms} $\varphi \in \Norm(\PT)$
are the $\varphi = \bigwedge_{i \in I} \bigvee_{j \in J_i}\psi_{i,j}$
with $\psi_{i,j} \in \Lang_\land(\PT)$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\noindent
Note that $\Lang(\PT)$ and $\Lang_{\Open}(\PT)$ are proper classes,
while $\Lang_{\land}(\PT)$ and $\Norm(\PT)$ are sets.


The semantics of formulae is defined in~\S\ref{sec:sem:log}.
%The intented meaning of the modalities in Figure~\ref{fig:modal} is as follows.
Their intended meaning is as follows.
The formula $\psi \realto \varphi \in \Lang(\PTbis \arrow \PT)$
is intended to select those $M : \PTbis \arrow \PT$
such that $\varphi$ holds on $M N : \PT$ whenever $\psi$ holds on $N : \PTbis$.
%
Similarly, $\form\fold \varphi$ holds on $M$ whenever
$\varphi$ holds on $\unfold M$.
%
%
For $i = 1,2$,
the formula $\form{\pi_i} \varphi$
selects those $M : \PT_1 \times \PT_2$
such that $\varphi$ holds on $\pi_i M$.
%
With
$\pair{\varphi_1,\varphi_2} \deq \form{\pi_1}\varphi_1 \land \form{\pi_2} \varphi_2$,
we have a formula which holds on those $M$ such that
$\varphi_i$ holds on $\pi_i M$ for $i = 1,2$.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:form:base}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Given $\BT \in \Base$ and $a \in \BT$,
the formula $\form a$ is intended to hold
on $a$ but not on the $b \in \BT \setminus \{a\}$.
For instance, given $\SP \sle \BT$, the formula
$\bigwedge_{a \in \SP}(\form a \realto \form{\term{tt}})$
is intended to select the $p : \BT \arrow \Bool$
such that $(p\, a)$ is $\term{tt}$ for all $a \in \SP$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:form:stream}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
On streams $\Stream\PTbis$, the composite modalities $\form\hd$ and $\form\tl$
are defined as $\form\hd \psi \deq \form\fold \form{\pi_1} \psi$
and $\form\tl \varphi \deq \form\fold \form{\pi_2} \varphi$.
Given $\psi \in \Lang(\PTbis)$ and $\varphi \in \Lang(\Stream\PTbis)$,
the formulae $\form\hd\psi \in \Lang(\Stream\PTbis)$
and $\form\tl\varphi \in \Lang(\Stream\PTbis)$
select those streams $M$ such that $\psi$ holds on $(\hd M)$
and such that $\varphi$ holds on $(\tl M)$, respectively.
In the following, we write $\Next\varphi$ for $\form\tl\varphi$.

Using $\NN$-indexed connectives,
we can define
the usual $\LTL$ modalities $\Box$ and $\Diam$ as 
$\Box \varphi \deq \bigwedge_{n \in \NN} \bigwedge_{0\leq k \leq n} \Next^k \varphi$
and
$\Diam \varphi \deq \bigvee_{n \in \NN} \bigvee_{0\leq k \leq n} \Next^k \varphi$.
Hence, $\Box \varphi$ (resp.\ $\Diam \varphi$)
is intended to hold on those $M : \Stream\PTbis$
such that $\varphi$ holds on $\tl^n M$ for all $n \in \NN$
(resp.\ for some $n \in \NN$).
In particular, $\Box\Diam \form\hd \psi$ (resp.\ $\Diam\Box\form\hd\psi$)
selects those streams with infinitely many (resp.\ ultimately all) elements
satisfying $\psi$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:form:tree}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Similarly, on trees $\Tree\PTbis$ 
one can define composite modalities $\form\lbl$, $\form\lft$ and $\form\rght$
such that
$\form\lbl\psi, \form\lft\varphi, \form\rght\varphi \in \Lang(\Tree\PTbis)$
whenever $\psi \in \Lang(\PTbis)$ and $\varphi \in \Lang(\Tree\PTbis)$.

Moreover, the $\LTL$ stream modalities $\Box,\Diam$ have their 
usual $\CTL$ counterparts 
$\forall\Box$, $\exists\Box$,
$\forall\Diam$ and $\exists\Diam$.
Namely, given $\varphi \in \Lang(\Tree\PTbis)$,
\[
\begin{array}{r l l !{\qquad\quad} r l l}
  \forall \Box \varphi
& \deq
& \bigwedge_{n \in \NN} 
  (\varphi \land \Land(\pl))^n(\True)

& \forall\Diam \varphi
& \deq
& \bigvee_{n \in \NN} 
  (\varphi \lor \Land(\pl))^n(\False)
\\

  \exists \Box \varphi
& \deq
& \bigwedge_{n \in \NN} 
  (\varphi \land \Lor(\pl))^n(\True)

& \exists\Diam \varphi
& \deq
& \bigvee_{n \in \NN} 
  (\varphi \lor \Lor(\pl))^n(\False)
\end{array}
\]


\noindent
where
$\Land\theta \deq \form\lft \theta \land \form\rght \theta$
and
$\Lor\theta \deq \form\lft \theta \lor \form\rght \theta$.

The intended meaning of $\forall\Box \form\lbl\psi$ is to select
those trees whose node labels all satisfy $\psi$,
while $\exists\Box \form\lbl\psi$ asks $\psi$ to hold on all
labels in some infinite path.
The formula $\exists\Diam \form\lbl\psi$
holds if there is a node whose label satisfies $\psi$,
and $\forall\Diam \form\lbl\psi$ requires that every infinite path
has a node label on which $\psi$ holds.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Examples~\ref{ex:form:stream} and~\ref{ex:form:tree}
are generalized in Example~\ref{ex:sem:modalmu} (\S\ref{sec:sem:reft})
to (negation-free) least and greatest fixpoints 
in the style of the modal $\mu$-calculus
(see e.g. \cite{bs07chapter,bw18chapter}).



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t!]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{c}

\dfrac{\psi \thesis \theta
  \quad
  \theta \thesis \varphi}
  {\psi \thesis \varphi}

\quad

\dfrac{a \neq b}
  {\form a \land \form b \thesis_{\BT} \False}

\quad

\ax{D}
\dfrac{}
  {\bigwedge_{i \in I}\bigvee_{j \in J_i} \varphi_{i,j}
  \,\thesis\,
  \bigvee_{f \in \prod_{i \in I} J_i}\bigwedge_{i \in I} \varphi_{i,f(i)}}

\\\\

\dfrac{}
  {\varphi \thesis \varphi}

\quad

\dfrac{\text{for each $i \in I$, $\psi \thesis \varphi_i$}}
  {\psi \thesis \bigwedge_{i \in I} \varphi_i}

\quad

\dfrac{\psi_i \thesis \varphi}
  {\bigwedge_{i \in I} \psi_i \thesis \varphi}
~(i \in I)

\quad

\dfrac{}
  {\bigwedge_{i \in I} \form\triangle \varphi_i
  \thesis
  \form\triangle \bigwedge_{i \in I} \varphi_i}

\\\\

\dfrac{\psi \thesis \varphi_i}
  {\psi \thesis \bigvee_{i \in I} \varphi_i}
~(i \in I)

\qquad\qquad

\dfrac{\text{for each $i \in I$, $\psi_i \thesis \varphi$}}
  {\bigvee_{i \in I}\psi_i \thesis \varphi}

\qquad\qquad

\dfrac{}
  {\form\triangle \bigvee_{i \in I}\varphi_i
  \thesis
  \bigvee_{i \in I} \form\triangle\varphi_i}

\\\\

\ax{F}
\dfrac{\psi \in \Lang_\land(\PTbis)
  \quad~~
  \varphi_i \in \Lang(\PT)
  \quad~~
  I \neq \emptyset}
  {\psi \realto \left( \bigvee_{i \in I}\varphi_i \right)
  \,\thesis\,
  \bigvee_{i \in I} \left( \psi \realto \varphi_i \right) }

\qquad

\dfrac{\psi' \thesis_{\PTbis} \psi
  \qquad
  \varphi \thesis_{\PT} \varphi'}
  {\psi \realto \varphi \,\thesis_{\PTbis \arrow \PT}\, \psi' \realto \varphi'}

\qquad

\dfrac{\psi \thesis \varphi}
  {\form\triangle \psi \thesis \form\triangle \varphi}

\\\\

\dfrac{}
  {\bigwedge_{i \in I}\left(\psi \realto \varphi_i \right)
  \,\thesis\,
  \psi \realto \left(\bigwedge_{i \in I} \varphi_i\right)}

\qquad\qquad

\dfrac{}
  {\bigwedge_{i \in I}\left( \psi_i \realto \varphi \right)
  \,\thesis\,
  \left(\bigvee_{i \in I} \psi_i \right) \realto \varphi}

\end{array}
\]
\caption{Basic deduction rules, where $\triangle$ is either $\pi_1$, $\pi_2$ or $\fold$.%
\label{fig:log:ded}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{definition}[Deduction]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
A \emph{sequent} has the form $\psi \thesis_{\PT} \varphi$
where $\varphi,\psi \in \Lang(\PT)$.
We often write $\psi \thesis \varphi$ for $\psi \thesis_{\PT} \varphi$.
%
\emph{Basic deduction} is defined by the rules in
Fig.~\ref{fig:log:ded}.

We write $\psi \thesisiff \varphi$ when the sequents
$\psi \thesis \varphi$ and $\varphi \thesis \psi$
are both derivable.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{definition}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Note that $\varphi \thesis \True$ and $\False \thesis \varphi$
by definition of $\True$ and $\False$.
%
One can derive that $\thesis$ preserves conjunctions
and disjunctions:
if $\psi_i \thesis \varphi_i$ for all $i \in I$,
then
$\bigwedge_{i \in I} \psi_i \thesis \bigwedge_{i \in I} \varphi_i$
and
$\bigvee_{i \in I} \psi_i \thesis \bigvee_{i \in I} \varphi_i$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:log:modalnf}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Let $\triangle$ be either $\pi_1,\pi_2$ or $\fold$.
The modality $\form\triangle$ commutes over conjunctions and disjunctions
($\bigwedge_i \form\triangle \varphi_i \thesisiff \form\triangle\bigwedge_i \varphi_i$,
and similarly for $\bigvee$).
In particular, for each normal form $\varphi$
there is a normal form $\psi$ such that $\form\triangle \varphi \thesisiff \psi$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:log:distr}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
As usual, the converse of $\ax{D}$ is derivable, and so is the dual
law
\(
  \bigwedge_{f \in \prod_{i \in I}J_i}\bigvee_{i \in I} \varphi_{i,f(i)}
  \,\thesisiff\,
  \bigvee_{i \in I}\bigwedge_{j \in J_i}\varphi_{i,j}
\)
(see e.g. \cite[Lemma VII.1.10]{johnstone82book}).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{remark}
\label{rem:log:realto}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Taking $I = \emptyset$ in the last two rules of Fig.~\ref{fig:log:ded}
yields $\True \thesis \left(\psi \realto \True \right)$
and $\True \thesis \left(\False \realto \varphi \right)$.
%Hence rule $\ax{F}$ would be unsound with $I = \emptyset$ and $\psi = \False$.
The rule $\ax{F}$ would thus be unsound with $I = \emptyset$ and $\psi = \False$.
Rule $\ax{F}$ differs from usual systems for DTLF
(cf.\ \cite[\S 4.2]{abramsky91apal} \cite[Figure 5]{bk03ic}
and \cite[Figure 10.3]{ac98book}).
The case of $I = \emptyset$
will be handled by rule $\ax{C}$ in \eqref{eq:compl:cc}, \S\ref{sec:compl:fin}.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{remark}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Refinement Types}
\label{sec:reft}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\noindent
\emph{Refinement types} (or \emph{types}), notation $\RT,\RTbis,\dots$,
are given by the grammar
\begin{equation*}
\begin{array}{r @{\ \ }c@{\ \ } l}
    \RT
&   \bnf
&   \PT
\gs \reft{\PT \mid \varphi}
\gs \RT \times \RT
\gs \RT \arrow \RT
\end{array}
\end{equation*}

\noindent
where $\PT$ is a pure type and $\varphi \in \Lang(\PT)$.
%
We shall consider typing judgments of the form
$\Env \thesis M : \RT$,
where $\Env$ is allowed to mention refinement types.
A judgment
$M : \reft{\PT \mid \varphi}$
is intended to mean that $M$ is of pure type $\PT$ and satisfies $\varphi$.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:reft:base}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Given a base type $\BT \in \Base$ and $\SP \sle \BT$,
a judgment of the form
\(
  p :
  \reft{\BT \arrow \Bool
  \mid
  \bigwedge_{a \in \SP}\left(\form a \realto \form{\term{tt}} \right)}
\)
expresses that 
$(p\, a)$ yields $\term{tt}$ for all $a \in \SP$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{table}[t!]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\scalebox{0.9}{\(
\begin{array}{c}
\toprule

\multicolumn{1}{l}{\text{\textbf{Map on streams}
(with $\triangle$ either $\Box$, $\Diam$, $\Diam\Box$ or $\Box\Diam$)}}
\\
\begin{array}{*{7}{l}}
  \map
& :
& \reft{\PT \arrow \PTbis \mid \psi \realto \varphi}
  %(\reft{\PT \mid \psi} \arrow \reft{\PTbis \mid \varphi})
& \longarrow
& \reft{\Stream \PT \mid \triangle \form{\hd}\psi}
& \longarrow
& \reft{\Stream \PTbis \mid \triangle \form{\hd}\varphi}
\end{array}

\\\midrule

\multicolumn{1}{l}{\text{\textbf{Filter on streams}
(with $\triangle$ either $\Box$ or $\Box\Diam$)}}
\\
\begin{array}{*{7}{l}}
  \filter
& :
& \reft{\BT \arrow \Bool \mid \bigwedge_{a \in \SP}(\form a \realto \form{\term{tt}})}
& \longarrow
& \reft{\Stream \PTbis \mid \triangle \form{\hd}\bigvee_{a \in \SP}\form a}
& \longarrow
& \reft{\Stream \PTbis \mid \Box \form{\hd}\bigvee_{a \in \SP}\form a}
\end{array}

\\\midrule

\multicolumn{1}{l}{\text{\textbf{Diagonal of streams of streams}
(with $\triangle$ either $\Box$ or $\Diam\Box$)}}
\\
\begin{array}{l l l l l}
  \diag
& :
& \reft{\Stream (\Stream \PTbis) \mid \triangle \form\hd \Box \form{\hd}\varphi}
& \longto 
& \reft{\Stream \PTbis \mid \triangle \form{\hd}\varphi}
\\
\end{array}

\\\midrule


\multicolumn{1}{l}{\text{\textbf{Breadth-first tree traversal}
(see Example~\ref{ex:reft:fun} for $\triangle$ and $\overline\triangle$)}}
\\

\begin{array}{l l r c l}
  \bft
& :
& \reft{\Tree\PTbis \mid \triangle \form\lbl \varphi}
& \longto
& \reft{\Stream\PTbis \mid \overline\triangle \form\hd \varphi}
\end{array}

\\\bottomrule

\end{array}\)}
\end{center}
\caption{Some judgments with refinement types
(functions defined in Table~\ref{tab:ex}).%
\label{tab:reft}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{table}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
\label{ex:reft:fun}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
Table~\ref{tab:reft} presents some specifications,
expressed as refinement types, for functions defined in Table~\ref{tab:ex}
(see Example~\ref{ex:pure:fun}).

For the $\map$ function,
assuming $f : \reft{\PTbis \arrow \PT \mid \psi \realto \varphi}$,
if $\triangle$ is $\Box$ (resp.\ $\Diam, \Box\Diam, \Diam\Box$),
then the judgment expresses
that $(\map f)$
takes a stream with all (resp.\ some, infinitely many, ultimately all)
elements satisfying $\psi$ to a stream with all
(resp.\ some, infinitely many, ultimately all)
elements satisfying~$\varphi$.

The specifications for $\filter$ are the expected ones.
Let $p : \BT \to \Bool$ such that
$(p\, a)$ yields $\term{tt}$ for all $a \in \SP$.
If $\triangle$ is $\Box$ (resp.\ $\Box\Diam$).
then the judgment means that
$(\filter p)$ takes a stream with all (resp.\@ infinitely many) elements in $\SP$
to a stream with all elements in $\SP$.
Recalling that the stream formula $\Box \form\hd \form a$ amounts to
$\bigwedge_{n \in \NN} \Next^n \form\hd \form a$,
note that none of the formulae $\Next^n \form\hd \form a$ hold on
$\Omega_{\Stream\BT} : \Stream\BT$.

Concerning the diagonal,
%As for the diagonal function,
if $\triangle$ is $\Box$ (resp.\ $\Diam\Box$),
then
the judgment
expresses that $\diag$ takes a stream whose component streams
all (resp.\@ ultimately all) satisfy $\Box \form\hd \varphi$
to a stream whose elements all (resp.\ ultimately all)
satisfy $\varphi$.

For the tree traversal $\bft$ we can allow for any sound
combination of $\triangle$ and $\overline\triangle$.
This includes all pairs $(\triangle,\overline\triangle)$
among
$(\forall \Box, \Box)$,
$(\exists \Box, \Box\Diam)$,
$(\exists \Diam, \Diam)$,
$(\forall \Diam, \Diam)$
and
$(\forall \Box \exists \Diam, \Box\Diam)$.
For instance,
if $\triangle$ is $\forall\Box$
(resp.\ $\exists\Diam, \forall\Box\exists\Diam$),
then
the judgment says that $\bft$
takes a tree with all (resp.\ some, infinitely many) node
labels satisfying $\varphi$ to a stream with all (resp.\ some, infinitely may)
elements satisfying~$\varphi$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t!]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\[
\begin{array}{c}

\dfrac{}
  {\RT \subtype \UPT\RT}

\qquad

\dfrac{}
  {\PT \subtype \reft{\PT \mid \True}}

\qquad

\dfrac{\psi \thesis_{\PT} \varphi}
  {\reft{\PT \mid \psi} \subtype \reft{\PT \mid \varphi}}

\qquad

\dfrac{\RT \subtype \RTbis
  \qquad
  \RTbis \subtype \RTter}
  {\RT \subtype \RTter}

\\\\

\dfrac{\RT \subtype \RT'
  \qquad
  \RTbis \subtype \RTbis'}
  {\RT \times \RTbis \subtype \RT' \times \RTbis'}

\qquad

\dfrac{}{
  \reft{\PT \mid \varphi}
  \times
  \reft{\PTbis \mid \psi}
  \eqtype
  \reft{\PT \times \PTbis \mid \pair{\varphi,\psi}}}

\qquad

\dfrac{}
  {\RT \subtype \RT}

\\\\

\dfrac{\RTbis' \subtype \RTbis
  \qquad
  \RT \subtype \RT'}
  {\RTbis \arrow \RT \subtype \RTbis' \arrow \RT'}


\qquad

\dfrac{}
  {\reft{\PTbis \mid \psi} \arrow \reft{\PT \mid \varphi}
  \eqtype
  \reft{\PTbis \arrow \PT \mid \psi \realto \varphi}}

\end{array}
\]

\caption{Subtyping.%
\label{fig:reft:subtyping}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{figure}[t!]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{center}
\scalebox{0.89}{\(
\begin{array}{c}
\dfrac{
  \begin{array}{l}
  \UPT\Env \thesis M : \PT
  \\
  \text{for each $i \in I$,}\quad \Env \thesis M : \reft{\PT \mid \varphi_i}
  \end{array}}
  {\Env \thesis M : \reft{\PT \mid \bigwedge_{i \in I} \varphi_i}}

\qquad\quad

\dfrac{
  \begin{array}{l}
  \UPT\Env, x:\PTbis, \UPT{\Env'} \thesis M : \UPT\RT
  \\
  \text{for each $i \in I$,}\quad
  \Env, x:\reft{\PTbis \mid \psi_i},\Env' \thesis M : \RT
  \end{array}}
  {\Env, x : \reft{\PTbis \mid \bigvee_{i \in I} \psi_i} , \Env' \thesis M : \RT}

\\\\


\dfrac{
  \Env' \subtype \Env
  \quad 
  \RT \subtype \RT'
  \quad
  \Env \thesis M : \RT}
  {\Env' \thesis M : \RT'}

\qquad

\dfrac{\Env \thesis \fix x.M : \reft{\PT \mid \psi}
  \quad
  \Env, x: \reft{\PT \mid \psi} \thesis M : \reft{\PT \mid \varphi}}
  {\Env \thesis \fix x.M : \reft{\PT \mid \varphi}}
%~\text{\scalebox{0.875}{$(\varphi,\psi \in \Lang_\land)$}}
~(\varphi,\psi \in \Lang_\land)

\\\\

\dfrac{\Env \thesis M : \reft{\PT_1 \times \PT_2 \mid \form{\pi_i} \varphi}}
  {\Env \thesis \pi_i(M) : \reft{\PT_i \mid \varphi}}
~(i=1,2)

\qquad\quad

\dfrac{\Env \thesis M_i : \reft{\PT_i \mid \varphi}
  \qquad
  \Env \thesis M_{3-i} : \PT_{3-i}}
  {\Env \thesis \pair{M_1,M_2} : \reft{\PT_1 \times \PT_2 \mid \form{\pi_i} \varphi}}
~(i=1,2)
\\\\


\dfrac{}
  {\Env \thesis a : \reft{\BT \mid \form a}}

\qquad\quad


\dfrac{
  \Env \thesis M : \reft{\BT \mid \form b}
  \qquad
  \Env \thesis N_b : \RT
  \qquad
  \text{for each $a \in A$,\quad} \UPT\Env \thesis N_a : \UPT\RT}
  {\Env \thesis \cse\ M\ \copair{a \mapsto N_a \mid a \in \BT} : \RT}


\\\\


\dfrac{\Env \thesis M : \reft{\PT[\rec\TV.\PT/\TV] \mid \varphi}}
  {\Env \thesis \fold(M) : \reft{\rec\TV.\PT \mid \form\fold \varphi}}

\qquad\quad

\dfrac{\Env \thesis M : \reft{\rec\TV.\PT \mid \form\fold \varphi}}
  {\Env \thesis \unfold(M) : \reft{\PT[\rec\TV.\PT/\TV] \mid \varphi}}

\end{array}\)}
\end{center}
\caption{Typing with refinement types.%
\label{fig:reft:reftyping}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Each refinement type $\RT$ has an \emph{underlying pure type} $\UPT\RT$
defined by induction from $\UPT\PT \deq \PT$
and $\UPT{\reft{\PT \mid \varphi}} \deq \PT$.
We write $\UPT\Env$ for the extension of $\UPT{\pl}$ to $\Env$.

We derive typing judgments $\Env \thesis M : \RT$
using the rules in Figure~\ref{fig:reft:reftyping}
augmented with \emph{all} the typing rules of the pure system (\S\ref{sec:pure})
extended to refinement types.
Deduction on formulae (\S\ref{sec:log})
enters the type system via a subtyping relation $\RTbis \subtype \RT$.
Subtyping rules are presented in Figure~\ref{fig:reft:subtyping},
where $\RTbis \eqtype \RT$
stands for the conjunction of $\RTbis \subtype \RT$ and $\RT \subtype \RTbis$.
Subtyping is extended to typing contexts:
given $\Env = x_1:\RTbis_1,\dots,x_n:\RTbis_n$
and $\Env' = x_1:\RTbis'_1,\dots,x_n:\RTbis'_n$,
we let $\Env \subtype \Env'$ when $\RTbis_i \subtype \RTbis'_i$
for all $i =1,\dots,n$.
Note that if $\Env \thesis M :\RT$ is derivable
then so is $\UPT\Env \thesis M : \UPT\RT$.

The rules in Figures~\ref{fig:reft:reftyping} and~\ref{fig:reft:subtyping}
are direct adaptations of those in~\cite{abramsky91apal,bk03ic,jr21esop}.
In particular, the rule for $\fix$
(in which $\varphi,\psi \in \Lang_\land(\PT)$)
comes from~\cite{abramsky91apal}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
The following rules are derived using the 
last rule in Figure~\ref{fig:reft:subtyping}.
\[
\begin{array}{c}
\dfrac{\Env,x : \reft{\PTbis \mid \psi} \thesis M : \reft{\PT \mid \varphi}}
  {\Env \thesis \lambda x.M : \reft{\PTbis \arrow \PT \mid \psi \realto \varphi}}

\quad

\dfrac{\Env \thesis M : \reft{\PTbis \arrow \PT \mid \psi \realto \varphi}
  \quad
  \Env \thesis N : \reft{\PTbis \mid \psi}}
  {\Env \thesis M N : \reft{\PT \mid \varphi}}
\end{array}
\]
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{example}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{lemma}
\label{lem:reft}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
For each type $\RT$, there is $\varphi \in \Lang(\UPT\RT)$
such that $\RT \eqtype \reft{\UPT\RT \mid \varphi}$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{lemma}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


Our goal is to devise extensions of this type system which
are sound and complete w.r.t.\ the usual Scott semantics,
the sense that given $\thesis M : \PT$,
\[
\begin{array}{c !{\quad}c!{\quad} c}
  \thesis M : \reft{\PT \mid \varphi}
& \text{if, and only if,}
& \text{$\varphi$ holds on $\I M$ in the Scott semantics.}
\end{array}
\]

\noindent
The Scott semantics is recalled in~\S\ref{sec:sem},
while \S\ref{sec:compl} discusses completeness.
In particular, all 
typing judgments in Table~\ref{tab:reft} (Example~\ref{ex:reft:fun})
will be derivable.





