% Initialize skillState ← IDLE  
% Initialize occupancyState ← EMPTY  
% Initialize lastIntention ← NONE  

% function reactivePlanner(currentInput):  
%     predictedIntent ← intentionModel.predict(currentInput)  
%     if predictedIntent is stable for K steps and predictedIntent ≠ lastIntention:  
%         if skillState is a manipulation skill and interruptionAllowed:  
%             skillState ← reverseOf(skillState)  
%             occupancyState ← updateOccupancyState()  

%         if startConditionFor(predictedIntent) is satisfied by occupancyState:  
%             skillState ← correspondingSkill(predictedIntent)  
%         else:  
%             path ← findPath(occupancyState, startConditionFor(predictedIntent))  
%             skillState ← executePath(path)  

%         lastIntention ← predictedIntent  

%     if currentSkillSucceeded(skillState) or currentSkillFailed(skillState):  
%         skillState ← IDLE  

%     return skillState  

% \begin{algorithm}[t]
%     \caption{Reactive Planner Pseudo-code}
%     \label{alg:reactive_planner}
%     \SetAlgoLined
%     \KwIn{
%       \\
%       \quad $M_t, H_t$: human body and hand posture at time $t$\\
%       \quad $B^i_t$: 3D bounding boxes of objects/hands at time $t$\\
%       \quad $P_t$: human head pose at time $t$\\
%       \quad $\text{IntentionPredictor}(\cdot)$: Transformer-based model for human intention\\
%       \quad $k$: number of consecutive frames required to confirm an intention\\
%       \quad $\mathcal{S}$: set of all possible skills\\
%       \quad $\text{startCondition}(s)$: the hand-occupancy requirement for skill $s$\\
%       \quad $\text{endTransition}(s)$: the change of hand occupancy after $s$ completes\\
%       \quad $\mathcal{G}$: directed graph of hand-occupancy transitions
%     }
%     \KwOut{Next robot action (skill execution)}
    
%     \textbf{Initialize:}\\
%     \quad $\text{currentSkill} \leftarrow \text{idle}$ \\
%     \quad $\text{currentOccupancy} \leftarrow [~]$ \ \tcp{Empty if no object in either hand}
%     \quad $\text{consecutiveCount}[i] \leftarrow 0, \forall i \in \text{AllIntentions}$ \\
%     \quad $\text{pendingSkill} \leftarrow \text{None}$ \\
    
%     \While{robot is running}{
%         \textbf{Step 1: Capture human behavior.}\\
%         \quad Retrieve sensor data $(M_t, H_t, B^i_t, P_t)$ from the RGB-D camera and detection models.\\
        
%         \textbf{Step 2: Predict human intention.}\\
%         \quad $I_t \leftarrow \text{IntentionPredictor}(M_t, H_t, B^i_t, P_t)$\\
%         \quad \ForEach{possible intention $i$}{
%             \uIf{$i = I_t$}{
%                 $\text{consecutiveCount}[i] \leftarrow \text{consecutiveCount}[i] + 1$\\
%             }
%             \Else{
%                 $\text{consecutiveCount}[i] \leftarrow 0$\\
%             }
%         }
        
%         \textbf{Step 3: Confirm intention for skill switching.}\\
%         \quad $I^* \leftarrow \arg\max_{i \in \text{AllIntentions}} \text{consecutiveCount}[i]$\\
%         \quad \If{$\text{consecutiveCount}[I^*] \geq k$}{
%             \textcolor{blue}{\tcp{We have a stable intention $I^*$}}
%             \quad $\text{pendingSkill} \leftarrow \text{mapIntentionToSkill}(I^*)$\;
%         }
        
%         \textbf{Step 4: Check if a skill switch is needed.}\\
%         \quad \uIf{$\text{pendingSkill} \neq \text{None}$}{
%             \quad \textcolor{blue}{\tcp{Interrupt current skill if needed}}
%             \quad \If{$\text{currentSkill} \neq \text{idle}$ \textbf{and} $\text{pendingSkill} \neq \text{currentSkill}$}{
%                 \quad \textcolor{blue}{\tcp{Handle interruption of manipulation skill if active}}
%                 \quad \text{reverseSkill}(\text{currentSkill})\;
%             }
%             \quad \textcolor{blue}{\tcp{Attempt to start the pending skill}}
%             \quad $s \leftarrow \text{pendingSkill}$\;
%             \quad \If(\tcp*[f]{Check start condition}){$\text{startCondition}(s)$ \textbf{is not satisfied by} $\text{currentOccupancy}$}{
%                 \quad \textcolor{blue}{\tcp{Find shortest path in occupancy graph $\mathcal{G}$ to fulfill start condition}}
%                 \quad $path \leftarrow \text{findOccupancyPath}(\mathcal{G}, \text{currentOccupancy}, \text{startCondition}(s))$\;
%                 \quad \ForEach{skill $p$ \textbf{in} $path$}{
%                     \quad Execute $p$ to modify $\text{currentOccupancy}$\;
%                 }
%             }
%             \quad \textcolor{blue}{\tcp{Now that occupancy requirements are met, start skill $s$}}
%             \quad $\text{currentSkill} \leftarrow s$\;
%             \quad $\text{pendingSkill} \leftarrow \text{None}$\;
%         }
        
%         \textbf{Step 5: Execute the current skill.}\\
%         \quad \uIf(\tcp*[f]{For manipulation skill}){$\text{currentSkill}$ \text{is manipulation}}{
%             \quad \If{\text{skill succeeds}}{
%                 \quad $\text{endTransition}(\text{currentSkill}) \rightarrow \text{currentOccupancy}$\;
%                 \quad $\text{currentSkill} \leftarrow \text{idle}$\;
%             }
%             \quad \ElseIf{\text{skill fails or times out}}{
%                 \quad \text{handleFailure}(\text{currentSkill})\;
%                 \quad $\text{currentSkill} \leftarrow \text{idle}$\;
%             }
%         }
%         \quad \ElseIf(\tcp*[f]{For motion skill}){$\text{currentSkill}$ \text{is motion}}{
%             \quad \If(\tcp*[f]{Stop if new intention or canceled}){a new stable intention emerges}{
%                 \quad $\text{currentSkill} \leftarrow \text{idle}$\;
%             }
%             \quad \Else{
%                 \quad Continue motion skill execution\;
%             }
%         }
%         \quad \Else{
%             \quad \textcolor{blue}{\tcp{Idle state: do nothing unless new skill arrives}}
%             \quad \text{currentSkill} \leftarrow \text{idle}\;
%         }
        
%         \textbf{Step 6: Repeat at 30Hz.}\\
%         \quad \textcolor{blue}{\tcp{Proceed to the next time step}}
%     }
%     \end{algorithm}
    
    % \begin{algorithm}[t]
    %     \caption{Reactive Planner Simplified Pseudo-code}
    %     \label{alg:reactive_planner_simplified}
    %     \SetAlgoLined
    %     \KwIn{
    %       \quad $M_t, H_t$: human body and hand posture at time $t$ \\
    %       \quad $B^i_t$: 3D bounding boxes of objects/hands at time $t$ \\
    %       \quad $P_t$: human head pose at time $t$ \\
    %       \quad $\mathcal{S}$: set of skills \\
    %       \quad $k$: number of frames for stable intention
    %     }
    %     \KwOut{Next robot action (skill execution)}
        
    %     \textbf{Initialize:} \\
    %     \quad $\text{currentSkill} \leftarrow \text{idle}$, $\text{currentOccupancy} \leftarrow [~]$ \\
    %     \quad $\text{pendingSkill} \leftarrow \text{None}$, $\text{consecutiveCount}[i] \leftarrow 0, \forall i$ \\
    %     \While{robot is running}{
    %         \textbf{Capture data:} \\
    %         \quad Retrieve $(M_t, H_t, B^i_t, P_t)$ from sensors.\\
            
    %         \textbf{Predict intention:} \\
    %         \quad $I_t \leftarrow \text{IntentionPredictor}(M_t, H_t, B^i_t, P_t)$. \\
    %         \quad \ForEach{intention $i$}{
    %             \quad $\text{consecutiveCount}[i] \leftarrow \text{consecutiveCount}[i] + 1$ if $i = I_t$ else 0.\\
    %         }
            
    %         \textbf{Confirm intention:} \\
    %         \quad $I^* \leftarrow \arg\max \text{consecutiveCount}[i]$ \\
    %         \quad \If{$\text{consecutiveCount}[I^*] \geq k$}{
    %             \quad $\text{pendingSkill} \leftarrow \text{mapIntentionToSkill}(I^*)$. \\
    %         }
            
    %         \textbf{Skill switch:} \\
    %         \quad \If{$\text{pendingSkill} \neq \text{None}$}{
    %             \quad \If{$\text{currentSkill} \neq \text{idle}$ \textbf{and} $\text{pendingSkill} \neq \text{currentSkill}$}{
    %                 \quad $\text{reverseSkill}(\text{currentSkill})$. \\
    %             }
    %             \quad \If{$\text{startCondition}(\text{pendingSkill})$ is met by $\text{currentOccupancy}$}{
    %                 \quad $\text{currentSkill} \leftarrow \text{pendingSkill}$. \\
    %                 \quad $\text{pendingSkill} \leftarrow \text{None}$. \\
    %             }
    %             \quad \Else{
    %                 \quad \text{Find and execute preparatory skills using the occupancy transition graph}. \\
    %             }
    %         }
            
    %         \textbf{Execute skill:} \\
    %         \quad \If{$\text{currentSkill}$ is manipulation}{
    %             \quad \If{skill succeeds}{ 
    %                 \quad $\text{endTransition}(\text{currentSkill})$. \\
    %                 \quad $\text{currentSkill} \leftarrow \text{idle}$. \\
    %             }
    %             \quad \ElseIf{skill fails or times out}{
    %                 \quad \text{handle failure}. \\
    %                 \quad $\text{currentSkill} \leftarrow \text{idle}$. \\
    %             }
    %         }
    %         \quad \ElseIf{$\text{currentSkill}$ is motion}{
    %             \quad \If{new intention emerges}{
    %                 \quad $\text{currentSkill} \leftarrow \text{idle}$. \\
    %             }
    %         }
    %         \quad \Else{
    %             \quad \text{Stay idle until next skill request}. \\
    %         }
    %     }
    %     \end{algorithm}

\begin{algorithm}
\caption{Pseudo-code for Skill Transitions of Reactive Planner.}
\begin{algorithmic}[1]
\label{alg:planner}
\STATE $Skill \gets \text{Idle}$
\WHILE{$true$}
    \STATE $human\_intention \gets \text{Recognize\_Human\_Intention()}$
    \IF{human intention is stable for $k$ frames and human intention != current intention}
        \IF{human intention $=$ Idle and Skill $=$ Manipulation}
            % continue the loop
            \STATE Continue
        \ENDIF
        \IF{Skill $=$ Manipulation and interruptionAllowed}
            \STATE $Skill \gets \text{Reverse\_Skill}(Skill)$
        \ENDIF
        \IF{$\text{Start\_Condition}(human\_intention)$ is not satisfied by hand occupancy}
             \STATE $path \gets$  FindPath(occupancy, StartCondition $(human\_intention))$
            % \STATE $\begin{aligned}
            %     path \gets & \text{FindPath}(\text{occupancy}, \\
            %     & \text{StartCondition}(human\_intention))
            % \end{aligned}$
            \STATE $Skill \gets \text{Execute\_Path}(path)$
        \ELSE
            \STATE $Skill \gets \text{Corresponding Skill} (human\_intention)$
        \ENDIF
    \ELSIF{SkillSucceeded(Skill) or SkillTimeout(Skill)}
        \STATE $Skill \gets \text{Idle}$
        \IF{SkillSucceeded(Skill)}
            \STATE $\text{Hand Occupancy} \gets \text{End\_Transition}(Skill)$
        \ENDIF
    \ENDIF
\ENDWHILE
\end{algorithmic}
\end{algorithm}