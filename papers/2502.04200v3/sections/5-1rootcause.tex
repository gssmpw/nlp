\subsection{RQ1:Root Causes}
Understanding root causes is vital as it lays the groundwork for developing a more robust login process in Android apps.
% The classification of root causes of login issues revealed several critical areas where improvements are necessary.
Through a meticulous process of open coding, our study categorized these root causes into five groups, each characterized by distinct patterns and contributing factors. Table~\ref{tab:root-causes} shows an overview of all the categories.
\begin{table}
  \centering
  \caption{Summary of Root Causes and Issue Counts \lili{Update the table with the new names of each category}\zixu{Done}}
  \label{tab:root-causes}
   \begin{tabular}{@{}c l r@{}}
    \toprule
    \textbf{No.} & \textbf{Root Causes }& \multicolumn{1}{c}{\textbf{\#Issues}} \\
    \midrule
    %\rowcolor[HTML]{EFEFEF} 
    1 & Login Flow Error & 214 \\ % Parent category
     & 1.1 Improper Error State Handling & 57  \\ 
     & 1.2 Interference with Other State Machines & 57   \\
     & 1.3 Missing Login Flow & 52 \\
     & 1.4 Incorrect Login Flow & 48  \\
    2 & API Misuse & 63  \\
    3 & Null Object Check Omission & 39 \\
    4 & Improper Encoding Algorithm & 23 \\
    5 & Wrong Environment Dependency & 22 \\
    \bottomrule
  \end{tabular}\\
\end{table}


\subsubsection{Login Flow Errors}
\begin{figure*}[ht!]
  \centering
  \includegraphics[width=0.9\linewidth]{figures/HighLevelModified.drawio.pdf}
  \caption{State Machine for Login Process}
  \label{fig:statemachine}
\end{figure*}
The login processes in Android apps typically require a dedicated sequence of operations (the login flow) involving the apps, the users, and some backend services. These operations can include user inputs, authentication, or error handling. For example, checking for the presence of a valid token will decide whether to transfer apps into logged-in or ask the user to input credentials. Subsequently, suppose the user inputs the correct credentials. In that case, the app will prompt the user for MFA processes or log in directly to the user, depending on whether the user activates MFA. 

We propose to leverage state machines to model this complicated process.
Figure~\ref{fig:statemachine} illustrates our proposed state machine, which is structured into three \textbf{composite states}: \textbf{Pre-Login}, \textbf{Login}, and \textbf{Post-Login}. The format denotes each transition between states: \textit{Trigger[Guard]/Action}, signifying that if the condition specified in the \textit{Guard} is met following a \textit{Trigger}, the app executes the corresponding \textit{Action}. Initially, the app checks for a valid token from the \textit{Initial State} within the \textbf{Pre-Login} phase; if a valid token is present, it transitions directly to the \textit{Logged In} state, thus bypassing the credential input. The app transfers to the \textit{Credential Input} state if no valid token exists, prompting the user to input login credentials. Subsequently, if the credentials are incorrectly formatted, the state transitions to \textit{Credential Format Error}; otherwise, the app proceeds to authenticate in the \textit{Authenticating} state under the \textbf{Login} phase. During authentication, the app moves to the \textit{Service Unavailable} state if the service is unavailable. Upon successful credential verification, and if multi-factor authentication (MFA) is required, the app transitions to the \textit{MFA Code Pending} state; if MFA is not required, or once MFA verification is complete without errors, the app then transitions to the \textit{Logged In} state. However, if MFA verification fails, the app enters the \textit{MFA Error} state. The \textbf{Post-Login} phase consists solely of the \textit{Logged In} state, indicating successful access to the app.

We proposed this state machine based on analyzing the login processes defined in our 44 analyzed Android apps. We initially examined the login methods supported by each app, discovering that 38 repositories utilize username and password authentication, and 18 of these also support MFA.
% Thus, we decided to model this process.
We downloaded all available repositories from Google Play to derive this state machine. We performed login actions for each app on an Android emulator using Appium\cite{appium}, a tool designed to facilitate UI automation that helps identify the current activity and corresponding method of an app. Subsequent analysis of the relevant source code revealed the complete process and the methods involved. We then abstracted the states and their transitions based on transitions between different methods, the conditions triggering these method calls, and the subsequent action.
% \lili{XXXX how you derived the states}
While different apps can have variations in the login process (e.g. NextCloud\cite{nextcloud-android} allows users to use their domain name to login), our state machine captures the general login processes of the Android apps.
% State transitions are facilitated by specific methods; for instance, the transition from \textit{Credential Input} to \textit{Authenticating} is managed by the \texttt{SubmitCredentials} operation which is achieved by invoking \texttt{Authenticate} method which will send credentials input by users to authentication server. Furthermore, the application should navigate to the appropriate subsequent state: valid credentials should logically transition to the \textit{Logged In} state, rather than the \textit{Invalid Credentials} state, and vice versa. \yuki{I recommend to specify what the "State" is here, and what the "State management" is. e.g., We define State as the consecutive steps during the login action. For example, input the username, password, Continue, verify the email, and so on... Then the term "State Transition" comes out, which is the "Next Step" action in the login steps? A simplified version of the State Transition image should fit here.} \rufeng{I agree. At least, we could have some examples of states here.}% \lili{I strongly agree. You need to explain: What is a state? What is state management? What are state management errors.}\zixu{Added}
Login flow errors refer to improper handling of states or transitions in the login flow. They were divided into four subcategories, each reflecting challenges in maintaining the integrity of the login process through proper state transitions and error handling.
\paragraph{Improper Error State Handling}
Improper Error State Handling induced 57 issues where the app did not correctly handle errors that arose in the login process. An example is issue \#7437 from WordPress~\cite{wordpress}, where users were incorrectly informed that their email was not registered when a network error occurred during the login process. This problem was addressed in a subsequent pull request, correcting the behavior by displaying a generic network error message instead.

\paragraph{Interference with Other State Machines}
\lili{After a second thought, I changed the name of the category. Please be reminded to revise other places.}\zixu{Modified}
Android apps are fundamentally built around the concept of lifecycles, which manage how activities within the app are created, paused, and destroyed based on user interactions and system events. The Android lifecycle can be viewed as a state machine~\cite{google-android-doc-state}, where each lifecycle state represents a node, and transitions between these states are triggered by lifecycle events.
The login flow can easily interfere with the lifecycle events as it involves intensive transitions between Activities. 
% Misalignment Between Two State Machines  refers to the state machine of the login process not being well-aligned with the lifecycle state machine.
57 issues in our dataset were induced by failures to consider such interference.
% This misalignment can lead to interference where crucial data is not preserved across lifecycle events, leading to data loss. This resulted in 53 instances in our dataset.
For example, in Thunderbird~\cite{thunderbird-android} and Wikimedia Commons Android apps~\cite{commons-android-commons}, users frequently encounter data loss issues when rotating their devices. Specifically, in Thunderbird issue \#4936 and Wikimedia Commons issue \#3973, users lose selected account information or entered credentials because the apps do not save the user input data during the lifecycle state transitions.
% , such as \texttt{selectedAccountUuid}, which contains the account user selected.
When the device is rotated, the login activity will be destroyed and then recreated.
The data will be lost if the user input data are not stored via \texttt{onSaveInstanceState()}.
% Therefore, using the \texttt{onSaveInstanceState()} to save crucial information before the device is rotated is necessary.
% This failure to effectively manage state transitions leads to a frustrating user experience.
%\yuki{Please consider explain the "lifecycle-aware" term in Android Views, and how it is related to the "State Saving or Restoring".}\zixu{Done}

\paragraph{Missing Login Flow}\label{Missingloginflow}
This category represented 52 \lili{Have you re-do the categorization for these 61 issues?}\zixu{Yes, this part is re-did and updated all into Table~\ref{tab:root-causes}}issues in which essential steps or states in the login flow are missing.
% such as failing to consider account-adding scenarios.
% \lili{I think we discussed in the past that the name/definition of this category should be changed. Can you please check your meeting slides and revise accordingly?}\zixu{modified}
For example, issue \#4462 from NextCloud~\cite{nextcloud-android}, which supports user login with multiple accounts, demonstrated that users could not add a new account without replacing the previous one. This occurred because app never updated the boolean variable  \texttt{isFirstRun}, a flag to identify whether it's the first time to log into the app.
As a result, the app mistakenly believed that it was always the first run, and consequently, the new account information will overwrite the previous logged-in information.

\paragraph{Incorrect Login Flow}
This category involved 48 instances in which an app transits to a state or branch that does not align with expected behavior, leading to an incorrect login flow.
Incorrect app transition implementations often cause these issues.
A relevant example is issue \#219 from Home Assistant~\cite{home-assistant-android}: users encounter a white screen after logging in. This problem stems from the application's handling of \texttt{PREF\_REMOTE\_URL}, which stores the redirecting URL after use log in. This issue occurs when a null value is passed to \texttt{PREF\_REMOTE\_URL} (e.g. when no URL was input from a user). Instead of using the existing default URL, the null value overrides the default one and leads to a white screen, representing a wrong consequence of the state transition.
% \lili{This entire paragraph needs to be rewritten. The problem is unclear. Can we just use the example in our response letter?}\zixu{Done}

\subsubsection{API Misuse}
The misuse of APIs, particularly those related to authentication, such as Google or Facebook login APIs, emerged as a significant root cause. This category includes 63 identified issues where developers often use login-related APIs or their return values incorrectly.
% or improperly use the return values from these APIs.
% Common problems include incorrect callbacks and improper handling of tokens.
For instance, issue \#8525 in NextCloud showed the app crashing when attempting to login when trying to access a null token.
The issue was induced by using a wrong API (\texttt{peekAuthToken}) from Android \texttt{AccountManager}.
% the resolution was to use 
% To fix the issue, the app used \texttt{blockingGetAuthToken} instead of \texttt{peekAuthToken}, which can return null if no token is cached for the app.
The developers overlooked that \texttt{peekAuthToken} will immediately return null if no token is cached for the app.
To fix the issue, \texttt{blockingGetAuthToken} is used instead to ensure that the application does not proceed without a valid token.
% It waits to get a token or fails clearly, preventing crashes caused by trying to use a non-existent (null) token.
% which could happen with \texttt{peekAuthToken}.
% if it returns null immediately without waiting for token availability.
% This method thereby adds reliability and stability to the login process by ensuring proper token handling. 

\subsubsection{Null Object Check Omission}
The omission of null object checks accounts for 39 issues where developers failed to verify whether an object was null before accessing it. For example, in NextCloud~\cite{nextcloud-android}, issue \#9971 reported a crash when sharing content to NextCloud without a prior login. Previously, the app directly called \texttt{getUser()}, but this method did not include a null check. The crash was resolved by updating the code first to check \texttt{getUser().isPresent()} before proceeding, ensuring that user information is available.


\subsubsection{Improper Encoding Algorithm}
Incorrect application of encoding algorithms, such as URL or Base64 encoding, induced 23 issues in our dataset. Problems often arose when an app did not adequately encode special characters in user credentials, leading to authentication errors. For example, in ownCloud~\cite{owncloud}, issue~\#2451 involved a login failure when the password contained the special character ``ยง". Initially, the code did not specify the character encoding when creating basic credentials, using \texttt{Credentials.basic(mUsername, mPassword)}.
As a result, this character cannot be encoded.
The issue was fixed by modifying the code to explicitly use UTF-8 encoding, changing to \texttt{Credentials.basic(mUsername, mPassword, Util.UTF\_8)}, thereby ensuring that all characters can be correctly handled in the credentials.

\subsubsection{Wrong Environment Dependency}
Finally, 22 issues were attributed to incorrect environment dependencies, where login functionalities failed due to being executed in unsuitable or misconfigured environments, such as specific Android versions. For example, in Thunderbird issue \#2146~\cite{thunderbird-android}, users could not log in and encountered an \texttt{SSLHandshakeException} after updating to Android 7.0. The developer explained that this was expected, as SSL cryptography in Android 7.0 is ``broken'' due to the absence of certain widely used elliptic curves. They advised users to upgrade to Android 7.1.1 or higher to resolve the issue.
%\rufeng{IMO, root causes and symptoms are closely linked. Consider adding symptoms to your examples and reducing the focus on solutions.} \zixu{Add examples for state management error}

% Each of these root causes not only highlights specific technical shortcomings but also reflects broader challenges in software development practices, such as the need for a better understanding of complex state transitions. Addressing these root causes through targeted improvements in coding practices, documentation, and developer training can significantly enhance login reliability in Android apps.



\begin{tcolorbox}[left=3pt,right=3pt,top=1pt,bottom=1pt]
    \textbf{Answer to RQ1:} 
\textit{We identified five categories of common root causes for login issues in Android apps. The most prevalent root cause is Login Flow Errors, where the login flows in the apps are broken due to missing steps, incorrect state transitions, improper error handling, or interference with other Android-native state machines such as the Activity lifecycles.
% which we further divided into four subcategories.
}
\end{tcolorbox}