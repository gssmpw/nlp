\subsection{Creating the Dataset}\label{subsec:dataset}







One of the biggest challenges in microservices decomposition research is the lack of data for supervised learning solutions \cite{oumoussa2024decompsurvey,Abgaz2023decompsurvey}. Monoliths rarely have a single definitive decomposition, making it difficult to rely on existing decompositions for model fine-tuning. However, the open-source ecosystem is abundant with Microservices solutions with various frameworks and diverse designs. We can leverage this fact to construct a dataset for training and evaluating the EMs which is only possible due to LLMs' generalization ability and Contrastive Learning self-supervised methods. The dataset creation process involves three steps:


\subsubsection{Application selection} focuses on choosing microservices repositories, primarily Java applications. Sources include a curated list \cite{rahman2019curatedset}, applications from decomposition research \cite{khaled2022hierdecomp,kalia2021mono2micro,desai2021cogcn,faustino2022stepwise}, and Github API queries. The latter includes only repositories with at least 10 Github stars, that have Java source files and that verify this regex:
\begin{center}
\resizebox{\columnwidth}{!}{\texttt{micro( |-)?services?( |-)(architecture|system|application)}}
\end{center}

\subsubsection{Repository Analysis} involves cloning and analyzing the selected repositories to filter out false positives. We define the sub-directory pattern \textit{"main/java"} as a microservice source root and remove projects with less than 2 microservices. For the remaining projects, we extract their classes and match their source code samples with the corresponding microservice.
\subsubsection{Triplets Sampling} creates the training dataset based on the extracted classes and microservices. Let  \( K \) be the maximum number of samples. We iteratively select random samples to create anchor, positive, and negative triplets. Anchor and positive classes are chosen from the same microservice within a randomly selected repository, while the negative class comes from a different service in the same repository. This process repeats  \( K \) times, after which duplicates are removed.