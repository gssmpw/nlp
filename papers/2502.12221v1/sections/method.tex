\section{METHODOLOGY}
\label{sec:method}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/method.pdf}
    \caption{Comparsion of the previous method and our method (ReF Decompile). 
    Previous end-to-end methods rely solely on information from the executable segment, leading to ``information loss'' during decompilation. 
    For example, the processed assembly here lost variable information (“\textbf{\textit{3.14}}” in the source code) and the jump target (“\textbf{\textit{1109}}” of “jbe 1109” in the raw assembly).
    This results in code reconstructions that appeared plausible but are actually incorrect.
    By incorporating Relabeling information (Relabeling) and leveraging relevant tools (Function Call), the model can now gain a deeper understanding of code jump logic and access valuable information stored outside the executable segment. 
    This enhancement allows the model to accurately reconstruct the original code, significantly improving the precision and reliability of the decompilation process. }
    \label{fig:main-method}
\end{figure}

Existing end-to-end decompilation methods often lose critical information needed to reconstruct control flow structures and variables when processing binary files, making it difficult to accurately recover the program’s logic.  
For example, in \Cref{fig:main-method}, the processed assembly of the previous method lost variable information (``$3.14$'' in the source code) and the jump target (``1109'' of ``jbe 1109'' in the raw assembly).

To solve the above challenge, in this paper, we propose the Relabeling and Function Call Enhanced Decompile method (ReF Decompile), which updates and optimizes the end-to-end decompilation process and applies it to both the training and inference stages.
The method includes using the Relabeling strategy to identify address information, and leveraging the function call strategy to complete variable information using the binary file.

In this section, we first introduce our proposed ReF Decompile and then describe how the training data are constructed.


\subsection{ReF Decompile: Relabeling and Function Call Enhanced Decompile}

In this subsection, we will introduce the overall process of the ReF Decompile method, which consists of the following four steps:

\begin{enumerate}
    \item \text{Disassembly Binary File:}
    By employing disassembly tools such as ``Objdump'' or ``Capstone'', and by specifying concrete function names or address ranges, we can translate the machine code of functions into raw assembly code that is more interpretable.
    Raw assembly code includes the complete source code information that will be used in the following steps.

    \item \text{Preprocess Assembly with Relabeling:}
    In this phase, we preprocess the raw assembly code to simplify its structure for data construction. 
    The processed result also satisfies the syntax accepted by the assembler.
    Initially, all jump instruction target addresses are replaced with labels (e.g., address 0x1109 is replaced with "L1"), and these labels are inserted at the corresponding target locations while removing all address information preceding non-target addresses. 
    Secondly, addresses in instructions related to data access are also labeled (e.g., \textit{0xef7(\%rip)} is replaced with \textit{D1(\%rip)}), and a mapping between these labels and their actual addresses is recorded.
    The preprocessed assembly code is then utilized as input for the model.

    \item \text{Process Function Call Request:}
    Our system incorporates a mechanism that allows the model to generate structured requests for function calls or accessing data.
    Upon feeding the preprocessed assembly code into the model, if it contains memory access instructions, the model typically issues a function call request that includes labels from the memory access instructions along with their associated data types.
    Leveraging the label-to-address mapping established in the previous step, we can identify the actual addresses represented by these labels and parse the corresponding sections of the binary file (commonly the .rodata section) according to the data types predicted by the model. The labels and parsing results are then fed back into the model as input.

    \item \text{Decompile Finally:}
    After completing the aforementioned steps, the model accumulates both the assembly code corresponding to the function and the data values at the addresses referenced by memory access instructions. Based on this information, the model produces a final high-level language representation, thereby achieving the transformation from low-level machine code to high-level programming language constructs.

\end{enumerate}

\subsection{Data construction}

In this section, we introduce the data construction process of \textit{Relabeling} and \textit{Function Call} in our proposed method.
The constructed data trains the model to understand the format of relabeled data and to interact through function calls.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/relocation.pdf}
    \caption{The processing details of Relabeling.}
    \label{fig:relabeling}
\end{figure}

\subsubsection{Relabeling}

The relabeling process aims to remove specific address information (including jump and memory access addresses) from the assembly code while preserving the program's jump logic to ensure control flow integrity. 
As the \Cref{fig:relabeling} shows, the specific steps are as follows:

\begin{enumerate}
    \item \textbf{Collection of Address Information and Label Assignment}: First, we perform a disassembly analysis of the program. (a) We identify all target addresses associated with jump instructions (e.g., ``jbe''), as these addresses control the program's flow of execution and are crucial for the relabeling process. These addresses are recorded and labeled (e.g., L1, L2, etc.). (b) We identify all instructions related to memory access (e.g., ``addss 0xef7(\%rip),\%xmm0''), record these addresses, and assign corresponding labels (e.g., D1, D2, etc.).
    \item \textbf{Replacement of Specific Addresses with Labels}: All addresses recorded in the previous step, including both jump and memory access addresses, are replaced with the assigned labels.
    \item \textbf{Insertion of Labels Before Jump Targets}: To eliminate specific memory address information while maintaining the jump logic, we insert the corresponding label before each jump target instruction.
\end{enumerate}

Through this process, we remove the address information while preserving the integrity of the program's jump logic and ensuring that critical jump information is not lost.

\subsubsection{Function Call}

This process is designed to lay the groundwork for subsequent decompilation efforts using LLMs.
This involves parsing source code and analyzing binary files to accurately extract and match literals with their storage addresses within the binaries. 
As the \Cref{fig:tool} shows, the detailed process is as follows:

\begin{figure}[t]
    \centering
    \includegraphics[width=0.9\linewidth]{figures/tool.pdf}
    \caption{Overview of the Data Construction for Function Call. }
    \label{fig:tool}
\end{figure}

\begin{enumerate}
\item \textbf{Collect Literals from Source Code:}
Initially, we employ the clang compiler toolchain to parse C language code, extracting literal data such as strings, floats, and doubles. This step identifies all constants within the source code, clarifying how these constants manifest post-compilation. To ensure consistency between literals in the source code (for example, the values 0.0 and 5.0 in the source code in Figure 4) and data in the binary files, we convert the extracted literals into corresponding bytecode based on their types. This conversion ensures that the storage format of literals matches the form present in the binary files, facilitating accurate comparison.

\item \textbf{Collecting Memory Access Addresses:}
Next, we disassemble the compiled binary files to identify memory addresses related to memory access instructions, assigning labels (e.g., D1, D2) to these addresses. This step mirrors the relabeling process, specifically focusing on address mapping pertinent to memory accesses.

\item \textbf{Constructing Data Addresses Mapping:}
Finally, we compare the bytecode representation of literals with the memory load addresses obtained from the disassembly analysis. Through this precise matching, we determine the specific storage addresses and types of literals within the binary files, thereby constructing a mapping relationship among labels, addresses, types, and data.

\item \textbf{Constructing Function Calls:}
Based on the established mapping relationships, we can formulate the necessary information for function calls, including the memory access labels and data types required by the model. The result of such a call is the value stored at the address corresponding to the label.
\end{enumerate}

This systematic approach provides high-quality input data for subsequent decompilation tasks using LLMs. By accurately extracting and matching literals with their storage addresses, and constructing function calls based on this mapping, the model gains a better understanding of program execution details, leading to more precise code representation generation.
