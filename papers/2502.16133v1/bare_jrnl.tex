%% bare_jrnl.tex
%% V1.4b
%% 2015/08/26
%% by Michael Shell
%% see http://www.michaelshell.org/
%% for current contact information.
%%
%% This is a skeleton file demonstrating the use of IEEEtran.cls
%% (requires IEEEtran.cls version 1.8b or later) with an IEEE
%% journal paper.
%%
%% Support sites:
%% http://www.michaelshell.org/tex/ieeetran/
%% http://www.ctan.org/pkg/ieeetran
%% and
%% http://www.ieee.org/

%%*************************************************************************
%% Legal Notice:
%% This code is offered as-is without any warranty either expressed or
%% implied; without even the implied warranty of MERCHANTABILITY or
%% FITNESS FOR A PARTICULAR PURPOSE! 
%% User assumes all risk.
%% In no event shall the IEEE or any contributor to this code be liable for
%% any damages or losses, including, but not limited to, incidental,
%% consequential, or any other damages, resulting from the use or misuse
%% of any information contained here.
%%
%% All comments are the opinions of their respective authors and are not
%% necessarily endorsed by the IEEE.
%%
%% This work is distributed under the LaTeX Project Public License (LPPL)
%% ( http://www.latex-project.org/ ) version 1.3, and may be freely used,
%% distributed and modified. A copy of the LPPL, version 1.3, is included
%% in the base LaTeX documentation of all distributions of LaTeX released
%% 2003/12/01 or later.
%% Retain all contribution notices and credits.
%% ** Modified files should be clearly indicated as such, including  **
%% ** renaming them and changing author support contact information. **
%%*************************************************************************


% *** Authors should verify (and, if needed, correct) their LaTeX system  ***
% *** with the testflow diagnostic prior to trusting their LaTeX platform ***
% *** with production work. The IEEE's font choices and paper sizes can   ***
% *** trigger bugs that do not appear when using other class files.       ***                          ***
% The testflow support page is at:
% http://www.michaelshell.org/tex/testflow/



\documentclass[journal]{IEEEtran}
%
% If IEEEtran.cls has not been installed into the LaTeX system files,
% manually specify the path to it like:
% \documentclass[journal]{../sty/IEEEtran}





% Some very useful LaTeX packages include:
% (uncomment the ones you want to load)


% *** MISC UTILITY PACKAGES ***
%
%\usepackage{ifpdf}
% Heiko Oberdiek's ifpdf.sty is very useful if you need conditional
% compilation based on whether the output is pdf or dvi.
% usage:
% \ifpdf
%   % pdf code
% \else
%   % dvi code
% \fi
% The latest version of ifpdf.sty can be obtained from:
% http://www.ctan.org/pkg/ifpdf
% Also, note that IEEEtran.cls V1.7 and later provides a builtin
% \ifCLASSINFOpdf conditional that works the same way.
% When switching from latex to pdflatex and vice-versa, the compiler may
% have to be run twice to clear warning/error messages.






% *** CITATION PACKAGES ***
%
\usepackage{cite}
% cite.sty was written by Donald Arseneau
% V1.6 and later of IEEEtran pre-defines the format of the cite.sty package
% \cite{} output to follow that of the IEEE. Loading the cite package will
% result in citation numbers being automatically sorted and properly
% "compressed/ranged". e.g., [1], [9], [2], [7], [5], [6] without using
% cite.sty will become [1], [2], [5]--[7], [9] using cite.sty. cite.sty's
% \cite will automatically add leading space, if needed. Use cite.sty's
% noadjust option (cite.sty V3.8 and later) if you want to turn this off
% such as if a citation ever needs to be enclosed in parenthesis.
% cite.sty is already installed on most LaTeX systems. Be sure and use
% version 5.0 (2009-03-20) and later if using hyperref.sty.
% The latest version can be obtained at:
% http://www.ctan.org/pkg/cite
% The documentation is contained in the cite.sty file itself.




\usepackage{caption}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{booktabs} 

\usepackage{makecell}

\usepackage{algorithm}  
\usepackage{algpseudocode}   

\renewcommand{\algorithmicrequire}{\textbf{Input:}}  
\renewcommand{\algorithmicensure}{\textbf{Output:}} 


% *** GRAPHICS RELATED PACKAGES ***
%
\ifCLASSINFOpdf
  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../pdf/}{../jpeg/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.pdf,.jpeg,.png}
\else
  % or other class option (dvipsone, dvipdf, if not using dvips). graphicx
  % will default to the driver specified in the system graphics.cfg if no
  % driver is specified.
  % \usepackage[dvips]{graphicx}
  % declare the path(s) where your graphic files are
  % \graphicspath{{../eps/}}
  % and their extensions so you won't have to specify these with
  % every instance of \includegraphics
  % \DeclareGraphicsExtensions{.eps}
\fi
% graphicx was written by David Carlisle and Sebastian Rahtz. It is
% required if you want graphics, photos, etc. graphicx.sty is already
% installed on most LaTeX systems. The latest version and documentation
% can be obtained at: 
% http://www.ctan.org/pkg/graphicx
% Another good source of documentation is "Using Imported Graphics in
% LaTeX2e" by Keith Reckdahl which can be found at:
% http://www.ctan.org/pkg/epslatex
%
% latex, and pdflatex in dvi mode, support graphics in encapsulated
% postscript (.eps) format. pdflatex in pdf mode supports graphics
% in .pdf, .jpeg, .png and .mps (metapost) formats. Users should ensure
% that all non-photo figures use a vector format (.eps, .pdf, .mps) and
% not a bitmapped formats (.jpeg, .png). The IEEE frowns on bitmapped formats
% which can result in "jaggedy"/blurry rendering of lines and letters as
% well as large increases in file sizes.
%
% You can find documentation about the pdfTeX application at:
% http://www.tug.org/applications/pdftex





% *** MATH PACKAGES ***
%
%\usepackage{amsmath}
% A popular package from the American Mathematical Society that provides
% many useful and powerful commands for dealing with mathematics.
%
% Note that the amsmath package sets \interdisplaylinepenalty to 10000
% thus preventing page breaks from occurring within multiline equations. Use:
%\interdisplaylinepenalty=2500
% after loading amsmath to restore such page breaks as IEEEtran.cls normally
% does. amsmath.sty is already installed on most LaTeX systems. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/amsmath





% *** SPECIALIZED LIST PACKAGES ***
%
%\usepackage{algorithmic}
% algorithmic.sty was written by Peter Williams and Rogerio Brito.
% This package provides an algorithmic environment fo describing algorithms.
% You can use the algorithmic environment in-text or within a figure
% environment to provide for a floating algorithm. Do NOT use the algorithm
% floating environment provided by algorithm.sty (by the same authors) or
% algorithm2e.sty (by Christophe Fiorio) as the IEEE does not use dedicated
% algorithm float types and packages that provide these will not provide
% correct IEEE style captions. The latest version and documentation of
% algorithmic.sty can be obtained at:
% http://www.ctan.org/pkg/algorithms
% Also of interest may be the (relatively newer and more customizable)
% algorithmicx.sty package by Szasz Janos:
% http://www.ctan.org/pkg/algorithmicx




% *** ALIGNMENT PACKAGES ***
%
%\usepackage{array}
% Frank Mittelbach's and David Carlisle's array.sty patches and improves
% the standard LaTeX2e array and tabular environments to provide better
% appearance and additional user controls. As the default LaTeX2e table
% generation code is lacking to the point of almost being broken with
% respect to the quality of the end results, all users are strongly
% advised to use an enhanced (at the very least that provided by array.sty)
% set of table tools. array.sty is already installed on most systems. The
% latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/array


% IEEEtran contains the IEEEeqnarray family of commands that can be used to
% generate multiline equations as well as matrices, tables, etc., of high
% quality.




% *** SUBFIGURE PACKAGES ***
%\ifCLASSOPTIONcompsoc
%  \usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
%\else
%  \usepackage[caption=false,font=footnotesize]{subfig}
%\fi
% subfig.sty, written by Steven Douglas Cochran, is the modern replacement
% for subfigure.sty, the latter of which is no longer maintained and is
% incompatible with some LaTeX packages including fixltx2e. However,
% subfig.sty requires and automatically loads Axel Sommerfeldt's caption.sty
% which will override IEEEtran.cls' handling of captions and this will result
% in non-IEEE style figure/table captions. To prevent this problem, be sure
% and invoke subfig.sty's "caption=false" package option (available since
% subfig.sty version 1.3, 2005/06/28) as this is will preserve IEEEtran.cls
% handling of captions.
% Note that the Computer Society format requires a larger sans serif font
% than the serif footnote size font used in traditional IEEE formatting
% and thus the need to invoke different subfig.sty package options depending
% on whether compsoc mode has been enabled.
%
% The latest version and documentation of subfig.sty can be obtained at:
% http://www.ctan.org/pkg/subfig




% *** FLOAT PACKAGES ***
%
%\usepackage{fixltx2e}
% fixltx2e, the successor to the earlier fix2col.sty, was written by
% Frank Mittelbach and David Carlisle. This package corrects a few problems
% in the LaTeX2e kernel, the most notable of which is that in current
% LaTeX2e releases, the ordering of single and double column floats is not
% guaranteed to be preserved. Thus, an unpatched LaTeX2e can allow a
% single column figure to be placed prior to an earlier double column
% figure.
% Be aware that LaTeX2e kernels dated 2015 and later have fixltx2e.sty's
% corrections already built into the system in which case a warning will
% be issued if an attempt is made to load fixltx2e.sty as it is no longer
% needed.
% The latest version and documentation can be found at:
% http://www.ctan.org/pkg/fixltx2e


%\usepackage{stfloats}
% stfloats.sty was written by Sigitas Tolusis. This package gives LaTeX2e
% the ability to do double column floats at the bottom of the page as well
% as the top. (e.g., "\begin{figure*}[!b]" is not normally possible in
% LaTeX2e). It also provides a command:
%\fnbelowfloat
% to enable the placement of footnotes below bottom floats (the standard
% LaTeX2e kernel puts them above bottom floats). This is an invasive package
% which rewrites many portions of the LaTeX2e float routines. It may not work
% with other packages that modify the LaTeX2e float routines. The latest
% version and documentation can be obtained at:
% http://www.ctan.org/pkg/stfloats
% Do not use the stfloats baselinefloat ability as the IEEE does not allow
% \baselineskip to stretch. Authors submitting work to the IEEE should note
% that the IEEE rarely uses double column equations and that authors should try
% to avoid such use. Do not be tempted to use the cuted.sty or midfloat.sty
% packages (also by Sigitas Tolusis) as the IEEE does not format its papers in
% such ways.
% Do not attempt to use stfloats with fixltx2e as they are incompatible.
% Instead, use Morten Hogholm'a dblfloatfix which combines the features
% of both fixltx2e and stfloats:
%
% \usepackage{dblfloatfix}
% The latest version can be found at:
% http://www.ctan.org/pkg/dblfloatfix




%\ifCLASSOPTIONcaptionsoff
%  \usepackage[nomarkers]{endfloat}
% \let\MYoriglatexcaption\caption
% \renewcommand{\caption}[2][\relax]{\MYoriglatexcaption[#2]{#2}}
%\fi
% endfloat.sty was written by James Darrell McCauley, Jeff Goldberg and 
% Axel Sommerfeldt. This package may be useful when used in conjunction with 
% IEEEtran.cls'  captionsoff option. Some IEEE journals/societies require that
% submissions have lists of figures/tables at the end of the paper and that
% figures/tables without any captions are placed on a page by themselves at
% the end of the document. If needed, the draftcls IEEEtran class option or
% \CLASSINPUTbaselinestretch interface can be used to increase the line
% spacing as well. Be sure and use the nomarkers option of endfloat to
% prevent endfloat from "marking" where the figures would have been placed
% in the text. The two hack lines of code above are a slight modification of
% that suggested by in the endfloat docs (section 8.4.1) to ensure that
% the full captions always appear in the list of figures/tables - even if
% the user used the short optional argument of \caption[]{}.
% IEEE papers do not typically make use of \caption[]'s optional argument,
% so this should not be an issue. A similar trick can be used to disable
% captions of packages such as subfig.sty that lack options to turn off
% the subcaptions:
% For subfig.sty:
% \let\MYorigsubfloat\subfloat
% \renewcommand{\subfloat}[2][\relax]{\MYorigsubfloat[]{#2}}
% However, the above trick will not work if both optional arguments of
% the \subfloat command are used. Furthermore, there needs to be a
% description of each subfigure *somewhere* and endfloat does not add
% subfigure captions to its list of figures. Thus, the best approach is to
% avoid the use of subfigure captions (many IEEE journals avoid them anyway)
% and instead reference/explain all the subfigures within the main caption.
% The latest version of endfloat.sty and its documentation can obtained at:
% http://www.ctan.org/pkg/endfloat
%
% The IEEEtran \ifCLASSOPTIONcaptionsoff conditional can also be used
% later in the document, say, to conditionally put the References on a 
% page by themselves.




% *** PDF, URL AND HYPERLINK PACKAGES ***
%
%\usepackage{url}
% url.sty was written by Donald Arseneau. It provides better support for
% handling and breaking URLs. url.sty is already installed on most LaTeX
% systems. The latest version and documentation can be obtained at:
% http://www.ctan.org/pkg/url
% Basically, \url{my_url_here}.




% *** Do not adjust lengths that control margins, column widths, etc. ***
% *** Do not use packages that alter fonts (such as pslatex).         ***
% There should be no need to do such things with IEEEtran.cls V1.6 and later.
% (Unless specifically asked to do so by the journal or conference you plan
% to submit to, of course. )


% correct bad hyphenation here
\hyphenation{op-tical net-works semi-conduc-tor}


\begin{document}
%
% paper title
% Titles are generally capitalized except for words such as a, an, and, as,
% at, but, by, for, in, nor, of, on, or, the, to and up, which are usually
% not capitalized unless they are the first or last word of the title.
% Linebreaks \\ can be used within to get better formatting as desired.
% Do not put math or special symbols in the title.
\title{A Trust-Aware and Cost-Optimized Blockchain Oracle Selection Model with Deep Reinforcement Learning}
%
%
% author names and IEEE memberships
% note positions of commas and nonbreaking spaces ( ~ ) LaTeX will not break
% a structure at a ~ so this keeps an author's name from being broken across
% two lines.
% use \thanks{} to gain access to the first footnote area
% a separate \thanks must be used for each paragraph as LaTeX2e's \thanks
% was not built to handle multiple paragraphs
%

% \author{% <-this % stops a space
% \thanks{}% <-this % stops a space
% \thanks{}% <-this % stops a space
% }

\author{Hengyang~Zhang,
        Shike~Li,~\IEEEmembership{Student~Member,~IEEE,}
        Hang~Bao, 
        Sixing~Wu,
        and~Jianbin~Li% <-this % stops a space
\thanks{This work is supported by Research on Key Technologies to Support Network Operation of Distributed Energy Storage (5100-202199544A-0-5- ZN).}     
\thanks{Hengyang Zhang, Hang Bao, Sixing Wu and Jianbin Li are with the School of Control and Computer Engineering, North China Electric Power University, Beijing, China (e-mail: \{hyzhang, wusx, lijb87\}@ncepu.edu.cn, hangbao06@163.com).}% <-this % stops a space
\thanks{Shike Li is with the Shanxi University(e-mail: lsk@sxu.edu.cn).}}

% note the % following the last \IEEEmembership and also \thanks - 
% these prevent an unwanted space from occurring between the last author name
% and the end of the author line. i.e., if you had this:
% 
% \author{....lastname \thanks{...} \thanks{...} }
%                     ^------------^------------^----Do not want these spaces!
%
% a space would be appended to the last name and could cause every name on that
% line to be shifted left slightly. This is one of those "LaTeX things". For
% instance, "\textbf{A} \textbf{B}" will typeset as "A B" not "AB". To get
% "AB" then you have to do: "\textbf{A}\textbf{B}"
% \thanks is no different in this regard, so shield the last } of each \thanks
% that ends a line with a % and do not let a space in before the next \thanks.
% Spaces after \IEEEmembership other than the last one are OK (and needed) as
% you are supposed to have spaces between the names. For what it is worth,
% this is a minor point as most people would not even notice if the said evil
% space somehow managed to creep in.



% The paper headers
% \markboth{Journal of \LaTeX\ Class Files,~Vol.~14, No.~8, August~2015}%
% {Shell \MakeLowercase{\textit{et al.}}: Bare Demo of IEEEtran.cls for IEEE Journals}
% The only time the second header will appear is for the odd numbered pages
% after the title page when using the twoside option.
% 
% *** Note that you probably will NOT want to include the author's ***
% *** name in the headers of peer review papers.                   ***
% You can use \ifCLASSOPTIONpeerreview for conditional compilation here if
% you desire.




% If you want to put a publisher's ID mark on the page you can do it like
% this:
%\IEEEpubid{0000--0000/00\$00.00~\copyright~2015 IEEE}
% Remember, if you use this you must call \IEEEpubidadjcol in the second
% column for its text to clear the IEEEpubid mark.



% use for special paper notices
%\IEEEspecialpapernotice{(Invited Paper)}




% make the title area
\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract or keywords.
\begin{abstract}

The rapid development of blockchain technology has driven the widespread application of decentralized applications (DApps) across various fields. However, DApps cannot directly access external data and rely on oracles to interact with off-chain data. As a bridge between blockchain and external data sources, oracles pose potential risks of malicious behavior, which may inject incorrect or harmful data, leading to trust and security issues. Additionally, with the surge in data requests, the disparity in oracle trustworthiness and costs has increased, making the dynamic selection of the most suitable oracle for each request a critical challenge. To address these issues, this paper proposes a Trust-Aware and Cost-Optimized Blockchain Oracle Selection Model with Deep Reinforcement Learning (TCO-DRL). The model incorporates a comprehensive trust management mechanism to evaluate oracle reputation from multiple dimensions and employs an improved sliding time window to monitor reputation changes in real time, enhancing resistance to malicious attacks. Moreover, TCO-DRL uses deep reinforcement learning algorithms to dynamically adapt to fluctuations in oracle reputation, ensuring the selection of high-reputation oracles while optimizing node selection, thereby reducing costs without compromising data quality. We implemented and validated TCO-DRL on Ethereum. Experimental results show that, compared to existing methods, TCO-DRL reduces the allocation rate to malicious oracles by more than 39.10\% and saves over 12.00\% in costs. Furthermore, simulated experiments on various malicious attacks further validate the robustness and effectiveness of TCO-DRL.


\end{abstract}

% Note that keywords are not normally used for peerreview papers.
\begin{IEEEkeywords}
Blockchain oracle, Trust management, Deep Reinforcement Learning, Smart Contract, Reputation, Internet of Things.
\end{IEEEkeywords}






% For peer review papers, you can put extra information on the cover
% page as needed:
% \ifCLASSOPTIONpeerreview
% \begin{center} \bfseries EDICS Category: 3-BBND \end{center}
% \fi
%
% For peerreview papers, this IEEEtran command inserts a page break and
% creates the second title. It will be ignored for other modes.
\IEEEpeerreviewmaketitle



\section{Introduction}
% The very first letter is a 2 line initial drop letter followed
% by the rest of the first word in caps.
% 
% form to use if the first word consists of a single letter:
% \IEEEPARstart{A}{demo} file is ....
% 
% form to use if you need the single drop letter followed by
% normal text (unknown if ever used by the IEEE):
% \IEEEPARstart{A}{}demo file is ....
% 
% Some journals put the first two words in caps:
% \IEEEPARstart{T}{his demo} file is ....
% 
% Here we have the typical use of a "T" for an initial drop letter
% and "HIS" in caps to complete the first word.
\IEEEPARstart{B}{lockchain} technology, with its decentralized architecture, consensus mechanisms, and data encryption capabilities, has been widely applied in building distributed IoT systems, effectively preventing potential attacks and enhancing the overall security of IoT networks \cite{9358215}. Additionally, the introduction of smart contracts allows predefined rules to be automatically executed without third-party intervention, further promoting the deep integration of blockchain and IoT across various fields, including computation offloading \cite{9336659}, resource management \cite{8891803}, shipment management \cite{baygin2022blockchain}, inventory management \cite{ho2021blockchain}, and smart grids \cite{8234700}. However, this integration of blockchain and IoT also introduces a critical issue: due to the isolation of blockchain environments from the outside world, smart contracts cannot directly access off-chain data \cite{van2018blockchain}. Existing studies often assume that the "entities" responsible for blockchain and off-chain data interaction are fully trustworthy, but this assumption is unrealistic.

These entities that act as bridges between blockchain and external data are known as blockchain oracles \cite{al2019decentralized}. Oracles are responsible for collecting and verifying data from the outside and then transmitting it to the blockchain \cite{hassan2023trust}. However, oracles are not always trustworthy; they can be manipulated or act out of self-interest by providing incorrect or misleading data, causing smart contracts to execute based on false information, which can lead to potential trust and security issues. This problem not only reintroduces the centralization risk in blockchain but also poses the threat of malicious data being injected into the blockchain, undermining the trust foundation of the system \cite{gigli2023decentralized}.


Researchers have developed various trust models for blockchain oracles. Some of these rely on trusted execution environments (TEE), such as Intel software guard extensions (SGX) \cite{costan2016intel}, and use widely adopted TLS Notary to provide authenticity proofs, as in oracle systems like Towncrier and Provable \cite{zhang2016town}. However, hardware-based proofs do not fully guarantee tamper-proof data, and these methods are not suitable for scenarios requiring manual input or where digital data is inaccessible \cite{taghavi2023reinforcement}. On the other hand, some oracle communities (such as ChainLink, Witnet, and Augur) \cite{al2020trustworthy} evaluate the trustworthiness of oracles based on reputation scores, using reputation as the core of their trust model \cite{resnick2000reputation}. However, these communities often rely on simple historical behaviour records to calculate reputation scores, which cannot comprehensively or accurately reflect the actual behaviour of the oracles and need more robust and integrated trust management mechanisms for evaluation. 

At the same time, with the rapid development of decentralized applications (DApps) based on blockchain, the frequency of external data interactions is continuously increasing, and the number of data requests is sharply rising \cite{chainlink2024update}. Selecting the appropriate oracle nodes to handle a large number of data requests has become one of the major challenges oracle systems face. The work \cite{taghavi2023reinforcement} utilized a reinforcement learning algorithm known as the Bayesian multi-armed bandit to select oracle nodes. However, the Bayesian multi-armed bandit is typically simplify the state space to a probability distribution over different options, making them inadequate for dealing with complex and dynamic environments. In contrast, deep reinforcement learning (DRL) combines the perception capabilities of deep learning with the decision-making abilities of reinforcement learning. It can learn complex decision-making rules through continuous interaction with the environment, allowing the system to automatically learn from historical experiences, adapt to environmental changes, and gradually optimize strategies \cite{zhang2023cost}. Therefore, using DRL to design oracle node selection strategies presents a promising solution to address the challenges of complex and dynamic environments.

To address the aforementioned issues, we propose a trust-aware and cost-optimized blockchain oracle node selection model based on deep reinforcement learning (TCO-DRL). Specifically, we have designed a comprehensive trust management mechanism that evaluates the reputation of oracles from multiple dimensions (such as reliability, behavior, etc.). Additionally, TCO-DRL introduces an improved sliding time window mechanism to store and calculate the final reputation of oracles, enabling timely detection of behavioral changes and preventing malicious nodes from undermining the system's trust foundation over a prolonged period. Building on this trust management mechanism, we further propose a DRL-based oracle node selection algorithm that dynamically adapts to the changing state of data requests and oracle nodes. Since highly reputable oracles are often associated with higher costs, TCO-DRL also incorporates user budget constraints and adjusts strategies to select more cost-effective yet trustworthy oracle nodes. Through dynamic strategy adjustments, it ensures that DApps' operating costs are minimized without compromising data trustworthiness. Ultimately, TCO-DRL achieves an optimal balance between trust and cost. The main contributions of this paper are summarized as follows:
\begin{enumerate}
    \item We proposed TCO-DRL, a model that evaluates the reputation of oracles through a multi-dimensional trust management mechanism, enabling the system to more accurately assess the trustworthiness of nodes. By incorporating an improved sliding time window, TCO-DRL integrates both historical and short-term trust indicators, enhancing the system's ability to defend against malicious nodes while reducing computational overhead.
    \item We addressed the complex problem of oracle node allocation by introducing a deep reinforcement learning-based selection algorithm within TCO-DRL. TCO-DRL intelligently selects the most suitable nodes based on the complexity of data requests, the dynamic changes in oracle reputation, and the cost of each oracle. In addition, TCO-DRL considers the varying needs of data requesters, optimizing cost-efficiency while ensuring trust.
    \item We implemented and validated TCO-DRL in experiments, comparing it with existing solutions that involve noise and deteriorating conditions. The results demonstrate that TCO-DRL excels in selecting trustworthy and cost-efficient oracles. Furthermore, we deployed TCO-DRL on the Ethereum platform and simulated several typical attacks, further proving the model's effectiveness and robustness. The relevant code has been made publicly available at https://github.com/elpsylearning/TCO-DRL.
\end{enumerate}

The remainder of this paper is structured as follows: Section II provides an overview of related work. Section III presents the system architecture and sequence diagram. Section IV describes the components of the trust management scheme in detail. In Section V, we outline the process of selecting oracle node based on DRL. Section VI presents and analyzes the experimental results. Finally, Section VII concludes our work.

% You must have at least 2 lines in the paragraph with the drop letter
% (should never be an issue)

\section{RELATED WORK}
\subsection{Blockchain-based Trust Management for IoT}
IoT is characterized by high complexity and heterogeneity, constantly facing significant security and privacy threats \cite{ray2018survey}. Trust management technologies play a crucial role in establishing a reliable and effective security mechanism for IoT \cite{roman2011securing}. One potential approach to computing trust is reputation-based \cite{aaqib2023iot}, which aggregates collected trust information in a centralized or distributed manner to generate reputation scores \cite{pourghebleh2019comprehensive}. In IoT environments, employing reputation-based trust management techniques can enhance the trustworthiness between entities and detect abnormal activities \cite{alzaid2013reputation}. However, existing trust management schemes still face challenges such as single points of failure, data consistency maintenance, and the provision of a global trust view \cite{liu2023survey}. Consequently, more research is leveraging the security features of blockchain to address these issues.

In the fields of edge computing and fog computing, the work \cite{yang2023trusted} designed a decentralized trust management mechanism to evaluate the trustworthiness of edge nodes. It implemented a trusted MEC (T-MEC) framework using a directed acyclic graph structured blockchain (DAG blockchain) and distributed trust management (DTM) to resolve inconsistencies between on-chain and off-chain trust. The work \cite{kouicem2020decentralized} proposed a layered and scalable trust management scheme to assess the credibility of service providers, where trust information is computed and managed by fog nodes and propagated through a blockchain network to obtain a global view of trust data. In the supply chain sector, the work \cite{malik2019trustchain} introduced a three-layer trust management framework capable of dynamically scoring reputations to evaluate the trustworthiness of supply chain entities. By combining consortium blockchain with trust management technologies, it addresses trust challenges related to the data itself. Similarly, the work \cite{wu2022integrated} proposed a blockchain-integrated trust management model for assessing the trust of supply chain entities, providing an analysis based on a real-world scenario. In the vehicular networks domain, the work \cite{du2023blockchain} developed a trust management scheme based on Bayesian inference, integrating consortium blockchain to solve trust issues in inter-vehicle information sharing. Additionally, the work \cite{9336659} utilized three-valued subjective logic (3VSL) to comprehensively evaluate entities within vehicular networks, achieving more accurate reputations and combining blockchain for secure computation offloading.

\subsection{Deep Reinforcement Learning for IoT}
Due to the heterogeneity, complexity, and dynamic nature of IoT systems, problems framed as game theory or combinatorial optimization are often NP-hard \cite{uprety2020reinforcement}. Many studies have employed dynamic programming and heuristic algorithms to address these challenges, but these methods typically require numerous iterations to achieve satisfactory solutions \cite{huang2019deep}. In recent years, DRL has been widely applied in IoT systems because of its advantages in long-term performance optimization, real-time decision making, online learning without prior knowledge, and high scalability \cite{chen2021deep}.

In the field of industrial IoT, the work \cite{luo2023deep} developed a job scheduling model for hybrid flow shop scheduling on batch processing machines (HFSP-BPM) based on DRL, overcoming the challenge where a fixed search paradigm could not simultaneously meet the requirements for real-time processing and solution quality. In the work \cite{chen2020deep}, a DRL-based approach was proposed for dynamic resource management in industrial IoT, aiming to minimize the average task delay. This approach leverages DRL’s capability to handle high-dimensional state spaces, addressing the issues that arise from the dynamic and continuous nature of tasks in resource-constrained IIoT environments. In the domain of smart grids, the work \cite{chung2020distributed} introduced a distributed DRL-based method for intelligent load scheduling in residential smart grids, which not only protects household privacy but also reduces grid stress and household electricity costs. The work \cite{park2022multi} applied multi-agent reinforcement learning to solve the electric vehicle charging scheduling problem in smart grids, allowing for quick responses to user demands while reducing operational costs for charging station operators. In the field of intelligent transportation, the work \cite{koh2020real} proposed a DRL-based approach to develop vehicle navigation systems designed to meet the real-time demands of complex urban environments, thereby alleviating traffic congestion. The effectiveness of this solution was validated through simulations in nine real-world traffic scenarios. The work \cite{qian2019deep} utilized DRL’s adaptive learning capabilities to develop an intelligent electric vehicle charging navigation system, aiming to minimize total travel time and charging costs for electric vehicles.

The problem of selecting oracle nodes can be modeled as a decision optimization problem. Leveraging the advantages of DRL technology to select the most suitable oracle from many nodes for complex data requests is a viable solution. Based on our research, at the time of writing this paper, no existing work has applied DRL technology to the blockchain oracle domain. Our work is the first attempt in this area.
\subsection{Blockchain Oracles}
Blockchain oracles, which act as intermediaries between blockchain networks and external data, have received increasing attention in recent years. The work \cite{gigli2023decentralized} proposed a decentralized IoT global marketplace architecture based on blockchain technology and oracle networks, allowing users to purchase IoT device data through smart contracts. Additionally, to ensure data quality and credibility, a reputation algorithm was designed to evaluate data sources. The work \cite{kochovski2019trust} developed a blockchain-based trust management system for Edge-to-Cloud environments, using oracles to obtain external system monitoring data to support smart contract execution, thereby establishing trust between service providers and stakeholders. However, both studies assume that oracles will always provide honest and reliable services, which is overly optimistic.

Oracles can also behave maliciously, potentially causing significant damage to the blockchain network. Many studies have adopted reputation as the trust model for oracle systems. For instance, the work \cite{lu2021exploring} in the construction industry used smart construction objects (SCOs) as blockchain oracles to transmit real-world construction process data to the blockchain and utilized smart contracts to rate the reputation of oracles. There are also commercial oracle networks like Chainlink \cite{breidenbach2021chainlink} and Witnet \cite{de2017witnet}. However, these studies often evaluate oracle reputation based only on some past records. Chainlink derives reputation scores by recording on-chain performance history, such as average response latency. The work \cite{lu2021exploring}, similar to Witnet, assigns a high reputation score to oracles that return results matching those of the majority of oracles, while those returning different results receive lower scores. These approaches lacks more comprehensive trust management mechanisms for evaluating the reputation of oracle nodes.

Moreover, current research on how to select oracle nodes is still quite limited, with only the work \cite{taghavi2023reinforcement} employing intelligent mechanisms for the flexible selection of oracle nodes. The Table \ref{tab:1} summarizes the comparison between the BLOR proposed in the work \cite{taghavi2023reinforcement} and the TCO-DRL introduced in this paper. Overall, TCO-DRL offers the following advantages:

\begin{table*}[!t]
\centering
\caption{Comparison of the proposed TCO-DRL with BLOR.}
\label{tab:1}
\renewcommand\arraystretch{1.3}
\begin{tabular*}{0.8\linewidth}{lcc}
\toprule
\textbf{Features} & \textbf{BLOR\cite{taghavi2023reinforcement}} & \textbf{TCO-DRL} \\
\midrule 
 \textbf{Trust Model} & Reputation & Reputation \\
 \makecell[tl]{\\\textbf{Reputation Metric}} &  \makecell[tc]{\\Success and failure count} & \makecell[tc]{Reliability score \\ Behavior score \\token score}\\
 \textbf{Execution Architecture} & On-chain &  On-chain/Off-chain\\ 
 \textbf{Learning Method} & Online learning with prior knowledge  & Online learning without prior knowledge\\
 \textbf{Adaptive Learning Capability} & Weak & Strong\\
 \textbf{Scalability} & Low & High \\
 \textbf{Time Factor} &  NO & YES\\
 \textbf{Trust} & YES & YES \\
 \textbf{Cost} & YES & YES \\
 \textbf{Service Matching}& NO & YES\\
 \textbf{Attack Resistance} & NO & YES \\
\bottomrule
\end{tabular*}
\end{table*}

\subsubsection{A more comprehensive trust management scheme} TCO-DRL not only considers factors such as the oracle's success rate, interaction frequency, and average response time to compute a reliability score but also evaluates the oracle's behavior and staked tokens. Additionally, TCO-DRL incorporates the influence of a time factor, resulting in a more comprehensive trust management scheme.
\subsubsection{Independence from prior knowledge} TCO-DRL does not rely on any predefined models or prior distributions but instead learns optimal strategies directly through interaction with the environment and experience replay, enabling automatic adjustment and optimization of strategies. By using neural networks as function approximators, TCO-DRL can handle complex, high-dimensional state and action spaces, demonstrating strong learning capabilities and adaptability in dynamic and complex environments.
\subsubsection{Improved quality of service} TCO-DRL additionally takes into account the specific service requirements added by data requesters, striving to match these with oracles that offer the same services to enhance quality of service and user experience.
\subsubsection{Resistance to attacks} TCO-DRL is designed with attack resistance in mind, incorporating an improved sliding time window in its trust management scheme, which makes it difficult for malicious nodes to continuously engage in harmful actions. This enhances the system's security and robustness against malicious attack.





% needed in second column of first page if using \IEEEpubid
%\IEEEpubidadjcol


\section{The Proposed TCO-DRL Model}
In this section, we demonstrate the process by which TCO-DRL selects trustworthy and cost-effective oracle nodes to establish trust between data requesters and external data, presenting the architecture and sequence diagram of TCO-DRL for illustration.

\subsection{The Architecture of TCO-DRL}
 As shown in Fig. \ref {fig_1}, the system architecture of TCO-DRL comprises three main entities: decentralized applications (DApps), oracle community, and external data sources. The descriptions of these entities are provided below.
\subsubsection{DApps}
DApps are applications that operate on blockchain technology, interacting with the blockchain network through smart contracts to deliver decentralized services and functionalities. These applications initiate data requests, requesting services from the oracle community to obtain off-chain data. The acquired data is subsequently used in the execution of smart contracts, enabling automated contract operations and decision-making.
\subsubsection{Oracle Community}
The oracle community acts as a bridge between the blockchain and the external world, comprising a network of oracle nodes responsible for retrieving data from external sources and transmitting it to the blockchain. Additionally, the oracle community includes monitoring and reputation modules, which gather information about the on-chain activities of oracles and employ reputation evaluation and verification mechanisms to ensure the accuracy and reliability of the data.
\subsubsection{External Data Sources}
External data sources refer to various off-chain data providers that supply input to oracle nodes. These sources may include IoT device data, financial market prices, web APIs, and complex off-chain computational tasks. Oracle nodes extract relevant information from these sources and transmit it to the blockchain, thereby providing the necessary external data support for the operation of DApps.
\begin{figure}[!t]
\centering
\includegraphics[width=3in]{bibtex/figure/system/System_architecture.pdf}
\caption{The architecture of TCO-DRL.}
\label{fig_1}
\end{figure}


\begin{figure*}[!t]
\centering
\includegraphics[width=0.9\textwidth]{bibtex/figure/system/Sequence_diagram_light_color.pdf}
\caption{The sequence diagram of TCO-DRL.}
\label{fig_2}
\end{figure*}

The major components of the system are detailed below.
\paragraph{Data Requesters}
Data requesters are entities that initiate data requests. They request services through smart contracts. Additionally, they may specify particular requirements for the data.
\paragraph{Smart Contracts}
The system includes four contracts: registration contract, request contract, invocation contract, and verification contract. The registration contract handles user account registration. The request contract defines data requests and attaches parameters such as data requirements. The invocation contract is responsible for loading and executing the DRL model to select oracle nodes. The verification contract is tasked with verifying data signatures and the validity of the data.
\paragraph{DRL-driven Model}
DRL-driven model is employed to optimize the selection of nodes within the oracle community. The Deep Q-Network (DQN) algorithm is used to dynamically choose the most appropriate nodes for providing services, based on on-chain data requests and the status information of the oracles. 
\paragraph{Reputation Module}
The reputation module is a critical component of the oracle community, responsible for evaluating and recording the reputation scores of each oracle node. In practice, the oracle community typically manages reputation scores through one or more smart contracts. Here, we refer to this component as the 'reputation module' for the sake of conceptual clarity.
\paragraph{Monitoring Module}
The monitoring module is responsible for overseeing the behavior and performance of oracle nodes. It continuously tracks the activities of these nodes, including their response times, the accuracy of data transmission, their online status, and so on.
\paragraph{Oracle Nodes}
Oracle nodes are the fundamental execution units within the oracle community, responsible for retrieving data from external sources and transmitting it to smart contracts on the blockchain. Each oracle node can operate independently and may be managed by different entities, such as individuals or organizations.
\subsection{The Sequence Diagram of TCO-DRL}
To further elaborate on the operation of TCO-DRL, we provide a detailed explanation of its specific process using the sequence diagram shown in Fig. \ref{fig_2}.



\begin{enumerate}
    \item Data requesters complete the registration process through the registration contract. 
    \item Data requesters submit service requests for external data through the request contract.
    \item The service request triggers the invocation contract. The invocation contract transmits the service request information to the DRL-driven Model and invokes the model for processing.
    \item Based on the service request information sent by the invocation contract, along with the latest reputation and relevant status information of oracle node obtained from the reputation module and monitoring module, the DRL-driven model selects trustworthy and cost-effective oracle node to handle the data request and returns the selection result to the invocation contract.
    \item The invocation contract sends the data request to the selected oracle node based on the selection result.
    \item The selected oracle node interact with external data sources to obtain the requested data.
    \item The external data sources transmit the data to the oracle node, which then sign the data and prepare it for submission to the blockchain.
    \item The oracle node return the signed data to the verification contract. The verification contract validates the data, and upon confirmation of its validity, notifies the request contract of the successful verification.
    \item The request contract delivers the final verified data back to the data requester, completing the entire data request process. The reputation module updates the reputation score of the oracle node based on its performance in this service. The monitoring module logs all operations related to this event and continues to monitor the subsequent performance of the oracle nodes.
\end{enumerate}

\section{The Proposed Trust Management Mechanism in TCO-DRL}
In this section, we provide a detailed explanation of the trust management mechanism designed for TCO-DRL to evaluate the trustworthiness of oracle nodes. Initially, the base reputation score for each oracle node is established by considering three dimensions: reliability score, behavior score, and token score. The integration of these three factors allows for the effective identification of nodes that are not only reliable and compliant but also demonstrate a strong sense of responsibility toward the network, thereby contributing to the security and stability of the oracle system. Additionally, the final reputation score of an oracle node is derived by incorporating a time factor into the base reputation score, ensuring that the system accurately reflects the node's current performance in real-time. This approach effectively prevents trust monopolies and reduces the risk of misjudgment due to historical data, thereby enhancing the robustness and security of the entire mechanism. The notations and relevant definitions can be found in Table \ref{tab:2}.



\subsection{Reliability Score}
The reliability score directly reflects the performance of an oracle node in executing its core function—providing data. This score aggregates three key metrics: relative response frequency, success rate, and average response time. Combining these three metrics helps to mitigate uncertainties caused by deviations in a single metric, offering a more comprehensive insight into the node’s performance. Ultimately, this approach aids in distinguishing nodes capable of consistently delivering high-quality data from those that may occasionally provide incorrect or delayed information. The detailed calculation process for each metric is outlined below.

\subsubsection{Relative Response Frequency}
Relative response frequency reflects the activity level and responsiveness of an oracle within the network. A higher relative response frequency indicates that the oracle is highly available and frequently participates in processing data requests. This metric is determined by calculating the ratio of the number of times the oracle actually responds to data requests within a specific time period to the average response count of all oracles:
\begin{equation}
ORF_j(\tau_k) = N_j(\tau_k) \times \frac{M}{\sum_{m=1}^{M} N_m(\tau_k)}
\end{equation}
Where $ ORF_j(\tau_k) $ represents the relative response frequency of the oracle $j$ during the time period $\tau_k$. $ N_j(\tau_k) $ denotes the number of data requests the oracle $j$ responded to within the time period $\tau_k$. $M$ indicates the total number of oracles within the oracle community.

\subsubsection{Success Rate}
Success rate is a key metric for evaluating the accuracy and effectiveness of the data provided by an oracle. Oracles with a high success rate typically demonstrate strong data processing capabilities, consistently delivering accurate and valid data in most cases. It is calculated as the ratio of the number of data requests successfully processed by the oracle to the total number of requests it has responded to:
\begin{equation}
OSR_j(\tau_k) = \frac{\sum_{i=1}^{N} y_{i,j}(\tau_k) \cdot Osucc_{i,j}(\tau_k)}{N_j(\tau_k)}
\end{equation}
Where $ y_{i,j}(\tau_k) $ is an indicator variable, taking the value of 1 if request $i$ is assigned to oracle $j$ during time period $\tau_k$, and 0 otherwise. $Osucc_{i,j}(\tau_k)$ indicates whether request $i$ was successfully completed by oracle $j$ during time period $\tau_k$, with $Osucc_{i,j}(\tau_k)=1$ for success and $Osucc_{i,j}(\tau_k)=0$ for failure. $N_j(\tau_k)$ denotes the total number of requests processed by oracle $j$ during time period $\tau_k$.The success of processing a data request is determined using the following equation:
\begin{equation}
Osucc_{ij}(\tau_k) = \\
\begin{aligned}
\begin{cases} 
1, & \text{if } ORT_{ij}(\tau_k) \leq DDL_i \text{ and } \\ 
 & Verification_{ij} = \text{TRUE} \\
0, & \text{else}
\end{cases}
\end{aligned}
\end{equation}
Where $ORT_{ij}(\tau_k)$ represents the response time of oracle $j$ in processing data request $i$ during time period $\tau_k$. $DDL_i$ denotes the deadline for data request $i$. $Verification_{ij}$ indicates whether the data request $i$ processed by oracle $j$ has passed verification.

\subsubsection{Average Response Time}
Average response time measures the efficiency of an oracle in processing and providing data. A shorter response time indicates a faster processing speed, enabling the oracle to provide data more promptly. Selecting oracles based on average response time helps improve the overall system's responsiveness and the real-time availability of data. It is calculated using the following equation:
\begin{equation}
ORT_j(\tau_k) = \frac{\sum_{i=1}^{N} y_{i,j}(\tau_k) \cdot (TS_{finish_{ij}} - TS_{start_{ij}})}{N_j(\tau_k)}
\end{equation}
Where $TS_{finish_{ij}}$ represents the timestamp when oracle $j$ completes request $i$, and $TS_{start_{ij}}$ denotes the timestamp when request $i$ begins processing by oracle $j$. $N_j(\tau_k)$ denotes the total number of requests processed by oracle $j$ during time period $\tau_k$.

Aggregating the above three metrics results in the reliability score of oracle $j$ for time period $\tau_k$:
\begin{equation}
\begin{aligned}
\text{reliability score}_j(\tau_k) = & \omega \cdot ORF_j(\tau_k) + \varphi \cdot OSR_j(\tau_k) \\
&+ \psi \cdot \left(\frac{DDL}{ORT_j(\tau_k)}\right)
\end{aligned}
\end{equation}
Where $\omega$, $\varphi$ and $\psi$ represent the weights assigned to the relative response frequency, success rate, and average response time, respectively, with $\omega + \varphi + \psi = 1$. $DDL$ denotes the deadline for the data request, which is used to assess the efficiency level of the oracle by comparing it to the oracle’s average response time.

\begin{table}[!t]
\centering
\caption{Table of abbreviated parameters}
\label{tab:2}
\begin{tabular}{ll}
\toprule
\textbf{Symbol} & \textbf{Definition} \\
\midrule 
$ N_j(\tau_k) $ & \makecell[tl]{The number of data requests the oracle $j$ \\  responded to during time period $\tau_k$}\\
$ M $   & The total number of oracles in the oracle community \\
$ y_{i,j}(\tau_k) $ &  \makecell[tl]{Denotes whether request $i$ is assigned to oracle $j$ \\ during time period $\tau_k$} \\
$Osucc_{i,j}(\tau_k)$  &  \makecell[tl]{Denotes whether request $i$ is successfully \\ completed by oracle $j$ during time period $\tau_k$}\\
$ORT_{ij}(\tau_k)$ &  \makecell[tl]{The response time of oracle $j$ in processing \\ data request $i$ during time period $\tau_k$}\\ 
$DDL_i$ & The deadline of data request $i$\\
$Verification_{ij}$ &  \makecell[tl]{Denotes whether the data request $i$ processed \\ by oracle $j$ has passed verification}\\
$TS_{start_{ij}}$ & \makecell[tl]{The timestamp when request $i$ begins processing\\ by oracle $j$}\\
$ TS_{finish_{ij}}$ & The timestamp when oracle $j$ completes request $i$\\ 
$ ORF_j(\tau_k) $ & \makecell[tl]{The relative response frequency of the oracle $j$ \\ during time period $\tau_k$}\\
$OSR_j(\tau_k)$ & The success rate of the oracle $j$ during time period $\tau_k$\\
$ORT_j(\tau_k)$ & \makecell[tl]{The average response time of the oracle $j$\\ during time period $\tau_k$}\\
$SF$ & The harm score of safe behavior\\
$MH$ & The harm score of minor harm behavior\\ 
$MoH$ & The harm score of moderate harm behavior\\ 
$SH$  & The harm score of severe harm behavior\\ 
$n_{SF,j}(\tau_k)$ & \makecell[tl]{The number of times oracle $j$ exhibited \\ safe behavior during time period $\tau_k$}\\
$n_{MH,j}(\tau_k)$ & \makecell[tl]{The number of times oracle $j$ exhibited \\ minor harm behavior during time period $\tau_k$}\\
$n_{MoH,j}(\tau_k)$ & \makecell[tl]{The number of times oracle $j$ exhibited\\ moderate harm behavior during time period $\tau_k$}\\
$n_{SH,j}(\tau_k)$  & \makecell[tl]{The number of times oracle $j$ exhibited \\ severe harm behavior during time period $\tau_k$}\\
$\text{Token}_j(\tau_k)$ & \makecell[tl]{The number of tokens staked by oracle $j$ \\ during time period $\tau_k$}\\
$\text{Oreputation}_j(\tau_k)$ & \makecell[tl]{The final reputation score of oracle $j$ \\ during time period $\tau_k$}\\
\bottomrule
\end{tabular}
\end{table}

\subsection{Behavior Score}
The behavior score primarily evaluates the overall conduct of an oracle within the network. Oracles that exhibit good behavior are generally considered more trustworthy and contribute positively to the long-term health of the network. This score is crucial for promptly identifying oracles engaging in non-compliant or malicious activities, thereby enhancing the system's security and stability. In the design of the trust management mechanism presented in this paper, preventing deliberate malicious actions by oracles is a key objective. Therefore, if any malicious behavior is detected, the oracle's reputation score will be significantly reduced, dropping below the trust threshold, which will result in the oracle being disallowed from providing further services. Specifically, we categorize oracle behavior into four levels: Safe, Minor Harm, Moderate Harm, and Severe Harm, drawing on risk assessment models. Detailed descriptions of these levels are provided below.

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/system/Oracles_Behavior_Probabilities.pdf}
\caption{Behavioral probabilities of various oracles.}
\label{fig_3}
\end{figure}


\subsubsection{Safe}
Safe indicates that the oracle has not engaged in any behavior during its operation that could negatively impact the system or other participants. The oracle has performed well during this period, providing accurate and timely data, actively participating in the consensus process, and adhering to all established rules and protocols.
\subsubsection{Minor Harm}
Minor harm indicates that the oracle may have committed minor violations or errors under certain circumstances, which do not pose a significant threat to the system’s overall security and stability but may affect certain functionalities or service quality. Examples include data delays or localized errors caused by software defects or minor performance issues.
\subsubsection{Moderate Harm}
Moderate harm suggests that the oracle’s behavior carries certain risks, potentially affecting some system functions or causing direct economic losses or trust issues for a subset of users. Examples include frequently providing inaccurate data, occasional violations of protocols, or failing to complete critical tasks within the designated time frame.
\subsubsection{Severe Harm}
Severe harm indicates that the oracle’s actions pose a threat to the system, endangering its stability and security, potentially leading to data loss, system crashes, serious security vulnerabilities, or irreversible damage to other nodes. Examples include the provision of widespread false data to manipulate markets, executing malicious code, intentionally violating protocols, or repeated severe violations. 

Ultimately, the behavior score of oracle $j$ during time period $\tau_k$ is calculated as follows:
\begin{equation}
\begin{aligned}
\text{behavior score}_j(\tau_k) = & SF \cdot n_{SF,j}(\tau_k) + MH \cdot n_{MH,j}(\tau_k) \\
& + MoH \cdot n_{MoH,j}(\tau_k) \\
& + SH \cdot n_{SH,j}(\tau_k)
\end{aligned}
\end{equation}
Where $SF$, $MH$, $MoH$, and $SH$ represent the harm scores for the four behavior categories: safe, minor harm, moderate harm, and severe harm, respectively. $n_{SF,j}(\tau_k)$, $n_{MH,j}(\tau_k)$, $n_{MoH,j}(\tau_k)$, and $n_{SH,j}(\tau_k)$ denote the number of times oracle $j$ exhibited each of these behaviors during time period $\tau_k$. Fig. \ref{fig_3} illustrates the probabilities of different behaviors for the three types of oracles simulated in our experiment: trustworthy oracles, benign oracles, and malicious oracles.




\subsection{Token Score}
The core function of the token score is to establish an economic constraint mechanism for oracles. By requiring oracles to stake a certain amount of tokens during their participation, the cost of not following the rules or providing incorrect data is effectively increased. A higher stake means that the oracle’s actions in the system carry greater economic risk, providing a stronger incentive for the oracle to maintain good behavior and deliver accurate data, in order to protect its staked tokens from being forfeited, thereby reducing the likelihood of malicious actions. Additionally, calculating and evaluating the token score is relatively straightforward, transparent, and can be done by simply referring to the oracle's staking records. This calculation imposes no significant burden on system performance while enhancing the system's credibility. The token score is calculated as the ratio of the number of tokens staked by the oracle to the average number of tokens staked by all oracles in the community:
\begin{equation}
\text{token score}_j(\tau_k) = \text{Token}_j(\tau_k) \times \frac{M}{\sum_{m=1}^{M} \text{Token}_m(\tau_k)}
\end{equation}
Where $M$ represents the number of oracles in the community, and $\text{Token}_j(\tau_k)$ denotes the number of tokens staked by oracle $j$ during time period $\tau_k$.

By aggregating the reliability score, behavior score, and token score, the base reputation value of oracle $j$ for time period $\tau_k$ is determined as follows:
\begin{equation}
\begin{aligned}
\text{base reputation}_j(\tau_k) = & \xi \cdot \text{reliability score}_j(\tau_k) \\
& - \zeta \cdot \text{behavior score}_j(\tau_k) \\
& + \delta \cdot \text{token score}_j(\tau_k)
\end{aligned}
\end{equation}
Where $\xi$, $\zeta$, and $\delta$ are the weighting coefficients for the reliability score, behavior score, and token score, respectively, with $\xi + \zeta + \delta = 1$.

\subsection{Time Factor}
The time factor is an element used to adjust and manage the impact of time on reputation scores. By incorporating the time factor into the trust management mechanism, the system can more rapidly respond to changes in oracle behavior and promptly adjust trust relationships. This paper adopts the function $\tanh\left(\frac{1}{x}\right)$, as utilized in the work \cite{li2023td}, as the time factor for TCO-DRL. The curve of this function is well-suited for influencing reputation, allowing the system to effectively capture recent behaviors and prevent short-term misconduct from being overlooked, while also balancing historical performance to avoid letting past behavior completely dominate the current reputation score. Additionally, we introduced a weighting coefficient $\chi$ to adjust the time factor, making its variation curve better suited to the studied scenario. The final reputation score of oracle $j$ for time period $\tau_k$ is calculated as follows:
\begin{equation}
\text{Oreputation}_j(\tau_k) = \sum_{\tau_1}^{\tau_k} \tanh\left(\frac{\chi}{\tau_k}\right) \cdot \text{base reputation}_j(\tau_k)
\end{equation}




\begin{table}[!t]
\centering
\caption{The final reputation of 5 oracles after 100 time periods with different lengths of sliding time window.}
\label{tab:3}
% \resizebox{width=2.5in}{!}{
\begin{tabular}{cccccc}
\toprule
\textbf{Length} & \textbf{Oracle 0} & \textbf{Oracle 1} & \textbf{Oracle 2} & \textbf{Oracle 3} & \textbf{Oracle 4} \\
\midrule 
 1 & -0.06935 & -0.29814 & 0.20315 & 0.17370 & 0.51310 \\
 2 & -7.32857 &  0.07426 & -2.02773 & 0.33217 & 0.69670 \\
 3 & -24.38311 & 0.33590 & -0.44883 & 0.78209 & 0.87278 \\
 4 & -2.35772 & 0.46118 & -0.20747 & 1.12951 & 1.28135 \\
 \textbf{5}  & \textbf{-10.32644}  & \textbf{0.98567}  & \textbf{-0.71223}  & \textbf{1.33996}  & \textbf{2.24718} \\
 6 & -11.09053 & 1.45541 & 1.07729 & 3.58305 & 5.02434 \\ 
 7 & -67.42975 & 5.51652 & -1.39116 & 9.83602 & 12.29896 \\
 8 & -291.00294 & 14.09663 & -9.62620 & 25.88607 & 34.86167 \\
 9 & -839.47177 & 23.50501 & -49.98351 & 62.04435 & 78.97845 \\
 10 & -1802.25521 & 53.32101 & -99.06507 & 101.07012 & 144.07206 \\
\bottomrule
\end{tabular}
% }
\end{table}

It is important to note that we use a sliding time window approach to store and calculate reputation scores. However, after testing, we found that the standard sliding time window approach is not well-suited for blockchain systems, leading us to make specific modifications.
\begin{itemize}
    \item Problem: Typically, a sliding time window records only the reputation of the oracle as assessed within that specific time period, with each window being independent and unconnected to others. The issue with this design is that if the sliding time window is short, the impact of malicious behavior on the oracle's reputation quickly dissipates, allowing a malicious oracle to easily regain the system's trust. On the other hand, extending the length of the sliding time window adds additional computational burden to the already resource-constrained blockchain network, thereby increasing system latency.
    \item Solution: Based on the considerations above, we record not just the independent reputation score within each time window, but rather a composite reputation score that incorporates the time factor and combines values from other time windows. This approach allows for a shorter sliding time window, reducing the need for maintaining extensive historical records and thus decreasing the computational burden on the blockchain system. At the same time, it extends the impact of malicious behavior on an oracle's reputation, ensuring that an oracle that has committed wrongdoing will require a significantly longer period before it can rejoin the community and continue providing services. The experimental results in Section VI demonstrate the effectiveness and reliability of our improvements.
\end{itemize}
We determined the appropriate length of the sliding time window used in TCO-DRL through experimentation. As shown in the Table \ref{tab:3}, we tested the final reputation values of 5 oracles after 100 time periods with different lengths of sliding time windows. The results indicate that if the sliding time window is too short, it can still differentiate between malicious and trusted oracles, but the distinction between different trusted oracles becomes less clear. Additionally, if the sliding time window is too long, it results in excessive accumulation of reputation scores, leading to exponential growth. Ultimately, we set the length of the sliding time window to 5.


\section{Trust and Cost-Aware Oracle Node Selection Algorithm in TCO-DRL}
In this section, we provide a detailed explanation of the specific algorithmic process implemented in TCO-DRL for selecting trustworthy and cost-effective oracles. We begin by introducing the underlying algorithm employed in our model—the Deep Q-Network (DQN). Next, we describe the DRL modeling of the problem. Finally, we present the specific process for dynamically selecting oracles based on DQN.
\subsection{Deep Q-Network}
Deep Q-Network (DQN) is a deep reinforcement learning algorithm that builds upon Q-Learning. Q-Learning \cite{watkins1992q} works by iteratively updating a function known as the Q-value, $Q(s, a)$, to learn the long-term rewards associated with taking a specific action $a$ in a given state $s$. However, traditional Q-Learning relies on a Q-table to store the Q-values for all state-action pairs, which becomes impractical in high-dimensional state spaces, as the size of the Q-table increases exponentially with the complexity of the state and action spaces. To address these limitations, DQN introduces several key improvements \cite{mnih2015human}, including the following:
\begin{itemize}
    \item Approximating the Q-Value Function Using DNNs: The core idea of DQN is to enhance Q-Learning by introducing Deep Neural Networks (DNNs) to approximate the Q-value function, which predicts the Q-values for state-action pairs. This approach addresses the issue of traditional Q-Learning being ineffective in high-dimensional state spaces.
    \item Experience Replay: DQN stores the state transitions experienced by the agent in a replay memory, from which it randomly samples small batches of data for training. This process breaks the correlation between data points, stabilizes the training process, and enhances data efficiency.
    \item Target Network: DQN employs two neural networks to stabilize the training process. One is the evaluation network, which is used for actual Q-value updates, and the other is the target network, which is used to calculate the target values for Q-value updates. The parameters of the target network are periodically copied from the evaluation network to reduce training instability.
\end{itemize}

\subsection{DRL Model Formulation}
Before introducing the specifics of DRL modeling, we first define the characteristics of data requests and oracles. Suppose there are $N$ data requests, denoted as $Request_1$, $Request_2$, ..., $Request_N$. For a data request $Request_i$, $ i \in \{{1, 2,..., N}\} $, it can be modeled by the following characteristics:
\begin{equation}
\begin{aligned}
\text{Request}_i = \{ & \text{RID}_i, \text{RarrivalTS}_{i,j}, \text{DDL}_i, \\
                    & \text{Rcomplexity}_i, \text{Rservice}_i \}
\end{aligned}
\end{equation}
Where $\text{RID}_i$ represents the unique ID that identifies data request $Request_i$. $\text{RarrivalTS}_{i,j}$ denotes the timestamp when data request $Request_i$ reaches oracle $j$. $\text{DDL}_i$ indicates the allowed deadline for $Request_i$, and $\text{Rcomplexity}_i$ represents the complexity of $Request_i$. $\text{Rservice}_i$ refers to some additional service requirements for $Request_i$, such as data update frequency and data accuracy.

Similarly, suppose there are $M$ oracles in the oracle community, denoted as $Oracle_1$, $Oracle_2$, ..., $Oracle_M$. The $Oracle_j$, $ j \in \{{1, 2,..., M}\} $ can be expressed as the following characteristics:

\begin{equation}
\begin{aligned}
\text{Oracle}_j = \{ & \text{OID}_j, \text{Oreputation}_j, \text{Ocost}_j, \\
                    & \text{Operformance}_j, \text{Oservice}_j \}
\end{aligned}
\end{equation}
Where $\text{OID}_j$ represents the unique ID that identifies $Oracle_j$, $\text{Oreputation}_j$ denotes the reputation score of $Oracle_j$. $\text{Ocost}_j$ indicates the cost per request for $Oracle_j$, $\text{Operformance}_j$ represents the processing capability of $Oracle_j$ for handling data requests, and $\text{Oservice}_j$ refers to the services that $Oracle_j$ can provide.

\subsubsection{State Space}
The state space represents the complete set of all possible conditions that an agent can perceive in its environment. Each state captures a snapshot of the environment at a specific moment, encompassing all the information necessary for the agent to make decisions. In TCO-DRL, the state space consists of the states of both data requests and oracles, denoted as $S = [S_{Request} \cup S_{Oracle}] $.
\subsubsection{Action Space}
The action space refers to the set of all possible actions an agent can choose from in any given state. Since the action in TCO-DRL involves selecting an oracle from the oracle community to provide service, the action space is defined as the set of oracles, i,e., $A = [OID_1, OID_2, \ldots, OID_M]$.
\subsubsection{Reward Function}
The reward function is the feedback signal received by the agent after interacting with the environment, indicating the quality of an action taken and guiding the agent in learning the optimal policy. The reward function designed in TCO-DRL is as follows:
\begin{equation}
\begin{aligned}
R &= \left(1 + \vartheta \cdot e^{\lambda - cost_j}\right) 
\left(\frac{exeT_{ij}}{responseT_{ij}}\right) \\
&\quad + Oreputation_j - \mu \cdot penalty_{ij}
\end{aligned}
\end{equation}

Where the conditions for the value of variable $penalty_{ij}$ are as follows:
\begin{equation}
penalty_{ij} = 
\begin{cases} 
0, & \text{if } Rservice_i = Oservice_j \\ 
1, & \text{else} 
\end{cases}
\end{equation}

In summary, the reward is directly proportional to the reputation $Oreputation_j$ of oracle $j$ and inversely proportional to the cost $cost_j$ of oracle $j$, guiding the agent to select oracles with high reputation and low cost to handle data requests. The reward function also encourages the service $Oservice_j$ provided by oracle $j$ to align closely with the additional service requirement $ Rservice_i $ of data request $i$, with mismatches resulting in penalty $penalty_{ij}$. Furthermore, to reduce the waiting time for data requests in queue and improve service quality, we also incorporate the proportion of the request execution time in the total response time into the reward function. The $\vartheta$, $\lambda$, and $\mu$ are the weighting coefficients for adjusting the influence of $\frac{exeT_{ij}}{responseT_{ij}}$, $cost_j$, and $penalty_{ij}$, respectively.

\subsection{Dynamic Oracle Node Selection Based on DQN}
Next, we provide a detailed explanation of the specific process for dynamically selecting oracles based on the DQN algorithm, including both the training phase and the execution phase. Fig. \ref{fig_4} visually illustrates the selection process.
\subsubsection{Initialize the DQN Model} We begin by initializing an evaluation network to approximate the Q-value function $Q(s, a; \theta)$, where $s$ represents the state, $a$ represents the action, and $\theta$ denotes the network parameters. We set the parameters for the evaluation network, including the exploration rate $\epsilon$, the learning rate $ \alpha $, and the discount factor $ \gamma $. Next, we initialize the target network, which has the same structure as the evaluation network, and establish the update frequency for the target network.
\subsubsection{Establish the Experience Replay Mechanism}
Initialize a replay memory to store experience samples $(S_t, A_t, R_t, S_{t+1})$ generated during the agent's interaction with the environment. These samples consist of the current state $S_t$, the action $A_t$ taken, the reward $R_t$ received, and the next state $S_{t+1}$ reached after performing the action.
\subsubsection{Dynamic Oracle Node Selection}
\begin{itemize}
    \item Execute Action and Update Strategy: At each time step $t$, an action $A_t$ is chosen based on the current state $S_t$ using the $\epsilon-greedy$ strategy. Specifically, with a probability of $1- \epsilon$, the action that maximizes Q-value is selected, which corresponds to choosing the oracle with the highest expected reward. With a probability of $\epsilon$, an action is randomly selected to explore new potential optimal strategies. The chosen action $A_t$ (selecting an oracle) is then executed, an immediate reward $R_t$ is received, and the next state $S_{t+1}$ is observed.
    \item Experience Replay and Learning: The current experience is stored in the replay memory. Then, updates are performed using experience replay: a small batch of samples $(S_k, A_k, R_k, S_{k+1})$ is randomly drawn from the replay memory for training. The target Q-value ${target}_k$ is calculated as follows:
    \begin{equation}
    {target}_k = r_k + {\gamma}\operatorname{max}_{A^{\prime}} {\hat{Q}}\left(S_{k + 1}; A^{\prime}; {\theta}^{\prime}\right)
    \end{equation}
    Where $\hat{Q}$, ${\theta}^{\prime}$ represent the output and parameter of the target network, respectively.  
    Next update the parameter $\theta$ of the evaluation network by minimizing the loss function:
    \begin{equation}
    \mathcal{L}(\theta) = \mathbb{E} \left[ \left( {target}_k - Q(S_k, A_k; \theta) \right)^2 \right]
    \end{equation}
    \item Update Target Network: Every fixed number of steps, copy the parameter $\theta$ of the evaluation network to the parameter ${\theta}^{\prime}$ of the target network:
    \begin{equation}
        \theta^{\prime} \leftarrow \theta
    \end{equation}
\end{itemize}
\subsubsection{Iterative Training Process}
The algorithm repeatedly executes step 3) until the defined stopping condition is reached, such as achieving a certain level of convergence or reaching a specified number of training iterations.

\begin{algorithm}[!t]   
  \caption{Dynamic Oracle Node Selection Algorithm in TCO-DRL Based on DQN}  
  \label{alg:1}  
  \begin{algorithmic}[1]  
    \State \textbf{Input:} initial $ \epsilon $, $ \alpha $, $ \gamma $, learning frequency $ f $, minibatch $ S_{\Delta} $, replay period $ \eta $
    \State Initialize replay memory $ \Delta $ with capacity $ N_{\Delta} $
    \State Initialize evaluation value function $ Q $ with random parameters $ \theta $
    \State Initialize target value function $ \hat{Q} $ with random parameters $ {\theta}^{\prime} $
     \For{each new request $ i $ arrives at $ t $}
     \State with probability $ \epsilon $, randomly choose an action; otherwise $ A_t=\operatorname{argmax}_A Q\left(S_t ; A ; \theta\right) $
     \State Dispatch request $ i $ according to action $ A_t $, receive reward $ R_t $, and observe state transition at next decision time $ t+1 $ with a new state $ S_{t+1} $
     \State Store transition $\left(S_t, A_{t}, R_{t}, S_{t+1}\right) $ in $ \Delta $
      \If {$ j $ $\geq$ $ t $ {and} $ t $ $ \equiv $ 0 mod $ f $}  
		\If {$ j $ $ \equiv $ 0 mod $ \eta $}
     	   \State Reset $ {\hat{Q}} = {Q} $
             \EndIf
             \State randomly select samples $ S_{\Delta} $ from $ N_{\Delta} $
             \For{each transition $\left(S_k, A_{k}, R_{k}, S_{k+1}\right) $ in $ S_{\Delta} $ }
                \State $ {target}_k = r_k + {\gamma}\operatorname{max}_{A^{\prime}} {\hat{Q}}\left(S_{k + 1}; A^{\prime}; {\theta}^{\prime}\right)$
                \State update DNN parameters $\theta$ with loss function
  			 \EndFor
            \State Gradually decrease $\epsilon$ until to the lower bound
		\EndIf   
  	\EndFor \\
        \Return action $ A_i $
  \end{algorithmic}  
\end{algorithm}

\subsubsection{Optimal Oracle Selection Strategy}
\begin{itemize}
    \item Policy Evaluation and Improvement: The training process of the DQN is represented by the dark blue lines in the Fig. \ref{fig_4}. After training is completed, the agent, using the learned Q-network, can select the optimal oracle in a given state to maximize cumulative rewards.
    \item Policy Implementation: The actual execution process of the DQN is represented by the red lines in the Fig. \ref{fig_4}. By applying the learned policy to the real-world oracle selection task, it is possible to dynamically choose the most suitable oracle based on real-time state information, such as the current reputation and cost of the oracles.
\end{itemize}
The overall training and execution process of the algorithm is summarized in Algorithm \ref{alg:1}.


\begin{figure*}[!t]
\centering
\includegraphics[width=0.9\textwidth]{bibtex/figure/system/DRL_model.pdf}
\caption{Oracle node selection process based on DQN.}
\label{fig_4}
\end{figure*}




\section{Simulation Results and Evaluations}
In this section, we provide a detailed analysis of the experimental design and evaluation results. We begin by describing the configuration of the experimental platform, the baseline methods for comparison and the simulated attacks. Next, we compare the robustness and performance of TCO-DRL with other baseline methods in environments with noise and progressively worsening conditions. Finally, we deploy TCO-DRL on blockchain and simulate three classic attacks to test its effectiveness.
\subsection{Simulation Settings}
\subsubsection{Platform Settings}
As described in the work \cite{taghavi2023reinforcement}, there is currently no available blockchain oracle dataset. The study work \cite{taghavi2023reinforcement} used synthetic data for experiments, and we have referenced its data on cost distribution. Additionally, based on the work \cite{taghavi2023reinforcement}, we have adjusted the parameters of the experimental data to closely match the real-world operation of oracle communities. Specifically, we designed the complexity of data requests and the performance metrics of oracles based on the average response time of data requests in BandChain \cite{bandprotocol}, making it to 6 seconds to align with BandChain's average. The arrival time of data requests follows a Poisson distribution. Regarding the pricing model, we adopted a fixed-rate pricing strategy, similar to most oracle communities, where a fixed fee is charged for each transaction or request.

The experiment simulated an oracle community consisting of 15 oracles, categorized into three types based on the service requests they can handle (e.g., data update frequency), with five oracles of each type. A total of 6,000 data requests were generated. The oracle community was simulated using Python, with configurations of Python 3.6 and TensorFlow 2.0.0. We set up a blockchain network using Ethereum on Ubuntu 18.04 and deployed and tested the smart contracts using the Truffle framework. All experiments were conducted on a host equipped with a 2.5 GHz Intel Core i5-7300HQ CPU and 8 GB RAM. The specific experimental parameters are shown in the Table \ref{tab:4}.

\begin{table}[!t]
\centering
\caption{SYSTEM SIMULATION PARAMETERS}
\label{tab:4}
\begin{tabular}{ll}
\toprule
\textbf{Parameter} & \textbf{Value} \\
\midrule
Capacity of reply memory $ N_{\Delta} $ & 800 \\
Capacity of minibatch $ S_{\Delta} $ & 30\\
Learning rate $ \alpha $ & 0.01 \\
Discount factor $ \gamma $ & 0.9 \\
Number of oracles & 15 \\
Number of data requests & 6000 \\
Data requests complexity & ${\mathcal N} \left(6000, 500\right) $  \\
Length of the sliding time window & 5\\
Initial reputation value & 0.5\\
Trust threshold & -1.5\\
Weights of calculating reliability score &  \makecell[tl]{$\omega$ = 0.2 $\varphi$ = 0.4 \\$\psi$ = 0.4} \\
The harm scores for the four behavior categories & \{0,1,5,100\} \\
Weights of calculating base reputation score & \makecell[tl]{$\xi$ = 0.4 $\zeta$ = 0.4 \\$\delta$ = 0.2}\\
Weight of time factor $\chi$ & 0.6 \\
Weights of calculating reward & \makecell[tl]{$\vartheta$ = 2.5 $\lambda$ = 1.5 \\ $\mu$ = 4}\\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Baseline Methods}
TCO-DRL was experimentally compared with a classic baseline method, Round-Robin, as well as two recent baseline methods: BLOR and PSG.
\paragraph{Round-Robin \cite{rasmussen2008round}}
Round-Robin is a commonly used allocation algorithm that is simple and easy to implement, primarily designed for the fair distribution of resources. This method assigns requests in a fixed order, ensuring that each oracle node has an equal opportunity to provide services.
\paragraph{BLOR \cite{taghavi2023reinforcement}}
BLOR is a method that uses a reinforcement learning approach called Bayesian Multi-Armed Bandit algorithm to intelligently select oracle nodes. It is the first smart mechanism specifically designed for oracle node selection and serves as one of the main baseline methods for our comparison. BLOR aims to optimize both the cost and reputation of the oracles. It is important to note that BLOR evaluates reputation based on the number of successful and failed requests handled by the oracles. The original study generated the corresponding historical records through simulation, but we did not have access to such data. To address this initialization issue for BLOR, we employed Round-Robin to fairly assign data requests during the initial training phase (for a short period) to generate historical records for the oracles.
\paragraph{PSG \cite{azizi2022deadline}}
PSG is a semi-greedy method originally used for task scheduling in the previous work. Essentially, it is a decision optimization method, so we have applied and implemented its concept in the selection of oracle nodes. First, we filter out all oracles that would receive a reward greater than zero after executing a specific data request. Then, we sort these oracles in ascending order based on cost, and finally, a random oracle is selected from the top $q$ oracles to handle the data request.

\subsubsection{Simulated Attacks}
We referred to the work \cite{marche2020trust} to simulate three common trust-related attacks for IoT.
\paragraph{Malicious With Everyone (ME)}
Malicious nodes exhibit harmful behavior towards all requesters. This is a basic type of attack where the node always provides low-quality service and unreliable recommendations, regardless of who the requester is.
\paragraph{On-Off Attack (OOA)}
Nodes periodically switch their behavior between honest (on) and malicious (off) states. In the honest phase, the node establishes trust, while in the malicious phase, it exploits this trust to launch attacks.
\paragraph{Opportunistic Service Attack (OSA)}
Malicious nodes provide high-quality service only when they notice their trust reputation declining. This strategy aims to maintain a satisfactory trust level, ensuring the node still has opportunities to provide services.

\subsection{Performance Comparison}
We classify oracles based on their behavior into three categories: trusted oracles, benign oracles, and malicious oracles. Trusted oracles are capable of providing high-quality and reliable services over the long term. Benign oracles are generally honest and reliable but may occasionally make mistakes, with performance and data quality that are not as high as those of trusted oracles. Malicious oracles intentionally provide false or misleading data to manipulate the system or harm other participants. In our community setup, we included three malicious oracles and three benign oracles, with the remaining oracles being trusted. It should be noted that, to better test the robustness of methods, we did not set a trust threshold for oracles in the comparative experiments. This means that even if an oracle engages in malicious behavior, causing its reputation value to fall below the trust threshold, it can still be selected to provide services. This design enables us to evaluate the performance of each method under the influence of persistent malicious behavior by oracles. Fig. \ref{fig_5} shows the convergence of TCO-DRL, with the model reaching convergence after approximately 2,000 training steps.
\begin{figure}[!t]
\centering
\includegraphics[width=3in]{bibtex/figure/experiment/Convergence_Performance_of_TCO-DRL.pdf}
\caption{Convergence performance of TCO-DRL.}
\label{fig_5}
\end{figure}

Fig. \ref{fig_6} shows the matching results of different methods for assigning requests to oracles. TCO-DRL has a significant advantage, successfully matching the services required by most requests (87.5\%) with those provided by the oracles. In contrast, Round-Robin assigns requests in a fixed order, resulting in completely random matches. BLOR shows poorer matching results because its source code does not provide corresponding optimization objectives. PSG performs better than Round-Robin and BLOR since it filters oracles with a reward value greater than zero. However, because the reward function emphasizes reputation and cost, PSG is limited when faced with more than two optimization objectives, resulting in a significantly lower matching rate compared to TCO-DRL.
\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Match_rate.pdf}
\caption{Match rate comparison of different methods.}
\label{fig_6}
\end{figure}

 Fig. \ref{fig_7} shows the distribution of data requests assigned to oracles with different behaviors using various methods. It is evident that TCO-DRL significantly reduces the number of requests assigned to malicious oracles: only 4.28\% of requests are assigned to malicious oracles with TCO-DRL, which is a reduction of 39.10\% to 78.58\% compared to other methods. This indicates that TCO-DRL excels at identifying and avoiding malicious oracles, effectively reducing the interference of malicious nodes in the system. Additionally, the proportion of requests allocated to trusted oracles by TCO-DRL is as high as 90.40\%, which is an increase of 15.27\% to 33.63\% over other methods. Moreover, the number of requests assigned to benign oracles by TCO-DRL is noticeably lower than that by other methods. These results indicate TCO-DRL's sensitivity to oracle reputation values and its tendency to prioritize selecting oracles with good behavior—even though benign oracles have a higher reputation than malicious ones and are a reasonable choice, TCO-DRL always strives to allocate requests to oracles with a highest reputation.

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Number_of_Data_Requests_Assigned_to_Various_Oracles.pdf}
\caption{Distribution of data requests assigned to various oracles using different methods.}
\label{fig_7}
\end{figure}

We then tested the performance of the four methods in noisy environments. Noise refers to situations where the behavior of oracles does not occur as expected. Fig. \ref{fig_8} shows the average response time of different methods as noise increases. It can be observed that the average response time for all methods increases with the increase in noise. Round-Robin has a relatively lower average response time because its algorithm is simple and straightforward, allowing for quicker decision-making. TCO-DRL and PSG show relatively good average response times across all noise percentages, with more stable variations, indicating better robustness. BLOR has the longest average response time, possibly because it always selects oracles with high reputation scores and low costs, leading to increased waiting times for data requests and thus raising the average response time.

Next, we examined how the cost changes with noise for different methods, as shown in Fig. \ref{fig_9}. It can be seen that the costs for Round-Robin, TCO-DRL, and PSG remain stable, suggesting strong resistance to noise interference. In contrast, the cost for the BLOR method varies significantly with noise, indicating a higher sensitivity to noise. The reason for the less noticeable cost variation curve in Round-Robin is the fixed-rate pricing model and its fixed order for request allocation. TCO-DRL and PSG exhibit more stable cost changes because their algorithms are better adapted to environmental changes, providing greater robustness. BLOR's poorer performance might be due to greater interference from noise in its decision-making process, a result consistent with the findings in the work \cite{taghavi2023reinforcement}.

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Response_time_Noise_Percentage1.pdf}
\caption{Average response time comparison of different methods against noise observations.}
\label{fig_8}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Cost_Noise_Percentage.pdf}
\caption{Cost comparison of different methods against noise observations.}
\label{fig_9}
\end{figure}

Finally, we tested the robustness of the four methods in increasingly adverse environments. Each time, we randomly selected one oracle from the remaining benign and trusted oracles to turn it into a malicious oracle, and we analyzed the changes in cost and the distribution of data requests for each method. Fig. \ref{fig_10} illustrates the cost variations across different methods. When there are three malicious oracles in the community, the average costs for Round-Robin, BLOR, and PSG are 0.540, 0.518, and 0.450, respectively, while TCO-DRL achieves a significantly lower average cost of 0.396, reducing costs by 12.00\% to 26.67\% compared to the other methods. This demonstrates that TCO-DRL is more effective at selecting low-cost oracles. As the number of malicious oracles in the community increases, the costs for TCO-DRL, BLOR, and PSG also rise. This is because all three algorithms strive to select oracles with high reputation values to handle data requests, but oracles with higher reputation values typically incur higher costs, thereby increasing the average cost. Notably, even when the number of malicious oracles in the community reaches nine (more than half of the total), TCO-DRL maintains a cost of 0.528, still below the overall average cost of 0.54 for all oracles. This indicates that TCO-DRL has a significant advantage in optimizing average costs.

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Cost_malicious_number.pdf}
\caption{Cost comparison of different methods with increasing malicious oracles.}
\label{fig_10}
\end{figure}

Fig. \ref{fig_11} depicts the changes in the number of data requests assigned to malicious oracles by each method. As the number of malicious oracles increases, the number of data requests assigned to them by all methods also rises. When the number of malicious oracles reaches nine, BLOR and PSG assign 1,342 and 1,118 requests, respectively, far below the theoretical average of 3,600, indicating their effectiveness in selecting trusted oracles. TCO-DRL assigns only 852 requests to malicious oracles, reducing the number by 23.79\% to 76.33\% compared to the other three methods, demonstrating superior capability in identifying malicious oracles and adapting to different environments. Additionally, Fig. \ref{fig_12} shows the number of requests assigned to benign and trusted oracles by each method. Compared to the other three methods, TCO-DRL not only assigns the highest total number of requests to benign and trusted oracles but also has the smallest proportion of requests assigned to benign oracles, ranging from 3.77\% to 6.74\%. In contrast, the proportions for Round-Robin, BLOR, and PSG are 16.66\% to 30.00\%, 9.62\% to 18.84\%, and 9.46\% to 24.86\%, respectively. This indicates that TCO-DRL not only has a finer ability to differentiate between nodes but also shows more stable variations than the other three methods, demonstrating stronger robustness.

In summary, the experiments demonstrate TCO-DRL's clear advantages in selecting trusted and cost-effective oracles, while also showing strong resistance to interference and robustness.

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Number_of_Data_Requests_Assigned_to_Malicious_Oracles.pdf}
\caption{Comparison of data requests assigned to malicious oracles with increasing malicious oracles.}
\label{fig_11}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Number_of_Data_Requests_Assigned_to_Benign_and_Trusted_Oracles.pdf}
\caption{Comparison of data requests assigned to benign and trusted oracles with increasing malicious oracles.}
\label{fig_12}
\end{figure}

\subsection{Effectiveness Analysis}
In this part of the experiment, we deployed TCO-DRL on Ethereum to test its performance and resistance to attacks. 
Fig. \ref{fig_13} shows the changes in total latency and average latency of TCO-DRL. Here, latency refers to the time required from initiating a transaction to receiving a transaction receipt, i.e., the time needed for transaction confirmation. As the number of requests increases, the system latency fluctuates but generally remains stable, with the average latency consistently below 0.2 seconds. We then tested the average gas consumption for contract invocations and the average CPU usage of TCO-DRL, as shown in Fig. \ref{fig_14}. As the number of data requests increases, the average gas consumption remains stable and consistently low. This is due to the hybrid on-chain and off-chain execution architecture, which moves complex computation off-chain, thereby avoiding additional gas costs associated with code complexity. Additionally, the CPU usage, which stays around 20\%, demonstrates that the algorithm can effectively handle more data requests without significantly increasing resource consumption.

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Total_and_average_latency.pdf}
\caption{Total and average latency with increasing data requests.}
\label{fig_13}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/Gas_and_CPU_usage.pdf}
\caption{Gas consumption and CPU usage with increasing data requests.}
\label{fig_14}
\end{figure}

We then evaluated the performance of TCO-DRL when facing three simulated attacks. It is important to note that in this part of the experiment, we set a trust threshold: oracles with a reputation value below this threshold will not be allowed to provide services until their reputation recovers above the threshold. Our trust management scheme permits an oracle to commit up to one instance of moderate harm, so we set the trust threshold at -1.5.

We first tested TCO-DRL's resistance to the malicious with everyone (ME) attack. As shown in Fig. \ref{fig_15}, our trust management scheme can clearly differentiate between the types of oracles based on their reputation values, indicating its effectiveness in accurately capturing each oracle's behavior and mapping it to a reputation score. Once a malicious node initiates an ME attack, its reputation value rapidly declines below the trust threshold, resulting in it being prohibited from providing services. The recovery of its reputation is a slow process, effectively preventing the malicious node from launching further ME attacks.



Next, Fig. \ref{fig_16} demonstrates TCO-DRL's superiority in defending against the on-off attack (OOA). We applied the improved sliding time window to TCO-DRL and compared it with the standard sliding time window. At time period 3, an OOA was initiated. With the standard sliding time window of the same length, the reputation value of the malicious oracle recovered above the trust threshold by time period 8, after just 5 periods, allowing it to continue providing services. In contrast, TCO-DRL makes it difficult for malicious oracles to escape the effects of their harmful actions, making the recovery of trust more challenging. It takes until time period 32 for the reputation to reach above the trust threshold, during which time a malicious node could have committed several malicious actions with the standard sliding time window. Compared to a standard sliding time window of the same length, TCO-DRL extends the reputation recovery period for nodes launching OOAs by 580\%, significantly increasing the time cost of OOAs and effectively reducing their ability to cause harm.

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/ME_Attack.pdf}
\caption{Change in reputation value under malicious with everyone attack.}
\label{fig_15}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/On-Off_Attack.pdf}
\caption{Change in reputation value under on-off attack.}
\label{fig_16}
\end{figure}


Finally, we tested TCO-DRL's ability to defend against Opportunistic service attack (OSA). Fig. \ref{fig_17} shows the changes in the reputation values of oracles that could launch OSA compared to those of trusted oracles. In TCO-DRL, once a malicious oracle engages in harmful behavior, its reputation value immediately undergoes a significant decline. Conversely, attempting to quickly boost reputation through short-term positive service is not feasible. In our scheme, maintaining a high reputation requires consistently following the rules and continuously providing high-quality service. 
Although oracles that engage in OSA may still maintain a reputation value above the trust threshold, achieving the reputation level of a trusted oracle requires continuously providing high-quality service. During this process, even minor permissible errors (such as delays caused by network fluctuations) can significantly slow down the growth of their reputation. However, such errors, like network fluctuations, are unavoidable. As shown in Fig. \ref{fig_17}, even after 50 time periods following an OSA, the reputation value of the attacking oracle remains lower than that of a trusted oracle. Fifty time periods is the total number of periods we set, during which 3,000 data requests can be processed. Therefore, if an oracle launches an OSA even once, its reputation will remain lower than that of a trusted oracle throughout the entire service process.
Fig. \ref{fig_18} shows the probability of data request assignments to oracles with OSA and trusted oracles over the corresponding time periods. When an OSA attack is launched at time period 3, there is a significant change in the oracle's reputation value. During the remaining time periods, the reputation values of oracles with OSA are significantly lower than those of trusted oracles, resulting in a very low probability of these oracles being selected to provide services throughout the service process, greatly increasing the difficulty of malicious behavior. This demonstrates TCO-DRL's effectiveness in defending against OSA.
\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/OSA_reputation.pdf}
\caption{Change in reputation value under opportunistic service attack.}
\label{fig_17}
\end{figure}

\begin{figure}[!t]
\centering
\includegraphics[width=2.5in]{bibtex/figure/experiment/OSA_selection_probability.pdf}
\caption{Change in selection probability under opportunistic service attack.}
\label{fig_18}
\end{figure}

% An example of a floating figure using the graphicx package.
% Note that \label must occur AFTER (or within) \caption.
% For figures, \caption should occur after the \includegraphics.
% Note that IEEEtran v1.7 and later has special internal code that
% is designed to preserve the operation of \label within \caption
% even when the captionsoff option is in effect. However, because
% of issues like this, it may be the safest practice to put all your
% \label just after \caption rather than within \caption{}.
%
% Reminder: the "draftcls" or "draftclsnofoot", not "draft", class
% option should be used if it is desired that the figures are to be
% displayed while in draft mode.
%
%\begin{figure}[!t]
%\centering
%\includegraphics[width=2.5in]{myfigure}
% where an .eps filename suffix will be assumed under latex, 
% and a .pdf suffix will be assumed for pdflatex; or what has been declared
% via \DeclareGraphicsExtensions.
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure}

% Note that the IEEE typically puts floats only at the top, even when this
% results in a large percentage of a column being occupied by floats.


% An example of a double column floating figure using two subfigures.
% (The subfig.sty package must be loaded for this to work.)
% The subfigure \label commands are set within each subfloat command,
% and the \label for the overall figure must come after \caption.
% \hfil is used as a separator to get equal spacing.
% Watch out that the combined width of all the subfigures on a 
% line do not exceed the text width or a line break will occur.
%
%\begin{figure*}[!t]
%\centering
%\subfloat[Case I]{\includegraphics[width=2.5in]{box}%
%\label{fig_first_case}}
%\hfil
%\subfloat[Case II]{\includegraphics[width=2.5in]{box}%
%\label{fig_second_case}}
%\caption{Simulation results for the network.}
%\label{fig_sim}
%\end{figure*}
%
% Note that often IEEE papers with subfigures do not employ subfigure
% captions (using the optional argument to \subfloat[]), but instead will
% reference/describe all of them (a), (b), etc., within the main caption.
% Be aware that for subfig.sty to generate the (a), (b), etc., subfigure
% labels, the optional argument to \subfloat must be present. If a
% subcaption is not desired, just leave its contents blank,
% e.g., \subfloat[].


% An example of a floating table. Note that, for IEEE style tables, the
% \caption command should come BEFORE the table and, given that table
% captions serve much like titles, are usually capitalized except for words
% such as a, an, and, as, at, but, by, for, in, nor, of, on, or, the, to
% and up, which are usually not capitalized unless they are the first or
% last word of the caption. Table text will default to \footnotesize as
% the IEEE normally uses this smaller font for tables.
% The \label must come after \caption as always.
%
%\begin{table}[!t]
%% increase table row spacing, adjust to taste
%\renewcommand{\arraystretch}{1.3}
% if using array.sty, it might be a good idea to tweak the value of
% \extrarowheight as needed to properly center the text within the cells
%\caption{An Example of a Table}
%\label{table_example}
%\centering
%% Some packages, such as MDW tools, offer better commands for making tables
%% than the plain LaTeX2e tabular which is used here.
%\begin{tabular}{|c||c|}
%\hline
%One & Two\\
%\hline
%Three & Four\\
%\hline
%\end{tabular}
%\end{table}


% Note that the IEEE does not put floats in the very first column
% - or typically anywhere on the first page for that matter. Also,
% in-text middle ("here") positioning is typically not used, but it
% is allowed and encouraged for Computer Society conferences (but
% not Computer Society journals). Most IEEE journals/conferences use
% top floats exclusively. 
% Note that, LaTeX2e, unlike IEEE journals/conferences, places
% footnotes above bottom floats. This can be corrected via the
% \fnbelowfloat command of the stfloats package.




\section{Conclusion}
This paper proposes a blockchain oracle trust-aware and cost-optimized model named TCO-DRL to address the trust issues related to blockchain oracles and the challenge of intelligently selecting oracles in complex, dynamic environments. TCO-DRL provides a comprehensive trust management scheme that evaluates oracle reputation from multiple dimensions. Additionally, TCO-DRL incorporates an improved sliding time window, which not only reduces storage overhead but also significantly weakens the ability of malicious nodes to persistently carry out harmful actions. Based on the DQN algorithm, TCO-DRL effectively identifies malicious oracles and intelligently selects trustworthy and cost-efficient oracles to provide services. Experimental results show that, compared to existing solutions, TCO-DRL significantly reduces the number of data requests allocated to malicious oracles and effectively lowers the average cost. Moreover, TCO-DRL demonstrates strong robustness and resistance against noise and deteriorating environments. By simulating three typical IoT trust-related attacks, TCO-DRL’s effectiveness and strong resilience against attacks were further validated. Future work will focus on introducing incentive mechanisms into the trust management system to encourage oracle nodes to consistently provide reliable services. Additionally, response time will be considered as a key optimization objective to further improve system efficiency and promote multi-objective optimization.





% if have a single appendix:
%\appendix[Proof of the Zonklar Equations]
% or
%\appendix  % for no appendix heading
% do not use \section anymore after \appendix, only \section*
% is possibly needed

% use appendices with more than one appendix
% then use \section to start each appendix
% you must declare a \section before using any
% \subsection or using \label (\appendices by itself
% starts a section numbered zero.)
%


% \appendices
% \section{Proof of the First Zonklar Equation}
% Appendix one text goes here.

% % you can choose not to have a title for an appendix
% % if you want by leaving the argument blank
% \section{}
% Appendix two text goes here.


% % use section* for acknowledgment
% \section*{Acknowledgment}


% The authors would like to thank...


% % Can use something like this to put references on a page
% % by themselves when using endfloat and the captionsoff option.
% \ifCLASSOPTIONcaptionsoff
%   \newpage
% \fi



% trigger a \newpage just before the given reference
% number - used to balance the columns on the last page
% adjust value as needed - may need to be readjusted if
% the document is modified later
%\IEEEtriggeratref{8}
% The "triggered" command can be changed if desired:
%\IEEEtriggercmd{\enlargethispage{-5in}}

% references section

% can use a bibliography generated by BibTeX as a .bbl file
% BibTeX documentation can be easily obtained at:
% http://mirror.ctan.org/biblio/bibtex/contrib/doc/
% The IEEEtran BibTeX style support page is at:
% http://www.michaelshell.org/tex/ieeetran/bibtex/
%\bibliographystyle{IEEEtran}
% argument is your BibTeX string definitions and bibliography database(s)
%\bibliography{IEEEabrv,../bib/paper}
%
% <OR> manually copy in the resultant .bbl file
% set second argument of \begin to the number of references
% (used to reserve space for the reference number labels box)

\bibliographystyle{IEEEtran}
% \bibliography{bibtex/bib/References}
\begin{thebibliography}{10}
\providecommand{\url}[1]{#1}
\csname url@samestyle\endcsname
\providecommand{\newblock}{\relax}
\providecommand{\bibinfo}[2]{#2}
\providecommand{\BIBentrySTDinterwordspacing}{\spaceskip=0pt\relax}
\providecommand{\BIBentryALTinterwordstretchfactor}{4}
\providecommand{\BIBentryALTinterwordspacing}{\spaceskip=\fontdimen2\font plus
\BIBentryALTinterwordstretchfactor\fontdimen3\font minus \fontdimen4\font\relax}
\providecommand{\BIBforeignlanguage}[2]{{%
\expandafter\ifx\csname l@#1\endcsname\relax
\typeout{** WARNING: IEEEtran.bst: No hyphenation pattern has been}%
\typeout{** loaded for the language `#1'. Using the pattern for}%
\typeout{** the default language instead.}%
\else
\language=\csname l@#1\endcsname
\fi
#2}}
\providecommand{\BIBdecl}{\relax}
\BIBdecl

\bibitem{9358215}
L.~D. Xu, Y.~Lu, and L.~Li, ``Embedding blockchain technology into iot for security: A survey,'' \emph{IEEE Internet of Things Journal}, vol.~8, no.~13, pp. 10\,452--10\,473, 2021.

\bibitem{9336659}
S.~Xu, C.~Guo, R.~Q. Hu, and Y.~Qian, ``Blockchain-inspired secure computation offloading in a vehicular cloud network,'' \emph{IEEE Internet of Things Journal}, vol.~9, no.~16, pp. 14\,723--14\,740, 2022.

\bibitem{8891803}
S.~Guo, Y.~Dai, S.~Xu, X.~Qiu, and F.~Qi, ``Trusted cloud-edge network resource management: Drl-driven service function chain orchestration for iot,'' \emph{IEEE Internet of Things Journal}, vol.~7, no.~7, pp. 6010--6022, 2020.

\bibitem{baygin2022blockchain}
M.~Baygin, O.~Yaman, N.~Baygin, and M.~Karakose, ``A blockchain-based approach to smart cargo transportation using uhf rfid,'' \emph{Expert Systems with Applications}, vol. 188, p. 116030, 2022.

\bibitem{ho2021blockchain}
G.~T. Ho, Y.~M. Tang, K.~Y. Tsang, V.~Tang, and K.~Y. Chau, ``A blockchain-based system to enhance aircraft parts traceability and trackability for inventory management,'' \emph{Expert Systems with Applications}, vol. 179, p. 115101, 2021.

\bibitem{8234700}
Z.~Li, J.~Kang, R.~Yu, D.~Ye, Q.~Deng, and Y.~Zhang, ``Consortium blockchain for secure energy trading in industrial internet of things,'' \emph{IEEE Transactions on Industrial Informatics}, vol.~14, no.~8, pp. 3690--3700, 2018.

\bibitem{van2018blockchain}
R.~Van~M{\"o}lken, \emph{Blockchain across Oracle: Understand the details and implications of the Blockchain for Oracle developers and customers}.\hskip 1em plus 0.5em minus 0.4em\relax Packt Publishing Ltd, 2018.

\bibitem{al2019decentralized}
H.~Al~Breiki, L.~Al~Qassem, K.~Salah, M.~H.~U. Rehman, and D.~Sevtinovic, ``Decentralized access control for iot data using blockchain and trusted oracles,'' in \emph{2019 IEEE International Conference on Industrial Internet (ICII)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2019, pp. 248--257.

\bibitem{hassan2023trust}
A.~Hassan, I.~Makhdoom, W.~Iqbal, A.~Ahmad, and A.~Raza, ``From trust to truth: Advancements in mitigating the blockchain oracle problem,'' \emph{Journal of Network and Computer Applications}, vol. 217, p. 103672, 2023.

\bibitem{gigli2023decentralized}
L.~Gigli, I.~Zyrianoff, F.~Montori, C.~Aguzzi, L.~Roffia, and M.~Di~Felice, ``A decentralized oracle architecture for a blockchain-based iot global market,'' \emph{IEEE Communications Magazine}, vol.~61, no.~8, pp. 86--92, 2023.

\bibitem{costan2016intel}
V.~Costan and S.~Devadas, ``Intel sgx explained,'' \emph{Cryptology ePrint Archive}, 2016.

\bibitem{zhang2016town}
F.~Zhang, E.~Cecchetti, K.~Croman, A.~Juels, and E.~Shi, ``Town crier: An authenticated data feed for smart contracts,'' in \emph{Proceedings of the 2016 aCM sIGSAC conference on computer and communications security}, 2016, pp. 270--282.

\bibitem{taghavi2023reinforcement}
M.~Taghavi, J.~Bentahar, H.~Otrok, and K.~Bakhtiyari, ``A reinforcement learning model for the reliability of blockchain oracles,'' \emph{Expert Systems with Applications}, vol. 214, p. 119160, 2023.

\bibitem{al2020trustworthy}
H.~Al-Breiki, M.~H.~U. Rehman, K.~Salah, and D.~Svetinovic, ``Trustworthy blockchain oracles: review, comparison, and open research challenges,'' \emph{IEEE access}, vol.~8, pp. 85\,675--85\,685, 2020.

\bibitem{resnick2000reputation}
P.~Resnick, K.~Kuwabara, R.~Zeckhauser, and E.~Friedman, ``Reputation systems,'' \emph{Communications of the ACM}, vol.~43, no.~12, pp. 45--48, 2000.

\bibitem{chainlink2024update}
\BIBentryALTinterwordspacing
{Chainlink Blog}, ``Chainlink product update: Q1 2024,'' 2024. [Online]. Available: \url{https://blog.chain.link/product-update-q1-2024}
\BIBentrySTDinterwordspacing

\bibitem{zhang2023cost}
J.~Zhang, L.~Cheng, C.~Liu, Z.~Zhao, and Y.~Mao, ``Cost-aware scheduling systems for real-time workflows in cloud: An approach based on genetic algorithm and deep reinforcement learning,'' \emph{Expert Systems with Applications}, vol. 234, p. 120972, 2023.

\bibitem{ray2018survey}
P.~P. Ray, ``A survey on internet of things architectures,'' \emph{Journal of King Saud University-Computer and Information Sciences}, vol.~30, no.~3, pp. 291--319, 2018.

\bibitem{roman2011securing}
R.~Roman, P.~Najera, and J.~Lopez, ``Securing the internet of things,'' \emph{Computer}, vol.~44, no.~9, pp. 51--58, 2011.

\bibitem{aaqib2023iot}
M.~Aaqib, A.~Ali, L.~Chen, and O.~Nibouche, ``Iot trust and reputation: a survey and taxonomy,'' \emph{Journal of Cloud Computing}, vol.~12, no.~1, p.~42, 2023.

\bibitem{pourghebleh2019comprehensive}
B.~Pourghebleh, K.~Wakil, and N.~J. Navimipour, ``A comprehensive study on the trust management techniques in the internet of things,'' \emph{IEEE Internet of Things Journal}, vol.~6, no.~6, pp. 9326--9337, 2019.

\bibitem{alzaid2013reputation}
H.~Alzaid, M.~Alfaraj, S.~Ries, A.~J{\o}sang, M.~Albabtain, and A.~Abuhaimed, ``Reputation-based trust systems for wireless sensor networks: A comprehensive review,'' in \emph{Trust Management VII: 7th IFIP WG 11.11 International Conference, IFIPTM 2013, Malaga, Spain, June 3-7, 2013. Proceedings 7}.\hskip 1em plus 0.5em minus 0.4em\relax Springer, 2013, pp. 66--82.

\bibitem{liu2023survey}
Y.~Liu, J.~Wang, Z.~Yan, Z.~Wan, and R.~J{\"a}ntti, ``A survey on blockchain-based trust management for internet of things,'' \emph{IEEE internet of Things Journal}, vol.~10, no.~7, pp. 5898--5922, 2023.

\bibitem{yang2023trusted}
W.~Yang, L.~Shi, H.~Liang, and W.~Zhang, ``Trusted mobile edge computing: Dag blockchain-aided trust management and resource allocation,'' \emph{IEEE Transactions on Wireless Communications}, 2023.

\bibitem{kouicem2020decentralized}
D.~E. Kouicem, Y.~Imine, A.~Bouabdallah, and H.~Lakhlef, ``Decentralized blockchain-based trust management protocol for the internet of things,'' \emph{IEEE Transactions on Dependable and Secure Computing}, vol.~19, no.~2, pp. 1292--1306, 2020.

\bibitem{malik2019trustchain}
S.~Malik, V.~Dedeoglu, S.~S. Kanhere, and R.~Jurdak, ``Trustchain: Trust management in blockchain and iot supported supply chains,'' in \emph{2019 IEEE international conference on blockchain (Blockchain)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2019, pp. 184--193.

\bibitem{wu2022integrated}
Y.~Wu and Y.~Zhang, ``An integrated framework for blockchain-enabled supply chain trust management towards smart manufacturing,'' \emph{Advanced Engineering Informatics}, vol.~51, p. 101522, 2022.

\bibitem{du2023blockchain}
G.~Du, Y.~Cao, J.~Li, Y.~Zhuang, X.~Chen, Y.~Li, and J.~Chen, ``A blockchain-based trust-value management approach for secure information sharing in internet of vehicles,'' \emph{IEEE Internet of Things Journal}, vol.~11, no.~1, pp. 333--344, 2023.

\bibitem{uprety2020reinforcement}
A.~Uprety and D.~B. Rawat, ``Reinforcement learning for iot security: A comprehensive survey,'' \emph{IEEE Internet of Things Journal}, vol.~8, no.~11, pp. 8693--8706, 2020.

\bibitem{huang2019deep}
L.~Huang, S.~Bi, and Y.-J.~A. Zhang, ``Deep reinforcement learning for online computation offloading in wireless powered mobile-edge computing networks,'' \emph{IEEE Transactions on Mobile Computing}, vol.~19, no.~11, pp. 2581--2593, 2019.

\bibitem{chen2021deep}
W.~Chen, X.~Qiu, T.~Cai, H.-N. Dai, Z.~Zheng, and Y.~Zhang, ``Deep reinforcement learning for internet of things: A comprehensive survey,'' \emph{IEEE Communications Surveys \& Tutorials}, vol.~23, no.~3, pp. 1659--1692, 2021.

\bibitem{luo2023deep}
Z.~Luo, C.~Jiang, L.~Liu, X.~Zheng, H.~Ma, F.~Dong, and F.~Li, ``Deep-reinforcement-learning-based production scheduling in industrial internet of things,'' \emph{IEEE Internet of Things Journal}, vol.~10, no.~22, pp. 19\,725--19\,739, 2023.

\bibitem{chen2020deep}
Y.~Chen, Z.~Liu, Y.~Zhang, Y.~Wu, X.~Chen, and L.~Zhao, ``Deep reinforcement learning-based dynamic resource management for mobile edge computing in industrial internet of things,'' \emph{IEEE Transactions on Industrial Informatics}, vol.~17, no.~7, pp. 4925--4934, 2020.

\bibitem{chung2020distributed}
H.-M. Chung, S.~Maharjan, Y.~Zhang, and F.~Eliassen, ``Distributed deep reinforcement learning for intelligent load scheduling in residential smart grids,'' \emph{IEEE Transactions on Industrial Informatics}, vol.~17, no.~4, pp. 2752--2763, 2020.

\bibitem{park2022multi}
K.~Park and I.~Moon, ``Multi-agent deep reinforcement learning approach for ev charging scheduling in a smart grid,'' \emph{Applied energy}, vol. 328, p. 120111, 2022.

\bibitem{koh2020real}
S.~Koh, B.~Zhou, H.~Fang, P.~Yang, Z.~Yang, Q.~Yang, L.~Guan, and Z.~Ji, ``Real-time deep reinforcement learning based vehicle navigation,'' \emph{Applied Soft Computing}, vol.~96, p. 106694, 2020.

\bibitem{qian2019deep}
T.~Qian, C.~Shao, X.~Wang, and M.~Shahidehpour, ``Deep reinforcement learning for ev charging navigation by coordinating smart grid and intelligent transportation system,'' \emph{IEEE transactions on smart grid}, vol.~11, no.~2, pp. 1714--1723, 2019.

\bibitem{kochovski2019trust}
P.~Kochovski, S.~Gec, V.~Stankovski, M.~Bajec, and P.~D. Drobintsev, ``Trust management in a blockchain based fog computing platform with trustless smart oracles,'' \emph{Future Generation Computer Systems}, vol. 101, pp. 747--759, 2019.

\bibitem{lu2021exploring}
W.~Lu, X.~Li, F.~Xue, R.~Zhao, L.~Wu, and A.~G. Yeh, ``Exploring smart construction objects as blockchain oracles in construction supply chain management,'' \emph{Automation in construction}, vol. 129, p. 103816, 2021.

\bibitem{breidenbach2021chainlink}
L.~Breidenbach, C.~Cachin, B.~Chan, A.~Coventry, S.~Ellis, A.~Juels, F.~Koushanfar, A.~Miller, B.~Magauran, D.~Moroz \emph{et~al.}, ``Chainlink 2.0: Next steps in the evolution of decentralized oracle networks,'' \emph{Chainlink Labs}, vol.~1, pp. 1--136, 2021.

\bibitem{de2017witnet}
A.~S. De~Pedro, D.~Levi, and L.~I. Cuende, ``Witnet: A decentralized oracle network protocol,'' \emph{arXiv preprint arXiv:1711.09756}, 2017.

\bibitem{li2023td}
S.~Li, J.~Li, Y.~Liang, H.~Zhang, S.~Wu, S.~Wang, and L.~Cheng, ``Td-sas: A trust-aware and decentralized speed advisory system for energy-efficient autonomous vehicle platoons,'' \emph{IEEE Transactions on Intelligent Vehicles}, 2023.

\bibitem{watkins1992q}
C.~J. Watkins and P.~Dayan, ``Q-learning,'' \emph{Machine learning}, vol.~8, pp. 279--292, 1992.

\bibitem{mnih2015human}
V.~Mnih, K.~Kavukcuoglu, D.~Silver, A.~A. Rusu, J.~Veness, M.~G. Bellemare, A.~Graves, M.~Riedmiller, A.~K. Fidjeland, G.~Ostrovski \emph{et~al.}, ``Human-level control through deep reinforcement learning,'' \emph{nature}, vol. 518, no. 7540, pp. 529--533, 2015.

\bibitem{bandprotocol}
\BIBentryALTinterwordspacing
{Band Protocol}, ``Band protocol.'' [Online]. Available: \url{https://www.bandprotocol.com/}
\BIBentrySTDinterwordspacing

\bibitem{rasmussen2008round}
R.~V. Rasmussen and M.~A. Trick, ``Round robin scheduling--a survey,'' \emph{European Journal of Operational Research}, vol. 188, no.~3, pp. 617--636, 2008.

\bibitem{azizi2022deadline}
S.~Azizi, M.~Shojafar, J.~Abawajy, and R.~Buyya, ``Deadline-aware and energy-efficient iot task scheduling in fog computing systems: A semi-greedy approach,'' \emph{Journal of network and computer applications}, vol. 201, p. 103333, 2022.

\bibitem{marche2020trust}
C.~Marche and M.~Nitti, ``Trust-related attacks and their detection: A trust management model for the social iot,'' \emph{IEEE Transactions on Network and Service Management}, vol.~18, no.~3, pp. 3297--3308, 2020.

\end{thebibliography}


% \begin{thebibliography}{1}

% \bibitem{IEEEhowto:kopka}
%   0.5em minus 0.4em\relax Harlow, England: Addison-Wesley, 1999.

% \end{thebibliography}

% biography section
% 
% If you have an EPS/PDF photo (graphicx package needed) extra braces are
% needed around the contents of the optional argument to biography to prevent
% the LaTeX parser from getting confused when it sees the complicated
% \includegraphics command within an optional argument. (You could create
% your own custom macro containing the \includegraphics command to make things
% simpler here.)
%\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{mshell}}]{Michael Shell}
% or if you just want to reserve a space for a photo:

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{bibtex/figure/authors/HengyangZhang.pdf}}]{Hengyang Zhang}
Hengyang Zhang received the B.S. degree from North China Electric Power University, Beijing, China, in 2022. He is currently pursuing the M.S. degree with the School of Control and Computer Engineering, North China Electric Power University, Beijing. His research interests include information security, deep reinforcement learning and blockchain systems.
\end{IEEEbiography}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{bibtex/figure/authors/ShikeLi.pdf}}]{Shike Li}
Shike Li is currently a Lecturer in the School of Computer \& Information Technology at Shanxi University, Taiyuan, China. She received the PhD degree from North China Electric Power University in 2024. She has around 10 papers in IEEE T-ITS, IEEE TVT, IEEE IOTJ, etc. Her research interest includes internet of vehicles, information security, data privacy and blockchain systems. 

\end{IEEEbiography}
\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{bibtex/figure/authors/HangBao.pdf}}]{Hang Bao}
Hang Bao is currently a master student in the School of Control and Computer Engineering at North China Electric Power University in Beijing. She received the B.S. degree in Computer Science and Technology from Capital University of Economics and Business in 2023. Her research interests include information security, data privacy and graph neural network.
\end{IEEEbiography}


\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{bibtex/figure/authors/SixingWu.pdf}}]{Sixing Wu}
Sixing Wu received the Ph.D. degree in the Department of Electronic Engineering from Tsinghua University in 2021. He focuses on research in the field of natural language understanding, such as sentiment analysis, information extraction and text mining, and has published several papers on journals and conferences in natural language processing and data mining. Besides, his research interests also include the application of artificial intelligence in smart grid and cyber security.
\end{IEEEbiography}

\begin{IEEEbiography}[{\includegraphics[width=1in,height=1.25in,clip,keepaspectratio]{bibtex/figure/authors/JianbinLi.pdf}}]{Jianbin Li}
Jianbin Li received the BS degree from Tsinghua University in 1992, and the MS degree from Analysis and Forecast Center of the State Seismological Bureau in 1995. He was the dean of the Institute of Information Security and Big Data at Central South University. He is currently a Full Professor with the North China Electric Power University in Beijing. His research interests mainly include information security, big data systems and blockchain.
\end{IEEEbiography}

% if you will not have a photo at all:

% \begin{IEEEbiographynophoto}{John Doe}
% Biography text here.
% \end{IEEEbiographynophoto}

% insert where needed to balance the two columns on the last page with
% biographies
%\newpage

% \begin{IEEEbiographynophoto}{Jane Doe}
% Biography text here.
% \end{IEEEbiographynophoto}

% You can push biographies down or up by placing
% a \vfill before or after them. The appropriate
% use of \vfill depends on what kind of text is
% on the last page and whether or not the columns
% are being equalized.

%\vfill

% Can be used to pull up biographies so that the bottom of the last one
% is flush with the other column.
%\enlargethispage{-5in}



% that's all folks
\end{document}


