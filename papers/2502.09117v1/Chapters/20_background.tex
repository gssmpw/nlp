\section{Background}
\label{sec:background}

In this work, we use CodeQL to perform taint analysis on nodes from the Node-RED framework and conduct a conformance analysis based on the results.
The background required to understand the presented results is introduced in the following.


\subsection{Node-RED}
\label{sub:node_red}


Node-RED is an open source project originally developed by IBM that allows the creation of flow-based IoT applications.
The platform follows the low-code paradigm, i.e., applications can be developed with \textit{nodes}, which are software components that realize specific functionalities and interact with other such nodes via input and output ports.
A multitude of nodes are available that can, for example, connect with hardware sensors and actuators, access online services such as mail servers or social media platforms, or interact with system resources such as files.
The job of the application developer is mainly visual.
The developer selects nodes 
and wires them together into an application (called \textit{flow} in the Node-RED ecosystem) 
that realizes the intended business functionality.
Only in exceptional cases does the developer have to resort to writing JavaScript code themselves, for example, by using the ``function'' node, which follows the function-as-a-service paradigm.

Nodes are made available for use in this process via the \textit{Node-RED library}. 
It contains some official and many third party nodes that are created by independent developers.
The exact number of official nodes can not reliably be determined, but the vast majority of available nodes are developed by open-source contributors.


A node consists of JavaScript/TypeScript files, an HTML file, and an additional JSON file for packaging.
The node's functionality is implemented in standard JavaScript or TypeScript and can interact with the framework via the Node-RED runtime API.
The HTML file contains a number of definitions needed for integration into the Node-RED framework, styling configurations for the visual editor, help texts, and other information.
Most importantly for this work, the HTML file also specifies the number of inputs and outputs of the node.
In the following, we call the JavaScript/TypeScript files defining the node's behavior its \textit{implementation} and the HTML file providing information about it its \textit{specification}.

Nodes can communicate with each other to allow the creation of flows, i.e., to combine the functionality of multiple nodes in a meaningful way.
They can do this by means of messages exchanged via the Node-RED runtime API.
The framework provides methods for sending messages and for registering a listener.
The routing is done by the user, i.e., when one node's output is connected to another node's input in the visual dashboard, messages sent by the upstream node are forwarded to the downstream one.
Although a node can only have one input port, multiple upstream nodes can be connected to it. 
In this case, they can be distinguished in the receiving node via fields in the message payload.


As of April 2020, a request must be submitted to Node-RED to add a node to the official node library.
Before, any package published on the package manager for Node.js (\textit{npm~\footnote{\;\url{https://www.npmjs.com/}}}) that contained a specific keyword was listed in the library.
It is not clear if and how requests are vetted, but the requirement for a request is for technical reasons and not to enforce any regulations.
Given the context of the platform, it is unlikely that extensive checks concerning the security or other properties of the packages are applied, if any.




\subsection{CodeQL}
\label{sub:codeql}

Information flow analysis is used to determine how data traverses a program and how it is changed. 
The typical use case is for the identification of information leaks or other unwanted and unforeseen software behavior.
It can detect \textit{sources} and \textit{sinks} of information, i.e., places where information is created or enters the program (e.g., user-provided input) and places where information leaves the system (e.g., when it is sent to a server).
The analysis then identifies possible connections between sources and sinks, i.e., program behavior that leads to information from a source propagating and reaching a sink.
Following the related literature~\cite{Krohn07_flume_information_flo_control}, we refer to sources and sinks collectively as \textit{endpoints}.

CodeQL is an open-source tool distributed by GitHub that enables information flow analysis and is often used to automate security checks.
It works by transforming the analyzed code into a relational database that can be analyzed via a custom query language.
Issues that are to be detected (such as known vulnerabilities or bugs) are expressed as queries and applied to the database.
The query engine returns any findings of occurrences of the expressed pattern.
Internally, CodeQL models the analyzed program as an abstract syntax tree, a data flow graph, and a control flow graph.
All can be used in a single query, making the approach highly customizable and allowing highly expressive queries.
The representations capture any possible flow of information through the program, including flows through transformation operations as known from taint analysis~\cite{Schwartz10_taint_analysis_all_you_want_to_know} (e.g., when tracking an object \textit{alpha}, after an operation \textit{beta} = \textit{alpha} + \textit{x} taint analysis as opposed to normal data flow analysis would continue to track the object \textit{beta} since it is dependent on \textit{alpha}).

In this paper, we use CodeQL to identify information flows in Node-RED nodes, thus revealing all endpoints of a node over which communication is possible during operation.





\subsection{Conformance Analysis}
\label{sub:conformance_analysis}

It is a known issue that the implementation of software systems tends to deviate from the system envisioned during the design phase over time.
Phenomenons like architectural erosion or concept drift lead to a discrepancy between \textit{what is} and \textit{what should be}.
Conformance analysis describes the process of checking for deviations between any two system artifacts.
Various use-cases have been presented in the literature (e.g., \cite{Cao24_catma}).
In the presented work, we check the conformance between the implementation and specifications of nodes in the Node-RED framework.
The specified inputs and outputs are extracted from the nodes' HTML specifications, and the implemented endpoints are identified via an information flow analysis with CodeQL.

The outcome of a conformance analysis can be one of three cases, \textit{convergence}, \textit{absence}, or \textit{divergence}.
In our analysis, more nuanced outcomes are possible since there are two variables that decide this case, the nodes' inputs and outputs.
For comparability and simplicity, we aggregate them into the standard three cases.
In the context of this work, they are defined as:



\begin{itemize}
    \item \textbf{Convergence:} The specification corresponds to the implementation, i.e., the number of detected sources and sinks matches the number of inputs and outputs in the specification.
    \item \textbf{Divergence:} More sources and/or sinks are detected in the implementation than inputs and/or outputs are specified.
    This case also contains samples where only the inputs or the outputs divert while the other one converges or shows absences.
    \item \textbf{Absence:} Fewer sources and/or sinks are detected in the implementation than inputs and/or outputs are specified.
    This case also contains samples where only the inputs or the outputs show absences while the other one converges.
\end{itemize}



The generalization of, e.g., measurements where only the observed inputs divert from the specified ones while the outputs converge leads to a loss of information.
However, in our analysis of the results we did not gain any further insights when considering the more nuanced results and thus opted for simplicity to increase the accessibility of the results.
The interested reader may refer to our replication package for the complete results~\cite{replication_package}.


The case of convergence is the desired one in any conformance analysis.
In the context of this work, absences are an issue mainly from a software engineering viewpoint.
While they are worth investigating, we focus on divergences in this paper.
Divergences are the cases that are most important from a security point of view.
Additional ``hidden'' information flows are potentially security- and privacy-relevant.









