\section{Related Work}
\label{sec:related}



\subsubsection{Security Conformance Analysis between Models and Code}
Detecting non-conformances between some model representation of a software system and its implementation in code can help identify security issues at different abstraction levels and during different steps of the software development lifecycle.
For example, Peldszus et al.~\cite{Peldszus19_data_flow_compliance} and Tuma et al.~\cite{Tuma23_security_compliance} presented an approach that supports developers in identifying cases of non-conformance in the security design by automatically detecting mappings between models and implementation, thereby allowing the detection of deviations.
Other approaches have been presented that are aimed to mitigate architectural drift by checking for non-conformances between the designed architecture of a software system and its implementation.
In this context, the problem of architectural drift or erosion describes discrepancies between the designed architecture and the implemented system that emerge over time.
A systematic mapping study performed by Li et al.~\cite{Li22_architecture_erosion} identified multiple approaches that address this issue.
A foundational work for this was presented by Murphy et al.~\cite{Murphy01_software}, which introduces the concept of software reflexion models 
Based on this, Zhong et al.~\cite{zhong23_domico} have proposed an approach that checks UML diagrams for non-conformances at multiple stages during the software development process.
Uzun and Tekinerdogan~\cite{Uzun19_architecture_conformance} proposed a model-based testing approach based on architectural constraints, where violations of these constraints are automatically detected.
Similarly, Marchezan et al.~\cite{Marchezan23_consistency_checks} propose an approach based on consistency rules of different software artifacts by modeling artifacts of different processes in a common model format.
Then, discrepancies between artifacts and consistency rules can automatically be identified.

Contrary to our work, all the above approaches assume a rich model representation of the analyzed software system beyond the specified inputs and outputs to be available for the conformance analysis.




\subsubsection{Code-level Information Flow Security Analysis}
Code-level security analysis omits the creation of a model of the analysed software system and instead works directly on the source code.
A publication by Tabrizi and Pattabiraman~\cite{Tabrizi19_iot_analysis} has shown the effectiveness of such approaches for the security analysis of IoT devices.
The authors compared a design-level security analysis approach based on model-checking against a code-level security analysis approach based on symbolic execution. 
They found, that the code-level analysis outperforms the design-level analysis in terms of accuracy and execution time.


Some approaches have been proposed that support the process of conducting information flow analysis itself.
Manual effort is required to create the information flow analysis specifications, i.e., to initially adjust the available analysis techniques to the specific domain -- in our case, to create the CodeQL query specific to the Node-RED ecosystem.
This issue limits the applicability and reliability of this type of analysis. 
Several approaches have been proposed as a mitigation of this problem, aiming to automate the identification of information flow analysis specifications, e.g., in C\# (Livshits et al.~\cite{Livshits09_merlin_specification_inference}), Python (Chibotaru et al.~\cite{Chibotaru19_taint_specification_learning}), and Android applications (Rasthofer et al.~\cite{Rasthofer14_android_sources_sinks}, Clapp et al.~\cite{Clapp15_mining_information_flow_specifications}).
For JavaScript, Dutta et al.~\cite{dutta2021inspectjs} have proposed a semi-automated approach that only considers the identification of sinks and is therefore not used in this paper.
Staicu et al.~\cite{Staicu20_taint_specifications} proposed a fully automated approach for the detection of both, sources and sinks, however, their approach is dynamic and therefore not feasible for our work.
While none of the above approaches were suitable in the context of this work, future research could include the adaption or extension of an existing approach to improve the creation process of the CodeQL query we used, especially if an approach such as our conformance analysis were to be used to implement automated compliance checks in Node-RED.




\subsubsection{Node-RED and npm}
The package manager npm and different security aspects of it have been investigated before and possible mitigations to increase its security have been proposed.
Since Node-RED relies on npm, some of the more general findings concern it as well.
For example, Zahan et al.~\cite{Zahan22_npm_weak_links} proposed multiple indicators for the detection of malicious packages on npm.
Decan et al.~\cite{Decan18_npm_vulnerabilities} as well as Alfadel et al.~\cite{Alfadel20_npm_vulnerable_dependencies} investigated security vulnerabilities, and Zimmermann et al.~\cite{Zimmermann19_npm_security_threats} investigated security risks in npm packages and their origin, all largely focusing on the issues of vulnerable dependencies.
All three publications reveal wide-spread issues of vulnerable and exploitable packages in npm while also aiming to support developers in the identification of pressing security issues that need to be addressed.
Ferrerira et al.~\cite{Ferreira21_npm_permission_system} have studied packages in npm and identified, that a stricter access control scheme following the principle of least-privilege could strengthen the security of applications built from npm packages, which applies to the Node-RED framework.
They proposed a permission system and enforcement mechanisms that could protect from malicious packages.
It might therefore be a candidate to help address the issue identified in this paper.

Some reseearch has also been conducted on Node-RED specifically.
A suite of multiple tools designed to increase security and privacy for applications built with the Node-RED framework has been presented by Ioannidis et al.\cite{Ioannidis23_securing_the_flow}. 
Specifically, the authors provide techniques and tools to enable encrypted information flows between nodes, to perform code verification at runtime, to enforce access control policies in Node-RED applications, and to monitor Node-RED applications at runtime to detect security incidents.
While these are valuable tools to enforce security in the ecosystem, their does not investigate the extent to which security issues could occur.
Ancona et al.~\cite{Ancona18_runtime_monitoring} proposed an approach for runtime monitoring of Node-RED applications.
They use program traces to verify that API patterns comply with reference specifications in order to prevent unsafe program flows.
Clerrisi et al.~\cite{Clerissi18_testing_nodered} follow the same idea but also capture static system information in their system models.
Although these techniques do not specifically consider security, their dynamic  approaches complement the static analysis approach we followed in our work well, allowing a holistic security analysis if such approaches were to be combined.
An approach proposed by Ahmadpanah et al.~\cite{Ahmadpanah21_securing_nodered} goes beyond monitoring and instead enforces access control of modules and APIs based on pre-defined security policies via allow-lists.
This idea resembles what we envisioned as one of the possible mitigations to the problem identified in this paper.

To the best of our knowledge, no investigation of the state of security of Node-RED nodes has been published before. 
This paper is the first to perform a comprehensive analysis of the source code that Node-RED applications are made from, concerning its information flow security.





