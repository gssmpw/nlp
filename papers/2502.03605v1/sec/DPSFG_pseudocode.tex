
\small
\begin{algorithm*}[t]
\vspace{-0.5cm}
\caption{Automated DP-SFG Generation for single phase analog circuits}
\label{algo:dpsfg}
\begin{multicols}{2}
\begin{algorithmic}[1]
\State \textbf{Input:} Netlist of circuit components (RCs, transitors, etc.)
\State \textbf{Output:} DP-SFG of the circuit
\State $V \gets \text{All terminals in the netlist as nodes}$  \label{algo1:init_begin}
\State $D_{nc} \gets \text{Initialize node-component dictionary including parasitics}$
\State $D_{cn} \gets \text{Initialize component-node dictionary including parasitics}$
\State $T_{n} \gets \text{All transistors and corresponding terminals}$ \label{algo1:init_end}

\Statex \textit{// \textbf{Step 1}: Initialization of auxiliary nodes}
\For{node $n$ in $D_{nc}$} \textit{// Iterate over all nodes} \label{algo1:step1_begin}
    % \If{$n$ is not connected to $Ground$}
        % \State $C \gets$ All components $c$ connected to $n$
        % \If {$\nexists$ no voltage in $C$}        
    %         \State $F_{aux}[n] \gets 1$ \textit{//node $n$ auxiliary flag assigned 1}
    %         \State Create auxiliary node $\Ddot{n}$
    %         \State Create edge $(\Ddot{n}, n)$ = driving-point impedance at $n$
    %     \EndIf
    % \EndIf
    \If{ $n \not =$ ground \textbf{or} connected to voltage source}   
        \State $F_{aux}[n] \gets 1$; Create auxiliary node $\hat{n}$
        \State Add edge $(\hat{n}, n)$; weight = driving-point impedance at $n$
    \EndIf    
\EndFor \label{algo1:step1_end}
\Statex \textit{// \textbf{Step 2}: Adding branches due to passive components}
\For{component $c$ connected between terminals $i, j \in D_{cn}$} \label{algo1:step2_begin}
    \State $G_c \gets$ admittance of component $c$ 
    \If {node $t \in \{i,j\}$ connects to an auxiliary source node $\hat{t}$}
    \State Add an edge from the other terminal to $\hat{t}$ with weight $G_c$
    \Else
    \State Add an edge from $i$ to $j$ with weight $G_c$ 
    % \redHL{Not clear. These are directed edges (I think) - so why $i$ to $j$, and not $j$ to $i$. The two terminals of a resistor are indistinguishable in terms of direction. \textbf{I did it according to the terminals ...like PLUS terminal to MINUS terminal of Resistors from netlist convention.....to be exact Higher potential to lower} {\em How do you know the potential? You have not solved the circuit and you don't know any voltages.}}
    \EndIf
    % \State {\em Is this what you want to say? \textbf{The edge should be from the non-aux node to the auxnode } OK now?yes YES (If so, pl delete this comment and remove the lines below. If not, please let me know how to correct it. As you will see, this is much more human-readable. The goal of pseudocode is to explain an algorithm clearly, rather than to be semantically correct and exhaustive wrt listing all if-then-else cases. Please use this guidance to adjust Step 3 (I have not seen your most recent version. FYI, I am landing soon and may be offline till ~10pm CT. Meanwhile, can you look at how I have rewritten Step 1, and write Steps 2 and 3 in that way? I first explain the {\em principle} and then go to the example of Fig. 2 to provide a particular case. Thanks. Also: trans-conductance $\rightarrow$ transconductance (``trans'' is not a stand-alone word (I can hyphenate ``stand-alone'' because ``stand'' and ``alone'' are both valid words.). Pl. search for all hyphenated words and fix.} OK PROF
    
    % \State $F_{aux}[s] == 1$ ? $(d, \hat{s})$ $\gets$ $G_c$ 
    % \State $F_{aux}[d] == 1$ ? $(s, \hat{d})$ $\gets$ $G_c$ 
    %\State If neither node is auxiliary, create edge $(s, d)$ $\gets$ $G_c$
\EndFor \label{algo1:step2_end}

\Statex\textit{// \textbf{Step 3}: Adding branches due to transconductance $g_m$}

\For{$t$ in $T_n$} \textit{// Iterate over all transistors} \label{algo1:step3_begin}
    \Statex \textit{// $I_d[t]$: Drain current of t; $g$: Gate; $s$: Source, $d$: Drain}

    \If{$V_{gs} \neq 0$}
        \If{transistor $t$ is NMOS}
            \State For node $i$, $j$  in $\{s,d\}$ terminals:
            \If{Voltage at node $i \propto I_d[t]$}
                \State Add edges from $i$ to $\hat{i}$ with weight $-g_m$ 
                \State Add an edge from $i$ to $\hat{j}$ with weight $+g_m$ 
            \Else  
                \State (Same as above, but negate the edge weights)
            \EndIf
            \State Add an edge from $g$ to $\hat{d}$ with weight $-g_m$ 
            \State Add an edge from $g$ to $\hat{s}$ with weight $+g_m$ 
        \Else \textit{// For PMOS transistors}
            \State (Same as above, but exchange ``then'' and ``else'')
        \EndIf
\EndIf
\EndFor \label{algo1:step3_end}


% \For{$t$ in $T_n$} \textit{// Iterate over all transistors}
%     \If{$V_{gs} \neq 0$}
%         \If{transistor $t$ is NMOS}
%             \State For node $t$ in \{s,d,g\} terminals:
%             \If{Voltage at node $t \propto I_d[t]$}
%                     \State $(t, \hat{x}) \gets (I_d[t] \propto V_{x} \text{ and } x \neq g) \ ? \ -g_m : +g_m$
%                     \State $(x, \hat{y}) \gets (I_d[t] \propto V_{x}) \ ? \ +g_m : -g_m$
%                 \Else
%                     \State $(g, \hat{d}) \gets -g_m$
%                     \State $(g, \hat{s}) \gets +g_m$
%                 \EndIf
%         \Else
%             \State For PMOS transistors, the logic for edge creation would be opposite.
%         \EndIf
% \EndIf
% \EndFor





\end{algorithmic}
\end{multicols}
\vspace{-0.3cm}
\end{algorithm*}
\normalsize

