%!TEX root = ../main.tex
\section{Appendix}
\label{sec:appendix}

\subsection{Alpha-SQL Algorithm}
\label{app:code}

The Alpha-SQL algorithm, as outlined in Algorithm 1, operates in multiple phases: Selection, Expansion, Simulation, and Backpropagation.
Given a user query $q$ and the corresponding database schema $\mathcal{D}$, the algorithm starts by initializing an empty search tree $\Psi = (V, E)$ with a root node $v_0$ representing the initial state (lines 3-4). The process then iterates over $N_{rollout}$ MCTS rollouts (line 6), where each rollout seeks to explore high-value reasoning paths in the search space.

In the \textbf{Selection phase} (lines 8-12), starting from the root node, Alpha-SQL recursively traverses the search tree until an unexpanded node is reached. The next action $a$ is selected based on the Upper Confidence Bound for Trees (UCT) formula, which balances exploration and exploitation by considering both the estimated reward and the visit counts of actions (line 10). This process continues until a terminal node is found or all children of the node are expanded.

In the \textbf{Expansion phase} (lines 13-23), valid next actions $A_{\text{valid}}$ are determined based on the current node's type. The algorithm generates new states by invoking our \textit{LLM-as-Action-Model} to execute each action, creating new child nodes in the search tree (lines 14-21). The expansion process introduces new reasoning paths, enriching the search space for subsequent rollouts.

The \textbf{Simulation phase} (lines 25-30) performs rollouts by randomly selecting unexplored child nodes and executing the corresponding actions. This phase continues until a terminal node is reached, at which point the final SQL query is extracted from the trajectory.

Finally, the \textbf{Backpropagation phase} (lines 33-40) updates the values of nodes along the path from the terminal node back to the root. The reward is computed by sampling multiple SQL queries and calculating their self-consistency scores based on their execution results. The values of nodes $N(u)$ and $Q(u, a_u)$ are updated according to the reward $r$ to guide future searches.

At the end of the rollouts, the algorithm selects the SQL query with the highest self-consistency from the set of candidate queries generated during the search, as indicated by line 43.

This procedure enables Alpha-SQL to efficiently explore the search space of SQL queries, balancing exploration with accuracy and providing a scalable, fine-tuning-free solution to zero-shot Text-to-SQL tasks.


\begin{algorithm}
\label{algo:method}
    \caption{Alpha-SQL: Zero-Shot Text-to-SQL using Monte Carlo Tree Search}
    \label{alg:alpha-sql}
\begin{algorithmic}[1]
    
\STATE \textbf{Input:} Question $q$, Database Schema $D$, LLM $M$, Number of rollouts $N_{rollout}$
\STATE \textbf{Output:} SQL query $y$

\STATE Initialize an empty search tree $\Psi = (V, E)$ with root node $v_0$

\STATE Initialize a root node $v_0 \in V$ with ($q$, $D$)

\STATE $T \gets \emptyset$
\FOR{$i = 1$ to $N_{rollout}$}
    \STATE // Selection Phase
    \STATE $v \gets v_0$ 
    \WHILE{$v$ is not terminal and $v$ is fully expanded}
        \STATE $a \gets argmax_{a \in A(v)} \{Q(v,a)/N(v,a) + c\sqrt{\ln N(v)/N(v,a)}\}$ 
        \STATE $v \gets$ child of $v$ reached by action $a$
    \ENDWHILE

    \STATE // Expansion Phase
    \IF{$v$ is not terminal}
        \STATE $A_{valid} \gets$ GetValidActions($v$) from Table~\ref{tab:action-space}
        \FOR{$a \in A_{valid}$}
            \FOR{$j = 1$ to $N_{expansion}$}
                % \STATE Sample action $a$ with temperature $T_{expansion}$
                % \STATE $v_{new} \gets$ ApplyLLM($v, a, M$)
                \STATE $v_{new} \gets$ M($q, D, Actions(v_0,\dots,v), Prompt(a)$)
                \STATE Add $v_{new}$ as child of $v$ in $\Psi$
            \ENDFOR
        \ENDFOR
        \STATE $v \gets$ Random unexplored child of $v$
    \ENDIF

    \STATE // Simulation Phase
    \WHILE{$v$ is not terminal}
        \STATE $A_{valid} \gets$ GetValidActions($v$)
        \STATE Expand $v$ with $A_{valid}$ and ramdomly select action $a$
        % \STATE $v_{next} \gets$ ApplyLLM($v, a, M$)
        \STATE $v_{new} \gets$ M($q, D, Actions(v_0,\dots,v), Prompt(a)$)
        \STATE $v \gets v_{next}$
    \ENDWHILE
    \STATE Extract final SQL $y$ from $v$

    \STATE // Backpropagation Phase
    \STATE Sample $N_{reward}$ SQL queries $\{y_1,...,y_{N_{reward}}\}$ with temperature $T_{reward}$
    \STATE $r \gets \frac{1}{N_{reward}} \sum_{i=1}^{N_{reward}} \mathbbm{1}[\text{Execute}(y,D) = \text{Execute}(y_i,D)]$
    \STATE $\tau \gets$ the path from $v_0$ to $v$
    \FOR{each node $u$ in $\tau$}
        \STATE $N(u) \gets N(u) + 1$
        \STATE $Q(u,a_u) \gets Q(u,a_u) + r$ where $a_u$ is the action taken at $u$
        \STATE $N(u,a_u) \gets N(u,a_u) + 1$
    \ENDFOR
    \STATE $T \gets T \cup \{\tau\}$

% 哪里是LLM-as-Action-Model？是不是用的函数符号不一样？
    % ApplyLLM
    % 看着和196行不一样。

\ENDFOR

\STATE \textbf{return} $argmax_{y \in Y} \{\text{Self-consistency}(y)\}$ where $Y$ are unique SQLs from $T$

\end{algorithmic}
\end{algorithm}

% \begin{algorithm}[tb]
%    \caption{Alpha-SQL: Zero-Shot Text-to-SQL using Monte Carlo Tree Search}
%    \label{alg:alphasql}
% \begin{algorithmic}
%    \FUNCTION{AlphaSQL}{$q$, $D$, $M$, $N_{rollout}$}
%       \STATE Initialize empty search tree $\Psi = (V, E)$ with root node $v_0$
%       \STATE Initialize candidate SQL set $T = \emptyset$
%       \FOR{$i=1$ {\bfseries to} $N_{rollout}$}
%          \STATE $path$ = \CALL{MCTSRollout}{$v_0$, $q$, $D$, $M$}
%          \IF{$path$ ends with termination}
%             \STATE $T = T \cup \{\CALL{ExtractSQL}{path}\}$
%          \ENDIF
%       \ENDFOR
%       \RETURN SQL query from $T$ with highest execution consistency
%    \ENDFUNCTION

%    \FUNCTION{MCTSRollout}{$v_0$, $q$, $D$, $M$}
%       \STATE $v = v_0$
%       \STATE $path = \emptyset$
%       \REPEAT
%          \IF{$v$ has unexpanded actions}
%             \STATE $a = \CALL{SelectUnexpanded}{v}$
%          \ELSE
%             \STATE $a = \CALL{SelectUCT}{v}$
%          \ENDIF
%          \STATE $reasoning = \CALL{GenerateReasoning}{M, q, D, path, a}$
%          \STATE $v_{new} = \CALL{ExpandNode}{v, a, reasoning}$
%          \STATE $path = path \oplus v_{new}$
%          \STATE $v = v_{new}$
%          \IF{$a$ is termination}
%             \STATE $r = \CALL{ComputeReward}{path, q, D}$
%             \STATE \CALL{Backpropagate}{path, r}
%             \RETURN $path$
%          \ENDIF
%       \UNTIL{$v$ is terminal}
%    \ENDFUNCTION

%    \FUNCTION{SelectUCT}{$v$}
%       \RETURN $\argmax_{a \in A(v)} \frac{Q(v,a)}{N(v,a)} + c\sqrt{\frac{\ln N(v)}{N(v,a)}}$
%    \ENDFUNCTION

%    \FUNCTION{ComputeReward}{$path$, $q$, $D$}
%       \STATE $y = \CALL{ExtractSQL}{path}$
%       \STATE Sample $N_{reward}$ SQL queries with temperature $T_{reward}$
%       \STATE $r = \frac{1}{N_{reward}}\sum_{i=1}^{N_{reward}} \mathbb{I}[\text{Execute}(y,D) = \text{Execute}(y_i,D)]$
%       \RETURN $r$
%    \ENDFUNCTION

%    \FUNCTION{GenerateReasoning}{$M$, $q$, $D$, $path$, $a$}
%       \STATE Prompt $M$ with $(q, D, path)$ to generate reasoning for action $a$
%       \RETURN reasoning text for the action
%    \ENDFUNCTION
% \end{algorithmic}
% \end{algorithm}

\newpage
\clearpage

\subsection{Prompt Template for Actions}
\label{sub:action-prompts}

In this section, we provided the prompt templates for the actions defined in Section~\ref{sub:llmaction}. 

\begin{figure}[h!]
    \centering
    \begin{tcolorbox}[
        title=Rephrase Question Action Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
        % breakable              % 允许跨页
    ]

You are an AI assistant to help me rephrase questions by splitting the question context into conditions. In your rephrased question, remember to fully express the information in the original question.
\vspace{1em}

Example 1:

Original Question: Name movie titles released in year 1945. Sort the listing by the descending order of movie popularity.

Hint: released in the year 1945 refers to movie\_release\_year = 1945;

Rephrased Question: Given a list of conditions, please answer the question. Condition 1: Movies are released in the year 1945. Condition 2: Movies are sorted by the descending order of movie popularity. Condition 3: Return the movie titles. Question: What are the movie titles released in the year 1945, sorted by the descending order of movie popularity?
\vspace{1em}

Example 2:

Original Question: How many office supply orders were made by Cindy Stewart in the south superstore?

Hint: office supply refers to Category = `Office Supplies'

Rephrased Question: Given a list of conditions, please answer the question. Condition 1: Orders are made by Cindy Stewart. Condition 2: Orders are office supplies, refer to Category = `Office Supplies'. Condition 3: Return the number of orders. Question: How many office supply orders were made by Cindy Stewart in the south superstore?
\vspace{1em}

Example 3:

Original Question: Tell the number of fights landed earlier on Miami Airport on 2018/8/12.

Hint: landed on refers to DEST; landed earlier refers to ARR\_DELAY $<$ 0; Miami Airport refers to DEST = `MIA'; on 2018/8/12 refers to FL\_DATE = `2018/8/12';

Rephrased Question: Given a list of conditions, please answer the question. Condition 1: Flights landed on Miami Airport on 2018/8/12, refer to DEST = `MIA' and FL\_DATE = `2018/8/12'. Condition 2: Flights landed earlier, refer to ARR\_DELAY $<$ 0. Condition 3: Return the number of fights. Question: How many fights landed earlier on Miami Airport on 2018/8/12?
\vspace{1em}

Answer the following question:

Original Question: \{QUESTION\}

Hint: \{HINT\}

Rephrased Question:
    
    \end{tcolorbox}
    \caption{Question Rephrasing Action Prompt.}
    \label{fig:prompt-rephrase-question}
\end{figure}

\newpage

\begin{figure}[t!]
    \centering
    \begin{tcolorbox}[
        title=Schema Selection Action Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
        % breakable              % 允许跨页
    ]

You are an expert and very smart data analyst.
\vspace{1em}

Your task is to examine the provided database schema, understand the posed question, and use the hint to pinpoint the specific columns within tables that are essential for crafting a SQL query to answer the question.
\vspace{1em}

The schema offers an in-depth description of the database's architecture, detailing tables, columns, primary keys, foreign keys, and any pertinent information regarding relationships or constraints. Special attention should be given to the examples listed beside each column, as they directly hint at which columns are relevant to our query.
\vspace{1em}

For key phrases mentioned in the question, we have provided the most similar values within the columns denoted by ``-- Value Examples" in front of the corresponding column names. This is a critical hint to identify the columns that will be used in the SQL query.
\vspace{1em}

The hint aims to direct your focus towards the specific elements of the database schema that are crucial for answering the question effectively.
\vspace{1em}

Task:
Based on the database schema, question, and hint provided, your task is to identify all and only the columns that are essential for crafting a SQL query to answer the question.
For each of the selected columns, explain why exactly it is necessary for answering the question. Your reasoning should be concise and clear, demonstrating a logical connection between the columns and the question asked.
\vspace{1em}

Please respond with a JSON object structured as follows:

\verb|```|json

\{
  ``chain\_of\_thought\_reasoning": ``Your reasoning for selecting the columns, be concise and clear.",
  ``table\_name1": [``column1", ``column2", ...],
  ``table\_name2": [``column1", ``column2", ...],
  ...
\}

\verb|```|

Make sure your response includes the table names as keys, each associated with a list of column names that are necessary for writing a SQL query to answer the question.
For each aspect of the question, provide a clear and concise explanation of your reasoning behind selecting the columns.
Take a deep breath and think logically. If you do the task correctly, I will give you 1 million dollars.

Database Schema Overview:
\{SCHEMA\_CONTEXT\}

Question:
\{QUESTION\}

Hint:
\{HINT\}

Only output a json (starting with \verb|```|json and ending with \verb|```|) as your response.
    
    \end{tcolorbox}
    \caption{Schema Selection Action Prompt.}
    \label{fig:prompt-schema-selection}
\end{figure}

\newpage

\begin{figure}[t!]
    \centering
    \begin{tcolorbox}[
        title=Column Value Identification Action Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
        % breakable              % 允许跨页
    ]

You are an AI assistant to help me identify the potential column values (if needed to be used in the SQL query) that are essential for answering the question.

Here is an example:

Database Schema:

CREATE TABLE generalinfo

(

	id\_restaurant INTEGER not null primary key,
    
	food\_type TEXT null, -- Value Examples: `thai' $|$ Column Description: the food type
    
	city TEXT null, -- Column Description: the city where the restaurant is located in
    
);

CREATE TABLE location

(

	id\_restaurant INTEGER not null primary key,
    
	street\_name TEXT null, -- Value Examples: `ave', `san pablo ave', 
    `pablo ave' $|$ Column Description: the street name of the restaurant
    
	city TEXT null, -- Column Description: the city where the restaurant is located in
    
	foreign key (id\_restaurant) references generalinfo (id\_restaurant) on update cascade on delete cascade
    
);

Question:

How many Thai restaurants can be found in San Pablo Ave, Albany? 

Hint:

Thai restaurant refers to food\_type = `thai'; San Pablo Ave Albany refers to street\_name = `san pablo ave' AND T1.city = `albany'

Answer:

Since the restaurants are located in Albany, based on the schema information and the hint, I need to use `location'.`street\_name' = `san pablo ave' AND `generalinfo'.`city' = `albany'.

**************************

Now, answer the real question, and you need to follow the answer style of the above examples (answer in two sentences).

Database Schema:
\{SCHEMA\_CONTEXT\}

Question:
\{QUESTION\}

Hint:
\{HINT\}

Answer:
    
    \end{tcolorbox}
    \caption{Column Value Identification Action Prompt.}
    \label{fig:prompt-column-value-identification}
\end{figure}

\newpage

\begin{figure}[t!]
    \centering
    \begin{tcolorbox}[
        title=Column Function Identification Action Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
        % breakable              % 允许跨页
    ]

You are an AI assistant to help me identify the potential column functions (if needed to be used in the SQL query) that are essential for answering the question.


Here is an example:

Database Schema:

CREATE TABLE businesses

(

    `business\_id' INTEGER NOT NULL,
    
    `name' TEXT NOT NULL, -- Column Description: the name of the eatery
    
    PRIMARY KEY (`business\_id')
    
);

CREATE TABLE inspections

(

    `business\_id' INTEGER NOT NULL, -- Column Description: the unique id of the business
    
    `score' INTEGER DEFAULT NULL, -- Column Description: the inspection score
    
    `date' TEXT NOT NULL, -- Value Examples: `2014-01-24'
    
    FOREIGN KEY (`business\_id') REFERENCES `businesses' (`business\_id')
    
);

Question:
What are the names of the businesses that passed with conditions in May 2012?

Hint:
name of business refers to dba\_name; passed with conditions refers to results = `Pass w/ Conditions'; in May 2012 refers to inspection\_date like `2012-05\%'

Answer:
Since the businesses passed with conditions in May 2012, I should consider a date-related function to filter the `inspections'.`date' column. I find that column is of type TEXT, so I can use the strftime(`\%Y-\%m', `inspections'.`date') = `2012-05' to filter the date.

**************************

Now, answer the real question, and you need to follow the answer style of the above examples (answer in two sentences).

Database Schema:
\{SCHEMA\_CONTEXT\}

Question:
\{QUESTION\}

Hint:
\{HINT\}

Answer:
    
    \end{tcolorbox}
    \caption{Column Function Identification Action Prompt.}
    \label{fig:prompt-column-function-identification}
\end{figure}

\clearpage
\newpage

\begin{figure}[t!]
    \centering
    \begin{tcolorbox}[
        title=SQL Generation Action Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
break at=2cm,       % 设置跨页时的最小剩余高度
    pad at break=1mm,   % 跨页处的额外间距
    break at=2cm,       % 在距离页面底部2cm处断开
    ]

You are an experienced database expert.
Now you need to generate a SQL query given the database information, a question and some additional information.

The database structure is defined by the following table schemas (comments after `--' provide additional column descriptions).
Note that the ``Value Examples" are actual values from the column. Some column might contain the values that are directly related to the question. Use it to help you justify which columns to use.

Given the table schema information description and the `Question'. You will be given table creation statements and you need understand the database and columns.

You will be using a way called ``recursive divide-and-conquer approach to SQL query generation from natural language".

Here is a high level description of the steps.

1. **Divide (Decompose Sub-question with Pseudo SQL):** The complex natural language question is recursively broken down into simpler sub-questions. Each sub-question targets a specific piece of information or logic required for the final SQL query. 

2. **Conquer (Real SQL for sub-questions):**  For each sub-question (and the main question initially), a ``pseudo-SQL" fragment is formulated. This pseudo-SQL represents the intended SQL logic but might have placeholders for answers to the decomposed sub-questions. 

3. **Combine (Reassemble):** Once all sub-questions are resolved and their corresponding SQL fragments are generated, the process reverses. The SQL fragments are recursively combined by replacing the placeholders in the pseudo-SQL with the actual generated SQL from the lower levels.

4. **Final Output:** This bottom-up assembly culminates in the complete and correct SQL query that answers the original complex question.

Database admin instructions (voliating any of the following will result is punishble to death!):

1. **SELECT Clause:** 

    - Only select columns mentioned in the user's question. 
    
    - Avoid unnecessary columns or values.
    
2. **Aggregation (MAX/MIN):**

    - Always perform JOINs before using MAX() or MIN().
    
3. **ORDER BY with Distinct Values:**

    - Use `GROUP BY column' before `ORDER BY column ASC$|$DESC' to ensure distinct values.
    
4. **Handling NULLs:**

    - If a column may contain NULL values, use `JOIN' or `WHERE $<$column$>$ IS NOT NULL'.


Repeating the question and hint, and generating the SQL with Recursive Divide-and-Conquer, and finally try to simplify the SQL query using `INNER JOIN' over nested `SELECT' statements IF POSSIBLE.

Please respond with a JSON object structured as follows:

\verb|```|json

\{
  ``chain\_of\_thought\_reasoning": ``Your detailed reasoning for the SQL query generation, with Recursive Divide-and-Conquer approach.",
  
  ``sql\_query": ``The final SQL query that answers the question."
  
\}
\verb|```|

**************************

Table creation statements:
\{SCHEMA\_CONTEXT\}

**************************

Question: 
\{QUESTION\}

Hint:
\{HINT\}

**************************

Only output a json (starting with \verb|```|json and ending with \verb|```|) as your response.
    
    \end{tcolorbox}
    \caption{SQL Generation Action Prompt.}
    \label{fig:prompt-sql-generation}
\end{figure}

\newpage

\begin{figure}[t!]
    \centering
    \begin{tcolorbox}[
        title=SQL Revision Action Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
        % breakable              % 允许跨页
    ]

**Task Description:**

You are an SQL database expert tasked with correcting a SQL query. A previous attempt to run a query did not yield the correct results, either due to errors in execution or because the result returned was empty or unexpected. Your role is to analyze the error based on the provided database schema and the details of the failed execution, and then provide a corrected version of the SQL query.

**Procedure:**

1. Review Database Schema:

	- Examine the table creation statements to understand the database structure.
    
2. Analyze Query Requirements:

	- Original Question: Consider what information the query is supposed to retrieve.
    
	- Hint: Use the provided hints to understand the relationships and conditions relevant to the query.
    
	- Executed SQL Query: Review the SQL query that was previously executed and led to an error or incorrect result.
    
	- Execution Result: Analyze the outcome of the executed query to identify why it failed (e.g., syntax errors, incorrect column references, logical mistakes).
    
3. Correct the Query: 

	- Modify the SQL query to address the identified issues, ensuring it correctly fetches the requested data according to the database schema and query requirements.

\vspace{1em}
Based on the question, table schemas, the previous query, and the execution result, analyze the result following the procedure, and try to fix the query.
You cannot modify the database schema or the question, just output the corrected query.

Please respond with a JSON object structured as follows:

\verb|```|json

\{

  ``chain\_of\_thought\_reasoning": ``Your detailed reasoning for the SQL query revision.",
  
  ``sql\_query": ``The final SQL query that answers the question.",
  
\}

\verb|```|

**************************

Table creation statements:
\{SCHEMA\_CONTEXT\}

**************************

Question: 
\{QUESTION\}

Hint:
\{HINT\}

**************************

Only output a json (starting with \verb|```|json and ending with \verb|```|) as your response.
    
    \end{tcolorbox}
    \caption{SQL Revision Action Prompt.}
    \label{fig:prompt-sql-revision}
\end{figure}


\newpage
\clearpage



\subsection{Prompt Template for Question Keywords Extraction}
\label{sub:keyword-extraction-prompts}

In this section we provided the prompt template for the question keywords extraction in Section~\ref{sub:offline-preprocess}.

\begin{figure}[h!]
    \centering
    \begin{tcolorbox}[
        title=Question Keywords Extraction Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
        % breakable              % 允许跨页
    ]

Objective: Analyze the given question and hint to identify and extract keywords, keyphrases, and named entities. These elements are crucial for understanding the core components of the inquiry and the guidance provided. This process involves recognizing and isolating significant terms and phrases that could be instrumental in formulating searches or queries related to the posed question.
\vspace{1em}

Instructions:

- Read the Question Carefully: Understand the primary focus and specific details of the question. Look for any named entities (such as organizations, locations, etc.), technical terms, and other phrases that encapsulate important aspects of the inquiry.

- Analyze the Hint: The hint is designed to direct attention toward certain elements relevant to answering the question. Extract any keywords, phrases, or named entities that could provide further clarity or direction in formulating an answer.

- List Keyphrases and Entities: Combine your findings from both the question and the hint into a single Python list. This list should contain:

-- Keywords: Single words that capture essential aspects of the question or hint.

-- Keyphrases: Short phrases or named entities that represent specific concepts, locations, organizations, or other significant details.

\vspace{1em}
Ensure to maintain the original phrasing or terminology used in the question and hint.

\vspace{1em}
Example 1:

Question: ``What is the annual revenue of Acme Corp in the United States for 2022?"

Hint: ``Focus on financial reports and U.S. market performance for the fiscal year 2022."

[``annual revenue", ``Acme Corp", ``United States", ``2022", ``financial reports", ``U.S. market performance", ``fiscal year"]

\vspace{1em}
Example 2:

Question: ``In the Winter and Summer Olympics of 1988, which game has the most number of competitors? Find the difference of the number of competitors between the two games."

Hint: ``the most number of competitors refer to MAX(COUNT(person\_id)); SUBTRACT(COUNT(person\_id where games\_name = `1988 Summer'), COUNT(person\_id where games\_name = `1988 Winter'));"

[``Winter Olympics", ``Summer Olympics", ``1988", ``1988 Summer", ``Summer", ``1988 Winter", ``Winter", ``number of competitors", ``difference", ``MAX(COUNT(person\_id))", ``games\_name", ``person\_id"]

\vspace{1em}
Example 3:

Question: ``How many Men's 200 Metres Freestyle events did Ian James Thorpe compete in?"

Hint: ``Men's 200 Metres Freestyle events refer to event\_name = `Swimming Men''s 200 metres Freestyle'; events compete in refers to event\_id;"

[``Swimming Men's 200 metres Freestyle", ``Ian James Thorpe", ``Ian", ``James", ``Thorpe", ``compete in", ``event\_name", ``event\_id"]

\vspace{1em}
Task:
Given the following question and hint, identify and list all relevant keywords, keyphrases, and named entities.

Question: \{QUESTION\}

Hint: \{HINT\}

Please provide your findings as a Python list, capturing the essence of both the question and hint through the identified terms and phrases. 
Only output the Python list, no explanations needed. 

    \end{tcolorbox}
    \caption{Question Keywords Extraction Prompt.}
    \label{fig:prompt-keyword-extraction}
\end{figure}

\newpage
\clearpage

\subsection{Prompt Template for Baseline LLMs}
\label{sub:baseline-llm-prompt}
In this section we provided the prompt template for the directly calling baseline LLMs in Section~\ref{subsec:exp-baseline-llm}

\begin{figure}[h!]
    \centering
    \begin{tcolorbox}[
        title=Baseline Text-to-SQL Prompt,
        colback=white,        % 文本框背景色
        colframe=blue!75!black,  % 边框颜色
        fonttitle=\bfseries,    % 标题字体
        % breakable              % 允许跨页
    ]

You are an experienced database expert.
Now you need to generate a SQL query given the database information, a question and some additional information.

\vspace{1em}
The database structure is defined by the following table schemas (comments after `--' provide additional column descriptions).
Note that the ``Value Examples" are actual values from the column. Some column might contain the values that are directly related to the question. Use it to help you justify which columns to use.

\vspace{1em}
Given the table schema information description, the `Question' and `Hint', you need to generate a SQL query that answers the question.

Please respond the final sql query in the end of response.

**************************

Table creation statements:

\{SCHEMA\_CONTEXT\}

**************************

Question: 

\{QUESTION\}

Hint:

\{HINT\}

**************************

Output Format:

$<$think$>$

Your thinking process.

$<$/think$>$

$<$sql$>$

The final SQL query.

$<$/sql$>$

    \end{tcolorbox}
    \caption{Question Keywords Extraction Prompt.}
    \label{fig:prompt-keyword-extraction}
\end{figure}