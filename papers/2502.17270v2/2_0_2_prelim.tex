

\section{Model\label{sec:prel}}


\paragraph{System Model}
We consider a permissioned system with $m$ clients and $n$ nodes.
These nodes are the replicated state machines of the DL and agree together on the order of transactions send by clients.
Once an honest node $\eta$ receives a new transaction $x$, $x$ is stored in the node's local mempool.
In a Blockchain network such as Cosmos \cite{dissecting_tendermint} or Ethereum PoS \cite{exploiting_ethereum_after_the_merge_the_interplay_between_pos_and_mev_strategies}, if $\eta$ emerges as the proposer of the next block, $x$ may be included in that block.
In DAG-based ledgers such as DagRider \cite{all_you_need_is_dag}, $\eta$ may include $x$ in its next vertex proposal.

%the mechanism is different as there are no single proposers for each height. Nevertheless, the finalization order of transactions still depends on the contents of the nodes' local mempools at a given time, which themselves depends on the history of communication events that occurred in the system.


\paragraph{Network Model}
Nodes and clients operate on a partially synchronous network \cite{consensus_in_the_presence_of_partial_synchrony} i.e., there exists a bound $\Delta$ that is not known by any node ($\Delta$ being unknown is equivalent to formulating partial synchrony using the Global Stabilization Time \cite{consensus_in_the_presence_of_partial_synchrony,themis_fast_strong_order_fairness_in_byzantine_consensus}) s.t., all messages send at time $t$ are received within $]t,t+\Delta]$.
A public key infrastructure is used to authenticate clients and nodes via digital signatures.



\paragraph{Application layer use-case}
The study of OF is notably motivated by the costs of MEV attacks \cite{flash_boys_frontrunning_in_decentralized_exchanges_miner_extractable_value_and_consensus_instability,sok_preventing_transaction_reordering_manipulations_in_decentralized_finance} in decentralized finance.
This usecase is characterized by \textbf{(1)} non commutative transactions and \textbf{(2)} incentives for an attacker to manipulate the order of transactions.
As in \cite{adversary_augmented_simulation_to_evaluate_client_fairness_on_hyperledger_fabric}, we consider a simple application layer which has both \textbf{(1)} and \textbf{(2)}. 
It consists in a game where puzzles are regularly revealed and clients compete to solve them.
Whenever a client $\chi$ solves a puzzle $k$, it submits a transaction $\chi:k$ that contains its solution.
For puzzle $k$, the winner is the first client $\chi$ s.t., $\chi:k$ is finalized.
For a given execution of the system, \%$g(\chi)$ denotes the percentage of games a client $\chi$ has won.
Supposing every client has knowledge of the puzzles at the same time and has the same ability, the game is {\em client-fair} iff \%$g(\chi)$ converges towards $1/m$.
By defining $\mathtt{score}(\chi) = \%g(\chi) * m$ we have a metric to evaluate client-fairness that is protocol agnostic and independent from the parameterization (numbers $m$ of clients, $n$ of nodes, etc.).
Unlike Jain's fairness index \cite{a_quantitative_measure_of_fairness_and_discrimination_for_resource_allocation_in_shared_computer_systems}, which is global, our $\mathtt{score}(\chi)$ is ``client-specific'' (an interesting metric in cases where specific clients are targeted). It also measures {\em send-order fairness} because, if the latter is upheld, then puzzle solutions of clients are finalized in the order in which they are send. Thus their success likelihood only depends upon their ability (and not on e.g., their network connection).
%Given our hypothesis that clients to have the same ability, this implies that their $\mathtt{scores}$ converge towards $1$.



\paragraph{Adversary}
Our adversary may control $b \in [0,f]$ nodes (where $f = (n-1)/3$) and force them to deviate from the protocol. However, it does not have direct control over the network (e.g., it can only delay messages emitted by the nodes it controls).
The goal of the adversary is to reduce $\mathtt{score}(\chi)$ for a target client $\chi$, reducing its chances of winning puzzles.
We also evaluate the impact of the adversary by measuring numbers of violations of OF properties.
This amounts to comparing, for each pair of finalized transactions $x$ and $x'$, their finalization order in the ledger and either the order of their initial emission (by the corresponding clients) or the order of their reception in each of the nodes.
Given $X$ the total number of finalized transactions at one moment in time, there are $X*(X-1)/2$ such pairs. 
In order to have statistically significant results, we need a high number $p$ of puzzle games, which yields a large number of transactions $X = m*p$ having $m$ transactions per game.
Thus, comparing reception orders on every pair of transactions on every node amounts to $n*m*p*(m*p -1)/2$ comparisons, which quickly become intractable.
In our usecase application, the order between two transactions $\chi_1:k_1$ and $\chi_2:k_2$ only matters if they concern the same puzzle game i.e., iff $k_1 = k_2$ (otherwise they can commute).
We leverage this by only comparing transactions involving the same puzzle, which only requires $n*p*m*(m-1)/2$ comparisons.
Then, counting the numbers of times $z$ that transaction $x$ is received before $x'$, we have that, if $z > n/2$, then receive-order fairness is violated if $x$ is finalized after $x'$.
By counting the numbers of times each property is violated (for all properties and all relevant pairs of transactions) during the run of a system, we can evaluate their respect and the effect that the adversarial attacks have on them.


