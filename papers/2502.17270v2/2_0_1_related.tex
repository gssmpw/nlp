

\section{Preliminaries and related works\label{sec:related}}


Fairness, in the context of Blockchains \cite{on_fairness_in_commitee_based_blockchains,on_fairness_in_voting_consensus_protocols} and DAGs \cite{fairness_notions_in_dag_based_dlts} may refer to various notions, including the fairness in committee selection \cite{on_fairness_in_commitee_based_blockchains}, rewarding \cite{do_the_rich_get_richer_fairness_analysis_for_blockchain_incentives} or the ability to take decisions \cite{on_fairness_in_voting_consensus_protocols,fairledger_a_fair_blockchain_protocol_for_financial_institutions} w.r.t.~individual nodes' voting power. 
While \cite{fairness_and_efficiency_in_dag_based_cryptocurrencies} studies reward fairness in PoW DAGs, \cite{on_fairness_in_voting_consensus_protocols} deals with fairness to validators.
\cite{fairness_notions_in_dag_based_dlts} reviews notions of fairness applied to DAG-based DL.
In \cite{sok_preventing_transaction_reordering_manipulations_in_decentralized_finance} ``fairness'' is achieved whenever participants cannot include, exclude or front-run \cite{flash_boys_frontrunning_in_decentralized_exchanges_miner_extractable_value_and_consensus_instability} a transaction after having seen its content.


In this paper, we are specifically interested in {\em order-fairness} \cite{order_fairness_for_byzantine_consensus,quick_order_fairness,byzantine_ordered_consensus_without_byzantine_oligarchy,themis_fast_strong_order_fairness_in_byzantine_consensus} (OF) properties, that relate partial orders on transaction finalization and on communication events.
\cite{order_fairness_for_byzantine_consensus} defines ``\textit{receive-order fairness}'' as follows: if a majority of nodes receive a transaction $x$ before $x'$ then $x$ must be finalized before $x'$.
However, for three transactions $x_1$, $x_2$ and $x_3$, it may be so that a majority of nodes receive $x_1$ before $x_2$, $x_2$ before $x_3$ and $x_3$ before $x_1$. Thus, this property is impossible to achieve, as $\{x_1,x_2,x_3\}$ forms a Condorcet cycle \cite{condorcet_attack_against_fair_transaction_ordering}.
As a solution, \cite{quick_order_fairness} proposes the achievable ``\textit{differential-order fairness}'', which rather considers the difference between the number of honest nodes that receive $x$, and resp.~$x'$ first.
%If this differences exceeds $2*f$, then $x$ must be finalized before $x'$.
\cite{themis_fast_strong_order_fairness_in_byzantine_consensus} proposes ``\textit{$\gamma$-(all)-batch-order fairness}'' that reasons on pairs of transactions that are not in the same Condorcet cycle.
%as follows: for $\gamma \geq 1/2$, if a proportion of nodes greater than $\gamma$ receives $x$ before $x'$ and if $x$ and $x'$ are not in a Condorcet cycle, then $x$ must be finalized before $x'$.



%These properties encode an intuitive notion of fairness in consensus ordering, as the finalization order, if ``fair'', should mimic the ``reception'' order. Yet, assessing the propensity of a protocol stack to violate such fairness properties is problematic whenever the notion of ``reception'' is ambiguous. It may be so that clients do not broadcast their transactions to all the nodes. An additional gossip protocol may be used. If a broadcast abstraction is involved, should the call or delivery events be considered ?



Because their premise involves the order with which nodes receive transactions, upholding such OF properties can only prevent an attacker from manipulating the finalization order, supposing the reception order remains unchanged (i.e., the attacker does not change it).
Yet, an attacker with a better network connection (than that of honest nodes and clients) may listen to an incoming transaction $x$ and front-run it via submitting $x'$ and ensuring that most nodes receive $x'$ before $x$ \cite{sok_preventing_transaction_reordering_manipulations_in_decentralized_finance}.
In that case, the attack is undetectable and even worse, upholding receive-order-fairness guarantees the attack to succeed.
\cite{condorcet_attack_against_fair_transaction_ordering} describes another attack, targeting protocols that uphold batch-order fairness.
This Condorcet attack consists in sending several transactions with high and small transmission delays to the nodes so as to artificially create Condorcet cycles. Its goal is to trap honest transactions in theses cycles so that e.g., they are easier to front-run (because they are all forced into the same batch).
As per \cite{sok_preventing_transaction_reordering_manipulations_in_decentralized_finance}, we refer to such attack as transaction reordering manipulations.
These attacks may rely on the power of individual clients and nodes (coordinated by the adversary) to order transactions.
\cite{condorcet_attack_against_fair_transaction_ordering} highlights that the existing Algorithmic Committee Ordering \cite{sok_preventing_transaction_reordering_manipulations_in_decentralized_finance} algorithms do not necessarily protect against transaction reordering.
On the other hand, cryptographic solutions such as commit \& reveal \cite{sok_preventing_transaction_reordering_manipulations_in_decentralized_finance,maximal_extractable_value_protection_on_a_DAG,fairness_notions_in_dag_based_dlts} are expensive.
DAG-based ledgers, which do not rely upon leaders in the same way as classical Blockchains do, could, theoretically, be more robust to transaction reordering and thus constitute a convenient alternative and a partial solution to that problem.
In this paper, we study the robustness of existing DAG-based algorithms to specific scenarios of transaction reordering.



{\em Send-order fairness} \cite{order_fairness_for_byzantine_consensus} relates the orders of transaction emission (by clients) and finalization. Upholding this property would prevent front-running by an adversary with a superior network connection.
However, in contrast to receive-order fairness, which involves locally observed reception orders on specific nodes, send-order fairness involves a global order of send events across all clients.
Distant machines having uncorrelated local clocks, and malicious clients being likely to falsify timestamps, maintaining that order would require consequent additional mechanisms and remains an unsolved problem \cite{order_fairness_for_byzantine_consensus}.
Yet, this notion of fairness remains a useful theoretical tool and it can actually be measured in a simulated environment (we have access to the simulator's clock).
Send-order fairness can be facilitated if one upholds ``fairness to clients'' \cite{fairness_notions_in_dag_based_dlts}.
The notion of {\em client-fairness} may refer to clients being treated fairly by the nodes. This includes how nodes should handle receiving multiple transactions from multiple clients \cite{byzid_byzantine_fault_tolerane_from_intrusion_detection,rbft_redundant_byzantine_fault_tolerance}. 
It can also correspond to nodes having ``fair access to transactions from all clients'', which can be modeled using Jain's fairness index \cite{a_quantitative_measure_of_fairness_and_discrimination_for_resource_allocation_in_shared_computer_systems}.





