

\section{Problem with weak edges in DagRider\label{anx:bug_dagrider}}


Let us remark that, thanks to our analysis and extensive simulation of DagRider, we have found an error in the definition of the algorithm in \cite{all_you_need_is_dag}.

If a given node (at row $r$) begins the reliable broadcast of two successive vertices $v^r_c$ and $v^r_{c+1}$ (via emitting the corresponding INIT messages). Then, under an asynchronous communication model, and due to the non-determinism incurred by networked communications, there are no guarantee, for any node $r'$, that $r'$ can collect $f+1$ READY messages for $v^r_c$ before observing $f+1$ READY messages for $v^r_{c+1}$. This may result in $v^r_{c+1}$ being delivered before $v^r_{c}$, as illustrated on Fig.\ref{fig:dagrider_bug}.

\begin{figure}[h]
    \centering
    \scalebox{.9}{\input{figures/dagrider_bug/bug}}
    \caption{Bug in DagRider : more than $f$ weak edges}
    \label{fig:dagrider_bug}
\end{figure}

In \cite{all_you_need_is_dag}, it is said that there can be up to $f$ weak edges.
However, these weak edges are programmatically defined in Algorithm 2 lines 27-31 in \cite{all_you_need_is_dag} by gathering all ``orphan'' vertices from columns before the previous column that have no path towards the new vertex proposal.
However, the creation of a new vertex ends with a call to $\mathtt{rbcast}$ (line 15 in Algorithm 2 of \cite{all_you_need_is_dag}) without waiting for the corresponding delivery ($\mathtt{rdlver}$) in the reliable broadcast layer. 
Because the subsequent creation of a new vertex does not depend on the reliable delivery of the previous one (it only depends on the delivery of $2*f+1$ vertices in the previous column, see lines 10 in Algorithm 2 of \cite{all_you_need_is_dag}), then it is possible for a node to emit several vertices with no edges between one another. 
This is exemplified on Fig.\ref{fig:dagrider_bug} with node ``D'' (on the bottom) which submits 3 vertices that are not linked with strong edges (in red and orange for better readability). This may occur if the delivery operation on the reliable broadcast layer is particularly slow for vertices submitted by ``D'' (this may be due to ``D'' having network issues, whether or not these are caused by malice).
In any case, supposing that node ``C'' (third row) then finally delivers the previous vertices from ``D'' and submits a new vertex proposal, by construction, this vertex will then includes at least the 3 weak edges drawn in blue on Fig.\ref{fig:dagrider_bug}.
In that case, because we have $n = 3*f+1$ and $n=4$, the limit is $f=1$ which contradicts the remark from \cite{all_you_need_is_dag}.

The fact that delivery operations on the reliable broadcast layer occur in a certain order is not guaranteed at all. In \cite{all_you_need_is_dag}, only three properties are given for the reliable broadcast abstraction: ``Agreement'', ``Integrity'' and ``Validity'' and none of them refer to ordering.
However, \cite{all_you_need_is_dag} seems to take for granted one such property, because in all the examples they propose there is always a strong edge between any two consecutive vertices submitted by the same node.
The aforementioned issue with the number of weak edges is related to this oversight w.r.t.~the ordering of delivery operation on the reliable broadcast layer. This underlines the importance of (fair) ordering properties in the definition of distributed protocols.

In order to correct the issue we could either \textbf{(1)} add additional properties on the reliable broadcast abstraction from \cite{all_you_need_is_dag} or \textbf{(2)} enforce the requirement that there is at most $f$ outgoing weak edges on a vertex.

Let us remark that \cite{reducing_latency_of_dag_based_consensus_in_the_asynchronous_setting_via_the_utxo_model} acknowledges that this problem may occur in Narwhal \& Tusk \cite{narwhal_and_tusk} and explicitly requires that a node's proposal at column $c$ always includes (i.e., has a strong edge towards) its proposal for column $c-1$ (i.e., solution \textbf{(1)}).

However, a problem with solution \textbf{(1)} is that it forces all nodes to wait for the delivery of their vertex at column $c$ before being able to initiate the broadcast of their vertex at column $c+1$.
Yet, as we discussed in Sec.\ref{ssec:dags_and_blockchains}, one of the advantages of DAG-based ledgers w.r.t.~Blockchain lies in the ability of each node to independently broadcast new vertices to be added to the DAG, instead of having to wait for the resolution of a consensus algorithm to select a new block.
Moreover, solution \textbf{(1)} may further increase the power of nuisance of an adversary that is able to delay the delivery of vertices (as described in Sec.\ref{ssec:attack_bracha}). Indeed, in addition of increasing the time between the moment of broadcast initiation and broadcast delivery for the vertex of column $c$, if solution \textbf{(1)} is implemented, the adversary will also delay the moment of the subsequent broadcast initiation (i.e., that of the vertex of column $c+1$).

For this reason, in this paper, we have considered solution \textbf{(2)}: limiting the number of weak edges to $f$ (randomly selecting those targeting the lower columns) even though more could be included.

