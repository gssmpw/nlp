


\subsection{DagRider\label{ssec:dagrider}}




\begin{figure}[h]
\vspace*{-.4cm}
    \centering
\scalebox{.875}{\input{figures/layers_dagrider}}
    \caption{Description of DagRider}
    \label{fig:layers_dagrider}
\vspace*{-.4cm}
\end{figure}



In \cite{all_you_need_is_dag}, DagRider is described via pseudocode.
For concision, we rather describe it via the atomic actions a DagRider node may perform and how these actions are triggered by each other or by external stimuli (c.f.~actor model \cite{a_universal_modular_actor_formalism_for_artificial_intelligence}).
Fig.\ref{fig:layers_dagrider} describes the behavior of any individual node. 
The rectangles and ellipses resp.~correspond to atomic actions it may execute and to persistent information stored in its memory.
The red arrows describe the effects of the actions on the memory.
Plain arrows carrying a symbol $Z$ correspond to calling an action on a value of type $Z$. 
%, carrying a symbol $Z$, corresponds to the completion of an action transferring a temporary value of type $Z$ to another action which is then executed.
Dotted arrows signify that the completion of an action may trigger the execution of another.
The colored areas correspond to layers of abstraction.
%that separate responsibilities for the implementation of the node's behavior.


In the application layer, ``receive transaction'' is triggered whenever a node receives a new transaction $x$ of type $X$. 
This results in $x$ (if not duplicated) being \ul{pushed} in a ``transactions mempool'' buffer.
This may in turn trigger the proposal of a new vertex by the node $r$ if the following condition is met: the node is at column $c$ (i.e, it has already broadcast vertices for all $c'<c$ and has yet to do so for $c$) and there are at least $2*f+1$ distinct vertices at column $c-1$ in its local copy of the DAG (which can be verified via \ul{lookup} of the ``DAG''). 
In that case, ``propose vertex'' creates a new vertex $v_c^r$ that contains transactions \ul{extracted} from ``buffered transactions'', has at least $2*f+1$ strong edges and at most $f$ weak edges.
Details in Appendix \ref{anx:bug_dagrider}.
%, we further discuss weak edges and an oversight in the original DagRider paper.


In the reliable broadcast layer (in blue on Fig.\ref{fig:layers_dagrider}), ``$\mathtt{rbcast}$'' and ``$\mathtt{rdlver}$'' resp.~correspond to triggering the broadcast and delivering the vertex.
As per \cite{all_you_need_is_dag}, the broadcast must guarantee: \textbf{agreement} i.e., if a correct node delivers a vertex $v$ then, eventually, all the other correct nodes will also deliver $v$, \textbf{integrity} i.e., for each round, only one vertex can be delivered per node and \textbf{validity} i.e., if a correct node broadcast a correct vertex $v$ then, eventually, every correct node will deliver $v$.
These properties are s.t.~we may safely ignore issues related to duplicated or equivocated vertices.


Once ``propose vertex'' outputs a vertex $v$, it is reliably broadcast to the $n$ nodes of the network via $\mathtt{rbcast}$.
Then, eventually, $\mathtt{rdlver}$ triggers ``receive vertex'' which \ul{pushes} $v$ in a set of ``buffered vertices''.
If all vertices $v'$ that are targets of the edges of $v$ are already present in the node's local copy of the DAG, then ``add to DAG'' is triggered, which causes the node to remove vertices from ``buffered vertices'' and to insert them at their correct position in its local copy of the DAG.
The reception of a single vertex may have cascading effects and cause the addition of a large number of vertices to the DAG.
Whenever a vertex is added to the DAG, the transactions it contains are \ul{filtered-out} from ``transactions mempool'', so that they won't be included in subsequent vertex proposals (thus purging the mempool).


As the local copy of the DAG grows, columns are progressively filled, which allows constructing the waves.
The first step is ``select leader'', which outputs the leader of wave $w \geq 0$ (at column $1 + w*4$). 
Its determination corresponds to the selection of a node/row.
So that the adversary cannot predict it and tamper with the broadcast of the leader vertex (via e.g., Denial of Service \cite{a_framework_for_classifying_denial_of_service_attacks}), this is done via a global perfect coin. 
This protocol (orange layer on Fig.\ref{fig:layers_dagrider}) provides a ``$\mathtt{cflip}$'' primitive that eventually returns the identity of the leader once at least $f+1$ distinct nodes called $\mathtt{cflip}$. 
This may be implemented via threshold signatures \cite{practical_threshold_signatures}.


Once a leader is selected at column $c = 1 + w*4$, the algorithm first verifies that there are at least $2*f+1$ strong paths between it and vertices at column $4 + w*4$. 
If this is not the case, the leader is skipped.
Otherwise, a new wave is formed, containing all the not-yet ordered vertices in the causal sub-graph of the leader.
This corresponds to the output of ``get wave'' on Fig.\ref{fig:layers_dagrider}.
As per \cite{all_you_need_is_dag}, the vertices of the wave are then ordered using a certain deterministic order ``order wave''.
This results in a total ordering of the transactions, which are then finalized.



