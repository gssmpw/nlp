\section{Limitations and Future Work}
Our work demonstrates the potential of code shaping as a novel interaction paradigm, but we acknowledge several limitations.
First, while our evaluation utilized Python as the programming language, its flexibility and dynamic nature make it a suitable testbed for prototyping various programming paradigms, including object-oriented, functional, and procedural styles. \rev{Code shaping is not inherently bound to Python or any specific language, as the ink annotations are not tied to computational semantics. While this suggests it might work with other languages, the user experience might differ and required future work to explore how different programming languages potentially influence the effectiveness and usability of sketch-based code editing.}
% However, Pythonâ€™s specific syntax and semantics may limit the generalizability of our findings to other programming languages, particularly those with more rigid type systems or different paradigms. 
% Future work should investigate the application of code shaping across a broader range of languages and environments to determine how different language features impact the effectiveness and usability of sketch-based code editing.

Second, the current implementation primarily focuses on small codebases (78 lines of code from scenario two), where the relationship between sketches and corresponding code edits is relatively straightforward. \rev{Sketching to edit larger codebases across multiple files might require the implementation of retrieval-augmented generation~\cite{zhang2023repocoder}. Additionally, resolving downstream and upstream implications of code edits, such as propagating variable renames or function refactorings, would require dependency analysis and incremental static analysis techniques to track and update references across the codebase. Currently, these dependencies are implicitly managed by the AI model, but implementing explicit dependency resolution mechanisms, such as abstract syntax tree (AST) traversal or control flow graph (CFG) augmentation, may be necessary for handling larger, interdependent codebases effectively.} This may further involve developing more sophisticated AI models capable of understanding and interpreting complex sketches that span multiple levels of abstraction or integrating visual modeling tools directly within the code editor. Similarly, \rev{while our system supports multiple files as demonstrated in the scenarios, we did not conduct a comprehensive evaluation or support a single ``sketch'' spanning across multiple interdependent files.} Investigating how code shaping can support multi-file editing, maintain context across files, and handle dependencies effectively will be crucial for extending the applicability of this approach to more complex development tasks.
% Future research should explore techniques to facilitate the mapping between these higher-level semantic components and the actual code blocks. 
% Furthermore, the current implementation of our system is a proof-of-concept prototype rather than a fully integrated development environment (IDE). We intentionally focused on exploring the core concept of code shaping with minimal functionality to understand essential design components. However, future research should consider developing and evaluating a fully functional code editor that supports code shaping, complete with advanced features like version control, real-time collaboration, debugging, and integrated testing tools. This would provide a more realistic assessment of how code shaping can be adopted in professional software development environments and identify additional design considerations that may arise in a full-scale implementation.
Finally, our study provides initial insights into the potential of code shaping, but further investigation is required to understand its long-term impact on programming practices, particularly in terms of code quality, maintainability, and developer productivity. \rev{We define code shaping in the context of code editing, where sketches are not persistent since they are removed once committed changes are accepted or rejected, or manually deleted. Future research could explore whether versioning sketches is a desirable feature. This could be beneficial for other coding activities such as resolving merge conflicts, refactoring, or asynchronous collaboration.}