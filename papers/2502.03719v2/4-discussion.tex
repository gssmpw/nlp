\section{Discussion}
We discussed participants' multi-level abstraction approaches to shape code, the use of sketches to constrain generated code edits and the design implications of code shaping as a new input paradigm.

\subsection{Interacting with Code Across Multiple Levels of Abstraction}
A program is an inherently abstract entity, lacking a fixed form, and can be conceptualized in various ways—from its tangible output, such as a web page, to the underlying code syntax~\cite{hartmanis1994turing}. 
In this paper, we explored the use of sketches as a medium for programmers to express how they envision code modifications across different levels of abstraction~\cite{10.1145/3526113.3545617, 9127262, 10.1145/3654777.3676357}.
Our initial findings revealed that participants used diverse methods to convey their intentions: some drew visualizations, others provided natural language instructions, and some simply wrote pseudocode. This flexibility stands in contrast to prior methods that rely on one-to-one mappings, such as natural language directly translated to code, predefined visual programming objects, or output-directed programming, where manipulation of output changes the underlying code. 


While this paper does not focus on the detailed translation of sketches from various abstraction levels into code, our classification of elements that programmers include in their sketches offers a compelling starting point. 
For instance, in the third stage of the study, we observed that two participants expected the generated code to retain specific function names with underscores as a convention used in Python. However, the AI modified these names to follow a ``camelCase'' format for consistency with other generated code edits. This suggests that while code shaping provides high-level constraints on where and how code edits should occur, the finer details of translating between different abstractions, such as which stylistic elements to preserve, deserve further exploration. Investigating which aspects of sketches should remain consistent and which can adapt in terms of structure or format presents an intriguing direction for future research~\cite{bff9b250-7640-39e2-8f34-329fd1552822}.

\rev{
\subsection{Scope of Sketches}
Code shaping represents the concept of sketching on and around code to perform edits by bridging freeform sketching, AI interpretation, and code. Based on participant tasks, sketches were categorized into commands (intended actions), parameters (supplementary details), and targets (specific areas to edit), see \autoref{fig:arrow-variants}. These sketches often included text, annotation primitives, code syntax, or symbols, and participants occasionally extended them to diagrams, visualizations, or symbolic visuals.

Our findings highlight several tradeoffs in using different sketch representations. First, there is a cost of structure. Participants often preferred minimal-effort annotations that were effective, as creating detailed sketches required significant effort, consistent with information sensemaking \cite{russell_cost_1993}. Second, while the current model can handle many low-level operations (e.g., deleting code, renaming variables, or wrapping lines in functions), participants sometimes opted to type directly for efficiency in Study 1 (e.g., P2 and P4). This suggests a need for integrating primitive gestures, as demonstrated in our third iteration and explored in prior studies~\cite{samuelsson_towards_2023}. Lastly, abstract sketches, though semantically rich, are often difficult to be evaluated and required iterative refinement to align with linguistic code forms. Future research can focus on exploring other types of feedforward interpretation introduced in Sec.~\ref{sec:feedforward}.

Overall, code shaping does not attempt to dictate the boundaries of user expression or current model capability. Instead, it seeks to classify sketching approaches, highlight tradeoffs, and offer actionable insights for designing interaction. Our study revealed that participants' sketches were highly flexible, adapting to AI performance and specific contexts, making their scope inherently malleable.
For example, in Task 2, some participants used arrows to signify variable type changes, like ``(int, int) $\rightarrow$ (int, string)'', while others annotated function parameters directly. 
Although both text and symbols were interpreted correctly, the model struggled to map between the sketch to the intended edits accurately due to the ambiguity inherent in context-dependent sketches. 
These challenges emphasize the critical role of iteration in code shaping, where users refine their sketches, receive feedforward, and adjust their input to better convey intent.
% These challenges highlight the importance of the iterative process supported by code shaping, where users refine their sketches, receive feedforward, and adjust their input to clarify intent.
}


\subsection{Shaping AI Output with Sketches}
While we did not compare sketches to textual prompts directly, some participants (5/18) across the three stages noted that the spatial nature of sketches helped them convey how they wanted to edit \pquote{with more control}{p7}. This suggests a balance between the freedom offered by sketches and the constraints imposed by AI interpretation of code edits. Code shaping tackles this challenge by using freeform sketches to guide the AI interpretation of where and how code edits should be applied, written, performed, or referenced.
Traditional AI-driven code generation tools typically rely on natural language input or UI elements drawn on separate canvases, generating code from different mediums without directly interacting with the code itself. 
This can lead to almost limitless variations in the way natural language is mapped to code structures, which may not always align with the intent of the programmer~\cite{liu_what_2023}.
\rev{One approach exploring the concept of programmable ink, illustrating the potential of combining sketching with computational workflows by enabling users to bind sketches to data and explore outputs dynamically~\cite{inkbase, xia2017writlarge,xia2018dataink, offenwanger2024datagarden}.
However, their focus on binding sketches to predefined computational roles can limit their flexibility for scenarios like code shaping, where the emphasis lies on annotations as interpretative guides rather than functional artifacts. 
Code shaping, therefore, differentiates itself by intentionally keeping sketches free from intrinsic computational meaning but remains the capability to shape AI interpretation by layering sketches on code.}
% Code shaping employs annotations, such as arrows pointing to specific code locations or pseudocode defining program structures, that combine spatial drawings and textual elements. This approach offers an integrated way to express code edits, providing higher-level constraints to guide how the AI interprets and modifies the code. 
The combination of sketches and handwritten textual instructions for prompting enhances the precision of the edits while maintaining flexibility~\cite{haught2003creativity}, and balances creative freedom with the necessary structure to achieve desired outcomes.




\subsection{Informal and Formal Programming}
% semi-formal programming; constraint (spatial mapping and reasoning); between freeform sketches and the needed constraint for programming. (sometimes the user sketches just not correct, AI not gonna generate anything) -- connected to the following section.
Our findings show that when participants are provided with a pen to code, they approach the program differently (\autoref{sec:conceptual_shift}), 
This approach highlights the contrast between the structured nature of typing code syntax and the more abstract thinking about program structure, flow, and function.
\rev{Code shaping, unlike previous programming-by-example approaches~\cite{10.1145/22627.22349}, extends current programming paradigms by integrating code and sketches, allowing programmers to interact with their work in ways that balance structural precision with creative flexibility (\autoref{fig:classification}). 
This aligns with Olsen’s heuristics \cite{10.1145/1294211.1294256} by demonstrating high expressive leverage and reducing solution viscosity since users can achieve complex edits without articulating structured forms of representation, all while maintaining creative flexibility and structural precision.}

The domain of programming presents a unique opportunity for study, as code takes various shapes highly dependent on its substrate, ranging from editor-based code to syntax within diagrams, visualizations, user interfaces, and even comics~\cite{10.1145/3526113.3545617}.
While there are ongoing discussions comparing differences between text-based programming with higher-level representations~\cite{10.1145/3399715.3399821, noone2018visual}, code shaping aims not to replace typing but to expand the programmer's interaction palette. 
Rather than viewing our research solely as a problem-solving method~\cite{10.1145/3025453.3025765}, we explore new insights and design possibilities emerging from evolving technology~\cite{10.1145/3468505}.
The historical progression from handwritten programs and sketches on printouts to punch cards and eventually typing in an editor illustrates how each programming paradigm unveils unique affordances and constraints~\cite{arawjo_write_2020}. We envision a shared future where programmers can approach their craft through diverse methods, both formal and informal~\cite{pollock2024designing}.
Future research can explore additional representations that bridge the gap between established typed input conventions and the dynamic possibilities of sketch-based interactions, further enriching the programming experience.