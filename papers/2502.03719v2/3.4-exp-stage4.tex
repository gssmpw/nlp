\section{Example Use Case Scenarios}
% considering the ink as dynamic that connect with the code syntax
We demonstrate how code-shaping could integrate with current programming practice in two usage scenarios. The interactions and user interface features to support these are real, we only had to modify the study prototype to support multiple files. Back-end infrastructure, like syncing code with a desktop editor is not implemented. Also see the accompanying video to view these scenarios.
% \dv{I re-framed the intro with more transparency about what works and what doesn't}

\subsection{Programming on the Couch}
\rev{ Alicia, a data scientist, is improving a machine-learning preprocessing pipeline distributed across multiple files. She wants to introduce flexible scaling and proper categorical encoding for both training and testing datasets. Seeking a fresh perspective, Alicia grabs her tablet and opens the Code Shaping editor to explore solutions.

To start, Alicia opens the editor support code shaping paradigm and runs the current code. She observes that the output does not handle categorical data correctly. Beside the data processing pipeline code, Alicia draws a flowchart directly on the tablet’s screen, visually aligning sketches to the vertical layout of the code. This flowchart proposes a branching structure starting from the code, \inlinecode{def preprocess\_pipeline} $\rightarrow$ 
% \emph{numerical: (min-max) || categorical: (one-hot encode)} 
\includegraphics[height=14pt]{figures/small_examples/flowchart.png}
$\rightarrow$ \inlinecode{processed data}.
The system’s feedforward interpretation (\autoref{fig:third-interface}c) \includegraphics[height=12pt]{figures/small_examples/onehot_interpretation.png} and the gutter (\autoref{fig:third-interface}d) highlights the affected lines, showing that the code will now include a one-hot encoding step where previously categorical features were ignored \includegraphics[height=10pt]{figures/small_examples/gutter_indication.png}. Alicia commits these changes using the commit button (\autoref{fig:third-interface}f) and then re-runs the code. The updated pipeline applies one-hot encoding to categorical features as intended. However, Alicia notices the code still ignores the \inlinecode{scaling} parameter.

To address this, Alicia decides to refine her sketches without losing her previous changes. She uses a one-finger tap-and-drag gesture (\autoref{fig:third-interface}a) to select the existing flowchart elements. She taps and drags downward on part of the numerical branch to create space and adds a new annotation: \emph{min-max $\rightarrow$} \includegraphics[height=10pt]{figures/small_examples/or_standardize.png}.
The feedforward interpretation and gutter again indicates what text being recognized and which code lines will be altered. Alicia commits these changes, and the editor transiently highlights the updated code snippet (\autoref{fig:third-interface}e). 
With the pipeline now meeting her requirements, Alicia draws a check mark to finalize the changes and remove any temporary sketches (\autoref{fig:third-interface}f). She re-runs the pipeline and confirm that the changes consider the \inlinecode{scaling} parameter. 
% \rev{
% Alicia, a data scientist, is tasked with refining a preprocessing pipeline for training and testing datasets used in a machine-learning workflow. The current pipeline has inconsistencies in numerical scaling and categorical encoding, and lacks a unified structure to handle both datasets. Seeking a fresh perspective, Alicia grabs her tablet and opens the Code Shaping editor to explore solutions.

% Alicia starts by analyzing the existing \inlinecode{preprocess\_pipeline} function, which only supports min-max scaling for numerical features and ignores categorical columns. She inspects the pipeline and identifies issues: standardization is hard without flexible numerical scaling, categorical features require encoding, and no consistent structure for applying transformations across datasets.
% To address these, Alicia sketches a flowchart beside the function, outlining a preprocessing pipeline with two branches, \pquote{Numerical → Scale (min-max/standardize)} and \pquote{Categorical → One-hot encode}, then draws arrows pointing to a merging node labeled \pquote{Processed Data}.
% The system provides a feedforward interpretation (\autoref{fig:third-interface}c,d), suggesting a preprocessing function with branching logic. However, the AI misinterprets the scaling logic, applying min-max scaling to all numerical features.

% To refine the new pipeline logic, Alicia duplicates part of her flowchart sketch using the tap-and-drag feature (\autoref{fig:third-interface}a). She selects the \pquote{Numerical → Scale (min-max)} branch, taps and drags it to duplicate the sketch, and then modifies the duplicate to annotate \pquote{Numerical → Scale (standardize)}. This clearly separates the scaling methods.
% Next, Alicia deletes a redundant arrow in her flowchart. She taps and drags across the unnecessary sketch element and selects \pquote{Delete} from the contextual menu (\autoref{fig:third-interface}a).
% With the refined sketch, the system reinterprets and updates its feedforward interpretation, showing the updated branching logic.
% Satisfied with the updated feedback, Alicia taps the \pquote{Commit} button (\autoref{fig:third-interface}e), seeing the code changes with diff highlighting. She then draws a check mark to integrate the changes into the function (\autoref{fig:third-interface}f) and her sketches are automatically removed, leaving a clean editor.
% Alicia tests the updated pipeline by running the \inlinecode{preprocess\_pipeline} function on both training and testing datasets. The system displays the output in the integrated console, showing correctly scaled numerical features and one-hot encoded categorical features.
}

% Alicia, a software engineer, is grappling with a complex refactoring task for a machine-learning pipeline. After hours at her workstation, she decides a change of scenery might help her think through the problem. She grabs her tablet and settles onto her living room couch, determined to work through it with some key code edits. This approach might help her better sort out abstract ideas \cite{goel1995sketches, tversky2002sketches, cherubini_lets_2007, victor2013media}.

% Opening the code shaping editor on her tablet, Alicia navigates to the main \inlinecode{preprocess\_data} function. She knows this function is a bottleneck, especially for large datasets. With a stylus, she begins sketching editing ideas directly on the code. She draws a bracket encompassing the entire function and jots down \pquote{parallelize} next to it. Then, she sketches a quick flowchart showing how the data could be split into separate streams for categories A and B.
% As she sketches, always-on feedforward AI interpretation highlights the affected code sections and suggests potential parallel processing implementations (\autoref{fig:third-interface} C-E). Encouraged, Alicia adds more detail to her plan. She circles the \inlinecode{complex\_calculation\_a} and \inlinecode{complex\_calculation\_b} function calls, drawing arrows to the side margin where she writes \pquote{vectorize}. The system responds by highlighting similar patterns in other parts of the codebase where vectorization has been applied.

% Alicia taps the commit button to accept the code modifications so far. The new version of the function introduces multiprocessing with \inlinecode{mp.Pool()} and numpy vectorization. 
% Alicia reviews the generated code, noting how it aligns with her high-level sketches.
% Alicia accepts most of the changes by drawing check-marks on the highlighted edits, but decides to iterate more on some lines of code. She draws a cross over the \inlinecode{return} statement and sketches a quick sort operation, indicating she wants the data recombined in its original order. The system updates the code to maintain the original data order, and she commits the edit with a check-mark.
% Alicia has made significant progress on a problem that had stumped her before, this has been a productive break from sitting at her desk.
% The ability to freely sketch her ideas directly on the code, seeing them instantly transformed into working implementations, has unlocked her creativity and problem-solving skills. Satisfied with her evening's work, she saves the changes and makes a note to share this breakthrough with her team tomorrow. The code shaping interface has not only allowed her to work comfortably from her couch but has also helped her bridge the gap between high-level problem-solving and concrete code implementation.

\subsection{Collaborative Code Reviewing Meeting}
Blair and Carol, senior software developers at a fintech startup, stand before a large interactive whiteboard running the code shaping interface. They are reviewing the core \inlinecode{process\_transaction} function of their payment system.
Blair loads the function into the editor on the board. Carol, stylus in hand, circles a block of nested if-statements for transaction validation. \pquote{These lines are slowing us down} she says, sketching a flowchart beside the code illustrating a streamlined process with early returns.
The system highlights the affected code sections, showing how Carol's sketch translates to code changes. Blair adds to the sketch, drawing parallel arrows for certain validation steps, suggesting \pquote{What if we run these checks concurrently?}.

Carol taps the commit button to see the final edits, but then spots a potential race condition in the new parallel structure. Blair undoes the modifications with a two-finger doubletap, and Carol sketches a new flow with the word \pquote{async} for concurrent validation.
While editing this section of code, Blair notices an opportunity to optimize database queries. He circles lines of code making multiple separate queries and draws a diagram of a batched query approach, consisting of a few boxes representing queries connected by arrows flowing into a single ``batched query'' box.
The AI model modifies the code to use a query builder pattern.
Carol points out that this change might affect error handling. She sketches a new try-catch block structure around the batched query execution. The system modifies the code based on her sketch, with the changes highlighted in green as staged edits.
As they near the end of their session, Blair and Carol review their changes holistically. They use check-marks to accept desired modifications and crosses to reject others, iterating through the highlighted sections.

% As they work, they encounter a complex algorithmic challenge in the transaction matching logic. Blair sketches out three alternative approaches directly on the code. With a swipe gesture, they create three parallel versions of the function to compare these approaches side-by-side.
% They implement each version using a mix of sketching high-level logic and directly manipulating code. The system helps fill in the details, suggesting optimizations and pointing out potential issues in each implementation.
% After running benchmarks on all three versions, they use pinch and zoom gestures to focus on the most promising approach. Carol refines this version further, smoothly transitioning between sketching architectural ideas and tweaking individual lines of code.
% Finally, they export their work: the revised code, a visual summary of their sketches and decision process, and the benchmark results. This comprehensive output is automatically added to their team's documentation system, ready for wider review and implementation.