@inproceedings{arawjo_notational_2022,
	address = {New York, NY, USA},
	series = {{UIST} '22},
	title = {Notational {Programming} for {Notebook} {Environments}: {A} {Case} {Study} with {Quantum} {Circuits}},
	isbn = {978-1-4503-9320-1},
	shorttitle = {Notational {Programming} for {Notebook} {Environments}},
	url = {https://dl.acm.org/doi/10.1145/3526113.3545619},
	doi = {10.1145/3526113.3545619},
	abstract = {We articulate a vision for computer programming that includes pen-based computing, a paradigm we term notational programming. Notational programming blurs contexts: certain typewritten variables can be referenced in handwritten notation and vice-versa. To illustrate this paradigm, we developed an extension, Notate, to computational notebooks which allows users to open drawing canvases within lines of code. As a case study, we explore quantum programming and designed a notation, Qaw, that extends quantum circuit notation with abstraction features, such as variable-sized wire bundles and recursion. Results from a usability study with novices suggest that users find our core interaction of implicit cross-context references intuitive, but suggests further improvements to debugging infrastructure, interface design, and recognition rates. Throughout, we discuss questions raised by the notational paradigm, including a shift from ‘recognition’ of notations to ‘reconfiguration’ of practices and values around programming, and from ‘sketching’ to writing and drawing, or what we call ‘notating.’},
	urldate = {2024-04-10},
	booktitle = {Proceedings of the 35th {Annual} {ACM} {Symposium} on {User} {Interface} {Software} and {Technology}},
	publisher = {Association for Computing Machinery},
	author = {Arawjo, Ian and DeArmas, Anthony and Roberts, Michael and Basu, Shrutarshi and Parikh, Tapan},
	month = oct,
	year = {2022},
	keywords = {computational notebooks, pen-based interfaces, programming paradigms, quantum computing},
	pages = {1--20},
}

@inproceedings{arawjo_write_2020,
	address = {New York, NY, USA},
	series = {{CHI} '20},
	title = {To {Write} {Code}: {The} {Cultural} {Fabrication} of {Programming} {Notation} and {Practice}},
	isbn = {978-1-4503-6708-0},
	shorttitle = {To {Write} {Code}},
	url = {https://dl.acm.org/doi/10.1145/3313831.3376731},
	doi = {10.1145/3313831.3376731},
	abstract = {Writing and its means have become detached. Unlike written and drawn practices developed prior to the 20th century, notation for programming computers developed in concert and conflict with discretizing infrastructure such as the shift-key typewriter and data processing pipelines. In this paper, I recall the emergence of high-level notation for representing computation. I show how the earliest inventors of programming notations borrowed from various written cultural practices, some of which came into conflict with the constraints of digitizing machines, most prominently the typewriter. As such, I trace how practices of "writing code" were fabricated along social, cultural, and material lines at the time of their emergence. By juxtaposing early visions with the modern status quo, I question long-standing terminology, dichotomies, and epistemological tendencies in the field of computer programming. Finally, I argue that translation work is a fundamental property of the practice of writing code by advancing an intercultural lens on programming practice rooted in history.},
	urldate = {2024-04-11},
	booktitle = {Proceedings of the 2020 {CHI} {Conference} on {Human} {Factors} in {Computing} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Arawjo, Ian},
	month = apr,
	year = {2020},
	keywords = {culture, infrastructure, materiality, notation, programming},
	pages = {1--15},
}

@article{barke_grounded_2022,
	title = {Grounded {Copilot}: {How} {Programmers} {Interact} with {Code}-{Generating} {Models}},
	url = {http://arxiv.org/abs/2206.15000},
	abstract = {Powered by recent advances in code-generating models, AI assistants like Github Copilot promise to change the face of programming forever. But what is this new face of programming? We present the first grounded theory analysis of how programmers interact with Copilot, based on observing 20 participants--with a range of prior experience using the assistant--as they solve diverse programming tasks across four languages. Our main finding is that interactions with programming assistants are bimodal: in acceleration mode, the programmer knows what to do next and uses Copilot to get there faster; in exploration mode, the programmer is unsure how to proceed and uses Copilot to explore their options. Based on our theory, we provide recommendations for improving the usability of future AI programming assistants.},
	author = {Barke, Shraddha and James, Michael B. and Polikarpova, Nadia},
	month = jun,
	year = {2022},
	note = {arXiv: 2206.15000},
	keywords = {subtask, ⛔ No DOI found},
}

@inproceedings{cherubini_lets_2007,
	address = {New York, NY, USA},
	series = {{CHI} '07},
	title = {Let's go to the whiteboard: how and why software developers use drawings},
	isbn = {978-1-59593-593-9},
	shorttitle = {Let's go to the whiteboard},
	url = {https://dl.acm.org/doi/10.1145/1240624.1240714},
	doi = {10.1145/1240624.1240714},
	abstract = {Software developers are rooted in the written form of their code, yet they often draw diagrams representing their code. Unfortunately, we still know little about how and why they create these diagrams, and so there is little research to inform the design of visual tools to support developers' work. This paper presents findings from semi-structured interviews that have been validated with a structured survey. Results show that most of the diagrams had a transient nature because of the high cost of changing whiteboard sketches to electronic renderings. Diagrams that documented design decisions were often externalized in these temporary drawings and then subsequently lost. Current visualization tools and the software development practices that we observed do not solve these issues, but these results suggest several directions for future research.},
	urldate = {2024-08-26},
	booktitle = {Proceedings of the {SIGCHI} {Conference} on {Human} {Factors} in {Computing} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Cherubini, Mauro and Venolia, Gina and DeLine, Rob and Ko, Amy J.},
	month = apr,
	year = {2007},
	pages = {557--566},
}

@inproceedings{horvath_using_2022,
	address = {New York, NY, USA},
	series = {{UIST} '22},
	title = {Using {Annotations} for {Sensemaking} {About} {Code}},
	isbn = {978-1-4503-9320-1},
	url = {https://dl.acm.org/doi/10.1145/3526113.3545667},
	doi = {10.1145/3526113.3545667},
	abstract = {Developers spend significant amounts of time finding, relating, navigating, and, more broadly, making sense of code. While sensemaking, developers must keep track of many pieces of information including the objectives of their task, the code locations of interest, their questions and hypotheses about the behavior of the code, and more. Despite this process being such an integral aspect of software development, there is little tooling support for externalizing and keeping track of developers’ information, which led us to develop Catseye – an annotation tool for lightweight notetaking about code. Catseye has advantages over traditional methods of externalizing code-related information, such as commenting, in that the annotations retain the original context of the code while not actually modifying the underlying source code, they can support richer interactions such as lightweight versioning, and they can be used as navigational aids. In our investigation of developers’ notetaking processes using Catseye, we found developers were able to successfully use annotations to support their code sensemaking when completing a debugging task.},
	urldate = {2023-06-16},
	booktitle = {Proceedings of the 35th {Annual} {ACM} {Symposium} on {User} {Interface} {Software} and {Technology}},
	publisher = {Association for Computing Machinery},
	author = {Horvath, Amber and Myers, Brad and Macvean, Andrew and Rahman, Imtiaz},
	month = oct,
	year = {2022},
	keywords = {Annotations, code comprehension, notetaking, sensemaking, software engineering},
	pages = {1--16},
}

@article{maalej_comprehension_2014,
	title = {On the {Comprehension} of {Program} {Comprehension}},
	volume = {23},
	issn = {1049-331X},
	url = {https://dl.acm.org/doi/10.1145/2622669},
	doi = {10.1145/2622669},
	abstract = {Research in program comprehension has evolved considerably over the past decades. However, only little is known about how developers practice program comprehension in their daily work. This article reports on qualitative and quantitative research to comprehend the strategies, tools, and knowledge used for program comprehension. We observed 28 professional developers, focusing on their comprehension behavior, strategies followed, and tools used. In an online survey with 1,477 respondents, we analyzed the importance of certain types of knowledge for comprehension and where developers typically access and share this knowledge. We found that developers follow pragmatic comprehension strategies depending on context. They try to avoid comprehension whenever possible and often put themselves in the role of users by inspecting graphical interfaces. Participants confirmed that standards, experience, and personal communication facilitate comprehension. The team size, its distribution, and open-source experience influence their knowledge sharing and access behavior. While face-to-face communication is preferred for accessing knowledge, knowledge is frequently shared in informal comments. Our results reveal a gap between research and practice, as we did not observe any use of comprehension tools and developers seem to be unaware of them. Overall, our findings call for reconsidering the research agendas towards context-aware tool support.},
	number = {4},
	urldate = {2024-05-31},
	journal = {ACM Transactions on Software Engineering and Methodology},
	author = {Maalej, Walid and Tiarks, Rebecca and Roehm, Tobias and Koschke, Rainer},
	month = sep,
	year = {2014},
	keywords = {Empirical software engineering, context-aware software engineering, information needs, knowledge sharing, program comprehension},
	pages = {31:1--31:37},
}

@article{mozannar_reading_2022,
	title = {Reading {Between} the {Lines}: {Modeling} {User} {Behavior} and {Costs} in {AI}-{Assisted} {Programming}},
	url = {http://arxiv.org/abs/2210.14306},
	abstract = {AI code-recommendation systems (CodeRec), such as Copilot, can assist programmers inside an IDE by suggesting and autocompleting arbitrary code; potentially improving their productivity. To understand how these AI improve programmers in a coding session, we need to understand how they affect programmers' behavior. To make progress, we studied GitHub Copilot, and developed CUPS -- a taxonomy of 12 programmer activities common to AI code completion systems. We then conducted a study with 21 programmers who completed coding tasks and used our labeling tool to retrospectively label their sessions with CUPS. We analyze over 3000 label instances, and visualize the results with timelines and state machines to profile programmer-CodeRec interaction. This reveals novel insights into the distribution and patterns of programmer behavior, as well as inefficiencies and time costs. Finally, we use these insights to inform future interventions to improve AI-assisted programming and human-AI interaction.},
	author = {Mozannar, Hussein and Bansal, Gagan and Fourney, Adam and Horvitz, Eric},
	month = oct,
	year = {2022},
	note = {arXiv: 2210.14306},
	keywords = {⛔ No DOI found},
}

@inproceedings{parnin_evaluating_2010,
	address = {New York, NY, USA},
	series = {{CHI} '10},
	title = {Evaluating cues for resuming interrupted programming tasks},
	isbn = {978-1-60558-929-9},
	url = {https://dl.acm.org/doi/10.1145/1753326.1753342},
	doi = {10.1145/1753326.1753342},
	abstract = {Developers, like all modern knowledge workers, are frequently interrupted and blocked in their tasks. In this paper we present a contextual inquiry into developers' current strategies for resuming interrupted tasks and investigate the effect of automated cues on improving task resumption. We surveyed 371 programmers on the nature of their tasks, interruptions, task suspension and resumption strategies and found that they rely heavily on note-taking across several types of media. We then ran a controlled lab study to compare the effects of two different automated cues to note taking when resuming interrupted programming tasks. The two cues differed in (1) whether activities were summarized in aggregate or presented chronologically and (2) whether activities were presented as program symbols or as code snippets. Both cues performed well: developers using either cue completed their tasks with twice the success rate as those using note-taking alone. Despite the similar performance of the cues, developers strongly preferred the cue that presents activities chronologically as code snippets.},
	urldate = {2024-08-26},
	booktitle = {Proceedings of the {SIGCHI} {Conference} on {Human} {Factors} in {Computing} {Systems}},
	publisher = {Association for Computing Machinery},
	author = {Parnin, Chris and DeLine, Robert},
	month = apr,
	year = {2010},
	pages = {93--102},
}

@inproceedings{raab_refactorpad_2013,
	address = {New York, NY, USA},
	series = {{EICS} '13},
	title = {{RefactorPad}: editing source code on touchscreens},
	isbn = {978-1-4503-2138-9},
	shorttitle = {{RefactorPad}},
	url = {https://dl.acm.org/doi/10.1145/2494603.2480317},
	doi = {10.1145/2494603.2480317},
	abstract = {Despite widespread use of touch-enabled devices, the field of software development has only slowly adopted new interaction methods for available tools. In this paper, we present our research on RefactorPad, a code editor for editing and restructuring source code on touchscreens. Since entering and modifying code with on-screen keyboards is time-consuming, we have developed a set of gestures that take program syntax into account and support common maintenance tasks on devices such as tablets. This work presents three main contributions: 1) a test setup that enables researchers and participants to collaboratively walk through code examples in real-time; 2) the results of a user study on editing source code with both finger and pen gestures; 3) a list of operations and some design guidelines for creators of code editors or software development environments who wish to optimize their tools for touchscreens.},
	urldate = {2023-10-03},
	booktitle = {Proceedings of the 5th {ACM} {SIGCHI} symposium on {Engineering} interactive computing systems},
	publisher = {Association for Computing Machinery},
	author = {Raab, Felix and Wolff, Christian and Echtler, Florian},
	month = jun,
	year = {2013},
	keywords = {editor, gestures, ide, pen, refactoring, source code, surface, tablet, touchscreen},
	pages = {223--228},
}

@inproceedings{samuelsson_towards_2023,
	title = {Towards a {Visual} {Language} for {Sketched} {Expression} of {Software} {IDE} {Commands}},
	url = {https://ieeexplore.ieee.org/abstract/document/10305696},
	doi = {10.1109/VL-HCC57772.2023.00021},
	abstract = {Given that touch- and pen-enabled screens are becoming more ubiquitous - not just in mobile devices, but also in laptop computers and large interactive display walls - we are exploring the potential for using digital ink sketches as a novel interaction modality that would allow users to express commands by drawing on top of an application's user interface with a pen or stylus. We hypothesize that such sketch-based interaction could be particularly useful when several people are collaborating at a large wall-mounted display where a mouse and keyboard are not in convenient reach, e.g. when software engineers undertake a code review. As a step towards building a prototype to evaluate that vision, this paper reports on two studies with professional software engineers to elicit and rate sketched expressions of a variety of commands in an integrated software development environment (IDE). We describe the experimental setup and discuss how the findings can help to define a sketchbased command language for IDEs.},
	urldate = {2024-06-16},
	booktitle = {2023 {IEEE} {Symposium} on {Visual} {Languages} and {Human}-{Centric} {Computing} ({VL}/{HCC})},
	author = {Samuelsson, Sigurdur Gauti and Book, Matthias},
	month = oct,
	year = {2023},
	note = {ISSN: 1943-6106},
	keywords = {Portable computers, Prototypes, Shape, Software, User interfaces, Visualization, Windows, sketching, software development environments, user interfaces, visual languages},
	pages = {115--123},
}

@phdthesis{sutherland_investigation_2017,
	type = {Thesis},
	title = {An {Investigation} into {Freeform}, {Dynamic}, {Digital} {Ink} {Annotation} for {Program} {Code}},
	copyright = {Items in ResearchSpace are protected by copyright, with all rights reserved, unless otherwise indicated. Previously published items are made available in accordance with the copyright policy of the publisher.},
	url = {https://researchspace.auckland.ac.nz/handle/2292/31647},
	abstract = {Understanding program code is cognitively demanding. One tool that has not been investigated previously is using ink freeform annotations to aid understanding of program code. Before we can investigate using freeform annotations for code comprehension there are some user and technical challenges that need answering. An iterative research approach was used for this investigation. A single research question was investigated in each iteration and the results informed the next iteration. In the first iteration, the focus was how and why programmers annotate when understanding program code on paper. The results indicate programmers reading program code use similar types of annotation to those reported for other types of reading. The main reasons for adding annotations were to assist with navigation and offload information from the reader’s memory. In the second iteration, the focus was how to classify digital annotations; a precursor to other operations. The initial phase used a general purpose automatic recogniser but failed to improve on previously reported results. The second phase combined automatic recognition with user input. While this approach resulted in higher classification accuracy, the accuracy rates were still lower than previously reported for sketch-based recognition. An unexpected finding was the participants did not want to classify all annotations during reading. In the third iteration, the focus was how to refit (modify) annotations in response to changes in the underlying text. Four classes of annotation were investigated: horizontal lines, vertical lines, enclosures and connectors. Several refitting algorithms were implemented and evaluated for each class of annotation. The findings indicate there are two preferred approaches for refitting annotations: stretching the annotation or splitting it and adding a visualisation showing where the annotation was split. This thesis makes five main contributions. First, a systematic literature review which provides an overview of the current research. Second, details of how and why programmers annotate code on paper. Third, an implementation of an extensible tool for investigating digital ink annotations on code. Fourth, details on how collaborative intelligence can improve recognition. Fifth, a set of proposals for how to refit annotations based on the annotation classification and user preferences.},
	urldate = {2024-08-27}

