\section{Related Work}
% writing, direct manipulating, sketching, gesture...
% the history of code
% Our research draws deeply from Ian Arawjo's work ``To Write Code''~\cite{arawjo_write_2020}, which examines how programming practices have been culturally and materially shaped over time. 
Historically, the practice of \textit{writing code} has evolved significantly alongside the development of different tools and technologies. Early methods relied on handwritten and drawn notations, reflecting the material and cultural contexts of their time~\cite{arawjo_write_2020}. 
The advent of the typewriter marked a pivotal shift, standardizing typed input as the dominant mode for programming.
% With the emergence of digital interfaces, 
However, multiple explorations into alternative, keyboard-less methods of code manipulation have been conducted. Research has investigated the use of gestures~\cite{murphy2011restructuring}, touch inputs~\cite{tillmann2012touchdevelop, raab_refactorpad_2013, 10.1145/1879211.1879217}, and \rev{voice- or speech-based input~\cite{arnold2000programming, desilets2001voicegrip} for programming. These studies demonstrate a consistent effort to move beyond traditional text-based coding by leveraging different interaction modalities to make programming more accessible.}




These studies demonstrate a consistent effort to move beyond traditional text-based coding by leveraging different interaction modalities to simplify and enhance the coding experience.
\rev{The advent of large language models (LLMs) marks another paradigm shift in the way code is written. With capabilities for code generation and completion from natural language, LLMs have made the long-envisioned concept of literate, unstructured, and natural programming more feasible~\cite{knuth1984literate, bobrow1964natural, weizenbaum1966eliza}. The use of LLM-driven code assistants is transforming programming workflows, as developers increasingly transition from writing code manually to critically evaluating and refining AI-generated code~\cite{barke_grounded_2022, mozannar_reading_2022}.}
While the keyboard remains a central tool, advancements in computer vision and speech recognition are expanding the possibilities of programming, allowing for diverse and multimodal forms of code input and manipulation~\cite{pollock2024designing, horowitz2023live}.
Among these modalities, sketching has attracted significant attention as a flexible and expressive method for generating code.


\subsection{Generate Code from Sketches}
\label{sec:sketch-to-code}
Prior work has explored the transformation of sketches into code to facilitate rapid prototyping and early-stage design. Tools like SILK~\cite{landay1995interactive, 910894} enable designers to sketch UI elements electronically, turning them into interactive prototypes, thereby supporting flexible sketching and demonstrating the effectiveness of sketch-based methods for generating functional UIs. DENIM~\cite{10.1145/332040.332486} extends this approach by offering a zoomable user interface that supports web design sketches across multiple levels of detail, from high-level site maps to specific page elements.
Other tools, such as Eve~\cite{10.1145/3290607.3312994}, provide a comprehensive sketch-based prototyping workbench that facilitates transitions between low, medium, and high-fidelity prototypes, ultimately generating executable code. More recent approaches, like pix2code~\cite{10.1145/3220134.3220135} and Microsoft's Sketch2Code~\cite{microsoft_sketch2code}, leverage deep learning and computer vision techniques to convert GUI sketches into code for multiple platforms. Although these tools demonstrate the utility of sketches in generating code, they primarily focus on sketching the program output and transforming them into code, rather than using sketches as a direct manipulation method for editing code.

Further, these sketches often exist in separate mediums from the code, and sometimes the code might not even be shown alongside them~\cite{tldraw}. 
This separation makes direct visual-to-code mappings challenging~\cite{cherubini_lets_2007} since code is inherently abstract without definitive representation.
This often results in sketches being transient, as they are attempts to translate fluid visual representations into the structured syntax required by code~\cite{4782972}. The temporary nature of these sketches highlights the difficulty in maintaining a clear mapping between visual sketches and syntactic code structures. Arawjo et al.~\cite{arawjo_notational_2022} introduced notational programming, which integrates small canvases containing handwritten notations within code cells of computational notebooks, showing an initial effort to merge sketches and code. However, this approach maintains only an implicit connection between code and sketches, limiting explicit linkage between handwritten symbols and their textual equivalents.
In contrast, our proposed concept, \textit{code shaping}, goes beyond both notational programming and programming-by-example approaches\cite{10.1145/22627.22349}. It enhances the linkage between sketches and code by allowing programmers to sketch directly on and around the code, resembling a visual programming language. This enables visual planning and referencing of future edits, fostering a more direct and dynamic interaction between sketches and actual code. 
% Unlike these programming-by-example approaches~\cite{10.1145/22627.22349} that generate programs from sketched outputs, code shaping resembles a visual programming language, treating sketches as an input modality for directly manipulating code.
% It enhances the linkage between sketches and code by allowing programmers to directly sketch on and around the code. This enables them to visually plan and reference future edits, fostering a more direct and dynamic interaction between sketches and the actual code. 








% % % sketching on code
% % Towards a Visual Language for Sketched Expression of Software IDE Commands
% % Eliciting Sketched Expressions of Command Intentions in an IDE


% DataInk and InkSight help data scientists transforming sketched visualizations into the code.
% However, these systems typically transform sketches into code without directly interacting with the actual text of the code. They focus more on converting the semantic meaning of sketches into code rather than integrating them with the syntax of existing textual code.


%  \begin{figure}
% \centering
%   \includegraphics[width=.9\linewidth]{figures/spectrum.pdf}
%   \caption{A spectrum from the syntactic code of the program to the semantic graphical notations. The higher the degrees of freedom (on the right), the greater the deviation from the code syntax and \textit{code shaping} aims to bridge this divide.}
%   \Description{This is the teaser description for screen readers.}
%   \label{fig:spectrum}
% \end{figure}



\subsection{Annotating and Planning Code with Sketches}
Programmers often use sketches, highlights, and external notes to annotate code for better comprehension, resource tracking, progress monitoring, and peer communication~\cite{maalej_comprehension_2014, sutherland_investigation_2017}. Several systems have been developed to support these annotation practices. For instance, Synectic IDE~\cite{synectic} facilitates linking and annotating code files to assist in programming tasks. However, for annotations to be effective, they should be integrated directly into the code editor or positioned close to the code to help programmers maintain their workflow~\cite{parnin_evaluating_2010}.
Annotations lacking context from surrounding code can hinder understanding of their implications for future edits~\cite{maalej_comprehension_2014}. Systems like Catseye have addressed this issue by enabling programmers to add contextually linked annotations alongside the code editor, serving as a note-taking tool~\cite{horvath_using_2022}.
However, Catseye's annotations are limited to typed textual notes linked to code snippets, lacking the flexibility offered by freeform sketches.
% 
Recent research in software engineering has focused on developing integrated development environments (IDEs) that allow programmers to sketch directly on the code editor for note-taking, such as CodeAnnotator~\cite{10.1145/1324892.1324935} and CodeGraffiti~\cite{10.1145/1866218.1866260}.
However, similar to the sketch-to-code approaches discussed in \autoref{sec:sketch-to-code}, these sketches primarily serve as static externalizations of users' thoughts rather than interactive mediums for code manipulation.
Consequently, sketches and programs remain separate modalities with distinct affordances. This limitation restricts the practical application of sketching on code to scenarios involving code comprehension or collaborative discussions.
% While inline comments are the most straightforward method for planning code edits, several studies have explored the use of free-form annotations, primarily in the context of code comprehension~\cite{10.1145/1324892.1324935, sutherland_investigation_2017}. 
% These free-form annotations help externalize tacit knowledge, reducing disruptions to the programmer's thought process~\cite{5069490}. 
% However, using annotations specifically for planning future code edits, whether within the code editor, on a whiteboard, or on printed source code, remains less common. \jz{less common -> under-explored. In general, I feel we need to defend ourselves more with respect to the above literature. It is not entirely clear where the gaps are.}




% This gap is largely due to the fundamental differences between code and general text, presenting unique challenges in annotation on code. 
However, integrating sketch-based annotations for planning code edits with subsequent code modifications presents significant challenges due to the inherent nature of the program.
First, the dynamic and interdependent nature of code means changes in one part can have cascading effects across the entire codebase, complicating the predictive power of annotations. Second, the code's non-linear nature, where functions, variables, and classes interact in complex, non-sequential ways, requires annotations to account for these intricate relationships. Third, the rigid syntax and structure of code demand precise and well-integrated annotations, unlike the more flexible and informal notes used in text editing.
Despite these challenges, using sketched annotations for planning code edits could play a significant role in software development~\cite{cherubini_lets_2007}.
Samuelsson et al. investigated common sketches for standard code editor commands, such as inserting or searching code~\cite{samuelsson_towards_2023}. However, they only considered using sketches as replacements for common IDE commands, similar to previous research using gestures to replace keyboard shortcuts~\cite{raab_refactorpad_2013}.
Our research, in contrast, explores the potential of transforming these annotations into actionable commands for \textit{code editing}, allowing programmers to make annotations and edits without constant context switching between code and external spaces like canvases or paper.

% However, we have little understanding of how programmers plan it with sketches on the code itself rather than through other mediums representing higher-level abstractions.


% Programmers annotate code to enhance understanding of a program [37, 41], keep track of useful resources [34], monitor task progress [36, 41], and share information with peers [37].
% % An Investigation into Freeform, Dynamic, Digital Ink Annotation for Program Code
% Compared to inline comments, programmers use sketches, highlights, and external notes to differentiate from text,
% % A Historical and Contemporary Study on Annotations to Derive Key Features for Systems Design
% which also persist longer through various stages of the code's lifecycle.
% % A Comparison of Reading Paper and On-line Documents
% Most importantly, these free-form annotations reduce disruptions to programmers' flow of thought,
% % Understanding How Programmers Can Use Annotations on Documentation
% helping programmers express their intentions more freely by externalizing tacit information [38, 39].


% While most studies focus on free-form code annotations for code comprehension,
% % An Investigation into Freeform, Dynamic, Digital Ink Annotation for Program Code
% a large survey found that many annotations are used to prepend future TODO tasks.
% % Eliciting Sketched Expressions of Command Intentions in an IDE
% % Towards a Visual Language for Sketched Expression of Software IDE Commands
% Several studies investigate how programmers annotate code to specify intended future changes. These studies categorize annotations into components like Command (the intended operation), Parameter (necessary details for the command), and Selection (the context for parameters and commands).
% These comments can help programmers recover work they left off and can also be used to communicate with others.
% % Design and Development of a Sketch Recognition Component for a Software IDE
% One study further developed a system supporting `command-ink', allowing users to express commands in software tools such as integrated development environments (IDEs). 

% While these studies analyze common annotations and scenarios, they do not support transforming annotations into actions, such as code editing or refactoring. A major challenge is that, despite advances in sketch recognition, the opaque nature of user sketches hinders accurate interpretation. This issue affects not only models but also human collaborators, who may perceive the same annotations differently. Consequently, multiple iterations are required in this annotations-to-action process, forcing programmers to switch from sketching to typing, disrupting their workflow.
% Thus, our research aims to explore designs that support iteration and recovery from common errors when transforming programmers' free-form annotations on code into actions of editing and refactoring.

% % % sensemaking
% % Understanding How Programmers Can Use Annotations on Documentation
% % - Prior work has found that developers write short notes, typically
% % as a way to keep track of and externalize important information
% % [ 38 , 39 ]