\section{An FPT algorthm with respect to the lifetime of the temporal graph and the treewidth of the underlying graph}
\label{sec:tw algo}
In this section we show that if a static problem is FPT in the treewidth, then its reconfiguration version is FPT in the treewidth of the footprint (the union of all time-steps) and the lifetime of the temporal graph.
We first introduce definitions specific to this section. Then, using Courcelle's theorem, we show that if the static version is expressable in MSO then the reconfiguration version can be parameterized by the lifetime and the treewidth.

%Finally, we show how to adapt a generic algorithm on a tree decomposition for the static version to the reconfiguration version.


% \subsection{Definitions}

\subsection{Treewidth and tree decompositions}

Tree decompositions are widely used to solve a large class of combinatorial problems efficiently by dynamic programming when the graph has low treewidth. 

\begin{definition}[Treewidth, tree decomposition \cite{BodlaenderK96,Kloks94}]\label{def:TD}
  Given a static graph $G$, a \emph{tree decomposition} of $G$ is a pair $(\mathcal{T},\mathcal{X})$
  where $\mathcal{T}$ is a tree and 
  $\mathcal{X}=\{B_i\mid i\in V(\mathcal{T})\}$ is a multiset of subsets of $V(G)$ (called ``bags'') such that
  \begin{enumerate}[(a)]
    \item for each $uv \in E(G)$, there is some $i$ with $uv \subseteq B_i$ and
    \item for each $v \in V(G)$, the bags $B_i$ containing $v$ form a connected subtree of $\mathcal{T}$.
    \end{enumerate}
    \vspace{0.1cm}
  The width of $(\mathcal{T},\mathcal{X})$ is $\max_{B_i \in \mathcal{X}} |B_i|-1$.
%   Further, $(\mathcal{T},\mathcal{X})$ is called \emph{nice} if
%   \begin{enumerate}[(i)]
%     \item $\mathcal{T}$ is rooted at bag $B_r$, with $B_r = \emptyset$ and each bag has at most two children.
%     \item Each bag $B_i$ of $\mathcal{T}$ has one of the four types:
%       \begin{itemize}
%       \item \textbf{Leaf bag:} $i$ has no children and $B_i = \emptyset$.
%         \item \textbf{Join bag:} $i$ has two children $j$ and $k$ and $B_i = B_j = B_k$.
%         \item \textbf{Introduce vertex $u$ bag:} $i$ has only one child $j$ and $B_j = B_i\setminus\{u\}$.
% %      \item \textbf{Introduce edge $uv$ bag:} $i$ has only one child $j$ and $B_j = B_i$.
%       \item \textbf{Forget $u$ bag:} $i$ has only one child $j$ and $B_j = B_i\cup\{u\}$.
%     \end{itemize}
%   \end{enumerate}
%   \vspace{0.1cm}
% 
  % For any bag $B_i$ of $\mathcal{T}$, we let $\mathcal{T}_i$ denote the subgraph of $G$ containing all vertices and edges that have been introduced ``below'' $B_i$
  % (that is, in a bag of the subtree of $T$ that is rooted at $i$).
\end{definition}

\noindent It is NP-complete to determine whether a graph has treewidth at most $k$~\cite{Arnborg87}. However, there exists a linear-time algorithm that, for any constant $k$, computes a tree-decomposition with treewidth at most $k$, if there is one~\cite{Bodlaender96}.
% \noindent
% Note that for each vertex $u$ of $G$, $(\mathcal{T},\mathcal{X})$ contains exactly one forget $u$ bag.  Bodlaender and Kloks shown that a nice tree decomposition contains at most $\mathcal{O}(|E|\cdot |V|)$ bags~\cite{BodlaenderK96}.
%
% Let $\mathcal{G}=(G,\lambda)$ be a temporal graph. A \emph{temporal tree decomposition} for $\mathcal{G}$ is a tree decomposition $(\mathcal{G},\mathcal{X})$ of the footprint $G$ in which we have replaced every introduce edge $uv$ bag by $|\lambda(uv)|$ introduce lambda edge $(uv,t)$ bag. Formally, let $B_i$ be an introduce edge $uv$ bag with child $B_j$ and parent $B_\ell$ and let $\lambda(uv)= \{t_1,\dots,t_k\}$. We replace remove $B_i$ from the tree decomposition and we introduce $k$ introduce lambda edge $(uv,t)$ bags $B_{t_1},\dots,B_{t_k}$ such that $B_j=B_{t_1}=\dots=B_{t_k}$, $B_{t_1}$ has child $B_j$, $B_\ell$ has child $B_{t_k}$ and for each $t_{x} \in \lambda(uv) \setminus \{t_1\}$, $B_{t_x}$ has child $B_{t_{x-1}}$.
%Notice that a nice tree decomposition contains at most $\mathcal{O}(\tau\cdot|E(G)|\cdot|V(G)|)$.


\paragraph{Monadic second order logic.} % A \emph{relational vocabulary} $\mathcal{R}$ is a set of relation symbols. Each relation symbol $R$  has an arity, denoted $arity(R) > 1$. A structure $\mathcal{A}$ of vocabulary $\mathcal{R}$ , or $\mathcal{R}$-structure, consists of a set $A$, called the \emph{universe}, and an interpretation $R^\mathcal{A} \subseteq A^{arity(R)}$ of each relation symbol $R \in \mathcal{R}$. We write $\bar{a} \in R^\mathcal{A}$ or $R^\mathcal{A}(a)$ to denote that the tuple
%  $a \in A^{arity(R)}$ belongs to the relation $R^\mathcal{A}$.
% We brieﬂy recall the syntax and semantics of ﬁrst-order logic. We ﬁx a countably inﬁnite set of (individual) variables, for
% which we use small letters. Atomic formulas of vocabulary $\mathcal{R}$ are of the form: $x = y$ or $R(x_1,\dots,x_r)$,  where $R \in \mathcal{R}$ is r-ary and $x_1,\dots,x_r,x,y$ are variables. \emph{First-order formulas} of vocabulary $\mathcal{R}$ are built from the atomic formulas using the boolean connectives $\neg, \vee,\wedge$ and existential and universal quantifiers $\exists$, $\forall$. The difference between first-order and second-order

Monadic second-order logic (MSO logic) is a fragment of second-order logic where quantification is restricted to sets. Importantly, if a graph property is expressible in MSO logic, Courcelle's theorem states that there exists fixed-parameter tractable algorithm in the treewidth of the graph and in the length of the MSO expression.
%
In graphs, we are allowed to use the following variables and relations to express a property in MSO logic:

\begin{compactitem}
  \item standard boolean connectives: $\neg$ (negation), $\wedge$ (and), $\vee$ (or), $\Rightarrow$ (implication),
  \item standard quantifiers: $\exists$ (existential quantifier), $\forall$ (universal quantifier), which can be applied to any variable used to represent vertices, edges, sets of vertices or sets of edges of a graph. By convention, lower-case letters are used to represent vertices and edges, and upper-case letters are used to represent sets of vertices or edges,
  \item the binary equality relation $=$, the binary inclusion relation $\in$, the binary incidence relation $inc(e,v)$ which encodes that an edge $e$ is incident to a vertex $v$.
\end{compactitem}

A \emph{free variable} is a variable not bound by quantifiers. An MSO \emph{sentence} is an MSO formula with no free variables. Let $G$ be a graph, the notation $G\models \phi$ indicates that $G$ verifies the formula. Courcelle's theorem is stated as follows.


\begin{theorem}[Courcelle's theorem~\cite{Courcelle86a,Courcelle90}]
  \label{theorem:courcelle} Let $G$ be a simple graph of treewidth $tw$ and a fixed MSO sentence $\phi$, there exists an algorithm that tests if $G\models \phi$ and runs in $\mathcal{O}(f(tw,|\phi|) \cdot |G|)$, where $f$ is a computable function.
\end{theorem}


\subsection{MSO formulation}

We show, using Courcelle's theorem, that if a static problem $\Pi_S$ is definable in the monadic second-order logic, then its reconfiguration version $\Pi_T$ is FPT when parameterized by the treewidth of the footprint and the lifetime of the temporal graph.

In order to do that, we first convert the temporal graph $\mathcal{G}=(G,\lambda)$ into a static graph $H$ as defined in the following construction.



\begin{construction}
  \label{const:sliding}
  Given a temporal graph $\mathcal{G}=(G,\lambda)$ with bounded lifetime $\tau$ and vertex set $V(G) = \{u_1,\dots,u_n\}$, we consider the following static graph $H$ with vertex set $V(H) = \{ v^t_i \mid u_i \in V(G), t \in [1,\tau]\}$ and such that $H$ contains the following edges:% and edge set $E(H) = \bigcup\limits_{t \in [1,\tau]} E_t \bigcup\limits_{t \in [1,\tau-1]} E_{t,t+1}$ where $E_t = \{v^t_iv^t_j \mid u_iu_j \in G_t\}$ and $E_{t,t+1} = \{v^t_iv^{t+1}_j \mid u_iu_j \in G_t\} \cup \{v^t_iv^{t+1}_i \mid u_i \in V(G)\}$.
  \begin{itemize}
    \item for each $t \in [1,\tau]$, $H$ contains the set of edges $E_t = \{ v^t_iv^t_j \mid u_iu_j \in E(G_t)\}$ (\textit{i.e.} $H$ contains the disjoint union of each snapshot $G_t$), and
    \item for each $t \in [1,\tau-1]$, $H$ contains the edge set $E_{t,t+1} = \{v^t_iv^{t+1}_j \mid u_iu_j \in E(G_t)\} \cup \{v^t_iv^{t+1}_i \mid u_i \in V(G)\}$ (\textit{i.e.} there is an edge between $v^t_i$ and $v^{t+1}_j$ if it is possible to move a token from $u_i$ to $u_j$ at time-step $t$).  
  \end{itemize}
\end{construction}
Note that this construction is related to but is not the same as the time-expanded graph of a temporal graph (as used in, e.g.~\cite{fluschnik_as_2020}).

\begin{lemmarep}
Let $\mathcal{G}=(G,\lambda)$ be a temporal graph, and let $H$ be the graph described in \Cref{const:sliding}. The treewidth of $H$ is at most $\tau\cdot tw$ where $tw$ is the treewidth of the footprint $G$.
\end{lemmarep}
\begin{proof}
  Let $(T,\mathcal{X})$ be a tree decomposition of $G$ of width $tw$. We construct a tree decomposition $(T,\mathcal{Y})$ for $H$ as follows. For each bag $B_x \in \mathcal{X}$, we subtsitute each vertex $u_i \in B_x$ by the set of vertices $\{v^t_i \mid t \in [1,\tau]\}$. Clearly, for any vertex $v^t_i \in V(H)$, the bags in $\mathcal{Y}$ containing $v^t_i$ are connected in $T$ since the bags in $\mathcal{X}$ containing $u_i$ are connected in $T$.
For each edge $v^t_iv^t_j \in E(H)$ (respectively $v^t_iv^{t+1}_j$), let $B_x$ be a bag containing $u_iu_j$ in $\mathcal{X}$, after the substitution, $B_x$ contains the edge $v^t_iv^t_j$ (resp. $v^t_iv^{t+1}_j$). For each edge $v^t_iv^{t+1}_i$, any bag $B_x$ containing the vertex $u_i \in \mathcal{X}$ contains the edge $v^t_iv^{t+1}_i$. Hence, $(T,\mathcal{Y})$ is a tree decomposition of $H$ and since each vertex is replaced by $\tau$ vertices in each bag, the width of $(T,\mathcal{Y})$ is $\tau \cdot tw$.
\end{proof}
 

\noindent An example of a graph produced by \Cref{const:sliding} is depicted in \Cref{fig:to static}.

\begin{figure}[ht]
  \centering
  \scalebox{0.75}{
  \begin{tikzpicture}
    \foreach \Y in {1,2} {
      \foreach \X in {1,...,3} {
        \foreach[count=\l from 1] \x/\y/\a in {0/0/-90,1/-1/-90,0/2/90,1/1/-135,1/3/90}{
          \ifthenelse{\equal{\Y}{2}}{
            \node[smallvertex,label=90+90*\X:{$v^\X_\l$}] (\X\l) at (\X*2.5+\x+\Y*9,\y*0.75) {};
          }{
            \node[smallvertex,label=90+90*\X:{$u_\l$}] (\X\l) at (\X*2.5+\x+\Y*9,\y*0.75) {};
          }
        }

        \ifthenelse{\equal{\Y}{1}}{
          \node at (\X*2.5+0.5+\Y*9,-2) {$G_\X$};
        }
        {}
      }
      
      \foreach \a/\b/\L in {2/1/{2,3},1/3/{1,3},3/5/{1},3/4/{2}} {
        \foreach \X in \L {
          \draw (\X\a) -- (\X\b);
          \ifthenelse{\equal{\Y}{2}}{
          \ifthenelse{\equal{\X}{3}}{}{
            \pgfmathsetmacro{\B}{int(\X + 1)}
            \draw[draw=iris,dashed] (\X\a) -- (\B\b);
            \draw[draw=iris,dashed] (\B\a) -- (\X\b);
          }
          }{}
        }
      }
      \ifthenelse{\equal{\Y}{2}}{
        \foreach[count=\B from 2] \X in {1,2}{
          \foreach \a in {1,...,5}{
          \draw[draw=iris,dashed] (\X\a) -- (\B\a);
        }
        }
      }{}
      
    }
 % \foreach \a in {12,22,33}
 % \node[smallvertex,fill=gray] at (\a.center) {};
    
  \end{tikzpicture}
}
  \caption{\label{fig:to static} Example of a graph produced by \Cref{const:sliding}. The edges in $E_{t,t+1}$ sets are depicted in blue/dashed.}
\end{figure}


Let $\mathcal{G}$ be a temporal graph and let $H$ be the static graph produced by \Cref{const:sliding} with $\mathcal{G}$ given in input. for convenience, we denote by $V_t$ the set of vertices in $H$ with superscript $t$. Notice that finding a solution for $\Pi_T$ in $\mathcal{G}$ is equivalent to finding a vertex set $X$ in $H$ such that:
\begin{compactitem}
  \item for each $t \in [\tau]$, $X \cap V_t$ is a solution for $\Pi_S$ in $H[V_t]$, and
  \item for each $t \in [\tau-1]$, there is a perfect matching between $X \cap V_t$ and $X \cap V_{t+1}$.
  \end{compactitem}
We show that if $\Pi_S$ can be expressed in MSO logic, then we can also express the reconfiguration version $\Pi_T$ in MSO logic, with an increase in formula size by a factor $\tau$.
By Courcelle's theorem, it follows that $\Pi_T$ is FPT in the lifetime of the temporal graph and the treewidth of the footprint combined.

\begin{theoremrep}
  \label{theorem:mso}
  Let $\Pi_T$ be a reconfiguration problem such that its static version $\Pi_S$ is expressable with an MSO formula $\phi(H)$.
  Let $\mathcal{G}=(G,\lambda)$ be a temporal graph such that the treewidth of $G$ is $tw$. There is an algorithm to determine if there is a reconfigurable sequence of size $k$ for $\Pi_T$ in $\mathcal{G}$ in $\mathcal{O}(f(tw,\tau,|\phi|) \cdot \tau\cdot|G|)$.
\end{theoremrep}

\begin{proof}

  Let $H$ be a graph produced by \Cref{const:sliding} on $\mathcal{G}=(G,\lambda)$. Since $\Pi_S$ is expressable in MSO logic, there is a predicate $\phi(G_t,X)$ indicating if a subset of vertices $X$ is a solution for $\Pi_S$ in $G_t$ 
  % Let $\phi$ be an MSO formula such that G
  We construct an MSO formula to express a set $X$ such that $X \cap V_t$ is a solution for $\Pi_S$ in $H[V_t]$ for each $t \in [\tau]$ and such that there is a perfect matching between $X \cap V_t$ and $X \cap V_{t+1}$ for each $t \in [\tau-1]$.


We introduce the following predicate that given a set of edges $M$, two sets of vertices $X$ and $Y$ and a set of edges $E$, $match\_edge$ returns \texttt{true} if
$v$ belongs to $X$,
there is exactly one edge $e\in M$ incident to $v$ and
the other endpoint of $e$ belongs to $Y$. 


\begin{eqnarray*}
  match\_edge(M,X,v,Y) = &  v \in X \wedge \exists e, \exists u, (e \in M) \wedge (u \in Y) &\wedge  \\
  & inc(e,v) \wedge inc(e,u) &\wedge  \\
  & \forall e', (e'\in M \wedge inc(e',v)) \Rightarrow e = e'&
  \end{eqnarray*}

  Notice that given two disjoint vertex sets $X$ and $Y$, a set of edges $M$ forms a perfect matching between $X$ and $Y$ if for every $v$ in $X$ we have $match\_edge(M,X,v,Y)= \texttt{true}$ and for every $u$ in $Y$ we have $match\_edge(M,Y,u,X) = \texttt{true}$.
  Hence, we can formulate the following predicate that, given two vertex sets $X$ and $Y$ and an edge set $E$ returns \texttt{true} if $E$ contains a perfect matching between $X$ and $Y$.


\begin{eqnarray*}
  Matching(X,Y,E) =
  \exists M, \forall v & &\\
                       & (v\not\in X  \wedge v \not\in Y ) &\vee\\
                       & match\_edge(M,X,v,Y) &\vee \\
                       &match\_edge(M,Y,v,X) &\\
\end{eqnarray*}

Hence, we can encode $\Pi_T$ with an MSO formula as follows:
\begin{eqnarray}
\exists X_1 \subseteq V_1,\dots, X_\tau \subseteq V_\tau \bigwedge\limits_{t\leq\tau} \phi(G_t,X_t) \bigwedge\limits_{t<\tau} Matching(X_t,X_{t+1},E_{t,t+1})  
\end{eqnarray}
The size of the formula is in $\mathcal{O}(\tau |\phi|)$ so, we can conclude by \Cref{theorem:courcelle} that $\Pi_T$ is solvable in $\mathcal{O}(f(tw,\tau,|\phi|) \cdot \tau\cdot|G|)$.
\end{proof}

\noindent Let $G$ be a static graph. {\sc Dominating Set} and {\sc Independent Set} can formulated in $G$ as follows:
  \[
    \exists D \subseteq V(G), \forall v \in V(G), v \in D \vee (\exists u\in D, uv\in E(G)) \tag{{\sc Dominating Set}}
  \]
  \[
    \exists I \subseteq V(G), \forall v \in I, \forall u \in I, uv \not\in E(G) \tag{{\sc Independent Set}}. 
  \]
  Hence, by \Cref{theorem:mso}, we can deduce the following result for {\sc Temporal Dominating Set Reconfiguration} and {\sc Temporal Independent Set Reconfiguration}.

\begin{corollary}
{\sc Temporal Dominating Set Reconfiguration} and {\sc Temporal Independent Set Reconfiguration} are solvable in $\mathcal{O}(f(tw,\tau) \cdot \tau\cdot|G|)$.
\end{corollary}




%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
