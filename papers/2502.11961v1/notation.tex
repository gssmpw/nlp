\section{Notation}
\label{sec:notation}
Where possible, we use standard graph theoretic notation, and direct the reader to \cite{golumbic} for detail.  A static graph is a pair $G = (V, E)$ where $V(G) = V$ is the vertex set and $E(G) = E$ is the edge set. We also use standard definitions and notation of parameterised algorithmics. We refer the interested reader to~\cite{cygan_parameterized_2015}.
%
A \emph{matching} $M \subseteq E(G)$ of graph $G$ is a set of edges that are pairwise disjoint. A matching $M$ is \emph{perfect} if each vertex $v \in V(G)$ is in exactly one edge in $M$.  Finally, given two subsets of vertices $X$ and $Y$, we say that there is a \emph{perfect matching between} $X$ and $Y$ if there exists a perfect matching in the bipartite subgraph $H$ with $V(H) = X \cup Y$ and $E(H) = \{xy \mid xy \in E(G), x \in X, y\in Y \}$. 

% I think we can probably get away without defining the below.
% A \emph{mapping function} $f : D \to 2^I$ is a function that associates some elements of $D$ to a (possibly empty) subset of $I$. We usually use the functional notation to describe a mapping function, that is, $f(x)=S$ indicates that $x\in D$ is associated to the subset $S \in I$. For conveniency, we also can see $f$ as a set of relations $x \to y$, where $x$ and $y$ are elements of $D$ and $I$, respectively. Hence, we have $f(x)= \{ y\in I \mid x \to y \in f\}$. It is particulary convenient when constructing a mapping function $f_2$ from another mapping function $f_1$: for example if $f_2 = f_1 \cup \{x_1 \to y_1\}$, then we have $f_2(x)=f_1(x) \cup \{y_1\}$ if $x=x_1$ and $f_2(x)=f_1(x)$ otherwise. 
%

\subsection{Temporal graphs}
A \emph{temporal graph} $\mathcal{G}$ is a pair $(G, \lambda)$, where $G$ is a static graph and $\lambda : E(G) \to 2^{\mathbb{N}}$ is a function called the \emph{time-labelling function}; for each edge $e \in E(G)$, $\lambda(e)$ denotes the set of time-steps at which $e$ is active. 
The \emph{lifetime} of $\mathcal{G}$, denoted by $\tau_{\mathcal{G}}$, is the maximum time-step at which an edge is active, i.e., $\tau_{\mathcal{G}} = \max \bigcup_{e \in E(G)} \lambda(e)$. 
When $\mathcal{G}$ is clear from the context, we may drop the subscript and simply write $\tau$. 
For a temporal graph $\mathcal{G} = (G, \lambda)$ and $t \in [\tau]$, the \emph{snapshot} of $\mathcal{G}$ at time-step $t$ is the static graph $G_t$ that consists of all the edges of $G$ that are active at time-step $t$, i.e.,  $V(G_t) = V(G)$ and $E(G_t) = \{e \in E(G) \mid t \in \lambda(e)\}$. For $v \in V(G_t)$, we use $N_t(v)$ (resp. $N_t[v]$) to denote the set of neighbours (resp. closed neighbours) of $v$ in the graph $G_t$. The \emph{footprint} of a temporal graph is the static graph formed by taking the union of the temporal graph at all time-steps. 


\section{Temporal reconfiguration problems}
\label{sec:tmp reconfiguration problems}
We now define temporal reconfiguration problems and give some intuition.  Here we define a temporal reconfiguration problem from a static graph vertex selection problem: any optimisation problem in which we choose a set of vertices that respect some property, with the aim of either maximising or minimising the number of vertices in the selected set.  
%
Intuitively, we can think of a set of selected vertices as a set of tokens placed on those vertices.  
Then, we require the vertices indicated by tokens to meet a required property at each time-step, and allow movement over an edge of each token at every time-step.
Importantly, each vertex can only contain at most one token. At each time-step and for each token, we have two possibilities: either to keep the token on the same vertex or to move the token to an adjacent vertex.  We then ask for the optimum number of tokens such that we respect the required property at each time and can also reconfigure the tokens from each time-step to the next.  

%
Formally, 
let $T_1,T_2 \subseteq V(G)$ be two sets of selected vertices in a temporal graph $\mathcal{G}$. We say that $T_1$ is \emph{reconfigurable} into $T_2$ at time-step $t$ if it is possible to move the tokens from the vertices of $T_1$ to the vertices of $T_2$ in $G_t$. Observe that $T_1$ is reconfigurable into $T_2$ at time-step $t$ if there is a bijection $b : T_1 \to T_2$, called a \emph{reconfiguration bijection}, such that for each $(u,v) \in b$, either $u=v$ (i.e.\ the token remains on the same vertex) or $uv \in G_t$ (i.e.\ the token moves from $u$ to $v$).

%
Notice that if $T_1$ is reconfigurable into $T_2$, then we have $|T_1|=|T_2|$. Let $T=(T_1,\dots,T_\tau)$ be a sequence such that for all $i \in [\tau]$, $T_i \subseteq V(G)$.  We say that $T$ is a \emph{reconfigurable sequence} of $\mathcal{G}$ if for each time-step $t \in [\tau-1]$, $T_t$ is reconfigurable into $T_{t+1}$ at time-step $t$. We denote by $|T|=|T_1|=\dots=|T_\tau|$ the size of the reconfigurable sequence $T$.
%
In a reconfiguration problem, we aim to find a reconfigurable sequence such that at each time-step $t$, the set of selected vertices $T_t$ respects a specific property $\Pi$ in $G_t$. This gives the formal basis for transforming a static vertex selection problem to a temporal reconfiguration problem. Consider the following generic vertex selection graph problem in a static setting:

 \prob{$\Pi$ static graph problem}{
   A static graph $G$.
}{
  Find a minimum/maximum set of vertices $X$ that respects property $\Pi$ in $G$.
}

\noindent The corresponding reconfiguration problem can be formulated as follow:

 \prob{Temporal $\Pi$ reconfiguration problem}{
   A temporal graph $\mathcal{G}=(G,\lambda)$ with lifetime $\tau$.
 }{
   Find a reconfigurable sequence $T=(T_1,\dots,T_\tau)$ of $\mathcal{G}$ of minimum/maximum size $|T|$ such that each $T_t$ respects property $\Pi$ in $G_t$.
 }
 % \TD{I think it's better to keep the optimisation formulation if we want to keep \Cref{th:approx}}
 For the sake of simplicity, we refer to ``static problem'' to exclusively refer to a vertex selection problem in a static graph while ``temporal reconfiguration problem'' will refer to a temporal reconfiguration version of a static problem. 
 Notice that, since any static graph is a temporal graph of lifetime $1$, if a static problem is NP-hard, then the corresponding reconfiguration problem is also NP-hard. More generally, any lower bounds on complexity can be transferred from the static problem to the temporal reconfiguration problem.
%
 As an example, we will use two classical problems, {\sc Dominating Set} and {\sc Independent Set} to illustrate the methods used throughout the paper. 

 \begin{exampleB}[Dominating Set]
   A \emph{dominating set} $D \subseteq V(G)$ is a set of vertices such that for each $v \in V(G)$, we have $N[v] \cap D \neq \emptyset$.
 \end{exampleB}

 
 A classical optimisation problem is to find a dominating set of minimum size in a static graph. This problem is known to be NP-complete~\cite{Garey90}.

 
 % \textcolor{magenta}{\textbf{Laura: max-edge result uses optimisation version of the problem. Below is also optimisation version, but title makes me think it was intended to be decision?}}

 % \prob{Temporal Reconfiguration Dominating Set}{ 
 %   A temporal graph $\mathcal{G}=(G,\lambda)$ with lifetime $\tau$.
 % }{
 %   Find a minimum-size reconfigurable sequence $T=(T_1,\dots,T_\tau)$ such that each $T_i$ is a dominating set.
 % }

\begin{exampleB}[Independent Set]
An \emph{independent set} $I \subseteq V(G)$ is a set of pairwise non-adjacent vertices.
\end{exampleB}
 
\noindent {\sc Independent Set} is one of Karp's NP-complete problems~\cite{Karp1972}.
In the following, we refer to the temporal reconfiguration versions of {\sc Dominating Set} and {\sc Independent Set} as {\sc Temporal Dominating Set Reconfiguration} and {\sc Temporal Independent Set Reconfiguration}, respectively.
 % \prob{Temporal Reconfiguration Independent Set}{
 %   A temporal graph $\mathcal{G}=(G,\lambda)$ with lifetime $\tau$.
 % }{
 %   Find a maximum-size reconfigurable sequence $T=(T_1,\dots,T_\tau)$ such that each $T_i$ is an independent set.
 % }



% \paragraph{Dominating set.} Let $G$ be a static graph. A \emph{dominating set} $D \subseteq V(G)$ is a set of vertices such that for each $v \in V(G)$, we have $N[v] \cap D \neq \emptyset$. In the following, we study a temporal version of the dominating where we allow a dominating set to evolve over time. For that, we use a set of tokens which will be placed on the vertices to represent dominant vertices. A token located on a vertex $v$ at time step $t$ can move on another vertex $u$ at time step $t+1$ if there is an edge $uv$ such that $t \in \lambda(uv)$. In that case, we say that the token \emph{slides along} the edge $uv$. Let $T_1, T_2\subseteq V(G)$ be two token positions in a temporal graph $\mathcal{G}$. We say that $T_1$ is \emph{reconfigurable} into $T_2$ if there is a perfect matching between $T_1 \setminus T_2$ and $T_2 \setminus T_1$ in $G_t$. Notice that if $T_1$ is reconfigurable into $T_2$ then $|T_1|=|T_2|$.
% \begin{definition}
%   A \emph{sliding dominating set} $T=(T_1,\dots,T_\tau)$ is a sequence of $\tau$ token positions such that:
%   \begin{enumerate}[(a)]
%     \item for each $t \in [1,\tau]$, $T_t$ is a dominating set in $G_t$, and
%     \item for each $t \in [1,\tau-1]$, $T_t$ is reconfigurable into $T_{t+1}$ in $G_t$.
%   \end{enumerate}
% \end{definition}
% The cardinality of $T$ is equal to the cardinality of any set of positions $T_i$.
% In the following, we study the following problem.
% \prob{Sliding Dominating Set (SDS)}{
%   A temporal graph $\mathcal{G}=(G,\lambda)$.
% }{
%   Find a minimum sliding dominating set.
% }

 
 
%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
