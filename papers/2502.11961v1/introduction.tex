\section{Introduction}

In many classical graph problems in static settings, the aim is to select a subset of vertices respecting some specified property, while minimizing or maximizing the number of selected vertices (e.g.\ maximum independent set, minimum dominating set, maximum clique).
%
Recently, reconfiguration versions of classical vertex-selection problems have been studied in static graphs, where the goal is typically to determine whether one valid solution can be transformed into another through a sequence of small modifications~\cite{BousquetMNS24,MouawadN0SS17}.

Formally, reconfiguration versions of vertex-selection problems in static graphs can be defined as follows. Let $\Pi$ be a vertex-selection problem such as {\sc Independent Set} or {\sc Dominating Set}. Reconfiguration problems in static graphs are often defined with a starting and end solution $S$ and $T$ respectively. The aim is to determine if there is a sequence of vertex sets starting with $S$ and ending with $T$ such that each is a solution for $\Pi$ and consecutive sets are adjacent in the space of solutions. The definition of solution adjacency varies according to model. In the \emph{token sliding model}, a solution can be seen as a set of tokens placed on the vertices of $G$~\cite{HEARN200572}. A solution $S_1$ is adjacent to another solution $S_2$ if we can transform $S_1$ into $S_2$ by sliding one token of $S_1$ along an edge of $G$, if there is an edge $uv$ such that $S_1 \setminus S_2 = \{u\}$ and $S_2 \setminus S_1 = \{v\}$. Both {\sc Independent Set Reconfiguration} and {\sc Dominating Set Reconfiguration} have been studied in parameterised~\cite{BodlaenderGS21,BartierBDLM21} and classical~\cite{BousquetJO20,SuzukiMN16} settings. 
% Other models, such as \emph{token jumping model}, and other reconfiguration problems have been studied, see~\cite{BousquetMNS24,MouawadN0SS17} for an overview.

Hearn and Demain~\cite{HEARN200572} show that {\sc Independent Set Reconfiguration} under token sliding is PSPACE-complete even in planar graphs with bounded degree. It is also known to be PSPACE-complete when restricted to other classes of graphs such as planar graphs of split graphs~\cite{BelmonteKLMOS21}, bipartite graphs~\cite{LokshtanovM19}, and bounded bandwidth~\cite{Wrochna18}. On the positive side, there are polynomial-time algorithms when restricted to trees~\cite{DemaineDFHIOOUY14}, interval graphs~\cite{BonamyB17}, bipartite permutation graphs~\cite{Fox-EpsteinHOU15} and line graphs~\cite{ItoDHPSUU11}. 

For {\sc Dominating Set Reconfiguration} under token sliding, the problem is also known to be PSPACE-complete even when  restricted to split, bipartite and bounded tree-width graphs~\cite{HaddadanIMNOST16}, or restricted to circle graphs~\cite{BousquetJ21}. The problem is polynomial-time solvable on dually chordal graphs, cographs~\cite{HaddadanIMNOST16} and on circular-arc graphs~\cite{BousquetJ21}.
% Some structural properties have also been studied .

%

While these reconfiguration problems provide valuable insights into how dynamic solutions can evolve in static graphs, they cannot model scenarios where the underlying structure of the graph evolves. This motivates the study of reconfiguration in a temporal setting.
%
    In this work, we extend the token sliding model into temporal graphs. Instead of determining whether a solution can be reconfigured into another, we ask if there exists a sequence of solutions where each solution can be reconfigured into the next. Moreover, while the token sliding model in static settings only allows one token to move at a time, we generalise by allowing all tokens to move along available edges simultaneously at each time-step. Verheije studied a version of this problem for {\sc Dominating Set} on temporal graphs~\cite{Verheije21}, under the name {\sc Marching Dominating}. He developed an exact exponential-time algorithm to determine whether a solution of {\sc Dominating Set} with at most $k$ tokens can be maintained in a temporal graph.

We introduce a new framework for transforming any vertex-selection problem in a static graph into a temporal reconfiguration problem. We also provide methods to compute reconfigurable sequences for temporal reconfiguration problems in some cases.


The paper is organised as follows: in section~\ref{sec:notation}, we introduce basic graph and temporal graph notation.  In \Cref{sec:tmp reconfiguration problems}, we formally introduce temporal reconfiguration problems. In \Cref{sec:polynomial}, we describe two preliminary results on temporal graphs, showing we can check if a specified sequence is temporally reconfigurable, and giving an approximation result. In Sections~\ref{sec:enum},~\ref{sec:ndiversity}, and~\ref{sec:tw algo} we give parameterised algorithmic results. In \Cref{sec:enum}, we study the parameterisation of temporal reconfiguration problems by the enumeration time of their static versions. In \Cref{sec:ndiversity}, we parameterise by temporal neighbourhood diversity and lifetime. Finally, in \Cref{sec:tw algo}, we parameterise by treewidth of the footprint graph. To save space the proofs have been moved in the appendix.

%%% Local Variables:
%%% mode: LaTeX
%%% TeX-master: "main"
%%% End:
