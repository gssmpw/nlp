\subsection{The structure of your software determines its research potential}\label{sec:architecture}

\paragraph{Background} Choosing and developing a suitable architecture is essential to developing research software efficiently. A typical definition of software architecture would be: "The software architecture of a program or computing system is the structure or structures of the system, which comprise software components, the externally visible properties of those components, and the relationships among them." \cite{BASSSoftwareArch}. Here, we mainly think of the composition of software components, the chosen abstractions of the real world, and the applied design patterns. Inadequate and/or outdated architectures lead to different problems. They slow the development of additional features and increase the complexity of finding bugs. This happens because such architectures do not adequately induce a structure that helps you to handle the code (and its bugs) and, therefore, to extend and reiterate it. For example, using clearly defined interfaces to modules of your code can drastically improve your ability to provide different implementations for the same task (e.g., using different MILP solvers). Considering these types of decisions early saves a lot of code refactoring.

\paragraph{Recommendations} We recommend creating the most straightforward possible architecture for \ac{ERS} while making it as complex as necessary to fulfill the specific needs of your research questions. For this, looking at typical architectures and patterns to fulfill different needs is necessary. In \ac{ERS}, we often encounter two types of overall architectures: (1) single-process input-output simulations or optimizations and (2) agent-based architectures. However, when looking at the details, there are a lot of architectural design patterns to structure these types according to specific needs (i.e., Gangs of Four \cite{GoFArch}). Further, one goal of implementing an architecture is to keep it maintainable, which includes some enforcement of the architectural patterns for future development. If it is sensible that some technical data is not directly accessible, technically enforce it by restricting access to specific data fields.

To determine how to implement the architecture, it is often helpful to look at the interfaces of your components to each other (which data belongs to which component, how much data should be shared, and how the data should be shared). We recommend using standards wherever possible, for example, the \ac{CIM} \cite{uslar2012common} for power grids or the \ac{FMI}\footnote{\url{https://fmi-standard.org/}, last access 2025-01-02} for dynamic simulation models. The same is true for reusing established APIs. For example, most energy-related reinforcement learning frameworks \cite{Wolgast_OPF-Gym, hou2024rladnhighperformancedeepreinforcement, NEURIPS2023_ba748557} reuse the well-known \texttt{Gymnasium} API to be compatible with open-source algorithms.


Additionally, it makes sense to think about the interface other researchers should use when applying your software. Your architecture should allow the development of user-centric APIs (designed to be used easily, not implemented easily).

When developing \ac{ERS}, you often decide on many specific architectural aspects. Be aware of them, and document them and their reasoning. For example, if you are developing a grid model and choose to represent it as a table vs. using a graph, be aware of its advantages and disadvantages. Also, do not hesitate to change these decisions and reiterate the architecture if your software outgrows your original decision and is starting to hold it back.

Lastly, actively consider knowledge transfer for your software's lifecycle. This includes transferring your knowledge to others (e.g., using architectural documentation) and learning about basic architectural knowledge \cite{BASSSoftwareArch} and design patterns, such as Gangs of Four~\cite{GoFArch}. 

To conclude, we recommend thinking and iterating on your architecture as much as needed while aiming to keep it as simple as possible to ensure the maintainability of your software.

\recommendation{Keep the architecture as simple as possible (but as complex as necessary)!}