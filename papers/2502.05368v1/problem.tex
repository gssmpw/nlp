\section{Problem Statement}\label{sec:problem}

In this work, we focus on the problem of generating tests from issues.
Specifically, the input $x$ is a pair
\mbox{$\langle d_\mathrm{issue},c_\mathrm{old}\rangle$}
of an issue description $d_\mathrm{issue}$ alongside the old version
$c_\mathrm{old}$ of the code before the issue is resolved.
The issue description is typically in natural language, but it may
sometimes contain embedded code snippets or stack traces.
The code is a snapshot of all the files and folders in a Python
source code repository.
The expected output $y$ is a set of tests that should go from failing
on $c_\mathrm{old}$ to passing on $c_\mathrm{new}$, which is the new
version of the code after the issue is resolved.
By failing on $c_\mathrm{old}$, the tests reproduce the issue, and by
passing on $c_\mathrm{new}$, they validate its resolution.
Besides going from failing to passing, the tests should also maximize
coverage of the code change. %(formalized in Section~\ref{sec:tddbench}).
A solution to this problem is thus a function $\mathit{genTests}$ that
takes an input $x$ and returns tests \mbox{$y=\mathit{genTests}(x)$}.
The new code $c_\mathrm{new}$ is not available to $\mathit{genTests}$, which must
generate tests $y$ based on $x$ alone.
This is representative of the real world where source code
repositories may have regression tests for existing code but lack
tests for open issues.
\solx provides an implementation of the $\mathit{genTests}$ function
and, thus, a solution to this problem.
