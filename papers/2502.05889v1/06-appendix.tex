\section{Appendix}
\subsection{Preliminaries: Missing Proofs}\label{appendix:preliminaries}
We present the formal proof of Lemma \ref{lemma:broadcast-easy}, establishing that whenever $\bb$ can be achieved, the $\byzantineSM$ problem is solvable.
\BroadcastEasy*

\begin{proof}
The parties distribute their input preference lists via $\bb$. This provides the parties with an identical view over the parties' preferences lists. If a party $P$ has not sent a valid preference list, then $P$ is byzantine, and the honest parties may simply assign a pre-defined default preference list to it. 
Afterwards, each party runs $\GaleShapley$ offline with the preference lists obtained and obtains a matching $M$. Each party then outputs its match in $M$.

Termination comes from $\bb$'s termination property. $\bb$'s validity condition ensures that, if the input of an honest party $P$ in our $\byzantineSM$ instance is the preference list $\pi_P$, then party $P$ has preference list $\pi_P$ in each of the honest parties' offline executions of $\GaleShapley$.
$\bb$'s Agreement properties ensures that all honest parties run $\GaleShapley$ with the same input. Since $\GaleShapley$ is deterministic, all honest parties obtain the same output $M$. 

According to Theorem \ref{theorem:gale-shapley}, $M$ is a proper matching (if $u$ is matched with $v$, then $v$ is matched with $u$) satisfying stability (no blocking pair). Therefore, as each honest party outputs its match in $M$, symmetry, non-competition and stability hold. Hence, $\byzantineSM$ is achieved.
\end{proof}


\subsection{Simplified Stable Matching: Missing Proofs} \label{appendix:simplified-stable-matching}

We first include the proof of Lemma \ref{coro:to-simplified}, establishing that $\simplifiedSM$ reduces to $\byzantineSM$.

\SimplifiedReduction*

\begin{proof}
It suffices to show that any protocol solving $\byzantineSM$ also solves $\simplifiedSM$. 
Given a protocol $\Pi$ solving $\byzantineSM$, we construct a protocol $\Pi'$ that solves $\simplifiedSM$, as follows:

Given its favorite as input, each party constructs an arbitrary preference list with the favorite ranked first. Afterward, parties join an invocation of $\Pi$ with the constructed lists as inputs. The output obtained in $\Pi$ for $\byzantineSM$ is used in $\Pi'$ as the output for $\simplifiedSM$.


First, $\Pi'$ maintains the resilience thresholds of $\Pi$. Moreover, the termination, symmetry, and non-competition guarantees of $\Pi'$ follow directly from $\Pi$ achieving termination, symmetry, and non-competition, respectively. Finally, if two honest parties are each other's favorites, they rank each other first in the constructed lists and, consequently, always form a blocking pair if they are not matched. Therefore, the simplified stability property of $\Pi'$ is guaranteed by the stability property of $\Pi$.
\end{proof}

We now present the proof of Lemma \ref{lemma:reduce-number}, allowing us to extend impossibility results from small settings to larger settings.
\ReduceNumberLemma*
\begin{proof}
We partition $L$ into $d$ disjoint sets $L_1$, \dots, $L_d$ such that $1 \leq |L_1|,\dots,|L_d| \leq \lceil |L| / d \rceil = \lceil k/d \rceil$. Similarly, we partition $R$ into $d$ disjoint sets $R_1$, \dots, $R_d$ such that $1 \leq |R_1|,\dots,|R_d| \leq \lceil |R| / d \rceil = \lceil k/d \rceil$. From each of these sets, we pick one representative: $l_1, \dots, l_d, r_1, \dots, r_d$. We build $\Pi'$ solving $\simplifiedSM$ for $2d$ parties: $l_1', \dots, l_d'$ on the left side and $r_1', \dots, r_d'$ on the right side, as follows:
\begin{itemize}[nosep]
\item Each party $l_i'$ in $\Pi'$ simulates all the parties in $L_i$ running $\Pi$. Similarly, each party $r_j'$ in $\Pi'$ simulates all the parties in $R_j$ running $\Pi$.
\item Input: If the input (favorite) of $l_i'$ is $r_j'$, then we assign $r_j$ as the favorite of $l_i$. Similarly, if the input of $r_j'$ is $l_i'$, then we assign $l_i$ as the favorite of $r_j$. For parties that are not representatives of their group, we assign arbitrary favorites.
\item Output: For a given $l_i$, if there is a $r_j$ such that $l_i$ matches $r_j$, then $l_i'$ declares that it matches $r_j'$. Otherwise $l_i'$ declares that it matches nobody.
\end{itemize}

We are basically running the $\simplifiedSM$ algorithm on the whole graph but only looking at the representative of each set and discarding anything unrelated to them. As a consequence, $\Pi'$ achieves termination, symmetry, simplified stability, and non-competition since $\Pi$ achieves termination, symmetry, simplified stability, and non-competition. 

As each party in $\Pi'$ simulates up to $\lceil k / d \rceil$ parties 
from $\Pi$ and $\Pi$ supports up to $t_L$ byzantine parties in $L$ and $t_R$ byzantine parties in $R$, the bound on the number of byzantine parties supported by $\Pi'$ follows immediately.
\end{proof}

\subsection{Byzantine Broadcast with General Adversaries}\label{appendix:general-adversaries}
To achieve the feasibility part of Theorem \ref{theo:pki-complete}, 
we got help from the result below.

\GeneralAdversaries*

As mentioned before, this is a corollary of \cite[{Theorem 2}]{DISC:FitMau98}. We again highlight that \cite{DISC:FitMau98} assumes a \emph{general adversary}, which we briefly introduce next. In this adversarial model, the corruption power of the adversary is specified by a (subset-closed) 
% needs to define an 
% considers an 
\emph{adversarial structure} $\mathcal{Z} \subseteq 2^\mathcal{P}$, where $\mathcal{P}$ denotes the set of parties. In particular, the adversary may choose to corrupt any set of parties in $\mathcal{Z}$.
For instance, if $\mathcal{P} := \{P_1, P_2, \ldots, P_5\}$, a potential adversarial structure $\mathcal{Z}$ is $\{\varnothing, \{P_1\}, \{P_2\}, \{P_1, P_2\}, \{P_4\}\}$, which means that the adversary may choose between corrupting no parties, corrupting parties $P_1, P_2$ (or only one of the two), or corrupting only party $P_4$. In contrast, one often considers a \emph{threshold adversary}, which may corrupt up to $t$ of the $n$ parties (as is the case in most literature): this is a particular case of the general adversary model where $\mathcal{Z}$ is the set of all subsets of at most $t$ parties. The adversary assumed in our work sits in-between these two: we assume that the adversary may corrupt up to $t_L$ parties in $L$ and up to $t_R$ parties in $R$, hence our adversary structure is $\mathcal{Z^\star} := \{S_L \cup S_R \mid S_L \subseteq L, S_R \subseteq R, \abs{S_L} \leq t_L, \abs{S_R} \leq t_R\}$. This can be thought of as the product of two threshold adversary structures.

In the general adversaries model, {\cite[{Theorem 2}]{DISC:FitMau98}} states the following:
\begin{theorem}[\hspace{-1pt}{\cite[{Theorem 2}]{DISC:FitMau98}}] \label{thm:general-adversaries-explicit}
    Assume a fully-connected unauthenticated network, and an adversary structure $\mathcal{Z}$ such that for any three sets $Z_1, Z_2, Z_3 \in \mathcal{Z}$ it holds that $Z_1 \cup Z_2 \cup Z_3 \neq \mathcal{P}$. Then, there is a protocol achieving $\bb$ in this setting.
\end{theorem}

Then, to prove Lemma \ref{lemma:general-adversaries}, we only need to show no three sets in our 
% implicit
adversary structure $\mathcal{Z}^\star$ cover the set of $n$ parties:
\begin{proof}[Proof of Lemma \ref{lemma:general-adversaries}]
Consider our adversarial structure $\mathcal{Z^\star} := \{S_L \cup S_R \mid S_L \subseteq L, S_R \subseteq R, \abs{S_L} \leq t_L, \abs{S_R} \leq t_R\}$, and let $Z_1, Z_2, Z_3 \in \mathcal{Z^\star}$ be arbitrary. We show that $Z_1 \cup Z_2 \cup Z_3 \neq L \cup R$.


Without loss of generality, we may assume that the condition $t_L < k / 3$ holds (the case where $t_R < k / 3$ and $t_L \geq k / 3$ is analogous). As every $Z \in Z^\star$ contains at most $t_L$ parties in $L$, it follows that $Z_1 \cup Z_2 \cup Z_3$ contain at most $3 \cdot t_L < 3 \cdot k / 3 = k$ parties in $L$. Hence, at least one element of $L$ is uncovered by $Z_1 \cup Z_2 \cup Z_3$, from which $Z_1 \cup Z_2 \cup Z_3 \neq L \cup R$.

Then, we may apply Theorem \ref{thm:general-adversaries-explicit} and conclude that there is a protocol achieving $\bb$ in our setting.
\end{proof}

\subsection{Unauthenticated Setting: Missing Proofs}\label{appendix:complete-bipartite-graph-without-pki}
We present the proof of Lemma \ref{lemma:pki-bipartite}. This has provided reductions between the communication models when analyzing $\byzantineSM$ in unauthenticated settings.
\BipartiteCommunicationNoPKI*

\begin{proof}
Let $u,v$ be parties in $S$. We want to simulate an authenticated channel between $u$ and $v$, i.e the receiver knows who the sender is. 

If $u$ wants to send a message $M$ to $v$, it sends the message ($u \rightarrow v$, $M$) to every party in $S'$. Then, if a party in $S'$ receives a message ($u \rightarrow v$, $M$) from $u$, it forwards it to $v$. Finally, if $v$ receives the same message ($u \rightarrow v$, $M$) from a majority (i.e strictly more than $k/2$) of $S'$, it considers it received message $M$ from $u$.

Using this strategy, we can see that sending a message takes a bounded amount of time (at most $2 \Delta$). Moreover, if $u$ is honest and sends a message $M$, at least $k - t_{S'} > k/2$ parties from $S'$ will forward it to $v$ which will therefore accept it.
If $v$ accepts a message $M$ from $u$, this means strictly more than $k/2$ parties from $S'$ forwarded it. Because $t_{S'} < k/2$, at least one honest party forwarded it, meaning $u$ intended to send this message (being honest or not).
\end{proof}

\subsection{Authenticated Setting: Missing Proofs} \label{appendix:bipartite-pki}
We present the proof of Lemma \ref{lemma:with-pki-one-sided}, which has provided us with reductions between the communicated models when analyzing $\byzantineSM$ in authenticated settings.

\PKIOneSided*

\begin{proof}
Let $u,v$ be parties in $S$. We want to simulate an authenticated channel between $u$ and $v$.
% to send a message from $u$ to $v$ in an authenticated way, i.e the receiver knows who the sender is. 

If $u$ wants to send a message $M$ to $v$, it sends the signed message ($u \rightarrow v$, $M$) to every party in $S'$. Then, if a party in $S'$ receives a message ($u \rightarrow v$, $M$) with a valid signature from $u$, it forwards it to $v$. Finally, if $v$ receives a message ($u \rightarrow v$, $M$) from a party in $S'$ with a valid signature, it considers it receives message $M$ from $u$.

Using this strategy, we can see that sending a message takes a bounded amount of time (at most $2 \Delta$). Moreover, if $u$ is honest and sends a message $M$, at least $k - t_{S'} > 0$ parties from $S'$ will forward it to $v$, which will therefore accept it.
If $v$ accepts a message $M$ from $u$, this message is signed by $u$, meaning $u$ intended to send this message (being honest or not).
\end{proof}

\MagicOmissionsNew*
\begin{proof}
Let $(u,v)$ be two parties in $L$ and assume that $u$ wants to send a message $\msg$ to $v$. $u$ sends a signed message $(u \rightarrow v, \timestamp, \msgId, \msg)$ to all parties in $R$, $\tau$ being the current timestamp and $\msgId$ being a message identifier. Parties in $R$ then forward this signed message to $v$. If $v$ receives a message $(u, \rightarrow, v, \timestamp, \msgId, \msg)$ properly signed by $u$ such that $\timestamp$ is at most $2\Delta$ units of time in the past and $u$ has not seen $\msgId$ has not been seen before, it accepts message $\msgId$ from $u$.

With this approach, if at least one party in $R$ is honest, messages always get forwarded and received within $2\Delta$ units of time. Otherwise, note that the byzantine parties cannot forge signatures on the honest parties' behalf. Hence, the byzantine parties may choose whether to forward the message or not, then causing an omission.
\end{proof}



\subsection{Protocols in Settings with or without Omissions} \label{appendix:sync-and-omission}
In order to prove sufficiency when one side may be completely byzantine in Section \ref{subsection:bipartite-pki}, we have considered a setting consisting of a fully-connected synchronous network where \emph{omissions} may occur: if a message is delivered, it is delivered within $\Delta$ time. We have utilized the building blocks described by the theorems below:
\BAWithOmissions*
\BBWithOmissions*

In the following, we describe the constructions behind these theorems.

\paragraph{Byzantine Agreement.} We start by presenting protocol $\Pi_{\ba}$.
We need a \emph{synchronous} $k$-party $\ba$ protocol resilient against $t_L < k / 3$ corruptions. We may use, for instance, the protocol of \cite{King}, presented below.
\begin{protocolbox}{$\Pi_{\king}$}
    \algoHead{Code for party $P \in L$ with input $v_{\inputt}$}
    \begin{algorithmic}[1]
    \State If you have not obtained any output by time $3(t_L + 1) \cdot \Delta$, output $\bot$.
    \State $v := v_{\inputt}$
    \For {$i = 1 \ldots t_L + 1$}
    \State \textbf{(Round 1)}
    \State Send $(\val, v)$ to all parties. 
    \State Wait $\Delta$ time.
    \State \textbf{(Round 2)}
    \State If you have received $(\val, v')$ for the same $v'$ from $k - t_L$ parties in $L$:
    \State \hspace{0.5cm} Send $(\propose, v')$ to all parties
    \State Wait $\Delta$ time.
    \State \textbf{(Round 3})
    \State If you have received some $(\propose, v')$ from more than $t_L$ parties, set $v' = v$.
    \State \textbf{King $P_i$ only}: Send $v_K := v$ to all parties.
    \State Wait $\Delta$ time.
    \State If you have received strictly less than $k - t_L$ messages $(\propose, v')$ for any $v'$:
    \State \hspace{0.5cm} If you have received $v_K$ from king $P_i$: Set $v = v_K$
    \EndFor
    \State Output $v$
\end{algorithmic}
\end{protocolbox}

The next theorem comes directly from \cite{King}.
\begin{theorem}[Theorem 3.1 of \cite{King}]
    Whenever $\Pi_{\king}$ runs in a synchronous network with maximum delay $\Delta$ and at most $t_L < k / 3$ byzantine corruptions, $\Pi_{\king}$ achieves $\ba$ within $\Delta_{\king} := 3(t_L + 1) \cdot \Delta$ time.
\end{theorem}

We note that, due to line 1, termination is guaranteed even when omissions occur.
\begin{remark}
    Whenever $\Pi_{\king}$ runs in a synchronous network with omissions with maximum delay $\Delta$, it achieves termination within $\Delta_{\king}(\Delta) := 3(t_L + 1) \cdot \Delta$ time.
\end{remark}

However, $\Pi_{\king}$ does not achieve weak agreement when omissions occur. To achieve this property, we need one more round of communication, as presented below.

\begin{protocolbox}{$\Pi_{\ba}$}
    \algoHead{Code for party $P \in L$ with input $v_{\inputt}$}
    \begin{algorithmic}[1]
    \State Join $\king$ with input $v_{\inputt}$ and obtain output $y$.
    \State At time $\Delta_{\king}(\Delta)$, send $y$ to every party.
    \State If the same value $z$ is received from $k - t_L$ parties in $L$ by time $\Delta_{\king}(\Delta) + \Delta$, output $z$. Otherwise, output $\bot$.
\end{algorithmic}
\end{protocolbox}


\begin{proof}[Proof of Theorem \ref{thm:ba-omissions}]
Termination  is achieved within $\Delta_\ba(\Delta) = 3(t_L + 1) \cdot \Delta + \Delta$ time even if omissions occur: this follows from $\Pi_{\king}$'s termination guarantees. 

We first show that $\ba$ is achieved when no omissions occur. In this case $\Pi_{\king}$ achieves $\ba$. Hence, all honest parties obtain the same value $y$. Then, at least the $k - t_L$ honest parties send $y$ to all parties. Since no omissions occur, these messages are received within $\Delta$ time, and all parties output $y$. Moreover, due to $\Pi_{\king}$'s validity, if all honest parties had the same input $v$, the honest parties have obtained $y = v$, and therefore all honest parties output $y$. Consequently, $\ba$ is achieved.


We may now discuss weak agreement if omissions occur. In this case $\Pi_{\king}$ only achieves termination (and it is possible that the honest parties obtain $y = \bot$). Assume that an honest party $p$ outputs $z \neq \bot$ in $\Pi_{\ba}$. Then, $p$ has received $z$ from $k - t_L$ parties, hence from at least $n - 2t_L > t_L$ honest parties. As such, every party can receive strictly less than $n - t_L$ values $z' \neq z$, and therefore no honest party outputs $z' \neq z$.  Therefore, weak agreement holds.
\end{proof}

\paragraph{Byzantine Broadcast.}
Protocol $\Pi_{\bb}$ is a simple reduction to $\Pi_{\ba}$. The sender $S$ sends its value to all parties, and afterwards the parties run $\Pi_{\ba}$ to agree on the value received.
\begin{protocolbox}{$\Pi_{\bb}$}
    \algoHead{Code for sender $S \in L$ with input $v_{S}$}
    \begin{algorithmic}[1]
    \State Send $v_{S}$ to all parties.
    \end{algorithmic}

    \algoHead{Code for party $P \in L$}
    \begin{algorithmic}[1]
    \State Receive value $v$ from the sender. If you did not receive a value within $\Delta$ time, set $v :=$ default value (default preference list).
    \State At time $\Delta$, join $\Pi_{\ba}$ with input $v$. Return the output obtained.
\end{algorithmic}
\end{protocolbox}

\begin{proof}[Proof of Theorem \ref{thm:bb-omissions}]
$\Pi_{\ba}$ achieves termination within $\Delta_{\ba}(\Delta)$ time even when omissions occur, hence $\Pi_{\bb}$ achieves termination within $\Delta_{\bb}(\Delta) = \Delta + \Delta_{\ba}(\Delta)$ time even when omissions occur.

If no omissions occur, $\Pi_{\ba}$ achieves $\ba$. Therefore, $\Pi_{\bb}$ achieves agreement. If the sender is honest with input $v_S$, all honest parties join $\Pi_{\ba}$ with input $v_S$, and the validity guarantee of $\Pi_{\ba}$ ensures that the parties output $v_S$. Then, $\Pi_{\bb}$ achieves validity, and consequently $\bb$.

Lastly, if omissions occur, as $\Pi_{\ba}$ achieves weak agreement, $\Pi_{\bb}$ also achieves weak agreement.
\end{proof}


