\section{Introduction}

The \emph{stable matching} problem (also known as \emph{stable marriage}), first introduced by Gale and Shapley \cite{GaleShapley}, has long been a cornerstone of combinatorial optimization and market design. 

It involves finding a stable pairing between two distinct sets of agents --- such as job seekers and job positions or students and universities --- where each participant ranks the opposite set based on individual preferences. The stability criterion dictates that there is no \emph{blocking pair}, i.e., no two unmatched agents should prefer each other over their assigned partners. This foundational task has multiple practical applications in resource assignment and subsequently led to Shapley and Roth winning the Nobel Prize in Economics in 2012 for their work on \textit{the theory of stable allocations and the practice of market design} \cite{ShapleyRoth}.


In their seminal work \cite{GaleShapley}, Gale and Shapley proved that when the $n$ agents are divided equally into the two sides, and each individual provides a complete preference ranking of the opposite set, a stable matching always exists. Moreover, they provided an algorithm finding such a matching with complexity $O(n^2)$. Further versions of this problem have been considered in \cite{GusfieldIrving}, including variants where the individuals only provide \emph{partial} preferences, or if ties are allowed within the preference rankings. The work of \cite{GusfieldIrving} has shown that a stable matching always exists even in such scenarios, although some individuals may not be matched. 


 The stable matching problem naturally extends to distributed settings, where each agent operates as an independent process or party. Through communication, agents determine their matches while ensuring stability --- a \emph{local} property. 
Furthermore, the Gale-Shapley algorithm inherently functions as a distributed algorithm, as it consists solely of marriage proposals and divorce declarations, both of which can be processed in parallel.

The distributed variant has been studied in various practical scenarios. For instance, the work of Maggs and Sitaraman \cite{MaSi15} explores stable matching in content delivery networks, where stable matching is used for global load balancing by mapping client groups to server clusters. Moreover, stable matching has been leveraged in wireless networks: \cite{BaLoLi11} employs this problem to pair primary and secondary users in a radio network, \cite{ElAhDa12} 
relies on stable matching to pair users and uplink carriers when performing channel assignment, and numerous other studies have explored similar applications \cite{GuZhPa15, BaLoHa12, PaBeSa13}.


We note that, in such scenarios, it is important for the stable-matching-based mechanisms to be resilient to potential faults. Notably, the work of Maggs and Sitaraman \cite{MaSi15} regarding stable matching in content delivery networks has pointed out the potential of (crash) failures. The mitigation strategy proposed by \cite{MaSi15} relies on \emph{leader election}: although crashes do not necessarily degrade the matching obtained, this is a point of failure if the leader misbehaves. To the best of our knowledge, prior works in distributed stable matching assume that parties follow the protocol, or that there is some central trusted unit which can gather all inputs, perform the stable matching algorithm and return the result. This motivates us to investigate scenarios where no such safety exists, and parties may not only crash, but also become byzantine and hence exhibit malicious behavior. Concretely, we ask the following question:

\vspace{-0.1cm}
{
\begin{center}
\emph{Can we achieve stable matching in a network even if some of the parties are byzantine?}
\end{center}
}
\vspace{-0.6cm}

\paragraph{Our Contribution.}
We firstly define the \emph{byzantine stable matching} problem $\byzantineSM$, taking into account that byzantine parties may choose not to participate in the protocol, and preventing honest parties from matching with the same byzantine party. We then investigate the necessary and sufficient conditions for achieving $\byzantineSM$ under various synchronous network topologies, both with and without cryptographic assumptions (digital signatures), and we provide tight conditions. 
We denote the two sets by $L$ and $R$, with $\abs{L} = \abs{R} = k$, and we assume that at most $t_L$ parties in $L$ and at most $t_R$ parties in $R$ may be byzantine.
We consider fully-connected networks, \emph{bipartite} networks (where the parties can only communicate to parties on the other side), and a topology in-between, which we call a \emph{one-sided} networks: this maintains the communication channels of a bipartite network, but additionally provides the parties in side $R$ with complete communication. 
We summarize our findings below:
\begin{itemize}[nosep,leftmargin=*]
    \item When no cryptographic setup is available, $\byzantineSM$ can be solved if and only if: 
    \begin{itemize}
        \item $t_L < k / 3$ or $t_R < k  / 3$ in a fully-connected network.
        \item the following hold in a bipartite network: (i) $t_L, t_R < k/2$; (ii) $t_L < k/3$ or $t_R < k/3$.
        \item the following hold in a one-sided network: (i) $t_R < k/2$; (ii)  $t_L < k/3$ or $t_R < k/3$.
    \end{itemize}
    \item Assuming digital signatures, $\byzantineSM$ can always be solved if the network is fully connected. Otherwise, $\byzantineSM$ can be solved if and only if:
    \begin{itemize}
        \item any of the following holds in a bipartite network: (i) $t_L, t_R < k$; (ii) $t_L < k/3$ or $t_R < k/3$.
        \item $t_R < k$ or $t_L < k / 3$ in a one-sided network.
    \end{itemize}
\end{itemize}

Our settings enable us to establish our conditions' sufficiency by reducing $\byzantineSM$ to Byzantine Broadcast \cite{LSP82}, with one notable exception: this approach falls short in bipartite networks with digital signatures, where one side may be completely byzantine, leaving the honest side disconnected. For this setting, we provide a protocol that simulates a \emph{synchronous fully-connected network with omissions} for the disconnected side, allowing us to achieve $\byzantineSM$.
We also add that our impossibility arguments prove, in fact, even stronger results: even a \emph{simplified} version of $\byzantineSM$ (where parties hold a single favorite as input as opposed to a complete preference list) cannot be solved unless the stated conditions hold.

\paragraph{Related work.}
While the stable matching problem has not been previously explored in the context of byzantine behaviour, malicious strategies such as \emph{lying} were considered. Concretely, Roth \cite{Roth1982TheEO} showed that stable matching is not \emph{truthful}: there are scenarios where an individual can get a more favorable result by lying about their preferences. However, Gale and Shapley \cite{GaleShapley} proved that their algorithm is truthful for one side: an individual on the side doing the proposals can never gain by lying. The case where multiple individuals on the proposing side can collude in the Gale-Shapley algorithm has also been studied \cite{HuChi06}. We note that such adversarial models essentially consider manipulations of the \emph{preferences lists}. In contrast, byzantine fault tolerance protocols are mainly concerned with providing reasonable guarantees even when byzantine parties attempt to prevent honest parties from obtaining \emph{a solution}.


As the Gale-Shapley algorithm \cite{GaleShapley} naturally adapts to distributed settings, lower bounds regarding the number of queries between the two sides have been the topic of interest. Gonczarowski et al \cite{GONCZAROWSKI2019626} provided a lower bound of  $\Omega(n^2)$ boolean queries. However, this does not take into account communication between parties on the same side. In this case, there is still a gap between the best-known lower bound of $\Omega(n^2)$ and upper bound of $O(n^2 \log n)$. When preference lists are similar, Khanchandani and Wattenhofer \cite{Khanchandani2016DistributedSM} describe an algorithm with better complexity and provide a lower bound depending on the similarity of the lists.
Approximation algorithms have also been a topic of interest as a strategy to circumvent the lower bound of \cite{GONCZAROWSKI2019626}. Various definitions for an \emph{approximation} of a stable matching have been analyzed, considering the number of blocking pairs \cite{Ostrovsky}, the number of matches which would have to be broken \cite{GONCZAROWSKI2019626} or how blocking each pair is \cite{Kipnis}. 




While some of our necessary conditions enable $\byzantineSM$ to be reduced to well-established problems such as Byzantine Broadcast and Byzantine Agreement \cite{LSP82}, we also encounter settings where $\byzantineSM$ is strictly weaker than these fundamental problems, requiring novel insights.
We also note that the term \emph{matching} has occurred in previous works regarding byzantine faults or \emph{self-stabilization} (starting from an arbitrary state, the system needs to reach a \emph{legitimate configuration} eventually). However, such works are concerned with finding a \emph{maximal} matching \cite{HSU199277, ChHiSe02, MaMjPi07}, or a maximum matching in a bipartite graph \cite{HaKa09} as opposed to a \emph{stable} matching.
