\section{Solvability in Authenticated Settings}


We now consider authenticated settings. Assuming digital signatures will enable us to solve $\byzantineSM$ up to much higher corruption thresholds in contrast to the unauthenticated case. This section is organized similarly to Section \ref{section:no-pki}: we first analyze the fully-connected network case, and afterwards focus on one-sided and bipartite networks.

\subsection{Fully-Connected Network} 
In the fully-connected network case, $\byzantineSM$ is always solvable: we utilize the Dolev-Strong protocol \cite{DolStr83}, which achieves $\bb$ resilient against $t < n$ corruptions assuming PKI. Then, \cref{lemma:broadcast-easy} directly implies the theorem below.
\begin{theorem}\label{theo:with-pki-complete}
$\byzantineSM$ is solvable in a fully-connected authenticated network.
\end{theorem}

\subsection{Bipartite and One-Sided Networks}\label{subsection:bipartite-pki}
The one-side and bipartite communication models offer more interesting restrictions, as described by the theorems below. 
Note that these results imply that, given PKI, $\byzantineSM$ is solvable even when one side is fully byzantine, i.e. $t_R = k$. This may seem counter-intuitive, as the honest parties' communication graph may be completely disconnected. However, we need to highlight that, if one side is completely byzantine, the $\byzantineSM$ definition allows the honest parties to simply match with nobody: any partial matching that satisfies non-competition suffices.
\begin{theorem} \label{thm:bipartite-pki-main}
$\byzantineSM$ is solvable in a bipartite authenticated network if at least one of these conditions holds: (i) $t_L, t_R < k$; (ii) $t_L < k/3$ or $t_R < k/3$.
\end{theorem}
\begin{theorem} \label{thm:one-sided-pki-main}
$\byzantineSM$ is solvable in a one-sided authenticated  network if $t_R < k$ or $t_L < k / 3$.
\end{theorem}


\paragraph{Sufficient conditions.}
In the following, we first focus on showing that the conditions described by the theorems above are sufficient.
In the unauthenticated setting, our conditions enabled us to provide the parties in the disconnected side with full communication. In turn, this allowed us to prove sufficiency by reducing the one-sided/bipartite network cases to the fully-connected network case. Assuming signatures enables us to proceed similarly: we may provide parties in side $S$ with complete communication \emph{whenever side $S'$ (which may or may not be connected) contains at least one honest party}. Roughly, the parties in $S$ will send signed messages to parties in $S'$, and the (honest) parties in $S'$ will forward these messages. Parties in $S$ will then accept messages signed correctly. We present the formal proof in Appendix \ref{appendix:bipartite-pki}.

\begin{restatable}{lemma}{PKIOneSided}\label{lemma:with-pki-one-sided}
Denote the two sides $L$ and $R$ by $S$ and $S'$.
If the parties in side $S$ are disconnected, $t_{S'} < k$, and the network is authenticated, we may assume the parties in $S$ are fully connected. 
\end{restatable}

The next corollaries follow from \cref{lemma:with-pki-one-sided}. Note that Corollary \ref{coro:one-sided-complete} enables us to conclude that $t_R < k$ is a sufficient condition for $\byzantineSM$ in a one-sided network with PKI. Similarly, Corollary \ref{coro:with-pki-complete} implies that $t_L, t_R < k$ is a sufficient condition for $\byzantineSM$ in a bipartite authenticated network.
\begin{corollary}\label{coro:one-sided-complete}
In a one-sided authenticated network, we may assume a fully-connected authenticated network if $t_R < k$.
\end{corollary}

\begin{corollary}\label{coro:with-pki-complete}
In a bipartite authenticated network, we may assume a fully-connected authenticated network if $t_L, t_R < k$.
\end{corollary}
Note that, for the one-sided network case we may already conclude that the conditions presented in \cref{thm:one-sided-pki-main} are sufficient. The condition $t_R < k$ follows from Corollary \ref{coro:one-sided-complete}, which enables us to reduce this case to the fully-connected authenticated setting described by Theorem~\ref{theo:with-pki-complete}. Moreover, the condition $t_L < k / 3$ is sufficient due to \cref{theorem:main:no-pki-one-sided}, which states that  $\byzantineSM$ can be solved even in an unauthenticated one-sided network when $t_L < k / 3$.

For the bipartite network case, the condition $t_L < k$ and $t_R < k$ being sufficient follows directly from Corollary \ref{coro:with-pki-complete}. Showing that having $t_L < k/3$ or $t_R < k/3$ is also sufficient introduces, however, different challenges. From this point on, we may assume without loss of generality that $t_L < k / 3$, which implies that the side $R$ may be fully byzantine. Note that this may cause the honest parties in $L$ to be completely disconnected.

While we cannot assume that the parties in $L$ are in a fully-connected network, we will be able to assume that they are \emph{in a fully-connected network with omissions}: a message may either be received within $2 \cdot \Delta$ units of time, or it is never delivered. Moreover, omissions occur \emph{only} if all parties in side $R$ are byzantine. We achieve this using the following strategy: whenever a party in $P \in L$ needs to send a message $\msg$ to a party in $P' \in R$, it sends the \emph{signed} message $\msg' := (P \rightarrow P', \timestamp, \msgId, \msg)$ to all parties in $R$, where $\msgId$ is a message identifier and $\timestamp$ is the time when $\msg'$ is sent. The (honest) parties in $R$ forward the signed message $\msg'$ to $P'$. $P'$ accepts this message only if the signature is valid and at most $2 \cdot \Delta$ time has passed since time $\tau$. We add that, as byzantine parties cannot forge signatures on the honest parties' behalf, this ensures reliable communication (up to omissions).

We may then design a protocol in the bipartite network case as follows: we (attempt) to provide the parties in $L$ with all parties' preferences lists. The parties in $L$ will run $\GaleShapley$ locally, which enables them to obtain their own matches and inform the parties in $R$ about their matches. Due to the forwarding mechanism, we may assume that the parties in $L$ are in a fully-connected network where omissions only occur if all parties in $R$ are byzantine.

To provide the honest parties in $L$ with identical views over the preferences' list, we rely on two building blocks: a synchronous $\bb$ protocol $\Pi_{\bb}$, and a synchronous \emph{Byzantine Agreement} ($\ba$) protocol $\Pi_{\ba}$. We recall the definition of $\ba$ below. 
\begin{definition}[Byzantine Agreement]\label{def:ba}
	Let $\Pi$ be a protocol where every party holds a value as input. 
    We say that $\Pi$ achieves $\ba$ if the following  hold even when up to $t$ parties are corrupted:
    (Termination) All honest parties output and terminate;
    (Validity) If all honest parties hold the same input value $v$, they output $v$.
    (Agreement) All honest parties output the same value.
\end{definition}

The potential for omissions will require us to enhance these protocols by adding a few properties when omissions occur: termination, and \emph{weak agreement}, described below. Note that we do not require any validity condition.

\vspace{0.1cm}
\noindent \emph{(Weak agreement)}: If $P$ and $P'$ are honest and output $v \neq \bot$ and $v' \neq \bot$ respectively, $v = v'$.
\vspace{0.1cm}


The theorems below describe our building blocks. $\Pi_{\ba}$ is obtained by making adjustments to the protocol of \cite{King}, and $\Pi_{\bb}$ is a simple reduction to $\Pi_{\ba}$. For constructions, see Appendix~\ref{appendix:sync-and-omission}. 
\begin{restatable}{theorem}{BAWithOmissions}\label{thm:ba-omissions}
    Assume the $k$ parties in $L$ are in a fully-connected synchronous network with delay $\Delta$. If $t_L < k/3$, there is a $k$-party protocol $\Pi_{\ba}$ achieving $\ba$ within $\Delta_{\ba}( \Delta)$ time. Moreover, if omissions occur, $\Pi_{\ba}$ still achieves weak agreement and termination within $\Delta_{\ba}(\Delta)$ time.
\end{restatable}
\begin{restatable}{theorem}{BBWithOmissions}\label{thm:bb-omissions}
Assume the $k$ parties in $L$ are in a fully-connected synchronous network with delay $\Delta$. If $t_L < k/3$, there is a $k$-party protocol $\Pi_{\bb}$ achieving $\bb$ within $\Delta_{\bb}(\Delta)$ time. Moreover, if omissions occur, $\Pi_{\bb}$ still achieves weak agreement and termination within $\Delta_{\bb}(\Delta)$ time.
\end{restatable}

We present the code of our protocol below.

\begin{protocolbox}{$\Pi_{\byzantineSM}$}
\algoHead{Code for party $P \in R$ with input $\preferences$}
\begin{algorithmic}[1]
\State Whenever you receive a properly signed message $\msg' = (P'' \rightarrow P', \timestamp, \msgId, \msg)$ from $P'' \in L$, forward the signed message to $P' \in L$.
\State Send your preference list $\sigma$ to every party in $L$.
\State At time $\max(\Delta_{\ba}(2\Delta) + \Delta, \Delta_{\bb}(2\Delta)) + \Delta$:
\State \hspace{0.5cm} $M_p :=$ matching suggestions received from parties in $L$.
\State \hspace{0.5cm} Decide to match according to the most common suggestion in $M_p$ (breaking ties arbitrarily). 
\end{algorithmic}
\vspace{.5cm}
\algoHead{Code for party $P \in L$ with input $\preferences$}
\begin{algorithmic}[1]
\State $\msgId := 0$. Whenever you need to send a message $\msg$ to $P' \in L$, let $\timestamp :=$ the current time. Send the signed message $(P \rightarrow P', \timestamp, \msgId, \msg)$ to all parties in $R$ and increment $\msgId$.
\State In parallel:
\State \hspace{0.5cm} Send $\pi$ to all parties via $\Pi_{\bb}$. Let $\sigma_\ell$ denote the list received via $\Pi_{\bb}$ from party $P_{\ell} \in L$.
\State \hspace{0.5cm} Wait $\Delta$ time to receive preference lists from the parties in $R$. Join an invocation of $\Pi_{\ba}$ for every party $P_r$ in $R$: with input $\preferences_r$ if you have received $\preferences_r$ from $P_r$, and with a default preference list otherwise. Obtain outputs $\sigma_r$.
\State At time $\max(\Delta_{\ba}(2 \Delta) + \Delta, \Delta_{\bb}(2 \Delta))$:
\State \hspace{0.5cm} If any value in $(\sigma_v)_{v \in L \cup R}$ is $\bot$, decide to match with nobody and terminate.
\State \hspace{0.5cm} Run $\GaleShapley$ locally with input $\left( (\sigma_l)_{l \in L}, (\sigma_r)_{r \in R} \right)$ and obtain output $M$.
\State \hspace{0.5cm} Send to each party $P_r \in R$ whom they should match to according to $M$.
\State \hspace{0.5cm} Decide who to match to according to $M$.
\end{algorithmic}
\end{protocolbox}



The next lemma states the guarantees of $\Pi_{\byzantineSM}$.
\begin{lemma}\label{lemma:protocol-omissions}
    $\Pi_{\byzantineSM}$ achieves $\byzantineSM$ in a  bipartite authenticated network if $t_L < k/3$.
\end{lemma}


We split the proof of \cref{lemma:protocol-omissions} into three lemmas. First, \cref{lemma:magic-omissions-new} describes the communication among the parties in $L$ in $\Pi_{\byzantineSM}$, allowing us to assume that the parties in $L$ are in a fully-connected network where omissions may only occur if all parties in $R$ are byzantine. Under this assumption, \cref{lemma:bdsm-protocol:omissions} shows that $\byzantineSM$ is achieved when no party in $R$ is honest, and \cref{lemma:bdsm-protocol:no-omissions} shows that $\byzantineSM$ is achieved when $R$ contains at least one honest party.
The proof of the next lemma is enclosed in Appendix  \ref{appendix:bipartite-pki}.
\begin{restatable}{lemma}{MagicOmissionsNew}\label{lemma:magic-omissions-new}
We may assume the parties in $L$ are in a fully-connected network with maximum delay $2 \cdot \Delta$  where omissions occur only if all parties in $R$ are byzantine.
\end{restatable}


\begin{lemma}\label{lemma:bdsm-protocol:omissions}
    If every party in $R$ is byzantine and $t_L < k / 3$, $\Pi_{\byzantineSM}$ achieves $\byzantineSM$.
\end{lemma}
\begin{proof}
According to \cref{lemma:magic-omissions-new}, the parties in $L$ run $\Pi_{\ba}$ and $\Pi_{\bb}$ run in a fully-connected network with omissions. As a consequence, the weak agreement and termination properties hold according to \cref{thm:ba-omissions} and \cref{thm:bb-omissions}: if the parties receive non-$\bot$ outputs, then these outputs are consistent.

Since $\Pi_{\ba}$ and $\Pi_{\bb}$ achieve termination, $\Pi_{\byzantineSM}$ achieves termination as well.

Because all parties in $R$ are byzantine, symmetry and stability are immediate: these properties concern two honest parties on opposite sides, which never happens here because one side is fully byzantine. We note that some honest parties in $L$ may have received $\bot$ and decided to match with nobody but this still results in a stable matching for this specific setting.

As for non-competition, weak agreement guarantees that the honest parties who have obtained preference lists in each of the $\Pi_{\ba}$ and $\Pi_{\bb}$ invocations run $\GaleShapley$ with the same input. \cref{theorem:gale-shapley} ensures that these parties obtain the same matching $M$. Therefore, we conclude that $\Pi_{\byzantineSM}$ achieves $\byzantineSM$ whenever all parties in $R$ are byzantine. 
\end{proof}

\begin{lemma}\label{lemma:bdsm-protocol:no-omissions}
    If $R$ contains an honest party and $t_L < k/3$, $\Pi_\byzantineSM$ achieves $\byzantineSM$.
\end{lemma}
\begin{proof}
Parties in $L$ are in a fully-connected network with no omissions according to \cref{lemma:magic-omissions-new}, hence $\Pi_{\ba}$ and $\Pi_{\bb}$ achieve respectively $\ba$ according to \cref{thm:ba-omissions} and $\bb$ according to Theorem~\ref{thm:bb-omissions}.
Consequently, all honest parties run $\GaleShapley$ locally on the same input due to agreement and termination. Moreover, the validity properties of $\Pi_{\ba}$ and $\Pi_{\bb}$ ensure that honest parties' preference lists are received correctly and used as input in the local run of $\GaleShapley$.
We therefore obtain that the honest parties in $L$ run the same instance of $\GaleShapley$ locally, and every honest party's preference list in $\GaleShapley$ is the same as its original input. Therefore, the stable matching $M$ computed by $\GaleShapley$ also satisfies our $\byzantineSM$ definition.

The last step is to prove that every honest party decides according to $M$. This is immediate for honest parties in $L$. As for honest parties in $R$, they decide according to the most common option sent by parties in $L$. Since $k - t_L > t_L$ of the parties in $L$ are honest, each party in $R$ receives its match in $M$ as the majority option, and decides on this match.
Therefore, all honest parties decide according to $M$. Consequently $\Pi_{\byzantineSM}$ achieves $\byzantineSM$ whenever $R$ contains at least one honest party.
\end{proof}



\paragraph{Necessary conditions.} We still need to show that the conditions presented in \cref{thm:bipartite-pki-main} and \cref{thm:one-sided-pki-main} are necessary.
We write our proof for one-sided communication, and the bipartite network case will be a corollary.
\begin{lemma}\label{lemma:with-pki-one-sided-impossible}
If $t_R = k$ and $t_L \geq k/3$, then achieving $\byzantineSM$ is a one-sided network is impossible.
\end{lemma}
\begin{proof}
We assume by contradiction that there is a protocol achieving $\byzantineSM$ in this setting. Using Corollary \ref{coro:to-simplified} and \cref{lemma:reduce-number}, this means that there exists a protocol $\Pi$ which solves $\simplifiedSM$ on $n := 6$ nodes with $t_R = 3$ and $t_L = 1$. We denote the six parties by  $L = \{a,b,c\}$ and $R = \{u,v,w\}$, and assume that $b$ and all parties in $R$ are byzantine. In the following, we fix an input configuration, and we describe an adversarial strategy that breaks the guarantees of $\Pi$ in this setting: honest parties $a$ and $c$ will match with the same byzantine party $v$ in $R$, hence breaking non-competition.

\begin{figure}[h]
\centering
\includegraphics[scale=0.55]{figures/pki-not-possible_cropped.pdf}
\caption{a) From the point of view of $a$, all parties are honest except $c$ (which crashed), simplified stability guarantees that $a$ matches with $v$. b) From the point of view of $c$, all parties are honest except $a$ (which crashed), simplified stability guarantees that $c$ matches with $v$. c) What is actually happening is that all byzantine parties are simulating two versions of themselves except $a$ and $c$, but both $a$ and $c$ are honest and try to match $v$, which is not allowed by the non-competition property}

\end{figure}


To do so, we define $a$ and $c$'s favorite as $v$. Moreover, each byzantine party will internally simulate two instances of themselves running protocol $\Pi$. For example, $v$ will internally simulate two instances of itself $v_1$ and $v_2$ such that $v_1$'s favorite is $a$ and $v_2$'s favorite is $b$. Each of the remaining byzantine parties $x \in \{ b, u, w \}$ simulates two instances of itself $x_1$ and $x_2$ with any arbitrary inputs.

% \textcolor{purple}{(todo: the parties in $R$ should be connected in the figure, but we omit this).}\textcolor{blue}{(I don't show the connection between parties in $L$ and $R$ neither as id doesn't matter.)}

Each communication edge has at least one of its two endpoints being a byzantine party in our setting: since the parties in $L$ are only connected to parties in $R$ in a one-sided network, byzantine parties have full control over the communication network. They may therefore divide the communication network in two groups: $\{a,b_1, u_1, v_1, w_1\}$ and $\{b_2, c, u_2, v_2, w_2\}$.
Messages only get sent and received within a group, meaning that if party $a$ running $\Pi$ wants to send a message to $w$, $w_1$ will receive it. Any message sent from $u_1, v_1$ and $w_1$ to $c$ is never received. 

We consider the output of $a$ and $c$ after running protocol $\Pi$ in this setting. We have $t_L = 1$ and $t_R = 3$, which satisfies $\Pi$'s requirements. Consequently, termination holds: $a$ and $c$ must decide to either match with some party or no one.

We then consider a new scenario for party $a$: parties $a, b, u, v, w$ are all honest with the same favorites as the previous scenario's first group. Party $c$ is byzantine and crashes at the beginning, i.e., it does not send any message. In this scenario, $t_L = 1$ and $t_R = 0$, which satisfies the requirements of $\Pi$. Therefore, termination holds and $a$ obtains an output. Since both $a$ and $v$ are honest and each other's favorite, they must match with each other according to simplified stability. However, we remark that $a$ cannot distinguish between this scenario and the previous one: it receives the exact same messages in both cases. Therefore, in the first scenario, $a$ also decides to match with $v$.

We may construct a symmetric scenario for party $c$: this time, parties $b, c, u, v, w$ are honest with the same inputs as in the first scenario's second group. Party $a$ is byzantine and crashes at the beginning of the protocol's execution. As $t_L = 1$ and $t_R = 0$, the requirements of $\Pi$ are satisfied: termination and simplified stability hold. Therefore, $c$ outputs $v$. Moreover, this scenario is indistinguishable to $c$ from the first scenario, hence $c$ matches with $v$ in the first scenario as well.


We consequently obtain a contradiction: in the first scenario, both $a$ and $c$ are honest and match with the same party, which breaks non-competition.
\end{proof}

As the bipartite communication model is weaker than the one-sided model, \cref{lemma:with-pki-one-sided-impossible} provides the following corollary.
\begin{corollary}\label{corollary:with-pki-bipartite-impossible}
If $t_R = k$ (resp. $t_L = k$) and $t_L \geq k/3$ (resp. $t_R \geq k/3$), then achieving $\byzantineSM$ in a bipartite network is impossible.
\end{corollary}




\paragraph{Putting it all together.} We conclude the section by providing the formal proofs of \cref{thm:bipartite-pki-main} and \cref{thm:one-sided-pki-main}. 
We first present the proof of \cref{thm:bipartite-pki-main}, focusing on a bipartite network.



\begin{proof}[Proof of \cref{thm:bipartite-pki-main}]
We first discuss sufficiency.
If $t_L < k$ and $t_R < k$, Corollary \ref{coro:with-pki-complete} enables us to assume a fully-connected network. Therefore, using \cref{theo:with-pki-complete}, we obtain that $\byzantineSM$ is solvable. If $t_L < k / 3$ and $t_R \leq k$, \cref{lemma:protocol-omissions} describes a protocol achieving $\byzantineSM$. The case $t_R < k / 3$ and $t_L \leq k$ is symmetrical.


Otherwise, if $t_L \geq k/3$ and $t_R = k$ or the opposite, we may apply Corollary \ref{corollary:with-pki-bipartite-impossible} and conclude that $\byzantineSM$ is impossible. 
\end{proof}


We now prove \cref{thm:one-sided-pki-main}, discussing the one-sided network case.
\begin{proof}[Proof of \cref{thm:one-sided-pki-main}]
For sufficiency, when $t_R < k$, we may apply \cref{lemma:with-pki-one-sided} and hence assume a fully-connected network. Then, \cref{theo:with-pki-complete} enables us to conclude that $\byzantineSM$ is solvable. If $t_R = k$ and $t_L < k/3$, \cref{theorem:main:no-pki-one-sided} guarantees that $\byzantineSM$ is solvable.
    
When none of these conditions holds, i.e., if $t_R = k$ and if $t_L \geq k/3$, \cref{lemma:with-pki-one-sided-impossible} enables us to conclude that $\byzantineSM$ is impossible.
\end{proof}
