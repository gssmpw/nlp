\section{Typing Algorithms}\label{app:alg}

\subsection{Type Synthesis}

\begin{figure}[H]
    \begin{multicols}{2}
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\under{v: b \;|\; \bot \;|\; \bot}, \; err())
            }{
                \Gamma \vdash err \;\textcolor{Green}{\Rightarrow}\; (\under{v: b \;|\; \bot \;|\; \bot}, \; err())
            }
            \tag{\textsc{SynErr}}
            \label{eq:synerr}
        \end{equation}
        
        \columnbreak
    
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\text{Ty}(c), \; \epsilon)
            }{
                \Gamma \vdash c \;\textcolor{Green}{\Rightarrow}\; (\text{Ty}(c), \; \epsilon)
            }
            \tag{\textsc{SynConst}}
            \label{eq:synconst}
        \end{equation}
    \end{multicols}

    \begin{multicols}{2}
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\text{Ty}(op), \; \epsilon)
            }{
                \Gamma \vdash op \;\textcolor{Green}{\Rightarrow}\; (\text{Ty}(op), \; \epsilon)
            }
            \tag{\textsc{SynOp}}
            \label{eq:synop}
        \end{equation}

        \columnbreak

        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\text{Ty}(\alpha), \; \epsilon)
            }{
                \Gamma \vdash \alpha \;\textcolor{Green}{\Rightarrow}\; (\text{Ty}(\alpha), \; \epsilon)
            }
            \tag{\textsc{SynAction}}
            \label{eq:synaction}
        \end{equation}
    \end{multicols}

    \begin{multicols}{2}
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\under{v: b \;|\; v = x \;|\; v = x}, \; \epsilon)
            }{
                \Gamma \vdash x \;\textcolor{Green}{\Rightarrow}\; (\under{v: b \;|\; v = x \;|\; v = x}, \; \epsilon)
            }
            \tag{\textsc{SynVarBase}}
            \label{eq:synvarb}
        \end{equation}

        \columnbreak

        \begin{equation}
            \frac{
                \Gamma(x) = (a: \tau_a \rightarrow \kappa) \quad \Gamma \vdash^{\textbf{WF}} (a:\tau_a \rightarrow \kappa, \; \epsilon)
            }{
                \Gamma \vdash x \;\textcolor{Green}{\Rightarrow}\; (a:\tau_a \rightarrow \kappa, \; \epsilon)
            }
            \tag{\textsc{SynVarFun}}
            \label{eq:synvarf}
        \end{equation}
    \end{multicols}

    \begin{equation}
        \frac{
            \begin{gathered}
                \neg(\kappa_x = \pi) \quad \Gamma \vdash v_1 \textcolor{Green}{\;\Rightarrow\;} (a{:}\overa{v: b \;|\; \phi} \rightarrow \kappa_x, \; H_{v_1}) \quad \Gamma \vdash v_2 \textcolor{Green}{\;\Rightarrow\;} (\under{v: b \;|\; \psi \;|\; \theta}, \; H_{v_2}) \\
                \Gamma' = a:\under{v: b \;|\; v = v_2 \;\land\; \phi \;|\; v = v_2 \;\land\; \phi}, \; x:\kappa_x \quad \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \\
                \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \; H_{v_1} \cdot H_{v_2} \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \;\texttt{let}\; x = v_1 \; v_2 \;\texttt{in}\; e \;\textcolor{Green}{\Rightarrow}\; (\tau', \;H_{v_1} \cdot H_{v_2} \cdot H_e')
        }
        \tag{\textsc{SynAppBaseMulti}}
        \label{eq:synappbasemulti}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash v_1 \textcolor{Green}{\;\Rightarrow\;} (a{:}\overa{v: b \;|\; \phi} \rightarrow (\tau_{v_1}, \;H_{\tau_{v_1}}), \; H_{v_1}) \quad \Gamma \vdash v_2 \textcolor{Green}{\;\Rightarrow\;} (\under{v: b \;|\; \psi \;|\; \theta}, \; H_{v_2}) \\
                \Theta = \{[Y/X] \;|\; new(X) \in H_{\tau_{v_1}} \;\land\; \nextd(\Delta) = Y\} \\
                H_{\tau_{v_1}}^{\star} = \bind(a: \under{v: b \;|\; v = v_2 \;\land\; \phi}, \; H_{\tau_{v_1}}(\Theta)) \\
                \Gamma' = a: \under{v: b \;|\; v = v_2 \;\land\; \phi \;|\; v = v_2 \;\land\; \phi}, \; x:\tau_{v_1}(\Theta) \quad \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \;H_e) \\
                \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \;H_{v_1} \cdot H_{v_2} \cdot H_{\tau_{v_1}}^{\star} \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \;\texttt{let}\; x = v_1 \; v_2 \;\texttt{in}\; e \textcolor{Green}{\;\Rightarrow\;} (\tau', \; H_{v_1} \cdot H_{v_2} \cdot H_{\tau_{v_1}}^{\star} \cdot H_e')
        }
        \tag{\textsc{SynAppBaseLast}}
        \label{eq:synappbaselast}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash e_x \textcolor{Green}{\;\Rightarrow\;} (\tau_x, \; H_{e_x}) \quad \Gamma' = x:\tau_x \quad \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \\
                \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \; H_{e_x} \cdot H_e')
            \end{gathered}  
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = e_x\;\texttt{\small{in}}\;e \textcolor{Green}{\;\Rightarrow\;} (\tau', \; H_{e_x} \cdot H_e')
        }
        \tag{\textsc{SynLetE}}
        \label{eq:synlete}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash op \textcolor{Green}{\;\Rightarrow\;} (\overline{a_i{:}\overa{v: b_i \;|\; \phi_i}} \rightarrow \tau_x, \; H_{op} ) \quad \forall i, \Gamma \vdash u_i \textcolor{Green}{\;\Rightarrow\;} (\under{v: b_i \;|\; \psi_i \;|\; \theta_i}, \;H_{u_i}) \\
                \Gamma' = \overline{a_i : \under{v: b_i \;|\; v = u_i \;\land\; \phi_i \;|\; u_i \;\land\; \phi_i}} \quad \Gamma, \Gamma' \vdash e : (\tau, \; H_e) \\
                \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad 
                H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad 
                \Gamma \vdash^{\textbf{WF}} (\tau', \; H_{op} \cdot ( \underset{i}{\bullet} \; H_{u_i} ) \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = op\;\overline{u_i}\;\texttt{\small{in}}\;e \textcolor{Green}{\;\Rightarrow\;} (\tau', \; H_{op} \cdot ( \underset{i}{\bullet} \; H_{u_i} ) \cdot H_e')
        }
        \tag{\textsc{SynAppOp}}
        \label{eq:synappop}
    \end{equation}
    \caption{Extension of type synthesis algorithms - Part I.}
    \label{fig:type-synthesis-1}
\end{figure}

\begin{figure}[H]
    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash u_a \textcolor{Green}{\;\Rightarrow\;} (\tau_{u_a}, \;H_{u_a}) \quad \forall i, \Gamma'_i = \overline{y: \tau_y} \quad \Gamma, \Gamma' \vdash d_i(\overline{y}) \textcolor{Green}{\;\Rightarrow\;} (\tau_{d_i}, \;H_{d_i}) \quad H_{d_i}' = \bind(\Gamma_{i'_{\psi}}, \;H_{d_i}) \\
                \forall i, \text{Ty}(d_i) = \overline{y{:}\overa{v: b_y \;|\; \theta_y}} \rightarrow \under{v: b \;|\; \psi_i \;|\; \psi_i} \\
                \Gamma''_{i} = \overline{y{:}\under{v: b_y \;|\; \theta_y \;|\; \theta_y}}, \;a{:}\under{v: b \;|\; v = u_a \;\land\; \psi_i \;|\; v = u_a \;\land\; \psi_i} \\
                \Gamma, \Gamma''_{i} \vdash e_i \textcolor{Green}{\;\Rightarrow\;} (\tau_i, \; H_i) \quad \tau'_i = \textcolor{blue}{\text{Ex}}(\Gamma''_{i}, \;\tau_i) \quad H_i' = \bind(\Gamma_{i''_{\psi}}, \;H_i) \\
                \Gamma \vdash^{\textbf{WF}} (\textcolor{blue}{\text{Disj}}(\overline{\tau'_i}), \;H_{u_a} \cdot (\underset{i}{\bullet} \;H_{d_i}) \cdot \underset{i}{\bigoplus} \;H_i')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{match} \;u_a\; \texttt{with}  \; \overline{d_i\overline{y} \rightarrow e_i} \textcolor{Green}{\;\Rightarrow\;} (\textcolor{blue}{\text{Disj}}(\overline{\tau'_i}), \; H_{u_a} \cdot (\underset{i}{\bullet} \; H_{d_i}') \cdot \underset{i}{\bigoplus} \; H_i')
        }
        \tag{\textsc{SynMatch}}
        \label{eq:synmatch}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \neg(\kappa_x = \pi) \quad \Gamma \vdash v_1 \textcolor{Green}{\;\Rightarrow\;} ((\tau_1 \rightarrow \kappa_1) \rightarrow \kappa_x, \; H_{v_1}) \quad \Gamma \vdash v_2 \textcolor{purple}{\;\Leftarrow\;} (\tau_1 \rightarrow \kappa_1, \; H_{v_2}) \quad \Gamma' = x : \kappa_x \\
                \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \quad \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \; H_{v_1} \cdot H_{v_2} \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = v_1\;v_2\;\texttt{\small{in}}\;e : (\tau', \; H_{v_1} \cdot H_{v_2} \cdot H_e')
        }
        \tag{\textsc{SynAppFunMulti}}
        \label{eq:synappfunmulti}
    \end{equation}
    
    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash v_1 \textcolor{Green}{\;\Rightarrow\;} ((\tau_1 \rightarrow \kappa_1) \rightarrow (\tau_{v_1}, \; H_{\tau_{v_1}}), \; H_{v_1}) \quad \Gamma \vdash v_2 \textcolor{purple}{\;\Leftarrow\;} (\tau_1 \rightarrow \kappa_1, \; H_{v_2}) \quad \Gamma' = x : \tau_{v_1} \\
                \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \quad \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \; H_{v_1} \cdot H_{v_2} \cdot H_{\tau_{v_1}} \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = v_1\;v_2\;\texttt{\small{in}}\;e : (\tau', \; H_{v_1} \cdot H_{v_2} \cdot H_{\tau_{v_1}} \cdot H_e')
        }
        \tag{\textsc{SynAppFunLast}}
        \label{eq:synappfunlast}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma' = x: \under{v: r \;|\; v = X \;|\; v = X} \quad \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \quad \nextd(\Delta) = X \\
                \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \; \tau) \quad H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \; \texttt{\small{new}}_r(X) \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = \texttt{\small{new}}_r\;()\;\texttt{\small{in}}\;e : (\tau, \;\texttt{\small{new}}_r(X) \cdot H_e)
        }
        \tag{\textsc{SynNew}}
        \label{eq:synew}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma' = x : \under{v: api \;|\; v = F \;|\; v = F} \quad \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \quad \Delta(F) = \tau_{F} \\
                \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad H_e' = \bind(\Gamma'_{\psi}, \;H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \; \texttt{\small{get}}(F) \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = \texttt{\small{get}}\;F\;\texttt{\small{in}}\;e : (\tau, \; \texttt{\small{get}}(F) \cdot H_e)
        }
        \tag{\textsc{SynGet}}
        \label{eq:syngetapi}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash \alpha \textcolor{Green}{\;\Rightarrow\;} (\overline{a_i{:}\overa{v: b_i \;|\; \phi_i}} \rightarrow \tau_x, \;H_{\alpha}) \\
                \forall i, \; \Gamma \vdash u_i \textcolor{Green}{\;\Rightarrow\;} (\under{v: b_i \;|\; \psi_i \;|\; \theta_i}, \; H_{u_i}) \quad \Gamma' = \overline{a_i{:}\under{v: b_i \;|\; v = u_i \;\land\; \phi_i \;|\; v = u_i \;\land\; \phi_i}} \quad \Gamma'' = \Gamma', x:\tau_x \\
                \Gamma, \Gamma'' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \quad \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma'', \;\tau) \quad H_e' = \bind(\Gamma''_{\psi}, \;H_e) \\
                H^{\star} = \bind(\Gamma'_{\psi}, \;\alpha(\overline{b_i{:}v = a_i})) \quad \Gamma \vdash^{\textbf{WF}} (\tau', \;H_\alpha \cdot ( \underset{i}{\bullet} \; H_{u_i} ) \cdot H^{\star} \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = \alpha \; \overline{u_i}\;\texttt{\small{in}}\;e \textcolor{Green}{\;\Rightarrow\;} (\tau', \; H_\alpha \cdot ( \underset{i}{\bullet} \; H_{u_i} ) \cdot H^{\star} \cdot H_e')
        }
        \tag{\textsc{SynLetAction}}
        \label{eq:synletaction}
    \end{equation}
    \caption{Extension of type synthesis algorithms - Part II.}
    \label{fig:type-synthesis-2}
\end{figure}

\begin{figure}[H]
    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash f \textcolor{Green}{\;\Rightarrow\;} \under{v: api \;|\; \phi \;|\; \psi} \quad \forall i, \; \Gamma \vdash y_i \textcolor{Green}{\;\Rightarrow\;} (\under{v: b_i \;|\; \phi_i \;|\; \psi_i}, \;H_{y_i}) \\
                \under{v: api \;|\; \phi' \;|\; \psi'} = \textsc{\textcolor{blue}{Ex}}(\Gamma, \;\under{v: api \;|\; \phi \;|\; \psi}) \quad Api = \{F \;|\; \phi'[v \mapsto F] \;\land\; \Delta(F)\downarrow\} \\
                \forall F \in Api, \;\Delta(F) = \overline{a_i{:}\overa{v: b_i \;|\; \theta_i}} \rightarrow (\tau_{F_x}, \; H_{F_x}) \;\land\; \Gamma \vdash^{\textbf{WF}} \overline{a_i{:}\overa{v: b_i \;|\; \theta_i}} \rightarrow (\tau_{F_x}, \; H_{F_x}) \\
                \textsc{\textcolor{blue}{Disj}}(\overline{\tau_{F_x}}) = \tau_x \quad \Gamma' = \overline{a_i: \under{v: b_i \;|\; v = y_i \;\land\; \theta_i \;|\; v = y_i \;\land\; \theta_i}}, \;x:\tau_x \\
                \Gamma, \Gamma' \vdash e \textcolor{Green}{\;\Rightarrow\;} (\tau, \; H_e) \quad \tau' = \textsc{\textcolor{blue}{Ex}}(\Gamma', \;\tau) \quad H_e' = \bind(\Gamma', \;H_e) \\
                \Gamma \vdash^{\textbf{WF}} (\tau', \; ( \underset{i}{\bullet} \; H_{y_i} ) \cdot call(\psi; \;\overline{a_i{:}(b_i{:}v = y_i \;\land\; \theta_i})) \cdot H_e')
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = f\;\overline{y_i}\; \texttt{\small{in}}\;e \textcolor{Green}{\;\Rightarrow\;} (\tau', \; ( \underset{i}{\bullet} \; H_{y_i} ) \cdot call(\psi; \;\overline{a_i{:}(b_i{:}v = y_i \;\land\; \theta_i})) \cdot H_e')
        }
        \tag{\textsc{SynAppAPI}}
        \label{eq:synappapi}
    \end{equation}
    \caption{Extension of type synthesis algorithms - Part III.}
    \label{fig:type-synthesis-3}
\end{figure}

\subsection{Type Check}

\begin{figure}[ht]
    \begin{multicols}{2}
        \begin{equation}
            \frac{
                \varnothing \vdash e \textcolor{Green}{\;\Rightarrow\;} \pi \quad \Gamma \vdash \pi <: \pi' \quad \Gamma \vdash^{\textbf{WF}} \pi'
            }{
                \Gamma \vdash e \textcolor{purple}{\;\Leftarrow\;} \pi'
            }
            \tag{\textsc{ChkSub}}
            \label{eq:chksub}
        \end{equation}

        \columnbreak
    
        \begin{equation}
            \frac{
                \Gamma, x: \tau_x \vdash e \textcolor{purple}{\;\Leftarrow\;} \pi \quad \Gamma \vdash^{\textbf{WF}} (x: \tau_x \rightarrow \pi, \; \epsilon)
            }{
                \Gamma \vdash \lambda x : \lfloor\tau_x\rfloor. e \textcolor{purple}{\;\Leftarrow\;} (x: \tau_x \rightarrow \pi, \; \epsilon)
            }
            \tag{\textsc{ChkFun}}
            \label{eq:chkfun}
        \end{equation}
    \end{multicols}
    
    \begin{equation}
        \frac{
            \Gamma, x: \tau_x \vdash e \textcolor{purple}{\;\Leftarrow\;} (y: \tau_y \rightarrow \kappa, \; \epsilon) \quad \Gamma \vdash^{\textbf{WF}} (x: \tau_x \rightarrow y: \tau_y \rightarrow \kappa, \; \epsilon)
        }{
            \Gamma \vdash \lambda x : \lfloor\tau_x\rfloor. e \textcolor{purple}{\;\Leftarrow\;} (x: \tau_x \rightarrow y: \tau_y \rightarrow \kappa, \; \epsilon)
        }
        \tag{\textsc{ChkFunFlat}}
        \label{eq:chkflat}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \nextd(\Delta, \;x{:}\overa{v: b \;|\; v \prec x \;\land\; \phi} \rightarrow \overline{\tau_i} \rightarrow (\tau, \;\epsilon)) = F \\
                \Gamma, x{:}\overa{v: b \;|\; \phi}, f{:}\under{v: api \;|\; v = F \;|\; v = F} \vdash e \textcolor{purple}{\;\Leftarrow\;} \overline{\tau_i} \rightarrow (\tau, \;H) \\
                A = \{x{:}(b{:}\phi)\} \cup \{a_i{:}(b_i{:}\psi_i) \;|\; \tau_i = a_i{:}\overa{v: b_i \;|\; \psi_i}\} \quad \Gamma \vdash^{\textbf{WF}} (x{:}\overa{v: b \;|\; \phi} \rightarrow \overline{\tau_i} \rightarrow (\tau, \;H), \;\mu F(A)(H))
            \end{gathered}
        }{
            \Gamma \vdash \text{fix}\;f{:}(b \rightarrow \lfloor\kappa\rfloor).\lambda x{:}b.\;e \textcolor{purple}{\;\Leftarrow\;} (x{:}\overa{v: b \;|\; \phi} \rightarrow \overline{\tau_i} \rightarrow (\tau, \;H), \;\mu F(A)(H))
        }
        \tag{\textsc{ChkFix}}
        \label{eq:chkfix}
    \end{equation}
    \caption{Extension of type check algorithms.}
    \label{fig:type-check}
\end{figure}

\newpage

\subsection{Auxiliary Functions}

\begin{algorithm}[ht]
    \caption{Exists}\label{alg:ex}
    \begin{algorithmic}[1]
        \Procedure {\textcolor{blue}{Ex}}{$x$, $\under{v: t \;|\; \phi_x \;|\; \psi_x}$, $\tau$}
            \Match {$\tau$}
                \Case {$\under{v: t \;|\; \phi \;|\; \psi}$}
                    \State \Return $\under{v: t \;|\; \exists x: t, \phi_x[v \mapsto x] \;\land\; \phi \;|\; \exists x: t, \psi_x[v \mapsto x] \;\land\; \psi}$
                \EndCase
                \Case {$(\tau_H, \;H)$}
                    \State \Return $(\Call{\textcolor{blue}{Ex}}{x, \under{v: t \;|\; \phi_x \;|\; \psi_x}, \;\tau_H}, \;\bind(x:\under{v: t \;|\; \psi_x}, \;H))$
                \EndCase
                \Case {$\overa{v: t \;|\; \phi}$}
                    \State \Return $\overa{v: t \;|\; \forall x: t, \phi_x[v \mapsto x] \Longrightarrow \phi}$
                \EndCase
                \Case {$a{:}\tau_a \rightarrow \kappa$}
                    \State $\tau_a' \gets \Call{\textcolor{blue}{Fa}}{x, \under{v: t \;|\; \phi_x \;|\; \psi_x}, \;\tau_a}$
                    \State \Return {$a{:}\tau'_a \rightarrow \Call{\textcolor{blue}{Ex}}{x, \under{v: t \;|\; \phi_x \;|\; \psi_x}, \;\kappa}$}
                \EndCase
            \EndMatch
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
    \caption{ForAll}\label{alg:forall}
    \begin{algorithmic}[1]
          \Procedure {\textcolor{blue}{Fa}}{$x$, $\under{v: t \;|\; \phi_x \;|\; \psi_x}$, $\tau$}
            \Match {$\tau$}
                \Case {$\under{v: t \;|\; \phi \;|\; \psi}$}
                    \State \Return $\under{v: t \;|\; \forall x: t, \phi_x[v \mapsto x] \Longrightarrow \phi \;|\; \forall x: t, \psi_x[v \mapsto x] \Longrightarrow \psi}$
                \EndCase
                \Case {$(\tau_H, \;H)$}
                    \State \Return $(\Call{\textcolor{blue}{Fa}}{x, \under{v: t \;|\; \phi_x \;|\; \psi_x}, \;\tau_H}, \;\bind(x:\under{v: t \;|\; \psi_x}, \;H))$
                \EndCase
                \Case {$\overa{v: t \;|\; \phi}$}
                    \State \Return $\overa{v: t \;|\; \exists x: t, \phi_x[v \mapsto x] \;\land\; \phi}$
                \EndCase
                \Case {$a{:}\tau_a \rightarrow \kappa$}
                    \State $\tau_a' \gets \Call{\textcolor{blue}{Ex}}{x, \under{v: t \;|\; \phi_x \;|\; \psi_x}, \;\tau_a}$
                    \State \Return {$a{:}\tau'_a \rightarrow \Call{\textcolor{blue}{Fa}}{x, \under{v: t \;|\; \phi_x \;|\; \psi_x}, \;\kappa}$}
                \EndCase
            \EndMatch
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
    \caption{Disjunction}\label{alg:disj}
    \begin{algorithmic}[1]
        \Procedure {\textcolor{blue}{Disj}}{$\Gamma$, $\tau_1$, $\tau_2$}
            \Match {$\tau_1$, $\tau_2$}
                \Case {$\under{v: t \;|\; \phi_1 \;|\; \psi_1}$, $\under{v: t \;|\; \phi_2 \;|\; \psi_2}$}
                    \State \Return $\under{v: t \;|\; \phi_1 \;\lor\; \phi_2 \;|\; \psi_1 \;\lor\; \psi_2}$
                \EndCase
                \Case {$(\tau_{H_1}, \;H_1)$, $(\tau_{H_2}, \;H_2)$}
                    \State \Return $(\Call{\textcolor{blue}{Disj}}{\Gamma, \;\tau_{H_1}, \;\tau_{H_2}}, \;H_1 + H_2)$
                \EndCase
                \Case {$\overa{v: t \;|\; \phi_1}$, $\overa{v: t \;|\; \phi_2}$}
                    \State \Return $\overa{v: t \;|\; \phi_1 \;\land\; \phi_2}$
                \EndCase
                \Case {$a{:}\tau_{a_1} \rightarrow \kappa_1$, $a{:}\tau_{a_2} \rightarrow \kappa_2$}
                    \State $\tau_a \gets \Call{\textcolor{blue}{Conj}}{\Gamma, \;\tau_{a_1}, \;\tau_{a_2}}$
                    \State \Return {$a{:}\tau_a \rightarrow \Call{\textcolor{blue}{Disj}}{\Gamma, \;\kappa_1, \;\kappa_2}$}
                \EndCase
            \EndMatch
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
    \caption{Conjunction}\label{alg:conj}
    \begin{algorithmic}[1]
        \Procedure {\textcolor{blue}{Conj}}{$\Gamma$, $\tau_1$, $\tau_2$}
            \Match {$\tau_1$, $\tau_2$}
                \Case {$\under{v: t \;|\; \phi_1 \;|\; \psi_1}$, $\under{v: t \;|\; \phi_2 \;|\; \psi_2}$}
                    \State \Return $\under{v: t \;|\; \phi_1 \;\land\; \phi_2 \;|\; \psi_1 \;\land\; \psi_2}$
                \EndCase
                \Case {$(\tau_{H_1}, \;H_1)$, $(\tau_{H_2}, \;H_2)$}
                    \State $H_3 \gets \Call{\textcolor{Mahogany}{HistConj}}{\Gamma, \;H_1, \;H_2}$
                    \If{$H_3 = \bot$}
                        \State \Return \Failure
                    \Else
                        \State \Return $(\Call{\textcolor{blue}{Conj}}{\Gamma, \;\tau_{H_1}, \;\tau_{H_2}}, \;H_3)$
                    \EndIf
                \EndCase
                \Case {$\overa{v: t \;|\; \phi_1}$, $\overa{v: t \;|\; \phi_2}$}
                    \State \Return $\overa{v: t \;|\; \phi_1 \;\lor\; \phi_2}$
                \EndCase
                \Case {$a{:}\tau_{a_1} \rightarrow \kappa_1$, $a{:}\tau_{a_2} \rightarrow \kappa_2$}
                    \State $\tau_a \gets \Call{\textcolor{blue}{Disj}}{\Gamma, \;\tau_{a_1}, \;\tau_{a_2}}$
                    \State \Return {$a{:}\tau_a \rightarrow \Call{\textcolor{blue}{Conj}}{\Gamma, \;\kappa_1, \;\kappa_2}$}
                \EndCase
            \EndMatch
        \EndProcedure
    \end{algorithmic}
\end{algorithm}