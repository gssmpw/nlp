In the original work on Coverage Types, a number of algorithms for typing were also presented in order to have semantics-independent rules that are easy to implement structurally.

\textcolor{Green}{Type synthesis} and \textcolor{purple}{type check} rules were presented as substitutes for type system rules, and algorithms were also proposed to achieve well-formedness, to check subtyping relationships, and to obtain disjointed types.

\subsection{Auxiliary Typing Algorithms}

The algorithm to obtain well-formedness for History Expressions, to be used in conjunction with \textsc{\textcolor{blue}{Ex}} and \textsc{\textcolor{blue}{Forall}}, does not need to be implemented, it is sufficient to use \bind, as the context-dependent denotation is defined by this exact function.

Even for the \textsc{\textcolor{blue}{Disj}} algorithm, which implements the disjunction, we have already seen how the intersection between the denotations of two History Expressions leads to a third history corresponding to the non-deterministic choice of the previous ones.

\begin{equation}
    H_1 + H_2 = H_3 \Longrightarrow \llbracket H_1 \rrbracket_{\Gamma_{\psi}} \cup \llbracket H_2 \rrbracket_{\Gamma_{\psi}} = \llbracket H_3 \rrbracket_{\Gamma_{\psi}}
\end{equation}

Thus, the only algorithms that need to be implemented from zero for History Expressions concern only the subtyping relation, to be used with the \textsc{\textcolor{blue}{Query}}, and the conjunction \textsc{\textcolor{blue}{Conj}}.

In order to structurally verify the subtyping relationship for histories, it is necessary that the histories themselves comply with general construction rules. We therefore introduce the Normal Form for History Expressions.

\begin{definition}[History Expression in Normal Form]
    A History Expression $H^{\sharp}$ is said to be in Normal Form if it respects the following properties:
    \begin{itemize}
        \item $H^{\sharp} = \underset{i}{\bigoplus} \; H^c_i, \; \forall i. \;H^c_i = \underset{j}{\bullet} \; H^T_j$
        \item $\forall H^c_i, \;\exists H,\; H^c_i = H \cdot \epsilon \;\land\; \epsilon \notin H$
        \item $\forall H^c_i, \;\forall \mu F(\overline{a{:}(b{:}\phi)})(H_{rec}) \in H^c_i, \; \mathcal{NF}(H_{rec}) \;\land\; \exists H', H'', H''', \\
        H^c_i = H' \cdot \mu F(\overline{a{:}(b{:}\phi)})(H_{rec}) \cdot H'' \cdot H''' \;\land\; (H'' = \epsilon \;\lor\; (H'' = call(\psi; \;\overline{c{:}(b{:}\theta})) \;\land\; \phi[v \mapsto F]))$
    \end{itemize}
    With $H^T$ defined as:
    \begin{equation}
        H^T := \epsilon \;|\; \alpha(\overline{r{:}\phi}) \;|\; new_r(X) \;|\; get(F) \;|\; call(\phi; \;\overline{a{:}(b{:}\psi)}) \;|\; \mu F(\overline{a{:}(b{:}\phi)})(H_F)
    \end{equation}
    \label{def:nf}
\end{definition}

That is, 
\begin{enumerate*}[label=(\roman*)]
    \item $H^{\sharp}$ must be written in extended form as a series of deterministic choices within which only the expressions defined in $H^T$ must be present in concatenation.
    \item Next, we find that for each of these concatenations, $\epsilon$ must be present \textbf{only} at the end.
    \item Finally, for each statement of a recursive function within each concatenation, we want the effect associated with the recursive function to be in Normal Form, and for the statement to be shifted as far to the right as possible, so that either it is the penultimate expression, before $\epsilon$, or immediately afterwards there is a potential call to the function itself.
\end{enumerate*}

We can now show the \subhist\ procedure for checking the subtyping relationship between two History Expressions $H_1$ and $H_2$ which must fulfil two conditions:

\begin{itemize}
    \item Being in Normal Form.
    \item Be in well-formedness with respect to the empty context, i.e. all logical formulae within them must not contain free variables.
\end{itemize}

The \subhist\ procedure is shown in Algorithm \ref{alg:subhist}, and is essentially concerned with checking for each concatenation present in $H_1$ whether there is another one belonging to $H_2$, a subtype of the first. The verification of the subtype relation between concatenations is shown in the Algorithm \ref{alg:subconc} called \subconc. Here we proceed by running the two concatenations on each expression in parallel, checking whether the qualifiers in the first one imply the counterparts in the second. In other words, it is checked whether the values satisfying the qualifiers in the expression of the first history are a subset of those satisfying the qualifiers of the second.

It is good to make an observation about the case of subtyping recursive functions: it is not necessary that the identifier of the two declared functions be the same since, as we have seen during the calculation of denotation, the application of a recursive function is not \emph{"saved"}, so essentially we check that, once we have bound all the parameters to the effects of the two functions, the first is subtyped by the second. It is necessary for $H_{res_2}$ and $H_{tail_2}$ to replace the occurrences of $G$ with $F$ otherwise the subtype relation of the $call$ inside may be skipped.

\begin{algorithm}[ht]
    \caption{History Expression Subtyping}\label{alg:subhist}
    \begin{algorithmic}[1]
        \Procedure{\textcolor{Mahogany}{SubHist}}{$H_1$, $H_2$}
            \Match{$H_1$}
                \Case{$H^c$}
                    \For{$H^c_{2_i} \in H_2$}
                        \If{\Call{\textcolor{Mahogany}{SubConc}}{$H^c, \;H^c_{2_i}$}}
                            \State \Return \True
                        \EndIf                       
                    \EndFor
                    \State \Return \False
                \EndCase
                \Case{$H^c + H_{tail}$}
                    \For{$H^c_{2_i} \in H_2$}
                        \If{\Call{\textcolor{Mahogany}{SubConc}}{$H^c, \;H^c_{2_i}$}}
                            \State \Return \Call{\textcolor{Mahogany}{SubHist}}{$H_{tail}$, $H_2$}
                        \EndIf                       
                    \EndFor
                    \State \Return \False
                \EndCase
            \EndMatch
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
    \caption{Concatenation Subtyping}\label{alg:subconc}
    \begin{algorithmic}[1]
        \Procedure{\textcolor{Mahogany}{SubConc}}{$H_1$, $H_2$}
            \Match{$H_1$, $H_2$}
                \Case{$\epsilon$, $\epsilon$}
                    \State \Return \True
                \EndCase
                \Case{$\alpha(\overline{r_i{:}\phi_i}) \cdot H_{tail_1}$, $\alpha(\overline{r_i{:}\psi_i}) \cdot H_{tail_2}$}
                    \State $Res \gets \forall i, \;\forall u{:}r_i, \; \phi[v \mapsto u] \Longrightarrow \psi[v \mapsto u]$
                    \State \Return $Res \;\land\; \Call{\textcolor{Mahogany}{SubConc}}{H_{tail_1}, \;H_{tail_2}}$
                \EndCase
                \Case{$new_r(X) \cdot H_{tail_1}$, $new_r(X) \cdot H_{tail_2}$}
                    \State \Return $\Call{\textcolor{Mahogany}{SubConc}}{H_{tail_1}, \;H_{tail_2}}$
                \EndCase
                \Case{$get(F) \cdot H_{tail_1}$, $get(F) \cdot H_{tail_2}$}
                    \State \Return $\Call{\textcolor{Mahogany}{SubConc}}{H_{tail_1}, \;H_{tail_2}}$
                \EndCase
                \Case{$call(\phi; \;\overline{a_i{:}(b_i{:}\theta_i})) \cdot H_{tail_1}$, $call(\psi; \;\overline{c_i{:}(b_i{:}\sigma_i})) \cdot H_{tail_2}$}
                    \State $Api \gets \forall u{:}api, \;\phi[v \mapsto u] \Longrightarrow \psi[v \mapsto u]$
                    \State $Params \gets \forall i, \;\forall u{:}b_i, \;\theta[v \mapsto u] \Longrightarrow \sigma[v \mapsto u]$
                    \State \Return $Api \;\land\; Params \;\land\; \Call{\textcolor{Mahogany}{SubConc}}{H_{tail_1}, \;H_{tail_2}}$
                \EndCase
                \Case{$\mu F(\overline{a_i{:}(b_i{:}\phi_i)})(H_{res_{1}}) \cdot H_{tail_1}$, $\mu G(\overline{c_j{:}(t_j{:}\psi_j)})(H_{res_2}) \cdot H_{tail_2}$}
                    \State $Body \gets \textsc{\textcolor{Mahogany}{SubHist}}(\bind(\overline{a_i{:}\overa{v{:}b_i \;|\; \phi_i}}, H_{res_1}),$
                    \State \hspace{7.5em}$\bind(\overline{c_j{:}\overa{v{:}t_j \;|\; \psi_j}}, H_{res_2}[F/G]))$
                    \State \Return $Body \;\land\; \Call{\textcolor{Mahogany}{SubConc}}{H_{tail_1}, \;H_{tail_2}[F/G]}$
                \EndCase
                \Default
                    \State \Return \False
                \EndCase
            \EndMatch
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{theorem}[Correctness of Procedure \subhist]
    \begin{equation*}
        \forall \;H_1, H_2. \;\subhist(H_1, \;H_2) \Longrightarrow \varnothing \vdash H_1 <: H_2
    \end{equation*}
\end{theorem}

\begin{proof}
    We first check that the \subconc\ procedure is correct.

    In general, we can state that if we have for two logical formulae a relation of the kind:
    \begin{equation}
        \phi \Longrightarrow \psi
    \end{equation}
    It means that all values satisfying the first qualifier are also contained in the second:
    \begin{equation}
        \{u \;|\; \phi[v \mapsto u]\} \subseteq \{u \;|\; \psi[v \mapsto u]\}
    \end{equation}
    Now let us call the first set $A$ and the second set $B$, since the first is contained in the second, there will exist a third set $C$ such that $B = A \cup C$, and thus there will also exist a third qualifier $theta$ such that the following relations are satisfied:
    \begin{equation}
        \begin{gathered}
            A \subseteq A \cup C \\
            \phi \Longrightarrow \phi \;\lor\; \theta
        \end{gathered}
    \end{equation}
    The subtype relationship can also be rewritten as:
    \begin{equation}
        \varnothing \vdash \alpha(b{:}\phi) <: \alpha(b{:}\phi \;\lor\; \theta)
    \end{equation}
    But the reduction relation for actions presented in Figure \ref{fig:denot_history} calculates exactly all values that satisfy the predicate and place each value in non-deterministic choice, so we can rewrite the previous relation as:
    \begin{equation}
        \varnothing \vdash \alpha(b{:}\phi) <: \alpha(b{:}\phi) + \alpha(b{:}\theta)
    \end{equation}
    And here the demonstration ends as by switching to denotations the relationship is correct:
    \begin{equation}
        \llbracket \alpha(b{:}\phi) \rrbracket \subseteq \llbracket \alpha(b{:}\phi) \rrbracket \cup \llbracket \alpha(b{:}\theta) \rrbracket
    \end{equation}
    For the other cases, the demonstration is trivial or mirrors the one for actions as for external function calls.

    Let us finish by showing the correctness then of the \subhist\ procedure, in this case $H_1$ and $H_2$ being in Normal Form we can rewrite the subtyping relation as:
    \begin{equation}
        \varnothing \vdash H_1^{c_1} + H_1^{c_2} + \dots + H_1^{c_n} <: H_2^{c_1} + H_2^{c_2} + \dots + H_2^{c_m}
    \end{equation}
    And thus prove that:
    \begin{equation}
        \llbracket H_1^{c_1} \rrbracket \cup \llbracket H_1^{c_2} \rrbracket \cup \dots \cup \llbracket H_1^{c_n} \rrbracket \subseteq \llbracket H_2^{c_1} \rrbracket \cup \llbracket H_2^{c_2} \rrbracket \cup \dots \cup \llbracket H_2^{c_m} \rrbracket
    \end{equation}
    But having already proved the correctness of the procedure \subconc, we know that \textbf{for all} concatenation of $H_1$ \textbf{exists} at least one concatenation $H_2$ supertype of this one:
    \begin{equation}
        \forall i. 1 \leq i \leq n. \;\exists j. 1 \leq j \leq m. \;\llbracket H_1^{c_i} \rrbracket \subseteq \llbracket H_2^{c_j} \rrbracket
    \end{equation}
    Using the set operator of union on both the right and the left side of the subset relation we have that the denotation of $H_1$ will be contained in the denotation of another history which will in turn be contained in the denotation of $H_2$ (this is because there is the existential quantifier on the concatenations of $H_2$). Thus $H_1$ will be a subtype of $H_2$.
\end{proof}

We cannot, however, assert the \emph{completeness} of the algorithm \subconc, as a property of minimality would have to be guaranteed and satisfied, both with regard to the unfolding of the recursion $\mu$, but also with regard to the qualifiers present in the $call$ and the $\alpha$ actions.

However, it would be possible to further refine the Normal Form by introducing other constraints, but for our purposes this is not necessary at present.

Figure \ref{fig:alg-subtyping} shows the auxiliary inference rules for subtyping with the appropriate modifications.

\begin{figure}[H]
    \begin{multicols}{2}
        \begin{equation*}
            \frac{
                \models \Call{\textcolor{blue}{Query}}{\Gamma, \;\under{v: b \;|\; \bot}, \;\under{v: b \;|\; \phi}}
            }{
                \texttt{err} \notin \llbracket \under{v: b \;|\; \phi \;|\; \psi} \rrbracket_{\Gamma}
            }
        \end{equation*}
    
        \begin{equation*}
            \frac{
                \models \Call{\textcolor{blue}{Query}}{\Gamma, \;\under{v: b \;|\; \phi_2}, \;\under{v: b \;|\; \phi_1}}
            }{
                \Gamma \vdash \overa{v: b \;|\; \phi_1 \;|\; \psi_1} <: \overa{v: b \;|\; \phi_2}
            }
        \end{equation*}
    \end{multicols}
    
    \begin{equation*}
        \frac{
            \begin{gathered}
                \models \Call{\textcolor{blue}{Query}}{\Gamma, \;\under{v: b \;|\; \phi_1}, \;\under{v: b \;|\; \phi_2}} \\
                \models \Call{\textcolor{blue}{Query}}{\Gamma, \;\under{v: b \;|\; \psi_1}, \;\under{v: b \;|\; \psi_2}} \quad \models \Call{\textcolor{blue}{Query}}{\Gamma, \;\under{v: b \;|\; \psi_2}, \;\under{v: b \;|\; \psi_1}} \\
                H_1^{\star} = \bind(\Gamma_{\psi}, \;H_1) \quad H_2^{\star} = \bind(\Gamma_{\psi}, \;H_2) \quad H^{\sharp}_1 = H^{\star}_1 \quad H^{\sharp}_2 = H^{\star}_2 \quad \models \subhist(H^{\sharp}_1, \;H^{\sharp}_2) \\
            \end{gathered}
        }{
            \Gamma \vdash (\under{v: b \;|\; \phi_1 \;|\; \psi_1}, \;H_1) <: (\under{v: b \;|\; \phi_2 \;|\; \psi_2}, \;H_2)
        }
    \end{equation*}
    \caption{Auxiliary subtyping rules.}
    \label{fig:alg-subtyping}
\end{figure}

Finally, we present the Algorithm \ref{alg:conj-hist}, called \histconj, which allows us to find a History Expression common to two histories $H_1$ and $H_2$. This algorithm makes it possible to implement the conjunction of histories, used when a latent effect belongs to a function that represents an argument of another outer function.

The algorithm fixes each concatenation of $H_1$ and for each other concatenation of $H_2$, it verifies which of the two fixed concatenations is contained in the other (via the \subconc\ procedure) by taking the smaller of the two. All these common histories are each time placed in non-deterministic choice since both $H_1$ and $H_2$ will already be in Normal Form.

The special symbol $\bot$ is used to indicate when a History Expression common to the two could not be found. This may occur because there is no universal subtype (let alone supertype) for the History Expressions presented.

When the history $H_{conj}$ returned by the procedure is equal to $\bot$, the typing procedure will fail.

\begin{algorithm}[H]
    \caption{Histories Conjunction}\label{alg:conj-hist}
    \begin{algorithmic}[1]
        \Procedure{\textcolor{Mahogany}{HistConj}}{$\Gamma$, $H_1$, $H_2$}
            \State $H_{conj} \gets \bot$
            \State $H_1 \gets \bind(\Gamma, \;H_1)$
            \State $H_1 \gets \bind(\Gamma, \;H_2)$
            \For{$H^c_{1_i} \in H_1$}
                \State $H_{common} \gets \bot$
                \For{$H^c_{2_j} \in H_2$}
                    \If{\Call{\textcolor{Mahogany}{SubConc}}{$H^c_{1_i}, \;H^c_{2_j}$}}
                        \If{$H_{common} = \bot$}
                            \State $H_{common} \gets H^c_{1_i}$
                        \Else
                            \State $H_{common} \gets H_{common} + H^c_{1_i}$
                        \EndIf
                    \ElsIf{\Call{\textcolor{Mahogany}{SubConc}}{$H^c_{2_j}, \;H^c_{1_i}$}}
                        \If{$H_{common} = \bot$}
                            \State $H_{common} \gets H^c_{2_j}$
                        \Else
                            \State $H_{common} \gets H_{common} + H^c_{2_j}$
                        \EndIf
                    \EndIf                       
                \EndFor
                \If{$H_{common} \neq \bot$}
                    \If{$H_{conj} \neq \bot$}
                        \State $H_{conj} \gets H_{conj} + H_{common}$
                    \Else
                        \State $H_{conj} \gets H_{common}$
                    \EndIf
                \EndIf
            \EndFor
            \State \Return $H_{conj}$
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

\begin{theorem}[Correctness of Procedure \histconj]
    \begin{equation*}
        \forall \;\Gamma, H_1, H_2. \;\histconj(H_1, \;H_2) = H_3 \;\land\; \neg(H_3 = \bot) \Longrightarrow \Gamma \vdash H_1 \;\land\;H_2 = H_3
    \end{equation*}
\end{theorem}

\begin{proof}
    Since both $H_1$ and $H_2$ are in Normal Form, they will have the following structure:
    \begin{equation}
        \begin{gathered}
            H_1 = H_{1_1}^c + H_{1_2}^c + \dots + H_{1_n}^c \\
            H_2 = H_{2_1}^c + H_{2_2}^c + \dots + H_{2_m}^c
        \end{gathered}
    \end{equation}
    Having fixed a concatenation $H_{1_i}^c$ of $H_1$ we will go on to find the history with the widest denotation that is a subtype of both $H_{1_i}^c$ and $H_2$.
    In fact, at each $j$-th iteration of the second for loop, from the correctness of the procedure \subconc\, if by inductive hypothesis it results that:
    \begin{equation}
        \begin{gathered}
            H_{common} <: H_{1_i}^c \\
            H_{common} <: H_{2_1}^c + H_{2_2}^c + \dots + H_{2_j}^c
        \end{gathered}
    \end{equation}
    At the $j+1$-th iteration it holds that:
    \begin{equation}
        \begin{gathered}
            H^{\star} <: H_{1_i}^c \\
            H^{\star} <: H_{2_{j+1}}^c
        \end{gathered}
    \end{equation}
    Where $H^{\star}$ is the concatenation found to be common between the two fixed. And with the transition to denotations, it is trivial to arrive at the following result:
    \begin{equation}
        \begin{gathered}
            H_{common} + H^{\star} <: H_{1_i}^c \\
            H_{common} + H^{\star} <: H_{2_1}^c + H_{2_2}^c + \dots + H_{2_j}^c + H_{2_{j+1}}^c
        \end{gathered}
    \end{equation}
    By making the transition to denotations, we can state that the denotation of $H_{common}$ is contained in the denotation of the intersection of the two histories:
    \begin{equation}
        \llbracket H_{common} \rrbracket \subseteq \llbracket H_{1_i}^c \rrbracket \cap \llbracket H_{2_1}^c + H_{2_2}^c + \dots + H_{2_j}^c \rrbracket
    \end{equation}
    And that therefore $H_{common}$ is a subtype of the history having as denotation the exact intersection of the two. But there cannot be a history with a denotation larger than $H_{common}$ that is contained in the intersection, this because each time we add a concatenation to $H_{common}$ this is the largest possible common fixed a $H_{1_i}^c$ and a $H_{2_j}^c$! And thus we can conclude that $H_{common}$ corresponds to the intersection.

    Proceeding iteratively on each concatenation $H_{1_i}^c$ of $H_1$, we can conclude that the history contained in $H_{common}$ will correspond to the intersection of $H_1$ and $H_2$.
\end{proof}

The extensions to the original auxiliary algorithms and the \textcolor{Green}{type synthesis} and \textcolor{purple}{type check} rules are given in Appendix \ref{app:alg} as the changes made result at this point quite intuitive.