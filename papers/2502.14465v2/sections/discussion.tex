This paper addressed the issues related to the use of \emph{Coverage Type} \cite{coverage}. These, based on a dual logic to that of \emph{Hoare}, the \emph{Incorrectness Logic}, and relying on a type structure similar to \emph{Refinement Types} \cite{refinement}, allow the definition of a type that provides guarantees of completeness.

These guarantees may be defined through the use of \emph{method predicates}, i.e. uninterpreted functions that take as input one or more values associated with a given base type, also structured as lists or trees, and return a truth value based on the satisfiability of the property by the values passed. The \emph{method predicates} are used within the type qualifiers, which are encoded in first-order logical formulae. The advantage of using logical formulae is the possibility of verifying their satisfiability through the use of \emph{theorem prover} such as \emph{Z3} \cite{z3}; and they also make it easy to implement algorithms in a structured manner that allow for the more procedural use of typing rules; and they also allow for the verification of certain properties between types, such as subtype relations, in a faster and more intuitive manner.

The usefulness of this new notion of type was presented in the context of the \emph{Input Test Generator} functions used in \emph{Property-Based Testing} \cite{PBT1, PBT2}. In this way, statically, we can determine whether an input value generator for a programme, in addition to being \emph{correct}, is also \emph{complete}, and thus allows for the random generation of \emph{all} possible inputs for the programme.
The advantage of having a generator, which is complete, and which randomly generates an input on which to test the programme, not only allows the testing phase to be automated, but also increases the probability of finding errors and borderline cases.

The language $\lambda^{\textbf{TG}}$, however, did not provide for the use, and especially the management, of resources. The concept of \emph{History Expression} \cite{history2, history3, history} was therefore first presented: we have seen how these expressions represent a sequence of events involving resources, and being able to define ordering ($<_{\eta}$) and belonging ($\in$) relations on these, we can go on to define and verify, again by means of first-order logical formulae, the policies that we want to be respected, generally for each of the History Expression $\eta$ that will belong to the denotation of a History Expression $H$.

Thus, firstly, \emph{History Expressions} were formally introduced, with their grammar, semantics, the operations that can be performed on these, and properties of equality and $\alpha$-conversion.

Secondly, we extended the language $\lambda^{\textbf{TG}}$ with resource types, resource identifiers, and actions, i.e., special operators that will be tracked within the History Expressions, as they act on resources. Consequently, new terms have also been added to the language for creating resources, obtaining \emph{API} and invoking them, and for the use of actions.
The most important extension, certainly, concerns the changes made to the types of the language, with the introduction of \textbf{Extended Coverage Types}, which allow \emph{\textbf{all and only}} the values returned by a term to be tracked, enabling History Expressions to be correctly over-approximated; \textbf{History} $\pi$ types, and the addition of latent effects in \textbf{Function Types}.
Thus, we have created the pair $(\tau, \;H)$ in which $\tau$ is a \emph{Extended Coverage Type}, while $H$ is a History Expression: it is worth emphasising that while $\tau$ (by extracting the \emph{Coverage Type} it defines) is a \emph{Under-approximation Type}, $H$ is a \emph{Over-approximation Type}. This reflects the objective we want to focus on, i.e. we want to try to statically establish the \emph{completeness} of an \emph{Input Test Generator}, but we also want to check the \emph{correctness} of resource usage. This justified the use of \emph{over-approximation} logic in the definition of \emph{History Expressions}, as opposed to \emph{Coverage Types}.

After the extension of $\lambda^{\textbf{TG}}$, we presented the appropriate extensions to the \emph{type system} associated with $\lambda^{\textbf{TG}}$, which was shown not to be completely \emph{syntax-driven}, but uses algorithmic procedures such as \nextd, to obtain the next free identifier to be used; and \bind, since, as History Expression have been defined, they are independent of the type logic (over- or under-approximated) associated with the variables within them, and therefore the use of this procedure is necessary to bind the precise qualifier associated with a value or variable on the fly.

Subsequently, we also presented the extension concerning the algorithms for the \emph{\textcolor{Green}{type synthesis}}, for the \emph{\textcolor{purple}{type check}}, and for the auxiliary functions. In the latter case, it was seen that thanks to the logical separation between the return type (\emph{Coverage Type}) and the behaviour type (\emph{History Expression}), the changes made to the algorithms are minimal. Three algorithms, \subhist, \subconc\ and \histconj, were also introduced in order to procedurally verify the subtype relationship between two History Expression $H_1$ and $H_2$. In order to do this, it was necessary for the \emph{history} to be defined in a more structured and common way to facilitate the implementation of the algorithms, hence the \emph{Normal Form} for History Expressions was introduced, which makes use of the equality rules presented in Figure \ref{fig:hist_eq} and the $\alpha$-conversion rules presented in \ref{subsec:alpha}.

The main advantage gained from the expressive power of the History Expressions, especially in recursive functions, is the availability of qualifiers within the \emph{history}: this has made it possible to infer types that represent a very refined \emph{over-approximation}, which is close to the real behaviour of the programme.