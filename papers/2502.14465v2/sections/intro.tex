Resource management and security are essential aspects of software development, as proper handling of these factors can prevent issues ranging from minor bugs to major security vulnerabilities. Here, the term resource refers not only to local resources—such as files, sockets, memory, and network connections—but also, and more importantly, to remote computational entities, such as remote APIs, service entry points, and database connections. The reason for this inclusion is straightforward. For example, even an unopened file could introduce a vulnerability that attackers might exploit. These seemingly simple oversights can be difficult to detect, even at runtime, especially if they occur in rarely accessed execution paths. In such cases, the issue may only become apparent too late, after the software has already been released to users. Implementing robust resource management mechanisms throughout the entire software development lifecycle not only helps prevent bugs and crashes but also strengthens the security and reliability of the software.

To manage resources effectively, software engineering methodologies implement a combination of policies and best practices. Resource management can be approached in two main ways: dynamically \cite{dynamic1-logicguard,dynamic2-java,dynamic3-trace-prop} and statically \cite{static3-types-effects,static1-costa,static2}.

Dynamic resource management involves continuously testing and monitoring software in various environments to identify and address resource-related issues during runtime. This approach exploits tools such as stress testing and runtime monitoring, which are capable of detecting problems like memory leaks, unclosed file handles, and excessive API calls in real-time. By identifying these issues as they occur, developers can promptly address them before they negatively affect the end-user experience. On the other hand, static resource management focuses on analysing the codebase to identify potential violations of resource management policies before the software is executed. By using static analysis tools, developers can catch issues early in the development process, which significantly reduces the risk of bugs and enhances the overall quality of the software \cite{taint}. Several static analyses have been proposed to verify the correct use of program resources \cite{resource-usage,time-regions,enforcing,flow-sensitive,path-sensitive,typestate}. Most of these employ a type-based method to ensure resource safety properties \cite{dynamic4-marriot}. These approaches exploits a type system augmented with suitable annotation about resource usage to guide the analysis.

For the sake of simplicity, we focus on remote APIs. Since the body of a remote function is unknown to us, we cannot predict its behaviour concerning resource usage. Consequently, we cannot define the function reliably. Therefore, it is the responsibility of the API provider to specify not only the parameter and return types but also the function's latent effects. These latent effects must be assumed to reliably characterize the function’s behaviour in relation to the resources it utilizes.

In our approach, we refer to the latent effect of a function as \emph{History Expressions} \cite{history2,history3,history}. Formally, a History Expression is a term within a suitable Basic Process Algebra (BPA) \cite{bpa}. Intuitively, a History Expression represents sequences and non-deterministic choices regarding resource actions, potentially extending infinitely.

In this paper, we focus on a static, type-based verification approach that enables the static analysis of resources by defining usage policies through first-order logic formulas. Our approach integrates two distinct lines of research:

The first research direction involves the definition of a \emph{type and effect system} \cite{types-effects-general,static3-types-effects} for functions, where History Expressions capture the effect by describing the set of possible behaviours of a function concerning resource usage. In other words, a History Expression provides an \emph{over-approximation} of the function's behaviour with respect to resources. Usage policies are then verified against each behaviour in this over-approximation. Unlike the approach in \cite{history}, our method defines usage policies as first-order logic formulas, allowing for efficient validation using specialized theorem provers such as \emph{Z3} \cite{z3}.

The second research direction extends the concept of Coverage Types \cite{coverage} by incorporating History Expressions. Coverage Types capture the set of values that an expression is guaranteed to produce, in contrast to the traditional approach where types represent the potential range of values an expression might yield. Notably, the concept of Coverage Types integrates "must-style" reasoning principles, which are inherently under-approximate \cite{IL1,IL2}, making them a fundamental aspect of the type system.

The extended version of Coverage Types seeks to retain the key characteristics of both approaches outlined above. In particular, we adopt the Coverage Type framework as the foundation for Property-Based Testing (PBT) of programs \cite{PBT1,PBT2}, ensuring that the types reliably capture the behaviour of the program with respect to specified properties. Simultaneously, we introduction of History Expressions facilitates the verification of resource usage within programs, providing a mechanism for tracking and reasoning about resource handling. To demonstrate our approach, we utilize a core programming language as a case study, specifically, a functional programming language that has been enhanced with primitives for executing resource operations. This combination allows us to effectively test properties and verify resource handling in a cohesive and integrated manner.

It is important to note that in our type system, History Expressions are decoupled from the return type logic, whether it involves over- or under-approximation. This separation is a crucial feature, as it allows History Expressions to behave as a versatile formal technique that can be applied across various type systems. However, the goal of verifying properties related to resource usage is not limited to the context of Property-Based Testing, but is applicable to a wide range of programs. Indeed, our approach effectively demonstrates the integration of two distinct logical abstract paradigms, namely over- and under-approximation, within a single type system. Specifically, under-approximation is employed for the return type of an expression (represented by the Coverage Type), while over-approximation governs the type associated with resource behaviour (captured by the History Expression). This dual approach allows for a flexible verification framework, capable of addressing both precise guarantees and broader resource behaviour predictions within the same system.

The paper is organized as follows:
\begin{enumerate}
    \item In Section \ref{sec:overview} we provides an informal, intuitive, step-by-step presentation of the key design choices for the types used, illustrated with an example that effectively demonstrates the semantics of the constructs.
    \item Section \ref{sec:history} formally introduces the concept of \emph{History Expressions} and its formal semantics.
    \item Section \ref{sec:policies} formally presents possible ways of defining policies on a History Expression. 
    \item Sections \ref{sec:tuple_type} and \ref{sec:type_system} focus on introducing the formal relationship between the return type and the behaviour type of functions. Specifically, we extend the language $\lambda^{\textbf{TG}}$ and its type system \cite{coverage} to incorporate History Expressions. In Section \ref{sec:type_system} we present the operational semantics of the language and the main results regarding the correctness of the type system.
    \item Section \ref{sec:algorithm} extends bidirectional typing algorithms \cite{bidirectional-typing} of $\lambda^{\textbf{TG}}$ \cite{coverage}, enabling properties such as subtyping to be verified in a structural, non-semantics-dependent manner.
    \item Section \ref{sec:discussion} summarizes the main contributions of this paper. Finally, Section \ref{sec:conclusion} discusses potential future developments of this work.
\end{enumerate}