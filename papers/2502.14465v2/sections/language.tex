In this section, we introduce our programming language, a functional language, along with its type system, which is based on Coverage Types. Figure \ref{fig:language} illustrates the syntax of the language $\lambda^{\textbf{TG}}$ originally introduced in \cite{coverage}, which has been extended incorporating enhancements in both terms and values, as well as in types.

\begin{figure}[ht]
    \centering
    \begin{tabularx}{\textwidth}{rcX}
        \textbf{Variables} &  & $x, f, u, \dots$ \\
        \textbf{Identifiers} &  & $X, Y, Z, \dots$ \\
        \textbf{Data Constructors} & $d ::= $ & $()$ \textsf{\;\textbar\; true \;\textbar\; false \;\textbar\; O \;\textbar\; S \;\textbar\; Cons \;\textbar\; Nil \;\textbar\; Leaf \;\textbar\; Node} \\
        \textbf{Constants} & $c ::= $ & $\mathbb{B} \;|\; \mathbb{N} \;|\; \mathbb{Z} \;|\; \dots \;|\; d\;\overline{c}$ \\
        \textbf{Operators} & $op ::= $ & $d$ \;\textbar\; $+$ \;\textbar\; $==$ \;\textbar\; $<$ \;\textbar\; \textsf{mod} \;\textbar\; \textsf{nat\_gen} \;\textbar\; \textsf{int\_gen} \;\textbar\; $\dots$ \\
        \textbf{Actions} & $\alpha ::= $ & $read$ \;\textbar\; $write$ \;\textbar\; $open$ \;\textbar\; $close$ \;\textbar\; $\dots$ \\
        \textbf{Values} & $v ::= $ & $c \;|\; op \;|\; x \;|\; \lambda x{:}t{.}e \;|\; \textsf{fix}\;f{:}t{.}\lambda x{:}t{.}e$ \\
        \textbf{Terms} & $e ::= $ & $v$ \;\textbar\; \textsf{err} \;\textbar\; $\texttt{\small{let}} \; x = e \; \texttt{\small{in}} \; e$ \;\textbar\; $\texttt{\small{let}} \; x = op\;\overline{v} \; \texttt{\small{in}} \; e$ \;\textbar\; $\texttt{\small{let}} \; x = v\;v \; \texttt{\small{in}} \; e$ \;\textbar\; $\texttt{\small{match}}\;v\;\texttt{\small{with}}\;\overline{d\;\overline{y} \rightarrow e}$ \;\textbar\; $\texttt{\small{let}}\;x = \alpha \; \overline{v}\;\texttt{\small{in}}\;e \;|\; \texttt{\small{let}}\;x = \texttt{\small{new}}_r \; ()\;\texttt{\small{in}}\;e \;|\; \texttt{\small{let}}\;x = \texttt{\small{get}}\; F \;\texttt{\small{in}}\;e \;|\; \texttt{\small{let}}\;x = f\;\overline{v}\;\texttt{\small{in}}\;e$ \\
        \textbf{Resource Types} & $r ::= $ & $file$ \;\textbar\; $socket$ \;\textbar\; $api$ \;\textbar\; $\dots$ \\
        \textbf{Base Types} & $b ::= $ & $r$ \;\textbar\; $unit$ \;\textbar\; $bool$ \;\textbar\; $nat$ \;\textbar\; $int$ \;\textbar\; $b\;list$ \;\textbar\; $b\;tree$ \;\textbar\; $\dots$ \\
        \textbf{Basic Types} & $t ::= $ & $b$ \;\textbar\; $t \rightarrow t$ \\
        \textbf{Method Predicates} & $mp ::= $ & $emp$ \;\textbar\; $hd$ \;\textbar\; $mem$ \;\textbar\; $\dots$ \\
        \textbf{Literals} & $l :: = $ & $c$ \;\textbar\; $x$ \\
        \textbf{Propositions} & $\phi ::= $ & $l$ \;\textbar\; $\bot$ \;\textbar\; $\top_b$ \;\textbar\; $op(\overline{l})$ \;\textbar\; $mp(\overline{x})$ \;\textbar\; $\neg \phi$ \;\textbar\; $\phi \;\land\; \phi$ \;\textbar\; $\phi \;\lor\; \phi$ \;\textbar\; $\phi \Longrightarrow \phi$ \;\textbar\; $\forall u{:}b . \phi$ \;\textbar\; $\exists u{:}b . \phi$ \\
        \textbf{Refinement Types} & $\tau ::= $ & $\under{v: b \;|\; \phi \;|\; \phi}$ \;\textbar\; $\overa{v: b \;|\; \phi}$ \;\textbar\; $x{:}\tau \rightarrow \kappa$ \\
        \textbf{Function Types} & $\kappa ::= $ & $x{:}\tau \rightarrow \kappa \;|\; \pi$ \\
        \textbf{History Types} & $\pi ::= $ & ($\tau, \;H)$ \\
        \textbf{Type Contexts} & $\Gamma ::= $ & $\varnothing$ \;\textbar\; $\Gamma,x{:}\tau$\\
    \end{tabularx}
    \caption{Syntax of $\lambda^{\textbf{TG}}$ extended for resource use.}
    \label{fig:language}
\end{figure}

Identifiers have been introduced as elements of the the set $Rid$, which is an infinite, countable set (although resources are always finite in any given context). Actions, represented by the symbol $\alpha$, are essentially functions. This means that their types must be predefined. It is crucial that the sets of identifiers and actions remain disjoint, as the inferable history in the type system rules will differ depending on the case.

The set of terms includes new forms of \verb|let-bindings|:
\begin{enumerate*}[label=(\roman*)]
    \item the application of an action
    \item the creation of a new resource
    \item the association to a variable of an external function
    \item the ability to apply a set of values to a variable. This is necessary for the application of APIs after they have been assigned to a variable using the keyword \verb|get|. 
\end{enumerate*}

Also types have been enriched. First, types for resources denoted by $r$ were added to the base types. In the refinement types, the return type of an arrow type has been modified to a function type. $\kappa$. This either recursively enforces the addition of an argument to the function or supports termination inserting the return type, which is now a pair type called a history type, denoted by $\pi$.
Here, $H$ represents the function's latent effect, and $\pi$ becomes the type that must be associated with each expression.

We introduce a number of properties and demonstrations on this extension. First we would like to demonstrate that if when typing an expression the rule \textsc{TSub} is not used then the associated Coverage Type will represent \textbf{\emph{all and only}} the values returned by the expression.

\begin{lemma}
    In the function \emph{Ty}, which associates a constant and an operator with its own type - and used in the rules \textsc{TConst} and \textsc{TOp} - the Coverage Type represents not only some of the values to which the expression reduces, but also represents all of them.
    \label{lemma:ty}
\end{lemma}

\begin{proof}
    The demonstration is divided for both cases:
    \begin{itemize}
        \item A constant $c$ will obviously be a value, so the Coverage Type associated with it will be of the form: $\under{v: b \;|\; v = c}$ for some base type $b$. Trivially, the qualifier represents all and only the values returned by the expression $c$, which being a value will only be $c$ itself.
        \item The type associated with an operator will be an arrow type. Again, the return type will correspond exactly to all and only the values returned by the function. In fact, the Coverage Type corresponding to the return type of an operator can be defined in two ways:
        \begin{itemize}
            \item Or by using the operator within the qualifier, e.g. $\text{Ty}(+) = a{:}\overa{v: int \;|\; \top_{int}} \rightarrow b{:}\overa{v: int \;|\; \top_{int}} \rightarrow \under{v: int \;|\; v = a + b}$.
            \item Or inductively on the base type structure of the returned value, e.g. for binary trees we define the type for leaves: $\text{Ty}(Leaf) = \under{v: b\;tree \;|\; emp(v)}$; and for nodes: $\text{Ty}(Node) = r{:}\overa{v: b \;|\; \top_{b}} \rightarrow l{:}\overa{v: b\;tree \;|\; \top_{b\;tree}} \rightarrow l{:}\overa{v: b\;tree \;|\; \top_{b\;tree}} \rightarrow \under{v: int \;|\; root(v, \;r) \;\land\; left(v, \;l) \;\land\; right(v, \;r)}$.
        \end{itemize}
        In conclusion, we can state that the return type of operators and constructors also depends exactly on the parameters passed, and the values satisfying its qualifier are \emph{\textbf{all and only}} those returned.
    \end{itemize}
\end{proof}

\begin{theorem}
    Typing an expression $e$ with a Coverage Type $\tau$, according to the type system rules of $\lambda^{\textbf{TG}}$, \emph{without the use of the \textsc{TSub} rule} and \emph{taking each branch into account when typing a} \verb|pattern-matching|; either leads to an error situation (even though using all the rules it might be possible to associate $\tau$ with $e$), or if the typing phase ends successfully, it means that $\tau$ not only represents some values that will surely be returned by $e$, but also describes \textbf{all} them.

    The same applies to the typing of a function $f$ with an arrow type $\overline{\tau} \rightarrow \under{v: b \;|\; \phi}$: in this case the property is shifted from the entire function to just the return type.
\end{theorem}

\begin{proof}
    The proof is presented inductively on the rule structure of the type system of $\lambda^{\textbf{TG}}$ \cite{coverage}:
    \begin{itemize}
        \item For the rules \textsc{TConst} and \textsc{TOp}, the demonstration is straightforward as it has already been proven in the previous lemma that the function \emph{Ty} satisfies the desired property. Axiomatically, we state that the rule \textsc{TErr} also conforms to this property since the qualifier $\bot$ can only be associated with divergent computations.
        \item For the rules \textsc{TVarBase}, \textsc{TVarFun}, \textsc{TFun} and \textsc{TFix}, the proof is straightforward since if the property holds for the expression in the premises it will also hold for the expression in the consequences.
        \item For the rule \textsc{TEq}, if the property holds for the type $\tau$, it will also hold for $\tau'$. Because it holds that the first is a subtype of the other, and vice versa, so the qualifiers of the two types are semantically equal, and denote the same set of expressions. Nothing is proved for the rule $\textsc{TSub}$ because it is not used in the assumptions of the theorem.
        \item For the rule \textsc{TApp}, if the qualifiers in the type of $a$ and $v_2$ match without using the rule \textsc{TSub}, the qualifier will represent all and only the values returned by $v_2$. Since we assume that the property is valid for the function type of $v_1$, substitution, for \emph{composition}, will allow the property to be unaltered for $\tau_x$. The last step is to assume that this also holds for $e$ and the type $\tau$, and under these conditions it will also hold. The same reasoning can be done for the rules \textsc{TAppOp}, \textsc{TAppFun} and \textsc{TLetE}.
        \item Let us therefore assume that the \textsc{TMerge} rule is cascaded over \textbf{all} the branches of a \verb|pattern-matching|, typed individually via the \textsc{TMatch} rule. The latter is the only rule for which the property will not apply. But it cannot be the first one to be applied because under the assumptions of the theorem it is not allowed; consequently, to type a \verb|pattern-matching| it will be necessary to start from the rule \textsc{TMerge}, and having to apply it on all the branches, the types $\tau_1$ and $\tau_2$ associated with each $e$ will not respect the property of covering all and only the values returned, but will cover the branches taken into consideration. Since the cascading rule must therefore be applied to all branches, the \verb|pattern-matching| will be typed with a Coverage Type whose qualifier will indicate \textbf{\emph{all and only}} the values it returns.
    \end{itemize}

    The proof for the typing of a function is similar, it is only necessary to first apply a series of \textsc{TFun} to populate the context with the parameters of the function ($\overline{\tau_i}$) and then proceed in an identical manner to the above with the body of the function.
\end{proof}

The next section will extend the type system of $\lambda^{\textbf{TG}}$ in order to:
\begin{enumerate}
    \item Add the \emph{History Expressions} to the type of each expression.
    \item Replace the Coverage Types with the \emph{Extended Coverage Types} so that the \textsc{TSub} rule can be used, but at the same time knowing the full set of values returned by an expression. This will allow for correct over-approximation when binding the type of a variable into an effect type (\emph{History Expressions}).
\end{enumerate}