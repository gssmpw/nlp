In this section, we introduce History Expressions and outline their semantics.

\begin{definition}[History Expression]
    A \textbf{\emph{History Expression}}, denoted $H$, is defined by the following grammar:
    \begin{equation}
        \begin{split}
            H, H' ::=& \;Val_H \;|\; Exp_H \;|\; H \cdot H' \;|\; H + H' \\
            Exp_{H} ::=& \;\alpha(\overline{b{:}\phi}) \;|\; F(\overline{a{:}(b{:}\phi})) \;|\; call(\phi; \;\overline{a{:}(b{:}\psi})) \;|\; \mu F(\overline{a{:}(b{:}\phi}))(H_F) \\
            Val_{H} ::=& \;\epsilon \;|\; \alpha(\overline{v}) \;|\; F(\overline{v}) \;|\; new_r(X) \;|\; get(F)
        \end{split}
        \label{eq:hist_gramm}
    \end{equation}
\end{definition}

The notation $\alpha(\overline{b{:}\phi})$ represents the application of the action named $\alpha$ on a resource, operating over a set of values with base type $b$, specifically those that satisfy the predicate $\phi$. A similar notation is used for the application of an external function named $F$. In this case, each parameter (represented by the base type-qualifier pair) is linked to the corresponding argument in the function signature.

We first comment on expressions. The expression $call$ represents the operation of invoking external functions. However, this expression supports a form of call by property, meaning that the function being called is one that satisfies the predicate $\phi$. Lastly, the $\mu$ notation denotes the declaration of a recursive function, with $H_F$ representing its latent effect.

We move move to values. Values consists of the following:
    \begin{itemize}
    \item The empty history $\epsilon$, indicating the occurrence of no relevant action;
    \item The application of an external function on a set of values; 
    \item The creation of a new resource of type $r$ with the identifier $X$ bound to it; 
    \item The value $get(F)$, which is a constant bound to the API described by the name $F$.
\end{itemize}

Intuitively, the inclusion of type qualifiers in actions and API calls allows for a more refined over-approximation. This topic will be explored further when we present the type system in Section \ref{sec:type_system}.

We can introduce the substitution operator $[\cdot/\cdot]$ on identifiers in History Expressions. This will be mainly useful in local \emph{non} recursive functions, as in these the creation of resources will be allowed, but when the latent effect of a function becomes active it will be necessary to change all the identifiers of the resources created within them, because if there were another call to that same function, the same identifiers would be reused!

\newpage

The substitution $[\cdot/\cdot]$ is then defined as follows:

\begin{equation}
    \begin{split}
        (H \cdot H')[Y/X] =&\; H[Y/X] \cdot H'[Y/X] \\
        (H + H')[Y/X] =&\; H[Y/X] + H'[Y/X] \\
        \alpha(\overline{b_i{:}\phi_i})[Y/X] = &\; \alpha(\overline{b_i{:}\phi_i[Y/X]}) \\
        call(\phi; \;\overline{a_i{:}(b_i{:}\psi_i)})[Y/X] = &\; call(\phi[Y/X]; \;\overline{a_i{:}(b_i{:}\psi_i[Y/X])}) \\
        (\mu F(\overline{a_i{:}({b_i{:}\phi_i})})(H_F) =& \;\mu(F[Y/X])(\overline{a_i{:}({b_i{:}\phi_i[Y/X]})})(H_F[Y/X]) \\
        F(\overline{a_i{:}(b_i{:}\phi_i}))[Y/X] =& \; F[Y/X](\overline{a_i{:}(b_i{:}\phi_i[Y/X]})) \\
        \epsilon[Y/X] =& \;\epsilon \\
        new_r(Z)[Y/X] = &\; new_r(Z[Y/X]) \\
        \alpha(\overline{v})[Y/X] =& \;\alpha(\overline{v[Y/X]}) \\
        F(\overline{v})[Y/X] =& \;F[Y/X](\overline{v[Y/X]}) \\
        get(F)[Y/X] =& \;get(F[Y/X])
    \end{split}
    \label{eq:subst}
\end{equation}

The $\mu$ construct serves as a variable binder for recursive function identifiers, hence this requires defining the identity of History Expressions up-to alpha conversion.

\subsection{$\alpha$-conversion History Expression}\label{subsec:alpha}

We can define the following two rules for the $\alpha$-conversion of History Expressions:
\begin{enumerate}
    \item $H' \cdot \mu F(\overline{a{:}(b{:}\phi)})(H_F) \cdot H'' \;=_{\alpha}\; H' \cdot \mu G(\overline{a{:}(b{:}\phi)})(H_F[G/F]) \cdot H''[G/F]$ \\
    $\text{if} \quad H' \cdot \mu F(\overline{a{:}(b{:}\phi)})(H_F) \cdot H''$ is the longest History Expression containing $\mu F$ and \\
    $G \notin \textsc{Bound}(H') \cup \textsc{Bound}(H_F) \cup \textsc{Bound}(H'')$ where $\textsc{Bound}(H)$ represents all the identifiers used within $H$.
    \item $H' \cdot \mu F(\overline{a{:}(b{:}\phi)})(H_{rec}) \cdot H'' \cdot H''' \;=_{\alpha}\;  H' \cdot H'' \cdot \mu F(\overline{a{:}(b{:}\phi)})(H_{rec}) \cdot H'''$ \\
    $\text{if} \quad \forall \;call(\psi; \;\overline{c{:}(b{:}\theta)}) \in H'', \; \neg \psi[v \mapsto F] \;\land\; \forall\; G(\overline{d{:}(b{:}{\sigma})}) \in H'', \; G \neq F$
\end{enumerate}

Rule (1) allows the identifier of a recursive function to be changed if it has not been used globally in the history in which it is contained.
Rule (2), on the other hand, permits a recursive function declaration to be shifted to the right, provided that the subsequent history ($H''$) contains no API type calls to the function.

\subsection{Equality Relation}
We introduce an equational theory of History Expressions. The equality relation $=$ over History Expressions is the least congruence including $\alpha$-conversion such that:

\begin{figure}[ht]
    \begin{equation*}
        \begin{gathered}
            \epsilon \cdot H = H = H \cdot \epsilon \quad \quad H = H + H \quad \quad H + H' = H' + H \\
            H \cdot (H' \cdot H'') = (H \cdot H') \cdot H'' \quad \quad H + (H' + H'') = (H + H') + H'' \\
            H \cdot (H' + H'') = (H \cdot H') + (H \cdot H'') \quad \quad (H' + H'') \cdot H = (H' \cdot H) + (H'' \cdot H)
        \end{gathered}
    \end{equation*}
    \caption{Equality Axioms of History Expressions}
    \label{fig:hist_eq}
\end{figure}

\subsection{Denotation}

We now focus on the denotation of History Expressions. We start by noting that the management of resource creations within recursive functions and APIs will not be taken into account in the definition of denotation. These constraints will be introduced in Section \ref{sec:type_system}, where the type system is presented, but we will discuss the motivations at the end of this paragraph.

We first introduce an auxiliary function that allows a variable to be bound within the qualifiers of the history. The function, \bind, is inductively defined on the structure of $H$, and its definition is shown in Figure \ref{eq:bind}.

With $\Phi(\tau_x)$ we indicate that only the qualifier of the passed type is taken. In the definition of this function, we note that the discourse about type independence made earlier applies: when we bind a variable in the history, we do not care if the type associated with it is an under- or over-approximation, but only the qualifier is taken into account.

\begin{figure}[H]
    \begin{equation*}
        \begin{split}
            \bind(x{:}\tau_x, \;H \cdot H') =& \; \bind(x{:}\tau_x, \;H) \cdot \bind(x{:}\tau_x, \;H') \\
            \bind(x{:}\tau_x, \;H + H') =& \; \bind(x{:}\tau_x, \;H) + \bind(x{:}\tau_x, \;H') \\
            \bind(x{:}\tau_x, \;\alpha(\overline{b_i{:}\phi_i})) =& \; \alpha(\overline{b_i{:}\exists x. \Phi(\tau_x)[v \mapsto x] \;\land\; \phi_i}) \\
            \bind(x{:}\tau_x, \;call(\phi; \;\overline{a_i{:}(b_i{:}\psi_i}))) =& \; call(\exists x. \Phi(\tau_x) \;\land\; \\
            & \phi; \;\overline{a_i{:}(b_i{:}\exists x. \Phi(\tau_x)[v \mapsto x] \;\land\; \psi_i})) \\
            \bind(x{:}\tau_x, \;\mu F(\overline{a_i{:}({b_i{:}\phi_i})})(H_F)) =& \;\mu F(\overline{a_i{:}({b_i{:}\exists x. \Phi(\tau_x)[v \mapsto x] \;\land\; \phi_i})}) \\
            & (\bind(x{:}\tau_x, \;H_F)) \\
            \bind(x{:}\tau_x, \;F(\overline{a_i{:}(b_i{:}\phi_i)})) =& \;F(\overline{a_i{:}(b_i{:}\exists x.\phi_i)}) \\
            \bind(x{:}\tau_x, \;\epsilon) =& \;\epsilon \\
            \bind(x{:}\tau_x, \;new_r(X)) =& \; new_r(X) \\
            \bind(x{:}\tau_x, \;\alpha(\overline{v})) =& \;\alpha(\overline{v}) \\
            \bind(x{:}\tau_x, \;F(\overline{v_i})) =& \;F(\overline{v_i}) \\
            \bind(x{:}\tau_x, \;get(F)) =& \;get(F)
        \end{split}
        \end{equation*}
    \caption{Definition of function \bind\ which aims to bind a variable within the qualifiers in the history.}
    \label{eq:bind}
\end{figure}

Furthermore, it is possible to execute the \bind\ function on several types by introducing the following equality:

\begin{equation}
    \bind(x_1{:}\tau_1, \dots, x_n{:}\tau_n, \;H) \doteq \bind(x_1{:}\tau_1, \dots, x_{n-1}{:}\tau_{n-1}, \;\bind(x_n{:}\tau_n, \;H))
\end{equation}

Below we are going to present a number of definitions and notations that will be much used throughout the presentation of the paper.

\begin{notation}[$Rid$]
    With the set $Rid$, we are going to denote the set of all possible resource identifiers, both local and remote.
\end{notation}

\begin{definition}[Resource Context]
    The \emph{resource context} is defined as follows:
    \begin{equation*}
        \Delta \subset Rid \cup (Rid \mapsto \tau)
    \end{equation*}
    This set will play two roles:
    \begin{enumerate*}[label=(\roman*)]
        \item makes it possible to keep track of resource identifiers already in use, that is, those that are already associated with resources that have already been created, so that when a new resource is created (through the \verb|new|), it has a new identifier;
        \item the second function is to contain the association between the resource identifiers used to represent the API, and the signature, that is, the $\tau$ type of the external function.
    \end{enumerate*}
    Obviously, in normal contexts, at first $\Delta$ is populated only by the mapping $Rid \mapsto \tau$ for each API that will be available within the program.
\end{definition}

\begin{notation}[$\eta$]
    With the symbol $\eta$, we shall indicate a history that is no longer reducible, which can only be composed of concatenations of the values $Val_H$ presented in \ref{eq:hist_gramm}.
\end{notation}

\begin{notation}[$\uparrow$]
    The notation $\uparrow$, associated with a History Expression $H$, allows each $new_r(X)$ present in $H$ to be assigned the symbol $\uparrow$: this is necessary because when calculating the denotation of $H$ we will have to take into account, in a set, the identifiers of the resources on which the \verb|new| was actually called, and since this in our language is a terminal value, we use this special symbol to indicate that we must first add the identifier to the set and then stop with the reduction.
    For example, if $H$ were equal to:
    \begin{equation}
        (new_r(X) + new_r(Y)) \cdot \alpha(r: v = X \;\lor\; v = Y)
    \end{equation}
    Applying $\uparrow$ to $H$ would return:
    \begin{equation}
        (new_r(X)^{\uparrow} + new_r(Y)^{\uparrow}) \cdot \alpha(r: v = X \;\lor\; v = Y)
    \end{equation}
    In this way, having to choose between the creation of $X$ and that of $Y$, assuming we choose the former, the identifier $X$ will be inserted in our set, and then during the reduction of the expression $\alpha$ we will know that only $X$ and not $Y$ will have to be taken into account, thus generating only the value $\alpha(X)$.

    The symbol $\uparrow$ is also associated with any expression indicating a call of an external function, of the form $F(\overline{a_i{:}(b_i{:}\phi_i}))$: in this case, however, the semantics of the symbol will indicate that the latent effect of $F$ has not yet been inserted into the main history. 
    
    The application of the $\uparrow$ symbol does not take place within the effects of the recursive functions linked to the $\mu$ construct: $\uparrow$ will be applied each time the effect becomes active.
\end{notation}

\begin{definition}[History Expression's Denotation without a Context]\label{def:history_den}
    The denotation $\llbracket \cdot \rrbracket$ of an \emph{History Expression} $H$, in a context of resources $\Delta$, is the set of all histories $\eta$ such that $H^{\uparrow}$ is reduced (in one or more steps) to $\eta$, and $\eta$ is terminal, i.e. it is no longer reducible.
    \begin{equation}
        \llbracket H \rrbracket = \{ \eta \;|\; (\varnothing, \;\varnothing, \;H^{\uparrow}) \rightarrow^* (\Omega, \;\Upsilon, \;\eta) \;\land\; (\Omega, \;\Upsilon, \;\eta) \nrightarrow \}
    \end{equation}
\end{definition}

We note how the reduction consists of a triple of the form:
\begin{equation}
    (\Omega, \;\Upsilon, \;H)
\end{equation}
Where $\Omega$ will denote the set in which the identifiers of the resources actually created during the calculation of a single history $\eta$ will be held. While with $\Upsilon$ we shall denote a list of substitutions specified by the notation $\{\cdot/\cdot\}$ that concern only the identifiers of external functions that actually represent recursive functions. This list will be the construct that will allow true recursion, as it will allow each identifier representing a recursive call to be substituted for the behaviour of the recursive function itself.

The relation $\rightarrow$ for $H$ is defined in Figure \ref{fig:denot_history}. Rule No. 6 makes it possible to add to the set $\Omega$ the identifier of a resource that has just been created and which may be used in actions following its creation. The two rules below constraint that in a concatenation, the whole of the term on the left must first be reduced and then the term on the right. This is necessary because histories have a property of temporal ordering between actions and, referring back to the previous rule concerning the \verb|new|, in order to be able to use a resource it will be necessary for it to have first been created and then added to the $\Omega$ set.

\begin{figure}[H]
    \begin{equation*}
        \begin{gathered}
            (\Omega, \;\Upsilon, \;\epsilon) \nrightarrow \quad \quad 
            (\Omega, \;\Upsilon, \;\alpha(\overline{v})) \nrightarrow \quad \quad
            (\Omega, \;\Upsilon, \;get(F)) \nrightarrow \quad \quad
            (\Omega, \;\Upsilon, \;F(\overline{v})) \nrightarrow \\ \\
            (\Omega, \;\Upsilon, \;new_r(X)) \nrightarrow \quad \quad
            \frac{
                (\Omega, \;\Upsilon, \;\eta) \nrightarrow \quad (\Omega, \;\Upsilon, \;\eta') \nrightarrow
            }{
                (\Omega, \;\Upsilon, \;\eta \cdot \eta') \nrightarrow
            } \\ \\
            (\Omega, \;\Upsilon, \;new_r(X)^{\uparrow}) \rightarrow (\Omega \cup \{X\}, \;\Upsilon, \;new_r(X)) \\ \\
            \frac{
                (\Omega, \;\Upsilon, \;H) \rightarrow (\Omega', \;\Upsilon', \;H'')
            }{
                (\Omega, \;\Upsilon, \;H \cdot H') \rightarrow (\Omega', \;\Upsilon', \;H'' \cdot H')
            } \quad \quad
            \frac{
                (\Omega, \;\Upsilon, \;\eta) \nrightarrow \quad (\Omega, \;\Upsilon, \;H) \rightarrow (\Omega', \;\Upsilon', \;H')
            }{
                (\Omega, \;\Upsilon, \;\eta \cdot H) \rightarrow (\Omega', \;\Upsilon', \;\eta \cdot H')
            } \\ \\
            (\Omega, \;\Upsilon, \;H + H') \rightarrow (\Omega, \;\Upsilon, \;H) \quad \quad
            (\Omega, \;\Upsilon, \;H + H') \rightarrow (\Omega, \;\Upsilon, \;H') \\ \\
            \frac{
                \begin{gathered}
                    \forall i, Val_i = \{u: b_i \;|\; \phi_i[v \mapsto u] \;\land\; (u \in Rid \Longrightarrow u \in \Omega \;\lor\; \Delta(u)\downarrow)\} \\
                    H = \begin{cases}
                        \underset{\overline{u} \in \underset{i}{\prod} Val_i}{\bigoplus} \alpha(\overline{u}) & \text{if}\;\forall i, Val_i \neq \varnothing \\
                        \epsilon & \text{otherwise}
                    \end{cases}
                \end{gathered}
            }{
                (\Omega, \;\Upsilon, \;\alpha(\overline{b_i{:}\phi_i})) \rightarrow (\Omega, \;\Upsilon, \;H)
            } \\ \\
            \frac{
                Api = \{ F \;|\; \phi[v \mapsto F] \;\land\; \Delta(F)\downarrow \} \quad H = \begin{cases}
                    (\underset{F \in Api}{\bigoplus} F(\overline{a_i{:}(b_i{:}\psi_i}))^{\uparrow}) & \text{if}\;Api \neq \varnothing \\
                    \epsilon & \text{otherwise}
                \end{cases}
            }{
                (\Omega, \;\Upsilon, \;call(\phi; \;\overline{a_i{:}(b_i{:}\psi_i))}) \rightarrow (\Omega, \;\Upsilon, \;H)
            } \\ \\
            \frac{
                \Delta(F) = \overline{\tau} \rightarrow (\tau_F, \; H_F) \quad H_F^{\star} = \bind(\overline{a_i: \under{v: b_i \;|\; \psi_i}}, \;H_F)
            }{
                (\Omega, \;\Upsilon, \;F(\overline{a_i{:}(b_i{:}\psi_i}))^{\uparrow}) \rightarrow (\Omega, \;\Upsilon, \;(F\Upsilon)(\overline{a_i{:}(b_i{:}\psi_i})) \cdot {H_F^{\star}}^{\uparrow})
            } \\ \\
            \frac{
                \begin{gathered}
                    \forall i, Val_i = \{u: b_i \;|\; \phi_i[v \mapsto u] \;\land\; (u \in Rid \Longrightarrow u \in \Omega \;\lor\; \Delta(u)\downarrow)\} \\
                    H = \begin{cases}
                        \underset{\overline{u} \in \underset{i}{\prod} Val_i}{\bigoplus} \alpha(\overline{u}) & \text{if}\;\forall i, Val_i \neq \varnothing \\
                        \epsilon & \text{otherwise}
                    \end{cases}             
                \end{gathered}
            }{
                (\Omega, \;\Upsilon, \;F(\overline{a_i{:}(b_i{:}\phi_i)})) \rightarrow (\Omega, \;\Upsilon, \;H)
            } \\ \\
            (\Omega, \;\Upsilon, \;H(\overline{a_i{:}(b_i{:}\psi_i)}) \rightarrow (\Omega, \;\Upsilon, \;{\bind(\overline{a_i{:}(b_i{:}\psi_i)}, \;H)}^{\uparrow}) \\ \\
            (\Omega, \;\Upsilon, \;\mu F(\overline{a_i{:}({b_i{:}\phi_i})})(H_F)) \rightarrow (\Omega, \;\Upsilon\{H_F/F\}, \;\epsilon)
        \end{gathered}
    \end{equation*}
    \caption{Reduction Relation for History Expressions}
    \label{fig:denot_history}
\end{figure}

After the two rules for nondeterministic choice, we present the reduction rule for invoking an action on \textbf{all} those values satisfying each predicate $\phi_i$. We note how not only are put into a set, for each argument $i$ of the action, all those values of type $b_i$ that satisfy $\phi_i$; but in the case where the value under consideration is an identifier of a resource - and thus $b_i$ will be a resource type - this either must be present in $\Omega$ - it was created by means of a \verb|new| - or in the case where the identifier represents an external function, this must be defined in $\Delta$. Finally, if each parameter $i$ has associated at least one value on which to perform the action (so each $Val_i$ is different from the empty set), we create a vector $\overline{u}$ for each possible combination between the values of each parameter $i$ and place them in nondeterministic choice. Otherwise, if there is at least one parameter that does not have any of the admissible values associated with it, it means that the action within the programme can never occur (this is guaranteed by the type qualifiers, which represent a correct over-approximation for each parameter). The same mechanism was used for APIs call reduction as can be seen in rule No. 15.

The next rule allows the calls of a set of external functions invoked on the same parameters to be unpacked into as many non-deterministic choices as possible. The APIs taken into consideration, in addition to having to satisfy the predicate $\phi$, must also be defined in the context of the resources $\Delta$.

Below, we find the rule that allows the latent effect of an external function to be active: the effect is then taken from $\Delta$ and all the parameters passed to the call are bound to it. In the case where the identifier $F$ is in fact associated with a recursive function, one (and only one) of the substitutions in $\Gamma$ will be successful (and as we will see in the type system rules in Section \ref{sec:type_system} the latent effect associated with a recursive function in $\Delta$ will be $\epsilon$).

The last two rules handle recursion. The term to be reduced in the first of the two is a direct consequence of the reduction of external functions with no active latent effect: thus $H$ will be the latent effect of a recursive function, inserted thanks to one of the reductions in $\Gamma$, and will be consequently bound to the parameters on which the recursive function was called. The last rule simply adds the substitution between the latent effect and the identifier of the recursive function declared through the $\mu$ construct to the $\Gamma$ list.

\begin{definition}[History Expression's Denotation under a Context]
    The denotation of a history $H$, taking into account already having a context $\Gamma$ to bind the non-quantified variables in the action qualifiers, is inductively defined on $\Gamma$ as follows:
    \begin{equation}
        \begin{gathered}
            {\llbracket H \rrbracket}_{\varnothing} = \llbracket H \rrbracket \\
            {\llbracket H \rrbracket}_{x: \tau_x,\Gamma} = {\llbracket \bind(H, \;x{:}\tau_x) \rrbracket}_{\Gamma}
        \end{gathered}
    \end{equation}
\end{definition}

That is, for the empty context, the denotation is the same as the context-free one defined above since the variables will all be bound; whereas, for the inductive step, if the context consists of an association $x:\tau_x$ and another set of associations contained in $\Gamma$, we evaluate the denotation in $\Gamma$, but of the history in which all the qualifiers in the actions are bound existentially to a variable $x$ of type $\tau_x$.

\begin{theorem}[Correctness of Denotation to Type Qualifiers]
    Given a History Expression $H$ and an interpretation $\mathcal{I}$ that maps each qualifier in $H$ with the value assigned by the interpretation itself, it holds that:
    \begin{equation}
        \forall \eta, \;\Gamma, \;H. \;\eta \in \llbracket H \rrbracket_{\Gamma} \Longrightarrow \exists \mathcal{I}. \;\mathcal{I} \models \Phi(H) \;\land\; \eta \in \llbracket H(\mathcal{I}) \rrbracket_{\Gamma}
    \end{equation}
    This property tells us that for each terminal history $\eta$ that belongs to a History Expression $H$, there exists at least one interpretation $\mathcal{I}$ that satisfies the qualifiers taken into account by $H$ such that, by applying the substitution within $H$, $\eta$ belongs to the denotation of $H$ with inside instead of type qualifiers the values, surely correct since they belong to a valid interpretation. Consequently, the values in $\eta$ will also be correct with respect to the type qualifiers as this belongs to a denotation (the second) which will not use the reduction rules on the calculation of values, this because there are directly within $H$. 
    
    \paragraph{Interpretation} Since the qualifiers have no variable name or explicit identifier associated with them, we will use a number as an identifier in the definition of the interpretations, which will represent the index of the position of the qualifier itself within the History Expression with respect to the others, starting from left to right.
    
    Applying an interpretation $\mathcal{I} = \{\overline{i = v_i}\}$ to a History Expression $H$ replaces each qualifier indexed by $i$ with the expression $v = v_i$. This actually contradicts what was said earlier about the rules on calculating qualifiers not being used, because in the end $v = v_i$ is still a qualifier. In fact in reality these rules will be used, but the type qualifier becomes trivial, the only value that satisfies $v = v_i$ is $v_i$ itself!
    
    Finally, it should be pointed out that the only qualifiers that will not require mapping are those encapsulated within the $\mu$ recursion construct, since as already mentioned this is not used for the semantic purposes of History Expressions, but only to verify well-formedness in the type system rules as we shall see later.
\end{theorem}

\begin{proof}
    Having used inference rules for the definition of denotation, the demonstration can proceed by induction:
    \begin{itemize}
        \item For the first five rules, the demonstration is immediate as we are already operating on values that are not altered. For the next rule (concatenation of two terminal histories) the same.
        \item The event of creation of a resource is not of interest to us, as it does not encapsulate any type qualifiers, but directly presents a value (the identifier of the new resource) that is preserved in the reduction, and is added to the set $\Omega$. This last piece of information is important for some of the following points.
        \item For the following two concatenation rules we simply use the inductive hypothesis on the reduction of the History Expressions $H$ into $H''$ and $H'$ respectively, since they are in the premises. We conclude by stating that the property on the qualifiers is respected.
        \item On the other hand, for non-deterministic choice rules, here we are simply dropping a history so within the chosen interpretation $\mathcal{I}$ for the qualifiers in it can be assigned any value, still respecting the type qualifier, but independent of the terminal history $\eta$.
        \item Let us move on to the first notable rule, which concerns the reduction of the action $\alpha$. We must first differentiate between the case in which the type of values is a resource and the case in which it is not. In the latter case, what we compute in the premises is precisely the set of \textbf{all} values satisfying each predicate, and then we place \textbf{any} of these values (actually a vector of values in the case where the action has more than one parameter, but the transition to this case is w.l.g.) in non-deterministic choice. Proceeding in the reduction we will then have to choose only one of these values $v_i$ (because of the rules on the operator $+$) and this will belong to the terminal history $\eta$ (encapsulated in the event $\alpha$). Within the interpretation $\mathcal{I}$ we can then choose as the value for the qualifier at the position of $\alpha$ just $v_i$ since it satisfies it. For resource types, when we go to compute the set of values, we simply add another condition to the qualifier $\phi$ (which allows us to have identifiers that actually exist or APIs that have been defined), only restricting the starting set.

        In the case where the value generated is $\epsilon$, it will mean that there will be at least one qualifier that represents a contradiction, so there can be no value that satisfies it: as the value for the interpretation $\mathcal{I}$ we will choose the special symbol $\bot$, which in the semantics of the interpretation allows us to skip checking the qualifier in question.
        
        \paragraph{Note} In practice, when we will integrate History Expressions with the Coverage Types type system, the variables can never have a type with a contradictory qualifier associated with them, as this would lead to a context not being in good form \cite{coverage}. On the merits, such a qualifier (e.g. trivially $v = 1 \;\land\; v = 2$) is possible to find during the typing phase (just think of the function application of a parameter that does not respect the type of the argument), but since it will represent the presence of a type-matching error, it will lead to an error by failing to infer a type. \\

        It is worth noting, as this last discussion makes us reflect on why in the theorem the implication does not also hold the other way around, i.e. that for every valid interpretation there is a terminal history that belongs to the denotation: this is not possible with resource types in mind, in fact one could take in $\mathcal{I}$ identifiers that satisfy the type qualifier, but which have not been defined or created.
        \item For the remaining rules using qualifiers, such as the one on the single API call, the demonstration is identical, as the premises are the same. For the multiple call of APIs the calculation is also similar, as done above we restrict the set of values that satisfy the qualifier, in this case with those that also represent defined APIs. Basically, as a value for each qualifier in $\mathcal{I}$ we always take the one chosen during the reduction.
        \item Finally, for the last three rules that do not perform calculations on the qualifiers, we note how these, regardless of the operations they perform, which are irrelevant for the choice of values in $\mathcal{I}$, always leave the type qualifiers unchanged by only dragging them into other constructs or sets, such as $\Omega$ for recursion, or by binding them into other histories through \bind.
    \end{itemize}
\end{proof}

\begin{note}[Creation of resources in recursive functions and APIs]
    As previously announced, there will be constraints on the latent effects of APIs and recursive functions for which the creation of any type of resource within them will not be permitted. This implementation choice was made for two reasons:
    \begin{enumerate}[label=(\roman*)]
        \item The former is mainly related to recursive functions, and the reason for this is that unfolding a recursive function that at each iteration \emph{could} create new resources is dangerous: we do not know how many times the recursive call could be invoked, statically the number of invocations is potentially infinite! Despite the fact that in the type system of $\lambda^{\textbf{TG}}$ there is a control on recursion that imposes a decreasing ordering relation between the first parameter of the current function and the one present in each recursive call \cite{coverage}, however, the resources we have at our disposal are always limited in quantity, so even if the recursive function after $n$ calls terminates, this $n$ could be sufficiently large to create, for example, a disproportionate number of files, or network connections, realising, deliberately or otherwise, a \emph{DOS} \cite{dos} attack. The same goes for APIs: due to the principle of compositionality, an API could call other APIs within it, perhaps using recursive functions, and encounter the same problem.
        Let us imagine that we have the following recursive History Expression $H$ associated with any function\footnote{In our type system this syntax is \textbf{illegal} both because in Section \ref{sec:type_system} we will see that a recursive function with this history cannot be typed, and also because if we were to calculate the denotation of this history this \textbf{not} would be a correct over-approximation of the function.}:
        \begin{equation}
            H \equiv \mu F(n{:}(v > 0))(new_{file}(X) \cdot F(n{:}(v = n - 1)))
        \end{equation}
        Although, as already mentioned, the rules guarantee that the recursion is finite - in fact $n$ descends by $1$ at each iteration and when it is less than or equal to $0$ the recursion stops - from the point of view of resources and their limited availability this represents a problem. Consider a potential call of $F$ with $n$ equal to $10,000$: although this is feasible, it would lead to the creation of $10,000$ files, which could cause problems on the memory device!
        \item The second reason, is related to a \emph{ROP} (Return Oriented Programming) \cite{rop} attack, which a potential attacker could carry out on our code. Should this be able to find an entry point in the program to inject and execute malicious code, such as through \emph{buffer overflow} \cite{buffer}, by checking the stack it can manage and change the address of the return function, subsequently creating a fairly long chain of function calls, in which for instance it always returns to the same function, which may be the one that creates one or more resources. In spite of this, in order not to limit the expressiveness of the language too much, we will still allow the creation of resources within local non-recursive functions, while for recursive functions, or for API calls, instead of creating them directly within them, it will be possible to use the \verb|new| before their invocation and pass the desired resources as parameters.
    \end{enumerate}
\end{note}

\begin{proof}[Correctness of $\alpha$-conversion rules] After having introduced the denotation of History Expressions, we can demonstrate the two rules concerning $\alpha$-conversion presented above:
    \begin{itemize}
        \item For rule (1), it is necessary to make the assumption that the identifiers associated with the recursive functions \textbf{not} can be used explicitly within programmes, but must only be used by the compiler. This constraint will actually be present in our language and will be formally defined in the well-formedness rules of the type system in Section \ref{sec:type_system}. Thus, it is not possible for these identifiers to be present within type qualifiers, except in the qualifier of the expression $call$ and consequently also as an identifier in the single API call $F(\overline{a_i{:}(b_i{:}\phi_i)})$.
        The first part of the History Expression, $H'$, is identical. The second part, the recursive construct, although the identifier is changed from $F$ to $G$, this will be reduced to $\epsilon$. But there is the side effect that adds the substitution $\{H_F/F\}$ to the list $\Omega$. So according to the denotation in Figure \ref{fig:denot_history}, if $F$ in $H''$ is a recursive function, then the substitution in $\Omega$ will be applied by replacing the identifier $F$ with the History Expressions associated with the body of the recursive function, and in any terminal history $\eta$ it will not be possible to find any reference to $F$ in the values, due to the assumption made at the beginning. Consequently it is possible to change the identifier $F$ in all occurrences in $H''$ - and in the body of $H_F$ since it can become active in $H''$ through substitutions - to another $G$ such that it is globally fresh. For $H'$, however, if it is correct, there can be no reference to $F$.
        \item For rule (2), the demonstration is simple. Since the recursive construct is reduced to $\epsilon$, we will have that:
        \begin{equation}
            H' \cdot \epsilon \cdot H'' \cdot H''' = H' \cdot H'' \cdot \epsilon \cdot H'''
        \end{equation}
        According to the rules of equality in Figure \ref{fig:hist_eq}. The only denotation that might change, however, is only that of H‘’ since in its evaluation it will now no longer have in $\Omega$ the recursive function identified by $F$. But if there are no calls to $F$ in it, this substitution will never be used.
    \end{itemize}
\end{proof}

\section{Policies}\label{sec:policies}

In this section, we explore different approaches to defining policies and introduce two widely applicable relationships.

\begin{definition}[Ordering between events]
    The relation $<_{\eta}$ defines an ordering between two events in the terminal history $\eta$, The relation is defined as follows:
    \begin{equation}
        \alpha(X) <_{\eta} \beta(Y) \Longleftrightarrow \exists \; \eta_1, \eta_2, \eta_3. \; \eta = \eta_1 \cdot \alpha(X) \cdot \eta_2 \cdot \beta(Y) \cdot \eta_3
    \end{equation}
\end{definition}

\begin{definition}[Ownership of an event]
    The ownership relation of an event in a terminal history $\eta$ is defined by:

    \begin{equation}
        \alpha(X) \in \eta \Longleftrightarrow \exists \; \eta_1, \eta_2. \; \eta = \eta_1 \cdot \alpha(X) \cdot \eta_2
    \end{equation}
\end{definition}

\begin{example}
    For example, the policy, discussed at the beginning of the introduction on reading and writing files, is defined by making use of the relationships presented above:
    
    \begin{equation}
        \begin{gathered}
            \forall \; \eta \in \llbracket H \rrbracket .\; \forall \; read(X) \in \eta .\; \exists \; open(X) . \; open(X) <_{\eta} read(X) \;\land\; \\ 
            \nexists \; close(X) \in \eta .\; \; open(X) <_{\eta} close(X) <_{\eta} read(X)
        \end{gathered}
    \end{equation}

  One can use the same pattern to represent the same policy but on write operations (\verb|write|).
\end{example}