Some type system rules will be based on the relationships between type denotations. As we shall see later, although new types are used, these are simply extensions or compositions of others that already exist. That is, the type pairs is composed of an Extended Coverage Type, which in turn is based on Coverage Types. Our choice has been not to create new denotations for these types - this has only been done with History Expressions as already seen in Section \ref{sec:history} - but to use existing ones. The motivation for this choice is to be able to prove the correctness of the type system in a faster and simpler way, guaranteeing the preservation of the properties on the Coverage Types. Therefore, since denotations on Coverage Types are based on a context of only function types with no history and traditional Coverage Types \cite{coverage}, we will make use of two definitions that allow us to transform the context:

\begin{definition}[Context Changes $\phi$]
    \begin{equation}
        \begin{gathered}
            (x{:}\tau_x, \;\Gamma)_{\phi} \equiv x{:}(\tau_x)_{\phi}, \;\Gamma_{\phi} \\
            (\tau, \;H)_{\phi} \equiv \tau_{\phi} \\
            \under{v: b \;|\; \phi \;|\; \psi}_{\phi} \equiv \under{v: b \;|\; \phi} \\
            \overa{v: b \;|\; \phi}_{\phi} \equiv \overa{v: b \;|\; \phi} \\
            (\overa{v: b \;|\; \phi} \rightarrow \kappa)_{\phi} \equiv \overa{v: b \;|\; \phi} \rightarrow (\kappa_{\phi}) \\
            ((a{:}\tau_a \rightarrow \kappa_b) \rightarrow \kappa)_{\phi} \equiv (a{:}(\tau_a)_{\phi} \rightarrow (\kappa_b)_{\phi}) \rightarrow \kappa_{\phi} \\
        \end{gathered}
    \end{equation}
\end{definition}

With these two definitions, we can modify the reference context by adapting it to the definitions of the denotations on the original Coverage Types, working either on the first qualifiers of the Extended Coverage Types ($\phi$), or on the second ones ($\psi$), as required.

\begin{definition}[Context Changes $\psi$]
    \begin{equation}
        \begin{gathered}
            (x{:}\tau_x, \;\Gamma)_{\psi} \equiv x{:}(\tau_x)_{\psi}, \;\Gamma_{\psi} \\
            (\tau, \;H)_{\psi} \equiv \tau_{\psi} \\
            \under{v: b \;|\; \phi \;|\; \psi}_{\psi} \equiv \under{v: b \;|\; \psi} \\
            \overa{v: b \;|\; \phi}_{\psi} \equiv \overa{v: b \;|\; \phi} \\
            (\overa{v: b \;|\; \phi} \rightarrow \kappa)_{\psi} \equiv \overa{v: b \;|\; \phi} \rightarrow (\kappa_{\psi}) \\
            ((a{:}\tau_a \rightarrow \kappa_b) \rightarrow \kappa)_{\psi} \equiv (a{:}(\tau_a)_{\psi} \rightarrow (\kappa_b)_{\psi}) \rightarrow \kappa_{\psi} \\
        \end{gathered}
    \end{equation}
\end{definition}

\subsection{Auxiliary Rules}

In Figure \ref{fig:well-form} we find the extended rules of well-formedness. Two rules have been added: the \textsc{WfHistory} that separately checks the property for the return type and the behaviour type; and the \textsc{WfHistExp} that checks for a History Expression that the qualifiers in each of its component expressions are bound formulae in the context $\Gamma$. For recursive function declarations, the property is checked recursively on the extended context with the parameters defined in the $\mu$ construct.

Furthermore, for the well-formedness of $H$, we require that each identifier of a recursive function be used only in the History Expression representing its body and here only for recursive calls (via $F$ or $call$). In fact $F$ is not really an API! Additionally, it is required as already explained that no new resources are created in the recursive functions.

A further check is made on the APIs defined in $\Delta$ which also must not contain the creation of resources within them.

The rule \textsc{WfBase}, for Extended Coverage Types only adds the closed formula constraint for the second predicate $\psi$.

Here we note the reason why the list of arguments with associated full type (base type and qualifier) was also presented in the definition of recursive functions in History Expressions: as we have seen in the calculation of denotation in Figure \ref{fig:denot_history}, this information is useless, but it is necessary, in the rules just discussed, to verify the well-formedness relationship (\textbf{WF}).

Figure \ref{fig:subtyping} shows the extensions for the rules concerning the verification of subtyping relations. The rule \textsc{SubUBase} is the only one worthy of comment: we keep the denotations for the traditional Coverage Types, and thus verify as in the original rule that the denotation of the type with qualifier $\phi_1$ is subtyped by that with qualifier $\phi_2$. We verify the same relation on the histories $H_1$ and $H_2$. Instead, the denotations on the Coverage Types constructed on $\psi_1$ and $\psi_2$ we want to be equal, i.e. semantically $\psi_1$ is equal to $\psi_2$. This intuitively reflects the role of this added qualifier, which represents all the values actually returned by an expression: we can neither add new ones as we would be inserting guarantees that are not respected, nor can we remove them as we would lose useful values for the correct over-approximation of the histories.

Finally, in Figure \ref{fig:disjunction}, we find the rules useful for joining types belonging to several branches of the same \verb|pattern-matching|. We note that compared to the original disjunction rule \cite{coverage}, here we did not have to use the denotations of the Coverage Types for the function types and preferred, as with the subtyping rules, to proceed structurally on the individual types that make up the function. This choice is constrained by the fact that a function may have as an argument another function that therefore has a latent effect. Separating in this case the History Expressions from the various return types becomes more difficult. Here, however, we have also changed the rules for Coverage Types, as we have to prove that the rules in Figure \ref{fig:disjunction} are correct.

\begin{figure}[H]
    \textbf{Well-Formedness}
    
    \begin{equation}
        \frac{
            \Gamma \vdash^{\textbf{WF}} \tau \quad \Gamma \vdash^{\textbf{WF}} H
        }{
            \Gamma \vdash^{\textbf{WF}} (\tau, \; H)
        }
        \tag{\textsc{WfHistory}}
        \label{eq:wfhistory}
    \end{equation}
    
    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \equiv \overline{x_i:\overa{v: b_{x_i} \;|\; \phi_{x_i}}, y_j:\under{v: b_{y_j} \;|\; \phi_{y_j} \;|\; \psi_{y_j}}, z:(a:\tau_a \rightarrow \tau_b)} \\
                \forall \; \alpha(\overline{r_k{:}\phi_k}) \in H, \; \forall k, \;(\overline{\;\exists x_i:b_{x_i}, \exists y_j : b_{y_j}}, \exists v : r_k, \phi_k) \; \text{is a Boolean predicate} \\
                \forall \; call(\phi; \;\overline{a_h{:}(b_h{:}\psi_h)}) \in H, \;(\overline{\;\exists x_i:b_{x_i}, \exists y_j : b_{y_j}}, \exists v : api, \phi) \;\text{is a Boolean predicate} \;\land \\
                \land\; \forall h, (\overline{\;\exists x_i:b_{x_i}, \exists y_j : b_{y_j}}, \exists v : b_h, \psi_h) \;\text{is a Boolean predicate} \\
                \forall \; F(\overline{a_m{:}(b_m{:}\sigma_m)}) \in H, \; \forall m, (\overline{\;\exists x_i:b_{x_i}, \exists y_j : b_{y_j}}, \exists v : b_m, \sigma_m) \;\text{is a Boolean predicate} \\
                \forall \;\mu F(\overline{a_l{:}({b_l{:}\theta_l})})(H_F) \in H, \; \Gamma, \overline{a_l: \overa{v: b_l \;|\; \theta_l}} \vdash^{\textbf{WF}} H_F \;\land \\
                \land\; \forall \;G(\overline{a{:}(b{:}\phi)}) \in H, \;G = F \;\Longrightarrow\; G(\overline{a{:}(b{:}\phi)}) \in H_F \;\land \\ \land\; \forall \;call(\phi; \;\overline{a{:}(b{:}\psi)}) \in H, \;\phi[v \mapsto F] \;\Longrightarrow\; call(\phi; \;\overline{a{:}(b{:}\psi)}) \in H_F \;\land \\
                \land\; \forall \;Val_H \in H_F. \;\forall r. \;\forall \;X \in Rid. \;\neg(Val_H = \texttt{\small{new}}_r(X)) \;\land\; \forall \;\alpha(\overline{r{:}\theta}) \in H, \;\forall \;\theta, \;\neg(\theta[v \mapsto F]) \\
                \forall \;(F, \;\overline{\tau} \rightarrow (\tau_F, \;H_F)) \in \Delta, \;\forall \;Val_H \in H_F, \;\forall r. \;\forall \;X \in Rid, \;\neg(Val_H = \texttt{\small{new}}_r(X)) \\
            \end{gathered} 
        }{
            \Gamma \vdash^{\textbf{WF}} H
        }
        \tag{\textsc{WfHistExp}}
        \label{eq:wfhexp}
    \end{equation}
    
    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \equiv \overline{x_i:\overa{v: b_{x_i} \;|\; \phi_{x_i}}, y_j:\under{v: b_{y_j} \;|\; \phi_{y_j} \;|\; \psi_{y_j}}, z:(a:\tau_a \rightarrow \tau_b)} \\
                (\overline{\forall x_i: b_{x_i}, \exists y_j: b_{y_j}}, \forall v: b, \phi) \; \text{is a Boolean predicate} \quad \forall j, \text{err} \notin \llbracket \under{v: b_{y_j} \;|\; \phi_{y_j}} \rrbracket_{\Gamma_{\phi}} \\
                (\overline{\forall x_i: b_{x_i}, \exists y_j: b_{y_j}}, \forall v: b, \psi) \; \text{is a Boolean predicate}
            \end{gathered}
        }{
            \Gamma \vdash^{\textbf{WF}} \under{v: b \;|\; \phi \;|\; \psi}
        }
        \tag{\textsc{WfBase}}
        \label{eq:wfbase}
    \end{equation}
    \begin{multicols}{2}
        \raggedcolumns
        \begin{equation}
            \frac{
                \Gamma, x:\overa{v: b \;|\; \phi} \vdash^{\textbf{WF}} \kappa
            }{
                \Gamma \vdash^{\textbf{WF}} x:\overa{v: b \;|\; \phi} \rightarrow \kappa
            }
            \tag{\textsc{WfArg}}
            \label{eq:wfarg}
        \end{equation}
    
        \columnbreak
    
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (a: \tau_a \rightarrow \kappa_b) \quad \Gamma \vdash^{\textbf{WF}} \kappa
            }{
                \Gamma \vdash^{\textbf{WF}} (a: \tau_a \rightarrow \kappa_b) \rightarrow \kappa
            }
            \tag{\textsc{WfRes}}
            \label{eq:wfres}
        \end{equation}
    \end{multicols}
    \caption{Extension of the auxiliary rules of Well-Formedness.}
    \label{fig:well-form}
\end{figure}

\begin{figure}[H]
    \textbf{Subtyping}
    
    \begin{equation}
        \frac{
            \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} \quad \llbracket H_1 \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket H_2 \rrbracket_{\Gamma_{\psi}} \quad \llbracket \under{v: b \;|\; \psi_1}\rrbracket_{\Gamma_{\psi}} = \llbracket \under{v: b \;|\; \psi_2} \rrbracket_{\Gamma_{\psi}}
        }{
            \Gamma \vdash (\under{v: b \;|\; \phi_1 \;|\; \psi_1}, \; H_1) <: (\under{v: b \;|\; \phi_2 \;|\; \psi_2}, \; H_2)
        }
        \tag{\textsc{SubUBase}}
        \label{eq:subu}
    \end{equation}

    \begin{equation}
        \frac{
            \llbracket \overa{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \overa{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}}
        }{
            \Gamma \vdash \overa{v: b \;|\; \phi_1} <: \overa{v: b \;|\; \phi_2}
        }
        \tag{\textsc{SubOBase}}
        \label{eq:subo}
    \end{equation}

    \begin{equation}
        \frac{
            \Gamma \vdash \tau_{21} <: \tau_{11} \quad \Gamma, x: \tau_{21} \vdash \kappa_{12} <: \kappa_{22}
        }{
            \Gamma \vdash x: \tau_{11} \rightarrow \kappa_{12} <: x:\tau_{21} \rightarrow \kappa_{22}
        }
        \tag{\textsc{SubArr}}
        \label{eq:subarr}
    \end{equation}
    \caption{Extension of the auxiliary rules of subtyping.}
    \label{fig:subtyping}
\end{figure}

\begin{figure}[h]
    \textbf{Disjunction}
    
    \begin{equation}
        \frac{
            \begin{gathered}
                \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \cap \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} = \llbracket \under{v: b \;|\; \phi_3} \rrbracket_{\Gamma_{\phi}} \\
                \llbracket \under{v: b \;|\; \psi_1} \rrbracket_{\Gamma_{\psi}} \cap \llbracket \under{v: b \;|\; \psi_2} \rrbracket_{\Gamma_{\psi}} = \llbracket \under{v: b \;|\; \psi_3} \rrbracket_{\Gamma_{\psi}}
            \end{gathered}
        }{
            \Gamma \vdash \under{v: b \;|\; \phi_1 \;|\; \psi_1} \;\lor\; \under{v: b \;|\; \phi_2 \;|\; \psi_2} = \under{v: b \;|\; \phi_3 \;|\; \psi_3}
        }
        \tag{\textsc{Disjunction Under}}
    \end{equation}

    \begin{equation}
        \frac{
            \llbracket \overa{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \cup \llbracket \overa{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} = \llbracket \overa{v: b \;|\; \phi_3} \rrbracket_{\Gamma_{\phi}}
        }{
            \Gamma \vdash \overa{v: b \;|\; \phi_1} \;\lor\; \overa{v: b \;|\; \phi_2} = \overa{v: b \;|\; \phi_3}
        }
        \tag{\textsc{Disjunction Over}}
    \end{equation}

    \begin{equation}
        \frac{
            \llbracket H_1 \rrbracket_{\Gamma_{\psi}} \cup \llbracket H_2 \rrbracket_{\Gamma_{\psi}} = \llbracket H_3 \rrbracket_{\Gamma_{\psi}}
        }{
            \Gamma \vdash H_1 \;\lor\; H_2 = H_3
        }
        \tag{\textsc{Disjunction History}}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash \tau_1 \;\lor\; \tau_2 = \tau_3 \quad \Gamma \vdash H_1 \;\lor\; H_2 = H_3
            \end{gathered}
        }{
            \Gamma \vdash (\tau_1, \;H_1) \;\lor\; (\tau_2, \;H_2) = (\tau_3, \;H_3)
        }
        \tag{\textsc{Disjunction Pair}}
    \end{equation}

    \begin{equation}
        \frac{
            \Gamma \vdash \tau_{a_1} \;\land\; \tau_{a_2} = \tau_{a_3} \quad \Gamma, a{:}\tau_{a_3} \vdash \kappa_1 \;\lor\; \kappa_2 = \kappa_3
        }{
            \Gamma \vdash a{:}\tau_{a_1} \rightarrow \kappa_1 \;\lor\; a{:}\tau_{a_2} \rightarrow \kappa_2 = a{:}\tau_{a_3} \rightarrow \kappa_3
        }
        \tag{\textsc{Disjunction Arrow}}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \cup \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} = \llbracket \under{v: b \;|\; \phi_3} \rrbracket_{\Gamma_{\phi}} \\
                \llbracket \under{v: b \;|\; \psi_1} \rrbracket_{\Gamma_{\psi}} \cup \llbracket \under{v: b \;|\; \psi_2} \rrbracket_{\Gamma_{\psi}} = \llbracket \under{v: b \;|\; \psi_3} \rrbracket_{\Gamma_{\psi}}
            \end{gathered}
        }{
            \Gamma \vdash \under{v: b \;|\; \phi_1 \;|\; \psi_1} \;\land\; \under{v: b \;|\; \phi_2 \;|\; \psi_2} = \under{v: b \;|\; \phi_3 \;|\; \psi_3}
        }
        \tag{\textsc{Conjunction Under}}
    \end{equation}

    \begin{equation}
        \frac{
            \llbracket \overa{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \cap \llbracket \overa{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} = \llbracket \overa{v: b \;|\; \phi_3} \rrbracket_{\Gamma_{\phi}}
        }{
            \Gamma \vdash \overa{v: b \;|\; \phi_1} \;\land\; \overa{v: b \;|\; \phi_2} = \overa{v: b \;|\; \phi_3}
        }
        \tag{\textsc{Conjunction Over}}
    \end{equation}

    \begin{equation}
        \frac{
            \llbracket H_1 \rrbracket_{\Gamma_{\psi}} \cap \llbracket H_2 \rrbracket_{\Gamma_{\psi}} = \llbracket H_3 \rrbracket_{\Gamma_{\psi}}
        }{
            \Gamma \vdash H_1 \;\land\; H_2 = H_3
        }
        \tag{\textsc{Conjunction History}}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash \tau_1 \;\land\; \tau_2 = \tau_3 \quad \Gamma \vdash H_1 \;\land\; H_2 = H_3
            \end{gathered}
        }{
            \Gamma \vdash (\tau_1, \;H_1) \;\land\; (\tau_2, \;H_2) = (\tau_3, \;H_3)
        }
        \tag{\textsc{Conjunction Pair}}
    \end{equation}

    \begin{equation}
        \frac{
            \Gamma \vdash \tau_{a_1} \;\lor\; \tau_{a_2} = \tau_{a_3} \quad \Gamma, a{:}\tau_{a_3} \vdash \kappa_1 \;\land\; \kappa_2 = \kappa_3
        }{
            \Gamma \vdash a{:}\tau_{a_1} \rightarrow \kappa_1 \;\land\; a{:}\tau_{a_2} \rightarrow \kappa_2 = a{:}\tau_{a_3} \rightarrow \kappa_3
        }
        \tag{\textsc{Conjunction Arrow}}
    \end{equation}
    \caption{Extension of auxiliary disjunction rules.}
    \label{fig:disjunction}
\end{figure}

\begin{comment}
    \begin{equation}
        \frac{
            \Gamma \vdash \tau_1 \;\lor\; \tau_2 = \tau_{12} \quad \Gamma \vdash \tau_{12} \;\lor\; \tau_3 \;\lor\; \dots \;\lor\; \tau_n = \tau
        }{
            \Gamma \vdash \tau_1 \;\lor\; \tau_2 \;\lor\; \tau_3 \;\lor\; \dots \;\lor\; \tau_n = \tau
        }
        \tag{\textsc{Multi-Disjunction}}
        \label{eq:multidisj}
    \end{equation}
\end{comment}

\begin{proof}[Correctness of Disjunction Rules for Coverage Types]
    The correctness of the procedure of unpacking the function and finding a disjunct (or conjunct) type for each individual type refinement and then recomposing the function structurally is actually already demonstrated in the original work when discussing the algorithmic procedures \textsc{\textcolor{blue}{Disj}} and \textsc{\textcolor{blue}{Conj}} \cite{coverage}. Here, however, we do not want to proceed in an algorithmic way (exploiting properties on qualifiers) and so we still rely on denotations showing that the procedure is the same. What we do know is that, for example given two Coverage Types $\under{v: b \;|\; \phi_1}$ and $\under{v: b \;|\; \phi_2}$, and a type context $\Gamma$, the following relationships apply:
    
    \begin{equation}
        \begin{gathered}
            \Gamma \vdash \under{v: b \;|\; \phi_1 \;\lor\; \phi_2} <: \under{v: b \;|\; \phi_1} \\
            \Gamma \vdash \under{v: b \;|\; \phi_1 \;\lor\; \phi_2} <: \under{v: b \;|\; \phi_2}
        \end{gathered}
    \end{equation}

    Thus, by definition of the subtyping relationship, it holds that:
    \begin{equation}
        \begin{gathered}
            \llbracket \under{v: b \;|\; \phi_1 \;\lor\; \phi_2} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \\
            \llbracket \under{v: b \;|\; \phi_1 \;\lor\; \phi_2} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}}
        \end{gathered}
    \end{equation}

    These two relationships lead to the statement that:
    
    \begin{equation}
         \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \cap \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_1 \;\lor\; \phi_2} \rrbracket_{\Gamma_{\phi}}
    \end{equation}

    But we know that $\under{v: b \;|\; \phi_1 \;\lor\; \phi_2}$ is the disjoint type of the two sets, which leads us to state that its denotation corresponds exactly to the intersection of the two sets:

    \begin{equation}
        \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \cap \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} = \llbracket \under{v: b \;|\; \phi_1 \;\lor\; \phi_2} \rrbracket_{\Gamma_{\phi}}
    \end{equation}

    A dual demonstration can be performed on the conjunction of two Coverage Types leading to the following relations:

    \begin{equation}
        \begin{gathered}
            \Gamma \vdash \under{v: b \;|\; \phi_2} <: \under{v: b \;|\; \phi_1 \;\land\; \phi_2} \quad \quad \Gamma \vdash \under{v: b \;|\; \phi_1} <: \under{v: b \;|\; \phi_1 \;\land\; \phi_2} \\
            \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_1 \;\land\; \phi_2} \rrbracket_{\Gamma_{\phi}} \quad \quad \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_1 \;\land\; \phi_2} \rrbracket_{\Gamma_{\phi}} \\
            \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \cup \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} = \llbracket \under{v: b \;|\; \phi_1 \;\land\; \phi_2} \rrbracket_{\Gamma_{\phi}}
        \end{gathered}
    \end{equation}

    We can also verify that these relations also apply to over-approximation types.

    During this demonstration, we have also shown implicitly that when checking the disjunction of a function the addition of the conjoined type of the preceding parameters to the context is correct, since in the subtyping rules this is done, but it is these that lead us to the intersection (or union) of the denotations of the disjoined (or conjoined) types! And these denotations are precisely computed under the same $\Gamma$ context where the conjoined (or disjoint) type will be found.

    In conclusion, we can say that the entire new set of disjunction rules is correct since we have shown that:
    \begin{enumerate*}[label=(\roman*)]
        \item structural separation of types is correct; 
        \item the assumptions concerning the intersection and union of the denotations for disjunction and conjunction (used for function parameters that are in contravariance to the main operator) respectively are correct; 
        \item finally, the evaluation of the denotations of the individual function types in the extended contexts with the previously disjointed (or conjoined) type is also correct.
    \end{enumerate*}
\end{proof}

\subsection{Type System}

Now, in Figures \ref{fig:type-system-1} and \ref{fig:type-system-2} we present the type system rules of the extended $\lambda^{\textbf{TG}}$ language for resource usage. We will show only a few selected ones, however most of them, the most noteworthy. However, it is possible to find the remaining set of rules in Appendix \ref{app:type-system}.

The special expression \verb|err| denoting divergent computations can be typed only with the contradictory qualifier $\bot$ (which is also the qualifier representing the exact values of the expression), while the effect produced is the special action $err()$.

As demonstrated in the Lemma \ref{lemma:ty} the $Ty$ function indicates not only the values it will surely return, but also specifies all of them, so to align with the syntax of Extended Coverage Types we need only replicate the qualifier a second time. The effect produced by just invoking a constant (\textsc{TConst}) or an action (\textsc{TAction}), without applying it, is null. The same is also true for variables. In the rule \textsc{TVarBase} the tautological qualifier $v = x$ is also used for the second qualifier: $x$ will be present in $\Gamma$ with an Extended Coverage Types associated with it, so the first and second $v = x$ will refer to the first and second qualifiers present in the type of $x$ in $\Gamma$, respectively.

For the rules \textsc{TSub} and \textsc{TEq} the only change is the use of the pair type $\pi$ instead of a traditional Coverage Type.

Even the mere declaration of a function is typed with the empty history (\textsc{TFun}). However, we introduce a new rule called \textsc{TFunFlat} that allows us to eliminate empty effects associated with parameters when a function has at least two. For example, it will be possible to change the type of a function declaration from (using only the rule \textsc{TFun}):
\begin{equation}
    (a{:}\tau_a \rightarrow (b{:}\tau_b \rightarrow (c{:}\tau_c \rightarrow (\tau, \;H), \;\epsilon), \;\epsilon), \;\epsilon)
\end{equation}
To one that eliminates all associated empty effects from the second to the last parameter:
\begin{equation}
    (a{:}\tau_a \rightarrow b{:}\tau_b \rightarrow c{:}\tau_c \rightarrow (\tau, \;H), \;\epsilon)
\end{equation}

The \textsc{TMatch} rule now prohibits being able to tip only one branch (or at any rate a smaller number than the total number of branches) of a \verb|pattern-matching|. We are obliged to make this change otherwise the property of representing \emph{all and only} the values returned by the expression in the second qualifier of an Extended Coverage Type would not be respected.
We note how the return type of each $v_i$ and $d_i(\overline{y})$ can be different (because of the $\psi$ qualifier of Extended Coverage Types), but we introduce the notation $\langle \cdot \rangle$ to transform Extended Coverage Types into traditional Coverage Types.

Despite this change, it is still possible to drop branches of a \verb|pattern-matching| by applying the \textsc{TSub} rule after the \textsc{TMatch} rule. In this way we retain the properties of the old type system but we are also able to identify in the second type qualifier \emph{all and only} the values returned to construct a proper over-approximation of the effects.

The rule for defining recursive functions is one that has been changed the most. In this case, in order to implement recursion also at the level of the History Expressions, we treat the function as an API: in this way the API calls (which will represent the recursive calls) will be present in the History associated with the recursive construct $\mu$, and as seen in the definition of denotations (Figure \ref{fig:denot_history}) this strategy allows us to implement a form of recursion. The History of the function associated with the identifier $F$ in $\Delta$ will be $\epsilon$ as it is not to be used in the calculation of the denotation of History Expressions. This is the only case in which the definition of a function will generate an active History, which is precisely the recursive construct $\mu$!

\begin{figure}[H]
    \begin{multicols}{2}
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\under{v: b \;|\; \bot \;|\; \bot}, \; err())
            }{
                \Gamma \vdash err : (\under{v: b \;|\; \bot \;|\; \bot}, \; err())
            }
            \tag{\textsc{TErr}}
            \label{eq:terr}
        \end{equation}
        
        \columnbreak
    
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\text{Ty}(c), \; \epsilon)
            }{
                \Gamma \vdash c : (\text{Ty}(c), \; \epsilon)
            }
            \tag{\textsc{TConst}}
            \label{eq:tconst}
        \end{equation}
    \end{multicols}

    \begin{multicols}{2}
        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\text{Ty}(\alpha), \; \epsilon)
            }{
                \Gamma \vdash \alpha : (\text{Ty}(\alpha), \; \epsilon)
            }
            \tag{\textsc{TAction}}
            \label{eq:taction}
        \end{equation}

        \columnbreak

        \begin{equation}
            \frac{
                \Gamma \vdash^{\textbf{WF}} (\under{v: b \;|\; v = x \;|\; v = x}, \; \epsilon)
            }{
                \Gamma \vdash x : (\under{v: b \;|\; v = x \;|\; v = x}, \; \epsilon)
            }
            \tag{\textsc{TVarBase}}
            \label{eq:tvarb}
        \end{equation}
    \end{multicols}

    \begin{multicols}{2}
        \noindent
        \begin{equation}
            \frac{
                \Gamma(x) = (a: \tau_a \rightarrow \kappa) \quad \Gamma \vdash^{\textbf{WF}} (a:\tau_a \rightarrow \kappa, \; \epsilon)
            }{
                \Gamma \vdash x : (a:\tau_a \rightarrow \kappa, \; \epsilon)
            }
            \tag{\textsc{TVarFun}}
            \label{eq:tvarf}
        \end{equation}
        \columnbreak
        \begin{equation}
            \frac{
                \varnothing \vdash \pi <: \pi' \quad \varnothing \vdash e : \pi \quad \Gamma \vdash^{\textbf{WF}} \pi'
            }{
                \Gamma \vdash e : \pi'
            }
            \tag{\textsc{TSub}}
            \label{eq:tsub}
        \end{equation}
    \end{multicols}

    \begin{multicols}{2}
        \begin{equation}
            \frac{
                \begin{gathered}
                    \Gamma \vdash \pi' <: \pi \quad \Gamma \vdash \pi <: \pi' \\
                    \Gamma \vdash e: \pi \quad \Gamma \vdash^{\textbf{WF}} \pi'
                \end{gathered}
            }{
                \Gamma \vdash e: \pi'
            }
            \tag{\textsc{TEq}}
            \label{eq:teq}
        \end{equation}

        \columnbreak

        \begin{equation}
            \frac{
                \Gamma, x: \tau_x \vdash e: \pi \quad \Gamma \vdash^{\textbf{WF}} (x: \tau_x \rightarrow \pi, \; \epsilon)
            }{
                \Gamma \vdash \lambda x : \lfloor\tau_x\rfloor. e : (x: \tau_x \rightarrow \pi, \; \epsilon)
            }
            \tag{\textsc{TFun}}
            \label{eq:tfun}
        \end{equation}
    \end{multicols}

    \begin{equation}
        \frac{
            \Gamma, x: \tau_x \vdash e: (y: \tau_y \rightarrow \kappa, \; \epsilon) \quad \Gamma \vdash^{\textbf{WF}} (x: \tau_x \rightarrow y: \tau_y \rightarrow \kappa, \; \epsilon)
        }{
            \Gamma \vdash \lambda x : \lfloor\tau_x\rfloor. e : (x: \tau_x \rightarrow y: \tau_y \rightarrow \kappa, \; \epsilon)
        }
        \tag{\textsc{TFunFlat}}
        \label{eq:tflat}
    \end{equation}    

    \begin{equation}
        \frac{
            \begin{gathered}
                \forall i, \;\Gamma \vdash v: (\tau_{v_i}, \; H_{v_i}) \quad \Gamma, \overline{y: \tau_y} \vdash d_i(\overline{y}) : (\tau_{d_i}, \;H_{y_i}) \quad \langle \tau_{v_i} \rangle = \langle \tau_{d_i} \rangle \quad \Gamma, \overline{y: \tau_y} \vdash e_i: (\tau_i, \;H_{e_i}) \\
                \tau = \underset{i}{\bigvee} \tau_i \quad H = \underset{i}{\bigvee} (H_{v_i} \cdot H_{y_i} \cdot H_{e_i}) \quad \Gamma \vdash^{\textbf{WF}} (\tau, \;H)   
            \end{gathered}
        }{
            \Gamma \vdash (\texttt{match}\;v\;\texttt{with}\;\overline{d_i\overline{y_j} \rightarrow e_i}): (\tau, \;H)
        }
        \tag{\textsc{TMatch}}
        \label{eq:tmatch}
    \end{equation}

    \begin{equation}
        \frac{
            \Gamma \vdash e : (\tau_1, \; H_1) \quad \Gamma \vdash e : (\tau_2, \; H_2) \quad \Gamma \vdash \tau_1 \;\lor\; \tau_2 = \tau \quad \Gamma \vdash H_1 \;\lor\; H_2 = H \quad \Gamma \vdash^{\textbf{WF}} (\tau, \; H)
        }{
            \Gamma \vdash e : (\tau, \; H)
        }
        \tag{\textsc{TMerge}}
        \label{eq:tmerge}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \nextd(\Delta, \;x{:}\overa{v: b \;|\; v \prec x \;\land\; \phi} \rightarrow \overline{\tau_i} \rightarrow (\tau, \;\epsilon)) = F \\
                \Gamma, x{:}\overa{v: b \;|\; \phi}, f{:}\under{v: api \;|\; v = F \;|\; v = F} \vdash e : \overline{\tau_i} \rightarrow (\tau, \;H) \\
                A = \{x{:}(b{:}\phi)\} \cup \{a_i{:}(b_i{:}\psi_i) \;|\; \tau_i = a_i{:}\overa{v: b_i \;|\; \psi_i}\} \quad \Gamma \vdash^{\textbf{WF}} (x{:}\overa{v: b \;|\; \phi} \rightarrow \overline{\tau_i} \rightarrow (\tau, \;H), \;\mu F(A)(H))
            \end{gathered}
        }{
            \Gamma \vdash \text{fix}\;f{:}(b \rightarrow \lfloor\kappa\rfloor).\lambda x{:}b.\;e : (x{:}\overa{v: b \;|\; \phi} \rightarrow \overline{\tau_i} \rightarrow (\tau, \;H), \;\mu F(A)(H))
        }
        \tag{\textsc{TFix}}
        \label{eq:tfix}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \neg(\kappa_x = \pi)
                \quad \Gamma \vdash v_1: (a{:}\overa{v: b \;|\; \phi} \rightarrow \kappa_x, \; H_{v_1}) \quad \Gamma \vdash v_2: (\under{v: b \;|\; \phi \;|\; \psi}, \; H_{v_2}) \\
                \Gamma, x : \kappa_x[a \mapsto v_2] \vdash e: (\tau, \; H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau, \; H_{v_1} \cdot H_{v_2} \cdot H_e) \\
            \end{gathered}
        }{
            \Gamma \vdash \;\texttt{let}\; x = v_1 \; v_2 \;\texttt{in}\; e: (\tau, \; H_{v_1} \cdot H_{v_2} \cdot H_e)
        }
        \tag{\textsc{TAppMulti}}
        \label{eq:tappmulti}
    \end{equation}
    \caption{Selected type system rules - Part I.}
    \label{fig:type-system-1}
\end{figure}

\begin{figure}[h]
    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash v_1: (a{:}\overa{v: b \;|\; \phi} \rightarrow (\tau_{v_1}, \;H_{\tau_{v_1}}), \; H_{v_1}) \quad \Gamma \vdash v_2: (\under{v: b \;|\; \phi \;|\; \psi}, \; H_{v_2}) \\
                \Theta = \{[Y/X] \;|\; new(X) \in H_{\tau_{v_1}} \;\land\; \nextd(\Delta) = Y\} \quad H_{\tau_{v_1}}^{\star} = H_{\tau_{v_1}}(\Theta)[a \mapsto v_2] \\
                \Gamma, x : \tau_{v_1}(\Theta)[a \mapsto v_2] \vdash e: (\tau, \; H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau, \; H_{v_1} \cdot H_{v_2} \cdot H_{\tau_{v_1}}^{\star} \cdot H_e)
            \end{gathered}
        }{
            \Gamma \vdash \;\texttt{let}\; x = v_1 \; v_2 \;\texttt{in}\; e: (\tau, \; H_{v_1} \cdot H_{v_2} \cdot H_{\tau_{v_1}}^{\star} \cdot H_e)
        }
        \tag{\textsc{TAppLast}}
        \label{eq:tapplast}
    \end{equation}

    \begin{equation}
        \frac{
            \Gamma, x: \under{v: r \;|\; v = X \;|\; v = X} \vdash e : (\tau, \; H_e) \quad \nextd(\Delta) = X \quad \Gamma \vdash^{\textbf{WF}} (\tau, \; \texttt{\small{new}}_r(X) \cdot H_e)
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = \texttt{\small{new}}_r\;()\;\texttt{\small{in}}\;e : (\tau, \;\texttt{\small{new}}_r(X) \cdot H_e)
        }
        \tag{\textsc{TNew}}
        \label{eq:tnew}
    \end{equation}

    \begin{equation}
        \frac{
            \Gamma, x : \under{v: api \;|\; v = F \;|\; v = F} \vdash e : (\tau, \; H_e) \quad \Delta(F) = \tau_{F} \quad \Gamma \vdash^{\textbf{WF}} (\tau, \; \texttt{\small{get}}(F) \cdot H_e)
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = \texttt{\small{get}}\;F\;\texttt{\small{in}}\;e : (\tau, \; \texttt{\small{get}}(F) \cdot H_e)
        }
        \tag{\textsc{TGet}}
        \label{eq:tgetapi}
    \end{equation}

    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash \alpha: (\overline{a_i{:}\overa{v: b_i \;|\; \phi_i}} \rightarrow \tau_x, \;H_{\alpha}) \quad \forall i, \; \Gamma \vdash u_i : (\under{v: b_i \;|\; \phi_i \;|\; \psi_i}, \; H_{u_i}) \\
                \Gamma, x{:}\tau_x[\overline{a_i \mapsto u_i}] \vdash e : (\tau, \; H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau, \;H_\alpha \cdot ( \underset{i}{\bullet} \; H_{u_i} ) \cdot \alpha(\overline{b_i{:}\psi_i}) \cdot H_e)
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = \alpha \; \overline{u_i}\;\texttt{\small{in}}\;e : (\tau, \; H_\alpha \cdot ( \underset{i}{\bullet} \; H_{u_i} ) \cdot \alpha(\overline{b_i{:}\psi_i}) \cdot H_e)
        }
        \tag{\textsc{TLetAction}}
        \label{eq:tletaction}
    \end{equation}
    
    \begin{equation}
        \frac{
            \begin{gathered}
                \Gamma \vdash f: \under{v: api \;|\; \phi \;|\; \psi} \quad \forall i, \; \Gamma \vdash y_i: (\under{v: b_i \;|\; \phi_i \;|\; \psi_i}, \; H_{y_i}) \\ \varnothing \vdash^{\textbf{WF}} \under{v: api \;|\; \phi \;|\; \psi} \quad Api = \{F \;|\; \phi[v \mapsto F] \;\land\; \Delta(F)\downarrow\} \\
                \forall F \in Api, \; \Delta(F) = \tau_F \;\land\; \Gamma, f'{:}\tau_F \vdash f': \overline{a_i{:}\overa{v: b_i \;|\; \phi_i}} \rightarrow (\tau_{F_x}, \; H_{F_x}) \;\land\; \\
                \Gamma \vdash \underset{F \in Api}{\bigvee} \tau_{F_x} = \tau_x \quad \Gamma, x{:}\tau_x\overline{[a_i \mapsto y_i]} \vdash e : (\tau, \; H_e) \quad \Gamma \vdash^{\textbf{WF}} (\tau, \; ( \underset{i}{\bullet} \; H_{y_i} ) \cdot call(\psi; \;\overline{a_i{:}(b_i{:}\psi_i}) \cdot H_e)
            \end{gathered}
        }{
            \Gamma \vdash \texttt{\small{let}}\;x = f\;\overline{y_i}\; \texttt{\small{in}}\;e : (\tau, \; ( \underset{i}{\bullet} \; H_{y_i} ) \cdot call(\psi; \;\overline{a_i{:}(b_i{:}\psi_i})) \cdot H_e)
        }
        \tag{\textsc{TAppAPI}}
        \label{eq:tappapi}
    \end{equation}
    \caption{Selected type system rules - Part II.}
    \label{fig:type-system-2}
\end{figure}

The rule \textsc{TMerge} also performs the disjunction between the two histories assignable to the expression. To emphasize the difference between over-approximated and under-approximated types, it is worth noting how, despite taking the disjunction of both the return type and the behaviour type, the relationship between the new type found via disjunction and the two types that are part of it is reversed: as seen in the auxiliary rules for disjunction, in Coverage Types we take the intersection of the denotations between the two types, because the type found is a subtype of them; while in History Expressions we take the union of the denotations, finding instead a supertype of the two.

The rule previously called \textsc{TApp}, for applying functions, has been split into two separate rules: \textsc{TAppMulti} and \textsc{TAppLast}, the former is used when the function represented by $v_1$ has more than one argument, and the latter when $v_1$ has exactly one argument. This choice is due to having to distinguish the moment when the last argument of a function is applied to a parameter, and thus the latent effect of the function can become active.

In the rule \textsc{TAppMulti} we specify in the premises that the return type of the function, $\kappa_x$ must be different from any pair type $\pi$, and so there will be at least one other parameter of the function. In the rule \textsc{TAppLast}, on the other hand, we require that immediately after the parameter $a$ there must be a pair type; in this case, we will have to make the latent effect $H_{\tau_{v_1}}$ active, i.e., include it in the type of the behaviour of the final expression. To do this, we must first address a problem: this concerns the creation of resources within the latent effects; in fact, if the function were applied a second time, and resources were created within it, the second application would use the same identifiers as the first, but this is wrong! So, we will first need to find all the identifiers that belong to a $new_r$ inside the latent effect, then we go on to create replacements for each of these identifiers, taking new ones.

Here, a new function called \nextd $\space$ comes into play, which takes care of taking the next free identifier according to any ordering of the set of identifiers: on the merits, the set $Rid$ of resources is a finite set (in fact in concrete the resources are always in finite quantity) so it is possible to put it in bi-univocal correspondence with the set of natural numbers $\mathbb{N}$ and therefore it is possible to define on the identifiers an ordering by indexing them. It is good to note, how the ordering that is taken does not matter to us, in fact we can think of the \nextd $\space$ as a function that finds an ordering of the identifiers (a permutation of them) such that if in $\Delta$ there are $n$ identifiers, these are the first $n$ in the ordering and $Y$ is the $n + 1$-th.

Once computed in the set $\Theta$, these substitutions will be applied to both the return type $\tau_{v_1}$ and the latent effect itself, in addition to the traditional substitution of the argument $a$ with the passed parameter $v_2$. 

The \textsc{TNew} rule allows a new resource to be created and associated with a variable. Here too, the procedure \nextd $\space$ is used to ensure that the next free identifier in $\Delta$ is precisely $X$. A Coverage Type with base type $r$ and exactly the same value as $X$ will be associated with $x$.

The \textsc{TGet} rule, on the other hand, allows an external function to be associated with a variable, in which case the identifier associated with the API must have already been defined in $\Delta$ by the programmer himself (intuitively, this is a correct choice since it is he himself who imports the external libraries).

The rule \textsc{TAction} allows the application of an operator involving resources. In fact, the rule is very similar to the \textsc{TOp} found in Appendix \ref{app:type-system}, the only difference being that in this case the event indicating the presence of the action $\alpha$ is also added to the active effect. We note that while the set of qualifiers $\phi_i$ is the one used to match the type of the parameters passed with those of the action arguments; the qualifiers $\psi_i$ are those encapsulated in the event present in the history.

The rule \textsc{TAppApi}, for the application of an external function, requires that the variable $f$ be of base type $api$, and that the Extended Coverage Type associated with it be closed with respect to the empty context; this allows us to be able to compute all the identifiers that satisfy the condition $\phi$, finding the APIs that will definitely be applied. For each of these, we take the associated type from the resource context $\Delta$, associate it with a ghost variable $f'$, and check whether it is possible to type the arguments of this API with the same type as the parameters passed $y_i$. Finally we perform the disjunction on the various return types of each API in the set $API$, and in the active effect to be associated with the expression an event of type $call$ should be added in which we encapsulate the qualifier of all APIs that will be executed ($\psi$) and also those associated with the parameters ($\psi_i$).

The inclusion of type qualifiers in actions and API calls enables a more refined over-approximation. This is because, when inferring the latent effect of functions, if a resource (or value) used in actions (or API calls) is part of the function's arguments, we can use a smaller set of values than those defined in the function's type during its application. This results in a more precise approximation of the function's behaviour (remember how in Coverage Types the type of function arguments is an over-approximation type and in the subtype relation the notion of contravariance on the type of function arguments applies \cite{coverage}). This is the same reason why the syntax for $call$ was also introduced and not just the syntax for the single application of $API$ is used.

\subsection{Operational Semantic}

In Figure \ref{fig:semantic-op} we find the small-step rules of the operation semantics. These do not require comment as they are very self-explanatory. The only notable rule is the \textsc{StAppApi} where an oracle $\tilde{O}$ is used to predict the value returned by an external function, since we do not know the body of the function but only its signature.

\begin{figure}[H]
    \begin{equation}
        \frac{
            op \; \overline{v} \equiv v_y
        }{
            (\texttt{let}\;y = op\;\overline{v}\;\texttt{in}\;e, \; H) \hookrightarrow (e[y \mapsto v_y], \; H \cdot \epsilon)
        }
        \tag{\textsc{StAppOp}}
        \label{eq:stappop}
    \end{equation}
    
    \begin{equation}
        \frac{
            (e_1, \;\epsilon) \hookrightarrow (e_1', \;H_{e_1'})
        }{
            (\texttt{let}\;y = e_1\;\texttt{in}\;e_2, \; H) \hookrightarrow (\texttt{let}\;y = e_1'\;\texttt{in}\;e_2, \; H \cdot H_{e_1}')
        }
        \tag{\textsc{StLetE1}}
        \label{eq:stlete1}
    \end{equation}
    
    \begin{equation}
        \frac{
            \space
        }{
            (\texttt{let}\;y = v\;\texttt{in}\;e, \; H) \hookrightarrow (e[y \mapsto v], \; H \cdot \epsilon)
        }
        \tag{\textsc{StLetE2}}
        \label{eq:stlete2}
    \end{equation}
    
    \begin{equation}
        \frac{
            \space
        }{
            (\texttt{let}\;y = \lambda x{:}t.e_1 \; v_x \;\texttt{in}\; e_2, \; H) \hookrightarrow (\texttt{let}\;y = e_1[x \mapsto v_x]\;\texttt{in}\; e_2, \; H \cdot \epsilon)
        }
        \tag{\textsc{StLetAppLam}}
        \label{eq:stletapplam}
    \end{equation}
    
    \begin{equation}
        \frac{
            \space
        }{
            \begin{gathered}
                (\texttt{let}\;y = \;\texttt{fix}\;f{:}t.\lambda x{:}t_x.e_1 \; v_x \;\texttt{in}\; e_2, \;H) \hookrightarrow \\
                (\texttt{let}\;y = (\lambda f{:}t.e_1[x \mapsto v_x])\;(\texttt{fix}\;f{:}t.\lambda x{:}t_x.e_1) \;\texttt{in}\;e_2, \;H \cdot \epsilon)
            \end{gathered}
        }
        \tag{\textsc{StLetAppFix}}
        \label{eq:stletappfix}
    \end{equation}

    \begin{equation}
        \frac{
            \space
        }{
            (\texttt{match}\;d_i\;\overline{v_j}\;\texttt{with}\;\overline{d_i\;\overline{y_j} \rightarrow e_i}, \; H) \hookrightarrow (e_i[\overline{y_j \mapsto v_j}], \;H \cdot \epsilon)
        }
        \tag{\textsc{StMatch}}
        \label{eq:stmatch}
    \end{equation}

    \begin{equation}
        \frac{
            \alpha \; \overline{v} \equiv v_y
        }{
            (\texttt{let}\;y = \alpha\;\overline{v}\;\texttt{in}\;e, \; H) \hookrightarrow (e[y \mapsto v_y], \; H \cdot \alpha(\overline{v}))
        }
        \tag{\textsc{StAppAction}}
        \label{eq:stappaction}
    \end{equation}

    \begin{equation}
        \frac{
            \nextd(\Delta) = X
        }{
            (\texttt{let}\;y = new_r ()\;\texttt{in}\;e, \; H) \hookrightarrow (e[y \mapsto X], \; H \cdot new_r(X))
        }
        \tag{\textsc{StNew}}
        \label{eq:stnew}
    \end{equation}

    \begin{equation}
        \frac{
            \Delta(F) = \tau_F
        }{
            (\texttt{let}\;y = \texttt{get}\;F\;\texttt{in}\;e, \; H) \hookrightarrow (e[y \mapsto F], \; H \cdot get(F))
        }
        \tag{\textsc{StGet}}
        \label{eq:stget}
    \end{equation}

    \begin{equation}
        \frac{
            \Delta(F) = \tau_F
        }{
            (\texttt{let}\;y = F\;\overline{v_i}\;\texttt{in}\;e, \; H) \hookrightarrow (e[y \mapsto \tilde{O}(F, \;\overline{v_i})], \; H \cdot F(\overline{v_i}))
        }
        \tag{\textsc{StAppApi}}
        \label{eq:stappapi}
    \end{equation}
    \caption{Semantics Operation of $\lambda^{\textbf{TG}}$ extended with History Expressions.}
    \label{fig:semantic-op}
\end{figure}

\subsection{A Case Study}

An example code generated by the language presented above is shown in Figure \ref{fig:exmp3}. Let us assume that we wish to construct a generator of all palindromic words of length less than $n$. Instead of implementing it from scratch, in our resource context we have an external API that generates all palindromes words exactly $n$ long, so we decided to implement our generator in terms of an existing one. Let us therefore assume that we have the following resource context (in reality $\Delta$ will also contain all the resources already present in the reference system, for simplicity and because it is of no interest to us we will not list them all):

\begin{equation}
    \begin{gathered}
        \Delta \equiv \{(F, \;n{:}\overa{v: nat \;|\; \top_{nat}} \rightarrow p{:}\overa{v: string \;|\; \top_{string}} \rightarrow \\
        (\under{v: string \;|\; len(v, \;n) \;\land\; is\_palindrome(v)}, \\
        open(string: v = p) \cdot write(string: v = p, \;string: len(v, \;n) \;\land\; is\_palindrome(v))))\}
    \end{gathered}
\end{equation}

For simplicity, we will assume that we also have polymorphic file primitives in our language $\lambda^{\textbf{TG}}$. In this case since the $F$ API works on file paths we will use primitives with the same name but which take as input a string instead of a resource identifier. This is intuitively correct since a path also uniquely identifies a file (or generally a resource).

Obviously in our language it is more advantageous to work with resource identifiers as we can know whether a resource is referable or not, but with paths this is not possible, we cannot know statically whether a path is correct or not, as our code could dynamically modify folders and files.

The problem, however, is that the API identified by $F$ also takes as a parameter a string representing the absolute path to a file where the function, in addition to returning the generated word, will also write it to this file.

\begin{wrapfigure}{l}{0.65\textwidth}
    \begin{lstlisting}
let palindromes_gen (n: nat) : string =
    let palindrom = ?\typeact{get}? F
    in
    let random = nat_gen ()
    in
    let l = random ?\typeact{mod}? n
    in
    palindrom l "/home/angelopassa/results.txt"
    \end{lstlisting}
    \caption{Generator of \emph{all} palindromic words of length less than $n$.}
    \label{fig:exmp3}
\end{wrapfigure}

However, we would like the function not to be passed sensitive files that should neither be read nor written.

Through the typing rules presented in this Section, we can assign the following type to the function \verb|palindromes_gen| in Figure \ref{fig:exmp3}:

\vspace{25pt}

\begin{equation}
    \begin{gathered}
         n{:}\overa{n: nat \;|\; \top_{nat}} \rightarrow (\under{v: string \;|\; is\_palindrome(v) \;\land\; \forall m. \;len(v, \;m) \Longrightarrow m < n}, \\
         get(F) \cdot F(n{:}(nat: v < n), \;p{:}(string: v = "/home/angelopassa/results.txt")))
    \end{gathered}
\end{equation}

So as mentioned, we would like to check that no strings representing sensitive file paths, such as \verb|/etc/shadow|, are passed to the $F$ API. To do this, we simply define a new policy as follows (denoting by $H$ the latent effect of the function \verb|palindromes_gen|):

\begin{equation}
    \forall \eta \in \llbracket H \rrbracket. \;\forall n{:}nat. \;\forall p{:}string. \;F(n, \;p) \in \eta \Longrightarrow \neg(p = "/etc/shadow")
\end{equation}

We can reuse the same logical formula to define the same type of policy for each of the sensitive files that concern us.

\subsection{Soundness}

Surprisingly, in this part we will not present any denotation of either the full type pair or the Extended Coverage Types. As mentioned above, there is no need to introduce new denotations since structurally it comes easy to separate types as needed. In the following we will therefore present only three theorems that in the aggregate will allow us to be able to assert the correctness of our type system:
\begin{enumerate*}[label=(\roman*)]
    \item First we will show that the correctness of the original type system remains unchanged in this extension. In essence, Theorem 4.3 presented in the original work \cite{coverage} is preserved.
    \item Next we will show that the qualifier $\psi$ presented in the Extended Coverage Types actually represents \textbf{\emph{all and alone}} the values returned by the expression, or function as the case may be.
    \item Finally, we present the type system correctness demonstration for the part concerning History Expressions.
\end{enumerate*}

\begin{theorem}[Correctness of Extension on Coverage Types]
    For each expression $e$, if one can infer a type for $e$ through the type system presented, i.e. $\Gamma \vdash e : (\under{v: b \;|\; \phi \;|\; \psi}, \;H)$, then through the original type system of $\lambda^{\textbf{TG}}$ it is possible to infer $\Gamma_{\phi} \vdash e : \under{v: b \;|\; \phi}$.
\end{theorem}

\begin{proof}
    Let us proceed rule by rule:
    \begin{itemize}
        \item For the rules \textsc{TErrr}, \textsc{TConst}, \textsc{TOp}, \textsc{TAction}, \textsc{TVarBase} and \textsc{TVarFun} the correspondence with the original rules is one-to-one. For \textsc{TErr} and \textsc{TVarBase} the demonstration is immediate. For rules using the function $Ty$ the proof depends on the construction of the function, but we have already mentioned how the qualifier $\phi$ is simply replicated a second time, consequently the theorem holds in these cases as well. For the rule \textsc{TVarFun}, the filtering operator $\phi$ applied to the context $\Gamma$, simply eliminates the histories and the $\psi$ qualifier while unchanging the contained variables, the Coverage Types qualifier and the function types qualifier.
        \item Also for the rules \textsc{TSub} and \textsc{TEq} the correspondence with the original rules is bi-univocal, here the premises are structurally identical, only the relation $<:$ that has been redefined changes. In the relation, however, only two new premises have been added, one on the denotation of the History Expressions and the other on the equality of the second qualifiers $\psi$. In essence, it is trivially true that:
        \begin{equation}
            \begin{gathered}
                \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}} \;\land\; \llbracket H_1 \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket H_2 \rrbracket_{\Gamma_{\psi}} \;\land\; \llbracket \under{v: b \;|\; \psi_1}\rrbracket_{\Gamma_{\psi}} = \llbracket \under{v: b \;|\; \psi_2} \rrbracket_{\Gamma_{\psi}} \\
                \Longrightarrow \\
                \llbracket \under{v: b \;|\; \phi_1} \rrbracket_{\Gamma_{\phi}} \subseteq \llbracket \under{v: b \;|\; \phi_2} \rrbracket_{\Gamma_{\phi}}
            \end{gathered}
        \end{equation}
        \item The rules \textsc{TFun} and \textsc{TFunFlat} do not alter the premises, moreover by eliminating the effects the rule \textsc{TFunFlat} is identical to the former.
        \item Even the rule \textsc{TMatch}, short of universal quantification on each branch, does not alter the premises, for although the type of $v_i$ and $d_i(\overline{y})$ are different, the addition of the condition using the operator $\langle \cdot \rangle$ places the constraint on the equality of the first qualifiers ($\phi$). Disjunction, as with the subtyping relationship, is also not altered for Coverage Types and only constraints are added to the original ones. The only difference is the fact that while in our type system it is possible to type a \verb|pattern-matching| in its entirety with one rule taking into account each branch, in the original one it is necessary to apply cascading \textsc{TMerge} on each pair of branches.
        The \textsc{TMerge} rule also does not alter the assumptions about the original Coverage Types.
        \item All rules on \verb|let-binding| constructs do not alter the structure of the original rules since the type of the function argument is always matched with the first qualifier of the type of the parameter passed, and the same substitutions are made in the contexts.
        \item The last rule, the \textsc{TFix}, is the most cumbersome to prove. Essentially, we add premises concerning History Expressions that are out of our interest in this demonstration, and then in place of encapsulating the expression $e$ in a $\lambda$ that takes as its argument the recursive function itself \cite{coverage}, we add to the environment the first parameter of the recursion $a$ and a variable $f$ of type $api$ that is associated via the resource context $\Delta$ with the very type we wish to infer. We note how we have thus only changed the way we perform the same procedure that leads us to the same result.
    \end{itemize}

    The same property applies for the typing of a function\footnote{We need to apply the operator $\phi$ to the entire function type - and not just remove the qualifier $\psi$ from the return type - since there may be other functions in the parameters.}:
    \begin{equation}
        \Gamma \vdash e : (\overline{\tau_i} \rightarrow (\under{v: b \;|\; \phi \;|\; \psi}, \;H_f), \;H_e) \Longrightarrow \Gamma_{\phi} \vdash e : (\overline{\tau_i} \rightarrow \under{v: b \;|\; \phi \;|\; \psi})_{\phi}
    \end{equation}
\end{proof}

\begin{theorem}[Correctness of Extended Coverage Types]
    For each expression $e$, if $\Gamma \vdash e : (\under{v: b \;|\; \phi \;|\; \psi}, \;H)$ then $\psi$ will represent \textbf{\emph{all and only}} the values returned by $e$.
\end{theorem}

\begin{proof}
    As we have already demonstrated, the function $Ty$ returns a Coverage Type (constants), or a function with a Coverage Type as return type (operators), which respect this property. In fact, the qualifier $\phi$ will always be identical to $\psi$, the latter being merely replicated to adapt to the new language type.
    For this demonstration, we can proceed inductively on the type system rules shown:
    \begin{itemize}
        \item For the rules \textsc{TConst}, \textsc{TAction}, \textsc{TOp} and \textsc{TErr} the demonstration is immediate from the above.
        \item For the rule \textsc{TVarFun}, the property is satisfied since the type of the variable $x$, already present in the context, is assumed to satisfy the property, and this type is the same as that present in the rule's consequences.
        \item Also for the rule \textsc{TVarBase} the property is satisfied since even if we add the same qualifier $v = x$ in all two positions of the type, when computing the denotation of the type of $x$ we will take the context $\Gamma$ by filtering the types through the second qualifier $\psi$, which by definition represents \emph{all and only} the values returned by the expression.
        \item The rule \textsc{TSub} retains the property since, if $\pi$ respects it, according to the relation $<:$ defined in the auxiliary rules, the denotation of the qualifiers $\psi$ also remains unchanged in $\pi'$, which will retain the property. The rule \textsc{TEq} does not alter the semantics of the entire type pair, so the property is retained.
        \item For the rule \textsc{TMatch}, by inductive assumption each branch $e_i$ will have associated an Extended Coverage Type (or a function that returns it), by performing the disjunction this will also be performed on the second qualifier $\psi$, thus guaranteeing for the \verb|pattern-matching| a type that also indicates \emph{all and only} the returned values.
        By the \textsc{TMerge} rule, by inductive hypothesis both $\tau_1$ and $\tau_2$ will respect the property, i.e. the qualifiers in the second field ($\phi$) will be semantically identical. Applying the disjunction between them takes the intersection between two sets (the denotations of $\tau_1$ and $\tau_2$) that are equal. The new qualifier $\phi$ belonging to $\tau$ is practically identical.
        \item The rule, \textsc{TFix}, has the same behaviour as the rules on functions already seen, essentially the type $\tau$ in the consequences is the same as in the premises, and a Coverage Type, $f$, is added to the context $\Gamma$, which trivially respects the property.
        \item The remaining rules are all on \verb|let-bindings| constructs, so the type $\tau$ in the premises is the same in the consequences. Furthermore, in rules such as \textsc{TNew} and \textsc{TGet} Coverage Types respecting the property are added to the context $\Gamma$; in the remaining ones, which are essentially applications of functions, the type of the passed parameters is an extended Coverage Type respecting the property (being in the premises), so replacing this in the return type of the function added to $\Gamma$ with the variable $x$ does not alter the property.
    \end{itemize}

    The same theorem also applies to the typing of a function: $\Gamma \vdash e : (\overline{\tau_i} \rightarrow (\under{v: b \;|\; \phi \;|\; \psi}, \;H_f), \;H_e)$, where $\psi$ represents \emph{\textbf{all and only}} the values returned by the function, based also on the parameters $\tau_i$.
\end{proof}

\begin{theorem}[Correctness of History Expressions]
    For every expression $e$, if $\Gamma \vdash e : (\tau, \;H)$ then for every $\eta$ such that $(e, \;\epsilon) \hookrightarrow^* (v, \;\eta)$ it holds that $\eta \in \llbracket H \rrbracket_{\Gamma}$.
\end{theorem}

\begin{proof}
    As we have already done, we proceed inductively on the rules of the type system, showing that if the property applies to expressions in the premises, it also applies to those in the consequences:
    \begin{itemize}
        \item For the rules \textsc{TConst}, \textsc{TOp}, \textsc{TAction}, \textsc{TVarBase} and \textsc{TVarFun} the verification is immediate as there is no reduction in the rules in Figure \ref{fig:semantic-op} and starting from a history $\epsilon$ this is also maintained in the static semantics.
        \item For the rule \textsc{TSub}, assuming for the sake of argument that the History Expression, which we will call $H$, present in $\pi$ is correct, the subtype relation $<:$ simply enlarges the denotation of H by changing it to an H', formally it holds that:
        \begin{equation}
            \forall \;\Gamma, \;H, \;H', \;\eta. \;\llbracket H \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket H'\rrbracket_{\Gamma_{\psi}} \;\land\; \eta \in \llbracket H \rrbracket_{\Gamma_{\psi}} \Longrightarrow \eta \in \llbracket H' \rrbracket_{\Gamma_{\psi}}
        \end{equation}
        The rule \textsc{TEq} does not alter the type denotation.
        \item For the rules \textsc{TFun} and \textsc{TFunFlat}, the argument is identical to that already made for the first point of the demonstration. Even for the recursive function statement alone (\textsc{TFix}) the empty history $\epsilon$ is the one generated this because according to the reduction rules in Figure \ref{fig:denot_history} the construct $\mu$ adds the appropriate substitution to $\Upsilon$, but reduces to $\epsilon$.
        \item For the rule \textsc{TMatch}, $v$ is a value, consequently as already demonstrated $\epsilon \in \llbracket H_{v_i} \rrbracket_{\Gamma_{\psi}}$ for each $i$. The same applies to the application of the constructors $d_i$ which, being part of the operators, their application will lead to the application of \textsc{TSub} to the empty history only. The disjunction leads to a situation in which for each $i$ it is true that $\llbracket H_{v_i} \cdot H_{y_i} \cdot H_{e_i} \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket H \rrbracket_{\Gamma_{\psi}}$. Having already noted that $\epsilon \in \llbracket H_{v_i} \rrbracket_{\Gamma_{\psi}}$ and $\epsilon \in \llbracket H_{y_i} \rrbracket$ we can affirm that $\llbracket \epsilon \cdot H_{e_i} \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket H \rrbracket_{\Gamma_{\psi}}$ for each $i$. To conclude, the operational rule \textsc{StMatch} reduces in one of the branches $e_i$ producing as effect $\epsilon$ (starting from $H = \epsilon$). But by inductive hypothesis $H_{e_i}$ is a correct over-approximation of $e_i$, and by eliminating the $\epsilon$ through the equality axioms presented in Figure \ref{fig:hist_eq} we arrive at stating that $\llbracket H_{e_i} \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket H \rrbracket_{\Gamma_{\psi}}$ for each $i$. We conclude by noting that one of $H_{e_i}$ is the correct over-approximation of the expression, but each of these belongs to $H$. The \textsc{TMerge} rule is actually similar to the \textsc{TSub} rule, in fact since both $H_1$ and $H_2$ are two correct over-approximations, the disjunction will take the larger of the two.
        \item Now we focus on the rules \textsc{TAppMulti} and \textsc{TAppLast} and $v_1$ will be either a normal function or a recursive function. Accordingly, we will take the rules \textsc{StLetAppLam} and \textsc{StLetAppFix} as reference in operational semantics. The same reasoning presented for the rule \textsc{TMatch} is used here, whereby the effects associated with $v_1$ and $v_2$ will surely contain in their denotations $\epsilon$. If the parameter $v_2$ applied is not the last of the function $v_1$, it will mean that the expression within the $\lambda$-abstraction is another function, and being a value it will produce no effect (relevant, $\epsilon$ excluded) by proceeding in the reduction immediately with $e_2$ (\textsc{StLetAppLam} or \textsc{StLetAppFix} and then \textsc{StLetE2}). For the rule \textsc{TAppMulti} we can end here since the effect $H_e$ will be correct by inductive hypothesis. By ending with the \textsc{TAppLast}, on the other hand, we can place the latent effect within the type of the behaviour since in this case $e_1$ will not be a value and it will be necessary to apply the rule \textsc{StLetE1} a given number of times. The history generated by the first reduction of $e_1$ until we proceed with $e_2$ will surely belong to the denotation of $H_{\tau_{v_1}}$ by inductive hypothesis.
        \item For the rules \textsc{TNew} and \textsc{TGet} the proof is straightforward since the concatenated history before $H_e$ is exactly the one found in the rules of semantic operation, where the premises on $\Delta$ also match.
        \item For the rule \textsc{TLetAction}, remembering the demonstration previously made on $\epsilon$ which in this case will definitely belong to the denotation of $H_{\alpha}$ and of each $H_{u_i}$ it is necessary to verify that $\llbracket \alpha(\overline{v_i}) \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket \alpha(\overline{b_i{:}\psi_i}) \rrbracket_{\Gamma_{\psi}}$. This is straightforward because we have already proved in the previous theorem that $\psi_i$ represents \emph{all and only} the values into which each $u_i$ could reduce, there will be no others. Consequently, for each $i$, $\psi[v \mapsto v_i]$ holds, and in relation to the rules in Figure \ref{fig:denot_history} we can state that the set-inclusion relation is verified.
        \item Finally, we conclude with the rule \textsc{TAppAPI}. Here we proceed in a mirrored manner to the demonstration on the rule \textsc{TLetAction}, only the relation to be proved changes, which becomes $\llbracket F(\overline{v_i}) \rrbracket_{\Gamma_{\psi}} \subseteq \llbracket call(\psi; \;\overline{a_i{:}(b_i{:}\psi_i})) \rrbracket_{\Gamma_{\psi}}$. But even here, thanks to the reduction relation of the History Expressions and the qualifier $\psi$ of the Extended Coverage Types it is easy to verify that it is satisfied.
    \end{itemize}
\end{proof}