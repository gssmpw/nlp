\section{METHOD}
\label{section: method}

This section introduces SVG-MPPI, a framework for navigating cluttered environments without explicit object placement. It combines the Semantic Visibility Graph (SVG) for path planning and MPPI with contact force minimization for robot control (Fig.~\ref{fig:overview_of_svg_mppi}). Sec.~\ref{sec: SVG} details the SVG algorithm, which adds passage nodes to connect disconnected regions. Sec.~\ref{sec: mppi with contact-force-minimization} explains the MPPI control strategy, using real-time feedback from IsaacGym to minimize contact forces. Finally, Sec.~\ref{sec: movability evaluation} covers movability evaluation for online replanning based on obstacle interactions.

\subsection{Semantic Visibility Graph (SVG)}
\label{sec: SVG}

The SVG extends the traditional VG by incorporating continuous movability, allowing the placement of \textit{passage nodes} near movable obstacles while accounting for the push actions required to access them. These nodes connect previously disconnected areas, creating new pathways for the robot, as shown in Fig.~\ref{fig:simple_svg_graph}b-c. In the initial phase (lines 1-11 of Algorithm \ref{alg:svg}), the process follows the conventional VG approach \cite{Berg2000}. In the second phase (lines 12-19 of Algorithm \ref{alg:svg}), passage nodes are added near movable obstacl
es where the space between pairs of obstacles is too narrow for the robot to pass. These passage nodes are integrated into the weighted visibility graph like any other node. However, accessing these nodes requires the robot to manipulate the obstacle as the safe distance margin is breached.

\begin{algorithm}[b!]
    \caption{Semantic Visibility Graph}
    \label{alg:svg}

    \algorithmwithoutend

    \footnotesize
    \begin{algorithmic}[1]
        \color{darkgray}
        \State \textbf{Input:} A set \( O \) of disjoint polygonal obstacles.
        \State \textbf{Output:} The visibility graph \( G(V, E) \).
        \vspace{1mm}

        \State Initialize \( V \gets \emptyset \); \( E \gets \emptyset \)
        \vspace{1mm}
        \For{$i \gets 0$ to $|O| - 1$}
            \State Compute \( P_i \gets \text{vertices of inflated polygon } O_i \text{ with safety margin } r \)
            \For{$j \gets 0$ to $|P_i| - 1$}
                \State Select \( v \gets P_i[j] \)
                \State Compute \( W \gets \text{visibleVertices}(v, O) \)
                \For{each vertex \( w \in W \)}
                    \State Update \( E \gets E \cup \{(v, w)\} \)
                \State Update \( V \gets V \cup \{v\} \)
                \EndFor
            \EndFor
        \EndFor

        \vspace{1mm}
        
        \color{black}
        \For{each pair \( (P_i, P_j) \) where \( i \neq j \)}
            \If{distance between \( P_i \) and \( P_j \) is less than \( 2r \)}
                \If{either \( \text{mass}(P_i) \leq \text{max mass} \) or \( \text{mass}(P_j) \leq \text{max mass} \)}
                    \State Compute \( p \gets \text{passageNodes}(P_i, P_j) \)
                    \State Compute \( W \gets \text{visibleVertices}(p, O) \)
                    \For{each vertex \( w \in W \)}
                        \State Update \( E \gets E \cup \{(p, w)\} \)
                    \State Update \( V \gets V \cup \{p\} \)
                    \EndFor
                \EndIf
            \EndIf
        \EndFor
        \color{black}
        \vspace{1mm}
        
        \State \Return \( G = (V, E) \)
    \end{algorithmic}
    \normalsize
\end{algorithm}

Movability is treated as a continuous variable, based on the mass \( m_i \) of each obstacle. Objects with masses below a threshold are considered movable, with lighter objects preferred for manipulation. Movability, defined by mass, can be estimated using perception-based machine learning models such as Image2Mass \cite{Standley2017}, or derived from obstacle interactions \cite{Wu2015, Aguilera2021, Dutta2023, Yuan2023}. However, the process of deriving mass from environmental data is beyond the scope of this work, meaning mass distributions are assumed to be known.

Passage nodes are created by identifying candidate obstacle pairs. Two obstacles, \( O_i \) and \( O_j \), form a pair if they are close together, at least one is movable, and the gap between them is too narrow for the robot to pass. The boundaries are approximated using convex hulls to ensure accurate node placement for both convex and non-convex shapes. Passage nodes are then created through a three-stage process, as visualized with two examples in Fig.~\ref{fig:passage_node_construction}. 
In Stage I, the nearest points on the edges of the objects are identified that lie on the line-segments connecting the vertices of $O_i$ to the other object $O_j$, to estimate the passage area.
By selecting the closest points within this set,
an area is created for connecting passage nodes to each other and the disconnected regions. In Stage II, entry and exit boundaries are drawn from the convex hull of all the nearest points, defining the line segments where passage nodes will be placed. Finally, In Stage III, passage nodes \( V_{\text{passage}} \) are placed along entry and exit boundaries, treating them interchangeably in an undirected graph. Each passage node is repositioned along the boundary using linear interpolation, shifting it closer to the lighter obstacle to minimize contact with the heavier one. The interpolation factor \( \gamma \) depends on the masses \( m_i \) and \( m_j \) of the obstacles. A passage node \( v_{\text{z}} \in V_{\text{passage}} \), where \( z \in \{1, \dots, n_{\text{passage}} \} \) and \( n_{\text{passage}} \) is the total number of passage nodes, is defined as:

\small
\begin{equation} \label{eq: passage node}
    v_z = v_i + \gamma (v_j - v_i), \qquad \text{where} \ \gamma = m_j 
\left({m_i + m_j}\right)^{-1}.
\end{equation}
\normalsize

In contrast to free space nodes, passage nodes have an additional cost based on the distances from the passage point to nearby obstacles, adjusted by their respective masses. Specifically, for a passage node \( v_z \in V_{\text{passage}}\), the cost \( C_{z} \) is computed as:

\small
\begin{equation} \label{eq:node_cost}
    C_{z} = \max\left(0, 1 - \frac{d_i}{r}\right) \cdot m_i + \max\left(0, 1 - \frac{d_j}{r}\right) \cdot m_j
\end{equation}
\normalsize

The SVG constructs a weighted, undirected graph where edge costs represent travel distances between waypoints, and node costs reflect the effort required to manipulate obstacles (Fig.~\ref{fig:simple_svg_graph}). 
A* \cite{Nilsson1968} is used to compute the optimal path, guided by edge costs for robot movement and manipulation-effort cost of the passage nodes, with the Euclidean distance as a heuristic. 
This ensures that both the distance traveled and the physical manipulation required are accounted for in determining the lowest-cost path. 
Using the set of waypoints, we apply linear interpolation, represented as a first-order polynomial, to ensure uniform spacing between waypoints~\cite{Agarwal1993}. This spacing aids in normalizing the distance cost term for our local control strategy MPPI.

\begin{figure}[tb!]
    \includegraphics[width=0.49\textwidth]{figures/3-method/img_passage_node_constructions.png}
    \caption{Visualization of passage node construction between two sets of obstacles: (1) Hexagon and square (top row), and (2) Triangle and pentagon (bottom row). Each stage displays the progression from initial shape plotting to the identification of nearest points, boundary construction, and final passage node generation.}
    \label{fig:passage_node_construction}
    \vspace{-4.5mm}
\end{figure}

\subsection{MPPI with Contact-Force Minimization}
\label{sec: mppi with contact-force-minimization}

The method introduced in Sec.~\ref{sec: SVG} generates a set of waypoints from the robot's starting position to the goal. In this section, we outline the constraints and objective function of MPPI, which ensure waypoint following while minimizing push actions by reducing contact forces on the robot. 
By integrating MPPI with the IsaacGym physics engine, as described in Sec.~\ref{sec: MPPI}, we extract the robot's contact force tensor and incorporate it into the objective function. 

The objective function is subject to both equality and inequality constraints. The robot’s state transition, \( \mathbf{x}_{t+1} = f(\mathbf{x}_t, \mathbf{v}_t) \), for all \( t \in [0, \dots, T-1] \), is computed using IsaacGym~\cite{Pezzato2023}. The initial state is constrained by the robot’s current pose, \( \mathbf{x}_0 = \mathbf{x}_{\text{init}} \) and inequality constraints ensure that the robot’s state \( \mathbf{x}_t \in \mathcal{X} \) and control inputs \( \mathbf{v}_t \in \mathcal{V} \) remain within the feasible space for all \( t \in [1, \dots, T] \).

MPPI defines state trajectories \( Q_k \) across \( k \in K \) rollouts, each evaluated by a corresponding cost \( C_k \). % based on the designed cost function \( C \). 
Unlike the implementation in~\cite{Pezzato2023}, we omit the discount factor \( \lambda \) and concentrate most terms within the terminal cost \( C_{\text{term}} \) at the final prediction step rather than distributed across intermediate steps with stage cost \( C_{\text{stage}} \). 
This ensures that MPPI emphasizes long-term planning and allows for deviations from the path at intermediate stages, to avoid unnecessary push actions. The total cost function \( C_{\text{NAMO}} \) for each rollout \( k \) is defined as:

\small
\begin{equation} \label{eq: stage and terminal function}
    C_{\text{NAMO}} = 
    \begin{cases}
        C_{\text{term}}    & ,\text{if} \ t = T \\
        C_{\text{stage}}   & ,\text{otherwise}.
    \end{cases}
\end{equation}
\normalsize

Next, we will discuss the individual cost terms that make up the total cost function. Each cost term, such as \( C_{\text{dist}} \) for distance or \( C_{\text{rot}} \) for rotation, is a weighted version of its corresponding component. For example, the distance cost is expressed as \( C_{\text{dist}} = w_{\text{dist}} \cdot c_{\text{dist}} \), where \( w_{\text{dist}} \) is the associated weight. These weights serve as hyperparameters that balance the different components of the robot's behavior. The stage and terminal costs are structured as follows: 

\small
\begin{subequations} \label{eq: cost function}
    \begin{align}
    C_{\text{term}} &= C_{\text{ctrl}} + C_{\text{dist}} + C_{\text{prog}} + C_{\text{rot}} + C_{\text{force}}, \\
    C_{\text{stage}} &= C_{\text{ctrl}}.
    \end{align}
\end{subequations}
\normalsize

The control cost \( c_{ctrl} \) minimizes deviations between the robot’s predicted velocity \( \mathbf{\dot{x}}_t \), obtained using IsaacGym, and the desired control input \( \mathbf{v}_t \). This cost penalizes jerky movements and encourages smooth trajectories. The weight for the control cost is represented as a diagonal matrix \( W_{\text{ctrl}} \), which assigns different penalties to each velocity component. The control cost is expressed as:

\small
\begin{equation} \label{eq: control cost}
    c_{\text{ctrl}} = \left( \frac{ | \dot{\textbf{x}}_t - \textbf{v}_t | }{\textbf{u}_{\text{max}}} \right)^T W_{\text{ctrl}} \left( \frac{ | \dot{\textbf{x}}_t - \textbf{v}_t | }{\textbf{u}_{\text{max}}} \right).
\end{equation}
\normalsize

The distance cost \( c_{\text{dist}} \) encourages the robot to move toward the next waypoint. First, the set $\mathbf{D}_t = \{d_{1, t}, \dots, d_{n_p, t}\}$ collects the Euclidean distances between the robot’s predicted state \( \mathbf{x}_t \) and all waypoints \( \mathcal{P} \). The closest waypoint $\textbf{p}_{i}$ is identified by finding the index \( i \) that minimizes \( \mathbf{D}_t \). % as defined in Eq.~\eqref{eq: distance cost}. 
The robot then targets the next waypoint \(\mathbf{p}_{i+1}\), where the distance \( d_{i+1,t} \) is normalized by \( \alpha \):

\small
\begin{equation} \label{eq: distance cost}
    c_{\text{dist}} = \frac{d_{i+1,t}}{\alpha}, \quad i = \arg\min(\textbf{D}_t). %, \quad \textbf{d}_t = \| \textbf{x}_t - \mathcal{P} \|_2.
\end{equation}
\normalsize

The progress cost \( c_{prog} \) evaluates the advancement of each rollout \( k \) along the path $\mathcal{P}$. Rollouts that lag behind are penalized. The index \( i_{T, k} \) of the closest waypoint at the terminal step $T$ is computed for each rollout $k$ and collected over all rollouts in the set $I_T = \{ i_{T, 1}, \dots, i_{T, K} \} $. 
Rollouts with lower waypoint indices are penalized, while those further along the path are rewarded. The progress cost is defined as:

\small
\begin{equation} \label{eq: progress cost}
    c_{\text{prog}, k} = 1 - \frac{i_{T,k} - \min(I_T)}{\max(I_T) - \min(I_T)} %, \quad \rho_t = \max(i_{t,k}) - \min(i_{t,k}).
\end{equation}
\normalsize

The rotation cost \( c_{rot} \) aligns the robot’s predicted orientation \( \theta_{t} \) with the direction of the next waypoint \( \theta_{\text{target}} \). This alignment ensures smooth navigation, particularly in cluttered environments where a precise orientation is necessary for safety. The target angle \( \theta_{\text{target}} \) is computed using the arctan function, which calculates the angle between the robot’s position and the upcoming waypoint $\textbf{p}_{i+1} = [p_x, p_y]^{\top}$. The rotation cost is normalized by \( \pi \):

\small
\begin{equation} \label{eq: rotation cost}
    c_{\text{rot}} = \frac{| \theta_{\text{target}} - \theta_{t} |}{\pi}, \quad \theta_{\text{target}} = \text{arctan2}(p_y - \mathrm{x}_t^y, p_x - \mathrm{x}_t^x).
\end{equation}
\normalsize

The force cost \( c_{\text{force}} \) penalizes excessive contact forces on the robot’s joints during interactions with obstacles. IsaacGym computes the forces applied to each joint at every prediction step. Rollouts with fewer push actions accumulate less force, resulting in lower penalties over the prediction horizon \( T \). The cumulative force \( f_{\text{robot}} \) is summed across all joints $j \in N$ and prediction steps $T$, and normalized:

\small
\begin{equation} \label{eq: force cost}
    c_{\text{force}} = \frac{f_{\text{robot}}}{\max(f_{\text{robot}}) + \epsilon}, \quad f_{\text{robot}} = \sum_{t=1}^{T} \sum_{j=1}^{N} f_{j,t}.
\end{equation}
\normalsize

\subsection{Movability Evaluation}
\label{sec: movability evaluation}

The robot evaluates the movability of objects based on their perceived mass distribution in the environment. If an object initially classified as movable resists manipulation, its mass distribution is updated to the maximum threshold, reclassifying it as non-movable. 
Currently, a binary re-evaluation of movability is used to avoid excessive replanning, though it could be extended to a continuous re-evaluation for a robotic system by estimating the obstacle mass from physical data~\cite{Aguilera2021, Dutta2023}. 
Updating movability estimates and replanning are therefore initiated when specific conditions suggest that an object is non-movable.
A timer mechanism monitors these conditions and starts a timer \( t_{\text{monitor}} \) when any are triggered. If the timer exceeds \( \tau_{\text{replan}} \), the robot captures a new snapshot of the environment, updates the movability data, and regenerates the graph and path to the goal. 

The first condition for replanning is triggered when the robot’s joint velocities drop close to zero; replanning occurs if the joint velocities fall below \( \epsilon = 0.1 \, \text{m/s} \), indicating significant resistance. The second condition involves a deviation between actual and desired joint velocities, with a deviation greater than 75\% (\( \lambda = 0.75 \)) of the desired velocity signaling ineffective movement. Lastly, if the joint velocities are high but the robot's position remains stable, indicating slipping, this condition is met when the robot is stationary but joint velocities exceed \( \mu = 0.1 \, \text{m/s} \). If none of these conditions are met, the timer resets, pausing the evaluation process until one of the conditions is activated again.
