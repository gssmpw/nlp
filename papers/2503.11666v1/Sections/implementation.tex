The proposed methodology flow, illustrated in Fig. \ref{proposedmethod}, commences with the development of a comprehensive verification plan derived from the design specification. This plan encompasses all verification scenarios and cover items that must be achieved during design verification. Subsequently, a \ac{PyUVM} testbench is created, incorporating functional tests and coverage models defined using PyVSC. The simulation of these tests generates coverage information, which is then merged using PyUCIS to obtain overall coverage \cite{Pyucis}. The application of data science and supervised \ac{ML} techniques to this data enables the creation of models using various \ac{ML} algorithms. These models are utilized to produce an \ac{ML}-optimized regression. A comparative analysis of the functional coverage between the original and \ac{ML}-optimized regressions for various \ac{ML} algorithms is performed. If the coverage regain in the optimized regression reaches \SI{99}{\percent} or higher, the flow is terminated. Otherwise, the flow reverts to the simulation regression step, and the process is repeated until the desired coverage is achieved.
\begin{figure}
	\centering
	\includegraphics[width=0.7\linewidth]{Figures/proposedmethod.pdf} 
	\caption{Proposed methodology}
	\label{proposedmethod}
\end{figure}
\subsection{Testbench creation and simulation regression}
\label{tbcreation}
\ac{DUVs} utilized in this study are a 32-bit \ac{ALU}, \ac{ADC}, and \ac{SECDED} \ac{ECC}. The cover bins for the \ac{ALU} and \ac{ECC} are deliberately defined to be challenging to hit, while the ADC is an analog-mixed signal model. This allow a more efficient evaluation of the methodology proposed in this research. The testbench is created using PyUVM and PyVSC. The detailed testbench architecture is also discussed in the work \cite{gadde}. The following considerations are taken into account when coding this script for running simulation regression:
\begin{itemize}
	\item Specify the tests defined in the testbench to be run multiple times
	\item Run each test with a different random seed value, generated using the Python random module
\end{itemize}

\subsection{Data collection and preparation}
\label{datacnp}
\ac{PyUVM} testbenches offer a significant advantage in data collection compared to SystemVerilog-UVM testbenches. During simulation regression, \ac{PyUVM} testbenches can collect sampled values of randomized input stimuli and coverbin hit/miss information at every clock cycle, storing them in a \ac{CSV} file.

PyVSC provides a callback method to collect bin hit/miss information, which is defined in the data collection class and registered in the UVM monitor class. Every clock cycle, the covergroup is sampled, and the information is collected along with the randomized objects. This data is then appended to the CSV file, created at the start of the regression. The process ï¬‚ow of collecting data is presented in Fig. \ref{datacollection}.
\begin{figure}
	\centering
	\includegraphics[width=0.85\linewidth]{Figures/datacollection.pdf} 
	\caption{Data collection}
	\label{datacollection}
\end{figure}
As discussed in Fig. \ref{datapreparation}, the collected CSV data is first processed using pandas \cite{pandas} dataframes. Duplicate rows are removed to ensure data quality. Next, the correlation function from the pandas library is applied to determine the dependent variable. The input with the highest correlation value with respect to a particular bin is selected as the dependent variable, while all other inputs are considered independent variables.
\begin{figure}
	\centering
	\includegraphics[width=0.9\linewidth]{Figures/datapreparation.pdf} 
	\caption{Data preparation}
	\label{datapreparation}
\end{figure}
\subsection{ML processing}
\label{mlp}
The final dataset is analyzed using supervised machine learning models to identify positive or negative relationships between the variables. These models can also forecast new, unseen observations. This work employs various supervised regression algorithms from the scikit-learn library \cite{scikit-learn}. A separate \ac{ML} model is constructed for each coverbin to train and predict constraints. These models aim to describe the relationships between variables by fitting lines to independent data samples and predicting dependent variable ranges required to hit the coverbins during test simulation.
\subsection{Automatic testbench updation}
\label{automatictb}
To minimize effort, we have implemented an automated solution using Python script to update the testbench. This script take the \ac{ML}-predicted value ranges as input and generate constraints, sequences, and tests for all ML algorithms. This automation enables efficient running of optimized regressions and avoids extra manual effort.