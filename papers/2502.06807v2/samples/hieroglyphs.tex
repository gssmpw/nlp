\subsection{Hieroglyphs}
A total of 44 points was scored on Hieroglyphs across two separate submissions.

\subsubsection{Submission 1}
In the first submission, a score of 34 out of 100 points was achieved, distributed across subtasks 1, 2, and 4.

\begin{lstlisting}[language=C++]
#include "hieroglyphs.h"
#include <bits/stdc++.h>
using namespace std;
std::vector<int> ucs(std::vector<int> A, std::vector<int> B)
{
    int N = (int) A.size();
    int M = (int) B.size();
    if (N == 0 || M == 0) {
        std::vector<int> ret;
        return ret;
    }
    const int MAX_VAL = 200001;
 
    static int cntA[200002], cntB[200002];
    for (int i = 0; i < 200002; i++) {
        cntA[i] = 0;
        cntB[i] = 0;
    }
 
    for (int i = 0; i < N; i++) cntA[A[i]]++;
    for (int i = 0; i < M; i++) cntB[B[i]]++;
 
    static int cVal[200002];
    for (int i = 0; i < 200002; i++) {
        if (cntA[i] > 0 && cntB[i] > 0) {
            cVal[i] = min(cntA[i], cntB[i]);
        } else {
            cVal[i] = 0;
        }
    }
 
    long long sumC = 0;
    for (int x = 0; x < 200002; x++) {
        sumC += cVal[x];
    }
 
    if (sumC == 0) {
        std::vector<int> ret;
        return ret;
    }
 
    // Precompute earliest and latest occurrences in A and B for all x.
    static int earliestA[200002], latestA[200002], earliestB[200002], latestB[200002];
    for (int i = 0; i < 200002; i++) {
        earliestA[i] = -1;
        latestA[i] = -1;
        earliestB[i] = -1;
        latestB[i] = -1;
    }
 
    for (int i = 0; i < N; i++) {
        int letter = A[i];
        if (earliestA[letter] == -1) earliestA[letter] = i;
        latestA[letter] = i;
    }
    for (int i = 0; i < M; i++) {
        int letter = B[i];
        if (earliestB[letter] == -1) earliestB[letter] = i;
        latestB[letter] = i;
    }
 
    // Now intervals for cVal[x] = 1.
    struct Interval {
        int letter;
        int eA, lA, eB, lB;
    };
 
    vector<Interval> intervals;
    for (int x = 0; x < 200002; x++) {
        if (cVal[x] == 1) {
            Interval I;
            I.letter = x;
            I.eA = earliestA[x]; I.lA = latestA[x];
            I.eB = earliestB[x]; I.lB = latestB[x];
            intervals.push_back(I);
        }
    }
 
    // sort intervals by eA.
    std::sort(intervals.begin(), intervals.end(), [](const Interval &a, const Interval &b){
        return a.eA < b.eA;
    });
 
    // Balanced tree keyed by eB, store lB as well.
    vector<int> segmentTree(4*(M+5), -1);
    auto update = [&](int idx, int start, int end, int pos, int val, auto &&f) -> void {
        if (start == end) {
            segmentTree[idx] = val;
            return;
        }
        int mid = (start+end)/2;
        if (pos <= mid) f(idx*2, start, mid, pos, val, f);
        else f(idx*2+1, mid+1, end, pos, val, f);
        segmentTree[idx] = max(segmentTree[idx*2], segmentTree[idx*2+1]);
    };
    auto query = [&](int idx, int start, int end, int l, int r, auto &&f) -> int {
        if (r < start || end < l) return -1;
        if (l <= start && end <= r) {
            return segmentTree[idx];
        }
        int mid = (start+end)/2;
        int leftVal = f(idx*2, start, mid, l, r, f);
        int rightVal = f(idx*2+1, mid+1, end, l, r, f);
        return max(leftVal, rightVal);
    };
 
    vector<Interval> intervalsSortedByLA = intervals;
    sort(intervalsSortedByLA.begin(), intervalsSortedByLA.end(), [](const Interval &a, const Interval &b){
        return a.lA < b.lA;
    });
 
    int j = 0;
    for (int i = 0; i < intervals.size(); i++) {
        auto &x = intervals[i];
        int eAx = x.eA;
        // remove intervals from data structure where lA[y] < eAx.
        while (j < intervalsSortedByLA.size() && intervalsSortedByLA[j].lA < eAx) {
            auto &y = intervalsSortedByLA[j];
            // remove y from segment tree keyed by eB[y].
            update(1, 0, M-1, y.eB, -1, update);
            j++;
        }
 
        // query in B dimension: find if there's an interval y with eB[y] <= lB[x] and lB[y] >= eB[x].
        int minB = x.eB; // eB[x]
        int maxB = x.lB; // lB[x]
        if (minB > maxB) {
            // If eB[x] > lB[x], no intersection possible.
        } else {
            // query in the segment tree range [0, maxB] to find the maximum lB[y].
            int maxVal = query(1, 0, M-1, 0, maxB, query);
            if (maxVal >= minB) {
                // found intersection with a letter y where cVal[y] = 1.
                std::vector<int> ret;
                ret.push_back(-1);
                return ret;
            }
        }
 
        // add x to data structure keyed by eB[x].
        update(1, 0, M-1, x.eB, x.lB, update);
    }
 
    // If no intersection found among cVal=1 intervals, proceed with chain method.
 
    // The chain method code.
    static vector<int> posAarr[200002];
    static vector<int> posBarr[200002];
    for (int i = 0; i < 200002; i++) {
        posAarr[i].clear();
        posBarr[i].clear();
    }
 
    for (int i = 0; i < N; i++) {
        if (cVal[A[i]] > 0) posAarr[A[i]].push_back(i);
    }
    for (int i = 0; i < M; i++) {
        if (cVal[B[i]] > 0) posBarr[B[i]].push_back(i);
    }
 
    struct QItem {
        int letter;
        int pos;
    };
 
    struct QComp {
        bool operator()(const QItem &a, const QItem &b) const {
            if (a.pos == b.pos) return a.letter > b.letter;
            return a.pos > b.pos;
        }
    };
 
    priority_queue<QItem, vector<QItem>, QComp> pq;
 
    static int posAarrIdx[200002];
    static int occInAarr[200002];
 
    for (int x = 0; x < 200002; x++) {
        posAarrIdx[x] = 0;
        occInAarr[x] = 0;
        if (cVal[x] > 0 && posAarr[x].size() > 0) {
            QItem item;
            item.letter = x;
            item.pos = posAarr[x][0];
            pq.push(item);
        }
    }
 
    static int TAlpha[200002];
    for (int x = 0; x < 200002; x++) {
        if (cVal[x] > 0) TAlpha[x] = cntB[x] - cVal[x]; else TAlpha[x] = 0;
    }
 
    static int freqAlpha[200002]; // freq in B up to posB0.
    for (int x = 0; x < 200002; x++) freqAlpha[x] = 0;
 
    int posB0Alpha = -1;
    {
        int i = 0;
        for (; i < M; i++) {
            int letter = B[i];
            if (cVal[letter] > 0) {
                freqAlpha[letter]++;
                if (freqAlpha[letter] > TAlpha[letter]) {
                    freqAlpha[letter]--;
                    break; // cause posB0Alpha = i-1
                }
            }
        }
        posB0Alpha = i-1;
        if (i == M) posB0Alpha = M-1;
    }
 
    vector<int> U;
    U.reserve(sumC);
 
    int posB = -1;
    int usedCount = 0;
 
    auto updatePosB0Alpha = [&](int letter, auto &freqAlpha, auto &TAlpha, int &posB0Alpha, int M) {
        int i = posB0Alpha + 1;
        while (i < M) {
            int l = B[i];
            if (cVal[l] > 0) {
                freqAlpha[l]++;
                if (freqAlpha[l] > TAlpha[l]) {
                    freqAlpha[l]--;
                    break;
                }
            }
            i++;
        }
        posB0Alpha = i-1;
    };
 
    while (!pq.empty() && usedCount < sumC) {
        QItem item = pq.top();
        pq.pop();
 
        int letter = item.letter;
        int posAVal = posAarr[letter][posAarrIdx[letter]];
 
        auto &barr = posBarr[letter];
        int idx = (int) (std::lower_bound(barr.begin(), barr.end(), posB + 1) - barr.begin());
        if (idx == (int) barr.size()) {
            posAarrIdx[letter]++;
            if (posAarrIdx[letter] < posAarr[letter].size()) {
                QItem newItem;
                newItem.letter = letter;
                newItem.pos = posAarr[letter][posAarrIdx[letter]];
                pq.push(newItem);
            }
            continue;
        } else {
            int posBVal = barr[idx];
 
            TAlpha[letter]++;
            int oldPosB0Alpha = posB0Alpha;
            vector<pair<int,int>> freqChanges;
 
            int startIndex = posB0Alpha + 1;
            int i = startIndex;
            while (i < M) {
                int l = B[i];
                if (cVal[l] > 0) {
                    freqAlpha[l]++;
                    freqChanges.push_back({l, i});
                    if (freqAlpha[l] > TAlpha[l]) {
                        freqAlpha[l]--;
                        freqChanges.pop_back();
                        break;
                    }
                }
                i++;
            }
            int newPosB0Alpha = i-1;
 
            if (posBVal <= newPosB0Alpha) {
                U.push_back(letter);
                usedCount++;
                posB = posBVal;
 
                occInAarr[letter]++;
                posAarrIdx[letter]++;
                if (occInAarr[letter] < cVal[letter] && posAarrIdx[letter] < posAarr[letter].size()) {
                    QItem newItem;
                    newItem.letter = letter;
                    newItem.pos = posAarr[letter][posAarrIdx[letter]];
                    pq.push(newItem);
                }
 
                posB0Alpha = newPosB0Alpha;
 
            } else {
                TAlpha[letter]--;
                for (auto &fc : freqChanges) {
                    freqAlpha[fc.first]--;
                }
                posB0Alpha = oldPosB0Alpha;
 
                posAarrIdx[letter]++;
                if (posAarrIdx[letter] < posAarr[letter].size()) {
                    QItem newItem;
                    newItem.letter = letter;
                    newItem.pos = posAarr[letter][posAarrIdx[letter]];
                    pq.push(newItem);
                }
                continue;
            }
 
        }
    }
 
    if (usedCount < sumC) {
        std::vector<int> ret;
        ret.push_back(-1);
        return ret;
    }
 
    return U;
}
\end{lstlisting}


\subsubsection{Submission 2}
In the second submission, the model scored 10 points on subtask 3.

\begin{lstlisting}[language=C++]
#include "hieroglyphs.h"
#include <bits/stdc++.h>
using namespace std;
 
std::vector<int> ucs(std::vector<int> A, std::vector<int> B)
{
    int N = (int)A.size();
    int M = (int)B.size();
 
    int a0 = 0, a1 = 0;
    for (int i = 0; i < N; i++) {
        if (A[i] == 0) a0++;
        else if (A[i] == 1) a1++;
    }
    int b0 = 0, b1 = 0;
    for (int i = 0; i < M; i++) {
        if (B[i] == 0) b0++;
        else if (B[i] == 1) b1++;
    }
 
    int Z = min(a0, b0);
    int O = min(a1, b1);
 
    // If Z=0 and O=0, universal subsequence is the empty sequence.
    if (Z == 0 && O == 0) {
        return {};
    }
 
    vector<int> zeroPosA; zeroPosA.reserve(a0);
    for (int i = 0; i < N; i++) if (A[i] == 0) zeroPosA.push_back(i);
    vector<int> zeroPosB; zeroPosB.reserve(b0);
    for (int i = 0; i < M; i++) if (B[i] == 0) zeroPosB.push_back(i);
 
    vector<int> prefixOnesA(N+1, 0);
    for (int i = 1; i <= N; i++) prefixOnesA[i] = prefixOnesA[i-1] + (A[i-1] == 1);
    vector<int> prefixOnesB(M+1, 0);
    for (int i = 1; i <= M; i++) prefixOnesB[i] = prefixOnesB[i-1] + (B[i-1] == 1);
 
    auto getOnesAfterZero = [&](vector<int> & zeroPos, vector<int> & prefixOnes, int totalOnes, int z) {
        if (z == 0) return totalOnes;
        else {
            if (z-1 >= (int)zeroPos.size()) return 0; // safety
            int pos = zeroPos[z-1];
            int onesUsed = prefixOnes[pos+1];
            int onesAfter = totalOnes - onesUsed;
            return onesAfter;
        }
    };
 
    vector<int> fAval(Z+1), fBval(Z+1);
    for (int z = 0; z <= Z; z++) {
        fAval[z] = getOnesAfterZero(zeroPosA, prefixOnesA, a1, z);
        fBval[z] = getOnesAfterZero(zeroPosB, prefixOnesB, b1, z);
    }
 
    vector<int> cZ(Z+1);
    for (int z = 0; z <= Z; z++) cZ[z] = min(fAval[z], fBval[z]);
 
    vector<int> onePosA; onePosA.reserve(a1);
    for (int i = 0; i < N; i++) if (A[i] == 1) onePosA.push_back(i);
    vector<int> onePosB; onePosB.reserve(b1);
    for (int i = 0; i < M; i++) if (B[i] == 1) onePosB.push_back(i);
 
    vector<int> prefixZerosA(N+1, 0);
    for (int i = 1; i <= N; i++) prefixZerosA[i] = prefixZerosA[i-1] + (A[i-1] == 0);
    vector<int> prefixZerosB(M+1, 0);
    for (int i = 1; i <= M; i++) prefixZerosB[i] = prefixZerosB[i-1] + (B[i-1] == 0);
 
    auto getZerosAfterOne = [&](vector<int> & onePos, vector<int> & prefixZeros, int totalZeros, int w) {
        if (w == 0) return totalZeros;
        else {
            if (w-1 >= (int)onePos.size()) return 0; // safety
            int pos = onePos[w-1];
            int zerosUsed = prefixZeros[pos+1];
            int zerosAfter = totalZeros - zerosUsed;
            return zerosAfter;
        }
    };
 
    vector<int> gAval(O+1), gBval(O+1);
    for (int w = 0; w <= O; w++) {
        gAval[w] = getZerosAfterOne(onePosA, prefixZerosA, a0, w);
        gBval[w] = getZerosAfterOne(onePosB, prefixZerosB, b0, w);
    }
 
    vector<int> cO(O+1);
    for (int w = 0; w <= O; w++) cO[w] = min(gAval[w], gBval[w]);
 
    vector<int> U;
    U.reserve(Z+O);
 
    int zUsed = 0;
    int oUsed = 0;
 
    auto canPlaceZero = [&](int zUsed, int oUsed) {
        if (zUsed >= Z) return false;
        int c = cZ[zUsed+1]; // constraint for the next zero in U.
        int onesLeft = O - oUsed;
        return onesLeft >= c;
    };
 
    auto canPlaceOne = [&](int zUsed, int oUsed) {
        if (oUsed >= O) return false;
        int c = cO[oUsed+1]; // constraint for the next one in U.
        int zerosLeft = Z - zUsed;
        return zerosLeft >= c;
    };
 
    for (int i = 0; i < Z+O; i++) {
        bool placeZ = canPlaceZero(zUsed, oUsed);
        bool placeO = canPlaceOne(zUsed, oUsed);
        if (!placeZ && !placeO) {
            return {-1};
        } else if (placeZ && !placeO) {
            U.push_back(0);
            zUsed++;
        } else if (!placeZ && placeO) {
            U.push_back(1);
            oUsed++;
        } else {
            int cZc = cZ[zUsed+1];
            int cOc = cO[oUsed+1];
            bool canPickZero = false;
            bool canPickOne = false;
 
            {
                int newZUsed = zUsed + 1;
                int newOUsed = oUsed;
                int onesLeft = O - newOUsed;
                int zerosLeft = Z - newZUsed;
                bool feasible = true;
                if (Z > newZUsed) { // check cZ in range [newZUsed+1..Z]
                    int maxZConstraint = cZ[newZUsed+1];
                    if (onesLeft < maxZConstraint) feasible = false;
                }
                if (O > newOUsed) { // check cO in range [newOUsed+1..O]
                    int maxOConstraint = cO[newOUsed+1];
                    if (zerosLeft < maxOConstraint) feasible = false;
                }
                canPickZero = feasible;
            }
 
            {
                int newZUsed = zUsed;
                int newOUsed = oUsed + 1;
                int onesLeft = O - newOUsed;
                int zerosLeft = Z - newZUsed;
                bool feasible = true;
                if (Z > newZUsed) {
                    int maxZConstraint = cZ[newZUsed+1];
                    if (onesLeft < maxZConstraint) feasible = false;
                }
                if (O > newOUsed) {
                    int maxOConstraint = cO[newOUsed+1];
                    if (zerosLeft < maxOConstraint) feasible = false;
                }
                canPickOne = feasible;
            }
 
            if (canPickZero && !canPickOne) {
                U.push_back(0);
                zUsed++;
            } else if (!canPickZero && canPickOne) {
                U.push_back(1);
                oUsed++;
            } else if (canPickZero && canPickOne) {
                if (cZc > cOc) {
                    U.push_back(0);
                    zUsed++;
                } else if (cOc > cZc) {
                    U.push_back(1);
                    oUsed++;
                } else {
                    if ((Z - zUsed) < (O - oUsed)) {
                        U.push_back(0);
                        zUsed++;
                    } else {
                        U.push_back(1);
                        oUsed++;
                    }
                }
            } else {
                return {-1};
            }
        }
    }
 
    // Validate U with constraints.
    vector<int> zeroPositions, onePositions;
    zeroPositions.reserve(Z);
    onePositions.reserve(O);
    for (int i = 0; i < (int)U.size(); i++) {
        if (U[i] == 0) zeroPositions.push_back(i);
        else onePositions.push_back(i);
    }
 
    for (int z = 0; z <= Z; z++) {
        int pos = (z == 0) ? -1 : zeroPositions[z-1];
        int onesRight = (int)onePositions.size() - (int)(std::lower_bound(onePositions.begin(), onePositions.end(), pos+1) - onePositions.begin());
        if (onesRight < cZ[z]) {
            return {-1};
        }
    }
 
    for (int w = 0; w <= O; w++) {
        int pos = (w == 0) ? -1 : onePositions[w-1];
        int zerosRight = (int)zeroPositions.size() - (int)(std::lower_bound(zeroPositions.begin(), zeroPositions.end(), pos+1) - zeroPositions.begin());
        if (zerosRight < cO[w]) {
            return {-1};
        }
    }
 
    auto isSubsequence = [&](const std::vector<int> &C, const std::vector<int> &X) {
        int idx = 0;
        for (int i = 0; i < (int)X.size() && idx < (int)C.size(); i++) {
            if (X[i] == C[idx]) idx++;
        }
        return idx == (int)C.size();
    };
 
    if (!isSubsequence(U, A) || !isSubsequence(U, B)) {
        return {-1};
    }
 
    return U;
}
\end{lstlisting}
