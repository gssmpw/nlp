\subsection{Mosaic}
A total of 42 points were scored on Mosaic across two separate submissions.

\subsubsection{Submission 1}
The first submission achieved a score of 22 out of 100, with points distributed across subtasks 1, 2, and 4.

\begin{lstlisting}[language=C++]
#include "mosaic.h"
#include <bits/stdc++.h>
using namespace std;
 
std::vector<long long> mosaic(std::vector<int> X, std::vector<int> Y,
                              std::vector<int> T, std::vector<int> B,
                              std::vector<int> L, std::vector<int> R)
{
    int N = X.size();
    int Q = T.size();
    if(N == 0) {
        return vector<long long>(Q, 0LL);
    }
 
    // Step 1: fill A (N*N array, store as char 0/1)
    vector<unsigned char> A;
    A.resize((size_t)N * (size_t)N);
    // fill top row
    for(int j=0; j<N; j++) {
        A[0*N + j] = X[j];
    }
    // fill left column
    for(int i=0; i<N; i++) {
        A[i*N + 0] = Y[i];
    }
    // fill rest
    for(int i=1; i<N; i++) {
        for(int j=1; j<N; j++) {
            A[i*N + j] = (1 - A[(i-1)*N + j]) * (1 - A[i*N + j-1]);
        }
    }
 
    // Step 2: compute prefix sums in P (N+1)*(N+1) array
    vector<int> P;
    P.resize((size_t)(N+1) * (size_t)(N+1));
    // initialize P with 0's
    std::fill(P.begin(), P.end(), 0);
 
    for(int i=0; i<N; i++) {
        int baseRow = (i+1)*(N+1);
        int prevRow = i*(N+1);
        for(int j=0; j<N; j++) {
            P[baseRow + (j+1)] = P[prevRow + (j+1)] + P[baseRow + j] - P[prevRow + j] + (A[i*N + j]);
        }
    }
 
    // Step 3: answer queries using P
    vector<long long> C;
    C.resize(Q);
    for(int k=0; k<Q; k++) {
        int top = T[k];
        int bottom = B[k];
        int left = L[k];
        int right = R[k];
        long long blackCount = (long long)P[(bottom+1)*(N+1) + (right+1)]
            - (long long)P[(top)*(N+1) + (right+1)]
            - (long long)P[(bottom+1)*(N+1) + left]
            + (long long)P[(top)*(N+1) + left];
        C[k] = blackCount;
    }
 
    return C;
}
\end{lstlisting}

\subsubsection{Submission 2}
The model scored 20 points in the second submission on subtasks 1, 3, and 5.
\begin{lstlisting}[language=C++]
#include "mosaic.h"
#include <bits/stdc++.h>
using namespace std;
 
// We'll implement the mosaic function as specified.
std::vector<long long> mosaic(std::vector<int> X, std::vector<int> Y,
                              std::vector<int> T, std::vector<int> B,
                              std::vector<int> L, std::vector<int> R)
{
    int N = X.size();
    int Q = T.size();
 
    // If N=1, the mosaic is just tile(0,0), queries are easy.
    if (N == 1) {
        vector<long long> result(Q);
        for (int q = 0; q < Q; q++) {
            // subrectangle T..B x L..R is always T=0,B=0,L=0,R=0 if we have queries.
            if (T[q] == 0 && B[q] == 0 && L[q] == 0 && R[q] == 0) {
                // black tile count is 1 if X[0]=1 or Y[0]=1, and X[0]=Y[0], else 0.
                // The problem states X[0] = Y[0], so tile(0,0) is black if X[0]=1.
                if (X[0] == 1) result[q] = 1; else result[q] = 0;
            } else {
                // no other queries are possible if N=1, but if they are, the subrectangle is empty or out of range.
                result[q] = 0;
            }
        }
        return result;
    }
 
    // Precompute prefix sums for X and Y.
    vector<long long> prefixX(N+1, 0), prefixY(N+1, 0);
    for (int i = 1; i <= N; i++) {
        prefixX[i] = prefixX[i-1] + X[i-1];
        prefixY[i] = prefixY[i-1] + Y[i-1];
    }
 
    // Determine alpha mod 2 and beta mod 2 from tile(1,1).
    // C[1,1] = 1 if X[1] and Y[1] are 0, else 0.
    int c11 = 0;
    if (N > 1) {
        if (X.size() > 1 && Y.size() > 1 && X[1] == 0 && Y[1] == 0) c11 = 1; else c11 = 0;
    } else {
        c11 = 0; // but N=1 scenario is handled above.
    }
 
    int alphaMod2, betaMod2;
    if (c11 == 1) {
        alphaMod2 = 0;
        betaMod2 = 0;
    } else {
        alphaMod2 = 0;
        betaMod2 = 1;
    }
 
    // define functions to count even and odd in a range.
    auto countEvenInRange = [&](int a, int b){
        if (b < a) return 0LL;
        long long A = a; long long B = b;
        long long evenCount = ((long long)B + 2) / 2 - ((long long)A + 1) / 2;
        return evenCount;
    };
 
    auto countOddInRange = [&](int a, int b){
        if (b < a) return 0LL;
        long long A = a; long long B = b;
        long long oddCount = ((long long)B + 1) / 2 - (long long)A / 2;
        return oddCount;
    };
 
    // Now for each query, compute the black tile count.
    std::vector<long long> result(Q);
    for (int q = 0; q < Q; q++) {
        long long t = T[q];
        long long b = B[q];
        long long l = L[q];
        long long r = R[q];
 
        long long count = 0;
 
        // if T=0, add black tile from row0 and columns L..R.
        if (t == 0 && r >= l) {
            long long sumRow0 = prefixX[r+1] - prefixX[(int)l]; // sum of X[L..R]
            count += sumRow0;
        }
 
        // if L=0, add black tile from column0 and rows T..B.
        if (l == 0 && b >= t) {
            long long sumCol0 = prefixY[b+1] - prefixY[(int)t]; // sum of Y[T..B]
            count += sumCol0;
        }
 
        // if T=0 and L=0, subtract tile(0,0) if black.
        if (t == 0 && l == 0 && r >= 0 && b >= 0) {
            if (X[0] == 1) {
                count -= 1;
            }
        }
 
        // add black tile from the interior submatrix T'=max(T,1)..B x L'=max(L,1)..R.
        int Tprime = max((int)t, 1);
        int Lprime = max((int)l, 1);
        if (Tprime <= b && Lprime <= r) {
            long long evenI = countEvenInRange(Tprime, (int)b);
            long long oddI = countOddInRange(Tprime, (int)b);
            long long evenJ = countEvenInRange(Lprime, (int)r);
            long long oddJ = countOddInRange(Lprime, (int)r);
 
            long long interiorCount = 0;
            if (alphaMod2 == betaMod2) {
                // black tile appear when i%
                interiorCount = evenI * evenJ + oddI * oddJ;
            } else {
                // black tile appear when i%
                interiorCount = evenI * oddJ + oddI * evenJ;
            }
            count += interiorCount;
        }
 
        result[q] = count;
    }
 
    return result;
}
\end{lstlisting}
