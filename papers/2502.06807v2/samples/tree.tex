\subsection{Tree}
A total of 30 points were scored on Tree across two separate submissions.

\subsubsection{Submission 1}
The first submission achieved a score of 17 out of 100, with points earned from subtasks 1 and 4.

\begin{lstlisting}[language=C++]
#include "tree.h"
#include <bits/stdc++.h>
using namespace std;
 
static int NGlobal;
static vector<int> parentGlobal;
static vector<int> weightGlobal;
static vector<long long> deltaGlobal;
static vector<int> leafCountGlobal;
static vector<int> sortedByLeafCount; // We'll store node indices sorted by leaf count.
static vector<long long> prefixDelta, prefixDeltaTimesLeafCount; // prefix sums in sorted order by leaf count.
static long long sumAllDelta;
static vector<vector<int>> childrenGlobal;
 
int computeLeafCountRec(int v){
    if (childrenGlobal[v].empty()){ // leaf
        leafCountGlobal[v] = 1;
        return 1;
    } else {
        int sum = 0;
        for (int c : childrenGlobal[v]) sum += computeLeafCountRec(c);
        leafCountGlobal[v] = sum;
        return sum;
    }
}
 
void init(std::vector<int> P, std::vector<int> W){
    int N = (int)P.size();
    NGlobal = N;
    parentGlobal = P;
    weightGlobal = W;
    if (N == 0) return;
 
    childrenGlobal.assign(N, {});
    for (int i=1; i < N; i++) childrenGlobal[parentGlobal[i]].push_back(i);
 
    leafCountGlobal.resize(N);
    computeLeafCountRec(0);
 
    vector<int> deg(N,0);
    for (int i=1; i < N; i++) deg[parentGlobal[i]]++;
    deltaGlobal.resize(N);
    for (int i=0; i < N; i++){
        if (parentGlobal[i] == -1){ // root
            if (deg[i] == 0) { // leaf root
                deltaGlobal[i] = weightGlobal[i];
            } else { // internal root
                deltaGlobal[i] = - (long long)weightGlobal[i];
            }
        } else {
            if (deg[i] == 0) { // leaf
                deltaGlobal[i] = (long long)weightGlobal[parentGlobal[i]] + (long long)weightGlobal[i];
            } else { // internal
                deltaGlobal[i] = (long long)weightGlobal[parentGlobal[i]] - (long long)weightGlobal[i];
            }
        }
    }
 
    sortedByLeafCount.resize(N);
    iota(sortedByLeafCount.begin(), sortedByLeafCount.end(), 0);
    sort(sortedByLeafCount.begin(), sortedByLeafCount.end(), [](int a, int b){
        return leafCountGlobal[a] < leafCountGlobal[b];
    });
    prefixDelta.resize(N,0);
    prefixDeltaTimesLeafCount.resize(N,0);
    sumAllDelta = 0;
    for (int i=0; i < N; i++) sumAllDelta += deltaGlobal[i];
    long long runningDeltaTimesLeaf = 0;
    long long runningDelta = 0;
    for (int i=0; i < N; i++){
        int idx = sortedByLeafCount[i];
        long long valDeltaTimesLeaf = deltaGlobal[idx] * (long long)leafCountGlobal[idx];
        runningDeltaTimesLeaf += valDeltaTimesLeaf;
        runningDelta += deltaGlobal[idx];
        prefixDeltaTimesLeafCount[i] = runningDeltaTimesLeaf;
        prefixDelta[i] = runningDelta;
    }
}
 
long long query(int L, int R){
    if (NGlobal == 0) return 0; // no nodes
    long long a = R / L; // floor of R/L.
 
    int left = -1;
    int right = NGlobal;
    while (right - left > 1){
        int mid = (left + right)/2;
        int node = sortedByLeafCount[mid];
        if ((long long)leafCountGlobal[node] <= a) left = mid; else right = mid;
    }
    int idx = left; // idx is the last index where b[i] <= a.
 
    long long sumA = 0; // sum of delta[i]*b[i] for nodes with b[i] <= a.
    if (idx >= 0) {
        sumA = prefixDeltaTimesLeafCount[idx]; // sum_{i: b[i] <= a} delta[i]*b[i]
    }
 
    long long sumPrefixDeltaWhereLessOrEqual = 0;
    if (idx >= 0) sumPrefixDeltaWhereLessOrEqual = prefixDelta[idx]; else sumPrefixDeltaWhereLessOrEqual = 0;
    long long sumDeltaWhereBGreater = sumAllDelta - sumPrefixDeltaWhereLessOrEqual;
 
    long long LLL = (long long)L;
    long long RRR = (long long)R;
 
    long long partA = LLL * sumA;
    long long partB = RRR * sumDeltaWhereBGreater;
 
    long long cost = partA + partB;
 
    return cost;
}
\end{lstlisting}

\subsubsection{Submission 2}
Submission 2 achieved 13 of 100 points on subtask 2.
\begin{lstlisting}[language=C++]
#include "tree.h"
#include <bits/stdc++.h>
using namespace std;
struct Pt {
    long long x;
    long long y;
};
struct PWL {
    long long L, R;
    vector<Pt> pts; // sorted by x
};
int NGlobal;
int PGlobal[2005];
int wGlobal[2005];
vector<int> childrenGlobal[2005];
PWL GGlobal[2005];
 
// define the helper functions as static.
 
static long long evalPWL(const PWL &f, long long x) {
    if (f.pts.empty()) return LLONG_MAX/2; // no function
    if (x <= f.pts.front().x) {
        return f.pts.front().y; // domain out, but we prefer front.
    }
    if (x >= f.pts.back().x) {
        return f.pts.back().y; // domain out, but prefer back.
    }
 
    int left = 0, right = f.pts.size()-1;
    while (left+1 < right) {
        int mid = (left + right) / 2;
        if (f.pts[mid].x == x) return f.pts[mid].y;
        if (f.pts[mid].x < x) left = mid; else right = mid;
    }
    if (f.pts[left].x <= x && x <= f.pts[right].x) {
        long long x1 = f.pts[left].x;
        long long y1 = f.pts[left].y;
        long long x2 = f.pts[right].x;
        long long y2 = f.pts[right].y;
        if (x1 == x2) return y1;
        long double slope = (long double)(y2 - y1)/(long double)(x2 - x1);
        long double valf = (long double) y1 + slope*(x - x1);
        long long vali = (long long) llround(valf);
        return vali;
    } else {
        return LLONG_MAX/2;
    }
}
struct ChildState {
    int idx; // child index in local array
    long long x; // current x in child's domain
    int seg; // segment in child's function
    long double slope;
    long long nextBound;
};
 
static PWL combineChildren(const vector<PWL> &childF, long long L, long long R) {
    int d = childF.size();
    if (d == 0) {
        PWL f; f.L = L; f.R = R; f.pts = {{L, 0}, {R, 0}}; return f;
    }
    long long sumDomainL = (long long)d * L;
    long long sumDomainR = (long long)d * R;
 
    vector<ChildState> cs(d);
    priority_queue<pair<long double, int>, vector<pair<long double, int>>, greater<pair<long double, int>>> pq;
 
    for (int i = 0; i < d; i++) {
        cs[i].idx = i;
        cs[i].x = L;
        int seg = 0; int n = childF[i].pts.size();
        while (seg < n-1 && childF[i].pts[seg+1].x <= L) seg++;
        cs[i].seg = seg;
        long double slope = 0;
        if (seg+1 < n) {
            long long dx = childF[i].pts[seg+1].x - childF[i].pts[seg].x;
            long long dy = childF[i].pts[seg+1].y - childF[i].pts[seg].y;
            slope = dx!=0?(long double)dy/dx:0;
        } else {
            slope = 0;
        }
        cs[i].slope = slope;
        if (seg+1 < n) cs[i].nextBound = min((long long)childF[i].pts[seg+1].x, R);
        else cs[i].nextBound = R;
        pq.push({slope, i});
    }
 
    long long sum = sumDomainL;
    long long cost = 0;
    for (int i = 0; i < d; i++) {
        cost += evalPWL(childF[i], L);
    }
 
    vector<Pt> fpts;
    fpts.push_back({sum, cost});
 
    while (!pq.empty() && sum < sumDomainR) {
        auto top = pq.top();
        long double slope = top.first;
        vector<int> group;
        while (!pq.empty() && abs(pq.top().first - slope) < 1e-9) {
            group.push_back(pq.top().second);
            pq.pop();
        }
        if (group.empty()) break;
 
        long long inc = LLONG_MAX;
        for (int idx : group) {
            long long newInc = cs[idx].nextBound - cs[idx].x;
            if (newInc < inc) inc = newInc;
        }
        if (inc <= 0) {
            for (int idx : group) {
                pq.push({cs[idx].slope, idx});
            }
            break;
        }
        long long feasibleInc = inc;
        if (sum + (long long)group.size() * inc > sumDomainR) {
            feasibleInc = (sumDomainR - sum) / (long long) group.size();
        }
        if (feasibleInc <= 0) {
            for (int idx : group) {
                pq.push({cs[idx].slope, idx});
            }
            break;
        }
 
        sum = sum + group.size() * feasibleInc;
        long double dcost = slope * feasibleInc * group.size();
        cost = (long long) llround((long double)cost + dcost);
 
        fpts.push_back({sum, cost});
 
        for (int idx : group) {
            cs[idx].x += feasibleInc;
            if (cs[idx].x == cs[idx].nextBound) {
                const PWL &g = childF[idx];
                int seg = cs[idx].seg;
                if (cs[idx].x == R) {
                    cs[idx].slope = 1e9; // saturate
                    cs[idx].nextBound = R;
                } else {
                    seg++;
                    cs[idx].seg = seg;
                    int n = g.pts.size();
                    if (seg+1 < n) {
                        long long dx = g.pts[seg+1].x - g.pts[seg].x;
                        long long dy = g.pts[seg+1].y - g.pts[seg].y;
                        long double slopeC = dx!=0?(long double)dy/dx:0;
                        cs[idx].slope = slopeC;
                        cs[idx].nextBound = min((long long)g.pts[seg+1].x, R);
                    } else {
                        cs[idx].slope = 0;
                        cs[idx].nextBound = R;
                    }
                }
            }
        }
        for (int idx : group) {
            if (cs[idx].x < R) {
                pq.push({cs[idx].slope, idx});
            }
        }
    }
 
    vector<Pt> unify;
    unify.push_back(fpts[0]);
    for (int i = 1; i < fpts.size(); i++) {
        if (fpts[i].x == unify.back().x) {
            unify.back().y = min(unify.back().y, fpts[i].y);
        } else unify.push_back(fpts[i]);
    }
 
    vector<Pt> final;
    if (!unify.empty()) final.push_back(unify[0]);
    for (int i = 1; i < unify.size()-1; i++) {
        long long x1 = final.back().x;
        long long y1 = final.back().y;
        long long x2 = unify[i].x;
        long long y2 = unify[i].y;
        long long x3 = unify[i+1].x;
        long long y3 = unify[i+1].y;
        long double slope1 = (x2!=x1)? (long double)(y2-y1)/(x2-x1) : 1e9;
        long double slope2 = (x3!=x2)? (long double)(y3-y2)/(x3-x2) : 1e9;
        if (abs(slope1 - slope2) < 1e-9) {
            // unify linear, skip unify[i]
        } else {
            final.push_back(unify[i]);
        }
    }
    if (!unify.empty()) final.push_back(unify.back());
 
    PWL result;
    result.L = sumDomainL; result.R = sumDomainR;
    result.pts = final;
 
    return result;
}
 
static PWL parentFormula(const PWL &f, long long wVal, long long L, long long R) {
    vector<long long> candVal;
    candVal.push_back(L);
    candVal.push_back(R);
    for (auto &p : f.pts) {
        if (p.x >= L && p.x <= R) candVal.push_back(p.x);
    }
    if (f.L >= L && f.L <= R) candVal.push_back(f.L);
    if (f.R >= L && f.R <= R) candVal.push_back(f.R);
 
    for (int i = 0; i < (int)f.pts.size()-1; i++) {
        long long sx = f.pts[i].x;
        long long sy = f.pts[i+1].x;
        long long dx = sy - sx;
        long long dy = f.pts[i+1].y - f.pts[i].y;
        long double a = dx!=0? (long double)dy/dx:0; // slope in s domain
        if (a <= wVal && a >= -wVal) {
            long long inL = max(sx, (long long)L);
            long long inR = min(sy, (long long)R);
            if (inL <= inR) {
                candVal.push_back(inL);
                candVal.push_back(inR);
            }
        }
    }
 
    sort(candVal.begin(), candVal.end());
    candVal.erase(unique(candVal.begin(), candVal.end()), candVal.end());
 
    vector<Pt> pts;
    for (auto val : candVal) {
        long long bestCost = LLONG_MAX/2;
        if (val >= f.L && val <= f.R) {
            int left = 0, right = f.pts.size()-1;
            while (left+1 < right) {
                int mid = (left + right) / 2;
                if (f.pts[mid].x <= val) left = mid; else right = mid;
            }
            if (f.pts[left].x <= val && val <= f.pts[right].x) {
                long long x1 = f.pts[left].x;
                long long y1 = f.pts[left].y;
                long long x2 = f.pts[right].x;
                long long y2 = f.pts[right].y;
                long double slope = (x2!=x1? (long double)(y2 - y1)/(long double)(x2 - x1) : 0);
                if (slope <= wVal && slope >= -wVal && val >= x1 && val <= x2) {
                    long double costf = (long double) y1 + slope * (long double)(val - x1);
                    long long c = (long long) llround(costf);
                    bestCost = min(bestCost, c);
                }
            }
        }
        for (auto &p : f.pts) {
            long long s = p.x;
            long long c = p.y + wVal * llabs(val - s);
            if (c < bestCost) bestCost = c;
        }
        pts.push_back({val, bestCost});
    }
 
    sort(pts.begin(), pts.end(), [](const Pt &a, const Pt &b){return a.x < b.x;});
 
    vector<Pt> unify;
    unify.push_back(pts[0]);
    for (int i = 1; i < pts.size(); i++) {
        if (pts[i].x == unify.back().x) {
            unify.back().y = min(unify.back().y, pts[i].y);
        } else unify.push_back(pts[i]);
    }
 
    vector<Pt> final;
    if (!unify.empty()) final.push_back(unify[0]);
    for (int i = 1; i < unify.size()-1; i++) {
        long long x1 = final.back().x;
        long long y1 = final.back().y;
        long long x2 = unify[i].x;
        long long y2 = unify[i].y;
        long long x3 = unify[i+1].x;
        long long y3 = unify[i+1].y;
        long double slope1 = x2!=x1? (long double)(y2-y1)/(x2-x1) : 1e9;
        long double slope2 = x3!=x2? (long double)(y3-y2)/(x3-x2) : 1e9;
        if (abs(slope1 - slope2) < 1e-9) {
            // unify linear, skip unify[i]
        } else {
            final.push_back(unify[i]);
        }
    }
    if (!unify.empty()) final.push_back(unify.back());
 
    PWL result;
    result.L = L; result.R = R;
    result.pts = final;
 
    return result;
}
 
static void computeG(int node, long long L, long long R) {
    for (int c : childrenGlobal[node]) {
        computeG(c, L, R);
    }
    if (childrenGlobal[node].empty()) {
        // leaf
        PWL result;
        result.L = L; result.R = R;
        if (L <= 0 && 0 <= R) {
            long long valL = wGlobal[node] * llabs(L);
            long long val0 = wGlobal[node] * 0; // 0
            long long valR = wGlobal[node] * llabs(R);
            result.pts.clear();
            result.pts.push_back({L, valL});
            result.pts.push_back({0, val0});
            result.pts.push_back({R, valR});
        } else {
            long long valL = wGlobal[node] * llabs(L);
            long long valR = wGlobal[node] * llabs(R);
            result.pts.clear();
            result.pts.push_back({L, valL});
            result.pts.push_back({R, valR});
        }
        GGlobal[node] = result;
    } else {
        vector<PWL> childF;
        for (int c : childrenGlobal[node]) {
            childF.push_back(GGlobal[c]);
        }
        PWL f = combineChildren(childF, L, R);
        PWL p = parentFormula(f, wGlobal[node], L, R);
        GGlobal[node] = p;
    }
}
 
void init(std::vector<int> P, std::vector<int> W) {
    NGlobal = W.size();
    for (int i = 0; i < NGlobal; i++) {
        PGlobal[i] = P[i];
        wGlobal[i] = W[i];
    }
    for (int i = 0; i < NGlobal; i++) childrenGlobal[i].clear();
    for (int i = 1; i < NGlobal; i++) {
        childrenGlobal[P[i]].push_back(i);
    }
}
 
long long query(int L, int R) {
    computeG(0, L, R);
    long long ans = LLONG_MAX;
    for (auto &p : GGlobal[0].pts) {
        if (p.y < ans) ans = p.y;
    }
    return ans;
}
\end{lstlisting}
