\subsection{Nile}
All 100 possible points for Nile were scored in a single submission.

\begin{lstlisting}[language=C++]
#include "nile.h"
#include <bits/stdc++.h>
using namespace std;
 
struct UF{
    vector<int> parent, sizee, minIndex;
    vector<array<long long, 2>> singledPat; // singledPat[0] = min d[i] for i mod 2 = 0 in block, singledPat[1] for i mod 2 = 1 in block
    vector<long long> singledBr; // singled bridging
    vector<long long> singled; // singled in block
};
 
long long sumSingledGlobal = 0;
 
int findRoot(UF &u, int x){
    if(u.parent[x] == x) return x;
    u.parent[x] = findRoot(u, u.parent[x]);
    return u.parent[x];
}
 
void updateSingled(UF &u, int r){
    if(u.sizee[r] %
        u.singled[r] = 0;
    } else {
        long long val = min(u.singledPat[r][u.minIndex[r] %
        if(val == LLONG_MAX) val = 0; // if no such node found, singled = 0?
        u.singled[r] = val;
    }
}
 
void unionNodes(UF &u, int a, int b){
    a = findRoot(u, a);
    b = findRoot(u, b);
    if(a == b) return; // already in the same component
 
    sumSingledGlobal -= u.singled[a];
    sumSingledGlobal -= u.singled[b];
 
    // union by size
    if(u.sizee[a] < u.sizee[b]) swap(a, b);
    u.parent[b] = a;
 
    int newSize = u.sizee[a] + u.sizee[b];
    int newMinIndex = min(u.minIndex[a], u.minIndex[b]);
 
    array<long long, 2> newSingledPat;
    newSingledPat[0] = min(u.singledPat[a][0], u.singledPat[b][0]);
    newSingledPat[1] = min(u.singledPat[a][1], u.singledPat[b][1]);
 
    long long newSingledBr = min(u.singledBr[a], u.singledBr[b]);
 
    u.sizee[a] = newSize;
    u.minIndex[a] = newMinIndex;
    u.singledPat[a] = newSingledPat;
    u.singledBr[a] = newSingledBr;
 
    updateSingled(u, a);
 
    sumSingledGlobal += u.singled[a];
}
 
void addBridging(UF &u, int x, long long val){
    int r = findRoot(u, x);
    sumSingledGlobal -= u.singled[r];
    if(u.sizee[r] %
        u.singledBr[r] = min(u.singledBr[r], val);
        updateSingled(u, r);
    } else {
        // block size is even, singled = 0 anyway, bridging won't matter because singledBr is for odd sized block.
        // but bridging might matter if block size becomes odd in future merges, so store singledBr as well.
        u.singledBr[r] = min(u.singledBr[r], val);
        // singled is 0 anyway
    }
    sumSingledGlobal += u.singled[r];
}
 
std::vector<long long> calculate_costs(
    std::vector<int> W, std::vector<int> A,
    std::vector<int> B, std::vector<int> E){
 
    int N = W.size();
    int Q = E.size();
 
    vector<int> idx(N); iota(idx.begin(), idx.end(), 0);
    sort(idx.begin(), idx.end(), [&](int a, int b){return W[a] < W[b];});
 
    vector<long long> sortedW(N), d(N);
    for(int i = 0; i < N; i++) {
        sortedW[i] = W[idx[i]];
        d[i] = (long long)A[idx[i]] - (long long)B[idx[i]];
    }
 
    long long sumB = 0;
    for(int i = 0; i < N; i++) sumB += B[idx[i]];
 
    struct Edge{ long long diff; int idx;};
    vector<Edge> edges;
    edges.reserve(N-1);
    for(int i = 0; i < N-1; i++) {
        edges.push_back({sortedW[i+1] - sortedW[i], i});
    }
    sort(edges.begin(), edges.end(), [&](const Edge &a, const Edge &b){return a.diff < b.diff;});
 
    vector<pair<long long, int>> bridging;
    bridging.reserve(N-2);
    for(int i = 1; i < N-1; i++) {
        long long val = sortedW[i+1] - sortedW[i-1];
        bridging.push_back({val, i});
    }
    sort(bridging.begin(), bridging.end(), [&](auto &a, auto &b){return a.first < b.first;});
 
    vector<pair<long long, int>> queriesVec;
    queriesVec.reserve(Q);
    for(int i = 0; i < Q; i++) queriesVec.push_back({(long long)E[i], i});
    sort(queriesVec.begin(), queriesVec.end(), [&](auto &a, auto &b){return a.first < b.first;});
 
    UF u;
    u.parent.resize(N);
    u.sizee.resize(N);
    u.minIndex.resize(N);
    u.singledPat.resize(N);
    u.singledBr.resize(N);
    u.singled.resize(N);
 
    for(int i = 0; i < N; i++) {
        u.parent[i] = i;
        u.sizee[i] = 1;
        u.minIndex[i] = i;
        u.singledPat[i][0] = (i %
        u.singledPat[i][1] = (i %
        u.singledBr[i] = LLONG_MAX;
        u.singled[i] = d[i]; // singled = d[i] because block size 1 is odd
    }
 
    sumSingledGlobal = 0;
    for(int i = 0; i < N; i++) {
        sumSingledGlobal += u.singled[i];
    }
 
    vector<long long> result(Q);
 
    int posE = 0; // index in edges
    int posB = 0; // index in bridging
 
    for(int i = 0; i < Q; i++) {
        long long D = queriesVec[i].first;
        int qidx = queriesVec[i].second;
 
        while(posE < (int)edges.size() && edges[posE].diff <= D) {
            unionNodes(u, edges[posE].idx, edges[posE].idx+1);
            posE++;
        }
 
        while(posB < (int)bridging.size() && bridging[posB].first <= D) {
            int x = bridging[posB].second;
            addBridging(u, x, d[x]);
            posB++;
        }
 
        long long costVal = sumB + sumSingledGlobal;
        result[qidx] = costVal;
    }
 
    return result;
}
\end{lstlisting}
