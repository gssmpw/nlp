\subsection{Message}
This solution achieved a score of 79.64 out of 100, with full marks awarded for subtask 1 and partial credit received for subtask 2.

\begin{lstlisting}[language=C++]
#include "message.h"
#include <bits/stdc++.h>
using namespace std;
 
extern std::vector<bool> send_packet(std::vector<bool> A);
 
void send_message(std::vector<bool> M, std::vector<bool> C)
{
    vector<int> safe_cols;
    vector<int> sabotage_cols;
    for (int i = 0; i < 31; i++) {
        if (!C[i]) safe_cols.push_back(i);
        else sabotage_cols.push_back(i);
    }
 
    // Step 1: send the first 4 packets with distinct sequences.
    vector<vector<bool>> first4results;
    first4results.reserve(4);
    for (int p = 0; p < 4; p++) {
        vector<bool> A(31, false);
        for (int i = 0; i < 16; i++) {
            int col = safe_cols[i];
            int bit = (i >> p) & 1; // p-th bit of i, i is the index in safe subset
            A[col] = bit;
        }
        for (int col : sabotage_cols) {
            A[col] = false;
        }
        std::vector<bool> B = send_packet(A);
        first4results.push_back(B);
    }
 
    // Now identify known safe column from the results of these 4 calls.
    vector<string> colSequences(31, string(4, '0'));
    for (int c = 0; c < 31; c++) {
        for (int r = 0; r < 4; r++) {
            colSequences[c][r] = first4results[r][c] ? '1' : '0';
        }
    }
 
    map<string, vector<int>> seqToCols;
    for (int c = 0; c < 31; c++) {
        seqToCols[colSequences[c]].push_back(c);
    }
    int knownSafeCol = -1;
    for (auto &kv : seqToCols) {
        if (kv.second.size() == 1) {
            int col = kv.second[0];
            // check if col is in safe subset. Because known safe column must be a safe column.
            if (find(safe_cols.begin(), safe_cols.end(), col) != safe_cols.end()) {
                // also check if the sequence is one of the distinct sequences for safe subset. The index in the safe subset is i, the sequence is 4 bits representing i.
                string seq = kv.first;
                int val = 0;
                for (int i = 0; i < 4; i++) {
                    if (seq[i] == '1') val |= (1 << i);
                }
                // check if val is < 16.
                if (val < 16) {
                    knownSafeCol = col;
                    break;
                }
            }
        }
    }
    if (knownSafeCol == -1) {
        // If not found, pick a safe column that has a distinct sequence anyway.
        // But for correctness, we require knownSafeCol to be found. If not found, our method has a problem.
    }
 
    // Step 2: store sabotage subset's bits in the known safe column in next 31 calls. The other 15 safe columns store message bits if available.
    int S = M.size(); // message length.
    int offset = 0; // offset in M.
    for (int i = 0; i < 31; i++) {
        vector<bool> A(31, false);
        int sabotageBit = C[i];
        A[knownSafeCol] = sabotageBit; // store sabotage subset's bit i in known safe column.
        for (int c : safe_cols) {
            if (c == knownSafeCol) continue; // skip known safe column because we used it for sabotage subset.
            int col = c;
            if (offset < S) {
                A[col] = M[offset];
                offset++;
            } else {
                A[col] = false;
            }
        }
        for (int sc : sabotage_cols) {
            A[sc] = false;
        }
        std::vector<bool> B = send_packet(A);
        // We do not store B because we do not need to adapt further. Actually, we can store B if we want to adapt but the solution does not require further adaptation.
    }
 
    // Step 3: store message length in the next 11 calls in the known safe column. The other 15 safe columns store more message bits if available.
    int L = S; // length in integer form.
    vector<int> lengthBinary(11, 0);
    for (int i = 0; i < 11; i++) {
        lengthBinary[i] = (L >> i) & 1;
    }
 
    for (int i = 0; i < 11; i++) {
        vector<bool> A(31, false);
        int bit = lengthBinary[i];
        A[knownSafeCol] = bit; // store length bit i in known safe column.
        for (int c : safe_cols) {
            if (c == knownSafeCol) continue; // skip known safe column.
            int col = c;
            if (offset < S) {
                A[col] = M[offset];
                offset++;
            } else {
                A[col] = false;
            }
        }
        for (int sc : sabotage_cols) {
            A[sc] = false;
        }
        std::vector<bool> B = send_packet(A);
    }
 
    // Step 4: store the rest of the message in subsequent calls using all 16 safe columns.
    int messageLeft = S - offset; // how many bits are left to store.
    int fullColumns = 16; // number of safe columns.
    int messageRows = (messageLeft + fullColumns - 1) / fullColumns; // how many rows needed.
 
    for (int r = 0; r < messageRows; r++) {
        vector<bool> A(31, false);
        for (int i = 0; i < fullColumns && offset + i < S; i++) {
            int col = safe_cols[i];
            A[col] = M[offset + i];
        }
        offset += fullColumns;
        for (int sc : sabotage_cols) {
            A[sc] = false;
        }
        std::vector<bool> B = send_packet(A);
    }
 
}
 
std::vector<bool> receive_message(std::vector<std::vector<bool>> R)
{
    int n = R.size();
    vector<bool> result; // message to return.
    if (n < 4) {
        return result;
    }
 
    // Step 1: from the first 4 rows in R, find the known safe column.
    vector<string> colSequences(31, string(4, '0'));
    for (int c = 0; c < 31; c++) {
        for (int r = 0; r < 4 && r < n; r++) {
            if (r < n) {
                colSequences[c][r] = R[r][c] ? '1' : '0';
            }
        }
    }
 
    map<string, vector<int>> seqToCols;
    for (int c = 0; c < 31; c++) {
        seqToCols[colSequences[c]].push_back(c);
    }
    int knownSafeCol = -1;
    for (auto &kv : seqToCols) {
        if (kv.second.size() == 1) {
            int col = kv.second[0];
            // check if the sequence is one of the binary representations from 0..15 because safe subset's sequences are distinct and in that range.
            string seq = kv.first;
            int val = 0;
            for (int i = 0; i < 4; i++) {
                if (seq[i] == '1') val |= (1 << i);
            }
            if (val < 16) {
                knownSafeCol = col;
                break;
            }
        }
    }
    if (knownSafeCol == -1) {
        // If none found, that means sabotage overcame the method or we made an error.
    }
 
    // Step 2: from next 31 rows in known safe column, read sabotage subset.
    vector<bool> sabotageSubset(31, false);
    int sabotageStart = 4;
    for (int i = 0; i < 31 && sabotageStart + i < n; i++) {
        sabotageSubset[i] = R[sabotageStart + i][knownSafeCol];
    }
 
    // Step 3: from next 11 rows in known safe column, read length.
    vector<bool> lengthBits(11, false);
    int lengthStart = sabotageStart + 31;
    for (int i = 0; i < 11 && lengthStart + i < n; i++) {
        lengthBits[i] = R[lengthStart + i][knownSafeCol];
    }
    int messageLength = 0;
    for (int i = 0; i < 11; i++) {
        messageLength |= (lengthBits[i] << i);
    }
 
    // Step 4: identify safe columns from sabotage subset.
    vector<int> safe_cols;
    for (int i = 0; i < 31; i++) {
        if (!sabotageSubset[i]) safe_cols.push_back(i);
    }
 
    // Step 5: read message from the next (31 + 11) rows' other safe columns and from subsequent rows using all safe columns.
    vector<bool> message;
    int offset = 0; // offset in message.
    int sabotageRowStart = 4;
    int sabotageRows = 31;
    for (int r = sabotageRowStart; r < sabotageRowStart + sabotageRows && r < n; r++) {
        for (int c : safe_cols) {
            if (c == knownSafeCol) continue; // skip known safe column.
            if (offset < messageLength) {
                message.push_back(R[r][c]);
                offset++;
            }
        }
    }
 
    int lengthRowStart = sabotageRowStart + sabotageRows; // 4 + 31 = 35.
    int lengthRows = 11;
    for (int r = lengthRowStart; r < lengthRowStart + lengthRows && r < n; r++) {
        for (int c : safe_cols) {
            if (c == knownSafeCol) continue; // skip known safe column.
            if (offset < messageLength) {
                message.push_back(R[r][c]);
                offset++;
            }
        }
    }
 
    int restRowStart = lengthRowStart + lengthRows; // 4 + 31 + 11 = 46.
    int fullColumns = 16; // number of safe columns.
    int messageLeft = messageLength - offset;
 
    int rowsForMessage = (messageLeft + fullColumns - 1) / fullColumns; // number of rows needed.
    for (int r = restRowStart; r < restRowStart + rowsForMessage && r < n; r++) {
        for (int i = 0; i < fullColumns && offset < messageLength; i++) {
            int col = safe_cols[i];
            message.push_back(R[r][col]);
            offset++;
        }
    }
 
    // The message is now in vector message. If offset < messageLength, we did not get all bits. but we should.
    return message;
}
\end{lstlisting}
