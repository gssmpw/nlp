\subsection{Sphinx}
A total of 71.5 points were scored on Sphinx across two separate submissions.

\subsubsection{Submission 1}
The first submission achieved a score of 50 out of 100, with 50\% partial credit earned on all subtasks.

\begin{lstlisting}[language=C++]
#include "sphinx.h"
#include <bits/stdc++.h>
int perform_experiment(std::vector<int> E);
std::vector<int> find_colours(int Nx, std::vector<int> Xx, std::vector<int> Yx) {
    int N = Nx;
    std::vector<std::vector<int>> adj(N);
    int M = Xx.size();
    for (int i = 0; i < M; i++) {
        int u = Xx[i], v = Yx[i];
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
 
    struct UnionFind {
        std::vector<int> parent, rank;
        UnionFind(int n) : parent(n), rank(n, 0) {
            for (int i = 0; i < n; i++) parent[i] = i;
        }
        int findp(int x) {
            if (parent[x] == x) return x;
            parent[x] = findp(parent[x]);
            return parent[x];
        }
        void unite(int x, int y) {
            x = findp(x); y = findp(y);
            if (x == y) return;
            if (rank[x] < rank[y]) parent[x] = y;
            else if (rank[x] > rank[y]) parent[y] = x;
            else {parent[y] = x; rank[x]++;}
        }
    } uf(N);
 
    auto connectedComponentsInSubset = [&](const std::vector<int>& subset) {
        static std::vector<int> visited;
        visited.assign(N, -1);
        for (int v : subset) visited[v] = 0;
        int count = 0;
        for (int v : subset) if (visited[v] == 0) {
            count++;
            std::queue<int> q;
            q.push(v);
            visited[v] = 1;
            while(!q.empty()) {
                int u = q.front(); q.pop();
                for (int w : adj[u]) {
                    if (visited[w] == 0) {
                        visited[w] = 1;
                        q.push(w);
                    }
                }
            }
        }
        return count;
    };
 
    auto queryMonochromComps = [&](const std::vector<int>& S) {
        std::vector<int> Earr(N);
        static std::vector<int> visited2;
        visited2.assign(N, -1);
        std::vector<int> Sset(N, 0);
        for (int v : S) Sset[v] = 1;
        for (int i = 0; i < N; i++) Earr[i] = (Sset[i] == 1) ? -1 : N;
 
        int res = perform_experiment(Earr);
 
        std::vector<int> compInput; compInput.reserve(N - S.size());
        for (int i = 0; i < N; i++) if (Sset[i] == 0) compInput.push_back(i);
        int compCount = 0;
        if (!compInput.empty()) compCount = connectedComponentsInSubset(compInput);
        else compCount = 0;
 
        int monos = res - compCount;
        return monos;
    };
 
    std::vector<int> c(N+1, 0);
    c[0] = 0; // no vertices, #connectedComponents(0) = 0.
    for (int k = 1; k <= N; k++) {
        std::vector<int> S; S.reserve(k);
        for (int i = 0; i < k; i++) S.push_back(i);
        c[k] = queryMonochromComps(S);
    }
 
    for (int k = 1; k <= N; k++) {
        int v = k-1;
        int merges = c[k-1] + 1 - c[k];
        if (merges < 0) merges = 0; // safety.
 
        auto findMerges = [&](auto &self, std::vector<int>& roots, int merges) -> void {
            if (merges == 0) return;
            if (merges == (int)roots.size()) {
                for (int r : roots) {
                    uf.unite(v, r);
                }
                return;
            } else {
                if (roots.size() == merges) {
                    for (int r : roots) {
                        uf.unite(v, r);
                    }
                    return;
                } else {
                    int half = roots.size()/2;
                    std::vector<int> left(roots.begin(), roots.begin() + half);
                    std::vector<int> right(roots.begin() + half, roots.end());
 
                    std::vector<int> S2; S2.reserve(1 + v);
                    S2.push_back(v);
                    for (int r : left) {
                        for (int i = 0; i < v; i++) {
                            if (uf.findp(i) == r) {
                                S2.push_back(i);
                            }
                        }
                    }
 
                    std::vector<int> Earr(N);
                    std::vector<int> Sset2(N, 0);
                    for (int i : S2) Sset2[i] = 1;
                    for (int i = 0; i < N; i++) Earr[i] = (Sset2[i] == 1) ? -1 : N;
 
                    int res = perform_experiment(Earr);
 
                    std::vector<int> compInput; compInput.reserve(N - S2.size());
                    static std::vector<int> visited2; visited2.assign(N, -1);
                    for (int i = 0; i < N; i++) visited2[i] = 0;
                    for (int i : S2) visited2[i] = -1;
                    compInput.clear();
                    for (int i = 0; i < N; i++) if (visited2[i] == 0) compInput.push_back(i);
                    int compCount = 0;
                    if (!compInput.empty()) {
                        for (int ip : compInput) visited2[ip] = 0; // re-mark for BFS.
                        for (int ip : compInput) if (visited2[ip] == 0) {
                            compCount++;
                            std::queue<int> q;
                            q.push(ip);
                            visited2[ip] = 1;
                            while(!q.empty()) {
                                int u = q.front(); q.pop();
                                for (int w : adj[u]) {
                                    if (visited2[w] == 0) {
                                        visited2[w] = 1;
                                        q.push(w);
                                    }
                                }
                            }
                        }
                    } else compCount = 0;
 
                    int monos2 = res - compCount;
                    int mergesInLeft = left.size() + 1 - monos2;
 
                    self(self, left, mergesInLeft);
                    self(self, right, merges - mergesInLeft);
                }
            }
        };
 
        std::set<int> distinctRoots;
        for (int i = 0; i < v; i++) distinctRoots.insert(uf.findp(i));
        std::vector<int> rootsVec(distinctRoots.begin(), distinctRoots.end());
 
        findMerges(findMerges, rootsVec, merges);
    }
 
    std::vector<int> rootID(N, -1);
    std::vector<int> colorID(N, -1);
    int nextID = 0;
    for (int i = 0; i < N; i++) {
        int r = uf.findp(i);
        if (rootID[r] == -1) {
            rootID[r] = nextID++;
        }
        colorID[i] = rootID[r];
    }
 
    return colorID;
}
\end{lstlisting}


\subsubsection{Submission 2}
Submission 2 achieved 43 points on subtasks 1, 2, and 3.
\begin{lstlisting}[language=C++]
#include "sphinx.h"
#include <bits/stdc++.h>
using namespace std;
 
int perform_experiment(vector<int> E);
 
vector<int> find_colours(int N, vector<int> X, vector<int> Y) {
    // We'll store adjacency.
    vector<vector<int>> adj(N);
    vector<vector<bool>> adjMatrix(N, vector<bool>(N, false));
    for (int i = 0; i < (int)X.size(); i++) {
        int u = X[i];
        int v = Y[i];
        adj[u].push_back(v);
        adj[v].push_back(u);
        adjMatrix[u][v] = adjMatrix[v][u] = true;
    }
 
    vector<int> final_colors(N, -1);
    vector<int> unassigned; for (int i = 0; i < N; i++) unassigned.push_back(i);
 
    // define group testing functions.
    // function query_count_in_T: how many in T have color x.
    auto query_count_in_T = [&](const vector<int> &T, int x) {
        vector<int> E(N, x);
        vector<int> inT(N, 0);
        for (int v : T) {
            E[v] = -1;
            inT[v] = 1;
        }
 
        int R = perform_experiment(E);
 
        // number c of connected components in the rest.
        vector<int> complement;
        for (int i = 0; i < N; i++) if (!inT[i]) complement.push_back(i);
        // BFS for c.
        vector<int> visited(N, 0);
        int ccount = 0;
        for (int v : complement) {
            if (!visited[v]) {
                ccount++;
                stack<int> st;
                st.push(v);
                visited[v] = 1;
                while (!st.empty()) {
                    int node = st.top(); st.pop();
                    for (int nb : adj[node]) {
                        if (!inT[nb] && !visited[nb]) {
                            visited[nb] = 1;
                            st.push(nb);
                        }
                    }
                }
            }
        }
 
        int c = ccount;
 
        int countx = (int)T.size() - (R - c);
        return countx;
    };
 
    // function find vertices in T with color x.
    auto find_vertices_in_T_with_color_x = [&](vector<int> T, int x) {
        vector<int> result;
        vector<int> S = T;
        int count = query_count_in_T(S, x);
        while (count > 0) {
            int l = 0; int r = S.size() - 1;
            while (l < r) {
                int mid = (l + r) / 2;
                vector<int> part(S.begin() + l, S.begin() + mid + 1);
                int cpart = query_count_in_T(part, x);
                if (cpart > 0) {
                    r = mid;
                } else {
                    l = mid + 1;
                }
            }
            int found = S[l];
            result.push_back(found);
 
            // remove found from S.
            auto it = find(S.begin(), S.end(), found);
            if (it != S.end()) S.erase(it);
 
            count = query_count_in_T(S, x);
        }
        return result;
    };
 
    auto find_independent_set_heuristic = [&](vector<int> &verts) {
        vector<int> best;
        // We'll use a random approach.
        for (int rep = 0; rep < 10; rep++) {
            vector<int> attempt;
            vector<int> local = verts;
            random_shuffle(local.begin(), local.end());
            for (int v : local) {
                bool can = true;
                for (int u : attempt) {
                    if (adjMatrix[u][v]) {
                        can = false;
                        break;
                    }
                }
                if (can) attempt.push_back(v);
            }
            if (attempt.size() > best.size()) best = attempt;
        }
        return best;
    };
 
    vector<int> U = unassigned;
    while (!U.empty()) {
        vector<int> T = find_independent_set_heuristic(U);
 
        vector<int> assignedInT;
        vector<int> S = T;
        while (!S.empty()) {
            bool foundX = false;
            for (int x = 0; x < N; x++) {
                if (S.empty()) break;
                int countx = query_count_in_T(S, x);
                if (countx > 0) {
                    vector<int> found = find_vertices_in_T_with_color_x(S, x);
                    for (int v : found) {
                        final_colors[v] = x;
                        assignedInT.push_back(v);
                    }
                    for (int v : found) {
                        auto it = find(S.begin(), S.end(), v);
                        if (it != S.end()) S.erase(it);
                    }
                    foundX = true;
                }
            }
            if (!foundX) {
                // If no color found for S, we can't assign those vertices.
                // But maybe it's impossible.
                break;
            }
        }
 
        // remove T from U.
        set<int> assignedSet(assignedInT.begin(), assignedInT.end());
        vector<int> newU;
        for (int v : U) {
            if (assignedSet.find(v) == assignedSet.end()) newU.push_back(v);
        }
        U = newU;
    }
 
    return final_colors;
}
\end{lstlisting}
