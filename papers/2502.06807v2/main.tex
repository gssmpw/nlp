\documentclass{article}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{subcaption} %
\usepackage{url}
\usepackage{xcolor}
\usepackage{booktabs}
\usepackage{adjustbox}
\usepackage{longtable}
\usepackage{listings}

\usepackage[a4paper, margin=1in]{geometry}  %

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=C++,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  backgroundcolor=\color{gray!10},
  columns=flexible,
  basicstyle={\small\ttfamily},
  numbers=none,
  numberstyle=\tiny\color{gray},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3
}


\usepackage{xcolor}
\usepackage{mleftright}
\usepackage{amsthm}
\usepackage[shortlabels]{enumitem}
\usepackage[capitalize,noabbrev]{cleveref}
\usepackage{pifont}
\usepackage{multirow}
\usepackage{float}
\usepackage{wrapfig}
\usepackage{xspace}

\usepackage{mathtools}
\newcommand{\defeq}{\vcentcolon=}
\renewcommand{\vec}[1]{\bm{#1}}
\newcommand{\anch}{\pi_{\text{anchor}}}
\newcommand{\codeforces}{\textsc{CodeForces}\xspace}


\newcommand{\ahelk}[1]{\textcolor{blue}{\textbf{TODO(ahelk):} #1}}

\title{Competitive Programming with Large Reasoning Models}
\author{OpenAI\thanks{Contributions listed in Appendix~\ref{app:authors}}
}
\date{}

\begin{document}
\maketitle

\begin{abstract}
We show that reinforcement learning applied to large language models (LLMs) significantly boosts performance on complex coding and reasoning tasks. Additionally, we compare two general-purpose reasoning models — OpenAI o1 and an early checkpoint of o3 — with a domain-specific system, o1-ioi, which uses hand-engineered inference strategies designed for competing in the 2024 International Olympiad in Informatics (IOI). We competed live at IOI 2024 with o1-ioi and, using hand-crafted test-time strategies, placed in the 49th percentile. Under relaxed competition constraints, o1-ioi achieved a gold medal. However, when evaluating later models such as o3, we find that o3 achieves gold without hand-crafted domain-specific strategies or relaxed constraints. Our findings show that although specialized pipelines such as o1-ioi yield solid improvements, the scaled-up, general-purpose o3 model surpasses those results without relying on hand-crafted inference heuristics. Notably, o3 achieves a gold medal at the 2024 IOI and obtains a \codeforces rating on par with elite human competitors. Overall, these results indicate that scaling general-purpose reinforcement learning, rather than relying on domain-specific techniques, offers a robust path toward state-of-the-art AI in reasoning domains, such as competitive programming.




\end{abstract}



\section{Introduction}

Competitive programming is widely recognized as a challenging benchmark for evaluating reasoning and coding proficiency~\cite{chen2021evaluating}.
Solving complex algorithmic problems demands advanced computational thinking and problem solving skills. Moreover, these problems are also objectively gradable, making it an ideal testbed to assess the reasoning capabilities of AI systems.

Recent work on program synthesis with large language models~\cite{austin2021program} has demonstrated that even relatively general models, ranging from 244M to 137B parameters, can generate short Python scripts from natural language instructions. Importantly, performance improves log-linearly with model size, and fine-tuning significantly boosts accuracy. Concurrently, Codex~\cite{chen2021evaluating}, an early code-focused LLM, excelled at Python program generation and powered GitHub Copilot. Further progress came from AlphaCode~\cite{li2022competition}, which tackled competitive programming tasks using large-scale code generation and heuristics at inference, and the subsequent AlphaCode2\cite{leblond2023alphacode}, whose improvements nearly doubled AlphaCode’s solved problems and placed it in the 85th percentile on the \codeforces platform.
Both AlphaCode systems used large-scale sampling of up to a million candidate solutions per problem before selecting their top 10 submissions with a hand-engineered test-time strategy.


Since then, significant progress has been made in harnessing reinforcement learning to improve LLMs’ reasoning skills. This has led to the emergence of large reasoning models (LRMs): language models trained via reinforcement learning to ``reason" and ``think through" extended chains of thought.  In particular, OpenAI’s o1~\cite{jaech2024openai,openai_learning_reason_llms} and its soon-to-be-released successor o3~\cite{openaio3} use chain-of-thought reasoning to tackle intricate tasks such as mathematics and coding. Work by DeepSeek-R1~\cite{deepseekai2025deepseekr1incentivizingreasoningcapability} and Kimi k1.5~\cite{kimiteam2025kimik15scalingreinforcement} independently illustrates how learning chain-of-thought boosts performance on both mathematical and programming challenges.


An open question is how domain-specific, hand-engineered inference strategies compare to learned approaches that models generate and execute on their own. We have three systems available that can shed light on this question: o1, o1-ioi, and early checkpoints of o3. OpenAI o1 was the first large reasoning model and used general purpose methods to improve programming performance.  Building on this foundation, o1-ioi was a fine-tuned system tailored to compete in the 2024 International Olympiad in Informatics (IOI) and used test-time strategies similar to those used in the AlphaCode system. This specialization led to strong performance improvements on both the 2024 IOI and competitive programming platforms such as \codeforces. Subsequent advances led to the development of o3, which has significantly advanced the reasoning capabilities of AI models. Unlike o1-ioi or AlphaCode, o3 does not depend on coding-specific test-time strategies defined by humans. Instead, we found that complex test-time reasoning strategies emerged naturally from end-to-end RL, leading to unprecedented performance on competitive programming benchmarks.

This report provides a high-level overview of the importance of reasoning in coding tasks such as competitive programming, the progress of OpenAI’s large reasoning models in programming ability, and our evaluation methodology and results on various competitive programming and coding benchmarks.

\section{OpenAI o1}
We start with OpenAI o1, a large language model trained with reinforcement learning to tackle complex reasoning tasks. By generating an extended internal chain of thought before answering~\cite{wei2022chain}, o1 resembles a human who methodically works through a challenging problem step by step. Reinforcement learning refines this chain-of-thought process, helping the model identify and correct errors, break down complex tasks into manageable parts, and explore alternate solution paths when an approach fails. These in-context reasoning capabilities substantially boost o1’s overall performance on a wide range of tasks.

Additionally, OpenAI o1 is trained to use external tools~\cite{schick2023toolformer}, especially for writing and executing code in a secure environment.\footnote{\url{https://platform.openai.com/docs/assistants/tools/code-interpreter}} This capability lets o1 verify whether its generated code compiles, passes provided test cases, and meets other correctness checks. By testing and refining its outputs, o1 iteratively improves its solutions over the course of a single sample.

\subsection{\codeforces Benchmark}
\codeforces is a programming competition website that hosts live contests.
It is internationally competitive and frequented by some of the best competitive programmers in the world.

To assess our models' competitive programming abilities, we simulated \codeforces contests under conditions that closely mirrored real competitions. This included using the full test suite for each problem and enforcing appropriate time and memory constraints for solutions.

Our evaluation focused on Division 1 contests from 2024 and December 2023, ensuring all test contests occurred after the data cut-off for both pretraining and RL. Additionally, we conducted a contamination check as a sanity measure, leveraging the OpenAI embedding API to verify that test problems had not been seen during training.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.85\textwidth]{figures/codeforces_elo_gpt4o.pdf}
    \caption{Comparing reasoning LLMs OpenAI o1-preview and o1 to gpt-4o on \codeforces.}
    \label{fig:codeforces_gpt4o}
\end{figure}

We compared o1 against a non-reasoning LLM (gpt-4o) and an earlier reasoning model (o1-preview). Figure~\ref{fig:codeforces_gpt4o} shows how both o1-preview and o1 dramatically outperform gpt-4o, highlighting the effectiveness of reinforcement learning for complex reasoning. The o1-preview model achieved a \codeforces rating of 1258 (62nd percentile) --- up from gpt-4o’s 808 (11th percentile). Further training pushed o1’s rating to 1673 (89th percentile), establishing a new milestone for AI performance in competitive programming.

In Appendix \ref{app:cf_details} we provide additional details of which problems our models can solve and how ratings were calculated.  

\section{OpenAI o1-ioi}
During our development and evaluation of OpenAI o1, we found that increasing both the amount of reinforcement learning (RL) compute and test-time inference compute consistently improved model performance.

\begin{figure}[h!] \centering \includegraphics[width=0.85\textwidth]{figures/compute.png} \caption{Additional RL training and additional test-time compute improves competitive mathematics performance.} \label{fig:aime_train_test} \end{figure}

As shown in Figure~\ref{fig:aime_train_test}, scaling RL training and extending test-time inference led to marked gains, highlighting the importance of optimizing these two compute dimensions to push performance beyond conventional LLM pretraining.

Building on these insights, we created the \textit{o1-ioi} system for competing at the 2024 International Olympiad in Informatics (IOI). In addition to continued RL training targeted at coding tasks, \textit{o1-ioi} incorporates specialized test-time inference strategies engineered for competitive programming.

\subsection{Coding RL Fine-tuning}
Our first step extended the reinforcement learning phase of OpenAI o1, focusing on coding tasks. By dedicating additional training compute to programming problems, we bolstered the model’s ability to plan, implement, and debug more involved solutions. Concretely:

\begin{enumerate}
    \item We resumed RL training from the OpenAI o1 checkpoint.
    \item We specifically emphasized challenging programming problems, helping the model improve C++ generation and runtime checks.
    \item We guided the model to produce outputs in the IOI submission format.
\end{enumerate}

This added focus on coding allowed o1-ioi to write and execute C++ programs during inference. The model improved its reasoning by iteratively running and refining solutions, thereby strengthening both its coding and problem-solving skills.

\subsection{o1-ioi Test-time Strategy}
\label{section:test-time-strategy}
At a high level, we divided each IOI problem into its constituent subtasks, sampled 10,000 solutions from o1-ioi for each subtask, and then employed a clustering- and reranking-based approach to decide which solutions from this set to submit.


\paragraph{Problem formulation} For o1-ioi we chose to attempt to solve the individual subtasks of each problem separately, as the scoring for IOI is done on a subtask-by-subtask basis and gives each competitor the maximum score over all of their attempts on each subtask. To do this, we divided each IOI problem into its composite subtasks (using the divisions laid out in the scoring guide for each problem). This was done simply by creating one version of the document for each subtask with the information about the other subtasks removed.

\paragraph{Clustering}
We clustered the generated solutions based on their outputs on model-generated test inputs. For each subtask, we first prompted the model to write random test input generators in C++ given the problem specification and subtask. We used these generators to generate 256 random test inputs. To ensure the validity of these test inputs, we then prompted the model to write test input validators in C++ that check, given a test input, whether it satisfies the subtask constraints. Finally, we accepted each test input that passes at least 75\% of the validators. For each subtask, we generated 256 of these random test case inputs, and then clustered based on their outputs for these test cases. Any programs that matched each other's outputs on all test inputs would be placed in the same cluster.

\paragraph{Reranking}
We then implemented the reranking core of our test-time compute strategy. We scored each solution based on:
\begin{itemize}
    \item The quality of the solution according to a learned scoring function.
    \item Errors on model-generated test inputs.
    \item Failing the provided public test cases.
\end{itemize}
Each cluster was given a score defined as the average score of the samples it contained minus a penalty for each time a sample submission was attempted from that cluster. The weights of all of these penalties were tuned by random search on solutions to previous years' IOI problems, by directly simulating the submission process.

\paragraph{Submission}
We then submitted up to \textbf{50} (the maximum number allowed for human competitors) of these solutions in a round-robin fashion over subtasks, starting from the hardest. We selected the top-ranked solution in the top-ranked cluster for each given subtask. When a subtask was solved (meaning that the maximum score was attained), we ceased sampling on that subtask. When submitting solutions to any subtask that was a strict superset of a solved subtask, we would filter out any solutions that did not match the outputs on test inputs of the solved constituent subtasks, allowing us to rapidly narrow down candidate solutions on harder subtasks by rejecting those that would almost certainly have failed easier subtasks.

\subsection{\codeforces Benchmark}
Once again, we simulated \codeforces contests to evaluate o1-ioi's coding abilities, closely mirroring contest conditions with the complete test suite for each problem and appropriate time and memory restrictions for solutions.

\begin{figure}[h!] \centering \includegraphics[width=0.85\textwidth]{figures/codeforces_elo_ioi.pdf} \caption{Further training OpenAI o1 on coding tasks and incorporating test-time strategies improves performance.} \label{fig:codeforces_ioi} \end{figure}

Figure~\ref{fig:codeforces_ioi} shows that o1-ioi reached a \codeforces rating of 1807, outperforming 93\% of competitors --- demonstrating clear improvements from additional RL training on coding tasks. When we applied a simple filter rejecting any solution that failed public tests, the rating rose to 2092 (96th percentile). Our complete test-time strategy pushed performance even further, attaining a rating of 2214 (98th percentile). These results confirm that domain-specific RL fine-tuning paired with advanced selection heuristics can significantly boost competitive programming outcomes.

\subsection{IOI 2024 Live Competition}

\begin{figure}[h!] \centering \includegraphics[width=0.85\textwidth]{figures/ioi_performance.pdf} \caption{Performance of o1-ioi competing at IOI 2024.} \label{fig:ioi_2024} \end{figure}


The o1-ioi system participated in the 2024 International Olympiad in Informatics (IOI) under the same conditions as human contestants. It had ten hours to solve six challenging algorithmic problems and was allowed up to 50 submissions per problem. We show the results in Figure~\ref{fig:ioi_2024}.

During the competition, our system generated 10,000 candidate solutions for each problem, and selected 50 submissions using our test-time selection strategy. This strategy prioritized submissions based on their performance on the IOI public test cases, model-generated test cases, and a learned scoring function. The model scored 213 points, placing it in the 49th percentile of the competition.

In comparison, selecting 50 random submissions would have yielded an average score of only 156 points, indicating that the selection strategy contributed nearly 60 additional points under the competition's constraints.

When the submission limit was relaxed to 10,000 per problem, the model's performance improved dramatically. Without employing any test-time selection strategy, it achieved a score of 362.14, surpassing the gold medal threshold and demonstrating the model's potential. We show samples that yielded the 362.14 score in Appendix~\ref{appendix:ioi_samples}.

\section{OpenAI o3}
Building on the insights gained from o1 and o1-ioi, we explore the limits of reinforcement learning (RL) training alone, without relying on human-engineered test-time strategies. While o1-ioi achieved strong results by combining additional RL fine-tuning with carefully designed test-time inference pipelines, its success hinged on human intervention to define and implement these strategies. We sought to explore the performance of a model even further trained with RL with the ability to autonomously develop and execute its own test-time reasoning strategies. To this end, we obtained access to early checkpoints of o3~\cite{openaio3} to evaluate on competitive programming tasks. 

\subsection{\codeforces Benchmark}
We evaluate an early checkpoint of the o3 model on our \codeforces benchmark set, where each prompt includes the problem description, constraints, and any available sample test cases.


\begin{figure}[h!]
\centering
\includegraphics[width=0.85\textwidth]{figures/codeforces_o3.pdf}
\caption{Performance of OpenAI o3 on the \codeforces benchmark.}
\label{fig:o3_codeforces}
\end{figure}


As shown in Figure~\ref{fig:o3_codeforces}, further RL training provided a significant improvement over both o1 and the full o1-ioi system. Notably, the transition from the o1-ioi model to o3 resulted in a rating increase from 2214 (98th percentile) to 2724 (99.8th percentile), reflecting a substantial leap in competitive programming performance. This improvement demonstrates o3’s ability to solve a wider range of complex algorithmic problems with higher reliability, pushing its capabilities closer to top-tier human competitors on \codeforces.

\begin{figure}[h!]
\centering
\includegraphics[width=0.95\textwidth]{figures/brute_force.png}
\caption{o3 testing its own solution. This reflects a sophisticated reasoning strategy that partially implements the hand-designed test-time strategy used for o1-ioi in IOI 2024.}
\label{fig:o3_strategy}
\end{figure}

In addition to its significantly improved problem-solving capabilities, we observe that o3 demonstrates more insightful and deliberate chains of thought. The model not only writes and executes code to validate its solutions against public test cases, it also refines its approach based on these verifications. Figure~\ref{fig:o3_strategy} shows an advanced test-time strategy discovered by o3: for problems where verification is nontrivial, it often writes simple brute-force solutions --- trading efficiency for correctness --- then cross-checks the outputs against its more optimized algorithmic implementations. This self-imposed validation mechanism lets o3 catch potential errors and improve the reliability of its solutions.


\subsection{IOI 2024 Benchmark}
Although we competed in IOI 2024 using o1-ioi, we retrospectively evaluated a checkpoint of o3 on the same six IOI 2024 problems to compare performance under identical conditions. As with o1-ioi, we strictly adhered to the official IOI rules, which permit a maximum of 50 submissions per problem.

The o3 results on the IOI 2024 were produced by a later version of o3 than the \codeforces results, and included additional fresher training data. 
IOI 2024 occurred after the training cut-off for this model, and we additionally confirmed with search that the IOI test problems are not contaminated with the training set.

\paragraph{Sampling Approach.}
Unlike o1-ioi, which sampled solutions separately for each subtask, we adopted a different approach when evaluating o3: \textit{sampling from a single prompt containing the original problem statement}. Additionally, while o1-ioi generated 10K solutions per subtask, for o3 we sampled only 1K solutions per problem.

Selection strategies also differed between the two models. Whereas o1-ioi relied on a complex, human-defined test-time strategy (\ref{section:test-time-strategy}) to select solutions, o3 followed a much simpler approach. Specifically, we selected the top 50 solutions with the highest test-time compute from 1,024 samples per problem. Despite this streamlined method, o3 produced robust solutions capable of covering many, if not all, subtasks --- without the need for subtask-specific prompts, manual partitioning, or intricate submission strategies.


\begin{figure}[h!]
    \centering
    \includegraphics[width=0.85\textwidth]{figures/ioi_o3_performance.pdf}
    \caption{\textbf{IOI 2024 scores under different submission strategies.} Even without human-engineered heuristics or relaxed submission limits, o3 outperforms o1-ioi and surpasses the gold threshold with just 50 submissions.}
    \label{fig:o3_ioi_bar}
\end{figure}

\paragraph{Results.} \Cref{fig:o3_ioi_bar} presents the final scores. The IOI scoring system is subtask-based, with a maximum total of 600 points in the 2024 contest. The gold medal threshold was approximately 360 points. Key results include:

\begin{itemize}[leftmargin=15pt]
    \item o1-ioi scored 213 points with 50 submissions, improving to 362.14 points with 10K submissions, just above the gold medal cutoff.
    \item o3 achieved 395.64 points, surpassing the gold threshold even under the 50-submission limit.
\end{itemize}

These results demonstrate that o3 outperforms o1-ioi without relying on IOI-specific, hand-crafted test-time strategies. Instead, the sophisticated test-time techniques that emerged during o3 training, such as generating brute-force solutions to verify outputs, served as a more than adequate replacement and eliminated the need for the hand-engineered clustering and selection pipelines required by o1-ioi.

Overall, the IOI 2024 findings confirm that large-scale RL training alone can achieve state-of-the-art coding and reasoning performance. By independently learning to generate, evaluate, and refine solutions, o3 surpasses o1-ioi without dependence on domain-specific heuristics or clustering-based methods.


\section{Software Engineering Evaluations}
We have demonstrated how reasoning significantly enhances LLM performance in competitive programming, where solving complex algorithmic challenges requires deep logical thinking. However, we also sought to evaluate the impact of reasoning on real-world coding tasks. To this end, we tested our models on two datasets: the HackerRank Astra\footnote{\url{www.hackerrank.com/ai/astra}}  dataset and SWE-bench verified\footnote{\url{https://openai.com/index/introducing-swe-bench-verified/}}~\cite{jimenez2023swe,openai_swe_bench_verified}.

\subsection{HackerRank Astra}

The HackerRank Astra dataset is composed of 65 project-oriented coding challenges, each crafted to simulate real-world software development tasks. These challenges cover a range of frameworks, including React.js, Django, and Node.js, allowing for hands-on experience in building features and applications.

What sets this dataset apart is its focus on assessing problem-solving skills in complex, multi-file, long-context scenarios that mirror actual development environments. Unlike typical competitive programming datasets, HackerRank Astra does not provide public test cases, which prevents us from relying on hand-crafted test-time tactics. Evaluating performance with this dataset reveals whether reasoning abilities enhance success in algorithmic problem solving alone, or extend to more practical, industry-related coding tasks.

\begin{figure}[h!] \centering \includegraphics[width=0.85\textwidth]{figures/hackerrank_astra.pdf} \caption{HackerRank Astra evaluation.} \label{fig:astra} \end{figure}

Figure~\ref{fig:astra} presents performance metrics such as pass@1 (the probability of successfully completing a task on the first attempt) and average scores (the mean proportion of test cases passed). The results illustrate the impact of chain-of-thought reasoning, with the o1-preview model achieving a 9.98\% improvement in pass@1 and a 6.03-point gain in average score compared to GPT-4o. Further fine-tuning through reinforcement learning enhances o1's performance, yielding a pass@1 of 63.92\% and an average score of 75.80\%—a 3.03\% increase in pass@1 over o1-preview. These metrics demonstrate o1's enhanced reasoning and adaptability, enabling it to address complex, industry-relevant software development tasks effectively.

\subsection{SWE-Bench Verified}
SWE-bench Verified is OpenAI's preparedness team's human-validated subset of SWE-bench that more reliably evaluates AI models’ ability to solve real-world software issues. This validated set of 500 tasks fixes certain issues with SWE-bench such as incorrect grading of correct solutions, under-specified problem statements, and overly specific unit tests. This helps ensure the benchmark accurately grades model capabilities.

To illustrate performance on this software task, we display the results presented in the o1 system card~\cite{jaech2024openai} as well as results from an early o3 checkpoint~\cite{openaio3}. Because o1-preview was not trained to use code execution or file editing tools, the best-performing open-source scaffold at the time of initial implementation, Agentless was used. Unlike for IOI, no specialized test-time strategies was used for SWE-Bench verified. All models are given 5 tries to generate a candidate patch. If the model fails after 5 attempts, it is considered an incorrect attempt. All evaluations are averaged over 3 trials. We do not penalize the model for system failures (e.g., container hangs or grading failures), and we retry these rollouts until we can record a valid attempt.

\begin{figure}[H] \centering \includegraphics[width=0.85\textwidth]{figures/swebench.pdf} \caption{SWE-bench evaluation.} \label{fig:swebench} \end{figure}


As illustrated in Figure~\ref{fig:swebench}, o1-preview demonstrates an 8.1\% performance improvement on SWE-bench compared to gpt-4o, showcasing notable advancements in reasoning capabilities. With additional reinforcement learning compute applied during training, o1 achieves a further 8.6\% improvement. Notably, o3, which was trained with significantly greater compute resources than o1, delivers an impressive 22.8\% improvement over o1. These results underscore that enhanced reasoning skills extend beyond competitive programming challenges, proving their applicability to real-world tasks like software engineering.

\section{Conclusion}
Through the o-series large reasoning models, we demonstrate that chain-of-thought reasoning is a powerful strategy for improving performance in coding tasks, from competitive programming benchmarks such as \codeforces and IOI to complex software engineering challenges like SWE-bench and Astra. Our findings highlight that increasing reinforcement learning training compute, coupled with enhanced test-time compute, consistently boosts model performance to nearly match the best humans in the world. Given these results, we believe o-series large reasoning models will unlock many new use cases for AI in science, coding, math, and many other fields.
\appendix

\section{Authorship, credit attribution, and acknowledgments}
\label{app:authors}

\paragraph{Data Preparation:}
Borys Minaiev, Ignasi Clavera, Lorenz Kuhn, Nat McAleese, Oleg Mürk, Szymon Sidor

\paragraph{IOI Model Training:} Ahmed El-Kishky, Mostafa Rohaninejad

\paragraph{Sampling Infrastructure:}
Andre Saraiva, Hunter Lightman, Vineet Kosaraju, Wenda Zhou

\paragraph{Test-time Strategy:} Alexander Wei, Daniel Selsam, David Dohan, Francis Song, Ignasi Clavera, Max Schwarzer, Rhythm Garg, Rui Shu

\paragraph{Evaluation:} Andre Saraiva, Ignasi Clavera, Lorenz Kuhn, Nat McAleese

\paragraph{Leadership:}
Jakub Pachocki, Jerry Tworek, Lukasz Kaiser, Mark Chen

\paragraph{o3 Model Development} o3 contributors~\cite{openaio3}.


\paragraph{Acknowledgments:} We are grateful to the IOI committee for allowing us to enter our model, o1-ioi, in the 2024 International Olympiad in Informatics. We also extend our thanks to Wael Ewida, a member of the IOI technical committee, for hosting a portal that enabled us to submit our solutions under the same conditions as the contestants. Additionally, we appreciate the support of those who contributed to and maintained our sandboxed code execution, including Taylor Gordon, Oleg Boiko, John Rizzo, Paul Ashbourne, Leo Liu, Alexander Prokofiev, and Scottie Yan. We also extend our gratitude to Chris Orsinger and Michelle Fradin for their contributions to data efforts. Finally, we would like to express our sincere gratitude to everyone involved in the reinforcement learning reasoning efforts for o1 and o3, whose dedication and expertise were instrumental in advancing this work.



\section{Additional \codeforces Details}
\label{app:cf_details}
In order to compare our models to human competitive programmers, we simulate contests.
This section provides details of how the simulation is performed, how the overall score and ratings are calculated, as well as the per-contest results.

\subsection{Data}
For our test set we use ``Division 1'' contests from late 2023 and 2024, all of which occurred after the o3 training set data cut-off. 
As a redundant additional check, we used embedding search to confirm that the test problems have not been seen by the model during training.
We excluded one contest that contained an interactive problem for which grading was inconvenient, but otherwise included all post-cut-off Division 1 problems to which we had access at the time.
During training we used a validation set of primarily Division 2 problems; when that set indicated that performance was very strong we built and evaluated the Division 1 set presented here.

\subsection{Grading}
We run the complete set of tests for each problem, and have confirmed that our test environment closely matches the official \codeforces grading service, including by manually submitting solutions for the hardest problems to the official \codeforces graders.

Following AlphaCode \cite{leblond2023alphacode} we allow the model to make 10 independent submissions against the full test set and mark a problem as solved if any one of those 10 passes.
This is close to but not strictly the same as the human affordance, as human participants see only the results of the pre-tests during the competition.
However in Division 1 contests the pre-tests are typically ``strong'' (highly correlated with full tests), and in our results the number of failures before a passing submission is typically small (see \ref{tab:cf-details}).
We did not have access to labels for which test cases were pre-tests.

\subsection{Thinking Time}

Competitors receive a higher score for submitting their solutions faster. 
Because models can think in parallel and simultaneously attempt all problems, they have an innate advantage over humans. We elected to reduce this advantage in our primary results by estimating o3's score for each solved problem as the median of the scores of the human participants that solved that problem in the contest with the same number of failed attempts.

We could instead use the model's real thinking time to compute ratings.
o3 uses a learned scoring function for test-time ranking in addition to a chain of thought.
This process is perfectly parallel and true model submission times therefore depend on the number of available GPU during the contest.
On a very large cluster the time taken to pick the top-ranked solutions is (very slightly more than) the maximum over the thinking times for each candidate submission.
Using this maximum parallelism assumption and the sequential o3 sampling speed would result in a higher estimated rating than presented here.
We note that because sequential test-time compute has grown rapidly since the early language models, it was not guaranteed that models would solve problems quickly compared to humans, but in practice o3 does.

\subsection{Estimated Rating}

The \codeforces rating system is described by the creator in three blog posts \cite{cf_rating_1, cf_rating_2, cf_rating_3}.
Ratings are similar to the Elo system and satisfy the property that if competitor $A$ has rating $R_A$ and competitor $B$ has rating $R_B$ then the probability that $A$ ranks better than $B$ any final contest standings is estimated as $$\frac 1 {10^{\frac {R_B - R_A} {400}}}$$

To find the model rating we first calculate the rank of the model in each of the test contest from the total contest score (described above) and then directly maximize the likelihood of the observed rankings and human ratings with respect to the model rating using the equation above.
We average to ensure that contests with more participants are not over-weighted.

We validated that this recovers known human ratings based on their contest performance and also gives similar values to linearly predicting participant rating from their average solve rate.

\subsection{Percentile performance}


Codeforces maintains a global leaderboard of active participants, and an estimated rating can be used to compare to that group. 
We can also directly compare the solve rate of o3 in our test contests to the other participants in those contests.
Figure \ref{fig:o3-vs-best-humans} shows both these comparisons.
Each point is a person that competed in at least 8 of the test contests.
We show their average solve rate over contests that they entered against their rating, as well as the rating thresholds for key performance levels.
The very best human competitors remain much stronger than o3, with solve rates in excess of 85\%, but both ratings and solve rates indicate that o3 would rank among the top 200 active participants worldwide.

\begin{figure}[h!]
    \centering
    \includegraphics[width=0.75\textwidth]{figures/o3-vs-best-humans.pdf}
    \caption{o3 would place among the best human competitive programmers in the world. Here we show the average solve rate and current rating for participants that entered at least 8 of our 12 unseen test contests. Horizontal lines show performance thresholds from the global \codeforces leaderboard of active competitors. The very best humans still solve more problems than AI, for now.}
    \label{fig:o3-vs-best-humans}
\end{figure}

\subsection{Per Problem Breakdown}


{\small
\begin{longtable}{lrrrrr}
\caption{
We estimate our \codeforces rating from simulated contest participation.
Here we show a detailed breakdown of o3 performance per-problem.
}%
\label{tab:cf-details}\\

\toprule
\textbf{problem} &
\shortstack{\textbf{problem}\\\textbf{rating}} &
\shortstack{\textbf{pass@1}\\\textbf{(no ranking)}} &
\shortstack{\textbf{pass@10}\\\textbf{(no ranking)}} &
\shortstack{\textbf{\# failed}\\\textbf{submissions}} &
\shortstack{\textbf{pass@10}\\\textbf{(ranking 1162)}}\\
\midrule
\endfirsthead

\toprule
\textbf{problem} &
\shortstack{\textbf{problem}\\\textbf{rating}} &
\shortstack{\textbf{pass@1}\\\textbf{(no ranking)}} &
\shortstack{\textbf{pass@10}\\\textbf{(no ranking)}} &
\shortstack{\textbf{\# failed}\\\textbf{submissions}} &
\shortstack{\textbf{pass@10}\\\textbf{(ranking 1162)}}\\
\midrule
\endhead

\midrule
\multicolumn{6}{r}{\textit{Continued on the next page}}\\
\endfoot

\bottomrule
\endlastfoot
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1909 - 23/Dec/23 - Pinely Round 3 (Div. 1 + Div. 2)}\\\textbf{ score: 7,220}}}}\\
1909 A & 800 & 1156 / 1162 & 1.00 & 0 & solved\\
1909 B & 1200 & 1066 / 1162 & 1.00 & 0 & solved\\
1909 C & 1400 & 1075 / 1162 & 1.00 & 0 & solved\\
1909 D & 1900 & 1099 / 1162 & 1.00 & 0 & solved\\
1909 E & 2400 & 703 / 1162 & 1.00 & 0 & solved\\
1909 F1 & 2200 & 57 / 1162 & 0.40 & 0 & solved\\
1909 F2 & 2500 & 0 / 1162 & 0.00 & 0 & not solved\\
1909 G & 3000 & 3 / 1162 & 0.03 & 0 & not solved\\
1909 H & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
1909 I & 1900 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1916 - 30/Dec/23 - Good Bye 2023}\\\textbf{ score: 8,920}}}}\\
1916 A & 800 & 1157 / 1162 & 1.00 & 0 & solved\\
1916 B & 1000 & 1133 / 1162 & 1.00 & 0 & solved\\
1916 C & 1200 & 1145 / 1162 & 1.00 & 0 & solved\\
1916 D & 1700 & 483 / 1162 & 1.00 & 0 & solved\\
1916 E & 2300 & 6 / 1162 & 0.05 & 0 & solved\\
1916 F & 2900 & 369 / 1162 & 0.98 & 2 & solved\\
1916 G & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
1916 H1 & 2700 & 1059 / 1162 & 1.00 & 0 & solved\\
1916 H2 & 2700 & 1045 / 1162 & 1.00 & 0 & solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1919 - 06/Jan/24 - Hello 2024}\\\textbf{ score: 6,214}}}}\\
1919 A & 800 & 1161 / 1162 & 1.00 & 0 & solved\\
1919 B & 800 & 1141 / 1162 & 1.00 & 0 & solved\\
1919 C & 1400 & 499 / 1162 & 1.00 & 0 & solved\\
1919 D & 2100 & 25 / 1162 & 0.20 & 2 & solved\\
1919 E & 2600 & 6 / 1162 & 0.05 & 1 & solved\\
1919 F1 & 2300 & 1090 / 1162 & 1.00 & 0 & solved\\
1919 F2 & 2800 & 227 / 1162 & 0.89 & 0 & solved\\
1919 G & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
1919 H & 2000 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1942 - 30/Mar/24 - CodeTON Round 8 (Div. 1 + Div. 2, Rated, Prizes!)}\\\textbf{ score: 8,701}}}}\\
1942 A & 800 & 1157 / 1162 & 1.00 & 0 & solved\\
1942 B & 1100 & 1157 / 1162 & 1.00 & 0 & solved\\
1942 C1 & 1300 & 999 / 1162 & 1.00 & 0 & solved\\
1942 C2 & 1700 & 525 / 1162 & 1.00 & 1 & solved\\
1942 D & 2100 & 1061 / 1162 & 1.00 & 0 & solved\\
1942 E & 2300 & 347 / 1162 & 0.97 & 0 & solved\\
1942 F & 2700 & 0 / 1162 & 0.00 & 0 & not solved\\
1942 G & 2800 & 239 / 1162 & 0.90 & 0 & solved\\
1942 H & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1943 - 16/Mar/24 - Codeforces Round 934 (Div. 1)}\\\textbf{ score: 3,427}}}}\\
1943 A & 1300 & 116 / 1162 & 0.65 & 0 & solved\\
1943 B & 2000 & 1 / 1162 & 0.01 & 0 & not solved\\
1943 C & 2300 & 160 / 1162 & 0.77 & 0 & solved\\
1943 D1 & 2400 & 848 / 1162 & 1.00 & 0 & solved\\
1943 D2 & 2800 & 14 / 1162 & 0.11 & 0 & solved\\
1943 E1 & 2900 & 0 / 1162 & 0.00 & 0 & not solved\\
1943 E2 & 3300 & 0 / 1162 & 0.00 & 0 & not solved\\
1943 F & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1951 - 06/Apr/24 - Codeforces Global Round 25}\\\textbf{ score: 9,396}}}}\\
1951 A & 900 & 1157 / 1162 & 1.00 & 0 & solved\\
1951 B & 1200 & 1150 / 1162 & 1.00 & 0 & solved\\
1951 C & 1400 & 1155 / 1162 & 1.00 & 0 & solved\\
1951 D & 2000 & 875 / 1162 & 1.00 & 0 & solved\\
1951 E & 2000 & 1009 / 1162 & 1.00 & 0 & solved\\
1951 F & 2500 & 53 / 1162 & 0.37 & 0 & solved\\
1951 G & 3100 & 34 / 1162 & 0.26 & 0 & solved\\
1951 H & 3200 & 1 / 1162 & 0.01 & 0 & not solved\\
1951 I & 3200 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1965 - 27/Apr/24 - Codeforces Round 941 (Div. 1)}\\\textbf{ score: 3,891}}}}\\
1965 A & 1400 & 1143 / 1162 & 1.00 & 0 & solved\\
1965 B & 1800 & 1064 / 1162 & 1.00 & 0 & solved\\
1965 C & 2300 & 313 / 1162 & 0.96 & 0 & solved\\
1965 D & 2900 & 690 / 1162 & 1.00 & 0 & solved\\
1965 E & 3100 & 0 / 1162 & 0.00 & 0 & not solved\\
1965 F & 3300 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1967 - 30/Apr/24 - Codeforces Round 942 (Div. 1)}\\\textbf{ score: 3,871}}}}\\
1967 A & 1400 & 1088 / 1162 & 1.00 & 0 & solved\\
1967 B1 & 1400 & 1154 / 1162 & 1.00 & 0 & solved\\
1967 B2 & 2200 & 1149 / 1162 & 1.00 & 0 & solved\\
1967 C & 2300 & 1116 / 1162 & 1.00 & 0 & solved\\
1967 D & 2800 & 9 / 1162 & 0.08 & 0 & solved\\
1967 E1 & 3100 & 0 / 1162 & 0.00 & 0 & not solved\\
1967 E2 & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
1967 F & 3200 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1975 - 25/May/24 - Codeforces Round 947 (Div. 1 + Div. 2)}\\\textbf{ score: 5,959}}}}\\
1975 A & 800 & 1161 / 1162 & 1.00 & 0 & solved\\
1975 B & 1000 & 1091 / 1162 & 1.00 & 0 & solved\\
1975 C & 1200 & 492 / 1162 & 1.00 & 0 & solved\\
1975 D & 1700 & 9 / 1162 & 0.08 & 3 & solved\\
1975 E & 2100 & 80 / 1162 & 0.51 & 1 & solved\\
1975 F & 2600 & 12 / 1162 & 0.10 & 0 & solved\\
1975 G & 3000 & 0 / 1162 & 0.00 & 0 & not solved\\
1975 H & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
1975 I & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 1984 - 09/Jun/24 - Codeforces Global Round 26}\\\textbf{ score: 12,255}}}}\\
1984 A & 800 & 1161 / 1162 & 1.00 & 0 & solved\\
1984 B & 1100 & 1158 / 1162 & 1.00 & 0 & solved\\
1984 C1 & 1300 & 914 / 1162 & 1.00 & 0 & solved\\
1984 C2 & 1700 & 768 / 1162 & 1.00 & 0 & solved\\
1984 D & 2000 & 193 / 1162 & 0.84 & 1 & solved\\
1984 E & 2400 & 849 / 1162 & 1.00 & 1 & solved\\
1984 F & 2500 & 918 / 1162 & 1.00 & 0 & solved\\
1984 G & 3200 & 0 / 1162 & 0.00 & 0 & not solved\\
1984 H & 3300 & 138 / 1162 & 0.72 & 3 & solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 2002 - 11/Aug/24 - EPIC IoT Round August 2024 (Div. 1 + Div. 2)}\\\textbf{ score: 8,981}}}}\\
2002 A & 800 & 1161 / 1162 & 1.00 & 0 & solved\\
2002 B & 1000 & 1152 / 1162 & 1.00 & 0 & solved\\
2002 C & 1200 & 1096 / 1162 & 1.00 & 0 & solved\\
2002 D1 & 1900 & 1067 / 1162 & 1.00 & 0 & solved\\
2002 D2 & 2300 & 805 / 1162 & 1.00 & 0 & solved\\
2002 E & 2300 & 232 / 1162 & 0.89 & 0 & solved\\
2002 F1 & 2600 & 12 / 1162 & 0.10 & 8 & solved\\
2002 F2 & 2800 & 7 / 1162 & 0.06 & 0 & not solved\\
2002 G & 3400 & 143 / 1162 & 0.73 & 1 & solved\\
2002 H & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
\multicolumn{6}{l}{\textbf{\shortstack[l]{\textbf{Contest 2006 - 30/Aug/24 - Codeforces Round 969 (Div. 1)}\\\textbf{ score: 2,757}}}}\\
2006 A & 1700 & 945 / 1162 & 1.00 & 0 & solved\\
2006 B & 1800 & 1149 / 1162 & 1.00 & 0 & solved\\
2006 C & 2300 & 811 / 1162 & 1.00 & 0 & solved\\
2006 D & 2600 & 2 / 1162 & 0.02 & 0 & not solved\\
2006 E & 3100 & 4 / 1162 & 0.03 & 0 & not solved\\
2006 F & 3500 & 0 / 1162 & 0.00 & 0 & not solved\\
\end{longtable}
}


\section{IOI Submissions}
\label{appendix:ioi_samples}
This section presents the solutions generated by o1-ioi during the 2024 International Olympiad in Informatics.
\input{samples/nile}
\input{samples/message}
\input{samples/tree}
\input{samples/hieroglyphs}
\input{samples/mosaic}
\input{samples/sphinx}


\bibliographystyle{plain}
\bibliography{main}
\end{document}
