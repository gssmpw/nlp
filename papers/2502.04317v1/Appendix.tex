\section{Appendix}


\section{Datasets}

The foundation of CFD in the automotive industry provides insight into design and engineering. The comprehensive previous texts provide a solid overview of computational methods in fluid dynamics and dedicate a comprehensive overview of traditional CFD techniques~\citep{ferziger2019computational} along with specification in automotive aerodynamics, also instrumental in understanding the principles~\citep{katz2016automotive}. Solvers, such as OpenFOAM, a GPU-accelerated open-source solver, along with commercialized licensed solvers are widely used for solving CFD equations in automotive simulations~\citep{jasak2007openfoam}. 

Such simulations consist of two main components, i) car designs, complex geometry often developed special software, and ii) running large scale computation to solve multivariate coupled equations. 
Significant advancements have been achieved by the Ahmed body shape~\citep{ahmed1984some}, a generic car model simple enough to enable high-fidelity industry standard simulations while retaining the main features characterizing the flow of modern cars.
Since then, attempts have been made to improve the realism of the shapes. Shape-net~\citep{chang2015shapenet} in particular has provided a valuable resource for simple CFD simulations of cars~\citep{umetani2018learning}. 
Extending Ahmed's body setting, the DrivAer data set introduces more complex and realistic car geometries~\citep{heft2012introduction}, with subsequent efforts, producing large-scale aerodynamics simulations on such geometries\citep{varney2020experimental}. 
On such dataset, prior work attempts to predict car surface drag coefficients directly by bypassing the surface pressure prediction, pioneered by ~\cite{jacob2021deep}. However, this approach deploys an architecture applied to 3D voxel grids, forcing the method to scale only to low-resolution 3D grid version of the data. The lack of resolution obscures the fine details of geometry, causing the network to predict the same results for cars with different information. This is in contrast to our work that predicts pressure fields on large scales and detailed meshes.



\textbf{Ahmed body} consists of generic automotive geometries~\citep{ahmed1984some}, simple enough to enable high-fidelity industry standard simulations but retaining the main features characterizing the flow of modern cars. It was generated and used in previous studies~\citep{li2023geometry} and contains simulations with various wind-tunnel inlet velocities.

The Ahmed body data set, generated using vehicle aerodynamic simulation in Ahmed body shapes~\citep{ahmed1984some}, consists of steady-state simulation of OpenFOAM solver in 3D meshes each with $10M$ vertices parameterized by height, width, length, ground clearance, slant angle, and fillet radius. The data set is generated and used in previous studies~\citep{li2023geometry} and contains GPU-accelerated simulations with surface mesh sizes of $100k$ on more than $500$ car geometries, each taking 7-19 hours. We follow the same setting as this study using the $10\%$ shape testing. The dataset is proprietary from NVIDIA Corp. Following this work, both of the deployed datasets are in the process of being made publicly available for further research. 

\input{Tables/AhmedControlKernel}

\textbf{DrivAerNet} datasets is the parametric extension of DrivAer datasets. DriveAer car geometries are more complex real-world automotive designs used by the automotive industry and solver development~\citep{heft2012introduction}. Solving the aerodynamic equation for such geometries is a challenging task, and GPU-accelerated solvers are used to provide fast and accurate solvers, generating training data for deep learning purposes~\citep{varney2020experimental,jacob2021deep}. To train our model on the DrivAer dataset, and to demonstrate the applicability of our approach to real-world applications, we use industry simulations from \cite{jacob2021deep}.
DrivAerNet with $50$ parameters in the design space. The dataset consists of $4000$ data points generated using
Reynolds-average Navier-Stokes (RANS) formulation on OpenFoam solver on $0.5$M mesh faces. 










\subsection{Baseline Network Configurations}

We list the network configurations used in the experiment in the appendix. We use OpenPoint~\cite{qian2022pointnext} for the baseline implementation and, with configuration, you can specify the network architecture.

\input{Sections/appendix-baselines}


\subsection{FIGConvNet Configuration}

We share the network configuration used in FIGConvNet experiments in the appendix. The code will be released upon acceptance, and the network configuration below uniquely defines the architecture.

\input{Sections/appendix-networkdetails}



\subsection{Warp-based Radius Search}

\floatname{algorithm}{Procedure}
\renewcommand{\algorithmicrequire}{\textbf{Input:}}
\renewcommand{\algorithmicensure}{\textbf{Output:}}

The algorithm~\ref{alg:warp-radius} describes how we efficiently find the input points within the radius of a query point in parallel. It follows the common three-step computational pattern in GPU computing when encountering dynamic number of results: Count, Exclusive Sum, Allocate, and Fill. We achieve excellent performance by leveraging NVIDIA's Warp Python framework, which compiles to native CUDA and provides spatially efficient point queries with its hash-grid primitive.

\begin{algorithm}
    \caption{GPU-accelerated points in a radius search}
    \begin{algorithmic}
        \Require{input points $p$, query points $q$, radius $r$}
        \Ensure{Results Array, Result Offset}
    \Procedure{CountRadiusResults}{query points, input points, radius $r$}
    \State Step 1: Count number of results

        \ForAll{query points $q$}
        \While{candidate $p\gets$ hash-grid query($q$,$r$)}
            \If{$\|q-p\|<$ radius}
                count[q]++
            \EndIf
        \EndWhile
        \EndFor
        \EndProcedure
        \Procedure{ComputeOffset}{count}
        \State offset $\gets$ exclusive-sum(count)
        \State total number results $\gets$ offset[last]
        \State results-array $\gets$ alloc(total number results)
        \EndProcedure
        \Procedure{FillRadiusResults}{query points, input points, radius $r$, offset}
        \ForAll{query points $q$}
        \State q-count $\gets 0$
        \While{candidate $p\gets$ hash-grid query($q$,$r$)}
        \If{$\|q-p\|<$ radius}
            \State results-array[offset[q-count]] $\gets p$
            \State q-count++
        \EndIf
        \EndWhile
        \EndFor
        \EndProcedure

        \Procedure{PointsInRadius}{input points, query points, radius}
        \State count $\gets$ \Call{CountRadiusResults}{query points, input points, radius}
        \State offset, allocated results array $\gets$ \Call{ComputeOffset}{count}
        \State results array $\gets$ \Call{FillRadiusResults}{query points, input points, radius, offset, results array}
        \EndProcedure
    \end{algorithmic}
    \label{alg:warp-radius}
\end{algorithm}
