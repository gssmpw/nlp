%
\begin{figure*}
    \vspace{10pt} 
    \centering
    \begin{subfigure}[t]{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{Figures/forwards_tile.pdf}
        \caption{Forward movement}
    \end{subfigure}
    \hfill
    \begin{subfigure}[t]{0.49\textwidth}
        \centering
        \includegraphics[width=\textwidth]{Figures/backwards_tile.pdf}
        \caption{Backward movement}
    \end{subfigure}
    \caption{The proposed framework enables the robot to automatically discover heel-to-toe foot strikes during forward walking and toe-to-heel strikes when moving backward. Shown is an example contact schedule for the right foot when we reach a stable walking gait.}
    \label{fig:banner}
    \vspace{-10pt} 
\end{figure*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Control Approach}\label{sec:control_approach}
We propose a hierarchical approach to solving the whole-body control problem. The main components of our framework are as follows: (i) receive high-level velocity and height commands from user inputs, (ii) generate a reference trajectory using the HLIP model, and (iii) use CI-MPC to vary contact modes from the reference and generate useful whole-body behavior. This proposed control architecture is shown in Fig. \ref{fig:control_architecture}.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{User Commands}
We define a command vector that includes desired Cartesian velocities, $v_{x,d}, v_{y,d}$, in the robot's body frame, $\{B\}$, desired angular velocity about the $z$-axis, $\omega_{z,d}$, and the desired center of mass (COM) height, $z_{0,d}$ in the world frame, $\{W\}$: 
%
\begin{equation} \label{eq:vel_commands}
   \bm c_{d} = 
    \begin{bmatrix}
        v_{x,d} & v_{y,d} & \omega_{z,d} & z_{0,d}
    \end{bmatrix} ^\T
     \in \R^4.
\end{equation}
%
These commands are used to generate a reference trajectory, as described below.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% The continuous phase of the HLIP dynamics are fully characterized by a single support phase (SSP) where one foot is on the ground and the other is swinging. The state of the HLIP in this continuous domain, $\Dcal$, is precisely:
% %
% \begin{equation}
%     \bm x^{\rm H}_{\rm{ssp}} = 
%     \begin{bmatrix}
%         \bm p_{\rm{com}}^{\rm{st}}\\ 
%         \bm v_{\rm{com}}^{\rm{st}}
%     \end{bmatrix}
%     =
%     \begin{bmatrix}
%         \bm p \\
%         \bm v
%     \end{bmatrix}
% \end{equation}
% %
% where the state is the position and velocity of the COM and with respect to the stance foot control frame ($\rm{st}$). It's reset map, $\Delta(\cdot)$, occurs when the stance foot is switched. The reset map is:
% \begin{equation}
%     \Delta \left(
%     \begin{bmatrix}
%         \bm p^{-} \\ \bm v^{-} 
%     \end{bmatrix}
%     \right)
%     =
%     \begin{bmatrix}
%         \bm p^{+} \\ \bm v^{+} 
%     \end{bmatrix}
%     =
%     \begin{bmatrix}
%         \bm p^{-} - \bm u \\ \bm v^{-} 
%     \end{bmatrix}.
% \end{equation}
% where $\bm u$ is the selected step length increment to stabilize the HLIP. 

\subsection{Reference Trajectory Synthesis} \label{sec:ref_gen}
We leverage the HLIP model to synthesize useful references for the joint states that are involved with walking. Specifically, we generate HLIP trajectories that track velocity commands $\bm c_d$ given by the user.

Given the robot's current whole-body state, we extract the initial center of mass state, $\bm{x}_0^{\rm{R}}$, which is then used to flow \eqref{eq:hlip_hc} forward in time and obtain $\chi(\bm{x}_0^{\rm{R}})$. The set of continuous solutions, $(\Lambda, I, C)$, provides a stable COM trajectory, but to obtain useful whole body references, we embed the HLIP onto the full body 3D robot kinematics, i.e., we formulate an error tracking problem:
%
\begin{equation} \label{eq:IK_outputs}
    \bm y =
    \underbrace{
    \begin{bmatrix}
        z^{a}_{\rm{com}} \\
        \bs q^{a}_{\rm{torso}} \\
        \bm p^{a}_{\rm{sw}} \\
        \bs q^{a}_{\rm{sw}}
    \end{bmatrix}
    }_{\bm y^a}
    -
    \underbrace{
    \begin{bmatrix}
        z^{d}_{\rm{com}} \\
        \bs q^{d}_{\rm{torso}} \\
        \bm p^{d}_{\rm{sw}} \\
        \bs q^{d}_{\rm{sw}}
    \end{bmatrix}
    }_{\bm y^d}
\end{equation}
%
where $(\cdot)^{a}$ and $(\cdot)^{d}$ denote the actual and desired outputs, $z_{\rm{com}}$ is the center of mass height, $\bs  q_{\rm{torso}}$ is the quaternion orientation of the torso, $\bm p_{\rm{sw}}$ is the desired position of the swing foot, and $\bs q_{\rm{sw}}$ is the quaternion orientation of the swing foot. These coordinates are defined with respect to the stance foot frame. The task of driving $\bm y \rightarrow \bm 0$ is achieved via inverse kinematics (IK) which is computed efficiently through the analytical solution. 

As in Section \ref{sec:cimpc}, we discretize the trajectory and solve $N$ inverse kinematics problems:
%
\begin{equation}\label{eq:inv_kin}
    \bm q^\ell_k = \mathrm{InvKin}(\bm y^d_k), \quad k = 0, 1, \dots, N,
\end{equation}
%
where $(\cdot)^{\ell}$ denotes the indices of the legs. We obtain leg velocities via finite differences, e.g., 
\begin{equation}
    \bm v^\ell_k = \frac{\bm q^\ell_{k+1} - \bm q^\ell_{k}}{\Delta t}. 
\end{equation}
For the torso coordinates, we propagate an upright configuration tracking the user commands \eqref{eq:vel_commands}. We found that this was more effective than tracking the torso reference from HLIP and inverse kinematics \eqref{eq:inv_kin}. The arm reference was fixed in the initial stationary position at all times. Altogether, this results in an HLIP-based reference for the full system state at each timestep, which we denote $\{ \bm x_{\rm{H}} \}_k$.

%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Trajectory Combinations}

To allow gradual transitions between standing and walking, we combine a stable standing reference with the HLIP reference described above. At each MPC replanning iteration, the reference is given by
\begin{equation} \label{ref_combo}
    \{\bm x_{\rm{ref}}\}_k = \alpha \{\bm x_{\rm H}\}_k + (1 - \alpha) \{\bm x_{\rm S}\}_k, 
\end{equation}
where $\{\bm x_{\rm S}\}_k$ is a statically standing trajectory. The scalar $\alpha : \R \rightarrow (0,1)$ weighs the relative importance of the two references, and is defined as
%
\begin{equation} \label{eq:activation}
\alpha(\phi) = \frac{1}{2} \rm{tanh}(\rho_1(\phi - \rho_2)) + \frac{1}{2},
\end{equation}
%
where $\rho_1, \rho_2$ are constants and $\phi$ is a function of the commanded velocity, $\bm c_d$, and the current base velocity $\bm v^b$:
%
\begin{equation}
    \phi = \left\|
    \begin{bmatrix}
        \bm c_d^\T & \bm v_b^\T
    \end{bmatrix} ^\T
    \right\|_{\bm P}^2.
\end{equation}
%
The norm-defining matrix
\begin{align}
    \bm P &= \mathrm{diag}\Big(
    [v_{x,\mathrm{max}}^{-2}, v_{y,\mathrm{max}}^{-2}, \omega_{z,\mathrm{max}}^{-2}, \\
    &\hspace{1.4cm} z_{0,\mathrm{min}}^{-2}, (v_{x,\mathrm{max}}^b)^{-2}, (v_{y,\mathrm{max}}^b)^{-2}]
    \Big) \nn
\end{align}
specifies a threshold for each component. Here, when one of the velocity components reaches its respective threshold, the weighted norm maps to one. Note that $\phi$ can reach values beyond 1 when multiple velocity components are active simultaneously, but $\alpha(\phi)$ is bounded to $(0, 1)$ by construction.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
\subsection{Contact-Implicit Model Predictive Control} \label{sec:idto}
%
The blended reference $\{ \bm x_{\rm{ref}}\}_k$ captures leg motion, but does not include useful arm motions and may not be dynamically feasible. CI-MPC takes this reference and generates control actions to track $\{ \bm x_{\rm{ref}}\}_k$ as described in Section~\ref{sec:cimpc}, generating new arm motions and deviating from the nominal contact schedule as needed. 
%
\subsection{Low-level Control}
%
CI-MPC outputs an optimal sequence of configurations $\{\bm q^*\}$, however, by construction of the problem, we obtain the optimal velocities via backward difference and the optimal torques via inverse dynamics,
\begin{equation*}
    \{\bm q^*\}_k 
    \quad
    \implies
    \quad 
    \{\bm v^* \}_k, \{\bm u^*\}_k.
\end{equation*}
%
From here, the solution is interpolated at a higher frequency to obtain the total low-level control input sent to the robot:
%
\begin{equation}
    \bm u_{\rm{tot}} = \bm u^* + \bm K_p (\bm q_j - \bm q_j^*) + \bm K_d (\bm v_j - \bm v^*_j),
\end{equation}
where $\bm u^*$ is the feed forward term, and $\bm K_{p}$ and $\bm K_{d}$ are PD gains that track the interpolated reference joint positions and velocities $(\bm \{\bm q^*_j\}_k, \{\bm v^*_j\}_k)$.
%