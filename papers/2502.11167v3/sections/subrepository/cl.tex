\subsection{CL}

\begin{table}[!ht]
  \centering
  \caption{Language usage count across different categories in the CL subset.}
  \label{tab:cl_language_usage}
  \begin{tabular}{lccc}
      \toprule
      Python & C++ & JavaScript \\
      \midrule
       50     & 51  & 49         \\
      \bottomrule
  \end{tabular}
\end{table}

\begin{table}[!ht]
  \centering
  \caption{Details of problems in different languages and different difficulty levels.}
  \label{tab:stat:2}
      \begin{tabular}{cccc}
\toprule
\textbf{Difficulty} & JavaScript & CPP & Python \\
\midrule
1 & 10 & 11 & 11 \\
2 & 6 & 4 & 6 \\
3 & 12 & 14 & 12 \\
4 & 8 & 8 & 9 \\
5 & 13 & 14 & 12 \\
\bottomrule
\end{tabular}
\end{table}

In CL, we selected competition problems of varying difficulty, each with solutions in Python, C++, and JavaScript. You can see the distribution of language in Table \ref{tab:cl_language_usage}, and the distribution of problem difficulty in Table \ref{tab:stat:2}. This selection allows us to test the model's cross-language capabilities and its ability to handle problems of different difficulty levels.

% \input{sections/subrepository/subrepo-tables/table_cl}

\subsubsection{System Prompts}


\paragraph{Zero-shot Chain-of-Thought:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
Given the following code, what is the execution result?
You should think step by step.  Your answer should be in the following format:
Thought: <your thought>
Output:
<execution result>
\end{lstlisting}
\end{tcolorbox}




\paragraph{Zero-shot:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
Given the following code, what is the execution result?
Your answer should be in the following format:
Output:
<execution result>
\end{lstlisting}
\end{tcolorbox}




\paragraph{Few-shot Chain-of-Thought:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
Given the following code, what is the execution result?
You should think step by step.  Your answer should be in the following format:
Thought: <your thought>
Output:
<execution result>
Following are 3 examples: 
{{examples here}}

\end{lstlisting}
\end{tcolorbox}





\subsubsection{Demo Questions}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
class TreeNode {
  constructor(val) {
    this.val = val;
    this.left = this.right = null;
  }
}

function maxDepth(root) {
  if (!root) return 0;
  const queue = [root, null];
  let depth = 1;

  while (queue.length > 0) {
    const node = queue.shift();
    if (node === null) {
      if (queue.length === 0) return depth;
      depth++;
      queue.push(null);
      continue;
    }
    if (node.left) queue.push(node.left);
    if (node.right) queue.push(node.right);
  }

  return depth;
}

// Test case
const root = new TreeNode(3);
root.left = new TreeNode(9);
root.right = new TreeNode(20);
root.right.left = new TreeNode(15);
root.right.right = new TreeNode(7);
console.log(maxDepth(root));
\end{lstlisting}
\end{tcolorbox}



\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
from collections import Counter
class Solution:
    def maxScoreWords(self, words, letters, score):
        self.ans = 0
        words_score = [sum(score[ord(c)-ord('a')] for c in word) for word in words]
        words_counter = [Counter(word) for word in words]

        def backtrack(start, cur, counter):
            if start > len(words):
                return
            self.ans = max(self.ans, cur)
            for j, w_counter in enumerate(words_counter[start:], start):
                if all(n <= counter.get(c,0) for c,n in w_counter.items()):
                    backtrack(j+1, cur+words_score[j], counter-w_counter)

        backtrack(0, 0, Counter(letters))
        return self.ans

solution = Solution()
print(solution.maxScoreWords(["dog","cat","dad","good"], ["a","a","c","d","d","d","g","o","o"], [1,0,9,5,0,0,3,0,0,0,0,0,0,0,2,0,0,0,0,0,0,0,0,0,0,0]))
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
#include <iostream>
#include <unordered_map>
#include <string>
using namespace std;

int findTheLongestSubstring(string s) {
    unordered_map<char, int> mapper = {{'a', 1}, {'e', 2}, {'i', 4}, {'o', 8}, {'u', 16}};
    unordered_map<int, int> seen;
    seen[0] = -1;
    int max_len = 0, cur = 0;

    for(int i = 0; i < s.size(); ++i){
        if(mapper.find(s[i]) != mapper.end()){
            cur ^= mapper[s[i]];
        }
        if(seen.find(cur) != seen.end()){
            max_len = max(max_len, i - seen[cur]);
        } else {
            seen[cur] = i;
        }
    }

    return max_len;
}

// Test case
class Solution {
public:
    void solve() {
        string input = "eleetminicoworoep";
        cout << findTheLongestSubstring(input) << endl; // Expected output: 13
    }
};

int main(){
    Solution sol;
    sol.solve();
    return 0;
}
\end{lstlisting}
\end{tcolorbox}


\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
class TreeNode {
    constructor(val) {
        this.val = val;
        this.left = this.right = null;
    }
}

function backtrack(root, sum, res, tempList) {
    if (root === null) return;
    if (root.left === null && root.right === null && sum === root.val)
        return res.push([...tempList, root.val]);

    tempList.push(root.val);
    backtrack(root.left, sum - root.val, res, tempList);
    backtrack(root.right, sum - root.val, res, tempList);
    tempList.pop();
}

function pathSum(root, sum) {
    if (root === null) return [];
    const res = [];
    backtrack(root, sum, res, []);
    return res;
}

// Test case setup
const root = new TreeNode(5);
root.left = new TreeNode(4);
root.right = new TreeNode(8);
root.left.left = new TreeNode(11);
root.right.left = new TreeNode(13);
root.right.right = new TreeNode(4);
root.left.left.left = new TreeNode(7);
root.left.left.right = new TreeNode(2);
root.right.right.left = new TreeNode(5);
root.right.right.right = new TreeNode(1);

console.log(pathSum(root, 22));
\end{lstlisting}
\end{tcolorbox}



\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
class TrieNode {
    constructor() {
        this.children = {};
        this.isEndOfWord = false;
    }
}

class Trie {
    constructor() {
        this.root = new TrieNode();
    }

    insert(word) {
        let node = this.root;
        for (let char of word) {
            if (!node.children[char]) {
                node.children[char] = new TrieNode();
            }
            node = node.children[char];
        }
        node.isEndOfWord = true;
    }

    search(stream) {
        let node = this.root;
        for (let char of stream) {
            if (!node.children[char]) {
                return false;
            }
            node = node.children[char];
            if (node.isEndOfWord) {
                return true;
            }
        }
        return false;
    }
}

class StreamChecker {
    constructor(words) {
        this.trie = new Trie();
        this.stream = [];

        for (let word of [...new Set(words)]) {
            this.trie.insert(word.split('').reverse().join(''));
        }
    }

    query(letter) {
        this.stream.unshift(letter);
        return this.trie.search(this.stream);
    }
}

// Test case
const streamChecker = new StreamChecker(["cd", "f", "kl"]);
console.log(streamChecker.query('a')); // false
console.log(streamChecker.query('b')); // false
console.log(streamChecker.query('c')); // false
console.log(streamChecker.query('d')); // true
console.log(streamChecker.query('e')); // false
console.log(streamChecker.query('f')); // true
console.log(streamChecker.query('g')); // false
console.log(streamChecker.query('h')); // false
console.log(streamChecker.query('i')); // false
console.log(streamChecker.query('j')); // false
console.log(streamChecker.query('k')); // false
console.log(streamChecker.query('l')); // true
\end{lstlisting}
\end{tcolorbox}