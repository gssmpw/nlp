\subsection{RL}


\begin{table}[!ht]
  \centering
  \caption{Language usage count across different categories in the RL subset.}
  \label{tab:rl_language_usage}
  \begin{tabular}{lcc}
      \toprule
       Python & C++  \\
      \midrule
       24     & 36   \\
      \bottomrule
  \end{tabular}
\end{table}

In RL, the distribution of programming language usage is shown in Table \ref{tab:rl_language_usage}. We utilized five GitHub repositories for this study, consisting of two Python projects and three C++ projects. Each repository contains a set of ten or more test cases, providing a diverse set of data for evaluation across different programming languages.

\subsubsection{System Prompts}


\paragraph{Zero-shot Chain-of-Thought:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
You will be given a github repository and a function that generates a latex file with this repo. Your task is to predict the content of the latex file generated by the function.
You should think step by step.  Your answer should be in the following format:
Thought: <your thought>
Output:
<file content>
\end{lstlisting}
\end{tcolorbox}




\paragraph{Zero-shot:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
You will be given a github repository and a function that generates a latex file with this repo. Your task is to predict the content of the latex file generated by the function.
Your answer should be in the following format:
Output:
<file content>
\end{lstlisting}
\end{tcolorbox}




\paragraph{Few-shot Chain-of-Thought:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
You will be given a github repository and a function that generates a latex file with this repo. Your task is to predict the content of the latex file generated by the function.
You should think step by step.  Your answer should be in the following format:
Thought: <your thought>
Output:
<file content>
Following is one example:  
{{examples here}}

\end{lstlisting}
\end{tcolorbox}





\subsubsection{Demo Questions}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
main.cpp:<start_file>#include <iostream>
#include <vector>
#include <utility>
#include <stdlib.h>
#include <time.h>
#include <unistd.h>
#include <fstream>
#include <map>
using namespace std;

typedef vector<vector<char> > Board;

const int N = 9;

class SudokuPlayer
{
private:
    // 使用位运算来表示某个数是否出现过
    int rowUsed[N];
    int columnUsed[N];
    int blockUsed[N];

public:
    vector<Board> result;
    vector<pair<int, int> > spaces;

public:
    SudokuPlayer()
    {
        initState();
    }

    void initState()
    {
        memset(rowUsed, 0, sizeof(rowUsed));
        memset(columnUsed, 0, sizeof(columnUsed));
        memset(blockUsed, 0, sizeof(blockUsed));
        spaces.clear();
        result.clear();
    }

    void addResult(Board &board)
    {
        vector<vector<char> > obj(board);
        result.push_back(obj);
    }

    void flip(int i, int j, int digit)
    {
        rowUsed[i] ^= (1 << digit);
        columnUsed[j] ^= (1 << digit);
        blockUsed[(i / 3) * 3 + j / 3] ^= (1 << digit);
    }

    vector<Board> solveSudoku(Board board)
    {
        initState();
        for (int i = 0; i < N; i++)
        {
            for (int j = 0; j < N; j++)
            {
                if (board[i][j] == '$')
                {
                    spaces.push_back(pair<int, int>(i, j));
                }
                else
                {
                    int digit = board[i][j] - '1';
                    flip(i, j, digit);
                }
            }
        }
        DFS(board, 0);
        return result;
    }

    void DFS(Board &board, int pos)
    {
        if (pos == spaces.size())
        {
            addResult(board);
            return;
        }
        int i = spaces[pos].first;
        int j = spaces[pos].second;
        int mask = ~(rowUsed[i] | columnUsed[j] | blockUsed[(i / 3) * 3 + j / 3]) & 0x1ff;
        int digit = 0;
        while (mask)
        {
            if (mask & 1)
            {
                flip(i, j, digit);
                board[i][j] = '1' + digit;
                DFS(board, pos + 1);
                flip(i, j, digit);
            }
            mask = mask >> 1;
            digit++;
        }
    }

    void getResult()
    {
        for (size_t i = 0; i < result.size(); i++)
        {
            Board board = result[i];
            printBoard(board);
        }
    }

    bool checkBoard(Board &board)
    {
        initState();
        for (int i = 0; i < 9; i++)
        {
            for (int j = 0; j < 9; j++)
            {
                if (board[i][j] != '$')
                {
                    int digit = board[i][j] - '1';
                    if ((rowUsed[i] | columnUsed[j] | blockUsed[(i / 3) * 3 + j / 3]) & (1 << digit))
                    {
                        return false;
                    }
                    flip(i, j, digit);
                }
            }
        }
        return true;
    }

    void printBoard(Board &board)
    {
        for (int i = 0; i < board.size(); i++)
        {
            for (int j = 0; j < board[i].size(); j++)
            {
                cout << board[i][j] << " ";
            }
            cout << "\n";
        }
    }

    Board generateBoard(int digCount)
    {
        vector<vector<char> > board(N, vector<char>(N, '$'));
        vector<int> row = getRand9();
        for (int i = 0; i < 3; i++)
        {
            board[3][i + 3] = row[i] + '1';
            board[4][i + 3] = row[i + 3] + '1';
            board[5][i + 3] = row[i + 6] + '1';
        }
        copySquare(board, 3, 3, true);
        copySquare(board, 3, 3, false);
        copySquare(board, 3, 0, false);
        copySquare(board, 3, 6, false);

        while (digCount)
        {
            int x = rand() % 9;
            int y = rand() % 9;
            if (board[x][y] == '$')
                continue;
            char tmp = board[x][y];
            board[x][y] = '$';

            solveSudoku(board);
            if (result.size() == 1)
            {
                digCount--;
            }
            else
            {
                board[x][y] = tmp;
            }
        }
        // printBoard(board);
        // cout << "spaces " << player.spaces.size() << "\n";
        if (!checkBoard(board))
        {
            cout << "wrong board" << endl;
        }

        return board;
    }

    vector<int> getRand9()
    {
        vector<int> result;
        int digit = 0;
        while (result.size() != 9)
        {
            int num = rand() % 9;
            if ((1 << num) & digit)
            {
                continue;
            }
            else
            {
                result.push_back(num);
                digit ^= (1 << num);
            }
        }
        return result;
    }

    void copySquare(Board &board, int src_x, int src_y, bool isRow)
    {
        int rand_tmp = rand() % 2 + 1;
        int order_first[3] = {1, 2, 0};
        int order_second[3] = {2, 0, 1};
        if (rand_tmp == 2)
        {
            order_first[0] = 2;
            order_first[1] = 0;
            order_first[2] = 1;
            order_second[0] = 1;
            order_second[1] = 2;
            order_second[2] = 0;
        }
        for (int i = 0; i < 3; i++)
        {
            if (isRow)
            {
                board[src_x][i] = board[src_x + order_first[0]][src_y + i];
                board[src_x + 1][i] = board[src_x + order_first[1]][src_y + i];
                board[src_x + 2][i] = board[src_x + order_first[2]][src_y + i];
                board[src_x][i + 6] = board[src_x + order_second[0]][src_y + i];
                board[src_x + 1][i + 6] = board[src_x + order_second[1]][src_y + i];
                board[src_x + 2][i + 6] = board[src_x + order_second[2]][src_y + i];
            }
            else
            {
                board[i][src_y] = board[src_x + i][src_y + order_first[0]];
                board[i][src_y + 1] = board[src_x + i][src_y + order_first[1]];
                board[i][src_y + 2] = board[src_x + i][src_y + order_first[2]];
                board[i + 6][src_y] = board[src_x + i][src_y + order_second[0]];
                board[i + 6][src_y + 1] = board[src_x + i][src_y + order_second[1]];
                board[i + 6][src_y + 2] = board[src_x + i][src_y + order_second[2]];
            }
        }
    }
};

char data[9][9] = {
    {'5', '3', '.', '.', '7', '.', '.', '.', '.'},
    {'6', '.', '.', '1', '9', '5', '.', '.', '.'},
    {'.', '9', '8', '.', '.', '.', '.', '6', '.'},
    {'8', '.', '.', '.', '6', '.', '.', '.', '3'},
    {'4', '.', '.', '8', '.', '3', '.', '.', '1'},
    {'7', '.', '.', '.', '2', '.', '.', '.', '6'},
    {'.', '6', '.', '.', '.', '.', '2', '8', '.'},
    {'.', '.', '.', '4', '1', '9', '.', '.', '5'},
    {'.', '.', '.', '.', '8', '.', '.', '7', '9'}};

void test()
{
    SudokuPlayer player;
    vector<vector<char> > board(N, vector<char>(N, '.'));

    for (int i = 0; i < board.size(); i++)
    {
        for (int j = 0; j < board[i].size(); j++)
        {
            board[i][j] = data[i][j];
        }
    }
    bool check = player.checkBoard(board);
    if (check)
        cout << "checked" << endl;

    player.solveSudoku(board);
    player.getResult();

    cout << endl;
}

vector<Board> readFile(string filePath)
{
    ifstream infile;
    vector<Board> boards;
    infile.open(filePath);
    char data[100];
    Board tmp;
    vector<char> row;
    while (!infile.eof())
    {
        infile.getline(data, 100);
        if (data[0] == '-')
        {
            boards.push_back(Board(tmp));
            tmp.clear();
            continue;
        }
        for (int i = 0; i < strlen(data); i++)
        {
            if (('1' <= data[i] && data[i] <= '9') || data[i] == '$')
            {
                row.push_back(data[i]);
            }
        }
        tmp.push_back(vector<char>(row));
        row.clear();
    }
    infile.close();
    return boards;
}

void writeFile(vector<Board> boards, ofstream &f)
{
    for (int k = 0; k < boards.size(); k++)
    {
        for (int i = 0; i < boards[k].size(); i++)
        {
            for (int j = 0; j < boards[k][i].size(); j++)
            {
                f << boards[k][i][j] << " ";
            }
            f << "\n";
        }
        f << "------- " << k << " -------" << endl;
    }
}

// 解析输入参数
map<char, string> parse(int argc, char *argv[])
{
    map<char, string> params;
    int compeleteBoardCount, gameNumber, gameLevel;
    vector<int> range;
    string inputFile;
    char opt = 0;
    while ((opt = getopt(argc, argv, "c:s:n:m:r:u")) != -1)
    {
        switch (opt)
        {
        case 'c':
            compeleteBoardCount = atoi(optarg);
            if (compeleteBoardCount < 1 || compeleteBoardCount > 1000000)
            {
                printf("生成数独终盘数量范围在1～1000000之间\n");
                exit(0);
            }
            params[opt] = string(optarg);
            break;
        case 's':
            inputFile = string(optarg);
            if (access(optarg, 0) == -1)
            {
                printf("file does not exist\n");
                exit(0);
            }
            params[opt] = string(optarg);
            break;
        case 'n':
            gameNumber = atoi(optarg);
            if (gameNumber < 1 || gameNumber > 10000)
            {
                printf("生成数独游戏数量范围在1～10000之间\n");
                exit(0);
            }
            params[opt] = string(optarg);
            break;
        case 'm':
            gameLevel = atoi(optarg);
            if (gameLevel < 1 || gameLevel > 3)
            {
                printf("生成游戏难度的范围在1～3之间\n");
                exit(0);
            }
            params[opt] = string(optarg);
            break;
        case 'r':
            char *p;
            p = strtok(optarg, "~");
            while (p)
            {
                range.push_back(atoi(p));
                p = strtok(NULL, "~");
            }
            if (range.size() != 2)
            {
                printf("请输入一个范围参数\n");
                exit(0);
            }
            if ((range[0] >= range[1]) || range[0] < 20 || range[1] > 55)
            {
                printf("请输入合法范围20～55\n");
                exit(0);
            }
            params[opt] = string(optarg);
            break;
        case 'u':
            params[opt] = string();
            break;
        default:
            printf("请输入合法参数\n");
            exit(0);
            break;
        }
    }
    return params;
}

void generateGame(int gameNumber, int gameLevel, vector<int> digCount, ofstream &outfile, SudokuPlayer &player)
{
    for (int i = 0; i < gameNumber; i++)
    {
        int cnt = 0;
        if (digCount.size() == 1)
        {
            cnt = digCount[0];
        }
        else
        {
            cnt = rand() % (digCount[1] - digCount[0] + 1) + digCount[0];
        }
        Board b = player.generateBoard(cnt);
        vector<Board> bs;
        bs.push_back(b);
        writeFile(bs, outfile);
    }
    outfile.close();
}

int main(int argc, char *argv[])
{
    srand((unsigned)time(NULL));
    SudokuPlayer player;

    map<char, string> params = parse(argc, argv);
    map<char, string>::iterator it, tmp;

    int opt = 0;

    vector<int> range;
    int gameNumber;
    int gameLevel = 0;
    int solution_count = 0;

    vector<Board> boards;
    ofstream outfile;

    it = params.begin();
    while (it != params.end())
    {
        switch (it->first)
        {
        case 'c':
            outfile.open("game.txt", ios::out | ios::trunc);
            range.push_back(0);
            generateGame(atoi(it->second.c_str()), 0, range, outfile, player);
            range.clear();
            break;

        case 's':
            outfile.open("sudoku.txt", ios::out | ios::trunc);
            boards = readFile(it->second);
            for (int i = 0; i < boards.size(); i++)
            {
                vector<Board> result = player.solveSudoku(boards[i]);
                writeFile(result, outfile);
            }
            outfile.close();
            break;

        case 'n':
        case 'm':
        case 'r':
        case 'u':
            tmp = params.find('n');
            if (tmp == params.end())
            {
                printf("缺少参数 n \n");
                exit(0);
            }

            gameNumber = atoi(tmp->second.c_str());

            tmp = params.find('u');
            if (tmp != params.end())
            {
                solution_count = 1;
            }

            tmp = params.find('m');
            if (tmp != params.end())
            {
                gameLevel = atoi(tmp->second.c_str());
            }

            tmp = params.find('r');
            if (tmp != params.end())
            {
                char *p;
                char *pc = new char[100];
                strcpy(pc, tmp->second.c_str());
                p = strtok(pc, "~");
                while (p)
                {
                    range.push_back(atoi(p));
                    p = strtok(NULL, "~");
                }
            }
            else
            {
                // 根据不同级别采取挖空数量不同
                if (gameLevel == 1)
                {
                    range.push_back(20);
                    range.push_back(30);
                }
                else if (gameLevel == 2)
                {
                    range.push_back(30);
                    range.push_back(40);
                }
                else if (gameLevel == 3)
                {
                    range.push_back(40);
                    range.push_back(55);
                }
                else
                {
                    range.push_back(20);
                    range.push_back(55);
                }
            }

            outfile.open("game.txt", ios::out | ios::trunc);
            generateGame(gameNumber, gameLevel, range, outfile, player);
            range.clear();
            break;
        }
        // cout << it->first << ' ' << it->second << endl;
        it++;
    }

    return 0;
}<end_file>;game.txt:<start_file><9 $ 5 $ 3 $ 7 1 2 
$ 1 2 $ $ 8 3 $ $ 
$ $ $ 2 7 $ 9 8 5 
8 $ 9 $ 6 $ 1 2 7 
1 $ $ $ 5 $ $ 6 3 
4 6 3 1 2 7 $ $ $ 
$ $ 8 3 4 6 2 7 1 
2 7 $ $ $ $ $ 3 $ 
$ 3 4 $ 1 $ $ $ 8 
------- 0 -------<endfile>
\end{lstlisting}
\end{tcolorbox}



\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
Here is the code repository:Cow.cpp:<start_file>#include "Cow.h"
Cow::Cow(std::string a,int b,int c,int d){
    name=a;
    l=b;
    u=c;
    m=d;
    in=0;
    state=0;
}<endfile>Cow.h:<start_file>#pragma once
#include <string>
class Cow{
    public:
    std::string name;
    int l,u,m;
    int in;
    int state;
    Cow(){}
    Cow(std::string a,int b,int c,int d);
};<endfile>Farm.cpp:<start_file>#include "Farm.h"
Farm::Farm(int a){
    n=a;
    num=0;
    cow=new Cow[a];
    milk=0;
}
void Farm::addCow(Cow a){
        cow[num]=a;
        num+=1;
    }
void Farm::supply(std::string a,int b){
    for(int i=0;i<n;i++){
        if(cow[i].name==a){
            cow[i].in+=b;
            break;
        }
    }
}
void Farm::startMeal(){
    for(int i=0;i<n;i++){
        if(cow[i].in==0)
        cow[i].state=0;
        if(cow[i].in>0&&cow[i].in<cow[i].l){
            cow[i].state=1;
            cow[i].in=0;
        }
        if(cow[i].in>=cow[i].l){
            cow[i].state=2;
            if(cow[i].in<=cow[i].u)
            cow[i].in=0;
            if(cow[i].in>cow[i].u)
            cow[i].in-=cow[i].u;
        }
    }
}
void Farm::produceMilk(){
    for(int i=0;i<n;i++){
        if(cow[i].state==0){
            milk+=0;
            continue;
        }
        if(cow[i].state==1){
            milk+=cow[i].m*0.5;
            continue;
        }
        if(cow[i].state==2){
            milk+=cow[i].m;
            continue;
        }
    }
}
float Farm::getMilkProduction(){
    return milk;
}<endfile>Farm.h:<start_file>#pragma once
#include"Cow.h"
class Farm{
    int n;
    int num;
    Cow* cow;
    public:
    float milk;
    Farm(int a);
    void addCow(Cow a);
    void supply(std::string a,int b);
    void startMeal();
    void produceMilk();
    float getMilkProduction();
    ~Farm(){
        delete[] cow;
    }
};<endfile>main.cpp:<start_file>#include <iostream>
#include <string>
#include "Cow.h"
#include "Farm.h"
using namespace std;

int main(){
    int n;
    cin >> n;
    Farm farm(n);
    string name;
    int l, u, m;
    for(int i = 0; i < n; ++i){
        cin >> name >> l >> u >> m;
        Cow cow(name, l, u, m);
        farm.addCow(cow);
    }

    int k;
    cin >> k;
    int t;
    int a;
    for(int i = 0; i < k; ++i){
        cin >> t;
        for(int j = 0; j < t; ++j){
            cin >> name >> a;
            farm.supply(name, a);
        }
        farm.startMeal();
        farm.produceMilk();
    }
    printf("%.1f", farm.getMilkProduction());
    return 0;
}<endfile>makefile:<start_file>main:main-3.o Farm.o Cow.o
	g++ main-3.o Farm.o Cow.o -o main

main-3.o:main-3.cpp Farm.h Cow.h
	g++ -c main-3.cpp -o main-3.o

Farm.o:Farm.cpp Farm.h Cow.h
	g++ -c Farm.cpp  -o Farm.o

Cow.o:Cow.cpp Cow.h
	g++ -c Cow.cpp  -o Cow.o

clean:
	rm *.o main<endfile>, and the input file is:./input/11.txt:<start_file>3
a 2 5 6
b 3 4 7
c 1 6 5
2
1 a 3
2 b 2 c 4<enfile>
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
Given the following code, what is the execution result? The file is under `/app/` directory, and is run with "python3 /app/test.py" if it is a python file, "g++ -std=c++11 /app/test.cpp -o /app/test
/app/test" if it is a cpp file, and "javac /app/\{class_name\}.java
java -cp /app \{class_name\}" if it is a java file.
You should think step by step.  Your answer should be in the following format:
Thought: <your thought>
Output:
<execution result>
\end{lstlisting}
\end{tcolorbox}


\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
Here is the code repository:car.cpp:<start_file>#include "car.h"
#include <iostream>
using namespace std;

Car::Car(int num,string eng):Vehicle(num,eng){}

void Car::describe(){
    cout<<"Finish building a car with "<<wheel.get_num()<<" wheels and a "<<engine.get_name()<<" engine."<<endl;
    cout<<"A car with "<<wheel.get_num()<<" wheels and a "<<engine.get_name()<<" engine."<<endl;
}

<endfile>car.h:<start_file>#pragma once
#include "vehicle.h"
using namespace std;

class Car: public Vehicle{
    public:
    Car(int num, string eng);
    void describe();
};<endfile>engine.cpp:<start_file>#include "engine.h"

Engine::Engine(string nam): name(nam) {
	cout << "Using "  << nam << " engine."<< endl;
}

string Engine::get_name() {
	return name;
}
<endfile>engine.h:<start_file>#pragma once
#include <iostream>
#include <string>
using namespace std;

class Engine {
	string name;
public:
	Engine(string);
	string get_name();
};<endfile>main.cpp:<start_file>
#include <iostream>
#include <string>
#include "wheel.h"
#include "engine.h"
#include "vehicle.h"
#include "motor.h"
#include "car.h"
using namespace std;

int main() {
	int n, type, num;
	string engine;

	cin >> n; 
	for (int i=0; i<n; i++) {
		cin >> type >> num >> engine;
		switch (type) {
			case 0: {
				Vehicle v = Vehicle(num, engine);
				v.describe();
				break;
			}
			case 1: {
				Motor m = Motor(num, engine);
				m.describe();
				m.sell();
				break;
			}
			case 2: {
				Car c = Car(num, engine);
				c.describe();
				break;
			}
		}
	}
	return 0;
}<endfile>motor.cpp:<start_file>#include "motor.h"
#include <iostream>
using namespace std;
Motor::Motor(int num,string eng):Vehicle(num,eng){}

void Motor::describe(){
    cout<<"Finish building a motor with "<<wheel.get_num()<<" wheels and a "<<engine.get_name()<<" engine."<<endl;
    cout<<"A motor with "<<wheel.get_num()<<" wheels and a "<<engine.get_name()<<" engine."<<endl;
}

void Motor::sell(){
    cout<<"A motor is sold!"<<endl;
}<endfile>motor.h:<start_file>#pragma once
#include "vehicle.h"
using namespace std;

class Motor: public Vehicle{
    public:
    Motor(int num, string eng);
    void describe();
    void sell();
};<endfile>vehicle.cpp:<start_file>#include "vehicle.h"
#include <iostream>
using namespace std;

Vehicle::Vehicle(int num,string eng):engine(eng),wheel(num){}

void Vehicle::describe(){
    cout<<"Finish building a vehicle with "<<wheel.get_num()<<" wheels and a "<<engine.get_name()<<" engine."<<endl;
    cout<<"A vehicle with "<<wheel.get_num()<<" wheels and a "<<engine.get_name()<<" engine."<<endl;
}<endfile>vehicle.h:<start_file>#pragma once
#include "wheel.h"
#include "engine.h"

using namespace std;

class Vehicle{
    public:
    Engine engine;
    Wheel wheel;
    Vehicle(int num, string eng);
    void describe();

};<endfile>wheel.cpp:<start_file>#include "wheel.h"

Wheel::Wheel(int num): number(num) {
	cout << "Building " << number << " wheels." << endl;
}

int Wheel::get_num() {
	return number;
}<endfile>wheel.h:<start_file>#pragma once
#include <iostream>
using namespace std;

class Wheel {
	int number;
public:
	Wheel(int);
	int get_num();
};<endfile>, and the input file is:./input/6.txt:<start_file>4
0 3 Gasoline
2 4 Hybrid
1 2 Electric
0 6 Magic<enfile>
\end{lstlisting}
\end{tcolorbox}



\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
Here is the code repository:24_game.py:<start_file>import itertools
import time
import math

# Operators
OP_CONST = 0  # Constant
OP_ADD = 1  # Addition
OP_SUB = 2  # Subtraction
OP_MUL = 3  # Multiplication
OP_DIV = 4  # Divition
OP_POW = 5  # Exponentiation

OP_SQRT = 6  # Squreroot
OP_FACT = 7  # Factorial
OP_LOG = 8  # Logarithm
OP_C = 9  # Combinations
OP_P = 10  # Permutations

# List of basic operators
operators = [OP_ADD,
             OP_SUB,
             OP_MUL,
             OP_DIV]

# List of advanced operators
advanced_operators = [OP_POW,
                      OP_LOG,
                      OP_C,
                      OP_P]

# List of unary operators
_unary_operators = [OP_SQRT,
                    OP_FACT]

# List of enabled unary operators
unary_operators = []

# Symbol of operators
symbol_of_operator = {OP_ADD: "%s+%s",
                      OP_SUB: "%s-%s",
                      OP_MUL: "%s*%s",
                      OP_DIV: "%s/%s",
                      OP_POW: "%s^%s",
                      OP_SQRT: "sqrt(%s)",
                      OP_FACT: "%s!",
                      OP_LOG: "log_%s(%s)",
                      OP_C: "C(%s, %s)",
                      OP_P: "P(%s, %s)"}

# Priority of operators
priority_of_operator = {OP_ADD: 0,
                        OP_SUB: 0,
                        OP_MUL: 1,
                        OP_DIV: 1,
                        OP_POW: 2,
                        OP_LOG: 3,
                        OP_C: 3,
                        OP_P: 3,
                        OP_SQRT: 3,
                        OP_FACT: 4,
                        OP_CONST: 5}

# Whether operator is commutative
is_operator_commutative = {OP_ADD: True,
                           OP_SUB: False,
                           OP_MUL: True,
                           OP_DIV: False,
                           OP_POW: False,
                           OP_LOG: False,
                           OP_C: False,
                           OP_P: False}

# Whether inside bracket is needed when rendering
need_brackets = {OP_ADD: True,
                 OP_SUB: True,
                 OP_MUL: True,
                 OP_DIV: True,
                 OP_POW: True,
                 OP_FACT: True,
                 OP_SQRT: False,
                 OP_LOG: False,
                 OP_C: False,
                 OP_P: False}


def permutation(n, k):
    return math.factorial(n)/math.factorial(k)


def combination(n, k):
    return permutation(n, k)/math.factorial(n-k)


def evaluate_operation(op, a, b=None):
    """
    Evaluate an operation on a and b.
    """
    if op == OP_ADD: return a + b
    if op == OP_SUB: return a - b
    if op == OP_MUL: return a * b

    try:
        if op == OP_POW and abs(a) < 20 and abs(b) < 20:
            return a ** b

        if op == OP_FACT and a < 10:
            return math.factorial(a)

        if op == OP_C and 0 < b <= a <= 13:
            return combination(a, b)

        if op == OP_P and 0 < b <= a <= 13:
            return permutation(a, b)

        if op == OP_SQRT and a < 1000000:
            return math.sqrt(a)

        if op == OP_DIV: return a / b
        if op == OP_LOG: return math.log(b, a)
    except (ZeroDivisionError, ValueError, TypeError):
        pass
    except OverflowError:
        print(a, b)

    return float("NaN")


def fit_to_int(x, eps=1e-9):
    """
    Convert x to int if x is close to an integer.
    """
    try:
        if abs(round(x) - x) <= eps:
            return round(x)
        else:
            return x
    except ValueError:
        return float("NaN")
    except TypeError:
        return float("NaN")


class Node:
    def __init__(self, value=None, left=None, right=None, op=OP_CONST):
        if op not in unary_operators \
                and op != OP_CONST and is_operator_commutative[op] \
                and str(left) > str(right):
            left, right = right, left

        self._value = value
        self._str_cache = None
        self.left = left
        self.right = right
        self.op = op

    @property
    def value(self):
        if self._value is None:
            assert self.op != OP_CONST

            if self.op in unary_operators:
                self._value = evaluate_operation(self.op, self.left.value)
            else:
                self._value = evaluate_operation(self.op, self.left.value, self.right.value)

            self._value = fit_to_int(self._value)
        return self._value

    def __str__(self):
        if self._str_cache is None:
            self._str_cache = self._str()
        return self._str_cache

    def _str(self):
        # Constant
        if self.op == OP_CONST:
            return str(self._value)

        # Unary operator
        elif self.op in unary_operators:
            str_left = str(self.left)

            if need_brackets[self.op] \
                    and priority_of_operator[self.left.op] < priority_of_operator[self.op]:
                str_left = "(" + str_left + ")"

            return symbol_of_operator[self.op] % str_left

        # Other operator
        else:
            str_left = str(self.left)
            str_right = str(self.right)

            # Add brackets inside
            if need_brackets[self.op] \
                    and priority_of_operator[self.left.op] < priority_of_operator[self.op]:
                str_left = "(" + str_left + ")"

            if need_brackets[self.op] \
                    and (priority_of_operator[self.right.op] < priority_of_operator[self.op]
                         or (priority_of_operator[self.right.op] == priority_of_operator[self.op]
                             and not is_operator_commutative[self.op])):
                str_right = "(" + str_right + ")"

            # Render
            return symbol_of_operator[self.op] % (str_left, str_right)


def enumerate_nodes(node_list, callback, max_depth):
    # Found an expression
    if len(node_list) == 1:
        callback(node_list[0])

    # Constrain maximum depth
    if max_depth == 0:
        return

    # Non-unary operators
    for left, right in itertools.permutations(node_list, 2):
        new_node_list = node_list.copy()
        new_node_list.remove(left)
        new_node_list.remove(right)

        for op in operators:
            enumerate_nodes(new_node_list + [Node(left=left, right=right, op=op)], callback, max_depth-1)

            if not is_operator_commutative[op] and str(left) != str(right):
                enumerate_nodes(new_node_list + [Node(left=right, right=left, op=op)], callback, max_depth-1)

    # Unary operators
    for number in node_list:
        new_node_list = node_list.copy()
        new_node_list.remove(number)

        for op in unary_operators:
            new_node = Node(left=number, op=op)
            if new_node.value == number.value:
                continue

            enumerate_nodes(new_node_list + [new_node], callback, max_depth-1)


class CallbackFindTarget:
    def __init__(self, target):
        self.target = target
        self.results = []
        self.duplication_count = 0
        self.enumeration_count = 0

    def __call__(self, node):
        if node.value == self.target and str(node) not in self.results:
            print(self.target, "=", node)
            self.results.append(str(node))
        elif node.value == self.target:
            self.duplication_count += 1

        self.enumeration_count += 1

    def show(self, execution_time):
        print()
        print("%d solution(s) in %.3f seconds" % (len(self.results), execution_time))
        print("%d duplication(s)" % self.duplication_count)
        print("%d combination(s)" % self.enumeration_count)


class CallbackAllTarget:
    def __init__(self):
        self.results = {}
        self.enumeration_count = 0

    def __call__(self, node):
        try:
            int(node.value)
        except ValueError:
            return

        if node.value not in self.results \
                and int(node.value) == node.value:
            self.results[node.value] = node

        self.enumeration_count += 1

    def __str__(self):
        string = ""
        for value in sorted(self.results.keys()):
            string += "%d = %s" % (value, str(self.results[value]))
            string += "\n"
        return string

    def show(self, execution_time):
        print(self)
        print()
        print("%d targets(s) in %.3f seconds" % (len(self.results), execution_time))
        print("%d combination(s)" % self.enumeration_count)


def select_yes_no(prompt, default=False):
    answer = input(prompt).strip().lower()
    if answer == "y":
        return True
    if answer == "n":
        return False
    return default


def select_int(prompt, default):
    try:
        return int(input(prompt).strip())
    except ValueError:
        return default


def main():
    global operators
    global unary_operators


    unary_operators_allowed = False
    enumerate_all = False


    if not enumerate_all:
        target = 24
        callback = CallbackFindTarget(target=target)

    if enumerate_all:
        callback = CallbackAllTarget()
    else:
        callback = CallbackFindTarget(target=target)

    with open('input.txt', 'r') as file:
        inputs = [int(i) for line in file for i in line.split() if i != ""]
    node_list = [Node(value=i) for i in inputs]

    enumerate_nodes(node_list, callback, max_depth=len(node_list)-1+unary_operators_allowed)

main()<enfile>, and the input file is: input.txt:<start_file>4 4 7 7<end_file>
\end{lstlisting}
\end{tcolorbox}