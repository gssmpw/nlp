\subsection{TC}

\subsubsection{Tasks Descriptions of Time Consuming~(TC)}
\label{sec:appendix2}

The time consuming component of \bench is comprised of 4 tasks in for computationally expensive areas, covering a spectrum of Linear Algebra, Sorting, Searching, Monte Carlo Simulations and String Matching Programs. Some of these tasks take hours to complete, showing their potential to benchmark LLM's ability to reason through lengthy computations.

\paragraph{Linear Algebra.} In this task, we are focused on acquiring key properties in linear algebra given square matrices of varying sizes. In particular, we query the model on solving LU decomposition, QR decomposition, the largest eigenvalue and eigenvector using the power method, and the inversion matrix.

\paragraph{Sorting And Searching.} We include four classical algorithmic problems in this area, namely Hamiltonian Cycle, Traveling Salesman Problem (TSP), Sorting an array of real numbers and Searching. For Hamiltonian Cycle, we adopt the backtracking algorithm. Specifically, we randomly generate graphs with vertices from 4 to 100 and ask the model to find whether a Hamiltonian cycle exists. For TSP, we implement a naive brute-force algorithm and ask the model to find the length of the optimal path. For Sorting, we adopt the bubble sort, quick sort, and merge sort algorithms. For each algorithm, we consider different list sizes from 5 to 100 and generate 10 test cases for each list size. The evaluation metric is the rank correlation (also Spearman's $\rho$ ). Lastly, for searching, we adopt binary search and query the model on randomly generated lists of varying sizes.
\paragraph{Monte Carlo Estimation.} We adopt Monte Carlo simulation to estimate the values of specific real numbers (e.g. $\pi, e$), as well as a future stock price prediction that follows the Brownian motion. We alter the number of samples used in Monte Carlo estimation, resulting in varying program outcomes.
\paragraph{String Matching Program.} We adopt the naive string matching, KMP, and Rabin-Karp algorithms. For each algorithm, we randomly generate text and pattern with varying lengths, and query the model on the existence and position of the matching.

\subsubsection{Evaluation Metrics}
\label{app:metric2}

\paragraph{Rank Correlation.} 
Rank Correlation~\citep{spearman1904proof}, also referred to as Spearman's $\rho$, is used to assess sorting tasks by measuring the correlation between the estimated ordinal ranking and the ground truth, which can be written as:
\begin{equation}
\text{RankCorr} = \frac{\text{Cov}(x_{1:N}, y_{1:N})}{\sigma(x_{1:N}) \sigma(y_{1:N})}
\end{equation}

where \( x_{1:N} \) and \( y_{1:N} \) denote the true and estimated rankings, respectively, and \( \text{Cov} \) and \( \sigma \) represent the covariance and standard deviation of the respective sequences.


% \input{sections/subrepository/subrepo-tables/table\_tc}


\subsubsection{System Prompts}


\paragraph{Zero-shot Chain-of-Thought:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
You are an expert in string_matching programming.
Please execute the above code with the input provided and return the output. You should think step by step.
Your answer should be in the following format:
Thought: <your thought>
Output: <execution result>
Please follow this format strictly and ensure the Output section contains only the required result without any additional text.
\end{lstlisting}
\end{tcolorbox}




\paragraph{Zero-shot:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
You are an expert in string_matching programming.
Please execute the given code with the provided input and return the output.
Make sure to return only the output in the exact format as expected.

Output Format:
Output: <result>
\end{lstlisting}
\end{tcolorbox}




\paragraph{Few-shot Chain-of-Thought:}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
You are an expert in string_matching programming.
Please execute the above code with the input provided and return the output. You should think step by step.
Your answer should be in the following format:
Thought: <your thought>
Output: <execution result>
Please follow this format strictly and ensure the Output section contains only the required result without any additional text.

Here are some examples:
{{examples here}}

\end{lstlisting}
\end{tcolorbox}





\subsubsection{Demo Questions}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
code:```
import itertools
import math
import sys
import argparse
def euclidean_distance(p1, p2):
    """Calculate the Euclidean distance between two points"""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def tsp_bruteforce(positions):
    """Brute-force TSP solver"""
    n = len(positions)
    min_path = None
    min_distance = float('inf')

    # Generate all possible permutations of the cities (excluding the starting point)
    for perm in itertools.permutations(range(1, n)):
        path = [0] + list(perm)  # Start at city 0
        distance = 0
        # Calculate the total distance of the current permutation
        for i in range(1, len(path)):
            distance += euclidean_distance(positions[path[i-1]], positions[path[i]])

        # Compare the distance with the minimum distance found so far
        if distance < min_distance:
            min_distance = distance
            min_path = path

    return min_path, min_distance

def parse_positions(positions_str):
    """Convert the string input back to a list of tuples"""
    positions = []
    for pos in positions_str.split():
        x, y = map(float, pos.split(','))
        positions.append((x, y))
    return positions

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--vertices", type=int, default=5, help="Number of vertices")
    parser.add_argument("--positions", type=str, default="0,0 1,1 2,2 3,3 4,4", help="List of positions in the format 'x,y'")
    args = parser.parse_args()

    vertices = args.vertices
    positions_str = args.positions
    
    # Parse positions
    positions = parse_positions(positions_str)

    # Solve TSP using brute force
    path, distance = tsp_bruteforce(positions)

    print(f"{distance:.2f}")

if __name__ == "__main__":
    main()

```
command:```
python tsp.py --vertices 3 --positions "8.51,4.18 8.1,7.92 1.57,0.49" 
```
\end{lstlisting}
\end{tcolorbox}



\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
code:```
import itertools
import math
import sys
import argparse
def euclidean_distance(p1, p2):
    """Calculate the Euclidean distance between two points"""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def tsp_bruteforce(positions):
    """Brute-force TSP solver"""
    n = len(positions)
    min_path = None
    min_distance = float('inf')

    # Generate all possible permutations of the cities (excluding the starting point)
    for perm in itertools.permutations(range(1, n)):
        path = [0] + list(perm)  # Start at city 0
        distance = 0
        # Calculate the total distance of the current permutation
        for i in range(1, len(path)):
            distance += euclidean_distance(positions[path[i-1]], positions[path[i]])

        # Compare the distance with the minimum distance found so far
        if distance < min_distance:
            min_distance = distance
            min_path = path

    return min_path, min_distance

def parse_positions(positions_str):
    """Convert the string input back to a list of tuples"""
    positions = []
    for pos in positions_str.split():
        x, y = map(float, pos.split(','))
        positions.append((x, y))
    return positions

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--vertices", type=int, default=5, help="Number of vertices")
    parser.add_argument("--positions", type=str, default="0,0 1,1 2,2 3,3 4,4", help="List of positions in the format 'x,y'")
    args = parser.parse_args()

    vertices = args.vertices
    positions_str = args.positions
    
    # Parse positions
    positions = parse_positions(positions_str)

    # Solve TSP using brute force
    path, distance = tsp_bruteforce(positions)

    print(f"{distance:.2f}")

if __name__ == "__main__":
    main()

```
command:```
python tsp.py --vertices 3 --positions "0.9,2.44 4.67,0.82 3.8,5.73" 
```
\end{lstlisting}
\end{tcolorbox}

\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
code:```
import itertools
import math
import sys
import argparse
def euclidean_distance(p1, p2):
    """Calculate the Euclidean distance between two points"""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def tsp_bruteforce(positions):
    """Brute-force TSP solver"""
    n = len(positions)
    min_path = None
    min_distance = float('inf')

    # Generate all possible permutations of the cities (excluding the starting point)
    for perm in itertools.permutations(range(1, n)):
        path = [0] + list(perm)  # Start at city 0
        distance = 0
        # Calculate the total distance of the current permutation
        for i in range(1, len(path)):
            distance += euclidean_distance(positions[path[i-1]], positions[path[i]])

        # Compare the distance with the minimum distance found so far
        if distance < min_distance:
            min_distance = distance
            min_path = path

    return min_path, min_distance

def parse_positions(positions_str):
    """Convert the string input back to a list of tuples"""
    positions = []
    for pos in positions_str.split():
        x, y = map(float, pos.split(','))
        positions.append((x, y))
    return positions

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--vertices", type=int, default=5, help="Number of vertices")
    parser.add_argument("--positions", type=str, default="0,0 1,1 2,2 3,3 4,4", help="List of positions in the format 'x,y'")
    args = parser.parse_args()

    vertices = args.vertices
    positions_str = args.positions
    
    # Parse positions
    positions = parse_positions(positions_str)

    # Solve TSP using brute force
    path, distance = tsp_bruteforce(positions)

    print(f"{distance:.2f}")

if __name__ == "__main__":
    main()

```
command:```
python tsp.py --vertices 3 --positions "7.63,4.72 1.07,1.42 8.36,5.63" 
```
\end{lstlisting}
\end{tcolorbox}


\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
code:```
import sys
import argparse

def binary_search(arr, target):
    """Binary Search algorithm"""
    low = 0
    high = len(arr) - 1
    
    while low <= high:
        mid = (low + high) // 2  # Find the middle element
        if arr[mid] == target:
            return mid  # Target found at index mid
        elif arr[mid] < target:
            low = mid + 1  # Target is in the right half
        else:
            high = mid - 1  # Target is in the left half
    
    return -1  # Target not found

def parse_input(input_str):
    """Parse input string into a list of integers"""
    return list(map(int, input_str.split()))

def main():
    parser = argparse.ArgumentParser(description="Binary Search Algorithm")
    parser.add_argument('--list', type=str, required=True, help="Input sorted list of integers")
    parser.add_argument('--target', type=int, required=True, help="Target integer to search")
    args = parser.parse_args()
    
    input_list = parse_input(args.list)
    
    result = binary_search(input_list, args.target)
    
    if result != -1:
        print(f"Target found at index: {result}")
    else:
        print("Target not found")

if __name__ == "__main__":
    main()

```
command:```
python binary_search.py --list "-334 -200 180 936 973" --target -771
```
\end{lstlisting}
\end{tcolorbox}



\begin{tcolorbox}[left=0mm,right=0mm,top=0mm,bottom=0mm,boxsep=1mm,arc=0mm,boxrule=0pt, frame empty, breakable]
    \small
    \begin{lstlisting}
code:```
import itertools
import math
import sys
import argparse
def euclidean_distance(p1, p2):
    """Calculate the Euclidean distance between two points"""
    return math.sqrt((p1[0] - p2[0])**2 + (p1[1] - p2[1])**2)

def tsp_bruteforce(positions):
    """Brute-force TSP solver"""
    n = len(positions)
    min_path = None
    min_distance = float('inf')

    # Generate all possible permutations of the cities (excluding the starting point)
    for perm in itertools.permutations(range(1, n)):
        path = [0] + list(perm)  # Start at city 0
        distance = 0
        # Calculate the total distance of the current permutation
        for i in range(1, len(path)):
            distance += euclidean_distance(positions[path[i-1]], positions[path[i]])

        # Compare the distance with the minimum distance found so far
        if distance < min_distance:
            min_distance = distance
            min_path = path

    return min_path, min_distance

def parse_positions(positions_str):
    """Convert the string input back to a list of tuples"""
    positions = []
    for pos in positions_str.split():
        x, y = map(float, pos.split(','))
        positions.append((x, y))
    return positions

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("--vertices", type=int, default=5, help="Number of vertices")
    parser.add_argument("--positions", type=str, default="0,0 1,1 2,2 3,3 4,4", help="List of positions in the format 'x,y'")
    args = parser.parse_args()

    vertices = args.vertices
    positions_str = args.positions
    
    # Parse positions
    positions = parse_positions(positions_str)

    # Solve TSP using brute force
    path, distance = tsp_bruteforce(positions)

    print(f"{distance:.2f}")

if __name__ == "__main__":
    main()

```
command:```
python tsp.py --vertices 10 --positions "6.81,5.28 9.95,8.98 0.63,0.11 8.84,0.55 9.03,9.98 6.22,2.7 2.99,9.11 0.54,9.36 3.08,4.15 5.73,1.86" 
```
\end{lstlisting}
\end{tcolorbox}