\section{Crash-fault tolerant consensus in the \model}\label{sec:crash-fault}

\subsection{Definition}
In the crash-fault model, faulty processes may permanently stop participating in the protocol at any time, but otherwise follow the protocol.
Crash-fault tolerant consensus is defined by the following properties:
\begin{description}
    \item[Validity] If a process decides $v$, then $v$ was proposed by some process. 
    \item[Uniform Agreement] If processes $p$ and $q$ decide $v$ and $w$ respectively, then $v = w$.
    \item[Termination] Every correct process decides some value.
\end{description}

\subsection{Algorithm}

Our algorithm for crash-fault tolerant consensus uses the same round-based structure, shown in \Cref{alg:skeleton}, as our Byzantine consensus algorithm from \Cref{sec:warmup}. We use a different implementation of the \textsc{Round} procedure, shown in \Cref{alg:aac-crash}.

\begin{algorithm}
\caption{Crash-tolerant \textsc{Round} implementation: pseudocode at process $i$}
\label{alg:aac-crash}
\begin{algorithmic} [1]
\State \textbf{procedure} \textsc{Round}$(r,v)$:
\State \hskip1em Send $\langle \textsc{Init}, r, v \rangle$ to all processes\label{line:fac-crash-init}
\BlueComment{Phase 1}
\State \hskip1em Wait for $n-f$ $\langle \textsc{Init}, r,\_ \rangle$ messages\label{line:fac-crash-wait-init}
\State \hskip1em \textbf{if} $\exists\, v^*$ such that I received $\geq f+1$ $\langle \textsc{Init}, r, v^* \rangle$ messages:\label{line:fac-crash-if-init}
\State \hskip2em $proposal \gets v^*$\label{line:fac-crash-phase1-v} 
\State \hskip1em \textbf{else}:
\State \hskip2em $proposal \gets \bot$ \label{line:fac-crash-phase1-bot} 
\State \hskip1em Send $\langle \textsc{Echo}, r, proposal \rangle$ to all processes
\BlueComment{Phase 2}\label{line:fac-crash-send-echo}
\State \hskip1em Wait for $n-f$ $\langle \textsc{Echo}, r, \_ \rangle$ messages\label{line:fac-crash-wait-echo}
\State \hskip1em \textbf{if} $\exists\, v^* \ne \bot$ such that I received $\geq f+1$ $\langle \textsc{Echo}, r, v^* \rangle$ messages:
\State \hskip2em \textbf{return} $\langle \textsc{Commit}, v^* \rangle$\label{line:fac-crash-commit}
\State \hskip1em \textbf{else if} $\exists\, v^* \ne \bot$ such that I received $\geq 1$ $\langle \textsc{Echo}, r, v^* \rangle$ messages:
\State \hskip2em \textbf{return} $\langle \textsc{Adopt}, v^* \rangle$\label{line:fac-crash-adopt-det}
\State \hskip1em \textbf{else}:
\State \hskip2em $v^* \gets$ value in first $\langle \textsc{Init}, r,\_ \rangle$ message received\label{line:fac-crash-adopt-rand}
\State \hskip2em \textbf{return} $\langle \textsc{Adopt}, v^* \rangle$ 
\end{algorithmic}
\end{algorithm}

The \textsc{Round} algorithm consists of two
phases. In the first phase, every correct process proposes a value by sending it to
all processes (line~\ref{line:fac-crash-init}). Then it waits to receive proposals from
a quorum of processes (line~\ref{line:fac-crash-wait-init}). If a process observes that all responses contain the same
phase-one proposal value then it proposes that value for the second phase (line~\ref{line:fac-crash-phase1-v}). If a process does not obtain a unanimous set of proposals in the first phase, the process simply proposes $\bot$ for the second phase (line~\ref{line:fac-crash-phase1-bot}).

Note that as a result of this procedure, if two processes propose a value different from $\bot$ for the second phase, they propose exactly the same value.
Let this value be called $v^*$.

The purpose of the second phase is to verify if $v^*$ was also observed by enough other processes.
After a process receives $n-f$ phase-two messages (line~\ref{line:fac-byz-wait-echo}), it checks if more than $f$ phase-two proposals are equal to $v^*$, and if so commits $v^*$ (line~\ref{line:fac-crash-commit}). A process adopts $v^*$ if it receives $v^*$ in the second phase, but is unable to collect enough $v^*$ values to decide (line~\ref{line:fac-crash-adopt-det}). Finally, it is possible that a process does not receive $v^*$ in the second phase (either because no such value was found in phase one or simply because it has received only $\bot$ in phase two); in this case the process adopts the fist value it received in phase one (line~\ref{line:fac-crash-adopt-rand}). 

As in the Byzantine case, the main intuition is that at each round, a favorable schedule can help processes agree (i.e., adopt the same estimate), by causing them to adopt the same estimate at line~\ref{line:fac-crash-adopt-rand} (e.g., by ensuring that the first \textsc{Init} message they receive is from the same process). Since the schedule is random, it has a non-zero chance of being favorable at each round. Thus, with probability $1$, the schedule will eventually be favorable. 

\subsection{Proofs}
We begin with a few lemmas which establish that the \textsc{Round} procedure in \Cref{alg:aac-crash} satisfies these properties:
\begin{description}
    \item[Integrity] If a process returns $(\cdot, v)$, then $v$ was proposed by some process.
    \item[Strong Validity] If all correct processes propose the same value $v$ and a process returns a pair $\langle \textsc{Grade}, v' \rangle$, then $\textsc{Grade} = \textsc{Commit}$ and $v' = v$.
    \item[Consistency] If any correct process returns  $\langle \textsc{Commit}, v \rangle$, then no process returns $(\cdot, v' \ne v)$.
    \item[Termination] If all correct processes propose, then every correct process eventually returns.
\end{description}

\begin{lemma}
    With crash faults and $n=2f+1$, \Cref{alg:aac-crash} satisfies integrity.
\end{lemma}
\begin{proof}
    We say that a value $v$ is \textit{valid} if it is the input value of some process. We want to show that processes only return valid values. We observe that (1) \textsc{Init} messages only contain valid values (line~\ref{line:fac-crash-init}), and therefore (2) \textsc{Echo} messages only contain valid values or $\bot$ (lines~\ref{line:fac-crash-if-init}--\ref{line:fac-crash-send-echo}). If a process $p$ returns $v$ at line~\ref{line:fac-crash-commit} or~\ref{line:fac-crash-adopt-det}, then $p$ received at least one \textsc{Echo} message for $v$, and thus $v$ is valid by (2) above. If $p$ returns $v$ at line~\ref{line:fac-crash-adopt-rand}, then $p$ received at least one \textsc{Init} message for $v$, and thus $v$ is valid by (1) above.
\end{proof}

\begin{lemma}
    With crash faults and $n=2f+1$, \Cref{alg:aac-crash} satisfies strong validity.
\end{lemma}
\begin{proof}
    If all processes propose the same value $v$, then all processes send $\langle\textsc{Init}, v\rangle$ at line~\ref{line:fac-crash-init}; all processes receive at least $n/2$ $\langle\textsc{Init}, v\rangle$ messages (since $n-f = f+1 \geq n/2$); all processes adopt $v$ as their proposal for the second phase and send $\langle\textsc{Echo}, v\rangle$ at line~\ref{line:fac-crash-send-echo}; all processes receive $n-f=f+1$ $\langle\textsc{Echo}, v\rangle$ and return $\langle\textsc{Commit}, v\rangle$.
\end{proof}

\begin{lemma}\label{lem:fac-no-two-echo}
    If a process $p$ sends $\langle\textsc{Echo}, v\rangle$ at line~\ref{line:fac-crash-send-echo}, then no process sends $\langle\textsc{Echo}, v'\rangle$, for any $v'\ne v$.
\end{lemma}
\begin{proof}
    Assume the lemma does not hold. Then $p$ must have received more than $n/2$ $\langle\textsc{Init}, v\rangle$ messages, and some process $p'$ must have received more than $n/2$ $\langle\textsc{Init}, v'\rangle$ for some $v'\ne v$. By quorum intersection, it follows that some process must have sent both an $\langle\textsc{Init}, v\rangle$ and $\langle\textsc{Init}, v'\rangle$ message. This is a contradiction, as processes only send one \textsc{Init} message at line~\ref{line:fac-crash-init}.
\end{proof}

\begin{lemma}
    With crash faults and $n=2f+1$, \Cref{alg:aac-crash} satisfies consistency.
\end{lemma}
\begin{proof}
    If process $p$ returns $\langle\textsc{Commit}, v\rangle$, it must do so at line~\ref{line:fac-crash-commit}, after having received $f+1$ $\langle\textsc{Echo}, v\rangle$ messages. Therefore, every other process $p'$ that returns, must receive at least one $\langle\textsc{Echo}, v\rangle$ message. If $p'$ also receives $f+1$ $\langle\textsc{Echo}, v\rangle$ messages, then it returns $\langle\textsc{Commit}, v\rangle$. Otherwise, by \Cref{lem:fac-no-two-echo}, $p'$ cannot receive an \textsc{Echo} message for any other value $v'\ne v$, so $p'$ returns $\langle\textsc{Adopt}, v\rangle$ at line~\ref{line:fac-crash-adopt-det}.
\end{proof}

\begin{lemma}
    With crash faults and $n=2f+1$, \Cref{alg:aac-crash} satisfies termination.
\end{lemma}
\begin{proof}
    This follows immediately from the construction of the algorithm. Processes perform two phases; the only blocking step of each phase is waiting for $n-f$ messages (lines~\ref{line:fac-crash-wait-init} and~\ref{line:fac-crash-wait-echo}). This waiting eventually terminates, since there are at least $n-f$ correct processes.
\end{proof}

% \begin{theorem}
%     With crash faults and $n=2f+1$, \Cref{alg:aac-crash} satisfies fairness.
% \end{theorem}
% \begin{proof}
%     We consider the worst case, in which processes do not all propose the same value. Since there are only two values ($0$ and $1$), one of the values must be the input value of more than $n/2$ processes. Among the scenarios that could lead to all processes outputting the same value, we consider the following: no process sends an $\langle\textsc{Echo}, v\rangle$ message (i.e., all processes send $\langle\textsc{Echo}, \bot\rangle$), but the schedule ensures that all processes receive the same value $v$ first and thus return $\langle\textsc{Adopt}, v\rangle$ at line~\ref{line:fac-crash-adopt-rand}. Let $P$ be the probability of such a schedule. We will show that $P$ is lower-bounded by a positive constant; in particular, $P$ does not decrease     

%     % There are three situations which could lead all processes to outputting the same value: (1) at least some process receives more than $n/2$ \textsc{Init} messages with the same value $v$ and sends an $\langle\textsc{Echo}, v\rangle$ message which is received by all processes at line~\ref{line:fac-crash-wait-echo}; (2) no process sends an $\langle\textsc{Echo}, v\rangle$ message (i.e., all processes send $\langle\textsc{Echo}, \bot\rangle$), but the schedule ensures that all processes receive the same value $v$ first and thus return $\langle\textsc{Adopt}, v\rangle$ at line~\ref{line:fac-crash-adopt-rand}; (3) some process sends a $\langle\textsc{Echo}, v\rangle$, but it is not received by all at line~\ref{line:fac-crash-wait-echo}; thus, some processes decide at line~\ref{line:fac-crash-adopt-det} and others at line~\ref{line:fac-crash-adopt-rand}
% \end{proof}
Now we can show that the consensus protocol in \Cref{alg:skeleton} is correct under crash faults.

\begin{theorem}\label{thm:validity-crash}
    With crash faults, \Cref{alg:skeleton} satisfies validity.
\end{theorem}

To prove the theorem, we first prove the following lemma:
\begin{lemma}\label{lem:crash-validity}
    If a process proposes $v$ to the \textsc{Round} procedure, then $v$ is the consensus input of some process.
\end{lemma}
\begin{proof}
    We prove the result by induction on the round $r$. For the base case: If $r = 0$, then all processes input their consensus inputs into $\textsc{Round}$. For the induction case: assume the lemma holds up to $r > 0$, and consider the case of $r + 1$. By the induction hypothesis and the integrity property of the \textsc{Round} procedure, any output of $\textsc{Round}(r,\cdot)$ must be the consensus input of some process. Since the input of $\textsc{Round}(r+1,\cdot)$ is the output of $\textsc{Round}(r,\cdot)$, the lemma must also hold for the case of $r+1$. This completes the induction.
\end{proof}

\begin{proof}[Proof of \Cref{thm:validity-crash}]
     If a process $p$ decides a value $v$, then the $\textsc{Round}$ procedure must have output $(\textsc{Commit}, v)$ at line \ref{line:skeleton-decide}. By \Cref{lem:crash-validity} and the integrity property of the \textsc{Round} procedure, it follows that $v$ is the consensus input of some process.
\end{proof}

\begin{theorem}\label{thm:crash-agreement}
    With crash faults, \Cref{alg:skeleton} satisfies uniform agreement.
\end{theorem}
\begin{proof}
    Let $r$ be the earliest round at which some process decides and let $p$ be a process that decides $v$ at round $r$. We will show that any other process $p'$ that decides, must decide $v$. 
    
    For $p$ to decide $v$ at round $r$, \textsc{Round} must output $(\textsc{Commit}, v)$ in that round. Thus, by the consistency property of \textsc{Round}, $\textsc{Round}(r,\cdot)$ must output $(\cdot, v)$ at all processes. If $\textsc{Round}(r,\cdot)$ outputs $(\textsc{Commit}, v)$ for $p'$, then $p'$ decides $v$ at round $r$ (line~\ref{line:skeleton-decide}). Otherwise, no other value than $v$ can be input to $\textsc{Round}(r+1,\cdot)$, and by the strong validity property, all processes (including $p'$) will output $(\textsc{Commit}, v)$ and decide $v$ at round $r+1$.
\end{proof}

\begin{theorem}\label{lem:termination-crash}
    With crash faults, \Cref{alg:skeleton} satisfies termination with probability $1$.
\end{theorem}
\begin{proof}
    We can describe the execution of the protocol as a Markov chain with states $0,\ldots,2f+1$; the system is at state $i$ if $i$ processes have estimate ($est_i$ variable) equal to $0$ before invoking $\textsc{Round}$. Due to the strong validity property of the $\textsc{Round}$ procedure, states $0$ and $2f+1$ are absorbing states. There is a non-zero transition probability from each state, other than $0$ and $2f+1$, to each other state (we show this below). Therefore, with probability $1$, the system will eventually reach one of the two absorbing states and remain there. Once this happens (all processes have the same $est_i$ variable), the strong validity property of $\textsc{Round}$ ensures that all processes (who have not decided yet) will decide within a round.
    
    It only remains to show that there is a non-zero transition probability from each state, other than $0$ and $2f+1$, to each other state. Consider a state $i \notin \{0,2f+1\}$ and a state $j$; there is a schedule $S$ with non-zero probability which leads the system from $i$ to $j$ in one invocation of \textsc{Round}. In $S$, every process receives \textsc{Init} messages for both $0$ and $1$ at line~\ref{line:fac-crash-wait-init}, and thus all processes send \textsc{Echo} messages with $\bot$ at line~\ref{line:fac-crash-send-echo}. Thus, all processes return at line~\ref{line:fac-crash-adopt-rand}. In $S$, $j$ processes receive an \textsc{Init} message with value $0$ first, so they adopt $0$, and $2f+1-j$ processes receive an \textsc{Init} message with value $1$ first, so they adopt $1$, bringing the system to state $j$.


    
    
    % Once all processes have the same estimate ($est_i$ variable), the strong validity property of $\textsc{Round}$ ensures that all processes (who have not decided yet) will decide within a round. 
    % By the fairness property of FAC, the probability that all processes output the same value at any given round, and thus will have the same estimate in the next round, is at least $P>0$. Thus the probability that, after $r$ rounds, processes do not have the same estimate is at most $P^r$; this probability tends to $0$ as $r$ increases. Since any execution that violates termination must have an infinite number of rounds in which processes do not have the same estimate, its probability is $0$. 
\end{proof}