\section{Challenges}\label{sec:challenges}

\subsection{Modeling Challenge}\label{sec:model-challenge}
Our aim is to propose a model for asynchrony without adversarial scheduling that is (1) general, i.e., does not restrict algorithm design (2) easy to work with for proofs, (3) usable by practical algorithms, and (4) intuitive.
In the course of defining the current model, we came up with several other possibilities that do not meet the aims above:
\begin{enumerate}
    \item A round-based model, similar to the fair scheduler model of Bracha and Toueg~\cite{BrachaT85}. In each communication round, a correct process sends a message to every process and waits to hear back from $n-f$ processes. The random scheduler assumption is: in each round, a correct process has a non-trivial (i.e., lower-bounded by a constant) probability of hearing from any subset of $n-f$ processes. This model has the advantage of being easy to work with, but is too restrictive, as it restricts algorithms to the round-based structure.
    \item A model which places probability directly on entire schedules, instead of on individual communication steps: each valid schedule has a non-trivial probability of occurring. We found this model to be un-intuitive and difficult to work with.
    \item A model in which the next message to be delivered is drawn, according to some distribution, from all currently pending messages (i.e., messages that have been sent but not yet delivered). The distribution must ensure that every message has a non-trivial probability to be scheduled next. This model is general (does not restrict algorithm structure), intuitive, and easy to work with, but has the following crucial flaw. Byzatine processes can skew the scheduling distribution by producing a large number of messages (potentially under the guise of retransmitting them as part of the reliable links assumption). If, at any given time, most pending messages are from Byzantine processes, then these messages are more likely to be delivered first, effectively reverting the model to an adversarial scheduler.
    \item Similarly to the previous proposal: at each scheduling step, a sender-receiver pair $(s,r)$ is drawn \textit{uniformly at random}, and the earliest pending message from $s$ to $r$ is the next message delivered in the system. This model is intuitive, and easy to work with, while also fixing the message injection attack by Byzantine processes: the number of pending messages from a (potentially Byzantine) process $s$ to process $r$ does not influence the probability distribution of $s$'s messages to be delivered before other messages. The only drawback is with respect to generality: the uniform distribution on the sender-receiver pairs is a strong assumption.
\end{enumerate}

Our final model is similar to the last proposal above, while solving the generality problem by removing the uniform distribution assumption. Instead, we simply assume that the probability of each sender-receiver pair being drawn is non-negligible.

\subsection{Algorithmic Challenge}\label{sec:algo-challenge}
Take the following naive (and incorrect) binary consensus algorithm for the $n\leq2f+1$ cases ($n=2f+1$ and/or $n=f+2$):
\begin{itemize}
    \item Round $0$: Processes initially sign and send their input value to all other processes, and wait for such messages from $n-f$ processes.
    \item Rounds $1$--$R$ (where $R$ is a parameter): Processes sign and send their entire history of sent and received messages to all processes and wait for valid such messages from $n-f$ processes.
    \item At the end of round $R$, correct processes decide on, say, the lowest input value they have received.
\end{itemize}

This algorithm is subject to the following attack:
\begin{itemize}
    \item Assume all correct processes have $1$ as their input value.
    \item The $f$ Byzantine processes do not send any messages to the $n-f$ correct processes up until and including round $R-1$. Otherwise, Byzantine processes act as correct processes whose input values are $0$, including accepting messages from correct processes.
    \item Thus, no correct processes is aware of $0$ as a valid input value before round $R$.
    \item Let $p$ be some correct processes that the Byzantine processes have agreed on before the start of the execution. The attack attempts to cause $p$ to decide on a different value than the other correct processes, breaking agreement.
    \item In round $R$, Byzantine processes send correctly constructed messages to $p$, containing their entire communication histories. If the random scheduler delivers even one of these messages to $p$ before the end of the round, then $p$ becomes aware of the input value $0$ for the first time in round $R$ (and therefore does not have time to inform the other correct processes).
    \item After round $R$, $p$ must decide $0$ (being the lowest input value it is aware of), while the other processes must decide $1$ (not being aware of $0$ as a valid input value), breaking agreement.
\end{itemize}

This attack succeeds if the random scheduler delivers a message from a Byzantine process to $p$ in round $R$, among the first $n-f$ messages delivered to $p$ in that round. This has a non-trivial chance of occurring.

This algorithm illustrates the main challenge of designing correct algorithms under the \model when $n\leq 2f+1$: even if the model ensures that all correct processes communicate with each other eventually, Byzantine processes can still equivocate and correct processes do not know necessarily know which messages are from correct processes and which are not.