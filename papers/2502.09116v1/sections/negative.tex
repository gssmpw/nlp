\section{Negative Results}\label{sec:negative}
 
In this section we provide negative results that closely match our positive results from previous sections. Intuitively, we show that in the \model it is not possible to obtain Byzantine consensus protocols with more powerful guarantees than the protocols we propose in this paper. This shows that the \model, while avoiding some restrictions and impossibilities of the standard asynchronous model, is not overly permissive.  

We prove the following three results. The first two results hold without any additional assumptions, while for the third result we require a couple of mild assumptions.

\begin{theorem}\label{thm:flp}
   No protocol can solve Byzantine consensus in the \model with deterministic strong validity, agreement, and termination.
\end{theorem}

\begin{theorem}\label{thm:2f+1}
    With $n=2f+1$, no protocol for Byzantine consensus in the \model can ensure strong validity and agreement with probability $1$, as well as deterministic termination. 
\end{theorem}

Before stating the third result, we describe two additional assumptions. Given a protocol $\mathcal{A}$, we say that an execution $E$ is \textit{clean} if all processes are correct in $E$; a schedule $S$ is clean if at least one clean execution admits $S$ as its schedule. Our first assumption is that the total probability of clean schedules is not negligible.  This assumption is reasonable, as without it, a protocol could, for instance, break agreement or validity in all clean executions and still claim \textit{whp} agreement and validity; such a protocol would be useless in practice, where clean executions are common. A protocol satisfying this assumption is called \textit{clean}.

Our second assumption is: if some correct process $p$ proposes $v\in\{0,1\}$ in an execution $E$ with schedule $S$, then there exists an execution $E'$ with the same schedule $S$, in which $p$ proposes $1-v$. Intuitively, this assumption implies that processes can have the same communication pattern (e.g. send the same number of messages) whether they propose $0$ or $1$. A protocol satisfying this assumption is called \textit{regular}. Now we are ready to state our third negative result.   

\begin{theorem}\label{thm:f+2}
    With $n=f+2, f\geq 2$, no clean, regular protocol for Byzantine consensus in the \model can ensure strong validity and agreement with high probability, while ensuring deterministic termination.
\end{theorem}

\begin{proof}[Proof sketch for \Cref{thm:flp}]
    This result is equivalent to the FLP impossibility~\cite{FLP} in the \model, and the FLP proof holds in our model as well. Essentially, if at least one process can fail by crashing, there exists an infinite bivalent execution (the same execution as constructed in the FLP proof), which prevents processes from deciding without breaking agreement.
\end{proof}

\begin{proof}[Proof of \Cref{thm:2f+1}]
    We prove the result by contradiction. Assume that such a protocol $\mathcal{A}$ exists. We show through a ``split-brain'' argument that $\mathcal{A}$ admits an execution $E$ such that $E$ breaks agreement and $E$ has non-zero probability. 

    Take $E$ to be an execution in which at least one correct process proposes $0$ and at least one correct process proposes $1$. Let $S_0$ be the set of correct processes that propose $0$, $|S_0| \geq 1$, and $S_1$ be the set of correct processes that propose $1$, $|S_1| \geq 1$. Let $B$ be the set of Byzantine processes, $|B|=f$.

    In $E$, the Byzantine processes behave toward the correct processes in $S_0$ as correct processes whose inputs are all $0$. And they behave toward the $S_1$ as correct processes whose inputs are all $1$. Furthermore, any message between a process $S_0$ and a process in $S_1$, or vice-versa, is delayed by the scheduler until after all correct processes have decided.
    \footnote{Correct processes in $S_0$ cannot wait for messages from $S_1$ before proceeding with their protocol logic, as in asynchrony processes may only wait for messages from $n-f = f+1$ processes. In $E$, the $f+1$ processes that a process from $S_0$ hears from first always happen to be from $S_0$ or $B$. Symmetrically, processes from $S_1$ always hear from $S_1$ or $B$ first and cannot wait for messages from $S_0$.} 
    To processes in $S_0$, $E$ is indistinguishable from an execution in which all correct processes have input $0$; thus they must decide $0$ in a finite number of steps to preserve termination and strong validity. Symmetrically, to processes in $S_0$, $E$ is indistinguishable from an execution in which all correct processes have input $1$; thus they must decide $1$ in a finite number of steps. Therefore, $E$ is a finite execution in which agreement is violated. 

    Since $E$ is a finite execution, it has a finite number of scheduling steps, each of which has non-zero probability; thus, $E$ has non-zero probability. We have shown that $\mathcal{A}$ admits an execution that  breaks agreement and has non-zero probability; a contradiction.
\end{proof}

\begin{lemma}\label{lem:all-schedules-bad}
    With $n=f+2$, $f\geq 2$, let $\mathcal{A}$ be a clean, regular Byzantine consensus protocol which satisfies strong valdity and agreement whp, as well as deterministic termination. Then any clean schedule $S$ of $\mathcal{A}$ is bad for strong validity or agreement.
\end{lemma}

\begin{proof}
    Consider any clean schedule $S$ of $\mathcal{A}$. Since $\mathcal{A}$ is regular, there exists a clean execution $E$ of $\mathcal{A}$ with schedule $S$, in which at least 2 processes propose $0$ and at least 2 processes propose $1$. Assume \textit{wlog} that $p_1$ and $p_2$ propose $0$, while $p_{n-1}$ and $p_n$ propose $1$. We now describe three executions $E_1$, $E_2$, and $E_3$, with the same schedule $S$ as $E$, and show that $\mathcal{A}$ must break either strong validity or agreement in one of the three executions. This is sufficient to show that $S$ is bad for strong validity or agreement.

    Let $E_1$ be an execution with schedule $S$, in which all processes behave identically to $E$; in $E_1$, $p_1$ and $p_2$ are correct, while $p_3,\ldots,p_n$ are Byzantine but behave correctly. To satisfy strong validity, $p_1$ must decide $0$ in $E_1$.

    Let $E_2$ be an execution with schedule $S$, in which again all processes behave identically to $E$; this time, $p_1$ and $p_n$ are correct, while $p_2,\ldots,p_{n-1}$ are Byzantine. Since $E_1$ and $E_2$ are indistinguishable to $p_1$, and $p_1$ has deterministic logic, $p_1$ must decide the same value in both executions, namely $0$. Thus, in order to satisfy agreement, $p_n$ must also decide $0$ in $E_2$. 

    Let $E_3$ be an execution with schedule $S$, in which again all processes behave as in $E$; this time, $p_{n-1}$ and $p_n$ are correct, while $p_1,\ldots,p_{n-2}$ are Byzantine. Since $E_2$ and $E_3$ are indistinguishable to $p_n$, and $p_n$ has deterministic logic, $p_n$ must decide the same value in both executions, namely $0$. But this breaks strong validity, as both correct processes ($p_{n-1}$ and $p_n$) have proposed $1$ in $E_3$.
\end{proof}

\begin{proof}[Proof of \Cref{thm:f+2}]
    Assume by contradiction that such a protocol $\mathcal{A}$ exists. By \Cref{lem:all-schedules-bad}, all clean schedules of $\mathcal{A}$ are bad for strong validity or agreement, and since $\mathcal{A}$ is clean, the total probability of its clean schedules is not negligible. It follows that the total probability of schedules which are bad for strong validity or agreement is not negligible, so $\mathcal{A}$ cannot satisfy strong validity and agreement both with high probability; a contradiction.
\end{proof}

% \begin{itemize}
%     \item With $n=3f+1$, no protocol can solve Byzantine consensus with deterministic strong safety and deterministic termination. More generally, no protocol can solve consensus with both deterministic safety and deterministic liveness. The main idea is that the bad schedule constructed in the FLP impossibility proof is also possible in the random network model, even though it has probability 0. 
%     \item With $n=2f+1$, no protocol can solve Byzantine consensus with P1 agreement and deterministic termination. The main idea here is assume such a protocol exists and to follow a split brain argument, as follows. There is an execution in which the correct processes can be partitioned into two subsets $A$ and $B$ such that $A$ and $B$ never hear from each other, and instead communicate only with the Byzantine processes. The Byzantine processes can behave as in a 0-valent execution towards $A$ and as in a 1-valent execution towards $B$, causing $A$ and $B$ to decide 0 and 1, respectively. Since the protocol ensures deterministic termination, this execution runs for a finite number of communication steps and thus its probability is not 0 (it may be negligible, as in our protocol). 
%     \item With $n=f+2$, $f\geq 2$, no protocol can solve Byzantine consensus with whp strong validity and deterministic termination. The main idea here is to assume such a protocol exists and to prove that strong validity can be broken with non-negligible probability. Take any execution $E$ in which strong validity is relevant, i.e., an execution in which all $n-f$ correct processes propose the same value; assume wlog that this value is $1$ (so correct processes need to decide $1$). We can assume that in $E$ all $f$ Byzantine processes propose $0$, but otherwise follow the protocol correctly. Now consider an execution $E'$ with the same message schedule as $E$, except that in $E'$ all $n-f$ correct processes propose $0$ (so correct processes need to decide $0$). In $E'$, $n-f$ Byzantine processes propose $1$ and the remaining $f-(n-f) = 2f - n$ Byzantine processes propose $0$. Since $E$ and $E'$ are indistinguishable to any correct process $p$, and since $p$ is deterministic, $p$ must decide the same value in both executions, and thus violate strong validity in one of the executions. Since $E$ and $E'$ have the same message schedules, they have the same probability and thus strong validity is violated with probability $1/2$, contradicting whp strong validity. 
% \end{itemize}