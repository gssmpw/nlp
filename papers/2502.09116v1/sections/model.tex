\section{Model \& Prelimnaries}\label{sec:model}

\paragraph{Processes} We consider a set $\Pi$ of $n$ processes, up to $f$ of which may be faulty. We consider the Byzantine-fault model, in which faulty processes may depart arbitrarily from the protocol. Throughout the paper, we assume that correct (non-faulty) processes have deterministic logic, i.e., they do not have access to a source of randomness.

\paragraph{Cryptography} We make standard assumptions: processes communicate through authenticated channels and have access to digital signatures whose properties cannot be broken by the adversary.

\paragraph{Network} The processes communicate by sending messages over a fully-connected reliable network: every pair of processes $p$ and $q$ communicate over a link that satisfies the \textit{integrity} and \textit{no-loss} properties. Integrity requires that a message $m$ from $p$ be received by $q$ at most once and only if $m$ was previously sent by $p$ to $q$. No-loss requires that a message $m$ sent from $p$ to $q$ be eventually received by $q$.

\paragraph{Random asynchrony} Processes send messages by submitting them to the network; a \textit{random scheduler} decides in which order submitted messages are delivered. We assume the scheduler delivers messages one by one, i.e., no two delivery events occur at exactly the same time. For convenience, we use a global discrete notion of time to reflect the sequence of delivery events: time proceeds in discrete steps $0, 1, \ldots$; each time step corresponds to a message delivery event in the system. Processes do not have access to this notion of time (they do not have clocks). Sending a message and performing local computation occur instantaneously, between time steps. Note that this notion of time does not bound message delays: an arbitrary amount of real time can pass between time steps.

We next describe the random scheduler. At any time $t$, let $P(t) \subseteq \Pi^2$ be the set of pairs of processes $(p,q)$ such that $p$ has at least one \textit{pending message} to $q$. We say that a message $m$ from $p$ to $q$ is pending at time $t$ if $p$ send $m$ before $t$ and $q$ has not received $m$ by time $t$. At each time step $t$, the random scheduler draws a pair $(p,q)$ at random from $P(t)$ and delivers to $q$ the earliest message from $p$. We assume that there exists a constant $\Cnf > 0$ such that, for any $p$ and $q$, the probability that $(p,q)\in P(t)$ is drawn at time $t$ is at least $\Cnf$. In general, $\Cnf$ may depend on $n$ and $f$, but not on $t$. We assume that each scheduling draw is independent from others, and does not depend on the content of the message being delivered. 

\paragraph{Consensus} Our algorithms solve two variants of binary Byzantine consensus: strong  and weak. Strong Byzantine consensus is defined by the following properties:
\begin{description}
    \item[Strong Validity] If all correct processes propose $v$, then correct processes that decide, decide~$v$. 
    \item[Agreement] If correct processes $p$ and $q$ decide $v$ and $w$ respectively, then $v = w$.
    \item[Termination] Every correct process decides some value.
\end{description}

Weak Byzantine consensus~\cite{weak-byz} has the same agreement and termination properties as the strong variant above, but has a different validity property:
\begin{description}
    \item[Weak Validity] If all processes are correct and propose $v$, then processes that decide, decide~$v$.
\end{description}

\paragraph{Deterministic and probabilistic properties}
The probability of a schedule is the probability of the intersection of all its scheduling steps. 
We say that an algorithm $\mathcal{A}$ ensures a property $\mathcal{P}$ \textit{deterministically} if $\mathcal{P}$ holds in every execution of $\mathcal{A}$. Note that any algorithm that ensures a property $\mathcal{P}$ deterministically in the standard asynchronous model, must also ensure $\mathcal{P}$ deterministically in the \model.
% Given an algorithm $\mathcal{A}$ and a property $\mathcal{P}$, we say that a schedule $S$ is $\mathcal{P}$\textit{-testable} if there exists an execution $E$ of $\mathcal{A}$ with schedule $S$ in which $\mathcal{P}$ does not hold vacuously.\footnote{For example, if there exists a schedule $S$ such that there is no execution of $\mathcal{A}$ with schedule $S$ in which all correct processes propose the same value, then $S$ is not validity-testable, because validity holds vacuously in all executions with schedule $S$.} 
Given an algorithm $\mathcal{A}$ and a property $\mathcal{P}$, we say that a schedule $S$ is \textit{bad for $\mathcal{P}$} if there exists an execution $E$ of $\mathcal{A}$ with schedule $S$ such that $\mathcal{P}$ does not hold in $E$.
An algorithm $\mathcal{A}$ ensures a property $\mathcal{P}$ \textit{with probability $1$} if the total probability of all schedules that are bad for $\mathcal{P}$ is $0$. 
An algorithm $\mathcal{A}$ ensures a property $\mathcal{P}$ \textit{with high probability (whp)} if the total probability of all schedules that are bad for $\mathcal{P}$ is negligible; in this paper, a probability is negligible if approaches $0$ exponentially with some parameter of the algorithm, for any (fixed) $n$ and $f$ (e.g., the number of communication steps). 
% \paragraph{More assumptions}
% \begin{itemize}
%     \item The probability of an execution is the probability of its underlying schedule.
%     \item The probability of a schedule is the probability of the intersection of all its scheduling steps.
%     \item A property of is a subset of all possible executions.
% \end{itemize}
% Round-based protocols in the fair model:
% \begin{itemize}
%     \item To simplify things, we work with round-based protocols. Such protocols proceed in rounds. In each round, each correct process sends a (potentially empty) message to all other processes and waits to receive $n-f$ messages before proceeding to the next round.
%     \item We claim that when such round-based protocols are run in the fair model, the following property is ensured: Assuming all processes send a message in round $r$, the set of processes that some process $p$ hears from by the end of $r$ is uniformly distributed among all sets of $n-f$ processes. \igor{This is a crucial result that we still need to prove. I am a bit stuck on how to start.}
% \end{itemize}
% Note that the (eventual) fairness concept can also be applied to partial or full synchrony. This is quite clear with Option 2 above: if the distribution is unbounded, then the model is asynchronous; if the distribution is bounded, the model is synchronous; if the distribution starts out unbounded and becomes bounded after some time, the model is partially synchronous.
