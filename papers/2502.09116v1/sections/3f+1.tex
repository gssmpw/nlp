\section{$n=3f+1$: Deterministic safety, termination with probability 1}
\label{sec:warmup}

In this section we solve binary Byzantine consensus with deterministic strong validity and agreement, and termination with probability $1$. 

Our algorithm, shown in \Cref{alg:skeleton}, proceeds in rounds: in each round, processes attempt to decide using a \textsc{Round} procedure; if unsuccessful, processes update their estimate and try again in the next round. The \textsc{Round} procedure is similar to an adopt-commit object~\cite{ac1, ac2}: processes \textit{propose} a value and return a pair $(g,v)$, where $v$ is a value and $g$ is a grade, which can be either \textsc{Commit} or \textsc{Adopt}. If $g=\textsc{Commit}$, then it is guaranteed that all correct processes return the same value $v$ (possibly with different grades). If all correct processes propose the same value $v$, then all correct processes are guaranteed to return $v$ with a \textsc{Commit} grade.

\begin{algorithm}
\caption{Main consensus algorithm for $n=3f+1$: pseudocode at process $i$}
\label{alg:skeleton}
\begin{algorithmic} [1]
\State \textbf{procedure }\textsc{Propose}$(v_i)$: 
\BlueComment{$v_i \in \{0,1\}$}
\State \hskip1em $est_i \gets v_i$
\State \hskip1em $r_i \gets 0$
\State \hskip1em \textbf{while} \textsf{true}:
\State \hskip2em $(g,v) \gets$ \textsc{Round}$(r_i, est_i)$
\State \hskip2em \textbf{if} $g = \textsc{Commit}$: \textsf{decide}$(v)$\label{line:skeleton-decide}
\BlueComment{Only once}
\State \hskip2em $est_i \gets v$
\State \hskip2em $r_i \gets r_i + 1$
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Byzantine \textsc{Round} implementation for $n=3f+1$: pseudocode at process $i$}
\label{alg:aac-byz}
\begin{algorithmic} [1]
\State \textbf{procedure} \textsc{Round}$(r,v)$:
\State \hskip1em BRB-Broadcast $\langle \textsc{Init}, r, v \rangle$\label{line:fac-byz-init}
\BlueComment{Phase 1}
\State \hskip1em Wait to BRB-Deliver $\langle \textsc{Init}, r,\_ \rangle$ from $n-f$ processes\label{line:fac-byz-wait-init}
\State \hskip1em $\mathcal{H} \gets$ delivered $\langle \textsc{Init}, r,\_ \rangle$ messages 
\State \hskip1em $proposal \gets$ majority value in $\mathcal{H}$\label{line:fac-byz-adopt-phase1}
\State \hskip1em \textbf{if} $\exists\, v^*$ such that I received $>n/2$ $\langle \textsc{Init}, r, v^* \rangle$ messages:\label{line:fac-byz-if-init}
\State \hskip1em BRB-Broadcast $\langle \textsc{Echo}, r, proposal, \mathcal{H} \rangle$ to all processes
\BlueComment{Phase 2}\label{line:fac-byz-send-echo}
\State \hskip1em Wait to BRB-Deliver valid $\langle \textsc{Echo}, r, \_, \_ \rangle$ messages from $n-f$ processes\label{line:fac-byz-wait-echo}
\State \hskip1em \textbf{if} $\exists\, v^* \ne \bot$ such that I received $\geq 2f+1$ $\langle \textsc{Echo}, r, v^*, \_ \rangle$ messages:
\State \hskip2em \textbf{return} $\langle \textsc{Commit}, v^* \rangle$\label{line:fac-byz-commit}
\State \hskip1em \textbf{else}:
\State \hskip2em $v^* \gets$ majority value among received $\langle \textsc{Echo}, r, \_ , \_\rangle$ messages
\State \hskip2em \textbf{return} $\langle \textsc{Adopt}, v^* \rangle$\label{line:fac-byz-adopt}
\end{algorithmic}
\end{algorithm}

The core of the algorithm is the \textsc{Round} procedure, shown in \Cref{alg:aac-byz}. There are two types of messages: \textsc{Init} and \textsc{Echo}. Processes rely on Byzantine Reliable Broadcast (BRB)~\cite{book} for communication.\footnote{Any asynchronous BRB protocol is also correct in the \model.} Furthermore, all messages are signed. The algorithm has two phases. In phase 1, each correct process $p$ broadcasts (using BRB) its input value $v$ in an \textsc{Init} message (line~\ref{line:fac-byz-init}), and waits to deliver $n-f = 2f+1$ \textsc{Init} messages (line~\ref{line:fac-byz-wait-init}). Process $p$ adopts as its \textit{proposal} for phase 2, the majority value among the received \textsc{Init} messages (line~\ref{line:fac-byz-adopt-phase1}). Then, in phase 2, $p$ broadcasts an \textsc{Echo} message with $p$'s phase 2 proposal, as well as the $n-f$ (signed) \textsc{Init} messages that justify $v$ to be the majority phase 1 value (line~\ref{line:fac-byz-send-echo}); $p$ waits for $n-f$ valid \textsc{Echo} messages (line~\ref{line:fac-byz-wait-echo}). If all delivered \textsc{Echo} messages are for the same value $v^*$, then $p$ commits $v^*$ (line~\ref{line:fac-byz-commit}); otherwise $p$ adopts the majority value (line~\ref{line:fac-byz-adopt}).

We prove the correctness of our algorithm in \Cref{sec:proofs-det}. The main intuition is that at each round, a favorable schedule can help all correct processes agree (i.e., adopt the same estimate), by causing them to select the same majority value in phase 1 (e.g., by ensuring that they deliver \textsc{Init} messages from the same set of processes). Since the schedule is random, it has a non-zero chance of being favorable at each round. Thus, with probability $1$, the schedule will eventually be favorable. This is similar in spirit to random coin based Byzantine Randomized Consensus algorithms~\cite{book}, in which correct processes choose their next estimate by tossing a coin, if they do not manage to reach agreement in a given round. Here we are relying on the random schedule instead of the random coin. However, as we show later, in our model, consensus is solvable for settings where it is impossible for standard asynchrony even when equipped with a common coin.%\igor{I think this will cause reviewers to pose the question if our model is equivalent to the standard model + common coin. We might want to answer that somewhere preemptively.}

\paragraph{Crash-fault tolerant consensus} A similar approach can be used to solve crash-fault tolerant consensus with $n=2f+1$, with the same guarantees of deterministic safety, as well as termination with probability $1$. Our algorithm uses the same round-based structure in \Cref{alg:skeleton} and a modified \textsc{Round} procedure, that does not require reliable broadcast, and employs standard point-to-point messages instead. The main intuition is similar to our Byzantine algorithm: the random scheduler eliminates the need for a common coin by ensuring that correct processes eventually deliver messages in a favorable order which leads them to agree and thus terminate. \Cref{sec:crash-fault} gives our algorithm and proves its correctness.
