\section{Introduction}\label{sec:intro}

Most current message-passing distributed algorithms assume model in which the adversary, in addition to being able to corrupt a subset of the participants, also has control over the network. More precisely, the standard asynchronous model typically assumes that the adversary controls the \textit{message schedule}, i.e., the order in which messages are delivered.

This model is a good worst-case model to design algorithms against. It captures the scenario in which the network behaves adversarially, either by bad luck, or by actual influence of a malicious adversary over the network.

However, in this paper, we argue that the standard model is too pessimistic. We believe that it is not realistic to assume that the adversary has control over the network. Instead, we propose the more realistic assumption that the network is independent of the adversary's influence, and is instead random. In more precise terms, in an asynchronous random network, every process is equally likely to have its message delivered next.

As we show in the paper this has several interesting theoretical and practical implications for the consensus problem. All of our results assume full asynchrony and deterministic processes. By deterministic here we mean that correct processes do not have access to sources of randomness. Such deterministic asynchronous consensus (DAC) protocols are highly desirable in practice, since they do not rely on timeouts, nor on expensive cryptographic sources of randomness.

We first show that in a random network, the consensus problem can be solved deterministically in full asynchrony, with both crash faults and Byzantine faults, circumventing the well-known FLP impossibility result~\cite{FLP}.  Our first protocol ensures safety (agreement and validity) at all times, and termination with probability 1. 

Secondly, we show that a with-high-probability-safety (WHPS) version of Byzantine consensus can be solved in the fair model, even if $n=2f+1$. WHPS here means that agreement and validity are ensured with high probability, and termination is ensured deterministically.

Finally, we show that by relaxing the problem even further, and ensuring only weak or external validity whp, as well as whp agreement and deterministic termination, the Byzantine consensus problem can be solved in the fair network model even if $n \leq 2f$.

Intuitively, the eventual fairness model enables these protocols because the randomness of the network ensures that an infinitely long bad schedule, i.e. one that would prevent termination or break safety, has probability $0$, or negligible probability, respectively. To see this, consider a DAC protocol $\mathcal{P}$ that is indulgent~\cite{indulgent-algs} towards the randomness property, i.e., $\mathcal{P}$ ensures safety even if the fairness property does not hold---we will present such protocols in \Cref{sec:warmup}. $\mathcal{P}$ proceeds in rounds: in each round correct processes attempt to agree on a single value. If in some good round, all processes receive messages from all other correct processes, then they can agree and decide. Many consensus protocols of this form exist, but in the standard asynchronous model, the adversary can choose a schedule that prevents good rounds from ever occurring. However, in the random network model the adversary no longer has this option. Since the probability of a good round is nonzero, the probability of an infinite sequence of bad rounds is zero---in other words, termination is guaranteed with probability 1. 

Similar assumptions to our random network have been explored by previous work. In message passing, the seminal paper of Bracha and Toueg~\cite{BrachaT85} defines the fair scheduler, which ensures that in each message round, there is a constant non-zero probability that each correct process receives messages from the same set of correct processes. It then proposes deterministic asynchronous binary consensus protocols for the crash-fault and Byzantine-fault models under the fair scheduler assumption. In shared memory, Aspnes~\cite{Aspnes02} defines noisy scheduling, in which the adversary may chose the schedule, but that adversarial schedule is perturbed randomly. He shows that with such a noisy schedule, deterministic asynchronous consensus is achievable. Also in shared memory, previous work introduce a \textit{stochastic scheduler}~\cite{AlistarhSV15,AlistarhCS16}, which schedules shared memory steps randomly. This line of work shows that many lock-free algorithms are essentially wait-free when run against a stochastic scheduler, because the schedules that would break wait-freedom have negligible probability. 

Here is a summary of our results:

\begin{table}[ht]
  \centering  % Center the table

  \begin{tabular}{ccc} % Define the table with 3 centered columns (ccc)
    \toprule  % Top rule using booktabs
    Resilience & Positive Result & Negative Result \\
    \midrule  % Mid rule using booktabs
    $n = 3f + 1$ & Det. strong safety \& P1 termination & Det. strong safety \& det. termination \\
    $n = 2f + 1$ & Whp strong safety \& det. termination & P1 safety \& det. termination \\
    $n = f + 2$ & Whp weak safety \& det. termination & P1 weak safety \& det. termination \\
    \bottomrule  % Bottom rule using booktabs
  \end{tabular}
  \caption{Results in this paper for Byzantine consensus. 
  \textit{Det.} means ``deterministic", \textit{P1} mea ns ``with probability 1'', and \textit{whp} means ``with high probability". Strong safety means agreement and strong validity. Weak safety means agreement and weak validity.
  }  % Add a caption
\end{table}
