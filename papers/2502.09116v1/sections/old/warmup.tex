\section{Deterministic safety, termination with probability 1}
\label{sec:warmup}

We provide in this section algorithms for crash-tolerant binary consensus and strong Byzantine consensus, which satisfy all of their safety properties deterministically (i.e., in every execution), and termination with probability $1$. Both algorithms share the same skeleton, shown in \Cref{alg:skeleton}. 

\Cref{alg:skeleton} relies on a novel variant of the adopt-commit (AC) object~\cite{ac1, ac2}, which we call \textit{fair adopt-commit} (FAC). The specification of the FAC object is given in Module~\ref{mod:fac}. The FAC object differs with respect to the standard AC object only in its \textit{fairness} property, which informally ensures that with at least some constant nonzero probability, all correct processes agree in their output from the FAC object, even if they do not have the same input.

\begin{module}
\caption{Crash-Tolerant Fair Adopt-Commit (FAC)}
\label{mod:fac}
\begin{algorithmic}[1]

\Statex \textbf{Interface}:
\Statex \hskip1em \textsc{Propose}$(v)$, where $v$ is a value. Returns $\{\langle \textsc{Grade}, v' \rangle\}$, where $\textsc{Grade} \in \{\textsc{Commit}, \textsc{Adopt}\}$ and $v'$ is \hphantom{mmm}a value.


\bigskip
\Statex \textbf{Properties:}
\Statex \hskip1em \emph{Integrity:} If a process returns $(\cdot, v)$, then $v$ was proposed by some process.
\smallskip 

\Statex \hskip1em \emph{Strong validity:} If all correct processes propose the same value $v$ and a correct process returns a pair \hphantom{mmm}$\langle \textsc{Grade}, v' \rangle$, then $\textsc{Grade} = \textsc{Commit}$ and $v' = v$.

\smallskip 
\Statex \hskip1em \emph{Consistency:} If any correct process returns  $\langle \textsc{Commit}, v' \rangle$, then no correct process returns $(\cdot, v' \ne v)$.

\smallskip 
\Statex \hskip1em \emph{Termination:} If all correct processes propose, then every correct process eventually returns.

\smallskip
\Statex \hskip1em \textit{Fairness:} There exists a constant $P>0$ such that, with probability at least $P$, all correct process that \hphantom{mmm}return, return the same value $v$ (possibly with different \textsc{Grade}s).

\end{algorithmic}
\end{module}

\Cref{alg:skeleton} proceeds in rounds: in each round, processes attempt to decide using a fresh FAC object. The fairness property of the FAC objects ensures that, with probability 1, correct processes eventually have the same estimate and thus, by the strong validity of FAC, all correct processes eventually return \textsc{Commit} and decide. The specific implementation of the AC object differs between the crash-only and Byzantine cases.

\begin{algorithm}
\caption{Skeleton consensus algorithm: pseudocode at process $i$}
\label{alg:skeleton}
\begin{algorithmic} [1]
\State \textbf{Uses:}
\State \hskip1em \textsf{FAC}[$0, \cdots$], an infinite array of FAC objects
\bigskip

\State \textbf{procedure }\textsc{Propose}$(v_i)$: 
\BlueComment{$v_i \in \{0,1\}$}
\State \hskip1em $est_i \gets v_i$
\State \hskip1em $r_i \gets 0$
\State \hskip1em \textbf{while} \textsf{true}:
\State \hskip2em \textbf{switch} \textsf{FAC}[$r_i$].\textsc{Propose}$(est_i)$:
\State \hskip3em \textbf{case} $\langle \textsc{Commit}, v \rangle$: \textsf{decide}$(v)$\label{line:skeleton-decide}
\BlueComment{Only once}
\State \hskip3em \textbf{case} $\langle \textsc{Adopt}, v \rangle$: $est_i \gets v$
\State \hskip2em $r_i \gets r_i + 1$
\end{algorithmic}
\end{algorithm}

\subsection{Crash Faults}

\Cref{alg:aac-crash} is adapted from~\cite{book}. It gives an implementation of crash-fault tolerant FAC under the assumption that $n=2f+1$.

The algorithm consists of two
phases. In the first phase, every correct process proposes a value by sending it to
all processes. Then it receives proposals from
a quorum of processes. If a process observes that all responses contain the same
phase-one proposal value then it proposes that value for the second phase. If a process does not obtain a unanimous set of proposals in the first phase, the process simply proposes $\bot$ for the second phase.

Note that as a result of this procedure, if two processes propose a value different from $\bot$ for the second phase, they propose exactly the same value.
Let this value be called $v*$.

The purpose of the second phase is to verify if $v*$
was also observed by enough other processes.
After a process receives $n-f$ phase-two messages, it checks if more than $f$ phase-two proposals are equal to $v*$, and may commit this value if there are enough of them. A process adopts $v*$ if it receives $v*$ in the second phase, but is unable to collect enough $v*$ values to decide. Finally, it is possible that a process does not receive $v*$ in the second phase (either because no such value was found in phase one or simply because it has received only $\bot$ in phase two); in this case the process adopts the fist value it received in phase one (we call this the \textit{first-seen-value (FSV) adopt rule}).

Except for the FSV adopt rule, the algorithm is a standard adopt-commit protocol. The additional fairness property comes from the FSV rule. In the fair model, the event that all correct processes receive the same value $v$ first has non-zero probability \lef{because they will all receive the same proposal from the same proposer?}. Thus, if the processes cannot deterministically choose the same value, the FSV rule gives them a non-zero probability to converge.  

\begin{algorithm}
\caption{Crash-fault tolerant FAC: pseudocode at process $i$}
\label{alg:aac-crash}
\begin{algorithmic} [1]
\State \textbf{procedure} \textsc{Propose}$(v)$:
\State \hskip1em Send $\langle \textsc{Init}, v \rangle$ to all processes\label{line:fac-crash-init}
\BlueComment{Phase 1}
\State \hskip1em Wait for $n-f$ $\langle \textsc{Init}, \_ \rangle$ messages\label{line:fac-crash-wait-init}
\State \hskip1em \textbf{if} $\exists\, v^*$ such that I received $>n/2$ $\langle \textsc{Init}, v^* \rangle$ messages:\label{line:fac-crash-if-init}
\State \hskip2em $proposal \gets v^*$ 
\State \hskip1em \textbf{else}:
\State \hskip2em $proposal \gets \bot$ 
\medskip
\State \hskip1em Send $\langle \textsc{Echo}, proposal \rangle$ to all processes
\BlueComment{Phase 2}\label{line:fac-crash-send-echo}
\State \hskip1em Wait for $n-f$ $\langle \textsc{Echo}, \_ \rangle$ messages\label{line:fac-crash-wait-echo}
\State \hskip1em \textbf{if} $\exists\, v^* \ne \bot$ such that I received $\geq f+1$ $\langle \textsc{Echo}, v^* \rangle$ messages:
\State \hskip2em \textbf{return} $\langle \textsc{Commit}, v^* \rangle$\label{line:fac-crash-commit}
\State \hskip1em \textbf{else if} $\exists\, v^* \ne \bot$ such that I received $\geq 1$ $\langle \textsc{Echo}, v^* \rangle$ messages:
\State \hskip2em \textbf{return} $\langle \textsc{Adopt}, v^* \rangle$\label{line:fac-crash-adopt-det}
\State \hskip1em \textbf{else}:
\State \hskip2em $v^* \gets$ value in first \textsc{Init} message I received\label{line:fac-crash-adopt-rand}
\State \hskip2em \textbf{return} $\langle \textsc{Adopt}, v^* \rangle$ 
\end{algorithmic}
\end{algorithm}


\subsection{Byzantine Faults}

\Cref{alg:aac-byz} is adapted from Bracha and Toueg~\cite{BrachaT85}. It gives an implementation of Byzantine fault tolerant FAC under the assumption that $n=3f+1$.

There are two types of messages: initial and echo. A process sends to all the processes an initial message with its name and its value. Upon receiving an initial message, every process echoes it back to all the processes. Process $p$ \textit{accepts} a message with value $v$ from process $q$ if it receives more than $(n + f)/2$ messages of the form $(echo, q, v)$. 

Process $p$ waits until it has accepted values from $n-f$ senders. If $p$ has accepted more than $(n+f)/2$ messages with the same value $v$, $p$ may commit $v$. Otherwise, $p$ adopts the majority value.

The main intuition here is that the fair model ensures there is a non-zero probability that every correct process hears from every other correct process first, before any potential messages from faulty processes. In this case, correct processes will converge on (adopt) the same value. Thus the fairness property is ensured. \lef{Basically instead of hoping the random coin will give the same value to everyone we hope the network will deliver the same value to everyone? Would this explanation make it more intuitive on why it works?}

\begin{algorithm}
\caption{Byzantine-fault tolerant FAC: pseudocode at process $i$}
\label{alg:aac-byz}
\begin{algorithmic} [1]
\State \textbf{Local variables}:
\State \hskip1em $echo\_count[0..1]$, array initialized to $\{0,0\}$
\State \hskip1em $accepted\_count[0..1]$, array initialized to  $\{0,0\}$

\smallskip
\State \textbf{Message format}:
\State \hskip1em $type \in \{\textsc{Init}, \textsc{Echo}\}$
\State \hskip1em $origin \in \Pi$
\State \hskip1em $value$

\bigskip
\State \textbf{procedure} \textsc{Propose}$(v)$:
\State \hskip1em Send $\langle \textsc{Init}, i, v \rangle$ to all processes
\State \hskip1em \textbf{while} $accepted\_count[0] + accepted\_count[1] < n-f$:
\State \hskip2em $msg \gets \textsc{Receive}()$
\State \hskip2em \textbf{if} this is the first message from the sender with these values of $msg.type$ and  $msg.origin$:
\State \hskip3em \textbf{if} $msg.type$ is \textsc{Init}:
\State \hskip4em Send $\langle \textsc{Echo}, msg.origin, msg.value \rangle$ to all processes
\State \hskip3em \textbf{else}: \BlueComment{Echo}
\State \hskip4em $echo\_count[msg.origin][msg.value] += 1$
\State \hskip4em \textbf{if} $echo\_count[msg.origin][msg.value] \geq 2f + 1$:
\State \hskip5em $accepted\_count[msg.value] += 1$
\State \hskip1em \textbf{if} $accepted\_count[0] < accepted\_count[1]$: $value \gets 1$
\State \hskip1em \textbf{else}: $value \gets 0$
\State \hskip1em \textbf{if} $\exists\, v^*$ such that $accepted\_count[v] \geq 2f+1$:
\State \hskip2em return $\langle \textsc{Commit}, v^* \rangle$
\State \hskip1em \textbf{else}:
\State \hskip2em return $\langle \textsc{Adopt}, value \rangle$
\end{algorithmic}
\end{algorithm}