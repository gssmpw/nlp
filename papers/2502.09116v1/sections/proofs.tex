\section{Proofs for Deterministic Safety Algorithms}\label{sec:proofs-det}

In this section we prove the correctness of our algorithm in \Cref{sec:warmup}.
We first prove that the \textsc{Round} procedure in \Cref{alg:aac-byz} satisfies the properties below, and then prove that \Cref{alg:skeleton} solves consensus under Byzantine faults.
\begin{description}
    \item[Strong Validity] If all correct processes propose the same value $v$ and a correct process returns a pair $\langle \textsc{Grade}, v' \rangle$, then $\textsc{Grade} = \textsc{Commit}$ and $v' = v$.
    \item[Consistency] If any correct process returns  $\langle \textsc{Commit}, v \rangle$, then no correct process returns $(\cdot, v' \ne v)$.
    \item[Termination] If all correct processes propose, then every correct process eventually returns.
\end{description}

In our proofs we rely on the following properties of Byzantine Reliable Broadcast (BRB)~\cite{book}:
\begin{description}
    \item[BRB-Validity] If a correct process $p$ broadcasts a message $m$, then every correct process eventually delivers $m$.
    \item[BRB-No-duplication] Every correct process delivers at most one message.
    \item[BRB-Integrity] If some correct process delivers a message $m$ with sender $p$ and process $p$ is correct, then $m$ was previously broadcast by $p$.
    \item[BRB-Consistency] If some correct process delivers a message $m$ and another correct process delivers a message $m$, then $m = m$.
    \item[BRB-Totality] If some message is delivered by any correct process, every correct process eventually delivers a message.
\end{description}

\begin{lemma}\label{lem:byz-round-validity}
    With Byzantine faults and $n=3f+1$, \Cref{alg:aac-byz} satisfies strong validity.
\end{lemma}
\begin{proof}
    If all correct processes propose the same value $v$, then at least $2f+1$ processes BRB-broadcast an \textsc{Init} message for $v$, and therefore at most $f$ processes BRB-broadcast an \textsc{Init} message for $1-v$. Thus $v$ will be the majority value among all \textsc{Init} messages delivered in phase 1, at all correct processes. Thus all correct processes will BRB-broadcast an \textsc{Echo} message for $v$. Furthermore, no Byzantine process can produce a valid \textsc{Echo} message for $1-v$, since to do so would require a set of $2f+1$ \textsc{Init} message with a majority value of $1-v$. This is impossible due to the properties of BRB and the fact that at most $f$ processes have BRB-broadcast an \textsc{Init} message for $1-v$.
    So, all valid \textsc{Echo} messages received by correct processes will be for $v$, so all correct processes will commit $v$ at line~\ref{line:fac-byz-commit}.
\end{proof}

\begin{lemma}
    With Byzantine faults and $n=3f+1$, \Cref{alg:aac-byz} satisfies consistency.
\end{lemma}
\begin{proof}
    If a correct process $p_1$ commits $v$ at line~\ref{line:fac-byz-commit}, then it must have delivered a set $S_1$ of $2f+1$ \textsc{Echo} messages for $v$ at line~\ref{line:fac-byz-wait-echo}. Take now another process $p_2$ and consider the set $S_2$ of $2f+1$ \textsc{Echo} messages it delivers at line~\ref{line:fac-byz-wait-echo}. By quorum intersection, $S_1$ and $S_2$ must intersect in at least $f+1$ messages. By the BRB-Consistency property, these $f+1$ messages must be identical at $p_1$ and $p_2$. Thus $p_2$ delivers at least $f+1$ \textsc{Echo} messages for $v$, which constitutes a majority of the $2f+1$ \textsc{Echo} messages it delivers overall. So if $p_2$ commits a value at line~\ref{line:fac-byz-commit}, then it must commit $v$, and if $p_2$ adopts a value at line~\ref{line:fac-byz-adopt}, then it must adopt $v$.
\end{proof}

\begin{lemma}
    With Byzantine faults and $n=3f+1$, \Cref{alg:aac-byz} satisfies termination.
\end{lemma}
\begin{proof}
    Follows immediately from the algorithm and from the properties of Byzantine Reliable Broadcast. Processes perform two phases; the only blocking step of each phase is waiting for $n-f$ messages (lines~\ref{line:fac-byz-wait-init} and~\ref{line:fac-byz-wait-echo}). This waiting eventually terminates, by the BRB-Validity property and the fact that there are at least $n-f$ correct processes.
\end{proof}

\begin{theorem}\label{thm:validity-byz}
    With Byzantine faults and $n=3f+1$, \Cref{alg:skeleton} satisfies strong validity.
\end{theorem}
\begin{proof}
    This follows from the strong validity property of the \textsc{Round} procedure (\Cref{lem:byz-round-validity}): if all correct processes propose $v$ to consensus, then all correct processes propose $v$ to \textsc{Round} in the first round, where by \Cref{lem:byz-round-validity}, all correct processes commit $v$, and thus all correct processes decide $v$ at line~\ref{line:skeleton-decide}.
\end{proof}

\begin{theorem}\label{thm:agreement-byz}
    With Byzantine faults and $n=3f+1$, \Cref{alg:skeleton} satisfies agreement.
\end{theorem}
\begin{proof}
    Let $r$ be the earliest round at which some process decides and let $p$ be a process that decides $v$ at round $r$. We will show that any other process $p'$ that decides, must decide $v$. 
    
    For $p$ to decide $v$ at round $r$, \textsc{Round} must output $(\textsc{Commit}, v)$ in that round. Thus, by the consistency property of \textsc{Round}, $\textsc{Round}(r,\cdot)$ must output $(\cdot, v)$ at all correct processes. If $\textsc{Round}(r,\cdot)$ outputs $(\textsc{Commit}, v)$ for $p'$, then $p'$ decides $v$ at round $r$ (line~\ref{line:skeleton-decide}). Otherwise, all correct processes input $v$ to $\textsc{Round}(r+1,\cdot)$, and by the strong validity property, all processes (including $p'$) will output $(\textsc{Commit}, v)$ and decide $v$ at round $r+1$.
\end{proof}

\begin{theorem}\label{thm:termination-byz}
    With Byzantine faults and $n=3f+1$, \Cref{alg:skeleton} satisfies termination.
\end{theorem}
\begin{proof}
     We can describe the execution of the protocol as a Markov chain with states $0,\ldots,n-f=2f+1$; the system is at state $i$ if $i$ correct processes have estimate ($est_i$ variable) equal to $0$ before invoking $\textsc{Round}$. Due to the strong validity property of the $\textsc{Round}$ procedure, states $0$ and $2f+1$ are absorbing states. There is a non-zero transition probability from each state (including $0$ and $2f+1$), to state $0$ or $2f+1$, or both (we show this below). Therefore, with probability $1$, the system will eventually reach one of the two absorbing states and remain there. Once this happens (i.e., once all processes have the same $est_i$ variable), the strong validity property of $\textsc{Round}$ ensures that all processes (who have not decided yet) will decide within a round.
    
    It only remains to show that there is a non-zero transition probability from each state to at least one of the absorbing states $0$ and $2f+1$. Consider a state $i \notin \{0,2f+1\}$; there is a schedule $S$ with non-zero probability which leads the system from $i$ to $0$ or $2f+1$ in one invocation of \textsc{Round}. We consider two cases:
    \begin{itemize}
        \item $i < f+1$: in this case $0$ is the minority value among correct processes. In schedule $S$, the $n-f$ \textsc{Init} messages delivered by correct process at line~\ref{line:fac-byz-wait-init} are all from correct processes. Thus, every correct process sees $i$ $0$s and $2f+1-i$ $1$; $1$ is the majority value, so all correct processes adopt it for phase 2. In phase 2, $S$ again ensures that the $n-f$ \textsc{Echo} messages delivered by correct process at line~\ref{line:fac-byz-wait-echo} are all from correct processes. Thus, all correct processes see $2f+1$ \textsc{Echo} messages for $1$ and commit $1$, bringing the system to state $0$.
        \item $i \geq f+1$: in this case $0$ is the majority value among correct processes. This case is symmetrical with respect to the previous one: the only difference is that all correct processes adopt $0$ (the majority value) at the end of phase 1, and all correct processes deliver $2f+1$ \textsc{Echo} messages for $0$, thus committing $0$ and bringing the system to state $2f+1$.
    \end{itemize}
\end{proof}