\section{Introduction}\label{sec:intro}

%%% Shortcomings of Current Approaches

Byzantine Fault-Tolerant (BFT) consensus is a fundamental primitive in distributed computing, serving as the backbone of many applications, including blockchains~\cite{sok-consensus}. Solving BFT consensus in an asynchronous network model~\cite{FLP} is a well-studied problem~\cite{book,dag-rider,ren2017,mahimahi}. Typically, algorithms in this model assume that the adversary controls (1) a subset of faulty processes and (2) message delays, particularly the \textit{message schedule}â€”the order in which messages are delivered.

%%% Our Approach: Relaxing Adversarial Scheduling

However, asynchronous BFT consensus is constrained by restrictive lower bounds~\cite{FLP, byz-generals}. These lower bounds often stem from the adversary's ability to impose arbitrary message schedules. Requiring an algorithm to function under the worst possible scheduling scenario often renders tasks impossible due to a single, highly unlikely counterexample, that is, a pathological schedule that violates the algorithm's properties~\cite{FLP}.

Yet, due to performance considerations, practical implementations of consensus circumvent the limitations of asynchrony by assuming that the schedule is not adversarial. For example, we are aware of asynchronous consensus protocols running in production commodity wide-area networks for extensive periods of time without a random coin implementation~\cite{narwhal}---so as to avoid the performance overhead of generating cryptographically-secure randomness---without loss of liveness. This motivates our search for a model that explains this empirical observation.

Another common relaxation that circumvents the limitations of asynchrony is to assume \textit{periods of synchrony}, leading to the widely used \textit{partially synchronous} model~\cite{dwork1988consensus}. However, protocols based on partial synchrony lose liveness outside of these periods, which may occur due to poor network conditions or denial-of-service (DoS) attacks~\cite{consensus-dos}.

In this paper, in order to provide a sound basis for non-adversarial scheduling as assumed by some modern practical systems, and to avoid the limitations of partial synchrony, we propose an alternative relaxation of the asynchronous model: we study asynchronous networks without adversarial scheduling. Specifically, we ask:
\textit{What becomes possible in a network where message delays are unbounded, but the message schedule is not adversarial?}

To explore this question, we introduce a new variant of the asynchronous model, which we call the \textit{\model}. In this model, message delays remain unbounded, and the adversary still controls a subset of processes. However, the message schedule is no longer adversarial; instead, messages are delivered in a \textit{random} order.  By relaxing adversarial scheduling, our approach unlocks new algorithmic possibilities for consensus. It enables protocols to achieve probabilistic guarantees~\cite{probft} that were previously impossible in the standard asynchronous model, while preserving unbounded message delays and Byzantine faults.

To isolate the impact of random scheduling, we consider only deterministic algorithms, meaning processes do not have access to local randomness. We analyze the impact of our model on Byzantine consensus at different resilience thresholds: $n = 3f + 1$, $n = 2f + 1$, and $n = f + 2$, where $n$ is the total number of processes, and up to $f$ processes may be faulty.

Our model enables consensus protocols that are impossible under standard asynchrony. The key insight is that the \model prevents an adversary from blocking honest parties from communicating indefinitely. In traditional asynchrony, an adversary can delay messages indefinitely to prevent termination (e.g., in the FLP impossibility result~\cite{FLP}). In contrast, in the \model, the adversary cannot control the schedule, ensuring that honest parties can exchange messages within a bounded number of steps with high probability.

%%% Protocol Overview and Challenges
\subsection{Modeling Challenges}

Designing an asynchronous model with a non-adversarial schedule presented several challenges. Our initial attempt at a round-based model, while mathematically tractable, proved too rigid, enforcing communication patterns that were overly restrictive. We then explored probabilistic scheduling over entire message schedules, but this approach was unintuitive and impractical for analysis.
%
A more promising approach was to randomly select individual messages for delivery. However, this exposed a critical vulnerability: Byzantine processes could manipulate the scheduling distribution by flooding the system with messages, effectively regaining control over the schedule. Attempts to mitigate this by encrypting messages failed, as the adversary could still infer crucial protocol information from the message patterns and delivery timings. More details about our initial attempts to model random asynchrony can be found in \Cref{sec:model-challenge}.

These challenges led us to our final model: instead of selecting individual messages, the scheduler randomly selects sender-receiver pairs. At each step, a sender-receiver pair $(s, r)$ is chosen, and the earliest pending message from $s$ to $r$ is delivered. This approach prevents Byzantine nodes from biasing the schedule since the probability of a message being delivered depends only on the number of available sender-receiver pairs, not on the volume of messages sent by a single process.

A natural concern is whether removing adversarial scheduling trivializes the consensus problem. We address this in two ways. First, Appendix~\ref{sec:algo-challenge} presents a naive algorithm that fails to solve consensus when $n \leq 2f + 1$, highlighting a fundamental challenge: even though the \model guarantees eventual communication, Byzantine nodes can still equivocate, preventing honest processes from distinguishing between correct and faulty messages. Second, we complement our positive results with corresponding impossibility results, establishing close bounds on what can be achieved in the \model.


%%% Contributions
\subsection{Our Results}

Our key contribution is the introduction of the \model, a novel relaxation of the classic asynchronous model that removes adversarial scheduling while preserving unbounded message delays and Byzantine faults. This relaxation allows us to achieve new bounds that were previously impossible under standard asynchrony.
%
We then design BFT consensus protocols in this new model, analyzing their feasibility at different resilience thresholds. Finally, we provide both positive results (demonstrating feasibility) and impossibility results (establishing the model's limits), summarized in \Cref{tab:results-summary}.

\begin{table}[ht]
  \centering
  \begin{tabular}{ccc}
    \toprule
    Resilience   & Positive Result             & Negative Result               \\
    \midrule
    $n = 3f + 1$ & Det. strong V, det. A, P1 T & Det. strong V, det. A, det. T \\
    $n = 2f + 1$ & Whp strong V, whp A, det. T & P1 strong V, P1 A, det. T   \\
    $n = f + 2$  & Det. weak V, whp A, det. T   & Whp strong V, whp A, det. T$^\dagger$   \\
    \bottomrule
  \end{tabular}
  \caption{
    Results in this paper for Byzantine consensus.
    \textit{Det.} means ``deterministic", \textit{P1} means ``with probability 1'', and \textit{whp} means ``with high probability".  \textit{V} stands for ``validity'', \textit{A} stands for ``agreement'', and \textit{T} stands for ``termination''. These terms are defined in \Cref{sec:model}. $^\dagger$Additional assumption needed (see \Cref{sec:negative}).
  }
  \label{tab:results-summary}
\end{table}
