\section{Background and Related Work}
\label{Sec:Background}
In this section we describe the big \textit{I} notation and its basic components. We also assess similar works in the field that estimate the efficiency of use in any way. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Big I
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Big \textit{I} notation}
The big \textit{I} notation **Shneiderman, "Designing the User Interface"** can be used to estimate the interaction complexity of lo-fi and hi-fi UX concepts, production-level user interface design, and user interfaces of launched applications. The letter \textit{I} stands for \textit{interaction}. 
%Since the big \textit{I} notation is not very well known, it is briefly introduced here. 

As a motivating example, imagine a building architect designing an airport. While making the first sketches, s/he may want to know the average time it takes for a passenger to walk from a security area to a gate. To do this, the architect measures the distance on the scale drawing with a ruler and transforms it into the real distance based on the scale, then multiply the distance by the average walking speed. The walking time can be determined within minutes, and the architect may decide to modify the design using this information.

Currently, there is no such "UX/HCI ruler", but there are two established techniques that measure time: summative usability tests **Nielsen, "Guerrilla HCI"** and KLM ____ ("The Keystroke-Level Model"). A usability test requires building a scale model of the airport, recruiting participants, having them walk from a security area to a gate, and measuring the time ('time-on-task'). KLM requires a production-level UI design with all its elements. 
If execution times for certain user actions and UI elements have been measured before they can be reused.
Otherwise, they have to be measured, requiring a similar effort as a summative usability test. Hence, both techniques take significant resources. In real-life projects, there is often no budget and time available to make significant design changes at mature phase in a project.
Big \textit{I} intends to be such a "UX/HCI ruler" by estimating interaction complexity, allowing to make efficiency-related decisions from the earliest stages.
While big \textit{I} is comparable to a ruler, the calculated interaction complexity is comparable to the measured distance. What big \textit{I} currently does not provide is a mapping of the interaction complexity to an average execution time value. This gap should be partially addressed by the study presented in this paper.

The big \textit{I} notation was designed to determine the efficiency of use for UX concepts, spanning from rough sketches or lo-fi wireframes to production-level UI designs or launched applications. Big \textit{I} is particularly useful for estimating efficiency of use for multiple lo-fi wireframes. It expresses the interaction complexity as a mathematical function, making the comparison between various UX concepts easy. Due to the use of mathematical expressions, an estimated interaction complexity has high believability. The big \textit{I} notation is very useful for application domains where the efficiency of use is a critical application property.

To the best of the authors' knowledge, there are multiple properties of big \textit{I} that make it a unique UX/HCI technique. 1) Big \textit{I} does not determine a single value, e.g., a single step or time value, but a complexity function, which allows for easily identifying design decisions that contribute to a relatively high interaction complexity. 2) Big \textit{I} can be applied in the early phases of a design and development process where major design changes can still be made. 3) Its application does not require user involvement. 4) Since big \textit{I} considers abstract user actions, it is modality-agnostic. It can be applied to graphical user interfaces, voice user interfaces, other modalities, and also to multi-modal user interfaces. 5) With some training and practice, the estimated interaction complexity for a given UX concept and a selected user task can be calculated in about an hour, or less. Hence, the application of big \textit{I} is highly cost-effective. The mentioned characteristics of big \textit{I} make it especially compelling for UX practitioners and HCI researchers who have a strong affinity for arithmetic.

Big \textit{I} has some limitations. One of them is that estimated interaction complexity is not precise. Also, it does not determine execution time for user actions. A complexity function is a useful output, but a time value is highly desirable as well. Mapping the estimated interaction complexity to a time value requires determining an average time for interaction steps. The aim of this study is to take time measurements for a selected user task (purchasing a movie ticket) that allows deriving an average execution time per interaction step, so that a time estimate can be determined for an estimated interaction complexity.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   Related work
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Related Work}

There are multiple approaches that are similar to the big \textit{I} notation. The keystroke-level model (KLM) predicts execution times for known task scenarios and graphical user interface elements using keyboards, mouse, and monitors as interaction devices ____ ("The Keystroke-Level Model"). 
%These predictions rely on measured average execution times for the specific target user group and operators using the application for which the predictions are made. ____ determined operators, such as pointing with a pointing device, pressing and releasing a key or button, moving hand from mouse to keyboard or vice versa, perception and accessing the memory with calculated average times (see Subsection~\ref{sec:Material:KLM}). The operators are modality-specific and independent of user tasks.
There are differences between KLM and big \textit{I}: 1) KLM applies to specific graphical UI elements like text inputs and buttons, requiring a complete user interface design, while big \textit{I} can be applied to both early UI concepts as well as late design artifacts (production-level UIs). 2) KLM determines execution time, while big \textit{I} estimates interaction complexity. 3) KLM is modality specific (graphical UIs), while big \textit{I} is modality agnostic.

The big \textit{I} notation is based on the big \textit{O} notation ____ ("Big O"), but
% which is used to estimate the complexity of algorithms. Big O expresses the asymptotic behavior of a function and describes its upper boundary. It is used to determine the complexity of algorithms with a polynomial function with one variable $n$. The polynomial function expresses how often an algorithm executes its instructions. Big \textit{O} simplifies the polynomial functional by keeping the highest growing function only and normalizing its coefficient to 1. For example, $O(2 \cdot n^2 + 4 \cdot n + 3)$ is simplified to $O(n^2)$, $O(2 \cdot n + 3)$ is simplified to $O(n)$, and $O(9)$ is simplified to $O(1)$.
there are a few key differences between big \textit{I} and big \textit{O}: 1) Big \textit{O} counts the number of instructions executed, treating all types of instructions equally. In contrast, big \textit{I} differentiates between five types of user actions: Think (T), Click a button (C), Scroll a page (S), Enter content (E), and use of an external application (X). This distinction helps to identify design inefficiencies. For instance, if the interaction complexity increases due to the necessary use of an external application (expressed as X), designers can explore alternative UX concepts with the intent to reduce the use of an external application or to completely exclude it. 2) Big \textit{O} simplifies the functional expression of the highest growing function by normalizing its coefficient to 1. In big \textit{I}, the coefficient of the highest growing function is not normalized. Due to the relative slowness of human performance compared to a microprocessor, the coefficient is crucial for determining the execution time of human actions. 3) Big \textit{O} uses a single variable that influences the functional complexity of an algorithm, typically the number of iterations. In big \textit{I}, more than one variable can influence the interaction complexity.

Summative usability tests **Nielsen, "Guerrilla HCI"** measure time-on-task, which does not reveal directly which parts of a UI cause high complexity and low efficiency.