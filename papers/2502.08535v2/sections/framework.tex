\section{Profiling methodology}
\label{sec:framework}

In this section, we describe our profiling methodology. We start with an outline of our approach, followed by a detailed presentation of its components.

\subsection{General workflow}
\label{sec:overview}

Fig.~\ref{fig:workflow} gives an overview on the workflow of our methodology to obtain a profile for a Smart Home device under a certain type of interaction. An interaction can require the usage of a triggering source, such as a companion app installed on a smartphone. In practice, a Smart Home device may support different interactions (e.g., for a smart lamp: switching on/off, changing its color, etc.) and triggering sources, and the workflow described here must be repeated for each of them. The workflow consists of multiple steps summarized below.

%For all devices, the considered interactions have been chosen to closely mimic a real user interacting with the device in a Smart Home setting, by using its companion app; e.g., for a smart lamp, we consider the following interactions: switching on/off, changing the brightness, changing the color.

\input{figures/tikz/workflow.tex}

\hyperref[sec:traffic-capture]{Step 1} consists in performing the interaction with the device under investigation and recording the  network traffic. To this end, we connect the Smart Home device (or, for non-IP devices, their gateway or hub) and the device running the triggering source to a (wireless or wired) LAN and capture the traffic on the Access Point (AP), respectively switch. We call an interaction and the resulting device state an \emph{event}. 
%% FDK: commented out because already explained in detail in the next subsection
%We believe, guided by previous work on device profiling \cite{ping-pong}, that the traffic of the Smart Home device and of the controlling device triggering the event are of equal importance, therefore we collect all their traffic. Step 1 is repeated multiple times.

In \hyperref[sec:sig-ex]{step 2}, the traffic traces obtained are filtered and analyzed, and an \emph{event signature} is extracted. The latter consists of a set of traffic flow descriptors, called \emph{Flow IDs} in the following, that describe the relevant features of the bidirectional flows observed in the traces, and therefore associated with the event. A Flow ID contains network and transport layer information, such as host addresses and port numbers, as well as application layer information (when available). The extracted Flow IDs are stored in a tree-shaped data structure that allows tracking which Flow IDs have already been observed.

In \hyperref[sec:event-tree]{step 3}, we select a Flow ID from the tree, configure a firewall running on the switch or AP to block packets matching that ID, and repeat steps 1 and 2. The idea is that by deliberately blocking some of the traffic associated with the interaction and repeating the steps 1 to 2, the device and/or app will try alternative communication patterns.

% until the event fails, i.e., the desired change of the device is not achieved because required communication has been blocked, or 

The steps above are repeated until no new patterns are discovered.
The final result is the profile of the device for the investigated event.
It takes the form of a tree,
where each node is a Flow ID linked to the event,
and the path from the root towards a given node gives
the set of parent Flow IDs which were blocked to let the current Flow ID appear.
%i.e. all the event signatures linked to that event together with the information which flows were blocked to let them appear
We define the Flow IDs initially occurring without any traffic blocking required as \emph{first-level} Flow IDs,
whereas the ones appearing as a result of traffic blocking are \emph{hidden} Flow IDs.
The latter are the communication patterns which can be discovered
only through our multi-level approach,
and therefore missed by state-of-the-art techniques.

%In the following sections, we describe the different steps of the workflow in more detail.
%An algorithmic representation of the workflow is shown in Algorithm~\ref{algo:exp} and will be referenced in the corresponding sections.

% \begin{algorithm}
%     \caption{Device profiling}
%     \label{algo:exp}
%     \begin{algorithmic}[1]
%         \Procedure{ProfileDevice}{$\mathit{device},\mathit{interaction}$} $\rightarrow$ $\mathit{signature\_tree}$
%             \State tree $\gets$ root node\label{algoempty1}
% 			\State firewall\_rules = \{ \}
% 			\State current\_node $\gets$ root node\label{algoempty2}
%             \Repeat						
% 				\State traces $\gets$ []\label{capturestart}
%                 \For {1 \textbf{to} $m$}
% 					\State trace $\gets$ start traffic capture
% 					\State trigger\_event(device, interaction)
% 					\State stop traffic capture after duration $d$
% 					\If{event is successful}
% 			    		\State add trace to traces
% 					\EndIf
% 					\State sleep random period
%                 \EndFor\label{captureend}

%                 \If {$\|$ traces $\|$ $\leq m/2$}\label{algotest1}
%                     \State continue with next iteration
%                 \EndIf\label{algotest2}
                
%                 \State $s$ $\gets$ extract\_event\_signature(traces)\label{algoextract}
%                 \For{flow\_id \textbf{in} $s$}\label{addloop1}
%                     \If{flow\_id \textbf{not} \textbf{in} tree}\label{algoprune}
%                         \State current\_node.add\_child(flow\_id)
%                     \EndIf
%                 \EndFor\label{addloop2}
                
%                 \State mark current\_node as visited
                
%                 \If{tree has unvisited nodes}\label{algoselect1}
%                     \State current\_node $\gets$ get\_unvisited\_node(tree)\label{algoselect}
%                     \State firewall\_rules $\gets$ reject ( $\{$ current\_node $\}\ \cup$ ancestors(current\_node) )
%                     \State apply firewall\_rules
%                 \EndIf\label{algoselect2}
%             \Until{no unvisited node in tree}

%             \State \Return tree
%         \EndProcedure
%     \end{algorithmic}
% \end{algorithm}

\subsection{Step 1: Traffic capturing}
\label{sec:traffic-capture}

Similarly to \emph{PingPong} \cite{ping-pong} and \emph{IoTAthena} \cite{wan_iotathena_2022}, we start capturing the network traffic, perform the interaction, then stop the traffic capture after a predefined duration $d$. We repeat each interaction and the traffic capturing $m$ times.
Our framework automates interactions triggered by a companion app by leveraging the Android Debug Bridge (ADB) tool \cite{adb} to generate touch events on the smartphone running the companion app. 
We also consider power-cycling the Smart home device as an interaction (called \emph{boot interaction} in the following). To automate the boot interaction, we plug the device in a smart power outlet controlled by our framework.

We collect all incoming and outgoing traffic of the Smart Home device and of the smartphone, since we consider the activities of both of them potentially relevant for the characterization of the event. Between captures, we introduce random waiting intervals to avoid the systematic capturing of periodic background traffic unrelated to the interaction.
%(lines~\ref{capturestart}--\ref{captureend} in Algorithm~\ref{algo:exp}).
Control plane packets are filtered out, in particular all ARP, ICMP, DHCP packets, TCP Handshake packets, and TLS Handshake packets, except \texttt{Client Hello} packets containing the Server Name Indication (SNI) extension.

As our approach is based on blocking traffic, it can happen that the interaction does not cause the desired state change in the Smart Home device. For the event signature extraction described in step 2, it is important to filter out such unsuccessful event executions. We do this by verifying the device state, e.g. whether the lamp has turned on, after each capture. To obtain the device state, we leverage the device's API. We believe this method is more precise and reliable than the approach followed by Mandalari \textit{et al.} \cite{blocking-without-breaking} which compares screenshots of the companion app to check whether the displayed status of the Smart Home device has changed. If there is no API, we fall back to screenshots, too, but we compute the Structural Similarity Measure (SSIM) \cite{ssim} and consider two screenshots identical if the SSIM is over an empirically defined threshold, instead of directly comparing image pixels like Mandalari \textit{et al.} The result are $m^+ \leq m$ traffic captures of successful event executions.

% If the device's state was correctly updated,
% we consider the related network traffic to build the event signature.
% Otherwise, we dismiss the captured traffic,
% and proceed to the next event iteration.

\subsection{Step 2: Event signature extraction}
\label{sec:sig-ex}

For each of the $m^+$ packet traces, the recorded packets are first aggregated to Flow IDs, and then the event signature is extracted. This happens in multiple steps that we now describe.
%(line~\ref{algoextract} in Algorithm~\ref{algo:exp}).

\subsubsection{Replacing IP addresses by domain names}

During an event, the Smart Home device or the companion app may communicate with cloud services provided by the device vendor.
Where possible, we replace non-local source and destination IP addresses by domain names. This makes the signature extraction more robust against changes in the IP addresses caused by cloud migrations or load balancing. To do so, we keep a table matching encountered domain names with their corresponding IP address(es). We first populate the table with entries from the LAN gateway's DNS cache, and then update it whenever a packet bearing domain data is observed, i.e. a DNS query/response or a TLS \texttt{Client Hello} message with the SNI extension.\footnote{We also tried reverse DNS lookups, but since most of the servers contacted during our experiments were hosted at big cloud providers such as Amazon, no meaningful data was obtained, and we abandoned this approach.}
%Therefore, we did not further consider reverse lookups.}


%\begin{itemize}
    %\item For DNS responses, we extract the domain name from the question resource record,
    %along with the related IP address(es) from the answer and additional resource records,
    %and save them in the table.
    %\item For TLS Client Hello packets with the SNI extension,
    %we extract the domain name from said extension,
    %and the IP address for the packet's IP layer.
%\end{itemize}

\subsubsection{Aggregating packets to Flow IDs}

Packets that share all attributes in the set of properties below are grouped to a bidirectional flow, and the attributes form the \emph{Flow ID} of that flow. %We use the following attributes:
\begin{itemize}
\item The hostname (domain name or IP address) of the \emph{source} and \emph{destination}. The Flow ID's \emph{source} is the source of the first packet in the bidirectional flow.
\item The \emph{protocol} (e.g. TCP or UDP).
\item The source and destination \emph{ports}. We only consider a port if it belongs to a well known service (e.g. port 80) or if it appears, for the given combination of the other attribute values, in all $m^+$ packet traces. This means, for example, that the packets of all TCP connections from a client $A$ to the port 80 of server $B$ are aggregated to a single flow and the random client ports used by $A$ are ignored and not further considered. The same is also done for vendor-specific ports, thanks to the above rule.
\item \emph{Application}-specific data for known application layer protocols, amongst others: query name and query type for DNS; method and URI for HTTP; message type, code and URI for CoAP. Consequently, for example, a DNS response is grouped with its query (based on the query type and name).
\end{itemize}

%Grouping along the application-layer data is not as strict as the other attributes,
%as, intuitively, varying application-layer data can be related to the same network flow.
%Therefore, we implemented custom, protocol-specific equality for application-layer data.
%For instance, as a pair of a DNS request and response must be grouped to the same Flow ID,
%we match them on the query type (e.g. A or AAAA) and queried name,
%but not on the QR flag (which indicates if the message is a query or a response).
%Other supported protocols include HTTP and CoAP, for which we respectively match on the method and URI fields,
%and the type (Confirmable or Non-confirmable), code (analogous to HTTP's method), and URI path.

\subsubsection{Building the event signature}

The aggregation of packets to Flow IDs produces a set $f_i$ of Flow IDs, with $1\leq i \leq m^+$, for each of the $m^+$ packet traces.
We define the \emph{event signature} $s$ for the investigated interaction as the set of Flow IDs that appear in all packet traces:
\[
    s := \bigcap_{i=1}^{m^+} f_i
\]
By only keeping the intersection, we filter out Flow IDs belonging to network communications that are not deterministically associated with the event, such as periodic or sporadic messages, as discussed in Section~\ref{sec:problem} and subsection~\ref{sec:traffic-capture}.


%% Moved this to subsubsection "Grouping packets per Flow ID"
% \subsubsection{Retrieve Flow ID's fixed port(s)}

% We consider, in turn, each flow comprised in the \emph{reference pattern},
% which will be dubbed \emph{base flow} in the following.
% Its hosts (regardless of the direction) and transport protocol
% will be used as is to provide data for one of the flows comprising the ultimate signature. \CP{What does it mean to provide data?}
% The ports, however, must not be taken as is;
% indeed, a lot of network flows showcase at least one port number which is random,
% usually on the client side,
% sometimes even on both sides.
% Therefore, we must first examine flows in the other patterns
% which correspond to the same data exchange as the given base flow,
% and consider their ports data.
% Once all related flows have been covered,
% we can potentially extract the port which was identical in all exchanges,
% as part of the signature's flow.
% It must be noted that,
% if at least one of the patterns does not contain any flow matching the base one,
% the base flow must be removed from the \emph{signature},
% as it is not present in every traffic capture.
% \CP{You can remove this last sentence if you talk of the intersection earlier.}


% \subsubsection{Construction of the event signature}

% By joining the hosts and transport protocol from the base flow,
% and the ports data derived from all matching flows,
% we obtain a flow which is part of the event signature.
% By repeating the process over each \emph{base flow} contained in the \emph{reference pattern},
% we construct the complete \emph{event signature} for the event under test.



% \begin{algorithm}
%     \caption{Signature extraction algorithm}
%     \label{algo:sig-extract}
%     \begin{algorithmic}
%         \Function{extract\_signature}{$\mathit{patterns}$}
%             \State sort(patterns)
%             \State ref\_pattern $\gets$ patterns[0]
%             \For{ flow \textbf{in} ref\_pattern }
%                 \State flow\_id $\gets$ extract\_id(flow)
%                 \For{ pattern \textbf{in} patterns \textbackslash\ \{ref\_pattern\} }
%                     \State matching\_flow $\gets$ find\_matching\_flow(pattern, ref\_flow)
%                     \If{ \textbf{no} matching\_flow }
%                         \State \textbf{skip} flow
%                     \EndIf
%                     \State flow\_id $\gets$ flow\_id + matching\_flow
%                 \EndFor
%             \State signature $\gets$ signature + flow\_id
%             \EndFor
%         \State \Return signature
%         \EndFunction
%     \end{algorithmic}
% \end{algorithm}


\subsection{Step 3: Blocking flows with the event signature tree}
\label{sec:event-tree}

The event signature tree is a \emph{connected}, \emph{acyclic}, \emph{rooted tree} where the nodes of the tree are Flow IDs, with the exception of the root node. The tree is used to keep track of the Flow IDs already seen and blocked.

%The intuition behind the tree is the following: After interacting with the device, we obtain an event signature consisting of Flow IDs. We then pick a Flow ID from the signature and configure the firewall to block packets matching it and repeat the interaction. To keep track which Flow IDs have been already blocked and which still have to be investigated, we use the tree.

\subsubsection{Tree creation}

At the beginning, when the profiling starts for a specific interaction of the device, the tree only consists of the root node. The firewall running on the switch or AP to which the Smart Home device and the companion app are connected does not block any traffic.
%(lines~\ref{algoempty1}--\ref{algoempty2} in Algorithm~\ref{algo:exp}).

After obtaining the event signature $s$ from step 2, we add the Flow IDs in the signature as a child node to the root node.
%(lines~\ref{addloop1}--\ref{addloop2} in Algorithm~\ref{algo:exp}).
For the next iteration of steps 1 through 3, we select a node, i.e. a Flow ID, that has not been visited yet from the tree and instruct the firewall to block all packets matching that node and all its ancestors in the tree. The node will be marked as visited and the newly found Flow IDs will be added as children to it, and the procedure is repeated.
%(lines~\ref{algoselect1}--\ref{algoselect2}).

The algorithm ends if no unvisited nodes are left. Theoretically, the algorithm could continue to run indefinitely if new Flow IDs are discovered in each iteration. However, in our experiments, the algorithm always terminated after a finite number of iterations because the more Flow IDs are blocked, the more constrained the communication of the device becomes and the fewer successful event traces are captured, until no more new Flow IDs are added to the tree.

\subsubsection{Tree traversal and pruning}

To select the next node,
%(line~\ref{algoselect})
we use a Breadth-First Search (BFS) \cite{algorithms-book} traversal,
i.e., we process all nodes at a given depth before proceeding to the next level.
%We chose BFS over DFS (\textbf{D}epth-\textbf{F}irst \textbf{S}earch) because it more closely fits to our experimental strategy.
Our objective is to trigger all possible network flows corresponding to a Smart Home device event, i.e., express all possible nodes in the event signature tree.
To manage resource usage and execution time, two strategies are used to limit the size of the tree.

Firstly, we already remove event signatures for which less than half of the trace captures were successful, i.e., $m^+ < m/2$, in step 2.
%(lines~\ref{algotest1}--\ref{algotest2} in Algorithm~\ref{algo:exp}).
In this way, we filter out event signatures for which there is not enough data to reliably determine the Flow IDs that are with a high probability linked to the event. In practice, we observe a polarization in terms of successful event execution:
either all event executions succeed ($m^+=m$) or none ($m^+=0$).
The latter occurs when the firewall rules prevent the event's success.
Setting the threshold at $m/2$ is therefore a conservative choice.

\input{figures/tikz/tree_pruning.tex}

Secondly, we prune branches of the tree
which will likely not provide new information,
i.e. no new Flow IDs,
by applying an \textit{ad hoc} pruning heuristic.
To determine which heuristic we can apply without losing any information,
we ran preliminary experiments with one of our testbed's devices,
the TP-Link HS110 smart plug \cite{hs110}.
We observed that, for any two nodes with the same Flow ID,
their children were always identical.
We conclude it is likely that no new information will be found
by processing a node identical to one which has already been processed,
regardless of its position in the tree.
Therefore, we adopt the \emph{node pruning} heuristic,
illustrated in Fig.~\ref{fig:tree-pruning}:
a node is pruned if an equivalent node, i.e., a node with the same Flow ID, has already been processed.


%% FDK: shortened this section, as I feel it does not need such extensive explanation

% A first insight is that,
% since the firewall rules are all blocking,
% the rule order is not important.
% As such, two distinct tree paths from the root to a leaf are equivalent
% if they comprise the same set of nodes,
% regardless of their order.
% We considered two pruning strategies:
% \emph{path pruning} and \emph{node pruning}.

% The \emph{path pruning} strategy prunes a tree node
% if the set of nodes comprising the path from the root to it
% has already been processed, regardless of their order.
% Considering the example tree shown on Fig.~\ref{fig:tree-pruning}
% (an excerpt of a real event signature tree
% resulting from our experiments with the TP-Link HS110 smart plug \cite{hs110}),
% this strategy will prune the node depicted with $\square$,
% as a path composed of node \circled{A} and \circled{B} has already been processed.

% Secondly, we must decide when to prune the exploration of the tree.
% A first insight is that,
% since the firewall rules are all blocking,
% the rule order is not important.
% As such, two distinct tree paths from the root to a leaf are equivalent
% if they comprise the same set of nodes,
% regardless of their order.
% % Moreover, a path $P_b$ which contains a subset of the nodes in another path $P_a$
% % is completely covered by it. 
% % A first pruning strategy would then be to prune a path
% % if it is a subset of, or equivalent to,
% % an already processed path.
% This \emph{path pruning} strategy is illustrated in Figure~\ref{fig:tree-pruning},
% which showcases an excerpt of a real event signature tree
% resulting from our experiments with the TP-Link HS110 smart plug \cite{hs110}.
% The path comprising the nodes \circled{B} and \circled{A} is pruned,
% as an equivalent path, comprising \circled{A} and \circled{B},
% had been processed before.

% To potentially prune the tree even further,
% we explore \emph{node pruning},
% i.e. pruning a tree branch if a node equivalent to the one being processed has already been visited (line~\ref{algoprune} in the algorithm) in a previous branch,
% as illustrated in Figure~\ref{fig:tree-pruning}, where \circled{A}, \circled{B} and \circled{C} are not explored the second time they are encountered.
% The complete resulting event signature tree
% when applying \emph{path pruning}
% is shown in Appendix~\ref{app:preliminary}
% in textual form.

% The \emph{node pruning} strategy prunes a tree node
% if an equivalent singular node has already been processed.
% Considering the example tree shown on Fig.~\ref{fig:tree-pruning},
% this strategy will prune the nodes depicted with $\triangle$.
% This strategy is more aggressive,
% so we performed some preliminary experiments
% to ensure it will still allow to discover all possible flows.
% In practice, we instrumented one of our testbed's devices,
% the TP-Link HS110 smart plug \cite{hs110}.
% We performed a preliminary batch of experiments with it,
% while applying the \emph{path pruning} strategy.
% We observed that
% for any occurrence of a given node,
% its children were always identical.
% The takeaway is, therefore,
% that \emph{path pruning} might be a too conservative strategy in our case,
% and that we can safely apply \emph{node pruning}
% without losing information.


\subsubsection{How to block packets matching a Flow ID}\label{sec:firewall}

As explained, a Flow ID comprises traffic features from multiple networking layers, such as hostnames, port numbers, and application layer information. 
The presence of application layer information in the Flow ID requires a firewall that is able to match and reject traffic based on information found at that layer. A simple firewall, such as the default Linux kernel firewall NFTables \cite{nftables} (successor of the well-known IPTables) is not sufficient.
Instead, we leverage the open-source Smart Home firewall by De Keersmaeker \textit{et al.} \cite{smart-home-firewall}. It is based on NFTables, while enhancing its capabilities to match additional application-layer protocols.
However, this firewall can only work with \emph{allow} rules, while our profiling algorithm is based on blocking rules.
Therefore, we modified the firewall, turning it into a \emph{deny-list} firewall. 
In our prototype implementation of the profiling algorithm, we translate the list of Flow IDs into firewall blocking rules and let the firewall enforce them for the next batch of experiments.
The code of the modified firewall will be made publicly available.

%In our prototype implementation of the profiling algorithm, we translate the list of Flow IDs to a list of blocking rules and produce a configuration file that we give to the firewall before starting the next batch of event generations.

%These rules, applied through a configuration file before the next batch of experiments, force the device or the companion app to reveal alternative communication paths by preventing them from using previously discovered network flows.


%% FDK: Removed the following subsection, as it is less relevant now that the paper's focus is on event robustness.
% \subsection{Profiling outcome}

% The outcome of our methodology takes the form of an \emph{event signature tree}.
% We define the Flow IDs occurring at the first tree depth as \emph{first-level} Flow IDs,
% whereas the ones appearing at depths of two and deeper are \emph{hidden} Flow IDs.
% The latter are the communication patterns which can be discovered
% only through our multi-level approach,
% and therefore missed by state-of-the-art techniques.

% \FDK{Now that the paper's focus is on robustness, do we still need the following paragraph ?}
% One of the incentives behind our work is to strengthen the security of Smart Home networks, by providing more robust device profiles, which could be used, amongst others, as configuration input for allow-list firewalls or IDS. Conveniently, the outcome of the profiling algorithm is a fully explored multi-level event signature tree containing all Flow IDs encountered for a specific interaction, and the firewall configuration files produced during the profiling can be directly used with the allow-list firewall by De Keersmaeker \textit{et al.} (see Section~\ref{sec:firewall}). They are also translatable to MUD profiles \cite{mud}, albeit at the expense of dropping the extracted application layer data, as MUD does not support it.
