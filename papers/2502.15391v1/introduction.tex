\section{Introduction}

The architecture is an important design aspect related to the
functionality of a computer network. For instance, the code of a
consensus protocol changes depending on whether it is used in a ring
or a clique-shaped network. The architecture is also a factor on which
the traffic balance and overall efficiency of communication
depend. Being able to formally model network architectures is a key
enabler for the use of verification algorithms that prove absence of
error scenarios in a distributed environment (\eg deadlocks, races
or mutual exclusion violations), or convergence towards a desired goal
(\eg building a spanning-tree or electing a leader).

The impressive size of present day networks requires
\emph{parameterized models}, that describe infinite families of
networks having an unbounded number of nodes. The problem of
\emph{parameterized verification} (\ie proving correctness for any
number of processes) often amounts to model-checking a small cut-off
of the system (see~\cite{BloemJacobsKhalimovKonnovRubinVeithWidder15}
for a survey). In cases where a cut-off does not exist or is too
large, symbolic representations of invariants (\ie sets of
configurations closed under local and communication actions) using \eg
boolean constraints~\cite{DBLP:conf/concur/EsparzaRW22},
well-structured transitions
systems~\cite{DBLP:conf/lics/AbdullaCJT96}, monadic second-order
logic~\cite{DBLP:journals/jlap/BozgaIS21} or finite-state
automata~\cite{DBLP:conf/birthday/LinR21} can be used to decide a
parameterized safety problem in a matter of seconds. This is because,
in particular, parameterized verification methods do not suffer from
the state explosion problem of classical model-checking techniques,
that scale poorly in the number of concurrent processes.

However, a current limitation is that most techniques rely on
hard-coded network topologies, typically
cliques~\cite{GermanSistla92}, rings~\cite{ClarkeGrumbergBrowne86} or
combinations thereof~\cite{DBLP:journals/dc/AminofKRSV18}. Many
architecture description languages have been developped by the
software engineering community (see, \eg \cite{bradbury2004survey} and
\cite{rumpe2017classification} for surveys) to support network design
but, in general, these languages lack support for verification. Only
few recent parameterized verification techniques take architectures as
input of the problem, described using, \eg
first-order~\cite{DBLP:conf/tacas/BozgaEISW20} or separation
logic~\cite{DBLP:journals/tcs/BozgaIS23}. Such descriptive
(logic-based) languages are typically hard to use, because of the
generality of their semantics, that requires complex frame conditions
to specify what is actually \emph{not} part of the architecture.
%% (\eg a chain between two given nodes, with no other disconnected
%% components).

\vspace*{-.5\baselineskip}
\paragraph{Contributions} We consider the parametric verification problem
for process networks specified by \emph{graph grammars} that use
the operations of the standard \emph{hyperedge-replacement} (\hrtext)
algebra of graphs~\cite{courcelle_engelfriet_2012} to describe how
graphs are inductively build from smaller subgraphs. This constructive
aspect of graph grammars makes them appealing for network design,
because recursive specification of types and datastructures are
widespread among programmers. Graph grammars are, moreover, at the
core of a solid theory (see~\cite{courcelle_engelfriet_2012} for a
comprehensive survey). In principle, \hrtext\ graph grammars can
specify families of graphs having bounded tree-width, such as chains,
rings, stars, trees (of unbounded rank) and beyond, \eg overlaid
structures such as trees or stars with certain nodes linked in a
list. Since cliques and grids are families of unbounded tree-width,
neither can be specified using \hrtext\ graph grammars.
\ifLongVersion However, the relation between the expressiveness of
\emph{vertex-replacement} (\vrtext) and that of
\hrtext\ grammars\footnote{Each \vrtext\ grammar can be transformed
  into an \hrtext\ grammar modulo an elimination of epsilon edges,
  similar to the epsilon edge elimination for finite automata.}
~\cite{COURCELLE1995275} could provide a generalization of our
techniques to cliques, bipartite graphs and, in general, architectures
specified using \vrtext\ grammars. We consider this for future
work. \fi

Because the parameterized verification problem is undecidable, even
for chain-like networks, we consider two orthogonal lines of
work. First, following the seminal work of German and Sistla
\cite{GermanSistla92}, where identities of processes communicating
through rendez-vous in a clique is ignored to keep only the number of
processes in each state, we define a \emph{counting abstraction} that
folds the infinite set of networks specified using a \hrtext{} grammar
into a finite set of Petri nets, which subsumes the behaviors of the
original set of networks. As a consequence, if a set of places is not
covered by an execution of some of the resulting Petri nets, then it
is not covered by the original set of behaviors. These coverability
problems can be used to express mutual exclusion, and can encode other
properties (\eg finite-valued consensus). Even though, computing the
counting abstraction for clique networks is fairly
simple~\cite{GermanSistla92}, it is less trivial for families of
networks specified by a grammar. We circumvent these technical
challenges by defining appropriate \hrtext{} algebras, in which the
abstraction can be computed by a finite Kleene iteration of the
grammar. This line of work is motivated by several recent advances on
the theory~\cite{DBLP:journals/sosym/FinkelL15} and tool
support~\cite{DBLP:conf/apn/Wolf18a} for the reachability and
coverability problem for Petri nets. The abstraction has been
implemented in a prototype tool and a number of experiments showing
the effectiveness of the method have been carried out.

Second, we define a decidable fragment of the original problem, by
restricting the local behavior of the nodes to \emph{pebble-passing
  systems}, where a finite (but unbounded) number of identical pebbles
can be moved from one node to another. We inspire ourselves from
token-passing
systems\cite{aminof-paramtoken-vmcai14,aminof-model-ijcar16} for which
a restriction on the behavior of each proccess allows to get
decidability results of some verification problems. Note that in our
case, the processes definition are simple, but we allow an unbounded
number of tokens/pebbles. Interestingly, our decidable restriction
applies only to the local behavior and does not restrict the family of
networks considered, other than that they must be the language of a
given \hrtext{} grammar. Examples of problems from this decidable
fragment include token-rings, tree-traversal used, in general, for
notification and binary consensus among the participants of general
(\hrtext-specified) architectures. We have studied the complexity of
the decidable fragment and found it to be doubly-exponential in the
unary size of the coverability property and in the maximal tree-width
the set of networks generated by the grammar. At the same time, we
found the problem to be \pspace-hard.

\vspace*{-.5\baselineskip}
\paragraph{Related Work}
Traditionally, verification of unbounded networks of parallel
processes considers known architectural patterns, typically cliques or
rings \cite{GermanSistla92,ClarkeGrumbergBrowne86}. Because the price
for decidability is drastic restriction on architecture styles
\cite{BloemJacobsKhalimovKonnovRubinVeithWidder15}, more recent works
propose practical semi-algorithms, \eg \emph{regular model checking}
\cite{KestenMalerMarcusPnueliShahar01} or \emph{automata learning}
\cite{ChenHongLinRummer17}. Here the architecture is implicitly
determined by the class of language recognizers: word automata encode
pipelines or rings, whereas tree automata describe trees.

Specifying parameterized concurrent systems by inductive definitions
is reminiscent of \emph{network grammars}
\cite{ShtadlerGrumberg89,LeMetayer,Hirsch}, that use inductive rules
to describe systems with linear (pipeline, token-ring) architectures
obtained by composition of an unbounded number of processes. In
contrast, our language is based on the \hrtext\ graph
algebra. Verification of network grammars against safety properties
(reachability of error configurations) requires the synthesis of
\emph{network invariants} \cite{WolperLovinfosse89}, computed by
rather costly fixpoint iterations \cite{LesensHalbwachsRaymond97} or
by abstracting (forgetting the particular values of indices in) the
composition of a small bounded number of instances
\cite{KestenPnueliShaharZuck02}. A more recent line of work considers
a lightweight invariant synthesis method based on the inference of
\emph{structural invariants}\footnote{Invariants that depend on the
  structure of a Petri net, which hold for any of its executions.} of
an infinite family of Petri nets, for parameterized systems whose
network architectures are specified using
logic~\cite{DBLP:conf/tacas/BozgaEISW20,DBLP:journals/tcs/BozgaIS23}. This
method is geared towards deadlock-freedom and mutual exclusion,
whereas our counting abstraction method works for coverability
properties, in general.

Other efficient methods to verify safety properties of parameterized
networks consist in changing the semantics of behaviors to obtain an
over-approximation having a decidable safety verification problem.  In
\cite{abdulla-monotonic-foundcs09}, the authors have implemented such
a scheme using a \emph{monotonic abstraction}, where the resulting
abstraction is a \emph{well-structured transition
  systems}~\cite{DBLP:conf/lics/AbdullaCJT96}.  They first consider
pipeline architectures, where communication is done by checking
existentially or universally the state of the other proceess.  In
\cite{abdulla-approximated.fmsd09}, a similar technique is applied to
networks with clique architectures, where processes can manipulate
shared boolean and natural variables. In contrast, both our methods
target network architectures defined by unrestricted \hrtext{} graph
grammars.
