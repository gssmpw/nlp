\newcommand{\Instrs}{\mathit{Instrs}}
\newcommand{\Count}{\mathit{Count}}
\newcommand{\Minsk}{\mathit{Minsk}}

To show that the two mentioned problems are undecidable,
we propose a reduction from the halting problem for a (two-counter) Minsky machine \cite{minsky-computation-67}.
A Minsky machine is a finite sequence of instructions $\Instrs$ manipulating two natural variables $c1$ and $c2$,
called counters, and each instruction has one of the following form:
\begin{enumerate}
\item $\ell:ci=ci+1;\mathtt{goto}~\ell';$
\item $\ell:\mathtt{if}~ci==0?~\mathtt{goto}~ \ell'; \mathtt{else}~ci=ci-1;\mathtt{goto}~\ell'';$
\end{enumerate}
where $\ell$.$\ell'$ and $\ell''$ are labels.
All labels are followed by an instruction except $\ell_f$, the final label.
The halting problem asks if the Minsky machine starting from an initial label $\ell_0$
with the two counters set to $0$ halts, \ie reaches the label $\ell_f$.

\input{figure-undecidable2}

\input{figure-undecidable1}

We fix a Minsky machine given by its set of instructions $\Instrs$.
In order to simulate this model, we consider a family of systems which all have the following shape:
there is a central vertex which simulates the instructions of the machine,
on the right side of this vertex there is a sequence of vertices to encode the value of the counter $c1$
and on its left side a sequence of vertices to encode the value of the counter $c2$.
The central node has process type $\Minsk$, it is represented on \figref{fig:proc-minsk},
where we notice that there is a place for each instruction label
and furthermore the initial marking only puts a token in the place $\ell_0$.
The vertices to encode the value of counter $c1$ are labeled by the process type $\Count_1$
depicted on \figref{fig:proc-count1} and the vertices to encode the value of counter $c2$
are labeled the process type $\Count_2$ which is similar to $\Count_1$.
We remark that in the process types $\Count_1$, there are two specific places $0C1$ and $1C1$,
and that initially the place $0C1$ is marked.
During a simulation of the machine with a behavior,
the number of vertices of process type $\Count_1$ for which a token is in place $1C1$
corresponds to the current value of $c1$.
To ease the explanation, we shall call the central vertex,
the controller and the vertices labeled by $\Count_i$ the counting processes for $c_i$, for $i=1,2$.
The grammar $\grammar_\Minsk$ producing the desired family of systems is given on
\figref{fig:grammmar-minsk} and an example of a system belonging to
$\alangof{}{\algof{S}}{\grammar_{\Minsk}}$ is depicted on \figref{fig:undec4}
(we omit the label on the edges to ease presentation).

We now provide the main ingredients of the simulation.
At the beginning the controller is in state $\ell_0$
and all the counting processes are in states $0C1$ or $0C2$ according to their process type,
$\Count_1$ or $\Count_2$.
At any `big step' (\ie when forgetting intermediate steps needed for the correctness) of the simulation,
when the controller is in a state corresponding to a label of the Minsky machine,
the sequence of the counting processes of type $\Count_1$ will always have the following form:
it begins with a sequence of processes in state $1C1$ and ends with a sequence of processes in state $0C1$
(the same property holds for the counting processes of type $\Count_2$ considering the state $1C2$ and $0C2$).
Moreove, the number of processes in state $1C1$ (\resp $1C2$) represents the value of the first (\resp second)
counter at this stage of the simulation. We have then the following behavior:
\begin{itemize}
    \item when the controller simulates an instruction of the form $\ell:c1=c1+1;\mathtt{goto}~\ell';$
        it begins to request for an increment with the transition $\ell\_reqi1$ and it waits for its acknowledgment with $\ell\_acki1$.
        The request is then transmitted by all the processes in state $1C1$
        to the first counting process in state $0C1$ which changes its state and acknowledges it moving to $1C1$,
        the acknowledgment being transmitted back to the controller.
        If there is no process of type $\Count_1$ in state $0C1$, the simulation is stuck,
        it means that the system is not `big' enough to simulate correctly the Minsky machine.
    \item when the controller simulates an instruction of the form
        $\ell:\mathtt{if}~c1==0?~\mathtt{goto}~ \ell';\linebreak[0] \mathtt{else}~c1=c1-1;\mathtt{goto}~\ell'';$
        and the counter $c1$ is equal to $0$,
        this means that there is no counting process of type $\Count_1$ in state $1C1$,
        then the controller takes the transition $\ell\_zero1$ together with the first counting process of type
        $\Count_1$ which takes the transition $z1$.
    \item when the controller simulates an instruction of the form
        $\ell:\mathtt{if}~c1==0?~\mathtt{goto}~ \ell';\linebreak[0] \mathtt{else}~c1=c1-1;\mathtt{goto}~\ell'';$
        and the counter $c1$ has a strictly positive value, then, as for the increment,
        the controller requests a decrement with the transition $\ell\_decqi1$,
        this request is transmitted to the last counting process of type $\Count_1$ in state $1C1$
        (there is necessarily one) and if this last process has a right neighbor whose state is $0C1$,
        then it moves to $0C1$ acknowledging the decrement,
        this acknowledgment being transmitted back to the controller which goes in state $\ell''$.
        Note that each counting process in state $1C1$ can choose nondeterministically
        whether it is or not the last one in state $1C1$ by taking the transition $pd1$
        (it transmits the decrement request) or $d1$ (it chooses it is the last one),
        but if it makes a bad choice, the simulation will be stuck.
    \item Finally, we have that the machine halts if and only if there is a system and an execution
        in its associated behavior where the controller ends in $\ell_f$.
\end{itemize}


We now provide an example on how the transmission of the information is performed in a system.
We consider a Minsky machine with two instructions
$\ell_0:c1=c1+1;\mathtt{goto}~\ell';$ and $\ell':c1=c1+1;\mathtt{goto}~\ell'';$.
\figref{fig:behav} presents a partial representation of a behavior simulating these instructions
with two counter processes of type $\Count_1$
(to make the figure readable, we put a dotted line between two transitions when they are synchronized).
First, the  controller simulates the instruction $\ell_0:c1=c1+1;\mathtt{goto}~\ell';$,
it takes the transition $\ell_0\_reqi1$ which says that it requests an increment,
this transitions is `synchronized' with two transitions $i1$ and $pi1$ of the first counting process
on its right and since the state of this process is initially $0C1$
then this first process takes the transition $i1$.
Afterwards, the controller waits for an acknowledgment of its request for an increment
which will arrive when it takes the transition $\ell_0\_acki1$.
This latter transition is synchronized with the two transitions $ai_1$ and $si_1$
of the first counting process.
In our case, the pair $(\ell_0\_acki1,ai_1)$ takes place and the controller ends in state $\ell'$
and the first counting process in $1C1$.
The controller can now simulate $\ell':c1=c1+1;\mathtt{goto}~\ell'';$.
It takes the transition $\ell'\_reqi1$, but this time the first counting process (which is in state $1C1$)
takes the transition $pi1$ signifying it transmits the request to its neighbor (if there is one).
Afterwards, if the first counting process has a neighbor, it  fires the transition $qi1$
(which synchronizes with the transitions $i1$ and $pi1$ of its right neighbor),
and its neighbor which is in state $0C1$ takes the transition $i1$,
they then both move with the pair $(ri1,ai1)$ and the second counting process arrives in state $1C1$
whereas the first counting process is able to acknowledge the fact that the increment has been performed
to the controller process with the synchronization $(\ell'\_acki1,si_1)$.
We end in a configuration where the controller is in state $\ell''$
and the two first counting processes of type $\Count_1$ are in state $1C1$.

\input{figure-gramm-undec}


We now present more formal arguments to explain why the reduction holds.
We first describe the systems belonging to the language of the  grammar $\grammar_{\Minsk}$
(presented on \figref{fig:grammmar-minsk}) in the algebras of systems.
Given two naturals $m,n \geq 1$, we define the system
$\asys^{m,n}_{\mathit{\Minsk}}=(\verts,\edges,\vlab)$ where:
\begin{itemize}
    \item $\verts=\{v^2_m,\ldots,v^2_1,v^c,v^1_1,\ldots,v^1_n\}$;
    \item $\edges=$\\$\{(v^2_i,a,v^2_{i-1}) \mid i \in [2,m] \mbox{ and } a \in \{(i2,qi2),(pi2,qi2),(ai2,ri2),(si2,ri2),\linebreak[0](d2,qd2),\linebreak[0](pd2,qd2),(ad2,rd2),(sd2,rd2),,(z2,nextz2)\}\} \cup $\\
    $\{(v^1_i,a,v^1_{i+1}) \mid i \in [1,n-1] \mbox{ and } a \in \{(qi1,i1),(qi1,pi1),(ri1,ai1),(ri1,si1),\linebreak[0](qd1,d1),\linebreak[0](qd1,pd1),(rd1,ad1),(rd1,sd1),(nextz1,z1)\}\} \cup$\\
    $\{(v^2_1,a,v^c) \mid a \in \{(i2,\ell\_reqi2), (pi2,\ell\_reqi2), (ai2,\ell\_acki2),(si2,\ell\_acki2)\mid \ell \in L_{inc2} \}\} \cup$\\
    $\{(v^2_1,a,v^c) \mid a \in \{(z2,\ell\_zero2),(d2,\ell\_reqd2),(pd2,\ell\_reqd2),(ad2,\ell\_ackd2),(sd2,\ell\_ackd2)\mid \ell \in L_{dec2} \}\} \cup$
    $\{(v^c,a,v^1_1) \mid a \in \{(\ell\_reqi1,i1), (\ell\_reqi1,pi1), (\ell\_acki1,ai1),(\ell\_acki1,si1)\mid \ell \in L_{inc1} \}\} \cup$\\
    $\{(v^c,a,v^1_1) \mid a \in \{(\ell\_zero1,z1),(\ell\_reqd1,d1),(\ell\_reqd1,pd1),(\ell\_ackd1,ad1),(\ell\_ackd1,sd1)\mid \ell \in L_{dec1} \}\}$ where $L_{inc1}$, $L_{dec1}$, $L_{inc2}$ and $L_{dec2}$ are defined on \figref{fig:grammmar-minsk};
    \item $\vlab(v^2_i)=\Count_2$ for all $i \in [1,m]$, $\vlab(v^1_i)=\Count_1$ for all $i \in [1,n]$ and $\vlab(v^c)=\Minsk$.

\end{itemize}

We can easily see that
$\alangof{}{\algof{S}}{\grammar_{\Minsk}}=\set{\asys^{m,n}_{\Minsk} \mid m \geq 1 \mbox{ and } n \geq 1}$.

We have given on Figures \ref{fig:proc-count1} and \ref{fig:proc-minsk},
the way process types $\Count_1$, $\Count_2$ and $\Minsk$ are built.
We notice that in the process type $\Minsk$,
there is a single vertex labelled by the halting label of the Minsky machine $\ell_f$. We let  $\amark_f:\mathcal{Q}
  \rightarrow\nat$ (where $\mathcal{Q}$ is the set of states of the different processes) be the marking such that
$\amark_f(\ell_f)=1$ and $\amark_f(q)=0$ for all other places $q$.
Our reduction claims that the Minsky machine halts iff the answer to
$\paramreach{\grammar_{\Minsk}}{\{\ell_f\}}{\amark_f}$
(\resp $\paramcover{\grammar_{\Minsk}}{\{\ell_f\}}{\amark_f}$) is positive.

Let us explain why the reduction holds for the two verification problems.
First note that if the answer to $\paramreach{\grammar_{\Minsk}}{\{\ell_f\}}{\amark_f}$
is positive then so is the answer to $\paramcover{\grammar_{\Minsk}}{\{\ell_f\}}{\amark_f}$
by definition of the problem.
Now assume the answer to $\paramcover{\grammar_{\Minsk}}{\{\ell_f\}}{\amark_f}$ is positive,
it means that there exists a system $\asys^{m,n}_{\Minsk}=(\verts,\edges,\vlab)$
with $\verts=\{v^2_m,\ldots,v^2_1,v^c,v^1_1,\ldots,v^1_n\}$
where $v^c$ is the only vertex such that $\vlab(v^c)=\Minsk$
and a marking $\overline{\amark}\in\cover{\behof{\asys^{m,n}_{\Minsk}}}$ verifying
$\overline{\amark}(\ell_f,v^c)=\amark(\ell_f)=1$.
By definition, there exists hence a marking $\overline{\amark}' \in \reach{\behof{\asys^{m,n}_\Minsk}}$
such that $\overline{\amark} \leq \overline{\amark}'$.
But since since $\behof{\asys^{m,n}_\Minsk}$ is an automata-like PN,
we have $\overline{\amark}'(\ell_f,v^c)=1$ and since $v^c$ is the only vertex such that $\vlab(v^c)=\Minsk$,
we conclude that the answer to $\paramreach{\grammar_{\Minsk}}{\{\ell_f\}}{\amark_f}$ is positive.

\input{figure-undecidable4}
\input{figure-undecidable3}

Assume now that the Minsky machine halts.
Let $m$ and $n$ be the maximum counter value taken by the counter $c2$ (\resp the counter $c1$)
during the execution of the machine starting at $\ell_0$ with $c1$ and $c2$ set at $0$ and ending in $\ell_f$.
We can simulate this execution, as we have explained before, in the behavior $\behof{\asys^{m+1,n+1}_\Minsk}$
to reach a marking with a token in the place $(\ell_f,v^c)$.
As a matter of fact, the answer to $\paramcover{\grammar_{\Minsk}}{\{\ell_f\}}{\amark_f}$ is positive.

On the other side if the answer to $\paramcover{\grammar_\Minsk}{\{\ell_f\}}{\amark_f}$ is positive,
there exists a system $\asys^{m,n}_\Minsk \in \alangof{}{\algof{S}}{\grammar_\Minsk}$
and a marking $\overline{\amark} \in \reach{\behof{\asys^{m,n}_\Minsk}}$
such that $\overline{\amark}(\ell_f,v^c)=1$.
The only way to reach such a marking from the initial marking of $\behof{\asys^{m,n}_\Minsk}$
is to simulate faithfully at each step an instruction of the Minsky machine
(if the behavior performs a wrong non-deterministic choice or if the vertices encoding the counters are not enough,
the simulation get stuck and there is no way to put a token in a place of the process type $\Minsk$ corresponding to a label of the machine).
We hence can rebuild an execution of the Minsky machine which ends in the label $\ell_f$. \qed

