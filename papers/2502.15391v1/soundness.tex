\section{Counting Abstraction}

We define the \emph{counting abstraction} of a set of behaviors as a
set of PNs having finitely many underlying nets with possibly
infinitely many initial markings each. The basic idea is to fold (i)
the copies of the same place from some process type into a single
place and (ii) the transitions having the same sets of predecessors
and successors into a single transition. We show that the counting
abstraction of the set of behaviors of a parameterized system
described by an \hrtext{} grammar can be computed by evaluating the
same grammar in a finite \hrtext{} algebra. Moreover, the infinite set
of initial markings of a folded PN can be finitely described by
another PN derived from the initial grammar describing the system.

\ifLongVersion\else
\begin{textAtEnd}[category=quotients]
\fi

We formalize our counting abstraction as quotienting of PNs with
respect to an equivalence relation on places, that has finitely many
classes. Let $\amarkednet = (\anet,\amark_0)$ be a PN with underlying
net $\anet = (\places,\trans,\weight)$ and let $\sim \subseteq \places
\times \places$ be an equivalence relation on the places of
$\anet$. We denote by $[q]_\sim$ the $\sim$-equivalence class of the
place $q \in \places$. The \emph{place-quotient} of $\anet$
w.r.t. $\sim$ is the net $(\places_{/\sim}, \trans, \weight_{/\sim})$,
where:
\begin{align*}
\places_{/\sim} \isdef \set{[q]_\sim \mid q \in \places} \hspace*{8mm}
\weight_{/\sim}([q]_\sim,t) \isdef \sum_{r \in [q]_\sim} \weight(r,t) \hspace*{8mm}
\weight_{\sim}(t,[q]_\sim) \isdef \sum_{r \in [q]_\sim} \weight(t,r) 
\end{align*}
for all $q \in \places$ and $t \in \trans$. The equivalence relation
$\sim$ on places induces the following equivalence relation $\approx
\subseteq \trans \times \trans$ on transitions:
\begin{align}\label{eq:rel-trans}
  t \approx t' \iffdef & \left\{\begin{array}{l}
    \weight_{/\sim}([q]_\sim,t) = \weight_{/\sim}([q]_\sim,t') \\
    \weight_{/\sim}(t,[q]_\sim) = \weight_{/\sim}(t',[q]_\sim) 
    \end{array}\right.
    \text{, for all } q \in \places 
\end{align}
We denote by $[t]_\approx$ the $\approx$-equivalence class of the
transition $t \in \trans$.  The \emph{quotient} of the net $\anet$
w.r.t. $\sim$ is the net $\anet_{/\sim} \isdef
({\places}_{/\sim},{\trans}_{/\approx},{\weight}_{/\sim})$, where
${\weight}_{/\sim}([t]_\approx) \isdef {\weight}_{/\sim}(t)$, for all
$t \in \trans$.  Note that ${\weight}_{/\sim}([t]_\approx)$ is
well-defined because all transitions in the equivalence class have the
same incoming and outgoing weighted edges. The quotient of the PN
$\amarkednet$ is the PN ${\amarkednet}_{~/\sim} \isdef
({\anet}_{/\sim},{\amark_0}_{\sim}) $, where
${\amark}_{/\sim}([q]_\sim) \isdef \sum_{r\in[q]_\sim} \amark(r)$, for
each $\amark:\places\rightarrow\nat$ and $q \in \places$. Quotienting
of markings is lifted to sets as usual ${\markset}_{/\sim} \isdef
\set{{\amark}_{/\sim} \mid \amark \in \markset}$.  The following lemma
relates the reachable (\resp coverable) markings in a PN with that of
its quotient:

\begin{lemma}\label{lemma:quotient-soundness}
  For each PN $\amarkednet$ and equivalence relation
  $\sim \subseteq \placeof{\amarkednet} \times \placeof{\amarkednet}$,
  ${\reach{\amarkednet}}_{/\sim} \subseteq \reach{{\amarkednet~}_{/\sim}}$
  and ${\cover{\amarkednet}}_{/\sim} \subseteq \cover{{\amarkednet~}_{/\sim}}$.
\end{lemma}
\begin{proof}
  Let $\amarkednet=(\anet,\amark_0)$,
  where $\anet=(\places,\trans,\weight)$.
  The proof for ${\reach{\amarkednet}}_{/\sim} \subseteq \reach{{\amarkednet}_{~/\sim}}$
  relies on the two facts below and
  ${\cover{\amarkednet}}_{/\sim} \subseteq \cover{{\amarkednet}_{~/\sim}}$
  is an immediate consequence. 

  \begin{fact}
    For all markings $\amark,\amark' : \places\rightarrow\nat$ and each transition $t \in \trans$,
    $\amark \fire{t} \amark'$ in $(\places,\trans,\weight)$ only if
    ${\amark}_{/\sim} \fire{t} {\amark'}_{/\sim}$
    in $({\places}_{/\sim}, \trans, {\weight}_{/\sim})$.
  \end{fact}
  \begin{proof}
    If $t$ is enabled in $\amark$ it means that
    $\amark(q) \geq \weight(q,t)$ for every $q \in \places$.
    Applying this inequality pointwise on
    ${\amark}_{/\sim}([q]_\sim)
      = \sum_{q' \in [q]_\sim} \amark(q')
      \geq \sum_{q' \in [q]_\sim} \weight(q',t)
      = {\weight}_{/\sim}([q]_\sim,t)$
    gives that $t$ is enabled in ${\amark}_{/\sim}$.
    By a similar manipulation,
    ${\amark}_{/\sim}([q]_\sim)
      - ({\weight}_{/\sim})([q]_\sim,t)
      + ({\weight}_{/\sim})(t,[q]_\sim)
    = \sum_{q' \in [q]_\sim} \amark(q')
      - \sum_{q' \in [q]_\sim} \weight(q',t)
      + \sum_{q' \in [q]_\sim} \weight(t,q')$
    can be rearranged into
    $\sum_{q' \in [q]_\sim} (\amark(q') - \weight(q',t) + \weight(t,q'))
      = \sum_{q' \in [q]_\sim} \amark'(q')
      = {\amark'}_{/\sim}([q]_\sim)$,
    which shows that the result of firing $t$ in ${\amark}_{/\sim}$
    is indeed ${\amark'}_{/\sim}$.
    \qed
  \end{proof}

  \begin{fact}
    For all markings $\amark,\amark' : \places\rightarrow\nat$ and each transition $t \in \trans$,
    ${\amark}_{/\sim} \fire{t} {\amark'}_{/\sim}$
    in $({\places}_{/\sim},\trans,{\weight}_{/\sim})$
    if and only if ${\amark}_{/\sim} \fire{[t]_\approx} {\amark'}_{/\sim}$
    in $({\places}_{/\sim},{\trans}_{/\approx},{\weight}_{/\sim})$.
  \end{fact}
  \begin{proof}
    $\weight(q,t) = {\weight}_{/\approx}(q,[t]_\approx)$
    for every $q \in \places$ by definition,
    therefore $t$ is enabled in ${\amark}_{/\sim}$ if and only if $[t]_\approx$
    is enabled in ${\amark}_{/\sim}$.
    Furthermore firing $t$ or $[t]_\approx$ in ${\amark}_{/\sim}$
    results in the same marking since
    ${\amark}_{/\sim}(q) - \weight(q,t) + \weight(t,q)
      = {\amark}_{/\sim}(q)
      - {\weight}_{/\approx}(q,[t]_\approx)
      + {\weight}_{/\approx}([t]_\approx,q)$.
    \qed
  \end{proof}
\end{proof}
\begin{proofSketch}
  Every transition $\amark \fire{t} \amark'$ in $(\places,\trans,\weight)$
  can be successively traced to
  some transition ${\amark}_{/\sim} \fire{t} {\amark'}_{/\sim}$
  in $({\places}_{/\sim}, \trans, {\weight}_{/\sim})$,
  then some ${\amark}_{/\sim} \fire{[t]_\approx} {\amark'}_{/\sim}$
  in $({\places}_{/\sim},{\trans}_{/\approx},{\weight}_{/\sim})$.
  Through this every firing sequence can be lifted from $(\places,\trans,\weight)$
  to $({\places}_{/\sim},{\trans}_{/\approx},{\weight}_{/\sim})$,
  thus preserving all reachability properties.
  \qed
\end{proofSketch}
\ifLongVersion\else
\end{textAtEnd}
\fi

\subsection{Folding}

We define a folding function on the domain $\universeOf{B}$ of system
behaviors. Let $\open{\asys} = (\asys,\sources)$ be a system and
$(\amarkednet,\overline{\sources}) = \behof{\open{\asys}}$ be its
behavior (\defref{def:behavior}). \ifLongVersion\else The folding is
defined as quotienting a behavior $\amarkednet$ via an equivalence
relation $\equiv$ on the places of $\amarkednet$. Note that quotienting is a
standard operation, meaning that equivalent places and transitions
having the same sets of predecessor and successor equivalence classes
$[q]_{\equiv}$, for $q \in \placeof{\amarkednet}$, are joined
together\footnote{We give the formal definition of the quotienting of
  a PN in \appref{app:quotients}.}, the result being denoted as
$\amarkednet_{~/\equiv}$. \fi

We recall that the places of $\amarkednet$ are pairs $(q,v)$, where $q
\in \placeof{\ptypes}$, $v \in \vertof{\asys}$ and the sources of the
behavior are labeled by the function $\overline{\sources}$. A function
$\eta : \sourcelabels \rightarrow \vertof{\asys}$, having $\dom{\eta}
\supseteq \dom{\sources}$, defines the following equivalence relation
$\foldrel{\eta} \subseteq \placeof{\amarkednet} \times
\placeof{\amarkednet}$:
\begin{align}\label{eq:foldrel}
  (q_1,v_1) \foldrel{\eta} (q_2,v_2) \iff
  q_1 = q_2 \text{ and } \set{v_1,v_2} \cap \img{\eta} \neq \emptyset \Rightarrow v_1 = v_2
\end{align}
\ie two places of $\amarkednet$ corresponding to the same place of a
process type (within two distinct instances thereof) are considered
equivalent, except for the sources with labels $\eta$, that are
equivalent only with themselves. The equivalence class of a place
$(q,v) \in \placeof{\amarkednet}$ is denoted
$[(q,v)]_{\foldrel{\eta}}$.
Because we have assumed that the set
of places corresponding to different process types are disjoint,
$(q_1,v_1) \foldrel{\sources} (q_2,v_2)$ implies that
$\vlabof{\asys}(v_1) = \vlabof{\asys}(v_2)$, \ie the two vertices are
instances of the same process type.

The \emph{folding} of $(\amarkednet,\overline{\sources})$ is defined
as $\foldof{\amarkednet,\overline{\sources}} \isdef
({\amarkednet}_{~/\foldrel{\sources}},{\overline{\sources}}_{/\foldrel{\sources}})$,
where, for each mapping $\eta : \sourcelabels \rightarrow
\vertof{\asys}$ having $\dom{\eta} \supseteq \dom{\sources}$, we
define $\overline{\sources}_{/\foldrel{\eta}}(\asrc,
[q]_{\foldrel{\eta}}) \isdef
[\overline{\sources}(\asrc,q)]_{\foldrel{\eta}}$ if $\asrc \in
\dom{\eta}$, else undefined, for each $\asrc \in \sourcelabels$. We
refer to \figref{fig:folding} for examples.

%% , for all $\asrc \in \sourcelabels$, 
%% \begin{align}\label{eq:fold}
%%   {\overline{\sources}}_{/\foldrel{\eta}}(\asrc,[q]_{\foldrel{\eta}}) \isdef & 
%%   \left\{\begin{array}{ll}
%%     \left[\overline{\sources}(\asrc,q)\right]_{\foldrel{\eta}} & \text{, if } \asrc \in \dom{\eta} \\
%%     \text{undefined} & \text{, otherwise}
%%   \end{array}\right. 
%% \end{align}

\input{figure-folding}

%% \begin{example}
%%   \figref{fig:folding} provides an example of the folding of the behavior of  $\asys_1$ (a) and of $\asys_2$ (b) from \figref{fig:proc-typ1} (c) and (d), respectively.
%% \end{example}

%% The following explicit interpretations of the \hrtext{} function symbols in
%% $\algof{B}$ are used in the proof of \lemref{lemma:cong-beh-fold}.

\ifLongVersion\else
\begin{textAtEnd}[category=proofs]
\fi
\begin{lemma}\label{lemma:direct-char-beh}
  Let $(\amarkednet,\overline{\sources})$ and $(\amarkednet',\overline{\sources'})$ be open behaviors. Then, we have: 
  \begin{align}
    \label{eq:pop}
    (\amarkednet,\overline{\sources}) \pop{\algof{B}} (\amarkednet',\overline{\sources'}) = & ~{(\amarkednet \uplus \amarkednet', \overline{\sources} \cup \overline{\sources'})}_{/\srcrel{\sources}{\sources'}} \\
    \label{eq:restrict}
    \restrict{\slabs}{\algof{B}}(\amarkednet,\overline{\sources}) = & ~(\amarkednet,\proj{\overline{\sources}}{\slabs\times\placeof{\amarkednet}}) \text{, for all } \slabs \finsubseteq \sourcelabels \\
    \label{eq:rename}
    \rename{\alpha}{\algof{B}}(\amarkednet,\overline{\sources}) = & ~(\amarkednet,\overline{\sources}\circ(\alpha^{-1} \times \fnid)) \text{, for all finite permutations } \alpha \text{ of } \sourcelabels
  \end{align}
\end{lemma}
\begin{proof}
  (\ref{eq:pop}) We first explain why despite some abuse of notation,
  the right-hand side of the equation is well-defined. Recall that
  $\sources : \sourcelabels \rightarrow \placeof{\amarkednet}$ and
  $\sources' : \sourcelabels \rightarrow \placeof{\amarkednet'}$ are
  injective, and that their lifting to behaviors as
  $\overline{\sources}$ and $\overline{\sources'}$ have disjoint
  images, because the systems whose behaviors
  $(\amarkednet,\overline{\sources})$ and
  $(\amarkednet',\overline{\sources'})$ are, must have disjoint sets
  of vertices, by the definition of $\pop{\algof{S}}$. Then,
  $\overline{\sources}^{-1}$ and $\overline{\sources}^{-1}$ are
  well-defined partial functions, and they have disjoint domains, thus
  $\overline{\sources}^{-1}\cup\overline{\sources'}^{-1}$ is an
  unambiguously defined partial function. It is however not injective,
  and its kernel matches places labeled by the same source in both
  $(\amarkednet,\overline{\sources})$ and
  $(\amarkednet',\overline{\sources'})$.

    Strictly speaking $\overline{\sources}\cup\overline{\sources'}$ is
    not well-defined because if there are shared sources then
    $\sources$ and $\sources'$ have non-disjoint domains.  However by
    construction the functions
    ${\overline{\sources}}_{/\srcrel{\sources}{\sources'}}$ and
    ${\overline{\sources'}}_{/\srcrel{\sources}{\sources'}}$
    coincide on their shared domain.  Thus the function
    ${\overline{\sources}}_{/\srcrel{\sources}{\sources'}} \cup
    {\overline{\sources'}}_{/\srcrel{\sources}{\sources'}}$ is
    well-defined.  Rather than writing: 
    \[({(\amarkednet\uplus\amarkednet')}_{/\srcrel{\sources}{\sources'}},
    {\overline{\sources}}_{/\srcrel{\sources}{\sources'}} \cup
    {\overline{\sources'}}_{/\srcrel{\sources}{\sources'}})\] we stick
    to ${(\amarkednet \uplus \amarkednet', \overline{\sources} \cup
      \overline{\sources'})}_{/\srcrel{\sources}{\sources'}}$ which,
    despite having some intermediate objects not completely
    well-defined, remains intuitively unambiguous.

    The definition of $(\asys,\sources) \pop{\algof{S}}
    (\asys',\sources')$ takes the disjoint union $\asys \uplus \asys'$
    and fuses pairs of $\asrc$-sources and identical edges.  The
    equivalence relation that determines when to fuse $\asrc$-sources
    happens to be exactly the kernel of
    $\sources^{-1}\cup\sources'^{-1}$.  Recall that the
    $\asrc$-sources of a system become sets of $(\asrc,q)$-sources in
    the behavior and that each edge is translated into a transition.
    Thus the kernel of $\sources^{-1}\cup\sources'^{-1}$
    lifted to behaviors is exactly the kernel of
    $\overline{\sources}^{-1}\cup\overline{\sources}^{-1}$,
    from which we deduce that the quotient by $\srcrel{\sources}{\sources'}$ is
    compatible with the translation from systems to behaviors, which
    gives the desired property.  

    \vspace*{\baselineskip}
    \noindent
    (\ref{eq:restrict}) This fact follows from
    $\overline{\proj{\sources}{\slabs}} =
    \proj{\overline{\sources}}{\slabs\times\places}$, for any finite subset of
    source labels $\slabs\finsubseteq\sourcelabels$.

    \vspace*{\baselineskip}
    \noindent
    (\ref{eq:rename}) This fact follows from $\overline{\sources \circ
      \alpha^{-1}} = \overline{\sources}\circ(\alpha^{-1}\times\fnid)$,
    for any permutation $\alpha:\sourcelabels\rightarrow\sourcelabels$.  \qed
\end{proof}
\begin{proofSketch}
  It is not obvious that these objects are all well-defined,
  since $\overline{\sources}$ and $\overline{\sources'}$ do not coincide on their
  shared domain. They do once we quotient by $\srcrel{\sources}{\sources'}$.
  The rest comes from unfolding the definition of the $\overline{\bullet}$ operator.
  \qed
\end{proofSketch}
\ifLongVersion\else
\end{textAtEnd}
\fi

The following lemma allows to define an algebra of abstract behaviors
$\absof{\algof{B}}$ (\figref{fig:alg-zoo}) from the algebra
$\algof{B}$ of behaviors, using \autoref{prop:cong-homo}. The domain
of $\absof{\algof{B}}$ is the set $\absof{\universeOf{B}}$ of folded
behaviors, \ie quotients of behaviors
$(\amarkednet,\overline{\sources})$ w.r.t. the $\foldrel{\sources}$
relation.

\begin{lemmaE}[][category=proofs]\label{lemma:cong-beh-fold}
  $\kerof{\afold}$ is an \hrtext{} congruence. 
\end{lemmaE}
\begin{proofE}
  By a small abuse of notation we shall denote by
  $\foldrel{\sources}$ both the equivalence relation
  on places as well as the equivalence relation
  on transitions that it induces as defined in
  \autoref{eq:rel-trans}.

  The main proof relies on the following preliminary observations
  about manipulating quotients and markings, which hold for any
  permutation $\alpha : \sourcelabels\rightarrow\sourcelabels$ and any
  set $\slabs\finsubseteq \sourcelabels$:
  \begin{enumerate}[(i)]
    \item\label{it1:cong-beh-fold} $\sources$ and $\sources\circ\alpha^{-1}$
      have the same range, which leads to $\foldrel{\sources}$
      and $\foldrel{\sources\circ\alpha^{-1}}$ having the same
      equivalence classes and defining the same quotients;
    \item\label{it2:cong-beh-fold} the bijectivity of $\alpha$ and the fact that
      $\foldrel{\sources}$
      does not identify vertices with different sources mean that
      $\overline{\sources\circ\alpha^{-1}} = \overline{\sources}\circ\alpha^{-1}$,
      and ${(\overline{\sources} \circ\alpha^{-1})}_{/\foldrel{\sources}}
      = {\overline{\sources}}_{/\foldrel{\sources}} \circ\alpha^{-1}$;
    \item\label{it3:cong-beh-fold} because $\proj{\sources}{\tau}$
      is a restriction of $\sources$,
      the equivalence relation induced by the former is a superset of the latter,
      and equivalence classes of $\foldrel{\proj{\sources}{\tau}}$ are unions
      of equivalence classes of $\foldrel{\sources}$.
    \item\label{it4:cong-beh-fold}
      ${\overline{\sources_1}}_{/\foldrel{\sources_1}} =
      {\overline{\sources_2}}_{/\foldrel{\sources_2}}$ implies
      $\sources_1 = \sources_2$.  Pick some
      ${\overline{\sources_1}}_{/\foldrel{\sources_1}}(\sigma,[q]_\sim)
      =
      {\overline{\sources_2}}_{/\foldrel{\sources_2}}(\sigma,[q]_\sim)$.
      Unfolding the definitions gives that
      $[\overline{\sources_1}(\asrc,q)]_{\foldrel{\sources_1}} =
      [\overline{\sources_2}(\asrc,q)]_{\foldrel{\sources_2}}$, which
      are equal to $[(q,\sources_1(\asrc))]_{\foldrel{\sources_1}}$
      and $[(q,\sources_2(\asrc))]_{\foldrel{\sources_2}}$
      respectively.  The equivalence classes respect the labeling of
      sources, so both of the above places are alone in their
      equivalence class.  This proves $(q,\sources_1(\asrc)) =
      (q,\sources_2(\asrc))$ from which we easily get
      $\sources_1(\asrc) = \sources_2(\asrc)$. Since the choice of
      $\asrc\in\sourcelabels$ was arbitrary, we obtain $\sources_1 =
      \sources_2$.
  \end{enumerate}

  We now proceed separately for each \hrtext{} function symbol: 
  \begin{itemize}
    \item $\sgraph{a}{\asrc_1}{\asrc_2}{}$
      is of arity zero thus trivially 
      $\sgraph{a}{\asrc_1}{\asrc_2}{\algof{B}} \kerof{\afold} \sgraph{a}{\asrc_1}{\asrc_2}{\algof{B}}$.
    %
    \item $\rename{\alpha}{}$: Let
      $(\amarkednet_{~1},\overline{\sources_1}) \kerof{\afold}
      (\amarkednet_{~2},\overline{\sources_2})$ be two open behaviors
      having the same folded image. Using observation
      (\ref{it1:cong-beh-fold}) above and given that
      $\rename{\alpha}{\algof{B}}$ does not modify the underlying net
      and the initial marking, we deduce that
      $\foldof{\rename{\alpha}{\algof{B}}(\amarkednet_{~1},\overline{\sources_1})}$
      and
      $\foldof{\rename{\alpha}{\algof{B}}(\amarkednet_{~2},\overline{\sources_2})}$
      have the same underlying net and initial marking. Then
      observation (\ref{it2:cong-beh-fold}) yields
      ${(\overline{\sources_1\circ\alpha^{-1}})}_{/\foldrel{\sources_1\circ\alpha^{-1}}}
      =
      \left({\overline{\sources_1}}_{/\foldrel{\sources_1}}\right) \circ\alpha^{-1}
      =
      \left({\overline{\sources_2}}_{/\foldrel{\sources_2}}\right) \circ\alpha^{-1}
      =
      {(\overline{\sources_2\circ\alpha^{-1}})}_{/\foldrel{\sources_2\circ\alpha^{-1}}}$
      and we conclude that
      $\rename{\alpha}{\algof{B}}(\amarkednet_{~1},\overline{\sources_1})
      \kerof{\afold}
      \rename{\alpha}{\algof{B}}(\amarkednet_{~2},\overline{\sources_2})$
    %
    \item $\restrict{\slabs}{}$: Let
      $(\amarkednet_{~1},\overline{\sources_1}) \kerof{\afold}
      (\amarkednet_{~2},\overline{\sources_2})$ be two open behaviors
      having the same folded image. By observation
      (\ref{it3:cong-beh-fold}), we have that $\foldrel{\sources_i}
      \subseteq \foldrel{\proj{\sources_i}{\tau}}$ for $i = 1,2$.
      This means that
      ${\amarkednet_{~i}}_{/\foldrel{\proj{\sources_i}{\tau}}}
      =
      {\left({\amarkednet_{~i}}_{/\foldrel{\sources_i}}\right)}_{/\foldrel{\proj{\sources_i}{\tau}}}$
      and because we know that (a)
      ${\amarkednet_{~1}}_{/\foldrel{\sources_i}} =
      {\amarkednet_{~2}}_{/\foldrel{\sources_2}}$ as well as
      (b) $\foldrel{\proj{\sources_1}{\tau}} =
      \foldrel{\proj{\sources_2}{\tau}}$, we deduce that
      ${\amarkednet_{~1}}_{/\foldrel{\proj{\sources_1}{\tau}}}
      =
      {\amarkednet_{~2}}_{/\foldrel{\proj{\sources_2}{\tau}}}$.
      Since, moreover,
      ${\overline{\sources_1}}_{/\foldrel{\sources_1}} =
      {\overline{\sources_2}}_{/\foldrel{\sources_2}}$, we
      conclude that
      ${\overline{\sources_1}}_{/\foldrel{\proj{\sources_1}{\tau}}}
      =
      {\overline{\sources_2}}_{/\foldrel{\proj{\sources_2}{\tau}}}$
      and thus
      $\foldof{\restrict{\slabs}{\algof{B}}(\amarkednet_{~1},\overline{\sources_1})}
      =
      \foldof{\restrict{\slabs}{\algof{B}}(\amarkednet_{~2},\overline{\sources_2})}$. 
    %
    \item $\aop = \pop{\algof{B}}$: Let
      $(\amarkednet_{~1},\overline{\sources_1}) \kerof{\afold}
      (\amarkednet_{~2},\overline{\sources_2})$ and
      $(\amarkednet'_{~1},\overline{\sources_1}) \kerof{\afold}
      (\amarkednet'_{~2},\overline{\sources_2})$ be pairwise
      equivalent behaviors.  \lemref{lemma:direct-char-beh} gives us
      $\afold((\amarkednet_{~i},\sources_i) \pop{\algof{B}}
      (\amarkednet'_{~i},\sources_i)) =
      ({\amarkednet''_{~i}}_{/\foldrel{\sources''_i}},
      {\overline{\sources''_i}}_{/\foldrel{\sources''_i}})$,
      where $\amarkednet''_{~i} = {(\amarkednet_{~i} \uplus
        \amarkednet'_{~i})}_{/\srcrel{\sources_i}{\sources'_i}}$ and
      $\sources''_i =
      {(\overline{\sources_i}\cup\overline{\sources'_i})}_{/\srcrel{\sources_i}{\sources'_i}}$.
      Since by the initial assumption we have
      ${\overline{\sources_1}}_{/\foldrel{\sources_1}} =
      {\overline{\sources_2}}_{/\foldrel{\sources_2}}$ we
      deduce by observation (\ref{it4:cong-beh-fold}) that $\sources_1
      = \sources_2$.  The same reasoning for $\sources'_1$ and
      $\sources'_2$ gives that the equivalence relations
      $\srcrel{\sources_1}{\sources'_1}$ and
      $\srcrel{\sources_2}{\sources'_2}$ are the same, hence
      $\sources''_1 = \sources''_2$.

      It remains to prove that
      ${\amarkednet''_{~1}}_{/\foldrel{\sources''_1}} =
      {\amarkednet''_{~2}}_{/\foldrel{\sources''_2}}$.  It helps that
      $\srcrel{\sources_i}{\sources'_i}$ fuses only places that are
      sources, while $\foldrel{\sources''_i}$ fuses only places that
      are not sources.  This means that whenever a place is part of
      some non-singleton equivalence class according to
      $\foldrel{\sources''_i}$, its equivalence class according to
      $\srcrel{\sources_i}{\sources''_i}$ is a singleton, and
      reciprocally.  Even though $\foldrel{\sources''_i}$ is
      technically defined on equivalence classes of places, this
      allows us to consider it as an equivalence relation between
      places, and to permute the two quotients to obtain
      ${\amarkednet''_{~i}}_{/\foldrel{\sources''_i}} =
      {(({\amarkednet_i \uplus
          \amarkednet'_i)}_{/\foldrel{\sources''_i}})}_{/\srcrel{\sources_i}{\sources'_i}}$
      It is now sufficient to prove
      ${(\amarkednet_{~1}\uplus\amarkednet'_{~1})}_{/\foldrel{\sources''_1}}
      =
      {(\amarkednet_{~2}\uplus\amarkednet'_{~2})}_{/\foldrel{\sources''_2}}$.
      Seeing that $\foldrel{\sources_i},\foldrel{\sources'_i}
      \subseteq \foldrel{\sources''_i}$ we can insert quotients by
      $\foldrel{\sources_i}$ and $\foldrel{\sources'_i}$ underneath a
      quotient by $\foldrel{\sources''_i}$ without affecting the final
      result:
      ${(\amarkednet_{~i}\uplus\amarkednet'_{~i})}_{/\foldrel{\sources''_i}}
      = {({\amarkednet_{~i}}_{/\foldrel{\sources_i}} \uplus
        {\amarkednet'_{~i}}_{/\foldrel{\sources'_i}})}_{/\foldrel{\sources''_i}}$.
      With this formulation it is finally clear that we can substitute
      the known equalities ${\amarkednet_{~1}}_{/\foldrel{\sources_1}}
      = {\amarkednet_{~2}}_{/\foldrel{\sources_2}}$ and
      ${\amarkednet'_{~1}}_{/\foldrel{\sources'_1}} =
      {\amarkednet'_{~2}}_{/\foldrel{\sources'_2}}$ to get the desired
      property.
  \end{itemize}
  Thus $\afold$ is an \hrtext{} congruence.
  \qed
\end{proofE}
\begin{proofSketch}
  For each function symbol $\aop \in \mathsf{HR}$, we express the effects
  of $\aop$ on the source labeling, essentially proving that if
  $\sources_1$ defines the same folding as $\sources_2$,
  then $\aop(\sources_1)$ defines the same folding as $\aop(\sources_2)$.
\end{proofSketch}

As an immediate consequence of \lemref{lemma:cong-beh-fold}, we obtain
that $\afold$ is a homomorphism between $\algof{B}$ and
$\absof{\algof{B}}$, hence the same \hrtext{} grammar can be used to
both specify an infinite set of behaviors and compute its folded
abstraction:

\begin{corollary}\label{prop:beh-fold}
  For each \hrtext{} grammar $\grammar$, we have
  $\foldof{\alangof{}{\algof{B}}{\grammar}}=\alangof{}{\absof{\algof{B}}}{\grammar}$.
\end{corollary}

Because $\ptypes$ is a finite set of process types, each having
finitely many places, the folded language
$\alangof{}{\absof{\algof{B}}}{\grammar}$ has a finite set of
underlying nets. This is because each transition $t$ in a behavior
$\amarkednet \in \alangof{}{\algof{B}}{\grammar}$ has at most two
incoming/outgoing edges. Since the same holds for each transition of
its quotient, \ie $\amarkednet_{~/\foldrel{\sources}}$, there are
finitely many places and transitions in each underlying net of some
$\amarkednet \in
\alangof{}{\absof{\algof{B}}}{\grammar}$. Nevertheless, the language
$\alangof{}{\absof{\algof{B}}}{\grammar}$ is unbounded, because the
set of initial markings is unbounded. In order to represent this set
in a finite way, we shall proceed in two
steps: \begin{compactenum}[1.]
  %
\item\label{it1:initial-markings} Isolate the initial markings that
  correspond to a given net from
  $\alangof{}{\absof{\algof{B}}}{\grammar}$; we address this problem
  using the Filtering Theorem (\thmref{thm:filtering}).
  %
\item\label{it2:initial-markings} Give a finite representation to the
  set of initial markings of each net; we tackle this problem using
  Esparza's idea \cite{Esparza95} of building PNs that simulate the derivations of the
  ``filtered'' grammars obtained in the previous step.
  %
\end{compactenum}

To formally define the finite set of underlying nets from a language
$\alangof{}{\absof{\algof{B}}}{\grammar}$, we consider the function
$\psi$ on the domain $\absof{\universeOf{B}}$, that drops the initial
marking:
\begin{align}\label{eq:drop}
\psi((\anet,\amark_0),\sources) \isdef (\anet,\sources)
\end{align}
Then, $\psi(\alangof{}{\absof{\algof{B}}}{\grammar})$ is finite,
because the numbers of places and transitions in each net from this
set are bounded by $\cardof{\placeof{\ptypes}}$ and
$\cardof{\placeof{\ptypes}}^4$ (\ie each transition has at most $2$
incoming and $2$ outgoing edges of weight $1$), respectively.

Since none of the operations from $\absof{\algof{B}}$ modify the
initial markings, it is straightforward that $\kerof{\psi}$ is a
\hrtext{} congruence. We define the algebra $\finabsof{\algof{B}}$
(\figref{fig:alg-zoo}) having the finite domain
$\finabsof{\universeOf{B}} \isdef \psi(\absof{\universeOf{B}})$ and
the usual interpretations of the \hrtext{} function symbols given by
\propref{prop:cong-homo}. By standard arguments (similar to
\autoref{prop:sys-beh} and \autoref{prop:beh-fold}), we obtain that
$\psi$ is a homomorphism between $\absof{\algof{B}}$ and
$\finabsof{\algof{B}}$, \ie
$\psi(\alangof{}{\absof{\algof{B}}}{\grammar}) =
\alangof{}{\finabsof{\algof{B}}}{\grammar}$.

As previously discussed, $\alangof{}{\finabsof{\algof{B}}}{\grammar}$
is a finite set. However, to ensure that this set can be effectively
computed, the computation of the interpretation of the
\hrtext{} signature in $\finabsof{\algof{B}}$ needs to be effective:

\begin{propositionE}[][category=proofs]\label{prop:effective-finite-abstraction}
  For each function symbol $\aop$ from the \hrtext{} signature, the
  function $\aop^{\finabsof{\algof{B}}}$ is effectively computable.
\end{propositionE}
\begin{proofE}
  Both the folding $\phi : \behaviors \to \absof{\behaviors}$
  and the projection $\psi : \absof{\behaviors} \to \finabsof{\behaviors}$
  preserve the arity of transitions, so the elements of
  $\finabsof{\behaviors}$ obey $1 \leq \cardof{\pre{t}} = \cardof{\post{t}} \leq 2$
  for every transition $t$, and can thus be seen as behaviors with empty markings:
  we define $z : \finabsof{\behaviors} \to \behaviors$ by
  $z((\anet,\overline{\sources})) \isdef ((\anet,0), \overline{\sources})$.
  Because empty markings added together remain empty,
  $z(\finabsof{\behaviors})$ forms a stable subset of $\behaviors$
  by all operations of \hrtext{}.
  This homomorphism $z$ is a right inverse of the translation from
  $\behaviors$ to $\finabsof{\behaviors}$: $(\psi\circ\afold) \circ z = \fnid$.

  By definition $\aop^{\finabsof{\algof{B}}}(b_1, ..., b_n) =
  (\psi\circ\afold)(\aop^{\algof{B}}((\psi\circ\afold)^{-1}(b_1),...,(\psi\circ\afold)^{-1}(b_n))$.
  Since $\kerof{\psi \circ \afold}$ is an \hrtext{} congruence, any right
  inverse of $\psi\circ\afold$ can replace $(\psi\circ\afold)^{-1}$ in
  the expression above, and a good candidate is $z$ which is an
  effectively computable right inverse.  This gives
  $\aop^{\finabsof{\algof{B}}}(b_1, ..., b_n) =
  \psi(\afold(\aop^{\algof{B}}(z(b_1),...,z(b_n))))$.  All of $z$,
  $\afold$, and $\psi$ are effectively computable, so in order for
  $\aop^{\finabsof{\algof{B}}}$ to be effectively computable it
  suffices that $\aop^{\algof{B}}$ also be effectively computable,
  which is given by the alternative characterizations of \hrtext{} operating
  directly on behaviors in \lemref{lemma:direct-char-beh}.  \qed
\end{proofE}
\begin{proofSketch}
  since $\kerof{\phi}$ is \hrtext{} congruence (and so is $\kerof{\psi}$, obviously),
  it suffices to exhibit a right inverse of $\psi \circ \phi$.
  We find that the candidate $z : \finabsof{\behaviors} \to \behaviors$
  defined by $z((\anet,\overline{\sources})) \isdef ((\anet,0), \overline{\sources})$
  works and provides $\aop^{\finabsof{\algof{B}}} = \psi \circ \phi \circ \aop^{\absof{\algof{B}}} \circ z$
  effectively computable.
  \qed
\end{proofSketch}

By the previous arguments, the language
$\alangof{}{\finabsof{\algof{B}}}{\grammar}$ is finite and effectively
computable, hence it can be produced by a finite Kleene iteration of
the monotonic function that maps a tuple of sets indexed by the
nonterminals of $\grammar$ into their $\finabsof{\algof{B}}$
interpretations, given by the rules of $\grammar$.  Let
$\set{(\anet_1, \overline{\sources_1}), \ldots, (\anet_n,
  \overline{\sources_n})} \isdef
\alangof{}{\finabsof{\algof{B}}}{\grammar}$ be this set. Using the
Filtering Theorem (\thmref{thm:filtering}) one can effectively build
grammars $\grammar_1, \ldots, \grammar_n$ such that:
\begin{align}\label{eq:filtering}
  \psi(\alangof{}{\absof{\algof{B}}}{\grammar_i}) =
  \alangof{}{\finabsof{\algof{B}}}{\grammar_i} =
  \set{(\anet_i,\overline{\sources_i})} \text{, for each } i \in \interv{1}{n}
\end{align}
More precisely, the Filtering Theorem gives, for each $i \in
\interv{1}{n}$, a grammar $\grammar_i$ such that
$\alangof{}{\absof{\algof{B}}}{\grammar_i} =
\alangof{}{\absof{\algof{B}}}{\grammar} \cap
\psi^{-1}(\set{(\anet_i,\overline{\sources_i})})$. By applying $\psi$
to both sides of the equality, we obtain (\autoref{eq:filtering}),
thus taking care of the first step of the construction
(\ref{it1:initial-markings}).

\subsection{Initial Markings}

Let $\grammar=(\nonterm,\rules)$ be any of the grammars $\grammar_1,
\ldots, \grammar_n$ (\autoref{eq:filtering}). To simplify matters at
hand, we assume w.l.o.g that the right-hand side of each rule in
$\grammar$ has exactly one occurrence of an \hrtext{} function symbol,
\ie a constant $\sgraph{a}{\asrc_1}{\asrc_2}{}$, a unary function
symbol $\restrict{\slabs}{}$ or $\rename{\alpha}{}$, or the binary
function symbol $\pop{}$, applied to $0$, $1$ or $2$ variables,
respectively. Note that each grammar can be put in this form, at the
cost of adding polynomially many extra nonterminals.

First, we annotate each nonterminal $X \in \nonterm$ with sets of
sources $\slabs$ that are \emph{visible} (\ie have been introduced by
a constant $\sgraph{a}{\asrc_1}{\asrc_2}{}$ and have not been removed
by some application of $\restrict{\slabs'}{}$) in each complete
derivation starting in $\annot{X}{\slabs}$, where $\annot{X}{\slabs}$
is a shorthand for the pair $(X,\slabs)$.  The annotated grammar
$\widehat{\grammar} = (\widehat{\nonterm}, \widehat{\rules})$ can be
built from $\grammar$ by a standard worklist iteration \ifLongVersion
The relation between $\grammar$ and $\widehat{\grammar}$ is captured
below: \else The language of the annotated grammar
$\widehat{\grammar}$ is the same as the original grammar
$\grammar$.\else\footnote{For reasons of space, the annotation
  algorithm is given in \figref{fig:annotation} from Appendix
  \ref{app:proofs}.}\fi Next, we use the annotated grammar
$\widehat{\grammar} = (\widehat{\nonterm},\widehat{\rules})$, to build
a PN $\initof{\widehat{\grammar}}$ that generates the initial markings
of $\grammar$ in the set of folded PNs (\autoref{prop:beh-fold}).

\ifLongVersion\else
\begin{textAtEnd}[category=initial]
\fi
\begin{lemma}\label{lemma:annotation}
  Let $\grammar=(\nonterm,\rules)$ be a grammar and
  $\widehat{\grammar}=(\widehat{\nonterm},\widehat{\rules})$ be the
  corresponding annotated grammar. Then
  $\alangof{}{\algof{A}}{\grammar} =
  \alangof{}{\algof{A}}{\widehat{\grammar}}$, for each
  \hrtext{} algebra $\algof{A}$.
\end{lemma}
\begin{proof}
  ``$\subseteq$'' Let $X \step{\grammar}^* \theta$ be a complete
  derivation starting with an axiom $\rightarrow X \in \rules$. By
  reverse induction on the length of this derivation we build a
  complete derivation $X^\slabs \step{\widehat{\grammar}}^* \theta$
  starting with an axiom $\rightarrow X^\slabs \in
  \widehat{\rules}$. It is clear that the rules used in this
  derivation are inserted into $\widehat{\rules}$ at line
  \ref{line:insert-rule}, whereas the axiom is inserted at line
  \ref{line:insert-axiom}. We obtain $\alangof{}{\algof{A}}{\grammar}
  \subseteq \alangof{}{\algof{A}}{\widehat{\grammar}}$ by the
  definition of the language of a grammar in $\algof{A}$. 

  \noindent``$\supseteq$'' Let $X^\slabs \step{\widehat{\grammar}}^*
  \theta$ be a complete derivation starting with an axiom $\rightarrow
  X^\slabs \in \widehat{\rules}$. Then the complete derivation $X
  \step{\grammar}^* \theta$ is obtained by applying, for each rule
  $X_0^{\slabs_0} \rightarrow \rho[X_1^{\slabs_1}, \ldots,
    X_n^{\slabs_n}] \in \widehat{\rules}$ the rule $X_0 \rightarrow
  \rho[X_1,\ldots,X_n] \in \rules$. Then $\rightarrow X$ is an axiom
  of $\grammar$, since $\rightarrow X^\slabs$ is an axiom of
  $\widehat{\grammar}$ that has been introduced at line
  \ref{line:insert-axiom}. We obtain $\alangof{}{\algof{A}}{\grammar}
  \supseteq \alangof{}{\algof{A}}{\widehat{\grammar}}$ by the
  definition of the language of a grammar in $\algof{A}$. \qed
\end{proof}
\begin{proofSketch}
  By induction on a complete derivation.
  All rules used by the derivation
  are well-typed with regard to the annotations,
  and thus available in the annotated grammar.
  \qed
\end{proofSketch}

\begin{figure}
  {\small\begin{algorithmic}[0]
    \STATE \textbf{input}: $\grammar=(\nonterm,\rules)$
    \STATE \textbf{output}: $\widehat{\grammar}=(\widehat{\nonterm}, \widehat{\rules})$
  \end{algorithmic}}
  {\small\begin{algorithmic}[1]
    \STATE \textbf{initially} $\widehat{\nonterm} := \emptyset$, 
    $\widehat{\rules} := \emptyset$, 
    $\mathit{changed} := \mathrm{true}$
    \WHILE{$\mathit{changed}$} 
    \STATE $\mathit{changed} := \mathrm{false}$
    \FOR{each $X \rightarrow \rho[X_1,\ldots,X_n] \in\rules$ and $X_1^{\slabs_1}, \ldots, X_n^{\slabs_n} \in \widehat{\nonterm}$}
    \STATE \textbf{match} $\rho[X_1,\ldots,X_n]$ \textbf{with}
    \Statex \begin{minipage}{5cm}
      \vspace*{-\baselineskip}
      \[
      \begin{array}{rcl}
        \sgraph{a}{\asrc_1}{\asrc_2}{} & \Longrightarrow & \slabs := \set{\asrc_1,\asrc_2} \\
        \restrict{\slabs'}{}(X_1) & \Longrightarrow & \slabs := \slabs_1 \cap \slabs' \\
        \rename{\alpha}{}(X_1) & \Longrightarrow & \slabs := \alpha(\slabs_1) \\
        X_1 \pop{} X_2 & \Longrightarrow & \slabs := \slabs_1 \cup \slabs_2
      \end{array}
      \]
    \end{minipage}
    \IF{$X^\slabs \not\in \widehat{\nonterm}$}
    \STATE $\widehat{\rules} := \widehat{\rules} \cup \set{X^\slabs \rightarrow \rho[X_1^{\slabs_1}, \ldots, X_n^{\slabs_n}]}$ \label{line:insert-rule}
    \STATE $\widehat{\nonterm} := \widehat{\nonterm} \cup \set{X^\slabs}$
    \STATE $\mathit{changed} := \mathrm{true}$
    \ENDIF
    \ENDFOR
    \STATE $\widehat{\rules} := \widehat{\rules} \cup \set{\rightarrow X^\slabs \mid \rightarrow X \in \rules,~ X^\slabs \in \widehat{\nonterm}}$ \label{line:insert-axiom}
    \ENDWHILE
  \end{algorithmic}}
  \caption{Bottom-up annotation of a grammar with visible sources}
  \label{fig:annotation}
\end{figure}

Formally we define $\initof{\widehat{\grammar}} \isdef (\anet,\amark_0)$ as:
\begin{align*}
  \placeof{\anet} \isdef & ~\set{S} \uplus \widehat{\nonterm} \uplus \placeof{\ptypes} \hspace*{5mm}
  \transof{\anet} \isdef ~\widehat{\rules} \\
  \weightof{\anet}(S,\rightarrow \annot{X}{\slabs}) \isdef & ~1 \hspace*{5mm}
  \weightof{\anet}(\rightarrow \annot{X}{\slabs}, \annot{X}{\slabs}) \isdef 1
  \text{, for all } \rightarrow \annot{X}{\slabs} \in \widehat{\rules}
  \\
  \weightof{\anet}(\rightarrow \annot{X}{\slabs}, q) \isdef & ~\sum_{\asrc\in\slabs} \initmarkof{\ptypeof{\asrc}}(q)
  \text{, for all } q \in \placeof{\ptypes}
  \\
  \weightof{\anet}(\annot{X}{\slabs},\annot{X_0}{\slabs_0} \rightarrow \rho[\annot{X_1}{\slabs_1},\ldots,\annot{X_n}{\slabs_n}]) \isdef & ~\left\{\begin{array}{ll}
  1 \text{, if } \annot{X}{\slabs} = \annot{X_0}{\slabs_0} \\
  0 \text{, otherwise} 
  \end{array}\right.
  \\
  \weightof{\anet}(\annot{X_0}{\slabs_0} \rightarrow \rho[\annot{X_1}{\slabs_1},\ldots,\annot{X_n}{\slabs_n}], \annot{X}{\slabs}) \isdef & ~\left\{\begin{array}{ll}
  1 \text{, if } \annot{X}{\slabs} \in \set{\annot{X_1}{\slabs_1}, \ldots, \annot{X_n}{\slabs_n}} \\
  0 \text{, otherwise} 
  \end{array}\right.
  \\
  & \text{for all } \annot{X}{\slabs} \in \widehat{\nonterm} \text{ and } \annot{X_0}{\slabs_0} \rightarrow \rho[\annot{X_1}{\slabs_1}, \ldots, \annot{X_n}{\slabs_n}] \in \widehat{\rules}
  \\
  \weightof{\anet}(\annot{X}{\slabs} \rightarrow \restrict{\slabs'}{}(\annot{X_1}{\slabs_1}), q) \isdef & \sum_{\asrc\in\slabs_1\setminus\slabs'} \initmarkof{\ptypeof{\asrc}}(q)
  \text{, for all } q \in \placeof{\ptypes}
  \\
  %% \weight(X_0 \rightarrow \sgraph{a}{\asrc_1}{\asrc_2}{},q) \isdef & ~\left\{\begin{array}{ll}
  %% 1 \text{, if } \initmarkof{\ptypeof{\asrc_i}}(q) = 1 \text{, for some } i \in \set{1,2} \\
  %% 0 \text{, otherwise}
  %% \end{array}\right. \\
  %% & \text{for all } X_0 \rightarrow \sgraph{a}{\asrc_1}{\asrc_2}{} \in \rules_i,~ q \in \placeof{\ptypes} \\
  \amark_{0}(x) \isdef & \left\{\begin{array}{ll}
  1 \text{, if } x = S \\
  0 \text{, otherwise} 
  \end{array}\right. \text{, for all } x \in \placeof{\anet}
\end{align*}
\ifLongVersion\else
\end{textAtEnd}
\fi
This construction is quite intuitive: by reinterpreting each rule of
$\widehat{\grammar}$ as a transition of $\initof{\widehat{\grammar}}$,
we get a PN whose firing sequences mimick derivations of
$\widehat{\grammar}$ in which the rules/transitions of
$\widehat{\grammar}$ and $\initof{\widehat{\grammar}}$ are applied in
the same order. More precisely, a partial derivation having $k$
occurrences of the nonterminal variable $X$, when reinterpreted as a
firing sequence, will lead to a marking in which there are $k$ tokens
in the place represented by $X$. Assume that $\annot{X}{\slabs}
\step{\widehat{\grammar}}^* \theta$ is a complete derivation, \ie
$\theta$ is a ground \hrtext{} term. Then, every instance of some
process type $\ptype$ that occurs in the system $(\asys,\sources)
\isdef \theta^\algof{S}$ starts in a vertex labeled by a source label
$\asrc \in \sourcelabels$ such that, either: \begin{enumerate}[(a)]
  %
  \item\label{it1:sources-instances} $\asrc$ is removed by an
    application of $\restrict{\slabs'}{}$ such that $\asrc \not\in
    \slabs'$, then $\asrc$ occurs in the subtree of $\theta$ rooted at
    the particular occurrence of $\restrict{\slabs'}{}$ that removed
    it, or
  %
  \item\label{it2:sources-instances} $\asrc$ is visible at the root of
    $\theta$, \ie $\asrc\in\slabs$.
  %
\end{enumerate}

\input{figure-initmarking.tex}

When processing the rules of the form $\annot{X}{\slabs} \rightarrow
\restrict{\slabs'}{}(\annot{X_1}{\slabs_1})$ and $\rightarrow
\annot{X}{\slabs}$ in the construction of
$\initof{\widehat{\grammar}}$, we add an outgoing edge to each place
$q$ that is initially marked in $\ptypeof{\asrc}$, for some $\asrc \in
\slabs_1 \setminus \slabs'$ or $\asrc \in \slabs$. Then, for every
instance of the process type that occurs in the system, its initial
marking will be added to $q$ by a firing sequence of
$\initof{\widehat{\grammar}}$. \ifLongVersion
\begin{example}
  \figref{fig:initof-example} shows the PNs obtained by this
  construction applied to $\widehat{\grammar}_{Chain}$ and
  $\widehat{\grammar}_{Star}$, \ie the annotated versions of the two
  grammars from \exref{ex:parameterized-grammars}. Intuitively, a
  chain system generated by the grammar $\grammar_\mathit{Chain}$, see
  \figref{fig:proc-typ1} (b) top, has $1$ instance of the process type
  $\mathit{Cont}$ and $n \geq 2$ instances of the process type
  $\mathit{Proc}$. This means that, initially, there is $1$ token on
  the place $\mathit{tokC}$ and $n\geq2$ tokens in $\mathit{nok}$, as
  in \figref{fig:initof-example} (a) Similarly, the initial marking of
  a star system, see \figref{fig:proc-typ1} (b) bottom, generated by
  the grammar $\grammar_\mathit{Star}$ has $1$ token in
  $\mathit{tokC}$ and $n\geq1$ tokens in $\mathit{nok}$, as in
  \figref{fig:initof-example} (b).
  
  We illustrate the construction of
  $\initof{\widehat{\grammar}_\mathit{Chain}}$ by explaining how the
  transitions labeled (1) and (2) in \figref{fig:initof-example} have
  been introduced: \begin{compactenum}[(1)]
    \item corresponds to the rule $\to C^{\set{\sigma_1}}$: the final
      system has one visible source label $\sigma_1$, whose process
      type is $\ptypeof{\sigma_1} = Proc$. When this rule is applied,
      it creates one instance of $Proc$, hence the outgoing edge to
      $nok$. Since this rule is, its corresponding transition has an
      incoming edge from the start place $S$ of
      $\initof{\widehat{\grammar}_\mathit{Chain}}$ and produces an
      instance of $C^\set{\sigma_1}$, hence the outgoing edge to $C$.
      %
    \item corresponds to the rule $C^\set{\sigma_1} \to
      \restrict{\set{\sigma_1}}{} \rename{\sigma_1 \leftrightarrow
        \sigma_2}{} (C^\set{\sigma_1} \pop{}
      (rel,get)_{(\sigma_1,\sigma_2)})$: it consumes one occurrence of
      $C^\set{\sigma_1}$ and produces another, hence having both an
      incoming and outgoing edge to $C$.  The $\restrict{}{}$
      operation hides a $\sigma_2$-source, where
      $\ptypeof{\sigma_2}=\mathit{Proc}$, thus each application of
      this rule is responsible for one additional instance of the
      process type $Proc$.
  \end{compactenum}
\end{example}
\else We refer to \figref{fig:initof-example} for examples of
initialization PNs obtained by this construction applied to
$\widehat{\grammar}_{Chain}$ and $\widehat{\grammar}_{Star}$, \ie the
annotated versions of the two grammars from
\exref{ex:parameterized-grammars}. \fi For a PN $\amarkednet$ and a
set of places $\mathcal{Q} \subseteq \placeof{\amarkednet}$, we denote
by:
\begin{align}\label{eq:zero-reach}
\zreach{\mathcal{Q}}{\amarkednet} \isdef
\{\amark\in\reach{\amarkednet} \mid \amark(q)=0
\text{, for all } q \in \mathcal{Q}\}
\end{align}
the set of reachable markings having zero tokens in a place from
$\mathcal{Q}$. For a set $\mathcal{M}$ of markings and a set
$\mathcal{Q}$ of places, we denote by
$\proj{\mathcal{M}}{\mathcal{Q}}$ the set of restrictions of each
$\amark\in\mathcal{M}$ to the places in $\mathcal{Q}$. The relation
between the set of folded PNs described by an annotated grammar
$\widehat{\grammar}$ and the PN $\initof{\widehat{\grammar}}$ is
formally captured below:

\begin{lemmaE}[][category=proofs]\label{lemma:initial-markings}
  Let $\widehat{\grammar}=(\widehat{\nonterm},\widehat{\rules})$ be an
  annotated grammar. Then, we have:
  \begin{align*}
  \set{\initmarkof{\amarkednet} \mid (\amarkednet,\sources) \in \alangof{}{\absof{\algof{B}}}{\widehat{\grammar}}}
  = \proj{\zreach{\set{S} \uplus \widehat{\nonterm}}{\initof{\widehat{\grammar}}}}{\placeof{\ptypes}}
  \end{align*}
\end{lemmaE}
\begin{proofE}
  Let $\initof{\widehat{\grammar}} \isdef (\anet,\amark_0)$ in the
  rest of this proof. 
  
  \noindent ``$\subseteq$'' Let $(\amarkednet,\sources) \in
  \alangof{}{\absof{\algof{B}}}{\widehat{\grammar}}$ be a folded PN
  and $\amark\isdef\initmarkof{\amarkednet}$ be its inital marking. By
  the definition of the $\absof{\algof{B}}$ algebra, there exists an
  open behavior $(\overline{\amarkednet},\overline{\sources}) \in
  \alangof{}{\algof{B}}{\widehat{\grammar}}$ such that
  $\foldof{\overline{\amarkednet},\overline{\sources}} =
  (\amarkednet,\sources)$. Let $\annot{X}{\slabs}
  \step{\widehat{\grammar}}^* \theta$ be a complete derivation,
  starting with an axiom $\rightarrow \annot{X}{\slabs} \in
  \widehat{\rules}$ and ending with a ground term $\theta$, such that
  $\theta^\algof{B} = (\overline{\amarkednet},\overline{\sources})$.
  Let $\overline{\amark} \isdef \initmarkof{\overline{\amarkednet}}$
  be the initial marking of $\overline{\amarkednet}$. Note that
  $\overline{\amark}(q,v) = 1$ if $q$ is initially marked in its
  process type and $\overline{\amark}(q,v) = 0$ otherwise, for all
  $(q,v) \in \placeof{\overline{\amarkednet}}$. Then $\amark(q) =
  \sum_{(q,v)\in\placeof{\overline{\amarkednet}}}
  \overline{\amark}(q,v)$, for all $q \in \placeof{\ptypes}$ (we
  recall that the $\foldrel{\overline{\sources}}$-equivalence classes
  are denoted by places from the process types). Let $\amark_{0}
  \fire{\vec{t}} \amark'$ be the firing sequence of
  $\initof{\widehat{\grammar}}$ that mimicks the derivation
  $\annot{X}{\slabs} \step{\widehat{\grammar}}^* \theta$. By the
  definition of $\initof{\widehat{\grammar}}$ we have $\amark' \in
  \reach{\initof{\widehat{\grammar}}}$ and $\amark'(x)=0$, for all $x
  \in \set{S} \uplus \widehat{\nonterm}$. It remains to prove that
  $\amark'$ and $\amark$ agree over $\placeof{\ptypes}$. Let $q \in
  \placeof{\ptypes}$ be a place and distinguish the following
  cases: \begin{itemize}
    %
  \item If $q$ is not initially marked in its process type then
    $\amark(q)=0$. But $\amark'(q)=0$ follows from the definition of
    $\initof{\widehat{\grammar}}$, because the only places from
    $\placeof{\ptypes}$ having an incoming edge in
    $\initof{\widehat{\grammar}}$ are the places from
    $\placeof{\ptypes}$ that are initially marked in their respective
    process types.
    %
  \item Else, $q$ is initially marked in its process type and
    $\amark(q)$ is the number of instances of that process type in the
    system $\theta^\algof{S}$. Then, $\amark'(q)=\amark(q)$ by the argument made at
    points (\ref{it1:sources-instances}) and
    (\ref{it2:sources-instances}) above.
    %
  \end{itemize}

  \noindent ``$\supseteq$'' Let $\amark\in
  \reach{\initof{\widehat{\grammar}}}$ be a marking such that
  $\amark(x)=0$, for all $x \in \set{S} \uplus \widehat{\nonterm}$.
  Since each firing sequence of $\initof{\widehat{\grammar}}$ starting
  from $\amark_0$ corresponds to a derivation of $\widehat{\grammar}$
  starting from an axiom $\rightarrow \annot{X}{\slabs} \in
  \widehat{\rules}$, the firing sequence $\amark_0 \fire{\vec{t}}
  \amark$ corresponds to a complete derivation $\annot{X}{\slabs}
  \step{\widehat{\grammar}}^* \theta$, because $\amark(x)=0$, for all
  $x \in \set{S}\uplus\widehat{\nonterm}$, by the definition of
  $\initof{\widehat{\grammar}}$. Let $(\overline{\amarkednet},
  \overline{\sources}) = \theta^\algof{B}$ be the behavior of the
  system built by this derivation and $\overline{\amark} \isdef
  \initmarkof{\overline{\amarkednet}}$ be its initial marking.  Let
  $(\amarkednet,\sources) \isdef \foldof{\overline{\amarkednet},
    \overline{\sources}} = \theta^{\absof{\algof{B}}}$ be the folded
  PN of this behavior and $\amark' \isdef \initmarkof{\amarkednet}$ be
  its initial marking,
  \ie $\amark'(q)=\sum_{(q,v)\in\placeof{\overline{\amarkednet}}} \overline{\amark}(q,v)$,
  for all $q \in \placeof{\ptypes}$.
  We prove that $\amark$ and $\amark'$ agree over $\placeof{\ptypes}$,
  by distinguishing the cases below: \begin{itemize}
    %
    \item If $q$ is not initially marked in its process type then
      $\amark'(q)=0$. In this case $\amark(q)=0$ because there are no
      incoming edges to $q$ in $\initmarkof{\widehat{\grammar}}$, by the
      definition of the latter. 
    %
    \item Else, $q$ is initially marked in its process types and
      $\amark'(q)$ is the number of instances of that process type in
      the system $\theta^\algof{S}$. Then, $\amark(q)=\amark'(q')$, by
      the argument made at points (\ref{it1:sources-instances}) and
      (\ref{it2:sources-instances}) above. \qed
    %
  \end{itemize}
  \qed
\end{proofE}
\begin{proofSketch}
  Read the above as: the initial markings of nets of $\alangof{}{\absof{\algof{B}}}{\widehat{\grammar}}$
  are exactly the reachable markings of $\initof{\widehat{\grammar}}$ once there are no
  more tokens in places representing nonterminals.
  The proof stems from the earlier observation that if partial derivations with
  $k$ instances of $X \in \widehat{\nonterm}$ match with firing sequences
  that put $k$ tokens in place $X$,
  then complete derivations must have zero tokens in every place that represents
  a nonterminal.
  \qed
\end{proofSketch}

\subsection{Soundness}

We now have all the elements to describe our counting abstraction
method and prove its soundness, \ie if the reachability
(resp. coverability) problem has a negative answer for the
abstraction, then the concrete reachability (resp. coverability)
problem has a negative answer. 

For each grammar $\grammar_i=(\nonterm_i,\rules_i)$ defined at
(\autoref{eq:filtering}), that corresponds to the (open) net
$(\anet_i,\sources_i)$, for $i\in\interv{1}{n}$, we define the PN
$\foldpn{\grammar_i} \isdef (\amarkednet_{~i}, \sources_i)$, where:
\begin{align*}
  \placeof{\amarkednet_{~i}} \isdef & ~\placeof{\initof{\widehat{\grammar}_i}} \cup \placeof{\anet_i} \hspace*{3mm}
  \transof{\amarkednet_{~i}} \isdef ~\transof{\initof{\widehat{\grammar}_i}} \uplus \transof{\anet_i} \hspace*{3mm}
  \weightof{\amarkednet_{~i}} \isdef ~\weightof{\initof{\widehat{\grammar}_i}} \cup \weightof{\anet_i} \hspace*{3mm}
  \initmarkof{\amarkednet_{~i}} \isdef ~\initmarkof{\initof{\widehat{\grammar}_i}}
\end{align*}
Note that $\zreach{\placeof{\initof{\widehat{\grammar}_i}} \setminus
  \placeof{\anet_i}}{\foldpn{\grammar_i}}$ is the set of markings of
$\foldpn{\grammar_i}$ that can be reached \emph{after} the full
generation of its initial marking, \ie from those markings that have
no more tokens in any of the places of
$\initof{\widehat{\grammar}_i}$, excepted the initially marked places
of $\placeof{\ptypes}$.

Our verification method for the grammar-based parameterized
reachability and coverability problems
(\defref{def:grammar-parameterized-verif}) relies on the construction
of a finite number of PNs $\foldpn{\grammar_1}, \ldots,
\foldpn{\grammar_n}$ from a given grammar $\grammar$ that describes a
set of systems. \ifLongVersion The relation between the reachability (resp. cover)
set of the original parameterized system and its finitary abstraction
is captured by the following lemma: \fi

\ifLongVersion\else
\begin{textAtEnd}[category=proofs]
\fi
\begin{lemma}\label{lemma:soundness}
  For each grammar $\grammar$ such that
  $\alangof{}{\finabsof{\algof{B}}}{\grammar} =
  \set{(\anet_1,\sources_1), \ldots, (\anet_n, \sources_n)}$, we have:
  \begin{align}
    \label{eq:reach}
    \bigcup_{(\amarkednet,\sources)\in\alangof{}{\algof{B}}{\grammar}} \hspace*{-5mm} \reach{\amarkednet}_{/\foldrel{\sources}} \subseteq &
    ~\reach{\alangof{}{\absof{\algof{B}}}{\grammar}} = \bigcup_{i=1}^n \proj{\zreach{\placeof{\foldpn{\grammar_i}} \setminus \placeof{\ptypes}}{\foldpn{\grammar_i}}}{\placeof{\ptypes}} \\[-1mm]
    \label{eq:cover}
    \bigcup_{(\amarkednet,\sources)\in\alangof{}{\algof{B}}{\grammar}} \hspace*{-5mm} \cover{\amarkednet}_{/\foldrel{\sources}} \subseteq &
    ~\cover{\alangof{}{\absof{\algof{B}}}{\grammar}} = \bigcup_{i=1}^n \proj{\cover{\foldpn{\grammar_i}}}{\placeof{\ptypes}}
  \end{align}
  where $\grammar_i$ is a grammar such that
  $\alangof{}{\finabsof{\algof{B}}}{\grammar_i} =
  \set{(\anet_i,\sources_i)}$, for all $i \in \interv{1}{n}$.
\end{lemma}
\begin{proof}
  (\ref{eq:reach}) For the first inclusion, we compute:
  \begin{align*}
    \bigcup_{(\amarkednet,\overline{\sources})\in\alangof{}{\algof{B}}{\grammar}}\reach{\amarkednet}_{/\foldrel{\sources}} \subseteq
    & ~\bigcup_{(\amarkednet,\overline{\sources})\in\alangof{}{\algof{B}}{\grammar}}\reach{\amarkednet_{~/\foldrel{\sources}}} \text{, by \lemref{lemma:quotient-soundness}} \\
    = & ~\bigcup_{(\amarkednet,\overline{\sources})\in\alangof{}{\algof{B}}{\grammar}}\reach{\foldof{\amarkednet,\overline{\sources}}} \\
    = & ~\reach{\foldof{\alangof{}{\algof{B}}{\grammar}}} \\
    = & ~\reach{\alangof{}{\absof{\algof{B}}}{\grammar}} \text{, by the definition of $\absof{\algof{B}}$}
  \end{align*}
  For the second equality, we compute:
  \begin{align*}
    \alangof{}{\absof{\algof{B}}}{\grammar} = & ~\bigcup_{i=1}^n \alangof{}{\absof{\algof{B}}}{\grammar_i} =
    ~\bigcup_{i=1}^n \alangof{}{\absof{\algof{B}}}{\widehat{\grammar}_i} \text{, by \lemref{lemma:annotation}} \\
    = & \bigcup_{i=1}^n \set{((\anet_i,\amark_0),\sources_i) \mid \amark_0 \in \proj{\big(\zreach{\placeof{\foldpn{\grammar_i}} \setminus \placeof{\ptypes}}{\initof{\widehat{\grammar}_i}}\big)}{\placeof{\ptypes}}}
    \text{, by \lemref{lemma:initial-markings}}
  \end{align*}
  The second equality follows from the above, by the definition of
  $\foldpn{\grammar_i}$.

  \vspace*{\baselineskip}
  \noindent(\ref{eq:cover}) The first inclusion is proved along the
  same lines as the first inclusion of point (\ref{eq:reach}). We
  prove the second equality:
  \[\cover{\alangof{}{\absof{\algof{B}}}{\grammar}} = \bigcup_{i=1}^n \proj{\left(\cover{\foldpn{\grammar_i}}\right)}{\placeof{\ptypes}}\]
  \noindent``$\subseteq$'' Let $\amark \in
  \cover{\alangof{}{\absof{\algof{B}}}{\grammar}}$ be a marking. Then
  there exists a PN $((\anet_i,\amark_0),\sources_i) \in
  \alangof{}{\absof{\algof{B}}}{\grammar}$ having a firing sequence
  $\amark_0 \fire{\vec{t}} \amark'$ such that $\amark \leq \amark'$,
  for some $i \in \interv{1}{n}$. By \lemref{lemma:initial-markings},
  we have $\amark_0 \in
  \proj{\big(\zreach{\placeof{\foldpn{\grammar_i}} \setminus
      \placeof{\ptypes}}{\initof{\widehat{\grammar}_i}}\big)}{\placeof{\ptypes}}$,
  hence $\initof{\widehat{\grammar}_i}$ has a firing sequence
  $\initmarkof{\initof{\widehat{\grammar}_i}} \fire{\vec{t}_0}
  \amark'_0$, for some marking $\amark'_0$ of
  $\initof{\widehat{\grammar}_i}$ that agrees with $\amark_0$ over
  $\placeof{\ptypes}$. Then,
  $\initmarkof{\foldpn{\grammar_i}} = \initmarkof{\initof{\widehat{\grammar}_i}} \fire{\vec{t}_0}
  \amark'_0 \fire{\vec{t}} \amark''$ is a firing sequence of
  $\foldpn{\grammar_i}$, for some marking $\amark''$ of
  $\foldpn{\grammar_i}$ that agrees with $\amark$ over
  $\placeof{\ptypes}$, thus
  $\amark\in\proj{\left(\cover{\foldpn{\grammar_i}}\right)}{\placeof{\ptypes}}$.

  \vspace*{\baselineskip}
  \noindent``$\supseteq$'' Let
  $\amark\in\proj{\left(\cover{\foldpn{\grammar_i}}\right)}{\placeof{\ptypes}}$
  be a marking and $\amark' \in \cover{\foldpn{\grammar_i}}$ be the
  extension of $\amark$ to $\placeof{\foldpn{\grammar_i}}$ that
  witnesses the membership, for some $i \in \interv{1}{n}$. Then there
  exists a firing sequence $\initmarkof{\foldpn{\grammar_i}}
  \fire{\vec{t}} \amark''$ of $\foldpn{\grammar_i}$ such that $\amark'
  \leq \amark''$. W.l.o.g. we consider that $\vec{t} =
  \vec{t}';\vec{t}''$, where $\vec{t}'$ and $\vec{t}''$ contain
  transitions from $\initof{\widehat{\grammar}_i}$ and $\anet_i$,
  respectively. Note that, since these sets of transitions are
  disjoint and independent, any firing sequence of
  $\foldpn{\grammar_i}$ can be rearranged in this way. Hence
  $\initmarkof{\foldpn{\grammar_i}} \fire{\vec{t}'} \amark_0
  \fire{\vec{t}''} \amark''$ is a firing sequence of
  $\foldpn{\grammar_i}$, for some marking $\amark_0 \in
  \reach{\foldpn{\grammar_i}}$. By the definition of
  $\initmarkof{\widehat{\grammar}_i}$, there exists a marking
  $\amark'_0\in\zreach{\placeof{\foldpn{\grammar_i}}
    \setminus \placeof{\ptypes}}{\initof{\widehat{\grammar}_i}}$ such
  that $\amark_0 \leq \amark'_0$. Indeed, $\amark'_0$ can be obtained
  from $\amark_0$ by moving the tokens from $\set{S} \uplus
  \widehat{\nonterm}_i$ into $\placeof{\ptypes}$, thus obtaining an
  initial marking for $\anet_i$, extended with the places $\set{S}
  \uplus \widehat{\nonterm}_i$ all having zero tokens.  By
  \lemref{lemma:initial-markings}, we obtain
  $((\anet_i,\proj{\amark'_0}{\placeof{\ptypes}}),\sources_i) \in
  \alangof{}{\absof{\algof{B}}}{\widehat{\grammar}_i}$, hence
  $((\anet_i,\proj{\amark'_0}{\placeof{\ptypes}}),\sources_i) \in
  \alangof{}{\absof{\algof{B}}}{\grammar_i}$, by
  \lemref{lemma:annotation}. By the monotonicity of firing sequences,
  we obtain that $\amark'_0 \fire{\vec{t}''} \amark'''$ is a firing
  sequence of $\foldpn{\grammar_i}$, for some marking $\amark''' \in
  \reach{\foldpn{\grammar_i}}$ such that $\amark'' \leq \amark'''$.
  By the definition of $\foldpn{\grammar_i}$, we have that
  $\proj{\amark'_0}{\placeof{\ptypes}} \fire{\vec{t}''}
  \proj{\amark'''}{\placeof{\ptypes}}$ is a firing sequence of
  $(\anet_i,\proj{\amark'_0}{\placeof{\ptypes}})$.  Then, we obtain
  $\amark' \leq \amark'''$ by transitivity,
  \ie $\proj{\amark'}{\placeof{\ptypes}} \in \cover{\anet_i,\amark'_0}$
  for some $i\in\interv{1}{n}$, thus
  $\amark\in\cover{\alangof{}{\absof{\algof{B}}}{\grammar}}$. \qed
\end{proof}
\begin{proofSketch}
  Due to the transitivity of reachability,
  we straightforwardly apply in succession the equalities and inclusions provided by
  \lemref{lemma:quotient-soundness}, \lemref{lemma:annotation}, \lemref{lemma:initial-markings}. 
  \qed
\end{proofSketch}
\ifLongVersion\else
\end{textAtEnd}
\fi

The soundness of the method is formally captured below:

\begin{theoremE}[][category=proofs]\label{thm:soundness}
  Let $\grammar$ be an \hrtext{} grammar such that
  $\alangof{}{\finabsof{\algof{B}}}{\grammar}=\set{(\anet_1,\sources_1),
    \ldots, (\anet_n,\sources_n)}$, $\mathcal{Q} \subseteq
  \placeof{\ptypes}$ a set of places, $\amark : \mathcal{Q}
  \rightarrow \nat$ a mapping. Then, one can effectively build
  grammars $\grammar_1,\ldots,\grammar_n$ such that
  $\alangof{}{\finabsof{\algof{B}}}{\grammar_i}=\set{(\anet_i,\sources_i)}$,
  for all $i\in\interv{1}{n}$ and:
  \begin{enumerate}
    %
  \item\label{it1:thm:soundness}
    $\paramreach{\grammar}{\mathcal{Q}}{\amark}$ has a negative answer
    if
    $\amark\not\in\bigcup_{i=1}^n\proj{\zreach{\placeof{\foldpn{\grammar_i}}
        \setminus
        \placeof{\ptypes}}{\foldpn{\grammar_i}}}{\mathcal{Q}}$.
    %
  \item\label{it2:thm:soundness}
    $\paramcover{\grammar}{\mathcal{Q}}{\amark}$ has a negative answer
    if
    $\amark\not\in\bigcup_{i=1}^n\proj{\cover{\foldpn{\grammar_i}}}{\mathcal{Q}}$.
    %
  \end{enumerate}
\end{theoremE}
\begin{proofE}
  The effective construction of $\grammar_1,\ldots,\grammar_n$ follows
  from \propref{prop:effective-finite-abstraction} and the
  effectiveness of the Fitering Theorem (\thmref{thm:filtering}).

  \vspace*{\baselineskip}
  \noindent(\ref{it1:thm:soundness}) We prove the contrapositive: $\paramreach{\grammar}{\mathcal{Q}}{\amark}$ has a positive answer
  \begin{align*}
    \iff & ~\exists \asys \in \alangof{}{\algof{S}}{\grammar} ~\exists \overline{\amark} \in \reach{\behof{\asys}} ~\forall q \in \mathcal{Q} ~.~
    \hspace*{-5mm} \sum_{v \in \vertof{\asys} \mid q \in \placeof{\vlabof{\asys}(v)}} \hspace*{-5mm} \overline{\amark}(q) = \amark(q)
    \text{, by definition of $\mathsf{Reach}$} \\
    \iff & ~\exists (\amarkednet,\sources) \in \alangof{}{\algof{B}}{\grammar} ~\exists \overline{\amark} \in \reach{\amarkednet} ~\forall q \in \mathcal{Q} ~.~
    \hspace*{-5mm} \sum_{v \in \vertof{\asys} \mid q \in \placeof{\vlabof{\asys}(v)}} \hspace*{-5mm} \overline{\amark}(q) = \amark(q)
    \text{, by \propref{prop:sys-beh}} \\
    \iff & ~\exists (\amarkednet,\sources) \in \alangof{}{\algof{B}}{\grammar} ~\exists \amark' \in \reach{\amarkednet}_{/\foldrel{\sources}} ~.~ \proj{\amark'}{\mathcal{Q}} = \amark \\
    \Longrightarrow & ~\exists (\amarkednet,\sources) \in \alangof{}{\algof{B}}{\grammar} ~\exists \amark' \in \reach{\amarkednet_{~/\foldrel{\sources}}} ~.~ \proj{\amark'}{\mathcal{Q}} = \amark
    \text{, by \lemref{lemma:soundness}, \autoref{eq:reach}} \\
    \iff & \amark \in \proj{\reach{\alangof{}{\absof{\algof{B}}}{\grammar}}}{\mathcal{Q}} \text{, by \propref{prop:beh-fold}} \\
    \iff & \amark \in \bigcup_{i=1}^n \proj{\left(\zreach{\placeof{\foldpn{\grammar_i}} \setminus \placeof{\ptypes}}{\foldpn{\grammar_i}}\right)}{\placeof{\ptypes}}
    \text{, by \lemref{lemma:soundness}, \autoref{eq:reach}}
  \end{align*}
  
  \vspace*{\baselineskip}
  \noindent(\ref{it2:thm:soundness}) Along the same lines as
  (\ref{it1:thm:soundness}), using \lemref{lemma:soundness},
  \autoref{eq:cover} instead of \autoref{eq:reach}. \qed
\end{proofE}
\noindent Note that, if $\paramreach{\grammar}{\mathcal{Q}}{\amark}$
(\resp $\paramcover{\grammar}{\mathcal{Q}}{\amark}$) has a negative
answer, then each instance the parameterized system described by
$\grammar$ (\ie the set of systems $\alangof{}{\algof{S}}{\grammar}$)
is safe with respect to the property encoded by the marking $\amark$,
\ie does not reach (\resp cover) the marking $\amark$ over the set of
places $\mathcal{Q}$. For instance, mutual exclusion (only one process
of a certain type in a certain state) is naturally encoded as a
coverability problem.
