\newcommand{\toolrepo}{\mycomment{Neven}{REPO}}
\newcommand{\toolname}{ParCoSys}
\newcommand{\toolnameexplanation}{(\textbf{Par}ameterized \textbf{Co}verability)}

\section{Experiments}

We have implemented the counting abstraction method in the prototype
tool \toolname{}
\footnote{The source code is available as anonymized additional
  material.} \toolnameexplanation{}. The input of the tool is a
grammar describing the system and a safety property to be checked. The
output is a finite set of Petri nets that is fed to the LoLA
analyzer~\cite{lola}. Our choice for LoLA was driven by its robustness
and performance, but any Petri net analyzer can be used as back-end,
in principle.

%% \toolname{} analyzes a family of systems given as input in a text file using
%% a custom syntax that describes both the grammar and the safety specification.
%% After analyzing the input file, \toolname{} converts it to a finite family
%% of Petri nets in a format readable by an existing analysis tool
%% that handles coverability queries.
%% We chose LoLA\footnote{For convenience,
%% a precompiled LoLA is also in the additional material,
%% but it is not part of the contributions of this paper.}
%% \cite{DBLP:conf/apn/Wolf18a} due to its convenient API
%% and good performance, but in principle any Petri net solver can serve as backend.

%\subsection{Overview of the Implementation}

%We briefly present its inner workings and justify the main ways in which
%\toolname{} is not a 1-to-1 translation of the theory presented thus far.
%
%\begin{paragraph}{Method.}
%  After invoking as many LoLA subprocesses as there are nets in the abstract
%  family, we read the individual verdicts and summarize them to determine whether
%  the entire family is safe.
%\end{paragraph}
%
%\begin{figure}
%  \begin{tikzpicture}
%    \node (parse)[draw=black] {parsing};
%    \node (abstr)[draw=black] at ($(parse) + (0.25cm,-1.2cm)$) {abstraction};
%    \node (cover)[draw=black] at ($(parse) + (6.5cm,0)$) {coverability};
%    \node (lola1)[draw=black] at ($(cover) + (-1.2cm,-2cm)$) {LoLA};
%    \node (lola2)[draw=black] at ($(cover) + (0cm,-2cm)$) {LoLA};
%    \node (lola3)[draw=black] at ($(cover) + (1.2cm,-2cm)$) {LoLA};
%
%    \node (error) at ($(parse) + (3cm,1.2cm)$) {error};
%    \node (spec) at ($(parse) + (-1cm,1.2cm)$) {specification};
%    \node[text width=1cm] (verdict) at ($(cover) + (1cm,1.2cm)$) {verdict (Yes/Maybe)};
%
%
%    \draw[->] (spec) -- (parse);
%    \draw[->] (parse) -- (error);
%    \draw[->] (parse) to[bend right=30] node[right,pos=0.3]{grammar} (abstr);
%    \draw[->] (parse) -- node[above,pos=0.3]{formulae} (cover);
%    \draw[->] (abstr) to[bend left=10] node[below,pos=0.2]{nets} (cover);
%    \draw[->] (cover) -- (error);
%    \draw[->] (cover) -- (verdict);
%
%    \draw[->] (abstr) to[in=-140,out=-40,looseness=3] node[below]{fixed point} (abstr);
%
%    \draw[color=gray,line width=1pt,dashed=dash]
%      ($(lola1) + (-9mm,0mm)$)
%      |- ($(lola2) + (0mm,5mm)$)
%      -| ($(lola3) + (9mm,0mm)$)
%      |- ($(lola2) + (0mm,-5mm)$)
%      -| ($(lola1) + (-9mm,0mm)$)
%      ;
%
%    \draw[color=gray,line width=1pt,dashed=dash]
%      ($(parse) + (-9mm,0mm)$)
%      |- ($(parse) + (0mm,5mm)$)
%      -| ($(cover) + (12mm,0mm)$)
%      |- ($(abstr) + (30mm,7mm)$)
%      |- ($(abstr) + (0mm,-12mm)$)
%      -| ($(parse) + (-9mm,0mm)$)
%      ;
%    \node at ($(parse) + (2.3cm,-2.2cm)$) {\textcolor{gray}{\toolname}};
%
%    \node (lolain) at ($(cover) + (-1.5cm,-1cm)$) {};
%    \node (lolaout) at ($(cover) + (1.5cm,-1cm)$) {};
%
%    \draw[->] (cover) .. controls (lolain) .. (lola1);
%    \draw[->] (cover) .. controls (lolain) .. (lola2);
%    \draw[->] (cover) .. controls (lolain) .. (lola3);
%
%    \draw[->] (lola1) .. controls (lolaout) .. (cover);
%    \draw[->] (lola2) .. controls (lolaout) .. (cover);
%    \draw[->] (lola3) .. controls (lolaout) .. (cover);
%
%    \node[fill=white,fill opacity=0.9,text opacity=1] at (lolain){queries};
%    \node[fill=white,fill opacity=0.9,text opacity=1,text width=1cm] at (lolaout){answers (Yes/No)};
%  \end{tikzpicture}
%\end{figure}
%
%
%\begin{paragraph}{Ease of use.}
%  To help diagnose mistakes during specification,
%  emphasis has been placed on the error messages of \toolname,
%  and it has an extensive test suite to make sure that malformed grammars are caught
%  early.
%
%  To make specifications expressive, \toolname{} checks not just safety properties,
%  it also has sanity checks (we can specify markings that if they are not coverable
%  then there must be a bug in the specification of the grammar)
%  and known failures of safety (if the abstraction incurs a known false positive,
%  we can mark it as such in the specification).
%\end{paragraph}
%
%\begin{paragraph}{Coverability Query vs. Upwards Closed Formulae.}
%  We have described a coverability query as the specification of a single marking $\mtarget$,
%  and asking the question ``is there a reachable $\amark$ such that $\amark \geq \mtarget$ ?''
%  This is fine for simple queries, such as
%  ``can there simultaneously be one process in state $q_1$ and one in state $q_2$?'',
%  easily expressed by $\mtarget = \{q_1 \mapsto 1; q_2\mapsto 1\}$.
%  However it quickly becomes a challenge to express more complex properties,
%  such as ``can there be simultaneously one process in state $q_1$ and one process
%  in either state $q_2$, or $q_3$ or $q_4$?'',
%  which now requires three target markings
%  ($\{q_1\mapsto 1; q_2 \mapsto 1\}$ or $\{q_1\mapsto 1; q_2\mapsto 3\}$ or $\{q_1\mapsto 1; q_4\mapsto 1\}$).
%  Even worse,
%  ``can the total number of processes in states $q_1$, $q_2$ or $q_3$ exceed 5?'',
%  has to be translated to ${7\choose 2}$ different target markings
%  ($\{q_1\mapsto 5; q_2\mapsto 0; q_3\mapsto 0\}$
%  or $\{q_1\mapsto 4; q_2 \mapsto 1; q_3\mapsto 0\}$
%  or $\{q_1\mapsto 3; q_2\mapsto 1; q_3\mapsto 1\}$
%  or...),
%  \ie 21 different coverability queries.
%
%  Instead our approach is to use \emph{upwards closed formulae} for safety specifications.
%  These are conjunctions and disjunctions (no negation) of formulae of the form
%  $\sum_{i \in I} \amark(p_i) \geq k$ where $k$ is some constant.
%  The three properties stated in the previous paragraph would be expressed respectively
%  as $\phi_1(\amark) = (\amark(q_1) \geq 1 \wedge \amark(q_2) \geq 1)$,
%  $\phi_2(\amark) = (\amark(q_1) \geq 1 \wedge (\amark(q_2) \geq 1 \vee \amark(q_3) \geq 1 \vee \amark(q_4) \geq 1))$,
%  and finally $\phi_3(\amark) = (\amark(q_1) + \amark(q_2) + \amark(q_3) \geq 5)$.
%  This provides a way of specifying safety properties that clearly has the same
%  expressivity ---a single target marking $\mtarget$ specifies exactly the constraint
%  $\phi_{\mtarget}(\amark) = (\bigwedge_{q\in Q} \amark(q) \geq \mtarget(q))$---
%  and is in some cases exponentially more compact.
%  Moreover LoLA expects a formula as input, and does not support batch mode
%  (one LoLA invocation can analyze only one formula on one net),
%  thus having a specification format that is cheap to translate and requires few
%  invocations is very beneficial.
%\end{paragraph}

% \subsection{Chosen Problems}

%% Not all problems have specifications that can be expressed as coverability properties,
%% but we have selected some to implement that center around uniqueness and mutual exclusion.
%% We have also tried to select them from a variety of architectures, featuring
%% at least stars, rings, and binary trees the three main basic shapes generated by \hrtext{}.

The \texttt{ring} example is a standard token ring, on which we verify
that the process holding the token is unique.  The \texttt{philos}
example, is the dining philosophers problem on a ring, for which we
prove mutual exclusion properties between neighbors.  The
\texttt{consensus} example features processes arranged as a star performing a
2-valued consensus. The \texttt{leader-election} example is a
finite-valued model of a leader election having a pre-determined
winner.

%% processes are arranged in a star around a write-once register
%% (which famously has infinite consensus number) and they perform a 2-valued
%% consensus.
%% The final standard example is \texttt{leader-election}, in which we describe an
%% approximation of a leader election algorithm on a loop, with a predetermined winner
%% so that it can be described with finitely many states.

In addition to these standard examples, we considered several mutual
exclusion protocols on stars (\texttt{lock}, \texttt{star}), binary
trees (\texttt{tree-dfs}, \texttt{tree-down}, \texttt{tree-halves}),
and more complex architectures, \eg \texttt{star-ring} is a star whose
points are chained, \texttt{server-loop} is a ring whith a star on
each node and \texttt{tree-nav} is a tree with chained leaves. It is
worth mentioning that \texttt{ring}, \texttt{star},
\texttt{tree-down}, \texttt{tree-nav} happen to be pebble-passing
systems (\secref{sec:pebble-passing}).

% \subsection{Results, Runtime, and Interpretation}

\input{bench-table.tex}

For most of these examples, we were able to automatically prove
several safety properties (\figref{fig:benchmarks}).  For instance, in
\texttt{lock}, we successfully verify the safety property that
$\mathit{proc}*p.(\mathit{on}) > 0 \wedge \mathit{proc}.(\mathit{on})
> 0$ is unreachable (\ie an instance of $\mathit{proc}$ may not have a token in
$\mathit{on}$ at the same time as any other instance of
$\mathit{proc}$), but we are unable to verify that
$\mathit{proc}.(\mathit{on}) > 1$ or $\mathit{proc}*p.(\mathit{on}) +
\mathit{proc}.(\mathit{on}) > 1$ are unreachable. Thus \texttt{lock}
is marked $1/3$, denoting 1 of 3 successful safety tests. In most
cases, we proved the stated properties (those where we failed require
future work to refine the abstraction).

The times were obtained on a Intel Ultra 7 laptop, with 16GiB RAM,
under Ubuntu 24.04. All benchmark specifications are provided as
additional material.

%% in \figref{fig:benchmarks} include
%% were measured using the command \texttt{hyperfine}, producing an
%% average over at least 30 runs for the end-to-end runtime including
%% parsing the input and logging the result. We used an Intel Ultra 7
%% laptop, with 16GiB RAM, under Ubuntu 24.04.  Over the execution of
%% the benchmarks, peak RAM usage (as measured by \texttt{/usr/bin/time
%%   -v}) did not exceed 60MiB.  

%Note that in \texttt{coverapprox}, \texttt{lock}, \texttt{simplify-me} and
%\texttt{propagation}, each have not all of their properties shown as proven because
%one property could not be verified without turning on a flag that applies some
%simplification heuristic. Thus in those cases, the outcome $1/2$ actually means
%1 property successfully proven, but requires the use of an additional flag.

%For \texttt{lock}, \texttt{open} and \texttt{server-loop},
%we were unable to prove at least one property, even with the aforementioned flag.
%Being able to do so is the subject of future work and work in progress on the tool.

