\section{Preliminaries}

We denote by $\nat$ the set of positive integers, including zero. For
$i, j \in \nat$, we denote by $\interv{i}{j}$ the set
$\set{i,\ldots,j}$, considered empty if $i > j$. The cardinality of a
finite set $A$ is denoted $\cardof{A}$. A singleton $\set{a}$ will be
denoted $a$. By $A \finsubseteq B$, we mean that $A$ is a finite
subset of $B$. The union of two disjoint sets $A$ and $B$ is denoted
as $A \uplus B$. The Cartesian product of two sets $A$ and $B$ is
denoted $A \times B$. As usual, we denote by $A^*$ the set of
(possibly empty) sequences of elements from $A$.

For a function $f : A \rightarrow B$ and $C \subseteq A$, we write
$f(C)\isdef \set{f(c) \mid c \in C}$ and $\proj{f}{C} \isdef
\set{(c,f(c)) \mid c \in C}$. The inverse of a function $f : A
\rightarrow B$ is the relation $f^{-1}\isdef\{(f(a),a) \mid a \in
A\}$. To alleviate notation, we write $f(x,y)$ instead of $f((x,y))$,
when no confusion arises. For two functions $f : A \rightarrow B$ and
$g : C \rightarrow D$, the function $f \times g : A \times B
\rightarrow C \times D$ maps each pair $(a,c) \in A \times C$ into the
pair $(f(a),g(c))\in B \times D$. A bijective function $f : A
\rightarrow A$ is a \emph{finite permutation} if the set $\set{a \in A
  \mid f(a)\neq a}$ is finite.  In particular, $a \leftrightarrow b$
denotes the finite permutation that switches $a$ with $b$ and leaves
the other elements of the domain unchanged. A finite partial function
is denoted as $f : A \finmap B$ and $\dom{f}$, $\img{f}$ denote its
domain and range, respectively.  When $f : A \to C$ and $g : B \to C$
coincide on their shared domain $A \cap B$, we write $f \cup g : A
\cup B \to C$ the function such that $\proj{(f \cup g)}{A} = f$ and
$\proj{(f \cup g)}{B} = g$.
\ifLongVersion\else
The proofs of the technical results from the paper are given in
\appref{app:proofs}.
\fi

\subsection{Petri Nets}

A \emph{net} is a tuple $\anet = (\places,\trans,\weight)$, where
$\places$ is a finite set of \emph{places}, $\trans$ is a finite set
of \emph{transitions} such that $\places\cap\trans=\emptyset$ and
$\weight : (\places \times \trans) \cup (\trans \times \places)
\rightarrow \nat$ is a \emph{weighted incidence relation} between
places and transitions. We denote by $\placeof{\anet}$,
$\transof{\anet}$ and $\weightof{\anet}$ the places, transitions and
incidence relation of $\anet$, respectively. For all
$x,y\in\places\cup\trans$ such that $\weight(x,y) > 0$, we say that
there is an \emph{edge of weight} $\weight(x,y)$ between $x$ and
$y$. For an element $x\in\places\cup\trans$, we define the set of
\emph{predecessors} $\pre{x} \isdef \set{y \in \places \cup \trans
  \mid \weight(y,x)>0}$, \emph{successors} $\post{x} \isdef \set{y \in
  \places \cup \trans \mid \weight(x,y)>0}$ and predecessor-successor
pair $\prepost{x} \isdef (\pre{x},\post{x})$.

A \emph{marking} of $\anet = (\places,\trans,\weight)$ is a function
$\amark : \places \rightarrow \nat$. A transition $t$ is
\emph{enabled} in the marking $\amark$ if $\amark(q) \geq
\weight(q,t)$, for each place $q \in \places$. For all markings
$\amark$, $\amark'$ and transitions $t \in \trans$, we write $\amark
\fire{t} \amark'$ whenever $t$ is enabled in $\amark$ and $\amark'(q)
= \amark(q) - \weight(q,t) + \weight(t,q)$, for all $q \in
\places$. Given two markings $\amark$ and $\amark'$, a finite sequence
of transitions $\vec{t} = (t_1, \ldots,t_n)$ is a \emph{firing
  sequence}, written $\amark \fire{\vec{t}} \amark'$, if and only if
either \begin{inparaenum}[(i)]
\item $n=0$ and $\amark=\amark'$, or
%
\item $n\geq1$ and there exist markings $\amark_1, \ldots,
  \amark_{n-1}$ such that $\amark \fire{t_1} \amark_1 \fire{t_2} \ldots
  \fire{t_{n-1}} \amark_{n-1} \fire{t_n} \amark'$.
\end{inparaenum}
A sequence $\vec{t}$ is \emph{fireable} from $\amark$ whenever there
exists a marking $\amark'$ such that $\amark \fire{\vec{t}} \amark'$.

A \emph{Petri net} (PN) is a pair $\amarkednet=(\anet,\amark_0)$,
where $\anet$ is a net and $\amark_0$ is the \emph{initial marking} of
$\anet$. For simplicity, we write $\placeof{\amarkednet} \isdef
\placeof{\anet}$, $\transof{\amarkednet} \isdef \transof{\anet}$,
$\weightof{\amarkednet} \isdef \weightof{\anet}$ and
$\initmarkof{\amarkednet}\isdef\amark_0$ for the elements of
$\amarkednet$. A marking $\amark$ is \emph{reachable} in $\amarkednet$
iff there exists a firing sequence $\vec{t}$ such that $\amark_0
\fire{\vec{t}} \amark$. We denote by $\reach{\amarkednet}$ the set of
reachable markings of $\amarkednet$. The \emph{reachability problem}
asks, given a PN $\amarkednet$ and a marking $\amark$, does
$\amark\in\reach{\amarkednet}$ ? The \emph{coverability problem} asks,
for a given PN $\amarkednet$ and marking $\amark$, does there exists a
marking $\amark' \in \reach{\amarkednet}$ such that $\amark \leq
\amark'$? Here the order of markings is the pointwise order on $\nat$,
\ie $\amark \leq \amark'$ iff $\amark(q) \leq \amark'(q)$ for all $q
\in \placeof{\amarkednet}$. The coverability problem is more concisely
stated using the set of covered markings $\cover{\amarkednet} \isdef
\{\amark \mid \exists \amark'\in\reach{\amarkednet} ~.~ \amark \leq
\amark'\}$, \ie given $\amarkednet$ and $\amark$, does
$\amark\in\cover{\amarkednet}$?

%% A PN $\amarkednet$ is \emph{$1$-safe} if $\amark(q) \leq 1$, for each
%% $\amark \in \reach{\amarkednet}$ and $q \in \placeof{\amarkednet}$. We
%% assume w.l.o.g. that the weights on the edges of a $1$-safe PN are
%% either $0$ or $1$, since any transition $t$ having $\weight(q,t)>1$
%% for some place $q$ is disabled in each of its reachable markings.

%% A net is \emph{communication-free} \cite{Esparza95} if
%% $\cardof{\pre{t}} =1$, for every transition $t \in \trans$ and
%% $\weight(s,t) \leq 1$ for every $s \in \places$ and $t \in \trans$.  A
%% PN $\amarkednet=(\anet,\amark_0)$ is communication-free if the
%% underlying net $\anet$ is communication-free.

\subsection{Parameterized Systems}

We begin by defining parameterized communicating systems, \ie graphs
whose vertices model network nodes that run identical copies of one or
more process types.  Neighbouring processes synchronize their
transitions according to the observable edge labels of the network
graph. In most of the literature (see, \eg \cite{BloemBook} for a
survey) process types are represented by finite labeled transition
systems (LTS), \eg with disjoint observable and internal alphabets of
transition labels. For simplicity, here we use PNs whose transitions
mimick closely the transitions of a LTS, thus avoiding the formal
definition of the latter.

Let $\valpha$ and $\ealpha$ be finite disjoint alphabets of vertex and
edge labels, respectively. A (binary labeled) \emph{graph} is a tuple
$\graph=(\verts,\edges,\vlab)$, where $\verts$ is a finite set of
vertices, $\edges \subseteq \verts\times\ealpha\times\verts$ is a set
of labeled binary edges and $\vlab : \verts \rightarrow \valpha$ maps
each vertex to a vertex label. Edges $(v_1,a,v_2)$ are written $v_1
\arrow{a}{} v_2$. We denote by $\vertof{\graph}$, $\edgeof{\graph}$
and $\vlabof{\graph}$ the vertices, edges and vertex labeling of
$\graph$, respectively. We do not distinguish isomorphic graphs,
\ie graphs that differ only in the identities of their vertices.

\begin{definition}\label{def:process-type}
  A \emph{process type} $\ptype$ is a PN having all weights at most
  $1$ and exactly one marked place initially, whose transitions are
  partitioned into \emph{observable} $\obstransof{\ptype}$ and
  \emph{internal} $\inttransof{\ptype}$, \ie
  $\transof{\ptype}=\obstransof{\ptype} \uplus \inttransof{\ptype}$,
  and each transition has exactly one predecessor and one
  successor. Let $\ptypes = \set{\ptype_1, \ldots, \ptype_k}$ be a
  finite fixed set of process types such that $\placeof{\ptype_i} \neq
  \emptyset$, for all $i \in \interv{1}{k}$ and $\placeof{\ptype_i}
  \cap \placeof{\ptype_j} = \emptyset$, for all $1 \leq i < j \leq k$.
\end{definition}
Because a process type has exactly one initial token and all
transitions have one predecessor and one successor, every reachable
marking of a process type has exactly one initial token. A PN having
this property is said to be \emph{automata-like}. We denote by
$\placeof{\ptypes}$ and $\obstransof{\ptypes}$ the sets of places and
observable transitions from some $\ptype\in\ptypes$, respectively.

\input{figure-proctype}

\begin{example}
  \figref{fig:proc-typ1} (a) shows two process types $\mathit{Cont}$
  and $\mathit{Proc}$. They both represent entities that can hold a
  token and they can either grab a token, if they do not have it, or
  release the token, otherwise. The first one, which we identify as a
  controller, has only observable transitions, whereas the second one,
  which represents a worker process, has two internal trasitions
  $\mathit{start}$ and $\mathit{stop}$ depicted in yellow. These
  transitions are used to simulate the fact that when the worker has
  the token, it can move to a working state, from which he cannot
  release the token and when it stops working, it can move back to a
  state from which the token can be released.
\end{example}

\begin{definition}\label{def:system}
  A \emph{system} $\asys=(\verts,\edges,\vlab)$ is a graph whose
  vertices are labeled with process types from $\ptypes$
  ($\valpha=\ptypes$) and edges with pairs of observable transitions
  from $\obstransof{\ptypes}$ (\ie
  $\ealpha=\obstransof{\ptypes}\times\obstransof{\ptypes}$), such that
  $t_i \in \obstransof{\vlab(v_i)}$, for both $i=1,2$, for each edge
  $v_1\arrow{(t_1,t_2)}{} v_2 \in \edgeof{\asys}$.
\end{definition}

% \input{figure-system}

\begin{example}
  \figref{fig:proc-typ1} (b) shows two systems labeled with the process
  types given by \figref{fig:proc-typ1} (a). They both represent a
  network with four entities, one controller of type $\mathit{Cont}$
  and three working processes of type $\mathit{Proc}$. In $\asys_1$,
  the controller can pass a token to the first working process, which
  can pass the token to the second one which can pass the token to the
  third one. In $\asys_2$, the controller is at the center and it
  communicate with all the working processes that get and release the
  token.
\end{example}

% \input{figure-behav1}
% \input{figure-behav2}

The communication (\ie synchronization between processes) in a
system is formally captured by the following notion of behavior:

\begin{definition}\label{def:behavior}
  A \emph{behavior} is a PN $\amarkednet$ such that $1 \leq
  \cardof{\pre{t}}=\cardof{\post{t}} \leq 2$, for each
  $t\in\transof{\amarkednet}$. The \emph{behavior of a system}
   $\asys=(\verts,\edges,\vlab)$ is $\behof{\asys} \isdef
   (\anet,\amark_0)$, where: \begin{itemize}
     %
   \item $\placeof{\anet} \isdef \set{(q,v) \mid q \in
     \placeof{\vlab(v)},~ v \in \verts}$, a place $(q,v)$ corresponds
     to the place $q$ of the process type $\vlab(v)$ that labels the
     vertex $v$;
     %
   \item $\transof{\anet} \isdef \edges \cup \set{(t,v) \mid t \in
     \inttransof{\vlab(v)},~ v \in \verts}$, the transitions are
     either edges of the system (\ie modeling the synchronizations
     of two processes) or pairs $(t,v)$ corresponding to an internal
     transition $t$ of the process type $\vlab(v)$ that labels the
     vertex $v$;
     %
   \item the weight function $\weightof{\anet}$ is defined below:
     \begin{align*}
       \weightof{\anet}((q,v),v_1 \arrow{(t_1,t_2)}{} v_2) \isdef & \left\{\begin{array}{ll}
       \weightof{\vlab(v)}(q,t_i) \text{, if } v=v_i, \text{, for } i=1,2 \\
       0 \text{, otherwise}
       \end{array}\right.  \\
       \weightof{\anet}(v_1 \arrow{(t_1,t_2)}{} v_2,(q,v)) \isdef & \left\{\begin{array}{ll}
       \weightof{\vlab(v)}(t_i,q) \text{, if } v=v_i \text{, for } i=1,2  \\
       0 \text{, otherwise}
       \end{array}\right.
     \end{align*}
     
     \vspace*{-.5\baselineskip}
     \begin{align*}
       \hspace*{-8mm}
       \weightof{\anet}((q,v),(t,v')) \isdef \left\{\begin{array}{ll}
       \weightof{\vlab(v)}(q,t) \text{, if } v=v' \\
       0 \text{, otherwise}
       \end{array}\right.
       \hspace*{4mm}
       \weightof{\anet}((t,v'),(q,v)) \isdef \left\{\begin{array}{ll}
       \weightof{\vlab(v)}(t,q) \text{, if } v=v' \\
       0 \text{, otherwise}
       \end{array}\right. 
     \end{align*}
     %
   \item $\amark_0(q,v)\isdef\initmarkof{\vlab(v)}(q)$, for all $v \in \verts$ and $q \in \placeof{\vlab(v)}$. 
     %
   \end{itemize}
\end{definition}
It is easy to check that $\behof{\asys}$ is a behavior, for any system
$\asys$. For example, \figref{fig:proc-typ1} (c) and (d) show the
behaviors of the two systems from \figref{fig:proc-typ1} (b).  By
construction, among places $\set{(q, v) \mid q\in\placeof{\vlab(v)}}$
for any $v$, there is exactly one token in all reachable markings
because $\vlab(v)$ is automata-like. By extension we say that such
behaviors are automata-like.

A \emph{parameterized system} $\parsys = \set{\asys_1,\asys_2,
  \ldots}$ is a possibly infinite set of systems, called
\emph{instances}. A parameterized system has an infinite set of
behaviors, denoted as $\behof{\parsys}$, \ie one for each
instance. \ifLongVersion
In the rest of this paper we are concerned with the following
parameterized verification problems:
\begin{definition}\label{def:parameterized-verif} 
  The \emph{parameterized reachability (\resp coverability) problem}
  takes in input a parameterized system $\parsys$, a set of places $\mathcal{Q}
  \subseteq \placeof{\ptypes}$ and a mapping 
  $\amark : \mathcal{Q} \rightarrow \nat$ and asks for the
  existence of an instance $\asys\in\parsys$ and of a marking
  $\overline{\amark} \in \reach{\behof{\asys}}$ (\resp
  $\overline{\amark} \in \cover{\behof{\asys}}$) where
  \(\sum_{\set{v \in \vertof{\asys} \mid q \in \placeof{\vlabof{\asys}(v)}}}
  \overline{\amark}(q,v)=\amark(q) \text{, for all } q \in
  \mathcal{Q}.\)
\end{definition}
For Petri nets, the reachability problem specified by the number of
token within a set of places is known as the \emph{submarking
reachability} \cite{DecidabilityPetriNets}. For example, a typical
correctness property that can be stated as a parameterized
coverability problem is mutual exclusion: a parameterized system
violates mutual exclusion if there is an instance that reaches a
marking in which two or more processes of the same type are in the
same given local place.
\begin{example}
  For the two systems depicted on \figref{fig:proc-typ1}, no two
  processes (\ie running on different nodes) work at the same time
  if and only if the parameterized coverability problem for
  $\places=\set{\mathit{work}}$ and $\amark = \set{(\mathit{work},2)}$
  has a negative answer, \ie some marking that agrees with $\amark$
  over $\mathit{work}$ cannot be covered by any marking reachable in
  the behavior of some instance.
\end{example}
\else The verification problems considered in this paper are, given a
parameterized system $\parsys$ and a marking $\amark$ for a subset
$\mathcal{Q}$ of the places in $\ptypes$, does there exist an instance
of $\parsys$ whose behavior reaches (covers) a marking that agrees
with $\amark$ over $\mathcal{Q}$? We shall define these problems
formally, once we have introduced the language for the specification
of parameterized systems. \fi

\subsection{Algebras}
\label{subsec:algebras}

We recall a few notions on algebras needed in the following. A
\emph{signature} is a set of function symbols $\signature=\set{\aop_1,
  \aop_2, \ldots}$.  An \emph{$\signature$-term} is a term built with
function symbols from $\signature$ and variables of arity zero.  An
$\signature$-term is \emph{ground} if it has no variables.  An
\emph{$\signature$-algebra} $\algof{A} =
(\universeOf{A},\aop^\algof{A}_1,\aop^\algof{A}_2,\ldots)$ interprets
the function symbols from $\signature$ as functions over the
\emph{domain} $\universeOf{A}$.  Given $\signature$-algebras
$\algof{A}$ and $\algof{B}$ having domains $\universeOf{A}$ and
$\universeOf{B}$, respectively, a \emph{homomorphism} is a function $h
: \universeOf{A} \rightarrow \universeOf{B}$ such that
$h(\aop^\algof{A}(a_1, \ldots, a_n)) = \aop^{\algof{B}}(h(a_1),
\ldots, h(a_n))$, for each function symbol $\aop\in\signature$ of
arity $n$ and $a_1, \ldots, a_n \in \universeOf{A}$. The \emph{kernel}
of a function $f : \universeOf{A} \rightarrow \universeOf{B}$ is the
equivalence relation $\kerof{f} \subseteq \universeOf{A} \times
\universeOf{A}$ defined as $a_1 \kerof{f} a_2 \iff f(a_1)=f(a_2)$. An
equivalence relation $\sim \subseteq \universeOf{A} \times
\universeOf{A}$ is an $\signature$-\emph{congruence} if and only if,
for each function symbol $\aop\in\signature$ of arity $n$ and $a_1,
a'_1, \ldots, a_n, a'_n \in \universeOf{A}$ such that $a_i\sim a'_i$,
for all $i \in \interv{1}{n}$, we have $\aop^\algof{A}(a_1,\ldots,a_n)
\sim \aop^\algof{A}(a'_1,\ldots,a'_n)$.

\begin{propositionE}[][category=proofs]\label{prop:cong-homo}
  Let $\algof{A}$ be an $\signature$-algebra having domain
  $\universeOf{A}$, and $f : \universeOf{A} \rightarrow
  \universeOf{B}$ be a function such that $\kerof{f}$ is an
  $\signature$-congruence. Then $f$ is a homomorphism between
  $\algof{A}$ and $\algof{B} \isdef
  (f(\universeOf{A}),\set{\aop^\algof{B}}_{\aop\in\signature})$, where
  $\aop^\algof{B}(b_1,\ldots,b_n)\isdef f(\aop^\algof{A}(f^{-1}(b_1),
  \ldots, f^{-1}(b_n)))$\footnote{The right-hand side of this
    definition is a singleton that we identify with its element.}, for
  each function symbol $\aop\in\signature$ of arity $n$ and all
  $b_1,\ldots,b_n\in f(\universeOf{A})$. Consequently,
  $f(\theta^\algof{A})=\theta^\algof{B}$, for each ground
  $\signature$-term $\theta$.
\end{propositionE}
\begin{proofE}
  First, we prove that $\aop^\algof{B}(b_1,\ldots,b_n)$ is
  well-defined and evaluates to a singleton, for each $\aop \in
  \signature$ and $b_1,\ldots,b_n \in f(\universeOf{A})$. Let $a_i \in
  f^{-1}(b_i)$ be elements, for all $i\in\interv{1}{n}$. The element
  $a_i$ exists, by the choice of $b_i \in f(\universeOf{A})$, for all
  $i \in \interv{1}{n}$. Then $f^{-1}(b_i)$ is the
  $\kerof{f}$-equivalence class of $a_i$, for all
  $i\in\interv{1}{n}$. Because $\kerof{f}$ is an
  $\signature$-congruence, $\aop^\algof{A}(f^{-1}(b_1), \ldots,
  f^{-1}(b_n))$ is the $\kerof{f}$-equivalence class of
  $\aop^\algof{A}(a_1,\ldots,a_n)$, hence
  $f(\aop^\algof{A}(f^{-1}(b_1), \ldots,
  f^{-1}(b_n)))=\set{f(\aop^\algof{A}(a_1), \ldots,
    \aop^\algof{A}(a_n))}$ is a singleton. Second, to prove that $f$
  is an homomorphism between $\algof{A}$ and $\algof{B}$, we compute,
  for each $\aop\in\signature$ and all
  $a_1,\ldots,a_n\in\universeOf{A}$:
  \begin{align*}
    \aop^\algof{B}(f(a_1), \ldots, f(a_n)) = & f(\aop^\algof{A}(f^{-1}(f(a_1)), \ldots, f^{-1}(f(a_n))))
    \text{, by the definition of } \aop^\algof{B} \\
    = & f(\aop^\algof{A}(a_1, \ldots, a_n)) \text{, because } \kerof{f} \text{ is an $\signature$-congruence}
  \end{align*}
  Finally, $f(\theta^\algof{A})=\theta^\algof{B}$ holds for each
  ground $\signature$-term $\theta$, because $f$ is a homomorphism
  between $\algof{A}$ and $\algof{B}$. \qed
\end{proofE}
\begin{proofSketch}
  The fact that $f(\aop^\algof{A}(f^{-1}(a_1),\ldots,f^{-1}(a_n)))$ evaluates to a singleton
  comes from the fact that $\kerof{f}$ is an $\signature$-congruence quite directly.
  In $f(\theta^\algof{A})$, use the now established definition of $\aop^\algof{B}$
  to push $f$ to the leaves.
  \qed
\end{proofSketch}

We introduce a standard signature of operations on graphs and define
two algebras, of open systems and behaviors. Let $\sourcelabels$ be a
countably infinite set of \emph{source labels}, fixed in the rest of
the paper. With no loss of generality, we assume that $\sourcelabels$
is partitioned into disjoint sets indexed by the process types
$\ptypes = \set{\ptype_1, \ldots, \ptype_k}$,
\ie $\sourcelabels = \sourcelabels_{\ptype_1} \uplus \ldots \uplus \sourcelabels_{\ptype_k}$.
A source label $\asrc\in\sourcelabels$
uniquely identifies a process type $\ptypeof{\asrc}\in\ptypes$ such
that $\asrc \in \sourcelabels_{\ptypeof{\asrc}}$.
A function $\alpha : \sourcelabels \rightarrow \sourcelabels$ is
\emph{$\ptypes$-preserving} if
$\ptypeof{\alpha(\asrc)}=\ptypeof{\asrc}$,
for all $\asrc\in\sourcelabels$.

The signature of the \emph{hyperedge-replacement} graph algebra
(\hrtext)~\cite{courcelle_engelfriet_2012} consists of the constants
$\sgraph{a}{\asrc_1}{\asrc_2}{}$, for all edge labels $a\in\ealpha$
and source labels $\asrc_1, \asrc_2 \in \sourcelabels$, the unary
symbols $\restrict{\slabs}{}$, for all $\slabs \finsubseteq
\sourcelabels$, $\rename{\alpha}{}$, for all $\ptypes$-preserving
finite permutations $\alpha: \sourcelabels \rightarrow \sourcelabels$
and the binary symbol $\pop{}$. By \hrtext{} congruence we mean an
equivalence relation that is a congruence for the \hrtext{} signature.

An \emph{open system} is a pair $\open{\asys} \isdef
(\asys,\sources)$, where $\asys=(\verts,\edges,\vlab)$ is a system and
$\sources : \sourcelabels \finmap \vertof{\asys}$ is an injective
partial function that assigns source labels to vertices of $\asys$
such that $\ptypeof{\asrc}=\vlab(\sources(\asrc))$, for each
$\asrc\in\dom{\sources}$, \ie the source label of a vertex has the
process type of that vertex. We say that a vertex $v\in\vertof{\asys}$
is the $\asrc$-source of $\open{\asys}$ if $\sources(\asrc)=v$. The
\emph{type} of $\open{\asys}$ is
$\typeof{\open{\asys}}\isdef\dom{\sources}$, \ie the set of source
labels that occurs in $\asys$. Since systems (\defref{def:system}) are
in fact open systems of empty type, we blur the distinction and refer
to open systems as systems from now on.

The algebra $\algof{S}$ of systems (\figref{fig:alg-zoo}) interprets
the \hrtext{} signature over the set $\systems$ of systems, as
follows: \begin{compactitem}[-]
  %
\item $\sgraph{a}{\asrc_1}{\asrc_2}{\algof{S}}$ is the system having a
  single $a$-labeled edge between its two vertices labeled with
  process types $\ptypeof{\asrc_1}$ and $\ptypeof{\asrc_2}$, that are
  the $\asrc_1$- and $\asrc_2$-sources, respectively, for each edge
  label $a\in\ealpha$ and source labels $\asrc_1,\asrc_2\in\sourcelabels$.
  %
\item $\restrict{\slabs}{\algof{S}}(\asys,\sources) \isdef
  (\asys,\proj{\sources}{\slabs})$ removes the source labels that are
  not in $\slabs \finsubseteq \sourcelabels$,
  %
\item
  $\rename{\alpha}{\algof{S}}(\asys,\sources) \isdef
  (\asys,\sources\circ\alpha^{-1})$ relabels the sources according to
  $\alpha$; note that $\sources\circ\alpha^{-1}$ is an injective
  partial mapping, since $\alpha$ is a finite permutation of
  $\sourcelabels$,
  %
\item $(\asys_1,\sources_1) \pop{\algof{S}} (\asys_2,\sources_2)$ is
  the disjoint union of $(\asys_1,\sources_1)$ and
  $(\asys_2,\sources_2)$, followed by: \begin{compactitem}[*]
    %
  \item fusion of each pair of common $\asrc$-sources $v_i \in
    \vertof{\asys_i}$, for $\asrc\in\typeof{\asys_1} \cap
    \typeof{\asys_2}$ and $i=1,2$, into a $\asrc$-source labeled with
    $\ptypeof{\asrc}$,
    %
  \item fusion of all the edges with the same label and endpoints into
    a single edge with the same label and endpoints.
    %
  \end{compactitem}
  %
\end{compactitem}
Every other \hrtext{} algebra considered in the rest of this paper
will be defined from $\algof{S}$ via an
homomorphism. \figref{fig:alg-zoo} shows the diagram of these algebras
and homomorphisms. Each such homomorphism $h$ (except for $\psi$,
which has a trivial definition) has a reference to a lemma proving
that $\kerof{h}$ is an \hrtext{} congruence.

\begin{figure}[t!]
  \vspace*{-\baselineskip}
  \begin{center}
    \begin{tikzpicture}
      \node[label=150:{\scriptsize systems}] (S) at (0,0) {$\algof{S}$};
      \node[label=90:{\scriptsize behaviors}] (B) at ($(S) + (3,0)$) {$\algof{B}$};
      \node[label=30:{\scriptsize folded behaviors}] (Bfold) at ($(B) + (3,0)$) {$\absof{\algof{B}}$};
      \node[draw=black,shape=circle,inner sep=1pt,label=-30:{\scriptsize folded nets}] (Bfin) at ($(Bfold) + (0,-1.5)$) {$\finabsof{\algof{B}}$};
      \node[draw=black,shape=circle,inner sep=1pt,label=-150:{\scriptsize flows}] (F) at ($(S) + (0,-1.5)$) {$\algof{F}$};

      \draw[->] (S) -- node[above]{$\abeh$} node[below]{\lemref{lemma:cong-sys-beh}} (B);
      \draw[->] (B) -- node[above]{$\afold$} node[below]{\lemref{lemma:cong-beh-fold}} (Bfold);
      \draw[->] (Bfold) -- node[right]{$\psi$} node[left]{\eqnref{eq:drop}} (Bfin);
      \draw[->] (S) -- node[left]{$\eta$} node[right]{\lemref{lemma:cong-sys-flow}} (F);
    \end{tikzpicture}
    \vspace*{-\baselineskip}
    \caption{Homomorphisms between the \hrtext{} algebras used in this
      paper. The circled algebras are the finite and effectively
      computable ones.}
    \label{fig:alg-zoo}
  \end{center}
  \vspace*{-2\baselineskip}
\end{figure}

An \emph{open behavior} is a pair
$\open{\amarkednet}\isdef(\amarkednet,\sources)$, where $\amarkednet$
is a behavior and $\sources : \sourcelabels \times \placeof{\ptypes}
\finmap \placeof{\amarkednet}$ is an injective partial function
assigning pairs $(\asrc,q)$ to places of $\amarkednet$, where $\asrc$
is a source label and $q$ is a place from some process type in
$\ptypes$. A place $r\in\placeof{\amarkednet}$ is a $(\asrc,q)$-source
of $\open{\amarkednet}$ if $\sources(\asrc,q)=r$ and
$\typeof{\open{\amarkednet}} \isdef \dom{\sources}$ denotes the type
of $\open{\amarkednet}$. Since behaviors (\defref{def:behavior}) are
actually open behaviors of empty type, we blur the distinction and
refer to open behaviors as behaviors, when no confusion arises.

To define the algebra of behaviors, we extend the $\abeh$ function
introduced by \defref{def:behavior} to (open) systems, as follows. The
behavior of the system $\open{\asys}=(\asys,\sources)$ is
$\behof{\open{\asys}}\isdef(\behof{\asys},\overline{\sources})$, where
$\behof{\asys}$ is given in \defref{def:behavior} and the source
labeling $\overline{\sources}$ is $\overline{\sources}(\asrc,q) \isdef
(q,\sources(\asrc))$ if $\sources(\asrc)$ is defined and
$(q,\sources(\asrc)) \in \placeof{\amarkednet}$, and undefined
otherwise, for all $\asrc\in\sourcelabels$ and $q \in
\placeof{\ptypes}$.
%% \begin{align}\label{eq:open-behavior}
%%   \hspace*{-2mm}
%%   \overline{\sources}(\asrc,q) \isdef & \left\{\begin{array}{ll}
%%   (q,\sources(\asrc)) & \text{, if } \sources(\asrc) \text{ is defined and } (q,\sources(\asrc)) \in \placeof{\amarkednet} \\
%%   \text{undefined} & \text{, otherwise}
%%   \end{array}\right. \\
%%   & \text{for all } \asrc\in\sourcelabels \text{ and } q \in \placeof{\ptypes} \nonumber
%% \end{align}

\begin{lemmaE}[][category=proofs]\label{lemma:cong-sys-beh}
  $\kerof{\abeh}$ is a \hrtext{} congruence. 
\end{lemmaE}
\begin{proofE}
  We prove a stronger statement, namely that $\abeh$ is
  injective. Then, $\kerof{\abeh}$ becomes the equality, which is
  trivially a congruence for any signature. Let $\open{\asys}_i =
  (\asys_i,\sources_i)$ be open systems and
  $\behof{\open{\asys}_i}=((\anet_i,\amark_{0i}),\overline{\sources}_i)$
  be open behaviors, for $i=1,2$, such that $\anet_1=\anet_2$,
  $\amark_{01}=\amark_{02}$ and
  $\overline{\sources}_1=\overline{\sources}_2$. We show that
  $\asys_1=\asys_2$ below: \begin{itemize}
    %
  \item $\vertof{\asys_1}=\vertof{\asys_2}$: Suppose, for a
    contradiction, that there exists a vertex $v \in \vertof{\asys_1}
    \setminus \vertof{\asys_2}$. Since
    $\placeof{\vlabof{\asys_1}(v)}\neq\emptyset$
    (\defref{def:process-type}), there exists a place
    $q\in\placeof{\vlabof{\asys_1}(v)}$. Since
    $\placeof{\anet_1}=\placeof{\anet_2}$, by 
    \defref{def:behavior}, we obtain $q\in\placeof{\vlabof{\asys_2}}(v)$
    and $v \in \vertof{\asys_2}$, contradiction. Hence
    $\vertof{\asys_1} \subseteq \vertof{\asys_2}$ and the proof in the
    other direction is symmetric.
    %
  \item $\vlabof{\asys_1}=\vlabof{\asys_2}$: Let $v \in
    \vertof{\asys_1}$ ($= \vertof{\asys_2}$, by the previous point)
    and let $q \in \placeof{\vlabof{\asys_1}(v)}$ be a place. Since
    $\placeof{\anet_1}=\placeof{\anet_2}$, by definition
    \defref{def:behavior}, we obtain $q \in
    \placeof{\vlabof{\asys_2}(v)}$, hence
    $\vlabof{\asys_1}(v)=\vlabof{\asys_2}(v)$, by
    \defref{def:process-type}, \ie because the process types are
    assumed to have pairwise disjoint sets of places. Since the choice
    of $v$ was arbitrary, we obtain
    $\vlabof{\asys_1}=\vlabof{\asys_2}$. 
    %
  \item $\edgeof{\asys_1} = \edgeof{\asys_2}$: since
    $\transof{\anet_1}=\transof{\anet_2}$,
    $\vertof{\asys_1}=\vertof{\asys_2}$ and
    $\vlabof{\asys_1}=\vlabof{\asys_2}$, by the previous points, we
    obtain $\edgeof{\asys_1} = \edgeof{\asys_2}$, by
    \defref{def:behavior}. 
    %
  \end{itemize}
  To prove $\sources_1 = \sources_2$, let $\asrc \in \sourcelabels$ be
  a source label and $q \in \placeof{\ptypes}$ be a place from some
  process type, such that $\overline{\sources}_1(\asrc,q)$ is
  defined. Then, $\overline{\sources}_1(\asrc,q) =
  (q,\sources_1(\asrc))$. Since $\overline{\sources}_1 =
  \overline{\sources}_2$, we obtain that
  $\overline{\sources}_2(\asrc,q)$ is defined and
  $\sources_1(\asrc)=\sources_2(\asrc)$. Since the choice of $\asrc$
  was arbitrary, we obtain $\sources_1 = \sources_2$. \qed
\end{proofE}
\begin{proofSketch}
  In fact $\abeh$ is injective making $\kerof{\abeh}$ the equality
  (thus a congruence).
  \qed
\end{proofSketch}

We introduce an algebra $\algof{B}$ of behaviors
(\figref{fig:alg-zoo}), whose domain and interpretation of \hrtext{}
function symbols are defined as in \propref{prop:cong-homo}. Since
$\kerof{\abeh}$ is a \hrtext{} congruence
(\lemref{lemma:cong-sys-beh}), it follows that $\abeh$ is a
homomorphism between $\algof{S}$ and $\algof{B}$. As we discuss next,
a grammar that describes a parameterized system $\parsys=\set{\asys_1,
  \asys_2, \ldots}$ can be reused to describe its set of behaviors
$\behof{\parsys}$.

\subsection{Grammars}

A \emph{grammar} is a pair $\grammar=(\nonterm,\rules)$ consisting of
a finite set $\nonterm$ of \emph{nonterminals} and a finite set
$\rules$ of \emph{rules} of the form, either (1) $X \rightarrow
\rho[X_1,\ldots,X_n]$, where $X,X_1,\ldots,X_n \in \nonterm$ are
nonterminals and $\rho$ is a term whose only variables are
$X_1,\ldots,X_n$, or (2) $\rightarrow X$, where $X \in \nonterm$; the
rules of this form are called \emph{axioms}. Given terms $\theta$ and
$\eta$, a \emph{step} $\theta \step{\grammar} \eta$ obtains $\eta$
from $\theta$ by replacing an occurrence of a nonterminal $X$ with the
term $\rho$, for some rule $X \rightarrow \rho$ of $\grammar$. An
$X$-\emph{derivation} is a sequence of steps starting with a
nonterminal $X$. The derivation is \emph{complete} if it ends in a
ground term. Let $\alangof{X}{\algof{A}}{\grammar} \isdef
\{\theta^\algof{A} \mid X \step{\grammar}^* \theta \text{ is a
  complete derivation}\}$ and $\alangof{}{\algof{A}}{\grammar} \isdef
\bigcup_{\rightarrow X \in \rules} \alangof{X}{\algof{A}}{\grammar}$
be the \emph{language} of $\grammar$ in the algebra $\algof{A}$.

The following result, also known as the \emph{Filtering Theorem},
allows to build a grammar for the intersection between the language of
a grammar and a \emph{recognizable set}, \ie the image of a finite
set via an inverse homomorphism~\cite[Theorem 3.88]{courcelle_engelfriet_2012}:

\begin{theorem}\label{thm:filtering}
  Let $\signature=\set{\aop_1, \aop_2, \ldots}$ be a signature,
  $\algof{A}=(\universeOf{A}, \aop^\algof{A}_1, \aop^\algof{A}_2,
  \ldots)$ and $\algof{B}=(\universeOf{B}, \aop^\algof{B}_1,
  \aop^\algof{B}_2, \ldots)$ be $\signature$-algebras, such that
  $\universeOf{B}$ is finite, and $h$ be a homomorphism between
  $\algof{A}$ and $\algof{B}$. For each $\signature$-grammar
  $\grammar$ and set $C \subseteq \universeOf{B}$, one can build a
  grammar $\grammar_{h,C}$ such that
  $\alangof{}{\algof{A}}{\grammar_{h,C}} =
  \alangof{}{\algof{A}}{\grammar} \cap h^{-1}(C)$.
\end{theorem}
\noindent The construction of the filtered grammar $\grammar_{h,C}$ is
effective: for each rule $X \rightarrow \rho[X_1,\ldots,X_n]$ of
$\grammar$ and each sequence of elements $b, b_1, \ldots, b_n \in
\universeOf{B}$ such that $b = \rho^\algof{B}(b_1,\ldots,b_n)$, the
grammar $\grammar_{h,C}$ has a rule $X^b \rightarrow
\rho[X_1^{b_1},\ldots,X_n^{b_n}]$; the axioms of $\grammar_{h,C}$ are
$\rightarrow X^c$, for each axiom $\rightarrow X$ of $\grammar$ and
each element $c \in C$.

The grammars from the rest of the paper use the \hrtext{} signature to
describe parameterized systems. The following example shows two
grammars that specify parameterized systems with chain-like and
star-like network topologies, as in \figref{fig:proc-typ1} (b):

\begin{example}\label{ex:parameterized-grammars}
  The grammar $\grammar_{Chain}$ below defines systems with chain-like network topologies
  and at least three processes including the controller
  (\figref{fig:proc-typ1} (b) top):

  \vspace*{-.5\baselineskip}
  \begin{center}
  \begin{minipage}{0.6\textwidth}
  \begin{align*}
    & \to C \\
    C &\to \restrict{\set{\sigma_1}}{} ((relC,get)_{(\sigma_3,\sigma_2)} \pop{} (rel,get)_{(\sigma_2,\sigma_1)}) \\
    C &\to \restrict{\set{\sigma_1}}{}
      \rename{\sigma_1 \leftrightarrow \sigma_2}{}
      (C \pop{} (rel,get)_{(\sigma_1,\sigma_2)})
  \end{align*}
  \end{minipage}
  \begin{minipage}{0.3\textwidth}
    \vspace*{1.5\baselineskip}
    \scalebox{0.6}{
      \begin{tikzpicture}[node distance=1.5cm]
      \tikzstyle{every state}=[inner sep=3pt,minimum size=20pt]
      \node(v0)[gnode,draw=black,label=-100:{$Cont$}]{};
      \node(v1)[gnode,draw=black,label=-90:{$Proc$}] at ($(v0) + (2,0)$) {};
      \node(v2)[gnode,draw=black,label=-80:{$Proc$},label=30:{$\sigma_1$}] at ($(v1) + (2,0)$) {};
      \path (v0) edge [->,thick,line width=1pt] node[above]{$(\mathit{relC},\mathit{get})$} (v1);
      \path (v1) edge [->,thick,line width=1pt] node[above]{$(\mathit{relC},\mathit{get})$} (v2);
      \end{tikzpicture}
    } \\
    \scalebox{0.6}{
      \begin{tikzpicture}[node distance=1.5cm]
      \tikzstyle{every state}=[inner sep=3pt,minimum size=20pt]
      \node(v0)[shape=rectangle,draw=black,minimum width=1cm,minimum height=5mm] {C};
      \node(v1)[gnode,draw=black] at ($(v0) + (5mm,0)$) {};
      \node(v2)[gnode,draw=black,label=-80:{$Proc$},label=30:{$\sigma_1$}] at ($(v1) + (2,0)$) {};
      \path (v1) edge [->,thick,line width=1pt] node[above]{$(\mathit{rel},\mathit{get})$}(v2);
      \end{tikzpicture}
    }
  \end{minipage}
  \end{center}
  
  \noindent The right-hand sides of the last two rules correspond to
  the graphs on the right. Similarly, the $\grammar_{Star}$ grammar
  below defines systems with star-shaped network topology
  and at least two processes including the controller
  (\figref{fig:proc-typ1} (b) bottom): 

  % \vspace*{-.5\baselineskip}
  \begin{center}
  \begin{minipage}{0.7\textwidth}
    \begin{align*}
      & \to Z \\
      Z &\to \restrict{\set{\sigma_1}}{}
        ((relC,get)_{(\sigma_1,\sigma_2)}
        \pop{\algof{S}} (getC,rel)_{(\sigma_1,\sigma_2)}) \\
      Z &\to \restrict{\set{\sigma_1}}{}
        (Z \pop{}
        (relC,get)_{(\sigma_1,\sigma_2)}
        \pop{\algof{S}} (getC,rel)_{(\sigma_1,\sigma_2)})
    \end{align*}
  \end{minipage}
  \vspace*{1.5\baselineskip}
  \begin{minipage}{0.2\textwidth}
    \scalebox{0.6}{
      \begin{tikzpicture}[node distance=1.5cm]
      \tikzstyle{every state}=[inner sep=3pt,minimum size=20pt]
      \node(v0)[gnode,draw=black,label=-100:{$Cont$},label=150:{$\sigma_1$}]{};
      \node(v1)[gnode,draw=black,label=-80:{$Proc$}] at ($(v0) + (2,0)$) {};
      \path (v0) edge [->,thick,line width=1pt,bend left=40] node[above]{$(\mathit{relC},\mathit{get})$}(v1);
      \path (v0) edge [->,thick,line width=1pt,bend right=40] node[below]{$(\mathit{getC},\mathit{rel})$}(v1);
      \end{tikzpicture}
    } \\
    \scalebox{0.6}{
      \begin{tikzpicture}[node distance=1.5cm]
      \tikzstyle{every state}=[inner sep=3pt,minimum size=20pt]
      \node(v0)[shape=rectangle,draw=black,minimum width=1cm,minimum height=5mm] {Z};
      \node(v1)[gnode,draw=black,label=0:{$\sigma_1$}] at ($(v0) + (5mm,0)$) {};
      \node(v2)[gnode,draw=black,label=-80:{$Proc$}] at ($(v1) + (2,0)$) {};
      \path (v1) edge [->,thick,line width=1pt,bend left=40] node[above]{$(\mathit{relC},\mathit{get})$}(v2);
      \path (v1) edge [->,thick,line width=1pt,bend right=40] node[below]{$(\mathit{getC},\mathit{rel})$}(v2);
      \end{tikzpicture}
    }
  \end{minipage}
  \end{center}
  \vspace*{-2\baselineskip}
\end{example}

The following argument will be repeated several times: if $\algof{A}$
is some \hrtext{} algebra related to $\algof{S}$ by a homomorphism
$h$, then $h(\alangof{}{\algof{S}}{\grammar}) =
\alangof{}{\algof{A}}{\grammar}$, for each grammar $\grammar$ written
using the \hrtext{} signature. Moreover, if the domain of $\algof{A}$
is finite, the language $\alangof{}{\algof{A}}{\grammar}$ is finite
and effectively computable by a finite Kleene iteration, provided that
the interpretation of each function symbol from the \hrtext{}
signature in $\algof{A}$ is effectively computable.  The finite and
effectively computable algebras in question are circled in
\figref{fig:alg-zoo}.

As a consequence of \lemref{lemma:cong-sys-beh}, a grammar that
specifies a parameterized system defines also its set of behaviors:

\begin{lemmaE}[][category=proofs]\label{prop:sys-beh}
  For each \hrtext{} grammar $\grammar$, we have
  $\behof{\alangof{}{\algof{S}}{\grammar}} =
  \alangof{}{\algof{B}}{\grammar}$.
\end{lemmaE}
\begin{proofE}
  By \lemref{lemma:cong-sys-beh}, $\abeh$ is a homomorphism between
  $\algof{S}$ and $\algof{B}$, hence
  $\behof{\theta^\algof{S}}=\theta^\algof{B}$, for each ground term
  $\theta$. The result follows, by the definition of the language of a
  grammar in a given algebra. \qed
\end{proofE}
\begin{proofSketch}
  Easy application of \lemref{lemma:cong-sys-beh}
  and \propref{prop:cong-homo}.
  \qed
\end{proofSketch}

We consider the problems of reachability and coverability for
parameterized systems specified by grammars and give the formal
definitions of the decision problems:
%% The only difference with \defref{def:parameterized-verif} is that
%% the parameterized system considered as input is the language
%% $\alangof{}{\algof{S}}{\grammar}$ of a grammar $\grammar$, written
%% using the set of source labels partitioned by process types, \ie
%% $\sourcelabels =
%% \biguplus_{\ptype\in\ptypes}\sourcelabels_{\ptype}$ and the edge
%% label alphabet of observable transitions from the process types,
%% \ie $\ealpha=\obstransof{\ptypes}\times\obstransof{\ptypes}$. In
%% particular, the constants occurring in $\grammar$ are of the form
%% $\sgraph{(t_1,t_2)}{\asrc_1}{\asrc_2}{}$, where $t_i \in
%% \obstransof{\ptypeof{\asrc_i}}$, for both $i=1,2$.

\begin{definition}\label{def:grammar-parameterized-verif}
  The $\paramreach{\grammar}{\mathcal{Q}}{\amark}$
  (\resp $\paramcover{\grammar}{\mathcal{Q}}{\amark}$) problem takes
  in input a grammar $\grammar$, a set of places $\mathcal{Q}
  \subseteq \placeof{\ptypes}$, a mapping $\amark : \mathcal{Q}
  \rightarrow\nat$ and asks for the existence of a system
  $\asys\in\alangof{}{\algof{S}}{\grammar}$ and marking
  $\overline{\amark}\in\reach{\behof{\asys}}$
  (\resp $\overline{\amark}\in\cover{\behof{\asys}}$) where 
  \(\sum_{v \in \vertof{\asys}:q \in \placeof{\vlabof{\asys}(v)}}
  \overline{\amark}(q,v)=\amark(q) \text{, for all } q \in
  \mathcal{Q}.\)
\end{definition}
%% Note that $\paramcover{\grammar}{\mathcal{Q}}{\amark}$ can be
%% reduced to $\paramcover{\grammar}{\placeof{\ptypes}}{\amark'}$,
%% where $\amark'$ agrees with $\amark$ over $\mathcal{Q}$ and is zero
%% everywhere else. However, this is not the case for
%% $\paramreach{\grammar}{\mathcal{Q}}{\amark}$.
Unsurprisingly, both problems are undecidable, even for simple
grammars defining parameterized systems with chain-like topologies
(see \exref{ex:parameterized-grammars}), when the structure of the
process types is unrestricted.
%% In particular, $\paramcover{\grammar}{\placeof{\ptypes}}{\amark}$
%% is decidable, because the size (\ie number of processes) of the
%% instances that must be considered is bounded by
%% $\sum_{q\in\placeof{\ptypes}} \amark(q)$.
%% \mycomment{Neven}{Clarify}

\begin{theoremE}[][category=proofs]\label{thm:undecidability}
  The $\paramreach{}{}{}$ and $\paramcover{}{}{}$ problems are
  undecidable.
\end{theoremE}
\begin{proofE}
  \input{proof-undecidability}
\end{proofE}
\begin{proofSketch}
  With 3 process types one can write a grammar whose language consists of
  nets that simulate executions of two-counter Minski machines,
  and the halting problem thus reduces to coverability.
  \qed
\end{proofSketch}
