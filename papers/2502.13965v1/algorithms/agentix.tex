\begin{algorithm}[t]
    \small
    \caption{\text{\name}'s Program-Aware Scheduler}
    \label{algorithm:agentix}
    \begin{algorithmic}[1]

    \Procedure{Update\_Process\_Table}{\textbf{Call} $c$, \textbf{Table} $pt$}
        \State $\text{pd} = \text{pt}[\text{c.pid}]$ \label{alg:line1}
        \State \textcolor{cyan}{// Total service time (PLAS), max critical path (ATLAS)} \label{alg:line2}
        \State $\text{pd}\text{.service} = \max(\text{pd}\text{.service}, \text{c.service} + \text{c.model\_time})$ \label{alg:line3}
        \State \textcolor{cyan}{// Update other metrics...} \label{alg:line4}
        \State \ldots \label{alg:line5}
    \EndProcedure \label{alg:line6}
    \Procedure{Scheduler}{\textbf{Queues} $Q_{1}, \ldots, Q_{K}$, \textbf{Table} $pt$}
      \For{$\text{c} \in C_{arrived}$} \Comment{Arriving LLM calls} \label{alg:line9}
            \State \textcolor{cyan}{// Fetch priority with program ID} \label{alg:line10}
            \State $\text{c.service} = pt[\text{c.pid}]\text{.service}$ \label{alg:line11}
            \State $\text{c.q\_idx} = i, \text{ } s.t. \text{ } Q^{low}_{i} \leq \text{c.service} \leq Q^{hi}_{i}$ \label{alg:line12}
            \State $Q_{\text{c.q\_idx}}\text{.append(c)}$, $\text{c.quanta} = Q_{\text{c.q\_idx}}\text{.quanta}$ \label{alg:line13}
      \EndFor \label{alg:line14}

      \For{$\text{c} \in \{Q_{1}, Q_{2}, ..., Q_{K}\}$} \label{alg:line16}
        \If{$\text{c.finished()}$} \Comment{Finished jobs update table} \label{alg:line17}
            \State \textsc{Update\_Process\_Table}$(\text{c}, \text{ }$pt$)$ \label{alg:line18}
            \State $Q_{\text{c.q\_idx}}\text{.remove(c)}$ \label{alg:line19}
        \EndIf \label{alg:line20}

        \If{$\text{c.quanta} \leq 0$} \Comment{Call demotion} \label{alg:line21}
            \State $Q_{\text{c.q\_idx}}\text{.remove(c)}$, $Q_{\text{c.q\_idx}+1}\text{.append(c)}$ \label{alg:line22}
            \State $\text{c.q\_idx} += 1$, $\text{c.quanta} = Q_{\text{c.q\_idx}}\text{.quanta}$ \label{alg:line23}
        \EndIf \label{alg:line24}

        \State $\text{wait} = pt[\text{c.pid}]\text{.wait} + \text{c.wait}$ \label{alg:line25}
        \State $\text{service} = pt[\text{c.pid}]\text{.service} + \text{c.model\_time}$ \label{alg:line26}
        \If{$\text{wait}/\text{service} \geq \beta$} \Comment{Anti-Starvation} \label{alg:line27}
            \State $Q_{\text{c.q\_idx}}\text{.remove(c)}$, $Q_{1}\text{.append(c)}$ \label{alg:line28}
            \State \textcolor{cyan}{// Reset waiting and model execution times} \label{alg:line29}
            \State $\text{c.wait}=0$, $\text{c.model\_time}=0$ \label{alg:unknown}
            % \State $pt[\text{c.pid}]\text{.service} = 0$, $pt[\text{c.pid}]\text{.wait} = 0$ 
        \EndIf \label{alg:line31}
      \EndFor \label{alg:line32}

      \State $B_{out} = []$ \Comment{Schedule next batch of LLM calls} \label{alg:line33}
      \For{$\text{c} \in \{Q_{1}, Q_{2}, ..., Q_{K}\}$} \label{alg:line34}
        \If{$\text{engine.can\_fit(c)}$} \label{alg:line35}
            \State $B_{out}\text{.append(c)}$ \label{alg:line36}
        \Else \label{alg:line37}
            \State \textbf{break} \label{alg:line38}
        \EndIf \label{alg:line39}
      \EndFor \label{alg:line40}
    \EndProcedure \label{alg:line41}
    \end{algorithmic}
\end{algorithm}
