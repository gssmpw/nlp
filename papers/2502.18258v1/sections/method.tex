\section{Indexing Structures for Advanced Cross-Modal Queries}
\label{sect:Structures}

In this section, we present two novel indexing structures designed to enhance the efficiency of advanced cross-modal queries.
Specifically, a verifiable and gas-efficient BHashTree is utilized for time range queries, whereas a verifiable high-performance trie is employed for fuzzy queries. 
Furthermore, we delve into the analysis of how the shift from a traditional B\(+\)Tree to a BHashTree reduces time complexity.


\subsection{Verifiable Gas-efficient BHashTree}
\label{sect:BHashTree}

In high-intensity insertion scenarios, traditional tree-based indexes face severe scalability bottlenecks in time-series workloads, as the insertion of monotonically increasing timestamp keys causes high contention within small memory. 
In contrast, Hash tables achieve O(1) time complexity for queries and inserts, making them highly efficient for exact queries and insertions. 
However, they lack key order and cannot perform range queries or sorting efficiently~\cite{cha2023blink}. 


\begin{figure}[htbp]
    \centering
    \includegraphics[width=.9\linewidth]{figures/BHashTree.pdf}
    % \captionsetup{skip=0pt}
    \caption{Dynamic Conversion of BHashTree. When the number of nodes reaches the predefined threshold $T$, \Chain converts B\(+\)Tree nodes to hash nodes.}
    \label{fig:Conversion}
\end{figure}


\begin{algorithm}[htbp]
% \captionsetup{skip=0pt}
\caption{Insertion Phase: Insert Data into BHashTree}
\label{Insert_Phase_BHashTree}
\begin{algorithmic}[1]
\Function{InsertToBHashTree}{entryId, timestamp}
    \State timeKey $\gets$ $\mathcal{C}$(\text{timestamp})
    \State rootNode $\gets$ BHashTreeNodes.rootId
    \If{rootNode.isLeaf \textbf{and} |rootNode.dEIds| $\geq$ T \textbf{and} \\
        \quad $\neg$ rootNode.isHashNode}
        \State rootNode.isHashNode $\gets$ \textbf{true}
        \State rootNode.fingerprint $\gets$ $\mathcal{C}$(\text{rootNode.dEIds}) \Comment{Compress fingerprints}
        \ForAll{entryId $\in$ rootNode.dEIds}
            \State key $\gets$ $\mathcal{F}$(rootNode.keys, entryId)
            \State rootNode.hashEty.key $\gets$ rootNode.hashEty.key $\cup$ \{entryId\}
        \EndFor
        \State rootNode.keys $\gets$ $\emptyset$
        \State rootNode.dEIds $\gets$ $\emptyset$
    \EndIf
    \If{rootNode.isHashNode}
        \State rootNode.hashEty.timeKey $\gets$ rootNode.hashEty.timeKey $\cup$ \{entryId\}
    \Else
        \State rootNode.keys $\gets$ rootNode.keys $\cup$ \{timeKey\}
        \State rootNode.dEIds $\gets$ rootNode.dEIds $\cup$ \{entryId\}
    \EndIf
    \State \Return True
\EndFunction
\end{algorithmic}
\end{algorithm}


To address these limitations, we propose BHashTree: a verifiable, gas-efficient index structure optimized for time-range queries. 
We modify the hash leaf node structure by employing a compressed fingerprint approach and fixed-size key-value pairs, thereby minimizing storage costs and ensuring efficient on-chain operations. 
We also adopt a dynamic adaptation strategy in which the system monitors insertion and scanning patterns through smart contract logic. This approach allows for the dynamic conversion of B\(+\)Tree nodes into hash nodes as scanning operations increase, optimizing storage and retrieval costs. 
As depicted in Fig.~\ref{fig:Conversion}, when the total number of B\(+\)Tree nodes reaches a predefined threshold \(T\) (set to 10 in our implementation), we iterate through the entire tree, transferring the values from tree nodes into hash nodes. 
Subsequently, we clear the keys and entryIDs of tree nodes to save storage.


To make BHashTree verifiable, we incorporate signed digests into the hash nodes. 
Following~\cite{pang2004authenticating}, we use a one-way hash function to compute the digest. 
Each leaf node stores a digest that encapsulates the key-value pair. 
Intermediate nodes maintain digests that propagate integrity up the tree. 
BHashTree generates a VO for time-range queries.
The VO includes digests for branches outside the queried range. 
This enables users to confirm result accuracy without accessing the entire structure. 
To preserve verifiability, we transfer digests for converted nodes without recalculating the whole tree. 
The root digest serves as a cryptographic anchor.
This allows efficient on-chain verification.
Algorithm \ref{Insert_Phase_BHashTree} and \ref{Query_Phase_Retrieve_Data} present the insertion and query phases of BHashTree. 


\subsubsection{Insertion phase}
As shown in Algorithm \ref{Insert_Phase_BHashTree}, lines 4 to 12 depict the conversion when the number of B\(+\)Tree nodes reaches the threshold $T$. 
Lines 7 to 10 set the node to a hash node and reorganize existing entries into the hash mapping. 
Lines 13 to 17 manage the insertion of new entries into the appropriate structure based on the status of rootNode.


\subsubsection{Query phase}
% Algorithm \ref{Query_Phase_Retrieve_Data} outlines the data retrieval process. 
As shown in Algorithm \ref{Query_Phase_Retrieve_Data},
% In lines 2 to 4, 
the function initializes search parameters and prepares the result collection (lines 2 to 4). 
The recursive function \texttt{FindEntriesByBHT} (lines 8 to 25) traverses the BHashTree to find entries within the specified time range. 
For leaf nodes, if the node is a hash node (lines 11 to 15), it iterates over the keys within the range and collects the corresponding entries; 
if it is a B\(+\)Tree node (lines 16 to 20), it scans through the keys and selects entries that match the time range.
Lines 22 to 24 handle internal nodes by recursively searching child nodes whose key ranges overlap with the query range.


\begin{algorithm}[htbp]
\caption{Query Phase: Retrieve Data by BHashTree}
\label{Query_Phase_Retrieve_Data}
\begin{algorithmic}[1]
\Function{GetDataByTime\_BHash}{startTime, endTime}
    \State \textit{sK} $\gets$ $\mathcal{C}$(startTime), \textit{eK} $\gets$ $\mathcal{C}$(endTime), \textit{rEIds} $\gets$ $\emptyset$
    % \State count $\gets$ 0
    \State \textit{count, rEIds} $\gets$ \Call{FindEntriesByBHT}{rootId, sK, eK, rEIds, count}
    \State $D \gets \{ d_i \mid i \in \textit{rEIds} \}$ \Comment{Retrieve data entries based on \textit{rEIds}}
    \State \Return $D$ \Comment{Return corresponding data entries}
\EndFunction

\Function{FindEntriesByBHT}{nodeId, sK, eK, rEIds, count}
    \State node $\gets$ BHashTreeNodes.nodeId
    \If{node.isLeaf}
        \If{node.isHashNode}
            \ForAll{key $\in$ $\langle$\textit{sK}, \textit{eK}$\rangle$}
                \ForAll{entryId $\in$ node.hashEty.key}
                    \State rEIds $\gets$ rEIds $\cup$ \{entryId\}, \text{count} $\gets$ \text{UpdateCount}(\text{count})
                \EndFor
            \EndFor
        \Else
            \ForAll{$\langle$key, entryId$\rangle$ $\in$ $\langle$node.keys, node.dEIds$\rangle$}
                \If{key $\geq$ sK \textbf{and} key $\leq$ eK}
                    \State rEIds $\gets$ rEIds $\cup$ \{entryId\}, \text{count} $\gets$ \text{UpdateCount}(\text{count})
                \EndIf
            \EndFor
        \EndIf
    \Else
        \ForAll{childId $\in$ node.children}
            \If{|$\mathcal{R}$(\text{Child}) $\cap$ [\textit{sK}, \textit{eK}]| > 0}
                \State count $\gets$ \Call{FindEntriesByBHT}{childId, sK, eK, rEIds, count}
            \EndIf
        \EndFor
    \EndIf
    \State \Return count
\EndFunction
\end{algorithmic}
\end{algorithm}


\subsection{Verifiable High-Performance Trie}
\label{sec:trie}
To support fuzzy queries, we present a verifiable high-performance trie based on previous work~\cite{fredkin1960trie}. 
Implementing a fast and gas-optimized trie in Solidity presents several challenges: (1) Minimizing gas consumption due to storage operations; (2) Handling timestamp strings efficiently despite lack of native string manipulation or character indexing; (3) Optimizing storage to reduce costs associated with mappings and dynamic arrays; (4) Ensuring scalability and performance given maximum call stack depth of 1024. 
To overcome these challenges, we reduce gas costs by using gas-efficient data structures and index-based storage. 
This involves assigning valid characters to fixed integer indices and storing nodes in mappings instead of arrays.
By encoding each character as an integer, we enable efficient traversal and storage without the overhead of string operations.
Furthermore, we optimize storage by replacing fixed-size arrays with mappings for child node indices in each trie node.
We enhance scalability by redesigning recursive functions into iterative ones, thus avoiding stack depth limitations and handling larger datasets efficiently within the EVM constraints.


To make the trie verifiable, we integrate hash digests into each node, where each digest is computed using a one-way hash function over the concatenation of the node's key and the digests of its child nodes.
This structure allows each node to verify the integrity of its data and its associated branches. 
The root node contains a global digest that serves as an anchor, updated with each structural modification (e.g., insertions or deletions) to maintain consistent integrity checks. 
By storing this root digest on-chain, clients can verify the correctness of any queried data without accessing the full trie, relying instead on a VO containing the path of digests from the root to the queried node along with sibling digests.


\subsection{Correctness and Completeness Analysis}
\label{sec:CorrectnessAnalysis}
\textbf{Theorem.} \emph{No false result is produced if the blockchain, off-chain storage, and verifiable indexing structures are functioning correctly.} 


\noindent \textit{Proof.} 
We prove this theorem by contradiction. 
Suppose a false result is produced. 
This could only occur if (i) the verifiable indexing structures failed, and (ii) the Bloom Filter-based cache returned a false result. 
However, (i) is impossible because the BHashTree and trie structures use cryptographic digests to ensure correctness.
If any modification or tampering occurs, it would result in a mismatch of digests during verification, thereby preventing false results from being returned. 
(ii) is impossible because the Bloom Filter cache, while possibly producing false positives, cannot return false negatives.
This means that if a result is not cached, it will be explicitly retrieved from the verifiable indexing structures, where the cryptographic verification ensures correctness.


\noindent \textbf{Theorem.} \emph{No valid result is missing if the blockchain, off-chain storage, and verifiable indexing structures are functioning correctly.}


\noindent \textit{Proof.} 
We prove this theorem by contradiction. Suppose a valid result is missing. 
This could only occur if (i) the verifiable indexing structures failed, (ii) the bloom-filter-based cache excluded it incorrectly, or (iii) the verification process rejected it. 
However, (i) is impossible because the BHashTree and trie structures maintain integrity through cryptographic digests, ensuring accurate indexing. 
(ii) is impossible because the Bloom Filter cache only risks false positives, never false negatives.
(iii) is impossible because any tampering would be detected via mismatched digests during verification. 
Therefore, no valid result will be missing.


\subsection{Security and Complexity Analysis}
\label{sec:SecurityAnalysis}


\textbf{Theorem.} 
\emph{Querying operations in \Chain are secure if the blockchain, off-chain storage, and verifiable indexing structures are secure.}


\noindent \textit{Proof.} 
We prove this theorem also by contradiction. 
Suppose the querying operations in \Chain are not secure. 
This would imply (i) the middleware introduces a vulnerability, (ii) the BHashTree or trie compromises security, or (iii) the verification process fails. 
However, (i) is impossible as \Chain adheres to the blockchain's security protocols. 
(ii) is impossible because the verifiable structures use cryptographic digests to ensure integrity. 
(iii) is impossible because mismatched digests during verification would detect any tampering. 
Thus, \Chain is secure if the underlying systems are secure.


\noindent \textbf{Complexity Analysis.} 
The BHashTree structure demonstrates an insertion time complexity of \( O(\log N) \) before conversion (when \( N < T \)) and \( O(1) \) after conversion (when \( N \geq T \)). 
The search time complexity is \( O(\log N + \frac{R}{B} ) \) before conversion and \( O(R) \) after conversion, where \( R \) is the number of result entries and \( B \) is the branching factor. The space complexity remains \( O(N) \). 
For the high-performance trie structure, the construction time complexity is \( O(n \, \overline{l}) \), where \( n \) is the number of strings and \( \overline{l} \) is the average string length. 
Its space complexity is \( O(n \, \overline{l} \, \sigma) \) in the worst case (where \( \sigma \) is the alphabet size) but is typically \( O(n \, \overline{l}) \) in practical scenarios.
Query operations have a time complexity of \( O(l) \), with \( l \) being the length of the query string, and a space complexity of \( O(1) \).