\section{System Architecture}


\subsection{Components}
In \Chain, the integration of on/off-chain resources enables efficient cross-modal SQL queries. 
This design allows users to execute complex queries. 
By leveraging the SQL middleware engine, \Chain balances performance and scalability in blockchain environments.
\Chain has three parties (illustrated in Fig.~\ref{fig:overview}): \ding{182} \textbf{Storage Layer}, \ding{183} \textbf{SQL Middleware Engine}, and \ding{184} \textbf{Query Client}.



\begin{figure}[htbp]
    \centering
    \includegraphics[width=.95\linewidth]{figures/System_Model.pdf}
    \caption{System Model of \Chain}
    \label{fig:overview}
\end{figure}




% \subsection{Components}


\subsubsection{Storage Layer}
The Storage Layer manages various multimodal data (e.g., text, images, and videos) by utilizing decentralized storage solutions (e.g., IPFS) to store large multimedia files off-chain while keeping essential metadata on-chain to guarantee data integrity and provenance. 
In the blockchain network~\cite{nakamoto2008bitcoin}~\cite{wood2014ethereum}, there are three types of nodes: full nodes, miner nodes, and light nodes. 
Full nodes maintain a complete copy of the blockchain ledger, ensuring data availability and validating transactions. 
Minor nodes contribute computational power to process transactions and add new blocks to the blockchain through consensus mechanisms, securing the network and maintaining its integrity. Light nodes store only essential information and rely on full nodes for data verification~\cite{V2FS2024}.


\subsubsection{SQL Middleware Engine}
The SQL Middleware Engine acts as a bridge between the query client and storage layer, the SQL middleware engine interprets high-level SQL queries into executable commands. Let a query \( Q \) be represented by a set of logical operations, \( Q = \{ L_1, L_2, \ldots, L_n \} \), where each \( L_i \) represents a logical operation that needs to be mapped to corresponding blockchain functions. The middleware engine uses a mapping function, \( T: Q \to C \), where \( C \) is the set of commands comprehensible by the blockchain network. Mathematically:


\begin{equation}
T(Q) = \{ T(L_1), T(L_2), \ldots, T(L_n) \}
\end{equation}


\subsubsection{Query Client}
The Query Client serves as the user interface for submitting SQL queries within the \Chain architecture. 
By interfacing directly with the SQL Middleware Engine, the Query Client delegates the interpretation and execution of high-level SQL queries to the middleware. 
This separation of concerns allows the Query Client to provide seamless query capabilities without storing or processing the entire distributed ledger. 
Consequently, users can perform complex cross-modal queries with reduced resource consumption, leveraging the scalability and performance benefits of the SQL Middleware Engine.


\subsection{Execution Flow}
As shown in Fig.~\ref{fig:execution_flow}, the execution flow of \Chain is divided into the following steps: 


\begin{enumerate}[leftmargin=*]
    \item Users initiate the process by submitting raw SQL queries \( Q \) through the User Interface Layer, which are then sent to the Parser for processing (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{192}}\)).

    \item The Optimizer refines \( Q \) into an execution plan \( P = \{p_1, p_2, \dots, p_n\} \) using dynamic programming, aiming to minimize the total computational cost \( C = \sum_{i=1}^n c(p_i) \), where \( c(p_i) \) represents the cost of each step (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{193}}\)).

    \item The Cache checks for previously computed results \( R_c \) matching \( Q \). 
    If \( R_c \neq \emptyset \), the cached results are returned to avoid redundant computation (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{194}}\)).
    If a match is found, the cached results \( R_c \) are directly delivered to the client (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{195}}\)).

    \item For uncached queries \( Q_u \), the Query Processing Unit retrieves the required data \( D = \{d_1, d_2, \dots, d_k\} \) by coordinating with both the blockchain and decentralized off-chain storage, ensuring consistency and data availability (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{196}}\)). 
    \item
    The retrieved data is integrated and formatted based on \( P \), generating the final results \( R \) for delivery (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{197}}\)).
    
    \item 
    Finally, the results \( R \) are returned to the client through the User Interface Layer (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{198}}\)).
\end{enumerate}


% Users initiate the process by submitting raw SQL queries \( Q \) via the User Interface Layer, which are then sent to the Parser for processing (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{192}}\)).
% The Optimizer refines \( Q \) into an execution plan \( P = \{p_1, p_2, \dots, p_n\} \) using dynamic programming, aiming to minimize the total computational cost \( C = \sum_{i=1}^n c(p_i) \), where \( c(p_i) \) represents the cost of each step (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{193}}\)).
% The Cache checks for previously computed results \( R_c \) matching \( Q \). If \( R_c \neq \emptyset \), cached results are returned to avoid redundant computation (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{194}}\)). 
% If a match is found, the cached results \( R_c \) are directly delivered to the client (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{195}}\)). 
% For uncached queries \( Q_u \), the Query Processing Unit retrieves the required data \( D = \{d_1, d_2, \dots, d_k\} \) by coordinating with both the blockchain and decentralized off-chain storage, ensuring consistency and data availability (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{196}}\)). 
% Retrieved data is integrated and formatted based on \( P \), generating the final results \( R \) for delivery (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{197}}\)). Finally, the results \( R \) are returned to the client through the User Interface Layer (\(\raisebox{-0.5ex}{\fontsize{14pt}{12pt}\selectfont\ding{198}}\)).


\begin{figure}[htbp]
    \centering
    \includegraphics[width=.9\linewidth]{figures/execution_flow.pdf}
    \caption{Execution Flow of \Chain}
    \label{fig:execution_flow}
\end{figure}