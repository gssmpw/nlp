The differentiable physics engine solves the robot motion equation and estimates
the trajectory corresponding to the delivered forces.
The trajectory is defined as a sequence of robot states $\tau = \{s_0, s_1, \ldots, s_T\}$,
where $\mathbf{s}_t = [\mathbf{x}_t, \mathbf{v}_t, R_t, \boldsymbol{\omega}_t]$
is the robot state at time $t$,
$\mathbf{x}_t \in \mathbb{R}^3$ and $\mathbf{v}_t \in \mathbb{R}^3$ define the robot's position and velocity in the world frame,
$R_t \in \mathbb{R}^{3 \times 3}$ is the robot's orientation matrix, and $\boldsymbol{\omega}_t \in \mathbb{R}^3$ is the angular velocity.
To get the next state $\mathbf{s}_{t+1}$, in general, we need to solve the following ODE:
\begin{equation}
    \label{eq:state_propagation}
    \mathbf{\dot{s}}_{t+1} = f(\mathbf{s}_t, \mathbf{u}_t, \mathbf{z}_t)
\end{equation}
where $\mathbf{u}_t$ is the control input and $\mathbf{z}_t$ is the environment state.
In practice, however, it is not feasible to obtain the full environment state $\mathbf{z}_t$.
Instead, we utilize terrain properties $\mathbf{m}_t = [\mathcal{H}_t, \mathcal{K}_t, \mathcal{D}_t, \mathcal{M}_t]$
predicted by the terrain encoder.
In this case, the motion ODE~\eqref{eq:state_propagation} can be rewritten as:
\begin{equation}
    \label{eq:state_propagation_terrain}
    \mathbf{\dot{s}}_{t+1} = \hat{f}(\mathbf{s}_t, \mathbf{u}_t, \mathbf{m}_t)
\end{equation}

Let's now derive the equation describing the state propagation function $\hat{f}$.
The time index $t$ is omitted further for brevity.
We model the robot as a rigid body with total mass $m$ represented by a~set of mass points
$\mathcal{P} = \{(\mathbf{p}_i, m_i)\; | \; \mathbf{p}_i~\in~\mathbb{R}^3, m_i~\in~\mathbb{R}^+, i=1~\dots~N\}$,
where $\mathbf{p}_i$ denotes coordinates of the $i$-th 3D point in the robot's body frame.
We employ common 6DOF dynamics of a rigid body~\cite{contact_dynamics-2018} as follows:
\begin{equation}
  \begin{split}
    \dot{\mathbf{x}} &= \mathbf{v}\\
    \dot{\mathbf{v}} &= \frac{1}{m}\sum_i\mathbf{F}_i
  \end{split}
  \quad\quad
  \begin{split}
    \dot{R} &= \Omega R\\
    \dot{\boldsymbol{\omega}} &= \mathbf{J}^{-1}\sum_i \mathbf{p}_i\times\mathbf{F}_i
  \end{split}
  \label{eq:contact_dynamics}
\end{equation}
where $\Omega = [\boldsymbol{\omega}]_{\times}$ is the skew-symmetric matrix of $\boldsymbol{\omega}$.
We denote $\mathbf{F}_i\in\mathbb{R}^3$ a total external force acting on $i$-th robot's body point.
Total mass $m = \sum_i~m_i$ and moment of inertia $\mathbf{J}\in\mathbb{R}^{3\times 3}$ of the robot's rigid body are assumed to be known
static parameters since they can be identified independently in laboratory conditions.
Note that the proposed framework allows backpropagating the gradient with respect to these quantities, too,
which makes them jointly learnable with the rest of the architecture.
The trajectory of the rigid body is the iterative solution of differential equations~\eqref{eq:contact_dynamics},
that can be obtained by any ODE solver for given external forces and initial state (pose and velocities).

When the robot is moving over a terrain, two types of external forces are acting
on the point cloud $\mathcal{P}$ representing its model:
(i) gravitational forces and (ii) robot-terrain interaction forces.
The former is defined as $m_i\mathbf{g} = [0, 0, -m_ig]^\top$ and acts on
all the points of the robot at all times,
while the latter is the result of complex physical interactions that are not easy
to model explicitly and act only on the points of the robot that are in contact
with the terrain.
There are two types of robot-terrain interaction forces:
(i) normal terrain force that prevents the penetration of the terrain by the robot points,
(ii) tangential friction force that generates forward acceleration when the tracks are moving,
and prevents side slippage of the robot.

\textbf{Robot-terrain interaction forces}

\begin{figure}[t]
    \centering
    \includegraphics[width=0.7\columnwidth]{imgs/dphysics/spring_forces}
    \caption{\textbf{Terrain force model}: Simplified 2D sketch demonstrating
    normal reaction forces acting on a robot body consisting of two points $p_i$ and $p_j$ .}
    \label{fig:spring_terrain_model}
\end{figure}

\textit{Normal reaction forces}.

One extreme option is to predict the 3D force vectors $\mathbf{F}_i$ directly
by a neural network, but we decided to enforce additional prior assumptions to reduce the risk of overfitting.
These prior assumptions are based on common intuition from the contact dynamics of flexible objects.
In particular, we assume that the magnitude of the force that the terrain exerts on the point $\mathbf{p}_i\in \mathcal{P}$
increases proportionally to the deformation of the terrain.
Consequently, the network does not directly predict the force,
but rather predicts the height of the terrain $h\in\mathcal{H}_t$
at which the force begins to act on the robot body and the stiffness of the terrain $e\in\mathcal{K}$.
We understand the quantity $e$ as an equivalent of the spring constant from Hooke's spring model, \autoref{fig:spring_terrain_model}.
Given the stiffness of the terrain and the point of the robot that penetrated the terrain
by ${\Delta}h$, the reaction force is calculated as $e\cdot{\Delta}h$.
% \begin{figure}[t]
%     \centering
%     \includegraphics[width=0.4\columnwidth]{imgs/dphysics/robot-terrain_forces}
%     \caption{\textbf{Robot-terrain interaction forces} acting on the robot's body at its contact points
%     with the terrain.
%     The point cloud was sampled from the MARV (\autoref{fig:robot_platforms}(b)) robot's 3D model.}
%     \label{fig:interaction_forces}
% \end{figure}

Since such a force, without any additional damping, would lead to an eternal bumping
of the robot on the terrain, we also introduce a robot-terrain damping coefficient $d\in\mathcal{D}$,
which similarly reduces the force proportionally to the velocity of the point
that is in contact with the terrain.
The model applies reaction forces in the normal direction $\mathbf{n}_i$ of the terrain surface,
where the $i$-th point is in contact with the terrain.
\begin{equation}\label{eq:normal_force}
    \mathbf{N}_{i} = \begin{cases}
 (e_i\Delta h_i - d_i(\dot{\mathbf{p}}_{i}^\top\mathbf{n}_i))\mathbf{n}_i  & \text{if } \mathbf{p}_{zi}\leq h_i \\
\mathbf{0} & \text{if } \mathbf{p}_{zi}> h_i
\end{cases},
\end{equation}
where terrain penetration $\Delta h_i = (h_i-\mathbf{p}_{zi})\mathbf{n}_{zi}$ is
estimated by projecting the vertical distance on the normal direction.
For a better gradient propagation, we use the smooth approximation of the Heaviside step function:
\begin{equation}
    \label{eq:smooth_normal_force}
    \mathbf{N}_i = (e_i\Delta h_i - d_i(\dot{\mathbf{p}}_{i}^\top\mathbf{n}_i))\mathbf{n}_i \cdot \sigma(h_i - \mathbf{p}_{zi}),
\end{equation}
where $\sigma(x) = \frac{1}{1+e^{-kx}}$ is the sigmoid function with a steepness hyperparameter $k$.

\begin{figure}[t]
    \centering
    \includegraphics[width=\columnwidth]{imgs/dphysics/optimization}
    \caption{\textbf{Terrain computed by backpropagating through $\nabla$Physics:}
    Shape of the terrain (border of the area where terrain forces start to act) outlined by heightmap surface,
    its color represents the friction of the terrain.
    The optimized trajectory is in green, and the ground truth trajectory is in blue.}
    \label{fig:terrain_optim}
\end{figure}

\textit{Tangential friction forces}.

Our tracked robot navigates by moving the main tracks and 4 flippers (auxiliary tracks).
The flipper motion is purely kinematic in our model.
This means that in a given time instant, their pose is uniquely determined by a $4$-dimensional vector
of their rotations, and they are treated as a rigid part of the robot.
The motion of the main tracks is transformed into forces tangential to the terrain.
The friction force delivers forward acceleration of the robot when robot tracks
(either on flippers or on main tracks) are moving.
At the same time, it prevents the robot from sliding sideways.
When a robot point $\mathbf{p}_i$, which belongs to a track, is in contact with terrain with
friction coefficient $\mu\in\mathcal{M}$, the resulting friction force at a contact point is computed as follows,~\cite{yong2012vehicle}:
\begin{equation}\label{eq:friction_force}
    \mathbf{F}_{f, i} = \mu_i |\mathbf{N}_i| ((\mathbf{u}_i - \mathbf{\dot{p}}_i)^\top\boldsymbol{\tau}_i)\boldsymbol{\tau}_i,
\end{equation}
where $\mathbf{u}_i = [u, 0, 0]^\top$, $u$ is the velocity of a track, and $\mathbf{\dot{p}}_i$ is the velocity of the point $\mathbf{p}_i$
with respect to the terrain transformed into the robot coordinate frame,
$\boldsymbol{\tau}_i$ is the unit vector tangential to the terrain surface at the point $\mathbf{p}_i$.
This model can be understood as a simplified Pacejka's tire-road model~\cite{pacejka-book-2012}
that is popular for modeling tire-road interactions.

To summarize, the state-propagation ODE~\eqref{eq:state_propagation_terrain}
(state $\mathbf{s}~=~[\mathbf{x},~\mathbf{v},~R,~\boldsymbol{\omega}]$) for a mobile robot moving over a terrain
is described by the equations of motion~\eqref{eq:contact_dynamics} where the force applied at a robot's $i$-th body point is computed as follows:
\begin{equation}\label{eq:forces}
    \begin{split}
        \mathbf{F}_i &= m_i\mathbf{g} + \mathbf{N}_i + \mathbf{F}_{f, i}
    \end{split}
\end{equation}
The robot-terrain interaction forces at contact points $\mathbf{N}_i$ and $\mathbf{F}_{f, i}$
are defined by the equations~\eqref{eq:smooth_normal_force} and~\eqref{eq:friction_force} respectively.


\textbf{Implementation of the Differentiable ODE Solver}

We implement the robot-terrain interaction ODE~\eqref{eq:contact_dynamics} in PyTorch~\cite{Paszke-NIPS-2019}.
The \textit{Neural ODE} framework~\cite{neural-ode-2021} is used to solve the system of ODEs.
For efficiency reasons, we utilize the Euler integrator for the ODE integration.
The differentiable ODE solver~\cite{neural-ode-2021} estimates the gradient through the implicit function theorem.
Additionally, we implement the ODE~\eqref{eq:contact_dynamics} solver that
estimates gradient through \textit{auto-differentiation}~\cite{Paszke-NIPS-2019},
i.e. it builds and retains the full computational graph of the feedforward integration.
