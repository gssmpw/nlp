
@inproceedings{brain_building_2019,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {Building {Better} {Bit}-{Blasting} for {Floating}-{Point} {Problems}},
	isbn = {978-3-030-17462-0},
	doi = {10.1007/978-3-030-17462-0\_5},
    url={https://doi.org/10.1007/978-3-030-17462-0\_5},
	abstract = {An effective approach to handling the theory of floating-point is to reduce it to the theory of bit-vectors. Implementing the required encodings is complex, error prone and requires a deep understanding of floating-point hardware. This paper presents SymFPU, a library of encodings that can be included in solvers. It also includes a verification argument for its correctness, and experimental results showing that its use in CVC4 out-performs all previous tools. As well as a significantly improved performance and correctness, it is hoped this will give a simple route to add support for the theory of floating-point.},
	language = {en},
	booktitle = {Tools and {Algorithms} for the {Construction} and {Analysis} of {Systems}},
	publisher = {Springer International Publishing},
	author = {Brain, Martin and Schanda, Florian and Sun, Youcheng},
	editor = {Vojnar, Tomáš and Zhang, Lijun},
	year = {2019},
	keywords = {SMT, Floating-point, IEEE-754, Satisfiability modulo theories},
	pages = {79--98},
	file = {Springer Full Text PDF:/home/sree/Zotero/storage/NCKZEB2U/Brain et al. - 2019 - Building Better Bit-Blasting for Floating-Point Pr.pdf:application/pdf},
}

@article{armstrong_isa_2019,
	title = {{ISA} semantics for {ARMv8}-a, {RISC}-v, and {CHERI}-{MIPS}},
	volume = {3},
	issn = {2475-1421, 2475-1421},
	url = {https://dl.acm.org/doi/10.1145/3290384},
	doi = {10.1145/3290384},
	language = {en},
	number = {POPL},
	urldate = {2020-11-21},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Armstrong, Alasdair and Bauereiss, Thomas and Campbell, Brian and Reid, Alastair and Gray, Kathryn E. and Norton, Robert M. and Mundkur, Prashanth and Wassell, Mark and French, Jon and Pulte, Christopher and Flur, Shaked and Stark, Ian and Krishnaswami, Neel and Sewell, Peter},
	month = jan,
	year = {2019},
	pages = {1--31},
	file = {Armstrong et al. - 2019 - ISA semantics for ARMv8-a, RISC-v, and CHERI-MIPS.pdf:/home/sree/Zotero/storage/BF7VMPIA/Armstrong et al. - 2019 - ISA semantics for ARMv8-a, RISC-v, and CHERI-MIPS.pdf:application/pdf},
}

@inproceedings{dasgupta_complete_2019,
	address = {New York, NY, USA},
	series = {{PLDI} 2019},
	title = {A {Complete} {Formal} {Semantics} of x86-64 {User}-level {Instruction} {Set} {Architecture}},
	isbn = {978-1-4503-6712-7},
	url = {http://doi.acm.org/10.1145/3314221.3314601},
	doi = {10.1145/3314221.3314601},
	abstract = {We present the most complete and thoroughly tested formal semantics of x86-64 to date. Our semantics faithfully formalizes all the non-deprecated, sequential user-level instructions of the x86-64 Haswell instruction set architecture. This totals 3155 instruction variants, corresponding to 774 mnemonics. The semantics is fully executable and has been tested against more than 7,000 instruction-level test cases and the GCC torture test suite. This extensive testing paid off, revealing bugs in both the x86-64 reference manual and other existing semantics. We also illustrate potential applications of our semantics in different formal analyses, and discuss how it can be useful for processor verification.},
	urldate = {2019-12-17},
	booktitle = {Proceedings of the 40th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Dasgupta, Sandeep and Park, Daejun and Kasampalis, Theodoros and Adve, Vikram S. and Roşu, Grigore},
	year = {2019},
	note = {event-place: Phoenix, AZ, USA},
	keywords = {ISA specification, x86-64, Formal Semantics},
	pages = {1133--1148},
	file = {ACM Full Text PDF:/home/sree/Zotero/storage/G2DI7A42/Dasgupta et al. - 2019 - A Complete Formal Semantics of x86-64 User-level I.pdf:application/pdf},
}

@book{nipkow_isabellehol_2021,
	title = {Isabelle/{HOL}: {A} {Proof} {Assistant} for {Higher}-{Order} {Logic}},
	url = {https://isabelle.in.tum.de/doc/tutorial.pdf},
	urldate = {2022-01-19},
	publisher = {Springer-Verlag},
	author = {Nipkow, Tobias and Paulson, Lawrence C. and Wenzel, Markus},
	month = dec,
	year = {2021},
	file = {tutorial.pdf:/home/sree/Zotero/storage/TX4C623V/tutorial.pdf:application/pdf},
}

@inproceedings{de_moura_z3_2008,
	address = {Berlin, Heidelberg},
	series = {{TACAS}'08/{ETAPS}'08},
	title = {Z3: {A}n {E}fficient {SMT} {S}olver},
	isbn = {978-3-540-78799-0},
	shorttitle = {Z3},
	abstract = {Satisfiability Modulo Theories (SMT) problem is a decision problem for logical first order formulas with respect to combinations of background theories such as: arithmetic, bit-vectors, arrays, and uninterpreted functions. Z3 is a new and efficient SMT Solver freely available from Microsoft Research. It is used in various software verification and analysis applications.},
    url = {https://dl.acm.org/doi/10.5555/1792734.1792766},
	urldate = {2020-11-20},
	booktitle = {Proceedings of the {Theory} and practice of software, 14th international conference on {Tools} and algorithms for the construction and analysis of systems},
	publisher = {Springer-Verlag},
	author = {De Moura, Leonardo and Bjørner, Nikolaj},
	month = mar,
	year = {2008},
	pages = {337--340},
}

@inproceedings{rungta_billion_2022,
	address = {Cham},
	series = {Lecture {Notes} in {Computer} {Science}},
	title = {A {Billion} {SMT} {Queries} a {Day} ({Invited} {Paper})},
	isbn = {978-3-031-13185-1},
	doi = {10.1007/978-3-031-13185-1_1},
	abstract = {Amazon Web Services (AWS) is a cloud computing services provider that has made significant investments in applying formal methods to proving correctness of its internal systems and providing assurance of correctness to their end-users. In this paper, we focus on how we built abstractions and eliminated specifications to scale a verification engine for AWS access policies, Zelkova, to be usable by all AWS users. We present milestones from our journey from a thousand SMT invocations daily to an unprecedented billion SMT calls in a span of five years. In this paper, we talk about how the cloud is enabling application of formal methods, key insights into what made this scale of a billion SMT queries daily possible, and present some open scientific challenges for the formal methods community.},
	language = {en},
	booktitle = {Computer {Aided} {Verification}},
	publisher = {Springer International Publishing},
	author = {Rungta, Neha},
	editor = {Shoham, Sharon and Vizel, Yakir},
	year = {2022},
	keywords = {Cloud Computing, Formal Verification, SMT Solving},
	pages = {3--18},
	file = {Full Text PDF:/home/sree/Zotero/storage/MXJMLMUN/Rungta - 2022 - A Billion SMT Queries a Day (Invited Paper).pdf:application/pdf},
    url = {https://doi.org/10.1007/978-3-031-13185-1\_1}
}

@inproceedings {vanegue_smt_2012,
title = {{SMT} Solvers in Software Security},
author = {Vanegue, Julien and Heelan, Sean and Rolles, Rolf},
booktitle = {6th USENIX Workshop on Offensive Technologies (WOOT 12)},
year = {2012},
address = {Bellevue, WA},
url = {https://www.usenix.org/conference/woot12/workshop-program/presentation/Vanegue},
publisher = {USENIX Association},
month = aug,
}

@inproceedings{trippel_checkmate_2018,
	address = {Fukuoka},
	title = {{CheckMate}: {Automated} {Synthesis} of {Hardware} {Exploits} and {Security} {Litmus} {Tests}},
	isbn = {978-1-5386-6240-3},
	shorttitle = {{CheckMate}},
	url = {https://ieeexplore.ieee.org/document/8574598/},
	doi = {10.1109/MICRO.2018.00081},
	abstract = {Recent research has uncovered a broad class of security vulnerabilities in which conﬁdential data is leaked through programmer-observable microarchitectural state. In this paper, we present CheckMate, a rigorous approach and automated tool for determining if a microarchitecture is susceptible to speciﬁed classes of security exploits, and for synthesizing proof-of-concept exploit code when it is. Our approach adopts “microarchitecturally happens-before” (µhb) graphs which prior work designed to capture the subtle orderings and interleavings of hardware execution events when programs run on a microarchitecture. CheckMate extends µhb graphs to facilitate modeling of security exploit scenarios and hardware execution patterns indicative of classes of exploits. Furthermore, it leverages relational model ﬁnding techniques to enable automated exploit program synthesis from microarchitecture and exploit pattern speciﬁcations.},
	language = {en},
	urldate = {2023-08-10},
	booktitle = {2018 51st {Annual} {IEEE}/{ACM} {International} {Symposium} on {Microarchitecture} ({MICRO})},
	publisher = {IEEE},
	author = {Trippel, Caroline and Lustig, Daniel and Martonosi, Margaret},
	month = oct,
	year = {2018},
	pages = {947--960},
	file = {Trippel et al. - 2018 - CheckMate Automated Synthesis of Hardware Exploit.pdf:/u/spai4/Zotero/storage/97QSXPZ7/Trippel et al. - 2018 - CheckMate Automated Synthesis of Hardware Exploit.pdf:application/pdf},
}

@inproceedings{lustig_coatcheck_2016,
	address = {Atlanta Georgia USA},
	title = {{COATCheck}: {Verifying} {Memory} {Ordering} at the {Hardware}-{OS} {Interface}},
	isbn = {978-1-4503-4091-5},
	shorttitle = {{COATCheck}},
	url = {https://dl.acm.org/doi/10.1145/2872362.2872399},
	doi = {10.1145/2872362.2872399},
	abstract = {Modern computer systems include numerous compute elements, from CPUs to GPUs to accelerators. Harnessing their full potential requires well-deﬁned, properly-implemented memory consistency models (MCMs), and low-level system functionality such as virtual memory and address translation (AT). Unfortunately, it is difﬁcult to specify and implement hardware-OS interactions correctly; in the past, many hardware and OS speciﬁcation mismatches have resulted in implementation bugs in commercial processors.},
	language = {en},
	urldate = {2023-08-10},
	booktitle = {Proceedings of the {Twenty}-{First} {International} {Conference} on {Architectural} {Support} for {Programming} {Languages} and {Operating} {Systems}},
	publisher = {ACM},
	author = {Lustig, Daniel and Sethi, Geet and Martonosi, Margaret and Bhattacharjee, Abhishek},
	month = mar,
	year = {2016},
	pages = {233--247},
}

@inproceedings{manerkar_ccicheck_2015,
	address = {Waikiki Hawaii},
	title = {{CCICheck}: using $\mu$hb graphs to verify the coherence-consistency interface},
	isbn = {978-1-4503-4034-2},
	shorttitle = {{CCICheck}},
	url = {https://dl.acm.org/doi/10.1145/2830772.2830782},
	doi = {10.1145/2830772.2830782},
	abstract = {In parallel systems, memory consistency models and cache coherence protocols establish the rules specifying which values will be visible to each instruction of parallel programs. Despite their central importance, verifying their correctness has remained a major challenge, due both to informal or incomplete speciﬁcations and to diﬃculties in scaling veriﬁcation to cover their operations comprehensively. While coherence and consistency are often speciﬁed and veriﬁed independently at an architectural level, many systems implement performance enhancements that tightly interweave coherence and consistency at a microarchitectural level in ways that make veriﬁcation of consistency diﬃcult. This paper introduces CCICheck, a tool and technique supporting static veriﬁcation of the coherenceconsistency interface (CCI). CCICheck enumerates and checks families of microarchitectural happens-before (µhb) graphs that describe how a particular coherence protocol combines with a particular processor’s pipelines and memory hierarchy to enforce the requirements of a given consistency model. To support tractable CCI veriﬁcation, CCICheck introduces the ViCL (Value in Cache Lifetime), an abstraction which allows the µhb graphs to cleanly represent CCI events relevant to consistency veriﬁcation, including demand fetching, cache line invalidation, coherence protocol windows of vulnerability, and partially incoherent cache hierarchies. We implement CCICheck as an automated tool and demonstrate its use on a number of case studies. We also show its tractability across a wide range of litmus tests.},
	language = {en},
	urldate = {2023-08-10},
	booktitle = {Proceedings of the 48th {International} {Symposium} on {Microarchitecture}},
	publisher = {ACM},
	author = {Manerkar, Yatin A. and Lustig, Daniel and Pellauer, Michael and Martonosi, Margaret},
	month = dec,
	year = {2015},
	pages = {26--37},
	file = {Manerkar et al. - 2015 - CCICheck using µhb graphs to verify the coherence.pdf:/u/spai4/Zotero/storage/EZSTM98N/Manerkar et al. - 2015 - CCICheck using µhb graphs to verify the coherence.pdf:application/pdf},
}
@inproceedings{lustig_pipecheck_2014,
	address = {Cambridge},
	title = {{PipeCheck}: {Specifying} and {Verifying} {Microarchitectural} {Enforcement} of {Memory} {Consistency} {Models}},
	isbn = {978-1-4799-6998-2},
	shorttitle = {{PipeCheck}},
	url = {https://doi.org/10.1109/MICRO.2014.38},
	doi = {10.1109/MICRO.2014.38},
	abstract = {We present PipeCheck, a methodology and automated tool for verifying that a particular microarchitecture correctly implements the consistency model required by its architectural speciﬁcation. PipeCheck adapts the notion of a “happens before” graph from architecture-level analysis techniques to the microarchitecture space. Each node in the “microarchitecturally happens before” (µhb) graph represents not only a memory instruction, but also a particular location (e.g., pipeline stage) within the microarchitecture. Architectural speciﬁcations such as “preserved program order” are then treated as propositions to be veriﬁed, rather than simply as assumptions.},
	language = {en},
	urldate = {2023-08-10},
	booktitle = {2014 47th {Annual} {IEEE}/{ACM} {International} {Symposium} on {Microarchitecture}},
	publisher = {IEEE},
	author = {Lustig, Daniel and Pellauer, Michael and Martonosi, Margaret},
	month = dec,
	year = {2014},
	pages = {635--646},
	file = {Lustig et al. - 2014 - PipeCheck Specifying and Verifying Microarchitect.pdf:/u/spai4/Zotero/storage/4RNYMZHN/Lustig et al. - 2014 - PipeCheck Specifying and Verifying Microarchitect.pdf:application/pdf},
}
@inproceedings{heule_stratified_2016,
	address = {New York, NY, USA},
	series = {{PLDI} '16},
	title = {Stratified {Synthesis}: {Automatically} {Learning} the x86-64 {Instruction} {Set}},
	isbn = {978-1-4503-4261-2},
	shorttitle = {Stratified {Synthesis}},
	url = {http://doi.acm.org/10.1145/2908080.2908121},
	doi = {10.1145/2908080.2908121},
	abstract = {The x86-64 ISA sits at the bottom of the software stack of most desktop and server software. Because of its importance, many software analysis and verification tools depend, either explicitly or implicitly, on correct modeling of the semantics of x86-64 instructions. However, formal semantics for the x86-64 ISA are difficult to obtain and often written manually through great effort. We describe an automatically synthesized formal semantics of the input/output behavior for a large fraction of the x86-64 Haswell ISA’s many thousands of instruction variants. The key to our results is stratified synthesis, where we use a set of instructions whose semantics are known to synthesize the semantics of additional instructions whose semantics are unknown. As the set of formally described instructions increases, the synthesis vocabulary expands, making it possible to synthesize the semantics of increasingly complex instructions. Using this technique we automatically synthesized formal semantics for 1,795 instruction variants of the x86-64 Haswell ISA. We evaluate the learned semantics against manually written semantics (where available) and find that they are formally equivalent with the exception of 50 instructions, where the manually written semantics contain an error. We further find the learned formulas to be largely as precise as manually written ones and of similar size.},
	urldate = {2019-12-17},
	booktitle = {Proceedings of the 37th {ACM} {SIGPLAN} {Conference} on {Programming} {Language} {Design} and {Implementation}},
	publisher = {ACM},
	author = {Heule, Stefan and Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
	year = {2016},
	note = {event-place: Santa Barbara, CA, USA},
	keywords = {program synthesis, ISA specification, x86-64},
	pages = {237--250},
	file = {ACM Full Text PDF:/u/spai4/Zotero/storage/QNATKD5R/Heule et al. - 2016 - Stratified Synthesis Automatically Learning the x.pdf:application/pdf},
}
