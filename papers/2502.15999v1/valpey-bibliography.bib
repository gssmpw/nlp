@article{ootomo2022recovering,
  title={{Recovering} {Single} {Precision} {Accuracy} from {Tensor} {Cores} {While} {Surpassing} the {FP32} {Theoretical} {Peak} {Performance}},
  author={Ootomo, Hiroyuki and Yokota, Rio},
  journal={The International Journal of High Performance Computing Applications},
  volume={36},
  number={4},
  pages={475--491},
  year={2022},
  publisher={SAGE Publications Sage UK: London, England},
  doi={10.1177/10943420221090256},
  url={https://doi.org/10.1177/10943420221090256}
}

@article{fasi2021numerical,
  title={{Numerical} {Behavior} of {NVIDIA} {Tensor} {Cores}},
  author={Fasi, Massimiliano and Higham, Nicholas J and Mikaitis, Mantas and Pranesh, Srikara},
  journal={PeerJ Computer Science},
  volume={7},
  pages={e330},
  year={2021},
  publisher={PeerJ Inc.},
  doi={10.7717/peerj-cs.330},
  url={https://doi.org/10.7717/peerj-cs.330}
}

@article{sun2022dissecting,
  title={{Dissecting} {Tensor} {Cores} via {Microbenchmarks}: {Latency}, {Throughput} and {Numeric} {Behaviors}},
  author={Sun, Wei and Li, Ang and Geng, Tong and Stuijk, Sander and Corporaal, Henk},
  journal={IEEE Transactions on Parallel and Distributed Systems},
  volume={34},
  number={1},
  pages={246--261},
  year={2022},
  publisher={IEEE},
  doi={10.1109/TPDS.2022.3217824},
  url={https://doi.org/10.1109/TPDS.2022.3217824}
}

@misc{cuda-c-programming,
  author = {{NVIDIA Corporation}},
  title = {CUDA {C++} {Programming} {Guide}},
  year = 2023,
  url = {https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html},
 lastaccessed = {Mar 27, 2023}
}

@misc{ptx-inline-assembly,
  author = {{NVIDIA Corporation}},
  title = {{Inline} {PTX} {Assembly} in {CUDA}},
  year = 2023,
  url = {https://docs.nvidia.com/cuda/inline-ptx-assembly/index.html},
 lastaccessed = {Mar 27, 2023}
}


@misc{ptx-isa-73,
  key={NVIDIA Corporation},
  publisher = {NVIDIA Corporation},
  title = {{Parallel} {Thread} {Execution} {ISA} {Version 6.5}},
  month={Apr},
  day=15,
  year = 2019,
  url = {https://docs.nvidia.com/cuda/archive/10.2/pdf/ptx\_isa\_6.5.pdf},
  urldate = {2023-03-27}
}

@techreport{volta-whitepaper,
    author={NVIDIA},
    institution={{NVIDIA Corporation}},
    title={{NVIDIA} {Tesla} {V100} {GPU} {Architecture}},
    month={Aug},
    year={2017},
    type={whitepaper},
    number={WP-08608-001\_v1.1},
    url={https://images.nvidia.com/content/volta-architecture/pdf/volta-architecture-whitepaper.pdf},
    urldate={2023-03-27}
}

@inproceedings{yan2020demystifying,
  author={Yan, Da and Wang, Wei and Chu, Xiaowen},
  booktitle={2020 IEEE International Parallel and Distributed Processing Symposium (IPDPS)}, 
  title={{Demystifying} {Tensor} {Cores} to {Optimize} {Half}-{Precision} {Matrix} {Multiply}}, 
  year={2020},
  volume={},
  number={},
  pages={634-643},
  doi={10.1109/IPDPS47924.2020.00071},
  url={https://doi.org/10.1109/IPDPS47924.2020.00071}
}

@misc{jia2018dissecting,
  title={{Dissecting} the {NVIDIA} {Volta} {GPU} {Architecture} via {Microbenchmarking}}, 
  author={Zhe Jia and Marco Maggioni and Benjamin Staiger and Daniele P. Scarpazza},
  year={2018},
  eprint={1804.06826},
  archivePrefix={arXiv},
  primaryClass={cs.DC},
  doi={10.48550/arXiv.1804.06826},
  url={https://doi.org/10.48550/arXiv.1804.06826}
}

@misc{BinaryUtilities,
  key={NVIDIA Corporation},
  publisher = {NVIDIA Corporation},
  title = {{CUDA} {Binary} {Utilities}},
  year = {2023},
  url = {https://docs.nvidia.com/cuda/cuda-binary-utilities/index.html},
  urldate = {2023-03-28}
}

@inproceedings{cvc5,
  author    = {Haniel Barbosa and
               Clark W. Barrett and
               Martin Brain and
               Gereon Kremer and
               Hanna Lachnitt and
               Makai Mann and
               Abdalrhman Mohamed and
               Mudathir Mohamed and
               Aina Niemetz and
               Andres N{\"{o}}tzli and
               Alex Ozdemir and
               Mathias Preiner and
               Andrew Reynolds and
               Ying Sheng and
               Cesare Tinelli and
               Yoni Zohar},
  editor    = {Dana Fisman and
               Grigore Rosu},
  title     = {cvc5: {A} {V}ersatile and {I}ndustrial-{S}trength {SMT} {S}olver},
  booktitle = {Tools and Algorithms for the Construction and Analysis of Systems
               - 28th International Conference, {TACAS} 2022, Held as Part of the
               European Joint Conferences on Theory and Practice of Software, {ETAPS}
               2022, Munich, Germany, April 2-7, 2022, Proceedings, Part {I}},
  series    = {Lecture Notes in Computer Science},
  volume    = {13243},
  pages     = {415--442},
  publisher = {Springer},
  year      = {2022},
  url       = {https://doi.org/10.1007/978-3-030-99524-9\_24},
  doi       = {10.1007/978-3-030-99524-9\_24},
  timestamp = {Fri, 01 Apr 2022 15:49:27 +0200},
  biburl    = {https://dblp.org/rec/conf/tacas/BarbosaBBKLMMMN22.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org},
}

@book{fp-handbook, 
  title={{H}andbook of {F}loating-{P}oint {A}rithmetic},
  url={http://dx.doi.org/10.1007/978-3-319-76526-6},
  DOI={10.1007/978-3-319-76526-6},
  publisher={Springer International Publishing}, 
  author={Muller, Jean-Michel and Brunie, Nicolas and de Dinechin, Florent and Jeannerod, Claude-Pierre and Joldes, Mioara and Lefèvre, Vincent and Melquiond, Guillaume and Revol, Nathalie and Torres, Serge},
  year={2018}
}

@article{ieee-754-2008,
  author={},
  key={IEEE},
  journal={IEEE Std 754-2008}, 
  title={{IEEE} {S}tandard for {F}loating-{P}oint {A}rithmetic}, 
  year={2008},
  volume={},
  number={},
  pages={1-70},
  doi={10.1109/IEEESTD.2008.4610935},
  url={https://doi.org/10.1109/IEEESTD.2008.4610935}
}

@inproceedings{markidis,
  title={{N}vidia {T}ensor {C}ore {P}rogrammability, {P}erformance \& {P}recision},
  author={Markidis, Stefano and Der Chien, Steven Wei and Laure, Erwin and Peng, Ivy Bo and Vetter, Jeffrey S},
  booktitle={2018 {IEEE} International Parallel and Distributed Processing Symposium Workshops (IPDPSW)},
  pages={522--531},
  year={2018},
  organization={IEEE},
  doi = {10.1109/ipdpsw.2018.00091},
  url = {https://doi.org/10.1109/ipdpsw.2018.00091},
}
@misc{nvcc-compile,
  title        = "NVIDIA CUDA Compiler Driver NVCC",
  author       = "{NVIDIA}",
  howpublished = "\url{https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/}",
  url={https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/},
  year         = 2023,
}

@misc{nvidia-ptx,
  key={NVIDIA Corporation},
  publisher = {NVIDIA Corporation},
  title = {{PTX} {ISA}},
  year = {2023},
  url = {https://docs.nvidia.com/cuda/parallel-thread-execution/},
}


@inproceedings{fang2022towards,
  title={{T}owards {P}recision-{A}ware {F}ault {T}olerance {A}pproaches for {M}ixed-{P}recision {A}pplications},
  author={Fang, Bo and Hari, Siva Kumar Sastry and Tsai, Timothy and Li, Xinyi and Gopalakrishnan, Ganesh and Laguna, Ignacio and Barker, Kevin and Li, Ang},
  booktitle={2022 IEEE/ACM 12th Workshop on Fault Tolerance for HPC at eXtreme Scale (FTXS)},
  pages={47--52},
  year={2022},
  organization={IEEE},
  doi={10.1109/FTXS56515.2022.00010},
  url={https://doi.org/10.1109/FTXS56515.2022.00010}
}

@techreport{smtlibspec,
  author =	 "Clark Barrett and Pascal Fontaine and Cesare Tinelli",
  title =	 {{The Satisfiability Modulo Theories Library (SMT-LIB)}},
  howpublished = {{\tt www.SMT-LIB.org}},
  year =	 2016,
  url={http://smtlib.cs.uiowa.edu/papers/smt-lib-reference-v2.6-r2021-05-12.pdf}
}

@misc{smt3,
url={http://smtlib.cs.uiowa.edu/version3.shtml},
title={{SMT-LIB} {Version} 3.0 - {Preliminary} {Proposal}},
year=2021,
month={12},
day={31}
}

@article{Hickmann2019ExperimentalAO,
  title={{E}xperimental {A}nalysis of {M}atrix {M}ultiplication {F}unctional {U}nits},
  author={Brian J. Hickmann and Dennis Bradford},
  journal={2019 IEEE 26th Symposium on Computer Arithmetic (ARITH)},
  year={2019},
  pages={116-119},
  url={https://api.semanticscholar.org/CorpusID:204821986},
  doi={10.1109/ARITH.2019.00031}
}

@inproceedings{norman2023pipesynth,
  author = {Norman, Chase and Godbole, Adwait and Manerkar, Yatin A.},
  title = {{P}ipe{S}ynth: {A}utomated {S}ynthesis of {M}icroarchitectural {A}xioms for {M}emory {C}onsistency},
  year = {2023},
  isbn = {9781450399180},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3582016.3582056},
  doi = {10.1145/3582016.3582056},
  abstract = {Formal verification can help ensure the correctness of today’s processors. However, such formal verification requires formal specifications of the processors being verified. Today, these specifications are mostly written by hand, which is tedious and error-prone. Furthermore, architects and hardware engineers generally do not have formal methods experience, making it even harder for them to write formal specifications. Existing methods for the automated synthesis of formal microarchitectural specifications utilise RTL implementations of processors for their synthesis, preventing their usage until RTL implementation of the processor has completed. This hampers the effectiveness of formal verification for processors, as catching design bugs pre-RTL can reduce verification overhead and overall development time. In response, we present PipeSynth, an automated formal methodology and tool for the synthesis of µspec microarchitectural ordering axioms from small example programs (litmus tests) and microarchitectural execution traces. PipeSynth helps architects automatically generate formal specifications for their microarchitectures before RTL is even written, enabling greater use of formal verification on today’s microarchitectures. We evaluate PipeSynth’s capability to synthesise single axioms and multiple axioms at the same time across four microarchitectures. Our evaluated microarchitectures include an out-of-order processor and one with a non-traditional coherence protocol. In single-axiom synthesis, PipeSynth is capable of synthesising replacement axioms for 42 out of 46 axioms from our evaluated microarchitectures in under 2 hours per axiom. When doing multi-axiom synthesis, we are able to synthesise an entire microarchitectural specification for the in-order Multi-V-scale processor in under 1 hour, and can synthesise at least 4 nontrivial axioms at the same time for our other microarchitectures.},
  booktitle = {Proceedings of the 28th ACM International Conference on Architectural Support for Programming Languages and Operating Systems, Volume 3},
  pages = {513–527},
  numpages = {15},
  keywords = {formal methods, synthesis, memory consistency, microarchitecture},
  location = {Vancouver, BC, Canada},
  series = {ASPLOS 2023}
}

@article{paranoia,
  author = {Karpinski, Richard},
  title={{Paranoia}: {A} {F}loating-{P}oint {B}enchmark},
  journal={Byte Magazine},
  pages={223-235},
  volume=10,
  number=2,
  month={Feb},
  year=1985,
  url={https://www.netlib.org/paranoia/}
}

@article{blanchard2020mixed,
  author = {Blanchard, Pierre and Higham, Nicholas J. and Lopez, Florent and Mary, Theo and Pranesh, Srikara},
  title = {{M}ixed {P}recision {B}lock {F}used {M}ultiply-{A}dd: {E}rror {A}nalysis and {A}pplication to {GPU} {T}ensor {C}ores},
  journal = {SIAM Journal on Scientific Computing},
  volume = {42},
  number = {3},
  pages = {C124-C141},
  year = {2020},
  doi = {10.1137/19M1289546},
  URL = {https://doi.org/10.1137/19M1289546},
  eprint = { https://doi.org/10.1137/19M1289546},
    abstract = { Computing units that carry out a fused multiply-add (FMA) operation with matrix arguments, referred to as tensor units by some vendors, have great potential for use in scientific computing. However, these units are inherently mixed precision, and existing rounding error analyses do not support them. We consider a mixed precision block FMA that generalizes both the usual scalar FMA and existing tensor units. We describe how to exploit such a block FMA in the numerical linear algebra kernels of matrix multiplication and LU factorization and give detailed rounding error analyses of both kernels. An important application is to GMRES-based iterative refinement with block FMAs, about which our analysis provides new insight. Our framework is applicable to the tensor core units in the NVIDIA Volta and Turing GPUs. For these we compare matrix multiplication and LU factorization with TC16 and TC32 forms of FMA, which differ in the precision used for the output of the tensor cores. Our experiments on an NVDIA V100 GPU confirm the predictions of the analysis that the TC32 variant is much more accurate than the TC16 one, and they show that the accuracy boost is obtained with almost no performance loss. }
}

@article{fasi2023matrix,
  author = {Fasi, Massimiliano and Higham, Nicholas J. and Lopez, Florent and Mary, Theo and Mikaitis, Mantas},
  title = {{M}atrix {M}ultiplication in {M}ultiword {A}rithmetic: {E}rror {A}nalysis and {A}pplication to {GPU} {T}ensor {C}ores},
  journal = {SIAM Journal on Scientific Computing},
  volume = {45},
  number = {1},
  pages = {C1-C19},
  year = {2023},
  doi = {10.1137/21M1465032},
  URL = {https://doi.org/10.1137/21M1465032},
  eprint = {https://doi.org/10.1137/21M1465032},
  abstract = { Abstract. In multiword arithmetic, a matrix is represented as the unevaluated sum of two or more lower precision matrices, and a matrix product is formed by multiplying the constituents in low precision. We investigate the use of multiword arithmetic for improving the performance-accuracy tradeoff of matrix multiplication with mixed precision block fused multiply–add (FMA) hardware, focusing especially on the tensor cores available on NVIDIA GPUs. Building on a general block FMA framework, we develop a comprehensive error analysis of multiword matrix multiplication. After confirming the theoretical error bounds experimentally by simulating low precision in software, we use the cuBLAS and CUTLASS libraries to implement a number of matrix multiplication algorithms using double-fp16 (double-binary16) arithmetic. When running the algorithms on NVIDIA V100 and A100 GPUs, we find that double-fp16 is not as accurate as fp32 (binary32) arithmetic despite satisfying the same worst-case error bound. Using probabilistic error analysis, we explain why this issue is likely to be caused by the rounding mode used by the NVIDIA tensor cores, and we propose a parameterized blocked summation algorithm that alleviates the problem and significantly improves the performance-accuracy tradeoff. }
}

@inproceedings{hsiao2021synthesizing,
  author = {Hsiao, Yao and Mulligan, Dominic P. and Nikoleris, Nikos and Petri, Gustavo and Trippel, Caroline},
  title = {{S}ynthesizing {F}ormal {M}odels of {H}ardware from {RTL} for {E}fficient {V}erification of {M}emory {M}odel {I}mplementations},
  year = {2021},
  isbn = {9781450385572},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  url = {https://doi.org/10.1145/3466752.3480087},
  doi = {10.1145/3466752.3480087},
  abstract = {Modern hardware complexity makes it challenging to determine if a given microarchitecture adheres to a particular memory consistency model (MCM). This observation inspired the Check tools, which formally check that a specific microarchitecture correctly implements an MCM with respect to a suite of litmus test programs. Unfortunately, despite their effectiveness and efficiency, the Check tools must be supplied a microarchitecture in the guise of a manually constructed axiomatic specification, called a μspec model. To facilitate MCM verification—and enable the Check tools to consume processor RTL directly—we introduce a methodology and associated tool, rtl2μspec, for automatically synthesizing μspec models from processor designs written in Verilog or SystemVerilog, with the help of modest user-provided design metadata. As a case study, we use rtl2μspec to facilitate the Check-based verification of the four-core RISC-V V-scale (multi-V-scale) processor’s MCM implementation. We show that rtl2μspec can synthesize a complete, and proven correct by construction, μspec model from the SystemVerilog design of the multi-V-scale processor in 6.84 minutes. Subsequent Check-based MCM verification of the synthesized μspec model takes less than one second per litmus test.},
  booktitle = {MICRO-54: 54th Annual IEEE/ACM International Symposium on Microarchitecture},
  pages = {679–694},
  numpages = {16},
  keywords = {shared memory, verification, memory consistency, concurrency},
  location = {Virtual Event, Greece},
  series = {MICRO '21}
}

@inproceedings{10.1145/3037697.3037719,
author = {Trippel, Caroline and Manerkar, Yatin A. and Lustig, Daniel and Pellauer, Michael and Martonosi, Margaret},
title = {TriCheck: {M}emory {M}odel {V}erification at the {T}risection of {S}oftware, {H}ardware, and {ISA}},
year = {2017},
isbn = {9781450344654},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3037697.3037719},
doi = {10.1145/3037697.3037719},
abstract = {Memory consistency models (MCMs) which govern inter-module interactions in a shared memory system, are a significant, yet often under-appreciated, aspect of system design. MCMs are defined at the various layers of the hardware-software stack, requiring thoroughly verified specifications, compilers, and implementations at the interfaces between layers. Current verification techniques evaluate segments of the system stack in isolation, such as proving compiler mappings from a high-level language (HLL) to an ISA or proving validity of a microarchitectural implementation of an ISA.This paper makes a case for full-stack MCM verification and provides a toolflow, TriCheck, capable of verifying that the HLL, compiler, ISA, and implementation collectively uphold MCM requirements. The work showcases TriCheck's ability to evaluate a proposed ISA MCM in order to ensure that each layer and each mapping is correct and complete. Specifically, we apply TriCheck to the open source RISC-V ISA [55], seeking to verify accurate, efficient, and legal compilations from C11. We uncover under-specifications and potential inefficiencies in the current RISC-V ISA documentation and identify possible solutions for each. As an example, we find that a RISC-V-compliant microarchitecture allows 144 outcomes forbidden by C11 to be observed out of 1,701 litmus tests examined. Overall, this paper demonstrates the necessity of full-stack verification for detecting MCM-related bugs in the hardware-software stack.},
booktitle = {Proceedings of the Twenty-Second International Conference on Architectural Support for Programming Languages and Operating Systems},
pages = {119–133},
numpages = {15},
keywords = {here, keywords, separated by semi-colons},
location = {Xi'an, China},
series = {ASPLOS '17}
}

@article{trippel2017tricheck,
  author = {Trippel, Caroline and Manerkar, Yatin A. and Lustig, Daniel and Pellauer, Michael and Martonosi, Margaret},
  title = {{T}ri{C}heck: {M}emory {M}odel {V}erification at the {T}risection of {S}oftware, {H}ardware, and {ISA}},
  year = {2017},
  issue_date = {March 2017},
  publisher = {Association for Computing Machinery},
  address = {New York, NY, USA},
  volume = {45},
  number = {1},
  issn = {0163-5964},
  url = {https://doi.org/10.1145/3093337.3037719},
  doi = {10.1145/3093337.3037719},
  abstract = {Memory consistency models (MCMs) which govern inter-module interactions in a shared memory system, are a significant, yet often under-appreciated, aspect of system design. MCMs are defined at the various layers of the hardware-software stack, requiring thoroughly verified specifications, compilers, and implementations at the interfaces between layers. Current verification techniques evaluate segments of the system stack in isolation, such as proving compiler mappings from a high-level language (HLL) to an ISA or proving validity of a microarchitectural implementation of an ISA.This paper makes a case for full-stack MCM verification and provides a toolflow, TriCheck, capable of verifying that the HLL, compiler, ISA, and implementation collectively uphold MCM requirements. The work showcases TriCheck's ability to evaluate a proposed ISA MCM in order to ensure that each layer and each mapping is correct and complete. Specifically, we apply TriCheck to the open source RISC-V ISA [55], seeking to verify accurate, efficient, and legal compilations from C11. We uncover under-specifications and potential inefficiencies in the current RISC-V ISA documentation and identify possible solutions for each. As an example, we find that a RISC-V-compliant microarchitecture allows 144 outcomes forbidden by C11 to be observed out of 1,701 litmus tests examined. Overall, this paper demonstrates the necessity of full-stack verification for detecting MCM-related bugs in the hardware-software stack.},
  journal = {SIGARCH Comput. Archit. News},
  month = {apr},
  pages = {119–133},
  numpages = {15},
}

@inproceedings{hayes_decoding_2019,
  author = {Hayes, Ari B. and Hua, Fei and Huang, Jin and Chen, Yanhao and Zhang, Eddy Z.},
  title = {{D}ecoding {CUDA} {B}inary},
  year = {2019},
  isbn = {9781728114361},
  url = {https://dl.acm.org/doi/10.5555/3314872.3314900},
  publisher = {IEEE Press},
  abstract = {NVIDIA's software does not offer translation of assembly code to binary for their GPUs, since the specifications are closed-source. This work fills that gap. We develop a systematic method of decoding the Instruction Set Architectures (ISAs) of NVIDIA's GPUs, and generating assemblers for different generations of GPUs. Our framework enables cross-architecture binary analysis and transformation. Making the ISA accessible in this manner opens up a world of opportunities for developers and researchers, enabling numerous optimizations and explorations that are unachievable at the source-code level. Our infrastructure has already benefited and been adopted in important applications including performance tuning, binary instrumentation, resource allocation, and memory protection.},
  booktitle = {Proceedings of the 2019 IEEE/ACM International Symposium on Code Generation and Optimization},
  pages = {229–241},
  numpages = {13},
  keywords = {Code Translation and Transformation, GPU, Instruction Set Architecture (ISA), Code Generation, CUDA},
  location = {Washington, DC, USA},
  series = {CGO 2019}
}

@misc{google-tpu,
  author={Jouppi, Norm},
  title={{G}oogle {S}upercharges {M}achine {L}earning {T}asks with {TPU} {C}ustom {C}hip},
  url= {https://cloud.google.com/blog/products/ai-machine-learning/google-supercharges-machine-learning-tasks-with-custom-chip},
  year={2016},
  month={may},
  day={18},
  lastaccessed={May 2, 2024},
  language={en},
  publisher={Google},
}

@inproceedings{boldo:hal-02982017,
  TITLE = {{A Correctly-Rounded Fixed-Point-Arithmetic Dot-Product Algorithm}},
  AUTHOR = {Boldo, Sylvie and Gallois-Wong, Diane and Hilaire, Thibault},
  URL = {https://inria.hal.science/hal-02982017},
  BOOKTITLE = {{ARITH 2020 - IEEE 27th Symposium on Computer Arithmetic}},
  ADDRESS = {Portland, United States},
  PUBLISHER = {{IEEE}},
  PAGES = {9-16},
  YEAR = {2020},
  MONTH = Jun,
  DOI = {10.1109/ARITH48897.2020.00011},
  KEYWORDS = {Dot Product ; Sum-of-Products ; Correct Round- ing ; Odd Rounding ; Fixed-Point Arithmetic},
  PDF = {https://inria.hal.science/hal-02982017v1/file/paper_17.pdf},
  HAL_ID = {hal-02982017},
  HAL_VERSION = {v1},
}

@misc{tcfft2024,
  author       = {Rox906},
  title        = {tcFFT},
  year         = {2024},
  howpublished = {\url{https://github.com/rox906/tcFFT}},
  note         = {Accessed: 2024-12-17}
}

 @inproceedings{Goodloe_Muñoz_Kirchner_Correnson_2013, address={Berlin, Heidelberg}, title={Verification of Numerical Programs: From Real Numbers to Floating Point Numbers}, ISBN={978-3-642-38088-4}, abstractNote={Numerical algorithms lie at the heart of many safety-critical aerospace systems. The complexity and hybrid nature of these systems often requires the use of interactive theorem provers to verify that these algorithms are logically correct. Usually, proofs involving numerical computations are conducted in the infinitely precise realm of the field of real numbers. However, numerical computations in these algorithms are often implemented using floating point numbers. The use of a finite representation of real numbers introduces uncertainties as to whether the properties verified in the theoretical setting hold in practice. This short paper describes work in progress aimed at addressing these concerns. Given a formally proven algorithm, written in the Program Verification System (PVS), the Frama-C suite of tools is used to identify sufficient conditions and verify that under such conditions the rounding errors arising in a C implementation of the algorithm do not affect its correctness. The technique is illustrated using an algorithm for detecting loss of separation among aircraft.}, booktitle={NASA Formal Methods}, publisher={Springer Berlin Heidelberg}, author={Goodloe, Alwyn E. and Muñoz, César and Kirchner, Florent and Correnson, Loïc}, editor={Brat, Guillaume and Rungta, Neha and Venet, Arnaud}, year={2013}, pages={441–446} }


@InProceedings{bohlender2012fast,
author="Bohlender, Gerd
and Kulisch, Ulrich",
editor="J{\'o}nasson, Kristj{\'a}n",
title={{Comments on Fast and Exact Accumulation of Products}},
booktitle="Applied Parallel and Scientific Computing",
year="2012",
publisher="Springer Berlin Heidelberg",
address="Berlin, Heidelberg",
pages="148--156",
abstract="A new IEEE arithmetic standard 1788 is currently being worked out. It will specify interval arithmetic and an exact dot product (EDP). In an EDP, an arbitrary finite number of products is accumulated without rounding errors.",
isbn="978-3-642-28145-7"
}

@inproceedings{rummer2010smt,
  title={An {SMT-LIB} {T}heory of {B}inary {F}loating-{P}oint {A}rithmetic},
  author={R{\"u}mmer, Philipp and Wahl, Thomas},
  booktitle={International Workshop on Satisfiability Modulo Theories (SMT)},
  volume={151},
  year={2010}
}

@article{schkufza2014stochastic,
  title={Stochastic {O}ptimization of {F}loating-{P}oint {P}rograms with {T}unable {P}recision},
  author={Schkufza, Eric and Sharma, Rahul and Aiken, Alex},
  journal={ACM SIGPLAN Notices},
  volume={49},
  number={6},
  pages={53--64},
  year={2014},
  publisher={ACM New York, NY, USA}
}
@inproceedings{darulova2014sound,
  title={{S}ound {C}ompilation of {R}eals},
  author={Darulova, Eva and Kuncak, Viktor},
  booktitle={Proceedings of the 41st ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages={235--248},
  year={2014}
}
@inproceedings{darulova2018daisy,
  title={Daisy-{F}ramework for {A}nalysis and {O}ptimization of {N}umerical {P}rograms ({T}ool {P}aper)},
  author={Darulova, Eva and Izycheva, Anastasiia and Nasir, Fariha and Ritter, Fabian and Becker, Heiko and Bastian, Robert},
  booktitle={Tools and Algorithms for the Construction and Analysis of Systems: 24th International Conference, TACAS 2018, Held as Part of the European Joint Conferences on Theory and Practice of Software, ETAPS 2018, Thessaloniki, Greece, April 14-20, 2018, Proceedings, Part I 24},
  pages={270--287},
  year={2018},
  organization={Springer}
}

@inproceedings{darulova2018sound,
  title={{S}ound {M}ixed-{P}recision {O}ptimization {W}ith {R}ewriting},
  author={Darulova, Eva and Horn, Einar and Sharma, Saksham},
  booktitle={2018 ACM/IEEE 9th International Conference on Cyber-Physical Systems (ICCPS)},
  pages={208--219},
  year={2018},
  organization={IEEE}
}

@INPROCEEDINGS{martin2015automatable,
  author={Brain, Martin and Tinelli, Cesare and Ruemmer, Philipp and Wahl, Thomas},
  booktitle={2015 IEEE 22nd Symposium on Computer Arithmetic}, 
  title={An {A}utomatable {F}ormal {S}emantics for {IEEE-754} {F}loating-{P}oint {A}rithmetic}, 
  year={2015},
  volume={},
  number={},
  pages={160-167},
  keywords={Cognition;Standards;Semantics;Floating-point arithmetic;Computers;Software;Hardware;Floating point aritihmetic;SMT},
  doi={10.1109/ARITH.2015.26}}

@inproceedings{leeser2014make,
  title={Make it {R}eal: {E}ffective {F}loating-{P}oint {R}easoning via {E}xact {A}rithmetic},
  author={Leeser, Miriam and Mukherjee, Saoni and Ramachandran, Jaideep and Wahl, Thomas},
  booktitle={2014 Design, Automation \& Test in Europe Conference \& Exhibition (DATE)},
  pages={1--4},
  year={2014},
  organization={IEEE}
}

@inproceedings{peleska2011automated,
  title={{A}utomated {T}est {C}ase {G}eneration with {SMT}-solving and {A}bstract {I}nterpretation},
  author={Peleska, Jan and Vorobev, Elena and Lapschies, Florian},
  booktitle={NASA Formal Methods: Third International Symposium, NFM 2011, Pasadena, CA, USA, April 18-20, 2011. Proceedings 3},
  pages={298--312},
  year={2011},
  organization={Springer}
}

@article{kim2019test,
  title={{T}est {S}pecification and {G}eneration for {C}onnected and {A}utonomous {V}ehicle in {V}irtual {E}nvironments},
  author={Kim, Baekgyu and Masuda, Takato and Shiraishi, Shinichi},
  journal={ACM Transactions on Cyber-Physical Systems},
  volume={4},
  number={1},
  pages={1--26},
  year={2019},
  publisher={ACM New York, NY, USA}
}

@INPROCEEDINGS{2011flcoq,
  author={Boldo, Sylvie and Melquiond, Guillaume},
  booktitle={2011 IEEE 20th Symposium on Computer Arithmetic}, 
  title={Flocq: {A} {U}nified {L}ibrary for {P}roving {F}loating-{P}oint {A}lgorithms in {C}oq}, 
  year={2011},
  volume={},
  number={},
  pages={243-252},
  keywords={Libraries;Automation;Testing;Humans;Electronic mail;Safety;Arrays;floating-point arithmetic;formal proof system;program verification},
  doi={10.1109/ARITH.2011.40}}

@article{solovyev2018rigorous,
  title={{R}igorous {E}stimation of {F}loating-{P}oint {R}ound-off {E}rrors with {S}ymbolic {T}aylor {E}xpansions},
  author={Solovyev, Alexey and Baranowski, Marek S and Briggs, Ian and Jacobsen, Charles and Rakamari{\'c}, Zvonimir and Gopalakrishnan, Ganesh},
  journal={ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume={41},
  number={1},
  pages={1--39},
  year={2018},
  publisher={ACM New York, NY, USA}
}

@inproceedings{appel2024vcfloat2,
  title={{VCF}loat2: {F}loating-{P}oint {E}rror {A}nalysis in {C}oq},
  author={Appel, Andrew and Kellison, Ariel},
  booktitle={Proceedings of the 13th ACM SIGPLAN International Conference on Certified Programs and Proofs},
  pages={14--29},
  year={2024}
}