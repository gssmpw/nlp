\begin{table}[!htp]\centering
\caption{Statistics of the studied data structures in Z3}\label{tab:z3-data}
\small
\begin{tabular}{l|rrrrrrrr}\toprule
&ema &dlist &heap &hashtable &permutation &scoped\_vector &bdd\_manager \\\midrule
\# LoC &57 &243 &309 &761 &177 &220 &1635 \\
\# dependencies &0 &2 &1 &9 &2 &2 &13 \\
\bottomrule
\end{tabular}
\end{table}

As a real-world case study, we apply \tech to synthesize invariants for 7 core data structures from Z3~\cite{z3}, ranging from the simple 57-line \CodeIn{ema} class to the complex 1635-line \CodeIn{bdd\_manager}. The complete set includes \CodeIn{dlist}, \CodeIn{heap}, \CodeIn{hashtable}, \CodeIn{permutation}, and \CodeIn{scoped\_vector}, with varying implementation complexity and the number of dependent classes as shown in Table~\ref{tab:z3-data}. 
Our results were validated by one of the Z3 authors, who confirmed at least one \emph{correct and useful} invariant for each studied class, with the \CodeIn{bdd\_manager} class yielding 11 valuable invariants including the 2 already present from 8 generations.

Z3 is a widely adopted SMT solver used in a variety of high-stakes applications requiring rigorous correctness, such as formal verification, program analysis, and automated reasoning. It is integrated into tools like LLVM~\cite{llvm}, KLEE~\cite{klee}, Dafny~\cite{leino2010dafny} and Frama-C~\cite{kirchner2015frama}.
We selected the Z3 codebase due to its stringent correctness requirements; as an SMT solver, Z3 is employed in applications demanding high reliability. This high-stakes environment makes Z3 an ideal testbed for assessing the effectiveness of synthesized invariants.


The \CodeIn{bdd\_manager} class\footnote{\url{https://github.com/Z3Prover/z3/blob/master/src/math/dd/dd_bdd.h}} is particularly noteworthy. 
It was chosen because it is a self-contained example with developer-written unit tests for validation, presenting a realistic yet manageable challenge. 
Note that the existing developer tests were used after invariants were generated, not as input to the LLM. 
The \CodeIn{bdd\_manager} class in Z3 is a utility for managing Binary Decision Diagrams (BDDs), which are data structures used to represent Boolean functions efficiently. In BDDs, Boolean functions are represented as directed acyclic graphs, where each non-terminal node corresponds to a Boolean variable, and edges represent the truth values of these variables (\textit{true} or \textit{false}). This representation simplifies complex Boolean expressions and enables efficient operations on Boolean functions.


With 382 lines of code in its header and 1253 lines in the implementation file, \CodeIn{bdd\_manager} surpasses standard data structure complexity, offering an opportunity to evaluate \tech's capability to generate meaningful invariants relevant to real-world scenarios. 
\tech achieves this by compositional generation, recursively traversing the source program's AST (Section~\ref{sec:llm}). 
Recursive generation became crucial when handling large classes like \CodeIn{bdd\_manager}, which exceeded the LLM’s context window. Decomposing and processing its components separately allowed us to fit relevant parts into the model’s input, demonstrating the utility of recursive invariant generation for large codebases. This supports its relevance in real-world applications beyond the benchmarks.

The  \CodeIn{bdd\_manager} class includes a developer-written member function for checking its well-formedness, as shown in Figure~\ref{fig:bdd_well_formed}, which we removed during \tech generation. Of the 56 invariants generated by \tech, one of Z3 main authors identified 11 distinct \textit{correct and useful} invariants (e.g., Figure~\ref{fig:bdd_correct_useful}) including the 2 developer-written invariants; these invariants could potentially be integrated into the codebase.
An additional 5 distinct \textit{ok} invariants (e.g., Figure~\ref{fig:bdd_ok})  are labeled correct but have limited utility, 16 distinct \textit{correct but useless} invariants (e.g., those already checked during compilation, such as type checks and constants, Figure~\ref{fig:bdd_correct_useless}), and 2 \textit{incorrect} invariants (e.g., Figure~\ref{fig:bdd_incorrect}). The remaining invariants were repetitions within these categories. This evaluation aligns with \tech's validation results, as our validation pipeline also identified 2 incorrect invariants that failed \CodeIn{bdd\_manager} unit tests.
\shuvendu{Why did you choose to report invariants that already failed the unit test?}

Overall, the Z3 authors' evaluation results further confirm \tech's potential utility in real-world, large-scale codebases.

\begin{figure}[htp]
    \centering
\begin{lstlisting}[language=c++]
bool bdd_manager::well_formed() {
    bool ok = true;
    for (unsigned n : m_free_nodes) {
        ok &= (lo(n) == 0 && hi(n) == 0 && m_nodes[n].m_refcount == 0);
        if (!ok) {
            IF_VERBOSE(0, verbose_stream() << "free node is not internal " << n << " " << lo(n) << " " << hi(n) << " " << m_nodes[n].m_refcount << "\n";
            display(verbose_stream()););
            UNREACHABLE();
            return false;
        }
    }
    
    for (bdd_node const& n : m_nodes) {
        if (n.is_internal()) continue;
        unsigned lvl = n.m_level;
        BDD lo = n.m_lo;
        BDD hi = n.m_hi;
        ok &= is_const(lo) || level(lo) < lvl;
        ok &= is_const(hi) || level(hi) < lvl;
        ok &= is_const(lo) || !m_nodes[lo].is_internal();
        ok &= is_const(hi) || !m_nodes[hi].is_internal();
        if (!ok) {
            IF_VERBOSE(0, display(verbose_stream() << n.m_index << " lo " << lo << " hi " << hi << "\n"););
            UNREACHABLE();
            return false;
        }
    }
    return ok;
}
\end{lstlisting}
    \caption{Z3 developer-written class invariants for \CodeIn{bdd\_manager} class}
    \label{fig:bdd_well_formed}
\end{figure}

\begin{figure}[htp]
    \centering
\begin{lstlisting}[language=c++]
// Node consistency: Each node's index should match its position in m_nodes
for (unsigned i = 0; i < m_nodes.size(); ++i) {
    assert(m_nodes[i].m_index == i);
}
\end{lstlisting}
    \caption{\textit{Correct and useful} invariant for \CodeIn{bdd\_manager} class}
    \label{fig:bdd_correct_useful}
\end{figure}

\begin{figure}[htp]
    \centering
\begin{lstlisting}[language=c++]
// Cache consistency: Entries in the operation cache should be valid
for (const auto* e : m_op_cache) {
    assert(e != nullptr);
    assert(e->m_result != null_bdd);
}
\end{lstlisting}
    \caption{\textit{Ok} invariant for \CodeIn{bdd\_manager} class}
    \label{fig:bdd_ok}
\end{figure}

\begin{figure}[htp]
    \centering
\begin{lstlisting}[language=c++]
// m_is_new_node is a boolean
assert(m_is_new_node == true || m_is_new_node == false);
\end{lstlisting}
    \caption{\textit{Correct and useless} invariant for \CodeIn{bdd\_manager} class}
    \label{fig:bdd_correct_useless}
\end{figure}


\begin{figure}[htp]
    \centering
\begin{lstlisting}[language=c++]
// The number of nodes should not exceed the maximum number of BDD nodes
assert(m_nodes.size() <= m_max_num_bdd_nodes);
\end{lstlisting}
    \caption{\textit{Incorrect} invariant for \CodeIn{bdd\_manager} class}
    \label{fig:bdd_incorrect}
\end{figure}

