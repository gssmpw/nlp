Invariants are predicates that hold on the program state for all executions of the program. Many invariants hold only at specific code locations.
For sequential imperative programs, it is useful to associate invariants with entry to a method (preconditions), exit from a method (postconditions), and loop headers (loop invariants).
Further, for stateful classes, class invariants are facts that hold as both preconditions and postconditions of the public methods of the class, in addition to serving as a postcondition for the class constructors for the class. 

These program invariants help make explicit the assumptions on the rest of the code helping modular review, reasoning, and analysis. 
Program invariants are useful for several aspects of software construction and maintenance during the lifetime of a program.
First, executable program invariants can be enforced at runtime, thus serving as an early indicator of state corruption helping root causing and stopping a program instead of producing unexpected values. 
Runtime invariants serve as additional test oracles to amplify testing efforts to catch subtle bugs related to state corruption; this in turn helps with regression testing as the program evolves to satisfy new requirements. 
The utility of program invariants has led to design-by-contract in languages such as Eiffel~\cite{meyer1992eiffel}, as well as support in other languages such as Java (JML~\cite{jml}) and .NET (Code Contracts~\cite{fahndrich2010static}). 
Further, for languages that support static formal verification (e.g., Dafny~\cite{leino2010dafny}, Verus~\cite{verus}, F*~\cite{swamy2011secure}, Frama-C~\cite{kirchner2015frama}), these invariants can serve as the specification as well as help make formal verification scale by making verification modular and scalable. Unfortunately, invariants are underutilized because they require additional work and are sometimes difficult to write, so it would be useful to find a way to generate them automatically.

We focus specifically on automating the creation of class invariants for mainstream languages without first-class specification language support (e.g., C++) for several reasons:
\begin{itemize}
\item Class invariants are crucial to maintain the integrity of data structures and help point to state corruption that may manifest much later within the class or in the clients.
Documenting such implicit contracts can greatly aid the understanding for maintainers of the class. 
\item Class invariants often form important parts of preconditions and postconditions for high-integrity data structures. Capturing such invariants in a method and asserting them in preconditions and postconditions help reduce bloat in the specifications. 
\item Class invariants are challenging for users to write as writing them requires global reasoning across all the public methods for the class. 
\end{itemize}

For example, consider the class for a doubly linked list as implemented in Z3 Satisfiability Modulo Theories (SMT) code\footnote{\url{https://github.com/Z3Prover/z3/blob/master/src/util/dlist.h}}. 
\begin{figure}[htp]
    \centering

\begin{subfigure}[t]{0.55\linewidth}
\begin{lstlisting}[language=c++]
   void insert_before(T* other) {
        ...
        SASSERT(invariant());
        SASSERT(other->invariant());
        ...
        T* prev = this->m_prev;
        T* other_end = other->m_prev;
        prev->m_next = other;
        other->m_prev = prev;
        other_end->m_next = static_cast<T*>(this);
        this->m_prev = other_end;
        ...
        SASSERT(invariant());
        SASSERT(other->invariant());
        ...
    }
\end{lstlisting}
    
\end{subfigure}
\hfill
\begin{subfigure}[t]{0.42\linewidth}
\begin{lstlisting}[language=c++,firstnumber=17]
    bool invariant() const {
        auto* e = this;
        do {
            if (e->m_next->m_prev != e)
                return false;
            e = e->m_next;
        }
        while (e != this);
        return true;
    }
\end{lstlisting}
\end{subfigure}
    \caption{An invariant in the doubly linked list class in Z3.}
    \label{fig:z3_dll}
\end{figure}

We see that the invariant is repeated four times: as a precondition and postcondition for the object instance \CodeIn{this} and for \CodeIn{other}.
The invariant is also non-trivial, requiring local variables and a loop.

Synthesizing program invariants has been an active line of research, with both static and dynamic analysis-based approaches. 
Static analysis approaches based on variants of \textit{abstract interpretation}~\cite{cousot1977abstract} and \textit{interpolation}~\cite{henzinger2004abstractions} create invariants that are sound by construction. 
However, such techniques do not readily apply to mainstream programming languages with complex language constructs or require highly specialized methods that do not scale to large modules, since the invariants need to be additionally \textit{provably inductive} to be retained. 
On the other hand, Daikon~\cite{ernst2007daikon} and successors learn invariants dynamically by instantiating a set of templates and retaining the predicates that hold on concrete test cases. 
While applicable to any mainstream language, it is well known that Daikon generated invariants overfit the test cases and are not sound for all test cases~\cite{polikarpova2009comparative}.
Recent works have studied fine-tuning large language models (LLMs) to learn program invariants~\cite{pei2023learning} but these methods inherit the same limitation from Daikon because their training data consists of Daikon generated invariants. More importantly, the approach has not been evaluated on stateful classes to construct class invariants. 

Recent work on \textit{prompting} LLMs such as GPT-4 to generate program invariants for mainstream languages~\cite{nl2postcond,greiner2024automated,ma2024specgen}  
has been used to generate preconditions, postconditions, and loop invariants, but these methods do not readily extend to generating class invariants.
Further, these methods cannot construct expressive invariants that require iterating over complex linked data structures (such as in Figure~\ref{fig:z3_dll}) other than simple arrays. 

In this work, we introduce \tech, a novel method for generating high-quality object invariants for C++ classes through \emph{co-generation} of invariants and test inputs using LLMs such as GPT-4o.
We leverage LLMs' ability to generate code to construct invariants that can express properties over complex data structures.
The ability to consume not only the code of a class but also the surrounding comments and variable names helps establish relationships difficult for purely symbolic methods.
Since an LLM can generate incorrect invariants, the method also generates test inputs to \emph{heuristically} prune incorrect candidate invariants. 


We leverage the framework proposed by Endres et al.~\cite{nl2postcond} to evaluate the test-set correctness and completeness given a set of hidden validation tests and mutants. 
We contribute a new benchmark comprising standard C++ data structures along with a harness that can help measure both the correctness and completeness of generated invariants (Section~\ref{sec:benchmark}).
We demonstrate that \tech outperforms a pure LLM-based technique for generating program invariants from code (Sections~\ref{subsec:correctness}--\ref{subsec:completeness}) as well as prior data-driven invariant inference techniques such as Daikon (Section~\ref{subsec:daikon_compare}).
We also demonstrate its applicability for real-world code by performing a case study on \CodeIn{ema}, \CodeIn{dlist}, \CodeIn{heap}, \CodeIn{hashtable}, \CodeIn{permutation}, \CodeIn{scoped\_vector}, and the most complex class, \CodeIn{bdd\_manager} within the Z3 SMT solver codebase; the developers of the codebase confirmed most of the new invariants proposed by \tech for these modules (Section~\ref{sec:z3}). 

Our contributions are summarized below:
\begin{itemize}
    \item Present new techniques of invariant-test co-generation by combining simple static analysis with LLM and implement an end-to-end prototype (Section~\ref{sec:approach}).
    \item Introduce a high-quality \tech-instrumented benchmark for evaluating object invariants  (Section~\ref{sec:benchmark}).
    \item Investigate LLM-assisted class invariant synthesis (Sections~\ref{subsec:correctness}--\ref{subsec:daikon_compare}).
    \item Conduct a case study on Z3 \CodeIn{bdd\_manager} module using \tech (Section~\ref{sec:z3}).
\end{itemize}



