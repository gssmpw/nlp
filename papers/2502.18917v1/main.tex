\PassOptionsToPackage{dvipsnames}{xcolor}
%\documentclass[acmsmall,screen,review,anonymous,nonacm]{acmart}
\documentclass[acmsmall,screen,nonacm]{acmart}


\acmJournal{JACM}
\acmVolume{37}
\acmNumber{4}
\acmArticle{111}
\acmMonth{8}

\usepackage{longtable}
\usepackage{tikz}
\usepackage[ruled, vlined, linesnumbered, commentsnumbered, longend]{algorithm2e}

\usepackage{xcolor}
\usepackage{xspace}
\usepackage{booktabs, multirow}
\usepackage{soul}
\usepackage{listings}
\usepackage{subcaption}
\usepackage{wrapfig}
\usepackage{enumitem}
\usepackage{wrapfig}

\renewcommand{\ttdefault}{txtt}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.97,0.97,0.95}
\definecolor{forestgreen}{rgb}{0.28,0.62,0.37}
\definecolor{codeblue}{rgb}{0,0.5,1}

\lstdefinelanguage{markdown}{
    morekeywords={*, \#, \_, `},
    sensitive=false,
    morecomment=[l]{//},   % to allow comments in markdown syntax
    morestring=[b]",        % double quotes for strings
    postbreak={},
breakindent=0pt,
breakautoindent=false,
}


\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codepurple},
    keywordstyle=\color{codepurple},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{blue},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                 
    numbers=left,                    
    numbersep=5pt,                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=4
}

\lstset{style=mystyle}
\newcommand{\HighlightBG}{\makebox[0pt][l]{\color{yellow!50}\rule[-0.45em]{\linewidth}{1.3em}}}

\usetikzlibrary{shapes, arrows}

\begin{document}
\input{macro}

\title{\tech: Class Invariant Synthesis using Large Language Models}

\author{Chuyue Sun}
\authornote{Work done while interning at Microsoft.}
\affiliation{%
   \institution{Stanford University}
   \country{USA}
}
\email{chuyues@stanford.edu}
\author{Viraj Agashe}
\affiliation{%
   \institution{Microsoft Research}
   \country{India}
}
\email{t-vagashe@microsoft.com}
\author{Saikat Chakraborty}
\affiliation{%
   \institution{Microsoft Research}
   \country{USA}
}
\email{saikatc@microsoft.com}
\author{Jubi Taneja}
\affiliation{%
   \institution{Microsoft Research}
   \country{USA}
}
\email{jubitaneja@microsoft.com}
\author{Clark Barrett}
\affiliation{%
   \institution{Stanford University}
   \country{USA}
}
\email{barrettc@stanford.edu}
\author{David Dill}
\affiliation{%
   \institution{Stanford University}
   \country{USA}
}
\email{dill@cs.stanford.edu}
\author{Xiaokang Qiu}
\authornote{Work done while visiting Microsoft.}
\affiliation{%
  \institution{Purdue University}
   \country{USA}
}
\email{xkqiu@purdue.edu}
\author{Shuvendu K. Lahiri}
\affiliation{%
   \institution{Microsoft Research}
   \country{USA}
}
\email{shuvendu@microsoft.com}


\begin{abstract}
Formal program specifications in the form of preconditions, postconditions, and class invariants have several benefits for the construction and maintenance of programs. They not only aid in program understanding due to their unambiguous semantics but can also be enforced dynamically (or even statically when the language supports a formal verifier).  However, synthesizing high-quality specifications in an underlying programming language is limited by the expressivity of the specifications or the need to express them in a declarative manner. Prior work has demonstrated the potential of large language models (LLMs) for synthesizing high-quality method pre/postconditions for Python and Java, but does not consider class invariants.

In this work, we describe \tech, a method for co-generating executable class invariants and test inputs to produce high-quality class invariants for a mainstream language such as C++, leveraging LLMs' ability to synthesize pure functions. We show that \tech outperforms a pure LLM-based technique to generate specifications (from code) as well as prior data-driven invariant inference techniques such as Daikon. We contribute a benchmark of standard C++ data structures along with a harness that can help measure both the correctness and completeness of generated specifications using tests and mutants. We also demonstrate its applicability to real-world code by performing a case study on several classes within a widely used and high-integrity C++ codebase.
\end{abstract}


\maketitle

\section{Introduction}
\input{intro}



\section{Running Example: AVL Tree}
\label{sec:avl_intro}

\input{motivation}

\section{Approach}
\label{sec:approach}
\input{approach}



\section{Results}
\label{sec:results}
\subsection{Benchmark}
\label{sec:benchmark}
\input{benchmark}
\subsection{Evaluation}
\input{experiments}
\input{results}

\section{Case study: Z3 \CodeIn{bdd\_manager} class}
\label{sec:z3}
\input{z3}

\section{Related Work}
\input{related-work}

\section{Limitation}
\input{discussion}

\section{Conclusion}
\label{sec:concl}
\input{concl}

\section*{Acknowledgments}
We would like to thank Nikolaj Bj√∏rner for his encouragement and help in inspecting the several generated invariants for the Z3 source code and provide feedback about their utility. 


\bibliographystyle{ACM-Reference-Format}
\bibliography{custom}

% \appendix
\appendix
\include{prompt_refine}
%\include{appendix/inv_table}

\end{document}
\endinput
%%
%% End of file `sample-acmcp.tex'.
