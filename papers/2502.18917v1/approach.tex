
\begin{figure*}[t]
    \centering
    \includegraphics[width=0.95\textwidth]{figure/framework.pdf}  % Adjust the width as needed
    \caption{Overview of \tech.}
    \label{fig:framework}
\end{figure*}


An overview of the \tech framework is shown in Figure~\ref{fig:framework}. It outlines an automated pipeline for inferring class invariants from source code. 
\tech takes a complete source program as input and outputs invariant candidates it has identified with high confidence (called \textit{filtered invariants}).
\tech starts with a preprocessing step which performs static analysis on the program (Section~\ref{sec:preprocess}).  Next, an LLM is used to generate candidate invariants and filtering test suites (Section~\ref{sec:llm}).  Then, the code is instrumented to facilitate checking candidate invariants (Section~\ref{sec:instrumentation}).  
Finally, \tech uses generated tests to prune invariant candidates (Section~\ref{sec:testing}), and a refinement loop is used to iteratively improve the results (Section~\ref{sec:refinement}). 
\shuvendu{Still cannot justify the test ranking}



\subsection{Generation}
\label{subsec:generation}


\subsubsection{Preprocessing}
\label{sec:preprocess}

As illustrated in Figure~\ref{fig:framework}, the generation phase begins with a static analysis of the source program. \tech uses a Tree-Sitter-based parser for program preprocessing; Tree-Sitter~\cite{treesitter} is a parser generator tool that constructs a syntax tree from source files.

\tech parses the entire source program into an abstract syntax tree (AST) to extract class members and their recursive dependencies. It then identifies the target class and gathers details (e.g., method declarations, field declarations, and subclass definitions) relevant to forming correct class invariants. \tech recursively analyzes all identified classes (i.e., the target class and its subclasses) and performs a topological sort to prepare generation from the leaf class upward as shown in Algorithm~\ref{algo:algo}.

\begin{algorithm}
\caption{Function to generate invariants for target class AST parsed by Tree-Sitter}
\small
\label{algo:algo}
\DontPrintSemicolon
\SetKwProg{Fn}{Function}{:}{}

\SetKwFunction{GenerateInvariant}{\textsc{GenerateInvariant}}
\SetKwFunction{getClassRecursively}{\textsc{getClassRecursively}}
\SetKwFunction{sort}{\textsc{reverseToplogicalSort}}
\SetKwFunction{getClassDependencies}{\textsc{getClassDependencies}}
\SetKwFunction{needsInvariant}{\textsc{needsInvariant}}
\SetKwFunction{getCodeForClass}{\textsc{getCodeForClass}}
\SetKwFunction{getCompletions}{\textsc{generateInvariantWithLLM}}

\SetKwFunction{getClassMethods}{\textsc{getClassMethods}}
\SetKwFunction{getText}{\textsc{getText}}

\Fn{\GenerateInvariant{target\_class}}{
    \If{target\_class.id $\in$ invariants\_dict}{
        \Return{invariants\_dict[target\_class.id]}\; \label{line:cache}
    }
    
    dep\_classes $\leftarrow$ \getClassRecursively{target\_class}\; \label{line:collect}
    rev\_topsorted\_classes $\leftarrow$ \sort{dep\_classes}\; \label{line:sort}
    
    \ForEach{class $\in$ rev\_topsorted\_classes}{
            
            class\_code $\leftarrow$ \getCodeForClass{class, invariants\_dict}\; \label{line:classcode}
            
            \ForEach{dep $\in$ \getClassDependencies{class}}{
            \tcp{Invariant: dep has been generated invariants for}
                dep\_code $\leftarrow$ \getCodeForClass{dep, invariants\_dict}\; \label{line:dev-code}
                class\_code $\leftarrow$ class\_code  + dep\_code\; \label{line:dev-code-ed}
            }
            
            invariants\_dict[class.id] $\leftarrow$ \getCompletions{class\_code}\; \label{line:geninv}
          
    }
    
    final\_invariants $\leftarrow$ invariants\_dict[target\_class.id]\;
    \Return{final\_invariants}\;
}

\Fn{\getCodeForClass{class, invariants\_dict, include\_method\_bodies=False}}{
    class\_text $\leftarrow$ class.get\_declaration\_text()\tcp*{Header code} \label{line:helper-1}
    \If{class.id $\in$ invariants\_dict \textbf{ and } invariants\_dict[class.id]}{
        class\_text $\leftarrow$ invariants\_dict[class.id] + class\_text  \tcp*{Get generated invariants} \label{line:helper-2}
    }
    
    \If{include\_method\_bodies}{
        \tcp{Add methods bodies to class\_text if context allows} \label{line:contextwd}
    }
    \Return{class\_text}\;
}
\end{algorithm}


\subsubsection{Generation by LLM}
\label{sec:llm}

\begin{figure*}[htp]
\begin{lstlisting}[language=markdown]
You are an expert in creating program invariants from code and natural language.
Invariants are assertions on the variables in scope that hold true at different program points
We are interested in finding invariants that hold at both start and end of a function within a data structure. Such an invariant is commonly known as an object invariant.  

The invariants can usually be expressed as a check on the state at the particular program point. The check should be expressed as a check in the same underlying programming language which evaluates to true or false. To express these, you can use:
- An assertion in the programming language
- A pure method (which does not have any side effect on the variables in scope) that checks one or more assertion
- For a collection, you can use a loop to iterate over elements of the collection and assert something on each element or a pair of elements.  

Task Description: 
Task 1: Given a module, in the form of a class definition, your task is to infer object invariants about the class. For doing so, you may examine how the methods of the class read and modify the various fields of the class. 
For coming up with invariants, you may use the provided code and any comments in the code. You may also use world knowledge to guide the search for invariants. 
 
Task 2: Generate unit tests for the class based on the class definition and public API methods. The test cases should simulate a series of public method calls to verify the behavior of the class, but do not use any testing framework like gtest. Do not add `assert` or any form of assertions.
\end{lstlisting}
    \caption{\tech Generation system prompt: instruction and task description.}
    \label{fig:prompt_generation_system_task}
\end{figure*}


After building the source program AST, \tech uses LLMs to analyze the class module and infers both invariants for the target class and tests that exercise the class’s implementation as thoroughly as possible. \tech uses a fixed system prompt that defines class invariants and outlines two main tasks: (1) generating class invariants from the source code, and (2) creating a test suite of valid API calls without specifying expected outputs (Figure~\ref{fig:prompt_generation_system_task} and Figure~\ref{fig:prompt_generation_system_inputoutput} in Appendix).
Next, \tech instantiates a user prompt template (Figure~\ref{appendix:prompt_generation_user} in Appendix) with the actual target class.

From the source program AST, \tech identifies program dependencies and populates the prompt template with the leaf struct/class. Starting from the leaf nodes, \tech leverages previously generated invariants by including them in the prompt for later classes. 
\shuvendu{I am still unconvinced that class invariants need to be exposed to clients without expanding to pre/post conditions.}
To accommodate the LLM's context window limit, only the relevant child classes of the current target class are included in the prompt, with method implementations and private fields/methods hidden when necessary. An algorithm for this process is presented in Algorithm~\ref{algo:algo}.

Algorithm~\ref{algo:algo} presents the invariant generation process for a source program AST. The main function \GenerateInvariant takes a \CodeIn{target\_class} and leverages a caching mechanism through \CodeIn{invariants\_dict} to avoid redundant computations (Line~\ref{line:cache}).
The algorithm first collects dependent classes via \getClassRecursively (Line~\ref{line:collect}) and sorts them using \sort to ensure dependency-aware processing (Line~\ref{line:sort}). For each \CodeIn{class} in the sorted order, it constructs the necessary context by obtaining the class code through \getCodeForClass (Line~\ref{line:classcode}). For each dependency \CodeIn{dep} of the current \CodeIn{class}, it retrieves the \CodeIn{dep\_code} and concatenates it with \CodeIn{class\_code} (Lines~\ref{line:dev-code}--\ref{line:dev-code-ed}). 
The algorithm then generates invariants using \getCompletions and stores them in \CodeIn{invariants\_dict} (Line~\ref{line:geninv}).
The helper function \getCodeForClass constructs class representations by combining the declaration text with any existing invariants from \CodeIn{invariants\_dict} (Lines~\ref{line:helper-1}--\ref{line:helper-2}).
It optionally includes method bodies based on context window constraints. This approach ensures efficient invariant generation while maintaining all necessary context and dependencies (Line~\ref{line:contextwd}).
The algorithm concludes by returning \CodeIn{final\_invariants} for the target class, effectively managing the invariant generation process while respecting LLM context limitations.


\tech accommodates large codebases by dividing the source program into smaller modules that fit within the LLM’s context window. It then iteratively generates invariants and test cases, starting from leaf classes and working up towards the root class. At each step, \tech leverages previous invariants generated for child classes to inform the invariants for parent classes.

For the \CodeIn{AvlTree} example, we begin by instantiating the prompt with \CodeIn{Node} for annotation, followed by \CodeIn{AvlTree}, since \CodeIn{Node} is a subclass of \CodeIn{AvlTree}, as illustrated in Figure~\ref{fig:avl_header}. In this specific case, however, Algorithm~\ref{algo:algo} does not make a difference due to the small size of the source program; the entire \CodeIn{AvlTree} code fits within the LLM’s context window easily.
In contrast, when working with the \CodeIn{bdd\_manager} class in Z3 (around 1700 lines of code), \tech begins generation with \CodeIn{bdd}, a subclass of \CodeIn{bdd\_manager}. Algorithm~\ref{algo:algo} enables \tech to partition \CodeIn{bdd\_manager} class and outputs meaningful class invariants (see Section~\ref{sec:z3}).

\subsubsection{Instrumentation}
\label{sec:instrumentation}

\begin{figure}[htp]
\centering
\begin{lstlisting}[language=c++, escapechar=@]
bool AvlTree::empty() { 
  check_invariant();
  auto ret = empty_original();
  check_invariant();
  return ret;
}

bool AvlTree::empty_original() { return n == 0; }
\end{lstlisting}
    \caption{AvlTree Instrumented with invariants}
    \label{fig:avl_instrumentation}
\end{figure}

\begin{figure}[htp]
\begin{lstlisting}[language=c++, escapechar=@]
void AvlTree::check_invariant() {
    std::function<bool(const std::unique_ptr<Node>&)> is_balanced = [&](const std::unique_ptr<Node>& node) -> bool {
        if (!node) return true;
        int left_height = height(node->left);
        int right_height = height(node->right);
        if (std::abs(left_height - right_height) > 1) return false;
        return is_balanced(node->left) && is_balanced(node->right);
    };
    assert(is_balanced(root));

}
\end{lstlisting}
    \caption{Example of a correct AvlTree class invariant
    % \cy{This seems to be a correct one, we may need to use another example}
    }
    \label{fig:avl_correct_inv2}
\end{figure}


\begin{figure}[htp]
\begin{lstlisting}[language=c++, escapechar=@]
void AvlTree::check_invariant() {
    assert(height(root) == get_height(root));
}
\end{lstlisting}
    \caption{Example of an incorrect invariant of AvlTree because there is no get\_height method}
    \label{fig:avl_incorrect}
\end{figure}

To check candidate invariants, each public method is automatically instrumented with a \CodeIn{check\_invariant} call at both the start and end of its implementation, as shown in Figure~\ref{fig:avl_instrumentation}. \tech instruments these invariants to use the compiler to rule out syntactic/type-based errors in the invariants.
Each invariant is implemented as a method call to prevent conflicts with local variables within the two invocations to \CodeIn{check\_invariant}.
To check a specific invariant, the code for the invariant is plugged in as the implementation for the \CodeIn{check\_invariant} function, and assertions are added to check that the invariant holds, as
depicted in Figures~\ref{fig:avl_correct_inv2} and~\ref{fig:avl_incorrect}. This setup ensures that during pruning, described below, whenever a public API call is made, each invariant candidate is automatically checked.



\subsection{Heuristic Pruning}
\label{sec:testing}

As discussed above, the LLM generates test suites for candidates.  \tech wishes to select the suite that is most effective at identifying inaccurate invariants. To select the most suitable test suite, we employ line coverage as a metric. Line coverage is used to select the best test suite because it serves as a straightforward proxy for test suite completeness. The tests with the highest coverage are considered \emph{filtering tests} and are used to prune the candidate invariants.


Notably, when generating tests, \tech focuses on creating valid sequences of API calls to exercise the class under test but does not assert the expected behavior. 
This approach simplifies the process by eliminating the need for a test oracle, which is unnecessary in the \tech framework since the purpose of test generation is to filter invariant candidates, not to test the source program directly.
\shuvendu{why not take the union of all the test suites to get the highest coverage?} \livia{addressed}

Among all generated test suites, \tech compiles and runs each one with the source program, measuring line coverage. The test suite with the highest line coverage is then selected as the \textit{filtering tests} and fixed from this point onward. \tech chooses only one test suite to balance the trade-off between test execution cost plus generation cost \shuvendu{This is not an issue} and test suite completeness. 
\shuvendu{The only reason we can justify a small test suite is that the presence of a large test suite may include spurious tests that may incorrectly prune good invariants. For example, calling a pop() method before calling the push() method may fail some assertions.}
As shown in our experiments in Section~\ref{subsec:correctness}, the current level of test co-generation already raises the pass rate of \textit{filtered invariants} to $100\%$, suggesting that further expansion of the \textit{filtering tests} would provide a limited additional benefit under our benchmark (Section~\ref{sec:benchmark}). More tests may be necessary for a different codebase.

\tech dynamically expands the \textit{filtering tests} only if coverage falls below a specified threshold (default $80\%$). It does not explicitly control the number or size of individual tests but focuses on measuring overall test suite coverage. In the experiment shown in Table~\ref{ds_refine}, each benchmark task’s \textit{filtering tests} includes 5 to 15 individual tests, with each test comprising 5 to 20 lines of code.

These \textit{filtering tests}, which are assumed to contain valid sequences, are then used to identify high-quality invariant candidates, referred to as \textit{filtered invariants}. If an invariant candidate successfully compiles and runs with the \textit{filtering tests}, it is designated a \textit{filtered invariant} and the final output of \tech.
\shuvendu{We use the failures for generated tests as a heuristic as the test may itself be infeasible (violates some implicit preconditions) resulting in a spurious removal. Do we study the impact?}\livia{we did not}


Figure~\ref{fig:avl_correct_inv2} illustrates a correct \textit{filtered invariant}, stating that the height of an \CodeIn{AvlTree} is balanced. In contrast, Figure~\ref{fig:avl_incorrect} shows an incorrect invariant that was filtered out by the \textit{filtering tests} during compilation because it references a \CodeIn{get\_height} method, which is not accessible to the user.
\shuvendu{This should be caught at compile time for C++, unless I am wrong. For Python, this argument holds.}

To filter invariants, \tech compiles and runs candidate invariants with the \textit{filtering tests}, retaining those that do not cause crashes and adding them to the set of \textit{filtered invariants}.


\begin{figure}[htp]
\begin{lstlisting}[language=c++, escapechar=!]
int main() {
    // Test Case 1
    // Basic insertions and traversals
    {
        AvlTree tree;
        tree.insert(10);
        tree.insert(20);
        tree.insert(5);
        tree.in_order_traversal();
        tree.pre_order_traversal();
        tree.post_order_traversal();
    }
    // Test Case 2
    // Checking size, height, and empty status
    {
        AvlTree tree;
        tree.insert(10);
        tree.insert(20);
        tree.insert(5);
        tree.size();
        tree.height();
        tree.empty();
    }
    ... // the rest tests are skipped
}
\end{lstlisting}
    \caption{A test suite generated for AvlTree}
    \label{fig:avl_tests}
\end{figure}


\subsection{Refinement}
\label{sec:refinement}
Invariants that fail at either compilation or runtime are candidates for refinement loops. For such failing invariants, \tech implements a feedback loop by collecting compiler output, error messages, and the results of \textit{filtering tests}, then feeding this information back to the LLM using a dedicated prompt template (Figures~\ref{appendix:prompt_refinement_system}--\ref{appendix:prompt_refinement_user} in Appendix) to generate refined invariants. The system prompt for refinement is fixed, while the user prompt is instantiated with the failing invariant, compiler error messages, the target class’s source code, and the \textit{filtering tests} that caused the failure.

For instance, the GCC error output shown in Figure~\ref{fig:gcc_compiler_error} for the \CodeIn{AvlTree} candidate invariant in Figure~\ref{fig:avl_bst_before} leads to the refined candidate invariant in Figure~\ref{fig:avl_bst_after}. We set the default threshold for refinement loops to 3, balancing the cost of calling LLMs with the benefit of repairing a single invariant; empirically, this number works well, though it may require adjustment for different codebases. If the invariant still fails after 3 refinement attempts, \tech discards it and moves on. Invariants are accepted as \textit{filtered} only after successfully passing all \textit{filtered tests}.
\shuvendu{We report results with only 1 refinement, but we state 3 here.}


\begin{figure}[htp]
\centering
\begin{lstlisting}[language=c++, escapechar=@]
avl_tree.cpp: In lambda function:
avl_tree.cpp:21:16: error: use of 'is_balanced' before deduction of 'auto'
\end{lstlisting}
    \caption{gcc compiler error messages}
    \label{fig:gcc_compiler_error}
\end{figure}
\begin{figure}[htp]
\begin{lstlisting}[language=c++, escapechar=@]
void AvlTree::check_invariant() {
@\CodeBG@   auto is_bst = [&](const std::unique_ptr<Node>& node, const T& min, const T& max) -> bool {
        if (!node) return true;
        if (node->data <= min || node->data >= max) return false;
        return is_bst(node->left, min, node->data) && is_bst(node->right, node->data, max);
    };

    assert(is_bst(root, std::numeric_limits<T>::min(), std::numeric_limits<T>::max()));
}
\end{lstlisting}
    \caption{BST property before refinement: the word \CodeIn{auto} is causing the compiler to complain}
    \label{fig:avl_bst_before}
\end{figure}




\begin{figure}[htp]
\centering
\begin{lstlisting}[language=c++, escapechar=@]
void AvlTree::check_invariant() {
@\CodeBGGreen@  std::function<bool(const std::unique_ptr<Node>&)> is_bst = [&](const std::unique_ptr<Node>& node, const T& min, const T& max) -> bool {
        if (!node) return true;
        if (node->data <= min || node->data >= max) return false;
        return is_bst(node->left, min, node->data) && is_bst(node->right, node->data, max);
    };

    assert(is_bst(root, std::numeric_limits<T>::min(), std::numeric_limits<T>::max()));
}
\end{lstlisting}
    \caption{BST property after refinement: \CodeIn{auto} is changed to explicit declarations. This change resolved type ambiguity, allowing the code to compile successfully.}
    \label{fig:avl_bst_after}
\end{figure}



