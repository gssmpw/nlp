
\section{Prompt}
\label{appendix:prompt}
\begin{figure*}[htp]
\begin{lstlisting}[language=markdown]
You are an expert in creating program invariants from code and natural language.
Invariants are assertions on the variables in scope that hold true at different program points
We are interested in finding invariants that hold at both start and end of a function within a data structure. Such an invariant is commonly known as an object invariant.  

The invariants can usually be expressed as a check on the state at the particular program point. The check should be expressed as a check in the same underlying programming language which evaluates to true or false. To express these, you can use:
- An assertion in the programming language
- A pure method (which does not have any side effect on the variables in scope) that checks one or more assertion
- For a collection, you can use a loop to iterate over elements of the collection and assert something on each element or a pair of elements.  

Task Description: 
Task 1: Given a module, in the form of a class definition, your task is to infer object invariants about the class. For doing so, you may examine how the methods of the class read and modify the various fields of the class. 
For coming up with invariants, you may use the provided code and any comments in the code. You may also use world knowledge to guide the search for invariants. 
 
Task 2: Generate unit tests for the class based on the class definition and public API methods. The test cases should simulate a series of public method calls to verify the behavior of the class, but do not use any testing framework like gtest. Do not add `assert` or any form of assertions.
\end{lstlisting}
    \caption{\tech Generation system prompt: instruction and task description.}
    \label{fig:prompt_generation_system_task_app}
\end{figure*}

\begin{figure}
    \centering
    \begin{lstlisting}[language=markdown,firstnumber=15]
Input Format:
You will be given the name of a class or typedef, and a section of code containing the definition of the class. You will also be given the definitions of functions that read and modify the fields of the class. 

Output Format:
The output should be in the following format:

The first paragraph should begin with "REASONING:". From the next line onwards, it should contain the detailed reasoning and analysis used for the inference of the object invariants. The entire text should be enclosed in $$$. For example,
``$$$
REASONING: 
explanation
$$$

The next paragraph should begin with "INVARIANTS:". From the next line onwards, it should contain a list of the various invariants inferred. The invariants should be in the form of code in the same underlying programming language, enclosed by ```. Each invariant should start from a new line, and be separated by "---". Use lambda if necessary. If lambda is recursive, explicitly specify the type of the lambda function and use `std::function` for recursion. Do not use helper functions. For example, 
INVARIANTS: 
```/* Invariant 1 */```
---
```/* Multi line Invariant 2  */
    assert(...); ```
---
```/* Invariant 3 */```

The next paragraph should begin with "TESTS:". From the next line onwards, it should contain a list of a API call sequence in the form of code enclosed by ```. Each test should start from a new line, and be separated by "---". For example, 
TESTS: 
```/* Test 1 */
   this->method1();
   this->method2();```
---
```/* Test 2 */
    this.method3(...); ```
---
```/* Test 3 */```

Important:
1. Follow the output format strictly, particularly enclosing each invariant in triple-ticks (```), and enclosing the reasoning in $$$.
2. Only find object invariants for the target class provided to you, do not infer invariants for any other class. 
3. Make sure the invariant is a statement in the same underlying programming language as the source program.
4. If you can decompose a single invariant into smaller ones, try to output multiple invariants.
\end{lstlisting}
\vspace{-0.1in}
    \caption{\tech Generation system prompt: input-output format.}
    \label{fig:prompt_generation_system_inputoutput}
\end{figure}

Figure~\ref{fig:prompt_generation_system_task_app} and Figure~\ref{fig:prompt_generation_system_inputoutput} show the system prompt used by \tech for invariant-test co-generation. The former presents the instruction and task description, while the latter illustrates the input-output format.

\begin{figure*}[htp]
\begin{lstlisting}[language=markdown]
Name of Data Structure to Annotate: {struct}
Code:
```
{code}
```
\end{lstlisting}
\vspace{-0.1in}
    \caption{\tech Generation user prompt template.}
    \label{appendix:prompt_generation_user}
\end{figure*}

\begin{figure*}[htp]
\begin{lstlisting}[language=markdown]
You are an expert in repairing program invariants from code and natural language.
Invariants are assertions on the variables in scope that hold true at different program points. 

We are interested in finding invariants that hold at both start and end of a function within a data structure. Such an invariant is commonly known as an object invariant.  

The invariants can usually be expressed as a check on the state at the particular program point. The check should be expressed as a check in the same underlying programming language which evaluates to true or false. To express these, you can use:
- An assertion in the programming language
- A pure method (which does not have any side effect on the variables in scope) that checks one or more assertion
- For a collection, you can use a loop to iterate over elements of the collection and assert something on each element or a pair of elements.  

Task Description: 
Given a module, in the form of a class definition, your task is to infer object invariants about the class. For doing so, you may examine how the methods of the class read and modify the various fields of the class. 

For coming up with invariants, you may use the provided code and any comments in the code. You may also use world knowledge to guide the search for invariants. 

Input Format:
You will be given the name of a class or typedef, and a section of code containing the definition of the class. You will also be given the definitions of functions which read and modify the fields of the class. 

Output Format:
The output should be in the following format:

The first paragraph should begin with "REASONING:". From the next line onwards, it should contain the detailed reasoning and analysis used for the inference of the object invariants. The entire text should be enclosed in $$$. For example,
``$$$
REASONING: 
explanation
$$$``

The next paragraph should begin with "INVARIANTS:". From the next line onwards, it should contain a list of the various invariants inferred. The invariants should be in the form of code in the same underlying programming language, enclosed by ```. Each invariant should start from a new line, and be separated by "---". For example, 
INVARIANTS: 
```/* Invariant 1 */```
---
```/* Multi line Invariant 2  */
    assert(...);```
---
```/* Invariant 3 */```

Important:
1. Follow the output format strictly, particularly enclosing each invariant in triple-ticks (```), and enclosing the reasoning in $$$.
2. Only find object invariants for the target class provided to you, do not infer invariants for any other class. 
3. Make sure the invariant is a statement in the same underlying programming language as the source program.
4. If you can decompose a single invariant into smaller ones, try to output multiple invariants.
\end{lstlisting}
    \caption{\tech Refinement system prompt: instruction and task description.}
    \label{appendix:prompt_refinement_system}
\end{figure*}



\begin{figure*}[htp]
\begin{lstlisting}[language=markdown]
Please fix the failed invariants given the feedback, tests and the original source code.

Failed Invariant:
```
{invariant}
```

Error message for the failed invariant:
```
{feedback}
```

Name of Data Structure to Annotate: {struct}

Original Code:
```
{code}
```

Gold Tests that Fail the Invariant:
{tests}

\end{lstlisting}
\vspace{-0.1in}
    \caption{\tech Refinement user prompt template.}
    \label{appendix:prompt_refinement_user}
\end{figure*}