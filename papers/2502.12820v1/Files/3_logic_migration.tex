
\section{Hybrid Cross-Chain Smart Contract Deployment Protocol}

% We propose an on-/off-chain Hybrid Cross-Chain Smart Contract Deployment Protocol to efficiently and securely deploy smart contracts across chains. In this section, we will provide a detailed explanation of the design of the protocol.

\subsection{Logic-State Decoupling}
\label{subsec:LSD}

To efficiently perform CCSCI, we need to deploy the logic of the invoked contracts to the same execution chain for efficient integrated execution. 
Existing contracts often contain both logic and state, and directly cloning such contracts would result in high gas costs and additional state storage overhead on the execution chain. 
Therefore, we design a set of Logic-State Decoupling (LSD) Guidelines to guide the developers to decouple existing contracts into logic execution contracts and state storage contracts. 
During cross-chain deployment, only the logic contracts need to be cloned, which reduces gas costs. 
Developers can follow these guidelines to develop new contracts with separated logic and state or upgrade existing contracts by decoupling them. 
We now provide a detailed explanation of the LSD Guidelines.
Moreover, a simple example illustrating the LSD is provided in Section \ref{codeex}.

\vspace{3pt}
\noindent
\textbf{State Contract.}
According to the LSD Guidelines, the decoupled state contract first includes all the \emph{variables} (representing states) from the original contract, as well as all the \emph{view functions} that read the contract's state. 
Since view functions are read-only and do not generate transactions, they do not affect cross-chain execution. 
Additionally, the state contract contains \emph{functions for locking and updating} the contract state, as cross-chain invocations require locking and updating states. 
The state contract should also contain \emph{functions that call the logic contract} in order to interact normally with the logic contract.
% To support normal on-chain calls, the state contract should also include functions that invoke the logic contract to execute the DApp's regular functionality.

\vspace{3pt}
\noindent
\textbf{Logic Contract.}
In the logic contract, no variables are stored. 
It only contains the functions that implement the original contract's \emph{execution logic}. 
These functions are called by the state contract to carry out the dApp's logic operations. 
When the state contract calls these functions, it passes all necessary state data (variables), and after the functions complete execution, the results are returned to the state contract. 
In our protocol, only the logic contract needs to be cloned, which reduces gas costs during cross-chain deployment.

\vspace{3pt}
\noindent
\emph{Remarks.}
Our protocol also supports existing smart contracts, even if they are not decoupled into logic and state. 
However, in such cases, the cross-chain deployment process will incur higher gas costs. 
% Furthermore, although the contracts migrated to the execution chain do not maintain contract states, they will be passively updated during each cross-chain call, leading to additional state storage costs.
In this case, the contracts deployed to the execution chain do not actively maintain their own state. 
Instead, they passively update their state during each cross-chain invocation. 
% This approach reduces the cost associated with active state updates.
The discussion related to developers' learning costs is given in Section \ref{disscussion}.



\vspace{3pt}
\subsubsection{Logic-State Decoupling Example}
\label{codeex}

We now give a sample of logic-state decoupling. In the following code~\ref{ex}, after applying logic-state decoupling, the original Hotel contract is split into two separate contracts: the logic contract \texttt{LHotel} and the state contract \texttt{SHotel}. The \texttt{LHotel} contract contains no state variables and only includes the \texttt{book()} function, which implements the hotel reservation functionality. Since there are no variables within the \texttt{LHotel} contract, the \texttt{book()} function must take all necessary parameters as inputs.

On the other hand, the \texttt{SHotel} contract retains all the variables from the original Hotel contract and introduces an additional address variable, \texttt{addr\_lhotel}, which records the address of the \texttt{LHotel} contract. In the \texttt{book()} function of the \texttt{SHotel} contract, no reservation logic is implemented directly; instead, it calls the \texttt{book()} function from \texttt{LHotel} using the \texttt{addr\_lhotel} parameter to execute the hotel reservation functionality.

By decoupling the logic and state in this way, only the \texttt{LHotel} contract needs to be cloned. 
% during logic updates. 
Since \texttt{LHotel} contains no state variables, this approach significantly reduces gas consumption during the cross-chain clone and deployment process.

\begin{lstlisting}[language=Solidity, caption={Pseudocode of Hotel Logic-State Decoupling}, label={ex}]
contract Hotel{
    int256 price;
    int256 remain;
    mapping (address => int256) accounts;
    function getPrice() public view returns(uint256); 
    function getRemain() public view returns(uint256); 
    function book(address user_addr, uint256 num) public returns(uint256); 
    function LockState(bytes[] memory args) public returns();
    function UpdateSteate(bytes[] memory args) public returns();

contract LHotel{
    function book(uint256 price, uint256 remain, uint256 num) public returns(uint256)
}

contract SHotel{
    int256 price;
    int256 remain;
    address addr_lhotel;
    mapping (address => int256) accounts;
    function getPrice() public view returns(uint256); 
    function getRemain() public view returns(uint256); 
    function LockState(bytes[] memory args) public returns();
    function UpdateSteate(bytes[] memory args) public returns();
    function book(address user_addr, uint256 num) public returns(uint256);

\end{lstlisting}




\begin{figure}[t]
    \centering
    % 第一个子图
    \begin{subfigure}[b]{0.525\textwidth}
        \centering
        \includegraphics[width=\textwidth]{Figures/migration2.png}  % 使用你的图片路径
        \vspace{-10pt}
        \caption{Off-chain clone and deployment}
        \label{migration}
    \end{subfigure}
     % 第二个子图
    \begin{subfigure}[b]{0.525\textwidth}
        \centering
        \includegraphics[width=\textwidth]{Figures/verification2.png}  % 使用你的图片路径
        \vspace{-10pt}
        \caption{On-chain verification}
        \label{verifaction}  % 子图标签，用于引用
    \end{subfigure}
    \vspace{-18pt}
    \caption{Hybrid Cross-Chain Smart Contract Deployment Protocol.}
    \label{MandV}  % 整体图的标签
\end{figure}



\subsection{Off-Chain Clone and Deployment}
\label{subsec:migration}

Transmitting contract bytecode on-chain (via contract event) requires a significant amount of gas.
% ensures security, but it requires a significant amount of gas and incurs delays due to the need for blockchain consensus. 
To improve the efficiency of cross-chain logic deployment and reduce gas consumption, we propose \emph{transferring the contract bytecode via an off-chain solution}. 
The off-chain clone and deployment consists of two phases: the preparation phase and the clone phase. 
% In the following, we will explain the off-chain migration process through these two phases. 
The main process is shown in Figure ~\ref{migration}.

\vspace{3pt}
\noindent
\textbf{Preparation.}
In this phase, the cross-chain dApp provider needs to obtain the call tree of smart contracts and determine which logic contracts need to be cloned.
This can be achieved by using some static analysis tools \cite{feist2019slither} and other methods, similar to existing works \cite{li2022jenga, robinson2021general, chen2024atomci}.
% can use static analysis tools, such as Slither~\cite{feist2019slither}, to obtain the call tree of smart contracts and determine which logic contracts need to be migrated. 
After this, the developer can choose a blockchain to deploy the cross-chain dApp. 
It is important to note that we offer developers a high degree of flexibility: 
They can select any blockchain according to their preference. 
To reduce costs, they may also choose a blockchain that already contains some of the invoked logic contracts. 
Once the selection is made, the developer sends a transaction to invoke the bridging contract on the chosen chain.
The bridging contract then triggers an event to notify the relayers to initiate the cross-chain deployment.
% which triggers an event for contract migration. 
The event includes the ID of the invoked chain and the addresses of the logic contracts $Addr_{\text{L}}$ to be cloned on the invoked chain. 
This concludes the preparation phase.

\vspace{3pt}
\noindent
\textbf{Clone.}
After the event is triggered, relayers will detect the event and use the \texttt{getcode()} function from the bridging contract on the invoked chain to obtain the bytecode of the contract that needs to be cloned. 
This process is an \emph{off-chain read-only inquiry and, therefore, does not consume gas.}
Subsequently, the relayers will obtain the ABI file which defines the contract interface. 
The relayers will then deploy the contract to the execution chain. 
Once a relayer completes the redeployment, it registers the address of the cloned logic contract $Addr'_{\text{L}}$, through the bridging contract on the execution chain, marking the end of the clone phase.

\vspace{3pt}
\noindent
\emph{Remarks.}
For the cross-chain reliability of the protocol, multiple relayers perform the clone process after detecting the bridging contract's event. 
Therefore, even if some relayers do not respond to the event, other relayers will ultimately complete the contract clone and deployment.
Once one relayer completes the deployment, the bridging contract will trigger an event to stop the others, ensuring that the logic contract will not be deployed multiple times.

\subsection{On-Chain Verification}
\label{subsec:verification}

Although off-chain clone and deployment can achieve efficient cross-chain logic deployment, it does not guarantee security as there may be malicious relayers present in the system.
A malicious relayer could potentially modify the contract bytecode or deploy a wrong contract. 
To ensure verifiability and security during the off-chain clone and deployment process,
% of the cloned and deployed logic contract, 
% we propose the on-chain cross-chain verification scheme to confirm the correctness of the cloned and deployed logic contract. 
we propose the on-chain cross-chain verification scheme to \emph{compare the cloned logic contract with the original contract and verify its correctness}.
The on-chain verification process is shown in Figure ~\ref{verifaction}.

After the cross-chain deployment is completed, the cross-chain dApp provider can initiate cross-chain verification on the execution chain by calling the \texttt{Verification()} function of the bridging contract. 
The bridging contract will search the cloned contract bytecode of address $Addr'_{\text{L}}$, and calculate the hash of the bytecode. 
Then the bridging contract triggers an event includes the hash computation result. 
% The blockchain node will generate the Merkle proof~\cite{merkle1987} to verify the validity of the transaction.
The relayers are responsible for transmitting this information (a cross-chain transaction) along with its Merkle proof \cite{merkle1987} to the invoked chain. 
In the invoked chain, the Merkle proof with the cross-chain transaction is first verified to ensure the result has already reached consensus on the execution chain. 
The bridging contract then searches the corresponding local contract bytecode based on the address $Addr_{\text{L}}$, and calculates the hash of the bytecode.
Then, the bridging contract will verify whether it matches the hash transmitted across the chain. 
% calculates the hash of the local contract bytecode based on the address $Addr_{\text{L}}$ and verifies whether it matches the hash transmitted across the chain. 
The result of the verification is then returned.

If the verification is successful, the cloned contract will be marked as verified and allowed for subsequent cross-chain invocations, and the relayer that performed the cross-chain deployment will be rewarded. 
If the verification fails, the relayer will be penalized, and the off-chain clone and deployment process will be restart. 

\noindent
\emph{Remarks.}
For the reliability of the cross-chain protocol, multiple relayers could transmit the same cross-chain transaction. 
However, the bridging contracts will deduplicate identical transactions from multiple relayers to avoid multiple executions on-chain.
This process also applies in the subsequent integrated execution protocol.