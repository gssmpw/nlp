% 在Hybrid Cross-Chain Smart Contract Deployment Protocol 协议中，relayer对需要被跨链调用intra-chain DApp的逻辑合约进行了迁移。relayer在bridging合约中通过已经部署的合约地址获得其字节码，合约的 API 文件用来定义与合约交互的接口，通常在智能合约部署时就会公开，因此可以直接获取。通过 API 文件以及链上合约的字节码，relayer可以重新在其他区块链上部署该合约。在IntegratedX系统中，Hybrid Cross-Chain Smart Contract Deployment Protocol 协议内的任意relayer都可以进行迁移操作，然而这些relayer并不一定是可信任的，这就导致了可能有恶意的relayer在迁移过程中故意更改字节码造成安全性漏洞，因此我们通过on-chain verification进行链上合约验证来保证字节码没有被更改。
% 我们设计使用bridging合约比较迁移后合约的字节码哈希值和原合约的字节码哈希值。合约字节码哈希值可以通过智能合约的链内调用获得，并且将会由relayer传输到intra-chain DApp所在的链上，由于存在至少一个可以运行的relayer，该哈希值最终会被传输到目标链上并由目标链进行验证并将验证结果回传。由于区块链数据的不可篡改性，使用链上智能合约验证可以保证验证结果无法被更改。只有通过验证的合约才会完成完整的登记流程并可以被跨链应用链内调用。由于区块链数据具有可追溯性，因此对于验证通过的合约，进行该次迁移的relayer将会获得奖励，如果验证失败，将由新的relayer进行迁移，并对迁移失败的relayre进行惩罚。惩罚措施包含建立黑名单机制，一定次数的验证失败将无法进行迁移且此次迁移的费用将会由relayer承担。通过这样的on-chain verification，可以保证逻辑合约迁移后的正确性。由于至少存在一个relayer可以正常工作，因此该逻辑合约最后一定会被成功迁移。
\section{Security Analysis}\label{security_analysis}
% In this section, we analyzed how \texttt{IntegrateX} can safely and efficiently perform complex cross-chain calls.

\subsection{Security in Hybrid Cross-Chain Smart Contract Deployment Protocol}

\begin{theorem}
The Hybrid Cross-Chain Smart Contract Deployment Protocol ensures reliability, verifiability, and consistency, if the proportion of Byzantine nodes in each blockchain is less than its fault tolerance threshold, and at least one functional relayer is present.
% As long as the number of Byzantine nodes in each blockchain remains within the Byzantine fault tolerance limits, and at least one functional relayer is present, the reliability, verifiability, and consistency of the Hybrid Cross-Chain Smart Contract Deployment Protocol can thus be assured.
\end{theorem}

\begin{proof}
\noindent
\textbf{Reliability. }
The Hybrid Cross-Chain Smart Contract Deployment Protocol ensures reliability, meaning that when an execution chain issues a request for cross-chain deployment of a contract, the requested contract will eventually be deployed to the execution chain. 
Within the Hybrid Cross-Chain Smart Contract Deployment Protocol, multiple relayers listen for such requests. Even if malicious relayers intentionally ignore the requests, assuming that at least one functional relayer exists, this relayer will ultimately handle the logic clone and deployment of the requested contract. Thus, even in the worst-case scenario, the protocol ensures that the contract will be successfully deployed to the execution chain.

\vspace{3pt}
\noindent
\textbf{Verifiability. }
The Hybrid Cross-Chain Smart Contract Deployment Protocol ensures verifiability, meaning that both the execution chain and the invoked chain are able to verify the cross-chain transactions transmitted by the relayers. 
Additionally, both chains can verify the hash values of the contract bytecode before and after the cross-chain clone and deployment to ensure that the contract has been deployed correctly. 

In the Hybrid Cross-Chain Smart Contract Deployment Protocol, multiple relayers listen to the request and relay the messages. 
% However, relayers are not responsible for verifying the cross-chain transactions. 
% Instead, 
The invoked chain (bridging contract) validates the authenticity of the transactions using the Merkle proof attached with the cross-chain transactions, thereby preventing the relayers from altering the cross-chain data. 
By parsing the transactions, the invoked chain can obtain the bytecode hash of the cloned contract and compare it with the bytecode hash of the original contract on the chain to ensure the correctness of the cross-chain deployment. 
Additionally, the nonce value associated with each transaction prevents malicious replay attacks.

\vspace{3pt}
\noindent
\textbf{Consistency. }
The Hybrid Cross-Chain Smart Contract Deployment Protocol ensures consistency, meaning that during the off-chain clone and deployment as well as the on-chain verification process, both the execution chain and the invoked chain reach agreement on the outcome of the cross-chain requests.
% meaning that the agreement between the execution chain and the invoked chain on the outcome of the cross-chain request during off-chain clone and deployment and on-chain verification. 
In the Hybrid Cross-Chain Smart Contract Deployment Protocol, the proportion of malicious nodes on both the execution chain and the invoked chain remains within the fault tolerance threshold.
Moreover, the protocol requires to wait until consensus on one chain is finalized (or highly likely to be finalized) before committing the cross-chain transaction to another chain. 
% both the execution chain and the invoked chain maintain within the Byzantine fault tolerance limits. 
As a result, even in the presence of Byzantine nodes, each chain can still achieve consensus on cross-chain transactions and finalize them, ensuring that consistency is not undermined by malicious nodes. 
This guarantees that the outcomes of cross-chain requests remain consistent.
\end{proof}

\subsection{Security in Cross-Chain Smart Contract Integrated Execution Protocol}
%Cross-Chain Smart Contract Integrated Execution Protocol实现了跨链调用的原子执行，IntegrateX系统通过类似于 2PC 的状态同步机制对invoked的合约进行状态锁定和更新，在cross-chain应用中当用户在execution chain上的调用cross-chain DApp合约后，bridging合约将向所有invoked chain上的invoked合约发送状态请求，如果任何一个invoked合约未能锁定状态，将会返回失败信息，bridging合约将会取消本次调用并且发送跨链请求解锁所有其他合约，被锁定的合约将被解锁，而当尚未完成锁定的合约先接收到了解锁请求，将会在忽略后续接收到的该次锁定请求，以此保证合约状态锁定的一致性。
% 当所有被请求的合约都成功锁定状态后，cross-chain DApp合约将在execution chain上进行集成执行并将结果返回给所有的invoked合约，invoked 合约的新的状态将会首先返回给invoked chain上的bridging合约，并由bridging合约返回状态更新成功信息，如果任意一条invoked chain上的状态更新失败，所有链上的bridging合约都会丢弃更新的状态，此次跨链调用将失败，只有所有invoked chain上都完成了状态更新，cross-chain DApp合约才会输出最终结果，invoked合约解锁状态并从本链的bridging合约进行状态更新，标志着此次调用成功，由此保证完整的跨链调用原子性。
\begin{theorem}
The Hybrid Cross-Chain Smart Contract Integrated Execution Protocol ensures overall atomicity, reliability, verifiability, and consistency, if the proportion of Byzantine nodes in each blockchain is less than its fault tolerance threshold, and at least one functional relayer is present.
% As long as the number of Byzantine nodes in each blockchain remains within the Byzantine fault tolerance limits, and at least one functional relayer is present, the atomicity, reliability, verifiability, and consistency of the Cross-Chain Smart Contract Integrated Execution Protocol can thus be assured.
\end{theorem}

\begin{proof}
\noindent
\textbf{Overall Atomicity. }
The Cross-Chain Smart Contract Integrated Execution Protocol guarantees overall atomicity, which means that in the selected CCSCI process, state changes on both the execution chain and the invoked chain either all succeed or all fail, preventing any situation where one chain's state changes while the other does not. 
We employ the atomic integrated execution mechanism, similar to the 2PC scheme. 
For one cross-chain dApp, during this process, all the states required by the invocation on the invoked chains will be locked. 
If any contract has already been locked by another invocation, this invocation will fail, and all other invoked contracts will be unlocked. 
If the execution chain obtains all the necessary states but the execution fails due to insufficient gas or other reasons, the execution will be aborted, and all related locked contracts will be unlocked without any state changes. 
Furthermore, the protocol incorporates a timeout scheme: 
If any of the invoked chains fails to return the required state within the specified time frame by dApp, or if the execution transaction on the execution chain fails to complete within the specified time limit, the execution chain will abort the invocation and unlock all related contract states, ignoring any subsequent state responses from the invoked chains. 
% In cases where an invoked chain receives a lock request after receiving an unlock request, it will also ignore the lock request, ensuring that all invoked contract states are either locked or unlocked simultaneously. 
As a result, only when the execution chain has successfully acquired all required states and completed execution will it issue state updates to all related invoked chains, thereby ensuring the atomicity of the entire CCSCI process.

\vspace{3pt}
\noindent
\textbf{Reliability. }
The Cross-Chain Smart Contract Integrated Execution Protocol ensures reliability, which means that when an execution chain initiates a CCSCI request, the invoked chain will eventually receive the cross-chain transaction, and the state returned by the invoked chain will likewise be received by the execution chain. 
In the Cross-Chain Smart Contract Integrated Execution Protocol, multiple relayers monitor CCSCI requests. 
Even in the presence of malicious relayers who deliberately fail to respond to the request, the assumption of at least one functional relayer ensures that, in the worst-case scenario, this relayer will relay the cross-chain transaction to the invoked chain, ensuring that the transaction is eventually received. 
Similarly, even in the worst-case scenario, at least one relayer will transmit the state returned by the invoked chain back to the execution chain, thereby guaranteeing the reliability of the CCSCI process.

\vspace{3pt}
\noindent
\textbf{Verifiability. }
The Cross-Chain Smart Contract Integrated Execution Protocol ensures verifiability, which means the ability of the invoked chain to verify the authenticity of cross-chain transactions transmitted by relayers from the execution chain, while the execution chain can also verify the transactions returned by the invoked chain. 
In this protocol, multiple relayers listen for the request and relay messages.
% , but relayers themselves are not responsible for verifying the cross-chain transactions. 
Both the execution chain and the invoked chain can independently validate the authenticity of the cross-chain transactions using the Merkle proof attached with the transactions. 
Additionally, the use of transaction nonce values prevents malicious replay attacks, ensuring the integrity of the cross-chain interaction.

\vspace{3pt}
\noindent
\textbf{Consistency. }
The Cross-Chain Smart Contract Integrated Execution Protocol guarantees consistency, ensuring that both the execution chain and the invoked chain agree on the result of the requested operation during a cross-chain smart contract invocation. 
In this protocol, the proportion of malicious nodes on both chains remains within the fault tolerance threshold, allowing consensus to be achieved even if there exist Byzantine nodes. 
Additionally, the protocol requires waiting until consensus on one chain has been finalized before committing the cross-chain transaction to the other chain.
Therefore, cross-chain transactions on the blockchain cannot be maliciously altered, ensuring that both the execution chain and the invoked chain reach a unified agreement on the outcome of cross-chain operations.
\end{proof}


% \subsection{Efficiency Between \texttt{IntegrateX} and GPACT}
% %在\texttt{IntegrateX}中通过迁移合约逻辑将跨链调用转换为链内调用可以提高调用效率，因为通过集成执行的方式，合约的状态将会被同步锁定，提高了不同invoked chain上对合约状态并行处理的效率，从而减少了链式调用的等待时间，从而达到减少整体跨链调用latency的目的。考虑在GPACT协议agency应用的调用过程，如图所示。
% %在GPACT中进行跨链调用的过程中，整个跨链调用过程是一个串联调用过程，由于一次跨链调用需要发送receipt来确定信息是否已经送达，因此一次跨链通信时间至少需要2个区块时间，分别为接收方获得跨链信息所需的1个区块时间和发送方确认receipt所需的1个区块时间。在GPACT中跨链调用必须从调用树的根节点合约进行状态锁定，并在到达叶子节点合约时遵从叶子节点到根节点的执行顺序进行执行，假设调用树的深度为d，则此过程需要2d次信息传递，在执行结束后的更新合约状态则需要进行1次跨链信息传递，因此总共需要2d+1次信息传递，即4d+2个区块时间，考虑在调用根节点合约时还需要一个区块时间处理该交易，因此总共需要4d+3个区块时间。在agency应用中，调用树的深度为2，因此需要进行5次跨链信息传递 ，总共需要11个区块时间。
% In \texttt{IntegrateX}, by migrating contract logic, cross-chain calls can be converted into intra-chain calls, which improves call efficiency. This is because, through integrated execution, contract states are synchronously locked, enhancing the efficiency of parallel processing of contract states on different invoked chains. This reduces the waiting time associated with chained calls, ultimately lowering the overall latency of cross-chain calls. Consider the call process in the agency application under the GPACT protocol, as illustrated in Fig. \ref{gpact}.
% \begin{figure}[htbp]
%     \centering
%     \includegraphics[width=0.35\textwidth]{Figures/GPACT_process.png}
%     \caption{The process of the agency application in the GPACT protocol.}
%     \label{gpact}
% \end{figure} 

% In GPACT, the cross-chain call process is sequential. Since each cross-chain call requires sending a receipt to confirm whether the information has been delivered, a single cross-chain communication requires at least 2 block times: 1 block time for the recipient to receive the cross-chain information and 1 block time for the sender to confirm the receipt. In GPACT, cross-chain calls must begin by locking the state at the root contract of the call tree, and the execution follows the sequence from the leaf node contract back to the root node contract. Assuming the depth of the call tree is $d$, this process requires $2d$ transmissions of information. After the execution, updating the contract state requires an additional cross-chain transmission, making a total of $2d+1$ transmissions, which corresponds to $4d+2$ block times. Considering that processing the transaction at the root contract also requires 1 block time, the total time required is $4d+3$ block times. In the agency application, where the depth of the call tree is 2, 5 cross-chain transmissions are needed, resulting in a total of 11 block times.

% %在\texttt{IntegrateX}中进行跨链调用的过程中，整个跨链调用过程是一个并行调用过程，如图所示。在\texttt{IntegrateX}中，跨链调用的调用树的根节点合约将同时对所有调用树中的其他节点合约发起状态锁定请求，并在获得所有其他节点合约状态后在本链进行integrated execution，并在执行结束后同时更新其他节点合约的状态。假设调用树的深度为d，则锁定和获取其他合约状态需要2次信息传递，在执行结束后的更新合约状态则需要进行1次跨链信息传递，因此总共需要3次信息传递，即6个区块时间，考虑在调用根节点合约时还需要一个区块时间处理该交易，因此总共需要7个区块时间，是一个常数，与调用树深度无关。
% In \texttt{IntegrateX}, the cross-chain call process is parallel, as illustrated in Fig. \ref{IntegrateX}. In \texttt{IntegrateX}, the root contract of the call tree simultaneously sends state lock requests to all other node contracts in the call tree. After obtaining the states of all other node contracts, integrated execution is performed on the same chain, and after execution, the states of the other node contracts are updated simultaneously. Assuming the depth of the call tree is $d$, locking and obtaining the states of other contracts require 2 transmissions of information. After execution, updating the contract states requires an additional cross-chain transmission, making a total of 3 transmissions, corresponding to 6 block times. Considering that processing the transaction at the root contract requires 1 block time, the total time needed is 7 block times, which is a constant and independent of the depth of the call tree.
% \begin{figure}[htbp]
%     \centering
%     \includegraphics[width=0.35\textwidth]{Figures/IntegrateX_process.png}
%     \caption{The process of the agency application in the \texttt{IntegrateX} protocol.}
%     \label{IntegrateX}
% \end{figure}

% %在agency应用中，\texttt{IntegrateX}协议完整跨链调用只需要7个区块时间，而GPACT需要11个区块时间，由于处理根节点合约的调用并不需要一个完整的区块时间，因此\texttt{IntegrateX}的最短时间将会介于6-7个区块时间，而GPACT则是介于4d+2-4d+3个区块时间。考虑到这只是一个调用树深度为2跨链调用，在 INtegratedX 中，跨链等待时间并不会随着调用树深度的增加而增大而在GPACT中跨链调用的latency会随着调用树的深度增加而增大。因此随着调用树的深度增加，\texttt{IntegrateX}将会减少更多的时间。然而在实际场景中，由于存在网络波动，跨链信息传递的发送和接收并不能保证一定会在一个区块时间内完成，因此\texttt{IntegrateX}和GPACT所需要的区块时间将会大于最短区块时间。
% In the agency application, the \texttt{IntegrateX} protocol requires only 7 block times for a complete cross-chain call, whereas GPACT requires 11 block times. Since processing the root contract's call does not necessarily require a full block time, the minimum time for \texttt{IntegrateX} will range between 6 to 7 block times, while for GPACT, it will range between $4d+2$ to $4d+3$ block times. Considering that this example is a cross-chain call with a call tree depth of 2, in \texttt{IntegrateX}, the cross-chain waiting time does not increase with the depth of the call tree, whereas in GPACT, the latency of cross-chain calls increases with the depth of the call tree. Therefore, as the depth of the call tree increases, \texttt{IntegrateX} will save more time. However, in real-world scenarios, due to network fluctuations, the transmission and reception of cross-chain information cannot always be guaranteed to complete within a single block time. Consequently, the actual block time required for \texttt{IntegrateX} and GPACT will be greater than the minimum block time.
