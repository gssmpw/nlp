\section{Cross-Chain Smart Contract Integrated Execution Protocol}

% To enhance concurrency and reduce overhead
% of CCSCI while ensuring atomicity. We propose
% a Cross-Chain Smart Contract Integrated Execution Protocol. This protocol ensures high efficiency and atomicity throughout the entire call process through the Three-Phase Integrated Execution mechanism. In addition, we have incorporated finer transaction aggregation mechanisms and  granularity lock within the protocol to further enhance the efficiency of the \texttt{IntegrateX} system in complex cross-chain smart contract call scenarios.

\subsection{Atomic Integrated Execution}
\label{subsec:execution}

To efficiently and atomically execute complex CCSCI, we propose an atomic integrated execution scheme. 
As all the invoked logic has been migrated onto the execution chain, the atomic integrated execution does not need multiple rounds of cross-chain execution when handling CCSCI.
This enables all the logic to be executed within a single transaction, enhancing the efficiency of CCSCI. 
Moreover, to ensure overall atomicity for a series of CCSCI, we employ a state synchronization mechanism based on the Two-Phase Commit protocol~\cite{lampson1993twopc}. 
This process locks the relevant states across the involved chains, transmits the states to the chain responsible for integrated execution, and then returns the states to the respective chains to unlock and update them after the execution is completed. 
The entire atomic integrated execution consists Locking, Integrated Execution and Updating, which is shown in the Figure~\ref{ta}.

\vspace{3pt}
\noindent
\textbf{Locking. }
The Locking process locks all the required invoked contract states on the invoked chain.
The cross-chain dApp provider can obtain all the required state on the call tree beforehand via tools such as static analysis \cite{feist2019slither}.
Based on this information, a user sends a transaction via the cross-chain dApp to invoke the cross-chain dApp contract. 
% During this process, a user first sends a transaction to the cross-chain dApp contract. 
% the dApp contract can obtain all the required state on the call tree. 
The cross-chain dApp contract then calls the bridging contract to issue an event to lock the relevant states on the invoked chains.
% will issue an event to lock the relevant states on the invoked chain through the bridging contract. 
When relayers detect the event, it will transfer this message (i.e., cross-chain transaction with Merkle proof) to each invoked chain. 
The bridging contract on the invoked chain will verify the authenticity of the cross-chain though calculating the Merkle proof of the transaction and invoke the \texttt{LockState()} function of each invoked contract. 
Once the bridging contract has successfully locked the state and retrieved the required contract states, it will trigger an event to return the states. 
After the relayers detect the event, they will transmit these states via cross-chain transactions to the execution chain. 
After the execution chain's bridging contract verifies the authenticity of the transactions via the Merkle proof, it will return the states to the dApp.
Once all requested states are returned from individual invoked chains, the Locking process ends, and these states are used as inputs for the Integrated Execution.

\vspace{3pt}
\noindent
\textbf{Integrated Execution. }
The Integrate Execution process executes the entire CCSCI logic on the execution chain.
Cross-chain dApp contracts on the execution chain use the requested state values as inputs to perform the full call tree execution. 
Since all contracts required for the cross-chain invocation have completed logic migration and have been verified already, the integrated execution can be completed within a single transaction on the execution chain. 
The cross-chain dApp contract records the output results of each invoked contract during the Integrated Execution, allowing for state updates of the invoked contracts on other chains after the execution is completed. 
Once execution is complete, the Integrated Execution ends and transitions to the Updating process.

\vspace{3pt}
\noindent
\textbf{Updating. }
The Updating process unlocks and updates all the invoked contract states on the invoked chains.
After Integrated Execution is completed on the execution chain, the cross-chain dApp contract triggers an event to update the result via bridging contract. 
The relayers will distribute the result to the invoked chains. 
The bridging contract on each invoked chain verifies the Merkle proof of the cross-chain transaction and 
then invokes the \texttt{UpdateState()} function of each invoked contract, which will unlock and update the states of the invoked contracts.

\vspace{3pt}
\noindent
\emph{Remarks:}
\textbf{\emph{Rollback.}}
During the Atomic Integrated Execution, state rollback may occur due to failure in locking the state or execution failure. 
The invoked state might already be locked by another cross-chain invocation, which causes the failure to lock the invoked state. 
In this case, the bridging contract on the execution chain will initiate a new event to unlock all associated contracts that have already been locked and returned in this cross-chain invocation. 
For the contracts that have not yet completed the locking process, the event will cancel the lock attempt, thereby ensuring overall atomicity.
The execution might also fail, due to the reason such as insufficient gas fee or insufficient states.
% In the case of execution failure, 
% if the obtained states are insufficient to complete the cross-chain call, the call will fail. 
In this case, the bridging contract on the execution chain will discard the obtained states and initiate a cross-chain event to unlock all locked contracts, thus ensuring all invoked contracts are either fully locked or not locked at all.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.51\textwidth]{Figures/3PIE1.png}
    \vspace{-18pt}
    \caption{The CCSCI process in sequential invocation (left) and in \texttt{IntegrateX}'s Cross-Chain Smart Contract Integrated
Execution Protocol (right).}
    % An illustration of CCSCI process of sequential invocation and invocation in IntegrateX.}
    \label{ta}
     
\end{figure} 

% \noindent
\textbf{\emph{Timeout.}}
Additionally, to prevent the invoked contract state from being locked for an extended period, a design of timeout will be determined by the dApp developer within the application and managed by the execution chain. 
For transactions that time out, such as when the locking is not completed or execution is not finished for an extended period, the execution chain will mark the cross-chain call as failed and send a cross-chain event to unlock the relevant contracts.
% That is because in a straightforward state-locking mechanism, 
% states locking can lead to a reduction in overall system call efficiency. To mitigate the impact of state locking and enhance the system's overall call efficiency and concurrency, we have designed a finer granularity lock. Once a contract state on the calling chain is requested, the requested state is locked, causing subsequent calls that attempt to change the state to fail due to the lock. To minimize such call conflicts and improve the overall efficiency of \texttt{IntegrateX}, we have implemented a finer granularity lock. finer granularity lock allows the state to be partially locked in a more granular manner, enabling it to be locked by multiple requests simultaneously, thereby increasing overall call efficiency. For contracts with frequent intra-chain calls, the finer granularity lock not only enhances cross-chain interoperability but also reduces intra-chain call blocking caused by cross-chain calls.

\textbf{\emph{Finality.}}
In \texttt{IntegrateX}, all cross-chain transactions must wait until the consensus on the initiating chain is finalized (or, for Nakamoto-type consensus, highly likely to be finalized) before being committed to the target chain, to ensure cross-chain security.

\subsection{Transaction Aggregation}
\label{subsec:aggregation}

A large amount of cross-chain transactions for transmitting state incurs significant gas consumption. 
As shown in Figure~\ref{ta} left, handling CCSCI by sequential invocation may need to invoke contracts on the same chain in multiple rounds, which cause \emph{multiple rounds of cross-chain state transfers}. 
To address this issue, we design a transaction aggregation mechanism to reduce gas costs caused by multiple invocations of different contracts and state transfers on the same chain.
% To mitigate the gas consumption in this situation, we design the transaction aggregation mechanism to reduce gas consumption for cross-chain invocations involving contracts on the same chain for multiple times.

% Existing methods for ensuring atomicity in cross-chain invocation are sequential, meaning that calls are processed step by step, as shown in the Figure~\ref{ta}. Therefore, they need multiple rounds of cross-chain execution and cross-chain interaction in sequential order across several involved chains. Therefore, when invoking multiple contract states on the same invoked chain, it is necessary to access that chain multiple times. However, 
As shown in Figure~\ref{ta} right, our protocol locks all required states simultaneously, allowing multiple states on the same chain to be locked together, even when the calls are non-contiguous. 
The transaction aggregation mechanism combines all state requests on the same chain into a single transaction, reducing the number of cross-chain transactions. 
Similarly, during state updates, the transaction aggregation mechanism reduces the number of update requests. 
Therefore, for cross-chain calls involving multiple contracts on the same chain, this approach ensures that the number of cross-chain transactions is equal to the number of invoked chains (rather than the number of contracts), thereby reducing gas consumption.

\subsection{Fine-Grained State Lock}
\label{subsec:lock}

During the atomic integrate execution process, we need to lock contract states to ensure atomicity. 
A simple approach is to either lock the entire state of the invoked contract or lock individual states being invoked~\cite{chen2024atomci, robinson2021general}. 
However, these state-locking mechanism reduces transaction concurrency.
Because once a state is locked, any subsequent transactions related to that state will fail until the state is unlocked. 
Therefore, we establish a set of guidelines to guide developers in decomposing certain states that can be split into finer granularity, and allowing \emph{partial state locking}. 
Unlike existing protocols that require locking the entire state, our fine-grained state lock mechanism locks only partial of a state at a fine-grained level. This approach enhances concurrency by reducing unnecessary state locking.

In EVM-compatible blockchains, Solidity is the smart contract language. 
In Solidity, the state of a contract is typically represented by \emph{variables}. 
Various types of variables are used in Solidity, such as \texttt{uint}, \texttt{address}, and \texttt{boolean}. 
% We observe that \texttt{uint} variables are the most widely applied. 
We find that the \texttt{uint} variable is widely used and can be decomposed.
Based on this observation, we design a fine-grained state lock specifically for \texttt{uint} variables and develop a lock pool mechanism. 
The lock pool is a structure where, during the use of the fine-grained state lock, part of the state is locked within this structure until execution is completed, while the unlocked portion of this state remains accessible, thereby enhancing the concurrency of the application. 

% For variables directly used based on user input, the exact value of the required state can be precisely determined. 
For variables that can be directly derived from transaction inputs, the exact value of the required state can be precisely determined.
A fine-grained state lock can be applied to accurately lock only the relevant portion of such state.
For states that are dynamically used during execution, their exact values cannot be determined at the beginning. 
We allow dApp developers to lock these states in fixed-size increments based on their needs.
% For states dynamically used during execution, which can not be precisely determined at the beginning, the fine-grained state lock will lock them in fixed-size increments. 

\vspace{3pt}
\noindent
\emph{Remarks.}
We focus on the flexibility of this mechanism, allowing developers to choose whether to implement the finer granularity locking mechanism in their dApp and to set the lock granularity based on the specific needs of the dApp. 
Moreover, developers can set the fixed size of the fine-grained state lock based on their preferences, tailored to the specific use case of the application.
More discussion related to developers' learning costs is given in Section \ref{disscussion}.