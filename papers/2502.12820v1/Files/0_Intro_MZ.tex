\section{Introduction} 

\IEEEPARstart{W}{ith} the advent of Bitcoin and Ethereum~\cite{bitcoin,eth}, 
% and the subsequent development of blockchain technology, 
we have witnessed the emergence of an increasing number of programmable blockchains
% capable of running smart contracts
~\cite{belchior2021pastSV,wang2023SV,huang2021survey,lohachab2021SV}. 
% Smart contracts are self-executing programs with the terms directly written into code. 
On these programmable blockchains, developers can write and deploy smart contracts to build various complex decentralized applications (dApps, such as DeFi, NFT, etc.~\cite{wenkai2022defiSV,nadini2021mapping}).
Among these programmable blockchains, those that share compatible smart contract execution environment with Ethereum (i.e., Ethereum Virtual Machine, a.k.a. EVM~\cite{ethereum_evm}) dominate the landscape, accounting for over 90\% of the total value locked \cite{chaintvl}. 
With the increasing number of EVM-compatible blockchains and the diversity of dApps running on each chain, the demand for cross-chain dApps has grown significantly~\cite{OU2022OV}. 
Cross-chain dApps refer to dApps that require \emph{\textbf{cross-chain smart contract invocations \emph{(}CCSCI\emph{)}}} and coordinated execution across multiple blockchains \cite{Falazi2024crosschain}.
% However, across numerous EVM-compatible blockchains, it has become an increasingly pressing issue of achieving \emph{atomic and efficient interoperability for \textbf{cross-chain smart contract invocations}}\textbf{ (\emph{CCSCI})}~\cite{Falazi2024crosschain}.

However, ensuring overall atomicity for the entire cross-chain dApp while efficiently handling CCSCI remains a critical challenge. 
As illustrated in Figure~\ref{compare} left, 
consider a classic train-and-hotel problem~\cite{train}. 
A user wants to book an outbound train ticket (on Train Chain) through a travel agency (on Agency Chain), then book a hotel (on Hotel Chain), followed by a return train ticket (again on Train Chain). 
The user wants to ensure that the entire series of CCSCI either all succeed or all fail, ensuring overall atomicity.
% consider a promising cross-chain flash loan scenario. 
% The user (on Chain A) wants to invoke the flash loan contract (on Chain B) to borrow funds for liquidation on the liquidation contract (on Chain C), and then repay the loan to the flash loan contract (on Chain B).
% Given the strong need for overall atomicity in flash loan scenarios, it is insufficient to only guarantee atomicity for a single cross-chain step. 
% Instead, the entire sequence of CCSCI (borrowing, liquidating, repaying, etc.) must either succeed or fail as a whole (ensuring overall atomicity).
More importantly, maintaining efficiency during CCSCI is crucial. 
Key considerations include how to minimize latency, reduce gas consumption (monetary cost), and improve concurrency during the CCSCI process.
More cross-chain dApp scenarios are discussed in Section \ref{disscussion}.

% Current cross-chain interoperability solutions suffer from various limitations. 
% % Many previous efforts primarily focus on atomic cross-chain token transfers and exchanges~\cite{2019atomicBEswap,Xu2021htlc,Luo2024crosschannel,Manevich2022ccas,tian2021enabling,herlihy2018atomic,deshpande2020privacy,thyagarajan2022universal,chen2024pacdam,yin2022sidechain,zamyatin2019xclaim}, without considering the invocation of general-purpose cross-chain smart contracts. 
% Some works propose more general cross-chain interoperability protocols. 
% They deploy bridging smart contracts across different blockchains to facilitate more versatile message transfers between chains~\cite{nissl2021towards,wood2016polkadot,cosmos2019,abebe2019enabling,darshan2023an,reigsbergen2023demo,ghosh2021leveraging,garoffolo2020zendoo}. 

% Existing CCSCI interoperability solutions generally either fail to ensure the overall atomicity of a cross-chain application or guarantee overall atomicity but with low efficiency. 
% For example, some works \cite{nissl2021towards,wood2016polkadot,cosmos2019,abebe2019enabling,darshan2023an,reigsbergen2023demo,ghosh2021leveraging,garoffolo2020zendoo} propose general cross-chain communication protocols that facilitate the transfer of information and data between blockchains through bridging smart contracts deployed on each blockchain.
% However, these approaches typically ensure at best the atomicity of single-step cross-chain interactions, but fail to guarantee overall atomicity for the entire cross-chain application.
% some of these protocols (e.g., blahblah) do not inherently guarantee atomic cross-chain interactions. 
% Ensuring atomicity requires extensions based on their protocols. 
% Other approaches can only ensure the atomicity of single-step cross-chain interactions, but fail to guarantee atomicity for the entire logic of more complex cross-chain applications.

% There are also solutions that attempt to address smart contract interoperability by moving or replicating the entire state of smart contracts across chains (a.k.a. smart contract portability)~\cite{fynn2020smom,westerkamp2022smartsync}. 
% This approach converts cross-chain contract invocations into intra-chain interactions. 
% However, its practicality is often called into question. 
% Decentralized applications usually choose to operate on specific blockchains based on several practical considerations, including ecosystem alignment or security concern. 
% Consequently, frequently relocating the entire state of smart contracts from one ecosystem to another is typically impractical and inefficient.
% not acceptable to developers. 
% Furthermore, smart contracts often manage a significant amount of user state, and frequently relocating all of this state across chains incurs substantial overhead. 
% This inefficiency further reduces the practicality of these approaches.

Existing CCSCI interoperability solutions generally \emph{either fail to ensure the overall atomicity of a cross-chain dApp or guarantee overall atomicity but with low efficiency. }
To ensure atomicity in the CCSCI process, a widely adopted approach is to use a \emph{two-phase commit (2PC) mechanism \cite{lampson1993twopc, Falazi2024crosschain} involving locking and unlocking}.
For example, some works \cite{nissl2021towards,wood2016polkadot,cosmos2019,abebe2019enabling,darshan2023an,reigsbergen2023demo,ghosh2021leveraging,garoffolo2020zendoo} propose general cross-chain communication protocols that facilitate the transfer of information and data between blockchains through bridging smart contracts deployed on each blockchain.
However, these approaches typically ensure at best the atomicity of single-step cross-chain interactions (Figure \ref{compare}, a single arrow), but fail to guarantee overall atomicity for the entire cross-chain dApp.
Some other recent studies attempt to explore how to ensure overall atomicity for the cross-chain dApp~\cite{robinson2021general,atomic-ibc,chen2024atomci,Falazi2024crosschain}. 
To ensure overall atomicity, the relevant states must remain locked throughout the entire CCSCI process.
However, they commonly face challenges in achieving efficiency. 
% either in maintaining atomicity or in achieving efficiency. 
% For instance, Hyperservice~\cite{liu2021hyperservice} only guarantees financial atomicity, which guarantees the atomicity of the final result by initiating new transactions to re-inject the results. However, it cannot roll back all states and thus cannot ensure the atomicity of a complete cross-chain invocation.
% On the other hand, 
% For instance, works such as GPACT~\cite{robinson2021general} ensure atomicity for entire cross-chain dApps, but their cross-chain interoperability protocols suffer from efficiency issues.
The main reason is that, these approaches usually require \emph{multiple rounds of cross-chain execution and cross-chain information transfer} when handling a cross-chain dApp (Figure \ref{compare}, left), since a cross-chain dApp usually involves interdependent execution logic distributed over multiple blockchains.
% A complex cross-chain dApp typically involves multiple blockchains and several interdependent dApp logic components.
% % , which are implemented through smart contracts. 
% In these works, handling such complexity requires \emph{multiple rounds of cross-chain execution and cross-chain interaction in sequential order across several involved chains. }
% % Specifically, this involves fragmenting the execution logic, reaching consensus, and transferring intermediate states to the next blockchain responsible for executing the subsequent logic fragment. 
It is evident that this method tends to be time-consuming and inefficient (as the locking time could be long), especially when dealing with complex CCSCI. 
More related work (e.g., cross-chain asset swap, smart contract portability) is discussed and differentiated in detail in Section~\ref{related_work}.
% Further related work is discussed in Section~\ref{related_work}.

To fill the research gap, we propose \texttt{IntegrateX}, an \emph{\textbf{efficient} interoperability system that guarantees \textbf{overall atomicity}} for the cross-chain dApp across EVM-compatible blockchains. 
To enhance the efficiency of CCSCI, our core idea is to \emph{clone and deploy\footnote{The logic on the original chain still exists and continues to function normally.} the logic of all contracts involved in a cross-chain dApp—originally distributed across multiple chains—onto a single blockchain}.
% The core idea behind enhancing the efficiency of CCSCI is that, for a cross-chain dApp, \emph{conducting cross-chain deployments for the logic of each involved contract onto a single blockchain.}
This chain thus integrates the entire execution logic of the cross-chain dApp. 
When the CCSCI is required, this chain can perform \emph{\textbf{integrated execution} in one transaction} for all related logic, after receiving the necessary states (Figure \ref{compare}, right). 
% within its environment after receiving the necessary states. 
Since multi-round cross-chain executions and interactions are no longer required, \texttt{IntegrateX} maintains high efficiency, even in complex cross-chain dApps.
% It is important to note that our approach differs from the concept of smart contract portability. 
% In \texttt{IntegrateX}, the states of individual smart contracts are still maintained by their original blockchains. 
% We only “borrow” the execution environment of a single chain to integrate and execute the cross-chain logic. 
% However, the design of \texttt{IntegrateX} is not straightforward, as it faces several significant challenges, which we will address below.

\begin{figure}[t]
    \centering
    \includegraphics[width=0.525\textwidth]{Figures/compare1.png}
    \vspace{-18pt}
    \caption{An example of existing CCSCI solutions (left) and \texttt{IntegrateX} (right) in the Train-and-Hotel scenario.}
    % \vspace{-10pt}
    \label{compare}
\end{figure} 

The design of \texttt{IntegrateX} faces several challenges, which we will address below.

\vspace{3pt}
\noindent
\textbf{Challenge 1: }
\textit{How to efficiently and securely deploy smart contracts across chains to the same blockchain.}
We address this by proposing an on-chain/off-chain \textbf{\emph{Hybrid Cross-Chain Smart Contract Deployment Protocol}}.
Specifically, to reduce the overhead associated with cross-chain deployment of smart contracts (thereby improving efficiency), we devise a set of guidelines that allow developers to \emph{decouple smart contracts into logic execution contracts and state storage contracts. }
This approach enables our protocol to clone and deploy only the logic contracts onto the same target blockchain, while the state-heavy contracts remain in their original locations.
% However, cross-chain deployment of smart contracts cannot be achieved through existing interoperability protocols (e.g., [blah]) using bridging smart contracts, because smart contracts cannot deploy other smart contracts. 
To further reduce the gas consumption during cross-chain deployment, we propose to \emph{clone and deploy the logic contracts to the same blockchain via an off-chain mechanism.}
However, malicious actors may tamper with the contracts during the off-chain clone and deployment process, leading to compromised security. 
To address this, we design and deploy bridging smart contracts on each blockchain. 
These bridging smart contracts perform \emph{on-chain cross-chain comparison and verification} of the logic contracts between the source chain and the target chain to ensure security.
% This, however, raises a security concern, as malicious actors could interfere during the off-chain migration and deployment process, leading to inconsistencies in the deployed contracts.
% To ensure the consistency of cross-chain deployment logic, we design and deploy bridging smart contracts for verification across the involved chains. 
% These bridging smart contracts perform \emph{cross-chain comparison and verification on-chain}, ensuring that the logic between the source chain and the destination chain remains consistent during the cross-chain deployment process.

\vspace{3pt}
\noindent
\textbf{Challenge 2: }
\textit{How to enhance concurrency and reduce overhead during CCSCI while ensuring overall atomicity.}
We address this by proposing a \textbf{\emph{Cross-Chain Smart Contract Integrated Execution Protocol}}.
Specifically, to ensure overall atomicity during CCSCI, we adopt a 2PC-based mechanism, similar to existing mainstream approaches.
This process involves locking the relevant states across the involved chains, transmitting the states to the chain responsible for integrated execution, executing all logic, and then returning the states to the respective chains to unlock and update them. 
This guarantees that the cross-chain dApp either completes entirely or is fully rolled back.
Moreover, cross-chain state transfers may incur significant overhead. 
To mitigate the \emph{\textbf{overhead}} of cross-chain communication, we \emph{aggregate multiple cross-chain transactions into a single one} where necessary, and transmit them across chains.
More importantly, a straightforward state-locking mechanism reduces transaction concurrency. 
To enhance \emph{\textbf{concurrency}}, we establish a set of guidelines that allow developers to further \emph{decompose and lock contract states at a finer granularity.} 
By locking more granular states, our protocol alleviates the issue of poor concurrency that arises when entire states are locked.


This paper mainly makes the following contributions:
% \vspace{-9pt}
\begin{itemize}[left=0pt]
    \item We present \texttt{IntegrateX}, a cross-chain interoperability system that efficiently facilitates CCSCI while ensuring overall atomicity for the cross-chain dApp. 
    \texttt{IntegrateX} can be flexibly deployed on EVM-compatible blockchains without requiring modifications to the underlying blockchain systems. 
    \item In \texttt{IntegrateX}, we propose the Hybrid Cross-Chain Smart Contract Deployment Protocol. 
    It achieves efficient and secure cross-chain deployment through the decoupling of smart contract logic and state, and the hybrid approach of off-chain logic deployment and on-chain comparison verification.
    \item In \texttt{IntegrateX}, we propose the Cross-Chain Smart Contract Integrated Execution Protocol. 
    It ensures overall atomicity of cross-chain invocations through a 2PC-based atomic integrated execution mechanism, and enhances the protocol efficiency through an aggregated cross-chain transaction transmission mechanism and fine-grained state lock.
    \item We implement a prototype of \texttt{IntegrateX} and make it open source~\cite{INTEGRATEX}. 
    Extensive experiments based on real-world use cases demonstrate that \texttt{IntegrateX} reduces latency by up to 61.2\% meanwhile maintains low gas cost and high concurrency compared to the state-of-the-art baseline. 
    In more complex cross-chain invocations, \texttt{IntegrateX} will further improve efficiency.
\end{itemize}
% Contributions. 
% We present \texttt{IntegrateX}, a cross-chain interoperability system that efficiently facilitates cross-chain smart contract invocations while ensuring the atomicity of entire cross-chain dApps. 
% \texttt{IntegrateX} can be flexibly deployed on EVM-compatible blockchains without requiring any modifications to the underlying blockchain systems. 
% Decentralized dApp developers only need to follow our established standards when developing or upgrading their smart contracts to take advantage of \texttt{IntegrateX}'s interoperability features.
% \texttt{IntegrateX} consists of two key protocols. 
% The first is the Hybrid Cross-Chain Smart Contract Deployment Protocol, which achieves efficient and secure cross-chain deployment through the decoupling of smart contract logic and state, and the hybrid approach of off-chain logic deployment and on-chain comparison verification.
% The second is the Cross-Chain Smart Contract Integrated Execution Protocol, which ensures the atomicity of cross-chain invocations through a 2PC-based mechanism, and enhances the protocol efficiency through fine-grained state locks and an aggregated cross-chain transaction transmission mechanism.
% We implement a prototype of \texttt{IntegrateX} and make it open source. 
% Extensive experiments based on real-world use cases demonstrate that \texttt{IntegrateX} delivers exceptional performance.
