\documentclass[11pt]{article}
%\usepackage[left=0.5in,right=0.5in,top=0.5in,bottom=0.5in,
%            footskip=0.25in]{geometry}
\usepackage{graphicx,float,hyperref, indentfirst} 
\usepackage{amsmath,amsthm,amssymb,amsfonts,geometry,mathtools,xcolor, enumerate, comment}
\usepackage{varwidth}
\usepackage{subfigure}
\usepackage{tikz}
\usepackage{booktabs}
\usepackage[noend]{algpseudocode}
\usepackage{algorithm2e}
\usepackage{afterpage}
\RestyleAlgo{ruled}
\usepackage{multirow}
\renewcommand{\arraystretch}{1.8}
%\usepackage[noend, noline]{algorithm2e}
%\usepackage[displaymath]{lineno}
%\linenumbers
\parindent 5mm
\parskip 0.2mm
\oddsidemargin  0pt \evensidemargin 0pt \marginparwidth 0pt
\marginparsep 0pt \topmargin 0pt \headsep 0pt \textheight 8.8in
\textwidth 6.6in
\renewcommand{\baselinestretch}{1.03}

\SetKwFor{RepTimes}{repeat}{times}{end}
 
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{property}[theorem]{Property}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{exercises}[theorem]{Exercises}
\newtheorem{example}[theorem]{Example}
\newtheorem{examples}[theorem]{Examples}
\newtheorem{question}[theorem]{Question}

\theoremstyle{remark}
\newtheorem{remark}{Remark}
\newtheorem{observation}{Observation}

\newcommand{\Bin}{\ensuremath{\textrm{Bin}}}
\newcommand{\Bern}{\text{Bern}}

\newcommand{\red}{\textcolor{red}}
 
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\C}{\mathbb{C}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\Nn}{\mathbb{N}}
\newcommand{\Var}{\text{Var}}
\newcommand{\Cov}{\text{Cov}}
\newcommand{\mcal}[1]{\mathcal{#1}}

\DeclarePairedDelimiter{\ceil}{\lceil}{\rceil}
\DeclarePairedDelimiter{\floor}{\lfloor}{\rfloor}


\title{Improved Sublinear Algorithms for Classical and Quantum Graph Coloring}
\author{Asaf Ferber, Liam Hardiman, Xiaonan Chen}
\date{\today}

\begin{document}


\maketitle
\begin{abstract}
    We present three sublinear randomized algorithms for vertex-coloring of graphs with maximum degree $\Delta$. The first is a simple algorithm that extends the idea of Morris and Song to color graphs with maximum degree $\Delta$ using $\Delta+1$ colors. Combined with the greedy algorithm, it achieves an expected runtime of $O(n^{3/2}\sqrt{\log n})$ in the query model, improving on Assadi, Chen, and Khanna’s algorithm by a $\sqrt{\log n}$ factor in expectation. When we allow quantum queries to the graph, we can accelerate the first algorithm using Grover's famous algorithm, resulting in a runtime of $\Tilde{O}(n^{4/3})$ quantum queries. Finally, we introduce a quantum algorithm for $(1+\epsilon)\Delta$-coloring, achieving $O(\epsilon^{-1}n^{5/4}\log^{3/2}n)$ quantum queries, offering a polynomial improvement over the previous best bound by Morris and Song.
\end{abstract}
\section{Introduction}
Given an integer $k\in \mathbb{N}$ and a graph $G=(V,E)$, a \emph{proper $k$-coloring} is a function $c:V\rightarrow \{1,\ldots,k\}$ such that for each $\{v,u\}\in E$ we have $c(u)\neq c(v)$ (that is, no edge is \emph{monochromatic}). 
The smallest positive $k$ such that $G$ admits a proper $k$-coloring is called the \emph{chromatic number} of $G$, denoted by $\chi(G)$.
While determining $\chi(G)$ is NP-hard \cite{Karp1972}, it is easy to color a graph $G$ with maximum degree $\Delta$ using $\Delta+1$ colors. A simple greedy algorithm achieves this by assigning each vertex a color different from those of its neighbors. Since each vertex has at most $\Delta$ neighbors, there is always at least one available color to ensure no edge becomes monochromatic. Without making further assumptions about $G$, this approach cannot do with fewer than $\Delta+1$ colors: consider a clique or an odd cycle.

To better understand the performance of coloring algorithms, we can evaluate them using various models \cite{Beame_MPC,ChangCongestedClique,Goldreich_2017}. One such model is the \emph{query model}, where we assume the graph is stored in a black box and we have access to an oracle that answers the following queries.
\begin{itemize}
    \item Adjacency queries: we may ask whether the vertices $u$ and $v$ are adjacent in $V$.
    In other words, if $A$ is the adjacency matrix of $G$, we may query $A_{u,v}$ for arbitrary $u$ and $v$.

    \item Degree queries: for any vertex $v\in V$, we may query its degree, denoted $d(v)$.

    \item Neighborhood queries: for any vertex $v$ and any integer $j$, we may query the $j$-th neighbor of $v$ (the ordering of the neighbors is arbitrary, but fixed).
    If $v$ does not have $j$ neighbors, then we assume the oracle returns some special symbol $\perp$.
\end{itemize}
Here we judge an algorithm's efficiency by the number of queries it makes to such an oracle.
The aforementioned greedy algorithm makes $O(|E|)$ neighborhood queries. For dense graphs, this becomes impractical since the number of edges can be extremely large, and computational resources may not scale accordingly. Therefore, we aim to design sublinear algorithms—in terms of the number of edges—that can still efficiently color $G$.

In this direction, Assadi, Chen, and Khanna \cite{assadiChenKhannaSublinear} detailed a randomized algorithm that generates a valid $(\Delta+1)$-coloring with high probability in $O(n^{2}\log^2 n/\Delta)$ adjacency queries.\footnote{As part of the standard query model, we assume that we may query the degree of an arbitrary vertex. Consequently, determining $\Delta$ takes only $\Tilde{O}(n)$ queries, where the $\Tilde{O}$ notation omits logarithmic factors in $n$. Thus, we do not need to assume that 
$\Delta$ is known beforehand.} They use a technique known as palette sparsification, whereby we sample a small number of colors to form a palette of size $O(\log n)$ for each vertex, and then construct a valid coloring from them.
Combining their algorithm with the greedy algorithm, we achieve an algorithm that properly colors $G$ in $O(n^{3/2} \log n)$ queries.
This is just a log factor greater than the lower bound of $\Omega(n^{3/2})$ queries proved in the same paper. If one has $(1+\epsilon)\Delta$ colors, Morris and Song \cite{morrisSongColoring} recently provided a very simple randomized algorithm that outputs a valid $(1+\epsilon)\Delta$-coloring in $O(\epsilon^{-1}n^2/\Delta)$ queries in expectation. Again, when combined with the greedy algorithm, this algorithm runs in $O(\epsilon^{-1/2}n^{3/2})$ queries in expectation.

Both works use a common framework that involves two algorithms to properly color a graph $G$ with $n$ vertices and maximum degree $\Delta$. The first algorithm makes $f(\Delta)$ adjacency queries, where $f(\Delta)$ is monotonically decreasing with $\Delta$, while the second makes $g(\Delta)$ neighborhood queries, where $g(\Delta)$ is monotonically increasing with $\Delta$.
If $\Delta^*$ is chosen so that $f(\Delta^*) = g(\Delta^*)$, we can apply the first algorithm when $\Delta \geq \Delta^*$ and the second when $\Delta < \Delta^*$ to obtain a combined algorithm that runs in at most $f(\Delta^*) = g(\Delta^*)$ queries.
%By applying the first algorithm when $\Delta$ is large and the second when $\Delta$ is small, we derive an optimal algorithm that runs in $f(\Delta^*) = g(\Delta^*)$ queries, where $\Delta^*$ is chosen such that $f(\Delta^*) = g(\Delta^*)$.
The improvements in above works came from enhancing the function $f$ while using $g(\Delta)=n\Delta$ from the greedy algorithm.

Following this framework, our first contribution is a simple Las Vegas algorithm for $(\Delta+1)$-coloring that improves the function $f(\Delta)$. Specifically, our algorithm uses $f(\Delta)=O(n^2\log n/\Delta)$ adjacency queries in expectation. In comparison, the algorithm of Assadi, Chen, and Khanna is a Monte Carlo algorithm that succeeds with probability \( 1 - 1/\mathrm{poly}(n) \) for some large polynomial in \( n \). However, their algorithm implicitly has an expected running time of \( f(\Delta) = O(n^2 \log^2 n / \Delta) \), so our approach improves on their result by a factor of \( \log n \) in expectation. On the other hand, our Las Vegas algorithm can be converted into a Monte Carlo algorithm using standard probabilistic boosting techniques. To achieve the same level of success probability as Assadi, Chen, and Khanna's algorithm, we require an additional \( \log n \) factor. In this case, the query complexity of our algorithm matches theirs, while still maintaining the same success probability.

Our method is relatively simple and easy to implement and analyze. Roughly speaking, we process the vertices sequentially, assigning each a random color and using adjacency queries to check if any of its neighbors share that color. For vertices with large degrees, this method can be more efficient than examining all neighbors beforehand, as randomly selecting a color still offers a good chance of avoiding a monochromatic edge. This approach is inspired by the work of Morris and Song \cite{morrisSongColoring} on $(1+\epsilon)\Delta$-coloring. By randomizing the order in which we visit the vertices of our graph, we are able to adapt it to $(\Delta+1)$-coloring. 

\begin{theorem}\label{thm: classical Delta+1}
    There is a randomized algorithm that, given a graph $G$ of maximum degree $\Delta$, properly $(\Delta+1)$-colors $G$ using $O(n^{2}\log n/\Delta)$ adjacency queries in expectation.
\end{theorem}
Using $g(\Delta)=n\Delta$ from the greedy algorithm, we derive the following corollary.
\begin{corollary}
    There is a randomized algorithm that, given a graph $G$ of maximum degree $\Delta$, properly $(\Delta+1)$-colors $G$ using $O(n^{3/2}\sqrt{\log n})$ queries in expectation.\footnote{Recently, the authors learned that this result has been independently proved by Sepehr Assadi, who presented it in a lecture at Simons Institute Bootcamp in May 2024.}
\end{corollary}

Can we do better than Theorem \ref{thm: classical Delta+1} if we have access to a quantum oracle? Following the approach of Morris and Song, we can utilize Grover's algorithm \cite{grover96}, which allows us to find a marked item in an unsorted list of $N$ items using only $O(\sqrt{N})$ quantum queries. By incorporating Grover's algorithm, we can achieve a further improvement in $f(\Delta)$, resulting in a quadratic speedup.

%A natural question to ask is whether we could do better than in Theorem \ref{thm: classical Delta+1} in case we had an access to a quantum oracle. The quantum query model is a fundamental framework in quantum computing, where one can access a black box (oracle) that answers specific queries. In this model, the oracle is treated as an unknown unitary operator acting on qubits, which are the quantum analogs of classical bits. A unique advantage of the quantum query model is that querying the oracle on a superposition of inputs allows the quantum algorithm to process multiple inputs simultaneously. This enables the quantum algorithm to gather more information in fewer queries by exploiting quantum superposition and interference. This model was first formalized by David Deutsch and Richard Jozsa in their work on the Deutsch-Jozsa algorithm \cite{deutsch1992rapid}, which demonstrated the first quantum algorithm capable of exponentially outperforming any classical algorithm in a black-box setting.

%Many of the most influential quantum algorithms, including Grover’s search algorithm \cite{grover96} and Shor’s factoring algorithm \cite{Shor_factor_97}, have been analyzed using the quantum query model. Grover’s algorithm, in particular, enables finding a marked item in an unsorted list of $N$ items using only $O(\sqrt{N})$ quantum queries. In our work, we transform the classical graph queries into quantum oracles and adopt Grover's algorithm to develop our quantum sublinear algorithms. By simply incorporating Grover's search, we can achieve a further improvement to our theorem \ref{thm: classical Delta+1}, resulting in a quadratic speedup in $f(\Delta)$.

\begin{theorem}\label{thm: quantum adjacency}
    There is a quantum algorithm that, given a graph $G$ of maximum degree $\Delta$, properly $(\Delta+1)$-colors $G$ using $O(n^{3/2}\log n/\sqrt{\Delta})$ quantum adjacency queries in expectation .
\end{theorem}
\begin{corollary}
    There is a quantum algorithm that, given a graph $G$ of maximum degree $\Delta$, properly $(\Delta+1)$-colors $G$ using $\Tilde{O}(n^{4/3})$ quantum queries in expectation .
\end{corollary}

The $\Tilde{O}(n^{4/3})$ comes from using $g(\Delta)=n\Delta$ again from the classical greedy algorithm, similar to the approach taken by Morris and Song \cite{morrisSongColoring} for 
$(1+\epsilon)\Delta$-coloring. This result breaks the classical lower bound of $\Omega(n^{3/2})$, leading us to consider whether improvements to $g(\Delta)$ are possible using a quantum oracle. Our last contribution is a quantum algorithm that runs in $g(\Delta)=\epsilon^{-2}n\log^2 n\sqrt{\Delta}$ queries. This takes the role of the greedy algorithm in previous results. The key idea is to randomly partition the vertices and then efficiently identify the neighbors of a vertex in the same part using neighborhood queries. While achieving this efficiently in the classical setting seems unlikely, the quantum setting makes it attainable.

\begin{theorem}\label{thm: quantum neighborhood}
    There is a quantum algorithm that, given a graph $G$ of maximum degree $\Delta$, properly $(1+\epsilon)\Delta$-colors $G$ using $O(\epsilon^{-2}n\log^2 n\sqrt{\Delta})$ quantum neighborhood queries.
    This algorithm succeeds with probability at least $2/3$.
\end{theorem}
 When combined with Theorem \ref{thm: quantum adjacency}, our algorithm achieves a polynomial improvement over the results presented in \cite{morrisSongColoring}.
\begin{corollary}
    There is a quantum algorithm that, given a graph $G$ of maximum degree $\Delta$, properly $(1+\epsilon)\Delta$-colors $G$ using $\tilde{O}(\epsilon^{-1}n^{5/4})$ queries.
    This algorithm succeeds with probability at least $2/3$.
\end{corollary}

\begin{table}[h!]
    \centering
    \begin{tabular}{|l||c|c|c|c|}\hline
     \multicolumn{1}{|c||}{}& \multicolumn{2}{c|}{Classical} & \multicolumn{2}{c|}{Quantum}\\\hline
                            & Neighborhood  & Adjacency                 & Neighborhood              & Adjacency\\\hline\hline
     $(\Delta+1)$-coloring          & $n\Delta$     & $O\left(\frac{n^2 \log^2 n}{\Delta}\right)$\cite{assadiChenKhannaSublinear}, $O\left(\frac{n^2\log n}{\Delta}\right)$[$\star$]       &                   & $\tilde O \left(\frac{n^{3/2}}{\sqrt \Delta}\right)$[$\star$]\\\hline
     $(1+\epsilon)\Delta$-coloring  &               & $\frac{n^2}{\epsilon \Delta}$\ \cite{morrisSongColoring} & $\tilde O\left(\frac{n\sqrt \Delta}{\epsilon^2}\right)$[$\star$] & $\tilde O\left( \frac{n^{3/2}}{\epsilon^{3/2}\sqrt \Delta} \right)$\cite{morrisSongColoring}\\\hline
    \end{tabular}
    \caption{Summary of expected runtimes. A [$\star$] indicates this work.}
    \label{tab:my_label}
\end{table}

We provide a table summarizing the current best algorithms using neighborhood or adjacency queries. Blank cells indicate areas where no non-trivial algorithms have been discovered so far. Discovering new algorithms that fill these gaps or improving existing algorithms using only one type of query could lead to improvements in the combined algorithm. In the remainder of the paper, we prove Theorem \ref{thm: classical Delta+1} in Section 2 and Theorems \ref{thm: quantum adjacency} and \ref{thm: quantum neighborhood} in Section 3.

% Our second result adapted the scenario to quantum algorithms. Specifically, we assume that adjacency queries and neighbor queries can be executed in quantum superposition. Quantum algorithms have demonstrated superior efficiency compared to classical algorithms in various settings. For instance, Grover's algorithm offers a quadratic speedup for search problems, reducing the time complexity of locating a target element in an unsorted size $N$ list from $O(N)$ to $O(\sqrt{N})$. Instantiating Grover's algorithm in their coloring algorithm, Morris and Song achieved a quantum algorithm for $(1+\epsilon)\Delta$-coloring problem in $O(\epsilon^{-1}n^{4/3})$ quantum adjacency queries \cite{morrisSongColoring}.  Additionally, they provide a quantum lower bound of $\Omega(n)$. 

% In this paper, we first extend our $(\Delta+1)$-coloring algorithm to an quantum algorithm using quantum adjacency queries. By a similar approach to \cite{morrisSongColoring}, our $\Delta+1$-coloring algorithm can be speedup by simply adapt the Grover's algorithm. Furthermore, we will provide a novel quantum algorithm that uses quantum neighbor queries to provide a valid $(1+\epsilon)\Delta$-coloring. If we combine our algorithm with the existing $(1+\epsilon)\Delta$-coloring algorithm using quantum adjacency queries, and pick the best of the two depending on the value of $\Delta$, we are able to find a quantum $(1+\epsilon)\Delta$-coloring algorithm that runs in $O(\epsilon^{-1/4}n^{5/4})$.
% This is a polynomial improvement to the one from \cite{morrisSongColoring}. 

% \begin{theorem}\label{thm: quantum alg}
%     Let $G$ be a graph on $n$ vertices with maximum degree $\Delta$. There exists a randomized algorithm that color the vertices of $G$ with at most $(1+\epsilon)\Delta$ colors while making $\mathcal {O}(\epsilon^{-1/4}n^{5/4})$ quantum queries.
% \end{theorem}


% \begin{table}[h!]
% \centering
%  \begin{tabular}{ |p{3cm}||p{3cm}|p{3cm}|p{3cm}|  }
%  \hline
%  Problem &  \# Queries &  Classic/Quantum & Reference\\
%  \hline
%  \hline
%  $(\Delta+1)$-coloring   & $O(n^{3/2}\log^2 n)$    & Classic &   Assadi, Chen \cite{assadiChenKhannaSublinear}\\
%  \hline
%  $(\Delta+1)$-coloring &  $O(n^{3/2}\log^{3/2}n)$   & Classic   & \textbf{This paper.}\\
%  \hline
%  $(1+\epsilon)\Delta$-coloring & $O(\epsilon^{-3/2}n\sqrt{ n\log n})$ & Classic&  Alon, Assadi \cite{AlonAssadi} \\
%  \hline
%  $(1+\epsilon)\Delta$-coloring & $O(\epsilon^{-1/2}n\sqrt{ n}\log n)$ & Classic&  Morris, Song \cite{morrisSongColoring}\\
%  \hline
%  $(1+\epsilon)\Delta$-coloring  & $O(\epsilon^{-1}n^{4/3})$ & Quantum&  Morris, Song \cite{morrisSongColoring}\\
%  \hline
%  $(1+\epsilon)\Delta$-coloring&   $O(\epsilon^{-1/4}n^{5/4})$  & Quantum & \textbf{This paper.}\\
%  \hline
% \end{tabular}   
% \caption{A brief summary of sublinear algorithms in query model.}
% \label{table:1}
% \end{table}

% We provide a table summarize the current best algorithms using neighborhood or adjacency queries. Blank cells indicate that no non-trivial algorithms have been discovered yet. Any new discovery filling a blank cell or improvement to an existing algorithm using only one type of query could lead to improvements in the combined algorithm.





% The key idea of our quantum neighbor query algorithm is the random graph partitioning technique, which has been used in various algorithms for graph coloring \cite{AlonAssadi, ChangCongestedClique, parterCongest}.
% We will take a detour and present an algorithm in coloring random graphs to illustrate our idea. Notably, efficient algorithms for coloring random graphs have been lacking within the existing query model framework. To address this gap, we introduce a simple algorithm designed to operate under a modified query model. Specifically, we assume that neighbor queries respect a fixed ordering of the vertices, which we refer to as the ``ordered query model''. 
% \begin{comment}
%    \begin{theorem}\label{thm: random_graph} 
%    Let $p>0$. A random graph $G_{n,p}$ is typically such that for any $\epsilon>0$, $1\le k\le \frac{\epsilon^2 np}{9\log n}$, there exists a randomized algorithm with expected running time $O(\frac{n^2p}{k})$, generates a valid $O(k\cdot \chi(G_{n/k,p}))$-coloring in the \textbf{ordered query model}.
%    \textcolor{red}{Make sure this upper bound on $k$ is actually an integer. Fine if $p$ is constant, but if $p$ is pretty small, then this upper bound is $<1$.}
% \end{theorem}
 
% \end{comment}

% \begin{theorem}\label{thm: random_graph} 
%    Let $1>p>0$. A random graph $G_{n,p}$ is typically such that for any $\epsilon>0$, there exists a randomized algorithm with expected running time $O(\epsilon^{-2}n\log n)$, generates a valid $(1+\epsilon)np$-coloring in the \textbf{ordered query model}.
% \end{theorem}


% \begin{comment}
    

% The random graph $G_{n,p}$ is a random variable that outputs a graph on vertex set $[n]$, where each possible pair $\{u,v\}\in \binom{[n]}{2}$ appears as an edge independently with probability $p$.
% The chromatic number of random graphs has been one of the major open problem in random graph theory until 1987 when the breakthrough result of Bollab\'as \cite{bollobas_chromatic} came out. He showed that with high probability, for constant $0<p<1$, the chromatic number $\chi(G_{n,p})\le (\frac{1}{2}+o(1))\frac{n}{\log_b n}$, where $b = \frac{1}{1-p}$. 
% Until now, there has been a lack of efficient algorithms for coloring random graphs within the existing query model framework. Our second algorithm is designed to address this gap. However, to meet our need, we will introduce a slight modification to the current query model. In particular, we assume the neighbor queries respect some fixed ordering of the vertices.

% \end{comment}

% In section 2, we will provide some preliminary tools used in this paper. Theorem \ref{thm: rand alg} will be proved in section 3. The adapted quantum algorithm using adjacency queries will be presented in section 4. Then we will show our coloring algorithm for random graph in section 5 and apply that idea to present the quantum algorithm using quantum neighbor queries in section 6. Discussions will be in the last section. 

% \begin{comment}
%  The authors of \cite{morrisSongColoring} also provide a quantum algorithm for $(1+\epsilon)\Delta$-coloring in $\mathcal O(\epsilon^{-1}n^{4/3}\log^2n)$ quantum queries (their algorithm succeeds with high probability). Here the quantum query assume an quantum oracle with access to adjacency matrix. i.e. we can query whether there is an edge between two vertices.
% We are able to slightly modify their algorithm to remove the $\log^2n$ factor.
% \begin{theorem}\label{thm: quantum}
%     Given a graph $G = (V,E)$ on $n$ vertices with maximum degree $\Delta$, there exists a quantum algorithm with running time $\mathcal O(\epsilon^{-1}n^{4/3})$ that, with high probability, generates a valid $(1+\epsilon)\Delta$-coloring in the quantum query model.
% \end{theorem}   
% \end{comment}




\begin{comment}


\section{Tools}

I WOULDN'T HOLD A SECTION ONLY FOR THESE TWO RESULTS.

We will use the following standard probabilistic tools to reason about our randomized algorithms.
References to all of these can be found in, e.g., \cite{mitzenmacher2017probability}

\begin{proposition}[Chernoff Bound]\label{chernoff}
    Let $X_1, \ldots, X_n$ be independent Bernoulli random variables. Define $S = \sum_{i=1}^n X_i$.
    Then for any $\delta\in (0,1)$ and $m \leq \E[S] \leq M$,
    \[
    \Pr[S > (1+\delta)M] \leq \exp\left(-\frac{\delta^2M}{3} \right),\qquad \Pr[S < (1-\delta)m] \leq \exp\left(-\frac{\delta^2m}{2} \right).
    \]
\end{proposition}
The above conclusion also holds in the case where $S$ is a hypergeometric random variable (see, e.g. \cite{JansonConcentration}).

    
\begin{proposition}[Jensen's Inequality]\label{jensen}
    If $X$ is a random variable and $f$ is a convex function, then
    \[
    \E[f(X)] \geq f(\E[X]).
    \]
    This inequality reverses if $f$ is instead concave.
\end{proposition}

% \begin{proposition}[Coupon Collector Problem]\label{coupon collector}
%     Let $U_n$ be a uniform random variable taking values in $[n]$.
%     Repeatedly sample $U_n$ until we have seen one of each output 1 through $n$.
%     If $X$ is the time at which this occurs, then
%     \[
%     \E[X] = n\log n + \Theta(n)
%     \]
%     and for any constant $c$,
%     \[
%     \lim_{n\to \infty}\Pr[X \geq n\log n + cn] = 1 - e^{-e^{-c}}.
%     \]
% \end{proposition}

    
\end{comment}

    

\section{Classical Sublinear Algorithm}
%We provide the following algorithm: under an arbitrary order, for each vertex, choose a random color and then check for edges in that color class, which is the set of all vertices with the given color under partial coloring. If there's an edge in it, roll a new color.
Let $V = \{v_1, \ldots, v_n\}$ be the vertices of $G$. We provide an algorithm that constructs the coloring $\chi: V\to [\Delta+1]$ by successively updating the color classes $\chi^{-1}(1), \ldots, \chi^{-1}(\Delta+1)$.
Start by selecting a permutation $\sigma \in S_n$ uniformly at random, and set $\chi_0^{-1}(c) = \emptyset$ for all colors $c\in[\Delta+1]$. At each step $0 < t \leq n$, choose a color $c$ 
uniformly at random for $v_{\sigma(t)}$. Let $\chi_t^{-1}(c)$ denote the set of vertices that have already been assigned the color $c$ up to step $t$. If the vertex $v_{\sigma(t)}$ is adjacent to any vertex in $\chi_t^{-1}(c)$, select a new random color $c'$. Otherwise, assign the color $c$ to $v_{\sigma(t)}$, and update $\chi_t^{-1}(c)$ by adding $v_{\sigma(t)}$ to the color class.
\begin{algorithm}[h]\label{alg: max degree color}
\caption{$(\Delta+1)$-Color($G,\Delta$)}
%\State Choose a random ordering for the vertices, $V = \{v_{\sigma(1)}, \ldots, v_{\sigma(n)}\}$
Choose a permutation $\sigma\in S_n$ uniformly at random

\For{$t = 1, \ldots, n$}{
    \While{$v_{\sigma(t)}$ is not colored}{
        Choose a color $c$ uniformly at random in $[\Delta + 1]$
        
        \For{$u \in \chi_t^{-1}(c)$}{
            Query if $\{u,v_{\sigma(t)}\}\in E$ 
            
            \If{$\{u,v_{\sigma(t)}\}\in E$}{
                \textbf{break}
            }
            Assign color $c$ to $v_{\sigma(t)}$ and update $\chi(c)$ with $v_{\sigma(t)}$
        }
    }
}
\Return the color assignment $\chi: V\to [\Delta+1]$
\end{algorithm}



%In particular, fix some permutation $\sigma$ on the vertex set.
\begin{proof}[Proof of Theorem \ref{thm: classical Delta+1}]
    
Let us analyze the expected runtime of Algorithm \ref{alg: max degree color}.
For each $t\leq n$, let $Q_t$ be the number of times we query the adjacency matrix before we assign a valid color to $v_{\sigma(t)}$, and let $Q_t(\sigma)$ be this random variable conditioned on the event that we ordered $V$ according to the permutation $\sigma$.
%For each $t \leq n$, let $Q_t(\sigma)$ be the number of times we query the adjacency matrix before we assign a valid color to $v_{\sigma(t)}$.
If we let $c$ be the first color we try to assign to $v_{\sigma(t)}$, 
%and $\chi_t(c)$ the color class of of $c$
let $p_t(\sigma)$ be the probability that it is a valid color, i.e., that no neighbor of $v_{\sigma(t)}$ has already been assigned the color $c$.
In the worst case, we need to check $v_{\sigma(t)}$ for adjacency with every vertex in $\chi^{-1}_t(c)$, so we can bound the expectation of $Q_t(\sigma)$ as follows.
\[
\E_c[Q_t(\sigma)] \leq p_t(\sigma)\E_c[|\chi^{-1}_t(c)| : c\text{ is valid}] + (1-p_t(\sigma))\bigg( \E_c[|\chi^{-1}_t(c)|: c\text{ is invalid}] + \E_c[Q_t(\sigma)]\bigg),
\]
so $\E_c[Q_t(\sigma)] \leq \E_c[|\chi^{-1}_t(c)|]/p_t(\sigma)$.
Since each vertex is colored randomly, we have
\[
\E_c [Q_t(\sigma)] \leq \frac{\E_c[|\chi^{-1}(c)|]}{p_t(\sigma)} \leq \frac{n}{\Delta+1}\cdot \frac{1}{p_t(\sigma)}.
\]
We obtain the expectation of $Q_t$ by averaging $Q_t(\sigma)$ over a uniformly chosen $\sigma$:
\[
\E[Q_t] \leq \frac{n}{\Delta+1}\cdot\E_\sigma \left[\frac{1}{p_t(\sigma)}\right].
\]
Now when we attempt to color $v_{\sigma(t)}$ by choosing $c$ at random, the worst case is that each neighbor of $v_{\sigma(t)}$ that has already been colored has a different color.
In other words, if we let
$$L_t(\sigma) = |\{i < t: \{v_{\sigma(i)},v_{\sigma(t)}\} \in E\}|$$
denote the number of neighbors of $v_{\sigma(t)}$ that have already been colored by time $t$, then
\[
p_t(\sigma) \geq \frac{\Delta + 1 - L_t(\sigma)}{\Delta+1}.
\]
The expectation is then bounded by
\begin{equation}\label{eqn:Qt exp bound}
\E[Q_t] \leq n\cdot  \E_\sigma\left[ \frac{1}{\Delta+1 - L_t(\sigma)}\right] = n\sum_{k=0}^\Delta \frac{\Pr[L_t(\sigma) = k]}{\Delta+1 - k}.
\end{equation}
After counting the number of permutations where $v_{\sigma(t)} = v$ and exactly $k$ neighbors of $v$ come before $v$ with respect to $\sigma$, the probability in the summation is given by
\[
\Pr[L_t(\sigma) = k] = \frac{1}{n}\sum_{v\in V}\Pr[L_t(\sigma) = k \mid v_{\sigma(t)} = v] = \frac{1}{n}\sum_{v\in V} \frac{\binom{t-1}{k}\binom{n-t}{d(v)-k}}{\binom{n-1}{d(v)}}.
\]
Substituting this into (\ref{eqn:Qt exp bound}) and switching the order of summation gives
\begin{equation}\label{eqn:expectation sum}
\E[Q_t] \leq \sum_{v\in V}\frac{1}{\binom{n-1}{d(v)}}\sum_{k = 0}^{d_v}\binom{t-1}{k}\binom{n-t}{d(v)-k} \frac{1}{\Delta+1-k}.
\end{equation}

Now if $d(v)$ is small, say less than $\epsilon \Delta$ for some small positive $\epsilon$, then
\begin{equation}\label{eqn: large degree}
\sum_{k=0}^{d(v)}\binom{t-1}{k}\binom{n-t}{d(v)-k}\frac{1}{\Delta+1-k} \leq \frac{1}{(1-\epsilon)\Delta}\sum_{k=0}^{d(v)}\binom{t-1}{k}\binom{n-t}{d(v)-k} = \frac{1}{(1-\epsilon)\Delta}\binom{n-1}{d(v)}.
\end{equation}
The last equality comes from recognizing the middle sum as the coefficient of $x^{d(v)}$ in the expansion of $(1+x)^{t-1}\cdot (1+x)^{n-t} = (1+x)^{n-1}$.
On the other hand, if $d(v)\geq \epsilon \Delta$, then
\begin{equation}\label{eqn: small degree}
\begin{split}
    \sum_{k=0}^{d(v)}\binom{t-1}{k}\binom{n-t}{d(v)-k}\frac{1}{\Delta+1-k} & \leq\sum_{k=0}^{d(v)}\binom{t-1}{k}\binom{n-t}{d(v)-k}\frac{1}{d(v)+1-k}.
\end{split}
\end{equation}
In order to bound this term, we notice that
\[
\sum_{k=0}^{\infty}\binom{n-t}{k}\frac{x^{k}}{k+1}=\frac{1}{x}\int_0^x \sum_{k=0}^{\infty}\binom{n-t}{k}s^kds=\frac{1}{x}\int_0^x (1+s)^{n-t}ds=\frac{(1+x)^{n-t+1}}{x(n-t+1)}.
\]
Hence the right-hand side in (\ref{eqn: small degree}) may be recognized as the coefficient of $x^{d(v)}$ in the expansion of 
\[
(1+x)^{t-1}\cdot\frac{(1+x)^{n-t+1}}{x(n-t+1)}=\frac{(1+x)^n}{x(n-t+1)},
\]
which is $\frac{1}{n-t+1}\binom{n}{d(v)+1}$.
Therefore,
\begin{align*}\label{eqn: Qt bound}
       \E[Q_t]&\le\sum_{v:\ d(v)<\epsilon \Delta}\frac{\binom{n-1}{d(v)}}{\binom{n-1}{d(v)}}\frac{1}{(1-\epsilon)\Delta}+\sum_{v:\ d(v)\ge \epsilon\Delta}\frac{\binom{n}{d(v)+1}}{\binom{n-1}{d(v)}}\frac{1}{n-t+1}\\
       &\le\sum_{v:\ d(v)<\epsilon \Delta}\frac{1}{(1-\epsilon)\Delta}+\frac{n}{n-t+1}\sum_{v:\ d(v)\ge \epsilon\Delta}\frac{1}{d(v)+1}.
\end{align*}
Notice $\epsilon$ here can be any constant, so the total number of query we need is 
\begin{align*}
    \E[\# \textrm{ of queries}]=\sum_{t=1}^n \E[Q_t]\le O(1)\cdot \frac{n}{\Delta}\cdot \sum_{t=1}^n\frac{n}{n-t+1} =O\left(\frac{n^2\log n}{\Delta}\right).
\end{align*}
\end{proof}
It is worth noting that this Las Vegas algorithm can be readily converted to a Monte Carlo algorithm that succeeds with probability 
$1-1/\mathrm{poly}(n)$, at the cost of an additional $\log n$ factor. By Markov's inequality, 
\[\Pr(\textrm{Algorithm 1 fails after }2\E[\# \textrm{ of queries}])\le 1/2.\]
Repeat this algorithm if it fails for $k\log_2 n$ times, the probability of failing all the time is bounded by $1/n^k$ for any constant $k$. 

%Such a Las Vegas algorithm can also be converted to a Monte Carlo algorithm: let the above algorithm runs until $n^{3/2}\sqrt{\log n}/\epsilon$. By Markov inequality, the probability that the algorithm fails is
% \[\Pr\{\text{Running time}\ge n^{3/2}\sqrt{\log n}/\epsilon\}\le \frac{\E[\text{Running time}]}{n^{3/2}\sqrt{\log n}/\epsilon}=\epsilon.\]
% This proves Theorem \ref{thm1}.

%IT WOULD BE NICE TO LEARN THE LOWER BOUND AND SEE IF WE CAN IMPROVE IT. MAYBE OUR ALGORITHM IS OPTIMAL? %




\section{Quantum Sublinear Algorithms}

In quantum computing, the fundamental unit of information is the qubit. Unlike a classical bit, which exists strictly in one of two states, 0 or 1, a qubit can exist in a superposition of both states simultaneously. Formally, a qubit is represented as a unit vector in the complex vector space $\C^2$.
Using Dirac’s ``bra-ket'’ notation, we denote a general qubit as $|\psi\rangle$ and denote the basis vectors for a pre-fixed orthonormal basis of $\C^2$ by $|0\rangle$ and $|1\rangle$.
Observing a qubit collapses its superposition to a definite basis state, $|0\rangle$ or $|1\rangle$. If we let $|\psi\rangle=\alpha|0\rangle+\beta|1\rangle$, then measuring a qubit yields $|0\rangle$ with probability $|\alpha|^2$ and $|1\rangle$ with probability $|\beta|^2$. For $n$ qubits, the system exists as a superposition of $2^n$ classical states, i.e \[|\psi\rangle = \sum_{0\le x\le 2^n-1}\alpha_x|x\rangle_n\textrm{, where }\sum_{0\le x\le 2^n-1}|\alpha_x|^2=1.\]
Qubits are manipulated by quantum gates, which can be represented as unitary transformations. Any operation of $n$ qubits can thus be described by a unitary transformation acting on $\C^{2^n}$. We refer the reader to \cite{Mermin_2007} for more details on quantum computing. 

In our problem, we transition from classical to quantum queries. Formally, any query problem can be viewed as evaluating an unknown function \( f: \{0,1\}^n \to \{0,1\}^m \), where \( f \) acts as an oracle, or black box, and each evaluation is called a query. The complexity is determined by the number of times \( f \) is queried. In the quantum setting, a standard approach to implementing \( f \) is to replace it with a unitary operator \( \mathcal{O}_f \) that acts on two registers: one for domain points and one for image points:
\[
\mathcal{O}_f |x, y\rangle = |x, y \oplus f(x)\rangle.
\]
Here, \( \oplus \) denotes the bitwise XOR operation. If \( f \) is binary-valued, we can also implement it as
\[
\mathcal{O}_f |x\rangle = (-1)^{f(x)} |x\rangle.
\]
To obtain this, we can apply the first oracle to $|x,-\rangle$, where $|-\rangle=\frac{1}{\sqrt{2}}(|0\rangle-|1\rangle)$, and only measure the first register. This conversion is sufficient for all known examples.

For instance, we consider a quantum adjacency query defined by the unitary map \( \mathcal{O}_A \) on the space \( \mathbb{C}^V \otimes \mathbb{C}^V \), given by
\[
\mathcal{O}_A |v, u\rangle = (-1)^{f_A(v, u)} |v, u\rangle,
\]
where \( f_A(v, u) = 1 \) if \( v \) and \( u \) are adjacent, and \( f_A(v, u) = 0 \) otherwise. Thus, when we refer to the number of quantum adjacency queries to \( G \), we mean the number of applications of \( \mathcal{O}_A \).


Morris and Song \cite{morrisSongColoring} observed that we can use Grover's \cite{grover98} algorithm to speed up the step of Algorithm \ref{alg: max degree color} where we check to see if vertex $v_{\sigma(t)}$ has a neighbor in the color class $\chi_t^{-1}(c)$ (they consider an algorithm for $(1+\epsilon)\Delta$-coloring that uses this same check as a subroutine).
Originally designed to find a unique marked item in an unsorted list of $N$ items,  Boyer, Brassard, H{\o}yer and Tapp \cite{boyer1998tight} showed that repeated applications of Grover's original algorithm could be used to find one of possibly multiple marked items, even when the number of marked items is unknown.

\begin{theorem}[Grover's Algorithm \cite{boyer1998tight}]\label{thm: Grover}
    Suppose we have an unsorted list of $N$ items, $k \geq 0$ of which are marked.
    Then there is a quantum algorithm that does the following:
    If $k > 0$, the algorithm outputs one marked item uniformly at random, using $O(\sqrt{N/k})$ quantum queries.
    If $k = 0$, then the algorithm concludes that there is no marked item using $O(\sqrt N)$ queries.
\end{theorem}
This will be the main tool we use to build our quantum algorithms. We will prove theorem \ref{thm: quantum adjacency} in section 3.1 and prove theorem \ref{thm: quantum neighborhood} in section 3.2
% This algorithm was shown to be tight (up to the constant factor implicit in the big-$\mathcal O$ notation) in \cite{bennett1997strengths}.
% With repeated applications of this algorithm, Boyer, Brassard, H{\o}yer and Tapp \cite{boyer1998tight} showed that we can achieve an expected runtime of $\mathcal O(\sqrt{N/k})$ when there are $k$ values of $x$ for which $f(x) = 1$ and $k$ is unknown (and possibly zero).

\subsection{Quantum algorithm for $(\Delta+1)$-coloring}
Recall that in our algorithm \ref{alg: max degree color}, we need to determine whether a vertex 
$v_{\sigma(t)}$ is adjacent to any vertex in $\chi_t^{-1}(c)$ — that is, we check if any vertex assigned color $c$ in step $t$ is a neighbor of $v_{\sigma(t)}$. In the quantum version of the algorithm, the only modification occurs in this checking step: we replace the classical search process with Grover's algorithm. 
\begin{proof}[Proof of Theorem \ref{thm: quantum adjacency}]
We apply the same argument as in the proof of Theorem \ref{thm: classical Delta+1}. In the classical setting, to color vertex $v_{\sigma(t)}$ with a randomly chosen color $c$, we bound the expected number of adjacency queries used to find a  neighbor of $v_{\sigma(t)}$ in $\chi_t(c)$ by $n/(\Delta+1)$.  Then
\[
\E_c [Q_t(\sigma)] \leq \frac{n}{\Delta+1}\cdot \frac{1}{p_t(\sigma)}.
\]
We aim to improve this bound in the quantum setting.
Specifically, we can view this checking process as an instance of the unstructured search problem in a list of size $|\chi_t^{-1}(c)|$. Applying Theorem \ref{thm: Grover}, we obtain
\begin{align*}
\E_c[Q_t(\sigma)]& \leq \frac{1}{p_t(\sigma)}\cdot  \E_c\left[O\left(\sqrt{|\chi_t^{-1}(c)|}\right)\right]\\
&\leq \frac{1}{p_t(\sigma)} \cdot O\left(\sqrt{\E_c[|\chi_t^{-1}(c)|]}\right)\\
&= O\left(\sqrt{\frac{n}{\Delta+1}}\cdot \frac{1}{p_t(\sigma)}\right).
\end{align*}
Here we used Jensen's inequality to move to the second line.
Taking the expectation over $\sigma$ and following the proof of Theorem \ref{thm: classical Delta+1} gives $O(\frac{n^{3/2}\log n}{\sqrt \Delta})$ quantum adjacency queries.



\end{proof}


We summarize this algorithm in Algorithm \ref{alg: quantum adjacency color}.
\vspace{3mm}

\begin{algorithm}[H]\label{alg: quantum adjacency color}
\caption{QuantumAdjacencyColor($G,\Delta$)}
%\State Choose a random ordering for the vertices, $V = \{v_{\sigma(1)}, \ldots, v_{\sigma(n)}\}$
Choose a permutation $\sigma\in S_n$ uniformly at random

\For{$t = 1, \ldots, n$}{
    \While{$v_{\sigma(t)}$ is not colored}{
        Choose a color $c$ uniformly at random in $[\Delta + 1]$

        \If{Grover's algorithm finds a neighbor of $v_{\sigma(t)}$ in $\chi_t^{-1}(c)$}{
            \textbf{break} choose a new color
        }
        Assign color $c$ to $v_{\sigma(t)}$ and update $\chi(c)$ with $v_{\sigma(t)}$ 
        % \For{$u \in \chi_t^{-1}(c)$}{
        %     Query $A_{u,v_{\sigma(t)}}$
            
        %     \If{$A_{u,v_{\sigma(t)}} = 1$}{
        %         \textbf{break} choose a new color
        %     }
        %     Assign color $c$ to $v_{\sigma(t)}$ and update $\chi(c)$ with $v_{\sigma(t)}$
        % }
    }
}
\Return the color assignment $\chi: V\to [\Delta+1]$
\end{algorithm}


% \begin{algorithm}[h]\label{alg: find conflict}
% \caption{FindConflict($G, v, S$)}
% %\State Choose a random ordering for the vertices, $V = \{v_{\sigma(1)}, \ldots, v_{\sigma(n)}\}$
% $|U\rangle \gets |S|^{-1/2}\sum_{u\in S}|v, u\rangle$

% \For{$t = 1, 2$}{
%     $|\psi\rangle \gets |U\rangle$
%     \RepTimes{$\frac{\pi}{4}\sqrt{|S|/t}$}{
%         $|\psi\rangle \gets \mathcal O_A |\psi\rangle$

%         Reflect $|\psi\rangle$ through $|U\rangle$
%     }
%     Measure $|\psi\rangle$ in the $\{|v, u\rangle:\ u\in S\}$ basis to obtain $|v,u\rangle$

%     \If{$A_{u,v} = 1$}{
%         \Return True
%     }
% }
% \Return False
% \end{algorithm}








\begin{comment}
    


\section{Coloring the random graph}

Before we present our next quantum algorithm, we present another coloring strategy.
Fix a graph $G$ and partition $V(G)$ into $V_1 \cup \cdots \cup V_t$, for some $t$.
Now color each induced subgraph $G[V_i]$ with its own color palette (i.e., if we color $G[V_i]$ with some palette $P_i$, then we require that $P_i\cap P_j = \emptyset$ for $i\neq j$).
This approach could be useful if the $G[V_i]$'s aren't too difficult to color and if we do not introduce too many colors by giving each $G[V_i]$ its own palette.
% We adapt the partitioning idea from \cite[Section 6]{AlonAssadi} to color $G := G_{n,p}$, $0<p<1$.
% In short, we partition $V(G)$ into $V_1 \cup \cdots \cup V_k$, for some $k$, and color the resulting induced subgraphs $G[V_i]$ with disjoint palettes. Notice for constant $0<p<1$, with high probability
% the chromatic number $\chi(G_{n,p})\le (\frac{1}{2}+o(1))\frac{n}{\log_b n}$, where $b = \frac{1}{1-p}$. 
% This is a well-known result of Bollab\'as \cite{bollobas_chromatic}, later improved by McDiarmid \cite{McDiarmid_random_chromatic}.

This partitioning strategy has been used by others \cite{AlonAssadi, ChangCongestedClique, parterCongest} for coloring in various models of computation.
In \cite{AlonAssadi}, for a fixed graph $G$, the partition is chosen at random from all equipartitions of $V(G)$ into $k$ parts, and all of the edges in each $G[V_i]$ are determined non-adaptively.
If $\Delta(G) > n/t$, then all pairs $\{u,v\} \in \binom{V_i}{2}$ are queried for adjacency.
Otherwise, the neighborhoods of each vertex are fully queried using neighborhood queries.
Finally, each $G[V_i]$ can be colored without the need for any further queries.

Our goal is to cut down the number of queries it takes to learn the edges in the $G[V_i]$'s.
Even if $\Delta(G) > n/t$, we may still query many non-adjacent pairs if we query all pairs $\{u,v\}\in \binom{V_i}{2}$.
Similarly, even if $\Delta(G) \leq n/t$, we may pick up many superfluous crossing edges in $E(V_i, V_j)$ when we fully query the neighborhood of each vertex (this reveals the entirety of $E(G)$, after all).

We accomplish our goal by cheating -- we will modify the behavior of our oracle.
Fix some ordering of $V(G) = \{v_1, \ldots, v_n\}$.
We now assume that neighborhood queries respect this ordering.
That is, for any vertex $u$, if $N(u) = \{v_{i_1}, v_{i_2}, \ldots, v_{i_{d(u)}}\}$ with $i_a < i_b$ for all $a<b$, then querying the $j$-th neighbor of $u$ returns $v_{i_j}$ (and some special symbol, e.g. $\perp$, if $j > d(u)$).
We will call these queries \emph{ordered neighborhood queries}.
We will also assume that we may query the degree of any vertex\footnote{We could ``manually'' obtain the degree of a vertex with $ O(\log n)$ neighborhood queries (ordered or otherwise) by using binary search.
This would incur $ O(n\log n)$ additional queries for our algorithm, which, as we will see, would not change the order of magnitude of the total number of queries.}.

\begin{theorem}
    There is a randomized algorithm that, given a random graph $G=G_{n,p}$, properly colors $G$ with $(1+\epsilon)np$ colors using $O(\epsilon^{-2}n\log n)$ ordered neighborhood queries in expectation.
\end{theorem}

\begin{proof}
    

We outline our algorithm, Algorithm \ref{alg: random graph}, for coloring $G = G_{n,p}$, the graph on $n$ vertices, each pair of which are joined by an edge with probability $p$ independently at random.
Fix some $t$ and some arbitrary $\epsilon > 0$.
Partition $V(G)$ into $t$ sets $V_1,\ldots ,V_t$, where for each $i$,
\[V_i=\left\{v_j: j\in \left[\frac{(i-1)n}{t}+1,\frac{in}{t}\right]\right\}.\]
By the Chernoff bound, Proposition \ref{chernoff}, with probability $1- O(ne^{-\epsilon^2np/3t})$, each $v$ has $(1\pm \epsilon)np$ neighbors in $G_{n,p}$, $(1\pm \epsilon)np/t$ of which are in the $V_i$ that contains $v$.
We can make this probability $1-O(1/n)$ by setting $t = \frac{\epsilon^2}{6}\frac{np}{\log n}$.

Suppose that $u\in V_i$ and that $N(u) = \{v_{j_1}, \ldots, v_{j_{d(u)}}\}$.
We can find the first neighbor of $u$ that belongs to $V_i$ (that is, the $v_{j_s}\in N(u)\cap V_i$ with minimal $s$) in $O(\log d(u)) = O(\log(np))$ ordered neighbor queries using binary search (with high probability).
Once we have this first neighbor of $u$ in $V_i$, we can obtain the rest of its neighborhood in $V_i$ by ordered neighbor querying its next $(1+\epsilon)np/t$ neighbors (with high probability).
This allows us to greedily color $G[V_i]$ with at most $(1+\epsilon)np/t$ colors and at most
\[
|V_i|\cdot \Delta(G[V_i]) \leq \frac nt \cdot (1+\epsilon)\frac{np}{t} = (1+\epsilon)\frac{n^2p}{t^2}
\]
ordered neighborhood queries (with high probability).
When we apply this procedure to all $t$ of the induced subgraphs, using disjoint color palettes for each subgraph, we use at most $(1+\epsilon)np$ colors and
\[
n\log(np) + \frac{6(1+\epsilon)}{\epsilon^2}n\log n
\]
ordered neighborhood queries.
Comparing to the $O(\frac{n^2\log n}{\Delta})$ adjacency queries (in expectation) of Algorithm \ref{alg: max degree color} and using the fact that $\Delta(G_{n,p}) = (1\pm\epsilon)np$, running Algorithm \ref{alg: max degree color} when $p \geq \frac{\epsilon^2}{5}$ and Algorithm \ref{alg: random graph} otherwise gives an algorithm that colors the random graph with $(1+\epsilon)\Delta(p)$ colors and $O(\epsilon^{-1}n\log n)$ queries.
%Comparing to the $n\Delta(G) \leq (1+\epsilon)n^2p$ queries of the greedy algorithm, using this algorithm when $p \geq \frac{10}{\epsilon^2}\frac{\log n}{n}$ colors $G$ in $\mathcal O(\frac{1}{\epsilon^2}n\log n)$ ordered neighbor queries. This proves Theorem \ref{thm: random_graph}. \textcolor{red}{I think we should compare to the adjacency query algorithm instead. The joke is finding when querying a color class is faster than querying neighbors.}


\begin{algorithm}[t!]\label{alg: random graph}
\caption{ColorRandomGraph($G_{n,p}, \epsilon$)}
%\State Choose a random ordering for the vertices, $V = \{v_{\sigma(1)}, \ldots, v_{\sigma(n)}\}$
Set $k \gets \frac{\epsilon^2}{6}\frac{np}{\log n}$

Let $P_1, \ldots, P_k$ be pairwise disjoint color palettes, each with $(1+\epsilon)\frac{np}{k}$ colors

Set $V_i \gets \{v_j: j\in [\frac{(i-1)n}{k}+1, \frac{in}{k}]\}$ for $1\leq i\leq k$

\For{$i=1,\dots,k$}{
    \For{$u\in V_i$}{
        $\ell \gets 1$

        $r \gets d(u)$
        
        \While{$\ell<r$}{ 
            $m\gets \lfloor\frac{\ell+r}{2}\rfloor$
            
            $v_s\gets $ OrderedNeighborQuery$(u,m)$
            
            \eIf{$s <  \frac{(i-1)n}{k}+1$}{
                $\ell \gets m+1$
                
            }{
                $r \gets m$
            }      
        }
        
        OrderedNeighborQuery$(u,j)$ for $j\in [m, m+(1+\epsilon)np/k]$ and let $\chi(u)$ be an arbitrary color from $P_i$ not seen among these neighbors.
    }
}
\Return The color assignment $\chi: V(G)\to P_1\cup \cdots \cup P_k$.
\end{algorithm}
%In practice, this modification should be natural. In the following, we will refer to our modified query model as the ``ordered query model", incorporating this extra assumption. With the extra assumption, $G$ can be colored by coloring each subgraph $G[V_i]$ with a distinct palette. The improvement of our modification is that inside each $G[V_i]$, we need approximately $\sum_{v\in V_i} d(v)/k$ many queries to learn all the edges \textcolor{red}{this comes from neighbor querying each vertex. Each has around $\Delta/k$ neighbors inside $V_i$ whp}. Hence we need less queries comparing to the method in \cite{AlonAssadi}, which need $\sum_{v\in V_i}d(v)$ queries. Let $C():=\chi(G_{n/k,p})$, with high probability, the following algorithm generate a valid $Ck$ coloring for $G_{n,p}$:

\end{proof}

\end{comment}


\subsection{Quantum algorithm for $(1+\epsilon)\Delta$-coloring}
Can we achieve a similar quantum speedup using neighborhood queries? Our motivating example is the following: Let \( G = G_{n,p} \) be the Erd\H{o}s-R\'enyi random graph, where each pair of vertices (independently) forms an edge with probability \( p \). Partition the vertex set \( V(G) = [n] \) into \( t \) subsets \( V_1, \ldots, V_t \) (assuming without loss of generality that \( t \mid n \)), where for each \( i \),
\[
V_i = \left[\frac{(i-1)n}{t} + 1, \frac{in}{t} \right].
\]
%Within each subgraph \( G[V_i] \), the degree of each vertex is bounded by \( (1+\epsilon)np/t \) with high probability by standard Chernoff bounds.
%Consequently, the indices of the neighbors of any vertex \( v \) within \( G[V_i] \) form an interval of length at most \( (1+\epsilon)np/t \).
 
Let's suppose that the neighborhood queries respect this vertex ordering—i.e., querying the \(i\)-th and \(j\)-th neighbors of \(v\) returns vertices \(u\) and \(w\), respectively, with \(u \le w\) when \(i \le j\).
Each vertex $v$ in $V_i$ has at most $(1+\epsilon)np/t$ neighbors in $V_i$ with high probability by the Chernoff bound, so the set of indices $I = \{1 \leq i \leq n: \text{the }i\text{-th neighbor of }v\text{ is in }V_i \}$ forms an interval of length at most $(1+\epsilon)np/t$.
We can then efficiently find the ``first'' neighbor of \(v\) within $G[V_i]$ using binary search and then query the next $(1+\epsilon)np/t$ neighbors to learn all of $N(v)\cap V_i$.

By repeating this process for each $v\in V_i$, we learn the entire edge set of $G[V_i]$.
We can now color each subgraph using a distinct color palette of size $(1+\epsilon)np/t$, thereby obtaining a proper $(1+\epsilon)np$-coloring of $G$ using only $O(n^2p/t)$ queries. For concentration of the degrees, we need $t=np/\log n$ and results an $O(n \log n)$ algorithm.  

This approach works well for random graphs because the neighbors of any particular vertex are more or less evenly distributed throughout the graph.
In the standard setting where neighborhood queries do not adhere to some fixed order, however, querying a specific interval of a vertex \(v\)’s neighbors may not capture neighbors that belong to the same part as \(v\).
If we could somehow pluck the neighbors of $v$ that live in $V_i$ from the neighborhood list of $v$, then we might be able to construct a proper coloring in fewer queries than the classical greedy algorithm.
We will show that Grover's algorithm allows us to accomplish exactly this in the quantum setting.


%On the other hand, through quantum neighbor query, we can efficiently learn the corresponding neighborhood inside each subgraph. 

%We claim that when we randomly (but equitably) partition the vertices of a graph $G$, we are able to learn all the edges inside each subgraph by $O()$
To begin, we define the oracle used in our quantum algorithm.
For any vertex $v\in V(G)$, $1\le j\le \Delta$, let the query function $f_N:V\times [\Delta]\to V\cup \{0\}$ be given by 
\[f(v,j)= \begin{cases}
u_j, &\text{ if $u_j$ is the $j$-th neighbor of $v$ }\\
0, &\text{ otherwise. }
\end{cases}\]
Then a quantum neighborhood query can be implemented by the map $\mathcal O_N$, which operates on $V\otimes [n]\otimes (V\cup \{0\})$ by
\begin{equation}\label{eqn: quantum neighborhood query}
\mathcal O_N |v, j, u\rangle = |v,j,u\oplus f(v,j)\rangle.
\end{equation}
This map is unitary, and moreover, self-inverse, i.e., $\mathcal O_N\circ \mathcal O_N=I_{V\otimes [n]\otimes (V\cup \{0\}) }$. 

Now we proceed with our algorithm.
We start by demonstrating that, when we randomly and equitably partition $V(G)$ into $t$ parts, that is, each part has size either $\lceil n/t\rceil$ or $\lfloor n/t\rfloor$, then a roughly $\frac 1t$-fraction of a vertex' neighborhood follows it to its part.

%We start by demonstrating that, when we select a random equitable partition of $V(G)$, where each part is nearly equal in size and chosen uniformly at random, the expected fraction of each vertex's neighborhood that remains within its part matches the intended proportion.

\begin{lemma}\label{lem: chernoff_degree}
    Fix $\epsilon > 0$ and let $G = (V, E)$ be a graph on $n$ vertices with maximum degree $\Delta$.
    Set $t = \frac{\epsilon^2\Delta}{6\log n}$.
    If we equitably partition $V = V_1 \cup \cdots \cup V_t$ at random, then with probability at least $1-\frac 1n$, the maximum degree of each $G[V_i]$ is at most $(1+\epsilon)\frac \Delta t$.
\end{lemma}
\begin{proof}
    Let $d_i(v)$ denote the number of neighbors of $v$ in $G[V_i]$ for each $v\in V_i$. Then $\E[d_i(v)]\le \frac{\Delta}{t}$.
    By the Chernoff bound, with $t=\frac{\epsilon^2\Delta}{6\log n}$
    \begin{align*}
        \Pr\left(d_i(v)\ge (1+\epsilon)\frac{\Delta}{t}\right)\le \exp\left(-\frac{\epsilon^2\Delta}{3t}\right)\le \frac{1}{n^2}.
    \end{align*}
    Now union bound over all $n$ vertices. 
\end{proof}


After partitioning $V(G)$ as in the above lemma, our plan is to assign each part its own color palette and mimic the greedy coloring algorithm in each part.
With this in mind, consider some $v\in V_i$.
With probability at least $1/4$, it takes $O(\sqrt \Delta)$ quantum neighborhood queries to Grover search $N(v)$ for a neighbor $u$ of $v$ that also lives in $V_i$ (or conclude that there is no such neighbor).
Moreover, the neighbor that Grover's algorithm outputs is random and uniformly distributed over all neighbors in $V_i$.
Finding all neighbors of $v$ that live in $V_i$ then amounts to running a sort of coupon collector process, with the twist that we have a $1/4$ chance of receiving a coupon at all.
We are still able to obtain a useful tail estimate despite this twist.

\begin{lemma}\label{lem: coupon collector}
    Consider a process where at each step, an event occurs with success probability $p$ and upon a success, one of $k$ distinct outcomes is chosen uniformly at random. Let $T$ be the number of steps required until all $k$ distinct outcomes have been observed at least once. Then for any positive constant $C$,
    \[
    \Pr\left[T \geq \frac Cp k \log k\right] \leq k^{-C+1}.
    \]
\end{lemma}
\begin{proof}
    The probability that the $i$-th outcome has not been observed after step $t$ is
    \[
    \left(1 - \frac pk  \right)^t \leq e^{-pt/k}.
    \]
    Union bounding over all $k$ coupons and setting $t = \frac Cp k \log k$ proves the result.
\end{proof}

As $v$ has at most $(1+\epsilon)\frac \Delta t$ neighbors in $V_i$ (with high probability), Lemma \ref{lem: coupon collector} shows that we need at most $O_\epsilon(\frac{\Delta}{t} \log \frac{\Delta}{t})$ Grover searches to find all of them.
Once we have these neighbors, we can assign $v$ a color not seen among them from the palette assigned to $V_i$.
We collect the details of this procedure in Algorithm \ref{alg: quantum neighborhood color}, \textbf{QuantumNeighborhoodColor}, and its subroutine, Algorithm \ref{alg: grover neighbors}, \textbf{GroverNeighbors}.
The proof of its correctness and analysis of its runtime will comprise the proof of Theorem \ref{thm: quantum neighborhood}.
\vspace{3mm}




\begin{algorithm}[H]\label{alg: quantum neighborhood color}
\caption{QuantumNeighborhoodColor($G, \epsilon$)}
%\State Choose a random ordering for the vertices, $V = \{v_{\sigma(1)}, \ldots, v_{\sigma(n)}\}$
Let $\mathcal P = \{V_1, \ldots, V_t\}$ be a random equitable partition of $V(G)$ into $t = \frac{\epsilon^2\Delta}{6\log n}$ parts

Let $P_1, \ldots, P_t$ be pairwise disjoint color palettes, each with $(1+\epsilon)\frac{\Delta}{t}$ colors

Prepare the operator $W = W(\mathcal P)$ as described in (\ref{eqn: partition operator})

\For{$i = 1, \ldots, t$}{
    \For{$v\in V_i$}{
        $N_i(v) \gets$GroverNeighbors$(G, v, \epsilon, \mathcal P, W)$

        Set $\chi(v)$ to an arbitrary color from $P_i$ not seen among those in $\chi^{-1}(N_i(v))$
    }
}

\Return The color assignment $\chi: V\to (P_1 \cup \cdots \cup P_t)$
\end{algorithm}



\SetKwFor{RepTimes}{repeat}{times}{end}


\begin{algorithm}[H]\label{alg: grover neighbors}
\caption{GroverNeighbors($G, v, \epsilon, \mathcal P, W$)}

$d\gets d(v)$

$k \gets \min\big( (1+\epsilon)\frac{\Delta}{t}, d  \big)$

$N_i(v) \gets \emptyset$

$|U\rangle \gets d^{-1/2}\sum_{j=1}^{d}|v, j, 0\rangle$

Prepare the operators $R_U = 2|U\rangle \langle U| - I$ and $R_B = \mathcal O_N W\mathcal O_N$

\RepTimes{$8k \log k\cdot \frac{\log n}{\log \log n}$}{
    $m\gets 1$
    
    \While{$m \leq \sqrt{d}$}{
        Set $j$ to a uniformly chosen random integer between 0 and $m$
    
        $|\psi\rangle \gets d^{-1/2}\sum_{j=1}^{d}|v, j, 0\rangle$
    
        $|\psi\rangle \gets (R_UR_B)^j|\psi\rangle$
    
        Measure $|\psi\rangle$ in the $\{|v, j, 0\rangle: 1\leq j\leq d\}$ basis to obtain $|v, j^*, 0\rangle$
    
        Let $u$ be the result of the classical neighborhood query for the $j^*$-th neighbor of $v$

        \If{$u\in V_i$}{

            $N_i(v) \gets N_i(v) \cup \{u\}$

            \textbf{break}

        }
    
        $m\gets \min( \frac{6}{5}m, \sqrt d)$
    }
}
\Return The set of neighbors $N_i(v)$
\end{algorithm}


% \begin{lemma}\label{lem: quantum neighborhood color}
%     Fix $\epsilon > 0$ and let $G = (V, E)$ be a graph on $n$ vertices with maximum degree $\Delta$.
%     Partition $V(G)$ as in Lemma \ref{lem: chernoff_degree}.
%     Then there is a quantum algorithm that properly colors the vertices of $G$ using at most $(1+\epsilon)\Delta$ colors and
%     \[
%     \mathcal O\left( \frac{1}{\epsilon^2}n (\log n)^2 \sqrt{\Delta} \right)
%     \]
%     quantum neighborhood queries.
%     This algorithm succeeds with probability at least $2/3$.
% \end{lemma}



\begin{proof}[Proof of Theorem \ref{thm: quantum neighborhood}]
    Set $t = \frac{\epsilon^2\Delta}{6\log n}$ and choose an equitable partition $V = V_1 \cup \cdots \cup V_t$ at random from the set of all such partitions and prepare the unitary operator $W$ on $V\otimes [n]\otimes (V\cup \{0\})$ that does the following:
    \begin{equation}\label{eqn: partition operator}
    W|v, j, u\rangle = \begin{cases}
    -|v, j, u\rangle, &\text{ if }u,v\in V_i\text{ for some }i\\
    |v, j, u\rangle,&\text{ otherwise}
    \end{cases}.
    \end{equation}
    In other words, $W$ indicates whether or not $u$ and $v$ lie in the same part.
    Constructing $W$ requires no knowledge of $E(G)$, and hence, uses no neighborhood or adjacency queries.

    We proceed part by part, coloring each vertex in that part one by one.
    To find the neighbors of $v\in V_i$ that also live in $V_i$, start by querying the degree $d(v)$ and then prepare the uniform superposition over the indices of its neighbors:
    \[
    |U_v\rangle = d(v)^{-1/2}\sum_{j=1}^{d(v)}|v, j, 0\rangle.
    \]

    Write $N(v) = \{u_1, \ldots, u_{d(v)}\}$ and suppose $v$ has $r(v)$ neighbors in its part $V_i$.
    If we define the states $|G\rangle$ and $|B\rangle$ by
    \[
    |G\rangle  = r(v)^{-1/2}\sum_{j: u_j \in V_i} |v, j, 0\rangle,\qquad |B\rangle = \big(d(v)-r(v)\big)^{-1/2}\sum_{j: u_j\notin V_i}|v, j, 0\rangle,
    \]
    then Grover's algorithm finds one of these $r(v)$ neighbors by manipulating the state $|U_v\rangle$ in the $|G\rangle,|B\rangle$-plane until it lies on (or sufficiently close to) $|G\rangle$.
    We accomplish this by repeatedly reflecting the current state about $|B\rangle$ and then about $|U_v\rangle$.
    Reflection through $|U_v\rangle$ is implemented by the unitary map
    \[
    R_U = 2|U_v\rangle \langle U_v| - I,
    \]
    and reflection through $|B\rangle$ is implemented with the quantum neighborhood oracle  $\mathcal O_N$ (\ref{eqn: quantum neighborhood query}) by
    \[
    R_B = \mathcal O_N W \mathcal O_N.
    \]
    The inner \texttt{while} loop of \textbf{GroverNeighbors} is the implementation of Grover's algorithm from \cite{boyer1998tight}, which outputs one of the $r(v)$ desired neighbors using $O(\sqrt{d(v)}) = O(\sqrt \Delta)$ queries, succeeding with probability at least $\frac 14$.


    
    % Apply $\mathcal O_N$ to this state to obtain the uniform superposition on $N(v) = \{u_1, \ldots, u_{d(v)}\}$.
    % Denote this state by $|U_v\rangle$.
    % \[
    % |U_v\rangle = d(v)^{-1/2}\sum_{j=1}^{d(v)}|v, j, u_j\rangle.
    % \]
    % This costs us $n$ degree queries. Next we apply a amplitude amplification on this qubit. In particular, we iterate the following two steps:
    %     \begin{enumerate}
    %         \item[(1)]\begin{center}$|\psi_v^i\rangle \gets \mathcal O_N^{-1}W^{i}\mathcal O_N |U_v\rangle.$\end{center}
    %         \item[(2)]\begin{center}Reflect $|\psi_v^i|$ through $|U_v\rangle$.\end{center}
    %     \end{enumerate}  
    % The first step applies our oracle $\mathcal O_N$ to obtain a uniform superposition of all the neighbors of $v$, then reflect those  in $V_i$. Specifically, let the index set $J_i(v)=\{j: u_j \textrm{ is the $j$-th neighbor of $v$ and $u_j\in V_i$} \}$,
    % \[|\psi_v^i\rangle =d(v)^{-1/2}\left(-\sum_{j\in J_i(v)}|v,j,0\rangle+\sum_{j\not\in J_i(v)}|v,j,0\rangle\right).\]
    % The second step can be implemented by the reflection operator $\mathcal{R}_v:=2|U_v\rangle\langle U_v|-1$. By doing so, we reflected $|\psi_v^i\rangle$ by the uniform superposition of all neighbors of $v$. Hence amplified the amplitude of those $|v,j,0\rangle$ with $j\in J_i(v)$.
    % Notice this process is similar to Grover's algorithm or any other amplitude amplification algorithm. For more references, see \cite{grover96,amp_Brassard_Hoyer97,grover98}. 
    
    Given that this inner loop returns a neighbor of $v$ that lives in $V_i$, it is uniformly distributed over these neighbors.
    Consequently, if we rerun Grover's algorithm until we have found all $r(v)$ of $v$'s neighbors that live in $V_i$, we obtain the modified coupon collector process from the setting of Lemma \ref{lem: coupon collector}.
    Applying this lemma with $p = \frac{1}{4}$, $k = (1+\epsilon)\frac \Delta t$ and $C = \frac{2\log n}{\log \log n}$, we see that $8k \log k \cdot \frac{ \log n}{\log \log n}$ Grover searches fail to find all neighbors in $V_i$ with probability less than $\frac{1}{4n}$.
    Once \textbf{GroverNeighbors} finds all relevant neighbors, \textbf{QuantumNeighborhoodColor} simply assigns $v$ a color not seen among these neighbors.

    This procedure fails to produce a proper $(1+\epsilon)\Delta$ coloring of $G$ only if, for some $i$ and $v\in V_i$, we fail to find all neighbors of $v$ that lie in $V_i$.
    When we include the possibility that the maximum degree of some $G[V_i]$ exceeds $(1+\epsilon)\frac \Delta t$ (Lemma \ref{lem: chernoff_degree}), the total failure probability is at most $\frac 14  + \frac 1n \leq \frac 13$.
    Upon totalling up the maximum number of iterations of the loops within \textbf{GroverNeighbors}, we see that the number of calls to the quantum neighborhood oracle $\mathcal O_N$ is at most
    \begin{align*}
        n\cdot O(\sqrt \Delta) \cdot O\left( \frac \Delta t \log \frac \Delta t \cdot \frac{ \log n}{\log \log n} \right) = O\left(\frac{1}{\epsilon^2} n (\log n)^2 \sqrt \Delta  \right).
    \end{align*}
    
    

\end{proof}
% \begin{algorithm}[h]\label{alg: prepare state}
% \caption{PrepareState($G, \mathcal P$)}
% %\State Choose a random ordering for the vertices, $V = \{v_{\sigma(1)}, \ldots, v_{\sigma(n)}\}$
% $|U\rangle \gets \sum_{v\in V} d(v)^{-1/2}\sum_{j=1}^{d(v)}|v, j, 0\rangle$

% $|\psi\rangle \gets |U\rangle$

% \RepTimes{$\frac{\pi}{2}\sqrt{t}$}{
%     $|\psi\rangle \gets \mathcal O_N^{-1}W_{\mathcal P}\mathcal O_N |\psi\rangle$

%     Reflect $|\psi\rangle$ through $|U\rangle$
% }

% $|\psi\rangle \gets \mathcal O_N|\psi\rangle$

% \Return $|\psi\rangle$
% \end{algorithm}




%\begin{proof}[Proof of Theorem \ref{thm: quantum neighborhood}]

% By Lemma \ref{lem: quantum neighborhood color}, \textbf{QuantumNeighborhoodColor} properly $(1+\epsilon)\Delta$-colors $G$ using $O(\epsilon^{-2}n\log^2n \sqrt \Delta)$ quantum neighborhood queries, while \textbf{QuantumAdjacencyColor} properly $\Delta$-colors $G$ with at most $O(n^{3/2}\log n / \sqrt \Delta)$ quantum adjacency queries.
% If we use \textbf{QuantumAdjacencyColor} when $\Delta \geq \epsilon^2\sqrt n / \log n$ and \textbf{QuantumNeighborhoodColor} otherwise, we obtain a combined randomized algorithm for $(1+\epsilon)\Delta$-coloring $G$ using $\tilde O(n^{5/4})$ quantum queries.


% \textbf{QuantumNeighborhoodColor} provide a valid $(1+\epsilon)\Delta$ coloring of $G$ using $\tilde{O}(\epsilon^{-1}n\sqrt{\Delta})$ quantum neighbor queries. Section 4 in \cite{morrisSongColoring} provide a $\tilde{O}\left(\epsilon^{-3/2}\frac{n^{3/2}}{\sqrt{\Delta}}\right)$ algorithm using quantum adjacency queries. Optimality is reached at $\Delta=\epsilon^{-1/2}\sqrt{n}$. So our algorithm makes $\tilde{O}(\epsilon^{-1/4}n^{5/4})$ queries combined with the existing algorithm.
%\end{proof}







\section{Discussion}
We would like to mention a few possibilities for future work.
\begin{itemize}
    \item \textbf{Improvement in $(\Delta+1)$-Coloring:} If we could obtain a $\tilde{O}(n\sqrt{\Delta})$ quantum neighborhood query algorithm for $(\Delta+1)$-coloring, we could combine it with our $\tilde{O}(n^{3/2}/\sqrt{\Delta})$ quantum adjacency query algorithm to achieve a $\tilde{O}(n^{5/4})$ query algorithm for $(\Delta+1)$-coloring.
    The factor of $(1+\epsilon)$ in our algorithm arises from the step where we randomly partition $V(G)$ to ensure that no vertex has too many neighbors within its own partition. However, using a random partition is unlikely to ensure that each vertex has at most $\frac{\Delta+1}{t}$ neighbors within its part. For the partitioning approach to be effective in $(\Delta+1)$-coloring, we suspect a more sophisticated partitioning method would be required.
    \item \textbf{Lower Bound for Quantum Algorithm:} In the classical setting, it is known that $\Omega(n^{3/2})$ queries are required for $(\Delta+1)$-coloring, and thus our classical algorithm is tight up to a $\sqrt{\log n}$ factor. However, in the quantum setting, a polynomial gap remains.  Morris and Song \cite{morrisSongColoring} showed that $\Omega(n)$ quantum adjacency queries are necessary for $O(\Delta)$-coloring by considering the optimality of Grover’s search algorithm, and we would like to know whether this bound can be achieved.
    \item \textbf{Other Computational Models:} It is worth noting that the query model is not the only interesting model in this area. The authors of \cite{assadiChenKhannaSublinear} and \cite{AlonAssadi} have also studied $(\Delta+1)$-coloring in the streaming and massively parallel computation (MPC) models, and the authors of \cite{ChangCongestedClique,parterCongest} consider the congested clique and local computational models.
    Could our algorithm, with appropriate modifications, be adapted to work in these models?
\end{itemize}

% BEGIN XIAONAN STUFF

% This algorithm works in the following way: for each vertex $v$ in the partition $V_i$, use binary search to find its smallest neighbor $t$ in $V_i$. Then ordered query a total of $(1+\epsilon)np/k$ many neighbors starting from $t$. We can learn all the edges in $V_i$ due to the following lemma: 


% \begin{lemma}\label{lem1}
% Let $G:=G_{n,p}$ be a random graph. $V=[n]$.  With parameters \[\epsilon>0, \hspace{1cm} 1\le k\le \frac{\epsilon^2 np}{9\log n}. \] 
% Suppose we segment $V$ into $k$ equal sized sets $V_1,\dots, V_k$, then with high probability, the max degree of $G[V_i]$ is at most $(1+\epsilon)np/k$.
% \end{lemma}
% \begin{proof}
%     Since $G_{n,p}$ is a random graph, so is each $G[V_i]$. 
%     For any $v\in V_i$, let $\deg_i(v)$ denote the number of neighbors of $v$ lies inside $V_i$. Then
%     \[\E[\deg_i(v)]=(n/k-1)p.\]
%     By Chernoff bound, when $k\le \frac{\epsilon^2\cdot np}{9\log n}$,
%     \[\Pr\big(|\deg_i(v)-\E[\deg_i(v)]|>\epsilon\E[\deg_i(v)]\big)\le \exp\left(-\frac{\epsilon^2}{3}(n/k-1)p\right)\le\frac{1}{n^3}.\]
%     Take a union bound on all $v\in V_i$ and all $i\in\{1,\dots, k\}$. We see with high probability, for each $i$, for all  $v\in V_i$, \[(1-\epsilon)(np/k)\le \deg_i(v)\le (1+\epsilon)(np/k).\] 
% \end{proof}
% \begin{proof}[Proof of Theorem 2]

% According to our algorithm, for a vertex $v\in V_i$, we will use binary search to find the smallest neighbor in $V_i$. Each search use at most $\log(d(v))\le \log(n)$ many queries.  Since the max degree in $G[V_i]$ is at most $(1+\epsilon)np/k$, ordered querying this many of neighbors following the smallest one will guarantee to find all of its neighbors in $G[V_i]$ with high probability. When all edges of $G[V_i]$ is fully learnt, we can color it with a distinct palette of size $\chi(G_{n/k,p})$. In expectation, the queries we used is at most
% \[\sum_{v\in V} \left((1+\epsilon)\frac{np}{k}+\log(d(v))\right)=\mathcal{\tilde{O}}(n^2p/k).\]

% While $\chi(G_{n/k,p})$ is a random variable, there are known results when $p$ is in particular range \cite{bollobas_chromatic, achlioptas2005two,Heckel_2018}. When $p$ is constant, $\chi(G_{n,p})\le (\frac{1}{2}+o(1))\frac{n}{\log_b n}$, where $b = \frac{1}{1-p}$ with high probability. Hence the total number of color we need is at most
% \[\sum_{i=1}^k \left(\frac{1}{2}+o(1)\right)\frac{n/k}{\log_b n/k}=O(\frac{n}{\log (n/k)})\]
% Take the optimal $k=\Theta(n/\log n )$, we see the total number of color is at most $O(n/\log\log n)$ while using $\mathcal{\tilde{O}}(n\log n )$ ordered queries. 

% For $p=d/n$, $0<d<1$, let $c^*$ be the smallest integer such that $d\le 2c\log c$. Achlioptas and Naor \cite{achlioptas2005two} proved that with high probability, $\chi(G_{n,d/n})= c^*$ or $c^*+1$. In particular $\chi(G_{n,d/n})\le d/2$. This means we can color $G_{n/k,p}$ with $d/2k$ colors and therefore color the whole graph with $d/2$ colors using $\mathcal{\tilde{O}}(n\log n )$ ordered queries. 

% This proves Theorem \ref{random_graph}.   

% \end{proof}

% In general, every graph with max degree $\Delta$ can be colored by $\Delta +1$ colors using $n\Delta$ queries by greedy algorithm we mentioned in the introduction. For random graph $G_{n,p}$, $\Delta\le (1+\epsilon)np$ with high probability. Hence a naive greedy algorithm color random graph with $(1+\epsilon)np+1$ colors using $O(n^2p)$ queries. We would like to address that our algorithm is faster than the greedy algorithm while using less colors in both dense and sparse cases.



% \textcolor{red}{Note that this is better than using adjacency queries: then we'd need like $|V_i|^2 = n^2/k^2$ queries per blob, for a total of $n^2/k$ queries. This isn't a real savings if $p$ is constant.}


%  END XIAONAN STUFF


% \begin{comment}
% \section{Proof of Theorem \ref{thm: quantum}}
% We start by partitioning $V$ into independent sets.

% Let $s = 100\sqrt{n\Delta}$ and let $V_1, \ldots, V_{\lfloor s\rfloor}$ be an equipartition of $V$, chosen uniformly at random from the set of all such partitions (that is, $|V_i| \in \{ \lfloor \sqrt{n/\Delta} \rfloor, \lceil \sqrt{n/\Delta}\rceil\}$ for $i = 1 \ldots, \lfloor s\rfloor$).
% Then, in expectation, each $V_i$ is an independent set. For
% \[\E[|e(V_i)|]=\sum_{(v,v')\in E} \Pr(v\in V_i\, \& \, v'\in V_i)\le \frac{n\Delta}{2}\cdot (1/s)^2=\frac{1}{200000}\ll 1.\]
% We can perform a quantum checking algorithm to make sure all $V_i$s are independent. (Can we always do this?)

% Now for each $V_i$, choose a color $c\in [(1+\epsilon)\Delta]$ uniformly at random and let $\chi_i^{-1}(c)$ be the color class of $c$, i.e. the set of vertices already assigned with $c$ before $V_i$. For each $v_{i,k}\in V_i$, $k\in [|V_i|]$, run a quantum edge checking algorithm between $v_{i,k}$ and $\chi_i^{-1}(c)$. If no edge found, assign the color $c$ to $v_{i,k}$, otherwise leave it uncolored. Let $V_i^{(1)}\subset V_i$ be the set of vertices remain uncolored.
% Choose a new color $c'$ at random from $[(1+\epsilon)\Delta]$ for $V_i^{(1)}$ and run the procedure again.
% Do this until $V_i$ is fully colored. 

% \begin{algorithm}[h]
% \caption{$(1+\epsilon)\Delta$-Quantum Color($G$)}
% \begin{algorithmic}
% %\State Choose a random ordering for the vertices, $V = \{v_{\sigma(1)}, \ldots, v_{\sigma(n)}\}$
% \For{$i = 1, \ldots, \lfloor s\rfloor$}
%     \While{$V_{i}$ is not fully colored}
%         \State Choose a color $c$ uniformly at random in $[(1+\epsilon)\Delta]$
%         \For{$k = 1,\dots,|V_i|$}
%             \State Quantum query $A(\chi_i^{-1}(c),v_{i,k})$
%             \If{$A_{u,v_{i,k}} = 1$}
%                 \State \textbf{skip}
%             \Else
%                 \State Assign color $c$ to $v_{i,k}$ and update $\chi(c)$
%             \EndIf
%         \EndFor
%     \EndWhile
% \EndFor
% \Return The color assignment $\{\chi^{-1}(1), \ldots, \chi^{-1}(1+\epsilon)\Delta\}$.
% \end{algorithmic}
% \end{algorithm}

% The running time of this quantum algorithm can be analyzed as following. For each $v_{i,k}\in V_i$, the expected edges between  $v_{i,k}$ and the random color class $\chi_i^{-1}(c)$ is at most $\frac{\Delta}{(1+\epsilon)\Delta}$ (Is this true?). Hence for each iteration in $V_i$, we expected to color
% \[\E[|V_i^{(j-1)}-V_i^{(j)}|]\ge \left(1-\frac{1}{1+\epsilon}\right)\cdot |V_i^{(j-1)}|.\]
% Thus in expectation, for each $V_i$, we will query 
% \[\E[\# \text{ of queries for }V_i]\le \sum_{m=1}^{\infty}\left(\frac{1}{1+\epsilon}\right)^m|V_i|\cdot |\text{queries of }A(\chi_i^{-1}(c),v_{i,k})|\le \frac{1}{\epsilon}\sqrt{n/\Delta}\cdot \sqrt{\frac{n}{(1+\epsilon)\Delta}}.\]
% Therefore the total expected running time is 
% \[\E[\text{Running time}]\le\E[\# \text{ of queries for }V_i]\cdot s\le \frac{1}{\epsilon}\frac{n^{3/2}}{\sqrt{\Delta}}.\]
% Again, compare this with the trivial greed algorithm. If we use our algorithm whenever $\Delta>n^{1/3}$, and greedy otherwise, we obtain an expected running time:
% \[\E[\text{Running time}]\le O(\epsilon^{-1}n^{4/3}).\]
% \end{comment}

%Ideally, we want good classical and quantum algorithms for $\Delta+1$ coloring a graph $G$ with max degree $\Delta$.
%We'll settle for good algorithms for $(1+\epsilon)\Delta$ coloring.
%We're trying to improve the results of Morris and Song \cite{morrisSongColoring}.







\bibliographystyle{abbrv}
\bibliography{coloring}



\end{document}