\documentclass[a4paper,UKenglish,cleveref,thm-restate]{lipics-v2021}

\nolinenumbers{}

\usepackage{ragged2e} % to justify text in abstract
\usepackage{graphicx}
\usepackage{svg}
\usepackage{balance}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage[utf8]{inputenc}
% \usepackage{url}
% \urlstyle{same}
% \usepackage{newtxmath}
\usepackage{float}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{multirow}
\usepackage{booktabs}
\usepackage{makecell}
\usepackage{amsthm}
\usepackage{thmtools}
\usepackage[makeroom]{cancel}
% \usepackage{thm-restate}
% \usepackage{wrapfig}
\usepackage{soul}
\usepackage{siunitx}
\usepackage{tablefootnote}
\usepackage{fancyvrb}
\VerbatimFootnotes
\usepackage[noEnd=true,indLines=true]{algpseudocodex}
\usepackage[ruled]{algorithm}
\tikzset{algpxIndentLine/.style={draw=black}}
%% \usepackage[newfloat=true]{minted}
%% \usepackage[newfloat=true,finalizecache]{minted}
\usepackage[newfloat=true,frozencache]{minted}
% \let\oldnl\nl% Store \nl in \oldnl
% \newcommand{\nonl}{\renewcommand{\nl}{\let\nl\oldnl}}% Remove line number for one line

\newmintedfile{rust}{
  linenos,
  numbersep=5pt,
  frame=lines,
  baselinestretch=1.05,
  fontsize=\footnotesize,
}

\sisetup{
group-separator = {,},
round-mode = places,
round-precision = 0,
group-minimum-digits = 3
}

\usepackage{afterpage}
% \usepackage[colorlinks=true,linkcolor=blue,urlcolor=magenta,citecolor=blue%magenta
% % ,allcolors=blue
% ]{hyperref}

\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    filecolor=magenta,
    urlcolor=magenta
}

\input{macros}
\input{packages}

\title{PtrHash: Minimal Perfect Hashing at RAM Throughput}

\author{Ragnar Groot Koerkamp}{ETH Zurich, Zurich, Switzerland}{ragnar.grootkoerkamp@inf.ethz.ch}{https://orcid.org/0000-0002-2091-1237}{ETH Research Grant ETH-1721-1 to Gunnar RÃ¤tsch.}

\ccsdesc{Theory of computation~Data structures design and analysis}
\ccsdesc{Information systems~Retrieval efficiency}

\authorrunning{R. Groot Koerkamp}
\Copyright{Ragnar Groot Koerkamp}

\supplementdetails[linktext={github.com/RagnarGrootKoerkamp/ptrhash}]{Software}{
    https://github.com/RagnarGrootKoerkamp/ptrhash
}

\keywords{Minimal perfect hashing; Compressed Data Structures}

\hideLIPIcs

%% \EventEditors{Solon P. Pissis and Wing-Kin Sung}
%% \EventNoEds{2}
%% \EventLongTitle{24th International Workshop on Algorithms in Bioinformatics (WABI 2024)}
%% \EventShortTitle{WABI 2024}
%% \EventAcronym{WABI}
%% \EventYear{2024}
%% \EventDate{September 2--4, 2024}
%% \EventLocation{Royal Holloway, London, United Kingdom}
%% \EventLogo{}
%% \SeriesVolume{312}
%% \ArticleNo{11}


\begin{document}

\hypersetup{pageanchor=false}
\maketitle

\begin{abstract}
\label{sec:orgadeced1}
\parag{Motivation.}
Given a set \(S\) of \(n\) keys, a minimal perfect hash function (MPHF) is a
collision-free bijective map \(\mphf\) from \(S\) to \(\{0, \dots, n-1\}\). These
functions have uses in databases, search engines, and are used in bioinformatics
indexing tools such as Pufferfish (using BBHash), and Piscem (PTHash).
PTHash is also used in SSHash, a data structure on $k$-mers that supports
membership queries. PTHash only takes around \(5\%\) of the
total space of SSHash, and thus, trading slightly more space for faster queries
is beneficial.
Thus, this work presents a (minimal) perfect hash function that
first prioritizes query throughput, while also allowing efficient construction
for \(10^9\) or more elements using 2.4~bits of memory per key.

\parag{Contributions.}
Both PTHash and PHOBIC first map all \(n\) keys to \(n/\lambda < n\) \emph{buckets}.
Then, each bucket stores a \emph{pilot} that controls the final hash value of the
keys mapping to it.
PtrHash builds on this by using 1) fixed-width (uncompressed) 8-bit pilots, 2) a construction
algorithm similar to cuckoo-hashing to find suitable pilot values. Further, it 3)
uses the same number of buckets \emph{and slots} for each part, with 4) a \emph{single}
remap table to map intermediate positions \(\geq n\) to \(<n\), 5) encoded using
per-cacheline Elias-Fano coding. Lastly, 6) PtrHash support \emph{streaming} queries, where we use
prefetching to answer a stream of multiple queries more efficiently than one-by-one processing.

\parag{Results.}
With default parameters, PtrHash takes 2.40~bits per key.
On 300 million string keys, PtrHash is as fast or faster
to build than other MPHFs, and at least \(1.75\times\) faster to query. When
streaming multiple queries, this improves to \(3.1\times\) speedup over the
fastest alternative, while also being significantly faster to construct.
When using \(10^9\) integer keys instead, query times are as
low as 12~ns/key when iterating in a for loop, or even down to 8~ns/key when using
the streaming approach, within \(10\%\) of the maximum memory-bound throughput.
\end{abstract}

\newpage

\hypersetup{pageanchor=true}
\setcounter{page}{1}


\section{Introduction}
\label{sec:org01e0707}
Given a set of \(n\) keys \(\{k_0, \dots, k_{n-1}\}\),
a \emph{hash function} maps them to some co-domain \([m] := \{0, \dots, m-1\}\).
When \(m\geq n\) and the hash is injective (collision-free), it is also called \emph{perfect}.
When additionally \(m=n\) and it is surjective onto \([n]\), it is \emph{minimal}.
Thus, a \emph{minimal perfect hash function} (MPHF) bijectively maps a set of \(n\) keys onto \([n]\).

\parag{Metrics.}
Various aspects of MPHF data structures can be optimized.
First, one could minimize its space usage and try to
approach the \(\log_2(e)=1.44\) bits/key lower bound \cite{mehlhorn82_mphf_size}.
Indeed, there are many recent works in this direction, such as Bipartite
ShockHash-RS, which gets below 1.5~bits/key \cite{shockhash,bipartite-shockhash,phf-thesis}.

In this paper, we focus primarily on optimizing for query throughput and
secondary on construction speed, while relaxing space usage up to 3~bits/key.
This continues the line of work of FCH \cite{fch}, PTHash \cite{pthash,pthash-2}, and
PHOBIC \cite{phobic}, that all provide relatively fast queries.

\parag{Problem statement.}
Construct a \emph{minimal perfect hash function}
data structure \(\mphf\) that is fast to query, ideally using one memory access
per lookup,
and fast to construct, while staying below 3~bits/key of space.

\parag{Motivation.}
Our main motivating application is to optimize the use of PTHash in SSHash~\cite{sshash}, a data structure to index a set of $k$-mers (sequences
of \(k\) DNA bases).
There, the MPHF only takes around \(5\%\) of the total space. Thus, a slightly
increased space usage of the MPHF has little effect on the total space, while
faster lookups could significantly improve the overall query speed. In this application,
$k$-mers are typically encoded as 64-bit integers, and thus we will focus our
attention on integer keys.

Further applications can be found in domains such as networking \cite{Lu_2006},
databases \cite{Chang_2005}, and
full-text indexing \cite{Belazzougui_2014}, where one could imagine hashing IP addresses,
URLs, or (compact) suffix-trie edge labels.

\parag{Contributions.}
We introduce PtrHash, a minimal perfect hash function that is primarily optimized for
query throughput and construction speed, at the cost of slightly more memory usage.
Compared to PTHash and PHOBIC, the main novelties are:
\begin{enumerate}
\item a fixed number of buckets \emph{and slots} per part, removing the need for
  a part-offset lookup;
\item the use of fixed-width 8-bit \emph{pilots}, so that no compact encoding is
  needed;
\item a pilot search based on cuckoo-hashing;
\item remapping using a \emph{single} remap table, again simplifying lookups;
\item a remap table based on a per-cacheline Elias-Fano encoding \cite{elias,fano}, CacheLineEF;
\item the use of \emph{prefetching} to \emph{stream} multiple queries in parallel.
\end{enumerate}

\parag{Results.}
When using 300 million string keys, PtrHash with default parameters takes 2.40~bits/key and is nearly as fast to construct as the fastest
other methods, while being much faster to query. Compared to the next-fastest
method to query, PtrHash provides \(1.75\times\) faster queries when looping naively, or \(3.1\times\) faster when streaming.

When using \(10^9\) integer keys instead, PtrHash can achieve a throughput of up to
12~ns/key when looping over queries, or even 8~ns/key when streaming, close to matching the
maximum throughput of random memory accesses of a single thread. In a
multi-threaded setting, PtrHash can fully saturate the DDR4 memory bandwidth
with 4 threads.
\section{Related work}
\label{sec:org04db7a4}
There is a vast amount of literature on (minimal) perfect hashing. Here we only
give a highlight of recent approaches. We refer the reader to Section 2 of
\cite{pthash-2} and Sections 4 and 8 of the thesis of Hans-Peter Lehmann
\cite{phf-thesis}, which contains a nice overview of the different approaches
taken by various tools.

\parag{Space lower bound.}
There is a lower bound of \(n \log_2(e)\)~bits to store a minimal perfect hash
function on \(n\) random keys \cite{mehlhorn82_mphf_size}.
To get some feeling for this bound, consider any hash function.
Intuitively the probability that this is
an MPHF is \(n!/n^n\). From this, it follows that at most, around
\(\log_2(n^n/n!)\approx n\log_2(e)\)~bits of information are needed to ``steer'' the hash
function in the right direction.
Now, a naive approach is to use a seeded hash function, and try
\(O(e^n)\) seeds until a perfect hash function is found. Clearly, that is not
feasible in practice.

\parag{Brute-force.}
When \(n\) is small, \(e^n\) can be sufficiently small to allow a bruteforce search
over \(n\). RecSplit exploits this by first partitioning the input
keys first into buckets, and then recursively splitting buckets until they have
size at most \(\ell \leq 16\). These \emph{leafs} can then be solved using brute-force, and the
overall space usage can be as low as 1.56~bits/key. SIMDRecSplit significantly
improves the construction time by using a meet-in-the-middle approach for the
leafs, and generally speeds up the implementation.
Consensus-RecSplit \cite{consensus} is a recent MPHF that is the first to
achieve construction time linear in \(1/\varepsilon\), where \(\varepsilon\) is the
bits-per-key space overhead on top of the \(\log_2(e)\) lower bound. Its core idea
is to efficiently encode the seeds for multiple sub-problems together.

\parag{Graphs.}
SicHash \cite{sichash} and its predecessor BPZ \cite{bpz} are based on
\emph{hypergraph peeling} \cite{mphf-peeling,hypergraph-peeling-bounds}: nodes are the \(n\) hash values, and each key
corresponds to a size-\(r\) hyper-edge. Then keys can be assigned a value
one-by-one as long as each set of \(k\) keys covers at least \(k+1\) values. This
is also alike cuckoo hashing, where each key has \(r=2\) target locations.
ShockHash~\cite{shockhash} then takes the RecSplit framework and uses an \(r=2\)
cuckoo table for the base case. It then tries \(O((e/2)^n)\) seeds until one is
found that allows building the cuckoo hash table.
Bipartite ShockHash-RS \cite{bipartite-shockhash}
further improves this by using meet-in-the-middle on the seeds, improving the
construction time to \(O\big(\big(\sqrt{e/2}\big)^n\big) = O(1.166^n)\). This is currently the
most space efficient approach. Bipartite ShockHash-Flat is a variant that trades
space for more efficient queries.

\parag{Fingerprinting.}
Fingerprinting \cite{chapman_2011,muller_2014} is a completely different
technique, and used in BBHash \cite{bbhash}. Here, the
idea is to start with any hash function mapping into \([\gamma n]\) for some
\(\gamma \geq 1\). Any slots that have exactly one element mapping to them are
marked with a 1, and the remaining \(n_1\) elements are processed recursively,
mapping them to \([\gamma n_1]\). Lookups are then done using rank queries on this
bitvector. FMPH \cite{fmph} has a much faster implementation of the construction that goes
down to 3.0~bits/key. FiPS \cite{phf-thesis} is a variant that trades some
space in the rank data structure for faster queries. FMPHGO \cite{fmph} is
variant that first splits keys into buckets, then uses a seeded hash function
that has a low number of collisions, and only then recurses into colliding keys.
This reduces the space usage and number of recursion steps, leading to faster
queries, but takes longer to construct.

\parag{Bucket placement.}
PtrHash builds on methods that first group the keys into
buckets of a few keys. Then, keys in the buckets are assigned their hash value
one bucket at a time, such that newly assigned values do not collide with
previously taken values. All methods iterate different possible key assignments
for each bucket until a collision-free one is found, but differ in the way
hash values are determined. To speed up the search for keys, large buckets are
placed before small buckets.

FCH \cite{fch} uses a fixed number of~bits to encode the seed for each bucket and
uses a \emph{skew} distribution of bucket sizes. The seed stored in each bucket
determines how far the keys are \emph{displaced} (shifted) to the right from their
initially hashed position. A fallback hash can be used if needed, and
construction can fail if that also does not work. CHD \cite{chd} uses uniform
bucket sizes, but uses a variable-width encoding for the seeds.
PTHash \cite{pthash} combines these two ideas and introduces a number of
compression schemes for the seed values, that are called \emph{pilots}. Instead of
directly generating an MPHF, it first generates a PHF to \([n']\) for
\(n'=n/\alpha \approx n/0.99\), and values mapping to positions \(\geq n\) are \emph{remapped} to
the skipped values in \([n]\). PTHash-HEM \cite{pthash-2} first partitions the keys, and uses this
to build multiple parts in parallel. This also enables external-memory construction.
Lastly, PHOBIC \cite{phobic} improves from the simple \emph{skew} distribution of
FCH to an \emph{optimal bucket assignment function}, which speeds up construction and
enables smaller space usage. Secondly, it partitions the input into parts of
expected size
2500 and uses the same number of buckets for each part. Then, it uses that the
pilot values of the \(i\)'th bucket of each part follow the same distribution, and
encodes them together. Together, this saves 0.17~bits/key over PTHash.
\section{PtrHash}
\label{sec:orge8f771f}

The core design goal of PtrHash\footnote{The
PT in PTHash stand for \emph{Pilot Table}. The
author of the present paper mistakenly understood it to stand for Pibiri and
Trani, the authors of the PTHash paper. Due to the current author's
unconventional last name, and PTGK not sounding great, the first initial (R) was
appended instead. As things go, nothing is as permanent as a temporary name.
Furthermore, we follow the Google style guide and avoid a long run of uppercase
letters, and write PtrHash instead of PTRHash.}
is to simplify PTHash to speed up both query speed
and construction time, at the cost of possibly using slightly more memory.
We first give a high level overview of PtrHash (\cref{sec:orgd1d6fb1}). Then, we explain
specific parts of PtrHash in more detail.

In \cref{sec:throughput}, we investigate \emph{batching} to improve query
throughput, and in \cref{sharding} we give details on the \emph{sharding} of the
input to construct PtrHash on large inputs.
\subsection{Overview}
\label{sec:orgd1d6fb1}

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{figs/overview}
\caption{\label{overview}Overview of PtrHash on \(n=23\) keys. The keys are
  hashed into \([H] = [2^{64}]\) and this range is split into \(P=2\) parts and
  \(B=5\) buckets per part. The key highlighted in yellow has a the 9'th
  smallest hash, and ends up in \emph{bucket} 4 (starting at index 0). The corresponding
  \emph{pilot} $p_4$ hashes the key to \emph{slot} 6.
  The array of pilots (grey background) is the main component of the PtrHash
  data structure, and ensures that all keys hash to different slots.
  The blue key has a hash in the second
  part (upper half) of hashes, in bucket 6. It gets hashed to slot 25, which is
  larger than the number of keys $n=23$. Thus, it is \emph{remapped} (along with
  the other red cells) into an
  empty slot $<n$ via a (compressed) list of free slots, which is the second
  main component of the data structure.}
\vspace{-1em}
\end{figure}

Before going into details, we first briefly explain the fully constructed
PtrHash data structure and how to query it, see \cref{overview} and \cref{query-code}. We also
highlight differences to PTHash \cite{pthash} and PHOBIC \cite{phobic}.

\parag{Parts and buckets.}
The input is a set of \(n\) \emph{keys} \(\{k_0, \dots, k_{n-1}\}\) that we want to hash to
\(n\) \emph{slots} \([n]:=\{0, \dots, n-1\}\).
We first hash the keys using a 64-bit hash function \(\h\) into
\(\{\h(k_0), \dots, \h(k_{n-1})\}\). The total space of hashes \([2^{64}]\)
is equally partitioned into \(P\) \emph{parts}, and the part of a key is easily found
as \(\left\lfloor P\cdot \h(k_i) / 2^{64}\right\rfloor\) \cite{fast-range}.
Then, the expected \(n/P\) keys in each part are partitioned into exactly \(B\) non-uniform \emph{buckets}:
each key has a \emph{relative position} \(x\) inside the part, and this is passed through
a \emph{bucket
assignment function} \(\gamma: [0,1)\mapsto[0,1)\) such as \(\gamma(x)=x^2\)
that controls the distribution of expected bucket
sizes \cite{phobic}, as explained in detail in \cref{bucket-fn}.
The result is then scaled to a bucket index in \([B]\):
\begin{align}
\begin{split}
  \part(k_i) &:= \left\lfloor P\cdot \h(k_i) / 2^{64}\right\rfloor,\\
  x &:= \big((P\cdot \h(k_i)) \bmod 2^{64}\big)/2^{64},\\
  \bucket(k_i) &:= \left\lfloor B\cdot \gamma(x)\right\rfloor.
\end{split}\label{eq:partbucket}
\end{align}
\vspace{-2em}

\parag{Slots and pilots.}
Now, the goal and core of the data structure is to map the \(n/P\) expected keys in each part to \(S\approx
(n/P)/\alpha\) \emph{slots}, where \(\alpha\approx 0.99\) gives us roughly \(\approx 1\%\) extra slots to
play with. The pilot for each bucket controls to which slots its keys map.
PtrHash uses fixed-width $8$-bit \emph{pilots} \(\{p_0, \dots,
p_{P\cdot B-1}\}\), one for each bucket. Specifically, key \(k_i\) in bucket \(\bucket(k_i)\) with pilot \(p_{\bucket(k_i)}\)
maps to slot
\begin{equation}
  \slot(k_i) := \part(k_i) \cdot S + \reduce(\h(k_i) \oplus \hp(p_{\bucket(k_i)}), S),\label{eq:slot}
\end{equation}
where \(\reduce(\cdot, S)\) maps the random 64-bit integer into \([S]\) as explained below.

Compared to PHOBIC and PTHash(-HEM) \cite{pthash-2}, there are two differences
here.
First, while we still split the input into parts, we assign each part
not only the same number of bukets, but also
the
\emph{same} number of slots, instead of scaling the number of slots with the
\emph{actual} size of each part. This removes the need to store a prefix sum of part
sizes, and avoids one memory access at query time to look up the offset of the
part.
Second, previous methods search for arbitrary large
pilot values that require some form of compression to store efficiently. Our
8-bit pilots can simply be stored in an array so that lookups are simple.

\parag{Construction.} The main difficulty of PtrHash is during construction (\cref{sec:construction}), where we must find values of the
pilots \(p_j\) such that all keys indeed map to different slots.
Like other methods, PtrHash processes multiple parts in parallel.
Within each part, it sorts the buckets from large to
small and ``greedily'' assigns them the smallest pilot value that maps the keys in
the bucket to slots that are still free.
Unlike other methods though, PtrHash only allows pilots up to \(255\). When no
suitable pilot is found, we use a method similar to (blocked) cuckoo hashing
\cite{cuckoo-hashing,dary-cuckoo-hashing}: a pilot with a minimal number of collisions is chosen,
and the colliding buckets are ``evicted'' and will have to search for a new pilot.
A similar approach was discovered independently by Stefan Hermann
\cite[Section 4.5]{phobic-thesis}.
\subsection{Details}
\label{sec:org0a4579c}

\begin{listing}[t]
  \rustfile[baselinestretch=1.00]{query.rs}%
  \vspace{-1.3em}%
\caption{\label{query-code}Rust code for a simple implementation of the query function.}
\end{listing}

We now go over some specific details.

\parag{Hash functions.}
The 8-bit pilots \(p_b\) are hashed into pseudo-random 64-bit integers by
using FxHash \cite{fxhash} for \(\hp\),
which simply multiplies the pilot with a \emph{mixing constant} \(\C\):
\begin{equation}
\hp(p) := \C \cdot p.
\end{equation}

When the keys are 64-bit integers, we use this same FxHash algorithm to hash
them (\(\h(k) := \C\cdot k\)), since multiplication by an odd constant is invertible modulo \(2^{64}\) and
hence collision-free.
For other types of keys, the hash function depends on the number of elements. When the
number of elements is not too far above \(10^9\), the probability of hash
collisions with a 64-bit hash function is sufficiently small, and we use
the 64-bit variant of xxHash \cite{xxhash,xxhash-rust}.
When the number of keys goes beyond \(2^{32} \approx 4\cdot 10^9\), the
probability of 64-bit hash collisions increases. In this case, we use the
\(128\) bit variant of xxHash.
The high 64~bits determine the part and bucket in \cref{eq:partbucket}, and the low
64~bits are used in \cref{eq:slot} to determine the slot.

\parag{The reduce function.} When 64-bit hashes are used, we must ensure that all bits of
the hash are used to avoid collisions. A simple choice would be \(\reduce(x,S) = x\bmod S\), which uses
all bits when \(S\) is \emph{not} a power of \(2\) and takes two multiplications using
\emph{fast mod} \cite{fast-mod}. Instead, we use \(S=2^s\), so that \(x\bmod 2^s\) is a simple bit-mask. Unfortunately, this only uses
the lower \(s\)~bits of the hash, while the \(part\) and \(bucket\) functions use the
high \(\log_2(P\cdot B)\)~bits, leaving some entropy in the middle bits unused.

As a solution, we first multiply \(x\) by the mixing constant \(\C\), and then take the low
\(s\)~bits of the high half. This uses all input bits and
only needs a single multiplication, giving a small speedup over fast mod:
\begin{equation}
  \reduce(x, 2^s) := \left\lfloor \C\cdot x/2^{64}\right\rfloor \bmod 2^s.
\end{equation}

\parag{Remapping.} Since each part has slightly (\(\approx 1\%\)) more slots than keys, some keys will map to an
index \(\geq n\), leading to a \emph{non-minimal} perfect hash function. To fix this,
those are \emph{remapped} back into the gaps left behind in slots \(<n\) using a
(possibly compressed) lookup table. This is explained in detail in \cref{remapping}.

Whereas PTHash-HEM uses a separate remap \emph{per part}, PtrHash only has a single
global remap table. PHOBIC directly builds a full \(\alpha=1\) table, and does
not need any remapping.

\parag{Parameter values.}
In practice, we usually use \(\alpha=0.99\).
Similar to PHOBIC, the number of buckets per part is set to \(B = \lceil(\alpha\cdot
S)/\lambda\rceil\), where \(\lambda\) is the expected size of each bucket and is around
\(3\) to \(4\).
The number of parts is \(P=\lceil n/(\alpha S)\rceil\).

\parag{Choosing the number of slots per part \(S\).}
PtrHash-HEM and PHOBIC randomly split the keys into parts, and a part with \(n_i\)
elements gets \(S_i=n_i/\alpha\) slots. In PtrHash, each part has the \emph{same}
number of slots \(S\). We would prefer many small parts, since
smaller parts fit better in cache and hence are faster to construct.
On the other hand, there is some variance in the part sizes, and the largest
parts will contain more than \(n/P\) keys.
In particular, for a given \(S\) and \(P=P(S)=\lceil n/(\alpha S)\rceil\), we estimate the size of the largest part as \(n/P +
\sqrt{n/P}\cdot \sqrt{2 \ln P}\). We then choose \(S\) as the smallest power of two for
which this is below \(S-1.5\sqrt{n/P}\), where the buffer ensures that, at least
in practice, a larger-than-expected largest part still fits.


\subsection{Construction}
\label{sec:construction}
Both PTHash-HEM and PHOBIC first partition the keys into parts, and then build
an MPHF part-by-part, optionally in parallel on multiple threads.
Within each part, the keys are randomly partitioned (\cref{overview}) into
\emph{buckets} of average size \(\lambda\).
Then, the buckets are sorted from large to small, and one-by-one \emph{greedily} assigned a
\emph{pilot}, such that the keys in the bucket map to \emph{slots} not yet covered by earlier buckets.

As more buckets are placed, there are fewer remaining empty slots, and searching for pilots becomes harder.
Hence, PTHash uses \(n/\alpha > n\) slots
to ensure there sufficiently many empty slots for the last pilots. This speeds
up the search and reduces the values of the pilots.
PHOBIC, on the other hand, uses relatively small parts of expected size 2500, so that
the search for the last empty slot usually should not take much more than 2500 attempts.
Nevertheless, a drawback of the greedy approach is that pilots values have an uneven
distribution, making it somewhat harder to compress them while still allowing
fast access (e.g. requiring the interleaved coding of PHOBIC).

\parag{Hash-evict.} In PtrHash, we instead use \emph{fixed width}, single byte pilots. To achieve
this, we use a technique resembling cuckoo hashing \cite{cuckoo-hashing} that
was also independently found in \cite[Section 4.5]{phobic-thesis}.
As before, buckets are greedily \emph{inserted} from large to small. For some buckets,
there may be no pilot in \([2^8]\) such that all its keys map to empty slots. When
this happens, a pilot is found with the lowest weighted number of \emph{collisions}.
The weight of a collision with an element of a bucket of size \(s\) is \(s^2\), to prevent
\emph{evicting}%
\footnote{We would have preferred to call this method hash-displace, as
\emph{displace} is the term used instead of \emph{evict} in e.g. the cuckoo filter~\cite{cuckoo-filter}.
Unfortunately, \emph{hash and displace} is already taken
by hash-and-displace~\cite{hash-displace,chd}.}
large buckets, as those are harder to place.
The colliding buckets are evicted by emptying the slots they map to and
pushing them back onto the priority queue of remaining buckets.
Then, the new bucket is inserted, and the next largest remaining or evicted
bucket is inserted.

\parag{Implementation details.} In order to speed up the code to search for pilots, a number of
optimizations are made.
\begin{itemize}
\item \textbf{\texttt{taken} bit mask.} Like PTHash and PHOBIC,
we keep a \texttt{taken} bit mask that indicates for each slot whether it was taken.
This keeps the array small so it can be cached efficiently.
\item \textbf{Collision-free hot path.} When searching for pilots, we first test if there
is a pilot without any collisions. This is usually the case, and is faster
since it only needs access to the bit vector. Additionally, where there
\emph{is} a collision, we know a pilot is optimal when it collides with exactly
one bucket of minimal size, allowing for an early break.
\item \textbf{Avoiding loops.} To avoid repeated patterns of the same buckets evicting
each other, the search for a pilot starts at a random number in \([2^8]\),
rather than always restarting at 0.
\item \textbf{Avoiding loops more.} Each time a bucket is placed that evicted some other
bucket(s), it is added to a list of the 16 most recently placed buckets.
Buckets in this list are never evicted. This avoids short cycles, where for
example two buckets keep evicting each other from the same slot.
\end{itemize}

\parag{Analysis.} Unfortunately, we do not currently have a formal analysis showing
that the hash-evict method works with high probability given that certain
criteria are met. Ideally, the analysis of \cite[Section 5]{phobic-thesis} would
be extended to fully cover our method. In \cref{sec:org283efff}, we show some practical results.
\subsection{Bucket Assignment Functions}

\begin{figure}[t]
  \centering
  \begin{subfigure}[t]{0.49\linewidth}
    \includesvg[width=1\linewidth]{plots/bucket-fn}
  \end{subfigure}
  \hfill
  \begin{subfigure}[t]{0.49\linewidth}
    \includesvg[width=1\linewidth]{plots/bucket-size}
  \end{subfigure}
\caption{\label{bucket-fn}The left shows various bucket assignment functions \(\gamma\), such as the piecewise linear function (skewed) used by FCH and PTHash, and the optimal function introduced by PHOBIC. Flatter slopes at \(x=0\) create larger buckets, while steeper slopes at \(x=1\) create more small buckets, as shown on the right, as the distribution of expected bucket sizes given by \((\gamma^{-1})'\) when the expected bucket size is \(\lambda=4\).}
\end{figure}

During construction, slots fill up as more buckets are
placed. Because of this, the first buckets are much easier to place than the
later ones, when only few empty slots are left.
To compensate for this, we can introduce an uneven distribution of bucket
sizes, so that the first buckets are much larger and the last buckets
are smaller.
FCH \cite{fch} accomplishes this by a \emph{skew} mapping that assigns \(60\%\) of the
elements to \(30\%\) of the
buckets, so that those \(30\%\) are \emph{large} buckets while the remaining \(70\%\)
is \emph{small} (\cref{bucket-fn}). This is also the scheme used by PTHash.

\parag{The optimal bucket function.}
PHOBIC \cite{phobic} provides a more thorough analysis and uses the optimal function
\(\gamma_p(x) = x + (1-x)\ln (1-x)\) when the target load factor is \(\alpha=1\).
A small modification is optimal for \(\alpha<1\) \cite[Appendix B]{phobic-full},
but for simplicity we only consider the original \(\gamma_p\).
This function has derivative 0 at \(x=0\), so
that many \(x\) values map close to 0.
In practice, this causes the largest buckets to have size much larger than \(\sqrt S\).
Such buckets are hard to place, because by the birthday paradox they are likely
to have multiple elements hashing to the same slot. To fix this, PHOBIC ensures the
slope of \(\gamma\) is at least \(\varepsilon=1/\big(5 \sqrt S\big)\) by using
\(\gamma_{p,\varepsilon}(x) = x + (1-\varepsilon)(1-x)\ln(1-x)\) instead.
For simplicity in the implementation, we fix \(\varepsilon = 1/{2^8}\) which works
well in practice.

\parag{Approximations.}
For PtrHash, we aim for high query throughput, and thus we would like to only
use simple computations and avoid additional lookups as much as possible.
To this end, we replace the \(\ln (1-x)\) by its
first order Taylor approximation at \(x=0\), \(\ln(1-x) \approx -x\), giving
the quadratic \(\gamma_2(x) := x^2\). Using the second order approximation \(\ln(1-x) \approx
-x-x^2/2\) results in the cubic \(\gamma(x) = (x^2+x^3)/2\). This version again
suffers from too large buckets, so in practice we use \(\gamma_3(x) :=
\frac{255}{2^8}\cdot (x^2+x^3)/2 + \frac{1}{2^8}\cdot x\).
We also test the trivial \(\gamma_1(x):=x\).

These values can all be computed efficiently by using that the input and output
of \(\gamma\) are 64-bit unsigned integers representing a fraction of \(2^{64}\),
so that e.g. \(x^2\) can be computed as the upper 64-bits of the widening \(64\times64\to 128\) bit
product \(x\cdot x\).
\subsection{Remapping using CacheLineEF}
\label{remapping}
Like PTHash, PtrHash uses a parameter \(0<\alpha\leq 1\) to use a total of
\(n'=n/\alpha\) slots, introducing \(n'-n\) additional free slots.
As a result of the additional slots, some, say \(R\), of the keys will map to positions \(n\leq
q_0<\dots< q_{R-1}< n'\), causing the perfect hash function to not be \emph{minimal}.

\parag{Remapping.} Since there are a total of \(n\) keys, this means there are exactly \(R\) empty
slots (gaps) left behind in \([n]\), say at positions \(L_0\) to \(L_{R-1}\).
We \emph{remap} the keys that map to positions \(\geq n\) to the empty slots at
positions \(< n\) to obtain a \emph{minimal} perfect hash function.

A simple way to store the remap is as a plain array \(\free\), such that
\(\free[q_i-n] = L_i\).
PTHash encodes this array using Elias-Fano coding \cite{elias,fano}, after setting undefined
positions of \(\free\) equal to their predecessor.
The benefit of a plain \(\free\) array is fast and cache-local lookups, whereas
Elias-Fano coding provides a more compact encoding that typically requires multiple
lookups to memory.


\parag{CacheLineEF.}
We would like to answer each query by reading only a single cache line from
memory. To do this, we use a method based on \emph{interleaving} data.
First, the list of non-decreasing \(\free\) positions is split into chunks of
\(C=44\) values \(\{v_0, \dots, v_{43}\}\), with the last chunk possibly containing fewer values.
We assume that values are at most 40~bits, and that the average stride in each
block is not more than 500.
Then, each chunk is encoded into 64 bytes that can be stored as single cache
line, as shown in \cref{cacheline-ef}.

We first split all values into their 8 \emph{low} bits (\(v_i \bmod 2^8\)) and 32
\emph{high} bits (\(\lfloor v_i/2^8\rfloor\)). Further, the high part is split into an
\emph{offset} (the high part of \(v_0\)) and the \emph{relative} high part:
\begin{equation}
v_i =
2^8\cdot\underbrace{\lfloor v_0/2^8\rfloor}_{\text{Offset}} +
2^8\cdot \underbrace{\left(\lfloor v_i/2^8\rfloor - \lfloor
v_0/2^8\rfloor\right)}_{\text{Relative high part}}
+\underbrace{(v_i\bmod 2^8)}_{\text{Low bits}}.
\label{eq:clef}
\end{equation}
This is stored as follows.
\begin{itemize}
\item First, the 32 bit offset \(\lfloor v_0/2^8\rfloor\) is stored.
\item Then, the relative high parts are encoded into 128~bits. For each \(i\in[44]\), bit \(i + \lfloor
  v_i/2^8\rfloor - \lfloor v_0/2^8\rfloor\) is set to 1.
Since the \(v_i\) are increasing, each \(i\) sets a distinct bit, for a total of 44 set bits.
\item Lastly, the low 8~bits of each \(v_i\) are directly written to the 44 trailing bytes.
\end{itemize}

\begin{figure}[t]
\centering
\includegraphics[width=\linewidth]{figs/cacheline-ef}
\caption{\label{cacheline-ef}Overview of the CacheLineEF data structure.}
\end{figure}

\parag{Lookup.} The value at position \(i\) is found by summing the terms of
\cref{eq:clef}. The offset and low bits can be read directly.
This relative high part can be found as \(2^8\cdot(\select(i)-i)\), where \(\select(i)\) gives
the position of the \(i\)'th 1 bit in the 128-bit-encoded relative high parts. In practice, this can be implemented
efficiently using the \texttt{PDEP} instruction provided by the BMI2 bit manipulation
instruction set \cite{fast-select}.

\parag{Limitations.} CacheLineEF uses \(64/44\cdot 8 = 11.6\)~bits per value, which is
more than the usual Elias-Fano, which for example takes \(8+2=10\)~bits per value for data
with an average stride of \(2^8\).
Furthermore, values are limited to 40~bits, covering \(10^{12}\)~items.
The range could be increased to 48 bit numbers by storing 5 bytes of the
offset, but this has not been necessary so far.
Lastly, each CacheLineEF can only span a range of around \((128-44)\cdot 2^8 =
21\ 504\), or an average stride of 500.
This means that for PtrHash, we only use CacheLineEF when \(\alpha\leq 0.99\), so that the
average distance between empty slots is 100 and the average stride of 500 is
not exceeded in practice. When \(\alpha > 0.99\), a simple plain array can be used
instead without much overhead.

\parag{Comparison.}
Compared to Elias-Fano coding, CacheLineEF stores the low order bits as exactly
a single byte, removing the need for unaligned reads. Further, the select
data structure on the high-order bits is replaced by a few local bit-wise operations.
CacheLineEF is also somewhat similar to \emph{(Uniform) Partitioned Elias-Fano Index}
\cite{partitioned-elias-fano}, in that both split the data.
The uniform partitioned index also uses fixed part sizes, but encodes them with
variable widths, and adds a second level of EF
to encode the part offsets. Instead, CacheLineEF prefers simplicity and uses
fixed part sizes with a constant width encoding and simply stores the offsets directly.

\begin{figure}[t]
\centering
\includesvg[width=\linewidth]{plots/bucket_fn_stats}
\caption{\label{bucket-fn-plot}Bucket size distribution (red) and average number of evictions (black) per additionally placed bucket during construction of the pilot table, for different bucket assignment functions. Parameters are \(n=10^9\) keys, \(S=2^{18}\) slots per part, and \(\alpha=0.98\), and the red shaded load factor ranges from 0 to \(\alpha\). In the first five plots \(\lambda=3.5\) so that the pilots take \(2.29\) bits/key. For \(\lambda=4.0\) (bottom-right), the linear, skewed, and optimal bucket assignment functions cause endless evictions, and construction fails. The cubic function does work, resulting in 2.0~bits/key for the pilots.}
\end{figure}



\section{Results}
\label{sec:org283efff}
We now evaluate PtrHash construction and query throughput for
different parameters, and compare PtrHash to other minimal perfect hash functions.
All experiments are run on an Intel Core i7-10750H CPU with 6 cores and
hyper-threading disabled.
The frequency is pinned to 2.6 GHz.
Cache sizes are 32 KiB L1 and 256 KiB L2 per core, and 12 MiB shared L3 cache. Main
memory is 64 GiB DDR4 at 3200 MHz, split over two 32 GiB banks.

In \cref{construction-eval}, we compare the effect of various parameters and
configurations on the size, construction speed, and query speed of PtrHash.
In \cref{sec:comparison}, we compare PtrHash to other methods.

Additionally, in \cref{query-eval} we investigate query throughput with
batching and when using multiple threads. In \cref{sharding-eval} we
compare various sharding methods, and lastly in \cref{hash-eval} we compare the effect
of different input types and hash functions on query throughput.
\subsection{Construction}
\label{construction-eval}
The construction experiments use \(10^9\) random 64-bit integer keys,
for which the data structure takes
over 300 MB and thus is much larger than L3 cache. Unless otherwise mentioned,
construction is in parallel using 6 cores.
For the query throughput experiments, we also test on
20 million keys, for which the data structure take around
6 MB and easily fit in L3 cache.
To avoid the time needed for hashing keys, and since our motivating application
is indexing $k$-mers that fit in 64~bits, we always use random 64-bit integer keys, and hash them using FxHash.
\subsubsection{Bucket Functions}
\label{sec:org222e6a1}

In \cref{bucket-fn-plot}, we compare the performance of different bucket assignment
functions \(\gamma\) in terms of the bucket size distribution and the number of
evictions for each additionally placed bucket.
We see that the linear \(\gamma_1(x) = x\) has a lot of evictions for the last
buckets of size \(3\) and \(2\), but like all methods it is fast for the last
buckets of size \(1\) due to the load factor \(\alpha < 1\). The optimal
distribution of PHOBIC performs only slightly better than the skewed one of FCH and
PTHash, and can be seen to create more large buckets since the load factor
increases fast for the first buckets.
The cubic \(\gamma_3\) is clearly much better than all other functions, and is
also tested with larger buckets of average size \(\lambda = 4\), where all other
functions fail.

In the remainder, we will test the linear \(\gamma_1\) for simplicity and lookup
speed, and the cubic~\(\gamma_3\) for space efficiency.
\subsubsection{Tuning Parameters for Construction}
\label{sec:org24c954f}

\begin{figure}[t]
\centering
\includesvg[width=\linewidth]{plots/size}
\caption{\label{fig:construction}This plot shows the construction time (blue and red, left axis) and data structure size (black, green, and yellow, right axis) as a function of \(\lambda\) for \(n=10^9\) keys. Parallel construction time on 6 threads is shown for both the linear and cubic \(\gamma\), and for various values of \(\alpha\) (thickness). The curves stop because construction times out when \(\lambda\) is too large. For each \(\lambda\), the black line shows the space taken by the array of pilots. For larger \(\lambda\) there are fewer buckets, and hence the pilots take less space. The total size including the remap table is shown in green (plain vector) and yellow (CacheLineEF) for various \(\alpha\). The blue (fast), black (default), and red (compact) dots highlight the chosen parameter configurations.}
\end{figure}

In \cref{fig:construction} we compare the multi-threaded construction time and space usage of PtrHash on
\(n=10^9\) keys for
various parameters \(\gamma\in \{\gamma_1, \gamma_3\}\), \(2.7\leq \lambda\leq 4.2\),
\(\alpha\in \{0.98, 0.99, 0.995, 0.998\}\), and plain remapping or CacheLineEF.
We see that for fixed \(\gamma\) and \(\alpha\), the construction time appears to
increase exponentially as \(\lambda\) increases, until it times out due to a
never-ending chain of evictions.
Load factors \(\alpha\) closer to \(1\) (thinner lines) achieve smaller overall data
structure size, but take longer to construct and time out at smaller \(\lambda\).
The cubic \(\gamma_3\) is faster to construct than the identity \(\gamma_1\) for
small \(\lambda \leq 3.5\). Unlike \(\gamma_1\), it also scales to much larger
\(\lambda\) up to \(4\), and thereby achieves significantly smaller overall size.

We note that for small \(\lambda\), construction time does converge to around 19~ns/key.
A rough time breakdown is that for each key, 1~ns is spent on hashing, 5~ns
on sorting all the keys, 12~ns to find pilots, and lastly 1~ns on remapping
to empty slots.

\parag{Recommended parameters.}
Based on these results, we choose three sets of parameters for further
evaluation, as indicated with blue, black, and red dots in \cref{fig:construction}:
\begin{itemize}
\item \textbf{Fast} (blue), aiming for query speed: using the linear \(\gamma_1\), \(\lambda=3.0\), \(\alpha=0.99\), and a plain
vector for remapping.
Construction takes only just over 20~ns/key, close to the apparent lower
bound, and space usage is 3~bits/key. This can be used when \(n\) is small, or
more generally when memory usage is not a bottleneck.
\item \textbf{Default} (black), a trade-off between fast construction and small
space: using cubic \(\gamma_3\), \(\lambda=3.5\), and \(\alpha=0.99\), with
CacheLineEF remapping.
\item \textbf{Compact} (red), aiming for small space: using the cubic \(\gamma_3\), \(\lambda=4.0\), \(\alpha=0.99\), and
CacheLineEF remapping. Construction now takes around 50~ns/key, but the data
structure only uses 2.12~bits/key.
In practice, this configuration sometimes ends up in endless eviction cycles
and \(\lambda=3.9\) may be better.
\end{itemize}
\subsubsection{Remap}
\label{sec:org2831d24}

\begin{table}[t]
\caption{\label{remap}Comparison of space usage (bits/key) and query throughput
  (ns/query) of PtrHash when using the recommended parameters with different remap structures. Query throughput is shown both for perfect hashing (without remap), and for minimal perfect hashing (with remap). Additionally, query throughput is shown both for a for-loop and for streaming.}
\centering
\setlength{\tabcolsep}{5pt}
\begin{tabular}{lrrrlrrr}
\toprule
Configuration & Pilots & \multicolumn{2}{c}{Query PHF} & \multicolumn{2}{c}{Remap} &
\multicolumn{2}{c}{Query MPHF} \\
\cmidrule(lr){3-4}
\cmidrule(lr){5-6}
\cmidrule(lr){7-8}
 & Space & Loop & Stream & Type & \hspace{-4em} Space& Loop & Stream\\
\midrule
Fast & 2.67 & 11.6 & 8.6 & Vec<u32> & 0.33 & 12.7 & 8.9\\
 &  &  &  & CacheLineEF & 0.12 & 12.1 & 8.9\\
 &  &  &  & EF & 0.09 & 14.4 & 9.7\\
\midrule
Default & 2.29 & 17.6 & 7.9 & Vec<u32> & 0.33 & 20.0 & 8.6\\
 &  &  &  & CacheLineEF & 0.12 & 21.0 & 8.7\\
 &  &  &  & EF & 0.09 & 21.2 & 9.6\\
\midrule
Compact & 2.00 & 17.5 & 7.9 & Vec<u32> & 0.33 & 20.0 & 8.5\\
 &  &  &  & CacheLineEF & 0.12 & 21.0 & 8.6\\
 &  &  &  & EF & 0.09 & 21.3 & 9.5\\
\bottomrule
\end{tabular}
\end{table}

In \cref{remap}, we compare the space usage and query throughput of the different remap
data structures for both the fast and compact parameters, for \(n=10^9\) keys. We observe that
the overhead of CacheLineEF is \(2.75\times\) smaller than a plain vector, and only \(40\%\) larger
than true Elias-Fano encoding.

The speed of non-minimal (PHF) queries that do not remap does not depend
on the remap structure used.

For \emph{minimal} (MPHF) queries with the for loop, EF is significantly slower
(14.2~ns) with the fast parameters than the plain vector (12.5~ns), while
CacheLineEF (12.9~ns) is only slightly slower.
The difference is much smaller with the compact parameters, because the
additional computations for the cubic \(\gamma_3\) reduce the number of iterations
the processor can work ahead.
When streaming queries, for both parameter choices CacheLineEF is less than 0.1~ns slower than the
plain vector, while EF is 1~ns slower.

In the end, we choose CacheLineEF when using compact parameters, but prefer the
simpler and slightly faster plain vector for fast parameters.

\begin{table}[t]
\caption{\label{tab:comparison}Performance comparison of MPHF on 300 million random
  string keys of uniform length between 10 and 50. Construction time is shown
  for 6 threads. A * indicates single-threaded timings (optimistic 6-fold speedup in parentheses). Near-optimal values in each column are shown in bold.}
\vspace{-0.5em}
\centering
\newcommand{\vname}[2]{\multirow{#1}{*}{\rotatebox[origin=c]{90}{#2}}}
\newcommand{\name}[2]{\multirow{#1}{*}{#2}}
\setlength{\tabcolsep}{5pt}
\scalebox{0.90}{
\begin{tabular}{lllrrr}
\toprule
&Approach & Configuration & \makecell[r]{\hspace{-2em}Space\\\hspace{-2em}bits/key} & \makecell[r]{Construction\\ 6t, ns/key} & \makecell[r]{Query\\ ns/query}\\
\midrule
\vname{5}{\small Bruteforce}
&\name{2}{SIMDRecSplit} & \(n{=}5\), \(b{=}5\) & 2.96 & \textbf{26} & 310\\[-0.1em]
&& \(n{=}8\), \(b{=}100\) & \textbf{1.81} & 66 & 258\\
\cmidrule{2-6}
&Bip. ShockHash-Flat & \(n{=}64\) & \textbf{1.62} & 2140* (357) & 201\\
\cmidrule{2-6}
&\name{2}{Consensus-RecSplit} & \(k=256\), \(\varepsilon=0.10\) & \textbf{1.58} & 521* (87) & 565\\[-0.1em]
&& \(k=512\), \(\varepsilon=0.03\) & \textbf{1.49} & 1199* (200) & 528\\
\midrule
\vname{6}{Fingerprinting}
&\name{2}{FMPH} & \(\gamma{=}2.0\) & 3.40 & 44 & 168\\[-0.1em]
&& \(\gamma{=}1.0\) & 2.80 & 69 & 236\\
\cmidrule{2-6}
&\name{2}{FMPHGO}& \(s{=}4\), \(b{=}16\), \(\gamma{=}2.0\) & 2.86 & 298 & 160\\[-0.1em]
&& \(s{=}4\), \(b{=}16\), \(\gamma{=}1.0\) & 2.21 & 423 & 212\\
\cmidrule{2-6}
&\name{2}{FiPS} & \(\gamma{=}2.0\) & 3.52 & 93* (\textbf{16}) & 109\\[-0.1em]
&& \(\gamma{=}1.5\) & 3.12 & 109* (\textbf{18}) & 124\\
\midrule
\vname{2}{\small Graph}
&\name{2}{SicHash} & \(p_1{=}0.21\), \(p_2{=}0.78\), \(\alpha{=}0.90\) & 2.41 & 48 & 149\\[-0.1em]
& & \(p_1{=}0.45\), \(p_2{=}0.31\), \(\alpha{=}0.97\) & 2.08 & 63 & 141\\
\midrule
\vname{16}{Bucket placement}
&CHD & \(\lambda{=}3.0\) & 2.27 & 1059* (177) & 542\\
\cmidrule{2-6}
&\name{4}{PTHash} & \(\lambda{=}4.0\), \(\alpha{=}0.99\), C-C & 3.19 & 403 & 77\\[-0.3em]
&& \ + HEM &  & 173 & \\
\cmidrule{3-6}
&& \(\lambda{=}5.0\), \(\alpha{=}0.99\), EF & 2.17 & 765 & 156\\[-0.3em]
&& \ + HEM  &  & 323 & \\
\cmidrule{2-6}
&\name{4}{PHOBIC} & \(\lambda{=}3.9\), \(\alpha{=}1.0\), IC-C & 4.14 & 62 & 116\\[-0.1em]
&& \(\lambda{=}4.5\), \(\alpha{=}1.0\), IC-R & 2.34 & 80 & 179\\[-0.1em]
%% && \(\lambda{=}6.5\), \(\alpha{=}1.0\), IC-R & \textbf{1.94} & 215 & 163\\[-0.1em]
&& \(\lambda{=}6.5\), \(\alpha{=}1.0\), IC-C & 2.44 & 220 & 108\\[-0.1em]
&& \(\lambda{=}7.0\), \(\alpha{=}1.0\), IC-R & \textbf{1.86} & 446 & 157\\
\cmidrule{2-6}
&\name{6}{\textbf{PtrHash}} & \hspace{-2.85em}Fast\ \ \  \(\lambda{=}3.0\),
\(\alpha{=}0.99\), $\gamma_1$, Vec & 2.99 & \textbf{26} & \textbf{38}\\[-0.3em]
&&\ + streaming  &  &  & \textbf{20}\\
\cmidrule{3-6}
&& \hspace{-4.22em}Default\ \ \   \(\lambda{=}3.5\), \(\alpha{=}0.99\), $\gamma_3$, CLEF & 2.40 & \textbf{32} & \textbf{44}\\[-0.3em]
&&\ + streaming  &  &  & \textbf{25}\\
\cmidrule{3-6}
&& \hspace{-4.93em}Compact\ \ \  \(\lambda{=}4.0\), \(\alpha{=}0.99\), $\gamma_3$, CLEF & 2.12 & 62 & \textbf{42}\\[-0.3em]
&&\ + streaming &  &  & \textbf{23}\\
\bottomrule
\end{tabular}
}
\vspace{-1em}
\end{table}

\subsection{Comparison to Other Methods}
\label{sec:comparison}

In \cref{tab:comparison} we compare the performance of PtrHash against other methods on
short, random strings.
In particular, we compare against methods and configurations that are reasonably fast to construct:
SIMDRecSplit \cite{recsplit,recsplit-gpu},
Bipartite ShockHash-Flat \cite{shockhash,bipartite-shockhash},
Consensus-RecSplit \cite{consensus},
FMPH and FMPHGO \cite{fmph},
FiPS \cite{phf-thesis},
SicHash \cite{sichash},
CHD \cite{chd},
PTHash \cite{pthash,pthash-2},
and PHOBIC \cite{phobic}.
We also include Bipartite ShockHash-Flat \cite{shockhash,bipartite-shockhash},
which is able to use relatively little space with fast construction time.
The specific parameters are based on Table 1 of \cite{phobic}, Table 8.1 of
\cite{phf-thesis}, and Table 3 of \cite{fmph}.
These results were obtained using the excellent MPHF-Experiments library
\cite{mphf-experiments} by Hans-Peter Lehmann. Construction is done on 6
threads in parallel when supported. By default, the framework queries
one key at a time. For PtrHash with streaming queries, we modified this to query
all keys at once.
\vspace{-1em}

\parag{Input.}
The input is 300 million random strings of random length between 10 and 50
characters. This input size is such that the MPHF data structures take around
75 MB, which is much larger than the 12 MB L3 cache.

\parag{PtrHash.} As expected, the space usage of PtrHash matches the numbers of \cref{remap}.
In general, PtrHash can be slightly larger due to rounding in the number of
parts and slots per part, but for large inputs like here this effect is small.
Construction times per key are slightly slower than as predicted by
\cref{fig:construction}, while we might expect slightly faster construction due to the
lower number of keys. Likely, the slowdown is caused by hashing the input strings.
The hashing of input strings has a much worse effect on query throughput. In
\cref{remap}, we obtained query throughput of 12~ns and 18~ns for the fast and compact
configurations when looping, and as low as 8~ns when streaming queries. With
string inputs, these numbers more than double to 38~ns resp. 42~ns when looping,
and 20~ns when streaming. A similar effect can be seen when comparing Tables 3
and 4 of \cite{fmph}. \cref{hash-eval} further investigates this.

\parag{Speed.}
We observe that PtrHash with fast parameters is the fastest to construct
alongside SIMDRecSplit (26~ns/key) and FiPS (16~ns/key, assuming optimal scaling to
6 threads),  resulting in around 3~bits/key for all three methods.
However, query throughput of PtrHash is \(8\times\) (SIMDRecSplit) resp.
\(2.8\times\) (FiPS) faster, going up to \(15\times\) resp.
\(5\times\) faster when streaming all queries at once.
Compared to the next-fastest method to query, PTHash-CC (HEM), PtrHash is twice
faster to query (or nearly \(4\times\) when streaming), is \(6.5\times\) faster to build, and
even slightly smaller.

With default parameters, PtrHash is \(1.75\times\) faster to query than the
fastest configuration of PTHash, and \(3.1\times\) faster when using streaming,
while being over \(5\times\) faster to construct.

Indeed, the speedup in query speed is explained by the fact that only a single
memory access is needed for most queries (compared to \(\geq 2\) for PtrHash-HEM
and PHOBIC), and generally by the fact that the code for querying is short.

\parag{Space.}
PtrHash with the fast parameters is larger (2.99~bits/key) than some other methods, but
compensates by being significantly faster to construct and/or query.
When space is of importance, the compact version can be used (2.12~bits/key).
This takes \(2.4\times\) longer to build at 62~ns/key, and has only slightly slower queries.
Compared to methods that are smaller,
PtrHash is over \(3\times\) faster to build than PHOBIC.
Consensus, SIMDRecSplit, and SicHash achieve smaller space of 1.58, 1.81 and 2.08~bits/key in
comparable time (63-87~ns/key), but again are at least \(3\times\) slower to query, or
over \(6\times\) compared to streaming queries.
\section{Conclusions and Future Work}
\label{sec:org5cb9a29}
We have introduced PtrHash, a minimal perfect hash function that builds on
PTHash and PHOBIC. Its main novelty is the used of fixed-width 8-bit pilots that
simplify queries. To make this possible, we use \emph{hash-and-evict}, similar to
Cuckoo hashing: when there is no pilot that leads to a collision-free placement
of the corresponding keys, some other pilots are \emph{evicted} and have to search
for a new value.

The result is an MPHF with twice faster queries (38~ns/key) than any other method
(at least 77~ns/key) for datasets larger than L3 cache. Further,
due to its simplicity, queries can be processed in \emph{streaming} fashion, giving
another two times speedup (20~ns/key). At this point, the hashing of string inputs becomes a
bottleneck. For integer keys, such as $k$-mers, much higher throughput of up to
8~ns/key can be obtained, fully saturating the RAM throughput of each core, or
when using multiple cores even saturating the main memory (2.5~ns/key).

\parag{Future work.}
A theoretical analysis of our method is currently missing. While
the hash-evict strategy works well in
practice, we currently have no relation between the bucket size \(\lambda\), load
factor \(\alpha\), and the number of evicts arising during construction.
Such an analysis could help to better understand the optimal bucket assignment
function, like PHOBIC \cite{phobic} did for the case without
eviction.

Second, the size of pilots could possibly be improved by further parameter
tuning. In particular we use 8-bit pilots, while slightly fewer or more
bits may lead to smaller data structures. An experiment with 4-bit pilots
was not promising, however.

Lastly, to further improve the throughput, we suggest that more attention is
given to the exact input format. As already seen, hashing all queries at once
can provide significant performance gains via prefetching.  For string input
specifically, it is more efficient when the strings are consecutively packed in memory
rather than separately allocated, and it might be more efficient to explicitly
hash multiple strings in parallel.
More generally, applications should investigate whether they can be rewritten to take
advantage of streaming queries.
\section*{Acknowledgements}
\label{sec:orgbb6ba66}
First, I thank Giulio Ermanno Pibiri for his ongoing feedback in
various stages of this project. Further, I thank Sebastiano Vigna for feedback
from trying to construct PtrHash on \(10^{12}\)~keys and integrating
$\varepsilon$-serde, and lastly I thank Hans-Peter Lehmann for feedback on the text.

\bibliographystyle{plainurl}
\bibliography{bibliography}

\newpage
\clearpage
\appendix

\section{Query throughput}
\label{sec:throughput}
\subsection{Batching and streaming}
\label{sec:orgcf2c161}
\parag{Throughput.}
In practice in bioinformatics applications such as SSHash, we expect many
independent queries to the MPHF. This means that queries can be answered in
parallel, instead of one by one. Thus, we should optimize for query \emph{throughput}
rather than individual query latency. We report throughput as \emph{inverse
throughput} in amortized nanoseconds per query, rather than the usual queries
per second.

\parag{Out-of-order execution.}
An MPHF on \(10^9\) keys requires memory at least \(1.5\mathrm{\ bits}/\mathrm{key} \times 10^9
\mathrm{\ keys} = 188\) MB, which is much larger than the L3 cache of size around
16 MB. Thus, most queries require reading a pilot from main memory (RAM), which usually
has a latency around 80~ns.
Nevertheless, existing MPHFs such as FCH \cite{fch} achieve an inverse throughput as
low as 35~ns/query on such a dataset \cite{pthash}.
This is achieved by \emph{pipelining} and the \emph{reorder buffer}.
For example, Intel Skylake CPUs can execute over 200 instructions ahead while waiting for memory
to become available \cite{measuring-rob,measuring-rob-skylake}. This allows the CPU to already start processing future
queries and fetch the required cache lines from RAM while waiting for the
current query. Thus, when each iteration requires less than 100 instructions
and there are no branch-misses, this effectively makes up to two reads in
parallel. A large part of speeding up queries is then to reduce the length of
each iteration so that out-of-order execution can fetch memory more iterations ahead.

\parag{Prefetching.}
Instead of relying on the CPU hardware to parallellize requests to memory, we can also
explicitly \emph{prefetch}\footnote{There are typically multiple types of prefetching
instructions that prefetch into a different level of the cache hierarchy. We
prefetch into all levels of cache using \texttt{prefetcht0}.} cache lines from our code.
Each prefetch requires a \emph{line fill buffer} to store the result before it is
copied into the L1 cache. Skylake has 12 line fill buffers~\cite{line-fill-buffer-skylake}, and hence can support up to 12 parallel
reads from memory.
In theory, this gives a maximal random memory throughput around $80/12 = 6.67$ ns per read
from memory, but in practice experiments show that the limit is 7.4~ns per read.
Thus, our goal is to achieve a query throughput of 7.4~ns.

We consider two models to implement prefetching: batching and streaming.

\begin{figure}[b]
\centering
\includegraphics[width=\linewidth]{figs/streaming}
\caption{\label{streaming}Simplified schematic of in-progress reads from main memory (RAM) when using two different prefetching approaches processing (up to) \(8\) reads in parallel. Each horizontal line indicates the duration a read is in progress, from the moment it is prefetched (left vertical bar) to the moment it is available in L1 cache and its corresponding line fill buffer is free again (right vertical bar). Streaming (right) provides better parallelism than batching (left).}
\end{figure}

\parag{Batching.}
In this approach, the queries are split into batches (chunks) of size
\(B\), and are then processed one batch at a time (\cref{streaming}, left).
In each batch, two passes are made over all keys.
In the first pass, each key is hashed, its
bucket it determined, and the cache line containing the corresponding pilot is prefetched.
In the second pass, the hashes are iterated again, and the corresponding slots are
computed.

\parag{Streaming.}
A drawback of batching is that at the start and end of each batch, the
memory bandwidth is not fully saturated.
Streaming fixes this by prefetching the cache line for the pilot \(B\) iterations
ahead of the current one, and is able to sustain the maximum possible number of
parallel prefetches throughout, apart from at the very start and end (\cref{streaming}, right).
\subsection{Evaluation}
\label{query-eval}
\parag{A note on benchmarking throughput.}
To our knowledge, all recent papers on (minimal) perfect hashing measure query
speed by first creating a list of keys, and then querying all keys in the list,
as in \texttt{for key in keys \{ ptr\_hash.query(key); \}}. One might think this measures the average
latency of a query, but that is not the case, as the CPU will execute
instructions from adjacent iterations at the same time.
Indeed, as can be seen in \cref{remap}, this loop can be as fast as 12
ns/key for \(n=10^9\), which is over 6 times faster than the RAM latency of
around 80~ns (for an input of size 300 MB),
and thus, at least 6 iterations are being processed in parallel.

Hence, we argue that existing benchmarks measure (and optimize for)
throughput and that they assume that the list of keys to query is known in advance.
We make this assumption explicit by changing the API to benchmark all queries at
once, as in \texttt{ptr\_hash.query\_all(keys)}. This way, we can explicitly process
multiple queries in parallel.

We also argue that properly optimizing for throughput is relevant for
applications. SSHash, for example, queries all minimizers of a DNA sequence,
which can be done by first computing and storing those minimizers, followed by
querying them all at once.

We now explore the effect of the batch size and number of parallel threads on
query throughput.

\parag{Batching and Streaming.}
\begin{figure}[t]
\centering
\includesvg[width=.95\linewidth]{plots/query_batching}
\caption{\label{fig:batching}Query throughput of prefetching via batching (dotted) and streaming (dashed) with various batch/lookahead sizes, compared to a plain for loop (solid), for \(n=20\cdot 10^6\) (left) and \(n=10^9\) (right) keys. Blue shows the results for the fast parameters, and red for the compact parameters. Default parameters give performance nearly identical to the compact parameters, since the main differentiating factor is the use of \(\gamma_1\) versus \(\gamma_3\). All times are measured over a total of \(10^9\) queries, and for (non-minimal) perfect hashing only, \emph{without} remapping.}
\end{figure}


In \cref{fig:batching}, we compare the query throughput of a simple for loop with the
batching and streaming variants with various batch/lookahead sizes. We see that
both for small \(n=20\cdot 10^6\) and large \(n=10^9\), the fast parameters yield
higher throughput than the compact parameters when using a for loop. This is
because of the overhead of computing \(\gamma_3(x)\). For small \(n\), batching and
streaming do not provide much benefit, indicating that memory latency is not a
bottleneck. However, for large \(n\), both batching and streaming improve over the
plain for loop. As expected, streaming is faster than batching here. For
streaming, throughput saturates when prefetching around 16 iterations ahead. At
this point, memory throughput is the bottleneck, and the difference between the
compact and fast parameters disappears. In fact, compact parameters with
\(\gamma_3\) are slightly \emph{faster}. This is because \(\gamma_3\) has a more skew
distribution of bucket sizes with more large buckets. When the pilots for these
large buckets are cached, they are more likely to be hit by subsequent queries,
and hence avoid some accesses to main memory.

For further experiments we choose streaming over batching, and use a lookahead
of 32 iterations.
The final throughput of 8~ns per query is very close to the optimal throughput of
7.4~ns per random memory read.

\begin{figure}[t]
\centering
\includesvg[width=.95\linewidth]{plots/query_throughput}
\caption{\label{fig:throughput}In this plot we compare the throughput of a for loop (solid) versus streaming (dashed) for multiple threads, for both non-minimal (dimmed) and minimal (bright) perfect hashing. The left shows results for \(n=20\cdot 10^6\), and the right shows results for \(n=10^9\). In blue the results for the fast parameters with \(\gamma_1\), and in red the results for compact parameters with \(\gamma_3\), which perfors nearly identical to the default parameters. On the right, the solid black line shows the maximum throughput based on 7.4~ns per random memory access per thread, and the solid black line shows the maximum throughput based on the total memory bandwidth of 25.6 GB/s.}
\vspace{-1em}
\end{figure}

\subsection{Multi-threaded Throughput}
\label{sec:org6cfc145}

In \cref{fig:throughput} we compare the throughput of the fast and compact parameters for
multiple threads. When \(n=20\cdot 10^6\) is small and the entire data structure
fits in L3 cache, the scaling to multiple threads is nearly perfect. As
expected, minimal perfect hashing (bright) tends to be slightly slower than
perfect hashing (dimmed), but the difference is small. The fast \(\gamma_1\) is faster than
the compact \(\gamma_3\), and streaming provides only a small benefit over a for
loop.
For large \(n=10^9\), all methods converge towards the limit imposed by the full
RAM throughput of 25.6 GB/s. Streaming variants hit this starting at around 4
threads, and remain faster than the for loop. As before, the compact version is
slightly faster because of its more efficient use of the caches, and is even
slightly better than the maximum throughput of random reads to RAM.
Minimal perfect hashing is only slightly slower than perfect hashing.

\section{Sharding}
\label{sharding}
When the number of keys is large, say over \(10^{10}\), their 64-bit (or 128-bit) hashes may not all fit
in memory at the same time, even though the final PtrHash data structure (the
list of pilots) would fit. Thus, we can not simply sort all hashes in
memory to partition them. Instead, we split the set of all \(n\) hashes into, say
\(s=\lceil n/2^{32}\rceil\) \emph{shards} of \(\approx 2^{32}\) elements each,
where the \(i\)'th shard corresponds to hash values in \(s_i:=[2^{64}\cdot i/s,
2^{64}\cdot (i+1)/s)\).
Then, shards are processed one at a time. The hashes in each shard are
sorted and split into parts, after which the parts are constructed as usual.
This way, the shards only play a role during construction, and the final
constructed data structure is independent of which sharding strategy was used.

\parag{In-memory sharding.}
The first approach to sharding is to iterate over the set of keys \(s\) times.
In the \(i\)'th iteration, all keys are hashed, and only those hashes in the
corresponding interval \(s_i\) are stored and processed.
This way, no disk space is needed for construction.

\parag{On-disk sharding.}
A drawback of the first approach is that keys are potentially hashed many times.
This can be avoided by writing hashes to disk. Specifically, we can create one
file per shard and append hashes to their corresponding file.
These files are then read and processed one by one.

\parag{Hybrid sharding.} A hybrid of the two approaches above only requires disk space
for \(D<s\) shards. This iterates and hashes the keys \(\lceil s/D\rceil\) times,
and in each iteration writes hashes for \(D\) shards to disk. Those are then
processed one by one as before.

\parag{On-disk PtrHash.}
When the number of keys is so large that even the pilots do not fit in memory, they
can also be stored to disk and read on-demand while querying. This is supported using $\varepsilon$-serde \cite{epserde,webgraph}.
\subsection{Evaluation}
\label{sharding-eval}
We tested the in-memory and hybrid sharding by constructing PtrHash with default
parameters on \(5\cdot
10^{10}\) random integer keys on a laptop with only 64 GB of memory, using 6 cores
in parallel.
All 64-bit hashes would take 400 GB, so we use 24 shards of
around \(2^{31}\) keys, that each take 16 GB.
The final data structure takes 2.40~bits/key, or 15 GB in total, and the
peak memory usage is around 50 GB.

The in-memory strategy iterates through and hashes the integer keys 24 times, and takes
3098 seconds in total or 129 s per shard. Of this, 67s (52\%) is spent on hashing
the keys, 14s (11\%) is spent sorting hashes into buckets, and 45s (35\%) is spent
searching for pilots.

The hybrid strategy is allowed to use up to 128 GB of disk space, and thus writes
hashes to disk in 3 batches of 8 shards at a time. This brings the total time
down to 2494 s (17\% faster), and uses 104 s per shard. Of this, an amortized 31
s (30\%) per shard is spent
writing hashes to disk, and 9 s (9\%) is spent reading hashes from disk, which
together is faster than the 67s that was previously spent on hashing all keys.
\section{Evaluating Hash Functions}
\label{hash-eval}
\begin{table}[b]
\caption{\label{hashes}MPHF query throughput (ns/key) of PtrHash with fast parameters (\(\alpha=0.99\), \(\lambda=3.0\), \(\gamma_1(x)=x\), and a plain vector for remapping) for \(n=10^8\) keys.}
\centering
\begin{tabular}{lrrrrrr}
  \toprule
Input &
\multicolumn{3}{c}{Loop} &
\multicolumn{3}{c}{Stream}  \\
\cmidrule(lr){2-4}
\cmidrule(lr){5-7}
 & FxHash & XXH3-64 & XXH3-128 & FxHash & XXH3-64 & XXH3-128\\
\midrule
u64 & 11.1 & 24.4 & 29.9 & 7.2 & 9.1 & 10.5\\
Box<u64> & 12.7 & 30.1 & 31.2 & 8.7 & 11.1 & 12.4\\
\&[u8; 10] & 19.4 & 27.7 & 32.9 & 10.1 & 12.5 & 14.2\\
\&[u8; 50] & 34.1 & 28.6 & 32.8 & 16.5 & 12.7 & 14.1\\
\&[u8] & 39.2 & 37.0 & 50.9 & 27.2 & 17.8 & 23.1\\
Vec<u8> & 40.2 & 40.6 & 52.7 & 28.3 & 20.2 & 25.3\\
\bottomrule
\end{tabular}
\end{table}

In \cref{hashes}, we compare the throughput of various hash functions on different
types of inputs, both when iterating and streaming through queries.
The hash functions being compared are 64-bit FxHash \cite{fxhash}, and the
64-bit and 128-bit variants of XxHash (XXH3 specifically).
We test various inputs, of increasing complexity:
\begin{enumerate}
\item plain integers keys, the easy case;
\item allocated integer keys, to measure the overhead of the memory indirection;
\item short back-to-back packed fixed-length strings, to measure the overhead of string hashing;
\item longer packed fixed-length strings, to measure the overhead of iteration the string characters;
\item variable-length packed strings, to measure the overhead of branch-mispredictions;
\item allocated variable-length strings, to again measure pointer indirection
overhead.
\end{enumerate}

The string slices are all packed back-to-back into a single large allocation, so
that their contents can be efficiently prefetched. The \texttt{Vec<u8>} version on the
other hand uses the default allocator, which may or may not put things close to
each other and/or in order.

\parag{Results.}
Both when iterating and when streaming queries, FxHashing plain integers is
fastest, as expected. Both XxHash variants are quite a bit slower, especially
when using plain iteration. On boxed integers, most methods become around 1~ns/key slower.
FxHash maintains this speed advantage for short strings, but for longer strings
XXH3-64 becomes faster. In fact, XXH3 is only marginally slower for 50 byte
strings than for boxed integers, which is quite impressive!

When moving on to variable-length strings, all methods take quite a hit of at
least 5~ns/key due to the branch-mispredictions.
XXH3-64 remains fastest, but FxHash is nearly as fast when looping over queries.
The same is true when moving to allocated strings, which is again around 2
ns/key slower.

Overall, FxHash is the best hash to use for integer keys, and XXH3-64 is a good
choice for strings. XXH3-128 is slower and should only be used when really needed.
Hashing is slightly faster when the keys are back to back in memory.

\end{document}
