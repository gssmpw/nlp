\subsection{Bad Partitioning in TEE Projects} \label{s:bp}
By analyzing 10 TEE projects from \textit{github.com}, we identified three primary types of bad partitioning issues: \whiteding{1} unencrypted data output, \whiteding{2} input validation weaknesses, and \whiteding{3} the direct usage of shared memory. We list some projects and issues they face in Table~\ref{tbl:project_list}, and discuss each of these issues in detail below.
In this paper, we use projects developed for ARM TrustZone as examples. The issues we identify and the proposed solutions work for other platforms as well.

% \begin{table*}[t]
%     \caption{Surveys of bad partitioning issues in real-world TEE projects.}
%     \label{tbl:project_list}
%     % \renewcommand{\arraystretch}{1.3}
%     % \footnotesize
%     \setlength{\tabcolsep}{1mm}
%     \resizebox{\linewidth}{!}{
%     \centering
% 	\begin{tabular}{ccccccc}
% 		\toprule
% 		\textbf{Bad Partitioning Issues} & \textbf{optee-sdp} & \textbf{optee-fiovb} & \textbf{basicAlg\_use} & \textbf{external\_rk\_tee\_user} & \textbf{secvideo\_demo} & \textbf{darknetz} \\
% 		\midrule
%             Unencrypted Data Output & \ding{108} & \ding{108} & \ding{108} & \ding{108} & & \\
%             Input Validation Weaknesses & \ding{108} & \ding{108} & \ding{108} & \ding{108} & & \\
%             Direct Usage of Shared Memory & & & & \ding{108} & \ding{108} & \ding{108} \\
% 		\bottomrule
% 	\end{tabular}
%     }
% \end{table*}

\begin{table*}[t]
    \caption{Surveys of bad partitioning issues in real-world TEE projects. \CIRCLE~means that the project contains the corresponding issue, and \Circle~indicates not containing the issue.}
    \label{tbl:project_list}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    % \setlength{\tabcolsep}{2.5mm}
    % \resizebox{\linewidth}{!}{
    \centering
	\begin{tabular}{lp{2.7cm}<{\centering}p{2.7cm}<{\centering}p{2.7cm}<{\centering}}
		\toprule
            \multirow{2}{*}{\textbf{Projects}} & Unencrypted Data Output & Input Validation Weaknesses & Direct Usage of Shared Memory \\
		\midrule
            optee-sdp & \CIRCLE & \CIRCLE & \Circle \\
            optee-fiovb & \CIRCLE & \CIRCLE & \Circle\\
            basicAlg\_use & \CIRCLE & \CIRCLE & \Circle\\
            external\_rk\_tee\_user & \CIRCLE & \CIRCLE & \CIRCLE \\
            secvideo\_demo & \Circle & \Circle & \CIRCLE \\
            darknetz & \Circle & \Circle & \CIRCLE \\
            acipher & \CIRCLE & \Circle & \Circle \\
            Lenet5\_in\_OPTEE & \CIRCLE & \CIRCLE & \Circle \\
            hotp & \CIRCLE & \Circle & \Circle \\
            random & \CIRCLE & \Circle & \Circle \\
		\bottomrule
	\end{tabular}
    % }
\end{table*}

\subsubsection{\textbf{Unencrypted Data Output}} \label{s:udo}
Since a TEE application can transfer data from TEE to the normal side using output parameters or shared memory, any unencrypted data is at risk of exposure to attackers during the output process, potentially compromising the confidentiality and security of sensitive data.

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
char dump[MAX_DUMP_SIZE];
op.params[0].tmpref.buffer = (void *)dump;
op.params[0].tmpref.size = MAX_DUMP_SIZE - 1;
res = TEEC_InvokeCommand(&session, TA_SDP_DUMP_STATUS, &op, &err_origin);
    \end{lstlisting}
    \caption{The array \texttt{dump} is an output parameter in normal-world Code.}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{\linewidth}
        \begin{lstlisting}[language=c++]
// params[0].memref is a memory copy of op.params[0].tmpref in the normal world
snprintf(params[0].memref.buffer, params[0].memref.size, "delta (decoder) refcount %d\n", delta_refcount);
// params[0].memref will be copied to op.params[0].tmpref after return
return TEE_SUCCESS;
    \end{lstlisting}
    \caption{TEE data \texttt{delta\_refcount} is directly copied to the output buffer.}
  \end{subfigure}
  \caption{The example of unencrypted data output from optee-sdp.}
  \label{fig:bp1code}
\end{figure}

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
char g_AesOutpUT[256] = {0};
// op.params[1].tmpref.buffer is an input buffer larger than test buffer in TEE
op.params[1].tmpref.buffer = g_AesOutpUT;
res = l_CryptoVerifyCa_SendCommand(&op, &session, CMD_AES_OPER);
    \end{lstlisting}
    \caption{The input buffer and its size are defined outside TEE.}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{\linewidth}
        \begin{lstlisting}[language=c++]
char test[] = {0x01, 0x02, 0x03, 0x04, 0x05};
// params[1].memref.buffer is the copy of op.params[1].tmpref.buffer in the normal world
TEE_MemMove(params[1].memref.buffer, test, sizeof(test));
    \end{lstlisting}
    \caption{\texttt{TEE\_MemMove} is called without verifying the size of input buffer.}
  \end{subfigure}
  \caption{The example of input validation weaknesses from basicAlg\_use.}
  \label{fig:bp2code}
\end{figure}

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
unsigned char membuf_input[] = "from_CA_to_TA";
// definition of shared memory
TEEC_SharedMemory shm = {
    .size = sizeof(membuf_input),
};
TEEC_AllocateSharedMemory(&ctx, &shm);
// shared memory can be changed outside TEE
memcpy(shm.buffer, membuf_input, shm.size);
op.params[2].memref.parent = &shm;
res = TEEC_InvokeCommand(&sess, TA_TEST_APP_FILL_MEM_BUF, &op, &err_origin);
    \end{lstlisting}
    \caption{Shared memory is managed in the normal world.}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{\linewidth}
        \begin{lstlisting}[language=c++]
// params[2].memref.buffer is shared memory
void *buf = params[2].memref.buffer;
unsigned int sz = params[2].memref.size;
// params[2].memref.buffer may have been changed outside TEE
if (!TEE_MemCompare(buf, "from_CA_to_TA", sz)) {
    IMSG("membuf test : Pass!\n");
}
    \end{lstlisting}
    \caption{\texttt{TEE\_MemCompare} is invoked without checking the buffer contents.}
  \end{subfigure}
  \caption{The example of the direct usage of shared memory from external\_rk\_tee\_user.}
  \label{fig:bp3code}
\end{figure}

Fig.~\ref{fig:bp1code} shows a scenario where if the TEE data is copied to an output buffer without being encrypted, then the attacker can directly obtain the plaintext from \texttt{dump} in the normal world. Therefore, implementing proper security measures is essential to prevent unauthorized access or data leakage during the TEE output.

\subsubsection{\textbf{Input Validation Weaknesses}} \label{s:ivw}
As mentioned in Section~\ref{s:params}, an attacker with normal-world permissions has the ability to tamper with any data intended for input into TEE. Fig.~\ref{fig:bp2code} illustrates that even though the normal-world code defines a much larger buffer than \texttt{text} buffer used in TEE, it is still susceptible to buffer overflow attacks that in-TEE code directly performs memory copy operations in the TEE code without validating the size of the input buffer \texttt{params[1].memref.buffer}. This occurs because the TEE code may incorrectly assume that the input buffer is secure and reliable without explicitly checking its size. If an attacker maliciously alters the input buffer size, memory copy operations within TEE could exceed the boundaries of the inputs, leading to severe consequences such as crashes and data corruption. Similar precautions should be taken when using input values as indices for array access in TEE. Moreover, checking the input value treated as the \textit{size} argument of the memory request function \texttt{TEE\_Malloc(}\textit{size}\texttt{)} can effectively reduce the probability of memory allocation failure.

To mitigate this risk, it is necessary for the TEE code to validate all inputs before performing any memory operations, regardless of whether input checking is partitioned to the normal side. This essential validation ensures that any tampering or unexpected changes to the input data in the normal world do not compromise the security of TEE.

\subsubsection{\textbf{Direct Usage of Shared Memory}} \label{s:dusm}
Shared memory, as a zero-copy memory block, provides the same physical memory space accessible to both the secure and non-secure partitions. Since this memory is maintained by the normal-world code, bad partitioning can introduce significant vulnerabilities. If the TEE code directly uses shared memory without validating its contents, an attacker could manipulate the shared memory data and influence the execution of TEE applications.

Fig.~\ref{fig:bp3code} shows that variable \texttt{buf} is initialized by a shallow copy of the shared memory. Therefore, the contents of \texttt{buf} can be directly modified from outside TEE. When \texttt{buf} is passed into \texttt{TEE\_MemCompare} function, the TEE application may not return the expected results. In order to solve this problem, shared memory should be deep copied to the in-TEE buffer, ensuring that the data used in TEE is isolated from external manipulations. 
% Additionally, integrity validate should be performed to protect the consistency of the shared memory data.
