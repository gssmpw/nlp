\section{System Design} \label{s:design}
In this section, we present the design of the proposed \ccSysName to identify bad partitioning issues of TEE projects. With the help of CodeQL~\cite{10.1002/spe.3199, codeql}, a code analysis engine developed by GitHub, we construct data-flows of parameters passed between the normal world and TEE based on Algorithms~\ref{algo:odf} to~\ref{algo:mdf} in Section~\ref{s:dfg}. Then, by analyzing the data-flows, \ccSysName can detect insecure operations caused by bad partitioning. The design process involves 6 key steps shown in Fig.~\ref{fig:workflow}:

\begin{figure*}[t]
    \centering
    \includegraphics[width=\textwidth]{figures/Fig_6.drawio.pdf}
    \caption{Overview workflow of \ccSysName.}
    \label{fig:workflow}
\end{figure*}

\textbf{Preparation Step: Rule Establishment.} Sensitive functions and data (\eg, array access, memory operations and key mentioned in Fig.~\ref{fig:workflow}) are critical to security and privacy. For example, sensitive data should not be directly passed to the normal world through output parameters. Rules are established to define permissible operations on these sensitive functions and data.

\textbf{Step 1: Parameter Type Identification.} The initial step is identifying the parameters exchanged between the normal world and TEE. These parameters are classified into three types based on Section~\ref{s:params}.
% \begin{itemize}
%     \item \textit{Output}: Data sent from TEE to the normal world.
%     \item \textit{Input}: Data transfer from the normal world into TEE.
%     \item \textit{Shared Memory}: This memory accessible by both sides. 
%     % enabling the processing with large amounts of data.
% \end{itemize}

\textbf{Step 2: Data-flow Generation.} Data-flows of input/output and shared memory parameters will be generated. This will trace the path of each parameter and map its interactions with different components.

\textbf{Step 3: Parameter Analysis.} The next step involves analyzing whether the parameters pass through functions or interact with data related to rules in the preparation step.

\textbf{Step 4: Rule Matching with Parameter Data-flows.} If a parameter passes through rule-related components, we match its data-flow against the established rules in the preparation step to identify violations. Parameters that violate the rules will pinpoint bad partitioning issues, such as leakage of sensitive data to the normal world and misuse of shared memory leading to unexpected execution of in-TEE code.

\textbf{Step 5: Reporting Bad Partitioning Issues.} Based on the rule violations detected in the previous step, \ccSysName generates detailed reports highlighting bad partitioning issues.

By following this process, \ccSysName ensures robust detection of partitioning flaws in TEE projects, aiding developers in adhering to security policies and mitigating potential vulnerabilities. In the following, we will describe the implementation of \ccSysName in detail.

\subsection{Rule Establishment} \label{s:rules}
Given the discussion on bad partitioning in Section~\ref{s:bp}, we need to define a set of rules to detect these issues. These rules will focus on identifying incorrect parameter interactions with in-TEE sensitive functions and data that arise from bad partitioning.

\textbf{Rule 1: Encrypting before Output.} In this scenario, we mainly consider two critical functions --- \texttt{snprinf()} and \texttt{TEE\_MemMove()}, and assignment statements. The following code gives an implementation of secure in-TEE data output:
\begin{lstlisting}[language=c++, aboveskip=10pt, belowskip=5pt]
char key[] = "123456";
// buf is the ciphertext of key
TEE_CipherUpdate(key, strlen(key), buf, &size);
TEE_MemMove(params[0].memref.buffer, buf, size)
\end{lstlisting}

In line 4, \texttt{key} is encrypted by the TEE Internal API \texttt{TEE\_CipherUpdate()} before copying to an output buffer via \texttt{TEE\_MemMove(dest, src, size)}, in which output \texttt{params[0].memref.buffer} is the destination buffer \texttt{dest}, and in-TEE data \texttt{key} is the source buffer \texttt{src}.
Similarly, for the function \texttt{snprintf(dest, size, format, args...)}, all arguments \texttt{args} must be encrypted before they are formatted to \texttt{dest}, which is a TEE output.
Meanwhile, when an output value is the left value of an assignment statement, the corresponding right value should also be encrypted data. Rule 1 is shown as follow:
\begin{equation}
\begin{aligned}
(e(buf) \Rightarrow w(o,buf))
\land (e(v) \Rightarrow assgin(o,v))
\end{aligned}
\end{equation}
where $buf$ and $v$ are the contents of memory copy and assignment, $e()$ represents the encryption function, $w()$ and $assgin()$ will transfer $buf$ and $v$ to the output parameter $o$.
The symbol $\Rightarrow$ defines that the left operation must be executed before the right operation.

\textbf{Rule 2: Checking Value before in-TEE Use.} According to the analysis in Section~\ref{s:ivw}, even if the input value is checked in the normal world, the attacker still has the ability to tamper with the input and affect the execution of in-TEE code. 
\begin{lstlisting}[language=c++, aboveskip=10pt, belowskip=5pt]
char buf[] = "123456";
unsigned int size = strlen(buf);
if (params[0].memref.size < size) {
    return TEE_ERROR_BAD_PARAMETERS;
}
TEE_MemMove(params[0].memref.buffer, buf, size);
...
// a special case
size = params[1].memref.size;
char *str = TEE_Malloc(size, 0);
TEE_MemMove(str, params[1].memref.buffer, size);
\end{lstlisting}

The above code provides the example of input value check. Before any input data is used, there should be a conditional statement containing that input. The usage of input values should be noted, including operations like indexing for array access, memory copying, and memory allocation. This leads us to define Rule 2:
\begin{equation}
\begin{aligned}
isChecked(i) \Rightarrow array(i) \vee m(i)
\end{aligned}
\end{equation}
Here, $isChecked()$ denotes the input $i$ has been checked in a conditional statement; then, it can be used in array access $array()$ or memory operation functions $m()$, such as \texttt{TEE\_MemMove()} and \texttt{TEE\_Malloc()}.
There is also a special case in lines 10 to 12. An memory space is allocated with the same size as the input buffer. Then, the input will be copied to the allocated memory. In this case, it is secure for an in-TEE dynamically allocated buffer based on the size of input buffer to accept input data, even if no conditional check is performed on the input. Therefore, the issue results need to filter this situation by the condition: $\neg(malloc(i) \Rightarrow m(i))$.

\textbf{Rule 3: Using Deep Copy of Shared Memory.} Since shared memory supports the feature of zero-copy, using a shallow copy of shared memory within TEE allows both the normal world and TEE to access the same physical memory. This creates a direct link between the trusted and untrusted environments, and breaks the isolation of TEE. 
% Therefore, the proper way to use shared memory is to perform a deep copy in TEE. 
\begin{lstlisting}[language=c++, aboveskip=10pt, belowskip=5pt]
unsigned int size = params[1].memref.size;
char *buf = TEE_Malloc(size);
TEE_MemMove(buf, params[1].memref.buffer, size);
...
if (!strcmp(buf, "from_CA_to_TA")) {
    ...
}
\end{lstlisting}

As shown in the above code, the first step after transferring a shared memory buffer into TEE should be creating a deep copy of the shared memory. This ensures that TEE operates on an independent copy of the data, maintaining its isolation and preventing any unauthorized access or influence from the normal world.
In Rule 3, an in-TEE buffer $buf$ needs to be initialized via function $deepCopy()$ with shared memory $shm$. Then, any memory operations $m()$ could be performed on $buf$:
\begin{equation}
\begin{aligned}
deepCopy(buf,shm) \Rightarrow m(buf)
\end{aligned}
\end{equation}

\subsection{Parameter Type Identification}
% In Intel SGX, the parameter types are relatively easy to determine. For instance, arguments in ECALLs are treated as inputs to the enclave, while arguments in OCALLs are treated as outputs from the enclave. 
Since \ccSysName requires constructing and analyzing data-flows for different types of parameters, it needs to first identify the type of each parameter transferred between the normal world and TEE.
For example, in TrustZone-based OP-TEE, there are 10 parameter names, and we classify them into 3 types, which are listed in Table~\ref{tbl:type_name}.

\begin{table}[t]
    \caption{Types of parameters in TrustZone-based OP-TEE.}
    \label{tbl:type_name}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    \setlength{\tabcolsep}{5mm}
    \centering
	\begin{tabular}{lc}
		\toprule
		\makecell[c]{\textbf{Name}} & \textbf{Type} \\
		\midrule
            \texttt{TEEC\_VALUE\_OUTPUT} & \multirow{2}{*}{Output} \\
            \texttt{TEEC\_MEMREF\_OUTPUT} & \\
            \midrule
            \texttt{TEEC\_VALUE\_INPUT} & \multirow{2}{*}{Input} \\
            \texttt{TEEC\_MEMREF\_INPUT} & \\
            \midrule
            \texttt{TEEC\_VALUE\_INOUT} & \multirow{2}{*}{Output \& Input} \\
            \texttt{TEEC\_MEMREF\_INOUT} & \\
            \midrule
            \texttt{TEEC\_MEMREF\_WHOLE} & \multirow{4}{*}{Shared Memory} \\
            \texttt{TEEC\_MEMREF\_PARTIAL\_INPUT} & \\
            \texttt{TEEC\_MEMREF\_PARTIAL\_OUTPUT} & \\
            \texttt{TEEC\_MEMREF\_PARTIAL\_INOUT} & \\
		\bottomrule
	\end{tabular}
\end{table}

\begin{algorithm}[t]
\caption{Determine the parameter types passed into OP-TEE.}
\label{algo:param_type}
\SetKwFunction{isBefore}{isBefore}
\KwIn{$F$, all function \texttt{TEEC\_InvokeCommand()} calls;\\
\hspace{11mm}$S$, all definition statements of parameter type}
\KwOut{$T$, types of parameters passed into each function call $f$ of $F$}
\ForEach{$f \in F$}{
    \tcp{$T_{f}$ means the f-th element in $T$, and $S_0$ is the first element of $S$}
    $T_{f} \gets S_0$\;
    \ForEach{$s \in S$}{
        \If{$s$.\isBefore{$f$} $\land$ $T_{f}$.\isBefore{$s$}}{
            $T_{f} \gets s$\;
        }
    }
}
\end{algorithm}

\begin{lstlisting}[language=c++, aboveskip=10pt, belowskip=5pt]
op.paramTypes = TEEC_PARAM_TYPES(...);
res = TEEC_InvokeCommand(&session, TA_CMD, &op, &err_origin);
\end{lstlisting}
% The function \texttt{TEEC\_InvokeCommand()} is responsible for transmitting four parameters with different types each time.

The above code shows that the parameter types are defined by the line 1 statement before the TEE invocation function \texttt{TEEC\_InvokeCommand()} in line 2.
Since the normal-world code may contain multiple pairs of parameter definition and TEE invocation, for a \texttt{TEEC\_InvokeCommand()} call, we need to locate the parameter type definition statement that precedes it and is closest to it. Algorithm~\ref{algo:param_type} gives the determination of the parameter types passed into one invocation. 
The algorithm iterates through all parameter definitions and TEE invocation statements, identifying the corresponding parameter definition statement for the current TEE invocation according to the condition in line 4, which means there are no other parameter definition statements between a parameter definition and the TEE invocation.
Then, we can generate the data-flows of these parameters by code analysis tools, such as CodeQL.

\subsection{Detection of Bad Partitioning}
\subsubsection{Data-flow Generation} \label{s:dfg}
In this step, we first build the data-flow of each parameter passed between the normal world and TEE.

\begin{table}[t]
    \caption{The sources and sinks of data-flow generation for output parameters.}
    \label{tbl:out_df}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    \centering
	\begin{tabular}{cp{11cm}}
		\toprule
            Sources & (1) in-TEE sensitive data\\
            \midrule
            \multirow{4}{*}{Sinks} & (1) output buffer, which is the destination buffer for copying the source: $w(o,source)$\\
             & (2) output value, which is assigned with the source: $o = source$\\
             & (3) all function calls, in which the source is passed: $functionCall(source)$\\
		\bottomrule
	\end{tabular}
\end{table}

\begin{algorithm}[t]
\caption{Data-flow generation for output parameters.}
\label{algo:odf}
\SetKwFunction{hasDestArgument}{hasDestArgument}
\SetKwFunction{getDestArgument}{getDestArgument}
\SetKwFunction{getSrcArgument}{geSrcArgument}
\SetKwFunction{getLeftValue}{getLeftValue}
\SetKwFunction{getRightValue}{getRightValue}
\SetKwFunction{hasArgument}{hasArgument}
\KwIn{$F$, all function calls;\\
\hspace{11mm}$S$, all assignment statements}
\KwOut{$D$, sensitive data list;\\
\hspace{13mm}$ODF$, data-flows for outputs}
$D \gets \emptyset$\;
$ODF \gets \emptyset$\;
\ForEach{$f \in F$}{
    \tcp{$f$ has the dest argument, which is an output}
    \If{$f$.\hasDestArgument{} is output}{
        \tcp{get the data copied to output}
        $D \gets D \cup \{f.\text{\getSrcArgument{}}\}$\;
    }
}
\ForEach{$s \in S$}{
    \tcp{get the assigned object}
    \If{$s$.\getLeftValue{} is output}{
        \tcp{get the data assigned to output}
        $D \gets D \cup \{s.\text{\getRightValue{}}\}$\;
    }
}
\ForEach{$d \in D$}{
    \ForEach{$f \in F$}{
        \tcp{check whether the data passed in $f$}
        \If{$f$.\hasArgument{$d$} is True}{
            $ODF_d \gets ODF_d \cup \{f\}$\;
        }
    }
}
\end{algorithm}

\begin{table}[t]
    \caption{The sources and sinks of data-flow generation for input parameters.}
    \label{tbl:in_df}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    \centering
	\begin{tabular}{cp{11cm}}
		\toprule
            \multirow{2}{*}{Sources} & (1) input value\\
             & (2) input buffer\\
            \midrule
            \multirow{4}{*}{Sinks} & (1) conditional statement with the source: $if(source)$\\
             & (2) index of array access, which is the source or expression with the source: $array(source) \vee array(expr(source))$\\
             & (3) memory operation function, in which the source passed: $m(source)$\\
		\bottomrule
	\end{tabular}
\end{table}

\begin{algorithm}[t]
\caption{Data-flow generation for input parameters.}
\label{algo:idf}
\SetKwFunction{getControllingExpr}{getControllingExpr}
\SetKwFunction{hasOperand}{hasOperand}
\SetKwFunction{getIndex}{getIndex}
\SetKwFunction{isInExpr}{isInExpr}
\SetKwFunction{getExpr}{getExpr}
\SetKwFunction{hasArgument}{hasArgument}
\KwIn{$I$, all input parameters;\\
\hspace{11mm}$C$, all conditional statements;\\
\hspace{11mm}$A$, all array access statements;\\
\hspace{11mm}$F$, all function calls; }
\KwOut{$IDF$, data-flows for inputs}
$IDF \gets \emptyset$\;
\ForEach{$i \in I$}{
    \ForEach{$c \in C$}{
        \tcp{$i$ is in the controlling exprseeion $e$ of $c$}
        $e \gets c$.\getControllingExpr{}\;
        \If{$e$.\hasOperand{$i$} is True}{
            $IDF_i \gets IDF_i \cup \{c\}$\;
        }
    }
    \ForEach{$a \in A$}{
        \tcp{$i$ is an index of $a$}
        \If{$a$.\getIndex{} is $i$}{
            $IDF_i \gets IDF_i \cup \{a\}$\;
        }
        \tcp{check whether $i$ is in an expression}
        \If{\isInExpr{$i$} is True}{
            \tcp{get the expression where the $i$ is an operand}
            $e \gets i$.\getExpr{}\;
            \If{$a$.\getIndex{} is $e$}{
                $IDF_i \gets IDF_i \cup \{a\}$\;
            }
        }
    }
    \ForEach{$f \in F$}{
        \If{$f$.\hasArgument{$i$} is True}{
            $IDF_i \gets IDF_i \cup \{f\}$\;
        }
    }
}
\end{algorithm}

For \textbf{output parameters}, the sources and sinks of their data-flow generation are listed in Table~\ref{tbl:out_df}. Sensitive data in TEE, such as cryptographic keys and authentication credentials, will be the sources. The sinks consist of output parameters that serve as the targets of source copies and assignment operations. In addition, we also need to obtain what operations the sensitive data in TEE has undergone, that is, which functions they have been called into.
Algorithm~\ref{algo:odf} describes the construction of data-flows for outputs, it has 2 stages: 

\begin{enumerate}[label=\alph*)]
    \item Lines 3 to 8 are the procedure of obtaining all in-TEE data that will be copied or assigned to the output parameters.
    \item Lines 9 to 12 can get all functions that have processed the above data.
\end{enumerate}

Then, we can trace the flow paths of in-TEE data to the outputs $ODF$, and $ODF_d$ means the path of $d$.

For \textbf{input parameters}, as illustrated in Table~\ref{tbl:in_df}, we only need to focus on the statements that they pass through, such as conditions, array access, memory operation function calls, etc. 
Additionally, the second sink needs to consider two types: \texttt{a[i]} and \texttt{a[i-1]}, which are \texttt{i} and the expression composed of \texttt{i} as an array index, respectively.
There are three loop blocks at lines 3 to 16 in Algorithm~\ref{algo:idf}. Each of them corresponds to three kinds of sinks in Table~\ref{tbl:in_df}. Finally, we get $IDF$ which represents the data-flow of each input during execution of in-TEE code, and $IDF_i$ denotes data-flow path of $i$.

In the end, the sinks of \textbf{shared memory} data-flows are the buffer initialization statements based on a shallow copy of shared memory, and function calls where they directly treat the shared memory buffer as the argument. According to Table~\ref{tbl:shm}, we design Algorithm~\ref{algo:mdf} to generate the data-flows of shared memory parameters. Lines 3 to 5 are responsible for retrieving the status of the first sink, lines 6 to 8 correspond to the second, and $MDF_m$ is data-flow of $m$.

\begin{table}[t]
    \caption{The sources and sinks of data-flow generation for shared memory.}
    \label{tbl:shm}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    \centering
	\begin{tabular}{cp{11cm}}
		\toprule
            Sources & (1) shared memory buffer\\
            \midrule
            \multirow{2}{*}{Sinks} & (1) shallow copy statement with the source: $buf=shm$\\
             & (2) all function calls, where directly use the source: $f(shm)$\\
		\bottomrule
	\end{tabular}
\end{table}

\begin{algorithm}[t]
\caption{Data-flow generation for shared memory.}
\label{algo:mdf}
\SetKwFunction{getRightValue}{getRightValue}
\SetKwFunction{hasArgument}{hasArgument}
\KwIn{$M$, all shared memory parameters;\\
\hspace{11mm}$S$, all assignment statements;\\
\hspace{11mm}$F$, all function calls; }
\KwOut{$MDF$, data-flows for shared memory}
$MDF \gets \emptyset$\;
\ForEach{$m \in M$}{
    \ForEach{$s \in S$}{
        \If{$s$.\getRightValue{} is $m$}{
            $MDF_m \gets MDF_m \cup \{s\}$\;
        }
    }
    \ForEach{$f \in F$}{
        \If{$f$.\hasArgument{$m$} is True}{
            $MDF_m \gets MDF_m \cup \{f\}$\;
        }
    }
}
\end{algorithm}

\subsubsection{Rule Matching and Issue Reporting} Once the data-flow of each parameter is constructed, it can be matched against the rules defined in Section~\ref{s:rules} to identify bad partitioning issues in TEE projects.

\textbf{Bad partitioning \whiteding{1}.} 
Algorithm~\ref{algo:bp1} describes a way of detecting unencrypted data that will be written to the output.
First, for each data-flow path in $ODF$, we initialize a flag $isEncrypted$ to False. This flag tracks whether data in the current path has been encrypted.
Then, we iterate through each node $n$ in the current path.
If $n$ represents a function call, we need to extract its name and check whether the name contains substrings like \textit{enc} or \textit{cipher}. If such a substring is present, set $isEncrypted$ to True. This ensures encryption functions within a data-flow are identified to determine the data has been protected.

For other function nodes, if they have a destination buffer argument that is an output, we should check whether $isEncrypted$ is False.
If so, we can record this node in the report $OR$.
For $n$, which is an assignment statement, if the left-value of this assignment is an output and $isEncrypted$ of this path is still False while iterating to the node, this node also needs to be put into $OR$.
After processing all paths in $ODF$, Algorithm~\ref{algo:bp1} returns the report $OR$, which contains all nodes where unencrypted data is copied to the output.

\begin{algorithm}[t]
\caption{Detection of unencrypted data output.}
\label{algo:bp1}
\SetKwFunction{isFunction}{isFunction}
\SetKwFunction{name}{name}
\SetKwFunction{isAssignment}{isAssignment}
\SetKwFunction{getLeftValue}{getLeftValue}
\KwIn{$ODF$, data-flows for outputs}
\KwOut{$OR$, report of unencrypted data output}
\ForEach{$path \in ODF$}{
    $isEncrypted \gets False$\;
    \tcp{$n$ is a node in the $path$}
    \ForEach{$n \in path$}{
        \If{\isFunction{$n$} is True}{
            \tcp{get the function name of $n$}
            \If{$(``enc" \vee ``cipher")$ in $n$.\name{}}{
                $isEncrypted \gets True$\;
            }
            \If{$n$.\hasDestArgument{} is output}{
                \If{$isEncrypted$ is False}{
                    $OR \gets OR \cup \{n\}$\;
                }
            }
        }
        \If{\isAssignment{$n$} is True}{
            \If{$n$.\getLeftValue{} is output}{
                \If{$isEncrypted$ is False}{
                    $OR \gets OR \cup \{n\}$\;
                }
            }
        }
    }
}
\end{algorithm}

\textbf{Bad partitioning \whiteding{2}.} 
Algorithm~\ref{algo:bp2} focuses on detecting potential weaknesses in input validation by checking whether inputs pass through conditional logic before being processed further.
It assumes that conditional statements are indicators of input validation and marks nodes of $IDF$ as vulnerable if they precede any such checks.

Similar to Algorithm~\ref{algo:bp1}, a flag $isChecked$ is also initialized to False and we retrieve each node in paths of $IDF$. The flag indicates whether input validation has been performed along the path.
If the node represents a conditional statement (\eg, an \texttt{if} or \texttt{switch} block), we can set $isChecked$ to True. If $isChecked$ remains False for a node $n$, it suggests that no validation has been performed for this input up to that point. The node $n$ will be added to the report $IR$.
In addition, we exclude the special case in Rule 2 through lines 9 to 14.

\begin{algorithm}[t]
\caption{Detection of input validation weaknesses.}
\label{algo:bp2}
\SetKwFunction{isConditional}{isConditional}
\SetKwFunction{isFunction}{isFunction}
\SetKwFunction{name}{name}
\KwIn{$IDF$, data-flows for inputs}
\KwOut{$IR$, report of input validation weaknesses}
\ForEach{$path \in IDF$}{
    $isChecked \gets False$\;
    $isSecure \gets False$\;
    \ForEach{$n \in path$}{
        \If{\isConditional{$n$} is True}{
            $isChecked \gets True$\;
        }
        \If{$isChecked$ is False}{
            $IR \gets IR \cup \{n\}$\;
        }
        \tcp{filter the special case}
        \If{\isFunction{$n$} is True}{
            \If{$(``malloc")$ in $n$.\name{}}{
                $isSecure \gets True$\;
            }
            \If{$(``memove")$ in $n$.\name{}}{
                \If{$isSecure$ is True}{
                    $IR \gets IR - \{n\}$\;
                }
            }
        }
    }
}
\end{algorithm}

\textbf{Bad partitioning \whiteding{3}.} 
Algorithm~\ref{algo:bp3} identifies direct access to shared memory without secure-guards, which can lead to in-TEE data corruption and leakage, or other issues of data integrity and confidentiality.
Rule 3 ensures that shared memory is only used after appropriate handling, such as deep copying, to avoid effects from the normal world.

If a node $n$ represents a function call, we will determine whether it performs a deep copy operation where the shared memory $shm$ is the source buffer.
If it is true, we could continue to check the next node.
For all other cases where $shm$ is directly accessed, then, the node $n$ is tagged on the bad partitioning of directly using shared memory.

\begin{algorithm}[t]
\caption{Detection of direct usage of shared memory.}
\label{algo:bp3}
\SetKwFunction{isConditional}{isConditional}
\SetKwFunction{hasSrcArgument}{hasSrcArgument}
\KwIn{$MDF$, data-flows for shared memory}
\KwOut{$MR$, report of direct usage of shared memory}
\ForEach{$path \in MDF$}{
    \ForEach{$n \in path$}{
        \If{\isFunction{$n$} is True}{
            \tcp{$n$ is a deep copy where shared memory is source buffer}
            \If{$n$.\hasSrcArgument{} is $shm$}{
                continue\;
            }
        }
        $MR \gets MR \cup \{n\}$\;
    }
}
\end{algorithm}

Finally, three kinds of bad partitioning within TEE projects are reported by \ccSysName.
Moreover, \ccSysName can provide strong scalability; by simply adding new rules to the system, it can be extended to detect a broader range of potential problems.
Thence, \ccSysName could adapt to evolving requirements and uncover additional vulnerabilities arisen from bad partitioning, making it valuable for ensuring robust and secure implementations of TEE projects.
