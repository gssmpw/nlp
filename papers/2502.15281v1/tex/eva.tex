\section{Evaluations} \label{s:eva}
We have conducted several experiments to prove the effectiveness of \ccSysName. In particular, our evaluation focuses on addressing the following research questions (RQs):

\begin{enumerate}[label=\textbf{RQ\arabic*.}]
    \item How effective is \ccSysName?
    \item How efficient is \ccSysName?
    \item How \ccSysName performs for the real-world TEE projects?
\end{enumerate}

\subsection{Environment Setup}
\subsubsection{Benchmark for Evaluation} \label{s:bench}
% Our dataset consists of \mnote{X} TEE-related projects sourced from GitHub, supplemented with synthetic code to expand its scale.
% The dataset contains \mnote{XXX} lines of code and includes \mnote{XX} ground truths (GT) related to bad partitioning.
% Specifically, there are \mnote{XX} instances of bad partitioning type \whiteding{1}, \mnote{XX} instances of type \whiteding{2}, and \mnote{XX} instances of type \whiteding{3}, providing a comprehensive foundation for evaluating the capabilities of \ccSysName.

% In order to cover a wide range of bad partitioning instances in TEE projects, it is necessary to create datasets by manually injecting vulnerabilities into TEE code~\cite{10.1145/3540250.3549128, 8901573}.
Prior studies~\cite{10.1145/3540250.3549128, 8901573} have created benchmarks for various static analysis tools that involve injecting vulnerabilities into code.
However, none of the existing studies have created a benchmark for TEE partitioning issues.
By referencing the construction methodology of the popular API-misuse dataset CryptoAPI-Bench~\cite{8901573, 9721567, 10225251}, we designed the benchmark \ccBenchName for evaluating the abilities of \ccSysName in bad partitioning detection.
We will describe its creation steps below.

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
int function(TEE_Param params[4])
{...
    params[0].value.a = var;
    ...
}
    \end{lstlisting}
    \caption{Example code of the in-procedure cases. In this case, the critical data \texttt{params} may be passed to another in-TEE function instead of being used directly after entering TEE, making it more challenging to track its data-flow.}
    \label{f:eic}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{\linewidth}
        \begin{lstlisting}[language=c++]
snprintf(params[1].memref.buffer, params[1].memref.size, "%s-%s-%d", key, vi, var);
    \end{lstlisting}
    \caption{Example code of the variadic function case. In this case, \texttt{snprintf} may have multiple arguments that need to be copied to the output buffer. Each argument must be checked to ensure it is encrypted.}
    \label{f:efs}
  \end{subfigure}
  \begin{subfigure}[b]{\linewidth}
        \begin{lstlisting}[language=c++]
if(params[2].memref.size > size) {
    memcpy(params[2].memref.buffer, buf, size);
}
    \end{lstlisting}
    \caption{Example code of control-flow-based cases. In this case, the memory operation \texttt{memcpy} is inside a conditional statement that checks the buffer size, so this operation is secure.}
    \label{f:eps}
  \end{subfigure}
  \caption{Examples of test cases in \ccBenchName.}
  \label{fig:cases}
\end{figure}

We divide the test cases into 5 parts, including basic cases, in-procedure cases, variadic function cases, control-flow-based cases, and combined cases. These parts will cover various bad partitioning issues.
\begin{enumerate}
    \item \textbf{Basic cases} are some simple instances described in in Section~\ref{s:bp}. These vulnerabilities typically occur in statements where parameters are directly used after invoking TEE.
    \item \textbf{In-procedure cases} mean that the parameter may be passed into other procedures or methods as an argument, which is shown in Fig.~\ref{f:eic}.
    \item Fig.~\ref{f:efs} gives a \textbf{variadic function case}, in which \texttt{snprintf()} may have more than one argument copied to the output buffer. We need to perform data flow analysis on each of them to find the issues of unencrypted data output.
    \item \textbf{Control-flow-based cases} will provide some \textbf{no-issue cases}, which can evaluate the precision of \ccSysName. For example, in Fig.~\ref{f:eps}, line 2 should not be identified as a bad partitioning issues, because it is in an \texttt{if} block, which checks the buffer size.
    \item \textbf{Combined cases} will introduce at least two of the above cases.
\end{enumerate}

As illustrated in Table~\ref{tbl:gttn}, we totally provide 110 cases for \ccBenchName, which are written in C programming language and developed for ARM TrustZone. Among these cases, 90 cases contain bad partitioning issues and 20 cases have no issues.

% \begin{table*}[t]
%     \caption{Summary of test cases in \ccBenchName. Details are given in Section~\ref{s:bench}.}
%     \label{tbl:benchmark}
%     \renewcommand{\arraystretch}{1.3}
%     \footnotesize
%     \centering
%     \setlength{\tabcolsep}{2.2mm}
% 	\begin{tabular}{c c p{1.3cm}<{\centering} p{1.3cm}<{\centering} p{1.3cm}<{\centering} p{1.3cm}<{\centering} p{1.3cm}<{\centering} p{1.6cm}<{\centering}}
% 		\toprule
% 		\multirow{2}{*}{\textbf{Bad Partitioning Issues}} & \multirow{2}{*}{\textbf{Basic Cases}} & \textbf{Once-Enterproce.} & \textbf{Twice-Enterproce.} & \textbf{Field Sensitive} & \textbf{Path Sensitive} & \textbf{Combined Cases} & \textbf{Total Cases per Issues}\\ 
%             \midrule
%             \makecell[l]{Unencrypted Data Output} & 5 & 6 & 4 & 6 & 6 & 16 & 43 \\
%             \makecell[l]{Input Validation Weaknesses} & 7 & 7 & 5 & 2 & 5 & 8 & 34 \\
%             \makecell[l]{Direct Usage of Shared Memory} & 6 & 7 & 3 & 6 & 2 & 9 & 33 \\
%             \midrule
%             \textbf{Total Cases pre Group} & 18 & 20 & 12 & 14 & 13 & 33 & 110\\
% 		\bottomrule
% 	\end{tabular}
% \end{table*}

% \begin{table}[t]
%     \caption{The number of bad partitioning issues and no-issue cases in \ccBenchName.}
%     \label{tbl:gttn}
%     % \renewcommand{\arraystretch}{1.3}
%     % \footnotesize
%     \setlength{\tabcolsep}{3mm}
%     \centering
% 	\begin{tabular}{lcc}
% 		\toprule
% 		\makecell[c]{\textbf{Bad Partitioning Issues}} & \textbf{Issue cases} & \textbf{No-issue Cases}\\ 
%             \midrule
%             Unencrypted Data Output & 35 & 8 \\
%             Input Validation Weaknesses & 29 & 5 \\
%             Direct Usage of Shared Memory & 26 & 7 \\
%             \midrule
%             \makecell[c]{\textbf{Total Cases}} & 90 & 20 \\
% 		\bottomrule
% 	\end{tabular}
% \end{table}

\begin{table}[t]
    \caption{The number of bad partitioning issues and no-issue cases in \ccBenchName.}
    \label{tbl:gttn}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    \setlength{\tabcolsep}{3mm}
    \centering
	\begin{tabular}{lc}
		\toprule
		\makecell[c]{\textbf{Bad Partitioning Issues}} & \textbf{Number of Cases}\\ 
            \midrule
            Unencrypted Data Output & 35 \\
            Input Validation Weaknesses & 29 \\
            Direct Usage of Shared Memory & 26 \\
            \midrule
            \makecell[c]{\textbf{No-issue Cases}} & 20 \\
            \midrule
            \makecell[c]{\textbf{Total Cases}} & 110 \\
		\bottomrule
	\end{tabular}
\end{table}

\subsubsection{Experimental Platform}
\ccSysName is implemented by Python in combination with the static analysis tool CodeQL. CodeQL is utilized to generate the data-flow for each parameter based on sources and sinks in Tables~\ref{tbl:out_df} to~\ref{tbl:shm}, and Algorithms~\ref{algo:odf} to~\ref{algo:mdf} for data-flow generation. The Python code is responsible for retrieving these data-flows and identifying the locations of bad partitioning issues with the help of Algorithms~\ref{algo:bp1} to~\ref{algo:bp3}.
All experiments were conducted on a machine running Ubuntu 24.04, equipped with a 48-core 2.3GHz AMD EPYC 7643 processor, and 512GB RAM.

% \begin{table*}[t]
%     \caption{The performance of \ccSysName in detecting three kinds of bad partitioning issues on benchmark. GT is the ground truth number of bad partitioning issues in each TEE project, TP is the number of true positives, and FP is the number of false positives. P, R, and F1 indicate the precision, recall, and F1 score, respectively\textsuperscript{*}.
%     }
%     \label{tbl:expr_res}
%     \renewcommand{\arraystretch}{1.3}
%     \footnotesize
%     \centering
%     \setlength{\tabcolsep}{2mm}
%     \begin{threeparttable} 
% 	\begin{tabular}{lccccccc|cccccc|cccccc}
% 		\toprule
% 		\multirow{2}{*}{\textbf{Projects}} & 
%             \multirow{2}{*}{\textbf{LoC}} & 
%             \multicolumn{6}{c}{Unencrypted Data Output} & 
%             \multicolumn{6}{c}{Input Validation Weaknesses} & \multicolumn{6}{c}{Direct Usage of Shared Memory} \\
%             \cline{3-20}
%              & & GT & TP & FP & P(\%) & R(\%) & F1 & 
%                  GT & TP & FP & P(\%) & R(\%) & F1 & 
%                  GT & TP & FP & P(\%) & R(\%) & F1 \\
% 		\hline
%             synthesis & 515 & 9 & 8 & 0 & 100 & 88.89 & 0.94 & 
%                         7 & 7 & 1 & 83.33 & 85.71 & 0.85 & 
%                         5 & 5 & 1 & 80 & 100 & 0.89 \\
%             optee-sdp & 468 & 12 & 10  & 0 & 100 & 83.33 & 0.91 & 
%                       --- & --- & --- & --- & --- & --- & 
%                       --- & --- & --- & --- & --- & --- \\
%             optee-fiovb & 399 & 1 & 1 & 1 & 100 & 100 & 1 & 
%                         &  &  &  &  &  & 
%                       --- & --- & --- & --- & --- & --- \\
%             basicAlg &  & & & & & & & 
%                        & & & & & & 
%                        --- & --- & --- & --- & --- & --- \\
%             rk\_tee\_user & & 2 & & & & & & 
%                        1 & 1 & --- & --- & --- & --- & 
%                        1 & 1 & & & & \\
%             secvideo & & --- & --- & --- & --- & --- & --- & 
%                       --- & --- & --- & --- & --- & --- & 
%                       & & & & & \\
%             darknetz & & --- & --- & --- & --- & --- & --- & 
%                       --- & --- & --- & --- & --- & --- & 
%                       & & & & & \\
%             \midrule
%             Total & & & & & & & & 
%                       & & & & & & 
%                       & & & & & \\
% 		\bottomrule
% 	\end{tabular}
%     \begin{tablenotes}
%         \footnotesize
%         \item[*] Note: $P(\%) = TP / (TP + FP) * 100$; $R(\%) = TP / GT * 100$; $F1 = 2 * P * R / (P + R)$.
%     \end{tablenotes}
%     \end{threeparttable} 
% \end{table*}

\subsection{RQ1: Precision and Recall Evaluation}

\begin{table}[t]
    \caption{The detection precision and recall of \ccSysName on \ccBenchName. NI is the number of partitioning issues, N is the number of detection results, and TP is the number of true positives. P, R and F1 indicates the precision, recall, and F1 score, respectively\textsuperscript{*}.
    }
    \label{tbl:recall_res}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    \setlength{\tabcolsep}{3mm}
    \centering
    \begin{threeparttable}
        \begin{tabular}{lcccccc}
        \toprule
        \makecell[c]{\textbf{Bad Partitioning Issues}} & \textbf{NI} & \textbf{N} & \textbf{TP} & \textbf{P(\%)} & \textbf{R(\%)} & \textbf{F1}\\
        \midrule
        Unencrypted Data Output & 35 & 34 & 33 & 97.06 & 94.29 & 0.96 \\
        Input Validation Weaknesses & 29 & 27 & 23 & 85.19 & 79.31 & 0.82 \\
        Direct Usage of Shared Memory & 26 & 30 & 25 & 83.33 & 96.15 & 0.89 \\
        \midrule
        \makecell[c]{\textbf{Total}} & 90 & 91 & 81 & 89.01 & 90 & 0.90\\
        \bottomrule
        \end{tabular}
    \begin{tablenotes}
        % \footnotesize
        \item[*] Note: $P(\%) = TP / N \times 100$, $R(\%) = TP / NI \times 100$.
    \end{tablenotes}
    \end{threeparttable}
\end{table}

Table~\ref{tbl:recall_res} lists the ground truth count of bad partitioning instances in these TEE projects, alongside the number of issues reported by \ccSysName. It can be seen that \ccSysName achieves the highest precision of 97.06\% in detecting bad partitioning of unencrypted data output. However, for the other two issues, more FPs are observed.

Through analysing the examples of misdiagnosed code shown in Fig.~\ref{fig:fp}, we categorize the FPs into the following three types:

\begin{figure}[t]
  \centering
    \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
char buf[] = "aabbcc";
...
params[0].memref.size = strlen(buf);
// params[1].value.a is the output, while params[2].value.a is the input
params[1].value.a = params[2].value.a;
    \end{lstlisting}
    \caption{The length of \texttt{buf} and \texttt{params[2].value.a} are not the sensitive data.}
    \label{fig:fp1}
  \end{subfigure}
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
unsigned int size = params[0].memref.size;
// obtain the third last character in the input buffer
char c = params[0].memref.buffer[size - 3];
    \end{lstlisting}
    \caption{Line 3 is the FP of input validation weaknesses, where \texttt{size} is an input parameter as array index.}
    \label{fig:fp2}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
// variable assignment by shared memory value
unsigned int size = params[3].memref.size;
// shallow copy of shared memory buffer
void *buf = params[3].memref.buffer;
    \end{lstlisting}
    \caption{Line 2 is the FP of direct usage of shared memory, where \texttt{params[0].memref.size} is a shared memory parameter.}
    \label{fig:fp3}
  \end{subfigure}
  \caption{Examples of FPs in \ccSysName reports.}
  \label{fig:fp}
\end{figure}

\begin{enumerate}
    \item \textbf{Non-sensitive data is assigned to the output:} Some data can be assigned to the output without encryption, and this will not compromise the confidentiality of TEE. For example, in Fig.~\ref{fig:fp1}, it is acceptable that we pass the length of the output buffer to the outside or copy the input directly to the output.
    \item \textbf{Indexing for Input Buffer with Its Size:} As shown in Fig.~\ref{fig:fp2}, although the index of array access is influenced by the input value \texttt{params[0].memref.size}, TEE can ensure that this input will not lead to buffer overflow. This is because that the input \texttt{params[0].memref.buffer} in TEE is actually a memory copy of the normal-side data, which is allocated with a size based on the above input value, and this input value is usually the size of the input data outside TEE. It means that the size of \texttt{params[0].memref.buffer} must not be smaller than the input value \texttt{params[0].memref.size}. Therefore, it is secure to directly use \texttt{params[0].memref.size} as an array index, even if no checks are performed on it which violates Rule 2.
    \item \textbf{Variable Assignment Using Shared Memory:} Similar to the input buffer, shared memory also transmits memory address and memory size, from the normal side to TEE by \texttt{params[3].memref}. According to Algorithm~\ref{algo:param_type}, both of these parameters are treated as the type of shared memory. Meanwhile, any assignment statement containing shared memory parameters is not allowed in Rule 3. However, the variable assignment in line 1 of Fig.~\ref{fig:fp3} can be acceptable, as it differs from the insecure shallow copy of shared memory in line 2.
\end{enumerate}

According to the Recall rate in Table~\ref{tbl:recall_res}, \ccSysName can give more comprehensive coverage of bad partitioning related to the direct use of shared memory than other issues.
% In order to analyze the missed detection, we get FNs by excluding true positives (TP) from GTs.
We also give two examples of FNs in Fig.~\ref{fig:fn} and discuss them as follow:

\begin{figure}[t]
  \centering
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
void test(char *dest, char *src)
{
    TEE_MemMove(dest, src, strlen(src));
}

void TA_InvokeCommandEntryPoint()
{
    char key[] = "123456";
    ...
    char *str = TEE_Malloc(strlen(key) + 1, 0);
    // case 1
    test(str, key);
    ...
    // case 2
    test(params[1].memref.buffer, key);
}
    \end{lstlisting}
    \caption{Line 15 is the FN of unencrypted data output, where \texttt{params[1].memref.buffer} is an output parameter.}
    \label{fig:fn1}
  \end{subfigure}
  \hfill
  \begin{subfigure}[b]{\linewidth}
    \begin{lstlisting}[language=c++]
char *str[1024] = {0};
...
for (int i = 0; i < params[2].memref.size; i++) {
    str[i] = params[2].memref.buffer[i];
}
    \end{lstlisting}
    \caption{Line 4 is the FN of input validation weaknesses, where \texttt{i} is affected by the input \texttt{params[2].memref.size}.}
    \label{fig:fn2}
  \end{subfigure}
  \caption{Examples of FNs in \ccSysName reports.}
  \label{fig:fn}
\end{figure}

\begin{enumerate}
    \item \textbf{Using Memory Operation Functions In Procedure:} The destination buffer \texttt{dest} of the function \texttt{TEE\_MemMove} in line 3 of Fig.~\ref{fig:fn1} is the formal parameter of function \texttt{test}.
    Therefore, \ccSysName recognizes the type of \texttt{dest} as a character array.
    However, as illustrated in lines 10 to 13, there are two instances of using \texttt{test}, one involves copying data to the in-TEE buffer \texttt{str}, while the other will copy data to an output.
    Since \ccSysName does not identify the actual parameter type of \texttt{dest} as an output, it also fails to report the above second instance as bad partitioning, which violates Rule 1.
    \item \textbf{Array Access Affected by Input:} Lines 3 to 5 give a \texttt{for} loop block, which is responsible for copying an buffer byte by byte.
    At this point, the input value \texttt{params[2].memref.size} does not directly serve as an index for array access but is instead used in the condition of \texttt{for} statement to constrain the value of \texttt{i}.
    Therefore, Algorithm~\ref{algo:idf} does not recognize this type of array access statement, that has broken Rule 2.
\end{enumerate}

In summary, if we formulate additional filters for the reported issues in the future, it is possible to effectively reduce FPs that deviate from the predefined rules but do not actually introduce security risks. What's more, we can refine the rules by incorporating the semantic context of the code, and FNs can be further reduced.

\begin{tcolorbox} [colback=gray!20!white]
\textbf{Answer to RQ1:}
(1) \ccSysName provides the highest F1 score of 0.96 in the detection of unencrypted data output (both precision and recall exceed 90\%).
(2) The detection of direct usage of shared memory achieves the best recall (above 95\%), but with relatively low precision (below 85\%).
(3) The detection of input validation weaknesses has an F1 score of 0.82. While its precision is above 85\%, the recall remains slightly lower at approximately 79\%.
\end{tcolorbox}

\subsection{RQ2: Efficiency Evaluation}

\begin{figure}
    \centering
    \includegraphics[width=0.5\linewidth]{figures/Fig_10.pdf}
    \caption{Time cost of data-flow construction and analysis under different scales of LoC in \ccSysName.}
    \label{fig:effi}
\end{figure}

On our benchmark tests, we recorded the time taken by \ccSysName to generate data-flows for three types of parameters and match these data-flows against the corresponding rules.

Algorithms~\ref{algo:odf} to \ref{algo:mdf}, which are responsible for constructing data-flows for parameters, involve $m$ parameters that need to be tracked and $n$ sensitive functions and data in TEE, resulting in the algorithmic complexity of them being $O(mn)$.
As shown in Fig.~\ref{fig:effi}, the time consumed by constructing data-flows increases from 21.53 seconds to 34.95 seconds as the lines of code (LoC) grow. 
Then, \ccSysName focuses only on critical functions and data during data-flow analysis, such as \texttt{TEE\_MemMove} and array access operations. The time spent on data-flow analysis remains relatively low and does not grow significantly with the changes of LoC (from 3.96 milliseconds to 7.13 milliseconds).

\begin{tcolorbox} [colback=gray!20!white]
\textbf{Answer to RQ2:}
As the code scale increases from 322 LoC to 5162 LoC, the time cost of the data-flow construction for bad partitioning analysis increases from 21.53 seconds to 34.95 seconds.
However, this time consumption also depends on the performance of the underlying code analysis tool.
\ccSysName still exhibits high efficiency for detecting bad partitioning issues in TEE projects (around 5.56 milliseconds).
\end{tcolorbox}

\subsection{RQ3: In-the-Wild Study}

% \begin{table*}[t]
%     \caption{The precision of \ccSysName in detecting three kinds of bad partitioning issues on real-world TEE projects. 
%     % N is the number of detection results, TP is the number of true positives, FP is the number of false positives, and P indicates the precision\textsuperscript{*}.
%     }
%     \label{tbl:expr_res}
%     \renewcommand{\arraystretch}{1.3}
%     \footnotesize
%     \centering
%     \setlength{\tabcolsep}{2.2mm}
%     \begin{threeparttable} 
% 	\begin{tabular}{lrp{0.6cm}<{\centering} p{0.6cm}<{\centering} p{0.6cm}<{\centering} p{0.6cm}<{\centering}|p{0.6cm}<{\centering} p{0.6cm}<{\centering} p{0.6cm}<{\centering} p{0.6cm}<{\centering}|p{0.6cm}<{\centering} p{0.6cm}<{\centering} p{0.6cm}<{\centering} p{0.6cm}<{\centering}}
% 		\toprule
% 		\multirow{2}{*}{\textbf{Projects}} & 
%             \multirow{2}{*}{\textbf{LoC}} & 
%             \multicolumn{4}{c}{Unencrypted Data Output} & 
%             \multicolumn{4}{c}{Input Validation Weaknesses} & \multicolumn{4}{c}{Direct Usage of Shared Memory} \\
%             \cline{3-14}
%              & & N & TP & FP & P(\%) & 
%                  N & TP & FP & P(\%) & 
%                  N & TP & FP & P(\%) \\
% 		\hline
%             % synthesis & 515 & 8 & 8 & 0 & 100 & 
%             %             6 & 5 & 1 & 83.33 & 
%             %             6 & 5 & 1 & 83.33 \\
%             optee-sdp & 830 & 11 & 11 & 0 & 100 & 
%                                7 &  7 & 0 & 100 & 
%                                0 &  0 & 0 & --- \\
%             optee-fiovb & 776 & 2 & 1 & 1 & 50 & 
%                                 2 & 2 & 0 & 100 & 
%                                 0 & 0 & 0 & --- \\
%             basicAlg\_use & 5,162 & & & & & 
%                                & & & & 
%                              0 & 0 & 0 & --- \\
%             external\_rk\_tee\_user & 716 & 4 & 2 & 2 & 50 & 
%                                   2 & 2 & 0 & 100 & 
%                                   1 & 1 & 0 & 100 \\
%             secvideo\_demo & 645 & 0 & 0 & 0 & --- & 
%                              0 & 0 & 0 & --- & 
%                              7 & 4 & 3 & 57.14 \\
%             darknetz & 41,608 & 0 & 0 & 0 & --- & 
%                                 0 & 0 & 0 & --- & 
%                                 1 & 1 & 0 & 100 \\
%             acipher & 338 & 1 & 0 & 0 & --- & 
%                             0 & 0 & 0 & --- & 
%                             0 & 0 & 0 & --- \\
%             Lenet5\_in\_OPTEE & 779 & 1 & 1 & 0 & 100 & 
%                                       3 & 2 & 1 & 66.67 & 
%                                       0 & 0 & 0 & --- \\
%             \midrule
%             Total & & & & & & 
%                       & & & & 
%                       & & & \\
% 		\bottomrule
% 	\end{tabular}
%     % \begin{tablenotes}
%     %     \footnotesize
%     %     \item[*] Note: $FP = N - TP$, $P(\%) = TP / N * 100$.
%     % \end{tablenotes}
%     \end{threeparttable} 
% \end{table*}

We searched for TEE-related projects on GitHub using API keywords associated with TEE. 
After excluding TEE SDK projects, we selected the top 16 projects with the highest star counts to evaluate the performance of \ccSysName on real-world programs, as shown in Table~\ref{tbl:expr_res}. 
These projects include 10 projects that have been manually analyzed in Section~\ref{s:bp}, along with 6 additional projects.

In these projects, \ccSysName reports 68 issues caused by bad partitioning and 55 of them are confirmed by ourselves.
For example, in \textit{optee-sdp} project, the log functionality implemented via \texttt{snprintf} copies a large amount of register data into the output parameters, which are accessible only to TEE. This compromises the confidentiality of TEE.
Additionally, in projects such as \textit{Lenet5\_in\_OPTEE},  \textit{external\_rk\_tee\_user}, there are instances where input buffers are directly used without validating their length.
Attackers could exploit this bad partitioning to cause buffer overflows in TEE applications.
What's more, in \textit{secvideo} project, encryption and decryption operations are directly performed on video data in shared memory, undermining the isolation provided by TEE.

\begin{table*}[t]
    \caption{The performance of \ccSysName in detecting three kinds of bad partitioning issues on real-world TEE projects. 
    % N is the number of detection results, TP is the number of true positives, FP is the number of false positives, and P indicates the precision\textsuperscript{*}.
    }
    \label{tbl:expr_res}
    % \renewcommand{\arraystretch}{1.3}
    % \footnotesize
    \setlength{\tabcolsep}{1.5mm}
    \resizebox{\linewidth}{!}{
    \centering
	\begin{tabular}{lr cc | cc | cc}
		\toprule
		\multirow{2}{*}{\textbf{Projects}} & 
            \multirow{2}{*}{\textbf{LoC}} & 
            \multicolumn{2}{c}{Unencrypted Data Output} & 
            \multicolumn{2}{c}{Input Validation Weaknesses} & \multicolumn{2}{c}{Direct Usage of Shared Memory} \\
            \cline{3-8}
             & & Report Number & True Positive & 
                 Report Number & True Positive & 
                 Report Number & True Positive \\
		\hline
            % synthesis & 515 & 8 & 8 & 0 & 100 & 
            %             6 & 5 & 1 & 83.33 & 
            %             6 & 5 & 1 & 83.33 \\
            optee-sdp & 830 & 11 & 11 &
                               7 &  7 & 
                             --- &  --- \\
            optee-fiovb & 776 & 2 & 1 & 
                                2 & 2 & 
                              --- & --- \\
            basicAlg\_use & 5,162 & 2 & 2 &  
                                    1 & 1 &  
                                  --- & --- \\
            external\_rk\_tee\_user & 716 & 4 & 2 & 
                                            2 & 2 & 
                                            1 & 1 \\
            secvideo\_demo & 645 & --- & --- & 
                                   --- & --- &
                                     7 & 4 \\
            darknetz & 41,608 & --- & --- &
                                --- & --- &
                                 1 & 1 \\
            acipher & 338 & 1 & 0 &
                          --- & --- &
                          --- & --- \\
            Lenet5\_in\_OPTEE & 1,610 & 1 & 1 & 
                                        3 & 2 &
                                      --- & --- \\
            hotp & 428 & 1 & 1 & 
                       --- & --- &
                       --- & --- \\
            random & 322 & 1 & 1 & 
                       --- & --- &
                       --- & --- \\
            read\_key & 404 & 2 & 1 & 
                       --- & --- &
                       --- & --- \\
            save\_key & 529 & 2 & 1 & 
                       --- & --- &
                       --- & --- \\
            socket-benchmark & 1,209 & 5 & 4 & 
                       --- & --- &
                       --- & --- \\
            socket-throughput & 1,100 & 5 & 5 & 
                       --- & --- &
                       --- & --- \\
            % tcp2ext & 322 & 5 & 1 & 
            %            --- & --- &
            %            --- & --- \\
            tcp\_server & 750 & 2 & 2 & 
                       --- & --- &
                       --- & --- \\
            threaded-socket & 1,059 & 5 & 3 & 
                       --- & --- &
                       --- & --- \\
            % \midrule
            % Total & & & & 
            %           & &  
            %           & \\
		\bottomrule
	\end{tabular}
    }
\end{table*}

\begin{tcolorbox} [colback=gray!20!white]
\textbf{Answer to RQ3:} 
\ccSysName is capable of identifying bad partitioning issues in real-world projects.
Through a review of 68 issues reported by \ccSysName in the wild, we have confirmed that 55 of them were true alarms.
% Additionally, we are actively reporting these issues to developers on GitHub.
\end{tcolorbox}
