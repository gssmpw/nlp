\section{Related work}
Python libraries such as Qiskit **Abhari, "Qiskit: An Open-Source Quantum Development Environment"** and PennyLane **Dutrieu, "PennyLane: Automatic Differentiation of Noisy Quantum Circuits"** provide library implementations for quantum integer arithmetic building blocks, such as adders and multipliers. However, the construction of complex expressions must be carried out programmatically in a manner that does not reflect the high-level intent. Furthermore, a specific implementation must be chosen explicitly for each operation, further entangling the functional intent with implementation details.
The addition operation, for example, may be implemented in many ways **Abhari, "Quantum Integer Arithmetic"**.
Moreover, the uncomputation of intermediate results must be performed manually. This introduces an additional layer of complexity into the code even when done naively. The size of registers for intermediate results, the final result, and the number of auxiliary qubits for each operation must also be specified explicitly, further burdening the programmer.

Q\# is similar to Qiskit and PennyLane in providing a library of operations for basic arithmetic building blocks **Lindner, "Q#: A High-Level Quantum Language"**. Unlike the Python libraries, Q\# supports local allocation and de-allocation of quantum storage. Hence, the management of auxiliary qubits can be handled within these building blocks and abstracted away in user code. Nevertheless, all implementation decisions within the basic operations, as well as in their composition into expressions, must still be handled explicitly. This leaves most of the responsibility for computing and uncomputing complex arithmetic to the programmer.

Qrisp **Dunjko, "Quantum Information Processing with Qrisp"** is similar in spirit to Qmod, and specifically in its support for quantum numeric variables and native arithmetic expressions. In addition, Qrisp includes some unique features not found in Qmod, such as arbitrary modular arithmetic. However, there are important Qmod capabilities that Qrisp does not provide at the time of writing this paper. For instance, Qrisp requires the size and precision of numeric variables to be declared explicitly and does not support type inference in this regard. Therefore, unless the programmer makes strong assumptions about how expressions are implemented, they risk overestimating or underestimating the required size when declaring the left-hand side variable of an assignment. In addition, Qrisp neither automatically truncates least-significant bits nor provides control over operation precision bounds. Because precision is effectively unbounded, only integers are supported as classical multiplication operands.

While Qmodâ€™s digital arithmetic (described in Section 3.1) has parallels in standard high-level programming languages, arithmetic computation in the phases or amplitudes of states (described in Section 3.2 and Section 3.3) does not. Of course, similar logic can be realized using gate-level description in any quantum programming framework. However, to the best of our knowledge, no other language currently supports these concepts natively, delegating their gate-level implementation to the compiler. In these respects, Qmod represents a significant step forward in terms of abstraction and automation potential.