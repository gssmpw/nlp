\section{Quasi-Newton method}

Quasi-Newton methods have been studied in the context of coupled problems in for example \cite{HaDe10,SchMe17,SchUe15} for the case where both solvers do one time step. They have recently been extended in \cite{RuUe21} to waveform iterations where both solvers use fixed equidistant time grids. For the case where the sub solvers use fixed but variable time steps, the residual is given by
\begin{equation}
	r(x) = \mathcal{S}_{2}  \circ \mathbf{I}_{\mathcal{T}_1} \circ \mathcal{S}_{1}( \mathbf{I}_{\mathcal{T}_2}(x)) - x \in \mathbb{R}^{d N_2},
\end{equation} 
where the term $\mathcal{S}_{2}  \circ \mathbf{I}_{\mathcal{T}_1} \circ \mathcal{S}_{1}( \mathbf{I}_{\mathcal{T}_2}(x))$ corresponds to the fixed point iteration in Equation \eqref{WRfixed}. 
To simplify the notation, we introduce the operator $H:R^{dN_2} \xrightarrow{} R^{d N_2}$ defined as 
\begin{equation*}
	H :=\mathcal{S}_{2}  \circ \mathbf{I}_{\mathcal{T}_1} \circ \mathcal{S}_{1}( \mathbf{I}_{\mathcal{T}_2}(x)), 
\end{equation*} 
simplifying the residual to 
\begin{equation*}
	r(x) = H(x) - x.
\end{equation*}

In order to avoid badly conditioned matrices, the Quasi-Newton method is often not applied to the residual $r(x) = H(x) - x$ directly. Instead it is applied to the modified residual defined as 
\begin{equation*}
	\tilde{r}(x) = H^{-1}(x) - x.
\end{equation*}
The update for the Quasi-Newton method is then given by
\begin{align}\label{QNWRFixed}
	\begin{split}
		\hat{x}^k &= H(x^k) \\
		x^{k+1} &= \hat{x}^{k} - W_k (V_k^T V_k)^{-1}V_k^{T} \tilde{r}(\hat{x}^{k}),
	\end{split}
\end{align} 
where  
\begin{equation*}
	V_k = [\tilde{r}(\hat{x}^1)-\tilde{r}(\hat{x}^0), ... , \tilde{r}(\hat{x}^k)-\tilde{r}(\hat{x}^{k-1})]  \in \mathbb{R}^{dN_2  \times k}
\end{equation*} 
and 
\begin{equation*}
	W_k = [\hat{x}^1 -\hat{x}^0, .... , \hat{x}^{k}- \hat{x}^{k-1}] \in \mathbb{R}^{dN_2 \times k}.
\end{equation*}

The modified residual $\tilde{r}(x)$ is generally not known explicitly. However, one can use the relation 
\begin{equation*}
	r(x) = H(x)-x = H^{-1} \circ H(\hat{x}) -  H^{-1}(\hat{x}) = -\tilde{r}(\hat{x}). \label{residuals}
\end{equation*} 
Using this, the matrix $V_k$ can be written as 
\begin{equation*}
	V_k = [-r(x^1)+r(x^0), ... , -r(x^k)+r(x^{k-1})]  \in R^{nd  \times k}. 
\end{equation*} 
This update requires one to have computed $x^1$, which is why one in the  first iteration commonly uses  a relaxation step.

Using the QR decomposition of $V_k = Q_k R_k$, where $Q_k$ has orthonormal columns and $R_k$ is an upper triangular matrix, the term $(V_k^TV_k)^{-1}V_k^T r(x^k)$ can efficiently be computed by solving $R_k \alpha = Q^T r(x^k)$ with backwards substitution. The update $W_k(V_k^TV_k)^{-1}V_k^T r(x^k) $ can then be computed by $W_k \alpha$. 
% This feels a little bit out of place here ... I would prefer to refer to the QN implementation in preCICE, since its actually more sophisticated.

In \cite{RuUe21} an alternative extension of the QN method to waveform iterations, referred to as the reduced Quasi-Newton waveform relaxation (rQNWR), is also presented. There, only the last time step is used to construct the residual and the matrix $V_k$, reducing the cost of the QR decomposition. Here, we focus on the version where all time steps are included in the residual and the matrix $V_k$. This allows for stronger convergence theorems in Section \ref{analysisQN}.

\subsection{Generalization to time adaptive sub-solvers}\label{QNWRTA}

The main difficulty with generalizing the Quasi-Newton method to time adaptive waveform iterations is that the number of time steps and the dimension of the discrete solution vector vary between iterations. Thus, the Quasi-Newton method for fixed time grids in equation \eqref{QNWRFixed} cannot directly be applied to the time adaptive waveform iterations in equation \eqref{badTAWR}. 

To extend the QN method to time adaptive waveform iterations, one has to either modify the Quasi-Newton method to work with a solution vector whose dimension changes in each iteration, or alternatively modify the time adaptive waveform iterations by interpolating everything to a fixed time grid. The former is possible by interpolating all vectors in the matrices $V_k$ and $W_k$, and then sampling the interpolant on the new time grid $\mathcal{T}_k$ after every iteration. Thus, one needs dynamic memory management and one needs to adjust the core QN update. This method is difficult to implement in a coupling library, and quite invasive. Furthermore, the convergence behaviour is hard to analyze, making it difficult to justify the added complexity of the implementation.

We therefore propose to instead interpolate the solution on an auxiliary fixed time grid $\mathcal{T}_{QN} = \{t^i_{QN}\}_{i=0}^{N_{QN}-1}$. We denote an interface vector on that grid by $x_{QN}$. It has the fixed dimension $dN_{QN}$. This changes the iteration in Equation \eqref{badTAWR} to
\begin{align} \label{WRTAQN}
	x_{QN}^{k+1} = \mathbf{I}_{\mathcal{T}_2^{k+1}} \circ \mathcal{S}^{TA}_{2}  \circ \mathbf{I}_{\mathcal{T}_1^{k+1}} \circ \mathcal{S}^{TA}_{1}\left( \mathbf{I}_{\mathcal{T}_{QN}}\left(x_{QN}^{k}\right)\right)\left(\mathcal{T}_{QN}\right).
\end{align} 

The Quasi-Newton update can then be computed exactly as described for fixed time steps, yielding the following time adaptive QNWR method:
 \begin{align}\label{timeAdaptiveQN}
	\begin{split}
		\hat{x}_{QN}^{k+1} &= \mathbf{I}_{\mathcal{T}_2^{k+1}} \circ \mathcal{S}^{TA}_{2}  \circ \mathbf{I}_{\mathcal{T}_1^{k+1}} \circ \mathcal{S}^{TA}_{1}\left( \mathbf{I}_{\mathcal{T}_{QN}^k}\left(x_{QN}^{k}\right)\right)\left(\mathcal{T}_{QN}\right) \\
		x_{QN}^{k+1} &= \hat{x}_{QN}^{k+1} + W_k (V_k^T V_k)^{-1}V_k^{T} r_{QN}(x_ {QN}^k),
	\end{split}
\end{align}
where the residual is given by 
\begin{align*}
	r_{QN}(x^k) = \hat{x}_{QN}^{k+1} - x^{k}_{QN} \in \mathbb{R}^{d N_{QN}},
\end{align*} 
and we have the matrices 
\begin{align*}
	V^{QN}_k &= [r_{QN}(x_{QN}^1)-r_{QN}(x_{QN}^0), ... , r_{QN}(x_{QN}^k)-r_{QN}(x_{QN}^{k-1})]  \in R^{n_{QN} d  \times k},\\
	W^{QN}_k &= [\hat{x}_{QN}^1 -\hat{x}_{QN}^0, .... , \hat{x}_{QN}^{k}- \hat{x}_{QN}^{k-1}] \in R^{d N_{QN}  \times k}.
\end{align*}

We have thus re-used the Quasi-Newton algorithm from the fixed time step case by adding one extra interpolation step, making it feasible to implement in coupling codes like preCICE. If both sub solvers use constant time grids, then we recover the QNWR method for fixed time steps if we choose $\mathcal{T}_{QN} = \mathcal{T}_2$. The interpolation error introduced by interpolating the iterates from $\mathcal{T}_2$ to $\mathcal{T}_{QN}$ when $\mathcal{T}_{QN} \neq \mathcal{T}_2$ will be investigated in section \ref{analysisQN}. 


\subsection{Implementation details of time adaptive QNWR in the open source coupling library preCICE}\label{implementationDetail}

preCICE is an open-source couping library designed to couple different solvers together in a minimally invasive fashion. For a more thorough description we refer to \cite{ChDa22}. In essence, preCICE controls the coupling between the two solvers, handling everything from the communication between the solvers to interpolating the interface data, as well as checking the termination criterion. For our purposes it is enough to know that preCICE has knowledge of the sub solvers interface data, time grids and the interpolations. Internally in preCICE the interface data, time steps and the interpolants are all stored in a class which all acceleration methods have full access to. 

preCICE also supports a wide range of different acceleration methods such as relaxation, aitken and QN. Furthermore, preCICE also supports a wide range of different options for such as scaling and filtering, as well as the QN extension IQN-IMVJ \cite{SchUe15}. The QN implementation in preCICE uses a vector to internally store the interface data. Furthermore, the implementation uses a class structure, with a base class for the QN methods containing common functionality.

We have implemented the time adaptive QNWR extension from section \ref{QNWRTA} in preCICE, scheduled to be released in version 3.2.0. For this, not many changes needed to be made. First, the pre-processing step, where the interface data is assembled in a large vector, has to be extended to interpolate the waveform iteration on the QN time grid $\mathcal{T}_{QN}$. Second, the post-processing step, where the QN vector is split back into interface data, has to be extended to also update the interpolant. These changes require that the QN methods can sample, reset and write new data to the interpolation object. However, they only require modifications to the QN base class. Lastly, in order to be able to select the Quasi-Newton time grid $\mathcal{T}_{QN}$ as the time grid of the second sub solver $\mathcal{T}_2$ the data structures in the QN classes have to be initialized after the first waveform iteration. This choice requires small changes to the inherited classes of the QN base class and is further discussed in Section \ref{preliminaryStudy}. 

\subsection{Linear analysis of the new method}\label{analysisQN}

To analyze the interpolation error in the new method \eqref{timeAdaptiveQN}, we assume that the solvers $S_1$ and $S_2$ both use the fixed time grid $\mathcal{T}_2$. 
%This allows us to analyze the impact of the interpolation error without considering the impact of the sub solvers adaptive time stepping on the simulation. While this setting is not very realistic, it still provides valuable insight into the behaviour of the time adaptive Quasi-Newton method as will be demonstrated in our experiments in Section \ref{preliminaryStudy}.
We further simplify the analysis by assuming that the solvers $S_1$ and $S_2$ are of the form, 
\begin{align*}
	x_1 &= A_1 x_2 + b_1 \\
	x_2 &= A_2 x_1 + b_2,
\end{align*} 
where $A_1, A_2 \in \mathbb{R}^{d N_2 \times d N_2}$ and $b_1, b_2 \in \mathbb{R}^{d N_2}$. The fixed point equation of the coupled system, given by 
\begin{align*}
	x_2 = S_2 \circ S_1(x_2),
\end{align*}
 simplifies then to 
 \begin{equation}\label{simWRTA}
	x_2 = A x_2 + b,
\end{equation} 
where $A \in \mathbb{R}^{d N_2 \times d N_2}$ and $b \in \mathbb{R}^{d N_2}$. 

In addition, we only consider linear interpolation, meaning that we can denote $I_{\mathcal{T}_{QN}}(x_{QN})({\cal T}_S)$ and $I_{\mathcal{T}_{S}}(x_{2})({\cal T}_{QN})$ by $\Phi x_{QN}$ and $\Theta x_{2}$ respectively, where $\Phi \in \mathbb{R}^{d N_2\times d N_{QN}}$ and $\Theta \in \mathbb{R}^{d N_{QN}\times d N_{2}}$ are matrices. For this simplified problem, the fixed point equation for the time adaptive QN method \eqref{timeAdaptiveQN} is given by \begin{align}\label{simQNWRTA}
	\begin{split}
		x_{QN} =\Theta A \Phi x_{QN} + b, \\
	\end{split}
\end{align} 

We now assume that the matrices $A$, $A-I$ and $\Theta A \Phi  - I$ are invertible. While these assumptions can be weakened this will not yield significantly more insight into the QNWR algorithms performance. Thus, the solutions of the fixed point equations \eqref{simWRTA} and \eqref{simQNWRTA} are characterized by 
\begin{equation*}
	x^* = (A - I)^{-1}b,
\end{equation*} 
and 
\begin{equation*}
	x^*_{QN} = (\Theta A \Phi - I)^{-1} \Theta b,
\end{equation*}  
respectively. The interpolation error of the QNWR method is then
\begin{equation*}
e_{QN} = x^* -  \Phi  x_{QN}^{*}.
\end{equation*}
Under these conditions it fulfills the following lemma.

\begin{lemma} \label{interpError}
If the coupled problem is linear and constant time grids are employed, then the interpolation error of the time adaptive QNWR \eqref{timeAdaptiveQN} is given by
\begin{equation}
e_{QN} = ( \Phi \Theta - I )b + ( \Phi  \Theta  (A^{-1} - \Phi \Theta )^{-1} \Phi \Theta  -(A^{-1}-I)^{-1} )b.
\end{equation} 
\end{lemma}
\begin{proof}
	The interpolation error is given by 
	\begin{equation*}
		e_{QN} = x^* -  \Phi  x_{QN}^{*} = (A- I)^{-1}b -  \Phi ( \Theta A \Phi  - I)^{-1} \Theta b.
	\end{equation*}
	Using that $A$, $A-I$ and $\Theta A \Phi  - I$ are invertible, the Sherman-Morrison-Woodbury formula yields
	\begin{align*}
		( \Theta A \Phi  - I)^{-1} &=  - I -  \Theta (A^{-1} - \Phi  \Theta )^{-1} \Phi,\\
		(A-I)^{-1} &= -I - (A^{-1}-I)^{-1},
	\end{align*}
	resulting in the following formula for the error
	\begin{equation*}
		e_{QN} = \left(-I - (A^{-1}-I)^{-1}\right)b - \Phi \left(- I  - \Theta (A^{-1} - \Phi  \Theta )^{-1} \right) \Theta b. 
	\end{equation*} 
	Simplifying yields,
	\begin{align*}
		e_{QN} = ( \Phi \Theta - I )b + ( \Phi  \Theta  (A^{-1} - \Phi \Theta )^{-1} \Phi \Theta  -(A^{-1}-I)^{-1} )b. 
	\end{align*} 
\end{proof}

It is worth pointing out that this interpolation error is zero if $\Phi \Theta = I$, which is the case if $\mathcal{T}_{QN} = \mathcal{T}_{2}$. If  $\Phi \Theta \neq I$, then the QNWR algorithm gives rise to an interpolation error which affects the accuracy of the simulation. For fixed time grids, choosing $\mathcal{T}_{QN}$ as the first time grid of the second sub solver $\mathcal{T}_2^1$ guarantees a zero interpolation error. For further investigations we refer to our experiments.  

Regarding convergence, general theorems are difficult, but a great deal can be said for linear fixed point equations like \eqref{simQNWRTA}. In \cite{HaDe10}, the following relationship was derived between the iterates $x^{k}_{GM}$ of GMRES and $x^{k}_{QN}$ of QN acceleration: 
\begin{align*}
	x^{k+1}_{QN} = A x^{k}_{GM} + b.
\end{align*} 
This relationship immediately proves the following theorem, since GMRES finds the exact solution in $d$ iterations.

\begin{theorem}\label{FiniteConvQN}
For a linear coupled system, QN converges to the exact solution in $d+1$ iterations, where d corresponds to the number of interface unknowns.
\end{theorem}

Thus, Theorem \ref{FiniteConvQN} guarantees that the time adaptive QNWR method converges to $x^*_{QN}$ in a finite number of iterations. This means that the choice of a fixed auxiliary grid when defining the new method gives us a convergent method, with a limit that contains an interpolation error, which can be controlled throught the choice of the auxiliary grid. 

As a final pont, we discuss termination: The algorithm might not terminate, since the residual is also affected by the interpolation error through the relation
\begin{equation*}
	r(\Phi x_{QN}^*) = r(\Phi x_{QN}^*)-r(x^*) = (A-I)(\Phi x_{QN}^*-x^*) = (A - I ) e_{QN}.
\end{equation*}

The residual of the last time step, which is used in the termination criterion of the waveform iteration \eqref{Conv-crit}, is given by
\begin{equation}\label{res}
\hat{r}(\Phi x_{QN})(t_f) = G \left( \left(A -I\right) \Phi x_{QN} - b \right),
\end{equation}
where $G = \begin{bmatrix}
	0 & \dots & 0 & I
\end{bmatrix} \in \mathbb{R}^{Nd \times d}$. We have the following result:

\begin{theorem}\label{QNWRTATerm}
  If the coupled problem is linear and the time grids $\mathcal{T}_2$ and $\mathcal{T}_{QN}$ are fixed, but possibly different, then $\hat{r}(\Phi x_{QN}^*)(t_f)=0$.
%the last time step of the residual, given in Equation \eqref{res}, is $0$ for $x_{QN}^*$. 
\end{theorem}

\begin{proof}
To show that the rhs of \eqref{res} is 0 for $x_{QN}^{*}$, we use that $t_f$ belongs to the time grids ${\cal T}_{QN}$ and ${\cal T}_2$. Thus, the interpolation matrices $\Phi$ and $\Theta$ have the following structure
\begin{equation*}
	\begin{bmatrix}
		\ddots &  & &   \\
		& \ddots & \vdots&   \\
		& \dots & \ddots &  \\
		0 & \dots & 0 & I
	\end{bmatrix},
\end{equation*}
where the last identity block has dimension $d$. 
	
The solution of the fixed point iteration in Equation \eqref{simQNWRTA} fulfills
\begin{align*}
	0 = ((\Theta A \Phi - I) x^*_{QN} + \Phi b).
\end{align*}
This holds in particular for the last row where we have
\begin{align*}
	0 = G \left( \left(\Theta A \Phi - I \right) x^*_{QN} - \Theta b \right).
\end{align*}
Simplifying using the fact that $G \Theta = G$ and $G \Phi = G$ yields
\begin{align*}:
0 =  \left( \left(G\Theta A \Phi - G \right) x_{QN}^* - G \Theta b \right) = G \left( (A-I)\Phi x_{QN}^* - b \right).
\end{align*}
Thus, the residual in the last time step is $0$ for $x^{*}_{QN}$. 
\end{proof}

Thus, in combination with Theorem \ref{FiniteConvQN}, this theorem guarantees that the time adaptive QNWR terminates after a finite number of iterations independently of the chosen time grid ${\cal T}_{QN}$.
