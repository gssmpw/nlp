\section{Heat test case}

To test the new method, we first consider two coupled linear heat equations as in \cite{BiMeMo23,BiMo18, BiMo19}. The combined problem is given by
\begin{align*}
	\alpha_1 \dot{u}_1(t,x) - \lambda_1 \Delta u_1(t,x) &= 0,  \quad x \in \Omega_1, \\
	\alpha_2 \dot{u}_2(t,x) - \lambda_2 \Delta u_2(t,x) &= 0, \quad  x \in \Omega_2, \\
	u_1(x,t) &= u_2(x,t), \quad  x \in \Gamma, \\
	u_2(x,0) &=  u_{0_2}(x), \quad  x\in \Omega_2,\\
	u_1(x,t) &= 0, \quad  x\in \partial \Omega_1 \setminus \Gamma, \\
	u_2(x,t) & = 0, \quad  x\in \partial \Omega_2 \setminus \Gamma, \\
	u_1(x,0) &=  u_{0_1}(x), \quad  x\in \Omega_1,\\
	\lambda_2 \frac{\partial u_2(x,t)}{\partial n} &= \lambda_1 \frac{\partial u_1(x,t)}{\partial n}, \quad  x \in \Gamma, 
\end{align*}
where $t\in[0,T_f]$, $\Omega_1 = [-1,0]\times[0,1]$, $\Omega_2 = [0,1]\times[0,1]$ and $\Gamma=\Omega_1\cap \Omega_2$. The constants $\lambda_1$ and $\lambda_2$ denote the thermal conductivities for the different materials in $\Omega_1$ and $\Omega_2$. Likewise, $\alpha_{m}$ for $m=1,2$ are constants defined by $\alpha_m = c_m \rho_m$, where $\rho_m$ is the density and $c_m$ the specific heat capacity of the material. The different material parameters used in the study are shown in Table~\ref{materials}. The initial value is given by $u(x,t) = 500\sin(\pi y)\sin(\pi(x + 1)/2)$.
\begin{table}
	\begin{center}
		\begin{tabular}{ |c|c|c| } 
			\hline
			Material & $\alpha$ $[J/(Km^3)]$ & $\lambda$ $[W/(mK)]$ \\ \hline
			Steel & 3 471 348 & 49 \\ \hline
			Water & 4 190 842 & 0.58 \\ \hline 
			Air & 1 299 465 & 0.024 \\
			\hline
		\end{tabular}
	\end{center}
	\caption{The different material parameters.}
	\label{materials}
\end{table} 

This coupled problem will be solved using Dirichlet-Neumann waveform iterations. Here, we use the Gau\ss -Seidel variant. First, the continuous Dirichlet problem on the time window $[0,T_f]$ is given by

\begin{align*}
	\alpha_1 \dot{u}^{k+1}_1(t,x) - \lambda_1 \Delta u^{k+1}_1(t,x) &= 0,  \quad x \in \Omega_1, \\
	u^{k+1}_1(x,t) &= 0, \quad  x\in \partial \Omega_1 \setminus \Gamma, \\
	u^{k+1}_1(x,t) &= u^k_\Gamma, \quad  x \in \Gamma,  \\
	u_1^{k+1}(x,0) &=  u_{0_1}(x), \quad  x\in \Omega_1,
\end{align*}
where $u_\Gamma^k$ denotes the interface temperature. Second, the Neumann problem on $[0,T_f]$ is given similarly by
\begin{align*}
	\alpha_2 \dot{u}^{k+1}_2(t,x) - \lambda_2 \Delta u^{k+1}_2(t,x) &= 0, \quad  x \in \Omega_2 \\
	u^{k+1}_2(x,t) &= 0, \quad  x\in \partial \Omega_2 \setminus \Gamma \\
	\lambda_2 \frac{\partial u^{k+1}_2(x,t)}{\partial n} &= q^{k+1}, \quad  x \in \Gamma, \\
	u_2^{k+1}(x,0) &=  u_{0_2}(x), \quad  x\in \Omega_2, 
\end{align*}
where $q^{k+1}=\lambda_1 \frac{\partial u_1^{k+1}(x,t)}{\partial n}$ denotes the heat flux from the Dirichlet domain. 

Exactly as in \cite{BiMo18} and \cite{BiMeMo23}, the two sub-problems are discretized using linear finite elements in space and SDIRK2 in time. For the fixed time step methods, the time step size is chosen such that both solvers obtain the same CFL number. This corresponds to choosing 
\begin{align*}
	\Delta t_1 &= T_f/(max(1, \lfloor(\alpha_1 \lambda_2)/(\alpha_2 \lambda_1)\rfloor)N), \\
	\Delta t_2 &= T_f/(max(1, \lfloor(\alpha_2 \lambda_1)/(\alpha_1 \lambda_2)\rfloor) N,
\end{align*} where the integer $N$ corresponds to a number of base time steps.

For the time adaptive methods, where the sub solvers select the time step based on an error measurement, a lower accuracy solution $\hat{u}$ can be obtained from the SDIRK2 method. The local error can then be estimated by $l^{k+1, n+1}_u = \tilde{u}^{k+1, n+1} - u^{k+1, n+1}$. The next time step is given by a PI controller, defined as
\begin{equation*}
	\Delta t^{k+1, n+1} = \Delta t^{k+1, n} \left (\frac{TOL_{TA}}{||l^{n+1}||_2}\right )^{1/12}\left (\frac{TOL_{TA}}{||l^{n}||_2}\right)^{1/12}.
\end{equation*} 
For the first time step we set $l^{0} = TOL_{TA}$, since we do not have any information of the previous error estimate. The first time step size is given by
\begin{equation*}
	\Delta t^0 = \frac{|T_f-T_0|TOL_{TA}^{1/2}}{100(1+||f(u_0)||_2)},
\end{equation*}
as suggested in \cite{So}. We choose $TOL_{TA}=TOL_{WR}/5$, compare \cite{BiMeMo23}. 

\subsection{Preliminary experiments}\label{preliminaryStudy}

We now study the choice of the time grid $\mathcal{T}_{QN}$ in the QN method for the case were both sub solvers use equidistant time grids, as well as when both sub solvers are time adaptive. For these experiments both the test case and algorithm will be implemented using python based on \cite{Me25}, allowing us to easily change the time grid $\mathcal{T}_{QN}$ inside the QN method. The updated code with the QN implementation is available under \cite{code}. 


\subsubsection{Interpolation error and termination}

We first consider equidistant time grids and use $N = 4, ..., 256$ number of base time steps. We also use an equidistant time grid in the Quasi-Newton method with grid sizes $N_{QN} = 10, 100, 10000$. The tolerance for the termination criteria was set to $10^{-12}$ in combination with a maximal number of QN iterations of 20. The error in the last time step and the number of iterations are reported in Figure \ref{iterationsQNF} and \ref{ErrorQNF}, respectively, for the different test cases. 

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorFixed/nbr_QNsteps_1_air_steel_10000.0iters.png}
		\caption{Air-steel}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorFixed/nbr_QNsteps_1_air_water_10000.0iters.png}
		\caption{Air-water}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorFixed/nbr_QNsteps_1_water_steel_10000.0iters.png}
		\caption{Water-steel}
	\end{subfigure}
	\hfill
	\caption{Number of iteration compared to the number of base time steps for different number of QN time steps.}
	\label{iterationsQNF}
\end{figure}

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorFixed/nbr_QNsteps_1_air_steel_10000.0trueErrors.png}
		\caption{Air-steel}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorFixed/nbr_QNsteps_1_air_water_10000.0trueErrors.png}
		\caption{Air-water}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorFixed/nbr_QNsteps_1_water_steel_10000.0trueErrors.png}
		\caption{Water-steel}
	\end{subfigure}
	\hfill
	\caption{Time discretization error of the last time step compared to the number of base time steps for different number of QN time steps.}
	\label{ErrorQNF}
\end{figure}

%Relate iteraitons to lemma 2...
In Figure \ref{iterationsQNF}, we see that the QNWR method terminated in a finite number of iterations for all test cases, which is in agreement with Theorem \ref{QNWRTATerm}. The number of iterations to reach the termination condition is almost independent of the QNWR time grid.
%However, it will have to be left as future work to see if this also generalizes to more complex test cases and other time interpolation methods.

Looking at the error in the last time step shown in Figure \ref{ErrorQNF}, one can observe that it quickly stagnates for $N_{QN} = 10$. This result is in agreement with Lemma \ref{interpError}, and due to that the QN time grid does not contain enough time steps to accurately represent the solution, resulting in a large interpolation error. 

Similarly, based on the result from Lemma \ref{interpError}, one would expect the error for the case $N_{QN} = 100$ to level off once both solvers do more than a 100 time steps. Additionally, one would expect the error for $N_{QN} = 10000$ to decrease linearly, since the QN time grid is finer than the time grids in the sub solvers. This is exactly what we see in the Air-steel and Air-water test case in Figure \ref{ErrorQNF}, where the case $N_{QN} = 10000$ decreases linearly while the error flattens out for $N_{QN} = 100$ when both solvers do more than a 100 time steps. 

For the Water-steel test case with $N_{QN} = 100$, the error also decreases linearly, which can be explained by that the time integration error is significantly larger than for the Air-steel and Air-water test cases. From these observations, we conclude that there is very little benefit to using more time steps in the QN time grid compared to the number of time steps in the sub-solvers. Furthermore, while using less time steps in the QN time grid reduces the computational cost, it also increases the interpolation error. 

\subsubsection{Comparison of different auxiliary time grids for the time adaptive case}

We now discuss how to choose the auxiliary grid $\mathcal{T}_{QN}$. A simple choice is be to use an equidistant time grid with a user defined number of time steps. However, based on our previous observations we expect that the computationally most efficient strategies use roughly the same number of time steps in the QN time grid as the two sub solvers. We therefore propose to select $\mathcal{T}_{QN}$ automatically based on the sub-solvers time grid after the first iteration. The following three strategies are considered:
 \begin{itemize}
	\item Stategy 1: The timegrid of the Neumann solver in the first iteration, $\mathcal{T}_{N}^1$,
	\item Stategy 2: The timegrid of the Dirichlet solver in the first iteration, $\mathcal{T}_{D}^1$,
	\item Stategy 3:  Equidistant time grid with the minimum number of time steps of the first time grid in the Dirichlet and Neumann solver.
\end{itemize}
To compare these strategies we look at the computational efficiency, error over work, reported in Figure \ref{TATGEfficiency}. The error was measured as the difference between the last time step of the solution and a solution that was computed with a tolerance of $10^{-6}$. The cost of the algorithm can be accurately measured by counting the number of time steps done by the two sub-solvers, since direct solvers are employed inside the two sub-solvers. 

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorTA/QNtimeGrid_1_air_steel_10000.0Efficiency.png}
		\caption{Air-steel}
	\end{subfigure}
	\hfill	
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorTA/QNtimeGrid_1_air_water_10000.0Efficiency.png}
		\caption{Air-water}
	\end{subfigure}
	\hfill
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/QNInterpolationErrorTA/QNtimeGrid_1_water_steel_10000.0Efficiency.png}
		\caption{Water-steel}
	\end{subfigure}
	\hfill
	\caption{The computational efficiency of the QNWR algorithm for the three different time grid selection strategies inside the time adaptive QNWR.}
	\label{TATGEfficiency}
\end{figure}

The three different time grid selection strategies in Figure \ref{TATGEfficiency} are quite close with strategy 2 performing slightly worse than strategy 1 and 3. Thus, there is little motivation not to choose strategy 1, since this reduces the QNWR method to \eqref{QNWRFixed} for fixed time steps. It also eliminates the interpolation error in the fixed time step case. 

\subsection{Efficiency of the time adaptive QNWR method}

We now compare the computational efficiency of our time adaptive QNWR algorithm with the optimal relaxation presented in \cite{BiMeMo23} and the multi-rate version of QNWR presented in \cite{RuUe21}. Similar to previous experiments, the code for the sub-solvers is based on \cite{Me25} and can be found here \cite{code}. Unlike in previous experiments we use the QNWR implementation in preCICE that is detailed in section \ref{implementationDetail}. For the optimal relaxation presented in \cite{BiMeMo23}, the coupling code is implemented in a stand alone python code closely following \cite{Me25}. 

We also include preCICE's relaxation feature, which uses a fixed relaxation parameter that is set before the simulation starts. We choose it as the optimal relaxation parameter of the first time step in this case.

As a measure of the computational efficiency we compare error over work, for tolerance $10^{-i}$, where $i = -1,...,-5$. The error was measured as the difference between the solution of the last time step and a solution that was computed with a tolerance of $10^{-6}$. 
For the multirate QNWR we used $N = 8, ..., 256$ base time steps in the sub solvers. Furthermore, a constant tolerance $TOL_{WR}$ of $10^{-6}$ was used in the multirate QNWR, corresponding to the finest tolerance used for the time adaptive methods. Work is measured as the total number of time steps done by the sub solvers, since direct solvers are employed inside the two sub-solvers and the cost of the coupling algorithm is assumed to be negligible compared to the cost of the sub-solvers. The results are presented in Figure \ref{QNEfficiency}.  

\begin{figure}
	\centering
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/EfficiencyTA/air_steelefficiency.png}
		\caption{Air-steel}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/EfficiencyTA/air_waterefficiency.png}
		\caption{Air-water}
	\end{subfigure}
	\begin{subfigure}[b]{0.3\textwidth}
		\centering
		\includegraphics[width=\textwidth]{Graphs/EfficiencyTA/water_steelefficiency.png}
		\caption{Water-steel}
	\end{subfigure}
	\caption{The error of the last time step compared to different tolerances.}
	\label{QNEfficiency}
\end{figure}

We see that for the Air-steel and Air-water test case all four methods are quite close together, implying that they will give similar performance on these two test cases. However, for the Water-Steel test case, we see a big difference in performance, with time adaptive QNWR being the fastest closely followed by the optimal relaxation parameter from \cite{BiMeMo23}. Using the constant acceleration method in preCICE results in a large loss of performance, which is due to that the optimal relaxation parameter of the first time step differs from the optimal relaxation parameter used in \cite{BiMeMo23}, resulting in significantly more iterations. The constant acceleration feature in preCICE is still more efficient than the multirate QNWR setup even though the multirate QNWR method terminated in fewer iterations. This can in part be explained by that the time adaptive solvers are able to select better step size ratios between the two solvers, making the time adaptive solvers the more robust choice.
