\section{Preliminary}

In this section, we introduce the theory of Linear Integer Arithmetic (LIA) in SMT and search techniques, including Conflict-Driven Clause Learning with Theory, also known as CDCL(T), and the local search framework for \SMTLIA.

\subsection{SMT(LIA)}
The Satisfiability Modulo Theories (SMT) problem involves evaluating whether a quantifier-free first-order logic formula is satisfiable within the context of certain background theories \cite{kroening2016decision,barrett2018satisfiability}. Our sampling algorithm is specifically designed to address the SMT sampling problem under Linear Integer Arithmetic (LIA) theory, that is, the \SMTLIA sampling problem. A constraint under LIA theory consists of a set of atomic formulas, where an \textit{atomic formula} can be a propositional variable or an arithmetic formula. Arithmetic formulas can consistently be expressed in the standard form $\sum_{i=0}^{n-1} a_ix_i \le k$ or $\sum_{i=0}^{n-1} a_ix_i = k$, where $x$ represents an integer variable, with $a$ and $k$ as constants. A \textit{literal} can either be an atomic formula or its negated form. A \textit{clause} is composed of the disjunction of a set of literals, and a formula in \textit{Conjunctive Normal Form} (CNF)  consists of the conjunction of a set of such clauses. Given sets of propositional variables $P$, and integer variables $X$, which are integral components of the \SMTLIA formula $F$, an assignment $\alpha$ of $F$ maps $X$ to the set of integers $\mathbb{Z}$ and $P$ to $\{true, false\}$. Under this assignment, $\alpha(x)$ represents the value of variable $x$.

The \textit{(Boolean) skeleton} of the SMT formula $F$ is obtained by replacing each atomic formula $\sigma$ in $F$ with its uniquely corresponding Boolean variable $p_\sigma$, where $p_\sigma$ is referred to as the (Boolean) encoder of $\sigma$.

\begin{example}
Given a set of integer variables \( X = \{x_1, x_2, x_3, x_4\} \) and a set of Boolean variables \( P = \{p_1, p_2\} \), and let \( F_{SMT(LIA)} \) be a typical \SMTLIA CNF formula, we construct the Boolean skeleton \( S_F \) of \( F_{SMT(LIA)} \) by introducing new Boolean variables \( p_{\sigma_1}, p_{\sigma_2}, p_{\sigma_3} \), corresponding to each LIA atomic formula.
\begin{equation}
\begin{split}
F_{SMT(LIA)} =  &\quad (p_1 \lor \neg p_2) \\
				&\land \left( \neg (x_1 + x_2 \le 2) \lor (-2x_1 + 3x_3 \leq 0) \right) \\
				&\land \left( p_2 \lor \left(3x_2 - 7x_3 \le 3 \right) \right)
\end{split}
\end{equation}

\begin{equation}
\begin{split}
	S_F = &\quad (p_1 \lor \neg p_2) \land \left( \neg p_{\sigma_1} \lor p_{\sigma_2} \right) \land (p_2 \lor p_{\sigma_3})
\end{split}
\end{equation}
\end{example}


\subsection{A Typical CDCL(T) Framework}
Most current SMT solvers, such as Z3~ \cite{de2008z3} and CVC5 \cite{barbosa2022cvc5}, deal with \SMTLIA constraints mainly using the Conflict-Driven Clause Learning with Theory (CDCL(T)) method. Within the CDCL(T) framework, a SAT solver based on the Conflict-Driven Clause Learning (CDCL) algorithm is used to reason about the Boolean skeleton of the \SMTLIA formula and solve this Boolean skeleton. The assignment generated by the SAT solver is then transferred to the theory solver, which processes the conjunction of the corresponding LIA atoms. The theory solver checks the consistency of the assignment under LIA theory and performs theory-based deductions.

\begin{algorithm}[htbp]
	\caption{CDCL(T) Algorithm.}
	\KwIn{%
		\begin{tabular}[t]{@{}l@{}}
			$F$: a SMT formula;
		\end{tabular}
	}
	\KwOut{the solution of $F$, or reporting "UNSAT";}
	$\alpha \leftarrow \{\}$;\\
	\While{true}{
		$c \leftarrow propagate()$;\\
		\uIf{$c \ne \emptyset$}{
			$lvl \leftarrow resolve\_conflict(c)$;\\
			\If{$ lvl < 0$}{
				\Return{'UNSAT'};
			}
			$backtrack(lvl)$;
		}
		\Else{
			\If{!decide()}{
				\Return{$\alpha$};
			}
		}
	}
	\Return $\alpha$;
\end{algorithm}

Algorithm 1 demonstrates the CDCL(T) framework implemented in Z3 \cite{de2008z3}. When a formula $F$ is loaded, its Boolean skeleton $S_F$ is abstracted. The assignment $\alpha_S$ to $S_F$ is continuously maintained throughout the search process of the CDCL(T) algorithm.

In line 3, \textit{propagate()} reasons about the unassigned variables in $S_F$ based on the current assignment, utilizing two techniques:\\
1. Boolean constraint propagation: deduced from the assignment in $\alpha_S$.\\
2. Theory propagation: constructs a T-theory formula based on the currently assigned encoders, and uses the T-theory solver to perform inference.

A new learnt clause is added to the clause database whenever a conflict is detected during propagation (line 3). At this point, the algorithm processes the conflict, derives the backtracking level \textit{lvl}, and clears certain variable assignments associated with the conflict (line 5). If the backtracking level $lvl < 0$ is deduced from the conflict, the algorithm returns 'UNSAT'.

Alternatively, If no further implications can be derived during the propagation process and no conflicts arise under the assignment $\alpha_S$, an unassigned variable is selected based on the \textit{branching heuristic} and assigned according to the \textit{phase selection heuristic}. Once a complete assignment is found without conflicts, the algorithm returns the current assignment $\alpha$, which serves as a model of the formula. More details about the CDCL(T) algorithm can be found in references \cite{kroening2016decision,barrett2018satisfiability,ganzinger2004dpll}.

\subsection{Local Search Framework for \SMTLIA}

The local search component of our sampling method uses the two-mode framework of LS-LIA, the first local search algorithm for \SMTLIA \cite{cai2022local}. Subsequently, we briefly review the LS-LIA algorithm.

\begin{algorithm}[htbp]
	\caption{Integer Mode of LS-LIA.}
	\While{non\_impr\_steps $\le L \times P_i$}{
		\If{all clauses are satisfied}{
			\Return $\alpha$;
		}
		\uIf{$\exists$ decreasing cm operation}{
			$op :=$ such an operation with the greatest $score$;
		}
		\Else{
			update clauses weights;\\
			$c :=$ a random falsified clause with integer variable;\\
			$op :=$ a $cm$ operation in $c$ with the greatest $dscore$;
		}
		$\alpha := \alpha$ with $op$ performed;
	}
\end{algorithm}

This algorithm divides its search process into two modes: \textit{Boolean mode} and \textit{Integer mode}. In different modes, operations on variables of the appropriate data type are selected to modify the current assignment. In each mode, when the number of \textit{non-improving steps} reaches the threshold it switches to another mode. In Boolean mode, the threshold is $L \times P_b$; in integer mode, its $L \times P_i$. Here, $P_b$ and $P_i$ denote the proportions of Boolean and integer literals in the falsified clauses, with $L$ as a parameter. In Boolean mode, the \textit{flip} operator turns a Boolean variable to its opposite value. The integer mode, as outlined in Algorithm 2, introduces a unique operator called the \textit{critical move (cm)} , which is defined below.

\begin{definition} The \textit{critical move} operator, represented as $cm(x, \ell)$, sets the integer variable $x$ to a threshold value that satisfies the literal $\ell$, where $\ell$ is a falsified literal that includes $x$.
\end{definition}

The threshold mentioned above refers to the minimal modification required to make the literal $\ell$ true for $x$. Example 2.2 demonstrates how \textit{critical move} operations can be applied to turn an arithmetic literal to true.

\begin{example}
Given the \SMTLIA constraint, which includes two literals, $\ell_1:=a - 5b \le -5$ and $\ell_2 := c -3d = 3$, the initial variable assignments are $\{a = 0, b = 0, c = 0, d = 0\}$. The operations $cm(\ell_1, a)$ and $cm(\ell_1, b)$ involve assigning 1 to variable $a$ and 2 to variable $b$, respectively, making the literal $\ell_1$ true. Similarly, $cm(\ell_2, c)$ and $cm(\ell_2, d)$ involve assigning variable $c$ to 3 and variable $d$ to 4, respectively, ensuring that the literal $\ell_2$ is true.
\end{example}

Whenever a $cm$ operation is executed, the corresponding literal $\ell$ is set to true. Therefore, during the algorithm's search process, any falsified literals are consistently selected, and a $cm$ operation is applied to make $\ell$ true.

%In our sampling algorithm, we optimised the \textit{critical move} operator for the sampling task. Now, this operator does not just modify the variables to boundary values, but modifies them to consistent random values based on the current state.
