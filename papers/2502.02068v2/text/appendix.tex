\newpage
\appendix
\onecolumn

\section{Additional Analysis}~\label{ap:analysis}
We analyze the effect of the message length on the watermarking performance in Table~\ref{tab:length}. As seen, increasing the message length results in degraded detectability, as the transformations to carry watermarks is limited on low entropy data. The code has to compromise the detectability to accommodate higher-bit watermarks. 

\begin{table}[!ht]
    \centering
    \small
    \vspace{-5pt}
    \begin{tabular}{c|c c c c}
    \toprule
       Message Length  &  Pass\% & AUROC & TPR & FPR \\ \hline
        4 bit & 98.15\% & 0.97 & 0.99 & 0.07\\
        8 bit & 97.74\% & 0.88 &  0.73 & 0.13\\
    \bottomrule
    \end{tabular}
    \vspace{-5pt}
    \caption{Impact of message length on the MBPP benchmark~\cite{austin2021program} performance.}
    \vspace{-10pt}
    \label{tab:length}
\end{table}

\section{Available Syntactic Transformations}~\label{ap:trans}
We provide details of the syntactic transformations used in \sys{} in Table~\ref{tab:code_style_options}. The transformations include naming style, loop type, loop condition, nested conditions, operator substitution, and parentheses in conditions. 

\begin{table}[!ht]
    \centering
    \small
    \renewcommand{\arraystretch}{1} %  
    \begin{tabular}{|l|p{5cm}|p{6cm}|}
        \hline
        \textbf{Name} & \textbf{Description} & \textbf{Example} \\
        \hline
        Naming Style & {\small Choice of naming conventions: \texttt{PascalCase}, \texttt{camelCase}, \texttt{snake\_case}, \texttt{\_underscore\_init}, or \texttt{ALL\_CAPS}.} & {\small 
        \begin{verbatim}
myVariable = 10  # camelCase
my_variable = 10  # snake_case
        \end{verbatim}
        } \\
        \hline
        Loop Type & {\small Choice between using a \texttt{for} loop or a \texttt{while} loop.} & {\small 
        \begin{verbatim}
for i in range(10):
    print(i)

while i < 10:
    print(i)
        \end{verbatim}
        } \\
        \hline
        Loop Condition & {\small Specification of conditions for infinite loops.} & {\small 
        \begin{verbatim}
while True:
    print("Running")

while 1:
    print("Running")
        \end{verbatim}
        } \\
        \hline
        Nested Conditions & {\small Use of merged conditions versus explicitly nested conditions.} & {\small 
        \begin{verbatim}
if x > 0 and y > 0:
    print("Both positive")

if x > 0:
    if y > 0:
        print("Both positive")
        \end{verbatim}
        } \\
        \hline
        Operator Substitution & {\small Choice between regular assignment and augmented assignment for binary operations.} & {\small 
        \begin{verbatim}
x = x * 5  # Regular
x *= 5  # Augmented
        \end{verbatim}
        } \\
        \hline
        Parentheses in Conditions & {\small Option to include or omit parentheses in \texttt{if} or \texttt{while} conditions.} & {\small 
        \begin{verbatim}
if (x > 0 and y < 10):
    print("Valid")

if x > 0 and y < 10:
    print("Valid")
        \end{verbatim}
        } \\
        \hline
    \end{tabular}
    \caption{Syntactic transformations provided by \sys{} to watermark Python code. }
    \label{tab:code_style_options}
\end{table}





\section{Additional Watermarked Examples}~\label{ap:example}
We include additional watermarked examples in the Figure~\ref{fig:append_example}.  The examples are randomly taken from HumanEval~\cite{chen2021codex} and MBPP~\cite{austin2021program}. All of the watermarks are successfully extracted. As seen, the watermarked code is functionality correct and the variables are replaced with close semantics. 


\begin{figure*}[!ht]
    \centering   
    \vspace{-10pt}
    \begin{minipage}{0.47\textwidth}
 \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Original code \#1]
def histogram(test):
    dict1={} 
    list1=test.split(" ") 
    t=0 
    for i in list1: 
        if(list1.count(i)>t) and i!='': 
            t=list1.count(i) 
        if t>0: 
            for i in list1: 
                if(list1.count(i)==t): 
                    dict1[i]=t 
            return dict1
\end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{0.47\textwidth}
        \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Watermarked code \#1]
def histogram(test):
    dict1={}
    list1=test.split(" ")
    t=0
    for item in list1:
        if ((list1.count(item)>t) and item!=''):
            t=list1.count(item)
    if (t>0):
        for item in list1:
            if(list1.count(item)==t):
                dict1[item]=t
    return dict1
        \end{lstlisting}
    \end{minipage} \\\vspace{-10pt}

     \begin{minipage}{0.47\textwidth}
 \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Original code \#2]
 def get_closest_vowel(word):
    if len(word) < 3:
        return ""
    vowels = {"a", "e", "i", "o", "u", "A", "E", 'O', 'U', 'I'} 
    for i in range(len(word)-2, 0, -1): 
        if word[i] in vowels: 
            if (word[i+1] not in vowels) and (word[i-1] not in vowels): 
                return word[i]
    return ""
\end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{0.47\textwidth}
        \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Watermarked code \#2]
def getClosestVowel(dates):
    if (len(dates) < 3):
        return ""
    vowels = {"a", "e", "i", "o", "u", "A", "E", 'O', 'U', 'I'}
    for i in range(len(dates)-2, 0, -1):
        if (dates[i] in vowels and (dates[i+1] not in vowels) and (dates[i-1] not in vowels)):
            return dates[i]
    return ""
        \end{lstlisting} 
    \end{minipage}\\\vspace{-10pt}
    \begin{minipage}{0.47\textwidth}
 \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Original code \#3]
def find_Extra(arr1,arr2,n) :
    for i in range(0, n) :
        if (arr1[i] != arr2[i]) :
            return i
    return n  
\end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{0.47\textwidth}
        \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Watermarked code \#3]
def find__extra(arr1,arr2,n) :
    for ena in range(0, n) : 
        if arr1[ena] != arr2[ena] : 
            return ena 
    return n 
        \end{lstlisting} 
    \end{minipage}\\ \vspace{-10pt}

    \begin{minipage}{0.47\textwidth}
 \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Original code \#4]
def fizz_buzz(n: int):
    ns = []
    for i in range(n):
        if i % 11 == 0 or i % 13 == 0:
            ns.append(i)
    s = ''.join(list(map(str, ns)))
    ans = 0
    for c in s:
        ans += (c == '7')            
    return ans
\end{lstlisting}
    \end{minipage}
    \hfill
    \begin{minipage}{0.47\textwidth}
        \begin{lstlisting}[basicstyle=\ttfamily\tiny,numbers=none,caption=Watermarked code \#4]
def FizzBuzz(n: int):
    Ns = []
    for I in range(n):
        if (I % 11 == 0 or I % 13 == 0):
            Ns.append(I)
    S = ''.join(list(map(str, Ns)))
    Ans = 0
    for C in S:
        Ans += (C == '7')
    return Ans
        \end{lstlisting} 
    \end{minipage} 
%     \\
%    \begin{minipage}{0.47\textwidth}
%  \begin{lstlisting}[basicstyle=\ttfamily\tiny,caption=Original code \#5]
% def sum_of_alternates(test_tuple):
%   sum1 = 0
%   sum2 = 0
%   for idx, ele in enumerate(test_tuple):
%     if idx % 2:
%       sum1 += ele
%     else:
%       sum2 += ele
%   return ((sum1),(sum2)) 
% \end{lstlisting}
%     \end{minipage}
%     \hfill
%     \begin{minipage}{0.47\textwidth}
%         \begin{lstlisting}[basicstyle=\ttfamily\tiny,caption=Watermarked code \#5]
% def sumOfAlternates(tests):
%   sum1 = 0
%   sum2 = 0
%   for idx, ele in enumerate(tests):
%     if (idx % 2):
%       sum1 += ele
%     else:
%       sum2 += ele
%   return ((sum1),(sum2)) 
%         \end{lstlisting} 
%     \end{minipage}
\vspace{-10pt}
    \caption{Watermarked example from HumanEval~\cite{chen2021codex} and MBPP~\cite{austin2021program}. The left code shows the original code and the right code shows the watermarked code, where all watermarks are successfully extracted.}
    \label{fig:append_example}
    \vspace{-10pt}
\end{figure*}

\section{\sys's Implementation Details}~\label{ap:hyper}
%In this section, we provide \sys's implementation details, including hyperparameter settings and architectures. 
\textbf{Hardware Infrastructure} Our code is implemented using PyTorch~\cite{pytorch}. The training and inference of our watermarking models are performed on NVIDIA RTX A6000 GPUs with Ubuntu 20.04.5 LTS and Intel(R) Xeon(R) Gold 6338 CPU. 


\textbf{Implementation Details} The training hyperparameters and model architecture settings are in Table~\ref{tab:hyper}.

\begin{figure}[!ht]

    \begin{minipage}[t]{0.3\linewidth}
    \vspace{10pt}
   \centering 
    \resizebox{\textwidth}{!}{
    \setlength\tabcolsep{3pt}
   \begin{tabular}{lc}
    \toprule
  Training-time & Settings\\
    \midrule
    Epoch, Batch size & 20, 16  \\
   $w_f$, $w_d$ $w_r$ & 1, 1, 0.05\\
    Maximum Token Size &  512\\
    Optimizer, Learning rate  & AdamW, 5e-5 \\
    $\sigma_p$ &  0.1\\
    \bottomrule  
  \end{tabular}}
    \end{minipage} 
    \hfill
     \begin{minipage}[t]{0.34\linewidth}
    \vspace{10pt}
    \centering 
    \resizebox{\textwidth}{!}{
    \setlength\tabcolsep{3pt}
    \begin{tabular}{lccc}
    \toprule
   SubModule  & Backbones & Input Size & Output Size\\
    \midrule
     Feat. $\mathbf{R}_f$ & Linear & 2304 & 768\\
     Lin. $\mathbf{R}_m$ & Linear & 4 & 768 \\
     Dec. $\mathbf{S}_{d1}$ & Linear & 1536 & 320 \\
     Dec. $\mathbf{S}_{d2}$ & Linear & 1536 & 32100 \\
    \bottomrule  
  \end{tabular}
 }\end{minipage} 
 \hfill
  \begin{minipage}[t]{0.34\linewidth}
    \vspace{10pt}
    \centering 
    \resizebox{\textwidth}{!}{
    \setlength\tabcolsep{3pt}
    \begin{tabular}{lccc}
    \toprule
   SubModule  & Backbones & Input Size & Output Size\\
    \midrule
    Enc $\mathbf{S}_e$ & CodeT5 Encoder & 512 & 768 \\
    Ext $\mathbf{R}_e$ & Linear & 768 & 4 \\
    \bottomrule  
  \end{tabular}
 }\end{minipage} 
   \captionof{table}{\sys's implementation details. From left to right, we show training hyperparameters, watermark insertion architecture, and watermark extraction architecture details. }\label{tab:hyper}
     \vspace{-0.5cm}
\end{figure}