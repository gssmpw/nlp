% \documentclass[11pt]{article}
% \documentclass[final,12pt,twocolumn]{elsarticle}
\documentclass[final,12pt,twocolumn]{elsarticle}
% \usepackage[left=1.75in, right=1.75in, top=1.25in, bottom=1.25in]{geometry}
\usepackage[margin=1.5cm,includefoot]{geometry}
% \usepackage{graphicx}
\usepackage[table,xcdraw]{xcolor}
\usepackage[refcheck=false,todonotes=false]{autopaper}
% refcheck=true can cause issues with \subref, switch to false before submission

% allow columns with specifeid length and centered content
\usepackage{array}
\newcolumntype{P}[1]{>{\centering\arraybackslash}p{#1}}

% format code blocks 
\usepackage{listings}

\definecolor{codegreen}{rgb}{0,0.6,0}
\definecolor{codegray}{rgb}{0.5,0.5,0.5}
\definecolor{codepurple}{rgb}{0.58,0,0.82}
\definecolor{backcolour}{rgb}{0.95,0.95,0.92}

\lstdefinestyle{mystyle}{
    backgroundcolor=\color{backcolour},   
    commentstyle=\color{codegreen},
    keywordstyle=\color{magenta},
    numberstyle=\tiny\color{codegray},
    stringstyle=\color{codepurple},
    basicstyle=\ttfamily\scriptsize,
    breakatwhitespace=false,         
    breaklines=true,                 
    captionpos=b,                    
    keepspaces=true,                                  
    showspaces=false,                
    showstringspaces=false,
    showtabs=false,                  
    tabsize=2,
    floatplacement=C,
    framexleftmargin=2pt,
    framexrightmargin=2pt,
    framextopmargin=1pt,
    framexbottommargin=1pt,
    frame=tb, framerule=0pt,
}

\lstset{style=mystyle}

% \usepackage{emoji}
\usepackage{makecell}  % Include this in the preamble for splitting text into multiple lines
\usepackage{adjustbox} % Include this in the preamble for angled headers
\usepackage{tabularx} % Include this in the preamble
\usepackage{pifont}   % Include this in the preamble for check marks
\newcommand{\cmark}{\ding{51}} % Check mark
\newcommand{\xmark}{\ding{55}} % Cross mark (optional)

\usepackage{CJKutf8}
\usepackage[utf8]{inputenc}
% \usepackage{luatexja} % for Japanese characters with LuaLaTeX

% \usepackage[labelfont=bf, skip=5pt, font={footnotesize}]{caption}

\usepackage{booktabs}


% \setlength{\parskip}{1em}
% \setlength{\parindent}{0in}
% \renewcommand{\baselinestretch}{1.1} 
\widowpenalty10000
\clubpenalty10000

% \usepackage[activate={true,nocompatibility},final,tracking=true,kerning=true,spacing=true,factor=1100,stretch=10,shrink=10]{microtype}

% \usepackage[style=chem-acs, articletitle=true]{biblatex}
% \renewcommand*{\bibfont}{\small}

% \addbibresource{references.bib}

\begin{document}

%to deal with white space better
\sloppy

% title, authors, abstract, keywords
\begin{frontmatter}

\title{Honegumi: An Interface for Accelerating the Adoption of Bayesian Optimization in the Experimental Sciences}
\author[utah,acceleration]{Sterling G.~Baird}\ead{sterling.baird@utoronto.ca}
\author[utah]{Andrew R. Falkowski}\ead{andrew.falkowski@utah.edu}
\author[utah,acceleration]{Taylor D.~Sparks}\ead{sparks@eng.utah.edu}

\address[utah]{Department of Materials Science and Engineering, University of Utah, Salt Lake City, UT 84108, USA}
\address[acceleration]{Acceleration Consortium, University of Toronto.\ 80 St George St, Toronto, ON M5S 3H6}


\date{August 2024}

\begin{abstract}
    \noindent Bayesian optimization (BO) has emerged as a powerful tool for guiding experimental design and decision-making in various scientific fields, including materials science, chemistry, and biology. However, despite its growing popularity, the complexity of existing BO libraries and the steep learning curve associated with them can deter researchers who are not well-versed in machine learning or programming. To address this barrier, we introduce Honegumi (\begin{CJK}{UTF8}{min}骨組み\end{CJK}), a user-friendly, interactive tool designed to simplify the process of creating advanced Bayesian optimization scripts. Honegumi offers a dynamic selection grid that allows users to configure key parameters of their optimization tasks, generating ready-to-use, unit-tested Python scripts tailored to their specific needs. Accompanying the interface is a comprehensive suite of tutorials that provide both conceptual and practical guidance, bridging the gap between theoretical understanding and practical implementation. Built on top of the Ax platform, Honegumi leverages the power of existing state-of-the-art libraries while restructuring the user experience to make advanced BO techniques more accessible to experimental researchers. By lowering the barrier to entry and providing educational resources, Honegumi aims to accelerate the adoption of advanced Bayesian optimization methods across various domains.
\end{abstract}

\begin{keyword}
Advanced Bayesian optimization \sep multi-task BO \sep autonomous experimentation \sep education
\end{keyword}

\end{frontmatter}

\section{Introduction}

Bayesian optimization (BO) has become a critical tool in guiding experimental and computational research in both lab and production settings. In contrast to traditional design of experiments approaches, the core BO loop sees a probabilistic model iteratively fit to observed data such that it models and eventually predicts the optimal region of a design space. The physical sciences, especially materials, chemistry, and biology have benefited greatly with numerous published case studies using the technique \cite{strieth-kalthoff_delocalized_2024, shields2021bayesian, agarwal2021discovery, chen2020bayesian, hickman2022bayesian}. %Need to add more famous case studies here.
Growing interest in self-driving laboratories has emphasized the need for automated experimental design policies to govern decision making. BO is and will continue to play a large role in this space \cite{arroyave2022perspective, tom2024self}. % Self-driving Labs for Chemistry and Materials Science (chemical reviews)
The core concepts and extensions of BO have been extensively reviewed within the literature, which we refer the unfamiliar reader to in the interest of brevity \cite{frazier_tutorial_2018, garnett_bayesian_2023, shahriari_taking_2016}.  

% How to make this less antagonistic towards Ax and Botorch?
Despite growing interest, there remains a barrier to entry in many BO libraries that dissuade researchers who aren't well versed in machine learning. Understanding the concepts behind BO does not immediately prepare a researcher to interact with many of the existing BO libraries such as Ax and Botorch \cite{balandat_botorch_2020}, which often employ library specific conventions and code structures in addition to making assumptions under the hood that aren't immediately clear to new users. Accessing more advanced features in these libraries typically requires extensive knowledge of the library codebase, which can limit researchers wanting to take advantage of new developments in the field of BO. Furthermore, these libraries typically aren't oriented towards experimental research, resulting in limited crossover between tutorial content and experimentalist needs. Building more targeted libraries is one solution, but runs the risk of minimal maintenance in the absence of larger organization support and may not include newer state of the art optimization tools.

Here we present Honegumi (\begin{CJK}{UTF8}{min}骨組み\end{CJK}), pronounced "ho-nay-goo-mee," a tool for interactively creating minimal working examples for advanced Bayesian optimization topics. Honegumi translates to "skeletal framework," which the developed tool echoes in its templating-oriented structure. Taking the form of a selection grid, the Honegumi interface dynamically constructs unit-tested python scripts based on user selections that can then be modified to meet user needs. Accompanying this selection tool is a suite of conceptual and coding tutorials that inform practitioners on the practical aspects of BO and guide them in making these modifications.

\section{Honegumi Overview}

\begin{figure*}
    \centering
    \includegraphics[width=0.9\textwidth]{figures/honegumi_selection_interface.png}
    \caption{Default selection interface available on the Honegumi web page with highlighted tooltip information.}
    \label{fig:selection_interface}
\end{figure*}

The Honegumi interface takes the form of a selection grid that allows users to configure optimization scripts through a series of toggleable options. Each row defines a distinct parameter or setting; for example, whether to construct a "Single" or "Multi" objective optimization script. The order of options reflects a balance between the order in which one proceeds in defining an optimization task, similarity in function, and the location within the constructed script. Tooltips provide additional context for each row and guide users in making appropriate selections for their application. An image of the interface is shown in \cref{fig:selection_interface}.

% ARF: Ax doesn't have a publication associated with it.

% ARF: Not sure if this is the right word here. Trying to emphasize that Ax tutorials all concern simple benchmarking problems with arbitrary constraints applied to them. Practical applications of BO are typically quite different and a little more messy.

Honegumi is built on top of the Adaptive Experimentation Platform (Ax Platform) developed by Meta. Ax provides a high-level tool set for performing BO campaigns and pulls from the state-of-the-art optimization and Gaussian process libraries BoTorch \cite{balandat_botorch_2020} and GPytorch \cite{gardner_gpytorch_2018}. A consequence of building on top of many libraries is that interacting with the codebase can be challenging. While a plethora of well written tutorials are present on the Ax website, these are typically oriented towards benchmark tasks and frequently span several operational modalities of the Ax framework (Loop, Service, and Developer), which can hinder researchers who may need to pull from several tutorials to find something that meets their specific needs. The Honegumi interface, on the other hand, simplifies and restructures how users access the powerful tools and state-of-the-art models built into Ax by providing a consistent framework that helps users learn the library's core features and extend them to their application needs. All scripts conform to the Ax Service API, which strikes a balance between simplicity and flexibility and is the recommended means of engagement with the Ax Platform. 

A Python script is dynamically constructed based on the selected options below the selection interface. This script functions as a minimum working BO example that can be copied and run in a code editor. Constructed tests are unit-tested to ensure functionality across the 4096 unique combinations of settings. This makes it easy for researchers to engage with the library's features without worrying about low-level implementation bugs. The standardized structure of the outputs provides a stable foundation of best practices for learning and expanding on simple BO scripts.

\section{An Educational Curriculum}

To guide users in modifying the scripts generated by Honegumi, a suite of conceptual and coding tutorials are included on the Honegumi website. The conceptual tutorials seek to emphasize important and often nuanced BO concepts and guide users in designing a script for their particular problem and avoiding certain pitfalls. The coding tutorials present a materials or chemistry problem and walk users through the process of translating a problem statement into proper Honegumi selections and code modifications. These are explained in more detail in the sections below.

\subsection{Concept Tutorials}

There is a risk in using tools with which one is unfamiliar, and BO can go astray if applied inappropriately. To further guide researchers, we provide several conceptual tutorials that expand on several topics that often cause confusion or are misapplied. The conceptual tutorials do not seek to be rigorous, but rather to provide practical understandings of nuanced topics through the use of written explanation, visuals, and mathematical equations where appropriate. The aim is to inform researchers such that they can make selections with greater confidence and understand the shortcomings of different optimization approaches. At the time of publication, there are four concept tutorials available on the Honegumi webpage covering single versus multi-objective optimization, batch optimization, standard versus fully Bayesian Gaussian process models, and the advantages and disadvantages of multitask BO. These are visualized along with an example of a tutorial in \cref{fig:concept_tutorials}. 

\begin{figure*}[h!]
    \centering
    \includegraphics[width=\textwidth]{figures/honegumi_concept_tutorials.png}
    \caption{List of concept tutorials and an example of the formatting.}
    \label{fig:concept_tutorials}
\end{figure*}

At the end of each concept tutorial is a link to a coding tutorial that shows how this concept can be applied using Honegumi, giving users the opportunity to see it in action within Ax. Additionally, a list of relevant references, publications, videos, and blogs that provide deeper insights on the concept are provided for those seeking deeper understanding. Honegumi does not seek to be a replacement for a proper education in BO, but rather to bridge the knowledge gap and make it easier for researchers to expand their knowledge of BO and engage with deeper literature.

\subsection{Coding Tutorials}

A variety of coding tutorials are provided on the Honegumi website that translate common experimental challenges into functional optimization scripts. All coding tutorials follow a common structure that proceeds from an experimental problem statement inspired by a real world application, the selections in Honegumi one might make given this problem statement, modification of the Honegumi constructed framework, to visualizations and analysis of results. While taking the guise of real experimental scenarios, the objective functions provided in each coding tutorial are synthetic and are intended to be functional examples rather than challenges. Each coding tutorial ends with a list of possible next steps and ways of further expanding the script. This inclusion is pedagogical and seeks to expand user's grasp of the tool and knowledge of what is possible with the tool set. The list of coding tutorials along with the concept(s) they explore is presented in \cref{tab:coding-tutorials}.

% \renewcommand{\arraystretch}{1.4}

% \begin{table*}[!ht]
% \raggedright % Left-align the whole table except "Tutorial"
% \caption{List of coding tutorials and explored optimization concepts. "Constr." refers to constraint. "obj." refers to objective. "thresh." refers to threshold.}
% \label{tab:coding_tutorials}
% \begin{tabularx}{\textwidth}{@{}>{\centering\arraybackslash}m{0.4cm} >{\centering\arraybackslash}m{6.8cm}*{12}{>{\centering\arraybackslash}p{0.35cm}}@{}}
% \toprule
% & \textbf{Tutorial} & \rotatebox{55}{\textbf{Multi-obj.}} & \rotatebox{55}{\textbf{Custom models}} & \rotatebox{55}{\textbf{Multi-task}} & \rotatebox{55}{\textbf{Categorical vars.}} & \rotatebox{55}{\textbf{Sum Constr.}} & \rotatebox{55}{\textbf{Order Constr.}} & \rotatebox{55}{\textbf{Linear Constr.}} & \rotatebox{55}{\textbf{Composition}} & \rotatebox{55}{\textbf{Custom thresh.}} & \rotatebox{55}{\textbf{Historical data}} & \rotatebox{55}{\textbf{Batching}} & \rotatebox{55}{\textbf{Visualization}} \\ 
% \midrule

% \emoji{thread} & \makecell[tl]{Optimizing 3D Printed Material \\ Strength under Constraints} &  &  &  & \cmark &  &  & \cmark &  &  &  &  & \cmark \\

% \emoji{test-tube} & \makecell[tl]{Optimizing a Polymer Compound \\ for Strength and Density} & \cmark &  &  &  &  &  &  & \cmark & \cmark & \cmark &  & \cmark \\

% \emoji{droplet} & \makecell[tl]{Optimizing Anti-Corrosion Coatings \\ with Noisy Measurements} &  & \cmark &  &  &  & \cmark &  & \cmark &  &  & \cmark & \cmark \\

% \emoji{triangular-ruler} & \makecell[tl]{Optimizing MAX Phases \\ with Featurization} &  & \cmark &  &  &  &  &  &  &  & \cmark &  & \cmark \\

% \emoji{teapot} & \makecell[tl]{Multi-Task Optimization Across \\ Ceramic Binder Systems} &  &  & \cmark &  &  &  &  &  &  &  &  & \cmark \\

% \emoji{person-lifting-weights} & \makecell[tl]{Benchmarking Acquisition Functions} & \cmark &  &  &  &  &  &  &  &  &  &  &  \\


\begin{table*}[!ht]
\renewcommand{\arraystretch}{0.15}
\centering
\caption{List of coding tutorials and explored optimization concepts. "Constr." refers to constraint. "obj." refers to objective. "thresh." refers to threshold.}
\label{tab:coding-tutorials}
% \begin{tabularx}{\textwidth}{@{}P{3.155in}*{12}{p{0.405cm}}@{}}
\begin{tabularx}{\textwidth}{@{}P{2.55in}*{12}{p{0.405cm}}@{}}
\textbf{Tutorial Name} &
  \rotatebox{55}{\textbf{Multi-Obj.}} &
  \rotatebox{55}{\textbf{Custom Model}} &
  \rotatebox{55}{\textbf{Multi-Task}} &
  \rotatebox{55}{\textbf{Categorical Vars.}} &
  \rotatebox{55}{\textbf{Sum Constraints}} &
  \rotatebox{55}{\textbf{Order Constraint}} &
  \rotatebox{55}{\textbf{Linear Constraint}} &
  \rotatebox{55}{\textbf{Composition}} &
  \rotatebox{55}{\textbf{Custom Thresh.}} &
  \rotatebox{55}{\textbf{Historical Data}} &
  \rotatebox{55}{\textbf{Batching}} &
  \rotatebox{55}{\textbf{Visualization}} \\ \midrule
\end{tabularx}
\begin{tabularx}{\textwidth}{@{}l*{12}{|P{0.39cm}}|@{}}
\makecell[l]{Optimizing 3D Printed Material\\[-2pt] Strength Under Constraints}  &   &   &   &  \cellcolor{gray!15}\cmark &  &   & \cellcolor{gray!15}\cmark &   &   &   &   & \cellcolor{gray!15}\cmark \\ \\
\makecell[l]{Optimizing a Polymer Compound \\[-2pt] for Strength and Density}    & \cellcolor{gray!15}\cmark &   &   &   &  &   &   & \cellcolor{gray!15}\cmark & \cellcolor{gray!15}\cmark & \cellcolor{gray!15}\cmark &   & \cellcolor{gray!15}\cmark \\ \\
\makecell[l]{Optimizing Anti-Corrosion Coatings\\[-2pt] with Noisy Measurements} &   & \cellcolor{gray!15}\cmark &   &   &  & \cellcolor{gray!15}\cmark &   & \cellcolor{gray!15}\cmark &   &   & \cellcolor{gray!15}\cmark & \cellcolor{gray!15}\cmark \\ \\
\makecell[l]{Optimizing MAX Phases\\[-2pt] with Featurization}                   &   & \cellcolor{gray!15}\cmark &   &   &  &   &   &   &   & \cellcolor{gray!15}\cmark &   & \cellcolor{gray!15}\cmark \\ \\
\makecell[l]{Multi-Task Optimization Across\\[-2pt] Ceramic Binder Systems}      &   & \cellcolor{gray!15}\cmark & \cellcolor{gray!15}\cmark &   &  &   &   &   &   &   &   & \cellcolor{gray!15}\cmark \\ \\
\makecell[l]{Benchmarking Across Several \\[-2pt] Acquisition Functions}         & \cellcolor{gray!15}\cmark &   &   &   &  &   &   &   &   &   &   &  \\
\bottomrule
\end{tabularx}
\end{table*}

\renewcommand{\arraystretch}{1.0}

\section{Under the Hood}

Behind the scenes, a suite of connected tools facilitates the assembly of coding templates, testing of relevant combinatorial selection options, and presentation of the interface to the user. There are two key tools that enable this are \href{https://jinja.palletsprojects.com/}{Jinja} and \href{https://pyscript.net/}{PyScript}, described below. Jinja is a Python-friendly templating engine that encodes the logic of the selection interface. PyScript is a package enabling Python in the browser, which allows the Honegumi package to be run on a ReadtheDocs instance. The influence of these tools on the Honegumi workflow are described below and presented visually in \cref{fig:flowchart}.

\begin{figure}[!b]
    \centering
    \includegraphics[width=\linewidth]{figures/honegumi_flowchart.png}
    \caption{Flowchart detailing the honegumi workflow.}
    \label{fig:flowchart}
\end{figure}

When a researcher visits the website, an HTML script runs that downloads PyScript and the most recent version of the \texttt{honegumi} package that has passed a unit testing framework. The use of unit testing ensures that updates to the code base do not break one of the 4096 possible scripts generated by selection combinations. Once loaded, PyScript calls the \texttt{honegumi} API on a default selection configuration. The \texttt{honegumi} API uses Jinja to render a Jinja template file into a Bayesian optimization script, which is then passed back to PyScript to be displayed to the user directly beneath the selection grid (\cref{fig:selection_interface}). The Jinja template file encodes the logic around which lines should be added, removed, or modified based on the selected set of options. Likewise, the code that renders the Jinja template encodes incompatible feature combinations, either due to not being implemented or being logically inconsistent. These incompatible configurations are crossed out. The act of pulling appropriate coding templates and displaying them to the user is repeated each time a new configuration option is selected.

The following subsections provide additional technical details on the implementations of the key tools enabling the framework.

\subsection{Jinja Templates}

The BO scripts presented to the user are generated using the Jinja templating engine. Jinja allows a suite of conditional "if" statements to map user selected options to a resulting script. These are sufficiently expressive to allow for multi-conditioned "if" statements to be used in cases where several options might create conflicts within the generated script. 

For example, take the case where one wants to switch between a function that returns a single output (single-objective) and one with two outputs (multi-objective) depending on the value of \texttt{obj}. The code blocks below show the Jinja template and the results depending on the value of \texttt{obj}:\\

\begin{lstlisting}[
  language=Python, 
  label={lst:jinja}
]
def fn{% if obj == "multi" %}_moo{% endif %}(x1, x2):

    y = 0.5*x1 + 0.2*x2
    
    {% if obj == "multi" -%}
    y2 = 0.2*x1 + 0.5*x2
    
    return {obj1_name: y, obj2_name: y2}
    {% else %} {# single objective #}

    return y
    {%- endif %}
\end{lstlisting}

% If this Jinja template were to be rendered with \texttt{obj="single"}, then the following single-objective script would be produced:

\noindent If \texttt{obj = "single"}, Jinja renders:

\begin{lstlisting}[
  language=Python, 
  label={lst:jinja-single}
]
def fn(x1, x2):
    y = 0.5*x1 + 0.2*x2
    return y

\end{lstlisting}

\noindent If \texttt{obj = "multi"}, Jinja renders:

\begin{lstlisting}[
  language=Python,  
  label={lst:jinja-multi}
]
def fn_moo(x1, x2):
    y = 0.5*x1 + 0.2*x2
    y2 = 0.2*x1 + 0.5*x2
    return {obj1_name: y, obj2_name: y2}
\end{lstlisting}


The full implementation is available at \href{https://github.com/sgbaird/honegumi/blob/main/src/honegumi/ax/main.py.jinja}{main.py.jinja} [\href{https://github.com/sgbaird/honegumi/blob/5ea978626c8dcd5869df1e4032ef837574c1e3fb/src/honegumi/ax/main.py.jinja}{permalink}] within the GitHub repository. Jinja is also used to create the HTML file with the Honegumi selection grid via \href{https://github.com/sgbaird/honegumi/blob/main/src/honegumi/core/honegumi.html.jinja}{honegumi.html.jinja} [\href{https://github.com/sgbaird/honegumi/blob/5ea978626c8dcd5869df1e4032ef837574c1e3fb/src/honegumi/core/honegumi.html.jinja}{permalink}].

% https://github.com/sgbaird/honegumi/blob/b2ae0275e02452162b00654fd92b03348bb46af7/src/honegumi/ax/main.py.jinja

% https://github.com/sgbaird/honegumi/blob/f963411997acaed046ad9e3f17f14f8ee3bbefd3/src/honegumi/core/honegumi.html.jinja

\subsection{PyScript}

Honegumi functions principally off of PyScript, which allows Python to be run in the browser and Honegumi to have a similar feel to a web application. Upon initialization, PyScript and Honegumi are installed. PyScript executes a top-level function within the \texttt{honegumi} package using the current grid selections as inputs, and outputs the rendered BO script. Each time a new selection is made, PyScript runs the function again.

Alternatively, we could have written all of the Honegumi functionality in pure Javascript, or taken a separate approach of hosting Honegumi as a dedicated web app with a full Python environment. Rather than splitting between languages, a Python-based approach was preferred for maintainability purposes. However, creating a dedicated web app with a Python environment would reduce the portability and separate the interface from the documentation site. PyScript offered a straightforward middle path where most of the development could still be done in Python and the interface could still be directly embedded within a static website.

Since PyScript uses WebAssembly and MicroPython, it can be run on most browsers; however, one limitation is that the Python code and dependencies must be based on pure Python. This is not a problem, since Honegumi and all dependencies are written this way.

% \subsection{Hypothesis Testing}

% Ideally, Honegumi will generate valid BO scripts that run correctly and do not raise unwanted errors. However, using a brute force method to run a script for every combination scales poorly. For example, the 4096 possible combinations with 12 binary options require approximately 160 hours of compute. Likewise, removing testing altogether is likely to lead to invalid implementations, which is problematic for the end user. Hypothesis allows us to maintain both robustness and scalability by intelligently and iteratively selecting a subset of tests to run.

% By design, Honegumi suffers from the combinatorial scaling issue that comes from mixing and matching many types of features. For example, there are 4096

% Manually writing test cases for all possible combinations of selections, which often fail in unique ways is odious, and isn't amenable to future scaling. To account for this, Honegumi uses Hypothesis to automatically generate a diverse range of test cases that cover a much broader spectrum of scenarios. \textbf{what sort of test cases?} In this way, edge cases, which might be challenging to find manually are automatically found and added to a recurring testing check. The other advantage of employing this method is in testing time. Prior to the implementation of Hypothesis, testing took approximately four hours when distributed across 40 cores available through github actions compute. Though not particularly long in the grand scheme, this limited iteration ability and slowed development. Additionally, it disincentivized additional more rigorous testing implementations in the interest of not extending that further. \textbf{add more.}

% A user goes to the honegumi website hostex on readthedocs. When they first enter the website, an html script runs that downloads pyscript and by extension the honegumi python package. When the user clicks a button, pyscript triggers a python function to run that passes the options selected within the grid to the Honegumi API. The Honegumi API uses Jinja to render a Jinja template file into a Bayesian optimization script, which is then passed back to pyscript to be displayed to the user directly beneath the grid. The Jinja template file encodes the logic around which lines should be added, removed, or modified based on the selected set of options. Within the Ax API, advanced functionality sometimes requires a change in the top-level syntax. Likewise, the code that renders the Jinja template encodes incompatible feature combinations, either due to not being implemented or being logically inconsistent. These get crossed out on the grid. Modification of the Jinja template and the encoding of incompatible configurations both require a thorough understanding of the Adaptive Experimentation (Ax) Platform API and how it relates to advanced Bayesian optimization tasks. To help catch errors early on and avoid releasing versions of Honegumi with incorrectly implemented outputs, unit tests are run on GitHub packages before a new release of the Honegumi package is allowed and surfaced to the website. We choose to use Hypothesis -- a property-based testing framework -- to help address the combinatorial complexity that comes from having many option rows. For example, with 12 rows, each with two options, there are 4096 possible configurations. Hypothesis intelligently chooses a subset of these Bayesian optimization scripts to run.

% \begin{table*}[]
% \caption{Tools Used in the Honegumi Project}
% \label{tab:honegumi_tools}
% \setlength{\extrarowheight}{0.4em}
% \begin{tabularx}{\textwidth}{>{\centering\arraybackslash}p{2cm} X X}
% \toprule
% \textbf{Tool} & \textbf{Description} & \textbf{Relevance to Honegumi} \\ \midrule
% \href{https://palletsprojects.com/projects/jinja/}{Jinja}          & A Python-friendly templating engine & Encodes the logic of toggling features \tabularnewline
% \href{https://pyscript.net/}{PyScript}       & A package that runs Python in a browser & Runs \texttt{Honegumi} package on ReadtheDocs \tabularnewline
% \href{https://hypothesis.readthedocs.io/en/latest/index.html}{Hypothesis}   & A scalable unit testing framework & Reduces combinatorial complexity \tabularnewline
% \bottomrule
% \end{tabularx}
% \end{table*}

% 1. \href{https://palletsprojects.com/projects/jinja/}{Jinja} - Python-friendly templating engine - used to encode the logic of toggling features
% 1. \href{https://pyscript.net/}{PyScript} - a platform for running Python in a browser using webassembly and MicroPython - used to run the Honegumi package within a static website
% 2. \href{https://docs.pytest.org/en/stable/}{Pytest} - unit testing framework - used to ensure that the code is runnable
% 3. \href{https://hypothesis.readthedocs.io/en/latest/index.html}{Hypothesis} - a scalable unit testing framework - used to intelligently run a subset of tests to address combinatorial scaling limitations
% 4. \href{https://about.readthedocs.com/}{ReadtheDocs} - a static web hosting service - used for hosting https://honegumi.readthedocs.io/
% 5. \href{https://github.com/features/actions}{GitHub Actions} - a continuous integration pipeline for GitHub repositories - used to run unit tests and release new package versions

\section{Conclusion}

Honegumi represents a new approach to increasing the accessibility of Bayesian optimization tools in experimental research. By combining an interactive interface with educational resources, it addresses both the technical and conceptual barriers that researchers often face when implementing BO in their work. The selection grid allows researchers to quickly generate working BO scripts while the accompanying tutorials provide the knowledge needed to modify these scripts appropriately for specific experimental contexts. This integration of practical tools with educational content helps researchers not only implement BO methods but also understand the principles behind their choices.

Looking forward, Honegumi's modular structure creates opportunities for expansion to other optimization platforms and experimental domains. The framework demonstrated here - using interactive interfaces to simplify complex computational tools while simultaneously teaching their proper use - may serve as a model for making other advanced computational methods more accessible to experimental researchers. As computational techniques become increasingly central to scientific discovery, tools that bridge the gap between theoretical capabilities and practical implementation will play an important role in accelerating research progress.


% \begin{itemize}
%     \item tool for the research community to accelerate the inclusion of more advanced tools for guiding experimental design
%     \item tool not only provides scripts, but teaches people how to use it such that they can interact with the underlying code base more easily going forward.
%     \item Modularity may allow other tools to adopt
%     \item example of how interfaces change how researchers can interact with complicated code bases and how such tools can be pedagogical with minimal effort.
% \end{itemize}


% \bibliographystyle{elsarticle-num-names}
\bibliographystyle{rsc}
\bibliography{references}

\end{document}
