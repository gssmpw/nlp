\section{Software Implementation} \label{subsec:implementation_sw}
The Arduino firmware was developed with C++ in platformIO. The firmware communicates with the hardware via USB using a serial breakout board and manages the low-level motion control, while the Dynamixel motors internally handle the hardware-level motor control.
In a first step, users configure the exoskeleton in the firmware with the \texttt{ExoskeletonBuilder}, which follows a builder pattern to add configured joints and define related hardware components and joint ranges, followed by a calibration step which determines the absolute zero-position for each actuated or sensing only joint. These configurations can be persisted in the Arduino's EEPROM for retrieval between microcontroller restarts.

In our event-based architecture, interactive behavior is modeled with \texttt{Condition} and \texttt{Action} classes. Conditions serve as runtime triggers that control the flow of actions, evaluating to true or false based on the exoskeletonâ€™s current state. This evaluation is checked in a control loop that runs at a fixed frequency. Actions encapsulate basic functions and augmentation strategies~(cf., Section~\ref{sec:concepts}). They can be combined sequentially or in parallel either for individual joints, a set of joints, or the arm for complex control flows. These are managed using \texttt{ActionBuilder}, which abstracts the sequentializion and parallelization of actions through another builder pattern, and provides an intuitive programming interface to the user.
Additionally, custom commands can be registered to trigger augmentation strategies from the outside through a serial console. The provided command-line interface, GUI, and Processing library build on this capability. 

The algorithms for implementing the functional abstraction are provided in the supplemental material. For the full implementation, please refer to the project's GitHub repository\footnote{\url{https://github.com/HCI-Lab-Saarland/ExoKit}}

\section{Hardware Implementation}\label{subsec:implementation_hw}
We designed the hardware components with Autodesk Fusion 360 and fabricated the 3D-printed parts with an Ultimaker S5 printer, using ABS filament. We recommend 100\% infill with an octet infill pattern for enhanced stability~\cite{pernet_2022} as well as a normal support structure and 2 mm wall thickness. The modular 3D-printed components are assembled with screws, nuts, and bearings, enabling easy adjustment.
The exoskeleton is held in place through a 3D-printed back rod, which is sewn onto a posture corrector. Two additional aluminium rods at the back further stabilize the system. 

\toolkit~contains only commercially available electronics. It supports the four motors of the Dynamixel XM series that we chose because of their balance between power and cost-efficiency. For sensing, we use Adafruit-based sensors, including load cells with HX711 ADC chips and a panel mount 10K potentiometer for angle tracking. The motors interface with the Dynamixel Shield for Arduino, while an Arduino Mega manages the communication with both the motors and sensors. A Sparkfun serial basic breakout~(CH340C) facilitates serial communication with the shield. The motors can be powered with 12 Volt using the Dynamixel power supplies or a portable power bank. %To ensure sufficient power when multiple motors are daisy-chained, additional SMPS2Dynamixel adapters can be inserted in the chain. 
For the portable power bank, we leveraged a Zeee Lipo Battery (3300mAh, 14.8V 50C) in a 4S1P configuration (348 grams, 131$\times$43.5$\times$29 mm. We connected the power supply to three voltage converters (12V, 5A, 60 grams) to power the Dynamixel shield and two SMPS2Dynamixel modules inserted into the daisy-chained motors to supply all 6 motors with power. Another voltage converter (5V, 3A, 50 grams) is used to power the Arduino. We put the converters into a box attached to the back of the posture corrector. This resulting setup is completely mobile (see minute 1:30 of the supplemental video).
