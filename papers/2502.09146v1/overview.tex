


\begin{figure}[t]
    \centering
    \subfigure[ERD metamodel]{
        \includegraphics[width=.44\textwidth]{figs/ERDMM.png} 
    }
    \subfigure[ERD instance]{
        %\includegraphics[width=0.50\linewidth]{figs/ERD_MODEL.png}
        \includegraphics[width=0.51\linewidth]{figs/image.png}
    }\\[5mm]
    \caption{Entity Relationship Diagram in \jjodel{}.}
    \label{fig:erd}
\end{figure}



To provide a comprehensive understanding of \jjodel{}’s capabilities, this section explores its architecture and core components. Section~\ref{sec:architecture} begins with an overview of the general structure of \jjodel{}, followed by an in-depth analysis of its front- and back-end services, the \jjodel{} Object Model (JjOM), the syntax and validation viewpoints, and the editing mechanisms. Together, these components illustrate how \jjodel{} enhances MDE workflows by offering flexibility, supporting unobtrusive co-evolution, enabling seamless collaboration, and ensuring robust and efficient functionality.

We illustrate these features using an example of an entity relationship diagram (ERD). In particular:


\begin{itemize}
    \item Figure~\ref{fig:erd}(a) illustrates the metamodel of an ERD, defined using classes and enumerations. An \code{Entity} contains \code{owned\-Attributes}, where each \code{Attribute} is characterized by a \texttt{type} and an \texttt{isPK}~attribute, indicating whether it is a primary key. A \texttt{Relation} connects two entities through the \texttt{left} and \texttt{right} references and is constrained by a \texttt{Cardinality} specification.
    
    \item Figure~\ref{fig:erd}(b) shows an example of an ERD model that conforms to the metamodel and is represented with a concrete syntax representing a diagrammatic notation. For example, the \texttt{User} entity includes attributes such as \texttt{id}, \texttt{surname}, and \texttt{firstname}, while the \texttt{Role} entity includes \texttt{id}, \texttt{name}, and \texttt{description}. These entities are connected by the \texttt{has} relationship, illustrating how the model adheres to the defined metamodel.
\end{itemize}

This example highlights the ability of \jjodel{} to handle both metamodel definitions and conforming models in an integrated environment, ensuring flexibility and precision in MDE workflows. We continue this section by presenting the architecture of \jjodel{}, detailing its core components and how they collectively support efficient MDE practices.  



%We illustrate those features by an entity relationship diagram (ERD) example. Figure \ref{fig:erd} shows a simple ERD metamodel and a very simple instance of an ERD defined in \jjodel{}. Figure~\ref{fig:erd}(a) shows the metamodel of ERD defined by classes and enumerations. An \texttt{ entity} contains owned \texttt{ attributes}, each of which has a \texttt{Type} and \texttt{isPK} attributes. A \texttt{Relation} connects two entities (via \texttt{left} and \texttt{right} references) and is constrained by a \texttt{Cardinality}.
%Figure~\ref{fig:erd}(b) shows an instance ERD model that conforms to the metamodel. For example, a \texttt{User} entity with attributes \texttt{id}, \texttt{surname}, and \texttt{firstname} is connected by a \texttt{has} relationship to a \texttt{Role} entity (with attributes \texttt{id}, \texttt{name}, and \texttt{description}). The 
%\begin{itemize}
%    \item \texttt{namedElement} abstract class provides a name attribute (of type EString). The other classes in the metamodel (i.e., Entity, Attribute, and Relation) all inherit from this base, ensuring each model element has a name.
%    \item \texttt{Entity} represents a conceptual “table” or domain object in an ERD. It owns multiple Attribute instances (via the ownedAttributes reference) and thus captures the typical structure of a data entity.
%    \item \texttt{Attribute} describes a field or column of an Entity. Each Attribute is typed by a separate enumeration, Type, which provides primitive data types (e.g., integer, string, boolean).
%    \item \texttt{Relation} models an association or relationship between two Entity classes (left and right). The Relation also carries a cardinality attribute wichi is type is an enumeration, Cardinality, describing whether the relationship is one-to-one (one2one), one-to-many (one2many), or many-to-many (many2many).
%\end{itemize}




\subsection{\jjodel{} Architecture}\label{sec:architecture}
\jjodel{} is a cloud-based reflective modeling platform that enhances MDE by minimizing accidental complexity and simplifying workflows. It offers robust capabilities, including metamodel and model definition, concrete syntax specification, and model validation using user-defined constraints. Moreover, with support for collaborative modeling in real-time, \jjodel{} enables multiple users to work simultaneously on shared projects, fostering teamwork and efficiency.

%The architecture of \jjodel{} integrates a carefully selected technology stack that supports real-time collaboration, efficient workflows, and robust back-end functionality. Using Docker\footnote{\url{https://docker.com/}}, \jjodel{} containerizes its components for scalable deployment across diverse infrastructures, ensuring consistency and seamless operation.  

The architecture of \jjodel{} is built on a carefully selected technology stack that not only supports real-time collaboration, efficient workflows, and robust back-end functionality, but also incorporates modern front-end technologies, ensuring an intuitive and responsive user interface. This stack enables enhanced expressiveness and flexibility, allowing even end-users to extend the tool’s functionalities. Using Docker\footnote{\url{https://docker.com/}}, \jjodel{} containerizes its components, ensuring scalable deployment across diverse infrastructures while maintaining consistency and seamless performance.

\begin{figure}
    \centering
\includegraphics[width=0.8\linewidth]{figs/architecture.pdf}
    \caption{Front-end architecture of \jjodel{}.}
    \label{fig:fe-architecture}
\end{figure}  

%The Front-End Service

%The \textit{front-end engine} is the main component for defining and managing MDE projects. It is implemented using TypeScript\footnote{\url{https://www.typescriptlang.org/}} for scalable and maintainable development, while React\footnote{\url{https://react.dev/}} powers its dynamic and interactive user interface. Users can seamlessly interact with metamodels, models, and concrete syntaxes through this interface.  
%
% The \textit{\jjodel{} Object Store} is managed by Redux\footnote{\url{https://redux.js.org/}}, which synchronizes the application states and manages key \jjodel{} objects, such as metamodels, models, and viewpoints. The front-end architecture employs a unidirectional data flow design pattern, ensuring predictable and efficient data management (Fig.~\ref{fig:fe-architecture}). 
%
% At the heart of the front-end service lies the \jjodel{} Object Store, a centralized repository implemented with Redux. It locally stores all essential artifacts, including metamodels, models, and viewpoints/views, and facilitates persistent state management. 
%

\medskip\noindent
The \textit{front-end} serves as the central component for defining and managing MDE projects. Built with TypeScript\footnote{\url{https://www.typescriptlang.org/}} to ensure scalability and maintainability, it leverages React\footnote{\url{https://react.dev/}} to power its dynamic and interactive user interface. It enables users to seamlessly interact with metamodels, models, and concrete syntaxes, creating an intuitive and powerful integrated environment.
%
The core of the front-end is the \textit{\jjodel{} Object Store}, a centralized repository implemented using Redux\footnote{\url{https://redux.js.org/}}. This layer manages all artifacts while synchronizing application states and ensuring persistent state management. By adopting a unidirectional data flow design pattern (Fig.~\ref{fig:fe-architecture}), the architecture guarantees a predictable, efficient, and robust data handling throughout the front-end.
%
More details on JjOM APIs for interacting with the \jjodel{} Object Store are provided in Section~\ref{sec:jom-api}, highlighting how developers can query, manipulate, and extend stored artifacts seamlessly.


The \textit{\jjodel{} Workbench/UI}, a core component of the front-end, serves as the primary interface for users. It offers editors for metamodels, models, and viewpoints, enabling users to define structural elements, ensure model conformance, and explore specific perspectives. A key feature of the platform is its built-in governance, made possible by its reflective architecture. This reflectiveness supports live metamodel/model coevolution~\cite{cicchetti2008automating}, allowing the tool to dynamically adapt editors and models in response to metamodel changes, ensuring seamless synchronization. This capability not only facilitates ongoing maintenance but also enables a test-driven development approach for metamodels~\cite{cicchetti2012test}.
%
In addition, the workbench integrates tools for managing DSL aspects, including model validation, interactive queries, and console functionalities, further improving the modeling experience and improving user productivity.

%The \textit{back-end services}  manage data persistence on the \jjodel{} repository and real-time collaboration. These services consist of two main components: The \jjodel{} Project Repository stores project data, including metamodels, models, concrete syntaxes, and user settings. It is built on Node.js\footnote{\url{https://nodejs.org/}} for server-side operations, Express.js\footnote{\url{https://expressjs.com/}} for routing and APIs, and MongoDB\footnote{\url{https://www.mongodb.com}} for data persistence.  
%The \jjodel{} Collaborative Service facilitates real-time collaboration by enabling simultaneous interaction among multiple users. It uses Socket.IO\footnote{\url{https://socket.io/}} to support real-time action and data exchange, while MongoDB provides persistent storage. Additionally, RESTful API endpoints allow room management and coordination during collaborative sessions. 
\medskip
\noindent
The \textit{back-end} manages data persistence within the \jjodel{} repository and enables collaborative modeling in real-time. It is made up of two primary components:
\begin{itemize}
    \item The \textit{\jjodel{} Project Repository}: it handles the storage of project data, including metamodels, models, concrete syntaxes and user settings. It is built on Node.js\footnote{\url{https://nodejs.org/}} for server-side operations, Express.js\footnote{\url{https://expressjs.com/}} for routing and APIs, and MongoDB\footnote{\url{https://www.mongodb.com}} for reliable and scalable data persistence.
	\item The \textit{\jjodel{} Collaborative Service}: designed to facilitate real-time collaboration, this service allows multiple users to interact simultaneously within the platform. It uses Socket.IO\footnote{\url{https://socket.io/}} for real-time communication and data synchronization, with MongoDB ensuring persistent storage of collaborative data. RESTful API endpoints further enhance functionality by managing rooms and coordinating activities during collaborative sessions.
\end{itemize}

Together, these services provide robust back-end support, enabling seamless collaboration and efficient data management, essential for powering the dynamic and interactive features of \jjodel{}.


\begin{comment}
\subsection{\jjodel{} User interface}\label{sec:user-interface}
%\jjodel{} provides a cohesive environment for secure access, project management, and model creation. The sign-in, registration, profile, and password recovery pages allow the user to establish or manage their credentials and user profile. Once logged in, users are directed to the dashboard (see Figure~\ref{fig:dashboard}), which consolidates essential operations, including creating or importing new projects and filtering and sorting existing projects. Opening a new project presents an overview screen that displays metamodels, models, and viewpoints and relevant metadata, with intuitive controls for downloading, favoriting, or closing the project. The metamodel editor (see Figure~\ref{fig:erd}(b) allows users to design structured blueprints through a central canvas for hierarchical class relationships, a properties panel for inspecting or editing details, and a feature panel to add elements. 

%% 
\jjodel{} offers a cohesive and user-friendly environment for secure access, project management, and model creation. The platform provides pages for sign-in, registration, profile management, and password recovery, allowing users to establish and maintain their credentials with ease. Once authenticated, users are directed to the dashboard (see Figure~\ref{fig:dashboard}), which centralizes key operations such as creating or importing new projects, as well as filtering and sorting existing ones for efficient navigation.
%
When a project is opened, an overview screen presents a comprehensive view of its metamodels, models, viewpoints, and associated metadata. This screen also includes intuitive controls for downloading, favoriting, or closing projects, ensuring seamless project management.

%For designing metamodels, the metamodel editor (see Figure~\ref{fig:erd}(b)) provides a robust interface that features a central canvas to create hierarchical class relationships, a properties panel to inspect and edit the details of the elements, and a feature panel to add new components. 

The metamodel editor (see Figure~\ref{fig:erd}(a)) offers a robust interface for designing metamodels, featuring a central canvas for creating hierarchical class relationships, a properties panel for inspecting and editing element details, and a feature panel for adding new components seamlessly.

Users can edit the abstract syntax using the \jjodel{} Default Syntax (JjDS), a diagrammatic notation inspired by UML class and object diagrams that adheres to the EMF Ecore~\cite{steinberg2008emf} standard. This approach combines user familiarity with the flexibility required for precise and efficient metamodel definitions.

Additionally, the user interface is designed to support real-time collaboration, allowing multiple users to work concurrently on shared projects, with changes instantly reflected across all sessions. Together, these features create an environment that prioritizes accessibility, efficiency, and collaboration for a wide range of modeling tasks.
%%
%
Both the metamodel and its instantiated models can be explored through the corresponding \textit{Tree-View panel}, where classes, attributes, references, and other model elements are hierarchically organized to emphasize their structural and relational aspects. The \textit{Viewpoints panel} complements this by offering customized visualizations and validations tailored to specific viewpoints, allowing users to flexibly analyze and refine their models within the \jjodel{} environment.

\begin{figure}
    \centering
    \includegraphics[width=\linewidth]{figs/dashboard.png}
    \caption{\jjodel{} dashboard.}
    \label{fig:dashboard}
\end{figure}
\end{comment}

\subsection{\jjodel{} Object Model (JjOM)}\label{sec:jom-api}
%\jjodel{} Object Model (JjOM) is a conceptual framework for managing all elements within the \jjodel{} Object Store. The JjOM framework is used to query the model, evaluate the model, define concrete syntaxes, and test/debug the model within a dedicated console, ensuring a systematic methodology for model development and refinement. 
%
The \jjodel{} Object Model (JjOM) defines how modeling artifacts are represented and accessed within the \textit{\jjodel{} Object Store}. It provides a structured way of interaction with model elements through its API, enabling users to query, evaluate, and manipulate models. JjOM also facilitates the definition of concrete syntaxes and provides a dedicated console for testing and debugging, offering a comprehensive framework for model development and refinement.

%

It organizes modeling artifacts through three interconnected submodels, each serving a specific purpose in managing and presenting modeling artifacts: 
\begin{itemize}

    \item \textit{Data Submodel} (\code{data}): this submodel is closely tied to the foundational elements of modeling, such as classes, attributes, relationships, constraints, and their corresponding instances. These elements form the core building blocks of the \jjodel{} meta-metamodel, as outlined in Table~\ref{tab:core-modeling}, which includes key constructs such as \code{DModel}, \code{DClass}, \code{DAttribute}, \code{DReference}, \code{DObject}, and \code{DValue}. Together, these constructs establish the structural and semantic framework necessary for defining and managing both metamodels and their conforming models.


    \item \textit{Node Submodel}  (\code{node}): responsible for managing layout information, this submodel determines the spatial organization and connectivity of elements within the modeling environment. It also serves as a flexible space for storing additional information used in operations. For example, the validation mechanism uses the state of the node to store and manage validation messages. Because \code{node} is interconnected with the other submodels, it enables the definition of viewpoints and semantic aspects that may depend on the layout information, both to represent and specifying the characteristics of the specific characteristics of the model. For an example, refer to Figure~\ref{fig:expressions};
    
    \item \textit{View Submodel}  (\code{view}): focused on representing the concrete syntax and visual details of model elements, the view submodel synchronizes data and node elements, ensuring consistency between the abstract structure and its visual representation.
\end{itemize}
\begin{table}[h]
    \centering
        \caption{Core Modeling Constructs.}
    \label{tab:core-modeling}
    \begin{tabular}{|l|p{9.5cm}|}
    \hline
        \textbf{Construct} & \textbf{Description} \\ \hline
         \texttt{DModel} & serves as the top-level container holding Packages or Classes. DModel acts as the root of model specification.
  \\ \hline
        \texttt{DPackage} & is a logical grouping or namespace for related classes. \\ \hline
        \texttt{DClass} & represents a class in the metamodel. It can extend from another class and declares, attributes, and references. \\ \hline
        \texttt{DAttribute} & represents a field or characteristic that holds an intrinsic value that can be typed as a primitive type, \ie{} integer, string, boolean, etc., or custom-defined enumeration),\\ \hline
        \texttt{DReference} & specifies a relationship between classes and may include cardinality constraints (e.g., one-to-one, one-to-many). DReferences can be containment or non-containment relationships. \\ \hline
        \texttt{DObject} & is an instance of a DClass. It stores runtime values for each DAttribute and links pointing to other objects.\\ \hline
        \texttt{DValue} & is the concrete value assigned to an attribute or data field. Each DObject’s DAttribute has one or more DValues, that can be a scalar (e.g., string, integer, boolean) or an enumeration literal. \\ \hline
    \end{tabular}
\end{table}


These submodels collectively enable JjOM to provide a comprehensive structure to interact with, visualize, and manage modeling artifacts, ensuring precision, expressiveness, and flexibility. In particular, \code{data}, \code{node}, and \code{view} encapsulate all the information specified by the meta-metamodel and provide programmatic access to these elements through attributes and functions exposed by the JjOM API, summarized in Table~\ref{tab:jjom-api}. This interface allows developers to query, manipulate, and validate modeling artifacts. For example, developers can use the API to retrieve all attributes associated with a specific \code{DClass}, add or remove relationships between \code{DObjects}, or validate constraints defined within a metamodel. 
%
%
%
%
% {\begin{table}[h!]
% \centering
% \caption{Attributes and Functions of the JjOM API}
% \label{tab:jjom-api}
% \begin{tabular}{|p{0.25\linewidth}|l|p{0.6\linewidth}|}
% \hline
% \textbf{Name} & \textbf{Scope} & \textbf{Description} \\ \hline
% \multicolumn{3}{|c|}{\textbf{Attributes}} \\ \hline
% \code{allInstances} & & An array of all instances of \code{DObject}. \\ \hline
% \code{attributes} && Represents attributes of type \code{<DAttribute>}. \\ \hline
% \code{className} & &Stores the class name as a \code{String}. \\ \hline
% \code{id} & &Unique identifier represented as a \code{Pointer}. \\ \hline
% \code{extendedBy} & &Array of \code{DClass} objects extending this class. \\ \hline
% \code{extends} & &Array of \code{DClass} objects this class extends. \\ \hline
% \code{features} & &Represents features of type \code{<Feature>}. \\ \hline
% %\code{final} & Indicates if the class is final (\code{Boolean}, deprecated). \\ \hline
% \code{instanceOf} & &References the class this object is an instance of (\code{DClass}). \\ \hline
% \code{instances} & &Array of instances of \code{DObject}. \\ \hline
% \code{isAbstract} & &Specifies whether the class is abstract (\code{Boolean}). \\ \hline
% \code{isFinal} & &Indicates whether the class is final (\code{Boolean}). \\ \hline
% \code{isInterface} & &Indicates whether the class is an interface (\code{Boolean}). \\ \hline
% \code{isPrimitive} & &Indicates whether the type is primitive (\code{Boolean}). \\ \hline
% \code{isMetamodel} & &Specifies if it is part of a metamodel (\code{Boolean}). \\ \hline
% \code{isRootable} & &Specifies if the class can be a root element (\code{Boolean}). \\ \hline
% \code{isSingleton} & &Indicates whether the class is a singleton (\code{Boolean}). \\ \hline
% \code{name} & & Represents the name of the element (\code{String}). \\ \hline
% \code{objects} & &Array of objects of type \code{DObject}. \\ \hline
% \code{operations} & &Defines operations of type \code{<DOperation>}. \\ \hline
% \code{packages} & &Array of \code{DPackage} elements associated with this class. \\ \hline
% \code{parent} & &Points to the parent object (can be of any type). \\ \hline
% \code{references} &  & Defines references of type \code{<DReference>}. \\ \hline
%
% \multicolumn{3}{|c|}{\textbf{Functions}} \\ \hline
% \code{getElementById (id:Pointer)} &
% & Retrieves an element by its unique identifier. \\ \hline
% \code{getAttributes (entity:DClass)} & Returns attributes associated with the given entity. \\ \hline
% \code{addAttribute (entity:DClass, attribute:DAttribute)} & Adds a new attribute to the specified entity. \\ \hline
% \code{removeAttribute (entity:DClass, attribute:DAttribute)} & Removes an existing attribute from the specified entity. \\ \hline
% \code{getRelationships (entity:DClass)} & Retrieves all relationships connected to the given entity. \\ \hline
% \code{addRelationship (entity1:DClass, entity2:DClass, type:RelationType)} & Creates a relationship between two entities of the specified type. \\ \hline
% \code{removeRelationship (relationship:DAssociation)} & Deletes the specified relationship. \\ \hline
% \code{validateModel()} & Validates the model against constraints and returns validation errors. \\ \hline
% \code{getNodeLayout (node: ??)} & Retrieves layout information (e.g., position or dimensions) for a node. \\ \hline
% \code{setNodeLayout (node: ??, layout: ??)} & Updates the layout information of a node. \\ \hline
% \code{executeQuery (query: ??)} & Executes a custom query and returns matching elements. \\ \hline
% \end{tabular}\label{tab:api}
% \end{table}}
%
% \begin{table}[h!]
% \centering\scriptsize
% \caption{Attributes and Functions of the JjOM API}
% \label{tab:jjom-api}
% \begin{tabular}{|p{0.265\linewidth}|p{0.07\linewidth}|p{0.57\linewidth}|}
% \hline
% \textbf{Name} & \textbf{Scope} & \textbf{Description} \\ \hline
% \multicolumn{3}{|c|}{\textbf{Attributes}} \\ \hline
% \code{allInstances} & \code{DModel} & Array of all instances (\code{DObject}). \\ \hline
% \code{attributes} & \code{DClass} & Array of all attributes (\code{DAttribute}) of a \code{DClass} instance.\\\hline
% \code{className} & \code{DObject} & The class name (\code{String}). \\ \hline
% \code{extendedBy} & \code{DClass} & Array of \code{DClass} objects extending this class. \\ \hline
% \code{extends} & \code{DClass} & Array of \code{DClass} objects this class extends. \\ \hline
% \code{features} & \code{DClass} & Represents features of type \code{<Feature>}. \\ \hline
% \texttt{id} & \texttt{DObject}, \texttt{DClass} & Unique identifier represented as a \code{Pointer} \\ \hline 
% \code{instanceOf} & \code{DObject} & References the class this object is an instance of (\code{DClass}). \\ \hline
% \code{instances} & \code{DClass} & Array of instances of \code{DObject}. \\ \hline
% \code{isAbstract} & \code{DClass} & Specifies whether the class is abstract (\code{Boolean}). \\ \hline
% \code{isFinal} & \code{DClass} & Indicates whether the class is final (\code{Boolean}). \\ \hline
% \code{isInterface} & \code{DClass} & Indicates whether the class is an interface (\code{Boolean}). \\ \hline
% \code{isPrimitive} & \code{DClass} & Indicates whether the type is primitive (\code{Boolean}). \\ \hline
% \code{isMetamodel} & \code{DModel} & Specifies if it is part of a metamodel (\code{Boolean}). \\ \hline
% \code{isRootable} & \code{DClass} & Specifies if the class can be a root element (\code{Boolean}). \\ \hline
% \code{isSingleton} & \code{DClass} & Indicates whether the class is a singleton (\code{Boolean}). \\ \hline
% \code{name} & Global & Represents the name of the element (\code{String}). \\ \hline
% \code{objects} & Global & Array of objects of type \code{DObject}. \\ \hline
% \code{operations} & \code{DClass} & Defines operations of type \code{<DOperation>}. \\ \hline
% \code{packages} & \code{DModel} & Array of \code{DPackage} elements associated with this class. \\ \hline
% \code{parent} & \code{DObject} & Points to the parent object (can be of any type). \\ \hline
% \code{references} & \code{DClass} & Defines references of type \code{<DReference>}. \\ \hline
% \texttt{value}  & \texttt{DValue} & (single-valued) value is the actual for attributes or references. It is applicable on attributes and references having a upper-bound equals to 1. \\ \hline
%         \texttt{values} & \texttt{DValue}  & (multi-valued) values is an array of data.  \\ \hline
%         \texttt{\$<name> (dynamic property)} & \texttt{DClass} \texttt{DModel}& dynamically accesses child elements or instances by exact name.\\ \hline
% \multicolumn{3}{|c|}{\textbf{Functions}} \\ \hline
% \code{getElementById (id:Pointer)} & \code{DObject} & Retrieves an element by its unique identifier. \\ \hline
% \code{getAttributes (entity:DClass)} & \code{DClass} & Returns attributes associated with the given entity. \\ \hline
% \code{addAttribute (entity:DClass, attribute:DAttribute)} & \code{DClass} & Adds a new attribute to the specified entity. \\ \hline
% \code{removeAttribute (entity:DClass, attribute:DAttribute)} & \code{DClass} & Removes an existing attribute from the specified entity. \\ \hline
% \code{getRelationships (entity:DClass)} & \code{DClass} & Retrieves all relationships connected to the given entity. \\ \hline
% \code{addRelationship (entity1:DClass, entity2:DClass, type:RelationType)} & \code{DClass} & Creates a relationship between two entities of the specified type. \\ \hline
% \code{removeRelationship (relationship:DAssociation)} & \code{DClass} & Deletes the specified relationship. \\ \hline
% \code{validateModel()} & \code{DModel} & Validates the model against constraints and returns validation errors. \\ \hline
% \code{getNodeLayout (node: ??)} & Layout-level & Retrieves layout information (e.g., position or dimensions) for a node. \\ \hline
% \code{setNodeLayout (node: ??, layout: ??)} & Layout-level & Updates the layout information of a node. \\ \hline
% \code{executeQuery (query: ??)} & Global & Executes a custom query and returns matching elements. \\ \hline
% \texttt{delete()} & \texttt{DClass} \texttt{DObject} \texttt{DValue} & removes the current element from the model. This operation also cleans up references or links to ensure the model remains consistent.\\ \hline
% \texttt{addClass (name : String)} & \texttt{DModel} & add a \texttt{DClass} with a given name to a \texttt{DPackage} or \texttt{DModel} \\ \hline
%         \texttt{addObject (param : JSON, className : String)} & \texttt{DModel} & creates an instance of a \texttt{DClass} that matches with \texttt{className} and initializes the attribute values as described in the JSON \texttt{param} \\ \hline
% \end{tabular}
% \end{table}

\newcommand{\tab}{\par\ \ \ }
\newcommand{\nl}{\par}
\begin{table}[p]
\centering\scriptsize
\caption{Attributes and Functions of the JjOM API.}
\label{tab:jjom-api}
\begin{tabular}{|@{\hskip 1mm}p{0.32 \linewidth}|p{0.07\linewidth}|>{\raggedright\arraybackslash}p{0.60\linewidth}|}
\hline
\textbf{Name} & \textbf{Scope} & \textbf{Description} \\ \hline
\multicolumn{3}{|c|}{\textbf{Attributes}} \\ \hline
\code{allInstances: DObject[]} & \code{DModel} & array containing all instances of type \code{DObject} \\ \hline
\code{attributes: DAttribute[]} & \code{DClass} & array of \code{DAttribute}s associated with a \code{DClass} \\ \hline
\code{className: String} & \code{DObject} & the name of the class represented as a \code{String} \\ \hline
\code{extendedBy: DClass[]} & \code{DClass} & array of \code{DClass} that extend this class \\ \hline
\code{extends: DClass[]} & \code{DClass} & array of \code{DClass} objects that this class extends \\ \hline
\code{id: Pointer} & \code{Any} & unique identifier represented as a \code{Pointer} \\ \hline
\code{instanceOf: DClass} & \code{DObject} & reference to the \code{DClass} this object is an instance of \\ \hline
\code{instances: DObject[]} & \code{DClass} & array containing all instances of this \code{DClass} \\ \hline
\code{isAbstract: Boolean} & \code{DClass} & boolean indicating whether the class is abstract \\ \hline
\code{isFinal: Boolean} & \code{DClass} & boolean indicating whether the class is final \\ \hline
\code{isInterface: Boolean} & \code{DClass} & boolean indicating whether the class is an interface \\ \hline
\code{isMetamodel: Boolean} & \code{DModel} & boolean specifying if the model belongs to a metamodel \\ \hline
\code{isPrimitive: Boolean} & \code{DClass} & boolean specifying whether the type is primitive \\ \hline
\code{isRootable: Boolean} & \code{DClass} & boolean specifying whether the class can be a root element \\ \hline
\code{isSingleton: Boolean} & \code{DClass} & boolean indicating whether the class is a singleton \\ \hline
\code{name: String} & Global & the name of the element represented as a \code{String} \\ \hline
\code{objects: DObject[]} & Global & array containing all \code{DObject} instances in the model \\ \hline
\code{operations: DOperation[]} & \code{DClass} & array of operations (\code{DOperation}) defined for the class \\ \hline
\code{packages: DPackage[]} & \code{DModel} & array of \code{DPackage} elements associated with the model \\ \hline
\code{parent: DObject} & \code{DObject} & reference to the parent object, which can be of any type \\ \hline
\code{references: DReference[]} & \code{DClass} & array of references (\code{DReference}) defined for the class \\ \hline
\code{value: DValue} & \code{DValue} & single-valued data for attributes or references with an upper bound of 1 \\ \hline
\code{values: DValue[]} & \code{DValue} & array of multi-valued data for attributes or references \\ \hline
\code{\$<name>: DValue} & \code{DClass}, \code{DModel} & dynamically accesses child elements or instances by exact name \\ \hline
\multicolumn{3}{|c|}{\textbf{Functions}} \\ \hline
\code{addAttribute(}\tab\code{attribute: DAttribute}\nl\code{): DClass} & \code{DClass} & adds an attribute (\code{DAttribute}) to the specified \code{DClass} \\ \hline
\code{addClass(\tab name: String\nl ): DPackage|DModel} & \code{DModel, DPackage} & adds a \code{DClass} with the specified name to a \code{DPackage} or \code{DModel} \\ \hline
\code{addObject(\tab param: JSON,\tab className: String\nl ): DModel} & \code{DModel} & creates an instance of the specified \code{DClass} and initializes it with values from the JSON \code{param} \\ \hline %\code{addObject(}\tab\code{param: JSON,}\tab\code{className: String}\nl\code{): DModel} 
\code{addRelationship(\tab type:DRelationType\nl ): DClass} & \code{DClass} & creates a relationship of the specified type between two \code{DClass} entities \\ \hline %\code{addRelationship (}\tab\code{entity:DClass,}\tab\code{type:RelationType}\nl\code{): DClass}
\code{delete (): void} & %\code{DClass}, \code{DObject}, \code{DValue} 
\code{Any}& deletes the current element and cleans up associated references or links to maintain model consistency \\ \hline
\code{executeQuery (\tab query: JSX~Expression\nl ): Any[]} & Global & executes a custom query and returns the matching elements \\ \hline
\code{getAttributes (): DAttribute[]} & \code{DClass} & retrieves the attributes associated with the specified \code{DClass}. \\ \hline
\code{getElementById(id:Pointer}\code{): Any} & \code{DObject} & retrieves an element by its unique identifier \\ \hline
%\code{getNodeLayout (): DViewElement} & \code{DVertex} & retrieves the layout information (e.g., position or dimensions) of the specified node \\ \hline
\code{getRelationships():\tab DReference[]} & \code{DClass} & retrieves all relationships connected to the specified \code{DClass} \\ \hline
\code{removeAttribute(\tab attr: DAttribute\nl ): DClass} & \code{DClass} & removes the specified attribute from the given \code{DClass} \\ \hline %\code{removeAttribute (}\tab\code{attribute:DAttribute}\nl\code{): DClass}
\code{removeRelationship (\tab ref: DRereference\nl ): DClass} & \code{DClass} & deletes the specified relationship from the model \\ \hline %code{removeRelationship (}\tab\code{rel: DAssociation}\nl\code{): DClass}
%\code{setNodeLayout (node: ??, layout: ??)} & Layout-level & updates the layout information of the specified node \\ \hline
\code{validateModel(): Error} & \code{DModel} & validates the model against constraints and returns any validation errors \\ \hline
\end{tabular}
\end{table}
%
%These submodels are accessible through dedicated APIs, which allow users to navigate, modify, and interact with modeling artifacts dynamically. The APIs also support advanced functionality, such as constraint validation, model transformations, and custom navigational expressions.  
%
% 
% All primary components of the JjOM are accessible through a dedicated API, which provides a programmatic interface to navigate and interact with the JjOM structure. The JjOM API offers methods for retrieving and manipulating objects representing model elements, their layout configurations, and their syntactic representations. Through this API, users can explore, modify, and integrate model data, supporting tasks such as constraint validation, model transformations, and dynamic updates.
 %
%
% The API is also central to enabling JSX expressions for advanced interactions, particularly in defining navigation paths and constraints within the \jjodel{} environment. By allowing users to define customized constraints and navigational expressions, the API supports flexible model querying and enables a dynamic, interactive modeling experience.
%
%
In essence, the API offers methods for retrieving and manipulating model elements, their layout configurations, and their syntactic representations. 
%
The API plays a central role in enabling JSX\footnote{\url{https://legacy.reactjs.org/docs/introducing-jsx.html}} expressions, which are particularly useful for defining navigation paths and constraints within the \jjodel{} environment. By allowing users to define customized constraints and navigational logic, the API facilitates flexible model querying to be used within JSX templates. This versatility not only enhances the usability of the platform, but also allows users to tailor their interactions to specific modeling needs and scenarios. 

\medskip
Figure~\ref{fig:jjom} shows three expressions of the JSX exemplar that interact with the submodels \code{data}, \code{node} and \code{view} (highlighted blue, red, and green, respectively), demonstrated within the context of the ERD scenario. The figure illustrates the interactive console of \jjodel{}, which facilitates dynamic exploration and manipulation of these submodels.
%
\begin{comment}
\begin{lstlisting}[language=jsx,caption=Interacting with JjOM.,label=lst:jjom]
 data.$ownedAttributes.values.map(attr => attr.name) // => [ 'id', 'surname', 'firstname' ]
 `${node.x} * ${node.y} = ${node.x * node.y}` // => 495 * 120 = 59400
 view.oclCondition // => context DObject inv: self.instanceof.name = 'Entity'
\end{lstlisting}
\end{comment}
\begin{figure}
    \centering
    \includegraphics[width=0.8\linewidth]{figs/jom.png}
    \caption{Interacting with JjOM.}
    \label{fig:jjom}
\end{figure}
%
Each interaction with the console is applied to the selected model element in the editor. In the following, we describe simple statements that interact with each submodel on the \texttt{User} entity:

\begin{itemize}
    \item The expression in console \circled{1} queries \code{data} to retrieve the attributes owned by the \code{User} entity and maps them to their \texttt{name} properties, demonstrating how declarative JSX expressions can extract and manipulate core data elements. In particular, the special character \code{\$} facilitates navigation through the model elements, allowing access to the child elements or instances by their exact name. For example, when an entity instance is selected in the editor, the expression \code{data.\$ownedAttributes} retrieves all the attributes it contains. Essentially, \code{data} functions as the equivalent of \texttt{self} in the OCL language~\cite{Cabot2012}, serving as a contextual reference point for querying and navigating the model elements.
    \item The expression \circled{2} interacts with \code{node}, which manages spatial layout and positioning. The properties \code{node.x} and \code{node.y} represent the coordinates (or other numeric attributes) of a node, corresponding to the visual representation of a model element. The expression multiplies these values, demonstrating the dynamic retrieval and manipulation of layout-related data at run-time.
    \item  The expression \circled{3} references \code{view}, which govern the concrete syntax and visual constraints of the model elements. The \code{oclCondition} enforces that any \code{DObject} in this view must be an instance of \code{Entity}. This shows how OCL-like constraints can be applied to validate or control visual representations on the model front-end. These constraints integrate seamlessly into JavaScript or JSX workflows, enabling UI-level validations and custom conditional rendering.
\end{itemize}
These examples illustrate the expressiveness and versatility of the JjOM API\footnote{A reference guide for the JjOM API is available online (\url{https://www.jjodel.io/jjodel-object-model-jjom/}).} to support advanced modeling scenarios, enabling developers to tightly integrate model data with dynamic and interactive front-end environments.

To further enhance the general usability, a set of predefined facilities has been introduced, facilitating common tasks and reducing the effort required for developers to interact with the JjOM. These facilities provide high-level abstractions and helper functions that simplify complex operations, such as querying model elements, managing layout configurations, and enforcing visual or semantic constraints. Table~\ref{tab:jjom-api} presents a subset of these predefined facilities, showcasing their role in accelerating development workflows and enabling intuitive interactions with \code{data}, \code{node}, and \code{view}. 

In particular, the adopted approach leverages React JSX, a notation widely covered in undergraduate courses, ensuring that many students and professionals are already familiar with its syntax and principles. This familiarity significantly reduces the learning curve, allowing users to quickly adapt and focus on using the features of the framework. Together, these facilities improve efficiency, accessibility, and user experience, helping to make the framework more transparent and as such suitable for a broad audience, from novice developers to seasoned professionals.


\begin{comment}
    

\begin{table}[]
    \centering
      \caption{JjOM facilities. (\textbf{da rimuovere?})}
    \label{tab:jjom-api-old}
    \begin{tabular}{|p{2.5cm}|p{1.2cm}|p{7cm}|}
    \hline
        \textbf{JjOM API} & \textbf{Scope} & \textbf{Description}  \\ \hline
        \texttt{id} & \texttt{DObject} \texttt{DClass} & allows access to the unique identifier for the model element, formatted as a pointer. \\ \hline 
        \texttt{allInstances} & \texttt{DClass} & returns all the instances of a given \texttt{DClass} including the instances of its subclasses.\\ \hline
        \texttt{attributes} or \texttt{references} & \texttt{DClass} & returns the collection containing all attributes or references of a \texttt{DClass}.\\ \hline
        \texttt{instanceOf} & \texttt{DObject} & returns a pointer to \texttt{DClass} type of a \texttt{DOject}. \\ \hline
        \texttt{addClass (name : String)} & \texttt{DModel} & add a \texttt{DClass} with a given name to a \texttt{DPackage} or \texttt{DModel} \\ \hline
        \texttt{addObject (param : JSON, className : String)} & \texttt{DModel} & creates an instance of a \texttt{DClass} that matches with \texttt{className} and initializes the attribute values as described in the JSON \texttt{param} \\ \hline
        \texttt{parent} & \texttt{Any} & returns the immediate container.\\ \hline
        \texttt{delete} & \texttt{DClass} \texttt{DObject} \texttt{DValue} & removes the current element from the model. This operation also cleans up references or links to ensure the model remains consistent.\\ \hline
        \texttt{value}  & \texttt{DValue} & (single-valued) value is the actual for attributes or references. It is applicable on attributes and references having a upper-bound equals to 1. \\ \hline
        \texttt{values} & \texttt{DValue}  & (multi-valued) values is an array of data.  \\ \hline
        \texttt{\$<name> (dynamic property)} & \texttt{DClass} \texttt{DModel}& dynamically accesses child elements or instances by exact name.\\ \hline
        
        
    \end{tabular}
  
\end{table}
\end{comment}



%You can seamlessly integrate this logic into a JavaScript or JSX environment to dynamically render node positions in your application.



\subsection{Syntax Viewpoints}
Syntax viewpoints in \jjodel{} define the concrete syntax of models, specifying how instances of abstract metamodel concepts are visually represented and interacted with. Each viewpoint consists of a collection of \textit{views} that define the mapping between abstract elements and their corresponding concrete representations. This bidirectional mapping ensures not only the visualization of abstract elements, but also, in the case of projectional editing, enables users to directly interact with the concrete representation to modify the underlying abstract model. These views are specified as graphical rules, each tailored to handle a specific class or element type. Each view consists of multiple aspects, enabling precise and intuitive model manipulation by addressing different facets of the visual representation and interaction. In particular,

\begin{itemize}
    \item \textit{ApplyTo}, specifies the predicate used to select the instances to which the view applies; the predicate can be defined using OCL or JavaScript.  
    \item \textit{Template}, defines a JSX template used to specify a component that visually represents each instance that satisfies the predicate defined in the \textit{ApplyTo} configuration. Templates access and manipulate model data using the JjOM API, i.e., declarative and functional JSX expressions, enabling dynamic and flexible visualizations. Additionally, a template can leverage predefined components provided by the \jjodel{} Syntax Definition (JjSD) library, which are designed to facilitate the creation of graphical syntaxes. An excerpt of these JSX components, along with their specific purposes, is listed in Table~\ref{tab:jdl-component}, offering modelers a robust foundation to define intuitive and expressive syntax representations.
    \item \textit{Style}, defines customizable parameters to tailor the visual appearance of graphical components, leveraging CSS/LESS stylings. Language engineers can specify styling variables, such as colors, border properties, and thickness, to ensure consistent and adaptable designs. As shown in Figure~\ref{fig:style-editor}, these parameters are configured through an intuitive interface that provides options to select color palettes, adjust numerical values (e.g. thickness), and define paths for shapes. This flexibility allows modelers to create visually cohesive and customizable syntaxes tailored to their specific requirements.
    \begin{figure}[ht]
    \centering
    \includegraphics[width=0.8\linewidth]{figs/styleparameters.png} % Replace with your actual image path
    \caption{Example user-defined parameters like color, thickness, and SVG paths for customizing the styling.}
    \label{fig:style-editor}
    \end{figure} 
    \item \textit{Events}, each view allows the modeler to define event handlers as part of Event-Condition-Action (ECA) rules, enabling the capture of user interactions such as dragging, resizing, and other actions. These events enhance interaction, allowing modelers to customize and extend the editor’s behavior while dynamically manipulating the model. Furthermore, events can be used to define the semantics of the modeling notation, linking user actions to meaningful model transformations or updates. A complete list of available event handlers is shown in Table~\ref{tab:trigger}.
    \item \textit{Options}, enables fine-tuning and advanced customizations, allowing modelers to define how elements are structured and aggregated. For example, elements can be configured to appear as a list within containers or as vertices in a graph. These options provide flexibility in organizing and presenting model components, ensuring that the visual representation aligns with the desired semantics and structure of the model.
\end{itemize}  


\begin{table}[]
    \footnotesize
    \centering
    \caption{\jjodel{} JSX Reusable Components.}
    \label{tab:jdl-component}
    \begin{tabular}{|l|p{8.5cm}|}
         \hline
\textbf{JjDL Component} & \textbf{Description} \\ \hline
\code{<Control/>} & Adds a control panel to parameterize the syntax rendering. \\ \hline
\code{<DefaultNode/>} & Corresponds to the view definition of an instance specified as an argument. \\ \hline
\code{<Edge/>} & Corresponds to an edge among two nodes. \\ \hline
\code{<Input/>} & Permits the projectional editing of an attribute. \\ \hline
\code{<Selector/>} & Permits the projectional editing among a set of elements. \\ \hline
\code{<Slider/>} & Adds a range slider to define the value of an integer parameter. \\ \hline
\code{<Toggle/>} & Adds a toggle for a boolean parameter. \\ \hline
\code{<View/>} & It is the opening/closing tag for views. \\ \hline
    \end{tabular}
\end{table}



Using the ERD scenario, the listings~\ref{lst:entity-template}, \ref{lst:attribute-template}, and \ref{lst:relation-template} illustrate how the templates for entities, attributes, and relations are specified within the example ERD context. Each component plays a distinct role in rendering and editing model elements in a 'projectional' style, ensuring a dynamic and customizable user experience.
%
The component \code{View} serves as the root or container for a particular visualization, encapsulating the layout of all templates, such as entity, attribute, and relation templates. Within this structure, the \code{} component, a key element of the \jjodel{} Syntax Definition (JjSD) library, plays a pivotal role in rendering sub-elements (often instances). It is a generic and polymorphic component that ensures that subelements are consistently represented, even if no custom view is explicitly defined for them.
%
In the entity template, attributes are iterated using the \texttt{ ownedAttributes} property of the entity, and each attribute is rendered using \code{}. This component inductively identifies the appropriate view to apply by performing a run-time lookup based on the value of the instance that satisfies the view predicates. Since the correct view cannot always be determined statically, this dynamic mechanism allows \code{} to flexibly adapt to different scenarios and contexts. It acts as a bridge, linking to a corresponding model template or providing a minimal default rendering when no custom view is specified.
%
For the ERD scenario, the \code{} component for attributes is explicitly bonded to the \texttt{Attribute} template. This ensures a seamless and consistent rendering of attributes within the entity visualization while leveraging the generic and polymorphic capabilities of the component to dynamically identify and apply the appropriate view.

All three templates utilize the \code{Input} component to enable projectional (in place) editing of a single attribute value, such as a name or a type. In the \code{Entity} template, \code{Input} is bound to \code{data.\$name}, representing the entity’s name. The property \code{field={‘value’}} specifies that it edits a single textual value. The component \code{Input} also supports additional properties; for example, the property \code{autosize} allows the text box to dynamically resize to fit its content, improving usability and visual clarity.
%
The \texttt{Attribute} template extends this functionality with the inclusion of the \texttt{Selector} component, which provides a dropdown list to select an enumeration literal, such as the \texttt{type} of an attribute. This enables intuitive interaction and simplifies the selection process for users.
%
The \texttt{Edge} component plays a critical role in representing connections between nodes in a graphical notation, such as relationships between entities in a diagram. In the ERD example, the \texttt{Relation} template defines two edge elements to visually represent how the \texttt{Relation} node connects to its associated left and right entities. Specifically, the first edge of the \texttt{Relation} node acts as the 'start', while the reference entity node serves as the 'end'. This means that the edge is drawn from the visual element of the relation to the entity it refers to. By specifying which nodes to connect, the modeler can draw edges between multiple nodes in the model (e.g., from a \texttt{User} entity to a \texttt{Role} entity), enabling clear and expressive visualizations of relationships.
\begin{lstlisting}[language=JSX-template,caption=ERD Entity template.,label=lst:entity-template]
<View className={'entity'}>
    <div className={'entity-header'}>
        <div className={'input-container mx-2'}>
            <Input
                data={data.$name}
                field={'value'}
                hidden={true}
                autosize={true}
                style={{backgroundColor: 'transparent', border: 'none'}}
            />
        </div>
    </div>
    <div className={'entity-body'}>
        {data.$ownedAttributes &&
            data.$ownedAttributes.values &&
            data.$ownedAttributes.values.map((attribute) => (
                <DefaultNode data={attribute} key={attribute.id} />
            ))}
    </div>
    {decorators}
</View>
\end{lstlisting}
\begin{lstlisting}[language=JSX-template,caption=ERD Attribute template.,label=lst:attribute-template]
<View className="attribute">
    <div className="attribute-header">
        <div className={'input-container mx-2'}>
            <Input
                data={data}
                field={'name'}
                hidden={true}
                autosize={true}
                style={{ backgroundColor: 'transparent', border: 'none', textAlign: 'center' }} />
            {data.$isPK.value  && '(PK)'}
            <Selector data={data} field={'type'}/>
        </div>
    </div>
    {decorators}
</View>
\end{lstlisting}
\begin{lstlisting}[language=JSX-template,caption=ERD Relation template.,label=lst:relation-template]
<View className="relation">
    <div className="relation-inner">
        <div className="relation-header">
            <div className={'input-container'}>
                <Input
                    data={data.$name}
                    field={'value'}
                    hidden={true}
                    autosize={true}
                    style={{ backgroundColor: 'transparent', border: 'none', textAlign: 'center' }}
                />
            </div>
        </div>
    </div>
    <Edge
        view={'EdgeAssociation'} 
        key={`${data.id}-${data.$left.value.id}`}
        start={node} 
        end={data.$left.value.node} 
    />
    <Edge
        view={'EdgeAssociation'} 
        key={`${data.id}-${data.$right.value.id}`}
        start={node} 
        end={data.$right.value.node} 
    />
    {decorators}
</View>
\end{lstlisting}

%\begin{figure}
%    \centering
%    \includegraphics[width=\linewidth]{figs/templates.png}
%    \caption{ERD Entity, Attribute, and Relation templates.}
%    \label{fig:template}
%\end{figure}

\subsection{Validation viewpoint} 
The validation viewpoint enforces the rules and constraints defined in the metamodel, ensuring the general consistency of the model and structural correctness. By enabling proactive error detection and providing immediate feedback during the modeling process, it helps reduce errors and reinforces best practices.
%
As a specialized viewpoint, the validation viewpoint focuses on identifying invalid elements within a modeling artifact and alerting users when these elements violate established constraints. This direct feedback mechanism simplifies the identification and resolution of issues, ensuring that the model remains robust and accurate. In \jjodel{}, validation rules are defined using views to ensure model consistency and identify errors. The \texttt{onDataUpdate} configuration is crucial to evaluating the validity of model instances, while the \texttt{state} property of a node object serves as a repository for storing validation errors associated with the model. These errors are seamlessly tied to the relevant model elements, enabling precise and context-sensitive feedback to guide modelers in solving issues.
%
In the ERD scenario, Figure~\ref{fig:erd}(b) illustrates a validation marker triggered when an entity lacks a primary key attribute. To implement this validation rule, the \texttt{onDataUpdate} handler is used to evaluate the model and identify any violations. Validation errors are stored in the \texttt{state} property of the corresponding node, ensuring that errors are persistently tied to the affected elements.
%
Figure~\ref{fig:validation} demonstrates how to enforce the constraint of requiring at least one primary key for each entity. The implementation initializes an \texttt{err} variable to \texttt{undefined}. Using the JjOM framework, model elements are navigated to check if at least one of the \texttt{ownedAttributes} is marked as a primary key. If no primary key is found, the \texttt{err} variable is updated with an error message. Finally, the error message is stored in the \texttt{state} property of the corresponding node. If a node contains an error message, a validation marker (e.g., an alert dialog) is displayed near the affected entity, as shown in Figure~\ref{fig:erd}(b).

This approach ensures that modelers receive immediate visual feedback, enabling them to address validation errors efficiently and maintain the integrity of the modeling artifact.
\begin{figure}
    \centering
    \includegraphics[width=0.9\linewidth]{figs/validation.png}
    \caption{Validation rule.}
    \label{fig:validation}
\end{figure}

 

\begin{table}[b!]
\centering
\caption{Rule triggers.}
\label{tab:trigger}
\begin{tabular}{|p{2cm}|p{6cm}|}\hline
\textbf{Trigger} & \textbf{Description}\\\hline
{onDataUpdate} & Triggered when model data changes.\\\hline
{onDragStart} & Triggered when a drag action starts.\\\hline
{whileDragging} & Triggered during a drag action.\\\hline
{onDragEnd} & Triggered when a drag action ends.\\\hline
{onResizeStart} & Triggered when a resize action starts.\\\hline
{whileResizing} & Triggered during a resize action.\\\hline
{onResizeEnd} & Triggered when a resize action ends.\\\hline
\end{tabular}
\end{table}  
