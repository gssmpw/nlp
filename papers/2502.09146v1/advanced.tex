% \draft{\begin{itemize}
%     \item Semantic Zooming
%     \item Projectional and Positional Editing
% \end{itemize}}

% \subsection{Flexible Modeling with Shapeless Objects and Bidirectional Semantic Mapping}

% \begin{itemize}
%     \item Explain how JJODEL’s shapeless objects allow users to create “in-progress” elements that can be refined later, supporting flexible, iterative modeling. 

% \item Example: Demonstrate creating a placeholder object representing an undefined UML element that can later be specified as a class or attribute. 

% \item Bidirectional Semantic Mapping: Discuss how JJODEL’s mapping allows changes to concrete representations to update the underlying model. 

% \item Takeaway: JJODEL’s flexible modeling approach enables users to explore ideas iteratively, without locking them into rigid structures early on. 
% \end{itemize}

% \subsection{ Collaborative Modeling}

% \begin{itemize}
%     \item  Multi-User Editing and Conflict Resolution: Describe JJODEL’s support for real-time collaboration, where multiple users can work on the same model or metamodel with instant updates. 

%     \item  Example: In a group project scenario, team members simultaneously edit a shared UML model, with JJODEL handling versioning and conflict management. 

%     \item  Takeaway: JJODEL fosters collaboration by allowing multiple users to contribute to a single model seamlessly, making it ideal for team environments and distributed projects. 
% \end{itemize}
A core objective of \jjodel{} is to offer flexibility, enabling end users and language engineers to navigate the complexity and richness of modern multifaceted domains. Flexibility is not just a feature, but a foundational principle embedded within its design and technology stack. This approach allows language designers to tailor the modeling environment to their specific needs without encountering the challenges typically associated with custom coding or inflexible extension mechanisms.

To show the flexibility of \jjodel{} in action, we present two illustrative examples: \textit{grid snapping} and \textit{semantic zooming}~\cite{frisch2008towards}. These examples highlight how \jjodel{}'s design facilitates effortless customization of modeling functionalities, demonstrating its adaptability to diverse user requirements and complex scenarios.

\subsection{Grid-snapping}\label{grid-snapping}

Grid snapping is an essential feature in modeling environments, enhancing precision, usability, and efficiency. Although its implementation can be challenging, requiring accurate layout information and dynamic adaptability, these challenges are outweighed by the benefits it provides. By automating alignment tasks, grid snapping allows users to concentrate on the creative and semantic dimensions of their models, ensuring both functional accuracy and aesthetic refinement.

\jjodel{} offers a flexible framework for extending modeling editors by integrating two powerful methodologies: (i) JSX templating and CSS for advanced visual customization, and (ii) Event-Condition-Action (ECA) rules~\cite{widom1995active} for introducing dynamic behavior. As an example, implementing a dot-based grid—a visually minimal yet effective tool for aligning and organizing elements within the modeling editor—can be accomplished through the following steps: 

\begin{enumerate}
\item Defining a CSS class to render the grid as a pattern of dots on the editor canvas.  
\item Adding a toggle command to dynamically enable or disable the grid.  
\item Specifying an ECA rule to snap elements to the nearest grid vertex during movement.  
\end{enumerate}

Each of these steps is elaborated in the following paragraphs.

\paragraph{Step 1: Defining the Grid Style.}

The dot-based grid style is implemented through a simple CSS class definition, as shown below:

\begin{lstlisting}[language=css]
 .grid {
    background-image: radial-gradient(silver 1px, transparent 0);
    background-size: 15px 15px; /* 15px x 15px grid */
 }
\end{lstlisting}

This class renders the grid as a pattern of evenly spaced dots. In the next step, we show how to dynamically apply or remove the \code{.grid} class in the model view.

\paragraph{Step 2: Adding a Toggle Command for Grid Control.}

\jjodel{} enables the extension of the editor functionalities using the \code{<Control/>} component within the model view\footnote{The model view is included in the default viewpoint but can be cloned and customized as needed.}. In this example, a \code{<Toggle/>} component is added to dynamically enable or disable the grid. The toggle operates on a Boolean parameter, \code{grid}, which is defined on the template page, as illustrated in Figure~\ref{fig:grid-parameter}.
%
\begin{figure}
\centering
\includegraphics[width=0.75\linewidth]{figs/gridparameter.png}
\caption{The user-defined \code{grid} parameter.}
\label{fig:grid-parameter}
\end{figure}
%
The parameter \code{grid} serves as a shortcut for the expression:\\
%\begin{center}
\begin{lstlisting}[language=JSX-template]
node.state.grid ?? false
\end{lstlisting}
%\end{center}
which initializes the parameter in the \code{node} submodel to \code{false}. The updated template for the model view is shown below:
%
\begin{lstlisting}[language=JSX-template]
 <View className={model ${grid && 'grid'}}>
    ...
    <Control title={'Workbench'} payoff={'Controls'}>
        <Toggle name={'grid'} title={'Grid'} node={node} />
    </Control>
 </View>
\end{lstlisting}
%
Here, the conditional expression \code{\$\{grid \&\& 'grid'\}} dynamically applies the \code{.grid} class whenever the value of the parameter \code{grid} is \code{true}, allowing the feature.

\paragraph{Step 3: Enabling Snap-to-Grid Behavior.}
To implement the snap-to-grid functionality, an ECA rule is defined, as shown in Figure~\ref{fig:eca}. This rule takes advantage of the \code{grid} parameter to ensure that the elements align with the nearest grid vertex when moved.
%
\begin{figure}[h]
\centering
\includegraphics[width=0.95\linewidth]{figs/ECA3.png}
\caption{ECA rule for the \textit{snap-to-grid} feature.}
\label{fig:eca}
\end{figure}
%
The event \code{onDataUpdate} \circled{1} is triggered when an element is moved. Condition \circled{2} verifies the state of the parameter \code{grid}, and if enabled, the action \circled{3} adjusts the coordinates \code{x} and \code{y} of the model element to align with the nearest grid vertex.  

Figure~\ref{fig:editor-grid} provides a screenshot of the editor with the grid enabled and \code{<Toggle/>} on.

\begin{figure}[h!]
\centering
\includegraphics[width=1\linewidth]{figs/editorgrid2.png}
\caption{Grid-enabled editor.}
\label{fig:editor-grid}
\end{figure}

\subsection{Semantic Zooming}
Semantic zooming~\cite{frisch2008towards} is an advanced interaction paradigm that dynamically adjusts the level of detail presented in a model based on the zoom level. Unlike traditional zooming, which merely magnifies or shrinks visual elements, semantic zooming alters the content itself to better align with the user’s context and focus. In modeling, this approach offers several benefits, including enhanced usability, reduced cognitive load, and more efficient navigation by presenting only the most relevant details at each zoom level~\cite{pirolli2001focus}. For example, at higher zoom levels, intricate details of specific model elements become visible, while at lower zoom levels, complexity is abstracted to provide an overview of the entire model.

In \jjodel{}, semantic zooming is achieved by linking different visual representations to predefined zoom thresholds. These representations are dynamically updated as users adjust the zoom level, ensuring that the displayed content remains contextually relevant and appropriately detailed. Although semantic zooming might seem more conceptually complex than features such as grid snapping, it is implemented seamlessly in \jjodel{} thanks to its flexible templating framework. This framework allows for the integration of controls, such as parameters similar to \code{grid} discussed above, that dynamically influence visualization without affecting the underlying models.

Semantic zooming in the default syntax is implemented through the following steps:  

\begin{enumerate}  
\item Define an integer parameter, such as \code{level}, to represent the current zoom level.  
\item Add a slider control to the user interface that allows users to interactively adjust the zoom level.  
\item Divide the template into sections corresponding to different zoom levels, ensuring that the level of detail displayed dynamically adjusts based on the parameter's value.  
\end{enumerate}  
Each of these steps is elaborated in the following paragraphs.

\paragraph{Step 1: Defining a new integer parameter.} This step mirrors the process of defining the parameter \code{grid} for the snap-to-grid feature discussed earlier. Here, a user-defined parameter serves as a dynamic control to adjust the visualization. For example, the \code{level} parameter can be introduced in the template as part of the dependency settings. It is initialized using an expression such as:  

%\begin{center}
\begin{lstlisting}[language=JSX-template]  
node.state.level ?? 3
\end{lstlisting}  
%\end{center}
depicted also in Figure~\ref{fig:level}. This ensures that the parameter is stored in the \code{node} submodel and defaults to 3 (or any specified starting zoom level) if the user does not explicitly set it.  

\begin{figure}  
    \centering  
\includegraphics[width=0.75\linewidth]{figs/level.png}  
    \caption{User-defined \code{level} parameter.}  
    \label{fig:level}  
\end{figure}  

The parameter \code{level} acts as a bridge between user input and the dynamic behavior of the semantic zooming feature. By making the zoom level accessible and modifiable, it allows the modeling editor to adjust the level of detail displayed dynamically based on the current zoom value. This foundational step ensures that the parameter is seamlessly integrated into the template and other relevant parts of the modeling environment, setting the stage for subsequent steps in the implementation of semantic zooming.  

\paragraph{Step 2: Adding a Slider Control for Zoom Level Adjustment.} 


\paragraph{Adding a Slider Control for Zoom Level Adjustment.} This step parallels the use of the \code{<Toggle/>} component for the snap-to-grid feature but utilizes a \code{<Slider/>} component to modify the \code{level} parameter.  

The component \code{<Slider/>} is added to the control panel in the template, providing an intuitive mechanism for users to adjust the zoom level. Dynamically updates the \code{level} parameter stored in the \code{node} submodel, ensuring real-time responsiveness. This parameter acts as a bridge between user input and the dynamic behavior of the template.  

For instance, the updated template might look as follows:  

\begin{lstlisting}[language=JSX-template]  
 <View className={`model`}>  
   ...  
   <Control title={'Workbench'} payoff={'Zoom Controls'}>  
      <Slider name={'level'} title={'Zoom level'} node={node} min={0} max={3} />  
   </Control>  
 </View>    
\end{lstlisting}  

In this example:  
\begin{itemize}
    \item In line 4, the \code{name} property links the slider to the \code{level} parameter, ensuring that any adjustments made via the slider directly update the parameter. 
    \item In line 5, additional properties such as \code{min} and \code{max} define the range of zoom levels (e.g., 0 to 3) and the granularity of adjustments.  
\end{itemize}


Similar to the grid-snapping feature, this slider control integrates seamlessly with the \jjodel{} framework, enabling users to dynamically modify visualizations without directly interacting with the model data. The \code{level} parameter remains synchronized with the slider's position, facilitating context-aware rendering based on the zoom level, which will be detailed in the next step.  

\paragraph{Step 3: Slicing the Template for Semantic Zooming.} This step specifies how content dynamically adapts as the zoom level changes, ensuring that the displayed information is contextually relevant and aligned with the user’s focus. The template is divided into sections, each corresponding to a specific zoom level. For example, at lower zoom levels (e.g. \code{level = 0}), the template displays high-level abstractions of the model, while at higher zoom levels (e.g., \code{level = 3}), more detailed information is revealed.  

The following is a simplified example of a template associated with a generic metaclass \code{<metaclass-name>}:  

\begin{lstlisting}[language=JSX-template]  
 <View className={'metaclass-name'}>  
    {level === 0 && (  
        <div className={'overview'}>  
            {/* Render high-level abstractions */}  
            Overview of the model...  
        </div>  
    )}  
    {level === 1 && (  
        <div className={'mid-detail'}>  
            {/* Render mid-level details */}  
            Model with basic elements...  
        </div>  
    )}  
    {level >= 2 && (  
        <div className="full-detail">  
            {/* Render detailed elements */}  
            Complete model details...  
        </div>  
    )}  
 </View>  
\end{lstlisting}  

In this example, lines 2, 8, and 14 use conditional rendering to determine which content is displayed based on the value of the \code{level} parameter. This approach ensures that the visualization dynamically adjusts to the user’s zoom level, providing the appropriate level of detail for their current focus.  

The described approach to slicing the template ensures that semantic zooming is both straightforward to implement and highly effective, creating a dynamic and user-friendly modeling environment. Using the \code{level} parameter and the \jjodel{} templating system, semantic zooming is achieved without the need for custom coding or complex extension mechanisms.  

It is worth noting that this is just one method of implementing semantic zooming, using a single template with multiple sections corresponding to different zoom levels. An alternative approach could involve using a separate view for each \code{level} value, which offers additional flexibility depending on the use case.