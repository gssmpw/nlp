\jjodel{} is a comprehensive metamodeling framework tailored for language designers to define, extend, and refine DSLs and their associated modeling notations. It offers a structured and systematic approach to capture key structural elements of a language through formalized viewpoints. These viewpoints address critical aspects of language design, including abstract syntax, concrete syntax (textual, visual, or hybrid), validation rules, text generation, and semantics such as editor behavior. Using these capabilities, \jjodel{} facilitates the creation of a precise, flexible, and robust domain-specific workbench, ensuring clarity, consistency, and adaptability throughout the design process.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.55\linewidth]{figs/exprmetamodel.png}
    \caption{The metamodel of a simple Expression Language.}
    \label{fig:expr-metamodel}
\end{figure}

To illustrate the practical application of \jjodel{}, consider the expression language, a concise example that is often used to introduce students to the foundational concepts of MDE. The abstract syntax of this language is formalized in the metamodel shown in Figure~\ref{fig:expr-metamodel}, which provides a structured framework to represent algebraic expressions. The metamodel consists of abstract classes such as \code{Expression} and \code{BinExpression}, along with their relationships (\code{left} and \code{right}). These components enable the representation of atomic values (\code{Number}) and composite operations (\code{Add}, \code{Sub}, \code{Mult}, \code{Div}). Each expression includes a \code{val} property that stores its computed value, whether representing a literal number or the result of a composite operation. This structure encapsulates the semantics of mathematical expressions while supporting positional representation through concrete syntax definitions.

For instance, consider the following algebraic expressions:
\begin{eqnarray}
    1000 - ((212 + 2) + 102) = 684\\
    ((212 + 2) + 102) - 1000 = -684
\end{eqnarray}

\begin{figure}[ht]
    \centering
    \subfigure[Expression (1)]{
        \includegraphics[width=.32\textwidth]{figs/expr1.png} 
    }
    \quad
    \subfigure[Expression (2)]{
        \includegraphics[width=.41\textwidth]{figs/expr2.png} 
    }
    \caption{Expressions illustrating the influence of positional semantics.}
    \label{fig:expressions}
\end{figure}

These expressions involve nested binary operations in which subtraction serves as the root operation. Their tree-based representations are shown in Fig.~\ref{fig:expressions}. Although these expressions share the same abstract syntax (Fig.~\ref{fig:expr-abstract}), their computed values differ due to the positional nature of algebraic notation. Subtraction, being non-commutative, depends on operand order (e.g., $(10 - 5) \neq (5 - 10)$). To address this, the concrete syntax \jjodel{}, defined in visual viewpoints, encodes layout information to represent positional semantics.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.85\linewidth]{figs/exprabstract2.png}
    \caption{Abstract syntax of expressions (1) and (2).}
    \label{fig:expr-abstract}
\end{figure}

\jjodel{} leverages its dynamic viewpoints to manage these semantics effectively. For example, the \code{Number} view renders numbers as colored nodes, assigning values to their \code{val} property using JSX templates and CSS rules. Composite operations such as addition (\code{AddView}) and subtraction (\code{SubView}) are governed by the ECA rules~\cite{widom1995active}.

\begin{figure}[ht]
    \centering
    \includegraphics[width=0.95\linewidth]{figs/vps2.png}
    \caption{Viewpoints and their corresponding views.}
    \label{fig:vps}
\end{figure}

ECA rules consist of three components:
\begin{itemize}
    \item Event: \code{onDataUpdate}, triggered whenever the data associated with a model element change.
    \item Condition: Defining the OCL predicates and determining the elements to which a view applies.
    \item Action: Specifies how values are computed or updated using features defined in the metamodel (e.g., \code{\$val}, \code{\$left}, \code{\$right}). For instance, addition is defined as follows:
\begin{center}
    \includegraphics[width=1\linewidth]{figs/imageadd.png}
\end{center}
\end{itemize}

For subtraction, the implementation of \code{SubView} ensures positional semantics by enforcing relative operand positioning:
%\begin{center}\small
\begin{lstlisting}[language=JSX-template]
if (data.$left.value.node.x < data.$right.value.node.x) {...}
\end{lstlisting}
%\end{center}

The dynamic updates in \jjodel{} propagate seamlessly. For example:
\begin{enumerate}
    \item At $t_0$, the user modifies $e_0$ from $212$ to $112$.
    \item This triggers an \code{onDataUpdate} event, updating $e_1$ at $t_1 > t_0$.
    \item The update cascades to $e_3$, recalculating the value at $t_2 > t_1$.
    \item Finally, $e_4$ is re-evaluated, producing the correct result at $t_3 > t_2$.
\end{enumerate}

\begin{figure}[ht]
    \centering
    \includegraphics[width=.9\linewidth]{figs/updates.png}
    \caption{Dynamic update propagation workflow.}
    \label{fig:updates}
\end{figure}

By automating dependency resolution, \jjodel{} ensures consistency and eliminates redundant computations, allowing users to focus on high-level design tasks. This example highlights the capabilities of \jjodel{} in streamlining modeling workflows and providing a powerful and intuitive framework to tackle complex MDE challenges.
