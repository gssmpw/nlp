\section{Sources of Looseness in the Analysis}
\label{sec:looseness}
We systematically identify the sources of looseness in the above analysis with illustrative examples, before proceeding to individually tighten them in the subsequent section.

\subsection{A Conservative Approach to Handling Doubly-Charged Pages}
\label{sec:looseness-double-counting}

Recall that in the summation $\sum_{t \le T} \beta(t)$ above, a cache miss for $\opt$ may be double-counted if the same page is assigned two charges. Although one way to address this overcounting is to divide the summation by 2, this approach is overly conservative, as it \textit{under}counts every cache miss in $\opt$ that results from a request to a singly-charged page. For instance, consider the following situation:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.5]{img/double-counting.png}
    \caption{Request for $q$ (a singly charged page) at $t_2$ constitutes a unit cache miss for $\opt$, but the division by 2 undercounts this (and every other singly-charged cache miss in $\opt$).}
    \label{fig:double-counting}
\end{figure}
Here, at time $t_1$, $\mcA$ evicts a page $p$. Suppose that $p$ continues to live in the cache of $\opt$ after the request at $t_1$, and hence $c(p)$ is assigned to some $q$ in $\mcA$'s cache. Now, say that $q$ is requested at time $t_2$, which is before $t_3=r(t_1, p)$. Furthermore, assume that at $t_2$, $q$ only had the single charge on itself (by $p$), i.e., $q$ was not evicted by $\mcA$ in the time between $t_1$ and $t_2$. Then, $\beta(t_1)=1$, but we are wastefully dividing it by 2 in our calculation.

\subsection{Inexhaustive Clearing of Charges upon a Page Request}
\label{sec:looseness-uncleared-charges}

Consider the first item in the charging scheme (\Cref{item:clear-charges})---whenever a page $s$ is requested, any charges that $s$ might be \textit{giving} are cleared (i.e., $c(s)=\emptyset$). Intuitively, this is supposed to account for the fact that, while $s$ was holding some page $c(s)$ responsible for being requested before $s$ itself, either this did happen, in which case we happily clear the already-paid charge, or this did not quite happen and $s$ got requested before $c(s)$, in which case we should let go of the charge and focus on the future. However, consider instead the case where $s$ does not have a charge on any other page, but is itself the bearer of a charge by some other page, say $p$. In this case, $s$ has successfully paid the charge that was expected of it---\textit{but this charge would only be cleared upon the next request to $p$!} If it so happens that $p$ is next requested \textit{after} the time horizon $T$, then even if $s$ successfully paid the charge due to $p$, since this charge was not cleared when it was requested, it would be counted in $\mcO$ as part of the open charges post time $T$, and wastefully subtracted in the calculation. This is concretely illustrated in the situation below:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{img/uncleared-charges.png}
    \caption{Here, $\beta(t_1)=1$, and $\opt$ suffers a cache miss at $t_2$. However, $p$ still holds a charge on $s$ at time $T$ because it is requested at $t_3 > T$. Thus, this charge is included in $\mcO$, canceling out the contribution due to the cache miss at $t_2$.}
    \label{fig:uncleared-charges}
\end{figure}
This suggests that whenever a page is requested, we should clear not only the charges it gives but also any charges it {\em bears}, preventing unnecessary inclusion in $\mcO$. This approach ensures that a page discards its imposed charge immediately upon ``paying it off" rather than with a delay.

\subsection{No Accounting for Uncharged, Non-first-timer Pages}
\label{sec:looseness-uncharged-non-first-time}

Finally, observe that in the accounting of cache misses for $\opt$, we only count those that occur due to requests to charged/savior pages (as counted by the $\beta(t)$'s), and those that occur due to first-time requests to pages not initially in the cache (as counted by $\mcI$). However, $\opt$ can also suffer cache misses due to a request to an \textit{uncharged} page. Namely, if there is a request to a page $q$ that was previously evicted by $\opt$, but at the time that it is requested, $q$ is bearing no charges at all, then the cache miss due to $q$ is not being counted in the calculation. This is illustrated by the scenario below: 
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.45]{img/uncharged-eviction.png}
    \caption{At $t_3$, $q$ does not have any charges on it, but still causes a cache miss for $\opt$.}
    \label{fig:uncharged-eviction}
\end{figure}
$\mcA$ evicts $p$ at time $t_1$ and assigns a charge to $q \neq p$, implying that $q$ is not in the cache of $\opt$ after the request at $t_1$ (but was instead previously evicted by $\opt$). Next, at $t_2$, $p$ is requested, and this clears the charge it had on $q$. Since $p$ got requested before $q$, $\beta(t_1)=0$. Then, at $t_3$, $q$ is requested---$q$ has no charges on it at this point. Notice that this still causes a cache miss for $\opt$ at $t_3$. However, this cache miss is not accounted for in our calculation, either by $\beta(t_1)$, or by $\mcI$ (since this is not the first time that $q$ is being brought into the cache).
