\section{4-competitive Analysis of \cite{lund1999paging}}
\label{sec:lpr}

We restate and provide a more detailed proof of the crucial technical lemma from \cite{lund1999paging}, which is particularly useful for our improved $2$-competitive analysis in Section~\ref{sec:tight-analysis}.

\begin{lemma}[Lemma 2.5 in \cite{lund1999paging}]
    \label{lem:lpr}
    Let $\mcA$ be a paging algorithm. Suppose that whenever $\mcA$ suffers a cache miss, the page $p$ that it chooses to evict is chosen from a distribution such that the following property is satisfied: for every page $q$ in the cache, the probability (over the choice of $p$ and the random sequence ahead, conditioned on the most recently requested page) that $q$ is next requested no later than the next request for $p$ is at least $1/c$. Then $\mcA$ is $2c$-competitive against $\opt$.
\end{lemma}
\begin{proof}
    Consider an infinite (random) sequence of page requests, and consider running $\mcA$ and $\opt$ (independently of each other) on this sequence. At any time $t$ that $\mcA$ suffers a cache miss (say on a request to page $s$), suppose that $\mcA$ chooses to evict page $p$. Let $\mcA^-$ denote the contents in the cache of $\mcA$ just \textit{before} the request. Similarly, let $\opt^+$ denote the contents in the cache of $\opt$ just \textit{after} the request.
    
The proof uses a carefully designed charging scheme:\footnote{The charging scheme is purely for analysis purposes.} if $\mcA$ has to evict a page $p$ at time $t$ (due to a request for page $s$), $p$ assigns a charge to a page $c(p)$ that is \textit{not} in the cache of $\opt$ after the request at time $t$. Ideally, this page $c(p)$ will be requested again before $p$, causing $\opt$ to incur a cache miss at that later time. The specific charging scheme is as follows:
    \begin{figure}[H]
        \begin{framed}
        Suppose that at time $t$, there is a request for page $s$.
            \vspace{-2mm}
                \begin{enumerate}
                    \item \label{item:clear-charges} Set $c(s)=\emptyset$.
                    \item \label{item:assign-charge} If $\mcA$ evicts some page $p$, $c(p)$ is selected as follows:
                    \begin{enumerate}
                        \item \label{item:p-not-in-opt+} If $p \notin \opt^+$, set $c(p)=p$.
                        \item \label{item:p-in-opt+} If $p \in \opt^+$, find a page $q \in \mcA^- \setminus \opt^+$ that has no charges from $\opt^+ \setminus \mcA^-$. Set $c(p)=q$.\footnotemark
                    \end{enumerate}
                    \item \label{item:opt-eviction-charge-reassign} If $\opt$ evicts some page $p$ and $c(p) \neq p$, set $c(p)=p$.
                \end{enumerate}
            \vspace{-2mm}
        \end{framed}
        \vspace{-4mm}
        \caption{Charging Scheme}
        \label{fig:charging-scheme}
    \end{figure}
    \footnotetext{for any page $p$ that $\mcA$ might evict which satisfies the condition $p \notin \opt^+$, we make the \textit{same} choice of $q$.}
    At any time for any page $p$, $c(p)$ will either be $\emptyset$, or some (single) page. Furthermore, before the request at any time, $c(p) \neq \emptyset$ if and only if $p$ is not currently in the cache of $\mcA$.
    
    The first action (\Cref{item:clear-charges}) at the time of any page request is the clearing of charges: when a page $s$ is requested, if $s$ was giving a charge (either to itself or another page), it is duly cleared. If $\mcA$ suffers a cache miss, and evicts $p$, then our task is to find a page which is not going to be in the cache of $\opt$ just after time $t$, and assign a charge from $p$ to this page.
    
    If $p$ is not in $\opt^+$ (\Cref{item:p-not-in-opt+}), we assign $p$'s charge to itself. Otherwise, $p$ is in $\opt^+$ (i.e., $p$ is a page in $\mcA^- \cap \opt^+$), and we need to find a different page to charge. In this case, we will argue the existence of a page $q$ that satisfies the condition in \Cref{item:p-in-opt+}, for $p$ that fall into this case. Let us remove the common set $\mcA^- \cap \opt^+$ from each of $\mcA^-$ and $\opt^+$, and consider the sets $\mcA^- \setminus \opt^+$, $\opt^+ \setminus \mcA^-$. Note that both these sets have the same size, and $s$ is in $\opt^+ \setminus \mcA^-$, but not in $\mcA^- \setminus \opt^+$. Furthermore, in our initial step, we set $c(s)=\emptyset$. Thus, even if every page in $\opt^+ \setminus \mcA^-$ other than $s$ assigns a charge to a page in $\mcA^- \setminus \opt^+$, at least one page remains unassigned.
    We select this page (say the first one in a natural ordering) as $q$, the required charge recipient for $p$. Either way, note that $c(p)$ is not in $\opt^+$, and if $c(p)$ is requested before $p$, then $\opt$ incurs a cache miss. In this sense, $c(p)$ can be thought of as the “savior” page for $p$. %
    
    \Cref{item:opt-eviction-charge-reassign} simply reassigns the charge that a page gives if it is eventually evicted from $\opt$. 
    Specifically, $p$ may have initially set $c(p) = q \neq p$ when $\mcA$ evicted $p$, as $p$ still remained in $\opt$'s cache. However, if $\opt$ later evicts $p$, we can safely transfer the responsibility back from $q$ to $p$.
    

    The nice property about this charging scheme is that no page ever has more than $2$ charges on it at any time. Specifically, a page can hold at most one charge from itself and at most one charge from another page (because of \Cref{item:p-in-opt+} and \Cref{item:opt-eviction-charge-reassign}). 
    In fact, the only way a page can have two charges is if it first receives a charge from another page and later gets evicted by $\mcA$, assigning itself a self-charge.

    Now, fix a finite time horizon $T$: we will reason about the number of cache misses suffered by $\mcA$ and $\opt$ over the course of the $T$ page requests at $t=1,\dots,T$.
    First, let $\mcI$ denote the random variable that is the number of pages $s$ that were not present in the cache initially\footnote{Note that both $\opt$ and $\mcA$ start with the same initial cache.}, but were requested at some $t \le T$: $\opt$ suffers a cache miss for each of these pages.

    Next, let $r(t,p)$ denote the first time after $t$ that there is a request for page $p$. Define the indicator random variables:
    \begin{align}
        \alpha(t) &= \Ind[\text{$\mcA$ is forced to evict at time $t$}], \label{eqn:alpha}\\
        \beta(t) &= \Ind[\text{$\mcA$ is forced to evict at time $t$ and the page $\bp$ it evicts satisfies that $c(\bp)$\footnotemark\ is requested} \nonumber \label{eqn:beta}\\
        &\qquad\qquad\text{no later than $r(t,\bp)$}],
    \end{align}\footnotetext{While it is possible for charges to be reassigned, it suffices for the analysis to consider the indicator with $c(p)$ being the page that $p$ charges at the time of its eviction.}
    where $\bp$ is a random variable denoting the evicted page. 
    Note that
    \begin{align*}
        \cost(\mcA, T) &= \sum_{t \le T}\alpha(t).
    \end{align*}
    Observe that the indicator $\beta(t)$ represents a cache miss for $\opt$ (in the infinite sequence of requests) due to a request for the savior page $c(\bp)$. Note, however, that a request to the savior page $c(\bp)$ might occur \textit{after} the time horizon $T$. This can be addressed by counting the number of \textit{open} charges remaining after the request at time $T$. Specifically, let $\mcO$ denote the number of charges assigned by pages that are not in $\mcA$'s cache after the request at time $T$.
    Upon subtraction of $\mcO$, the quantity
    \begin{align*}
        \sum_{t \le T}\beta(t) - \mcO
    \end{align*}
    counts the number of cache misses suffered by $\opt$ due to requests to savior pages. A final detail is that a savior page could potentially have two charges on it, and hence we may count the same cache miss for $\opt$ twice in the above calculation. Concretely, suppose at time $t_1$, $p$ gets evicted by $\mcA$, and assigns a charge to $c(p)=q \neq p$. Then, suppose that at time $t_2 > t_1$ but $t_2 < r(t_1,p)$, $q$ is itself evicted by $\mcA$, resulting also in a charge $c(q)=q$. Now, suppose that $q$ gets requested after $t_2$ but before $r(t_1,p)$. In this case, we have that both $\beta(t_1)=1$ and $\beta(t_2)=1$, but these are really the same cache miss in $\opt$. Thus, we need to account for a possible double-counting of cache misses in $\opt$---one way to (very conservatively) do this is simply dividing the expression by 2. In total, we obtain that
    \begin{align}
        \cost(\opt, T) &\ge \frac{1}{2}\left(\sum_{t \le T}\beta(t) - \mcO \right) + \mcI, \label{eqn:lpr-final-accounting}
    \end{align}
    and hence
    \begin{align*}
        \E[\cost(\opt, T)] &\ge \frac{1}{2}\sum_{t \le T}\E[\beta(t)] + \E\left[\mcI - \frac{\mcO}{2}\right] \\
        &\ge \frac{1}{2}\sum_{t \le T}\E[\beta(t)] + \E\left[\mcI - \mcO\right].
    \end{align*}
    The expectation on the left side above is only with respect to the randomness in the sequence of page requests and $\opt$, whereas the expectation on the right side is over the randomness in the sequence of requests, $\opt$ as well as $\mcA$. 
    
    Now, fix any $t \le T$. Let $\sigma_{\le t}$ denote a fixed sequence of $t$ page requests, $\opt_{\le t}$ denote the execution of $\opt$ on these $t$ page requests, and $\mcA_{<t}$ denote the execution of $\mcA$ on all but the last of these page requests, such that $\sigma_{\le t}, \opt_{\le t}, \mcA_{< t}$ together result in a cache miss for $\mcA$ at time $t$. Then, we have that
    \begin{align*}
        \E[\beta(t)] &= \Pr[\text{$\mcA$ is forced to evict at time $t$ and the page $\bp$ it evicts satisfies that $c(\bp)$ is requested} \nonumber \\
        &\text{no later than $r(t,\bp)$}] \\
        &\hspace{-0.8cm}= \sum_{\sigma_{\le t}, \opt_{\le t}, \mcA_{<t}} \Pr[\sigma_{\le t}, \opt_{\le t}, \mcA_{<t}] \cdot \Pr\left[\text{page $\bp$ evicted by $\mcA$ at time $t$ satisfies that $c(\bp)$} \right. \\ &\qquad\qquad\qquad\qquad\qquad\qquad\qquad\qquad
        \left.\text{is requested no later than $r(t,\bp)$}\ \big|\ \sigma_{\le t}, \opt_{\le t}, \mcA_{<t}\right],
    \end{align*}
    Let us use the shorthand $\mcB:=\sigma_{\le t}, \opt_{\le t}, \mcA_{<t}$, and focus on the latter term in the summation.
    Note that once we have conditioned on $\mcB$, the configuration of $\mcA$'s cache (before the page request at $t$) is determined---denote its pages by $\mcA^-$.  At the last page request in $\sigma_{\le t}$, $\mcA$ suffers a cache miss, and chooses a page to evict from $\mcA^-$ from a (conditional) distribution $\mcP_t$ satisfying the property given in the lemma statement. Namely,
    \begin{align*}
        &\Pr\left[\text{page $\bp$ evicted by $\mcA$ at time $t$ satisfies that $c(\bp)$ is requested no later than $r(t,\bp)$}\ \big|\ \mcB\right] \\
        &= \sum_{p \in \mcA^-}\Pr_{\mcP_t}[p] \Pr\left[\text{$c(p)$ is requested no later than $r(t,p)$}\ \big|\ \mcB\right].
    \end{align*}
    But note that conditioning on $\sigma_{\le t}$, $\opt_{\le t}$ determines the cache of $\opt$ after time $t$: let its contents be denoted by $\opt^+$. Then, according to our charging scheme, for any $p \in \mcA^-$, $c(p)$ is as follows: if $p \notin \opt^+, c(p)=p$, whereas if $p \in \opt^+$, $c(p)=q$ for some fixed $q \in \mcA^-\setminus \opt^+$ that satisfies the condition in \Cref{item:p-in-opt+}. Note importantly that we make the same choice of $q$ for any $p$ in the latter case.
    \begingroup
    \allowdisplaybreaks
    \begin{align*}
        &\sum_{p \in \mcA^-}\Pr_{\mcP_t}[p] \Pr\left[\text{$c(p)$ is requested no later than $r(t,p)$}\ \big|\ \mcB\right] \\
        &= \sum_{p \in \mcA^-, c(p)=p}\Pr_{\mcP_t}[p]\underbrace{ \Pr\left[\text{$p$ is requested no later than $r(t,p)$}\ \big|\ \mcB\right]}_{=1\text{ since $p$ itself is the page requested at $r(t,p)$}} \\
        &+ \sum_{p \in \mcA^-, c(p)=q}\Pr_{\mcP_t}[p] \Pr\left[\text{$q$ is requested no later than $r(t,p)$}\ \big|\ \mcB\right] \\
        &\ge \sum_{p \in \mcA^-, c(p)=p}\Pr_{\mcP_t}[p] \Pr\left[\text{$q$ is requested no later than $r(t,p)$}\ \big|\ \mcB\right] \\
        &+ \sum_{p \in \mcA^-, c(p)=q}\Pr_{\mcP_t}[p] \Pr\left[\text{$q$ is requested no later than $r(t,p)$}\ \big|\ \mcB\right] \\
        &= \sum_{p \in \mcA^-}\Pr_{\mcP_t}[p] \Pr\left[\text{$q$ is requested no later than $r(t,p)$}\ \big|\ \mcB\right] \\
        &\ge \frac{1}{c},
    \end{align*}%
    \endgroup
    where in the last line, we used the property of the distribution $\mcP_t$ from the lemma statement. %
    Tracing backwards, we have obtained that
    \begin{align*}
        \E[\beta(t)] &\ge \sum_{\sigma_{\le t}, \opt_{\le t}, \mcA_{<t}} \Pr[\sigma_{\le t}, \opt_{\le t}, \mcA_{<t}] \cdot \frac{1}{c} = \frac{1}{c}\cdot \Pr[\text{$\mcA$ is forced to evict at time $t$}] = \frac{1}{c} \cdot \E[\alpha(t)].
    \end{align*}
    Finally, we observe that the random variable $\mcI-\mcO$ is always nonnegative. This is because, any page that is in the cache of $\mcA$ after the request at time $T$, or not in the cache of $\mcA$ after time $T$ but giving a charge, \textit{must necessarily} have either been in the initial cache, or must have been requested at some time $t \le T$. This implies that $k+\mcO \le k + \mcI$, which implies that $\mcI-\mcO \ge 0$. In total, 
    \begin{align*}
        \E[\cost(\opt, T)] \ge \frac12\sum_{t \le T}\E[\beta(t)] + \E\left[\mcI - \mcO\right]
        \ge \frac{1}{2c}\E\left[\sum_{t \le T}\alpha(t)\right] = \frac{1}{2c}\E[\cost(\mcA, T)]
    \end{align*}
    as required.    
\end{proof}

\begin{corollary}
    \label{corollary:dom-is-4-competitive}
    The dominating distribution algorithm $\mcA_\dom$ is 4-competitive against $\opt$.
\end{corollary}
\begin{proof}
    This follows from \Cref{lem:lpr} and \Cref{claim:dominating-distribution-probability}.
\end{proof}

\begin{remark}
    \label{remark:suboptimal-fifo}
    Consider setting $c=1$ in \Cref{lem:lpr}: this corresponds to $\mcA$ effectively being an \textit{offline} algorithm, which \textit{knows} which page in the cache is going to next be requested farthest in the future compared to all the other pages in the cache. We already know that such an algorithm is optimal, i.e., is 1-competitive against $\opt$. However, the guarantee given by \Cref{lem:lpr} for such an algorithm is still only $2$-competitiveness. This at least suggests that there is scope to improve the guarantee to $c$-competitiveness. %
\end{remark}
