
\section{Introduction}
In numerical algebraic geometry, curve tracking algorithms were originally introduced for solving polynomial systems using homotopy continuation, see, e.g., \cite{Sommese:2005,Bertini:2013} and the references therein.  More recently, the study of the connectivity structure defined by homotopy paths has opened new avenues of research, e.g., \cite{Sommese:2001,GaloisDuff:2022}.  With the recent development of efficient certified homotopy continuation methods in \cite{xu2018approach,guillemot2024validated,duff2024certified}, the computations of these connectivity structures become proofs.  The current paper continues this approach, using homotopy continuation and interval arithmetic to produce certified approximations to curves in arbitrary dimensions as well as their generic projections to $\mathbb{R}^2$.

Suppose $C$ is a smooth algebraic curve without self-intersections in $\mathbb{R}^n$ for some $n\geq 3$ and $x\in\mathbb{R}^n$ approximates a point $x^\star$ on the curve.  We present two certified algorithms for computations with this curve.  First, we provide an algorithm to compute an isotopic approximation to the component of the curve $C$ which contains $x^\star$ along with a tubular neighborhood containing this component of the curve $C$.  Second, if $\pi:\mathbb{R}^n\rightarrow\mathbb{R}^2$ is a generic projection, then we compute an isotopic approximation to the image of the component of the curve $C$ which contains $x^\star$ under the projection $\pi$.  In our calculations, the curve $C$ is usually given implicitly as the zero set of a system of $n-1$ polynomials, but our approach also applies to open curves given parametrically by $x=\gamma(t)$, where $\gamma$ consists of $n$ univariate polynomials.

For our first algorithm, we combine and develop ideas from the certified homotopy continuation algorithms \cite{guillemot2024validated,duff2024certified} with the certified curve tracking algorithm \cite{martin2013certified}.  This results in a certified approximation to the curve which can be locally refined as needed.  We note that one of the significant differences between our approach and that of \cite{martin2013certified} is that we do not use a global upper bound on the allowed step-size, and our algorithm is guaranteed to terminate with correct output on all nonsingular curves.

In our second algorithm, we introduce ideas from \cite{Byrd:2023} to correctly approximate intersections in the image of the curve after a generic projection to $\mathbb{R}^2$.  We observe that, due to a dimension argument, a generic projection $\pi:\mathbb{R}^n\rightarrow\mathbb{R}^m$ with $m>2$ introduces no intersections.  On the other hand, projections to $\mathbb{R}^2$ typically introduce intersections.  These intersections induce the main challenge in the construction of an approximation.  In particular, the issue is that the projection of an approximation may not be an approximation of the projection as errors in the approximation may introduce or miss self-intersections.

\subsection*{Outline}

In Section \ref{sec:background}, we review the necessary background for the paper from the certified computation literature.  In Section \ref{sec:path_tracking_algorithm}, we present the path tracking algorithm under study in this paper, see Algorithm \ref{algo:certified_curve_tracking}.  We apply this algorithm in Section \ref{sec:approximation} to develop Algorithm \ref{algo:certified_plane_curve}, which computes certified approximations to generic projections of curves.  Finally, a GitHub repository holds the code used to construct the illustrative examples (\Cref{fig:tubular_nbd,fig:two_projections,fig:PTOPO_example}) in this paper at

\centerline{\url{https://github.com/klee669/certified_curve_projections}}

\section{Background}\label{sec:background}
Suppose that $C$ is a smooth algebraic curve without self-intersections in $\mathbb{R}^n$ given by the common zeros of a polynomial system $F$ consisting of $n-1$ polynomials in $n$ variables.  Here, smooth means that the derivative of $C$ is nonzero everywhere, and we also observe that the self-intersection restriction does not exclude closed curves.  The algorithms in this paper compute certified piecewise-linear approximations to the curve $C$ and its generic projections.  In this context, a certified algorithm is one that provides a proof of correctness for its output, and, for our problems, the output is correct if the approximation and curve are close in Hausdorff distance and there is an ambient isotopy deforming the curve to the approximation.  In all of our algorithms we consider polynomial systems and inputs with coefficients in $\mathbb{Q}$ because they can be represented exactly on a computer and to avoid having to address how arbitrary real numbers are represented.

There is an extensive history of curve tracking algorithms, but there are relatively fewer certified path tracking algorithms, see, e.g., \cite{kearfott1994interval,Kim:2004,PV:2004,PV:2007,BCGY:2012,martin2013certified,Hoeven2015,katsamaki2023ptopo,Byrd:2023}.  Several certified approaches \cite{kearfott1994interval,Kim:2004,martin2013certified,Hoeven2015} are based on certifying predictor-corrector techniques.  In addition, \cite{PV:2004,PV:2007,BCGY:2012,Byrd:2023} use subdivision-based techniques until the curve (or curves) have simple local behavior.  The paper \cite{katsamaki2023ptopo} solves the related problem of tracking parametrically defined curves without converting the system to an implicit system.  For the special problem of path tracking in homotopy continuation, there are several approaches that certify the constructed curve, see, e.g., \cite{Smale:1993,Beltran:2008,Burgisser:2011,beltran2012certified,beltran2013robust,hauenstein2014posteriori,Hauenstein:2016,xu2018approach,guillemot2024validated,duff2024certified}.  Of these algorithms, it seems that \cite{guillemot2024validated,duff2024certified} may be among the most practical.  In the current paper, we combine ideas from \cite{guillemot2024validated,duff2024certified} to create a certified path tracking algorithm whose correctness is based on interval arithmetic and the Krawczyk method.  An important feature of our approach, that is lacking from many of the previous algorithms, is that the approximation can be locally refined after completion of the computation.

\subsection{Interval arithmetic}
Interval arithmetic is a method of computing with intervals instead of single numbers.  One advantage of using intervals to represent points is that conservative calculations in interval arithmetic can be used to quantify numerical errors.  Another use of interval arithmetic is that larger intervals can be used to study the behavior of functions over regions.  By performing arithmetic using intervals, our algorithms ensure reliable results.  

For a given arithmetic operator $\odot$, such as addition or multiplication, and intervals $I$ and $J$, we define 
\begin{equation}\label{eq:interval_arithmetic}
    I\odot J=\{x\odot y\mid x\in I, y\in J\}
\end{equation}
For instance, $[a,b]+[c,d]=[a+c,b+d]$; see, e.g., \cite{moore2009introduction} for more details.  We denote the collection of real intervals by $\mathbb{IR}$, and those with rational endpoints by $\mathbb{IQ}$. For a function $f:\mathbb{R}^n\rightarrow \mathbb{R}$ and an $n$-dimensional interval vector $I=(I_1,\dots, I_n)\in \mathbb{IQ}^n$, we define an \emph{interval extension} $\square f(I)$ of $f$ over $I$ to be an interval in $\mathbb{R}$ satisfying 
\[\square f(I)\supset \{f(x)\mid x\in I\}.\]
We note that an interval extension $\square f(I)$ for a specific $f$ and $I$ is not unique.  In fact, there may be several formulas for interval extensions of $f$ over $I$ which result in different over-approximations.  For a polynomial function $f\in \mathbb{Q}[X_1,\dots, X_n]$, an interval extension may be obtained by replacing variables by intervals and applying \Cref{eq:interval_arithmetic}. We define the interval extension $\square F(I)$ for a system of equations $F:\mathbb{R}^n\rightarrow \mathbb{R}^m$ by extending each coordinate function individually.

For an interval $I\in \mathbb{IR}$, we define the \emph{$\infty$-norm}  $\|I\|:=\max\limits_{x\in I}|x|$. We use the induced norm for interval vectors and interval matrices.  More precisely, for an interval vector $I=(I_1,\dots, I_n)$, we define $\|I\|=\max\limits_{i=1,\dots, n}\|I_i\|$. Likewise, for an interval matrix $M\in\mathbb{IR}^{n\times m}$, we define $\|M\|=\max\limits_{A\in M}\max\limits_{x\in \mathbb{R}^n}\frac{\|Ax\|}{\|x\|}$ where $\|x\|=\max\limits_{i=1}|x_i|$.

\subsection{The Krawczyk test}
The Krawczyk method is a central tool in certified path tracking as success with it proves the existence and uniqueness of a solution within a region.  The test combines a generalized Newton's method-type computation with interval arithmetic to prove that a specified region contains a unique solution.  Krawczyk \cite{krawczyk1969newton} introduced an interval operator that refines a compact convex region in order to isolate roots of nonlinear systems.  Moore \cite{moore1977test} demonstrated how to use this method to prove the existence of a solution to a nonlinear system. Building on this, Rump \cite{rump1983solving} extended the approach to establish the uniqueness of the solution.  Using this test, we define when an approximation solution is certified by the Krawczyk method.

\begin{definition}\label{def:approximate_solution}
    Given a polynomial system $F:\mathbb{R}^n\rightarrow\mathbb{R}^n$ and some $\rho\in (0,1)$, a point $x\in \mathbb{R}^n$ is called a \emph{$\rho$-approximate solution} to $F$ if there is an $n\times n$ invertible matrix $A$ and a constant $r>0$ such that  \begin{equation}\label{eq:krawczyk_test}
-AF(x)+\left(I_n-AJF(x+rB)\right)rB\subset r\rho B, 
    \end{equation}   where $B=([-1,1]+i[-1,1])^n$ is a unit interval box in $\RR^n$.
    In this case, a unique solution $x^\star$ to $F$ in $x+rB$ exists, and we say that $x^\star$ is the \emph{associated solution} to $x$. 
\end{definition}

When $x$ is a $\rho$-approximate solution, then the quasi-Newton map $g(x)=x-AF(x)$ is a $\rho$-Lipschitz continuous function.  The constant $\rho$ represents how accurate $x$ must be.  In other words, as $\rho$ gets smaller, the distance between $x$ and $x^\star$ must be smaller for the containment in \Cref{eq:krawczyk_test} to be satisfied. The following test uses interval arithmetic to test the containment in \Cref{eq:krawczyk_test}.

\algrenewcommand\algorithmicrequire{\textbf{Input}:}
\algrenewcommand\algorithmicensure{\textbf{Output}:}

\begin{algorithm}[ht]
	\caption{KrawczykTest}
 \label{algo:Krawczyk-test}
\begin{algorithmic}[1]
\Require  
\begin{itemize}
    \item A polynomial system $F=\{f_1,\dots, f_n\}\subset\mathbb{Q}[X_1,\dots, X_n]$,
    \item a point $x=(x_1,\dots, x_n)\in \mathbb{Q}^n$ (or $\mathbb{IQ}^n$),
    \item a positive real number $r\in \mathbb{Q}$,
    \item an $n\times n$ invertible matrix $A\in\mathbb{Q}^{n\times n}$ (or $\mathbb{IQ}^{n\times n}$),
    \item $\rho\in (0,1)$.
\end{itemize}
\Ensure A boolean.
\State {Set $K=-\frac{1}{r}A F(x)+\left(I_n-A\square JF(x+rB)\right)B$.}
\State {Return $\|K\|< \rho$.}
 \end{algorithmic}
 \end{algorithm}


\begin{remark}
Although we focus on real curves in this paper, it is natural to extend interval arithmetic to $\mathbb{C}^n$ by considering $\mathbb{C}^n$ as $\mathbb{R}^{2n}$ and modifying the operations appropriately.  In addition, the Krawczyk test and definition of an approximate solution can be adapted to the complex case, see, e.g., \cite{Analytic2019,Breiding:2023,guillemot2024validated,duff2024certified} for more details.
\end{remark}

\subsection{Certified homotopy path tracking}

\emph{Homotopy path tracking} is a method to find a solution to a system of nonlinear equations.  In order to solve the system $F:\mathbb{C}^n\rightarrow\mathbb{C}^n$, the method uses another system $G:\mathbb{C}^n\rightarrow\mathbb{C}^n$ whose solutions are known in advance and a homotopy $H(x;t):\mathbb{C}^n\times [0,1]\rightarrow\mathbb{C}^n$ with $H(x;0)=G(x)$ and $H(x;1)=F(x)$.  If $F$ and $G$ both have finitely many nonsingular solutions, then solutions to $F$ found by starting at solutions to $G$, and tracking paths from $t=0$ to $t=1$.  \emph{Certified homotopy path tracking} algorithms guarantee the correctness of this path tracking by constructing a compact region that contains the homotopy path. This compact region has the added property that, for any fixed $t^\ast\in [0,1]$, there is only one solution to $H(x;t^\ast)$ in the region.  There are two main methods for constructing this compact region.  The approaches in \cite{beltran2012certified,beltran2013robust,hauenstein2014posteriori} use Smale's alpha theory to certify their solution paths.  On the other hand, \cite{kearfott1994interval,martin2013certified,Hoeven2015,xu2018approach,duff2024certified,guillemot2024validated} use interval arithmetic-based approaches for certification.  In the current paper, we adapt the methods of \cite{duff2024certified,guillemot2024validated} from homotopy path tracking to more general path tracking.

\section{Curve tracking algorithm}\label{sec:path_tracking_algorithm}

We introduce a curve tracking algorithm for a regular curve in $\mathbb{R}^n$. Our approach is inspired by the homotopy tracking algorithms from \cite{duff2024certified,guillemot2024validated}.  The main distinction between homotopy continuation and path tracking is that, in homotopy continuation, there is a distinguished variable $t$, while in path tracking, the best that one can do is to have a locally distinguished variable.  We illustrate how interval arithmetic and the Krawczyk method are exploited to track the curve in a certified manner. %Especially, we focus on the modification from the homotopy tracking algorithms introduced due to the difference between homotopy paths and curves.% The primary concept of certified homotopy tracking algorithms is to enclose a given solution path with a sequence of interval boxes (or tubes). In particular, it aims to ensure the path in interval boxes is unique so that other solution paths do not trespass on any interval box.

Let $C$ be a regular curve in $\mathbb{R}^n$ given by the real loci of an algebraic variety $\mathbf{V}(c_1,\dots, c_{n-1})$ defined by $n-1$ polynomials $c_i\in \mathbb{Q}[X_1,\dots, X_n]$ for $i=1,\dots, n-1$.  We note that we use the notation $C$ for both the algebraic variety $\mathbf{V}(c_1,\dots,c_{n-1})$ as well as the polynomial system $\{c_1,\dots, c_{n-1}\}\subset\mathbb{Q}[X_1,\dots, X_n]$.  We denote the intersection of the curve $C$ and the plane $X_n=a$ by $C_a$.  Moreover, we note that when $a\in\mathbb{Q}$, $C_a:\mathbb{R}^{n-1}\rightarrow \mathbb{R}^{n-1}$ can be seen as a square polynomial system in $\mathbb{Q}[X_1,\dots, X_{n-1}]$.  On the other hand, for a point $x=(x_1,\dots, x_n)\in\mathbb{R}^n$, we let $x_{-n}=(x_1,\dots, x_{n-1})$ be the point in $\mathbb{R}^{n-1}$ consisting of the first $n-1$ coordinates of $x$.

%and a system $C_{x_n}:\mathbb{R}^{n-1}\rightarrow\mathbb{R}^{n-1}$, we denote $C(x)=C_{x_n}(x_1,\dots,x_{n-1})$ by $C_{x_n}(x)$ for the sake of brevity.



\subsection{Unitary transformation}

The first step that must be considered in adapting homotopy path tracking to general curve tracking is to update the distinguished direction.  Unlike a solution path in a homotopy, which maintains a consistent direction as $t$ increases, a general curve may change its direction over the path.  A straightforward remedy involves rotating the curve to temporarily align its tangent vector in the same specified direction at each step of the algorithm, see \Cref{fig:curve_rotation}. We introduce a unitary transformation designed for this purpose in \Cref{algo:transform}.

\begin{figure}
    \centering
    \input{curve_rotation}
    \caption{A schematic illustration of curve tracking with rotation.}
    \label{fig:curve_rotation}
\end{figure}


\algrenewcommand\algorithmicrequire{\textbf{Input}:}
\algrenewcommand\algorithmicensure{\textbf{Output}:}

\begin{algorithm}[ht]
	\caption{UnitaryTransformation}
 \label{algo:transform}
\begin{algorithmic}[1]
\Require  
\begin{itemize}
    \item A regular curve $C=\{c_1,\dots, c_{n-1}\}\subset\mathbb{Q}[X_1,\dots, X_n]$, and
    \item a point $x=(x_1,\dots,x_n)\in \mathbb{Q}^n$ approximating a point on the curve $C$.
\end{itemize}
\Ensure \begin{itemize}

    \item A transformed curve $\hat{C}$,
    \item a transformed point $\hat{x}$, and
    \item unitary matrices $U$ and $V^\star$.
\end{itemize} 
%\State {Define $C_{x_n}$ by plugging in $X_n=x_n$ for the curve $C$.}
\State {Compute the SVD of $JC(x)=U\Sigma V^\star$\\
Set $\hat{C}=U^\star C(V(X))$.\\
Set $\hat{x}=V^\star x$.\\
Return $(\hat{C},\hat{x}, U, V^\star)$.}

 \end{algorithmic}
 \end{algorithm}

For a regular curve $C$ and point $x$, let $U\Sigma V^\star$ be the SVD of $JC(x)$, and $\hat{x}$ the corresponding image of $x$ under this rotation.  We observe that applying this transformation results in a curve $\hat{C}$ with $\|\hat{C}(\hat{x})\|=\|C(x)\|$. Furthermore, we have that
    $$
    J\hat{C}(\hat{x})= U^\star JC(x)V=U^\star U\Sigma V^\star V=\Sigma.
    $$
We observe that $\Sigma$ is an $(n-1)\times n$ matrix whose last column consists of all zeros. Hence, $\ker J\hat{C}(\hat{x})=\langle e_n\rangle$. When $x$ and $y$ are points on the curve $C$, we know that $V^\star x$ and $V^\star y$ are also points on the curve $\hat{C}$. Moreover, since $V^\star$ is unitary, we have
\[\|\hat{x}-\hat{y}\|=\|V^\star x-V^\star y\|=\|x-y\|.\]

\begin{remark}
We note that \Cref{algo:transform} requires the computation of the singular value decomposition. For rigorous computation, we perform this computation using interval arithmetic so $U$, $\Sigma$, and $V^\star$ are all represented by interval matrices with arbitrary small intervals.  In this case, the diagonal structure and the column of zeros of $\Sigma$ are both maintained.  Since these matrices can be made with arbitrarily small intervals, any subsequent calculation can be made as precise as needed.
\end{remark}

%This unitary transformation will be applied at each step of constructing an interval box that covers the curve. This transformation allows for effective tracking by aligning the curve to track the direction of its kernel vector.

To avoid excessive use of $\hat{C}$ and $\hat{x}$, we always assume that the curve $C$ has been replaced by $\hat{C}$ and $x$ by $\hat{x}$.  Then, we combine this approach with \Cref{def:approximate_solution} to arrive at the following: for a regular curve $C\subset \mathbb{R}^n$, we say that a point $x=(x_1,\dots, x_n)\in \mathbb{R}^n$ is a \emph{$\rho$-approximate solution} to $C$ if $x_{-n}$ is a $\rho$-approximate solution to $C_{x_n}$. In this case, an associated solution $x^\star$ is a point on the curve $C$ where the last coordinate satisfies $X_n=x_n$.

\subsection{Curve prediction}

The core idea of our certified curve tracking algorithm is to construct a series of regions that begin from one point on (or near) the curve and cover a portion of the curve.
The Krawczyk test is applied to these regions to ensure that only one arc of the curve is contained within each region and the curve behaves nicely within the region. To construct such a tube, we use a numerical approximation of the curve (referred to as a \emph{prediction}) and create a region around this approximation with a fixed radius. If the Krawczyk test from \Cref{algo:Krawczyk-test} passes for this region, we proceed to the next step of tracking.

Two methods for curve prediction have been recently proposed in the literature for certified homotopy continuation \cite{duff2024certified,guillemot2024validated}.  In \cite[Algorithm 2]{duff2024certified}, the authors exploit the predictor-corrector method (see, e.g., \cite[Section 2.3]{sommese2005numerical}) for a prediction of the curve.  On the other hand, \cite[Section 6.3]{guillemot2024validated} employs a higher-order approximation of the curve obtained from a point on the curve and a tangent vector. The Taylor model (see \cite[Section 9.3]{moore2009introduction}) is applied to construct a curved interval box bounding this higher-order approximation.  One of the notable differences between these two prediction methods is the use of the step size and a corrector. The predictor algorithm in \cite{duff2024certified} requires the desired step size as input to correct a specific point from a prediction. In contrast, \cite{guillemot2024validated} derives an appropriate step size and does not need a step size as input. 

For a curve $C$, and a point $x$, we denote a prediction of the curve by $X(\eta):[0,\infty)\rightarrow \mathbb{R}^{n-1}$ such that $(X(0),x_n)=x$. The choice of the algorithm to produce such a prediction may be chosen by the user. For a fixed radius $r$, when the algorithm from \cite{duff2024certified} is chosen, we denote this algorithm by $\text{Predictor}(C,x,r,h)$ with a desired step size $h$, or $\text{Predictor}(C,x,r)$ when the prediction algorithm from \cite{guillemot2024validated} is chosen.  Since the choice of prediction is a user-defined choice, in our images we draw enclosing boxes for the prediction tube to illustrate the structure even the true prediction tube may be curved.

\subsection{Refinement}

Since it is difficult to access an exact point on the curve, we must apply the prediction algorithm to a point close to the curve.  The more accurate a given point is, the more precise the prediction will be, and the corresponding tracking will be more efficient.  The refinement step replaces a given prediction by a better prediction, leading to better behavior for the predictor.  \Cref{algo:meta_refine} performs this refinement.  In particular, it takes a $\rho$-approximate solution $x$ with an associated solution $x^\star$ to $C$ as an input and returns a point $x$ and $r$ such that all points in $x+r\tau[-1,0]^n$ are $\tau$-approximate solutions to $C$ for $\tau\in (0,1)$. In this case, a point $y\in x+r\tau[-1,0]^n$ and its associated solution $y^\star$ share the same last coordinate, that is, $y_n=y_n^\star$.  In \Cref{sec:curve_tracking_algorithm}, we illustrate why refining the region $x+r\tau[-1,0]^n$ and replacing $x$ with a better approximate, are both useful in our algorithms.

\begin{algorithm}[ht]
	\caption{RefineSolution}
 \label{algo:meta_refine}
\begin{algorithmic}[1]
\Require  
\begin{itemize}
    \item A regular curve $C=\{c_1,\dots, c_{n-1}\}\subset\mathbb{Q}[X_1,\dots,X_n]$,
    \item a $\rho$-approximate solution $x=(x_1,\dots, x_n)$ to $C$ with a radius $0<r<1$ and an $(n-1)\times (n-1)$ invertible matrix $A$, and
    \item a constant $\tau\in (0,1)$ representing a desired accuracy.
\end{itemize}
\Ensure A $\tau$-approximate solution $x$ with a corresponding radius $r$ and an $(n-1)\times (n-1)$ invertible matrix $A$.
\State{Set $x_{-n}=(x_1,\dots, x_{n-1})$}
\State{Set $I=[-1,0]^{n-1}\in\mathbb{IQ}^{n-1}$}
\While{$\text{KrawczykTest}(C_{x_n+[-r\tau,0]}, x_{-n}+r\tau I, r, A, \tau)=False$}
\State{Set $x_{-n}=x_{-n}-AC_{x_n}(x_{-n})$}
\State{Set $x=(x_{-n},x_n)$}
\State{Set $r=\frac{1}{2}r$}
    \State{Set $A=JC_{x_n}(x_{-n})^{-1}$}
\EndWhile
\While{$2r\leq 1$ and 

$\!\!\!\text{KrawczykTest}(C_{x_n+[-r\tau,0]}, x_{-n}+r\tau I, 2r, A, \tau)=True$}\label{line:while_loop_in_Refine}
\State{Set $r=2r$.}
\EndWhile
\State{Return $x,r,A$.}
 \end{algorithmic}
 \end{algorithm}

As \Cref{algo:meta_refine} may refine a $\rho$-approximate solution to an approximate solution with smaller $\rho$, we can use this algorithm to subdivide the computed regions for a curve. Subdividing these regions is needed when we want a finer curve approximation with a smaller tubular neighborhood. This feature plays an important role in computing the isotopic approximation of a projection of a curve, see \Cref{sec:approximation} for additional details.

We remark that \Cref{algo:meta_refine} is inspired by \cite[Algorithm 2]{guillemot2024validated}. For the completeness, we provide the correctness and termination statement for the algorithm. The detailed analysis can be found in \cite[Section 4.2]{guillemot2024validated} 
\begin{lemma}
\Cref{algo:meta_refine} returns a $\tau$-approximate solution and terminates within finitely many iterations.
\end{lemma}
\begin{proof}
    The input $x$ is a $\rho$-approximate solution, so the map $g(x)=x-AF(x)$ is a $\rho$-Lipschitz continuous function. Also, $x+r\tau[-1,0]^n$ converges to $x$ as $r$ converges to $0$. Therefore, if the first while loop iterates infinitely many times, a point $x$ converges to an exact point on the curve. Furthermore, if $r$ converges to $0$, then $\|K\|$ converges to $0$ where 
    $$K=-\frac{1}{r}A F(x)+\left(I_n-A\square JF(x+rB)\right)B.$$
    %{\color{blue} (Kisun: Check this. Does not $\frac{1}{r}$ prevent $\|K\|\rightarrow0$?)}
    Therefore, the first loop must terminate within finitely many iterations.  The second loop enlarges the radius without changing the result of the Krawczyk test. It must terminate in finitely many iterations since $r$ can only be doubled finitely many times before $r$ is greater than $\frac{1}{2}$.
\end{proof}

The first while loop reduces the radius at each iteration, potentially resulting in a narrow region. Tracking using a narrow interval box can be ineffective because a narrow box results in a narrow curve, strongly controlling the shape of the curve.  The second while loop enlarges the radius to avoid this.

\subsection{Stopping criterion}

We consider two stopping criteria for curve tracking. For a regular curve $C$ in $\mathbb{R}^n$ and a $\rho$-approximate solution $x$ to $C$ with the radius $r$, we suppose that the user provides a compact region of interest $D$ that contains $x$. Tracking terminates whenever we prove that the curve is closed or a newly constructed interval region $I$ intersects with the boundary of $D$. To conclude that the curve $C$ is closed, we check if $I$ intersects with an interval vector $J = x+r\rho[-1,1]^n$. If they intersect, we refine both independently. If the refinement of $J$ is contained in $I$, then we conclude that the curve is closed. If the refinement of $J$ does not intersect $I$ (or its refinement), we continue tracking the curve. We denote these criteria by $\text{StoppingCriterion}(D,x,C)$.
% SHOULD THIS BE: CONTAINS THE DISK AROUND x that contains x^* and passes the Krawczyck test (if not refine both x and the path coming in).

\subsection{Curve tracking algorithm}\label{sec:curve_tracking_algorithm}

We propose \Cref{algo:certified_curve_tracking} to track a regular curve $C$ in $\mathbb{R}^n$ starting with the point $x$.  We recall that the singular value decomposition uses interval arithmetic, so there may be roundoff error in its computation.  Hence, we require that the precision has been increased to make $\|VV^\star- I_n\|$ as small as needed.  Similarly, the computation of any inverses in the algorithm can be made precise enough so that any subsequent error is as small as necessary.  


\begin{algorithm}[ht]
	\caption{CertifiedCurveTracking}
 \label{algo:certified_curve_tracking}
\begin{algorithmic}[1]
\Require  
\begin{itemize}
    \item A regular curve $C=\{c_1,\dots, c_{n-1}\}\subset\mathbb{Q}[X_1,\dots, X_n]$,
    \item an approximate solution $x\in\mathbb{Q}^n$ to the curve $C$,
    \item a constant $h>0$,
    \item a compact region $D$,
    \item constants $\rho\in(0,\frac{1}{2}]$ and $\tau\in(\frac{1}2,1)$
\end{itemize}
\Ensure {\begin{itemize}
    \item A set of interval regions $\mathcal{I}$, and
    \item a $\rho$-approximate solution $x$ of $C$ outside $D$ or a certificate that $C$ is a closed curve.
\end{itemize}}
\State{Set $(\hat{C},\hat{x}, U, V^\star)=\text{UnitaryTransformation}(C,x)$.}
\State{Set $A= J\hat{C}_{\hat{x}_n}(\hat{x}_{-n})^{-1}$.}
\State{Set $\mathcal{I}=\emptyset$.}
\While{$\text{StoppingCriterion}(D,x,C)=False$}
\State{Set $h=\frac{5}{4}h$.}
\State{Set $(\hat{x}, r, A) =\text{RefineSolution}(\hat{C},\hat{x},r,A,\rho)$.}\label{line:6}
\State{Set $x=V\hat{x}$.}\label{line:rotate_back}
\State{Set $(\hat{C},\hat{x}, U, V^\star)=\text{UnitaryTransformation}(C,x)$.}\label{line:unitary_transformation}
\State{Set $A= J\hat{C}_{\hat{x}_n}(\hat{x}_{-n})^{-1}$.}
\State{Set $\hat{X}(\eta)=\left\{\begin{array}{ll}
    \hat{x}_{-n} & \text{ if }\eta<0  \\
    X(\eta)=\text{Predictor}(\hat{C},\hat{x},r,h) & \text{ if } \eta\geq 0
\end{array}\right.$.}\label{line:retract}
%\State{Set $X(\eta)=\text{Predictor}(\hat{C},\hat{x},r,h)$.}
\While{$\text{KrawczykTest}(\hat{C}_{\hat{x}_n+[-r\rho,h]},\hat{X}([-r\rho,h]),r,A,\tau)=False$}\label{line:10}
\State{$h=\frac{h}{2}$.}
\State{Set $X(\eta)=\text{Predictor}(\hat{C},\hat{x},r,h)$.}
\EndWhile
\State{Set $\mathcal{I}=\mathcal{I}\cup\{V\cdot(\hat{X}([-r\rho,h]),\hat{x}_n+[-r\rho,h])^\top\}$.}
\If{$I\cap J\ne\emptyset$ for any non-adjacent $I,J\in \mathcal{I}$ (except if the StoppingCriterion holds).}
\State{Break. Try again with a smaller $\rho$.}
\EndIf
\State{Set $\hat{x}=(X(h),\hat{x}_n+h)$.}\label{line:update}
\EndWhile
\State{Return $x$ or a conclusion that $C$ is a closed curve.}
 \end{algorithmic}
 \end{algorithm}


\begin{lemma}
     %$\text{KrawczykTest}(\hat{C}_{\hat{x}_n+[-r\rho,h]},\hat{X}([-r\rho,h]),r,A,\tau)$ 
     \Cref{line:10} of \Cref{algo:certified_curve_tracking} returns $True$ for some $h>0$.
\end{lemma}
\begin{proof}
%    To avoid abusing notations, we denote $\hat{X}\cup X(\eta)$ by $X(\eta)$ and $\hat{x}_n+[-r\rho,0]$ by $\hat{x}_n$. 
Define 
$$    K(\eta)=-\frac{1}{r}A \hat{C}_{\hat{x}_n+\eta}(\hat{X}(\eta))\\+\left(I_n-A\square J\hat{C}_{\hat{x}_n+\eta}(\hat{X}(\eta)+rB)\right)B$$ from the Krawczyk test in \Cref{line:10}.
    We show that 
    $\|K([-r\rho,h])\|< \tau$
    for some $h>0$ after sufficiently many iterations of the while loop in  \Cref{line:10}.
    When $h$ converges to $0$, the vector $(\hat{X}([-r\rho,h]),\hat{x}_n+[-r\rho,h])$ converges to $(\hat{x}_{-n},\hat{x}_n+[-r\rho,0])$. Hence, there is some sufficiently small $h>0$ such that $\|K([-r\rho,h])\|< \rho$ because $\|K([-r\rho,0])\|<\rho$ from \Cref{line:6}. When the norm is sufficiently small, the Krawczyk test succeeds.  Since the norm is a continuous function of $h$, the result follows.
\end{proof}
% I MADE A CHANGE to line 16, is it OK?
% Good.

The vector $\hat{X}(\eta)$ in \Cref{line:retract} is for constructing an interval extended backwards to cover the curve without any gaps. By evaluating $(\hat{X}(\eta),\hat{x}_n+\eta)$ over the interval $[-r\rho, h]$, the next step of the approximation completely covers the portion of the boundary of the previous interval region that contains the exiting curve.  Without extending the interval backwards, the intervals may not completely cover the curve (see \Cref{fig:retract_box}). Since refinement makes the initial tangent vector closer to the curve's tangent vector, the required backwards component shrinks and the curve will not deviate from the extended part.

\begin{figure}
    \centering
    \input{retract_box}
    \caption{The blue dot represents refined $\hat{x}$ from \Cref{line:6} in \Cref{algo:certified_curve_tracking}. The dashed arrow describes the prediction $\hat{X}$. The red dashed box constructed from $\hat{x}$ does not cover the curve completely. The solid magenta portion of the curve shows the small uncovered gap when the red dashed box is used. It is covered by the interval extended backward by $r\rho$. The solid black boxes represent actual intervals computed to cover the curve.}
    \label{fig:retract_box}
\end{figure}



\begin{lemma}
    In \Cref{algo:certified_curve_tracking}, $\hat{x}=(X(h),\hat{x}_n+h)$ from \Cref{line:update} is a $\tau$-approximate solution to $\hat{C}$.
\end{lemma}
\begin{proof}
For a point $\hat{x}$ obtained from \Cref{line:unitary_transformation}, define
$$K(\eta)=-\frac{1}{r}A \hat{C}_{\hat{x}_n+\eta}(X(\eta))\\+\left(I_n-A\square J\hat{C}_{\hat{x}_n+\eta}(X(\eta)+rB)\right)B.$$ 
    Due to the second while loop, we have $\|K(h)\|< \tau$
    for any $h\in [-r\rho,h]$. This implies that $(X(h),\hat{x}_n+h)$ in \Cref{line:update} is a $\tau$-approximate solution to $\hat{C}$.
\end{proof}


\begin{thm}
\Cref{algo:certified_curve_tracking} terminates.
\end{thm}
\begin{proof}
    We prove that the a sequence of points $x$ obtained in \Cref{line:rotate_back} does not converge to a point until it satisfies the stopping criterion.  Suppose that the sequence does converge before satisfying the stopping criterion.  This means that $h$ must be halved infinitely many times as we repeat the second while loop in \Cref{line:10}.  Define $$K(\eta,\lambda)=-\frac{1}{\lambda}A\hat{C}_{\hat{x}_n+\eta}(\hat{X}(\eta))+\left(I_n-A\square J\hat{C}_{\hat{x}_n+\eta}(\hat{X}(\eta)+\lambda B)\right)B.$$
    Then, we have $\|K([-r\rho,h],r)\|>\tau$ for infinitely many $h$.
    On the other hand, $\|K([-r\rho,0],r)\|< \rho$ because of \Cref{line:6} in the algorithm. 
    
    If there is $r_0>0$ such that $r\geq r_0$ at each iteration, then we have $\lim\limits_{h\rightarrow 0}\|K([-r_0\rho,h],r_0)\|<\rho$ which contradicts the fact that $\|K([-r\rho,h],r)\|>\tau>\rho$ for infinitely many $h$.
    Therefore, we may assume that $r$ becomes arbitrarily small due to refinement in  \Cref{line:6}. %In this case, the matrix $A$ converges to $J\hat{C}_{\hat{x}_n}(\hat{x})^{-1}$. 
    Then, whenever $r<1$ is returned from \Cref{line:6}, we have
    $\|K([-r\rho,0],2r)\|>\rho$ because of the second loop in \Cref{line:while_loop_in_Refine} of \Cref{algo:meta_refine}.
    Furthermore,
    since $\square J\hat{C}_{\hat{x}_n+[-r\rho,0]}(\hat{X}([-r\rho,0])+2rB)$ converges to $J\hat{C}_{\hat{x}_n}(\hat{x}_{-n})$ as $r$ converges to $0$, for any $0<\epsilon<1$, there is $r_0>0$ such that 
    \[\left\|I_n-A\square J\hat{C}_{\hat{x}_n+[-r\rho,0]}(\hat{X}([-r\rho,0])+2rB)\right\|<\epsilon\]
    whenever $r<r_0$.
    Therefore, we have $$\left\|-\frac{1}{2r}A\hat{C}_{\hat{x}_n+[-r\rho,0]}(\hat{X}([-r\rho,0])\right\|+\epsilon \geq \|K([-r\rho,0],2r)\|>\rho.$$ This contradicts the inequality $\|K([-r\rho,0],r)\|<\rho$.
\end{proof}

For a detailed analysis of the homotopy path tracking algorithm with adaptive precision, see \cite[Section 5.3]{guillemot2024validated}.

We say that the collection of all interval regions computed from \Cref{algo:certified_curve_tracking} is a \emph{tubular neighborhood} of the curve $C$ and denote this by $\mathcal{A}(C)$ (see \Cref{fig:tubular_nbd}).  We observe that by reducing $\rho$ as needed, we can make the Hausdorff distance between the approximation and the curve as small as desired.  In addition, if we wish to create an approximation to the curve itself, we may construct a path within the interval regions connecting, connecting them sequentially.

\begin{figure}[h]
    \centering
    \input{graph9}
    % \includegraphics[width=0.5\linewidth]{curve_rotation.png}
    \caption{A tubular neighborhood of the curve $C=\{x^3-2.7x-y^2+2\}$ computed with $\rho = \frac{1}{8}$.  Even though the curve track is executed with tilted or curved intervals, rotating interval regions back to the original coordinates with interval arithmetic results in rectangular boxes.}
    \label{fig:tubular_nbd}
\end{figure}


\section{Approximating a plane curve}\label{sec:approximation}

We introduce a method for approximating a plane curve from the result of a generic projection $\pi : \RR^n \to \RR^2$ when $C$ is a regular curve.  In this case, generic means that the projection has no triple intersections, all of the crossings in the image are transverse, and there are no tangent vectors in the kernel of the projection.  Straight-forward dimension checks show that generic projections satisfy these three conditions.  To construct such an approximation, we start with a tubular neighborhood of the curve $C$ computed from Algorithm \ref{algo:certified_curve_tracking} and further refine until we can guarantee the correctness of the projection.  The main challenge with this approach is correctly handling self-intersections of $\pi(C).$

In order to achieve the correct topological statements, we need two tests.  One to exclude intersections from regions and another to detect crossings.  Suppose that $I_1$ and $I_2$ are two interval regions from $\mathcal{A}(C)$ such that $\pi(I_1)$ and $\pi(I_2)$ intersect.  This indicates that it is possible for the image of the curve to have a self-intersection within $\pi(I_1)\cap\pi(I_2)$.

We first discuss our exclusion test.  Let $(I_1,I_2)$ be the sequence of consecutive interval regions constructed in $\mathcal{A}(C)$ that goes between $I_1$ and $I_2$.  If $C$ is a closed curve, then both of the two possible sequences can be used for $(I_1,I_2)$.  We exclude intersections between the curve in $I_1$ and $I_2$ if the direction of the curve doesn't change too much in $(I_1,I_2)$.

For each interval region $I$ in $(I_1,I_2)$, we evaluate the Jacobian $JC(I)$ and compute its numerical kernel $K$ using interval arithmetic.  In this case, $\pi(K)$ contains all tangent vectors to the curve $\pi(C)$ coming from $C\cap I$.  By the genericity assumption, for a sufficiently close approximation, $\pi(K)$ does not contain $0$.  We now take the union of all $\pi(K)$ for $I$ in $(I_1,I_2)$.  If this union lies in an open half-space, then the image of the curve from $(I_1,I_2)$ cannot self-intersect in the projection as the projected curve is always traveling in the direction of the normal to this half-space and never turns around.

If this test fails, then it is possible that there is a self-intersection of the curve in $\pi(I_1)\cap\pi(I_2)$.  In order to detect this crossing, we carefully approximate the image of the curve near $\pi(I_1)\cap\pi(I_2)$.  By studying the global behavior of the approximation, we can conclude if there is a self-intersection of the projection.  The main idea is to construct, for each of $I_1$ and $I_2$, a long rectangular region that contains the projection of the curve from either $I_1$ or $I_2$ such that the curve passes through the short ends of the rectangles.  If the rectangles intersect on their long sides only, then by the intermediate value theorem, the projections of the curves must cross.  Our test is detailed in Algorithm \ref{algo:strip_test}.  See Figure \ref{fig:crossing_rectangles} for additional details.


\begin{figure}[h]
    \centering
    \input{crossing_rectangles}
    % \includegraphics[width=0.5\linewidth]{curve_rotation.png}
    \caption{A schematic illustrating how self-intersections of the curves are detected.  The two rectangles contain the curve along their lengths and intersect on their lateral sides.  This guarantees a crossing of the curves.}
    \label{fig:crossing_rectangles}
\end{figure}

Before we begin the details of our test, we note that Algorithm \ref{algo:certified_curve_tracking} can be easily adapted to locally refine the tubular neighborhood $\cA(C)$.  Suppose that we wish to refine a consecutive sequence of tubes.  At each end of this sequence, there are points $x_1$ and $x_2$ that approximate the curve.  Without loss of generality, we assume that the direction in which we track $C$ passes $x_1$ first and then $x_2$.  By applying Algorithm \ref{algo:certified_curve_tracking} starting at $x_1$ and with small $\rho$ results in a refinement of the tubular neighborhood when the StoppingCriterion succeeds for the point $x_2$.




%\hrule


%\hrule




%We can exclude any intersections of the curve between these two regions 


%s until the approximation satisfies additional tests.  We provide an algorithm for constructing the tubular neighborhood of $\pi(C)$ and prove its correctness using some topological results.
 
%\begin{definition}
%    For a tubular neighborhood $\mathcal{A}(C)$ of a regular curve $C$, consider two interval tubes $I_1$ and $I_2$. We say that $I_1$ and $I_2$ are \emph{adjacent} if they are created consecutively by \Cref{algo:certified_curve_tracking}.
    
%    Furthermore, %we say that two interval tubes $I_1$ and $I_2$ \emph{intersect non-trivially} if $I_1\cap I_2\ne \emptyset$ and $I_1$ and $I_2$ are not adjacent. 
%    Finally, 
%if a generic projection $\pi:\mathbb{R}^n\rightarrow \mathbb{R}^2$ is given, we may define adjacency of $\pi(I_1)$ and $\pi(I_2)$ naturally.
%\end{definition}



%\begin{definition}
%    Let $C$ be a regular curve in $\mathbb{R}^n$ and $\pi:\mathbb{R}^n\rightarrow \mathbb{R}^2$ be a generic projection. For the projection $\pi(\mathcal{A}(C))=\{\pi(I_1),\dots, \pi(I_N)\}$ of the tubular neighborhood, we say that $\pi(I_i)$ is an \emph{intersecting tube} if there is $\pi(I_j)\in \pi(\mathcal{A}(C))$ intersecting non-trivially with $\pi(I_i)$.
%\end{definition}


% \begin{definition}
%     Let $\mathcal{A}_1$ and $\mathcal{A}_2$ be subcollections of $\mathcal{A}(C)$ such that each $\mathcal{A}_i$ consists of adjacent interval tubes.
%     We say that $\mathcal{A}_1$ and $\mathcal{A}_2$ \emph{intersect} if $I\cup\left(\bigcup_{J\in \mathcal{A}_2}J\right)\ne\emptyset$ for any $I\in \mathcal{A}_1$. In this case, we call $\{\mathcal{A}_1,\mathcal{A}_2\}$ an \emph{intersecting part}.
%     Furthermore, we say that $\mathcal{A}_1$ and $\mathcal{A}_2$ \emph{intersect transversally} if any deformation retract of $\bigcup_{I\in \mathcal{A}_i}I$ intersects transversally. 
% \end{definition}

% \textcolor{blue}{Sketch of the procedure.}
% \begin{itemize}
%     \item Build an adjacency list of all boxes in $\pi(\cA(C)).$
%     \item For each pair of intersecting boxes, $A$ and $B$ do the following:
%     \begin{itemize}
%         \item Test if the direction changes by more than $\pi$ radians. This is done by approximating the angle of the tangent vectors in each box between $A$ and $B$ inclusive. If the union of such angles covers more than half a circle (i.e., the angle changes by more than $\pi$ radians), then we refine. \textcolor{blue}{Do we refine just $A$ and $B$ or every box between too?}
%         \item If $\{A, B\}$ fail the $\pi$-test, then we move on to the strip test. To do this, we pick an arbitrary point in $ p \in A \cap B$ and compute the direction of the tangent vector for $\pi^{-1}(p) \in \pi^{-1}(A)$ and $\pi^{-1}(p) \in \pi^{-1}(B).$ Using the tangent vectors we construct tubes of radius \textcolor{blue}{something in terms of $\rho$ and $r$}. We then extend these two tubes until they are completely separated \textcolor{blue}{this distance can be determined with a little trig}. Extending outward from $A$ and $B$ through adjacent boxes, we check if a box intersects the ``walls'' of the tubes. If this type of intersection occurs, we refine. If the boxes ``escape'' the tubes through the end caps for both tubes, then we have an intersection. 
%         \item If we have detected an intersection using the strip test, we need to check for multiple intersections. To do this, we use the $C_1^\times$ test (\textcolor{blue}{this needs to be properly defined)}.
%     \end{itemize}
% \end{itemize}

% \begin{definition}
%     Let $\{\mathcal{A}_1, \mathcal{A}_2\}$ be an intersecting part of $\mathcal{A}(C)$. The \emph{intersecting completion} of $\{\mathcal{A}_1, \mathcal{A}_2\}$ is constructed as follows:
%     \begin{enumerate}
%     \item Add to $\mathcal{A}_2$ all interval tubes that intersect some $B \in \mathcal{A}_1$ but are not already adjacent to any $B \in \mathcal{A}_1$.
%     \item If $\mathcal{A}_2$ is no longer a contiguous collection of adjacent interval tubes, add the necessary adjacent interval tubes to restore contiguity.
%     \item Add to $\mathcal{A}_1$ all interval tubes that intersect some $B \in \mathcal{A}_2$ but are not already adjacent to any $B \in \mathcal{A}_2$.
%     \item If $\mathcal{A}_1$ is no longer a contiguous collection of adjacent interval tubes, add the necessary adjacent interval tubes to restore contiguity.
%     \item Repeat this process until no further interval tubes are added to either $\mathcal{A}_1$ or $\mathcal{A}_2$.
%     \end{enumerate} We say a pair $\{\cA_1, \cA_2\}$ is a \emph{complete intersecting part} if the intersecting completion of $\{\cA_1, \cA_2\}$ is the pair itself.
% \end{definition}

% How do we detect and remove regions where we suspect there may be multiple intersections?
% \begin{itemize}
%     \item Compute a tubular neighborhood $\mathcal{A}(C)$ of $C$.
%     \item For a generic projection $\pi$ consider $\pi(\mathcal{A}(C))$
%     \item Find all intersecting pairs $(\pi(\mathcal{A}_i),\pi(\mathcal{A}_j))$ from $\pi(\mathcal{A}(C))$. 
%     \item For intersecting $\pi(\mathcal{A}_1)$ and $\pi(\mathcal{A}_2)$, if they intersect transversally, then we conclude that there is no multiple intersections in the part. (need to prove. we may use the fact that the curve is contained ``uniquely'' in the tube.)
%     \item If there is a non-transversal intersection of $\pi(\mathcal{A}_1)$ and $\pi(\mathcal{A}_2)$, there must be deformation retract $r_i$ of $\pi(\mathcal{A}_i)$ such that $r_1$ and $r_2$ has  parallel tangent vectors. This will be detected via interval arithmetic as Michael wrote.
%     \item If $\pi(\mathcal{A}_1)$ and $\pi(\mathcal{A}_2)$ intersect non-transversally, we refine $\mathcal{A}_1$ and $\mathcal{A}_2$ further until non-transversal intersections are removed.
%     (we need to prove that a non-transversal intersection may be removed after sufficient refinements)
% \end{itemize}

%Let $C$ be a regular curve in $\RR^n$ with tubular neighborhood $\cA(C)$ and let $\pi:\RR^n \to \RR^2$ be a generic projection. Let $I_1$ and $I_2$ be two interval tubes of $\cA(C).$ We define $T_0(I_1, I_2)$ in the following way. First, we construct a sequence, $S,$ of adjacent interval tubes connecting $I_1$ and $I_2.$ If two such sequences exist, we consider both. For each interval tube $J_i \in S,$ we evaluate the Jacobian, $J_C(J),$ and compute its numerical kernel $K_i$ using interval arithmetic. Then, we consider $\pi(K_i)$ and determine the interval of angles of the tangent vectors of the curve. If the angle does not change by more than $\pi$ for at least one sequence $S,$ $T_0(I_1, I_2)$ returns $\true,$ otherwise $T_0(I_1, I_2)$ returns $ \false.$ 

%Let $C$ be a regular curve in $\RR^n$ with tubular neighborhood $\cA(C)$ and let $\pi:\RR^n \to \RR^2$ be a generic projection. Let $I_1$ and $I_2$ be two interval tubes of $\cA(C).$ We define the predicate $T_1(I_1, I_2)$ in the following way. We start by determining the Jacobian matrix, $J_C.$ Then, for each $I_i,$ we compute the numerical kernel $K_i.$ Then, we have $T_1(I_1, I_2) = \true$ when $0 \notin \pi(K_1) \times \pi(K_2),$ otherwise  $T_1(I_1, I_2) = \false.$ 

\begin{algorithm}[h]
	\caption{IntersectionCheck}
 \label{algo:strip_test}
\begin{algorithmic}[1]
\Require  
\begin{itemize}
    \item A regular curve $C=\{c_1,\dots,c_{n-1}\}\subset\mathbb{Q}[X_1,\dots,X_n]$
    \item A tubular neighborhood $\cA(C)$ obtained by Algorithm \ref{algo:certified_curve_tracking}
    \item A generic projection $\pi: \RR^n \to \RR^2$
    \item A pair of interval regions $\{I_1, I_2\}$ with intersecting projections
\end{itemize}
\Ensure 
\begin{itemize}
    \item A boolean value indicating confirmation of a self-intersection.
\end{itemize}
\State{Set $p$ to be the center of $\pi(I_1) \cap \pi(I_2)$}
\State{Construct approximation $v_i$ to the image of the tangent vector at $p$ for $\pi(I_i)$.}
\If{$v_1$ and $v_2$ are parallel}
\State{Refine $I_1$ and $I_2$}
\State{Return \false}
\EndIf
\State{Set $r$ to be the maximum diameter of $\pi(I_1)$ and $\pi(I_2)$.}
\State{Construct rectangular region $R_i$ to be a rectangle centered at $p$ whose width is of length $2r$ in the direction $v_i^\perp$ and whose length is long enough so that the edges of length $2r$ are outside the other rectangle.}
\State{Refine $\cA(C)$ until every interval region intersecting $R_i$ has diameter at most $r$.}
\State{Starting at $I_i$, find the first interval region in the forward and backward directions of $\cA(C)$ that are completely outside $R_i$.  Set $(F_i,L_i)$ to be these consecutive sequence of regions.}
\If{Either $(F_i,L_i)$ intersects the lateral sides of $R_i$}
\State{Refine all interval regions in $R_i$.}
\State{Return \false}
\EndIf
\If{Each $(F_i,L_i)$ does not satisfy the half-space tangent vector condition above}
\State{Refine all interval regions in $R_i$.}
\State{Return \false}
\EndIf
\For{{\bf each} pair of interval regions $J_i\in R_i$}
\State{Set $K_i$ to be an interval box containing the numerical kernel of $JC(J_i)$}
\If{$\pi(K_1)$ and $\pi(K_2)$ contain a parallel vector}
\State{Refine all interval regions in $R_i$.}
\State{Return \false}
\EndIf
\EndFor
\State{Return \true}
\end{algorithmic}
\end{algorithm}

% This algorithm was already started in algo:certified_plane_curve - Byrd Feb 5th

% \begin{algorithm}[ht]
% 	\caption{approximate plane curve from projection}
%  \label{algo:projection_approx}
% \begin{algorithmic}[1]
% \Require  
% \begin{itemize}
%     \item A regular curve defined by $n-1$ equations $C=(c_1,\dots, c_{n-1})$ in $\mathbb{R}^n$,
%     \item A tubular neighborhood $\cA(C)$ obtained by Algorithm \ref{algo:certified_curve_tracking}
%     \item A generic projection $\pi: \RR^n \to \RR^2$
% \end{itemize}
% \Ensure 
% \begin{itemize}
%     \item a refined $\cA(C)$ such that $\pi(\cA(C))$ is a tubular neighborhood of $\pi(C)$
% \end{itemize}
% \State{Initialize queue $Q$ containing all pairs of intersecting interval tubes $\{ I, J\}$ where $I, J \in \pi(\cA(C))$}
% \While{$Q$ is not empty}
% \State{pop pair $\{ I, J \}$ from $Q$} 
% \If{$T_0(I, J) = \false$}
% \State{refine $I$ and $J$ \textcolor{blue}{and every box in between?}}
% \State{update $Q$}
% \ElsIf{$I$ and $J$ fail the strip test}
% \State{refine all interval tubes contained in both strips}
% \State{update $Q$}
% \Else{}
% \State{accept $\{ I, J \}$}
% \EndIf
% \EndWhile
% \State{Return accepted regions.}
% \end{algorithmic}
% \end{algorithm}

We observe that if Algorithm~\ref{algo:strip_test} returns \true, then the curve must have a self-intersection, as described above.  In addition, if there were multiple intersections in $R_1\cap R_2$, then \cite[Lemma 3.1]{Byrd:2023} would imply that at the extreme point, i.e., when the curves are farthest apart, their tangent vectors would point in the same (or opposite) directions.  This is prevented by Line 21 of Algorithm~\ref{algo:strip_test}.  This implies that success of Algorithm~\ref{algo:strip_test} implies that there is exactly one intersection in $R_1\cap R_2$.  We now prove that after sufficient refinements both intersections and non-intersections can be detected, see Figure \ref{fig:two_projections}.

\begin{lemma}
    Let $C$ in $\RR^n$ be a regular curve and $\pi: \RR^n \to \RR^2$ a generic projection. Let $\cA(C)$ be the tubular neighborhood of $C$ constructed with Algorithm \ref{algo:certified_curve_tracking}. For every self-intersection of $\pi(C),$ there exists a pair of interval regions $I_1$ and $I_2$ such that Algorithm \ref{algo:strip_test} returns $\true$ after sufficient refinement.
\end{lemma}
\begin{proof}
Let $I_1$ and $I_2$ be the two interval regions such that there is a point $p_i\in I_i$ such that both $p_i$'s project to the same point.  When $I_1$ and $I_2$ are sufficiently small, $v_1$ and $v_2$ are approximately the tangent vectors of the projected curve at the intersection point.  Since all self-intersections are transversal, the tangent vectors at the intersection are not parallel, so, after sufficient refinement, $v_1$ and $v_2$ cannot be parallel either.

Since after sufficient refinement, the vectors $v_1$ and $v_2$ approach the tangent vectors of the projected self-intersection, the angles of the sides of $R_1$ and $R_2$ become stable, so the aspect ratio of each $R_i$ becomes nearly fixed.  Observe that any curve can be described locally by $p_0+tv_0+O(t^2)$.  For each branch at the self-intersection point $p\rightarrow p_0$ and, for some $i$, $v_i\rightarrow v_0$.  Finally, since the size of $R_i$ also gets smaller with refinement, the error in the curve is eventually small enough so that it passes through the ends of $R_i$ of length $2r$.  This implies that after sufficient refinement, $(F_i,L_i)$ cannot intersect the lateral sides of $R_i$.

Finally, by the same argument as above, after sufficient refinement, the tangent vector to the projected curve is nearly constant.  In addition, the calculated numerical kernels are also almost constant.  Therefore, after sufficient refinement, the tangent vectors are all pointing in almost the same direction, so the half-space tangent vector condition must hold.  Since the tangent vectors at the projected self-intersection are not parallel, this also implies that after sufficient refinement, the projected numerical kernels cannot contain parallel vectors.  

Therefore, after sufficient refinement, the IntersectionCheck algorithm returns \true.
\end{proof}



%In order to prove the correctness of Algorithm \ref{algo:certified_plane_curve}, we 


%provide the following lemmas.

%\begin{lemma}
%    Let $C$ in $\RR^n$ be a regular curve and $\pi: \RR^n \to \RR^2$ a generic projection. Let $\cA(C)$ be the tubular neighborhood of $C$ constructed with Algorithm \ref{algo:certified_curve_tracking}. For every self-intersection of $\pi(C),$ there exists a pair of intersecting interval tubes $\pi(I)$ and $\pi(J)$ in $\pi(\cA(C))$ such that Algorithm \ref{algo:strip_test} returns $\true$ after sufficient refinement.
%\end{lemma}

%\begin{proof}
    % Sketch
    % \begin{itemize}
    %     \item Start with the intersection point.
    %     \item Determine the smaller angle of tangent vectors at the intersection point
    %     \item Choose some distance $d$ for the length of the tubes in the direction of the tangents.
    %     \item Determine the radius of the tubes such that the ends of the tube do not intersect. This will depend on the angle of the tangents at intersection and the length of the tubes.
    % \end{itemize}
 %   Let $p$ be the point where $\pi(C)$ self intersections and define $p_I := \pi^{-1}(p) \in I$ and $p_J := \pi^{-1}(p) \in J.$ Construct straight tubes $T_I$ and $T_J$ directed and centered with the tangent of $C$ at $p_I$ and $p_J,$ respectively. Extend both $T_I$ and $T_J$ a distance of $d$ in both directions from $p_I$ and $p_J.$ Then, the radius of $T_I$ and $T_J$ is $\frac{d}{2}\tan\left(\frac{\theta}{2}\right),$ where $\theta$ is the angle between the two tangents of $\pi(C)$ at $p.$ As long as the interval tubes of $\pi(C)$ intersect the sides of $\pi(T_I)$ or $\pi(T_J),$ further refinement is required. To show that this process will terminate, we first show that there exists small enough tubes $T_I$ and $T_J$ such that $\pi(C)$ exits each through the ends. For small $d,$ we have that the curvature of $\pi(C)$ is approximately $O\left(d^2\right), $ therefore there exists $\tilde{d} > 0$ such that $T_I$ and $T_J$ have length $2\tilde{d}$ and radius $\frac{\tilde{d}}{2}\tan\left(\frac{\theta}{2}\right)$ and $\pi(C)$ exits $\pi(T_I)$ and $\pi(T_J)$ through the ends. It remains to show that the interval tubes approximating $\pi(C)$ do not intersect the sides of $\pi(T_I)$ or $\pi(T_J).$ Since $\pi(C)$ does not intersect the sides of $\pi(T_I)$ or $\pi(T_J),$ there is some positive $\tilde{r}$ that is the minimum distance from $\pi(C)$ to the sides of $\pi(T_I)$ and $\pi(T_J).$ Therefore, we can refine the interval tubes approximating $C$ within $T_I$ and $T_J$ such that the ``radius'' of each interval tube is less than $\tilde{r}$ after a finite number of steps.

    % \textcolor{blue}{Locally, a curve is of the form $p+tv+O(t^2)$.  Therefore, if the tube length is $\epsilon$, then the curve bends away from the midline by $O(\epsilon^2)$. If the side lengths of the tube are proportional, then the width of the tube is $O(\epsilon)$.  When epsilon is small, the curve must stay within the tube.}
%\end{proof} 

\begin{lemma}
    Let $C$ in $\RR^n$ be a regular curve and $\pi: \RR^n \to \RR^2$ a generic projection. Let $\cA(C)$ be a tubular neighborhood of $C$ constructed with Algorithm \ref{algo:certified_curve_tracking}.  If for two interval regions $I_1$ and $I_2$, $\pi(I_1)$ and $\pi(I_2)$ intersect but their curves do not correspond to a self-intersection, then this is detected after sufficient refinement.
\end{lemma}
    
%    do not correspond to a self-intersection, then 
    
    
%    If $T_0(I, J) = \false$ and $\pi(I)$ and $\pi(J)$ do not correspond to a self-intersection of $\pi(C),$ then $\pi(I) \cap \pi(C)$ and $\pi(J) \cap \pi(C)$ will be separated after sufficient refinement.
%\end{lemma}

\begin{proof}
    If there is a nonzero minimum distance between the images of the curves from $I_0$ and $I_1$, then once refinements of $I_0$ and $I_1$ have sufficiently small diameter, their projections will also have small diameter, and they cannot intersect.

    On the other hand, if the minimum distance is zero, this means that $I_1$ and $I_2$ correspond to a single arc of the curve.  After sufficiently many refinements, this portion of the arc is so small that the tangent vector does not change much over the arc and the half-space tangent vector condition succeeds.  In either case, the lack of an intersection is detected.
\end{proof}

    % Sketch
    % \begin{itemize}
    %     \item By assumption, we have that the subset of the projected curve does not intersect in $\pi(I) \cap \pi(J)$
    %     \item Define $C_I := \pi(I) \cap \pi(C)$ and $C_J := \pi(J) \cap \pi(C)$.
    %     \item Since $C_I \cap C_J = \emptyset$ and we are working over a compact region, we have that there is some positive infimum distance $m$ between $C_I$ and $C_J$. $m := \inf \{ \lVert x - y \rVert : x \in C_I, y \in C_J \} > 0.$ 
    %     \item Ensure that all interval tubes that are a result of some number of refinements of $I$ and $J$ have ``radius'' smaller than $m/2$. 
    % \end{itemize}
    
%    Let $C_I := \pi(I) \cap \pi(C)$ and $C_J := \pi(J) \cap \pi(C).$ By assumption, we have that $C_I$ and $C_J$ do not intersect. Let $m = \inf \{ \lVert x - y \rVert : x \in C_I, y \in C_J \} > 0. $ It suffices to show that, after sufficient refinement, the distance between $C_I$ and the interval tubes containing $C_I$ is less than $m/2.$  We have for any interval tube $\tilde{I} \in \cA(C),$ \[d(C \cap \tilde{I}, \tilde{I}) := \sup_{x \in C \cap \tilde{I}} \inf_{a \in \partial \tilde{I}}\{ \lVert x - a\rVert \} \leq \rho \cdot r, \] where \textcolor{blue}{``explanation regarding $\rho$-approximations.''} Moreover, we have that $d(\pi(C \cap \tilde{I}), \pi(\tilde{I})) \leq d(C \cap \tilde{I}, \tilde{I}).$ Therefore,  every interval tube, $\tilde{I},$ containing $C_I$ can be refined such that $d(C_I, \tilde{I}) < \frac{m}{2}$ after finitely many steps. Similarly, we can show the same is true for $C_J.$ Therefore, we have that $\pi(I) \cap \pi(C)$ and $\pi(J) \cap \pi(C)$ can be separated after sufficient refinement.
%\end{proof}

Putting these lemmas together, we have the following theorem.

\begin{thm}
    Let $\pi:\mathbb{R}^n\rightarrow\mathbb{R}^2$ be a generic projection. For a regular curve $C$ in $\mathbb{R}^n$, Algorithm \ref{algo:certified_plane_curve} returns a tubular neighborhood $\mathcal{A}(C)$ of $C$ such that $\pi(\mathcal{A}(C))$ is a tubular neighborhood of $\pi(C)$. 
\end{thm}
\begin{proof}
We must only argue that in Algorithm \ref{algo:certified_plane_curve}, no intersection is detected twice.  To see this, suppose that an intersection is detected twice.  In this case, since the rectangles $R_i$ for each test of Algorithm \ref{algo:strip_test} separate the approximations and separate the arcs of the projected curves, the two pairs of boxes must be contained in each other's $R_i$'s, which is not possible by Line 13 of Algorithm \ref{algo:certified_plane_curve}.  
\end{proof}

\begin{thm}
    \Cref{algo:certified_plane_curve} terminates within finitely many iterations.
\end{thm}


% Let $C$ be a regular curve defined by $n-1$ equations $(c_1, \ldots, c_n)$ in $n$ dimensional space. We start by computing a tubular neighborhood $\mathcal{A}(C)$ using Algorithm NUMBER. Then, we consider the projection $\pi\left( \mathcal{A}\left( C \right) \right),$ where $\pi$ is a generic projection. Consider the following procedure. Let $\mathcal{Q}$ be a queue of all pairs $\left( \pi\left( \mathcal{A}_i \right), \pi\left( \mathcal{A}_j \right) \right)$ such that $\pi \left(\mathcal{A}_i\right) \subseteq \pi\left( \mathcal{A}\left( C \right) \right), i \neq j,$ and $\pi\left( \mathcal{A}_i \right) $ and $ \pi\left( \mathcal{A}_j \right)$ intersect. For each pair in $\mathcal{Q},$ such that $\pi\left( \mathcal{A}_i \right) $ and $ \pi\left( \mathcal{A}_j \right)$ intersect transversally, we have that the corresponding curves of \textcolor{blue}{to be continued...}

% We are not dealing with intersecting parts anymore - Byrd Feb 5th

% \begin{algorithm}[ht]
% 	\caption{removing non-transversal intersecting part}
%  \label{algo:remove_non_transversality}
% \begin{algorithmic}[1]
% \Require  
% \begin{itemize}
%     \item A regular curve defined by $n-1$ equations $C=(c_1,\dots, c_{n-1})$ in $\mathbb{R}^n$,
%     \item A non-transversally intersecting part $\{\mathcal{A}_1,\mathcal{A}_2\}$.
%     \item A constant $\tau\in (0,1/2]$.
% \end{itemize}
% \Ensure 
% \begin{itemize}
%     \item a refined $\mathcal{A}_1$ and $\mathcal{A}_2$ that are intersecting transversally, or disjoint.
% \end{itemize}

% \State{Enumerate  $\mathcal{A}_1=\{I_1,\dots, I_N\}$.}
% \For{$I\in \mathcal{A}_1$}
% \State{Define $\mathcal{I}:=\{J\in \mathcal{A}_2\mid I\cap J\ne \emptyset\}$.}
% \State{Compute the tangent vector $r'(I)=\begin{bmatrix}
%     A^{-1}(I)\mathbf{v}(I) \\
%     1
% \end{bmatrix}$ for $I$ and all $J\in \mathcal{I}$.}
% \While{$r'(I)$ is parallel to $r'(J)$ for some $J\in \mathcal{I}$}
% \State{Redefine $\tau=\frac{\tau}{2}$.}
% \State{Refine $I$ and $J$ with $\tau$.}
% \State{Whenever new interval tubes $\{I_{i_1},\dots, I_{i_k}\}$ created from refining $I$, redefine $\mathcal{A}_1:=\mathcal{A}_1\cup \{I_{i_1},\dots, I_{i_k}\}$.}
% \State{Whenever new interval tubes $\{J_{j_1},\dots, J_{j_k}\}$ created from refining $J$, redefine $\mathcal{A}_2:=\mathcal{A}_2\cup \{J_{j_1},\dots, J_{j_k}\}$.}
% \State{\color{blue} TODO: prove that refining boxes sufficiently removes parallel tubes.}
% \EndWhile
% \EndFor
% \State{Return $\mathcal{A}_1$ and $\mathcal{A}_2$.}
%  \end{algorithmic}
%  \end{algorithm}


\begin{algorithm}[ht]
	\caption{CertifiedPlaneCurve}
 \label{algo:certified_plane_curve}
\begin{algorithmic}[1]
\Require  
\begin{itemize}
    A regular curve $C=\{c_1,\dots,c_{n-1}\}\subset\mathbb{Q}[X_1,\dots,X_n]$,
    \item a point $x$ approximating a nonsingular point on the curve $C$,
    \item a positive number $r>0$ for the initial radius.
    \item a generic projection $\pi:\mathbb{R}^n\rightarrow \mathbb{R}^2$,
    \item a compact region $D$,
    \item constants $\rho\in(0,\frac{1}{2}]$ and $\tau\in(\frac{1}{2},1)$.
\end{itemize}
\Ensure 
\begin{itemize}
    \item a certified tubular neighborhood of a plane curve $\pi(C)$.
\end{itemize}

\State{Compute a tubular neighborhood $\mathcal{A}(C)$ of $C$ using Algorithm $\ref{algo:certified_curve_tracking}$ with $C, x, r, D$, $\tau$, and $\rho$.}
% \State{For a generic projection $\pi$ consider $\pi(\mathcal{A}(C))$}
% \State{Find all intersecting parts from $\pi(\mathcal{A}(C))$.}
\State{Initialize queue $Q$ containing all pairs of intersecting interval regions $\{ I_1,I_2\}$}
\While{$Q$ is not empty}
\State{Pop pair $\{ I_1, I_2\}$ from $Q$} 
\If{$I_1$ and $I_2$ satisfy the half-space tangent vector condition}
\State{Accept $I_1$ and $I_2$}
\State{Do not consider $I_1$ and $I_2$ or their children as a pair again.}
\ElsIf{Algorithm \ref{algo:strip_test} on $I_1$ and $I_2$ returns $\false$}
\State{Refine the interval regions as described in Algorithm \ref{algo:strip_test}.}
\State{Update $Q$ with all pairs of intersecting interval tubes}
\Else{}
\State{Accept $I_1$ and $I_2$}
\State{Discard all other pairs $J_1\subset R_1$ and $J_2\subset R_2$ in $Q$ where $R_1$ and $R_2$ are the regions computed in Algorithm \ref{algo:strip_test}.}
\EndIf
\EndWhile
\State{Return accepted regions.}
 \end{algorithmic}
 \end{algorithm}

 In addition, if we wish to create an approximation to the projection to the curve itself, we may take the projection of the curve constructed in $\mathbb{R}^n$, with care to remove all self-intersections except those indicated by Algorithm \ref{algo:strip_test}.

 \begin{remark}
If the curve $C$ is not closed and is given by a parametric curve $C=\gamma(t)$.  Then, we may turn this into an implicit system by increasing the dimension by $1$ and considering the system of polynomials $X_i-\gamma_i(T)$.  In this case, we are interested in projections that include the $T$-direction in their kernel.  If such a projection is generic, then Algorithm \ref{algo:certified_plane_curve} correctly approximates the projection, see Figure \ref{fig:PTOPO_example}.
 \end{remark}
