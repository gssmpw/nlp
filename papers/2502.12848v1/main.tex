\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

\usepackage[hyphens]{url}
\usepackage{hyperref}
\usepackage[hyphenbreaks]{breakurl}

\usepackage{booktabs}
\usepackage{multirow}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{graphicx}
\usepackage{amsthm}
\usepackage{url}
\usepackage{listings}
\usepackage{mathtools}
\usepackage[matrix,arrow,curve]{xy}
\usepackage{enumitem}
\usepackage{extarrows}
\usepackage{comment}
\usepackage{tikzsymbols}
\usepackage[utf8]{inputenc}
\usepackage{csquotes}
\usepackage{pbalance}
\usepackage{nowidow}

\newcommand*{\CAMERAREADY}{}%

\ifdefined\COLORDIFF
  \newcommand{\diff}[1]{{\color{cbred} #1}}
\else
  \newcommand{\diff}[1]{{#1}}
\fi



\usepackage{tikz}
\usetikzlibrary{positioning,shapes,arrows,calc,fit,arrows.meta}

\tikzset{
  invisible/.style={opacity=0},
  visible on/.style={alt={#1{}{invisible}}},
  alt/.code args={<#1>#2#3}{%
    \alt<#1>{\pgfkeysalso{#2}}{\pgfkeysalso{#3}} %
  },
}


\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb}
\usepackage{url}




\newtheorem{example}{Example}

\newtheorem{conjecture}{Conjecture}

\newtheorem{theorem}{Theorem}

\newtheorem{lemma}{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{proposition}
\newtheorem{proposition}{Proposition}
\usepackage[numbers,compress]{natbib}

\usepackage[capitalise]{cleveref}



\usepackage{strandstyle}

\newcommand{\myparagraph}[1]{\smallskip\subsubsection*{#1}}
\usepackage{zi4}            %
\usepackage{xcolor}
\usepackage{listings}
\usepackage{lstautogobble}  %
\usepackage{xspace}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{ltblue}{rgb}{0,0.4,0.4}
\definecolor{dkviolet}{rgb}{0.3,0,0.5}

\lstdefinelanguage{Coq}{
    mathescape=false,
    texcl=false,
    morekeywords=[1]{Section, Module, End, Require, Import, Export,
        Variable, Variables, Parameter, Parameters, Axiom, Hypothesis,
        Hypotheses, Notation, Local, Tactic, Reserved, Scope, Open, Close,
        Bind, Delimit, Definition, Let, Ltac, Fixpoint, CoFixpoint, Add,
        Morphism, Relation, Implicit, Arguments, Unset, Contextual,
        Strict, Prenex, Implicits, Inductive, CoInductive, Record,
        Structure, Canonical, Coercion, Context, Class, Global, Instance,
        Program, Infix, Theorem, Lemma, Corollary, Coro, llary, Proposition, Fact,
        Remark, Example, Proof, Goal, Save, Qed, Defined, Hint, Resolve,
        Rewrite, View, Search, Show, Print, Printing, All, Eval, Check,
        Projections, inside, outside, Def},
    morekeywords=[2]{forall, exists, exists2, fun, fix, cofix, struct,
        match, with, end, as, in, return, let, if, is, then, else, for, of,
        nosimpl, when},
    morekeywords=[3]{Type,Prop, Set, true, false, option},
    morekeywords=[4]{pose, set, move, case, elim, apply, clear, hnf,
        intro, intros, generalize, rename, pattern, after, destruct,
        induction, using, refine, inversion, injection, rewrite, congr,
        unlock, compute, ring, field, fourier, replace, fold, unfold,
        change, cutrewrite, simpl, have, suff, wlog, suffices, without,
        loss, nat_norm, assert, cut, trivial, revert, bool_congr, nat_congr,
        symmetry, transitivity, auto, split, left, right, autorewrite},
    morekeywords=[5]{by, done, exact, reflexivity, tauto, romega, omega,
        assumption, solve, contradiction, discriminate},
    morekeywords=[6]{do, last, first, try, idtac, repeat},
    morecomment=[s]{(*}{*)},
    showstringspaces=false,
    morestring=[b]",
    morestring=[d]‚Äô,
    tabsize=2,
    extendedchars=true,
    inputencoding=utf8,
    sensitive=true,
    breaklines=true,
    basicstyle=\small,
    captionpos=b,
    columns=[l]flexible,
    identifierstyle={\ttfamily\color{black}},
    keywordstyle=[1]{\ttfamily\color{dkviolet}},
    keywordstyle=[2]{\ttfamily\color{dkgreen}},
    keywordstyle=[3]{\ttfamily\color{ltblue}},
    keywordstyle=[5]{\ttfamily\color{dkred}},
    stringstyle=\ttfamily,
    commentstyle={\ttfamily\color{dkgreen}},
    keepspaces,
    xleftmargin=2mm,
    literate=
    {‚â∫}{{$\prec$}}1
    {Œ£}{{$\Sigma$}}1
    {‚Ñì}{{$\ell$}}1
    {Œ†}{{$\Pi$}}1
    {œÄ}{{$\pi$}}1
    {‚äñ}{{$\ominus$}}1
    {‚äï}{{$\oplus$}}1
    {ùî∏}{{$\mathbb{A}$}}1
    {‚ü®}{{$\langle$}}1
    {‚ü©}{{$\rangle$}}1
    {‚ãÖ}{{$\cdot$}}1
    {œï}{{$\phi$}}1
    {‚Ñú}{{$\mathcal{R}$}}1
    {‚ä¢}{{$\vdash$}}1
    {‚àà}{{$\in$}}1
    {‚äè}{{$\sqsubset$}}1
    {œÑ}{{$\tau$}}1
    {'}{{$^\prime$}}1
    {forall}{{$\forall$}}1
    {exists}{{$\exists$}}1
    {<-}{{$\leftarrow$}}1
    {=>+}{{$\Rightarrow^+$}}1
    {==}{{\code{==}}}1
    {->}{{$\rightarrow$}}1
    {<->}{{$\leftrightarrow$}}1
    {\#}{{\texttt{\#}}}1
    {\/\\}{{$\wedge$}}1
    {\\\/}{{$\vee$}}1
    {<>}{{$\neq$}}1
    {~}{{$\lnot$}}1
}[keywords,comments,strings]
\lstset{language=Coq}


\newcommand{\arxivonly}[1]{{}}

  \makeatletter
  \def\ps@IEEEtitlepagestyle{
    \def\@oddfoot{\mycopyrightnotice}
    \def\@evenfoot{}
  }

  \def\mycopyrightnotice{
    {\footnotesize
    \begin{minipage}{\textwidth}
    To appear at IEEE CSF'25, June 16-20, 2025, Santa Cruz, CA, USA.
    \copyright~2025 IEEE.
    Personal use of this material is permitted.
    Permission from IEEE must be obtained for all other uses, in any current or future media, including reprinting/republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or reuse of any copyrighted component of this work in other works.
    The definitive Version of Record is going to appear in the proceedings of the
    38th IEEE Computer Security Foundations Symposium (IEEE CSF'25), June 16-20, 2025, Santa Cruz, CA, USA.
    \end{minipage}
    }
  }


\begin{document}

\newcommand{\easystrands}{\texttt{StrandsRocq}}

\title{
  Strands Rocq:\\  %
  \huge Why is a Security Protocol Correct, Mechanically?
}

\ifdefined\CAMERAREADY
  \author{
      \IEEEauthorblockN{Matteo Busi}
      \IEEEauthorblockA{
      \textit{DAIS, Ca' Foscari University}\\
      Venice, Italy \\
      matteo.busi@unive.it}
  \and
      \IEEEauthorblockN{Riccardo Focardi}
      \IEEEauthorblockA{
      \textit{DAIS, Ca' Foscari University}\\
      Venice, Italy \\
      focardi@unive.it}
  \and
      \IEEEauthorblockN{Flaminia L. Luccio}
      \IEEEauthorblockA{
      \textit{DAIS, Ca' Foscari University}\\
      Venice, Italy \\
      luccio@unive.it}
  }
\else
  \author{Anonymous author(s)}
\fi

\maketitle

\newcommand{\enc}[2]{{\ensuremath {\langle #1 \rangle _{#2}}}}

\begin{abstract}
Strand spaces are a formal framework for symbolic protocol verification that allows for pen-and-paper proofs of security \cite{FHG98}. While extremely insightful, pen-and-paper proofs are error-prone, and it is hard to gain confidence on their correctness. To overcome this problem, we developed \easystrands, a full mechanization of the strand spaces in Coq (soon to be renamed Rocq). The mechanization was designed to be faithful to the original pen-and-paper development, and it was engineered to be modular and extensible. \easystrands{} incorporates new original proof techniques, a novel notion of maximal penetrator that enables protocol compositionality, and a set of Coq tactics tailored to the domain, facilitating proof automation and reuse, and simplifying the work of protocol analysts. To demonstrate the versatility of our approach, we modelled and analyzed a family of authentication protocols, drawing inspiration from ISO/IEC 9798-2 two-pass authentication, the classical Needham-Schroeder-Lowe protocol, as well as a recently-proposed static analysis for a key management API. The analyses in \easystrands{} confirmed the high degree of proof reuse, and enabled us to distill the minimal requirements for protocol security. Through mechanization, we identified and addressed several issues in the original proofs and we were able to significantly improve the precision of the static analysis for the key management API. Moreover, we were able to leverage the novel notion of maximal penetrator to provide a compositional proof of security for two simple authentication protocols.
\end{abstract}


\begin{IEEEkeywords}
Formal Methods, Strand Spaces, security protocols, Coq.
\end{IEEEkeywords}


\section{Introduction}
\input{sections/introduction}

\section{Background on Strand Spaces}\label{sec:background-new}
  \input{sections/background}

\section{Mechanizing Strand Spaces: \easystrands}\label{sec:running}
  \input{sections/isoprotocol}

\section{Case Studies}\label{sec:casestudies}
  \input{sections/casestudies}



\section{Summary of Analyzed Protocols}
\label{sec:summary}
\input{sections/appendix}

\section{Discussion and Conclusions}
  \input{sections/concl}

\section*{Acknowledgments}
We would like to thank the anonymous reviewers for their comments and suggestions, which greatly helped us in improving this paper.
This work is partially supported by projects ``SEcurity and RIghts In the CyberSpace - SERICS'' (PE00000014 - CUP H73C2200089001), ``Interconnected Nord-Est Innovation Ecoscheme - iNEST'' (ECS00000043 - CUP H43C22000540006), and PRIN/PNRR ``Automatic Modelling and \(\forall\)erification of Dedicated sEcUrity deviceS - AM\(\forall\)DEUS'' (P2022EPPHM - CUP H53D23008130001), all under the National Recovery and Resilience Plan (NRRP) funded by the European Union - NextGenerationEU.



\bibliographystyle{IEEEtranN}

\small{
\bibliography{biblio}
}






\end{document}
