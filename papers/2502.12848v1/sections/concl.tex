

In this paper we have described our efforts in mechanizing the strand spaces framework~\cite{FHG98} in Coq.
To assess the flexibility of the approach and the usability of the library and of the proofs we have analyzed a variety of examples: a basic authentication protocol and some of its variants, the classical Needham-Schroeder-Lowe authentication protocol, and a recent key management API equipped with a key management policy.

Wherever possible, our mechanization remains faithful to the original pen-and-paper development of strand spaces.
At the same time, we put a lot of engineering effort to make the code and the proofs reusable.
For that, we have made the framework modular and parametric in the terms and the penetrator.
Additionally, we have developed a number of strands-specific tactics whose goal is to make the life of the protocol's analyst easier by removing some of the burden of these kinds of proofs.
Indeed, the tactics automate a number of intermediate steps enabling, in some cases, easy proof reuse.
For instance, the proof of the NSL responder's nonce secrecy
 required just one hour of work using the initiator's nonce secrecy.
The mechanization
gives the freedom to experiment with protocols and their properties, while retaining the unique ability of strand spaces-based analyses to give interesting insights on the inner workings of protocols.
With our experiments, we uncovered
and fixed issues, discarded
redundant or unused requirements, and significantly improved previous results on the analysis of key management policies, making it possible to formally prove the security of the \emph{secure templates} policy from \cite{BCFS-ccs10} (\cref{sec:casestudies}).

\cref{tab:simpleauth,tab:nsl} in \cref{sec:summary}  summarize the premises for each security property across the analyzed protocol variants. These premises are essential for our security proofs and offer important insights into the assumptions required to make a security protocol correct. The strand spaces model highlights this aspect, and the use of Coq and the \easystrands{} library further clarifies the minimal and necessary nature of these assumptions, reinforcing the model's ability to accurately capture security requirements.
With the insights from these experiments we also developed a new proof technique which we call \emph{protected predicate} technique that, in certain situations, simplifies the proofs making some previously challenging cases trivial.


Another advantage of having this mechanized platform is that it opens up new and interesting avenues of research.
\ifdefined\COLORDIFF
    \color{cbred}
\else
\fi
For instance, an intriguing enhancement to our framework would be the inclusion of algebraic intruders. We believe they can be implemented using at least two approaches, which we briefly outline below.

Given an equational theory $E$ over a signature $\mathit{FS}$, the first approach requires implementing $E$ as a (terminating and confluent) rewriting system \lstinline{rew_E}, and allow penetrators to use \lstinline{rew_E} to manipulate terms containing symbols of $\mathit{FS}$.
More concretely, we first need to create an instance of \easystrands{} terms with support for function symbols in $\mathit{FS}$, then we can extend the penetrator as:
\begin{lstlisting}
Inductive penetrator_strand : Œ£ -> Prop := ...
| PT_Eqn : forall (g h : ùî∏) i, replace g h rew_E  -> penetrator_strand (i, [‚äñ g; ‚äï h]).
\end{lstlisting}
where \lstinline{replace g h rew_E} holds iff \lstinline{g} can be rewritten as \lstinline{h} under \lstinline{rew_E}.
This approach is inspired by that of Tamarin \cite{MSCB13}.

The second approach aligns  with the method used in DY*~\cite{DY}, where cryptographic primitives are modeled as functions that symbolically represent the actual primitives, e.g., \lstinline{dec (c, k) = (if c = enc (m, k) then m else Error)}.
With these definitions, the equational theory $E$ could be defined using Coq Setoids and used for terms in place of Leibniz equality.
This has the advantage to allow both honest parties and the intruder to transparently use the equational theory.
However, as observed by~\citet{DY}, this approach requires proving (at least) that $E$ is an equivalence relation respected by all functions, predicates, and protocol specifications which can be lengthy and tedious.
\ifdefined\COLORDIFF
    \color{black}
\else
\fi

Despite their age, strand spaces have been a catalyst for extensive research, leading to notable extensions that include authentication tests~\cite{guttman2000authentication}, process algebraic-style choice operators~\cite{YEMMS16},
 compositionality \cite{StrandComposition,StrandIndependence,StrandMixed}, and stateful protocols \cite{J12}.
Many of these advancements are crucial for enhancing the expressiveness and usability of the model.
Our plan is to enhance \easystrands{} by integrating these extensions, thereby enabling scalability to more realistic protocols.
Ultimately, this will help narrow the gap with state-of-the-art tools such as DY* \cite{DY}.
In terms of foundational research, an intriguing avenue involves closely examining the relationship between Paulson's inductive method \cite{Paulson94} and strand spaces. We plan to mechanize Paulson's method in Coq and conduct a comparative analysis to assess the relative merits of these two inductive methods.

Finally, we defined a maximal penetrator as the set of strands that do not violate sensitive cryptographic operations required for protocol security. This method is inspired by the approach in \cite{banaSymbolic} to achieve computational soundness and, to our knowledge, has not been explored in a purely symbolic context before. It allows for proving injective agreement without explicitly defining the Dolev-Yao attacker, which we showed to be \diff{strictly} subsumed by the maximal penetrator. Notably, this approach facilitates the composition of protocols proven secure under their respective maximal penetrators, provided they adhere to each other's constraints. We are currently extending this technique to protocols like NSL, where security relies on decryption capabilities.

