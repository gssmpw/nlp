In addition to the family of simple authentication protocols inspired by the ISO/IEC 9798-2 two-pass authentication protocol (\cref{sec:running}), we have applied \easystrands{} to two nontrivial case studies:
the classic Needham-Schoeder-Lowe protocol and its original flawed version (\cref{subsec:NSL}) \cite{lowe1995attack}, and a recently proposed solution for secure key management policies (\cref{subsec:KMP}) \cite{focardi2021secure}.
Due to space constraints we only briefly describe the highlights and refer the interested reader to the files respectively in \lstinline{Examples/nsl}, \lstinline{Examples/ns_original} and \lstinline{Examples/kmp}.

\subsection{Case Study 1: Needham-Schroeder-Lowe Protocol}\label{subsec:NSL}
The NSL protocol is a standard protocol that has been widely analyzed \cite{lowe1995attack}.
The protocol assumes that $A$ and $B$ know their respective public keys, $\mathit{PK} A$ and $\mathit{PK} B$:
\begin{align*}
    &A \rightarrow B: \langle N_a \cdot A \rangle_{\mathit{PK} B}\\
    &B \rightarrow A: \langle N_a \cdot N_b \cdot B \rangle_{\mathit{PK} A}\\
    &A \rightarrow B: \langle N_b \rangle_{\mathit{PK} B}
\end{align*}
This protocol can be used to mutually authenticate the \emph{initiator} $A$ and the \emph{responder} $B$, while allowing them to share two secret values (the nonces, $N_a$ and $N_b$) that can be used together to generate a shared session key.
Intuitively, the authentication guarantee arises from the fact that only $A$ and $B$ can decrypt the nonces using their private keys and send them back to each other. Meanwhile, cryptography ensures the secrecy of the fresh nonces. This protocol, along with its original flawed version (in which $B$ was absent in the second message), has been used in \cite{FHG98} to illustrate the strand spaces model.

\myparagraph{Results} We have successfully mechanized all the proofs in \cite{FHG98} spotting and fixing two problems, described below. We also applied our new \emph{protected predicate} proof technique from \cref{sec:newproofs} to simplify some proofs.

\myparagraph{First issue}
When proving Lemma 4.4 in \cite{FHG98}, Fabrega et al. consider the set
$T = \{ m \in C \mid m \prec_C n_2 \land g \cdot h \sqsubset \mathit{term} (m) \}$ (for some $n_2$, $g$, and $h$),
and they implicitly assume that $T$ is \emph{sign closed}, i.e., is such that for any pair of nodes $m, m'$ with the same unsigned term, it holds $m \in S$ iff $m' \in S$. However, this is not true when $m \prec_C n_2$ but $m' \not\prec_C n_2$. This means that the authors could not have applied Lemma 2.7 from~\cite{FHG98} that states that minimal elements of sign closed sets are always positive. Fortunately, the conclusion of this lemma still holds when weakening the requirements of being sign closed, and in \easystrands{} we have devised a general lemma to handle these cases uniformly and simply. In particular, we have a lemma similar to 2.7 from~\cite{FHG98} which only requires that for each negative node in a set there exists a preceding positive node that also belongs to the set (see \lstinline|Lemma minimal_is_positive_weak| in \lstinline|Common/Bundles.v|).

\myparagraph{Second issue}
Initiator's nonce secrecy is only sketched in \cite{FHG98}.
Reformulated in Coq, the first part of the initiator's nonce secrecy
\mbox{proposition
from~\cite{FHG98} would
be:}
\begin{lstlisting}
forall m, is_node_of m C -> $Na ⊏ uns_term m ->
    (⟨ $Na ⋅ $A ⟩_(PK B)) ⊏ uns_term m \/
      (⟨ $Na ⋅ $Nb ⋅ $B ⟩_(PK A)) ⊏ uns_term m.
\end{lstlisting}
Intuitively, whenever \Na appears in a node, one of the two above ciphertexts should also appear in the node.
Unfortunately, this proposition fails in (at least) two cases:
$(i)$ consider a node \lstinline{m} that lies on an \emph{initiator} strand with parameters \lstinline{A}, \lstinline{B}, \lstinline{Na}, and \lstinline{Na}.
Then, the third message \lstinline{⟨ $Na ⟩_(PK B)} contradicts the proposition;
$(ii)$ consider \lstinline{m} lying on a \emph{responder} strand with parameters \lstinline{A}, \lstinline{B}, \lstinline{Na}, and \lstinline{Nb' <> Nb}.
Here, the second message \lstinline{$Na ⊏ ⟨ $Na ⋅ $Nb' ⋅ $B ⟩_(PK A)} contradicts the proposition.
To solve this issue and prove the initiator's nonce secrecy, we weakened the theorem just enough by accounting for the missing case \lstinline{(⟨ $Na ⟩_(PK B)) ⊏ uns_term m}, and by letting \lstinline|Nb| free in \lstinline|⟨ $Na ⋅ $Nb ⋅ $B ⟩_(PK A)| 
(full proof in \lstinline{Examples/nsl/NSL_secrecy_initiator_simple.v}).

\subsection{Case Study 2: Key Management Policies}\label{subsec:KMP}
Key management encompasses the practices involved in generating, distributing, storing, and revoking cryptographic keys. To ensure security, keys are commonly stored in tamper-resistant hardware like Hardware Security Modules (HSMs) and accessed through suitable APIs, such as \texttt{PKCS\#11}.
Unfortunately, incorrect key management or overly liberal APIs, which do not allow to provide a policy that precisely determines the intended use of a certain class of keys, may hinder the security of the stored keys ~\cite{anderson00correctness,clulow03pkcs11}.
Among others~\cite{CentenaroFL13,KunPOST15}, Focardi and Luccio \cite{focardi2021secure} proposed security solutions based on {typed key management policies}.
The idea is to dynamically keep track of key types by encrypting a key and its type under a device master key. The policy dictates which key can wrap/unwrap which other key based on the respective types.

The proof in \cite{focardi2021secure} is developed in strand spaces and, due to the overapproximation result, we claim that such general soundness result would be hard if not impossible to achieve using state-of-the-art fully automated tools.
Preliminary tests with Tamarin allowed us to prove the security of specific policies, disregarding the overapproximation part.
Scalability became an issue as the policy size increased,  since the tool had to traverse all policy states for the analysis.

\myparagraph{Results} We fully mechanized the soundness theorem of \cite{focardi2021secure} and uncovered an ambiguous usage of the proof technique in the pen-and-paper development and a redundant case in the original notion of policy closure that we simplified. We improved the precision of the analysis by providing a more accurate closure operation, which allowed us to prove the security of the \emph{secure templates} example \cite{BCFS-ccs10}, previously rejected by the analysis in \cite{focardi2021secure}.

\myparagraph{First issue} The security theorem presented in \cite{focardi2021secure}
is a soundness result.
It establishes that the policy closure overapproximates the key types at runtime and at all bundle nodes.
Focardi and Luccio achieve this by considering the dual set of nodes violating the properties and demonstrating its emptiness through an inductive examination of all possible strands. During our analysis, we found that in the pen-and-paper development, the definition of this set did not encompass all possible cases for subterms. To address this, we employed our novel \emph{protected predicate} proof technique, which centers around the \lstinline|protected| predicate as outlined in \cref{sec:newproofs}. This approach inherently covers all subterms by construction and simplify the treatment of pair terms, especially in penetrator strands.

\myparagraph{Second issue}
While developing the proof mechanization we realized that one of the condition in the policy closure (item 5 in Definition 6 of \cite{focardi2021secure}) dealing with decryption operations was never
used in the proof and could be safely removed (see below for more detail).

\myparagraph{Improving the analysis precision}
While mechanizing  the proof by~\citet{focardi2021secure} we realized that the closure operation could be made more precise, simpler and more intuitive.
In the following we briefly present our improved closure operation and show that it is more precise than the original one by validating a particular policy, proposed in \cite{BCFS-ccs10}, that was rejected by the original analysis.

We need to provide more details about the model presented in \cite{focardi2021secure}.
When a key is created, a type is assigned to it and encrypted along with the key under a secret master key $\mkey$ to enforce the policy at execution time.
For example, key $k_1$ of type $\ckey_1$ is  modeled as $\enc{k_1,\ckey_1}{\mkey}$.
Keys can be used to encrypt and decrypt other keys to securely export them out of the device and possibly import them into another one.
These two operations are usually referred to as \emph{wrap} and \emph{unwrap}.
When a key is unwrapped any type admitted by the policy is assigned to the unwrapped key, making it possible to have multiple types for the same key.
This is modeled by creating another ciphertext with the new assigned type, e.g., $\enc{k_1,\ckey_2}{\mkey}$.

A key management policy is specified as a set of directives $\policyold{\ckey_1}{\lenc}{\ckey_2}$ and $\policyold{\ckey_1}{\ldec}{\ckey_2}$ respectively indicating that keys of type $\ckey_1$ can encrypt keys of type $\ckey_2$, and keys of type $\ckey_1$ can decrypt wrapped keys and assign them type $\ckey_2$.
We also let $D$ denote the type for generic data so $\policyold{\ckey_1}{\lenc}{D}$ and $\policyold{\ckey_1}{\ldec}{D}$ indicate that keys of type $\ckey_1$ can perform standard encryption and decryption operations on messages.
Let $\termDKey$ denote the keys originated in the device,
then the key management API strands have the following form:
\begin{description}[leftmargin=6em,style=nextline]
\item [~~\rm Create:] \strand{+\enc{k,\ckey}{\mkey}} with $k \in \termDKey$ uniquely originating
\item [~~\rm Encrypt:] \strand{-m,~ {-\enc{k,\ckey}{\mkey}},~ {+\enc{m}{k}}} if $\policyold{\ckey}{\lenc}{D}$
\item [~~\rm Decrypt:] \strand{-\enc{m}{k},~ {-\enc{k,\ckey}{\mkey}},~ {+m}} if $\policyold{\ckey}{\ldec}{D}$
\item [~~\rm Wrap:] \strand{-\enc{k_1,\ckey_1}{\mkey},~ {-\enc{k_2,\ckey_2}{\mkey}},~ {+\enc{k_1}{k_2}}} if $\policyold{\ckey_2}{\lenc}{\ckey_1}$
\item [~~\rm Unwrap:] \strand{-\enc{k_1}{k_2},~ {-\enc{k_2,\ckey_2}{\mkey}},~ {+\enc{k_1,\ckey_1}{\mkey}}} if $\policyold{\ckey_2}{\ldec}{\ckey_1}$
\end{description}
Intuitively, Create generates a new device key of type $K$, Encrypt and Decrypt perform standard encrypt and decrypt operations on messages if the policy enables them, Wrap and Unwrap model key management operations in which a key encrypts/decrypts other keys along the policy directives.

A {closure operation} applied to the key management policy yields an overapproximation of the types that a particular key may assume during runtime, and a security theorem establishes the soundness of this overapproximation, ensuring that keys never assuming the insecure \emph{Data} type $D$ are guaranteed to remain undisclosed. The set of types that are \emph{reachable} from an initial type $\ckey$ is noted $\R_\ckey$. To compute this set, a new policy denoted by $\Rightarrow$ is defined, extending $\rightarrow$ to overapproximate all possible key types that can be reached when executing the key management APIs.

The original closure of \cite{focardi2021secure} defines $\Rightarrow$ as the smallest relation such that:
\begin{enumerate}
    \item $\policy{\ckey}{l}{\cdkey}$ implies $\policyC{\ckey}{l}{\cdkey}$;
      \label{item1}
    \item $\ckey \in \R_\ckey$;
      \label{item2}
    \item $\policyC{D}{l}{D}$;
      \label{item2bis}
    \item $\policyC{\ckey}{\lenc}{\cdkey}$ and $\policyC{\ckey}{\ldec}{\czkey}$ implies $\czkey \in \R_\cdkey$;
      \label{item3}
      \item $\policyold{\ckey}{\ldec}{\cdkey}$ and $\ckey \in \R_\czkey$ implies $\policyC{\czkey}{\ldec}{\cdkey}$
     \label{item3bis}
  \item $\policyC{\ckey}{\lenc}{\cdkey}$ and ($\ckey \in \R_\czkey$ or $\czkey \in \R_\ckey$) implies $\policyC{\czkey}{\lenc}{\cdkey}$
       \label{item5}
  \item $\policyC{\cdkey}{\lenc}{\ckey}$ and ($\ckey \in \R_\czkey$ or $\czkey \in \R_\ckey$) implies $\policyC{\cdkey}{\lenc}{\czkey}$
       \label{item6}
  \end{enumerate}
Intuitively,  whatever is allowed by $\rightarrow$ is also allowed by $\Rightarrow$ (item \ref{item1}); a type $\ckey$ is always reachable by itself (item \ref{item2}); $D$ can perform any operation over  $D$, in order to account for penetrator's behaviour (item \ref{item2bis}); if a type $\ckey$ can acquire the capability of wrapping $\cdkey$ and then decrypt it as $\czkey$, then $\czkey$ should belong to the types $\R_\cdkey$ that are reachable from $\cdkey$ (item \ref{item3}). Item \ref{item3bis} propagates decryption capability from $K$ to $J$ if $K$ is reachable from $J$. Similarily, items \ref{item5} and \ref{item6} propagate encryption capabilities bidirectionally.

Developing our mechanized proof we first realized that item \ref{item3bis} was unnecessary, as discussed above, and we removed it.
Moreover,
while this closure can be proved to soundly approximate the propagation of key types and so it is enough for security, the last two items look overly conservative and not very intuitive.
We then devised a more accurate closure which replaces original rules from \ref{item3bis} to \ref{item6} with the following:
\begin{enumerate}
    \setcounter{enumi}{4}
\item $\policyC{\ckey}{\lenc}{\cdkey}$ and $\ckey \in \R_\czkey$ and $\cdkey \in \R_\cwkey$ implies $\policyC{\czkey}{\lenc}{\cwkey}$
     \label{item5b}
\item \vspace*{-.2cm}$\policyC{\ckey}{\ldec}{\cdkey}$ and $\ckey \in \R_\czkey$ implies $\policyC{\czkey}{\ldec}{\cdkey}$
     \label{item6b}
\end{enumerate}
Intuitively, when $K$ and $J$ can be reached by $Z$ and $W$, the encryption capabilities between $K$ and $J$ are inherited by $Z$ and $W$ (item \ref{item5b}).
Similarly, for decryption, the capability to decrypt to a type $J$ is inherited from $K$ by $Z$ if $K$ is reachable from $Z$ (item \ref{item6b}).
These two rules model more accurately the fact that encryption and decryption capabilities are acquired when a certain type $K$ is reached by another type $Z$.
\begin{figure}[t]
    \centering
    \begin{tikzpicture}[node distance=10mm and 20mm, main/.style = {semithick, inner sep=0, draw, circle,minimum width =0.7cm}]
    \node[main] (1) {$\ckey_1$};
    \node[main] (2) [below= of 1]{$\ckey_2$};
    \node[main] (3) [below= of 2]{$\ckey_3$};
    \node[main] (4) [right= of 2]{$D$};
    \path (1) edge [semithick, loop above, ->]  node[midway, above] {\lenc} (1);
    \path (1) edge [semithick, ->]  node[midway, right] {\lenc/\ldec} (2);
    \path (3) edge [semithick, bend right, ->]  node[midway, right] {\lenc/\ldec} (4);
    \draw[->] (1) [semithick, bend right, ->] to[in=225]++ (-2,-2) to[out=315]  node[at start, left] {\lenc} (3);
    \draw[semithick, ->] (2) -- node[midway, above] {\lenc} (4);
    \path (2) edge [semithick, loop left, ->]  node[midway, left] {\ldec} (2);
    \end{tikzpicture}
  \caption{Secure templates of \cite{BCFS-ccs10} as specified in \cite{focardi2021secure}.}
  \label{fig:templates}
\end{figure}

By largely reusing the mechanization of the original proof, we were able to demonstrate that this closure is also sound.
We applied it to all the examples in \cite{focardi2021secure}, reproducing all the results and additionally proving the security of the \emph{secure templates} policy shown in~\cref{fig:templates}.
Intuitively, this policy has a unique type for unwrapped keys ($\ckey_2$) that prevent conflicting roles.
Keys can be generated either as wrap/unwrap keys ($\ckey_1$) or as encrypt/decrypt keys ($\ckey_3$).
When unwrap happens, the imported key assumes type $\ckey_2$ which is only allowed to unwrap and encrypt. The rationale is that unwrap and encrypt operations do not conflict with the initial key roles.

The refined closure provides the following reachable types:
\begin{eqnarray*}
    \R_{\ckey_1} & = & \{ \ckey_1, \ckey_2 \} \\
    \R_{\ckey_2} & = & \{ \ckey_2 \} \\
    \R_{\ckey_3} & = & \{ \ckey_2, \ckey_3 \} \\
    \R_{\ckey_D} & = & \{ \ckey_2, D \}
\end{eqnarray*}
This confirms the intuition that from each type, it is possible to reach only the unwrapped key $\ckey_2$ and nothing else. In turn, this proves the confidentiality of key types $\ckey_1$, $\ckey_2$, and $\ckey_3$, since $D$, the insecure \emph{Data} type, does not appear in their reachable sets. Consequently, values of keys with those initial types will never appear as plaintext. In \cite{focardi2021secure}, instead, it is shown that the original closure computes reachable sets that all contain $D$, making it impossible to draw any conclusions about key confidentiality for this particular policy.
To the best of our knowledge, this is the first proof of security of the \emph{secure templates} policy from \cite{BCFS-ccs10}.

