In this section, we review the primary components of strand spaces from \cite{FHG98}.

\myparagraph{Strands and terms} Intuitively, a \emph{strand} is an ordered sequence of events, denoting the activity of either a legitimate participant in a security protocol or a series of actions performed by an intruder.
 The events consist of a term $t \in \terms$ being
 transmitted $+t$  or received $-t$.
 The set of all possible signed terms is denoted $\pm \terms$, and a finite sequence of such events is called a {\em strand}, denoted $s$, and is an element of $(\pm \terms)^*$.
 A collection of strands is called a \emph{strand space}, and it includes strands of the legitimate participants and strands of the penetrator.


We let $\T$ be a set of atomic messages (texts), and $\termKey$ be a set of cryptographic keys, disjoint from $\T$, equipped with a function $\inv: \termKey \rightarrow \termKey$, providing the inverse of a given key. The function $\inv$ associates each element of a key pair in an asymmetric cryptosystem with its counterpart, and it associates a symmetric key with itself. We write $k^{-1}$ to denote $\inv(k)$. Then, we write $\enc{g}{k}$ to denote term $g$ encrypted under key $k$ and  $g \cdot h$ to denote the concatenation of terms $g$ and $h$.
Finally, we let \terms denote the set of all terms constructed by applying encryption and concatenation starting from $\T$ and $\termKey$. The subterm relation $\sqsubset$ is used to express that a certain term occurs into another one, and thus in the corresponding node.
Notice that, the subterm relation does not consider a cryptographic key $k$ in a ciphertext \enc{.}{k} as a subterm of the ciphertext, given that $k$ does not occur in the message payload but it is instead used to generate the ciphertext.

 \begin{example}[Simple authentication protocol]
  \label{ex:simpleprotocol}
  We consider a simple unilateral authentication protocol based on symmetric key cryptography and nonces, inspired from
  ISO/IEC 9798-2 two-pass authentication~\cite{ISO97982}:
  \begin{align*}
    A \rightarrow B & : A \cdot B \cdot N_a \\
    B \rightarrow A & : \enc{N_a \cdot A}{ \SK{AB}}
  \end{align*}
Intuitively, the protocol begins with Alice ($A$) initiating communication by sending the principal identifiers and a fresh nonce $N_a$ to Bob ($B$). Bob encrypts the nonce $N_a$ along with the identifier of $A$ using a  symmetric key $\SK{AB}$ shared between $A$ and $B$. Alice then verifies that the received message is indeed encrypted under the correct key and includes the nonce $N_a$ along with her identifier $A$. This confirmation is sufficient to convince her that she is communicating with Bob, a security guarantee referred to as \emph{unilateral authentication}.
Notice that, $A$ and $B$ in the initial message constitute Alice's initial claim regarding the protocol session. However, they lack security significance as they can be manipulated by the attacker. Consequently, the security of the protocol does not rely on them.


The protocol is formalized in the strand spaces model by specifying that
the initiator strands have the form
\[ \strand{ + A \cdot B \cdot N_a; - \enc{N_a \cdot A}{ \SK{AB}} } \]
while the responder strands have the form
\[ \strand{ - A \cdot B \cdot N_a; + \enc{N_a \cdot A}{ \SK{AB}} } \]
for all $A, B, N_a \in \T$.
\end{example}
\myparagraph{Nodes, bundles, and the penetrator}
A strand space has an associated graph in which nodes are assigned to events in a strand and are indexed by the event position. A node is, in fact, noted as a pair $\node{ s, i }$ representing the node association to the $i$-th event of the strand name $s$. The graph includes edges connecting output and input events related to the same message, as well as consecutive events on the same strand. In particular, every node $\node{ s, i }$ with an output event $+t$ is related to node $\node{ s', i' }$ with the corresponding input event $-t$ through the \emph{interstrand} relation $\node{ s, i } \rightarrow \node{ s', i' }$. Moreover, each node $\node{ s, i }$ is related to the next one $\node{ s, i+1 }$ in the same strand through the \emph{intrastrand} relation $\node{ s, i } \Rightarrow \node{ s, i+1 }$. We use $\term(n)$ to denote the event (i.e., the signed term) associated with node $n$.

\begin{figure}[t]
  $$\xymatrix@R=3mm@C=20mm{
  \node{s_i,0}\ar@{=>}[dd]\ar[r]^{A \cdot B \cdot N_a}&\node{s_r,0}\ar@{=>}[dd]\\ \\
  \node{s_i,1}&\node{s_r,1}\ar[l]_{\enc{N_a \cdot A}{ \SK{AB}}}\\
  }$$
  \caption{A bundle for the unilateral authentication protocol of \cref{ex:simpleprotocol}.}
  \label{fig:simpleprotocol}
\end{figure}

 Protocol runs are modeled by \emph{bundles}, which select events from the strand space and display their causal dependencies, establishing a partial order for events in the run.
 Bundles are finite and acyclic subgraphs of the strand space graph. Each event within a bundle requires all preceding events on the same strand, along with the corresponding edges indicating strand precedence. Every input event in the bundle is linked by a single incoming edge from an output event.




\begin{example}[Bundle]
  \label{ex:bundle}
Consider again the protocol of \cref{ex:simpleprotocol}.
A bundle for a given instance of $A, B$ and $N_a$ is depicted in \cref{fig:simpleprotocol}.
On the left, we see the two nodes \node{s_i,0}, \node{s_i,1} of the initiator strand $s_i$, and on the right, the two nodes \node{s_r,0}, \node{s_r,1} of the responder strand $s_r$ connected vertically by the intrastrand relation $\Rightarrow$. This represents the causal dependencies between the sequential events in each strand. Then, we see the interstrand relation $\rightarrow$ connecting outputs and inputs: the initiator sends the message $A \cdot B \cdot N_a$ to the responder, who answers with $\enc{N_a \cdot A}{ \SK{AB}}$. Notice, in particular, that the events, i.e., the signed terms, associated to the nodes are:
\[
  \begin{array}{lll}
\term(~\node{s_i,0}~) & = & + A \cdot B \cdot N_a\\
\term(~\node{s_i,1}~) & = & - \enc{N_a \cdot A}{ \SK{AB}} \\
\term(~\node{s_r,0}~) & = & - A \cdot B \cdot N_a\\
\term(~\node{s_r,1}~) & = & + \enc{N_a \cdot A}{ \SK{AB}}
  \end{array}
  \]
\end{example}
\smallskip
Penetrator strands model a standard Dolev-Yao attacker that  intercepts, duplicates, and manipulates messages, knows a subset $\KP$ of the keys $\termKey$, and encrypts and decrypts messages only when they know the appropriate key.
\begin{definition}[Penetrator \cite{FHG98}]
\label{def:penetrator}
Let $g, h, m \in \terms$ note generic terms, and $k \in \termKey$ a key.
A penetrator strand has one of the following forms:
\begin{description}[leftmargin=9.5em,style=nextline]
\item[~~\rm Text message] \strand{+t} with $t \in \T$
\item[~~\rm Flushing] \strand{-g}
\item[~~\rm Tee] \strand{-g;~ +g ;~ +g}
\item[~~\rm Concatenation] \strand{-g;~ {-h};~ {+g \cdot h}}
\item[~~\rm Separation] \strand{-g \cdot h;~ {+g};~ {+h}}
\item[~~\rm Key] \strand{+k} with $k \in \KP$
\item[~~\rm Encryption] \strand{-k;~ {-m};~ {+\enc{m}{k}}}
\item[~~\rm Decryption] \strand{-k^{-1};~ {-\enc{m}{k}};~ {+m}}
\end{description}
\end{definition}

\begin{figure}[t]
  $$\xymatrix@R=10mm@C=20mm{
  \node{s_i,0}\ar@{=>}[dd]\ar[rr]^{A \cdot B \cdot N_a} & & \node{s_r,0}\ar@{=>}[d]\\
   & \node{s_{\mathit{Tee}},0}\ar@{=>}[d] & \node{s_r,1}\ar[l]_{\enc{N_a \cdot A}{ \SK{AB}}}\\
  \node{s_i,1}  & \node{s_{\mathit{Tee}},1}\ar[l]_{\enc{N_a \cdot A}{ \SK{AB}}}\ar@{=>}@/^3pc/[dd] \\
  \node{s'_i,0}\ar@{=>}[d]\ar[r]^{A \cdot B \cdot N_a} & \node{s_{\mathit{Flushing}},0}\\
  \node{s'_i,1} & \node{s_{\mathit{Tee}},2}\ar[l]_{\enc{N_a \cdot A}{ \SK{AB}}}\\
  }$$
  \caption{A bundle representing a replay attack when there is no assumption on $N_a$ freshness. The attack is prevented by requiring that $N_a$ uniquely originates in \node{s_i,0}.}
  \label{fig:replay}
\end{figure}

\begin{example}[A replay attack]
  For the protocol of \cref{ex:simpleprotocol} we assume that $\SK{AB} \not\in \KP$ in order to prevent trivial attacks in which the penetrator knows $\SK{AB}$. However, this assumption is not enough: the protocol prevents replay attacks thanks to the freshness of the nonce $N_a$. We have not formalized this assumption yet, which means that the attack is possible, as illustrated in \cref{fig:replay}. There are two initiator strands $s_i$, $s'_i$ using the same nonce $N_a$. The penetrator intercepts the message $\enc{N_a \cdot A}{ \SK{AB}}$ from the responder and replays it twice thanks to the \emph{Tee} strand $s_{\mathit{Tee}}$. Before sending the second copy, the penetrator drops the first message $A \cdot B \cdot N_a$ from the second initiator $s'_i$ using a \emph{Flushing} strand $s_{\mathit{Flush}}$.

  Nonce freshness is formalized by requiring that $N_a$ \emph{uniquely originates} in node \node{s_i,0}. Intuitively, this means that if $N_a$ appears in a positive node of a strand and there is no preceding node in the same strand containing $N_a$, then such a node must be \node{s_i,0}. This condition makes the bundle of \cref{fig:replay} invalid since $N_a$ originates both on \node{s_i,0} and on \node{s'_i,0}. In fact, the freshness of $N_a$ is a necessary condition to prevent replay attacks on this particular protocol.
\end{example}



\myparagraph{Proving security}
Strand spaces can be used to formalize and prove various security properties. For example, unilateral authentication can be expressed as a standard
agreement statement~\cite{lowe1997hierarchy}: for any initiator strand $s_i$ with parameters $A, B, N_a$ in a given bundle, there exists a responder strand $s_r$ that agrees on $A, B, N_a$.
The proof technique introduced in \cite{FHG98} is elegant and effective and leverage the fact that given a bundle $C$ the reflexive and transitive closure of the two relations $\rightarrow$ and $\Rightarrow$ that are part of $C$ define a partial order $\preceq_C$. From this, it is possible to prove that any nonempty subset of $C$ has a $\preceq_C$-minimal element. This provides a powerful inductive principle that can be applied locally on each protocol and penetrator strand.

\begin{example}[Proof sketch for agreement]
  \label{ex:proofs}
  In order to prove agreement for the protocol of \cref{ex:simpleprotocol}, i.e., that a responder strand $s_r$ exists and it agrees on $A, B$ and $N_a$, we consider the set $S = \{ m \in  C : \enc{N_a \cdot A}{ \SK{AB}} \sqsubset term(m) \}$ for a given bundle $C$. We know that this set is nonempty because $term(~\node{s_i,1}~) = \enc{N_a \cdot A}{ \SK{AB}}$ and so $\node{s_i,1} \in S$. So, as discussed before, $S$ has a $\preceq_C$-minimal element.
  The intriguing observation now is that it is possible to prove that the minimal element must be \node{s_r,1} (see \cref{fig:simpleprotocol}), i.e., the last node of the responder strand $s_r$, thereby establishing the agreement result, by a purely local reasoning over strands.
  It is enough to examine each individual strand to demonstrate that  \enc{N_a \cdot A}{ \SK{AB}} cannot \emph{originate}, i.e., appear for the first time, in any of them, except precisely in \node{s_r,1}.

  For example, consider the {Concatenation} strand
  $ \strand{-g;~ {-h};~ {+g \cdot h}} $ of the penetrator. Minimal elements are always positive due to the fact that negative nodes in a bundle are always preceded, via $\rightarrow$ by a positive node with the same term.
  The only positive node has term ${g \cdot h}$. Suppose this is minimal in $S$. Then, $\enc{N_a \cdot A}{ \SK{AB}} \sqsubset {g \cdot h}$ which implies that either $\enc{N_a \cdot A}{ \SK{AB}} \sqsubset g$ or $\enc{N_a \cdot A}{ \SK{AB}} \sqsubset h$. In both cases we get a contradiction as respectively the first or the second node of the strand would belong to $S$, breaking the minimality assumption. A fully mechanized proof for this protocol will be presented in \cref{sec:proofprotocol}.
\end{example}
