
In this section,
we present \easystrands, a complete mechanization of strand spaces in Coq.
We briefly introduce the structure and engineering of the library (\cref{sec:library}). Then, we demonstrate the process of specifying and proving the correctness of the protocol presented in \cref{ex:simpleprotocol} through simple steps, illustrating the specification phase (\cref{sec:specification}), the underlying proof technique, its mechanization, and our novel proof automation techniques (\cref{sec:proofprotocol}) that allow for compact and reusable proofs (\cref{sec:reusing}).
Finally in \cref{sec:newproofs} we present a new proof technique that simplifies the one presented by Fabrega et al. \cite{FHG98}.
During this journey, we start with the basic authentication protocol from \cref{ex:simpleprotocol}, inspired by the ISO/IEC 9798-2 two-pass authentication protocol~\cite{ISO97982}, and successfully analyze five different variants, uncovering the minimal security assumptions for each of them.

\ifdefined\CAMERAREADY
  \myparagraph{Note for the readers} The complete mechanization and proofs are available online~\cite{strandsrocqcode}.
\else
  \myparagraph{Note for the reviewers} The complete mechanization and proofs are included as supplementary material with the submission.
\fi

\subsection{The \easystrands{} library}
\label{sec:library}
We organized the library into modules, separating the theory of strands based on abstract domains, as in the original paper (folder \lstinline|Common|), from an implementation that we believe is more convenient for verifying protocols.
Implementing the abstract domains is an important sanity check to remove all axioms and assumptions, ensuring that such assumptions are realistic (folder \lstinline|Instances|).
For example, concrete terms are part of \lstinline|Instances|, which makes the library very flexible if one wishes to model new cryptographic primitives: the entire \lstinline|Common| section remains unchanged, and it is only necessary to instantiate a specific \lstinline|Module Type|.
Unlike the abstract strand definition from~\cref{sec:background-new}, strands are instantiated here as \lstinline|Σ := nat * list sT|.
The natural number serves as a strand identifier and \lstinline|list sT| is a list of signed terms denoting the trace associated with the strand.
This choice is particularly convenient for protocol specification as it allows for specifying strands and their traces in a single place.
In the original paper, traces are bound to strands through a separate function \lstinline|tr|.
In our implementation we just have that \lstinline|tr s| is defined as \lstinline|snd s|, i.e., the second field of the strand instantiation.

\subsection{Modelling Protocols}
\label{sec:specification}

We define the roles in the protocol by inductively listing all the possible strands they can undertake.
This might seem overly intricate since, in most cases, honest principals follow a single execution trace that is quantified over parameters and payload values.
Nevertheless, in general, a principal could engage in more than one trace.
For instance, a penetrator may carry out various potential traces (\cref{sec:background-new}).
Additionally, when modeling key management APIs (\cref{subsec:KMP}), a single principal/device can implement various functionalities, each represented by a distinct trace.

Starting now, we directly present the notation employed in \easystrands, which deviates slightly from the mathematical notation used so far.
We use \lstinline{Na} to represent the nonce $N_a$, \lstinline{SK A B} to denote the key $\mathit{\SK{AB}}$, \lstinline{⟨ M ⟩_(K)} to indicate $\enc{M}{K}$, and \lstinline{⊕}, \lstinline{⊖} to respectively denote $+$ and $-$.
Since the type of \lstinline{A}, \lstinline{B} and \lstinline{Na} is \T, representing atomic terms, we respectively write \lstinline{$A}, \lstinline{$B} and \lstinline{$Na} to represent their values as general terms of type \terms.
For the protocol of \cref{ex:simpleprotocol},
the initiator strands are defined as follows:
\begin{lstlisting}
Inductive SA_initiator_strand (A B Na : T) : Σ -> Prop :=
  | SAS_Init : forall i,
      SA_initiator_strand A B Na
        (i, [ ⊕ $A ⋅ $B ⋅ $Na; ⊖ ⟨ $Na ⋅ $A ⟩_(SK A B) ]).
\end{lstlisting}
Dually, the responder strands have swapped inputs and outputs:
\begin{lstlisting}
Inductive SA_responder_strand (A B Na : T) : Σ -> Prop :=
  | SAS_Resp : forall i,
      SA_responder_strand A B Na
        (i, [ ⊖ $A ⋅ $B ⋅ $Na; ⊕ ⟨ $Na ⋅ $A ⟩_(SK A B) ]).
\end{lstlisting}
To analyze this protocol we will restrict ourselves to strands of three types: \lstinline{penetrator_strand} (defined along \cref{sec:background-new}), \lstinline{SA_initiator_strand}, or \lstinline{SA_responder_strand}:
\begin{lstlisting}
Inductive SA_StrandSpace (K__P : K -> Prop) : Σ -> Prop :=
  | SASS_Pen  : forall s,
    penetrator_strand K__P s -> SA_StrandSpace K__P s
  | SASS_Init : forall (A B Na : T) s,
    SA_initiator_strand A B Na s -> SA_StrandSpace K__P s
  | SASS_Resp : forall (A B Na : T) s,
    SA_responder_strand A B Na s -> SA_StrandSpace K__P s
\end{lstlisting}
where \lstinline|K__P| encodes the knowledge of the penetrator at the beginning of the execution.
For our purposes the following minimal definition suffices:
\begin{lstlisting}
Definition K__P_AB (A B : T) (k : K) := k <> SK A B.
\end{lstlisting}
Intuitively, we assume that the only key the penetrator should not know is the actual key used by the two honest parties.





\subsection{Proof Automation}
\label{sec:proofprotocol}

We have developed a Coq library and some tactics to efficiently implement case analysis over strands, searching for a minimal element over a given strand.
We illustrate their usage below.
From now on we assume to have two honest parties \lstinline|A| and \lstinline|B|, a nonce \lstinline|Na| and a bundle \lstinline|C| whose nodes belong to the protocol strands \lstinline|SA_StrandSpace (K__P_AB A B)| in which the attacker does not know the key \lstinline|SK A B|. Since we want to prove authentication for the initiator, we assume that \lstinline|C| contains an initiator strand \lstinline|s| with the appropriate parameters, i.e., \lstinline|SA_initiator_strand A B Na s|.
All of these variables and hypotheses are specified locally using Coq \lstinline|Variable| and \lstinline|Hypothesis| commands and make propositions and lemmas more succinct and readable.

We consider \emph{non-injective agreement} requiring that, under the above assumptions,
there exists a responder strand \lstinline{s'}, and the initiator and responder traces agree on parameters
\lstinline{A}, \lstinline{B} and \lstinline{Na}.
Formally,
\begin{lstlisting}
Proposition noninjective_agreement :
  exists s' : Σ,
    SA_responder_strand A B Na s' /\ is_strand_of s' C.
\end{lstlisting}





\noindent
As illustrated in \cref{ex:proofs},
the proof in the strand spaces model revolves around showing that only the responder, with parameters \lstinline{A}, \lstinline{B} and \lstinline{Na}, can generate the expected ciphertext \lstinline{c = (⟨ $Na ⋅ $A ⟩_(SK A B))}.
The proof
is based on lemma \texttt{\small exists\_minimal\_bundle} (see \lstinline{Common/Bundles.v}) stating that each nonempty subset of nodes has a minimal w.r.t.\ the $\preceq_C$ relation (\cref{sec:background-new}).

The proof inspects all possible kinds of strands for \lstinline{s}: penetrator, initiator and responder.
Doing this in Coq is tedious and requires repetitive proofs even for cases that are deemed as trivial in pen-and-paper proofs.
For this reason, \easystrands{} provides a characterization of the minimal element of set of nodes in terms of a logical proposition covering all the possible cases.
For example, for the first strand of the penetrator, which is the output of an atomic term \lstinline{t} written \lstinline{[⊕ $t]} we obtain the
proposition \lstinline{False \/ c = $t /\ True /\ index m = 0}
which is false since \lstinline{c} is a ciphertext and it cannot be that \lstinline{c = $t}.
Other cases are more complex, e.g., for pair generation \lstinline{[⊖ g; ⊖ h; ⊕ g ⋅ h]} we get
\begin{lstlisting}
((False \/ subterm c g /\ False /\ index m = 0) \/
~ subterm c g /\ subterm c h /\ False /\ index m = 1) \/
~ subterm c g /\ ~ subterm c h /\
(c = g ⋅ h \/ subterm c g \/ subterm c h) /\
True /\ index m = 2
\end{lstlisting}
that is less trivial to analyze manually.
Therefore, we have implemented a tactic called \lstinline{simplify_prop}, which recursively simplifies propositions, leveraging the decidability of underlying statements.
It also attempts to automatically prove straightforward
(in)equalities, such as \lstinline{c <> $t} in the first case of the penetrator.


When applied to the penetrator case, the \lstinline{simplify_prop} tactic eliminates seven out of eighth cases, leaving only the interesting one, i.e., the encryption case with trace
\begin{lstlisting}
[⊖ #(SK A B); ⊖ $Na ⋅ $A; ⊕ (⟨ $Na ⋅ $A ⟩_(SK A B))]
\end{lstlisting}
Intuitively, this refers to the case where the penetrator generates the ciphertext \lstinline{c}, which is used by \lstinline{A} to confirm the identity of \lstinline{B}.
We eliminate this case by exploiting the fact that the penetrator can never learn a secure symmetric key.
This can be proved using a general property regarding the penetrator,
which asserts that the key read in the first node of a penetrator's encryption strand, in this case \lstinline{SK A B}, cannot be equal to a key that is not initially known by the penetrator and does not originate on a honest participant strand.
The fact that \lstinline{SK A B} is not initially known by the attacker is a direct consequence of the definition of \lstinline{K__P_AB A B} as \lstinline|k <> SK A B|. Additionally, the fact that \lstinline{SK A B} is not generated by the honest participants is demonstrated through a simple lemma, which can be proved using the same proof automation technique in just 8 lines of Coq.
So, we conclude that it must be \lstinline{SK A B <> SK A B}, leading to a contradiction.

The initiator case is automatically resolved by the \lstinline{simplify_prop} tactic, while the responder case leaves us with two subcases, depending on whether \lstinline{A} and \lstinline{B} are equal or not.
Both cases are resolved easily, as they yield a valid binding for the protocol parameters.
Interestingly, thanks to our proof automation techniques, the whole proof of \lstinline|noninjective_agreement| amounts to about 60 lines, as is greatly reusable as we will se next.

We also prove that each responder session corresponds to a different initiator session, i.e., that authentication is \emph{injective} and cannot be reused in a replay attack.
\begin{lstlisting}
Proposition injectivity :
  uniquely_originates $Na ->
    forall U U' s',
      SA_initiator_traces U U' Na (tr s') -> s' = s.
\end{lstlisting}
Notice that this property only holds if \lstinline{Na} is freshly generated which, in the strand spaces model, is captured by the \lstinline{uniquely_originates} definition stating that \lstinline{Na} originates, i.e., appears for the first time, in a unique node in a given bundle.
Injective agreement follows as a corollary from \lstinline{noninjective_agreement} and \lstinline{injectivity} (see \lstinline{injective_agreement} in \lstinline{Examples/simple_auth/SimpleAuth.v}).
\subsection{Proof Reuse}\label{sec:reusing}
An important feature of protocol analysis tools is the ability to \emph{play} with protocol specifications by quickly exploring various protocol variants.
This process is useful and insightful, as it allows us to observe how modifying the protocol affects its security.
We have incorporated this feature into \easystrands{} through proof automation via Coq tactics that perform case analysis, and eliminate the easy cases, as illustrated in the previous section.
Even though this does not guarantee that proofs can be reused when a specification is modified, in practice, we have observed that it is often the case.
Below, we provide examples supporting this fact.
Moreover, we point out that the proofs for the protocol in \cref{sec:proofprotocol} were mostly reused for the proofs of the NSL protocol, which is entirely different and relies on an asymmetric key cryptosystem (\cref{subsec:NSL}).

\myparagraph{Replacing $A$ with $B$ in the ciphertext}
The role of $A$ in the second protocol message is crucial for the security of the protocol, as it clarifies the direction of the message.
This is attributed to our consideration of the symmetric key $\SK{AB}$ as \emph{bidirectional}, meaning it remains the same whether the protocol is run by $A$ with $B$ or by $B$ with $A$.
Without an identifier in the ciphertext, the protocol would be vulnerable to what is commonly known as a \emph{reflection attack}, which we will discuss in the next section.
Here, we demonstrate that using either $A$ or $B$ in the ciphertext achieves the same result, as both identifiers disambiguate the protocol's direction.
To this aim, we consider a variant where $B$ replaces $A$ in the second message:
\vspace*{-0.2cm}
\begin{align*}
  A \rightarrow B & : A \cdot B \cdot N_a \\
  B \rightarrow A & : \enc{N_a \cdot B}{ \SK{AB}}
\end{align*}
Interestingly, when we make this modification, the security proof of the original protocol remains valid for this variant: we just need to change the ciphertext \lstinline{c} from \lstinline{(⟨ $Na ⋅ $A ⟩_(SK A B))} to \lstinline{(⟨ $Na ⋅ $B ⟩_(SK A B))} and the name of one hypothesis in a single rewrite statement.
This can be attributed to our characterization of the minimal element of the set of nodes using a logical proposition that covers all possible cases, along with the utilization of the \lstinline{simplify_prop} tactic in our proof automation.
This tactic automatically resolves most cases, even if they differ for some terms.
The example can be found in \lstinline{Examples/simple_auth/SimpleAuthWithB.v}.

\myparagraph{A flawed version of the protocol}
If we remove both $A$ and $B$ identifiers from the ciphertext the protocol is subject to a well-known reflection attack.
\begin{align*}
  A \rightarrow B & : A \cdot B \cdot N_a \\
  B \rightarrow A & : \enc{N_a }{ \SK{AB}}
\end{align*}
In this case we can copy-paste the proof of the original protocol to check where and why it fails.
The problem arises in the responder case, which has the goal
\begin{lstlisting}
  SA_responder_strand A B Na [⊖ ($B ⋅ $A) ⋅ $Na; ⊕ c]
\end{lstlisting}
but in the hypotheses, we have
\begin{lstlisting}
  SA_responder_strand B A Na [⊖ ($B ⋅ $A) ⋅ $Na; ⊕ c]
\end{lstlisting}
with \lstinline{A} and \lstinline{B} swapped, indicating a (known) reflection attack where \lstinline{c} is generated by \lstinline{A} itself acting as the responder.
The proof can only be closed when \lstinline{A = B}.
In this particular case, \lstinline{A} is persuaded to communicate with itself, which holds true even if the attacker reflects messages between two distinct sessions.
This example can be found in \lstinline{Examples/simple_auth/SimpleAuthFlawed.v}.

\myparagraph{Relaxing the Term Typing}
A common strategy for aiding automated verification involves constraining term types. In our current example, for example, we assume that \Na belongs to the set \T of atomic terms. A notable advantage of strand spaces lies in the insightful nature of their proofs, allowing the addition of assumptions only when necessary. Consequently, it becomes feasible to establish minimal assumptions for protocol security. This, coupled with our proof automation enabling the reuse of proofs, facilitates experimentation with type relaxation over terms to identify missing assumptions when needed. We conducted such an experiment by relaxing the typing, considering \Na as a general term belonging to \terms, not necessarily atomic,
The first lemma that cannot be proven is the one stating that \lstinline{(SKA A B)} never originates on a honest participant strand. In other words, we cannot prove that honest participants do not leak the symmetric key.
In fact, it might be the case that \Nap, for a given initiator, contains \lstinline{#(SKA A B)} as a subterm.
Therefore, the first restriction we need is:
\begin{lstlisting}
forall U U', ~ #(SK U U') ⊏ Na'
\end{lstlisting}
Intuitively, we impose the requirement that a nonce does not covertly transport the secure key  \lstinline{(SKA A B)} as a subterm. Should this occur, the initial message of the initiator would originate such a key, potentially exposing it to the penetrator.

The second point where the proof for the original protocol fails is in the initiator case of the \lstinline{noninjective_agreement} proposition. At this stage of the proof, we aim to eliminate the possibility that an initiator with parameters \Ap, \Bp, \Nap originates the ciphertext \lstinline{⟨ Na ⋅ A ⟩_(SKA A B)}. Once again, this scenario could arise if this ciphertext is a subterm of \Ap, \Bp, or \Nap.
To address this, we require the following:
\begin{lstlisting}
forall N U U', ~ (⟨ N ⋅ $U ⟩_(SK U U')) ⊏ Na'
\end{lstlisting}
We conclude that the protocol remains secure even when nonces are general terms, as long as they do not covertly transport the secure key and the corresponding ciphertext, the two fundamental ingredients for the security of the protocol.
These conditions are included in the specification of the strands for honest participants.
For example for the initiator (and similarly for the responder):
\begin{lstlisting}
Inductive SA_initiator_strand (A B : T) (Na : 𝔸) :
  Σ -> Prop :=
  | SAS_Init : forall i,
    (forall U U', ~ #(SK U U') ⊏ Na) ->
    (forall N U U', ~ (⟨ N ⋅ $U ⟩_(SK U U')) ⊏ Na) ->
    SA_initiator_strand A B Na
      (i, [ ⊕ $A ⋅ $B ⋅ Na; ⊖ ⟨ Na ⋅ $A ⟩_(SK A B) ]).
\end{lstlisting}

The example can be found in \lstinline{Examples/simple_auth/SimpleAuthUntyped.v}.

\subsection{A New Proof Technique}\label{sec:newproofs}
All proofs are based on the minimality lemma that we described in \cref{sec:background-new} and \cref{ex:proofs}.
However, it is up to the analyst to specify the specific set whose minimal elements exhibit witnesses for certain strands, such as in agreement properties, or whose emptiness proves a particular property, as in secrecy proofs that we will examine next (\cref{subsec:KMP}).

\easystrands{} has allowed us to experiment with various approaches to improve the proof techniques of \cite{FHG98}.
To illustrate this, we consider the dual protocol of \cref{ex:simpleprotocol} in which Alice sends an encrypted nonce to Bob, who decrypts it and sends it back in the clear.
Here, authentication is testified by the unique ability of the responder to decrypt an encrypted random challenge, so there is no ciphertext proving the presence of the responder.
Instead, the fact that the nonce has been decrypted needs to be considered as proof of the presence of Bob. Even here, we need one of the identifiers in the ciphertext to prevent reflection attacks.
The protocol is:
\begin{align*}
  A \rightarrow B & : \enc{N_a \cdot A}{\SK{AB}} \\
  B \rightarrow A & : N_a
\end{align*}
We let \lstinline|c := ⟨ Na ⋅ A ⟩_(SK A B)| and we consider the set of nodes whose term \lstinline|t| satisfies the proposition \lstinline|P := $Na ⊏ t /\ ~ c ⊏ t|.
Intuitively, these nodes contain the nonce \Na but do not contain the ciphertext \lstinline|c|.
Thus, they are $\preceq_C$-preceded by the node where the decryption happens.
Therefore, the minimal element of such a set should identify the responder node that performs the decryption and effectively binds all the responder parameters to the expected values \A, \B, \Na.

This proof technique for encrypted challenges, while effective, has a limitation: to eliminate the penetrator strand that destructs pairs, we need to prove that neither the initiator nor the responder originate pairs \lstinline|g ⋅ h| such that \linebreak\lstinline{c ⊏ h} or \lstinline|c ⊏ g|.
This enables the elimination of the pair destruction case of the penetrator, mainly because the penetrator is the only one that might have generated the problematic pairs containing \lstinline|c| in one element and \Na in the other.
These cases are problematic in general because we could have instances such as \linebreak\lstinline|P g /\ c ⊏ h|, implying \lstinline|~P (g ⋅ h)|. This observation is also mentioned in the proof of the NSL protocol in \cite{FHG98}.

Even though in \easystrands{} we have devised a general lemma to handle these cases uniformly and simply, this property on pairs really depends on the protocol syntax and is unrelated to its security.
Protocols that violate this property cannot be proved secure using this technique.
To overcome this limitation, we have explored a new proof technique, which we call the \emph{protected predicate} technique, and we now illustrate with a variant of the above protocol:
\begin{align*}
  A \rightarrow B & : B \cdot \enc{N_a \cdot A}{\SK{AB}} \\
  B \rightarrow A & : N_a
\end{align*}
This protocol adds \B in the clear in the first message, breaking the requirement that a honest participant strand never originates pairs \lstinline|g ⋅ h| such that \lstinline{c ⊏ h} or \lstinline|c ⊏ g|.
Thus, to prove the security of this protocol we define the following predicate:

\begin{lstlisting}
Fixpoint protected a :=
  match a with
  | $t => t <> Na
  | #_ => True
  | ⟨g ⋅ h⟩_(k) =>
      (k = SK A B /\ g = $Na /\ h = $A) \/
      (protected g /\ protected h)
  | ⟨g⟩_(k) => protected g
  | g⋅h => protected g /\ protected h
  end.
\end{lstlisting}
Intuitively, the condition \lstinline|protected A B Na a| holds if and only if \Na appears in \lstinline|a| in the form \lstinline|⟨ Na ⋅ A ⟩_(SK A B)|, or if it does not appear in \lstinline|a| at all.
Now we consider the set of nodes whose terms do not satisfy this condition and use its minimal element to prove agreement.
In fact,
we can prove that the first node where \Na appears unprotected is the responder node that performs the decryption.

This notion is less demanding than the previous predicate \lstinline|$Na ⊏ t /\ ~c ⊏ t|.
For example, term \lstinline|t = Na ⋅ ⟨ Na ⋅ A ⟩_(SK A B)| does not satisfy \lstinline|$Na ⊏ t /\ ~c ⊏ t| as \lstinline|c ⊏ t|, but satisfies \lstinline|~protected A B Na t| since \Na appears in \lstinline|t| in a form different from \lstinline|c|.
It is easy to see that \lstinline|~protected A B Na g| or \lstinline{~protected A B Na h} imply \lstinline|~protected A B Na (g⋅h)|, which solves the pair destruction case of the penetrator without any extra lemma.
We have used this technique to prove the security of the above protocol, and we have also applied it to the NSL protocol (\cref{subsec:NSL}).

Interestingly, regardless of the proof technique used, it is necessary for this protocol to assume that \lstinline|Na| uniquely originates, even
for
noninjective agreement.
Without this assumption, the attacker could simply guess \lstinline|Na| and impersonate Bob.
In the initial protocol of \cref{sec:proofprotocol}, nonce freshness is only required for injective agreement.
This illustrates the elegance of strand spaces, enabling the distillation of the minimal requirements for security proofs.

The example with the original proof technique can be found in \lstinline{Examples/simple_auth/SimpleAuthDual.v} and the variant using the \lstinline|protected| predicate can be found in \lstinline{Examples/simple_auth/SimpleAuthDualBProtected.v}.

\subsection{Maximal Penetrators and Compositionality}\label{sec:maximal}
We have seen that proofs in \easystrands{} rely on case analysis of the various strands belonging to the penetrator and the honest participants.
The goal is to show that a certain subset of nodes is either empty, as it does not contain a minimal element (e.g., for secrecy), or that it admits a minimal element on a specific honest strand (e.g., for authentication).
For penetrator strands, we typically need to demonstrate that none of them admits a minimal element, thus proving that the penetrator cannot interfere with the desired security property.

While performing our many mechanized proofs, we realized that a more general and efficient way to specify the penetrator would be to take a dual approach.
Instead of listing all possible penetrator strands in the classic Dolev-Yao style, we could define the penetrator in terms of what they cannot do with respect to sensitive cryptographic operations.
In other words, penetrator strands would include all those that do not violate specific cryptographic constraints.
This idea resembles the intriguing approach proposed in \cite{banaSymbolic} to achieve computational soundness results, and, in fact, is commonly used in computational models of cryptography.
Here, we explore this concept in a purely symbolic setting, which, to the best of our knowledge, is novel and unexplored in the literature.

This approach, which we call the \emph{maximal penetrator}, offers several advantages.
First, it allows for proving security without the need to specify a Dolev-Yao attacker, which depends on the specific structure of terms and requires updates whenever new terms, such as cryptographic primitives, are introduced.
Second, it enables the penetrator to be maximized by only specifying what is strictly forbidden in order to achieve the security of a given protocol.
As a result, if the security of two protocols has been proven with respect to their maximal penetrators, they can be composed when they mutually respect each other's maximal penetrator conditions.
Intuitively, given two protocols,
if the behavior of each protocol is fully subsumed by the maximal penetrator of the other, we can safely combine them and derive a security proof for the combined protocol from the individual proofs.
In other words, this approach provides protocol compositionality for free.

We have implemented this technique on the protocol of \cref{ex:simpleprotocol} and its variant presented in \cref{sec:reusing}, where $A$ is replaced by $B$.
We then proved the security of their composition by fully reusing the individual security proofs for each protocol, as explained below.

We begin by defining the concept of maximal penetrator strands.
The key challenge is defining a property that ensures the penetrator does not compromise the cryptographic primitives required for the protocol's security.
Ideally, this property should be minimal in order to maximize the penetrator’s capabilities.
In the simple authentication protocol of \cref{ex:simpleprotocol}, security relies on the ability to encrypt using \lstinline|SK A B|.
Thus, the following definition asserts that encryption by the penetrator should only be allowed if the key is known, i.e., it is readable in cleartext from the network.
\begin{lstlisting}
Definition NoForgeCipher A B n :=
  forall p, originates (⟨ p ⟩_(SK A B)) n ->
    exists n', n' =>+ n /\ term n' = ⊖ #(SK A B).
\end{lstlisting}
The above definition states that for given \A and \B, if a ciphertext \lstinline|⟨ p ⟩_(SK A B)| originates in an output node, there must exist a preceding input node in the same strand where the key \lstinline|SK A B| is read in the clear.

The only other property needed for security is that the penetrator never originates \lstinline|SK A B|.
Therefore, we specify maximal penetrator strands as those whose nodes do not originate \lstinline|SK A B| and satisfy \lstinline|NoForgeCipher A B|:
\begin{lstlisting}
Inductive SA_maximal_penetrator_strand (A B : T) : Σ -> Prop :=
  | SAS_Pen : forall s,
      ( forall n, s = strand n ->
        ~originates #(SK A B) n /\ NoForgeCipher A B n ) ->
        SA_maximal_penetrator_strand A B s.
\end{lstlisting}
Under this maximal penetrator, we were able to prove the same authentication properties that we established using the standard Dolev-Yao penetrator (see \lstinline{Examples/simple_auth/SimpleAuthMaximalEnc.v}).

We then demonstrated several interesting results.
First%
, the Dolev-Yao penetrator is subsumed by the maximal penetrator, confirming that we are not overlooking any significant attacks.
\begin{lstlisting}
Lemma DY_is_SA_maximal_penetrator:
  forall A B s, penetrator_strand (K__P_AB A B) s -> SA_maximal_penetrator_strand A B s.
\end{lstlisting}
This also implies that the results we proved under the Dolev-Yao penetrator can now be derived from those established under the maximal penetrator by simply applying the lemma above.
\ifdefined\COLORDIFF
    \color{cbred}
\else
\fi
Crucially, our maximal penetrator is strictly stronger than the Dolev-Yao penetrator but still allows the protocol to be proved secure.
Consider for example the strand \lstinline{[⊖ ⟨ M ⟩_(SK A B); ⊕ M ]}, where an encrypted message is decrypted without knowledge of the secret key \lstinline{SK A B}.
This strand cannot be constructed by a Dolev-Yao penetrator because such intruders cannot break cryptography.
However, since the strand satisfies \lstinline{NoForgeCipher} and does not originate \lstinline{SK A B}, the maximal penetrator can produce it.
This intuition is formalized in file \lstinline{SimpleAuthMaximalEnc.v} by the lemma \lstinline{SA_maximal_penetrator_not_eq_DY}, whose proof is based on the above example.
\ifdefined\COLORDIFF
    \color{black}
\else
\fi

For compositionality, it is useful to demonstrate that certain honest participants can be mimicked by the maximal penetrator.
In particular, we find that the initiator is always subsumed by the penetrator, as it neither originates ciphertexts nor sensitive keys.
In contrast, for the responder, this holds only when the initiator key \lstinline|SK A' B'| is different from the one the attacker cannot forge, namely \lstinline|SK A B|.
This situation arises when neither \lstinline|A = A' /\ B = B'| nor \lstinline|A = B' /\ B = A'|.
This latter property is also the basis for our compositionality result.
\begin{lstlisting}
Lemma ini_penetrator :
  forall s A B Na A' B',
    SA_initiator_strand A' B' Na s ->
    SA_maximal_penetrator_strand A B s.

Lemma res_penetrator :
  forall s A B Na A' B',
    ~((A = A' /\ B = B') \/ (A = B' /\ B = A')) ->
    SA_responder_strand A' B' Na s ->
    SA_maximal_penetrator_strand A B s.
\end{lstlisting}
We have finally composed the protocol of \cref{ex:simpleprotocol} and its variant presented in \cref{sec:reusing}, where $A$ is replaced by $B$ in the protocol, under the same maximal penetrator.
This is done by simply placing in the same strand space the maximal penetrator strands and the initiator and responder strands of the two protocols, whose identities are required to respectively satisfy two predicates \lstinline|p1| and \lstinline|p2|.
Fixed a maximal penetrator for \lstinline|A| and \lstinline|B|, if we pick
\begin{lstlisting}
Definition p1 (A' B' : T) := True.
Definition p2 (A' B' : T) := ~((A = A' /\ B = B') \/ (A = B' /\ B = A')).
\end{lstlisting}
we allow all participants for protocol 1, as well as all participants with \lstinline|SK A' B'| that is disjoint from \lstinline|SK A B| for protocol 2.
Due to this restriction, protocol 2 can be emulated by the maximal penetrator, thanks to the \lstinline|res_penetrator| lemma.
Consequently, we can prove that the composed strand space is essentially the same as the strand space of protocol 1, allowing us to directly reuse all the results that have already been established for protocol 1.
\begin{lstlisting}
Lemma comp_is_protocol1:
  C_is_SS C (SA_StrandSpace p1 p2 A B) ->
  C_is_SS C (SimpleAuthMaximalEnc.SA_StrandSpace A B).
\end{lstlisting}
The same result also holds for protocol 2 by swapping predicates \lstinline|p1| and \lstinline|p2|.
All details are available in \lstinline{Examples/simple_auth/SimpleAuthMaximalEnc*.v}.





