
The literature on the analysis of cryptographic protocols is extensive and highly diverse, as evidenced by comprehensive surveys such as~\cite{barbosa:SoKCAC,blanchetPOST2012,CortierSurvey2011}.
Strand spaces have been a pioneering formalism for the specification and analysis of security protocols~\cite{FHG98}.
The slogan in the title, ``why is a security protocol correct?'' that we borrowed and extended in our paper, succinctly captures the underlying motivation: strand spaces were crafted to enable intuitive reasoning about protocol security.
Impressively, they facilitate concise and insightful pen-and-paper proofs of security for protocols featuring unbounded participants, sessions, keys, nonces, and more.
In the process of proving security, it becomes natural to introduce an assumption only when needed, resulting in a set of minimal assumptions necessary for the security proof to hold.
This approach is extremely insightful as it guides the analyst to gain a deep understanding of the root reasons behind protocol security and the crucial assumptions for such security to hold.
To the best of our knowledge, no other formalism allows for this level of insightfulness.
In fact, strand spaces had a significant impact on the research community, leading to a considerable amount of follow-up work and extensions.
Notable examples include~\cite{CVB05,CDLMS03,HP03,KL09,YEMMS16}, just to mention a few.





In the era of automated and mechanized verification, interest in pen-and-paper proofs is waning.
While strand spaces allow for concise proofs, the manual analysis of complex protocols is not credible, and even experimenting with variants of the same protocol can become tedious and time-consuming.
Moreover, mistakes can occur in pen-and-paper proofs.
The Cryptographic Protocol Shapes Analyzer (CPSA) \cite{cpsa,LRGR16} offers automated verification of protocols based on strand spaces.
However, it lacks the beauty and insightfulness of pen-and-paper proofs, and has been overshadowed by mainstream popular tools (see, e.g., \cite{BSCS20,EMM09,MSCB13}).
The primary motivation of this work is to revitalize the strand space model.
While our focus remains on understanding ``why is a security protocol correct?'' we aim to achieve this in a mechanized and reusable manner, by providing extensions that lessen the effort required by analysts to write security proofs.
In particular, we aim for: full mechanization; a good degree of proof automation to keep proofs short, readable, and reusable;
compositionality results to improve tool scalability.

In this paper, we present \easystrands{},\footnote{pronounced ``\emph{Strands Rock!}''.} the first full implementation of the strand spaces model in the Coq proof assistant.
Coq is extremely appealing for our goal as it offers full flexibility, allows for fully mechanized proofs with a small and popular trusted computing base, and provides the possibility of developing tactics for proof automation.
The development of the precise strand spaces model in Coq was challenging and required the development of original proof techniques and tactics to achieve a satisfactory degree of proof automation, eliminating all trivial and tedious cases.
A significant effort was also put in engineering the library to ensure its reusability for different protocols.

As confirmation, we mechanized several security proofs.
We began with a family of simple authentication protocols inspired by the ISO/IEC 9798-2 two-pass authentication protocol~\cite{ISO97982}, which we successfully analyzed in five different variants while significantly reusing the proofs. This confirmed that, although the initial effort to analyze a new protocol may be greater than with popular automated tools, once a proof is established, \easystrands{} allows for exploring protocol variants with relatively low effort. Furthermore, we introduced the notion of \emph{maximal penetrator} based on restrictions regarding sensitive cryptographic operations rather than enumerating all possible malicious capabilities. This approach enables the composition of two protocols proven secure under their respective maximal penetrators if they adhere to each other's conditions. We applied this technique to two simple authentication protocols, successfully proving the security of their composition by reusing the individual proofs.

We reproduced the pen-and-paper proofs of the classic Needham-Schroeder-Protocol (NSL) from the original strand spaces paper \cite{FHG98}, using exactly the same arguments and proof techniques, and then improved and simplified them using the new proof techniques offered by \easystrands{}.
We also verified the results of \citet{focardi2021secure}, correcting some errors in the original pen-and-paper development and improving their findings. Through mechanization, we identified some superfluous conditions in the proposed static analysis, which we refined to enhance its precision. To validate our approach, we demonstrate that the most complex example presented by \citet{focardi2021secure}, originally used to illustrate the limitations of their analysis, can be proven correct using our refined solution.



\myparagraph{Main contributions}
We summarize our main contributions as follows:
\begin{itemize}
\item we provide the first fully mechanized implementation of the original strand spaces model in a proof assistant (\cref{sec:running}) and we implement Coq libraries that allow for the automation of case analysis in the proofs (\cref{sec:proofprotocol}), making them concise and reusable (\cref{sec:reusing});
\item we devise new proof techniques that overcome some limitations of the ones used in \cite{FHG98} (\cref{sec:newproofs}) and provide protocol compositionality through the notion of maximal penetrator (\cref{sec:maximal});
\item we analyze a family of simple authentication protocols inspired by the ISO/IEC 9798-2 two-pass authentication protocol~\cite{ISO97982}, across several different variants, with significant proof reuse,  providing insights into the minimal security assumptions required for each variant.
\item we reproduce the analysis of the NSL protocol from~\cite{FHG98}, addressing a few mistakes in the pen-and-paper lemmas and proofs (\cref{subsec:NSL});
\item we mechanize and fix a recent proof of security for a key management API based on a static analysis of the policy~\cite{focardi2021secure}, a
task we believe to be particularly unsuitable for automated tools, since the security theorem is based on an overapproximation of the API behavior (\cref{subsec:KMP}). We propose an enhanced static analysis, demonstrating its security while largely reusing our mechanized proof for the original analysis.
\end{itemize}

\ifdefined\CAMERAREADY
  \myparagraph{Note} The Coq implementation, the examples and case studies are available online~\cite{strandsrocqcode}. 
\else
\myparagraph{Note} The Coq implementation, the examples and case studies are fully available to the reviewers as supplementary material.
\fi

\section{Related Work}


\myparagraph{Mechanized protocol analysis}
The literature on mechanized protocol analysis from the past two decades is extensive and challenging to encompass within a single paragraph (see, e.g., \cite{barbosa:SoKCAC,blanchetPOST2012,CortierSurvey2011}). Researchers have studied various methodologies to prove the correctness of security protocols, both in the idealized world of symbolic models and in the more concrete realm of computational models. These two approaches complement each other and are sometimes connected by computational soundness results that allow for obtaining proofs in computational models through purely symbolic analysis \cite{blanchetPOST2012}.
Symbolic analysis has scaled to the point of automatically verifying real-world protocols, and the plethora of popular tools, such as \cite{cpsa,BSCS20,EMM09,MSCB13,Paulson98}, confirms the success
of this approach.

Other successful approaches in the literature offer semi-automated, interactive symbolic techniques in which proofs are partially provided by hand. A representative example is DY* \cite{DY}, a recently proposed verification framework for symbolic protocol analysis based on F* \cite{Fstar}. DY* leverages dependent types to prove protocol security, and allows for extracting protocol implementations in F*. Interestingly, Bhargavan et al. \cite{DY} point out how automated tools impose limitations on the protocol model to keep the analysis feasible, and how some protocols require powerful inductive reasoning provided by general-purpose proof frameworks such as Coq \cite{coq} and F* \cite{Fstar}, which are only partially supported by state-of-the-art automated tools. In this work, following the direction set by DY*, aiming to provide full flexibility of general-purpose proof frameworks for symbolic protocol analysis,  we fully mechanize strand spaces in Coq, and provide mechanized and reusable proofs of security for significant core examples. We are certainly far from competing with state-of-the-art tools in terms of coverage and scalability, but we claim that our contribution is significant and distinguished from various perspectives that we discuss below.


\myparagraph{Mechanized proof methods for symbolic protocol analysis}
The model proposed by Paulson \cite{Paulson98}, based on the Isabelle theorem prover \cite{Paulson94}, is the closest to our mechanization of strand spaces. Interestingly, both approaches rely on inductive reasoning, and Fabrega et al. \cite{FHG98} briefly discuss the differences between them pointing out that strand spaces have a peculiar underlying causal semantics that represents protocol executions as partially ordered events. This allows for a powerful inductive principle that permits to prove properties of executions by reasoning on the local behaviour of protocol participants. Moreover, this provides very insightful proofs of protocol security, which point out necessary conditions, such as nonce freshness and key secrecy, in a direct and very intuitive way, allowing to prove protocol security under a set of minimal necessary conditions.
Notably, Paulson's approach~\cite{Paulson98}  has been applied to complex and realistic protocols, demonstrating its scalability through proof automation in Isabelle (see, e.g., \cite{BellaP98}). The lack of automation for strand spaces proofs has historically hindered achieving similar results and conducting a close comparison between the two approaches. We anticipate that \easystrands{} will address this gap and offer further insights into their relative merits, similarities, and differences.

Another closely related work is DY* \cite{DY} that we already mentioned above.
While our proposal is certainly not as scalable or mature as DY*, we believe it offers interesting distinctions. Specifically, in \easystrands, we demonstrate protocol security on straightforward specifications that directly correspond to the so-called \emph{Alice and Bob notation}.
In fact, our
security proofs are conducted on the plain protocol specification without any typing annotations.
While in DY*, the primary analyst effort is on providing sophisticated dependent types to enable protocol typechecking, our approach amounts to devising a suitable property that is proven inductively.
For this reason, we believe that both approaches offer valuable insights and complement each other. However, the maturity of DY* and F* is so significantly higher compared to our approach that it is nearly impossible to make a direct comparison between the two.



\myparagraph{Mechanization of strand spaces}
Li and Pang \cite{li2013inductive} proposed a version of strand spaces in Isabelle/HOL.
The authors partially modified and extended the original strand spaces model \cite{FHG98}, basing their inductive verification on the concept of authentication tests from \cite{guttman2000authentication}.
They highlighted that their automated proof of the Needham-Schroeder-Lowe (NSL) protocol spans 1954 lines, and the proof scripts are still available at \cite{Yongjianstrands}.
In contrast, our goal was to provide an accurate mechanization of the original strand spaces model without resorting to any modification or extension. Despite the initial intricacy of the process, we successfully mechanized strand spaces with no alterations. As confirmation of our successful mechanization, we were able to reproduce the exact pen-and-paper proofs for the NSL protocol (\cref{subsec:NSL}), which, in our case, are much shorter than those presented in \cite{li2013inductive}, totaling nearly 400 lines for the verification of the same properties. Additionally, we developed Coq tactics that enable proof automation and reuse, as discussed in \cref{sec:proofprotocol,sec:reusing}, and
devised new proof techniques that overcome some limitations of the ones used in \cite{FHG98} (\cref{sec:newproofs}), providing protocol compositionality through the notion of maximal penetrator (\cref{sec:maximal}).

The Cryptographic Protocol Shapes Analyzer (CPSA) is a tool designed for the analysis and design of security protocols grounded in strand space theory~\cite{cpsa,LRGR16}, while Maude-NPA adopts the strand spaces formalism to formally specify protocols~\cite{EMM09}.
Both tools have been employed for the automated analysis of various cryptographic protocols and security APIs \cite{MaudeAPI1,MaudeAPI2,J12,LZ17,RGMO12,RDGR18,SRP20}, and they belong to the category of automated symbolic verification tools. Our focus is complementary, as we do not aim for fully automated verification.

Strand spaces rely on nonstandard definitions and introduce a specific induction principle, necessitating careful formalization and tailored proof automation techniques to prevent proofs from becoming lengthy and tedious, thus avoiding distractions for the analyst with too many uninteresting cases. This presented a significant challenge, and our mechanization of strand spaces in Coq is the first comprehensive one, including significant examples.
We found existing repositories lacking protocol examples and seemingly unmaintained \cite{kentstrands,nguyenauthtests,nguyenstrands}. The only related published document is a BSc thesis by Hai Hoang Nguyen \cite{nguyenthesis}, which is related to the aforementioned repositories.








