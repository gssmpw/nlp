%%
%% This is file `sample-sigconf.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `all,proceedings,bibtex,sigconf')

%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-sigconf.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%%
%% Commands for TeXCount
%TC:macro \cite [option:text,text]
%TC:macro \citep [option:text,text]
%TC:macro \citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass
%% command.
%%
%% For submission and review of your manuscript please change the
%% command to \documentclass[manuscript, screen, review]{acmart}.
%%
%% When submitting camera ready or to TAPS, please change the command
%% to \documentclass[sigconf]{acmart} or whichever template is required
%% for your publication.
%%
%%
\documentclass[sigconf]{acmart}
\usepackage[linesnumbered,ruled]{algorithm2e}
\usepackage{array}
\usepackage{CJKutf8}
\usepackage[caption=false,font=normalsize,labelfont=sf,textfont=sf]{subfig}
\usepackage{textcomp}
\usepackage[inkscapelatex=false]{svg}
\usepackage{stfloats}
\usepackage{booktabs} 
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage{hyperref}
\usepackage{bbding}
\usepackage{color}
\newcommand{\yukun}[1]{\textcolor{red}{#1}}
\newcommand{\xk}[1]{\textcolor{blue}{#1}}
\usepackage{url}
\usepackage{verbatim}

\usepackage{multirow} 
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    Bib\TeX}}}
%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
% \setcopyright{acmlicensed}
% \copyrightyear{2018}
% \acmYear{2018}
% \acmDOI{XXXXXXX.XXXXXXX}

%% These commands are for a PROCEEDINGS abstract or paper.
% \acmConference[Conference acronym 'XX]{Make sure to enter the correct
%   conference title from your rights confirmation emai}{June 03--05,
%   2018}{Woodstock, NY}
%%
%%  Uncomment \acmBooktitle if the title of the proceedings is different
%%  from ``Proceedings of ...''!
%%
%%\acmBooktitle{Woodstock '18: ACM Symposium on Neural Gaze Detection,
%%  June 03--05, 2018, Woodstock, NY}
% \acmISBN{978-1-4503-XXXX-X/18/06}


%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command \citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}


%%
%% end of the preamble, start of the body of the document source.
\begin{document}
\begin{CJK}{UTF8}{gbsn}
%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{HAIL: An Efficient Iterative Algorithm for Qubit Mapping via Layer-Weight Assignment and Search Space Reduction}
% HAIL: An Efficient Heuristic Qubit Mapping Algorithm via Simplified Iteration and Layer-Weight Assignment
%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.
\author{Kang Xu}
\affiliation{%
  \institution{Beijing Key Laboratory of Petroleum Data Mining, China University of Petroleum, Beijing 102249, China}
    \institution{State Key Lab of Processors, Institute of Computing Technology, CAS,Beijing 100190,China}
    \country{}
  % \city{Haidian Qu}
  % \state{Beijing Shi}
  % \country{China}
  }
  \author{Zeyang Li}
\affiliation{%
  \institution{Beijing Key Laboratory of Petroleum Data Mining, China University of Petroleum, Beijing 102249, China}
  \country{}
  % \city{Haidian Qu}
  % \state{Beijing Shi}
  % \country{China}
  }
  \author{Xinjian Liu}
\affiliation{%
  \institution{Beijing Key Laboratory of Petroleum Data Mining, China University of Petroleum, Beijing 102249, China}
  \country{}
  % \city{Haidian Qu}
  % \state{Beijing Shi}
   %\country{China}
  }
    \author{Dandan Li}
\affiliation{%
  \institution{School of Computer Science (National Pilot Software Engineering School)}
    \institution{Beijing University of Posts and Telecommunications, Beijing 100876, China．}
    \country{}
  %\country{China}
  }
     \authornotemark[1]
     \email{dandl@bupt.edu.cn}
  \author{Yukun Wang}
\affiliation{%
  \institution{Beijing Key Laboratory of Petroleum Data Mining, China University of Petroleum, Beijing 102249, China}
  \institution{State Key Lab of Processors, Institute of Computing Technology, CAS, Beijing 100190, China}
  \country{}
  % \city{Haidian Qu}
  % \state{Beijing Shi}
  % \country{China}
  }
   \authornotemark[2]
     \email{wykun06@gmail.com}
% \author{Ben Trovato}
% \authornote{Both authors contributed equally to this research.}
% \email{trovato@corporation.com}
% \orcid{1234-5678-9012}
% \author{G.K.M. Tobin}
% \authornotemark[1]
% \email{webmaster@marysville-ohio.com}
% \affiliation{%
%   \institution{Institute for Clarity in Documentation}
%   \city{Dublin}
%   \state{Ohio}
%   \country{USA}
% }

% \author{Lars Th{\o}rv{\"a}ld}
% \affiliation{%
%   \institution{The Th{\o}rv{\"a}ld Group}
%   \city{Hekla}
%   \country{Iceland}}
% \email{larst@affiliation.org}

% \author{Valerie B\'eranger}
% \affiliation{%
%   \institution{Inria Paris-Rocquencourt}
%   \city{Rocquencourt}
%   \country{France}
% }

% \author{Aparna Patel}
% \affiliation{%
%  \institution{Rajiv Gandhi University}
%  \city{Doimukh}
%  \state{Arunachal Pradesh}
%  \country{India}}

% \author{Huifen Chan}
% \affiliation{%
%   \institution{Tsinghua University}
%   \city{Haidian Qu}
%   \state{Beijing Shi}
%   \country{China}}

% \author{Charles Palmer}
% \affiliation{%
%   \institution{Palmer Research Laboratories}
%   \city{San Antonio}
%   \state{Texas}
%   \country{USA}}
% \email{cpalmer@prl.com}

% \author{John Smith}
% \affiliation{%
%   \institution{The Th{\o}rv{\"a}ld Group}
%   \city{Hekla}
%   \country{Iceland}}
% \email{jsmith@affiliation.org}

% \author{Julius P. Kumquat}
% \affiliation{%
%   \institution{The Kumquat Consortium}
%   \city{New York}
%   \country{USA}}
% \email{jpkumquat@consortium.net}

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more con cise list
%% of authors' names for this purpose.
% \renewcommand{\shortauthors}{Trovato et al.}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
%{Quantum architectures currently face limitations, as they restrict multi-qubit gates to interconnected qubits. Effectively executing quantum circuits on a given device requires additional SWAP gates for interactions between non-directly connected qubits, but these extra gates can increase error rates and quantum resource usage. To tackle these challenges, this paper proposes an iterative heuristic algorithm aimed at minimizing additional SWAP gates, thereby improving circuit quality. Initially, we introduce a subgraph isomorphism and completion method based on layer-weight assignment to establish an initial mapping that reduces SWAP gates. Subsequently, a heuristic method is proposed to efficiently swap qubits by identifying optimal SWAP sequences and using a look-ahead window to narrow the search scope. Finally, the qubit mapping is refined through iterative forward and backward traversals to further reduce the number of SWAP gates. We test our algorithm on the IBM Q20 architecture and benchmark it against existing heuristics. The results demonstrate that our proposed algorithm optimizes the number of additional gates inserted in the given benchmarks by 20.62\% compared to current state-of-the-art algorithms. Additionally, we optimize the number of candidate SWAP sequences and conduct experiments on the sparsely connected Google Sycamore architecture, demonstrating shorter runtime and fewer additional quantum gates.}
{Current quantum devices only support interactions between physical qubits and a limited number of neighboring qubits, preventing quantum circuits from being executed directly on the devices. To execute the circuit, SWAP gates must be inserted to adjust the mapping relationships between qubits, which consequently increases runtime and error rates in quantum circuits. To address these challenges, this paper proposes HAIL, an efficient iterative qubit mapping algorithm to minimize additional SWAP gates. First, a layer-weight assignment method integrated with the subgraph isomorphism algorithm is introduced to establish an initial mapping. Next, we propose a SWAP sequence search combined with the post-processing function to identify the optimal SWAP sequences. Finally, the qubit mapping algorithm is refined through iterative forward and backward traversals to further reduce the number of SWAP gates. Experimental results on the IBM Q20 architecture and various benchmarks demonstrate that HAIL-3 reduces the number of additional gates inserted in the $\mathcal{B}_{23}$ by 20.62\% compared to state-of-the-art algorithms. Additionally, we present a partially extended strategy based on HAIL to reduce the sequence search space, with experiments on the sparsely connected Google Sycamore architecture showing a reduction in both algorithm runtime and additional SWAP gates.}

\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
% \begin{CCSXML}
% <ccs2012>
%  <concept>
%   <concept_id>00000000.0000000.0000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>500</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>00000000.00000000.00000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>300</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>00000000.00000000.00000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
%  <concept>
%   <concept_id>00000000.00000000.00000000</concept_id>
%   <concept_desc>Do Not Use This Code, Generate the Correct Terms for Your Paper</concept_desc>
%   <concept_significance>100</concept_significance>
%  </concept>
% </ccs2012>
% \end{CCSXML}

% \ccsdesc[500]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[300]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc{Do Not Use This Code~Generate the Correct Terms for Your Paper}
% \ccsdesc[100]{Do Not Use This Code~Generate the Correct Terms for Your Paper}
\pagestyle{empty}
%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{Qubit mapping, subgraph isomorphism, iterative optimization, heuristic algorithm.}
%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
% \begin{teaserfigure}
%   \includegraphics[width=\textwidth]{sampleteaser}
%   \caption{Seattle Mariners at Spring Training, 2010.}
%   \Description{Enjoying the baseball game from the third-base
%   seats. Ichiro Suzuki preparing to bat.}
%   \label{fig:teaser}
% \end{teaserfigure}

% \received{20 February 2007}
% \received[revised]{12 March 2009}
% \received[accepted]{5 June 2009}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\settopmatter{printacmref=false} 
\renewcommand\footnotetextcopyrightpermission[1]{}

\maketitle
\section{Introduction}
In recent years, quantum computing has emerged as a leading post-Moore's Law technology, attracting significant attention from researchers due to its powerful parallel processing capabilities. The use of quantum computers to simulate quantum systems, initially proposed by Feynman\cite{feynman2018simulating} in 1982, has driven significant advancements in the field. Examples of such progress include Shor’s algorithm for factoring \cite{shor1994algorithms}, Grover’s search algorithm \cite{grover1996fast}, and Harrow’s quantum linear systems algorithm \cite{harrow2009quantum}. In addition to the development of quantum algorithms\cite{li2025efficient,song2024quantum}, quantum hardware has also undergone significant improvements.
Recent milestones include the development of quantum chips with {70-100 }%有变多吗？70-100？ %有很多已经超过这个数目了，之前放50-70只是想往sycamore(53)上面靠，但实际上也合理写成70-100
qubits across diverse quantum technologies such as superconducting, neutral atoms, ion traps, and photonics. This progress culminated in 2023 with the launch of IBM's Condor\cite{Condor2023ibm} quantum processor, featuring 1121 qubits and significantly advancing the practical application of quantum computing.
% IBM's quantum roadmap outlines an ambitious vision for future development, fueling anticipation for practical quantum computing applications and accelerating solutions to real-world challenges in the Noisy Intermediate-Scale Quantum (NISQ) era.
% Among these are the Shor\cite{shor1994algorithms} algorithm for integer factorization, the Grover\cite{grover1996fast} algorithm for unsorted database search, and the HHL\cite{harrow2009quantum} algorithm for linear systems of equations solving. Many of these algorithms have exhibited remarkable progress in diverse domains, including chemical simulation, financial analysis, and machine learning.
%Several years ago, IBM, Intel, and Google each unveiled quantum chips with approximately 50-70 qubits. % Furthermore, IBM has made several real quantum computing chips available on its cloud platform for research purposes. 
%In 2023, IBM introduced the Condor\cite{Condor2023ibm}, its new quantum processor featuring 1121 qubits, and unveiled a new roadmap for future technological advancements.  



   
%Despite significant progress in quantum computing, achieving large-scale fault-tolerant quantum computing still faces major challenges due to limitations in qubit availability, high error rates, and inadequate connectivity in quantum architectures. 
 % These challenges stem from limitations in the number of available qubits, the error rates associated with qubits, and deficiencies in connectivity among quantum architectures. 
Despite the remarkable progress in quantum computing, achieving large-scale fault-tolerant quantum computing still faces significant challenges such as limited qubit count and inadequate device connectivity. When executing quantum algorithms on real quantum devices, the connectivity of the physical qubits must be considered, as prevailing quantum architectures support multi-qubit gates only between interconnected qubits. Therefore, it is essential to first establish a mapping between the logical qubits and the physical qubits of the quantum device. When a multi-qubit gate does not satisfy the current mapping relationship, SWAP gates must be inserted to adjust the mapping relationship and make non-adjacent qubits adjacent, enabling the execution of circuits while maintaining functional equivalence between physical and logical circuits. However, this qubit mapping process introduces additional gates, increasing both gate count and circuit depth \cite{sun2023asymptotically}, which can adversely affect quantum algorithm performance. So the primary goal of qubit mapping is to minimize the number of SWAP gates.

 


The qubit mapping problem, formally recognized as NP-complete \cite{botea2018complexity, NPsiraichi2018qubit}, poses significant challenges. Various methods\cite{ge2024quantumcircuitsynthesiscompilation} have been employed to address this issue, including mathematical programming, machine learning, and heuristic algorithms.
Mathematical programming techniques involve converting mapping problems into integer programming problems \cite{shafaei2014qubit,nannicini2022optimal,bhattacharjee2017depth, bhattacharjee2019muqut}, satisfiability (SAT) problems \cite{tan2021optimal,murali2019noise,lye2015determining,wille2019mapping,molavi2022qubit,lin2023scalable}, and then solving them with different kinds of advanced solver, such as the SMT solver (Satisfiability Modulo Theories) and the SAT solver. However, these methods are often limited to smaller problems due to their high time complexity.
%However, these methods are typically used for problems with a few qubits and quantum gates because of their high time complexity in handling mapping problems. 
On the other hand, machine learning approaches for qubit mapping problems have emerged with the advancement of artificial intelligence technologies\cite{zhou2020monte,sinha2022qubit,pozzi2022using,li2024deep,fan2022optimizing,zhou2022supervised,paler2023machine}, including Monte Carlo Tree Search \cite{zhou2020monte}, reinforcement learning \cite{pozzi2022using}, and neural networks \cite{zhou2022supervised}, for decision making. However, these methods face challenges such as extensive data requirements, high computational costs, and limited interpretability, which hinder their widespread adoption. %machine learning approaches for qubit mapping problems have emerged with the advancement of artificial intelligence technologies\cite{zhou2020monte,sinha2022qubit,pozzi2022using,li2024deep,fan2022optimizing,zhou2022supervised,paler2023machine}, encompassing Monte Carlo Tree Search \cite{zhou2020monte,sinha2022qubit}, reinforcement learning techniques \cite{pozzi2022using,li2024deep,fan2022optimizing}, and artificial neural networks\cite{zhou2022supervised} for decision making.
%However, machine learning methods also face challenges such as extensive data requirements for model training, substantial computational resources, and a lack of intuitive interpretability, which prevents them from becoming the predominant research approach.

 In contrast, heuristic algorithms offer excellent scalability, efficiently solving mapping problems involving tens of qubits and thousands of quantum gates in a relatively short time.
%These algorithms utilize experience-based rules and functions to optimize qubit placement in the initial mapping and the insertion of SWAP gates during the routing phase, aiming to achieve near-optimal additional SWAP cost.
These algorithms use experience-based rules to optimize qubit placement and SWAP gate insertion for near-optimal SWAP costs.
 Numerous heuristic algorithms for qubit mapping have been developed\cite{matsuo2012changing,zulehner2018efficient,li2019tackling,ash2019qure,niu2020hardware,lao20222qan,li2023timing,li2020qubit,zhu2021iterated,qian2023method,jiang2021quantum,datta2023improved,chang2021mapping,ovide2023mapping,liu2023tackling,zhu2020dynamic,huang2024efficient}.
For example,  Zulehner et al. \cite{zulehner2018efficient} first introduced the A* search algorithm, but the search space grows exponentially with depth, which can potentially result in high complexity. 
In response, Li et al. \cite{li2019tackling} proposed SABRE, a novel bidirectional search algorithm that significantly reduces both time complexity and the number of additional SWAP gates compared to the A* algorithm. 
Additionally, Li et al. \cite{li2020qubit} employed subgraph isomorphism algorithms for initial mapping, effectively identifying SWAP-free mappings. % which can more effectively identify mappings that avoid the need for SWAP gates. 
However, they use the number of gates between qubits as weights for isomorphism discrimination, which may inadequately captures circuit details. To  improve initial mappings, iterative methods have been introduced. These methods refine mappings by exploring their neighborhood through repeated circuit executions. %Zhu et al. \cite{zhu2021iterated} proposed an iterative algorithm using bidirectional searches and shuffling perturbations, reducing SWAP gates but requiring extensive computational resources. Qian et al. \cite{qian2023method} introduced a time-weighted approach where gate weights decrease progressively, addressing uniform weight issues, though it does not adequately account for parallel gate weights. 
Zhu et al. \cite{zhu2021iterated} developed an iterative algorithm using bidirectional searches and shuffling perturbations to reduce SWAP gates. But it requires multiple iterations, which may increase computational demands. Qian et al. \cite{qian2023method} proposed a time-weighted method where gate weights decrease progressively, addressing uniform weight issues. However, it does not fully account for parallel gate weights, which may potentially limiting its effectiveness.
Despite advances, challenges like neglecting parallel gate weights, high iteration counts, and long runtime remain. Research by Tan \cite{tan2020optimality} reveals significant performance gaps in QUEKO benchmarks, indicating a need for further improvements in heuristic qubit mapping algorithms.
 
 %Additionally, iterative methods have also been applied in qubit mapping problem. Since the initial mapping may not be optimal, the neighborhood of the initial mapping will be explored by repeatedly executing the circuit, yielding better initial mapping results. 
 
 %Zhu et al. \cite{zhu2021iterated} first introduced an iterative algorithm based on bidirectional searches, which applies shuffling perturbations to the optimal mapping obtained during iterations.
 %This method reduces the number of SWAP gates but requires a large number of iterations, increasing computational resource demands.
%In 2023, Qian\cite{qian2023method} et al. identified that it is unreasonable for the weights of each gate in the circuit to be uniform\cite{li2020qubit}, so they proposed a time-weighted method for assigning weights in which the weight of each gate decreases progressively.
 %However, the weights of parallel gates were not adequately considered, which could potentially affect its effectiveness. 
%Overall, the issues affecting algorithm performance, including the neglect of parallel gate weights, high iteration nums, and extended runtime associated with deep search depths, remain to be addressed. Moreover, although numerous heuristic algorithms are effective, research by Tan\cite{tan2020optimality} suggests a significant gap in their performance on QUEKO benchmarks, indicating substantial room for improvement in addressing the qubit mapping problem.
 


In this paper, we propose HAIL, an iterative optimization-based heuristic algorithm with the aim of minimizing the additional SWAP gates in the qubit mapping problem. The algorithm begins with the introduction of subgraph isomorphism algorithm and a completion algorithm with layer-weight assignment to partition the circuit and map it into a coupling structure graph. To address limitations of the subgraph isomorphism algorithm, a mapping completion approach is employed to enable qubit insertion around placed qubits. After establishing a complete initial mapping, we apply a sequence search method for SWAP gates, prioritizing sequences with the highest average executable CNOT count, and refine this selection with a loss function based on distance and layer-weight. We then introduce a simplified iterative framework using forward-backward techniques for optimizing the mapping. Experimental results show that HAIL-3 outperforms state-of-the-art methods, including SABRE, ILS, and TWP, achieving a 20.62\% reduction in additional SWAP gates on the IBM Q20 for the $\mathcal{B}_{23}$ benchmark. When HAIL is integrated with a search space reduction strategy, comparative experiments across various benchmarks and architectures demonstrate reductions in both runtime and additional gates, confirming its scalability and efficiency.
%Initially, we introduce a subgraph isomorphism algorithm and a completion algorithm utilizing layer-weight assignment to partition the circuit and embed it into a coupling structure graph. Concretely, to overcome the limitation of the subgraph isomorphism algorithm, the mapping completion algorithm is introduced to enable qubit insertion around already placed qubits. Once a complete initial mapping is established, we employ a sequence search method for SWAP gates, emphasizing sequences with the highest average executable CNOT count. We further refine SWAP sequence selection using a loss function based on distance and layer-weight. Recognizing potential mismatches between initial and optimal mappings, we propose a simplified iterative framework that solely employs forward-backward techniques to optimize the entire mapping algorithm iteratively.
%Finally, we compare our algorithm with the prevailing state-of-the-art algorithms, SABRE\cite{li2019tackling}, ILS\cite{zhu2021iterated}, and TWP\cite{qian2023method} algorithms, demonstrating a 20.62\% optimization in additional gate insertions. Furthermore, to validate the generalization capability of the algorithm, we conducted comparative experiments across various benchmarks and architectures. The results showed that the algorithm achieved a reduction in both runtime and the number of additional gates, which further confirms the effectiveness and scalability of our algorithm.

The rest of this paper is organized as follows. Section 2 introduces the background of quantum computing, followed by a detailed description of the proposed algorithm in Section 3. In Section 4, experiments are carried out on the IBM Q20 and Google Sycamore architectures, with a comprehensive analysis of the results performed. Finally, the whole paper is summarized.
\begin{figure}[!t]
\centering
\includegraphics[width=\linewidth]{basicgates.pdf}
\caption{Some common basic gates. (a) H gate, (b) Ry($\theta$) gate, (c) CNOT gate, (d) SWAP gate.}
\label{fig_1}
\end{figure}
\begin{figure}[t]
\centering
\includegraphics[width=0.95\linewidth]{Figure2.pdf}
\caption{(a) An initial circuit and one of its corresponding mappings to the linear quantum architecture, where the red color indicates that the gates are not executable under the mapping in this architecture,
% \yukun{An initial circuit and one of its corresponding mappings to the Linear quantum architecture, where the red color indicates that the gate is not executable under the mapping in this architecture.}
(b)  A swap is inserted to enable execution in the linear quantum architecture and mapped accordingly, (c) The qubit interaction graph of the initial circuit.}
\label{fig_2}
\end{figure}
\begin{figure}[t]
\centering
\includegraphics[width=0.95\linewidth]{architecture.pdf}
\caption{The quantum hardware architectures. (a) IBM QX2, (b) IBM QX4, (c) IBM Q20, (d) Google Sycamore.}
\label{fig_4}
\end{figure}
\section{Background}
This section aims to provide a concise introduction to the fundamentals of quantum computing, enabling a better understanding of the challenges surrounding qubit mapping and the proposed methodologies.
% to aid in understanding the issues of qubit mapping and the subsequent proposed algorithms.
\subsection{{Quantum Gates and Quantum Circuits}% 如果最后投的是量子类的相关期刊，这一部分建议就不用要了，建议介绍量子线路映射的一般问题，包括启发式算法实现线路映射问题的几个步骤，每个步骤面临的具体问题。 这里可以引入一个具体的例子。
}
Qubit is the fundamental unit of quantum computing. Unlike classical bits, which can only be in states of 0 or 1, qubits can exist in superpositions of these states due to quantum mechanics. In quantum computing, a qubit's state can be represented as $|\phi\rangle = \alpha|0\rangle + \beta|1\rangle$, where $|0\rangle$ and $|1\rangle$ are the basic states, and $\alpha$ and $\beta$ are complex numbers satisfying the normalization condition $|\alpha|^2 + |\beta|^2 = 1$.
% Similarly, when extending this concept to the scenario involving two qubits, the system's state can be described as $|\phi_2\rangle = \alpha_{00} |00\rangle + \alpha_{01} |01\rangle +\alpha_{10} |10\rangle + \alpha_{11} |11\rangle$. Moreover, it remains subject to $|\alpha_{00}|^2 + |\alpha_{01}|^2 + |\alpha_{10}|^2 + |\alpha_{11}|^2 = 1$.

Quantum gates typically act on qubits, and a combination of single-qubit gates and CNOT gates can generally achieve arbitrary unitary gates. Therefore, these two types of quantum gates are introduced primarily.
% \begin{figure}[!t]
% \centering
% \includegraphics[width=0.50\linewidth]{Fig/SWAP.png}
% \caption{The SWAP gate can be decomposed into three CNOT gates.}
% \label{SWAP}
% \end{figure}
In Fig. \ref{fig_1}, some representative quantum gates are illustrated. The $H$ gate is extensively used for creating quantum superposition states. The $Ry(\theta)$ gate, a single-qubit gate rotating around the Y-axis, is prominent in variational quantum algorithms. The CNOT gate, denoted as $g=<p,q>$, alters the target qubit's state based on the control qubit's state. If the control qubit is $|1\rangle$, the target qubit undergoes an $X (NOT)$ gate. The SWAP gate facilitates the exchange of states between two qubits, transforming $|a, b\rangle$ to $|b, a\rangle$. Additionally, a SWAP gate can be decomposed into three CNOT gates, which is crucial in qubit mapping problems.

A quantum circuit acts as a formal representation of a quantum algorithm or program, delineated by a series of quantum gates, as demonstrated in Fig. \ref{fig_2}(a). This circuit comprises five single-qubit gates ($H$ gate and $Ry(\theta)$ gate) and four two-qubit gates (CNOT gate). In this paper, such quantum circuits are called logical circuits, denoted by the notation $LC(Q, G)$, where $Q$ represents logical qubits, and $G$ denotes the set of all gates in the circuit. Fig. \ref{fig_2}(b) shows the quantum circuit after being adjusted for execution in the given quantum architecture, where a SWAP gate is inserted. Since gate permutation or cancellation operations between gates are not performed in the quantum circuit in our paper, single-qubit gates do not affect the outcome of qubit mapping. Thus, the qubit mapping problem can be simplified to only consider two-qubit gates.
\subsection{Qubit Interaction Graph and Quantum Hardware Architecture}
Once a quantum logical circuit $LC(Q, G)$ is obtained, a qubit Interaction Graph ($IG$) can be defined to represent the connections of the logical qubits. The \(IG\) is an undirected graph where nodes represent the qubits in \(Q\). An edge is formed between two nodes \(q_i\) and \(q_j\) if there is a correlated two-qubit gate between them, which plays a crucial role in subgraph isomorphism matching. Specifically, Fig. \ref{fig_2}(c) illustrates the \(IG\) for the quantum circuit shown in Fig. \ref{fig_2}(a), consisting of four nodes and four edges.
% \begin{figure}[!t]
% \centering
% \includegraphics[width=0.3\linewidth]{Fig/new_fig4.png}
% \caption{This is the qubit interaction graph obtained by converting the quantum circuit in Fig. \ref{fig_2}. If there is a connection between different qubits, it indicates the presence of a CNOT gate between the corresponding qubits.}
% \label{fig_3}
% \end{figure}
 

{The quantum hardware architecture is represented as $AG(V, E)$, where $V$ denotes the nodes and $E$ denotes the edges.} To provide an overview of quantum hardware architectures, Fig. \ref{fig_4} illustrates several architectures from IBM and Google. Despite advancements such as the Condor quantum processor, current architectures are still constrained by connectivity limitations. Among these architectures, the IBM Q20 is notable for its dense bidirectional connectivity and is widely used.
% \yukun{ Represented as an undirected graph ($AG$), nodes ($V$) and edges ($E$) denote the Architecture Graph's structure and connectivity.}
%This paper also focuses on the IBM Q20 architecture due to its effectiveness.
%在介绍谁？
%NOTE:已修改

\subsection{Initial Qubit 
 Mapping and Routing Problem}
The quantum circuit mapping problem is primarily divided into the initial qubit mapping and qubit routing problems, with the assumption that the input quantum circuit is denoted as \( LC(Q, G) \) and the given quantum device as \( AG(V, E) \).

First, the initial qubit mapping problem refers to the one-to-one correspondence between logical qubits and physical qubits (e.g., \( Q \rightarrow V \)). This process typically involves various approaches such as random mapping, naive mapping, and optimization-based techniques. An example of a simple mapping is shown in Fig. \ref{fig_2}(a), where the mapping is represented as \( \tau = \{q_0 : v_0, q_1 : v_1, q_2 : v_2, q_3 : v_3\} \). Under this mapping, the gate marked in red cannot be executed because the mapped nodes are not directly connected.

The routing problem is defined as follows: during the execution of the circuit, if a gate cannot be executed due to the current mapping and gate dependency constraints, SWAP gates must be inserted to transform the mapping, resulting in a new mapping \( \tau' \). As shown in Fig. \ref{fig_2}(b), the insertion of SWAP gates allows the remaining two CNOT gates to be executed. However, this process introduces additional SWAP gate operations, and thus, the primary optimization goal of quantum circuit mapping is to minimize the number of additional SWAP gates inserted.
% The input quantum circuit $LC(Q, G)$  and a given connectivity architecture $AG(V, E)$ are considered. To simplify the problem, assume that the circuit contains only single-qubit gates and CNOT gates. The mapping between logical and physical qubits can be either random or based on a straightforward mapping method (e.g., $Q_i \rightarrow V_i$),  as demonstrated by the mapping relationship in Fig. \ref{fig_2}(a), which defines a one-to-one correspondence between logical qubits and physical qubits. 

% The routing problem is defined as follows: during the execution of the circuit, if a gate $g_i$ cannot be executed under the current mapping \( \pi^{init} \), SWAP gates will be inserted to modify the mapping to $\pi^{modified}$, as illustrated in Fig. \ref{fig_2}(b). This adjustment ensures that the two physical qubits involved in gate \( g_i \) are directly connected, allowing the gate to be executed. By continuously inserting SWAP gates, a quantum circuit that satisfies the constraints of the given physical architecture is ultimately formed.

\section{Method}
This section provides an introduction to the proposed method for minimizing the additional insertion of SWAP gates. First, a layer-weighted subgraph isomorphism approach and a novel mapping completion method are presented to establish the initial mapping. Subsequently, a SWAP sequence search method is introduced to address the selection of SWAP gates. Finally, the approach incorporates a simplified iterative optimization framework, which significantly enhances the overall effectiveness of the mapping algorithm.
% This section elaborates on the proposed method for solving the qubit mapping problem to minimize the additional SWAP gates inserted. First, we will provide details of the generation and completion algorithms for initial mapping, ensuring the generation of appropriate initial mapping. Additionally, a method for intermediate qubit routing will be introduced to insert SWAP gates to meet the requirements of specific quantum devices. Finally, the approach involves a simplified iterative optimization framework that can significantly enhance the overall effectiveness of the mapping algorithm.


\begin{figure*}[t]
\centering
\includegraphics[width=0.95\linewidth]{initialmapping.pdf}
\caption{Paradigm of initial mapping generation. In Step 1, each gate in the quantum circuit is prioritized based on layer-weight assignment, with the number on the gate representing its weight. In Step 2, for the qubit interaction graph generated by the logical circuit, the weight on each edge is the sum of the weights of the gates acting on the respective qubits. In Step 3, the matching of the subgraph for a specific architecture is completed by gradually adding edges with higher priorities. In Step 4, for the unmapped qubits, their placement locations are determined to complete the mapping.}
\label{fig_6}
\end{figure*}
\subsection{Initial Mapping}
To address the mapping problem, we divided the entire algorithm into two parts, ultimately generating a reasonable initial mapping to reduce the number of subsequent SWAP gate insertions.
% Initial mapping  typically refers to the one-to-one correspondence between logical qubits and physical qubits. An example of a simple mapping is shown in Fig. \ref{fig_2}(a), where the mapping is represented as $\tau = \{q_0 : v_0, q_1 : v_1, q_2 : v_2, q_3 : v_3\}$. Under this mapping, the gate marked in red cannot be executed, as the mapped nodes are not directly connected, emphasizing the need to optimize the initial mapping.%初始映射指的是什么，在这个过程中需要解决的问题是什么。
%NOTE:后续介绍了初始映射的定义，以及在这个阶段中需要解决的问题就是 最大化可执行门数量，最小化SWAP数量。
% Typically, we first obtain an $LC(Q, G)$ describing a logical quantum circuit that involves many qubits and gates. A quantum physical device is usually described by $AG(V, E)$, where $V$ and $E$, respectively, represent the nodes of the physical device and the connectivity relationships between these nodes.  
% usually refers to the one-to-one correspondence between logical qubits and physical qubits. This process typically includes various approaches such as random mapping, naive mapping, and optimization-based techniques. The choice of strategy depends on factors such as circuit complexity, hardware constraints, and optimization goals. For simple scenarios or small-scale circuits, naive mapping is sufficient, in which logical qubits are directly assigned to physical qubits without optimization. 
% {An example of the naive mapping is provided in Fig. \ref{fig_2}(a). 
% In this example, the mapping is represented by $\tau=\{q_0:v_0, q_1:v_1, q_2:v_2, q_3:v_3\}$. Under this mapping, the first two gates in the circuit, $<q_0, q_1>$ and $<q_2, q_3>$, can be directly executed because the qubits mapped onto the physical architecture are adjacent. The gate marked in red cannot be executed as the mapped nodes are not directly connected, thus requiring a series of SWAP gates.}%所以初始映射是指，在线路执行过程中通过插入一些swap操作，使得逻辑线路在物理线路上可以实施？还有其它操作吗？这个过程中主要需要考虑的问题是swap的位置？在介绍初始映射时，需要将这些表示清楚，一般是怎么实现的，怎么处理swap位置的，存在的问题是什么。我们注意到了哪些操作可以提升这一问题。所以后面进一步介绍自己的工作。
%NOTE:初始映射中没有涉及到SWAP的插入，只有在routing这一块才会设计SWAP插入，这相当于是两个独立的部分。initial mapping:只是给定得到一个映射关系，该映射关系能够满足线路中一些CNOT门操作执行 routing:考虑插入SWAP操作，改变映射关系执行原本不满足架构限制的操作。
% { Generally speaking, these are more complex circuits that require the use of advanced techniques such as optimization algorithms which employ heuristic functions or simulated annealing to generate initial mappings, the objective is to optimize the mapping to ensure the execution of more CNOT gates, thereby reducing the number of SWAP gates required.}

% \xk{In this process, it is preferable to maximize the number of CNOT gates that adhere to the mapping, as this effectively minimizes the number of subsequent SWAP gates}. 

% \begin{figure}[!t]
% \centering
% \includegraphics[width=0.9\linewidth]{Fig/new_fig7.png}
% \caption{Mapping logical qubits in a quantum circuit to physical hardware architecture nodes. (a) Quantum circuit with three qubits and three CNOT gate operations, (b) The qubits are mapped to a part of the IBM Q20 architecture.}
% \label{fig_6}
% \end{figure}


% all quantum gates in the circuit are executable because all logical qubits have been mapped and there are connected edges between the mapped nodes.
% From the above example, two constraints of the initial mapping can be derived:
% \begin{enumerate}
% \item{} Each logical qubit can be mapped to only one physical node.
% \item{} CNOT gate operations can only be applied to two directly connected nodes. If two nodes are not directly connected, they need to be transformed to be adjacent to support gate operations.
% \end{enumerate}
% By fully considering these constraints, reasonable algorithms can be designed to improve the effectiveness of the initial mapping, thereby reducing the cost of the overall route.
\subsubsection{\bf{Layer-Weighted Isomorphism Mapping Algorithm}}
We are addressing the connectivity issue and have proposed a layer-weight-based method to fully consider the priority of each gate in the circuit through weight assignment, %\yukun{to generate a good initial mapping}.%good initial 是指swap少的？层权重是怎么可以减少swap的
{thereby enabling the execution of more CNOT gates at the front of the circuit and reducing the distance between subsequent gates.}
%NOTE:good initial指的是能够满足的CNOT数量多。
This method prioritizes quantum gates located at the front of the circuit, ensuring that they have the highest priority. When multiple gates can be executed simultaneously, they are assigned equal weights, making this weight-based layer approach intuitive and rational. The process is detailed in Steps 1 to 3 in Fig. \ref{fig_6}. Initially, the circuit is partitioned, ensuring qubits of any two gates in the same layer do not intersect. Then, for each gate $g_i$, a corresponding weight is assigned using the following weight function:
\begin{equation}
\label{eq1}
W_{g}(g_i )=(Depth(LC)-Layer(g_i ))+1,
\end{equation}
where $Depth(LC)$ represents the circuit depth after the partition of $LC$, and $Layer(g_i)$ represents the layer number where $g_i$ is located.

Then for any given quantum circuit $LC$, after denoting $IG(Q, E)$ to describe the interactions between qubits in the quantum circuit, we use the layer weight (Eq. \ref{eq1}) to assign a value for each gate in the circuit. In $IG$, the weight on each edge is the sum of the weights of the corresponding gates, described by the following formula:
\begin{equation}
\label{eq2}
W_{e}((p,q))=\sum_{p\, \&\, q\ in\ g_i}^{LC} {W_{g}(g_i)},
% E_{weight}((p,q))=\sum_{(p,q)\ in\  g_i}{G_{weight}(g_i)},
\end{equation}
where the criterion implies that both qubits $p$ and $q$ should be involved in the quantum gate $g_i$, and $(p,q)$ represents the edge between the two qubits. 
% Fig. \ref{fig_7} clearly illustrates the layer-weight-based assignment method. By evaluating the priority of each gate in the circuit, the weight of each edge in $IG$ is obtained.



% After obtaining the $IG$ with layer-weight assignment, the subgraph isomorphic matching algorithm is introduced to accomplish the task of initial mapping generation.
% Subgraph isomorphism matching aims to find a subgraph in a larger graph $G_{big}$ that exactly matches the structure of a given smaller graph $G_{small}$. Generally, if $G_{small}$ can be embedded in $G_{big}$, then there exists a subgraph in $G_{big}$ that is isomorphic to $G_{small}$. 
% The commonly used subgraph isomorphic matching algorithm is the VF2\cite{1323804} algorithm. 
%Although the subgraph isomorphism matching problem is NP-complete, algorithms such as VF2 can effectively tackle graph matching problems with thousands of nodes within a reasonable timeframe.  Given that current quantum computing development is in the NISQ era, where most quantum circuits involve fewer than 100 qubits, the VF2 algorithm can swiftly and effectively accomplish the task.
% , so it is wise to adopt this algorithm.
\begin{algorithm}[t]
    \SetAlgoLined %显示end
	\caption{Initial mapping employing subgraph isomorphism and layer-weight }%算法名字
        \label{alg1}
	\KwIn{A logic circuit $LC$, a architecture graph $AG$.}%输入参数
	\KwOut{A mapping of logical qubits to physical qubits $result$.}%输出
$LC\_{depth}, Layer = Partition(LC)$\;
$W_e = \{\,\}, G_{im} = \{\,\}$\;
$IG = LC\_to\_IG(LC)$\;
 %\;用于换行
	\For{$g$ in LC}{
$W_g(g) = LC\_depth - Layer(g) + 1$\;
		\eIf{ $(g_{\cdot} c, g_{\cdot} t )$ in IG }{
		 $W_e((g.c, g.t)) += W_g(g)$\;
		}{
 $W_e((g.t,g.c)) += {W_g(g)}$;}
 }
$sort(W_e)$\;
\For{$edge\ in\ W_e$}{
\If{ $subgraph\_isomorphism (G_{im} \cup edge,\ AG)$ }{$G_{im} = G_{im} \cup edge$\;}
}
{$temp\_result = vf2_{\cdot} dfsMatch(G_{im},\ AG)$}\;
{$result = Finalizing(AG,\ IG,\ W_e,\ temp\_result)$}\; 
{\textbf{return} $result$}\;
\end{algorithm}
After obtaining the $IG$ with layer-weight assignment, we utilize the VF2 algorithm \cite{1323804}, a widely used subgraph isomorphic matching algorithm, to maximize the embedding of edges contained in the $IG$ into the $AG$, thus establishing the correspondence between logical qubits and physical qubits. The initial mapping algorithm is described in Algorithm \ref{alg1}. It takes the logical circuit and a specific hardware architecture as inputs. Initially, the logical circuit is partitioned into layers using the function $Partition$, which determines the depth of the quantum circuit and assigns each gate to its corresponding layer number. Subsequently, the function $LC\_ to\_ IG$ converts the logical circuit into a qubit interaction graph ($IG$). Each gate is then assigned a weight based on its layer position, and these weights are associated with the edges in $IG$. Finally, the edges in $IG$ are sorted based on their weights in descending order, establishing the priority of each edge. Upon successive addition of each edge to $W_e$ to form the graph $G_{im}$, which represents the current maximum subgraph matched. If the addition of an edge makes $G_{im}$ isomorphic to any subgraph in the hardware architecture $AG$, then the edge is included in $G_{im}$. This process continues until all edges have been traversed. 
% Here isomorphic matching judgment of $G_{im}$ and $AG$'s subgraphs is utilized by the VF2 algorithm, and the corresponding mapping relationship can also be obtained. After the mapping is acquired, it is then passed to the subsequent completion algorithm to achieve a complete mapping.

{{For example, }%这个例子给了一个初始映射的例子，这个例子按权重给出一个初始的映射，然后存在一个Q4未被映射上，后续采取补全策略。但没展示初始映射需要解决的问题，什么是好的初始映射？
%NOTE:
in step 3 of Fig. \ref{fig_6}, we begin by incorporating the edge set $\{(q_0, q_1), (q_2, q_3)\}$ to form the graph $G_{im}$, based on the priority of edges obtained in step 2, because these two edges can be embedded into the architecture graph. $(q_0, q_2)$ is then added to {$G_{im}$}%这个符号第一次出现？根据这个例子，初始映射就是先给一个一一映射，未被映射的采取补全，不能执行的操作后续加swap操作。好的一一映射要使得尽可能多的边连接？尽可能做的qubit映射上？这个在初始映射部分说清楚。其中的困难是是什么，good 映射指什么。子图同构算法的优势是什么？这里面考虑了哪些优化策略，后面补全也是为了不全初始映射。补全要考虑哪些问题，有什么优化策略，别人都是怎么做的。未考虑到哪些因素。
, and it remains compatible with the architecture graph. For the subsequent edges $(q_1, q_3)$, $(q_0, q_3)$, and $(q_0, q_4)$, adding any of these to $G_{im}$ does not fit within the architecture graph, so these edges are excluded from $G_{im}$. Ultimately, a graph is obtained that includes the edges $\{(q_0, q_1), (q_0, q_2), (q_2, q_3)\}$, which can be embedded in \(AG\), while a qubit labeled \(q_4\) remains unmapped. The red parts illustrate the feasible mapping relationships, one of which is represented by the mapping $\tau = \{q_1: v_1, q_0: v_2, q_2: v_3, q_3: v_4\}$. This mapping enables the execution of three CNOT gates, whereas the naive mapping can only execute two, thus making the proposed approach more efficient.}
\begin{algorithm}[t]
    \SetAlgoLined %显示end
	\caption{Finalizing the initial mapping}%算法名字
        \label{alg2}
	\KwIn{A architecture Graph $AG$, a interaction Graph $IG$, an edge weighted graph E$_w$, a transient mapping T$_m$. }%输入参数
	\KwOut{A modified final mapping $result$. }%输出
{$result = T_m$}\;
\While{$existing\ unmapped\ qubits$}{
{$maximum = 0$}\;
$free\_place = adjacent(result,\ IG)$\;
\For{$qubit\ in\ IG.nodes$}{
$T = result$\;
\If{ $qubit\ is\ not\ mapped$}{
\For{$node\ in\ free\_place$}{
$T.update({qubit: node})$\;
$F = F_{val}(T,\ E_w,\ AG)$\;
\If{$F\,\textgreater\,maximum$}{
$maximum = F$\;
$cand = \{qubit: node\}$;
}
}
}
}
$result.update(cand)$\;
}
{
\textbf{return} 	$result$\;
}
\end{algorithm}
\subsubsection{\bf{Mapping Completion Algorithm}}
% \yukun{Since there may be a few discrete unmapped qubits by using subgraph isomorphism to solve the initial mapping problem, we propose a heuristic function based on weight and distance to evaluate the most suitable placable nodes.}%因果不对，不能是因为未完整，提出启发函数，启发韩式只是工具，要说明用它干啥。
% %note:其实有说明是选择一个合适的位置以进行放置。
Since subgraph isomorphism may result in discrete unmapped qubits during the initial mapping process, we introduce a completion algorithm to address this issue.
% The completion is based on a heuristic approach, %\yukun{where the heuristic function utilizing weight and distance}%位置和权重如何起作用的，作为启发函数不是根本原因。
%NOTE:后续对于起作用的原因进行了介绍
%effectively \yukun{combines and balances }the relationships between \yukun{different factors} to comprehensively assess the most suitable available nodes.%completion 过程考虑哪些因素？
{The primary objective is to map the unmapped qubits to the most suitable free nodes, thereby reducing the distances between gates involving these qubits and subsequently minimizing the number of SWAP gates. As the two most critical attributes of gates are distance and weight, the optimal scenario for circuit execution is to enhance the number of executable gates by reducing the distances for gates with greater weights.}
In Step 4 of Fig. \ref{fig_6}, the mapping completion algorithm serves a discriminative function to determine the optimal positions. The algorithm details are outlined in Algorithm \ref{alg2}.
% 表述有无问题？
% note: 合理
% The Algorithm is shown in Algorithm. \ref{alg2}.


%The first step is to find the unmapped logical qubits. , which can be easily derived from the transient mapping $T_m$. %To reduce the\yukun{search space}, %这里的search space指什么？之前需要大体介绍下你算法的思想，在已有节点周边选择physical qubit进行映射补全？所以才有search space 的事情。
%Note:具体下来，说明了结点放置越紧密，越能够减少两比特门对应结点的距离，所以才将候选集设定在距离已放置结点为1的地方。
{Considering that a closer placement of qubits leads to a reduction in the distance between the two qubits of the CNOT gates}, the candidate nodes refer to the free nodes that are located adjacent to the already deployed nodes. For all logical qubits, if the qubit has not been mapped yet, the corresponding function value is calculated for placing it on each available node, and the position \(v\) with the maximum function value is identified for \(q\). The detailed content of the function $F_{val}$ is as follows:
% argmax_{v} 
\begin{equation}
\label{eq3}
F_{val}(q,v)=\sum_u(dia(AG)-dis(u,v))*E_w(u,v), 
\end{equation}
where $q$ represents an unmapped qubit, $u$ is the node in $AG$ that has been mapped by $q$'s neighboring logical qubit, and $v$ is a previously mentioned free candidate node in $AG$. The $dia(AG)$ stands for the diameter of $AG$, $dis(u,v)$ is the distance between the nodes $u$ and $v$, and $E_w(u,v)$ represents the edge weight between logic qubits corresponding to the nodes $u$ and $v$.

The proposed heuristic function effectively accounts for the relationship between the evaluation node positions and their corresponding weights. If the distance between the free node $v$ and the already placed node $u$ is short, and the weight value between them is high, it indicates that the mapping can execute more CNOT gates. Therefore, selecting the logical qubit $q$ and the free node $v$ with the highest function value enables a good completion of the current mapping algorithm, and adding this mapping relation to the current mapping completes the update. This process continues iteratively until all logical qubits are mapped to appropriate free nodes. Ultimately, the algorithm returns a final mapping result, where each logical qubit is mapped to a corresponding physical hardware node, completing the mapping process.

{For example, as illustrated in step 4 of Fig.\ref{fig_6}, the placement position for the unallocated qubit $q_4$ is determined using the evaluation function specified in Eq. \ref{eq3}. 
The function is calculated for two potential mapping positions:
\begin{align}
F_{val}(q_4 \rightarrow v_0) = (5 - 2) \times 1 = 3.\\
F_{val}(q_4 \rightarrow v_5) = (5 - 3) \times 1 = 2.
\end{align}
These calculations reveal that mapping qubit $q_4$ to $v_0$ results in a higher evaluation score of 3, in contrast to a score of 2 for mapping it to $v_5$. To optimize the evaluation function and ensure the most effective placement, $v_0$ is chosen as the mapping position for qubit $q_4$. As a result, the final mapping relationship is expressed as $
\tau = \{q_1: v_1, q_0: v_2, q_2: v_3, q_3: v_4, q_4: v_0\},
$ which demonstrates that it is a complete mapping and each logical qubit is assigned a specific position within the architecture graph.}



\subsection{Intermediate Qubit Routing}
The initial mapping obtained above typically fails to meet the requirements for executing all CNOT gates, requiring additional SWAP gates. To tackle this, we divide the proposed qubit routing algorithm into two stages: SWAP sequence selection and post-processing to refine the optimal sequence.
%\yukun{By maintaining these two stages, the efficiency of the generated SWAP sequence and the quality of the qubit mapping algorithm will be satisfactory.}%这句不用要了
%Note:描述性语句已删除
% ensured to be 
\begin{figure}[!t]
\centering
\includegraphics[width=\linewidth]{SWAPsequence1.pdf}
\caption{{Diagram of SWAP sequence insertion. Four CNOT gates cannot be executed in the circuit. After determining the optimal SWAP sequence through a Depth-2 sequence search and the subsequent post-processing stage, the mapping relationship is adjusted to ensure the execution of three CNOT gates.
%yields the \yukun{highest value for the average number of gates that each SWAP gate can execute.}%？什么意思
}%
}
% 指的是 平均每插入一个SWAP的代价，能够使得多少个CNOT门执行，我们目标是最大化这个可执行CNOT门数量。

%问题1：你这个例子是线路在执行过程中依此查看？q0,q1可执行，q3,q4可执行，遇到q0,q2不可执行，此时在swap序列里搜索合适的swap序列，使得q0,q2可执行？
%回复1：是的，这是在线路的运行过程中进行判断的；遇到可以执行的门就进行执行，而遇到不可以执行的门，我们将其涉及的量子比特给记录下来，相当于锁死了，后续有涉及这些比特的门都无法执行，直到所有的量子比特都被锁死。就从SWAP候选集中选出序列进行eq.7值的判别。

%问题2：上个问题中涉及q0,q2不可执行时，在哪些swap序列里搜索？ 在涉及q0,q1,q2,q3所有序列里？ 如果线路比较大，n个比特是意味着在E^n中搜吗？
%回复2：2.1 在3.3.1的结尾处，我们提到到了---最坏的情况下----的序列数量，前提是 ---搜索深度--- 为n , 那么对于任何一个SWAP门，其可能落在架构AG(我们认为架构的边数量为|E|, )的任意一条边上， 所以一共会有 O(|E|^n) 个候选序列。  2.2 在真正实验的时候，我们只考虑前3层涉及到的qubit,在这个情况下就会是(q0,q2,q3,q4),就是任何一个SWAP操作都会至少涉及到 这四个中的一个qubit。  3.3 线路比较大，假定为N (为了区分前面搜索深度的n) 个qubits; 最坏情况下也只是在单个SWAP操作出现的位置也只会是架构的边数量为|E|(通常来说|E|>N 的)之中，影响序列数量最为关键的因素只会是搜索深度，因为它在指数上。(例子:figure 6 中例子， 如果搜索深度为2，对于N(这里是5)个比特的线路， 架构的边数为|E|, 那么我们得到的SWAP序列数量就会有 O(|E|^2) {也就是序列长度为1的时候会有 |E|种情况，序列长度为2的会有 |E|^2种情况，一共就会有|E|+|E|^2，也就是O(|E|^2) }个 ， )

%问题3：你例子中是同时考虑的q0,q2;q2,q4的执行与否？ 选适当的SWAP序列使得它们能被执行，此时候选Swap序列是涉及到q0,q1,q2,q3的所有Swap?  这个例子比较简单刚好只涉及q0,q1,q2,q3的SWAP就完成了。在实际中，怎么确定Swap的搜索空间？ 有可能所涉及的bit之间的SWAP不够，还需要关于其它qubit的swap？ 还有在实际中一次看几个不能执行的门操作？ 这个怎么处理的。
%回复3：3.1 SWAP序列的判别遵循eq.7,因此是同时会考虑到后续的门执行与否，而不是单纯的一个门q0,q2; 3.2 是的上面一致，这里如果我们设定SWAP序列搜索深度为1，那么就只会有(4种SWAP进行判断，如果Q4右边还接了一个Q5，那么就会有5种SWAP操作进行判断，因为 边Q4-Q5涉及的SWAP操作中含有q4.) 3.3 与问题2一致，我们通过大量实验说明了，(在平衡最终效果和运行时间)搜索深度设置在2或者是3就已经足够了，那么搜索空间最坏就是O(|E|^n （n为搜索深度 2 or 3）)。  3.4 涉及的bit之间SWAP不够？ 指的是CNOT门相距太远？ 对于在给定的搜索序列中，如果任何一个序列都没法执行一个门操作，即eq.7最大值是0，那么就插入一个SWAP操作使得front_layer的CNOT中两比特距离最小的门 接近。 3.5 一次看几个不能执行的门操作？ 首先，在实验中 SWAP候选集只会涉及到前面3层的qubits， 在eq.8中才会涉及到一个滑动窗口的概念，也就是向后看多少个门的概念，这里我们只是也只是按照经验划分，将窗口大小设置为 30 或者 其他大小 第四章节的开头部分有提到。

%在实际的运行中，我们手上只有门的序列[[0,1],[3,4],[0,2],[2,4],[3,4],[0,3]] , 以及一个对应的映射关系{q0:Q0,q1:Q1,q2:Q2,q3:Q3,q4:Q4}, 假设还会有一个Q5, 如果给定了一个SWAP(Q4,Q5),那么就会有{q0:Q0,q1:Q1,q2:Q2,q3:Q3,q4:Q5}, 但是在逻辑线路上无法呈现SWAP(Q4,Q5)，除非在引入一个ancilla比特映射到Q5来说明这一个过程。

\label{fig_8}
\end{figure}

\subsubsection{\bf SWAP Sequence Selection}
We introduce a method for selecting SWAP sequences to better accommodate the initial mapping algorithm proposed in the previous section. First, we introduce the set \( Edges_{tp} \)where each element represents a SWAP gate that involves at least one qubit from the look-ahead three layers of the currently unexecutable circuit. We also assume that the number of elements in this \( Edges_{tp} \) is $t$. Therefore, for a SWAP sequence of length $d$, it is formulated as $seq_i = \{ \text{SWAP}_1, \text{SWAP}_2, \ldots, \text{SWAP}_d \} $, with each $\text{SWAP}_k \in  Edges_{tp} $. There are a total of $O(t^d)$ possible $d-$length swap sequence, and the collection of all such sequences forms $SQ_d$. For the SWAP sequence search with depth $d$, the set is defined as $seq = \{ SQ_1, SQ_2, \ldots, SQ_{d} \}$, where the number of elements in $seq$ is $O(t+t^2+\ldots+t^d)$. For a quantum device $AG(V, E)$, the total number of candidate SWAP sequences is $O(|E|^d)$ in the worst case.%and the definition of Depth-$n$ SWAP sequence search is as follows: 
%\begin{equation}
%\label{SWAP_seq}
 %{seq_i = \{ \text{SWAP}_1, \text{SWAP}_2, \text{SWAP}_3, \ldots, \text{SWAP}_l}% 问题1：需要说明Swap_1,...到Swap_n来着哪里？是涉及哪些qubit的？还是每次遍历所有的$AG(V, E)$？；问题2：第一次出现下标i,i需要说明。
% \} ,
%回复1：我们其实就在公式(6)的底部有进行标注， 每一个SWAP门都可以被应用在架构的任何一条边上，对于每一个序列，不超过n个SWAP门操作。
%\end{equation}
%where for any \( seq_i \) in \( seq \), the conditions \( 1 \leq l \leq n \) and \( SWAP_k \in candi\_SWAP \) are satisfied. 

 %where each SWAP gate can be applied to any edge in the architecture and there are no more than $n$ SWAP gates in each candidate sequence $seq_i$, where $i$ represents the index of the sequence (as there are many candidate SWAP sequences). For a quantum device $AG(V, E)$, the total number of candidate SWAP sequences is $O(|E|^n)$ in the worst case.} 
% This approach, similar but distinct from FIDLS\cite{li2020qubit}, \yukun{limits the search space of SWAP sequences to improve effectiveness.}
%先以例子介绍以下SWAP序列的问题，搜素空间的问题，搜索空间会导致什么问题。
%介绍了SWAP搜索序列的定义，搜索空间
% along with restrictions on the search space for SWAP sequences, to efficiently accomplish the task.
%\xk{For the gates to be executed in the circuit, these front gates hold a higher priority, so the restriction range for SWAP gate sequences is set such that at least one qubit involved exists in the first few layers of the remaining circuit. Compared to considering all qubits in the circuit or all edges of the architecture, this will reduce the number of candidate SWAP sequences.}

%\yukun{This will significantly reduce the number of SWAP gate combinations.}%这怎么减少了数量
%NOTE:加上解释考虑的qubits越少，那么总的SWAP序列数量就会越少。
 %图6没有展示出来具体Swap插入，搜素序列，空间这些问题。这个图给的比较简略，没有有用信息。这里在展示问题时可以用些数量表示。
%NOTE：修改绘图
For the evaluation of each SWAP sequence, the average number of two-qubit gates executable per SWAP gate is selected as the primary metric. This approach is considered more direct and insightful than a distance-based evaluation between gates. Consequently, the heuristic function is defined as follows, with the optimal sequence $seq_{opt}$ chosen to maximize this heuristic function:
\begin{equation}
\label{eq4}
% Gval(\tau^{current},seq)=\frac{num\ of\ gates\ executable\ by\ \tau^{update}}{len (seq) }.which may not satisfy subsequent gate requirements, necessitating transformations to enable their execution
Gval(\tau^{current},seq_i)=\frac{{\rm Executable\ gate\ count\ under}\ \tau^{'}}{len (seq_i) },
\end{equation}
where $\tau^{current}$ denotes the current mapping, $len(seq_i)$ indicates the number of SWAP gates contained in the $seq_i$. \( \tau' \) represents the mapping relation corresponding to \( \tau^{current} \) after the insertion of the SWAP gates included in \( seq_i \).

Finally, after determining the SWAP sequence $seq_{opt}$ corresponding to the maximum function, the SWAP gates in the $seq_{opt}$ are inserted sequentially. However, since the calculation may have multiple maximum function values $Gval$, further judgments are required to determine which SWAP sequence is optimal. This additional processing is conducted in the post-processing stage to make a more reasonable decision. Besides, if a suitable SWAP sequence cannot be found within the set search limit to enable the subsequent gates to be executed, an alternative approach is adopted. {The CNOT gate whose corresponding two qubits are closest }%啥意思
%NOTE：也就是一个CNOT门对应两个结点，然后两个结点会有距离。
in the front layer is selected, and then a SWAP gate is applied {to reduce the distance between them.}% swap能减少距离？
%NOTE：通过交换，减少比特之间的距离
This ensures that the routing algorithm runs smoothly, preventing situations where CNOT gates cannot be executed within the specified search depth.
\begin{algorithm}[t]
  \SetAlgoLined
  \caption{Routing operation optimization}
  \label{alg3}
  \KwIn{A logical circuit $LC$, an architecture graph $AG$, an initial mapping of input $\tau^{initial}$. }
  \KwOut{A physical circuit adapted to a specific architecture $PC$, the mapping at the end of the quantum circuit $\tau^{current}$.}
$\tau^{current} = \tau^{initial}$\;
$PC = [\,]$\;
  \While{$existing\ unexecuted\ gates$}{
    $EG = Executable\_gates(LC,\ AG,\ \tau^{current})$\;
    \For{$gate\ in\ EG$}{$LC.delete(gate)$\;
				$PC.add(gate)$\;
}
    \If{$len(LC)\, ==\, 0$}{break\;}
    Find the maximum swap sequence $seq_{opt}$ that satisfies the heuristic function Eq. \ref{eq4}\;
    $SP = argmax\ dw(LC,\ AG,\ \tau^{current},\ seq_{opt})$\;
    $PC.add(SP)$\;
   $\tau^{current}=transformation(\tau^{current},\ SP)$\;

    }
\textbf{return} $PC,\ \tau^{current}$\;

\end{algorithm}
\subsubsection{\bf The Post-Processing Stage}This stage aims to address the situation where multiple identical maximum \( G_{\text{val}} \) values exist. Given that our primary objective is to execute more gates per SWAP, it is therefore reasonable to treat Eq.\ref{eq4} and this stage separately. Specifically,
if two mappings, $\tau^{'}_{1}$ and $\tau^{'}_{2}$ (more mappings of the same value are also applicable), have the same $Gval$ value, specifically $Gval(\tau^{current},{seq}_{{opt}} ^1)= Gval (\tau^{current},{seq}_{opt}^2)$. Then an evaluation function based on weight and distance is proposed to further assess their merits, thereby improving the routing algorithm. Given that gates in the rear have a relatively small impact on the mapping algorithm, and considering the potentially large number of subsequent gates, a significant amount of additional calculations will be introduced. Therefore,  a look-ahead window is set, with its size determined by the hyperparameter $wnd$. The evaluation function for post-processing is:
\begin{equation}\label{eq5}
\begin{split}
% &argmax_{\tau^{'} } \ dw(\tau^{'} )=\sum_{g_i\ in\ LC}^{window\_size}W(g_i )* \\&(diameter(G) -dis(\tau^{'}(q),\tau^{'}(p))),\\&
 dw(\tau^{'})=\sum_{g_i\, \in \, LC}^{wnd}W_g(g_i )*(dia(AG)-dis(\tau^{'}(q),\tau^{'}(p))),
\end{split} 
\end{equation}
where $W_g(g_i)$ represents the weight of gate $g_i$, $dis(\tau^{'}(q),\tau^{'}(p))$ represents the distance of qubit $q$ and $p$ in the gate $g_i$ under the mapping relationship $\tau^{'}$.
% The design of this evaluation function can comprehensively weigh \yukun{ various factors},%哪些介绍出来，这些怎么影响swap序列选择。
%NOTE:various factors指的是后续的weight and distance,为了简洁将这里省略，前一部分有同样也是利用了这两个factor,有相关的介绍。
% providing better decision criteria and guidance to optimize the quality and efficiency of the qubit mapping algorithms. 
\begin{figure*}[t]
\centering
\includegraphics[width=0.9\linewidth]{iterate.pdf}
\caption{A simplified iterative optimization framework for the whole qubit mapping problem.}
\label{fig_5}
\end{figure*}

By integrating both weight and distance considerations, this function appropriately assesses the influence of these factors simultaneously. This block resembles the heuristic function Eq. \ref{eq3} proposed earlier for initial mapping, but with a difference: it primarily focuses on the distance of each gate and its associated weight. Both are effective in completing the corresponding tasks.
% Both factors play crucial roles in completing the  in tasks effectively.
Algorithm. \ref{alg3} combines the SWAP sequence selection and post-processing to optimize intermediate qubit routing. It takes inputs such as the logical circuit, the physical hardware architecture, and the generated initial mapping. Initially, it identifies executable gates (EG) based on the current mapping, transferring them from the logical circuit $LC$ to the physical circuit $PC$. The algorithm iterates until all gates in $LC$ are executed. During each iteration, it calculates the SWAP sequence with the largest $Gval$ and applies post-processing to find the most suitable sequence using the discriminant function $dw$. The selected SWAP gates are then inserted into $PC$ sequentially, and the current mapping is adjusted according to the SWAP sequence using the transformation function. This process continues until all gates are executed and the modified physical circuits $PC$ and $\tau^{current}$ are returned.  

To clearly illustrate the entire SWAP sequence insertion process, the schematic diagram of the insertion of the SWAP sequence is shown in Fig. \ref{fig_8}. Under the mapping $\tau^{current}$, two CNOT gates can be executed, while four CNOT gates (marked in red) cannot. We choose a Depth-2 sequence search in this example. After applying the heuristic evaluation functions in Eq. (\ref{eq4}) and Eq. (\ref{eq5}), the optimal SWAP sequence is selected and inserted into the circuit, resulting in the mapping \( \tau' \), which enables the execution of the subsequent three CNOT gates.


In general, the intermediate qubit routing algorithm can take into account many factors such as the size of the search space, weight information, and distance between qubits. Compared with many other intermediate qubit routing algorithms, it can comprehensively assess the influence of {weight and distance} and effectively balance their relationships. This also enables the mapping algorithm to outperform many existing algorithms in terms of overall effectiveness.

\subsection{{Simplified Iterative Optimization Framework}%这个框架是不是放最后好一些？你斟酌下放这里还是子算法结束后。
%稍后将此部分放置在这一节末尾
}
To find the case with the minimum number of SWAP gates, one could repeatedly run the routing algorithm for the entire circuit. However, in a quantum circuit consisting of $n$ qubits, there are $n$! potential initial mappings. Therefore, exhaustively evaluating these mappings to assess their quality incurs a significantly high time complexity. To efficiently alleviate the need for additional SWAP gate insertions in the circuit and enhance initial mappings, we propose a simplified iterative optimization framework, which can effectively mitigate the high complexity problem caused by exhaustive methods through a small number of iterations.

The simplified iterative optimization framework, depicted in Fig. \ref{fig_5}, takes the {$Initial\_mapping$ }
as input, which defines the relationship between logical qubits and physical qubits. {It incorporates a common forward-backward traverse technique \cite{li2019tackling} to optimize the qubit mapping, where the quantum circuit's gates are traversed in both forward and backward directions. The process typically begins with a random initial mapping and then refines it using the routing algorithm and its inverse circuit, resulting in a mapping that better aligns with the connectivity requirements of the initial gates. }
Unlike other algorithms based on this technique, our focus extends beyond initial mapping generation to optimizing circuit mapping results during the iterative process. Compared to the iterative algorithm presented in \cite{zhu2021iterated}, our algorithm incorporates an effective initial mapping rather than a random one to enhance the comprehensive performance of the algorithm. Additionally, we prioritize the performance of the intermediate qubit routing algorithm, as it is more crucial within the overall qubit mapping algorithm.
Thus, we simplify the shuffling perturbations towards optimal mapping, reduce the number of high iterations, and address other relevant aspects during the iteration process, which reduces computational resource requirements.


After completion of {the forward-traverse }
phase of the quantum circuit, the $Temp\_mapping$ at the end of the circuit is preserved for input into the inverse circuit, then the circuit is processed again by the routing algorithm to execute all the gates. This process ultimately yields $Final\_mapping$. The $Final\_mapping$ is then iteratively input back into the initial circuit. Ultimately, our objective is to preserve the best mapping and quantum circuit with the smallest number of additional SWAP gates inserted throughout the iterations.  Within the iterative framework, the parameter $N_i$ indicates the number of iterations required for optimization. Importantly, it is crucial to track the circuit execution direction at minimal cost during the iteration process.  This is because the case with the minimum number of SWAP gates inserted may occur in the backward-traverse phase, where it is necessary to invert the current circuit to obtain the target quantum circuit. 

\textbf{Complexity Analysis.} As for the analysis of the algorithm's time complexity. In the worst-case scenario, for any given architecture $AG(V, E)$ and quantum circuit $LC(Q, G)$, if the SWAP sequences have length $l$, there will be $O(|E|^l)$ possible sequences. The computational complexity of each sequence is linearly related to $wnd$, and if only one gate is executed each time, there will be a maximum of $|G|$ iterations. The entire process requires $N_i$ iterations. Therefore, the overall time complexity of the iterative framework, including routing, is $O(N_i \cdot |E|^l \cdot wnd \cdot |G|)$.

\section{Experiments and Evaluation}
In this section, we will evaluate the proposed HAIL algorithm and compare its performance with that of other algorithms across various benchmarks and coupling architectures.

\textbf{Benchmarks.} We evaluate the proposed algorithm using publicly available benchmarks, including $\mathcal{B}_{23}$, which contains 23 quantum circuits categorized by gate count: small ( $<300$ gates), medium ($300-4000$ gates), and large ($\ge4000$ gates). Additionally, we assess the algorithm's performance across various scenarios using multiple benchmarks \cite{zhou2020monte}. These benchmarks, limited to 20 qubits, include single-qubit operations (e.g., $H$, $T$, $Ry(\theta)$) and CNOT gates. A detailed description of these benchmarks is provided in Table \ref{tab:benchmark}, allowing for a comprehensive evaluation of the algorithm across different circuit scales.
\begin{table}[ht]
\caption{Characteristics of the benchmark set}
    \centering
    \scalebox{0.8}{ % Resize to column width
        \begin{tabular}{m{2.5cm} c c} % Set fixed column widths
            \toprule
   {\centering Benchmark Name
    /Number of Circuits}& {Total Number of Gates}
            & {Average CNOTs per Circuit} \\ \midrule
            \centering $\mathcal{B}_{23}$/23        & 63333    & 1202.609   \\
            \centering $\mathcal{B}_{114}$/114      & 554497   & 2180.289   \\
            \centering $\mathcal{B}_{ran}$/170      & 34000    & 200        \\
            \centering $\mathcal{B}_{real}$/173     & 603654   & 1506.295   \\ \bottomrule
        \end{tabular}}
    \label{tab:benchmark}
\end{table}

\textbf{Hardware Architecture.}
Commonly used quantum architectures, such as the IBM Q20 (Fig. \ref{fig_4}(c)) and the Google Sycamore (Fig. \ref{fig_4}(d)), were employed to evaluate the algorithm’s adaptability by considering architectures with varying levels of sparsity. 

\textbf{Algorithm Configuration.} To distinguish between different SWAP search depths during the routing phase, we defer to the algorithm with a search depth of $n$ as HAIL-$n$. The number of iterations $N_i$ is fixed at 5, and each SWAP gate involves at least one qubit from the first three layers of the remaining gates. Additionally, to adjust $wnd$ dynamically, if the remaining gates $rg$ exceed 4000, $wnd$ is set to $\lfloor 1.5*\sqrt{rg}\rfloor$, otherwise, it remains at 30.

\textbf{Experimental Platform.}
All experiments were conducted on a personal laptop featuring an Intel(R) Core(TM) i5-8300H CPU @ 2.30GHz, paired with 16 GB of DDR4 RAM.

\textbf{Comparative Algorithms.}
To validate the effectiveness of the proposed algorithm, we compare it with state-of-the-art algorithms like SABRE\cite{li2019tackling}, ILS\cite{zhu2021iterated}, TWP\cite{qian2023method}. Since TWP is an improvement of FIDLS\cite{li2020qubit} and exhibits superior performance, it has been selected for comparison.





% These circuits come in various sizes, thus enabling the assessment of the effectiveness and applicability of the proposed algorithm. 
% In our qubit mapping algorithm, we don't utilize gate permutation and cancellation properties. Hence, we preprocess the benchmark to remove single-qubit gates, retaining only two-qubit gates to simplify the mapping process. The widely used IBM Q20 architecture serves as our benchmark. When evaluating algorithm performance, the number of additional inserted gates significantly impacts circuit quality, so we use this as our evaluation criterion. 

\makeatletter
\newsavebox{\@tabnotebox}
\providecommand\tmark{} % so having ctable or not is irrelevant
\providecommand\tnote{}
\newenvironment{tabularwithnotes}[3][c]
{\long\def\@tabnotes{#3}%
\renewcommand\tmark[1][a]{\makebox[0pt][l]{\textsuperscript{\itshape##1}}}%
\renewcommand\tnote[2][a]{\textsuperscript{\itshape##1}\,##2\par}
\begin{lrbox}{\@tabnotebox}
\begin{tabular}{#2}}
{\end{tabular}\end{lrbox}%
\parbox{\wd\@tabnotebox}{
\usebox{\@tabnotebox}\par
\smallskip\@tabnotes
}%
}
\makeatother
\begin{table*}
\renewcommand{\arraystretch}{1.4}
\label{table1}
\caption{Number of additional gates compared with SABRE\cite{li2019tackling}, ILS\cite{zhu2021iterated}, and TWP\cite{qian2023method} algorithms on benchmark $\mathcal{B}_{23}$.\label{table1}}

\centering


% \begin{tabularwithnotes}{lr}
% {
% $Circuit\_Name$ represents the name of the quantum circuit in the benchmark, $QubitNu$ represents the number of qubits corresponding to the quantum circuit, and $GateNu$ represents the number of quantum gates in the quantum circuit. The data in the corresponding columns of SABRE, ILS, and TWP represent the number of CNOT gates inserted during the mapping process, followed by the results of the algorithm proposed in this paper.
% }

\renewcommand{\arraystretch}{1.2}
\begin{tabular}{cccccccccc}

% {\linewidth}{@{}LLLLLLLLLL@{}}

\toprule
\multicolumn{3}{c}{Benchmark}&
 \multicolumn{4}{c}{Number of additional CNOT gates} &  \multicolumn{3}{c}{Optimization ratio} \\ 
 Circuit Name&	Qubit Num&	Gate Num&	 $g_1$\cite{li2019tackling}&	$g_2$\cite{zhu2021iterated}&	$g_3$\cite{qian2023method}&$g_0$(HAIL-3)&	$(g_1-g_0)/g_1$ &	$(g_2-g_0)/g_2$& $(g_3-g_0)/g_3$
									
\\
\midrule
        4mod5\_v1\_22 & 5 & 21 & 0 & 0 & 0 & 0 & 0.00\% & 0.00\% & 0.00\% \\ 
        mod5mils\_65 & 5 & 35 & 0 & 0 & 0 & 0 & 0.00\% & 0.00\% & 0.00\% \\ 
        alu-v0\_27 & 5 & 36 & 3 & 3 & 9 & 3 & 0.00\% & 0.00\% & 66.67\% \\
        decod24v2\_43 & 4 & 52 & 0 & 0 & 0 & 0 & 0.00\% & 0.00\% & 0.00\% \\ 
        4gt13\_92 & 5 & 66 & 0 & 0 & 0 & 0 & 0.00\% & 0.00\% & 0.00\% \\ 
        qft\_10 & 10 & 200 & 54 & 27 & 33 & 30 & 44.44\% & -11.11\% & 9.09\% \\ 
        qft\_16 & 16 & 512 & 186 & 120 & 117 & 120 & 35.48\% & 0.00\% & -2.56\% \\ 
        ising\_model\_10 & 10 & 480 & 0 & 0 & 0 & 0 & 0.00\% & 0.00\% & 0.00\% \\ 
        ising\_model\_13 & 13 & 633 & 0 & 0 & 0 & 0 & 0.00\% & 0.00\% & 0.00\% \\ 
        ising\_model\_16 & 16 & 786 & 0 & 0 & 0 & 0 & 0.00\% & 0.00\% & 0.00\% \\ 
        rd84\_142 & 15 & 343 & 105 & 60 & 66 & 57 & 45.71\% & 5.00\% & 13.64\% \\ 
        sym6\_145 & 7 & 3888 & 1272 & 495 & 405 & 369 & 70.99\% & 25.45\% & 8.89\% \\
        z4\_268 & 11 & 3073 & 1365 & 456 & 363 & 372 & 72.75\% & 18.42\% & -2.48\% \\ 
        radd\_250 & 13 & 3213 & 1275 & 579 & 576 & 384 & 69.88\% & 33.68\% & 33.33\% \\ 
        cycle10\_2\_110 & 12 & 6050 & 2622 & 948 & 969 & 729 & 72.20\% & 23.10\% & 24.77\% \\ 
        adr4\_197 & 13 & 3439 & 1614 & 516 & 648 & 381 & 76.39\% & 26.16\% & 41.20\% \\ 
        misex1\_241 & 15 & 4813 & 1521 & 492 & 444 & 414 & 72.78\% & 15.85\% & 6.76\% \\ 
        rd73\_252 & 10 & 5321 & 2133 & 876 & 732 & 615 & 71.17\% & 29.79\% & 15.98\% \\ 
        square\_root\_7 & 15 & 7630 & 2598 & 819 & 1017 & 738 & 71.59\% & 9.89\% & 27.43\% \\
        co14\_215 & 15 & 17936 & 8982 & 2775 & 2658 & 2340 & 73.95\% & 15.68\% & 11.96\% \\ 
        rd84\_253 & 12 & 13658 & 6147 & 2484 & 1827 & 1719 & 72.04\% & 30.80\% & 5.91\% \\ 
        sqn\_258 & 10 & 10223 & 4344 & 1599 & 1212 & 999 & 77.00\% & 37.52\% & 17.57\% \\ 
        sym9\_193 & 11 & 34881 & 16653 & 5562 & 5361 & 3777 & 77.32\% & 32.09\% & 29.55\% \\ 
        Sum & - & - & \bf{50874} & \bf{17811} & \bf{16437} & \bf{13047} & \bf{74.35}\% & \bf{26.75}\% & \bf{20.62}\% \\ 
\bottomrule
\end{tabular}

% @{}LLLLLLLLLL@{}
\end{table*}
% \begin{table*}[!t]
% \centering{\includegraphics[width=6.5in]{Fig/table1.png}%
% }
% \hfil
% \caption{Comparison results with SABRE, ILS, and TWP algorithms.\label{table1}}
% \end{table*}
\subsection{Performance Analysis Compared with Some Algorithms on IBM Q20}
This experiment was conducted on the IBM Q20 architecture using the $\mathcal{B}_{23}$ benchmark. We can see in Table. \ref{table1}, the first three columns contain the circuit benchmark information, while the subsequent four columns ($g_1$, $g_2$, $g_3$, $g_0$) respectively display the number of CNOT gates inserted by SABRE, ILS, TWP, and our proposed algorithm HAIL-3 into the corresponding circuit. The last three columns show the improvement rate of our algorithm to others. This comparison is calculated by the formula:
\begin{equation}
\label{eq6}
\Delta_i=1- \frac{g_0}{g_i}.
\end{equation}
% \Delta=1- \frac{CNOT\ gates\ inserted\ by\ our's\ algorithm}{CNOT\ gates\ inserted\ by\ other \ algorithms}

% The comparison reveals that our algorithm's effectiveness isn't as pronounced as TWP in smaller benchmarks like $qft\_16$, and it even performs worse in some cases. Additionally, for the $qft$ circuits provided, our algorithm exhibits certain deficiencies compared to others. 
% However, for small-scale circuits, the limited number of qubits and gates in these circuits constrains the potential for improvement, diminishing the significance of performance differences. 

From the comparative data, it is evident that the optimization capability of our proposed HAIL-3 algorithm is limited for small-scale circuits, as the competing algorithms are also able to find optimal solutions in these cases. Specifically, when compared to the TWP algorithm, our algorithm achieves a 66.67\% improvement in the number of additional CNOT gates on the quantum circuit $alu-v0\_27$. However, for the $qft\_10$ circuit, when compared to the ILS algorithm, our algorithm results in a negative optimization effect, which may be due to the choice of the look-ahead window size. Given the small scale of the quantum circuits and the fact that the difference in the number of additional CNOT gates is minimal, such an optimization rate is still considered acceptable.

Conversely, for medium-scale or large-scale circuits, Compared to the SABRE, ILS, and TWP algorithms, our proposed algorithm demonstrates notable optimization improvements on these two types of quantum circuits.
Specifically, HAIL-3 achieves improvements of 77.32\%, 32.09\%, and 29.55\%, respectively, over the three algorithms in the $sym9\_193$ quantum circuit, representing a significant enhancement. Moreover, this algorithm outperforms SABRE and ILS in all corresponding circuits, and similarly, it performs better than the TWP algorithm in most cases, with the exception of a slight performance decrease observed in $z4\_268$. The comparison with TWP shows a -2.48\% optimization rate, which highlights the limitations of heuristic algorithms, as they are prone to getting trapped in local optima, leading to unstable optimization results.

According to the data in the table, the proposed algorithm has a 74.35\% performance improvement compared to the foundational SABRE algorithm. Similarly, for ILS, which is also an iterative algorithm, the performance improves by 26.75\%. Additionally, TWP, the recently proposed algorithm with the best comprehensive effect, also has an optimization of 20.62\%. Therefore, the algorithm in this paper has a corresponding performance improvement on most of the quantum circuits in the benchmark, and this improvement is more obvious in medium and large quantum circuits.



\subsection{Trade-Off Between Performance and Time}

In previous experiments, it was observed that when the search depth exceeded 3 in HAIL, the algorithm's runtime increased significantly, which is attributed to the exponential dependence on the search depth. However, we found that a search depth of 3 typically provides a balance between performance and runtime, making it generally acceptable. Yet, for larger circuits, this setting still resulted in longer runtime compared to other heuristic algorithms. Through multiple experiments, it was noticed that SWAP sequences with a depth of 3 occurred relatively infrequently throughout the decision-making process. On the other hand, considering only the Depth-2 SWAP sequences led to a significant decline in performance. %Depth- SWAP sequences 是在补全算法过程中涉及的，要先讲一下。再说这里的问题。
%NOTE：Depth-X sequence search 是在routing阶段涉及到的方法。

 To further enhance the scalability of the algorithm and achieve a better balance between performance and runtime, we further propose a partially extended strategy to narrow the candidate set of SWAP sequences, referring to it as HAIL-imp.
\begin{figure}[!t]
\centering
\includegraphics[width=\linewidth]{trueFigure1.pdf}
\caption{{Comparison of the proposed HAIL series algorithms, TWP, and ILS on the IBM Q20 for $\mathcal{B}_{23}$, with the inserted CNOT gates normalized to ILS and the algorithm runtime normalized to HAIL-3. }%横纵坐标是什么？怎么depth和twp,ils做比较?
}
%NOTE:我们整个算法中的SWAP搜索策略是给出了搜索深度为2，为3的情况，另一种是改进的名为depth-imp;这些都是完整的映射方法。
\label{fig_b23_q20}
\end{figure}
{Specifically, We start with a Depth-2 sequence search and select the top $K$ sequences based on Eq.\ref{eq4} for further evaluation. Among these $K$ sequences, only those with a length of 2 will be extended to a length of 3, as they demonstrate greater potential. In the worst case, the number of sequences of length 3 is $K * |EG|$, and the total number of all sequences is $O(|EG|^2 + (K+1) * |EG|)$. This is significantly smaller than the number of sequences generated with a maximum search depth of 3, which is $O(|EG|^3)$. In the experiments, $K$ is set to 50. All these algorithms are tested on the same benchmark, $\mathcal{B}_{23}$, using the IBM Q20 architecture. As shown in Fig. \ref{fig_b23_q20}, the improved search algorithm HAIL-imp significantly reduces time with only a slight decrease in overall performance when compared to HAIL-3. Besides, our proposed HAIL outperforms both TWP and ILS in additional inserted SWAP gates when the maximum search depth is 2, and as the search depth increases, the runtime also increases. Specifically, while HAIL-imp results in a 5\% increase in CNOT gate insertions compared to HAIL-3, it achieves a 90\% reduction in execution time, which represents the desired balance between performance and runtime. Similarly, both the HAIL-2 and ILS algorithms exhibit a slight decrease in execution time compared to HAIL-imp, but they lead to increases in CNOT gate insertions by 15.58\% and 29.87\%, respectively. In comparison to the TWP algorithm, HAIL-imp not only reduces execution time but also decreases CNOT gate insertions by 16.3\%.}

{Additionally, to demonstrate the feasibility of the algorithm across different benchmarks, we conduct experiments on the $\mathcal{B}_{114}$, $\mathcal{B}_{ran}$, and $\mathcal{B}_{real}$. Since the algorithm TWP outperforms both ILS and SABRE, it is compared only with the proposed algorithm HAIL in these benchmarks, with experiments performed on the IBM Q20 and Sycamore architectures. The experimental results on IBM Q20 are shown in the Fig. \ref{fig_q20&sycamore}. According to the results, the HAIL-imp algorithm achieved an approximate 8\% reduction in both runtime and the number of additional CNOT gates on the $\mathcal{B}_{114}$ benchmark. On $\mathcal{B}_{ran}$, the number of CNOT gates decreases by 12\%, while the runtime is significantly reduced by 78.5\%, marking a considerable improvement. However, on the $\mathcal{B}_{real}$, there is a 23.07\% reduction in additional CNOT gates, but the required runtime increases. This may be due to the characteristics of the benchmark, leading to fewer gate executions per decision-making, which in turn increases the whole time. This issue may need to be addressed in future work. Overall, on the IBM Q20 for various benchmarks, HAIL-imp shows a reduction in the number of CNOT gate insertions and time, which also reflects the effectiveness of the algorithm. As for HAIL-2, the algorithm consistently demonstrates fewer CNOT gates and shorter runtime compared to the TWP in these scenarios, but the additional number of CNOT gates inserted is higher than that of HAIL-imp.}

Similarly, the experimental results on Sycamore are shown in Fig. \ref{fig_q20&sycamore}. {As we can see both the HAIL-imp and HAIL-2 algorithms exhibit a reduction in the number of additional CNOT gates inserted compared to the TWP algorithm for the four specified benchmarks on the Sycamore architecture. This reduction is more obvious in the $\mathcal{B}_{ran}$ benchmark, where HAIL-imp and HAIL-2 achieve reductions of $37.8\%$ and $32.6\%$, respectively. For the remaining benchmarks, a reduction of approximately 10\% is also observed. Notably, the HAIL-imp algorithm consistently inserts fewer additional SWAP gates than HAIL-2. In terms of runtime, the HAIL-imp algorithm demonstrates a longer execution time solely on the $\mathcal{B}_{real}$ benchmark compared to both HAIL-2 and TWP. Furthermore, it is reasonable that HAIL-imp has a longer runtime compared to HAIL-2, as the algorithm's search space is larger, evaluating a broader range of candidate SWAP sequences. For the other three benchmarks, the runtime of the HAIL-imp algorithm is at least $50\%$ shorter than that of the TWP algorithm, further highlighting the effectiveness and scalability of the proposed algorithms. }

\begin{figure}[!t]
\centering
\hspace*{-0.5cm}
\includegraphics[width=1.1\linewidth]{Figure8.pdf}
\caption{Comparison of the proposed HAIL-X series methods with TWP on the benchmarks $\mathcal{B}_{23}$, $\mathcal{B}_{114}$, $\mathcal{B}_{{ran}}$, and $\mathcal{B}_{{real}}$ is conducted on the IBM Q20 and Google Sycamore architectures, with normalization of the results based on the number of inserted CNOT gates(bar chart) and algorithm runtime(line chart).
}
\label{fig_q20&sycamore}
\end{figure}
\section{Conclusion}
In this paper, we propose HAIL, an iterative heuristic algorithm designed to tackle the qubit mapping problem, with the objective of minimizing additional SWAP gates. First, we introduce a subgraph isomorphism algorithm based on layer-weight assignment, which generates a more effective initial mapping compared to previous methods that either ignore parallel gates or use gate count as a weighting factor. %这里体现你和之前文章的不同，他们用的门-权重？在效果上好在那里？We are addressing the connectivity issue and have
%proposed a layer-weight-based method to fully consider the priority
%of each gate in the circuit through weight assignment, to generate
%a good initial mapping.前面这些描述，这里可以总结下。
Since the subgraph isomorphism may result in unmapped qubits, we propose a completion algorithm that considers weight and distance, effectively balancing these properties to address this issue. %这表述不完整，什么考虑权重和距离，会体现什么优势，是迭代启发函数？在优化过程有优势？在文本介绍的地方，你有提过优势，可以拿过来。
% To address the possible issue of incomplete initial mapping, a heuristic function based on weight and distance is proposed to complete the initial mapping. 
% By combining the two methods, the problem of initial mapping is effectively resolved. 
Then, in the qubit routing stage, a SWAP gate sequence search method and a novel discriminant function with a look-ahead window are proposed to optimize the selection of the SWAP sequence. Additionally, a simplified iterative framework is introduced, utilizing forward-backward techniques with a limited number of iterations to reduce computational costs, which significantly enhances the overall efficiency of the algorithm. We evaluate our algorithm by comparing it with state-of-the-art algorithms, such as SABRE, ILS, and TWP, on the IBM Q20 architecture. Experiments on benchmark $\mathcal{B}_{23}$ demonstrate that HAIL achieves a 20.62\% reduction in the number of additional gates compared to TWP and also outperforms SABRE and ILS in terms of performance. %具体多好

{To further optimize the trade-off between runtime and performance, we propose an improved version, HAIL-imp, which reduces the number of candidate SWAP sequences in the HAIL-3 algorithm by partially extending the sequence. Evaluation on both the IBM Q20 and Google Sycamore quantum processors demonstrates significant improvements in runtime and the number of additional SWAP gates compared to TWP. On the $\mathcal{B}_{ran}$ benchmark under the Sycamore architecture, the number of additional SWAP gates was reduced by 37.8\%, and runtime decreased by 71.52\%, confirming the effectiveness and scalability of the algorithm.}
% \yukun{This further verifies the effectiveness and scalability of our algorithm. }%关于时间的实验要再介绍下，最后加一段展望总结，未来需要进一步研究的内容。

% Similarly, in future research, we will further consider the following directions: 
% \begin{enumerate}
% \item{\bf More factors in the actual architecture: }Explore how to incorporate the crosstalk effect of quantum circuits in the actual hardware architecture and the fidelity of various types of quantum gate operations, to optimize the fidelity and performance of quantum circuits to a greater extent.
% \item{\bf Multi-objective optimization of quantum mapping: }By researching how to consider the effect of quantum circuit depth on the execution time and fidelity in the qubit mapping problem, the internal relationship between quantum circuit depth and fidelity will be further illustrated. Based on the current single-objective optimization, further exploration is needed to significantly reduce the depth of quantum circuits by introducing some additional costs. This aims to achieve a reasonable trade-off between the number of additional inserted gates and the depth of the quantum circuits.
% \item{\bf Application of machine learning methods:} Given the extensive scope for research in machine learning methods, it is necessary to investigate how to further optimize the agent or policy within reinforcement learning methods to solve arbitrary qubit mapping problems, thereby achieving improved optimization of the mapping results. It is also urgent to explore how to further apply deep learning methods, such as neural networks, to train models to solve qubit mapping problems to improve mapping effectiveness and efficiency.
% % \addbibresource{ref.bib}
% \end{enumerate}

\section*{acknowledgments}
This research was supported by the National Nature Science Foundation of China (Grant No. 62101600, Grant No. 62471070), the Science Foundation of the China University of Petroleum, Beijing (Grant No. 2462021YJRC008), and the State Key Lab of Processors, Institute of Computing Technology, CAS (Grant No. CLQ202404).

%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
% \clearpage
\bibliographystyle{IEEEtran}
%\bibliography{IEEEabrv,ref}
\begin{thebibliography}{10}

\bibitem{feynman2018simulating}
R.~P. Feynman \emph{et~al.}, ``Simulating physics with computers,'' \emph{Int. j. Theor. phys}, vol.~21, no. 6/7, 2018.

\bibitem{shor1994algorithms}
P.~W. Shor, ``Algorithms for quantum computation: discrete logarithms and factoring,'' in \emph{Proceedings 35th annual symposium on foundations of computer science}.\hskip 1em plus 0.5em minus 0.4em\relax Ieee, 1994, pp. 124--134.

\bibitem{grover1996fast}
L.~K. Grover, ``A fast quantum mechanical algorithm for database search,'' in \emph{Proceedings of the twenty-eighth annual ACM symposium on Theory of computing}, 1996, pp. 212--219.

\bibitem{harrow2009quantum}
A.~W. Harrow, A.~Hassidim, and S.~Lloyd, ``Quantum algorithm for linear systems of equations,'' \emph{Physical review letters}, vol. 103, no.~15, p. 150502, 2009.

\bibitem{li2025efficient}
L.~Li, J.~Li, Y.~Song, S.~Qin, Q.~Wen, and F.~Gao, ``An efficient quantum proactive incremental learning algorithm,'' \emph{Science China Physics, Mechanics \& Astronomy}, vol.~68, no.~1, pp. 1--9, 2025.

\bibitem{song2024quantum}
Y.~Song, Y.~Wu, S.~Wu, D.~Li, Q.~Wen, S.~Qin, and F.~Gao, ``A quantum federated learning framework for classical clients,'' \emph{Science China Physics, Mechanics \& Astronomy}, vol.~67, no.~5, p. 250311, 2024.

\bibitem{Condor2023ibm}
D.~Castelvecchi, ``Ibm releases first-ever 1,000-qubit quantum chip,'' \emph{Nature}, vol. 624, no. 7991, pp. 238--238, 2023.

\bibitem{sun2023asymptotically}
X.~Sun, G.~Tian, S.~Yang, P.~Yuan, and S.~Zhang, ``Asymptotically optimal circuit depth for quantum state preparation and general unitary synthesis,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol.~42, no.~10, pp. 3301--3314, 2023.

\bibitem{botea2018complexity}
A.~Botea, A.~Kishimoto, and R.~Marinescu, ``On the complexity of quantum circuit compilation,'' in \emph{Proceedings of the International Symposium on Combinatorial Search}, vol.~9, no.~1, 2018, pp. 138--142.

\bibitem{NPsiraichi2018qubit}
M.~Y. Siraichi, V.~F.~d. Santos, C.~Collange, and F.~M.~Q. Pereira, ``Qubit allocation,'' in \emph{Proceedings of the 2018 International Symposium on Code Generation and Optimization}, 2018, pp. 113--125.

\bibitem{ge2024quantumcircuitsynthesiscompilation}
Y.~Ge, W.~Wenjie, C.~Yuheng, P.~Kaisen, L.~Xudong, Z.~Zixiang, W.~Yuhan, W.~Ruocheng, and Y.~Junchi, ``Quantum circuit synthesis and compilation optimization: Overview and prospects,'' 2024. [Online]. Available: \url{https://arxiv.org/abs/2407.00736}

\bibitem{shafaei2014qubit}
A.~Shafaei, M.~Saeedi, and M.~Pedram, ``Qubit placement to minimize communication overhead in 2d quantum architectures,'' in \emph{2014 19th Asia and South Pacific Design Automation Conference (ASP-DAC)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2014, pp. 495--500.

\bibitem{nannicini2022optimal}
G.~Nannicini, L.~S. Bishop, O.~G{\"u}nl{\"u}k, and P.~Jurcevic, ``Optimal qubit assignment and routing via integer programming,'' \emph{ACM Transactions on Quantum Computing}, vol.~4, no.~1, pp. 1--31, 2022.

\bibitem{bhattacharjee2017depth}
D.~Bhattacharjee and A.~Chattopadhyay, ``Depth-optimal quantum circuit placement for arbitrary topologies,'' \emph{arXiv preprint arXiv:1703.08540}, 2017.

\bibitem{bhattacharjee2019muqut}
D.~Bhattacharjee, A.~A. Saki, M.~Alam, A.~Chattopadhyay, and S.~Ghosh, ``Muqut: Multi-constraint quantum circuit mapping on nisq computers,'' in \emph{2019 IEEE/ACM international conference on computer-aided design (ICCAD)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2019, pp. 1--7.

\bibitem{tan2021optimal}
B.~Tan and J.~Cong, ``Optimal qubit mapping with simultaneous gate absorption,'' in \emph{2021 IEEE/ACM International Conference On Computer Aided Design (ICCAD)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2021, pp. 1--8.

\bibitem{murali2019noise}
P.~Murali, J.~M. Baker, A.~Javadi-Abhari, F.~T. Chong, and M.~Martonosi, ``Noise-adaptive compiler mappings for noisy intermediate-scale quantum computers,'' in \emph{Proceedings of the twenty-fourth international conference on architectural support for programming languages and operating systems}, 2019, pp. 1015--1029.

\bibitem{lye2015determining}
A.~Lye, R.~Wille, and R.~Drechsler, ``Determining the minimal number of swap gates for multi-dimensional nearest neighbor quantum circuits,'' in \emph{The 20th Asia and South Pacific Design Automation Conference}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2015, pp. 178--183.

\bibitem{wille2019mapping}
R.~Wille, L.~Burgholzer, and A.~Zulehner, ``Mapping quantum circuits to ibm qx architectures using the minimal number of swap and h operations,'' in \emph{Proceedings of the 56th Annual Design Automation Conference 2019}, 2019, pp. 1--6.

\bibitem{molavi2022qubit}
A.~Molavi, A.~Xu, M.~Diges, L.~Pick, S.~Tannu, and A.~Albarghouthi, ``Qubit mapping and routing via maxsat,'' in \emph{2022 55th IEEE/ACM International Symposium on Microarchitecture (MICRO)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2022, pp. 1078--1091.

\bibitem{lin2023scalable}
W.-H. Lin, J.~Kimko, B.~Tan, N.~Bj{\o}rner, and J.~Cong, ``Scalable optimal layout synthesis for nisq quantum processors,'' in \emph{2023 60th ACM/IEEE Design Automation Conference (DAC)}.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2023, pp. 1--6.

\bibitem{zhou2020monte}
X.~Zhou, Y.~Feng, and S.~Li, ``A monte carlo tree search framework for quantum circuit transformation,'' in \emph{Proceedings of the 39th International Conference on Computer-Aided Design}, 2020, pp. 1--7.

\bibitem{sinha2022qubit}
A.~Sinha, U.~Azad, and H.~Singh, ``Qubit routing using graph neural network aided monte carlo tree search,'' in \emph{Proceedings of the AAAI Conference on Artificial Intelligence}, vol.~36, no.~9, 2022, pp. 9935--9943.

\bibitem{pozzi2022using}
M.~G. Pozzi, S.~J. Herbert, A.~Sengupta, and R.~D. Mullins, ``Using reinforcement learning to perform qubit routing in quantum compilers,'' \emph{ACM Transactions on Quantum Computing}, vol.~3, no.~2, pp. 1--25, 2022.

\bibitem{li2024deep}
Y.~Li, W.~Liu, and M.~Li, ``Deep reinforcement learning for mapping quantum circuits to 2d nearest-neighbor architectures,'' \emph{Advanced Quantum Technologies}, vol.~7, no.~2, p. 2300289, 2024.

\bibitem{fan2022optimizing}
H.~Fan, C.~Guo, and W.~Luk, ``Optimizing quantum circuit placement via machine learning,'' in \emph{Proceedings of the 59th ACM/IEEE Design Automation Conference}, 2022, pp. 19--24.

\bibitem{zhou2022supervised}
X.~Zhou, Y.~Feng, and S.~Li, ``Supervised learning enhanced quantum circuit transformation,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol.~42, no.~2, pp. 437--447, 2022.

\bibitem{paler2023machine}
A.~Paler, L.~Sasu, A.-C. Florea, and R.~Andonie, ``Machine learning optimization of quantum circuit layouts,'' \emph{ACM Transactions on Quantum Computing}, vol.~4, no.~2, pp. 1--25, 2023.

\bibitem{matsuo2012changing}
A.~Matsuo and S.~Yamashita, ``Changing the gate order for optimal lnn conversion,'' in \emph{Reversible Computation: Third International Workshop, RC 2011, Gent, Belgium, July 4-5, 2011. Revised Papers 3}.\hskip 1em plus 0.5em minus 0.4em\relax Springer, 2012, pp. 89--101.

\bibitem{zulehner2018efficient}
A.~Zulehner, A.~Paler, and R.~Wille, ``An efficient methodology for mapping quantum circuits to the ibm qx architectures,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol.~38, no.~7, pp. 1226--1236, 2018.

\bibitem{li2019tackling}
G.~Li, Y.~Ding, and Y.~Xie, ``Tackling the qubit mapping problem for nisq-era quantum devices,'' in \emph{Proceedings of the Twenty-Fourth International Conference on Architectural Support for Programming Languages and Operating Systems}, 2019, pp. 1001--1014.

\bibitem{ash2019qure}
A.~Ash-Saki, M.~Alam, and S.~Ghosh, ``Qure: Qubit re-allocation in noisy intermediate-scale quantum computers,'' in \emph{Proceedings of the 56th Annual Design Automation Conference 2019}, 2019, pp. 1--6.

\bibitem{niu2020hardware}
S.~Niu, A.~Suau, G.~Staffelbach, and A.~Todri-Sanial, ``A hardware-aware heuristic for the qubit mapping problem in the nisq era,'' \emph{IEEE Transactions on Quantum Engineering}, vol.~1, pp. 1--14, 2020.

\bibitem{lao20222qan}
L.~Lao and D.~E. Browne, ``2qan: A quantum compiler for 2-local qubit hamiltonian simulation algorithms,'' in \emph{Proceedings of the 49th Annual International Symposium on Computer Architecture}, 2022, pp. 351--365.

\bibitem{li2023timing}
Y.~Li, Y.~Zhang, M.~Chen, X.~Li, and P.~Xu, ``Timing-aware qubit mapping and gate scheduling adapted to neutral atom quantum computing,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, 2023.

\bibitem{li2020qubit}
S.~Li, X.~Zhou, and Y.~Feng, ``Qubit mapping based on subgraph isomorphism and filtered depth-limited search,'' \emph{IEEE Transactions on Computers}, vol.~70, no.~11, pp. 1777--1788, 2020.

\bibitem{zhu2021iterated}
P.~Zhu, S.~Feng, and Z.~Guan, ``An iterated local search methodology for the qubit mapping problem,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol.~41, no.~8, pp. 2587--2597, 2021.

\bibitem{qian2023method}
Y.~Qian, Z.~Guan, S.~Zheng, and S.~Feng, ``A method based on timing weight priority and distance optimization for quantum circuit transformation,'' \emph{Entropy}, vol.~25, no.~3, p. 465, 2023.

\bibitem{jiang2021quantum}
H.~Jiang, Y.~Deng, and M.~Xu, ``Quantum circuit transformation based on tabu search,'' \emph{arXiv preprint arXiv:2104.05214}, 2021.

\bibitem{datta2023improved}
K.~Datta, A.~Kole, I.~Sengupta, and R.~Drechsler, ``Improved cost-metric for nearest neighbor mapping of quantum circuits to 2-dimensional hexagonal architecture,'' in \emph{International Conference on Reversible Computation}.\hskip 1em plus 0.5em minus 0.4em\relax Springer, 2023, pp. 218--231.

\bibitem{chang2021mapping}
K.-Y. Chang and C.-Y. Lee, ``Mapping nearest neighbor compliant quantum circuits onto a 2-d hexagonal architecture,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol.~41, no.~10, pp. 3373--3386, 2021.

\bibitem{ovide2023mapping}
A.~Ovide, S.~Rodrigo, M.~Bandic, H.~Van~Someren, S.~Feld, S.~Abadal, E.~Alarcon, and C.~G. Almudever, ``Mapping quantum algorithms to multi-core quantum computing architectures,'' \emph{arXiv preprint arXiv:2303.16125}, 2023.

\bibitem{liu2023tackling}
J.~Liu, E.~Younis, M.~Weiden, P.~Hovland, J.~Kubiatowicz, and C.~Iancu, ``Tackling the qubit mapping problem with permutation-aware synthesis,'' in \emph{2023 IEEE International Conference on Quantum Computing and Engineering (QCE)}, vol.~1.\hskip 1em plus 0.5em minus 0.4em\relax IEEE, 2023, pp. 745--756.

\bibitem{zhu2020dynamic}
P.~Zhu, Z.~Guan, and X.~Cheng, ``A dynamic look-ahead heuristic for the qubit mapping problem of nisq computers,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, vol.~39, no.~12, pp. 4721--4735, 2020.

\bibitem{huang2024efficient}
C.-Y. Huang and W.-K. Mak, ``Efficient qubit routing using a dynamically-extract-and-route framework,'' \emph{IEEE Transactions on Computer-Aided Design of Integrated Circuits and Systems}, 2024.

\bibitem{tan2020optimality}
B.~Tan and J.~Cong, ``Optimality study of existing quantum computing layout synthesis tools,'' \emph{IEEE Transactions on Computers}, vol.~70, no.~9, pp. 1363--1373, 2020.

\bibitem{1323804}
L.~Cordella, P.~Foggia, C.~Sansone, and M.~Vento, ``A (sub)graph isomorphism algorithm for matching large graphs,'' \emph{IEEE Transactions on Pattern Analysis and Machine Intelligence}, vol.~26, no.~10, pp. 1367--1372, 2004.

\end{thebibliography}


%%
%% If your work has an appendix, this is the place to put it.
\end{CJK}
\end{document}
\endinput
%%
%% End of file `sample-sigconf.tex'.
