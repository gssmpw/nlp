\section{Related Work}
% ======================================================================================================================================

As already mentioned, we found EC suitable for reasoning about requirements specifications due to its low semantic gap against them.
%
In comparison, the semantics of automata-based approaches, which are often used in the literature to model CPSs, such as timed automata~\cite{timed-automata-uppaal} or hybrid automata~\cite{hybrid-automata}, require one to ``design" explicit states and transitions, and may lead to decomposition of the system into sub-systems each with their own automaton.
%
Current industrial model-based engineering approaches, such as those based, e.g., on Matlab Simulink models and tools like \hilite{}~\cite{hilite}, are only suitable for validation of low-level requirements.
%
This is due to the low-level nature of the models they use, especially when automated generation of code from the models is required.
%
Much research has been done on using temporal logics (e.g., LTL, CTL, CTL*~\cite{hand-book-modelchecking}) and real time temporal logics (e.g., MTL~\cite{temporal-logic-mtl}) to represent system properties.
%
However, we have not considered temporal logics as a~target for transforming high-level system specifications since the semantics of the temporal logics that we are aware of are further away from natural language which makes the transformation more difficult to perform and to understand in comparison with EC.

Apart from the EC-based approach introduced in~\cite{gupta-train}, which my work builds upon, 
there are other ones which aim to target automated validation of high-level requirements put on CPSs.
%
The work~\cite{ge-assert} is based on ontologies and uses theorem proving, which traditionally requires significant manual work.
%
The work~\cite{cea-glossaries-and-process-algebras} is based on transforming CPS specifications from templated-English
%
into process algebras extended with real-time aspects, however, no continuous variables (apart from time) are dealt with and no experimental results are presented, which makes it difficult to judge the scalability of this approach.

Finally, there are other ASP solvers than the \scasp{} system that I am currently using, such as the grounding-based \clingo{}~\cite{clingo-paper}.
%
However, in my experiments so far, \clingo{} has, unfortunately, proven to be unsuitable for reasoning about fluents with large or continuous value domains due to the explosion in the grounding and a~need to discretize the time.
%
This causes the solver to quickly run out of memory even on models with very limited continuous value domains, while the discretized time steps introduce issues when trying to step on exact values during periods of continuous change.
%
An advantage of \clingo{} is that it does not suffer from non-termination issues, which make things much more complicated in \scasp{}, therefore, I plan to further investigate the possibility of using it in my research once advancements are made in reducing the grounding explosion.



% ======================================================================================================================================