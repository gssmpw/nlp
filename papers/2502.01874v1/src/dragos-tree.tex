
In this section, we present a polynomial time algorithm that finds the optimal solution for hierarchy graphs. A hierarchy graph is a rooted directed tree where all the edges are pointing away from the root. An example is shown Figure~\ref{fig:org-chart}. Such graphs model organizational hierarchies. 
In this type of tree, information flows from bottom up, which is a natural representation of multiple real life scenarios, such as people on the lower levels in the hierarchy reporting what their opinion to their immediate superior. 

While we presented the FJ model for undirected graphs, it naturally adapts to directed graphs as follows:  
\begin{align*}
\textstyle x_u(t+1) = \alpha_u s_u + \frac{1-\alpha_u}{\deg(u)} \sum_{v \in N_{\mathrm{out}}(u)}  w_{uv} x_v(t) \hfill \text{~for all~~}u \in V.
\end{align*}
\subsection{General approach}

Formally, a hierarchy graph is a rooted tree $T$ where $w_{uv} > 0$ only if $v$ is the direct child of $u$.

%
As a result, each node is only influenced by the nodes in its subtree, so we can compute its equilibrium opinion by recursively computing the equilibrium opinions of its children, which are independent from each other. We use a dynamic programming approach to ensure we are getting an optimal solution. 
%\fabian{what are states?} \dragos{I'll say that later but I changes states}.
%
The other reason why we can achieve polynomial time is because the continuous values that represent the opinion of each node become discrete at the end by being either a \textsf{yes} vote or a \textsf{no} vote,  depending on whether they are above $0.50$ or not respectively.  
%\fabian{yes vote means $> 0.5$?}
%
%\fabian{I'd put this at the end}

\subsection{Dynamic programming algorithm}

Now we explain how to use dynamic programming to find the optimal choice of stooges to bring the opinion of more than half the nodes above $0.5$.

Let $\text{dp}_{u,\text{numVotes},k}  $ denote the maximum opinion for node $u$ when the subtree is rooted in $u$ so that $k$ nodes are stooges and we have $\text{numVotes}$ nodes that have opinion $>0.5$.
The optimal number of stooges will be the smallest $k$ such that there exists a $j > \frac{n}{2}$ so that $\text{dp}_{u, j, k}$ is a reachable state, where $u$ is the root. If this state is reachable it means we have a way of assigning $k$ stooges so we can get $j$ nodes with opinion $>0.5$.

\begin{align*}
    D(u) &= \textrm{descendants of $u$ in $G$} \\
    X_{u, k} &= \{ x^\star(\alpha', W, s) :
        S \subseteq D(u) \textrm{ such that } |S| = k
        \textrm{ and } \alpha'_w = \alpha_w \textrm{ for all } w \notin S \} \\
    X_{u, j, k} &= \{ x^\star \in X_{u, k} : |\{ w \in D(u)
        : x^\star_w > {\textstyle \frac 1 2} \}| = j \} \\
    \mathrm{dp}_{u, j, k} &= \left\{ \begin{array}{ll}
         \max\{ x^\star_u : x^\star \in X_{u, j, k} \}
         & \textrm{if } X_{u, j, k} \not= \emptyset \\
         \bot & \textrm{otherwise}
    \end{array} \right.
\end{align*}

The base cases are the leaves. For a leaf $\ell$ it doesn't matter if a leaf is a stooge or not since it will have the same opinion. So this corresponds to either $\text{dp}_{\ell, 1, 0} = s_\ell$ if $s_\ell > 0.5$ or $\text{dp}_{\ell, 0, 0} = s_\ell$ otherwise.

\begin{align*}
    \textrm{for a leaf $u$ and $j, k \in \{0, 1\}$ we set} \qquad
    \mathrm{dp}_{u, j, k} = \left\{ \begin{array}{ll}
         s_u & \textrm{if } j > 0 \textrm{ and } s_u > \frac 1 2 \\
        \bot & \textrm{otherwise}
    \end{array} \right.
\end{align*}

For nodes with  children, we must optimally allocate  the   $k$ available stooges among them. We do so by creating an auxiliary dynamic program: let $\text{cdp}_{i,j,k} = $ be the largest sum of opinions across the first $i$ children with a total of $j$ nodes having opinion $> 0.5$ and using a total of $k$ stooges. This is very similar to a 2D version of the knapsack problem \cite{williamsonbook}, since when we add the $(i+1)^{\text{th}}$ child and have to combine a $\text{cdp}_{i,j,k}$ with $\text{dp}_{c,j',k'}$ we create the state $\text{cdp}_{i+1,j+j',k+k'} = \text{cdp}_{i,j,k} + w_{i,c} \cdot \text{dp}_{c, j', k'}$. After these auxiliary states are calculated, we can update the original dynamic program, and check whether the current node's opinion is above $0.5$, in which case we add $1$ to the number of votes. 
The complete pseudocode is given in Algorithm~\ref{alg:algo1}.

For each node, we create an auxiliary dynamic program $\mathrm{cdp}_{i,j,k}$. Let
$D(u, i)$ be the descendants of the first $i$ children of $u$.
\begin{align*}
    Y_k &= \{ x^\star(\alpha', W, s) : S \subseteq D(u, i) \textrm{ such that } |S| = k
        \textrm{ and } \alpha'_w = \alpha_w \textrm{ for all } w \notin S \} \\
    Y_{j, k} &= \{ x^\star \in Y_k : |\{ w \in D(u, i) :
        x_w^\star > {\textstyle \frac 1 2} \}| = j \} \\
    \mathrm{cdp}_{i, j, k} &= \left\{ \begin{array}{ll}
        \max \{ \sum_{v \in D(u, i) \cap N(u)} w_{uv} x^\star_v : x^\star \in Y_{j, k} \} & \textrm{if } Y_{j, k} \not= \emptyset \\
        \bot & \textrm{otherwise}
    \end{array} \right.
\end{align*}

The overall complexity is the same as the auxiliary dynamic program, which is $O(n^4)$ per child node, for a total of $O(n^5)$.


