

% \begin{algorithm}[t]
% \caption{\textit{Compute winning region for MDPST}}
% \begin{algorithmic}[1]
% \Require Product MDPST $\M^\times$.
% %\Ensure AMEC $E_{\M} = \{(S'_i, U'_i)\}$.
% \Ensure Winning region $W^\times$.
% \State Compute $S_p$ and construct sub-MDPST $\M_{sub}^\times = (S_p, s^\times_0, A^\times, \F_p, \mathcal{T}_p, \L_p, \acc^\times)$;
% \State flag $= 1$;
% \While {flag $= 1$}
% \State Split ${\acc}^\times$ into two virtual copies $I_{in} = \{s^{in}: \text{$s^{in}$ is a virtual copy of $s, \forall s\in \acc^\times$}\}$ and $I_{ out}\{s^{in}: \text{$s^{out}$ is a virtual copy of $s, \forall s\in \acc^\times$}\}$;
% \State $\hat{S} =(S_p \setminus {\acc}^\times)\cup I_{\rm in}\cup I_{\rm out}$;
% \State Construct the MDPST $\hat{\M}_{sub}^\times$ (cf. (\ref{def:hat_mdpst})) over $\hat{S}$;
% \State Compute the optimal value function $V_{sat}$ for $\hat{\M}_{sub}^\times$ with the robust dynamic programming operator $T$ in (\ref{valuefunction_MDPST});
% \If {$\exists s^{out}\in I_{out}$ s.t. $V_{sat}(s^{out})\neq 1$ }
% \State flag $\leftarrow 1$;
% \For {$s^{out}\in I_{out}$ s.t. $V_{sat}(s^{out})\neq 1$}
% \State $S_p\leftarrow S_p \setminus \{s\in \acc^\times: \text{$s^{out}$ is the virtual copy of s}\}$;
% \State $\acc^\times \leftarrow \acc^\times \setminus \{s\in \acc^\times: \text{$s^{out}$ is the virtual copy of s}\}$;
% \EndFor
% \Else
% \State flag $\leftarrow 0$;
% \EndIf
% \For {$s^\times\in S_p\setminus \acc^\times$}
% \If {$V_{sat}(s^\times)\neq 1$}
% \State $S_p \leftarrow S_p \setminus s^\times$;
% \EndIf
% \EndFor
% \EndWhile
% \State $W^{\times} = S_p$.
% \end{algorithmic}
% \end{algorithm}

%%%Simplified version
%%%%%%%%%%%%%%%%%%%%%
\begin{algorithm}[t]
\caption{\textit{Compute winning region for MDPST}}
\begin{algorithmic}[1]
\Require Product MDPST $\M^\times$.
%\Ensure AMEC $E_{\M} = \{(S'_i, U'_i)\}$.
\Ensure Winning region $W^\times$.
\State Compute $S_p$ and construct sub-MDPST $\M_{sub}^\times = (S_p, s^\times_0, A^\times, \F_p, \mathcal{T}_p, \L_p, \acc^\times)$;
\State flag $= 1$;
\While {flag $= 1$ and $\acc^\times \neq \emptyset$}
\State Split ${\acc}^\times$ into two virtual copies $I_{in} = \{s^{in}: \text{$s^{in}$ is a virtual copy of $s, \forall s\in \acc^\times$}\}$ and $I_{ out}\{s^{in}: \text{$s^{out}$ is a virtual copy of $s, \forall s\in \acc^\times$}\}$;
\State $\hat{S} =(S_p \setminus {\acc}^\times)\cup I_{\rm in}\cup I_{\rm out}$;
\State Construct the MDPST $\hat{\M}_{sub}^\times$ (cf. (\ref{def:hat_mdpst})) over $\hat{S}$;
\State Compute the optimal value function $V_{sat}$ for $\hat{\M}_{sub}^\times$ with the robust dynamic programming operator $T$ in (\ref{VF_deterministic});
\If {$\exists s^{out}\in I_{out}$ s.t. $V_{sat}(s^{out})\neq 1$ }
\State flag $\leftarrow 1$;
\State Update $S_p$ and $\acc^\times$;
\Else
\State flag $\leftarrow 0$;
\EndIf
\EndWhile
\State $W^{\times} = S_p$.
\end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%
% \begin{algorithm}[t]
% \caption{\textit{Compute reach goal for MDPST}}
% \begin{algorithmic}[1]
% \Require Product MDPST $\M_{sub}^\times$.
% %\Ensure AMEC $E_{\M} = \{(S'_i, U'_i)\}$.
% \Ensure Accepting set $S'$.
% \State Construct the corresponding MDP $\M_G$ for $\M_{sub}^\times$;
% \State $E_{\M_G}$ = \textsc{computeAMEC}$(\G, \acc^\times)$;
% \For {$E_i = (S_i, A_i, \acc_i) \in E_{\M_G}$}
% \State flag $= 1$;
% \If {flag $= 1$}
% \State Construct the MDPST $\hat{\M}_i$ with state-space $\hat{S_i} = (S_i\setminus \acc_i)\cup I_{in} \cup I_{out}$ and $\hat{A}_i = A_i\cup \{\tau\}$;
% \State Compute the value function $V_i$ for $\hat{\M}_i$ with goal set $I_{in}$;
% \If {$\exists s_i^{out}$ s.t. $V_i(s_i^{out})\neq 1$ }
% \State flag $\leftarrow 1$;
% \For {$s_i^{out}\in I_{out}$ s.t. $V_i(s_i)\neq 1$}
% \State $\hat{S_i} \leftarrow \hat{S_i}\setminus \{s_i^{out}, s_i^{in}\}$;
% \EndFor
% \Else
% \State flag $\leftarrow 0$;
% \EndIf
% \For {$s_i\in S_i\setminus \acc_i$}
% \If {$V_i(s_i)\neq 1$}
% \State $\hat{S_i} \leftarrow \hat{S_i}\setminus s_i$;
% \EndIf
% \EndFor
% \Else
% \State $\hat{S}'_i = \{s_i: s_i \in S_i\setminus \acc_i\} \cup \{s_i: s_i^{out} \in \acc_i\}$;
% \EndIf
% \EndFor
% \State $S' = \cup_i\{\hat{S}'_i\}$.
% \end{algorithmic}
% \end{algorithm}