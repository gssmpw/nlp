
In order to be easy to parse, readable with reasonable effort, and to be similar to the SMTLib-format, \llissy uses s-expressions.

Only single line comments exist which start with \textsf{';'} and span to the end of the line. 
Newlines are \textsf{'\textbackslash r\textbackslash n', '\textbackslash n \textbackslash r', ' \textbackslash r'} and \textsf{'\textbackslash n'}. 
However, when generating \llissy automatically \textsf{'\textbackslash n'} should be used. 
Similarly \textsf{' '} (Space) and \textsf{'\textbackslash t'} (Tabs) are both non-newline white-spaces. 
However, only \textsf{' '} should be used upon generation. 
The following productions define identifiers and natural numbers.
\begin{grammar}
<ALPHA> ::= `a'...`z' | `A'...`Z' 

<DIGIT> ::= `0'...`9'

<ID>    ::= <ALPHA> (<ALPHA> | <DIGIT> | `_')*

<PID>   ::= <ID> ['$\sim$']

<NAT>   ::=  <DIGIT>+

<RAT>   ::=  <DIGIT>+ `.' <DIGIT>+
\end{grammar}

\noindent
Note that all of these should be parsed greedily until a white-space, '(', ')', or the end-of-file occurs.

A \llissy specification consists of lists of variable declarations, formula specifications and game specifications. The variables declarations include all variables used in all games and formulas. 
The formula and game specifications are interpreted conjunctively. 
However, at most one game or formula can be a non-safety game or non-safety formula.

\begin{grammar}
<SPEC> ::= `(' `(' <VARDEC>* `)' `(' <FSPEC>* `)' `(' <GSPEC>*  `)' `)'
\end{grammar}

\noindent
A variable declaration declares an input or state variable and its respective type
\begin{grammar}
<VARDEC>  ::= `(' `input' <TYPE> <ID> `)' | `(' `state' <TYPE> <ID> `)'

<TYPE>   ::=  `Int' | `Bool' | `Real'
\end{grammar}

A formula specification is a pair of assumption and guarantee lists. Each element is an RP-LTL formula.
The assumptions come first, and each of the two lists is interpreted as a conjunction. 
\begin{grammar}
<FSPEC>   ::= `(' `(' <FORMULA>* `)' `(' <FORMULA>* `)' `)'

<FORMULA> ::= `(' `ap' <TERM>`')' \alt `(' <UOP> <FORMULA> `)' \alt `(' <BOP> <FORMULA> <FORMULA> `)' \alt (<NOP> <FORMULA>*)

<UOP>     ::= `X' | `F' | `G' | `not'

<BOP>     ::= `U' | `W' | `R'

<NOP>     ::= '`and' | `or'
\end{grammar}

A game specification consists of a list of location definitions, transition definitions from one location to another location, and an objective definition.
The objective defines the initial location and the winning condition. Each location is annotated with a natural number. For Safety, Reachability, Buechi, and CoBuechi a location is safe, target, Buechi accepting, coBuechi accepting iff the number is greater than zero. 
For ParitMaxOdd the number is the color in the parity game.

\begin{grammar}
<GSPEC>    ::= `(' `(' <LOCDEF>* `)' `(' <TRANSDEF>* `)' <OBJ> `)'

<LOCDEF>   ::= `(' <ID> <NAT> <TERM> `)'

<TRANSDEF> ::= `(' <ID> <ID> <TERM> `)'

<OBJ>      ::= `(' <ID> (`Safety' | `Reachability ' | `Buechi' | `CoBuechi' \newline \phantom{aaaaaaaaaaaaaaaa} | `ParityMaxOdd') `)'
\end{grammar}

A term is basically like in the SMT-Lib-2 format without quantifiers, lambda, and let expressions. Similar rules for typing apply.
Only variables declared initially are allowed to be free variables, and additionally primed version (with $\sim$) of the state variables.

\begin{grammar}
<TERM>   ::= `(' <OP> <TERM>* `)' | <PID> | <CONSTS>

<OP>     ::= `and ' | `or' | `not' | `ite' | `distinct' | `=>' |
         `=' | `<' | `>'| `<=' | `>=' |
         `+' | `-' | `*' | `/' | `mod' | `abs' | `to_real' 

<CONSTS> ::= <RAT> | <NAT> | `true' | `false'
\end{grammar}
