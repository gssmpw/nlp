The architecture of \issy is shown in \Cref{fig:toolchain}.  We discussed the components translating a specification to a single synthesis game in \Cref{sec:to-game}.
Now we present the game solver underlying \issy, focusing on the novel  technical developments.

\begin{figure}[t!]
\input{tool-diagram.tex}
\vspace{-.7cm}
\caption{Architecture of \issy. Components depicted in blue and pink are part of the tool's implementation, those depicted in white are external.}
\label{fig:toolchain}
\end{figure}

The approach behind the \issy solver builds on the method proposed in~\cite{HeimD24}.
The fist main difference to the prototype \rpgsolve from~\cite{HeimD24} is that \rpgsolve accepts RPGs,  a strictly more restricted class of symbolic games.  Furthermore,  the initial version of \rpgsolve does not support parity winning conditions.   
Our \Cref{ex:simple-example} cannot be modelled as an RPG,  because the system player has the power to select any real values as next-state values for the state variables.
Furthermore,  the specification in \Cref{ex:simple-example} translates to a parity game.
\issy's solver supports a more general symbolic game model, and also implements a symbolic method for infinite-state parity games based on fixpoint computation (a lifting of the classical Zielonka's algorithm~\cite{Zielonka98}).  Thus,  \issy is able to establish the realizability of the specification in Listing~\ref{lst:example} thanks to the new techniques it implements.

The crux to this is the acceleration technique introduced in~\cite{HeimD24}.
Naive fixpoint-based game-solving diverges on this example.
\emph{Attractor acceleration}~\cite{HeimD24} uses ranking arguments to establish that by iterating some strategy an unbounded number of times through some location, a player in the game can  enforce reaching a set of target states.  In \Cref{ex:simple-example},  attractor acceleration is used within the procedure for solving the parity game to establish that (under the respective constraints on the environment) from any state satisfying the formula \texttt{balanced},  a state where both \texttt{load1} and \texttt{load2} are in the bounded interval $[\frac{3}{10},\frac{9}{10}]$ can be enforced by the system player.  This argument is formalized as what is called an \emph{acceleration lemma}~\cite{HeimD24}.  From the interval $[\frac{3}{10},\frac{9}{10}]$,  the system player can then enforce reaching in a bounded number of steps a state where  \texttt{load1} and \texttt{load2} are zero.

We developed a novel method for generating acceleration lemmas and  implemented in \issy in addition to that from~\cite{HeimD24}.
To search for acceleration lemmas,  \rpgsolve introduces uninterpreted predicates representing the lemmas' components, and collects SMT constraints asserting the applicability of the lemma.  Thus,  \rpgsolve would have to discover the formula \texttt{[load1 >= load2] \&\& [load1 <= 2 * load2]  ||[load2 >= load1] \&\& [load2 <= 2 * load1]} as part of the acceleration lemma, which it is not able to do within a reasonable timeout.
The alternative method we implemented in \issy performs analysis of the game in order to generate candidate  acceleration lemmas.
First,  it analyzes the game in order to identify variables potentially making progress in a ranking argument.  For instance,  variables that remain unchanged in the relevant game locations can  be ruled out.  
Second, the new method uses the distance to the target set of states to generate ranking arguments for candidate acceleration lemmas.  Finally,  to search for a set of states where the  respective player can enforce the decrease of the distance, it uses symbolic iteration and SMT-based formula generalization.  As demonstrated for \Cref{ex:simple-example}, and more broadly by our experimental evaluation in \Cref{sec:experiments},  this new method for generating acceleration lemmas, which we call \emph{geometric acceleration}, is successful in many cases that are challenging for \rpgsolve. In \issy, geometric attractor acceleration is enabled by default, and the method can be switched using the parameter \texttt{\textcolor{blue}{-{}-accel-attr}}.

In addition to an alternative method for generating acceleration lemmas,  the \issy solver utilizes new techniques for their localization. Building on ideas in~\cite{SchmuckHDN24}, 
we restrict the size of the sub-games used for the acceleration lemma computation and project away variables that are not relevant in the respective subgame.  Unlike~\cite{SchmuckHDN24}, where this is done for pre-computing accelerations,  in \issy these localization techniques are applied on-the-fly during the main game solving.

\issy also provides support for strategy synthesis and extraction of C programs for realizable specifications.  The latter can be extended to other target languages,  utilizing the 
generic data structure for reactive program representation in \issy.

\issy\footnote{\url{https://github.com/phheim/issy}} is implemented in Haskell with focus on modularity and extensibility,  including detailed documentation.  Using the Haskell tool Stack,  building  \issy and getting its dependencies is seamless.
The external tools used are \texttt{Spot}~\cite{Duret-LutzRCRAS22}  for translation of LTL  to automata,  the $\mu$CLP solver \texttt{MuVal}~\cite{UnnoTGK23} and the Optimal CHC solver \texttt{OptPCSat}~\cite{GuTU23}  for the monitor construction,  and \texttt{z3}~\cite{Z3} for all SMT,  formula simplification and quantifier elimination queries.


