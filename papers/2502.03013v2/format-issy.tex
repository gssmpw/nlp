The \issy input format has the key advantage that it combines two modes for specification of synthesis problems for infinite-state reactive systems: temporal logic formulas,  and two-player games, both over variables with infinite domains, such as integers or reals.  
The advantages of this mutli-paradigm specification format are two-fold.
First,  it often allows specification designers to specify requirements in a less cumbersome way.  
For example,  constraints that  depend on the system's state, or encode behaviour in different phases,  are usually easier to specify as games.  On the other hand, mission specifications such that under certain assumptions the system must eventually stabilize, or that some tasks should be carried out repeatedly, are often more concisely expressed in temporal logic.  \looseness=-1

\input{example-listing}

Each of the two modes of specification can potentially offer opportunities for optimization of the synthesis tools processing these specifications. 
In~\cite{HeimD25}, we showed how the translation from \rpltl{} formulas  to  games can benefit from the high-level information present in the formula in order to simplify the  game. 


\begin{figure}[b!]
\begin{center}
\input{issy-grammar-part.tex}
\end{center}
\caption{An excerpt from the \issy  format.  The full description is in~\Cref{sec:format-issy-full}.}
\label{fig:issy-grammar-part}
\end{figure}





Now, we turn to an example that illustrates and motivates the main features of the \issy format.
An excerpt of the format's grammar is given in \Cref{fig:issy-grammar-part}.

\begin{example}\label{ex:simple-example}
Consider a reactive system that has to balance the loads, \texttt{load1} and \texttt{load2}, of two components.
At any point,  the environment can increase the total load,  via the environment-controlled input variable \texttt{add}.  When that happens,  the system has to re-balance the total load by appropriate partitioning. When the load does not increase,  the system has to control the throughput of each component,  state variables \texttt{rem1} and \texttt{rem2} respectively,  in accordance with the components' speeds and the total available throughput,  \texttt{rem} controlled by the environment.
The specification of this system is given in Listing~\ref{lst:example}, and consists of variable declarations,  a formula specification,   macro definitions for better readability, and the second part of the specification given as a two-player game.  


Variable declarations specify whether the variable is \texttt{\textcolor{blue}{input}} controlled by the environment, or is a \texttt{\textcolor{blue}{state}} variable controlled by the system.
The currently supported data types are \texttt{bool, int} and \texttt{real}.
The domains of variables can be further constrained in the \texttt{\textcolor{blue}{game}} specifications by additional constraints.




The \texttt{\textcolor{blue}{formula}} specification is a list \rpltl{} formulas,  prefixed by the keywords \texttt{\textcolor{blue}{assume}} and \texttt{\textcolor{blue}{assert}},  denoting constraints on the environment and system respectively.
They use temporal operators like LTL, but with quantifier-free first-order atoms 
instead of Boolean propositions.
The assumption \texttt{F G [add <= 0]} uses the temporal operators \texttt{F} (eventually) and  \texttt{G} (globally) to state that from some point on, no more load will be added by the environment.
The assert statement in line \ref{lst:lassert} requires the system to ensure, under the above assumption, that both loads eventually stabilize at zero. 
The semantics of a \texttt{\textcolor{blue}{formula}} specification is that the conjunction of the assumptions implies the conjunction of the asserts. 

The possible actions of the system and the requirement to balance \texttt{load1} and \texttt{load2} are described by the 
\texttt{\textcolor{blue}{game}} specification in Listing~\ref{lst:example}. The game has locations \texttt{init}, \texttt{lbal}, \texttt{lrem}, \texttt{done}, \texttt{err} that are local to the game, unlike variables that are global to the whole specification.
The transitions between locations in the game are defined via  quantifier-free formulas over input, state, and next-state variables (such as \texttt{load1'}).  Nondeterminism is under the control of the system.  The \issy format enables the use of macros to formula readability. 
For example,  the transition in line \ref{lst:lremerr} requires the system to transition from location  \texttt{lrem} to the unsafe location \texttt{err} if the condition \texttt{balanced} defined by the macro in line \ref{lst:baldef} is violated. 
The game has a \emph{safety} winning condition,  indicated by the keyword \texttt{\textcolor{blue}{Safety}}, and defined by the natural numbers with which the locations are labelled ($0$ indicates that \texttt{err} is unsafe, while all  labelled $1$  are safe).
\end{example}

A specification can contain multiple \texttt{\textcolor{blue}{formula}} and \texttt{\textcolor{blue}{game}} components,  interpreted conjunctively.  The semantics is a two-player game defined as the product of the games for the individual formulas and all game specifications.  
\issy requires and checks that at most one of these games has a non-safety winning condition. 

The \issy specification in \Cref{ex:simple-example} illustrates the modelling flexibility of the format. Expressing the same requirements purely in \rpltl\ or as an RPG results in a difficult to write and understand specification,  making the specification process error prone.  We believe that \issy  alleviates this problem to some extent, offering modularity and syntactic sugar constructs, and,  most importantly, unifying the temporal logic and game formats for 
infinite-state reactive systems.\looseness=-1

\vspace{-.3cm}
\paragraph{The \issy compiler and the \llissy format.}
The \issy compiler,  part of our synthesis framework,  compiles specifications in  \issy format to a low-level intermediate format called \llissy,  given in \Cref{sec:format-llissy}.
The compiler checks compliance with the syntax and gives informative error messages.
The \llissy format is easier to parse, while retaining the ability to specify both logical formulas and games. 
We envision that the development of tools  for translation from various high-level specification formats to the \llissy format will enable the seamless exchange of benchmarks and experimental comparison between different tools.
\issy also accepts input directly in \issy format, as well as the older formats  \textsf{tslmt} and \textsf{rpg}.


