Reactive systems are computational systems that constantly interact with their environment and run indefinitely.  Notable examples include communication protocols and controllers for embedded systems or robots.  Reactive synthesis is the problem of automatically generating correct-by-construction reactive systems from formal specifications describing the system's desired behavior.
Many target applications of synthesis require the treatment of \emph{infinite-state} models,  as they operate with unbounded data such as integers.
For this reason, the synthesis of reactive systems over infinite data domains has received increasing  attention over the last years.  In this paper, we present \issy, a comprehensive open-source  tool for the specification and synthesis of infinite-state reactive systems,  that builds upon recently developed approaches and newly engineered efficient techniques.
\issy{} comes with an expressive specification language that encompasses current formalisms,  thus providing a basis for the further development of synthesis tools.

\input{table-input}

Requirements for reactive systems are typically specified using temporal logics,  such as Linear Temporal Logic (LTL)~\cite{Pnueli77} in the case of finite-state systems. 
 Alternatively,  the synthesis problem can be described as a \emph{two-player game} modelling the interaction between a system and its environment.  These specification formalisms have been extended to the setting of infinite-state systems, resulting in temporal logics such as TSL-MT~\cite{FinkbeinerHP22}, LTL$_\mathcal T$~\cite{RodriguezS23}, and \rpltl~\cite{HeimD25},  on the one hand,  and infinite-state game models, such as reactive program games (RPGs)~\cite{HeimD24} on the other.
\Cref{table:compare-input} summarizes the types of specifications used in the main existing  prototype tools for realizability and synthesis of infinite-state reactive systems,  and that of our new tool \issy presented in this paper.
Most of the tools fall into one of two categories: those that support temporal logic formulas (\temos~\cite{ChoiFPS22},  \raboniel~\cite{MaderbacherB22}, the \cesars, sweap~\cite{AzzopardiPSS24}, \tslmtrpg~\cite{HeimD25}) and those using directly two-player games
(\gensys~\cite{SamuelDK21}, \gensysltl~\cite{SamuelDK23}, \simsynth~\cite{FarzanK18},  \rpgsolve~\cite{HeimD24},  \rpgstela~\cite{SchmuckHDN24}).
However, different types of requirements are more naturally modelled in one formalism or the other. 
For example,  constraints that depend heavily of the systems' state or execution phase (such as, for instance, the available moves of a robot) are often difficult to express in temporal logic, and result in long and complex formulas.  High-level mission requirements, on the other hand,  are more naturally formalized in temporal logics.  Motivated by this, we developed \issy with support for a new input format that unites both specification paradigms.  
Often, even tools using the same specification logic have different input formats, such as for example the tools in \Cref{table:compare-input} using TSL-MT. 
In contrast to the case for finite-state systems, where an established specification format, TLSF~\cite{JacobsPS23},  exists and is used in SYNTCOMP~\cite{syntcomp},  there is no such common format for  infinite-state reactive systems. 
We envision that the \issy framework is a major step towards filling this gap.
The \issy input format  supports the main types of synthesis objectives,  possibly infinite domains for both the input and the output variables of the specified system,  and three basic data types (bool, int, and real).  As \Cref{table:compare-input} shows,  the specification capabilities of \issy strictly subsume those of the  existing tools.\looseness=-1

\input{table-techniques}

\vspace{-.9cm}

The synthesis problem for infinite-state systems is in general undecidable.  
From \Cref{table:compare-input},  only~\cite{RodriguezS23,RodriguezS24}  considers a decidable restriction of the problem. The others implement different incomplete techniques summarized in \Cref{table:compare-techniques}.
One of the common approaches,  used in \temos, \raboniel,  and sweep,  is abstraction to synthesis from LTL specifications, accompanied by some form of specification refinement.  Alternatives include  fixpoint-based game-solving as~\cite{SamuelDK21,SamuelDK23}, and constraint solving as in \simsynth and \muval, the last of which is a tool for solving first-order fixpoint constraints.
In~\cite{HeimD24} we proposed a technique for solving infinite-state games that aims to address one of the limitations of prior abstraction and fixpoint-based approaches, namely, that they usually diverge on game-solving tasks that require reasoning about the unbounded iteration of strategic decisions.  
The core of~\cite{HeimD24} is a technique called \emph{attractor acceleration} that employs \emph{ranking arguments} to improve the convergence of symbolic game-solving procedures. 
\cite{AzzopardiPSS24}  also addresses unbounded behavior,  in the context of abstraction-based methods by introducing the so called liveness refinement. 
Column ``Unb.  Loop'' indicates which of the techniques handle unbounded strategy loops.  Further, the table indicates whether the tool performs synthesis (or only checks realizability,  that is, the existence of an implementation for the specification). Finally , we also indicate the main technologies (LTL synthesis,  SMT, translation of LTL to automata) used by each tool, and whether the tool is available open-source. 

 \issy builds on the acceleration technique in~\cite{HeimD24},  but in addition to the new input format,  integrates methods and ideas from our recent work~\cite{SchmuckHDN24} and \cite{HeimD25},  as well as novel techniques discussed in \Cref{sec:solver}. 
We evaluate \issy on an extensive set of benchmarks,  demonstrating its competitiveness with the state of the art.




