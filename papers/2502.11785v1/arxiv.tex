%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% LaTeX Template for AAMAS-2025 (based on sample-sigconf.tex)
%%% Prepared by the AAMAS-2025 Program Chairs based on the version from AAMAS-2025. 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Start your document with the \documentclass command.


%%% == IMPORTANT ==
%%% Use the first variant below for the final paper (including auithor information).
%%% Use the second variant below to anonymize your submission (no authoir information shown).
%%% For further information on anonymity and double-blind reviewing, 
%%% please consult the call for paper information
%%% https://aamas2025.org/index.php/conference/calls/submission-instructions-main-technical-track/

%%%% For anonymized submission, use this
%\documentclass[sigconf,anonymous]{aamas} 

%%%% For camera-ready, use this
%\documentclass[sigconf]{aamas} 

\newif\ifarxiv
\arxivtrue
%\arxivfalse

\ifarxiv 
\documentclass[sigconf, nonacm, authorversion]{aamas} 
\fi

\ifarxiv \else
%%%% For camera-ready, use this
\documentclass[sigconf]{aamas} 
\fi


%%% Load required packages here (note that many are included already).

\usepackage{algorithm}


\usepackage{enumerate}
\usepackage[shortlabels]{enumitem}

\let\Bbbk\relax %This was added to avoid the error "Command `\Bbbk' already defined."

% The following two lines were added due to the error "Too many math alphabets used in version normal."
\newcommand\hmmax{0}
\newcommand\bmmax{0}

%\usepackage{logicproof} 
\usepackage{amsmath, amsthm}
%\usepackage{amssymb}
%\usepackage{stmaryrd}
\usepackage{algpseudocode}
\usepackage{multicol}
\usepackage{tikz}
\usetikzlibrary{shapes.misc, fit, decorations.pathreplacing,calligraphy,positioning} %for crossing-out arrows and rectangles around nodes
\usepackage{float}
\usepackage{harmony}
\usepackage{scalerel}
\usepackage{cleveref}
\usepackage{xcolor}
\usepackage{MnSymbol}
%\usepackage{yfonts} %for Nima
%\usepackage[makeroom]{cancel} %for crossing out math text
\usepackage{bm,xspace} %for formating complexity classes

\usepackage{soul}
%\setlength {\marginparwidth }{2cm}
%\usepackage{todonotes}
%\newcommand\rustam[1]{\todo[color=blue!30,size=\small,inline]{\textbf{Rustam}: #1}}
%\newcommand\maksim[1]{\todo[color=green!30,size=\small,inline]{\textbf{Maksim}: #1}}
%\newcommand\munyque[1]{\todo[color=orange!30,size=\small,inline]{\textbf{Munyque}: #1}}
%\newcommand\nima[1]{\todo[color=red!30,size=\small,inline]{\textgoth{Prof. Motamed}: #1}}
\newcommand{\munyquem}[1]{{\color{black}#1}}
\newcommand{\rust}[1]{{\color{black}#1}}
\newcommand{\maks}[1]{{\color{black}#1}}

\algtext*{EndIf}
\algtext*{EndFor}
\renewcommand{\sl}{\mathfrak{sl}}

\algnewcommand\algorithmiccase{\textbf{case}}
\algdef{SE}[CASE]{Case}{EndCase}[1]{\algorithmiccase\ #1}{\algorithmicend\ \algorithmiccase}%
\algtext*{EndCase}

\makeatletter
\newenvironment{breakablealgorithm}
  {% \begin{breakablealgorithm}
   \begin{center}
     \refstepcounter{algorithm}% New algorithm
     \hrule height.8pt depth0pt \kern2pt% \@fs@pre for \@fs@ruled
     \renewcommand{\caption}[2][\relax]{% Make a new \caption
       {\raggedright\textbf{\fname@algorithm~\thealgorithm} ##2\par}%
       \ifx\relax##1\relax % #1 is \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##2}%
       \else % #1 is not \relax
         \addcontentsline{loa}{algorithm}{\protect\numberline{\thealgorithm}##1}%
       \fi
       \kern2pt\hrule\kern2pt
     }
  }{% \end{breakablealgorithm}
     \kern2pt\hrule\relax% \@fs@post for \@fs@ruled
   \end{center}
  }
\makeatother

%=================================================================================================================================

\newcommand{\lcirc}[1]{\mathchoice
{\mathbin{\vcenter{\hbox{\scaleobj{.75}{\mbox{\Kr{$#1$}}}}}}}
{\mathbin{\vcenter{\hbox{\scaleobj{.75}{\mbox{\Kr{$#1$}}}}}}}
{\mathbin{\vcenter{\hbox{\scaleobj{.5}{\mbox{\Kr{$#1$}}}}}}}
{\mathbin{\vcenter{\hbox{\scaleobj{.5}{\mbox{\Kr{$#1$}}}}}}}
}

\newcommand{\suggestion}[1]{{\color{blue}#1}}
\newcommand{\remove}[1]{{\color{red}#1}}

%=================================================================================================================================
%LETTERS:
\newcommand{\cM}{\mathcal{M}}
\newcommand{\cN}{\mathcal{N}}
\newcommand{\cE}{\mathcal{E}}
\newcommand{\cF}{\mathcal{F}}
\newcommand{\cS}{\mathcal{S}}
\newcommand{\cL}{\mathcal{L}}
\newcommand{\cV}{\mathcal{V}}
\newcommand{\cR}{\mathcal{R}}
\newcommand{\cA}{\mathcal{A}}
\newcommand{\cP}{\mathcal{P}}
\newcommand{\cC}{\mathcal{C}}
\newcommand{\cQ}{\mathcal{Q}}
\newcommand{\lb}{\langle}
\newcommand{\rb}{\rangle}
\newcommand{\llb}{\lb \! \lb}
\newcommand{\rrb}{\rb \! \rb}
\newcommand{\cU}{\mathcal{U}}
\newcommand{\cI}{\mathcal{I}}
\newcommand{\cO}{\mathcal{O}}
\newcommand{\cH}{\mathcal{H}}
\newcommand{\cW}{\mathcal{W}}
\newcommand{\cT}{\mathcal{T}}


\newcommand{\X}{\mathsf{X}}
\newcommand{\M}{\mathsf{M}}
\newcommand{\N}{\Nom}
\newcommand{\U}{\mathsf{U}}
\newcommand{\R}{\mathsf{R}}
\newcommand{\G}{\mathsf{G}}
\newcommand{\E}{\mathsf{E}}
\newcommand{\F}{\mathsf{F}}
\newcommand{\Y}{\mathsf{Y}}
\newcommand{\K}{\mathsf{K}}
\newcommand{\C}{\mathsf{C}}
\newcommand{\sfS}{\mathsf{S}}
\newcommand{\s}{\mathsf{s}}
\newcommand{\sft}{\mathsf{t}}


%====================================

\newcommand{\mM}{\mathfrak{M}}

%====================================


\newcommand{\AG}{\mathit{Agt}}
\newcommand{\AP}{\mathit{Prop}}
\newcommand{\Nom}{\mathit{Nom}}
\newcommand{\Act}{\mathit{Act}}
\newcommand{\act}{\mathit{act}}
\newcommand{\Env}{\mathit{Env}}
\newcommand{\pre}{\mathit{pre}}
\newcommand{\out}{\mathit{out}}

%=============

%To denote logics

\newcommand{\CL}{\mathsf{CL}}
\newcommand{\CLTL}{\mathcal{L}_\mathsf{CLTL}}
\newcommand{\CEL}{\mathcal{L}^\mathsf{C}_{\mathsf{E}}}
\newcommand{\CELTL}{\mathcal{L}^\mathsf{C}_\mathsf{ELTL}}
\newcommand{\LTL}{\mathsf{LTL}}
\newcommand{\ATL}{\mathsf{ATL}}
\newcommand{\ATLstar}{\mathsf{ATL}^*}
\newcommand{\SL}{\mathsf{SL}}
\newcommand{\LAMB}{\mathsf{LAMB}}
\newcommand{\HATL}{\mathsf{HATL}}


\protected\def\Ptime{\ifmmode \mbox{\sc P} \else {\sc P}\xspace\fi}
\protected\def\Pspace{\ifmmode \mbox{\sc Pspace} \else {\sc Pspace}\xspace\fi}
\protected\def\Exptime{\ifmmode \mbox{\sc Exptime} \else {\sc Exptime}\xspace\fi}
\protected\def\Dexptime{\ifmmode \mbox{\sc 2Exptime} \else {\sc 2Exptime}\xspace\fi}
\protected\def\NONELEMENTARY{\ifmmode \mbox{\sc NonElementary} \else {\sc NonElementary}\xspace\fi}
\protected\def\NP{\ifmmode \mbox{\sc NP} \else {\sc NP}\xspace\fi}


% \newtheorem{theorem}{Theorem}
% \newtheorem*{theorem*}{Theorem}
% \newtheorem{lemma}{Lemma}
% \newtheorem{corollary}{Corollary}

% \theoremstyle{definition}

% \newtheorem{proposition}{Proposition}
% \newtheorem{example}{Example}
% \newtheorem{definition}{Definition}
\newtheorem{remark}{Remark}

%====================================================
%TIKZ settings
\usetikzlibrary{chains,fit,shapes}

\tikzset{%
round/.style={circle, draw=gray!60,fill=gray!5, very thick,minimum size=7mm, align=center},
dot/.style={draw, circle, minimum size=2mm,inner sep=0pt,outer sep=0pt,fill=black},% and so on
}

%==========================================

\usepackage{balance} % for balancing columns on the final page

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% AAMAS-2025 copyright block (do not change!)

\makeatletter
\gdef\@copyrightpermission{
  \begin{minipage}{0.2\columnwidth}
   \href{https://creativecommons.org/licenses/by/4.0/}{\includegraphics[width=0.90\textwidth]{by}}
  \end{minipage}\hfill
  \begin{minipage}{0.8\columnwidth}
   \href{https://creativecommons.org/licenses/by/4.0/}{This work is licensed under a Creative Commons Attribution International 4.0 License.}
  \end{minipage}
  \vspace{5pt}
}
\makeatother

\setcopyright{ifaamas}
\acmConference[AAMAS '25]{Proc.\@ of the 24th International Conference
on Autonomous Agents and Multiagent Systems (AAMAS 2025)}{May 19 -- 23, 2025}
{Detroit, Michigan, USA}{Y.~Vorobeychik, S.~Das, A.~Now√©  (eds.)}
\copyrightyear{2025}
\acmYear{2025}
\acmDOI{}
\acmPrice{}
\acmISBN{}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% == IMPORTANT ==
%%% Use this command to specify your OpenReview submission number.
%%% In anonymous mode, it will be printed on the first page.

\acmSubmissionID{<<OpenReview submission id>>}

%%% Use this command to specify the title of your paper.

\title[Changing the Rules of the Game]{Changing the Rules of the Game:\\
Reasoning about Dynamic Phenomena in Multi-Agent Systems}\thanks{This is an extended version of the same title paper that will appear in AAMAS
2025. This version contains a technical appendix with proof details that, for space reasons, do
not appear in the AAMAS 2025 version.}

% Add the subtitle below for an extended abstract
%\subtitle{AAAI Track}

%%% Provide names, affiliations, and email addresses for all authors.

\author{Rustam Galimullin}
\affiliation{
  \institution{University of Bergen}
  \city{Bergen}
  \country{Norway}}
\email{rustam.galimullin@uib.no}

\author{Maksim Gladyshev}
\affiliation{
  \institution{Utrecht University}
  \city{Utrecht}
  \country{The Netherlands}}
\email{m.gladyshev@uu.nl}

\author{Munyque Mittelmann}
\affiliation{
  \institution{University of Naples Federico II}
  \city{Naples}
  \country{Italy}}
\email{munyque.mittelmann@unina.it}

\author{Nima Motamed}
\affiliation{
  \institution{Utrecht University}
  \city{Utrecht}
  \country{The Netherlands}}
\email{n.motamed@uu.nl}


%%% Use this environment to specify a short abstract for your paper.

\begin{abstract}
The design and application of multi-agent systems (MAS) require reasoning about the effects of modifications on their underlying structure.  
In particular, such changes may impact the satisfaction of system specifications and the strategic abilities of their autonomous components. 
In this paper, we are concerned with the problem of verifying and synthesising modifications (or \textit{updates}) of MAS. 
We propose an extension of the Alternating-Time Temporal Logic ($\ATL$) that enables reasoning about the dynamics of model change, called the \textit{Logic for $\ATL$ Model Building} ($\LAMB$). We show how $\LAMB$ can express various intuitions and ideas about the dynamics of MAS, from normative updates to mechanism design.
%Finally, we formally study the logic and its fragments from the point of view of expressivity and model-checking complexity. 
As the main technical result, we prove that, while being strictly more expressive than $\ATL$, $\LAMB$ enjoys a \Ptime-complete model-checking procedure.

%We formally study the logic and its fragments with respect to the expressivity and complexity of model-checking.  
%As the main results, we show that the model-checking problem for $\LAMB$ is polynomial time complete and that it is more expressive than hybrid $\ATL$.  
%OLD abstract:
%Dynamic phenomena are ubiquitous in AI and multi-agent systems (MAS) research. Reasoning about such phenomena, from normative updates to mechanism design, in many cases can be captured by various strategy logics interpreted over concurrent game models (CGMs). From the conceptual side, we propose a more general treatment of such dynamic features by opening up the general research direction of updates (or modifications) of CGMs. From the technical side, we present a dynamic extension of alternating-time temporal logic ($\ATL$) that allows us to reason about modular updates of the underlying model. We call such an extension \textit{Logic for $\ATL$ Model Building} ($\LAMB$) and show how it can express various intuitions and ideas about the dynamics of MAS. Moreover, we study the expressive power of $\LAMB$ and the complexity of its model checking procedure.              
\end{abstract}

%%% The code below was generated by the tool at http://dl.acm.org/ccs.cfm.
%%% Please replace this example with code appropriate for your own paper.


%%% Use this command to specify a few keywords describing your work.
%%% Keywords should be separated by commas.

\keywords{\maks{Strategy Logics; Model Change; Formal Verification}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% Include any author-defined commands here.
         
\newcommand{\BibTeX}{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em\TeX}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

%%% The following commands remove the headers in your paper. For final 
%%% papers, these will be inserted during the pagination process.

\pagestyle{fancy}
\fancyhead{}

%%% The next command prints the information defined in the preamble.

\maketitle 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Introduction}
%\maksim{Here we go. We have 1.5 pages of extra space! I see some compilation errors, will check later.}

%\munyquem{
Mechanism Design is a subfield of game theory  concerned with the design of  
%is the problem of designing 
mathematical structures (i.e. \textit{mechanisms}) 
describing the interaction of strategic agents 
that achieve 
desirable economic properties 
under the assumption of rational behavior %that such individuals act rationally 
\cite{Nisan2007}.  %{jackson2014mechanism}. 
Although it originated in economics, mechanism design provides an important foundation for the creation and analysis of multi-agent systems (MAS) \cite{dash2003computational,phelps2010evolutionary}. 
In numerous situations, the protocols and institutions describing interactions have already been designed and implemented. When those do not comply with the designer's objective (i.e. the economic properties) their complete redesign may not be feasible. For instance, a university with 
a selection procedure seen as  \textit{unfair}, % or \textit{not efficient},
would avoid implementing an entirely new procedure, but could be willing to adjust the existing one. %it. 

Although logic-based approaches have been widely used for the verification \cite{Clarke2018}  and synthesis \cite{david2017program} of MAS, most research focuses on static or parametrised models and does not capture the dynamics of model change. One of the classic static approaches %first and most important developments 
in the field is the Alternating-time Temporal Logic ($\ATL$) \cite{alur2002}.  $\ATL$ expresses conditions on the strategic abilities of agents interacting in a MAS, represented by a concurrent game model (CGM). 
In this paper, we are concerned with the problem of reasoning about the effects of modifications on CGMs. %in the MAS model. 
%To do so, we propose the \textit{Logic for $\ATL$ Model Building} ($\LAMB$), which 
To tackle the problem, we extend $\ATL$ in two directions that have not been considered in the literature. 
First, we augment $\ATL$ with 
nominals and hybrid logic operators \cite{ARECES2007821}. The resulting logic is called Hybrid $\ATL$ ($\HATL$). $\HATL$ allows us to verify properties at states named by a given nominal, which cannot be captured by $\ATL$. Second, we propose the \textit{Logic for $\ATL$ Model Building} ($\LAMB$), which enhances $\HATL$ with update operators that describe explicit modular modifications in the model.%. These operators describe explicit modular modifications in the model.


We define three fundamental update operators in $\LAMB$. First, we can \textit{change the valuation} of some propositional variable in a particular state to the valuation of a given formula. %We denote this by $[p_\alpha:=\psi]\varphi$ meaning `after assigning variable $p$ in state $\alpha$ the truth-value of formula $\psi$ in the same state, $\varphi$ holds'. 
Second, we can \textit{switch the transition} from one state to another, 
%redirect an arrow starting from state $\alpha$ and labelled with an action profile $A = a_1,...,a_n$ to go to some state $\beta$. This is denoted by $[\alpha \xrightarrow{A} \beta]\varphi$, and 
which corresponds to modifying agents' abilities in a given state. 
Finally, we can \textit{add} a new state to the model and assign a fresh nominal to it. % All arrows labelled with all action profiles are reflexively closed on that state. Valuations of propositional variables are false. This operation is denoted by $[\lcirc{\alpha}]\varphi$ and means `after adding a new state and assigning it name $\alpha$, $\varphi$ holds'. We assume that if the state with name $\alpha$ already exists, then the action has no effect. 
More complex operations, like adding a state, assigning it some propositional variable and adding incoming/outgoing transitions to it can %, subsequently,
be described in our language as sequences of primitive updates.  

Our intuitions on model updates are guided by research in Dynamic Epistemic Logic ($\mathsf{DEL}$) \cite{hvdetal.del:2007}, where one can reason about the effects of epistemic events on agents' knowledge. While epistemic and strategic reasoning are quite different domains, various $\mathsf{DEL}$s have been considered in the strategic setting (see, e.g., \cite{maubert20,delima14,agotnes08}). At the same time, research on updating models for strategic reasoning has been relatively sporadic and predominantly within the area of normative reasoning \cite{alechina18,alechina2022automatic}.     


%One of the first and most important developments in using Formal Methods for the Strategic Reasoning in MAS is the Alternating-time Temporal Logic T 

%\textbf{Contribution. } 
We deem our contribution to be two-fold. On the \textit{conceptual level}, we propose the exploration of general logic-based approaches to dynamic phenomena in MAS, not confined to particular implementation areas. 
On the \textit{technical level}, we propose a new %logic-based
formalism, $\LAMB$, to reason about modifications on MAS that
%$\LAMB$ 
enables the verification of the strategic behavior of agents acting in a changing environment, and the synthesis of modifications on CGMs. %to satisfy \rust{a given specification.} %an $\ATL$ specification. % temporal specification. 
We show how $\LAMB$ can express
various intuitions and ideas about the dynamics of MAS from
normative updates to mechanism design. We also formally study
the logic (and some of its fragments) from the point of view of expressivity and model-checking complexity. 
Our results show that $\LAMB$ is strictly more expressive than $\HATL$, which, in turn, is strictly more expressive than $\ATL$.  
Finally, we present a \Ptime-complete algorithm for model checking $\LAMB$.
%Finally, we present an algorithm for model checking $\LAMB$, and show that the problem is \Ptime-complete. 
%\ifarxiv 
%This paper is the extended version of the paper with the same title accepted at AAMAS 2025. 
%\else
%\textcolor{blue}{Detailed proofs are presented in the extended version of this paper, available on ArXiV [add url]. }
%\fi 

%This problem consists of modifying the objectives or strategies of the players to obtain stability or to improve social welfare.
%Normative Systems Automatic Synthesis of Dynamic Norms for Multi-Agent Systems


%\paragraph{Outline.} (If space allows)

%\munyquem{} Advantages: relying on formal methods - correct by construction. The modifications are "programs" (steps describing how to "fix" the game).  Small cost w.r.t. sl.

%" In artificial intelligence, and in particular in the multi-agent systems research field, social laws, norms, and sanctions have been widely proposed as flexible means for coordinating the behaviour of autonomous agents in multi-agent settings. " Bulling and Dastani

%A mechanism is simply a  mathematical structure (or a game) specifying how  economic decisions are made in a MAS


%%\munyque{I incorporated some of the following in the introduction, without the formal notation. }
%\paragraph*{Overall idea}
%In our setting, there are three fundamental operations for \suggestion{(re)}building new models. First, we can change a valuation of some propositional variable in a particular state to the valuation of a given formula. We denote this by $[p_\alpha:=\psi]\varphi$ meaning `after assigning variable $p$ in state $\alpha$ the truth-value of formula $\psi$ in the same state, $\varphi$ holds'.

%Second, we can redirect an arrow starting from state $\alpha$ and labelled with an action profile $A = a_1,...,a_n$ to go to some state $\beta$. This is denoted by $[\alpha \xrightarrow{A} \beta]\varphi$, and corresponds to modifying agents' abilities in a given state of a game. 

%Finally, we can add a new state to the model and assign a fresh nominal to it. All arrows labelled with all action profiles are reflexively closed on that state. Valuations of propositional variables are false. This operation is denoted by $[\lcirc{\alpha}]\varphi$ and means `after adding a new state and assigning it name $\alpha$, $\varphi$ holds'. We assume that if the state with name $\alpha$ already exists, then the action has no effect. 

%\munyque{Do we need to justify why new states have self-loops and all propositions are false?  }



%More complex actions, like adding a state and assigning it some propositional variable or adding incoming or outgoing arrows can be described in our language as sequences of primitive actions and treated as abbreviations. 


\section{Reasoning About Strategic Abilities in the Changing Environment}

%\munyque{This section is a bit too long. We are presenting the models, HATL, and $\LAMB$. Can we separate in two? E.g., one for models+HATL, another for LAMB. }
  
\subsection{Models}

%\maksim{we can save 1 line by removing this heading}
%\rustam{yes, if we need to! i still think it is nice to have a separate heading for this big chunk of text}

Let $\AG = \{1,...,n\}$ be a non-empty finite set of agents. We will call subsets $C \subseteq \AG$ \textit{coalitions}, and complements $\overline{C}$ of $C$ \textit{anti-coalitions}. Sometimes we also call $\AG$ \textit{the grand coalition}. Moreover, let $\AP = \{p, q, ...\}$ and $\Nom = \{\alpha, \beta, ...\}$ be disjoint countably infinite sets of \textit{atomic propositions} and \textit{nominals} correspondingly. Finally, let $\Act = \{a_1, ..., a_m\}$ be a non-empty finite set of actions. 


\begin{definition}[Named CGM]\label{def:cgs} \maks{Given a set of atomic propositions $\AP$, nominals $\Nom$ and agents $\AG$, a} \emph{named Concurrent Game Model} (nCGM) is a tuple $M = \lb S, \tau, L\rb$, where:
\begin{itemize}
    \item $S$ is a non-empty finite set of states;
    \item $\tau: 
    %\{(s,a_1, ..., a_n) \mid s \in S, a_i \in \Act\} \to S$ 
    S\times \Act^{\AG} \to S$ is a transition function that assigns the outcome state $s' =\tau(s, (a_1,\dots, a_n))$ to a state $s$ and a tuple of actions $(a_1,\dots, a_n)$;
    \item $L: \AP \cup \Nom \to 2^{S}$ is a valuation function such that for all $\alpha \in \Nom: |L(\alpha)|\leqslant 1$ and for all $s \in S$, there is some $\alpha \in \Nom$ such that $L(\alpha) = \{s\}$.
\end{itemize}
We denote an nCGM $M$ with a \rust{designated} state $s$ as $M_s$.
%\suggestion{In this paper, we restrict our attention to named CGMs.}
Since all CGMs we are dealing with in this paper are named, we will abuse terminology and call nCGMs just CGMs.

Let $True(s)=\{p\in \AP \mid s\in L(p)\}\cup \{\alpha\in \Nom \mid s\in L(\alpha)\}$ be the set of all propositional variables and nominals that are true in state $s$. We define the \emph{size} of CGM $M$ as $|M| = |\AG| + |\Act| + |S| + |\tau| + \sum\limits_{s\in S}|True(s)|$, where $|\tau| = |S|\cdot |Act|^{|\AG|}$. We call a CGM \emph{finite}, if $|M|$ is finite. In this paper, we restrict our attention to finite models.
%All models we are dealing with in this paper are finite.

%Finally, let $True(s)=\{p\in \AP \mid p\in L(s)\}\cup \{\alpha\in \Nom \mid \alpha\in L(\alpha)\}$. We call a model \emph{finite} if for all $s\in S$, $True(s)$ is finite. Note that both $S$ and $\tau$ are finite by \Cref{def:cgs}. Given a finite model $M$, the size of $M$, denoted by $|M|$, is defined as follows: 
%$$|M| := |S| + |\tau| + \sum\limits_{s\in S}|True(s)|,$$
%where $|\tau| = |S|\cdot |Act|^{|\AG|}$.
\end{definition}

Our models differ from standard CGMs in two ways. First, similarly to hybrid logic \cite{ARECES2007821}, states of our models have names represented by nominals $\Nom$. So, each nominal is assigned to at most one state, but each state may have multiple names. Observe that differently from hybrid logic, we allow nominals to have empty extensions, that is, to not be
assigned to any state. In the next section we will use this property to ensure that once new states are introduced to a model, we always have names available for them.  Finally, we also assume that our models are \textit{properly named}, i.e. each state is assigned some nominal. 

% \munyque{If one is not familiar with nominal, it is not clear what "satisfies" means here, because we have not introduced the semantics yet. Maybe: "each state of a given model is assigned/associated to a nominal." }
% \rustam{We'll rewrite it properly, I put this text just for us (:}

% \maksim{We can call it just 'a name' of a state instead of a 'nominal' here.}

We also assume that all agents have the whole set $\Act$ of actions available to them. Such an assumption is relatively common in the strategy logics literature (see, e.g., \cite{mogavero10,aminof2019probabilistic,BOZZELLI2020199}), and allows for a clearer presentation of our framework. 

%Another major difference of our models from standard CGMs is that in our setting, we assume that all agents have the whole set $\Act$ of actions available to them. Such an assumption is relatively common in the strategy logics literature (see, e.g., \cite{mogavero10,aminof2019probabilistic,BOZZELLI2020199}), and allows for a clearer presentation of our framework. 

%\maksim{\textbf{Justification here. Papers to mention: \cite{BOZZELLI2020199}, \cite{aminof2019probabilistic}, ... Anything esle? }}

% \rustam{Here we should really justify it mentioning, perhaps, that it is quite a common assumptions in games.}

% \maksim{I am trying to find a paper mentioning that, but cannot yet (I am pretty sure I saw a few). But we still need it for technical reasons: otherwise some updates can be problematic.}

% \maksim{Ok, it seems that here \cite{BOZZELLI2020199} they use the same assumption, but do not provide any discussion on the topic.}

% \munyque{The assumption that all the actions are available at any time is not very standard in the context of ATL/SL. Another example is \cite{aminof2019probabilistic}. The main reason for not using it seems to be convenience (simpler definitions). I believe we should either (i) argue that we don't lose much / our setting is still interesting, or (ii) use an availability function.

% --

% Suggestion if we would like to do (ii): 

% \smallskip

% In the CGM definition: 

% -  $d: \AG\times S \to 2^{\Act}$ is an availability function, defining the available actions of an agent in a state
  
    
% - $\tau:S\times DC \to S$ is the (partial) transition function such that $\tau(s, d_{\AG})$ is defined for a state $s$ and a joint action $d_{\AG} = (a_1, ..., a_{|C|})$ only if for every agent $i\in\AG$, $a_i\in d(i,s)$.

% \smallskip

% We consider only strategies where the actions are available.

% \smallskip

% The language could be extended with $\alpha \oplus (i, a)$   (action a becomes available for i in $\alpha$) and $\alpha \ominus (i, a)$   (action a is no longer available for i in $\alpha$). 

% \smallskip

% Semantics idea:

% \smallskip

% Let $M$ be a model, $s_\alpha$ the state with name $\alpha$:

% - The model is updated only if needed (e.g., given the formula $[\alpha \oplus (i, a)]\phi$, $\phi$ is checked in $M$ if $a\in d(i,s_\alpha)$).

% - Otherwise: for $\oplus$,  define the updated model $M^{\alpha \oplus (i, a)} = \langle S, d', \tau', L\rangle$ such that:

% $\qquad$ - the  updated availability function  $d'$ is equal to $d$ except that $d'(i, s_\alpha)$  also includes $a$.

% $\qquad$ - for each joint action $d_{\AG}$ available in $s_\alpha$, 
% $\tau'(s_\alpha, d_{\AG}) =\tau(s_\alpha, d_{\AG})$ if the action of $i$ in $d_{\AG}$ is not $a$. Otherwise, $\tau'(s_\alpha, d_{\AG}) = s_\alpha$ (that is, the new action defines a self-loop for all others' actions - this is in line with the model update performed when a new state is added).

% - For $\ominus$, the model update is similar (transitions are only defined if they exist in the original model and they do not contain the action $a$ for $i$).


% }

% \maksim{@Munyque,@all, I believe we should stick to (i) option for simplicity. In my opinion (ii)'nd option has several disadvantages. 

% Firstly, the semantics of $[\alpha \xrightarrow{A} \beta]$ update breaks. Recall that $[\alpha \xrightarrow{A} \beta]$ means 'now an action profile A in a state $\alpha$ goes to state $\beta$' (@all, I think it needs a better definition in Def. 5). In case of (i), when we have uniformity of actions (idk if there is a term for it, but I will call it \textit{uniformity}), we know that any profile A is available at any state $\alpha$. So, there is no problem to 'rewrite' one transition within a model. In case of (ii) we need to check availability of A first and if this profile is \textbf{not} available in $\alpha$, we need to: either make this update 'unsuccessful' and do not change the model at all, which seems undesirable to me \textbf{or} to make new actions available to agents in $\alpha$ and define a new transition. But in the latter case we have a lot of undefined transitions, since the set of complete action profiles increased. And update $[\alpha \xrightarrow{A} \beta]$ does not provide any information on where these transitions must go. So, the only reasonable solution to preserve the updated model as a well-defined SGM is to make those transitions self-looped. 

% \ \

% And this is the second point. As Munyque said, $[\alpha \oplus (i, a)]\phi$ update also results in adding self-loops to the model. I think we discussed this issue, because it also occurred in \cite{galimullin2022action} and agreed that this could be considered an \textit{ad hoc} solution. 

% \ \

% Maybe it is not difficult to argue that we do not lose much sticking to action uniformity. I am pretty sure that there must be some results on the equivalence of such representations (with vs without uniformity). Or maybe we can show something like that ourselves? That given any SCG without action uniformity, we can extend it to a uniform one by 'duplicating' some transitions. The resulting model will contain more transitions, but they will only be 'duplicates' of the old ones, so agents do not gain any extra power. But I may be wrong here. At least I cannot find a  counterexample, where something can be modelled by a non-uniform model and cannot be by a uniform one. 

% And finally, we can also discuss the (ii) alternative in the Discussion and maybe even show that model-checking will have the same complexity in both cases. 

% }


\begin{definition}[Strategies] Given a coalition $C\subseteq \AG$, an \emph{action profile \rust{for coalition $C$}}, $A_C$,
is an element of $\Act^C$, and %which is the set of all tuples $(a_1,\dots , a_{|C|})$ of actions $a_i$ for all $i \in C$. %So, $A_C$ assigns to each agent $i\in C$ some action from $\Act$. 
$\Act^{\AG}$ is the set of all \textit{complete} action profiles, i.e. all tuples $(a_1, \dots, a_n)$ for $\AG = \{1, \dots, n\}$. 

Given an action profile $A_C$, 
     we write $\tau(s, A_C)$ to denote a set $\{%\tau (s, A)\mid A = A_C \cup A_{\overline{C}} 
     \tau (s,A)\mid A = A_C \cup A_{\overline{C}} , A_{\overline{C}}\in  Act^{\overline{C}} \}$.
     Intuitively, $\tau(s, A_C)$ is the set of all states reachable by (complete) action profiles that extend a given action profile $A_C$\rust{\footnote{\rust{Here, we here slightly abuse the notation and treat, whenever convenient, action profiles as sets rather than ordered tuples.}}}.
    
    A \emph{(memoryless) strategy profile} for $C$ is a function $\sigma_C: S \times C \to \Act$ with $\sigma_C(s,i)$ being an action agent $i$ takes in $s$.
    
    
    Given a CGM $M$, a \emph{play} $\lambda = s_0 s_1 \cdots$ is an infinite sequence of states in $S$ such that for all $i \geqslant 0$, state $s_{i+1}$ is a successor of $s_i$ i.e., there exists an action profile $A \in Act^{Agt}$ s.t. $\tau(s_i, A) = s_{i+1}$. We will denote the $i$-th element of play $\lambda$ by $\lambda[i]$. The set of all plays that can be realised by coalition $C$ following strategy $\sigma_C$ from some given state $s$, denoted by $\Lambda^s_{\sigma_C}$, %(s, \sigma_C)$, 
    is defined as
    $$\{\lambda \mid \lambda[0] = s \text{ and } \forall i \in \mathbb{N}: \lambda[i+1] \in \tau(\lambda[i], \sigma_C (\lambda[i]))\}.$$
\end{definition}

\rust{
\begin{remark}
    Note that we consider only memoryless (positional) strategies here. One can also employ memory-full (perfect recall) strategies, where the choice of actions by a coalition depends not on the current state, but on the whole history of the system up to the given moment. We resort to the former for simplicity. Observe, however, that for $\ATL$, the semantics based on these two types of strategies are equivalent \cite{alur2002,schobbens04,jamroga15}.  
    We conjecture that this is also the case for $\LAMB$, and leave it for future work.
\end{remark}
}

\begin{example}
Examples of CGMs are given in Figure \ref{fig::exampleCGM}, where an arrow labelled, for example, by $ab$ denotes the action profile, where agent $1$ takes action $a$ and agent $2$ takes action $b$. 
In a state $s$ of model $M$,  the two agents can make a transition to state $t$, if they synchronise on their actions, i.e. if they choose the same actions. In model $N$, on the other hand, a similar transition can be performed whenever they choose  different actions. 
\begin{figure}[h!]
\centering
\scalebox{0.75}{
\begin{tikzpicture}
\node(-1) at (2,0) {$M$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$s:\alpha$}](1) at (0,0) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=below:{$t:\beta$}](2) at (4,0) {};

\draw [->,thick](1) to [loop above] node[above, align=left] {$ab,ba$} (1);
\draw [->,thick](1) to [bend right] node[below,align=left] {$aa,bb$} (2);
\draw [->,thick] (2) to [bend right] node[above,align=left] {$aa,bb$} (1);
\draw [->,thick] (2) to [loop above] node[above,align=left] {$ab,ba$} (2);
\end{tikzpicture}
\hspace{10mm}
\begin{tikzpicture}
\node(-1) at (2,0) {$N$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$s:\alpha$}](1) at (0,0) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=below:{$t:\beta$}](2) at (4,0) {};

\draw [->,thick] (1) to [loop above] node[above, align=left] {$aa,bb$} (1);
\draw [->,thick](1) to [bend right] node[below,align=left] {$ab,ba$} (2);
\draw [->,thick] (2) to [bend right] node[above,align=left] {$ab,ba$} (1);
\draw [->,thick] (2) to [loop above] node[above,align=left] {$aa,bb$} (2);
\end{tikzpicture}
}
\caption{CGMs $M$ and $N$ for two agents and two actions. Propositional variable $p$ is true in black states, and nominals $\alpha$ and $\beta$ are true in their corresponding states.}
\label{fig::exampleCGM}
\end{figure} 
\end{example}


%\maksim{Maybe to put the figure under the text? I think now it looks a bit confusing.}



\subsection{Hybrid $\ATL$}

%We start by presenting an extension of $\ATL$ with hybrid logic features that, to the best of our knowledge, has never been considered in the literature before. 
We start %by presenting 
with an extension of $\ATL$ with hybrid logic features that allow us to express properties at states named by a given nominal. %%%NOTE (MM): We already mentioned that it is the first extension of ATL with hybrid in the introduction and later in the expressivity (no need to include it here).

\begin{definition}[Syntax of $\mathsf{HATL}$] The language of Hybrid ATL ($\mathsf{HATL}$) logic is defined recursively as follows
   \begin{alignat*}{3}
        &\mathsf{HATL} &&\thinspace \ni && \enspace \varphi ::= p \mid \alpha \mid @_\alpha \varphi \mid \neg \varphi \mid (\varphi \land \varphi) \mid \llb C \rrb \X \varphi \mid\\ 
        & && &&\mid \llb C \rrb \varphi \U \varphi \mid \llb C \rrb \varphi \mathsf{R} \varphi
\end{alignat*}
where $p \in \AP$, $\alpha \in \Nom$ and $C \subseteq \AG$. %The fragment of $\mathsf{HATL}$ without $\alpha$ and $@_\alpha \varphi$ is called \emph{alternating-time temporal logic} ($\ATL$)
The fragment of $\mathsf{HATL}$ without $\alpha$ and $@_\alpha \varphi$ corresponds to $\ATL$ 
\footnote{We define $\mathsf{ATL}$ over $\{\llb C \rrb \X\varphi,$ $\llb C \rrb\varphi \U \varphi,$ $\llb C \rrb \varphi \mathsf{R} \varphi\}$  as it is strictly more expressive than $\mathsf{ATL}$ defined over $\{\llb C \rrb \X\varphi,$ $\llb C \rrb\varphi \U \varphi,$ $\llb C \rrb \G \varphi\}$ \cite{Laroussinie2008}.% In this paper we use $\{\llb C \rrb \X\varphi, \llb C \rrb\varphi \U \varphi, \llb C \rrb \varphi \mathsf{R} \varphi\}$ as basic $\mathsf{ATL}$ modalities for extra expressivity: it is known \cite{Laroussinie2008} that $\llb C \rrb \varphi \mathsf{R} \varphi$ cannot be expressed with $\{\llb C \rrb \X\varphi, \llb C \rrb\varphi \U \varphi, \llb C \rrb \G \varphi\}$ operators, while $\llb C \rrb \G \varphi$ is expressible with $\{\llb C \rrb \X\varphi, \llb C \rrb\varphi \U \varphi, \llb C \rrb \varphi \mathsf{R} \varphi\}$.
}. %We also refer to the \emph{static fragment} of $\LAMB$, i.e.  the fragment without $[\pi]\varphi$, as \emph{Hybrid} $\ATL$ ($\mathsf{HATL}$).
\end{definition}

%\munyque{If we need space, we can omit the footnote about why we consider R instead of G. }
Here, $\llb C \rrb \X\varphi$ means that a coalition $C$ can ensure that $\varphi$ holds in the ne$\X$t state. The operator $\llb C \rrb\varphi \U \psi$ (here $\U$ stands for \textit{$\U$ntil}) means that $C$ has a strategy to enforce $\psi$ while maintaining the truth of $\varphi$. $\llb C \rrb \varphi \mathsf{R} \psi$ means that $C$ can maintain $\psi$ until $\varphi$ \textit{$\R$eleases} the requirement for the truth of $\psi$.  %enforce that $\varphi$ \textit{releases} $\psi$". 
Derived operators $\llb C \rrb\F\varphi =_{def} \llb C \rrb \top\U\varphi$ and $\llb C \rrb \G\varphi =_{def} \llb C \rrb\bot\R\varphi$ mean ``$C$ has a strategy to \textit{eventually} make $\varphi$ true" and ``$C$ has a strategy to make sure that $\varphi$ is \textit{always} true" respectively. Hybrid logic operator $@_\alpha \varphi$ means ``at state named $\alpha$, $\varphi$ is true". This operator allows us to `switch' our point of evaluation to the state labelled with nominal $\alpha$ in the syntax. %Boolean connectives are defined in a standard way. 
Given a formula $\varphi\in \mathsf{HATL}$, the \emph{size of} $\varphi$, denoted by $|\varphi|$, is the number of symbols in $\varphi$.



\begin{definition}[Semantics of $\mathsf{HATL}$]\label{def:semantics_static}
Let $M = \lb S, \tau, L\rb$ be a CGM, $s\in S$, $p \in \AP$, $\alpha \in \Nom$, and $\varphi, \psi \in \mathsf{HATL}$. The semantics of $\mathsf{HATL}$  is defined by induction as follows: 
    \begin{alignat*}{3}
        &M_s \models p && \text{ iff } && s \in L(p)\\
        &M_s \models \alpha && \text{ iff } && s \in L(\alpha)\\
        &M_s \models @_\alpha \varphi && \text{ iff } && \exists t \in S: \{t\} = L(\alpha)  \text{ and } M_t \models \varphi\\
        &M_s \models \lnot \varphi && \text{ iff } && M_s \not \models \varphi\\
        &M_s \models\varphi \land \psi && \text{ iff } && M_s \models \varphi \text{ and } M_s \models \psi\\
        &M_s \models \langle \! \langle C \rangle \! \rangle \mathsf{X} \varphi && \text{ iff } && \exists \sigma_C, \forall \lambda \in \Lambda^s_{\sigma_C}: M_{\lambda[1]} \models \varphi\\
        &M_s \models \langle \! \langle C \rangle \! \rangle \psi \mathsf{U} \varphi && \text{ iff } && \exists \sigma_C, \forall \lambda \in \Lambda^s_{\sigma_C}, \exists i \geqslant 0: M_{\lambda[i]} \models \varphi  \\
        & && && \text{ and } M_{\lambda[j]} \models \psi%\varphi %there was a typo
        \text{ for all } 0 \leqslant j < i\\  
        %Release
        &M_s \models \langle \! \langle C \rangle \! \rangle \psi \mathsf{R} \varphi && \text{ iff } &&   \exists \sigma_C, \forall \lambda \in \Lambda^s_{\sigma_C}, 
        \forall i \geqslant 0: M_{\lambda[i]} \models \varphi \\
        & && && \text{ or } %\exists j \in [0,i) \text{ s. t. } 
        M_{\lambda[j]} \models \psi  \text{ for some } 0 \leqslant j \leqslant i       
\end{alignat*}     
%We call a formula $\varphi$ \emph{valid} if for all $M_s$ it holds that $M_s \models \varphi$. %Moreover, we will also write $\llbracket \varphi \rrbracket_M$ for $\{s\in S \mid M_s \models \varphi\}$.
\end{definition}

Observe that differently from standard hybrid logics \cite{ARECES2007821}, the truth condition for $@_\alpha \varphi$ also requires the state with name $\alpha$ to exist. This modification is necessary as we let some nominals to have empty denotations. 

\begin{example}
Recall CGM $M$ from Figure \ref{fig::exampleCGM}. It is easy to see that %, for example,
$M_s \models \alpha$ meaning that state $s$ is named $\alpha$; $M_s \models \llb \{1,2\} \rrb \X \lnot p$, i.e. that from state $s$ the grand coalition can force $\lnot p$ to hold in the next state; and $M_s \models @_\beta \llb \{1,2\} \rrb \G \beta$ meaning that in the state named $\beta$ %(i.e. state $t$) 
the grand coalition has a strategy to always remain in this state.
\end{example}




%\subsection{Expressivity} 


\paragraph*{Expressivity of $\mathsf{HATL}$.} 
%\munyque{If we need space, I suggest to remove the first paragraph on ATL.}
%$ 
%\ATL$ logic is a well-known tool for reasoning about various distributed and multi-agent systems due to its expressive power and the ability to describe important properties of those systems. 
%\ATL$ is a well-known tool for reasoning about various properties of MAS.
%For example, \textit{safety} property  $\llb C\rrb\G \mathsf{safe}$ allows us to verify that coalition $C$ has a strategy to never end up in an unsafe state.
%describe a situation where coalition $C$ has a strategy to never end up in an unsafe state. 
%Similarly, %we may reason about 
%\textit{liveness} property  $\llb C \rrb\G\F \mathsf{good}$ captures the fact that $C$ %can enforce that in future it is always the case that some $\mathsf{good}$ state will eventually be visited. 
%can always eventually visit some $\mathsf{good}$ state.
%Having a model, we can employ formal verification techniques to check if the model satisfies the desired properties.

%Once we have a model of a multi-agent (or any concurrent) system, we can use $\ATL$ to encode the such properties and employ formal verification techniques to check if the model satisfies the desired properties.

Even though the interplay between nominals and temporal modalities has been quite extensively studied (see, e.g., \cite{blackburn99,Goranko2000-GORCTL-2,franceschet06,
%Kara2009,
Kernberger2020}), to the best of our knowledge, the extension of $\ATL$ with nominals has never been considered. 
Our \textit{Hybrid} $\ATL$ provides us with extra expressive power, compared to the standard $\ATL$. %, and extends the range of properties we can encode. 
%Now we can formulate safety and liveness properties (as well as many others) in terms of \textit{names} of the states rather than \textit{propositions}. 
We can, for instance, formulate safety and liveness properties in terms of \textit{names}.
For example, %a formula $\varphi\in \mathsf{HATL}$
formula
\[\llb C \rrb \G \, \mathsf{safe} \wedge  \llb D \rrb  \neg \mathsf{crashed}\,\U\, {\alpha} \wedge \llb \emptyset \rrb \F \beta\]
states that (1) coalition $C$ can enforce that only $\mathsf{safe}$ states will be visited, %in future, 
(2) coalition $D$ can %maintain without 
avoid crashing until a state named %$state_\alpha$ 
$\alpha$ is visited, and (3) no matter what the agents $\AG$ do, a state named ${\beta}$ will eventually be visited. Both conjuncts (2) and (3) use nominals to refer to state names in syntax, and are not expressible in $\ATL$. %Taking into account  
Given that (as we will show later) the valuation of propositions in dynamic systems may change over time, as well as the transitions affecting reachability of some states, we believe that %this feature of 
$\mathsf{HATL}$ allows for a more fine-grained way to capture safety and liveness. %may be useful in various domains. 

%The ability to refer to particular states of a CGM also allows us to verify that for a given model there are no deadlocks in the system, i.e. there are no states from which there is no transition to some other state.  Indeed, let  a finite CGM $M = \lb S, \tau, L\rb$ be given, and let $\mathit{Nom}(s) = \{\alpha | L(\alpha) = \{s\}\}$. Then the formula to express the absence of deadlocks in $M$ will look like
%\nima{Is this formula really convincing? It is defined relative to a \emph{specific} model, which means that technically it is of limited interest (as opposed to being able to generally express deadlock freeness). When you define wrt specific models, you may as well say that $\mathit{no\_deadlocks}:= \top$ for $M$ without deadlocks, and $\mathit{no\_deadlocks}:= \bot$ otherwise. Technicality-wise, this is exactly the same the model-specific formula offers no real advantage, it seems.

%But wait - we write in the definition of CGMs that we assume models to always be properly named, with every state referred to by at least one nominal. If that is the case, we can replace the conjunction over states by a conjunction over nominals and obtain a truly generic deadlock-freeness formula. But then we run into issues with having a countably infinite supply of nominals. Anyways, there's some problems here.

%Biggest of which is the following. Our definition of CGMs precludes deadlocks: there is always, for every action profile, a successor state. So what are we trying to express? I really think we would be best served removing this.}
%$$\mathit{no\_deadlocks}:= \bigwedge_{s \in S} \bigwedge_{\alpha \in \mathit{Nom}(s)} @_{\alpha} \llb Ag \rrb \X \lnot \bigvee_{\beta \in \mathit{Nom} (s)} \beta.$$
%\remove{Intuitively, formula $\mathit{no\_deadlocks}$ states that for any state (that can have several names) of the model, there is a transition outside of that state. }

%\munyque{I find a bit odd to have the expressivity of HATL here while for LAMB it is in a separated section. }

%Before continuing further, we formally introduce the notion of expressivity.

%\nima{Perhaps this definition is not necessary. Would save quite a bit of space. Plus, technically, we never define the notion of language. We may get some slightly nitpicking reviewer that does not like this.}
\begin{definition}
Let $\mathsf{L}_1$ and $\mathsf{L}_2$ be two languages, and let $\varphi \in \mathsf{L}_1$ and $\psi \in \mathsf{L}_2$. 
We say that $\varphi$ and $\psi$ are \emph{equivalent}, when for all CGMs $M_s$: $M_s \models \varphi$ if and only if $M_s \models \psi$.
%Let $\mathsf{L}_1$ and $\mathsf{L}_2$ be two languages. 

If for every $\varphi \in \mathsf{L}_1$ there is an equivalent $\psi \in \mathsf{L}_2$, we write $\mathsf{L}_1 \preccurlyeq \mathsf{L}_2$ and say that $\mathsf{L}_2$ is \emph{at least as expressive as} $\mathsf{L}_1$. We write $\mathsf{L}_1 \prec \mathsf{L}_2$ iff $\mathsf{L}_1 \preccurlyeq \mathsf{L}_2$ and $\mathsf{L}_2 \not \preccurlyeq \mathsf{L}_1$, and we say that $\mathsf{L}_2$ is \emph{strictly more expressive than} $\mathsf{L}_1$. Finally, if $\mathsf{L}_1 \preccurlyeq \mathsf{L}_2$ and $\mathsf{L}_2 \preccurlyeq \mathsf{L}_1$, we say that $\mathsf{L}_1$ and $\mathsf{L}_2$ are \emph{equally expressive} and write $\mathsf{L}_1 \approx \mathsf{L}_2$.
\end{definition}

%Finally, $@_{\alpha}$ operator allows us to `scan' the entire model and reason about states not accessible from the current one by the transition function. 
\rust{Let us return to \Cref{fig::exampleCGM}, and assume that we have model $N'$, which is exactly like $N$ with the only difference that $N'_s \models q$.} Now, CGMs $M$ and $N'$ can be viewed as a \maks{disjoint union} \cite{thebluebible} $M \biguplus N'$ (modulo renaming states in $N'$ and assigning to them other nominals than $\alpha$ and $\beta$, \rust{like $\gamma$ and $\delta$ correspondingly})
%\suggestion{\textbf{Maksim: maybe to rename those states in original figure and omit this remark?} Rustam: We then reuse the models for expressivity and wee need the same nominals in the proof} 
of two isolated submodels $M$ and $N'$. %(such constructions are called \textit{disjoint unions} \cite{thebluebible}). 
Note that no $\ATL$ formula $\varphi$ that holds in $M$ depends on the submodel $N'$ as there are no transitions there. Hence, $\ATL$ cannot distinguish between $M$ and $M \biguplus N'$.
At the same time, \maks{in contrast to state labels, we can use nominals in the syntax. So, formulas of $\mathsf{HATL}$ containing $@_\alpha$ operators can access states in the submodel $N'$, and hence can have different truth values in $M$ and $M \biguplus N'$. An example of such a formula would be $@_\gamma q$, which is false everywhere in $M$ (since there is no state named $\gamma$), and true everywhere in $M \biguplus N'$.} This trivially implies that $\mathsf{HATL}$ \textit{is strictly more expressive than} $\mathsf{ATL}$ ($\mathsf{ATL}\prec \mathsf{HATL}$).

\iffalse

So, $\ATL$ preserves formulas' truth under generated submodels and disjoint unions.  However, $\mathsf{HATL}$ lacks this property. This fact is unusual for many modal logics, yet it is fairly standard for hybrid logics.



\begin{theorem}\label{thm:submodels} $\mathsf{HATL}$ is \emph{not} invariant under generated submodels and disjoint unions.
\end{theorem}

\begin{proof}
Consider a simplest counterexample. Let $\AG = \{i\}$ and $Act=\{a\}$. Consider two models $M =(S, \tau, L)$ and $N=(S', \tau', L')$, consisting of a single state, so $S=\{s\}$ and $S' =\{t\}$. We also assume that all propositions from $\AP$ are false in $s$ and $t$; $s$ is named $\alpha$ and $t$ is named $\beta$. So, $L(s) = \{\alpha\}$, $L'(t) = \{\beta\}$. Finally, $\tau(s, a)=s$ and $\tau'(t, a)=t$. We denote a `big' model, which is a disjoint union of $M$ and $N$ as $M \biguplus N$.  

% {\centering
% \begin{tikzpicture}
%     \node[dot] [label=left:{s}] [label=below:{$\alpha$}] (s) {};
%     \node[dot] [label=right:{t}] [label=below:{$\beta$}] [right=2cm of s] (t) {};

%     \path[thick,-to] (s) edge [loop above] (s);
%     \path[thick,-to] (t) edge [loop above] (t);

%     \node [below=.5cm of s] (M) {$M$};
%     \node [below=.5cm of t] (N) {$N$};

%     \node [below right=1cm and .5 of s] (MN) {$M\biguplus N$};
% \end{tikzpicture}

% }

It is straightforward to check that according to \Cref{def:semantics_static}, $(M \biguplus N)_s\vDash @_{\beta}\top$, but $M_s\nvDash @_{\beta}\top$, because there is no state named $\beta$ in an $\{s\}$-generated submodel $M$. The argument for disjoint unions is symmetric: $M_s\vDash \neg @_{\beta}\top$ and $(M \biguplus N)_s\nvDash \neg @_{\beta}\top$.
\end{proof}

\maksim{the proof can be shortned be reference to Fig.1}


To formally establish expressivity of $\mathsf{HATL}$, we need to introduce necessary definitions.

\begin{definition}[Relative expressivity] A logic $\cL_2$ is \emph{at least as expressive} as a logic $\cL_1$, denoted $\cL_1 \preceq \cL_2$, if for every formula $\varphi_1\in \cL_1$ there is an equivalent formula $\varphi_2\in \cL_2$. We write $\cL_1 \approx
\cL_2$ if $\cL_1 \preceq \cL_2$ and $\cL_2 \preceq \cL_1$, and $\cL_1 \prec\cL_2$ if $\cL_1 \preceq \cL_2$ and $\cL_2 \npreceq \cL_1$.
\end{definition}

Now, let $\mathsf{ATL}\bigoplus \Nom$ be a fragment of $\mathsf{HATL}$ without $@_{\alpha}$ operator. Firstly, it is easy to see that no $\ATL$ formula can distinguish $M_s$ and $N_t$ models from the proof of \Cref{thm:submodels}. Yet, an $\mathsf{ATL}\bigoplus \Nom$ formula $\alpha$ holds in $M_s$, but not in $N_t$, so, $\mathsf{ATL}\prec\mathsf{ATL}\bigoplus\Nom$. Secondly, \Cref{thm:submodels} implies that $\mathsf{ATL} \prec \mathsf{HATL}$, since $\mathsf{ATL}$ is known to be invariant under generated submodels and disjoint unions. But since it is a routine to check that $\mathsf{ATL}\bigoplus\Nom$ is invariant under generated submodels as well, it follows that $\mathsf{ATL}\bigoplus\Nom\prec \mathsf{HATL}$. So, the following result can be established immediately: 
$$\mathsf{ATL}\prec\mathsf{ATL}\bigoplus\Nom\prec \mathsf{HATL}$$.
\fi
%\rustam{@Maksim: I have rewritten the argument informally, as maybe it's an overkill to reason about generated submodels here (: Maybe we can have your more formal argument in the appendix with all the definitions..?}

%\maksim{Sure, I agree. I do not think we need def.s of submodels and unions even in Appendix. Though I think we can still introduce defs 5-6 here.}
%\rustam{Oh yes, defs 5-6 are already here! I just copy-pasted those from the other section, so that notation is consistent}

\subsection{Logic for $\ATL$ Model Building}

Now we turn to the full logic with dynamic update operators. 
 %et $a = \Act^{\AG}$ be the set of all complete action profiles  $A_\AG$.



%\maksim{Should not we use $\tau(s, A_C)$ instead of $Out(s, A_C)$? Also, I have used 'decision' instead of 'action' above, so if no one objects, I will modify this Def slightly}
%\munyque{Agree with both suggestions. }

%\maksim{I have implemented modifications. I decided to leave 'action profile' instead of a 'decision', but replaced Out() with $\tau()$. If everyone agrees, you can comment out this comments. }



\begin{definition}[Syntax of $\LAMB$]
The language $\LAMB$ of \emph{Logic for ATL Model Building} is defined %recursively
as follows 
\begin{alignat*}{4}
        &\LAMB &&\thinspace \ni && \enspace \varphi ::= &&p \mid \alpha \mid @_\alpha \varphi \mid \neg \varphi \mid \varphi \land \varphi \mid \llb C \rrb \X \varphi \mid \\
        & && && &&   \mid \llb C \rrb \varphi \U \varphi \mid \llb C \rrb \varphi \mathsf{R} \varphi \mid [\pi]\varphi\\
        & &&\thinspace  && \enspace \pi ::= &&(p_\alpha:=\psi) \mid \alpha \xrightarrow{A} \alpha \mid \lcirc{\alpha}  %\mid \pi;\pi\mid \pi \cup \pi
\end{alignat*}
where $p \in \AP$, $\alpha \in \Nom$, $C \subseteq \AG$, $A \in \Act^{\AG}$. %All standard abbreviations are defined as before. 
We will also write $[\pi_1; ...; \pi_n]\varphi$ for $[\pi_1]...[\pi_n]\varphi$.  %As before, Boolean connectives are defined in a standard way, and we use the same abbreviations for $\llb C \rrb \F\varphi$ and $\llb C \rrb \G\varphi$. 
Two important fragments of $\LAMB$ that we will also consider are the one without constructs $\alpha \xrightarrow{A} \alpha$ and $\lcirc{\alpha}$, called \emph{substitution} $\LAMB$ ($\mathsf{S}\LAMB$); and the one without $p_\alpha:=\psi$  and $\lcirc{\alpha}$, called \emph{arrow} $\LAMB$ ($\mathsf{A}\LAMB$).
\end{definition}

%\maksim{I have removed $\G$ operator, please let me know if you want to reverse it.}

% \munyque{While this syntax corresponds to classic ATL, it could be better to use the release operator instead of G. In ATL, we cannot represent the release using the other operators (while we can represent G with the release). Thus, the logic would have all classic temporal operators.
% }
% \rustam{Isn't it the case only for ATL*? or also for ATL? Oh I found a reference!!!\\
% https://www.irif.fr/~francoisl/PUBLIS/LMO-lmcs08.pdf}
% \munyque{Yes, that paper shows that in ATL (with G, X, and U) you cannot express Release (but with ATL* you can express everything with just X and U). Some recent works still consider the syntax you use in Def 3, but I have seen reviewers complain about it. 
% I included the syntax and semantics in case you want to use R (we can remove G then). }

% \rustam{I was on the receiveing end of this complaints once (:}

% \munyque{About hybrid ATL: Was it defined previously? Otherwise, we could also study its complexity/discuss what it is useful for...}

% \rustam{I think that no! I think that hybrid modal logic community and ATL community have the empty intersection. Indeed, even hybrid ATL seems quite interesting, and we should spend some time on it}

% \maksim{I also never heard of Hybrid ATL before, I think it was our idea. I agree that it can be interesting from expressivity and complexity points of view. BTW, it could be possible to axiomatize it by modifying Goranko's proof. But not in this paper of course.}

% \maksim{I've done some research on it. It seems that Goranko used some HL ideas for CTL* in \cite{Goranko2000-GORCTL-2}. Another (possibly relevant paper) is \cite{HANSEN201133}, but it uses nominals in DEL settings only. Complexity of temporal logics with nonimals was studied in \cite{Areces_Blackburn2000}. No paper on ATL is found so far. Other possibly relevant papers to mention: \cite{Kernberger2020,Lange2009,Kara2009}}

%The semantics of $\LAMB$ are presented in the following two definitions via a joint recursion. 

\begin{definition}[Semantics of $\LAMB$]
\label{def:semLAMB}
Let $M = \lb S, \tau, L\rb$ be a CGM, $s\in S$, $p \in \AP$, $\alpha \in \Nom$, and $\varphi, \psi \in \LAMB$. The semantics of $\LAMB$  is defined as in Definition \ref{def:semantics_static} with the following additional cases: 
    \begin{alignat*}{3}
        %&M_s \models p && \text{ iff } && s \in L(p)\\
        %&M_s \models \alpha && \text{ iff } && s \in L(\alpha)\\
        %&M_s \models @_\alpha \varphi && \text{ iff } && \exists t \in S: \{t\} = L(\alpha)  \text{ and } M_t \models \varphi\\
        %&M_s \models \lnot \varphi && \text{ iff } && M_s \not \models \varphi\\
        %&M_s \models\varphi \land \psi && \text{ iff } && M_s \models \varphi \text{ and } M_s \models \psi\\
        %&M_s \models \langle \! \langle C \rangle \! \rangle \mathsf{X} \varphi && \text{ iff } && \exists \sigma_C, \forall \lambda \in Plays(s,\sigma_C): M_{\lambda[1]} \models \varphi\\
       % &\remove{M_s \models \langle \! \langle C \rangle \! \rangle \mathsf{G} \varphi} && \text{ iff } && \exists \sigma_C, \forall \lambda \in Plays(s,\sigma_C): \lambda[i] \models \varphi \text{ for all } i \in \mathbb{N}\\
        %&M_s \models \langle \! \langle C \rangle \! \rangle \psi \mathsf{U} \varphi && \text{ iff } && \exists \sigma_C, \forall \lambda \in Plays(s,\sigma_C), \exists i \geqslant 0: M_{\lambda[i]} \models \varphi \\
        %& && && \text{ and } M_{\lambda[j]} \models \psi%\varphi %there was a typo
        %\text{ for all } 0 \leqslant j < i \\  
        %Release
        %&M_s \models \langle \! \langle C \rangle \! \rangle \psi \mathsf{R} \varphi && \text{ iff } &&  \exists \sigma_C, \forall \lambda \in Plays(s,\sigma_C), 
        %\forall i \geqslant 0: \\
        %& && && M_{\lambda[i]} \models \varphi \text{ or } %\exists j \in [0,i) \text{ s. t. } 
        %M_{\lambda[j]} \models \psi 
        %\text{ for some } 0 \leqslant j < i
        % \\
        &M_s \models [p_\alpha:=\psi]\varphi && \quad \text{ iff } \quad && M^{p_\alpha:=\psi}_s \models \varphi\\
        &M_s \models [\lcirc{\alpha}]\varphi && \quad \text{ iff } \quad && M^{\lcirc{\alpha}}_s \models \varphi\\
        %&M_s \models [\alpha \xrightarrow{A} \beta]\varphi && \text{ iff } && \forall t,u \in S: L(\alpha) = t \text{ and } L(\beta) = u \text{ implies } M^{\alpha \xrightarrow{A} \beta}_s \models \varphi\\
        &M_s \models [\alpha \xrightarrow{A} \beta]\varphi && \quad \text{ iff } \quad && M^{\alpha \xrightarrow{A} \beta}_s \models \varphi
        %&M_s \models [\pi ; \rho] \varphi && \text{ iff } &&M_s \models [\pi][\rho] \varphi\\
        %&M_s \models [\pi \cup \rho] \varphi && \text{ iff } &&M_s \models [\pi] \varphi \text{ and } M_s \models [\rho] \varphi\\
\end{alignat*} 
where $M^\pi$ with $\pi \in \{p_\alpha:=\psi, \alpha \xrightarrow{A} \beta, \lcirc{\alpha}\}$ is called an \emph{updated} CGM, and is defined as follows:
\begin{itemize}
    \item $M^{p_\alpha:=\psi}_s = \lb S, \tau, L^{p_\alpha:=\psi}\rb$, where, if $\exists t \in S$ such that $L(\alpha) = \{t\}$, then  
    \[ L^{p_\alpha:=\psi } (p) =
    \begin{cases}

        L(p) \cup \{t\} &\text{if } %L(\alpha) = \{s\} \text{ and } 
        M_s \models \psi,\\
        L(p) \setminus \{t\} &\text{if } %L(\alpha) = \{s\} \text{ and } 
        M_s \not \models \psi,\\
       %L(p) &\text{ otherwise}.\\

    \end{cases}\]
    and $M^{p_\alpha:=\psi} = \lb S, \tau, L\rb$ otherwise.
%    \item  $M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau^{\alpha \xrightarrow{A} \beta}, L\rb$, where $\tau^{\alpha \xrightarrow{A} \beta}(s,A) = t$ if $\exists s,t \in S$ such that $L(\alpha) = s$ and $L(\beta) = t$, and the same otherwise. 
    \item  $M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau^{\alpha \xrightarrow{A} \beta}, L\rb$, where, if $\exists s,t \in S$ such that $L(\alpha) = s$ and $L(\beta) = t$, then
    \[\tau^{\alpha \xrightarrow{A} \beta}(s',A') =
        \begin{cases}
            t, &\text{if } s' = s \text{ and } A' = A\\
            \tau(s',A') &\text{otherwise},\\
        \end{cases}
    \]
    and  $ M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau, L\rb$ otherwise.
    %where $\tau^{\alpha \xrightarrow{A} \beta}(s,A) = t$ and $\tau^{\alpha \xrightarrow{A} \beta}(s',A') = \tau(s',A')$  for each state $s' \neq s$ and decision $A' \neq A$, and $ M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau, L\rb$ otherwise. }    
    \item $M^{\lcirc{\alpha}} = \lb S^{\lcirc{\alpha}}, \tau^{\lcirc{\alpha}}, L^{\lcirc{\alpha}}\rb$, where, if $L(\alpha) = \emptyset$, then  $S^{\lcirc{\alpha}} = S \cup \{t\}$ with  $t \not \in S$, $\tau^{\lcirc{\alpha}} = \tau \cup \{(t, A, t) \mid \forall A \in \Act^\AG\}$, and $L^{\lcirc{\alpha}}(\alpha) = L \cup \{(\alpha, \{t\})\}$. If $L(\alpha) \neq \emptyset$, then $M^{\lcirc{\alpha}} = \lb S, \tau, L\rb$. %\suggestion{Maksim: Maybe $M^{\lcirc{\alpha}} = M$?}
    %with $ S^{\lcirc{\alpha}} = S \cup \{t\}$ with $t \not \in S$ and $L(\alpha) = \emptyset$, $L^{\lcirc{\alpha}}(\alpha) = t$, and $\forall p \in \AP \cup \Nom \setminus \{\alpha\}: L^{\lcirc{\alpha}}(p) = L(p)$.
\end{itemize}
%\end{definition}

%\maksim{I have a question about valuation change. Why do we check the truth of $\psi$ at state $s$ rather than at state $\alpha$ at $[p_{\alpha}:= \psi]$? For example, in terms of normative update, I would like to formulate smth like [$sunction_{\alpha} := unsafe$] meaning that at state $\alpha$ $sunction$ becomes true if $unsafe$ is true \textbf{there}, but not in a current state. So, I would define it as\\
 %   $\begin{cases}

 %       L(p) \cup \{t\} &\text{if } %L(\alpha) = \{s\} \text{ and } 
 %       M_t \models \psi,\\
 %       L(p) \setminus \{t\} &\text{if } %L(\alpha) = \{s\} \text{ and } 
 %       M_t \not \models \psi,\\
       %L(p) &\text{ otherwise}.\\

 %   \end{cases}$
     
 %       Or am I wrong?}

%\rustam{It is just a bit more general. We can define your version by using $@_a$ in front of $unsafe$. The more general approach does not complicate anything, and this is just a stylistic choice. We could go either way}

%\maksim{Fair enough. Maybe we can mention it when we discuss applications.}
%\rustam{Maybe we should mention it here, I anyway need an informal explanation of the update operators.}

%\munyque{Why do we have the two last operators in the logic? Couldn't we simply say that they denote an abbreviation? }

%\rustam{Oh yes... They need for an easier model checking complexity proof haha. They are quite harmless as they do not increase complexity and just useful abbreviations}

%\munyque{Should definition 5 come before (or be included in) the semantics? 

%Where does $s$ come from in the first bullet point of definition 5? Is it for any $s$? 

%For the second point, we should also say $\tau^{\alpha \xrightarrow{A}}$ is equal to $\tau$ for any other pair of state and decision/joint action (I wrote a suggestion in blue). 
%}

%\begin{definition}[Updated model]\label{def:updated_model} 
%Given an nCGM  $M = \lb S, \tau, L\rb$ and $\dag\in \{p_\alpha:=\psi, \alpha \xrightarrow{A} \beta, \lcirc{\alpha}\}$, we define the corresponding \emph{updated} nCGM $M^{\dag}$ as follows:
\iffalse
\begin{itemize}
    \item $M^{p_\alpha:=\psi}_s = \lb S, \tau, L^{p_\alpha:=\psi}\rb$, where, if $\exists t \in S$ such that $L(\alpha) = \{t\}$, then  
    \[ L^{p_\alpha:=\psi } (p) =
    \begin{cases}

        L(p) \cup \{t\} &\text{if } %L(\alpha) = \{s\} \text{ and } 
        M_s \models \psi,\\
        L(p) \setminus \{t\} &\text{if } %L(\alpha) = \{s\} \text{ and } 
        M_s \not \models \psi,\\
       %L(p) &\text{ otherwise}.\\

    \end{cases}\]
    and $M^{p_\alpha:=\psi} = \lb S, \tau, L\rb$ otherwise.
%    \item  $M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau^{\alpha \xrightarrow{A} \beta}, L\rb$, where $\tau^{\alpha \xrightarrow{A} \beta}(s,A) = t$ if $\exists s,t \in S$ such that $L(\alpha) = s$ and $L(\beta) = t$, and the same otherwise. 
    \item  $M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau^{\alpha \xrightarrow{A} \beta}, L\rb$, where, if $\exists s,t \in S$ such that $L(\alpha) = s$ and $L(\beta) = t$, then
    \[\tau^{\alpha \xrightarrow{A} \beta}(s',A') =
        \begin{cases}
            t, &\text{if } s' = s \text{ and } A' = A\\
            \tau(s',A') &\text{otherwise},\\
        \end{cases}
    \]
    and  $ M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau, L\rb$ otherwise.
    %where $\tau^{\alpha \xrightarrow{A} \beta}(s,A) = t$ and $\tau^{\alpha \xrightarrow{A} \beta}(s',A') = \tau(s',A')$  for each state $s' \neq s$ and decision $A' \neq A$, and $ M^{\alpha \xrightarrow{A} \beta} =  \lb S, \tau, L\rb$ otherwise. }    
    \item $M^{\lcirc{\alpha}} = \lb S^{\lcirc{\alpha}}, \tau^{\lcirc{\alpha}}, L^{\lcirc{\alpha}}\rb$, where, if $L(\alpha) = \emptyset$, then  $S^{\lcirc{\alpha}} = S \cup \{t\}$ with  $t \not \in S$, $\tau^{\lcirc{\alpha}} = \tau \cup \{(t, A, t) \mid \forall A \in \Act^\AG\}$, and $L^{\lcirc{\alpha}}(\alpha) = L \cup \{(\alpha, \{t\})\}$. If $L(\alpha) \neq \emptyset$, then $M^{\lcirc{\alpha}} = \lb S, \tau, L\rb$.
    %with $ S^{\lcirc{\alpha}} = S \cup \{t\}$ with $t \not \in S$ and $L(\alpha) = \emptyset$, $L^{\lcirc{\alpha}}(\alpha) = t$, and $\forall p \in \AP \cup \Nom \setminus \{\alpha\}: L^{\lcirc{\alpha}}(p) = L(p)$.
\end{itemize}
    \fi
\end{definition}

Intuitively, updating a given model with $p_\alpha := \psi$ assigns to propositional variable $p$ in the state named $\alpha$ (if there is such a state) the truth value of $\psi$ in the state of evaluation. Observe, however, that due to the presence of operators $@_\alpha$, we can also let the truth-value of $p$ be dependent on the truth of $\psi$ in any other state. Updating with $\alpha \xrightarrow{A} \beta$ results in redirecting the $A$-labelled arrow that starts in state named $\alpha$ from some state $\tau(L(\alpha), A)$ to state named $\beta$ (if states named $\alpha$ and $\beta$ exist). Finally, operator $\lcirc{\alpha}$ adds a new state to the model and gives it name $\alpha$. All propositional variables are false in the new state and all transitions are self-loops. The self-loops and the fact that propositional variables are false in the new state is a design choice that achieves two goals. First, adding new state results in a finite model (recall that to determine the size of a model we count all true propositions), and, second, we deem this to be the smallest meaningful change that is in line with the idea of modularity. All valuations and self-loops can be then further modified by the corresponding substitutions and arrow operators.   

\begin{example}
\label{ex:expressive}
    Consider CGMs $M$ and $N$ from Figure \ref{fig::exampleCGM} and an update $\alpha \xrightarrow{aa} \alpha$. Observe that such an update leaves $N$ intact as there is already a self-loop labelled $aa$ in the $\alpha$-state. Model $M$, on the other hand, is changed and the resulting updated model $M^{\alpha \xrightarrow{aa} \alpha}$  is depicted in Figure \ref{fig::updateExample}. 

    \begin{figure}[h!]
\centering
\scalebox{0.75}{
\begin{tikzpicture}
\node(-1) at (2,0) {$M^{\alpha \xrightarrow{aa} \alpha}$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$s:\alpha$}](1) at (0,0) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=below:{$t:\beta$}](2) at (4,0) {};

\draw[->,thick] (1) to [loop above] node[above, align=left] {$ab, ba, aa$} (1);
\draw [->,thick](1) to [bend right] node[below,align=left] {$bb$} (2);
\draw [->,thick] (2) to [bend right] node[above,align=left] {$aa, bb$} (1);
\draw [->,thick] (2) to [loop above] node[above,align=left] {$ab, ba$} (2);

\node(-1) at (2,-3.3) {$M^{\pi_1}$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$s:\alpha$}](1) at (0,-3.3) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=below:{$t:\beta$}](2) at (4,-3.3) {};

\node[rectangle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$u:\gamma$}](3) at (0,-5.3) {};


\draw [->,thick] (1) to [loop above] node[above, align=left] {$ab, ba$} (1);
\draw [->,thick](1) to [bend right] node[below,align=left] {$aa,bb$} (2);
\draw [->,thick] (2) to [bend right] node[above,align=left] {$aa,bb$} (1);
%\draw [->,thick] (2) to [loop above] node[above,align=left] {$ab$\\$ba$} (2);
%\draw [->,thick](1) to [bend right] node[left,align=left] {$ab$\\$ba$} (3);
\draw [->,thick] (3) to [loop above] node[above,align=left] {$aa,ab$\\$ba,bb$} (3);
%\draw [->,thick](3) to[bend right] node[below,align=left, near start] {$aa$\\$bb$} (2);

\end{tikzpicture}
%\hspace{2mm}
\begin{tikzpicture}
\node(-1) at (2,0) {$M^{\pi_2}$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=above:{$s:\alpha$}](1) at (0,0) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=above:{$t:\beta$}](2) at (4,0) {};

\node[rectangle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$u:\gamma$}](3) at (0,-2) {};


%\draw [->,thick] (1) to [loop above] node[above, align=left] {$ab, ba$} (1);
\draw [->,thick](1) to [bend right] node[below,align=left] {$aa, bb$} (2);
\draw [->,thick] (2) to [bend right] node[above,align=left] {$aa, bb$} (1);
%\draw [->,thick] (2) to [loop above] node[above,align=left] {$ab$\\$ba$} (2);
\draw [->,thick](1) to [bend right] node[left,align=left] {$ab$\\$ba$} (3);
\draw [->,thick] (3) to [loop above] node[above right,align=left] {$ab$\\$ba$} (3);
\draw [->,thick](3) to[bend right] node[below,align=left, near end] {$aa$\\$bb$} (2);

\node(-1) at (2,-3.3) {$M^{\mathit{SN}}$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=above:{$s:\alpha$}](1) at (0,-3.3) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=above:{$t:\beta$}](2) at (4,-3.3) {};

\node[rectangle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$u:\gamma$}](3) at (0,-5.3) {};

\node[rectangle,draw=black, minimum size=4pt,inner sep=0pt, label=below:{$v:\delta$}](4) at (4,-5.3) {};

%\draw [->,thick] (1) to [loop above] node[above, align=left] {$ab$\\$ba$} (1);
\draw [->,thick](1) to [bend right] node[below,align=left] {$aa,bb$} (2);
\draw [->,thick] (2) to [bend right] node[above,align=left] {$aa,bb$} (1);
%\draw [->,thick] (2) to [loop above] node[above,align=left] {$ab$\\$ba$} (2);
\draw [->,thick](1) to [bend right] node[left,align=left] {$ab$\\$ba$} (3);
\draw [->,thick] (3) to [loop above] node[above,align=left] {$ab$\\$ba$} (3);
\draw [->,thick](2) to [bend left] node[right,align=left] {$ab$\\$ba$} (4);
\draw [->,thick] (4) to [loop above] node[above,align=left] {$ab$\\$ba$} (4);
\draw [->,thick](3) to[bend right] node[below,align=left, near start] {$aa$\\$bb$} (2);
\draw [->,thick](4) to[bend left] node[below,align=left, near start] {$aa$\\$bb$} (1);
\end{tikzpicture}

}
\caption{Updated CGMs $M^{\alpha \xrightarrow{aa} \alpha}$ (top left), \rust{$M^{\pi_1
}$ (bottom left), $M^{\pi_2}$ (top right),} and $M^{\mathit{SN}}$ (bottom right). Proposition $p$ is true in black states, and $\mathit{fine}$ is true in square states.}
\label{fig::updateExample}
\end{figure} 

Now it is easy to see, for example, that in the updated model the first agent can force the system to stay in the $\alpha$-state by choosing action $a$, i.e. $M_s \models [\alpha \xrightarrow{aa} \alpha] \llb \{1\} \rrb \X \alpha$, while it is not the case for $N^{\alpha \xrightarrow{aa} \alpha}$ (which is the same as $N$), i.e.  $N_s \not \models [\alpha \xrightarrow{aa} \alpha] \llb \{1\} \rrb \X \alpha$. 

\rust{
As a more complex update, consider $\pi_1:= \lcirc{\gamma}; p_\gamma:=\top; \textit{f}ine_\gamma:=\top$ and the resulting model $M^{\pi_1}$, where we have a new state named $\gamma$ that satisfies propositions $p$ and $\textit{f}ine$ (the intuition behind $\textit{f}ine$ is given in Section \ref{sec:norms}). Further, we can add redirection of some edges $\pi_2:= \pi_1; \alpha \xrightarrow{ab} \gamma; \alpha \xrightarrow{ba} \gamma; \gamma \xrightarrow{aa} \beta; \gamma \xrightarrow{bb} \beta$ to obtain model $M^{\pi_2}$.
The final complex update of $M$ with $\mathit{SN}$, also presented in Figure \ref{fig::updateExample}, is discussed in the next section in the context of normative updates.
}
%An example of a more complex update of $M$ with $\mathit{SN}$, also presented in Figure \ref{fig::updateExample}, is discussed in the next section in the context of normative updates.


\end{example}

%\maksim{I would also break Example environment after 'depicted in Figure 2' for a better presentation}

\section{Dynamic MAS through the lens of $\LAMB$}

In this section, we show how our dynamic approach to CGMs allows us to capture various ideas and intuitions from the MAS research. 
%We claim that our dynamic approach to CGMs allows us to capture various ideas and intuitions from the MAS research. In this section, we look at three such examples. 

%\maksim{maybe we should avoid focusing on MAS only? And rename the section? Or maybe just merge this discussion with the previous section?}
%\rustam{Hmm i thought that everything is a MAS (: I'm open to renaming the section no problems. But still I think it is nice to keep a separate section on use cases, as it is our conceptual justification}
%\munyque{ATL is a logic for MAS; single-agent models are a simple case. I think it is not a problem to focus on MAS. I agree with leaving the use cases in a separate section (unless the section is quite small). }
%\rustam{We can also just call the section Use Cases}

%Since the language of $\LAMB$ combines ideas from various logical traditions, we believe that it is worthwhile to spend a moment contemplating on what properties of multi-agent systems we can express with it and its sublanguages.



%\textit{Changing valuations}. ???

%-> introducing 'sanctions' as in normative updates by changing valuations

%' whether the agent(s) can bring about a state satisfying a property without incurring a specified number of sanctions.'

%\cite{alechina18} represent updated model as a tree unravelling of M. We can also initate this. 

\subsection{Normative Updates on CGMs} 
\label{sec:norms}


Updates of CGMs play a crucial role in the area of normative MAS (see \cite{alechina18} for an overview). In the context of $\ATL$, the general idea is to divide actions of agent's into those that are permitted to be executed in a current state, and into those that are not. We argue that $\LAMB$, thanks to its dynamic features, captures various intuitions and technicalities of reasoning about norms in MAS.

%First, note that since we are not explicitly removing arrows and rather redirect them, we are not running into a situation where in a potential updated model agents run out of actions to perform. This ensures that function $\tau$ remains total and deterministic. Perhaps, one could argue that in some cases an all-forbidding norm makes sense. We, however, follow a more accepted assumption that each (normative) update leaves some actions available to every agent. This assumption is sometimes called \textit{reasonableness} in the literature \cite{agotnes_07,hoek_07,agotnes10,agotnes10b,alechina13}. 

%Another approach to reasonableness that is in perfect alignment with our redirection operators is to loop selected arrows in a current state \cite{bulling2016norm}. This corresponds to the intuition that a selected action profile has no noticeable effect and thus the system stays in the same state. The authors of  \cite{bulling2016norm} also argue that such a design choice can be interpreted as a non-performance of the joint action, or a prohibition of a selected action profile to enter certain states. 

%\maksim{Should we maybe move 2 paragraphs above to the Discussion to safe space? And just breifly mention that $\tau$ never breaks?}

%It is clear that given a finite CGM $M$, we can use the arrow redirecting operators to capture normative updates with the reasonabless assumption in the sense of \cite{bulling2016norm}. For example, the authors of \cite{hoek_07} consider\footnote{Here we simplify the exposition for the sake of clarity.} behavioural constrains of the form $BC: \AG \times \Act \to 2^S$, where $\beta(i,a) = \{s,t\}$ means that agent $i$ is not allowed to perform action $a$ in states $s$ and $t$. Now, using the arrow redirecting operators and the reasonabless assumption in the vein of \cite{bulling2016norm}, we can model behavioural constraints for a given model in $\LAMB$. Indeed, prohibition of action $a$ for agent $i$ in state $s$ means then that we loop all the action profiles, where agent $i$ chooses $a$, back to $s$. So, if implementing a behavioural constraint $BC$ results in a new model satisfying some $\varphi$ in state $s$, we can equivalently write $[\alpha \xrightarrow{A} \alpha; ...; \beta \xrightarrow{B} \beta]\varphi$, where $A,...,B$ are action profiles that contain prohibited actions, and $\alpha,...,\beta$ are corresponding states.    

%\maksim{Minor comment: section names 'Normative updates' and 'Norm-based mechanism design' are a bit confusing, it seems they describe similar problem and in both we use (Bulling, Dastani 2016) paper. Plus we talk about mechanism design (not normative) later . So maybe to rename or merge these sections?}
%\rustam{I think that what you mention is a rather major comment :) Depending on what we will have here, maybe we can cut out the whole Normative Updates on CGMs part, and norm-based mechanisms kinda cover it (even though I have to admit it is really hard to kill your own children). This will save some space as well. But if we have three good applications, Norms (a-la Mehdi), Mechanism Design, and Synthesis, then maybe it is more than enough. These three are also quite different from one another to demonstrate the range.}


%\paragraph*{Norm-based mechanism design}
As a use case of $\LAMB$, we consider \textit{norm-based updates} as presented in \cite{bulling2016norm}.\footnote{We simplify the exposition for the sake of clarity.} The authors distinguish two types of norms for CGMs: regimenting norms and sanctioning norms. 
Regimenting norms prohibit certain transitions by looping them to the origin state. This corresponds to the intuition that a selected action profile has no noticeable effect and thus the system stays in the same state. %The authors also argue that such a design choice can be interpreted as a non-performance of the joint action, or a prohibition of a selected action profile to enter certain states. 
Note that agents in this case always have available actions. This  assumption is sometimes called \textit{reasonableness} %in the literature 
\cite{agotnes_07,hoek_07,agotnes10,agotnes10b,alechina13,galimullin2024synthesizing}. %synthesising social laws

While it is quite straightforward to model regimenting norms in $\LAMB$ using arrow updates, for the sake of an example we focus on more general and subtle sanctioning norms. Such norms put sanctions, or fines, on certain action profiles without explicitly prohibiting them. A bit more formally, a sanctioning norm is a triple $(\varphi, \mathcal{A}, \mathcal{S})$, where $\varphi$ is a formula of a logic, $\mathcal{A}$ is a set of action profiles, and  $\mathcal{S}$ is a set of sanctions, which is a subset of the set of propositional variables. Intuitively, sanctioning norm $(\varphi, \mathcal{A}, \mathcal{S})$ states that performing action profiles from $\mathcal{A}$ from states satisfying $\varphi$ imposes sanctions from $\mathcal{S}$. %Then, the authors define a \textit{norm-based mechanism} as a pair $(M, \mathcal{N})$, where $M$ is a CGM and $\mathcal{N}$ is a set of norms.  

%While the former prohibit certain transitions by looping them similarly to the normative updates of the previous paragraph (and hence they can be modelled in our framework similarly), the latter are more subtle in their effects and we focus on them.
%Sanctioning norms put sanctions, or fines, on certain action profiles without explicitly prohibiting them. A bit more formally, a sanctioning norm is a triple $(\varphi, \mathcal{A}, \mathcal{S})$, where $\varphi$ is a formula of a logic, $\mathcal{A}$ is a set of action profiles, and  $\mathcal{S}$ is a set of sanctions, which is a subset of the set of propositional variables. Intuitively, sanctioning norm $(\varphi, \mathcal{A}, \mathcal{S})$ states that performing action profiles from $\mathcal{A}$ from states satisfying $\varphi$ imposes sanctions from $\mathcal{S}$. Then, the authors define a \textit{norm-based mechanism} as a pair $(M, \mathcal{N})$, where $M$ is a CGM and $\mathcal{N}$ is a set of norms.  

The result of updating a CGM $M$ with a norm $\mathsf{SN} = (\varphi, \mathcal{A}, \mathcal{S})$ is a CGM $M^\mathsf{SN}$ such that for all $\mathcal{A}$-transitions from $\varphi$-states, we create copies of those states and make sanctioning atoms $\mathcal{S}$ true in those copies. Non-sanctioned transitions from the copy-states have the same outcome as the original transitions in the initial model. 

Consider as an example the sanctioning norm $\mathsf{SN} = (\top, \{ab,ba\}, \allowbreak \{\mathit{fine}\})$ and CGM $M$ from Example \ref{fig::exampleCGM}. Recall that in $M$, agents can switch the current state only if they cooperate (i.e. choose the same actions). Hence, norm $\mathsf{SN}$ penalises non-cooperative behaviour with the sanction $\mathit{fine}$. %Having the norm-based mechanism $(M, \{\mathsf{SN}\})$, we can directly model the implementation of $\mathsf{SN}$ on $M$ in $\LAMB$. For this, we translate $\mathsf{SN}$ into a complex update
We can directly model the implementation of $\mathsf{SN}$ on $M$ in $\LAMB$ by translating $\mathsf{SN}$ into a complex update
\begin{alignat*}{1}
    &\mathit{SN}=\lcirc{\gamma}; p_\gamma:=\top; \mathit{fine}_\gamma:= \top; \alpha \xrightarrow{ab} \gamma; \alpha \xrightarrow{ba} \gamma; \gamma \xrightarrow{aa} \beta;\\
    &\gamma \xrightarrow{bb} \beta; \lcirc{\delta}; \mathit{fine}_\delta:= \top; \beta \xrightarrow{ab} \delta; \beta \xrightarrow{ba} \delta; \delta \xrightarrow{aa} \alpha;\delta \xrightarrow{bb} \alpha.
\end{alignat*}
The result of updating $M$ with $\mathit{SN}$ \rust{as well as some intermediate updates} is presented in Figure \ref{fig::updateExample}. In $M^{\mathit{SN}}$, we create copies of states $s$ and $t$ (both satisfying $\top$), named $u$ and $v$, which now also satisfy sanction $\mathit{fine}$. Then, undesirable action profiles $\{ab,ba\}$ originating in $s$ and $t$ lead to the sanctioned states $u$ and $v$. At the same time, action profiles not from $\{ab,ba\}$ behave similarly to the initial model. It is easy to see that our $\LAMB$ update $\mathit{SN}$ on $M$ captures the effect of $\mathsf{SN}$ on $M$. %the implementation of the norm-based mechanism $(M, \{\mathsf{SN}\})$. 

%Finally, we can also reason about the compliance of norm-based mechanisms with some desired property $\varphi$ (e.g. a safety requirement). In other words, for a given model $M_s$ and a set of sets of norms $\mathcal{N}_1 = \{\mathsf{SN}_1^1, ..., \mathsf{SN}^1_k\}, ..., \mathcal{N}_n = \{\mathsf{SN}_1^n, ..., \mathsf{SN}_l^n\}$, we can explicitly check whether $M_s$ satisfies $\bigwedge_{\mathcal{N}_i} [\mathit{SN}^i_1;...; \mathit{SN}^i_m]\varphi$, where $\mathit{SN}^i_j$'s are $\LAMB$ updates constructed as described above.  


%\paragraph*{Global $\ATL$ synthesis} The full language of $\LAMB$ is expressive enough to capture the \textit{global synthesis problem} for $\ATL$. The problem consists in providing a $\pi_\varphi$ for a given $\varphi \in \ATL$ such that if $\varphi$ is satisfiable, then $M_s \models [\pi_\varphi]\varphi$ for all $M_s$. In other words, we can reframe the $\ATL$ satisfiability as the global synthesis problem, where $\pi_\varphi$ would be a program that instructs how to make any CGM satisfy some given $\varphi$. In our case, for the reasons described below, we consider a slight restatement of the problem, where we construct a $\pi_\varphi$ such that $M_s \models [\pi_\varphi]@_\alpha \varphi$.

\subsection{Synthesis} 
\label{sec:synth}
\rust{Assume that you have a model $M_s$ of a MAS that does not satisfy some safety requirement $\varphi$. One way to go about it would be to create a completely new model from scratch, or to try to manually fix the existing one. However, in case of large models and complex safety requirements, both options may not be feasible.
%One way to go about it would be to try to introduce changes to the model `by hand', or create a new model from scratch. In the case of large models and complex requirements $\varphi$, both options may not be optimal or even possible. 
This is exactly where the problem of \textit{synthesis} (or \textit{modification synthesis}) comes in. 
The full language of $\LAMB$ is expressive enough to capture the (bounded) synthesis problem from a given specification and starting model. In such a way, the modifications %to a given
of the model are presented as updates operators of $\LAMB$. }

%\begin{definition}
 %   For a given CGM $M_s$ and a formula $\varphi$, the \emph{(modification) synthesis problem} returns the update $\pi_\varphi:= [\pi_1, ..., \pi_k]$ such that $M_s \models [\pi_\varphi] \varphi$, or returns NO if no such update exists. \munyque{I prefer "returns false".}\maksim{I agree}
%\end{definition}

%The corresponding decision problem can be defined as follows.

%\begin{definition}
%    For a given CGM $M_s$ and a formula $\varphi$, the \emph{(modification) synthesis existence problem} decides whether there is an update $\pi_\varphi:= [\pi_1, ..., \pi_k]$ such that $M_s \models [\pi_\varphi] \varphi$. 
%\end{definition}

%Even though the two definitions look similar, there is an important difference between them. While the synthesis problem is about constructing the required update, the synthesis existence problem only checks whether such an update exists. Ideally, one would prefer to solve the latter by actually presenting an update, but it is not uncommon to have an algorithm that returns just a YES\textbackslash{NO} answer. \munyque{In many cases, we can tweak the algorithms to return the synthesized object. In the blue sky paper, you mentioned that it is not the case for DEL. Maybe it would be good to also explain it here.
%}
%\maksim{I think in CompComplexity it is called Search VS Decision problem}
%}

%Consider also the bounded variant of the synthesis existence problem. 

%\munyque{In my opinion, we could skip the definitions 3.1 and 3.2. Since we are not showing any results there, it introduces unnecessary details.  
%An alternative option is to present the old unbounded synthesis procedure in the appendix - especially because we later say that Lamb captures the unbounded case (which is not so convincing without saying how to solve it). 
%} 
\rust{
\begin{definition}
    For a given CGM $M_s$, formula $\varphi$, and natural number $n$, the \emph{bounded (modification) synthesis existence problem} decides whether there is an update $\pi_\varphi:= [\pi_1, ..., \pi_k]$, with the size at most $n$, such that $M_s \models [\pi_\varphi] \varphi$. 
\end{definition}

The bounded synthesis existence problem is important, as it tackles the synthesis of \textit{compact} modifications. Indeed, oftentimes designers of (a model of) MAS are interested in a modification that achieves the goal without significantly altering the initial model. Think of an example of a software update, where we would like to extend the functionality of the software without rewriting most of its code. Moreover, the bounded %variation of the 
synthesis %existence 
problem is also important in  cases where changes in the given model %(and in the corresponding MAS) 
are costly, and we want to avoid wasting resources as much as possible. %\munyque{I suggest  removing "economical", it is less precise than the term "compact". }

In Section \ref{sec:mc}, we show that the complexity of the model checking problem for $\LAMB$ is \Ptime-complete. With this in mind, it is easy to see that the complexity of the bounded synthesis existence problem is \NP-complete. %w.r.t. the sizes of the given model, formula $\varphi$, and bound $n$. 
%with respect to the sizes of the given model, formula $\varphi$, and bound $n$.

\begin{proposition}
The bounded synthesis problem for $\LAMB$ is \NP-complete.
\end{proposition}

\begin{proof}
    To see that the problem is in \NP, let $M_s$ be a CGM, $\varphi$ be a formula, and $n$ be a natural number. We guess a $\pi_\varphi$ of size at most $n$. It follows that $[\pi_\varphi] \varphi$ is of polynomial size %with respect to 
    w.r.t $|\varphi| + n$. Then we can model check $M_s \models [\pi_\varphi] \varphi$ in polynomial time (\Cref{thm:MC}).

    For the \NP-hardness, we employ the reduction from 3-SAT problem. Let $\varphi:= \bigwedge_{1 \leqslant i \leqslant k} (\psi_{i,1} \lor \psi_{i,2} \lor \psi_{i,3})$, where $\psi$'s are literals, be an instance of 3-SAT, and let $P^\varphi = \{p^1, ..., p^m\}$ be the set of propositions appearing in $\varphi$. We construct model $M^\varphi$ over one agent consisting of a single state $s$ with the name $\alpha$, and such that $V^\varphi (p^i) = \emptyset$ for all $p^i \in P^\varphi$. All transitions for the agent are self-loops. Now it is easy to see that $\varphi$ is satisfiable iff there is a $\pi_\varphi$ consisting only of substitutions $p^i_\alpha:= \top$, and thus of the size linear in $|P^\varphi|$, such that $M_s^\varphi \models [\pi_\varphi]\varphi$. In other words, if there is an assignment that makes $\varphi$ true, we can explicitly simulate it in $M_s^\varphi$ using constructs $p^i_\alpha:= \top$ for variables $p^i \in P^\varphi$ that should be assigned `true'. %The final size of $\pi_\varphi$ is at most linear in $|P^\varphi|$. %the size of $\varphi$.
\end{proof}


%\munyque{It would be good to frame it formally as a result. Since it is not as important as the other results, we can call it "Proposition".}

The fact that $\LAMB$ captures the modification synthesis %, both unbounded and bounded versions, 
is significant, because a \textit{constructive} solution to the problem would produce a step-by-step recipe, or an instruction, of how to modify a given model to make it satisfy some desirable property $\varphi$. %Apart from that, it opens the whole research agenda of \textit{constructive} solutions to the both syntheses problems. 
In this section we studied the computational complexity of checking \textit{whether} a required modification of certain size exists. In future work, we will focus on constructive solutions to the problem, i.e. providing algorithms that automatically construct the required $\LAMB$ update. }
%\munyque{I would move the part starting with "Those solutions can be then embedded into some of the existing model checkers, ..." to the conclusion section. 
%}

\iffalse
The full language of $\LAMB$ is expressive enough to capture the \textit{global synthesis} (or \textit{modification synthesis})  \textit{problem} from $\ATL$-specifications. The problem consists of providing an %(composed)
update $\pi_\varphi$ for a given $\varphi \in \ATL$ such that if $\varphi$ is satisfiable, then
$M_s \models [\pi_\varphi]\varphi$ for all $M_s$. % if such $\pi_\varphi$ exists 
In other words, we can reframe the $\ATL$ satisfiability as the global synthesis problem, where $\pi_\varphi$ can be understood as a program that instructs how to modify any CGM to satisfy some given $\varphi$. In our case, for convenience, %for the reasons described below,
we consider a slight restatement of the problem, where we construct a $\pi_\varphi$ such that $M_s \models [\pi_\varphi]@_\alpha \varphi$.


To construct such a $\pi_\varphi$, we can use the finite model property of $\ATL$ and the fact that the satisfiability problem for $\ATL$ is decidable (\Exptime-complete, to be precise) 
\cite{goranko06}. The proof of \cite{goranko06} uses a filtration-based argument to construct a finite model $M^\varphi_t$ for a given $\varphi \in \ATL$ (see also \cite{walther06} for a detailed construction of the satisfying model). Once the model is constructed, we create a complex program $\pi_\varphi$ that essentially builds up model $M^\varphi_t$. In particular, we create new states using $\lcirc{\alpha}$'s. %, where $\alpha$'s are fresh nominals not appearing in the given $M_s$. 
To set the values of propositional atoms we then use assignments $p_\alpha := \bullet$ for $\bullet \in \{\top, \bot\}$. Then, we `unravel' all the self-loops in the new states to redirect them to required states via $\alpha \xrightarrow{A} \beta$. %To connect the given state of evaluation $s$ in model $M$ with the constructed $M^\varphi$, we redirect an arrow 
%coming out of $s$ to the state of evaluation of $M_\varphi$ named $\alpha$. 
Combining all these operators consecutively, we obtain $\pi_\varphi:= \lcirc{\alpha};...;\lcirc{\beta};p_\alpha := \bullet; ...; q_\beta := \bullet; \alpha \xrightarrow{A} \beta;...;\gamma \xrightarrow{B} \delta$. %; \mathit{Nom}(s) \xrightarrow{X} \alpha$. %, where the part $\mathit{Nom}(s) \xrightarrow{X} \alpha$ corresponds to rerouting an action profile $X$ from $s$ to state named $\alpha$.  
Finally, %%the global synthesis algorithm for a given $M_s$,
we rename nominals in $M$ if they clash with the nominals in $\pi_\varphi$. Such a renaming is innocuous as it does not change the structure of the model, and does not affect the truth-value of $\varphi$ as $\varphi \in \ATL$ and hence contains no nominals. It is easy to see now that as a result, %of such a procedure, 
we have $M_s \models [\pi_\varphi]@_\alpha \varphi$ for any given $M_s$ with $\alpha$ being the name of $t$.

%The fact that $\LAMB$ captures the global synthesis for $\ATL$ is significant, because it essentially produces a step-by-step recipe of how to modify any given model to make it satisfy some desirable $\varphi$. Of course, the presented procedure crucially depends on the satisfiability construction \cite{goranko06,walther06}, and by no means is optimal. We essentially reconstruct the model satisfying $\varphi$ and `jump' to its state of evaluation. However, such an expressivity of our language is remarkable from the conceptual point: we believe the promising direction for future work is to investigate more succinct ways to construct $\pi_\varphi$, or to consider the synthesis of programs only involving arrows' redirections and assignments.

The fact that $\LAMB$ captures the global synthesis for $\ATL$ is significant because it produces a step-by-step recipe of how to modify a given model to make it satisfy some desirable property $\varphi$. 
While the procedure we presented is directly based on the satisfiability construction \cite{goranko06,walther06},  it provides a first solution for a program-like approach to reconstructing models. %and by no means is optimal.  We essentially reconstruct the model satisfying $\varphi$ and `jump' to its state of evaluation.  However,
Notably, 
a promising direction for future work is to investigate more succinct ways to construct $\pi_\varphi$, or to consider the synthesis of programs only involving arrows' redirections and assignments.
\fi

%\maksim{pls revert it if you like}

\subsection{Mechanisms for Social Choice }

\newcommand{\egdef}{:=}

%The \remove{expressivity of $\LAMB$ is remarkable from the conceptual point of view: it provides tools for synthesising MAS and analysing its changing environments.}
%We now discuss 
%This highlights its potential to assist the design of mechanisms for social choice. 

The key advantage of synthesising mechanisms from logical specifications is that, as a declarative approach, the designer is not required to construct a complete solution for the problem of interest; instead, she can describe the desired mechanism in terms of its rules and desirable properties. Some recent approaches use model checking and satisfiability procedures for Strategy Logic \cite{SLKF_KR21,MittelmannMMP22}. We, however, focus on the dynamic $\LAMB$ approach. %MittelmannMMP23 
%While being able to analyse MAS with respect to complex solution concepts, all these works face high complexity issues.  

Let us assume a mechanism encoded as a CGM, and a finite set of alternatives $Alt$. Such a mechanism may represent, for instance, a single-winner election or a resource allocation protocol.
In such CGM, 
we let the atomic  proposition $\textit{pref(i,j)}_a$ denote that agent $a$ prefers the alternative $i$ to $j$ (e.g., she prefers that $i$ is elected over $j$).
%In such CGM, the atomic proposition $\textit{des}_a$ denotes whether the agent $a$ \textit{most desirable} situation is true in a state (e.g., her favorite candidate was elected),
We also let $\textit{dislike}_a(i)$ indicate that $i$ is \textit{disliked} by agent $a$, % (e.g., $i$ is one of the worst candidates from $a$'s opinion),
and $chosen_i$ denote that the alternative $i$ was chosen. %Assuming at most one of those propositions is true in any state, 
%Clearly, the agent prefers states where $\textit{pref}_a$ is true but  %%%%Situations in which both propositions are false (e.g., the agent is indifferent to the candidate elected) are preferred by agent $a$ to states where only $\textit{undes}_a$  is true.

We now illustrate how to capture two classic concepts from game theory: individual rationality and Pareto optimality.  
Individual rationality expresses the idea that each agent can ensure nonnegative utility \cite{Nisan2007}. In our setting, this can be seen as avoiding disliked candidates and expressed with the following formula  
$$ \bigwedge_{a \in Agt, i \in Alt} \llb \{a\} \rrb \G \neg ( \textit{chosen}_i \land \textit{disliked}_a(i))$$
which states that each agent has a strategy to enforce that none of the disliked alternatives are ever chosen. 

A mechanism is  Pareto optimal if any change of outcome that is beneficial to one agent is detrimental to at least one of the other agents.
%  no other alternative is strongly preferred by at least one agent, and weakly preferred by all others 
The formula
$$pareto_i \egdef  \bigwedge_{a \in Agt,  j \in Alt\setminus\{i\}}\big(
( \textit{pref}_a(j,i)
 \rightarrow 
\bigvee_{b \in Agt} \textit{pref}_b(i,j)
   \big)$$
expresses that  an alternative $i$ is Pareto optimal  whenever for any other alternative $j$, if $j$ is preferred to an agent $a$, then there is an agent $b$ that prefers $i$ over $j$. 

We can then express that there is a strategy for the coalition $C$ to ensure that any chosen alternative is Pareto optimal, with the  formula $ \varphi_{po}:=  \llb C \rrb  \G \bigwedge_{i \in Alt} chosen_i \to pareto_i
$. 
If we let $C = \emptyset$, this formula requires choices to be Pareto optimal for any possible behavior of the agents.

Once desirable mechanism properties are expressed as $\ATL$ formulas, one can use $\LAMB$ to verify whether CGM $M_s$ has such property or would have it in case a sequence of modifications $\pi_1; ..., \pi_n$ was performed, i.e. whether $M_s \models [\pi_1; ...; \pi_n] \varphi_{po}$ for Pareto optimality. Further, 
\rust{
employing the ideas of synthesis, one could automatically obtain the required modifications. 
}
%the procedure of global synthesis described above could be directly applied to obtain the required modifications.


%The key advantage of synthesizing mechanisms from logical specifications is that, as a declarative approach, the designer is not required to construct a complete solution for the problem of interest; instead, she can describe the desired mechanism in terms of its rules and desirable economic properties.

%As pointed out by \cite{dash2003computational}, the rationality assumption in Mechanism Design can be inappropriate in computational settings because agents may not have enough computational power to calculate equilibrium strategies.  
%\munyque{

%The key differences with MD are the rationality assumption  (related to solution concepts) and the agents' utilities (we are restricted to Boolean goals). There are some logical approaches to MD: the work on "rational verification" where agents' goals are LTL formulas, and work that encodes the classic problem in SL.  More relevant works: incentive engineering (given a CGS, synthesize taxes to achieve goal) and norm-design (given a CGS, synthesize norms to achieve goal, i.e., restrictions on how the agents can act).

%In another direction, the research on model repair (in process mining) is also related. The problem consists of having a model (Petri net, automata) that does not recognize a set of traces (related to LTLf specifications), and they look for ways of changing the model to recognize it. Differences: (i) AFAIK there is no logic to reason about repairs (although SAT-based approaches may be used to search for solutions); (ii) usually, single-agent perspective. }
%\rustam{@Munyque: would it be possible to write up mechanism design here with preferably some little snippets how some intuitions about the design can be (potentially) captured by LAMB?}


\section{Expressivity}

In this section, we compare the expressive power of $\LAMB$ and its fragments. In particular, we show that, interestingly enough, substitutions on their own do not add expressive power compared to the base $\HATL$ (Theorem \ref{thm:hatlEQslamb}). The ability to move arrows, on the other hand, leads to an increase in expressivity (Theorem \ref{thm:hatlVSalamb}). %But before we delve into the results, we provide the formal definition of expressivity first.

%\maksim{Is in't it Def. 5? We should remove duplications}

First, we show that $\mathsf{SLAMB}$ and $\mathsf{HATL}$ are equally expressive. This is quite intriguing since it means that adding substitutions to the base logic $\mathsf{HATL}$ does not allow us to express anything that we could not express in $\mathsf{HATL}$.
%maybe i'll reuse it somewhere
%\paragraph*{Fragment $\mathsf{S}\LAMB$} The substitution fragment of $\LAMB$ is quite interesting in its own right. As we have mentioned, the fragment allows to capture .... However, it turns out that $\mathsf{S}\LAMB$ is no more expressive than our static $\mathsf{H}\ATL$, which is quite interesting taking into account that $\LAMB$ is strictly more expressive than $\mathsf{H}\ATL$. Moreover, while we have to pay for the increased expressivity of $\LAMB$ with a complexity jump of the model checking problem from P-complete to PSPACE-complete, we show that $\mathsf{S}\LAMB$ is still P-complete.
We prove this %expressivity 
result by providing a truth-preserving translation from formulas of $\mathsf{S}\LAMB$ into formulas of $\mathsf{H}\ATL$. While expressivity results that use translation schemas (usually based on \textit{reduction axioms}) are quite ubiquitous in $\mathsf{DEL}$ (see \cite{hvdetal.del:2007} for an overview, and 
\cite{kooi07,kuijer14} for substitution specific translations), to the best of our knowledge, this is the first time reduction has been discussed in the context of dynamics for logics of strategic abilities. 

\begin{theorem}
\label{thm:hatlEQslamb}
$\mathsf{HATL}\approx \mathsf{SLAMB}$
\end{theorem}

\begin{proof}
 %First, we provide a set of reduction axioms for substitutions.
 \rust{Consider the reduction axioms below.}
 \begin{enumerate}[start=1,label={(\bfseries A\arabic*):},leftmargin = 2em]
    \item[A1] $[p_\alpha := \psi] p \leftrightarrow (\alpha \to  \psi) \land (\lnot \alpha \to p)$
    \item[A2] $[p_\alpha := \psi] q \leftrightarrow q$ for $p \neq q$
    \item[A3] $[p_\alpha := \psi] \beta \leftrightarrow \beta$ 
    \item[A4] $[p_\alpha := \psi] @_\beta \varphi \leftrightarrow @_\beta [p_\alpha := \psi] \varphi$
    \item[A5] $[p_\alpha := \psi] \lnot \varphi \leftrightarrow \lnot [p_\alpha := \psi] \varphi$
    \item[A6] $[p_\alpha := \psi] (\varphi \land \chi) \leftrightarrow [p_\alpha := \psi] \varphi \land [p_\alpha := \psi] \chi$
    \item[A7] $[p_\alpha := \psi] \llb C \rrb \X \varphi \leftrightarrow \llb C \rrb \X [p_\alpha := \psi] \varphi$
    \item[A8] $[p_\alpha := \psi] \llb C \rrb \varphi \U \chi \leftrightarrow \llb C \rrb [p_\alpha := \psi] \varphi \U [p_\alpha := \psi] \chi$
    \item[A9] $[p_\alpha := \psi] \llb C \rrb \varphi \R \chi \leftrightarrow \llb C \rrb [p_\alpha := \psi] \varphi \R [p_\alpha := \psi] \chi$
\end{enumerate}
Soundness of the axioms can be shown by application of the definition of semantics (Definition \ref{def:semLAMB}). %, and a proof sketch can be found in the  Appendix.
\rust{As an example, consider axiom A1. % $[p_\alpha := \psi] p \leftrightarrow (\alpha \to  \psi) \land (\lnot \alpha \to p)$. 
Let us assume that for some CGM $M_s$ it holds that $M_s \models [p_\alpha := \psi] p$. According to the definition of $M_s^{p_\alpha := \psi}$ (Definition \ref{def:semLAMB}), we consider two cases. First, if $M_s \models \alpha$, then the truth-value of $p$ is equivalent to whether $M_s \models \psi$. Hence, the first conjunct of the right-hand part of A1: $M_s \models \alpha \to \psi$. Second, if $M_s \not \models \alpha$, then the truth-value of $p$ remains intact, i.e. $M_s \models \lnot \alpha \to p$. Combining two parts together, we have that $M_s \models [p_\alpha := \psi] p$ if and only if $M_s \models (\alpha \to \psi) \land (\lnot \alpha \to p)$.     

As another example, consider A7. %$[p_\alpha := \psi] \llb C \rrb \X \varphi \leftrightarrow \llb C \rrb \X [p_\alpha := \psi] \varphi$. 
Assume that for an arbitrary CGM $M_s$ we have that $M_s \models [p_\alpha := \psi] \llb C \rrb \X \varphi$. By the definition of semantics, the latter is equivalent to $M_s^{p_\alpha := \psi} \models  \llb C \rrb \X \varphi$, which in turn is equivalent to the fact that $\exists \sigma_C, \forall \lambda \in \Lambda^s_{\sigma_C}:$ $M^{p_\alpha := \psi}_{\lambda[1]} \models \varphi$. Now, by the semantics of substitutions, we have that $\exists \sigma_C, \forall \lambda \in \Lambda^s_{\sigma_C}:$ $M_{\lambda[1]} \models [p_\alpha := \psi]\varphi$, which in turn is equivalent to $M_s \models \llb C \rrb \X [p_\alpha := \psi] \varphi$.
Other cases can be shown in a similarly. }
 
Now, having a set of sound reduction axioms, it is %relatively 
straightforward to define a truth-preserving translation $tr: \mathsf{S}\LAMB \to$ $\mathsf{H}\ATL$. %, where cases of choice and composition are dealt using equivalences $[\pi \cup \rho]\varphi 
%\leftrightarrow [\pi]\varphi \land [\rho]\varphi$ and $[\pi;\rho]\varphi \leftrightarrow [\pi][\rho]\varphi$. 
 Such a translation would work from inside-out, taking the innermost occurrence of a substitution and %either breaking it down to simpler parts in the cases of  $[\pi \cup \rho]\varphi$ and $[\pi;\rho]\varphi$, or 
pushing it closer to propositions and nominals, eventually translating them away completely. 
\rust{In particular, axioms A2 and A3 state that changing the valuation of $p$ does not affect other propositional variables and nominals. Axiom A1 intuitively means that if the current state is named $\alpha$, then the valuation of $p$ is the same as the valuation $\psi$ in this state. And if the current state is not $\alpha$, then $p$ in the \textit{current} state retains its valuation.}
See \cite{hvdetal.del:2007,kooi07,kuijer14} for %examples of 
translations in the context of $\mathsf{DEL}$.
\end{proof}

An observant reader may notice, that the presented %truth-preserving 
translation of a $\mathsf{SLAMB}$ formula may result in an exponentially larger formula of $\mathsf{HATL}$ (due to repetitions in A6, A8, and A9). Or, equivalently, that the initial formula of $\mathsf{SLAMB}$ is exponentially \emph{more succinct} than its translation. Such a blow-up is quite natural for reduction-based translations in $\mathsf{DEL}$ 
\cite{lutz06,french13}. In the next section we will show that despite this, %the model checking problem of %(a variant of) 
%$\mathsf{SLAMB}$ is still \Ptime-complete. 
model checking $\mathsf{SLAMB}$ is \Ptime-complete.
 
Now we turn to %the expressiveness of 
$\mathsf{ALAMB}$ and show that the ability to move arrows grants us additional expressivity.


\begin{theorem}
\label{thm:hatlVSalamb}
$\mathsf{HATL} \prec \mathsf{ALAMB}$ and $\mathsf{SLAMB} \prec \mathsf{ALAMB}$.
\end{theorem}

\begin{proof}
The fact that $\mathsf{HATL} \preccurlyeq \mathsf{ALAMB}$ follows trivially as  $\mathsf{HATL}$ is a fragment of $\mathsf{ALAMB}$.
To see that $\mathsf{ALAMB} \not \preccurlyeq \mathsf{HATL}$ recall Example \ref{ex:expressive}. 
%consider two CGMs, $M_s$ and $N_s$ depicted in Figure \ref{fig::hatlVSalamb}. The models are for the single agent with two available actions: $a$ and $b$. In model $M$, agent 1 can switch the current state by choosing action $a$, and in model $N$ she can switch the current state by choosing $b$.
\iffalse
\begin{figure}[h]
\centering
\begin{tikzpicture}
\node(-1) at (2,0) {$M$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$s:\alpha$}](1) at (0,0) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=below:{$t:\beta$}](2) at (4,0) {};

\path (1) edge [loop above] node[align=left] {$b$} (1);
\draw [->](1) to [bend right] node[below] {$a$} (2);
\draw [->] (2) to [bend right] node[above] {$a$} (1);
\draw [->] (2) to [loop above] node[above] {$b$} (2);
\end{tikzpicture}
\hspace{10mm}
\begin{tikzpicture}
\node(-1) at (2,0) {$N$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$s:\alpha$}](1) at (0,0) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=below:{$t:\beta$}](2) at (4,0) {};

\path (1) edge [loop above] node[align=left] {$a$} (1);
\draw [->](1) to [bend right] node[below] {$b$} (2);
\draw [->] (2) to [bend right] node[above] {$b$} (1);
\draw [->] (2) to [loop above] node[above] {$a$} (2);
\end{tikzpicture}
\hspace{10mm}
\begin{tikzpicture}
\node(-1) at (2,0) {$M^{\alpha \xrightarrow{a} \alpha}$};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, fill = black, label=below:{$s:\alpha$}](1) at (0,0) {};
\node[circle,draw=black, minimum size=4pt,inner sep=0pt, , label=below:{$t:\beta$}](2) at (4,0) {};

\path (1) edge [loop above] node[align=left] {$a, b$} (1);
%\draw [->](1) to [bend right] node[below] {$a$} (2);
\draw [->] (2) to [bend right] node[above] {$a$} (1);
\draw [->] (2) to [loop above] node[above] {$b$} (2);
\end{tikzpicture}
\caption{CGMs $M$, $N$, and $M^{\alpha \xrightarrow{a} \alpha}$ for a single agent and two actions. Propositional variable $p$ is true in black states, and nominals $\alpha$ and $\beta$ are true in their corresponding states.}
\label{fig::hatlVSalamb}
\end{figure} 
\fi
It is easy to see that models $M_s$ and $N_s$ cannot be distinguished by any $\mathsf{HATL}$ formula\footnote{\rust{In fact, there is an alternating bisimulation \cite{agotnes07irr} between the models. The discussion of an appropriate notion of bisimulation for $\LAMB$ is outside of the scope of this paper and is left for future work.}}. Indeed, in both models states $s$ and $t$ agree on their corresponding nominals and propositional variables, and, moreover in all states none of the agents can force a transition on their own.
%the two models are bisimilar, and thus cannot be distinguished by any $\mathsf{HATL}$ formula. Indeed, in both models in all states, agent 1 has the full control whether to stay in the current state or switch to the other one. The fact that such a switch
The fact that such a transition requires different %actions 
action profiles by $\{1,2\}$ in different models cannot be captured by formulas of $\mathsf{HATL}$ as they do not have the access to particular actions, rather just to abilities of the agent.

At the same time, as shown in Example \ref{ex:expressive}, the $\mathsf{ALAMB}$ formula $[\alpha \xrightarrow{aa} \alpha] \llb \{1\} \rrb \X \alpha$ holds in $M_s$ and is false in $N_s$, and, therefore, $\mathsf{HATL} \prec \mathsf{ALAMB}$.
%Now consider the $\mathsf{ALAMB}$ formula $[\alpha \xrightarrow{a} \alpha] \llb 1 \rrb \lnot p$. The effect of updating CGM $M$ with $\alpha \xrightarrow{a} \alpha$, $M^{\alpha \xrightarrow{a} \alpha}$ is shown in Figure \ref{fig::hatlVSalamb}. Observe that now agent 1 does not have any outgoing arrows from the $p$-state $s$, and thus $M^{\alpha \xrightarrow{a} \alpha} \not \models \llb 1 \rrb \lnot p$. On the other hand, updating $N$ with $\alpha \xrightarrow{a} \alpha$ results in exactly the same model (action profile labelled with $a$ is already directed from the $\alpha$-state to itself). Hence, $N^{\alpha \xrightarrow{a} \alpha} \models \llb 1 \rrb \lnot p$, and therefore $\mathsf{HATL} \prec \mathsf{ALAMB}$. 
The fact that $\mathsf{SLAMB} \prec \mathsf{ALAMB}$ follows by transitivity of the expressivity relation from $\mathsf{HATL} \approx \mathsf{SLAMB}$.
\end{proof}

From Theorem \ref{thm:hatlVSalamb} it %trivially
follows that $\mathsf{HATL} \prec \mathsf{LAMB}$ and $\mathsf{SLAMB} \prec \mathsf{LAMB}$. %both $\mathsf{HATL}$ and $\mathsf{SLAMB}$ are strictly less expressive than the full language $\LAMB$. 
For future work, we leave open the question of whether $\LAMB$ is strictly more expressive than $\mathsf{ALAMB}$, and conjecture that it is indeed the case.
Figure \ref{fig:expressivity} summarises the expressivity results.

\begin{figure}[h!]
\centering
\begin{tikzpicture}[scale=0.8, transform shape]
\node (HATL) at (0,0) {$\mathsf{HATL}$};
\node (SLAMB) at (3,0) {$\mathsf{SLAMB}$};
\node (ALAMB) at (6,0) {$\mathsf{ALAMB}$};
\node (LAMB) at (9,0) {$\mathsf{LAMB}$};

\draw[thick,<->] (HATL) to node[sloped, anchor=center, above] {\footnotesize{Thm. \ref{thm:hatlEQslamb}}} (SLAMB);
\draw[thick,->] (SLAMB) to node[sloped, anchor=center, above] {\footnotesize{Thm. \ref{thm:hatlVSalamb}}} (ALAMB);
\draw[thick,->] (ALAMB) to [bend right] (LAMB);
\draw[thick,->,dashed] (LAMB) to [bend right] node[above] {?}  (ALAMB);

\end{tikzpicture}
\caption{Overview of the expressivity results. An arrow from $\mathsf{L}_1$ to $\mathsf{L}_2$ means $\mathsf{L}_1 \preccurlyeq\mathsf{L}_2$. If there is no symmetric arrow, then $\mathsf{L}_1 \prec \mathsf{L}_2$. This relation is transitive, and we omit transitive arrows in the figure. The dashed arrow with the question mark denotes the open question.}
\label{fig:expressivity}
\end{figure}





\section{Model checking} 
\label{sec:mc}

%Now we turn to the complexity of the model checking problem for $\LAMB$. 
The \rust{model checking problem for $\LAMB$} consists in determining, for a CGM $M_s$ and a formula $\varphi$, whether $M_s \models \varphi$. We show %, in particular, 
that despite the increase in expressivity, the complexity of the model checking problem for the full language of $\LAMB$ is \rust{still} \Ptime-complete. 

The complexity of model checking $\ATL$ is known to be \Ptime-complete \cite{alur2002}, and it is easy to see that it remains the same also for $\mathsf{HATL}$. The algorithm for $\ATL$ uses function $Pre (M, C, Q)$ that computes for a given CGM $M$, coalition $C \subseteq Agt$ and a set $Q \subseteq S$, the set of states, from which coalition $C$ can force the outcome to be in one of the $Q$ states. Function $Pre$ can be computed in polynomial time. We can use exactly the same algorithm for computing $Pre$ as for the standard $\ATL$, however in our case we will compute $Pre$ for not only the original model model $M$, but its updated versions as well. 

\begin{breakablealgorithm}
	\caption{An algorithm for model checking $\LAMB$}\label{lambMC} 
	\small
 %\footnotesize
	\begin{algorithmic}[1] 		
		\Procedure{MC}{$M, s, \varphi$}		
      %\Case {$\varphi = p$}
       %     \State{\textbf{return} $s \in L(p)$}
       % \EndCase
        \Case {$\varphi = \alpha$}
            \State{\textbf{return} $s \in L(\alpha)$}
        \EndCase
        \Case {$\varphi = @_\alpha \psi$}
        \If {$L(\alpha) \neq \emptyset$}
            \State{\textbf{return}  $\textsc{MC} (M, L(\alpha), \psi)$}
        \Else
            \State{\textbf{return}  \textit{false}}
        \EndIf
        \EndCase
       % \Case {$\varphi = \lnot \psi$}
      %      \State{\textbf{return}  not $\textsc{MC} (M, s, \psi)$}
      % \EndCase
      % \Case {$\varphi = \psi \land \chi$}
       %     \State{\textbf{return} $\textsc{MC} (M,s,\psi)$ and  $\textsc{MC} (M,s,\chi)$}
       % \EndCase
      %\Case {$\varphi = \llb C \rrb \X \psi$}
       %      \State{\textbf{return} $s \in Pre(M, C, \{t \in S | \textsc{MC}(M, t, \psi)\})$}
        %\EndCase
    %\Case{$\varphi = \llb C \rrb \psi \U  \varphi$}
    %\State{$X:= \emptyset$ and $Y:= \{t \in S \mid \textsc{MC} (M,t, \varphi)$\}}
    %\While{$Y \neq X$}
     %   \State{$X:= Y$}
      %  \State{$Y := \{t \in S \mid \textsc{MC} (M,t, \varphi)\} \cup (Pre(M, C, X) \cap \{t in S \mid \textsc{MC} (M,t, \psi)\})$}
    %\EndWhile
    %\State{\textbf{return} $s \in X$}
    %\EndCase

    %\Case{$\varphi = \llb C \rrb \psi \R \varphi$}
    %\State{$X:= \emptyset$ and $Y := \{t \in S \mid \textsc{MC} (M,t, \varphi)\} \cup \{t \in S \mid \textsc{MC} (M,t, \psi)\} $}
   % \State{$X:= S$ and $Y := \{t \in S \mid \textsc{MC} (M,t, \varphi)\}$}
    %\While{$Y \not \subseteq X$}
    %    \State{$X:= X \cup Y$}
    %    \State{$Y:=Pre(M, C, X) \cap \{t \in S \mid \textsc{MC} (M,t, \varphi)\}$}
  %  \While{$Y \neq X$}
  %      \State{$X:= Y$}
  %      \State{$Y := \{t \in S \mid \textsc{MC} (M,t, \varphi)\} \cap (Pre(M, C, X) \cup \{t \in S \mid \textsc{MC} (M,t, \psi)\})$}
  %  \EndWhile
  %  \State{\textbf{return} $s \in X$}
  %  \EndCase
    
\Case {$\varphi = [\pi] \psi$ with $\pi\in \{p_\alpha:=\psi, \alpha \xrightarrow{A} \beta, \lcirc{\alpha}\}$}
			\State{\textbf{return} $\textsc{MC} (\textsc{Update} (M, s, \pi), s, \psi)$}
		\EndCase
   \EndProcedure

	\end{algorithmic}
\end{breakablealgorithm}

The model checking algorithm for $\LAMB$ (Algorithm \ref{lambMC}) is similar to the one for $\ATL$ when it comes to temporal modalities and Boolean cases, and thus we omit them for brevity (see the full algorithm in the  Appendix). Apart from them, we have hybrid cases $\varphi = \alpha$ and $\varphi = @_\alpha \psi$, and the dynamic case $\varphi = [\pi] \psi$ with $\pi\in \{p_\alpha:=\psi, \alpha \xrightarrow{A} \beta, \lcirc{\alpha}\}$. Regarding the  $\varphi = @_\alpha \psi$, we evaluate $\psi$ at state named $\alpha$, if the state with such a name exists. If the denotation of name $\alpha$ is empty, then $@_\alpha \psi$ is false. 

The dynamic case $\varphi = [\pi] \psi$ is a bit more involved as the algorithm evaluates $\psi$ in a new updated model $M^\pi$. Procedure \textsc{Update} for constructing updated models is captured by Algorithm \ref{update}.

\begin{breakablealgorithm}
	\caption{An algorithm for computing updated models}\label{update} 
	\small
	\begin{algorithmic}[1] 	
    \Procedure{Update}{$M, s, \pi$}
   \Case{$\pi = p_\alpha:=\psi$}
    \If{$L(\alpha) \neq \emptyset$}
        \If{$\textsc{MC} (M,s, \psi)$}
            \State{$L^\pi (p) = L (p) \cup L(\alpha)$}
        \Else
            \State{$L^\pi (p) = L (p) \setminus L(\alpha)$}
        \EndIf
        \State{\textbf{return} $M^\pi = \langle S, \tau, L^\pi \rangle$}
    \Else
        \State{\textbf{return} $M$}
    \EndIf
   \EndCase
   
   \Case{$\pi = \alpha \xrightarrow{A} \beta$}
        \If{$L(\alpha) \neq \emptyset$ and $L(\beta) \neq \emptyset$}
            \State{$\tau^\pi = \tau \setminus \{(L(\alpha), A, \tau(L(\alpha), A))\} \cup \{(L(\alpha), A, L(\beta))\} $}
            \State{\textbf{return} $M^\pi = \langle S, \tau^\pi, L \rangle$}
        \Else
            \State{\textbf{return} $M$}
        \EndIf
   \EndCase

      \Case{$\pi = \lcirc{\alpha}$}
   \If{$L(\alpha) = \emptyset$}
        \State{$S^\pi = S \cup \{t\}$, where $t$ is fresh}
        \State{$\tau^\pi = \tau \cup \{(t, A, t) \mid A \in \Act^\AG\}$}
        \State{$L^\pi = L \cup \{(\alpha, \{t\})\}$}
        \State{\textbf{return} $M^\pi = \langle S^\pi, \tau^\pi, L^\pi \rangle$}
    \Else
        \State{\textbf{return} $M$}
   \EndIf
   \EndCase
   \EndProcedure
	\end{algorithmic}
\end{breakablealgorithm}

In the procedure, an updated model is constructed according to Definition \ref{def:semLAMB}. For the case of substitutions, we first check whether state named $\alpha$ exists, and if it does, we update the valuation function $L$ based on whether $M_s \models \psi$. For arrows $\alpha \xrightarrow{A} \beta$, if both states named $\alpha$ and $\beta$ exist, we substitute in $\tau$ transition $(L(\alpha), A,$ $\tau(L(\alpha), A))$ (i.e. transition from state named $\alpha$ via $A$ to whatever state is assigned according to $\tau(L(\alpha), A)$) by the required transition $(L(\alpha), A, L(\beta))$ (line 13). Finally, to add a new state with name $\alpha$, we first check whether the name is not used, and then extend $S$, $\tau$, and $L$ of the original model accordingly.

Model checking for $\LAMB$ is done then recursively by a combination of procedures \textsc{MC}, which decides whether a given formula is true in a given model, and \textsc{Update}, which computes required updated models. %Procedure 
\textsc{MC} calls  \textsc{Update} when it needs to perform an update (line 10, Alg. \ref{lambMC}), and  \textsc{Update} calls \textsc{MC} when it needs to compute the valuation of $\psi$ for case $\pi = p_\alpha:=\psi$ (line 4, Alg. \ref{update}).

We run \textsc{MC}($N,t,\psi$) for at most $|\varphi|$ formulas $\psi$ and at most $|\varphi|$ models $N$. Each run, similarly to the algorithm for $\ATL$, is done in polynomial time with respect to $|M|$. %Each run is bounded by $|S|$ iterations (while loops for until and release) for each of which we call function $Pre$ computable in polynomial time with respect to $|M|$ (see the Technical Appendix). 
Hence, procedure \textsc{MC} is used by the model checking algorithm for a polynomial amount of time.   

At the same time, we run \textsc{Update}($N, t, \pi$) for at most $|\varphi|$ models $N$ and at most $|\varphi|$ formulas $\psi$ (the substitution case). The sizes of updated models are bounded by $|\varphi|\cdot|M|$ (the case of adding a new state). Thus, each run of \textsc{Update} takes polynomial time, and hence we spend a polynomial amount of time in the procedure while performing model checking. 

Both procedures, \textsc{MC} and \textsc{Update}, take polynomial time to run, and, therefore, model checking for $\LAMB$ can be done in polynomial time. The lower bound follows straightforwardly from \Ptime-completeness of $\ATL$ model checking.

%the fact that model checking $\ATL$ is \Ptime-complete.

\begin{theorem}\label{thm:MC}
    The model checking problem for $\LAMB$ is \Ptime-complete.
\end{theorem}

\begin{remark}
To make the language of $\LAMB$ more succinct, we can extend it with constructs $[\pi \cup \rho] \varphi$, meaning ‚Äòwhichever update we implement, $\pi$ or $\rho$, $\varphi$ will be true (in both cases)‚Äô. The model checking of the resulting logic is \Pspace-complete. Details about the extension and proofs can be found in section \emph{A Note On Succinctness} in the Technical Appendix.
\end{remark}

\section{Related work }
\label{sec:related}

%\maksim{Mention STIT}

\paragraph*{Strategic Reasoning.}

From the perspective of strategic reasoning, our work is related to the research on rational verification and synthesis. The first is the problem of checking whether a temporal goal is 
satisfied in some (or all) game-theoretic equilibria of a CGM \cite{AbateGHHKNPSW21,GutierrezNPW23}. Rational synthesis consists in the automated construction of such a model \cite{FismanKL10, CFGR16}.  
In this direction, 
\cite{KR2024-44} investigated the problem of finding \emph{incentives} by manipulating the weights of atomic propositions to persuade %motivate %rational
agents to act towards a temporal goal. %the system designers' goal.




Recent work has also investigated the use of formal methods to verify and synthesize mechanisms for social choice using model checking and satisfiability procedures for variants of Strategy Logic \cite{SLKF_KR21,MittelmannMMP22,MittelmannMMP23}. 
While being able to analyse MAS with respect to complex solution concepts, all these works face high complexity issues. 
In particular, key decision problems for rational verification with temporal specifications are known to be \Dexptime-complete \cite{GutierrezNPW23} and model checking  Strategy Logic is \NONELEMENTARY for memoryfull agents \cite{MogaveroMPV14}. 
\rust{
Compared to these approaches, $\LAMB$ offers relatively high expressivity while maintaining  the \Ptime-completeness of its model checking problem.
}

   % \munyque{If we have space, we can add a comment saying something about how we have some nice cost-expressivity balance with LAMB (in comparison with the exponential approaches mentioned here). }

\rust{
The recently introduced
\textit{obstruction ATL} \cite{catta23,catta24} ($\mathsf{O}\ATL$) allows reasoning 
%one to reason
about agents' strategic abilities %to cooperate and execute their strategies
while being hindered by an external force, called the \textit{Demon}. Being inspired by sabotage modal logic \cite{vanbenthem05}, in this logic  
the Demon is able to disable some transitions and thus impact the strategic abilities of the agents in a system. This is somewhat related to normative updates that we covered in Section \ref{sec:norms} and the \textit{module checking problem} \cite{kupferman2001module,jamroga2015module}, where agents interact with a non-deterministic environment that may inhibit access to certain paths of the computation tree. 

Notice that $\LAMB$ is significantly more general than the presented approaches %and ideas, 
as it allows to not only restrict transitions or access, but also change it in a more nuanced way by redirecting arrows (and, e.g., granting access to a state). Moreover, $\LAMB$ also allows adding \textit{new} states, as well as changing the valuations of propositions. Moreover, updates in $\LAMB$ are explicitly present in the syntax that enables explicit synthesis of model modifications.
}

\rust{
\paragraph*{Nominals.} Nominals are an integral part of \textit{hybrid logic} \cite{ARECES2007821} and is a common tool whenever one needs to refer to particular states on the syntax level. For example, nominals and other hybrid modalities are ubiquitous in the research on \textit{logics for social networks} (see \cite[Chapter 3]{minathesis} for a comprehensive overview). %The idea there is to identify states with agents, and the accessibility relation as a friendship, followership, visibility, or any other relation corresponding to a social network setting. 

In the setting of DEL, tools and methods of hybrid logic have been used, for example, to relax the assumption of common knowledge of agents' names \cite{wang18}, to study the interplay between public announcements and distributed knowledge \cite{HANSEN201133}, and to tackle the information and intentions dynamics in interactive scenarios \cite{Roy2009}. Moreover, nominals were used to provide an axiomatisation of a hybrid variant of \textit{sabotage modal logic} \cite{vanbenthem23}, which extends the standard language of modal logic with constructs $\blacklozenge \varphi$ meaning `after removing some edge in the model, $\varphi$ holds' \cite{vanbenthem05,aucher18}.

Nominals were also used in \textit{linear-} and \textit{branching-time temporal logics} %in order 
to refer to particular points in computation (see, e.g.,  \cite{blackburn99,Goranko2000-GORCTL-2,Franceschet_etal2003,franceschet06,Kara2009,Lange2009,BOZZELLI2010454,Kernberger2020}). 
In the framework of strategic reasoning, \cite{Huang_Meyden2018} %used constructs similar to the hybrid logic modality $\E$, 
used some ideas from hybrid logic,
but neither $@_{\alpha}$ nor nominals themselves. Hence, in terms of novelty,   %we believe that
to the best of our knowledge, the  \textit{Hybrid ATL} ($\mathsf{HATL}$) proposed in this paper is the first attempt to combine nominals with the $\mathsf{ATL}$-style strategic reasoning.

}

%\maksim{We refer to strategic reasoning in the par. above and then again introduce the whole paragraph on strategic reasoning.}
%\rustam{Maybe we can swap the order of paragraphs?}

%\maksim{I think E modality has never been mentioned, so it may be confusing}


%\munyque{Is it worth adding our rebuttal comment about how, expressivity-wise, the LAMB and Obstruction ATL are not comparable? }

%\maksim{I think we should}

\rust{
\paragraph*{The Interplay Between DEL and Strategic Reasoning.}

As we mentioned in the introduction, albeit DEL and various strategic logics being very different formalism, some avenues of DEL research has incorporated ideas from logics for strategic reasoning. Examples include the exploration of \textit{concurrent DEL games} \cite{maubert20}, \textit{alternating-time temporal DEL} \cite{delima14}, \textit{coalitions announcements} \cite{agotnes08,galimullin21b} and other forms of \textit{strategic multi-agent communication} (see, e.g., \cite{agotnes10GAL,galimullin24}).

To the best of our knowledge, DEL updates for CGMs, up until now, were considered only in \cite{galimullin21,galimullin2022action}, where the authors capture granting and revoking actions of singular agents as well as updates based on \textit{action models} \cite{bms22}. Both works are limited to the ne$\mathsf{X}$t-time fragment of $\ATL$ (so-called \textit{coalition logic} \cite{pauly02}). Moreover, they do not support such expressive features of $\LAMB$ as adding \textit{new} states and changing the valuation of propositional variables. Additionally, our arrow-redirecting operators allow for greater flexibility while dealing with agents' strategies. }


\balance %Balance is required on the last page when using AAMAS template


\section{Discussion \& Conclusion}

We proposed $\LAMB$, a logic for updating CGMs that combines ideas from both the strategy logics tradition ($\ATL$ in our case) and the $\mathsf{DEL}$ tradition. We have argued that $\LAMB$ can be useful for reasoning about a variety of dynamic phenomena in MAS thanks to the modular nature of its primitive update operators. Finally, we have explored the expressivity hierarchy of $\LAMB$ and its fragments, and demonstrated that the model checking problem for $\LAMB$ is \Ptime-complete.   

As we have just scratched the surface of dynamic updates for CGMs, there is a plethora of open questions. One of the immediate ones is to explore the satisfiability problem for $\LAMB$. \rust{
Another one is to assign costs to different types of model changes. In such a way, we will be able to generalise the bounded modification synthesis to the scenarios, where some changes are more costly to implement and thus are less optimal. Moreover, having costs associated with model changes will allow for a direct comparison of (this generalised version of) $\LAMB$ and Obstruction $\ATL$ (see Section \ref{sec:related}). %Indeed, the models of the latter are CGMs with costs assigned to transitions. 
We conjecture that in such a scenario, $\LAMB$ will subsume $\mathsf{O}\ATL$.  
}

%Another one is to consider more efficient approaches to the synthesis problem. 

%Apart from that, we would like to explore orderings on updates in cases where several updates reach the desired result. The simplest order could be based on the size of updates, i.e. the number of primitive operations that constitute them. In such a way, we can focus on the most economical model modifications that reach some target goals.
\rust{
Apart from that, in Section \ref{sec:synth}, we mentioned the exploration of constructive solutions to the synthesis problem, both bounded and unbounded versions, as a promising area of further research. One way to go about it is, perhaps, taking intuitions from the constructive approaches to the $\ATL$ satisfiability \cite{goranko06,walther06,goranko09}. 
Those solutions can be then embedded into some of the existing model checkers, like MCMAS \cite{lomuscio17} and STV \cite{kurpiewski19}, so that if a model checker returns FALSE for a given model and property $\varphi$, the tool automatically constructs an update that can fix the model so that it satisfies $\varphi$.
%Another tempting research direction is to consider the synthesis of updates that involve only particular types of modifications, e.g. only arrow changes. This is important in the cases, where changes of some particular features of a model are unsafe or undesirable. 
}

In a more general setting of CGM updates, one can also consider modifications that cannot be captured by $\LAMB$. For example, we can explore the effects of granting or revoking actions to/from certain agents, changing the number of agents, or any combinations thereof with the $\LAMB$ updates. \rust{As mentioned in Section \ref{sec:related},} some preliminary work on changing the actions available to agents has been done for the ne$\mathsf{X}$t-time fragment of $\ATL$ \cite{galimullin21,galimullin2022action}.

Finally, as $\LAMB$ is based on $\ATL$, we find it particularly interesting to consider more expressive base languages, like, $\ATL^\star$ or variations of strategy logic $\mathsf{SL}$ \cite{MogaveroMPV14}. Of particular interest is the \textit{simple goal fragment of} $\mathsf{SL}$ \cite{belardinelli19}, which is strictly more expressive than $\ATL$ and yet allows for  \Ptime-time model checking. 
\rust{
%Additionally, 
We would also like to consider the ideas of model updates in the setting of %strategy logics that are not based on CGMs, like, e.g., 
STIT logics \cite{horty01,broersen15}.  
Additionally, we believe that ideas from Separation Logics
\cite{Reynolds02,DemriD15,DemriF19}, which were proposed to verify programs with mutable data structures, could also provide insights on how to reason about separation and composition-based modifications of MAS.  
}
 
 %Also related is the research on social norms in MAS
%\cite{alechina18,alechina2022automatic}, which aims at regulate agents' behaviour by removing their available actions. None of those approaches consider the dynamic updates introduced in this paper, or the encoding of such changes in the concurrent game model as logical formulas. 

%In terms of novelty, we believe that the proposed Hybrid ATL logic ($\mathsf{HATL}$) is the first attempt to combine hybrid logic ideas with an $\mathsf{ATL}$-style strategic reasoning. Even though we consider a fragment of Hybrid Logic without existential modality $\E$ and binder operator $\downarrow$ (for details see \cite{ARECES2007821}), to the best of our knowledge even the extension of $\ATL$ with nominals and $@_{\alpha}$ operator (sometimes it is called the \textit{basic
%hybrid language} \cite{Areces_Blackburn2000}) has never been considered. At the same time various temporal hybrid logics have been proposed before. Thus, expressivity and complexity problems for hybrid extensions of both linear- and branching-time temporal logics have been extensively studied in \cite{blackburn99,Areces_Blackburn2000,Goranko2000-GORCTL-2,Franceschet_etal2003,franceschet06,Kara2009,Lange2009,BOZZELLI2010454,Kernberger2020}. In the framework of strategic reasoning, \cite{Huang_Meyden2018} used constructs similar to hybrid logic modality $\E$, but not $@_{\alpha}$ or nominals themselves. Finally, although some works using hybrid logic ideas in the context of Dynamic Epistemic Logic has appeared recently \cite{Roy2009,HANSEN201133} as well as several papers \cite{knobbout2016dynamic,bulling2016norm,galimullin2022action,galimullin2024synthesizing} combining Concurrent Game Models with $\mathsf{DEL}$-style updates for reasoning about normative updates or policy changes, we believe that our $\LAMB$ logic provides the most flexible tool for reasoning about strategic behaviour in a changing environment. 

%Given some starting configuration $M_s$ that does not satisfy $\varphi$, and a set of updates $\{\pi_1, ..., \pi_m\}$ each one of them makes $\varphi$ true, we can perhaps explore orderings on them, the simplest one being the size ordering based on the number of primitive operations that constitute $\pi_i$.




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% The acknowledgments section is defined using the "acks" environment
%%% (rather than an unnumbered section). The use of this environment 
%%% ensures the proper identification of the section in the article 
%%% metadata as well as the consistent spelling of the heading.

\begin{acks}
\ifarxiv This project has received funding from the European Union‚Äôs Horizon 2020 research and innovation programme under the Marie Sk≈Çodowska-Curie grant agreement No 101105549. 
\else
This project has been supported by the  EU H2020 Marie Sklodowska-Curie project with grant agreement No 101105549. 
\fi%If you wish to include any acknowledgments in your paper (e.g., to 
%people or funding agencies), please do so using the `\texttt{acks}' 
%environment. Note that the text of your acknowledgments will be omitted
%if you compile your document with the `\texttt{anonymous}' option.
\end{acks}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%% The next two lines define, first, the bibliography style to be 
%%% applied, and, second, the bibliography file to be used.

\bibliographystyle{ACM-Reference-Format} 
\bibliography{arxiv}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%\ifarxiv
\input{Appendix}
%\fi
%\input{Cover_letter}

\end{document}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

