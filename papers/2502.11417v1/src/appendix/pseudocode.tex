\section{Pseudocode for Cost-Aware Adaptive Request Scheduling}\label{appendix:pseudocode_scheduling}

The request scheduling algorithm consists of three key components. Algorithm~\ref{alg:definitions} defines the input parameters and determines whether the scenario is device-constrained or server-constrained based on the relative costs. For device-constrained scenarios, Algorithm~\ref{alg:device_constrained} implements a wait-time strategy to protect tail latency while conserving device energy when possible. For server-constrained scenarios, Algorithm~\ref{alg:server_constrained} employs a length-based routing approach to optimize TTFT while maintaining the server budget constraint. These algorithms work together to achieve the dual objectives of minimizing latency and managing costs.

\begin{algorithm}[ht]
\caption{Variable Definitions and Constraints}
\label{alg:definitions}
\begin{algorithmic}[1]
\REQUIRE
    \STATE $p(l)$: Length distribution
    \STATE $F(t)$: TTFT CDF of server
    \STATE $b \in [0,1]$: Budget ratio 
    \STATE $c^p_d,c^d_d$: Device prefill/decode costs
    \STATE $c^p_s,c^d_s$: Server prefill/decode costs
    \STATE $\alpha \in (0,1)$: Tail ratio
\ENSURE Policy type based on cost constraints
\STATE \textbf{if} $\min(c^p_d,c^d_d) > \max(c^p_s,c^d_s)$ \textbf{then} Device-constrained
\STATE \textbf{else} Server-constrained
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Device-constrained Scheduling}
\label{alg:device_constrained}
\begin{algorithmic}[1]
\REQUIRE Variables from Algorithm \ref{alg:definitions}
\STATE // Phase 1: Set maximum wait time for tail protection
\STATE $w_{tail} \leftarrow F^{-1}(1 - \min(\alpha, b))$ 
\STATE // Initialize wait times for all prompt lengths
\STATE $W \leftarrow \{l: w_{tail} \text{ for all } l\}$

\IF{$b \leq \alpha$} 
    \RETURN $W$ \COMMENT{Use max wait time for all lengths}
\ENDIF

\STATE // Phase 2: Optimize wait times with remaining budget
\STATE available\_budget $\leftarrow b - \alpha$
\FOR{$l \in$ sort(support($p(l)$))}
    \STATE length\_cost $\leftarrow p(l) \cdot l \cdot (1-\alpha)$ 
    \IF{available\_budget $\geq$ length\_cost}
        \STATE $W[l] \leftarrow 0$ \COMMENT{Start device immediately}
        \STATE available\_budget $\leftarrow$ available\_budget - length\_cost
    \ELSE
        \STATE // Find optimal wait time that meets budget
        \STATE Find $w^* \in [0, w_{tail}]$ where:
        \STATE $F(w^*) \cdot$ length\_cost + (b - available\_budget) = $b$
        \STATE $W[l] \leftarrow w^*$
        \STATE \textbf{break}
    \ENDIF
\ENDFOR
\RETURN $W$ \COMMENT{Map from prompt lengths to wait times}
\end{algorithmic}
\end{algorithm}

\begin{algorithm}[ht]
\caption{Server-constrained Scheduling}
\label{alg:server_constrained}
\begin{algorithmic}[1]
\REQUIRE Variables from Algorithm \ref{alg:definitions}
\STATE // Find length threshold to split execution modes
\STATE Compute $l_{th}$ where: $\int_0^{l_{th}} l \cdot p(l) dl = (1-b) \cdot \int_0^\infty l \cdot p(l) dl$

\STATE // Initialize execution policy map
\STATE $P \leftarrow \emptyset$ 
\FOR{$l \in$ support($p(l)$)}
    \IF{$l < l_{th}$}
        \STATE $P[l] \leftarrow$ (1, 0) \COMMENT{$(I_d,I_s)$: Device only}
    \ELSE
        \STATE $P[l] \leftarrow$ (1, 1) \COMMENT{$(I_d,I_s)$: Concurrent execution}
    \ENDIF
\ENDFOR
\RETURN $P$ \COMMENT{Map from lengths to execution indicators}
\end{algorithmic}
\end{algorithm}