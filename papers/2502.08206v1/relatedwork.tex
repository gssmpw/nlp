\section{Related work}
\label{sec:related-work}

\gls{FL} has shifted decisively from synchronous \cite{wang2020tackling, qu2021feddq, makarenko2022adaptive, mao2022communication, tyurin2022dasha} to asynchronous models, driven by challenges in scaling, resource allocation, and coordination. Key studies highlight the limitations of synchronous \gls{FL}, such as the susceptibility to delays from stragglers and difficulties in managing communication rounds as the number of agents increases \cite{xie2019asynchronous}. This has accelerated the adoption of asynchronous approaches, such as \texttt{FedAsync} and its variants \cite{xie2019asynchronous, chen2020asynchronous, xu2021asynchronous}, which incorporate memory-based updates, adaptive learning rate adjustments, and strategies to reduce staleness and handle varying computational speeds.

Nevertheless, limitations persist, especially in dealing with heterogeneous data environments \cite{koloskova2022sharper}. Innovations such as \texttt{FedBuff} \cite{Nguyen2021FederatedLW}, with \gls{CS}-side buffering, and \texttt{AsyncSGD} \cite{koloskova2022sharper}, with its delay guarantees, address some issues, but existing performance guarantees often rely on simplified assumptions about queue dynamics and processing delays, affecting \gls{FL} system performance and efficiency.

Recent work like \texttt{AsGrad} \cite{islamov2023asgrad}, which extends asynchronous \gls{FL} analysis under bounded-gradient assumptions, underscores the benefits of deeper insights into these dynamics. The typical finite-delay assumption reveals a major gap in the literature: existing models fail to fully capture the unpredictable and heterogeneous nature of client speeds and network conditions, even if these are the fundamental motivation for introducing asynchronous \gls{FL} in the first place. Despite progress in the understanding of asynchronous FL, a comprehensive analysis of the underlying stochastic queuing dynamics remains urgently needed.
A preliminary attempt is made in~\cite{leconte2024queuing}, which introduces \texttt{Generalized AsyncSGD}â€”an algorithm that utilizes non-uniform client selection to address queuing dynamics and heterogeneous server speeds. However, their analysis falls short in providing explicit performance bounds, instead relying on scaling regimes to approximate the system behavior\celine{One could argue that you were still able to optimize the bound~$G$. Maybe explain why it's not sufficient to analyze scaling regimes and/or why it was "hard" to optimize~$G$?}. A detailed analysis is central to the optimization of \gls{FL} systems, not only in terms of traditional network performance metrics, but also for achieving effective, efficient, and fair learning outcomes with diverse and distributed clients.
Our results highlight in particular that routing strategies should be adapted based on the specific bottlenecks imposed by applications, such as the number of computations rounds versus actual training time.