\documentclass[runningheads]{llncs}
% If you use the hyperref package, please uncomment the following two lines
% to display URLs in blue roman font according to Springer's eBook style:
%\usepackage{color}
%\renewcommand\UrlFont{\color{blue}\rmfamily}
%\urlstyle{rm}
%

\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{wrapfig2}
\usepackage{amsmath,amssymb}
\usepackage{mathrsfs}
\usepackage{stackrel}
\usepackage{mathtools}
\usepackage{nicefrac}
\usepackage{thmtools}
\usepackage{stmaryrd}
\usepackage{wasysym}
\usepackage{pifont}
\usepackage{array}
\usepackage{cases}
\usepackage{adjustbox}
\usepackage[inline]{enumitem}
\usepackage{url}
\usepackage{doi}
\usepackage{acronym}
\usepackage{todonotes}

\usepackage[font=small,labelfont=bf,tableposition=top]{caption}
\DeclareCaptionLabelFormat{andtable}{#1~#2  \&  \tablename~\thetable}

\usepackage{framed}
\usepackage{listings}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{multirow}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{arrows,automata}
\usetikzlibrary{shapes.geometric} % For elliptic states
\usetikzlibrary{shapes.misc} % for chamfered rectangle
\usetikzlibrary{decorations.pathmorphing} % For snake line
\usetikzlibrary{matrix}
\usetikzlibrary{calc}

% for commenting out large parts of text
\usepackage{comment}

% to force image position in the text
\usepackage{float}

% for fancy code
\usepackage[frozencache, cachedir=.]{minted}

% for coloring
\usepackage{xcolor}


% \newcommand{\slimparagraph}[1]{\paragraph{#1}}
\newcommand{\slimparagraph}[1]{\noindent \emph{#1}}

% Avoid extra line spacing due to tall math expressions
%\lineskiplimit=-\maxdimen

\input{macros}
\input{acronyms}

\begin{document}
%
\title{$\toolname$: a Model Checker for probabilistic Pushdown Automata}
%
%\titlerunning{Abbreviated paper title}
% If the paper title is too long for the running head, you can set
% an abbreviated paper title here
%
\author{Francesco Pontiggia\inst{1} \and
    Ezio Bartocci\inst{1} \and
    Michele Chiari\inst{1}}
\institute{TU Wien, Austria
\email{}}

%
\maketitle              % typeset the header of the contribution
%

\acused{POTLF}

\vspace{-5ex}

\begin{abstract}
We present $\toolname$, the first full-fledged model checking tool for \acp{pPDA}.
$\toolname$ provides a user-friendly probabilistic modeling language with recursion that automatically translates into \acp{pOPA}.
\acp{pOPA} are a class of \acp{pPDA} that can express all the behaviors of probabilistic programs.
On \acp{pOPA}, $\toolname$ can solve reachability queries as well as qualitative and quantitative model checking queries for specifications in \ac{LTL} and a fragment of \ac{POTL}, a logic for context-free properties such as pre/post-conditioning.

% \keywords{Probabilistic Model Checking \and
%  Pushdown Model Checking \and
%  Temporal Logic \and
%  Operator Precedence Languages.}
\end{abstract}

\section{Introduction}
\label{sec:intro}

\begin{wrapfigure}[10]{r}{0.4\textwidth}
\vspace{-10ex}
\begin{minted}[fontsize=\scriptsize]{python}
# global variables: a[], mid, val
B(u4 left, u4 right) {
  mid = Uniform(left, right);
  if (left < right){
    if (a[mid] < val) {
      left = min(mid +1, right);
      B(left, right);
    } else { if (a[mid] > val) {
      right = max(mid -1, left);
      B(left, right);
    } }
  }
}
\end{minted}
\vspace{-3ex}
\caption{Sherwood Binary search.}
\label{fig:Sherwood}
\vspace{-3em}
\end{wrapfigure}

The last two decades saw great efforts to study \acfp{pPDA} ~\cite{EsparzaKM04,KuceraEM06,BrazdilEK05,BrazdilBHK08,BrazdilEKK13,BrazdilKKV15} and the equivalent model of \acp{RMC}~\cite{EtessamiY05,YannakakisE05,EtessamiY05b,EtessamiY09,EtessamiY12,EtessamiY15} as a succinct formalism to express infinite-state probabilistic systems and to model probabilistic programs with nested and possibly recursive procedures. However, no existing tool implements such model checking algorithms, due to their theoretical complexity and many practical obstacles. With $\toolname$, we leverage various recent results on \acp{pPDA} analysis to produce an efficient model checking tool for \acp{pPDA} scaling beyond toy examples, and forms a baseline for future verification tools targeting infinite-state probabilistic systems.

\slimparagraph{Illustrative Example.}
Consider the Sherwood~\cite{mcconnell2007analysis} variant of the binary search (Fig.~\ref{fig:Sherwood}), a well-known recursive algorithm.
\B{} searches for \texttt{val} in the array \arr{}.
Unlike the deterministic version, in each iteration \B{} selects the pivot \texttt{mid} randomly among the remaining portion of \texttt{a}.
Thanks to randomness, worst-, best- and average runtime align.
If \texttt{a} has a finite bound and its elements have a finite domain, \B{} can be translated into a (finite-state) \ac{pPDA}:
automaton states model global and local variable values,
while stack symbols model procedure parameter values.
A well-studied property of this program is \textbf{partial correctness}~\cite{OlmedoKKM16}:
when \B{} is invoked in a state where \texttt{left} $\leq$ \texttt{right},
\arr{} is sorted and \texttt{val} occurs in \arr{}, then at return \texttt{mid} stores the index of \texttt{a} where \texttt{val} lies.
This property, just like pre/post-conditioning, requires to match each call to \B{} in the recursion
to its corresponding return, and skip inner calls to \B{} in the execution trace:
it is a context-free property beyond \acs{LTL}'s expressivity, limited to regular properties.
\ac{POTL}~\cite{ChiariMP21a} is a state-of-the-art logic based on \acp{OPL}~\cite{Floyd1963}, a subclass of context-free languages, and expresses partial correctness as:
\begin{center}
$\llglob (\lcall \land \mathtt{B} \land \mathtt{sorted} \land \mathtt{valOccurs} \land  \mathtt{left} \leq \mathtt{right} \implies \lcunext \mathtt{a[mid]} == \mathtt{val})$
\end{center}

\slimparagraph{Probabilistic programming.}
Probabilistic programs have recently gained popularity in AI and machine learning~\cite{Ghahramani15}, where they are employed as succinct models for Bayesian inference~\cite{GordonHNR14}.
In addition to randomized assignment, a prominent feature of this programming model is \emph{conditioning},
which allows for adding evidence of observed events by conditioning the program variables to take certain values.
When using rejection sampling, a probabilistic program contains statements \texttt{observe(e)},
where \texttt{e} is a Boolean condition.
If \texttt{e} is not satisfied, the current execution trace is rejected: in such a case, we assume that the program is restarted.
%we can assume the program is restarted, hoping for better luck in the future.
The semantics of a probabilistic program is the probability distribution in the return statement, also called \emph{posterior}.
Probabilistic programs can also be nested: a program samples a value from a distribution represented by another probabilistic program.
They are known under the name of \emph{nested queries}, and model scenarios beyond the expressivity of flat probabilistic programs: most notably, metareasoning patterns \cite{StuhlmullerG14,ZhangA22}, multi-agent planning~\cite{seaman2020} and sequential decision making~\cite{Evans17}.
To the best of our knowledge, \acp{pOPA}~\cite{abs-2404-03515} are the smallest subclass of \acp{pPDA} that can model effectively these behaviors. \acp{pOPA} traces are \acp{OPL}.
Unlike general context-free languages, \acp{OPL} are closed under most relevant Boolean operations~\cite{MP18}.
Let $\mathcal{B}$ be an (deterministic or separated) \ac{OPBA}, the class of automata recognizing \acp{OPL}.
When a \ac{pOPA} $\mathcal{A}$ and $\mathcal{B}$ are defined over the same alphabet, we can verify automatically $\mathcal{A}$ against $\mathcal{B}$ via automata-based model checking~\cite{abs-2404-03515}.

%\slimparagraph{Earlier Attempts and Related Work.}
%\todo[inline]{I would like to write this just like PET - they have a section like this}
% The two main practical obstacles are:
% \begin{itemize}
%     \item nondeterminism of the formula's automaton, which also leads to a very big and intricate automaton with an exponential blowup
%     \item solving systems of polynomial equations, for which SMT solver offer only very slow doubly exponential decision procedures.
% \end{itemize}

\slimparagraph{Our approach.} The main challenge in \acp{pPDA} model checking is computing the \emph{termination probabilities}, which involves solving a system of \textbf{non-linear} equations. 
While tools like PReMo~\cite{WojtczakE07} approximate them from below, for general model checking we need to know whether these quantities are exactly 1.
We could employ off-the-shelf SMT solvers (e.g. Z3~\cite{MouraB08}) with decision procedures for the \ac{ETR} (\textsc{qf\_nra}), but they offer only doubly exponential decision procedures~\cite{JovanovicM12},
although \ac{ETR} is in \textsc{pspace}~\cite{Canny88,Renegar92}.
We thus devise a semi-algorithm leveraging both certificates for termination probabilities~\cite{WinklerK23a} via a numeric method called \ac{OVI}, and certificates for expected runtimes~\cite{WinklerK23b}.
A second challenge is the need for deterministic automata in probabilistic verification---a common problem already present in the far simpler setting of \acs{LTL} model checking for Markov Chains~\cite{andriushchenko2024tools}.
In this regard, we exploit~\cite{EtessamiY12,abs-2404-03515} which provide resp.\ single exponential model checking algorithms (i.e., avoiding determinization) for \acs{LTL} and a fragment of \ac{POTL} (\acs{POTLF}).
These algorithms represent the theoretical ground of $\toolname$.
In practice, we use the POMC tool \cite{PontiggiaCP21,Pontiggia21,ChiariMPP23} for automata construction.

%%The main challenges we faced during the design of $\toolname$  were the nondeterminism of the automaton representing the formula to check, which leads to a large and complex automaton with exponential growth, and the problem of solving systems of polynomial equations, for which SMT solvers offer only slow and doubly exponential decision procedures.  To overcome these challenges, 
%$\toolname$ uses the \textsc{POMC} tool  for automata construction supporting both LTL and POTL.  Furthermore, by restricting POTL to a special fragment, our model checker can leverage the algorithm based on single exponential separation proposed in. Finally, to avoid the prohibitive computational cost of SMT solvers to solve systems of polynomial equations $\toolname$ also provides a more practical, but inconclusive approach based on the semi-algorithm proposed in \cite{WinklerK23a,WinklerK23b} for generating (non)termination certificates for probabilistic pushdown automata. 
%
$\toolname$ is available at: 
%\begin{center}
\url{https://github.com/michiari/POMC/tree/popa}
%\end{center}


\slimparagraph{Contributions.}
We present i) a semi-algorithm overcoming numerical issues regarding computing termination probabilities;
ii) \toolname, a model checker for \acp{pPDA} based on this semi-algorithm; 
iii) a user-friendly domain-specific language for recursive probabilistic programs;
and iv) an extensive experimental evaluation with a benchmark of programs and LTL/\acs{POTLF} formulae.


\section{Background}
\label{sec:background}

\subsection{\acf{pOPA}}
\acp{pOPA} are \acp{pPDA} with state labels from a set $\Sigma$.
State labels drive the stack behavior of \acp{pOPA} through three \emph{\acp{PR}}:
given two labels $a$ and $b$, we say $a$ \emph{yields precedence} to $b$ iff $a \lessdot b$,
$a$ and $b$ are \emph{equal in precedence} iff $a \doteq b$,
and $a$ \emph{takes precedence} from $b$ iff $a \gtrdot b$.
An \ac{OPM} is a total function
$M : \Sigma^2 \rightarrow \{\mathord{\lessdot}, \mathord{\doteq}, \mathord{\gtrdot}\}$.
$\mathfrak{D}(S) = \{f : S \rightarrow [0,1] \mid \sum_{s \in S} f(s) = 1\}$
is the set of probability distributions on a finite set $S$.
\begin{definition}[\cite{abs-2404-03515}]
A \ac{pOPA} is a tuple
$\mathcal A = (\Sigma, \allowbreak M, \allowbreak Q, \allowbreak u_0,
\allowbreak \delta, \allowbreak \Lambda)$ where:
$\Sigma$ is a finite set of state labels; $M$ is an \ac{OPM};
$Q$ is a finite set of states;
$u_0$ is the initial state;
$\Lambda : Q \rightarrow \Sigma$ is a state labeling function; and
$\delta$ is a triple of transition functions
$\delta_{\mathit{push}} : Q \rightarrow \mathfrak{D}(Q)$,
$\delta_{\mathit{shift}} : Q \rightarrow \mathfrak{D}(Q)$, and
$\delta_{\mathit{pop}} : (Q \times Q) \rightarrow \mathfrak{D}(Q)$,
such that pop moves have the following condition, for all $u, s, v \in Q$:
\vspace{-1ex}
\begin{center}
\(
\delta_\mathit{pop}(u, s)(v) > 0 \implies
  \forall a \in \Sigma : a \gtrdot \Lambda(u) \implies a \gtrdot \Lambda(v).
\)
\vspace{-.5ex}
\end{center}
\end{definition}
We define the semantics of $\mathcal{A}$ through
an infinite Markov chain~\cite{BaierK08} $\Delta(\mathcal{A})$
with vertex set $Q \times (\Gamma^* \{\bot\})$
where $\bot$ is the initial stack symbol,
which can never be pushed or popped,
and $\Gamma = \Sigma \times Q$ is the set of stack symbols.
\acp{PR} decide whether to push or pop from the stack.
For any stack contents $A \in \Gamma^* \{\bot\}$:\\
\textbf{push:} $(u, A) \apush{x} (v, [\Lambda(u), u] A)$
  if $\symb{A} \lessdot \Lambda(u)$
  and $\delta_{\mathit{push}}(u)(v) = x$;\\
\textbf{shift:} $(u, [a, s] A) \apush{x} (v, [\Lambda(u), s] A)$
  if $a \doteq \Lambda(u)$
  and $\delta_{\mathit{shift}}(u)(v) = x$;\\
\textbf{pop:} $(u, [a, s] A) \apush{x} (v, A)$
  if $a \gtrdot \Lambda(u)$
  and $\delta_{\mathit{pop}}(u, s)(v) = x$;\\
\noindent where $\symb{\bot} = \#$ and $\symb{[a, r]} = a$ for $[a, r] \in \Gamma$.
A run of $\mathcal{A}$ is a path in $\Delta(\mathcal{A})$ that starts in $(u_0, \bot)$.
%where $u_0$ is the initial state.
Since $\symb{\bot} = \#$, the first move is always a push.
The probability space over the set of such runs
is obtained by the classic cylinder set construction for Markov chains~\cite{BaierK08}.
The set of infinite words formed by labels of states in a run form an \ac{OPL} \cite{abs-2404-03515}.

\begin{wrapfigure}[5]{r}{3.5cm}%
\vspace{-8ex}
\scriptsize
\centering
\(
\begin{array}{r | c c c c c}
         & \lcall   & \lret   & \lqry    & \lobs    & \lstm \\
\hline
\lcall   & \lessdot & \doteq  & \lessdot & \gtrdot  & \lessdot \\
\lret    & \gtrdot  & \gtrdot & \gtrdot  & \gtrdot  & \gtrdot \\
\lqry    & \lessdot & \doteq  & \lessdot & \lessdot & \lessdot \\
\lobs    & \gtrdot  & \gtrdot & \gtrdot  & \gtrdot  & \gtrdot \\
\lstm    & \gtrdot  & \gtrdot & \gtrdot  & \gtrdot & \gtrdot \\
\end{array}
\)
\vspace{-1.5ex}
\caption{\acs{OPM} $M_\lcall$.}
\label{fig:opm}
%\vspace{-4ex}
\end{wrapfigure}
State labels in \ac{OPM} $M_\lcall$ (Fig.~\ref{fig:opm}) represent traces of probabilistic programs.
$\lcall$ and $\lret$ are function calls and returns,
$\lstm$ statements that do not affect the stack (e.g., assignments),
and $\lqry$ and $\lobs$ are query statements and false observations.
\acp{PR} are such that a \ac{pOPA} always pushes from a $\lcall$ state
($\lcall \lessdot \lcall$, etc.),
and pops after reading $\lret$ through a shift move
($\lcall \doteq \lret$ and $\lret$ takes precedence from other symbols):
this way, the \ac{pOPA} stack mimics the program's stack.
Moreover, $\lobs$ triggers pop moves that unwind the stack until a symbol with $\lqry$,
representing a nested query, is reached, in line with rejection sampling~\cite{OlmedoGJKKM18}.


\subsection{Specification Formalism}

We express specifications through a temporal logic with the following syntax:
\begin{center}
\vspace{-1ex}
\(
    \varphi \coloneqq \mathrm{a}
    \mid T
    \mid \neg \varphi
    \mid \varphi \lor \varphi
    \mid \lnext \varphi
    \mid \lluntil{\varphi}{\varphi}
    \mid \lnextsup{t} \varphi
    \mid \lcnext{t} \varphi
    \mid \lguntil{t}{\chi}{\varphi}{\varphi}
\)
\vspace{-1ex}
\end{center}
Formulas are evaluated in the first position of program traces,
and subformulas in further positions.
$\mathrm{a}$ is an \emph{atomic proposition} from a finite set $AP$ containing
labels from Fig.~\ref{fig:opm} and names of program functions.
$T$ is any term of the form $e_1 \bowtie e_2$, where $\bowtie$ is a binary comparison operator
($=$, $>$, etc.) and $e_1, e_2$ are integer arithmetic expressions involving program variables and constants.
$\neg$ and $\lor$ are propositional operators,
to which we add the derived operators $\land$ and $\implies$ with the usual semantics.
$\lnext \varphi$ and $\lluntil{\varphi_1}{\varphi_2}$ are the \emph{next} and \emph{until} operators from \ac{LTL}~\cite{Pnueli77},
resp.\ meaning that $\varphi$ will hold in the next time instant,
and that $\varphi_1$ holds until a time instant in which $\varphi_2$ does.
We use the derived operators \emph{eventually} $\lleven \varphi \equiv \lluntil{\top}{\varphi}$,
and \emph{globally} $\llglob \varphi \equiv \neg \lleven \neg \varphi$.

The remaining operators form a fragment of \ac{POTL} called \acs{POTLF}.
They move up ($t = u$) and down ($t = d$) among function frames in the program stack.
$\ldnext \varphi$ holds if the next time instant belongs to the same or a lower frame
and $\varphi$ holds in it, and \emph{vice versa} for $\lunext$.
$\lcdnext$ moves along a binary relation that links function calls to their returns and inner function calls.
E.g., if evaluated in an instant labeled with $\lcall$,
$\lcdnext (\lret \land \varphi)$ holds if the function returns in an instant in which $\varphi$ holds;
$\lcunext \lobs$ holds if it contains a false \texttt{observe}.
The semantics of $\lguntil{t}{\chi}{}{}$ are the same as the \ac{LTL} until,
except it works on paths obtained by iterating the $\lnextsup{t}$ and $\lcnext{t}$ operators,
for $t \in \{u,d\}$.
For a complete definition, cf.~\cite{ChiariMP21b}.


\section{Model Checking algorithm}
\label{sec:mc-algorithm}

\subsection{The Support Chain}
\label{sec:support-chain}

Let $\mathcal{A} = (\Sigma, \allowbreak M, \allowbreak Q, \allowbreak u_0,
\allowbreak \delta, \allowbreak \Lambda)$
be a \ac{pOPA}.
A \emph{support} is a sequence of \ac{pOPA} moves
\(
u_0
\apush{}{u_1}
\ashift{}{}
\dots
\ashift{}{u_\ell}
\apop{u_0} {u_{\ell+1}},
\)
denoted as $u_0 \asupp{}{} u_{\ell+1}$,
that occur from the move pushing a stack symbol $[\Lambda(u_0), u_0]$ to the move popping it.
Given $u, v \in Q$ and $\alpha \in \Gamma$, we define $\pvar{u}{\alpha}{v}$
as the probability that $\mathcal{A}$ has a support $u \asupp{}{} v$
starting and ending with $\alpha$ on top of the stack.
Such \emph{termination} probabilities~\cite{EtessamiY09,BrazdilEKK13}
are the least non-negative solutions of the equation system
$\mathbf{v} = f(\mathbf{v})$, where $\mathbf{v}$ is the vector of triples
$\pvar{u}{\alpha}{v}$ for all $u, v \in Q$, $\alpha \in \Gamma$ and $f(\pvar{u}{\alpha}{v})$ is given by
\vspace{-1ex}
\[
\begin{cases}
\sum_{r, t \in Q} \delta_\mathit{push}(u)(r) \pvar{r}{[\Lambda(u), u]}{t} \pvar{t}{\alpha}{v} & \text{if $\alpha = \bot$, or $\alpha = [a, s]$ and $a \lessdot \Lambda(u)$} \\
\sum_{r \in Q} \delta_\mathit{shift}(u)(r) \pvar{r}{[\Lambda(u), s]}{v} & \text{if $\alpha = [a, s]$ and $a \doteq \Lambda(u)$} \\
\delta_\mathit{pop}(u, s)(v) & \text{if $\alpha = [a, s]$ and $a \gtrdot \Lambda(u)$}
\end{cases}
\vspace{-1ex}
\]
The probability that $\alpha \in \Gamma$ is never popped
after a run visits a configuration $(u, \alpha A)$ for $u \in Q$ and some stack contents $A$ is
\(\nex{u, \alpha} = 1 - \sum_{v \in Q} \pvar{u}{\alpha}{v}.\)

The \emph{support chain} is a finite Markov chain that replaces supports with single transitions,
and describes the behavior of %non-terminating 
\ac{pOPA} runs while preserving their probability distribution.
Its transition probabilities are conditioned on the fact that a run of $\mathcal{A}$ including them never terminates.
\begin{definition}[\cite{abs-2404-03515}]
The \emph{support chain} $M_\mathcal{A}$ of $\mathcal{A}$ is a Markov chain with states in
$\mathcal{C} = \{ (u, \alpha) \in Q \times \Gamma_\bot \mid \nex{u, \alpha} > 0 \}$,
initial state $(u_0, \bot)$,
and a transition probability function $\delta_{M_\mathcal{A}}$ such that
\begin{itemize}
\item
  $\delta_{M_\mathcal{A}}(u, [a, s])(v, [\Lambda(u), s]) = \delta_{\mathit{shift}}(u)(v) \nex{v, [\Lambda(u), s]} / \nex{u, [a, s]}$\\
  for all $(u, [a, s]), (v, [\Lambda(u), s]) \in \mathcal{C}$ such that $a \doteq \Lambda(u)$;
\item otherwise, for all $(u, \alpha), (v, \alpha') \in \mathcal{C}$,\\
  \(
  \delta_{M_\mathcal{A}}(u, \alpha)(v, \alpha') =
    (P_\mathit{push} + P_\mathit{supp}) \nex{v, \alpha'} / \nex{u, \alpha}
  \)
  where
  \begin{itemize}
    \item $P_\mathit{push} = \delta_{\mathit{push}}(u)(v)$ if $\symb{\alpha} \lessdot \Lambda(u)$,
          and $P_\mathit{push} = 0$ otherwise;
    \item $P_\mathit{supp} = \sum_{v' \in Q} \delta_{\mathit{push}}(u)(v') \pvar{v'}{[\Lambda(u), u]}{v}$,
          if $\alpha = \alpha'$, $\symb{\alpha} \lessdot \Lambda(u)$, and $\mathcal{A}$ has a support $u \asupp{}{} v$,
          and $P_\mathit{supp} = 0$ otherwise.
  \end{itemize}
\end{itemize}
\end{definition}
%We can prove that 
%There exists a map between finite paths in $\Delta(\mathcal{A})$ and $M_\mathcal{A}$
%that preserves the probability measure of the respective cylinder sets \cite[Thm.~4.9]{abs-2404-03515}.


%\subsection{Building the Support Chain}
%\label{sec:building-the-sc}

% To build the support chain of $\mathcal{A}$, 
% we must check whether $\nex{c} > 0$ for all $c \in Q \times \Gamma_\bot$.
% A straightforward solution is to use an SMT solver supporting the \ac{ETR} (or \textsc{qf\_nra}) \cite{EtessamiY09,BrazdilEKK13}:
% %Since $\nex{c} = 1 - \sum_{v \in Q} \pvarnode{c}{v}$,
% we check satisfiability of assertions
% $\mathbf{v} = f(\mathbf{v}) \land \nex{c} > 0$
% (recall that $\nex{c} = 1 - \sum_{v \in Q} \pvarnode{c}{v}$),
% calling $\mathbf{v}^*$ the \emph{least} solution of $\mathbf{v} = f(\mathbf{v})$,
% which is the vector of termination probabilities $\pvarnode{c}{v}$.
% If any solution satisfies $\nex{c} > 0$, so does the least solution.
% %Note that in qualitative model checking we do not need the exact probability values.
% % this is not true and misleading, we need to build the support chain for qualitative model checking
% We tried using Z3~\cite{MouraB08} for its better performance on such queries~\cite{WinklerK23a}, but it timed out in most of our experiments. 

\begin{figure}[tb]
\centering
\begin{tikzpicture}
  [ node distance=0pt, font=\scriptsize, >=latex,
    action/.style={draw, rectangle},
    cond/.style={draw, chamfered rectangle, chamfered rectangle xsep=5em, chamfered rectangle ysep=0pt},
    scale=.7
  ]
\node (popa) [action] {pOPA};
\node (fv) [action, right=10pt of popa] {$f(\mathbf{v})$};
\node (Z3) [action, right=11pt of fv, yshift=10pt] {Z3 $\overline{\mathbf{v}}^*$};
\node (ovi) [action, right=10pt of fv, yshift=-10pt] {\textsc{ovi} $\overline{\mathbf{v}}^*$};
\node (ast) [cond, right=10pt of ovi, yshift=10pt] {$\underline{\nex{c}} > 0?$};
\node (past) [action, right=10pt of ast] {Z3 (\textsc{past})};
\node (pastc) [cond, right=10pt of past] {is $c$ \textsc{past}?};
%
\node (inc) [action, right=10pt of pastc, yshift=-10pt, text width=42pt] {inconclusive};
\node (disc) [action, above=3pt of inc, text width=42pt] {discard};
\node (suppc) [action, above=3pt of disc, text width=42pt] {add to SC};
%
\path (popa) edge[->] (fv)
      (fv) edge[->] (Z3)
      (Z3) edge[->] (ast.west)
      (fv) edge[->] (ovi)
      (ovi) edge[->] (ast.west)
      (ast) edge[->] node[shift={(-1pt,-3pt)}]{no} (past)
      (past) edge[->] (pastc);
\path[draw, ->] (ast.east) node[shift={(6pt,16pt)}]{yes} |- (suppc.west);
\path[draw, ->] (pastc.east) node[shift={(3pt,8pt)}]{yes} |- (disc.west);
\path[draw, ->] (pastc.east) node[shift={(5pt,-7pt)}]{no} |- (inc.west);
\draw[dotted] ($ (Z3.north west) + (-3pt,15pt) $) node[shift={(12pt,-4pt)}]{$\forall c \in \mathcal{C}$} rectangle ($ (inc.south east) + (1pt,-1pt) $);
\end{tikzpicture}
\caption{Overview of the semi-algorithm for building the support chain (SC).}
\label{fig:workflow-diagram}
\end{figure}

To build the support chain of $\mathcal{A}$, 
we must check whether $\nex{c} > 0$ for all $c \in Q \times \Gamma_\bot$.
We propose the approach sketched in Fig.~\ref{fig:workflow-diagram},
that exploits recent results on finding certificates for \acp{pPDA}.

Let $\mathbf{v}^*$ be the \emph{least} solution of $\mathbf{v} = f(\mathbf{v})$,
i.e., the vector of termination probabilities $\pvarnode{c}{v}$.
Recall that $\nex{c} = 1 - \sum_{v \in Q} \pvarnode{c}{v}$.
First, we find an upper bound $\overline{\mathbf{v}}^*$ for $\mathbf{v}^*$,
which we use to compute a lower bound $\underline{\nex{c}}$ for $\nex{c}$.
If $\underline{\nex{c}} > 0$, then $\nex{c} > 0$ and we add $c$ to the support chain.
Otherwise, we make the hypothesis that $\nex{c} = 0$,
i.e., that $c$ is almost-surely terminating (\textsc{ast}),
and check the stronger condition that $c$ is positively \textsc{ast} (\textsc{past}). 
A node $c = (u, \alpha)$ is \textsc{past} if stack symbol $\alpha$ is popped with probability 1 in \emph{finite expected time}.
We check \textsc{past} by solving with Z3 a system of linear equations~\cite{WinklerK23b} for the expected termination times.
If a solution exists, then $c$ is \textsc{past} and therefore \textsc{ast}. 
In this case, we do not add $c$ to the support chain;
otherwise, the whole algorithm is inconclusive.
We further optimize the algorithm by applying it bottom-up to \acp{SCC} of the system $\mathbf{v} = f(\mathbf{v})$.

We find the upper bound $\overline{\mathbf{v}}^*$ in two different ways.
In both cases, we first find a lower bound $\underline{\mathbf{v}}^*$ to $\mathbf{v}^*$ by value iteration.
\begin{itemize}
\item In the first method, we give $\underline{\mathbf{v}}^*$ as a hint to Z3, and
obtain  $\overline{\mathbf{v}}^*$ as a model for $\mathbf{v}$ in the query
$\underline{\mathbf{v}}^* \leq \mathbf{v} \leq \underline{\mathbf{v}}^* + \varepsilon \land \mathbf{v} \geq f(\mathbf{v})$,
for a small positive $\varepsilon$.
% We experimentally found that Z3 solves such queries faster than those with a strict equality.
\item The other method employs \ac{OVI}~\cite{WinklerK23a}, which computes $\overline{\mathbf{v}}^*$ numerically.
We run \ac{OVI} per-\ac{SCC}, initialized on $\underline{\mathbf{v}}^*$.
\end{itemize}


\subsection{Avoid determinization with a separation-based approach}
\label{sec:mc-algorithm-separation}

A prominent approach to \acs{LTL} model checking on probabilistic systems expresses specifications as deterministic automata.
Storm~\cite{HenselJKQV22} and PRISM~\cite{KwiatkowskaNP11} translate the input formula into a deterministic Rabin automaton~\cite{BaierK08}, % , i.e. a deterministic FSA with a Rabin acceptance condition.
with a worst-case doubly exponential blowup.
While singly exponential algorithms that avoiding determinization exist~\cite{CouvreurSS03,BaierK00023},
a common argument for using the conceptually simpler notion of Rabin automata is that for unsophisticated \acs{LTL} formulae the corresponding deterministic automata are still relatively small-sized~\cite{EsparzaKS20}.
Unfortunately, the same cannot be said for \ac{POTL} formulae: the automata construction for \acs{POTL} is much more involved~\cite{ChiariMPP23},
and easily generates intractable automata.
%Determinizing these would be unfeasible.
%Moreover, this task requires developing an acceptance condition more expressive than Rabin's,
%which is inadequate for pushdown automata accepting infinite words~\cite{LonatiEtAl2015}.

\begin{figure}[tb]
\centering
\begin{tikzpicture}
  [ node distance=0pt, font=\scriptsize, >=latex,
    action/.style={draw, rectangle},
    cond/.style={draw, chamfered rectangle, chamfered rectangle xsep=5em, chamfered rectangle ysep=0pt},
    round/.style={draw, circle},
    scale=.7
  ]
\node (phi) [action, align=center] {Formula};
\node (opba) [action, right=10pt of phi, align=center] {separated \acs{OPBA}};
\node (prog) [action, below=9pt of phi.south west, anchor=north west, align=center] {Program};
\node (popa) [action, right=10pt of prog, align=center] {\acs{pOPA}};
\node (sc) [action, right=20pt of popa, align=center] {Support Chain};
\node (prod) [round, inner sep=1pt, right=3pt of sc, yshift=11pt] {$\times$};
\node (g) [action, right=10pt of prod, align=center] {Synch.\\Product};
\node (ast) [action, right=30pt of g, align=center] {AS?};
\node (yes) [round, right=160pt of opba, align=center] {\cmark};
\node (no) [round, below=3pt of yes, align=center] {\xmark};
\node (quant) [action, right=10pt of no, align=center] {quant. \\ bounds};
%
\path (phi) edge[->] (opba)
      (prog) edge[->] (popa)
      (popa) edge[->] node[yshift=4pt] {Fig.\ref{fig:workflow-diagram}} (sc);
\path[draw, ->] (opba.east) -| (prod.north);
\path[draw, ->] (sc.east) -| (prod.south);
\path (prod) edge[->] (g)
      (g) edge[->] node[align=center] {\acs{SCC}\\analysis} (ast);
\path (ast) edge[->] (yes)
      (ast) edge[->] (no)
      (no) edge[->] (quant);
\end{tikzpicture}
\caption{Overview of model checking probabilistic programs against \acs{POTLF} formulae.}
\label{fig:qualitative-workflow-diagram}
\end{figure}

$\toolname$ takes a different approach, outlined in Fig.~\ref{fig:qualitative-workflow-diagram}.
\acs{LTL} formulae can be translated into \emph{separated} B\"uchi automata,
such that the languages they accept starting from different states are disjoint~\cite{CouvreurSS03}.
Similarly, \acs{POTLF} formulae can be translated into \acp{OPBA},
i.e., pushdown automata that capture the class of infinite-word \acp{OPL},
that are \emph{separated}.
Thanks to separation, we can build a synchronized product
between the support chain of the \ac{pOPA} modeling the program
and the automaton encoding the formula.
We then perform qualitative model checking by analyzing the \acp{SCC} of the product.
%, exploiting some ideas from the algorithm for model checking \acs{LTL} formulae
%against \acp{RMC}~\cite{EtessamiY12} in exponential time.
% I would leave this out since here we are equidistanti from both papers, the LTL and the POTLFX one,.
%
Since formulae are translated into automata of exponential size~\cite{VardiW94,ChiariMPP23},
the whole procedure requires time exponential in formula size
and space polynomial in \ac{pOPA} size.
For quantitative model checking, we compute numerically the probabilities associated with edges
in the synchronized product:
edges subsuming supports require solving equation systems resembling those for termination probabilities.
We compute bounds for them with \ac{OVI}.
Since the product has size exponential in formula
\begin{wrapfigure}[15]{r}{.42\textwidth}
\begin{minipage}{.45\textwidth}
\vspace{-8ex}
\small
\begin{align*}
\mathit{prog} \coloneqq & \; [\mathit{decl} ; \dots] \; \mathit{func} \; [\mathit{func} \dots] \\
\mathit{decl} \coloneqq & \; \mathit{type \; identifier} \; [, \mathit{identifier} \dots] \\
\mathit{type} \coloneqq & \; \mathtt{bool} \mid \mathtt{u}\mathit{int} \mid \mathtt{s}\mathit{int} \mid \mathtt{u}\mathit{int}[\mathit{int}] \mid \mathtt{s}\mathit{int}[\mathit{int}] \\
\mathit{func} \coloneqq & \; f \texttt{(}\mathit{type} \; [\&] x_1 \; [, \mathit{type} \; [\&] x_2 \dots]\texttt{)} \\
  &\; \{ [\mathit{decl} ; \dots] \; \mathit{block} \} \\
\mathit{stmt} \coloneqq
    & \; \mathit{lval} = e \\
    &\mid \mathit{lval} = \mathtt{Distribution}\texttt{(} \dots \texttt{)} \\
    &\mid \mathit{lval} = e_1 \{ e_2 : e_3 \} [e_4 \{ e_5 : e_6 \} \dots] e_n \\
%    &\mid f\texttt{(}e_1 \mid \mathit{lval}_1 \; [, e_2 \mid \mathit{lval}_2 \dots]\texttt{)} \\
    &\mid [\texttt{query}] \; f\texttt{(}e_1 \mid \mathit{lval}_1 \; [, e_2 \mid \mathit{lval}_2 \dots]\texttt{)} \\
    &\mid \mathtt{if} \; \texttt{(}e\texttt{)} \; \{ \mathit{block} \} \ \mathtt{else} \ \{ \mathit{block} \} \\
    &\mid \mathtt{while} \; \texttt{(}e\texttt{)} \; \{ \mathit{block} \} \\
    &\mid \mathtt{observe} \; \texttt{(}e\texttt{)} \\
\mathit{block} \coloneqq & \; \mathit{stmt} ; [\mathit{stmt} \dots ; ] \\
\mathit{lval} \coloneqq & \; \mathit{identifier} \mid \mathit{identifier}[e]
\end{align*}
\end{minipage}
\vspace{-2ex}
\caption{MiniProb syntax.}
\label{fig:miniprob}
\end{wrapfigure}
length, quantitative model checking is in \textsc{expspace}.
For a formal treatment, cf.~\cite{abs-2404-03515}.


\section{Input Language}
\label{sec:toolDescr}

\toolname{} analyzes programs written in MiniProb, a simple probabilistic programming language (Fig.~\ref{fig:miniprob}).
MiniProb supports (un)signed integer variables of arbitrary width
(\texttt{u8} is an 8-bit unsigned type) and fixed-size arrays.
Functions take parameters by value or value-result (with \&).
Actual parameters can only be variable identifiers for value-result parameters,
and any expression if passed by value.
Expressions consist of variables, array indexing, integer constants, and the usual arithmetic and Boolean operators, including comparisons.
Boolean operators handle integers (0 means false, everything else true).
Programs may sample from $\texttt{Bernoulli(} e_1, e_2 \texttt{)}$,
% what about "where p = e1 / e2" magari killiamo la vedova
which returns 1 with probability $p = e_1 / e_2$, and 0 with probability $1-p$,
or from $\texttt{Uniform(} e_1, e_2 \texttt{)}$,
which samples uniformly among integers from $e_1$ to $e_2 - 1$.
Random assignments of the form $x = e_1 \{ e_2 / e_3 \} e_4$ mean that $x$ is assigned
the value of $e_1$ with probability $e_2 / e_3$, and $e_4$ with probability $1 - e_2 / e_3$.
Finally, functions can \texttt{query} the distribution on value-result parameters of another function,
and condition on a Boolean expression with \texttt{observe}.


\section{Evaluation}
\label{sec:experiments}
% We evaluate \toolname.
We devised our experiments around the following questions:
can our approach build support chains for probabilistic programs of medium size?
How large equations systems arise in quantitative model checking?
What are the scalability limits of our implementation, i.e., how large programs and systems can our tool solve in a reasonable time? 

\begin{table}[bt]
\caption{Benchmark formulae.}
\label{tab:formulae_experiments}
    \centering
    \begin{adjustbox}{max width=\textwidth}
    \renewcommand{\arraystretch}{1.1}
    \begin{tabular}{l @{\hspace{.4em}} l l @{\hspace{.4em}} l}
    \toprule
    \# & Formula & \# & Formula  \\
    \midrule
    \textbf{Q.1}  & $ \lleven \llglob (\neg \lobs)$ &
    \textbf{Q.2}  & $\llglob \bigl(\lqry \implies \ldnext (\lcall \land \neg \lcunext \lobs) \lor \lcdnext (\lcall \land \neg \lcunext \lobs)\bigr)$ \\
    \textbf{Q.3}  & $\llglob \, (\lcall \land \mathtt{Alice} \land \mathtt{p} \geq 0.4 \implies \neg \lcunext \lobs)$ & 
    \textbf{Q.4} & $\lluntil{\neg \mathtt{ sampleA }} {(\lcall \land \mathtt{sampleA} \land \lcdnext (\lqry \land \ldnext (\lcall \land \mathtt{sampleA})))}$ \\
    \textbf{Q.5} & $\neg \lleven \bigl(\lqry \land \lcunext (\mathtt{sampleA} \land \mathtt{opR} == 0 \land \mathtt{opC} == 1)\bigr)$ &
     \textbf{Q.6} & $\lcduntil{(\neg \mathtt{elder})}{(\mathtt{young} \land f)}$  \\
    \textbf{Q.7} & $\lleven \bigl(\lcdnext (\ldnext \mathtt{elder}) \land \lcunext (\mathtt{elder} \land \neg f)\bigr)$ &
    \textbf{Q.8} & $ \lcunext (\mathtt{aliceLoc} == 1)$ \\
    \textbf{Q.9} & $\lleven \bigl(\lret \land \mathtt{main} \land \mathtt{aliceLoc} == 1\bigr)$ &
    \textbf{Q.10} & $\neg \lcunext (\mathtt{R} == 0 \land \mathtt{C} == 2)$ \\
    \textbf{Q.11} & $\neg \lcunext (\mathtt{R} == 0 \land \mathtt{C} == 1)$ & \textbf{Q.12} & $\lluntil{\neg \lobs}{(\lcall \land \mathtt{Bob} \land \lcunext \lobs)}$ \\
     \textbf{Q.13} & $\lluntil{\neg \mathtt{Alice}}{(\lcall \land \mathtt{Alice} \land \neg \lcunext \lobs)}$ & \textbf{Q.14} & $\lleven (\lret \land \mathtt{main} \land \mathtt{R} == 0 \land \mathtt{C} == 2)$
     \\
    \textbf{Q.15} & $\lluntil{\neg \lobs}{(\lcall \land \mathtt{Alice} \land \lcunext \lobs)}$ && \\
    \textbf{Q.16} & \multicolumn{3}{l}{$\lluntil{\neg \mathtt{ sampleA }} {(\lcall \land \mathtt{sampleA} \land \lcdnext (\lqry \land \ldnext (\lcall \land \mathtt{sampleA} \land \lcdnext (\lqry \land \ldnext (\lcall \land \mathtt{sampleA})))))}$} \\
    \textbf{S.1}  & \multicolumn{3}{l}{$\llglob (\lcall \land \mathtt{B} \land \mathtt{sorted} \land \mathtt{valOccurs} \land  \mathtt{left} \leq \mathtt{right} \implies \lcunext \mathtt{a[mid]} == \mathtt{val})$} \\
    \textbf{S.2} & \multicolumn{3}{l}{$\llglob (\lcall \land \mathtt{B} \land \mathtt{sorted} \land \neg \mathtt{valOccurs} \land  \mathtt{left} \leq \mathtt{right} \implies \lcunext \mathtt{a[mid]} \neq \mathtt{val})$} \\
    \textbf{S.3} & \multicolumn{3}{l}{$\llglob (\lcall \land \mathtt{B} \land \mathtt{sorted} \land \mathtt{valOccurs} \land  \mathtt{left} < \mathtt{right} \implies \ldnext \lleven (\lcall \land \mathtt{B}))$} \\
    \textbf{S.4} & \multicolumn{3}{l}{$\llglob (\lcall \land \mathtt{B} \land \mathtt{sorted} \land \neg \mathtt{valOccurs} \land  \mathtt{left} < \mathtt{right} \implies \ldnext \lleven (\lcall \land \mathtt{B}))$} \\
    \bottomrule
    \end{tabular}
    \end{adjustbox}
\end{table}

\slimparagraph{Setup.}
Our benchmark consists of three programs (\emph{\textbf{Schelling}}, \emph{\textbf{Tic-tac-toe}} and \emph{\textbf{Virus}}) and 16 mixed LTL/\acs{POTLF} formulae (Table \ref{tab:formulae_experiments}, \textbf{Q} formulae).
All programs consist of a potentially unbounded sequence of nested queries.
This places them at the frontier of probabilistic programming: even solving simple questions about their posterior distribution is a hardly tractable problem~\cite{Rainforth18,ChiangMS23}. Additionally, to inquire scalability, we provide a case study on the \emph{\textbf{Sherwood}} binary search with increasing program state space, against four formulae (Table \ref{tab:formulae_experiments}, \textbf{S} formulae).
We run the experiments on a machine with a 4.5GHz AMD CPU and 64~GB of RAM running Ubuntu 24.04.
%
We do not offer an experimental comparison with PReMo~\cite{WojtczakE07} nor Pray~\cite{WinklerK23a}, since they only compute termination probabilities on \acp{pPDA}.
This task is not the bottleneck of the overall model checking algorithm---our tool always computes them in less than one second.

We describe in the following the three programs, (some of) the formulae we verify on them, and their results. Afterwards, we present the case study separately.
Two formulae inspecting conditioning are of interest for all three.
(\textbf{Q.1} and \textbf{Q.2}). 
If an observe statement conditions on an event with zero probability, 
all runs of a query are rejected. 
Such \emph{ill-defined} queries~\cite{Jacobs21} 
do not represent a valid probability distribution, an undesired 
condition.
\acs{LTL} property \textbf{Q.1} means that a run is always sooner or later reinstantiated into a feasible one.
However, if queries indefinitely call each other in a nonterminating program, a diverging run 
indefinitely hits unsatisfied observations in the infinite nesting.
\acs{POTLF} formula \textbf{Q.2} means that no procedure is indefinitely reinstantiated by an observation: either it terminates, or it diverges.

%Observations are expensive because they introduce a \ac{SCC}, exactly the bottleneck of these algorithms.

%\slimparagraph{Remark.} When adding a bound to the recursion depth, \acp{pPDA} are exponentially more succint than the corresponding Markov Chains where the stack is unfolded into the state space.

% schelling.pomc
\begin{wrapfigure}[16]{r}{0.32\textwidth}
\centering
\vspace{-3em}
\begin{minted}[fontsize=\scriptsize]{python}
u4 p;
main() {
  bool res;
  p = 0{2:6}1{1:6}2{1:6}3{1:6}4;
  query alice(res);
}
Alice(bool &res) {
  aliceLoc = Bernoulli(55,100);
  query Bob(bobLoc);
  observe (aliceLoc == bobLoc);
  res = aliceLoc;
}
Bob(bool &res) {
  bobLoc = Bernoulli(55,100);
  fair = true {p:10} false;
  if (fair) {
    query Alice(aliceLoc);
    observe (bobLoc == aliceLoc);
  } 
  res = bobLoc;
}
\end{minted}
\vspace{-1em}
\caption{Schelling.}
\vspace{-1em}
\label{fig:coordination_game}
\end{wrapfigure}
\slimparagraph{\textbf{Schelling}.}
We consider an instance 
of a \emph{Schelling coordination game}~\cite{StuhlmullerG14,Schelling1980}.
Two agents wish to meet in town but cannot communicate.
However, they know perfectly each other's preferences.
Each agent samples both a location according to its preference, and one obtained simulating the behavior of the other agent. Finally, it conditions on the two being equal.
The original program~\cite{StuhlmullerG14} bounds the recursion 
depth by a constant (cf.~\cite{ZhangA22}).
Conversely, we allow for unbounded recursion,  but we introduce 
a parameter \texttt{p} controlling the recursion probability. 
We fix \texttt{p}'s distribution so that the program is \textsc{ast}.
Formula \textbf{Q.13} is the event that the first call to \texttt{Bob} is rejected,
while \textbf{Q.14} that the first call to \texttt{Alice} is \emph{not} rejected. Since 
Bob is not always fair, his procedure is much less likely to be rejected.

% tic-tac-toe.pomc
\begin{wrapfigure}[5]{r}{0.15\textwidth}
\vspace{-5ex}
\centering
\large
\begin{tabular}{c|c|c}   & $\ocircle$ &  \\      \hline
 $\ocircle$  & $\times$ & $\times$ \\      \hline
   & $\ocircle$ &
\end{tabular}
\vspace{-2ex}
\caption{~\cite{StuhlmullerG14}}
\label{fig:tic-tac-toe}
\end{wrapfigure}
\slimparagraph{\textbf{Tic-tac-toe}}.
Recursive probabilistic programs also
model multi-player games involving sequential decision-making.
In these games, players choose actions that maximize future rewards by simulating, through nested queries,
others' turns as the game progresses.
We consider tic-tac-toe~\cite{StuhlmullerG14} (further analyzed in a bounded version in~\cite[Sec. 7.5]{ZhangA22}).
We inspect the max/min number of turns until termination of the game,
corresponding to the program's max/min recursion depth.
\textbf{Q.4} means that there are at least two recursive calls (i.e., two turns)%
---what we would expect from the initial state of Fig.~\ref{fig:tic-tac-toe},
where no move can immediately terminate the game.
%We also examine the players' meta-reasoning:
\textbf{Q.5} excludes that a player ever thinks
that the other one will pick cell $[0,1]$ in the next turn, which is indeed already marked at the beginning.

% vaccine_virus.pomc
\slimparagraph{\textbf{Virus}}.
Recursive probabilistic programs encode epidemiological models
and general Markov Population Models (MPPs)~\cite{RandoneDCB24} in systems biology~\cite{EtessamiY05b,haccou2005branching}.
They consist of an unbounded population of susceptible individuals
belonging to distinct species.
In the programs, the stack models the individuals currently involved in the system, and 
different procedures model different species' behaviors.
We consider the program from \cite[Fig.~1]{WinklerGK22}: a virus outbreak.
We introduce conditioning in the model expressing that some individuals are less likely to transmit the virus.
%We adapt it and add probabilistic sampling of whether to vaccinate against the disease,
%and conditioning on the fact that a vaccinated person transmits the infection at most once.
%The resulting program has a higher termination probability (i.e., virus extinction),
%but remains non-\textsc{ast}.
\textbf{Q.6} encodes the CaRet formula of~\cite[p.~3]{WinklerGK22}:
a chain of infections of young people leads to the death of an elder person.
\textbf{Q.7} means that eventually an elder person infects at least one elder person,
but none of them passes away.

\slimparagraph{Results.}
We report the experimental results for building the support chain (Table~\ref{tab:termResults}, cf. Fig.~\ref{fig:workflow-diagram}) and for solving qualitative and quantitative model checking (Table~\ref{tab:results}, cf. Fig.~\ref{fig:qualitative-workflow-diagram}). All times are in seconds and the timeout is 1 h.
A key metric is the number of equations arising from each instance.
Since we decompose the system into SCCs and solve it bottom-up, many equations are solved just by propagating already computed values---namely, when an SCC is formed by only one variable.
We thus report how many equations actually require running our semi-algorithm because of a circular dependency. % between variables.
We call them \textbf{non-trivial} (NT) equations. 
In Table~\ref{tab:termResults}, 
$|Q_\mathcal{A}|$,$|f|_{(\mathcal{A})}$, $|f_{NT}|{_{(\mathcal{A})}}$ 
are the number of resp.\ states, equations and non-trivial equations
that arise when analysing \ac{pOPA} $\mathcal{A}$ modeling the program. 
To estimate the size of individual SCCs we feed to OVI/Z3,
we report also $|f_{NT}(\text{SCC})|{_\mathit{max}}_{(\mathcal{A})}$, 
the maximum number of non-trivial equations 
in an SCC of the equation system of $\mathcal{A}$. 
In Table~\ref{tab:results}, AS tells whether the formula holds almost surely. 
If it is not the case, we perform quantitative model checking to get probability P, 
for which we provide the same metrics as above, 
but on $\hat{\mathcal{A}}$, the cross-product between $\mathcal{A}$ 
and the formula automaton (Sec.~\ref{sec:mc-algorithm-separation}).

\slimparagraph{\textbf{Sherwood}.}
The \acs{pOPA} state space is ruled by two parameters: 
\texttt{K}, the number of bits of each array element, 
and \texttt{M}, the array's size. We investigate \texttt{K} $\in [1,4]$ and \texttt{M} $\in [1,7]$.
For each instance, the main procedure randomly initializes the array and a value to search, and calls \B. We assume that calls to \texttt{uniform()} diverge if \texttt{left} $>$ \texttt{right}.
Formula \textbf{S.1} is partial correctness from the Introduction. 
Formula \textbf{S.2} is a dual version. 
Formulae \textbf{S.3} and \textbf{S.4} are stack-inspection properties: 
if \B{} is invoked in a state where \texttt{left} $\leq$ \texttt{right}, 
\arr{} is sorted and \texttt{val} occurs in \arr{} (does not, in S.4), 
then there is a recursive call to \B{}. All formulae hold almost surely except S.3: 
if the array has multiple elements, the randomized pivot selection may pick the searched value, terminating the program immediately.
Figure 8 and Table 2 show results for qualitative model checking on all formulae, and quantitative for some parameters of S.3.

\begin{figure}
\begin{minipage}{.6\textwidth}
  \centering
  \includegraphics[width=\textwidth]{figures/output.pdf}
\end{minipage}%
\begin{minipage}{.4\textwidth}
    \centering
    \scriptsize
    \begin{tabular}{c c @{\hspace{.5em}} | @{\hspace{.5em}} r @{\hspace{.5em}} r @{\hspace{.5em}} r }
    \toprule
    &&\multicolumn{3}{c}{Quantitative MC} \\
    \midrule
    K & M & $|f|{_{(\hat{\mathcal{A}})}}$ & $t_\mathit{tot}$ & P\\
    \midrule
          1  &  1  & 154k   & 16    & 1  \\
          1  &  2  & 2 M    & 233  & 0.906  \\
          1  &  3  & 8 M    & 1011  & 0.882  \\
          2  &  1  & 598k   & 74    & 1  \\
           2 &  2  & 15 M   & 1943  & 0.961 \\
           3 &  1  & 2.3 M  & 499  & 1  \\
    \bottomrule
    \end{tabular}
\end{minipage}
    \vspace{-2ex}
    \captionlistentry[table]{Qualitative model checking of all formulae (left) and quantitative model checking}
    \captionsetup{labelformat=andtable}
    \caption{Sherwood binary search: qualitative model checking of all formulae (left, both axis are on logarithmic scale) and quantitative model checking of S.3 for some values of \texttt{K} and \texttt{M} (right). If an instance times out, we do not run greater instances.}
    \label{tab:results-sherwood}
\end{figure}


\begin{table}[bt]
\caption{Experimental results for the computation of termination probabilities.
  $t_{Z3}$ (resp. $t_{OVI}$) is the time required to compute upper bounds with Z3 (OVI).
}
\label{tab:termResults}
\centering
\begin{adjustbox}{max width=\textwidth}
\renewcommand{\arraystretch}{1.1}
\begin{tabular}{l @{\hspace{.5em}} | @{\hspace{.5em}} r @{\hspace{.5em}} r @{\hspace{.5em}} r @{\hspace{.5em}} r @{\hspace{.5em}} | @{\hspace{.5em}} r @{\hspace{.5em}} r @{\hspace{.5em}} | r}
\toprule
name & $|Q_\mathcal{A}|$ &  $|f|_{(\mathcal{A})}$  & $|f_{NT}|{_{(\mathcal{A})}}$ & $|f_{NT}(\text{SCC})|{_\mathit{max}}_{(\mathcal{A})}$ & $t_\mathit{Z3}$ & $t_\mathit{OVI}$ & $t_\mathit{PAST}$ \\
\midrule
Schelling   & 311   & 1230  & 266 & 52 & TO   &  0.03  &  0.03  \\
Tic-tac-toe &  1780 & 3443 & 248 & 36 & 0.02 &  0.01  &  0.08 \\
Virus       &  427  & 21211 & 5962 & 5960 & TO   &   0.38 &  0 \\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}



\begin{table}[bt]
\caption{Qualitative and quantitative MC.
  $t_\mathit{G}$, $t_\mathit{OVI}$ are times spent resp. analyzing the synchronized product and computing with OVI upper bounds for non trivial equations.
}
\label{tab:results}
\centering
\scriptsize
\begin{adjustbox}{max width=\textwidth}
\scriptsize
\begin{tabular}{l c | r r r @{\hspace{.5em}} | r r r r r c }
\toprule
\multicolumn{2}{c}{} & 
\multicolumn{3}{|c|}{Qualitative MC} &
\multicolumn{6}{c}{Quantitative MC} \\
\midrule
name & $\varphi$ & $t_G$ & $t_\mathit{tot}$ & AS & $|f|{_{(\hat{\mathcal{A}})}}$ & $|f_{NT}|{_{(\hat{\mathcal{A}})}}$ & $|f_{NT}(\text{SCC})|{_\mathit{max}}_{(\hat{\mathcal{A}})}$ & $t_\mathit{OVI}$ & $t_\mathit{tot}$ & P\\
\midrule
\parbox[t]{3em}{\centering\multirow{8}{*}{\rotatebox[origin=c]{90}{Schelling}}} &
    Q.1   & 0.02   & 0.15   &  \cmark  & -  & -  & -  & -  & -  &  1\\
&    Q.2  & 26.28  & 26.40  &  \cmark  & -  & -  & -  & -  & -  &  1 \\
&    Q.3  & 1.25   & 1.37   &  \xmark  & 893k  & 62k  &  7.3k  & 33.32 & 101.12  &   $\sim$ 0.895 \\
&    Q.8  & 0.22  & 0.34   &  \xmark  & 214k   & 15k  & 1.4k   & 4.87   & 13.98  &  $\sim$ 0.610 \\
&    Q.9 & 0.04  & 0.16   &  \xmark  & 36k   & 3.2k  & 252 & 1.00  & 1.69  &  $\sim$ 0.610 \\
&    Q.12 & 1.01  & 1.14   &  \xmark  & 651k   & 58k  & 6.7k  & 28.08 & 86.25  & $\sim$ 0.096  \\
&    Q.13 & 0.67  & 0.80   &  \xmark  & 599k   & 39k & 5.7k   & 22.73 & 78.13 & $\sim$ 0.506 \\
%%&    Q.16 & 67.63  & 67.76   &  \xmark  & ?  & ?  & ?   & ?  & ?  & OOM \\
&    Q.15 & 0.95 & 1.07   &  \xmark  & 762k  & 58k  & 7.5k & 44.58 &  120.97 & $\sim$ 0.543 \\

\addlinespace[2pt]
\midrule
\parbox[t]{3em}{\centering\multirow{8}{*}{\rotatebox[origin=c]{90}{Tic-tac-toe}}} &
    Q.1    & 0.12   & 0.28    & \cmark  & -  & -  & - & - & -  &  1\\
&   Q.2    & 122.16  & 122.33  & \cmark  & -  & -  & - & - & -  &  1\\
&   Q.4    & 9.79  & 9.98  & \cmark  & -  & -  & -  & - & - &  1\\
&   Q.5    & 8.22   & 8.41   & \cmark  & -  & -  & -  & - & -  &  1\\
&   Q.10   & 2.94    & 3.10    & \xmark  & 1.1 M & 77k & 3k & 2.79 & 293.16 & $\sim$ 0.712 \\
&   Q.11    & 2.96    & 3.13    & \cmark  & - & -  & -  & - & - &  1 \\
&   Q.14   & 0.54    & 0.71    & \xmark  & 280k & 20k & 1.5k & 0.70 & 20.36 & $\sim$ 0.288  \\
&   Q.16    & 386.10    & 386.22    & \cmark  & -  & -  & - & -  & -  &  1 \\
\addlinespace[2pt]
\midrule
\parbox[t]{3em}{\centering\multirow{4}{*}{\rotatebox[origin=c]{90}{Virus}}} &
    Q.1 & 0.18   & 2.13   & \xmark  & 243k & 24k & 12k & 2.65 & 28.40 & $\sim$ 0.239 \\
&   Q.2 & 263.94 & 265.9  & \cmark  & -  & -   & -  & - & - &  1\\
&   Q.6 & 14.96  & 16.95   & \xmark  & ?  & ?   & ? & ? &  ? & TO  \\
&   Q.7 & 891.45  & 893.37    & \xmark  & ?   & ?  & ? & ? & ? &  TO \\
\bottomrule
\end{tabular}
\end{adjustbox}
\end{table}


\section{Discussion and Future Work}
% aggiungere una frase sul fatto che siamo successful nel buildare la support chain, e che il bottleneck now è il grafo G.
Experimental results show that OVI scales better than Z3 in solving systems for building the support chain. Z3 already times out when provided with a system of 52 equations.
For quantitative model checking, the exponential blow-up on the formula automaton generates in our benchmark hundred of thousands of equations. This suggests that determinization-based approaches, leading to another exponentiation, would not work. 
Finally, our tool scales up to a few million of equations, supporting checking non-trivial formulae on medium-size \acp{pPDA}.


%\begin{itemize}
%    \item we go up to millions of equations 
%    \item OVI is very fast and effectful for computing the support chain
%    \item a single exponential already gives a lot of equations, so doubly exponential would be very bad, this motivates our separation based approach.
%\end{itemize}

As future work, we plan to release Python bindings for our model checking APIs (like Stormpy for Storm \cite{HenselJKQV22}), to enable other tools leveraging \toolname.



%Future work includes using \toolname for exact inference in nested probabilistic programs.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "main"
%%% End:





\clearpage

\section*{Acknowledgements}
We are thankful to Tobias Winkler and Joost-Pieter Katoen (RWTH Aachen)
for the fruitful discussions and for the advice on implementing OVI.

\begin{wrapfigure}{l}{2cm}
\vspace{-4ex}
\includegraphics[width=2cm]{eu_logo}
\vspace{-2ex}
\end{wrapfigure}
This work was partially funded by the Vienna Science and Technology Fund (WWTF)
grant [10.47379/ICT19018] (ProbInG),
and WWTF project ICT22-023 (TAIGER),
and by the EU Commission in the Horizon Europe research and innovation programme
under grant agreements No.\ 101034440 (Marie Sk\l{}odowska-Curie Doctoral Network LogiCS@TU Wien)
and No.\ 101107303 (MSCA Postdoctoral Fellowship CORPORA).


%
%
%
%
% ---- Bibliography ----
%
% BibTeX users should specify bibliography style 'splncs04'.
% References will then be sorted and formatted in the correct style.
%
\bibliographystyle{splncs04}
\bibliography{biblio,prob}

% \clearpage
% \appendix
% \input{appendix}

\end{document}
