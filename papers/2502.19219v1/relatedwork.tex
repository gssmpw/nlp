\section{Related Work}
Current methods for code clone detection are broadly classified into different categories, such as text-based, token-based, tree-based, graph-based, and metric-based tools. 
 These diverse approaches utilize a range of techniques to discern code clones, thereby contributing significantly to the progression of code clone detection.

For text-based clone detection techniques \cite{johnson1994substring, ducasse1999language, roy2008nicad, ragkh2017using, kim2018software, jadon2016code, yu2017detecting, kim2017vuddy}, they compare the similarity of two code snippets by treating the source code as a sequence of lines or strings. 
For instance, Johnson et al. \cite{johnson1994substring} utilize the fingerprint matching method to detect clones, while Ducasse et al. \cite{ducasse1999language} apply string matching methods, treating lines of code as strings to estimate similarity. 
% However, these methods are limited to identifying highly similar code clone.
Similarly, Roy et al. \cite{roy2008nicad} detect potential clones using an algorithm based on the longest common subsequence for matching code text. 
These methods focus solely on string matching and do not consider the logic of the code, making them ineffective in identifying complex Type-3 clones.

For token-based clone detection techniques \cite{gode2009incremental, kamiya2002ccfinder, sajnani2016sourcerercc, li2017cclearner, wang2018ccaligner, golubev2021multi, hung2020cppcd}, they apply lexical analysis to convert the source code into token sequences and then detect code clones by scanning them. 
For example, \emph{CCFinder} \cite{kamiya2002ccfinder} extracts token sequences from program code and utilizes transformation rules to enable the detection of Type-1 and Type-2 clones. 
% \emph{SourcererCC} \cite{sajnani2016sourcerercc} compares tokens overlapping for clone detection.
\emph{CCAligner} \cite{wang2018ccaligner} excels in detecting clones with large gaps by employing innovative electron mismatch indices and asymmetric similarity coefficients. 
Golubev et al. \cite{golubev2021multi} propose a modified token bag-based clone detection technique with a multi-threshold search, optimizing clone detection by reducing overlap and effectively identifying Type-3 clones. 

For tree-based clone detection techniques \cite{jiang2007deckard, wei2017cdlh, zhang2019astnn, liang2021astpath, jo2021twopass, pati2017comparison, chodarev2015haskell, hu2022treecen, wu2022amain}, they parse the program code into a parse tree or abstract syntax tree (AST) and then identify clones by performing tree matching. 
For example, \emph{Deckard} \cite{jiang2007deckard} utilizes locality sensitive hashing (LSH) to detect clones by clustering similar vectors computed from AST of. 
\emph{ASTNN} \cite{zhang2019astnn} segments the AST into subtrees based on predefined rules and encodes each subtree independently using a bidirectional recurrent neural network (RNN) model.
\emph{Amain} \cite{wu2022amain} simplifies complex tree analysis using a Markov chains model for code representation, followed by training a classifier with traditional machine learning algorithms.
% \emph{Treecen} \cite{hu2022treecen} utilizes the tree graph to preserve AST structural details and employ centrality measures to enhance clone detection ability.
% Tree-based approaches excel in detecting complex clones thanks to the detailed syntax information embedded in abstract syntax trees. 
However, they frequently encounter substantial time overhead and scalability challenges, potentially restricting their effectiveness in handling large-scale codebases.

For graph-based clone detection techniques \cite{krinke2001duplix, komondoor2001pdgdup, wang2017ccsharp, zhao2018deepsim, wu2020scdetector, zou2020ccgraph}, they use program dependency graph (PDG) and control flow graph (CFG) to represent the program code. 
For example, Krinke et al. \cite{krinke2001duplix} and Komondoor et al. \cite{komondoor2001pdgdup} utilize subgraph matching for clone detection. 
However, subgraph matching approaches often entail significant time overhead. 
To mitigate this, \emph{CCSharp} \cite{wang2017ccsharp} introduces two strategies for reducing this overhead. 
The first method involves adjusting the graph structure, while the second method entails filtering the feature vectors. 
In \emph{Deepsim} \cite{zhao2018deepsim}, code control flow and data flow are translated into semantic high-dimensional sparse matrices. These matrices are then transformed into binary feature vectors and fed into a deep learning model to evaluate the functional similarity of the code fragments.
% \emph{CCGraph} \cite{zou2020ccgraph} optimizes the PDG size for efficiency and applies numerical feature-based coarse filtering, string similarity-based fine filtering, and graph kernel to detect clone pairs.
However, like tree-based approaches, the graph-based approach faces scalability challenges due to issues with graph isomorphism and graph matching.

% For metric-based methods \cite{mayrand1996experiment, balazinska1999measuring, patenaude1999extending, saini2018oreo, ragkh2018apicture, haque2016generic, sudhamani2016code, svajlenko2017fast, tsunoda2016assessing}, they leverage various properties of the code to measure the similarity between two code fragments. 
% For example, Patenaude et al. \cite{patenaude1999extending} detect clones by considering various classes of metrics, such as classes, couplings, and hierarchies, obtained directly from the source code. 
% \emph{Oreo} \cite{saini2018oreo} showcases the potential of integrating machine learning, information retrieval, and software metrics to achieve high precision and recall in clone detection.

\lida{Text-based and token-based methods offer quick clone detection but lack robustness when names are replaced, limiting their effectiveness in detecting complex code clones. In contrast, graph-based and tree-based methods are adept at identifying complex clones but often require compilation, which can be problematic for small code fragments. Consequently, none of these methods assign weights to differentiate the importance of code lines within a code block, allowing trivial supporting code lines to disproportionately affect the matching results.}