\section{Lattice reduction algorithms}

In this section, we briefly discuss classical methods for lattice reduction. Let $$\Lambda(B)=\left\{\sum_{i=1}^nx_ib_i\mid x_i\in\Z\right\}$$ be a lattice with basis $B=(b_1,\dotsc,b_n)$ for linearly independent vectors $b_i\in\R^d$ for $n\leq d$. Here, we consider the full-dimensional case $n=d$. Such bases are not unique as lattices are invariant under unimodular transformations, i.e., $\Lambda(B)=\Lambda(BU)$ for all $U\in\mathrm{GL}_n(\Z)$ with $\det(U)=\pm1$. In particular, every lattice of dimension $n>1$ has infinitely many bases. We denote the length of a shortest vector of the lattice $\Lambda$ by $\lambda_1(\Lambda)$.

The $\gamma$-SVP problem asks for finding an approximate shortest non-zero vector in the lattice, i.e., a vector $v\in\Lambda\setminus\{0\}$ with $\|v\|\leq\gamma\lambda_1(\Lambda)$, where $\gamma\geq1$ is the approximation factor. Breaking an LWE based cryptosystem requires the ability of finding a shortest vector up to an approximation factor that is linear in the lattice dimension \cite{Peikert16}. 

Classical lattice reduction algorithms such as Lenstra-Lenstra-Lovász (LLL) \cite{LLL82} and Block Korkin-Zolotarev (BKZ) \cite{Schnorr94} and variants thereof can be applied to obtain a basis $B'=(b_1',\dotsc,b_n')$ of relatively short and nearly orthogonal vectors. Here, ``relatively short'' means that the resulting bases are guaranteed to contain a vector of length $\gamma\cdot\lambda_1(\Lambda)$ up to an approximation factor $\gamma\in\R$ \cite{Schneider10}.

The LLL algorithm \cite{LLL82} has a polynomial runtime with respect to the lattice dimension $n$, and is guaranteed to solve $\gamma$-SVP for approximation factors exponential in the lattice dimension $n$: It is parametrized by $\delta\in(1/4,1]$ which appears in the Lovász condition that controls the strictness of the reduction process, i.e. how short and orthogonal the vectors of the reduced basis are. Thereby, it balances the trade-off between computational efficiency and the quality of the reduced basis.
The LLL algorithm produces a basis whose first vector satisfies
$$ \|b_1\|\leq (\delta-1/4)^{\frac{1-n}{2}}\lambda_1(\Lambda) $$
In practice, the LLL algorithm finds much shorter vectors than guaranteed by this worse-case bound \cite{Schnorr94}.

The BKZ algorithm \cite{Schnorr94} combines enumeration based methods with LLL, and is parametrized by the block size parameter $\beta$ and the LLL parameter $\delta$. It produces bases whose first vector satisfies 
$$ \|b_1\|\leq (\gamma_{\beta})^{\frac{n-1}{\beta-1}}\lambda_1(\Lambda) $$
where $\gamma_{\beta}$ is the Hermite constant in dimension $\beta$ \cite{Schnorr94}.
The running time scales exponentially in the bock size $\beta$ for the enumeration step.
Therefore, it offers a trade-off between the running time and the quality of the output basis.


