
\section{+Tour Algorithm}\label{sec:solution}

To solve the MEC-PTIR problem, we propose the next-generation of Touristic services assisted by modern mobile networks (+Tour) algorithm described in Algorithm~\ref{alg:rawpir}. As described in Section~\ref{sec:problem-formulation-first-stage}, the first stage of the MEC-PTIR problem is a multi-objective orienteering problem with two conflicting objectives: maximizing the total collected profit and minimizing the travel cost. This problem belongs to the class of NP-hard problems~\cite{feillet-tsp:05}. To solve this part of the problem optimally and efficiently, +Tour uses a variant of the Shortest Path Problem with Resource Constraints (SPPRC)~\cite{irnich-shortest:05}, summarized in Algorithm~\ref{alg:rptimt-5g_stage1}. The second stage of the MEC-PTIR problem is a Mixed Integer Linear Programming problem, which can be obtained straightforwardly from a linear optimization solver such as Gurobi, IBM ILOG CPLEX, or SCIP~\cite{meindl2012analysis}. In the following, Section~\ref{sec:alg-first-stage} describes how we use the SPPRC variant to solve the MEC-PTIR problem's first stage, while Section~\ref{sec:complexity-analysis} provides a complexity analysis of +Tour.

\begin{algorithm} [!ht]
\label{alg:rawpir}

\caption{The +Tour Algorithm}
\DontPrintSemicolon
\small
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\Input{$G = (\mathcal{V},\mathcal{E})$; $\mathcal{U}_d$, $\alpha$; and $int_{u}(c)$, $b_u$, $\mathcal{A}_{u} \in 2^{\mathcal{A}}$, $\ \forall \ c \in \mathcal{C}, \ \forall \ u \in \mathcal{U}_d$; and $pop(v_{i}), dur(v_{i}), cat(v_{i})$ $\forall v_i \in \mathcal{V} \setminus \{v_{0}, v_{n+1}\}$}
\Output{$\mathcal{I}_*$}
\BlankLine
\BlankLine
 $\mathcal{I} \gets \emptyset$ \\
\ForAll{$u \in \mathcal{U}_d$}
{
    \tcp{Stage 1}
    $\mathcal{I}_{u*} \gets$ $\textbf{Algorithm 2}$ ($G = (\mathcal{V},\mathcal{E})$; $\alpha$;\\ 
    \nonl ($pop(v_{i}), dur(v_{i}), cat(v_{i})$) $\forall v_i \in \mathcal{V} \setminus \{v_{0}, v_{n+1}\}$; \\
    \nonl (($int_{u}(c)$ $\forall c \in \mathcal{C}$), $b_u$)) \\
    $\mathcal{I} \gets$ $\mathcal{I} \cup \mathcal{I}_{u*}$ \\ 
    
}
\tcp{Stage 2}
Find $\mathcal{I}_*$ by solving Stage 2 (MEC-PTIR) using $\mathcal{I}$ as input \\
\Return{$\mathcal{I}_*$}
\end{algorithm}

\subsection{Solution for the first stage} 
\label{sec:alg-first-stage}
The SPPRC finds the shortest path among all paths that start from a source node, end at a destination node, and satisfy a set of constraints defined over a set of resources. In this context, a resource corresponds to a quantity, for example, time or money, which varies along a path according to resource extension functions. A resource extension function is defined for every edge in the graph and every resource involved in the problem. Each function provides a lower bound on its corresponding resource related to the next vertex, given the value accumulated in the present vertex. The resource constraints are given as intervals, also known as resource windows, which limit the values that can be taken by the resources at every vertex along a path. These constraints are defined for every vertex and every considered resource. If multiple resources are involved in the problem, as in the first stage of MEC-PTIR, the SPPRC becomes very close to a multi-criteria problem~\cite{irnich-shortest:05} since the paths may not be comparable for different resources. In this context, by solving the SPPRC, we obtain a set of optimal solutions, i.e., a Pareto front.

Indeed, due to the constraint represented by Equation~(\ref{c:conn_no-rep}), to solve the first stage of the MEC-PTIR, +Tour employs the Elementary SPPRC (ESPPRC), a variant of the SPPRC algorithm that finds only elementary paths, i.e., paths in which no vertex is visited more than once. We use two types of resources: constrained (i.e., time) and unconstrained (i.e., profit). We use a dynamic programming methodology to map the first stage of MEC-PTIR into the ESPPRC framework.\\ 

\noindent\textbf{ESPPRC procedure.} For a given itinerary or path $P = (v_0, v_1, ..., v_{p-1}, v_p)$, let $res(P) = v_p$ be the resident vertex of $P$ (i.e., the last vertex of $P$) and $(v_0, v_1, ..., v_{p-1})$ be an example of prefix path of $P$. For the sake of efficiency, itineraries (or paths) in dynamic programming algorithms are represented through labels. Thus, associated with every itinerary $P$ there is a label $R$. A label stores multiple information, for example, its resident vertex, its predecessor edge, its predecessor label, and its current vector of resource values. For the first stage of MEC-PTIR, two resources are critical to be stored in the labels:
\begin{itemize}
    \item $Spent(R) \in \mathbb{R}$: constrained resource that represents the amount of time spent along the itinerary $P$. Time is consumed whenever the user visits a POI or moves from one POI to another. As described in Section~\ref{sec:model-3}, for every user $u \in \mathcal{U}_d$, the time consumed moving from POI $v_i$ to POI $v_j$ and visiting $v_j$ is represented by Equation~\ref{eq:cost_vi}.
    \item $Profit(R) \in \mathbb{R}$: unconstrained resource that represents the profit of the itinerary $P$. As described in Section~\ref{sec:model-3}, for every user $u \in \mathcal{U}_d$, each POI $v_i \in P$ has a physical profit given by Equation~\ref{eq:prof_vi}.
\end{itemize}

In Algorithm~\ref{alg:rptimt-5g_stage1}, function \code{getLabel} obtains a label from a path while function \code{getPath} obtains a path from a label. Algorithm~\ref{alg:rptimt-5g_stage1} operates over two main sets: $\mathcal{P}$, the set of useful paths, and $\mathcal{Q}$, the set of unprocessed paths, i.e., paths that have not yet been extended. The useful paths $P \in \mathcal{P}$ have already been processed, and they are Pareto-optimal paths or prefixes of Pareto-optimal paths. The set $\mathcal{P}$ is initially empty (line 1), while the set $\mathcal{Q}$ is initiated with the trivial path $(v_0)$ (line 2). In summary, the main loop (line 3) consists of: \textbf{1)} selecting and removing a path $Q \in \mathcal{Q}$ (line 4), \textbf{2)} making all feasible extensions from $Q$ (lines 5-10), \textbf{3)} adding $Q$ to $\mathcal{P}$ (line 11), and \textbf{4)} identifying and removing dominated paths from $\mathcal{P} \cup \mathcal{Q}$ (lines 12-17). The algorithm obtains the set of non-dominated paths (or itineraries) that end in vertex $v_{n+1}$ (line 18), discarding eventual prefixes contained in $P$. 

\begin{algorithm}
\label{alg:rptimt-5g_stage1}

\caption{Dynamic programming ESPPRC -- MEC-PTIR Stage 1}
\DontPrintSemicolon
\small
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}
\Input{$G = (\mathcal{V},\mathcal{E})$; $\alpha$; 
    ($pop(v_{i}), dur(v_{i}), cat(v_{i})$) $\forall v_i \in \mathcal{V} \setminus \{v_{0}, v_{n+1}\}$; ($int_{u}(c)$ $\forall c \in \mathcal{C}$, $b_u$)}
\Output{set $\mathcal{I}_{u*}$ for a user $u \in \mathcal{U}_d$}
\BlankLine
\BlankLine
$\mathcal{P} \gets \emptyset$\\
$\mathcal{Q} \gets \{(v_0)\}$\\
\While{$\mathcal{Q} \neq \emptyset$}
{
    Choose a path $Q \in \mathcal{Q}$ and remove $Q$ from $\mathcal{Q}$\\
    \ForAll{$v_j \in \mathcal{V} \mid (v_j \neq res(Q) \; {\bf and} \; v_j \notin Q)$}
    {
        $R \gets$ getLabel($Q$)\\
        $feasible, R' \gets$ \textbf{Algorithm 3} $(R,v_j,\alpha,pop(v_{j}),dur(v_{j}),int_u(cat(v_j)),b_u)$\\
        \If{$feasible =$ true}
        {
            $Q' \gets$ getPath($R'$)\\
            Add the path $Q'$ to $\mathcal{Q}$
        }
    }
    Add the path $Q$ to $\mathcal{P}$\\
    \ForAll{pair of paths $(P_1,P_2) \in \mathcal{P} \cup \mathcal{Q}$ {\bf and} $res(P_1) = res(P_2)$}
    {
        $R_1 \gets$ getLabel($P_1$)\\
        $R_2 \gets$ getLabel($P_2$)\\
        $dominates \gets$ \textbf{Algorithm 4} ($R_1,R_2$)\\
        \If{$dominates =$ true}
        {
            Remove the path $P_2$
        }
    }
}
Filter $\mathcal{P}$ such that $res(P) = v_{n+1}$ $\forall P \in \mathcal{P}$ \\
\Return $\mathcal{P}$
\end{algorithm}
%Filter $\mathcal{P}$, such that $\forall P \in \mathcal{P} \mid res(P) = v_f^{u}$

Let $\Xi$ be the set of all solutions of the ESPPRC, where each element $\mathcal{X} \in \Xi$ is a set of Pareto-optimal paths, such that:
\setcounter{equation}{22}
\begin{equation}
\label{eq:extension_invariant}
	\exists \mathcal{X} \in \Xi \mid \mathcal{X} \subseteq \{ (Q,P) \mid Q \in \mathcal{Q}, P \in \mathcal{Z}(Q) \} \cup \mathcal{P},
\end{equation}

\noindent where $\mathcal{Z}(Q) = \{P \mid (Q,P) \in \mathcal{F}(v_i,v_j)) \cap \mathcal{G}\}$ represents the set of all feasible extensions. The set $\mathcal{F}(v_i,v_j)$ has all resource-feasible paths from vertex $v_i$ to vertex $v_j$. 

The condition described by Equation (\ref{eq:extension_invariant}) is held for the initialization of Algorithm~\ref{alg:rptimt-5g_stage1} (lines 1-2), since $v_i = v_0$ and $v_j = res(P) = \emptyset$. For every vertex $v_j \in \mathcal{V}$ (line 5), the condition described by Equation (\ref{eq:extension_invariant}) is verified (line 8) before adding the extended path $Q'$ to $\mathcal{Q}$ (line 10). This depends on Algorithm~\ref{alg:extension} (called in line 7) described latter in this section. In addition, to be efficient, Algorithm~\ref{alg:rptimt-5g_stage1} must avoid making extensions over dominated prefix paths, i.e., paths not part of the Pareto front. Thus, after processing every path $Q \in \mathcal{Q}$ (lines 4-11), the algorithm takes every pair of paths $(P_1,P_2) \in \mathcal{P} \cup \mathcal{Q}$ where $res(P_1) = res(P_2)$ (line 12), verifies if $P_1$ dominates $P_2$ (line 16) and, if this is true, removes the path $P_2$ (line 17). This procedure depends on Algorithm~\ref{alg:dominance} (called in line 15) described latter in this section.

\noindent\textbf{Extension procedure.} The goal of Algorithm~\ref{alg:extension} is to verify if path $P$ (described by label $R$) can be extended to vertex $v_j$. After identifying the path $P$ associated with label $R$ (line 1) and the resident vertex $v_i = res(P)$ of this path (line 2), the algorithm includes into label $R'$ (associated with the extended path $P'$) the information about the time consumed for traveling from $v_i$ to $v_j$ and for visiting the vertex (or POI) $v_j$ (lines 3-4). The algorithm also includes into label $R'$ the information about the profit of the path $P'$ (line 5). Finally, the algorithm verifies if the constrained resource $Spend(R')$ is inside its resource window (line 6), which can be seen as the interval $[ 0, b_u - Cost_{u}(v_i,v_j) ]$. The algorithm returns \textbf{true}, if the extension is feasible (line 7), or \textbf{false} (line 9), otherwise.

\begin{algorithm}
\label{alg:extension}

\caption{Extension procedure}
\DontPrintSemicolon
\small
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\Input{\textbf{R} (label), \textbf{$v_j$} (vertex for path extension),\\
        $\alpha$, $pop(v_{j})$, $dur(v_{j})$, $int_u(cat(v_j))$, $b_u$}
\Output{\textbf{true} or \textbf{false} to indicate the feasibility or not of the extension, \textbf{R'} (label of the path extension)}
\BlankLine
\BlankLine
$P \gets$ getPath($R$)\\
$v_i \gets res(P)$\\
\If{$v_j=v_{n+1}$}
{
    $Cost_{u}(v_i,v_j) \gets 0$\\
}
\Else
{
$Cost_{u}(v_i,v_j) \gets c_{i,j} + dur(v_{j})int_u(cat(v_j))$\\
}
$Spent(R') \gets Spent(R) + Cost_{u}(v_i,v_j)$\\
$Profit(R') \gets Profit(R) + Prof_u(v_j)$\\

\If{$Spent(R') \leq b_u$}
{
    \Return{(\textbf{true},R')}
}
\Else
{
    \Return{(\textbf{false},R')}
}
\end{algorithm}

\noindent\textbf{Dominance procedure.} In general terms, dominance rules identify non-useful paths by comparing the resource vector $T(Q)$ and the set of all feasible extensions $\mathcal{Z}(Q)$ with the corresponding $T(P)$ and $\mathcal{Z}(P)$, such that $res(P) = res(Q)$. In the context of the first stage of MEC-PTIR, as described by Algorithm~\ref{alg:dominance}, this comparison consists of verifying if label $R_1$ (corresponding to path $P_1$) provides a higher or equal profit and consumes less or equal time than label $R_2$ (that corresponds to path $P_2$) (line 1). The algorithm returns \textbf{true} if the condition is satisfied (line 2) or \textbf{false} (line 4), otherwise. When the condition is true, path $P_2$  must be removed since it was identified as equal to or worse than $P_1$.

\begin{algorithm}
\label{alg:dominance}

\caption{Dominance procedure}
\DontPrintSemicolon
\small
\SetKwInOut{Input}{Input}
\SetKwInOut{Output}{Output}

\Input{$\mathbf{R_1}$ (label), $\mathbf{R_2}$ (label)}
\Output{\textbf{true} if $\mathbf{R_1}$ dominates $\mathbf{R_2}$, \textbf{false} otherwise}
\BlankLine
\BlankLine
\If{$Profit(R_1) \geq Profit(R_2)$ \textbf{and} $Spent(R_1) \leq Spent(R_2)$ }
{
    \Return{\textbf{true}}
}
\Else
{
    \Return{\textbf{false}}
}
\end{algorithm}

\subsection{Complexity Analysis of +Tour Algorithm}
\label{sec:complexity-analysis}
In this Section, we analyze the complexity of +Tour, represented by Algorithm~\ref{alg:rawpir}, which is composed of Algorithm~\ref{alg:rptimt-5g_stage1} ($A_2$), Algorithm~\ref{alg:extension} ($A_3$), Algorithm~\ref{alg:dominance} ($A_4$), and Stage 2 ($S_2$). In the worst case, the complexity of Algorithm~\ref{alg:rawpir}  is $\mathcal{O}\big(|\mathcal{U}_d| \mathcal{O}(A_2)\big) + \mathcal{O}(S_2)$, i.e., the iteration through all users in $\mathcal{U}_d$ (line 2) times the complexity of Algorithm~\ref{alg:rptimt-5g_stage1} (line 3), plus the complexity of Stage 2 (line 5). The complexity of Algorithm~\ref{alg:rptimt-5g_stage1} is $\mathcal{O} \Big(|\mathcal{Q}| \big( |\mathcal{V}|\mathcal{O}(A_3) + \frac{|\mathcal{P} \cup \mathcal{Q}|  (|\mathcal{P} \cup \mathcal{Q}| - 1)}{2}\mathcal{O}(A_4)\big)\Big) + \mathcal{O}(|\mathcal{P}|)$, i.e., the iteration through all paths in $\mathcal{Q}$ (line 3), times the iteration through all POIs in $\mathcal{V}$ (line 5) times the complexity of Algorithm~\ref{alg:extension} (line 7), plus the combination of path pairs in $\mathcal{P} \cup \mathcal{Q}$ (line 12) times the complexity of Algorithm~\ref{alg:dominance} (line 15), plus the iteration through the paths in $\mathcal{P}$ (line 18). In line 12, since $\mathcal{P} \cap \mathcal{Q} = \emptyset$, in the worst case,  $|\mathcal{P}|$, $|\mathcal{Q}|$ and $|\mathcal{P} \cup \mathcal{Q}|$ are all equal to $\sum_{k=1}^n \frac{n!}{(n-k)!}$ where $n = |\mathcal{V}|$ and $k$ represent the number of extensions. Finally, Algorithms~\ref{alg:extension} and~\ref{alg:dominance} are constant, i.e., their complexity is $\mathcal{O}(1)$.