\subsection{Area Evaluation}
\input{tab-area-result}

\BF{Methodology --}
We use a post-synthesis component-level area modeling methodology to evaluate
area overheads of hardware added to a baseline 16$\times$16 systolic array for
SparseZipper.
We implement area-significant components of the systolic array in RTL and
synthesize them using a 12nm standard-cell library.
Each PE includes a 32-bit single-precision floating-point MAC unit.
We model control logic added to a PE to support for the stream sorting and
merging operations.
Each skew/deskew buffer is used to stagger input and output data coming in and
going out of the systolic array.
We model each skew/deskew buffer as an array of 16 shift registers using
flip-flops with their sizes ranging from one to 16 entries.
We model 16 rows, each is 512-bit wide (16$\times$ 32-bit data elements), in a
SRAM-based matrix register and a total of 16 physical matrix registers.
Regarding the popcount logic, we implemented an array of 16 five-bit counters
(counting up to 16) and a list of counter vector registers (16 $\times$ 5 bits
per register).

\BF{Area overheads of SparseZipper --}
Table~\ref{tab-spz-area-result} shows the detailed area comparison between
SparseZipper and the baseline using our first-order component-based area
modeling methodology.
In overall, a 16$\times$16 SparseZipper implementation adds around 12.72\% area
overhead compared to the baseline implementation with the same systolic array's
dimensions.
When considering a complete system including an out-of-order core, its vector
engine, and its caches, we expect the percentage of extra area added to the
baseline systolic array for supporting SparseZipper to be much lower.
