%=========================================================================
% SparseZipper: ISA extension
%=========================================================================

\section{S\lowercase{parse}Z\lowercase{ipper} Instruction Set Extension}
\label{sec-spz-isa}

In this section, we first describe a merge-based implementation of the
row-wise-product SpGEMM algorithm to motivate key designs in our SparseZipper
ISA extension.
We then present details of SparseZipper abstraction.

\input{fig-stream-merge-tree}
\input{fig-stream-merging-steps}

%----------
%----------
% Motivate the proposed instruction by showing how key-value streams are merged
% together in a merge tree (slightly modified merge sort algorithm)
\subsection{Merge-Based Row-Wise-Product SpGEMM}
\label{sec-spz-isa-merge-spgemm}

Figure~\ref{fig-spz-stream-merge-tree} shows an example of the row-wise-product
dataflow in multiplying two sparse matrices.
Partial results for an \IT{i-th} row in the output matrix are generated by
multiplying each non-zero element \TT{A[i][j]} in the first matrix with all
non-zero elements \TT{B[j][k]} in a \IT{j-th} row of the second matrix.
After generating partial results, for each row of the output matrix, we get
a list of tuples, each consisting of a column index (key) and a value.
To generate an output row, this list, which is called a key-value stream, is
then sorted by keys, and tuples with duplicate keys are accumulated.
The final sorted stream of unique key-value tuples represents non-zeros in the
\IT{i-th} row of the output matrix.

Merging partial tuples into the final list can be done in multiple steps.
The expanded list is split into equally sized partitions.
Tuples in each partition are then sorted by their keys.
Finally, adjacent partitions are merged together in multiple reduction steps to
form a final sorted streams of tuples, as shown in
Figure~\ref{fig-spz-stream-merge-tree}.
This merging procedure is similar to the conventional merge sort algorithm
except that tuples with duplicate keys are accumulated.

In order to merge two long sorted partitions of key-value tuples, we break them
in chunks fitting in registers (e.g., vector registers) and repeatedly merge
two N-element chunks (i.e., one from each tuple) at a time as shown in
Figure~\ref{fig-spz-stream-merging-steps}.
It is important to note that we may not be able to move all N tuples from each
partition in one step.
For example, in the first two chunks (in
Figure~\ref{fig-spz-stream-merging-steps}), three tuples (4, 1), (6, 7), and
(8, 3) from the second partition cannot be moved to the output partition since
their keys are greater than every key from the current chunk in the first
partition.
Instead, those tuples need to be merged in the next step.
Therefore, the number of tuples that we can advance at the end of a step in
each partition is data-dependent.

%----------
%----------
\subsection{Architectural States}
\label{sec-spz-isa-arch-states}
\input{fig-stream-mtx-register-mapping}

SparseZipper leverages both vector and matrix registers in the base vector and
matrix ISAs to store key-value streams and their metadata.
Without the loss of generality, in this work, we use the RISC-V vector
extension~\cite{riscv-vector-ext} as the base vector ISA and a baseline matrix
ISA inspired by Intel AMX~\cite{intel-amx-web} and the RISC-V matrix extension
proposal~\cite{riscv-mtx-ext-proposal-web}.

\BF{Matrix registers --}
The base matrix ISA supports eight general-purpose two-dimensional matrix
registers (tile registers) named from \TT{TR0} to \TT{TR7}.
The length in bits for a row in a matrix register is the same as the number of
bits in a single vector register (\TT{VLEN}) as defined in the RISC-V vector
extension.
In this work, we limit the size in bits of each element (i.e., \TT{ELEN}) in a
vector register to 32 bits to simplify our description of SparseZipper.
A complete matrix instruction set may support other element bit widths such as
16 and 64 bits.
There are $R = VLEN / ELEN$ elements in a row of a matrix register.
We assume that each matrix register has the same number of rows as the number
of elements in a row.
%Therefore, the total number of elements in a matrix register is $R^2$.

\BF{Mapping streams to matrix and vector registers --}
SparseZipper enables processing multiple key-value streams by mapping them to
different rows of a matrix register.
Figure~\ref{fig-spz-stream-mtx-reg-mapping} shows an example of this
stream-register mapping.
Matrix registers \TT{TR0} and \TT{TR1} store keys and values respectively.
Each row of a matrix register is mapped to a stream, and it stores a chunk of
keys or values in the stream.
SparseZipper uses existing vector registers to store metadata about a current
set of streams (e.g., vector register \TT{V0} in
Figure~\ref{fig-spz-stream-mtx-reg-mapping} stores the number of tuples in each
stream).

\BF{Special-purpose counter vector registers --}
SparseZipper introduces a set of four light-weight special-purpose counter
vector registers.
\TT{IC0} and \TT{IC1} are used for counting processed elements per input matrix
row.
\TT{OC0} and \TT{OC1} are used for counting output elements per output matrix
row.
More details regarding the use of those registers are specified in the
following instruction set specification.
Since each counter in a counter vector register counts up to the max number of
elements (i.e., \TT{R}) in a row of a matrix register, each counter is
$\log_2R$-bit wide.  Therefore, each counter vector register has $R \times
\log_2 R$ bits in total.

%----------
%----------
\subsection{Instruction Set Specification}
\input{tab-matrix-insts}
%\input{fig-mtx-base-insts}

Table~\ref{tab-spz-mtx-insts} shows a list of SparseZipper instructions
including (1) indexed matrix load and store, (2) stream sorting, (3) stream
merging, and (4) counter vector move instructions.

\BF{Indexed matrix load and store instructions --}
SparseZipper introduces two memory instructions: \TT{mlxe.t} and \TT{msxe.t} to
move key-value chunks from multiple streams between matrix registers and
memory.
Multiple key-value streams may have different lengths, and their chunks are
located at arbitrary locations.
Therefore, in addition to the base address (\TT{rs1}) and matrix register
(\TT{td1}), \TT{mlxe.t} and \TT{msxe.t} take two vector operands: \TT{vs2}
specifying memory locations (i.e., byte offsets to a base address) and \TT{vs3}
holding stream lengths.

%\input{fig-mtx-indexed-ld-st-insts}
%\input{fig-mtx-mssortk-inst}
%\input{fig-mtx-mssortv-inst}
%\input{fig-mtx-mszipk-inst}
%\input{fig-mtx-mszipv-inst}
%\input{fig-mtx-mv-insts}

\BF{Stream sorting instructions --}
SparseZipper introduces two instructions called \TT{mssortk.tt} and
\TT{mssortv.tt} to sort multiple chunks of key-value tuples by keys.
The two instructions work together by first sorting keys and then shuffling
values based on the key reordering.
Duplicate keys are combined, and their corresponding values are accumulated.
In order to transfer the key reordering information between \TT{mssortk.tt} and
\TT{mssortv.tt} instructions, SparseZipper adds an abstract special-purpose
architectural state that captures how input keys are reordered per key-value
chunk.
This state is intentionally left abstract in the ISA specification so that a
micro-architecture can freely choose how to implement it.
Section~\ref{sec-spz-uarch} later discusses an implementation of this state
using a systolic array.
Since an output chunk may be shorter than its input chunk (i.e., due to
duplicate keys), \TT{mssortk.tt} updates the special-purpose output counter
vector registers (\TT{OC0} and \TT{OC1}) with the lengths of output chunks.

\BF{Stream merging instructions --}
SparseZipper provides two instructions called \TT{mszipk.tt} and \TT{mszipv.tt}
to merge sorted key-value partitions of a stream.
Similar to \TT{mssortk.tt} and \TT{mssortv.tt}, the two stream merging
instructions work together by first merging keys and then shuffling values.
Duplicate keys are combined, and their corresponding values are accumulated.
The key reordering is also captured by an abstract special-purpose
architectural state that is produced by \TT{mszipk.tt} and then used by
\TT{mszipv.tt} to shuffle and accumulate values.
Instruction \TT{mszipk.tt} updates input counter vector registers (\TT{IC0} and
\TT{IC1}) with the number of tuples that have been merged per input partition.
The output counter vector registers (\TT{OC0} and \TT{OC1}) are updated with
the number of elements per merged output partition.

\BF{Counter vector move instructions --}
SparseZipper provides two move instructions \TT{mmv.vi} and \TT{mmv.vo} that
copy values from special-purpose input and output counter vector registers
respectively into general-purpose vector registers.
These values are typically used to update pointers and stream lengths through
vector instructions.

%----------
%----------
\subsection{Code Examples}

\input{fig-code-example}
%\input{fig-mssort-code}
%\input{fig-mszip-code}

%In this section, we show how to use the new SparseZipper instructions to sort
%and merge key-value chunks from multiple streams.

\BF{Sorting key-value chunks --}
Figure~\ref{fig-spz-mssort-code} shows a \mbox{RISC-V} assembly code snippet of
sorting key-value chunks from VLEN number of streams.
Keys and values of current chunks are loaded into matrix registers using
\TT{mlxe.tt} in lines 8-11.
Register \TT{tr0} and \TT{tr2} hold input keys while register \TT{tr1} and
\TT{tr3} store corresponding input values.
In line 13, \TT{mssortk.tt} sorts per-chunk keys in an ascending order and
writes the sorted keys in the same matrix registers (\TT{tr0} and \TT{tr2}).
In line 14, \TT{mssortv.tt} shuffles and accumulates values based on the
reordering of keys.
Lines 16-17 move lengths of output chunks from the special-purpose output
counter vectors into general-purpose vector registers for updating the lengths
of output streams.
Finally, keys and values in output chunks are written back to memory in lines
19-22.

\BF{Merging key-value chunks --}
Figure~\ref{fig-spz-mszip-code} shows a RISC-V assembly code snippet of merging
key-value chunks from adjacent partitions across VLEN number of streams.
Similar to the sorting code, keys and values of current chunks are loaded into
matrix registers using \TT{mlxe.tt} in lines 8-11, and register \TT{tr0} and
\TT{tr2} hold input keys while register \TT{tr1} and \TT{tr3} store
corresponding input values.
In lines 13-14, \TT{mszipk.tt} merges pairs of key-value chunks across VLEN
streams, and \TT{mszipv.tt} shuffles corresponding values based on the key
reordering.
Duplicate keys are combined, and their values are accumulated.
Merged and sorted output keys are stored in the same \TT{tr0} and then \TT{tr1}
in an ascending order.
Lines 16-17 move per-input-chunk numbers of merged keys from special-purpose
counter registers \TT{IC0} and \TT{IC1} into general-purpose vector registers
for updating input pointers.
Lines 19-20 extract lengths of output chunks from counter vector registers
\TT{OC0} and \TT{OC1}.
In lines 22-27, merged keys and values are written back to memory per output
streams using \TT{msxe.t}.
