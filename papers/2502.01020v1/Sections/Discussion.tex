In this section, we discuss the implications of RiskHarvester based on our study findings.

\textbf{Only the asset identifier is not enough to aid developers in prioritizing the software secret removal.} Basak et al.~\cite{assetharvester} constructed AssetHarvester for detecting the corresponding asset identifier by the secret. From our developer survey, we observed that 73\% of developers changed their priority based on asset identifiers, and 10\% of developers were unsure of their decision and wanted more asset context. However, when we provided the security risk scores with the value of asset and ease of attack information, 86\% of the developers changed their priority in the descending order of security risk score. In addition, developers pointed out that the value of asset and ease of attack information helped them to make informed decisions to tackle the secret removal efforts.


\textbf{The risk-based analysis for secrets should be integrated into the secret detection tools.} We developed RiskHarvester to automatically calculate the security risk for the checked-in secrets. Our approach eliminates the need for developers to manually analyze each secret detection tool alert and calculate the security risk. To integrate our approach, the input for RiskHarvester will be the repository source code, and RiskHarvester will output the secrets ranked by descending security risk score. Thus, developers can focus their mitigation efforts on the most critical security risks. 


\textbf{RiskHarvester can be extended to calculate the security risk score of secrets in other programming languages and secret types.} In our study, we calculated the security risk score of four database providers in Python. We now discuss the effort needed and challenges to extend RiskHarvester for other programming languages and secret types.

\uline{Programming Language}: We identified the secret-asset pairs using pattern matching, data flow analysis, and fast-approximation heuristics. We parsed the database names from the identified asset identifiers. Since pattern matching and fast-approximation heuristics are programming-language agnostic, we can apply the techniques in other programming languages without additional effort. Additionally, we leveraged data flow analysis to detect the secret-asset pair instance that flows into query functions and then extracted database keywords from raw SQL and ORM classes (Step 2.1). Though data flow analysis is programming language dependent, we can compute the abstract syntax tree, control flow, and data flow graph for each programming language in a repository separately using CodeQL. Next, we can identify the secret-asset pair sources and sinks from the computed graphs with minimal effort. Additionally, SQL parsing is programming-language agnostic, enabling the parsing of database keywords in other languages.

\uline{Non-database Secret Types}: From SecretBench~\cite{secretbench}, we inspected five random samples of secrets of seven secret types, such as API keys, private keys, and authentication tokens. We now discuss extending RiskHarvester to identify non-database secret-asset pairs and corresponding asset keywords.

\textbf{1. Secret-Asset Pairs}: The 2024 GitGuardian report~\cite{gitguardian-secret-sprawl} reveals that cloud secrets such as API keys and tokens are the second most exposed in GitHub. Since cloud providers have specific formats, we can identify the secret-asset pair using the regex (Step 1.1). Additionally, we can identify the functions of frameworks such as .NET and Spring, where the secret-asset pairs are passed similarly to database drivers and employ data flow analysis (Step 1.2). The list of functions will not be huge since most non-database secret-asset pairs are passed in HTTP clients such as \texttt{get} and \texttt{post} functions. %Additionally, driven by the rising use of LLMs, GitGuardian found a 1212-fold increase in leaked OpenAI API keys since 2022~\cite{gitguardian-secret-sprawl}. For future work, we will focus on extending RiskHarvester to detect the security risk score of cloud secrets.

\textbf{2. Non-Database Keywords}: We inferred the asset's value from raw SQL and ORM parsing for database secrets. However, for non-database secrets, we can infer the data category from the request body and response of HTTP requests that use the secret-asset pair. Thus, using data flow analysis (Step 2), we can identify the request body (sinks) and parse the request body parameters (sources) to infer the data categories. However, the responses of HTTP requests (typically in JSON or XML format) are serialized into classes. Thus, we can employ data flow analysis to detect the response class and identify the data categories from the class attributes. In our study, we used the \texttt{py-models-parser}~\cite{py-models-parser} package to parse ORM models (Step 2.1), which also supports parsing any data class.

% The list of regex and sinks of data flow analysis for RiskHarvester is configurable, requiring minimal source code change to detect non-database secret-asset pairs and the corresponding value of asset and ease of attack. Despite the manual effort needed to identify the regex and sinks from documentation, we can automate the process in the future by mining the vendor documentation. We can use the knowledge gained from the manual analysis of our study and generate LLM prompts to identify the regex and sinks from the documentation. 


\textbf{The security risk score can be improved by employing active network analysis in RiskHarvester.} Our study focused on passive network information for estimating the ease of attack. However, developers wanted the deployment-related security information, such as the level of security controls present on the asset and network vulnerabilities (Section~\ref{DeveloperSurvey}). We will extend RiskHarvester by leveraging the information provided by the active network scanning and vulnerability assessment tools such as Nessus~\cite{nessus} and Nmap~\cite{nmap}. Additionally, we will improve the value of asset by retrieving the metadata information of a database, such as whether the data is encrypted or hashed, using database auditing tools such as Datadog~\cite{datadog}. We will deploy RiskHarvester in the organization where these scanning and auditing tools are deployed.
