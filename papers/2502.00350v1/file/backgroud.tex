
\subsection{Fault Localization Algorithms and Systems}
Fault localization (FL) aims to identify suspicious locations (e.g., statements or methods) in source code that are associated with bugs. Prior to the advent of LLMs, fault localization had been extensively studied, with techniques such as spectrum-based fault localization (SBFL) \citep{jones2005empirical}, mutation-based fault localization (MBFL) \citep{papadakis2015metallaxis}, and learning-based approaches like FLUCCS \citep{sohn2017fluccs}, DeepFL \citep{li2019deepfl}, and TRANSFER \citep{meng2022improving}. However, effective fault localization in large-scale software systems remains challenging due to the vast size of codebases and the overwhelming volume of error messages, which often exceed the capabilities of standalone learning models.

Since the advanced code and natural language understanding capabilities of LLMs, Recent studies \citep{yang2024large,wu2023large,li2024enhancing,hossain2024deep,kang2023preliminary,qin2024agentfl,wang2024rcagent} have proposed LLM-based FL methods. These methods incorporate agents and tools to address the challenges of large-scale systems. AUTOFL \citep{kang2023preliminary} enhances standalone LLMs with tool invocations, such as repository retrieval tools, for more effective exploration of code repositories. RCAgent \citep{wang2024rcagent} integrates four tools (code analysis, log analysis, memory retrieval, and information collection) to support decision-making. AgentFL \citep{qin2024agentfl} scales LLM-based fault localization to project-level contexts by combining multiple agents with static analysis tools like Tree-sitter.

However, effectively and robustly exploring the codebase while balancing the trade-off between context granularity and search space remains a significant challenge. In contrast to existing techniques, \nickname introduces a dynamic action scheduling exploration system and mechanisms to score decomposed actions, addressing these limitations effectively.

\subsection{LLM-Agent for Software Engineering}
LLMs have recently demonstrated remarkable capabilities in achieving human-level performance across a wide range of tasks, significantly advancing the field of ASE. Unlike traditional function-level or file-level coding tasks like Humaneval\cite{chen2021evaluating}, ASE requires not only basic coding proficiency but also advanced skills in managing and interacting with code repositories. To solve such more complex tasks, LLM-based agents enhance project-level software engineering tasks by iteratively and autonomously performing actions, observing feedback, and planning future steps \citep{hong2023metagpt,kong2024contrastrepair,wang2024executable,yang2024swe,xia2024agentless,ouyang2024repograph,zhang2024autocoderover}. 

OpenHands \citep{wang2024openhands} is a community-driven platform integrating widely used agent systems to explore end-to-end LLM-based agent solutions for handling complex SE tasks. 
AutoCodeRover \citep{zhang2024autocoderover} introduces LLM agents with specialized code search methods to iteratively retrieve code context and locate bugs using test cases.
Agentless \citep{xia2024agentless} proposes a two-stage bug-fixing system based on a streamlined workflow approach.
Repounderstander \citep{ma2024understand} empowers agents to comprehensively understand the whole repositories by a code knowledge graph for repositories and a Monte Carlo tree search-based repository exploration strategy.

However, existing approaches remain limited as their search processes rely entirely on the LLM to manage and guide actions, often resulting in unstable and ineffective search performance. Meanwhile, current systems, such as \cite{autocoderover,xia2024agentless}, directly incorporate all search results as context, which is inefficient and can mislead the LLM. In contrast, \nickname employs a Priority-Based Action Scheduling System for LLM-guided actions and a Distance-Aware Context Pruning mechanism, significantly improving both efficiency and robustness.