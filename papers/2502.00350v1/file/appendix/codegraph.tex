\subsection{Graph Construction Process}
The \textbf{CodeGraph} represents the structural and semantic relationships within a codebase by integrating \textit{containment} and \textit{reference} relationships. It is constructed using \textbf{Abstract Syntax Tree (AST)} analysis and additional \textbf{directory-based} hierarchical relationships.

\subsection{Containment Graph Construction}
The \textbf{containment graph} models the \textit{lexical and structural hierarchy} of the codebase. We extract entities by analyzing each file in the repository using AST, identifying: \textbf{Classes}: \( v^{\text{class}} \), \textbf{Functions}: \( v^{\text{function}} \), \textbf{Methods}: \( v^{\text{method}} \)
, \textbf{files}: \( v^{\text{file}} \)

A \textbf{containment edge} \( e_1 \) is added to represent hierarchical relationships:
$
    v^{\text{method}} \to v^{\text{class}} \in e_1, \quad v^{\text{function}} \to v^{\text{file}} \in e_1
$

Although directories are not code entities, we explicitly include them in the \textbf{CodeGraph} to \textit{preserve structural context}. The directory structure is modeled as follows:

\begin{itemize}
    \item Files within the same directory are connected via containment edges.
    \item A directory node is linked to its subdirectories.
    \item The \textbf{root directory} (\texttt{"."}) connects to all 1-depth subdirectories and files, forming the top-level hierarchy:
\end{itemize}
This could be summarized as a formula
$v^{\text{file}} \to v^{\text{directory}} \in e_1, \quad 
    v^{\text{directory}} \to v^{\text{subdirectory}} \in e_1, \quad 
    v^{\text{directory}} \to v^{\text{root}} \in e_1$, which ensures that \textit{file relationships and directory nesting} are explicitly represented in the \textbf{CodeGraph}.

\subsection{Reference Graph Construction}
The \textbf{reference graph} captures execution dependencies between code entities, including function calls, variable references, and module imports. Using function call analysis from the AST, we add \textbf{reference edges}: $v^{\text{caller}} \to v^{\text{callee}} \in e_2$, where \( e_2 \) represents a \textbf{function call}. We didn't use static analysis to get references like the method A used in another function B, which we think is a future direction for better ASE. 

\subsection{Heterogeneous Graph Representation}
Our \textbf{CodeGraph} is a heterogeneous graph, integrating both containment relationships (\( e_1 \)) and reference relationships (\( e_2 \)). We efficiently apply Depth First Search (DFS) for code entity search during the agent exploration. 




