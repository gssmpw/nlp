
% Begin of file 1-Introduction.tex

\section{Introduction}

Driven by the unprecedented growth of interconnected data, \emph{graph-based
data representations} have emerged as an expressive and versatile framework for
modelling and analysing connections in data sets~\cite{SakrBVIAAAABBDV21}.
This rapid growth however, has led to a proliferation of diverse approaches,
each with its own identity and perspective.

The two most prominent graph data models are \emph{RDF} (Resource Description
Framework)~\cite{CWL14} and \emph{Property Graphs}~\cite{BFVY23}.
In RDF, data is modelled as a collection of triples, each consisting of a
subject, predicate, and object.
Such triples naturally represent either edges in a directed labelled graph
(where the predicates represent relationships between nodes), or
attributes-value pairs of nodes.
That is, objects can both be entities or atomic (literal) values.
In contrast, Property Graphs model data as nodes and edges, where both can have
labels and records attached, allowing for a flexible representation of
attributes directly on the entities and relationships.

Similarly to the different data models, we are also seeing different approaches
towards \emph{schema languages} for graph-structured data.
Traditionally, in the Semantic Web community, schema and constraint languages
have been \emph{descriptive}, focusing on flexibility to accommodate varying
structures.
However, there has been a growing need for more \emph{prescriptive} schemas
that focus on \emph{validation of data}.
At the same time, in the Database community, schemas have traditionally been
prescriptive but, since the rise of semi-structured data, the demand for
descriptive schemas has been growing.
Thus, the philosophies of schemas in the two communities have been growing
closer together.

For RDF, there are two main schema languages: SHACL (Shapes Constraint
Language)~\cite{KK17}, which is also a W3C recommendation, and ShEx (Shape
Expressions)~\cite{PGS14}.
In the realm of Property Graphs, the current main approach is
PG-Schema~\cite{ABDF23,ABDF21}; it was developed with liaisons to the GQL and SQL/PGQ standardization committees and is currently being used as a basis for extending these standards.
%, since it is being used as a basis by the GQL and SQL/PGQ ISO committees.}
The development processes of these languages have been quite different.
For SHACL and ShEx, the formal semantics were only introduced after their
initial implementations, echoing the evolution of programming languages.
Indeed, an analysis of SHACL's expressive power and associated decision problems
appeared in the literature~\cite{LSRLS20,PKMN20,PK21,BJB22,PKM22,BJVdB24} only
after it was published as a W3C recommendation, leading up to a fully
\emph{recursive variant} of the
language~\cite{CRS18,CFRS19,ACORSS20,BJ21,PKM22}, whose semantics had been left
undefined in the standard.
%
A similar scenario occurred with ShEx, where formal analyses were only conducted
in later phases~\cite{BGP17,SBG15}.
%
PG-Schema developed in the opposite direction.
Here, a group of experts from industry and academia first defined the main ideas
in a sequence of research papers~\cite{ABDF21,ABDF23} and the implementation is
expected to follow.

Since these three languages have been developed in different communities, in the
course of different processes, it is no surprise that they are quite different.
SHACL, ShEx, and PG-Schema use an array of diverse approaches for defining how
their components work, ranging from \emph{declarative} (formulae that
\emph{specify what to look for}) to \emph{generative} (expressions that
\emph{generate the matching content}), and even combinations thereof.
The bottom line is that we are left with three approaches to express a ``schema
for graph-structured data'' that are very different at first glance.

As a group of authors coming from both the Semantic Web and Database
communities, we believe that there is a \emph{need for common understanding}.
While the functionalities of schemas and constraints used in the two communities
largely overlap, it is a daunting task to understand the essence of languages,
such as SHACL, ShEx, and PG-Schema.
In this paper, we therefore aim to shed light on the common aspects and the
differences between these three languages.
We focus on non-recursive schemas, as neither PG-Schema nor
standard SHACL support recursion and also in the academic community the
discussion on the semantics of recursive SHACL has not reached consensus
yet~\cite{CRS18,CFRS19,ACORSS20,BJ21,PKM22,OS24}.

Using a common framework, we provide crisp definitions of the main aspects of
the languages.
Since the languages operate on different data models, as a first step we
introduce the \emph{Common Graph Data Model}, a mathematical representation of
data that \emph{canonically embeds} both RDF graphs and Property Graphs (see
Section~\ref{sec:prl}, which also develops general common foundations).
Precise abstractions of the languages themselves are presented in
Sections~\ref{sec:shacl} (SHACL),~\ref{sec:shex} (ShEx),
and~\ref{sec:pgschema-simplified} (PG-Schema);
\todo{Remove or reformulate!}
in the Appendices we explain how and why we sometimes deviate from the original
formalisms.
Each of these sections contains examples to give readers an immediate intuition
about what kinds of conditions each language can express.
Then, in Section~\ref{sec:core}, we present the \emph{Common Graph Schema
Language (CoGSL)}, which consists of functionalities shared by them all.

Casting all three languages in a common framework has the immediate advantage
that the reader can identify common functionalities \emph{based on the syntax
only}: on the one hand, we aim at giving the same semantics to schema language
components that syntactically look the same, and on the other hand, we can
provide examples of properties that distinguish the three languages using simple
syntactic constructs that are not part of the common core.
Aside from corner cases, properties expressed using constructs outside the
common core are generally not expressible in all three languages.
By providing an understanding of fundamental differences and similarities
between the three schema languages, we hope to benefit both practitioners in
choosing a schema language fitting their needs, and researchers in studying the
complexity and expressiveness of schema languages.

% End of file 1-Introduction.tex
