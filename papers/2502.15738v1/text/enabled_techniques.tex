\section{On the Battlefield}
    We have implemented a first prototype of \sname as outlined in \sect~\ref{sec:model} on the \zculong development board.
    This board features a \soc composed of four ARM64 Cortex-A53 \cpu cores and a coherent \fpga which hosts our \sname prototype.
    This initial prototype implements the watermarking feature discussed in \sect~\ref{subsec:challenges} to address Assumption~(1).
    However, the prototype still requires an isolated target VA, as per Assumption~(2) and that the \va mappings are pre-populated---Assumption~(3).
    This prototype focuses on virtualizing a subset of pages in a Linux user-space process. This section presents early results \wrt measured overhead introduced by \sname.
    
    
    \subsection{Overhead}

        \begin{table}[ht]
            \centering
            \begin{tabular}{cccc}
                Linux & Passive SNV & Active SNV & Jailhouse  \\
                 \toprule
                 $2.39 \pm 0.035s$ & $2.4 \pm 0.052s$ & $2.38 \pm 0.04s$ & $2.38 \pm 0.034s$ \\
                 \bottomrule
            \end{tabular}
            \caption{Avg/min/max runtime of the histogram benchmark. "Active \sname{"} has single-page virtualization.}
            \label{tab:OH-SNV}
            \vspace{-0.8cm}
        \end{table}

        To measure the overheads of single-page virtualization, the RGB histogram benchmark was chosen, with an $\sim$55.6\mb input image. This application is characterized by a large pool of cold pages for the image data, warmer pages for the code itself, and a single hot page for the aggregated data of the histogram; the \va of the latter is the target for \sname.

        The benchmark is executed under three scenarios, shown in Table~\ref{tab:OH-SNV}:
        \textbf{Linux}: Linux without \sname being implemented in the \fpga, averaging  $2.39 \pm 0.035s$; 
        \textbf{Passive \sname}: our \sname module is instantiated in the \fpga as a coherent {\master} but it has no target \va{s}, averaging $2.38 \pm 0.04s$;
        \textbf{Active \sname}: \sname implemented and enabled to virtualize a single page, averaging $2.38 \pm 0.04s$.
        Comparing the \textbf{Linux} and \textbf{Passive \sname} cases captures the overhead introduced by adding a {\master} to the coherence domain.
        As reported in Table~\ref{tab:OH-SNV}, the overhead is negligible.
        Indeed, \textbf{Active \sname} introduces overheads that are in line with the 1\% figure reported by previous works~\cite{shedding-light} for common type-1 hypervisors---\eg Jailhouse, which we also evaluate in Table~\ref{tab:OH-SNV}.
    
    \subsection{Ascertained Novel Features}
    
        \para{Selective Virtualization}
            Our technology allows virtualizing just what is needed with the granularity of a single process/OS page. Unlike traditional virtualization, any translation outside the range of interest will be minimally impacted since no additional steps are added in this case---step~\step{5b} in \fig{skeleton}.
            Moreover, since the \sname machinery is synthesized in FPGA, no virtualization management cost, in the form of extra instructions to be executed on the CPU, needs to be paid.
            Finally, no additional main memory will be allocated for 1:1 flat translations.
        
        \para{Dynamic Translation Semantics}
            As noted previously, the content of traditional translation tables can be changed at any time, allowing more sophisticated mapping.
            Usually, however, this is an expensive operation, and use cases beyond allocation/deallocation of new areas are seldom performed.
            Conversely, under \sname, the rule-based, dynamic translation is more lightweight, and arbitrarily complex semantics can be implemented in the \fpga.
    