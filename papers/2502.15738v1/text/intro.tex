\section{Introduction}
    \label{sec:introduction}

    Virtualization is a staple of modern computing systems.
    In the last decade, support and use cases for hardware-aided virtualization have substantially proliferated, touching a wide range of real-world deployment from large-scale enterprise and cloud infrastructure~\cite{virt_cloud}, to general-purpose consumer computing~\cite{wolf2006virtualization}, to embedded systems~\cite{virt_embedded,shedding-light}. Indeed, virtualization support offers flexible hardware provisioning, 
    allows abstracting away resources, managing their visibility to guest \os's, and isolating them as needed to achieve multi-tenant/multi-domain setups with spatial and performance isolation properties. 
        
    Unfortunately, the virtualization superpower comes with a hefty price.
    First, the need to introduce one (or more) layers of software and hardware often comes with noticeable overheads~\cite{virt_overhead}.
    Moreover, the additional software layers add complexity and widen the security attack surface~\cite{security_hyper}.
    Second, current support for virtualization is \textit{"binary"}, \ie either everything or nothing in a system is virtualized.
    Although some hypervisors can be dynamically activated after boot~\cite{jailhouse}, once a hypervisor is active, there is little to no control over what resources are virtualized and which ones are not.
    For instance, any memory page accessed by a guest OS must be mapped to physical memory by the hypervisor. 
    
    The aforementioned shortcomings of traditional memory and \io virtualization technology arise from its reliance on page table-based address translation.
    However, what if one could \emph{steer} address translation using arbitrary logic?
    In this case, intermediate-to-physical address resolution could be dynamically defined on the fly.
    
    In this paper, we demonstrate that this is already possible in commercial hardware by surgically interacting with the cache coherence traffic originating from a \cpu cluster.
    We refer to one such approach to enact resource virtualization as \emph{\snamefull}, or \sname for short.
    \sname enables us to re-think virtualization support and opens the doors to untapped resource management paradigms.
    To this end, we present the proof-of-concept implementation of a hardware module capable of providing basic \sname primitives and the preliminary results we obtained on an initial single-page virtualization use case.
    