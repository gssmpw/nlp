% \begin{algorithm*}[tb]
%    \caption{
%    function $\texttt{GenerateActions}$. There are two aspects that need more discussions: (1) As for conventional MCTS methods, the number of different search agents $m =1$; while in the case of \textsc{MoSA}, $m > 1$.  (2) The \texttt{FinalizeSubAnswer} function is simply majority voting in the case of not using aggregators. Upon using aggregators, that function works by aggregating all candidate sub-answers with \textsc{MoSA} and then feed both the aggregated sub-answers and the candidate sub-answers into majority voting, as shown by the right part of Figure~\ref{fig:ours}.
%    }
%    \label{alg:mosa-A_1}
% \begin{algorithmic}
%     \REQUIRE Selected node $s_i$; Number of sub-questions $n_q$; Number of candidate sub-answers per sub-question $n_a$; A set of LLMs $\pi^{\mathrm{mix}} = \{ \pi_1, \pi_2, ..., \pi_m \}$
%     \ENSURE Generate a set of new actions $\texttt{\small new\_actions} = \{ \texttt{\small action}_1, \texttt{\small action}_2, ..., \texttt{\small action}_{n_q} \}$
    
%    % \STATE {\bfseries Initialization:}
%    % \STATE \COMMENTALGO{init the set of nodes, with the root node being $x$ }  
%    % \STATE $N \leftarrow \{x\}$
%    % \STATE Let $\texttt{\small sub\_questions} \leftarrow \emptyset$, $\texttt{\small sub\_answers} \leftarrow \emptyset$
%    \STATE Let $\texttt{\small new\_actions} \leftarrow \emptyset$ \COMMENTALGO{Initialize the set of new actions}
%    \STATE \COMMENTALGO{for-loop: sample $n_q$ sub-questions}
%    \FOR{$i=1$ {\bfseries to} $n_q$}
%    % \STATE \COMMENTALGO{for-loop: sample $n_q$ sub-questions (i.e., children) }
%    \STATE ${\pi}^{\mathrm{sub\_q}} \leftarrow \texttt{\small SelectLLM}(\pi^{\mathrm{mix}} )$ \COMMENTALGO{Select an LLM to sample $\texttt{\small sub\_question}_i$}
%    % \STATE \textcolor{olive}{\texttt{\small /* Sample a sequence of tokens, $q_{i,k}$, from the output distribution of ${\pi}^{\mathrm{mix}}_{q}$ */ }}
%    \STATE $\texttt{\small sub\_question}_i \leftarrow \texttt{\small GenerateSubQuestion}( {\pi}^{\mathrm{sub\_q}}, s_i)$ \COMMENTALGO{Sample a sequence of tokens as the $i$-th sub-question}
%    \STATE Let $\texttt{\small candidate\_sub\_answers} \leftarrow \emptyset$ \COMMENTALGO{Initialize candidate\_sub\_answers for sub\_question$_i$}
%    \STATE \COMMENTALGO{for-loop: sample $n_a$ candidate sub-answers for sub\_question$_i$}
%    \FOR{$j=1$ {\bfseries to} $n_a$}
%  %   \STATE \textcolor{olive}{\texttt{\small /* 
%  % Sample an SLM, ${\pi}^{\mathrm{mix}}_{a}$,  as the answer proposer */ }}
%    \STATE ${\pi}^{\mathrm{sub\_a}} \leftarrow \texttt{\small SelectLLM}(\pi^{\mathrm{mix}} )$ \COMMENTALGO{Select an LLM from the set of LLMs to sample a candidate sub\_answer for sub\_question$_i$}
%    % \STATE \textcolor{olive}{\texttt{\small /* Sample a sequence of tokens, $a_{i,j,k}$, from the output distribution of ${\pi}^{\mathrm{mix}}_{a}$ */ }}
%    \STATE $\texttt{\small candidate\_sub\_answer}_j \leftarrow \texttt{\small GenerateSubAnswer}({\pi}^{\mathrm{sub\_a}}, s_i, \texttt{\small sub\_question}_i)$ \COMMENTALGO{Sample a sequence of tokens as the $j$-th candidate sub\_answer}
%    % \textcolor{olive}{\texttt{\small /* Sample a sequence of tokens, $a_{i,j,k}$, from the output distribution of ${\pi}^{\mathrm{mix}}_{a}$ */ }}
%    \STATE \texttt{\small candidate\_sub\_answers.add(candidate\_sub\_answer$_j$)}  \COMMENTALGO{Add it into candidate answers }
%    \ENDFOR
%    % aggregate the sub-answers
%    \STATE $\texttt{\small sub\_answer}_i \leftarrow \texttt{\small FinalizeSubAnswer(candidate\_sub\_answers)}$ \COMMENTALGO{Finalize a single sub\_answer from all candidate sub\_answers}
%    % \COMMENTALGO{obtain the chosen answer $a_i^*$ for $q_i$ through majority-voting }
%    % \STATE $N \leftarrow N + \{ \mathrm{NewNode}(q_i, a^*_i, \mathrm{parent}=x)\}$ \COMMENTALGO{add the new node $(q_i, a_i^*, \mathrm{parent}=x)$ to the tree }
%    \STATE \texttt{\small action$_i \leftarrow$ concat(sub\_question$_i$, sub\_answer$_i$)} \COMMENTALGO{Create action$_i$ using concatenation}
%    \STATE \texttt{\small new\_actions.add(action$_i$)} \COMMENTALGO{Add action$_i$ to new\_actions}
%    \ENDFOR
% % \STATE \textbf{return} \texttt{\small new\_actions}
% \end{algorithmic}
% \end{algorithm*}



\begin{algorithm*}[tb]
\begin{small}
   \caption{
   \small
   \texttt{GenerateActions}: A function for generating actions, i.e., a sub-question along with a sub-answer, given the current state.
    The implementation of this function using conventional MCTS and MoSA mainly differs in two aspects: 
   (1) In conventional MCTS methods, the number of search agents \(m=1\), while for \textsc{MoSA}, \(m > 1\). 
   (2) The \texttt{FinalizeSubAnswer} function employs heuristic majority voting for single-model search, while employing an additional neural aggregation function for \textsc{MoSA} (see the right section of Figure~\ref{fig:ours}).
   }
   % When aggregators are used, the function combines all candidate sub-answers with \textsc{MoSA}, feeds the aggregated results back, and applies majority voting (see Figure~\ref{fig:ours}, right
   % ).
   
   \label{alg:mosa-A_1}
\begin{algorithmic}
    \REQUIRE Selected node \(s_i\); Number of sub-questions \(n_q\); Number of candidate sub-answers per sub-question \(n_a\); A set of LLMs \(\pi^{\mathrm{mix}} = \{ \pi_1, \pi_2, ..., \pi_m \}\)
    \ENSURE A set of new actions \(\texttt{\small new\_actions} = \{ \texttt{\small action}_1, \texttt{\small action}_2, ..., \texttt{\small action}_{n_q} \}\)
    
    \STATE Initialize \(\texttt{\small new\_actions} \leftarrow \emptyset\) \COMMENTALGO{Prepare the set of new actions}
    % \STATE \COMMENTALGO{Sample \(n_q\) sub-questions}
    \FOR{\(i=1\) {\bfseries to} \(n_q\)}
        \STATE \(\pi^{\mathrm{sub\_q}} \leftarrow \texttt{\small SelectLLM}(\pi^{\mathrm{mix}})\) \COMMENTALGO{Select an LLM for generating sub-question}
        \STATE \(\texttt{\small sub\_question}_i \leftarrow \texttt{\small GenerateSubQuestion}(\pi^{\mathrm{sub\_q}}, s_i)\) \COMMENTALGO{Generate the \(i\)-th sub-question}
        
        \STATE Initialize \(\texttt{\small candidate\_sub\_answers} \leftarrow \emptyset\) \COMMENTALGO{Store candidate sub-answers for sub-question \(i\)}

        % \STATE \COMMENTALGO{Sample \(n_a\) candidate sub-answers for sub-question \(i\)}
        \FOR{\(j=1\) {\bfseries to} \(n_a\)}
            \STATE \(\pi^{\mathrm{sub\_a}} \leftarrow \texttt{\small SelectLLM}(\pi^{\mathrm{mix}})\) \COMMENTALGO{Select an LLM for generating a sub-answer}
            \STATE \(\texttt{\small candidate\_sub\_answer}_j \leftarrow \texttt{\small GenerateSubAnswer}(\pi^{\mathrm{sub\_a}}, s_i, \texttt{\small sub\_question}_i)\) \COMMENTALGO{Generate the \(j\)-th candidate sub-answer}
            \STATE \texttt{\small candidate\_sub\_answers.add(candidate\_sub\_answer$_j$)} \COMMENTALGO{Store the candidate sub-answer}
        \ENDFOR
        
        \STATE \(\texttt{\small sub\_answer}_i \leftarrow \texttt{\small FinalizeSubAnswer(candidate\_sub\_answers)}\) \COMMENTALGO{Aggregate or vote on candidate sub-answers}
        \STATE \(\texttt{\small action}_i \leftarrow \texttt{\small concat}(\texttt{\small sub\_question}_i, \texttt{\small sub\_answer}_i)\) \COMMENTALGO{Form the final action by concatenation}
        \STATE \texttt{\small new\_actions.add(action$_i$)} \COMMENTALGO{Add the action to the set of new actions}
    \ENDFOR
    
    \STATE return \(\texttt{\small new\_actions}\)
\end{algorithmic}
\end{small}
\end{algorithm*}
