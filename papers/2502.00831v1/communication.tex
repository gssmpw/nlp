This section introduces the proposed communication scheme, which includes modulation, synchronization, and detection.
%
\scaleSubsection
\subsection{Modulation and Reception}\label{Sec:Modulation}
\scaleSubsectionBelow
%
In \Sections{subsubsec:tx}{subsubsec:rx}, we discussed modulation and reception qualitatively, respectively. This section provides a formal description of the transmission parameters, their effects on the \ac{MC} signal, and the detection at the \ac{RX}.

To transmit a symbol $\symVar[k] \in \{0, 1, \ldots, \modOrder - 1\}$, the \ac{TX} is turned on with a corresponding light intensity $\txInten_\symVar$ for irradiation duration $\Ti$. Here, $\symIdx$ and $\modOrder = 2^\eta$ with $\eta \in \mathbb{N}$, where $\mathbb{N}$ is the set of positive integers, denote the symbol index and the modulation order, respectively. $\Ti$ is followed by the guard interval of duration $\Tg$, which results in $\Ts = \Ti + \Tg$, cf. \Section{subsubsec:tx}, and a data rate $R$ of
\begin{equation}
    R = \frac{\log_2 \modOrder}{\Ts} \;.
\end{equation}
During the irradiation process, the \ac{GFPD} in the tube section of the \ac{TX} undergoes a state transition (from ON to OFF) when hit by the emitted photons, reducing the local fluorescence. Increasing light intensity $\txInten$ increases the hit probability, allowing control over the local fluorescence. This enables higher-order modulation with distinct fluorescence drops for different symbols $\symVar$. 
%
In particular, in this work, we modulate the light intensity ratio $\ratioInten_\symVar$ for symbol $\symVar$ as
\begin{equation}\label{eq:power_ratio}
    \ratioInten_\symVar = \frac{\txInten_\symVar}{\maxTxInten} = \frac{3 \symVar}{4(M-1)} + \frac{1}{4},
\end{equation}
i.e., $\ratioInten_\symVar$ is determined as the ratio of $\txInten_\symVar$ to the maximum available light intensity $\maxTxInten$. Eq.~\Equation{eq:power_ratio} shows that $\ratioInten_\symVar$ ranges from $1/4$ to $1$, i.e., we do not assign intensity ratio zero to any symbol. This guarantees that the transmission of all symbols is distinct from the idle channel state, i.e., a turned off \ac{TX}. This is necessary for symbol-by-symbol synchronization, as described in \Section{subsec:sync}.
%
On the \ac{RX} side, the spectrometer periodically measures the local fluorescence by sampling with time interval $\sampleInt$. After isolating the part of the signal close to the wavelength of interest, i.e., $\lambda_\mathrm{E} = 529 \, \si{\nm}$, and normalizing\footnote{The \textit{ThorSpectra software} internally scales the received fluorescence intensity in a non-transparent manner. Comparing absolute fluorescence values from different experiments is therefore not possible. Instead, it is useful to compare relative values, i.e., trends of the measured fluorescence intensities, which is guaranteed by the proposed normalization.} the maximum signal value to $1$, the discrete-time received signal $\recSig(\tn) \in [0,1]$ is obtained, where $\tn = n\sampleInt$, with $n \in \mathbb{N}_0$. Here, $\mathbb{N}_0$ denotes the set of non-negative integers.
%
\scaleSubsection
\subsection{Synchronization}\label{subsec:sync}
\scaleSubsectionBelow
%
Synchronization is an integral part of any communication system and is required for demodulation. While in stationary environments it can be sufficient to synchronize once at the beginning of the transmission of a data packet, the task of synchronization becomes critical -- and more challenging -- when dealing with non-stationary communication channels. Sources of this non-stationarity can be, for example, closed-loop \ac{ISI} effects, \ac{TX} and \ac{RX} movement, or a time-varying flow velocity. In this section, we propose synchronization schemes consisting of a transmission start detection and symbol-by-symbol synchronization. Hence, they address the aforementioned synchronization challenges.
%
\scaleSubsubsection
\subsubsection{Transmission Start Detection}\label{subsec:transmission}
\scaleSubsubsectionBelow
%
Prior to the initiation of demodulation, the \ac{RX} must detect that data transmission has started. To this end, a simple threshold-based trigger scheme is used, where transmission is assumed to have started when $\recSig(\tn)$ drops below a threshold $\trainThresh$. For this, $\recSig(\tn)$, which prior the to first transmission contains only noise, is used to estimate the noise statistics. Then, $\trainThresh$ is determined based on the noise statistic. We assume that the noise arises from many small, independent sources of randomness, e.g., thermal noise in the spectrometer, photon noise, i.e., the distribution of photons emitted by coherent light \cite{mandel1959fluctuations} from the \ac{RX} \ac{LED}, etc. Hence, applying the central limit theorem, we model the noise as Gaussian distributed.

Formally, before transmission has started, we collect a set of samples $\trainSet[\trainIdx] \triangleq \{\recSig(\tn)|\n \in \{\trainIdx \trainLength, \trainIdx \trainLength + 1, \hdots, (\trainIdx+1) \trainLength -1 \}\}$ of size $\trainLength$ for $\trainIdx \in \mathbb{N}_0$. Next, $\trainSet[\trainIdx]$ is used to fit a Normal distribution with mean $\trainMean[\trainIdx] = \frac{1}{\trainLength}\sum_{\recSig(\tn) \in \trainSet[\trainIdx]}\recSig(\tn)$ and variance $\trainVariance[\trainIdx] = \frac{1}{\trainLength-1}\sum_{\recSig(\tn) \in \trainSet[\trainIdx]} (\recSig(\tn) - \trainMean[\trainIdx])^2$ assuming independent and identically distributed samples, i.e., $\recSig(\tn)\,\sim\,\mathcal{N}(\trainMean[\trainIdx], \trainVariance[\trainIdx])$. Finally, we obtain the threshold value $\trainThresh[\trainIdx] = \Phi^{-1}(\pFA; \trainMean[\trainIdx], \trainVariance[\trainIdx])$ for which a desired false alarm probability $\pFA$, i.e., the residual risk of an incorrect decision that transmission has started, is achieved. Here, $\Phi^{-1}(\cdot)$ denotes the inverse of the Gaussian cumulative distribution function.

The obtained $\trainThresh[\trainIdx]$ is applied to the next sample set $\trainSet[\trainIdx+1]$. The transmission start is detected based on
\begin{equation}
    \tts = \min_{\forall \trainIdx}\{\tn|\recSig(\tn) \leq \trainThresh[\trainIdx],\, \recSig(\tn) \in \trainSet[\trainIdx+1]\}\;,
\end{equation}
where $\tts$ denotes the time at which transmission has started. Since $\recSig(\tn)$ may decreases (slowly) over time due to photobleaching, this process is continuously repeated to ensure that $\trainThresh$ is periodically adjusted until a transmission start has been detected\footnote{Note that detecting the end of transmission is not needed, as we assume fixed-length messages.}.
%
\scaleSubsubsection
\subsubsection{Symbol Synchronization}
\scaleSubsubsectionBelow
Synchronization guarantees a temporal alignment of the \ac{RX} with the \ac{TX}. For the testbed, we use a symbol-by-symbol synchronization approach \cite{jamali2017symbol}, which correlates the processed received signal\footnote{In particular, we use $\Tilde{\recSig}(\tn) \in \{1 - \recSig(\tn), \recSig(t_{\n+1}) - \recSig(\tn)\}$, as explained in detail in the next paragraph.} $\Tilde{\recSig}(\tn)$ with a receive template filter $g(\tn)$ to obtain the synchronization metric
\begin{equation}
  \syncMetric (\tn) = \vec{\filter}^\top \Tilde{\vec{\recSig}} (\tn) \;,
\label{sync_metric}
\end{equation}
based on which the symbol start time $\tsEst[\symIdx]$ is estimated\footnote{Note that $\tsEst[k]$ does not correspond to the actual symbol start time, as the channel-related propagation delay is not known at the \ac{RX}. Instead, it represents the \ac{RX}'s estimate of when a new symbol starts based on the selected template signal/filter.}.
Here, $\vec{\filter} = \big[\, g(t_{0}) \quad g(t_{1}) \quad \hdots$\\$ \quad g(t_{\filterLength-1})\,\big]^\top$ and $\Tilde{\vec{\recSig}}(\tn) = \big[\,\Tilde{\recSig}(\tn) \quad \Tilde{\recSig}(t_{n+1}) \quad \hdots \quad \Tilde{\recSig}(t_{n+\filterLength-1})\,\big]^\top$ are the vector representations of $g(\tn)$ and $\Tilde{\recSig}(\tn)$, respectively, where $\filterLength$ is the filter length and $[\cdot]^\top$ denotes the transpose operator.
Two synchronization schemes are employed: \Ac{CS} and \ac{DCS}.
\begin{itemize}
    \item \textit{Correlation-based Synchronization (CS)}: The \ac{CS} scheme utilizes the cross-correlation between the processed received signal $\Tilde{\recSig}(\tn) = 1 - \recSig(\tn)$, which captures the deviation from maximum fluorescence, and a corresponding receive filter $g(\tn) \in \{g^{\mathrm{D}}_{\mathrm{C}}(\tn), g^{\mathrm{B}}_{\mathrm{C}}(\tn)\}$. Details of how the data-based receive filter $g^{\mathrm{D}}_{\mathrm{C}}(\tn)$, referred to as \ac{SCF}, and the blind receive filter $g^{\mathrm{B}}_{\mathrm{C}}(\tn)$, referred to as \ac{BCF}, are obtained, respectively, are provided in \Section{matched_filter}.
    \item \textit{Differential Correlation-based Synchronization (DCS)}: The \ac{DCS} scheme is designed to mitigate the effects of slowly time-varying processes, such as offset-\ac{ISI}, and utilizes the cross-correlation between the \textit{differential} received signal $\Tilde{\recSig}(\tn) = \diffRecSig(\tn) = \recSig(t_{\n+1}) - \recSig(\tn)$ and a corresponding \textit{differential} receive filter $g(\tn) \in \{g^{\mathrm{D}}_{\mathrm{D}}(\tn), g^{\mathrm{B}}_{\mathrm{D}}(\tn)\}$. Note that in this case the corresponding vectors $\vec{\filter}$ and $\Tilde{\vec{\recSig}} (\tn)$ in \Equation{sync_metric} have dimension $\filterLength-1$, as the forward difference cannot be computed for the last vector entry. Details of how the data-based differential receive filter $g^{\mathrm{D}}_{\mathrm{D}}(\tn)$, referred to as \ac{SDCF}, and the blind differential receive filter $g^{\mathrm{B}}_{\mathrm{D}}(\tn)$, referred to as \ac{BDCF}, are obtained, respectively, are provided in \Section{matched_filter}.
  \end{itemize}
%
\paragraph{Symbol-by-symbol synchronization}
In the proposed symbol-by-symbol scheme, synchronization for the symbol in symbol interval $k$ relies on the last estimated symbol start time $\tsEst[k-1]$. A good initial guess for the start of the current symbol is given by $\tsInit[k] = \tsEst[k-1] + \Ts$. Note that $\tsInit[k]$ would also be the best estimate, if the previous estimate was accurate and the channel had not changed. Next, we define a search interval around $\tsInit[k]$ as $\searchInt[k] \triangleq [\tsInit[k] - \searchRadius \Ts, \tsInit[k] + \searchRadius \Ts]$. Here, $\searchRadius \in [0,1]$ denotes the normalized search radius, which can be adjusted based on the channel statistics, i.e., the stationarity of the channel.
The start time $\tsEst[k]$ of the current symbol interval $k$ is obtained as
\begin{equation}
  \tsEst[k] = \argmax_{\tn \in \searchInt[\symIdx]} \syncMetric(\tn)\;.
  \label{eq:estimation_symbol_start}
\end{equation}
This process is carried out for each symbol interval until the end of the transmission. The proposed synchronization method can adjust to fluctuations of the propagation delays in the channel within a single symbol interval as long as the true symbol start time is within the search interval.
%
\paragraph{Synchronization initialization}
Since for the first symbol interval there is no previous estimate $\tsEst[-1]$, we utilize the detected transmission start time as initial estimate, $\tsInit[0] = \tts$, and set the search radius to $\searchRadius=0.5$ -- resulting in search interval $\searchInt[0] = [\tsInit[0] - \frac{\Ts}{2}, \tsInit[0] + \frac{\Ts}{2}]$. Even if $\tts$ does not correspond to a false alarm, it may still be a suboptimal estimate for the first symbol start. Therefore, choosing search radius $\searchRadius=0.5$ ensures that the best estimate for the first symbol start time is within the search interval. Synchronization then proceeds as described above.
%
\scaleSubsection
\subsection{Receive Filters} \label{matched_filter}
\scaleSubsectionBelow
\begin{figure}[!tbp]
\vspace*{-1cm}
    \centering
    \begin{subfigure}[b]{0.49\textwidth}
        \caption{}
        \vspace{-3pt}
        \includegraphics[width=\textwidth]{fig/blind_matched_filter_new.pdf}
        \label{fig:BlindCorrFilter}
        \vspace*{-5mm}
    \end{subfigure}
    \begin{subfigure}[b]{0.49\textwidth}
        \caption{}
        \vspace{-3pt}
        \includegraphics[width=\textwidth]{fig/blind_diff_matched_filter_new.pdf}
        \label{fig:BlindDiffFilter}
        \vspace*{-5mm}
    \end{subfigure}
    \vspace*{0mm}
    \begin{subfigure}[b]{\textwidth}
        \includegraphics[width=\textwidth]{fig/filter_legend.pdf}
    \end{subfigure}
    \vspace*{-9mm}
    \caption{Data-based receive filters and blind receive filters in comparison for two different configurations: $\Ti=\SI{3}{\second}$, $\Ts=\SI{5}{\second}$ (on the left) and $\Ti=\SI{10}{\second}$, $\Ts=\SI{15}{\second}$ (on the right) for the \acs{CS} (a) and the \acs{DCS} scheme (b), respectively.}
    \label{fig:ReceiveFilter}
    \vspace*{-8mm}
\end{figure}
Two different approaches are used to obtain receive filters for the \ac{CS} and the \ac{DCS} schemes, namely a data-based approach and a blind filter approach. Although these filters are akin to a matched filter, we do no refer to them as such, as we cannot guarantee their optimality \ac{wrt} the achieved signal-to-noise ratio.
%
\scaleSubsubsection
\subsubsection{Data-Based Receive Filters}\label{data_filter}
\scaleSubsubsectionBelow
For each $\Ti$ considered in this work, a separate experiment was performed to obtain the typical shape of the received signal for that irradiation duration, on the basis of which the data-based filter was determined. Each of these experiments consisted of a binary transmission of a single bit 1 repeated 11 times at 60 second intervals. The 11 individual received signals obtained in this way are referred to as \acp{SR} $\SR(\tn)$. To derive the data-based filter, the first \ac{SR} is discarded and the remaining \acp{SR} are averaged and further smoothed using locally weighted polynomial regression \cite{cleveland1988locally} to obtain $\avgSR(\tn)$. Ignoring the first \ac{SR} is necessary because in the beginning almost all \acp{GFPD} are in the equilibrium state, cf. \Section{subsec:GFPD}, and therefore the fluorescence decay for the first \ac{SR} is higher than for the following \acp{SR}.
Then, the \ac{SCF}, $g^{\mathrm{D}}_{\mathrm{C}}(\tn)  = 1 - \avgSR(\tn)$, $n \in \{0, 1, \ldots, \filterLength-1\}$, and the \ac{SDCF}, $g^{\mathrm{D}}_{\mathrm{D}}(\tn)  = \avgSR(t_{\n+1}) - \avgSR(\tn)$, $n \in \{0, 1, \ldots, \filterLength-2\}$, are obtained by limiting them to an $\filterLength$ and $\filterLength-1$ samples long signal, respectively, i.e., limiting them such that their lengths match the lengths of the corresponding $\Tilde{\vec{\recSig}}(\tn)$, cf. \Equation{sync_metric}. The resulting receive filters $g^{\mathrm{D}}_{\mathrm{C}}(\tn)$ and $g^{\mathrm{D}}_{\mathrm{D}}(\tn)$ are shown in blue in \Figure{fig:BlindCorrFilter} and \Figure{fig:BlindDiffFilter}, respectively, exemplarily for two different symbol durations $\Ts$. \Figure{fig:BlindCorrFilter} shows that $g^{\mathrm{D}}_{\mathrm{C}}(\tn)$ increases over the irradiation durations $\Ti=\SI{3}{\second}$ (left subplot in \Figure{fig:BlindCorrFilter}) and $\Ti=\SI{10}{\second}$ (right subplot in \Figure{fig:BlindCorrFilter}), and decreases during the subsequent guard interval. For $\Ts=\SI{5}{\second}$ (left subplot in \Figure{fig:BlindCorrFilter}), $g^{\mathrm{D}}_{\mathrm{C}}(\tn)$ is bell-shaped, while for the longer symbol duration, $\Ts=\SI{15}{\second}$ (right subplot in \Figure{fig:BlindCorrFilter}), we see that $g^{\mathrm{D}}_{\mathrm{C}}(\tn)$ reaches a value of $0.25$, before decreasing after $\tn = \Ti = \SI{10}{\second}$. In \Figure{fig:BlindDiffFilter}, we see that the shape of $g^{\mathrm{D}}_{\mathrm{D}}(\tn)$ follows the derivative of $- g^{\mathrm{D}}_{\mathrm{C}}(\tn)$. Hence, it has a negative and a positive dip. For $\Ts=\SI{15}{\second}$ (right subplot in \Figure{fig:BlindDiffFilter}), $g^{\mathrm{D}}_{\mathrm{D}}(\tn)$ shows some fluctuations around $\tn=\SI{6}{\second}$, caused by noise that is amplified by the differentiation operation.
%
\scaleSubsubsection
\subsubsection{Blind Receive Filter}\label{blind_filter}
\scaleSubsubsectionBelow
In cases where the data-based filter cannot be obtained in advance, we propose blind filters as surrogates for both the \ac{CS} and \ac{DCS} schemes, respectively. For these blind filters, we aim to capture roughly the shape of the data-based filters, with the goal of achieving a solution that is applicable across a broad range of unknown parameters without significant performance loss. For the sake of a simple and practical implementation, we limit the modeling of the blind filters to piecewise polynomials. Hence, the impulse responses of the proposed blind filters \ac{BCF}, $g^{\mathrm{B}}_{\mathrm{C}}(\tn)$, and \ac{BDCF}, $g^{\mathrm{B}}_{\mathrm{D}}(\tn)$, are given as follows,
\begin{equation}\label{eq:blind_corr_filter}
\blindCorrFilter(\tn) =
\begin{cases}
     - \frac{\tn^2}{2\Ti} + \tn, & 0\leq \tn \leq \Ti\\[-0.2cm]
     \frac{0.5\Ti}{(\Ts-\Ti)^2}(\tn^2 -2\Ts \tn + \Ts^2), &  \Ti < \tn \leq  \Ts\\[-0.2cm]
     0, & \text{otherwise}
\end{cases}
\end{equation}
and
\begin{equation}\label{eq:blind_diff_corr_filter}
\blindDiffCorrFilter(\tn) =
    \begin{cases}
        \frac{\tn}{\Ti} - 1, & 0\leq \tn \leq \Ti\\[-0.2cm]
        \frac{\Ts - \tn}{\Ts-\Ti}, &  \Ti < \tn \leq  \Ts\\[-0.2cm]
        0, & \mathrm{otherwise}
    \end{cases}\,,
\end{equation}
respectively. $g^{\mathrm{B}}_{\mathrm{C}}(\tn)$ and $g^{\mathrm{B}}_{\mathrm{D}}(\tn)$ are plotted in green in \Figure{fig:BlindCorrFilter} and \Figure{fig:BlindDiffFilter}, respectively, exemplarily for two different symbol durations $\Ts$. \Figure{fig:BlindCorrFilter} shows that the shapes of the data-based filter $g^{\mathrm{D}}_{\mathrm{C}}(\tn)$ and the blind filter $g^{\mathrm{B}}_{\mathrm{C}}(\tn)$ are quite similar, while those of the differential filters $g^{\mathrm{D}}_{\mathrm{D}}(\tn)$ and $g^{\mathrm{B}}_{\mathrm{D}}(\tn)$ in \Figure{fig:BlindDiffFilter} are more different. We will show in \Section{sssec:effect_filter_and_detection} that despite these visible differences, the use of blind filters only leads to a small loss in performance compared to the use of data-based filters. In addition, blind filters do not require data collection, which justifies their use. Note that the blind filters are defined independent of each other as this leads to better results, i.e., $g^{\mathrm{B}}_{\mathrm{D}}(\tn)$ is not necessarily the sectional derivative of $g^{\mathrm{B}}_{\mathrm{C}}(\tn)$. Furthermore, note that the scaling of the data-based filters and the blind filters are different. However, for a given synchronization scheme, adjusting the scaling of any receive filter has no impact on the decisions derived from \Equation{sync_metric} and \Equation{eq:estimation_symbol_start}, since the operation in \Equation{sync_metric} is linear. Therefore, no scaling adjustment is needed.
%
\scaleSubsection
\subsection{Symbol Detection}\label{subsec:symbol_detection}
\scaleSubsectionBelow
%
For symbol detection, we use a single detection sample $\detecSample[\symIdx]$. Here, the detection sample is chosen to be the filtered received signal for the estimated symbol start time $\tsEst[\symIdx]$, which was determined by the proposed synchronization scheme, i.e., 
\begin{equation}
\detecSample[\symIdx]=\vec{\filter}^\top \Tilde{\vec{\recSig}} (\tsEst[\symIdx]) \;. \label{eq:detection_sample}
\end{equation}
In \Equation{eq:detection_sample}, correlation-based detection and differential correlation-based detection are employed, if \ac{CS} and \ac{DCS} was used for synchronization, respectively. Hence, when \ac{CS} and \ac{DCS} are mentioned in the following, this therefore also refers to the detection scheme used.

For detection, we employ an adaptive (multi-)threshold detector that periodically adjusts its thresholds based on previously detected symbols to account for the gradual reduction of the fluorescence over time due to photobleaching. Let $\detecThreshSet[\detecThreshSetIdx] \triangleq \{\detecThresh_0, \detecThresh_1, \hdots, \detecThresh_{\modOrder-2}\}$ denote the set of detection thresholds, where $\detecThresh_{\detecThreshIdx}$, $\detecThreshIdx \in \{0, 1, \hdots, \modOrder-2\}$, and $\detecThreshSetIdx$ denote the individual threshold and the threshold set index, respectively. Additionally, we assume \ac{wlog} that $\detecThreshSet[\detecThreshSetIdx]$ is ordered in ascending order, i.e., $\detecThresh_\detecThreshIdx < \detecThresh_{\detecThreshIdx+1}$. For the employed single-sample detection, the transmitted symbol $\estSym[\symIdx]$ is determined as follows
\begin{equation}
\estSym[\symIdx] = \max\{\detecThreshIdx | \detecThreshIdx \in \{0, 1, \hdots, \modOrder-2\} \wedge \detecSample[\symIdx] \geq \detecThresh_\detecThreshIdx\} \;,
\end{equation}
i.e., the symbol decision is based on $\detecSample[\symIdx]$ and $\detecThreshSet[\detecThreshSetIdx]$ only.
%
\scaleSubsubsection
\subsubsection{Detection Initialization}
\scaleSubsubsectionBelow
%
To determine the initial set of thresholds, $\detecThreshSet[0]$, each transmission starts with a random sequence of $\nSkip$ symbols.
This sequence is used to allow the system to settle\footnote{The experiment is initially in a settling phase caused by the offset \ac{ISI}, which develops slowly over successive transmissions and remains relatively constant after several symbols. \Section{sssec:effect_modulation_order} presents experimental results that illustrate the transient phase of the testbed.} and is not considered for detection. Next, $\nPilots$ pilot symbols are transmitted, where each $\symVar \in \{0, 1, \ldots, \modOrder - 1\}$ is sent at least once. The corresponding detection samples $\detecSample[k]$ form the initial sets $\symbolSampleSet_{\symVar}[\detecThreshSetIdx = 0] \triangleq \{d[\mu]|\mu \in \{\nSkip, \nSkip+1, \ldots, \nSkip+\nPilots-1\} \wedge \symVar[\mu]=i\}$, $\symVar \in \{0, 1, \ldots, \modOrder - 1\}$. The average of each set can be computed as follows
\begin{equation}
    \Bar{S}_\symVar[\detecThreshSetIdx] = \frac{1}{|\symbolSampleSet_{\symVar}[\detecThreshSetIdx]|}\sum_{s\in \symbolSampleSet_{\symVar}[\detecThreshSetIdx]} s \;.
    \label{eq:average_set}
\end{equation}
Here, $|\cdot|$ denotes the cardinality of a set. Hence, we use $\detecThreshSetIdx = 0$ in \Equation{eq:average_set} to determine the averages $\Bar{S}_\symVar[\detecThreshSetIdx = 0]$ of the initial sets $\symbolSampleSet_{\symVar}[\detecThreshSetIdx = 0]$. Finally, the threshold values are computed as the means of the $\Bar{S}_\symVar[l]$ of adjacent sets:
%
\begin{equation}\label{eq:nt}
    \detecThresh_\detecThreshIdx[\detecThreshSetIdx] = \frac{\avgSymbolSampleSet_{\detecThreshIdx+1}[\detecThreshSetIdx] + \avgSymbolSampleSet_{\detecThreshIdx}[\detecThreshSetIdx]}{2}\,,
\end{equation}
for $\detecThreshIdx \in \{0, 1, \hdots, \modOrder-2\}$. Thus, to obtain the initial set of thresholds, $\detecThreshSet[0]$, we use $\detecThreshSetIdx = 0$ in \Equation{eq:nt}.
%
\scaleSubsubsection
\subsubsection{Adaptation Algorithm}
\scaleSubsubsectionBelow
%
The duration for which the threshold set is valid has an upper limit that is determined by the coherence time of the channel. Therefore, a new set of thresholds must be determined after a certain number of detected symbols $\nCoherence$. In contrast to the initial set of thresholds $\detecThreshSet[0]$, which is determined based on the $\nPilots$ pilot symbols, the \textit{update} of the set of thresholds requires only previously detected \textit{data symbols}, i.e., no pilot symbols are used to update the threshold values. The corresponding update algorithm is described next.

For this, we relate the symbol index $\symIdx$ to the currently valid threshold set index $\detecThreshSetIdx$ via $\detecThreshSetIdx = \lfloor \frac{\symIdx-\nSkip-\nPilots}{\nCoherence}\rfloor$, where $\lfloor \cdot \rfloor$ denotes the floor function. Note that $\detecThreshSetIdx$ is not defined for $\symIdx < \nPilots + \nSkip$ because the first thresholds are computed only after the $\nPilots$ pilot symbols have been received.

Similar to the initial sets $\symbolSampleSet_\symVar[\detecThreshSetIdx = 0]$, we define sets
\begin{equation}
    \symbolSampleSet_\symVar[\detecThreshSetIdx]\triangleq\{\detecSample[\mu]|\mu \in \{\detecThreshSetIdx\nCoherence+\nSkip+\nPilots-\nWindow,..., \detecThreshSetIdx\nCoherence+\nSkip+\nPilots-1\} \wedge \estSym[\mu]=\symVar\}\;,
    \label{eq:sampleSets}
\end{equation}
for $\detecThreshSetIdx>0$ and $\nCoherence+\nPilots-\nWindow \geq 0$. Here, $\nWindow$ denotes the window width that determines the number of past samples $\detecSample[k]$ used for reevaluation. Finally, using \Equation{eq:average_set} and \Equation{eq:nt}, we obtain the new set of thresholds $\detecThreshSet[\detecThreshSetIdx]$.

In contrast to the pilot symbol sequence, now it is not guaranteed that all symbol values will be present in the $\nWindow$ previously received symbols, i.e., some sets may remain empty ($|\symbolSampleSet_\symVar[\detecThreshSetIdx]| = 0$). For this special case, the corresponding new thresholds cannot be determined directly using \Equation{eq:average_set} and \Equation{eq:nt}. We determine the differences between the new thresholds and the previous thresholds for the subset of thresholds for which this is possible, i.e., $\threshDiff_q[\detecThreshSetIdx] =\detecThresh_q[\detecThreshSetIdx] - \detecThresh_q[\detecThreshSetIdx-1]$ for $q \in \mathcal{Q}\triangleq\{\detecThreshIdx \,|\,|\symbolSampleSet_{\detecThreshIdx+1}[\detecThreshSetIdx]|\neq0 \wedge |\symbolSampleSet_{\detecThreshIdx}[\detecThreshSetIdx]|\neq 0\}$ with $\detecThreshIdx \in \{0, 1, \hdots, \modOrder-2\}$. The thresholds corresponding to the empty sets are subsequently obtained by adjusting the previous threshold value according to the \textit{average} change across all thresholds $\avgThreshDiff[\detecThreshSetIdx] = \frac{1}{|\mathcal{Q}|}\sum_{q \in \mathcal{Q}}\threshDiff_q[\detecThreshSetIdx]$ as $\detecThresh_\detecThreshIdx[\detecThreshSetIdx] = \detecThresh_\detecThreshIdx[\detecThreshSetIdx-1] + \avgThreshDiff[\detecThreshSetIdx]$ for $\detecThreshIdx \notin \mathcal{Q}$. For the rare case, for which no new threshold can be determined, i.e., $|\symbolSampleSet_{\detecThreshIdx}[\detecThreshSetIdx]|=0 \,\vee\, |\symbolSampleSet_{\detecThreshIdx+1}[\detecThreshSetIdx]|=0,\,\forall \detecThreshIdx$, the thresholds retain their previous values, i.e., $\detecThreshSet[\detecThreshSetIdx]=\detecThreshSet[\detecThreshSetIdx-1]$.