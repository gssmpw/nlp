@article{BAKER1996225,
title = {{Mutual exclusion scheduling}},
journal = {Theoretical Computer Science},
volume = {162},
number = {2},
pages = {225-243},
year = {1996},
issn = {0304-3975},
doi = {https://doi.org/10.1016/0304-3975(96)00031-X},
url = {https://www.sciencedirect.com/science/article/pii/030439759600031X},
author = {Brenda S Baker and Edward G Coffman},
abstract = {Mutual exclusion scheduling is the problem of scheduling unit-time tasks non-preemptively on m processors subject to constraints represented by a graph G, such that tasks represented by adjacent vertices in G must run in disjoint time intervals. This problem arises in load-balancing the parallel solution of partial differential equations by domain decomposition. Minimizing the completion time is NP-hard even if either the number of processors or the completion time is fixed but greater than two. However, polynomial time is sufficient to produce optimal schedules for forests, and simple heuristics perform well on certain classes of graphs. For graphs derived from the two-dimensional domain decomposition problem, heuristics yield solutions within 4c − 7 time units of optimal, where c is the maximal number of regions that touch each other at a single point in the domain decomposition; these solutions are within a constant factor of optimal.}
}

@misc{aptos,
  author = {Aptos Foundation},
  title = {{{Aptos} Whitepaper}},
  howpublished = {\url{https://aptos.dev/assets/files/Aptos-Whitepaper-47099b4b907b432f81fc0effd34f3b6a.pdf
}},
  year = 2023,
  note = "Accessed on 12.04.2023"
}

@article{aria,
author = {Lu, Yi and Yu, Xiangyao and Cao, Lei and Madden, Samuel},
title = {{Aria: A Fast and Practical Deterministic OLTP Database}},
year = {2020},
issue_date = {August 2020},
publisher = {VLDB Endowment},
volume = {13},
number = {12},
issn = {2150-8097},
url = {https://doi.org/10.14778/3407790.3407808},
doi = {10.14778/3407790.3407808},
abstract = {Deterministic databases are able to efficiently run transactions across different replicas without coordination. However, existing state-of-the-art deterministic databases require that transaction read/write sets are known before execution, making such systems impractical in many OLTP applications. In this paper, we present Aria, a new distributed and deterministic OLTP database that does not have this limitation. The key idea behind Aria is that it first executes a batch of transactions against the same database snapshot in an execution phase, and then deterministically (without communication between replicas) chooses those that should commit to ensure serializability in a commit phase. We also propose a novel deterministic reordering mechanism that allows Aria to order transactions in a way that reduces the number of conflicts. Our experiments on a cluster of eight nodes show that Aria outperforms systems with conventional nondeterministic concurrency control algorithms and the state-of-the-art deterministic databases by up to a factor of two on two popular benchmarks (YCSB and TPC-C).},
journal = {Proc. VLDB Endow.},
month = {jul},
pages = {2047–2060},
numpages = {14}
}

@inproceedings{blurring,
author = {Sharma, Ankur and Schuhknecht, Felix Martin and Agrawal, Divya and Dittrich, Jens},
title = {{Blurring the Lines between Blockchains and Database Systems: the Case of Hyperledger Fabric}},
year = {2019},
isbn = {9781450356435},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
url = {https://doi.org/10.1145/3299869.3319883},
doi = {10.1145/3299869.3319883},
abstract = {Within the last few years, a countless number of blockchain systems have emerged on the market, each one claiming to revolutionize the way of distributed transaction processing in one way or the other. Many blockchain features, such as byzantine fault tolerance, are indeed valuable additions in modern environments. However, despite all the hype around the technology, many of the challenges that blockchain systems have to face are fundamental transaction management problems. These are largely shared with traditional database systems, which have been around for decades already. These similarities become especially visible for systems, that blur the lines between blockchain systems and classical database systems. A great example of this is Hyperledger Fabric, an open-source permissioned blockchain system under development by IBM. By implementing parallel transaction processing, Fabric's workflow is highly motivated by optimistic concurrency control mechanisms in classical database systems. This raises two questions: (1)~Which conceptual similarities and differences do actually exist between a system such as Fabric and a classical distributed database system? (2)~Is it possible to improve on the performance of Fabric by transitioning technology from the database world to blockchains and thus blurring the lines between these two types of systems even further? To tackle these questions, we first explore Fabric from the perspective of database research, where we observe weaknesses in the transaction pipeline. We then solve these issues by transitioning well-understood database concepts to Fabric, namely transaction reordering as well as early transaction abort. Our experimental evaluation under the Smallbank benchmark as well as under a custom workload shows that our improved version Fabric++ significantly increases the throughput of successful transactions over the vanilla version by up to a factor of 12x, while decreasing the average latency to almost half.},
booktitle = {Proceedings of the 2019 International Conference on Management of Data},
pages = {105–122},
numpages = {18},
keywords = {blockchain, concurrenct control, distributed ledger, distributed systems, fabric, hyperledger, information systems, ledger, transactions},
location = {Amsterdam, Netherlands},
series = {SIGMOD '19}
}

@misc{chiron,
      title={{CHIRON: Accelerating Node Synchronization without Security Trade-offs in Distributed Ledgers}}, 
      author={Ray Neiheiser and Arman Babaei and Giannis Alexopoulos and Marios Kogias and Eleftherios Kokoris Kogias},
      year={2024},
      eprint={2401.14278},
      archivePrefix={arXiv},
      primaryClass={cs.DC}
}

@misc{ethereum,
  author = {Buterin, Vitalik},
  title = {{{Ethereum} Whitepaper}}},
  howpublished = {\url{https://ethereum.org/en/whitepaper/}},
  year = 2013,
  note = "Accessed on 12.04.2023"
}

@misc{polygonupdate,
  title={{Innovating the Main Chain: a Polygon PoS Study in Parallelization}},
  author={Polygon Team},
  publisher = {Polygon},
  year={2022},
  howpublished = {\url{https://polygon.technology/blog/innovating-the-main-chain-a-polygon-pos-study-in-parallelization}},
  note = "Accessed on 05.12.2022"
}

@article{solana,
  title={{Solana: A new architecture for a high performance blockchain v0. 8.13}},
  author={Yakovenko, Anatoly},
  journal={Whitepaper},
  year={2018}
}

@misc{sui,
  author = {The MystenLabs Team},
  title = {{The Sui Smart Contracts Platform}},
  howpublished = {\url{https://docs.sui.io/paper/sui.pdf
}},
  year = 2023,
  note = "Accessed on 15.01.2024"
}

@misc{suiupdate,
  author = {Sui Foundation},
  title = {{Streamlining Transactions with Sui’s Shared Object Congestion Control}},
  howpublished = {\url{https://blog.sui.io/shared-object-congestion-control
}},
  year = 2024,
  note = "Accessed on 09.10.2024"
}

