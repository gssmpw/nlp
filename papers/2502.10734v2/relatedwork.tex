\section{Related Work}
\label{Section2_RelatedWork}

In this chapter, we would like to briefly review the related work on path/trajectory planning algorithms.

The conventional popular path planning algorithms are mainly divided into three types: the sampling-based ones, the graph-based searching ones, and the optimization-based ones.

In the realm of sampling-based path planning algorithms, the most influential one to date remains the Probabilistic RoadMaps (PRM) (\cite{1996_TRO_PRM}). The PRM algorithm, as a multiple-query method, first constructs a comprehensive graph representing a rich set of collision-free trajectories by sampling in the configuration space and performing collision detection on the sampled points. It then obtains feasible paths through graph search. The advantages of PRM lies in its efficiency, which depends primarily on the difficulty of finding paths rather than the dimensionality of the configuration space. Therefore, it performs well even in high-dimensional spaces. Additionally, the probability of planning failure decreases exponentially to zero as the number of sampled points increases (\cite{1998_TRO_PRM}). Hence, the PRM algorithm is probabilistically complete.

However, when a robot's working environment is unknown in advance or when the robot frequently switches between different environments, the multiple-query methods become less effective. Therefore, the Incremental Sampling-based Rapidly-exploring Random Tree (RRT) algorithm (\cite{2001_IJRR_RRT}) and its asymptotically optimal variant, RRT* (\cite{2011_IJRR_Sampling_based_algorithms}), were primarily proposed for unstructured environments. The RRT* algorithm builds a search tree of valid paths rooted at the start by incrementally sampling and connecting states when these local connections are valid. This approach avoids the need to predefine the number of sampled points while also constraining the sampling region. Additionally, the RRT* algorithm had been proven to be probabilistically complete. However, because the sample points are generated randomly, the RRT* algorithm cannot guarantee that the final path is globally optimal, particularly in complex scenarios.

Different to sampling-based methods, the graph-based searching methods can consistently provide optimal solutions on a global scale. One of the most common graph searching algorithms is the Dijkstra's algorithm (\cite{1959_NM_Dijkstra}). Its main idea is to approach a target point from an initial point by employing a greedy strategy. During each traversal, it selects the nearest neighboring node to the starting point that has not been visited yet, continuing until it reaches the destination. Dijkstra's algorithm primarily addresses the problem of finding the shortest path in weighted graphs. However, as the dimensionality of the search space increases, its searching efficiency decreases exponentially.

Currently, there is a method that combines graph searching techniques with sampling methods. It leverages the heuristic searching from the A* algorithm (\cite{1968_TSSC_Astar}) and the informed sampling-based incremental sampling from the RRT* algorithm. This method is known as the Batch Informed Trees (BIT*) algorithm (\cite{2020_IJRR_BIT}). The BIT* algorithm employs a multi-batch, multi-sampling method, allowing it to quickly return feasible solutions before finding the optimal solution during the searching process. Additionally, within each sampling batch, it introduces heuristic values to perform ordered searches near the optimal solution, thereby enhancing searching efficiency.

But both the graph-based searching and the sampling-based methods require a step-by-step expansion of nodes in the configuration space. No matter expanding a single node or a batch of nodes in a single iteration, there is no guarantee that any of the previously expanded nodes are valid until the target point is reached. The manipulator can only follow the desired trajectory after the entire planning algorithm is completed. But dynamic obstacles can disrupt the generated path at any time. Consequently, these motion planning approaches are inherently not suitable for dynamic scenarios.

Besides graph-based searching and sampling-based methods, the optimization-based motion planning is also a prevalent approach. The main challenge of optimization-based methods lies in transforming constraints from task space to configuration space. Currently, there are two approaches to address this difficulty. The first method attempts to transform the obstacles from task space to configuration space to obtain an unreachable region, by using inverse kinematics. The unreachable region serves as constraints for the optimization problem. However, these constraints are generally hard to be described by analytical expressions, making it very difficult to solve the optimization problem (\cite{1988_canny_complexity}). In addition, this method can only handle obstacle avoidance for the end-effector part. The collision with the other parts of the manipulator, e.g., the links, are difficult to be considered by this method. Despite the aforementioned shortcomings, some pleasant results have been achieved. It has been demonstrated (\cite{2012_latombe_robot_motion_planning}) that if all constraints in the task space can be described as semialgebraic sets, which are the intersections and unions of polynomial inequalities, then the constraint set in the configuration space is also a semialgebraic set. This indicates that although the method is currently challenging, it is solvable.

The second method attempts to directly describe the reachable regions in configuration space as a union of several simple sets. The IRIS algorithm (\cite{2015_STAR_Computing_Large_Convex_Regions}) achieved this by decomposing obstacles in known, convex configuration spaces into a set of reachable space regions, which are convex. Building upon this, some scholars (\cite{2023_IJRR_Certified_polyhedral_decompositions}) proposed a method to describe the reachable regions using convex polyhedra in a bijective, rational parametrization of the configuration space, which is known as the tangent configuration space. This method efficiently generates reachable space in configuration space by decomposing it into multiple convex polyhedra. However, such methods are still primarily applicable for solving path planning problems in static, known environments. The trajectory planning with dynamic obstacles remains challenging.

Building upon convex optimization methods, a Convex Set Graph (GCS) trajectory optimization algorithm framework (\cite{2023_SR_Motion_planning_around_obstacles_with_convex_optimization}), that integrates graph searching with convex optimization, was proposed. This framework facilitates efficient and reliable trajectory planning around obstacles using convex optimization techniques. By leveraging GCS methods for finding shortest paths, the algorithm incorporates a convex relaxation based on linear programming (LP) or second-order cone programming (SOCP), coupled with a randomized rounding algorithm. This approach ensures the determination of a globally optimal collision-free path. However, it is noteworthy that this method is applicable only to static obstacle scenarios.

In recent years, with the development of commercial solvers, the optimization-based path planning methods have gradually achieved very low time consumption and high success rates. However, most of these successful outcomes require the algorithms to pre-compute the current working environment during the offline stage, and the manipulator must wait for the solver to finish solving the objective function before it can react. Therefore, the optimization-based path planning methods are not suitable for highly-dynamic environments.

Except for the sampling-based, the graph-based searching, and the optimization-based methods, another group of related work is on the local re-planning strategy, which was proposed to address dynamic obstacles. A common approach is to utilize the RRT algorithm and its variants for local replanning (\cite{2006_ICRA_Replanning_with_rrts}, \cite{2021_RSJ_Robotic_lime_picking_by_considering}). For a path temporarily blocked by a dynamic obstacle, \cite{2023_RAL_Path_Re_Planning_Design} proposed to delete the nodes that detected collisions and replan using the APF and RRT with the current point as the root node and any point in the original path after the collision as the connecting target. Similarly, \cite{2013_ASCC_VF_RRT} proposed an RRT-based algorithm for re-sampling using a potential field, called Vector Field RRT (VF-RRT), which dynamically balances the weights of the random sampling and the potential energy sampling based on the space occupied by obstacles. This method preserved the benefits of paths based on the potential energy sampling while avoiding local minima. However, efforts to adapt sampling-based methods for dynamic environments encounter significant challenges. These adaptations often either perform worse than the original sampling-based approaches in terms of time consumption and path quality, or fail to achieve effective dynamic obstacle avoidance. These phenomena validated that these methods are inherently not suitable for dynamic scenarios, because, for instance, they might only achieve end-effector avoidance without addressing real-time obstacle dynamics effectively.

Recently, besides using re-planning methods, a method based on the modulated dynamic system (DS) (\cite{2012_AR_DS}) has been proposed for reactive motion planning (\cite{2024_IJRR_ReactiveMPC}). This method defines a vector field to guide the motion of the manipulator while employing a dynamic modulation matrix to update the vector field in real time. Furthermore, a reactive collision-free motion generation method which combines the dynamic modulation system with sampling-based Model Predictive Control (MPC) has been proposed. By optimizing the real-time dynamic modulation matrix through sampling-based MPC, this approach ensures that the vector field does not fall into local minima near non-convex obstacles. However, the calculation of the dynamic modulation matrix for complex and highly-dynamic environments is still a bottle-neck for real-time update, leading to a only 20Hz frequency loop, which is fall behind the unconditioned reflex reaction time of humans.

The last group of related work is about the SDF-based motion planning algorithms. As stated before, the aforementioned approaches are all based on explicit representation methods, in which a time-consuming searching for the obstacle avoidance velocity is inevitable. The time-consuming searching makes it impossible to generate real-time reflexes for highly-dynamic events. To overcome the time-consuming issue of explicit methods, the SDF is introduced since it can replace the time-consuming searching by a highly-efficient querying on the pre-computed SDF table at runtime. However, the articulated objects, e.g., manipulators, bring challenges to the pre-computation of the SDF.

To bridge this gap, two possible solutions are proposed. In the first one, the global SDF is defined over the space instead of different objects. In this way, the space is discretized into a group of voxels and the SDF is updated over each voxel by considering all objects. For example, \cite{2016_ICRA_Considering_avoidance_and_consistency_in_motion_planning} introduced two occupancy grids over the space, to record occupancy over time for both a robot and human collaborator.
%These occupancy grids are used to define two cost functions for a trajectory optimizer to plan a human-avoiding reaching motion for better human-robot collaboration.
Furthermore, \cite{2021_PICAPS_Predicted_composite_signed-distance_fields} demonstrated that the global SDF value over a specific voxel can be superposed by all the object SDFs using a $min$ operation, resulting in a composite SDF.
This solution avoids the pre-computation for articulated objects. Instead, it requires to update the SDF values over all voxels in the space. For a space with sparse objects, this update is faster than the collision check by utilizing explicit representation methods. Thus this solution has achieved success in human-robot collaboration and real-time motion planning in dynamic environments.
However, this solution brings dimensional explosion problem. It is difficult to tune a proper resolution to discretize the space. To guarantee the obstacle avoidance for all objects, the resolution has to be chosen as the highest one. With the improvement of precision requirements, the computation time of the global SDF update is greatly increased.

The other solution is to store the SDFs in a neural network by utilizing learning approaches. For example, \cite{2024_ICRA_dynamic_neural_fields_for_robot_self-modeling}, \cite{2022_SR_Fully_body_visual_self_modeling} presented a full-body visual self-modeling approach that captures the entire robot morphology and kinematics using a single implicit neural representation, i.e., a global SDF to answer queries as to whether a spatial position $\left(x, y, z\right)$ will be occupied if the joints move to some specified angles. Similarly, \cite{2024_arxiv_CDF} proposed to plan in the robot configuration space, in which a neural Configuration-space Distance Filed (CDF) representation is introduced and computed by using Multilayer Perceptrons (MLPs).
Another two approaches were proposed by \cite{2022_RAL_Neural_joint_space_implicit} and \cite{2022_RSJ_Regularized_deep_signed_distance_fields}, respectively. \cite{2022_RAL_Neural_joint_space_implicit} utilized model files such as URDF to collect distance data from points in space relative to the surface of the manipulation under different configurations, generating and storing a state-indexed full-body SDF for the manipulation within a neural network. \cite{2022_RSJ_Regularized_deep_signed_distance_fields} utilized point cloud data from the manipulation in various configurations. By expanding outward along the normal direction of each surface point on the object, they obtained a series of distance contours. These contour points were then used as training data to generate a neural network that models the full-body SDF of the manipulation. However, only the manipulator is modeled and the information about the dynamic environment is missing in these two approaches.
By using learning approaches, all the signed distanced functions, which are indexed by states, are generated and stored in a neural network. When a query is requested, the current states, e.g., the joint angles of the manipulator, together with the spatial locations, are provided as inputs to the neural network to get the occupancy information.
However, the learning approaches exhibit poor interpretability and generalizability. Generally, this solution requires a tedious and costly offline stage to collect extensive labeled data for a specific scenarios. When the robot faces a new scene, the data collection and the training process require to redo to obtain a new neural network. Thus it is difficult to be applied in highly-dynamic scenarios where the scene changes frequently.