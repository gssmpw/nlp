\paragraph{Algorithm}
we adapt and modify the Bellman-Ford algorithm which use a dynamic programming approach. The main goal is to handle the minima cost within all considered criteria.

\begin{algorithm}
\caption{Multi-shortest-path}
\begin{algorithmic}[1]
    \Function{Multi-shortest-path}{$G = \{E,V\}, source$}
        \State {\# Initialization}
        \For{each $V$ in $G$}
            \State$D_v \gets \phi$
        \EndFor
        \State$D_{source} \gets \{0\}$
        %\State$t_s \gets$add a terminal point
        
        \State {\# Bellman-Ford algorithm.}
        \For{$i \gets 1$ to $v-1$}
            \For{each $E$}
                (x, y belong to E)
                \State update($D_y, (D_x, T_{xy})$)
            \EndFor
            \State$D_y \gets$dominate($D_y$)
        \EndFor
        \State \Return$D$
    \EndFunction
\end{algorithmic}
\end{algorithm}

\begin{figure}[ht!]
\centering
\includegraphics[width=60mm]{structure.png}
\caption{Schematic diagram for using Use $u$ to relax the distance of $\overline{sv}$ \label{structure}}
\end{figure}

Considering multiple cost criteria, algorithm2 computes the shortest paths from a given source vertex to all other vertices in a graph. The distance list $D_v$ represents the set of target points for reaching vertex $v$ from the source vertex. Initially, all item in $D_v$ are empty except for the source vertex. We set the distance to itself $D_s$ as zero for all cost dimensions. 

Secondly, it employs a modified version of the Bellman-Ford algorithm. During each iteration, it iterates over the vertices excluding the source and conducts a tailored merging process, for each edge $(x, y)$ in the graph, performs an update operation. The update operation extends the $D_y$for the destination vertex $y$ by combining the distance from the source vertex $x$ with the cost of the current edge $(x, y)$ and pruning step. Let $f^\prime (u, \ell - 1) = update(f(u, \ell - 1), d(u, v))$, which means update $D_u$ by connect with edge $\overline{uv}$
\todo{use "update" in pseudo code might be confused with the dp equation}
\begin{equation}
\begin{aligned}
f(v, \ell) = prune_{u \in \text{in}(v)}(\text{concatenate}\left(f^\prime (u, \ell - 1)) ,f(v, \ell - 1)\right)
\end{aligned}
\end{equation}

\textbf {concatenate} 

The concatenate operation is responsible for updating the distance $D$ estimate f(v, $\ell$) for a target vertex v at iteration $\ell$ by combining the distance estimates f(u, $\ell$ - 1) from the source to all vertices u that have an incoming edge to v (denoted by u $\in$ in(v)), with the respective costs d(u, v) of the edges from u to v. The f(u, $\ell$ - 1) represents the distance estimate from the source to the vertex u at the previous iteration $\ell$ - 1. Based on the Bellman-Ford algorithm, the concatenate operation uses the distance estimate f(u, $\ell$ - 1) from the source to u to update or "relax" the cost or distance estimate f(v, $\ell$) for the target vertex v. It considers all possible paths from adjacent vertices to v through u, accumulating the distances along the way.\\

\textbf {prune} 
 
After obtaining the distances through the concatenate operation. The prune operation is employed to refine the distances estimate f(v, $\ell$) for a vertex v at iteration $\ell$ by comparing the trade-offs between the current estimate f(v, $\ell$ - 1) and the newly merged distances from the adjacent vertices u $\in$ in(v). It then iterates through the sorted list, ensures that the distance list remains compact and efficient by retaining only the dominant points that represent the most significant trade-offs in the multi-dimensional space.  


\todo {whether we need to add table size control}
Additionally, if the size of the pruned distance list exceeds a specified limit, the prune function further reduces the list by sampling a fixed number of points at equal intervals, preserving the overall shape of the cost curve while limiting its size. This sampling process helps manage the size of the distance lists and ensures efficiency in subsequent calculations.
% Once all edges have been processed, the algorithm returns the list of distance $D$. These distance capture the trade-offs between different cost criteria and can be used for efficient decision-making in various scenarios, such as transportation or communication networks, where multiple cost factors influence path selection.

\begin{algorithm}
\caption{Backtracking Algorithm}
\begin{algorithmic}[1]
    \Function{backtracking}{$S, T, D$}
        \State paths$\gets$[]
        \For{$u$ belongs to$D_T$}
            \State path$\gets$[]
            \State$v \gets T$
            \While{$v \neq S$}
                \State path.add($u$)
                \State cost$\gets$get edge cost($v, u$)
                \For{each$i$belongs to$D_u$}
                    \If{cost$v ==$cost$u +$cost}
                        \State find parent if cost$v ==$cost$u +$cost
                        \State$v \gets u$
                        \State$u \gets i$
                    \EndIf
                \EndFor
            \EndWhile
            \State paths.add(path)
        \EndFor
        \State \Return paths
    \EndFunction
\end{algorithmic}
\end{algorithm}

The Backtracking Algorithm is used to find paths in a graph from a target vertex back to a source vertex, given certain constraints. The algorithm operates by exploring possible paths starting from each vertex in a set of destination vertices $D_T$, backtracking to the source vertex $S$. For each destination vertex $u$ in the set $D_T$, the algorithm initiates a search for a path by traversing edges backward from $u$ to $S$. It does so by iterative examining edges and their associated costs, identifying the parent vertex that minimizes the total cost to reach $u$ from $S$. This process continues until the source vertex $S$ is reached. The algorithm then records the discovered path and proceeds to explore paths from other destination vertices. Once all possible paths have been explored, the algorithm returns the collected paths. This approach is useful for various applications, including finding optimal routes in transportation networks or identifying dependencies in computational tasks.