\section{Optimal Selection Code}
\label{sec:optimal_selection_computation}

In this section we provide the actual code used to compute the optimal selection.

\begin{lstlisting}[language=Python]
import numpy as np
from scipy.spatial.distance import cdist

def solve_local_search_min_dist_normalized(
    vectors: np.ndarray,
    rating: np.ndarray,
    k: int,
    max_iter: int = 100,
    random_seed: int = 42
):
    # Normalize ratings
    rating_min = np.min(rating)
    rating_max = np.max(rating)
    rating_normalized = (rating - rating_min) / (rating_max - rating_min) if rating_max > rating_min else np.zeros_like(rating) + 0.5  

    # Identify top-rated point
    excluded_top_index = int(np.argmax(rating_normalized))

    # Reduce dataset
    new_to_old = [idx for idx in range(len(rating_normalized)) if idx != excluded_top_index]
    vectors_reduced = np.delete(vectors, excluded_top_index, axis=0)
    rating_reduced = np.delete(rating_normalized, excluded_top_index)

    # Compute L2 distances and normalize
    if len(rating_reduced) == 0:
        return excluded_top_index, None, [], [], []
    distance_matrix = cdist(vectors_reduced, vectors_reduced, metric='euclidean')
    distance_matrix /= distance_matrix.max() if distance_matrix.max() > 1e-12 else 1

    # Compute weights
    mean_rating_reduced = np.mean(rating_reduced)
    w = np.exp(mean_rating_reduced - rating_reduced)

    # Local search setup
    def compute_objective(chosen_set):
        return sum(w[i] * min(distance_matrix[i, j] for j in chosen_set) for i in range(len(w)))

    rng = np.random.default_rng(random_seed)
    all_indices = np.arange(len(rating_reduced))
    current_set = set(rng.choice(all_indices, size=k, replace=False)) if k < len(rating_reduced) else set(all_indices)
    current_cost = compute_objective(current_set)

    # Local search loop
    improved = True
    while improved:
        improved = False
        best_swap = (None, None, 0)
        for j_out in list(current_set):
            for j_in in all_indices:
                if j_in not in current_set:
                    candidate_set = (current_set - {j_out}) | {j_in}
                    improvement = current_cost - compute_objective(candidate_set)
                    if improvement > best_swap[2]:
                        best_swap = (j_out, j_in, improvement)
        if best_swap[2] > 1e-12:
            current_set.remove(best_swap[0])
            current_set.add(best_swap[1])
            current_cost -= best_swap[2]
            improved = True

    chosen_indices_original = [new_to_old[j] for j in sorted(current_set)]
    rejected_indices_original = [new_to_old[j] for j in sorted(set(all_indices) - current_set)]
    return excluded_top_index, chosen_indices_original[0], rejected_indices_original[:k], chosen_indices_original, rejected_indices_original
\end{lstlisting}