This section presents an informal description
how cross-chain coordination works in practice,
with the goal of motivating the formal model presented in the next section.

A \emph{distributed ledger}\footnote{
Following common usage, we use ``ledgers'', ``chains'', and ``blockchains''
interchangeably in informal discourse,
even though ledgers need not be implemented using blockchain technology.
} is a publicly-readable tamper-proof distributed database
used to track ownership of  \emph{assets},
which may be cryptocurrencies,
financial instruments, tokens, concert tickets,
or any data of value.
%Our discussion here is independent of which technology is used to implement a ledger.

\emph{Parties} own \emph{assets}.
A party can be a person, an organization, or even a bot acting on another party's behalf.
Parties are untrustworthy:
they may depart from any agreed-upon protocol in arbitrary ways,
including irrational ways that work against their own interests.
We assume only that every interaction includes at least one honest party who faithfully follows the agreed-upon protocol. 
While it is reasonable to assume, for example,
that a super-majority of the validators securing a blockchain are honest,
it is not reasonable (or prudent) to assume the same for a small number
of parties willing to participate in a one-shot financial transaction or other distributed task.
 
Parties may own assets controlled by one or more ledgers.
Parties are active agents, initiating and reacting to communication,
although parties do no typically communicate directly with other parties.
Instead,
interactions among parties are mediated by \emph{smart contracts}.
Each smart contract resides on a single ledger,
and different smart contracts may reside on different ledgers.
Contracts are automata that change state
in response to authenticated messages from parties. These messages are  structured as calls to functions exported by contracts.
The code of a smart contract must be deterministic, because it is repeatedly re-executed by mutually-suspicious parties
to check the correctness of earlier executions.\footnote{Even so-called ``probabilistic smart contracts''~\cite{ChatterjeeGP2019}
are actually deterministic because once they are written to the ledger,
they return the same results when re-executed.}

A smart contract's code and current state are public,
so a party calling a contract knows what code will be executed,
and trusts the contract to execute that code correctly.\footnote{Concurrent
calls to the same contract may be executed in
a non-deterministic order.}
Since the state of a smart contract is public,
a party can read a contract's state at any time.

In accordance with current practice,  contracts are passive:
a contract on one ledger cannot send messages directly to  a contract on another ledger
(because such network communications cannot be deterministically replayed). 
A contract $A$ on one chain can learn of a state change of
a contract $B$ on another chain only if some party explicitly
informs $A$ of $B$'s change,
perhaps accompanied by evidence that the informing party is honest.
For ease of exposition and without loss of generality,
we will assume that distinct smart contracts reside
on distinct ledgers.

A  \emph{cross-chain task} (or \emph{task} for short) specifies the problem that   multiple parties want to solve.
For example,
Alice, Bob, and Carol might agree to do a three-way token swap,
where each token is managed on a distinct ledger.
Alice will transfer token $A$ to Bob,
Bob will transfer token $B$ to Carol,
and Carol will transfer token $C$ to Alice.

A \emph{cross-chain protocol} is a sequence of actions for each party  to solve a cross-chain task.
Honest parties who follow the protocol are said to be \emph{compliant},
while dishonest parties who do not follow the protocol are said to be \emph{deviating}.
A party's compliance can often be monitored by the other parties,
but never enforced.
Unlike most conventional agreement protocols in Byzantine models,
we do not assume that a supermajority of participants is honest.
Instead,
we assume only that there is at least one compliant party in every protocol execution
(because
executions without compliant parties are not interesting).
While it is reasonable to assume, for example,
that a super-majority of the validators securing a blockchain are honest,
it is not reasonable (or prudent) to assume the same for a small number
of parties willing to participate in a particular financial transaction.

In our swap example,
Alice, Bob, and Carol take turns placing their assets into escrow
(by calling the distinct contracts managing the distinct asset types),
and when all assets are safely escrowed,
each party triggers a transfer from its counterparty. 
If some party deviates from the protocol,
then either all transfers are canceled,
or the deviating party loses its own asset.
See~\cite{Herlihy2018} for a complete protocol description,
and~\secref{example} for a two-party swap protocol.

The swap task's \emph{input party vector} describes who wants to transfer what to whom.
It makes sense for these inputs to be controlled by the participating parties. 
The task's \emph{input contract vector} describes who who owns which assets at the start.
The task's \emph{output contract vector} describes how asset ownership has changed:
who transferred what to whom.
It makes sense for these outputs to be controlled by the  contracts,
not the parties.
(In real life, banks, not their customers,
have the final word on customer account balances.)

What does it mean for a protocol to correctly implement a task?
By analogy with mainstream distributed computing,
we might naively require a correct protocol to be \emph{all-or-nothing}:
either all intended transfers take place, or none does,
a property also known as \emph{atomicity}.
While doing nothing should always be a legitimate course of action when things go wrong,
it may not always be possible.
Because parties can depart arbitrarily (and even irrationally) from the protocol,
we cannot prevent, for example, 
Alice from sending Bob two tokens instead of one.
Bob, if he is rational, will pocket the extra token and continue the protocol.
(Perhaps Alice and Bob are secretly laundering assets.)
In the end, Alice has one token less than the task specifies,
and Bob has one token more.
Here is a protocol outcome that is neither ``all'' nor ``nothing'',
yet this outcome is perfectly acceptable to the conforming party Bob.

It follows that when defining correctness in the cross-chain world,
it will be helpful to borrow
some elementary notions from game theory.

A party's \emph{utility} in an execution is a quantitative
measure of how much that party considers itself to be better
or worse of after the execution.
A configuration
is in a \emph{Nash equilibrium} if no party can increase its
utility by deviating while the other parties remain compliant.
Ensuring that a protocol is in Nash equilibrium is
necessary, but not sufficient.
A \emph{Sybil attack} occurs when one individual or organization
secretly controls a \emph{coalition} of multiple parties.
The controller may be willing to incur a small loss of utility
for one coalition member in return for a larger gain for another.
For this reason,
common sense demands that
protocols should be in Nash equilibrium across coalitions:
no coalition can increase its collective utility by deviating
while the other parties remain compliant\footnote{
This condition is not the same as a \emph{strong Nash equilibrium}~\cite{StrongNashEquilibrium},
which requires \emph{all} coalition members to gain utility by deviating.}.

No rational party would agree to participate in a protocol
that did not satisfy the following common-sense conditions:
\begin{itemize}
\item
  \emph{Coalition Nash Equilibrium}:
  No coalition of parties can increase its collective utility by deviating from the protocol
  while the others comply.

\item
  \emph{Liveness}:
  If all parties are compliant,
  then all and only agreed-upon asset transfers take place.
  
\item
  \emph{Safety}: No compliant party can end up ``worse off'',
  even if other parties deviate from the protocol\footnote{
  We treat as negligible costs in transaction fees and wasted time incurred by failed exchanges.
  In practice,
  some protocols compensate jilted parties~\cite{XueH2021} while others do not.}.
\end{itemize}
These conditions will be restated formally in the next section.

Operationally,
a cross-chain protocol is executed as follows.
Communication between parties and contracts occurs in synchronous rounds.  
Each round has four phases: 
\begin{enumerate}
\item 
  Parties optionally send messages to contracts;
\item
  The contacts receive messages (possibly sent in earlier rounds)
  and execute local computations;
\item 
  Parties read the contracts' new states;
\item 
  Parties execute local computations based on the states read and optionally prepare messages for the next round. 
\end{enumerate}
Message delivery may be delayed by congestion in the network, or in a chain's consensus protocol.
Different chains may accept messages at different rates.
(Most chains allow parties to pay higher fees to request speedier message delivery.)

Nevertheless,
we do assume that there is a known bound
on the number of rounds it takes for a message to be delivered on any chain.
It is usually convenient to express delay bounds in terms of time and clocks,
rather than rounds and round numbers.
Most blockchains produce new blocks at a more-or-less constant rate,
so the current block number is often used as a proxy for the current time.
We assume there is a known duration $\Delta > 0$
such that any message sent by a party to a contract
will be received, processed by the contract,
and observed by the other parties,
within duration $\Delta$.

The model encompasses synchronous execution with a known upper bound on message delivery delay
because this is the model currently presented by distributed ledgers such as
Bitcoin, Ethereum, Cardano, and others.
Timing upper bounds are important in practice because many decentralized finance protocols
 involve some form of \emph{escrow},
where a contract assumes temporary control of an asset that is intended to change hands.
(See, for example, the two-party swap example in \secref{example}.)
To be effective, each escrow needs an appropriate timeout:
if the exchange fails to complete in a reasonable amount of time,
the escrowed asset should be refunded to its original owner.
An asset should not be refunded prematurely (compromising liveness)
or held in escrow forever (compromising safety).

Because contracts cannot send messages to one another, they cannot directly observe one another's states.\footnote{In practice,
contracts \emph{on the same chain} can call one another, but we are interested in problems
where the contracts reside on distinct chains.}
Deviating parties may communicate with one another through channels
hidden from compliant parties.
Failure to send a protocol message is detected by a timeout. 
In  \secref{formal} we will define in more detail the model including timing assumptions.
