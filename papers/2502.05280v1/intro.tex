The rise of decentralized finance and distributed ledger
technology presents both an opportunity and a challenge
to the distributed computing community.

The \emph{opportunity}: decentralized finance based on blockchains
has become a multi-billion dollar industry,
providing what seems to be an ideal application for the kinds of
fault-tolerant distributed algorithms and protocols
the distributed computing community has studied for decades.
Specific companies and cryptocurrencies may come and go,
but the ancient problem of how mutually untrusting parties can securely and efficiently exchange
valuable assets will only grow in importance as the world becomes more interconnected.

The \emph{challenge}:
classical 
 shared-memory and message-passing models
do not accurately mirror the realities of blockchains and smart contracts.
This paper proposes the \emph{smart contract model},
which we hope will help in adapting protocols and algorithms
from classical distributed computing to the world of decentralized, tamper-proof ledgers.
Our focus is on \emph{cross-chain} protocols
executed by a collection of active parties, some who follow the protocol, and some who might not.
interacting through shared smart contracts deployed on different blockchains. 

The smart contract model borrows from classical distributed computing models,
but it differs in some essential ways.
For example, in classical models,
a task is specified by its inputs and outputs.
Each process chooses an input,
and after communicating with the others via shared memory or messages,
it chooses an output consistent with the task specification.
In shared-memory models, 
shared objects typically keep track of a protocol's state as it executes.

By contrast,
while cross-chain protocols are capable of general computations,
they are primarily used to track ownership of assets
such as cryptocurrencies or other valuable data with a digital representation.
Smart contracts implement the ledgers that control
asset ownership.
Contracts are trusted, deterministic automata that change state in response
to authenticated messages from parties.

To carry out a task,
the parties agree on \emph{protocol}:
a sequence of steps for exchanging their assets.
\emph{Compliant} parties follow the agreed-upon protocol,
while \emph{deviating} parties can depart from the protocol in arbitrary ways.
No party can assume another will be compliant,
so any protocol must be designed to ensure both \emph{safety}:
no compliant party ends up worse off than it started,
and \emph{liveness}:
if all parties comply, all parties end up better off.

Because parties are autonomous (not under the protocol's control)
and potentially deviating,
tasks to be solved are formulated using elementary game-theoretic notions,
expressed in terms of the utility to each party of each possible outcome.
As in the classical model, the parties provide the inputs,
typically expressed as an agreed-upon sequence of proposed asset transfers.
Because some parties may deviate,
the transfers that actually take place may
differ from those agreed upon.
In the end, unlike in the classical model,
the \emph{contracts}, not the parties,
decide task outputs in the form of executed asset transfers,
since the contracts alone are trusted to control ownership of valuable assets.

The contracts are similar to shared objects in shared-memory distributed computing.
They are  deterministic state machines, 
but unlike the parties,
they are trustworthy.
Contract state and contract code are observable by any party,
since that state is replicated on multiple public repositories.
For example,
in an \emph{atomic cross-chain swap} task,
where two parties exchange assets that
reside on distinct ledgers.
The protocol must guarantee that if both parties conform to the protocol, 
then the swap takes place.
If one party deviates,
the other conforming party ends up no worse off than it started.
