This section presents
the \emph{smart contract model}.
It formally defines the notion of parties, contracts, tasks, and protocols.

\subsection{Cross-chain Systems}
\seclabel{crosschain_model}
 A \emph{cross-chain system} $CCS=(\cP,\cC)$ is composed of a finite set of \emph{parties} $\cP=\{P_1, \ldots, P_m\}$, $m \geq 2$ and a finite set of \emph{smart contracts} $\cC=\{C_1, \ldots, C_n\}$, $n \geq 2$. 
 
Parties and smart contracts are both modeled as \emph{interface automata}~\cite{AlfaroH01}.
 An interface automaton is a tuple $IA=(V, V^{init}, \cA^I, \cA^O, \cA^H, \cT)$  where:
 \begin{itemize}
     \item $V$ is a set of states;
     \item $V^{init} \subseteq V$ is a set of initial states;
     \item $\cA^I$, $\cA^O$, $\cA^H$ are mutually disjoint sets of input, output and internal actions;
     \item $\cT \subseteq V \times \cA \times V$ is the set of steps where $\cA=\cA^I \cup \cA^O \cup \cA^H$   
 \end{itemize}
An action $a \in \cA$ is \emph{enabled} at some state $v \in V$ if there is a step $(v,a,v^\prime) \in \cT$ for some $v^\prime \in V$.
An \emph{execution fragment}  of an interface automaton is a finite sequence of alternate states and enabled actions $v_0,a_0,v_1,a_1,v_2 \ldots v_{t-1},a_{t-1},v_t$ such that $(v_i,a_i,v_{i+1}) \in \cT$,$  \forall i \in \{0, \dots, t-1\}$.

 Let $IA_P=(V_P, V_P^{init}, \cA_P^I, \cA_P^O, \cA_P^H, \cT_P)$ be the interface automaton of party $P \in \cP$ and $IA_C=(V_C, V_C^{init}, \cA_C^I, \cA_C^O, \cA_C^H, \cT_C)$ be the interface automaton of a smart contract $C \in \cC$. 
 Let $Shared(\cA_P, \cA_C)=\cA_P \cap \cA_C$ be the common actions of $IA_P$ and $IA_C$. 
 $IA_P$ and $IA_C$ are \emph{composable} if the following four properties hold:
 \begin{align*}
   \cA_P^I \cap \cA_C^I &= \emptyset\\
   \cA_P^O \cap \cA_C^O &= \emptyset\\
   \cA_P^H \cap \cA_C &= \emptyset\\
   \cA_C^H \cap \cA_P = \emptyset
 \end{align*}
 The \emph{product}  of two composable interface automata $IA_P$ and $IA_C$ is the interface automaton
 \begin{align*}
   IA_{P \otimes C}=(&V_P \times V_C,\\
                  &V_P^{init} \times V_C^{init},\\
                  &\cA_P^I \cup \cA_C^I \setminus  Shared(\cA_P, \cA_C),\\
                  &\cA_P^O \cup \cA_C^O \setminus  Shared(\cA_P, \cA_C)\\
                  &\cA_P^H \cup \cA_C^H \cup  Shared(\cA_P, \cA_C),\\
                  &\cT_P \otimes  \cT_C)
    \end{align*}
 where $\cT_P \otimes  \cT_C$ is defined as:
 \begin{equation*}
\cT_P \otimes  \cT_C = TR_P \cup TR_C \cup TR_{PC}
 \end{equation*}
and
 \begin{align*}
 TR_P &=\set{((v,u),a,(v^\prime,u)) \mid (v,a,v^\prime) \in \cT_P \wedge a \notin Shared(P,C) \wedge u \in V_C}\\
 TR_C &=\set{((v,u),a,(v,u^\prime))  \mid  (u,a,u^\prime) \in \cT_C \wedge a \notin Shared(P,C) \wedge v \in V_P}\\
 TR_{PC}&=\set{((v,u),a,(v^\prime,u^\prime))  \mid  (v,a,v^\prime) \in \cT_P \wedge (u,a,u^\prime) \in \cT_C \wedge a \in Shared(P,C)}
 \end{align*}
The interface automaton of a cross-chain system $CCS=(\cP,\cC)$ is 
the composition of the interface automata of parties in $\cP$ and interface automata of smart contracts in $\cC$ as proposed by Alfaro and Henzinger~\cite{AlfaroH01}.
 
 In the sequel if $V$ is a vector, $V[i]$ is $V$'s $i^\text{th}$ element.
If $D$ is a domain, $2^D$ is the powerset of $D$.

\subsection{Cross-chain Tasks}
 
 Given a cross-chain system $\text{CCS}=(\cP,\cC)$ where $\cP$ is a set of $m$ parties  and $\cC$ a set of $n$ smart contracts
 a \emph{cross-chain task} is a tuple $(\cI_P,\cI_C,\cO_C, U)$, where:
 \begin{itemize}
 \item 
   $\cI_P$ is a set of $m$-element \emph{input party vectors},
   representing each party's input to the task,
 \item
   $\cI_C$ is a set of $n$-element \emph{input contract state vectors},
   representing each contract's state before executing the task,
 \item
   $\cO_C$ is a set of $n$-element \emph{output contract state vectors},
   representing each contract's state after executing the task, and
 \item
   $U:  \cI_P \times \cI_C \times \cO_C \to \Reals^m$ is a \emph{utility function}
   that characterizes how each party values each possible transition.
 \end{itemize}
 The utility for an individual party $P$ is written $U(I_P,I_C,O_C)[P]$,
 and the utility for a coalition $\cQ \subset \cP$ is defined to be
 \begin{equation*}
   U(I_P,I_C,O_C)[\cQ] := \sum_{Q \in \cQ} U(I_P,I_C,O_C)[Q].
 \end{equation*}
As mentioned,
the utility function captures the notion of ``better off'' and ``worse off'' for parties.
A \emph{transition} is a triple $(I_P,I_C,O_C) \in \cI_P \times \cI_C \times \cO_C$.
Party $P$ considers transition $(I_P,I_C,O_C)$ \emph{acceptable}
if $U(I_P,I_C,O_C)[P] \geq 0$,
and \emph{preferred} if $U(I_P,I_C,O_C)[P] > 0$.
A transition is \emph{acceptable} if it is acceptable to all parties,
and \emph{preferred} if it is preferred by all parties.

Note that a task's set of output contract states must encompass all reachable output contract states,
even those produced when parties deviate.
Because parties are autonomous (and possibly Byzantine),
a task definition is not expressed in terms of parties' states, 
only in terms of the input values they provide to the task.

For a task to be \emph{feasible} (capable of solution),
it must satisfy certain additional feasibility conditions.
Because deviating parties can always obstruct progress,
the null transition must always be acceptable.
For any input vectors
$I_P \in \cI_P$ and $I_C \in \cI_C$,
\begin{equation}
  \eqnlabel{feas:nothing}
  \cI_C \subset \cO_C \text{ and } (I_P,I_C,I_C) \text{ is an acceptable transition}.
\end{equation}
Each task must be solvable in principle:
for all input vectors $I_P \in \cI_P, I_C \in \cI_C$,
there must exist a preferred transition:
\begin{equation}
  \eqnlabel{feas:prefer}
  \exists O_C \in \cO_C \text{ such that } (I_P,I_C,O_C) \text{ is a preferred transition}.
\end{equation}
A task will have no solution if a deviating party $Q$ can trick a compliant
party $P$ into negative utility simply by lying about $Q$'s input.
For any two input party vectors $I_P, I_P'$, and for every party $P$,
\begin{equation}
  \eqnlabel{feas:inputs}
  \text{if } I_P[P] = I_P'[P] \text{ and } U(I_P,I_C,O_C)[P] \geq 0,
  \text{ then } U(I_P',I_C,O_C)[P] \geq 0.
\end{equation}
A hidden input might shift a compliant party's utility from from one non-negative quantity to another,
but never from non-negative to negative.

\subsection{Cross-chain Protocols}
To execute a task,
parties agree on a sequence of contract calls called a \emph{cross-chain protocol}.

As noted,
compliant parties follow the agreed-upon protocol,
while deviating parties do not.

When describing a protocol execution,
it is convenient to indicate which parties are compliant by a
\emph{compliance set} $\cQ \subset \cP$,
where $P \in \cQ$ means $P$ is compliant.

Formally, given a cross-chain system $CCS=(\cP,\cC)$ where $\cP$ is a set of $m$ parties and $\cC$ is a set of $n$ smart contracts, a cross-chain 
protocol is a tuple $(\cI_P,\cI_C,\cO_C,\Xi)$,
where
\begin{itemize}
\item 
  $\cI_P$ is a set of $m$-element \emph{input party vectors},
\item
  $\cI_C$ is a set of $n$-element \emph{input contract state vectors},
\item
  $\cO_C$ is a set of $n$-element \emph{output contract state vectors},
\item
  $\Xi: \cI_P \times \cI_C \times 2^\cP \to 2^{\cO_C}$,
  the \emph{execution function}, is a map
  that carries a input party vector, an input contract state vector,
  and a compliance set
  to a set of output contract state vectors representing possible outcomes.
\end{itemize}
The protocol itself is the interface automaton obtained by the composition of interface automata modeling parties in $\cP$ and interface automata modeling smart contracts in $\cC$.

The execution of a cross-chain protocol is an execution fragment (see Section \secref{crosschain_model}) starting in a state $(I_P,I_C) \in \cI_P \times \cI_C$ and terminating in a state in $\Xi(I_P,I_C,\cQ)$ where $\cQ \subseteq \cP$ indicates which parties were compliant during the protocol execution.   

A cross-chain protocol for a cross-chain task is \emph{correct} if each execution of the protocol satisfies the following properties:
\begin{itemize}
\item 
\emph{Coalition Nash Equilibrium:}
No coalition of parties can increase its collective utility
by deviating from the protocol while the others comply.
More precisely,
for all coalitions $\cQ \subset \cP$,
input vectors $I_P \in \cI_P, I_C \in \cI_c$,
conforming executions $O_C \in \Xi(I_P, I_C, \cP)$,
and $\cQ$-deviating executions $O_C' \in  \Xi(I_P, I_C, \cP \backslash \cQ)$,
conforming is the better strategy for $\cQ$
\begin{equation*}
U(I_P,I_C,O_C)[\cQ] \geq U(I_P,I_C,O_C')[\cQ].
\end{equation*}        
\item
\emph{Liveness:}
If all parties are compliant
then the protocol's transitions are preferred:
\begin{equation}
  \eqnlabel{protocol:prefer}
  (\forall O_C \in \Xi(I_P,I_C,\cP))\;
  (\forall P \in \cP)\;
  U(I_P,I_C,O_C)[P] > 0
\end{equation}

\item
\emph{Safety:}
  No compliant party ends up worse off:
\begin{equation*}
(\forall O_C \in \Xi(I_P,I_C,\cQ))\;
  (\forall Q \in \cQ)\;
  U(I_P,I_C,O_C)[Q] \geq 0.
  \end{equation*}
\end{itemize}

\subsection{Communication and Timing}
In a cross-chain system $CCS=(\cP,\cC)$,
parties in $\cP$ communicate with contracts in $\cC$ via messages.
Compliant parties do not communicate directly with other parties,
and contracts do not communicate directly with contracts.
Communication channels are \emph{authenticated}: a message's sender cannot be forged,
and \emph{reliable}: a channel does not create, lose, or duplicate messages.

As outlined earlier,
executions proceeds in synchronous rounds.
\begin{enumerate}
\item
  In the \emph{send phase},
  each party optionally sends a message to one or more contracts.
\item
  In the \emph{contract-local phase},
  each contract receives the messages in an arbitrary order
  and undergoes state changes in response.
\item
  In the \emph{read phase}
  each party reads the new contract state.
\item
  In the \emph{party-local phase},
  each party optionally prepares a new message.
\end{enumerate}
