\section{Customizing Models in FairDiverse}
We outline the steps for customizing and evaluating new IR models using the APIs we provide. Detailed API descriptions and source code can be found in~\url{https://xuchen0427.github.io/FairDiverse/}. 
The provided APIs can be used by installing them via pip: 

\begin{lstlisting}[style=shell]
pip install fairdiverse
\end{lstlisting}

%\texttt{pip install fairdiverse}.
%The steps can be easily implemented with just a few lines of code.

\subsection{Steps}
Figure~\ref{fig:rec_APIs} illustrates the three key steps for implementing fairness- and diversity-aware IR models named \textit{YourModel}.

\noindent\textbf{Step 1.} Configure your custom model parameters and save them in a newly created \texttt{YourModel.yaml} file in the \texttt{/properties/models/} directory. Then you can change the model in the running configuration file \texttt{Post-processing.yaml}.

\noindent\textbf{Step 2.} Select the appropriate Python abstract class from our provided options based on your model type and implement your model in a newly created file, \texttt{YourModel.py}, stored in the corresponding directory. You can use the integrated tools and common parameters within the abstract class. Researchers only need to focus on designing the model without worrying about the rest of the pipeline. 

%Different types of models must adhere to the function formats and return value structures defined in the abstract class. 

\noindent\textbf{Step 3.} Configure your model for the training pipeline by following these steps: import your custom model package in the corresponding file (\texttt{/model\_type/\_\_init\_\_.py}) and define the model in the appropriate script (\texttt{/train.py}, \texttt{/reranker.py}).

%The implementation for other models follows a similar approach.

\subsection{Examples}
%\textbf{Examples.} 
Here, we provide two example codes demonstrating how to design a custom search and recommendation model, respectively. 
\begin{lstlisting}[language=Python]
#/recommendation/rank_model/YourModel.py
class YourModel(Abstract_Regularizer):
    def __init__(self, config, group_weight):
        super().__init__(config)

    def fairness_loss(self, input_dict):
        return torch.var(input_dict['scores'])

#/recommendation/rank_model/__init__.py
from .YourModel import YourModel

#/recommendation/trainer.py
if config["model"] == "YourModel":
  self.Model = YourModel(config)
\end{lstlisting}

\begin{lstlisting}[language=Python]
#/search/preprocessing_model/YourModel.py
class YourModel(PreprocessingFairnessIntervention):
    def __init__(self, configs, dataset):
        super().__init__(configs, dataset)

    def fit(self, X_train, run):
    # Train the fairness model using the training set.

    def transform(self, X_train, run file_name=None):
    # Apply the fairness transformation to the dataset.

#/search/preprocessing_model/__init__.py
from .YourModel import YourModel
fairness_method_mapping['YourModel'] = YourModel


\end{lstlisting}



% #test.py
% from recommendation.trainer import RecTrainer

% config = {'model': 'BPR', 'data_type': 'pair', 'fair-rank': True, 'rank_model': 'YourModel', 'use_llm': False, 'log_name': "test", 'dataset': 'steam'}

% trainer = RecTrainer(train_config=config)
% trainer.train()

% \subsection{Search}
% As for the search part, the key steps for implementing a diversified search model named \textit{YourModel}.

%can also refer to Figure~\ref{fig:rec_APIs}.

% \textbf{Step 1.} First, configure your custom model parameters and save them in a newly created \texttt{YourModel.yaml} file within the \texttt{/properties/models/} directory. Then you can change the model in the running configuration file \texttt{Post-processing.yaml}.

% \textbf{Step 2.} Select the appropriate Python abstract class from our provided options based on your model type and implement your model in a newly created file, \texttt{YourModel.py}, stored in the corresponding directory (see Figure~\ref{fig:rec_APIs} for details). Different types of models must adhere to the function formats and return value structures defined in the abstract class. To facilitate development, we have integrated various tools and common parameters within the abstract class. Researchers only need to focus on designing the model itself without worrying about the rest of the pipeline, creating a convenient environment for fair comparisons across different models.


% \textbf{Step 3.} Configure your model for the training pipeline by following these steps: import your custom model package in the corresponding file (\texttt{/model\_type/\_\_init\_\_.py}) and define the model in the appropriate script (\texttt{/train.py}).