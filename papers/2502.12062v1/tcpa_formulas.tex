\usepackage{bm}

\newcommand{\mmat}[1]{\mathbf{#1}}
\newcommand{\mvec}[1]{\bm{#1}}
\newcommand{\mset}[1]{\mathcal{#1}}
\newcommand{\mtrans}{^\intercal}
\newcommand{\mbaseSet}[1]{\mathbb{#1}}
\newcommand{\msetBuilder}[2]{\{{#1}\ |\ {#2}\}}
\newcommand{\mpowerSet}[1]{\mathcal{P}(#1)}

\newcommand{\plaDimension}{n}

\newcommand{\plaGenericVector}[1]{(#1_0, \dots, #1_{\plaDimension - 1})}
\newcommand{\plaSpecificVector}[2]{(#1_0, \dots, #1_{#2}, \dots, #1_{\plaDimension - 1})}
\newcommand{\plaDimensionVector}[2]{#1_0 \times \dots \times #1_{#2} \times \dots \times #1_{\plaDimension - 1}}

\newcommand{\plaIteration}{\mvec{i}}
\newcommand{\plaIntraIteration}{\mvec{j}}
\newcommand{\plaInterIteration}{\mvec{k}}
\newcommand{\plaTiledIteration}{\mvec{i}^*}

\newcommand{\plaIterationElement}{i}
\newcommand{\plaIntraIterationElement}{j}
\newcommand{\plaInterIterationElement}{k}
\newcommand{\plaTiledIterationElement}{i*}

\newcommand{\plaIterationSpace}{\mset{I}}
\newcommand{\plaIterationSpaceDefinition}{\plaIterationSpace \subseteq \mbaseSet{Z}^\plaDimension}
\newcommand{\plaIterationLongDefinition}{\plaIteration=\plaGenericVector{i}\mtrans \in \plaIterationSpace}
\newcommand{\plaIterationDefinition}{\plaIteration \in \plaIterationSpace}

\newcommand{\plaEquation}[1][i]{S_{#1}}
\newcommand{\plaEquationSpace}{\mset{S}}
\newcommand{\plaEquationDomain}[1][i]{\mset{I}_{#1}}
\newcommand{\plaEquationSpaceDefinition}{\plaEquationSpace = \{\plaEquation[0], \plaEquation[1], \dots\}}
\newcommand{\plaOperation}[1][i]{F_{#1}}
\newcommand{\plaOperationArity}[1][i]{1 \le j \le \text{arity}(\plaOperation[#1])}

\newcommand{\plaWriteIndexingFunctionMatrix}[1][i]{\mmat{P}_{#1}}
\newcommand{\plaWriteIndexingFunctionOffset}[1][i]{\mvec{f}_{#1}}
\newcommand{\plaWriteIndexingFunction}[1][i]{\plaWriteIndexingFunctionMatrix[#1]\plaIteration + \plaWriteIndexingFunctionOffset[#1]}

\newcommand{\plaReadIndexingFunctionMatrix}[1][{i, j}]{\mmat{Q}_{#1}}
\newcommand{\plaReadIndexingFunctionOffset}[1][{i, j}]{\mvec{d}_{#1}}
\newcommand{\plaReadIndexingFunction}[1][{i, j}]{\plaReadIndexingFunctionMatrix[#1]\plaIteration - \plaReadIndexingFunctionOffset[#1]}

\newcommand{\plaVariable}[1]{#1}
\newcommand{\plaVariableSpace}{\mset{X}}

\newcommand{\plaInputVariableSpace}{\plaVariableSpace_{\text{in}}}
\newcommand{\plaInputVariableSpaceDefinition}{\plaInputVariableSpace= \msetBuilder{\plaVariable{x} \in \plaVariableSpace}{\nexists i_x: \plaVariable{x}_{i_x} = \plaVariable{x} \land \exists! {i_x}, {j_x}: \plaVariable{y}_{{i_x}, {j_x}} = \plaVariable{x}}}
\newcommand{\plaOutputVariableSpace}{\plaVariableSpace_{\text{out}}}
\newcommand{\plaOutputVariableSpaceDefinition}{\plaOutputVariableSpace= \msetBuilder{\plaVariable{x} \in \plaVariableSpace}{\exists! {i_x}: \plaVariable{x}_{i_x} = \plaVariable{x} \land \nexists {i_x}, {j_x}: \plaVariable{y}_{{i_x}, {j_x}} = \plaVariable{x}}}


\newcommand{\plaInternalVariableSpace}{\plaVariableSpace_{\text{var}}}
\newcommand{\plaInternalVariableSpaceDefinition}{\plaInternalVariableSpace= \plaVariableSpace \setminus \plaInputVariableSpace \setminus \plaOutputVariableSpace}

\newcommand{\plaIOVariableSpace}{\plaVariableSpace_{\text{I/O}}}
\newcommand{\plaIOVariableSpaceDefinition}{\plaIOVariableSpace = \plaInputVariableSpace \cup \plaOutputVariableSpace}

\newcommand{\plaInternalVariableWriteConstraints}{%
    \plaWriteIndexingFunctionMatrix \in \begin{cases}%
        \{\text{diag}(1, \dots, 1)\} & x_i \in \plaInternalVariableSpace\\
        \mbaseSet{Z}^{m\times n} & \text{else}
    \end{cases}%
}
\newcommand{\plaInternalVariableReadConstraints}{%
    \plaReadIndexingFunctionMatrix \in \begin{cases}%
        \{\text{diag}(1, \dots, 1)\} & y_{i, j} \in \plaInternalVariableSpace\\
        \mbaseSet{Z}^{m\times n} & \text{else}
    \end{cases}%
}

\newcommand{\plaVariableAt}[2]{\plaVariable{#1}[#2]}

\newcommand{\plaEquationDefinition}{\plaEquation[i]: \plaVariableAt{x_i}{\plaWriteIndexingFunction} = \plaOperation[i](\dots, \plaVariableAt{y_{i, j}}{\plaReadIndexingFunction}, \dots) \quad \text{if } \plaIteration \in \plaEquationDomain[i]}

\newcommand{\plaTileSizes}{\mvec{p}}
\newcommand{\plaTileSize}{p}
\newcommand{\plaTileSizesDefinition}{\plaTileSizes = \plaSpecificVector{\plaTileSize}{i}}
\newcommand{\plaTileSizesDimension}{\plaDimensionVector{\plaTileSize}{i}}

\newcommand{\plaIntra}{^j}
\newcommand{\plaInter}{^k}
\newcommand{\plaTiled}{^*}

\newcommand{\plaTileCounts}{\mvec{t}}
\newcommand{\plaTileCount}{t}
\newcommand{\plaTileCountsDefinition}{\plaTileCounts = \plaSpecificVector{\plaTileCount}{i}}
\newcommand{\plaTileCountsDimension}{\plaDimensionVector{\plaTileCount}{i}}

\newcommand{\plaIntraIterationSpace}{\mset{J}}
\newcommand{\plaIntraIterationSpaceDefinition}{\plaIntraIterationSpace = \msetBuilder{\plaIntraIteration=\plaSpecificVector{\plaIntraIterationElement}{i}\mtrans}{0 \le \plaIntraIterationElement_i < \plaTileSize_i}}
\newcommand{\plaInterIterationSpace}{\mset{K}}
\newcommand{\plaInterIterationSpaceDefinition}{\plaInterIterationSpace = \msetBuilder{\plaInterIteration=\plaSpecificVector{\plaInterIterationElement}{i}\mtrans}{0 \le \plaInterIterationElement_i < \plaTileCount_i}}

\newcommand{\plaTiledIterationSpace}{\mset{I}^*}
\newcommand{\plaTiledIterationSpaceDefinition}{\plaTiledIterationSpace=\msetBuilder{\plaTiledIteration=(\plaIntraIteration\mtrans, \plaInterIteration\mtrans)\mtrans}{\plaIntraIteration \in \plaIntraIterationSpace \land \plaInterIteration \in \plaInterIterationSpace}}

\newcommand{\plaTilingOperation}{\theta}
\newcommand{\plaTilingOperationDefinition}{\plaTilingOperation: \plaIterationSpace \rightarrow \plaTiledIterationSpace}
\newcommand{\plaInverseTilingOperation}{\theta^{-1}}

\newcommand{\plaScheduleVector}{\mvec{\lambda}}
\newcommand{\plaTiledIntraScheduleVector}{\mvec{\lambda}\plaIntra}
\newcommand{\plaTiledInterScheduleVector}{\mvec{\lambda}\plaInter}
\newcommand{\plaTiledScheduleVector}{\mvec{\lambda^*}}
\newcommand{\plaTiledScheduleVectorDefinition}{\mvec{\lambda^*} = (\plaTiledIntraScheduleVector, \plaTiledInterScheduleVector)}
\newcommand{\plaScheduleOperationStartTime}[1][i]{\tau_{#1}}
\newcommand{\plaScheduleOperationExecutionTime}[1][i]{\delta_{#1}}
\newcommand{\plaScheduleOperationScheduleTime}{t_{\plaTiledIteration, i}}
\newcommand{\plaScheduleOperationScheduleTimeDefinition}{\plaScheduleOperationScheduleTime = \plaTiledScheduleVector\plaTiledIteration+\tau_i}

\newcommand{\plaScheduleScanningOrder}{\sigma}
\newcommand{\plaScheduleInitiationInterval}{II}
\newcommand{\plaScheduleLocalLatency}{L_\text{local}}
\newcommand{\plaScheduleLocalLatencyDefinition}{L_\text{local} = \text{max}_i\ (\plaScheduleOperationStartTime[i] + \plaScheduleOperationExecutionTime[i]) - \text{min}_i\ \plaScheduleOperationStartTime[i] }

\newcommand{\plaScheduleGlobalLatency}{L_\text{global}}
\newcommand{\plaScheduleGlobalLatencyDefinition}{L_\text{global} = \text{max}_{\plaTiledIteration}\ \plaTiledScheduleVector\plaTiledIteration - \text{min}_{\plaTiledIteration}\ \plaTiledScheduleVector\plaTiledIteration }

\newcommand{\plaScheduleTotalLatency}{L_\text{total}}
\newcommand{\plaScheduleTotalLatencyDefinition}{L_\text{total} = \plaScheduleGlobalLatency + \plaScheduleLocalLatency}

\newcommand{\plaConditionSpace}{\plaEquationDomain}
\newcommand{\plaConditionSpaceMatrix}{\mmat{A}_i}
\newcommand{\plaConditionSpaceMatrixDefinition}{\plaConditionSpaceMatrix \in \mbaseSet{Z}^{m \times \plaDimension}}
\newcommand{\plaConditionSpaceOffset}{\mvec{b}_i}
\newcommand{\plaConditionSpaceOffsetDefinition}{\plaConditionSpaceOffset \in \mbaseSet{Z}^\plaDimension}

\newcommand{\plaConditionSpaceLongDefinition}{\plaConditionSpace = \msetBuilder{\plaIteration \in \plaIterationSpace}{\plaConditionSpaceMatrix\plaIteration \ge \plaConditionSpaceOffset}}
\newcommand{\plaConditionSpaceDefinition}{\plaConditionSpace \subseteq \plaIterationSpace}

\newcommand{\plaIntraTileConditionSpace}[1][i]{\mset{J}_{#1}}
\newcommand{\plaIntraTileConditionSpaceDefinition}{\plaIntraTileConditionSpace \subseteq \plaIntraIterationSpace}
\newcommand{\plaInterTileConditionSpace}[1][i]{\mset{K}_{#1}}
\newcommand{\plaInterTileConditionSpaceDefinition}{\plaInterTileConditionSpace \subseteq \plaInterIterationSpace}

\newcommand{\plaTiledConditionSpace}[1][i]{\mset{I}^*_{#1}}
\newcommand{\plaTiledConditionSpaceDefinition}{\plaTiledConditionSpace \subseteq \plaTiledIterationSpace}

\newcommand{\plaStorageLayout}{\mvec{s}}
\newcommand{\plaStorageLayoutOffset}{\alpha}

\newcommand{\plaAddressTranslation}{\mvec{m}}
\newcommand{\plaAddressTranslationOffset}{\mu}

\newcommand{\plaAddressTranslationDefinition}{\plaAddressTranslation_x\plaIteration+\plaAddressTranslationOffset_x = \begin{cases}%
    \plaStorageLayout_x(\plaReadIndexingFunction[{i_x, j_x}]) + \plaStorageLayoutOffset_x & x \in \plaInputVariableSpace\\
    \plaStorageLayout_x(\plaWriteIndexingFunction[i_x]) + \plaStorageLayoutOffset_x & x \in \plaOutputVariableSpace
\end{cases}}

\newcommand{\plaAccessSpace}{\mset{A}}
\newcommand{\plaAccessTuple}{(\plaVariable{x}, \plaIntraIterationSpace, \plaInterIteration)}
\newcommand{\plaAccessSpaceDefinition}{\plaAccessSpace = \msetBuilder{\plaAccessTuple}{\plaVariable{x} \in \plaIOVariableSpace \land \plaIntraIterationSpace = \msetBuilder{\plaIntraIteration}{\begin{pmatrix}\plaIntraIteration\\ \plaInterIteration\end{pmatrix} \in \plaTiledConditionSpace[i_x]} \land \plaInterIteration \in \plaInterIterationSpace}}
\newcommand{\plaBankIndex}{b}
\newcommand{\plaBankSpace}{\mset{B}}
\newcommand{\plaBankSpaceDefinition}{\plaBankSpace \subseteq \mbaseSet{N}_0}
\newcommand{\plaBankMapping}{\beta}
\newcommand{\plaBankMappingDefinition}{\beta: \plaAccessSpace \rightarrow \mpowerSet{\plaBankSpace} \setminus \emptyset}
\newcommand{\plaBankMappingConstraint}{\forall a,b \in \plaAccessSpace: a \neq b \implies \beta(a) \cap \beta(b) = \emptyset}


\newcommand{\plaLifetime}{Life}
\newcommand{\plaLifetimeDefinition}{\plaLifetime_{i,j} = \plaScheduleVector\plaIntra\plaReadIndexingFunctionOffset\plaIntra}

\newcommand{\plaDepth}{Depth}
\newcommand{\plaDepthDefinition}{\plaDepth_{i, j} = \frac{\plaLifetime_{i, j}}{\plaScheduleInitiationInterval}}

