\subsection{Problem Formalisation}

The initial input of our framework is a text expressed in natural language containing a description of the following:
\begin{enumerate*}
    \item How a task can be accomplished by combining high-level actions.
    \item The robotic resources available, along with a description of the low-level actions they are capable of performing.
    \item The environment.
\end{enumerate*}
The final objective is to generate, through an explainable process, an executable specification of the actions assigned to each robotic resource. The key requirements for the framework are as follows:
\begin{itemize}
    \item \textbf{R1:} The execution of a task must be formally correct, i.e., it must accomplish the goals and adhere to the constraints derived from the natural language text.
    \item \textbf{R2:} The process must be \emph{explainable}, ensuring that methods exist for human users to understand and trust the results produced by the system.
    \item \textbf{R3:} The knowledge obtained from understanding task execution through high-level actions must be \emph{reusable} across different implementation scenarios (e.g., using one robot or multiple robots).
    \item \textbf{R4:} The generation of the plan must support and optimise the parallel execution of actions across the available robotic resources.
    \item \textbf{R5:} The executable specification of the plan must be compatible with ROS2, which serves as a de facto standard for the execution environment of a wide range of robotic devices.
\end{itemize}

\subsection{Solution Overview}
\label{ssec:contributions}

\begin{figure*}[t!]
    \centering
    % \includegraphics[width=\linewidth]{figures/llmp_itmp.png}
    \includegraphics[width=\columnwidth]{figures/FrameworkDiagram.png}
    \caption{The architecture of the proposed framework.}
    \label{fig:arch_LLM_pKB}
\end{figure*}



The problem outlined above is addressed in this paper through a software framework depicted in Figure~\ref{fig:arch_LLM_pKB}. The framework comprises the following modules:
\begin{itemize}
    \item \textbf{Knowledge Management System} (KMS): It takes the initial natural language inputs and extracts a \kb in Prolog.
    \item \textbf{Planner}: It determines an executable plan from the \kb.
    \item \textbf{Execution Module}: It executes the plan by leveraging integration with the ROS2 middleware.
\end{itemize}

The KMS utilises an LLM to generate the \kb from a collection of
natural language texts. In the first step, the description of the
process and the environment is used to generate a high-level knowledge
base, i.e., a set of logical predicates that encode the breakdown of
the task execution into a number of interconnected \HL
actions. In the second step, this knowledge is augmented with
low-level robot-specific information, specifying how a \HL action can be
implemented using the elementary actions provided by the robot.

The technical details of these steps are outlined in
Section~\ref{sec:kb}. The generation of the \kb is not fully
automated and requires, at each step, some consistency checks (CC) by
the human developer. These checks ensure that the generated Prolog is
formally correct and that the goals and constraints are adequately
captured. When an inconsistency is identified, a few-shot learning
approach is used to provide feedback within the prompt, enabling the
system to correct itself.
%\edocom{Can we mention explicitely PDDL?}
Using a Prolog \kb offers several advantages over directly generating an executable plan:
\begin{enumerate}[nosep]
  \item The \kb contains a formal statement of goals and constraints, which facilitates the generation of formal correct plans (\textbf{R1}).
  \item A Prolog \kb is compact, human-readable, and understandable, enhancing the generation process's \emph{explainability} (\textbf{R2}).
  \item The deductive reasoning capabilities of Prolog make the \kb inherently compositional and reusable (\textbf{R3}).
  %
  Differently from other approaches to represent task planning in the robotic setting (e.g., those based on PDDL~\cite{pddl31} like for instance RosPlan~\cite{DBLP:conf/aips/CashmoreFLMRCPH15} or PlanSys2~\cite{DBLP:conf/iros/0001CMR21}) which are static, the Prolog \kb allows us to deduce new concepts and perform queries to check the consistency of the \kb, infer new knowledge, or update the current knowledge, evaluating the effects of the \kb update by logical reasoning. A new robotic implementation of the same task can be achieved by refining the same predicates and actions.
%  \item \todo[inline]{TO MR: We could add something about the ability to perform inference (absent in PDDL), reachability analysis, and formal consistency verifications.}
\end{enumerate}

\noindent The two-phase construction of the \kb provides two key benefits:
\begin{enumerate*}
    \item Facilitates reuse of the same \HL conceptual structure for different robotic implementations. 
    \item Helps manage the complexity of plan generation.
\end{enumerate*}


The generation of plans follows three steps. In the first step, detailed in
Section~\ref{ssec:toplangen}, a forward search is carried out starting
from the initial state encoded in the \kb. Different combinations of
actions are tested until a sequence is found that transitions from the
initial state to the goal state. This sequence represents a totally
ordered set of actions, but does not include timing information or
account for resource-specific constraints.

The second step, discussed in Section~\ref{ssec:poplangen}, utilises
Prolog's capabilities to analyse causal dependencies between
actions. Additionally, the \kb associates each action with the type of
resource required for its execution (e.g., a \verb|move| operation
might require a \verb|RoboticArm|). The outcome is a partially ordered
plan, where sequencing constraints exist only between causally
dependent actions. Resource-sharing constraints are not yet captured
at this stage.

In the third step, detailed in Section~\ref{ssec:poplanopt}, a
mixed-integer linear optimisation problem (MILP) is formulated. This
step aims to: 
\begin{enumerate*}
    \item Allocate actual resources to actions.  
    \item Optimise the timing of actions.  
\end{enumerate*}
The MILP encodes causal relationships between
actions (\emph{enablers}), resource constraints, and limits on the duration of the actions. The solution is a simple temporal network (STN), which can be checked for consistency. If successful, the resulting plan
supports parallel execution (\textbf{R4}) and is translated into a Behaviour Tree (\bt), a standard formalism for the execution of robotic plans in ROS2 (\textbf{R5}). Further details on this phase are provided in Section~\ref{sec:bt}.
If this operation fails, Prolog's backtracking capability can be
employed to generate an alternative total-order and repeat the
process. Persistent failures indicate a possible error in the \kb or
domain description, both of which should be revised.

A preliminary version of this work is presented in~\cite{saccon2023prolog}, where the LLM was used to generate only the initial and final states of the planning problem. This work extends the previous one in several directions. 
%
First, we have a flow to validate the output of the LLM, considering feedback to the user to correct possible logical and consistency errors.
%
Second, the LLM produces a high-level description of the planning task and a low-level one where additional details (e.g., resources and affordability) are considered, together with a mapping of high-level actions into low-level plans. 
%
Third, the formulation differentiating two levels allows reducing the burden and possible bottlenecks of generating the plan directly at the low-level of details.
%
Finally, in generating the low-level plan, we consider resources to reduce the makespan of the plans and parallelise the tasks on different robots.

% In~\cite{saccon2023prolog}, we used Prolog to first extract a total-order plan, then refine it into a partial-order plan and finally check its consistency by transforming it into an STN before extracting a BT to execute. 

%The main problem with this approach is that Prolog inherently performs a depth-first search, which has some drawbacks, mainly:
Similarly to ~\cite{saccon2023prolog}, the planner we implemented in Prolog performs a depth-first search, which has some drawbacks, mainly:
\begin{itemize}
    \item the provided plan is inefficient and usually sub-optimal since the solver will return the first plan that is feasible;
    \item the number of actions to choose from and the number of resources that must be allocated deeply impact the time to compute a feasible plan and its optimality.
\end{itemize}
We decided to focus on the second aspect to improve the plan obtained with the framework. We left as future work to leverage existing state-of-the-art planners (e.g., OPTIC~\cite{DBLP:conf/aips/BentonCC12} or FastDownward~\cite{DBLP:journals/jair/Helmert06}) for the generation of plans to further be optimized considering resources.