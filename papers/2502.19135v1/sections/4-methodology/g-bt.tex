\newcommand{\seq}[0]{\protect\writings{\texttt{SEQUENCE}}}
\newcommand{\parr}[0]{\protect\writings{\texttt{PARALLEL}}}

% In this section, we first introduce how to convert from a STN to a \bt, and then we provide some details regarding the implementation. 

% \subsubsection{\bt Generation}\label{sssec:btgen}

The conversion from STN to \bt is taken from~\cite{roveriSTNtoBT}. We summarize it here and refer the reader to the main article. 

An STN is a graph with a source and a sink, which can be artificial nodes in the sense that they represent the start and the end of the plan. Each node can have multiple parent and multiple children. Having multiple parents implies that the node cannot be executed as long as all the parents haven not finished and, whereas, having multiple children implies that they will be executed in parallel. 

With this knowledge we can extract a \btree, which is a structure that, starting from the root, ticks all the nodes in the tree until it finishes the last leaf. Nodes in the tree can be of different types:
\begin{itemize}
    \item \emph{action}: they are an action that has to be executed;
    \item \emph{control}: they can be either \seq or \parr and state how the children nodes must be executed;
    \item \emph{condition}: they check whether a condition is correct or not;
\end{itemize}
The ticking of a node means that the node is asked to do its function, e.g., if a \seq node is ticked, then it will tick the children one at a time, while if a condition node is ticked, it will make sure that the condition is satisfied before continuing with the next tick. 

The algorithm %(Algorithm~\ref{alg:stntobt})
to convert the STN to a \bt starts from the fictitious initial node (\verb|init|), and for every node it checks:
\begin{itemize}
    \item The number of children: if there is only one child, then it is a \seq node, otherwise it is a \parr node. 
    \item The number of parents: if there are more than one parents then the node must wait for all the parents to have ticked, before being executed.
    \item The type of the action: if it is a low-level action, then it is inserted into the \bt for execution, otherwise it will not be included.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% \begin{algorithm}
% \caption{Algorithm extracting a \btree from an STN.}
% \label{alg:stntobt}
% \KwData{The STN $G$}
% \KwResult{\bt corresponding to the STN}

% \DontPrintSemicolon

% \SetKwProg{extractBT}{EXTRACT\_BT}{}{}

% \SetKwInOut{Input} {In}
% \SetKwInOut{Output}{Out}

% \extractBT{(G)}{
%   \Input{The STN $G$ to convert}
%   \Output{The \bt $\mathcal{T}$}
%   \KwRet{$\mathcal{T}$}\;
% }

% \end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% THIS has been moved to the Implementation details section of Experimental Validation
% \subsubsection{\bt Execution}\label{sssec:btexec}

% As said, the execution of a \btree starts from the root and it gradually ticks the different nodes of the tree until all nodes have been ticked. 

% While \bts have become a de facto standard for executing robotic tasks, no universally accepted framework exists for their creation or execution. Some notable examples include PlanSys2~\cite{martin2021plansys2} and BehaviorTree.CPP~\cite{BehaviorTreeCppWebsite}. PlanSys2 is tightly integrated with ROS2; beyond merely executing \btrees, it can also derive feasible plans from a knowledge base. In contrast, BehaviorTree.CPP is a more general framework that enables the creation and execution of \bts from an XML file. We selected BehaviorTree.CPP since our main objective was to execute APIs from a \bt, which is easily represented using an XML file, while also maintaining maximum generality. Nevertheless, BehaviorTree.CPP also offers a ROS2 wrapper, which can easily be integrated with the flow.

% \enrcom{Maybe it should be moved to Section~\ref{ssec:implementation}?}