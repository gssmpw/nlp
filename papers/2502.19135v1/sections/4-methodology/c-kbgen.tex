The Knowledge Management System module (KMS), is in charge of taking the natural language description of both the environment and the actions that the agents can do, and convert them to a Prolog \kb using a LLM. 
The \kb contains all the necessary elements to define the mapped planning problem introduced in the previous section.

The framework works by considering a high-level and a low-level \kbase. For this reason, the input descriptions are also split into \HL and \LL. The former captures more abstract concepts, e.g., complex actions such as \verb|move_block| or the objects that are present in the environment. The latter captures more concrete and physical aspects of the problem, e.g., the actions that can be actually carried out by the agents such as \verb|move_arm| or the positions of the blocks. An example of this division can be seen in Section~\ref{sssec:runegKMS}.

% Describe how the kb works
The \kbase is divided in the following parts:
\begin{itemize}
    \item General \kb ($K$): contains the grounding predicates, both for the \HL and \LL. These predicates describe parts of the scenario or of the environment that do not change during execution. For example, the predicate \verb|wheeled(a1)|, which states that robot \verb | a1| has wheels, should be part of the general \kb and not of the state. 
    \item Initial ($I$) and final states ($G$): they contain all the fluents that change during the execution of the plan. This could be, for example, the position of blocks in the environment. 
    \item High-level actions ($DA_H$): each high-level action predicate is written as:
\begin{minted}[fontsize=\small,breaklines]{Prolog}
action(
    action_name(args),
    [positive_preconditions],
    [negative_preconditions],
    [grounding_predicates],
    [effects]
).
\end{minted}
    The low-level actions ($DA_L$) have the same structure, but instead of being described as predicates of type \verb|action|, they are described as \verb|ll_action|. The preconditions $\pc{a}$ of an action $a$ are obtained by combining the list of predicates \verb|positive_preconditions| and \verb|negative_preconditions|. The predicates in the list \verb|grounding_predicates| are used to ground the parametrised fluents of the action. For example, the action \verb|move_block| depends on a block, and we can check that the action is correctly picking a block and not another object by querying the \kb in this step. Section~\ref{sssec:runegKMS} clarifies this aspect.  
    \item Mappings ($M$): contains a dictionary of \HL actions $DA_H$ and how they should be mapped to a sequence of \LL actions $DA_L$. As will become apparent in the following, the distinction between \HL and \LL actions induces a significant simplification in the planning phase.
    \item Resources ($R$): the predicate \verb|resource\1| states whether another predicate is part of the resources or not. As mentioned before, this is helpful because it allows one to shrink the complexity of the problem not having to check multiple predicates, but instead they are later allocated during the optimisation part.
\end{itemize}

% Describe the process to validate the initial descriptions
Once the user provides descriptions for the \HL and \LL parts, the framework performs a consistency check to ensure that there are no conflicts between them. It verifies that both descriptions share the same goal, that objects remain consistent across \HL and \LL, and that agents are capable of executing the tasks. This validation is carried out by an LLM, which, if inconsistencies are detected, provides an explanation to help the user make the necessary corrections.

In both this step and the subsequent steps to generate the \kb, the LLM is not used directly out of the box. Instead, we employ the Chain-of-Thought (CoT)~\cite{wei2022chain} approach, which involves providing the LLM with examples to guide its reasoning. This process ensures that the output is not only structurally correct, but also more aligned with the overall goal of the task.

% Describe how the different aspects of the kb are extracted
Examples are particularly important when generating the \kb. Indeed, as we have mentioned before, the \kbase is highly structured and the planner expects to have the different components written correctly. CoT enables the LLM to know these details. 

We tested two different ways of generating the \kb through LLMs:
\begin{itemize}
    \item either we produced the whole \kb for the high-level and the low-level all at once, or
    \item we produced the single parts of the \kbs. 
\end{itemize}

The first approach is quite straightforward: once we have the examples to give to the LLM for the CoT process, we can input the \HL description and query the LLM to first extract the high-level \kb, and then also feed the created \HL \kb to the LLM to generate the \LL \kb, which will contain everything. % Highlight why one would want this. 

Instead, the second approach requires more requests to the LLM. We first focus on the \HL \kb, and then feed the \kb that we have obtained to generate the \LL parts. For the \HL generation, we ask the LLM to generate the general \kb, the initial and final states, and the actions set in this particular order. Each time we provide the LLM with the \HL description and with the elements generated in the previous steps. The same thing is done for the \LL \kb, generating again the four components and feeding each time also the \HL \kb. We include a final step that generates the mappings between the \HL and \LL actions. As for all the other steps, also in this final step, we pass the previously generated elements of the \LL \kb. 
Although generating the entire \kbase at once would reduce token usage and speed up the process, dividing the generation of the \kb into distinct steps enhances the system's accuracy, as demonstrated in the experimental evaluation of Section~\ref{sec:experiments}. This improvement comes because the iterative approach allows the LLM to first focus on generating more homogeneous information (i.e., the high-level) and then leverage the previously generated content to perform a consistency check.  

\subsection{Runing Example -- KMS}
\label{sssec:runegKMS}

\input{sections/4-methodology/a-runningexample}

Let's now focus on the \kbase generation. For example, the two queries that could be passed to the system are:

\begin{textbox}{\HL query}
% \textboxtitle{\HL query}{
\footnotesize
In this scenario, there are two blocks on a table. They are placed in positions (1,1) and (3,1). There is a robotic agent that can move the blocks from one position to another. In particular, it can:
\begin{itemize}
    \item move a block from a position on the table, to another position on the table;
    \item move a block from a position on the table, to the top of another block;
    \item move a block from the top of a block, to a position on the table;
    \item move a block from the top of a block, to the top of another block.
\end{itemize}
The goal of this scenario is to move the first block from position (1,1) to position (2,2), and then place the second block on top of it.
% }
\end{textbox}

\begin{textbox}{\LL query}
% \textboxtitle{\LL query}{
\footnotesize
In this scenario, there are two blocks that are in the same positions as described in the \HL query. The robotic agent is a robotic arm and its end-effector is a two-finger gripper that can grasp an object. In particular, the following APIs are made available for the agent to move:
\begin{itemize}
    \item \texttt{move\_arm(Arm, X1, Y1, X2, Y2)}, which allows the end-effector to be moved from one position to another;
    \item \texttt{grip(Arm)}, which allows the gripper to be lowered onto a block and grip the block;
    \item \texttt{release(Arm)}, which allows to lower the block and release the gripper leaving the block in place.
\end{itemize}
% }
\end{textbox}


As mentioned before, the first step is to pass the two queries for validation. In this case, when using GPT-4o, both queries pass the consistency check. If instead of using the previous \HL query, we would modify it by removing the possibility of placing one block on top of the other, then the LLM would return the following error:

\begin{textboxerror}
\footnotesize
The description of the scenario has an issue. The agent is described as being able to move a block from a position on the table to another position on the table, and from the top of a block to a position on the table. However, the goal requires the agent to place the second block on top of the first block, which is not listed as an action that the agent can carry out. The agent's capabilities do not include placing a block on top of another block, which is necessary to achieve the goal.
\end{textboxerror}

\noindent This also allows the user to understand where the mistake is and correct it. 

Once the validation part succeeds, the system generates the \HL \kb. In this particular instance, for space limitation, we present only the general \kbase ($K$), the initial ($I$) and final ($G$) states, and a single action. 

\begin{center}
\begin{minipage}{\linewidth}
    \begin{minipage}{.48\linewidth}
        \begin{codebox}{prolog}{General KB}
% Positions
pos(1,1).
pos(2,2).
pos(3,1).

% Blocks
block(b1).
block(b2).

% Agents
agent(a1).

% Resources
resources(agent(_)).
        \end{codebox}
    \end{minipage}
    \hfill
    \begin{minipage}{.48\linewidth}
        \begin{minipage}{\linewidth}
        \begin{codebox}{prolog}{Initial state ($I$)}
init_state([
  ontable(b1), ontable(b2),
  at(b1,1,1), at(b2,3,1),
  clear(b1), clear(b2),
  available(a1)
]).
        \end{codebox}
        \end{minipage}
        \hspace{1cm}\\
        \begin{minipage}{\linewidth}
        \begin{codebox}{prolog}{Final state ($G$)}
goal_state([
  ontable(b1),
  on(b2, b1),
  at(b1,2,2), at(b2,2,2),
  clear(b2),
  available(a1)
]).
        \end{codebox}
        \end{minipage}
    \end{minipage}
\end{minipage}
\begin{codebox}{prolog}{Action example}
action(move_table_to_table_start(Agent, Block, X1, Y1, X2, Y2), 
  [ontable(Block), at(Block, X1, Y1), available(Agent), clear(Block)],
  [
    at(_, X2, Y2), on(Block, _), moving_table_to_table(_, Block, _, _, _, _), 
    moving_table_to_block(_, Block, _, _, _, _, _)
  ],
  [agent(Agent), pos(X1, Y1), pos(X2, Y2), block(Block)],
  [
    del(available(Agent)), del(clear(Block)), del(ontable(Block)), del(at(Block, X1, Y1)),
    add(moving_table_to_table(Agent, Block, X1, Y1, X2, Y2))
  ]
).
\end{codebox}
\end{center}

The resulting \HL \kb is human-readable and relatively simple (in fulfilment of requirement \textbf{R2}).
The user at this point can make corrections to the \HL \kb, if needed, and finally, \frameworkname will also generate the \LL \kbase. In this case for space limitation, we show the changes made to the previous elements, one low-level action, and one mapping. 

\begin{center}
\begin{minipage}{\linewidth}
    \begin{minipage}{.48\linewidth}
        \begin{codebox}{prolog}{General KB}
% Positions
pos(0,0).
pos(1,1).
pos(2,2).
pos(3,1).

% Blocks
block(b1).
block(b2).

% Agents
agent(a1).

% Low-level predicates
ll_arm(a1).
ll_gripper(a1).

% Resources
resources(agent(_)).
        \end{codebox}
    \end{minipage}
    \hfill
    \begin{minipage}{.48\linewidth}
        \begin{minipage}{\linewidth}
        \begin{codebox}{prolog}{Initial state ($I$)}
init_state([
  ontable(b1), ontable(b2),
  at(b1,1,1), at(b2,3,1),
  clear(b1), clear(b2),
  available(a1),
  ll_arm_at(a1,0,0), 
  ll_gripper(a1,open) 
]).
        \end{codebox}
        \end{minipage}
        \hspace{1cm}\\
        \begin{minipage}{\linewidth}
        \begin{codebox}{prolog}{Final state ($G$)}
goal_state([
  ontable(b1),
  on(b2, b1),
  at(b1,2,2), at(b2,2,2),
  clear(b2),
  available(a1),
  ll_arm_at(a1,_,_), 
  ll_gripper(a1,_)    
]).
        \end{codebox}
        \end{minipage}
    \end{minipage}
\end{minipage}
\begin{codebox}{prolog}{Action example}
ll_action(move_arm_start(Arm, X, Y),
  [],
  [ll_arm_at(_, X, Y), moving_arm(Arm, _, _, _, _), gripping(Arm, _), releasing(Arm)],
  [],
  [ll_arm(Arm), pos(X, Y)],
  [
    add(moving_arm(Arm, X, Y)),
    del(ll_arm_at(Arm, X, Y))
  ]
).
\end{codebox}
\begin{codebox}{prolog}{Mapping example}
mapping(move_table_to_table_start(Agent, Block, X1, Y1, X2, Y2),
  [
    move_arm_start(Agent, X1, Y1),
    move_arm_end(Agent, X1, Y1),
    grip_start(Agent),
    grip_end(Agent),
    move_arm_start(Agent, X2, Y2),
    move_arm_end(Agent, X2, Y2),
    release_start(Agent),
    release_end(Agent)
  ]
).
\end{codebox}
\end{center}

Again, the user can correct possible errors (or anyway refine the \kb) and then move on to the planning phase.
