A total-order plan is a strictly sequential list of actions that drives the system from the initial to the goal state. 
The algorithm used to extract a total-order plan is shown in~\autoref{alg:toplanning} and consists of two distinct steps:
\begin{itemize}
    \item identify a total-order plan for high-level actions, and
    \item recursively map each high-level action to a sequence of actions with a lower level until they are mapped to actions corresponding to the APIs of the available robotic resources.
\end{itemize}

\begin{algorithm}
\footnotesize
\caption{Algorithm generating a TO plan with mappings}\label{alg:toplanning}
\KwData{$TP=(F, DA, I, G, K)$}
\KwResult{Plan solving TP}

\DontPrintSemicolon

\SetKwProg{plan}{TO\_PLAN}{}{}
\SetKwProg{map}{APPLY\_MAP}{}{}
\SetKwProg{action}{APPLY\_ACTION}{}{}
\SetKwProg{maps}{APPLY\_MAPPINGS}{}{}

\SetKwInOut{Input} {In}
\SetKwInOut{Output}{Out}

\plan{(S, P)}{
  \Input{The current state $S$ and the current plan $P$}
  \Output{The final plan}
  \If{$S \neq G$}{
      select\_action($a_i$)\;
      (US, UP) $\gets$ APPLY\_ACTION($a_i$, S, P)\;
      P $\gets$ TO\_PLAN(US, UP)\;
  }
  (US, UP) $\gets$ APPLY\_MAPPINGS(S,P)\;
  \KwRet{P}\;
}

\maps{(S, P)}{
  \Input{The current state $S$ and the current plan $P$}
  \Output{The updated state $US$ and plan $UP$ after the mappings}
  US, UP $\gets$ S, P\;
  \ForEach{$a_i \in P$}{
    \If{\textnormal{is\_start($a_i$) $\wedge$ has\_mapping($a_i$)}}{
      (US, UP) $\gets$ APPLY\_MAP($a_i$, \textnormal{US}, UP)\;
    }
  }
  \KwRet{(US, UP}\;
}

\map{($a$, S, P)}{
  \Input{The action $a$, the current state $S$ and the current plan $P$}
  \Output{The updated state $US$ and plan $UP$ after the mappings}
  M $\gets$ mapping($a$)\;
  \ForEach{$a_i \in M$}{
    (US, UP) $\gets$ APPLY\_ACTION($a$, S, P)\;
  }
  \KwRet{(US, UP)}\;
}

\action{($a, S, P$)}{
  \Input{The action $a$, the current state $S$ and the current plan $P$}
  \Output{The updated state $US$ and plan $UP$ after applying the effects of $a$}
  \eIf{\textnormal{is\_applicable($a_i$)}}{
    US $\gets$ change\_state($a_i$.eff, S)\;
    UP $\gets$ plan\_action($a_i$, P)\;
    \KwRet{(US, UP)}\;
  }{
    \KwRet{(S, P)}
  }
}
\end{algorithm}

This enables the extraction of total-order plans that are consistent with the \kb provided, and we reduce the computational cost of checking all the possible actions at each time step. The \texttt{TO\_PLAN} function is the main function, which takes the initial and final states, and it inspects which actions can be executed given the current state. The \texttt{select\_action} function selects the next action from the set of possible actions. This search is based on the Prolog inference engine, which tries the actions in the order in which they are written in the KB, and hence it is not an informed search. 

The algorithm then moves to the \texttt{APPLY\_ACTION} function, which first checks if the chosen action's preconditions are met in the current state and, if they are, then it applies its effects changing the state (\texttt{change\_state}) and adding the action to the plan (\texttt{plan\_action}). It continues until the current state satisfies the goal state. Whenever the search reaches a fail point, we exploit the Prolog algorithm of resolution to step back and explore alternative possibilities.

Once the algorithm has extracted a high-level total-order plan, it applies the mappings. To do so, it iterates over the actions in the plan, and for each action it checks if it is a start action ($a_\vdash$) and if there are mappings for it. If this is the case, it calls the function \texttt{APPLY\_MAP}, which sequentially applies the actions in the mapping to the current state, also adding the actions to the plan. Notice that to do so, we call the \texttt{APPLY\_ACTION} function, which checks the preconditions of the actions w.r.t. the current state, ensuring that the lower-level actions can actually be applied.
% Also, the functions recursively check if any action from the mapped action has a mapping on its own, ensuring that all the actions have a direct grounding to APIs.

The total-order plan $TO$ extracted from this function is a list of actions that are executed in sequence:
\begin{equation*}
    \forall i \in \{0,\hdots \vert TO\vert-1\}~t(a_i)<t(a_{i+1})
\end{equation*}

\subsubsection{Running Example -- Total-Order Plan}
\label{sssec::runegTOPlan}

Let us consider again the \kb that we generated in Section~\ref{sssec:runegKMS}. Let us now see how \frameworkname extracts the TO plan.

The algorithm starts from the initial state and from the first action in the \kb, which in this case is the one shown in Section~\ref{sssec:runegKMS}. The algorithm takes the grounding predicates in this case:

\begin{minted}[fontsize=\footnotesize]{prolog}
agent(Agent), pos(X1, Y1), pos(X2, Y2), block(Block)
\end{minted}

and checks whether there is an assignment of predicates from the \kbase that satisfies them. For example, the predicate \verb|pos(1,1)| satisfies \verb|pos(X1,Y1)|. Not only this, but since the predicates in this list are grounded w.r.t. the \kb, one can also check some conditions. For example, if we were to assign the values to the previous predicates, it can happen that \verb|X1 = X2| and \verb|Y1 = Y2|, which is useless for an action that moves a block from one position to another. By adding the following predicates, we can ensure that the values are different:

\begin{minted}[fontsize=\footnotesize]{prolog}
agent(Agent), pos(X1, Y1), pos(X2, Y2), block(Block), X1\=X2, Y1\=Y2
\end{minted}

Once an assignment for the predicates inside the grounding list is found, the algorithm checks whether the predicates inside the preconditions are satisfied. Let us consider the preconditions for the \verb|move_table_to_table_start| action from Section~\ref{sssec:runegKMS}:

\begin{minted}[fontsize=\footnotesize]{prolog}
% Positive predicates
[ontable(Block), at(Block, X1, Y1), available(Agent), clear(Block)],
% Negative predicates
[
  at(_, X2, Y2), on(Block, _), moving_table_to_table(_, Block, _, _, _,_), 
  moving_table_to_block(_, Block, _, _, _, _, _)
]
\end{minted}

After the first grounding step, they become the following:

\begin{minted}[fontsize=\footnotesize]{prolog}
% Positive predicates
[ontable(b1), at(b1, 0, 0), available(a1), clear(b1)],
% Negative predicates
[
  at(_, 0, 0), on(b1, _), moving_table_to_table(_, b1, _, _, _,_), 
  moving_table_to_block(_, b1, _, _, _, _, _)
]
\end{minted}

The algorithm checks whether the predicates from the first list are satisfied in the current state and whether the predicates from the second list are not present in the current state. Comparing them with the initial state as shown in Section~\ref{sssec:runegKMS}, we can see that \verb|ontable(b1)| is present, but \verb|at(b1, 0, 0)|, so this combination of predicates would already be discarded. The first grounding that is accepted is that in which \verb | Block = b1, X1 = 1, Y1 = 1, Agent = a1 |. Notice that the predicates that start with \verb|_| mean "any", e.g., the predicate \verb|at(_, 0, 0)| checks if there is any predicate with name \verb|at| and arity 3 that has the last two arguments set to 0, regardless of what the first argument is.

By checking the different combinations of actions, the planner can extract a \HL TO plan. In this case, it would be something like this:

\begin{minted}[fontsize=\footnotesize]{text}
[0] move_table_to_table_start(a1, b1, 1, 1, 2, 2)
[1] move_table_to_table_end(a1, b1, 1, 1, 2, 2)
[2] move_table_to_block_start(a1, b2, 3, 1, 2, 2)
[3] move_table_to_block_end(a1, b2, 3, 1, 2, 2)
\end{minted}

At this point, the algorithm takes the mappings and it applies them to the previous plan. For instance, from Section~\ref{sssec:runegKMS} we saw that the mapping for \verb|move_table_to_table_start| is:
\begin{minted}[fontsize=\footnotesize]{prolog}
mapping(move_table_to_table_start(Agent, Block, X1, Y1, X2, Y2),
  [
    move_arm_start(Agent, X1, Y1), move_arm_end(Agent, X1, Y1),
    grip_start(Agent), grip_end(Agent),
    move_arm_start(Agent, X2, Y2), move_arm_end(Agent, X2, Y2),
    release_start(Agent), release_end(Agent)
  ]
).
\end{minted}

Hence, we would change the previous plan with:

\begin{minted}[fontsize=\footnotesize]{text}
[0] move_table_to_table_start(a1, b1, 1, 1, 2, 2)
[1] move_arm_start(a1, 1, 1)
[2] move_arm_end(a1, 1, 1)
[3] grip_start(a1)
[4] grip_end(a1)
[5] move_arm_start(a1, 2, 2)
[6] move_arm_end(a1, 2, 2)
[7] release_start(a1)
[8] release_end(a1)
[9] move_table_to_table_end(a1, b1, 1, 1, 2, 2)
[10] move_table_to_block_start(a1, b2, 3, 1, 2, 2)
[11] move_arm_start(a3, 3, 1)
[12] move_arm_end(a1, 3, 1)
[13] grip_start(a1)
[14] grip_end(a1)
[15] move_arm_start(a1, 2, 2)
[16] move_arm_end(a1, 2, 2)
[17] release_start(a1)
[18] release_end(a1)
[19] move_table_to_block_end(a1, b2, 3, 1, 2, 2)
\end{minted}

