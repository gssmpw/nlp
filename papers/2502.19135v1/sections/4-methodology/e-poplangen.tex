The next step is to analyse the total-order plan in search of all possible causal relationships. This is done by
looking for actions that enable other actions (enablers). In addition, we extract all the resources that can be allocated
and used for the execution of the task. This step will be important for the next phase of the planning process, the MILP problem, in which 
the resources will be re-allocated allowing for shrinking the makespan of the plan.
%
In this work, the only resource considered is the robotic agent, but this limitation could easily be removed by modifying the \kb.  To this end,  we define a special predicate, named \texttt{resource/1}, that allows us to specify the resources.

Given an action $a_i$, another action $a_j$ is an enabler of $a_i$ if it either adds a literal $l$ satisfying one or more preconditions of $a_i$, or it removes a fluent violating one or more preconditions of $a_i$, and if $a_i$ happens after $a_j$: 

\begin{equation}
\small
\begin{array}{rl}
     a_j \in \ach{a_i} \iff & t(a_i) > t(a_j) \wedge \\
                            & ((l\in \pc{a_i}~ \wedge add(l)\in \eff{a_j}) \vee\\
                            & \,\,(\lnot l\in \pc{a_i} \wedge del(l)\in \eff{a_j}))
\end{array}
\label{eq:enablers}
\end{equation}

It is important to note that we consider an action $a_j\notin\ach{a_i}$ if there is at least a fluent $l$ that is not a resource. If all the fluents and their arguments that would make $a_j$ an enabler of $a_i$ are resources, then $a_j$ is not considered an enabler, as this relationship depends on the assignment of the resources, which comes with the optimisation step. 

Besides the enablers added corresponding to the classical definition, we also enforce the following precedence constraints:
\begin{itemize}
    \item When we expand a mapping $m(\alpha_i)$ of a high-level durative action $\alpha_i$ and reach the ending action $\aEnd{\alpha_i}$, then we add all previous durative actions as enablers until the corresponding start action. For example, assume that $m(\alpha_i)=\{\alpha_j, \alpha_k\}$, this means that the total-order plan will be the sequence $\{\aStart{\alpha_i}, \aStart{\alpha_j}, \aEnd{\alpha_j}, \aStart{\alpha_k}, \aEnd{\alpha_k}, \aEnd{\alpha_i}\}$. It follows that $\aStart{\alpha_i}$ is an enabler of $\aEnd{\alpha_i}$, but also all intermediate actions are part of the set of its enablers as they must be completed in order for $\alpha_i$ to end.
    \begin{equation}
        \bigwedge_{a\in m(\alpha_i)} a\in \ach{\aEnd{\alpha_i}}.
        \label{eq:constraint5}
    \end{equation}
    \item When we expand a mapping, all actions in the mapping must have the start of the higher-level action as one of the enablers. For instance, after the previous example, $\aStart{\alpha_j}, \aEnd{\alpha_j}, \aStart{\alpha_k}, \aEnd{\alpha_k}$ have $\aStart{\alpha_i}$ as an enabler.
    \begin{equation}
        \bigwedge_{a\in m(\alpha_i)} \aStart{\alpha} \in \ach{a_i}.
        \label{eq:constraint4}
    \end{equation}
\end{itemize}

% We then create a graph from which we can extract partial-order plans. To do this, after having obtained a plan from the \texttt{TO\_PLAN} from~\autoref{alg:planning}, we look for the achievers of the actions as shown in~\autoref{alg:po_planning}. 

The algorithm that manages this extraction is shown in~\autoref{alg:poplanning}. For ease of reading, we define $R\subseteq F$ as the set of fluents that are resources.

The algorithm \texttt{FIND\_ENABLERS} takes the total-order plan and, starting with the first action in the plan, it extracts all the causal relationships between the actions. The auxiliary function \texttt{IS\_ENABLER} tests whether an action $a_j$ is an enabler of an action $a_i$ by checking the properties of~\autoref{eq:enablers} plus the precedence constraints just described. Finally, notice that the literal checked to be present (absent) in both additive (subtractive) effects must not contain arguments that are part of the resources $R$. For example, consider the case in which an action $a_i$ needs the precondition $l(x_1, x_2, x_3)$ and $a_j$ provides the predicate, then if at least one of $x_1, x_2, x_3$ is in $R$, $a_j$ is an enabler of $a_i$, otherwise it is not. This ensures that only causal relationships that do not depend on the resources are extracted at this time. The precedence of the resources will be defined and discussed in Section~\ref{ssec:poplanopt}. 

\begin{algorithm}[htp]
\footnotesize
\caption{Algorithm extracting the actions enablers and the resources}
\label{alg:poplanning}
\KwData{$TP=(F, DA, I, G, K)$}
\KwResult{Enablers and resources $R$}

\DontPrintSemicolon

\SetKwProg{findenablers}{FIND\_ENABLERS}{}{}
\SetKwProg{isenabler}{IS\_ENABLER}{}{}
\SetKwProg{findresources}{EXTRACT\_RESOURCES}{}{}

\SetKwInOut{Input} {In}
\SetKwInOut{Output}{Out}

\findenablers{$(\tn{TO\_P}, a_i)$}{
  \Input{The total-order plan TO\_P, the $i$th action}
  \Output{The enablers $E$ for all the actions in the plan}

  \For{$a_j \in \tn{TO\_P}, a_j\neq a_i$}{
    \uIf{$\tn{IS\_ENABLER}(a_j, a_i)$}{
      $E[a_i].add(a_j)$;
    }
  }

  \If{$a_i\neq \tn{TO\_P}.back()$}{
    $E \gets \tn{FIND\_ENABLERS}(\tn{TO\_P}, a_{i+1})$\;
  }
  \KwRet{E}\;
}

\isenabler{$(a_j, a_i)$}{
  \Input{The action $a_j$ to test if it's enabler of $a_i$}
  \Output{True if $a_j$ is enabler of $a_i$}

  \ForEach{$e \in \eff{a_j}$}{
    \uIf{$\left(e=\tn{add}(l) \wedge l\in\pc{a_i})\right)$ OR
         $~\left(e=\tn{del}(l) \wedge \lnot l\in\pc{a_i}\right)$ OR
         $~\left(\tn{isStart}(a_j) \wedge a_i \in m(a_j)\right)$ OR\\
         $~~\left(\tn{isEnd}(a_j) \wedge a_i \in m(a_j)\right)$}
    {
      $X\gets \tn{set of arguments of }e$; 
        
      \uIf{$\not\exists x \in X | x \in R$}{
        \KwRet{True};
      }
    }
  }
  \KwRet{False};
}

\findresources{$()$}{
  \output{A list of resources}
  findall(X, resources(X), AllResources)\;
  $R$ = make\_set(AllResources)\;
  \KwRet{$R$}\;
}

\end{algorithm}

\subsubsection{Running Example -- Partial-Order Plan}
\label{sssec:PORunEx}

Once we have applied the mappings as before, we have the full TO plan. We want to extract information from this, which will then be exploited to improve the plan for multiple agents. This is done by examining all the actions and checking which are their enablers. For instance, the 10th action, \verb|move_table_to_block_start(a1, b2, 3, 1, 2, 2)|, has as a precondition the following predicate \verb|clear(Block2), Block2=b1|, which is true only when the 9th action has applied its effects. Since \verb|b1| is not part of the resources, the algorithm will state that $a_9$ is an enabler of $a_{10}$. 

If the second move were to move a block to another position on the table, hence independent of the first move, then the algorithm would not set $a_9$ as an enabler of $a_{10}$, as the only reason it may do so is if the same agent is used, but this is known only later.

After this step, we know the enablers for the actions (shown in squared brackets in the list below):

\begin{minted}[fontsize=\footnotesize]{text}
[0] init()[]
[1] move_table_to_table_start(a1, b1, 1, 1, 2, 2), [0]
[2] move_arm_start(a1, 1, 1), [0,1]
[3] move_arm_end(a1, 1, 1), [0,1,2]
[4] grip_start(a1), [0,1,2,3]
[5] grip_end(a1), [0,1,2,3,4]
[6] move_arm_start(a1, 2, 2), [0,1,2,3,4,5]
[7] move_arm_end(a1, 2, 2), [0,1,2,3,4,5,6]
[8] release_start(a1), [0,1,2,3,4,5,6,7]
[9] release_end(a1), [0,1,2,3,4,5,6,7,8]
[10] move_table_to_table_end(a1, b1, 1, 1, 2, 2), [0,1,2,3,4,5,6,7,8,9]
[11] move_table_to_block_start(a1, b2, 3, 1, 2, 2), [0,10]
[12] move_arm_start(a1, 3, 1), [0,11]
[13] move_arm_end(a1, 3, 1), [0,11,12]
[14] grip_start(a1), [0,11,12,13]
[15] grip_end(a1), [0,11,12,13,14]
[16] move_arm_start(a1, 2, 2), [0,11,12,13,14,15]
[17] move_arm_end(a1, 2, 2), [0,11,12,13,14,15,16]
[18] release_start(a1), [0,11,12,13,14,15,16,17]
[19] release_end(a1), [0,11,12,13,14,15,16,17,18]
[20] move_table_to_block_end(a1, b2, 3, 1, 2, 2), [0,10,11,12,13,14,15,16,17,18,19]
[21] end(), [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
\end{minted}

From this we could already notice that all the actions will be carried out in sequence. We also see that in this step we add two fictitious actions, \verb|init| and \verb|end|. This simply represents the start and the end of the plan, respectively. \verb|init| is an enabler of all the actions in the plan and \verb|end| has all the other actions as enablers, which means that the plan can be considered finished only when all the actions have been executed.

As for the resources, we first extract all the possible resources by looking at the predicates \verb|resource(X)| in the \kb, as shown in Section~\ref{sssec:runegKMS}. Then we assign the type of resources used to each action by checking action per action which resources they are using. This is useful because it will provide MILP with the basis to correctly allocate the different resources to the actions.

\begin{minted}[fontsize=\footnotesize]{text}
Resources:
[0] agent-2
Resources list:
[0] agent-[agent(a1),agent(a2)]
Resources required by action:
[4] 6-[agent]
[9] 1-[agent]
\end{minted}

