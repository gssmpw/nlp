\section{Related work and discussion}
\label{sec:related-work}

Frame Logic (F-logic), introduced in ____, is a knowledge representation language that combines conceptual modeling with object-oriented and frame-based languages. 
In this language, it is possible to use types as predicates which is sufficient for expressing formulae like (\ref{eq:conjunction-guarding}) and (\ref{eq:implication-guarding}).
Logic programming incorporating polymorphically order-sorted types is investigated in ____. 
The Flora-2____ system combines F-logic and HiLog____, resulting in an even more expressive language.
The key differences between these languages and guarded \OSL are:
    \textit{(i)} F-logic is mainly utilizing subtyping from the perspective of object-oriented paradigm while the focus of this paper is on a more general notion of types.
    % That is not  a clear, let alone,  convincing argument. 
    \textit{(ii)} Results of these papers are related to \emph{parametric polymorphism}~\cite[Chapter 23]{pierce2002types} rather than subtyping polymorphism.
    \emph{Parametric (Ad hoc) polymorphism} includes generic types,  polymorphic  predicate and function symbols %that represent multiple types (e.g., generic types and functions) 
    and quantification over types.
    An example is $\mother$ and $\father$ functions, mapping animals of a certain kind to another animal of that same kind. Using parametric polymorphism the typing signature of this function can be expressed as ($\mother : \forall k \OSTd \Animal \ .\ k \rightarrow k$). Even though this notation strongly resembles the idea presented in Section~\ref{sec:osl-i-typeing} they are different. Here, variable $k$ ranges over types, while in the other example, this does not have to be the case. However, the dependent type approach with intensional logic can sometimes simulate parametric polymorphism. In this particular example: ($\mother : k \rightarrow k \mid k : \con^T[\Animal]$).
    \textit{(iii)} These languages lack intensional aspects. While HiLog allows for higher-order language constructs, it does not include concepts. This means that using functions such as $\Co{soundOfKind}$ to ``compose'' formulae is not possible. 
    In other words, one can see the intensional logic presented in this paper as a mechanism for expressing templates of formulae. This is because objects from the vocabulary are first-class citizens. This is not the case with the higher-order logic.
    \textit{(iv)} Implicit type guarding is not supported in these languages. 
    In particular, to the best of our knowledge, no other languages use such language constructs (except for our previous work____ where guards ensure the safe application of partial functions).
    However, this paper demonstrates the importance of implicit guarding and power coming from combining it with intensional logic.

The points \textit{(iii)} and \textit{(iv)} suggest that these languages may encounter similar problems to those concerning \OSL discussed in Section~\ref{sec:log-anaysis} and intensional logic from Section~\ref{sec:intensional-osl}.

On the other side, the scope of this paper is limited to subtyping polymorphism. 
Future research should explore how the approach presented in this paper relates to \emph{parametric (Ad hoc) polymorphism}.
In particular, it is worth investigating whether the two typing systems have the same expressive power.
Another research question that opens here is what if we perceive typed logic as a logic of partial predicates, what is then the relation between guarding presented in this paper and guarding that ensures arguments of a function are in its domain of definedness (our previous work____).

Similar to the approach demonstrated in formula (\ref{eq:intensional-guarding}), it is possible to define higher-order functions in HiLog to map propositions to propositions, thereby achieving similar outcomes. 
However, this approach carries the same issues as the one with intensional logic.
Namely, it requires introduction of new functions and predicates representing the typing relation between different concepts which is redundant as this information is present in the typing signature of these concepts. 
This issue was discussed in Section~\ref{sec:results}.  
Similar issues apply to many imperative programming languages, such as Python, where \emph{dynamic function invocation} can yield similar results but with the price of introducing redundant type information. 
Dynamic function invocation allows one to store names of functions in variables and then invoke these functions by using the variable.

In conclusion, many declarative (logic-based) and imperative languages can achieve similar results as presented in this paper. However, mainly due to the lack of implicit guarding and intensional aspects of the language, these languages do not support the subtyping discussed in this paper as a native language construct. To the best of our knowledge, there are no such knowledge representation languages.