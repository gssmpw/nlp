Our study proposes a hierarchical tool stacking method, named ChemHTS, to optimize the tool invocation process of LLMs in chemistry-related tasks. ChemHTS iteratively refines and optimizes the tool stacking trajectory, ultimately identifying the optimal sequence of tool calls to enhance computational performance (Fig.\ref{fig:010method}).
\subsection{Step 1: Tool Self-stacking Warmup}

%将工具分为两类，计算和检索。
%由于化学任务研究往往是理论计算与实验知识的结合，通过计算预测未知性质或过程，以及通过检索获取已有知识，因此本文将工具集$\mathcal{L}$分为compute-based tools $\mathcal{L}_c$ and retriever-based tools $\mathcal{L}_r$两类别的工具。
%为了通过测试单个工具在多次调用后的表现，确定其是否适合进行堆叠，我们首先进行单个工具的自我叠加预热阶段。
To evaluate the performance of a single tool after multiple invocations and determine its suitability for stacking, we first conduct a self-stacking warm-up phase for the individual tool.
Since research in chemical tasks often integrates theoretical computations with experimental knowledge, leveraging computation to predict unknown properties or processes and retrieval to access existing knowledge, we categorize the chemical LLM toolset $\mathcal{L}$ into two types: compute-based tools $\mathcal{L}_c$ and retriever-based tools $\mathcal{L}_r$.
For computational tools, it may be necessary to test whether repeated invocations lead to improved computational accuracy or stability. In contrast, for retriever-based tools, it may be important to evaluate whether multiple retrievals can enhance knowledge coverage.

For a given chemical task $\mathcal{T}$ and its corresponding tool library $\mathcal{L}$, the performance of an individual tool ($ToolA_i$) and its self-stacking ($A_i \to A_i$) is evaluated. If repeated invocations of the same tool type result in performance degradation, further stacking of that tool is discontinued. From each category, the top-k most effective tool combinations are selected for the next stage of stacking, as outlined in Algorithm~\ref{alg:HTS}.. 
These refined tool-stacking pathways are encapsulated as new tools, reducing the subsequent search space, improving computational efficiency, and providing stronger tool combination strategies for the next phase.
\subsection{Step 2: Multi-Layer Optimization}
\input{tables/algorithm-new}

%由于遍历 Top-k 最优工具组合，并结合所有工具进行进一步堆叠。计算不同堆叠方式的任务性能。若堆叠导致性能下降或达到设定的最大堆叠深度 n，则停止堆叠。选择最终性能最优的工具堆叠路径，作为该任务的最优执行轨迹（T*，Optimal Stacking Pathway）。

%By iterating through the Top-k most optimal tool combinations and further stacking them with all available tools, the task performance of different stacking configurations is evaluated. If stacking results in performance degradation or the predefined maximum stacking depth n is reached, the stacking process is terminated. The tool stacking pathway with the highest overall performance is selected as the task's optimal execution trajectory.

To explore the optimal invocation pathways across tool combinations and progressively encapsulate the best tools, ultimately determining the globally optimal tool invocation strategy, we divide the tool-stacking process into multiple layers and perform stacking optimization step by step.
In the first layer, the Top-1 computational tool selected in Stage 1 is combined with the Top-k retrieval tools, and the Top-1 retrieval tool is combined with the Top-k computational tools. Each agent is restricted to selecting the best tool from a pool of $m$ candidate tools in each step. If the optimal performance in this layer is worse than that of Stage 1, the stacking process is terminated; otherwise, the iteration continues.
In subsequent layers, all tools are re-ranked, and the top $k$ optimal pathways in each category are selected and encapsulated as new tools. This process continues until either the maximum number of layers $n$ is reached or no further optimization space remains.
Finally, the optimal tool invocation pathway is selected as the general tool invocation strategy for the given task.



