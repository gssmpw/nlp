\begin{algorithm}[H]
\caption{ChemHTS Algorithm}
\small
\label{alg:HTS}
\begin{algorithmic}[1]
\REQUIRE Training dataset $\mathcal{D}$, tool library $\mathcal{L}$ (including compute-based tools $\mathcal{L}_c$ and retriever-based tools $\mathcal{L}_r$), maximum hierarchy depth $n$, number of selected paths per category $k$, maximum tool selection per step $m$.
\ENSURE Optimized tool invocation strategy $\mathcal{P}^*$.

\STATE \textbf{STEP 1: SELF-STACKING WARMUP}
\FOR{each tool $T_i \in \mathcal{L}_c \cup \mathcal{L}_r$}
    \STATE Evaluate self-stacking paths of $T_i$ on $\mathcal{D}$.
\ENDFOR
\STATE Select the Top-$k$ best-performing paths for computational tools $\mathcal{P}_c$ and retriever tools $\mathcal{P}_r$.
\STATE Encapsulate selected tool stacks as new tools in $\mathcal{L}$.

\STATE \textbf{STEP 2: MULTI-LAYER OPTIMAZATION}
\STATE Initialize hierarchy level $L \gets 1$.
\WHILE{$L \leq n$}
    \STATE Sort computational tools $\mathcal{L}_c$ and RAG tools $\mathcal{L}_r$ based on performance metrics.
    \STATE Select Top-1 computational tool $T_c^*$ and Top-$k$ RAG tools $\mathcal{P}_r$.
    \STATE Select Top-1 RAG tool $T_r^*$ and Top-$k$ computational tools $\mathcal{P}_c$.
    
    \FOR{each tool subset $\mathcal{L}_L \subseteq (\mathcal{P}_c \cup \mathcal{P}_r)$, $|\mathcal{L}_L| \leq m$}
        \STATE Evaluate the performance of the tool invocation path.
        \IF{current best performance $\leq$ previous best performance}
            \STATE \textbf{STOP} stacking process.
            \STATE \textbf{BREAK}.
        \ENDIF
    \ENDFOR
    \STATE Encapsulate best-performing paths as new tools.
    \STATE $L \gets L + 1$.
\ENDWHILE


\STATE Select the best tool invocation path $\mathcal{P}^*$ as the final strategy.
\RETURN $\mathcal{P}^*$.

\end{algorithmic}
\end{algorithm}