\section{Related Work}
% \subsection{Patterns in computing practice}

% Design patterns. Alexander

%\subsection{Programming plans help explain how programmers think}
% \subsection{Programming plans can be used in a variety of instructional tools and methods}
\subsection{Improving Instruction With Programming Plans}

%Cognitive era (Soloway, Rist, PROUST, etc, etc)
% Programming plans help explain how programmers think. 

Informed by schema theory, Elliot Soloway and his students first described \emph{programming plans} in the 1980s \cite{soloway1980problems,soloway-yale-studies,soloway1985problems}. They defined plans as chunks of code that achieve particular goals, like guarding against erroneous data or summing across a collection. 
% Student progress in learning programming can be explained in terms of their understanding and use of plans. 
They provided evidence that knowledge of plans can represent progress in learning programming~\cite{soloway1986learning}, and student errors could be explained in terms of misunderstanding plans \cite{looping,highfreq} and plan composition errors \cite{putalltogether}. 
% In a recent review, Robins claimed ``There is considerable evidence that the plan is the basic cognitive unit used in program design and understanding''~\cite{robins201912}.
%More recently,  As we better understand how programmers think beyond CS1, programming plans will help us understand both novice and expert cognition.
%Green doesn't think patterns explain everything. 
% \subsection{How do people think about patterns?}
% Implicit vs explicit knowledge.
% Expert-novice differences.
Inspired by this, educational designers have used programming plans as scaffolding (assistance for learners~\cite{wood1976role}) to enable novice programmers to write more code than they would be able to on their own and designed plan-based curricula and tools~\cite{gpceditor, hohmann1992soda}. 
% In the 1980s and 90s, Soloway led a team to develop plan-based curricula and tools to support programming with plans. 
% The GPCeditor was a programming tool for students to support them in learning Pascal programming through the specification of goals and plans \cite{gpceditor}. 
% Students learned plans which they then transferred into a more traditional Pascal IDE.
% SODA extended the GPCeditor with support for program design and software engineering practices \cite{hohmann1992soda}. 
A variety of classroom instructional techniques have organized instruction around common patterns~\cite{clancy_designing_1996, muller_pattern-oriented_2007, muller_supporting_2008}, used plans to inform the design of instruction~\cite{Duran_ProgramComplexity_ICER-2018}, and evaluated students' expertise based on their ability to recall plans~\cite{arto_ava_reviewer}.
% Programming plans have been used in a variety of classroom instructional techniques as well. Clancy and Linn developed teaching methods that explicitly taught introductory programming topics using Pascal templates~\cite{clancy_designing_1996}. Muller and colleagues introduced Pattern-oriented Instruction, where instruction (again in introductory programming) is organized around common algorithmic patterns~\cite{muller_pattern-oriented_2007, muller_supporting_2008}. Duran et al. used programming plans to define the complexity of programs in a way that can better inform the design of instruction~\cite{Duran_ProgramComplexity_ICER-2018}. Heinonen et al. used recall ability of programming plans as a measure of students' expertise during a programming course~\cite{arto_ava_reviewer}.

However, until recently, these instructional approaches were confined to introductory courses as most well-established sets of plans have been identified from introductory programming content (e.g., \cite{Iyer_PatternCensus_SIGCSE-2021, wallingford1998elementary, izu_inventory_2021}). Recent work proposed the purpose-first programming approach~\cite{Cunningham_PurposeFirstProgramming_CHI-2021} to support conversational programmers~\cite{Chilana_RiseConversationalProgrammer_VLHCC-2015, conversational-programmers-industry_Chilana_CHI-2016}, showing that plan-based scaffolding can support students with learning goals beyond those of an introductory programming course. While earlier systems focused on supporting introductory programming learning, purpose-first programming included plans drawn from an applied coding topic, web scraping, making programs from that application area accessible to novices. With a more efficient plan identification process, we can more easily extend promising pattern-based approaches like purpose-first programming to new programming application areas. 

%% Suggest that knowing the common subgoals may be a cricual skill in the era of LLMs. <ACM article>

%``Designing patterns that students find accessible requires empirical investigation.''

% A set of programming plans is the foundation for all of the tools and instructional strategies described above. However, with only few exceptions, programming plan-based supports focus on introductory programming. Catalogs of programming plans in introductory programming content are the most well-established (e.g., \cite{Iyer_PatternCensus_SIGCSE-2021, wallingford1998elementary, izu_inventory_2021}), while very few programming plans have been identified in other areas. 

% \subsection{Technologies Can Support Automated Generation of Code Plans}
\subsection{Identifying Patterns in Programs Automatically}


Software engineering literature on the mining of \textit{code idioms}~\cite{haggis_code_similarity, jezero_code_similarity, code_similarity_newest} uses statistical natural language processing to extract semantically meaningful pieces from a code corpus. This approach has been extended to support program synthesis using these idioms~\cite{shin2019idiomssynthesis}.
%\edit{In addition, various techniques have been developed to perform program slicing for isolating faulty lines of code \cite{tip1994survey}. }
\edit{API development has been a fruitful context for the automated detection of programs with similar goals: static program slicing and machine learning techniques have been used to populate documentation of new APIs with relevant examples~\cite{montandon2013documenting, sohan2015spyrest} and statistical NLP has been used on OpenAPI data to suggest similar examples based on the content a programmer is currently developing~\cite{Moon_API-miner-API-to_API_FinanSE-2024}. } 
%SpyREST~\cite{sohan2015spyrest} is another tool that generates examples for specialized programming domains or Application Specific Interfaces (APIs) using machine learning techniques. 
%Other work, like, APIMiner~\cite{montandon2013documenting} uses a static slicing algorithm to identify key examples to help developers learning new APIs in Java.} 
%\edit{However, tools implementing these techniques \cite{anderson2001software, jayaraman2005kaveri} check code statements primarily for syntactic and logical validity, rather than authenticity or usefulness in educational contexts.}
%program slicing \cite{xu2005surveyprogramslicing}. 
%Similarly, t
Techniques for representing code in ways that facilitate machine learning methods (e.g. code2vec \cite{alon2019code2vec}) expand the toolbox for code clustering methods. \edit{Some code summarization frameworks extract important lines of code as an intermediate step~\cite{sun2023extractiveandabstractiveframeworksourcecode}.}
% , which can be adopted for plan generation because these statements may represent plans or key concepts that students should learn about.}
%\edit{ However, even though} 
%these systems utilize a large amount of real code on platforms like Github and StackOverflow, 
\edit{While these approaches provide exciting methods for finding meaningful code patterns, all such techniques are intended for the software engineering community or experienced developers. Thus, they do not incorporate any pedagogical concerns that instructors may} consider when identifying programming plans, limiting their applicability to instruction. Understanding these pedagogical concerns 
\edit{may pave the way for} these natural language processing and machine learning approaches to be incorporated into instructional tools. % Today, more code than ever before is available to analyze with more methods than ever before.
% \edit{While similar tools like  have been tested with undergraduate learners; they do not allow experts to edit or refine the given examples. Supporting instructors in refining the mined examples to better align with their audience's prior knowledge levels and learning objectives would scale the adoption of these tools in generating instructional content.} 

% \edit{Prior work has identified techniques to mine common programs from existing codebases. For instance, 
% Such examples may also increase the cognitive load for novice learners, diminishing their ability to learn the purpose behind code and impacting their transferability. 
% Extracting programming plans that mask low-level implementation details and allow learners to focus on the purpose that code achieves would better align with their learning objectives.}


Recent work in HCI has \edit{used some of the above methodologies to not only collect common patterns, but also display} commonalities in code samples in ways that support learning and instruction. Glassman et al. clustered student programming assignment data to reveal common learner misunderstandings in an interface built for instructors \cite{glassman2015studentsolutions}. 
Glassman et al. also visualized varieties of API calls from StackOverflow data~\cite{Zhang_StackOverflowAPIMining_ICSE-2018} to reveal common use cases to learners \cite{glassman2018visualizingapi}. \edit{CodeScoop~\cite{head2018interactive} eases the process of extracting complete and compilable code examples from larger programs to support developers sharing examples with their communities.} 
% However, complete code examples may be complex and contain surface-level features that may confuse novice learners.
Although these \edit{systems may} help instructors, these works do not attempt to produce high-level code plans that emphasize the purpose of code over their implementation details. 
% abstracted from particular implementations. 
Forming concrete guidelines on how experts perform this abstraction process can inform the design of systems that support instruction.
% While this identification of code patterns can aid instructors, it is different from programming plan identification because it focuses on incorrect student code rather than canonical code plans. 
% This approach is closer to identifying programming plans, but it shows many variations of use surrounding a single API call, rather than discrete code ``chunks'' (see Figure~\ref{fig:teaser}).

% Hinges on the ability to compare pieces of code for similarity, which is a difficult challenge. AST? Gets at structural similarity, but may miss functionality/semantics differences. Character similarity? May be too similar in context. Haggis, etc have innovative approaches, but their focus on ASTs means that their implementations are language-specific, and will be challenging for instructors to readily use. 

\subsection{Incorporating Large Language Models Into Computing Education}
% \subsection{Generating and interpreting code with large language models}

While large language models (LLMs) have not yet been used for identifying programming plans, their capability to generate code and related natural language descriptions has been widely established. In addition to solving programming exercises of varying topics and difficulty with high accuracy~\cite{finnie-ansleyRobotsAreComing2022, finnie-ansleyMyAIWants2023, wangExploringRoleAI2023}, LLMs have been employed to generate programming exercises in custom contexts~\cite{sarsaAutomaticGenerationProgramming2022b, logachevaEvaluatingContextuallyPersonalized2024} and novel assignment types that produce code using student explanations as input~\cite{dennyPromptProblemsNew2024, dennyExplainingCodePurpose2024}. Moreover, using LLMs to generate code explanations produced simpler and more accurate explanations compared to student submissions~\cite{leinonenComparingCodeExplanations2023}. Jury et al. further evaluated the code explanation capabilities of LLMs by generating worked examples, which are step-by-step solutions used for demonstrating the problem-solving process of an expert to a student, through expert assessment and a large-scale user study, showing that LLMs can not only generate code but also generate explanations on different levels of abstraction to explain the program to a novice learner~\cite{juryEvaluatingLLMgeneratedWorked2024a}. Despite these extensive capabilities, in the context of interactive design for education, the use of LLMs has been mostly limited to applications designed for \textit{students}, such as extensions for existing development environments~\cite{ferdowsiValidatingAIGeneratedCode2024, yanIvieLightweightAnchored2024, liTutorlyTurningProgramming2018}, programming assistants~\cite{kazemitabaarCodeAidEvaluatingClassroom2024, liffitonCodeHelpUsingLarge2024, yangDebuggingAITutor2024}, and interactive learning environments~\cite{jinTeachAIHow2024}.

Some studies also observed that LLM-generated code may include structures unfamiliar to novices~\cite{juryEvaluatingLLMgeneratedWorked2024a} or fail to follow industry best practices~\cite{ciprianoGPT3VsObject2023}. A potential research direction is designing tools to support \textit{instructors}, who might be better suited to address incorrect or inappropriate outputs generated by these models. 
% Thus, LLMs may be an appropriate candidate for automating parts of the plan identification process only if they are utilized in systems that incorporate the concerns that instructors consider when identifying programming plans. 
\edit{While this area has not been explored extensively, studies have shown the promise of using LLMs for authoring learning objectives \cite{sridhar2023harnessing}, instructional content generation, grading, and question generation \cite{wang2024large}. \citet{mollick2023assigning}
explored the promise and pitfalls of AI as a tutor, coach, mentor, teammate, tool, simulator, and student, concluding that AI can be a ``force multiplier'' for teachers when used appropriately and in alignment with best practices. }
%https://link.springer.com/chapter/10.1007/978-981-99-5414-8_61
% https://arxiv.org/html/2403.18105v1
%%%% Two ideas for this RW improvement: Have one LLM section that mentions the capabilities of LLMs AND design considerations with LLMs, or have one with generating code and have one with supporting people
% \subsection{Designing LLM-supported tools for computing education}
% \edit{Recent work has also explored the use of LLMs as tutors \cite{}. However, when using LLMs as tutors, instructors need to ensure that the LLM agents promote inclusive environments \cite{} and work effectively in diverse scenarios that may arise in classroom settings. To assist instructors in refining their pedagogical conversational agents, researchers designed TeachTune \cite{jin2024teachtunereviewingpedagogicalagents}, an instructor-facing tool that allows instructors to test their PCAs in 
\edit{One such example of ``instructor-in-the-loop''} is VIVID~\cite{choiVIVIDHumanAICollaborative2024a}: a tool for helping instructors revise lecture videos into dialogue-style material. 
\edit{Another is TeachTune \cite{jin2024teachtunereviewingpedagogicalagents}, which incorporates a split-screen interface that allows instructors to evaluate and refine their pedagogical conversational agents. This interface enables users to build their agent using a graph-like state machine representation on one side while simultaneously observing the agent's real-time behavior with simulated students on the other.}
\edit{WEAT \cite{hassany2024humanaicocreationworkedexamples, hassany2024authoring} utilizes LLMs to generate first draft line-by-line explanations for code in worked examples which can then be edited by instructors. \citet{leiker2306prototyping} showed the potential of reducing human involvement in learning material generation for adult learners using LLMs.}

\edit{These tools} present promising precedent for systems that could help instructors generate content by presenting initial drafts of materials and supporting interactions for refinement. \edit{These tools can facilitate collaboration between the instructors and the LLM, leveraging LLMs' content generation capabilities and instructors' pedagogical expertise to create instructional content that follows best practices and aligns with learners' goals \cite{viola2023human}.} LLMs may be an appropriate candidate for automating parts of the plan identification process only if they are incorporated into a system that allows instructors to address their concerns with the generated content. 


%With the benefit of advances in machine learning and program analysis, it appears that the automatic detection of programming plans could be within reach. However, it's unclear whether simply finding pieces of code that are common in practice is sufficient to meet the quality threshold instructors are looking for. Approaches for generating common code from large code corpuses have not yet been employed in the process of generating programming plans for instructional purposes, so it is unclear how to incorporate these technologies into the creation of curriculum for novices. In our interview study, we investigate the full process of plan identification as it is currently performed in order to suggest where automated code pattern identification can complement or replace human insight.

% To satisfy these three goals, we will use a process that builds on several recent advances in code clustering and program analysis. First, we will identify common \textit{code idioms} \cite{allamanis2014miningidioms} in our corpus, representing an initial set of subgoals. Next, we will use program slicing methods \cite{xu2005surveyprogramslicing, head2018extractingexamples} to expand upon these subgoals and identify cohesive, larger instances of these idioms' use that are frequently present in the code corpus. Finally, these larger examples will be clustered \cite{glassman2015studentsolutions}, resulting in a final set of plans, subgoals, and slots.

