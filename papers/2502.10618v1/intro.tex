\section{Introduction}

%%% Design argument notes
% Outcome: Code pattern appropriate for instruction for any programming domain
% Obstacles: 
% - Unclear how to do the process. 
% - Not automated. 
% - Automated is unclear if appropraite for instuctional use
% - Experts in various programming areas may not be aware of programming plans

% Characteristic:
% - Have components , metrics
% - Automatically generates plans that meet the metrics and components



% \begin{quote}
%     Get into a rut early: Do the same processes the same way. Accumulate idioms. Standardize. 
%     The only difference(!) between Shakespeare and you was the size of his idiom list — not the size of his vocabulary.

%     -- Alan Perlis, "Epigrams on Programming" \cite{}

% \end{quote}

% \begin{quote}
%     In programming, everything we do is a special case of something more general — and often we know it too quickly.

%     -- Alan Perlis, "Epigrams on Programming" \cite{}
% \end{quote}

% canonical
%%% Takeaway: Using programming plans improves instruction but they are not utilized in nonintro

\begin{figure*}
\centering
\Description{Four example programming plans from prior work. The first one is captioned `Get a soup from multiple web pages', and shows a Python program with subgoal labels. Some parameters are replaced with fill-in-the-blanks boxes. The second one is captioned `Encapsulation in Object-oriented Programming', and shows a Python class definition with color coding for parts that could change. The third one is captioned `Find a value of the list that satisfies a certain condition', and a pseudocode solution is given with changeable parts highlighted. The fourth one is captioned `Arrange-Act-Assert Testing', and includes testing code with some parts highlighted.}
\includegraphics[width=\textwidth]{img/example_plans_teaser.pdf}
\caption{Programming plans that educators have already identified from a variety of programming domains, including (from left to right) web scraping with Beautiful Soup~\cite{Cunningham_PurposeFirstProgramming_CHI-2021}, introductory object-oriented programming~\cite{Iyer_PatternCensus_SIGCSE-2021}, introductory procedural programming~\cite{Wermelinger_problems-to-programs}, and testing with RSpec~\cite{LojoFox_TestingPlan_ITiCSE-2022}.}
\label{fig:example-plans}
\end{figure*}

Programming plans, also known as programming patterns \cite{Iyer_PatternCensus_SIGCSE-2021, muller_pattern-oriented_2007} or code idioms \cite{haggis_code_similarity}, are short, stereotypical solutions that can be adapted to solve various problems with programming (see Figure~\ref{fig:example-plans}). Knowledge about programming plans has long been considered a significant aspect of programming expertise: 
% After a while, any programmer will notice that they read and write similar pieces of code over and over again. These ``stereotypical'' or ``canned'' solutions are known by several names, including programming plans \cite{Soloway1984EmpiricalSO, spohrer_goalplan_1985}, These common plans have been proven to be a crucial aspect of computer science education:
%This consistent coding style 
% Consistent use of programming plans is valued in the programming community. 
% Alan Perlis commands readers of his ``Epigrams on Programming'' \cite{epigrams-on-programming_Perlis_SIGPLAN-1982} to \textit{``Do the same processes the same way. Accumulate idioms.''} He suggests that knowledge of code plans is key to strong programming with an analogy: \textit{``The only difference(!) between Shakespeare and you was the size of his idiom list...''}
% Perlis was proven right by the psychology of programming.
%A defining mark of expertise in a domain is understanding meaningful patterns of information~\cite{ExpertNoviceDifferences_HowPeopleLearn_2000}. 
the ability to recognize programming plans in code differentiates novices from experts~\cite{Soloway1984EmpiricalSO}, and knowledge of plans seems to underlie effective code writing~\cite{robins201912, spohrer_goalplan_1985}. 
% These canonical approaches or "schemas" are known as \textit{programming plans}.  
% Programming plans have psychological validity as a representation of how programmers think \cite{robins201912}, 
% In an effort to understand and lessen the gap between new and seasoned programmers, computing educators have cataloged programming plans since the 1980s (e.g., ~\cite{Spohrer1985-pi, Rist1989-fo, muller_pattern-oriented_2007, izu_inventory_2021}, see Figure~\ref{fig:teaser} for examples). Once collected, these plans are foundational to certain 
%instructional approaches, either by explicitly teaching the plans~\cite{Clancy}, or cleverly organizing examples and assessment  to ensure ~\cite{muller_pattern-oriented_2007} and understand differences in course content across institutions~\cite{Iyer_PatternCensus_SIGCSE-2021}.
When instructional strategies in computing education provide support in the form of programming plans, they can improve learners' ability to solve programming problems~\cite{Castro_ImpactSingleLecturePlans_Koli2017, muller_pattern-oriented_2007, Weinman_Fox_Faded_Parsons}. However, work that describes sets of programming plans~\cite{Spohrer1985-pi, Rist1989-fo, muller_pattern-oriented_2007, izu_inventory_2021, Iyer_PatternCensus_SIGCSE-2021} and that applies those plans in instructional tools~\cite{ Weinman_Fox_Faded_Parsons, Jigsaw} has so far been largely limited to only introductory programming content.

Recent research has shown that \textit{domain-specific} programming plans, which are plans from application-focused domains of programming such as data analysis or machine learning, can be effective in teaching and motivating a diverse set of students. Domain-specific plans have been used to support computer science majors learning software testing~\cite{LojoFox_TestingPlan_ITiCSE-2022}, expanding on the successful use of a similar tool in introductory programming~\cite{Weinman_Fox_Faded_Parsons}. 
A tool that guided students to learn and apply plans in a new topic area (web scraping with BeautifulSoup) was shown to motivate less confident ``conversational programmers''~\cite{Chilana_RiseConversationalProgrammer_VLHCC-2015} by giving them a brief and purpose-oriented overview of a new programming domain~\cite{Cunningham_PurposeFirstProgramming_CHI-2021}. 
These promising results imply that using programming plans in the instruction of a wider variety of programming topics can support learners in reaching their learning objectives. 



\subsection{Challenges in Widespread Adoption of Plan-focused Pedagogies}
%%% There are obstacles for domain-specific plan identification
A major barrier in expanding plan-focused pedagogies to application-focused domains may be the difficulty of identifying the relevant programming plans in the first place. There are several challenges that prevent instructors from easily identifying these domain-specific programming plans.
One is the opaqueness of the plan identification process. Most computing education publications that identify plans 
%have focused on introductory programming, and they 
%in introductory programming 
do not describe their process and omit crucial details necessary to replicate the process in another domain. A more transparent process for plan identification may help experts identify plans in application-focused domains so they can better support learners interested in those applications. 
%Particularly, understanding which \textit{components} of a plan are the most important for instructors, which \textit{characteristics} instructors look for when evaluating programming plans, and what are the main \textit{challenges} during plan identification would unravel the current plan identification process and support the identification of domain-specific plans.
% Particularly, we seek the answers to these three questions to unravel the current plan identification process: 
% \begin{itemize}
%     \item \textbf{Q1:} Which components in a plan are the most important for instructors?
%     \item \textbf{Q2:} How do instructors evaluate the quality of a programming plan?
%     \item \textbf{Q3:} What are the main challenges instructors have to solve when identifying programming plans?
% \end{itemize}
Secondly, what we do know about programming plan design suggests that instructors' state-of-the-art process is fully manual, and therefore potentially tedious and effortful. The cost of designing programming plans for more niche, application-focused domains may be deemed too high by instructors. A more efficient and supportive process could lower this barrier of entry, thereby enabling programming plan design for more instructors in diverse fields. %Third, instructors may not yet be aware of the potential benefits of teaching in ways that utilize programming plans. 

There may be an opportunity for technologies to support domain-specific programming plan identification, but much is still unknown about how to best use these technological advances to support instructors in their plan identification process.
While there have been efforts in the software engineering community to automatically identify common code pieces~\cite{haggis_code_similarity, jezero_code_similarity, code_similarity_newest}, these approaches do not consider pedagogical aspects of identified constructs and likely do not meet the needs of instructors. However, with the latest developments in technologies such as large language models (LLMs) that can effectively explain and generate code~\cite{juryEvaluatingLLMgeneratedWorked2024a}, it might now be possible to build tools that support the identification of domain-specific programming plans by reducing the workload of instructors. % and enable plan identification across many programming application areas. 
However, it is currently unclear what the needs of instructors working on plan identification are, as well as how their process for designing programming plans can be improved. 



%%% Takeaway: However, plans are only identified in introductory domains due to a lack of transparency
% While many works have identified plans common in introductory programming content (e.g. ~\cite{Spohrer1985-pi, Rist1989-fo, muller_pattern-oriented_2007, izu_inventory_2021, Iyer_PatternCensus_SIGCSE-2021}), instruction that incorporates plans beyond introductory level are few and far between. Despite the success of instructional approaches that utilized plans for teaching advanced plans such as software testing~\cite{LojoFox_TestingPlan_ITiCSE-2022} and web scraping~\cite{Cunningham_PurposeFirstProgramming_CHI-2021}, plan identification efforts failed to generalize beyond introductory content. Plan identification seems to be an opaque process that is difficult to replicate as the prior work tends to omit details about the process itself. Clarifying the procedures followed in plan identification could help instructors enhance their students' abstraction and problem-solving skills through plans in more application-focused domains, like writing machine learning algorithms in TensorFlow or performing data analysis in Pandas.
%are still an area with space for improvement.more application-focused 
%the impact of programming plans on computing instruction is limited by the fact that published collections of programming plans are almost entirely drawn from introductory programming content. Certainly, programmers coding in more application-focused domains like creating computer graphics in WebGL, writing machine learning algorithms in PyTorch, and performing data analysis with Pandas also encounter and use common, meaningful code chunks. If an instructor wanted to identify  relevant programming plans in any of these topics for their students, they would have to undergo a completely manual procedure with no technical support. So far, code plan identification for instructional purposes has been performed by hand, in what appears to be a tedious and lengthy process. Even if an instructor wished to replicate a published plan identification process, they would find that authors rarely share any details about their procedures. 

%What's worse, instructors who want to identify plans can't depend on the literature for guidance: publications where programming plans are listed rarely share any details about their plan identification methodology. Even in cases where publications share part of the process, it is not in sufficient precision to inform ways that the process may be automated or otherwise supported with technology.

% Another roadblock in  the definition of programming plans is often vague \cite{Robins}. Adding to the confusion is the common use of the term "programming patterns" . In this paper, we focus on 
% specific enough to be implemented line by line
% relatively small chunks of code. 
% Programming plans are different than programming patterns.
% Not more architectural, not more general. 
% Some educators still use the term ``pattern'' to refer to 
% For example, Model-View-Controller

%Work in identifying and publishing programming plans has been primarily been performed in the context of introductory programming courses, but there are opportunities for programming plans to benefit students other than those in their first programming course. Instruction that incorporates programming plans may support advanced students to accelerate their understanding of new areas, like software testing \cite{LojoFox_TestingPlan_ITiCSE-2022}. For non-majors, learning with programming plans has shown promise to help novices focus on \textit{why} programmers write code in application domains like web scraping, without bogging down learners in syntax details \cite{Cunningham_PurposeFirstProgramming_CHI-2021}. 


%Understandably, work with programming plans has been at the novice level. But there is potential for more. 
% Vision: an instructor can have support while creating code templates for their class. This enables them to help students with problem-solving, or to share common subgoals of programming task completion.
% Advanced students may be even more apt to benefit from patterns, as their foundational programming knowledge is firmly in place. 

% We found that authors rarely describe exactly how they found new plans. 


%While many such experts teach introductory programming, the number of individuals who deeply understand both a programming domain and what is likely to work for students decreases for topics considered more advanced. 


% %%% Takeaway: Transparent plan identification can enable technical support
% Transparent principles for plan identification can enable the design of technologies to support instructors, particularly for plans in topics beyond introductory programming. %More specifically, a well-designed sociotechnical system has the potential to make the plan identification process more efficient by automating some of the tedium in finding programming plans. 
% While algorithms and approaches for finding common code idioms exist with impressive results (e.g. \cite{haggis_code_similarity, jezero_code_similarity, code_similarity_newest}), the benefits and drawbacks of applying such technologies to identify plans for \textit{instruction} demands more consideration. Specifically, plan identification for instruction concerns both pedagogical and technical aspects.
% %In addition, such a system may be able to mitigate the issue that the number of individuals who are knowledgeable about the concept of programming plans and also deeply understand a particular advanced programming topics may be fairly small.
% A plan identification system could facilitate communication between instructors and individuals with the relevant expertise to identify programming patterns in more advanced programming domains. However, a deep understanding of the needs of instructors is necessary to design systems that could facilitate the sharing of required expertise. To understand these needs, we pose the following research questions:
% \begin{itemize}
%     \item \textbf{RQ1:} What do instructors look for when identifying plans in a domain?
%     \item \textbf{RQ2:} Could an automated pipeline (e.g. ChatGPT) for identifying plans in application-focused domains meet the needs of instructors?
% \end{itemize}

% To address these obstacles for identifying domain-specific plans, we seek the answers to two research questions:
% \begin{itemize}
%     \item \textbf{RQ1:} What are the components, characteristics, and challenges relevant for the plan identification process?
%     \item \textbf{RQ2:} How can LLMs (e.g. ChatGPT) support the identification of domain-specific plans?
% \end{itemize}
\subsection{Introducing PLAID and its Design Process}
We present PLAID, a pedagogically-informed 
\textbf{\ul{PLA}}n \textbf{\ul{ID}}entification tool for instructors. 
%to support plan identification LLMs.
% that supports instructors to 
%\textbf{pla}n \textbf{id}entification 
% system that supports instructors to more efficiently design domain-specific programmming plans that are pedagogically appropriate for their students.

To guide the design of PLAID based on the needs and challenges of instructors during the programming plan identification process, we conducted a formative study that included semi-structured interviews with ten computer science education researchers who had identified programming plans and used plans in instruction. We present insights into the current state-of-the-art in programming plan design, and we identify design opportunities for three major challenges instructors face in the design process.
% which we confirm is performed manually by instructors, 
% often with heavy use of reference materials and frequently in discussion with others to support iterative improvement. 
% We report key aspects of the current design process, including the components instructors search for, desired plan characteristics, and what types of expertise they draw on to make decisions. 
% We note challenges in their current process relevant to the identification of domain-specific programming plans, and opportunities for sociotechnical systems to support programming plan design.
Our findings suggest that simply identifying common code patterns is not sufficient for designing programming plans that meet pedagogical goals, preventing the process from being completely automated. 
Therefore, we propose a sociotechnical system that accelerates instructors' current design process
while standardizing the results
as the 
the best path to support plan-focused pedagogies in application-focused domains at scale. %identification of domain-specific programming plans.


% Big idea: supporting abstraction ability. That goes beyond just programming plans.

Through a series of design workshops with instructors, we contribute design goals for developing this sociotechnical system that assists instructors in identifying domain-specific programming plans.
Based on observations and feedback from seven instructors wit expertise in application-focused programming domains, 
% who designed plans with both the standard approach and with the support of LLM-generated candidate plans, we develop design guidelines for systems that support domain-specific programming plan identification.
% These guidelines suggest that
we identify key interactions to support efficient viewing of reference material with many code examples, easy refinement of automatically generated candidate plans, support for exploring unfamiliar code functionality, and the ability to organize identified plans in a meaningful sequence.

% We enact those design goals in PLAID, a 
% \ul{pla}n \ul{id}entification 
% %\textbf{pla}n \textbf{id}entification 
% system that supports instructors to more efficiently design domain-specific programmming plans that are pedagogically appropriate for their students.
We enact those design goals in PLAID, enabling instructors to view, understand, and edit a variety of LLM-generated domain-specific example programs and candidate plan content as they design programming plans in a standardized template. We show that the design of PLAID is effective based on a within-subjects evaluation study with 12 computing instructors that showed that instructors experienced lower cognitive demands and had a lower overall task load while using PLAID compared to a baseline condition representative of the current state-of-the-art. Instructors were able to design more plans and use their time more efficiently with PLAID, and they found using PLAID satisfying. Instructors liked having access to the large and diverse set of generated reference materials in the interface and were able to utilize those materials optimally to identify plans based on their own existing ideas as well as come up with novel plan ideas.
PLAID can be used to identify domain-specific plans in a wide variety of application-specific programming domains, supporting plan-based pedagogies at scale.
% Instructors using PLAID also required...time to design...quality... 
% Instructors used PLAID in a variety of styles and with a difference in engagement with LLM-generated candidate content. Our results suggest that ... most useful for ... novice instructors vs experienced instructors...


\subsection{Summary of Our Contributions}

% More about design? We learn that the LLM pipeline has to be well-designed and aligned with the pedagogical approach. LLMs can be used to generate content that makes educators' work more efficient, freeing up their time to work on more important issues. 
% PLAID demonstrates a way of using LLM-generated content to support the curriculum design process of instructors. We learned that presenting content is not sufficient, rather, the content should be generated in ways that align with best practices, and navigation should support targeted focus and instructor goals.... We work to balance 
% ____ supports ____
% Our key contributions include:


This work explores how the capabilities of large language models can be utilized to support educators in the adoption of promising instructional approaches.
%rooted in educational research and theories. 
% With PLAID, we show a concrete example of how LLM-generated content can decrease tedious parts of instructor process, given that they are presented in environments designed to capture instructor values. 
% in interfaces  tools can support instructors in embracing best practices for teaching. 
With PLAID\footnote{PLAID is available at http://tryplaid.web.illinois.edu/.}, LLM-generated reference content replaces the tedious parts of the plan identification process, allowing instructors to spend their effort primarily in areas that require pedagogical expertise: refining plans to better support the learning of their students. We show a concrete example of how LLMs can empower instructors by automating repetitive information-gathering tasks, allowing them to focus on tasks that require abstraction and other human expertise. 
This was achieved by treating instructors as key stakeholders throughout the design process, informing the design of all aspects of our tool with instructor needs, from the phrasing of the LLM prompts to the interactions with generated content.
%minimizing their time spent gathering examples of tasks students need to complete, while also supporting the instructors' ability to abstract and generalize examples for instructional use.
%In this way, we combine the relative strengths of both LLMs and instructors to reach a better outcome together.


Our contributions are three-fold: 
First, we gather insights into instructor practices for programming plan identification and the challenges they face
% for plan-focused pedagogies, 
which has not been documented previously. Second, we identify opportunities to support plan identification and present design goals for incorporating LLM-generated content into instructor workflows for designing plan-focused instruction.
Finally, we design and evaluate a system that combines LLMs' strengths with instructor expertise, showing that it accelerates the design of programming plans and holds potential for increasing the adoption of plan-focused pedagogies in any given domain. 
% Finally, we suggest design considerations for supporting instructors using emerging technologies without undermining individual expertise, educational research, and prior theory.

% Using the design guidelines, we proposed an LLM-powered domain-specific plan identification pipeline. Incorporating LLMs in the generation of programming plans is not as straightforward as ``prompt engineering.'' One-shot or few-shot learning approaches for programming plan generation offer little promise due to the lack of identified plans in specific application areas. We carefully used a chain-of-thought prompting approach to identify each component in an example and clustered similar examples together into plans. Our web interface assists instructors in viewing the generated candidate plans and enables interactions that they would use as part of their pattern identification process. This system was then evaluated using a within-subjects user study with instructors and graduate students experienced in creating instructional content and knowledgable in an application of computing. 
% it via quantitative and qualitative metrics based on findings from our interview study. Our work reveals that plan identification requires various kinds of expertise, and automated systems can support plan identification. 
% Our key contributions are as follows:
% \begin{itemize}
%     \item 
%     %\item We present an LLM pipeline that not only identifies common code patterns in an arbitrary programming domain, but also suggests values for all plan components instructors find valuable, such as the goal of the code pattern and parts of code that are commonly changed. A face value evaluation finds this method to identify plans that are similar to instructor-identified plans in the domain of web scraping. 
%     \item 
%     \item 
% \end{itemize}

%But to design such technologies, 

%Mirroring the paucity of CSEd research beyond CS1 \cite{}, 
%Also, this programming plan identification has been performed by those with expertise in \textit{both} instruction and the relevant programming domain.  

%% Can beef up!!
% To design plan identification systems that meet the needs of computing educators, 
% we need to understand what those educators hope to achieve during the plan identification process, and how we can hope to address their current challenges. 
% To guide future work, we need to understand the process of plan identification as it currently exists, and opportunities to make it more efficient and effective. 
%, including exactly what plan identifiers look for, and how they judge their own success. 
%In publications, 
%The process of identifying programming plans is rarely described in detail precise enough to automate or standardize. 
 
%What opportunities are there for improving the process? For implementing the process in topic areas outside of CS1? For using technology to make this process more efficient? 
%In this paper, we contribute:
%(1) A literature review of published programming plan identification strategies, 
%(2)
%(1) A detailed description of plan identification processes as described by pattern identifiers in the CSEd community, and 
%(2) Implications for the design of tools to support instructors and curriculum designers with the process of plan identification.

% \subsection{Summary of Contributions}

% % \subsubsection{A literature review of published programming plan identification strategies}

% % We began to understand the process of programming plan identification with a survey of the computing education and HCI literature about programming plans. We found that authors rarely describe exactly how they found new plans. Even in cases where publications share part of the process, it is not in sufficient precision to inform ways that the process may be automated or otherwise supported with technology.

% % Challenges in the process as it currently exists, and challenges for identifying plans in additional domains.


% %% In order to characterize key challenges and tradeoffs that instructors make when identifying programming plans. 
% In order to understand the state of the art in programming plan identification for educational purposes, we performed an interview study with ten computing educators who have identified programming plans. Analysis resulted in the following contributions:

% \subsubsection{A deep and specific understanding of computing educators' current plan identification process}

% We describe several aspects of the plan identification process, including (a) the particular components of programming plans that educators look for, (b) the characteristics that educators use to judge quality of plans, (c) the procedures educators use during the identification process,
% % (c) the actions educators typically perform during the identification process,
% and (d) the types of expertise plan identifiers utilize during plan identification.
% % this matches the order we present the findings in later, also added the word 'metrics'
% % With an understanding of the components, \edit{metrics, and }procedures typically in use in educators' plan identification process, as well as what they consider their greatest challenges, \edit{we can inform the design of a socio-technical system to support the plan identification process}.  
% %We interviewed authors of the papers in our literature review to understand in specific detail the ways people educators programming plans. 
%  %components, procedures, metrics


% %Programming patterns can support student learning by bridging the gap between the code and the problems it solves. They can be a motivating way to learn for conversational programmers in the form of domain-specific patterns that can help them learn about the applications of CS in their domain. Yet, the plan identification process largely has been restricted to a CS1 context, so these goals can’t be achieved; if we had programming plans in more areas, we could better support student learning.  Ambiguous plan definitions and unclear approaches to identifying patterns makes it challenging for experts in a non CS1 domain to identify patterns. 

% %Thus, based on our analysis of the interview transcripts, we list all the possible things that our interviewees felt should be parts of a plan including it's name, goal, rationale, solutions, and examples.
% %We also identify metrics to evaluate the candidate plans identified. These include the commonality, abstraction level, and the usability of a plan. Essentially, these metrics help identify "good" plans that best suit the needs of the audience.  

% % what makes a programming plan “good”.

% %\subsubsection{Research Study and Qualitative Analysis to Understand the Current Process}

% %The process of identifying code patterns is unclear in published work, as authors list their results but not how they got there. We conduct a study where we interview 10 CS educators about their process of identifying patterns and perform qualitative analysis of the interview transcripts. We observed that looking at sample programs including patterns as well as code, discussions with other experts and colleagues about refinement and elimination of potential patterns, and drawing on past experiences to identify patterns were some of the strategies that were used.

% % new approach to programming instruction requires new approaches!

% %\subsubsection{Roles that Various Types of Expertise Play in the Plan Identification Process}

% %The process of finding patterns has been restricted to a manual identification. With this study, we aimed to find more concrete details about the plan identification process to move towards implications to design a system that automates some of this process. As a part, we uncover the contributions that humans provide in the process by evaluating the importance of domain-specific and instructional expertise. While instructors have the necessary skills to best convey the patterns to their audience, industry experts have the knowledge to identify patterns that can be used in large practice. Together, they rely on their past experiences to intuit patterns.

% % (domain-specific expertise, instructional expertise).
% % We likely need humans in the loop, but we don’t fully understand what humans contribute

% \subsubsection{The challenges that computing educators face when identifying programming plans}

% We find that in their experience, educators found identifying programming plans from example programs and problems challenging and tedious. Educators also found it difficult to establish the right level of abstraction for a programming plan. When considering plan identification in the future, educators had low confidence in their ability to identify programming plans within an unfamiliar programming topic, at least without the help of an expert in the relevant area.

% \subsubsection{Opportunities for the design of systems for plan identification}

% %Implications for the design of tools to support instructors and curriculum designers with the process of plan identification.

% %So far in the education space, programming plan identification has been performed by hand. This is not efficient, and not scalable across many domains. 
% We propose approaches for systems to facilitate the ability of instructors to identify novel programming plans. With an understanding of the components, characteristics, and procedures relevant to the plan identification process, we suggest several opportunities for design as well as a system-level design approach that augments stages of the plan identification process with technology. We describe new, technology-backed plan identification processes that can aid in the generation of candidate plans, can automate values used to understand plan quality, and can connect people with various relevant expertise to identify plans collaboratively.

% %Using the identified parts of a plan, we believe that it is possible to design a system that can generate candidate plans. There is potential to add constraints to this system with the metrics to evaluate plans, so that the system can also verify candidate plans. This automates the "tedious" part of the plan identification process.

% %Only by understanding how What can be supported with technology, and what depends on human expertise?

% %Learners planning to be end-user programmers \cite{Ko_EndUserSoftwareEngineering_2011} or conversational programmers \cite{Wang_ConversationalPorgrammerLearningFailure_CHI-2018} want to know more than CS1 content. They want to know what’s possible to achieve with code \cite{Dorn_WebDesignersPerspectives_ICER-2010,  Cunningham_ConversationalProgrammerLearningGoals_SIGCSE-2022}, in domains of interest like data visualization or mobile applications. 

% %Centering instruction on \textit{domain-specific programming plans} can highlight code’s applications, while also
% %scaffolding  difficult tasks, like writing code in a new domain \cite{Cunningham_PurposeFirstProgramming_CHI-2021}. We define a domain-specific programming plan as a piece of code common to programs from a particular application area, (e.g., text parsing) that achieves a specific goal in that context.

% %However, identifying % domain-specific programming
% %plans across many application areas is challenging. 
% %While extensive work has identified patterns in CS1 programs \cite{Iyer_PatternCensus_SIGCSE-2021}, 
% %those plans are too general to represent work in specific topic areas.
% %Further, authors typically omit details of their plan identification process (e.g., \cite{Iyer_PatternCensus_SIGCSE-2021, Quilici_RecognizingProgrammingPlans, Duran_ProgramComplexityFromaCognitivePerspective_ICER-18}), leaving methodology for future plan identification unclear.

% \begin{figure}
% \centering
% \includegraphics[width=0.5\textwidth]{img/overall-methods-new3.png}
% \caption{An overview of the stages of our study.}
% \label{fig:overall-methods}
% \end{figure}