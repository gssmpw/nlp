%%
%% This is file `sample-manuscript.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% samples.dtx  (with options: `manuscript')
%% 
%% IMPORTANT NOTICE:
%% 
%% For the copyright see the source file.
%% 
%% Any modified versions of this file must be renamed
%% with new filenames distinct from sample-manuscript.tex.
%% 
%% For distribution of the original source see the terms
%% for copying and modification in the file samples.dtx.
%% 
%% This generated file may be distributed as long as the
%% original source files, as listed above, are part of the
%% same distribution. (The sources need not necessarily be
%% in the same archive or directory.)
%%
%% Commands for TeXCount
%TC:macro~\cite [option:text,text]
%TC:macro~\citep [option:text,text]
%TC:macro~\citet [option:text,text]
%TC:envir table 0 1
%TC:envir table* 0 1
%TC:envir tabular [ignore] word
%TC:envir displaymath 0 word
%TC:envir math 0 word
%TC:envir comment 0 0
%%
%%
%% The first command in your LaTeX source must be the \documentclass command.
%%%% Small single column format, used for CIE, CSUR, DTRAP, JACM, JDIQ, JEA, JERIC, JETC, PACMCGIT, TAAS, TACCESS, TACO, TALG, TALLIP (formerly TALIP), TCPS, TDSCI, TEAC, TECS, TELO, THRI, TIIS, TIOT, TISSEC, TIST, TKDD, TMIS, TOCE, TOCHI, TOCL, TOCS, TOCT, TODAES, TODS, TOIS, TOIT, TOMACS, TOMM (formerly TOMCCAP), TOMPECS, TOMS, TOPC, TOPLAS, TOPS, TOS, TOSEM, TOSN, TQC, TRETS, TSAS, TSC, TSLP, TWEB.
% \documentclass[acmsmall]{acmart}

%%%% Large single column format, used for IMWUT, JOCCH, PACMPL, POMACS, TAP, PACMHCI
% \documentclass[acmlarge,screen]{acmart}

%%%% Large double column format, used for TOG
% \documentclass[acmtog, authorversion]{acmart}

%%%% Generic manuscript mode, required for submission
%%%% and peer review
% \documentclass[manuscript,review,anonymous]{acmart}
% \documentclass[authorversion]{acmart}
\documentclass[sigconf, screen]{acmart}
\setcopyright{none}

\usepackage{xcolor}  % Include this line in the preamble
% \usepackage{subfig}
\usepackage{listings}

\lstset{
  breaklines=true,            % Enable breaking long lines
  breakindent=0pt,            % Ensure no indentation after line
  basicstyle=\ttfamily,       % Set font for listings
  frame=single,               % Add a frame around the listings
  breakautoindent=false,      % Disable automatic indentation after
  prebreak={}                 % No special character or space before
}

% \newcommand{\edit}[1]{\textcolor{orange}{#1}}


% Extra packages
\usepackage{multirow}
\usepackage{makecell}
\usepackage{cleveref}
\usepackage{float}
\crefname{figure}{Figure}{}
\crefname{section}{Section}{}
\usepackage{soul} %for better underlining
\usepackage{graphicx}
\usepackage{subcaption}


%% Fonts used in the template cannot be substituted; margin 
%% adjustments are not allowed.
%%
%% \BibTeX command to typeset BibTeX logo in the docs
\AtBeginDocument{%
  \providecommand\BibTeX{{%
    \normalfont B\kern-0.5em{\scshape i\kern-0.25em b}\kern-0.8em\TeX}}}

%% Rights management information.  This information is sent to you
%% when you complete the rights form.  These commands have SAMPLE
%% values in them; it is your responsibility as an author to replace
%% the commands and values with those provided to you when you
%% complete the rights form.
% \setcopyright{acmcopyright}
% \copyrightyear{2025}
% \acmYear{2025}
% \acmDOI{XXXXXXX.XXXXXXX}

% %% These commands are for a PROCEEDINGS abstract or paper.
% \acmConference[CHI '25]{CHI Conference on Human Factors in Computing Systems}{April 26--May 1, 2025}{Yokohama, Japan}
% %
% %  Uncomment \acmBooktitle if th title of the proceedings is different
% %  from ``Proceedings of ...''!
% %
% \acmBooktitle{CHI '25: CHI Conference on Human Factors in Computing Systems,
%  April 26--May 1, 2025, Yokohama, Japan} 
% \acmPrice{15.00}
% \acmISBN{978-1-4503-XXXX-X/18/06}

% \copyrightyear{2025}
% \acmYear{2025}
% \setcopyright{cc}
% \setcopyright{none}
% \setcctype{by}
\acmConference[CHI '25]{CHI Conference on Human Factors in Computing 
Systems}{April 26-May 1, 2025}{Yokohama, Japan}
% \acmBooktitle{CHI Conference on Human Factors in Computing Systems (CHI 
% '25), April 26-May 1, 2025, Yokohama, 
% Japan}
\acmDOI{10.1145/3706598.3713832}
\acmISBN{979-8-4007-1394-1/25/04}



%%
%% Submission ID.
%% Use this when submitting an article to a sponsored event. You'll
%% receive a unique submission ID from the organizers
%% of the event, and this ID should be used as the parameter to this command.
%%\acmSubmissionID{123-A56-BU3}

%%
%% For managing citations, it is recommended to use bibliography
%% files in BibTeX format.
%%
%% You can then either use BibTeX with the ACM-Reference-Format style,
%% or BibLaTeX with the acmnumeric or acmauthoryear sytles, that include
%% support for advanced citation of software artefact from the
%% biblatex-software package, also separately available on CTAN.
%%
%% Look at the sample-*-biblatex.tex files for templates showcasing
%% the biblatex styles.
%%

%%
%% The majority of ACM publications use numbered citations and
%% references.  The command~\citestyle{authoryear} switches to the
%% "author year" style.
%%
%% If you are preparing content for an event
%% sponsored by ACM SIGGRAPH, you must use the "author year" style of
%% citations and references.
%% Uncommenting
%% the next command will enable that style.
%%\citestyle{acmauthoryear}

%%
%% end of the preamble, start of the body of the document source.
\begin{document}

%%
%% The "title" command has an optional parameter,
%% allowing the author to define a "short title" to be used in page headers.
\title{PLAID: Supporting Computing Instructors to Identify Domain-Specific Programming Plans at Scale} %: Needs, Challenges, and Solutions}
%\title{The Process of Programming Plan Identification and Its Challenges}

\author{Yoshee Jain}
\authornote{Indicates that both authors contributed equally to the paper.}
\orcid{0009-0005-6291-5438}
\affiliation{%
  % \department{Siebel School of Computing \\ and Data Science}
  \institution{University of Illinois Urbana-Champaign}
  % \streetaddress{201 N. Goodwin Ave}
  \city{Urbana}
  \state{Illinois}
  \country{USA}
}
\email{yosheej2@illinois.edu}

\author{Mehmet Arif Demirta\c{s}}
\authornotemark[1]
\orcid{0000-0001-5674-5878}
\affiliation{%
  %\department{Siebel School of \\ Computing and Data Science}
  \institution{University of Illinois Urbana-Champaign}
  % \streetaddress{201 N. Goodwin Ave}
  \city{Urbana}
  \state{Illinois}
  \country{USA}
}
\email{mad16@illinois.edu}

\author{Kathryn Cunningham}
\orcid{0000-0002-9702-2796}
\affiliation{%
  % \department{Siebel School of Computing and \\ Data Science}
  \institution{University of Illinois Urbana-Champaign}
  % \streetaddress{201 N. Goodwin Ave}
  \city{Urbana}
  \state{Illinois}
  \country{USA}
}
\email{katcun@illinois.edu}

%%
%% The "author" command and its associated commands are used to define
%% the authors and their affiliations.
%% Of note is the shared affiliation of the first two authors, and the
%% "authornote" and "authornotemark" commands
%% used to denote shared contribution to the research.

%%
%% By default, the full list of authors will be used in the page
%% headers. Often, this list is too long, and will overlap
%% other information printed in the page headers. This command allows
%% the author to define a more concise list
%% of authors' names for this purpose.
\renewcommand{\shortauthors}{Yoshee Jain, Mehmet Arif Demirta\c{s}, \& Kathryn Cunningham}

%%%portion for highlighting edits
% \definecolor{editCol}{RGB}{255,140,0}
\definecolor{editCol}{RGB}{0,0,0}
% \definecolor{editCol}{RGB}{0,0,0}
\newcommand{\edit}[1]{{\textcolor{editCol}{#1}}}

%%
%% The abstract is a short summary of the work to be presented in the
%% article.
\begin{abstract}
Pedagogical approaches focusing on stereotypical code solutions, known as programming plans, can increase problem-solving ability and motivate diverse learners. However, plan-focused pedagogies are rarely used beyond introductory programming. Our formative study (N=10 educators) showed that identifying plans is a tedious process. To advance plan-focused pedagogies in application-focused domains, we created an LLM-powered pipeline that automates the effortful parts of educators' plan identification process by providing use-case-driven program examples and candidate plans. In design workshops (N=7 educators), we identified design goals to maximize instructors' efficiency in plan identification by optimizing interaction with this LLM-generated content. Our resulting tool, PLAID, enables instructors to access a corpus of relevant programs to inspire plan identification, compare code snippets to assist plan refinement, and facilitates them in structuring code snippets into plans. We evaluated PLAID in a within-subjects user study (N=12 educators) and found that PLAID led to lower cognitive demand and increased productivity compared to the state-of-the-art. Educators found PLAID beneficial for generating instructional material. Thus, our findings suggest that human-in-the-loop approaches hold promise for supporting plan-focused pedagogies at scale.



% % Programming plans are important for programming ability
% Knowledge of programming plans, which are stereotypical code patterns that achieve a goal, is key to programmers' ability to write programs.
% % Programming ability may be improved with explicit instruction
% When computing educators are armed with a set of programming plans, they can take advantage of instructional techniques that may accelerate their students' learning.
% % Explicit instruction requires sets of plans
% However, plan identification is an effortful process that is not well documented in prior work. 
% % 
% Moreover, existing sets of plans are primarily drawn from introductory programming content, so plan-based instructional techniques are not yet possible for many programming application domains, like web scraping, data analysis, web development, or machine learning model creation.
% % Through interviews with ten computing educators who have identified novel plans
% With our formative study, we contribute a comprehensive understanding of the current plan identification process, including the plan components instructors value, the characteristics by which plans are judged, and critical challenges.
% Using a design workshop with seven instructors, we present key design guidelines for developing systems that support instructors' plan identification process. 
% Applying these design guidelines, we designed <should we name the system?> that presents instructors with complete contextualized programs as reference material.
% <name of the system> supports various interactions, enabling educators to use reference material effectively, understand domain-specific content, gather inspiration from given material, and organize information into plans.
% Our within-subjects evaluation study demonstrates...


% an LLM-supported plan identification pipeline and evaluate it in comparison to a set of expert-identified plans in the web scraping domain. 
% Our work provides important implications for automating plan identification, including where and how processes may be automated, and how these processes can be augmented with an instructor in the loop.

% When instructors know the common patterns programmers use to write code in their topic of expertise, they can design their teaching in more fruitful ways. However, these programming patterns or programming plans have mostly been identified in the context of CS1 problems, so our community does not yet understand code patterns in most application-focused or advanced programming domains. In order for instructors to develop pattern-focused instruction across more topics in computer science, more programming patterns need to be identified across a wider number of topic areas. 
% The ability of CS Educators to describe programming plans is hampered by the fact that the process of programming pattern identification is not well-understood. While several researchers have cataloged programming patterns, they rarely share their methodology. Better understanding of this process is not only useful for others to repeat programming plan identification by hand, but also to inform the design of sociotechnical systems that support instructors to identify programming plans more efficiently, effectively, and in new domains. 
% We interviewed 10 CS Education researchers who identified programming plans in order to describe the process of plan identification in specific detail. We list typical components of programming plans, metrics by which plans are judged, procedures used to identify plans, and the types of expertise these pattern identifiers brought to bear. We also provide implications for the design of systems for improved plan identification, including where and how processes may be automated, and which procedures still require an instructor ``in the loop''.

%To move towards an effective process for domain-specific plan identification, we propose metrics to describe the quality of domain-specific plans and detail %three 
%techniques for discovering them. 
%We hope this poster encourages discussion around approaches for identifying domain-specific programming plans, as well as how to measure success in such efforts. 


%%%%% Alternative abstract proposal
% 
%\\\\
% % Programming plans are important for programming ability
% Knowledge of programming plans, which are stereotypical code patterns that achieve a goal, is key to programmers' ability to write programs.
% % Programming ability may be improved with plan focused instruction
% When computing educators are provided with a set of programming plans for teaching, they can take advantage of instructional techniques that may accelerate their students' learning.
% % Plan-focused instruction cannot be applied beyond introductory
% However, programming plans beyond introductory programming have not been curated in prior research efforts.
% % Our effort carries this beyond introduction
% Our work unveils the process of identifying programming plans and scaffolds the experience of instructors in this process through a novel design artifact.
% % Through interviews with ten computing educators who have identified novel plans
% We conduct interviews with 10 instructors who have curated introductory plans in prior work, uncovering their process through a set of values and challenges.
% Informed by our interviews, we create a set of design considerations through workshops with 7 participants from 2 application-specific domains to imagine how the plan design process should be structured beyond introductory programming.
% Our tool, PLAID, combines insights from interviews with design considerations from workshops to empower instructors with domain knowledge to design instructional content for novice learners. 
% PLAID allows instructors to access many relevant programs at once, compare program pieces easily, and modify programs to structure them into plans.
% We evaluate PLAID in a within-subjects user study with 12 participants from 3 application-specific domains (machine learning with Pytorch, data analysis with Pandas, and web development with Django). 
% We show that participants experienced lower cognitive demand and were more productive using PLAID. Moreover, instructors found PLAID to be beneficial for generating instructional material.

% \\\\
% Knowledge of programming plans, which are stereotypical code patterns that achieve a goal, is key to programmers' ability to write programs. When computing educators are equipped with a set of programming plans for teaching, they can take advantage of instructional techniques that may accelerate their students' learning. However, programming plans have been primary identified in introductory programming. The process of plan identification is not well documented in prior work yielding to the lack of plans beyond introductory programming. Our work unveils the process of identifying programming plans and scaffolds the experience of instructors in this process through a novel design artifact.
\end{abstract}

%%
%% The code below is generated by the tool at http://dl.acm.org/ccs.cfm.
%% Please copy and paste the code instead of the example below.
%%
\begin{CCSXML}
<ccs2012>
   <concept>
       <concept_id>10003456.10003457.10003527</concept_id>
       <concept_desc>Social and professional topics~Computing education</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
   <concept>
       <concept_id>10003456.10003457.10003527.10003531.10003533</concept_id>
       <concept_desc>Social and professional topics~Computer science education</concept_desc>
       <concept_significance>500</concept_significance>
       </concept>
 </ccs2012>
\end{CCSXML}

\ccsdesc[500]{Social and professional topics~Computing education}
\ccsdesc[500]{Social and professional topics~Computer science education}

%%
%% Keywords. The author(s) should pick words that accurately describe
%% the work being presented. Separate the keywords with commas.
\keywords{programming plan, programming pattern, pattern identification, instructor support}

%% A "teaser" image appears between the author and affiliation
%% information and the body of the document, and typically spans the
%% page.
\begin{teaserfigure}
\centering
\Description{A three-stage figure showing how PLAID can be utilized. On the left, an instructor is looking at a set of LLM-generated programs and editing parts of the program to identify similarities. An arrow saying ``Identify programming parts in application focused-domains'' connects this to middle part, where multiple plans are shown as short code snippets with annotations. An arrow saying ``Support plan-focused pedagogies in that domain'' connects this to the right part, which shows different use cases for plans. These include `Organize course content', `Create examples', and `Build assessments'.}
\includegraphics[width=0.84\textwidth]{img/teaser-new.png}
\caption{PLAID supports instructors to more efficiently identify programming plans (i.e., common code patterns and information about their use) in application-focused programming domains by supporting their ability to explore and refine AI-generated content. Plan identification is a crucial step in the development of promising plan-based pedagogies. 
%With PLAID, instructors explore example programs generated and annotated with AI, refine suggested content into programming plans, and organize plans in preparation for supporting students.
}
\label{fig:teaser-why-plaid-matters}
\end{teaserfigure}
% \begin{teaserfigure}
%   \centering
%   \includegraphics[width=\textwidth]{img/example_plans_teaser.png}
%   \centering
%   \caption{Programming plans that educators have already identified from a variety of programming applications, including (from left to right) web scraping with Beautiful Soup~\cite{Cunningham_PurposeFirstProgramming_CHI-2021}, introductory object-oriented programming~\cite{Iyer_PatternCensus_SIGCSE-2021}, introductory procedural programming~\cite{Wermelinger_problems-to-programs}, and testing with RSpec~\cite{LojoFox_TestingPlan_ITiCSE-2022}.}
%   %, code patterns from a domain area are identified and annotated with information that highlights their purpose. These patterns are used to develop a curriculum where learners study plans, write code, debug code, and understand code.}
%   \Description{This diagram shows 4 examples of different plans that we observed in our literature review. It includes the web scraping plan that helps get a soup from multiple web-pages, the software engineering plan that expresses encapsulation in object-oriented programming, the introductory programming plan that finds a value of the list that satisfies a certain condition and the software testing plan that symbolizes arrange-act-assert testing.}
%   \label{fig:teaser}
% \end{teaserfigure}

%%
%% This command processes the author and affiliation and title
%% information and builds the first part of the formatted document.
\maketitle

\input{intro}

\input{background}

\input{overview}

\input{challenges}

% \input{discussion}

%\input{discussion-study1}

% \input{llm-plan-generation}

% \input{llm-plan-evaluation}

\input{design-workshop}

% \input{example-scenario}

\input{system}

% \input{system-implementation}

\input{evaluation-study}

% \input{final-evaluation}

% \input{discussion-study2}

%\subsection{Limitations}

\input{eval-discussion}

\input{limitations-and-future-work}

\section{Conclusion}
\edit{In this paper, we present PLAID, a tool that assists instructors in generating programming plans in application-focused programming domains, a crucial step towards the use of plan-based pedagogies.
Such pedagogies have shown promising outcomes for introductory programming learners, but have not been applied to application-focused programming domains such as data analysis or machine learning.
Through formative interviews (N=10 educators), we identified how creating programming plans that capture high-level patterns in these domains can be challenging and tedious, even with access to AI-generated content. 
Through design workshops (N=7 educators), we derived design goals detailing how AI-generated content should be presented to instructors to make this plan creation process more efficient.
Our findings from a mixed methods within-subjects user study (N=12 educators) show that during the plan identification process, instructors experience lower cognitive demands and overall task load with PLAID, find it more satisfying to use, and prefer it over traditional approaches.
Our work not only addresses the challenges in generating programming plans for application-focused programming domains but also contributes design considerations to guide the development of ``human-in-the-loop'' AI tools.
We find that instructors can leverage LLMs to effectively author instructional material when the LLM-generated content is presented in a format that reflects best practices and reduces distractions. }
% Future work should explore other interactions for presenting LLM-generated content 
We believe PLAID can be easily extended to support plan identification in many application-focused programming domains, potentially encouraging the adoption of plan-based pedagogies at scale. Moreover, our design goals and insights from instructor-LLM interactions can inform the design of tools that support instructors in creating content in their domain of expertise. 

% By providing access to relevant code examples generated by large language models compiled in one interface with interactions designed to ensure greater efficiency,  refining the content.

% Plan-based pedagogies have shown promising outcomes in enhancing knowledge acquisition for novices in introductory programming. 
% Introducing plan-focused pedagogies in application-focused domains, like data analysis or machine learning, can help propagate these positive outcomes to a broader audience. 
% However, our formative study revealed that the current state of the art in programming plan identification, a prerequisite for plan-based pedagogies, is a lengthy manual procedure. % good!
% Following a design workshop with instructors, we propose design goals to motivate the design of interfaces that help instructors interact with LLM-generated content effectively and efficiently.
% We developed PLAID, an interface that enables educators to access a corpus of relevant reference material that they can navigate to generate abstract, high-level programming plans.
% Due to its LLM pipeline, PLAID can be easily extended to support plan identification in many application-focused programming domains, potentially encouraging adoption of plan-based pedagogies at scale.
% By enabling effective interactions between LLMs and instructors, PLAID combines LLMs' content generation capabilities and instructors' pedagogical expertise to create instructional content that aligns with best practices. 
% \edit{We designed PLAID to improve instructor experience while creating programming plans to encourage more instructors to adopt plan-based pedagogies. However, designing programming plans is an intermediate step in creating instructional content that uses plan-based pedagogy and future work can explore techniques that effectively incorporate plans in instruction to meet the learning objectives of students.} 
% We believe our design goals and insights from instructor-LLM interactions can inform the design of tools that support instructors in creating content in their domain of expertise.





% It is motivating to explore if they can be introduced in the design of curricula in application-focused domains like data analysis or machine learning. 
% PLAID addresses the challenges for this broader adoption by generating candidate plans and programs, enabling efficient exploration of this content, and providing tools for effective refinement of plans.
% Importantly, as PLAID generates content using an automated pipeline, it could be easily applied to any domain.
% Our studies with instructors show that LLM-generated content can greatly improve instructor processes by scaffolding information-gathering tasks, and instructors become interested in applying plan-focused pedagogies in their domains.
% We believe our design goals and insights from instructor-LLM interactions can inform tools for supporting instructors to enhance their ability to create quality content for learners.






 %enhance their ability to create quality content for learners.

% create learner-centric content.

% Thus, PLAID can assist instructors from any domain to incorporate plan-based pedagogy into their curricula. 

% PLAID builds on the relative strengths of both LLMs and instructors, using an LLM pipeline based on instructors' desired characteristics to generate ``first draft'' content, and supporting instructors' ability to abstract general concepts from the LLM-generated examples.

% Due to its LLM pipeline, PLAID can be easily extended to support plan identification in a wide number of application-focused programming domains, potentially encouraging adoption of plan-based pedagogies at scale.


% Our evaluation study highlights that participants experience a lower overall task load and found PLAID beneficial for generating instructional material.
% Thus, PLAID may help instructors design plans for in-class modules, questions on assessments, or cheatsheets.

% Instructors can utilize LLM-generated content in instructional design, as long as certain design goals are met...
% Systems can support instructors to more quickly generate key abstractions that can support instructional design. By enabling instructors to efficiently view and manipulate a diverse set of use cases, their ability to identify abstract concepts was improved, and their experience was more positive. 
% Instructors can benefit from systems that support curriculum design by providing key abstractions %that support instructional design. 
% Having access to a diverse set of use cases that can be efficiently viewed and manipulated improved their experience in identifying abstract concepts. 
% We find that LLM-generated content can be beneficial to instructors by providing a diverse set of examples of programming use cases, but this benefit might only be present if the content is organized correctly. 






% llms can support instructors but not out of the box. instructor needs to make use of content but we cannot replace instructors



% The current state of the art in programming plan identification is a lengthy manual procedure. ...



% With a more efficient, technologically-supported plan identification process, educators may be able to use programming plans in their instruction for a wide range of subjects beyond introductory programming. In this study, we gathered concrete details about the current state of the art in plan identification processes to understand what plan components instructors seek, what metrics they use to judge success, and where they face challenges. 
%Given the rise of large language models and generative AI technologies, 
% Then, we explored the use of ChatGPT as an aid in the plan identification process 
%and described its strengths and shortcomings. 
% and found that it could generate candidate programming plans with significant similarity to instructor-designed plans, however, many of the plans' explanatory components were not well attuned to the needs of beginning learners. These results suggest that the way forward in plan identification across domains should involve collaboration between LLMs and instructors.
% The current state of the art in programming plan identification is a lengthy manual procedure. With the aid of a more efficient, technologically-supported plan identification process, educators may be able to use programming plans in their instruction for a wide range of subjects beyond introductory programming.  In this study, we gathered concrete details about the current state of the art in plan identification processes to understand what is important to instructors \edit{and where they face challenges, in order to} inform the design of a system that automates some of the plan identification process. As we lay a groundwork for the design of systems for plan identification, we note that it is unlikely that humans will no longer be a part of choosing programming plans for educational purposes. 
% %Plan identifiers' instructional experience and programming experience both play a role in choosing and refining plans. While it may be possible to spread the work of one educator by distributing it to different individuals, the human element will not disappear.
% As computing educators are tasked with teaching an increasingly diverse set of learners with widely varied interests, we believe that plan identification systems can support them to develop instructional material that not only based on the psychology of programming, but also is more tailored to their students' interests. 
%\section{Domain-specific Plan Quality}
%We propose three metrics for the quality of a %domain-specific programming 
%plan.
%\begin{itemize}
%     \item \textit{Frequency in Professional Use}: The plan should be commonly used in well-written programs.
%     \item \textit{Comprehensibility to Novices}: While understanding likely requires domain-specific content knowledge, plan information should not be too complex. 
%     %Since these plans are being identified for novice instruction, the understandability of the piece of code is essential.
%     \item \textit{Alignment with Domain Context}: The plan should achieve a goal specific to its domain. %rather than something generic.
% \end{itemize}


% \section{Identification Approaches}
% \subsection{Code Corpus Analysis}

% Repositories like StackOverflow and GitHub hold billions of lines of code \cite{billions_cite}.
% %that undoubtedly contain domain-specific patterns. 
% By scraping, one can collect corpuses of programs in particular topics and search them for patterns, by hand (as in \cite{Cunningham_PurposeFirstProgramming_CHI-2021}) or possibly with code similarity algorithms \cite{Allamanis_MiningCodeIdioms_FSM-2014}.
 
% By analyzing many programs on a platform used by % industry
% professionals, these plans can claim \textit{frequency in professional use}. However, the goal of a plan is challenging to intuit from code alone, although comments or metadata may yield insight. Ensuring \textit{alignment with domain context} likely requires domain-specific expertise. Similarly, this approach offers no inherent advantage in \textit{comprehensibility}.% will require additional work.% as well.

% \subsection{Expert Instructor Opinion}

% % Domain-specific programming 
% Plans may also be found in code written by instructors of %advanced or
% specialized courses. These patterns can be collected from assignments
% %or exams designed for university students, 
% or by interviewing instructors. %directly.

% Instructors 
% %may or may not have connections to industry practice, but they 
% likely have %special 
% insight into designing plans \textit{comprehensible to novices}. 
% As instructors are knowledgeable in their topic area, the plans they create are probably \textit{aligned with domain context}.  
% However, this approach can feasibly include only few instructors, who may or may not be familiar with industry standards. These plans' \textit{frequency in professional use} is unclear.

% \subsection{Guided Expert Pattern Elicitation}

% %Experts in a domain certainly know relevant programming patterns \cite{Soloway1984EmpiricalSO}.
% %, although they may need support to articulate them. 
% Plans may be gathered from domain experts by interviewing them about their %own 
% programs, with questions designed to elicit common patterns and goals.

% With enough interviews, this approach could identify plans \textit{frequent in professional use}. Well-designed prompts may support \textit{alignment with domain context}. Expert blind spot \cite{Nathan_ExpertBlindSpot_2001} presents a challenge in achieving \textit{comprehensibility to novices}, although questions inspired by cognitive task analysis \cite{Catrambone_TAPS_2011} may help.

%%
%% The acknowledgments section is defined using the "acks" environment
%% (and NOT an unnumbered section). This ensures the proper
%% identification of the section in the article metadata, and the
%% consistent spelling of the heading.
\begin{acks}
We thank the members of the TRAILS Lab for their insightful feedback. We also express our gratitude to the reviewers for their thoughtful and valuable suggestions. We extend our appreciation to the CS STARS program, the Siebel School of Computing and Data Science, the Campus Honors Program, and the Office of Undergraduate Research at the University of Illinois Urbana-Champaign for funding that contributed to this work.
\end{acks}
\newline
%%
%% The next two lines define the bibliography style to be used, and
%% the bibliography file.
\bibliographystyle{ACM-Reference-Format}
\bibliography{bib/bib_new
, bib/background, bib/sample-base, bib/paperpile, bib/mark, bib/cps, bib/SBF-review}

\appendix
\input{appendix}

\end{document}
\endinput
%%
%% End of file `sample-authordraft.tex'.
