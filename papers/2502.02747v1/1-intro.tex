\section{Introduction}
\label{sec:intro}

% background and problem
Automatic patching of issues and vulnerabilities has long been a challenging task in software engineering and security~\cite{jiang2021cure,le2021automatic,monperrus2018automatic,gazzola2018automatic}. 
Before the emergence of generative AI, automated code generation primarily relied on program synthesis~\cite{feng2018program,huang2019using}, which requires human-written specifications and cannot be applied to complex programs due to the constraints of SMT solvers.
With the recent success of LLMs in various generative tasks~\cite{peng2023study,lian2023llm,ghosal2023text,huang2024audiogpt}, particularly in code generation~\cite{zhu2024deepseek,claude3,achiam2023gpt,team2023gemini,roziere2023code}, researchers recently started exploring their applications in automatically fixing software vulnerabilities. 
They build LLM-based agents that automatically analyze and fix issues in real-world codebases~\cite{wang2024openhands,liu2024marscode,ruan2024specrover,zhang2024autocoderover,yang2024swe}.

% limitation of existing methods
Technically speaking, existing patching agents consist of three main components: localization, generation, and validation.
The localization component identifies the code snippets responsible for the issue that need to be fixed. 
The generation component produces patch candidates, while the validation component selects the final patch from candidates.
There are two ways to schedule these components:
agent-based planning\cite{yang2024swe,moatless,zhang2024autocoderover,IBM_SWE1_0,liu2024marscode,CodeR,pedregosa2011scikit,ma2024lingma,wang2024openhands,Amazon_Q}, which utilizes LLMs to dynamically determine the patching workflow for different issues;
and human-based planning\cite{xia2024agentless,ouyang2024repograph} that follows a fixed, predefined workflow for all issues, as specified by humans.
Although achieving high patching performance, agent-based planning methods suffer a high cost and are not stable, which significantly limits their applicability in the real world.   
In contrast, existing human-based planning methods are more stable and cost-efficient but have limited patching performance due to limitations in their planning workflows.

% our method
In this paper, we present \sys, a novel patching framework that balances the~\textit{patching efficacy, stability, and cost-efficiency}. 
At a high level, \sys designs a human-based planning workflow composed of five components: reproduction, localization, generation, validation, and refinement.
Given an issue as input, \sys first reproduces the issue and retrieves related testing cases and finds the root cause (code snippets causing the issue) through localization. 
Its generation and validation components then generate patch candidates and validate whether they fix the issues while preserving the benign functionalities. 
Unlike existing human-based patchers\cite{xia2024agentless}, which regenerate patches from scratch whenever validation fails, \sys introduces a novel refinement component that iteratively improves the current patch based on validation feedback. This refinement continues until the patch passes validation (i.e., becomes “qualified”) or the iteration limit is reached.
%This design is based on our observation that refining partially corrected patches is typically more effective than regenerating the patches from scratch. 
This design is aligned with the human patching workflow, which requires multiple rounds of trials and errors. 

As specified in~\cref{sec:technique}, each component has its own technical challenges, and we introduce specified designs to address them. 
Specifically, first, we not only reproduce the issue but also find related benign tests, which later are critical for determining whether the generated patches break normal functionalities during the validation.
Second, we design our localization to provide not only the root cause but also the related context that is necessary for patching, and design additional tools for localization to retrieve necessary information from the codebase.
Third, for generation, we break it down into patch planning, which produces a multi-step patching plan, and patch generation, which generates patches following the plan.
This design is inspired by the recent emergence of inference-phase reasoning~\cite{wei2022chain,yao2024tree,yang2024buffer}. 
Having a detailed plan can explicitly prompt the LLM to think deeper and reason about the issue and give more comprehensive patching solutions, which is more effective than directly prompting the model to generate the whole patch.   
% Finally, we include both vulnerability tests and functionality tests in validation to ensure the generated patches do not break the benign functionalities. 

% characteristics
Through extensive evaluations, we first show that \sys outperforms all SOTA open-source methods on the SWE-Bench-Lite and SWE-Bench-Verified benchmark~\cite{jimenez2023swe}.
Besides, we show that \sys achieves the lowest cost among both top open-source and closed-source methods, validating its balance in patching accuracy and cost-efficiency.
Second, we demonstrate that \sys is more stable than the SOTA agent-based planning method \openhands~\cite{wang2024openhands}, validating the advantage of human-based planning in terms of stability. 
Finally, we validate the key designs discussed above through a detailed ablation study and demonstrate that \sys is compatible with multiple SOTA LLMs. 
Although \sys is not on top of the SWE-Bench, to the best of our knowledge, it achieves the best balance between patching performance, stability, and cost-efficiency. 
These are critical for practicality, making \sys a promising candidate for deployment in real-world scenarios.
We will open-source our implementation, agents, and logs on SWE-Bench.