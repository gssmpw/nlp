\section{Existing Patching Agent and Limitations}
\label{sec:rw}

% general workflow
At a high level, existing patching agents mainly have three components: localization, generation, and validation. 
The \emph{localization} component pinpoints the code snippets that cause the issue and need to be fixed (denoted as ``root cause''), the \emph{generation} produces patch candidates, and the \emph{validation} 
tries to find a final patch in the candidates.
Although they have similar components, based on planning strategies, existing patching agents can be categorized into \emph{agent-based planning} and \emph{human-based planning}.
Agent-based planning leverages LLMs to determine the patching workflow (i.e., deciding when and which components to call), which can be different from different issues. 
On the contrary, human-based planning follows a fixed workflow for all issues pre-specified by humans.
% In the following, we introduce the methods in each category and discuss their limitations.

\noindent\textbf{Agent-based planning.}
Most existing patching agents follow agent-based planning.
However, most of them are closed-source: Marscode Agent~\cite{liu2024marscode}, Composio SWE-Kit~\cite{Composio}, CodeR~\cite{CodeR}, Lingma~\cite{ma2024lingma}, Amazon Q~\cite{Amazon_Q}, IBM Research SWE-1.0~\cite{IBM_SWE1_0}, devlo~\cite{devlo}, Gru~\cite{gru}, and Globant Code Fixer Agent~\cite{Globant_Code_Fixer_Agent}.
Here, we focus on the open-source approaches.

A notable early method is SWE-Agent~\cite{yang2024swe}, which has only localization and generation and leverages an LLM planner to drive the patching process. 
To assist the planner in calling functions within each component, SWE-Agent provides an Agent-Computer Interface (ACI), which grants LLMs the ability to execute bash commands and handle file operations (e.g., \texttt{file\_open} and \texttt{func\_edit}).
Follow-up works improve SWE-Agent by either improving its current components (AutoCodeRover~\cite{zhang2024autocoderover}) or incorporating additional components (Moatless~\cite{moatless, antoniades2024swe} and SpecRover~\cite{ruan2024specrover}).
Notably, Moatless and SpecRover add a validation component.
This component first lets LLM generate an input that can trigger the issue (denoted as ``Proof-of-Concept (PoC)'') and then runs the PoC against the generated patches to decide if they fix the issue. 

So far, the SOTA open-source tool in this category is OpenHands~\cite{wang2024openhands}, which is inspired by the CodeAct Agent~\cite{wang2024executable}. 
OpenHands has three components: localization, generation, validation. 
Its validation follows a similar idea as SpecRover, i.e., reproducing and executing PoC to decide if the issue is fixed. 
Similar to the SWE-agent, OpenHands also designs an ACI for the agent.
% The key reason why OpenHands has high performance is that it provides web browsing capability and a PoC code execution environment for refinement.

\noindent\underline{Limitations.}
Agent-based planning approaches inherently suffer from two critical limitations. 
First, as probabilistic models, LLMs intrinsically have randomness. 
The randomness is aggregated and amplified when the model is making all critical decisions during the patching. 
This will significantly jeopardize the stability and reliability of the patching agents, hindering their real-world usage. 
Second, to reduce randomness, existing approaches conduct multiple samples and trials, and ensemble them to obtain the LLMs' decisions.
Moreover, LLMs often need multiple trials to obtain a correct decision. 
All these extra samples and trials significantly raise computational costs as well as financial costs as they need to use commercial models.  


\noindent\textbf{Human-based planning.}
Agentless~\cite{xia2024agentless} is the SOTA method following human-based planning. 
Agentless strictly follows a pre-defined sequential workflow, comprising localization, generation, and validation.
Specifically, for localization, Agentless designs a three-step procedure (file, function, line), where LLM is used to pinpoint the root cause at each step.
It directly queries LLM without leveraging the rich information in the code structure. 
Agentless's generation feeds the root cause and issue description to LLM and lets the model generate patch candidates.
It simply stacks the input information together without using advanced prompting strategies.
Its validation is similar to the agent-based planning methods introduced above.
RepoGraph~\cite{ouyang2024repograph} improves the localization by providing a repository-level graph but without changing other components. 
Having a pre-specified workflow makes these methods more stable than agent-based planning methods.
It also allows the agent to integrate human knowledge. 

\noindent\underline{Limitations.}
Agentless's sequential workflow is overly restrictive. 
The agent cannot refine the root cause, generated patches, and PoCs if the patch candidates cannot pass the validation.
It has to start over again, which is less efficient. 
In addition, as discussed above, the individual components of Agentless and RepoGraph also have flaws. 


