\section{Background and Related Works}
\subsection{LLMs for Chip Design}

%芯片设计流程包括系统规格，架构设计，功能设计，逻辑综合，物理设计等多个环节[iEDA]。目前LLM在芯片设计的应用主要包括RTL代码生成，EDA脚本生成，芯片验证和领域知识问答四个方面。在代码生成任务中，文章【ChipGPT: How far are we from natural language hardware design】【AutoChip: Automating HDL Generation Using LLM Feedback】采用提示工程的方式利用LLM生成verilog代码并进行语法和功能验证；文章【Benchmarking Large Language Models for Automated Verilog RTL Code Generation】【VeriGen: A Large Language Model for Verilog Code Generation】【BetterV: Controlled Verilog Generation with Discriminative Guidance】【CodeV: Empowering LLMs for Verilog Generation through Multi-Level Summarization】【AutoVCoder: A Systematic Framework for Automated Verilog Code Generation using LLMs】采用指令微调的方式创建专用于Verilog代码生成的LLM，提高了生成的代码的质量。文章【RTLCoder: Fully Open-Source and Efficient LLM-Assisted RTL Code Generation Technique】【Large Language Model for Verilog Generation with Golden Code Feedback】【VerilogCoder: Autonomous Verilog Coding Agents with Graph-based Planning and Abstract Syntax Tree (AST)-based Waveform Tracing Tool】则基于LLM创建的Agent能够根据EDA工具的反馈生成质量更好的代码。文章【Data is all you need: Finetuning LLMs for Chip Design via an Automated design-data augmentation framework】【ChatEDA: A Large Language Model Powered Autonomous Agent for EDA】利用LLM生成操作EDA工具的脚本，自动化芯片设计流程。为了评估LLM生成verilog代码的语法和功能正确性，文章【VerilogEval: Evaluating Large Language Models for Verilog Code Generation】【RTLLM: An Open-Source Benchmark for Design RTL Generation with Large Language Model】【MG-Verilog: Multi-grained Dataset Towards Enhanced LLM-assisted Verilog Generation】提供了开源的数据集。然而这些数据集无法评估LLM的缺陷检测能力。
%此外，文章【VerilogReader: LLM-Aided Hardware Test Generation】【Evaluating LLMs for Hardware Design and Test】【LLM-based Processor Verification: A Case Study for Neuromorphic Processor】【AutoBench: Automatic Testbench Generation and Evaluation Using LLMs for HDL Design】【LLM4DV: Using Large Language Models for Hardware Test Stimuli Generation】使用LLM生成测试激励，测试芯片的覆盖率。使用LLM作为一个辅助设计人员的全能助手，通过与设计人员的交互，能够完成芯片的初步设计。【Chip-Chat: Challenges and Opportunities in Conversational Hardware Design】【Towards LLM-Powered Verilog RTL Assistant: Self-Verification and Self-Correction】【Customized Retrieval Augmented Generation and Benchmarking for EDA Tool Documentation QA】【ChipNeMo: Domain-Adapted LLMs for Chip Design】。先前的工作通过使用LLM结合EDA工具，揭示了LLM在芯片设计中的强大能力。然而，与此不同的是，我们这项工作探索原生LLM的能力【The Dawn of AI-Native EDA: Promises and  Challenges of Large Circuit Models】，在不使用EDA工具辅助下，首次使用LLM作为Linting工具完成verilog代码缺陷检测任务。


The chip design process includes system specification, architectural design, functional design, logic synthesis, and physical design ____. Recent advancements highlight the application of LLMs in chip design across four primary directions, RTL code generation, EDA script generation, chip verification, and domain-specific knowledge Q\&A. In RTL code generation, researchers have employed LLMs to generate Verilog code through prompt engineering techniques ____. Other studies have focused on instruction fine-tuning to adapt LLMs specifically for Verilog code generation, significantly improving the quality and accuracy of generated code ____. Additionally, research has demonstrated the use of LLM-based agents that iteratively improve code quality by integrating feedback from EDA tools ____. In script generation, LLMs have been utilized to automatically create scripts for EDA tools operations and simplify workflows ____. To evaluate the syntax and function correctness of generated codes, researchers have developed open-source datasets ____. However, these datasets currently lack mechanisms to evaluate defect detection capabilities. For chip verification, LLMs have also been employed to generate test stimuli and analyze coverage, demonstrating their utility in comprehensive testing tasks ____. Moreover, researchers have explored LLM as an interactive design assistant to assist preliminary design stages through iterative dialogue with designers ____. 

Overall, these studies underscore the robust capabilities of LLMs in supporting EDA tools across various chip design tasks. In contrast to prior studies, our research investigates the potential of LLM-native approaches ____, employing LLM as an open-source Linting tool to autonomously detect Verilog code defects without relying on EDA tools supporting for the first time.


\subsection{Static Code Analysis}

%静态代码分析是一种在不实际运行代码的情况下，通过预定义的模式或规则检测代码中的语法、编码风格和设计不一致。[How developers engage with static analysis tools in different contexts.]。Linting工具能够辅助验证人员提高缺陷检测效率，其工作原理是对代码的语法、结构、和潜在缺陷进行解析，并通过与既定的规则集匹配，来识别不符合这些规则的潜在问题[Taxonomy of Static Code Analysis Tools]。在硬件设计领域，传统的工具如synopsys的SpyGlass，Cadence的JasperGold和Siemens的Questa Lint，他们通过自定义的编码规则能够检测verilog中潜在的缺陷。然而，这些工具的一个常见问题是它们倾向于产生假阳性报告,报告的代码问题不是实际问题的情况[Why don’t software developers use static analysis tools to find bugs? ]。最近，软件工程的文章【Code Linting Using Language Models】，使用LLM对Java代码进行缺陷分类获得了较好的结果。这项工作启发了我们的思考，能够使用LLM作为Linting工具针对硬件描述语言的缺陷检测，并降低误报的产生。

Static code analysis is a method of detecting syntax, coding style, and design inconsistencies in code through predefined patterns or rules without actually running the code ____. Linting tools can assist verification personnel in improving defect detection efficiency. They work by analyzing the syntax, structure, and potential defects of the code and identifying potential problems that do not comply with these rules by matching them with the established rule set ____. In the field of hardware design, traditional EDA tools such as Synopsys's SpyGlass ____, Cadence's JasperGold ____, and Siemens's Questa Lint ____ can detect potential defects in Verilog through customized coding rules. However, a common problem with these tools is that they tend to generate false positive reports, reporting code issues that actually are not defects ____.  

Recently, Holden et al. ____ uses LLMs to classify Java code defects and achieved good results in the field of software engineering. This work inspired us to think about using LLM as a Linting tool for defect detection of Verilog code and reducing the generation of false positives.

%----------------------------------------------------------------------------------------

\begin{figure}[t]
	\centering
	\includegraphics[width=0.45\textwidth]{picture/overview.pdf} % main2
	\caption{Workflow of Traditional Linting and LLM-based Linting}
	\label{pic1}
	\vspace{-2mm}
\end{figure}