
\documentclass[preprint, 12pt]{elsarticle}
%\documentclass[final,5p,times,twocolumn]{elsarticle}

\usepackage{graphicx}
\usepackage{balance}
\usepackage{pgfplots}
\pgfplotsset{compat=1.18} 
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{multicol}
\usepackage{pifont}
\usepackage{tcolorbox}
\usepackage{listings}
\usepackage{url}
\lstset{
basicstyle=\ttfamily\tiny,
columns=flexible,
breaklines=true
}

\newcommand{\cmark}{\ding{51}}%
\newcommand{\xmark}{\ding{55}}%

\author[udc]{David Soler\corref{cor1}}
\author[udc]{Carlos Dafonte}
\author[uvigo]{Manuel Fernández-Veiga}
\author[uvigo]{Ana Fernández Vilas}
\author[udc]{Francisco J. Nóvoa}
\cortext[cor1]{Corresponding author. Contact: david.soler@udc.es}

\affiliation[udc]{organization={CITIC, Universidade da Coruña},
            city={A Coruña},
            country={Spain}}
\affiliation[uvigo]{organization={atlanTTic, Universidade de Vigo},
            city={Vigo},
            country={Spain}}

\journal{Computers \& Security}

\title{Experimental Analysis of Efficiency of the Messaging Layer Security for Multiple Delivery Services}

\begin{document}
\begin{frontmatter}

\begin{abstract}
Messaging Layer security (MLS) and its underlying Continuous Group Key Agreement (CGKA) protocol allows a group of users to share a cryptographic secret in a dynamic manner, such that the secret is modified in member insertions and deletions. One of the most relevant contributions of MLS is its efficiency, as its communication cost scales logarithmically with the number of members. However, this claim has only been analysed in theoretical models and thus it is unclear how efficient MLS is in real-world scenarios. Furthermore, practical decisions such as the chosen Delivery Service and paradigm can also influence the efficiency and evolution of an MLS group. In this work we analyse MLS from an empirical viewpoint: we provide real-world measurements for metrics such as commit generation and processing times and message sizes under different conditions. In order to obtain these results we have developed a highly configurable environment for empirical evaluations of MLS through the simulation of MLS clients. Among other findings, our results show that computation costs scale linearly in practical scenarios even in the best-case scenario.
\end{abstract}

\begin{highlights}
\item We study the efficiency of the Messaging Layer Security (MLS) protocol in an experimental setting.
\item We provide an implementation of a configurable environment for the empirical evaluation of MLS. 
\item We measure latency, generation and processing times and message sizes for different Delivery Services, paradigms and group states.
\end{highlights}

\begin{keyword}
%% keywords here, in the form: keyword \sep keyword
Continuous Group Key Agreement \sep MLS \sep Delivery Service \sep Network simulation
\sep Decentralised Communications 
\end{keyword}

\end{frontmatter}

\section{Introduction} 
\label{sec:introduction}

Messaging Layer Security (MLS)~\cite{mls} is a recent communications standard for establishing secure messaging groups between a set of users. It is mainly composed by a cryptographic scheme named Continuous Group Key Agreement (CGKA), whose objective is to distribute a shared secret between members of the group. One of the most relevant characteristics of CGKA protocols is its flexibility in group composition: the scheme allows insertions and deletions of members while ensuring the security properties of Forward Secrecy (FS) and Post-Compromise Security (PCS). 

In addition to these security properties CGKA schemes also have a significant focus in maintaining efficiency as the group increases in size. Indeed, MLS employs a version of TreeKEM \cite{treekem} as its underlying CGKA protocol, which structures the group as a binary tree in order to achieve logarithmic complexity in relation to group size. The efficiency of CGKA protocols has been widely analysed in the literature \cite{cost_1, cost_2, bounds} and multiple CGKA variants that attempt to increase efficiency under certain scenarios have been proposed \cite{saik, cmpke, decaf, overlap}. 

However, most contributions to the CGKA literature only address the theoretical aspects of these protocols. While some works perform empirical measurements of their CGKA variants \cite{a_cgka, dec_ack, cost_tree}, they are often limited to small groups and specific scenarios. This prevents the analysis of practical considerations that also affect the development of MLS groups. Specifically, the Authentication and Delivery services defined in the MLS RFC have received very little attention \cite{aa_cgka}, and are usually instantiated as abstract functionalities. The latter is relevant for the execution of the CGKA protocol, as it handles the transmission of messages between members of a group and stores information required to insert new members. The treatment of these services as abstract and efficient obfuscate their influence on the correct functioning and efficiency of the protocol. Thus, the interaction between the underlying CGKA schemes and the real-world instantiation of these services has not been explored.

Furthermore, MLS introduces new elements to CGKA groups whose impact has not been studied in the literature. In particular, MLS defines a method for \textit{External Joins}, through which users can enter a group without requiring invitation. The \textit{KeyPackage} and \textit{GroupInfo} messages are required to add new members to the group, and they need to be stored and made available to users. The \textit{propose-and-commit} paradigm requires the generation, distribution and processing of \textit{proposal messages} that represent an additional overhead.

In this work we address those issues by performing an empirical evaluation of the performance of MLS under multiple different scenarios. We study how performance - mainly commit generation and processing times, as well as message size - is affected by different conditions such as the chosen Delivery Service and paradigm.

To that end we have developed a testbed for experimental evaluations of MLS. Our implementation consists of a simulated MLS client that autonomously joins groups and periodically publishes messages and updates, as well as two different Delivery Services to distribute MLS messages between the clients. The testbed is highly configurable and allows for the deployment of an arbitrary number of simulated clients. We publish our implementation as open-source so that it is available for researchers to perform their own analysis or even create new scenarios.

In summary, our work presents the following contributions:
\begin{enumerate}
    \item A testbed for experimental evaluations of MLS. We provide a Rust implementation\footnote{Available at \url{https://github.com/SDABIS/mls_experimental_analysis}} of a simulated MLS client that can be configured in detail to perform various tests. When executed in parallel, these clients will create MLS groups, add or remove other clients and exchange application messages, according to their parameters. We also implement two different Delivery Services: a centralised MQTT server and a distributed P2P-based publish-subscribe network.
    \item An empirical analysis of the performance of MLS. We study MLS behaviour under multiple conditions: the type of Delivery Service employed, the number and behaviour of users and whether or not some MLS functionalities like External Joins and the \textit{propose-and-commit} paradigm are being employed. We measure the computational cost of generating and processing updates, the size of exchanged messages and the time required to deliver them to all members. Among other findings, our results show that the expected logarithmic complexity of MLS does not hold in practice, even in a best-case scenario.
\end{enumerate}

The rest of the document is organised as follows: Section~\ref{sec:literature} will review related works to provide the context to our contribution. Section~\ref{sec:background} will introduce to the reader the concepts of CGKA and MLS that are relevant for our analysis. In Section~\ref{sec:env} we identify the variables we will measure and the parameters that will impact them. Section~\ref{sec:impl} introduces our implementation of the simulated MLS clients and the Delivery Services and in Section~\ref{sec:measurements} we present our measurements of said environment. In Section \ref{sec:discussion} we discuss our most relevant findings and overall implications of our results. Finally, Section~\ref{sec:conclusion} will conclude this document and discuss future improvements.

\section{Related Work}
\label{sec:literature}

CGKA protocols have been thoroughly defined in the literature~\cite{cgka_analysis, itk, pass_continuous_2020}, exploring the security properties of Forward Security (FS) and Post-Compromise Security (PCS)~\cite{cgka_analysis}. Since one of the main objectives of CGKA protocols is to provide efficient  scaling with the number of users~\cite{bounds}, they usually employ binary trees to represent the state of the group~\cite{art, treekem, ttkem}. As such, CGKA protocols usually aim for logarithmic complexity in adds and removals, although the PCS requirement unavoidably causes its efficiency to degrade under certain conditions \cite{worst-case}. The most popular instantiation of a CGKA protocol is the Messaging Layer Security (MLS), which has recently been standardised as RFC 9420 \cite{mls}. MLS employs TreeKEM \cite{treekem} as its CGKA protocol, and uses the shared cryptographic secret to perform Secure Group Messaging between its members.  

%There are numerous works that attempt to increase the efficiency of CGKA protocols. The variant of TreeKEM proposed in~\cite{ttkem} aims to address a problem introduced by the \textit{propose-and-commit} paradigm of MLS, which degrades efficiency in the case of removals. The works of~\cite{saik} and \cite{saik_2} propose using a server that can forward updates to each member, sending only the information they need to modify their state in order to reduce bandwidth. The work~\cite{cocoa} is a modification of \cite{saik} in which the server is the only party with complete information about the CGKA tree and is able to merge concurrent updates.

The efficiency of CGKA protocols has mostly been discussed in a theoretical framework, without presenting experimental results. The authors of \cite{saik} discuss the bandwidth required to distribute messages to all members of the CGKA group, and propose introducing a server to more efficiently provide each member with the information they require. A similiar approach is taken in \cite{cmpke}, which also optimises the protocol for post-quantum algorithms for public key encryption. The impact of the tree's state in efficiency is taken into account. Other works further develop this analysis to estimate the \textit{communication cost} (i.e., the amount of messages required) of healing the group after a compromise. Communication cost is estimated both for a generic CGKA protocol \cite{cost_1, cost_2, bounds} and for specific schemes \cite{cocoa, qtk, cgka_fa}. The authors of \cite{cost_tree} also analyse the communication cost of the TreeKEM protocol by focusing on the shape of the ratchet tree.

The authors of \cite{discreet_original} propose a Delivery Service that employs Reliable Broadcast and consensus mechanisms to distribute proposals and commits, respectively. They later presented an implementation \cite{discreet}, but without experimental measurements. The CGKA variant introduced in \cite{decaf} is particularly suited for its implementation using a Blockchain as a decentralised Delivery Service, although the work is mainly theoretical and no experimental environment is discussed. Conversely, the authors of \cite{art_bc} do implement a CGKA environment using a blockchain for IoT devices, but employ Asynchronous Ratchet Trees \cite{art}, an outdated version of TreeKEM and thus not compatible with MLS. In \cite{dec_ack} an alternative CGKA protocol that does not employ binary trees is presented and an implementation is provided for a simplified execution environment. 

Experimental analysis of CGKA implementations is limited to works that present an specific CGKA variant such as \cite{a_cgka, dec_ack, treesync}, although their experimental settings are limited: they only consider groups with few members - up to 128 - and do not model user behaviour. In both cases their measurements show how commit generation times increase linearly as the number of users grow. 

\section{Background} 
\label{sec:background}

\subsection{Continuous Group Key Agreement}
\label{sec:cgka}

A \textit{Continuous Group Key Agreement} (CGKA) protocol is a scheme that allows a set of users to establish a common secret. This shared value changes dynamically with every modification of the state of the group, whether it be insertions or eliminations of users. In addition to the shared secret, each member possesses some private information such as a signing key pair linked to an identity credential. Each state of the group is called an \textit{epoch}; whenever a member issues a modification to the state of the group through a \textit{commit message}, a new epoch is created with a different shared secret. Throughout this document, we will refer to the group member who generates a commit as \textit{committer}.

CGKA protocols are designed to resist the leakage of the shared secret, whether it be because of a failure in the implementation or the compromise of a member, whose secrets are stolen~\cite{itk}. As a result, the most relevant security properties a CGKA protocol aims to provide are \textit{Forward Secrecy} (\textit{FS}) and \textit{Post-Compromise Security} (\textit{PCS}) which state that if the shared secret of an epoch is compromised, it should not be possible to obtain any secret information from previous and following epochs.

A commit may add a new member to the group or remove an existing one. Additionally, members can modify their individual state if they believe it has been compromised. This also refreshes the group's state and may modify some of the group's contextual information and parameters. We will refer to this actions as \textit{Add}, \textit{Remove} and \textit{Update}, respectively.

Efficiency is also a main focus of CGKA protocols, aiming to achieve logarithmic complexity in updates to the state of the group~\cite{bounds}. To this end, tree structures in which each user possesses information stored in a leaf node~\cite{art,treekem} are common in the literature. 

\subsection{Messaging Layer Security (MLS)}

MLS uses TreeKEM \cite{treekem} as its underlying CGKA protocol. The group's state is structured as a binary tree in which every node holds a cryptographic key pair. The leaf nodes represent the members and contain other information like their credentials and signature key. The participants only know the secret key of those nodes that are included in their path to the root. The secret contained in the root node is known to all members, and thus it is employed to derive the \textit{shared secret}.

Commits that alter the group's state may modify both the committer's leaf node and the secret key of intermediate nodes in its path to the root. In order to securely transmit these changes to other users, a set of \textit{path secrets} is generated by encrypting the new secrets with some of the tree's public keys, such that all members can recalculate the shared secret.

For the correct functioning of an MLS group, two abstract services are defined \cite{mls_arch}: the Authentication Service (AS) and the Delivery Service (DS). The former is tasked with generating the member's credentials and assisting in validating the identity of other members.  The AS is considered to be an external entity to the protocol: for example, it could be instantiated as the current Public Key Infrastructure, in which X.509 certificates containing a public key are signed by Certificate Authorities that are trusted by default.

\begin{figure}
\centering
\includegraphics[width=\linewidth]{figures/ds.jpg}
\caption{Message flow in MLS through the Delivery Service.}
\label{fig:ds}
\end{figure}

On the other hand, the Delivery Service is tasked with distributing messages and storing relevant information about both groups and users. The flow of information in MLS is shown in Figure \ref{fig:ds}: Whenever group members send a message, it is published to the Delivery Service, which is tasked with forwarding it to the recipients (usually the other group members).  

\subsection{Communication in MLS}

The following message types are defined in MLS \cite{mls}:

\begin{itemize}
    \item Handshake: Messages that apply or propose changes to the group's state. Usually handshake messages are generated by group members, with the exception of \textit{External Joins}, in which non-members insert themselves into the group. By default, handshake messages are encrypted with the group's shared secret. Handshake messages fall into the following categories: 
    \begin{itemize}
        \item Proposal: does not apply a change directly to the group, but instead communicates the intention to do so. 
        \item Commit: contains one or more proposals (not necessarily generated by the committer) and applies them to the group. It also contains the updated \textit{path secrets} that the receivers will employ to update their Ratchet Tree. 
    \end{itemize}
    \item Welcome: Generated by commits that include new members to the group. It contains a copy of the group's Ratchet Tree and any other information that the new user needs in order to participate in the group.
    \item Application: any message exchanged between group members, protected by the group's secret.
\end{itemize} 

These messages are generated by users and distributed to members of the group (in the case of the Welcome message, to the new member) through the Delivery Service. 

In addition to delivering protocol messages, the DS must also store some information generated by users and groups such that it can be accessed by any party on demand. We will refer to this abstract functionality of the DS as \textit{Directory}. There are two types of objects that the Directory must store:

\begin{itemize}
    \item Key Packages: they are generated by users and contain cryptographic information required to insert them into an MLS group, including their credential and capabilities as well as an \textit{Hybrid Public Key Encryption} (HPKE) \cite{hpke} public key. Key Packages are included in Add proposals and cannot be reused.
    \item Group Information (\textit{GroupInfo}): they contain the a group's Ratchet tree and other contextual information that is required for performing \textit{External Joins}. It also contains an HPKE public key whose secret counterpart is derived from the group's shared secret, and thus is known by all members. GroupInfo packages can be generated by any group member and represent its state for an specific epoch.
\end{itemize}

Since MLS messages are encrypted, the DS does not need to be a trusted party. However, we remark that a malicious or compromised DS still has the capability of tracking group compositions, reordering or deleting messages or even deny service to a party. 

\subsection{Group Updates}

\begin{figure*}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/add.jpg}
        \caption{Invitation.}
        \label{fig:new_add}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/join.jpg}
        \caption{External Join.}
        \label{fig:new_join}
    \end{subfigure}
    \caption{Overview of the \textit{Invitation} and \textit{External Join} methods through which new members are added to the MLS group.}
    \label{fig:new}
\end{figure*}

As mentioned, a group's state is modified by commits which can either add or remove members or update their individual state. While the two latter operations are fairly simple, inserting new members into an MLS group requires additional steps. They can either be added through \textit{Invitation} - if a current member inserts them into the group - or \textit{External Join} - if they insert themselves \cite{aa_cgka}. These two methods are represented in Figure \ref{fig:new}.

\paragraph{\textbf{Invitation}}

Figure \ref{fig:new_add} shows the message flow for inviting new users to the group. As a prerequisite, the new user Bob must have uploaded a Key Package created by him to the Delivery Service's Directory. Then, the group member member Alice obtains it and generates an Add proposal that includes the Key Package. When the proposal is committed, Alice employs the HPKE public key contained in Bob's Key Package to encrypt the group's secrets and includes them in a Welcome message directed to Bob, along other contextual information required to participate in the group.

All other members of the group then process Alice's commit. Bob's Key Package also included a \textit{leaf node} which is inserted into the group's TreeKEM after validating his credentials.

\paragraph{\textbf{External Join}}

In contrast to Add proposals, External Joins are initiated by the joiner, who is not a member of the group. The procedure is shown in Figure \ref{fig:new_join}: First, the joiner Bob accesses the group's \textit{GroupInfo}, which was uploaded to the Directory by the group member Alice. Then, he generates a value that will be used to derive the new epoch's shared secret and encrypts it with the group's HPKE public key (contained in the \textit{GroupInfo}) such that it is accessible only to members of the group. Finally, Bob generates a commit with the \textit{Join} proposal - a new proposal type defined by MLS -, which is validated and processed by all members of the group. We remark that an MLS group can specify if External Joins are allowed.

%\subsection{Paradigms}

\section{Empirical evaluation of MLS} 
\label{sec:env}

In this Section we will analyse the most relevant properties of the execution environment in which we will measure the behaviour of MLS using different Delivery Services. We will start by defining the parameters that will configure our testbed. Then, we will introduce the variables that we will measure, whose values will be predictably affected by the parameter configuration.

\subsection{Parameters}
\label{sec:parameters}

The most relevant metric for our experiments is \textit{group size}, that is, the current number of members of the MLS group. It is claimed that MLS' efficiency scales logarithmically with group size \cite{saik, cocoa}, and all of our measurements are is significantly influenced by it. We will also analyse how the other parameters introduced in this Section interact with group size.

In addition to group size, we will measure the influence of the following parameters: 

\subsubsection{Delivery Service}

The Delivery Service can be instantiated as a centralised server that manages the MLS groups and relays messages to its participants. The use of a server help to ensure consistency as it can ensure that all parties receive all messages and in the same order. However, the server also represents a \textit{single point of failure} and may introduce bandwidth limitations, as all messages need to go through a single machine. On the other hand, a distributed network of devices that autonomously transmit and forward messages between them can also serve as a Delivery Service. In addition to the distribution of messages, the distributed network can also serve as Directory by storing KeyPackages and GroupInfo messages. 

\subsubsection{Paradigm}

Users apply modifications to an MLS group by issuing a commit, which updates the shared secret and certain nodes in the Ratchet Tree. This can lead to inefficiencies if multiple commits are generated consecutively, as the updated secrets are needlessly overwritten. Alternatively, a commit can simultaneously apply multiple modifications through the use of proposals. We refer to this two different approaches as \textit{paradigms}.

More specifically, we will distinguish between these paradigms:

\begin{itemize}
    \item \textit{Commit}: Modifications are directly and individually applied to the group by a Commit.
    \item \textit{Propose-and-commit}: A single commit includes and applies any number of previously exchanged proposals, possibly generated by different members. This effectively reduces the amount of commits generated while maintaining the overall behaviour of the group.
\end{itemize}

The \textit{propose-and-commit} paradigm reduces the number of modifications to the Ratchet Tree that are required to perform the same functionality. However, it also introduces an additional overhead: the generation, distribution and processing of proposal messages. In the \textit{propose-and-commit} paradigm, a commit that applies $n$ proposals requires the exchange of $n + 1$ messages: each of the $n$ proposal messages and the commit message itself. This contrasts with the \textit{commit} paradigm, in which every handshake message applies exactly one modification. We unify these results under the following \textit{Average Update cost} ($auc$) metric:

\[ auc = \frac{cc + \sum_{i=0}^{n} cp_i}{n} \]

where $cc$ and $cp_i$ are the costs of the commit and its $i$th proposal, respectively.

We will also consider \textit{External Joins} in our discussion of paradigms. Although External Joins are not incompatible with any of the other two paradigms - as removes and updates can still be either \textit{commit} or \textit{propose-and-commit} - they do represent a different method for adding new members to the group that can be compared with them.

\subsubsection{Ratchet Tree State}

Although the TreeKEM protocol aims to achieve to scale logarithmically as the number of users grow, this is only the ideal case: when all the tree branches, included intermediate nodes, are populated. These branches can be \textit{blanked} by some operations, such as invitations of removals under certain conditions \cite{ttkem}. In the worst case (i.e. whenever all intermediate nodes are blanked), the group is structured as a list, which implies that the scaling becomes linear \cite{itk}.

The amount and location of blanked nodes depends mostly on which users perform the updates. A group reaches its worst possible state if all updates are issued by the same user - the group creator -, as only the nodes in its path to the root will be populated. In contrast, the best state is reached when all members issue an update, without considering removes. This ensures that all intermediate nodes are populated. This can be achieved by only allowing the last user to join to issue updates.

We will model these scenarios by restricting who is able to issue updates: the \textit{First} user for the worst state and the \textit{Last} for the best case. We will compare them to a normal scenario in which updates are performed by \textit{Random} users. 

\subsection{Measurements}
\label{sec:measurements}

We will measure the following values in our executions:

\paragraph{\textbf{Latency}}

In the context of this work, we define an user's \textit{latency} with respect to a commit as "the amount of time between the generation of the commit and the moment in which its changes are applied to the user". Since an MLS group is composed of multiple users, we will measure the \textbf{average latency} and \textbf{max latency} for each commit generated. The latter represents the delay between the generation of a commit and the start of the new epoch for all members.

The time between the generation of a message and its processing is relevant for all messaging applications, but is particularly relevant for handshake messages in MLS: when a member issues a commit, the group remains in an unstable state until all parties have processed the change and thus cannot adequately exchange any other handshake or application messages. 

%Since MLS does not define any mechanism to handle concurrent updates - although numerous works attempt to design alternative CGKA schemes that do - this temporary disagreement over the state of the group can cause problems to its development. In the best case scenario, all users will agree on which update to process and they will discard the other, with the corresponding waste of resources. If there is no method for all users to agree, the group can be divided into irreconcilable states, preventing any communication between parties that have processed a different update.

\paragraph{\textbf{Commit generation and processing times}}

CGKA protocols that employ tree structures, such as MLS, are claimed to have logarithmic complexity in relation to the number of members \cite{saik, cocoa}. These claims refer to the \textit{Communication cost}, that is, the amount of information that needs to be exchanged in order to heal the group. This metric's relation to computational costs is unclear, and thus in this work we analyse both generation and processing time. We will use CPU time to measure both values.

Besides group size, we measure how the choice of paradigm and state of the Ratchet Tree affect generation and processing times.
%We will also analyse how efficiency is affected by the current state of the tree. 

\paragraph{\textbf{Message size}}

Our analysis includes handshake messages - both commits and proposals, using the \textit{Average Update cost} metric - as well as other message types like Welcome and GroupInfo packages. The latter two include the full Ratchet Tree, so their size is expected to scale poorly as the group grows.

This experimental measurement complements the communication cost that has been widely analysed in the literature. Our measurements can provide specific values that can be fed into communication cost calculations such that the obtained results can be applied to real-world scenarios.

\section{Implementation}
\label{sec:impl}

In this Section we will introduce our implementation of the different Delivery Services we will employ in our execution environment. We have developed our implementation in Rust, using the OpenMLS project \cite{openmls} as a baseline and incrementally expanding upon it.

We employ two different Delivery Services, each of them with their corresponding Directory. The first employs a centralised server and forwards messages through the MQTT protocol while the second distributes them through a peer-to-peer network. Their implementations are analysed in subsequent sections. Both are based in a Publish-Subscribe architecture.

Figure \ref{fig:pubsub} shows the handling of topics of a Publish/Subscribe Delivery Service for MLS. Every group has a different topic to which all current members are subscribed. Every user is subscribed to a \textit{welcome} topic through which it receives all Welcome messages directed to them. Additionally, all groups have their own topic that all members are subscribed to, and every handshake and application message of that group is published through it. 

\begin{figure}[!t]
\centering
\includegraphics[width=1\linewidth]{figures/pubsub.jpg}
\caption{Subscription process for new group members.}
\label{fig:pubsub}
\end{figure}

\subsection{MQTT Delivery Service}

MQTT is a protocol for establishing publish/subscribe queues of messages \cite{mqtt}. In this architecture, users can publish messages to different \textit{topics} such that they are received all users that are subscriber to said topic. The transmission of these messages to all subscribers is managed by a centralised server named \textit{MQTT broker}. For our execution environment, we employ the open-source Mosquitto \cite{mosquitto} implementation of a MQTT broker. 

Besides the MQTT broker, the Delivery Service also employs a web server that acts as Directory, with endpoints to store and consume KeyPackages and GroupInfo messages. The latter needs to be updated for each new group epoch, so users aiming to perform an External Join can successfully access the group. Furthermore, this web server also acts as a \textit{signaling server} in which users can register to notify other participants of their existence, such that they can be invited to MLS groups through an Add proposal.

\subsection{GossipSub Delivery Service}

For this Delivery Service we maintain the Publish-Subscribe nature but replace the centralised MQTT server with a distributed architecture. We employ the \textit{GossipSub} protocol \cite{gossipsub} that allows peers to subscribe to different topics; peers share with each other metadata of messages they have received and can request the full message if it is from a topic they are subscribed to. Connections are dynamic and favour other members subscribed to the same topic. 

We also employ a Decentralised Hash Table (DHT) as this Delivery Service's Directory. Each client publishes its KeyPackage as a key-value pair, with the key referencing its user identifier. We limit the involvement of the server to that of \textit{signaling server} as defined for the MQTT Delivery Service.
%Instead of using a centralised Directory as in the MQTT Delivery Service, in this iteration we employ a Decentralised Hash Table.

For our implementation we include Rust's Libp2p \cite{libp2p} into the simulated clients, which provides an implementation for GossipSub and the Kademlia \cite{kademlia} DHT.

\subsection{Client Simulation}

Our testbed is composed of multiple simulated clients that independently participate in MLS groups. They emulate the behaviour of real clients by randomly adding or removing members, updating their individual leaf nodes and sending application messages. 

\begin{figure}[!t]
\centering
\begin{tcolorbox}[colback=white, colframe=black, width=\linewidth]
\begin{multicols}{2}
\begin{lstlisting}
[cgka]
ds = "mqtt"
groups = ["group_1", "group_2"]
external_join = true
join_chance = 0.01
issue_update_chance = 0.2
message_chance = 0.3
scale = false
auth_policy = "Random"
message_length_min = 500
message_length_max = 2000
sleep_millis_min = 20000
sleep_millis_max = 60000
\end{lstlisting}

\columnbreak

\begin{lstlisting}
[paradigm]
paradigm = "propose"
proposals_per_commit = 4
invite_chance = 0.6
remove_chance = 0.1
update_chance = 0.3

[http_server]
url = "http://<ip>:<port>"

[mqtt]
url = "tcp://<ip>:<port>"

[meta]
replicas = 10
\end{lstlisting}
\end{multicols}
\end{tcolorbox}
\caption{Example Client configuration file.}
\label{lst:conf}
\end{figure}

The behaviour of our simulated clients can be specified in detail through configuration files, as shown in Figure \ref{lst:conf}. Among other parameters, it is possible to configure the groups the user will try to join (or create if they do not exist), how often it will attempt to perform an action and with what probability. The configuration file also defines which paradigm to use and the types of actions (Add, Remove, Update, Join) the client is execute, as well as the Delivery Service that will be employed.

\begin{figure}[!t]
\centering
\begin{tcolorbox}[colback=white, colframe=black, width=\linewidth]
\begin{lstlisting}
group_1 8 User_0d4341e0c0f4 Invite User_b3f20ed42c2a 1065 1739176120380282661 5885
group_1 8 User_d13041578e84 Process User_0d4341e0c0f4 1739176120384444036 8599
group_1 8 User_b3f20ed42c2a Welcome User_0d4341e0c0f4 2755 1739176120461981624 1823
\end{lstlisting}
\end{tcolorbox}
\caption{Logs generated by clients.}
\label{lst:log}
\end{figure}

Every action related to the evolution of an MLS group is recorded in a log file. Figure \ref{lst:log} shows the trace of an Invitation, which includes involves the following entries: \textit{Invite}, \textit{Process} and \textit{Welcome}. Each entry records the size of the message, the timestamp at which it was performed and its time cost.

\section{Experimental Results} 
\label{sec:result}

In this section we deploy the environment presented in previous sections and perform empirical evaluations on its performance. 

We have executed all following tests three times with the objective of clearing any potential noise in the measurements. Every figure in this Section shows the average of the results obtained in all executions; we omit the standard deviation as it is not relevant to our scenarios.

\subsection{Latency}
\label{sec:lat}

\begin{figure*}
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/plots/latency_mqtt.pdf}
        \caption{MQTT}
        \label{fig:lat_mqtt}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=1\linewidth]{figures/plots/latency_gossipsub.pdf}
        \caption{GossipSub}
        \label{fig:lat_gossipsub}
    \end{subfigure}
    \caption{Mean and Max Latency for the Delivery Services.}
    \label{fig:cpu_time}
\end{figure*}

Figures \ref{fig:lat_mqtt} and \ref{fig:lat_gossipsub} show the latency for the two Delivery Services. While both experience a significant increase as the number of users grow, the GossipSub DS is noticeably less efficient as its latency more than doubles that of the MQTT DS. Latency also increases more irregularly of GossipSub, with an important increase at 512 group members. However, at higher group sizes the latency grows slower for GossipSub. 

\subsection{Paradigm}
\label{sec:paradigm}

We now compare the \textit{Average Update cost} for the \textit{commit} and \textit{propose-and-commit} paradigms, including multiple amounts of \textit{proposals per commit} for the latter to see how the cost varies as the number of updates increases. We note that our measurements do not include the cost of retrieving information from the Directory such as KeyPackages for Add proposals, as it remains constant regardless of the chosen paradigm. 

\begin{figure*}[t]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/plots/gen_elapsed.pdf}
        \caption{\textit{Commit} and \textit{propose-and-commit} paradigms}
        \label{fig:cpu_gen_para}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/plots/gen_elapsed_welcome_join.pdf}
        \caption{Commits (also including Welcome processing time) and External Joins.}
        \label{fig:cpu_gen_join}
    \end{subfigure}
    \caption{Average Update generation time for different paradigms as the number of users grow.}
    \label{fig:cpu_gen}
\end{figure*}


\begin{figure*}[t]
    \centering
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/plots/processing_elapsed.pdf}
        \caption{Processing time.}
        \label{fig:cpu_proc}
    \end{subfigure}
    \begin{subfigure}{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/plots/sizes.pdf}
        \caption{Message size.}
        \label{fig:cpu_size}
    \end{subfigure}
    \caption{Average Update cost for different paradigms as the number of users grow.}
    \label{fig:cpu_cost}
\end{figure*}

Figures \ref{fig:cpu_gen_para} and \ref{fig:cpu_gen_join} show the Average Update generation time for the two paradigms and for External Joins, respectively. Clearly, the Average Update cost is significantly reduced as the number of proposals increases.

We also note that the time to perform an External Join is much larger to that of inviting new members through Add proposals. In order to understand these differences we highlight that an user performing an External Join must also parse the current state of the group including the full Ratchet Tree, which would explain the poor scaling of External Joins. This operation is also performed in an Invitation setting by the invited user when the Welcome message is processed; when accounting for the processing time of Welcome messages, the two methods have a similar cost (as shown in Figure \ref{fig:cpu_gen_join} by the line labelled \textit{Commit + Welcome}).

Figure \ref{fig:cpu_proc} shows the processing time per Update as the number of users grow. As with generation time, the processing cost is significantly reduced as the number of proposals increases. Processing time is noticeably more stable than generation time, although it experiences significant increases at the powers of 2 as a new layer is added to the Ratchet Tree. It is apparent that both generation and processing times scale mostly linearly with the number of members in the CGKA group, with $R^2$ scores over 0.9 when adjusting for linear regression and around 0.6 for logarithmic regression.

Similarly, Figure \ref{fig:cpu_size} shows the message size per update. Clearly, the correlation between the message size and the number of users is much smaller than in the other metrics. Contrary to the results obtained while measuring processing and generation times, message size is generally bigger as the number of proposals increase. We recall that commit messages also include copies of the proposals it applies; this redundant information increases the cost per update.

\subsection{Other Messages}

\begin{figure}
\centering
\includegraphics[width=\linewidth]{figures/plots/sizes_welcome_join.pdf}
\caption{Message size for Welcome messages and GroupInfo packages.}
\label{fig:size_wel}
\end{figure}

We also evaluate the size of the Welcome messages and GroupInfo packages, which take part in Invitations and External Joins, respectively. Figure \ref{fig:size_wel} shows the obtained results. Since both contain a full copy of the Ratchet Tree, they are significantly larger than any handshake message. Expectedly, their size increases linearly with the number of group members.

\subsection{Ratchet Tree State}

\begin{figure*}[t]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/plots/gen_elapsed_state.pdf}
        \caption{Generation time.}
        \label{fig:state_gen}
    \end{subfigure}
    \begin{subfigure}[b]{0.45\textwidth}
        \centering
        \includegraphics[width=\linewidth]{figures/plots/sizes_state.pdf}
        \caption{Message size.}
        \label{fig:state_size}
    \end{subfigure}
    \caption{Generation time and message size for different states of the group's Ratchet Tree. Processing time is omitted as it is not influenced by this metric.}
    \label{fig:state}
\end{figure*}

Finally, we analyse the impact in performance of the current state if the Ratchet Tree, exemplified by the \textit{First}, \textit{Last} and \textit{Random} scenarios introduced in Section \ref{sec:parameters}. Figure \ref{fig:state} shows the generation time and message size - processing time is omitted as no significant difference was found between the three scenarios. 

As with previous measurements, generation time also scales linearly in all scenarios - this includes \textit{Last} which corresponds to the best possible state of the tree. Message size does show a significant correlation, with \textit{First} increasing much faster than in the other scenarios.

\section{Discussion}
\label{sec:discussion}

\paragraph{\textbf{Comparison with other works}}

\begin{table*}[t]
\centering
\resizebox{\textwidth}{!}{
\begin{tabular}{cccccccccc}
\hline
                      & Protocol     & Perspective  & Group Size     & Time   & Bandwidth  & Tree State & Paradigm & Join   & DS     \\ \hline
\cite{saik}           & CGKA Variant & Theoretical  & N/A            & \xmark & \cmark     & \cmark     & \xmark   & \xmark & \cmark \\ 
\cite{cost_1, cost_2} & CGKA         & Theoretical  & N/A            & \xmark & \cmark     & \cmark     & \xmark   & \xmark & \xmark \\ 
\cite{dec_ack}        & CGKA Variant & Experimental & $\approx$ 128  & \cmark & \cmark     & \xmark     & \xmark   & \xmark & \xmark \\ 
\cite{a_cgka}         & CGKA Variant & Experimental & $\approx$ 128  & \cmark & \xmark     & \xmark     & \xmark   & \xmark & \xmark \\
\cite{discreet}       & MLS          & Theoretical  & N/A            & \xmark & \cmark     & \xmark     & \xmark   & \xmark & \cmark \\ 
Ours                  & MLS          & Experimental & $\approx$ 1000 & \cmark & \cmark     & \cmark     & \cmark   & \cmark & \cmark \\ \hline
    \end{tabular}}
\caption{Comparison between works that analyse CGKA performance and ours. The columns indicate if the works consider the following topics. \textit{CPU}: update generation/processing time. \textit{Bandwidth}: message size and communication cost. \textit{Paradigm}: influence of chosen paradigm. \textit{Tree State}: Influence of the current state of the Ratchet Tree. \textit{Join}: External Joins. \textit{DS}: influence of the Delivery Service.}
\label{tab:comparison}
\end{table*}

Table \ref{tab:comparison} shows a comparison between our work and other works that perform an analysis of performance of CGKA. Our experimental approach allows us to measure CPU time in generating and processing messages and the importance of the Delivery Service in their distribution. When compared with other experimental works, ours has the largest group size and also covers less studied topics such as the influence of paradigm and the current state of the Ratchet Tree.

\paragraph{\textbf{Delivery Service}}

The increased bandwidth of larger groups has a noticeable impact on latency, as the cost of distributing messages between all members increases. The MQTT DS performs significantly better than the GossipSub DS, but the former does not require a centralised server to distribute the messages and thus is more reliable. 

Latency represents the most significant cost in the evolution of MLS groups, as every other generation or processing cost is negligible in comparison. Updates in MLS are necessarily sequential: if two commits are generated from the same epoch, the group enters into an inconsistent state. In order to generate a valid commit, an user must have received and processed all previous valid commits. Thus, latency is a significant bottleneck to group evolution as it represents the minimum amount of time between two valid commits.

Our measurements reach up to 2 seconds of maximum latency in which the group is in an inconsistent state; while for most applications this span is too short to be noticed, it is something that must be taken into account for situations that require strict synchronisation.

\paragraph{\textbf{Message cost}}

Generation and processing times are comparable and represent a small cost in the order of milliseconds. Both experience noticeable increases when a new layer is added to the Ratchet Tree, that is, when group size reaches the next power of 2. In practice, both generation and processing times increase linearly with the amount of users in the group, which contradicts the theoretical assumptions that the protocol complexity is logarithmic. Notably, this trend is maintained even in the best-case scenario where the minimum amount of intermediate nodes are blanked. When compared to latency, with generation and processing times represent a negligible cost.

Welcome messages and GroupInfo packages are significantly costlier to process - as shown in Figure \ref{fig:cpu_gen_join} - than normal commits. Fortunately, they only need to be processed once in order to access a group. This cost difference is due to their size as they both contain the full Ratchet Tree, which needs to be parsed by the receiving party. In contrast, the size of handshake messages is less influenced by group size and is mostly determined by the state of the Ratchet Tree. Generation time is also significantly affected. Even though these two metrics are slightly correlated they present significant differences and thus should be analysed separately. Our results show that groups in which only a small number of users generate updates are less efficient.

\paragraph{\textbf{Impact of paradigm}}

The \textit{propose-and-commit} paradigm also significantly affects performance: the cost of generating and processing proposal messages is negligible compared to the cost of applying an update to the group. As shown, more proposals per update increase the efficiency of the protocol, but we remark that such amount of modifications to a group applied at once would be rare in a real setting, only possible in a highly unstable group. The size of handshake messages is less affected by the amount of group members and the paradigm, as it is mostly determined by the current state of the Ratchet Tree. 

External Joins combine the operations of generating a commit and processing a Welcome message, in the sense that the joiner needs to parse the full Ratchet Tree in order to join. When taking these two operations into account, the cost of an Invitation is similar to that of an External Join. 

\section{Conclusion and Future Work}
\label{sec:conclusion}

In this work we have analysed the performance of MLS in an empirical setting. We analyse the protocol under different parameters such as Delivery Service, chosen paradigm or state of the Ratchet Tree. Our results show that theoretical claims of logarithmic complexity in communication cost do not necessarily manifest in practice.

Our work also demonstrates the relevance of practical considerations in the performance of MLS, as opposed to theoretical analysis. We have found that the most significant time cost - by multiple orders of magnitude - is message distribution through the Delivery Service. Furthermore, the messages that introduce higher workload are Welcome and GroupInfo messages, as they contain the full Ratchet Tree. To the extent of our knowledge, no other work has attempted to increase the efficiency of these operations.

We also publish our execution environment as open source, which includes a configurable simulated MLS client and two different Delivery Services. We hope that it can help other researchers to perform their own simulations and that it can serve as a baseline for more complex simulation environments.

We plan on continuing to study the applicability of concepts defined specifically in MLS - such as the \textit{propose-and-commit} paradigm or External Joins \cite{aa_cgka} - to general definitions of CGKA and their impact on the security properties and efficiency of these schemes.

\section*{Declaration of competing interest}

The authors declare that they have no known competing financial interests or 
personal relationships that could have appeared to influence the work reported 
in this paper.

\section*{Acknowledgement}

D.S. acknowledges support from Xunta de Galicia and the European Union 
(European Social Fund - ESF) scholarship [ED481A-2023-219].

This work is part of the project TED2021-130369B-C31 and TED2021-130492B-C21
funded by MCIN/AEI/10.13039/501100011033 and by “ERDF A way of making Europe”.

\bibliographystyle{elsarticle-num} 
\bibliography{main}

\end{document}